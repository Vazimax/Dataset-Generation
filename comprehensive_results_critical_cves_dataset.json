{
  "dataset_name": "Critical CVEs Dataset",
  "total_samples": 10,
  "overall_metrics": {
    "overall_detection_rate": 0.8666666666666667,
    "tools_tested": 6,
    "total_detections": 52,
    "average_confidence": 0.3941666666666667,
    "average_detection_time": 0.583151113986969
  },
  "tool_performance": {
    "cppcheck": {
      "detection_rate": 0.2,
      "average_confidence": 0.04,
      "average_detection_time": 0.007853865623474121,
      "total_detections": 2,
      "total_samples": 10,
      "error_rate": 0.0
    },
    "clang": {
      "detection_rate": 1.0,
      "average_confidence": 0.3,
      "average_detection_time": 0.021563911437988283,
      "total_detections": 10,
      "total_samples": 10,
      "error_rate": 0.0
    },
    "gcc": {
      "detection_rate": 1.0,
      "average_confidence": 0.3,
      "average_detection_time": 0.02314620018005371,
      "total_detections": 10,
      "total_samples": 10,
      "error_rate": 0.0
    },
    "flawfinder": {
      "detection_rate": 1.0,
      "average_confidence": 0.425,
      "average_detection_time": 0.030015110969543457,
      "total_detections": 10,
      "total_samples": 10,
      "error_rate": 0.0
    },
    "bandit": {
      "detection_rate": 1.0,
      "average_confidence": 0.5,
      "average_detection_time": 0.08689250946044921,
      "total_detections": 10,
      "total_samples": 10,
      "error_rate": 0.0
    },
    "semgrep": {
      "detection_rate": 1.0,
      "average_confidence": 0.8,
      "average_detection_time": 3.3294350862503053,
      "total_detections": 10,
      "total_samples": 10,
      "error_rate": 0.0
    }
  },
  "timestamp": "2025-09-02T15:52:43.762442",
  "detection_results": [
    {
      "cve_id": "CVE-2016-1621",
      "tool_name": "Cppcheck",
      "detected": false,
      "confidence": 0.0,
      "detection_time": 0.01016998291015625,
      "tool_output": "Checking /var/folders/ql/btm7z5tx32ddpsky8z3bz4_r0000gn/T/tmpeezasweg.c ...\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<results version=\"2\">\n    <cppcheck version=\"2.18.0\"/>\n    <errors>\n        <error id=\"syntaxError\" severity=\"error\" msg=\"syntax error\" verbose=\"syntax error\" file0=\"/var/folders/ql/btm7z5tx32ddpsky8z3bz4_r0000gn/T/tmpeezasweg.c\">\n            <location file=\"/var/folders/ql/btm7z5tx32ddpsky8z3bz4_r0000gn/T/tmpeezasweg.c\" line=\"1\" column=\"1311\"/>\n        </error>\n        <error id=\"checkersReport\" severity=\"information\" msg=\"Active checkers: There was critical errors (use --checkers-report=&lt;filename&gt; to see details)\" verbose=\"Active checkers: There was critical errors (use --checkers-report=&lt;filename&gt; to see details)\"/>\n    </errors>\n</results>\n",
      "error_message": null
    },
    {
      "cve_id": "CVE-2020-14954",
      "tool_name": "Cppcheck",
      "detected": true,
      "confidence": 0.2,
      "detection_time": 0.006804943084716797,
      "tool_output": "Checking /var/folders/ql/btm7z5tx32ddpsky8z3bz4_r0000gn/T/tmp1atn60h5.c ...\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<results version=\"2\">\n    <cppcheck version=\"2.18.0\"/>\n    <errors>\n        <error id=\"syntaxError\" severity=\"error\" msg=\"syntax error: &quot;ifdef&quot; .. if\" verbose=\"syntax error: &quot;ifdef&quot; .. if\" file0=\"/var/folders/ql/btm7z5tx32ddpsky8z3bz4_r0000gn/T/tmp1atn60h5.c\">\n            <location file=\"/var/folders/ql/btm7z5tx32ddpsky8z3bz4_r0000gn/T/tmp1atn60h5.c\" line=\"1\" column=\"1665\"/>\n        </error>\n        <error id=\"checkersReport\" severity=\"information\" msg=\"Active checkers: There was critical errors (use --checkers-report=&lt;filename&gt; to see details)\" verbose=\"Active checkers: There was critical errors (use --checkers-report=&lt;filename&gt; to see details)\"/>\n    </errors>\n</results>\n",
      "error_message": null
    },
    {
      "cve_id": "CVE-2020-15474",
      "tool_name": "Cppcheck",
      "detected": false,
      "confidence": 0.0,
      "detection_time": 0.007784843444824219,
      "tool_output": "Checking /var/folders/ql/btm7z5tx32ddpsky8z3bz4_r0000gn/T/tmpty3a0cu4.c ...\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<results version=\"2\">\n    <cppcheck version=\"2.18.0\"/>\n    <errors>\n        <error id=\"syntaxError\" severity=\"error\" msg=\"syntax error\" verbose=\"syntax error\" file0=\"/var/folders/ql/btm7z5tx32ddpsky8z3bz4_r0000gn/T/tmpty3a0cu4.c\">\n            <location file=\"/var/folders/ql/btm7z5tx32ddpsky8z3bz4_r0000gn/T/tmpty3a0cu4.c\" line=\"1\" column=\"561\"/>\n        </error>\n        <error id=\"checkersReport\" severity=\"information\" msg=\"Active checkers: There was critical errors (use --checkers-report=&lt;filename&gt; to see details)\" verbose=\"Active checkers: There was critical errors (use --checkers-report=&lt;filename&gt; to see details)\"/>\n    </errors>\n</results>\n",
      "error_message": null
    },
    {
      "cve_id": "CVE-2017-15385",
      "tool_name": "Cppcheck",
      "detected": false,
      "confidence": 0.0,
      "detection_time": 0.0075190067291259766,
      "tool_output": "Checking /var/folders/ql/btm7z5tx32ddpsky8z3bz4_r0000gn/T/tmpourr8zfr.c ...\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<results version=\"2\">\n    <cppcheck version=\"2.18.0\"/>\n    <errors>\n        <error id=\"syntaxError\" severity=\"error\" msg=\"syntax error\" verbose=\"syntax error\" file0=\"/var/folders/ql/btm7z5tx32ddpsky8z3bz4_r0000gn/T/tmpourr8zfr.c\">\n            <location file=\"/var/folders/ql/btm7z5tx32ddpsky8z3bz4_r0000gn/T/tmpourr8zfr.c\" line=\"1\" column=\"1419\"/>\n        </error>\n        <error id=\"checkersReport\" severity=\"information\" msg=\"Active checkers: There was critical errors (use --checkers-report=&lt;filename&gt; to see details)\" verbose=\"Active checkers: There was critical errors (use --checkers-report=&lt;filename&gt; to see details)\"/>\n    </errors>\n</results>\n",
      "error_message": null
    },
    {
      "cve_id": "CVE-2019-19275",
      "tool_name": "Cppcheck",
      "detected": false,
      "confidence": 0.0,
      "detection_time": 0.007530927658081055,
      "tool_output": "Checking /var/folders/ql/btm7z5tx32ddpsky8z3bz4_r0000gn/T/tmp8fpydqdq.c ...\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<results version=\"2\">\n    <cppcheck version=\"2.18.0\"/>\n    <errors>\n        <error id=\"syntaxError\" severity=\"error\" msg=\"syntax error\" verbose=\"syntax error\" file0=\"/var/folders/ql/btm7z5tx32ddpsky8z3bz4_r0000gn/T/tmp8fpydqdq.c\">\n            <location file=\"/var/folders/ql/btm7z5tx32ddpsky8z3bz4_r0000gn/T/tmp8fpydqdq.c\" line=\"1\" column=\"1646\"/>\n        </error>\n        <error id=\"checkersReport\" severity=\"information\" msg=\"Active checkers: There was critical errors (use --checkers-report=&lt;filename&gt; to see details)\" verbose=\"Active checkers: There was critical errors (use --checkers-report=&lt;filename&gt; to see details)\"/>\n    </errors>\n</results>\n",
      "error_message": null
    },
    {
      "cve_id": "CVE-2019-19481",
      "tool_name": "Cppcheck",
      "detected": false,
      "confidence": 0.0,
      "detection_time": 0.007257223129272461,
      "tool_output": "Checking /var/folders/ql/btm7z5tx32ddpsky8z3bz4_r0000gn/T/tmp1rg24afo.c ...\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<results version=\"2\">\n    <cppcheck version=\"2.18.0\"/>\n    <errors>\n        <error id=\"syntaxError\" severity=\"error\" msg=\"syntax error\" verbose=\"syntax error\" file0=\"/var/folders/ql/btm7z5tx32ddpsky8z3bz4_r0000gn/T/tmp1rg24afo.c\">\n            <location file=\"/var/folders/ql/btm7z5tx32ddpsky8z3bz4_r0000gn/T/tmp1rg24afo.c\" line=\"1\" column=\"1566\"/>\n        </error>\n        <error id=\"checkersReport\" severity=\"information\" msg=\"Active checkers: There was critical errors (use --checkers-report=&lt;filename&gt; to see details)\" verbose=\"Active checkers: There was critical errors (use --checkers-report=&lt;filename&gt; to see details)\"/>\n    </errors>\n</results>\n",
      "error_message": null
    },
    {
      "cve_id": "CVE-2019-13308",
      "tool_name": "Cppcheck",
      "detected": false,
      "confidence": 0.0,
      "detection_time": 0.006989955902099609,
      "tool_output": "Checking /var/folders/ql/btm7z5tx32ddpsky8z3bz4_r0000gn/T/tmp6zhgt1dv.c ...\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<results version=\"2\">\n    <cppcheck version=\"2.18.0\"/>\n    <errors>\n        <error id=\"syntaxError\" severity=\"error\" msg=\"syntax error\" verbose=\"syntax error\" file0=\"/var/folders/ql/btm7z5tx32ddpsky8z3bz4_r0000gn/T/tmp6zhgt1dv.c\">\n            <location file=\"/var/folders/ql/btm7z5tx32ddpsky8z3bz4_r0000gn/T/tmp6zhgt1dv.c\" line=\"1\" column=\"212\"/>\n        </error>\n        <error id=\"checkersReport\" severity=\"information\" msg=\"Active checkers: There was critical errors (use --checkers-report=&lt;filename&gt; to see details)\" verbose=\"Active checkers: There was critical errors (use --checkers-report=&lt;filename&gt; to see details)\"/>\n    </errors>\n</results>\n",
      "error_message": null
    },
    {
      "cve_id": "CVE-2018-1999011",
      "tool_name": "Cppcheck",
      "detected": false,
      "confidence": 0.0,
      "detection_time": 0.007434844970703125,
      "tool_output": "Checking /var/folders/ql/btm7z5tx32ddpsky8z3bz4_r0000gn/T/tmpujeidqvn.c ...\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<results version=\"2\">\n    <cppcheck version=\"2.18.0\"/>\n    <errors>\n        <error id=\"syntaxError\" severity=\"error\" msg=\"syntax error\" verbose=\"syntax error\" file0=\"/var/folders/ql/btm7z5tx32ddpsky8z3bz4_r0000gn/T/tmpujeidqvn.c\">\n            <location file=\"/var/folders/ql/btm7z5tx32ddpsky8z3bz4_r0000gn/T/tmpujeidqvn.c\" line=\"1\" column=\"500\"/>\n        </error>\n        <error id=\"checkersReport\" severity=\"information\" msg=\"Active checkers: There was critical errors (use --checkers-report=&lt;filename&gt; to see details)\" verbose=\"Active checkers: There was critical errors (use --checkers-report=&lt;filename&gt; to see details)\"/>\n    </errors>\n</results>\n",
      "error_message": null
    },
    {
      "cve_id": "CVE-2017-15385",
      "tool_name": "Cppcheck",
      "detected": false,
      "confidence": 0.0,
      "detection_time": 0.00683283805847168,
      "tool_output": "Checking /var/folders/ql/btm7z5tx32ddpsky8z3bz4_r0000gn/T/tmphp41svac.c ...\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<results version=\"2\">\n    <cppcheck version=\"2.18.0\"/>\n    <errors>\n        <error id=\"syntaxError\" severity=\"error\" msg=\"syntax error\" verbose=\"syntax error\" file0=\"/var/folders/ql/btm7z5tx32ddpsky8z3bz4_r0000gn/T/tmphp41svac.c\">\n            <location file=\"/var/folders/ql/btm7z5tx32ddpsky8z3bz4_r0000gn/T/tmphp41svac.c\" line=\"1\" column=\"1419\"/>\n        </error>\n        <error id=\"checkersReport\" severity=\"information\" msg=\"Active checkers: There was critical errors (use --checkers-report=&lt;filename&gt; to see details)\" verbose=\"Active checkers: There was critical errors (use --checkers-report=&lt;filename&gt; to see details)\"/>\n    </errors>\n</results>\n",
      "error_message": null
    },
    {
      "cve_id": "CVE-2019-19244",
      "tool_name": "Cppcheck",
      "detected": true,
      "confidence": 0.2,
      "detection_time": 0.010214090347290039,
      "tool_output": "Checking /var/folders/ql/btm7z5tx32ddpsky8z3bz4_r0000gn/T/tmpkrkemrwg.c ...\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<results version=\"2\">\n    <cppcheck version=\"2.18.0\"/>\n    <errors>\n        <error id=\"syntaxError\" severity=\"error\" msg=\"syntax error: &quot;if&quot; .. if\" verbose=\"syntax error: &quot;if&quot; .. if\" file0=\"/var/folders/ql/btm7z5tx32ddpsky8z3bz4_r0000gn/T/tmpkrkemrwg.c\">\n            <location file=\"/var/folders/ql/btm7z5tx32ddpsky8z3bz4_r0000gn/T/tmpkrkemrwg.c\" line=\"1\" column=\"1659\"/>\n        </error>\n        <error id=\"checkersReport\" severity=\"information\" msg=\"Active checkers: There was critical errors (use --checkers-report=&lt;filename&gt; to see details)\" verbose=\"Active checkers: There was critical errors (use --checkers-report=&lt;filename&gt; to see details)\"/>\n    </errors>\n</results>\n",
      "error_message": null
    },
    {
      "cve_id": "CVE-2016-1621",
      "tool_name": "Clang Static Analyzer",
      "detected": true,
      "confidence": 0.25,
      "detection_time": 0.033325910568237305,
      "tool_output": "/var/folders/ql/btm7z5tx32ddpsky8z3bz4_r0000gn/T/tmptdj0ys3f.c:1:1: error: unknown type name 'CWE'\n    1 | CWE-119 int main ( int argc , char * * argv ) { int frame_cnt = 0 ; FILE * outfile = NULL ; vpx_codec_ctx_t codec ; const VpxInterface * decoder = NULL ; VpxVideoReader * reader = NULL ; const VpxVideoInfo * info = NULL ; int n = 0 ; int m = 0 ; int is_range = 0 ; char * nptr = NULL ; exec_name = argv [ 0 ] ; if ( argc != 4 ) die ( \"Invalid<S2SV_blank>number<S2SV_blank>of<S2SV_blank>arguments.\" ) ; reader = vpx_video_reader_open ( argv [ 1 ] ) ; if ( ! reader ) die ( \"Failed<S2SV_blank>to<S2SV_blank>open<S2SV_blank>%s<S2SV_blank>for<S2SV_blank>reading.\" , argv [ 1 ] ) ; if ( ! ( outfile = fopen ( argv [ 2 ] , \"wb\" ) ) ) die ( \"Failed<S2SV_blank>to<S2SV_blank>open<S2SV_blank>%s<S2SV_blank>for<S2SV_blank>writing.\" , argv [ 2 ] ) ; n = strtol ( argv [ 3 ] , & nptr , 0 ) ; m = strtol ( nptr + 1 , NULL , 0 ) ; is_range = ( * nptr == '-' ) ; if ( ! n || ! m || ( * nptr != '-' && * nptr != '/' ) ) die ( \"Couldn\\'t<S2SV_blank>parse<S2SV_blank>pattern<S2SV_blank>%s.\\\\n\" , argv [ 3 ] ) ; info = vpx_video_reader_get_info ( reader ) ; decoder = get_vpx_decoder_by_fourcc ( info -> codec_fourcc ) ; if ( ! decoder ) die ( \"Unknown<S2SV_blank>input<S2SV_blank>codec.\" ) ; <S2SV_StartBug> printf ( \"Using<S2SV_blank>%s\\\\n\" , vpx_codec_iface_name ( decoder -> interface ( ) ) ) ; <S2SV_EndBug> <S2SV_StartBug> if ( vpx_codec_dec_init ( & codec , decoder -> interface ( ) , NULL , 0 ) ) <S2SV_EndBug> die_codec ( & codec , \"Failed<S2SV_blank>to<S2SV_blank>initialize<S2SV_blank>decoder.\" ) ; while ( vpx_video_reader_read_frame ( reader ) ) { vpx_codec_iter_t iter = NULL ; vpx_image_t * img = NULL ; size_t frame_size = 0 ; int skip ; const unsigned char * frame = vpx_video_reader_get_frame ( reader , & frame_size ) ; if ( vpx_codec_decode ( & codec , frame , ( unsigned int ) frame_size , NULL , 0 ) ) die_codec ( & codec , \"Failed<S2SV_blank>to<S2SV_blank>decode<S2SV_blank>frame.\" ) ; ++ frame_cnt ; skip = ( is_range && frame_cnt >= n && frame_cnt <= m ) || ( ! is_range && m - ( frame_cnt - 1 ) % m <= n ) ; if ( ! skip ) { putc ( '.' , stdout ) ; while ( ( img = vpx_codec_get_frame ( & codec , & iter ) ) != NULL ) vpx_img_write ( img , outfile ) ; } else { putc ( 'X' , stdout ) ; } fflush ( stdout ) ; } printf ( \"Processed<S2SV_blank>%d<S2SV_blank>frames.\\\\n\" , frame_cnt ) ; if ( vpx_codec_destroy ( & codec ) ) die_codec ( & codec , \"Failed<S2SV_blank>to<S2SV_blank>destroy<S2SV_blank>codec.\" ) ; printf ( \"Play:<S2SV_blank>ffplay<S2SV_blank>-f<S2SV_blank>rawvideo<S2SV_blank>-pix_fmt<S2SV_blank>yuv420p<S2SV_blank>-s<S2SV_blank>%dx%d<S2SV_blank>%s\\\\n\" , info -> frame_width , info -> frame_height , argv [ 2 ] ) ; vpx_video_reader_close ( reader ) ; fclose ( outfile ) ; return EXIT_SUCCESS ; }\n      | ^\n/var/folders/ql/btm7z5tx32ddpsky8z3bz4_r0000gn/T/tmptdj0ys3f.c:1:4: error: expected identifier or '('\n    1 | CWE-119 int main ( int argc , char * * argv ) { int frame_cnt = 0 ; FILE * outfile = NULL ; vpx_codec_ctx_t codec ; const VpxInterface * decoder = NULL ; VpxVideoReader * reader = NULL ; const VpxVideoInfo * info = NULL ; int n = 0 ; int m = 0 ; int is_range = 0 ; char * nptr = NULL ; exec_name = argv [ 0 ] ; if ( argc != 4 ) die ( \"Invalid<S2SV_blank>number<S2SV_blank>of<S2SV_blank>arguments.\" ) ; reader = vpx_video_reader_open ( argv [ 1 ] ) ; if ( ! reader ) die ( \"Failed<S2SV_blank>to<S2SV_blank>open<S2SV_blank>%s<S2SV_blank>for<S2SV_blank>reading.\" , argv [ 1 ] ) ; if ( ! ( outfile = fopen ( argv [ 2 ] , \"wb\" ) ) ) die ( \"Failed<S2SV_blank>to<S2SV_blank>open<S2SV_blank>%s<S2SV_blank>for<S2SV_blank>writing.\" , argv [ 2 ] ) ; n = strtol ( argv [ 3 ] , & nptr , 0 ) ; m = strtol ( nptr + 1 , NULL , 0 ) ; is_range = ( * nptr == '-' ) ; if ( ! n || ! m || ( * nptr != '-' && * nptr != '/' ) ) die ( \"Couldn\\'t<S2SV_blank>parse<S2SV_blank>pattern<S2SV_blank>%s.\\\\n\" , argv [ 3 ] ) ; info = vpx_video_reader_get_info ( reader ) ; decoder = get_vpx_decoder_by_fourcc ( info -> codec_fourcc ) ; if ( ! decoder ) die ( \"Unknown<S2SV_blank>input<S2SV_blank>codec.\" ) ; <S2SV_StartBug> printf ( \"Using<S2SV_blank>%s\\\\n\" , vpx_codec_iface_name ( decoder -> interface ( ) ) ) ; <S2SV_EndBug> <S2SV_StartBug> if ( vpx_codec_dec_init ( & codec , decoder -> interface ( ) , NULL , 0 ) ) <S2SV_EndBug> die_codec ( & codec , \"Failed<S2SV_blank>to<S2SV_blank>initialize<S2SV_blank>decoder.\" ) ; while ( vpx_video_reader_read_frame ( reader ) ) { vpx_codec_iter_t iter = NULL ; vpx_image_t * img = NULL ; size_t frame_size = 0 ; int skip ; const unsigned char * frame = vpx_video_reader_get_frame ( reader , & frame_size ) ; if ( vpx_codec_decode ( & codec , frame , ( unsigned int ) frame_size , NULL , 0 ) ) die_codec ( & codec , \"Failed<S2SV_blank>to<S2SV_blank>decode<S2SV_blank>frame.\" ) ; ++ frame_cnt ; skip = ( is_range && frame_cnt >= n && frame_cnt <= m ) || ( ! is_range && m - ( frame_cnt - 1 ) % m <= n ) ; if ( ! skip ) { putc ( '.' , stdout ) ; while ( ( img = vpx_codec_get_frame ( & codec , & iter ) ) != NULL ) vpx_img_write ( img , outfile ) ; } else { putc ( 'X' , stdout ) ; } fflush ( stdout ) ; } printf ( \"Processed<S2SV_blank>%d<S2SV_blank>frames.\\\\n\" , frame_cnt ) ; if ( vpx_codec_destroy ( & codec ) ) die_codec ( & codec , \"Failed<S2SV_blank>to<S2SV_blank>destroy<S2SV_blank>codec.\" ) ; printf ( \"Play:<S2SV_blank>ffplay<S2SV_blank>-f<S2SV_blank>rawvideo<S2SV_blank>-pix_fmt<S2SV_blank>yuv420p<S2SV_blank>-s<S2SV_blank>%dx%d<S2SV_blank>%s\\\\n\" , info -> frame_width , info -> frame_height , argv [ 2 ] ) ; vpx_video_reader_close ( reader ) ; fclose ( outfile ) ; return EXIT_SUCCESS ; }\n      |    ^\n2 errors generated.\n",
      "error_message": null
    },
    {
      "cve_id": "CVE-2020-14954",
      "tool_name": "Clang Static Analyzer",
      "detected": true,
      "confidence": 0.25,
      "detection_time": 0.021926164627075195,
      "tool_output": "/var/folders/ql/btm7z5tx32ddpsky8z3bz4_r0000gn/T/tmphw7k7v49.c:1:1: error: unknown type name 'CWE'\n    1 | CWE-74 int nntp_open_connection ( struct NntpAccountData * adata ) { struct Connection * conn = adata -> conn ; char buf [ 256 ] ; int cap ; bool posting = false , auth = true ; if ( adata -> status == NNTP_OK ) return 0 ; if ( adata -> status == NNTP_BYE ) return - 1 ; adata -> status = NNTP_NONE ; if ( mutt_socket_open ( conn ) < 0 ) return - 1 ; if ( mutt_socket_readln ( buf , sizeof ( buf ) , conn ) < 0 ) return nntp_connect_error ( adata ) ; if ( mutt_str_startswith ( buf , \"200\" , CASE_MATCH ) ) posting = true ; else if ( ! mutt_str_startswith ( buf , \"201\" , CASE_MATCH ) ) { mutt_socket_close ( conn ) ; mutt_str_remove_trailing_ws ( buf ) ; mutt_error ( \"%s\" , buf ) ; return - 1 ; } cap = nntp_capabilities ( adata ) ; if ( cap < 0 ) return - 1 ; if ( cap > 0 ) { if ( ( mutt_socket_send ( conn , \"MODE<S2SV_blank>READER\\\\r\\\\n\" ) < 0 ) || ( mutt_socket_readln ( buf , sizeof ( buf ) , conn ) < 0 ) ) { return nntp_connect_error ( adata ) ; } if ( mutt_str_startswith ( buf , \"200\" , CASE_MATCH ) ) posting = true ; else if ( mutt_str_startswith ( buf , \"201\" , CASE_MATCH ) ) posting = false ; else if ( adata -> hasCAPABILITIES ) { mutt_socket_close ( conn ) ; mutt_error ( _ ( \"Could<S2SV_blank>not<S2SV_blank>switch<S2SV_blank>to<S2SV_blank>reader<S2SV_blank>mode\" ) ) ; return - 1 ; } if ( adata -> hasCAPABILITIES ) { cap = nntp_capabilities ( adata ) ; if ( cap < 0 ) return - 1 ; } } mutt_message ( _ ( \"Connected<S2SV_blank>to<S2SV_blank>%s.<S2SV_blank>%s\" ) , conn -> account . host , posting ? _ ( \"Posting<S2SV_blank>is<S2SV_blank>ok\" ) : _ ( \"Posting<S2SV_blank>is<S2SV_blank>NOT<S2SV_blank>ok\" ) ) ; mutt_sleep ( 1 ) ; # ifdef USE_SSL if ( ( adata -> use_tls != 1 ) && ( adata -> hasSTARTTLS || C_SslForceTls ) ) { if ( adata -> use_tls == 0 ) { adata -> use_tls = C_SslForceTls || query_quadoption ( C_SslStarttls , _ ( \"Secure<S2SV_blank>connection<S2SV_blank>with<S2SV_blank>TLS?\" ) ) == MUTT_YES ? 2 : 1 ; } if ( adata -> use_tls == 2 ) { if ( ( mutt_socket_send ( conn , \"STARTTLS\\\\r\\\\n\" ) < 0 ) || ( mutt_socket_readln ( buf , sizeof ( buf ) , conn ) < 0 ) ) { return nntp_connect_error ( adata ) ; <S2SV_StartBug> } <S2SV_EndBug> if ( ! mutt_str_startswith ( buf , \"382\" , CASE_MATCH ) ) { adata -> use_tls = 0 ; mutt_error ( \"STARTTLS:<S2SV_blank>%s\" , buf ) ; } else if ( mutt_ssl_starttls ( conn ) ) { adata -> use_tls = 0 ; adata -> status = NNTP_NONE ; mutt_socket_close ( adata -> conn ) ; mutt_error ( _ ( \"Could<S2SV_blank>not<S2SV_blank>negotiate<S2SV_blank>TLS<S2SV_blank>connection\" ) ) ; return - 1 ; } else { cap = nntp_capabilities ( adata ) ; if ( cap < 0 ) return - 1 ; } } } # endif if ( conn -> account . flags & MUTT_ACCT_USER ) { if ( ! conn -> account . user [ 0 ] ) auth = false ; } else { if ( ( mutt_socket_send ( conn , \"STAT\\\\r\\\\n\" ) < 0 ) || ( mutt_socket_readln ( buf , sizeof ( buf ) , conn ) < 0 ) ) { return nntp_connect_error ( adata ) ; } if ( ! mutt_str_startswith ( buf , \"480\" , CASE_MATCH ) ) auth = false ; } if ( auth && ( nntp_auth ( adata ) < 0 ) ) return - 1 ; if ( adata -> hasCAPABILITIES && ( auth || ( cap > 0 ) ) ) { cap = nntp_capabilities ( adata ) ; if ( cap < 0 ) return - 1 ; if ( cap > 0 ) { mutt_socket_close ( conn ) ; mutt_error ( _ ( \"Could<S2SV_blank>not<S2SV_blank>switch<S2SV_blank>to<S2SV_blank>reader<S2SV_blank>mode\" ) ) ; return - 1 ; } } if ( nntp_attempt_features ( adata ) < 0 ) return - 1 ; adata -> status = NNTP_OK ; return 0 ; }\n      | ^\n/var/folders/ql/btm7z5tx32ddpsky8z3bz4_r0000gn/T/tmphw7k7v49.c:1:4: error: expected identifier or '('\n    1 | CWE-74 int nntp_open_connection ( struct NntpAccountData * adata ) { struct Connection * conn = adata -> conn ; char buf [ 256 ] ; int cap ; bool posting = false , auth = true ; if ( adata -> status == NNTP_OK ) return 0 ; if ( adata -> status == NNTP_BYE ) return - 1 ; adata -> status = NNTP_NONE ; if ( mutt_socket_open ( conn ) < 0 ) return - 1 ; if ( mutt_socket_readln ( buf , sizeof ( buf ) , conn ) < 0 ) return nntp_connect_error ( adata ) ; if ( mutt_str_startswith ( buf , \"200\" , CASE_MATCH ) ) posting = true ; else if ( ! mutt_str_startswith ( buf , \"201\" , CASE_MATCH ) ) { mutt_socket_close ( conn ) ; mutt_str_remove_trailing_ws ( buf ) ; mutt_error ( \"%s\" , buf ) ; return - 1 ; } cap = nntp_capabilities ( adata ) ; if ( cap < 0 ) return - 1 ; if ( cap > 0 ) { if ( ( mutt_socket_send ( conn , \"MODE<S2SV_blank>READER\\\\r\\\\n\" ) < 0 ) || ( mutt_socket_readln ( buf , sizeof ( buf ) , conn ) < 0 ) ) { return nntp_connect_error ( adata ) ; } if ( mutt_str_startswith ( buf , \"200\" , CASE_MATCH ) ) posting = true ; else if ( mutt_str_startswith ( buf , \"201\" , CASE_MATCH ) ) posting = false ; else if ( adata -> hasCAPABILITIES ) { mutt_socket_close ( conn ) ; mutt_error ( _ ( \"Could<S2SV_blank>not<S2SV_blank>switch<S2SV_blank>to<S2SV_blank>reader<S2SV_blank>mode\" ) ) ; return - 1 ; } if ( adata -> hasCAPABILITIES ) { cap = nntp_capabilities ( adata ) ; if ( cap < 0 ) return - 1 ; } } mutt_message ( _ ( \"Connected<S2SV_blank>to<S2SV_blank>%s.<S2SV_blank>%s\" ) , conn -> account . host , posting ? _ ( \"Posting<S2SV_blank>is<S2SV_blank>ok\" ) : _ ( \"Posting<S2SV_blank>is<S2SV_blank>NOT<S2SV_blank>ok\" ) ) ; mutt_sleep ( 1 ) ; # ifdef USE_SSL if ( ( adata -> use_tls != 1 ) && ( adata -> hasSTARTTLS || C_SslForceTls ) ) { if ( adata -> use_tls == 0 ) { adata -> use_tls = C_SslForceTls || query_quadoption ( C_SslStarttls , _ ( \"Secure<S2SV_blank>connection<S2SV_blank>with<S2SV_blank>TLS?\" ) ) == MUTT_YES ? 2 : 1 ; } if ( adata -> use_tls == 2 ) { if ( ( mutt_socket_send ( conn , \"STARTTLS\\\\r\\\\n\" ) < 0 ) || ( mutt_socket_readln ( buf , sizeof ( buf ) , conn ) < 0 ) ) { return nntp_connect_error ( adata ) ; <S2SV_StartBug> } <S2SV_EndBug> if ( ! mutt_str_startswith ( buf , \"382\" , CASE_MATCH ) ) { adata -> use_tls = 0 ; mutt_error ( \"STARTTLS:<S2SV_blank>%s\" , buf ) ; } else if ( mutt_ssl_starttls ( conn ) ) { adata -> use_tls = 0 ; adata -> status = NNTP_NONE ; mutt_socket_close ( adata -> conn ) ; mutt_error ( _ ( \"Could<S2SV_blank>not<S2SV_blank>negotiate<S2SV_blank>TLS<S2SV_blank>connection\" ) ) ; return - 1 ; } else { cap = nntp_capabilities ( adata ) ; if ( cap < 0 ) return - 1 ; } } } # endif if ( conn -> account . flags & MUTT_ACCT_USER ) { if ( ! conn -> account . user [ 0 ] ) auth = false ; } else { if ( ( mutt_socket_send ( conn , \"STAT\\\\r\\\\n\" ) < 0 ) || ( mutt_socket_readln ( buf , sizeof ( buf ) , conn ) < 0 ) ) { return nntp_connect_error ( adata ) ; } if ( ! mutt_str_startswith ( buf , \"480\" , CASE_MATCH ) ) auth = false ; } if ( auth && ( nntp_auth ( adata ) < 0 ) ) return - 1 ; if ( adata -> hasCAPABILITIES && ( auth || ( cap > 0 ) ) ) { cap = nntp_capabilities ( adata ) ; if ( cap < 0 ) return - 1 ; if ( cap > 0 ) { mutt_socket_close ( conn ) ; mutt_error ( _ ( \"Could<S2SV_blank>not<S2SV_blank>switch<S2SV_blank>to<S2SV_blank>reader<S2SV_blank>mode\" ) ) ; return - 1 ; } } if ( nntp_attempt_features ( adata ) < 0 ) return - 1 ; adata -> status = NNTP_OK ; return 0 ; }\n      |    ^\n2 errors generated.\n",
      "error_message": null
    },
    {
      "cve_id": "CVE-2020-15474",
      "tool_name": "Clang Static Analyzer",
      "detected": true,
      "confidence": 0.25,
      "detection_time": 0.018980741500854492,
      "tool_output": "/var/folders/ql/btm7z5tx32ddpsky8z3bz4_r0000gn/T/tmpcblkq_v_.c:1:1: error: unknown type name 'CWE'\n/var/folders/ql/btm7z5tx32ddpsky8z3bz4_r0000gn/T/tmpcblkq_v_.c:1:4: error: expected identifier or '('\n2 errors generated.\n",
      "error_message": null
    },
    {
      "cve_id": "CVE-2017-15385",
      "tool_name": "Clang Static Analyzer",
      "detected": true,
      "confidence": 0.5,
      "detection_time": 0.022365331649780273,
      "tool_output": "/var/folders/ql/btm7z5tx32ddpsky8z3bz4_r0000gn/T/tmpi9rrqmqs.c:1:1: error: unknown type name 'CWE'\n    1 | CWE-119 static Sdb * store_versioninfo_gnu_verdef ( ELFOBJ * bin , Elf_ ( Shdr ) * shdr , int sz ) { const char * section_name = \"\" ; const char * link_section_name = \"\" ; char * end = NULL ; Elf_ ( Shdr ) * link_shdr = NULL ; ut8 dfs [ sizeof ( Elf_ ( Verdef ) ) ] = { 0 } ; Sdb * sdb ; int cnt , i ; if ( shdr -> sh_link > bin -> ehdr . e_shnum ) { return false ; } link_shdr = & bin -> shdr [ shdr -> sh_link ] ; if ( shdr -> sh_size < 1 ) { return false ; } Elf_ ( Verdef ) * defs = calloc ( shdr -> sh_size , sizeof ( char ) ) ; if ( ! defs ) { return false ; } if ( bin -> shstrtab && shdr -> sh_name < bin -> shstrtab_size ) { section_name = & bin -> shstrtab [ shdr -> sh_name ] ; } if ( link_shdr && bin -> shstrtab && link_shdr -> sh_name < bin -> shstrtab_size ) { link_section_name = & bin -> shstrtab [ link_shdr -> sh_name ] ; } if ( ! defs ) { bprintf ( \"Warning:<S2SV_blank>Cannot<S2SV_blank>allocate<S2SV_blank>memory<S2SV_blank>(Check<S2SV_blank>Elf_(Verdef))\\\\n\" ) ; return NULL ; } sdb = sdb_new0 ( ) ; end = ( char * ) defs + shdr -> sh_size ; sdb_set ( sdb , \"section_name\" , section_name , 0 ) ; sdb_num_set ( sdb , \"entries\" , shdr -> sh_info , 0 ) ; sdb_num_set ( sdb , \"addr\" , shdr -> sh_addr , 0 ) ; sdb_num_set ( sdb , \"offset\" , shdr -> sh_offset , 0 ) ; sdb_num_set ( sdb , \"link\" , shdr -> sh_link , 0 ) ; sdb_set ( sdb , \"link_section_name\" , link_section_name , 0 ) ; <S2SV_StartBug> for ( cnt = 0 , i = 0 ; cnt < shdr -> sh_info && ( ( char * ) defs + i < end ) ; ++ cnt ) { <S2SV_EndBug> Sdb * sdb_verdef = sdb_new0 ( ) ; char * vstart = ( ( char * ) defs ) + i ; char key [ 32 ] = { 0 } ; Elf_ ( Verdef ) * verdef = ( Elf_ ( Verdef ) * ) vstart ; Elf_ ( Verdaux ) aux = { 0 } ; int j = 0 ; int isum = 0 ; r_buf_read_at ( bin -> b , shdr -> sh_offset + i , dfs , sizeof ( Elf_ ( Verdef ) ) ) ; verdef -> vd_version = READ16 ( dfs , j ) verdef -> vd_flags = READ16 ( dfs , j ) verdef -> vd_ndx = READ16 ( dfs , j ) verdef -> vd_cnt = READ16 ( dfs , j ) verdef -> vd_hash = READ32 ( dfs , j ) verdef -> vd_aux = READ32 ( dfs , j ) verdef -> vd_next = READ32 ( dfs , j ) vstart += verdef -> vd_aux ; if ( vstart > end || vstart + sizeof ( Elf_ ( Verdaux ) ) > end ) { sdb_free ( sdb_verdef ) ; goto out_error ; } j = 0 ; aux . vda_name = READ32 ( vstart , j ) aux . vda_next = READ32 ( vstart , j ) isum = i + verdef -> vd_aux ; if ( aux . vda_name > bin -> dynstr_size ) { sdb_free ( sdb_verdef ) ; goto out_error ; } sdb_num_set ( sdb_verdef , \"idx\" , i , 0 ) ; sdb_num_set ( sdb_verdef , \"vd_version\" , verdef -> vd_version , 0 ) ; sdb_num_set ( sdb_verdef , \"vd_ndx\" , verdef -> vd_ndx , 0 ) ; sdb_num_set ( sdb_verdef , \"vd_cnt\" , verdef -> vd_cnt , 0 ) ; sdb_set ( sdb_verdef , \"vda_name\" , & bin -> dynstr [ aux . vda_name ] , 0 ) ; sdb_set ( sdb_verdef , \"flags\" , get_ver_flags ( verdef -> vd_flags ) , 0 ) ; for ( j = 1 ; j < verdef -> vd_cnt ; ++ j ) { int k ; Sdb * sdb_parent = sdb_new0 ( ) ; isum += aux . vda_next ; vstart += aux . vda_next ; if ( vstart > end || vstart + sizeof ( Elf_ ( Verdaux ) ) > end ) { sdb_free ( sdb_verdef ) ; sdb_free ( sdb_parent ) ; goto out_error ; } k = 0 ; aux . vda_name = READ32 ( vstart , k ) aux . vda_next = READ32 ( vstart , k ) if ( aux . vda_name > bin -> dynstr_size ) { sdb_free ( sdb_verdef ) ; sdb_free ( sdb_parent ) ; goto out_error ; } sdb_num_set ( sdb_parent , \"idx\" , isum , 0 ) ; sdb_num_set ( sdb_parent , \"parent\" , j , 0 ) ; sdb_set ( sdb_parent , \"vda_name\" , & bin -> dynstr [ aux . vda_name ] , 0 ) ; snprintf ( key , sizeof ( key ) , \"parent%d\" , j - 1 ) ; sdb_ns_set ( sdb_verdef , key , sdb_parent ) ; } snprintf ( key , sizeof ( key ) , \"verdef%d\" , cnt ) ; sdb_ns_set ( sdb , key , sdb_verdef ) ; if ( ! verdef -> vd_next ) { sdb_free ( sdb_verdef ) ; goto out_error ; } <S2SV_StartBug> i += verdef -> vd_next ; <S2SV_EndBug> } free ( defs ) ; return sdb ; out_error : free ( defs ) ; sdb_free ( sdb ) ; return NULL ; }\n      | ^\n/var/folders/ql/btm7z5tx32ddpsky8z3bz4_r0000gn/T/tmpi9rrqmqs.c:1:4: error: expected identifier or '('\n    1 | CWE-119 static Sdb * store_versioninfo_gnu_verdef ( ELFOBJ * bin , Elf_ ( Shdr ) * shdr , int sz ) { const char * section_name = \"\" ; const char * link_section_name = \"\" ; char * end = NULL ; Elf_ ( Shdr ) * link_shdr = NULL ; ut8 dfs [ sizeof ( Elf_ ( Verdef ) ) ] = { 0 } ; Sdb * sdb ; int cnt , i ; if ( shdr -> sh_link > bin -> ehdr . e_shnum ) { return false ; } link_shdr = & bin -> shdr [ shdr -> sh_link ] ; if ( shdr -> sh_size < 1 ) { return false ; } Elf_ ( Verdef ) * defs = calloc ( shdr -> sh_size , sizeof ( char ) ) ; if ( ! defs ) { return false ; } if ( bin -> shstrtab && shdr -> sh_name < bin -> shstrtab_size ) { section_name = & bin -> shstrtab [ shdr -> sh_name ] ; } if ( link_shdr && bin -> shstrtab && link_shdr -> sh_name < bin -> shstrtab_size ) { link_section_name = & bin -> shstrtab [ link_shdr -> sh_name ] ; } if ( ! defs ) { bprintf ( \"Warning:<S2SV_blank>Cannot<S2SV_blank>allocate<S2SV_blank>memory<S2SV_blank>(Check<S2SV_blank>Elf_(Verdef))\\\\n\" ) ; return NULL ; } sdb = sdb_new0 ( ) ; end = ( char * ) defs + shdr -> sh_size ; sdb_set ( sdb , \"section_name\" , section_name , 0 ) ; sdb_num_set ( sdb , \"entries\" , shdr -> sh_info , 0 ) ; sdb_num_set ( sdb , \"addr\" , shdr -> sh_addr , 0 ) ; sdb_num_set ( sdb , \"offset\" , shdr -> sh_offset , 0 ) ; sdb_num_set ( sdb , \"link\" , shdr -> sh_link , 0 ) ; sdb_set ( sdb , \"link_section_name\" , link_section_name , 0 ) ; <S2SV_StartBug> for ( cnt = 0 , i = 0 ; cnt < shdr -> sh_info && ( ( char * ) defs + i < end ) ; ++ cnt ) { <S2SV_EndBug> Sdb * sdb_verdef = sdb_new0 ( ) ; char * vstart = ( ( char * ) defs ) + i ; char key [ 32 ] = { 0 } ; Elf_ ( Verdef ) * verdef = ( Elf_ ( Verdef ) * ) vstart ; Elf_ ( Verdaux ) aux = { 0 } ; int j = 0 ; int isum = 0 ; r_buf_read_at ( bin -> b , shdr -> sh_offset + i , dfs , sizeof ( Elf_ ( Verdef ) ) ) ; verdef -> vd_version = READ16 ( dfs , j ) verdef -> vd_flags = READ16 ( dfs , j ) verdef -> vd_ndx = READ16 ( dfs , j ) verdef -> vd_cnt = READ16 ( dfs , j ) verdef -> vd_hash = READ32 ( dfs , j ) verdef -> vd_aux = READ32 ( dfs , j ) verdef -> vd_next = READ32 ( dfs , j ) vstart += verdef -> vd_aux ; if ( vstart > end || vstart + sizeof ( Elf_ ( Verdaux ) ) > end ) { sdb_free ( sdb_verdef ) ; goto out_error ; } j = 0 ; aux . vda_name = READ32 ( vstart , j ) aux . vda_next = READ32 ( vstart , j ) isum = i + verdef -> vd_aux ; if ( aux . vda_name > bin -> dynstr_size ) { sdb_free ( sdb_verdef ) ; goto out_error ; } sdb_num_set ( sdb_verdef , \"idx\" , i , 0 ) ; sdb_num_set ( sdb_verdef , \"vd_version\" , verdef -> vd_version , 0 ) ; sdb_num_set ( sdb_verdef , \"vd_ndx\" , verdef -> vd_ndx , 0 ) ; sdb_num_set ( sdb_verdef , \"vd_cnt\" , verdef -> vd_cnt , 0 ) ; sdb_set ( sdb_verdef , \"vda_name\" , & bin -> dynstr [ aux . vda_name ] , 0 ) ; sdb_set ( sdb_verdef , \"flags\" , get_ver_flags ( verdef -> vd_flags ) , 0 ) ; for ( j = 1 ; j < verdef -> vd_cnt ; ++ j ) { int k ; Sdb * sdb_parent = sdb_new0 ( ) ; isum += aux . vda_next ; vstart += aux . vda_next ; if ( vstart > end || vstart + sizeof ( Elf_ ( Verdaux ) ) > end ) { sdb_free ( sdb_verdef ) ; sdb_free ( sdb_parent ) ; goto out_error ; } k = 0 ; aux . vda_name = READ32 ( vstart , k ) aux . vda_next = READ32 ( vstart , k ) if ( aux . vda_name > bin -> dynstr_size ) { sdb_free ( sdb_verdef ) ; sdb_free ( sdb_parent ) ; goto out_error ; } sdb_num_set ( sdb_parent , \"idx\" , isum , 0 ) ; sdb_num_set ( sdb_parent , \"parent\" , j , 0 ) ; sdb_set ( sdb_parent , \"vda_name\" , & bin -> dynstr [ aux . vda_name ] , 0 ) ; snprintf ( key , sizeof ( key ) , \"parent%d\" , j - 1 ) ; sdb_ns_set ( sdb_verdef , key , sdb_parent ) ; } snprintf ( key , sizeof ( key ) , \"verdef%d\" , cnt ) ; sdb_ns_set ( sdb , key , sdb_verdef ) ; if ( ! verdef -> vd_next ) { sdb_free ( sdb_verdef ) ; goto out_error ; } <S2SV_StartBug> i += verdef -> vd_next ; <S2SV_EndBug> } free ( defs ) ; return sdb ; out_error : free ( defs ) ; sdb_free ( sdb ) ; return NULL ; }\n      |    ^\n2 errors generated.\n",
      "error_message": null
    },
    {
      "cve_id": "CVE-2019-19275",
      "tool_name": "Clang Static Analyzer",
      "detected": true,
      "confidence": 0.25,
      "detection_time": 0.019115209579467773,
      "tool_output": "/var/folders/ql/btm7z5tx32ddpsky8z3bz4_r0000gn/T/tmp4gnkwv9e.c:1:1: error: unknown type name 'CWE'\n/var/folders/ql/btm7z5tx32ddpsky8z3bz4_r0000gn/T/tmp4gnkwv9e.c:1:4: error: expected identifier or '('\n2 errors generated.\n",
      "error_message": null
    },
    {
      "cve_id": "CVE-2019-19481",
      "tool_name": "Clang Static Analyzer",
      "detected": true,
      "confidence": 0.25,
      "detection_time": 0.020105361938476562,
      "tool_output": "/var/folders/ql/btm7z5tx32ddpsky8z3bz4_r0000gn/T/tmpd911bolp.c:1:1: error: unknown type name 'CWE'\n    1 | CWE-119 static int cac_read_binary ( sc_card_t * card , unsigned int idx , unsigned char * buf , size_t count , unsigned long flags ) { cac_private_data_t * priv = CAC_DATA ( card ) ; int r = 0 ; u8 * val = NULL ; u8 * cert_ptr ; <S2SV_StartBug> size_t val_len ; <S2SV_EndBug> size_t len , cert_len ; u8 cert_type ; SC_FUNC_CALLED ( card -> ctx , SC_LOG_DEBUG_VERBOSE ) ; if ( priv -> cached ) { sc_log ( card -> ctx , \"returning<S2SV_blank>cached<S2SV_blank>value<S2SV_blank>idx=%d<S2SV_blank>count=%\" SC_FORMAT_LEN_SIZE_T \"u\" , idx , count ) ; if ( idx > priv -> cache_buf_len ) { LOG_FUNC_RETURN ( card -> ctx , SC_ERROR_FILE_END_REACHED ) ; } len = MIN ( count , priv -> cache_buf_len - idx ) ; memcpy ( buf , & priv -> cache_buf [ idx ] , len ) ; LOG_FUNC_RETURN ( card -> ctx , len ) ; } sc_log ( card -> ctx , \"clearing<S2SV_blank>cache<S2SV_blank>idx=%d<S2SV_blank>count=%\" SC_FORMAT_LEN_SIZE_T \"u\" , idx , count ) ; free ( priv -> cache_buf ) ; priv -> cache_buf = NULL ; priv -> cache_buf_len = 0 ; r = cac_cac1_get_certificate ( card , & val , & val_len ) ; if ( r < 0 ) goto done ; if ( val_len < 1 ) { r = SC_ERROR_INVALID_DATA ; goto done ; } cert_type = val [ 0 ] ; cert_ptr = val + 1 ; cert_len = val_len - 1 ; if ( ( cert_type & 0x3 ) == 1 ) { # ifdef ENABLE_ZLIB r = sc_decompress_alloc ( & priv -> cache_buf , & priv -> cache_buf_len , cert_ptr , cert_len , COMPRESSION_AUTO ) ; # else sc_log ( card -> ctx , \"CAC<S2SV_blank>compression<S2SV_blank>not<S2SV_blank>supported,<S2SV_blank>no<S2SV_blank>zlib\" ) ; r = SC_ERROR_NOT_SUPPORTED ; # endif if ( r ) goto done ; } else if ( cert_len > 0 ) { priv -> cache_buf = malloc ( cert_len ) ; if ( priv -> cache_buf == NULL ) { r = SC_ERROR_OUT_OF_MEMORY ; goto done ; } priv -> cache_buf_len = cert_len ; memcpy ( priv -> cache_buf , cert_ptr , cert_len ) ; } priv -> cached = 1 ; len = MIN ( count , priv -> cache_buf_len - idx ) ; if ( len && priv -> cache_buf ) memcpy ( buf , & priv -> cache_buf [ idx ] , len ) ; r = len ; done : if ( val ) free ( val ) ; LOG_FUNC_RETURN ( card -> ctx , r ) ; }\n      | ^\n/var/folders/ql/btm7z5tx32ddpsky8z3bz4_r0000gn/T/tmpd911bolp.c:1:4: error: expected identifier or '('\n    1 | CWE-119 static int cac_read_binary ( sc_card_t * card , unsigned int idx , unsigned char * buf , size_t count , unsigned long flags ) { cac_private_data_t * priv = CAC_DATA ( card ) ; int r = 0 ; u8 * val = NULL ; u8 * cert_ptr ; <S2SV_StartBug> size_t val_len ; <S2SV_EndBug> size_t len , cert_len ; u8 cert_type ; SC_FUNC_CALLED ( card -> ctx , SC_LOG_DEBUG_VERBOSE ) ; if ( priv -> cached ) { sc_log ( card -> ctx , \"returning<S2SV_blank>cached<S2SV_blank>value<S2SV_blank>idx=%d<S2SV_blank>count=%\" SC_FORMAT_LEN_SIZE_T \"u\" , idx , count ) ; if ( idx > priv -> cache_buf_len ) { LOG_FUNC_RETURN ( card -> ctx , SC_ERROR_FILE_END_REACHED ) ; } len = MIN ( count , priv -> cache_buf_len - idx ) ; memcpy ( buf , & priv -> cache_buf [ idx ] , len ) ; LOG_FUNC_RETURN ( card -> ctx , len ) ; } sc_log ( card -> ctx , \"clearing<S2SV_blank>cache<S2SV_blank>idx=%d<S2SV_blank>count=%\" SC_FORMAT_LEN_SIZE_T \"u\" , idx , count ) ; free ( priv -> cache_buf ) ; priv -> cache_buf = NULL ; priv -> cache_buf_len = 0 ; r = cac_cac1_get_certificate ( card , & val , & val_len ) ; if ( r < 0 ) goto done ; if ( val_len < 1 ) { r = SC_ERROR_INVALID_DATA ; goto done ; } cert_type = val [ 0 ] ; cert_ptr = val + 1 ; cert_len = val_len - 1 ; if ( ( cert_type & 0x3 ) == 1 ) { # ifdef ENABLE_ZLIB r = sc_decompress_alloc ( & priv -> cache_buf , & priv -> cache_buf_len , cert_ptr , cert_len , COMPRESSION_AUTO ) ; # else sc_log ( card -> ctx , \"CAC<S2SV_blank>compression<S2SV_blank>not<S2SV_blank>supported,<S2SV_blank>no<S2SV_blank>zlib\" ) ; r = SC_ERROR_NOT_SUPPORTED ; # endif if ( r ) goto done ; } else if ( cert_len > 0 ) { priv -> cache_buf = malloc ( cert_len ) ; if ( priv -> cache_buf == NULL ) { r = SC_ERROR_OUT_OF_MEMORY ; goto done ; } priv -> cache_buf_len = cert_len ; memcpy ( priv -> cache_buf , cert_ptr , cert_len ) ; } priv -> cached = 1 ; len = MIN ( count , priv -> cache_buf_len - idx ) ; if ( len && priv -> cache_buf ) memcpy ( buf , & priv -> cache_buf [ idx ] , len ) ; r = len ; done : if ( val ) free ( val ) ; LOG_FUNC_RETURN ( card -> ctx , r ) ; }\n      |    ^\n2 errors generated.\n",
      "error_message": null
    },
    {
      "cve_id": "CVE-2019-13308",
      "tool_name": "Clang Static Analyzer",
      "detected": true,
      "confidence": 0.25,
      "detection_time": 0.019353866577148438,
      "tool_output": "/var/folders/ql/btm7z5tx32ddpsky8z3bz4_r0000gn/T/tmp5lrkswle.c:1:1: error: unknown type name 'CWE'\n/var/folders/ql/btm7z5tx32ddpsky8z3bz4_r0000gn/T/tmp5lrkswle.c:1:4: error: expected identifier or '('\n2 errors generated.\n",
      "error_message": null
    },
    {
      "cve_id": "CVE-2018-1999011",
      "tool_name": "Clang Static Analyzer",
      "detected": true,
      "confidence": 0.25,
      "detection_time": 0.019068241119384766,
      "tool_output": "/var/folders/ql/btm7z5tx32ddpsky8z3bz4_r0000gn/T/tmp_8uyvyo9.c:1:1: error: unknown type name 'CWE'\n    1 | CWE-119 static int parse_video_info ( AVIOContext * pb , AVStream * st ) { uint16_t size_asf ; uint32_t size_bmp ; unsigned int tag ; st -> codecpar -> width = avio_rl32 ( pb ) ; st -> codecpar -> height = avio_rl32 ( pb ) ; avio_skip ( pb , 1 ) ; size_asf = avio_rl16 ( pb ) ; tag = ff_get_bmp_header ( pb , st , & size_bmp ) ; st -> codecpar -> codec_tag = tag ; st -> codecpar -> codec_id = ff_codec_get_id ( ff_codec_bmp_tags , tag ) ; size_bmp = FFMAX ( size_asf , size_bmp ) ; <S2SV_StartBug> if ( size_bmp > BMP_HEADER_SIZE ) { <S2SV_EndBug> int ret ; st -> codecpar -> extradata_size = size_bmp - BMP_HEADER_SIZE ; if ( ! ( st -> codecpar -> extradata = av_malloc ( st -> codecpar -> extradata_size + AV_INPUT_BUFFER_PADDING_SIZE ) ) ) { st -> codecpar -> extradata_size = 0 ; return AVERROR ( ENOMEM ) ; } memset ( st -> codecpar -> extradata + st -> codecpar -> extradata_size , 0 , AV_INPUT_BUFFER_PADDING_SIZE ) ; if ( ( ret = avio_read ( pb , st -> codecpar -> extradata , st -> codecpar -> extradata_size ) ) < 0 ) return ret ; } return 0 ; }\n      | ^\n/var/folders/ql/btm7z5tx32ddpsky8z3bz4_r0000gn/T/tmp_8uyvyo9.c:1:4: error: expected identifier or '('\n    1 | CWE-119 static int parse_video_info ( AVIOContext * pb , AVStream * st ) { uint16_t size_asf ; uint32_t size_bmp ; unsigned int tag ; st -> codecpar -> width = avio_rl32 ( pb ) ; st -> codecpar -> height = avio_rl32 ( pb ) ; avio_skip ( pb , 1 ) ; size_asf = avio_rl16 ( pb ) ; tag = ff_get_bmp_header ( pb , st , & size_bmp ) ; st -> codecpar -> codec_tag = tag ; st -> codecpar -> codec_id = ff_codec_get_id ( ff_codec_bmp_tags , tag ) ; size_bmp = FFMAX ( size_asf , size_bmp ) ; <S2SV_StartBug> if ( size_bmp > BMP_HEADER_SIZE ) { <S2SV_EndBug> int ret ; st -> codecpar -> extradata_size = size_bmp - BMP_HEADER_SIZE ; if ( ! ( st -> codecpar -> extradata = av_malloc ( st -> codecpar -> extradata_size + AV_INPUT_BUFFER_PADDING_SIZE ) ) ) { st -> codecpar -> extradata_size = 0 ; return AVERROR ( ENOMEM ) ; } memset ( st -> codecpar -> extradata + st -> codecpar -> extradata_size , 0 , AV_INPUT_BUFFER_PADDING_SIZE ) ; if ( ( ret = avio_read ( pb , st -> codecpar -> extradata , st -> codecpar -> extradata_size ) ) < 0 ) return ret ; } return 0 ; }\n      |    ^\n2 errors generated.\n",
      "error_message": null
    },
    {
      "cve_id": "CVE-2017-15385",
      "tool_name": "Clang Static Analyzer",
      "detected": true,
      "confidence": 0.5,
      "detection_time": 0.02250814437866211,
      "tool_output": "/var/folders/ql/btm7z5tx32ddpsky8z3bz4_r0000gn/T/tmp10y0eaxr.c:1:1: error: unknown type name 'CWE'\n    1 | CWE-119 static Sdb * store_versioninfo_gnu_verdef ( ELFOBJ * bin , Elf_ ( Shdr ) * shdr , int sz ) { const char * section_name = \"\" ; const char * link_section_name = \"\" ; char * end = NULL ; Elf_ ( Shdr ) * link_shdr = NULL ; ut8 dfs [ sizeof ( Elf_ ( Verdef ) ) ] = { 0 } ; Sdb * sdb ; int cnt , i ; if ( shdr -> sh_link > bin -> ehdr . e_shnum ) { return false ; } link_shdr = & bin -> shdr [ shdr -> sh_link ] ; if ( shdr -> sh_size < 1 ) { return false ; } Elf_ ( Verdef ) * defs = calloc ( shdr -> sh_size , sizeof ( char ) ) ; if ( ! defs ) { return false ; } if ( bin -> shstrtab && shdr -> sh_name < bin -> shstrtab_size ) { section_name = & bin -> shstrtab [ shdr -> sh_name ] ; } if ( link_shdr && bin -> shstrtab && link_shdr -> sh_name < bin -> shstrtab_size ) { link_section_name = & bin -> shstrtab [ link_shdr -> sh_name ] ; } if ( ! defs ) { bprintf ( \"Warning:<S2SV_blank>Cannot<S2SV_blank>allocate<S2SV_blank>memory<S2SV_blank>(Check<S2SV_blank>Elf_(Verdef))\\\\n\" ) ; return NULL ; } sdb = sdb_new0 ( ) ; end = ( char * ) defs + shdr -> sh_size ; sdb_set ( sdb , \"section_name\" , section_name , 0 ) ; sdb_num_set ( sdb , \"entries\" , shdr -> sh_info , 0 ) ; sdb_num_set ( sdb , \"addr\" , shdr -> sh_addr , 0 ) ; sdb_num_set ( sdb , \"offset\" , shdr -> sh_offset , 0 ) ; sdb_num_set ( sdb , \"link\" , shdr -> sh_link , 0 ) ; sdb_set ( sdb , \"link_section_name\" , link_section_name , 0 ) ; <S2SV_StartBug> for ( cnt = 0 , i = 0 ; cnt < shdr -> sh_info && ( ( char * ) defs + i < end ) ; ++ cnt ) { <S2SV_EndBug> Sdb * sdb_verdef = sdb_new0 ( ) ; char * vstart = ( ( char * ) defs ) + i ; char key [ 32 ] = { 0 } ; Elf_ ( Verdef ) * verdef = ( Elf_ ( Verdef ) * ) vstart ; Elf_ ( Verdaux ) aux = { 0 } ; int j = 0 ; int isum = 0 ; r_buf_read_at ( bin -> b , shdr -> sh_offset + i , dfs , sizeof ( Elf_ ( Verdef ) ) ) ; verdef -> vd_version = READ16 ( dfs , j ) verdef -> vd_flags = READ16 ( dfs , j ) verdef -> vd_ndx = READ16 ( dfs , j ) verdef -> vd_cnt = READ16 ( dfs , j ) verdef -> vd_hash = READ32 ( dfs , j ) verdef -> vd_aux = READ32 ( dfs , j ) verdef -> vd_next = READ32 ( dfs , j ) vstart += verdef -> vd_aux ; if ( vstart > end || vstart + sizeof ( Elf_ ( Verdaux ) ) > end ) { sdb_free ( sdb_verdef ) ; goto out_error ; } j = 0 ; aux . vda_name = READ32 ( vstart , j ) aux . vda_next = READ32 ( vstart , j ) isum = i + verdef -> vd_aux ; if ( aux . vda_name > bin -> dynstr_size ) { sdb_free ( sdb_verdef ) ; goto out_error ; } sdb_num_set ( sdb_verdef , \"idx\" , i , 0 ) ; sdb_num_set ( sdb_verdef , \"vd_version\" , verdef -> vd_version , 0 ) ; sdb_num_set ( sdb_verdef , \"vd_ndx\" , verdef -> vd_ndx , 0 ) ; sdb_num_set ( sdb_verdef , \"vd_cnt\" , verdef -> vd_cnt , 0 ) ; sdb_set ( sdb_verdef , \"vda_name\" , & bin -> dynstr [ aux . vda_name ] , 0 ) ; sdb_set ( sdb_verdef , \"flags\" , get_ver_flags ( verdef -> vd_flags ) , 0 ) ; for ( j = 1 ; j < verdef -> vd_cnt ; ++ j ) { int k ; Sdb * sdb_parent = sdb_new0 ( ) ; isum += aux . vda_next ; vstart += aux . vda_next ; if ( vstart > end || vstart + sizeof ( Elf_ ( Verdaux ) ) > end ) { sdb_free ( sdb_verdef ) ; sdb_free ( sdb_parent ) ; goto out_error ; } k = 0 ; aux . vda_name = READ32 ( vstart , k ) aux . vda_next = READ32 ( vstart , k ) if ( aux . vda_name > bin -> dynstr_size ) { sdb_free ( sdb_verdef ) ; sdb_free ( sdb_parent ) ; goto out_error ; } sdb_num_set ( sdb_parent , \"idx\" , isum , 0 ) ; sdb_num_set ( sdb_parent , \"parent\" , j , 0 ) ; sdb_set ( sdb_parent , \"vda_name\" , & bin -> dynstr [ aux . vda_name ] , 0 ) ; snprintf ( key , sizeof ( key ) , \"parent%d\" , j - 1 ) ; sdb_ns_set ( sdb_verdef , key , sdb_parent ) ; } snprintf ( key , sizeof ( key ) , \"verdef%d\" , cnt ) ; sdb_ns_set ( sdb , key , sdb_verdef ) ; if ( ! verdef -> vd_next ) { sdb_free ( sdb_verdef ) ; goto out_error ; } <S2SV_StartBug> i += verdef -> vd_next ; <S2SV_EndBug> } free ( defs ) ; return sdb ; out_error : free ( defs ) ; sdb_free ( sdb ) ; return NULL ; }\n      | ^\n/var/folders/ql/btm7z5tx32ddpsky8z3bz4_r0000gn/T/tmp10y0eaxr.c:1:4: error: expected identifier or '('\n    1 | CWE-119 static Sdb * store_versioninfo_gnu_verdef ( ELFOBJ * bin , Elf_ ( Shdr ) * shdr , int sz ) { const char * section_name = \"\" ; const char * link_section_name = \"\" ; char * end = NULL ; Elf_ ( Shdr ) * link_shdr = NULL ; ut8 dfs [ sizeof ( Elf_ ( Verdef ) ) ] = { 0 } ; Sdb * sdb ; int cnt , i ; if ( shdr -> sh_link > bin -> ehdr . e_shnum ) { return false ; } link_shdr = & bin -> shdr [ shdr -> sh_link ] ; if ( shdr -> sh_size < 1 ) { return false ; } Elf_ ( Verdef ) * defs = calloc ( shdr -> sh_size , sizeof ( char ) ) ; if ( ! defs ) { return false ; } if ( bin -> shstrtab && shdr -> sh_name < bin -> shstrtab_size ) { section_name = & bin -> shstrtab [ shdr -> sh_name ] ; } if ( link_shdr && bin -> shstrtab && link_shdr -> sh_name < bin -> shstrtab_size ) { link_section_name = & bin -> shstrtab [ link_shdr -> sh_name ] ; } if ( ! defs ) { bprintf ( \"Warning:<S2SV_blank>Cannot<S2SV_blank>allocate<S2SV_blank>memory<S2SV_blank>(Check<S2SV_blank>Elf_(Verdef))\\\\n\" ) ; return NULL ; } sdb = sdb_new0 ( ) ; end = ( char * ) defs + shdr -> sh_size ; sdb_set ( sdb , \"section_name\" , section_name , 0 ) ; sdb_num_set ( sdb , \"entries\" , shdr -> sh_info , 0 ) ; sdb_num_set ( sdb , \"addr\" , shdr -> sh_addr , 0 ) ; sdb_num_set ( sdb , \"offset\" , shdr -> sh_offset , 0 ) ; sdb_num_set ( sdb , \"link\" , shdr -> sh_link , 0 ) ; sdb_set ( sdb , \"link_section_name\" , link_section_name , 0 ) ; <S2SV_StartBug> for ( cnt = 0 , i = 0 ; cnt < shdr -> sh_info && ( ( char * ) defs + i < end ) ; ++ cnt ) { <S2SV_EndBug> Sdb * sdb_verdef = sdb_new0 ( ) ; char * vstart = ( ( char * ) defs ) + i ; char key [ 32 ] = { 0 } ; Elf_ ( Verdef ) * verdef = ( Elf_ ( Verdef ) * ) vstart ; Elf_ ( Verdaux ) aux = { 0 } ; int j = 0 ; int isum = 0 ; r_buf_read_at ( bin -> b , shdr -> sh_offset + i , dfs , sizeof ( Elf_ ( Verdef ) ) ) ; verdef -> vd_version = READ16 ( dfs , j ) verdef -> vd_flags = READ16 ( dfs , j ) verdef -> vd_ndx = READ16 ( dfs , j ) verdef -> vd_cnt = READ16 ( dfs , j ) verdef -> vd_hash = READ32 ( dfs , j ) verdef -> vd_aux = READ32 ( dfs , j ) verdef -> vd_next = READ32 ( dfs , j ) vstart += verdef -> vd_aux ; if ( vstart > end || vstart + sizeof ( Elf_ ( Verdaux ) ) > end ) { sdb_free ( sdb_verdef ) ; goto out_error ; } j = 0 ; aux . vda_name = READ32 ( vstart , j ) aux . vda_next = READ32 ( vstart , j ) isum = i + verdef -> vd_aux ; if ( aux . vda_name > bin -> dynstr_size ) { sdb_free ( sdb_verdef ) ; goto out_error ; } sdb_num_set ( sdb_verdef , \"idx\" , i , 0 ) ; sdb_num_set ( sdb_verdef , \"vd_version\" , verdef -> vd_version , 0 ) ; sdb_num_set ( sdb_verdef , \"vd_ndx\" , verdef -> vd_ndx , 0 ) ; sdb_num_set ( sdb_verdef , \"vd_cnt\" , verdef -> vd_cnt , 0 ) ; sdb_set ( sdb_verdef , \"vda_name\" , & bin -> dynstr [ aux . vda_name ] , 0 ) ; sdb_set ( sdb_verdef , \"flags\" , get_ver_flags ( verdef -> vd_flags ) , 0 ) ; for ( j = 1 ; j < verdef -> vd_cnt ; ++ j ) { int k ; Sdb * sdb_parent = sdb_new0 ( ) ; isum += aux . vda_next ; vstart += aux . vda_next ; if ( vstart > end || vstart + sizeof ( Elf_ ( Verdaux ) ) > end ) { sdb_free ( sdb_verdef ) ; sdb_free ( sdb_parent ) ; goto out_error ; } k = 0 ; aux . vda_name = READ32 ( vstart , k ) aux . vda_next = READ32 ( vstart , k ) if ( aux . vda_name > bin -> dynstr_size ) { sdb_free ( sdb_verdef ) ; sdb_free ( sdb_parent ) ; goto out_error ; } sdb_num_set ( sdb_parent , \"idx\" , isum , 0 ) ; sdb_num_set ( sdb_parent , \"parent\" , j , 0 ) ; sdb_set ( sdb_parent , \"vda_name\" , & bin -> dynstr [ aux . vda_name ] , 0 ) ; snprintf ( key , sizeof ( key ) , \"parent%d\" , j - 1 ) ; sdb_ns_set ( sdb_verdef , key , sdb_parent ) ; } snprintf ( key , sizeof ( key ) , \"verdef%d\" , cnt ) ; sdb_ns_set ( sdb , key , sdb_verdef ) ; if ( ! verdef -> vd_next ) { sdb_free ( sdb_verdef ) ; goto out_error ; } <S2SV_StartBug> i += verdef -> vd_next ; <S2SV_EndBug> } free ( defs ) ; return sdb ; out_error : free ( defs ) ; sdb_free ( sdb ) ; return NULL ; }\n      |    ^\n2 errors generated.\n",
      "error_message": null
    },
    {
      "cve_id": "CVE-2019-19244",
      "tool_name": "Clang Static Analyzer",
      "detected": true,
      "confidence": 0.25,
      "detection_time": 0.0188901424407959,
      "tool_output": "/var/folders/ql/btm7z5tx32ddpsky8z3bz4_r0000gn/T/tmpzu7hpmh8.c:1:1: error: unknown type name 'CWE'\n/var/folders/ql/btm7z5tx32ddpsky8z3bz4_r0000gn/T/tmpzu7hpmh8.c:1:4: error: expected identifier or '('\n2 errors generated.\n",
      "error_message": null
    },
    {
      "cve_id": "CVE-2016-1621",
      "tool_name": "GCC Security Warnings",
      "detected": true,
      "confidence": 0.25,
      "detection_time": 0.023409128189086914,
      "tool_output": "/var/folders/ql/btm7z5tx32ddpsky8z3bz4_r0000gn/T/tmps5oqeaaa.c:1:1: error: unknown type name 'CWE'\n    1 | CWE-119 int main ( int argc , char * * argv ) { int frame_cnt = 0 ; FILE * outfile = NULL ; vpx_codec_ctx_t codec ; const VpxInterface * decoder = NULL ; VpxVideoReader * reader = NULL ; const VpxVideoInfo * info = NULL ; int n = 0 ; int m = 0 ; int is_range = 0 ; char * nptr = NULL ; exec_name = argv [ 0 ] ; if ( argc != 4 ) die ( \"Invalid<S2SV_blank>number<S2SV_blank>of<S2SV_blank>arguments.\" ) ; reader = vpx_video_reader_open ( argv [ 1 ] ) ; if ( ! reader ) die ( \"Failed<S2SV_blank>to<S2SV_blank>open<S2SV_blank>%s<S2SV_blank>for<S2SV_blank>reading.\" , argv [ 1 ] ) ; if ( ! ( outfile = fopen ( argv [ 2 ] , \"wb\" ) ) ) die ( \"Failed<S2SV_blank>to<S2SV_blank>open<S2SV_blank>%s<S2SV_blank>for<S2SV_blank>writing.\" , argv [ 2 ] ) ; n = strtol ( argv [ 3 ] , & nptr , 0 ) ; m = strtol ( nptr + 1 , NULL , 0 ) ; is_range = ( * nptr == '-' ) ; if ( ! n || ! m || ( * nptr != '-' && * nptr != '/' ) ) die ( \"Couldn\\'t<S2SV_blank>parse<S2SV_blank>pattern<S2SV_blank>%s.\\\\n\" , argv [ 3 ] ) ; info = vpx_video_reader_get_info ( reader ) ; decoder = get_vpx_decoder_by_fourcc ( info -> codec_fourcc ) ; if ( ! decoder ) die ( \"Unknown<S2SV_blank>input<S2SV_blank>codec.\" ) ; <S2SV_StartBug> printf ( \"Using<S2SV_blank>%s\\\\n\" , vpx_codec_iface_name ( decoder -> interface ( ) ) ) ; <S2SV_EndBug> <S2SV_StartBug> if ( vpx_codec_dec_init ( & codec , decoder -> interface ( ) , NULL , 0 ) ) <S2SV_EndBug> die_codec ( & codec , \"Failed<S2SV_blank>to<S2SV_blank>initialize<S2SV_blank>decoder.\" ) ; while ( vpx_video_reader_read_frame ( reader ) ) { vpx_codec_iter_t iter = NULL ; vpx_image_t * img = NULL ; size_t frame_size = 0 ; int skip ; const unsigned char * frame = vpx_video_reader_get_frame ( reader , & frame_size ) ; if ( vpx_codec_decode ( & codec , frame , ( unsigned int ) frame_size , NULL , 0 ) ) die_codec ( & codec , \"Failed<S2SV_blank>to<S2SV_blank>decode<S2SV_blank>frame.\" ) ; ++ frame_cnt ; skip = ( is_range && frame_cnt >= n && frame_cnt <= m ) || ( ! is_range && m - ( frame_cnt - 1 ) % m <= n ) ; if ( ! skip ) { putc ( '.' , stdout ) ; while ( ( img = vpx_codec_get_frame ( & codec , & iter ) ) != NULL ) vpx_img_write ( img , outfile ) ; } else { putc ( 'X' , stdout ) ; } fflush ( stdout ) ; } printf ( \"Processed<S2SV_blank>%d<S2SV_blank>frames.\\\\n\" , frame_cnt ) ; if ( vpx_codec_destroy ( & codec ) ) die_codec ( & codec , \"Failed<S2SV_blank>to<S2SV_blank>destroy<S2SV_blank>codec.\" ) ; printf ( \"Play:<S2SV_blank>ffplay<S2SV_blank>-f<S2SV_blank>rawvideo<S2SV_blank>-pix_fmt<S2SV_blank>yuv420p<S2SV_blank>-s<S2SV_blank>%dx%d<S2SV_blank>%s\\\\n\" , info -> frame_width , info -> frame_height , argv [ 2 ] ) ; vpx_video_reader_close ( reader ) ; fclose ( outfile ) ; return EXIT_SUCCESS ; }\n      | ^\n/var/folders/ql/btm7z5tx32ddpsky8z3bz4_r0000gn/T/tmps5oqeaaa.c:1:4: error: expected identifier or '('\n    1 | CWE-119 int main ( int argc , char * * argv ) { int frame_cnt = 0 ; FILE * outfile = NULL ; vpx_codec_ctx_t codec ; const VpxInterface * decoder = NULL ; VpxVideoReader * reader = NULL ; const VpxVideoInfo * info = NULL ; int n = 0 ; int m = 0 ; int is_range = 0 ; char * nptr = NULL ; exec_name = argv [ 0 ] ; if ( argc != 4 ) die ( \"Invalid<S2SV_blank>number<S2SV_blank>of<S2SV_blank>arguments.\" ) ; reader = vpx_video_reader_open ( argv [ 1 ] ) ; if ( ! reader ) die ( \"Failed<S2SV_blank>to<S2SV_blank>open<S2SV_blank>%s<S2SV_blank>for<S2SV_blank>reading.\" , argv [ 1 ] ) ; if ( ! ( outfile = fopen ( argv [ 2 ] , \"wb\" ) ) ) die ( \"Failed<S2SV_blank>to<S2SV_blank>open<S2SV_blank>%s<S2SV_blank>for<S2SV_blank>writing.\" , argv [ 2 ] ) ; n = strtol ( argv [ 3 ] , & nptr , 0 ) ; m = strtol ( nptr + 1 , NULL , 0 ) ; is_range = ( * nptr == '-' ) ; if ( ! n || ! m || ( * nptr != '-' && * nptr != '/' ) ) die ( \"Couldn\\'t<S2SV_blank>parse<S2SV_blank>pattern<S2SV_blank>%s.\\\\n\" , argv [ 3 ] ) ; info = vpx_video_reader_get_info ( reader ) ; decoder = get_vpx_decoder_by_fourcc ( info -> codec_fourcc ) ; if ( ! decoder ) die ( \"Unknown<S2SV_blank>input<S2SV_blank>codec.\" ) ; <S2SV_StartBug> printf ( \"Using<S2SV_blank>%s\\\\n\" , vpx_codec_iface_name ( decoder -> interface ( ) ) ) ; <S2SV_EndBug> <S2SV_StartBug> if ( vpx_codec_dec_init ( & codec , decoder -> interface ( ) , NULL , 0 ) ) <S2SV_EndBug> die_codec ( & codec , \"Failed<S2SV_blank>to<S2SV_blank>initialize<S2SV_blank>decoder.\" ) ; while ( vpx_video_reader_read_frame ( reader ) ) { vpx_codec_iter_t iter = NULL ; vpx_image_t * img = NULL ; size_t frame_size = 0 ; int skip ; const unsigned char * frame = vpx_video_reader_get_frame ( reader , & frame_size ) ; if ( vpx_codec_decode ( & codec , frame , ( unsigned int ) frame_size , NULL , 0 ) ) die_codec ( & codec , \"Failed<S2SV_blank>to<S2SV_blank>decode<S2SV_blank>frame.\" ) ; ++ frame_cnt ; skip = ( is_range && frame_cnt >= n && frame_cnt <= m ) || ( ! is_range && m - ( frame_cnt - 1 ) % m <= n ) ; if ( ! skip ) { putc ( '.' , stdout ) ; while ( ( img = vpx_codec_get_frame ( & codec , & iter ) ) != NULL ) vpx_img_write ( img , outfile ) ; } else { putc ( 'X' , stdout ) ; } fflush ( stdout ) ; } printf ( \"Processed<S2SV_blank>%d<S2SV_blank>frames.\\\\n\" , frame_cnt ) ; if ( vpx_codec_destroy ( & codec ) ) die_codec ( & codec , \"Failed<S2SV_blank>to<S2SV_blank>destroy<S2SV_blank>codec.\" ) ; printf ( \"Play:<S2SV_blank>ffplay<S2SV_blank>-f<S2SV_blank>rawvideo<S2SV_blank>-pix_fmt<S2SV_blank>yuv420p<S2SV_blank>-s<S2SV_blank>%dx%d<S2SV_blank>%s\\\\n\" , info -> frame_width , info -> frame_height , argv [ 2 ] ) ; vpx_video_reader_close ( reader ) ; fclose ( outfile ) ; return EXIT_SUCCESS ; }\n      |    ^\n2 errors generated.\n",
      "error_message": null
    },
    {
      "cve_id": "CVE-2020-14954",
      "tool_name": "GCC Security Warnings",
      "detected": true,
      "confidence": 0.25,
      "detection_time": 0.025304079055786133,
      "tool_output": "/var/folders/ql/btm7z5tx32ddpsky8z3bz4_r0000gn/T/tmpiu5_d2ty.c:1:1: error: unknown type name 'CWE'\n    1 | CWE-74 int nntp_open_connection ( struct NntpAccountData * adata ) { struct Connection * conn = adata -> conn ; char buf [ 256 ] ; int cap ; bool posting = false , auth = true ; if ( adata -> status == NNTP_OK ) return 0 ; if ( adata -> status == NNTP_BYE ) return - 1 ; adata -> status = NNTP_NONE ; if ( mutt_socket_open ( conn ) < 0 ) return - 1 ; if ( mutt_socket_readln ( buf , sizeof ( buf ) , conn ) < 0 ) return nntp_connect_error ( adata ) ; if ( mutt_str_startswith ( buf , \"200\" , CASE_MATCH ) ) posting = true ; else if ( ! mutt_str_startswith ( buf , \"201\" , CASE_MATCH ) ) { mutt_socket_close ( conn ) ; mutt_str_remove_trailing_ws ( buf ) ; mutt_error ( \"%s\" , buf ) ; return - 1 ; } cap = nntp_capabilities ( adata ) ; if ( cap < 0 ) return - 1 ; if ( cap > 0 ) { if ( ( mutt_socket_send ( conn , \"MODE<S2SV_blank>READER\\\\r\\\\n\" ) < 0 ) || ( mutt_socket_readln ( buf , sizeof ( buf ) , conn ) < 0 ) ) { return nntp_connect_error ( adata ) ; } if ( mutt_str_startswith ( buf , \"200\" , CASE_MATCH ) ) posting = true ; else if ( mutt_str_startswith ( buf , \"201\" , CASE_MATCH ) ) posting = false ; else if ( adata -> hasCAPABILITIES ) { mutt_socket_close ( conn ) ; mutt_error ( _ ( \"Could<S2SV_blank>not<S2SV_blank>switch<S2SV_blank>to<S2SV_blank>reader<S2SV_blank>mode\" ) ) ; return - 1 ; } if ( adata -> hasCAPABILITIES ) { cap = nntp_capabilities ( adata ) ; if ( cap < 0 ) return - 1 ; } } mutt_message ( _ ( \"Connected<S2SV_blank>to<S2SV_blank>%s.<S2SV_blank>%s\" ) , conn -> account . host , posting ? _ ( \"Posting<S2SV_blank>is<S2SV_blank>ok\" ) : _ ( \"Posting<S2SV_blank>is<S2SV_blank>NOT<S2SV_blank>ok\" ) ) ; mutt_sleep ( 1 ) ; # ifdef USE_SSL if ( ( adata -> use_tls != 1 ) && ( adata -> hasSTARTTLS || C_SslForceTls ) ) { if ( adata -> use_tls == 0 ) { adata -> use_tls = C_SslForceTls || query_quadoption ( C_SslStarttls , _ ( \"Secure<S2SV_blank>connection<S2SV_blank>with<S2SV_blank>TLS?\" ) ) == MUTT_YES ? 2 : 1 ; } if ( adata -> use_tls == 2 ) { if ( ( mutt_socket_send ( conn , \"STARTTLS\\\\r\\\\n\" ) < 0 ) || ( mutt_socket_readln ( buf , sizeof ( buf ) , conn ) < 0 ) ) { return nntp_connect_error ( adata ) ; <S2SV_StartBug> } <S2SV_EndBug> if ( ! mutt_str_startswith ( buf , \"382\" , CASE_MATCH ) ) { adata -> use_tls = 0 ; mutt_error ( \"STARTTLS:<S2SV_blank>%s\" , buf ) ; } else if ( mutt_ssl_starttls ( conn ) ) { adata -> use_tls = 0 ; adata -> status = NNTP_NONE ; mutt_socket_close ( adata -> conn ) ; mutt_error ( _ ( \"Could<S2SV_blank>not<S2SV_blank>negotiate<S2SV_blank>TLS<S2SV_blank>connection\" ) ) ; return - 1 ; } else { cap = nntp_capabilities ( adata ) ; if ( cap < 0 ) return - 1 ; } } } # endif if ( conn -> account . flags & MUTT_ACCT_USER ) { if ( ! conn -> account . user [ 0 ] ) auth = false ; } else { if ( ( mutt_socket_send ( conn , \"STAT\\\\r\\\\n\" ) < 0 ) || ( mutt_socket_readln ( buf , sizeof ( buf ) , conn ) < 0 ) ) { return nntp_connect_error ( adata ) ; } if ( ! mutt_str_startswith ( buf , \"480\" , CASE_MATCH ) ) auth = false ; } if ( auth && ( nntp_auth ( adata ) < 0 ) ) return - 1 ; if ( adata -> hasCAPABILITIES && ( auth || ( cap > 0 ) ) ) { cap = nntp_capabilities ( adata ) ; if ( cap < 0 ) return - 1 ; if ( cap > 0 ) { mutt_socket_close ( conn ) ; mutt_error ( _ ( \"Could<S2SV_blank>not<S2SV_blank>switch<S2SV_blank>to<S2SV_blank>reader<S2SV_blank>mode\" ) ) ; return - 1 ; } } if ( nntp_attempt_features ( adata ) < 0 ) return - 1 ; adata -> status = NNTP_OK ; return 0 ; }\n      | ^\n/var/folders/ql/btm7z5tx32ddpsky8z3bz4_r0000gn/T/tmpiu5_d2ty.c:1:4: error: expected identifier or '('\n    1 | CWE-74 int nntp_open_connection ( struct NntpAccountData * adata ) { struct Connection * conn = adata -> conn ; char buf [ 256 ] ; int cap ; bool posting = false , auth = true ; if ( adata -> status == NNTP_OK ) return 0 ; if ( adata -> status == NNTP_BYE ) return - 1 ; adata -> status = NNTP_NONE ; if ( mutt_socket_open ( conn ) < 0 ) return - 1 ; if ( mutt_socket_readln ( buf , sizeof ( buf ) , conn ) < 0 ) return nntp_connect_error ( adata ) ; if ( mutt_str_startswith ( buf , \"200\" , CASE_MATCH ) ) posting = true ; else if ( ! mutt_str_startswith ( buf , \"201\" , CASE_MATCH ) ) { mutt_socket_close ( conn ) ; mutt_str_remove_trailing_ws ( buf ) ; mutt_error ( \"%s\" , buf ) ; return - 1 ; } cap = nntp_capabilities ( adata ) ; if ( cap < 0 ) return - 1 ; if ( cap > 0 ) { if ( ( mutt_socket_send ( conn , \"MODE<S2SV_blank>READER\\\\r\\\\n\" ) < 0 ) || ( mutt_socket_readln ( buf , sizeof ( buf ) , conn ) < 0 ) ) { return nntp_connect_error ( adata ) ; } if ( mutt_str_startswith ( buf , \"200\" , CASE_MATCH ) ) posting = true ; else if ( mutt_str_startswith ( buf , \"201\" , CASE_MATCH ) ) posting = false ; else if ( adata -> hasCAPABILITIES ) { mutt_socket_close ( conn ) ; mutt_error ( _ ( \"Could<S2SV_blank>not<S2SV_blank>switch<S2SV_blank>to<S2SV_blank>reader<S2SV_blank>mode\" ) ) ; return - 1 ; } if ( adata -> hasCAPABILITIES ) { cap = nntp_capabilities ( adata ) ; if ( cap < 0 ) return - 1 ; } } mutt_message ( _ ( \"Connected<S2SV_blank>to<S2SV_blank>%s.<S2SV_blank>%s\" ) , conn -> account . host , posting ? _ ( \"Posting<S2SV_blank>is<S2SV_blank>ok\" ) : _ ( \"Posting<S2SV_blank>is<S2SV_blank>NOT<S2SV_blank>ok\" ) ) ; mutt_sleep ( 1 ) ; # ifdef USE_SSL if ( ( adata -> use_tls != 1 ) && ( adata -> hasSTARTTLS || C_SslForceTls ) ) { if ( adata -> use_tls == 0 ) { adata -> use_tls = C_SslForceTls || query_quadoption ( C_SslStarttls , _ ( \"Secure<S2SV_blank>connection<S2SV_blank>with<S2SV_blank>TLS?\" ) ) == MUTT_YES ? 2 : 1 ; } if ( adata -> use_tls == 2 ) { if ( ( mutt_socket_send ( conn , \"STARTTLS\\\\r\\\\n\" ) < 0 ) || ( mutt_socket_readln ( buf , sizeof ( buf ) , conn ) < 0 ) ) { return nntp_connect_error ( adata ) ; <S2SV_StartBug> } <S2SV_EndBug> if ( ! mutt_str_startswith ( buf , \"382\" , CASE_MATCH ) ) { adata -> use_tls = 0 ; mutt_error ( \"STARTTLS:<S2SV_blank>%s\" , buf ) ; } else if ( mutt_ssl_starttls ( conn ) ) { adata -> use_tls = 0 ; adata -> status = NNTP_NONE ; mutt_socket_close ( adata -> conn ) ; mutt_error ( _ ( \"Could<S2SV_blank>not<S2SV_blank>negotiate<S2SV_blank>TLS<S2SV_blank>connection\" ) ) ; return - 1 ; } else { cap = nntp_capabilities ( adata ) ; if ( cap < 0 ) return - 1 ; } } } # endif if ( conn -> account . flags & MUTT_ACCT_USER ) { if ( ! conn -> account . user [ 0 ] ) auth = false ; } else { if ( ( mutt_socket_send ( conn , \"STAT\\\\r\\\\n\" ) < 0 ) || ( mutt_socket_readln ( buf , sizeof ( buf ) , conn ) < 0 ) ) { return nntp_connect_error ( adata ) ; } if ( ! mutt_str_startswith ( buf , \"480\" , CASE_MATCH ) ) auth = false ; } if ( auth && ( nntp_auth ( adata ) < 0 ) ) return - 1 ; if ( adata -> hasCAPABILITIES && ( auth || ( cap > 0 ) ) ) { cap = nntp_capabilities ( adata ) ; if ( cap < 0 ) return - 1 ; if ( cap > 0 ) { mutt_socket_close ( conn ) ; mutt_error ( _ ( \"Could<S2SV_blank>not<S2SV_blank>switch<S2SV_blank>to<S2SV_blank>reader<S2SV_blank>mode\" ) ) ; return - 1 ; } } if ( nntp_attempt_features ( adata ) < 0 ) return - 1 ; adata -> status = NNTP_OK ; return 0 ; }\n      |    ^\n2 errors generated.\n",
      "error_message": null
    },
    {
      "cve_id": "CVE-2020-15474",
      "tool_name": "GCC Security Warnings",
      "detected": true,
      "confidence": 0.25,
      "detection_time": 0.022301912307739258,
      "tool_output": "/var/folders/ql/btm7z5tx32ddpsky8z3bz4_r0000gn/T/tmp7_rh1je0.c:1:1: error: unknown type name 'CWE'\n/var/folders/ql/btm7z5tx32ddpsky8z3bz4_r0000gn/T/tmp7_rh1je0.c:1:4: error: expected identifier or '('\n2 errors generated.\n",
      "error_message": null
    },
    {
      "cve_id": "CVE-2017-15385",
      "tool_name": "GCC Security Warnings",
      "detected": true,
      "confidence": 0.5,
      "detection_time": 0.025308847427368164,
      "tool_output": "/var/folders/ql/btm7z5tx32ddpsky8z3bz4_r0000gn/T/tmph_dd26n2.c:1:1: error: unknown type name 'CWE'\n    1 | CWE-119 static Sdb * store_versioninfo_gnu_verdef ( ELFOBJ * bin , Elf_ ( Shdr ) * shdr , int sz ) { const char * section_name = \"\" ; const char * link_section_name = \"\" ; char * end = NULL ; Elf_ ( Shdr ) * link_shdr = NULL ; ut8 dfs [ sizeof ( Elf_ ( Verdef ) ) ] = { 0 } ; Sdb * sdb ; int cnt , i ; if ( shdr -> sh_link > bin -> ehdr . e_shnum ) { return false ; } link_shdr = & bin -> shdr [ shdr -> sh_link ] ; if ( shdr -> sh_size < 1 ) { return false ; } Elf_ ( Verdef ) * defs = calloc ( shdr -> sh_size , sizeof ( char ) ) ; if ( ! defs ) { return false ; } if ( bin -> shstrtab && shdr -> sh_name < bin -> shstrtab_size ) { section_name = & bin -> shstrtab [ shdr -> sh_name ] ; } if ( link_shdr && bin -> shstrtab && link_shdr -> sh_name < bin -> shstrtab_size ) { link_section_name = & bin -> shstrtab [ link_shdr -> sh_name ] ; } if ( ! defs ) { bprintf ( \"Warning:<S2SV_blank>Cannot<S2SV_blank>allocate<S2SV_blank>memory<S2SV_blank>(Check<S2SV_blank>Elf_(Verdef))\\\\n\" ) ; return NULL ; } sdb = sdb_new0 ( ) ; end = ( char * ) defs + shdr -> sh_size ; sdb_set ( sdb , \"section_name\" , section_name , 0 ) ; sdb_num_set ( sdb , \"entries\" , shdr -> sh_info , 0 ) ; sdb_num_set ( sdb , \"addr\" , shdr -> sh_addr , 0 ) ; sdb_num_set ( sdb , \"offset\" , shdr -> sh_offset , 0 ) ; sdb_num_set ( sdb , \"link\" , shdr -> sh_link , 0 ) ; sdb_set ( sdb , \"link_section_name\" , link_section_name , 0 ) ; <S2SV_StartBug> for ( cnt = 0 , i = 0 ; cnt < shdr -> sh_info && ( ( char * ) defs + i < end ) ; ++ cnt ) { <S2SV_EndBug> Sdb * sdb_verdef = sdb_new0 ( ) ; char * vstart = ( ( char * ) defs ) + i ; char key [ 32 ] = { 0 } ; Elf_ ( Verdef ) * verdef = ( Elf_ ( Verdef ) * ) vstart ; Elf_ ( Verdaux ) aux = { 0 } ; int j = 0 ; int isum = 0 ; r_buf_read_at ( bin -> b , shdr -> sh_offset + i , dfs , sizeof ( Elf_ ( Verdef ) ) ) ; verdef -> vd_version = READ16 ( dfs , j ) verdef -> vd_flags = READ16 ( dfs , j ) verdef -> vd_ndx = READ16 ( dfs , j ) verdef -> vd_cnt = READ16 ( dfs , j ) verdef -> vd_hash = READ32 ( dfs , j ) verdef -> vd_aux = READ32 ( dfs , j ) verdef -> vd_next = READ32 ( dfs , j ) vstart += verdef -> vd_aux ; if ( vstart > end || vstart + sizeof ( Elf_ ( Verdaux ) ) > end ) { sdb_free ( sdb_verdef ) ; goto out_error ; } j = 0 ; aux . vda_name = READ32 ( vstart , j ) aux . vda_next = READ32 ( vstart , j ) isum = i + verdef -> vd_aux ; if ( aux . vda_name > bin -> dynstr_size ) { sdb_free ( sdb_verdef ) ; goto out_error ; } sdb_num_set ( sdb_verdef , \"idx\" , i , 0 ) ; sdb_num_set ( sdb_verdef , \"vd_version\" , verdef -> vd_version , 0 ) ; sdb_num_set ( sdb_verdef , \"vd_ndx\" , verdef -> vd_ndx , 0 ) ; sdb_num_set ( sdb_verdef , \"vd_cnt\" , verdef -> vd_cnt , 0 ) ; sdb_set ( sdb_verdef , \"vda_name\" , & bin -> dynstr [ aux . vda_name ] , 0 ) ; sdb_set ( sdb_verdef , \"flags\" , get_ver_flags ( verdef -> vd_flags ) , 0 ) ; for ( j = 1 ; j < verdef -> vd_cnt ; ++ j ) { int k ; Sdb * sdb_parent = sdb_new0 ( ) ; isum += aux . vda_next ; vstart += aux . vda_next ; if ( vstart > end || vstart + sizeof ( Elf_ ( Verdaux ) ) > end ) { sdb_free ( sdb_verdef ) ; sdb_free ( sdb_parent ) ; goto out_error ; } k = 0 ; aux . vda_name = READ32 ( vstart , k ) aux . vda_next = READ32 ( vstart , k ) if ( aux . vda_name > bin -> dynstr_size ) { sdb_free ( sdb_verdef ) ; sdb_free ( sdb_parent ) ; goto out_error ; } sdb_num_set ( sdb_parent , \"idx\" , isum , 0 ) ; sdb_num_set ( sdb_parent , \"parent\" , j , 0 ) ; sdb_set ( sdb_parent , \"vda_name\" , & bin -> dynstr [ aux . vda_name ] , 0 ) ; snprintf ( key , sizeof ( key ) , \"parent%d\" , j - 1 ) ; sdb_ns_set ( sdb_verdef , key , sdb_parent ) ; } snprintf ( key , sizeof ( key ) , \"verdef%d\" , cnt ) ; sdb_ns_set ( sdb , key , sdb_verdef ) ; if ( ! verdef -> vd_next ) { sdb_free ( sdb_verdef ) ; goto out_error ; } <S2SV_StartBug> i += verdef -> vd_next ; <S2SV_EndBug> } free ( defs ) ; return sdb ; out_error : free ( defs ) ; sdb_free ( sdb ) ; return NULL ; }\n      | ^\n/var/folders/ql/btm7z5tx32ddpsky8z3bz4_r0000gn/T/tmph_dd26n2.c:1:4: error: expected identifier or '('\n    1 | CWE-119 static Sdb * store_versioninfo_gnu_verdef ( ELFOBJ * bin , Elf_ ( Shdr ) * shdr , int sz ) { const char * section_name = \"\" ; const char * link_section_name = \"\" ; char * end = NULL ; Elf_ ( Shdr ) * link_shdr = NULL ; ut8 dfs [ sizeof ( Elf_ ( Verdef ) ) ] = { 0 } ; Sdb * sdb ; int cnt , i ; if ( shdr -> sh_link > bin -> ehdr . e_shnum ) { return false ; } link_shdr = & bin -> shdr [ shdr -> sh_link ] ; if ( shdr -> sh_size < 1 ) { return false ; } Elf_ ( Verdef ) * defs = calloc ( shdr -> sh_size , sizeof ( char ) ) ; if ( ! defs ) { return false ; } if ( bin -> shstrtab && shdr -> sh_name < bin -> shstrtab_size ) { section_name = & bin -> shstrtab [ shdr -> sh_name ] ; } if ( link_shdr && bin -> shstrtab && link_shdr -> sh_name < bin -> shstrtab_size ) { link_section_name = & bin -> shstrtab [ link_shdr -> sh_name ] ; } if ( ! defs ) { bprintf ( \"Warning:<S2SV_blank>Cannot<S2SV_blank>allocate<S2SV_blank>memory<S2SV_blank>(Check<S2SV_blank>Elf_(Verdef))\\\\n\" ) ; return NULL ; } sdb = sdb_new0 ( ) ; end = ( char * ) defs + shdr -> sh_size ; sdb_set ( sdb , \"section_name\" , section_name , 0 ) ; sdb_num_set ( sdb , \"entries\" , shdr -> sh_info , 0 ) ; sdb_num_set ( sdb , \"addr\" , shdr -> sh_addr , 0 ) ; sdb_num_set ( sdb , \"offset\" , shdr -> sh_offset , 0 ) ; sdb_num_set ( sdb , \"link\" , shdr -> sh_link , 0 ) ; sdb_set ( sdb , \"link_section_name\" , link_section_name , 0 ) ; <S2SV_StartBug> for ( cnt = 0 , i = 0 ; cnt < shdr -> sh_info && ( ( char * ) defs + i < end ) ; ++ cnt ) { <S2SV_EndBug> Sdb * sdb_verdef = sdb_new0 ( ) ; char * vstart = ( ( char * ) defs ) + i ; char key [ 32 ] = { 0 } ; Elf_ ( Verdef ) * verdef = ( Elf_ ( Verdef ) * ) vstart ; Elf_ ( Verdaux ) aux = { 0 } ; int j = 0 ; int isum = 0 ; r_buf_read_at ( bin -> b , shdr -> sh_offset + i , dfs , sizeof ( Elf_ ( Verdef ) ) ) ; verdef -> vd_version = READ16 ( dfs , j ) verdef -> vd_flags = READ16 ( dfs , j ) verdef -> vd_ndx = READ16 ( dfs , j ) verdef -> vd_cnt = READ16 ( dfs , j ) verdef -> vd_hash = READ32 ( dfs , j ) verdef -> vd_aux = READ32 ( dfs , j ) verdef -> vd_next = READ32 ( dfs , j ) vstart += verdef -> vd_aux ; if ( vstart > end || vstart + sizeof ( Elf_ ( Verdaux ) ) > end ) { sdb_free ( sdb_verdef ) ; goto out_error ; } j = 0 ; aux . vda_name = READ32 ( vstart , j ) aux . vda_next = READ32 ( vstart , j ) isum = i + verdef -> vd_aux ; if ( aux . vda_name > bin -> dynstr_size ) { sdb_free ( sdb_verdef ) ; goto out_error ; } sdb_num_set ( sdb_verdef , \"idx\" , i , 0 ) ; sdb_num_set ( sdb_verdef , \"vd_version\" , verdef -> vd_version , 0 ) ; sdb_num_set ( sdb_verdef , \"vd_ndx\" , verdef -> vd_ndx , 0 ) ; sdb_num_set ( sdb_verdef , \"vd_cnt\" , verdef -> vd_cnt , 0 ) ; sdb_set ( sdb_verdef , \"vda_name\" , & bin -> dynstr [ aux . vda_name ] , 0 ) ; sdb_set ( sdb_verdef , \"flags\" , get_ver_flags ( verdef -> vd_flags ) , 0 ) ; for ( j = 1 ; j < verdef -> vd_cnt ; ++ j ) { int k ; Sdb * sdb_parent = sdb_new0 ( ) ; isum += aux . vda_next ; vstart += aux . vda_next ; if ( vstart > end || vstart + sizeof ( Elf_ ( Verdaux ) ) > end ) { sdb_free ( sdb_verdef ) ; sdb_free ( sdb_parent ) ; goto out_error ; } k = 0 ; aux . vda_name = READ32 ( vstart , k ) aux . vda_next = READ32 ( vstart , k ) if ( aux . vda_name > bin -> dynstr_size ) { sdb_free ( sdb_verdef ) ; sdb_free ( sdb_parent ) ; goto out_error ; } sdb_num_set ( sdb_parent , \"idx\" , isum , 0 ) ; sdb_num_set ( sdb_parent , \"parent\" , j , 0 ) ; sdb_set ( sdb_parent , \"vda_name\" , & bin -> dynstr [ aux . vda_name ] , 0 ) ; snprintf ( key , sizeof ( key ) , \"parent%d\" , j - 1 ) ; sdb_ns_set ( sdb_verdef , key , sdb_parent ) ; } snprintf ( key , sizeof ( key ) , \"verdef%d\" , cnt ) ; sdb_ns_set ( sdb , key , sdb_verdef ) ; if ( ! verdef -> vd_next ) { sdb_free ( sdb_verdef ) ; goto out_error ; } <S2SV_StartBug> i += verdef -> vd_next ; <S2SV_EndBug> } free ( defs ) ; return sdb ; out_error : free ( defs ) ; sdb_free ( sdb ) ; return NULL ; }\n      |    ^\n2 errors generated.\n",
      "error_message": null
    },
    {
      "cve_id": "CVE-2019-19275",
      "tool_name": "GCC Security Warnings",
      "detected": true,
      "confidence": 0.25,
      "detection_time": 0.0225069522857666,
      "tool_output": "/var/folders/ql/btm7z5tx32ddpsky8z3bz4_r0000gn/T/tmp2a2_7ir1.c:1:1: error: unknown type name 'CWE'\n/var/folders/ql/btm7z5tx32ddpsky8z3bz4_r0000gn/T/tmp2a2_7ir1.c:1:4: error: expected identifier or '('\n2 errors generated.\n",
      "error_message": null
    },
    {
      "cve_id": "CVE-2019-19481",
      "tool_name": "GCC Security Warnings",
      "detected": true,
      "confidence": 0.25,
      "detection_time": 0.023640155792236328,
      "tool_output": "/var/folders/ql/btm7z5tx32ddpsky8z3bz4_r0000gn/T/tmpsxaoagoh.c:1:1: error: unknown type name 'CWE'\n    1 | CWE-119 static int cac_read_binary ( sc_card_t * card , unsigned int idx , unsigned char * buf , size_t count , unsigned long flags ) { cac_private_data_t * priv = CAC_DATA ( card ) ; int r = 0 ; u8 * val = NULL ; u8 * cert_ptr ; <S2SV_StartBug> size_t val_len ; <S2SV_EndBug> size_t len , cert_len ; u8 cert_type ; SC_FUNC_CALLED ( card -> ctx , SC_LOG_DEBUG_VERBOSE ) ; if ( priv -> cached ) { sc_log ( card -> ctx , \"returning<S2SV_blank>cached<S2SV_blank>value<S2SV_blank>idx=%d<S2SV_blank>count=%\" SC_FORMAT_LEN_SIZE_T \"u\" , idx , count ) ; if ( idx > priv -> cache_buf_len ) { LOG_FUNC_RETURN ( card -> ctx , SC_ERROR_FILE_END_REACHED ) ; } len = MIN ( count , priv -> cache_buf_len - idx ) ; memcpy ( buf , & priv -> cache_buf [ idx ] , len ) ; LOG_FUNC_RETURN ( card -> ctx , len ) ; } sc_log ( card -> ctx , \"clearing<S2SV_blank>cache<S2SV_blank>idx=%d<S2SV_blank>count=%\" SC_FORMAT_LEN_SIZE_T \"u\" , idx , count ) ; free ( priv -> cache_buf ) ; priv -> cache_buf = NULL ; priv -> cache_buf_len = 0 ; r = cac_cac1_get_certificate ( card , & val , & val_len ) ; if ( r < 0 ) goto done ; if ( val_len < 1 ) { r = SC_ERROR_INVALID_DATA ; goto done ; } cert_type = val [ 0 ] ; cert_ptr = val + 1 ; cert_len = val_len - 1 ; if ( ( cert_type & 0x3 ) == 1 ) { # ifdef ENABLE_ZLIB r = sc_decompress_alloc ( & priv -> cache_buf , & priv -> cache_buf_len , cert_ptr , cert_len , COMPRESSION_AUTO ) ; # else sc_log ( card -> ctx , \"CAC<S2SV_blank>compression<S2SV_blank>not<S2SV_blank>supported,<S2SV_blank>no<S2SV_blank>zlib\" ) ; r = SC_ERROR_NOT_SUPPORTED ; # endif if ( r ) goto done ; } else if ( cert_len > 0 ) { priv -> cache_buf = malloc ( cert_len ) ; if ( priv -> cache_buf == NULL ) { r = SC_ERROR_OUT_OF_MEMORY ; goto done ; } priv -> cache_buf_len = cert_len ; memcpy ( priv -> cache_buf , cert_ptr , cert_len ) ; } priv -> cached = 1 ; len = MIN ( count , priv -> cache_buf_len - idx ) ; if ( len && priv -> cache_buf ) memcpy ( buf , & priv -> cache_buf [ idx ] , len ) ; r = len ; done : if ( val ) free ( val ) ; LOG_FUNC_RETURN ( card -> ctx , r ) ; }\n      | ^\n/var/folders/ql/btm7z5tx32ddpsky8z3bz4_r0000gn/T/tmpsxaoagoh.c:1:4: error: expected identifier or '('\n    1 | CWE-119 static int cac_read_binary ( sc_card_t * card , unsigned int idx , unsigned char * buf , size_t count , unsigned long flags ) { cac_private_data_t * priv = CAC_DATA ( card ) ; int r = 0 ; u8 * val = NULL ; u8 * cert_ptr ; <S2SV_StartBug> size_t val_len ; <S2SV_EndBug> size_t len , cert_len ; u8 cert_type ; SC_FUNC_CALLED ( card -> ctx , SC_LOG_DEBUG_VERBOSE ) ; if ( priv -> cached ) { sc_log ( card -> ctx , \"returning<S2SV_blank>cached<S2SV_blank>value<S2SV_blank>idx=%d<S2SV_blank>count=%\" SC_FORMAT_LEN_SIZE_T \"u\" , idx , count ) ; if ( idx > priv -> cache_buf_len ) { LOG_FUNC_RETURN ( card -> ctx , SC_ERROR_FILE_END_REACHED ) ; } len = MIN ( count , priv -> cache_buf_len - idx ) ; memcpy ( buf , & priv -> cache_buf [ idx ] , len ) ; LOG_FUNC_RETURN ( card -> ctx , len ) ; } sc_log ( card -> ctx , \"clearing<S2SV_blank>cache<S2SV_blank>idx=%d<S2SV_blank>count=%\" SC_FORMAT_LEN_SIZE_T \"u\" , idx , count ) ; free ( priv -> cache_buf ) ; priv -> cache_buf = NULL ; priv -> cache_buf_len = 0 ; r = cac_cac1_get_certificate ( card , & val , & val_len ) ; if ( r < 0 ) goto done ; if ( val_len < 1 ) { r = SC_ERROR_INVALID_DATA ; goto done ; } cert_type = val [ 0 ] ; cert_ptr = val + 1 ; cert_len = val_len - 1 ; if ( ( cert_type & 0x3 ) == 1 ) { # ifdef ENABLE_ZLIB r = sc_decompress_alloc ( & priv -> cache_buf , & priv -> cache_buf_len , cert_ptr , cert_len , COMPRESSION_AUTO ) ; # else sc_log ( card -> ctx , \"CAC<S2SV_blank>compression<S2SV_blank>not<S2SV_blank>supported,<S2SV_blank>no<S2SV_blank>zlib\" ) ; r = SC_ERROR_NOT_SUPPORTED ; # endif if ( r ) goto done ; } else if ( cert_len > 0 ) { priv -> cache_buf = malloc ( cert_len ) ; if ( priv -> cache_buf == NULL ) { r = SC_ERROR_OUT_OF_MEMORY ; goto done ; } priv -> cache_buf_len = cert_len ; memcpy ( priv -> cache_buf , cert_ptr , cert_len ) ; } priv -> cached = 1 ; len = MIN ( count , priv -> cache_buf_len - idx ) ; if ( len && priv -> cache_buf ) memcpy ( buf , & priv -> cache_buf [ idx ] , len ) ; r = len ; done : if ( val ) free ( val ) ; LOG_FUNC_RETURN ( card -> ctx , r ) ; }\n      |    ^\n2 errors generated.\n",
      "error_message": null
    },
    {
      "cve_id": "CVE-2019-13308",
      "tool_name": "GCC Security Warnings",
      "detected": true,
      "confidence": 0.25,
      "detection_time": 0.022027969360351562,
      "tool_output": "/var/folders/ql/btm7z5tx32ddpsky8z3bz4_r0000gn/T/tmp2zlvn09k.c:1:1: error: unknown type name 'CWE'\n/var/folders/ql/btm7z5tx32ddpsky8z3bz4_r0000gn/T/tmp2zlvn09k.c:1:4: error: expected identifier or '('\n2 errors generated.\n",
      "error_message": null
    },
    {
      "cve_id": "CVE-2018-1999011",
      "tool_name": "GCC Security Warnings",
      "detected": true,
      "confidence": 0.25,
      "detection_time": 0.021969318389892578,
      "tool_output": "/var/folders/ql/btm7z5tx32ddpsky8z3bz4_r0000gn/T/tmpdjyjvvs2.c:1:1: error: unknown type name 'CWE'\n    1 | CWE-119 static int parse_video_info ( AVIOContext * pb , AVStream * st ) { uint16_t size_asf ; uint32_t size_bmp ; unsigned int tag ; st -> codecpar -> width = avio_rl32 ( pb ) ; st -> codecpar -> height = avio_rl32 ( pb ) ; avio_skip ( pb , 1 ) ; size_asf = avio_rl16 ( pb ) ; tag = ff_get_bmp_header ( pb , st , & size_bmp ) ; st -> codecpar -> codec_tag = tag ; st -> codecpar -> codec_id = ff_codec_get_id ( ff_codec_bmp_tags , tag ) ; size_bmp = FFMAX ( size_asf , size_bmp ) ; <S2SV_StartBug> if ( size_bmp > BMP_HEADER_SIZE ) { <S2SV_EndBug> int ret ; st -> codecpar -> extradata_size = size_bmp - BMP_HEADER_SIZE ; if ( ! ( st -> codecpar -> extradata = av_malloc ( st -> codecpar -> extradata_size + AV_INPUT_BUFFER_PADDING_SIZE ) ) ) { st -> codecpar -> extradata_size = 0 ; return AVERROR ( ENOMEM ) ; } memset ( st -> codecpar -> extradata + st -> codecpar -> extradata_size , 0 , AV_INPUT_BUFFER_PADDING_SIZE ) ; if ( ( ret = avio_read ( pb , st -> codecpar -> extradata , st -> codecpar -> extradata_size ) ) < 0 ) return ret ; } return 0 ; }\n      | ^\n/var/folders/ql/btm7z5tx32ddpsky8z3bz4_r0000gn/T/tmpdjyjvvs2.c:1:4: error: expected identifier or '('\n    1 | CWE-119 static int parse_video_info ( AVIOContext * pb , AVStream * st ) { uint16_t size_asf ; uint32_t size_bmp ; unsigned int tag ; st -> codecpar -> width = avio_rl32 ( pb ) ; st -> codecpar -> height = avio_rl32 ( pb ) ; avio_skip ( pb , 1 ) ; size_asf = avio_rl16 ( pb ) ; tag = ff_get_bmp_header ( pb , st , & size_bmp ) ; st -> codecpar -> codec_tag = tag ; st -> codecpar -> codec_id = ff_codec_get_id ( ff_codec_bmp_tags , tag ) ; size_bmp = FFMAX ( size_asf , size_bmp ) ; <S2SV_StartBug> if ( size_bmp > BMP_HEADER_SIZE ) { <S2SV_EndBug> int ret ; st -> codecpar -> extradata_size = size_bmp - BMP_HEADER_SIZE ; if ( ! ( st -> codecpar -> extradata = av_malloc ( st -> codecpar -> extradata_size + AV_INPUT_BUFFER_PADDING_SIZE ) ) ) { st -> codecpar -> extradata_size = 0 ; return AVERROR ( ENOMEM ) ; } memset ( st -> codecpar -> extradata + st -> codecpar -> extradata_size , 0 , AV_INPUT_BUFFER_PADDING_SIZE ) ; if ( ( ret = avio_read ( pb , st -> codecpar -> extradata , st -> codecpar -> extradata_size ) ) < 0 ) return ret ; } return 0 ; }\n      |    ^\n2 errors generated.\n",
      "error_message": null
    },
    {
      "cve_id": "CVE-2017-15385",
      "tool_name": "GCC Security Warnings",
      "detected": true,
      "confidence": 0.5,
      "detection_time": 0.023631811141967773,
      "tool_output": "/var/folders/ql/btm7z5tx32ddpsky8z3bz4_r0000gn/T/tmpgnz0a7v1.c:1:1: error: unknown type name 'CWE'\n    1 | CWE-119 static Sdb * store_versioninfo_gnu_verdef ( ELFOBJ * bin , Elf_ ( Shdr ) * shdr , int sz ) { const char * section_name = \"\" ; const char * link_section_name = \"\" ; char * end = NULL ; Elf_ ( Shdr ) * link_shdr = NULL ; ut8 dfs [ sizeof ( Elf_ ( Verdef ) ) ] = { 0 } ; Sdb * sdb ; int cnt , i ; if ( shdr -> sh_link > bin -> ehdr . e_shnum ) { return false ; } link_shdr = & bin -> shdr [ shdr -> sh_link ] ; if ( shdr -> sh_size < 1 ) { return false ; } Elf_ ( Verdef ) * defs = calloc ( shdr -> sh_size , sizeof ( char ) ) ; if ( ! defs ) { return false ; } if ( bin -> shstrtab && shdr -> sh_name < bin -> shstrtab_size ) { section_name = & bin -> shstrtab [ shdr -> sh_name ] ; } if ( link_shdr && bin -> shstrtab && link_shdr -> sh_name < bin -> shstrtab_size ) { link_section_name = & bin -> shstrtab [ link_shdr -> sh_name ] ; } if ( ! defs ) { bprintf ( \"Warning:<S2SV_blank>Cannot<S2SV_blank>allocate<S2SV_blank>memory<S2SV_blank>(Check<S2SV_blank>Elf_(Verdef))\\\\n\" ) ; return NULL ; } sdb = sdb_new0 ( ) ; end = ( char * ) defs + shdr -> sh_size ; sdb_set ( sdb , \"section_name\" , section_name , 0 ) ; sdb_num_set ( sdb , \"entries\" , shdr -> sh_info , 0 ) ; sdb_num_set ( sdb , \"addr\" , shdr -> sh_addr , 0 ) ; sdb_num_set ( sdb , \"offset\" , shdr -> sh_offset , 0 ) ; sdb_num_set ( sdb , \"link\" , shdr -> sh_link , 0 ) ; sdb_set ( sdb , \"link_section_name\" , link_section_name , 0 ) ; <S2SV_StartBug> for ( cnt = 0 , i = 0 ; cnt < shdr -> sh_info && ( ( char * ) defs + i < end ) ; ++ cnt ) { <S2SV_EndBug> Sdb * sdb_verdef = sdb_new0 ( ) ; char * vstart = ( ( char * ) defs ) + i ; char key [ 32 ] = { 0 } ; Elf_ ( Verdef ) * verdef = ( Elf_ ( Verdef ) * ) vstart ; Elf_ ( Verdaux ) aux = { 0 } ; int j = 0 ; int isum = 0 ; r_buf_read_at ( bin -> b , shdr -> sh_offset + i , dfs , sizeof ( Elf_ ( Verdef ) ) ) ; verdef -> vd_version = READ16 ( dfs , j ) verdef -> vd_flags = READ16 ( dfs , j ) verdef -> vd_ndx = READ16 ( dfs , j ) verdef -> vd_cnt = READ16 ( dfs , j ) verdef -> vd_hash = READ32 ( dfs , j ) verdef -> vd_aux = READ32 ( dfs , j ) verdef -> vd_next = READ32 ( dfs , j ) vstart += verdef -> vd_aux ; if ( vstart > end || vstart + sizeof ( Elf_ ( Verdaux ) ) > end ) { sdb_free ( sdb_verdef ) ; goto out_error ; } j = 0 ; aux . vda_name = READ32 ( vstart , j ) aux . vda_next = READ32 ( vstart , j ) isum = i + verdef -> vd_aux ; if ( aux . vda_name > bin -> dynstr_size ) { sdb_free ( sdb_verdef ) ; goto out_error ; } sdb_num_set ( sdb_verdef , \"idx\" , i , 0 ) ; sdb_num_set ( sdb_verdef , \"vd_version\" , verdef -> vd_version , 0 ) ; sdb_num_set ( sdb_verdef , \"vd_ndx\" , verdef -> vd_ndx , 0 ) ; sdb_num_set ( sdb_verdef , \"vd_cnt\" , verdef -> vd_cnt , 0 ) ; sdb_set ( sdb_verdef , \"vda_name\" , & bin -> dynstr [ aux . vda_name ] , 0 ) ; sdb_set ( sdb_verdef , \"flags\" , get_ver_flags ( verdef -> vd_flags ) , 0 ) ; for ( j = 1 ; j < verdef -> vd_cnt ; ++ j ) { int k ; Sdb * sdb_parent = sdb_new0 ( ) ; isum += aux . vda_next ; vstart += aux . vda_next ; if ( vstart > end || vstart + sizeof ( Elf_ ( Verdaux ) ) > end ) { sdb_free ( sdb_verdef ) ; sdb_free ( sdb_parent ) ; goto out_error ; } k = 0 ; aux . vda_name = READ32 ( vstart , k ) aux . vda_next = READ32 ( vstart , k ) if ( aux . vda_name > bin -> dynstr_size ) { sdb_free ( sdb_verdef ) ; sdb_free ( sdb_parent ) ; goto out_error ; } sdb_num_set ( sdb_parent , \"idx\" , isum , 0 ) ; sdb_num_set ( sdb_parent , \"parent\" , j , 0 ) ; sdb_set ( sdb_parent , \"vda_name\" , & bin -> dynstr [ aux . vda_name ] , 0 ) ; snprintf ( key , sizeof ( key ) , \"parent%d\" , j - 1 ) ; sdb_ns_set ( sdb_verdef , key , sdb_parent ) ; } snprintf ( key , sizeof ( key ) , \"verdef%d\" , cnt ) ; sdb_ns_set ( sdb , key , sdb_verdef ) ; if ( ! verdef -> vd_next ) { sdb_free ( sdb_verdef ) ; goto out_error ; } <S2SV_StartBug> i += verdef -> vd_next ; <S2SV_EndBug> } free ( defs ) ; return sdb ; out_error : free ( defs ) ; sdb_free ( sdb ) ; return NULL ; }\n      | ^\n/var/folders/ql/btm7z5tx32ddpsky8z3bz4_r0000gn/T/tmpgnz0a7v1.c:1:4: error: expected identifier or '('\n    1 | CWE-119 static Sdb * store_versioninfo_gnu_verdef ( ELFOBJ * bin , Elf_ ( Shdr ) * shdr , int sz ) { const char * section_name = \"\" ; const char * link_section_name = \"\" ; char * end = NULL ; Elf_ ( Shdr ) * link_shdr = NULL ; ut8 dfs [ sizeof ( Elf_ ( Verdef ) ) ] = { 0 } ; Sdb * sdb ; int cnt , i ; if ( shdr -> sh_link > bin -> ehdr . e_shnum ) { return false ; } link_shdr = & bin -> shdr [ shdr -> sh_link ] ; if ( shdr -> sh_size < 1 ) { return false ; } Elf_ ( Verdef ) * defs = calloc ( shdr -> sh_size , sizeof ( char ) ) ; if ( ! defs ) { return false ; } if ( bin -> shstrtab && shdr -> sh_name < bin -> shstrtab_size ) { section_name = & bin -> shstrtab [ shdr -> sh_name ] ; } if ( link_shdr && bin -> shstrtab && link_shdr -> sh_name < bin -> shstrtab_size ) { link_section_name = & bin -> shstrtab [ link_shdr -> sh_name ] ; } if ( ! defs ) { bprintf ( \"Warning:<S2SV_blank>Cannot<S2SV_blank>allocate<S2SV_blank>memory<S2SV_blank>(Check<S2SV_blank>Elf_(Verdef))\\\\n\" ) ; return NULL ; } sdb = sdb_new0 ( ) ; end = ( char * ) defs + shdr -> sh_size ; sdb_set ( sdb , \"section_name\" , section_name , 0 ) ; sdb_num_set ( sdb , \"entries\" , shdr -> sh_info , 0 ) ; sdb_num_set ( sdb , \"addr\" , shdr -> sh_addr , 0 ) ; sdb_num_set ( sdb , \"offset\" , shdr -> sh_offset , 0 ) ; sdb_num_set ( sdb , \"link\" , shdr -> sh_link , 0 ) ; sdb_set ( sdb , \"link_section_name\" , link_section_name , 0 ) ; <S2SV_StartBug> for ( cnt = 0 , i = 0 ; cnt < shdr -> sh_info && ( ( char * ) defs + i < end ) ; ++ cnt ) { <S2SV_EndBug> Sdb * sdb_verdef = sdb_new0 ( ) ; char * vstart = ( ( char * ) defs ) + i ; char key [ 32 ] = { 0 } ; Elf_ ( Verdef ) * verdef = ( Elf_ ( Verdef ) * ) vstart ; Elf_ ( Verdaux ) aux = { 0 } ; int j = 0 ; int isum = 0 ; r_buf_read_at ( bin -> b , shdr -> sh_offset + i , dfs , sizeof ( Elf_ ( Verdef ) ) ) ; verdef -> vd_version = READ16 ( dfs , j ) verdef -> vd_flags = READ16 ( dfs , j ) verdef -> vd_ndx = READ16 ( dfs , j ) verdef -> vd_cnt = READ16 ( dfs , j ) verdef -> vd_hash = READ32 ( dfs , j ) verdef -> vd_aux = READ32 ( dfs , j ) verdef -> vd_next = READ32 ( dfs , j ) vstart += verdef -> vd_aux ; if ( vstart > end || vstart + sizeof ( Elf_ ( Verdaux ) ) > end ) { sdb_free ( sdb_verdef ) ; goto out_error ; } j = 0 ; aux . vda_name = READ32 ( vstart , j ) aux . vda_next = READ32 ( vstart , j ) isum = i + verdef -> vd_aux ; if ( aux . vda_name > bin -> dynstr_size ) { sdb_free ( sdb_verdef ) ; goto out_error ; } sdb_num_set ( sdb_verdef , \"idx\" , i , 0 ) ; sdb_num_set ( sdb_verdef , \"vd_version\" , verdef -> vd_version , 0 ) ; sdb_num_set ( sdb_verdef , \"vd_ndx\" , verdef -> vd_ndx , 0 ) ; sdb_num_set ( sdb_verdef , \"vd_cnt\" , verdef -> vd_cnt , 0 ) ; sdb_set ( sdb_verdef , \"vda_name\" , & bin -> dynstr [ aux . vda_name ] , 0 ) ; sdb_set ( sdb_verdef , \"flags\" , get_ver_flags ( verdef -> vd_flags ) , 0 ) ; for ( j = 1 ; j < verdef -> vd_cnt ; ++ j ) { int k ; Sdb * sdb_parent = sdb_new0 ( ) ; isum += aux . vda_next ; vstart += aux . vda_next ; if ( vstart > end || vstart + sizeof ( Elf_ ( Verdaux ) ) > end ) { sdb_free ( sdb_verdef ) ; sdb_free ( sdb_parent ) ; goto out_error ; } k = 0 ; aux . vda_name = READ32 ( vstart , k ) aux . vda_next = READ32 ( vstart , k ) if ( aux . vda_name > bin -> dynstr_size ) { sdb_free ( sdb_verdef ) ; sdb_free ( sdb_parent ) ; goto out_error ; } sdb_num_set ( sdb_parent , \"idx\" , isum , 0 ) ; sdb_num_set ( sdb_parent , \"parent\" , j , 0 ) ; sdb_set ( sdb_parent , \"vda_name\" , & bin -> dynstr [ aux . vda_name ] , 0 ) ; snprintf ( key , sizeof ( key ) , \"parent%d\" , j - 1 ) ; sdb_ns_set ( sdb_verdef , key , sdb_parent ) ; } snprintf ( key , sizeof ( key ) , \"verdef%d\" , cnt ) ; sdb_ns_set ( sdb , key , sdb_verdef ) ; if ( ! verdef -> vd_next ) { sdb_free ( sdb_verdef ) ; goto out_error ; } <S2SV_StartBug> i += verdef -> vd_next ; <S2SV_EndBug> } free ( defs ) ; return sdb ; out_error : free ( defs ) ; sdb_free ( sdb ) ; return NULL ; }\n      |    ^\n2 errors generated.\n",
      "error_message": null
    },
    {
      "cve_id": "CVE-2019-19244",
      "tool_name": "GCC Security Warnings",
      "detected": true,
      "confidence": 0.25,
      "detection_time": 0.021361827850341797,
      "tool_output": "/var/folders/ql/btm7z5tx32ddpsky8z3bz4_r0000gn/T/tmp2pcu27_4.c:1:1: error: unknown type name 'CWE'\n/var/folders/ql/btm7z5tx32ddpsky8z3bz4_r0000gn/T/tmp2pcu27_4.c:1:4: error: expected identifier or '('\n2 errors generated.\n",
      "error_message": null
    },
    {
      "cve_id": "CVE-2016-1621",
      "tool_name": "Flawfinder",
      "detected": true,
      "confidence": 0.5,
      "detection_time": 0.029964923858642578,
      "tool_output": "<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.01 Transitional//EN\" \"http://www.w3.org/TR/html4/loose.dtd\">\n<html>\n<head>\n<meta http-equiv=\"Content-type\" content=\"text/html; charset=utf8\">\n<title>Flawfinder Results</title>\n<meta name=\"author\" content=\"David A. Wheeler\">\n<meta name=\"keywords\" lang=\"en\" content=\"flawfinder results, security scan\">\n</head>\n<body>\n<h1>Flawfinder Results</h1>\nHere are the security scan results from\n<a href=\"https://dwheeler.com/flawfinder\">Flawfinder version 2.0.19</a>,\n(C) 2001-2019 <a href=\"https://dwheeler.com\">David A. Wheeler</a>.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\n<p>\nExamining /var/folders/ql/btm7z5tx32ddpsky8z3bz4_r0000gn/T/tmpt9tn2b83.c <br>\n\n<h2>Final Results</h2>\n<ul>\n<li>/var/folders/ql/btm7z5tx32ddpsky8z3bz4_r0000gn/T/tmpt9tn2b83.c:1: <b>  [2] </b> (misc) <i> fopen:\n  Check when opening files - can an attacker redirect it (via symlinks),\n  force the opening of special file type (e.g., device files), move things\n  around to create a race condition, control its ancestors, or change its\n  contents? (<a\n  href=\"https://cwe.mitre.org/data/definitions/362.html\">CWE-362</a>). </i>\n<pre>\nCWE-119 int main ( int argc , char * * argv ) { int frame_cnt = 0 ; FILE * outfile = NULL ; vpx_codec_ctx_t codec ; const VpxInterface * decoder = NULL ; VpxVideoReader * reader = NULL ; const VpxVideoInfo * info = NULL ; int n = 0 ; int m = 0 ; int is_range = 0 ; char * nptr = NULL ; exec_name = argv [ 0 ] ; if ( argc != 4 ) die ( \"Invalid&lt;S2SV_blank&gt;number&lt;S2SV_blank&gt;of&lt;S2SV_blank&gt;arguments.\" ) ; reader = vpx_video_reader_open ( argv [ 1 ] ) ; if ( ! reader ) die ( \"Failed&lt;S2SV_blank&gt;to&lt;S2SV_blank&gt;open&lt;S2SV_blank&gt;%s&lt;S2SV_blank&gt;for&lt;S2SV_blank&gt;reading.\" , argv [ 1 ] ) ; if ( ! ( outfile = fopen ( argv [ 2 ] , \"wb\" ) ) ) die ( \"Failed&lt;S2SV_blank&gt;to&lt;S2SV_blank&gt;open&lt;S2SV_blank&gt;%s&lt;S2SV_blank&gt;for&lt;S2SV_blank&gt;writing.\" , argv [ 2 ] ) ; n = strtol ( argv [ 3 ] , &amp; nptr , 0 ) ; m = strtol ( nptr + 1 , NULL , 0 ) ; is_range = ( * nptr == '-' ) ; if ( ! n || ! m || ( * nptr != '-' &amp;&amp; * nptr != '/' ) ) die ( \"Couldn\\'t&lt;S2SV_blank&gt;parse&lt;S2SV_blank&gt;pattern&lt;S2SV_blank&gt;%s.\\\\n\" , argv [ 3 ] ) ; info = vpx_video_reader_get_info ( reader ) ; decoder = get_vpx_decoder_by_fourcc ( info -&gt; codec_fourcc ) ; if ( ! decoder ) die ( \"Unknown&lt;S2SV_blank&gt;input&lt;S2SV_blank&gt;codec.\" ) ; &lt;S2SV_StartBug&gt; printf ( \"Using&lt;S2SV_blank&gt;%s\\\\n\" , vpx_codec_iface_name ( decoder -&gt; interface ( ) ) ) ; &lt;S2SV_EndBug&gt; &lt;S2SV_StartBug&gt; if ( vpx_codec_dec_init ( &amp; codec , decoder -&gt; interface ( ) , NULL , 0 ) ) &lt;S2SV_EndBug&gt; die_codec ( &amp; codec , \"Failed&lt;S2SV_blank&gt;to&lt;S2SV_blank&gt;initialize&lt;S2SV_blank&gt;decoder.\" ) ; while ( vpx_video_reader_read_frame ( reader ) ) { vpx_codec_iter_t iter = NULL ; vpx_image_t * img = NULL ; size_t frame_size = 0 ; int skip ; const unsigned char * frame = vpx_video_reader_get_frame ( reader , &amp; frame_size ) ; if ( vpx_codec_decode ( &amp; codec , frame , ( unsigned int ) frame_size , NULL , 0 ) ) die_codec ( &amp; codec , \"Failed&lt;S2SV_blank&gt;to&lt;S2SV_blank&gt;decode&lt;S2SV_blank&gt;frame.\" ) ; ++ frame_cnt ; skip = ( is_range &amp;&amp; frame_cnt &gt;= n &amp;&amp; frame_cnt &lt;= m ) || ( ! is_range &amp;&amp; m - ( frame_cnt - 1 ) % m &lt;= n ) ; if ( ! skip ) { putc ( '.' , stdout ) ; while ( ( img = vpx_codec_get_frame ( &amp; codec , &amp; iter ) ) != NULL ) vpx_img_write ( img , outfile ) ; } else { putc ( 'X' , stdout ) ; } fflush ( stdout ) ; } printf ( \"Processed&lt;S2SV_blank&gt;%d&lt;S2SV_blank&gt;frames.\\\\n\" , frame_cnt ) ; if ( vpx_codec_destroy ( &amp; codec ) ) die_codec ( &amp; codec , \"Failed&lt;S2SV_blank&gt;to&lt;S2SV_blank&gt;destroy&lt;S2SV_blank&gt;codec.\" ) ; printf ( \"Play:&lt;S2SV_blank&gt;ffplay&lt;S2SV_blank&gt;-f&lt;S2SV_blank&gt;rawvideo&lt;S2SV_blank&gt;-pix_fmt&lt;S2SV_blank&gt;yuv420p&lt;S2SV_blank&gt;-s&lt;S2SV_blank&gt;%dx%d&lt;S2SV_blank&gt;%s\\\\n\" , info -&gt; frame_width , info -&gt; frame_height , argv [ 2 ] ) ; vpx_video_reader_close ( reader ) ; fclose ( outfile ) ; return EXIT_SUCCESS ; }\n</pre>\n</ul>\n<h2>Analysis Summary</h2>\n<p>\nHits = 1\n<br>\nLines analyzed = 1 in approximately 0.00 seconds (594 lines/second)\n<br>\nPhysical Source Lines of Code (SLOC) = 1\n<br>\nHits@level = [0]   3 [1]   0 [2]   1 [3]   0 [4]   0 [5]   0 <br>\nHits@level+ = [0+]   4 [1+]   1 [2+]   1 [3+]   0 [4+]   0 [5+]   0 <br>\nHits/KSLOC@level+ = [0+] 4000 [1+] 1000 [2+] 1000 [3+]   0 [4+]   0 [5+]   0 <br>\nMinimum risk level = 1\n<br>\nNot every hit is necessarily a security vulnerability.\nYou can inhibit a report by adding a comment in this form:\n// flawfinder: ignore\nMake *sure* it's a false positive!\nYou can use the option --neverignore to show these.\n<br>\nThere may be other security vulnerabilities; review your code!\n<br>\nSee '<a href=\"https://dwheeler.com/secure-programs\">Secure Programming HOWTO</a>'\n(<a href=\"https://dwheeler.com/secure-programs\">https://dwheeler.com/secure-programs</a>) for more information.\n</body>\n</html>\n",
      "error_message": null
    },
    {
      "cve_id": "CVE-2020-14954",
      "tool_name": "Flawfinder",
      "detected": true,
      "confidence": 0.5,
      "detection_time": 0.028953075408935547,
      "tool_output": "<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.01 Transitional//EN\" \"http://www.w3.org/TR/html4/loose.dtd\">\n<html>\n<head>\n<meta http-equiv=\"Content-type\" content=\"text/html; charset=utf8\">\n<title>Flawfinder Results</title>\n<meta name=\"author\" content=\"David A. Wheeler\">\n<meta name=\"keywords\" lang=\"en\" content=\"flawfinder results, security scan\">\n</head>\n<body>\n<h1>Flawfinder Results</h1>\nHere are the security scan results from\n<a href=\"https://dwheeler.com/flawfinder\">Flawfinder version 2.0.19</a>,\n(C) 2001-2019 <a href=\"https://dwheeler.com\">David A. Wheeler</a>.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\n<p>\nExamining /var/folders/ql/btm7z5tx32ddpsky8z3bz4_r0000gn/T/tmpoxoyuli7.c <br>\n\n<h2>Final Results</h2>\n<ul>\n<li>/var/folders/ql/btm7z5tx32ddpsky8z3bz4_r0000gn/T/tmpoxoyuli7.c:1: <b>  [2] </b> (buffer) <i> char:\n  Statically-sized arrays can be improperly restricted, leading to potential\n  overflows or other issues (<a\n  href=\"https://cwe.mitre.org/data/definitions/119.html\">CWE-119</a>!/<a\n  href=\"https://cwe.mitre.org/data/definitions/120.html\">CWE-120</a>).\n  Perform bounds checking, use functions that limit length, or ensure that\n  the size is larger than the maximum possible length. </i>\n<pre>\nCWE-74 int nntp_open_connection ( struct NntpAccountData * adata ) { struct Connection * conn = adata -&gt; conn ; char buf [ 256 ] ; int cap ; bool posting = false , auth = true ; if ( adata -&gt; status == NNTP_OK ) return 0 ; if ( adata -&gt; status == NNTP_BYE ) return - 1 ; adata -&gt; status = NNTP_NONE ; if ( mutt_socket_open ( conn ) &lt; 0 ) return - 1 ; if ( mutt_socket_readln ( buf , sizeof ( buf ) , conn ) &lt; 0 ) return nntp_connect_error ( adata ) ; if ( mutt_str_startswith ( buf , \"200\" , CASE_MATCH ) ) posting = true ; else if ( ! mutt_str_startswith ( buf , \"201\" , CASE_MATCH ) ) { mutt_socket_close ( conn ) ; mutt_str_remove_trailing_ws ( buf ) ; mutt_error ( \"%s\" , buf ) ; return - 1 ; } cap = nntp_capabilities ( adata ) ; if ( cap &lt; 0 ) return - 1 ; if ( cap &gt; 0 ) { if ( ( mutt_socket_send ( conn , \"MODE&lt;S2SV_blank&gt;READER\\\\r\\\\n\" ) &lt; 0 ) || ( mutt_socket_readln ( buf , sizeof ( buf ) , conn ) &lt; 0 ) ) { return nntp_connect_error ( adata ) ; } if ( mutt_str_startswith ( buf , \"200\" , CASE_MATCH ) ) posting = true ; else if ( mutt_str_startswith ( buf , \"201\" , CASE_MATCH ) ) posting = false ; else if ( adata -&gt; hasCAPABILITIES ) { mutt_socket_close ( conn ) ; mutt_error ( _ ( \"Could&lt;S2SV_blank&gt;not&lt;S2SV_blank&gt;switch&lt;S2SV_blank&gt;to&lt;S2SV_blank&gt;reader&lt;S2SV_blank&gt;mode\" ) ) ; return - 1 ; } if ( adata -&gt; hasCAPABILITIES ) { cap = nntp_capabilities ( adata ) ; if ( cap &lt; 0 ) return - 1 ; } } mutt_message ( _ ( \"Connected&lt;S2SV_blank&gt;to&lt;S2SV_blank&gt;%s.&lt;S2SV_blank&gt;%s\" ) , conn -&gt; account . host , posting ? _ ( \"Posting&lt;S2SV_blank&gt;is&lt;S2SV_blank&gt;ok\" ) : _ ( \"Posting&lt;S2SV_blank&gt;is&lt;S2SV_blank&gt;NOT&lt;S2SV_blank&gt;ok\" ) ) ; mutt_sleep ( 1 ) ; # ifdef USE_SSL if ( ( adata -&gt; use_tls != 1 ) &amp;&amp; ( adata -&gt; hasSTARTTLS || C_SslForceTls ) ) { if ( adata -&gt; use_tls == 0 ) { adata -&gt; use_tls = C_SslForceTls || query_quadoption ( C_SslStarttls , _ ( \"Secure&lt;S2SV_blank&gt;connection&lt;S2SV_blank&gt;with&lt;S2SV_blank&gt;TLS?\" ) ) == MUTT_YES ? 2 : 1 ; } if ( adata -&gt; use_tls == 2 ) { if ( ( mutt_socket_send ( conn , \"STARTTLS\\\\r\\\\n\" ) &lt; 0 ) || ( mutt_socket_readln ( buf , sizeof ( buf ) , conn ) &lt; 0 ) ) { return nntp_connect_error ( adata ) ; &lt;S2SV_StartBug&gt; } &lt;S2SV_EndBug&gt; if ( ! mutt_str_startswith ( buf , \"382\" , CASE_MATCH ) ) { adata -&gt; use_tls = 0 ; mutt_error ( \"STARTTLS:&lt;S2SV_blank&gt;%s\" , buf ) ; } else if ( mutt_ssl_starttls ( conn ) ) { adata -&gt; use_tls = 0 ; adata -&gt; status = NNTP_NONE ; mutt_socket_close ( adata -&gt; conn ) ; mutt_error ( _ ( \"Could&lt;S2SV_blank&gt;not&lt;S2SV_blank&gt;negotiate&lt;S2SV_blank&gt;TLS&lt;S2SV_blank&gt;connection\" ) ) ; return - 1 ; } else { cap = nntp_capabilities ( adata ) ; if ( cap &lt; 0 ) return - 1 ; } } } # endif if ( conn -&gt; account . flags &amp; MUTT_ACCT_USER ) { if ( ! conn -&gt; account . user [ 0 ] ) auth = false ; } else { if ( ( mutt_socket_send ( conn , \"STAT\\\\r\\\\n\" ) &lt; 0 ) || ( mutt_socket_readln ( buf , sizeof ( buf ) , conn ) &lt; 0 ) ) { return nntp_connect_error ( adata ) ; } if ( ! mutt_str_startswith ( buf , \"480\" , CASE_MATCH ) ) auth = false ; } if ( auth &amp;&amp; ( nntp_auth ( adata ) &lt; 0 ) ) return - 1 ; if ( adata -&gt; hasCAPABILITIES &amp;&amp; ( auth || ( cap &gt; 0 ) ) ) { cap = nntp_capabilities ( adata ) ; if ( cap &lt; 0 ) return - 1 ; if ( cap &gt; 0 ) { mutt_socket_close ( conn ) ; mutt_error ( _ ( \"Could&lt;S2SV_blank&gt;not&lt;S2SV_blank&gt;switch&lt;S2SV_blank&gt;to&lt;S2SV_blank&gt;reader&lt;S2SV_blank&gt;mode\" ) ) ; return - 1 ; } } if ( nntp_attempt_features ( adata ) &lt; 0 ) return - 1 ; adata -&gt; status = NNTP_OK ; return 0 ; }\n</pre>\n</ul>\n<h2>Analysis Summary</h2>\n<p>\nHits = 1\n<br>\nLines analyzed = 1 in approximately 0.00 seconds (604 lines/second)\n<br>\nPhysical Source Lines of Code (SLOC) = 1\n<br>\nHits@level = [0]   0 [1]   0 [2]   1 [3]   0 [4]   0 [5]   0 <br>\nHits@level+ = [0+]   1 [1+]   1 [2+]   1 [3+]   0 [4+]   0 [5+]   0 <br>\nHits/KSLOC@level+ = [0+] 1000 [1+] 1000 [2+] 1000 [3+]   0 [4+]   0 [5+]   0 <br>\nMinimum risk level = 1\n<br>\nNot every hit is necessarily a security vulnerability.\nYou can inhibit a report by adding a comment in this form:\n// flawfinder: ignore\nMake *sure* it's a false positive!\nYou can use the option --neverignore to show these.\n<br>\nThere may be other security vulnerabilities; review your code!\n<br>\nSee '<a href=\"https://dwheeler.com/secure-programs\">Secure Programming HOWTO</a>'\n(<a href=\"https://dwheeler.com/secure-programs\">https://dwheeler.com/secure-programs</a>) for more information.\n</body>\n</html>\n",
      "error_message": null
    },
    {
      "cve_id": "CVE-2020-15474",
      "tool_name": "Flawfinder",
      "detected": true,
      "confidence": 0.5,
      "detection_time": 0.03183722496032715,
      "tool_output": "<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.01 Transitional//EN\" \"http://www.w3.org/TR/html4/loose.dtd\">\n<html>\n<head>\n<meta http-equiv=\"Content-type\" content=\"text/html; charset=utf8\">\n<title>Flawfinder Results</title>\n<meta name=\"author\" content=\"David A. Wheeler\">\n<meta name=\"keywords\" lang=\"en\" content=\"flawfinder results, security scan\">\n</head>\n<body>\n<h1>Flawfinder Results</h1>\nHere are the security scan results from\n<a href=\"https://dwheeler.com/flawfinder\">Flawfinder version 2.0.19</a>,\n(C) 2001-2019 <a href=\"https://dwheeler.com\">David A. Wheeler</a>.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\n<p>\nExamining /var/folders/ql/btm7z5tx32ddpsky8z3bz4_r0000gn/T/tmphp_y92lf.c <br>\n\n<h2>Final Results</h2>\n<ul>\n<li>/var/folders/ql/btm7z5tx32ddpsky8z3bz4_r0000gn/T/tmphp_y92lf.c:1: <b>  [2] </b> (buffer) <i> char:\n  Statically-sized arrays can be improperly restricted, leading to potential\n  overflows or other issues (<a\n  href=\"https://cwe.mitre.org/data/definitions/119.html\">CWE-119</a>!/<a\n  href=\"https://cwe.mitre.org/data/definitions/120.html\">CWE-120</a>).\n  Perform bounds checking, use functions that limit length, or ensure that\n  the size is larger than the maximum possible length. </i>\n<pre>\nCWE-787 static void processCertificateElements ( struct ndpi_detection_module_struct * ndpi_struct , struct ndpi_flow_struct * flow , u_int16_t p_offset , u_int16_t certificate_len ) { struct ndpi_packet_struct * packet = &amp; flow -&gt; packet ; u_int num_found = 0 , i ; &lt;S2SV_StartBug&gt; char buffer [ 64 ] = { '\\\\0' } , rdnSeqBuf [ 1024 ] = { '\\\\0' } ; &lt;S2SV_EndBug&gt; u_int rdn_len = 0 ; # ifdef DEBUG_TLS printf ( \"[TLS]&lt;S2SV_blank&gt;%s()&lt;S2SV_blank&gt;[offset:&lt;S2SV_blank&gt;%u][certificate_len:&lt;S2SV_blank&gt;%u]\\\\n\" , __FUNCTION__ , p_offset , certificate_len ) ; # endif for ( i = p_offset ; i &lt; certificate_len ; i ++ ) { if ( ( packet -&gt; payload [ i ] == 0x55 ) &amp;&amp; ( packet -&gt; payload [ i + 1 ] == 0x04 ) &amp;&amp; ( packet -&gt; payload [ i + 2 ] == 0x03 ) ) { int rc = extractRDNSequence ( packet , i , buffer , sizeof ( buffer ) , rdnSeqBuf , &amp; rdn_len , sizeof ( rdnSeqBuf ) , \"CN\" ) ; if ( rc == - 1 ) break ; # ifdef DEBUG_TLS printf ( \"[TLS]&lt;S2SV_blank&gt;%s()&lt;S2SV_blank&gt;[%s][%s:&lt;S2SV_blank&gt;%s]\\\\n\" , __FUNCTION__ , ( num_found == 0 ) ? \"Subject\" : \"Issuer\" , \"Common&lt;S2SV_blank&gt;Name\" , buffer ) ; # endif } else if ( ( packet -&gt; payload [ i ] == 0x55 ) &amp;&amp; ( packet -&gt; payload [ i + 1 ] == 0x04 ) &amp;&amp; ( packet -&gt; payload [ i + 2 ] == 0x06 ) ) { int rc = extractRDNSequence ( packet , i , buffer , sizeof ( buffer ) , rdnSeqBuf , &amp; rdn_len , sizeof ( rdnSeqBuf ) , \"C\" ) ; if ( rc == - 1 ) break ; # ifdef DEBUG_TLS printf ( \"[TLS]&lt;S2SV_blank&gt;%s()&lt;S2SV_blank&gt;[%s][%s:&lt;S2SV_blank&gt;%s]\\\\n\" , __FUNCTION__ , ( num_found == 0 ) ? \"Subject\" : \"Issuer\" , \"Country\" , buffer ) ; # endif } else if ( ( packet -&gt; payload [ i ] == 0x55 ) &amp;&amp; ( packet -&gt; payload [ i + 1 ] == 0x04 ) &amp;&amp; ( packet -&gt; payload [ i + 2 ] == 0x07 ) ) { int rc = extractRDNSequence ( packet , i , buffer , sizeof ( buffer ) , rdnSeqBuf , &amp; rdn_len , sizeof ( rdnSeqBuf ) , \"L\" ) ; if ( rc == - 1 ) break ; # ifdef DEBUG_TLS printf ( \"[TLS]&lt;S2SV_blank&gt;%s()&lt;S2SV_blank&gt;[%s][%s:&lt;S2SV_blank&gt;%s]\\\\n\" , __FUNCTION__ , ( num_found == 0 ) ? \"Subject\" : \"Issuer\" , \"Locality\" , buffer ) ; # endif } else if ( ( packet -&gt; payload [ i ] == 0x55 ) &amp;&amp; ( packet -&gt; payload [ i + 1 ] == 0x04 ) &amp;&amp; ( packet -&gt; payload [ i + 2 ] == 0x08 ) ) { int rc = extractRDNSequence ( packet , i , buffer , sizeof ( buffer ) , rdnSeqBuf , &amp; rdn_len , sizeof ( rdnSeqBuf ) , \"ST\" ) ; if ( rc == - 1 ) break ; # ifdef DEBUG_TLS printf ( \"[TLS]&lt;S2SV_blank&gt;%s()&lt;S2SV_blank&gt;[%s][%s:&lt;S2SV_blank&gt;%s]\\\\n\" , __FUNCTION__ , ( num_found == 0 ) ? \"Subject\" : \"Issuer\" , \"State&lt;S2SV_blank&gt;or&lt;S2SV_blank&gt;Province\" , buffer ) ; # endif } else if ( ( packet -&gt; payload [ i ] == 0x55 ) &amp;&amp; ( packet -&gt; payload [ i + 1 ] == 0x04 ) &amp;&amp; ( packet -&gt; payload [ i + 2 ] == 0x0a ) ) { int rc = extractRDNSequence ( packet , i , buffer , sizeof ( buffer ) , rdnSeqBuf , &amp; rdn_len , sizeof ( rdnSeqBuf ) , \"O\" ) ; if ( rc == - 1 ) break ; # ifdef DEBUG_TLS printf ( \"[TLS]&lt;S2SV_blank&gt;%s()&lt;S2SV_blank&gt;[%s][%s:&lt;S2SV_blank&gt;%s]\\\\n\" , __FUNCTION__ , ( num_found == 0 ) ? \"Subject\" : \"Issuer\" , \"Organization&lt;S2SV_blank&gt;Name\" , buffer ) ; # endif } else if ( ( packet -&gt; payload [ i ] == 0x55 ) &amp;&amp; ( packet -&gt; payload [ i + 1 ] == 0x04 ) &amp;&amp; ( packet -&gt; payload [ i + 2 ] == 0x0b ) ) { int rc = extractRDNSequence ( packet , i , buffer , sizeof ( buffer ) , rdnSeqBuf , &amp; rdn_len , sizeof ( rdnSeqBuf ) , \"OU\" ) ; if ( rc == - 1 ) break ; # ifdef DEBUG_TLS printf ( \"[TLS]&lt;S2SV_blank&gt;%s()&lt;S2SV_blank&gt;[%s][%s:&lt;S2SV_blank&gt;%s]\\\\n\" , __FUNCTION__ , ( num_found == 0 ) ? \"Subject\" : \"Issuer\" , \"Organization&lt;S2SV_blank&gt;Unit\" , buffer ) ; # endif } else if ( ( packet -&gt; payload [ i ] == 0x30 ) &amp;&amp; ( packet -&gt; payload [ i + 1 ] == 0x1e ) &amp;&amp; ( packet -&gt; payload [ i + 2 ] == 0x17 ) ) { u_int8_t len = packet -&gt; payload [ i + 3 ] ; u_int offset = i + 4 ; if ( num_found == 0 ) { num_found ++ ; # ifdef DEBUG_TLS printf ( \"[TLS]&lt;S2SV_blank&gt;%s()&lt;S2SV_blank&gt;IssuerDN&lt;S2SV_blank&gt;[%s]\\\\n\" , __FUNCTION__ , rdnSeqBuf ) ; # endif if ( rdn_len ) flow -&gt; protos . stun_ssl . ssl . issuerDN = ndpi_strdup ( rdnSeqBuf ) ; rdn_len = 0 ; } if ( ( offset + len ) &lt; packet -&gt; payload_packet_len ) { char utcDate [ 32 ] ; # ifdef DEBUG_TLS u_int j ; printf ( \"[CERTIFICATE]&lt;S2SV_blank&gt;notBefore&lt;S2SV_blank&gt;[len:&lt;S2SV_blank&gt;%u][\" , len ) ; for ( j = 0 ; j &lt; len ; j ++ ) printf ( \"%c\" , packet -&gt; payload [ i + 4 + j ] ) ; printf ( \"]\\\\n\" ) ; # endif if ( len &lt; ( sizeof ( utcDate ) - 1 ) ) { struct tm utc ; utc . tm_isdst = - 1 ; strncpy ( utcDate , ( const char * ) &amp; packet -&gt; payload [ i + 4 ] , len ) ; utcDate [ len ] = '\\\\0' ; if ( strptime ( utcDate , \"%y%m%d%H%M%SZ\" , &amp; utc ) != NULL ) { flow -&gt; protos . stun_ssl . ssl . notBefore = timegm ( &amp; utc ) ; # ifdef DEBUG_TLS printf ( \"[CERTIFICATE]&lt;S2SV_blank&gt;notBefore&lt;S2SV_blank&gt;%u&lt;S2SV_blank&gt;[%s]\\\\n\" , flow -&gt; protos . stun_ssl . ssl . notBefore , utcDate ) ; # endif } } offset += len ; if ( ( offset + 1 ) &lt; packet -&gt; payload_packet_len ) { len = packet -&gt; payload [ offset + 1 ] ; offset += 2 ; if ( ( offset + len ) &lt; packet -&gt; payload_packet_len ) { u_int32_t time_sec = flow -&gt; packet . current_time_ms / 1000 ; # ifdef DEBUG_TLS u_int j ; printf ( \"[CERTIFICATE]&lt;S2SV_blank&gt;notAfter&lt;S2SV_blank&gt;[len:&lt;S2SV_blank&gt;%u][\" , len ) ; for ( j = 0 ; j &lt; len ; j ++ ) printf ( \"%c\" , packet -&gt; payload [ offset + j ] ) ; printf ( \"]\\\\n\" ) ; # endif if ( len &lt; ( sizeof ( utcDate ) - 1 ) ) { struct tm utc ; utc . tm_isdst = - 1 ; strncpy ( utcDate , ( const char * ) &amp; packet -&gt; payload [ offset ] , len ) ; utcDate [ len ] = '\\\\0' ; if ( strptime ( utcDate , \"%y%m%d%H%M%SZ\" , &amp; utc ) != NULL ) { flow -&gt; protos . stun_ssl . ssl . notAfter = timegm ( &amp; utc ) ; # ifdef DEBUG_TLS printf ( \"[CERTIFICATE]&lt;S2SV_blank&gt;notAfter&lt;S2SV_blank&gt;%u&lt;S2SV_blank&gt;[%s]\\\\n\" , flow -&gt; protos . stun_ssl . ssl . notAfter , utcDate ) ; # endif } } if ( ( time_sec &lt; flow -&gt; protos . stun_ssl . ssl . notBefore ) || ( time_sec &gt; flow -&gt; protos . stun_ssl . ssl . notAfter ) ) NDPI_SET_BIT ( flow -&gt; risk , NDPI_TLS_CERTIFICATE_EXPIRED ) ; } } } } else if ( ( packet -&gt; payload [ i ] == 0x55 ) &amp;&amp; ( packet -&gt; payload [ i + 1 ] == 0x1d ) &amp;&amp; ( packet -&gt; payload [ i + 2 ] == 0x11 ) ) { u_int8_t matched_name = 0 ; # ifdef DEBUG_TLS printf ( \"*******&lt;S2SV_blank&gt;[TLS]&lt;S2SV_blank&gt;Found&lt;S2SV_blank&gt;subjectAltName\\\\n\" ) ; # endif i += 3 ; i ++ ; if ( i &lt; packet -&gt; payload_packet_len ) { i += ( packet -&gt; payload [ i ] &amp; 0x80 ) ? ( packet -&gt; payload [ i ] &amp; 0x7F ) : 0 ; if ( i &lt; packet -&gt; payload_packet_len ) { i += 2 ; if ( i &lt; packet -&gt; payload_packet_len ) { i += ( packet -&gt; payload [ i ] &amp; 0x80 ) ? ( packet -&gt; payload [ i ] &amp; 0x7F ) : 0 ; i ++ ; while ( i &lt; packet -&gt; payload_packet_len ) { if ( packet -&gt; payload [ i ] == 0x82 ) { if ( ( i &lt; ( packet -&gt; payload_packet_len - 1 ) ) &amp;&amp; ( ( i + packet -&gt; payload [ i + 1 ] + 2 ) &lt; packet -&gt; payload_packet_len ) ) { u_int8_t len = packet -&gt; payload [ i + 1 ] ; char dNSName [ 256 ] ; i += 2 ; if ( len == 0 ) break ; strncpy ( dNSName , ( const char * ) &amp; packet -&gt; payload [ i ] , len ) ; dNSName [ len ] = '\\\\0' ; cleanupServerName ( dNSName , len ) ; # if DEBUG_TLS printf ( \"[TLS]&lt;S2SV_blank&gt;dNSName&lt;S2SV_blank&gt;%s&lt;S2SV_blank&gt;[%s]\\\\n\" , dNSName , flow -&gt; protos . stun_ssl . ssl . client_requested_server_name ) ; # endif if ( matched_name == 0 ) { if ( ( dNSName [ 0 ] == '*' ) &amp;&amp; strstr ( flow -&gt; protos . stun_ssl . ssl . client_requested_server_name , &amp; dNSName [ 1 ] ) ) matched_name = 1 ; else if ( strcmp ( flow -&gt; protos . stun_ssl . ssl . client_requested_server_name , dNSName ) == 0 ) matched_name = 1 ; } if ( flow -&gt; protos . stun_ssl . ssl . server_names == NULL ) flow -&gt; protos . stun_ssl . ssl . server_names = ndpi_strdup ( dNSName ) , flow -&gt; protos . stun_ssl . ssl . server_names_len = strlen ( dNSName ) ; else { u_int16_t dNSName_len = strlen ( dNSName ) ; u_int16_t newstr_len = flow -&gt; protos . stun_ssl . ssl . server_names_len + dNSName_len + 1 ; char * newstr = ( char * ) ndpi_realloc ( flow -&gt; protos . stun_ssl . ssl . server_names , flow -&gt; protos . stun_ssl . ssl . server_names_len + 1 , newstr_len + 1 ) ; if ( newstr ) { flow -&gt; protos . stun_ssl . ssl . server_names = newstr ; flow -&gt; protos . stun_ssl . ssl . server_names [ flow -&gt; protos . stun_ssl . ssl . server_names_len ] = ',' ; strncpy ( &amp; flow -&gt; protos . stun_ssl . ssl . server_names [ flow -&gt; protos . stun_ssl . ssl . server_names_len + 1 ] , dNSName , dNSName_len + 1 ) ; flow -&gt; protos . stun_ssl . ssl . server_names [ newstr_len ] = '\\\\0' ; flow -&gt; protos . stun_ssl . ssl . server_names_len = newstr_len ; } } if ( ! flow -&gt; l4 . tcp . tls . subprotocol_detected ) if ( ndpi_match_hostname_protocol ( ndpi_struct , flow , NDPI_PROTOCOL_TLS , dNSName , len ) ) flow -&gt; l4 . tcp . tls . subprotocol_detected = 1 ; i += len ; } else { # if DEBUG_TLS printf ( \"[TLS]&lt;S2SV_blank&gt;Leftover&lt;S2SV_blank&gt;%u&lt;S2SV_blank&gt;bytes\" , packet -&gt; payload_packet_len - i ) ; # endif break ; } } else { break ; } } if ( ! matched_name ) NDPI_SET_BIT ( flow -&gt; risk , NDPI_TLS_CERTIFICATE_MISMATCH ) ; } } } } } if ( rdn_len ) flow -&gt; protos . stun_ssl . ssl . subjectDN = ndpi_strdup ( rdnSeqBuf ) ; if ( flow -&gt; protos . stun_ssl . ssl . subjectDN &amp;&amp; flow -&gt; protos . stun_ssl . ssl . issuerDN &amp;&amp; ( ! strcmp ( flow -&gt; protos . stun_ssl . ssl . subjectDN , flow -&gt; protos . stun_ssl . ssl . issuerDN ) ) ) NDPI_SET_BIT ( flow -&gt; risk , NDPI_TLS_SELFSIGNED_CERTIFICATE ) ; # if DEBUG_TLS printf ( \"[TLS]&lt;S2SV_blank&gt;%s()&lt;S2SV_blank&gt;SubjectDN&lt;S2SV_blank&gt;[%s]\\\\n\" , __FUNCTION__ , rdnSeqBuf ) ; # endif }\n</pre>\n<li>/var/folders/ql/btm7z5tx32ddpsky8z3bz4_r0000gn/T/tmphp_y92lf.c:1: <b>  [2] </b> (buffer) <i> char:\n  Statically-sized arrays can be improperly restricted, leading to potential\n  overflows or other issues (<a\n  href=\"https://cwe.mitre.org/data/definitions/119.html\">CWE-119</a>!/<a\n  href=\"https://cwe.mitre.org/data/definitions/120.html\">CWE-120</a>).\n  Perform bounds checking, use functions that limit length, or ensure that\n  the size is larger than the maximum possible length. </i>\n<pre>\nCWE-787 static void processCertificateElements ( struct ndpi_detection_module_struct * ndpi_struct , struct ndpi_flow_struct * flow , u_int16_t p_offset , u_int16_t certificate_len ) { struct ndpi_packet_struct * packet = &amp; flow -&gt; packet ; u_int num_found = 0 , i ; &lt;S2SV_StartBug&gt; char buffer [ 64 ] = { '\\\\0' } , rdnSeqBuf [ 1024 ] = { '\\\\0' } ; &lt;S2SV_EndBug&gt; u_int rdn_len = 0 ; # ifdef DEBUG_TLS printf ( \"[TLS]&lt;S2SV_blank&gt;%s()&lt;S2SV_blank&gt;[offset:&lt;S2SV_blank&gt;%u][certificate_len:&lt;S2SV_blank&gt;%u]\\\\n\" , __FUNCTION__ , p_offset , certificate_len ) ; # endif for ( i = p_offset ; i &lt; certificate_len ; i ++ ) { if ( ( packet -&gt; payload [ i ] == 0x55 ) &amp;&amp; ( packet -&gt; payload [ i + 1 ] == 0x04 ) &amp;&amp; ( packet -&gt; payload [ i + 2 ] == 0x03 ) ) { int rc = extractRDNSequence ( packet , i , buffer , sizeof ( buffer ) , rdnSeqBuf , &amp; rdn_len , sizeof ( rdnSeqBuf ) , \"CN\" ) ; if ( rc == - 1 ) break ; # ifdef DEBUG_TLS printf ( \"[TLS]&lt;S2SV_blank&gt;%s()&lt;S2SV_blank&gt;[%s][%s:&lt;S2SV_blank&gt;%s]\\\\n\" , __FUNCTION__ , ( num_found == 0 ) ? \"Subject\" : \"Issuer\" , \"Common&lt;S2SV_blank&gt;Name\" , buffer ) ; # endif } else if ( ( packet -&gt; payload [ i ] == 0x55 ) &amp;&amp; ( packet -&gt; payload [ i + 1 ] == 0x04 ) &amp;&amp; ( packet -&gt; payload [ i + 2 ] == 0x06 ) ) { int rc = extractRDNSequence ( packet , i , buffer , sizeof ( buffer ) , rdnSeqBuf , &amp; rdn_len , sizeof ( rdnSeqBuf ) , \"C\" ) ; if ( rc == - 1 ) break ; # ifdef DEBUG_TLS printf ( \"[TLS]&lt;S2SV_blank&gt;%s()&lt;S2SV_blank&gt;[%s][%s:&lt;S2SV_blank&gt;%s]\\\\n\" , __FUNCTION__ , ( num_found == 0 ) ? \"Subject\" : \"Issuer\" , \"Country\" , buffer ) ; # endif } else if ( ( packet -&gt; payload [ i ] == 0x55 ) &amp;&amp; ( packet -&gt; payload [ i + 1 ] == 0x04 ) &amp;&amp; ( packet -&gt; payload [ i + 2 ] == 0x07 ) ) { int rc = extractRDNSequence ( packet , i , buffer , sizeof ( buffer ) , rdnSeqBuf , &amp; rdn_len , sizeof ( rdnSeqBuf ) , \"L\" ) ; if ( rc == - 1 ) break ; # ifdef DEBUG_TLS printf ( \"[TLS]&lt;S2SV_blank&gt;%s()&lt;S2SV_blank&gt;[%s][%s:&lt;S2SV_blank&gt;%s]\\\\n\" , __FUNCTION__ , ( num_found == 0 ) ? \"Subject\" : \"Issuer\" , \"Locality\" , buffer ) ; # endif } else if ( ( packet -&gt; payload [ i ] == 0x55 ) &amp;&amp; ( packet -&gt; payload [ i + 1 ] == 0x04 ) &amp;&amp; ( packet -&gt; payload [ i + 2 ] == 0x08 ) ) { int rc = extractRDNSequence ( packet , i , buffer , sizeof ( buffer ) , rdnSeqBuf , &amp; rdn_len , sizeof ( rdnSeqBuf ) , \"ST\" ) ; if ( rc == - 1 ) break ; # ifdef DEBUG_TLS printf ( \"[TLS]&lt;S2SV_blank&gt;%s()&lt;S2SV_blank&gt;[%s][%s:&lt;S2SV_blank&gt;%s]\\\\n\" , __FUNCTION__ , ( num_found == 0 ) ? \"Subject\" : \"Issuer\" , \"State&lt;S2SV_blank&gt;or&lt;S2SV_blank&gt;Province\" , buffer ) ; # endif } else if ( ( packet -&gt; payload [ i ] == 0x55 ) &amp;&amp; ( packet -&gt; payload [ i + 1 ] == 0x04 ) &amp;&amp; ( packet -&gt; payload [ i + 2 ] == 0x0a ) ) { int rc = extractRDNSequence ( packet , i , buffer , sizeof ( buffer ) , rdnSeqBuf , &amp; rdn_len , sizeof ( rdnSeqBuf ) , \"O\" ) ; if ( rc == - 1 ) break ; # ifdef DEBUG_TLS printf ( \"[TLS]&lt;S2SV_blank&gt;%s()&lt;S2SV_blank&gt;[%s][%s:&lt;S2SV_blank&gt;%s]\\\\n\" , __FUNCTION__ , ( num_found == 0 ) ? \"Subject\" : \"Issuer\" , \"Organization&lt;S2SV_blank&gt;Name\" , buffer ) ; # endif } else if ( ( packet -&gt; payload [ i ] == 0x55 ) &amp;&amp; ( packet -&gt; payload [ i + 1 ] == 0x04 ) &amp;&amp; ( packet -&gt; payload [ i + 2 ] == 0x0b ) ) { int rc = extractRDNSequence ( packet , i , buffer , sizeof ( buffer ) , rdnSeqBuf , &amp; rdn_len , sizeof ( rdnSeqBuf ) , \"OU\" ) ; if ( rc == - 1 ) break ; # ifdef DEBUG_TLS printf ( \"[TLS]&lt;S2SV_blank&gt;%s()&lt;S2SV_blank&gt;[%s][%s:&lt;S2SV_blank&gt;%s]\\\\n\" , __FUNCTION__ , ( num_found == 0 ) ? \"Subject\" : \"Issuer\" , \"Organization&lt;S2SV_blank&gt;Unit\" , buffer ) ; # endif } else if ( ( packet -&gt; payload [ i ] == 0x30 ) &amp;&amp; ( packet -&gt; payload [ i + 1 ] == 0x1e ) &amp;&amp; ( packet -&gt; payload [ i + 2 ] == 0x17 ) ) { u_int8_t len = packet -&gt; payload [ i + 3 ] ; u_int offset = i + 4 ; if ( num_found == 0 ) { num_found ++ ; # ifdef DEBUG_TLS printf ( \"[TLS]&lt;S2SV_blank&gt;%s()&lt;S2SV_blank&gt;IssuerDN&lt;S2SV_blank&gt;[%s]\\\\n\" , __FUNCTION__ , rdnSeqBuf ) ; # endif if ( rdn_len ) flow -&gt; protos . stun_ssl . ssl . issuerDN = ndpi_strdup ( rdnSeqBuf ) ; rdn_len = 0 ; } if ( ( offset + len ) &lt; packet -&gt; payload_packet_len ) { char utcDate [ 32 ] ; # ifdef DEBUG_TLS u_int j ; printf ( \"[CERTIFICATE]&lt;S2SV_blank&gt;notBefore&lt;S2SV_blank&gt;[len:&lt;S2SV_blank&gt;%u][\" , len ) ; for ( j = 0 ; j &lt; len ; j ++ ) printf ( \"%c\" , packet -&gt; payload [ i + 4 + j ] ) ; printf ( \"]\\\\n\" ) ; # endif if ( len &lt; ( sizeof ( utcDate ) - 1 ) ) { struct tm utc ; utc . tm_isdst = - 1 ; strncpy ( utcDate , ( const char * ) &amp; packet -&gt; payload [ i + 4 ] , len ) ; utcDate [ len ] = '\\\\0' ; if ( strptime ( utcDate , \"%y%m%d%H%M%SZ\" , &amp; utc ) != NULL ) { flow -&gt; protos . stun_ssl . ssl . notBefore = timegm ( &amp; utc ) ; # ifdef DEBUG_TLS printf ( \"[CERTIFICATE]&lt;S2SV_blank&gt;notBefore&lt;S2SV_blank&gt;%u&lt;S2SV_blank&gt;[%s]\\\\n\" , flow -&gt; protos . stun_ssl . ssl . notBefore , utcDate ) ; # endif } } offset += len ; if ( ( offset + 1 ) &lt; packet -&gt; payload_packet_len ) { len = packet -&gt; payload [ offset + 1 ] ; offset += 2 ; if ( ( offset + len ) &lt; packet -&gt; payload_packet_len ) { u_int32_t time_sec = flow -&gt; packet . current_time_ms / 1000 ; # ifdef DEBUG_TLS u_int j ; printf ( \"[CERTIFICATE]&lt;S2SV_blank&gt;notAfter&lt;S2SV_blank&gt;[len:&lt;S2SV_blank&gt;%u][\" , len ) ; for ( j = 0 ; j &lt; len ; j ++ ) printf ( \"%c\" , packet -&gt; payload [ offset + j ] ) ; printf ( \"]\\\\n\" ) ; # endif if ( len &lt; ( sizeof ( utcDate ) - 1 ) ) { struct tm utc ; utc . tm_isdst = - 1 ; strncpy ( utcDate , ( const char * ) &amp; packet -&gt; payload [ offset ] , len ) ; utcDate [ len ] = '\\\\0' ; if ( strptime ( utcDate , \"%y%m%d%H%M%SZ\" , &amp; utc ) != NULL ) { flow -&gt; protos . stun_ssl . ssl . notAfter = timegm ( &amp; utc ) ; # ifdef DEBUG_TLS printf ( \"[CERTIFICATE]&lt;S2SV_blank&gt;notAfter&lt;S2SV_blank&gt;%u&lt;S2SV_blank&gt;[%s]\\\\n\" , flow -&gt; protos . stun_ssl . ssl . notAfter , utcDate ) ; # endif } } if ( ( time_sec &lt; flow -&gt; protos . stun_ssl . ssl . notBefore ) || ( time_sec &gt; flow -&gt; protos . stun_ssl . ssl . notAfter ) ) NDPI_SET_BIT ( flow -&gt; risk , NDPI_TLS_CERTIFICATE_EXPIRED ) ; } } } } else if ( ( packet -&gt; payload [ i ] == 0x55 ) &amp;&amp; ( packet -&gt; payload [ i + 1 ] == 0x1d ) &amp;&amp; ( packet -&gt; payload [ i + 2 ] == 0x11 ) ) { u_int8_t matched_name = 0 ; # ifdef DEBUG_TLS printf ( \"*******&lt;S2SV_blank&gt;[TLS]&lt;S2SV_blank&gt;Found&lt;S2SV_blank&gt;subjectAltName\\\\n\" ) ; # endif i += 3 ; i ++ ; if ( i &lt; packet -&gt; payload_packet_len ) { i += ( packet -&gt; payload [ i ] &amp; 0x80 ) ? ( packet -&gt; payload [ i ] &amp; 0x7F ) : 0 ; if ( i &lt; packet -&gt; payload_packet_len ) { i += 2 ; if ( i &lt; packet -&gt; payload_packet_len ) { i += ( packet -&gt; payload [ i ] &amp; 0x80 ) ? ( packet -&gt; payload [ i ] &amp; 0x7F ) : 0 ; i ++ ; while ( i &lt; packet -&gt; payload_packet_len ) { if ( packet -&gt; payload [ i ] == 0x82 ) { if ( ( i &lt; ( packet -&gt; payload_packet_len - 1 ) ) &amp;&amp; ( ( i + packet -&gt; payload [ i + 1 ] + 2 ) &lt; packet -&gt; payload_packet_len ) ) { u_int8_t len = packet -&gt; payload [ i + 1 ] ; char dNSName [ 256 ] ; i += 2 ; if ( len == 0 ) break ; strncpy ( dNSName , ( const char * ) &amp; packet -&gt; payload [ i ] , len ) ; dNSName [ len ] = '\\\\0' ; cleanupServerName ( dNSName , len ) ; # if DEBUG_TLS printf ( \"[TLS]&lt;S2SV_blank&gt;dNSName&lt;S2SV_blank&gt;%s&lt;S2SV_blank&gt;[%s]\\\\n\" , dNSName , flow -&gt; protos . stun_ssl . ssl . client_requested_server_name ) ; # endif if ( matched_name == 0 ) { if ( ( dNSName [ 0 ] == '*' ) &amp;&amp; strstr ( flow -&gt; protos . stun_ssl . ssl . client_requested_server_name , &amp; dNSName [ 1 ] ) ) matched_name = 1 ; else if ( strcmp ( flow -&gt; protos . stun_ssl . ssl . client_requested_server_name , dNSName ) == 0 ) matched_name = 1 ; } if ( flow -&gt; protos . stun_ssl . ssl . server_names == NULL ) flow -&gt; protos . stun_ssl . ssl . server_names = ndpi_strdup ( dNSName ) , flow -&gt; protos . stun_ssl . ssl . server_names_len = strlen ( dNSName ) ; else { u_int16_t dNSName_len = strlen ( dNSName ) ; u_int16_t newstr_len = flow -&gt; protos . stun_ssl . ssl . server_names_len + dNSName_len + 1 ; char * newstr = ( char * ) ndpi_realloc ( flow -&gt; protos . stun_ssl . ssl . server_names , flow -&gt; protos . stun_ssl . ssl . server_names_len + 1 , newstr_len + 1 ) ; if ( newstr ) { flow -&gt; protos . stun_ssl . ssl . server_names = newstr ; flow -&gt; protos . stun_ssl . ssl . server_names [ flow -&gt; protos . stun_ssl . ssl . server_names_len ] = ',' ; strncpy ( &amp; flow -&gt; protos . stun_ssl . ssl . server_names [ flow -&gt; protos . stun_ssl . ssl . server_names_len + 1 ] , dNSName , dNSName_len + 1 ) ; flow -&gt; protos . stun_ssl . ssl . server_names [ newstr_len ] = '\\\\0' ; flow -&gt; protos . stun_ssl . ssl . server_names_len = newstr_len ; } } if ( ! flow -&gt; l4 . tcp . tls . subprotocol_detected ) if ( ndpi_match_hostname_protocol ( ndpi_struct , flow , NDPI_PROTOCOL_TLS , dNSName , len ) ) flow -&gt; l4 . tcp . tls . subprotocol_detected = 1 ; i += len ; } else { # if DEBUG_TLS printf ( \"[TLS]&lt;S2SV_blank&gt;Leftover&lt;S2SV_blank&gt;%u&lt;S2SV_blank&gt;bytes\" , packet -&gt; payload_packet_len - i ) ; # endif break ; } } else { break ; } } if ( ! matched_name ) NDPI_SET_BIT ( flow -&gt; risk , NDPI_TLS_CERTIFICATE_MISMATCH ) ; } } } } } if ( rdn_len ) flow -&gt; protos . stun_ssl . ssl . subjectDN = ndpi_strdup ( rdnSeqBuf ) ; if ( flow -&gt; protos . stun_ssl . ssl . subjectDN &amp;&amp; flow -&gt; protos . stun_ssl . ssl . issuerDN &amp;&amp; ( ! strcmp ( flow -&gt; protos . stun_ssl . ssl . subjectDN , flow -&gt; protos . stun_ssl . ssl . issuerDN ) ) ) NDPI_SET_BIT ( flow -&gt; risk , NDPI_TLS_SELFSIGNED_CERTIFICATE ) ; # if DEBUG_TLS printf ( \"[TLS]&lt;S2SV_blank&gt;%s()&lt;S2SV_blank&gt;SubjectDN&lt;S2SV_blank&gt;[%s]\\\\n\" , __FUNCTION__ , rdnSeqBuf ) ; # endif }\n</pre>\n<li>/var/folders/ql/btm7z5tx32ddpsky8z3bz4_r0000gn/T/tmphp_y92lf.c:1: <b>  [2] </b> (buffer) <i> char:\n  Statically-sized arrays can be improperly restricted, leading to potential\n  overflows or other issues (<a\n  href=\"https://cwe.mitre.org/data/definitions/119.html\">CWE-119</a>!/<a\n  href=\"https://cwe.mitre.org/data/definitions/120.html\">CWE-120</a>).\n  Perform bounds checking, use functions that limit length, or ensure that\n  the size is larger than the maximum possible length. </i>\n<pre>\nCWE-787 static void processCertificateElements ( struct ndpi_detection_module_struct * ndpi_struct , struct ndpi_flow_struct * flow , u_int16_t p_offset , u_int16_t certificate_len ) { struct ndpi_packet_struct * packet = &amp; flow -&gt; packet ; u_int num_found = 0 , i ; &lt;S2SV_StartBug&gt; char buffer [ 64 ] = { '\\\\0' } , rdnSeqBuf [ 1024 ] = { '\\\\0' } ; &lt;S2SV_EndBug&gt; u_int rdn_len = 0 ; # ifdef DEBUG_TLS printf ( \"[TLS]&lt;S2SV_blank&gt;%s()&lt;S2SV_blank&gt;[offset:&lt;S2SV_blank&gt;%u][certificate_len:&lt;S2SV_blank&gt;%u]\\\\n\" , __FUNCTION__ , p_offset , certificate_len ) ; # endif for ( i = p_offset ; i &lt; certificate_len ; i ++ ) { if ( ( packet -&gt; payload [ i ] == 0x55 ) &amp;&amp; ( packet -&gt; payload [ i + 1 ] == 0x04 ) &amp;&amp; ( packet -&gt; payload [ i + 2 ] == 0x03 ) ) { int rc = extractRDNSequence ( packet , i , buffer , sizeof ( buffer ) , rdnSeqBuf , &amp; rdn_len , sizeof ( rdnSeqBuf ) , \"CN\" ) ; if ( rc == - 1 ) break ; # ifdef DEBUG_TLS printf ( \"[TLS]&lt;S2SV_blank&gt;%s()&lt;S2SV_blank&gt;[%s][%s:&lt;S2SV_blank&gt;%s]\\\\n\" , __FUNCTION__ , ( num_found == 0 ) ? \"Subject\" : \"Issuer\" , \"Common&lt;S2SV_blank&gt;Name\" , buffer ) ; # endif } else if ( ( packet -&gt; payload [ i ] == 0x55 ) &amp;&amp; ( packet -&gt; payload [ i + 1 ] == 0x04 ) &amp;&amp; ( packet -&gt; payload [ i + 2 ] == 0x06 ) ) { int rc = extractRDNSequence ( packet , i , buffer , sizeof ( buffer ) , rdnSeqBuf , &amp; rdn_len , sizeof ( rdnSeqBuf ) , \"C\" ) ; if ( rc == - 1 ) break ; # ifdef DEBUG_TLS printf ( \"[TLS]&lt;S2SV_blank&gt;%s()&lt;S2SV_blank&gt;[%s][%s:&lt;S2SV_blank&gt;%s]\\\\n\" , __FUNCTION__ , ( num_found == 0 ) ? \"Subject\" : \"Issuer\" , \"Country\" , buffer ) ; # endif } else if ( ( packet -&gt; payload [ i ] == 0x55 ) &amp;&amp; ( packet -&gt; payload [ i + 1 ] == 0x04 ) &amp;&amp; ( packet -&gt; payload [ i + 2 ] == 0x07 ) ) { int rc = extractRDNSequence ( packet , i , buffer , sizeof ( buffer ) , rdnSeqBuf , &amp; rdn_len , sizeof ( rdnSeqBuf ) , \"L\" ) ; if ( rc == - 1 ) break ; # ifdef DEBUG_TLS printf ( \"[TLS]&lt;S2SV_blank&gt;%s()&lt;S2SV_blank&gt;[%s][%s:&lt;S2SV_blank&gt;%s]\\\\n\" , __FUNCTION__ , ( num_found == 0 ) ? \"Subject\" : \"Issuer\" , \"Locality\" , buffer ) ; # endif } else if ( ( packet -&gt; payload [ i ] == 0x55 ) &amp;&amp; ( packet -&gt; payload [ i + 1 ] == 0x04 ) &amp;&amp; ( packet -&gt; payload [ i + 2 ] == 0x08 ) ) { int rc = extractRDNSequence ( packet , i , buffer , sizeof ( buffer ) , rdnSeqBuf , &amp; rdn_len , sizeof ( rdnSeqBuf ) , \"ST\" ) ; if ( rc == - 1 ) break ; # ifdef DEBUG_TLS printf ( \"[TLS]&lt;S2SV_blank&gt;%s()&lt;S2SV_blank&gt;[%s][%s:&lt;S2SV_blank&gt;%s]\\\\n\" , __FUNCTION__ , ( num_found == 0 ) ? \"Subject\" : \"Issuer\" , \"State&lt;S2SV_blank&gt;or&lt;S2SV_blank&gt;Province\" , buffer ) ; # endif } else if ( ( packet -&gt; payload [ i ] == 0x55 ) &amp;&amp; ( packet -&gt; payload [ i + 1 ] == 0x04 ) &amp;&amp; ( packet -&gt; payload [ i + 2 ] == 0x0a ) ) { int rc = extractRDNSequence ( packet , i , buffer , sizeof ( buffer ) , rdnSeqBuf , &amp; rdn_len , sizeof ( rdnSeqBuf ) , \"O\" ) ; if ( rc == - 1 ) break ; # ifdef DEBUG_TLS printf ( \"[TLS]&lt;S2SV_blank&gt;%s()&lt;S2SV_blank&gt;[%s][%s:&lt;S2SV_blank&gt;%s]\\\\n\" , __FUNCTION__ , ( num_found == 0 ) ? \"Subject\" : \"Issuer\" , \"Organization&lt;S2SV_blank&gt;Name\" , buffer ) ; # endif } else if ( ( packet -&gt; payload [ i ] == 0x55 ) &amp;&amp; ( packet -&gt; payload [ i + 1 ] == 0x04 ) &amp;&amp; ( packet -&gt; payload [ i + 2 ] == 0x0b ) ) { int rc = extractRDNSequence ( packet , i , buffer , sizeof ( buffer ) , rdnSeqBuf , &amp; rdn_len , sizeof ( rdnSeqBuf ) , \"OU\" ) ; if ( rc == - 1 ) break ; # ifdef DEBUG_TLS printf ( \"[TLS]&lt;S2SV_blank&gt;%s()&lt;S2SV_blank&gt;[%s][%s:&lt;S2SV_blank&gt;%s]\\\\n\" , __FUNCTION__ , ( num_found == 0 ) ? \"Subject\" : \"Issuer\" , \"Organization&lt;S2SV_blank&gt;Unit\" , buffer ) ; # endif } else if ( ( packet -&gt; payload [ i ] == 0x30 ) &amp;&amp; ( packet -&gt; payload [ i + 1 ] == 0x1e ) &amp;&amp; ( packet -&gt; payload [ i + 2 ] == 0x17 ) ) { u_int8_t len = packet -&gt; payload [ i + 3 ] ; u_int offset = i + 4 ; if ( num_found == 0 ) { num_found ++ ; # ifdef DEBUG_TLS printf ( \"[TLS]&lt;S2SV_blank&gt;%s()&lt;S2SV_blank&gt;IssuerDN&lt;S2SV_blank&gt;[%s]\\\\n\" , __FUNCTION__ , rdnSeqBuf ) ; # endif if ( rdn_len ) flow -&gt; protos . stun_ssl . ssl . issuerDN = ndpi_strdup ( rdnSeqBuf ) ; rdn_len = 0 ; } if ( ( offset + len ) &lt; packet -&gt; payload_packet_len ) { char utcDate [ 32 ] ; # ifdef DEBUG_TLS u_int j ; printf ( \"[CERTIFICATE]&lt;S2SV_blank&gt;notBefore&lt;S2SV_blank&gt;[len:&lt;S2SV_blank&gt;%u][\" , len ) ; for ( j = 0 ; j &lt; len ; j ++ ) printf ( \"%c\" , packet -&gt; payload [ i + 4 + j ] ) ; printf ( \"]\\\\n\" ) ; # endif if ( len &lt; ( sizeof ( utcDate ) - 1 ) ) { struct tm utc ; utc . tm_isdst = - 1 ; strncpy ( utcDate , ( const char * ) &amp; packet -&gt; payload [ i + 4 ] , len ) ; utcDate [ len ] = '\\\\0' ; if ( strptime ( utcDate , \"%y%m%d%H%M%SZ\" , &amp; utc ) != NULL ) { flow -&gt; protos . stun_ssl . ssl . notBefore = timegm ( &amp; utc ) ; # ifdef DEBUG_TLS printf ( \"[CERTIFICATE]&lt;S2SV_blank&gt;notBefore&lt;S2SV_blank&gt;%u&lt;S2SV_blank&gt;[%s]\\\\n\" , flow -&gt; protos . stun_ssl . ssl . notBefore , utcDate ) ; # endif } } offset += len ; if ( ( offset + 1 ) &lt; packet -&gt; payload_packet_len ) { len = packet -&gt; payload [ offset + 1 ] ; offset += 2 ; if ( ( offset + len ) &lt; packet -&gt; payload_packet_len ) { u_int32_t time_sec = flow -&gt; packet . current_time_ms / 1000 ; # ifdef DEBUG_TLS u_int j ; printf ( \"[CERTIFICATE]&lt;S2SV_blank&gt;notAfter&lt;S2SV_blank&gt;[len:&lt;S2SV_blank&gt;%u][\" , len ) ; for ( j = 0 ; j &lt; len ; j ++ ) printf ( \"%c\" , packet -&gt; payload [ offset + j ] ) ; printf ( \"]\\\\n\" ) ; # endif if ( len &lt; ( sizeof ( utcDate ) - 1 ) ) { struct tm utc ; utc . tm_isdst = - 1 ; strncpy ( utcDate , ( const char * ) &amp; packet -&gt; payload [ offset ] , len ) ; utcDate [ len ] = '\\\\0' ; if ( strptime ( utcDate , \"%y%m%d%H%M%SZ\" , &amp; utc ) != NULL ) { flow -&gt; protos . stun_ssl . ssl . notAfter = timegm ( &amp; utc ) ; # ifdef DEBUG_TLS printf ( \"[CERTIFICATE]&lt;S2SV_blank&gt;notAfter&lt;S2SV_blank&gt;%u&lt;S2SV_blank&gt;[%s]\\\\n\" , flow -&gt; protos . stun_ssl . ssl . notAfter , utcDate ) ; # endif } } if ( ( time_sec &lt; flow -&gt; protos . stun_ssl . ssl . notBefore ) || ( time_sec &gt; flow -&gt; protos . stun_ssl . ssl . notAfter ) ) NDPI_SET_BIT ( flow -&gt; risk , NDPI_TLS_CERTIFICATE_EXPIRED ) ; } } } } else if ( ( packet -&gt; payload [ i ] == 0x55 ) &amp;&amp; ( packet -&gt; payload [ i + 1 ] == 0x1d ) &amp;&amp; ( packet -&gt; payload [ i + 2 ] == 0x11 ) ) { u_int8_t matched_name = 0 ; # ifdef DEBUG_TLS printf ( \"*******&lt;S2SV_blank&gt;[TLS]&lt;S2SV_blank&gt;Found&lt;S2SV_blank&gt;subjectAltName\\\\n\" ) ; # endif i += 3 ; i ++ ; if ( i &lt; packet -&gt; payload_packet_len ) { i += ( packet -&gt; payload [ i ] &amp; 0x80 ) ? ( packet -&gt; payload [ i ] &amp; 0x7F ) : 0 ; if ( i &lt; packet -&gt; payload_packet_len ) { i += 2 ; if ( i &lt; packet -&gt; payload_packet_len ) { i += ( packet -&gt; payload [ i ] &amp; 0x80 ) ? ( packet -&gt; payload [ i ] &amp; 0x7F ) : 0 ; i ++ ; while ( i &lt; packet -&gt; payload_packet_len ) { if ( packet -&gt; payload [ i ] == 0x82 ) { if ( ( i &lt; ( packet -&gt; payload_packet_len - 1 ) ) &amp;&amp; ( ( i + packet -&gt; payload [ i + 1 ] + 2 ) &lt; packet -&gt; payload_packet_len ) ) { u_int8_t len = packet -&gt; payload [ i + 1 ] ; char dNSName [ 256 ] ; i += 2 ; if ( len == 0 ) break ; strncpy ( dNSName , ( const char * ) &amp; packet -&gt; payload [ i ] , len ) ; dNSName [ len ] = '\\\\0' ; cleanupServerName ( dNSName , len ) ; # if DEBUG_TLS printf ( \"[TLS]&lt;S2SV_blank&gt;dNSName&lt;S2SV_blank&gt;%s&lt;S2SV_blank&gt;[%s]\\\\n\" , dNSName , flow -&gt; protos . stun_ssl . ssl . client_requested_server_name ) ; # endif if ( matched_name == 0 ) { if ( ( dNSName [ 0 ] == '*' ) &amp;&amp; strstr ( flow -&gt; protos . stun_ssl . ssl . client_requested_server_name , &amp; dNSName [ 1 ] ) ) matched_name = 1 ; else if ( strcmp ( flow -&gt; protos . stun_ssl . ssl . client_requested_server_name , dNSName ) == 0 ) matched_name = 1 ; } if ( flow -&gt; protos . stun_ssl . ssl . server_names == NULL ) flow -&gt; protos . stun_ssl . ssl . server_names = ndpi_strdup ( dNSName ) , flow -&gt; protos . stun_ssl . ssl . server_names_len = strlen ( dNSName ) ; else { u_int16_t dNSName_len = strlen ( dNSName ) ; u_int16_t newstr_len = flow -&gt; protos . stun_ssl . ssl . server_names_len + dNSName_len + 1 ; char * newstr = ( char * ) ndpi_realloc ( flow -&gt; protos . stun_ssl . ssl . server_names , flow -&gt; protos . stun_ssl . ssl . server_names_len + 1 , newstr_len + 1 ) ; if ( newstr ) { flow -&gt; protos . stun_ssl . ssl . server_names = newstr ; flow -&gt; protos . stun_ssl . ssl . server_names [ flow -&gt; protos . stun_ssl . ssl . server_names_len ] = ',' ; strncpy ( &amp; flow -&gt; protos . stun_ssl . ssl . server_names [ flow -&gt; protos . stun_ssl . ssl . server_names_len + 1 ] , dNSName , dNSName_len + 1 ) ; flow -&gt; protos . stun_ssl . ssl . server_names [ newstr_len ] = '\\\\0' ; flow -&gt; protos . stun_ssl . ssl . server_names_len = newstr_len ; } } if ( ! flow -&gt; l4 . tcp . tls . subprotocol_detected ) if ( ndpi_match_hostname_protocol ( ndpi_struct , flow , NDPI_PROTOCOL_TLS , dNSName , len ) ) flow -&gt; l4 . tcp . tls . subprotocol_detected = 1 ; i += len ; } else { # if DEBUG_TLS printf ( \"[TLS]&lt;S2SV_blank&gt;Leftover&lt;S2SV_blank&gt;%u&lt;S2SV_blank&gt;bytes\" , packet -&gt; payload_packet_len - i ) ; # endif break ; } } else { break ; } } if ( ! matched_name ) NDPI_SET_BIT ( flow -&gt; risk , NDPI_TLS_CERTIFICATE_MISMATCH ) ; } } } } } if ( rdn_len ) flow -&gt; protos . stun_ssl . ssl . subjectDN = ndpi_strdup ( rdnSeqBuf ) ; if ( flow -&gt; protos . stun_ssl . ssl . subjectDN &amp;&amp; flow -&gt; protos . stun_ssl . ssl . issuerDN &amp;&amp; ( ! strcmp ( flow -&gt; protos . stun_ssl . ssl . subjectDN , flow -&gt; protos . stun_ssl . ssl . issuerDN ) ) ) NDPI_SET_BIT ( flow -&gt; risk , NDPI_TLS_SELFSIGNED_CERTIFICATE ) ; # if DEBUG_TLS printf ( \"[TLS]&lt;S2SV_blank&gt;%s()&lt;S2SV_blank&gt;SubjectDN&lt;S2SV_blank&gt;[%s]\\\\n\" , __FUNCTION__ , rdnSeqBuf ) ; # endif }\n</pre>\n<li>/var/folders/ql/btm7z5tx32ddpsky8z3bz4_r0000gn/T/tmphp_y92lf.c:1: <b>  [1] </b> (buffer) <i> strncpy:\n  Easily used incorrectly; doesn't always \\0-terminate or check for invalid\n  pointers [MS-banned] (<a\n  href=\"https://cwe.mitre.org/data/definitions/120.html\">CWE-120</a>). </i>\n<pre>\nCWE-787 static void processCertificateElements ( struct ndpi_detection_module_struct * ndpi_struct , struct ndpi_flow_struct * flow , u_int16_t p_offset , u_int16_t certificate_len ) { struct ndpi_packet_struct * packet = &amp; flow -&gt; packet ; u_int num_found = 0 , i ; &lt;S2SV_StartBug&gt; char buffer [ 64 ] = { '\\\\0' } , rdnSeqBuf [ 1024 ] = { '\\\\0' } ; &lt;S2SV_EndBug&gt; u_int rdn_len = 0 ; # ifdef DEBUG_TLS printf ( \"[TLS]&lt;S2SV_blank&gt;%s()&lt;S2SV_blank&gt;[offset:&lt;S2SV_blank&gt;%u][certificate_len:&lt;S2SV_blank&gt;%u]\\\\n\" , __FUNCTION__ , p_offset , certificate_len ) ; # endif for ( i = p_offset ; i &lt; certificate_len ; i ++ ) { if ( ( packet -&gt; payload [ i ] == 0x55 ) &amp;&amp; ( packet -&gt; payload [ i + 1 ] == 0x04 ) &amp;&amp; ( packet -&gt; payload [ i + 2 ] == 0x03 ) ) { int rc = extractRDNSequence ( packet , i , buffer , sizeof ( buffer ) , rdnSeqBuf , &amp; rdn_len , sizeof ( rdnSeqBuf ) , \"CN\" ) ; if ( rc == - 1 ) break ; # ifdef DEBUG_TLS printf ( \"[TLS]&lt;S2SV_blank&gt;%s()&lt;S2SV_blank&gt;[%s][%s:&lt;S2SV_blank&gt;%s]\\\\n\" , __FUNCTION__ , ( num_found == 0 ) ? \"Subject\" : \"Issuer\" , \"Common&lt;S2SV_blank&gt;Name\" , buffer ) ; # endif } else if ( ( packet -&gt; payload [ i ] == 0x55 ) &amp;&amp; ( packet -&gt; payload [ i + 1 ] == 0x04 ) &amp;&amp; ( packet -&gt; payload [ i + 2 ] == 0x06 ) ) { int rc = extractRDNSequence ( packet , i , buffer , sizeof ( buffer ) , rdnSeqBuf , &amp; rdn_len , sizeof ( rdnSeqBuf ) , \"C\" ) ; if ( rc == - 1 ) break ; # ifdef DEBUG_TLS printf ( \"[TLS]&lt;S2SV_blank&gt;%s()&lt;S2SV_blank&gt;[%s][%s:&lt;S2SV_blank&gt;%s]\\\\n\" , __FUNCTION__ , ( num_found == 0 ) ? \"Subject\" : \"Issuer\" , \"Country\" , buffer ) ; # endif } else if ( ( packet -&gt; payload [ i ] == 0x55 ) &amp;&amp; ( packet -&gt; payload [ i + 1 ] == 0x04 ) &amp;&amp; ( packet -&gt; payload [ i + 2 ] == 0x07 ) ) { int rc = extractRDNSequence ( packet , i , buffer , sizeof ( buffer ) , rdnSeqBuf , &amp; rdn_len , sizeof ( rdnSeqBuf ) , \"L\" ) ; if ( rc == - 1 ) break ; # ifdef DEBUG_TLS printf ( \"[TLS]&lt;S2SV_blank&gt;%s()&lt;S2SV_blank&gt;[%s][%s:&lt;S2SV_blank&gt;%s]\\\\n\" , __FUNCTION__ , ( num_found == 0 ) ? \"Subject\" : \"Issuer\" , \"Locality\" , buffer ) ; # endif } else if ( ( packet -&gt; payload [ i ] == 0x55 ) &amp;&amp; ( packet -&gt; payload [ i + 1 ] == 0x04 ) &amp;&amp; ( packet -&gt; payload [ i + 2 ] == 0x08 ) ) { int rc = extractRDNSequence ( packet , i , buffer , sizeof ( buffer ) , rdnSeqBuf , &amp; rdn_len , sizeof ( rdnSeqBuf ) , \"ST\" ) ; if ( rc == - 1 ) break ; # ifdef DEBUG_TLS printf ( \"[TLS]&lt;S2SV_blank&gt;%s()&lt;S2SV_blank&gt;[%s][%s:&lt;S2SV_blank&gt;%s]\\\\n\" , __FUNCTION__ , ( num_found == 0 ) ? \"Subject\" : \"Issuer\" , \"State&lt;S2SV_blank&gt;or&lt;S2SV_blank&gt;Province\" , buffer ) ; # endif } else if ( ( packet -&gt; payload [ i ] == 0x55 ) &amp;&amp; ( packet -&gt; payload [ i + 1 ] == 0x04 ) &amp;&amp; ( packet -&gt; payload [ i + 2 ] == 0x0a ) ) { int rc = extractRDNSequence ( packet , i , buffer , sizeof ( buffer ) , rdnSeqBuf , &amp; rdn_len , sizeof ( rdnSeqBuf ) , \"O\" ) ; if ( rc == - 1 ) break ; # ifdef DEBUG_TLS printf ( \"[TLS]&lt;S2SV_blank&gt;%s()&lt;S2SV_blank&gt;[%s][%s:&lt;S2SV_blank&gt;%s]\\\\n\" , __FUNCTION__ , ( num_found == 0 ) ? \"Subject\" : \"Issuer\" , \"Organization&lt;S2SV_blank&gt;Name\" , buffer ) ; # endif } else if ( ( packet -&gt; payload [ i ] == 0x55 ) &amp;&amp; ( packet -&gt; payload [ i + 1 ] == 0x04 ) &amp;&amp; ( packet -&gt; payload [ i + 2 ] == 0x0b ) ) { int rc = extractRDNSequence ( packet , i , buffer , sizeof ( buffer ) , rdnSeqBuf , &amp; rdn_len , sizeof ( rdnSeqBuf ) , \"OU\" ) ; if ( rc == - 1 ) break ; # ifdef DEBUG_TLS printf ( \"[TLS]&lt;S2SV_blank&gt;%s()&lt;S2SV_blank&gt;[%s][%s:&lt;S2SV_blank&gt;%s]\\\\n\" , __FUNCTION__ , ( num_found == 0 ) ? \"Subject\" : \"Issuer\" , \"Organization&lt;S2SV_blank&gt;Unit\" , buffer ) ; # endif } else if ( ( packet -&gt; payload [ i ] == 0x30 ) &amp;&amp; ( packet -&gt; payload [ i + 1 ] == 0x1e ) &amp;&amp; ( packet -&gt; payload [ i + 2 ] == 0x17 ) ) { u_int8_t len = packet -&gt; payload [ i + 3 ] ; u_int offset = i + 4 ; if ( num_found == 0 ) { num_found ++ ; # ifdef DEBUG_TLS printf ( \"[TLS]&lt;S2SV_blank&gt;%s()&lt;S2SV_blank&gt;IssuerDN&lt;S2SV_blank&gt;[%s]\\\\n\" , __FUNCTION__ , rdnSeqBuf ) ; # endif if ( rdn_len ) flow -&gt; protos . stun_ssl . ssl . issuerDN = ndpi_strdup ( rdnSeqBuf ) ; rdn_len = 0 ; } if ( ( offset + len ) &lt; packet -&gt; payload_packet_len ) { char utcDate [ 32 ] ; # ifdef DEBUG_TLS u_int j ; printf ( \"[CERTIFICATE]&lt;S2SV_blank&gt;notBefore&lt;S2SV_blank&gt;[len:&lt;S2SV_blank&gt;%u][\" , len ) ; for ( j = 0 ; j &lt; len ; j ++ ) printf ( \"%c\" , packet -&gt; payload [ i + 4 + j ] ) ; printf ( \"]\\\\n\" ) ; # endif if ( len &lt; ( sizeof ( utcDate ) - 1 ) ) { struct tm utc ; utc . tm_isdst = - 1 ; strncpy ( utcDate , ( const char * ) &amp; packet -&gt; payload [ i + 4 ] , len ) ; utcDate [ len ] = '\\\\0' ; if ( strptime ( utcDate , \"%y%m%d%H%M%SZ\" , &amp; utc ) != NULL ) { flow -&gt; protos . stun_ssl . ssl . notBefore = timegm ( &amp; utc ) ; # ifdef DEBUG_TLS printf ( \"[CERTIFICATE]&lt;S2SV_blank&gt;notBefore&lt;S2SV_blank&gt;%u&lt;S2SV_blank&gt;[%s]\\\\n\" , flow -&gt; protos . stun_ssl . ssl . notBefore , utcDate ) ; # endif } } offset += len ; if ( ( offset + 1 ) &lt; packet -&gt; payload_packet_len ) { len = packet -&gt; payload [ offset + 1 ] ; offset += 2 ; if ( ( offset + len ) &lt; packet -&gt; payload_packet_len ) { u_int32_t time_sec = flow -&gt; packet . current_time_ms / 1000 ; # ifdef DEBUG_TLS u_int j ; printf ( \"[CERTIFICATE]&lt;S2SV_blank&gt;notAfter&lt;S2SV_blank&gt;[len:&lt;S2SV_blank&gt;%u][\" , len ) ; for ( j = 0 ; j &lt; len ; j ++ ) printf ( \"%c\" , packet -&gt; payload [ offset + j ] ) ; printf ( \"]\\\\n\" ) ; # endif if ( len &lt; ( sizeof ( utcDate ) - 1 ) ) { struct tm utc ; utc . tm_isdst = - 1 ; strncpy ( utcDate , ( const char * ) &amp; packet -&gt; payload [ offset ] , len ) ; utcDate [ len ] = '\\\\0' ; if ( strptime ( utcDate , \"%y%m%d%H%M%SZ\" , &amp; utc ) != NULL ) { flow -&gt; protos . stun_ssl . ssl . notAfter = timegm ( &amp; utc ) ; # ifdef DEBUG_TLS printf ( \"[CERTIFICATE]&lt;S2SV_blank&gt;notAfter&lt;S2SV_blank&gt;%u&lt;S2SV_blank&gt;[%s]\\\\n\" , flow -&gt; protos . stun_ssl . ssl . notAfter , utcDate ) ; # endif } } if ( ( time_sec &lt; flow -&gt; protos . stun_ssl . ssl . notBefore ) || ( time_sec &gt; flow -&gt; protos . stun_ssl . ssl . notAfter ) ) NDPI_SET_BIT ( flow -&gt; risk , NDPI_TLS_CERTIFICATE_EXPIRED ) ; } } } } else if ( ( packet -&gt; payload [ i ] == 0x55 ) &amp;&amp; ( packet -&gt; payload [ i + 1 ] == 0x1d ) &amp;&amp; ( packet -&gt; payload [ i + 2 ] == 0x11 ) ) { u_int8_t matched_name = 0 ; # ifdef DEBUG_TLS printf ( \"*******&lt;S2SV_blank&gt;[TLS]&lt;S2SV_blank&gt;Found&lt;S2SV_blank&gt;subjectAltName\\\\n\" ) ; # endif i += 3 ; i ++ ; if ( i &lt; packet -&gt; payload_packet_len ) { i += ( packet -&gt; payload [ i ] &amp; 0x80 ) ? ( packet -&gt; payload [ i ] &amp; 0x7F ) : 0 ; if ( i &lt; packet -&gt; payload_packet_len ) { i += 2 ; if ( i &lt; packet -&gt; payload_packet_len ) { i += ( packet -&gt; payload [ i ] &amp; 0x80 ) ? ( packet -&gt; payload [ i ] &amp; 0x7F ) : 0 ; i ++ ; while ( i &lt; packet -&gt; payload_packet_len ) { if ( packet -&gt; payload [ i ] == 0x82 ) { if ( ( i &lt; ( packet -&gt; payload_packet_len - 1 ) ) &amp;&amp; ( ( i + packet -&gt; payload [ i + 1 ] + 2 ) &lt; packet -&gt; payload_packet_len ) ) { u_int8_t len = packet -&gt; payload [ i + 1 ] ; char dNSName [ 256 ] ; i += 2 ; if ( len == 0 ) break ; strncpy ( dNSName , ( const char * ) &amp; packet -&gt; payload [ i ] , len ) ; dNSName [ len ] = '\\\\0' ; cleanupServerName ( dNSName , len ) ; # if DEBUG_TLS printf ( \"[TLS]&lt;S2SV_blank&gt;dNSName&lt;S2SV_blank&gt;%s&lt;S2SV_blank&gt;[%s]\\\\n\" , dNSName , flow -&gt; protos . stun_ssl . ssl . client_requested_server_name ) ; # endif if ( matched_name == 0 ) { if ( ( dNSName [ 0 ] == '*' ) &amp;&amp; strstr ( flow -&gt; protos . stun_ssl . ssl . client_requested_server_name , &amp; dNSName [ 1 ] ) ) matched_name = 1 ; else if ( strcmp ( flow -&gt; protos . stun_ssl . ssl . client_requested_server_name , dNSName ) == 0 ) matched_name = 1 ; } if ( flow -&gt; protos . stun_ssl . ssl . server_names == NULL ) flow -&gt; protos . stun_ssl . ssl . server_names = ndpi_strdup ( dNSName ) , flow -&gt; protos . stun_ssl . ssl . server_names_len = strlen ( dNSName ) ; else { u_int16_t dNSName_len = strlen ( dNSName ) ; u_int16_t newstr_len = flow -&gt; protos . stun_ssl . ssl . server_names_len + dNSName_len + 1 ; char * newstr = ( char * ) ndpi_realloc ( flow -&gt; protos . stun_ssl . ssl . server_names , flow -&gt; protos . stun_ssl . ssl . server_names_len + 1 , newstr_len + 1 ) ; if ( newstr ) { flow -&gt; protos . stun_ssl . ssl . server_names = newstr ; flow -&gt; protos . stun_ssl . ssl . server_names [ flow -&gt; protos . stun_ssl . ssl . server_names_len ] = ',' ; strncpy ( &amp; flow -&gt; protos . stun_ssl . ssl . server_names [ flow -&gt; protos . stun_ssl . ssl . server_names_len + 1 ] , dNSName , dNSName_len + 1 ) ; flow -&gt; protos . stun_ssl . ssl . server_names [ newstr_len ] = '\\\\0' ; flow -&gt; protos . stun_ssl . ssl . server_names_len = newstr_len ; } } if ( ! flow -&gt; l4 . tcp . tls . subprotocol_detected ) if ( ndpi_match_hostname_protocol ( ndpi_struct , flow , NDPI_PROTOCOL_TLS , dNSName , len ) ) flow -&gt; l4 . tcp . tls . subprotocol_detected = 1 ; i += len ; } else { # if DEBUG_TLS printf ( \"[TLS]&lt;S2SV_blank&gt;Leftover&lt;S2SV_blank&gt;%u&lt;S2SV_blank&gt;bytes\" , packet -&gt; payload_packet_len - i ) ; # endif break ; } } else { break ; } } if ( ! matched_name ) NDPI_SET_BIT ( flow -&gt; risk , NDPI_TLS_CERTIFICATE_MISMATCH ) ; } } } } } if ( rdn_len ) flow -&gt; protos . stun_ssl . ssl . subjectDN = ndpi_strdup ( rdnSeqBuf ) ; if ( flow -&gt; protos . stun_ssl . ssl . subjectDN &amp;&amp; flow -&gt; protos . stun_ssl . ssl . issuerDN &amp;&amp; ( ! strcmp ( flow -&gt; protos . stun_ssl . ssl . subjectDN , flow -&gt; protos . stun_ssl . ssl . issuerDN ) ) ) NDPI_SET_BIT ( flow -&gt; risk , NDPI_TLS_SELFSIGNED_CERTIFICATE ) ; # if DEBUG_TLS printf ( \"[TLS]&lt;S2SV_blank&gt;%s()&lt;S2SV_blank&gt;SubjectDN&lt;S2SV_blank&gt;[%s]\\\\n\" , __FUNCTION__ , rdnSeqBuf ) ; # endif }\n</pre>\n<li>/var/folders/ql/btm7z5tx32ddpsky8z3bz4_r0000gn/T/tmphp_y92lf.c:1: <b>  [1] </b> (buffer) <i> strncpy:\n  Easily used incorrectly; doesn't always \\0-terminate or check for invalid\n  pointers [MS-banned] (<a\n  href=\"https://cwe.mitre.org/data/definitions/120.html\">CWE-120</a>). </i>\n<pre>\nCWE-787 static void processCertificateElements ( struct ndpi_detection_module_struct * ndpi_struct , struct ndpi_flow_struct * flow , u_int16_t p_offset , u_int16_t certificate_len ) { struct ndpi_packet_struct * packet = &amp; flow -&gt; packet ; u_int num_found = 0 , i ; &lt;S2SV_StartBug&gt; char buffer [ 64 ] = { '\\\\0' } , rdnSeqBuf [ 1024 ] = { '\\\\0' } ; &lt;S2SV_EndBug&gt; u_int rdn_len = 0 ; # ifdef DEBUG_TLS printf ( \"[TLS]&lt;S2SV_blank&gt;%s()&lt;S2SV_blank&gt;[offset:&lt;S2SV_blank&gt;%u][certificate_len:&lt;S2SV_blank&gt;%u]\\\\n\" , __FUNCTION__ , p_offset , certificate_len ) ; # endif for ( i = p_offset ; i &lt; certificate_len ; i ++ ) { if ( ( packet -&gt; payload [ i ] == 0x55 ) &amp;&amp; ( packet -&gt; payload [ i + 1 ] == 0x04 ) &amp;&amp; ( packet -&gt; payload [ i + 2 ] == 0x03 ) ) { int rc = extractRDNSequence ( packet , i , buffer , sizeof ( buffer ) , rdnSeqBuf , &amp; rdn_len , sizeof ( rdnSeqBuf ) , \"CN\" ) ; if ( rc == - 1 ) break ; # ifdef DEBUG_TLS printf ( \"[TLS]&lt;S2SV_blank&gt;%s()&lt;S2SV_blank&gt;[%s][%s:&lt;S2SV_blank&gt;%s]\\\\n\" , __FUNCTION__ , ( num_found == 0 ) ? \"Subject\" : \"Issuer\" , \"Common&lt;S2SV_blank&gt;Name\" , buffer ) ; # endif } else if ( ( packet -&gt; payload [ i ] == 0x55 ) &amp;&amp; ( packet -&gt; payload [ i + 1 ] == 0x04 ) &amp;&amp; ( packet -&gt; payload [ i + 2 ] == 0x06 ) ) { int rc = extractRDNSequence ( packet , i , buffer , sizeof ( buffer ) , rdnSeqBuf , &amp; rdn_len , sizeof ( rdnSeqBuf ) , \"C\" ) ; if ( rc == - 1 ) break ; # ifdef DEBUG_TLS printf ( \"[TLS]&lt;S2SV_blank&gt;%s()&lt;S2SV_blank&gt;[%s][%s:&lt;S2SV_blank&gt;%s]\\\\n\" , __FUNCTION__ , ( num_found == 0 ) ? \"Subject\" : \"Issuer\" , \"Country\" , buffer ) ; # endif } else if ( ( packet -&gt; payload [ i ] == 0x55 ) &amp;&amp; ( packet -&gt; payload [ i + 1 ] == 0x04 ) &amp;&amp; ( packet -&gt; payload [ i + 2 ] == 0x07 ) ) { int rc = extractRDNSequence ( packet , i , buffer , sizeof ( buffer ) , rdnSeqBuf , &amp; rdn_len , sizeof ( rdnSeqBuf ) , \"L\" ) ; if ( rc == - 1 ) break ; # ifdef DEBUG_TLS printf ( \"[TLS]&lt;S2SV_blank&gt;%s()&lt;S2SV_blank&gt;[%s][%s:&lt;S2SV_blank&gt;%s]\\\\n\" , __FUNCTION__ , ( num_found == 0 ) ? \"Subject\" : \"Issuer\" , \"Locality\" , buffer ) ; # endif } else if ( ( packet -&gt; payload [ i ] == 0x55 ) &amp;&amp; ( packet -&gt; payload [ i + 1 ] == 0x04 ) &amp;&amp; ( packet -&gt; payload [ i + 2 ] == 0x08 ) ) { int rc = extractRDNSequence ( packet , i , buffer , sizeof ( buffer ) , rdnSeqBuf , &amp; rdn_len , sizeof ( rdnSeqBuf ) , \"ST\" ) ; if ( rc == - 1 ) break ; # ifdef DEBUG_TLS printf ( \"[TLS]&lt;S2SV_blank&gt;%s()&lt;S2SV_blank&gt;[%s][%s:&lt;S2SV_blank&gt;%s]\\\\n\" , __FUNCTION__ , ( num_found == 0 ) ? \"Subject\" : \"Issuer\" , \"State&lt;S2SV_blank&gt;or&lt;S2SV_blank&gt;Province\" , buffer ) ; # endif } else if ( ( packet -&gt; payload [ i ] == 0x55 ) &amp;&amp; ( packet -&gt; payload [ i + 1 ] == 0x04 ) &amp;&amp; ( packet -&gt; payload [ i + 2 ] == 0x0a ) ) { int rc = extractRDNSequence ( packet , i , buffer , sizeof ( buffer ) , rdnSeqBuf , &amp; rdn_len , sizeof ( rdnSeqBuf ) , \"O\" ) ; if ( rc == - 1 ) break ; # ifdef DEBUG_TLS printf ( \"[TLS]&lt;S2SV_blank&gt;%s()&lt;S2SV_blank&gt;[%s][%s:&lt;S2SV_blank&gt;%s]\\\\n\" , __FUNCTION__ , ( num_found == 0 ) ? \"Subject\" : \"Issuer\" , \"Organization&lt;S2SV_blank&gt;Name\" , buffer ) ; # endif } else if ( ( packet -&gt; payload [ i ] == 0x55 ) &amp;&amp; ( packet -&gt; payload [ i + 1 ] == 0x04 ) &amp;&amp; ( packet -&gt; payload [ i + 2 ] == 0x0b ) ) { int rc = extractRDNSequence ( packet , i , buffer , sizeof ( buffer ) , rdnSeqBuf , &amp; rdn_len , sizeof ( rdnSeqBuf ) , \"OU\" ) ; if ( rc == - 1 ) break ; # ifdef DEBUG_TLS printf ( \"[TLS]&lt;S2SV_blank&gt;%s()&lt;S2SV_blank&gt;[%s][%s:&lt;S2SV_blank&gt;%s]\\\\n\" , __FUNCTION__ , ( num_found == 0 ) ? \"Subject\" : \"Issuer\" , \"Organization&lt;S2SV_blank&gt;Unit\" , buffer ) ; # endif } else if ( ( packet -&gt; payload [ i ] == 0x30 ) &amp;&amp; ( packet -&gt; payload [ i + 1 ] == 0x1e ) &amp;&amp; ( packet -&gt; payload [ i + 2 ] == 0x17 ) ) { u_int8_t len = packet -&gt; payload [ i + 3 ] ; u_int offset = i + 4 ; if ( num_found == 0 ) { num_found ++ ; # ifdef DEBUG_TLS printf ( \"[TLS]&lt;S2SV_blank&gt;%s()&lt;S2SV_blank&gt;IssuerDN&lt;S2SV_blank&gt;[%s]\\\\n\" , __FUNCTION__ , rdnSeqBuf ) ; # endif if ( rdn_len ) flow -&gt; protos . stun_ssl . ssl . issuerDN = ndpi_strdup ( rdnSeqBuf ) ; rdn_len = 0 ; } if ( ( offset + len ) &lt; packet -&gt; payload_packet_len ) { char utcDate [ 32 ] ; # ifdef DEBUG_TLS u_int j ; printf ( \"[CERTIFICATE]&lt;S2SV_blank&gt;notBefore&lt;S2SV_blank&gt;[len:&lt;S2SV_blank&gt;%u][\" , len ) ; for ( j = 0 ; j &lt; len ; j ++ ) printf ( \"%c\" , packet -&gt; payload [ i + 4 + j ] ) ; printf ( \"]\\\\n\" ) ; # endif if ( len &lt; ( sizeof ( utcDate ) - 1 ) ) { struct tm utc ; utc . tm_isdst = - 1 ; strncpy ( utcDate , ( const char * ) &amp; packet -&gt; payload [ i + 4 ] , len ) ; utcDate [ len ] = '\\\\0' ; if ( strptime ( utcDate , \"%y%m%d%H%M%SZ\" , &amp; utc ) != NULL ) { flow -&gt; protos . stun_ssl . ssl . notBefore = timegm ( &amp; utc ) ; # ifdef DEBUG_TLS printf ( \"[CERTIFICATE]&lt;S2SV_blank&gt;notBefore&lt;S2SV_blank&gt;%u&lt;S2SV_blank&gt;[%s]\\\\n\" , flow -&gt; protos . stun_ssl . ssl . notBefore , utcDate ) ; # endif } } offset += len ; if ( ( offset + 1 ) &lt; packet -&gt; payload_packet_len ) { len = packet -&gt; payload [ offset + 1 ] ; offset += 2 ; if ( ( offset + len ) &lt; packet -&gt; payload_packet_len ) { u_int32_t time_sec = flow -&gt; packet . current_time_ms / 1000 ; # ifdef DEBUG_TLS u_int j ; printf ( \"[CERTIFICATE]&lt;S2SV_blank&gt;notAfter&lt;S2SV_blank&gt;[len:&lt;S2SV_blank&gt;%u][\" , len ) ; for ( j = 0 ; j &lt; len ; j ++ ) printf ( \"%c\" , packet -&gt; payload [ offset + j ] ) ; printf ( \"]\\\\n\" ) ; # endif if ( len &lt; ( sizeof ( utcDate ) - 1 ) ) { struct tm utc ; utc . tm_isdst = - 1 ; strncpy ( utcDate , ( const char * ) &amp; packet -&gt; payload [ offset ] , len ) ; utcDate [ len ] = '\\\\0' ; if ( strptime ( utcDate , \"%y%m%d%H%M%SZ\" , &amp; utc ) != NULL ) { flow -&gt; protos . stun_ssl . ssl . notAfter = timegm ( &amp; utc ) ; # ifdef DEBUG_TLS printf ( \"[CERTIFICATE]&lt;S2SV_blank&gt;notAfter&lt;S2SV_blank&gt;%u&lt;S2SV_blank&gt;[%s]\\\\n\" , flow -&gt; protos . stun_ssl . ssl . notAfter , utcDate ) ; # endif } } if ( ( time_sec &lt; flow -&gt; protos . stun_ssl . ssl . notBefore ) || ( time_sec &gt; flow -&gt; protos . stun_ssl . ssl . notAfter ) ) NDPI_SET_BIT ( flow -&gt; risk , NDPI_TLS_CERTIFICATE_EXPIRED ) ; } } } } else if ( ( packet -&gt; payload [ i ] == 0x55 ) &amp;&amp; ( packet -&gt; payload [ i + 1 ] == 0x1d ) &amp;&amp; ( packet -&gt; payload [ i + 2 ] == 0x11 ) ) { u_int8_t matched_name = 0 ; # ifdef DEBUG_TLS printf ( \"*******&lt;S2SV_blank&gt;[TLS]&lt;S2SV_blank&gt;Found&lt;S2SV_blank&gt;subjectAltName\\\\n\" ) ; # endif i += 3 ; i ++ ; if ( i &lt; packet -&gt; payload_packet_len ) { i += ( packet -&gt; payload [ i ] &amp; 0x80 ) ? ( packet -&gt; payload [ i ] &amp; 0x7F ) : 0 ; if ( i &lt; packet -&gt; payload_packet_len ) { i += 2 ; if ( i &lt; packet -&gt; payload_packet_len ) { i += ( packet -&gt; payload [ i ] &amp; 0x80 ) ? ( packet -&gt; payload [ i ] &amp; 0x7F ) : 0 ; i ++ ; while ( i &lt; packet -&gt; payload_packet_len ) { if ( packet -&gt; payload [ i ] == 0x82 ) { if ( ( i &lt; ( packet -&gt; payload_packet_len - 1 ) ) &amp;&amp; ( ( i + packet -&gt; payload [ i + 1 ] + 2 ) &lt; packet -&gt; payload_packet_len ) ) { u_int8_t len = packet -&gt; payload [ i + 1 ] ; char dNSName [ 256 ] ; i += 2 ; if ( len == 0 ) break ; strncpy ( dNSName , ( const char * ) &amp; packet -&gt; payload [ i ] , len ) ; dNSName [ len ] = '\\\\0' ; cleanupServerName ( dNSName , len ) ; # if DEBUG_TLS printf ( \"[TLS]&lt;S2SV_blank&gt;dNSName&lt;S2SV_blank&gt;%s&lt;S2SV_blank&gt;[%s]\\\\n\" , dNSName , flow -&gt; protos . stun_ssl . ssl . client_requested_server_name ) ; # endif if ( matched_name == 0 ) { if ( ( dNSName [ 0 ] == '*' ) &amp;&amp; strstr ( flow -&gt; protos . stun_ssl . ssl . client_requested_server_name , &amp; dNSName [ 1 ] ) ) matched_name = 1 ; else if ( strcmp ( flow -&gt; protos . stun_ssl . ssl . client_requested_server_name , dNSName ) == 0 ) matched_name = 1 ; } if ( flow -&gt; protos . stun_ssl . ssl . server_names == NULL ) flow -&gt; protos . stun_ssl . ssl . server_names = ndpi_strdup ( dNSName ) , flow -&gt; protos . stun_ssl . ssl . server_names_len = strlen ( dNSName ) ; else { u_int16_t dNSName_len = strlen ( dNSName ) ; u_int16_t newstr_len = flow -&gt; protos . stun_ssl . ssl . server_names_len + dNSName_len + 1 ; char * newstr = ( char * ) ndpi_realloc ( flow -&gt; protos . stun_ssl . ssl . server_names , flow -&gt; protos . stun_ssl . ssl . server_names_len + 1 , newstr_len + 1 ) ; if ( newstr ) { flow -&gt; protos . stun_ssl . ssl . server_names = newstr ; flow -&gt; protos . stun_ssl . ssl . server_names [ flow -&gt; protos . stun_ssl . ssl . server_names_len ] = ',' ; strncpy ( &amp; flow -&gt; protos . stun_ssl . ssl . server_names [ flow -&gt; protos . stun_ssl . ssl . server_names_len + 1 ] , dNSName , dNSName_len + 1 ) ; flow -&gt; protos . stun_ssl . ssl . server_names [ newstr_len ] = '\\\\0' ; flow -&gt; protos . stun_ssl . ssl . server_names_len = newstr_len ; } } if ( ! flow -&gt; l4 . tcp . tls . subprotocol_detected ) if ( ndpi_match_hostname_protocol ( ndpi_struct , flow , NDPI_PROTOCOL_TLS , dNSName , len ) ) flow -&gt; l4 . tcp . tls . subprotocol_detected = 1 ; i += len ; } else { # if DEBUG_TLS printf ( \"[TLS]&lt;S2SV_blank&gt;Leftover&lt;S2SV_blank&gt;%u&lt;S2SV_blank&gt;bytes\" , packet -&gt; payload_packet_len - i ) ; # endif break ; } } else { break ; } } if ( ! matched_name ) NDPI_SET_BIT ( flow -&gt; risk , NDPI_TLS_CERTIFICATE_MISMATCH ) ; } } } } } if ( rdn_len ) flow -&gt; protos . stun_ssl . ssl . subjectDN = ndpi_strdup ( rdnSeqBuf ) ; if ( flow -&gt; protos . stun_ssl . ssl . subjectDN &amp;&amp; flow -&gt; protos . stun_ssl . ssl . issuerDN &amp;&amp; ( ! strcmp ( flow -&gt; protos . stun_ssl . ssl . subjectDN , flow -&gt; protos . stun_ssl . ssl . issuerDN ) ) ) NDPI_SET_BIT ( flow -&gt; risk , NDPI_TLS_SELFSIGNED_CERTIFICATE ) ; # if DEBUG_TLS printf ( \"[TLS]&lt;S2SV_blank&gt;%s()&lt;S2SV_blank&gt;SubjectDN&lt;S2SV_blank&gt;[%s]\\\\n\" , __FUNCTION__ , rdnSeqBuf ) ; # endif }\n</pre>\n<li>/var/folders/ql/btm7z5tx32ddpsky8z3bz4_r0000gn/T/tmphp_y92lf.c:1: <b>  [1] </b> (buffer) <i> strncpy:\n  Easily used incorrectly; doesn't always \\0-terminate or check for invalid\n  pointers [MS-banned] (<a\n  href=\"https://cwe.mitre.org/data/definitions/120.html\">CWE-120</a>). </i>\n<pre>\nCWE-787 static void processCertificateElements ( struct ndpi_detection_module_struct * ndpi_struct , struct ndpi_flow_struct * flow , u_int16_t p_offset , u_int16_t certificate_len ) { struct ndpi_packet_struct * packet = &amp; flow -&gt; packet ; u_int num_found = 0 , i ; &lt;S2SV_StartBug&gt; char buffer [ 64 ] = { '\\\\0' } , rdnSeqBuf [ 1024 ] = { '\\\\0' } ; &lt;S2SV_EndBug&gt; u_int rdn_len = 0 ; # ifdef DEBUG_TLS printf ( \"[TLS]&lt;S2SV_blank&gt;%s()&lt;S2SV_blank&gt;[offset:&lt;S2SV_blank&gt;%u][certificate_len:&lt;S2SV_blank&gt;%u]\\\\n\" , __FUNCTION__ , p_offset , certificate_len ) ; # endif for ( i = p_offset ; i &lt; certificate_len ; i ++ ) { if ( ( packet -&gt; payload [ i ] == 0x55 ) &amp;&amp; ( packet -&gt; payload [ i + 1 ] == 0x04 ) &amp;&amp; ( packet -&gt; payload [ i + 2 ] == 0x03 ) ) { int rc = extractRDNSequence ( packet , i , buffer , sizeof ( buffer ) , rdnSeqBuf , &amp; rdn_len , sizeof ( rdnSeqBuf ) , \"CN\" ) ; if ( rc == - 1 ) break ; # ifdef DEBUG_TLS printf ( \"[TLS]&lt;S2SV_blank&gt;%s()&lt;S2SV_blank&gt;[%s][%s:&lt;S2SV_blank&gt;%s]\\\\n\" , __FUNCTION__ , ( num_found == 0 ) ? \"Subject\" : \"Issuer\" , \"Common&lt;S2SV_blank&gt;Name\" , buffer ) ; # endif } else if ( ( packet -&gt; payload [ i ] == 0x55 ) &amp;&amp; ( packet -&gt; payload [ i + 1 ] == 0x04 ) &amp;&amp; ( packet -&gt; payload [ i + 2 ] == 0x06 ) ) { int rc = extractRDNSequence ( packet , i , buffer , sizeof ( buffer ) , rdnSeqBuf , &amp; rdn_len , sizeof ( rdnSeqBuf ) , \"C\" ) ; if ( rc == - 1 ) break ; # ifdef DEBUG_TLS printf ( \"[TLS]&lt;S2SV_blank&gt;%s()&lt;S2SV_blank&gt;[%s][%s:&lt;S2SV_blank&gt;%s]\\\\n\" , __FUNCTION__ , ( num_found == 0 ) ? \"Subject\" : \"Issuer\" , \"Country\" , buffer ) ; # endif } else if ( ( packet -&gt; payload [ i ] == 0x55 ) &amp;&amp; ( packet -&gt; payload [ i + 1 ] == 0x04 ) &amp;&amp; ( packet -&gt; payload [ i + 2 ] == 0x07 ) ) { int rc = extractRDNSequence ( packet , i , buffer , sizeof ( buffer ) , rdnSeqBuf , &amp; rdn_len , sizeof ( rdnSeqBuf ) , \"L\" ) ; if ( rc == - 1 ) break ; # ifdef DEBUG_TLS printf ( \"[TLS]&lt;S2SV_blank&gt;%s()&lt;S2SV_blank&gt;[%s][%s:&lt;S2SV_blank&gt;%s]\\\\n\" , __FUNCTION__ , ( num_found == 0 ) ? \"Subject\" : \"Issuer\" , \"Locality\" , buffer ) ; # endif } else if ( ( packet -&gt; payload [ i ] == 0x55 ) &amp;&amp; ( packet -&gt; payload [ i + 1 ] == 0x04 ) &amp;&amp; ( packet -&gt; payload [ i + 2 ] == 0x08 ) ) { int rc = extractRDNSequence ( packet , i , buffer , sizeof ( buffer ) , rdnSeqBuf , &amp; rdn_len , sizeof ( rdnSeqBuf ) , \"ST\" ) ; if ( rc == - 1 ) break ; # ifdef DEBUG_TLS printf ( \"[TLS]&lt;S2SV_blank&gt;%s()&lt;S2SV_blank&gt;[%s][%s:&lt;S2SV_blank&gt;%s]\\\\n\" , __FUNCTION__ , ( num_found == 0 ) ? \"Subject\" : \"Issuer\" , \"State&lt;S2SV_blank&gt;or&lt;S2SV_blank&gt;Province\" , buffer ) ; # endif } else if ( ( packet -&gt; payload [ i ] == 0x55 ) &amp;&amp; ( packet -&gt; payload [ i + 1 ] == 0x04 ) &amp;&amp; ( packet -&gt; payload [ i + 2 ] == 0x0a ) ) { int rc = extractRDNSequence ( packet , i , buffer , sizeof ( buffer ) , rdnSeqBuf , &amp; rdn_len , sizeof ( rdnSeqBuf ) , \"O\" ) ; if ( rc == - 1 ) break ; # ifdef DEBUG_TLS printf ( \"[TLS]&lt;S2SV_blank&gt;%s()&lt;S2SV_blank&gt;[%s][%s:&lt;S2SV_blank&gt;%s]\\\\n\" , __FUNCTION__ , ( num_found == 0 ) ? \"Subject\" : \"Issuer\" , \"Organization&lt;S2SV_blank&gt;Name\" , buffer ) ; # endif } else if ( ( packet -&gt; payload [ i ] == 0x55 ) &amp;&amp; ( packet -&gt; payload [ i + 1 ] == 0x04 ) &amp;&amp; ( packet -&gt; payload [ i + 2 ] == 0x0b ) ) { int rc = extractRDNSequence ( packet , i , buffer , sizeof ( buffer ) , rdnSeqBuf , &amp; rdn_len , sizeof ( rdnSeqBuf ) , \"OU\" ) ; if ( rc == - 1 ) break ; # ifdef DEBUG_TLS printf ( \"[TLS]&lt;S2SV_blank&gt;%s()&lt;S2SV_blank&gt;[%s][%s:&lt;S2SV_blank&gt;%s]\\\\n\" , __FUNCTION__ , ( num_found == 0 ) ? \"Subject\" : \"Issuer\" , \"Organization&lt;S2SV_blank&gt;Unit\" , buffer ) ; # endif } else if ( ( packet -&gt; payload [ i ] == 0x30 ) &amp;&amp; ( packet -&gt; payload [ i + 1 ] == 0x1e ) &amp;&amp; ( packet -&gt; payload [ i + 2 ] == 0x17 ) ) { u_int8_t len = packet -&gt; payload [ i + 3 ] ; u_int offset = i + 4 ; if ( num_found == 0 ) { num_found ++ ; # ifdef DEBUG_TLS printf ( \"[TLS]&lt;S2SV_blank&gt;%s()&lt;S2SV_blank&gt;IssuerDN&lt;S2SV_blank&gt;[%s]\\\\n\" , __FUNCTION__ , rdnSeqBuf ) ; # endif if ( rdn_len ) flow -&gt; protos . stun_ssl . ssl . issuerDN = ndpi_strdup ( rdnSeqBuf ) ; rdn_len = 0 ; } if ( ( offset + len ) &lt; packet -&gt; payload_packet_len ) { char utcDate [ 32 ] ; # ifdef DEBUG_TLS u_int j ; printf ( \"[CERTIFICATE]&lt;S2SV_blank&gt;notBefore&lt;S2SV_blank&gt;[len:&lt;S2SV_blank&gt;%u][\" , len ) ; for ( j = 0 ; j &lt; len ; j ++ ) printf ( \"%c\" , packet -&gt; payload [ i + 4 + j ] ) ; printf ( \"]\\\\n\" ) ; # endif if ( len &lt; ( sizeof ( utcDate ) - 1 ) ) { struct tm utc ; utc . tm_isdst = - 1 ; strncpy ( utcDate , ( const char * ) &amp; packet -&gt; payload [ i + 4 ] , len ) ; utcDate [ len ] = '\\\\0' ; if ( strptime ( utcDate , \"%y%m%d%H%M%SZ\" , &amp; utc ) != NULL ) { flow -&gt; protos . stun_ssl . ssl . notBefore = timegm ( &amp; utc ) ; # ifdef DEBUG_TLS printf ( \"[CERTIFICATE]&lt;S2SV_blank&gt;notBefore&lt;S2SV_blank&gt;%u&lt;S2SV_blank&gt;[%s]\\\\n\" , flow -&gt; protos . stun_ssl . ssl . notBefore , utcDate ) ; # endif } } offset += len ; if ( ( offset + 1 ) &lt; packet -&gt; payload_packet_len ) { len = packet -&gt; payload [ offset + 1 ] ; offset += 2 ; if ( ( offset + len ) &lt; packet -&gt; payload_packet_len ) { u_int32_t time_sec = flow -&gt; packet . current_time_ms / 1000 ; # ifdef DEBUG_TLS u_int j ; printf ( \"[CERTIFICATE]&lt;S2SV_blank&gt;notAfter&lt;S2SV_blank&gt;[len:&lt;S2SV_blank&gt;%u][\" , len ) ; for ( j = 0 ; j &lt; len ; j ++ ) printf ( \"%c\" , packet -&gt; payload [ offset + j ] ) ; printf ( \"]\\\\n\" ) ; # endif if ( len &lt; ( sizeof ( utcDate ) - 1 ) ) { struct tm utc ; utc . tm_isdst = - 1 ; strncpy ( utcDate , ( const char * ) &amp; packet -&gt; payload [ offset ] , len ) ; utcDate [ len ] = '\\\\0' ; if ( strptime ( utcDate , \"%y%m%d%H%M%SZ\" , &amp; utc ) != NULL ) { flow -&gt; protos . stun_ssl . ssl . notAfter = timegm ( &amp; utc ) ; # ifdef DEBUG_TLS printf ( \"[CERTIFICATE]&lt;S2SV_blank&gt;notAfter&lt;S2SV_blank&gt;%u&lt;S2SV_blank&gt;[%s]\\\\n\" , flow -&gt; protos . stun_ssl . ssl . notAfter , utcDate ) ; # endif } } if ( ( time_sec &lt; flow -&gt; protos . stun_ssl . ssl . notBefore ) || ( time_sec &gt; flow -&gt; protos . stun_ssl . ssl . notAfter ) ) NDPI_SET_BIT ( flow -&gt; risk , NDPI_TLS_CERTIFICATE_EXPIRED ) ; } } } } else if ( ( packet -&gt; payload [ i ] == 0x55 ) &amp;&amp; ( packet -&gt; payload [ i + 1 ] == 0x1d ) &amp;&amp; ( packet -&gt; payload [ i + 2 ] == 0x11 ) ) { u_int8_t matched_name = 0 ; # ifdef DEBUG_TLS printf ( \"*******&lt;S2SV_blank&gt;[TLS]&lt;S2SV_blank&gt;Found&lt;S2SV_blank&gt;subjectAltName\\\\n\" ) ; # endif i += 3 ; i ++ ; if ( i &lt; packet -&gt; payload_packet_len ) { i += ( packet -&gt; payload [ i ] &amp; 0x80 ) ? ( packet -&gt; payload [ i ] &amp; 0x7F ) : 0 ; if ( i &lt; packet -&gt; payload_packet_len ) { i += 2 ; if ( i &lt; packet -&gt; payload_packet_len ) { i += ( packet -&gt; payload [ i ] &amp; 0x80 ) ? ( packet -&gt; payload [ i ] &amp; 0x7F ) : 0 ; i ++ ; while ( i &lt; packet -&gt; payload_packet_len ) { if ( packet -&gt; payload [ i ] == 0x82 ) { if ( ( i &lt; ( packet -&gt; payload_packet_len - 1 ) ) &amp;&amp; ( ( i + packet -&gt; payload [ i + 1 ] + 2 ) &lt; packet -&gt; payload_packet_len ) ) { u_int8_t len = packet -&gt; payload [ i + 1 ] ; char dNSName [ 256 ] ; i += 2 ; if ( len == 0 ) break ; strncpy ( dNSName , ( const char * ) &amp; packet -&gt; payload [ i ] , len ) ; dNSName [ len ] = '\\\\0' ; cleanupServerName ( dNSName , len ) ; # if DEBUG_TLS printf ( \"[TLS]&lt;S2SV_blank&gt;dNSName&lt;S2SV_blank&gt;%s&lt;S2SV_blank&gt;[%s]\\\\n\" , dNSName , flow -&gt; protos . stun_ssl . ssl . client_requested_server_name ) ; # endif if ( matched_name == 0 ) { if ( ( dNSName [ 0 ] == '*' ) &amp;&amp; strstr ( flow -&gt; protos . stun_ssl . ssl . client_requested_server_name , &amp; dNSName [ 1 ] ) ) matched_name = 1 ; else if ( strcmp ( flow -&gt; protos . stun_ssl . ssl . client_requested_server_name , dNSName ) == 0 ) matched_name = 1 ; } if ( flow -&gt; protos . stun_ssl . ssl . server_names == NULL ) flow -&gt; protos . stun_ssl . ssl . server_names = ndpi_strdup ( dNSName ) , flow -&gt; protos . stun_ssl . ssl . server_names_len = strlen ( dNSName ) ; else { u_int16_t dNSName_len = strlen ( dNSName ) ; u_int16_t newstr_len = flow -&gt; protos . stun_ssl . ssl . server_names_len + dNSName_len + 1 ; char * newstr = ( char * ) ndpi_realloc ( flow -&gt; protos . stun_ssl . ssl . server_names , flow -&gt; protos . stun_ssl . ssl . server_names_len + 1 , newstr_len + 1 ) ; if ( newstr ) { flow -&gt; protos . stun_ssl . ssl . server_names = newstr ; flow -&gt; protos . stun_ssl . ssl . server_names [ flow -&gt; protos . stun_ssl . ssl . server_names_len ] = ',' ; strncpy ( &amp; flow -&gt; protos . stun_ssl . ssl . server_names [ flow -&gt; protos . stun_ssl . ssl . server_names_len + 1 ] , dNSName , dNSName_len + 1 ) ; flow -&gt; protos . stun_ssl . ssl . server_names [ newstr_len ] = '\\\\0' ; flow -&gt; protos . stun_ssl . ssl . server_names_len = newstr_len ; } } if ( ! flow -&gt; l4 . tcp . tls . subprotocol_detected ) if ( ndpi_match_hostname_protocol ( ndpi_struct , flow , NDPI_PROTOCOL_TLS , dNSName , len ) ) flow -&gt; l4 . tcp . tls . subprotocol_detected = 1 ; i += len ; } else { # if DEBUG_TLS printf ( \"[TLS]&lt;S2SV_blank&gt;Leftover&lt;S2SV_blank&gt;%u&lt;S2SV_blank&gt;bytes\" , packet -&gt; payload_packet_len - i ) ; # endif break ; } } else { break ; } } if ( ! matched_name ) NDPI_SET_BIT ( flow -&gt; risk , NDPI_TLS_CERTIFICATE_MISMATCH ) ; } } } } } if ( rdn_len ) flow -&gt; protos . stun_ssl . ssl . subjectDN = ndpi_strdup ( rdnSeqBuf ) ; if ( flow -&gt; protos . stun_ssl . ssl . subjectDN &amp;&amp; flow -&gt; protos . stun_ssl . ssl . issuerDN &amp;&amp; ( ! strcmp ( flow -&gt; protos . stun_ssl . ssl . subjectDN , flow -&gt; protos . stun_ssl . ssl . issuerDN ) ) ) NDPI_SET_BIT ( flow -&gt; risk , NDPI_TLS_SELFSIGNED_CERTIFICATE ) ; # if DEBUG_TLS printf ( \"[TLS]&lt;S2SV_blank&gt;%s()&lt;S2SV_blank&gt;SubjectDN&lt;S2SV_blank&gt;[%s]\\\\n\" , __FUNCTION__ , rdnSeqBuf ) ; # endif }\n</pre>\n<li>/var/folders/ql/btm7z5tx32ddpsky8z3bz4_r0000gn/T/tmphp_y92lf.c:1: <b>  [1] </b> (buffer) <i> strlen:\n  Does not handle strings that are not \\0-terminated; if given one it may\n  perform an over-read (it could cause a crash if unprotected) (<a\n  href=\"https://cwe.mitre.org/data/definitions/126.html\">CWE-126</a>). </i>\n<pre>\nCWE-787 static void processCertificateElements ( struct ndpi_detection_module_struct * ndpi_struct , struct ndpi_flow_struct * flow , u_int16_t p_offset , u_int16_t certificate_len ) { struct ndpi_packet_struct * packet = &amp; flow -&gt; packet ; u_int num_found = 0 , i ; &lt;S2SV_StartBug&gt; char buffer [ 64 ] = { '\\\\0' } , rdnSeqBuf [ 1024 ] = { '\\\\0' } ; &lt;S2SV_EndBug&gt; u_int rdn_len = 0 ; # ifdef DEBUG_TLS printf ( \"[TLS]&lt;S2SV_blank&gt;%s()&lt;S2SV_blank&gt;[offset:&lt;S2SV_blank&gt;%u][certificate_len:&lt;S2SV_blank&gt;%u]\\\\n\" , __FUNCTION__ , p_offset , certificate_len ) ; # endif for ( i = p_offset ; i &lt; certificate_len ; i ++ ) { if ( ( packet -&gt; payload [ i ] == 0x55 ) &amp;&amp; ( packet -&gt; payload [ i + 1 ] == 0x04 ) &amp;&amp; ( packet -&gt; payload [ i + 2 ] == 0x03 ) ) { int rc = extractRDNSequence ( packet , i , buffer , sizeof ( buffer ) , rdnSeqBuf , &amp; rdn_len , sizeof ( rdnSeqBuf ) , \"CN\" ) ; if ( rc == - 1 ) break ; # ifdef DEBUG_TLS printf ( \"[TLS]&lt;S2SV_blank&gt;%s()&lt;S2SV_blank&gt;[%s][%s:&lt;S2SV_blank&gt;%s]\\\\n\" , __FUNCTION__ , ( num_found == 0 ) ? \"Subject\" : \"Issuer\" , \"Common&lt;S2SV_blank&gt;Name\" , buffer ) ; # endif } else if ( ( packet -&gt; payload [ i ] == 0x55 ) &amp;&amp; ( packet -&gt; payload [ i + 1 ] == 0x04 ) &amp;&amp; ( packet -&gt; payload [ i + 2 ] == 0x06 ) ) { int rc = extractRDNSequence ( packet , i , buffer , sizeof ( buffer ) , rdnSeqBuf , &amp; rdn_len , sizeof ( rdnSeqBuf ) , \"C\" ) ; if ( rc == - 1 ) break ; # ifdef DEBUG_TLS printf ( \"[TLS]&lt;S2SV_blank&gt;%s()&lt;S2SV_blank&gt;[%s][%s:&lt;S2SV_blank&gt;%s]\\\\n\" , __FUNCTION__ , ( num_found == 0 ) ? \"Subject\" : \"Issuer\" , \"Country\" , buffer ) ; # endif } else if ( ( packet -&gt; payload [ i ] == 0x55 ) &amp;&amp; ( packet -&gt; payload [ i + 1 ] == 0x04 ) &amp;&amp; ( packet -&gt; payload [ i + 2 ] == 0x07 ) ) { int rc = extractRDNSequence ( packet , i , buffer , sizeof ( buffer ) , rdnSeqBuf , &amp; rdn_len , sizeof ( rdnSeqBuf ) , \"L\" ) ; if ( rc == - 1 ) break ; # ifdef DEBUG_TLS printf ( \"[TLS]&lt;S2SV_blank&gt;%s()&lt;S2SV_blank&gt;[%s][%s:&lt;S2SV_blank&gt;%s]\\\\n\" , __FUNCTION__ , ( num_found == 0 ) ? \"Subject\" : \"Issuer\" , \"Locality\" , buffer ) ; # endif } else if ( ( packet -&gt; payload [ i ] == 0x55 ) &amp;&amp; ( packet -&gt; payload [ i + 1 ] == 0x04 ) &amp;&amp; ( packet -&gt; payload [ i + 2 ] == 0x08 ) ) { int rc = extractRDNSequence ( packet , i , buffer , sizeof ( buffer ) , rdnSeqBuf , &amp; rdn_len , sizeof ( rdnSeqBuf ) , \"ST\" ) ; if ( rc == - 1 ) break ; # ifdef DEBUG_TLS printf ( \"[TLS]&lt;S2SV_blank&gt;%s()&lt;S2SV_blank&gt;[%s][%s:&lt;S2SV_blank&gt;%s]\\\\n\" , __FUNCTION__ , ( num_found == 0 ) ? \"Subject\" : \"Issuer\" , \"State&lt;S2SV_blank&gt;or&lt;S2SV_blank&gt;Province\" , buffer ) ; # endif } else if ( ( packet -&gt; payload [ i ] == 0x55 ) &amp;&amp; ( packet -&gt; payload [ i + 1 ] == 0x04 ) &amp;&amp; ( packet -&gt; payload [ i + 2 ] == 0x0a ) ) { int rc = extractRDNSequence ( packet , i , buffer , sizeof ( buffer ) , rdnSeqBuf , &amp; rdn_len , sizeof ( rdnSeqBuf ) , \"O\" ) ; if ( rc == - 1 ) break ; # ifdef DEBUG_TLS printf ( \"[TLS]&lt;S2SV_blank&gt;%s()&lt;S2SV_blank&gt;[%s][%s:&lt;S2SV_blank&gt;%s]\\\\n\" , __FUNCTION__ , ( num_found == 0 ) ? \"Subject\" : \"Issuer\" , \"Organization&lt;S2SV_blank&gt;Name\" , buffer ) ; # endif } else if ( ( packet -&gt; payload [ i ] == 0x55 ) &amp;&amp; ( packet -&gt; payload [ i + 1 ] == 0x04 ) &amp;&amp; ( packet -&gt; payload [ i + 2 ] == 0x0b ) ) { int rc = extractRDNSequence ( packet , i , buffer , sizeof ( buffer ) , rdnSeqBuf , &amp; rdn_len , sizeof ( rdnSeqBuf ) , \"OU\" ) ; if ( rc == - 1 ) break ; # ifdef DEBUG_TLS printf ( \"[TLS]&lt;S2SV_blank&gt;%s()&lt;S2SV_blank&gt;[%s][%s:&lt;S2SV_blank&gt;%s]\\\\n\" , __FUNCTION__ , ( num_found == 0 ) ? \"Subject\" : \"Issuer\" , \"Organization&lt;S2SV_blank&gt;Unit\" , buffer ) ; # endif } else if ( ( packet -&gt; payload [ i ] == 0x30 ) &amp;&amp; ( packet -&gt; payload [ i + 1 ] == 0x1e ) &amp;&amp; ( packet -&gt; payload [ i + 2 ] == 0x17 ) ) { u_int8_t len = packet -&gt; payload [ i + 3 ] ; u_int offset = i + 4 ; if ( num_found == 0 ) { num_found ++ ; # ifdef DEBUG_TLS printf ( \"[TLS]&lt;S2SV_blank&gt;%s()&lt;S2SV_blank&gt;IssuerDN&lt;S2SV_blank&gt;[%s]\\\\n\" , __FUNCTION__ , rdnSeqBuf ) ; # endif if ( rdn_len ) flow -&gt; protos . stun_ssl . ssl . issuerDN = ndpi_strdup ( rdnSeqBuf ) ; rdn_len = 0 ; } if ( ( offset + len ) &lt; packet -&gt; payload_packet_len ) { char utcDate [ 32 ] ; # ifdef DEBUG_TLS u_int j ; printf ( \"[CERTIFICATE]&lt;S2SV_blank&gt;notBefore&lt;S2SV_blank&gt;[len:&lt;S2SV_blank&gt;%u][\" , len ) ; for ( j = 0 ; j &lt; len ; j ++ ) printf ( \"%c\" , packet -&gt; payload [ i + 4 + j ] ) ; printf ( \"]\\\\n\" ) ; # endif if ( len &lt; ( sizeof ( utcDate ) - 1 ) ) { struct tm utc ; utc . tm_isdst = - 1 ; strncpy ( utcDate , ( const char * ) &amp; packet -&gt; payload [ i + 4 ] , len ) ; utcDate [ len ] = '\\\\0' ; if ( strptime ( utcDate , \"%y%m%d%H%M%SZ\" , &amp; utc ) != NULL ) { flow -&gt; protos . stun_ssl . ssl . notBefore = timegm ( &amp; utc ) ; # ifdef DEBUG_TLS printf ( \"[CERTIFICATE]&lt;S2SV_blank&gt;notBefore&lt;S2SV_blank&gt;%u&lt;S2SV_blank&gt;[%s]\\\\n\" , flow -&gt; protos . stun_ssl . ssl . notBefore , utcDate ) ; # endif } } offset += len ; if ( ( offset + 1 ) &lt; packet -&gt; payload_packet_len ) { len = packet -&gt; payload [ offset + 1 ] ; offset += 2 ; if ( ( offset + len ) &lt; packet -&gt; payload_packet_len ) { u_int32_t time_sec = flow -&gt; packet . current_time_ms / 1000 ; # ifdef DEBUG_TLS u_int j ; printf ( \"[CERTIFICATE]&lt;S2SV_blank&gt;notAfter&lt;S2SV_blank&gt;[len:&lt;S2SV_blank&gt;%u][\" , len ) ; for ( j = 0 ; j &lt; len ; j ++ ) printf ( \"%c\" , packet -&gt; payload [ offset + j ] ) ; printf ( \"]\\\\n\" ) ; # endif if ( len &lt; ( sizeof ( utcDate ) - 1 ) ) { struct tm utc ; utc . tm_isdst = - 1 ; strncpy ( utcDate , ( const char * ) &amp; packet -&gt; payload [ offset ] , len ) ; utcDate [ len ] = '\\\\0' ; if ( strptime ( utcDate , \"%y%m%d%H%M%SZ\" , &amp; utc ) != NULL ) { flow -&gt; protos . stun_ssl . ssl . notAfter = timegm ( &amp; utc ) ; # ifdef DEBUG_TLS printf ( \"[CERTIFICATE]&lt;S2SV_blank&gt;notAfter&lt;S2SV_blank&gt;%u&lt;S2SV_blank&gt;[%s]\\\\n\" , flow -&gt; protos . stun_ssl . ssl . notAfter , utcDate ) ; # endif } } if ( ( time_sec &lt; flow -&gt; protos . stun_ssl . ssl . notBefore ) || ( time_sec &gt; flow -&gt; protos . stun_ssl . ssl . notAfter ) ) NDPI_SET_BIT ( flow -&gt; risk , NDPI_TLS_CERTIFICATE_EXPIRED ) ; } } } } else if ( ( packet -&gt; payload [ i ] == 0x55 ) &amp;&amp; ( packet -&gt; payload [ i + 1 ] == 0x1d ) &amp;&amp; ( packet -&gt; payload [ i + 2 ] == 0x11 ) ) { u_int8_t matched_name = 0 ; # ifdef DEBUG_TLS printf ( \"*******&lt;S2SV_blank&gt;[TLS]&lt;S2SV_blank&gt;Found&lt;S2SV_blank&gt;subjectAltName\\\\n\" ) ; # endif i += 3 ; i ++ ; if ( i &lt; packet -&gt; payload_packet_len ) { i += ( packet -&gt; payload [ i ] &amp; 0x80 ) ? ( packet -&gt; payload [ i ] &amp; 0x7F ) : 0 ; if ( i &lt; packet -&gt; payload_packet_len ) { i += 2 ; if ( i &lt; packet -&gt; payload_packet_len ) { i += ( packet -&gt; payload [ i ] &amp; 0x80 ) ? ( packet -&gt; payload [ i ] &amp; 0x7F ) : 0 ; i ++ ; while ( i &lt; packet -&gt; payload_packet_len ) { if ( packet -&gt; payload [ i ] == 0x82 ) { if ( ( i &lt; ( packet -&gt; payload_packet_len - 1 ) ) &amp;&amp; ( ( i + packet -&gt; payload [ i + 1 ] + 2 ) &lt; packet -&gt; payload_packet_len ) ) { u_int8_t len = packet -&gt; payload [ i + 1 ] ; char dNSName [ 256 ] ; i += 2 ; if ( len == 0 ) break ; strncpy ( dNSName , ( const char * ) &amp; packet -&gt; payload [ i ] , len ) ; dNSName [ len ] = '\\\\0' ; cleanupServerName ( dNSName , len ) ; # if DEBUG_TLS printf ( \"[TLS]&lt;S2SV_blank&gt;dNSName&lt;S2SV_blank&gt;%s&lt;S2SV_blank&gt;[%s]\\\\n\" , dNSName , flow -&gt; protos . stun_ssl . ssl . client_requested_server_name ) ; # endif if ( matched_name == 0 ) { if ( ( dNSName [ 0 ] == '*' ) &amp;&amp; strstr ( flow -&gt; protos . stun_ssl . ssl . client_requested_server_name , &amp; dNSName [ 1 ] ) ) matched_name = 1 ; else if ( strcmp ( flow -&gt; protos . stun_ssl . ssl . client_requested_server_name , dNSName ) == 0 ) matched_name = 1 ; } if ( flow -&gt; protos . stun_ssl . ssl . server_names == NULL ) flow -&gt; protos . stun_ssl . ssl . server_names = ndpi_strdup ( dNSName ) , flow -&gt; protos . stun_ssl . ssl . server_names_len = strlen ( dNSName ) ; else { u_int16_t dNSName_len = strlen ( dNSName ) ; u_int16_t newstr_len = flow -&gt; protos . stun_ssl . ssl . server_names_len + dNSName_len + 1 ; char * newstr = ( char * ) ndpi_realloc ( flow -&gt; protos . stun_ssl . ssl . server_names , flow -&gt; protos . stun_ssl . ssl . server_names_len + 1 , newstr_len + 1 ) ; if ( newstr ) { flow -&gt; protos . stun_ssl . ssl . server_names = newstr ; flow -&gt; protos . stun_ssl . ssl . server_names [ flow -&gt; protos . stun_ssl . ssl . server_names_len ] = ',' ; strncpy ( &amp; flow -&gt; protos . stun_ssl . ssl . server_names [ flow -&gt; protos . stun_ssl . ssl . server_names_len + 1 ] , dNSName , dNSName_len + 1 ) ; flow -&gt; protos . stun_ssl . ssl . server_names [ newstr_len ] = '\\\\0' ; flow -&gt; protos . stun_ssl . ssl . server_names_len = newstr_len ; } } if ( ! flow -&gt; l4 . tcp . tls . subprotocol_detected ) if ( ndpi_match_hostname_protocol ( ndpi_struct , flow , NDPI_PROTOCOL_TLS , dNSName , len ) ) flow -&gt; l4 . tcp . tls . subprotocol_detected = 1 ; i += len ; } else { # if DEBUG_TLS printf ( \"[TLS]&lt;S2SV_blank&gt;Leftover&lt;S2SV_blank&gt;%u&lt;S2SV_blank&gt;bytes\" , packet -&gt; payload_packet_len - i ) ; # endif break ; } } else { break ; } } if ( ! matched_name ) NDPI_SET_BIT ( flow -&gt; risk , NDPI_TLS_CERTIFICATE_MISMATCH ) ; } } } } } if ( rdn_len ) flow -&gt; protos . stun_ssl . ssl . subjectDN = ndpi_strdup ( rdnSeqBuf ) ; if ( flow -&gt; protos . stun_ssl . ssl . subjectDN &amp;&amp; flow -&gt; protos . stun_ssl . ssl . issuerDN &amp;&amp; ( ! strcmp ( flow -&gt; protos . stun_ssl . ssl . subjectDN , flow -&gt; protos . stun_ssl . ssl . issuerDN ) ) ) NDPI_SET_BIT ( flow -&gt; risk , NDPI_TLS_SELFSIGNED_CERTIFICATE ) ; # if DEBUG_TLS printf ( \"[TLS]&lt;S2SV_blank&gt;%s()&lt;S2SV_blank&gt;SubjectDN&lt;S2SV_blank&gt;[%s]\\\\n\" , __FUNCTION__ , rdnSeqBuf ) ; # endif }\n</pre>\n<li>/var/folders/ql/btm7z5tx32ddpsky8z3bz4_r0000gn/T/tmphp_y92lf.c:1: <b>  [1] </b> (buffer) <i> strlen:\n  Does not handle strings that are not \\0-terminated; if given one it may\n  perform an over-read (it could cause a crash if unprotected) (<a\n  href=\"https://cwe.mitre.org/data/definitions/126.html\">CWE-126</a>). </i>\n<pre>\nCWE-787 static void processCertificateElements ( struct ndpi_detection_module_struct * ndpi_struct , struct ndpi_flow_struct * flow , u_int16_t p_offset , u_int16_t certificate_len ) { struct ndpi_packet_struct * packet = &amp; flow -&gt; packet ; u_int num_found = 0 , i ; &lt;S2SV_StartBug&gt; char buffer [ 64 ] = { '\\\\0' } , rdnSeqBuf [ 1024 ] = { '\\\\0' } ; &lt;S2SV_EndBug&gt; u_int rdn_len = 0 ; # ifdef DEBUG_TLS printf ( \"[TLS]&lt;S2SV_blank&gt;%s()&lt;S2SV_blank&gt;[offset:&lt;S2SV_blank&gt;%u][certificate_len:&lt;S2SV_blank&gt;%u]\\\\n\" , __FUNCTION__ , p_offset , certificate_len ) ; # endif for ( i = p_offset ; i &lt; certificate_len ; i ++ ) { if ( ( packet -&gt; payload [ i ] == 0x55 ) &amp;&amp; ( packet -&gt; payload [ i + 1 ] == 0x04 ) &amp;&amp; ( packet -&gt; payload [ i + 2 ] == 0x03 ) ) { int rc = extractRDNSequence ( packet , i , buffer , sizeof ( buffer ) , rdnSeqBuf , &amp; rdn_len , sizeof ( rdnSeqBuf ) , \"CN\" ) ; if ( rc == - 1 ) break ; # ifdef DEBUG_TLS printf ( \"[TLS]&lt;S2SV_blank&gt;%s()&lt;S2SV_blank&gt;[%s][%s:&lt;S2SV_blank&gt;%s]\\\\n\" , __FUNCTION__ , ( num_found == 0 ) ? \"Subject\" : \"Issuer\" , \"Common&lt;S2SV_blank&gt;Name\" , buffer ) ; # endif } else if ( ( packet -&gt; payload [ i ] == 0x55 ) &amp;&amp; ( packet -&gt; payload [ i + 1 ] == 0x04 ) &amp;&amp; ( packet -&gt; payload [ i + 2 ] == 0x06 ) ) { int rc = extractRDNSequence ( packet , i , buffer , sizeof ( buffer ) , rdnSeqBuf , &amp; rdn_len , sizeof ( rdnSeqBuf ) , \"C\" ) ; if ( rc == - 1 ) break ; # ifdef DEBUG_TLS printf ( \"[TLS]&lt;S2SV_blank&gt;%s()&lt;S2SV_blank&gt;[%s][%s:&lt;S2SV_blank&gt;%s]\\\\n\" , __FUNCTION__ , ( num_found == 0 ) ? \"Subject\" : \"Issuer\" , \"Country\" , buffer ) ; # endif } else if ( ( packet -&gt; payload [ i ] == 0x55 ) &amp;&amp; ( packet -&gt; payload [ i + 1 ] == 0x04 ) &amp;&amp; ( packet -&gt; payload [ i + 2 ] == 0x07 ) ) { int rc = extractRDNSequence ( packet , i , buffer , sizeof ( buffer ) , rdnSeqBuf , &amp; rdn_len , sizeof ( rdnSeqBuf ) , \"L\" ) ; if ( rc == - 1 ) break ; # ifdef DEBUG_TLS printf ( \"[TLS]&lt;S2SV_blank&gt;%s()&lt;S2SV_blank&gt;[%s][%s:&lt;S2SV_blank&gt;%s]\\\\n\" , __FUNCTION__ , ( num_found == 0 ) ? \"Subject\" : \"Issuer\" , \"Locality\" , buffer ) ; # endif } else if ( ( packet -&gt; payload [ i ] == 0x55 ) &amp;&amp; ( packet -&gt; payload [ i + 1 ] == 0x04 ) &amp;&amp; ( packet -&gt; payload [ i + 2 ] == 0x08 ) ) { int rc = extractRDNSequence ( packet , i , buffer , sizeof ( buffer ) , rdnSeqBuf , &amp; rdn_len , sizeof ( rdnSeqBuf ) , \"ST\" ) ; if ( rc == - 1 ) break ; # ifdef DEBUG_TLS printf ( \"[TLS]&lt;S2SV_blank&gt;%s()&lt;S2SV_blank&gt;[%s][%s:&lt;S2SV_blank&gt;%s]\\\\n\" , __FUNCTION__ , ( num_found == 0 ) ? \"Subject\" : \"Issuer\" , \"State&lt;S2SV_blank&gt;or&lt;S2SV_blank&gt;Province\" , buffer ) ; # endif } else if ( ( packet -&gt; payload [ i ] == 0x55 ) &amp;&amp; ( packet -&gt; payload [ i + 1 ] == 0x04 ) &amp;&amp; ( packet -&gt; payload [ i + 2 ] == 0x0a ) ) { int rc = extractRDNSequence ( packet , i , buffer , sizeof ( buffer ) , rdnSeqBuf , &amp; rdn_len , sizeof ( rdnSeqBuf ) , \"O\" ) ; if ( rc == - 1 ) break ; # ifdef DEBUG_TLS printf ( \"[TLS]&lt;S2SV_blank&gt;%s()&lt;S2SV_blank&gt;[%s][%s:&lt;S2SV_blank&gt;%s]\\\\n\" , __FUNCTION__ , ( num_found == 0 ) ? \"Subject\" : \"Issuer\" , \"Organization&lt;S2SV_blank&gt;Name\" , buffer ) ; # endif } else if ( ( packet -&gt; payload [ i ] == 0x55 ) &amp;&amp; ( packet -&gt; payload [ i + 1 ] == 0x04 ) &amp;&amp; ( packet -&gt; payload [ i + 2 ] == 0x0b ) ) { int rc = extractRDNSequence ( packet , i , buffer , sizeof ( buffer ) , rdnSeqBuf , &amp; rdn_len , sizeof ( rdnSeqBuf ) , \"OU\" ) ; if ( rc == - 1 ) break ; # ifdef DEBUG_TLS printf ( \"[TLS]&lt;S2SV_blank&gt;%s()&lt;S2SV_blank&gt;[%s][%s:&lt;S2SV_blank&gt;%s]\\\\n\" , __FUNCTION__ , ( num_found == 0 ) ? \"Subject\" : \"Issuer\" , \"Organization&lt;S2SV_blank&gt;Unit\" , buffer ) ; # endif } else if ( ( packet -&gt; payload [ i ] == 0x30 ) &amp;&amp; ( packet -&gt; payload [ i + 1 ] == 0x1e ) &amp;&amp; ( packet -&gt; payload [ i + 2 ] == 0x17 ) ) { u_int8_t len = packet -&gt; payload [ i + 3 ] ; u_int offset = i + 4 ; if ( num_found == 0 ) { num_found ++ ; # ifdef DEBUG_TLS printf ( \"[TLS]&lt;S2SV_blank&gt;%s()&lt;S2SV_blank&gt;IssuerDN&lt;S2SV_blank&gt;[%s]\\\\n\" , __FUNCTION__ , rdnSeqBuf ) ; # endif if ( rdn_len ) flow -&gt; protos . stun_ssl . ssl . issuerDN = ndpi_strdup ( rdnSeqBuf ) ; rdn_len = 0 ; } if ( ( offset + len ) &lt; packet -&gt; payload_packet_len ) { char utcDate [ 32 ] ; # ifdef DEBUG_TLS u_int j ; printf ( \"[CERTIFICATE]&lt;S2SV_blank&gt;notBefore&lt;S2SV_blank&gt;[len:&lt;S2SV_blank&gt;%u][\" , len ) ; for ( j = 0 ; j &lt; len ; j ++ ) printf ( \"%c\" , packet -&gt; payload [ i + 4 + j ] ) ; printf ( \"]\\\\n\" ) ; # endif if ( len &lt; ( sizeof ( utcDate ) - 1 ) ) { struct tm utc ; utc . tm_isdst = - 1 ; strncpy ( utcDate , ( const char * ) &amp; packet -&gt; payload [ i + 4 ] , len ) ; utcDate [ len ] = '\\\\0' ; if ( strptime ( utcDate , \"%y%m%d%H%M%SZ\" , &amp; utc ) != NULL ) { flow -&gt; protos . stun_ssl . ssl . notBefore = timegm ( &amp; utc ) ; # ifdef DEBUG_TLS printf ( \"[CERTIFICATE]&lt;S2SV_blank&gt;notBefore&lt;S2SV_blank&gt;%u&lt;S2SV_blank&gt;[%s]\\\\n\" , flow -&gt; protos . stun_ssl . ssl . notBefore , utcDate ) ; # endif } } offset += len ; if ( ( offset + 1 ) &lt; packet -&gt; payload_packet_len ) { len = packet -&gt; payload [ offset + 1 ] ; offset += 2 ; if ( ( offset + len ) &lt; packet -&gt; payload_packet_len ) { u_int32_t time_sec = flow -&gt; packet . current_time_ms / 1000 ; # ifdef DEBUG_TLS u_int j ; printf ( \"[CERTIFICATE]&lt;S2SV_blank&gt;notAfter&lt;S2SV_blank&gt;[len:&lt;S2SV_blank&gt;%u][\" , len ) ; for ( j = 0 ; j &lt; len ; j ++ ) printf ( \"%c\" , packet -&gt; payload [ offset + j ] ) ; printf ( \"]\\\\n\" ) ; # endif if ( len &lt; ( sizeof ( utcDate ) - 1 ) ) { struct tm utc ; utc . tm_isdst = - 1 ; strncpy ( utcDate , ( const char * ) &amp; packet -&gt; payload [ offset ] , len ) ; utcDate [ len ] = '\\\\0' ; if ( strptime ( utcDate , \"%y%m%d%H%M%SZ\" , &amp; utc ) != NULL ) { flow -&gt; protos . stun_ssl . ssl . notAfter = timegm ( &amp; utc ) ; # ifdef DEBUG_TLS printf ( \"[CERTIFICATE]&lt;S2SV_blank&gt;notAfter&lt;S2SV_blank&gt;%u&lt;S2SV_blank&gt;[%s]\\\\n\" , flow -&gt; protos . stun_ssl . ssl . notAfter , utcDate ) ; # endif } } if ( ( time_sec &lt; flow -&gt; protos . stun_ssl . ssl . notBefore ) || ( time_sec &gt; flow -&gt; protos . stun_ssl . ssl . notAfter ) ) NDPI_SET_BIT ( flow -&gt; risk , NDPI_TLS_CERTIFICATE_EXPIRED ) ; } } } } else if ( ( packet -&gt; payload [ i ] == 0x55 ) &amp;&amp; ( packet -&gt; payload [ i + 1 ] == 0x1d ) &amp;&amp; ( packet -&gt; payload [ i + 2 ] == 0x11 ) ) { u_int8_t matched_name = 0 ; # ifdef DEBUG_TLS printf ( \"*******&lt;S2SV_blank&gt;[TLS]&lt;S2SV_blank&gt;Found&lt;S2SV_blank&gt;subjectAltName\\\\n\" ) ; # endif i += 3 ; i ++ ; if ( i &lt; packet -&gt; payload_packet_len ) { i += ( packet -&gt; payload [ i ] &amp; 0x80 ) ? ( packet -&gt; payload [ i ] &amp; 0x7F ) : 0 ; if ( i &lt; packet -&gt; payload_packet_len ) { i += 2 ; if ( i &lt; packet -&gt; payload_packet_len ) { i += ( packet -&gt; payload [ i ] &amp; 0x80 ) ? ( packet -&gt; payload [ i ] &amp; 0x7F ) : 0 ; i ++ ; while ( i &lt; packet -&gt; payload_packet_len ) { if ( packet -&gt; payload [ i ] == 0x82 ) { if ( ( i &lt; ( packet -&gt; payload_packet_len - 1 ) ) &amp;&amp; ( ( i + packet -&gt; payload [ i + 1 ] + 2 ) &lt; packet -&gt; payload_packet_len ) ) { u_int8_t len = packet -&gt; payload [ i + 1 ] ; char dNSName [ 256 ] ; i += 2 ; if ( len == 0 ) break ; strncpy ( dNSName , ( const char * ) &amp; packet -&gt; payload [ i ] , len ) ; dNSName [ len ] = '\\\\0' ; cleanupServerName ( dNSName , len ) ; # if DEBUG_TLS printf ( \"[TLS]&lt;S2SV_blank&gt;dNSName&lt;S2SV_blank&gt;%s&lt;S2SV_blank&gt;[%s]\\\\n\" , dNSName , flow -&gt; protos . stun_ssl . ssl . client_requested_server_name ) ; # endif if ( matched_name == 0 ) { if ( ( dNSName [ 0 ] == '*' ) &amp;&amp; strstr ( flow -&gt; protos . stun_ssl . ssl . client_requested_server_name , &amp; dNSName [ 1 ] ) ) matched_name = 1 ; else if ( strcmp ( flow -&gt; protos . stun_ssl . ssl . client_requested_server_name , dNSName ) == 0 ) matched_name = 1 ; } if ( flow -&gt; protos . stun_ssl . ssl . server_names == NULL ) flow -&gt; protos . stun_ssl . ssl . server_names = ndpi_strdup ( dNSName ) , flow -&gt; protos . stun_ssl . ssl . server_names_len = strlen ( dNSName ) ; else { u_int16_t dNSName_len = strlen ( dNSName ) ; u_int16_t newstr_len = flow -&gt; protos . stun_ssl . ssl . server_names_len + dNSName_len + 1 ; char * newstr = ( char * ) ndpi_realloc ( flow -&gt; protos . stun_ssl . ssl . server_names , flow -&gt; protos . stun_ssl . ssl . server_names_len + 1 , newstr_len + 1 ) ; if ( newstr ) { flow -&gt; protos . stun_ssl . ssl . server_names = newstr ; flow -&gt; protos . stun_ssl . ssl . server_names [ flow -&gt; protos . stun_ssl . ssl . server_names_len ] = ',' ; strncpy ( &amp; flow -&gt; protos . stun_ssl . ssl . server_names [ flow -&gt; protos . stun_ssl . ssl . server_names_len + 1 ] , dNSName , dNSName_len + 1 ) ; flow -&gt; protos . stun_ssl . ssl . server_names [ newstr_len ] = '\\\\0' ; flow -&gt; protos . stun_ssl . ssl . server_names_len = newstr_len ; } } if ( ! flow -&gt; l4 . tcp . tls . subprotocol_detected ) if ( ndpi_match_hostname_protocol ( ndpi_struct , flow , NDPI_PROTOCOL_TLS , dNSName , len ) ) flow -&gt; l4 . tcp . tls . subprotocol_detected = 1 ; i += len ; } else { # if DEBUG_TLS printf ( \"[TLS]&lt;S2SV_blank&gt;Leftover&lt;S2SV_blank&gt;%u&lt;S2SV_blank&gt;bytes\" , packet -&gt; payload_packet_len - i ) ; # endif break ; } } else { break ; } } if ( ! matched_name ) NDPI_SET_BIT ( flow -&gt; risk , NDPI_TLS_CERTIFICATE_MISMATCH ) ; } } } } } if ( rdn_len ) flow -&gt; protos . stun_ssl . ssl . subjectDN = ndpi_strdup ( rdnSeqBuf ) ; if ( flow -&gt; protos . stun_ssl . ssl . subjectDN &amp;&amp; flow -&gt; protos . stun_ssl . ssl . issuerDN &amp;&amp; ( ! strcmp ( flow -&gt; protos . stun_ssl . ssl . subjectDN , flow -&gt; protos . stun_ssl . ssl . issuerDN ) ) ) NDPI_SET_BIT ( flow -&gt; risk , NDPI_TLS_SELFSIGNED_CERTIFICATE ) ; # if DEBUG_TLS printf ( \"[TLS]&lt;S2SV_blank&gt;%s()&lt;S2SV_blank&gt;SubjectDN&lt;S2SV_blank&gt;[%s]\\\\n\" , __FUNCTION__ , rdnSeqBuf ) ; # endif }\n</pre>\n<li>/var/folders/ql/btm7z5tx32ddpsky8z3bz4_r0000gn/T/tmphp_y92lf.c:1: <b>  [1] </b> (buffer) <i> strncpy:\n  Easily used incorrectly; doesn't always \\0-terminate or check for invalid\n  pointers [MS-banned] (<a\n  href=\"https://cwe.mitre.org/data/definitions/120.html\">CWE-120</a>). </i>\n<pre>\nCWE-787 static void processCertificateElements ( struct ndpi_detection_module_struct * ndpi_struct , struct ndpi_flow_struct * flow , u_int16_t p_offset , u_int16_t certificate_len ) { struct ndpi_packet_struct * packet = &amp; flow -&gt; packet ; u_int num_found = 0 , i ; &lt;S2SV_StartBug&gt; char buffer [ 64 ] = { '\\\\0' } , rdnSeqBuf [ 1024 ] = { '\\\\0' } ; &lt;S2SV_EndBug&gt; u_int rdn_len = 0 ; # ifdef DEBUG_TLS printf ( \"[TLS]&lt;S2SV_blank&gt;%s()&lt;S2SV_blank&gt;[offset:&lt;S2SV_blank&gt;%u][certificate_len:&lt;S2SV_blank&gt;%u]\\\\n\" , __FUNCTION__ , p_offset , certificate_len ) ; # endif for ( i = p_offset ; i &lt; certificate_len ; i ++ ) { if ( ( packet -&gt; payload [ i ] == 0x55 ) &amp;&amp; ( packet -&gt; payload [ i + 1 ] == 0x04 ) &amp;&amp; ( packet -&gt; payload [ i + 2 ] == 0x03 ) ) { int rc = extractRDNSequence ( packet , i , buffer , sizeof ( buffer ) , rdnSeqBuf , &amp; rdn_len , sizeof ( rdnSeqBuf ) , \"CN\" ) ; if ( rc == - 1 ) break ; # ifdef DEBUG_TLS printf ( \"[TLS]&lt;S2SV_blank&gt;%s()&lt;S2SV_blank&gt;[%s][%s:&lt;S2SV_blank&gt;%s]\\\\n\" , __FUNCTION__ , ( num_found == 0 ) ? \"Subject\" : \"Issuer\" , \"Common&lt;S2SV_blank&gt;Name\" , buffer ) ; # endif } else if ( ( packet -&gt; payload [ i ] == 0x55 ) &amp;&amp; ( packet -&gt; payload [ i + 1 ] == 0x04 ) &amp;&amp; ( packet -&gt; payload [ i + 2 ] == 0x06 ) ) { int rc = extractRDNSequence ( packet , i , buffer , sizeof ( buffer ) , rdnSeqBuf , &amp; rdn_len , sizeof ( rdnSeqBuf ) , \"C\" ) ; if ( rc == - 1 ) break ; # ifdef DEBUG_TLS printf ( \"[TLS]&lt;S2SV_blank&gt;%s()&lt;S2SV_blank&gt;[%s][%s:&lt;S2SV_blank&gt;%s]\\\\n\" , __FUNCTION__ , ( num_found == 0 ) ? \"Subject\" : \"Issuer\" , \"Country\" , buffer ) ; # endif } else if ( ( packet -&gt; payload [ i ] == 0x55 ) &amp;&amp; ( packet -&gt; payload [ i + 1 ] == 0x04 ) &amp;&amp; ( packet -&gt; payload [ i + 2 ] == 0x07 ) ) { int rc = extractRDNSequence ( packet , i , buffer , sizeof ( buffer ) , rdnSeqBuf , &amp; rdn_len , sizeof ( rdnSeqBuf ) , \"L\" ) ; if ( rc == - 1 ) break ; # ifdef DEBUG_TLS printf ( \"[TLS]&lt;S2SV_blank&gt;%s()&lt;S2SV_blank&gt;[%s][%s:&lt;S2SV_blank&gt;%s]\\\\n\" , __FUNCTION__ , ( num_found == 0 ) ? \"Subject\" : \"Issuer\" , \"Locality\" , buffer ) ; # endif } else if ( ( packet -&gt; payload [ i ] == 0x55 ) &amp;&amp; ( packet -&gt; payload [ i + 1 ] == 0x04 ) &amp;&amp; ( packet -&gt; payload [ i + 2 ] == 0x08 ) ) { int rc = extractRDNSequence ( packet , i , buffer , sizeof ( buffer ) , rdnSeqBuf , &amp; rdn_len , sizeof ( rdnSeqBuf ) , \"ST\" ) ; if ( rc == - 1 ) break ; # ifdef DEBUG_TLS printf ( \"[TLS]&lt;S2SV_blank&gt;%s()&lt;S2SV_blank&gt;[%s][%s:&lt;S2SV_blank&gt;%s]\\\\n\" , __FUNCTION__ , ( num_found == 0 ) ? \"Subject\" : \"Issuer\" , \"State&lt;S2SV_blank&gt;or&lt;S2SV_blank&gt;Province\" , buffer ) ; # endif } else if ( ( packet -&gt; payload [ i ] == 0x55 ) &amp;&amp; ( packet -&gt; payload [ i + 1 ] == 0x04 ) &amp;&amp; ( packet -&gt; payload [ i + 2 ] == 0x0a ) ) { int rc = extractRDNSequence ( packet , i , buffer , sizeof ( buffer ) , rdnSeqBuf , &amp; rdn_len , sizeof ( rdnSeqBuf ) , \"O\" ) ; if ( rc == - 1 ) break ; # ifdef DEBUG_TLS printf ( \"[TLS]&lt;S2SV_blank&gt;%s()&lt;S2SV_blank&gt;[%s][%s:&lt;S2SV_blank&gt;%s]\\\\n\" , __FUNCTION__ , ( num_found == 0 ) ? \"Subject\" : \"Issuer\" , \"Organization&lt;S2SV_blank&gt;Name\" , buffer ) ; # endif } else if ( ( packet -&gt; payload [ i ] == 0x55 ) &amp;&amp; ( packet -&gt; payload [ i + 1 ] == 0x04 ) &amp;&amp; ( packet -&gt; payload [ i + 2 ] == 0x0b ) ) { int rc = extractRDNSequence ( packet , i , buffer , sizeof ( buffer ) , rdnSeqBuf , &amp; rdn_len , sizeof ( rdnSeqBuf ) , \"OU\" ) ; if ( rc == - 1 ) break ; # ifdef DEBUG_TLS printf ( \"[TLS]&lt;S2SV_blank&gt;%s()&lt;S2SV_blank&gt;[%s][%s:&lt;S2SV_blank&gt;%s]\\\\n\" , __FUNCTION__ , ( num_found == 0 ) ? \"Subject\" : \"Issuer\" , \"Organization&lt;S2SV_blank&gt;Unit\" , buffer ) ; # endif } else if ( ( packet -&gt; payload [ i ] == 0x30 ) &amp;&amp; ( packet -&gt; payload [ i + 1 ] == 0x1e ) &amp;&amp; ( packet -&gt; payload [ i + 2 ] == 0x17 ) ) { u_int8_t len = packet -&gt; payload [ i + 3 ] ; u_int offset = i + 4 ; if ( num_found == 0 ) { num_found ++ ; # ifdef DEBUG_TLS printf ( \"[TLS]&lt;S2SV_blank&gt;%s()&lt;S2SV_blank&gt;IssuerDN&lt;S2SV_blank&gt;[%s]\\\\n\" , __FUNCTION__ , rdnSeqBuf ) ; # endif if ( rdn_len ) flow -&gt; protos . stun_ssl . ssl . issuerDN = ndpi_strdup ( rdnSeqBuf ) ; rdn_len = 0 ; } if ( ( offset + len ) &lt; packet -&gt; payload_packet_len ) { char utcDate [ 32 ] ; # ifdef DEBUG_TLS u_int j ; printf ( \"[CERTIFICATE]&lt;S2SV_blank&gt;notBefore&lt;S2SV_blank&gt;[len:&lt;S2SV_blank&gt;%u][\" , len ) ; for ( j = 0 ; j &lt; len ; j ++ ) printf ( \"%c\" , packet -&gt; payload [ i + 4 + j ] ) ; printf ( \"]\\\\n\" ) ; # endif if ( len &lt; ( sizeof ( utcDate ) - 1 ) ) { struct tm utc ; utc . tm_isdst = - 1 ; strncpy ( utcDate , ( const char * ) &amp; packet -&gt; payload [ i + 4 ] , len ) ; utcDate [ len ] = '\\\\0' ; if ( strptime ( utcDate , \"%y%m%d%H%M%SZ\" , &amp; utc ) != NULL ) { flow -&gt; protos . stun_ssl . ssl . notBefore = timegm ( &amp; utc ) ; # ifdef DEBUG_TLS printf ( \"[CERTIFICATE]&lt;S2SV_blank&gt;notBefore&lt;S2SV_blank&gt;%u&lt;S2SV_blank&gt;[%s]\\\\n\" , flow -&gt; protos . stun_ssl . ssl . notBefore , utcDate ) ; # endif } } offset += len ; if ( ( offset + 1 ) &lt; packet -&gt; payload_packet_len ) { len = packet -&gt; payload [ offset + 1 ] ; offset += 2 ; if ( ( offset + len ) &lt; packet -&gt; payload_packet_len ) { u_int32_t time_sec = flow -&gt; packet . current_time_ms / 1000 ; # ifdef DEBUG_TLS u_int j ; printf ( \"[CERTIFICATE]&lt;S2SV_blank&gt;notAfter&lt;S2SV_blank&gt;[len:&lt;S2SV_blank&gt;%u][\" , len ) ; for ( j = 0 ; j &lt; len ; j ++ ) printf ( \"%c\" , packet -&gt; payload [ offset + j ] ) ; printf ( \"]\\\\n\" ) ; # endif if ( len &lt; ( sizeof ( utcDate ) - 1 ) ) { struct tm utc ; utc . tm_isdst = - 1 ; strncpy ( utcDate , ( const char * ) &amp; packet -&gt; payload [ offset ] , len ) ; utcDate [ len ] = '\\\\0' ; if ( strptime ( utcDate , \"%y%m%d%H%M%SZ\" , &amp; utc ) != NULL ) { flow -&gt; protos . stun_ssl . ssl . notAfter = timegm ( &amp; utc ) ; # ifdef DEBUG_TLS printf ( \"[CERTIFICATE]&lt;S2SV_blank&gt;notAfter&lt;S2SV_blank&gt;%u&lt;S2SV_blank&gt;[%s]\\\\n\" , flow -&gt; protos . stun_ssl . ssl . notAfter , utcDate ) ; # endif } } if ( ( time_sec &lt; flow -&gt; protos . stun_ssl . ssl . notBefore ) || ( time_sec &gt; flow -&gt; protos . stun_ssl . ssl . notAfter ) ) NDPI_SET_BIT ( flow -&gt; risk , NDPI_TLS_CERTIFICATE_EXPIRED ) ; } } } } else if ( ( packet -&gt; payload [ i ] == 0x55 ) &amp;&amp; ( packet -&gt; payload [ i + 1 ] == 0x1d ) &amp;&amp; ( packet -&gt; payload [ i + 2 ] == 0x11 ) ) { u_int8_t matched_name = 0 ; # ifdef DEBUG_TLS printf ( \"*******&lt;S2SV_blank&gt;[TLS]&lt;S2SV_blank&gt;Found&lt;S2SV_blank&gt;subjectAltName\\\\n\" ) ; # endif i += 3 ; i ++ ; if ( i &lt; packet -&gt; payload_packet_len ) { i += ( packet -&gt; payload [ i ] &amp; 0x80 ) ? ( packet -&gt; payload [ i ] &amp; 0x7F ) : 0 ; if ( i &lt; packet -&gt; payload_packet_len ) { i += 2 ; if ( i &lt; packet -&gt; payload_packet_len ) { i += ( packet -&gt; payload [ i ] &amp; 0x80 ) ? ( packet -&gt; payload [ i ] &amp; 0x7F ) : 0 ; i ++ ; while ( i &lt; packet -&gt; payload_packet_len ) { if ( packet -&gt; payload [ i ] == 0x82 ) { if ( ( i &lt; ( packet -&gt; payload_packet_len - 1 ) ) &amp;&amp; ( ( i + packet -&gt; payload [ i + 1 ] + 2 ) &lt; packet -&gt; payload_packet_len ) ) { u_int8_t len = packet -&gt; payload [ i + 1 ] ; char dNSName [ 256 ] ; i += 2 ; if ( len == 0 ) break ; strncpy ( dNSName , ( const char * ) &amp; packet -&gt; payload [ i ] , len ) ; dNSName [ len ] = '\\\\0' ; cleanupServerName ( dNSName , len ) ; # if DEBUG_TLS printf ( \"[TLS]&lt;S2SV_blank&gt;dNSName&lt;S2SV_blank&gt;%s&lt;S2SV_blank&gt;[%s]\\\\n\" , dNSName , flow -&gt; protos . stun_ssl . ssl . client_requested_server_name ) ; # endif if ( matched_name == 0 ) { if ( ( dNSName [ 0 ] == '*' ) &amp;&amp; strstr ( flow -&gt; protos . stun_ssl . ssl . client_requested_server_name , &amp; dNSName [ 1 ] ) ) matched_name = 1 ; else if ( strcmp ( flow -&gt; protos . stun_ssl . ssl . client_requested_server_name , dNSName ) == 0 ) matched_name = 1 ; } if ( flow -&gt; protos . stun_ssl . ssl . server_names == NULL ) flow -&gt; protos . stun_ssl . ssl . server_names = ndpi_strdup ( dNSName ) , flow -&gt; protos . stun_ssl . ssl . server_names_len = strlen ( dNSName ) ; else { u_int16_t dNSName_len = strlen ( dNSName ) ; u_int16_t newstr_len = flow -&gt; protos . stun_ssl . ssl . server_names_len + dNSName_len + 1 ; char * newstr = ( char * ) ndpi_realloc ( flow -&gt; protos . stun_ssl . ssl . server_names , flow -&gt; protos . stun_ssl . ssl . server_names_len + 1 , newstr_len + 1 ) ; if ( newstr ) { flow -&gt; protos . stun_ssl . ssl . server_names = newstr ; flow -&gt; protos . stun_ssl . ssl . server_names [ flow -&gt; protos . stun_ssl . ssl . server_names_len ] = ',' ; strncpy ( &amp; flow -&gt; protos . stun_ssl . ssl . server_names [ flow -&gt; protos . stun_ssl . ssl . server_names_len + 1 ] , dNSName , dNSName_len + 1 ) ; flow -&gt; protos . stun_ssl . ssl . server_names [ newstr_len ] = '\\\\0' ; flow -&gt; protos . stun_ssl . ssl . server_names_len = newstr_len ; } } if ( ! flow -&gt; l4 . tcp . tls . subprotocol_detected ) if ( ndpi_match_hostname_protocol ( ndpi_struct , flow , NDPI_PROTOCOL_TLS , dNSName , len ) ) flow -&gt; l4 . tcp . tls . subprotocol_detected = 1 ; i += len ; } else { # if DEBUG_TLS printf ( \"[TLS]&lt;S2SV_blank&gt;Leftover&lt;S2SV_blank&gt;%u&lt;S2SV_blank&gt;bytes\" , packet -&gt; payload_packet_len - i ) ; # endif break ; } } else { break ; } } if ( ! matched_name ) NDPI_SET_BIT ( flow -&gt; risk , NDPI_TLS_CERTIFICATE_MISMATCH ) ; } } } } } if ( rdn_len ) flow -&gt; protos . stun_ssl . ssl . subjectDN = ndpi_strdup ( rdnSeqBuf ) ; if ( flow -&gt; protos . stun_ssl . ssl . subjectDN &amp;&amp; flow -&gt; protos . stun_ssl . ssl . issuerDN &amp;&amp; ( ! strcmp ( flow -&gt; protos . stun_ssl . ssl . subjectDN , flow -&gt; protos . stun_ssl . ssl . issuerDN ) ) ) NDPI_SET_BIT ( flow -&gt; risk , NDPI_TLS_SELFSIGNED_CERTIFICATE ) ; # if DEBUG_TLS printf ( \"[TLS]&lt;S2SV_blank&gt;%s()&lt;S2SV_blank&gt;SubjectDN&lt;S2SV_blank&gt;[%s]\\\\n\" , __FUNCTION__ , rdnSeqBuf ) ; # endif }\n</pre>\n</ul>\n<h2>Analysis Summary</h2>\n<p>\nHits = 9\n<br>\nLines analyzed = 1 in approximately 0.00 seconds (311 lines/second)\n<br>\nPhysical Source Lines of Code (SLOC) = 1\n<br>\nHits@level = [0]  20 [1]   6 [2]   3 [3]   0 [4]   0 [5]   0 <br>\nHits@level+ = [0+]  29 [1+]   9 [2+]   3 [3+]   0 [4+]   0 [5+]   0 <br>\nHits/KSLOC@level+ = [0+] 29000 [1+] 9000 [2+] 3000 [3+]   0 [4+]   0 [5+]   0 <br>\nMinimum risk level = 1\n<br>\nNot every hit is necessarily a security vulnerability.\nYou can inhibit a report by adding a comment in this form:\n// flawfinder: ignore\nMake *sure* it's a false positive!\nYou can use the option --neverignore to show these.\n<br>\nThere may be other security vulnerabilities; review your code!\n<br>\nSee '<a href=\"https://dwheeler.com/secure-programs\">Secure Programming HOWTO</a>'\n(<a href=\"https://dwheeler.com/secure-programs\">https://dwheeler.com/secure-programs</a>) for more information.\n</body>\n</html>\n",
      "error_message": null
    },
    {
      "cve_id": "CVE-2017-15385",
      "tool_name": "Flawfinder",
      "detected": true,
      "confidence": 0.5,
      "detection_time": 0.030015945434570312,
      "tool_output": "<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.01 Transitional//EN\" \"http://www.w3.org/TR/html4/loose.dtd\">\n<html>\n<head>\n<meta http-equiv=\"Content-type\" content=\"text/html; charset=utf8\">\n<title>Flawfinder Results</title>\n<meta name=\"author\" content=\"David A. Wheeler\">\n<meta name=\"keywords\" lang=\"en\" content=\"flawfinder results, security scan\">\n</head>\n<body>\n<h1>Flawfinder Results</h1>\nHere are the security scan results from\n<a href=\"https://dwheeler.com/flawfinder\">Flawfinder version 2.0.19</a>,\n(C) 2001-2019 <a href=\"https://dwheeler.com\">David A. Wheeler</a>.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\n<p>\nExamining /var/folders/ql/btm7z5tx32ddpsky8z3bz4_r0000gn/T/tmpqwgfl07m.c <br>\n\n<h2>Final Results</h2>\n<ul>\n<li>/var/folders/ql/btm7z5tx32ddpsky8z3bz4_r0000gn/T/tmpqwgfl07m.c:1: <b>  [2] </b> (buffer) <i> char:\n  Statically-sized arrays can be improperly restricted, leading to potential\n  overflows or other issues (<a\n  href=\"https://cwe.mitre.org/data/definitions/119.html\">CWE-119</a>!/<a\n  href=\"https://cwe.mitre.org/data/definitions/120.html\">CWE-120</a>).\n  Perform bounds checking, use functions that limit length, or ensure that\n  the size is larger than the maximum possible length. </i>\n<pre>\nCWE-119 static Sdb * store_versioninfo_gnu_verdef ( ELFOBJ * bin , Elf_ ( Shdr ) * shdr , int sz ) { const char * section_name = \"\" ; const char * link_section_name = \"\" ; char * end = NULL ; Elf_ ( Shdr ) * link_shdr = NULL ; ut8 dfs [ sizeof ( Elf_ ( Verdef ) ) ] = { 0 } ; Sdb * sdb ; int cnt , i ; if ( shdr -&gt; sh_link &gt; bin -&gt; ehdr . e_shnum ) { return false ; } link_shdr = &amp; bin -&gt; shdr [ shdr -&gt; sh_link ] ; if ( shdr -&gt; sh_size &lt; 1 ) { return false ; } Elf_ ( Verdef ) * defs = calloc ( shdr -&gt; sh_size , sizeof ( char ) ) ; if ( ! defs ) { return false ; } if ( bin -&gt; shstrtab &amp;&amp; shdr -&gt; sh_name &lt; bin -&gt; shstrtab_size ) { section_name = &amp; bin -&gt; shstrtab [ shdr -&gt; sh_name ] ; } if ( link_shdr &amp;&amp; bin -&gt; shstrtab &amp;&amp; link_shdr -&gt; sh_name &lt; bin -&gt; shstrtab_size ) { link_section_name = &amp; bin -&gt; shstrtab [ link_shdr -&gt; sh_name ] ; } if ( ! defs ) { bprintf ( \"Warning:&lt;S2SV_blank&gt;Cannot&lt;S2SV_blank&gt;allocate&lt;S2SV_blank&gt;memory&lt;S2SV_blank&gt;(Check&lt;S2SV_blank&gt;Elf_(Verdef))\\\\n\" ) ; return NULL ; } sdb = sdb_new0 ( ) ; end = ( char * ) defs + shdr -&gt; sh_size ; sdb_set ( sdb , \"section_name\" , section_name , 0 ) ; sdb_num_set ( sdb , \"entries\" , shdr -&gt; sh_info , 0 ) ; sdb_num_set ( sdb , \"addr\" , shdr -&gt; sh_addr , 0 ) ; sdb_num_set ( sdb , \"offset\" , shdr -&gt; sh_offset , 0 ) ; sdb_num_set ( sdb , \"link\" , shdr -&gt; sh_link , 0 ) ; sdb_set ( sdb , \"link_section_name\" , link_section_name , 0 ) ; &lt;S2SV_StartBug&gt; for ( cnt = 0 , i = 0 ; cnt &lt; shdr -&gt; sh_info &amp;&amp; ( ( char * ) defs + i &lt; end ) ; ++ cnt ) { &lt;S2SV_EndBug&gt; Sdb * sdb_verdef = sdb_new0 ( ) ; char * vstart = ( ( char * ) defs ) + i ; char key [ 32 ] = { 0 } ; Elf_ ( Verdef ) * verdef = ( Elf_ ( Verdef ) * ) vstart ; Elf_ ( Verdaux ) aux = { 0 } ; int j = 0 ; int isum = 0 ; r_buf_read_at ( bin -&gt; b , shdr -&gt; sh_offset + i , dfs , sizeof ( Elf_ ( Verdef ) ) ) ; verdef -&gt; vd_version = READ16 ( dfs , j ) verdef -&gt; vd_flags = READ16 ( dfs , j ) verdef -&gt; vd_ndx = READ16 ( dfs , j ) verdef -&gt; vd_cnt = READ16 ( dfs , j ) verdef -&gt; vd_hash = READ32 ( dfs , j ) verdef -&gt; vd_aux = READ32 ( dfs , j ) verdef -&gt; vd_next = READ32 ( dfs , j ) vstart += verdef -&gt; vd_aux ; if ( vstart &gt; end || vstart + sizeof ( Elf_ ( Verdaux ) ) &gt; end ) { sdb_free ( sdb_verdef ) ; goto out_error ; } j = 0 ; aux . vda_name = READ32 ( vstart , j ) aux . vda_next = READ32 ( vstart , j ) isum = i + verdef -&gt; vd_aux ; if ( aux . vda_name &gt; bin -&gt; dynstr_size ) { sdb_free ( sdb_verdef ) ; goto out_error ; } sdb_num_set ( sdb_verdef , \"idx\" , i , 0 ) ; sdb_num_set ( sdb_verdef , \"vd_version\" , verdef -&gt; vd_version , 0 ) ; sdb_num_set ( sdb_verdef , \"vd_ndx\" , verdef -&gt; vd_ndx , 0 ) ; sdb_num_set ( sdb_verdef , \"vd_cnt\" , verdef -&gt; vd_cnt , 0 ) ; sdb_set ( sdb_verdef , \"vda_name\" , &amp; bin -&gt; dynstr [ aux . vda_name ] , 0 ) ; sdb_set ( sdb_verdef , \"flags\" , get_ver_flags ( verdef -&gt; vd_flags ) , 0 ) ; for ( j = 1 ; j &lt; verdef -&gt; vd_cnt ; ++ j ) { int k ; Sdb * sdb_parent = sdb_new0 ( ) ; isum += aux . vda_next ; vstart += aux . vda_next ; if ( vstart &gt; end || vstart + sizeof ( Elf_ ( Verdaux ) ) &gt; end ) { sdb_free ( sdb_verdef ) ; sdb_free ( sdb_parent ) ; goto out_error ; } k = 0 ; aux . vda_name = READ32 ( vstart , k ) aux . vda_next = READ32 ( vstart , k ) if ( aux . vda_name &gt; bin -&gt; dynstr_size ) { sdb_free ( sdb_verdef ) ; sdb_free ( sdb_parent ) ; goto out_error ; } sdb_num_set ( sdb_parent , \"idx\" , isum , 0 ) ; sdb_num_set ( sdb_parent , \"parent\" , j , 0 ) ; sdb_set ( sdb_parent , \"vda_name\" , &amp; bin -&gt; dynstr [ aux . vda_name ] , 0 ) ; snprintf ( key , sizeof ( key ) , \"parent%d\" , j - 1 ) ; sdb_ns_set ( sdb_verdef , key , sdb_parent ) ; } snprintf ( key , sizeof ( key ) , \"verdef%d\" , cnt ) ; sdb_ns_set ( sdb , key , sdb_verdef ) ; if ( ! verdef -&gt; vd_next ) { sdb_free ( sdb_verdef ) ; goto out_error ; } &lt;S2SV_StartBug&gt; i += verdef -&gt; vd_next ; &lt;S2SV_EndBug&gt; } free ( defs ) ; return sdb ; out_error : free ( defs ) ; sdb_free ( sdb ) ; return NULL ; }\n</pre>\n</ul>\n<h2>Analysis Summary</h2>\n<p>\nHits = 1\n<br>\nLines analyzed = 1 in approximately 0.00 seconds (559 lines/second)\n<br>\nPhysical Source Lines of Code (SLOC) = 1\n<br>\nHits@level = [0]   2 [1]   0 [2]   1 [3]   0 [4]   0 [5]   0 <br>\nHits@level+ = [0+]   3 [1+]   1 [2+]   1 [3+]   0 [4+]   0 [5+]   0 <br>\nHits/KSLOC@level+ = [0+] 3000 [1+] 1000 [2+] 1000 [3+]   0 [4+]   0 [5+]   0 <br>\nMinimum risk level = 1\n<br>\nNot every hit is necessarily a security vulnerability.\nYou can inhibit a report by adding a comment in this form:\n// flawfinder: ignore\nMake *sure* it's a false positive!\nYou can use the option --neverignore to show these.\n<br>\nThere may be other security vulnerabilities; review your code!\n<br>\nSee '<a href=\"https://dwheeler.com/secure-programs\">Secure Programming HOWTO</a>'\n(<a href=\"https://dwheeler.com/secure-programs\">https://dwheeler.com/secure-programs</a>) for more information.\n</body>\n</html>\n",
      "error_message": null
    },
    {
      "cve_id": "CVE-2019-19275",
      "tool_name": "Flawfinder",
      "detected": true,
      "confidence": 0.25,
      "detection_time": 0.030724763870239258,
      "tool_output": "<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.01 Transitional//EN\" \"http://www.w3.org/TR/html4/loose.dtd\">\n<html>\n<head>\n<meta http-equiv=\"Content-type\" content=\"text/html; charset=utf8\">\n<title>Flawfinder Results</title>\n<meta name=\"author\" content=\"David A. Wheeler\">\n<meta name=\"keywords\" lang=\"en\" content=\"flawfinder results, security scan\">\n</head>\n<body>\n<h1>Flawfinder Results</h1>\nHere are the security scan results from\n<a href=\"https://dwheeler.com/flawfinder\">Flawfinder version 2.0.19</a>,\n(C) 2001-2019 <a href=\"https://dwheeler.com\">David A. Wheeler</a>.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\n<p>\nExamining /var/folders/ql/btm7z5tx32ddpsky8z3bz4_r0000gn/T/tmpm9yckzw1.c <br>\n\n<h2>Final Results</h2>\n<ul>\n</ul>\n<h2>Analysis Summary</h2>\n<p>\nNo hits found.\n<br>\nLines analyzed = 1 in approximately 0.00 seconds (556 lines/second)\n<br>\nPhysical Source Lines of Code (SLOC) = 1\n<br>\nHits@level = [0]   0 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0 <br>\nHits@level+ = [0+]   0 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0 <br>\nHits/KSLOC@level+ = [0+]   0 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0 <br>\nMinimum risk level = 1\n<br>\nThere may be other security vulnerabilities; review your code!\n<br>\nSee '<a href=\"https://dwheeler.com/secure-programs\">Secure Programming HOWTO</a>'\n(<a href=\"https://dwheeler.com/secure-programs\">https://dwheeler.com/secure-programs</a>) for more information.\n</body>\n</html>\n",
      "error_message": null
    },
    {
      "cve_id": "CVE-2019-19481",
      "tool_name": "Flawfinder",
      "detected": true,
      "confidence": 0.75,
      "detection_time": 0.029455184936523438,
      "tool_output": "<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.01 Transitional//EN\" \"http://www.w3.org/TR/html4/loose.dtd\">\n<html>\n<head>\n<meta http-equiv=\"Content-type\" content=\"text/html; charset=utf8\">\n<title>Flawfinder Results</title>\n<meta name=\"author\" content=\"David A. Wheeler\">\n<meta name=\"keywords\" lang=\"en\" content=\"flawfinder results, security scan\">\n</head>\n<body>\n<h1>Flawfinder Results</h1>\nHere are the security scan results from\n<a href=\"https://dwheeler.com/flawfinder\">Flawfinder version 2.0.19</a>,\n(C) 2001-2019 <a href=\"https://dwheeler.com\">David A. Wheeler</a>.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\n<p>\nExamining /var/folders/ql/btm7z5tx32ddpsky8z3bz4_r0000gn/T/tmp9zssyxmp.c <br>\n\n<h2>Final Results</h2>\n<ul>\n<li>/var/folders/ql/btm7z5tx32ddpsky8z3bz4_r0000gn/T/tmp9zssyxmp.c:1: <b>  [2] </b> (buffer) <i> memcpy:\n  Does not check for buffer overflows when copying to destination (<a\n  href=\"https://cwe.mitre.org/data/definitions/120.html\">CWE-120</a>). Make\n  sure destination can always hold the source data. </i>\n<pre>\nCWE-119 static int cac_read_binary ( sc_card_t * card , unsigned int idx , unsigned char * buf , size_t count , unsigned long flags ) { cac_private_data_t * priv = CAC_DATA ( card ) ; int r = 0 ; u8 * val = NULL ; u8 * cert_ptr ; &lt;S2SV_StartBug&gt; size_t val_len ; &lt;S2SV_EndBug&gt; size_t len , cert_len ; u8 cert_type ; SC_FUNC_CALLED ( card -&gt; ctx , SC_LOG_DEBUG_VERBOSE ) ; if ( priv -&gt; cached ) { sc_log ( card -&gt; ctx , \"returning&lt;S2SV_blank&gt;cached&lt;S2SV_blank&gt;value&lt;S2SV_blank&gt;idx=%d&lt;S2SV_blank&gt;count=%\" SC_FORMAT_LEN_SIZE_T \"u\" , idx , count ) ; if ( idx &gt; priv -&gt; cache_buf_len ) { LOG_FUNC_RETURN ( card -&gt; ctx , SC_ERROR_FILE_END_REACHED ) ; } len = MIN ( count , priv -&gt; cache_buf_len - idx ) ; memcpy ( buf , &amp; priv -&gt; cache_buf [ idx ] , len ) ; LOG_FUNC_RETURN ( card -&gt; ctx , len ) ; } sc_log ( card -&gt; ctx , \"clearing&lt;S2SV_blank&gt;cache&lt;S2SV_blank&gt;idx=%d&lt;S2SV_blank&gt;count=%\" SC_FORMAT_LEN_SIZE_T \"u\" , idx , count ) ; free ( priv -&gt; cache_buf ) ; priv -&gt; cache_buf = NULL ; priv -&gt; cache_buf_len = 0 ; r = cac_cac1_get_certificate ( card , &amp; val , &amp; val_len ) ; if ( r &lt; 0 ) goto done ; if ( val_len &lt; 1 ) { r = SC_ERROR_INVALID_DATA ; goto done ; } cert_type = val [ 0 ] ; cert_ptr = val + 1 ; cert_len = val_len - 1 ; if ( ( cert_type &amp; 0x3 ) == 1 ) { # ifdef ENABLE_ZLIB r = sc_decompress_alloc ( &amp; priv -&gt; cache_buf , &amp; priv -&gt; cache_buf_len , cert_ptr , cert_len , COMPRESSION_AUTO ) ; # else sc_log ( card -&gt; ctx , \"CAC&lt;S2SV_blank&gt;compression&lt;S2SV_blank&gt;not&lt;S2SV_blank&gt;supported,&lt;S2SV_blank&gt;no&lt;S2SV_blank&gt;zlib\" ) ; r = SC_ERROR_NOT_SUPPORTED ; # endif if ( r ) goto done ; } else if ( cert_len &gt; 0 ) { priv -&gt; cache_buf = malloc ( cert_len ) ; if ( priv -&gt; cache_buf == NULL ) { r = SC_ERROR_OUT_OF_MEMORY ; goto done ; } priv -&gt; cache_buf_len = cert_len ; memcpy ( priv -&gt; cache_buf , cert_ptr , cert_len ) ; } priv -&gt; cached = 1 ; len = MIN ( count , priv -&gt; cache_buf_len - idx ) ; if ( len &amp;&amp; priv -&gt; cache_buf ) memcpy ( buf , &amp; priv -&gt; cache_buf [ idx ] , len ) ; r = len ; done : if ( val ) free ( val ) ; LOG_FUNC_RETURN ( card -&gt; ctx , r ) ; }\n</pre>\n<li>/var/folders/ql/btm7z5tx32ddpsky8z3bz4_r0000gn/T/tmp9zssyxmp.c:1: <b>  [2] </b> (buffer) <i> memcpy:\n  Does not check for buffer overflows when copying to destination (<a\n  href=\"https://cwe.mitre.org/data/definitions/120.html\">CWE-120</a>). Make\n  sure destination can always hold the source data. </i>\n<pre>\nCWE-119 static int cac_read_binary ( sc_card_t * card , unsigned int idx , unsigned char * buf , size_t count , unsigned long flags ) { cac_private_data_t * priv = CAC_DATA ( card ) ; int r = 0 ; u8 * val = NULL ; u8 * cert_ptr ; &lt;S2SV_StartBug&gt; size_t val_len ; &lt;S2SV_EndBug&gt; size_t len , cert_len ; u8 cert_type ; SC_FUNC_CALLED ( card -&gt; ctx , SC_LOG_DEBUG_VERBOSE ) ; if ( priv -&gt; cached ) { sc_log ( card -&gt; ctx , \"returning&lt;S2SV_blank&gt;cached&lt;S2SV_blank&gt;value&lt;S2SV_blank&gt;idx=%d&lt;S2SV_blank&gt;count=%\" SC_FORMAT_LEN_SIZE_T \"u\" , idx , count ) ; if ( idx &gt; priv -&gt; cache_buf_len ) { LOG_FUNC_RETURN ( card -&gt; ctx , SC_ERROR_FILE_END_REACHED ) ; } len = MIN ( count , priv -&gt; cache_buf_len - idx ) ; memcpy ( buf , &amp; priv -&gt; cache_buf [ idx ] , len ) ; LOG_FUNC_RETURN ( card -&gt; ctx , len ) ; } sc_log ( card -&gt; ctx , \"clearing&lt;S2SV_blank&gt;cache&lt;S2SV_blank&gt;idx=%d&lt;S2SV_blank&gt;count=%\" SC_FORMAT_LEN_SIZE_T \"u\" , idx , count ) ; free ( priv -&gt; cache_buf ) ; priv -&gt; cache_buf = NULL ; priv -&gt; cache_buf_len = 0 ; r = cac_cac1_get_certificate ( card , &amp; val , &amp; val_len ) ; if ( r &lt; 0 ) goto done ; if ( val_len &lt; 1 ) { r = SC_ERROR_INVALID_DATA ; goto done ; } cert_type = val [ 0 ] ; cert_ptr = val + 1 ; cert_len = val_len - 1 ; if ( ( cert_type &amp; 0x3 ) == 1 ) { # ifdef ENABLE_ZLIB r = sc_decompress_alloc ( &amp; priv -&gt; cache_buf , &amp; priv -&gt; cache_buf_len , cert_ptr , cert_len , COMPRESSION_AUTO ) ; # else sc_log ( card -&gt; ctx , \"CAC&lt;S2SV_blank&gt;compression&lt;S2SV_blank&gt;not&lt;S2SV_blank&gt;supported,&lt;S2SV_blank&gt;no&lt;S2SV_blank&gt;zlib\" ) ; r = SC_ERROR_NOT_SUPPORTED ; # endif if ( r ) goto done ; } else if ( cert_len &gt; 0 ) { priv -&gt; cache_buf = malloc ( cert_len ) ; if ( priv -&gt; cache_buf == NULL ) { r = SC_ERROR_OUT_OF_MEMORY ; goto done ; } priv -&gt; cache_buf_len = cert_len ; memcpy ( priv -&gt; cache_buf , cert_ptr , cert_len ) ; } priv -&gt; cached = 1 ; len = MIN ( count , priv -&gt; cache_buf_len - idx ) ; if ( len &amp;&amp; priv -&gt; cache_buf ) memcpy ( buf , &amp; priv -&gt; cache_buf [ idx ] , len ) ; r = len ; done : if ( val ) free ( val ) ; LOG_FUNC_RETURN ( card -&gt; ctx , r ) ; }\n</pre>\n<li>/var/folders/ql/btm7z5tx32ddpsky8z3bz4_r0000gn/T/tmp9zssyxmp.c:1: <b>  [2] </b> (buffer) <i> memcpy:\n  Does not check for buffer overflows when copying to destination (<a\n  href=\"https://cwe.mitre.org/data/definitions/120.html\">CWE-120</a>). Make\n  sure destination can always hold the source data. </i>\n<pre>\nCWE-119 static int cac_read_binary ( sc_card_t * card , unsigned int idx , unsigned char * buf , size_t count , unsigned long flags ) { cac_private_data_t * priv = CAC_DATA ( card ) ; int r = 0 ; u8 * val = NULL ; u8 * cert_ptr ; &lt;S2SV_StartBug&gt; size_t val_len ; &lt;S2SV_EndBug&gt; size_t len , cert_len ; u8 cert_type ; SC_FUNC_CALLED ( card -&gt; ctx , SC_LOG_DEBUG_VERBOSE ) ; if ( priv -&gt; cached ) { sc_log ( card -&gt; ctx , \"returning&lt;S2SV_blank&gt;cached&lt;S2SV_blank&gt;value&lt;S2SV_blank&gt;idx=%d&lt;S2SV_blank&gt;count=%\" SC_FORMAT_LEN_SIZE_T \"u\" , idx , count ) ; if ( idx &gt; priv -&gt; cache_buf_len ) { LOG_FUNC_RETURN ( card -&gt; ctx , SC_ERROR_FILE_END_REACHED ) ; } len = MIN ( count , priv -&gt; cache_buf_len - idx ) ; memcpy ( buf , &amp; priv -&gt; cache_buf [ idx ] , len ) ; LOG_FUNC_RETURN ( card -&gt; ctx , len ) ; } sc_log ( card -&gt; ctx , \"clearing&lt;S2SV_blank&gt;cache&lt;S2SV_blank&gt;idx=%d&lt;S2SV_blank&gt;count=%\" SC_FORMAT_LEN_SIZE_T \"u\" , idx , count ) ; free ( priv -&gt; cache_buf ) ; priv -&gt; cache_buf = NULL ; priv -&gt; cache_buf_len = 0 ; r = cac_cac1_get_certificate ( card , &amp; val , &amp; val_len ) ; if ( r &lt; 0 ) goto done ; if ( val_len &lt; 1 ) { r = SC_ERROR_INVALID_DATA ; goto done ; } cert_type = val [ 0 ] ; cert_ptr = val + 1 ; cert_len = val_len - 1 ; if ( ( cert_type &amp; 0x3 ) == 1 ) { # ifdef ENABLE_ZLIB r = sc_decompress_alloc ( &amp; priv -&gt; cache_buf , &amp; priv -&gt; cache_buf_len , cert_ptr , cert_len , COMPRESSION_AUTO ) ; # else sc_log ( card -&gt; ctx , \"CAC&lt;S2SV_blank&gt;compression&lt;S2SV_blank&gt;not&lt;S2SV_blank&gt;supported,&lt;S2SV_blank&gt;no&lt;S2SV_blank&gt;zlib\" ) ; r = SC_ERROR_NOT_SUPPORTED ; # endif if ( r ) goto done ; } else if ( cert_len &gt; 0 ) { priv -&gt; cache_buf = malloc ( cert_len ) ; if ( priv -&gt; cache_buf == NULL ) { r = SC_ERROR_OUT_OF_MEMORY ; goto done ; } priv -&gt; cache_buf_len = cert_len ; memcpy ( priv -&gt; cache_buf , cert_ptr , cert_len ) ; } priv -&gt; cached = 1 ; len = MIN ( count , priv -&gt; cache_buf_len - idx ) ; if ( len &amp;&amp; priv -&gt; cache_buf ) memcpy ( buf , &amp; priv -&gt; cache_buf [ idx ] , len ) ; r = len ; done : if ( val ) free ( val ) ; LOG_FUNC_RETURN ( card -&gt; ctx , r ) ; }\n</pre>\n</ul>\n<h2>Analysis Summary</h2>\n<p>\nHits = 3\n<br>\nLines analyzed = 1 in approximately 0.00 seconds (475 lines/second)\n<br>\nPhysical Source Lines of Code (SLOC) = 1\n<br>\nHits@level = [0]   0 [1]   0 [2]   3 [3]   0 [4]   0 [5]   0 <br>\nHits@level+ = [0+]   3 [1+]   3 [2+]   3 [3+]   0 [4+]   0 [5+]   0 <br>\nHits/KSLOC@level+ = [0+] 3000 [1+] 3000 [2+] 3000 [3+]   0 [4+]   0 [5+]   0 <br>\nMinimum risk level = 1\n<br>\nNot every hit is necessarily a security vulnerability.\nYou can inhibit a report by adding a comment in this form:\n// flawfinder: ignore\nMake *sure* it's a false positive!\nYou can use the option --neverignore to show these.\n<br>\nThere may be other security vulnerabilities; review your code!\n<br>\nSee '<a href=\"https://dwheeler.com/secure-programs\">Secure Programming HOWTO</a>'\n(<a href=\"https://dwheeler.com/secure-programs\">https://dwheeler.com/secure-programs</a>) for more information.\n</body>\n</html>\n",
      "error_message": null
    },
    {
      "cve_id": "CVE-2019-13308",
      "tool_name": "Flawfinder",
      "detected": true,
      "confidence": 0.25,
      "detection_time": 0.029282093048095703,
      "tool_output": "<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.01 Transitional//EN\" \"http://www.w3.org/TR/html4/loose.dtd\">\n<html>\n<head>\n<meta http-equiv=\"Content-type\" content=\"text/html; charset=utf8\">\n<title>Flawfinder Results</title>\n<meta name=\"author\" content=\"David A. Wheeler\">\n<meta name=\"keywords\" lang=\"en\" content=\"flawfinder results, security scan\">\n</head>\n<body>\n<h1>Flawfinder Results</h1>\nHere are the security scan results from\n<a href=\"https://dwheeler.com/flawfinder\">Flawfinder version 2.0.19</a>,\n(C) 2001-2019 <a href=\"https://dwheeler.com\">David A. Wheeler</a>.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\n<p>\nExamining /var/folders/ql/btm7z5tx32ddpsky8z3bz4_r0000gn/T/tmpk5exch_9.c <br>\n\n<h2>Final Results</h2>\n<ul>\n</ul>\n<h2>Analysis Summary</h2>\n<p>\nNo hits found.\n<br>\nLines analyzed = 1 in approximately 0.00 seconds (544 lines/second)\n<br>\nPhysical Source Lines of Code (SLOC) = 1\n<br>\nHits@level = [0]   0 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0 <br>\nHits@level+ = [0+]   0 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0 <br>\nHits/KSLOC@level+ = [0+]   0 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0 <br>\nMinimum risk level = 1\n<br>\nThere may be other security vulnerabilities; review your code!\n<br>\nSee '<a href=\"https://dwheeler.com/secure-programs\">Secure Programming HOWTO</a>'\n(<a href=\"https://dwheeler.com/secure-programs\">https://dwheeler.com/secure-programs</a>) for more information.\n</body>\n</html>\n",
      "error_message": null
    },
    {
      "cve_id": "CVE-2018-1999011",
      "tool_name": "Flawfinder",
      "detected": true,
      "confidence": 0.25,
      "detection_time": 0.028767108917236328,
      "tool_output": "<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.01 Transitional//EN\" \"http://www.w3.org/TR/html4/loose.dtd\">\n<html>\n<head>\n<meta http-equiv=\"Content-type\" content=\"text/html; charset=utf8\">\n<title>Flawfinder Results</title>\n<meta name=\"author\" content=\"David A. Wheeler\">\n<meta name=\"keywords\" lang=\"en\" content=\"flawfinder results, security scan\">\n</head>\n<body>\n<h1>Flawfinder Results</h1>\nHere are the security scan results from\n<a href=\"https://dwheeler.com/flawfinder\">Flawfinder version 2.0.19</a>,\n(C) 2001-2019 <a href=\"https://dwheeler.com\">David A. Wheeler</a>.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\n<p>\nExamining /var/folders/ql/btm7z5tx32ddpsky8z3bz4_r0000gn/T/tmp8r2_er8v.c <br>\n\n<h2>Final Results</h2>\n<ul>\n</ul>\n<h2>Analysis Summary</h2>\n<p>\nNo hits found.\n<br>\nLines analyzed = 1 in approximately 0.00 seconds (759 lines/second)\n<br>\nPhysical Source Lines of Code (SLOC) = 1\n<br>\nHits@level = [0]   0 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0 <br>\nHits@level+ = [0+]   0 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0 <br>\nHits/KSLOC@level+ = [0+]   0 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0 <br>\nMinimum risk level = 1\n<br>\nThere may be other security vulnerabilities; review your code!\n<br>\nSee '<a href=\"https://dwheeler.com/secure-programs\">Secure Programming HOWTO</a>'\n(<a href=\"https://dwheeler.com/secure-programs\">https://dwheeler.com/secure-programs</a>) for more information.\n</body>\n</html>\n",
      "error_message": null
    },
    {
      "cve_id": "CVE-2017-15385",
      "tool_name": "Flawfinder",
      "detected": true,
      "confidence": 0.5,
      "detection_time": 0.029551029205322266,
      "tool_output": "<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.01 Transitional//EN\" \"http://www.w3.org/TR/html4/loose.dtd\">\n<html>\n<head>\n<meta http-equiv=\"Content-type\" content=\"text/html; charset=utf8\">\n<title>Flawfinder Results</title>\n<meta name=\"author\" content=\"David A. Wheeler\">\n<meta name=\"keywords\" lang=\"en\" content=\"flawfinder results, security scan\">\n</head>\n<body>\n<h1>Flawfinder Results</h1>\nHere are the security scan results from\n<a href=\"https://dwheeler.com/flawfinder\">Flawfinder version 2.0.19</a>,\n(C) 2001-2019 <a href=\"https://dwheeler.com\">David A. Wheeler</a>.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\n<p>\nExamining /var/folders/ql/btm7z5tx32ddpsky8z3bz4_r0000gn/T/tmprc1p36il.c <br>\n\n<h2>Final Results</h2>\n<ul>\n<li>/var/folders/ql/btm7z5tx32ddpsky8z3bz4_r0000gn/T/tmprc1p36il.c:1: <b>  [2] </b> (buffer) <i> char:\n  Statically-sized arrays can be improperly restricted, leading to potential\n  overflows or other issues (<a\n  href=\"https://cwe.mitre.org/data/definitions/119.html\">CWE-119</a>!/<a\n  href=\"https://cwe.mitre.org/data/definitions/120.html\">CWE-120</a>).\n  Perform bounds checking, use functions that limit length, or ensure that\n  the size is larger than the maximum possible length. </i>\n<pre>\nCWE-119 static Sdb * store_versioninfo_gnu_verdef ( ELFOBJ * bin , Elf_ ( Shdr ) * shdr , int sz ) { const char * section_name = \"\" ; const char * link_section_name = \"\" ; char * end = NULL ; Elf_ ( Shdr ) * link_shdr = NULL ; ut8 dfs [ sizeof ( Elf_ ( Verdef ) ) ] = { 0 } ; Sdb * sdb ; int cnt , i ; if ( shdr -&gt; sh_link &gt; bin -&gt; ehdr . e_shnum ) { return false ; } link_shdr = &amp; bin -&gt; shdr [ shdr -&gt; sh_link ] ; if ( shdr -&gt; sh_size &lt; 1 ) { return false ; } Elf_ ( Verdef ) * defs = calloc ( shdr -&gt; sh_size , sizeof ( char ) ) ; if ( ! defs ) { return false ; } if ( bin -&gt; shstrtab &amp;&amp; shdr -&gt; sh_name &lt; bin -&gt; shstrtab_size ) { section_name = &amp; bin -&gt; shstrtab [ shdr -&gt; sh_name ] ; } if ( link_shdr &amp;&amp; bin -&gt; shstrtab &amp;&amp; link_shdr -&gt; sh_name &lt; bin -&gt; shstrtab_size ) { link_section_name = &amp; bin -&gt; shstrtab [ link_shdr -&gt; sh_name ] ; } if ( ! defs ) { bprintf ( \"Warning:&lt;S2SV_blank&gt;Cannot&lt;S2SV_blank&gt;allocate&lt;S2SV_blank&gt;memory&lt;S2SV_blank&gt;(Check&lt;S2SV_blank&gt;Elf_(Verdef))\\\\n\" ) ; return NULL ; } sdb = sdb_new0 ( ) ; end = ( char * ) defs + shdr -&gt; sh_size ; sdb_set ( sdb , \"section_name\" , section_name , 0 ) ; sdb_num_set ( sdb , \"entries\" , shdr -&gt; sh_info , 0 ) ; sdb_num_set ( sdb , \"addr\" , shdr -&gt; sh_addr , 0 ) ; sdb_num_set ( sdb , \"offset\" , shdr -&gt; sh_offset , 0 ) ; sdb_num_set ( sdb , \"link\" , shdr -&gt; sh_link , 0 ) ; sdb_set ( sdb , \"link_section_name\" , link_section_name , 0 ) ; &lt;S2SV_StartBug&gt; for ( cnt = 0 , i = 0 ; cnt &lt; shdr -&gt; sh_info &amp;&amp; ( ( char * ) defs + i &lt; end ) ; ++ cnt ) { &lt;S2SV_EndBug&gt; Sdb * sdb_verdef = sdb_new0 ( ) ; char * vstart = ( ( char * ) defs ) + i ; char key [ 32 ] = { 0 } ; Elf_ ( Verdef ) * verdef = ( Elf_ ( Verdef ) * ) vstart ; Elf_ ( Verdaux ) aux = { 0 } ; int j = 0 ; int isum = 0 ; r_buf_read_at ( bin -&gt; b , shdr -&gt; sh_offset + i , dfs , sizeof ( Elf_ ( Verdef ) ) ) ; verdef -&gt; vd_version = READ16 ( dfs , j ) verdef -&gt; vd_flags = READ16 ( dfs , j ) verdef -&gt; vd_ndx = READ16 ( dfs , j ) verdef -&gt; vd_cnt = READ16 ( dfs , j ) verdef -&gt; vd_hash = READ32 ( dfs , j ) verdef -&gt; vd_aux = READ32 ( dfs , j ) verdef -&gt; vd_next = READ32 ( dfs , j ) vstart += verdef -&gt; vd_aux ; if ( vstart &gt; end || vstart + sizeof ( Elf_ ( Verdaux ) ) &gt; end ) { sdb_free ( sdb_verdef ) ; goto out_error ; } j = 0 ; aux . vda_name = READ32 ( vstart , j ) aux . vda_next = READ32 ( vstart , j ) isum = i + verdef -&gt; vd_aux ; if ( aux . vda_name &gt; bin -&gt; dynstr_size ) { sdb_free ( sdb_verdef ) ; goto out_error ; } sdb_num_set ( sdb_verdef , \"idx\" , i , 0 ) ; sdb_num_set ( sdb_verdef , \"vd_version\" , verdef -&gt; vd_version , 0 ) ; sdb_num_set ( sdb_verdef , \"vd_ndx\" , verdef -&gt; vd_ndx , 0 ) ; sdb_num_set ( sdb_verdef , \"vd_cnt\" , verdef -&gt; vd_cnt , 0 ) ; sdb_set ( sdb_verdef , \"vda_name\" , &amp; bin -&gt; dynstr [ aux . vda_name ] , 0 ) ; sdb_set ( sdb_verdef , \"flags\" , get_ver_flags ( verdef -&gt; vd_flags ) , 0 ) ; for ( j = 1 ; j &lt; verdef -&gt; vd_cnt ; ++ j ) { int k ; Sdb * sdb_parent = sdb_new0 ( ) ; isum += aux . vda_next ; vstart += aux . vda_next ; if ( vstart &gt; end || vstart + sizeof ( Elf_ ( Verdaux ) ) &gt; end ) { sdb_free ( sdb_verdef ) ; sdb_free ( sdb_parent ) ; goto out_error ; } k = 0 ; aux . vda_name = READ32 ( vstart , k ) aux . vda_next = READ32 ( vstart , k ) if ( aux . vda_name &gt; bin -&gt; dynstr_size ) { sdb_free ( sdb_verdef ) ; sdb_free ( sdb_parent ) ; goto out_error ; } sdb_num_set ( sdb_parent , \"idx\" , isum , 0 ) ; sdb_num_set ( sdb_parent , \"parent\" , j , 0 ) ; sdb_set ( sdb_parent , \"vda_name\" , &amp; bin -&gt; dynstr [ aux . vda_name ] , 0 ) ; snprintf ( key , sizeof ( key ) , \"parent%d\" , j - 1 ) ; sdb_ns_set ( sdb_verdef , key , sdb_parent ) ; } snprintf ( key , sizeof ( key ) , \"verdef%d\" , cnt ) ; sdb_ns_set ( sdb , key , sdb_verdef ) ; if ( ! verdef -&gt; vd_next ) { sdb_free ( sdb_verdef ) ; goto out_error ; } &lt;S2SV_StartBug&gt; i += verdef -&gt; vd_next ; &lt;S2SV_EndBug&gt; } free ( defs ) ; return sdb ; out_error : free ( defs ) ; sdb_free ( sdb ) ; return NULL ; }\n</pre>\n</ul>\n<h2>Analysis Summary</h2>\n<p>\nHits = 1\n<br>\nLines analyzed = 1 in approximately 0.00 seconds (569 lines/second)\n<br>\nPhysical Source Lines of Code (SLOC) = 1\n<br>\nHits@level = [0]   2 [1]   0 [2]   1 [3]   0 [4]   0 [5]   0 <br>\nHits@level+ = [0+]   3 [1+]   1 [2+]   1 [3+]   0 [4+]   0 [5+]   0 <br>\nHits/KSLOC@level+ = [0+] 3000 [1+] 1000 [2+] 1000 [3+]   0 [4+]   0 [5+]   0 <br>\nMinimum risk level = 1\n<br>\nNot every hit is necessarily a security vulnerability.\nYou can inhibit a report by adding a comment in this form:\n// flawfinder: ignore\nMake *sure* it's a false positive!\nYou can use the option --neverignore to show these.\n<br>\nThere may be other security vulnerabilities; review your code!\n<br>\nSee '<a href=\"https://dwheeler.com/secure-programs\">Secure Programming HOWTO</a>'\n(<a href=\"https://dwheeler.com/secure-programs\">https://dwheeler.com/secure-programs</a>) for more information.\n</body>\n</html>\n",
      "error_message": null
    },
    {
      "cve_id": "CVE-2019-19244",
      "tool_name": "Flawfinder",
      "detected": true,
      "confidence": 0.25,
      "detection_time": 0.03159976005554199,
      "tool_output": "<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.01 Transitional//EN\" \"http://www.w3.org/TR/html4/loose.dtd\">\n<html>\n<head>\n<meta http-equiv=\"Content-type\" content=\"text/html; charset=utf8\">\n<title>Flawfinder Results</title>\n<meta name=\"author\" content=\"David A. Wheeler\">\n<meta name=\"keywords\" lang=\"en\" content=\"flawfinder results, security scan\">\n</head>\n<body>\n<h1>Flawfinder Results</h1>\nHere are the security scan results from\n<a href=\"https://dwheeler.com/flawfinder\">Flawfinder version 2.0.19</a>,\n(C) 2001-2019 <a href=\"https://dwheeler.com\">David A. Wheeler</a>.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\n<p>\nExamining /var/folders/ql/btm7z5tx32ddpsky8z3bz4_r0000gn/T/tmp5wwpcxuq.c <br>\n\n<h2>Final Results</h2>\n<ul>\n</ul>\n<h2>Analysis Summary</h2>\n<p>\nNo hits found.\n<br>\nLines analyzed = 1 in approximately 0.00 seconds (249 lines/second)\n<br>\nPhysical Source Lines of Code (SLOC) = 1\n<br>\nHits@level = [0]   0 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0 <br>\nHits@level+ = [0+]   0 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0 <br>\nHits/KSLOC@level+ = [0+]   0 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0 <br>\nMinimum risk level = 1\n<br>\nThere may be other security vulnerabilities; review your code!\n<br>\nSee '<a href=\"https://dwheeler.com/secure-programs\">Secure Programming HOWTO</a>'\n(<a href=\"https://dwheeler.com/secure-programs\">https://dwheeler.com/secure-programs</a>) for more information.\n</body>\n</html>\n",
      "error_message": null
    },
    {
      "cve_id": "CVE-2016-1621",
      "tool_name": "Bandit",
      "detected": true,
      "confidence": 0.5,
      "detection_time": 0.08644294738769531,
      "tool_output": "{\n  \"errors\": [\n    {\n      \"filename\": \"/var/folders/ql/btm7z5tx32ddpsky8z3bz4_r0000gn/T/tmp25qkng10.c\",\n      \"reason\": \"syntax error while parsing AST from file\"\n    }\n  ],\n  \"generated_at\": \"2025-09-02T19:52:09Z\",\n  \"metrics\": {\n    \"/var/folders/ql/btm7z5tx32ddpsky8z3bz4_r0000gn/T/tmp25qkng10.c\": {\n      \"loc\": 1,\n      \"nosec\": 0,\n      \"skipped_tests\": 0\n    },\n    \"_totals\": {\n      \"CONFIDENCE.HIGH\": 0,\n      \"CONFIDENCE.LOW\": 0,\n      \"CONFIDENCE.MEDIUM\": 0,\n      \"CONFIDENCE.UNDEFINED\": 0,\n      \"SEVERITY.HIGH\": 0,\n      \"SEVERITY.LOW\": 0,\n      \"SEVERITY.MEDIUM\": 0,\n      \"SEVERITY.UNDEFINED\": 0,\n      \"loc\": 1,\n      \"nosec\": 0,\n      \"skipped_tests\": 0\n    }\n  },\n  \"results\": []\n}[main]\tINFO\tprofile include tests: None\n[main]\tINFO\tprofile exclude tests: None\n[main]\tINFO\tcli include tests: None\n[main]\tINFO\tcli exclude tests: None\n",
      "error_message": null
    },
    {
      "cve_id": "CVE-2020-14954",
      "tool_name": "Bandit",
      "detected": true,
      "confidence": 0.5,
      "detection_time": 0.08491897583007812,
      "tool_output": "{\n  \"errors\": [\n    {\n      \"filename\": \"/var/folders/ql/btm7z5tx32ddpsky8z3bz4_r0000gn/T/tmpt0n664p4.c\",\n      \"reason\": \"syntax error while parsing AST from file\"\n    }\n  ],\n  \"generated_at\": \"2025-09-02T19:52:09Z\",\n  \"metrics\": {\n    \"/var/folders/ql/btm7z5tx32ddpsky8z3bz4_r0000gn/T/tmpt0n664p4.c\": {\n      \"loc\": 1,\n      \"nosec\": 0,\n      \"skipped_tests\": 0\n    },\n    \"_totals\": {\n      \"CONFIDENCE.HIGH\": 0,\n      \"CONFIDENCE.LOW\": 0,\n      \"CONFIDENCE.MEDIUM\": 0,\n      \"CONFIDENCE.UNDEFINED\": 0,\n      \"SEVERITY.HIGH\": 0,\n      \"SEVERITY.LOW\": 0,\n      \"SEVERITY.MEDIUM\": 0,\n      \"SEVERITY.UNDEFINED\": 0,\n      \"loc\": 1,\n      \"nosec\": 0,\n      \"skipped_tests\": 0\n    }\n  },\n  \"results\": []\n}[main]\tINFO\tprofile include tests: None\n[main]\tINFO\tprofile exclude tests: None\n[main]\tINFO\tcli include tests: None\n[main]\tINFO\tcli exclude tests: None\n",
      "error_message": null
    },
    {
      "cve_id": "CVE-2020-15474",
      "tool_name": "Bandit",
      "detected": true,
      "confidence": 0.5,
      "detection_time": 0.0847630500793457,
      "tool_output": "{\n  \"errors\": [\n    {\n      \"filename\": \"/var/folders/ql/btm7z5tx32ddpsky8z3bz4_r0000gn/T/tmpnx12r20j.c\",\n      \"reason\": \"syntax error while parsing AST from file\"\n    }\n  ],\n  \"generated_at\": \"2025-09-02T19:52:09Z\",\n  \"metrics\": {\n    \"/var/folders/ql/btm7z5tx32ddpsky8z3bz4_r0000gn/T/tmpnx12r20j.c\": {\n      \"loc\": 1,\n      \"nosec\": 0,\n      \"skipped_tests\": 0\n    },\n    \"_totals\": {\n      \"CONFIDENCE.HIGH\": 0,\n      \"CONFIDENCE.LOW\": 0,\n      \"CONFIDENCE.MEDIUM\": 0,\n      \"CONFIDENCE.UNDEFINED\": 0,\n      \"SEVERITY.HIGH\": 0,\n      \"SEVERITY.LOW\": 0,\n      \"SEVERITY.MEDIUM\": 0,\n      \"SEVERITY.UNDEFINED\": 0,\n      \"loc\": 1,\n      \"nosec\": 0,\n      \"skipped_tests\": 0\n    }\n  },\n  \"results\": []\n}[main]\tINFO\tprofile include tests: None\n[main]\tINFO\tprofile exclude tests: None\n[main]\tINFO\tcli include tests: None\n[main]\tINFO\tcli exclude tests: None\n",
      "error_message": null
    },
    {
      "cve_id": "CVE-2017-15385",
      "tool_name": "Bandit",
      "detected": true,
      "confidence": 0.5,
      "detection_time": 0.08691000938415527,
      "tool_output": "{\n  \"errors\": [\n    {\n      \"filename\": \"/var/folders/ql/btm7z5tx32ddpsky8z3bz4_r0000gn/T/tmpsksmlk9l.c\",\n      \"reason\": \"syntax error while parsing AST from file\"\n    }\n  ],\n  \"generated_at\": \"2025-09-02T19:52:09Z\",\n  \"metrics\": {\n    \"/var/folders/ql/btm7z5tx32ddpsky8z3bz4_r0000gn/T/tmpsksmlk9l.c\": {\n      \"loc\": 1,\n      \"nosec\": 0,\n      \"skipped_tests\": 0\n    },\n    \"_totals\": {\n      \"CONFIDENCE.HIGH\": 0,\n      \"CONFIDENCE.LOW\": 0,\n      \"CONFIDENCE.MEDIUM\": 0,\n      \"CONFIDENCE.UNDEFINED\": 0,\n      \"SEVERITY.HIGH\": 0,\n      \"SEVERITY.LOW\": 0,\n      \"SEVERITY.MEDIUM\": 0,\n      \"SEVERITY.UNDEFINED\": 0,\n      \"loc\": 1,\n      \"nosec\": 0,\n      \"skipped_tests\": 0\n    }\n  },\n  \"results\": []\n}[main]\tINFO\tprofile include tests: None\n[main]\tINFO\tprofile exclude tests: None\n[main]\tINFO\tcli include tests: None\n[main]\tINFO\tcli exclude tests: None\n",
      "error_message": null
    },
    {
      "cve_id": "CVE-2019-19275",
      "tool_name": "Bandit",
      "detected": true,
      "confidence": 0.5,
      "detection_time": 0.0874321460723877,
      "tool_output": "{\n  \"errors\": [\n    {\n      \"filename\": \"/var/folders/ql/btm7z5tx32ddpsky8z3bz4_r0000gn/T/tmpa9eod14m.c\",\n      \"reason\": \"syntax error while parsing AST from file\"\n    }\n  ],\n  \"generated_at\": \"2025-09-02T19:52:10Z\",\n  \"metrics\": {\n    \"/var/folders/ql/btm7z5tx32ddpsky8z3bz4_r0000gn/T/tmpa9eod14m.c\": {\n      \"loc\": 1,\n      \"nosec\": 0,\n      \"skipped_tests\": 0\n    },\n    \"_totals\": {\n      \"CONFIDENCE.HIGH\": 0,\n      \"CONFIDENCE.LOW\": 0,\n      \"CONFIDENCE.MEDIUM\": 0,\n      \"CONFIDENCE.UNDEFINED\": 0,\n      \"SEVERITY.HIGH\": 0,\n      \"SEVERITY.LOW\": 0,\n      \"SEVERITY.MEDIUM\": 0,\n      \"SEVERITY.UNDEFINED\": 0,\n      \"loc\": 1,\n      \"nosec\": 0,\n      \"skipped_tests\": 0\n    }\n  },\n  \"results\": []\n}[main]\tINFO\tprofile include tests: None\n[main]\tINFO\tprofile exclude tests: None\n[main]\tINFO\tcli include tests: None\n[main]\tINFO\tcli exclude tests: None\n",
      "error_message": null
    },
    {
      "cve_id": "CVE-2019-19481",
      "tool_name": "Bandit",
      "detected": true,
      "confidence": 0.5,
      "detection_time": 0.08829689025878906,
      "tool_output": "{\n  \"errors\": [\n    {\n      \"filename\": \"/var/folders/ql/btm7z5tx32ddpsky8z3bz4_r0000gn/T/tmpzwuu9j8i.c\",\n      \"reason\": \"syntax error while parsing AST from file\"\n    }\n  ],\n  \"generated_at\": \"2025-09-02T19:52:10Z\",\n  \"metrics\": {\n    \"/var/folders/ql/btm7z5tx32ddpsky8z3bz4_r0000gn/T/tmpzwuu9j8i.c\": {\n      \"loc\": 1,\n      \"nosec\": 0,\n      \"skipped_tests\": 0\n    },\n    \"_totals\": {\n      \"CONFIDENCE.HIGH\": 0,\n      \"CONFIDENCE.LOW\": 0,\n      \"CONFIDENCE.MEDIUM\": 0,\n      \"CONFIDENCE.UNDEFINED\": 0,\n      \"SEVERITY.HIGH\": 0,\n      \"SEVERITY.LOW\": 0,\n      \"SEVERITY.MEDIUM\": 0,\n      \"SEVERITY.UNDEFINED\": 0,\n      \"loc\": 1,\n      \"nosec\": 0,\n      \"skipped_tests\": 0\n    }\n  },\n  \"results\": []\n}[main]\tINFO\tprofile include tests: None\n[main]\tINFO\tprofile exclude tests: None\n[main]\tINFO\tcli include tests: None\n[main]\tINFO\tcli exclude tests: None\n",
      "error_message": null
    },
    {
      "cve_id": "CVE-2019-13308",
      "tool_name": "Bandit",
      "detected": true,
      "confidence": 0.5,
      "detection_time": 0.08827781677246094,
      "tool_output": "{\n  \"errors\": [\n    {\n      \"filename\": \"/var/folders/ql/btm7z5tx32ddpsky8z3bz4_r0000gn/T/tmpkqj4ph48.c\",\n      \"reason\": \"syntax error while parsing AST from file\"\n    }\n  ],\n  \"generated_at\": \"2025-09-02T19:52:10Z\",\n  \"metrics\": {\n    \"/var/folders/ql/btm7z5tx32ddpsky8z3bz4_r0000gn/T/tmpkqj4ph48.c\": {\n      \"loc\": 1,\n      \"nosec\": 0,\n      \"skipped_tests\": 0\n    },\n    \"_totals\": {\n      \"CONFIDENCE.HIGH\": 0,\n      \"CONFIDENCE.LOW\": 0,\n      \"CONFIDENCE.MEDIUM\": 0,\n      \"CONFIDENCE.UNDEFINED\": 0,\n      \"SEVERITY.HIGH\": 0,\n      \"SEVERITY.LOW\": 0,\n      \"SEVERITY.MEDIUM\": 0,\n      \"SEVERITY.UNDEFINED\": 0,\n      \"loc\": 1,\n      \"nosec\": 0,\n      \"skipped_tests\": 0\n    }\n  },\n  \"results\": []\n}[main]\tINFO\tprofile include tests: None\n[main]\tINFO\tprofile exclude tests: None\n[main]\tINFO\tcli include tests: None\n[main]\tINFO\tcli exclude tests: None\n",
      "error_message": null
    },
    {
      "cve_id": "CVE-2018-1999011",
      "tool_name": "Bandit",
      "detected": true,
      "confidence": 0.5,
      "detection_time": 0.08696603775024414,
      "tool_output": "{\n  \"errors\": [\n    {\n      \"filename\": \"/var/folders/ql/btm7z5tx32ddpsky8z3bz4_r0000gn/T/tmpn966m2b9.c\",\n      \"reason\": \"syntax error while parsing AST from file\"\n    }\n  ],\n  \"generated_at\": \"2025-09-02T19:52:10Z\",\n  \"metrics\": {\n    \"/var/folders/ql/btm7z5tx32ddpsky8z3bz4_r0000gn/T/tmpn966m2b9.c\": {\n      \"loc\": 1,\n      \"nosec\": 0,\n      \"skipped_tests\": 0\n    },\n    \"_totals\": {\n      \"CONFIDENCE.HIGH\": 0,\n      \"CONFIDENCE.LOW\": 0,\n      \"CONFIDENCE.MEDIUM\": 0,\n      \"CONFIDENCE.UNDEFINED\": 0,\n      \"SEVERITY.HIGH\": 0,\n      \"SEVERITY.LOW\": 0,\n      \"SEVERITY.MEDIUM\": 0,\n      \"SEVERITY.UNDEFINED\": 0,\n      \"loc\": 1,\n      \"nosec\": 0,\n      \"skipped_tests\": 0\n    }\n  },\n  \"results\": []\n}[main]\tINFO\tprofile include tests: None\n[main]\tINFO\tprofile exclude tests: None\n[main]\tINFO\tcli include tests: None\n[main]\tINFO\tcli exclude tests: None\n",
      "error_message": null
    },
    {
      "cve_id": "CVE-2017-15385",
      "tool_name": "Bandit",
      "detected": true,
      "confidence": 0.5,
      "detection_time": 0.08795714378356934,
      "tool_output": "{\n  \"errors\": [\n    {\n      \"filename\": \"/var/folders/ql/btm7z5tx32ddpsky8z3bz4_r0000gn/T/tmpxepgyjyi.c\",\n      \"reason\": \"syntax error while parsing AST from file\"\n    }\n  ],\n  \"generated_at\": \"2025-09-02T19:52:10Z\",\n  \"metrics\": {\n    \"/var/folders/ql/btm7z5tx32ddpsky8z3bz4_r0000gn/T/tmpxepgyjyi.c\": {\n      \"loc\": 1,\n      \"nosec\": 0,\n      \"skipped_tests\": 0\n    },\n    \"_totals\": {\n      \"CONFIDENCE.HIGH\": 0,\n      \"CONFIDENCE.LOW\": 0,\n      \"CONFIDENCE.MEDIUM\": 0,\n      \"CONFIDENCE.UNDEFINED\": 0,\n      \"SEVERITY.HIGH\": 0,\n      \"SEVERITY.LOW\": 0,\n      \"SEVERITY.MEDIUM\": 0,\n      \"SEVERITY.UNDEFINED\": 0,\n      \"loc\": 1,\n      \"nosec\": 0,\n      \"skipped_tests\": 0\n    }\n  },\n  \"results\": []\n}[main]\tINFO\tprofile include tests: None\n[main]\tINFO\tprofile exclude tests: None\n[main]\tINFO\tcli include tests: None\n[main]\tINFO\tcli exclude tests: None\n",
      "error_message": null
    },
    {
      "cve_id": "CVE-2019-19244",
      "tool_name": "Bandit",
      "detected": true,
      "confidence": 0.5,
      "detection_time": 0.0869600772857666,
      "tool_output": "{\n  \"errors\": [\n    {\n      \"filename\": \"/var/folders/ql/btm7z5tx32ddpsky8z3bz4_r0000gn/T/tmpsl3l1xl7.c\",\n      \"reason\": \"syntax error while parsing AST from file\"\n    }\n  ],\n  \"generated_at\": \"2025-09-02T19:52:10Z\",\n  \"metrics\": {\n    \"/var/folders/ql/btm7z5tx32ddpsky8z3bz4_r0000gn/T/tmpsl3l1xl7.c\": {\n      \"loc\": 1,\n      \"nosec\": 0,\n      \"skipped_tests\": 0\n    },\n    \"_totals\": {\n      \"CONFIDENCE.HIGH\": 0,\n      \"CONFIDENCE.LOW\": 0,\n      \"CONFIDENCE.MEDIUM\": 0,\n      \"CONFIDENCE.UNDEFINED\": 0,\n      \"SEVERITY.HIGH\": 0,\n      \"SEVERITY.LOW\": 0,\n      \"SEVERITY.MEDIUM\": 0,\n      \"SEVERITY.UNDEFINED\": 0,\n      \"loc\": 1,\n      \"nosec\": 0,\n      \"skipped_tests\": 0\n    }\n  },\n  \"results\": []\n}[main]\tINFO\tprofile include tests: None\n[main]\tINFO\tprofile exclude tests: None\n[main]\tINFO\tcli include tests: None\n[main]\tINFO\tcli exclude tests: None\n",
      "error_message": null
    },
    {
      "cve_id": "CVE-2016-1621",
      "tool_name": "Semgrep",
      "detected": true,
      "confidence": 0.8,
      "detection_time": 4.053981304168701,
      "tool_output": "{\"version\":\"1.134.0\",\"results\":[],\"errors\":[{\"code\":3,\"level\":\"warn\",\"type\":[\"PartialParsing\",[{\"path\":\"/var/folders/ql/btm7z5tx32ddpsky8z3bz4_r0000gn/T/tmpjn5brw0r.c\",\"start\":{\"line\":1,\"col\":1,\"offset\":0},\"end\":{\"line\":1,\"col\":46,\"offset\":45}},{\"path\":\"/var/folders/ql/btm7z5tx32ddpsky8z3bz4_r0000gn/T/tmpjn5brw0r.c\",\"start\":{\"line\":1,\"col\":1175,\"offset\":0},\"end\":{\"line\":1,\"col\":1176,\"offset\":1}}]],\"message\":\"Syntax error at line /var/folders/ql/btm7z5tx32ddpsky8z3bz4_r0000gn/T/tmpjn5brw0r.c:1:\\n `CWE-119 int main ( int argc , char * * argv )` was unexpected\",\"path\":\"/var/folders/ql/btm7z5tx32ddpsky8z3bz4_r0000gn/T/tmpjn5brw0r.c\",\"spans\":[{\"file\":\"/var/folders/ql/btm7z5tx32ddpsky8z3bz4_r0000gn/T/tmpjn5brw0r.c\",\"start\":{\"line\":1,\"col\":1,\"offset\":0},\"end\":{\"line\":1,\"col\":46,\"offset\":45}},{\"file\":\"/var/folders/ql/btm7z5tx32ddpsky8z3bz4_r0000gn/T/tmpjn5brw0r.c\",\"start\":{\"line\":1,\"col\":1175,\"offset\":0},\"end\":{\"line\":1,\"col\":1176,\"offset\":1}}]}],\"paths\":{\"scanned\":[\"/var/folders/ql/btm7z5tx32ddpsky8z3bz4_r0000gn/T/tmpjn5brw0r.c\"]},\"time\":{\"rules\":[],\"rules_parse_time\":0.6580910682678223,\"profiling_times\":{\"config_time\":1.5664429664611816,\"core_time\":1.0085771083831787,\"ignores_time\":0.0006420612335205078,\"total_time\":2.576148271560669},\"parsing_time\":{\"total_time\":0.0,\"per_file_time\":{\"mean\":0.0,\"std_dev\":0.0},\"very_slow_stats\":{\"time_ratio\":0.0,\"count_ratio\":0.0},\"very_slow_files\":[]},\"scanning_time\":{\"total_time\":0.012295007705688477,\"per_file_time\":{\"mean\":0.004098335901896159,\"std_dev\":1.6983907635727115e-05},\"very_slow_stats\":{\"time_ratio\":0.0,\"count_ratio\":0.0},\"very_slow_files\":[]},\"matching_time\":{\"total_time\":0.0,\"per_file_and_rule_time\":{\"mean\":0.0,\"std_dev\":0.0},\"very_slow_stats\":{\"time_ratio\":0.0,\"count_ratio\":0.0},\"very_slow_rules_on_files\":[]},\"tainting_time\":{\"total_time\":0.0,\"per_def_and_rule_time\":{\"mean\":0.0,\"std_dev\":0.0},\"very_slow_stats\":{\"time_ratio\":0.0,\"count_ratio\":0.0},\"very_slow_rules_on_defs\":[]},\"fixpoint_timeouts\":[],\"prefiltering\":{\"project_level_time\":0.0,\"file_level_time\":0.0,\"rules_with_project_prefilters_ratio\":0.0,\"rules_with_file_prefilters_ratio\":1.0,\"rules_selected_ratio\":0.018867924528301886,\"rules_matched_ratio\":0.018867924528301886},\"targets\":[],\"total_bytes\":0,\"max_memory_bytes\":1102702784},\"engine_requested\":\"OSS\",\"skipped_rules\":[]}\n/Users/bakr/miniforge3/lib/python3.12/site-packages/opentelemetry/instrumentation/dependencies.py:4: UserWarning: pkg_resources is deprecated as an API. See https://setuptools.pypa.io/en/latest/pkg_resources.html. The pkg_resources package is slated for removal as early as 2025-11-30. Refrain from using this package or pin to Setuptools<81.\n  from pkg_resources import (\n               \n               \n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 Scan Status \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n  Scanning 1 file tracked by git with 1062 Code rules:\n                                                                                                                        \n  Language      Rules   Files          Origin      Rules                                                                \n \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500        \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500                                                               \n  <multilang>      48       1          Community    1062                                                                \n  c                 5       1                                                                                           \n                                                                                                                        \n                \n                \n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 Scan Summary \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\u2705 Scan completed successfully.\n \u2022 Findings: 0 (0 blocking)\n \u2022 Rules run: 53\n \u2022 Targets scanned: 1\n \u2022 Parsed lines: <0.1%\n \u2022 No ignore information available\n \u2022 For a detailed list of skipped files and lines, run semgrep with the --verbose flag\nRan 53 rules on 1 file: 0 findings.\n(need more rules? `semgrep login` for additional free Semgrep Registry rules)\n\nIf Semgrep missed a finding, please send us feedback to let us know!\nSee https://semgrep.dev/docs/reporting-false-negatives/\n",
      "error_message": null
    },
    {
      "cve_id": "CVE-2020-14954",
      "tool_name": "Semgrep",
      "detected": true,
      "confidence": 0.8,
      "detection_time": 3.2810566425323486,
      "tool_output": "{\"version\":\"1.134.0\",\"results\":[],\"errors\":[{\"code\":3,\"level\":\"warn\",\"type\":[\"PartialParsing\",[{\"path\":\"/var/folders/ql/btm7z5tx32ddpsky8z3bz4_r0000gn/T/tmpyudtm0me.c\",\"start\":{\"line\":1,\"col\":1,\"offset\":0},\"end\":{\"line\":1,\"col\":67,\"offset\":66}},{\"path\":\"/var/folders/ql/btm7z5tx32ddpsky8z3bz4_r0000gn/T/tmpyudtm0me.c\",\"start\":{\"line\":1,\"col\":2135,\"offset\":0},\"end\":{\"line\":1,\"col\":2136,\"offset\":1}},{\"path\":\"/var/folders/ql/btm7z5tx32ddpsky8z3bz4_r0000gn/T/tmpyudtm0me.c\",\"start\":{\"line\":1,\"col\":2151,\"offset\":0},\"end\":{\"line\":1,\"col\":2154,\"offset\":3}}]],\"message\":\"Syntax error at line /var/folders/ql/btm7z5tx32ddpsky8z3bz4_r0000gn/T/tmpyudtm0me.c:1:\\n `CWE-74 int nntp_open_connection ( struct NntpAccountData * adata )` was unexpected\",\"path\":\"/var/folders/ql/btm7z5tx32ddpsky8z3bz4_r0000gn/T/tmpyudtm0me.c\",\"spans\":[{\"file\":\"/var/folders/ql/btm7z5tx32ddpsky8z3bz4_r0000gn/T/tmpyudtm0me.c\",\"start\":{\"line\":1,\"col\":1,\"offset\":0},\"end\":{\"line\":1,\"col\":67,\"offset\":66}},{\"file\":\"/var/folders/ql/btm7z5tx32ddpsky8z3bz4_r0000gn/T/tmpyudtm0me.c\",\"start\":{\"line\":1,\"col\":2135,\"offset\":0},\"end\":{\"line\":1,\"col\":2136,\"offset\":1}},{\"file\":\"/var/folders/ql/btm7z5tx32ddpsky8z3bz4_r0000gn/T/tmpyudtm0me.c\",\"start\":{\"line\":1,\"col\":2151,\"offset\":0},\"end\":{\"line\":1,\"col\":2154,\"offset\":3}}]}],\"paths\":{\"scanned\":[\"/var/folders/ql/btm7z5tx32ddpsky8z3bz4_r0000gn/T/tmpyudtm0me.c\"]},\"time\":{\"rules\":[],\"rules_parse_time\":0.6473090648651123,\"profiling_times\":{\"config_time\":0.9597251415252686,\"core_time\":0.9354438781738281,\"ignores_time\":0.0005559921264648438,\"total_time\":1.8961658477783203},\"parsing_time\":{\"total_time\":0.0,\"per_file_time\":{\"mean\":0.0,\"std_dev\":0.0},\"very_slow_stats\":{\"time_ratio\":0.0,\"count_ratio\":0.0},\"very_slow_files\":[]},\"scanning_time\":{\"total_time\":0.009153842926025391,\"per_file_time\":{\"mean\":0.003051280975341797,\"std_dev\":1.247682200755662e-05},\"very_slow_stats\":{\"time_ratio\":0.0,\"count_ratio\":0.0},\"very_slow_files\":[]},\"matching_time\":{\"total_time\":0.0,\"per_file_and_rule_time\":{\"mean\":0.0,\"std_dev\":0.0},\"very_slow_stats\":{\"time_ratio\":0.0,\"count_ratio\":0.0},\"very_slow_rules_on_files\":[]},\"tainting_time\":{\"total_time\":0.0,\"per_def_and_rule_time\":{\"mean\":0.0,\"std_dev\":0.0},\"very_slow_stats\":{\"time_ratio\":0.0,\"count_ratio\":0.0},\"very_slow_rules_on_defs\":[]},\"fixpoint_timeouts\":[],\"prefiltering\":{\"project_level_time\":0.0,\"file_level_time\":0.0,\"rules_with_project_prefilters_ratio\":0.0,\"rules_with_file_prefilters_ratio\":1.0,\"rules_selected_ratio\":0.03773584905660377,\"rules_matched_ratio\":0.03773584905660377},\"targets\":[],\"total_bytes\":0,\"max_memory_bytes\":1102440640},\"engine_requested\":\"OSS\",\"skipped_rules\":[]}\n/Users/bakr/miniforge3/lib/python3.12/site-packages/opentelemetry/instrumentation/dependencies.py:4: UserWarning: pkg_resources is deprecated as an API. See https://setuptools.pypa.io/en/latest/pkg_resources.html. The pkg_resources package is slated for removal as early as 2025-11-30. Refrain from using this package or pin to Setuptools<81.\n  from pkg_resources import (\n               \n               \n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 Scan Status \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n  Scanning 1 file tracked by git with 1062 Code rules:\n                                                                                                                        \n  Language      Rules   Files          Origin      Rules                                                                \n \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500        \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500                                                               \n  <multilang>      48       1          Community    1062                                                                \n  c                 5       1                                                                                           \n                                                                                                                        \n                \n                \n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 Scan Summary \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\u2705 Scan completed successfully.\n \u2022 Findings: 0 (0 blocking)\n \u2022 Rules run: 53\n \u2022 Targets scanned: 1\n \u2022 Parsed lines: <0.1%\n \u2022 No ignore information available\n \u2022 For a detailed list of skipped files and lines, run semgrep with the --verbose flag\nRan 53 rules on 1 file: 0 findings.\n(need more rules? `semgrep login` for additional free Semgrep Registry rules)\n\nIf Semgrep missed a finding, please send us feedback to let us know!\nSee https://semgrep.dev/docs/reporting-false-negatives/\n",
      "error_message": null
    },
    {
      "cve_id": "CVE-2020-15474",
      "tool_name": "Semgrep",
      "detected": true,
      "confidence": 0.8,
      "detection_time": 3.383549928665161,
      "tool_output": "{\"version\":\"1.134.0\",\"results\":[],\"errors\":[],\"paths\":{\"scanned\":[\"/var/folders/ql/btm7z5tx32ddpsky8z3bz4_r0000gn/T/tmpwa0ehzcx.c\"]},\"time\":{\"rules\":[],\"rules_parse_time\":0.6394040584564209,\"profiling_times\":{\"config_time\":1.124798059463501,\"core_time\":0.9209580421447754,\"ignores_time\":0.0005700588226318359,\"total_time\":2.046696901321411},\"parsing_time\":{\"total_time\":0.0,\"per_file_time\":{\"mean\":0.0,\"std_dev\":0.0},\"very_slow_stats\":{\"time_ratio\":0.0,\"count_ratio\":0.0},\"very_slow_files\":[]},\"scanning_time\":{\"total_time\":0.0018720626831054688,\"per_file_time\":{\"mean\":0.0006240208943684896,\"std_dev\":3.8401986380954945e-08},\"very_slow_stats\":{\"time_ratio\":0.0,\"count_ratio\":0.0},\"very_slow_files\":[]},\"matching_time\":{\"total_time\":0.0,\"per_file_and_rule_time\":{\"mean\":0.0,\"std_dev\":0.0},\"very_slow_stats\":{\"time_ratio\":0.0,\"count_ratio\":0.0},\"very_slow_rules_on_files\":[]},\"tainting_time\":{\"total_time\":0.0,\"per_def_and_rule_time\":{\"mean\":0.0,\"std_dev\":0.0},\"very_slow_stats\":{\"time_ratio\":0.0,\"count_ratio\":0.0},\"very_slow_rules_on_defs\":[]},\"fixpoint_timeouts\":[],\"prefiltering\":{\"project_level_time\":0.0,\"file_level_time\":0.0,\"rules_with_project_prefilters_ratio\":0.0,\"rules_with_file_prefilters_ratio\":1.0,\"rules_selected_ratio\":0.0,\"rules_matched_ratio\":0.0},\"targets\":[],\"total_bytes\":0,\"max_memory_bytes\":1102702784},\"engine_requested\":\"OSS\",\"skipped_rules\":[]}\n/Users/bakr/miniforge3/lib/python3.12/site-packages/opentelemetry/instrumentation/dependencies.py:4: UserWarning: pkg_resources is deprecated as an API. See https://setuptools.pypa.io/en/latest/pkg_resources.html. The pkg_resources package is slated for removal as early as 2025-11-30. Refrain from using this package or pin to Setuptools<81.\n  from pkg_resources import (\n               \n               \n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 Scan Status \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n  Scanning 1 file tracked by git with 1062 Code rules:\n                                                                                                                        \n  Language      Rules   Files          Origin      Rules                                                                \n \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500        \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500                                                               \n  <multilang>      48       1          Community    1062                                                                \n  c                 5       1                                                                                           \n                                                                                                                        \n                \n                \n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 Scan Summary \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\u2705 Scan completed successfully.\n \u2022 Findings: 0 (0 blocking)\n \u2022 Rules run: 53\n \u2022 Targets scanned: 1\n \u2022 Parsed lines: ~100.0%\n \u2022 No ignore information available\nRan 53 rules on 1 file: 0 findings.\n(need more rules? `semgrep login` for additional free Semgrep Registry rules)\n\nIf Semgrep missed a finding, please send us feedback to let us know!\nSee https://semgrep.dev/docs/reporting-false-negatives/\n",
      "error_message": null
    },
    {
      "cve_id": "CVE-2017-15385",
      "tool_name": "Semgrep",
      "detected": true,
      "confidence": 0.8,
      "detection_time": 3.1598401069641113,
      "tool_output": "{\"version\":\"1.134.0\",\"results\":[],\"errors\":[],\"paths\":{\"scanned\":[\"/var/folders/ql/btm7z5tx32ddpsky8z3bz4_r0000gn/T/tmpdkprm41e.c\"]},\"time\":{\"rules\":[],\"rules_parse_time\":0.7226731777191162,\"profiling_times\":{\"config_time\":1.0712521076202393,\"core_time\":1.000788927078247,\"ignores_time\":0.0005800724029541016,\"total_time\":2.0730419158935547},\"parsing_time\":{\"total_time\":0.0,\"per_file_time\":{\"mean\":0.0,\"std_dev\":0.0},\"very_slow_stats\":{\"time_ratio\":0.0,\"count_ratio\":0.0},\"very_slow_files\":[]},\"scanning_time\":{\"total_time\":0.0015041828155517578,\"per_file_time\":{\"mean\":0.0005013942718505859,\"std_dev\":1.0639079543276845e-08},\"very_slow_stats\":{\"time_ratio\":0.0,\"count_ratio\":0.0},\"very_slow_files\":[]},\"matching_time\":{\"total_time\":0.0,\"per_file_and_rule_time\":{\"mean\":0.0,\"std_dev\":0.0},\"very_slow_stats\":{\"time_ratio\":0.0,\"count_ratio\":0.0},\"very_slow_rules_on_files\":[]},\"tainting_time\":{\"total_time\":0.0,\"per_def_and_rule_time\":{\"mean\":0.0,\"std_dev\":0.0},\"very_slow_stats\":{\"time_ratio\":0.0,\"count_ratio\":0.0},\"very_slow_rules_on_defs\":[]},\"fixpoint_timeouts\":[],\"prefiltering\":{\"project_level_time\":0.0,\"file_level_time\":0.0,\"rules_with_project_prefilters_ratio\":0.0,\"rules_with_file_prefilters_ratio\":1.0,\"rules_selected_ratio\":0.0,\"rules_matched_ratio\":0.0},\"targets\":[],\"total_bytes\":0,\"max_memory_bytes\":1102702784},\"engine_requested\":\"OSS\",\"skipped_rules\":[]}\n/Users/bakr/miniforge3/lib/python3.12/site-packages/opentelemetry/instrumentation/dependencies.py:4: UserWarning: pkg_resources is deprecated as an API. See https://setuptools.pypa.io/en/latest/pkg_resources.html. The pkg_resources package is slated for removal as early as 2025-11-30. Refrain from using this package or pin to Setuptools<81.\n  from pkg_resources import (\n               \n               \n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 Scan Status \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n  Scanning 1 file tracked by git with 1062 Code rules:\n                                                                                                                        \n  Language      Rules   Files          Origin      Rules                                                                \n \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500        \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500                                                               \n  <multilang>      48       1          Community    1062                                                                \n  c                 5       1                                                                                           \n                                                                                                                        \n                \n                \n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 Scan Summary \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\u2705 Scan completed successfully.\n \u2022 Findings: 0 (0 blocking)\n \u2022 Rules run: 53\n \u2022 Targets scanned: 1\n \u2022 Parsed lines: ~100.0%\n \u2022 No ignore information available\nRan 53 rules on 1 file: 0 findings.\n(need more rules? `semgrep login` for additional free Semgrep Registry rules)\n\nIf Semgrep missed a finding, please send us feedback to let us know!\nSee https://semgrep.dev/docs/reporting-false-negatives/\n",
      "error_message": null
    },
    {
      "cve_id": "CVE-2019-19275",
      "tool_name": "Semgrep",
      "detected": true,
      "confidence": 0.8,
      "detection_time": 3.1013612747192383,
      "tool_output": "{\"version\":\"1.134.0\",\"results\":[],\"errors\":[],\"paths\":{\"scanned\":[\"/var/folders/ql/btm7z5tx32ddpsky8z3bz4_r0000gn/T/tmpbyy2s5r2.c\"]},\"time\":{\"rules\":[],\"rules_parse_time\":0.6541600227355957,\"profiling_times\":{\"config_time\":1.0126469135284424,\"core_time\":0.9336540699005127,\"ignores_time\":0.0005538463592529297,\"total_time\":1.9472110271453857},\"parsing_time\":{\"total_time\":0.0,\"per_file_time\":{\"mean\":0.0,\"std_dev\":0.0},\"very_slow_stats\":{\"time_ratio\":0.0,\"count_ratio\":0.0},\"very_slow_files\":[]},\"scanning_time\":{\"total_time\":0.001931905746459961,\"per_file_time\":{\"mean\":0.0006439685821533203,\"std_dev\":1.0838941003991446e-08},\"very_slow_stats\":{\"time_ratio\":0.0,\"count_ratio\":0.0},\"very_slow_files\":[]},\"matching_time\":{\"total_time\":0.0,\"per_file_and_rule_time\":{\"mean\":0.0,\"std_dev\":0.0},\"very_slow_stats\":{\"time_ratio\":0.0,\"count_ratio\":0.0},\"very_slow_rules_on_files\":[]},\"tainting_time\":{\"total_time\":0.0,\"per_def_and_rule_time\":{\"mean\":0.0,\"std_dev\":0.0},\"very_slow_stats\":{\"time_ratio\":0.0,\"count_ratio\":0.0},\"very_slow_rules_on_defs\":[]},\"fixpoint_timeouts\":[],\"prefiltering\":{\"project_level_time\":0.0,\"file_level_time\":0.0,\"rules_with_project_prefilters_ratio\":0.0,\"rules_with_file_prefilters_ratio\":1.0,\"rules_selected_ratio\":0.0,\"rules_matched_ratio\":0.0},\"targets\":[],\"total_bytes\":0,\"max_memory_bytes\":1102702784},\"engine_requested\":\"OSS\",\"skipped_rules\":[]}\n/Users/bakr/miniforge3/lib/python3.12/site-packages/opentelemetry/instrumentation/dependencies.py:4: UserWarning: pkg_resources is deprecated as an API. See https://setuptools.pypa.io/en/latest/pkg_resources.html. The pkg_resources package is slated for removal as early as 2025-11-30. Refrain from using this package or pin to Setuptools<81.\n  from pkg_resources import (\n               \n               \n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 Scan Status \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n  Scanning 1 file tracked by git with 1062 Code rules:\n                                                                                                                        \n  Language      Rules   Files          Origin      Rules                                                                \n \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500        \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500                                                               \n  <multilang>      48       1          Community    1062                                                                \n  c                 5       1                                                                                           \n                                                                                                                        \n                \n                \n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 Scan Summary \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\u2705 Scan completed successfully.\n \u2022 Findings: 0 (0 blocking)\n \u2022 Rules run: 53\n \u2022 Targets scanned: 1\n \u2022 Parsed lines: ~100.0%\n \u2022 No ignore information available\nRan 53 rules on 1 file: 0 findings.\n(need more rules? `semgrep login` for additional free Semgrep Registry rules)\n\nIf Semgrep missed a finding, please send us feedback to let us know!\nSee https://semgrep.dev/docs/reporting-false-negatives/\n",
      "error_message": null
    },
    {
      "cve_id": "CVE-2019-19481",
      "tool_name": "Semgrep",
      "detected": true,
      "confidence": 0.8,
      "detection_time": 3.351656913757324,
      "tool_output": "{\"version\":\"1.134.0\",\"results\":[],\"errors\":[],\"paths\":{\"scanned\":[\"/var/folders/ql/btm7z5tx32ddpsky8z3bz4_r0000gn/T/tmpk7c3aosw.c\"]},\"time\":{\"rules\":[],\"rules_parse_time\":0.6764421463012695,\"profiling_times\":{\"config_time\":1.0883781909942627,\"core_time\":0.9550769329071045,\"ignores_time\":0.0005810260772705078,\"total_time\":2.0443949699401855},\"parsing_time\":{\"total_time\":0.0,\"per_file_time\":{\"mean\":0.0,\"std_dev\":0.0},\"very_slow_stats\":{\"time_ratio\":0.0,\"count_ratio\":0.0},\"very_slow_files\":[]},\"scanning_time\":{\"total_time\":0.0013501644134521484,\"per_file_time\":{\"mean\":0.0004500548044840495,\"std_dev\":5.738393661482e-09},\"very_slow_stats\":{\"time_ratio\":0.0,\"count_ratio\":0.0},\"very_slow_files\":[]},\"matching_time\":{\"total_time\":0.0,\"per_file_and_rule_time\":{\"mean\":0.0,\"std_dev\":0.0},\"very_slow_stats\":{\"time_ratio\":0.0,\"count_ratio\":0.0},\"very_slow_rules_on_files\":[]},\"tainting_time\":{\"total_time\":0.0,\"per_def_and_rule_time\":{\"mean\":0.0,\"std_dev\":0.0},\"very_slow_stats\":{\"time_ratio\":0.0,\"count_ratio\":0.0},\"very_slow_rules_on_defs\":[]},\"fixpoint_timeouts\":[],\"prefiltering\":{\"project_level_time\":0.0,\"file_level_time\":0.0,\"rules_with_project_prefilters_ratio\":0.0,\"rules_with_file_prefilters_ratio\":1.0,\"rules_selected_ratio\":0.0,\"rules_matched_ratio\":0.0},\"targets\":[],\"total_bytes\":0,\"max_memory_bytes\":1102440640},\"engine_requested\":\"OSS\",\"skipped_rules\":[]}\n/Users/bakr/miniforge3/lib/python3.12/site-packages/opentelemetry/instrumentation/dependencies.py:4: UserWarning: pkg_resources is deprecated as an API. See https://setuptools.pypa.io/en/latest/pkg_resources.html. The pkg_resources package is slated for removal as early as 2025-11-30. Refrain from using this package or pin to Setuptools<81.\n  from pkg_resources import (\n               \n               \n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 Scan Status \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n  Scanning 1 file tracked by git with 1062 Code rules:\n                                                                                                                        \n  Language      Rules   Files          Origin      Rules                                                                \n \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500        \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500                                                               \n  <multilang>      48       1          Community    1062                                                                \n  c                 5       1                                                                                           \n                                                                                                                        \n                \n                \n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 Scan Summary \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\u2705 Scan completed successfully.\n \u2022 Findings: 0 (0 blocking)\n \u2022 Rules run: 53\n \u2022 Targets scanned: 1\n \u2022 Parsed lines: ~100.0%\n \u2022 No ignore information available\nRan 53 rules on 1 file: 0 findings.\n(need more rules? `semgrep login` for additional free Semgrep Registry rules)\n\nIf Semgrep missed a finding, please send us feedback to let us know!\nSee https://semgrep.dev/docs/reporting-false-negatives/\n",
      "error_message": null
    },
    {
      "cve_id": "CVE-2019-13308",
      "tool_name": "Semgrep",
      "detected": true,
      "confidence": 0.8,
      "detection_time": 3.1543538570404053,
      "tool_output": "{\"version\":\"1.134.0\",\"results\":[],\"errors\":[],\"paths\":{\"scanned\":[\"/var/folders/ql/btm7z5tx32ddpsky8z3bz4_r0000gn/T/tmpzas_muhk.c\"]},\"time\":{\"rules\":[],\"rules_parse_time\":0.6152298450469971,\"profiling_times\":{\"config_time\":1.1699988842010498,\"core_time\":0.8807251453399658,\"ignores_time\":0.0005481243133544922,\"total_time\":2.0515999794006348},\"parsing_time\":{\"total_time\":0.0,\"per_file_time\":{\"mean\":0.0,\"std_dev\":0.0},\"very_slow_stats\":{\"time_ratio\":0.0,\"count_ratio\":0.0},\"very_slow_files\":[]},\"scanning_time\":{\"total_time\":0.0017201900482177734,\"per_file_time\":{\"mean\":0.0005733966827392578,\"std_dev\":2.2454779961359843e-08},\"very_slow_stats\":{\"time_ratio\":0.0,\"count_ratio\":0.0},\"very_slow_files\":[]},\"matching_time\":{\"total_time\":0.0,\"per_file_and_rule_time\":{\"mean\":0.0,\"std_dev\":0.0},\"very_slow_stats\":{\"time_ratio\":0.0,\"count_ratio\":0.0},\"very_slow_rules_on_files\":[]},\"tainting_time\":{\"total_time\":0.0,\"per_def_and_rule_time\":{\"mean\":0.0,\"std_dev\":0.0},\"very_slow_stats\":{\"time_ratio\":0.0,\"count_ratio\":0.0},\"very_slow_rules_on_defs\":[]},\"fixpoint_timeouts\":[],\"prefiltering\":{\"project_level_time\":0.0,\"file_level_time\":0.0,\"rules_with_project_prefilters_ratio\":0.0,\"rules_with_file_prefilters_ratio\":1.0,\"rules_selected_ratio\":0.0,\"rules_matched_ratio\":0.0},\"targets\":[],\"total_bytes\":0,\"max_memory_bytes\":1102702784},\"engine_requested\":\"OSS\",\"skipped_rules\":[]}\n/Users/bakr/miniforge3/lib/python3.12/site-packages/opentelemetry/instrumentation/dependencies.py:4: UserWarning: pkg_resources is deprecated as an API. See https://setuptools.pypa.io/en/latest/pkg_resources.html. The pkg_resources package is slated for removal as early as 2025-11-30. Refrain from using this package or pin to Setuptools<81.\n  from pkg_resources import (\n               \n               \n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 Scan Status \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n  Scanning 1 file tracked by git with 1062 Code rules:\n                                                                                                                        \n  Language      Rules   Files          Origin      Rules                                                                \n \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500        \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500                                                               \n  <multilang>      48       1          Community    1062                                                                \n  c                 5       1                                                                                           \n                                                                                                                        \n                \n                \n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 Scan Summary \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\u2705 Scan completed successfully.\n \u2022 Findings: 0 (0 blocking)\n \u2022 Rules run: 53\n \u2022 Targets scanned: 1\n \u2022 Parsed lines: ~100.0%\n \u2022 No ignore information available\nRan 53 rules on 1 file: 0 findings.\n(need more rules? `semgrep login` for additional free Semgrep Registry rules)\n\nIf Semgrep missed a finding, please send us feedback to let us know!\nSee https://semgrep.dev/docs/reporting-false-negatives/\n",
      "error_message": null
    },
    {
      "cve_id": "CVE-2018-1999011",
      "tool_name": "Semgrep",
      "detected": true,
      "confidence": 0.8,
      "detection_time": 3.4919512271881104,
      "tool_output": "{\"version\":\"1.134.0\",\"results\":[],\"errors\":[],\"paths\":{\"scanned\":[\"/var/folders/ql/btm7z5tx32ddpsky8z3bz4_r0000gn/T/tmpz0zah4do.c\"]},\"time\":{\"rules\":[],\"rules_parse_time\":0.638441801071167,\"profiling_times\":{\"config_time\":1.3766591548919678,\"core_time\":0.9207079410552979,\"ignores_time\":0.000553131103515625,\"total_time\":2.2983591556549072},\"parsing_time\":{\"total_time\":0.0,\"per_file_time\":{\"mean\":0.0,\"std_dev\":0.0},\"very_slow_stats\":{\"time_ratio\":0.0,\"count_ratio\":0.0},\"very_slow_files\":[]},\"scanning_time\":{\"total_time\":0.0012400150299072266,\"per_file_time\":{\"mean\":0.00041333834330240887,\"std_dev\":2.5382986576813793e-09},\"very_slow_stats\":{\"time_ratio\":0.0,\"count_ratio\":0.0},\"very_slow_files\":[]},\"matching_time\":{\"total_time\":0.0,\"per_file_and_rule_time\":{\"mean\":0.0,\"std_dev\":0.0},\"very_slow_stats\":{\"time_ratio\":0.0,\"count_ratio\":0.0},\"very_slow_rules_on_files\":[]},\"tainting_time\":{\"total_time\":0.0,\"per_def_and_rule_time\":{\"mean\":0.0,\"std_dev\":0.0},\"very_slow_stats\":{\"time_ratio\":0.0,\"count_ratio\":0.0},\"very_slow_rules_on_defs\":[]},\"fixpoint_timeouts\":[],\"prefiltering\":{\"project_level_time\":0.0,\"file_level_time\":0.0,\"rules_with_project_prefilters_ratio\":0.0,\"rules_with_file_prefilters_ratio\":1.0,\"rules_selected_ratio\":0.0,\"rules_matched_ratio\":0.0},\"targets\":[],\"total_bytes\":0,\"max_memory_bytes\":1102440640},\"engine_requested\":\"OSS\",\"skipped_rules\":[]}\n/Users/bakr/miniforge3/lib/python3.12/site-packages/opentelemetry/instrumentation/dependencies.py:4: UserWarning: pkg_resources is deprecated as an API. See https://setuptools.pypa.io/en/latest/pkg_resources.html. The pkg_resources package is slated for removal as early as 2025-11-30. Refrain from using this package or pin to Setuptools<81.\n  from pkg_resources import (\n               \n               \n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 Scan Status \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n  Scanning 1 file tracked by git with 1062 Code rules:\n                                                                                                                        \n  Language      Rules   Files          Origin      Rules                                                                \n \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500        \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500                                                               \n  <multilang>      48       1          Community    1062                                                                \n  c                 5       1                                                                                           \n                                                                                                                        \n                \n                \n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 Scan Summary \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\u2705 Scan completed successfully.\n \u2022 Findings: 0 (0 blocking)\n \u2022 Rules run: 53\n \u2022 Targets scanned: 1\n \u2022 Parsed lines: ~100.0%\n \u2022 No ignore information available\nRan 53 rules on 1 file: 0 findings.\n(need more rules? `semgrep login` for additional free Semgrep Registry rules)\n\nIf Semgrep missed a finding, please send us feedback to let us know!\nSee https://semgrep.dev/docs/reporting-false-negatives/\n",
      "error_message": null
    },
    {
      "cve_id": "CVE-2017-15385",
      "tool_name": "Semgrep",
      "detected": true,
      "confidence": 0.8,
      "detection_time": 3.3060836791992188,
      "tool_output": "{\"version\":\"1.134.0\",\"results\":[],\"errors\":[],\"paths\":{\"scanned\":[\"/var/folders/ql/btm7z5tx32ddpsky8z3bz4_r0000gn/T/tmp0_z06qkl.c\"]},\"time\":{\"rules\":[],\"rules_parse_time\":0.7174179553985596,\"profiling_times\":{\"config_time\":1.0813202857971191,\"core_time\":1.00295090675354,\"ignores_time\":0.0006229877471923828,\"total_time\":2.0853381156921387},\"parsing_time\":{\"total_time\":0.0,\"per_file_time\":{\"mean\":0.0,\"std_dev\":0.0},\"very_slow_stats\":{\"time_ratio\":0.0,\"count_ratio\":0.0},\"very_slow_files\":[]},\"scanning_time\":{\"total_time\":0.001508951187133789,\"per_file_time\":{\"mean\":0.0005029837290445963,\"std_dev\":1.2355649737906383e-08},\"very_slow_stats\":{\"time_ratio\":0.0,\"count_ratio\":0.0},\"very_slow_files\":[]},\"matching_time\":{\"total_time\":0.0,\"per_file_and_rule_time\":{\"mean\":0.0,\"std_dev\":0.0},\"very_slow_stats\":{\"time_ratio\":0.0,\"count_ratio\":0.0},\"very_slow_rules_on_files\":[]},\"tainting_time\":{\"total_time\":0.0,\"per_def_and_rule_time\":{\"mean\":0.0,\"std_dev\":0.0},\"very_slow_stats\":{\"time_ratio\":0.0,\"count_ratio\":0.0},\"very_slow_rules_on_defs\":[]},\"fixpoint_timeouts\":[],\"prefiltering\":{\"project_level_time\":0.0,\"file_level_time\":0.0,\"rules_with_project_prefilters_ratio\":0.0,\"rules_with_file_prefilters_ratio\":1.0,\"rules_selected_ratio\":0.0,\"rules_matched_ratio\":0.0},\"targets\":[],\"total_bytes\":0,\"max_memory_bytes\":1102440640},\"engine_requested\":\"OSS\",\"skipped_rules\":[]}\n/Users/bakr/miniforge3/lib/python3.12/site-packages/opentelemetry/instrumentation/dependencies.py:4: UserWarning: pkg_resources is deprecated as an API. See https://setuptools.pypa.io/en/latest/pkg_resources.html. The pkg_resources package is slated for removal as early as 2025-11-30. Refrain from using this package or pin to Setuptools<81.\n  from pkg_resources import (\n               \n               \n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 Scan Status \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n  Scanning 1 file tracked by git with 1062 Code rules:\n                                                                                                                        \n  Language      Rules   Files          Origin      Rules                                                                \n \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500        \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500                                                               \n  <multilang>      48       1          Community    1062                                                                \n  c                 5       1                                                                                           \n                                                                                                                        \n                \n                \n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 Scan Summary \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\u2705 Scan completed successfully.\n \u2022 Findings: 0 (0 blocking)\n \u2022 Rules run: 53\n \u2022 Targets scanned: 1\n \u2022 Parsed lines: ~100.0%\n \u2022 No ignore information available\nRan 53 rules on 1 file: 0 findings.\n(need more rules? `semgrep login` for additional free Semgrep Registry rules)\n\nIf Semgrep missed a finding, please send us feedback to let us know!\nSee https://semgrep.dev/docs/reporting-false-negatives/\n",
      "error_message": null
    },
    {
      "cve_id": "CVE-2019-19244",
      "tool_name": "Semgrep",
      "detected": true,
      "confidence": 0.8,
      "detection_time": 3.0105159282684326,
      "tool_output": "{\"version\":\"1.134.0\",\"results\":[],\"errors\":[],\"paths\":{\"scanned\":[\"/var/folders/ql/btm7z5tx32ddpsky8z3bz4_r0000gn/T/tmpaaby6vyg.c\"]},\"time\":{\"rules\":[],\"rules_parse_time\":0.6490590572357178,\"profiling_times\":{\"config_time\":0.946523904800415,\"core_time\":0.9381420612335205,\"ignores_time\":0.0005750656127929688,\"total_time\":1.885645866394043},\"parsing_time\":{\"total_time\":0.0,\"per_file_time\":{\"mean\":0.0,\"std_dev\":0.0},\"very_slow_stats\":{\"time_ratio\":0.0,\"count_ratio\":0.0},\"very_slow_files\":[]},\"scanning_time\":{\"total_time\":0.003556489944458008,\"per_file_time\":{\"mean\":0.0011854966481526692,\"std_dev\":2.5845885273964893e-07},\"very_slow_stats\":{\"time_ratio\":0.0,\"count_ratio\":0.0},\"very_slow_files\":[]},\"matching_time\":{\"total_time\":0.0,\"per_file_and_rule_time\":{\"mean\":0.0,\"std_dev\":0.0},\"very_slow_stats\":{\"time_ratio\":0.0,\"count_ratio\":0.0},\"very_slow_rules_on_files\":[]},\"tainting_time\":{\"total_time\":0.0,\"per_def_and_rule_time\":{\"mean\":0.0,\"std_dev\":0.0},\"very_slow_stats\":{\"time_ratio\":0.0,\"count_ratio\":0.0},\"very_slow_rules_on_defs\":[]},\"fixpoint_timeouts\":[],\"prefiltering\":{\"project_level_time\":0.0,\"file_level_time\":0.0,\"rules_with_project_prefilters_ratio\":0.0,\"rules_with_file_prefilters_ratio\":1.0,\"rules_selected_ratio\":0.0,\"rules_matched_ratio\":0.0},\"targets\":[],\"total_bytes\":0,\"max_memory_bytes\":1102702784},\"engine_requested\":\"OSS\",\"skipped_rules\":[]}\n/Users/bakr/miniforge3/lib/python3.12/site-packages/opentelemetry/instrumentation/dependencies.py:4: UserWarning: pkg_resources is deprecated as an API. See https://setuptools.pypa.io/en/latest/pkg_resources.html. The pkg_resources package is slated for removal as early as 2025-11-30. Refrain from using this package or pin to Setuptools<81.\n  from pkg_resources import (\n               \n               \n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 Scan Status \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n  Scanning 1 file tracked by git with 1062 Code rules:\n                                                                                                                        \n  Language      Rules   Files          Origin      Rules                                                                \n \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500        \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500                                                               \n  <multilang>      48       1          Community    1062                                                                \n  c                 5       1                                                                                           \n                                                                                                                        \n                \n                \n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 Scan Summary \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\u2705 Scan completed successfully.\n \u2022 Findings: 0 (0 blocking)\n \u2022 Rules run: 53\n \u2022 Targets scanned: 1\n \u2022 Parsed lines: ~100.0%\n \u2022 No ignore information available\nRan 53 rules on 1 file: 0 findings.\n(need more rules? `semgrep login` for additional free Semgrep Registry rules)\n\nIf Semgrep missed a finding, please send us feedback to let us know!\nSee https://semgrep.dev/docs/reporting-false-negatives/\n",
      "error_message": null
    }
  ]
}