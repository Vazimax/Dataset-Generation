{
  "metadata": {
    "description": "Complete Critical CVE Training Dataset - 363 high-quality, weaponizable CVE samples with ACTUAL code",
    "version": "2.0",
    "created_by": "CVE Dataset Generator (Complete Version)",
    "creation_time": "2025-08-31T15:41:49.192280",
    "total_samples": 363,
    "target_audience": "Vulnerability Detection Model Training and Variant Generation",
    "usage": "Training, validation, testing, and LLM-guided variant generation for CVE detection",
    "important_note": "This dataset contains ACTUAL vulnerable and fixed code samples for variant generation"
  },
  "statistics": {
    "dataset_info": {
      "total_samples": 363,
      "creation_time": "2025-08-31T15:41:49.192282",
      "source": "c-code-samples-selection.json (with actual code)",
      "analysis_file": "c_code_samples_analysis.json"
    },
    "code_statistics": {
      "samples_with_code": 363,
      "average_vulnerable_code_length": 5146.1322314049585,
      "average_fixed_code_length": 280.3636363636364,
      "total_code_volume": 1969818
    },
    "cwe_distribution": {
      "CWE-119": 180,
      "CWE-74": 4,
      "CWE-787": 25,
      "CWE-125": 48,
      "CWE-000": 21,
      "CWE-415": 7,
      "CWE-416": 15,
      "CWE-190": 15,
      "CWE-20": 15,
      "CWE-476": 17,
      "CWE-674": 2,
      "CWE-772": 6,
      "CWE-22": 1,
      "CWE-434": 1,
      "CWE-189": 1,
      "CWE-78": 1,
      "CWE-19": 1,
      "CWE-399": 1,
      "CWE-665": 1,
      "CWE-617": 1
    },
    "project_distribution": {
      "external": 66,
      "neomutt": 6,
      "ntop": 1,
      "radare": 14,
      "python": 12,
      "OpenSC": 9,
      "ImageMagick": 22,
      "FFmpeg": 24,
      "sqlite": 4,
      "torvalds": 87,
      "enferex": 3,
      "curl": 2,
      "openssl": 6,
      "lurcher": 1,
      "glensc": 1,
      "gpac": 5,
      "krb5": 7,
      "TurboVNC": 1,
      "php": 2,
      "libimobiledevice": 1,
      "resiprocate": 1,
      "sctplab": 1,
      "naviserver": 1,
      "rpm-software-management": 2,
      "libarchive": 4,
      "wireshark": 7,
      "OP-TEE": 2,
      "xkbcommon": 1,
      "vadz": 2,
      "z3APA3A": 1,
      "libexif": 2,
      "frameworks": 1,
      "postgres": 1,
      "perl5-dbi": 1,
      "LibVNC": 3,
      "kamailio": 1,
      "accel-ppp": 1,
      "dosfstools": 2,
      "fontforge": 1,
      "kohler": 4,
      "erikd": 3,
      "memcached": 2,
      "sleuthkit": 1,
      "FreeRDP": 7,
      "uclouvain": 5,
      "chromium": 2,
      "mdadams": 3,
      "bonzini": 3,
      "VirusTotal": 3,
      "the-tcpdump-group": 1,
      "mongodb": 2,
      "shadowsocks": 1,
      "tats": 2,
      "hoene": 1,
      "fragglet": 1,
      "FreeRTOS": 1,
      "DanBloomberg": 1,
      "ArtifexSoftware": 1,
      "yoe": 1,
      "git": 2,
      "esnet": 2,
      "openbsd": 1,
      "NagiosEnterprises": 1,
      "miniupnp": 1,
      "jsummers": 1,
      "eclipse": 1
    },
    "severity_distribution": {
      "critical": 363
    },
    "difficulty_distribution": {
      "expert": 94,
      "advanced": 269
    },
    "score_distribution": {
      "perfect_10": 61,
      "high_9": 33,
      "high_8": 141,
      "high_7": 128
    }
  },
  "samples": [
    {
      "cve_id": "CVE-2016-1621",
      "cwe_id": "CWE-119",
      "cwe_name": "Buffer Overflow",
      "project": "external",
      "severity": "critical",
      "weaponization_score": 10.0,
      "is_critical": true,
      "is_weaponizable": true,
      "is_high_priority_project": false,
      "vulnerable_code": "CWE-119 int main ( int argc , char * * argv ) { int frame_cnt = 0 ; FILE * outfile = NULL ; vpx_codec_ctx_t codec ; const VpxInterface * decoder = NULL ; VpxVideoReader * reader = NULL ; const VpxVideoInfo * info = NULL ; int n = 0 ; int m = 0 ; int is_range = 0 ; char * nptr = NULL ; exec_name = argv [ 0 ] ; if ( argc != 4 ) die ( \"Invalid<S2SV_blank>number<S2SV_blank>of<S2SV_blank>arguments.\" ) ; reader = vpx_video_reader_open ( argv [ 1 ] ) ; if ( ! reader ) die ( \"Failed<S2SV_blank>to<S2SV_blank>open<S2SV_blank>%s<S2SV_blank>for<S2SV_blank>reading.\" , argv [ 1 ] ) ; if ( ! ( outfile = fopen ( argv [ 2 ] , \"wb\" ) ) ) die ( \"Failed<S2SV_blank>to<S2SV_blank>open<S2SV_blank>%s<S2SV_blank>for<S2SV_blank>writing.\" , argv [ 2 ] ) ; n = strtol ( argv [ 3 ] , & nptr , 0 ) ; m = strtol ( nptr + 1 , NULL , 0 ) ; is_range = ( * nptr == '-' ) ; if ( ! n || ! m || ( * nptr != '-' && * nptr != '/' ) ) die ( \"Couldn\\'t<S2SV_blank>parse<S2SV_blank>pattern<S2SV_blank>%s.\\\\n\" , argv [ 3 ] ) ; info = vpx_video_reader_get_info ( reader ) ; decoder = get_vpx_decoder_by_fourcc ( info -> codec_fourcc ) ; if ( ! decoder ) die ( \"Unknown<S2SV_blank>input<S2SV_blank>codec.\" ) ; <S2SV_StartBug> printf ( \"Using<S2SV_blank>%s\\\\n\" , vpx_codec_iface_name ( decoder -> interface ( ) ) ) ; <S2SV_EndBug> <S2SV_StartBug> if ( vpx_codec_dec_init ( & codec , decoder -> interface ( ) , NULL , 0 ) ) <S2SV_EndBug> die_codec ( & codec , \"Failed<S2SV_blank>to<S2SV_blank>initialize<S2SV_blank>decoder.\" ) ; while ( vpx_video_reader_read_frame ( reader ) ) { vpx_codec_iter_t iter = NULL ; vpx_image_t * img = NULL ; size_t frame_size = 0 ; int skip ; const unsigned char * frame = vpx_video_reader_get_frame ( reader , & frame_size ) ; if ( vpx_codec_decode ( & codec , frame , ( unsigned int ) frame_size , NULL , 0 ) ) die_codec ( & codec , \"Failed<S2SV_blank>to<S2SV_blank>decode<S2SV_blank>frame.\" ) ; ++ frame_cnt ; skip = ( is_range && frame_cnt >= n && frame_cnt <= m ) || ( ! is_range && m - ( frame_cnt - 1 ) % m <= n ) ; if ( ! skip ) { putc ( '.' , stdout ) ; while ( ( img = vpx_codec_get_frame ( & codec , & iter ) ) != NULL ) vpx_img_write ( img , outfile ) ; } else { putc ( 'X' , stdout ) ; } fflush ( stdout ) ; } printf ( \"Processed<S2SV_blank>%d<S2SV_blank>frames.\\\\n\" , frame_cnt ) ; if ( vpx_codec_destroy ( & codec ) ) die_codec ( & codec , \"Failed<S2SV_blank>to<S2SV_blank>destroy<S2SV_blank>codec.\" ) ; printf ( \"Play:<S2SV_blank>ffplay<S2SV_blank>-f<S2SV_blank>rawvideo<S2SV_blank>-pix_fmt<S2SV_blank>yuv420p<S2SV_blank>-s<S2SV_blank>%dx%d<S2SV_blank>%s\\\\n\" , info -> frame_width , info -> frame_height , argv [ 2 ] ) ; vpx_video_reader_close ( reader ) ; fclose ( outfile ) ; return EXIT_SUCCESS ; }\n",
      "fixed_code": "<S2SV_ModStart> ( decoder -> codec_interface <S2SV_ModEnd> ( ) ) <S2SV_ModStart> , decoder -> codec_interface <S2SV_ModEnd> ( ) ,\n",
      "source_code_length": 2710,
      "target_code_length": 130,
      "vulnerability_patterns": {
        "buffer_overflow": 2,
        "use_after_free": 6,
        "integer_overflow": 23,
        "null_pointer": 146,
        "total": 177
      },
      "total_patterns": 177,
      "original_address": "https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426",
      "discovery_time": "2016-03-12T21:59Z",
      "project_commit_id": "external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426",
      "extraction_time": "2025-08-31T15:41:49.174025",
      "label": 1,
      "vulnerability_type": "buffer_overflow",
      "difficulty_level": "expert",
      "risk_factors": [
        "memory_corruption",
        "arbitrary_code_execution",
        "buffer_overflow",
        "system_crash",
        "use_after_free"
      ],
      "attack_vectors": [
        "memory_manipulation",
        "malicious_input",
        "code_analysis",
        "buffer_overflow",
        "reverse_engineering",
        "fuzzing"
      ],
      "mitigation_strategies": [
        "safe_string_functions",
        "dynamic_analysis",
        "code_review",
        "static_analysis",
        "memory_safety_checks",
        "input_validation",
        "fuzzing",
        "bounds_checking",
        "secure_coding_practices"
      ],
      "code_differences": {
        "has_differences": true,
        "source_lines": 2,
        "target_lines": 2,
        "character_differences": 2580,
        "similarity_percentage": 4.464285714285714
      },
      "vulnerability_location": {
        "vulnerability_present": true,
        "fix_applied": true,
        "code_changed": true,
        "estimated_lines_changed": 0
      }
    },
    {
      "cve_id": "CVE-2020-14954",
      "cwe_id": "CWE-74",
      "cwe_name": "Command Injection",
      "project": "neomutt",
      "severity": "critical",
      "weaponization_score": 10.0,
      "is_critical": true,
      "is_weaponizable": true,
      "is_high_priority_project": true,
      "vulnerable_code": "CWE-74 int nntp_open_connection ( struct NntpAccountData * adata ) { struct Connection * conn = adata -> conn ; char buf [ 256 ] ; int cap ; bool posting = false , auth = true ; if ( adata -> status == NNTP_OK ) return 0 ; if ( adata -> status == NNTP_BYE ) return - 1 ; adata -> status = NNTP_NONE ; if ( mutt_socket_open ( conn ) < 0 ) return - 1 ; if ( mutt_socket_readln ( buf , sizeof ( buf ) , conn ) < 0 ) return nntp_connect_error ( adata ) ; if ( mutt_str_startswith ( buf , \"200\" , CASE_MATCH ) ) posting = true ; else if ( ! mutt_str_startswith ( buf , \"201\" , CASE_MATCH ) ) { mutt_socket_close ( conn ) ; mutt_str_remove_trailing_ws ( buf ) ; mutt_error ( \"%s\" , buf ) ; return - 1 ; } cap = nntp_capabilities ( adata ) ; if ( cap < 0 ) return - 1 ; if ( cap > 0 ) { if ( ( mutt_socket_send ( conn , \"MODE<S2SV_blank>READER\\\\r\\\\n\" ) < 0 ) || ( mutt_socket_readln ( buf , sizeof ( buf ) , conn ) < 0 ) ) { return nntp_connect_error ( adata ) ; } if ( mutt_str_startswith ( buf , \"200\" , CASE_MATCH ) ) posting = true ; else if ( mutt_str_startswith ( buf , \"201\" , CASE_MATCH ) ) posting = false ; else if ( adata -> hasCAPABILITIES ) { mutt_socket_close ( conn ) ; mutt_error ( _ ( \"Could<S2SV_blank>not<S2SV_blank>switch<S2SV_blank>to<S2SV_blank>reader<S2SV_blank>mode\" ) ) ; return - 1 ; } if ( adata -> hasCAPABILITIES ) { cap = nntp_capabilities ( adata ) ; if ( cap < 0 ) return - 1 ; } } mutt_message ( _ ( \"Connected<S2SV_blank>to<S2SV_blank>%s.<S2SV_blank>%s\" ) , conn -> account . host , posting ? _ ( \"Posting<S2SV_blank>is<S2SV_blank>ok\" ) : _ ( \"Posting<S2SV_blank>is<S2SV_blank>NOT<S2SV_blank>ok\" ) ) ; mutt_sleep ( 1 ) ; # ifdef USE_SSL if ( ( adata -> use_tls != 1 ) && ( adata -> hasSTARTTLS || C_SslForceTls ) ) { if ( adata -> use_tls == 0 ) { adata -> use_tls = C_SslForceTls || query_quadoption ( C_SslStarttls , _ ( \"Secure<S2SV_blank>connection<S2SV_blank>with<S2SV_blank>TLS?\" ) ) == MUTT_YES ? 2 : 1 ; } if ( adata -> use_tls == 2 ) { if ( ( mutt_socket_send ( conn , \"STARTTLS\\\\r\\\\n\" ) < 0 ) || ( mutt_socket_readln ( buf , sizeof ( buf ) , conn ) < 0 ) ) { return nntp_connect_error ( adata ) ; <S2SV_StartBug> } <S2SV_EndBug> if ( ! mutt_str_startswith ( buf , \"382\" , CASE_MATCH ) ) { adata -> use_tls = 0 ; mutt_error ( \"STARTTLS:<S2SV_blank>%s\" , buf ) ; } else if ( mutt_ssl_starttls ( conn ) ) { adata -> use_tls = 0 ; adata -> status = NNTP_NONE ; mutt_socket_close ( adata -> conn ) ; mutt_error ( _ ( \"Could<S2SV_blank>not<S2SV_blank>negotiate<S2SV_blank>TLS<S2SV_blank>connection\" ) ) ; return - 1 ; } else { cap = nntp_capabilities ( adata ) ; if ( cap < 0 ) return - 1 ; } } } # endif if ( conn -> account . flags & MUTT_ACCT_USER ) { if ( ! conn -> account . user [ 0 ] ) auth = false ; } else { if ( ( mutt_socket_send ( conn , \"STAT\\\\r\\\\n\" ) < 0 ) || ( mutt_socket_readln ( buf , sizeof ( buf ) , conn ) < 0 ) ) { return nntp_connect_error ( adata ) ; } if ( ! mutt_str_startswith ( buf , \"480\" , CASE_MATCH ) ) auth = false ; } if ( auth && ( nntp_auth ( adata ) < 0 ) ) return - 1 ; if ( adata -> hasCAPABILITIES && ( auth || ( cap > 0 ) ) ) { cap = nntp_capabilities ( adata ) ; if ( cap < 0 ) return - 1 ; if ( cap > 0 ) { mutt_socket_close ( conn ) ; mutt_error ( _ ( \"Could<S2SV_blank>not<S2SV_blank>switch<S2SV_blank>to<S2SV_blank>reader<S2SV_blank>mode\" ) ) ; return - 1 ; } } if ( nntp_attempt_features ( adata ) < 0 ) return - 1 ; adata -> status = NNTP_OK ; return 0 ; }\n",
      "fixed_code": "<S2SV_ModStart> ) ; } mutt_socket_empty ( conn ) ;\n",
      "source_code_length": 3436,
      "target_code_length": 51,
      "vulnerability_patterns": {
        "null_pointer": 20,
        "total": 20
      },
      "total_patterns": 20,
      "original_address": "https://github.com/neomutt/neomutt/commit/fb013ec666759cb8a9e294347c7b4c1f597639cc",
      "discovery_time": "2020-06-21T17:15Z",
      "project_commit_id": "neomutt@neomutt/fb013ec666759cb8a9e294347c7b4c1f597639cc",
      "extraction_time": "2025-08-31T15:41:49.174087",
      "label": 1,
      "vulnerability_type": "command_injection",
      "difficulty_level": "expert",
      "risk_factors": [
        "command_injection",
        "arbitrary_code_execution",
        "critical_infrastructure",
        "remote_code_execution"
      ],
      "attack_vectors": [
        "command_injection",
        "system_commands",
        "code_analysis",
        "reverse_engineering",
        "fuzzing",
        "user_input"
      ],
      "mitigation_strategies": [
        "fuzzing",
        "dynamic_analysis",
        "command_whitelisting",
        "static_analysis",
        "secure_coding_practices",
        "privilege_separation",
        "input_sanitization",
        "code_review",
        "input_validation"
      ],
      "code_differences": {
        "has_differences": true,
        "source_lines": 2,
        "target_lines": 2,
        "character_differences": 3385,
        "similarity_percentage": 4.901960784313726
      },
      "vulnerability_location": {
        "vulnerability_present": true,
        "fix_applied": true,
        "code_changed": true,
        "estimated_lines_changed": 0
      }
    },
    {
      "cve_id": "CVE-2020-15474",
      "cwe_id": "CWE-787",
      "cwe_name": "Out-of-bounds Write",
      "project": "ntop",
      "severity": "critical",
      "weaponization_score": 10.0,
      "is_critical": true,
      "is_weaponizable": true,
      "is_high_priority_project": false,
      "vulnerable_code": "CWE-787 static void processCertificateElements ( struct ndpi_detection_module_struct * ndpi_struct , struct ndpi_flow_struct * flow , u_int16_t p_offset , u_int16_t certificate_len ) { struct ndpi_packet_struct * packet = & flow -> packet ; u_int num_found = 0 , i ; <S2SV_StartBug> char buffer [ 64 ] = { '\\\\0' } , rdnSeqBuf [ 1024 ] = { '\\\\0' } ; <S2SV_EndBug> u_int rdn_len = 0 ; # ifdef DEBUG_TLS printf ( \"[TLS]<S2SV_blank>%s()<S2SV_blank>[offset:<S2SV_blank>%u][certificate_len:<S2SV_blank>%u]\\\\n\" , __FUNCTION__ , p_offset , certificate_len ) ; # endif for ( i = p_offset ; i < certificate_len ; i ++ ) { if ( ( packet -> payload [ i ] == 0x55 ) && ( packet -> payload [ i + 1 ] == 0x04 ) && ( packet -> payload [ i + 2 ] == 0x03 ) ) { int rc = extractRDNSequence ( packet , i , buffer , sizeof ( buffer ) , rdnSeqBuf , & rdn_len , sizeof ( rdnSeqBuf ) , \"CN\" ) ; if ( rc == - 1 ) break ; # ifdef DEBUG_TLS printf ( \"[TLS]<S2SV_blank>%s()<S2SV_blank>[%s][%s:<S2SV_blank>%s]\\\\n\" , __FUNCTION__ , ( num_found == 0 ) ? \"Subject\" : \"Issuer\" , \"Common<S2SV_blank>Name\" , buffer ) ; # endif } else if ( ( packet -> payload [ i ] == 0x55 ) && ( packet -> payload [ i + 1 ] == 0x04 ) && ( packet -> payload [ i + 2 ] == 0x06 ) ) { int rc = extractRDNSequence ( packet , i , buffer , sizeof ( buffer ) , rdnSeqBuf , & rdn_len , sizeof ( rdnSeqBuf ) , \"C\" ) ; if ( rc == - 1 ) break ; # ifdef DEBUG_TLS printf ( \"[TLS]<S2SV_blank>%s()<S2SV_blank>[%s][%s:<S2SV_blank>%s]\\\\n\" , __FUNCTION__ , ( num_found == 0 ) ? \"Subject\" : \"Issuer\" , \"Country\" , buffer ) ; # endif } else if ( ( packet -> payload [ i ] == 0x55 ) && ( packet -> payload [ i + 1 ] == 0x04 ) && ( packet -> payload [ i + 2 ] == 0x07 ) ) { int rc = extractRDNSequence ( packet , i , buffer , sizeof ( buffer ) , rdnSeqBuf , & rdn_len , sizeof ( rdnSeqBuf ) , \"L\" ) ; if ( rc == - 1 ) break ; # ifdef DEBUG_TLS printf ( \"[TLS]<S2SV_blank>%s()<S2SV_blank>[%s][%s:<S2SV_blank>%s]\\\\n\" , __FUNCTION__ , ( num_found == 0 ) ? \"Subject\" : \"Issuer\" , \"Locality\" , buffer ) ; # endif } else if ( ( packet -> payload [ i ] == 0x55 ) && ( packet -> payload [ i + 1 ] == 0x04 ) && ( packet -> payload [ i + 2 ] == 0x08 ) ) { int rc = extractRDNSequence ( packet , i , buffer , sizeof ( buffer ) , rdnSeqBuf , & rdn_len , sizeof ( rdnSeqBuf ) , \"ST\" ) ; if ( rc == - 1 ) break ; # ifdef DEBUG_TLS printf ( \"[TLS]<S2SV_blank>%s()<S2SV_blank>[%s][%s:<S2SV_blank>%s]\\\\n\" , __FUNCTION__ , ( num_found == 0 ) ? \"Subject\" : \"Issuer\" , \"State<S2SV_blank>or<S2SV_blank>Province\" , buffer ) ; # endif } else if ( ( packet -> payload [ i ] == 0x55 ) && ( packet -> payload [ i + 1 ] == 0x04 ) && ( packet -> payload [ i + 2 ] == 0x0a ) ) { int rc = extractRDNSequence ( packet , i , buffer , sizeof ( buffer ) , rdnSeqBuf , & rdn_len , sizeof ( rdnSeqBuf ) , \"O\" ) ; if ( rc == - 1 ) break ; # ifdef DEBUG_TLS printf ( \"[TLS]<S2SV_blank>%s()<S2SV_blank>[%s][%s:<S2SV_blank>%s]\\\\n\" , __FUNCTION__ , ( num_found == 0 ) ? \"Subject\" : \"Issuer\" , \"Organization<S2SV_blank>Name\" , buffer ) ; # endif } else if ( ( packet -> payload [ i ] == 0x55 ) && ( packet -> payload [ i + 1 ] == 0x04 ) && ( packet -> payload [ i + 2 ] == 0x0b ) ) { int rc = extractRDNSequence ( packet , i , buffer , sizeof ( buffer ) , rdnSeqBuf , & rdn_len , sizeof ( rdnSeqBuf ) , \"OU\" ) ; if ( rc == - 1 ) break ; # ifdef DEBUG_TLS printf ( \"[TLS]<S2SV_blank>%s()<S2SV_blank>[%s][%s:<S2SV_blank>%s]\\\\n\" , __FUNCTION__ , ( num_found == 0 ) ? \"Subject\" : \"Issuer\" , \"Organization<S2SV_blank>Unit\" , buffer ) ; # endif } else if ( ( packet -> payload [ i ] == 0x30 ) && ( packet -> payload [ i + 1 ] == 0x1e ) && ( packet -> payload [ i + 2 ] == 0x17 ) ) { u_int8_t len = packet -> payload [ i + 3 ] ; u_int offset = i + 4 ; if ( num_found == 0 ) { num_found ++ ; # ifdef DEBUG_TLS printf ( \"[TLS]<S2SV_blank>%s()<S2SV_blank>IssuerDN<S2SV_blank>[%s]\\\\n\" , __FUNCTION__ , rdnSeqBuf ) ; # endif if ( rdn_len ) flow -> protos . stun_ssl . ssl . issuerDN = ndpi_strdup ( rdnSeqBuf ) ; rdn_len = 0 ; } if ( ( offset + len ) < packet -> payload_packet_len ) { char utcDate [ 32 ] ; # ifdef DEBUG_TLS u_int j ; printf ( \"[CERTIFICATE]<S2SV_blank>notBefore<S2SV_blank>[len:<S2SV_blank>%u][\" , len ) ; for ( j = 0 ; j < len ; j ++ ) printf ( \"%c\" , packet -> payload [ i + 4 + j ] ) ; printf ( \"]\\\\n\" ) ; # endif if ( len < ( sizeof ( utcDate ) - 1 ) ) { struct tm utc ; utc . tm_isdst = - 1 ; strncpy ( utcDate , ( const char * ) & packet -> payload [ i + 4 ] , len ) ; utcDate [ len ] = '\\\\0' ; if ( strptime ( utcDate , \"%y%m%d%H%M%SZ\" , & utc ) != NULL ) { flow -> protos . stun_ssl . ssl . notBefore = timegm ( & utc ) ; # ifdef DEBUG_TLS printf ( \"[CERTIFICATE]<S2SV_blank>notBefore<S2SV_blank>%u<S2SV_blank>[%s]\\\\n\" , flow -> protos . stun_ssl . ssl . notBefore , utcDate ) ; # endif } } offset += len ; if ( ( offset + 1 ) < packet -> payload_packet_len ) { len = packet -> payload [ offset + 1 ] ; offset += 2 ; if ( ( offset + len ) < packet -> payload_packet_len ) { u_int32_t time_sec = flow -> packet . current_time_ms / 1000 ; # ifdef DEBUG_TLS u_int j ; printf ( \"[CERTIFICATE]<S2SV_blank>notAfter<S2SV_blank>[len:<S2SV_blank>%u][\" , len ) ; for ( j = 0 ; j < len ; j ++ ) printf ( \"%c\" , packet -> payload [ offset + j ] ) ; printf ( \"]\\\\n\" ) ; # endif if ( len < ( sizeof ( utcDate ) - 1 ) ) { struct tm utc ; utc . tm_isdst = - 1 ; strncpy ( utcDate , ( const char * ) & packet -> payload [ offset ] , len ) ; utcDate [ len ] = '\\\\0' ; if ( strptime ( utcDate , \"%y%m%d%H%M%SZ\" , & utc ) != NULL ) { flow -> protos . stun_ssl . ssl . notAfter = timegm ( & utc ) ; # ifdef DEBUG_TLS printf ( \"[CERTIFICATE]<S2SV_blank>notAfter<S2SV_blank>%u<S2SV_blank>[%s]\\\\n\" , flow -> protos . stun_ssl . ssl . notAfter , utcDate ) ; # endif } } if ( ( time_sec < flow -> protos . stun_ssl . ssl . notBefore ) || ( time_sec > flow -> protos . stun_ssl . ssl . notAfter ) ) NDPI_SET_BIT ( flow -> risk , NDPI_TLS_CERTIFICATE_EXPIRED ) ; } } } } else if ( ( packet -> payload [ i ] == 0x55 ) && ( packet -> payload [ i + 1 ] == 0x1d ) && ( packet -> payload [ i + 2 ] == 0x11 ) ) { u_int8_t matched_name = 0 ; # ifdef DEBUG_TLS printf ( \"*******<S2SV_blank>[TLS]<S2SV_blank>Found<S2SV_blank>subjectAltName\\\\n\" ) ; # endif i += 3 ; i ++ ; if ( i < packet -> payload_packet_len ) { i += ( packet -> payload [ i ] & 0x80 ) ? ( packet -> payload [ i ] & 0x7F ) : 0 ; if ( i < packet -> payload_packet_len ) { i += 2 ; if ( i < packet -> payload_packet_len ) { i += ( packet -> payload [ i ] & 0x80 ) ? ( packet -> payload [ i ] & 0x7F ) : 0 ; i ++ ; while ( i < packet -> payload_packet_len ) { if ( packet -> payload [ i ] == 0x82 ) { if ( ( i < ( packet -> payload_packet_len - 1 ) ) && ( ( i + packet -> payload [ i + 1 ] + 2 ) < packet -> payload_packet_len ) ) { u_int8_t len = packet -> payload [ i + 1 ] ; char dNSName [ 256 ] ; i += 2 ; if ( len == 0 ) break ; strncpy ( dNSName , ( const char * ) & packet -> payload [ i ] , len ) ; dNSName [ len ] = '\\\\0' ; cleanupServerName ( dNSName , len ) ; # if DEBUG_TLS printf ( \"[TLS]<S2SV_blank>dNSName<S2SV_blank>%s<S2SV_blank>[%s]\\\\n\" , dNSName , flow -> protos . stun_ssl . ssl . client_requested_server_name ) ; # endif if ( matched_name == 0 ) { if ( ( dNSName [ 0 ] == '*' ) && strstr ( flow -> protos . stun_ssl . ssl . client_requested_server_name , & dNSName [ 1 ] ) ) matched_name = 1 ; else if ( strcmp ( flow -> protos . stun_ssl . ssl . client_requested_server_name , dNSName ) == 0 ) matched_name = 1 ; } if ( flow -> protos . stun_ssl . ssl . server_names == NULL ) flow -> protos . stun_ssl . ssl . server_names = ndpi_strdup ( dNSName ) , flow -> protos . stun_ssl . ssl . server_names_len = strlen ( dNSName ) ; else { u_int16_t dNSName_len = strlen ( dNSName ) ; u_int16_t newstr_len = flow -> protos . stun_ssl . ssl . server_names_len + dNSName_len + 1 ; char * newstr = ( char * ) ndpi_realloc ( flow -> protos . stun_ssl . ssl . server_names , flow -> protos . stun_ssl . ssl . server_names_len + 1 , newstr_len + 1 ) ; if ( newstr ) { flow -> protos . stun_ssl . ssl . server_names = newstr ; flow -> protos . stun_ssl . ssl . server_names [ flow -> protos . stun_ssl . ssl . server_names_len ] = ',' ; strncpy ( & flow -> protos . stun_ssl . ssl . server_names [ flow -> protos . stun_ssl . ssl . server_names_len + 1 ] , dNSName , dNSName_len + 1 ) ; flow -> protos . stun_ssl . ssl . server_names [ newstr_len ] = '\\\\0' ; flow -> protos . stun_ssl . ssl . server_names_len = newstr_len ; } } if ( ! flow -> l4 . tcp . tls . subprotocol_detected ) if ( ndpi_match_hostname_protocol ( ndpi_struct , flow , NDPI_PROTOCOL_TLS , dNSName , len ) ) flow -> l4 . tcp . tls . subprotocol_detected = 1 ; i += len ; } else { # if DEBUG_TLS printf ( \"[TLS]<S2SV_blank>Leftover<S2SV_blank>%u<S2SV_blank>bytes\" , packet -> payload_packet_len - i ) ; # endif break ; } } else { break ; } } if ( ! matched_name ) NDPI_SET_BIT ( flow -> risk , NDPI_TLS_CERTIFICATE_MISMATCH ) ; } } } } } if ( rdn_len ) flow -> protos . stun_ssl . ssl . subjectDN = ndpi_strdup ( rdnSeqBuf ) ; if ( flow -> protos . stun_ssl . ssl . subjectDN && flow -> protos . stun_ssl . ssl . issuerDN && ( ! strcmp ( flow -> protos . stun_ssl . ssl . subjectDN , flow -> protos . stun_ssl . ssl . issuerDN ) ) ) NDPI_SET_BIT ( flow -> risk , NDPI_TLS_SELFSIGNED_CERTIFICATE ) ; # if DEBUG_TLS printf ( \"[TLS]<S2SV_blank>%s()<S2SV_blank>SubjectDN<S2SV_blank>[%s]\\\\n\" , __FUNCTION__ , rdnSeqBuf ) ; # endif }\n",
      "fixed_code": "<S2SV_ModStart> , rdnSeqBuf [ 2048 <S2SV_ModEnd> ] = {\n",
      "source_code_length": 9434,
      "target_code_length": 55,
      "vulnerability_patterns": {
        "buffer_overflow": 4,
        "use_after_free": 7,
        "integer_overflow": 14,
        "format_string": 20,
        "null_pointer": 85,
        "total": 130
      },
      "total_patterns": 130,
      "original_address": "https://github.com/ntop/nDPI/commit/23594f036536468072198a57c59b6e9d63caf6ce",
      "discovery_time": "2020-07-01T11:15Z",
      "project_commit_id": "ntop@nDPI/23594f036536468072198a57c59b6e9d63caf6ce",
      "extraction_time": "2025-08-31T15:41:49.174132",
      "label": 1,
      "vulnerability_type": "out-of-bounds_write",
      "difficulty_level": "expert",
      "risk_factors": [
        "memory_corruption",
        "arbitrary_code_execution",
        "buffer_overflow",
        "system_crash",
        "use_after_free"
      ],
      "attack_vectors": [
        "memory_manipulation",
        "malicious_input",
        "code_analysis",
        "buffer_overflow",
        "reverse_engineering",
        "fuzzing"
      ],
      "mitigation_strategies": [
        "safe_string_functions",
        "dynamic_analysis",
        "code_review",
        "static_analysis",
        "memory_safety_checks",
        "input_validation",
        "fuzzing",
        "bounds_checking",
        "secure_coding_practices"
      ],
      "code_differences": {
        "has_differences": true,
        "source_lines": 2,
        "target_lines": 2,
        "character_differences": 9379,
        "similarity_percentage": 3.428571428571429
      },
      "vulnerability_location": {
        "vulnerability_present": true,
        "fix_applied": true,
        "code_changed": true,
        "estimated_lines_changed": 0
      }
    },
    {
      "cve_id": "CVE-2017-15385",
      "cwe_id": "CWE-119",
      "cwe_name": "Buffer Overflow",
      "project": "radare",
      "severity": "critical",
      "weaponization_score": 10.0,
      "is_critical": true,
      "is_weaponizable": true,
      "is_high_priority_project": true,
      "vulnerable_code": "CWE-119 static Sdb * store_versioninfo_gnu_verdef ( ELFOBJ * bin , Elf_ ( Shdr ) * shdr , int sz ) { const char * section_name = \"\" ; const char * link_section_name = \"\" ; char * end = NULL ; Elf_ ( Shdr ) * link_shdr = NULL ; ut8 dfs [ sizeof ( Elf_ ( Verdef ) ) ] = { 0 } ; Sdb * sdb ; int cnt , i ; if ( shdr -> sh_link > bin -> ehdr . e_shnum ) { return false ; } link_shdr = & bin -> shdr [ shdr -> sh_link ] ; if ( shdr -> sh_size < 1 ) { return false ; } Elf_ ( Verdef ) * defs = calloc ( shdr -> sh_size , sizeof ( char ) ) ; if ( ! defs ) { return false ; } if ( bin -> shstrtab && shdr -> sh_name < bin -> shstrtab_size ) { section_name = & bin -> shstrtab [ shdr -> sh_name ] ; } if ( link_shdr && bin -> shstrtab && link_shdr -> sh_name < bin -> shstrtab_size ) { link_section_name = & bin -> shstrtab [ link_shdr -> sh_name ] ; } if ( ! defs ) { bprintf ( \"Warning:<S2SV_blank>Cannot<S2SV_blank>allocate<S2SV_blank>memory<S2SV_blank>(Check<S2SV_blank>Elf_(Verdef))\\\\n\" ) ; return NULL ; } sdb = sdb_new0 ( ) ; end = ( char * ) defs + shdr -> sh_size ; sdb_set ( sdb , \"section_name\" , section_name , 0 ) ; sdb_num_set ( sdb , \"entries\" , shdr -> sh_info , 0 ) ; sdb_num_set ( sdb , \"addr\" , shdr -> sh_addr , 0 ) ; sdb_num_set ( sdb , \"offset\" , shdr -> sh_offset , 0 ) ; sdb_num_set ( sdb , \"link\" , shdr -> sh_link , 0 ) ; sdb_set ( sdb , \"link_section_name\" , link_section_name , 0 ) ; <S2SV_StartBug> for ( cnt = 0 , i = 0 ; cnt < shdr -> sh_info && ( ( char * ) defs + i < end ) ; ++ cnt ) { <S2SV_EndBug> Sdb * sdb_verdef = sdb_new0 ( ) ; char * vstart = ( ( char * ) defs ) + i ; char key [ 32 ] = { 0 } ; Elf_ ( Verdef ) * verdef = ( Elf_ ( Verdef ) * ) vstart ; Elf_ ( Verdaux ) aux = { 0 } ; int j = 0 ; int isum = 0 ; r_buf_read_at ( bin -> b , shdr -> sh_offset + i , dfs , sizeof ( Elf_ ( Verdef ) ) ) ; verdef -> vd_version = READ16 ( dfs , j ) verdef -> vd_flags = READ16 ( dfs , j ) verdef -> vd_ndx = READ16 ( dfs , j ) verdef -> vd_cnt = READ16 ( dfs , j ) verdef -> vd_hash = READ32 ( dfs , j ) verdef -> vd_aux = READ32 ( dfs , j ) verdef -> vd_next = READ32 ( dfs , j ) vstart += verdef -> vd_aux ; if ( vstart > end || vstart + sizeof ( Elf_ ( Verdaux ) ) > end ) { sdb_free ( sdb_verdef ) ; goto out_error ; } j = 0 ; aux . vda_name = READ32 ( vstart , j ) aux . vda_next = READ32 ( vstart , j ) isum = i + verdef -> vd_aux ; if ( aux . vda_name > bin -> dynstr_size ) { sdb_free ( sdb_verdef ) ; goto out_error ; } sdb_num_set ( sdb_verdef , \"idx\" , i , 0 ) ; sdb_num_set ( sdb_verdef , \"vd_version\" , verdef -> vd_version , 0 ) ; sdb_num_set ( sdb_verdef , \"vd_ndx\" , verdef -> vd_ndx , 0 ) ; sdb_num_set ( sdb_verdef , \"vd_cnt\" , verdef -> vd_cnt , 0 ) ; sdb_set ( sdb_verdef , \"vda_name\" , & bin -> dynstr [ aux . vda_name ] , 0 ) ; sdb_set ( sdb_verdef , \"flags\" , get_ver_flags ( verdef -> vd_flags ) , 0 ) ; for ( j = 1 ; j < verdef -> vd_cnt ; ++ j ) { int k ; Sdb * sdb_parent = sdb_new0 ( ) ; isum += aux . vda_next ; vstart += aux . vda_next ; if ( vstart > end || vstart + sizeof ( Elf_ ( Verdaux ) ) > end ) { sdb_free ( sdb_verdef ) ; sdb_free ( sdb_parent ) ; goto out_error ; } k = 0 ; aux . vda_name = READ32 ( vstart , k ) aux . vda_next = READ32 ( vstart , k ) if ( aux . vda_name > bin -> dynstr_size ) { sdb_free ( sdb_verdef ) ; sdb_free ( sdb_parent ) ; goto out_error ; } sdb_num_set ( sdb_parent , \"idx\" , isum , 0 ) ; sdb_num_set ( sdb_parent , \"parent\" , j , 0 ) ; sdb_set ( sdb_parent , \"vda_name\" , & bin -> dynstr [ aux . vda_name ] , 0 ) ; snprintf ( key , sizeof ( key ) , \"parent%d\" , j - 1 ) ; sdb_ns_set ( sdb_verdef , key , sdb_parent ) ; } snprintf ( key , sizeof ( key ) , \"verdef%d\" , cnt ) ; sdb_ns_set ( sdb , key , sdb_verdef ) ; if ( ! verdef -> vd_next ) { sdb_free ( sdb_verdef ) ; goto out_error ; } <S2SV_StartBug> i += verdef -> vd_next ; <S2SV_EndBug> } free ( defs ) ; return sdb ; out_error : free ( defs ) ; sdb_free ( sdb ) ; return NULL ; }\n",
      "fixed_code": "<S2SV_ModStart> = 0 ; i >= 0 && <S2SV_ModStart> out_error ; } if ( ( st32 ) verdef -> vd_next < 1 ) { eprintf ( \"Warning:<S2SV_blank>Invalid<S2SV_blank>vd_next<S2SV_blank>in<S2SV_blank>the<S2SV_blank>ELF<S2SV_blank>version\\\\n\" ) ; break ; }\n",
      "source_code_length": 3931,
      "target_code_length": 241,
      "vulnerability_patterns": {
        "use_after_free": 3,
        "integer_overflow": 6,
        "format_string": 2,
        "null_pointer": 48,
        "memory_leak": 1,
        "total": 60
      },
      "total_patterns": 60,
      "original_address": "https://github.com/radare/radare2/commit/21a6f570ba33fa9f52f1bba87f07acc4e8c178f4",
      "discovery_time": "2017-10-16T22:29Z",
      "project_commit_id": "radare@radare2/21a6f570ba33fa9f52f1bba87f07acc4e8c178f4",
      "extraction_time": "2025-08-31T15:41:49.174215",
      "label": 1,
      "vulnerability_type": "buffer_overflow",
      "difficulty_level": "expert",
      "risk_factors": [
        "memory_corruption",
        "critical_infrastructure",
        "arbitrary_code_execution",
        "system_crash",
        "use_after_free"
      ],
      "attack_vectors": [
        "memory_manipulation",
        "malicious_input",
        "code_analysis",
        "buffer_overflow",
        "reverse_engineering",
        "fuzzing"
      ],
      "mitigation_strategies": [
        "safe_string_functions",
        "dynamic_analysis",
        "code_review",
        "static_analysis",
        "memory_safety_checks",
        "input_validation",
        "fuzzing",
        "bounds_checking",
        "secure_coding_practices"
      ],
      "code_differences": {
        "has_differences": true,
        "source_lines": 2,
        "target_lines": 2,
        "character_differences": 3690,
        "similarity_percentage": 12.5
      },
      "vulnerability_location": {
        "vulnerability_present": true,
        "fix_applied": true,
        "code_changed": true,
        "estimated_lines_changed": 0
      }
    },
    {
      "cve_id": "CVE-2019-19275",
      "cwe_id": "CWE-125",
      "cwe_name": "Out-of-bounds Read",
      "project": "python",
      "severity": "critical",
      "weaponization_score": 10.0,
      "is_critical": true,
      "is_weaponizable": true,
      "is_high_priority_project": true,
      "vulnerable_code": "CWE-125 static arguments_ty ast_for_arguments ( struct compiling * c , const node * n ) { int i , j , k , nposargs = 0 , nkwonlyargs = 0 ; int nposdefaults = 0 , found_default = 0 ; asdl_seq * posargs , * posdefaults , * kwonlyargs , * kwdefaults ; arg_ty vararg = NULL , kwarg = NULL ; arg_ty arg ; node * ch ; if ( TYPE ( n ) == parameters ) { if ( NCH ( n ) == 2 ) return arguments ( NULL , NULL , NULL , NULL , NULL , NULL , c -> c_arena ) ; n = CHILD ( n , 1 ) ; } assert ( TYPE ( n ) == typedargslist || TYPE ( n ) == varargslist ) ; for ( i = 0 ; i < NCH ( n ) ; i ++ ) { ch = CHILD ( n , i ) ; if ( TYPE ( ch ) == STAR ) { i ++ ; if ( i < NCH ( n ) && ( TYPE ( CHILD ( n , i ) ) == tfpdef || TYPE ( CHILD ( n , i ) ) == vfpdef ) ) { i ++ ; } break ; } if ( TYPE ( ch ) == DOUBLESTAR ) break ; if ( TYPE ( ch ) == vfpdef || TYPE ( ch ) == tfpdef ) nposargs ++ ; if ( TYPE ( ch ) == EQUAL ) nposdefaults ++ ; } for ( ; i < NCH ( n ) ; ++ i ) { ch = CHILD ( n , i ) ; if ( TYPE ( ch ) == DOUBLESTAR ) break ; if ( TYPE ( ch ) == tfpdef || TYPE ( ch ) == vfpdef ) nkwonlyargs ++ ; } posargs = ( nposargs ? _Ta3_asdl_seq_new ( nposargs , c -> c_arena ) : NULL ) ; if ( ! posargs && nposargs ) return NULL ; kwonlyargs = ( nkwonlyargs ? _Ta3_asdl_seq_new ( nkwonlyargs , c -> c_arena ) : NULL ) ; if ( ! kwonlyargs && nkwonlyargs ) return NULL ; posdefaults = ( nposdefaults ? _Ta3_asdl_seq_new ( nposdefaults , c -> c_arena ) : NULL ) ; if ( ! posdefaults && nposdefaults ) return NULL ; kwdefaults = ( nkwonlyargs ? _Ta3_asdl_seq_new ( nkwonlyargs , c -> c_arena ) : NULL ) ; if ( ! kwdefaults && nkwonlyargs ) return NULL ; <S2SV_StartBug> if ( nposargs + nkwonlyargs > 255 ) { <S2SV_EndBug> ast_error ( c , n , \"more<S2SV_blank>than<S2SV_blank>255<S2SV_blank>arguments\" ) ; return NULL ; } i = 0 ; j = 0 ; k = 0 ; while ( i < NCH ( n ) ) { ch = CHILD ( n , i ) ; switch ( TYPE ( ch ) ) { case tfpdef : case vfpdef : if ( i + 1 < NCH ( n ) && TYPE ( CHILD ( n , i + 1 ) ) == EQUAL ) { expr_ty expression = ast_for_expr ( c , CHILD ( n , i + 2 ) ) ; if ( ! expression ) return NULL ; assert ( posdefaults != NULL ) ; asdl_seq_SET ( posdefaults , j ++ , expression ) ; i += 2 ; found_default = 1 ; } else if ( found_default ) { ast_error ( c , n , \"non-default<S2SV_blank>argument<S2SV_blank>follows<S2SV_blank>default<S2SV_blank>argument\" ) ; return NULL ; } arg = ast_for_arg ( c , ch ) ; if ( ! arg ) return NULL ; asdl_seq_SET ( posargs , k ++ , arg ) ; i += 1 ; <S2SV_StartBug> if ( i < NCH ( n ) && TYPE ( CHILD ( n , i ) ) == COMMA ) <S2SV_EndBug> i += 1 ; break ; case STAR : if ( i + 1 >= NCH ( n ) || ( i + 2 == NCH ( n ) && ( TYPE ( CHILD ( n , i + 1 ) ) == COMMA || TYPE ( CHILD ( n , i + 1 ) ) == TYPE_COMMENT ) ) ) { ast_error ( c , CHILD ( n , i ) , \"named<S2SV_blank>arguments<S2SV_blank>must<S2SV_blank>follow<S2SV_blank>bare<S2SV_blank>*\" ) ; return NULL ; } ch = CHILD ( n , i + 1 ) ; if ( TYPE ( ch ) == COMMA ) { int res = 0 ; i += 2 ; <S2SV_StartBug> if ( i < NCH ( n ) && TYPE ( CHILD ( n , i ) ) == TYPE_COMMENT ) { <S2SV_EndBug> ast_error ( c , CHILD ( n , i ) , \"bare<S2SV_blank>*<S2SV_blank>has<S2SV_blank>associated<S2SV_blank>type<S2SV_blank>comment\" ) ; return NULL ; } res = handle_keywordonly_args ( c , n , i , kwonlyargs , kwdefaults ) ; if ( res == - 1 ) return NULL ; i = res ; } else { vararg = ast_for_arg ( c , ch ) ; if ( ! vararg ) return NULL ; i += 2 ; <S2SV_StartBug> if ( i < NCH ( n ) && TYPE ( CHILD ( n , i ) ) == COMMA ) <S2SV_EndBug> i += 1 ; <S2SV_StartBug> if ( i < NCH ( n ) && TYPE ( CHILD ( n , i ) ) == TYPE_COMMENT ) { <S2SV_EndBug> vararg -> type_comment = NEW_TYPE_COMMENT ( CHILD ( n , i ) ) ; i += 1 ; } if ( i < NCH ( n ) && ( TYPE ( CHILD ( n , i ) ) == tfpdef || TYPE ( CHILD ( n , i ) ) == vfpdef ) ) { int res = 0 ; res = handle_keywordonly_args ( c , n , i , kwonlyargs , kwdefaults ) ; if ( res == - 1 ) return NULL ; i = res ; } } break ; case DOUBLESTAR : ch = CHILD ( n , i + 1 ) ; assert ( TYPE ( ch ) == tfpdef || TYPE ( ch ) == vfpdef ) ; kwarg = ast_for_arg ( c , ch ) ; if ( ! kwarg ) return NULL ; i += 2 ; <S2SV_StartBug> if ( i < NCH ( n ) && TYPE ( CHILD ( n , i ) ) == COMMA ) <S2SV_EndBug> i += 1 ; break ; case TYPE_COMMENT : assert ( i ) ; if ( kwarg ) arg = kwarg ; arg -> type_comment = NEW_TYPE_COMMENT ( ch ) ; i += 1 ; break ; default : PyErr_Format ( PyExc_SystemError , \"unexpected<S2SV_blank>node<S2SV_blank>in<S2SV_blank>varargslist:<S2SV_blank>%d<S2SV_blank>@<S2SV_blank>%d\" , TYPE ( ch ) , i ) ; return NULL ; } } return arguments ( posargs , vararg , kwonlyargs , kwdefaults , kwarg , posdefaults , c -> c_arena ) ; }\n",
      "fixed_code": "<S2SV_ModStart> return NULL ; <S2SV_ModEnd> i = 0 <S2SV_ModStart> ; if ( <S2SV_ModEnd> TYPE ( CHILD <S2SV_ModStart> ; if ( <S2SV_ModEnd> TYPE ( CHILD <S2SV_ModStart> ; if ( <S2SV_ModEnd> TYPE ( CHILD <S2SV_ModStart> ; if ( <S2SV_ModEnd> TYPE ( CHILD <S2SV_ModStart> ; if ( <S2SV_ModEnd> TYPE ( CHILD\n",
      "source_code_length": 4617,
      "target_code_length": 300,
      "vulnerability_patterns": {
        "use_after_free": 2,
        "integer_overflow": 19,
        "null_pointer": 16,
        "total": 37
      },
      "total_patterns": 37,
      "original_address": "https://github.com/python/typed_ast/commit/156afcb26c198e162504a57caddfe0acd9ed7dce",
      "discovery_time": "2019-11-26T15:15Z",
      "project_commit_id": "python@typed_ast/156afcb26c198e162504a57caddfe0acd9ed7dce",
      "extraction_time": "2025-08-31T15:41:49.174266",
      "label": 1,
      "vulnerability_type": "out-of-bounds_read",
      "difficulty_level": "expert",
      "risk_factors": [
        "memory_corruption",
        "critical_infrastructure",
        "information_disclosure",
        "use_after_free",
        "integer_overflow"
      ],
      "attack_vectors": [
        "memory_manipulation",
        "malicious_input",
        "code_analysis",
        "buffer_overflow",
        "reverse_engineering",
        "fuzzing"
      ],
      "mitigation_strategies": [
        "safe_string_functions",
        "dynamic_analysis",
        "code_review",
        "static_analysis",
        "memory_safety_checks",
        "input_validation",
        "fuzzing",
        "bounds_checking",
        "secure_coding_practices"
      ],
      "code_differences": {
        "has_differences": true,
        "source_lines": 2,
        "target_lines": 2,
        "character_differences": 4317,
        "similarity_percentage": 9.70873786407767
      },
      "vulnerability_location": {
        "vulnerability_present": true,
        "fix_applied": true,
        "code_changed": true,
        "estimated_lines_changed": 0
      }
    },
    {
      "cve_id": "CVE-2019-19481",
      "cwe_id": "CWE-119",
      "cwe_name": "Buffer Overflow",
      "project": "OpenSC",
      "severity": "critical",
      "weaponization_score": 10.0,
      "is_critical": true,
      "is_weaponizable": true,
      "is_high_priority_project": false,
      "vulnerable_code": "CWE-119 static int cac_read_binary ( sc_card_t * card , unsigned int idx , unsigned char * buf , size_t count , unsigned long flags ) { cac_private_data_t * priv = CAC_DATA ( card ) ; int r = 0 ; u8 * val = NULL ; u8 * cert_ptr ; <S2SV_StartBug> size_t val_len ; <S2SV_EndBug> size_t len , cert_len ; u8 cert_type ; SC_FUNC_CALLED ( card -> ctx , SC_LOG_DEBUG_VERBOSE ) ; if ( priv -> cached ) { sc_log ( card -> ctx , \"returning<S2SV_blank>cached<S2SV_blank>value<S2SV_blank>idx=%d<S2SV_blank>count=%\" SC_FORMAT_LEN_SIZE_T \"u\" , idx , count ) ; if ( idx > priv -> cache_buf_len ) { LOG_FUNC_RETURN ( card -> ctx , SC_ERROR_FILE_END_REACHED ) ; } len = MIN ( count , priv -> cache_buf_len - idx ) ; memcpy ( buf , & priv -> cache_buf [ idx ] , len ) ; LOG_FUNC_RETURN ( card -> ctx , len ) ; } sc_log ( card -> ctx , \"clearing<S2SV_blank>cache<S2SV_blank>idx=%d<S2SV_blank>count=%\" SC_FORMAT_LEN_SIZE_T \"u\" , idx , count ) ; free ( priv -> cache_buf ) ; priv -> cache_buf = NULL ; priv -> cache_buf_len = 0 ; r = cac_cac1_get_certificate ( card , & val , & val_len ) ; if ( r < 0 ) goto done ; if ( val_len < 1 ) { r = SC_ERROR_INVALID_DATA ; goto done ; } cert_type = val [ 0 ] ; cert_ptr = val + 1 ; cert_len = val_len - 1 ; if ( ( cert_type & 0x3 ) == 1 ) { # ifdef ENABLE_ZLIB r = sc_decompress_alloc ( & priv -> cache_buf , & priv -> cache_buf_len , cert_ptr , cert_len , COMPRESSION_AUTO ) ; # else sc_log ( card -> ctx , \"CAC<S2SV_blank>compression<S2SV_blank>not<S2SV_blank>supported,<S2SV_blank>no<S2SV_blank>zlib\" ) ; r = SC_ERROR_NOT_SUPPORTED ; # endif if ( r ) goto done ; } else if ( cert_len > 0 ) { priv -> cache_buf = malloc ( cert_len ) ; if ( priv -> cache_buf == NULL ) { r = SC_ERROR_OUT_OF_MEMORY ; goto done ; } priv -> cache_buf_len = cert_len ; memcpy ( priv -> cache_buf , cert_ptr , cert_len ) ; } priv -> cached = 1 ; len = MIN ( count , priv -> cache_buf_len - idx ) ; if ( len && priv -> cache_buf ) memcpy ( buf , & priv -> cache_buf [ idx ] , len ) ; r = len ; done : if ( val ) free ( val ) ; LOG_FUNC_RETURN ( card -> ctx , r ) ; }\n",
      "fixed_code": "<S2SV_ModStart> ; size_t val_len = 0\n",
      "source_code_length": 2066,
      "target_code_length": 37,
      "vulnerability_patterns": {
        "buffer_overflow": 3,
        "use_after_free": 3,
        "null_pointer": 24,
        "memory_leak": 1,
        "total": 31
      },
      "total_patterns": 31,
      "original_address": "https://github.com/OpenSC/OpenSC/commit/b75c002cfb1fd61cd20ec938ff4937d7b1a94278",
      "discovery_time": "2019-12-01T23:15Z",
      "project_commit_id": "OpenSC@OpenSC/b75c002cfb1fd61cd20ec938ff4937d7b1a94278",
      "extraction_time": "2025-08-31T15:41:49.174319",
      "label": 1,
      "vulnerability_type": "buffer_overflow",
      "difficulty_level": "expert",
      "risk_factors": [
        "memory_corruption",
        "arbitrary_code_execution",
        "buffer_overflow",
        "system_crash",
        "use_after_free"
      ],
      "attack_vectors": [
        "memory_manipulation",
        "malicious_input",
        "code_analysis",
        "buffer_overflow",
        "reverse_engineering",
        "fuzzing"
      ],
      "mitigation_strategies": [
        "safe_string_functions",
        "dynamic_analysis",
        "code_review",
        "static_analysis",
        "memory_safety_checks",
        "input_validation",
        "fuzzing",
        "bounds_checking",
        "secure_coding_practices"
      ],
      "code_differences": {
        "has_differences": true,
        "source_lines": 2,
        "target_lines": 2,
        "character_differences": 2029,
        "similarity_percentage": 6.024096385542169
      },
      "vulnerability_location": {
        "vulnerability_present": true,
        "fix_applied": true,
        "code_changed": true,
        "estimated_lines_changed": 0
      }
    },
    {
      "cve_id": "CVE-2019-13308",
      "cwe_id": "CWE-119",
      "cwe_name": "Buffer Overflow",
      "project": "ImageMagick",
      "severity": "critical",
      "weaponization_score": 10.0,
      "is_critical": true,
      "is_weaponizable": true,
      "is_high_priority_project": true,
      "vulnerable_code": "CWE-119 static MagickBooleanType EncodeImage ( const ImageInfo * image_info , Image * image , const size_t data_size ) { # define MaxCode ( number_bits ) ( ( one << ( number_bits ) ) - 1 ) # define MaxHashTable 5003 # define MaxGIFBits 12UL # define MaxGIFTable ( 1UL << MaxGIFBits ) <S2SV_StartBug> # define GIFOutputCode ( code ) { if ( bits > 0 ) datum |= ( size_t ) ( code ) << bits ; else datum = ( size_t ) ( code ) ; bits += number_bits ; while ( bits >= 8 ) { packet [ length ++ ] = ( unsigned char ) ( datum & 0xff ) ; if ( length >= 254 ) { ( void ) WriteBlobByte ( image , ( unsigned char ) length ) ; ( void ) WriteBlob ( image , length , packet ) ; length = 0 ; } datum >>= 8 ; bits -= 8 ; } if ( free_code > max_code ) { number_bits ++ ; if ( number_bits == MaxGIFBits ) max_code = MaxGIFTable ; else max_code = MaxCode ( number_bits ) ; } } <S2SV_EndBug> IndexPacket index ; short * hash_code , * hash_prefix , waiting_code ; size_t bits , clear_code , datum , end_of_information_code , free_code , length , max_code , next_pixel , number_bits , one , pass ; ssize_t displacement , offset , k , y ; unsigned char * packet , * hash_suffix ; assert ( image != ( Image * ) NULL ) ; one = 1 ; packet = ( unsigned char * ) AcquireQuantumMemory ( 256 , sizeof ( * packet ) ) ; hash_code = ( short * ) AcquireQuantumMemory ( MaxHashTable , sizeof ( * hash_code ) ) ; hash_prefix = ( short * ) AcquireQuantumMemory ( MaxHashTable , sizeof ( * hash_prefix ) ) ; hash_suffix = ( unsigned char * ) AcquireQuantumMemory ( MaxHashTable , sizeof ( * hash_suffix ) ) ; if ( ( packet == ( unsigned char * ) NULL ) || ( hash_code == ( short * ) NULL ) || ( hash_prefix == ( short * ) NULL ) || ( hash_suffix == ( unsigned char * ) NULL ) ) { if ( packet != ( unsigned char * ) NULL ) packet = ( unsigned char * ) RelinquishMagickMemory ( packet ) ; if ( hash_code != ( short * ) NULL ) hash_code = ( short * ) RelinquishMagickMemory ( hash_code ) ; if ( hash_prefix != ( short * ) NULL ) hash_prefix = ( short * ) RelinquishMagickMemory ( hash_prefix ) ; if ( hash_suffix != ( unsigned char * ) NULL ) hash_suffix = ( unsigned char * ) RelinquishMagickMemory ( hash_suffix ) ; return ( MagickFalse ) ; } ( void ) memset ( packet , 0 , 256 * sizeof ( * packet ) ) ; ( void ) memset ( hash_code , 0 , MaxHashTable * sizeof ( * hash_code ) ) ; ( void ) memset ( hash_prefix , 0 , MaxHashTable * sizeof ( * hash_prefix ) ) ; ( void ) memset ( hash_suffix , 0 , MaxHashTable * sizeof ( * hash_suffix ) ) ; number_bits = data_size ; max_code = MaxCode ( number_bits ) ; clear_code = ( ( short ) one << ( data_size - 1 ) ) ; end_of_information_code = clear_code + 1 ; free_code = clear_code + 2 ; length = 0 ; datum = 0 ; bits = 0 ; GIFOutputCode ( clear_code ) ; offset = 0 ; pass = 0 ; waiting_code = 0 ; for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { register const IndexPacket * magick_restrict indexes ; register const PixelPacket * magick_restrict p ; register ssize_t x ; p = GetVirtualPixels ( image , 0 , offset , image -> columns , 1 , & image -> exception ) ; if ( p == ( const PixelPacket * ) NULL ) break ; indexes = GetVirtualIndexQueue ( image ) ; if ( y == 0 ) { waiting_code = ( short ) ( * indexes ) ; p ++ ; } for ( x = ( ssize_t ) ( y == 0 ? 1 : 0 ) ; x < ( ssize_t ) image -> columns ; x ++ ) { <S2SV_StartBug> index = ( IndexPacket ) ( ( size_t ) GetPixelIndex ( indexes + x ) & 0xff ) ; <S2SV_EndBug> p ++ ; k = ( ssize_t ) ( ( ( size_t ) index << ( MaxGIFBits - 8 ) ) + waiting_code ) ; if ( k >= MaxHashTable ) k -= MaxHashTable ; <S2SV_StartBug> next_pixel = MagickFalse ; <S2SV_EndBug> displacement = 1 ; if ( hash_code [ k ] > 0 ) { if ( ( hash_prefix [ k ] == waiting_code ) && ( hash_suffix [ k ] == ( unsigned char ) index ) ) { waiting_code = hash_code [ k ] ; continue ; } if ( k != 0 ) displacement = MaxHashTable - k ; for ( ; ; ) { k -= displacement ; if ( k < 0 ) k += MaxHashTable ; if ( hash_code [ k ] == 0 ) break ; if ( ( hash_prefix [ k ] == waiting_code ) && ( hash_suffix [ k ] == ( unsigned char ) index ) ) { waiting_code = hash_code [ k ] ; next_pixel = MagickTrue ; break ; } } if ( next_pixel != MagickFalse ) continue ; } GIFOutputCode ( waiting_code ) ; if ( free_code < MaxGIFTable ) { hash_code [ k ] = ( short ) free_code ++ ; hash_prefix [ k ] = waiting_code ; hash_suffix [ k ] = ( unsigned char ) index ; } else { for ( k = 0 ; k < MaxHashTable ; k ++ ) hash_code [ k ] = 0 ; free_code = clear_code + 2 ; GIFOutputCode ( clear_code ) ; number_bits = data_size ; max_code = MaxCode ( number_bits ) ; } waiting_code = ( short ) index ; } if ( image_info -> interlace == NoInterlace ) offset ++ ; else switch ( pass ) { case 0 : default : { offset += 8 ; if ( offset >= ( ssize_t ) image -> rows ) { pass ++ ; offset = 4 ; } break ; } case 1 : { offset += 8 ; if ( offset >= ( ssize_t ) image -> rows ) { pass ++ ; offset = 2 ; } break ; } case 2 : { offset += 4 ; if ( offset >= ( ssize_t ) image -> rows ) { pass ++ ; offset = 1 ; } break ; } case 3 : { offset += 2 ; break ; } } } GIFOutputCode ( waiting_code ) ; GIFOutputCode ( end_of_information_code ) ; if ( bits > 0 ) { packet [ length ++ ] = ( unsigned char ) ( datum & 0xff ) ; if ( length >= 254 ) { ( void ) WriteBlobByte ( image , ( unsigned char ) length ) ; ( void ) WriteBlob ( image , length , packet ) ; length = 0 ; } } if ( length > 0 ) { ( void ) WriteBlobByte ( image , ( unsigned char ) length ) ; ( void ) WriteBlob ( image , length , packet ) ; } hash_suffix = ( unsigned char * ) RelinquishMagickMemory ( hash_suffix ) ; hash_prefix = ( short * ) RelinquishMagickMemory ( hash_prefix ) ; hash_code = ( short * ) RelinquishMagickMemory ( hash_code ) ; packet = ( unsigned char * ) RelinquishMagickMemory ( packet ) ; return ( MagickTrue ) ; }\n",
      "fixed_code": "<S2SV_ModStart> ( code ) \\\\\\n{ <S2SV_ModEnd> if ( bits <S2SV_ModStart> ) ; } \\\\\\n} <S2SV_ModEnd> IndexPacket index ; <S2SV_ModStart> ++ ) { next_pixel = MagickFalse ; displacement = 1 ; <S2SV_ModStart> -= MaxHashTable ; if ( k < 0 ) continue <S2SV_ModEnd> ; if (\n",
      "source_code_length": 5773,
      "target_code_length": 263,
      "vulnerability_patterns": {
        "buffer_overflow": 4,
        "integer_overflow": 22,
        "null_pointer": 8,
        "total": 34
      },
      "total_patterns": 34,
      "original_address": "https://github.com/ImageMagick/ImageMagick6/commit/19651f3db63fa1511ed83a348c4c82fa553f8d01",
      "discovery_time": "2019-07-05T01:15Z",
      "project_commit_id": "ImageMagick@ImageMagick6/19651f3db63fa1511ed83a348c4c82fa553f8d01",
      "extraction_time": "2025-08-31T15:41:49.174349",
      "label": 1,
      "vulnerability_type": "buffer_overflow",
      "difficulty_level": "expert",
      "risk_factors": [
        "memory_corruption",
        "critical_infrastructure",
        "arbitrary_code_execution",
        "buffer_overflow",
        "system_crash"
      ],
      "attack_vectors": [
        "memory_manipulation",
        "malicious_input",
        "code_analysis",
        "buffer_overflow",
        "reverse_engineering",
        "fuzzing"
      ],
      "mitigation_strategies": [
        "safe_string_functions",
        "dynamic_analysis",
        "code_review",
        "static_analysis",
        "memory_safety_checks",
        "input_validation",
        "fuzzing",
        "bounds_checking",
        "secure_coding_practices"
      ],
      "code_differences": {
        "has_differences": true,
        "source_lines": 2,
        "target_lines": 2,
        "character_differences": 5510,
        "similarity_percentage": 17.322834645669293
      },
      "vulnerability_location": {
        "vulnerability_present": true,
        "fix_applied": true,
        "code_changed": true,
        "estimated_lines_changed": 0
      }
    },
    {
      "cve_id": "CVE-2018-1999011",
      "cwe_id": "CWE-119",
      "cwe_name": "Buffer Overflow",
      "project": "FFmpeg",
      "severity": "critical",
      "weaponization_score": 10.0,
      "is_critical": true,
      "is_weaponizable": true,
      "is_high_priority_project": true,
      "vulnerable_code": "CWE-119 static int parse_video_info ( AVIOContext * pb , AVStream * st ) { uint16_t size_asf ; uint32_t size_bmp ; unsigned int tag ; st -> codecpar -> width = avio_rl32 ( pb ) ; st -> codecpar -> height = avio_rl32 ( pb ) ; avio_skip ( pb , 1 ) ; size_asf = avio_rl16 ( pb ) ; tag = ff_get_bmp_header ( pb , st , & size_bmp ) ; st -> codecpar -> codec_tag = tag ; st -> codecpar -> codec_id = ff_codec_get_id ( ff_codec_bmp_tags , tag ) ; size_bmp = FFMAX ( size_asf , size_bmp ) ; <S2SV_StartBug> if ( size_bmp > BMP_HEADER_SIZE ) { <S2SV_EndBug> int ret ; st -> codecpar -> extradata_size = size_bmp - BMP_HEADER_SIZE ; if ( ! ( st -> codecpar -> extradata = av_malloc ( st -> codecpar -> extradata_size + AV_INPUT_BUFFER_PADDING_SIZE ) ) ) { st -> codecpar -> extradata_size = 0 ; return AVERROR ( ENOMEM ) ; } memset ( st -> codecpar -> extradata + st -> codecpar -> extradata_size , 0 , AV_INPUT_BUFFER_PADDING_SIZE ) ; if ( ( ret = avio_read ( pb , st -> codecpar -> extradata , st -> codecpar -> extradata_size ) ) < 0 ) return ret ; } return 0 ; }\n",
      "fixed_code": "<S2SV_ModStart> size_bmp > BMP_HEADER_SIZE && size_bmp < INT_MAX - AV_INPUT_BUFFER_PADDING_SIZE\n",
      "source_code_length": 1057,
      "target_code_length": 96,
      "vulnerability_patterns": {
        "buffer_overflow": 1,
        "null_pointer": 24,
        "total": 25
      },
      "total_patterns": 25,
      "original_address": "https://github.com/FFmpeg/FFmpeg/commit/2b46ebdbff1d8dec7a3d8ea280a612b91a582869",
      "discovery_time": "2018-07-23T15:29Z",
      "project_commit_id": "FFmpeg@FFmpeg/2b46ebdbff1d8dec7a3d8ea280a612b91a582869",
      "extraction_time": "2025-08-31T15:41:49.174411",
      "label": 1,
      "vulnerability_type": "buffer_overflow",
      "difficulty_level": "expert",
      "risk_factors": [
        "memory_corruption",
        "critical_infrastructure",
        "arbitrary_code_execution",
        "buffer_overflow",
        "system_crash"
      ],
      "attack_vectors": [
        "memory_manipulation",
        "malicious_input",
        "code_analysis",
        "buffer_overflow",
        "reverse_engineering",
        "fuzzing"
      ],
      "mitigation_strategies": [
        "safe_string_functions",
        "dynamic_analysis",
        "code_review",
        "static_analysis",
        "memory_safety_checks",
        "input_validation",
        "fuzzing",
        "bounds_checking",
        "secure_coding_practices"
      ],
      "code_differences": {
        "has_differences": true,
        "source_lines": 2,
        "target_lines": 2,
        "character_differences": 961,
        "similarity_percentage": 10.0
      },
      "vulnerability_location": {
        "vulnerability_present": true,
        "fix_applied": true,
        "code_changed": true,
        "estimated_lines_changed": 0
      }
    },
    {
      "cve_id": "CVE-2017-15385",
      "cwe_id": "CWE-119",
      "cwe_name": "Buffer Overflow",
      "project": "radare",
      "severity": "critical",
      "weaponization_score": 10.0,
      "is_critical": true,
      "is_weaponizable": true,
      "is_high_priority_project": true,
      "vulnerable_code": "CWE-119 static Sdb * store_versioninfo_gnu_verdef ( ELFOBJ * bin , Elf_ ( Shdr ) * shdr , int sz ) { const char * section_name = \"\" ; const char * link_section_name = \"\" ; char * end = NULL ; Elf_ ( Shdr ) * link_shdr = NULL ; ut8 dfs [ sizeof ( Elf_ ( Verdef ) ) ] = { 0 } ; Sdb * sdb ; int cnt , i ; if ( shdr -> sh_link > bin -> ehdr . e_shnum ) { return false ; } link_shdr = & bin -> shdr [ shdr -> sh_link ] ; if ( shdr -> sh_size < 1 ) { return false ; } Elf_ ( Verdef ) * defs = calloc ( shdr -> sh_size , sizeof ( char ) ) ; if ( ! defs ) { return false ; } if ( bin -> shstrtab && shdr -> sh_name < bin -> shstrtab_size ) { section_name = & bin -> shstrtab [ shdr -> sh_name ] ; } if ( link_shdr && bin -> shstrtab && link_shdr -> sh_name < bin -> shstrtab_size ) { link_section_name = & bin -> shstrtab [ link_shdr -> sh_name ] ; } if ( ! defs ) { bprintf ( \"Warning:<S2SV_blank>Cannot<S2SV_blank>allocate<S2SV_blank>memory<S2SV_blank>(Check<S2SV_blank>Elf_(Verdef))\\\\n\" ) ; return NULL ; } sdb = sdb_new0 ( ) ; end = ( char * ) defs + shdr -> sh_size ; sdb_set ( sdb , \"section_name\" , section_name , 0 ) ; sdb_num_set ( sdb , \"entries\" , shdr -> sh_info , 0 ) ; sdb_num_set ( sdb , \"addr\" , shdr -> sh_addr , 0 ) ; sdb_num_set ( sdb , \"offset\" , shdr -> sh_offset , 0 ) ; sdb_num_set ( sdb , \"link\" , shdr -> sh_link , 0 ) ; sdb_set ( sdb , \"link_section_name\" , link_section_name , 0 ) ; <S2SV_StartBug> for ( cnt = 0 , i = 0 ; cnt < shdr -> sh_info && ( ( char * ) defs + i < end ) ; ++ cnt ) { <S2SV_EndBug> Sdb * sdb_verdef = sdb_new0 ( ) ; char * vstart = ( ( char * ) defs ) + i ; char key [ 32 ] = { 0 } ; Elf_ ( Verdef ) * verdef = ( Elf_ ( Verdef ) * ) vstart ; Elf_ ( Verdaux ) aux = { 0 } ; int j = 0 ; int isum = 0 ; r_buf_read_at ( bin -> b , shdr -> sh_offset + i , dfs , sizeof ( Elf_ ( Verdef ) ) ) ; verdef -> vd_version = READ16 ( dfs , j ) verdef -> vd_flags = READ16 ( dfs , j ) verdef -> vd_ndx = READ16 ( dfs , j ) verdef -> vd_cnt = READ16 ( dfs , j ) verdef -> vd_hash = READ32 ( dfs , j ) verdef -> vd_aux = READ32 ( dfs , j ) verdef -> vd_next = READ32 ( dfs , j ) vstart += verdef -> vd_aux ; if ( vstart > end || vstart + sizeof ( Elf_ ( Verdaux ) ) > end ) { sdb_free ( sdb_verdef ) ; goto out_error ; } j = 0 ; aux . vda_name = READ32 ( vstart , j ) aux . vda_next = READ32 ( vstart , j ) isum = i + verdef -> vd_aux ; if ( aux . vda_name > bin -> dynstr_size ) { sdb_free ( sdb_verdef ) ; goto out_error ; } sdb_num_set ( sdb_verdef , \"idx\" , i , 0 ) ; sdb_num_set ( sdb_verdef , \"vd_version\" , verdef -> vd_version , 0 ) ; sdb_num_set ( sdb_verdef , \"vd_ndx\" , verdef -> vd_ndx , 0 ) ; sdb_num_set ( sdb_verdef , \"vd_cnt\" , verdef -> vd_cnt , 0 ) ; sdb_set ( sdb_verdef , \"vda_name\" , & bin -> dynstr [ aux . vda_name ] , 0 ) ; sdb_set ( sdb_verdef , \"flags\" , get_ver_flags ( verdef -> vd_flags ) , 0 ) ; for ( j = 1 ; j < verdef -> vd_cnt ; ++ j ) { int k ; Sdb * sdb_parent = sdb_new0 ( ) ; isum += aux . vda_next ; vstart += aux . vda_next ; if ( vstart > end || vstart + sizeof ( Elf_ ( Verdaux ) ) > end ) { sdb_free ( sdb_verdef ) ; sdb_free ( sdb_parent ) ; goto out_error ; } k = 0 ; aux . vda_name = READ32 ( vstart , k ) aux . vda_next = READ32 ( vstart , k ) if ( aux . vda_name > bin -> dynstr_size ) { sdb_free ( sdb_verdef ) ; sdb_free ( sdb_parent ) ; goto out_error ; } sdb_num_set ( sdb_parent , \"idx\" , isum , 0 ) ; sdb_num_set ( sdb_parent , \"parent\" , j , 0 ) ; sdb_set ( sdb_parent , \"vda_name\" , & bin -> dynstr [ aux . vda_name ] , 0 ) ; snprintf ( key , sizeof ( key ) , \"parent%d\" , j - 1 ) ; sdb_ns_set ( sdb_verdef , key , sdb_parent ) ; } snprintf ( key , sizeof ( key ) , \"verdef%d\" , cnt ) ; sdb_ns_set ( sdb , key , sdb_verdef ) ; if ( ! verdef -> vd_next ) { sdb_free ( sdb_verdef ) ; goto out_error ; } <S2SV_StartBug> i += verdef -> vd_next ; <S2SV_EndBug> } free ( defs ) ; return sdb ; out_error : free ( defs ) ; sdb_free ( sdb ) ; return NULL ; }\n",
      "fixed_code": "<S2SV_ModStart> = 0 ; i >= 0 && <S2SV_ModStart> out_error ; } if ( ( st32 ) verdef -> vd_next < 1 ) { eprintf ( \"Warning:<S2SV_blank>Invalid<S2SV_blank>vd_next<S2SV_blank>in<S2SV_blank>the<S2SV_blank>ELF<S2SV_blank>version\\\\n\" ) ; break ; }\n",
      "source_code_length": 3931,
      "target_code_length": 241,
      "vulnerability_patterns": {
        "use_after_free": 3,
        "integer_overflow": 6,
        "format_string": 2,
        "null_pointer": 48,
        "memory_leak": 1,
        "total": 60
      },
      "total_patterns": 60,
      "original_address": "https://github.com/radare/radare2/commit/21a6f570ba33fa9f52f1bba87f07acc4e8c178f4",
      "discovery_time": "2017-10-16T22:29Z",
      "project_commit_id": "radare@radare2/21a6f570ba33fa9f52f1bba87f07acc4e8c178f4",
      "extraction_time": "2025-08-31T15:41:49.174429",
      "label": 1,
      "vulnerability_type": "buffer_overflow",
      "difficulty_level": "expert",
      "risk_factors": [
        "memory_corruption",
        "critical_infrastructure",
        "arbitrary_code_execution",
        "system_crash",
        "use_after_free"
      ],
      "attack_vectors": [
        "memory_manipulation",
        "malicious_input",
        "code_analysis",
        "buffer_overflow",
        "reverse_engineering",
        "fuzzing"
      ],
      "mitigation_strategies": [
        "safe_string_functions",
        "dynamic_analysis",
        "code_review",
        "static_analysis",
        "memory_safety_checks",
        "input_validation",
        "fuzzing",
        "bounds_checking",
        "secure_coding_practices"
      ],
      "code_differences": {
        "has_differences": true,
        "source_lines": 2,
        "target_lines": 2,
        "character_differences": 3690,
        "similarity_percentage": 12.5
      },
      "vulnerability_location": {
        "vulnerability_present": true,
        "fix_applied": true,
        "code_changed": true,
        "estimated_lines_changed": 0
      }
    },
    {
      "cve_id": "CVE-2019-19244",
      "cwe_id": "CWE-000",
      "cwe_name": "Unknown/Uncategorized",
      "project": "sqlite",
      "severity": "critical",
      "weaponization_score": 10.0,
      "is_critical": true,
      "is_weaponizable": true,
      "is_high_priority_project": true,
      "vulnerable_code": "CWE-000 int sqlite3Select ( Parse * pParse , Select * p , SelectDest * pDest ) { int i , j ; WhereInfo * pWInfo ; Vdbe * v ; int isAgg ; ExprList * pEList = 0 ; SrcList * pTabList ; Expr * pWhere ; ExprList * pGroupBy ; Expr * pHaving ; int rc = 1 ; DistinctCtx sDistinct ; SortCtx sSort ; AggInfo sAggInfo ; int iEnd ; sqlite3 * db ; ExprList * pMinMaxOrderBy = 0 ; u8 minMaxFlag ; db = pParse -> db ; v = sqlite3GetVdbe ( pParse ) ; if ( p == 0 || db -> mallocFailed || pParse -> nErr ) { return 1 ; } if ( sqlite3AuthCheck ( pParse , SQLITE_SELECT , 0 , 0 , 0 ) ) return 1 ; memset ( & sAggInfo , 0 , sizeof ( sAggInfo ) ) ; # if SELECTTRACE_ENABLED SELECTTRACE ( 1 , pParse , p , ( \"begin<S2SV_blank>processing:\\\\n\" , pParse -> addrExplain ) ) ; if ( sqlite3SelectTrace & 0x100 ) { sqlite3TreeViewSelect ( 0 , p , 0 ) ; } # endif assert ( p -> pOrderBy == 0 || pDest -> eDest != SRT_DistFifo ) ; assert ( p -> pOrderBy == 0 || pDest -> eDest != SRT_Fifo ) ; assert ( p -> pOrderBy == 0 || pDest -> eDest != SRT_DistQueue ) ; assert ( p -> pOrderBy == 0 || pDest -> eDest != SRT_Queue ) ; if ( IgnorableOrderby ( pDest ) ) { assert ( pDest -> eDest == SRT_Exists || pDest -> eDest == SRT_Union || pDest -> eDest == SRT_Except || pDest -> eDest == SRT_Discard || pDest -> eDest == SRT_Queue || pDest -> eDest == SRT_DistFifo || pDest -> eDest == SRT_DistQueue || pDest -> eDest == SRT_Fifo ) ; sqlite3ExprListDelete ( db , p -> pOrderBy ) ; p -> pOrderBy = 0 ; p -> selFlags &= ~ SF_Distinct ; } sqlite3SelectPrep ( pParse , p , 0 ) ; if ( pParse -> nErr || db -> mallocFailed ) { goto select_end ; } assert ( p -> pEList != 0 ) ; # if SELECTTRACE_ENABLED if ( sqlite3SelectTrace & 0x104 ) { SELECTTRACE ( 0x104 , pParse , p , ( \"after<S2SV_blank>name<S2SV_blank>resolution:\\\\n\" ) ) ; sqlite3TreeViewSelect ( 0 , p , 0 ) ; } # endif if ( pDest -> eDest == SRT_Output ) { generateColumnNames ( pParse , p ) ; } # ifndef SQLITE_OMIT_WINDOWFUNC if ( sqlite3WindowRewrite ( pParse , p ) ) { goto select_end ; } # if SELECTTRACE_ENABLED if ( p -> pWin && ( sqlite3SelectTrace & 0x108 ) != 0 ) { SELECTTRACE ( 0x104 , pParse , p , ( \"after<S2SV_blank>window<S2SV_blank>rewrite:\\\\n\" ) ) ; sqlite3TreeViewSelect ( 0 , p , 0 ) ; } # endif # endif pTabList = p -> pSrc ; isAgg = ( p -> selFlags & SF_Aggregate ) != 0 ; memset ( & sSort , 0 , sizeof ( sSort ) ) ; sSort . pOrderBy = p -> pOrderBy ; # if ! defined ( SQLITE_OMIT_SUBQUERY ) || ! defined ( SQLITE_OMIT_VIEW ) for ( i = 0 ; ! p -> pPrior && i < pTabList -> nSrc ; i ++ ) { struct SrcList_item * pItem = & pTabList -> a [ i ] ; Select * pSub = pItem -> pSelect ; Table * pTab = pItem -> pTab ; if ( ( pItem -> fg . jointype & JT_LEFT ) != 0 && sqlite3ExprImpliesNonNullRow ( p -> pWhere , pItem -> iCursor ) && OptimizationEnabled ( db , SQLITE_SimplifyJoin ) ) { SELECTTRACE ( 0x100 , pParse , p , ( \"LEFT-JOIN<S2SV_blank>simplifies<S2SV_blank>to<S2SV_blank>JOIN<S2SV_blank>on<S2SV_blank>term<S2SV_blank>%d\\\\n\" , i ) ) ; pItem -> fg . jointype &= ~ ( JT_LEFT | JT_OUTER ) ; unsetJoinExpr ( p -> pWhere , pItem -> iCursor ) ; } if ( pSub == 0 ) continue ; if ( pTab -> nCol != pSub -> pEList -> nExpr ) { sqlite3ErrorMsg ( pParse , \"expected<S2SV_blank>%d<S2SV_blank>columns<S2SV_blank>for<S2SV_blank>\\'%s\\'<S2SV_blank>but<S2SV_blank>got<S2SV_blank>%d\" , pTab -> nCol , pTab -> zName , pSub -> pEList -> nExpr ) ; goto select_end ; } if ( ( pSub -> selFlags & SF_Aggregate ) != 0 ) continue ; assert ( pSub -> pGroupBy == 0 ) ; if ( pSub -> pOrderBy != 0 && i == 0 && ( p -> selFlags & SF_ComplexResult ) != 0 && ( pTabList -> nSrc == 1 || ( pTabList -> a [ 1 ] . fg . jointype & ( JT_LEFT | JT_CROSS ) ) != 0 ) ) { continue ; } if ( flattenSubquery ( pParse , p , i , isAgg ) ) { if ( pParse -> nErr ) goto select_end ; i = - 1 ; } pTabList = p -> pSrc ; if ( db -> mallocFailed ) goto select_end ; if ( ! IgnorableOrderby ( pDest ) ) { sSort . pOrderBy = p -> pOrderBy ; } } # endif # ifndef SQLITE_OMIT_COMPOUND_SELECT if ( p -> pPrior ) { rc = multiSelect ( pParse , p , pDest ) ; # if SELECTTRACE_ENABLED SELECTTRACE ( 0x1 , pParse , p , ( \"end<S2SV_blank>compound-select<S2SV_blank>processing\\\\n\" ) ) ; if ( ( sqlite3SelectTrace & 0x2000 ) != 0 && ExplainQueryPlanParent ( pParse ) == 0 ) { sqlite3TreeViewSelect ( 0 , p , 0 ) ; } # endif if ( p -> pNext == 0 ) ExplainQueryPlanPop ( pParse ) ; return rc ; } # endif if ( pTabList -> nSrc > 1 && OptimizationEnabled ( db , SQLITE_PropagateConst ) && propagateConstants ( pParse , p ) ) { # if SELECTTRACE_ENABLED if ( sqlite3SelectTrace & 0x100 ) { SELECTTRACE ( 0x100 , pParse , p , ( \"After<S2SV_blank>constant<S2SV_blank>propagation:\\\\n\" ) ) ; sqlite3TreeViewSelect ( 0 , p , 0 ) ; } # endif } else { SELECTTRACE ( 0x100 , pParse , p , ( \"Constant<S2SV_blank>propagation<S2SV_blank>not<S2SV_blank>helpful\\\\n\" ) ) ; } # ifdef SQLITE_COUNTOFVIEW_OPTIMIZATION if ( OptimizationEnabled ( db , SQLITE_QueryFlattener | SQLITE_CountOfView ) && countOfViewOptimization ( pParse , p ) ) { if ( db -> mallocFailed ) goto select_end ; pEList = p -> pEList ; pTabList = p -> pSrc ; } # endif for ( i = 0 ; i < pTabList -> nSrc ; i ++ ) { struct SrcList_item * pItem = & pTabList -> a [ i ] ; SelectDest dest ; Select * pSub ; # if ! defined ( SQLITE_OMIT_SUBQUERY ) || ! defined ( SQLITE_OMIT_VIEW ) const char * zSavedAuthContext ; # endif if ( pItem -> colUsed == 0 && pItem -> zName != 0 ) { sqlite3AuthCheck ( pParse , SQLITE_READ , pItem -> zName , \"\" , pItem -> zDatabase ) ; } # if ! defined ( SQLITE_OMIT_SUBQUERY ) || ! defined ( SQLITE_OMIT_VIEW ) pSub = pItem -> pSelect ; if ( pSub == 0 ) continue ; testcase ( pItem -> addrFillSub != 0 ) ; pParse -> nHeight += sqlite3SelectExprHeight ( p ) ; if ( OptimizationEnabled ( db , SQLITE_PushDown ) && pushDownWhereTerms ( pParse , pSub , p -> pWhere , pItem -> iCursor , ( pItem -> fg . jointype & JT_OUTER ) != 0 ) ) { # if SELECTTRACE_ENABLED if ( sqlite3SelectTrace & 0x100 ) { SELECTTRACE ( 0x100 , pParse , p , ( \"After<S2SV_blank>WHERE-clause<S2SV_blank>push-down<S2SV_blank>into<S2SV_blank>subquery<S2SV_blank>%d:\\\\n\" , pSub -> selId ) ) ; sqlite3TreeViewSelect ( 0 , p , 0 ) ; } # endif } else { SELECTTRACE ( 0x100 , pParse , p , ( \"Push-down<S2SV_blank>not<S2SV_blank>possible\\\\n\" ) ) ; } zSavedAuthContext = pParse -> zAuthContext ; pParse -> zAuthContext = pItem -> zName ; if ( i == 0 && ( pTabList -> nSrc == 1 || ( pTabList -> a [ 1 ] . fg . jointype & ( JT_LEFT | JT_CROSS ) ) != 0 ) ) { int addrTop = sqlite3VdbeCurrentAddr ( v ) + 1 ; pItem -> regReturn = ++ pParse -> nMem ; sqlite3VdbeAddOp3 ( v , OP_InitCoroutine , pItem -> regReturn , 0 , addrTop ) ; VdbeComment ( ( v , \"%s\" , pItem -> pTab -> zName ) ) ; pItem -> addrFillSub = addrTop ; sqlite3SelectDestInit ( & dest , SRT_Coroutine , pItem -> regReturn ) ; ExplainQueryPlan ( ( pParse , 1 , \"CO-ROUTINE<S2SV_blank>%u\" , pSub -> selId ) ) ; sqlite3Select ( pParse , pSub , & dest ) ; pItem -> pTab -> nRowLogEst = pSub -> nSelectRow ; pItem -> fg . viaCoroutine = 1 ; pItem -> regResult = dest . iSdst ; sqlite3VdbeEndCoroutine ( v , pItem -> regReturn ) ; sqlite3VdbeJumpHere ( v , addrTop - 1 ) ; sqlite3ClearTempRegCache ( pParse ) ; } else { int topAddr ; int onceAddr = 0 ; int retAddr ; struct SrcList_item * pPrior ; testcase ( pItem -> addrFillSub == 0 ) ; pItem -> regReturn = ++ pParse -> nMem ; topAddr = sqlite3VdbeAddOp2 ( v , OP_Integer , 0 , pItem -> regReturn ) ; pItem -> addrFillSub = topAddr + 1 ; if ( pItem -> fg . isCorrelated == 0 ) { onceAddr = sqlite3VdbeAddOp0 ( v , OP_Once ) ; VdbeCoverage ( v ) ; VdbeComment ( ( v , \"materialize<S2SV_blank>\\\\\"%s\\\\\"\" , pItem -> pTab -> zName ) ) ; } else { VdbeNoopComment ( ( v , \"materialize<S2SV_blank>\\\\\"%s\\\\\"\" , pItem -> pTab -> zName ) ) ; } pPrior = isSelfJoinView ( pTabList , pItem ) ; if ( pPrior ) { sqlite3VdbeAddOp2 ( v , OP_OpenDup , pItem -> iCursor , pPrior -> iCursor ) ; assert ( pPrior -> pSelect != 0 ) ; pSub -> nSelectRow = pPrior -> pSelect -> nSelectRow ; } else { sqlite3SelectDestInit ( & dest , SRT_EphemTab , pItem -> iCursor ) ; ExplainQueryPlan ( ( pParse , 1 , \"MATERIALIZE<S2SV_blank>%u\" , pSub -> selId ) ) ; sqlite3Select ( pParse , pSub , & dest ) ; } pItem -> pTab -> nRowLogEst = pSub -> nSelectRow ; if ( onceAddr ) sqlite3VdbeJumpHere ( v , onceAddr ) ; retAddr = sqlite3VdbeAddOp1 ( v , OP_Return , pItem -> regReturn ) ; VdbeComment ( ( v , \"end<S2SV_blank>%s\" , pItem -> pTab -> zName ) ) ; sqlite3VdbeChangeP1 ( v , topAddr , retAddr ) ; sqlite3ClearTempRegCache ( pParse ) ; } if ( db -> mallocFailed ) goto select_end ; pParse -> nHeight -= sqlite3SelectExprHeight ( p ) ; pParse -> zAuthContext = zSavedAuthContext ; # endif } pEList = p -> pEList ; pWhere = p -> pWhere ; pGroupBy = p -> pGroupBy ; pHaving = p -> pHaving ; sDistinct . isTnct = ( p -> selFlags & SF_Distinct ) != 0 ; # if SELECTTRACE_ENABLED if ( sqlite3SelectTrace & 0x400 ) { SELECTTRACE ( 0x400 , pParse , p , ( \"After<S2SV_blank>all<S2SV_blank>FROM-clause<S2SV_blank>analysis:\\\\n\" ) ) ; sqlite3TreeViewSelect ( 0 , p , 0 ) ; } # endif if ( ( p -> selFlags & ( SF_Distinct | SF_Aggregate ) ) == SF_Distinct && sqlite3ExprListCompare ( sSort . pOrderBy , pEList , - 1 ) == 0 <S2SV_StartBug> ) { <S2SV_EndBug> p -> selFlags &= ~ SF_Distinct ; pGroupBy = p -> pGroupBy = sqlite3ExprListDup ( db , pEList , 0 ) ; assert ( sDistinct . isTnct ) ; # if SELECTTRACE_ENABLED if ( sqlite3SelectTrace & 0x400 ) { SELECTTRACE ( 0x400 , pParse , p , ( \"Transform<S2SV_blank>DISTINCT<S2SV_blank>into<S2SV_blank>GROUP<S2SV_blank>BY:\\\\n\" ) ) ; sqlite3TreeViewSelect ( 0 , p , 0 ) ; } # endif } if ( sSort . pOrderBy ) { KeyInfo * pKeyInfo ; pKeyInfo = sqlite3KeyInfoFromExprList ( pParse , sSort . pOrderBy , 0 , pEList -> nExpr ) ; sSort . iECursor = pParse -> nTab ++ ; sSort . addrSortIndex = sqlite3VdbeAddOp4 ( v , OP_OpenEphemeral , sSort . iECursor , sSort . pOrderBy -> nExpr + 1 + pEList -> nExpr , 0 , ( char * ) pKeyInfo , P4_KEYINFO ) ; } else { sSort . addrSortIndex = - 1 ; } if ( pDest -> eDest == SRT_EphemTab ) { sqlite3VdbeAddOp2 ( v , OP_OpenEphemeral , pDest -> iSDParm , pEList -> nExpr ) ; } iEnd = sqlite3VdbeMakeLabel ( pParse ) ; if ( ( p -> selFlags & SF_FixedLimit ) == 0 ) { p -> nSelectRow = 320 ; } computeLimitRegisters ( pParse , p , iEnd ) ; if ( p -> iLimit == 0 && sSort . addrSortIndex >= 0 ) { sqlite3VdbeChangeOpcode ( v , sSort . addrSortIndex , OP_SorterOpen ) ; sSort . sortFlags |= SORTFLAG_UseSorter ; } if ( p -> selFlags & SF_Distinct ) { sDistinct . tabTnct = pParse -> nTab ++ ; sDistinct . addrTnct = sqlite3VdbeAddOp4 ( v , OP_OpenEphemeral , sDistinct . tabTnct , 0 , 0 , ( char * ) sqlite3KeyInfoFromExprList ( pParse , p -> pEList , 0 , 0 ) , P4_KEYINFO ) ; sqlite3VdbeChangeP5 ( v , BTREE_UNORDERED ) ; sDistinct . eTnctType = WHERE_DISTINCT_UNORDERED ; } else { sDistinct . eTnctType = WHERE_DISTINCT_NOOP ; } if ( ! isAgg && pGroupBy == 0 ) { u16 wctrlFlags = ( sDistinct . isTnct ? WHERE_WANT_DISTINCT : 0 ) | ( p -> selFlags & SF_FixedLimit ) ; # ifndef SQLITE_OMIT_WINDOWFUNC Window * pWin = p -> pWin ; if ( pWin ) { sqlite3WindowCodeInit ( pParse , pWin ) ; } # endif assert ( WHERE_USE_LIMIT == SF_FixedLimit ) ; SELECTTRACE ( 1 , pParse , p , ( \"WhereBegin\\\\n\" ) ) ; pWInfo = sqlite3WhereBegin ( pParse , pTabList , pWhere , sSort . pOrderBy , p -> pEList , wctrlFlags , p -> nSelectRow ) ; if ( pWInfo == 0 ) goto select_end ; if ( sqlite3WhereOutputRowCount ( pWInfo ) < p -> nSelectRow ) { p -> nSelectRow = sqlite3WhereOutputRowCount ( pWInfo ) ; } if ( sDistinct . isTnct && sqlite3WhereIsDistinct ( pWInfo ) ) { sDistinct . eTnctType = sqlite3WhereIsDistinct ( pWInfo ) ; } if ( sSort . pOrderBy ) { sSort . nOBSat = sqlite3WhereIsOrdered ( pWInfo ) ; sSort . labelOBLopt = sqlite3WhereOrderByLimitOptLabel ( pWInfo ) ; if ( sSort . nOBSat == sSort . pOrderBy -> nExpr ) { sSort . pOrderBy = 0 ; } } if ( sSort . addrSortIndex >= 0 && sSort . pOrderBy == 0 ) { sqlite3VdbeChangeToNoop ( v , sSort . addrSortIndex ) ; } assert ( p -> pEList == pEList ) ; # ifndef SQLITE_OMIT_WINDOWFUNC if ( pWin ) { int addrGosub = sqlite3VdbeMakeLabel ( pParse ) ; int iCont = sqlite3VdbeMakeLabel ( pParse ) ; int iBreak = sqlite3VdbeMakeLabel ( pParse ) ; int regGosub = ++ pParse -> nMem ; sqlite3WindowCodeStep ( pParse , p , pWInfo , regGosub , addrGosub ) ; sqlite3VdbeAddOp2 ( v , OP_Goto , 0 , iBreak ) ; sqlite3VdbeResolveLabel ( v , addrGosub ) ; VdbeNoopComment ( ( v , \"inner-loop<S2SV_blank>subroutine\" ) ) ; sSort . labelOBLopt = 0 ; selectInnerLoop ( pParse , p , - 1 , & sSort , & sDistinct , pDest , iCont , iBreak ) ; sqlite3VdbeResolveLabel ( v , iCont ) ; sqlite3VdbeAddOp1 ( v , OP_Return , regGosub ) ; VdbeComment ( ( v , \"end<S2SV_blank>inner-loop<S2SV_blank>subroutine\" ) ) ; sqlite3VdbeResolveLabel ( v , iBreak ) ; } else # endif { selectInnerLoop ( pParse , p , - 1 , & sSort , & sDistinct , pDest , sqlite3WhereContinueLabel ( pWInfo ) , sqlite3WhereBreakLabel ( pWInfo ) ) ; sqlite3WhereEnd ( pWInfo ) ; } } else { NameContext sNC ; int iAMem ; int iBMem ; int iUseFlag ; int iAbortFlag ; int groupBySort ; int addrEnd ; int sortPTab = 0 ; int sortOut = 0 ; int orderByGrp = 0 ; if ( pGroupBy ) { int k ; struct ExprList_item * pItem ; for ( k = p -> pEList -> nExpr , pItem = p -> pEList -> a ; k > 0 ; k -- , pItem ++ ) { pItem -> u . x . iAlias = 0 ; } for ( k = pGroupBy -> nExpr , pItem = pGroupBy -> a ; k > 0 ; k -- , pItem ++ ) { pItem -> u . x . iAlias = 0 ; } assert ( 66 == sqlite3LogEst ( 100 ) ) ; if ( p -> nSelectRow > 66 ) p -> nSelectRow = 66 ; if ( sSort . pOrderBy && pGroupBy -> nExpr == sSort . pOrderBy -> nExpr ) { int ii ; for ( ii = 0 ; ii < pGroupBy -> nExpr ; ii ++ ) { u8 sortFlags = sSort . pOrderBy -> a [ ii ] . sortFlags & KEYINFO_ORDER_DESC ; pGroupBy -> a [ ii ] . sortFlags = sortFlags ; } if ( sqlite3ExprListCompare ( pGroupBy , sSort . pOrderBy , - 1 ) == 0 ) { orderByGrp = 1 ; } } } else { assert ( 0 == sqlite3LogEst ( 1 ) ) ; p -> nSelectRow = 0 ; } addrEnd = sqlite3VdbeMakeLabel ( pParse ) ; memset ( & sNC , 0 , sizeof ( sNC ) ) ; sNC . pParse = pParse ; sNC . pSrcList = pTabList ; sNC . uNC . pAggInfo = & sAggInfo ; VVA_ONLY ( sNC . ncFlags = NC_UAggInfo ; ) sAggInfo . mnReg = pParse -> nMem + 1 ; sAggInfo . nSortingColumn = pGroupBy ? pGroupBy -> nExpr : 0 ; sAggInfo . pGroupBy = pGroupBy ; sqlite3ExprAnalyzeAggList ( & sNC , pEList ) ; sqlite3ExprAnalyzeAggList ( & sNC , sSort . pOrderBy ) ; if ( pHaving ) { if ( pGroupBy ) { assert ( pWhere == p -> pWhere ) ; assert ( pHaving == p -> pHaving ) ; assert ( pGroupBy == p -> pGroupBy ) ; havingToWhere ( pParse , p ) ; pWhere = p -> pWhere ; } sqlite3ExprAnalyzeAggregates ( & sNC , pHaving ) ; } sAggInfo . nAccumulator = sAggInfo . nColumn ; if ( p -> pGroupBy == 0 && p -> pHaving == 0 && sAggInfo . nFunc == 1 ) { minMaxFlag = minMaxQuery ( db , sAggInfo . aFunc [ 0 ] . pExpr , & pMinMaxOrderBy ) ; } else { minMaxFlag = WHERE_ORDERBY_NORMAL ; } for ( i = 0 ; i < sAggInfo . nFunc ; i ++ ) { Expr * pExpr = sAggInfo . aFunc [ i ] . pExpr ; assert ( ! ExprHasProperty ( pExpr , EP_xIsSelect ) ) ; sNC . ncFlags |= NC_InAggFunc ; sqlite3ExprAnalyzeAggList ( & sNC , pExpr -> x . pList ) ; # ifndef SQLITE_OMIT_WINDOWFUNC assert ( ! IsWindowFunc ( pExpr ) ) ; if ( ExprHasProperty ( pExpr , EP_WinFunc ) ) { sqlite3ExprAnalyzeAggregates ( & sNC , pExpr -> y . pWin -> pFilter ) ; } # endif sNC . ncFlags &= ~ NC_InAggFunc ; } sAggInfo . mxReg = pParse -> nMem ; if ( db -> mallocFailed ) goto select_end ; # if SELECTTRACE_ENABLED if ( sqlite3SelectTrace & 0x400 ) { int ii ; SELECTTRACE ( 0x400 , pParse , p , ( \"After<S2SV_blank>aggregate<S2SV_blank>analysis:\\\\n\" ) ) ; sqlite3TreeViewSelect ( 0 , p , 0 ) ; for ( ii = 0 ; ii < sAggInfo . nColumn ; ii ++ ) { sqlite3DebugPrintf ( \"agg-column[%d]<S2SV_blank>iMem=%d\\\\n\" , ii , sAggInfo . aCol [ ii ] . iMem ) ; sqlite3TreeViewExpr ( 0 , sAggInfo . aCol [ ii ] . pExpr , 0 ) ; } for ( ii = 0 ; ii < sAggInfo . nFunc ; ii ++ ) { sqlite3DebugPrintf ( \"agg-func[%d]:<S2SV_blank>iMem=%d\\\\n\" , ii , sAggInfo . aFunc [ ii ] . iMem ) ; sqlite3TreeViewExpr ( 0 , sAggInfo . aFunc [ ii ] . pExpr , 0 ) ; } } # endif if ( pGroupBy ) { KeyInfo * pKeyInfo ; int addr1 ; int addrOutputRow ; int regOutputRow ; int addrSetAbort ; int addrTopOfLoop ; int addrSortingIdx ; int addrReset ; int regReset ; sAggInfo . sortingIdx = pParse -> nTab ++ ; pKeyInfo = sqlite3KeyInfoFromExprList ( pParse , pGroupBy , 0 , sAggInfo . nColumn ) ; addrSortingIdx = sqlite3VdbeAddOp4 ( v , OP_SorterOpen , sAggInfo . sortingIdx , sAggInfo . nSortingColumn , 0 , ( char * ) pKeyInfo , P4_KEYINFO ) ; iUseFlag = ++ pParse -> nMem ; iAbortFlag = ++ pParse -> nMem ; regOutputRow = ++ pParse -> nMem ; addrOutputRow = sqlite3VdbeMakeLabel ( pParse ) ; regReset = ++ pParse -> nMem ; addrReset = sqlite3VdbeMakeLabel ( pParse ) ; iAMem = pParse -> nMem + 1 ; pParse -> nMem += pGroupBy -> nExpr ; iBMem = pParse -> nMem + 1 ; pParse -> nMem += pGroupBy -> nExpr ; sqlite3VdbeAddOp2 ( v , OP_Integer , 0 , iAbortFlag ) ; VdbeComment ( ( v , \"clear<S2SV_blank>abort<S2SV_blank>flag\" ) ) ; sqlite3VdbeAddOp3 ( v , OP_Null , 0 , iAMem , iAMem + pGroupBy -> nExpr - 1 ) ; sqlite3VdbeAddOp2 ( v , OP_Gosub , regReset , addrReset ) ; SELECTTRACE ( 1 , pParse , p , ( \"WhereBegin\\\\n\" ) ) ; pWInfo = sqlite3WhereBegin ( pParse , pTabList , pWhere , pGroupBy , 0 , WHERE_GROUPBY | ( orderByGrp ? WHERE_SORTBYGROUP : 0 ) , 0 ) ; if ( pWInfo == 0 ) goto select_end ; if ( sqlite3WhereIsOrdered ( pWInfo ) == pGroupBy -> nExpr ) { groupBySort = 0 ; } else { int regBase ; int regRecord ; int nCol ; int nGroupBy ; explainTempTable ( pParse , ( sDistinct . isTnct && ( p -> selFlags & SF_Distinct ) == 0 ) ? \"DISTINCT\" : \"GROUP<S2SV_blank>BY\" ) ; groupBySort = 1 ; nGroupBy = pGroupBy -> nExpr ; nCol = nGroupBy ; j = nGroupBy ; for ( i = 0 ; i < sAggInfo . nColumn ; i ++ ) { if ( sAggInfo . aCol [ i ] . iSorterColumn >= j ) { nCol ++ ; j ++ ; } } regBase = sqlite3GetTempRange ( pParse , nCol ) ; sqlite3ExprCodeExprList ( pParse , pGroupBy , regBase , 0 , 0 ) ; j = nGroupBy ; for ( i = 0 ; i < sAggInfo . nColumn ; i ++ ) { struct AggInfo_col * pCol = & sAggInfo . aCol [ i ] ; if ( pCol -> iSorterColumn >= j ) { int r1 = j + regBase ; sqlite3ExprCodeGetColumnOfTable ( v , pCol -> pTab , pCol -> iTable , pCol -> iColumn , r1 ) ; j ++ ; } } regRecord = sqlite3GetTempReg ( pParse ) ; sqlite3VdbeAddOp3 ( v , OP_MakeRecord , regBase , nCol , regRecord ) ; sqlite3VdbeAddOp2 ( v , OP_SorterInsert , sAggInfo . sortingIdx , regRecord ) ; sqlite3ReleaseTempReg ( pParse , regRecord ) ; sqlite3ReleaseTempRange ( pParse , regBase , nCol ) ; sqlite3WhereEnd ( pWInfo ) ; sAggInfo . sortingIdxPTab = sortPTab = pParse -> nTab ++ ; sortOut = sqlite3GetTempReg ( pParse ) ; sqlite3VdbeAddOp3 ( v , OP_OpenPseudo , sortPTab , sortOut , nCol ) ; sqlite3VdbeAddOp2 ( v , OP_SorterSort , sAggInfo . sortingIdx , addrEnd ) ; VdbeComment ( ( v , \"GROUP<S2SV_blank>BY<S2SV_blank>sort\" ) ) ; VdbeCoverage ( v ) ; sAggInfo . useSortingIdx = 1 ; } if ( orderByGrp && OptimizationEnabled ( db , SQLITE_GroupByOrder ) && ( groupBySort || sqlite3WhereIsSorted ( pWInfo ) ) ) { sSort . pOrderBy = 0 ; sqlite3VdbeChangeToNoop ( v , sSort . addrSortIndex ) ; } addrTopOfLoop = sqlite3VdbeCurrentAddr ( v ) ; if ( groupBySort ) { sqlite3VdbeAddOp3 ( v , OP_SorterData , sAggInfo . sortingIdx , sortOut , sortPTab ) ; } for ( j = 0 ; j < pGroupBy -> nExpr ; j ++ ) { if ( groupBySort ) { sqlite3VdbeAddOp3 ( v , OP_Column , sortPTab , j , iBMem + j ) ; } else { sAggInfo . directMode = 1 ; sqlite3ExprCode ( pParse , pGroupBy -> a [ j ] . pExpr , iBMem + j ) ; } } sqlite3VdbeAddOp4 ( v , OP_Compare , iAMem , iBMem , pGroupBy -> nExpr , ( char * ) sqlite3KeyInfoRef ( pKeyInfo ) , P4_KEYINFO ) ; addr1 = sqlite3VdbeCurrentAddr ( v ) ; sqlite3VdbeAddOp3 ( v , OP_Jump , addr1 + 1 , 0 , addr1 + 1 ) ; VdbeCoverage ( v ) ; sqlite3ExprCodeMove ( pParse , iBMem , iAMem , pGroupBy -> nExpr ) ; sqlite3VdbeAddOp2 ( v , OP_Gosub , regOutputRow , addrOutputRow ) ; VdbeComment ( ( v , \"output<S2SV_blank>one<S2SV_blank>row\" ) ) ; sqlite3VdbeAddOp2 ( v , OP_IfPos , iAbortFlag , addrEnd ) ; VdbeCoverage ( v ) ; VdbeComment ( ( v , \"check<S2SV_blank>abort<S2SV_blank>flag\" ) ) ; sqlite3VdbeAddOp2 ( v , OP_Gosub , regReset , addrReset ) ; VdbeComment ( ( v , \"reset<S2SV_blank>accumulator\" ) ) ; sqlite3VdbeJumpHere ( v , addr1 ) ; updateAccumulator ( pParse , iUseFlag , & sAggInfo ) ; sqlite3VdbeAddOp2 ( v , OP_Integer , 1 , iUseFlag ) ; VdbeComment ( ( v , \"indicate<S2SV_blank>data<S2SV_blank>in<S2SV_blank>accumulator\" ) ) ; if ( groupBySort ) { sqlite3VdbeAddOp2 ( v , OP_SorterNext , sAggInfo . sortingIdx , addrTopOfLoop ) ; VdbeCoverage ( v ) ; } else { sqlite3WhereEnd ( pWInfo ) ; sqlite3VdbeChangeToNoop ( v , addrSortingIdx ) ; } sqlite3VdbeAddOp2 ( v , OP_Gosub , regOutputRow , addrOutputRow ) ; VdbeComment ( ( v , \"output<S2SV_blank>final<S2SV_blank>row\" ) ) ; sqlite3VdbeGoto ( v , addrEnd ) ; addrSetAbort = sqlite3VdbeCurrentAddr ( v ) ; sqlite3VdbeAddOp2 ( v , OP_Integer , 1 , iAbortFlag ) ; VdbeComment ( ( v , \"set<S2SV_blank>abort<S2SV_blank>flag\" ) ) ; sqlite3VdbeAddOp1 ( v , OP_Return , regOutputRow ) ; sqlite3VdbeResolveLabel ( v , addrOutputRow ) ; addrOutputRow = sqlite3VdbeCurrentAddr ( v ) ; sqlite3VdbeAddOp2 ( v , OP_IfPos , iUseFlag , addrOutputRow + 2 ) ; VdbeCoverage ( v ) ; VdbeComment ( ( v , \"Groupby<S2SV_blank>result<S2SV_blank>generator<S2SV_blank>entry<S2SV_blank>point\" ) ) ; sqlite3VdbeAddOp1 ( v , OP_Return , regOutputRow ) ; finalizeAggFunctions ( pParse , & sAggInfo ) ; sqlite3ExprIfFalse ( pParse , pHaving , addrOutputRow + 1 , SQLITE_JUMPIFNULL ) ; selectInnerLoop ( pParse , p , - 1 , & sSort , & sDistinct , pDest , addrOutputRow + 1 , addrSetAbort ) ; sqlite3VdbeAddOp1 ( v , OP_Return , regOutputRow ) ; VdbeComment ( ( v , \"end<S2SV_blank>groupby<S2SV_blank>result<S2SV_blank>generator\" ) ) ; sqlite3VdbeResolveLabel ( v , addrReset ) ; resetAccumulator ( pParse , & sAggInfo ) ; sqlite3VdbeAddOp2 ( v , OP_Integer , 0 , iUseFlag ) ; VdbeComment ( ( v , \"indicate<S2SV_blank>accumulator<S2SV_blank>empty\" ) ) ; sqlite3VdbeAddOp1 ( v , OP_Return , regReset ) ; } else { # ifndef SQLITE_OMIT_BTREECOUNT Table * pTab ; if ( ( pTab = isSimpleCount ( p , & sAggInfo ) ) != 0 ) { const int iDb = sqlite3SchemaToIndex ( pParse -> db , pTab -> pSchema ) ; const int iCsr = pParse -> nTab ++ ; Index * pIdx ; KeyInfo * pKeyInfo = 0 ; Index * pBest = 0 ; int iRoot = pTab -> tnum ; sqlite3CodeVerifySchema ( pParse , iDb ) ; sqlite3TableLock ( pParse , iDb , pTab -> tnum , 0 , pTab -> zName ) ; if ( ! HasRowid ( pTab ) ) pBest = sqlite3PrimaryKeyIndex ( pTab ) ; for ( pIdx = pTab -> pIndex ; pIdx ; pIdx = pIdx -> pNext ) { if ( pIdx -> bUnordered == 0 && pIdx -> szIdxRow < pTab -> szTabRow && pIdx -> pPartIdxWhere == 0 && ( ! pBest || pIdx -> szIdxRow < pBest -> szIdxRow ) ) { pBest = pIdx ; } } if ( pBest ) { iRoot = pBest -> tnum ; pKeyInfo = sqlite3KeyInfoOfIndex ( pParse , pBest ) ; } sqlite3VdbeAddOp4Int ( v , OP_OpenRead , iCsr , iRoot , iDb , 1 ) ; if ( pKeyInfo ) { sqlite3VdbeChangeP4 ( v , - 1 , ( char * ) pKeyInfo , P4_KEYINFO ) ; } sqlite3VdbeAddOp2 ( v , OP_Count , iCsr , sAggInfo . aFunc [ 0 ] . iMem ) ; sqlite3VdbeAddOp1 ( v , OP_Close , iCsr ) ; explainSimpleCount ( pParse , pTab , pBest ) ; } else # endif { int regAcc = 0 ; if ( sAggInfo . nAccumulator ) { for ( i = 0 ; i < sAggInfo . nFunc ; i ++ ) { if ( ExprHasProperty ( sAggInfo . aFunc [ i ] . pExpr , EP_WinFunc ) ) continue ; if ( sAggInfo . aFunc [ i ] . pFunc -> funcFlags & SQLITE_FUNC_NEEDCOLL ) break ; } if ( i == sAggInfo . nFunc ) { regAcc = ++ pParse -> nMem ; sqlite3VdbeAddOp2 ( v , OP_Integer , 0 , regAcc ) ; } } assert ( p -> pGroupBy == 0 ) ; resetAccumulator ( pParse , & sAggInfo ) ; assert ( minMaxFlag == WHERE_ORDERBY_NORMAL || pMinMaxOrderBy != 0 ) ; assert ( pMinMaxOrderBy == 0 || pMinMaxOrderBy -> nExpr == 1 ) ; SELECTTRACE ( 1 , pParse , p , ( \"WhereBegin\\\\n\" ) ) ; pWInfo = sqlite3WhereBegin ( pParse , pTabList , pWhere , pMinMaxOrderBy , 0 , minMaxFlag , 0 ) ; if ( pWInfo == 0 ) { goto select_end ; } updateAccumulator ( pParse , regAcc , & sAggInfo ) ; if ( regAcc ) sqlite3VdbeAddOp2 ( v , OP_Integer , 1 , regAcc ) ; if ( sqlite3WhereIsOrdered ( pWInfo ) > 0 ) { sqlite3VdbeGoto ( v , sqlite3WhereBreakLabel ( pWInfo ) ) ; VdbeComment ( ( v , \"%s()<S2SV_blank>by<S2SV_blank>index\" , ( minMaxFlag == WHERE_ORDERBY_MIN ? \"min\" : \"max\" ) ) ) ; } sqlite3WhereEnd ( pWInfo ) ; finalizeAggFunctions ( pParse , & sAggInfo ) ; } sSort . pOrderBy = 0 ; sqlite3ExprIfFalse ( pParse , pHaving , addrEnd , SQLITE_JUMPIFNULL ) ; selectInnerLoop ( pParse , p , - 1 , 0 , 0 , pDest , addrEnd , addrEnd ) ; } sqlite3VdbeResolveLabel ( v , addrEnd ) ; } if ( sDistinct . eTnctType == WHERE_DISTINCT_UNORDERED ) { explainTempTable ( pParse , \"DISTINCT\" ) ; } if ( sSort . pOrderBy ) { explainTempTable ( pParse , sSort . nOBSat > 0 ? \"RIGHT<S2SV_blank>PART<S2SV_blank>OF<S2SV_blank>ORDER<S2SV_blank>BY\" : \"ORDER<S2SV_blank>BY\" ) ; assert ( p -> pEList == pEList ) ; generateSortTail ( pParse , p , & sSort , pEList -> nExpr , pDest ) ; } sqlite3VdbeResolveLabel ( v , iEnd ) ; rc = ( pParse -> nErr > 0 ) ; select_end : sqlite3ExprListDelete ( db , pMinMaxOrderBy ) ; sqlite3DbFree ( db , sAggInfo . aCol ) ; sqlite3DbFree ( db , sAggInfo . aFunc ) ; # if SELECTTRACE_ENABLED SELECTTRACE ( 0x1 , pParse , p , ( \"end<S2SV_blank>processing\\\\n\" ) ) ; if ( ( sqlite3SelectTrace & 0x2000 ) != 0 && ExplainQueryPlanParent ( pParse ) == 0 ) { sqlite3TreeViewSelect ( 0 , p , 0 ) ; } # endif ExplainQueryPlanPop ( pParse ) ; return rc ; }\n",
      "fixed_code": "<S2SV_ModStart> ) == 0 && p -> pWin == 0\n",
      "source_code_length": 25653,
      "target_code_length": 41,
      "vulnerability_patterns": {
        "buffer_overflow": 3,
        "integer_overflow": 34,
        "null_pointer": 229,
        "sql_injection": 4,
        "total": 270
      },
      "total_patterns": 270,
      "original_address": "https://github.com/sqlite/sqlite/commit/e59c562b3f6894f84c715772c4b116d7b5c01348",
      "discovery_time": "2019-11-25T20:15Z",
      "project_commit_id": "sqlite@sqlite/e59c562b3f6894f84c715772c4b116d7b5c01348",
      "extraction_time": "2025-08-31T15:41:49.174474",
      "label": 1,
      "vulnerability_type": "unknown/uncategorized",
      "difficulty_level": "expert",
      "risk_factors": [
        "critical_infrastructure",
        "sql_injection",
        "buffer_overflow"
      ],
      "attack_vectors": [
        "fuzzing",
        "code_analysis",
        "reverse_engineering"
      ],
      "mitigation_strategies": [
        "dynamic_analysis",
        "static_analysis",
        "fuzzing",
        "code_review",
        "secure_coding_practices"
      ],
      "code_differences": {
        "has_differences": true,
        "source_lines": 2,
        "target_lines": 2,
        "character_differences": 25612,
        "similarity_percentage": 1.5418502202643172
      },
      "vulnerability_location": {
        "vulnerability_present": true,
        "fix_applied": true,
        "code_changed": true,
        "estimated_lines_changed": 0
      }
    },
    {
      "cve_id": "CVE-2016-10190",
      "cwe_id": "CWE-119",
      "cwe_name": "Buffer Overflow",
      "project": "FFmpeg",
      "severity": "critical",
      "weaponization_score": 10.0,
      "is_critical": true,
      "is_weaponizable": true,
      "is_high_priority_project": true,
      "vulnerable_code": "CWE-119 static int process_line ( URLContext * h , char * line , int line_count , int * new_location ) { HTTPContext * s = h -> priv_data ; const char * auto_method = h -> flags & AVIO_FLAG_READ ? \"POST\" : \"GET\" ; char * tag , * p , * end , * method , * resource , * version ; int ret ; if ( line [ 0 ] == '\\\\0' ) { s -> end_header = 1 ; return 0 ; } p = line ; if ( line_count == 0 ) { if ( s -> is_connected_server ) { method = p ; while ( * p && ! av_isspace ( * p ) ) p ++ ; * ( p ++ ) = '\\\\0' ; av_log ( h , AV_LOG_TRACE , \"Received<S2SV_blank>method:<S2SV_blank>%s\\\\n\" , method ) ; if ( s -> method ) { if ( av_strcasecmp ( s -> method , method ) ) { av_log ( h , AV_LOG_ERROR , \"Received<S2SV_blank>and<S2SV_blank>expected<S2SV_blank>HTTP<S2SV_blank>method<S2SV_blank>do<S2SV_blank>not<S2SV_blank>match.<S2SV_blank>(%s<S2SV_blank>expected,<S2SV_blank>%s<S2SV_blank>received)\\\\n\" , s -> method , method ) ; return ff_http_averror ( 400 , AVERROR ( EIO ) ) ; } } else { av_log ( h , AV_LOG_TRACE , \"Autodetected<S2SV_blank>%s<S2SV_blank>HTTP<S2SV_blank>method\\\\n\" , auto_method ) ; if ( av_strcasecmp ( auto_method , method ) ) { av_log ( h , AV_LOG_ERROR , \"Received<S2SV_blank>and<S2SV_blank>autodetected<S2SV_blank>HTTP<S2SV_blank>method<S2SV_blank>did<S2SV_blank>not<S2SV_blank>match<S2SV_blank>\" \"(%s<S2SV_blank>autodetected<S2SV_blank>%s<S2SV_blank>received)\\\\n\" , auto_method , method ) ; return ff_http_averror ( 400 , AVERROR ( EIO ) ) ; } if ( ! ( s -> method = av_strdup ( method ) ) ) return AVERROR ( ENOMEM ) ; } while ( av_isspace ( * p ) ) p ++ ; resource = p ; while ( ! av_isspace ( * p ) ) p ++ ; * ( p ++ ) = '\\\\0' ; av_log ( h , AV_LOG_TRACE , \"Requested<S2SV_blank>resource:<S2SV_blank>%s\\\\n\" , resource ) ; if ( ! ( s -> resource = av_strdup ( resource ) ) ) return AVERROR ( ENOMEM ) ; while ( av_isspace ( * p ) ) p ++ ; version = p ; while ( * p && ! av_isspace ( * p ) ) p ++ ; * p = '\\\\0' ; if ( av_strncasecmp ( version , \"HTTP/\" , 5 ) ) { av_log ( h , AV_LOG_ERROR , \"Malformed<S2SV_blank>HTTP<S2SV_blank>version<S2SV_blank>string.\\\\n\" ) ; return ff_http_averror ( 400 , AVERROR ( EIO ) ) ; } av_log ( h , AV_LOG_TRACE , \"HTTP<S2SV_blank>version<S2SV_blank>string:<S2SV_blank>%s\\\\n\" , version ) ; } else { while ( ! av_isspace ( * p ) && * p != '\\\\0' ) p ++ ; while ( av_isspace ( * p ) ) p ++ ; s -> http_code = strtol ( p , & end , 10 ) ; av_log ( h , AV_LOG_TRACE , \"http_code=%d\\\\n\" , s -> http_code ) ; if ( ( ret = check_http_code ( h , s -> http_code , end ) ) < 0 ) return ret ; } } else { while ( * p != '\\\\0' && * p != ':' ) p ++ ; if ( * p != ':' ) return 1 ; * p = '\\\\0' ; tag = line ; p ++ ; while ( av_isspace ( * p ) ) p ++ ; if ( ! av_strcasecmp ( tag , \"Location\" ) ) { if ( ( ret = parse_location ( s , p ) ) < 0 ) return ret ; * new_location = 1 ; <S2SV_StartBug> } else if ( ! av_strcasecmp ( tag , \"Content-Length\" ) && s -> filesize == - 1 ) { <S2SV_EndBug> <S2SV_StartBug> s -> filesize = strtoll ( p , NULL , 10 ) ; <S2SV_EndBug> } else if ( ! av_strcasecmp ( tag , \"Content-Range\" ) ) { parse_content_range ( h , p ) ; } else if ( ! av_strcasecmp ( tag , \"Accept-Ranges\" ) && ! strncmp ( p , \"bytes\" , 5 ) && s -> seekable == - 1 ) { h -> is_streamed = 0 ; } else if ( ! av_strcasecmp ( tag , \"Transfer-Encoding\" ) && ! av_strncasecmp ( p , \"chunked\" , 7 ) ) { <S2SV_StartBug> s -> filesize = - 1 ; <S2SV_EndBug> s -> chunksize = 0 ; } else if ( ! av_strcasecmp ( tag , \"WWW-Authenticate\" ) ) { <S2SV_StartBug> ff_http_auth_handle_header ( & s -> auth_state , tag , p ) ; <S2SV_EndBug> } else if ( ! av_strcasecmp ( tag , \"Authentication-Info\" ) ) { ff_http_auth_handle_header ( & s -> auth_state , tag , p ) ; } else if ( ! av_strcasecmp ( tag , \"Proxy-Authenticate\" ) ) { ff_http_auth_handle_header ( & s -> proxy_auth_state , tag , p ) ; } else if ( ! av_strcasecmp ( tag , \"Connection\" ) ) { if ( ! strcmp ( p , \"close\" ) ) s -> willclose = 1 ; } else if ( ! av_strcasecmp ( tag , \"Server\" ) ) { if ( ! av_strcasecmp ( p , \"AkamaiGHost\" ) ) { s -> is_akamai = 1 ; } else if ( ! av_strncasecmp ( p , \"MediaGateway\" , 12 ) ) { s -> is_mediagateway = 1 ; } } else if ( ! av_strcasecmp ( tag , \"Content-Type\" ) ) { av_free ( s -> mime_type ) ; s -> mime_type = av_strdup ( p ) ; } else if ( ! av_strcasecmp ( tag , \"Set-Cookie\" ) ) { if ( parse_cookie ( s , p , & s -> cookie_dict ) ) av_log ( h , AV_LOG_WARNING , \"Unable<S2SV_blank>to<S2SV_blank>parse<S2SV_blank>\\'%s\\'\\\\n\" , p ) ; } else if ( ! av_strcasecmp ( tag , \"Icy-MetaInt\" ) ) { <S2SV_StartBug> s -> icy_metaint = strtoll ( p , NULL , 10 ) ; <S2SV_EndBug> } else if ( ! av_strncasecmp ( tag , \"Icy-\" , 4 ) ) { if ( ( ret = parse_icy ( s , tag , p ) ) < 0 ) return ret ; } else if ( ! av_strcasecmp ( tag , \"Content-Encoding\" ) ) { if ( ( ret = parse_content_encoding ( h , p ) ) < 0 ) return ret ; } } return 1 ; }\n",
      "fixed_code": "<S2SV_ModStart> -> filesize == UINT64_MAX <S2SV_ModEnd> ) { s <S2SV_ModStart> -> filesize = strtoull <S2SV_ModEnd> ( p , <S2SV_ModStart> -> filesize = UINT64_MAX ; s -> chunksize = 0 ; } else if ( ! av_strcasecmp ( tag , \"WWW-Authenticate\" ) ) { ff_http_auth_handle_header ( & s -> auth_state , tag , p ) ; } else if ( ! av_strcasecmp ( tag , \"Authentication-Info\" ) ) { ff_http_auth_handle_header ( & s -> auth_state , tag , p ) ; } else if ( ! av_strcasecmp ( tag , \"Proxy-Authenticate\" ) ) { ff_http_auth_handle_header ( & s -> proxy_auth_state , tag , p ) ; } else if ( ! av_strcasecmp ( tag , \"Connection\" ) ) { if ( ! strcmp ( p , \"close\" ) ) s -> willclose = 1 ; } else if ( ! av_strcasecmp ( tag , \"Server\" ) ) { if ( ! av_strcasecmp ( p , \"AkamaiGHost\" ) ) { s -> is_akamai = 1 ; } else if ( ! av_strncasecmp ( p , \"MediaGateway\" , 12 ) ) { s -> is_mediagateway = 1 ; } } else if ( ! av_strcasecmp ( tag , \"Content-Type\" ) ) { av_free ( s -> mime_type ) ; s -> mime_type = av_strdup ( p ) ; } else if ( ! av_strcasecmp ( tag , \"Set-Cookie\" ) ) { if ( parse_cookie ( s , p , <S2SV_ModEnd> & s -> <S2SV_ModStart> & s -> <S2SV_ModEnd> cookie_dict ) ) <S2SV_ModStart> -> icy_metaint = strtoull <S2SV_ModEnd> ( p ,\n",
      "source_code_length": 4836,
      "target_code_length": 1219,
      "vulnerability_patterns": {
        "use_after_free": 2,
        "integer_overflow": 12,
        "null_pointer": 28,
        "total": 42
      },
      "total_patterns": 42,
      "original_address": "https://github.com/FFmpeg/FFmpeg/commit/2a05c8f813de6f2278827734bf8102291e7484aa",
      "discovery_time": "2017-02-09T15:59Z",
      "project_commit_id": "FFmpeg@FFmpeg/2a05c8f813de6f2278827734bf8102291e7484aa",
      "extraction_time": "2025-08-31T15:41:49.174689",
      "label": 1,
      "vulnerability_type": "buffer_overflow",
      "difficulty_level": "expert",
      "risk_factors": [
        "memory_corruption",
        "critical_infrastructure",
        "arbitrary_code_execution",
        "system_crash",
        "use_after_free"
      ],
      "attack_vectors": [
        "memory_manipulation",
        "malicious_input",
        "code_analysis",
        "buffer_overflow",
        "reverse_engineering",
        "fuzzing"
      ],
      "mitigation_strategies": [
        "safe_string_functions",
        "dynamic_analysis",
        "code_review",
        "static_analysis",
        "memory_safety_checks",
        "input_validation",
        "fuzzing",
        "bounds_checking",
        "secure_coding_practices"
      ],
      "code_differences": {
        "has_differences": true,
        "source_lines": 2,
        "target_lines": 2,
        "character_differences": 3617,
        "similarity_percentage": 33.33333333333333
      },
      "vulnerability_location": {
        "vulnerability_present": true,
        "fix_applied": true,
        "code_changed": true,
        "estimated_lines_changed": 0
      }
    },
    {
      "cve_id": "CVE-2016-10208",
      "cwe_id": "CWE-125",
      "cwe_name": "Out-of-bounds Read",
      "project": "torvalds",
      "severity": "critical",
      "weaponization_score": 10.0,
      "is_critical": true,
      "is_weaponizable": true,
      "is_high_priority_project": false,
      "vulnerable_code": "CWE-125 static int ext4_fill_super ( struct super_block * sb , void * data , int silent ) { char * orig_data = kstrdup ( data , GFP_KERNEL ) ; struct buffer_head * bh ; struct ext4_super_block * es = NULL ; struct ext4_sb_info * sbi = kzalloc ( sizeof ( * sbi ) , GFP_KERNEL ) ; ext4_fsblk_t block ; ext4_fsblk_t sb_block = get_sb_block ( & data ) ; ext4_fsblk_t logical_sb_block ; unsigned long offset = 0 ; unsigned long journal_devnum = 0 ; unsigned long def_mount_opts ; struct inode * root ; const char * descr ; int ret = - ENOMEM ; int blocksize , clustersize ; unsigned int db_count ; unsigned int i ; int needs_recovery , has_huge_files , has_bigalloc ; __u64 blocks_count ; int err = 0 ; unsigned int journal_ioprio = DEFAULT_JOURNAL_IOPRIO ; ext4_group_t first_not_zeroed ; if ( ( data && ! orig_data ) || ! sbi ) goto out_free_base ; sbi -> s_blockgroup_lock = kzalloc ( sizeof ( struct blockgroup_lock ) , GFP_KERNEL ) ; if ( ! sbi -> s_blockgroup_lock ) goto out_free_base ; sb -> s_fs_info = sbi ; sbi -> s_sb = sb ; sbi -> s_inode_readahead_blks = EXT4_DEF_INODE_READAHEAD_BLKS ; sbi -> s_sb_block = sb_block ; if ( sb -> s_bdev -> bd_part ) sbi -> s_sectors_written_start = part_stat_read ( sb -> s_bdev -> bd_part , sectors [ 1 ] ) ; strreplace ( sb -> s_id , '/' , '!' ) ; ret = - EINVAL ; blocksize = sb_min_blocksize ( sb , EXT4_MIN_BLOCK_SIZE ) ; if ( ! blocksize ) { ext4_msg ( sb , KERN_ERR , \"unable<S2SV_blank>to<S2SV_blank>set<S2SV_blank>blocksize\" ) ; goto out_fail ; } if ( blocksize != EXT4_MIN_BLOCK_SIZE ) { logical_sb_block = sb_block * EXT4_MIN_BLOCK_SIZE ; offset = do_div ( logical_sb_block , blocksize ) ; } else { logical_sb_block = sb_block ; } if ( ! ( bh = sb_bread_unmovable ( sb , logical_sb_block ) ) ) { ext4_msg ( sb , KERN_ERR , \"unable<S2SV_blank>to<S2SV_blank>read<S2SV_blank>superblock\" ) ; goto out_fail ; } es = ( struct ext4_super_block * ) ( bh -> b_data + offset ) ; sbi -> s_es = es ; sb -> s_magic = le16_to_cpu ( es -> s_magic ) ; if ( sb -> s_magic != EXT4_SUPER_MAGIC ) goto cantfind_ext4 ; sbi -> s_kbytes_written = le64_to_cpu ( es -> s_kbytes_written ) ; if ( ext4_has_feature_metadata_csum ( sb ) && ext4_has_feature_gdt_csum ( sb ) ) ext4_warning ( sb , \"metadata_csum<S2SV_blank>and<S2SV_blank>uninit_bg<S2SV_blank>are<S2SV_blank>\" \"redundant<S2SV_blank>flags;<S2SV_blank>please<S2SV_blank>run<S2SV_blank>fsck.\" ) ; if ( ! ext4_verify_csum_type ( sb , es ) ) { ext4_msg ( sb , KERN_ERR , \"VFS:<S2SV_blank>Found<S2SV_blank>ext4<S2SV_blank>filesystem<S2SV_blank>with<S2SV_blank>\" \"unknown<S2SV_blank>checksum<S2SV_blank>algorithm.\" ) ; silent = 1 ; goto cantfind_ext4 ; } if ( ext4_has_feature_metadata_csum ( sb ) ) { sbi -> s_chksum_driver = crypto_alloc_shash ( \"crc32c\" , 0 , 0 ) ; if ( IS_ERR ( sbi -> s_chksum_driver ) ) { ext4_msg ( sb , KERN_ERR , \"Cannot<S2SV_blank>load<S2SV_blank>crc32c<S2SV_blank>driver.\" ) ; ret = PTR_ERR ( sbi -> s_chksum_driver ) ; sbi -> s_chksum_driver = NULL ; goto failed_mount ; } } if ( ! ext4_superblock_csum_verify ( sb , es ) ) { ext4_msg ( sb , KERN_ERR , \"VFS:<S2SV_blank>Found<S2SV_blank>ext4<S2SV_blank>filesystem<S2SV_blank>with<S2SV_blank>\" \"invalid<S2SV_blank>superblock<S2SV_blank>checksum.<S2SV_blank><S2SV_blank>Run<S2SV_blank>e2fsck?\" ) ; silent = 1 ; ret = - EFSBADCRC ; goto cantfind_ext4 ; } if ( ext4_has_feature_csum_seed ( sb ) ) sbi -> s_csum_seed = le32_to_cpu ( es -> s_checksum_seed ) ; else if ( ext4_has_metadata_csum ( sb ) ) sbi -> s_csum_seed = ext4_chksum ( sbi , ~ 0 , es -> s_uuid , sizeof ( es -> s_uuid ) ) ; def_mount_opts = le32_to_cpu ( es -> s_default_mount_opts ) ; set_opt ( sb , INIT_INODE_TABLE ) ; if ( def_mount_opts & EXT4_DEFM_DEBUG ) set_opt ( sb , DEBUG ) ; if ( def_mount_opts & EXT4_DEFM_BSDGROUPS ) set_opt ( sb , GRPID ) ; if ( def_mount_opts & EXT4_DEFM_UID16 ) set_opt ( sb , NO_UID32 ) ; set_opt ( sb , XATTR_USER ) ; # ifdef CONFIG_EXT4_FS_POSIX_ACL set_opt ( sb , POSIX_ACL ) ; # endif if ( ext4_has_metadata_csum ( sb ) ) set_opt ( sb , JOURNAL_CHECKSUM ) ; if ( ( def_mount_opts & EXT4_DEFM_JMODE ) == EXT4_DEFM_JMODE_DATA ) set_opt ( sb , JOURNAL_DATA ) ; else if ( ( def_mount_opts & EXT4_DEFM_JMODE ) == EXT4_DEFM_JMODE_ORDERED ) set_opt ( sb , ORDERED_DATA ) ; else if ( ( def_mount_opts & EXT4_DEFM_JMODE ) == EXT4_DEFM_JMODE_WBACK ) set_opt ( sb , WRITEBACK_DATA ) ; if ( le16_to_cpu ( sbi -> s_es -> s_errors ) == EXT4_ERRORS_PANIC ) set_opt ( sb , ERRORS_PANIC ) ; else if ( le16_to_cpu ( sbi -> s_es -> s_errors ) == EXT4_ERRORS_CONTINUE ) set_opt ( sb , ERRORS_CONT ) ; else set_opt ( sb , ERRORS_RO ) ; set_opt ( sb , BLOCK_VALIDITY ) ; if ( def_mount_opts & EXT4_DEFM_DISCARD ) set_opt ( sb , DISCARD ) ; sbi -> s_resuid = make_kuid ( & init_user_ns , le16_to_cpu ( es -> s_def_resuid ) ) ; sbi -> s_resgid = make_kgid ( & init_user_ns , le16_to_cpu ( es -> s_def_resgid ) ) ; sbi -> s_commit_interval = JBD2_DEFAULT_MAX_COMMIT_AGE * HZ ; sbi -> s_min_batch_time = EXT4_DEF_MIN_BATCH_TIME ; sbi -> s_max_batch_time = EXT4_DEF_MAX_BATCH_TIME ; if ( ( def_mount_opts & EXT4_DEFM_NOBARRIER ) == 0 ) set_opt ( sb , BARRIER ) ; if ( ! IS_EXT3_SB ( sb ) && ! IS_EXT2_SB ( sb ) && ( ( def_mount_opts & EXT4_DEFM_NODELALLOC ) == 0 ) ) set_opt ( sb , DELALLOC ) ; sbi -> s_li_wait_mult = EXT4_DEF_LI_WAIT_MULT ; if ( sbi -> s_es -> s_mount_opts [ 0 ] ) { char * s_mount_opts = kstrndup ( sbi -> s_es -> s_mount_opts , sizeof ( sbi -> s_es -> s_mount_opts ) , GFP_KERNEL ) ; if ( ! s_mount_opts ) goto failed_mount ; if ( ! parse_options ( s_mount_opts , sb , & journal_devnum , & journal_ioprio , 0 ) ) { ext4_msg ( sb , KERN_WARNING , \"failed<S2SV_blank>to<S2SV_blank>parse<S2SV_blank>options<S2SV_blank>in<S2SV_blank>superblock:<S2SV_blank>%s\" , s_mount_opts ) ; } kfree ( s_mount_opts ) ; } sbi -> s_def_mount_opt = sbi -> s_mount_opt ; if ( ! parse_options ( ( char * ) data , sb , & journal_devnum , & journal_ioprio , 0 ) ) goto failed_mount ; if ( test_opt ( sb , DATA_FLAGS ) == EXT4_MOUNT_JOURNAL_DATA ) { printk_once ( KERN_WARNING \"EXT4-fs:<S2SV_blank>Warning:<S2SV_blank>mounting<S2SV_blank>\" \"with<S2SV_blank>data=journal<S2SV_blank>disables<S2SV_blank>delayed<S2SV_blank>\" \"allocation<S2SV_blank>and<S2SV_blank>O_DIRECT<S2SV_blank>support!\\\\n\" ) ; if ( test_opt2 ( sb , EXPLICIT_DELALLOC ) ) { ext4_msg ( sb , KERN_ERR , \"can\\'t<S2SV_blank>mount<S2SV_blank>with<S2SV_blank>\" \"both<S2SV_blank>data=journal<S2SV_blank>and<S2SV_blank>delalloc\" ) ; goto failed_mount ; } if ( test_opt ( sb , DIOREAD_NOLOCK ) ) { ext4_msg ( sb , KERN_ERR , \"can\\'t<S2SV_blank>mount<S2SV_blank>with<S2SV_blank>\" \"both<S2SV_blank>data=journal<S2SV_blank>and<S2SV_blank>dioread_nolock\" ) ; goto failed_mount ; } if ( test_opt ( sb , DAX ) ) { ext4_msg ( sb , KERN_ERR , \"can\\'t<S2SV_blank>mount<S2SV_blank>with<S2SV_blank>\" \"both<S2SV_blank>data=journal<S2SV_blank>and<S2SV_blank>dax\" ) ; goto failed_mount ; } if ( test_opt ( sb , DELALLOC ) ) clear_opt ( sb , DELALLOC ) ; } else { sb -> s_iflags |= SB_I_CGROUPWB ; } sb -> s_flags = ( sb -> s_flags & ~ MS_POSIXACL ) | ( test_opt ( sb , POSIX_ACL ) ? MS_POSIXACL : 0 ) ; if ( le32_to_cpu ( es -> s_rev_level ) == EXT4_GOOD_OLD_REV && ( ext4_has_compat_features ( sb ) || ext4_has_ro_compat_features ( sb ) || ext4_has_incompat_features ( sb ) ) ) ext4_msg ( sb , KERN_WARNING , \"feature<S2SV_blank>flags<S2SV_blank>set<S2SV_blank>on<S2SV_blank>rev<S2SV_blank>0<S2SV_blank>fs,<S2SV_blank>\" \"running<S2SV_blank>e2fsck<S2SV_blank>is<S2SV_blank>recommended\" ) ; if ( es -> s_creator_os == cpu_to_le32 ( EXT4_OS_HURD ) ) { set_opt2 ( sb , HURD_COMPAT ) ; if ( ext4_has_feature_64bit ( sb ) ) { ext4_msg ( sb , KERN_ERR , \"The<S2SV_blank>Hurd<S2SV_blank>can\\'t<S2SV_blank>support<S2SV_blank>64-bit<S2SV_blank>file<S2SV_blank>systems\" ) ; goto failed_mount ; } } if ( IS_EXT2_SB ( sb ) ) { if ( ext2_feature_set_ok ( sb ) ) ext4_msg ( sb , KERN_INFO , \"mounting<S2SV_blank>ext2<S2SV_blank>file<S2SV_blank>system<S2SV_blank>\" \"using<S2SV_blank>the<S2SV_blank>ext4<S2SV_blank>subsystem\" ) ; else { ext4_msg ( sb , KERN_ERR , \"couldn\\'t<S2SV_blank>mount<S2SV_blank>as<S2SV_blank>ext2<S2SV_blank>due<S2SV_blank>\" \"to<S2SV_blank>feature<S2SV_blank>incompatibilities\" ) ; goto failed_mount ; } } if ( IS_EXT3_SB ( sb ) ) { if ( ext3_feature_set_ok ( sb ) ) ext4_msg ( sb , KERN_INFO , \"mounting<S2SV_blank>ext3<S2SV_blank>file<S2SV_blank>system<S2SV_blank>\" \"using<S2SV_blank>the<S2SV_blank>ext4<S2SV_blank>subsystem\" ) ; else { ext4_msg ( sb , KERN_ERR , \"couldn\\'t<S2SV_blank>mount<S2SV_blank>as<S2SV_blank>ext3<S2SV_blank>due<S2SV_blank>\" \"to<S2SV_blank>feature<S2SV_blank>incompatibilities\" ) ; goto failed_mount ; } } if ( ! ext4_feature_set_ok ( sb , ( sb -> s_flags & MS_RDONLY ) ) ) goto failed_mount ; blocksize = BLOCK_SIZE << le32_to_cpu ( es -> s_log_block_size ) ; if ( blocksize < EXT4_MIN_BLOCK_SIZE || blocksize > EXT4_MAX_BLOCK_SIZE ) { ext4_msg ( sb , KERN_ERR , \"Unsupported<S2SV_blank>filesystem<S2SV_blank>blocksize<S2SV_blank>%d<S2SV_blank>(%d<S2SV_blank>log_block_size)\" , blocksize , le32_to_cpu ( es -> s_log_block_size ) ) ; goto failed_mount ; } if ( le32_to_cpu ( es -> s_log_block_size ) > ( EXT4_MAX_BLOCK_LOG_SIZE - EXT4_MIN_BLOCK_LOG_SIZE ) ) { ext4_msg ( sb , KERN_ERR , \"Invalid<S2SV_blank>log<S2SV_blank>block<S2SV_blank>size:<S2SV_blank>%u\" , le32_to_cpu ( es -> s_log_block_size ) ) ; goto failed_mount ; } if ( le16_to_cpu ( sbi -> s_es -> s_reserved_gdt_blocks ) > ( blocksize / 4 ) ) { ext4_msg ( sb , KERN_ERR , \"Number<S2SV_blank>of<S2SV_blank>reserved<S2SV_blank>GDT<S2SV_blank>blocks<S2SV_blank>insanely<S2SV_blank>large:<S2SV_blank>%d\" , le16_to_cpu ( sbi -> s_es -> s_reserved_gdt_blocks ) ) ; goto failed_mount ; } if ( sbi -> s_mount_opt & EXT4_MOUNT_DAX ) { err = bdev_dax_supported ( sb , blocksize ) ; if ( err ) goto failed_mount ; } if ( ext4_has_feature_encrypt ( sb ) && es -> s_encryption_level ) { ext4_msg ( sb , KERN_ERR , \"Unsupported<S2SV_blank>encryption<S2SV_blank>level<S2SV_blank>%d\" , es -> s_encryption_level ) ; goto failed_mount ; } if ( sb -> s_blocksize != blocksize ) { if ( ! sb_set_blocksize ( sb , blocksize ) ) { ext4_msg ( sb , KERN_ERR , \"bad<S2SV_blank>block<S2SV_blank>size<S2SV_blank>%d\" , blocksize ) ; goto failed_mount ; } brelse ( bh ) ; logical_sb_block = sb_block * EXT4_MIN_BLOCK_SIZE ; offset = do_div ( logical_sb_block , blocksize ) ; bh = sb_bread_unmovable ( sb , logical_sb_block ) ; if ( ! bh ) { ext4_msg ( sb , KERN_ERR , \"Can\\'t<S2SV_blank>read<S2SV_blank>superblock<S2SV_blank>on<S2SV_blank>2nd<S2SV_blank>try\" ) ; goto failed_mount ; } es = ( struct ext4_super_block * ) ( bh -> b_data + offset ) ; sbi -> s_es = es ; if ( es -> s_magic != cpu_to_le16 ( EXT4_SUPER_MAGIC ) ) { ext4_msg ( sb , KERN_ERR , \"Magic<S2SV_blank>mismatch,<S2SV_blank>very<S2SV_blank>weird!\" ) ; goto failed_mount ; } } has_huge_files = ext4_has_feature_huge_file ( sb ) ; sbi -> s_bitmap_maxbytes = ext4_max_bitmap_size ( sb -> s_blocksize_bits , has_huge_files ) ; sb -> s_maxbytes = ext4_max_size ( sb -> s_blocksize_bits , has_huge_files ) ; if ( le32_to_cpu ( es -> s_rev_level ) == EXT4_GOOD_OLD_REV ) { sbi -> s_inode_size = EXT4_GOOD_OLD_INODE_SIZE ; sbi -> s_first_ino = EXT4_GOOD_OLD_FIRST_INO ; } else { sbi -> s_inode_size = le16_to_cpu ( es -> s_inode_size ) ; sbi -> s_first_ino = le32_to_cpu ( es -> s_first_ino ) ; if ( ( sbi -> s_inode_size < EXT4_GOOD_OLD_INODE_SIZE ) || ( ! is_power_of_2 ( sbi -> s_inode_size ) ) || ( sbi -> s_inode_size > blocksize ) ) { ext4_msg ( sb , KERN_ERR , \"unsupported<S2SV_blank>inode<S2SV_blank>size:<S2SV_blank>%d\" , sbi -> s_inode_size ) ; goto failed_mount ; } if ( sbi -> s_inode_size > EXT4_GOOD_OLD_INODE_SIZE ) sb -> s_time_gran = 1 << ( EXT4_EPOCH_BITS - 2 ) ; } sbi -> s_desc_size = le16_to_cpu ( es -> s_desc_size ) ; if ( ext4_has_feature_64bit ( sb ) ) { if ( sbi -> s_desc_size < EXT4_MIN_DESC_SIZE_64BIT || sbi -> s_desc_size > EXT4_MAX_DESC_SIZE || ! is_power_of_2 ( sbi -> s_desc_size ) ) { ext4_msg ( sb , KERN_ERR , \"unsupported<S2SV_blank>descriptor<S2SV_blank>size<S2SV_blank>%lu\" , sbi -> s_desc_size ) ; goto failed_mount ; } } else sbi -> s_desc_size = EXT4_MIN_DESC_SIZE ; sbi -> s_blocks_per_group = le32_to_cpu ( es -> s_blocks_per_group ) ; sbi -> s_inodes_per_group = le32_to_cpu ( es -> s_inodes_per_group ) ; sbi -> s_inodes_per_block = blocksize / EXT4_INODE_SIZE ( sb ) ; if ( sbi -> s_inodes_per_block == 0 ) goto cantfind_ext4 ; if ( sbi -> s_inodes_per_group < sbi -> s_inodes_per_block || sbi -> s_inodes_per_group > blocksize * 8 ) { ext4_msg ( sb , KERN_ERR , \"invalid<S2SV_blank>inodes<S2SV_blank>per<S2SV_blank>group:<S2SV_blank>%lu\\\\n\" , sbi -> s_blocks_per_group ) ; goto failed_mount ; } sbi -> s_itb_per_group = sbi -> s_inodes_per_group / sbi -> s_inodes_per_block ; sbi -> s_desc_per_block = blocksize / EXT4_DESC_SIZE ( sb ) ; sbi -> s_sbh = bh ; sbi -> s_mount_state = le16_to_cpu ( es -> s_state ) ; sbi -> s_addr_per_block_bits = ilog2 ( EXT4_ADDR_PER_BLOCK ( sb ) ) ; sbi -> s_desc_per_block_bits = ilog2 ( EXT4_DESC_PER_BLOCK ( sb ) ) ; for ( i = 0 ; i < 4 ; i ++ ) sbi -> s_hash_seed [ i ] = le32_to_cpu ( es -> s_hash_seed [ i ] ) ; sbi -> s_def_hash_version = es -> s_def_hash_version ; if ( ext4_has_feature_dir_index ( sb ) ) { i = le32_to_cpu ( es -> s_flags ) ; if ( i & EXT2_FLAGS_UNSIGNED_HASH ) sbi -> s_hash_unsigned = 3 ; else if ( ( i & EXT2_FLAGS_SIGNED_HASH ) == 0 ) { # ifdef __CHAR_UNSIGNED__ if ( ! ( sb -> s_flags & MS_RDONLY ) ) es -> s_flags |= cpu_to_le32 ( EXT2_FLAGS_UNSIGNED_HASH ) ; sbi -> s_hash_unsigned = 3 ; # else if ( ! ( sb -> s_flags & MS_RDONLY ) ) es -> s_flags |= cpu_to_le32 ( EXT2_FLAGS_SIGNED_HASH ) ; # endif } } clustersize = BLOCK_SIZE << le32_to_cpu ( es -> s_log_cluster_size ) ; has_bigalloc = ext4_has_feature_bigalloc ( sb ) ; if ( has_bigalloc ) { if ( clustersize < blocksize ) { ext4_msg ( sb , KERN_ERR , \"cluster<S2SV_blank>size<S2SV_blank>(%d)<S2SV_blank>smaller<S2SV_blank>than<S2SV_blank>\" \"block<S2SV_blank>size<S2SV_blank>(%d)\" , clustersize , blocksize ) ; goto failed_mount ; } if ( le32_to_cpu ( es -> s_log_cluster_size ) > ( EXT4_MAX_CLUSTER_LOG_SIZE - EXT4_MIN_BLOCK_LOG_SIZE ) ) { ext4_msg ( sb , KERN_ERR , \"Invalid<S2SV_blank>log<S2SV_blank>cluster<S2SV_blank>size:<S2SV_blank>%u\" , le32_to_cpu ( es -> s_log_cluster_size ) ) ; goto failed_mount ; } sbi -> s_cluster_bits = le32_to_cpu ( es -> s_log_cluster_size ) - le32_to_cpu ( es -> s_log_block_size ) ; sbi -> s_clusters_per_group = le32_to_cpu ( es -> s_clusters_per_group ) ; if ( sbi -> s_clusters_per_group > blocksize * 8 ) { ext4_msg ( sb , KERN_ERR , \"#clusters<S2SV_blank>per<S2SV_blank>group<S2SV_blank>too<S2SV_blank>big:<S2SV_blank>%lu\" , sbi -> s_clusters_per_group ) ; goto failed_mount ; } if ( sbi -> s_blocks_per_group != ( sbi -> s_clusters_per_group * ( clustersize / blocksize ) ) ) { ext4_msg ( sb , KERN_ERR , \"blocks<S2SV_blank>per<S2SV_blank>group<S2SV_blank>(%lu)<S2SV_blank>and<S2SV_blank>\" \"clusters<S2SV_blank>per<S2SV_blank>group<S2SV_blank>(%lu)<S2SV_blank>inconsistent\" , sbi -> s_blocks_per_group , sbi -> s_clusters_per_group ) ; goto failed_mount ; } } else { if ( clustersize != blocksize ) { ext4_warning ( sb , \"fragment/cluster<S2SV_blank>size<S2SV_blank>(%d)<S2SV_blank>!=<S2SV_blank>\" \"block<S2SV_blank>size<S2SV_blank>(%d)\" , clustersize , blocksize ) ; clustersize = blocksize ; } if ( sbi -> s_blocks_per_group > blocksize * 8 ) { ext4_msg ( sb , KERN_ERR , \"#blocks<S2SV_blank>per<S2SV_blank>group<S2SV_blank>too<S2SV_blank>big:<S2SV_blank>%lu\" , sbi -> s_blocks_per_group ) ; goto failed_mount ; } sbi -> s_clusters_per_group = sbi -> s_blocks_per_group ; sbi -> s_cluster_bits = 0 ; } sbi -> s_cluster_ratio = clustersize / blocksize ; if ( sbi -> s_blocks_per_group == clustersize << 3 ) set_opt2 ( sb , STD_GROUP_SIZE ) ; err = generic_check_addressable ( sb -> s_blocksize_bits , ext4_blocks_count ( es ) ) ; if ( err ) { ext4_msg ( sb , KERN_ERR , \"filesystem\" \"<S2SV_blank>too<S2SV_blank>large<S2SV_blank>to<S2SV_blank>mount<S2SV_blank>safely<S2SV_blank>on<S2SV_blank>this<S2SV_blank>system\" ) ; if ( sizeof ( sector_t ) < 8 ) ext4_msg ( sb , KERN_WARNING , \"CONFIG_LBDAF<S2SV_blank>not<S2SV_blank>enabled\" ) ; goto failed_mount ; } if ( EXT4_BLOCKS_PER_GROUP ( sb ) == 0 ) goto cantfind_ext4 ; blocks_count = sb -> s_bdev -> bd_inode -> i_size >> sb -> s_blocksize_bits ; if ( blocks_count && ext4_blocks_count ( es ) > blocks_count ) { ext4_msg ( sb , KERN_WARNING , \"bad<S2SV_blank>geometry:<S2SV_blank>block<S2SV_blank>count<S2SV_blank>%llu<S2SV_blank>\" \"exceeds<S2SV_blank>size<S2SV_blank>of<S2SV_blank>device<S2SV_blank>(%llu<S2SV_blank>blocks)\" , ext4_blocks_count ( es ) , blocks_count ) ; goto failed_mount ; } if ( le32_to_cpu ( es -> s_first_data_block ) >= ext4_blocks_count ( es ) ) { ext4_msg ( sb , KERN_WARNING , \"bad<S2SV_blank>geometry:<S2SV_blank>first<S2SV_blank>data<S2SV_blank>\" \"block<S2SV_blank>%u<S2SV_blank>is<S2SV_blank>beyond<S2SV_blank>end<S2SV_blank>of<S2SV_blank>filesystem<S2SV_blank>(%llu)\" , le32_to_cpu ( es -> s_first_data_block ) , ext4_blocks_count ( es ) ) ; goto failed_mount ; } blocks_count = ( ext4_blocks_count ( es ) - le32_to_cpu ( es -> s_first_data_block ) + EXT4_BLOCKS_PER_GROUP ( sb ) - 1 ) ; do_div ( blocks_count , EXT4_BLOCKS_PER_GROUP ( sb ) ) ; if ( blocks_count > ( ( uint64_t ) 1 << 32 ) - EXT4_DESC_PER_BLOCK ( sb ) ) { ext4_msg ( sb , KERN_WARNING , \"groups<S2SV_blank>count<S2SV_blank>too<S2SV_blank>large:<S2SV_blank>%u<S2SV_blank>\" \"(block<S2SV_blank>count<S2SV_blank>%llu,<S2SV_blank>first<S2SV_blank>data<S2SV_blank>block<S2SV_blank>%u,<S2SV_blank>\" \"blocks<S2SV_blank>per<S2SV_blank>group<S2SV_blank>%lu)\" , sbi -> s_groups_count , ext4_blocks_count ( es ) , le32_to_cpu ( es -> s_first_data_block ) , EXT4_BLOCKS_PER_GROUP ( sb ) ) ; goto failed_mount ; } sbi -> s_groups_count = blocks_count ; sbi -> s_blockfile_groups = min_t ( ext4_group_t , sbi -> s_groups_count , ( EXT4_MAX_BLOCK_FILE_PHYS / EXT4_BLOCKS_PER_GROUP ( sb ) ) ) ; db_count = ( sbi -> s_groups_count + EXT4_DESC_PER_BLOCK ( sb ) - 1 ) / <S2SV_StartBug> EXT4_DESC_PER_BLOCK ( sb ) ; <S2SV_EndBug> sbi -> s_group_desc = ext4_kvmalloc ( db_count * sizeof ( struct buffer_head * ) , GFP_KERNEL ) ; if ( sbi -> s_group_desc == NULL ) { ext4_msg ( sb , KERN_ERR , \"not<S2SV_blank>enough<S2SV_blank>memory\" ) ; ret = - ENOMEM ; goto failed_mount ; } bgl_lock_init ( sbi -> s_blockgroup_lock ) ; for ( i = 0 ; i < db_count ; i ++ ) { block = descriptor_loc ( sb , logical_sb_block , i ) ; sbi -> s_group_desc [ i ] = sb_bread_unmovable ( sb , block ) ; if ( ! sbi -> s_group_desc [ i ] ) { ext4_msg ( sb , KERN_ERR , \"can\\'t<S2SV_blank>read<S2SV_blank>group<S2SV_blank>descriptor<S2SV_blank>%d\" , i ) ; db_count = i ; goto failed_mount2 ; } } if ( ! ext4_check_descriptors ( sb , logical_sb_block , & first_not_zeroed ) ) { ext4_msg ( sb , KERN_ERR , \"group<S2SV_blank>descriptors<S2SV_blank>corrupted!\" ) ; ret = - EFSCORRUPTED ; goto failed_mount2 ; } sbi -> s_gdb_count = db_count ; get_random_bytes ( & sbi -> s_next_generation , sizeof ( u32 ) ) ; spin_lock_init ( & sbi -> s_next_gen_lock ) ; setup_timer ( & sbi -> s_err_report , print_daily_error_info , ( unsigned long ) sb ) ; if ( ext4_es_register_shrinker ( sbi ) ) goto failed_mount3 ; sbi -> s_stripe = ext4_get_stripe_size ( sbi ) ; sbi -> s_extent_max_zeroout_kb = 32 ; sb -> s_op = & ext4_sops ; sb -> s_export_op = & ext4_export_ops ; sb -> s_xattr = ext4_xattr_handlers ; sb -> s_cop = & ext4_cryptops ; # ifdef CONFIG_QUOTA sb -> dq_op = & ext4_quota_operations ; if ( ext4_has_feature_quota ( sb ) ) sb -> s_qcop = & dquot_quotactl_sysfile_ops ; else sb -> s_qcop = & ext4_qctl_operations ; sb -> s_quota_types = QTYPE_MASK_USR | QTYPE_MASK_GRP | QTYPE_MASK_PRJ ; # endif memcpy ( sb -> s_uuid , es -> s_uuid , sizeof ( es -> s_uuid ) ) ; INIT_LIST_HEAD ( & sbi -> s_orphan ) ; mutex_init ( & sbi -> s_orphan_lock ) ; sb -> s_root = NULL ; needs_recovery = ( es -> s_last_orphan != 0 || ext4_has_feature_journal_needs_recovery ( sb ) ) ; if ( ext4_has_feature_mmp ( sb ) && ! ( sb -> s_flags & MS_RDONLY ) ) if ( ext4_multi_mount_protect ( sb , le64_to_cpu ( es -> s_mmp_block ) ) ) goto failed_mount3a ; if ( ! test_opt ( sb , NOLOAD ) && ext4_has_feature_journal ( sb ) ) { if ( ext4_load_journal ( sb , es , journal_devnum ) ) goto failed_mount3a ; } else if ( test_opt ( sb , NOLOAD ) && ! ( sb -> s_flags & MS_RDONLY ) && ext4_has_feature_journal_needs_recovery ( sb ) ) { ext4_msg ( sb , KERN_ERR , \"required<S2SV_blank>journal<S2SV_blank>recovery<S2SV_blank>\" \"suppressed<S2SV_blank>and<S2SV_blank>not<S2SV_blank>mounted<S2SV_blank>read-only\" ) ; goto failed_mount_wq ; } else { if ( test_opt2 ( sb , EXPLICIT_JOURNAL_CHECKSUM ) ) { ext4_msg ( sb , KERN_ERR , \"can\\'t<S2SV_blank>mount<S2SV_blank>with<S2SV_blank>\" \"journal_checksum,<S2SV_blank>fs<S2SV_blank>mounted<S2SV_blank>w/o<S2SV_blank>journal\" ) ; goto failed_mount_wq ; } if ( test_opt ( sb , JOURNAL_ASYNC_COMMIT ) ) { ext4_msg ( sb , KERN_ERR , \"can\\'t<S2SV_blank>mount<S2SV_blank>with<S2SV_blank>\" \"journal_async_commit,<S2SV_blank>fs<S2SV_blank>mounted<S2SV_blank>w/o<S2SV_blank>journal\" ) ; goto failed_mount_wq ; } if ( sbi -> s_commit_interval != JBD2_DEFAULT_MAX_COMMIT_AGE * HZ ) { ext4_msg ( sb , KERN_ERR , \"can\\'t<S2SV_blank>mount<S2SV_blank>with<S2SV_blank>\" \"commit=%lu,<S2SV_blank>fs<S2SV_blank>mounted<S2SV_blank>w/o<S2SV_blank>journal\" , sbi -> s_commit_interval / HZ ) ; goto failed_mount_wq ; } if ( EXT4_MOUNT_DATA_FLAGS & ( sbi -> s_mount_opt ^ sbi -> s_def_mount_opt ) ) { ext4_msg ( sb , KERN_ERR , \"can\\'t<S2SV_blank>mount<S2SV_blank>with<S2SV_blank>\" \"data=,<S2SV_blank>fs<S2SV_blank>mounted<S2SV_blank>w/o<S2SV_blank>journal\" ) ; goto failed_mount_wq ; } sbi -> s_def_mount_opt &= EXT4_MOUNT_JOURNAL_CHECKSUM ; clear_opt ( sb , JOURNAL_CHECKSUM ) ; clear_opt ( sb , DATA_FLAGS ) ; sbi -> s_journal = NULL ; needs_recovery = 0 ; goto no_journal ; } if ( ext4_has_feature_64bit ( sb ) && ! jbd2_journal_set_features ( EXT4_SB ( sb ) -> s_journal , 0 , 0 , JBD2_FEATURE_INCOMPAT_64BIT ) ) { ext4_msg ( sb , KERN_ERR , \"Failed<S2SV_blank>to<S2SV_blank>set<S2SV_blank>64-bit<S2SV_blank>journal<S2SV_blank>feature\" ) ; goto failed_mount_wq ; } if ( ! set_journal_csum_feature_set ( sb ) ) { ext4_msg ( sb , KERN_ERR , \"Failed<S2SV_blank>to<S2SV_blank>set<S2SV_blank>journal<S2SV_blank>checksum<S2SV_blank>\" \"feature<S2SV_blank>set\" ) ; goto failed_mount_wq ; } switch ( test_opt ( sb , DATA_FLAGS ) ) { case 0 : if ( jbd2_journal_check_available_features ( sbi -> s_journal , 0 , 0 , JBD2_FEATURE_INCOMPAT_REVOKE ) ) set_opt ( sb , ORDERED_DATA ) ; else set_opt ( sb , JOURNAL_DATA ) ; break ; case EXT4_MOUNT_ORDERED_DATA : case EXT4_MOUNT_WRITEBACK_DATA : if ( ! jbd2_journal_check_available_features ( sbi -> s_journal , 0 , 0 , JBD2_FEATURE_INCOMPAT_REVOKE ) ) { ext4_msg ( sb , KERN_ERR , \"Journal<S2SV_blank>does<S2SV_blank>not<S2SV_blank>support<S2SV_blank>\" \"requested<S2SV_blank>data<S2SV_blank>journaling<S2SV_blank>mode\" ) ; goto failed_mount_wq ; } default : break ; } set_task_ioprio ( sbi -> s_journal -> j_task , journal_ioprio ) ; sbi -> s_journal -> j_commit_callback = ext4_journal_commit_callback ; no_journal : sbi -> s_mb_cache = ext4_xattr_create_cache ( ) ; if ( ! sbi -> s_mb_cache ) { ext4_msg ( sb , KERN_ERR , \"Failed<S2SV_blank>to<S2SV_blank>create<S2SV_blank>an<S2SV_blank>mb_cache\" ) ; goto failed_mount_wq ; } if ( ( DUMMY_ENCRYPTION_ENABLED ( sbi ) || ext4_has_feature_encrypt ( sb ) ) && ( blocksize != PAGE_SIZE ) ) { ext4_msg ( sb , KERN_ERR , \"Unsupported<S2SV_blank>blocksize<S2SV_blank>for<S2SV_blank>fs<S2SV_blank>encryption\" ) ; goto failed_mount_wq ; } if ( DUMMY_ENCRYPTION_ENABLED ( sbi ) && ! ( sb -> s_flags & MS_RDONLY ) && ! ext4_has_feature_encrypt ( sb ) ) { ext4_set_feature_encrypt ( sb ) ; ext4_commit_super ( sb , 1 ) ; } if ( es -> s_overhead_clusters ) sbi -> s_overhead = le32_to_cpu ( es -> s_overhead_clusters ) ; else { err = ext4_calculate_overhead ( sb ) ; if ( err ) goto failed_mount_wq ; } EXT4_SB ( sb ) -> rsv_conversion_wq = alloc_workqueue ( \"ext4-rsv-conversion\" , WQ_MEM_RECLAIM | WQ_UNBOUND , 1 ) ; if ( ! EXT4_SB ( sb ) -> rsv_conversion_wq ) { printk ( KERN_ERR \"EXT4-fs:<S2SV_blank>failed<S2SV_blank>to<S2SV_blank>create<S2SV_blank>workqueue\\\\n\" ) ; ret = - ENOMEM ; goto failed_mount4 ; } root = ext4_iget ( sb , EXT4_ROOT_INO ) ; if ( IS_ERR ( root ) ) { ext4_msg ( sb , KERN_ERR , \"get<S2SV_blank>root<S2SV_blank>inode<S2SV_blank>failed\" ) ; ret = PTR_ERR ( root ) ; root = NULL ; goto failed_mount4 ; } if ( ! S_ISDIR ( root -> i_mode ) || ! root -> i_blocks || ! root -> i_size ) { ext4_msg ( sb , KERN_ERR , \"corrupt<S2SV_blank>root<S2SV_blank>inode,<S2SV_blank>run<S2SV_blank>e2fsck\" ) ; iput ( root ) ; goto failed_mount4 ; } sb -> s_root = d_make_root ( root ) ; if ( ! sb -> s_root ) { ext4_msg ( sb , KERN_ERR , \"get<S2SV_blank>root<S2SV_blank>dentry<S2SV_blank>failed\" ) ; ret = - ENOMEM ; goto failed_mount4 ; } if ( ext4_setup_super ( sb , es , sb -> s_flags & MS_RDONLY ) ) sb -> s_flags |= MS_RDONLY ; if ( sbi -> s_inode_size > EXT4_GOOD_OLD_INODE_SIZE ) { sbi -> s_want_extra_isize = sizeof ( struct ext4_inode ) - EXT4_GOOD_OLD_INODE_SIZE ; if ( ext4_has_feature_extra_isize ( sb ) ) { if ( sbi -> s_want_extra_isize < le16_to_cpu ( es -> s_want_extra_isize ) ) sbi -> s_want_extra_isize = le16_to_cpu ( es -> s_want_extra_isize ) ; if ( sbi -> s_want_extra_isize < le16_to_cpu ( es -> s_min_extra_isize ) ) sbi -> s_want_extra_isize = le16_to_cpu ( es -> s_min_extra_isize ) ; } } if ( EXT4_GOOD_OLD_INODE_SIZE + sbi -> s_want_extra_isize > sbi -> s_inode_size ) { sbi -> s_want_extra_isize = sizeof ( struct ext4_inode ) - EXT4_GOOD_OLD_INODE_SIZE ; ext4_msg ( sb , KERN_INFO , \"required<S2SV_blank>extra<S2SV_blank>inode<S2SV_blank>space<S2SV_blank>not\" \"available\" ) ; } ext4_set_resv_clusters ( sb ) ; err = ext4_setup_system_zone ( sb ) ; if ( err ) { ext4_msg ( sb , KERN_ERR , \"failed<S2SV_blank>to<S2SV_blank>initialize<S2SV_blank>system<S2SV_blank>\" \"zone<S2SV_blank>(%d)\" , err ) ; goto failed_mount4a ; } ext4_ext_init ( sb ) ; err = ext4_mb_init ( sb ) ; if ( err ) { ext4_msg ( sb , KERN_ERR , \"failed<S2SV_blank>to<S2SV_blank>initialize<S2SV_blank>mballoc<S2SV_blank>(%d)\" , err ) ; goto failed_mount5 ; } block = ext4_count_free_clusters ( sb ) ; ext4_free_blocks_count_set ( sbi -> s_es , EXT4_C2B ( sbi , block ) ) ; err = percpu_counter_init ( & sbi -> s_freeclusters_counter , block , GFP_KERNEL ) ; if ( ! err ) { unsigned long freei = ext4_count_free_inodes ( sb ) ; sbi -> s_es -> s_free_inodes_count = cpu_to_le32 ( freei ) ; err = percpu_counter_init ( & sbi -> s_freeinodes_counter , freei , GFP_KERNEL ) ; } if ( ! err ) err = percpu_counter_init ( & sbi -> s_dirs_counter , ext4_count_dirs ( sb ) , GFP_KERNEL ) ; if ( ! err ) err = percpu_counter_init ( & sbi -> s_dirtyclusters_counter , 0 , GFP_KERNEL ) ; if ( ! err ) err = percpu_init_rwsem ( & sbi -> s_journal_flag_rwsem ) ; if ( err ) { ext4_msg ( sb , KERN_ERR , \"insufficient<S2SV_blank>memory\" ) ; goto failed_mount6 ; } if ( ext4_has_feature_flex_bg ( sb ) ) if ( ! ext4_fill_flex_info ( sb ) ) { ext4_msg ( sb , KERN_ERR , \"unable<S2SV_blank>to<S2SV_blank>initialize<S2SV_blank>\" \"flex_bg<S2SV_blank>meta<S2SV_blank>info!\" ) ; goto failed_mount6 ; } err = ext4_register_li_request ( sb , first_not_zeroed ) ; if ( err ) goto failed_mount6 ; err = ext4_register_sysfs ( sb ) ; if ( err ) goto failed_mount7 ; # ifdef CONFIG_QUOTA if ( ext4_has_feature_quota ( sb ) && ! ( sb -> s_flags & MS_RDONLY ) ) { err = ext4_enable_quotas ( sb ) ; if ( err ) goto failed_mount8 ; } # endif EXT4_SB ( sb ) -> s_mount_state |= EXT4_ORPHAN_FS ; ext4_orphan_cleanup ( sb , es ) ; EXT4_SB ( sb ) -> s_mount_state &= ~ EXT4_ORPHAN_FS ; if ( needs_recovery ) { ext4_msg ( sb , KERN_INFO , \"recovery<S2SV_blank>complete\" ) ; ext4_mark_recovery_complete ( sb , es ) ; } if ( EXT4_SB ( sb ) -> s_journal ) { if ( test_opt ( sb , DATA_FLAGS ) == EXT4_MOUNT_JOURNAL_DATA ) descr = \"<S2SV_blank>journalled<S2SV_blank>data<S2SV_blank>mode\" ; else if ( test_opt ( sb , DATA_FLAGS ) == EXT4_MOUNT_ORDERED_DATA ) descr = \"<S2SV_blank>ordered<S2SV_blank>data<S2SV_blank>mode\" ; else descr = \"<S2SV_blank>writeback<S2SV_blank>data<S2SV_blank>mode\" ; } else descr = \"out<S2SV_blank>journal\" ; if ( test_opt ( sb , DISCARD ) ) { struct request_queue * q = bdev_get_queue ( sb -> s_bdev ) ; if ( ! blk_queue_discard ( q ) ) ext4_msg ( sb , KERN_WARNING , \"mounting<S2SV_blank>with<S2SV_blank>\\\\\"discard\\\\\"<S2SV_blank>option,<S2SV_blank>but<S2SV_blank>\" \"the<S2SV_blank>device<S2SV_blank>does<S2SV_blank>not<S2SV_blank>support<S2SV_blank>discard\" ) ; } if ( ___ratelimit ( & ext4_mount_msg_ratelimit , \"EXT4-fs<S2SV_blank>mount\" ) ) ext4_msg ( sb , KERN_INFO , \"mounted<S2SV_blank>filesystem<S2SV_blank>with%s.<S2SV_blank>\" \"Opts:<S2SV_blank>%.*s%s%s\" , descr , ( int ) sizeof ( sbi -> s_es -> s_mount_opts ) , sbi -> s_es -> s_mount_opts , * sbi -> s_es -> s_mount_opts ? \";<S2SV_blank>\" : \"\" , orig_data ) ; if ( es -> s_error_count ) mod_timer ( & sbi -> s_err_report , jiffies + 300 * HZ ) ; ratelimit_state_init ( & sbi -> s_err_ratelimit_state , 5 * HZ , 10 ) ; ratelimit_state_init ( & sbi -> s_warning_ratelimit_state , 5 * HZ , 10 ) ; ratelimit_state_init ( & sbi -> s_msg_ratelimit_state , 5 * HZ , 10 ) ; kfree ( orig_data ) ; # ifdef CONFIG_EXT4_FS_ENCRYPTION memcpy ( sbi -> key_prefix , EXT4_KEY_DESC_PREFIX , EXT4_KEY_DESC_PREFIX_SIZE ) ; sbi -> key_prefix_size = EXT4_KEY_DESC_PREFIX_SIZE ; # endif return 0 ; cantfind_ext4 : if ( ! silent ) ext4_msg ( sb , KERN_ERR , \"VFS:<S2SV_blank>Can\\'t<S2SV_blank>find<S2SV_blank>ext4<S2SV_blank>filesystem\" ) ; goto failed_mount ; # ifdef CONFIG_QUOTA failed_mount8 : ext4_unregister_sysfs ( sb ) ; # endif failed_mount7 : ext4_unregister_li_request ( sb ) ; failed_mount6 : ext4_mb_release ( sb ) ; if ( sbi -> s_flex_groups ) kvfree ( sbi -> s_flex_groups ) ; percpu_counter_destroy ( & sbi -> s_freeclusters_counter ) ; percpu_counter_destroy ( & sbi -> s_freeinodes_counter ) ; percpu_counter_destroy ( & sbi -> s_dirs_counter ) ; percpu_counter_destroy ( & sbi -> s_dirtyclusters_counter ) ; failed_mount5 : ext4_ext_release ( sb ) ; ext4_release_system_zone ( sb ) ; failed_mount4a : dput ( sb -> s_root ) ; sb -> s_root = NULL ; failed_mount4 : ext4_msg ( sb , KERN_ERR , \"mount<S2SV_blank>failed\" ) ; if ( EXT4_SB ( sb ) -> rsv_conversion_wq ) destroy_workqueue ( EXT4_SB ( sb ) -> rsv_conversion_wq ) ; failed_mount_wq : if ( sbi -> s_mb_cache ) { ext4_xattr_destroy_cache ( sbi -> s_mb_cache ) ; sbi -> s_mb_cache = NULL ; } if ( sbi -> s_journal ) { jbd2_journal_destroy ( sbi -> s_journal ) ; sbi -> s_journal = NULL ; } failed_mount3a : ext4_es_unregister_shrinker ( sbi ) ; failed_mount3 : del_timer_sync ( & sbi -> s_err_report ) ; if ( sbi -> s_mmp_tsk ) kthread_stop ( sbi -> s_mmp_tsk ) ; failed_mount2 : for ( i = 0 ; i < db_count ; i ++ ) brelse ( sbi -> s_group_desc [ i ] ) ; kvfree ( sbi -> s_group_desc ) ; failed_mount : if ( sbi -> s_chksum_driver ) crypto_free_shash ( sbi -> s_chksum_driver ) ; # ifdef CONFIG_QUOTA for ( i = 0 ; i < EXT4_MAXQUOTAS ; i ++ ) kfree ( sbi -> s_qf_names [ i ] ) ; # endif ext4_blkdev_remove ( sbi ) ; brelse ( bh ) ; out_fail : sb -> s_fs_info = NULL ; kfree ( sbi -> s_blockgroup_lock ) ; out_free_base : kfree ( sbi ) ; kfree ( orig_data ) ; return err ? err : ret ; }\n",
      "fixed_code": "<S2SV_ModStart> sb ) ; if ( ext4_has_feature_meta_bg ( sb ) ) { if ( le32_to_cpu ( es -> s_first_meta_bg ) >= db_count ) { ext4_msg ( sb , KERN_WARNING , \"first<S2SV_blank>meta<S2SV_blank>block<S2SV_blank>group<S2SV_blank>too<S2SV_blank>large:<S2SV_blank>%u<S2SV_blank>\" \"(group<S2SV_blank>descriptor<S2SV_blank>block<S2SV_blank>count<S2SV_blank>%u)\" , le32_to_cpu ( es -> s_first_meta_bg ) , db_count ) ; goto failed_mount ; } }\n",
      "source_code_length": 31364,
      "target_code_length": 430,
      "vulnerability_patterns": {
        "buffer_overflow": 2,
        "use_after_free": 6,
        "integer_overflow": 4,
        "null_pointer": 297,
        "sql_injection": 2,
        "total": 311
      },
      "total_patterns": 311,
      "original_address": "https://github.com/torvalds/linux/commit/3a4b77cd47bb837b8557595ec7425f281f2ca1fe",
      "discovery_time": "2017-02-06T06:59Z",
      "project_commit_id": "torvalds@linux/3a4b77cd47bb837b8557595ec7425f281f2ca1fe",
      "extraction_time": "2025-08-31T15:41:49.174746",
      "label": 1,
      "vulnerability_type": "out-of-bounds_read",
      "difficulty_level": "expert",
      "risk_factors": [
        "memory_corruption",
        "sql_injection",
        "buffer_overflow",
        "information_disclosure",
        "use_after_free",
        "integer_overflow"
      ],
      "attack_vectors": [
        "memory_manipulation",
        "malicious_input",
        "code_analysis",
        "buffer_overflow",
        "reverse_engineering",
        "fuzzing"
      ],
      "mitigation_strategies": [
        "safe_string_functions",
        "dynamic_analysis",
        "code_review",
        "static_analysis",
        "memory_safety_checks",
        "input_validation",
        "fuzzing",
        "bounds_checking",
        "secure_coding_practices"
      ],
      "code_differences": {
        "has_differences": true,
        "source_lines": 2,
        "target_lines": 2,
        "character_differences": 30934,
        "similarity_percentage": 2.871621621621622
      },
      "vulnerability_location": {
        "vulnerability_present": true,
        "fix_applied": true,
        "code_changed": true,
        "estimated_lines_changed": 0
      }
    },
    {
      "cve_id": "CVE-2016-10190",
      "cwe_id": "CWE-119",
      "cwe_name": "Buffer Overflow",
      "project": "FFmpeg",
      "severity": "critical",
      "weaponization_score": 10.0,
      "is_critical": true,
      "is_weaponizable": true,
      "is_high_priority_project": true,
      "vulnerable_code": "CWE-119 static int process_line ( URLContext * h , char * line , int line_count , int * new_location ) { HTTPContext * s = h -> priv_data ; const char * auto_method = h -> flags & AVIO_FLAG_READ ? \"POST\" : \"GET\" ; char * tag , * p , * end , * method , * resource , * version ; int ret ; if ( line [ 0 ] == '\\\\0' ) { s -> end_header = 1 ; return 0 ; } p = line ; if ( line_count == 0 ) { if ( s -> is_connected_server ) { method = p ; while ( * p && ! av_isspace ( * p ) ) p ++ ; * ( p ++ ) = '\\\\0' ; av_log ( h , AV_LOG_TRACE , \"Received<S2SV_blank>method:<S2SV_blank>%s\\\\n\" , method ) ; if ( s -> method ) { if ( av_strcasecmp ( s -> method , method ) ) { av_log ( h , AV_LOG_ERROR , \"Received<S2SV_blank>and<S2SV_blank>expected<S2SV_blank>HTTP<S2SV_blank>method<S2SV_blank>do<S2SV_blank>not<S2SV_blank>match.<S2SV_blank>(%s<S2SV_blank>expected,<S2SV_blank>%s<S2SV_blank>received)\\\\n\" , s -> method , method ) ; return ff_http_averror ( 400 , AVERROR ( EIO ) ) ; } } else { av_log ( h , AV_LOG_TRACE , \"Autodetected<S2SV_blank>%s<S2SV_blank>HTTP<S2SV_blank>method\\\\n\" , auto_method ) ; if ( av_strcasecmp ( auto_method , method ) ) { av_log ( h , AV_LOG_ERROR , \"Received<S2SV_blank>and<S2SV_blank>autodetected<S2SV_blank>HTTP<S2SV_blank>method<S2SV_blank>did<S2SV_blank>not<S2SV_blank>match<S2SV_blank>\" \"(%s<S2SV_blank>autodetected<S2SV_blank>%s<S2SV_blank>received)\\\\n\" , auto_method , method ) ; return ff_http_averror ( 400 , AVERROR ( EIO ) ) ; } if ( ! ( s -> method = av_strdup ( method ) ) ) return AVERROR ( ENOMEM ) ; } while ( av_isspace ( * p ) ) p ++ ; resource = p ; while ( ! av_isspace ( * p ) ) p ++ ; * ( p ++ ) = '\\\\0' ; av_log ( h , AV_LOG_TRACE , \"Requested<S2SV_blank>resource:<S2SV_blank>%s\\\\n\" , resource ) ; if ( ! ( s -> resource = av_strdup ( resource ) ) ) return AVERROR ( ENOMEM ) ; while ( av_isspace ( * p ) ) p ++ ; version = p ; while ( * p && ! av_isspace ( * p ) ) p ++ ; * p = '\\\\0' ; if ( av_strncasecmp ( version , \"HTTP/\" , 5 ) ) { av_log ( h , AV_LOG_ERROR , \"Malformed<S2SV_blank>HTTP<S2SV_blank>version<S2SV_blank>string.\\\\n\" ) ; return ff_http_averror ( 400 , AVERROR ( EIO ) ) ; } av_log ( h , AV_LOG_TRACE , \"HTTP<S2SV_blank>version<S2SV_blank>string:<S2SV_blank>%s\\\\n\" , version ) ; } else { while ( ! av_isspace ( * p ) && * p != '\\\\0' ) p ++ ; while ( av_isspace ( * p ) ) p ++ ; s -> http_code = strtol ( p , & end , 10 ) ; av_log ( h , AV_LOG_TRACE , \"http_code=%d\\\\n\" , s -> http_code ) ; if ( ( ret = check_http_code ( h , s -> http_code , end ) ) < 0 ) return ret ; } } else { while ( * p != '\\\\0' && * p != ':' ) p ++ ; if ( * p != ':' ) return 1 ; * p = '\\\\0' ; tag = line ; p ++ ; while ( av_isspace ( * p ) ) p ++ ; if ( ! av_strcasecmp ( tag , \"Location\" ) ) { if ( ( ret = parse_location ( s , p ) ) < 0 ) return ret ; * new_location = 1 ; <S2SV_StartBug> } else if ( ! av_strcasecmp ( tag , \"Content-Length\" ) && s -> filesize == - 1 ) { <S2SV_EndBug> <S2SV_StartBug> s -> filesize = strtoll ( p , NULL , 10 ) ; <S2SV_EndBug> } else if ( ! av_strcasecmp ( tag , \"Content-Range\" ) ) { parse_content_range ( h , p ) ; } else if ( ! av_strcasecmp ( tag , \"Accept-Ranges\" ) && ! strncmp ( p , \"bytes\" , 5 ) && s -> seekable == - 1 ) { h -> is_streamed = 0 ; } else if ( ! av_strcasecmp ( tag , \"Transfer-Encoding\" ) && ! av_strncasecmp ( p , \"chunked\" , 7 ) ) { <S2SV_StartBug> s -> filesize = - 1 ; <S2SV_EndBug> s -> chunksize = 0 ; } else if ( ! av_strcasecmp ( tag , \"WWW-Authenticate\" ) ) { <S2SV_StartBug> ff_http_auth_handle_header ( & s -> auth_state , tag , p ) ; <S2SV_EndBug> } else if ( ! av_strcasecmp ( tag , \"Authentication-Info\" ) ) { ff_http_auth_handle_header ( & s -> auth_state , tag , p ) ; } else if ( ! av_strcasecmp ( tag , \"Proxy-Authenticate\" ) ) { ff_http_auth_handle_header ( & s -> proxy_auth_state , tag , p ) ; } else if ( ! av_strcasecmp ( tag , \"Connection\" ) ) { if ( ! strcmp ( p , \"close\" ) ) s -> willclose = 1 ; } else if ( ! av_strcasecmp ( tag , \"Server\" ) ) { if ( ! av_strcasecmp ( p , \"AkamaiGHost\" ) ) { s -> is_akamai = 1 ; } else if ( ! av_strncasecmp ( p , \"MediaGateway\" , 12 ) ) { s -> is_mediagateway = 1 ; } } else if ( ! av_strcasecmp ( tag , \"Content-Type\" ) ) { av_free ( s -> mime_type ) ; s -> mime_type = av_strdup ( p ) ; } else if ( ! av_strcasecmp ( tag , \"Set-Cookie\" ) ) { if ( parse_cookie ( s , p , & s -> cookie_dict ) ) av_log ( h , AV_LOG_WARNING , \"Unable<S2SV_blank>to<S2SV_blank>parse<S2SV_blank>\\'%s\\'\\\\n\" , p ) ; } else if ( ! av_strcasecmp ( tag , \"Icy-MetaInt\" ) ) { <S2SV_StartBug> s -> icy_metaint = strtoll ( p , NULL , 10 ) ; <S2SV_EndBug> } else if ( ! av_strncasecmp ( tag , \"Icy-\" , 4 ) ) { if ( ( ret = parse_icy ( s , tag , p ) ) < 0 ) return ret ; } else if ( ! av_strcasecmp ( tag , \"Content-Encoding\" ) ) { if ( ( ret = parse_content_encoding ( h , p ) ) < 0 ) return ret ; } } return 1 ; }\n",
      "fixed_code": "<S2SV_ModStart> -> filesize == UINT64_MAX <S2SV_ModEnd> ) { s <S2SV_ModStart> -> filesize = strtoull <S2SV_ModEnd> ( p , <S2SV_ModStart> -> filesize = UINT64_MAX ; s -> chunksize = 0 ; } else if ( ! av_strcasecmp ( tag , \"WWW-Authenticate\" ) ) { ff_http_auth_handle_header ( & s -> auth_state , tag , p ) ; } else if ( ! av_strcasecmp ( tag , \"Authentication-Info\" ) ) { ff_http_auth_handle_header ( & s -> auth_state , tag , p ) ; } else if ( ! av_strcasecmp ( tag , \"Proxy-Authenticate\" ) ) { ff_http_auth_handle_header ( & s -> proxy_auth_state , tag , p ) ; } else if ( ! av_strcasecmp ( tag , \"Connection\" ) ) { if ( ! strcmp ( p , \"close\" ) ) s -> willclose = 1 ; } else if ( ! av_strcasecmp ( tag , \"Server\" ) ) { if ( ! av_strcasecmp ( p , \"AkamaiGHost\" ) ) { s -> is_akamai = 1 ; } else if ( ! av_strncasecmp ( p , \"MediaGateway\" , 12 ) ) { s -> is_mediagateway = 1 ; } } else if ( ! av_strcasecmp ( tag , \"Content-Type\" ) ) { av_free ( s -> mime_type ) ; s -> mime_type = av_strdup ( p ) ; } else if ( ! av_strcasecmp ( tag , \"Set-Cookie\" ) ) { if ( parse_cookie ( s , p , <S2SV_ModEnd> & s -> <S2SV_ModStart> & s -> <S2SV_ModEnd> cookie_dict ) ) <S2SV_ModStart> -> icy_metaint = strtoull <S2SV_ModEnd> ( p ,\n",
      "source_code_length": 4836,
      "target_code_length": 1219,
      "vulnerability_patterns": {
        "buffer_overflow": 1,
        "integer_overflow": 3,
        "null_pointer": 19,
        "total": 23
      },
      "total_patterns": 23,
      "original_address": "https://github.com/FFmpeg/FFmpeg/commit/2a05c8f813de6f2278827734bf8102291e7484aa",
      "discovery_time": "2017-02-09T15:59Z",
      "project_commit_id": "FFmpeg@FFmpeg/2a05c8f813de6f2278827734bf8102291e7484aa",
      "extraction_time": "2025-08-31T15:41:49.174943",
      "label": 1,
      "vulnerability_type": "buffer_overflow",
      "difficulty_level": "expert",
      "risk_factors": [
        "memory_corruption",
        "critical_infrastructure",
        "arbitrary_code_execution",
        "buffer_overflow",
        "system_crash"
      ],
      "attack_vectors": [
        "memory_manipulation",
        "malicious_input",
        "code_analysis",
        "buffer_overflow",
        "reverse_engineering",
        "fuzzing"
      ],
      "mitigation_strategies": [
        "safe_string_functions",
        "dynamic_analysis",
        "code_review",
        "static_analysis",
        "memory_safety_checks",
        "input_validation",
        "fuzzing",
        "bounds_checking",
        "secure_coding_practices"
      ],
      "code_differences": {
        "has_differences": true,
        "source_lines": 2,
        "target_lines": 2,
        "character_differences": 3617,
        "similarity_percentage": 33.33333333333333
      },
      "vulnerability_location": {
        "vulnerability_present": true,
        "fix_applied": true,
        "code_changed": true,
        "estimated_lines_changed": 0
      }
    },
    {
      "cve_id": "CVE-2017-16805",
      "cwe_id": "CWE-125",
      "cwe_name": "Out-of-bounds Read",
      "project": "radare",
      "severity": "critical",
      "weaponization_score": 10.0,
      "is_critical": true,
      "is_weaponizable": true,
      "is_high_priority_project": true,
      "vulnerable_code": "CWE-125 static const ut8 * r_bin_dwarf_parse_attr_value ( const ut8 * obuf , int obuf_len , RBinDwarfAttrSpec * spec , RBinDwarfAttrValue * value , const RBinDwarfCompUnitHdr * hdr , const ut8 * debug_str , size_t debug_str_len ) { const ut8 * buf = obuf ; const ut8 * buf_end = obuf + obuf_len ; size_t j ; <S2SV_StartBug> if ( ! spec || ! value || ! hdr || ! obuf || obuf_len < 0 ) { <S2SV_EndBug> return NULL ; } value -> form = spec -> attr_form ; value -> name = spec -> attr_name ; value -> encoding . block . data = NULL ; value -> encoding . str_struct . string = NULL ; value -> encoding . str_struct . offset = 0 ; switch ( spec -> attr_form ) { case DW_FORM_addr : switch ( hdr -> pointer_size ) { case 1 : value -> encoding . address = READ ( buf , ut8 ) ; break ; case 2 : value -> encoding . address = READ ( buf , ut16 ) ; break ; case 4 : value -> encoding . address = READ ( buf , ut32 ) ; break ; case 8 : value -> encoding . address = READ ( buf , ut64 ) ; break ; default : eprintf ( \"DWARF:<S2SV_blank>Unexpected<S2SV_blank>pointer<S2SV_blank>size:<S2SV_blank>%u\\\\n\" , ( unsigned ) hdr -> pointer_size ) ; return NULL ; } break ; case DW_FORM_block2 : value -> encoding . block . length = READ ( buf , ut16 ) ; if ( value -> encoding . block . length > 0 ) { value -> encoding . block . data = calloc ( sizeof ( ut8 ) , value -> encoding . block . length ) ; for ( j = 0 ; j < value -> encoding . block . length ; j ++ ) { value -> encoding . block . data [ j ] = READ ( buf , ut8 ) ; } } break ; case DW_FORM_block4 : value -> encoding . block . length = READ ( buf , ut32 ) ; if ( value -> encoding . block . length > 0 ) { ut8 * data = calloc ( sizeof ( ut8 ) , value -> encoding . block . length ) ; if ( data ) { for ( j = 0 ; j < value -> encoding . block . length ; j ++ ) { data [ j ] = READ ( buf , ut8 ) ; } } value -> encoding . block . data = data ; } break ; <S2SV_StartBug> case DW_FORM_data2 : <S2SV_EndBug> value -> encoding . data = READ ( buf , ut16 ) ; break ; case DW_FORM_data4 : value -> encoding . data = READ ( buf , ut32 ) ; break ; case DW_FORM_data8 : value -> encoding . data = READ ( buf , ut64 ) ; <S2SV_StartBug> break ; <S2SV_EndBug> case DW_FORM_string : value -> encoding . str_struct . string = * buf ? strdup ( ( const char * ) buf ) : NULL ; buf += ( strlen ( ( const char * ) buf ) + 1 ) ; break ; case DW_FORM_block : buf = r_uleb128 ( buf , buf_end - buf , & value -> encoding . block . length ) ; if ( ! buf ) { return NULL ; } value -> encoding . block . data = calloc ( sizeof ( ut8 ) , value -> encoding . block . length ) ; <S2SV_StartBug> for ( j = 0 ; j < value -> encoding . block . length ; j ++ ) { <S2SV_EndBug> <S2SV_StartBug> value -> encoding . block . data [ j ] = READ ( buf , ut8 ) ; <S2SV_EndBug> } break ; case DW_FORM_block1 : value -> encoding . block . length = READ ( buf , ut8 ) ; value -> encoding . block . data = calloc ( sizeof ( ut8 ) , value -> encoding . block . length + 1 ) ; <S2SV_StartBug> for ( j = 0 ; j < value -> encoding . block . length ; j ++ ) { <S2SV_EndBug> <S2SV_StartBug> value -> encoding . block . data [ j ] = READ ( buf , ut8 ) ; <S2SV_EndBug> } break ; case DW_FORM_flag : value -> encoding . flag = READ ( buf , ut8 ) ; break ; case DW_FORM_sdata : buf = r_leb128 ( buf , & value -> encoding . sdata ) ; break ; case DW_FORM_strp : value -> encoding . str_struct . offset = READ ( buf , ut32 ) ; if ( debug_str && value -> encoding . str_struct . offset < debug_str_len ) { value -> encoding . str_struct . string = strdup ( ( const char * ) ( debug_str + value -> encoding . str_struct . offset ) ) ; } else { value -> encoding . str_struct . string = NULL ; } break ; case DW_FORM_udata : { ut64 ndata = 0 ; const ut8 * data = ( const ut8 * ) & ndata ; buf = r_uleb128 ( buf , R_MIN ( sizeof ( data ) , ( size_t ) ( buf_end - buf ) ) , & ndata ) ; memcpy ( & value -> encoding . data , data , sizeof ( value -> encoding . data ) ) ; value -> encoding . str_struct . string = NULL ; } break ; case DW_FORM_ref_addr : value -> encoding . reference = READ ( buf , ut64 ) ; break ; case DW_FORM_ref1 : value -> encoding . reference = READ ( buf , ut8 ) ; break ; case DW_FORM_ref2 : value -> encoding . reference = READ ( buf , ut16 ) ; break ; case DW_FORM_ref4 : value -> encoding . reference = READ ( buf , ut32 ) ; break ; case DW_FORM_ref8 : value -> encoding . reference = READ ( buf , ut64 ) ; break ; case DW_FORM_data1 : value -> encoding . data = READ ( buf , ut8 ) ; break ; default : eprintf ( \"Unknown<S2SV_blank>DW_FORM<S2SV_blank>0x%02\" PFMT64x \"\\\\n\" , spec -> attr_form ) ; value -> encoding . data = 0 ; return NULL ; } return buf ; }\n",
      "fixed_code": "<S2SV_ModStart> || obuf_len < 1 <S2SV_ModEnd> ) { return <S2SV_ModStart> } break ; # if 0 <S2SV_ModStart> ; break ; # endif <S2SV_ModStart> length ) ; if ( value -> encoding . block . data ) { <S2SV_ModStart> ut8 ) ; } <S2SV_ModStart> 1 ) ; if ( value -> encoding . block . data ) { <S2SV_ModStart> ut8 ) ; }\n",
      "source_code_length": 4664,
      "target_code_length": 309,
      "vulnerability_patterns": {
        "buffer_overflow": 1,
        "use_after_free": 4,
        "integer_overflow": 5,
        "null_pointer": 59,
        "memory_leak": 4,
        "total": 73
      },
      "total_patterns": 73,
      "original_address": "https://github.com/radare/radare2/commit/2ca9ab45891b6ae8e32b6c28c81eebca059cbe5d",
      "discovery_time": "2017-11-13T21:29Z",
      "project_commit_id": "radare@radare2/2ca9ab45891b6ae8e32b6c28c81eebca059cbe5d",
      "extraction_time": "2025-08-31T15:41:49.174995",
      "label": 1,
      "vulnerability_type": "out-of-bounds_read",
      "difficulty_level": "expert",
      "risk_factors": [
        "memory_corruption",
        "critical_infrastructure",
        "buffer_overflow",
        "information_disclosure",
        "use_after_free",
        "integer_overflow"
      ],
      "attack_vectors": [
        "memory_manipulation",
        "malicious_input",
        "code_analysis",
        "buffer_overflow",
        "reverse_engineering",
        "fuzzing"
      ],
      "mitigation_strategies": [
        "safe_string_functions",
        "dynamic_analysis",
        "code_review",
        "static_analysis",
        "memory_safety_checks",
        "input_validation",
        "fuzzing",
        "bounds_checking",
        "secure_coding_practices"
      ],
      "code_differences": {
        "has_differences": true,
        "source_lines": 2,
        "target_lines": 2,
        "character_differences": 4355,
        "similarity_percentage": 17.647058823529413
      },
      "vulnerability_location": {
        "vulnerability_present": true,
        "fix_applied": true,
        "code_changed": true,
        "estimated_lines_changed": 0
      }
    },
    {
      "cve_id": "CVE-2018-16425",
      "cwe_id": "CWE-415",
      "cwe_name": "Double Free",
      "project": "OpenSC",
      "severity": "critical",
      "weaponization_score": 10.0,
      "is_critical": true,
      "is_weaponizable": true,
      "is_high_priority_project": false,
      "vulnerable_code": "CWE-415 int sc_file_set_sec_attr ( sc_file_t * file , const u8 * sec_attr , size_t sec_attr_len ) { u8 * tmp ; if ( ! sc_file_valid ( file ) ) { return SC_ERROR_INVALID_ARGUMENTS ; } <S2SV_StartBug> if ( sec_attr == NULL ) { <S2SV_EndBug> if ( file -> sec_attr != NULL ) free ( file -> sec_attr ) ; file -> sec_attr = NULL ; file -> sec_attr_len = 0 ; return 0 ; } tmp = ( u8 * ) realloc ( file -> sec_attr , sec_attr_len ) ; if ( ! tmp ) { if ( file -> sec_attr ) free ( file -> sec_attr ) ; file -> sec_attr = NULL ; file -> sec_attr_len = 0 ; return SC_ERROR_OUT_OF_MEMORY ; } file -> sec_attr = tmp ; memcpy ( file -> sec_attr , sec_attr , sec_attr_len ) ; file -> sec_attr_len = sec_attr_len ; return 0 ; }\n",
      "fixed_code": "<S2SV_ModStart> sec_attr == NULL || sec_attr_len\n",
      "source_code_length": 712,
      "target_code_length": 49,
      "vulnerability_patterns": {
        "buffer_overflow": 9,
        "use_after_free": 4,
        "integer_overflow": 2,
        "null_pointer": 90,
        "sql_injection": 1,
        "memory_leak": 3,
        "total": 109
      },
      "total_patterns": 109,
      "original_address": "https://github.com/OpenSC/OpenSC/commit/360e95d45ac4123255a4c796db96337f332160ad",
      "discovery_time": "2018-09-04T00:29Z",
      "project_commit_id": "OpenSC@OpenSC/360e95d45ac4123255a4c796db96337f332160ad",
      "extraction_time": "2025-08-31T15:41:49.175047",
      "label": 1,
      "vulnerability_type": "double_free",
      "difficulty_level": "expert",
      "risk_factors": [
        "denial_of_service",
        "memory_corruption",
        "sql_injection",
        "buffer_overflow",
        "system_crash",
        "use_after_free"
      ],
      "attack_vectors": [
        "memory_manipulation",
        "null_pointer",
        "code_analysis",
        "reverse_engineering",
        "use_after_free",
        "fuzzing"
      ],
      "mitigation_strategies": [
        "null_pointer_checks",
        "fuzzing",
        "dynamic_analysis",
        "memory_management",
        "static_analysis",
        "use_after_free_prevention",
        "code_review",
        "secure_coding_practices"
      ],
      "code_differences": {
        "has_differences": true,
        "source_lines": 2,
        "target_lines": 2,
        "character_differences": 663,
        "similarity_percentage": 10.81081081081081
      },
      "vulnerability_location": {
        "vulnerability_present": true,
        "fix_applied": true,
        "code_changed": true,
        "estimated_lines_changed": 0
      }
    },
    {
      "cve_id": "CVE-2018-16644",
      "cwe_id": "CWE-119",
      "cwe_name": "Buffer Overflow",
      "project": "ImageMagick",
      "severity": "critical",
      "weaponization_score": 10.0,
      "is_critical": true,
      "is_weaponizable": true,
      "is_high_priority_project": true,
      "vulnerable_code": "CWE-119 static Image * ReadDCMImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { <S2SV_StartBug> # define ThrowDCMException ( exception , message ) { if ( info . scale != ( Quantum * ) NULL ) info . scale = ( Quantum * ) RelinquishMagickMemory ( info . scale ) ; if ( data != ( unsigned char * ) NULL ) data = ( unsigned char * ) RelinquishMagickMemory ( data ) ; if ( graymap != ( int * ) NULL ) graymap = ( int * ) RelinquishMagickMemory ( graymap ) ; if ( bluemap != ( int * ) NULL ) bluemap = ( int * ) RelinquishMagickMemory ( bluemap ) ; if ( greenmap != ( int * ) NULL ) greenmap = ( int * ) RelinquishMagickMemory ( greenmap ) ; if ( redmap != ( int * ) NULL ) redmap = ( int * ) RelinquishMagickMemory ( redmap ) ; if ( stream_info -> offsets != ( ssize_t * ) NULL ) stream_info -> offsets = ( ssize_t * ) RelinquishMagickMemory ( stream_info -> offsets ) ; if ( stream_info != ( DCMStreamInfo * ) NULL ) stream_info = ( DCMStreamInfo * ) RelinquishMagickMemory ( stream_info ) ; ThrowReaderException ( ( exception ) , ( message ) ) ; } <S2SV_EndBug> char explicit_vr [ MagickPathExtent ] , implicit_vr [ MagickPathExtent ] , magick [ MagickPathExtent ] , photometric [ MagickPathExtent ] ; DCMInfo info ; DCMStreamInfo * stream_info ; Image * image ; int * bluemap , datum , * greenmap , * graymap , * redmap ; MagickBooleanType explicit_file , explicit_retry , use_explicit ; MagickOffsetType offset ; register unsigned char * p ; register ssize_t i ; size_t colors , height , length , number_scenes , quantum , status , width ; ssize_t count , scene ; unsigned char * data ; unsigned short group , element ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickCoreSignature ) ; if ( image_info -> debug != MagickFalse ) ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , \"%s\" , image_info -> filename ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickCoreSignature ) ; image = AcquireImage ( image_info , exception ) ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } image -> depth = 8UL ; image -> endian = LSBEndian ; ( void ) memset ( & info , 0 , sizeof ( info ) ) ; data = ( unsigned char * ) NULL ; graymap = ( int * ) NULL ; redmap = ( int * ) NULL ; greenmap = ( int * ) NULL ; bluemap = ( int * ) NULL ; stream_info = ( DCMStreamInfo * ) AcquireMagickMemory ( sizeof ( * stream_info ) ) ; if ( stream_info == ( DCMStreamInfo * ) NULL ) ThrowDCMException ( ResourceLimitError , \"MemoryAllocationFailed\" ) ; ( void ) memset ( stream_info , 0 , sizeof ( * stream_info ) ) ; count = ReadBlob ( image , 128 , ( unsigned char * ) magick ) ; if ( count != 128 ) ThrowDCMException ( CorruptImageError , \"ImproperImageHeader\" ) ; count = ReadBlob ( image , 4 , ( unsigned char * ) magick ) ; if ( ( count != 4 ) || ( LocaleNCompare ( magick , \"DICM\" , 4 ) != 0 ) ) { offset = SeekBlob ( image , 0L , SEEK_SET ) ; if ( offset < 0 ) ThrowDCMException ( CorruptImageError , \"ImproperImageHeader\" ) ; } ( void ) CopyMagickString ( photometric , \"MONOCHROME1<S2SV_blank>\" , MagickPathExtent ) ; info . bits_allocated = 8 ; info . bytes_per_pixel = 1 ; info . depth = 8 ; info . mask = 0xffff ; info . max_value = 255UL ; info . samples_per_pixel = 1 ; info . signed_data = ( ~ 0UL ) ; info . rescale_slope = 1.0 ; data = ( unsigned char * ) NULL ; element = 0 ; explicit_vr [ 2 ] = '\\\\0' ; explicit_file = MagickFalse ; colors = 0 ; redmap = ( int * ) NULL ; greenmap = ( int * ) NULL ; bluemap = ( int * ) NULL ; graymap = ( int * ) NULL ; height = 0 ; number_scenes = 1 ; use_explicit = MagickFalse ; explicit_retry = MagickFalse ; width = 0 ; while ( TellBlob ( image ) < ( MagickOffsetType ) GetBlobSize ( image ) ) { for ( group = 0 ; ( group != 0x7FE0 ) || ( element != 0x0010 ) ; ) { image -> offset = ( ssize_t ) TellBlob ( image ) ; group = ReadBlobLSBShort ( image ) ; element = ReadBlobLSBShort ( image ) ; if ( ( group == 0xfffc ) && ( element == 0xfffc ) ) break ; if ( ( group != 0x0002 ) && ( image -> endian == MSBEndian ) ) { group = ( unsigned short ) ( ( group << 8 ) | ( ( group >> 8 ) & 0xFF ) ) ; element = ( unsigned short ) ( ( element << 8 ) | ( ( element >> 8 ) & 0xFF ) ) ; } quantum = 0 ; for ( i = 0 ; dicom_info [ i ] . group < 0xffff ; i ++ ) if ( ( group == dicom_info [ i ] . group ) && ( element == dicom_info [ i ] . element ) ) break ; ( void ) CopyMagickString ( implicit_vr , dicom_info [ i ] . vr , MagickPathExtent ) ; count = ReadBlob ( image , 2 , ( unsigned char * ) explicit_vr ) ; if ( count != 2 ) ThrowDCMException ( CorruptImageError , \"ImproperImageHeader\" ) ; if ( ( explicit_file == MagickFalse ) && ( group != 0x0002 ) ) explicit_file = ( isupper ( ( unsigned char ) * explicit_vr ) != MagickFalse ) && ( isupper ( ( unsigned char ) * ( explicit_vr + 1 ) ) != MagickFalse ) ? MagickTrue : MagickFalse ; use_explicit = ( ( group == 0x0002 ) && ( explicit_retry == MagickFalse ) ) || ( explicit_file != MagickFalse ) ? MagickTrue : MagickFalse ; if ( ( use_explicit != MagickFalse ) && ( strncmp ( implicit_vr , \"xs\" , 2 ) == 0 ) ) ( void ) CopyMagickString ( implicit_vr , explicit_vr , MagickPathExtent ) ; if ( ( use_explicit == MagickFalse ) || ( strncmp ( implicit_vr , \"!!\" , 2 ) == 0 ) ) { offset = SeekBlob ( image , ( MagickOffsetType ) - 2 , SEEK_CUR ) ; if ( offset < 0 ) ThrowDCMException ( CorruptImageError , \"ImproperImageHeader\" ) ; quantum = 4 ; } else { quantum = 2 ; if ( ( strncmp ( explicit_vr , \"OB\" , 2 ) == 0 ) || ( strncmp ( explicit_vr , \"UN\" , 2 ) == 0 ) || ( strncmp ( explicit_vr , \"OW\" , 2 ) == 0 ) || ( strncmp ( explicit_vr , \"SQ\" , 2 ) == 0 ) ) { ( void ) ReadBlobLSBShort ( image ) ; quantum = 4 ; } } datum = 0 ; if ( quantum == 4 ) { if ( group == 0x0002 ) datum = ReadBlobLSBSignedLong ( image ) ; else datum = ReadBlobSignedLong ( image ) ; } else if ( quantum == 2 ) { if ( group == 0x0002 ) datum = ReadBlobLSBSignedShort ( image ) ; else datum = ReadBlobSignedShort ( image ) ; } quantum = 0 ; length = 1 ; if ( datum != 0 ) { if ( ( strncmp ( implicit_vr , \"OW\" , 2 ) == 0 ) || ( strncmp ( implicit_vr , \"SS\" , 2 ) == 0 ) || ( strncmp ( implicit_vr , \"US\" , 2 ) == 0 ) ) quantum = 2 ; else if ( ( strncmp ( implicit_vr , \"FL\" , 2 ) == 0 ) || ( strncmp ( implicit_vr , \"OF\" , 2 ) == 0 ) || ( strncmp ( implicit_vr , \"SL\" , 2 ) == 0 ) || ( strncmp ( implicit_vr , \"UL\" , 2 ) == 0 ) ) quantum = 4 ; else if ( strncmp ( implicit_vr , \"FD\" , 2 ) == 0 ) quantum = 8 ; else quantum = 1 ; if ( datum != ~ 0 ) length = ( size_t ) datum / quantum ; else { quantum = 0 ; length = 0 ; } } if ( image_info -> verbose != MagickFalse ) { if ( use_explicit == MagickFalse ) explicit_vr [ 0 ] = '\\\\0' ; for ( i = 0 ; dicom_info [ i ] . description != ( char * ) NULL ; i ++ ) if ( ( group == dicom_info [ i ] . group ) && ( element == dicom_info [ i ] . element ) ) break ; ( void ) FormatLocaleFile ( stdout , \"0x%04lX<S2SV_blank>%4ld<S2SV_blank>%s-%s<S2SV_blank>(0x%04lx,0x%04lx)\" , ( unsigned long ) image -> offset , ( long ) length , implicit_vr , explicit_vr , ( unsigned long ) group , ( unsigned long ) element ) ; if ( dicom_info [ i ] . description != ( char * ) NULL ) ( void ) FormatLocaleFile ( stdout , \"<S2SV_blank>%s\" , dicom_info [ i ] . description ) ; ( void ) FormatLocaleFile ( stdout , \":<S2SV_blank>\" ) ; } if ( ( group == 0x7FE0 ) && ( element == 0x0010 ) ) { if ( image_info -> verbose != MagickFalse ) ( void ) FormatLocaleFile ( stdout , \"\\\\n\" ) ; break ; } data = ( unsigned char * ) NULL ; if ( ( length == 1 ) && ( quantum == 1 ) ) datum = ReadBlobByte ( image ) ; else if ( ( length == 1 ) && ( quantum == 2 ) ) { if ( group == 0x0002 ) datum = ReadBlobLSBSignedShort ( image ) ; else datum = ReadBlobSignedShort ( image ) ; } else if ( ( length == 1 ) && ( quantum == 4 ) ) { if ( group == 0x0002 ) datum = ReadBlobLSBSignedLong ( image ) ; else datum = ReadBlobSignedLong ( image ) ; } else if ( ( quantum != 0 ) && ( length != 0 ) ) { if ( length > ( size_t ) GetBlobSize ( image ) ) ThrowDCMException ( CorruptImageError , \"InsufficientImageDataInFile\" ) ; if ( ~ length >= 1 ) data = ( unsigned char * ) AcquireQuantumMemory ( length + 1 , quantum * sizeof ( * data ) ) ; if ( data == ( unsigned char * ) NULL ) ThrowDCMException ( ResourceLimitError , \"MemoryAllocationFailed\" ) ; count = ReadBlob ( image , ( size_t ) quantum * length , data ) ; if ( count != ( ssize_t ) ( quantum * length ) ) { if ( image_info -> verbose != MagickFalse ) ( void ) FormatLocaleFile ( stdout , \"count=%d<S2SV_blank>quantum=%d<S2SV_blank>\" \"length=%d<S2SV_blank>group=%d\\\\n\" , ( int ) count , ( int ) quantum , ( int ) length , ( int ) group ) ; ThrowDCMException ( CorruptImageError , \"InsufficientImageDataInFile\" ) ; } data [ length * quantum ] = '\\\\0' ; } if ( ( ( ( unsigned int ) group << 16 ) | element ) == 0xFFFEE0DD ) { if ( data != ( unsigned char * ) NULL ) data = ( unsigned char * ) RelinquishMagickMemory ( data ) ; continue ; } switch ( group ) { case 0x0002 : { switch ( element ) { case 0x0010 : { char transfer_syntax [ MagickPathExtent ] ; if ( ( datum == 0 ) && ( explicit_retry == MagickFalse ) ) { explicit_retry = MagickTrue ; ( void ) SeekBlob ( image , ( MagickOffsetType ) 0 , SEEK_SET ) ; group = 0 ; element = 0 ; if ( image_info -> verbose != MagickFalse ) ( void ) FormatLocaleFile ( stdout , \"Corrupted<S2SV_blank>image<S2SV_blank>-<S2SV_blank>trying<S2SV_blank>explicit<S2SV_blank>format\\\\n\" ) ; break ; } * transfer_syntax = '\\\\0' ; if ( data != ( unsigned char * ) NULL ) ( void ) CopyMagickString ( transfer_syntax , ( char * ) data , MagickPathExtent ) ; if ( image_info -> verbose != MagickFalse ) ( void ) FormatLocaleFile ( stdout , \"transfer_syntax=%s\\\\n\" , ( const char * ) transfer_syntax ) ; if ( strncmp ( transfer_syntax , \"1.2.840.10008.1.2\" , 17 ) == 0 ) { int subtype , type ; type = 1 ; subtype = 0 ; if ( strlen ( transfer_syntax ) > 17 ) { count = ( ssize_t ) sscanf ( transfer_syntax + 17 , \".%d.%d\" , & type , & subtype ) ; if ( count < 1 ) ThrowDCMException ( CorruptImageError , \"ImproperImageHeader\" ) ; } switch ( type ) { case 1 : { image -> endian = LSBEndian ; break ; } case 2 : { image -> endian = MSBEndian ; break ; } case 4 : { if ( ( subtype >= 80 ) && ( subtype <= 81 ) ) image -> compression = JPEGCompression ; else if ( ( subtype >= 90 ) && ( subtype <= 93 ) ) image -> compression = JPEG2000Compression ; else image -> compression = JPEGCompression ; break ; } case 5 : { image -> compression = RLECompression ; break ; } } } break ; } default : break ; } break ; } case 0x0028 : { switch ( element ) { case 0x0002 : { info . samples_per_pixel = ( size_t ) datum ; if ( ( info . samples_per_pixel == 0 ) || ( info . samples_per_pixel > 4 ) ) ThrowDCMException ( CorruptImageError , \"ImproperImageHeader\" ) ; break ; } case 0x0004 : { if ( data == ( unsigned char * ) NULL ) break ; for ( i = 0 ; i < ( ssize_t ) MagickMin ( length , MagickPathExtent - 1 ) ; i ++ ) photometric [ i ] = ( char ) data [ i ] ; photometric [ i ] = '\\\\0' ; info . polarity = LocaleCompare ( photometric , \"MONOCHROME1<S2SV_blank>\" ) == 0 ? MagickTrue : MagickFalse ; break ; } case 0x0006 : { if ( datum == 1 ) image -> interlace = PlaneInterlace ; break ; } case 0x0008 : { if ( data == ( unsigned char * ) NULL ) break ; number_scenes = StringToUnsignedLong ( ( char * ) data ) ; break ; } case 0x0010 : { height = ( size_t ) datum ; break ; } case 0x0011 : { width = ( size_t ) datum ; break ; } case 0x0100 : { info . bits_allocated = ( size_t ) datum ; info . bytes_per_pixel = 1 ; if ( datum > 8 ) info . bytes_per_pixel = 2 ; info . depth = info . bits_allocated ; if ( ( info . depth == 0 ) || ( info . depth > 32 ) ) ThrowDCMException ( CorruptImageError , \"ImproperImageHeader\" ) ; info . max_value = ( 1UL << info . bits_allocated ) - 1 ; image -> depth = info . depth ; break ; } case 0x0101 : { info . significant_bits = ( size_t ) datum ; info . bytes_per_pixel = 1 ; if ( info . significant_bits > 8 ) info . bytes_per_pixel = 2 ; info . depth = info . significant_bits ; if ( ( info . depth == 0 ) || ( info . depth > 16 ) ) ThrowDCMException ( CorruptImageError , \"ImproperImageHeader\" ) ; info . max_value = ( 1UL << info . significant_bits ) - 1 ; info . mask = ( size_t ) GetQuantumRange ( info . significant_bits ) ; image -> depth = info . depth ; break ; } case 0x0102 : { break ; } case 0x0103 : { info . signed_data = ( size_t ) datum ; break ; } case 0x1050 : { if ( data != ( unsigned char * ) NULL ) info . window_center = StringToDouble ( ( char * ) data , ( char * * ) NULL ) ; break ; } case 0x1051 : { if ( data != ( unsigned char * ) NULL ) info . window_width = StringToDouble ( ( char * ) data , ( char * * ) NULL ) ; break ; } case 0x1052 : { if ( data != ( unsigned char * ) NULL ) info . rescale_intercept = StringToDouble ( ( char * ) data , ( char * * ) NULL ) ; break ; } case 0x1053 : { if ( data != ( unsigned char * ) NULL ) info . rescale_slope = StringToDouble ( ( char * ) data , ( char * * ) NULL ) ; break ; } case 0x1200 : case 0x3006 : { if ( data == ( unsigned char * ) NULL ) break ; colors = ( size_t ) ( length / info . bytes_per_pixel ) ; datum = ( int ) colors ; if ( graymap != ( int * ) NULL ) graymap = ( int * ) RelinquishMagickMemory ( graymap ) ; graymap = ( int * ) AcquireQuantumMemory ( MagickMax ( colors , 65536 ) , sizeof ( * graymap ) ) ; if ( graymap == ( int * ) NULL ) ThrowDCMException ( ResourceLimitError , \"MemoryAllocationFailed\" ) ; ( void ) memset ( graymap , 0 , MagickMax ( colors , 65536 ) * sizeof ( * graymap ) ) ; for ( i = 0 ; i < ( ssize_t ) colors ; i ++ ) if ( info . bytes_per_pixel == 1 ) graymap [ i ] = ( int ) data [ i ] ; else graymap [ i ] = ( int ) ( ( short * ) data ) [ i ] ; break ; } case 0x1201 : { unsigned short index ; if ( data == ( unsigned char * ) NULL ) break ; colors = ( size_t ) ( length / 2 ) ; datum = ( int ) colors ; if ( redmap != ( int * ) NULL ) redmap = ( int * ) RelinquishMagickMemory ( redmap ) ; redmap = ( int * ) AcquireQuantumMemory ( MagickMax ( colors , 65536 ) , sizeof ( * redmap ) ) ; if ( redmap == ( int * ) NULL ) ThrowDCMException ( ResourceLimitError , \"MemoryAllocationFailed\" ) ; ( void ) memset ( redmap , 0 , MagickMax ( colors , 65536 ) * sizeof ( * redmap ) ) ; p = data ; for ( i = 0 ; i < ( ssize_t ) colors ; i ++ ) { if ( image -> endian == MSBEndian ) index = ( unsigned short ) ( ( * p << 8 ) | * ( p + 1 ) ) ; else index = ( unsigned short ) ( * p | ( * ( p + 1 ) << 8 ) ) ; redmap [ i ] = ( int ) index ; p += 2 ; } break ; } case 0x1202 : { unsigned short index ; if ( data == ( unsigned char * ) NULL ) break ; colors = ( size_t ) ( length / 2 ) ; datum = ( int ) colors ; if ( greenmap != ( int * ) NULL ) greenmap = ( int * ) RelinquishMagickMemory ( greenmap ) ; greenmap = ( int * ) AcquireQuantumMemory ( MagickMax ( colors , 65536 ) , sizeof ( * greenmap ) ) ; if ( greenmap == ( int * ) NULL ) ThrowDCMException ( ResourceLimitError , \"MemoryAllocationFailed\" ) ; ( void ) memset ( greenmap , 0 , MagickMax ( colors , 65536 ) * sizeof ( * greenmap ) ) ; p = data ; for ( i = 0 ; i < ( ssize_t ) colors ; i ++ ) { if ( image -> endian == MSBEndian ) index = ( unsigned short ) ( ( * p << 8 ) | * ( p + 1 ) ) ; else index = ( unsigned short ) ( * p | ( * ( p + 1 ) << 8 ) ) ; greenmap [ i ] = ( int ) index ; p += 2 ; } break ; } case 0x1203 : { unsigned short index ; if ( data == ( unsigned char * ) NULL ) break ; colors = ( size_t ) ( length / 2 ) ; datum = ( int ) colors ; if ( bluemap != ( int * ) NULL ) bluemap = ( int * ) RelinquishMagickMemory ( bluemap ) ; bluemap = ( int * ) AcquireQuantumMemory ( MagickMax ( colors , 65536 ) , sizeof ( * bluemap ) ) ; if ( bluemap == ( int * ) NULL ) ThrowDCMException ( ResourceLimitError , \"MemoryAllocationFailed\" ) ; ( void ) memset ( bluemap , 0 , MagickMax ( colors , 65536 ) * sizeof ( * bluemap ) ) ; p = data ; for ( i = 0 ; i < ( ssize_t ) colors ; i ++ ) { if ( image -> endian == MSBEndian ) index = ( unsigned short ) ( ( * p << 8 ) | * ( p + 1 ) ) ; else index = ( unsigned short ) ( * p | ( * ( p + 1 ) << 8 ) ) ; bluemap [ i ] = ( int ) index ; p += 2 ; } break ; } default : break ; } break ; } case 0x2050 : { switch ( element ) { case 0x0020 : { if ( ( data != ( unsigned char * ) NULL ) && ( strncmp ( ( char * ) data , \"INVERSE\" , 7 ) == 0 ) ) info . polarity = MagickTrue ; break ; } default : break ; } break ; } default : break ; } if ( data != ( unsigned char * ) NULL ) { char * attribute ; for ( i = 0 ; dicom_info [ i ] . description != ( char * ) NULL ; i ++ ) if ( ( group == dicom_info [ i ] . group ) && ( element == dicom_info [ i ] . element ) ) break ; if ( dicom_info [ i ] . description != ( char * ) NULL ) { attribute = AcquireString ( \"dcm:\" ) ; ( void ) ConcatenateString ( & attribute , dicom_info [ i ] . description ) ; for ( i = 0 ; i < ( ssize_t ) MagickMax ( length , 4 ) ; i ++ ) if ( isprint ( ( int ) data [ i ] ) == MagickFalse ) break ; if ( ( i == ( ssize_t ) length ) || ( length > 4 ) ) { ( void ) SubstituteString ( & attribute , \"<S2SV_blank>\" , \"\" ) ; ( void ) SetImageProperty ( image , attribute , ( char * ) data , exception ) ; } attribute = DestroyString ( attribute ) ; } } if ( image_info -> verbose != MagickFalse ) { if ( data == ( unsigned char * ) NULL ) ( void ) FormatLocaleFile ( stdout , \"%d\\\\n\" , datum ) ; else { for ( i = 0 ; i < ( ssize_t ) MagickMax ( length , 4 ) ; i ++ ) if ( isprint ( ( int ) data [ i ] ) == MagickFalse ) break ; if ( ( i != ( ssize_t ) length ) && ( length <= 4 ) ) { ssize_t j ; datum = 0 ; for ( j = ( ssize_t ) length - 1 ; j >= 0 ; j -- ) datum = ( 256 * datum + data [ j ] ) ; ( void ) FormatLocaleFile ( stdout , \"%d\" , datum ) ; } else for ( i = 0 ; i < ( ssize_t ) length ; i ++ ) if ( isprint ( ( int ) data [ i ] ) != MagickFalse ) ( void ) FormatLocaleFile ( stdout , \"%c\" , data [ i ] ) ; else ( void ) FormatLocaleFile ( stdout , \"%c\" , '.' ) ; ( void ) FormatLocaleFile ( stdout , \"\\\\n\" ) ; } } if ( data != ( unsigned char * ) NULL ) data = ( unsigned char * ) RelinquishMagickMemory ( data ) ; if ( EOFBlob ( image ) != MagickFalse ) { ThrowFileException ( exception , CorruptImageError , \"UnexpectedEndOfFile\" , image -> filename ) ; break ; } } if ( ( group == 0xfffc ) && ( element == 0xfffc ) ) { Image * last ; last = RemoveLastImageFromList ( & image ) ; if ( last != ( Image * ) NULL ) last = DestroyImage ( last ) ; break ; } if ( ( width == 0 ) || ( height == 0 ) ) ThrowDCMException ( CorruptImageError , \"ImproperImageHeader\" ) ; image -> columns = ( size_t ) width ; image -> rows = ( size_t ) height ; if ( info . signed_data == 0xffff ) info . signed_data = ( size_t ) ( info . significant_bits == 16 ? 1 : 0 ) ; if ( ( image -> compression == JPEGCompression ) || ( image -> compression == JPEG2000Compression ) ) { Image * images ; ImageInfo * read_info ; int c ; for ( i = 0 ; i < ( ssize_t ) stream_info -> remaining ; i ++ ) if ( ReadBlobByte ( image ) == EOF ) break ; ( void ) ( ( ( ssize_t ) ReadBlobLSBShort ( image ) << 16 ) | ReadBlobLSBShort ( image ) ) ; length = ( size_t ) ReadBlobLSBLong ( image ) ; if ( length > ( size_t ) GetBlobSize ( image ) ) ThrowDCMException ( CorruptImageError , \"InsufficientImageDataInFile\" ) ; stream_info -> offset_count = length >> 2 ; if ( stream_info -> offset_count != 0 ) { if ( stream_info -> offsets != ( ssize_t * ) NULL ) stream_info -> offsets = ( ssize_t * ) RelinquishMagickMemory ( stream_info -> offsets ) ; stream_info -> offsets = ( ssize_t * ) AcquireQuantumMemory ( stream_info -> offset_count , sizeof ( * stream_info -> offsets ) ) ; if ( stream_info -> offsets == ( ssize_t * ) NULL ) ThrowDCMException ( ResourceLimitError , \"MemoryAllocationFailed\" ) ; for ( i = 0 ; i < ( ssize_t ) stream_info -> offset_count ; i ++ ) stream_info -> offsets [ i ] = ( ssize_t ) ReadBlobLSBSignedLong ( image ) ; offset = TellBlob ( image ) ; for ( i = 0 ; i < ( ssize_t ) stream_info -> offset_count ; i ++ ) stream_info -> offsets [ i ] += offset ; } read_info = CloneImageInfo ( image_info ) ; SetImageInfoBlob ( read_info , ( void * ) NULL , 0 ) ; images = NewImageList ( ) ; for ( scene = 0 ; scene < ( ssize_t ) number_scenes ; scene ++ ) { char filename [ MagickPathExtent ] ; const char * property ; FILE * file ; Image * jpeg_image ; int unique_file ; unsigned int tag ; tag = ( ( unsigned int ) ReadBlobLSBShort ( image ) << 16 ) | ReadBlobLSBShort ( image ) ; length = ( size_t ) ReadBlobLSBLong ( image ) ; <S2SV_StartBug> if ( tag == 0xFFFEE0DD ) <S2SV_EndBug> break ; if ( tag != 0xFFFEE000 ) { read_info = DestroyImageInfo ( read_info ) ; ThrowDCMException ( CorruptImageError , \"ImproperImageHeader\" ) ; } file = ( FILE * ) NULL ; unique_file = AcquireUniqueFileResource ( filename ) ; if ( unique_file != - 1 ) file = fdopen ( unique_file , \"wb\" ) ; if ( file == ( FILE * ) NULL ) { ( void ) RelinquishUniqueFileResource ( filename ) ; ThrowFileException ( exception , FileOpenError , \"UnableToCreateTemporaryFile\" , filename ) ; break ; } for ( c = EOF ; length != 0 ; length -- ) { c = ReadBlobByte ( image ) ; if ( c == EOF ) { ThrowFileException ( exception , CorruptImageError , \"UnexpectedEndOfFile\" , image -> filename ) ; break ; } if ( fputc ( c , file ) != c ) break ; } ( void ) fclose ( file ) ; if ( c == EOF ) break ; ( void ) FormatLocaleString ( read_info -> filename , MagickPathExtent , \"jpeg:%s\" , filename ) ; if ( image -> compression == JPEG2000Compression ) ( void ) FormatLocaleString ( read_info -> filename , MagickPathExtent , \"j2k:%s\" , filename ) ; jpeg_image = ReadImage ( read_info , exception ) ; if ( jpeg_image != ( Image * ) NULL ) { ResetImagePropertyIterator ( image ) ; property = GetNextImageProperty ( image ) ; while ( property != ( const char * ) NULL ) { ( void ) SetImageProperty ( jpeg_image , property , GetImageProperty ( image , property , exception ) , exception ) ; property = GetNextImageProperty ( image ) ; } AppendImageToList ( & images , jpeg_image ) ; } ( void ) RelinquishUniqueFileResource ( filename ) ; } read_info = DestroyImageInfo ( read_info ) ; if ( stream_info -> offsets != ( ssize_t * ) NULL ) stream_info -> offsets = ( ssize_t * ) RelinquishMagickMemory ( stream_info -> offsets ) ; stream_info = ( DCMStreamInfo * ) RelinquishMagickMemory ( stream_info ) ; if ( info . scale != ( Quantum * ) NULL ) info . scale = ( Quantum * ) RelinquishMagickMemory ( info . scale ) ; if ( graymap != ( int * ) NULL ) graymap = ( int * ) RelinquishMagickMemory ( graymap ) ; if ( bluemap != ( int * ) NULL ) bluemap = ( int * ) RelinquishMagickMemory ( bluemap ) ; if ( greenmap != ( int * ) NULL ) greenmap = ( int * ) RelinquishMagickMemory ( greenmap ) ; if ( redmap != ( int * ) NULL ) redmap = ( int * ) RelinquishMagickMemory ( redmap ) ; image = DestroyImageList ( image ) ; return ( GetFirstImageInList ( images ) ) ; } if ( info . depth != ( 1UL * MAGICKCORE_QUANTUM_DEPTH ) ) { QuantumAny range ; length = ( size_t ) ( GetQuantumRange ( info . depth ) + 1 ) ; if ( length > ( size_t ) GetBlobSize ( image ) ) ThrowDCMException ( CorruptImageError , \"InsufficientImageDataInFile\" ) ; if ( info . scale != ( Quantum * ) NULL ) info . scale = ( Quantum * ) RelinquishMagickMemory ( info . scale ) ; info . scale = ( Quantum * ) AcquireQuantumMemory ( MagickMax ( length , 256 ) , sizeof ( * info . scale ) ) ; if ( info . scale == ( Quantum * ) NULL ) ThrowDCMException ( ResourceLimitError , \"MemoryAllocationFailed\" ) ; ( void ) memset ( info . scale , 0 , MagickMax ( length , 256 ) * sizeof ( * info . scale ) ) ; range = GetQuantumRange ( info . depth ) ; for ( i = 0 ; i <= ( ssize_t ) GetQuantumRange ( info . depth ) ; i ++ ) info . scale [ i ] = ScaleAnyToQuantum ( ( size_t ) i , range ) ; } if ( image -> compression == RLECompression ) { unsigned int tag ; for ( i = 0 ; i < ( ssize_t ) stream_info -> remaining ; i ++ ) { int c ; c = ReadBlobByte ( image ) ; if ( c == EOF ) break ; } tag = ( ( unsigned int ) ReadBlobLSBShort ( image ) << 16 ) | ReadBlobLSBShort ( image ) ; ( void ) tag ; length = ( size_t ) ReadBlobLSBLong ( image ) ; if ( length > ( size_t ) GetBlobSize ( image ) ) ThrowDCMException ( CorruptImageError , \"InsufficientImageDataInFile\" ) ; stream_info -> offset_count = length >> 2 ; if ( stream_info -> offset_count != 0 ) { if ( stream_info -> offsets != ( ssize_t * ) NULL ) stream_info -> offsets = ( ssize_t * ) RelinquishMagickMemory ( stream_info -> offsets ) ; stream_info -> offsets = ( ssize_t * ) AcquireQuantumMemory ( stream_info -> offset_count , sizeof ( * stream_info -> offsets ) ) ; if ( stream_info -> offsets == ( ssize_t * ) NULL ) ThrowDCMException ( ResourceLimitError , \"MemoryAllocationFailed\" ) ; for ( i = 0 ; i < ( ssize_t ) stream_info -> offset_count ; i ++ ) { stream_info -> offsets [ i ] = ( ssize_t ) ReadBlobLSBSignedLong ( image ) ; if ( EOFBlob ( image ) != MagickFalse ) break ; } offset = TellBlob ( image ) + 8 ; for ( i = 0 ; i < ( ssize_t ) stream_info -> offset_count ; i ++ ) stream_info -> offsets [ i ] += offset ; } } for ( scene = 0 ; scene < ( ssize_t ) number_scenes ; scene ++ ) { image -> columns = ( size_t ) width ; image -> rows = ( size_t ) height ; image -> depth = info . depth ; status = SetImageExtent ( image , image -> columns , image -> rows , exception ) ; if ( status == MagickFalse ) break ; image -> colorspace = RGBColorspace ; ( void ) SetImageBackgroundColor ( image , exception ) ; if ( ( image -> colormap == ( PixelInfo * ) NULL ) && ( info . samples_per_pixel == 1 ) ) { int index ; size_t one ; one = 1 ; if ( colors == 0 ) colors = one << info . depth ; if ( AcquireImageColormap ( image , colors , exception ) == MagickFalse ) ThrowDCMException ( ResourceLimitError , \"MemoryAllocationFailed\" ) ; if ( redmap != ( int * ) NULL ) for ( i = 0 ; i < ( ssize_t ) colors ; i ++ ) { index = redmap [ i ] ; if ( ( info . scale != ( Quantum * ) NULL ) && ( index >= 0 ) && ( index <= ( int ) info . max_value ) ) index = ( int ) info . scale [ index ] ; image -> colormap [ i ] . red = ( MagickRealType ) index ; } if ( greenmap != ( int * ) NULL ) for ( i = 0 ; i < ( ssize_t ) colors ; i ++ ) { index = greenmap [ i ] ; if ( ( info . scale != ( Quantum * ) NULL ) && ( index >= 0 ) && ( index <= ( int ) info . max_value ) ) index = ( int ) info . scale [ index ] ; image -> colormap [ i ] . green = ( MagickRealType ) index ; } if ( bluemap != ( int * ) NULL ) for ( i = 0 ; i < ( ssize_t ) colors ; i ++ ) { index = bluemap [ i ] ; if ( ( info . scale != ( Quantum * ) NULL ) && ( index >= 0 ) && ( index <= ( int ) info . max_value ) ) index = ( int ) info . scale [ index ] ; image -> colormap [ i ] . blue = ( MagickRealType ) index ; } if ( graymap != ( int * ) NULL ) for ( i = 0 ; i < ( ssize_t ) colors ; i ++ ) { index = graymap [ i ] ; if ( ( info . scale != ( Quantum * ) NULL ) && ( index >= 0 ) && ( index <= ( int ) info . max_value ) ) index = ( int ) info . scale [ index ] ; image -> colormap [ i ] . red = ( MagickRealType ) index ; image -> colormap [ i ] . green = ( MagickRealType ) index ; image -> colormap [ i ] . blue = ( MagickRealType ) index ; } } if ( image -> compression == RLECompression ) { unsigned int tag ; for ( i = 0 ; i < ( ssize_t ) stream_info -> remaining ; i ++ ) { int c ; c = ReadBlobByte ( image ) ; if ( c == EOF ) break ; } tag = ( ( unsigned int ) ReadBlobLSBShort ( image ) << 16 ) | ReadBlobLSBShort ( image ) ; stream_info -> remaining = ( size_t ) ReadBlobLSBLong ( image ) ; if ( ( tag != 0xFFFEE000 ) || ( stream_info -> remaining <= 64 ) || ( EOFBlob ( image ) != MagickFalse ) ) { if ( stream_info -> offsets != ( ssize_t * ) NULL ) stream_info -> offsets = ( ssize_t * ) RelinquishMagickMemory ( stream_info -> offsets ) ; ThrowDCMException ( CorruptImageError , \"ImproperImageHeader\" ) ; } stream_info -> count = 0 ; stream_info -> segment_count = ReadBlobLSBLong ( image ) ; for ( i = 0 ; i < 15 ; i ++ ) stream_info -> segments [ i ] = ( ssize_t ) ReadBlobLSBSignedLong ( image ) ; stream_info -> remaining -= 64 ; if ( stream_info -> segment_count > 1 ) { info . bytes_per_pixel = 1 ; info . depth = 8 ; if ( stream_info -> offset_count > 0 ) ( void ) SeekBlob ( image , ( MagickOffsetType ) stream_info -> offsets [ 0 ] + stream_info -> segments [ 0 ] , SEEK_SET ) ; } } if ( ( info . samples_per_pixel > 1 ) && ( image -> interlace == PlaneInterlace ) ) { register ssize_t x ; register Quantum * q ; ssize_t y ; for ( i = 0 ; i < ( ssize_t ) info . samples_per_pixel ; i ++ ) { for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { q = GetAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { switch ( ( int ) i ) { case 0 : { SetPixelRed ( image , ScaleCharToQuantum ( ( unsigned char ) ReadDCMByte ( stream_info , image ) ) , q ) ; break ; } case 1 : { SetPixelGreen ( image , ScaleCharToQuantum ( ( unsigned char ) ReadDCMByte ( stream_info , image ) ) , q ) ; break ; } case 2 : { SetPixelBlue ( image , ScaleCharToQuantum ( ( unsigned char ) ReadDCMByte ( stream_info , image ) ) , q ) ; break ; } case 3 : { SetPixelAlpha ( image , ScaleCharToQuantum ( ( unsigned char ) ReadDCMByte ( stream_info , image ) ) , q ) ; break ; } default : break ; } q += GetPixelChannels ( image ) ; } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ; if ( status == MagickFalse ) break ; } } } } else { const char * option ; option = GetImageOption ( image_info , \"dcm:display-range\" ) ; if ( option != ( const char * ) NULL ) { if ( LocaleCompare ( option , \"reset\" ) == 0 ) info . window_width = 0 ; } option = GetImageOption ( image_info , \"dcm:window\" ) ; if ( option != ( char * ) NULL ) { GeometryInfo geometry_info ; MagickStatusType flags ; flags = ParseGeometry ( option , & geometry_info ) ; if ( flags & RhoValue ) info . window_center = geometry_info . rho ; if ( flags & SigmaValue ) info . window_width = geometry_info . sigma ; info . rescale = MagickTrue ; } option = GetImageOption ( image_info , \"dcm:rescale\" ) ; if ( option != ( char * ) NULL ) info . rescale = IsStringTrue ( option ) ; if ( ( info . window_center != 0 ) && ( info . window_width == 0 ) ) info . window_width = info . window_center ; status = ReadDCMPixels ( image , & info , stream_info , MagickTrue , exception ) ; if ( ( status != MagickFalse ) && ( stream_info -> segment_count > 1 ) ) { if ( stream_info -> offset_count > 0 ) ( void ) SeekBlob ( image , ( MagickOffsetType ) stream_info -> offsets [ 0 ] + stream_info -> segments [ 1 ] , SEEK_SET ) ; ( void ) ReadDCMPixels ( image , & info , stream_info , MagickFalse , exception ) ; } } if ( SetImageGray ( image , exception ) != MagickFalse ) ( void ) SetImageColorspace ( image , GRAYColorspace , exception ) ; if ( EOFBlob ( image ) != MagickFalse ) { ThrowFileException ( exception , CorruptImageError , \"UnexpectedEndOfFile\" , image -> filename ) ; break ; } if ( image_info -> number_scenes != 0 ) if ( image -> scene >= ( image_info -> scene + image_info -> number_scenes - 1 ) ) break ; if ( scene < ( ssize_t ) ( number_scenes - 1 ) ) { AcquireNextImage ( image_info , image , exception ) ; if ( GetNextImageInList ( image ) == ( Image * ) NULL ) { status = MagickFalse ; break ; } image = SyncNextImageInList ( image ) ; status = SetImageProgress ( image , LoadImagesTag , TellBlob ( image ) , GetBlobSize ( image ) ) ; if ( status == MagickFalse ) break ; } } if ( TellBlob ( image ) < ( MagickOffsetType ) GetBlobSize ( image ) ) { AcquireNextImage ( image_info , image , exception ) ; if ( GetNextImageInList ( image ) == ( Image * ) NULL ) { status = MagickFalse ; break ; } image = SyncNextImageInList ( image ) ; status = SetImageProgress ( image , LoadImagesTag , TellBlob ( image ) , GetBlobSize ( image ) ) ; if ( status == MagickFalse ) break ; } } if ( stream_info -> offsets != ( ssize_t * ) NULL ) stream_info -> offsets = ( ssize_t * ) RelinquishMagickMemory ( stream_info -> offsets ) ; stream_info = ( DCMStreamInfo * ) RelinquishMagickMemory ( stream_info ) ; if ( info . scale != ( Quantum * ) NULL ) info . scale = ( Quantum * ) RelinquishMagickMemory ( info . scale ) ; if ( graymap != ( int * ) NULL ) graymap = ( int * ) RelinquishMagickMemory ( graymap ) ; if ( bluemap != ( int * ) NULL ) bluemap = ( int * ) RelinquishMagickMemory ( bluemap ) ; if ( greenmap != ( int * ) NULL ) greenmap = ( int * ) RelinquishMagickMemory ( greenmap ) ; if ( redmap != ( int * ) NULL ) redmap = ( int * ) RelinquishMagickMemory ( redmap ) ; if ( image == ( Image * ) NULL ) return ( image ) ; ( void ) CloseBlob ( image ) ; if ( status == MagickFalse ) return ( DestroyImageList ( image ) ) ; return ( GetFirstImageInList ( image ) ) ; }\n",
      "fixed_code": "<S2SV_ModStart> , message ) \\\\\\n{ <S2SV_ModEnd> if ( info <S2SV_ModStart> ) ) ; \\\\\\n} <S2SV_ModEnd> char explicit_vr [ <S2SV_ModStart> ; if ( length > ( size_t ) GetBlobSize ( image ) ) ThrowDCMException ( CorruptImageError , \"InsufficientImageDataInFile\" ) ; if (\n",
      "source_code_length": 33012,
      "target_code_length": 265,
      "vulnerability_patterns": {
        "buffer_overflow": 7,
        "use_after_free": 1,
        "integer_overflow": 38,
        "null_pointer": 117,
        "total": 163
      },
      "total_patterns": 163,
      "original_address": "https://github.com/ImageMagick/ImageMagick/commit/16916c8979c32765c542e216b31cee2671b7afe7",
      "discovery_time": "2018-09-06T22:29Z",
      "project_commit_id": "ImageMagick@ImageMagick/16916c8979c32765c542e216b31cee2671b7afe7",
      "extraction_time": "2025-08-31T15:41:49.175067",
      "label": 1,
      "vulnerability_type": "buffer_overflow",
      "difficulty_level": "expert",
      "risk_factors": [
        "memory_corruption",
        "critical_infrastructure",
        "arbitrary_code_execution",
        "buffer_overflow",
        "system_crash",
        "use_after_free"
      ],
      "attack_vectors": [
        "memory_manipulation",
        "malicious_input",
        "code_analysis",
        "buffer_overflow",
        "reverse_engineering",
        "fuzzing"
      ],
      "mitigation_strategies": [
        "safe_string_functions",
        "dynamic_analysis",
        "code_review",
        "static_analysis",
        "memory_safety_checks",
        "input_validation",
        "fuzzing",
        "bounds_checking",
        "secure_coding_practices"
      ],
      "code_differences": {
        "has_differences": true,
        "source_lines": 2,
        "target_lines": 2,
        "character_differences": 32747,
        "similarity_percentage": 4.615384615384616
      },
      "vulnerability_location": {
        "vulnerability_present": true,
        "fix_applied": true,
        "code_changed": true,
        "estimated_lines_changed": 0
      }
    },
    {
      "cve_id": "CVE-2016-10190",
      "cwe_id": "CWE-119",
      "cwe_name": "Buffer Overflow",
      "project": "FFmpeg",
      "severity": "critical",
      "weaponization_score": 10.0,
      "is_critical": true,
      "is_weaponizable": true,
      "is_high_priority_project": true,
      "vulnerable_code": "CWE-119 static int process_line ( URLContext * h , char * line , int line_count , int * new_location ) { HTTPContext * s = h -> priv_data ; const char * auto_method = h -> flags & AVIO_FLAG_READ ? \"POST\" : \"GET\" ; char * tag , * p , * end , * method , * resource , * version ; int ret ; if ( line [ 0 ] == '\\\\0' ) { s -> end_header = 1 ; return 0 ; } p = line ; if ( line_count == 0 ) { if ( s -> is_connected_server ) { method = p ; while ( * p && ! av_isspace ( * p ) ) p ++ ; * ( p ++ ) = '\\\\0' ; av_log ( h , AV_LOG_TRACE , \"Received<S2SV_blank>method:<S2SV_blank>%s\\\\n\" , method ) ; if ( s -> method ) { if ( av_strcasecmp ( s -> method , method ) ) { av_log ( h , AV_LOG_ERROR , \"Received<S2SV_blank>and<S2SV_blank>expected<S2SV_blank>HTTP<S2SV_blank>method<S2SV_blank>do<S2SV_blank>not<S2SV_blank>match.<S2SV_blank>(%s<S2SV_blank>expected,<S2SV_blank>%s<S2SV_blank>received)\\\\n\" , s -> method , method ) ; return ff_http_averror ( 400 , AVERROR ( EIO ) ) ; } } else { av_log ( h , AV_LOG_TRACE , \"Autodetected<S2SV_blank>%s<S2SV_blank>HTTP<S2SV_blank>method\\\\n\" , auto_method ) ; if ( av_strcasecmp ( auto_method , method ) ) { av_log ( h , AV_LOG_ERROR , \"Received<S2SV_blank>and<S2SV_blank>autodetected<S2SV_blank>HTTP<S2SV_blank>method<S2SV_blank>did<S2SV_blank>not<S2SV_blank>match<S2SV_blank>\" \"(%s<S2SV_blank>autodetected<S2SV_blank>%s<S2SV_blank>received)\\\\n\" , auto_method , method ) ; return ff_http_averror ( 400 , AVERROR ( EIO ) ) ; } if ( ! ( s -> method = av_strdup ( method ) ) ) return AVERROR ( ENOMEM ) ; } while ( av_isspace ( * p ) ) p ++ ; resource = p ; while ( ! av_isspace ( * p ) ) p ++ ; * ( p ++ ) = '\\\\0' ; av_log ( h , AV_LOG_TRACE , \"Requested<S2SV_blank>resource:<S2SV_blank>%s\\\\n\" , resource ) ; if ( ! ( s -> resource = av_strdup ( resource ) ) ) return AVERROR ( ENOMEM ) ; while ( av_isspace ( * p ) ) p ++ ; version = p ; while ( * p && ! av_isspace ( * p ) ) p ++ ; * p = '\\\\0' ; if ( av_strncasecmp ( version , \"HTTP/\" , 5 ) ) { av_log ( h , AV_LOG_ERROR , \"Malformed<S2SV_blank>HTTP<S2SV_blank>version<S2SV_blank>string.\\\\n\" ) ; return ff_http_averror ( 400 , AVERROR ( EIO ) ) ; } av_log ( h , AV_LOG_TRACE , \"HTTP<S2SV_blank>version<S2SV_blank>string:<S2SV_blank>%s\\\\n\" , version ) ; } else { while ( ! av_isspace ( * p ) && * p != '\\\\0' ) p ++ ; while ( av_isspace ( * p ) ) p ++ ; s -> http_code = strtol ( p , & end , 10 ) ; av_log ( h , AV_LOG_TRACE , \"http_code=%d\\\\n\" , s -> http_code ) ; if ( ( ret = check_http_code ( h , s -> http_code , end ) ) < 0 ) return ret ; } } else { while ( * p != '\\\\0' && * p != ':' ) p ++ ; if ( * p != ':' ) return 1 ; * p = '\\\\0' ; tag = line ; p ++ ; while ( av_isspace ( * p ) ) p ++ ; if ( ! av_strcasecmp ( tag , \"Location\" ) ) { if ( ( ret = parse_location ( s , p ) ) < 0 ) return ret ; * new_location = 1 ; <S2SV_StartBug> } else if ( ! av_strcasecmp ( tag , \"Content-Length\" ) && s -> filesize == - 1 ) { <S2SV_EndBug> <S2SV_StartBug> s -> filesize = strtoll ( p , NULL , 10 ) ; <S2SV_EndBug> } else if ( ! av_strcasecmp ( tag , \"Content-Range\" ) ) { parse_content_range ( h , p ) ; } else if ( ! av_strcasecmp ( tag , \"Accept-Ranges\" ) && ! strncmp ( p , \"bytes\" , 5 ) && s -> seekable == - 1 ) { h -> is_streamed = 0 ; } else if ( ! av_strcasecmp ( tag , \"Transfer-Encoding\" ) && ! av_strncasecmp ( p , \"chunked\" , 7 ) ) { <S2SV_StartBug> s -> filesize = - 1 ; <S2SV_EndBug> s -> chunksize = 0 ; } else if ( ! av_strcasecmp ( tag , \"WWW-Authenticate\" ) ) { <S2SV_StartBug> ff_http_auth_handle_header ( & s -> auth_state , tag , p ) ; <S2SV_EndBug> } else if ( ! av_strcasecmp ( tag , \"Authentication-Info\" ) ) { ff_http_auth_handle_header ( & s -> auth_state , tag , p ) ; } else if ( ! av_strcasecmp ( tag , \"Proxy-Authenticate\" ) ) { ff_http_auth_handle_header ( & s -> proxy_auth_state , tag , p ) ; } else if ( ! av_strcasecmp ( tag , \"Connection\" ) ) { if ( ! strcmp ( p , \"close\" ) ) s -> willclose = 1 ; } else if ( ! av_strcasecmp ( tag , \"Server\" ) ) { if ( ! av_strcasecmp ( p , \"AkamaiGHost\" ) ) { s -> is_akamai = 1 ; } else if ( ! av_strncasecmp ( p , \"MediaGateway\" , 12 ) ) { s -> is_mediagateway = 1 ; } } else if ( ! av_strcasecmp ( tag , \"Content-Type\" ) ) { av_free ( s -> mime_type ) ; s -> mime_type = av_strdup ( p ) ; } else if ( ! av_strcasecmp ( tag , \"Set-Cookie\" ) ) { if ( parse_cookie ( s , p , & s -> cookie_dict ) ) av_log ( h , AV_LOG_WARNING , \"Unable<S2SV_blank>to<S2SV_blank>parse<S2SV_blank>\\'%s\\'\\\\n\" , p ) ; } else if ( ! av_strcasecmp ( tag , \"Icy-MetaInt\" ) ) { <S2SV_StartBug> s -> icy_metaint = strtoll ( p , NULL , 10 ) ; <S2SV_EndBug> } else if ( ! av_strncasecmp ( tag , \"Icy-\" , 4 ) ) { if ( ( ret = parse_icy ( s , tag , p ) ) < 0 ) return ret ; } else if ( ! av_strcasecmp ( tag , \"Content-Encoding\" ) ) { if ( ( ret = parse_content_encoding ( h , p ) ) < 0 ) return ret ; } } return 1 ; }\n",
      "fixed_code": "<S2SV_ModStart> -> filesize == UINT64_MAX <S2SV_ModEnd> ) { s <S2SV_ModStart> -> filesize = strtoull <S2SV_ModEnd> ( p , <S2SV_ModStart> -> filesize = UINT64_MAX ; s -> chunksize = 0 ; } else if ( ! av_strcasecmp ( tag , \"WWW-Authenticate\" ) ) { ff_http_auth_handle_header ( & s -> auth_state , tag , p ) ; } else if ( ! av_strcasecmp ( tag , \"Authentication-Info\" ) ) { ff_http_auth_handle_header ( & s -> auth_state , tag , p ) ; } else if ( ! av_strcasecmp ( tag , \"Proxy-Authenticate\" ) ) { ff_http_auth_handle_header ( & s -> proxy_auth_state , tag , p ) ; } else if ( ! av_strcasecmp ( tag , \"Connection\" ) ) { if ( ! strcmp ( p , \"close\" ) ) s -> willclose = 1 ; } else if ( ! av_strcasecmp ( tag , \"Server\" ) ) { if ( ! av_strcasecmp ( p , \"AkamaiGHost\" ) ) { s -> is_akamai = 1 ; } else if ( ! av_strncasecmp ( p , \"MediaGateway\" , 12 ) ) { s -> is_mediagateway = 1 ; } } else if ( ! av_strcasecmp ( tag , \"Content-Type\" ) ) { av_free ( s -> mime_type ) ; s -> mime_type = av_strdup ( p ) ; } else if ( ! av_strcasecmp ( tag , \"Set-Cookie\" ) ) { if ( parse_cookie ( s , p , <S2SV_ModEnd> & s -> <S2SV_ModStart> & s -> <S2SV_ModEnd> cookie_dict ) ) <S2SV_ModStart> -> icy_metaint = strtoull <S2SV_ModEnd> ( p ,\n",
      "source_code_length": 4836,
      "target_code_length": 1219,
      "vulnerability_patterns": {
        "use_after_free": 3,
        "integer_overflow": 13,
        "format_string": 1,
        "null_pointer": 68,
        "total": 85
      },
      "total_patterns": 85,
      "original_address": "https://github.com/FFmpeg/FFmpeg/commit/2a05c8f813de6f2278827734bf8102291e7484aa",
      "discovery_time": "2017-02-09T15:59Z",
      "project_commit_id": "FFmpeg@FFmpeg/2a05c8f813de6f2278827734bf8102291e7484aa",
      "extraction_time": "2025-08-31T15:41:49.175303",
      "label": 1,
      "vulnerability_type": "buffer_overflow",
      "difficulty_level": "expert",
      "risk_factors": [
        "memory_corruption",
        "critical_infrastructure",
        "arbitrary_code_execution",
        "system_crash",
        "use_after_free"
      ],
      "attack_vectors": [
        "memory_manipulation",
        "malicious_input",
        "code_analysis",
        "buffer_overflow",
        "reverse_engineering",
        "fuzzing"
      ],
      "mitigation_strategies": [
        "safe_string_functions",
        "dynamic_analysis",
        "code_review",
        "static_analysis",
        "memory_safety_checks",
        "input_validation",
        "fuzzing",
        "bounds_checking",
        "secure_coding_practices"
      ],
      "code_differences": {
        "has_differences": true,
        "source_lines": 2,
        "target_lines": 2,
        "character_differences": 3617,
        "similarity_percentage": 33.33333333333333
      },
      "vulnerability_location": {
        "vulnerability_present": true,
        "fix_applied": true,
        "code_changed": true,
        "estimated_lines_changed": 0
      }
    },
    {
      "cve_id": "CVE-2019-19275",
      "cwe_id": "CWE-125",
      "cwe_name": "Out-of-bounds Read",
      "project": "python",
      "severity": "critical",
      "weaponization_score": 10.0,
      "is_critical": true,
      "is_weaponizable": true,
      "is_high_priority_project": true,
      "vulnerable_code": "CWE-125 static arguments_ty ast_for_arguments ( struct compiling * c , const node * n ) { int i , j , k , nposargs = 0 , nkwonlyargs = 0 ; int nposdefaults = 0 , found_default = 0 ; asdl_seq * posargs , * posdefaults , * kwonlyargs , * kwdefaults ; arg_ty vararg = NULL , kwarg = NULL ; arg_ty arg ; node * ch ; if ( TYPE ( n ) == parameters ) { if ( NCH ( n ) == 2 ) return arguments ( NULL , NULL , NULL , NULL , NULL , NULL , c -> c_arena ) ; n = CHILD ( n , 1 ) ; } assert ( TYPE ( n ) == typedargslist || TYPE ( n ) == varargslist ) ; for ( i = 0 ; i < NCH ( n ) ; i ++ ) { ch = CHILD ( n , i ) ; if ( TYPE ( ch ) == STAR ) { i ++ ; if ( i < NCH ( n ) && ( TYPE ( CHILD ( n , i ) ) == tfpdef || TYPE ( CHILD ( n , i ) ) == vfpdef ) ) { i ++ ; } break ; } if ( TYPE ( ch ) == DOUBLESTAR ) break ; if ( TYPE ( ch ) == vfpdef || TYPE ( ch ) == tfpdef ) nposargs ++ ; if ( TYPE ( ch ) == EQUAL ) nposdefaults ++ ; } for ( ; i < NCH ( n ) ; ++ i ) { ch = CHILD ( n , i ) ; if ( TYPE ( ch ) == DOUBLESTAR ) break ; if ( TYPE ( ch ) == tfpdef || TYPE ( ch ) == vfpdef ) nkwonlyargs ++ ; } posargs = ( nposargs ? _Ta3_asdl_seq_new ( nposargs , c -> c_arena ) : NULL ) ; if ( ! posargs && nposargs ) return NULL ; kwonlyargs = ( nkwonlyargs ? _Ta3_asdl_seq_new ( nkwonlyargs , c -> c_arena ) : NULL ) ; if ( ! kwonlyargs && nkwonlyargs ) return NULL ; posdefaults = ( nposdefaults ? _Ta3_asdl_seq_new ( nposdefaults , c -> c_arena ) : NULL ) ; if ( ! posdefaults && nposdefaults ) return NULL ; kwdefaults = ( nkwonlyargs ? _Ta3_asdl_seq_new ( nkwonlyargs , c -> c_arena ) : NULL ) ; if ( ! kwdefaults && nkwonlyargs ) return NULL ; <S2SV_StartBug> if ( nposargs + nkwonlyargs > 255 ) { <S2SV_EndBug> ast_error ( c , n , \"more<S2SV_blank>than<S2SV_blank>255<S2SV_blank>arguments\" ) ; return NULL ; } i = 0 ; j = 0 ; k = 0 ; while ( i < NCH ( n ) ) { ch = CHILD ( n , i ) ; switch ( TYPE ( ch ) ) { case tfpdef : case vfpdef : if ( i + 1 < NCH ( n ) && TYPE ( CHILD ( n , i + 1 ) ) == EQUAL ) { expr_ty expression = ast_for_expr ( c , CHILD ( n , i + 2 ) ) ; if ( ! expression ) return NULL ; assert ( posdefaults != NULL ) ; asdl_seq_SET ( posdefaults , j ++ , expression ) ; i += 2 ; found_default = 1 ; } else if ( found_default ) { ast_error ( c , n , \"non-default<S2SV_blank>argument<S2SV_blank>follows<S2SV_blank>default<S2SV_blank>argument\" ) ; return NULL ; } arg = ast_for_arg ( c , ch ) ; if ( ! arg ) return NULL ; asdl_seq_SET ( posargs , k ++ , arg ) ; i += 1 ; <S2SV_StartBug> if ( i < NCH ( n ) && TYPE ( CHILD ( n , i ) ) == COMMA ) <S2SV_EndBug> i += 1 ; break ; case STAR : if ( i + 1 >= NCH ( n ) || ( i + 2 == NCH ( n ) && ( TYPE ( CHILD ( n , i + 1 ) ) == COMMA || TYPE ( CHILD ( n , i + 1 ) ) == TYPE_COMMENT ) ) ) { ast_error ( c , CHILD ( n , i ) , \"named<S2SV_blank>arguments<S2SV_blank>must<S2SV_blank>follow<S2SV_blank>bare<S2SV_blank>*\" ) ; return NULL ; } ch = CHILD ( n , i + 1 ) ; if ( TYPE ( ch ) == COMMA ) { int res = 0 ; i += 2 ; <S2SV_StartBug> if ( i < NCH ( n ) && TYPE ( CHILD ( n , i ) ) == TYPE_COMMENT ) { <S2SV_EndBug> ast_error ( c , CHILD ( n , i ) , \"bare<S2SV_blank>*<S2SV_blank>has<S2SV_blank>associated<S2SV_blank>type<S2SV_blank>comment\" ) ; return NULL ; } res = handle_keywordonly_args ( c , n , i , kwonlyargs , kwdefaults ) ; if ( res == - 1 ) return NULL ; i = res ; } else { vararg = ast_for_arg ( c , ch ) ; if ( ! vararg ) return NULL ; i += 2 ; <S2SV_StartBug> if ( i < NCH ( n ) && TYPE ( CHILD ( n , i ) ) == COMMA ) <S2SV_EndBug> i += 1 ; <S2SV_StartBug> if ( i < NCH ( n ) && TYPE ( CHILD ( n , i ) ) == TYPE_COMMENT ) { <S2SV_EndBug> vararg -> type_comment = NEW_TYPE_COMMENT ( CHILD ( n , i ) ) ; i += 1 ; } if ( i < NCH ( n ) && ( TYPE ( CHILD ( n , i ) ) == tfpdef || TYPE ( CHILD ( n , i ) ) == vfpdef ) ) { int res = 0 ; res = handle_keywordonly_args ( c , n , i , kwonlyargs , kwdefaults ) ; if ( res == - 1 ) return NULL ; i = res ; } } break ; case DOUBLESTAR : ch = CHILD ( n , i + 1 ) ; assert ( TYPE ( ch ) == tfpdef || TYPE ( ch ) == vfpdef ) ; kwarg = ast_for_arg ( c , ch ) ; if ( ! kwarg ) return NULL ; i += 2 ; <S2SV_StartBug> if ( i < NCH ( n ) && TYPE ( CHILD ( n , i ) ) == COMMA ) <S2SV_EndBug> i += 1 ; break ; case TYPE_COMMENT : assert ( i ) ; if ( kwarg ) arg = kwarg ; arg -> type_comment = NEW_TYPE_COMMENT ( ch ) ; i += 1 ; break ; default : PyErr_Format ( PyExc_SystemError , \"unexpected<S2SV_blank>node<S2SV_blank>in<S2SV_blank>varargslist:<S2SV_blank>%d<S2SV_blank>@<S2SV_blank>%d\" , TYPE ( ch ) , i ) ; return NULL ; } } return arguments ( posargs , vararg , kwonlyargs , kwdefaults , kwarg , posdefaults , c -> c_arena ) ; }\n",
      "fixed_code": "<S2SV_ModStart> return NULL ; <S2SV_ModEnd> i = 0 <S2SV_ModStart> ; if ( <S2SV_ModEnd> TYPE ( CHILD <S2SV_ModStart> ; if ( <S2SV_ModEnd> TYPE ( CHILD <S2SV_ModStart> ; if ( <S2SV_ModEnd> TYPE ( CHILD <S2SV_ModStart> ; if ( <S2SV_ModEnd> TYPE ( CHILD <S2SV_ModStart> ; if ( <S2SV_ModEnd> TYPE ( CHILD\n",
      "source_code_length": 4617,
      "target_code_length": 300,
      "vulnerability_patterns": {
        "use_after_free": 3,
        "null_pointer": 257,
        "sql_injection": 1,
        "total": 261
      },
      "total_patterns": 261,
      "original_address": "https://github.com/python/typed_ast/commit/156afcb26c198e162504a57caddfe0acd9ed7dce",
      "discovery_time": "2019-11-26T15:15Z",
      "project_commit_id": "python@typed_ast/156afcb26c198e162504a57caddfe0acd9ed7dce",
      "extraction_time": "2025-08-31T15:41:49.175346",
      "label": 1,
      "vulnerability_type": "out-of-bounds_read",
      "difficulty_level": "expert",
      "risk_factors": [
        "memory_corruption",
        "critical_infrastructure",
        "sql_injection",
        "information_disclosure",
        "use_after_free",
        "integer_overflow"
      ],
      "attack_vectors": [
        "memory_manipulation",
        "malicious_input",
        "code_analysis",
        "buffer_overflow",
        "reverse_engineering",
        "fuzzing"
      ],
      "mitigation_strategies": [
        "safe_string_functions",
        "dynamic_analysis",
        "code_review",
        "static_analysis",
        "memory_safety_checks",
        "input_validation",
        "fuzzing",
        "bounds_checking",
        "secure_coding_practices"
      ],
      "code_differences": {
        "has_differences": true,
        "source_lines": 2,
        "target_lines": 2,
        "character_differences": 4317,
        "similarity_percentage": 9.70873786407767
      },
      "vulnerability_location": {
        "vulnerability_present": true,
        "fix_applied": true,
        "code_changed": true,
        "estimated_lines_changed": 0
      }
    },
    {
      "cve_id": "CVE-2017-7854",
      "cwe_id": "CWE-125",
      "cwe_name": "Out-of-bounds Read",
      "project": "radare",
      "severity": "critical",
      "weaponization_score": 10.0,
      "is_critical": true,
      "is_weaponizable": true,
      "is_high_priority_project": true,
      "vulnerable_code": "CWE-125 static RList * r_bin_wasm_get_data_entries ( RBinWasmObj * bin , RBinWasmSection * sec ) { RList * ret = NULL ; RBinWasmDataEntry * ptr = NULL ; <S2SV_StartBug> if ( ! ( ret = r_list_newf ( ( RListFree ) free ) ) ) { <S2SV_EndBug> return NULL ; } ut8 * buf = bin -> buf -> buf + ( ut32 ) sec -> payload_data ; <S2SV_StartBug> ut32 len = sec -> payload_len ; <S2SV_EndBug> ut32 count = sec -> count ; ut32 i = 0 , r = 0 ; size_t n = 0 ; <S2SV_StartBug> while ( i < len && r < count ) { <S2SV_EndBug> if ( ! ( ptr = R_NEW0 ( RBinWasmDataEntry ) ) ) { return ret ; } if ( ! ( consume_u32 ( buf + i , buf + len , & ptr -> index , & i ) ) ) { <S2SV_StartBug> free ( ptr ) ; <S2SV_EndBug> return ret ; } if ( ! ( n = consume_init_expr ( buf + i , buf + len , R_BIN_WASM_END_OF_CODE , NULL , & i ) ) ) { <S2SV_StartBug> free ( ptr ) ; <S2SV_EndBug> return ret ; } ptr -> offset . len = n ; if ( ! ( consume_u32 ( buf + i , buf + len , & ptr -> size , & i ) ) ) { <S2SV_StartBug> free ( ptr ) ; <S2SV_EndBug> return ret ; } ptr -> data = sec -> payload_data + i ; r_list_append ( ret , ptr ) ; r += 1 ; } return ret ; <S2SV_StartBug> } <S2SV_EndBug>\n",
      "fixed_code": "<S2SV_ModStart> = NULL ; ut32 len = sec -> payload_len ; <S2SV_ModStart> -> payload_data ; int buflen = bin -> buf -> length - ( ut32 ) sec -> payload_data <S2SV_ModEnd> ; ut32 count <S2SV_ModStart> i < len && len < buflen <S2SV_ModStart> ) ) { goto beach ; } if ( i + 4 >= buflen ) { goto beach <S2SV_ModEnd> ; } if <S2SV_ModStart> ) ) { goto beach <S2SV_ModEnd> ; } ptr <S2SV_ModStart> ) ) { goto beach ; } if ( i + 4 >= buflen ) { goto beach <S2SV_ModEnd> ; } ptr <S2SV_ModStart> return ret ; beach : free ( ptr ) ; return ret ;\n",
      "source_code_length": 1150,
      "target_code_length": 532,
      "vulnerability_patterns": {
        "use_after_free": 3,
        "integer_overflow": 1,
        "null_pointer": 10,
        "total": 14
      },
      "total_patterns": 14,
      "original_address": "https://github.com/radare/radare2/commit/d2632f6483a3ceb5d8e0a5fb11142c51c43978b4",
      "discovery_time": "2017-04-13T16:59Z",
      "project_commit_id": "radare@radare2/d2632f6483a3ceb5d8e0a5fb11142c51c43978b4",
      "extraction_time": "2025-08-31T15:41:49.175399",
      "label": 1,
      "vulnerability_type": "out-of-bounds_read",
      "difficulty_level": "expert",
      "risk_factors": [
        "memory_corruption",
        "critical_infrastructure",
        "information_disclosure",
        "use_after_free",
        "integer_overflow"
      ],
      "attack_vectors": [
        "memory_manipulation",
        "malicious_input",
        "code_analysis",
        "buffer_overflow",
        "reverse_engineering",
        "fuzzing"
      ],
      "mitigation_strategies": [
        "safe_string_functions",
        "dynamic_analysis",
        "code_review",
        "static_analysis",
        "memory_safety_checks",
        "input_validation",
        "fuzzing",
        "bounds_checking",
        "secure_coding_practices"
      ],
      "code_differences": {
        "has_differences": true,
        "source_lines": 2,
        "target_lines": 2,
        "character_differences": 618,
        "similarity_percentage": 36.231884057971016
      },
      "vulnerability_location": {
        "vulnerability_present": true,
        "fix_applied": true,
        "code_changed": true,
        "estimated_lines_changed": 0
      }
    },
    {
      "cve_id": "CVE-2013-4263",
      "cwe_id": "CWE-119",
      "cwe_name": "Buffer Overflow",
      "project": "FFmpeg",
      "severity": "critical",
      "weaponization_score": 10.0,
      "is_critical": true,
      "is_weaponizable": true,
      "is_high_priority_project": true,
      "vulnerable_code": "CWE-119 static int filter_frame ( AVFilterLink * inlink , AVFrame * inpic ) { KerndeintContext * kerndeint = inlink -> dst -> priv ; AVFilterLink * outlink = inlink -> dst -> outputs [ 0 ] ; AVFrame * outpic ; const uint8_t * prvp ; const uint8_t * prvpp ; const uint8_t * prvpn ; const uint8_t * prvppp ; const uint8_t * prvpnn ; const uint8_t * prvp4p ; const uint8_t * prvp4n ; const uint8_t * srcp ; const uint8_t * srcpp ; const uint8_t * srcpn ; const uint8_t * srcppp ; const uint8_t * srcpnn ; const uint8_t * srcp3p ; const uint8_t * srcp3n ; const uint8_t * srcp4p ; const uint8_t * srcp4n ; uint8_t * dstp , * dstp_saved ; const uint8_t * srcp_saved ; int src_linesize , psrc_linesize , dst_linesize , bwidth ; int x , y , plane , val , hi , lo , g , h , n = kerndeint -> frame ++ ; double valf ; const int thresh = kerndeint -> thresh ; const int order = kerndeint -> order ; const int map = kerndeint -> map ; const int sharp = kerndeint -> sharp ; const int twoway = kerndeint -> twoway ; const int is_packed_rgb = kerndeint -> is_packed_rgb ; outpic = ff_get_video_buffer ( outlink , outlink -> w , outlink -> h ) ; if ( ! outpic ) { av_frame_free ( & inpic ) ; return AVERROR ( ENOMEM ) ; } av_frame_copy_props ( outpic , inpic ) ; outpic -> interlaced_frame = 0 ; <S2SV_StartBug> for ( plane = 0 ; inpic -> data [ plane ] && plane < 4 ; plane ++ ) { <S2SV_EndBug> h = plane == 0 ? inlink -> h : FF_CEIL_RSHIFT ( inlink -> h , kerndeint -> vsub ) ; bwidth = kerndeint -> tmp_bwidth [ plane ] ; srcp = srcp_saved = inpic -> data [ plane ] ; src_linesize = inpic -> linesize [ plane ] ; psrc_linesize = kerndeint -> tmp_linesize [ plane ] ; dstp = dstp_saved = outpic -> data [ plane ] ; dst_linesize = outpic -> linesize [ plane ] ; srcp = srcp_saved + ( 1 - order ) * src_linesize ; dstp = dstp_saved + ( 1 - order ) * dst_linesize ; for ( y = 0 ; y < h ; y += 2 ) { memcpy ( dstp , srcp , bwidth ) ; srcp += 2 * src_linesize ; dstp += 2 * dst_linesize ; } memcpy ( dstp_saved + order * dst_linesize , srcp_saved + ( 1 - order ) * src_linesize , bwidth ) ; memcpy ( dstp_saved + ( 2 + order ) * dst_linesize , srcp_saved + ( 3 - order ) * src_linesize , bwidth ) ; memcpy ( dstp_saved + ( h - 2 + order ) * dst_linesize , srcp_saved + ( h - 1 - order ) * src_linesize , bwidth ) ; memcpy ( dstp_saved + ( h - 4 + order ) * dst_linesize , srcp_saved + ( h - 3 - order ) * src_linesize , bwidth ) ; prvp = kerndeint -> tmp_data [ plane ] + 5 * psrc_linesize - ( 1 - order ) * psrc_linesize ; prvpp = prvp - psrc_linesize ; prvppp = prvp - 2 * psrc_linesize ; prvp4p = prvp - 4 * psrc_linesize ; prvpn = prvp + psrc_linesize ; prvpnn = prvp + 2 * psrc_linesize ; prvp4n = prvp + 4 * psrc_linesize ; srcp = srcp_saved + 5 * src_linesize - ( 1 - order ) * src_linesize ; srcpp = srcp - src_linesize ; srcppp = srcp - 2 * src_linesize ; srcp3p = srcp - 3 * src_linesize ; srcp4p = srcp - 4 * src_linesize ; srcpn = srcp + src_linesize ; srcpnn = srcp + 2 * src_linesize ; srcp3n = srcp + 3 * src_linesize ; srcp4n = srcp + 4 * src_linesize ; dstp = dstp_saved + 5 * dst_linesize - ( 1 - order ) * dst_linesize ; for ( y = 5 - ( 1 - order ) ; y <= h - 5 - ( 1 - order ) ; y += 2 ) { for ( x = 0 ; x < bwidth ; x ++ ) { if ( thresh == 0 || n == 0 || ( abs ( ( int ) prvp [ x ] - ( int ) srcp [ x ] ) > thresh ) || ( abs ( ( int ) prvpp [ x ] - ( int ) srcpp [ x ] ) > thresh ) || ( abs ( ( int ) prvpn [ x ] - ( int ) srcpn [ x ] ) > thresh ) ) { if ( map ) { g = x & ~ 3 ; if ( is_packed_rgb ) { AV_WB32 ( dstp + g , 0xffffffff ) ; x = g + 3 ; } else if ( inlink -> format == AV_PIX_FMT_YUYV422 ) { AV_WB32 ( dstp + g , 0xeb80eb80 ) ; x = g + 3 ; } else { dstp [ x ] = plane == 0 ? 235 : 128 ; } } else { if ( is_packed_rgb ) { hi = 255 ; lo = 0 ; } else if ( inlink -> format == AV_PIX_FMT_YUYV422 ) { hi = x & 1 ? 240 : 235 ; lo = 16 ; } else { hi = plane == 0 ? 235 : 240 ; lo = 16 ; } if ( sharp ) { if ( twoway ) { valf = + 0.526 * ( ( int ) srcpp [ x ] + ( int ) srcpn [ x ] ) + 0.170 * ( ( int ) srcp [ x ] + ( int ) prvp [ x ] ) - 0.116 * ( ( int ) srcppp [ x ] + ( int ) srcpnn [ x ] + ( int ) prvppp [ x ] + ( int ) prvpnn [ x ] ) - 0.026 * ( ( int ) srcp3p [ x ] + ( int ) srcp3n [ x ] ) + 0.031 * ( ( int ) srcp4p [ x ] + ( int ) srcp4n [ x ] + ( int ) prvp4p [ x ] + ( int ) prvp4n [ x ] ) ; } else { valf = + 0.526 * ( ( int ) srcpp [ x ] + ( int ) srcpn [ x ] ) + 0.170 * ( ( int ) prvp [ x ] ) - 0.116 * ( ( int ) prvppp [ x ] + ( int ) prvpnn [ x ] ) - 0.026 * ( ( int ) srcp3p [ x ] + ( int ) srcp3n [ x ] ) + 0.031 * ( ( int ) prvp4p [ x ] + ( int ) prvp4p [ x ] ) ; } dstp [ x ] = av_clip ( valf , lo , hi ) ; } else { if ( twoway ) { val = ( 8 * ( ( int ) srcpp [ x ] + ( int ) srcpn [ x ] ) + 2 * ( ( int ) srcp [ x ] + ( int ) prvp [ x ] ) - ( int ) ( srcppp [ x ] ) - ( int ) ( srcpnn [ x ] ) - ( int ) ( prvppp [ x ] ) - ( int ) ( prvpnn [ x ] ) ) >> 4 ; } else { val = ( 8 * ( ( int ) srcpp [ x ] + ( int ) srcpn [ x ] ) + 2 * ( ( int ) prvp [ x ] ) - ( int ) ( prvppp [ x ] ) - ( int ) ( prvpnn [ x ] ) ) >> 4 ; } dstp [ x ] = av_clip ( val , lo , hi ) ; } } } else { dstp [ x ] = srcp [ x ] ; } } prvp += 2 * psrc_linesize ; prvpp += 2 * psrc_linesize ; prvppp += 2 * psrc_linesize ; prvpn += 2 * psrc_linesize ; prvpnn += 2 * psrc_linesize ; prvp4p += 2 * psrc_linesize ; prvp4n += 2 * psrc_linesize ; srcp += 2 * src_linesize ; srcpp += 2 * src_linesize ; srcppp += 2 * src_linesize ; srcp3p += 2 * src_linesize ; srcp4p += 2 * src_linesize ; srcpn += 2 * src_linesize ; srcpnn += 2 * src_linesize ; srcp3n += 2 * src_linesize ; srcp4n += 2 * src_linesize ; dstp += 2 * dst_linesize ; } srcp = inpic -> data [ plane ] ; dstp = kerndeint -> tmp_data [ plane ] ; av_image_copy_plane ( dstp , psrc_linesize , srcp , src_linesize , bwidth , h ) ; } av_frame_free ( & inpic ) ; return ff_filter_frame ( outlink , outpic ) ; }\n",
      "fixed_code": "<S2SV_ModStart> = 0 ; <S2SV_ModEnd> plane < 4 <S2SV_ModStart> plane < 4 && inpic -> data [ plane ] && inpic -> linesize [ plane ]\n",
      "source_code_length": 5860,
      "target_code_length": 130,
      "vulnerability_patterns": {
        "buffer_overflow": 5,
        "integer_overflow": 24,
        "null_pointer": 31,
        "total": 60
      },
      "total_patterns": 60,
      "original_address": "https://github.com/FFmpeg/FFmpeg/commit/e43a0a232dbf6d3c161823c2e07c52e76227a1bc",
      "discovery_time": "2013-11-23T17:55Z",
      "project_commit_id": "FFmpeg@FFmpeg/e43a0a232dbf6d3c161823c2e07c52e76227a1bc",
      "extraction_time": "2025-08-31T15:41:49.175433",
      "label": 1,
      "vulnerability_type": "buffer_overflow",
      "difficulty_level": "expert",
      "risk_factors": [
        "memory_corruption",
        "critical_infrastructure",
        "arbitrary_code_execution",
        "buffer_overflow",
        "system_crash"
      ],
      "attack_vectors": [
        "memory_manipulation",
        "malicious_input",
        "code_analysis",
        "buffer_overflow",
        "reverse_engineering",
        "fuzzing"
      ],
      "mitigation_strategies": [
        "safe_string_functions",
        "dynamic_analysis",
        "code_review",
        "static_analysis",
        "memory_safety_checks",
        "input_validation",
        "fuzzing",
        "bounds_checking",
        "secure_coding_practices"
      ],
      "code_differences": {
        "has_differences": true,
        "source_lines": 2,
        "target_lines": 2,
        "character_differences": 5730,
        "similarity_percentage": 9.701492537313433
      },
      "vulnerability_location": {
        "vulnerability_present": true,
        "fix_applied": true,
        "code_changed": true,
        "estimated_lines_changed": 0
      }
    },
    {
      "cve_id": "CVE-2019-14934",
      "cwe_id": "CWE-787",
      "cwe_name": "Out-of-bounds Write",
      "project": "enferex",
      "severity": "critical",
      "weaponization_score": 10.0,
      "is_critical": true,
      "is_weaponizable": true,
      "is_high_priority_project": false,
      "vulnerable_code": "CWE-787 pdf_t * pdf_new ( const char * name ) { const char * n ; pdf_t * pdf ; <S2SV_StartBug> pdf = calloc ( 1 , sizeof ( pdf_t ) ) ; <S2SV_EndBug> if ( name ) { if ( ( n = strrchr ( name , '/' ) ) ) ++ n ; else n = name ; <S2SV_StartBug> pdf -> name = malloc ( strlen ( n ) + 1 ) ; <S2SV_EndBug> strcpy ( pdf -> name , n ) ; } else { <S2SV_StartBug> pdf -> name = malloc ( strlen ( \"Unknown\" ) + 1 ) ; <S2SV_EndBug> strcpy ( pdf -> name , \"Unknown\" ) ; } return pdf ; }\n",
      "fixed_code": "<S2SV_ModStart> ; pdf = safe_calloc ( <S2SV_ModEnd> sizeof ( pdf_t <S2SV_ModStart> -> name = safe_calloc <S2SV_ModEnd> ( strlen ( <S2SV_ModStart> -> name = safe_calloc <S2SV_ModEnd> ( strlen (\n",
      "source_code_length": 472,
      "target_code_length": 193,
      "vulnerability_patterns": {
        "buffer_overflow": 2,
        "use_after_free": 3,
        "integer_overflow": 1,
        "null_pointer": 4,
        "memory_leak": 3,
        "total": 13
      },
      "total_patterns": 13,
      "original_address": "https://github.com/enferex/pdfresurrect/commit/0c4120fffa3dffe97b95c486a120eded82afe8a6",
      "discovery_time": "2019-08-11T22:15Z",
      "project_commit_id": "enferex@pdfresurrect/0c4120fffa3dffe97b95c486a120eded82afe8a6",
      "extraction_time": "2025-08-31T15:41:49.175494",
      "label": 1,
      "vulnerability_type": "out-of-bounds_write",
      "difficulty_level": "expert",
      "risk_factors": [
        "memory_corruption",
        "arbitrary_code_execution",
        "buffer_overflow",
        "system_crash",
        "use_after_free"
      ],
      "attack_vectors": [
        "memory_manipulation",
        "malicious_input",
        "code_analysis",
        "buffer_overflow",
        "reverse_engineering",
        "fuzzing"
      ],
      "mitigation_strategies": [
        "safe_string_functions",
        "dynamic_analysis",
        "code_review",
        "static_analysis",
        "memory_safety_checks",
        "input_validation",
        "fuzzing",
        "bounds_checking",
        "secure_coding_practices"
      ],
      "code_differences": {
        "has_differences": true,
        "source_lines": 2,
        "target_lines": 2,
        "character_differences": 279,
        "similarity_percentage": 25.0
      },
      "vulnerability_location": {
        "vulnerability_present": true,
        "fix_applied": true,
        "code_changed": true,
        "estimated_lines_changed": 0
      }
    },
    {
      "cve_id": "CVE-2017-15931",
      "cwe_id": "CWE-125",
      "cwe_name": "Out-of-bounds Read",
      "project": "radare",
      "severity": "critical",
      "weaponization_score": 10.0,
      "is_critical": true,
      "is_weaponizable": true,
      "is_high_priority_project": true,
      "vulnerable_code": "CWE-125 static Sdb * store_versioninfo_gnu_verneed ( ELFOBJ * bin , Elf_ ( Shdr ) * shdr , int sz ) { ut8 * end , * need = NULL ; const char * section_name = \"\" ; Elf_ ( Shdr ) * link_shdr = NULL ; const char * link_section_name = \"\" ; Sdb * sdb_vernaux = NULL ; Sdb * sdb_version = NULL ; Sdb * sdb = NULL ; int i , cnt ; if ( ! bin || ! bin -> dynstr ) { return NULL ; } if ( shdr -> sh_link > bin -> ehdr . e_shnum ) { return NULL ; } if ( shdr -> sh_size < 1 ) { return NULL ; } sdb = sdb_new0 ( ) ; if ( ! sdb ) { return NULL ; } link_shdr = & bin -> shdr [ shdr -> sh_link ] ; if ( bin -> shstrtab && shdr -> sh_name < bin -> shstrtab_size ) { section_name = & bin -> shstrtab [ shdr -> sh_name ] ; } if ( bin -> shstrtab && link_shdr -> sh_name < bin -> shstrtab_size ) { link_section_name = & bin -> shstrtab [ link_shdr -> sh_name ] ; } if ( ! ( need = ( ut8 * ) calloc ( R_MAX ( 1 , shdr -> sh_size ) , sizeof ( ut8 ) ) ) ) { bprintf ( \"Warning:<S2SV_blank>Cannot<S2SV_blank>allocate<S2SV_blank>memory<S2SV_blank>for<S2SV_blank>Elf_(Verneed)\\\\n\" ) ; goto beach ; } end = need + shdr -> sh_size ; sdb_set ( sdb , \"section_name\" , section_name , 0 ) ; sdb_num_set ( sdb , \"num_entries\" , shdr -> sh_info , 0 ) ; sdb_num_set ( sdb , \"addr\" , shdr -> sh_addr , 0 ) ; sdb_num_set ( sdb , \"offset\" , shdr -> sh_offset , 0 ) ; sdb_num_set ( sdb , \"link\" , shdr -> sh_link , 0 ) ; sdb_set ( sdb , \"link_section_name\" , link_section_name , 0 ) ; if ( shdr -> sh_offset > bin -> size || shdr -> sh_offset + shdr -> sh_size > bin -> size ) { goto beach ; } if ( shdr -> sh_offset + shdr -> sh_size < shdr -> sh_size ) { goto beach ; } i = r_buf_read_at ( bin -> b , shdr -> sh_offset , need , shdr -> sh_size ) ; if ( i < 0 ) goto beach ; for ( i = 0 , cnt = 0 ; cnt < shdr -> sh_info ; ++ cnt ) { int j , isum ; ut8 * vstart = need + i ; Elf_ ( Verneed ) vvn = { 0 } ; if ( vstart + sizeof ( Elf_ ( Verneed ) ) > end ) { goto beach ; } Elf_ ( Verneed ) * entry = & vvn ; char key [ 32 ] = { 0 } ; sdb_version = sdb_new0 ( ) ; if ( ! sdb_version ) { goto beach ; } j = 0 ; vvn . vn_version = READ16 ( vstart , j ) vvn . vn_cnt = READ16 ( vstart , j ) vvn . vn_file = READ32 ( vstart , j ) vvn . vn_aux = READ32 ( vstart , j ) vvn . vn_next = READ32 ( vstart , j ) sdb_num_set ( sdb_version , \"vn_version\" , entry -> vn_version , 0 ) ; sdb_num_set ( sdb_version , \"idx\" , i , 0 ) ; if ( entry -> vn_file > bin -> dynstr_size ) { goto beach ; } { char * s = r_str_ndup ( & bin -> dynstr [ entry -> vn_file ] , 16 ) ; sdb_set ( sdb_version , \"file_name\" , s , 0 ) ; free ( s ) ; } sdb_num_set ( sdb_version , \"cnt\" , entry -> vn_cnt , 0 ) ; <S2SV_StartBug> vstart += entry -> vn_aux ; <S2SV_EndBug> for ( j = 0 , isum = i + entry -> vn_aux ; j < entry -> vn_cnt && vstart + sizeof ( Elf_ ( Vernaux ) ) <= end ; ++ j ) { int k ; Elf_ ( Vernaux ) * aux = NULL ; Elf_ ( Vernaux ) vaux = { 0 } ; sdb_vernaux = sdb_new0 ( ) ; if ( ! sdb_vernaux ) { goto beach ; } aux = ( Elf_ ( Vernaux ) * ) & vaux ; k = 0 ; vaux . vna_hash = READ32 ( vstart , k ) vaux . vna_flags = READ16 ( vstart , k ) vaux . vna_other = READ16 ( vstart , k ) vaux . vna_name = READ32 ( vstart , k ) vaux . vna_next = READ32 ( vstart , k ) if ( aux -> vna_name > bin -> dynstr_size ) { goto beach ; } sdb_num_set ( sdb_vernaux , \"idx\" , isum , 0 ) ; if ( aux -> vna_name > 0 && aux -> vna_name + 8 < bin -> dynstr_size ) { char name [ 16 ] ; strncpy ( name , & bin -> dynstr [ aux -> vna_name ] , sizeof ( name ) - 1 ) ; name [ sizeof ( name ) - 1 ] = 0 ; sdb_set ( sdb_vernaux , \"name\" , name , 0 ) ; } sdb_set ( sdb_vernaux , \"flags\" , get_ver_flags ( aux -> vna_flags ) , 0 ) ; sdb_num_set ( sdb_vernaux , \"version\" , aux -> vna_other , 0 ) ; isum += aux -> vna_next ; vstart += aux -> vna_next ; snprintf ( key , sizeof ( key ) , \"vernaux%d\" , j ) ; sdb_ns_set ( sdb_version , key , sdb_vernaux ) ; } if ( ( int ) entry -> vn_next < 0 ) { bprintf ( \"Invalid<S2SV_blank>vn_next\\\\n\" ) ; break ; } i += entry -> vn_next ; snprintf ( key , sizeof ( key ) , \"version%d\" , cnt ) ; sdb_ns_set ( sdb , key , sdb_version ) ; if ( ! entry -> vn_next ) { break ; } } free ( need ) ; return sdb ; beach : free ( need ) ; sdb_free ( sdb_vernaux ) ; sdb_free ( sdb_version ) ; sdb_free ( sdb ) ; return NULL ; }\n",
      "fixed_code": "<S2SV_ModStart> 0 ) ; st32 vnaux = entry -> vn_aux ; if ( vnaux < 1 ) { goto beach ; } vstart += vnaux <S2SV_ModEnd> ; for (\n",
      "source_code_length": 4265,
      "target_code_length": 125,
      "vulnerability_patterns": {
        "buffer_overflow": 1,
        "use_after_free": 4,
        "integer_overflow": 6,
        "format_string": 2,
        "null_pointer": 63,
        "memory_leak": 1,
        "total": 77
      },
      "total_patterns": 77,
      "original_address": "https://github.com/radare/radare2/commit/c6d0076c924891ad9948a62d89d0bcdaf965f0cd",
      "discovery_time": "2017-10-27T18:29Z",
      "project_commit_id": "radare@radare2/c6d0076c924891ad9948a62d89d0bcdaf965f0cd",
      "extraction_time": "2025-08-31T15:41:49.175515",
      "label": 1,
      "vulnerability_type": "out-of-bounds_read",
      "difficulty_level": "expert",
      "risk_factors": [
        "memory_corruption",
        "critical_infrastructure",
        "buffer_overflow",
        "information_disclosure",
        "use_after_free",
        "integer_overflow"
      ],
      "attack_vectors": [
        "memory_manipulation",
        "malicious_input",
        "code_analysis",
        "buffer_overflow",
        "reverse_engineering",
        "fuzzing"
      ],
      "mitigation_strategies": [
        "safe_string_functions",
        "dynamic_analysis",
        "code_review",
        "static_analysis",
        "memory_safety_checks",
        "input_validation",
        "fuzzing",
        "bounds_checking",
        "secure_coding_practices"
      ],
      "code_differences": {
        "has_differences": true,
        "source_lines": 2,
        "target_lines": 2,
        "character_differences": 4140,
        "similarity_percentage": 13.043478260869565
      },
      "vulnerability_location": {
        "vulnerability_present": true,
        "fix_applied": true,
        "code_changed": true,
        "estimated_lines_changed": 0
      }
    },
    {
      "cve_id": "CVE-2018-20458",
      "cwe_id": "CWE-125",
      "cwe_name": "Out-of-bounds Read",
      "project": "radare",
      "severity": "critical",
      "weaponization_score": 10.0,
      "is_critical": true,
      "is_weaponizable": true,
      "is_high_priority_project": true,
      "vulnerable_code": "CWE-125 struct r_bin_dyldcache_obj_t * r_bin_dyldcache_from_bytes_new ( const ut8 * buf , ut64 size ) { <S2SV_StartBug> struct r_bin_dyldcache_obj_t * bin ; <S2SV_EndBug> <S2SV_StartBug> if ( ! ( bin = malloc ( sizeof ( struct r_bin_dyldcache_obj_t ) ) ) ) { <S2SV_EndBug> return NULL ; } <S2SV_StartBug> memset ( bin , 0 , sizeof ( struct r_bin_dyldcache_obj_t ) ) ; <S2SV_EndBug> if ( ! buf ) { return r_bin_dyldcache_free ( bin ) ; } bin -> b = r_buf_new ( ) ; <S2SV_StartBug> if ( ! r_buf_set_bytes ( bin -> b , buf , size ) ) { <S2SV_EndBug> return r_bin_dyldcache_free ( bin ) ; } if ( ! r_bin_dyldcache_init ( bin ) ) { return r_bin_dyldcache_free ( bin ) ; } bin -> size = size ; return bin ; }\n",
      "fixed_code": "<S2SV_ModStart> r_bin_dyldcache_obj_t * bin = R_NEW0 ( struct r_bin_dyldcache_obj_t ) <S2SV_ModStart> if ( ! bin <S2SV_ModEnd> ) { return <S2SV_ModStart> NULL ; } <S2SV_ModEnd> if ( ! <S2SV_ModStart> ; if ( ! bin -> b ||\n",
      "source_code_length": 703,
      "target_code_length": 221,
      "vulnerability_patterns": {
        "buffer_overflow": 1,
        "use_after_free": 1,
        "null_pointer": 5,
        "memory_leak": 1,
        "total": 8
      },
      "total_patterns": 8,
      "original_address": "https://github.com/radare/radare2/commit/4e98402f09a0ef0bb8559a33a4c1988c54938eaf",
      "discovery_time": "2018-12-25T19:29Z",
      "project_commit_id": "radare@radare2/4e98402f09a0ef0bb8559a33a4c1988c54938eaf",
      "extraction_time": "2025-08-31T15:41:49.175569",
      "label": 1,
      "vulnerability_type": "out-of-bounds_read",
      "difficulty_level": "expert",
      "risk_factors": [
        "memory_corruption",
        "critical_infrastructure",
        "buffer_overflow",
        "information_disclosure",
        "use_after_free",
        "integer_overflow"
      ],
      "attack_vectors": [
        "memory_manipulation",
        "malicious_input",
        "code_analysis",
        "buffer_overflow",
        "reverse_engineering",
        "fuzzing"
      ],
      "mitigation_strategies": [
        "safe_string_functions",
        "dynamic_analysis",
        "code_review",
        "static_analysis",
        "memory_safety_checks",
        "input_validation",
        "fuzzing",
        "bounds_checking",
        "secure_coding_practices"
      ],
      "code_differences": {
        "has_differences": true,
        "source_lines": 2,
        "target_lines": 2,
        "character_differences": 482,
        "similarity_percentage": 42.10526315789473
      },
      "vulnerability_location": {
        "vulnerability_present": true,
        "fix_applied": true,
        "code_changed": true,
        "estimated_lines_changed": 0
      }
    },
    {
      "cve_id": "CVE-2017-9761",
      "cwe_id": "CWE-119",
      "cwe_name": "Buffer Overflow",
      "project": "radare",
      "severity": "critical",
      "weaponization_score": 10.0,
      "is_critical": true,
      "is_weaponizable": true,
      "is_high_priority_project": true,
      "vulnerable_code": "CWE-119 static int r_core_cmd_subst_i ( RCore * core , char * cmd , char * colon ) { const char * quotestr = \"`\" ; const char * tick = NULL ; char * ptr , * ptr2 , * str ; char * arroba = NULL ; int i , ret = 0 , pipefd ; bool usemyblock = false ; int scr_html = - 1 ; int scr_color = - 1 ; bool eos = false ; bool haveQuote = false ; if ( ! cmd ) { return 0 ; } cmd = r_str_trim_head_tail ( cmd ) ; switch ( * cmd ) { case '.' : if ( cmd [ 1 ] == \\'\"\\' ) { return r_cmd_call ( core -> rcmd , cmd ) ; } break ; case \\'\"\\' : for ( ; * cmd ; ) { int pipefd = - 1 ; ut64 oseek = UT64_MAX ; char * line , * p ; haveQuote = * cmd == \\'\"\\' ; if ( haveQuote ) { cmd ++ ; <S2SV_StartBug> p = find_eoq ( cmd + 1 ) ; <S2SV_EndBug> if ( ! p || ! * p ) { eprintf ( \"Missing<S2SV_blank>\\\\\"<S2SV_blank>in<S2SV_blank>(%s).\" , cmd ) ; return false ; } * p ++ = 0 ; if ( ! * p ) { eos = true ; } } else { char * sc = strchr ( cmd , ';' ) ; if ( sc ) { * sc = 0 ; } r_core_cmd0 ( core , cmd ) ; if ( ! sc ) { break ; } cmd = sc + 1 ; continue ; } if ( p [ 0 ] ) { if ( p [ 0 ] == '@' ) { p -- ; } while ( p [ 1 ] == ';' || IS_WHITESPACE ( p [ 1 ] ) ) { p ++ ; } if ( p [ 1 ] == '@' || ( p [ 1 ] && p [ 2 ] == '@' ) ) { char * q = strchr ( p + 1 , \\'\"\\' ) ; if ( q ) { * q = 0 ; } haveQuote = q != NULL ; oseek = core -> offset ; r_core_seek ( core , r_num_math ( core -> num , p + 2 ) , 1 ) ; if ( q ) { * p = \\'\"\\' ; p = q ; } else { p = strchr ( p + 1 , ';' ) ; } } if ( p && * p && p [ 1 ] == '>' ) { str = p + 2 ; while ( * str == '>' ) { str ++ ; } while ( IS_WHITESPACE ( * str ) ) { str ++ ; } r_cons_flush ( ) ; pipefd = r_cons_pipe_open ( str , 1 , p [ 2 ] == '>' ) ; } } line = strdup ( cmd ) ; line = r_str_replace ( line , \"\\\\\\\\\\\\\"\" , \"\\\\\"\" , true ) ; if ( p && * p && p [ 1 ] == '|' ) { str = p + 2 ; while ( IS_WHITESPACE ( * str ) ) { str ++ ; } r_core_cmd_pipe ( core , cmd , str ) ; } else { r_cmd_call ( core -> rcmd , line ) ; } free ( line ) ; if ( oseek != UT64_MAX ) { r_core_seek ( core , oseek , 1 ) ; oseek = UT64_MAX ; } if ( pipefd != - 1 ) { r_cons_flush ( ) ; r_cons_pipe_close ( pipefd ) ; } if ( ! p ) { break ; } if ( eos ) { break ; } if ( haveQuote ) { if ( * p == ';' ) { cmd = p + 1 ; } else { if ( * p == \\'\"\\' ) { cmd = p + 1 ; } else { * p = \\'\"\\' ; cmd = p ; } } } else { cmd = p + 1 ; } } return true ; case '(' : if ( cmd [ 1 ] != '*' ) { return r_cmd_call ( core -> rcmd , cmd ) ; } } if ( * cmd != '#' ) { ptr = ( char * ) r_str_lastbut ( cmd , '#' , quotestr ) ; if ( ptr && ( ptr [ 1 ] == '<S2SV_blank>' || ptr [ 1 ] == '\\\\t' ) ) { * ptr = '\\\\0' ; } } if ( * cmd != '#' ) { ptr = ( char * ) r_str_lastbut ( cmd , ';' , quotestr ) ; if ( colon && ptr ) { int ret ; * ptr = '\\\\0' ; if ( r_core_cmd_subst ( core , cmd ) == - 1 ) { return - 1 ; } cmd = ptr + 1 ; ret = r_core_cmd_subst ( core , cmd ) ; * ptr = ';' ; return ret ; } } ptr = ( char * ) r_str_lastbut ( cmd , '|' , quotestr ) ; if ( ptr ) { char * ptr2 = strchr ( cmd , '`' ) ; if ( ! ptr2 || ( ptr2 && ptr2 > ptr ) ) { if ( ! tick || ( tick && tick > ptr ) ) { * ptr = '\\\\0' ; cmd = r_str_clean ( cmd ) ; if ( ! strcmp ( ptr + 1 , \"?\" ) ) { eprintf ( \"Usage:<S2SV_blank><r2command><S2SV_blank>|<S2SV_blank><program|H|>\\\\n\" ) ; eprintf ( \"<S2SV_blank>pd|?<S2SV_blank><S2SV_blank><S2SV_blank>-<S2SV_blank>show<S2SV_blank>this<S2SV_blank>help\\\\n\" ) ; eprintf ( \"<S2SV_blank>pd|<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>-<S2SV_blank>disable<S2SV_blank>scr.html<S2SV_blank>and<S2SV_blank>scr.color\\\\n\" ) ; eprintf ( \"<S2SV_blank>pd|H<S2SV_blank><S2SV_blank><S2SV_blank>-<S2SV_blank>enable<S2SV_blank>scr.html,<S2SV_blank>respect<S2SV_blank>scr.color\\\\n\" ) ; return ret ; } else if ( ! strcmp ( ptr + 1 , \"H\" ) ) { scr_html = r_config_get_i ( core -> config , \"scr.html\" ) ; r_config_set_i ( core -> config , \"scr.html\" , true ) ; } else if ( ptr [ 1 ] ) { int value = core -> num -> value ; if ( * cmd ) { r_core_cmd_pipe ( core , cmd , ptr + 1 ) ; } else { r_io_system ( core -> io , ptr + 1 ) ; } core -> num -> value = value ; return 0 ; } else { scr_html = r_config_get_i ( core -> config , \"scr.html\" ) ; r_config_set_i ( core -> config , \"scr.html\" , 0 ) ; scr_color = r_config_get_i ( core -> config , \"scr.color\" ) ; r_config_set_i ( core -> config , \"scr.color\" , false ) ; } } } } ptr = ( char * ) r_str_lastbut ( cmd , '&' , quotestr ) ; while ( ptr && ptr [ 1 ] == '&' ) { * ptr = '\\\\0' ; ret = r_cmd_call ( core -> rcmd , cmd ) ; if ( ret == - 1 ) { eprintf ( \"command<S2SV_blank>error(%s)\\\\n\" , cmd ) ; if ( scr_html != - 1 ) { r_config_set_i ( core -> config , \"scr.html\" , scr_html ) ; } if ( scr_color != - 1 ) { r_config_set_i ( core -> config , \"scr.color\" , scr_color ) ; } return ret ; } for ( cmd = ptr + 2 ; cmd && * cmd == '<S2SV_blank>' ; cmd ++ ) ; ptr = strchr ( cmd , '&' ) ; } free ( core -> oobi ) ; core -> oobi = NULL ; ptr = strstr ( cmd , \"?*\" ) ; if ( ptr ) { char * prech = ptr - 1 ; if ( * prech != '~' ) { ptr [ 1 ] = 0 ; if ( * cmd != '#' && strlen ( cmd ) < 5 ) { r_cons_break_push ( NULL , NULL ) ; recursive_help ( core , cmd ) ; r_cons_break_pop ( ) ; r_cons_grep_parsecmd ( ptr + 2 , \"`\" ) ; if ( scr_html != - 1 ) { r_config_set_i ( core -> config , \"scr.html\" , scr_html ) ; } if ( scr_color != - 1 ) { r_config_set_i ( core -> config , \"scr.color\" , scr_color ) ; } return 0 ; } } } # if 0 ptr = strchr ( cmd , '<' ) ; if ( ptr ) { ptr [ 0 ] = '\\\\0' ; if ( r_cons_singleton ( ) -> is_interactive ) { if ( ptr [ 1 ] == '<' ) { for ( str = ptr + 2 ; str [ 0 ] == '<S2SV_blank>' ; str ++ ) { } eprintf ( \"==><S2SV_blank>Reading<S2SV_blank>from<S2SV_blank>stdin<S2SV_blank>until<S2SV_blank>\\'%s\\'\\\\n\" , str ) ; free ( core -> oobi ) ; core -> oobi = malloc ( 1 ) ; if ( core -> oobi ) { core -> oobi [ 0 ] = '\\\\0' ; } core -> oobi_len = 0 ; for ( ; ; ) { char buf [ 1024 ] ; int ret ; write ( 1 , \"><S2SV_blank>\" , 2 ) ; fgets ( buf , sizeof ( buf ) - 1 , stdin ) ; if ( feof ( stdin ) ) { break ; } if ( * buf ) buf [ strlen ( buf ) - 1 ] = '\\\\0' ; ret = strlen ( buf ) ; core -> oobi_len += ret ; core -> oobi = realloc ( core -> oobi , core -> oobi_len + 1 ) ; if ( core -> oobi ) { if ( ! strcmp ( buf , str ) ) { break ; } strcat ( ( char * ) core -> oobi , buf ) ; } } } else { for ( str = ptr + 1 ; * str == '<S2SV_blank>' ; str ++ ) { } if ( ! * str ) { goto next ; } eprintf ( \"Slurping<S2SV_blank>file<S2SV_blank>\\'%s\\'\\\\n\" , str ) ; free ( core -> oobi ) ; core -> oobi = ( ut8 * ) r_file_slurp ( str , & core -> oobi_len ) ; if ( ! core -> oobi ) { eprintf ( \"cannot<S2SV_blank>open<S2SV_blank>file\\\\n\" ) ; } else if ( ptr == cmd ) { return r_core_cmd_buffer ( core , ( const char * ) core -> oobi ) ; } } } else { eprintf ( \"Cannot<S2SV_blank>slurp<S2SV_blank>with<S2SV_blank><<<S2SV_blank>in<S2SV_blank>non-interactive<S2SV_blank>mode\\\\n\" ) ; return 0 ; } } next : # endif ptr = strchr ( cmd , '>' ) ; if ( ptr ) { int fdn = 1 ; int pipecolor = r_config_get_i ( core -> config , \"scr.pipecolor\" ) ; int use_editor = false ; int ocolor = r_config_get_i ( core -> config , \"scr.color\" ) ; * ptr = '\\\\0' ; str = r_str_trim_head_tail ( ptr + 1 + ( ptr [ 1 ] == '>' ) ) ; if ( ! * str ) { eprintf ( \"No<S2SV_blank>output?\\\\n\" ) ; goto next2 ; } if ( ptr > ( cmd + 1 ) && ISWHITECHAR ( ptr [ - 2 ] ) ) { char * fdnum = ptr - 1 ; if ( * fdnum == 'H' ) { scr_html = r_config_get_i ( core -> config , \"scr.html\" ) ; r_config_set_i ( core -> config , \"scr.html\" , true ) ; pipecolor = true ; * fdnum = 0 ; } else { if ( IS_DIGIT ( * fdnum ) ) { fdn = * fdnum - '0' ; } * fdnum = 0 ; } } r_cons_set_interactive ( false ) ; if ( ! strcmp ( str , \"-\" ) ) { use_editor = true ; str = r_file_temp ( \"dumpedit\" ) ; r_config_set ( core -> config , \"scr.color\" , \"false\" ) ; } if ( fdn > 0 ) { pipefd = r_cons_pipe_open ( str , fdn , ptr [ 1 ] == '>' ) ; if ( pipefd != - 1 ) { if ( ! pipecolor ) { r_config_set_i ( core -> config , \"scr.color\" , 0 ) ; } ret = r_core_cmd_subst ( core , cmd ) ; r_cons_flush ( ) ; r_cons_pipe_close ( pipefd ) ; } } r_cons_set_last_interactive ( ) ; if ( ! pipecolor ) { r_config_set_i ( core -> config , \"scr.color\" , ocolor ) ; } if ( use_editor ) { const char * editor = r_config_get ( core -> config , \"cfg.editor\" ) ; if ( editor && * editor ) { r_sys_cmdf ( \"%s<S2SV_blank>\\'%s\\'\" , editor , str ) ; r_file_rm ( str ) ; } else { eprintf ( \"No<S2SV_blank>cfg.editor<S2SV_blank>configured\\\\n\" ) ; } r_config_set_i ( core -> config , \"scr.color\" , ocolor ) ; free ( str ) ; } if ( scr_html != - 1 ) { r_config_set_i ( core -> config , \"scr.html\" , scr_html ) ; } if ( scr_color != - 1 ) { r_config_set_i ( core -> config , \"scr.color\" , scr_color ) ; } return ret ; } next2 : ptr = strchr ( cmd , '`' ) ; if ( ptr ) { int empty = 0 ; int oneline = 1 ; if ( ptr [ 1 ] == '`' ) { memmove ( ptr , ptr + 1 , strlen ( ptr ) ) ; oneline = 0 ; empty = 1 ; } ptr2 = strchr ( ptr + 1 , '`' ) ; if ( empty ) { } else if ( ! ptr2 ) { eprintf ( \"parse:<S2SV_blank>Missing<S2SV_blank>backtick<S2SV_blank>in<S2SV_blank>expression.\\\\n\" ) ; goto fail ; } else { int value = core -> num -> value ; * ptr = '\\\\0' ; * ptr2 = '\\\\0' ; if ( ptr [ 1 ] == '!' ) { str = r_core_cmd_str_pipe ( core , ptr + 1 ) ; } else { str = r_core_cmd_str ( core , ptr + 1 ) ; } if ( ! str ) { goto fail ; } if ( * str == '|' || * str == '*' ) { eprintf ( \"r_core_cmd_subst_i:<S2SV_blank>invalid<S2SV_blank>backticked<S2SV_blank>command\\\\n\" ) ; free ( str ) ; goto fail ; } if ( oneline && str ) { for ( i = 0 ; str [ i ] ; i ++ ) { if ( str [ i ] == '\\\\n' ) { str [ i ] = '<S2SV_blank>' ; } } } str = r_str_append ( str , ptr2 + 1 ) ; cmd = r_str_append ( strdup ( cmd ) , str ) ; core -> num -> value = value ; ret = r_core_cmd_subst ( core , cmd ) ; free ( cmd ) ; if ( scr_html != - 1 ) { r_config_set_i ( core -> config , \"scr.html\" , scr_html ) ; } free ( str ) ; return ret ; } } core -> fixedblock = false ; if ( r_str_endswith ( cmd , \"~?\" ) && cmd [ 2 ] == '\\\\0' ) { r_cons_grep_help ( ) ; return true ; } if ( * cmd != '.' ) { r_cons_grep_parsecmd ( cmd , quotestr ) ; } if ( * cmd != '(' && * cmd != \\'\"\\' ) { ptr = strchr ( cmd , '@' ) ; if ( ptr == cmd + 1 && * cmd == '?' ) { ptr = NULL ; } } else { ptr = NULL ; } core -> tmpseek = ptr ? true : false ; int rc = 0 ; if ( ptr ) { char * f , * ptr2 = strchr ( ptr + 1 , '!' ) ; ut64 addr = UT64_MAX ; const char * tmpbits = NULL ; const char * offstr = NULL ; ut64 tmpbsz = core -> blocksize ; char * tmpeval = NULL ; ut64 tmpoff = core -> offset ; char * tmpasm = NULL ; int tmpfd = - 1 ; int sz , len ; ut8 * buf ; * ptr = '\\\\0' ; for ( ptr ++ ; * ptr == '<S2SV_blank>' ; ptr ++ ) { } if ( * ptr && ptr [ 1 ] == ':' ) { } else { ptr -- ; } arroba = ( ptr [ 0 ] && ptr [ 1 ] && ptr [ 2 ] ) ? strchr ( ptr + 2 , '@' ) : NULL ; repeat_arroba : if ( arroba ) { * arroba = 0 ; } if ( ptr [ 1 ] == '?' ) { helpCmdAt ( core ) ; } else if ( ptr [ 0 ] && ptr [ 1 ] == ':' && ptr [ 2 ] ) { usemyblock = true ; switch ( ptr [ 0 ] ) { case 'f' : f = r_file_slurp ( ptr + 2 , & sz ) ; if ( f ) { buf = malloc ( sz ) ; if ( buf ) { free ( core -> block ) ; core -> block = buf ; core -> blocksize = sz ; memcpy ( core -> block , f , sz ) ; } else { eprintf ( \"cannot<S2SV_blank>alloc<S2SV_blank>%d\" , sz ) ; } free ( f ) ; } else { eprintf ( \"cannot<S2SV_blank>open<S2SV_blank>\\'%s\\'\\\\n\" , ptr + 3 ) ; } break ; case 'r' : if ( ptr [ 1 ] == ':' ) { ut64 regval ; char * mander = strdup ( ptr + 2 ) ; char * sep = findSeparator ( mander ) ; if ( sep ) { char ch = * sep ; * sep = 0 ; regval = r_debug_reg_get ( core -> dbg , mander ) ; * sep = ch ; char * numexpr = r_str_newf ( \"0x%\" PFMT64x \"%s\" , regval , sep ) ; regval = r_num_math ( core -> num , numexpr ) ; free ( numexpr ) ; } else { regval = r_debug_reg_get ( core -> dbg , ptr + 2 ) ; } r_core_seek ( core , regval , 1 ) ; free ( mander ) ; } break ; case 'b' : tmpbits = strdup ( r_config_get ( core -> config , \"asm.bits\" ) ) ; r_config_set_i ( core -> config , \"asm.bits\" , r_num_math ( core -> num , ptr + 2 ) ) ; break ; case 'i' : { ut64 addr = r_num_math ( core -> num , ptr + 2 ) ; if ( addr ) { r_core_cmdf ( core , \"so<S2SV_blank>%s\" , ptr + 2 ) ; } } break ; case 'e' : tmpeval = parse_tmp_evals ( core , ptr + 2 ) ; break ; case 'x' : if ( ptr [ 1 ] == ':' ) { buf = malloc ( strlen ( ptr + 2 ) + 1 ) ; if ( buf ) { len = r_hex_str2bin ( ptr + 2 , buf ) ; r_core_block_size ( core , R_ABS ( len ) ) ; memcpy ( core -> block , buf , core -> blocksize ) ; core -> fixedblock = true ; free ( buf ) ; } else { eprintf ( \"cannot<S2SV_blank>allocate\\\\n\" ) ; } } else { eprintf ( \"Invalid<S2SV_blank>@x:<S2SV_blank>syntax\\\\n\" ) ; } break ; case 'k' : { char * out = sdb_querys ( core -> sdb , NULL , 0 , ptr + ( ( ptr [ 1 ] ) ? 2 : 1 ) ) ; if ( out ) { r_core_seek ( core , r_num_math ( core -> num , out ) , 1 ) ; free ( out ) ; } } break ; case 'o' : if ( ptr [ 1 ] == ':' ) { tmpfd = core -> io -> raised ; r_io_raise ( core -> io , atoi ( ptr + 2 ) ) ; } break ; case 'a' : if ( ptr [ 1 ] == ':' ) { char * q = strchr ( ptr + 2 , ':' ) ; tmpasm = strdup ( r_config_get ( core -> config , \"asm.arch\" ) ) ; if ( q ) { * q ++ = 0 ; tmpbits = r_config_get ( core -> config , \"asm.bits\" ) ; r_config_set ( core -> config , \"asm.bits\" , q ) ; } r_config_set ( core -> config , \"asm.arch\" , ptr + 2 ) ; } else { eprintf ( \"Usage:<S2SV_blank>pd<S2SV_blank>10<S2SV_blank>@a:arm:32\\\\n\" ) ; } break ; case 's' : len = strlen ( ptr + 2 ) ; r_core_block_size ( core , len ) ; memcpy ( core -> block , ptr + 2 , len ) ; break ; default : goto ignore ; } * ptr = '@' ; goto next_arroba ; } ignore : ptr = r_str_trim_head ( ptr + 1 ) ; ptr -- ; cmd = r_str_clean ( cmd ) ; if ( ptr2 ) { if ( strlen ( ptr + 1 ) == 13 && strlen ( ptr2 + 1 ) == 6 && ! memcmp ( ptr + 1 , \"0x\" , 2 ) && ! memcmp ( ptr2 + 1 , \"0x\" , 2 ) ) { } else if ( strlen ( ptr + 1 ) == 9 && strlen ( ptr2 + 1 ) == 4 ) { } else { * ptr2 = '\\\\0' ; if ( ! ptr2 [ 1 ] ) { goto fail ; } r_core_block_size ( core , r_num_math ( core -> num , ptr2 + 1 ) ) ; } } offstr = r_str_trim_head ( ptr + 1 ) ; addr = r_num_math ( core -> num , offstr ) ; if ( isalpha ( ( unsigned char ) ptr [ 1 ] ) && ! addr ) { if ( ! r_flag_get ( core -> flags , ptr + 1 ) ) { eprintf ( \"Invalid<S2SV_blank>address<S2SV_blank>(%s)\\\\n\" , ptr + 1 ) ; goto fail ; } } else { char ch = * offstr ; if ( ch == '-' || ch == '+' ) { addr = core -> offset + addr ; } } next_arroba : if ( arroba ) { ptr = arroba ; arroba = NULL ; goto repeat_arroba ; } if ( ptr [ 1 ] == '@' ) { if ( ptr [ 2 ] == '@' ) { char * rule = ptr + 3 ; while ( * rule && * rule == '<S2SV_blank>' ) rule ++ ; ret = r_core_cmd_foreach3 ( core , cmd , rule ) ; } else { ret = r_core_cmd_foreach ( core , cmd , ptr + 2 ) ; } } else { bool tmpseek = false ; const char * fromvars [ ] = { \"anal.from\" , \"diff.from\" , \"graph.from\" , \"io.buffer.from\" , \"lines.from\" , \"search.from\" , \"zoom.from\" , NULL } ; const char * tovars [ ] = { \"anal.to\" , \"diff.to\" , \"graph.to\" , \"io.buffer.to\" , \"lines.to\" , \"search.to\" , \"zoom.to\" , NULL } ; ut64 curfrom [ R_ARRAY_SIZE ( fromvars ) - 1 ] , curto [ R_ARRAY_SIZE ( tovars ) - 1 ] ; if ( ptr [ 1 ] == '.' && ptr [ 2 ] == '.' ) { char * range = ptr + 3 ; char * p = strchr ( range , '<S2SV_blank>' ) ; if ( ! p ) { eprintf ( \"Usage:<S2SV_blank>/<S2SV_blank>ABCD<S2SV_blank>@..0x1000<S2SV_blank>0x3000\\\\n\" ) ; free ( tmpeval ) ; free ( tmpasm ) ; goto fail ; } * p = '\\\\x00' ; ut64 from = r_num_math ( core -> num , range ) ; ut64 to = r_num_math ( core -> num , p + 1 ) ; for ( i = 0 ; fromvars [ i ] ; i ++ ) { curfrom [ i ] = r_config_get_i ( core -> config , fromvars [ i ] ) ; } for ( i = 0 ; tovars [ i ] ; i ++ ) { curto [ i ] = r_config_get_i ( core -> config , tovars [ i ] ) ; } for ( i = 0 ; fromvars [ i ] ; i ++ ) { r_config_set_i ( core -> config , fromvars [ i ] , from ) ; } for ( i = 0 ; tovars [ i ] ; i ++ ) { r_config_set_i ( core -> config , tovars [ i ] , to ) ; } tmpseek = true ; } if ( usemyblock ) { if ( addr != UT64_MAX ) { core -> offset = addr ; } ret = r_cmd_call ( core -> rcmd , r_str_trim_head ( cmd ) ) ; } else { if ( addr != UT64_MAX ) { if ( ! ptr [ 1 ] || r_core_seek ( core , addr , 1 ) ) { r_core_block_read ( core ) ; ret = r_cmd_call ( core -> rcmd , r_str_trim_head ( cmd ) ) ; } else { ret = 0 ; } } } if ( tmpseek ) { for ( i = 0 ; fromvars [ i ] ; i ++ ) { r_config_set_i ( core -> config , fromvars [ i ] , curfrom [ i ] ) ; } for ( i = 0 ; tovars [ i ] ; i ++ ) { r_config_set_i ( core -> config , tovars [ i ] , curto [ i ] ) ; } } } if ( ptr2 ) { * ptr2 = '!' ; r_core_block_size ( core , tmpbsz ) ; } if ( tmpasm ) { r_config_set ( core -> config , \"asm.arch\" , tmpasm ) ; tmpasm = NULL ; } if ( tmpfd != - 1 ) { r_io_raise ( core -> io , tmpfd ) ; } if ( tmpbits ) { r_config_set ( core -> config , \"asm.bits\" , tmpbits ) ; tmpbits = NULL ; } if ( tmpeval ) { r_core_cmd0 ( core , tmpeval ) ; R_FREE ( tmpeval ) ; } r_core_seek ( core , tmpoff , 1 ) ; * ptr = '@' ; rc = ret ; goto beach ; } rc = cmd ? r_cmd_call ( core -> rcmd , r_str_trim_head ( cmd ) ) : false ; beach : if ( scr_html != - 1 ) { r_cons_flush ( ) ; r_config_set_i ( core -> config , \"scr.html\" , scr_html ) ; } if ( scr_color != - 1 ) { r_config_set_i ( core -> config , \"scr.color\" , scr_color ) ; } core -> fixedblock = false ; return rc ; fail : rc = - 1 ; goto beach ; }\n",
      "fixed_code": "<S2SV_ModStart> ; p = cmd [ 0 ] ? <S2SV_ModStart> + 1 ) : NULL\n",
      "source_code_length": 17268,
      "target_code_length": 63,
      "vulnerability_patterns": {
        "buffer_overflow": 6,
        "use_after_free": 20,
        "integer_overflow": 24,
        "null_pointer": 122,
        "memory_leak": 4,
        "total": 176
      },
      "total_patterns": 176,
      "original_address": "https://github.com/radare/radare2/commit/00e8f205475332d7842d0f0d1481eeab4e83017c",
      "discovery_time": "2017-06-19T16:29Z",
      "project_commit_id": "radare@radare2/00e8f205475332d7842d0f0d1481eeab4e83017c",
      "extraction_time": "2025-08-31T15:41:49.175593",
      "label": 1,
      "vulnerability_type": "buffer_overflow",
      "difficulty_level": "expert",
      "risk_factors": [
        "memory_corruption",
        "critical_infrastructure",
        "arbitrary_code_execution",
        "buffer_overflow",
        "system_crash",
        "use_after_free"
      ],
      "attack_vectors": [
        "memory_manipulation",
        "malicious_input",
        "code_analysis",
        "buffer_overflow",
        "reverse_engineering",
        "fuzzing"
      ],
      "mitigation_strategies": [
        "safe_string_functions",
        "dynamic_analysis",
        "code_review",
        "static_analysis",
        "memory_safety_checks",
        "input_validation",
        "fuzzing",
        "bounds_checking",
        "secure_coding_practices"
      ],
      "code_differences": {
        "has_differences": true,
        "source_lines": 2,
        "target_lines": 2,
        "character_differences": 17205,
        "similarity_percentage": 4.075235109717868
      },
      "vulnerability_location": {
        "vulnerability_present": true,
        "fix_applied": true,
        "code_changed": true,
        "estimated_lines_changed": 0
      }
    },
    {
      "cve_id": "CVE-2018-16842",
      "cwe_id": "CWE-125",
      "cwe_name": "Out-of-bounds Read",
      "project": "curl",
      "severity": "critical",
      "weaponization_score": 10.0,
      "is_critical": true,
      "is_weaponizable": true,
      "is_high_priority_project": true,
      "vulnerable_code": "CWE-125 static void voutf ( struct GlobalConfig * config , const char * prefix , const char * fmt , va_list ap ) { size_t width = ( 79 - strlen ( prefix ) ) ; if ( ! config -> mute ) { size_t len ; char * ptr ; char * print_buffer ; print_buffer = curlx_mvaprintf ( fmt , ap ) ; if ( ! print_buffer ) return ; len = strlen ( print_buffer ) ; ptr = print_buffer ; while ( len > 0 ) { fputs ( prefix , config -> errors ) ; if ( len > width ) { size_t cut = width - 1 ; while ( ! ISSPACE ( ptr [ cut ] ) && cut ) { cut -- ; } if ( 0 == cut ) cut = width - 1 ; ( void ) fwrite ( ptr , cut + 1 , 1 , config -> errors ) ; fputs ( \"\\\\n\" , config -> errors ) ; ptr += cut + 1 ; <S2SV_StartBug> len -= cut ; <S2SV_EndBug> } else { fputs ( ptr , config -> errors ) ; len = 0 ; } } curl_free ( print_buffer ) ; } }\n",
      "fixed_code": "<S2SV_ModStart> len -= cut + 1\n",
      "source_code_length": 804,
      "target_code_length": 31,
      "vulnerability_patterns": {
        "buffer_overflow": 1,
        "integer_overflow": 3,
        "null_pointer": 7,
        "total": 11
      },
      "total_patterns": 11,
      "original_address": "https://github.com/curl/curl/commit/d530e92f59ae9bb2d47066c3c460b25d2ffeb211",
      "discovery_time": "2018-10-31T19:29Z",
      "project_commit_id": "curl@curl/d530e92f59ae9bb2d47066c3c460b25d2ffeb211",
      "extraction_time": "2025-08-31T15:41:49.175744",
      "label": 1,
      "vulnerability_type": "out-of-bounds_read",
      "difficulty_level": "expert",
      "risk_factors": [
        "memory_corruption",
        "critical_infrastructure",
        "buffer_overflow",
        "information_disclosure",
        "integer_overflow"
      ],
      "attack_vectors": [
        "memory_manipulation",
        "malicious_input",
        "code_analysis",
        "buffer_overflow",
        "reverse_engineering",
        "fuzzing"
      ],
      "mitigation_strategies": [
        "safe_string_functions",
        "dynamic_analysis",
        "code_review",
        "static_analysis",
        "memory_safety_checks",
        "input_validation",
        "fuzzing",
        "bounds_checking",
        "secure_coding_practices"
      ],
      "code_differences": {
        "has_differences": true,
        "source_lines": 2,
        "target_lines": 2,
        "character_differences": 773,
        "similarity_percentage": 8.620689655172415
      },
      "vulnerability_location": {
        "vulnerability_present": true,
        "fix_applied": true,
        "code_changed": true,
        "estimated_lines_changed": 0
      }
    },
    {
      "cve_id": "CVE-2013-7008",
      "cwe_id": "CWE-000",
      "cwe_name": "Unknown/Uncategorized",
      "project": "FFmpeg",
      "severity": "critical",
      "weaponization_score": 10.0,
      "is_critical": true,
      "is_weaponizable": true,
      "is_high_priority_project": true,
      "vulnerable_code": "CWE-000 static int decode_slice_header ( H264Context * h , H264Context * h0 ) { unsigned int first_mb_in_slice ; unsigned int pps_id ; int ret ; unsigned int slice_type , tmp , i , j ; int last_pic_structure , last_pic_droppable ; int must_reinit ; int needs_reinit = 0 ; int field_pic_flag , bottom_field_flag ; h -> me . qpel_put = h -> h264qpel . put_h264_qpel_pixels_tab ; h -> me . qpel_avg = h -> h264qpel . avg_h264_qpel_pixels_tab ; first_mb_in_slice = get_ue_golomb_long ( & h -> gb ) ; if ( first_mb_in_slice == 0 ) { if ( h0 -> current_slice && FIELD_PICTURE ( h ) ) { field_end ( h , 1 ) ; } h0 -> current_slice = 0 ; if ( ! h0 -> first_field ) { if ( h -> cur_pic_ptr && ! h -> droppable ) { ff_thread_report_progress ( & h -> cur_pic_ptr -> tf , INT_MAX , h -> picture_structure == PICT_BOTTOM_FIELD ) ; } h -> cur_pic_ptr = NULL ; } } slice_type = get_ue_golomb_31 ( & h -> gb ) ; if ( slice_type > 9 ) { av_log ( h -> avctx , AV_LOG_ERROR , \"slice<S2SV_blank>type<S2SV_blank>too<S2SV_blank>large<S2SV_blank>(%d)<S2SV_blank>at<S2SV_blank>%d<S2SV_blank>%d\\\\n\" , slice_type , h -> mb_x , h -> mb_y ) ; return AVERROR_INVALIDDATA ; } if ( slice_type > 4 ) { slice_type -= 5 ; h -> slice_type_fixed = 1 ; } else h -> slice_type_fixed = 0 ; slice_type = golomb_to_pict_type [ slice_type ] ; h -> slice_type = slice_type ; h -> slice_type_nos = slice_type & 3 ; h -> pict_type = h -> slice_type ; pps_id = get_ue_golomb ( & h -> gb ) ; if ( pps_id >= MAX_PPS_COUNT ) { av_log ( h -> avctx , AV_LOG_ERROR , \"pps_id<S2SV_blank>%d<S2SV_blank>out<S2SV_blank>of<S2SV_blank>range\\\\n\" , pps_id ) ; return AVERROR_INVALIDDATA ; } if ( ! h0 -> pps_buffers [ pps_id ] ) { av_log ( h -> avctx , AV_LOG_ERROR , \"non-existing<S2SV_blank>PPS<S2SV_blank>%u<S2SV_blank>referenced\\\\n\" , pps_id ) ; return AVERROR_INVALIDDATA ; } h -> pps = * h0 -> pps_buffers [ pps_id ] ; if ( ! h0 -> sps_buffers [ h -> pps . sps_id ] ) { av_log ( h -> avctx , AV_LOG_ERROR , \"non-existing<S2SV_blank>SPS<S2SV_blank>%u<S2SV_blank>referenced\\\\n\" , h -> pps . sps_id ) ; return AVERROR_INVALIDDATA ; } if ( h -> pps . sps_id != h -> current_sps_id || h0 -> sps_buffers [ h -> pps . sps_id ] -> new ) { h0 -> sps_buffers [ h -> pps . sps_id ] -> new = 0 ; h -> current_sps_id = h -> pps . sps_id ; h -> sps = * h0 -> sps_buffers [ h -> pps . sps_id ] ; if ( h -> mb_width != h -> sps . mb_width || h -> mb_height != h -> sps . mb_height * ( 2 - h -> sps . frame_mbs_only_flag ) || h -> avctx -> bits_per_raw_sample != h -> sps . bit_depth_luma || h -> cur_chroma_format_idc != h -> sps . chroma_format_idc ) needs_reinit = 1 ; if ( h -> bit_depth_luma != h -> sps . bit_depth_luma || h -> chroma_format_idc != h -> sps . chroma_format_idc ) { h -> bit_depth_luma = h -> sps . bit_depth_luma ; h -> chroma_format_idc = h -> sps . chroma_format_idc ; needs_reinit = 1 ; } if ( ( ret = h264_set_parameter_from_sps ( h ) ) < 0 ) return ret ; } h -> avctx -> profile = ff_h264_get_profile ( & h -> sps ) ; h -> avctx -> level = h -> sps . level_idc ; h -> avctx -> refs = h -> sps . ref_frame_count ; must_reinit = ( h -> context_initialized && ( 16 * h -> sps . mb_width != h -> avctx -> coded_width || 16 * h -> sps . mb_height * ( 2 - h -> sps . frame_mbs_only_flag ) != h -> avctx -> coded_height || h -> avctx -> bits_per_raw_sample != h -> sps . bit_depth_luma || h -> cur_chroma_format_idc != h -> sps . chroma_format_idc || av_cmp_q ( h -> sps . sar , h -> avctx -> sample_aspect_ratio ) || h -> mb_width != h -> sps . mb_width || h -> mb_height != h -> sps . mb_height * ( 2 - h -> sps . frame_mbs_only_flag ) ) ) ; if ( h0 -> avctx -> pix_fmt != get_pixel_format ( h0 , 0 ) ) must_reinit = 1 ; h -> mb_width = h -> sps . mb_width ; h -> mb_height = h -> sps . mb_height * ( 2 - h -> sps . frame_mbs_only_flag ) ; h -> mb_num = h -> mb_width * h -> mb_height ; h -> mb_stride = h -> mb_width + 1 ; h -> b_stride = h -> mb_width * 4 ; h -> chroma_y_shift = h -> sps . chroma_format_idc <= 1 ; h -> width = 16 * h -> mb_width ; h -> height = 16 * h -> mb_height ; ret = init_dimensions ( h ) ; if ( ret < 0 ) return ret ; if ( h -> sps . video_signal_type_present_flag ) { h -> avctx -> color_range = h -> sps . full_range > 0 ? AVCOL_RANGE_JPEG : AVCOL_RANGE_MPEG ; if ( h -> sps . colour_description_present_flag ) { if ( h -> avctx -> colorspace != h -> sps . colorspace ) needs_reinit = 1 ; h -> avctx -> color_primaries = h -> sps . color_primaries ; h -> avctx -> color_trc = h -> sps . color_trc ; h -> avctx -> colorspace = h -> sps . colorspace ; } } if ( h -> context_initialized && ( h -> width != h -> avctx -> coded_width || h -> height != h -> avctx -> coded_height || must_reinit || needs_reinit ) ) { if ( h != h0 ) { av_log ( h -> avctx , AV_LOG_ERROR , \"changing<S2SV_blank>width/height<S2SV_blank>on<S2SV_blank>\" \"slice<S2SV_blank>%d\\\\n\" , h0 -> current_slice + 1 ) ; return AVERROR_INVALIDDATA ; } flush_change ( h ) ; if ( ( ret = get_pixel_format ( h , 1 ) ) < 0 ) return ret ; h -> avctx -> pix_fmt = ret ; av_log ( h -> avctx , AV_LOG_INFO , \"Reinit<S2SV_blank>context<S2SV_blank>to<S2SV_blank>%dx%d,<S2SV_blank>\" \"pix_fmt:<S2SV_blank>%s\\\\n\" , h -> width , h -> height , av_get_pix_fmt_name ( h -> avctx -> pix_fmt ) ) ; if ( ( ret = h264_slice_header_init ( h , 1 ) ) < 0 ) { av_log ( h -> avctx , AV_LOG_ERROR , \"h264_slice_header_init()<S2SV_blank>failed\\\\n\" ) ; return ret ; } } if ( ! h -> context_initialized ) { if ( h != h0 ) { av_log ( h -> avctx , AV_LOG_ERROR , \"Cannot<S2SV_blank>(re-)initialize<S2SV_blank>context<S2SV_blank>during<S2SV_blank>parallel<S2SV_blank>decoding.\\\\n\" ) ; return AVERROR_PATCHWELCOME ; } if ( ( ret = get_pixel_format ( h , 1 ) ) < 0 ) return ret ; h -> avctx -> pix_fmt = ret ; if ( ( ret = h264_slice_header_init ( h , 0 ) ) < 0 ) { av_log ( h -> avctx , AV_LOG_ERROR , \"h264_slice_header_init()<S2SV_blank>failed\\\\n\" ) ; return ret ; } } if ( h == h0 && h -> dequant_coeff_pps != pps_id ) { h -> dequant_coeff_pps = pps_id ; init_dequant_tables ( h ) ; } h -> frame_num = get_bits ( & h -> gb , h -> sps . log2_max_frame_num ) ; h -> mb_mbaff = 0 ; h -> mb_aff_frame = 0 ; last_pic_structure = h0 -> picture_structure ; last_pic_droppable = h0 -> droppable ; h -> droppable = h -> nal_ref_idc == 0 ; if ( h -> sps . frame_mbs_only_flag ) { h -> picture_structure = PICT_FRAME ; } else { if ( ! h -> sps . direct_8x8_inference_flag && slice_type == AV_PICTURE_TYPE_B ) { av_log ( h -> avctx , AV_LOG_ERROR , \"This<S2SV_blank>stream<S2SV_blank>was<S2SV_blank>generated<S2SV_blank>by<S2SV_blank>a<S2SV_blank>broken<S2SV_blank>encoder,<S2SV_blank>invalid<S2SV_blank>8x8<S2SV_blank>inference\\\\n\" ) ; return - 1 ; } field_pic_flag = get_bits1 ( & h -> gb ) ; if ( field_pic_flag ) { bottom_field_flag = get_bits1 ( & h -> gb ) ; h -> picture_structure = PICT_TOP_FIELD + bottom_field_flag ; } else { h -> picture_structure = PICT_FRAME ; h -> mb_aff_frame = h -> sps . mb_aff ; } } h -> mb_field_decoding_flag = h -> picture_structure != PICT_FRAME ; if ( h0 -> current_slice != 0 ) { if ( last_pic_structure != h -> picture_structure || last_pic_droppable != h -> droppable ) { av_log ( h -> avctx , AV_LOG_ERROR , \"Changing<S2SV_blank>field<S2SV_blank>mode<S2SV_blank>(%d<S2SV_blank>-><S2SV_blank>%d)<S2SV_blank>between<S2SV_blank>slices<S2SV_blank>is<S2SV_blank>not<S2SV_blank>allowed\\\\n\" , last_pic_structure , h -> picture_structure ) ; h -> picture_structure = last_pic_structure ; h -> droppable = last_pic_droppable ; return AVERROR_INVALIDDATA ; } else if ( ! h0 -> cur_pic_ptr ) { av_log ( h -> avctx , AV_LOG_ERROR , \"unset<S2SV_blank>cur_pic_ptr<S2SV_blank>on<S2SV_blank>%d.<S2SV_blank>slice\\\\n\" , h0 -> current_slice + 1 ) ; return AVERROR_INVALIDDATA ; } } else { if ( h -> frame_num != h -> prev_frame_num && h -> prev_frame_num >= 0 ) { int unwrap_prev_frame_num = h -> prev_frame_num ; int max_frame_num = 1 << h -> sps . log2_max_frame_num ; if ( unwrap_prev_frame_num > h -> frame_num ) unwrap_prev_frame_num -= max_frame_num ; if ( ( h -> frame_num - unwrap_prev_frame_num ) > h -> sps . ref_frame_count ) { unwrap_prev_frame_num = ( h -> frame_num - h -> sps . ref_frame_count ) - 1 ; if ( unwrap_prev_frame_num < 0 ) unwrap_prev_frame_num += max_frame_num ; h -> prev_frame_num = unwrap_prev_frame_num ; } } if ( h0 -> first_field ) { assert ( h0 -> cur_pic_ptr ) ; assert ( h0 -> cur_pic_ptr -> f . data [ 0 ] ) ; assert ( h0 -> cur_pic_ptr -> reference != DELAYED_PIC_REF ) ; <S2SV_StartBug> if ( ! last_pic_droppable && h0 -> cur_pic_ptr -> tf . owner == h0 -> avctx ) { <S2SV_EndBug> ff_thread_report_progress ( & h0 -> cur_pic_ptr -> tf , INT_MAX , last_pic_structure == PICT_BOTTOM_FIELD ) ; } if ( ! FIELD_PICTURE ( h ) || h -> picture_structure == last_pic_structure ) { <S2SV_StartBug> if ( ! last_pic_droppable && last_pic_structure != PICT_FRAME ) { <S2SV_EndBug> ff_thread_report_progress ( & h0 -> cur_pic_ptr -> tf , INT_MAX , last_pic_structure == PICT_TOP_FIELD ) ; } } else { if ( h0 -> cur_pic_ptr -> frame_num != h -> frame_num ) { <S2SV_StartBug> if ( ! last_pic_droppable && last_pic_structure != PICT_FRAME ) { <S2SV_EndBug> ff_thread_report_progress ( & h0 -> cur_pic_ptr -> tf , INT_MAX , last_pic_structure == PICT_TOP_FIELD ) ; } } else { if ( ! ( ( last_pic_structure == PICT_TOP_FIELD && h -> picture_structure == PICT_BOTTOM_FIELD ) || ( last_pic_structure == PICT_BOTTOM_FIELD && h -> picture_structure == PICT_TOP_FIELD ) ) ) { av_log ( h -> avctx , AV_LOG_ERROR , \"Invalid<S2SV_blank>field<S2SV_blank>mode<S2SV_blank>combination<S2SV_blank>%d/%d\\\\n\" , last_pic_structure , h -> picture_structure ) ; h -> picture_structure = last_pic_structure ; h -> droppable = last_pic_droppable ; return AVERROR_INVALIDDATA ; } else if ( last_pic_droppable != h -> droppable ) { avpriv_request_sample ( h -> avctx , \"Found<S2SV_blank>reference<S2SV_blank>and<S2SV_blank>non-reference<S2SV_blank>fields<S2SV_blank>in<S2SV_blank>the<S2SV_blank>same<S2SV_blank>frame,<S2SV_blank>which\" ) ; h -> picture_structure = last_pic_structure ; h -> droppable = last_pic_droppable ; return AVERROR_PATCHWELCOME ; } } } } while ( h -> frame_num != h -> prev_frame_num && h -> prev_frame_num >= 0 && ! h0 -> first_field && h -> frame_num != ( h -> prev_frame_num + 1 ) % ( 1 << h -> sps . log2_max_frame_num ) ) { Picture * prev = h -> short_ref_count ? h -> short_ref [ 0 ] : NULL ; av_log ( h -> avctx , AV_LOG_DEBUG , \"Frame<S2SV_blank>num<S2SV_blank>gap<S2SV_blank>%d<S2SV_blank>%d\\\\n\" , h -> frame_num , h -> prev_frame_num ) ; if ( ! h -> sps . gaps_in_frame_num_allowed_flag ) for ( i = 0 ; i < FF_ARRAY_ELEMS ( h -> last_pocs ) ; i ++ ) h -> last_pocs [ i ] = INT_MIN ; ret = h264_frame_start ( h ) ; if ( ret < 0 ) return ret ; h -> prev_frame_num ++ ; h -> prev_frame_num %= 1 << h -> sps . log2_max_frame_num ; h -> cur_pic_ptr -> frame_num = h -> prev_frame_num ; ff_thread_report_progress ( & h -> cur_pic_ptr -> tf , INT_MAX , 0 ) ; ff_thread_report_progress ( & h -> cur_pic_ptr -> tf , INT_MAX , 1 ) ; ret = ff_generate_sliding_window_mmcos ( h , 1 ) ; if ( ret < 0 && ( h -> avctx -> err_recognition & AV_EF_EXPLODE ) ) return ret ; ret = ff_h264_execute_ref_pic_marking ( h , h -> mmco , h -> mmco_index ) ; if ( ret < 0 && ( h -> avctx -> err_recognition & AV_EF_EXPLODE ) ) return ret ; if ( h -> short_ref_count ) { if ( prev ) { av_image_copy ( h -> short_ref [ 0 ] -> f . data , h -> short_ref [ 0 ] -> f . linesize , ( const uint8_t * * ) prev -> f . data , prev -> f . linesize , h -> avctx -> pix_fmt , h -> mb_width * 16 , h -> mb_height * 16 ) ; h -> short_ref [ 0 ] -> poc = prev -> poc + 2 ; } h -> short_ref [ 0 ] -> frame_num = h -> prev_frame_num ; } } if ( h0 -> first_field ) { assert ( h0 -> cur_pic_ptr ) ; assert ( h0 -> cur_pic_ptr -> f . data [ 0 ] ) ; assert ( h0 -> cur_pic_ptr -> reference != DELAYED_PIC_REF ) ; if ( ! FIELD_PICTURE ( h ) || h -> picture_structure == last_pic_structure ) { h0 -> cur_pic_ptr = NULL ; h0 -> first_field = FIELD_PICTURE ( h ) ; } else { if ( h0 -> cur_pic_ptr -> frame_num != h -> frame_num ) { ff_thread_report_progress ( & h0 -> cur_pic_ptr -> tf , INT_MAX , h0 -> picture_structure == PICT_BOTTOM_FIELD ) ; h0 -> first_field = 1 ; h0 -> cur_pic_ptr = NULL ; } else { h0 -> first_field = 0 ; } } } else { h0 -> first_field = FIELD_PICTURE ( h ) ; } if ( ! FIELD_PICTURE ( h ) || h0 -> first_field ) { if ( h264_frame_start ( h ) < 0 ) { h0 -> first_field = 0 ; return AVERROR_INVALIDDATA ; } } else { release_unused_pictures ( h , 0 ) ; } if ( FIELD_PICTURE ( h ) ) { for ( i = ( h -> picture_structure == PICT_BOTTOM_FIELD ) ; i < h -> mb_height ; i ++ ) memset ( h -> slice_table + i * h -> mb_stride , - 1 , ( h -> mb_stride - ( i + 1 == h -> mb_height ) ) * sizeof ( * h -> slice_table ) ) ; } else { memset ( h -> slice_table , - 1 , ( h -> mb_height * h -> mb_stride - 1 ) * sizeof ( * h -> slice_table ) ) ; } h0 -> last_slice_type = - 1 ; } if ( h != h0 && ( ret = clone_slice ( h , h0 ) ) < 0 ) return ret ; for ( i = 0 ; i < h -> slice_context_count ; i ++ ) if ( h -> thread_context [ i ] ) { ret = alloc_scratch_buffers ( h -> thread_context [ i ] , h -> linesize ) ; if ( ret < 0 ) return ret ; } h -> cur_pic_ptr -> frame_num = h -> frame_num ; av_assert1 ( h -> mb_num == h -> mb_width * h -> mb_height ) ; if ( first_mb_in_slice << FIELD_OR_MBAFF_PICTURE ( h ) >= h -> mb_num || first_mb_in_slice >= h -> mb_num ) { av_log ( h -> avctx , AV_LOG_ERROR , \"first_mb_in_slice<S2SV_blank>overflow\\\\n\" ) ; return AVERROR_INVALIDDATA ; } h -> resync_mb_x = h -> mb_x = first_mb_in_slice % h -> mb_width ; h -> resync_mb_y = h -> mb_y = ( first_mb_in_slice / h -> mb_width ) << FIELD_OR_MBAFF_PICTURE ( h ) ; if ( h -> picture_structure == PICT_BOTTOM_FIELD ) h -> resync_mb_y = h -> mb_y = h -> mb_y + 1 ; av_assert1 ( h -> mb_y < h -> mb_height ) ; if ( h -> picture_structure == PICT_FRAME ) { h -> curr_pic_num = h -> frame_num ; h -> max_pic_num = 1 << h -> sps . log2_max_frame_num ; } else { h -> curr_pic_num = 2 * h -> frame_num + 1 ; h -> max_pic_num = 1 << ( h -> sps . log2_max_frame_num + 1 ) ; } if ( h -> nal_unit_type == NAL_IDR_SLICE ) get_ue_golomb ( & h -> gb ) ; if ( h -> sps . poc_type == 0 ) { h -> poc_lsb = get_bits ( & h -> gb , h -> sps . log2_max_poc_lsb ) ; if ( h -> pps . pic_order_present == 1 && h -> picture_structure == PICT_FRAME ) h -> delta_poc_bottom = get_se_golomb ( & h -> gb ) ; } if ( h -> sps . poc_type == 1 && ! h -> sps . delta_pic_order_always_zero_flag ) { h -> delta_poc [ 0 ] = get_se_golomb ( & h -> gb ) ; if ( h -> pps . pic_order_present == 1 && h -> picture_structure == PICT_FRAME ) h -> delta_poc [ 1 ] = get_se_golomb ( & h -> gb ) ; } ff_init_poc ( h , h -> cur_pic_ptr -> field_poc , & h -> cur_pic_ptr -> poc ) ; if ( h -> pps . redundant_pic_cnt_present ) h -> redundant_pic_count = get_ue_golomb ( & h -> gb ) ; ret = ff_set_ref_count ( h ) ; if ( ret < 0 ) return ret ; if ( slice_type != AV_PICTURE_TYPE_I && ( h0 -> current_slice == 0 || slice_type != h0 -> last_slice_type || memcmp ( h0 -> last_ref_count , h0 -> ref_count , sizeof ( h0 -> ref_count ) ) ) ) { ff_h264_fill_default_ref_list ( h ) ; } if ( h -> slice_type_nos != AV_PICTURE_TYPE_I ) { ret = ff_h264_decode_ref_pic_list_reordering ( h ) ; if ( ret < 0 ) { h -> ref_count [ 1 ] = h -> ref_count [ 0 ] = 0 ; return ret ; } } if ( ( h -> pps . weighted_pred && h -> slice_type_nos == AV_PICTURE_TYPE_P ) || ( h -> pps . weighted_bipred_idc == 1 && h -> slice_type_nos == AV_PICTURE_TYPE_B ) ) ff_pred_weight_table ( h ) ; else if ( h -> pps . weighted_bipred_idc == 2 && h -> slice_type_nos == AV_PICTURE_TYPE_B ) { implicit_weight_table ( h , - 1 ) ; } else { h -> use_weight = 0 ; for ( i = 0 ; i < 2 ; i ++ ) { h -> luma_weight_flag [ i ] = 0 ; h -> chroma_weight_flag [ i ] = 0 ; } } if ( h -> nal_ref_idc ) { ret = ff_h264_decode_ref_pic_marking ( h0 , & h -> gb , ! ( h -> avctx -> active_thread_type & FF_THREAD_FRAME ) || h0 -> current_slice == 0 ) ; if ( ret < 0 && ( h -> avctx -> err_recognition & AV_EF_EXPLODE ) ) return AVERROR_INVALIDDATA ; } if ( FRAME_MBAFF ( h ) ) { ff_h264_fill_mbaff_ref_list ( h ) ; if ( h -> pps . weighted_bipred_idc == 2 && h -> slice_type_nos == AV_PICTURE_TYPE_B ) { implicit_weight_table ( h , 0 ) ; implicit_weight_table ( h , 1 ) ; } } if ( h -> slice_type_nos == AV_PICTURE_TYPE_B && ! h -> direct_spatial_mv_pred ) ff_h264_direct_dist_scale_factor ( h ) ; ff_h264_direct_ref_list_init ( h ) ; if ( h -> slice_type_nos != AV_PICTURE_TYPE_I && h -> pps . cabac ) { tmp = get_ue_golomb_31 ( & h -> gb ) ; if ( tmp > 2 ) { av_log ( h -> avctx , AV_LOG_ERROR , \"cabac_init_idc<S2SV_blank>overflow\\\\n\" ) ; return AVERROR_INVALIDDATA ; } h -> cabac_init_idc = tmp ; } h -> last_qscale_diff = 0 ; tmp = h -> pps . init_qp + get_se_golomb ( & h -> gb ) ; if ( tmp > 51 + 6 * ( h -> sps . bit_depth_luma - 8 ) ) { av_log ( h -> avctx , AV_LOG_ERROR , \"QP<S2SV_blank>%u<S2SV_blank>out<S2SV_blank>of<S2SV_blank>range\\\\n\" , tmp ) ; return AVERROR_INVALIDDATA ; } h -> qscale = tmp ; h -> chroma_qp [ 0 ] = get_chroma_qp ( h , 0 , h -> qscale ) ; h -> chroma_qp [ 1 ] = get_chroma_qp ( h , 1 , h -> qscale ) ; if ( h -> slice_type == AV_PICTURE_TYPE_SP ) get_bits1 ( & h -> gb ) ; if ( h -> slice_type == AV_PICTURE_TYPE_SP || h -> slice_type == AV_PICTURE_TYPE_SI ) get_se_golomb ( & h -> gb ) ; h -> deblocking_filter = 1 ; h -> slice_alpha_c0_offset = 52 ; h -> slice_beta_offset = 52 ; if ( h -> pps . deblocking_filter_parameters_present ) { tmp = get_ue_golomb_31 ( & h -> gb ) ; if ( tmp > 2 ) { av_log ( h -> avctx , AV_LOG_ERROR , \"deblocking_filter_idc<S2SV_blank>%u<S2SV_blank>out<S2SV_blank>of<S2SV_blank>range\\\\n\" , tmp ) ; return AVERROR_INVALIDDATA ; } h -> deblocking_filter = tmp ; if ( h -> deblocking_filter < 2 ) h -> deblocking_filter ^= 1 ; if ( h -> deblocking_filter ) { h -> slice_alpha_c0_offset += get_se_golomb ( & h -> gb ) << 1 ; h -> slice_beta_offset += get_se_golomb ( & h -> gb ) << 1 ; if ( h -> slice_alpha_c0_offset > 104U || h -> slice_beta_offset > 104U ) { av_log ( h -> avctx , AV_LOG_ERROR , \"deblocking<S2SV_blank>filter<S2SV_blank>parameters<S2SV_blank>%d<S2SV_blank>%d<S2SV_blank>out<S2SV_blank>of<S2SV_blank>range\\\\n\" , h -> slice_alpha_c0_offset , h -> slice_beta_offset ) ; return AVERROR_INVALIDDATA ; } } } if ( h -> avctx -> skip_loop_filter >= AVDISCARD_ALL || ( h -> avctx -> skip_loop_filter >= AVDISCARD_NONKEY && h -> slice_type_nos != AV_PICTURE_TYPE_I ) || ( h -> avctx -> skip_loop_filter >= AVDISCARD_BIDIR && h -> slice_type_nos == AV_PICTURE_TYPE_B ) || ( h -> avctx -> skip_loop_filter >= AVDISCARD_NONREF && h -> nal_ref_idc == 0 ) ) h -> deblocking_filter = 0 ; if ( h -> deblocking_filter == 1 && h0 -> max_contexts > 1 ) { if ( h -> avctx -> flags2 & CODEC_FLAG2_FAST ) { h -> deblocking_filter = 2 ; } else { h0 -> max_contexts = 1 ; if ( ! h0 -> single_decode_warning ) { av_log ( h -> avctx , AV_LOG_INFO , \"Cannot<S2SV_blank>parallelize<S2SV_blank>deblocking<S2SV_blank>type<S2SV_blank>1,<S2SV_blank>decoding<S2SV_blank>such<S2SV_blank>frames<S2SV_blank>in<S2SV_blank>sequential<S2SV_blank>order\\\\n\" ) ; h0 -> single_decode_warning = 1 ; } if ( h != h0 ) { av_log ( h -> avctx , AV_LOG_ERROR , \"Deblocking<S2SV_blank>switched<S2SV_blank>inside<S2SV_blank>frame.\\\\n\" ) ; return 1 ; } } } h -> qp_thresh = 15 + 52 - FFMIN ( h -> slice_alpha_c0_offset , h -> slice_beta_offset ) - FFMAX3 ( 0 , h -> pps . chroma_qp_index_offset [ 0 ] , h -> pps . chroma_qp_index_offset [ 1 ] ) + 6 * ( h -> sps . bit_depth_luma - 8 ) ; h0 -> last_slice_type = slice_type ; memcpy ( h0 -> last_ref_count , h0 -> ref_count , sizeof ( h0 -> last_ref_count ) ) ; h -> slice_num = ++ h0 -> current_slice ; if ( h -> slice_num ) h0 -> slice_row [ ( h -> slice_num - 1 ) & ( MAX_SLICES - 1 ) ] = h -> resync_mb_y ; if ( h0 -> slice_row [ h -> slice_num & ( MAX_SLICES - 1 ) ] + 3 >= h -> resync_mb_y && h0 -> slice_row [ h -> slice_num & ( MAX_SLICES - 1 ) ] <= h -> resync_mb_y && h -> slice_num >= MAX_SLICES ) { av_log ( h -> avctx , AV_LOG_WARNING , \"Possibly<S2SV_blank>too<S2SV_blank>many<S2SV_blank>slices<S2SV_blank>(%d<S2SV_blank>>=<S2SV_blank>%d),<S2SV_blank>increase<S2SV_blank>MAX_SLICES<S2SV_blank>and<S2SV_blank>recompile<S2SV_blank>if<S2SV_blank>there<S2SV_blank>are<S2SV_blank>artifacts\\\\n\" , h -> slice_num , MAX_SLICES ) ; } for ( j = 0 ; j < 2 ; j ++ ) { int id_list [ 16 ] ; int * ref2frm = h -> ref2frm [ h -> slice_num & ( MAX_SLICES - 1 ) ] [ j ] ; for ( i = 0 ; i < 16 ; i ++ ) { id_list [ i ] = 60 ; if ( j < h -> list_count && i < h -> ref_count [ j ] && h -> ref_list [ j ] [ i ] . f . buf [ 0 ] ) { int k ; AVBuffer * buf = h -> ref_list [ j ] [ i ] . f . buf [ 0 ] -> buffer ; for ( k = 0 ; k < h -> short_ref_count ; k ++ ) if ( h -> short_ref [ k ] -> f . buf [ 0 ] -> buffer == buf ) { id_list [ i ] = k ; break ; } for ( k = 0 ; k < h -> long_ref_count ; k ++ ) if ( h -> long_ref [ k ] && h -> long_ref [ k ] -> f . buf [ 0 ] -> buffer == buf ) { id_list [ i ] = h -> short_ref_count + k ; break ; } } } ref2frm [ 0 ] = ref2frm [ 1 ] = - 1 ; for ( i = 0 ; i < 16 ; i ++ ) ref2frm [ i + 2 ] = 4 * id_list [ i ] + ( h -> ref_list [ j ] [ i ] . reference & 3 ) ; ref2frm [ 18 + 0 ] = ref2frm [ 18 + 1 ] = - 1 ; for ( i = 16 ; i < 48 ; i ++ ) ref2frm [ i + 4 ] = 4 * id_list [ ( i - 16 ) >> 1 ] + ( h -> ref_list [ j ] [ i ] . reference & 3 ) ; } if ( h -> ref_count [ 0 ] ) h -> er . last_pic = & h -> ref_list [ 0 ] [ 0 ] ; if ( h -> ref_count [ 1 ] ) h -> er . next_pic = & h -> ref_list [ 1 ] [ 0 ] ; h -> er . ref_count = h -> ref_count [ 0 ] ; if ( h -> avctx -> debug & FF_DEBUG_PICT_INFO ) { av_log ( h -> avctx , AV_LOG_DEBUG , \"slice:%d<S2SV_blank>%s<S2SV_blank>mb:%d<S2SV_blank>%c%s%s<S2SV_blank>pps:%u<S2SV_blank>frame:%d<S2SV_blank>poc:%d/%d<S2SV_blank>ref:%d/%d<S2SV_blank>qp:%d<S2SV_blank>loop:%d:%d:%d<S2SV_blank>weight:%d%s<S2SV_blank>%s\\\\n\" , h -> slice_num , ( h -> picture_structure == PICT_FRAME ? \"F\" : h -> picture_structure == PICT_TOP_FIELD ? \"T\" : \"B\" ) , first_mb_in_slice , av_get_picture_type_char ( h -> slice_type ) , h -> slice_type_fixed ? \"<S2SV_blank>fix\" : \"\" , h -> nal_unit_type == NAL_IDR_SLICE ? \"<S2SV_blank>IDR\" : \"\" , pps_id , h -> frame_num , h -> cur_pic_ptr -> field_poc [ 0 ] , h -> cur_pic_ptr -> field_poc [ 1 ] , h -> ref_count [ 0 ] , h -> ref_count [ 1 ] , h -> qscale , h -> deblocking_filter , h -> slice_alpha_c0_offset / 2 - 26 , h -> slice_beta_offset / 2 - 26 , h -> use_weight , h -> use_weight == 1 && h -> use_weight_chroma ? \"c\" : \"\" , h -> slice_type == AV_PICTURE_TYPE_B ? ( h -> direct_spatial_mv_pred ? \"SPAT\" : \"TEMP\" ) : \"\" ) ; } return 0 ; }\n",
      "fixed_code": "<S2SV_ModStart> ; if ( <S2SV_ModEnd> h0 -> cur_pic_ptr <S2SV_ModStart> { if ( <S2SV_ModEnd> last_pic_structure != PICT_FRAME <S2SV_ModStart> { if ( <S2SV_ModEnd> last_pic_structure != PICT_FRAME\n",
      "source_code_length": 22599,
      "target_code_length": 195,
      "vulnerability_patterns": {
        "buffer_overflow": 3,
        "use_after_free": 2,
        "integer_overflow": 17,
        "null_pointer": 533,
        "total": 555
      },
      "total_patterns": 555,
      "original_address": "https://github.com/FFmpeg/FFmpeg/commit/29ffeef5e73b8f41ff3a3f2242d356759c66f91f",
      "discovery_time": "2013-12-09T16:36Z",
      "project_commit_id": "FFmpeg@FFmpeg/29ffeef5e73b8f41ff3a3f2242d356759c66f91f",
      "extraction_time": "2025-08-31T15:41:49.175770",
      "label": 1,
      "vulnerability_type": "unknown/uncategorized",
      "difficulty_level": "expert",
      "risk_factors": [
        "critical_infrastructure",
        "buffer_overflow",
        "use_after_free"
      ],
      "attack_vectors": [
        "fuzzing",
        "code_analysis",
        "reverse_engineering"
      ],
      "mitigation_strategies": [
        "dynamic_analysis",
        "static_analysis",
        "fuzzing",
        "code_review",
        "secure_coding_practices"
      ],
      "code_differences": {
        "has_differences": true,
        "source_lines": 2,
        "target_lines": 2,
        "character_differences": 22404,
        "similarity_percentage": 2.881844380403458
      },
      "vulnerability_location": {
        "vulnerability_present": true,
        "fix_applied": true,
        "code_changed": true,
        "estimated_lines_changed": 0
      }
    },
    {
      "cve_id": "CVE-2013-4263",
      "cwe_id": "CWE-119",
      "cwe_name": "Buffer Overflow",
      "project": "FFmpeg",
      "severity": "critical",
      "weaponization_score": 10.0,
      "is_critical": true,
      "is_weaponizable": true,
      "is_high_priority_project": true,
      "vulnerable_code": "CWE-119 static int filter_frame ( AVFilterLink * inlink , AVFrame * inpic ) { KerndeintContext * kerndeint = inlink -> dst -> priv ; AVFilterLink * outlink = inlink -> dst -> outputs [ 0 ] ; AVFrame * outpic ; const uint8_t * prvp ; const uint8_t * prvpp ; const uint8_t * prvpn ; const uint8_t * prvppp ; const uint8_t * prvpnn ; const uint8_t * prvp4p ; const uint8_t * prvp4n ; const uint8_t * srcp ; const uint8_t * srcpp ; const uint8_t * srcpn ; const uint8_t * srcppp ; const uint8_t * srcpnn ; const uint8_t * srcp3p ; const uint8_t * srcp3n ; const uint8_t * srcp4p ; const uint8_t * srcp4n ; uint8_t * dstp , * dstp_saved ; const uint8_t * srcp_saved ; int src_linesize , psrc_linesize , dst_linesize , bwidth ; int x , y , plane , val , hi , lo , g , h , n = kerndeint -> frame ++ ; double valf ; const int thresh = kerndeint -> thresh ; const int order = kerndeint -> order ; const int map = kerndeint -> map ; const int sharp = kerndeint -> sharp ; const int twoway = kerndeint -> twoway ; const int is_packed_rgb = kerndeint -> is_packed_rgb ; outpic = ff_get_video_buffer ( outlink , outlink -> w , outlink -> h ) ; if ( ! outpic ) { av_frame_free ( & inpic ) ; return AVERROR ( ENOMEM ) ; } av_frame_copy_props ( outpic , inpic ) ; outpic -> interlaced_frame = 0 ; <S2SV_StartBug> for ( plane = 0 ; inpic -> data [ plane ] && plane < 4 ; plane ++ ) { <S2SV_EndBug> h = plane == 0 ? inlink -> h : FF_CEIL_RSHIFT ( inlink -> h , kerndeint -> vsub ) ; bwidth = kerndeint -> tmp_bwidth [ plane ] ; srcp = srcp_saved = inpic -> data [ plane ] ; src_linesize = inpic -> linesize [ plane ] ; psrc_linesize = kerndeint -> tmp_linesize [ plane ] ; dstp = dstp_saved = outpic -> data [ plane ] ; dst_linesize = outpic -> linesize [ plane ] ; srcp = srcp_saved + ( 1 - order ) * src_linesize ; dstp = dstp_saved + ( 1 - order ) * dst_linesize ; for ( y = 0 ; y < h ; y += 2 ) { memcpy ( dstp , srcp , bwidth ) ; srcp += 2 * src_linesize ; dstp += 2 * dst_linesize ; } memcpy ( dstp_saved + order * dst_linesize , srcp_saved + ( 1 - order ) * src_linesize , bwidth ) ; memcpy ( dstp_saved + ( 2 + order ) * dst_linesize , srcp_saved + ( 3 - order ) * src_linesize , bwidth ) ; memcpy ( dstp_saved + ( h - 2 + order ) * dst_linesize , srcp_saved + ( h - 1 - order ) * src_linesize , bwidth ) ; memcpy ( dstp_saved + ( h - 4 + order ) * dst_linesize , srcp_saved + ( h - 3 - order ) * src_linesize , bwidth ) ; prvp = kerndeint -> tmp_data [ plane ] + 5 * psrc_linesize - ( 1 - order ) * psrc_linesize ; prvpp = prvp - psrc_linesize ; prvppp = prvp - 2 * psrc_linesize ; prvp4p = prvp - 4 * psrc_linesize ; prvpn = prvp + psrc_linesize ; prvpnn = prvp + 2 * psrc_linesize ; prvp4n = prvp + 4 * psrc_linesize ; srcp = srcp_saved + 5 * src_linesize - ( 1 - order ) * src_linesize ; srcpp = srcp - src_linesize ; srcppp = srcp - 2 * src_linesize ; srcp3p = srcp - 3 * src_linesize ; srcp4p = srcp - 4 * src_linesize ; srcpn = srcp + src_linesize ; srcpnn = srcp + 2 * src_linesize ; srcp3n = srcp + 3 * src_linesize ; srcp4n = srcp + 4 * src_linesize ; dstp = dstp_saved + 5 * dst_linesize - ( 1 - order ) * dst_linesize ; for ( y = 5 - ( 1 - order ) ; y <= h - 5 - ( 1 - order ) ; y += 2 ) { for ( x = 0 ; x < bwidth ; x ++ ) { if ( thresh == 0 || n == 0 || ( abs ( ( int ) prvp [ x ] - ( int ) srcp [ x ] ) > thresh ) || ( abs ( ( int ) prvpp [ x ] - ( int ) srcpp [ x ] ) > thresh ) || ( abs ( ( int ) prvpn [ x ] - ( int ) srcpn [ x ] ) > thresh ) ) { if ( map ) { g = x & ~ 3 ; if ( is_packed_rgb ) { AV_WB32 ( dstp + g , 0xffffffff ) ; x = g + 3 ; } else if ( inlink -> format == AV_PIX_FMT_YUYV422 ) { AV_WB32 ( dstp + g , 0xeb80eb80 ) ; x = g + 3 ; } else { dstp [ x ] = plane == 0 ? 235 : 128 ; } } else { if ( is_packed_rgb ) { hi = 255 ; lo = 0 ; } else if ( inlink -> format == AV_PIX_FMT_YUYV422 ) { hi = x & 1 ? 240 : 235 ; lo = 16 ; } else { hi = plane == 0 ? 235 : 240 ; lo = 16 ; } if ( sharp ) { if ( twoway ) { valf = + 0.526 * ( ( int ) srcpp [ x ] + ( int ) srcpn [ x ] ) + 0.170 * ( ( int ) srcp [ x ] + ( int ) prvp [ x ] ) - 0.116 * ( ( int ) srcppp [ x ] + ( int ) srcpnn [ x ] + ( int ) prvppp [ x ] + ( int ) prvpnn [ x ] ) - 0.026 * ( ( int ) srcp3p [ x ] + ( int ) srcp3n [ x ] ) + 0.031 * ( ( int ) srcp4p [ x ] + ( int ) srcp4n [ x ] + ( int ) prvp4p [ x ] + ( int ) prvp4n [ x ] ) ; } else { valf = + 0.526 * ( ( int ) srcpp [ x ] + ( int ) srcpn [ x ] ) + 0.170 * ( ( int ) prvp [ x ] ) - 0.116 * ( ( int ) prvppp [ x ] + ( int ) prvpnn [ x ] ) - 0.026 * ( ( int ) srcp3p [ x ] + ( int ) srcp3n [ x ] ) + 0.031 * ( ( int ) prvp4p [ x ] + ( int ) prvp4p [ x ] ) ; } dstp [ x ] = av_clip ( valf , lo , hi ) ; } else { if ( twoway ) { val = ( 8 * ( ( int ) srcpp [ x ] + ( int ) srcpn [ x ] ) + 2 * ( ( int ) srcp [ x ] + ( int ) prvp [ x ] ) - ( int ) ( srcppp [ x ] ) - ( int ) ( srcpnn [ x ] ) - ( int ) ( prvppp [ x ] ) - ( int ) ( prvpnn [ x ] ) ) >> 4 ; } else { val = ( 8 * ( ( int ) srcpp [ x ] + ( int ) srcpn [ x ] ) + 2 * ( ( int ) prvp [ x ] ) - ( int ) ( prvppp [ x ] ) - ( int ) ( prvpnn [ x ] ) ) >> 4 ; } dstp [ x ] = av_clip ( val , lo , hi ) ; } } } else { dstp [ x ] = srcp [ x ] ; } } prvp += 2 * psrc_linesize ; prvpp += 2 * psrc_linesize ; prvppp += 2 * psrc_linesize ; prvpn += 2 * psrc_linesize ; prvpnn += 2 * psrc_linesize ; prvp4p += 2 * psrc_linesize ; prvp4n += 2 * psrc_linesize ; srcp += 2 * src_linesize ; srcpp += 2 * src_linesize ; srcppp += 2 * src_linesize ; srcp3p += 2 * src_linesize ; srcp4p += 2 * src_linesize ; srcpn += 2 * src_linesize ; srcpnn += 2 * src_linesize ; srcp3n += 2 * src_linesize ; srcp4n += 2 * src_linesize ; dstp += 2 * dst_linesize ; } srcp = inpic -> data [ plane ] ; dstp = kerndeint -> tmp_data [ plane ] ; av_image_copy_plane ( dstp , psrc_linesize , srcp , src_linesize , bwidth , h ) ; } av_frame_free ( & inpic ) ; return ff_filter_frame ( outlink , outpic ) ; }\n",
      "fixed_code": "<S2SV_ModStart> = 0 ; <S2SV_ModEnd> plane < 4 <S2SV_ModStart> plane < 4 && inpic -> data [ plane ] && inpic -> linesize [ plane ]\n",
      "source_code_length": 5860,
      "target_code_length": 130,
      "vulnerability_patterns": {
        "buffer_overflow": 5,
        "integer_overflow": 24,
        "null_pointer": 31,
        "total": 60
      },
      "total_patterns": 60,
      "original_address": "https://github.com/FFmpeg/FFmpeg/commit/e43a0a232dbf6d3c161823c2e07c52e76227a1bc",
      "discovery_time": "2013-11-23T17:55Z",
      "project_commit_id": "FFmpeg@FFmpeg/e43a0a232dbf6d3c161823c2e07c52e76227a1bc",
      "extraction_time": "2025-08-31T15:41:49.175939",
      "label": 1,
      "vulnerability_type": "buffer_overflow",
      "difficulty_level": "expert",
      "risk_factors": [
        "memory_corruption",
        "critical_infrastructure",
        "arbitrary_code_execution",
        "buffer_overflow",
        "system_crash"
      ],
      "attack_vectors": [
        "memory_manipulation",
        "malicious_input",
        "code_analysis",
        "buffer_overflow",
        "reverse_engineering",
        "fuzzing"
      ],
      "mitigation_strategies": [
        "safe_string_functions",
        "dynamic_analysis",
        "code_review",
        "static_analysis",
        "memory_safety_checks",
        "input_validation",
        "fuzzing",
        "bounds_checking",
        "secure_coding_practices"
      ],
      "code_differences": {
        "has_differences": true,
        "source_lines": 2,
        "target_lines": 2,
        "character_differences": 5730,
        "similarity_percentage": 9.701492537313433
      },
      "vulnerability_location": {
        "vulnerability_present": true,
        "fix_applied": true,
        "code_changed": true,
        "estimated_lines_changed": 0
      }
    },
    {
      "cve_id": "CVE-2018-11381",
      "cwe_id": "CWE-125",
      "cwe_name": "Out-of-bounds Read",
      "project": "radare",
      "severity": "critical",
      "weaponization_score": 10.0,
      "is_critical": true,
      "is_weaponizable": true,
      "is_high_priority_project": true,
      "vulnerable_code": "CWE-125 static int string_scan_range ( RList * list , RBinFile * bf , int min , const ut64 from , const ut64 to , int type ) { ut8 tmp [ R_STRING_SCAN_BUFFER_SIZE ] ; ut64 str_start , needle = from ; int count = 0 , i , rc , runes ; int str_type = R_STRING_TYPE_DETECT ; if ( type == - 1 ) { type = R_STRING_TYPE_DETECT ; } if ( from >= to ) { eprintf ( \"Invalid<S2SV_blank>range<S2SV_blank>to<S2SV_blank>find<S2SV_blank>strings<S2SV_blank>0x%llx<S2SV_blank>..<S2SV_blank>0x%llx\\\\n\" , from , to ) ; return - 1 ; } <S2SV_StartBug> ut8 * buf = calloc ( to - from , 1 ) ; <S2SV_EndBug> if ( ! buf || ! min ) { return - 1 ; } <S2SV_StartBug> r_buf_read_at ( bf -> buf , from , buf , to - from ) ; <S2SV_EndBug> while ( needle < to ) { rc = r_utf8_decode ( buf + needle - from , to - needle , NULL ) ; if ( ! rc ) { needle ++ ; continue ; } if ( type == R_STRING_TYPE_DETECT ) { char * w = ( char * ) buf + needle + rc - from ; <S2SV_StartBug> if ( ( to - needle ) > 5 ) { <S2SV_EndBug> <S2SV_StartBug> bool is_wide32 = needle + rc + 2 < to && ! w [ 0 ] && ! w [ 1 ] && ! w [ 2 ] && w [ 3 ] && ! w [ 4 ] ; <S2SV_EndBug> if ( is_wide32 ) { str_type = R_STRING_TYPE_WIDE32 ; } else { bool is_wide = needle + rc + 2 < to && ! w [ 0 ] && w [ 1 ] && ! w [ 2 ] ; str_type = is_wide ? R_STRING_TYPE_WIDE : R_STRING_TYPE_ASCII ; } } else { str_type = R_STRING_TYPE_ASCII ; } } else { str_type = type ; } runes = 0 ; str_start = needle ; for ( rc = i = 0 ; i < sizeof ( tmp ) - 3 && needle < to ; i += rc ) { RRune r = { 0 } ; if ( str_type == R_STRING_TYPE_WIDE32 ) { rc = r_utf32le_decode ( buf + needle - from , to - needle , & r ) ; if ( rc ) { rc = 4 ; } } else if ( str_type == R_STRING_TYPE_WIDE ) { rc = r_utf16le_decode ( buf + needle - from , to - needle , & r ) ; if ( rc == 1 ) { rc = 2 ; } } else { rc = r_utf8_decode ( buf + needle - from , to - needle , & r ) ; if ( rc > 1 ) { str_type = R_STRING_TYPE_UTF8 ; } } if ( ! rc ) { needle ++ ; break ; } needle += rc ; if ( r_isprint ( r ) && r != '\\\\\\\\' ) { if ( str_type == R_STRING_TYPE_WIDE32 ) { if ( r == 0xff ) { r = 0 ; } } rc = r_utf8_encode ( & tmp [ i ] , r ) ; runes ++ ; } else if ( r && r < 0x100 && strchr ( \"\\\\b\\\\v\\\\f\\\\n\\\\r\\\\t\\\\a\\\\033\\\\\\\\\" , ( char ) r ) ) { if ( ( i + 32 ) < sizeof ( tmp ) && r < 93 ) { tmp [ i + 0 ] = '\\\\\\\\' ; tmp [ i + 1 ] = \"<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>abtnvfr<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>e<S2SV_blank><S2SV_blank>\" \"<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>\" \"<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>\" \"<S2SV_blank><S2SV_blank>\\\\\\\\\" [ r ] ; } else { break ; } rc = 2 ; runes ++ ; } else { break ; } } tmp [ i ++ ] = '\\\\0' ; if ( runes >= min ) { if ( str_type == R_STRING_TYPE_ASCII ) { int j ; for ( j = 0 ; j < i ; j ++ ) { char ch = tmp [ j ] ; if ( ch != '\\\\n' && ch != '\\\\r' && ch != '\\\\t' ) { if ( ! IS_PRINTABLE ( tmp [ j ] ) ) { continue ; } } } } RBinString * bs = R_NEW0 ( RBinString ) ; if ( ! bs ) { break ; } bs -> type = str_type ; bs -> length = runes ; bs -> size = needle - str_start ; bs -> ordinal = count ++ ; switch ( str_type ) { case R_STRING_TYPE_WIDE : if ( str_start - from > 1 ) { const ut8 * p = buf + str_start - 2 - from ; if ( p [ 0 ] == 0xff && p [ 1 ] == 0xfe ) { str_start -= 2 ; } } break ; case R_STRING_TYPE_WIDE32 : if ( str_start - from > 3 ) { const ut8 * p = buf + str_start - 4 - from ; if ( p [ 0 ] == 0xff && p [ 1 ] == 0xfe ) { str_start -= 4 ; } } break ; } bs -> paddr = bs -> vaddr = str_start ; bs -> string = r_str_ndup ( ( const char * ) tmp , i ) ; if ( list ) { r_list_append ( list , bs ) ; } else { print_string ( bs , bf ) ; r_bin_string_free ( bs ) ; } } } free ( buf ) ; return count ; }\n",
      "fixed_code": "<S2SV_ModStart> 1 ; } int len = to - from ; <S2SV_ModStart> = calloc ( len <S2SV_ModEnd> , 1 ) <S2SV_ModStart> , buf , len <S2SV_ModEnd> ) ; while <S2SV_ModStart> ) > 5 + rc <S2SV_ModStart> bool is_wide32 = ( <S2SV_ModStart> 2 < to ) && ( <S2SV_ModEnd> ! w [ <S2SV_ModStart> [ 4 ] )\n",
      "source_code_length": 4455,
      "target_code_length": 283,
      "vulnerability_patterns": {
        "use_after_free": 2,
        "integer_overflow": 11,
        "null_pointer": 14,
        "memory_leak": 1,
        "total": 28
      },
      "total_patterns": 28,
      "original_address": "https://github.com/radare/radare2/commit/3fcf41ed96ffa25b38029449520c8d0a198745f3",
      "discovery_time": "2018-05-22T19:29Z",
      "project_commit_id": "radare@radare2/3fcf41ed96ffa25b38029449520c8d0a198745f3",
      "extraction_time": "2025-08-31T15:41:49.175995",
      "label": 1,
      "vulnerability_type": "out-of-bounds_read",
      "difficulty_level": "expert",
      "risk_factors": [
        "memory_corruption",
        "critical_infrastructure",
        "information_disclosure",
        "use_after_free",
        "integer_overflow"
      ],
      "attack_vectors": [
        "memory_manipulation",
        "malicious_input",
        "code_analysis",
        "buffer_overflow",
        "reverse_engineering",
        "fuzzing"
      ],
      "mitigation_strategies": [
        "safe_string_functions",
        "dynamic_analysis",
        "code_review",
        "static_analysis",
        "memory_safety_checks",
        "input_validation",
        "fuzzing",
        "bounds_checking",
        "secure_coding_practices"
      ],
      "code_differences": {
        "has_differences": true,
        "source_lines": 2,
        "target_lines": 2,
        "character_differences": 4172,
        "similarity_percentage": 21.875
      },
      "vulnerability_location": {
        "vulnerability_present": true,
        "fix_applied": true,
        "code_changed": true,
        "estimated_lines_changed": 0
      }
    },
    {
      "cve_id": "CVE-2015-0206",
      "cwe_id": "CWE-119",
      "cwe_name": "Buffer Overflow",
      "project": "openssl",
      "severity": "critical",
      "weaponization_score": 10.0,
      "is_critical": true,
      "is_weaponizable": true,
      "is_high_priority_project": true,
      "vulnerable_code": "CWE-119 int dtls1_read_bytes ( SSL * s , int type , unsigned char * buf , int len , int peek ) { int al , i , j , ret ; unsigned int n ; SSL3_RECORD * rr ; void ( * cb ) ( const SSL * ssl , int type2 , int val ) = NULL ; if ( s -> s3 -> rbuf . buf == NULL ) if ( ! ssl3_setup_buffers ( s ) ) return ( - 1 ) ; if ( ( type && ( type != SSL3_RT_APPLICATION_DATA ) && ( type != SSL3_RT_HANDSHAKE ) ) || ( peek && ( type != SSL3_RT_APPLICATION_DATA ) ) ) { SSLerr ( SSL_F_DTLS1_READ_BYTES , ERR_R_INTERNAL_ERROR ) ; return - 1 ; } if ( ( ret = have_handshake_fragment ( s , type , buf , len , peek ) ) ) return ret ; # ifndef OPENSSL_NO_SCTP if ( ( ! s -> in_handshake && SSL_in_init ( s ) ) || ( BIO_dgram_is_sctp ( SSL_get_rbio ( s ) ) && ( s -> state == DTLS1_SCTP_ST_SR_READ_SOCK || s -> state == DTLS1_SCTP_ST_CR_READ_SOCK ) && s -> s3 -> in_read_app_data != 2 ) ) # else if ( ! s -> in_handshake && SSL_in_init ( s ) ) # endif { i = s -> handshake_func ( s ) ; if ( i < 0 ) return ( i ) ; if ( i == 0 ) { SSLerr ( SSL_F_DTLS1_READ_BYTES , SSL_R_SSL_HANDSHAKE_FAILURE ) ; return ( - 1 ) ; } } start : s -> rwstate = SSL_NOTHING ; rr = & ( s -> s3 -> rrec ) ; if ( s -> state == SSL_ST_OK && rr -> length == 0 ) { pitem * item ; item = pqueue_pop ( s -> d1 -> buffered_app_data . q ) ; if ( item ) { # ifndef OPENSSL_NO_SCTP if ( BIO_dgram_is_sctp ( SSL_get_rbio ( s ) ) ) { DTLS1_RECORD_DATA * rdata = ( DTLS1_RECORD_DATA * ) item -> data ; BIO_ctrl ( SSL_get_rbio ( s ) , BIO_CTRL_DGRAM_SCTP_SET_RCVINFO , sizeof ( rdata -> recordinfo ) , & rdata -> recordinfo ) ; } # endif dtls1_copy_record ( s , item ) ; OPENSSL_free ( item -> data ) ; pitem_free ( item ) ; } } if ( dtls1_handle_timeout ( s ) > 0 ) goto start ; if ( ( rr -> length == 0 ) || ( s -> rstate == SSL_ST_READ_BODY ) ) { ret = dtls1_get_record ( s ) ; if ( ret <= 0 ) { ret = dtls1_read_failed ( s , ret ) ; if ( ret <= 0 ) return ( ret ) ; else goto start ; } } if ( s -> d1 -> listen && rr -> type != SSL3_RT_HANDSHAKE ) { rr -> length = 0 ; goto start ; } if ( s -> s3 -> change_cipher_spec && ( rr -> type != SSL3_RT_HANDSHAKE ) ) { <S2SV_StartBug> dtls1_buffer_record ( s , & ( s -> d1 -> buffered_app_data ) , rr -> seq_num ) ; <S2SV_EndBug> rr -> length = 0 ; goto start ; } if ( s -> shutdown & SSL_RECEIVED_SHUTDOWN ) { rr -> length = 0 ; s -> rwstate = SSL_NOTHING ; return ( 0 ) ; } if ( type == rr -> type ) { if ( SSL_in_init ( s ) && ( type == SSL3_RT_APPLICATION_DATA ) && ( s -> enc_read_ctx == NULL ) ) { al = SSL_AD_UNEXPECTED_MESSAGE ; SSLerr ( SSL_F_DTLS1_READ_BYTES , SSL_R_APP_DATA_IN_HANDSHAKE ) ; goto f_err ; } if ( len <= 0 ) return ( len ) ; if ( ( unsigned int ) len > rr -> length ) n = rr -> length ; else n = ( unsigned int ) len ; memcpy ( buf , & ( rr -> data [ rr -> off ] ) , n ) ; if ( ! peek ) { rr -> length -= n ; rr -> off += n ; if ( rr -> length == 0 ) { s -> rstate = SSL_ST_READ_HEADER ; rr -> off = 0 ; } } # ifndef OPENSSL_NO_SCTP if ( BIO_dgram_is_sctp ( SSL_get_rbio ( s ) ) && rr -> type == SSL3_RT_APPLICATION_DATA && ( s -> state == DTLS1_SCTP_ST_SR_READ_SOCK || s -> state == DTLS1_SCTP_ST_CR_READ_SOCK ) ) { s -> rwstate = SSL_READING ; BIO_clear_retry_flags ( SSL_get_rbio ( s ) ) ; BIO_set_retry_read ( SSL_get_rbio ( s ) ) ; } if ( BIO_dgram_is_sctp ( SSL_get_rbio ( s ) ) && s -> d1 -> shutdown_received && ! BIO_dgram_sctp_msg_waiting ( SSL_get_rbio ( s ) ) ) { s -> shutdown |= SSL_RECEIVED_SHUTDOWN ; return ( 0 ) ; } # endif return ( n ) ; } { unsigned int k , dest_maxlen = 0 ; unsigned char * dest = NULL ; unsigned int * dest_len = NULL ; if ( rr -> type == SSL3_RT_HANDSHAKE ) { dest_maxlen = sizeof s -> d1 -> handshake_fragment ; dest = s -> d1 -> handshake_fragment ; dest_len = & s -> d1 -> handshake_fragment_len ; } else if ( rr -> type == SSL3_RT_ALERT ) { dest_maxlen = sizeof ( s -> d1 -> alert_fragment ) ; dest = s -> d1 -> alert_fragment ; dest_len = & s -> d1 -> alert_fragment_len ; } # ifndef OPENSSL_NO_HEARTBEATS else if ( rr -> type == TLS1_RT_HEARTBEAT ) { dtls1_process_heartbeat ( s ) ; rr -> length = 0 ; s -> rwstate = SSL_READING ; BIO_clear_retry_flags ( SSL_get_rbio ( s ) ) ; BIO_set_retry_read ( SSL_get_rbio ( s ) ) ; return ( - 1 ) ; } # endif else if ( rr -> type != SSL3_RT_CHANGE_CIPHER_SPEC ) { if ( rr -> type == SSL3_RT_APPLICATION_DATA ) { BIO * bio ; s -> s3 -> in_read_app_data = 2 ; bio = SSL_get_rbio ( s ) ; s -> rwstate = SSL_READING ; BIO_clear_retry_flags ( bio ) ; BIO_set_retry_read ( bio ) ; return ( - 1 ) ; } al = SSL_AD_UNEXPECTED_MESSAGE ; SSLerr ( SSL_F_DTLS1_READ_BYTES , SSL_R_UNEXPECTED_RECORD ) ; goto f_err ; } if ( dest_maxlen > 0 ) { if ( rr -> length < dest_maxlen ) { # ifdef DTLS1_AD_MISSING_HANDSHAKE_MESSAGE FIX ME # endif s -> rstate = SSL_ST_READ_HEADER ; rr -> length = 0 ; goto start ; } for ( k = 0 ; k < dest_maxlen ; k ++ ) { dest [ k ] = rr -> data [ rr -> off ++ ] ; rr -> length -- ; } * dest_len = dest_maxlen ; } } if ( ( ! s -> server ) && ( s -> d1 -> handshake_fragment_len >= DTLS1_HM_HEADER_LENGTH ) && ( s -> d1 -> handshake_fragment [ 0 ] == SSL3_MT_HELLO_REQUEST ) && ( s -> session != NULL ) && ( s -> session -> cipher != NULL ) ) { s -> d1 -> handshake_fragment_len = 0 ; if ( ( s -> d1 -> handshake_fragment [ 1 ] != 0 ) || ( s -> d1 -> handshake_fragment [ 2 ] != 0 ) || ( s -> d1 -> handshake_fragment [ 3 ] != 0 ) ) { al = SSL_AD_DECODE_ERROR ; SSLerr ( SSL_F_DTLS1_READ_BYTES , SSL_R_BAD_HELLO_REQUEST ) ; goto err ; } if ( s -> msg_callback ) s -> msg_callback ( 0 , s -> version , SSL3_RT_HANDSHAKE , s -> d1 -> handshake_fragment , 4 , s , s -> msg_callback_arg ) ; if ( SSL_is_init_finished ( s ) && ! ( s -> s3 -> flags & SSL3_FLAGS_NO_RENEGOTIATE_CIPHERS ) && ! s -> s3 -> renegotiate ) { s -> d1 -> handshake_read_seq ++ ; s -> new_session = 1 ; ssl3_renegotiate ( s ) ; if ( ssl3_renegotiate_check ( s ) ) { i = s -> handshake_func ( s ) ; if ( i < 0 ) return ( i ) ; if ( i == 0 ) { SSLerr ( SSL_F_DTLS1_READ_BYTES , SSL_R_SSL_HANDSHAKE_FAILURE ) ; return ( - 1 ) ; } if ( ! ( s -> mode & SSL_MODE_AUTO_RETRY ) ) { if ( s -> s3 -> rbuf . left == 0 ) { BIO * bio ; s -> rwstate = SSL_READING ; bio = SSL_get_rbio ( s ) ; BIO_clear_retry_flags ( bio ) ; BIO_set_retry_read ( bio ) ; return ( - 1 ) ; } } } } goto start ; } if ( s -> d1 -> alert_fragment_len >= DTLS1_AL_HEADER_LENGTH ) { int alert_level = s -> d1 -> alert_fragment [ 0 ] ; int alert_descr = s -> d1 -> alert_fragment [ 1 ] ; s -> d1 -> alert_fragment_len = 0 ; if ( s -> msg_callback ) s -> msg_callback ( 0 , s -> version , SSL3_RT_ALERT , s -> d1 -> alert_fragment , 2 , s , s -> msg_callback_arg ) ; if ( s -> info_callback != NULL ) cb = s -> info_callback ; else if ( s -> ctx -> info_callback != NULL ) cb = s -> ctx -> info_callback ; if ( cb != NULL ) { j = ( alert_level << 8 ) | alert_descr ; cb ( s , SSL_CB_READ_ALERT , j ) ; } if ( alert_level == 1 ) { s -> s3 -> warn_alert = alert_descr ; if ( alert_descr == SSL_AD_CLOSE_NOTIFY ) { # ifndef OPENSSL_NO_SCTP if ( BIO_dgram_is_sctp ( SSL_get_rbio ( s ) ) && BIO_dgram_sctp_msg_waiting ( SSL_get_rbio ( s ) ) ) { s -> d1 -> shutdown_received = 1 ; s -> rwstate = SSL_READING ; BIO_clear_retry_flags ( SSL_get_rbio ( s ) ) ; BIO_set_retry_read ( SSL_get_rbio ( s ) ) ; return - 1 ; } # endif s -> shutdown |= SSL_RECEIVED_SHUTDOWN ; return ( 0 ) ; } # if 0 if ( alert_descr == DTLS1_AD_MISSING_HANDSHAKE_MESSAGE ) { unsigned short seq ; unsigned int frag_off ; unsigned char * p = & ( s -> d1 -> alert_fragment [ 2 ] ) ; n2s ( p , seq ) ; n2l3 ( p , frag_off ) ; dtls1_retransmit_message ( s , dtls1_get_queue_priority ( frag -> msg_header . seq , 0 ) , frag_off , & found ) ; if ( ! found && SSL_in_init ( s ) ) { ssl3_send_alert ( s , SSL3_AL_WARNING , DTLS1_AD_MISSING_HANDSHAKE_MESSAGE ) ; } } # endif } else if ( alert_level == 2 ) { char tmp [ 16 ] ; s -> rwstate = SSL_NOTHING ; s -> s3 -> fatal_alert = alert_descr ; SSLerr ( SSL_F_DTLS1_READ_BYTES , SSL_AD_REASON_OFFSET + alert_descr ) ; BIO_snprintf ( tmp , sizeof tmp , \"%d\" , alert_descr ) ; ERR_add_error_data ( 2 , \"SSL<S2SV_blank>alert<S2SV_blank>number<S2SV_blank>\" , tmp ) ; s -> shutdown |= SSL_RECEIVED_SHUTDOWN ; SSL_CTX_remove_session ( s -> ctx , s -> session ) ; return ( 0 ) ; } else { al = SSL_AD_ILLEGAL_PARAMETER ; SSLerr ( SSL_F_DTLS1_READ_BYTES , SSL_R_UNKNOWN_ALERT_TYPE ) ; goto f_err ; } goto start ; } if ( s -> shutdown & SSL_SENT_SHUTDOWN ) { s -> rwstate = SSL_NOTHING ; rr -> length = 0 ; return ( 0 ) ; } if ( rr -> type == SSL3_RT_CHANGE_CIPHER_SPEC ) { struct ccs_header_st ccs_hdr ; unsigned int ccs_hdr_len = DTLS1_CCS_HEADER_LENGTH ; dtls1_get_ccs_header ( rr -> data , & ccs_hdr ) ; if ( s -> version == DTLS1_BAD_VER ) ccs_hdr_len = 3 ; if ( ( rr -> length != ccs_hdr_len ) || ( rr -> off != 0 ) || ( rr -> data [ 0 ] != SSL3_MT_CCS ) ) { i = SSL_AD_ILLEGAL_PARAMETER ; SSLerr ( SSL_F_DTLS1_READ_BYTES , SSL_R_BAD_CHANGE_CIPHER_SPEC ) ; goto err ; } rr -> length = 0 ; if ( s -> msg_callback ) s -> msg_callback ( 0 , s -> version , SSL3_RT_CHANGE_CIPHER_SPEC , rr -> data , 1 , s , s -> msg_callback_arg ) ; if ( ! s -> d1 -> change_cipher_spec_ok ) { goto start ; } s -> d1 -> change_cipher_spec_ok = 0 ; s -> s3 -> change_cipher_spec = 1 ; if ( ! ssl3_do_change_cipher_spec ( s ) ) goto err ; dtls1_reset_seq_numbers ( s , SSL3_CC_READ ) ; if ( s -> version == DTLS1_BAD_VER ) s -> d1 -> handshake_read_seq ++ ; # ifndef OPENSSL_NO_SCTP BIO_ctrl ( SSL_get_wbio ( s ) , BIO_CTRL_DGRAM_SCTP_AUTH_CCS_RCVD , 1 , NULL ) ; # endif goto start ; } if ( ( s -> d1 -> handshake_fragment_len >= DTLS1_HM_HEADER_LENGTH ) && ! s -> in_handshake ) { struct hm_header_st msg_hdr ; dtls1_get_message_header ( rr -> data , & msg_hdr ) ; if ( rr -> epoch != s -> d1 -> r_epoch ) { rr -> length = 0 ; goto start ; } if ( msg_hdr . type == SSL3_MT_FINISHED ) { if ( dtls1_check_timeout_num ( s ) < 0 ) return - 1 ; dtls1_retransmit_buffered_messages ( s ) ; rr -> length = 0 ; goto start ; } if ( ( ( s -> state & SSL_ST_MASK ) == SSL_ST_OK ) && ! ( s -> s3 -> flags & SSL3_FLAGS_NO_RENEGOTIATE_CIPHERS ) ) { # if 0 s -> state = SSL_ST_BEFORE | ( s -> server ) ? SSL_ST_ACCEPT : SSL_ST_CONNECT ; # else s -> state = s -> server ? SSL_ST_ACCEPT : SSL_ST_CONNECT ; # endif s -> renegotiate = 1 ; s -> new_session = 1 ; } i = s -> handshake_func ( s ) ; if ( i < 0 ) return ( i ) ; if ( i == 0 ) { SSLerr ( SSL_F_DTLS1_READ_BYTES , SSL_R_SSL_HANDSHAKE_FAILURE ) ; return ( - 1 ) ; } if ( ! ( s -> mode & SSL_MODE_AUTO_RETRY ) ) { if ( s -> s3 -> rbuf . left == 0 ) { BIO * bio ; s -> rwstate = SSL_READING ; bio = SSL_get_rbio ( s ) ; BIO_clear_retry_flags ( bio ) ; BIO_set_retry_read ( bio ) ; return ( - 1 ) ; } } goto start ; } switch ( rr -> type ) { default : # ifndef OPENSSL_NO_TLS if ( s -> version == TLS1_VERSION ) { rr -> length = 0 ; goto start ; } # endif al = SSL_AD_UNEXPECTED_MESSAGE ; SSLerr ( SSL_F_DTLS1_READ_BYTES , SSL_R_UNEXPECTED_RECORD ) ; goto f_err ; case SSL3_RT_CHANGE_CIPHER_SPEC : case SSL3_RT_ALERT : case SSL3_RT_HANDSHAKE : al = SSL_AD_UNEXPECTED_MESSAGE ; SSLerr ( SSL_F_DTLS1_READ_BYTES , ERR_R_INTERNAL_ERROR ) ; goto f_err ; case SSL3_RT_APPLICATION_DATA : if ( s -> s3 -> in_read_app_data && ( s -> s3 -> total_renegotiations != 0 ) && ( ( ( s -> state & SSL_ST_CONNECT ) && ( s -> state >= SSL3_ST_CW_CLNT_HELLO_A ) && ( s -> state <= SSL3_ST_CR_SRVR_HELLO_A ) ) || ( ( s -> state & SSL_ST_ACCEPT ) && ( s -> state <= SSL3_ST_SW_HELLO_REQ_A ) && ( s -> state >= SSL3_ST_SR_CLNT_HELLO_A ) ) ) ) { s -> s3 -> in_read_app_data = 2 ; return ( - 1 ) ; } else { al = SSL_AD_UNEXPECTED_MESSAGE ; SSLerr ( SSL_F_DTLS1_READ_BYTES , SSL_R_UNEXPECTED_RECORD ) ; goto f_err ; } } f_err : ssl3_send_alert ( s , SSL3_AL_FATAL , al ) ; err : return ( - 1 ) ; }\n",
      "fixed_code": "<S2SV_ModStart> ) ) { if ( <S2SV_ModStart> -> seq_num ) < 0 ) { SSLerr ( SSL_F_DTLS1_READ_BYTES , ERR_R_INTERNAL_ERROR ) ; return - 1 ; } <S2SV_ModEnd> rr -> length\n",
      "source_code_length": 11724,
      "target_code_length": 165,
      "vulnerability_patterns": {
        "buffer_overflow": 1,
        "use_after_free": 2,
        "integer_overflow": 7,
        "null_pointer": 215,
        "total": 225
      },
      "total_patterns": 225,
      "original_address": "https://github.com/openssl/openssl/commit/103b171d8fc282ef435f8de9afbf7782e312961f",
      "discovery_time": "2015-01-09T02:59Z",
      "project_commit_id": "openssl@openssl/103b171d8fc282ef435f8de9afbf7782e312961f",
      "extraction_time": "2025-08-31T15:41:49.176048",
      "label": 1,
      "vulnerability_type": "buffer_overflow",
      "difficulty_level": "expert",
      "risk_factors": [
        "memory_corruption",
        "critical_infrastructure",
        "arbitrary_code_execution",
        "buffer_overflow",
        "system_crash",
        "use_after_free"
      ],
      "attack_vectors": [
        "memory_manipulation",
        "malicious_input",
        "code_analysis",
        "buffer_overflow",
        "reverse_engineering",
        "fuzzing"
      ],
      "mitigation_strategies": [
        "safe_string_functions",
        "dynamic_analysis",
        "code_review",
        "static_analysis",
        "memory_safety_checks",
        "input_validation",
        "fuzzing",
        "bounds_checking",
        "secure_coding_practices"
      ],
      "code_differences": {
        "has_differences": true,
        "source_lines": 2,
        "target_lines": 2,
        "character_differences": 11559,
        "similarity_percentage": 7.480314960629922
      },
      "vulnerability_location": {
        "vulnerability_present": true,
        "fix_applied": true,
        "code_changed": true,
        "estimated_lines_changed": 0
      }
    },
    {
      "cve_id": "CVE-2016-7533",
      "cwe_id": "CWE-125",
      "cwe_name": "Out-of-bounds Read",
      "project": "ImageMagick",
      "severity": "critical",
      "weaponization_score": 10.0,
      "is_critical": true,
      "is_weaponizable": true,
      "is_high_priority_project": true,
      "vulnerable_code": "CWE-125 static Image * ReadWPGImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { typedef struct { size_t FileId ; MagickOffsetType DataOffset ; unsigned int ProductType ; unsigned int FileType ; unsigned char MajorVersion ; unsigned char MinorVersion ; unsigned int EncryptKey ; unsigned int Reserved ; } WPGHeader ; typedef struct { unsigned char RecType ; size_t RecordLength ; } WPGRecord ; typedef struct { unsigned char Class ; unsigned char RecType ; size_t Extension ; size_t RecordLength ; } WPG2Record ; typedef struct { unsigned HorizontalUnits ; unsigned VerticalUnits ; unsigned char PosSizePrecision ; } WPG2Start ; typedef struct { unsigned int Width ; unsigned int Height ; unsigned int Depth ; unsigned int HorzRes ; unsigned int VertRes ; } WPGBitmapType1 ; typedef struct { unsigned int Width ; unsigned int Height ; unsigned char Depth ; unsigned char Compression ; } WPG2BitmapType1 ; typedef struct { unsigned int RotAngle ; unsigned int LowLeftX ; unsigned int LowLeftY ; unsigned int UpRightX ; unsigned int UpRightY ; unsigned int Width ; unsigned int Height ; unsigned int Depth ; unsigned int HorzRes ; unsigned int VertRes ; } WPGBitmapType2 ; typedef struct { unsigned int StartIndex ; unsigned int NumOfEntries ; } WPGColorMapRec ; Image * image ; unsigned int status ; WPGHeader Header ; WPGRecord Rec ; WPG2Record Rec2 ; WPG2Start StartWPG ; WPGBitmapType1 BitmapHeader1 ; WPG2BitmapType1 Bitmap2Header1 ; WPGBitmapType2 BitmapHeader2 ; WPGColorMapRec WPG_Palette ; int i , bpp , WPG2Flags ; ssize_t ldblk ; size_t one ; unsigned char * BImgBuff ; tCTM CTM ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickCoreSignature ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickCoreSignature ) ; one = 1 ; image = AcquireImage ( image_info , exception ) ; image -> depth = 8 ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } Header . FileId = ReadBlobLSBLong ( image ) ; Header . DataOffset = ( MagickOffsetType ) ReadBlobLSBLong ( image ) ; Header . ProductType = ReadBlobLSBShort ( image ) ; Header . FileType = ReadBlobLSBShort ( image ) ; Header . MajorVersion = ReadBlobByte ( image ) ; Header . MinorVersion = ReadBlobByte ( image ) ; Header . EncryptKey = ReadBlobLSBShort ( image ) ; Header . Reserved = ReadBlobLSBShort ( image ) ; if ( Header . FileId != 0x435057FF || ( Header . ProductType >> 8 ) != 0x16 ) ThrowReaderException ( CorruptImageError , \"ImproperImageHeader\" ) ; if ( Header . EncryptKey != 0 ) ThrowReaderException ( CoderError , \"EncryptedWPGImageFileNotSupported\" ) ; image -> columns = 1 ; image -> rows = 1 ; image -> colors = 0 ; bpp = 0 ; BitmapHeader2 . RotAngle = 0 ; switch ( Header . FileType ) { case 1 : while ( ! EOFBlob ( image ) ) { ( void ) SeekBlob ( image , Header . DataOffset , SEEK_SET ) ; if ( EOFBlob ( image ) ) break ; Rec . RecType = ( i = ReadBlobByte ( image ) ) ; if ( i == EOF ) break ; Rd_WP_DWORD ( image , & Rec . RecordLength ) ; if ( EOFBlob ( image ) ) break ; Header . DataOffset = TellBlob ( image ) + Rec . RecordLength ; switch ( Rec . RecType ) { case 0x0B : BitmapHeader1 . Width = ReadBlobLSBShort ( image ) ; BitmapHeader1 . Height = ReadBlobLSBShort ( image ) ; if ( ( BitmapHeader1 . Width == 0 ) || ( BitmapHeader1 . Height == 0 ) ) ThrowReaderException ( CorruptImageError , \"ImproperImageHeader\" ) ; BitmapHeader1 . Depth = ReadBlobLSBShort ( image ) ; BitmapHeader1 . HorzRes = ReadBlobLSBShort ( image ) ; BitmapHeader1 . VertRes = ReadBlobLSBShort ( image ) ; if ( BitmapHeader1 . HorzRes && BitmapHeader1 . VertRes ) { image -> units = PixelsPerCentimeterResolution ; image -> resolution . x = BitmapHeader1 . HorzRes / 470.0 ; image -> resolution . y = BitmapHeader1 . VertRes / 470.0 ; } image -> columns = BitmapHeader1 . Width ; image -> rows = BitmapHeader1 . Height ; bpp = BitmapHeader1 . Depth ; goto UnpackRaster ; case 0x0E : WPG_Palette . StartIndex = ReadBlobLSBShort ( image ) ; WPG_Palette . NumOfEntries = ReadBlobLSBShort ( image ) ; image -> colors = WPG_Palette . NumOfEntries ; if ( ! AcquireImageColormap ( image , image -> colors , exception ) ) goto NoMemory ; for ( i = WPG_Palette . StartIndex ; i < ( int ) WPG_Palette . NumOfEntries ; i ++ ) { image -> colormap [ i ] . red = ScaleCharToQuantum ( ( unsigned char ) ReadBlobByte ( image ) ) ; image -> colormap [ i ] . green = ScaleCharToQuantum ( ( unsigned char ) ReadBlobByte ( image ) ) ; image -> colormap [ i ] . blue = ScaleCharToQuantum ( ( unsigned char ) ReadBlobByte ( image ) ) ; } break ; case 0x11 : if ( Rec . RecordLength > 8 ) image = ExtractPostscript ( image , image_info , TellBlob ( image ) + 8 , ( ssize_t ) Rec . RecordLength - 8 , exception ) ; break ; case 0x14 : BitmapHeader2 . RotAngle = ReadBlobLSBShort ( image ) ; BitmapHeader2 . LowLeftX = ReadBlobLSBShort ( image ) ; BitmapHeader2 . LowLeftY = ReadBlobLSBShort ( image ) ; BitmapHeader2 . UpRightX = ReadBlobLSBShort ( image ) ; BitmapHeader2 . UpRightY = ReadBlobLSBShort ( image ) ; BitmapHeader2 . Width = ReadBlobLSBShort ( image ) ; BitmapHeader2 . Height = ReadBlobLSBShort ( image ) ; if ( ( BitmapHeader2 . Width == 0 ) || ( BitmapHeader2 . Height == 0 ) ) ThrowReaderException ( CorruptImageError , \"ImproperImageHeader\" ) ; BitmapHeader2 . Depth = ReadBlobLSBShort ( image ) ; BitmapHeader2 . HorzRes = ReadBlobLSBShort ( image ) ; BitmapHeader2 . VertRes = ReadBlobLSBShort ( image ) ; image -> units = PixelsPerCentimeterResolution ; image -> page . width = ( unsigned int ) ( ( BitmapHeader2 . LowLeftX - BitmapHeader2 . UpRightX ) / 470.0 ) ; image -> page . height = ( unsigned int ) ( ( BitmapHeader2 . LowLeftX - BitmapHeader2 . UpRightY ) / 470.0 ) ; image -> page . x = ( int ) ( BitmapHeader2 . LowLeftX / 470.0 ) ; image -> page . y = ( int ) ( BitmapHeader2 . LowLeftX / 470.0 ) ; if ( BitmapHeader2 . HorzRes && BitmapHeader2 . VertRes ) { image -> resolution . x = BitmapHeader2 . HorzRes / 470.0 ; image -> resolution . y = BitmapHeader2 . VertRes / 470.0 ; } image -> columns = BitmapHeader2 . Width ; image -> rows = BitmapHeader2 . Height ; bpp = BitmapHeader2 . Depth ; UnpackRaster : if ( ( image -> colors == 0 ) && ( bpp != 24 ) ) { image -> colors = one << bpp ; if ( ! AcquireImageColormap ( image , image -> colors , exception ) ) { NoMemory : ThrowReaderException ( ResourceLimitError , \"MemoryAllocationFailed\" ) ; } for ( i = 0 ; ( i < ( int ) image -> colors ) && ( i < 256 ) ; i ++ ) { image -> colormap [ i ] . red = ScaleCharToQuantum ( WPG1_Palette [ i ] . Red ) ; image -> colormap [ i ] . green = ScaleCharToQuantum ( WPG1_Palette [ i ] . Green ) ; image -> colormap [ i ] . blue = ScaleCharToQuantum ( WPG1_Palette [ i ] . Blue ) ; } } else { if ( bpp < 24 ) if ( ( image -> colors < ( one << bpp ) ) && ( bpp != 24 ) ) image -> colormap = ( PixelInfo * ) ResizeQuantumMemory ( image -> colormap , ( size_t ) ( one << bpp ) , sizeof ( * image -> colormap ) ) ; } if ( bpp == 1 ) { if ( image -> colormap [ 0 ] . red == 0 && image -> colormap [ 0 ] . green == 0 && image -> colormap [ 0 ] . blue == 0 && image -> colormap [ 1 ] . red == 0 && image -> colormap [ 1 ] . green == 0 && image -> colormap [ 1 ] . blue == 0 ) { image -> colormap [ 1 ] . red = image -> colormap [ 1 ] . green = image -> colormap [ 1 ] . blue = QuantumRange ; } } if ( UnpackWPGRaster ( image , bpp , exception ) < 0 ) { DecompressionFailed : ThrowReaderException ( CoderError , \"UnableToDecompressImage\" ) ; } if ( Rec . RecType == 0x14 && BitmapHeader2 . RotAngle != 0 && ! image_info -> ping ) { if ( BitmapHeader2 . RotAngle & 0x8000 ) { Image * flop_image ; flop_image = FlopImage ( image , exception ) ; if ( flop_image != ( Image * ) NULL ) { DuplicateBlob ( flop_image , image ) ; ( void ) RemoveLastImageFromList ( & image ) ; AppendImageToList ( & image , flop_image ) ; } } if ( BitmapHeader2 . RotAngle & 0x2000 ) { Image * flip_image ; flip_image = FlipImage ( image , exception ) ; if ( flip_image != ( Image * ) NULL ) { DuplicateBlob ( flip_image , image ) ; ( void ) RemoveLastImageFromList ( & image ) ; AppendImageToList ( & image , flip_image ) ; } } if ( BitmapHeader2 . RotAngle & 0x0FFF ) { Image * rotate_image ; rotate_image = RotateImage ( image , ( BitmapHeader2 . RotAngle & 0x0FFF ) , exception ) ; if ( rotate_image != ( Image * ) NULL ) { DuplicateBlob ( rotate_image , image ) ; ( void ) RemoveLastImageFromList ( & image ) ; AppendImageToList ( & image , rotate_image ) ; } } } AcquireNextImage ( image_info , image , exception ) ; image -> depth = 8 ; if ( image -> next == ( Image * ) NULL ) goto Finish ; image = SyncNextImageInList ( image ) ; image -> columns = image -> rows = 0 ; image -> colors = 0 ; break ; case 0x1B : if ( Rec . RecordLength > 0x3C ) image = ExtractPostscript ( image , image_info , TellBlob ( image ) + 0x3C , ( ssize_t ) Rec . RecordLength - 0x3C , exception ) ; break ; } } break ; case 2 : ( void ) memset ( CTM , 0 , sizeof ( CTM ) ) ; StartWPG . PosSizePrecision = 0 ; while ( ! EOFBlob ( image ) ) { ( void ) SeekBlob ( image , Header . DataOffset , SEEK_SET ) ; if ( EOFBlob ( image ) ) break ; Rec2 . Class = ( i = ReadBlobByte ( image ) ) ; if ( i == EOF ) break ; Rec2 . RecType = ( i = ReadBlobByte ( image ) ) ; if ( i == EOF ) break ; Rd_WP_DWORD ( image , & Rec2 . Extension ) ; Rd_WP_DWORD ( image , & Rec2 . RecordLength ) ; if ( EOFBlob ( image ) ) break ; Header . DataOffset = TellBlob ( image ) + Rec2 . RecordLength ; switch ( Rec2 . RecType ) { case 1 : StartWPG . HorizontalUnits = ReadBlobLSBShort ( image ) ; StartWPG . VerticalUnits = ReadBlobLSBShort ( image ) ; StartWPG . PosSizePrecision = ReadBlobByte ( image ) ; break ; case 0x0C : WPG_Palette . StartIndex = ReadBlobLSBShort ( image ) ; WPG_Palette . NumOfEntries = ReadBlobLSBShort ( image ) ; image -> colors = WPG_Palette . NumOfEntries ; if ( AcquireImageColormap ( image , image -> colors , exception ) == MagickFalse ) ThrowReaderException ( ResourceLimitError , \"MemoryAllocationFailed\" ) ; for ( i = WPG_Palette . StartIndex ; i < ( int ) WPG_Palette . NumOfEntries ; i ++ ) { image -> colormap [ i ] . red = ScaleCharToQuantum ( ( char ) ReadBlobByte ( image ) ) ; image -> colormap [ i ] . green = ScaleCharToQuantum ( ( char ) ReadBlobByte ( image ) ) ; image -> colormap [ i ] . blue = ScaleCharToQuantum ( ( char ) ReadBlobByte ( image ) ) ; ( void ) ReadBlobByte ( image ) ; } break ; case 0x0E : Bitmap2Header1 . Width = ReadBlobLSBShort ( image ) ; Bitmap2Header1 . Height = ReadBlobLSBShort ( image ) ; if ( ( Bitmap2Header1 . Width == 0 ) || ( Bitmap2Header1 . Height == 0 ) ) ThrowReaderException ( CorruptImageError , \"ImproperImageHeader\" ) ; Bitmap2Header1 . Depth = ReadBlobByte ( image ) ; Bitmap2Header1 . Compression = ReadBlobByte ( image ) ; if ( Bitmap2Header1 . Compression > 1 ) continue ; switch ( Bitmap2Header1 . Depth ) { case 1 : bpp = 1 ; break ; case 2 : bpp = 2 ; break ; case 3 : bpp = 4 ; break ; case 4 : bpp = 8 ; break ; case 8 : bpp = 24 ; break ; default : continue ; } image -> columns = Bitmap2Header1 . Width ; image -> rows = Bitmap2Header1 . Height ; if ( ( image -> colors == 0 ) && ( bpp != 24 ) ) { size_t one ; one = 1 ; image -> colors = one << bpp ; if ( ! AcquireImageColormap ( image , image -> colors , exception ) ) goto NoMemory ; } else { if ( bpp < 24 ) if ( image -> colors < ( one << bpp ) && bpp != 24 ) image -> colormap = ( PixelInfo * ) ResizeQuantumMemory ( image -> colormap , ( size_t ) ( one << bpp ) , sizeof ( * image -> colormap ) ) ; } switch ( Bitmap2Header1 . Compression ) { case 0 : { ldblk = ( ssize_t ) ( ( bpp * image -> columns + 7 ) / 8 ) ; BImgBuff = ( unsigned char * ) AcquireQuantumMemory ( ( size_t ) <S2SV_StartBug> ldblk , sizeof ( * BImgBuff ) ) ; <S2SV_EndBug> if ( BImgBuff == ( unsigned char * ) NULL ) goto NoMemory ; for ( i = 0 ; i < ( ssize_t ) image -> rows ; i ++ ) { ( void ) ReadBlob ( image , ldblk , BImgBuff ) ; InsertRow ( image , BImgBuff , i , bpp , exception ) ; } if ( BImgBuff ) BImgBuff = ( unsigned char * ) RelinquishMagickMemory ( BImgBuff ) ; ; break ; } case 1 : { if ( UnpackWPG2Raster ( image , bpp , exception ) < 0 ) goto DecompressionFailed ; break ; } } if ( CTM [ 0 ] [ 0 ] < 0 && ! image_info -> ping ) { Image * flop_image ; flop_image = FlopImage ( image , exception ) ; if ( flop_image != ( Image * ) NULL ) { DuplicateBlob ( flop_image , image ) ; ( void ) RemoveLastImageFromList ( & image ) ; AppendImageToList ( & image , flop_image ) ; } } if ( CTM [ 1 ] [ 1 ] < 0 && ! image_info -> ping ) { Image * flip_image ; flip_image = FlipImage ( image , exception ) ; if ( flip_image != ( Image * ) NULL ) { DuplicateBlob ( flip_image , image ) ; ( void ) RemoveLastImageFromList ( & image ) ; AppendImageToList ( & image , flip_image ) ; } } AcquireNextImage ( image_info , image , exception ) ; image -> depth = 8 ; if ( image -> next == ( Image * ) NULL ) goto Finish ; image = SyncNextImageInList ( image ) ; image -> columns = image -> rows = 1 ; image -> colors = 0 ; break ; case 0x12 : i = ReadBlobLSBShort ( image ) ; if ( Rec2 . RecordLength > ( unsigned int ) i ) image = ExtractPostscript ( image , image_info , TellBlob ( image ) + i , ( ssize_t ) ( Rec2 . RecordLength - i - 2 ) , exception ) ; break ; case 0x1B : WPG2Flags = LoadWPG2Flags ( image , StartWPG . PosSizePrecision , NULL , & CTM ) ; ( void ) WPG2Flags ; break ; } } break ; default : { ThrowReaderException ( CoderError , \"DataEncodingSchemeIsNotSupported\" ) ; } } status = SetImageExtent ( image , image -> columns , image -> rows , exception ) ; if ( status == MagickFalse ) return ( DestroyImageList ( image ) ) ; Finish : ( void ) CloseBlob ( image ) ; { Image * p ; ssize_t scene = 0 ; p = image ; image = NULL ; while ( p != ( Image * ) NULL ) { Image * tmp = p ; if ( ( p -> rows == 0 ) || ( p -> columns == 0 ) ) { p = p -> previous ; DeleteImageFromList ( & tmp ) ; } else { image = p ; p = p -> previous ; } } for ( p = image ; p != ( Image * ) NULL ; p = p -> next ) p -> scene = ( size_t ) scene ++ ; } if ( image == ( Image * ) NULL ) ThrowReaderException ( CorruptImageError , \"ImageFileDoesNotContainAnyImageData\" ) ; return ( image ) ; }\n",
      "fixed_code": "<S2SV_ModStart> size_t ) ldblk + 1\n",
      "source_code_length": 14332,
      "target_code_length": 35,
      "vulnerability_patterns": {
        "buffer_overflow": 1,
        "use_after_free": 1,
        "integer_overflow": 5,
        "null_pointer": 82,
        "total": 89
      },
      "total_patterns": 89,
      "original_address": "https://github.com/ImageMagick/ImageMagick/commit/bef1e4f637d8f665bc133a9c6d30df08d983bc3a",
      "discovery_time": "2017-04-19T14:59Z",
      "project_commit_id": "ImageMagick@ImageMagick/bef1e4f637d8f665bc133a9c6d30df08d983bc3a",
      "extraction_time": "2025-08-31T15:41:49.176156",
      "label": 1,
      "vulnerability_type": "out-of-bounds_read",
      "difficulty_level": "expert",
      "risk_factors": [
        "memory_corruption",
        "critical_infrastructure",
        "buffer_overflow",
        "information_disclosure",
        "use_after_free",
        "integer_overflow"
      ],
      "attack_vectors": [
        "memory_manipulation",
        "malicious_input",
        "code_analysis",
        "buffer_overflow",
        "reverse_engineering",
        "fuzzing"
      ],
      "mitigation_strategies": [
        "safe_string_functions",
        "dynamic_analysis",
        "code_review",
        "static_analysis",
        "memory_safety_checks",
        "input_validation",
        "fuzzing",
        "bounds_checking",
        "secure_coding_practices"
      ],
      "code_differences": {
        "has_differences": true,
        "source_lines": 2,
        "target_lines": 2,
        "character_differences": 14297,
        "similarity_percentage": 2.242152466367713
      },
      "vulnerability_location": {
        "vulnerability_present": true,
        "fix_applied": true,
        "code_changed": true,
        "estimated_lines_changed": 0
      }
    },
    {
      "cve_id": "CVE-2018-7485",
      "cwe_id": "CWE-119",
      "cwe_name": "Buffer Overflow",
      "project": "lurcher",
      "severity": "critical",
      "weaponization_score": 10.0,
      "is_critical": true,
      "is_weaponizable": true,
      "is_high_priority_project": false,
      "vulnerable_code": "CWE-119 SQLRETURN SQLSetDescFieldW ( SQLHDESC descriptor_handle , SQLSMALLINT rec_number , SQLSMALLINT field_identifier , SQLPOINTER value , SQLINTEGER buffer_length ) { DMHDESC descriptor = ( DMHDESC ) descriptor_handle ; SQLRETURN ret ; SQLCHAR s1 [ 100 + LOG_MESSAGE_LEN ] ; int isStrField = 0 ; if ( ! __validate_desc ( descriptor ) ) { dm_log_write ( __FILE__ , __LINE__ , LOG_INFO , LOG_INFO , \"Error:<S2SV_blank>SQL_INVALID_HANDLE\" ) ; # ifdef WITH_HANDLE_REDIRECT { DMHDESC parent_desc ; parent_desc = find_parent_handle ( descriptor , SQL_HANDLE_DESC ) ; if ( parent_desc ) { dm_log_write ( __FILE__ , __LINE__ , LOG_INFO , LOG_INFO , \"Info:<S2SV_blank>found<S2SV_blank>parent<S2SV_blank>handle\" ) ; if ( CHECK_SQLSETDESCFIELDW ( parent_desc -> connection ) ) { dm_log_write ( __FILE__ , __LINE__ , LOG_INFO , LOG_INFO , \"Info:<S2SV_blank>calling<S2SV_blank>redirected<S2SV_blank>driver<S2SV_blank>function\" ) ; return SQLSETDESCFIELDW ( parent_desc -> connection , descriptor , rec_number , field_identifier , value , buffer_length ) ; } } } # endif return SQL_INVALID_HANDLE ; } function_entry ( descriptor ) ; if ( log_info . log_flag ) { <S2SV_StartBug> sprintf ( descriptor -> msg , \"\\\\n\\\\t\\\\tEntry:\\\\\\n<S2SV_blank>\\\\n\\\\t\\\\t\\\\tDescriptor<S2SV_blank>=<S2SV_blank>%p\\\\\\n<S2SV_blank>\\\\n\\\\t\\\\t\\\\tRec<S2SV_blank>Number<S2SV_blank>=<S2SV_blank>%d\\\\\\n<S2SV_blank>\\\\n\\\\t\\\\t\\\\tField<S2SV_blank>Ident<S2SV_blank>=<S2SV_blank>%s\\\\\\n<S2SV_blank>\\\\n\\\\t\\\\t\\\\tValue<S2SV_blank>=<S2SV_blank>%p\\\\\\n<S2SV_blank>\\\\n\\\\t\\\\t\\\\tBuffer<S2SV_blank>Length<S2SV_blank>=<S2SV_blank>%d\" , <S2SV_EndBug> descriptor , rec_number , __desc_attr_as_string ( s1 , field_identifier ) , value , ( int ) buffer_length ) ; dm_log_write ( __FILE__ , __LINE__ , LOG_INFO , LOG_INFO , descriptor -> msg ) ; } thread_protect ( SQL_HANDLE_DESC , descriptor ) ; if ( descriptor -> connection -> state < STATE_C4 ) { dm_log_write ( __FILE__ , __LINE__ , LOG_INFO , LOG_INFO , \"Error:<S2SV_blank>HY010\" ) ; __post_internal_error ( & descriptor -> error , ERROR_HY010 , NULL , descriptor -> connection -> environment -> requested_version ) ; return function_return_nodrv ( SQL_HANDLE_DESC , descriptor , SQL_ERROR ) ; } if ( __check_stmt_from_desc ( descriptor , STATE_S8 ) || __check_stmt_from_desc ( descriptor , STATE_S9 ) || __check_stmt_from_desc ( descriptor , STATE_S10 ) || __check_stmt_from_desc ( descriptor , STATE_S11 ) || __check_stmt_from_desc ( descriptor , STATE_S12 ) || __check_stmt_from_desc ( descriptor , STATE_S13 ) || __check_stmt_from_desc ( descriptor , STATE_S14 ) || __check_stmt_from_desc ( descriptor , STATE_S15 ) ) { dm_log_write ( __FILE__ , __LINE__ , LOG_INFO , LOG_INFO , \"Error:<S2SV_blank>HY010\" ) ; __post_internal_error ( & descriptor -> error , ERROR_HY010 , NULL , descriptor -> connection -> environment -> requested_version ) ; return function_return_nodrv ( SQL_HANDLE_DESC , descriptor , SQL_ERROR ) ; } if ( rec_number < 0 ) { __post_internal_error ( & descriptor -> error , ERROR_07009 , NULL , descriptor -> connection -> environment -> requested_version ) ; return function_return_nodrv ( SQL_HANDLE_DESC , descriptor , SQL_ERROR ) ; } switch ( field_identifier ) { case SQL_DESC_ALLOC_TYPE : case SQL_DESC_ARRAY_SIZE : case SQL_DESC_ARRAY_STATUS_PTR : case SQL_DESC_BIND_OFFSET_PTR : case SQL_DESC_BIND_TYPE : case SQL_DESC_COUNT : case SQL_DESC_ROWS_PROCESSED_PTR : case SQL_DESC_AUTO_UNIQUE_VALUE : case SQL_DESC_CASE_SENSITIVE : case SQL_DESC_CONCISE_TYPE : case SQL_DESC_DATA_PTR : case SQL_DESC_DATETIME_INTERVAL_CODE : case SQL_DESC_DATETIME_INTERVAL_PRECISION : case SQL_DESC_DISPLAY_SIZE : case SQL_DESC_FIXED_PREC_SCALE : case SQL_DESC_INDICATOR_PTR : case SQL_DESC_LENGTH : case SQL_DESC_NULLABLE : case SQL_DESC_NUM_PREC_RADIX : case SQL_DESC_OCTET_LENGTH : case SQL_DESC_OCTET_LENGTH_PTR : case SQL_DESC_PARAMETER_TYPE : case SQL_DESC_PRECISION : case SQL_DESC_ROWVER : case SQL_DESC_SCALE : case SQL_DESC_SEARCHABLE : case SQL_DESC_TYPE : case SQL_DESC_UNNAMED : case SQL_DESC_UNSIGNED : case SQL_DESC_UPDATABLE : isStrField = 0 ; break ; case SQL_DESC_BASE_COLUMN_NAME : case SQL_DESC_BASE_TABLE_NAME : case SQL_DESC_CATALOG_NAME : case SQL_DESC_LABEL : case SQL_DESC_LITERAL_PREFIX : case SQL_DESC_LITERAL_SUFFIX : case SQL_DESC_LOCAL_TYPE_NAME : case SQL_DESC_NAME : case SQL_DESC_SCHEMA_NAME : case SQL_DESC_TABLE_NAME : case SQL_DESC_TYPE_NAME : isStrField = 1 ; break ; default : isStrField = buffer_length != SQL_IS_POINTER && buffer_length != SQL_IS_INTEGER && buffer_length != SQL_IS_UINTEGER && buffer_length != SQL_IS_SMALLINT && buffer_length != SQL_IS_USMALLINT ; } if ( isStrField && buffer_length < 0 && buffer_length != SQL_NTS ) { __post_internal_error ( & descriptor -> error , ERROR_HY090 , NULL , descriptor -> connection -> environment -> requested_version ) ; return function_return_nodrv ( SQL_HANDLE_DESC , descriptor , SQL_ERROR ) ; } <S2SV_StartBug> if ( field_identifier == SQL_DESC_COUNT && ( SQLINTEGER ) value < 0 ) <S2SV_EndBug> { __post_internal_error ( & descriptor -> error , ERROR_07009 , NULL , descriptor -> connection -> environment -> requested_version ) ; return function_return_nodrv ( SQL_HANDLE_DESC , descriptor , SQL_ERROR ) ; } <S2SV_StartBug> if ( field_identifier == SQL_DESC_PARAMETER_TYPE && value != SQL_PARAM_INPUT <S2SV_EndBug> <S2SV_StartBug> && value != SQL_PARAM_OUTPUT && value != SQL_PARAM_INPUT_OUTPUT && <S2SV_EndBug> <S2SV_StartBug> value != SQL_PARAM_INPUT_OUTPUT_STREAM && value != SQL_PARAM_OUTPUT_STREAM ) <S2SV_EndBug> { __post_internal_error ( & descriptor -> error , ERROR_HY105 , NULL , descriptor -> connection -> environment -> requested_version ) ; return function_return_nodrv ( SQL_HANDLE_DESC , descriptor , SQL_ERROR ) ; } if ( descriptor -> connection -> unicode_driver || CHECK_SQLSETDESCFIELDW ( descriptor -> connection ) ) { if ( ! CHECK_SQLSETDESCFIELDW ( descriptor -> connection ) ) { dm_log_write ( __FILE__ , __LINE__ , LOG_INFO , LOG_INFO , \"Error:<S2SV_blank>IM001\" ) ; __post_internal_error ( & descriptor -> error , ERROR_IM001 , NULL , descriptor -> connection -> environment -> requested_version ) ; return function_return_nodrv ( SQL_HANDLE_DESC , descriptor , SQL_ERROR ) ; } ret = SQLSETDESCFIELDW ( descriptor -> connection , descriptor -> driver_desc , rec_number , field_identifier , value , buffer_length ) ; if ( log_info . log_flag ) { sprintf ( descriptor -> msg , \"\\\\n\\\\t\\\\tExit:[%s]\" , __get_return_status ( ret , s1 ) ) ; dm_log_write ( __FILE__ , __LINE__ , LOG_INFO , LOG_INFO , descriptor -> msg ) ; } } else { SQLCHAR * ascii_str = NULL ; if ( ! CHECK_SQLSETDESCFIELD ( descriptor -> connection ) ) { dm_log_write ( __FILE__ , __LINE__ , LOG_INFO , LOG_INFO , \"Error:<S2SV_blank>IM001\" ) ; __post_internal_error ( & descriptor -> error , ERROR_IM001 , NULL , descriptor -> connection -> environment -> requested_version ) ; return function_return_nodrv ( SQL_HANDLE_DESC , descriptor , SQL_ERROR ) ; } switch ( field_identifier ) { case SQL_DESC_NAME : ascii_str = ( SQLCHAR * ) unicode_to_ansi_alloc ( value , buffer_length , descriptor -> connection , NULL ) ; value = ascii_str ; buffer_length = strlen ( ( char * ) ascii_str ) ; break ; default : break ; } ret = SQLSETDESCFIELD ( descriptor -> connection , descriptor -> driver_desc , rec_number , field_identifier , value , buffer_length ) ; if ( log_info . log_flag ) { sprintf ( descriptor -> msg , \"\\\\n\\\\t\\\\tExit:[%s]\" , __get_return_status ( ret , s1 ) ) ; dm_log_write ( __FILE__ , __LINE__ , LOG_INFO , LOG_INFO , descriptor -> msg ) ; } if ( ascii_str ) { free ( ascii_str ) ; } } return function_return ( SQL_HANDLE_DESC , descriptor , ret ) ; }\n",
      "fixed_code": "<S2SV_ModStart> -> msg , \"\\\\n\\\\t\\\\tEntry:\\\\\\n\\\\n\\\\t\\\\t\\\\tDescriptor<S2SV_blank>=<S2SV_blank>%p\\\\\\n\\\\n\\\\t\\\\t\\\\tRec<S2SV_blank>Number<S2SV_blank>=<S2SV_blank>%d\\\\\\n\\\\n\\\\t\\\\t\\\\tField<S2SV_blank>Ident<S2SV_blank>=<S2SV_blank>%s\\\\\\n\\\\n\\\\t\\\\t\\\\tValue<S2SV_blank>=<S2SV_blank>%p\\\\\\n\\\\n\\\\t\\\\t\\\\tBuffer<S2SV_blank>Length<S2SV_blank>=<S2SV_blank>%d\" <S2SV_ModEnd> , descriptor , <S2SV_ModStart> SQL_DESC_COUNT && ( intptr_t <S2SV_ModEnd> ) value < <S2SV_ModStart> == SQL_DESC_PARAMETER_TYPE && ( intptr_t ) <S2SV_ModStart> != SQL_PARAM_INPUT && ( intptr_t ) <S2SV_ModStart> != SQL_PARAM_OUTPUT && ( intptr_t ) <S2SV_ModStart> != SQL_PARAM_INPUT_OUTPUT && ( intptr_t ) <S2SV_ModStart> != SQL_PARAM_INPUT_OUTPUT_STREAM && ( intptr_t )\n",
      "source_code_length": 7648,
      "target_code_length": 723,
      "vulnerability_patterns": {
        "buffer_overflow": 3,
        "use_after_free": 1,
        "format_string": 3,
        "null_pointer": 52,
        "total": 59
      },
      "total_patterns": 59,
      "original_address": "https://github.com/lurcher/unixODBC/commit/45ef78e037f578b15fc58938a3a3251655e71d6f#diff-d52750c7ba4e594410438569d8e2963aL24",
      "discovery_time": "2018-02-26T14:29Z",
      "project_commit_id": "lurcher@unixODBC/45ef78e037f578b15fc58938a3a3251655e71d6f",
      "extraction_time": "2025-08-31T15:41:49.176268",
      "label": 1,
      "vulnerability_type": "buffer_overflow",
      "difficulty_level": "expert",
      "risk_factors": [
        "memory_corruption",
        "arbitrary_code_execution",
        "buffer_overflow",
        "system_crash",
        "use_after_free"
      ],
      "attack_vectors": [
        "memory_manipulation",
        "malicious_input",
        "code_analysis",
        "buffer_overflow",
        "reverse_engineering",
        "fuzzing"
      ],
      "mitigation_strategies": [
        "safe_string_functions",
        "dynamic_analysis",
        "code_review",
        "static_analysis",
        "memory_safety_checks",
        "input_validation",
        "fuzzing",
        "bounds_checking",
        "secure_coding_practices"
      ],
      "code_differences": {
        "has_differences": true,
        "source_lines": 2,
        "target_lines": 2,
        "character_differences": 6925,
        "similarity_percentage": 9.826589595375722
      },
      "vulnerability_location": {
        "vulnerability_present": true,
        "fix_applied": true,
        "code_changed": true,
        "estimated_lines_changed": 0
      }
    },
    {
      "cve_id": "CVE-2012-1571",
      "cwe_id": "CWE-119",
      "cwe_name": "Buffer Overflow",
      "project": "glensc",
      "severity": "critical",
      "weaponization_score": 10.0,
      "is_critical": true,
      "is_weaponizable": true,
      "is_high_priority_project": false,
      "vulnerable_code": "CWE-119 ssize_t cdf_read_short_sector ( const cdf_stream_t * sst , void * buf , size_t offs , size_t len , const cdf_header_t * h , cdf_secid_t id ) { <S2SV_StartBug> assert ( ( size_t ) CDF_SHORT_SEC_SIZE ( h ) == len ) ; <S2SV_EndBug> ( void ) memcpy ( ( ( char * ) buf ) + offs , <S2SV_StartBug> ( ( const char * ) sst -> sst_tab ) + CDF_SHORT_SEC_POS ( h , id ) , len ) ; <S2SV_EndBug> return len ; }\n",
      "fixed_code": "<S2SV_ModStart> id ) { size_t ss = <S2SV_ModEnd> CDF_SHORT_SEC_SIZE ( h <S2SV_ModStart> ( h ) ; size_t pos = CDF_SHORT_SEC_POS ( h , id ) ; assert ( ss <S2SV_ModStart> len ) ; if ( sst -> sst_len < ( size_t ) id ) { DPRINTF ( ( \"bad<S2SV_blank>sector<S2SV_blank>id<S2SV_blank>%d<S2SV_blank>><S2SV_blank>%d\\\\n\" , id , sst -> sst_len ) ) ; return - 1 ; } <S2SV_ModStart> sst_tab ) + pos <S2SV_ModEnd> , len )\n",
      "source_code_length": 405,
      "target_code_length": 407,
      "vulnerability_patterns": {
        "buffer_overflow": 10,
        "use_after_free": 4,
        "integer_overflow": 10,
        "null_pointer": 6,
        "memory_leak": 3,
        "total": 33
      },
      "total_patterns": 33,
      "original_address": "https://github.com/glensc/file/commit/1859fdb4e67c49c463c4e0078054335cd46ba295",
      "discovery_time": "2012-07-17T21:55Z",
      "project_commit_id": "glensc@file/1859fdb4e67c49c463c4e0078054335cd46ba295",
      "extraction_time": "2025-08-31T15:41:49.176319",
      "label": 1,
      "vulnerability_type": "buffer_overflow",
      "difficulty_level": "expert",
      "risk_factors": [
        "memory_corruption",
        "arbitrary_code_execution",
        "buffer_overflow",
        "system_crash",
        "use_after_free"
      ],
      "attack_vectors": [
        "memory_manipulation",
        "malicious_input",
        "code_analysis",
        "buffer_overflow",
        "reverse_engineering",
        "fuzzing"
      ],
      "mitigation_strategies": [
        "safe_string_functions",
        "dynamic_analysis",
        "code_review",
        "static_analysis",
        "memory_safety_checks",
        "input_validation",
        "fuzzing",
        "bounds_checking",
        "secure_coding_practices"
      ],
      "code_differences": {
        "has_differences": true,
        "source_lines": 2,
        "target_lines": 2,
        "character_differences": 2,
        "similarity_percentage": 39.130434782608695
      },
      "vulnerability_location": {
        "vulnerability_present": true,
        "fix_applied": true,
        "code_changed": true,
        "estimated_lines_changed": 0
      }
    },
    {
      "cve_id": "CVE-2020-14954",
      "cwe_id": "CWE-74",
      "cwe_name": "Command Injection",
      "project": "neomutt",
      "severity": "critical",
      "weaponization_score": 10.0,
      "is_critical": true,
      "is_weaponizable": true,
      "is_high_priority_project": true,
      "vulnerable_code": "CWE-74 int nntp_open_connection ( struct NntpAccountData * adata ) { struct Connection * conn = adata -> conn ; char buf [ 256 ] ; int cap ; bool posting = false , auth = true ; if ( adata -> status == NNTP_OK ) return 0 ; if ( adata -> status == NNTP_BYE ) return - 1 ; adata -> status = NNTP_NONE ; if ( mutt_socket_open ( conn ) < 0 ) return - 1 ; if ( mutt_socket_readln ( buf , sizeof ( buf ) , conn ) < 0 ) return nntp_connect_error ( adata ) ; if ( mutt_str_startswith ( buf , \"200\" , CASE_MATCH ) ) posting = true ; else if ( ! mutt_str_startswith ( buf , \"201\" , CASE_MATCH ) ) { mutt_socket_close ( conn ) ; mutt_str_remove_trailing_ws ( buf ) ; mutt_error ( \"%s\" , buf ) ; return - 1 ; } cap = nntp_capabilities ( adata ) ; if ( cap < 0 ) return - 1 ; if ( cap > 0 ) { if ( ( mutt_socket_send ( conn , \"MODE<S2SV_blank>READER\\\\r\\\\n\" ) < 0 ) || ( mutt_socket_readln ( buf , sizeof ( buf ) , conn ) < 0 ) ) { return nntp_connect_error ( adata ) ; } if ( mutt_str_startswith ( buf , \"200\" , CASE_MATCH ) ) posting = true ; else if ( mutt_str_startswith ( buf , \"201\" , CASE_MATCH ) ) posting = false ; else if ( adata -> hasCAPABILITIES ) { mutt_socket_close ( conn ) ; mutt_error ( _ ( \"Could<S2SV_blank>not<S2SV_blank>switch<S2SV_blank>to<S2SV_blank>reader<S2SV_blank>mode\" ) ) ; return - 1 ; } if ( adata -> hasCAPABILITIES ) { cap = nntp_capabilities ( adata ) ; if ( cap < 0 ) return - 1 ; } } mutt_message ( _ ( \"Connected<S2SV_blank>to<S2SV_blank>%s.<S2SV_blank>%s\" ) , conn -> account . host , posting ? _ ( \"Posting<S2SV_blank>is<S2SV_blank>ok\" ) : _ ( \"Posting<S2SV_blank>is<S2SV_blank>NOT<S2SV_blank>ok\" ) ) ; mutt_sleep ( 1 ) ; # ifdef USE_SSL if ( ( adata -> use_tls != 1 ) && ( adata -> hasSTARTTLS || C_SslForceTls ) ) { if ( adata -> use_tls == 0 ) { adata -> use_tls = C_SslForceTls || query_quadoption ( C_SslStarttls , _ ( \"Secure<S2SV_blank>connection<S2SV_blank>with<S2SV_blank>TLS?\" ) ) == MUTT_YES ? 2 : 1 ; } if ( adata -> use_tls == 2 ) { if ( ( mutt_socket_send ( conn , \"STARTTLS\\\\r\\\\n\" ) < 0 ) || ( mutt_socket_readln ( buf , sizeof ( buf ) , conn ) < 0 ) ) { return nntp_connect_error ( adata ) ; <S2SV_StartBug> } <S2SV_EndBug> if ( ! mutt_str_startswith ( buf , \"382\" , CASE_MATCH ) ) { adata -> use_tls = 0 ; mutt_error ( \"STARTTLS:<S2SV_blank>%s\" , buf ) ; } else if ( mutt_ssl_starttls ( conn ) ) { adata -> use_tls = 0 ; adata -> status = NNTP_NONE ; mutt_socket_close ( adata -> conn ) ; mutt_error ( _ ( \"Could<S2SV_blank>not<S2SV_blank>negotiate<S2SV_blank>TLS<S2SV_blank>connection\" ) ) ; return - 1 ; } else { cap = nntp_capabilities ( adata ) ; if ( cap < 0 ) return - 1 ; } } } # endif if ( conn -> account . flags & MUTT_ACCT_USER ) { if ( ! conn -> account . user [ 0 ] ) auth = false ; } else { if ( ( mutt_socket_send ( conn , \"STAT\\\\r\\\\n\" ) < 0 ) || ( mutt_socket_readln ( buf , sizeof ( buf ) , conn ) < 0 ) ) { return nntp_connect_error ( adata ) ; } if ( ! mutt_str_startswith ( buf , \"480\" , CASE_MATCH ) ) auth = false ; } if ( auth && ( nntp_auth ( adata ) < 0 ) ) return - 1 ; if ( adata -> hasCAPABILITIES && ( auth || ( cap > 0 ) ) ) { cap = nntp_capabilities ( adata ) ; if ( cap < 0 ) return - 1 ; if ( cap > 0 ) { mutt_socket_close ( conn ) ; mutt_error ( _ ( \"Could<S2SV_blank>not<S2SV_blank>switch<S2SV_blank>to<S2SV_blank>reader<S2SV_blank>mode\" ) ) ; return - 1 ; } } if ( nntp_attempt_features ( adata ) < 0 ) return - 1 ; adata -> status = NNTP_OK ; return 0 ; }\n",
      "fixed_code": "<S2SV_ModStart> ) ; } mutt_socket_empty ( conn ) ;\n",
      "source_code_length": 3436,
      "target_code_length": 51,
      "vulnerability_patterns": {
        "null_pointer": 15,
        "total": 15
      },
      "total_patterns": 15,
      "original_address": "https://github.com/neomutt/neomutt/commit/fb013ec666759cb8a9e294347c7b4c1f597639cc",
      "discovery_time": "2020-06-21T17:15Z",
      "project_commit_id": "neomutt@neomutt/fb013ec666759cb8a9e294347c7b4c1f597639cc",
      "extraction_time": "2025-08-31T15:41:49.176333",
      "label": 1,
      "vulnerability_type": "command_injection",
      "difficulty_level": "expert",
      "risk_factors": [
        "command_injection",
        "arbitrary_code_execution",
        "critical_infrastructure",
        "remote_code_execution"
      ],
      "attack_vectors": [
        "command_injection",
        "system_commands",
        "code_analysis",
        "reverse_engineering",
        "fuzzing",
        "user_input"
      ],
      "mitigation_strategies": [
        "fuzzing",
        "dynamic_analysis",
        "command_whitelisting",
        "static_analysis",
        "secure_coding_practices",
        "privilege_separation",
        "input_sanitization",
        "code_review",
        "input_validation"
      ],
      "code_differences": {
        "has_differences": true,
        "source_lines": 2,
        "target_lines": 2,
        "character_differences": 3385,
        "similarity_percentage": 4.901960784313726
      },
      "vulnerability_location": {
        "vulnerability_present": true,
        "fix_applied": true,
        "code_changed": true,
        "estimated_lines_changed": 0
      }
    },
    {
      "cve_id": "CVE-2018-20763",
      "cwe_id": "CWE-787",
      "cwe_name": "Out-of-bounds Write",
      "project": "gpac",
      "severity": "critical",
      "weaponization_score": 10.0,
      "is_critical": true,
      "is_weaponizable": true,
      "is_high_priority_project": false,
      "vulnerable_code": "CWE-787 int mp4client_main ( int argc , char * * argv ) { char c ; const char * str ; int ret_val = 0 ; u32 i , times [ 100 ] , nb_times , dump_mode ; u32 simulation_time_in_ms = 0 ; u32 initial_service_id = 0 ; Bool auto_exit = GF_FALSE ; Bool logs_set = GF_FALSE ; Bool start_fs = GF_FALSE ; Bool use_rtix = GF_FALSE ; Bool pause_at_first = GF_FALSE ; Bool no_cfg_save = GF_FALSE ; Bool is_cfg_only = GF_FALSE ; Double play_from = 0 ; # ifdef GPAC_MEMORY_TRACKING GF_MemTrackerType mem_track = GF_MemTrackerNone ; # endif Double fps = GF_IMPORT_DEFAULT_FPS ; Bool fill_ar , visible , do_uncache , has_command ; char * url_arg , * out_arg , * the_cfg , * rti_file , * views , * mosaic ; FILE * logfile = NULL ; Float scale = 1 ; # ifndef WIN32 dlopen ( NULL , RTLD_NOW | RTLD_GLOBAL ) ; # endif strcpy ( the_url , \".\" ) ; memset ( & user , 0 , sizeof ( GF_User ) ) ; dump_mode = DUMP_NONE ; fill_ar = visible = do_uncache = has_command = GF_FALSE ; url_arg = out_arg = the_cfg = rti_file = views = mosaic = NULL ; nb_times = 0 ; times [ 0 ] = 0 ; for ( i = 1 ; i < ( u32 ) argc ; i ++ ) { char * arg = argv [ i ] ; if ( ! strcmp ( arg , \"-c\" ) || ! strcmp ( arg , \"-cfg\" ) ) { the_cfg = argv [ i + 1 ] ; i ++ ; } else if ( ! strcmp ( arg , \"-mem-track\" ) || ! strcmp ( arg , \"-mem-track-stack\" ) ) { # ifdef GPAC_MEMORY_TRACKING mem_track = ! strcmp ( arg , \"-mem-track-stack\" ) ? GF_MemTrackerBackTrace : GF_MemTrackerSimple ; # else fprintf ( stderr , \"WARNING<S2SV_blank>-<S2SV_blank>GPAC<S2SV_blank>not<S2SV_blank>compiled<S2SV_blank>with<S2SV_blank>Memory<S2SV_blank>Tracker<S2SV_blank>-<S2SV_blank>ignoring<S2SV_blank>\\\\\"%s\\\\\"\\\\n\" , arg ) ; # endif } else if ( ! strcmp ( arg , \"-gui\" ) ) { gui_mode = 1 ; } else if ( ! strcmp ( arg , \"-guid\" ) ) { gui_mode = 2 ; } else if ( ! strcmp ( arg , \"-h\" ) || ! strcmp ( arg , \"-help\" ) ) { PrintUsage ( ) ; return 0 ; } } # ifdef GPAC_MEMORY_TRACKING gf_sys_init ( mem_track ) ; # else gf_sys_init ( GF_MemTrackerNone ) ; # endif gf_sys_set_args ( argc , ( const char * * ) argv ) ; cfg_file = gf_cfg_init ( the_cfg , NULL ) ; if ( ! cfg_file ) { fprintf ( stderr , \"Error:<S2SV_blank>Configuration<S2SV_blank>File<S2SV_blank>not<S2SV_blank>found\\\\n\" ) ; return 1 ; } if ( gf_log_set_tools_levels ( gf_cfg_get_key ( cfg_file , \"General\" , \"Logs\" ) ) != GF_OK ) { return 1 ; } if ( gf_cfg_get_key ( cfg_file , \"General\" , \"Logs\" ) != NULL ) { logs_set = GF_TRUE ; } if ( ! gui_mode ) { str = gf_cfg_get_key ( cfg_file , \"General\" , \"ForceGUI\" ) ; if ( str && ! strcmp ( str , \"yes\" ) ) gui_mode = 1 ; } for ( i = 1 ; i < ( u32 ) argc ; i ++ ) { char * arg = argv [ i ] ; if ( ! strcmp ( arg , \"-rti\" ) ) { rti_file = argv [ i + 1 ] ; i ++ ; } else if ( ! strcmp ( arg , \"-rtix\" ) ) { rti_file = argv [ i + 1 ] ; i ++ ; use_rtix = GF_TRUE ; } else if ( ! stricmp ( arg , \"-size\" ) ) { if ( sscanf ( argv [ i + 1 ] , \"%dx%d\" , & forced_width , & forced_height ) != 2 ) { forced_width = forced_height = 0 ; } i ++ ; } else if ( ! strcmp ( arg , \"-quiet\" ) ) { be_quiet = 1 ; } else if ( ! strcmp ( arg , \"-strict-error\" ) ) { gf_log_set_strict_error ( 1 ) ; } else if ( ! strcmp ( arg , \"-log-file\" ) || ! strcmp ( arg , \"-lf\" ) ) { logfile = gf_fopen ( argv [ i + 1 ] , \"wt\" ) ; gf_log_set_callback ( logfile , on_gpac_log ) ; i ++ ; } else if ( ! strcmp ( arg , \"-logs\" ) ) { if ( gf_log_set_tools_levels ( argv [ i + 1 ] ) != GF_OK ) { return 1 ; } logs_set = GF_TRUE ; i ++ ; } else if ( ! strcmp ( arg , \"-log-clock\" ) || ! strcmp ( arg , \"-lc\" ) ) { log_time_start = 1 ; } else if ( ! strcmp ( arg , \"-log-utc\" ) || ! strcmp ( arg , \"-lu\" ) ) { log_utc_time = 1 ; } # if defined ( __DARWIN__ ) || defined ( __APPLE__ ) else if ( ! strcmp ( arg , \"-thread\" ) ) threading_flags = 0 ; # else else if ( ! strcmp ( arg , \"-no-thread\" ) ) threading_flags = GF_TERM_NO_DECODER_THREAD | GF_TERM_NO_COMPOSITOR_THREAD | GF_TERM_WINDOW_NO_THREAD ; # endif else if ( ! strcmp ( arg , \"-no-cthread\" ) || ! strcmp ( arg , \"-no-compositor-thread\" ) ) threading_flags |= GF_TERM_NO_COMPOSITOR_THREAD ; else if ( ! strcmp ( arg , \"-no-audio\" ) ) no_audio = 1 ; else if ( ! strcmp ( arg , \"-no-regulation\" ) ) no_regulation = 1 ; else if ( ! strcmp ( arg , \"-fs\" ) ) start_fs = 1 ; else if ( ! strcmp ( arg , \"-opt\" ) ) { set_cfg_option ( argv [ i + 1 ] ) ; i ++ ; } else if ( ! strcmp ( arg , \"-conf\" ) ) { set_cfg_option ( argv [ i + 1 ] ) ; is_cfg_only = GF_TRUE ; i ++ ; } else if ( ! strcmp ( arg , \"-ifce\" ) ) { gf_cfg_set_key ( cfg_file , \"Network\" , \"DefaultMCastInterface\" , argv [ i + 1 ] ) ; i ++ ; } else if ( ! stricmp ( arg , \"-help\" ) ) { PrintUsage ( ) ; return 1 ; } else if ( ! stricmp ( arg , \"-noprog\" ) ) { no_prog = 1 ; gf_set_progress_callback ( NULL , progress_quiet ) ; } else if ( ! stricmp ( arg , \"-no-save\" ) || ! stricmp ( arg , \"--no-save\" ) ) { no_cfg_save = 1 ; } else if ( ! stricmp ( arg , \"-ntp-shift\" ) ) { s32 shift = atoi ( argv [ i + 1 ] ) ; i ++ ; gf_net_set_ntp_shift ( shift ) ; } else if ( ! stricmp ( arg , \"-run-for\" ) ) { simulation_time_in_ms = atoi ( argv [ i + 1 ] ) * 1000 ; if ( ! simulation_time_in_ms ) simulation_time_in_ms = 1 ; i ++ ; } else if ( ! strcmp ( arg , \"-out\" ) ) { out_arg = argv [ i + 1 ] ; i ++ ; } else if ( ! stricmp ( arg , \"-fps\" ) ) { fps = atof ( argv [ i + 1 ] ) ; i ++ ; } else if ( ! strcmp ( arg , \"-avi\" ) || ! strcmp ( arg , \"-sha\" ) ) { dump_mode &= 0xFFFF0000 ; if ( ! strcmp ( arg , \"-sha\" ) ) dump_mode |= DUMP_SHA1 ; else dump_mode |= DUMP_AVI ; if ( ( url_arg || ( i + 2 < ( u32 ) argc ) ) && get_time_list ( argv [ i + 1 ] , times , & nb_times ) ) { if ( ! strcmp ( arg , \"-avi\" ) && ( nb_times != 2 ) ) { fprintf ( stderr , \"Only<S2SV_blank>one<S2SV_blank>time<S2SV_blank>arg<S2SV_blank>found<S2SV_blank>for<S2SV_blank>-avi<S2SV_blank>-<S2SV_blank>check<S2SV_blank>usage\\\\n\" ) ; return 1 ; } i ++ ; } } else if ( ! strcmp ( arg , \"-rgbds\" ) ) { dump_mode |= DUMP_RGB_DEPTH_SHAPE ; } else if ( ! strcmp ( arg , \"-rgbd\" ) ) { dump_mode |= DUMP_RGB_DEPTH ; } else if ( ! strcmp ( arg , \"-depth\" ) ) { dump_mode |= DUMP_DEPTH_ONLY ; } else if ( ! strcmp ( arg , \"-bmp\" ) ) { dump_mode &= 0xFFFF0000 ; dump_mode |= DUMP_BMP ; if ( ( url_arg || ( i + 2 < ( u32 ) argc ) ) && get_time_list ( argv [ i + 1 ] , times , & nb_times ) ) i ++ ; } else if ( ! strcmp ( arg , \"-png\" ) ) { dump_mode &= 0xFFFF0000 ; dump_mode |= DUMP_PNG ; if ( ( url_arg || ( i + 2 < ( u32 ) argc ) ) && get_time_list ( argv [ i + 1 ] , times , & nb_times ) ) i ++ ; } else if ( ! strcmp ( arg , \"-raw\" ) ) { dump_mode &= 0xFFFF0000 ; dump_mode |= DUMP_RAW ; if ( ( url_arg || ( i + 2 < ( u32 ) argc ) ) && get_time_list ( argv [ i + 1 ] , times , & nb_times ) ) i ++ ; } else if ( ! stricmp ( arg , \"-scale\" ) ) { sscanf ( argv [ i + 1 ] , \"%f\" , & scale ) ; i ++ ; } else if ( ! strcmp ( arg , \"-c\" ) || ! strcmp ( arg , \"-cfg\" ) ) { i ++ ; } if ( ! gui_mode ) { if ( arg [ 0 ] != '-' ) { if ( url_arg ) { fprintf ( stderr , \"Several<S2SV_blank>input<S2SV_blank>URLs<S2SV_blank>provided<S2SV_blank>(\\\\\"%s\\\\\",<S2SV_blank>\\\\\"%s\\\\\").<S2SV_blank>Check<S2SV_blank>your<S2SV_blank>command-line.\\\\n\" , url_arg , arg ) ; return 1 ; } url_arg = arg ; } else if ( ! strcmp ( arg , \"-loop\" ) ) loop_at_end = 1 ; else if ( ! strcmp ( arg , \"-bench\" ) ) bench_mode = 1 ; else if ( ! strcmp ( arg , \"-vbench\" ) ) bench_mode = 2 ; else if ( ! strcmp ( arg , \"-sbench\" ) ) bench_mode = 3 ; else if ( ! strcmp ( arg , \"-no-addon\" ) ) enable_add_ons = GF_FALSE ; else if ( ! strcmp ( arg , \"-pause\" ) ) pause_at_first = 1 ; else if ( ! strcmp ( arg , \"-play-from\" ) ) { play_from = atof ( ( const char * ) argv [ i + 1 ] ) ; i ++ ; } else if ( ! strcmp ( arg , \"-speed\" ) ) { playback_speed = FLT2FIX ( atof ( ( const char * ) argv [ i + 1 ] ) ) ; if ( playback_speed <= 0 ) playback_speed = FIX_ONE ; i ++ ; } else if ( ! strcmp ( arg , \"-no-wnd\" ) ) user . init_flags |= GF_TERM_WINDOWLESS ; else if ( ! strcmp ( arg , \"-no-back\" ) ) user . init_flags |= GF_TERM_WINDOW_TRANSPARENT ; else if ( ! strcmp ( arg , \"-align\" ) ) { if ( argv [ i + 1 ] [ 0 ] == 'm' ) align_mode = 1 ; else if ( argv [ i + 1 ] [ 0 ] == 'b' ) align_mode = 2 ; align_mode <<= 8 ; if ( argv [ i + 1 ] [ 1 ] == 'm' ) align_mode |= 1 ; else if ( argv [ i + 1 ] [ 1 ] == 'r' ) align_mode |= 2 ; i ++ ; } else if ( ! strcmp ( arg , \"-fill\" ) ) { fill_ar = GF_TRUE ; } else if ( ! strcmp ( arg , \"-show\" ) ) { visible = 1 ; } else if ( ! strcmp ( arg , \"-uncache\" ) ) { do_uncache = GF_TRUE ; } else if ( ! strcmp ( arg , \"-exit\" ) ) auto_exit = GF_TRUE ; else if ( ! stricmp ( arg , \"-views\" ) ) { views = argv [ i + 1 ] ; i ++ ; } else if ( ! stricmp ( arg , \"-mosaic\" ) ) { mosaic = argv [ i + 1 ] ; i ++ ; } else if ( ! stricmp ( arg , \"-com\" ) ) { has_command = GF_TRUE ; i ++ ; } else if ( ! stricmp ( arg , \"-service\" ) ) { initial_service_id = atoi ( argv [ i + 1 ] ) ; i ++ ; } } } if ( is_cfg_only ) { gf_cfg_del ( cfg_file ) ; fprintf ( stderr , \"GPAC<S2SV_blank>Config<S2SV_blank>updated\\\\n\" ) ; return 0 ; } if ( do_uncache ) { const char * cache_dir = gf_cfg_get_key ( cfg_file , \"General\" , \"CacheDirectory\" ) ; do_flatten_cache ( cache_dir ) ; fprintf ( stderr , \"GPAC<S2SV_blank>Cache<S2SV_blank>dir<S2SV_blank>%s<S2SV_blank>flattened\\\\n\" , cache_dir ) ; gf_cfg_del ( cfg_file ) ; return 0 ; } if ( dump_mode && ! url_arg ) { FILE * test ; url_arg = ( char * ) gf_cfg_get_key ( cfg_file , \"General\" , \"StartupFile\" ) ; test = url_arg ? gf_fopen ( url_arg , \"rt\" ) : NULL ; if ( ! test ) url_arg = NULL ; else gf_fclose ( test ) ; if ( ! url_arg ) { fprintf ( stderr , \"Missing<S2SV_blank>argument<S2SV_blank>for<S2SV_blank>dump\\\\n\" ) ; PrintUsage ( ) ; if ( logfile ) gf_fclose ( logfile ) ; return 1 ; } } if ( ! gui_mode && ! url_arg && ( gf_cfg_get_key ( cfg_file , \"General\" , \"StartupFile\" ) != NULL ) ) { gui_mode = 1 ; } # ifdef WIN32 if ( gui_mode == 1 ) { const char * opt ; TCHAR buffer [ 1024 ] ; DWORD res = GetCurrentDirectory ( 1024 , buffer ) ; buffer [ res ] = 0 ; opt = gf_cfg_get_key ( cfg_file , \"General\" , \"ModulesDirectory\" ) ; if ( strstr ( opt , buffer ) ) { gui_mode = 1 ; } else { gui_mode = 2 ; } } # endif if ( gui_mode == 1 ) { hide_shell ( 1 ) ; } if ( gui_mode ) { no_prog = 1 ; gf_set_progress_callback ( NULL , progress_quiet ) ; } if ( ! url_arg && simulation_time_in_ms ) simulation_time_in_ms += gf_sys_clock ( ) ; # if defined ( __DARWIN__ ) || defined ( __APPLE__ ) carbon_init ( ) ; # endif if ( dump_mode ) rti_file = NULL ; if ( ! logs_set ) { gf_log_set_tool_level ( GF_LOG_ALL , GF_LOG_WARNING ) ; } if ( rti_file || logfile || log_utc_time || log_time_start ) gf_log_set_callback ( NULL , on_gpac_log ) ; if ( rti_file ) init_rti_logs ( rti_file , url_arg , use_rtix ) ; { GF_SystemRTInfo rti ; if ( gf_sys_get_rti ( 0 , & rti , 0 ) ) fprintf ( stderr , \"System<S2SV_blank>info:<S2SV_blank>%d<S2SV_blank>MB<S2SV_blank>RAM<S2SV_blank>-<S2SV_blank>%d<S2SV_blank>cores\\\\n\" , ( u32 ) ( rti . physical_memory / 1024 / 1024 ) , rti . nb_cores ) ; } if ( dump_mode ) { user . init_flags |= GF_TERM_NO_DECODER_THREAD | GF_TERM_NO_COMPOSITOR_THREAD | GF_TERM_NO_REGULATION ; if ( ! visible ) user . init_flags |= GF_TERM_INIT_HIDE ; gf_cfg_set_key ( cfg_file , \"Audio\" , \"DriverName\" , \"Raw<S2SV_blank>Audio<S2SV_blank>Output\" ) ; no_cfg_save = GF_TRUE ; } else { init_w = forced_width ; init_h = forced_height ; } user . modules = gf_modules_new ( NULL , cfg_file ) ; if ( user . modules ) i = gf_modules_get_count ( user . modules ) ; if ( ! i || ! user . modules ) { fprintf ( stderr , \"Error:<S2SV_blank>no<S2SV_blank>modules<S2SV_blank>found<S2SV_blank>-<S2SV_blank>exiting\\\\n\" ) ; if ( user . modules ) gf_modules_del ( user . modules ) ; gf_cfg_del ( cfg_file ) ; gf_sys_close ( ) ; if ( logfile ) gf_fclose ( logfile ) ; return 1 ; } fprintf ( stderr , \"Modules<S2SV_blank>Found<S2SV_blank>:<S2SV_blank>%d<S2SV_blank>\\\\n\" , i ) ; str = gf_cfg_get_key ( cfg_file , \"General\" , \"GPACVersion\" ) ; if ( ! str || strcmp ( str , GPAC_FULL_VERSION ) ) { gf_cfg_del_section ( cfg_file , \"PluginsCache\" ) ; gf_cfg_set_key ( cfg_file , \"General\" , \"GPACVersion\" , GPAC_FULL_VERSION ) ; } user . config = cfg_file ; user . EventProc = GPAC_EventProc ; user . opaque = user . modules ; if ( threading_flags ) user . init_flags |= threading_flags ; if ( no_audio ) user . init_flags |= GF_TERM_NO_AUDIO ; if ( no_regulation ) user . init_flags |= GF_TERM_NO_REGULATION ; if ( threading_flags & ( GF_TERM_NO_DECODER_THREAD | GF_TERM_NO_COMPOSITOR_THREAD ) ) term_step = GF_TRUE ; if ( dump_mode ) user . init_flags |= GF_TERM_USE_AUDIO_HW_CLOCK ; if ( bench_mode ) { gf_cfg_discard_changes ( user . config ) ; auto_exit = GF_TRUE ; gf_cfg_set_key ( user . config , \"Audio\" , \"DriverName\" , \"Raw<S2SV_blank>Audio<S2SV_blank>Output\" ) ; if ( bench_mode != 2 ) { gf_cfg_set_key ( user . config , \"Video\" , \"DriverName\" , \"Raw<S2SV_blank>Video<S2SV_blank>Output\" ) ; gf_cfg_set_key ( user . config , \"RAWVideo\" , \"RawOutput\" , \"null\" ) ; gf_cfg_set_key ( user . config , \"Compositor\" , \"OpenGLMode\" , \"disable\" ) ; } else { gf_cfg_set_key ( user . config , \"Video\" , \"DisableVSync\" , \"yes\" ) ; } } { char dim [ 50 ] ; sprintf ( dim , \"%d\" , forced_width ) ; gf_cfg_set_key ( user . config , \"Compositor\" , \"DefaultWidth\" , forced_width ? dim : NULL ) ; sprintf ( dim , \"%d\" , forced_height ) ; gf_cfg_set_key ( user . config , \"Compositor\" , \"DefaultHeight\" , forced_height ? dim : NULL ) ; } fprintf ( stderr , \"Loading<S2SV_blank>GPAC<S2SV_blank>Terminal\\\\n\" ) ; i = gf_sys_clock ( ) ; term = gf_term_new ( & user ) ; if ( ! term ) { fprintf ( stderr , \"\\\\nInit<S2SV_blank>error<S2SV_blank>-<S2SV_blank>check<S2SV_blank>you<S2SV_blank>have<S2SV_blank>at<S2SV_blank>least<S2SV_blank>one<S2SV_blank>video<S2SV_blank>out<S2SV_blank>and<S2SV_blank>one<S2SV_blank>rasterizer...\\\\nFound<S2SV_blank>modules:\\\\n\" ) ; list_modules ( user . modules ) ; gf_modules_del ( user . modules ) ; gf_cfg_discard_changes ( cfg_file ) ; gf_cfg_del ( cfg_file ) ; gf_sys_close ( ) ; if ( logfile ) gf_fclose ( logfile ) ; return 1 ; } fprintf ( stderr , \"Terminal<S2SV_blank>Loaded<S2SV_blank>in<S2SV_blank>%d<S2SV_blank>ms\\\\n\" , gf_sys_clock ( ) - i ) ; if ( bench_mode ) { display_rti = 2 ; gf_term_set_option ( term , GF_OPT_VIDEO_BENCH , ( bench_mode == 3 ) ? 2 : 1 ) ; if ( bench_mode == 1 ) bench_mode = 2 ; } if ( dump_mode ) { if ( fill_ar ) gf_term_set_option ( term , GF_OPT_ASPECT_RATIO , GF_ASPECT_RATIO_FILL_SCREEN ) ; } else { str = gf_cfg_get_key ( cfg_file , \"Video\" , \"DriverName\" ) ; if ( ! bench_mode && ! strcmp ( str , \"Raw<S2SV_blank>Video<S2SV_blank>Output\" ) ) fprintf ( stderr , \"WARNING:<S2SV_blank>using<S2SV_blank>raw<S2SV_blank>output<S2SV_blank>video<S2SV_blank>(memory<S2SV_blank>only)<S2SV_blank>-<S2SV_blank>no<S2SV_blank>display<S2SV_blank>used\\\\n\" ) ; str = gf_cfg_get_key ( cfg_file , \"Audio\" , \"DriverName\" ) ; if ( ! str || ! strcmp ( str , \"No<S2SV_blank>Audio<S2SV_blank>Output<S2SV_blank>Available\" ) ) fprintf ( stderr , \"WARNING:<S2SV_blank>no<S2SV_blank>audio<S2SV_blank>output<S2SV_blank>available<S2SV_blank>-<S2SV_blank>make<S2SV_blank>sure<S2SV_blank>no<S2SV_blank>other<S2SV_blank>program<S2SV_blank>is<S2SV_blank>locking<S2SV_blank>the<S2SV_blank>sound<S2SV_blank>card\\\\n\" ) ; str = gf_cfg_get_key ( cfg_file , \"General\" , \"NoMIMETypeFetch\" ) ; no_mime_check = ( str && ! stricmp ( str , \"yes\" ) ) ? 1 : 0 ; } str = gf_cfg_get_key ( cfg_file , \"HTTPProxy\" , \"Enabled\" ) ; if ( str && ! strcmp ( str , \"yes\" ) ) { str = gf_cfg_get_key ( cfg_file , \"HTTPProxy\" , \"Name\" ) ; if ( str ) fprintf ( stderr , \"HTTP<S2SV_blank>Proxy<S2SV_blank>%s<S2SV_blank>enabled\\\\n\" , str ) ; } if ( rti_file ) { str = gf_cfg_get_key ( cfg_file , \"General\" , \"RTIRefreshPeriod\" ) ; if ( str ) { rti_update_time_ms = atoi ( str ) ; } else { gf_cfg_set_key ( cfg_file , \"General\" , \"RTIRefreshPeriod\" , \"200\" ) ; } UpdateRTInfo ( \"At<S2SV_blank>GPAC<S2SV_blank>load<S2SV_blank>time\\\\n\" ) ; } Run = 1 ; if ( dump_mode ) { if ( ! nb_times ) { times [ 0 ] = 0 ; nb_times ++ ; } ret_val = dump_file ( url_arg , out_arg , dump_mode , fps , forced_width , forced_height , scale , times , nb_times ) ; Run = 0 ; } else if ( views ) { } else if ( ! gui_mode && url_arg ) { char * ext ; if ( strlen ( url_arg ) >= sizeof ( the_url ) ) { fprintf ( stderr , \"Input<S2SV_blank>url<S2SV_blank>%s<S2SV_blank>is<S2SV_blank>too<S2SV_blank>long,<S2SV_blank>truncating<S2SV_blank>to<S2SV_blank>%d<S2SV_blank>chars.\\\\n\" , url_arg , ( int ) ( sizeof ( the_url ) - 1 ) ) ; strncpy ( the_url , url_arg , sizeof ( the_url ) - 1 ) ; the_url [ sizeof ( the_url ) - 1 ] = 0 ; } else { strcpy ( the_url , url_arg ) ; } ext = strrchr ( the_url , '.' ) ; if ( ext && ( ! stricmp ( ext , \".m3u\" ) || ! stricmp ( ext , \".pls\" ) ) ) { GF_Err e = GF_OK ; fprintf ( stderr , \"Opening<S2SV_blank>Playlist<S2SV_blank>%s\\\\n\" , the_url ) ; strcpy ( pl_path , the_url ) ; if ( ! strncmp ( \"http:\" , the_url , 5 ) ) { GF_DownloadSession * sess = gf_dm_sess_new ( term -> downloader , the_url , GF_NETIO_SESSION_NOT_THREADED , NULL , NULL , & e ) ; if ( sess ) { e = gf_dm_sess_process ( sess ) ; if ( ! e ) { strncpy ( the_url , gf_dm_sess_get_cache_name ( sess ) , sizeof ( the_url ) - 1 ) ; <S2SV_StartBug> the_url [ sizeof ( the_cfg ) - 1 ] = 0 ; <S2SV_EndBug> } gf_dm_sess_del ( sess ) ; } } playlist = e ? NULL : gf_fopen ( the_url , \"rt\" ) ; readonly_playlist = 1 ; if ( playlist ) { request_next_playlist_item = GF_TRUE ; } else { if ( e ) fprintf ( stderr , \"Failed<S2SV_blank>to<S2SV_blank>open<S2SV_blank>playlist<S2SV_blank>%s:<S2SV_blank>%s\\\\n\" , the_url , gf_error_to_string ( e ) ) ; fprintf ( stderr , \"Hit<S2SV_blank>\\'h\\'<S2SV_blank>for<S2SV_blank>help\\\\n\\\\n\" ) ; } } else { fprintf ( stderr , \"Opening<S2SV_blank>URL<S2SV_blank>%s\\\\n\" , the_url ) ; if ( pause_at_first ) fprintf ( stderr , \"[Status:<S2SV_blank>Paused]\\\\n\" ) ; gf_term_connect_from_time ( term , the_url , ( u64 ) ( play_from * 1000 ) , pause_at_first ) ; } } else { fprintf ( stderr , \"Hit<S2SV_blank>\\'h\\'<S2SV_blank>for<S2SV_blank>help\\\\n\\\\n\" ) ; str = gf_cfg_get_key ( cfg_file , \"General\" , \"StartupFile\" ) ; if ( str ) { strncpy ( the_url , \"MP4Client<S2SV_blank>\" GPAC_FULL_VERSION , sizeof ( the_url ) - 1 ) ; the_url [ sizeof ( the_url ) - 1 ] = 0 ; gf_term_connect ( term , str ) ; startup_file = 1 ; is_connected = 1 ; } } if ( gui_mode == 2 ) gui_mode = 0 ; if ( start_fs ) gf_term_set_option ( term , GF_OPT_FULLSCREEN , 1 ) ; if ( views ) { char szTemp [ 4046 ] ; sprintf ( szTemp , \"views://%s\" , views ) ; gf_term_connect ( term , szTemp ) ; } if ( mosaic ) { char szTemp [ 4046 ] ; sprintf ( szTemp , \"mosaic://%s\" , mosaic ) ; gf_term_connect ( term , szTemp ) ; } if ( bench_mode ) { rti_update_time_ms = 500 ; bench_mode_start = gf_sys_clock ( ) ; } while ( Run ) { if ( ( gui_mode == 1 ) || ! gf_prompt_has_input ( ) ) { if ( reload ) { reload = 0 ; gf_term_disconnect ( term ) ; gf_term_connect ( term , startup_file ? gf_cfg_get_key ( cfg_file , \"General\" , \"StartupFile\" ) : the_url ) ; } if ( restart && gf_term_get_option ( term , GF_OPT_IS_OVER ) ) { restart = 0 ; gf_term_play_from_time ( term , 0 , 0 ) ; } if ( request_next_playlist_item ) { c = '\\\\n' ; request_next_playlist_item = 0 ; goto force_input ; } if ( has_command && is_connected ) { has_command = GF_FALSE ; for ( i = 0 ; i < ( u32 ) argc ; i ++ ) { if ( ! strcmp ( argv [ i ] , \"-com\" ) ) { gf_term_scene_update ( term , NULL , argv [ i + 1 ] ) ; i ++ ; } } } if ( initial_service_id && is_connected ) { GF_ObjectManager * root_od = gf_term_get_root_object ( term ) ; if ( root_od ) { gf_term_select_service ( term , root_od , initial_service_id ) ; initial_service_id = 0 ; } } if ( ! use_rtix || display_rti ) UpdateRTInfo ( NULL ) ; if ( term_step ) { gf_term_process_step ( term ) ; } else { gf_sleep ( rti_update_time_ms ) ; } if ( auto_exit && eos_seen && gf_term_get_option ( term , GF_OPT_IS_OVER ) ) { Run = GF_FALSE ; } if ( simulation_time_in_ms && ( ( gf_term_get_elapsed_time_in_ms ( term ) > simulation_time_in_ms ) || ( ! url_arg && gf_sys_clock ( ) > simulation_time_in_ms ) ) ) { Run = GF_FALSE ; } continue ; } c = gf_prompt_get_char ( ) ; force_input : switch ( c ) { case 'q' : { GF_Event evt ; memset ( & evt , 0 , sizeof ( GF_Event ) ) ; evt . type = GF_EVENT_QUIT ; gf_term_send_event ( term , & evt ) ; } break ; case 'X' : exit ( 0 ) ; break ; case 'Q' : break ; case 'o' : startup_file = 0 ; gf_term_disconnect ( term ) ; fprintf ( stderr , \"Enter<S2SV_blank>the<S2SV_blank>absolute<S2SV_blank>URL\\\\n\" ) ; if ( 1 > scanf ( \"%s\" , the_url ) ) { fprintf ( stderr , \"Cannot<S2SV_blank>read<S2SV_blank>absolute<S2SV_blank>URL,<S2SV_blank>aborting\\\\n\" ) ; break ; } if ( rti_file ) init_rti_logs ( rti_file , the_url , use_rtix ) ; gf_term_connect ( term , the_url ) ; break ; case 'O' : gf_term_disconnect ( term ) ; fprintf ( stderr , \"Enter<S2SV_blank>the<S2SV_blank>absolute<S2SV_blank>URL<S2SV_blank>to<S2SV_blank>the<S2SV_blank>playlist\\\\n\" ) ; if ( 1 > scanf ( \"%s\" , the_url ) ) { fprintf ( stderr , \"Cannot<S2SV_blank>read<S2SV_blank>the<S2SV_blank>absolute<S2SV_blank>URL,<S2SV_blank>aborting.\\\\n\" ) ; break ; } playlist = gf_fopen ( the_url , \"rt\" ) ; if ( playlist ) { if ( 1 > fscanf ( playlist , \"%s\" , the_url ) ) { fprintf ( stderr , \"Cannot<S2SV_blank>read<S2SV_blank>any<S2SV_blank>URL<S2SV_blank>from<S2SV_blank>playlist,<S2SV_blank>aborting.\\\\n\" ) ; gf_fclose ( playlist ) ; break ; } fprintf ( stderr , \"Opening<S2SV_blank>URL<S2SV_blank>%s\\\\n\" , the_url ) ; gf_term_connect ( term , the_url ) ; } break ; case '\\\\n' : case 'N' : if ( playlist ) { int res ; gf_term_disconnect ( term ) ; res = fscanf ( playlist , \"%s\" , the_url ) ; if ( ( res == EOF ) && loop_at_end ) { fseek ( playlist , 0 , SEEK_SET ) ; res = fscanf ( playlist , \"%s\" , the_url ) ; } if ( res == EOF ) { fprintf ( stderr , \"No<S2SV_blank>more<S2SV_blank>items<S2SV_blank>-<S2SV_blank>exiting\\\\n\" ) ; Run = 0 ; } else if ( the_url [ 0 ] == '#' ) { request_next_playlist_item = GF_TRUE ; } else { fprintf ( stderr , \"Opening<S2SV_blank>URL<S2SV_blank>%s\\\\n\" , the_url ) ; gf_term_connect_with_path ( term , the_url , pl_path ) ; } } break ; case 'P' : if ( playlist ) { u32 count ; gf_term_disconnect ( term ) ; if ( 1 > scanf ( \"%u\" , & count ) ) { fprintf ( stderr , \"Cannot<S2SV_blank>read<S2SV_blank>number,<S2SV_blank>aborting.\\\\n\" ) ; break ; } while ( count ) { if ( fscanf ( playlist , \"%s\" , the_url ) ) { fprintf ( stderr , \"Failed<S2SV_blank>to<S2SV_blank>read<S2SV_blank>line,<S2SV_blank>aborting\\\\n\" ) ; break ; } count -- ; } fprintf ( stderr , \"Opening<S2SV_blank>URL<S2SV_blank>%s\\\\n\" , the_url ) ; gf_term_connect ( term , the_url ) ; } break ; case 'r' : if ( is_connected ) reload = 1 ; break ; case 'D' : if ( is_connected ) gf_term_disconnect ( term ) ; break ; case 'p' : if ( is_connected ) { Bool is_pause = gf_term_get_option ( term , GF_OPT_PLAY_STATE ) ; fprintf ( stderr , \"[Status:<S2SV_blank>%s]\\\\n\" , is_pause ? \"Playing\" : \"Paused\" ) ; gf_term_set_option ( term , GF_OPT_PLAY_STATE , is_pause ? GF_STATE_PLAYING : GF_STATE_PAUSED ) ; } break ; case 's' : if ( is_connected ) { gf_term_set_option ( term , GF_OPT_PLAY_STATE , GF_STATE_STEP_PAUSE ) ; fprintf ( stderr , \"Step<S2SV_blank>time:<S2SV_blank>\" ) ; PrintTime ( gf_term_get_time_in_ms ( term ) ) ; fprintf ( stderr , \"\\\\n\" ) ; } break ; case 'z' : case 'T' : if ( ! CanSeek || ( Duration <= 2000 ) ) { fprintf ( stderr , \"scene<S2SV_blank>not<S2SV_blank>seekable\\\\n\" ) ; } else { Double res ; s32 seekTo ; fprintf ( stderr , \"Duration:<S2SV_blank>\" ) ; PrintTime ( Duration ) ; res = gf_term_get_time_in_ms ( term ) ; if ( c == 'z' ) { res *= 100 ; res /= ( s64 ) Duration ; fprintf ( stderr , \"<S2SV_blank>(current<S2SV_blank>%.2f<S2SV_blank>%%)\\\\nEnter<S2SV_blank>Seek<S2SV_blank>percentage:\\\\n\" , res ) ; if ( scanf ( \"%d\" , & seekTo ) == 1 ) { if ( seekTo > 100 ) seekTo = 100 ; res = ( Double ) ( s64 ) Duration ; res /= 100 ; res *= seekTo ; gf_term_play_from_time ( term , ( u64 ) ( s64 ) res , 0 ) ; } } else { u32 r , h , m , s ; fprintf ( stderr , \"<S2SV_blank>-<S2SV_blank>Current<S2SV_blank>Time:<S2SV_blank>\" ) ; PrintTime ( ( u64 ) res ) ; fprintf ( stderr , \"\\\\nEnter<S2SV_blank>seek<S2SV_blank>time<S2SV_blank>(Format:<S2SV_blank>s,<S2SV_blank>m:s<S2SV_blank>or<S2SV_blank>h:m:s):\\\\n\" ) ; h = m = s = 0 ; r = scanf ( \"%d:%d:%d\" , & h , & m , & s ) ; if ( r == 2 ) { s = m ; m = h ; h = 0 ; } else if ( r == 1 ) { s = h ; m = h = 0 ; } if ( r && ( r <= 3 ) ) { u64 time = h * 3600 + m * 60 + s ; gf_term_play_from_time ( term , time * 1000 , 0 ) ; } } } break ; case 't' : { if ( is_connected ) { fprintf ( stderr , \"Current<S2SV_blank>Time:<S2SV_blank>\" ) ; PrintTime ( gf_term_get_time_in_ms ( term ) ) ; fprintf ( stderr , \"<S2SV_blank>-<S2SV_blank>Duration:<S2SV_blank>\" ) ; PrintTime ( Duration ) ; fprintf ( stderr , \"\\\\n\" ) ; } } break ; case 'w' : if ( is_connected ) PrintWorldInfo ( term ) ; break ; case 'v' : if ( is_connected ) PrintODList ( term , NULL , 0 , 0 , \"Root\" ) ; break ; case 'i' : if ( is_connected ) { u32 ID ; fprintf ( stderr , \"Enter<S2SV_blank>OD<S2SV_blank>ID<S2SV_blank>(0<S2SV_blank>for<S2SV_blank>main<S2SV_blank>OD):<S2SV_blank>\" ) ; fflush ( stderr ) ; if ( scanf ( \"%ud\" , & ID ) == 1 ) { ViewOD ( term , ID , ( u32 ) - 1 , NULL ) ; } else { char str_url [ GF_MAX_PATH ] ; if ( scanf ( \"%s\" , str_url ) == 1 ) ViewOD ( term , 0 , ( u32 ) - 1 , str_url ) ; } } break ; case 'j' : if ( is_connected ) { u32 num ; do { fprintf ( stderr , \"Enter<S2SV_blank>OD<S2SV_blank>number<S2SV_blank>(0<S2SV_blank>for<S2SV_blank>main<S2SV_blank>OD):<S2SV_blank>\" ) ; fflush ( stderr ) ; } while ( 1 > scanf ( \"%ud\" , & num ) ) ; ViewOD ( term , ( u32 ) - 1 , num , NULL ) ; } break ; case 'b' : if ( is_connected ) ViewODs ( term , 1 ) ; break ; case 'm' : if ( is_connected ) ViewODs ( term , 0 ) ; break ; case 'l' : list_modules ( user . modules ) ; break ; case 'n' : if ( is_connected ) set_navigation ( ) ; break ; case 'x' : if ( is_connected ) gf_term_set_option ( term , GF_OPT_NAVIGATION_TYPE , 0 ) ; break ; case 'd' : if ( is_connected ) { GF_ObjectManager * odm = NULL ; char radname [ GF_MAX_PATH ] , * sExt ; GF_Err e ; u32 i , count , odid ; Bool xml_dump , std_out ; radname [ 0 ] = 0 ; do { fprintf ( stderr , \"Enter<S2SV_blank>Inline<S2SV_blank>OD<S2SV_blank>ID<S2SV_blank>if<S2SV_blank>any<S2SV_blank>or<S2SV_blank>0<S2SV_blank>:<S2SV_blank>\" ) ; fflush ( stderr ) ; } while ( 1 > scanf ( \"%ud\" , & odid ) ) ; if ( odid ) { GF_ObjectManager * root_odm = gf_term_get_root_object ( term ) ; if ( ! root_odm ) break ; count = gf_term_get_object_count ( term , root_odm ) ; for ( i = 0 ; i < count ; i ++ ) { GF_MediaInfo info ; odm = gf_term_get_object ( term , root_odm , i ) ; if ( gf_term_get_object_info ( term , odm , & info ) == GF_OK ) { if ( info . od -> objectDescriptorID == odid ) break ; } odm = NULL ; } } do { fprintf ( stderr , \"Enter<S2SV_blank>file<S2SV_blank>radical<S2SV_blank>name<S2SV_blank>(+\\\\\\'.x\\\\\\'<S2SV_blank>for<S2SV_blank>XML<S2SV_blank>dumping)<S2SV_blank>-<S2SV_blank>\\\\\"std\\\\\"<S2SV_blank>for<S2SV_blank>stderr:<S2SV_blank>\" ) ; fflush ( stderr ) ; } while ( 1 > scanf ( \"%s\" , radname ) ) ; sExt = strrchr ( radname , '.' ) ; xml_dump = 0 ; if ( sExt ) { if ( ! stricmp ( sExt , \".x\" ) ) xml_dump = 1 ; sExt [ 0 ] = 0 ; } std_out = strnicmp ( radname , \"std\" , 3 ) ? 0 : 1 ; e = gf_term_dump_scene ( term , std_out ? NULL : radname , NULL , xml_dump , 0 , odm ) ; fprintf ( stderr , \"Dump<S2SV_blank>done<S2SV_blank>(%s)\\\\n\" , gf_error_to_string ( e ) ) ; } break ; case 'c' : PrintGPACConfig ( ) ; break ; case '3' : { Bool use_3d = ! gf_term_get_option ( term , GF_OPT_USE_OPENGL ) ; if ( gf_term_set_option ( term , GF_OPT_USE_OPENGL , use_3d ) == GF_OK ) { fprintf ( stderr , \"Using<S2SV_blank>%s<S2SV_blank>for<S2SV_blank>2D<S2SV_blank>drawing\\\\n\" , use_3d ? \"OpenGL\" : \"2D<S2SV_blank>rasterizer\" ) ; } } break ; case 'k' : { Bool opt = gf_term_get_option ( term , GF_OPT_STRESS_MODE ) ; opt = ! opt ; fprintf ( stderr , \"Turning<S2SV_blank>stress<S2SV_blank>mode<S2SV_blank>%s\\\\n\" , opt ? \"on\" : \"off\" ) ; gf_term_set_option ( term , GF_OPT_STRESS_MODE , opt ) ; } break ; case '4' : gf_term_set_option ( term , GF_OPT_ASPECT_RATIO , GF_ASPECT_RATIO_4_3 ) ; break ; case '5' : gf_term_set_option ( term , GF_OPT_ASPECT_RATIO , GF_ASPECT_RATIO_16_9 ) ; break ; case '6' : gf_term_set_option ( term , GF_OPT_ASPECT_RATIO , GF_ASPECT_RATIO_FILL_SCREEN ) ; break ; case '7' : gf_term_set_option ( term , GF_OPT_ASPECT_RATIO , GF_ASPECT_RATIO_KEEP ) ; break ; case 'C' : switch ( gf_term_get_option ( term , GF_OPT_MEDIA_CACHE ) ) { case GF_MEDIA_CACHE_DISABLED : gf_term_set_option ( term , GF_OPT_MEDIA_CACHE , GF_MEDIA_CACHE_ENABLED ) ; break ; case GF_MEDIA_CACHE_ENABLED : gf_term_set_option ( term , GF_OPT_MEDIA_CACHE , GF_MEDIA_CACHE_DISABLED ) ; break ; case GF_MEDIA_CACHE_RUNNING : fprintf ( stderr , \"Streaming<S2SV_blank>Cache<S2SV_blank>is<S2SV_blank>running<S2SV_blank>-<S2SV_blank>please<S2SV_blank>stop<S2SV_blank>it<S2SV_blank>first\\\\n\" ) ; continue ; } switch ( gf_term_get_option ( term , GF_OPT_MEDIA_CACHE ) ) { case GF_MEDIA_CACHE_ENABLED : fprintf ( stderr , \"Streaming<S2SV_blank>Cache<S2SV_blank>Enabled\\\\n\" ) ; break ; case GF_MEDIA_CACHE_DISABLED : fprintf ( stderr , \"Streaming<S2SV_blank>Cache<S2SV_blank>Disabled\\\\n\" ) ; break ; case GF_MEDIA_CACHE_RUNNING : fprintf ( stderr , \"Streaming<S2SV_blank>Cache<S2SV_blank>Running\\\\n\" ) ; break ; } break ; case 'S' : case 'A' : if ( gf_term_get_option ( term , GF_OPT_MEDIA_CACHE ) == GF_MEDIA_CACHE_RUNNING ) { gf_term_set_option ( term , GF_OPT_MEDIA_CACHE , ( c == 'S' ) ? GF_MEDIA_CACHE_DISABLED : GF_MEDIA_CACHE_DISCARD ) ; fprintf ( stderr , \"Streaming<S2SV_blank>Cache<S2SV_blank>stopped\\\\n\" ) ; } else { fprintf ( stderr , \"Streaming<S2SV_blank>Cache<S2SV_blank>not<S2SV_blank>running\\\\n\" ) ; } break ; case 'R' : display_rti = ! display_rti ; ResetCaption ( ) ; break ; case 'F' : if ( display_rti ) display_rti = 0 ; else display_rti = 2 ; ResetCaption ( ) ; break ; case 'u' : { GF_Err e ; char szCom [ 8192 ] ; fprintf ( stderr , \"Enter<S2SV_blank>command<S2SV_blank>to<S2SV_blank>send:\\\\n\" ) ; fflush ( stdin ) ; szCom [ 0 ] = 0 ; if ( 1 > scanf ( \"%[^\\\\t\\\\n]\" , szCom ) ) { fprintf ( stderr , \"Cannot<S2SV_blank>read<S2SV_blank>command<S2SV_blank>to<S2SV_blank>send,<S2SV_blank>aborting.\\\\n\" ) ; break ; } e = gf_term_scene_update ( term , NULL , szCom ) ; if ( e ) fprintf ( stderr , \"Processing<S2SV_blank>command<S2SV_blank>failed:<S2SV_blank>%s\\\\n\" , gf_error_to_string ( e ) ) ; } break ; case 'e' : { GF_Err e ; char jsCode [ 8192 ] ; fprintf ( stderr , \"Enter<S2SV_blank>JavaScript<S2SV_blank>code<S2SV_blank>to<S2SV_blank>evaluate:\\\\n\" ) ; fflush ( stdin ) ; jsCode [ 0 ] = 0 ; if ( 1 > scanf ( \"%[^\\\\t\\\\n]\" , jsCode ) ) { fprintf ( stderr , \"Cannot<S2SV_blank>read<S2SV_blank>code<S2SV_blank>to<S2SV_blank>evaluate,<S2SV_blank>aborting.\\\\n\" ) ; break ; } e = gf_term_scene_update ( term , \"application/ecmascript\" , jsCode ) ; if ( e ) fprintf ( stderr , \"Processing<S2SV_blank>JS<S2SV_blank>code<S2SV_blank>failed:<S2SV_blank>%s\\\\n\" , gf_error_to_string ( e ) ) ; } break ; case 'L' : { char szLog [ 1024 ] , * cur_logs ; cur_logs = gf_log_get_tools_levels ( ) ; fprintf ( stderr , \"Enter<S2SV_blank>new<S2SV_blank>log<S2SV_blank>level<S2SV_blank>(current<S2SV_blank>tools<S2SV_blank>%s):\\\\n\" , cur_logs ) ; gf_free ( cur_logs ) ; if ( scanf ( \"%s\" , szLog ) < 1 ) { fprintf ( stderr , \"Cannot<S2SV_blank>read<S2SV_blank>new<S2SV_blank>log<S2SV_blank>level,<S2SV_blank>aborting.\\\\n\" ) ; break ; } gf_log_modify_tools_levels ( szLog ) ; } break ; case 'g' : { GF_SystemRTInfo rti ; gf_sys_get_rti ( rti_update_time_ms , & rti , 0 ) ; fprintf ( stderr , \"GPAC<S2SV_blank>allocated<S2SV_blank>memory<S2SV_blank>\" LLD \"\\\\n\" , rti . gpac_memory ) ; } break ; case 'M' : { u32 size ; do { fprintf ( stderr , \"Enter<S2SV_blank>new<S2SV_blank>video<S2SV_blank>cache<S2SV_blank>memory<S2SV_blank>in<S2SV_blank>kBytes<S2SV_blank>(current<S2SV_blank>%ud):\\\\n\" , gf_term_get_option ( term , GF_OPT_VIDEO_CACHE_SIZE ) ) ; } while ( 1 > scanf ( \"%ud\" , & size ) ) ; gf_term_set_option ( term , GF_OPT_VIDEO_CACHE_SIZE , size ) ; } break ; case 'H' : { u32 http_bitrate = gf_term_get_option ( term , GF_OPT_HTTP_MAX_RATE ) ; do { fprintf ( stderr , \"Enter<S2SV_blank>new<S2SV_blank>http<S2SV_blank>bitrate<S2SV_blank>in<S2SV_blank>bps<S2SV_blank>(0<S2SV_blank>for<S2SV_blank>none)<S2SV_blank>-<S2SV_blank>current<S2SV_blank>limit:<S2SV_blank>%d\\\\n\" , http_bitrate ) ; } while ( 1 > scanf ( \"%ud\" , & http_bitrate ) ) ; gf_term_set_option ( term , GF_OPT_HTTP_MAX_RATE , http_bitrate ) ; } break ; case 'E' : gf_term_set_option ( term , GF_OPT_RELOAD_CONFIG , 1 ) ; break ; case 'B' : switch_bench ( ! bench_mode ) ; break ; case 'Y' : { char szOpt [ 8192 ] ; fprintf ( stderr , \"Enter<S2SV_blank>option<S2SV_blank>to<S2SV_blank>set<S2SV_blank>(Section:Name=Value):\\\\n\" ) ; fflush ( stdin ) ; szOpt [ 0 ] = 0 ; if ( 1 > scanf ( \"%[^\\\\t\\\\n]\" , szOpt ) ) { fprintf ( stderr , \"Cannot<S2SV_blank>read<S2SV_blank>option\\\\n\" ) ; break ; } set_cfg_option ( szOpt ) ; } break ; case 'Z' : { char szFileName [ 100 ] ; u32 nb_pass , nb_views , offscreen_view = 0 ; GF_VideoSurface fb ; GF_Err e ; nb_pass = 1 ; nb_views = gf_term_get_option ( term , GF_OPT_NUM_STEREO_VIEWS ) ; if ( nb_views > 1 ) { fprintf ( stderr , \"Auto-stereo<S2SV_blank>mode<S2SV_blank>detected<S2SV_blank>-<S2SV_blank>type<S2SV_blank>number<S2SV_blank>of<S2SV_blank>view<S2SV_blank>to<S2SV_blank>dump<S2SV_blank>(0<S2SV_blank>is<S2SV_blank>main<S2SV_blank>output,<S2SV_blank>1<S2SV_blank>to<S2SV_blank>%d<S2SV_blank>offscreen<S2SV_blank>view,<S2SV_blank>%d<S2SV_blank>for<S2SV_blank>all<S2SV_blank>offscreen,<S2SV_blank>%d<S2SV_blank>for<S2SV_blank>all<S2SV_blank>offscreen<S2SV_blank>and<S2SV_blank>main)\\\\n\" , nb_views , nb_views + 1 , nb_views + 2 ) ; if ( scanf ( \"%d\" , & offscreen_view ) != 1 ) { offscreen_view = 0 ; } if ( offscreen_view == nb_views + 1 ) { offscreen_view = 1 ; nb_pass = nb_views ; } else if ( offscreen_view == nb_views + 2 ) { offscreen_view = 0 ; nb_pass = nb_views + 1 ; } } while ( nb_pass ) { nb_pass -- ; if ( offscreen_view ) { sprintf ( szFileName , \"view%d_dump.png\" , offscreen_view ) ; e = gf_term_get_offscreen_buffer ( term , & fb , offscreen_view - 1 , 0 ) ; } else { sprintf ( szFileName , \"gpac_video_dump_\" LLU \".png\" , gf_net_get_utc ( ) ) ; e = gf_term_get_screen_buffer ( term , & fb ) ; } offscreen_view ++ ; if ( e ) { fprintf ( stderr , \"Error<S2SV_blank>dumping<S2SV_blank>screen<S2SV_blank>buffer<S2SV_blank>%s\\\\n\" , gf_error_to_string ( e ) ) ; nb_pass = 0 ; } else { # ifndef GPAC_DISABLE_AV_PARSERS u32 dst_size = fb . width * fb . height * 4 ; char * dst = ( char * ) gf_malloc ( sizeof ( char ) * dst_size ) ; e = gf_img_png_enc ( fb . video_buffer , fb . width , fb . height , fb . pitch_y , fb . pixel_format , dst , & dst_size ) ; if ( e ) { fprintf ( stderr , \"Error<S2SV_blank>encoding<S2SV_blank>PNG<S2SV_blank>%s\\\\n\" , gf_error_to_string ( e ) ) ; nb_pass = 0 ; } else { FILE * png = gf_fopen ( szFileName , \"wb\" ) ; if ( ! png ) { fprintf ( stderr , \"Error<S2SV_blank>writing<S2SV_blank>file<S2SV_blank>%s\\\\n\" , szFileName ) ; nb_pass = 0 ; } else { gf_fwrite ( dst , dst_size , 1 , png ) ; gf_fclose ( png ) ; fprintf ( stderr , \"Dump<S2SV_blank>to<S2SV_blank>%s\\\\n\" , szFileName ) ; } } if ( dst ) gf_free ( dst ) ; gf_term_release_screen_buffer ( term , & fb ) ; # endif } } fprintf ( stderr , \"Done:<S2SV_blank>%s\\\\n\" , szFileName ) ; } break ; case 'G' : { GF_ObjectManager * root_od , * odm ; u32 index ; char szOpt [ 8192 ] ; fprintf ( stderr , \"Enter<S2SV_blank>0-based<S2SV_blank>index<S2SV_blank>of<S2SV_blank>object<S2SV_blank>to<S2SV_blank>select<S2SV_blank>or<S2SV_blank>service<S2SV_blank>ID:\\\\n\" ) ; fflush ( stdin ) ; szOpt [ 0 ] = 0 ; if ( 1 > scanf ( \"%[^\\\\t\\\\n]\" , szOpt ) ) { fprintf ( stderr , \"Cannot<S2SV_blank>read<S2SV_blank>OD<S2SV_blank>ID\\\\n\" ) ; break ; } index = atoi ( szOpt ) ; odm = NULL ; root_od = gf_term_get_root_object ( term ) ; if ( root_od ) { if ( gf_term_find_service ( term , root_od , index ) ) { gf_term_select_service ( term , root_od , index ) ; } else { fprintf ( stderr , \"Cannot<S2SV_blank>find<S2SV_blank>service<S2SV_blank>%d<S2SV_blank>-<S2SV_blank>trying<S2SV_blank>with<S2SV_blank>object<S2SV_blank>index\\\\n\" , index ) ; odm = gf_term_get_object ( term , root_od , index ) ; if ( odm ) { gf_term_select_object ( term , odm ) ; } else { fprintf ( stderr , \"Cannot<S2SV_blank>find<S2SV_blank>object<S2SV_blank>at<S2SV_blank>index<S2SV_blank>%d\\\\n\" , index ) ; } } } } break ; case 'h' : PrintHelp ( ) ; break ; default : break ; } } if ( bench_mode ) { PrintAVInfo ( GF_TRUE ) ; } if ( simulation_time_in_ms ) { gf_log_set_strict_error ( 0 ) ; } i = gf_sys_clock ( ) ; gf_term_disconnect ( term ) ; if ( rti_file ) UpdateRTInfo ( \"Disconnected\\\\n\" ) ; fprintf ( stderr , \"Deleting<S2SV_blank>terminal...<S2SV_blank>\" ) ; if ( playlist ) gf_fclose ( playlist ) ; # if defined ( __DARWIN__ ) || defined ( __APPLE__ ) carbon_uninit ( ) ; # endif gf_term_del ( term ) ; fprintf ( stderr , \"done<S2SV_blank>(in<S2SV_blank>%d<S2SV_blank>ms)<S2SV_blank>-<S2SV_blank>ran<S2SV_blank>for<S2SV_blank>%d<S2SV_blank>ms\\\\n\" , gf_sys_clock ( ) - i , gf_sys_clock ( ) ) ; fprintf ( stderr , \"GPAC<S2SV_blank>cleanup<S2SV_blank>...\\\\n\" ) ; gf_modules_del ( user . modules ) ; if ( no_cfg_save ) gf_cfg_discard_changes ( cfg_file ) ; gf_cfg_del ( cfg_file ) ; gf_sys_close ( ) ; if ( rti_logs ) gf_fclose ( rti_logs ) ; if ( logfile ) gf_fclose ( logfile ) ; if ( gui_mode ) { hide_shell ( 2 ) ; } # ifdef GPAC_MEMORY_TRACKING if ( mem_track && ( gf_memory_size ( ) || gf_file_handles_count ( ) ) ) { gf_log_set_tool_level ( GF_LOG_MEMORY , GF_LOG_INFO ) ; gf_memory_print ( ) ; return 2 ; } # endif return ret_val ; }\n",
      "fixed_code": "<S2SV_ModStart> [ sizeof ( the_url <S2SV_ModEnd> ) - 1\n",
      "source_code_length": 37793,
      "target_code_length": 55,
      "vulnerability_patterns": {
        "buffer_overflow": 14,
        "use_after_free": 4,
        "integer_overflow": 41,
        "format_string": 90,
        "null_pointer": 28,
        "sql_injection": 1,
        "total": 178
      },
      "total_patterns": 178,
      "original_address": "https://github.com/gpac/gpac/commit/1c449a34fe0b50aaffb881bfb9d7c5ab0bb18cdd",
      "discovery_time": "2019-02-06T23:29Z",
      "project_commit_id": "gpac@gpac/1c449a34fe0b50aaffb881bfb9d7c5ab0bb18cdd",
      "extraction_time": "2025-08-31T15:41:49.176375",
      "label": 1,
      "vulnerability_type": "out-of-bounds_write",
      "difficulty_level": "expert",
      "risk_factors": [
        "memory_corruption",
        "sql_injection",
        "arbitrary_code_execution",
        "buffer_overflow",
        "system_crash",
        "use_after_free"
      ],
      "attack_vectors": [
        "memory_manipulation",
        "malicious_input",
        "code_analysis",
        "buffer_overflow",
        "reverse_engineering",
        "fuzzing"
      ],
      "mitigation_strategies": [
        "safe_string_functions",
        "dynamic_analysis",
        "code_review",
        "static_analysis",
        "memory_safety_checks",
        "input_validation",
        "fuzzing",
        "bounds_checking",
        "secure_coding_practices"
      ],
      "code_differences": {
        "has_differences": true,
        "source_lines": 2,
        "target_lines": 2,
        "character_differences": 37738,
        "similarity_percentage": 1.0189228529839884
      },
      "vulnerability_location": {
        "vulnerability_present": true,
        "fix_applied": true,
        "code_changed": true,
        "estimated_lines_changed": 0
      }
    },
    {
      "cve_id": "CVE-2019-19275",
      "cwe_id": "CWE-125",
      "cwe_name": "Out-of-bounds Read",
      "project": "python",
      "severity": "critical",
      "weaponization_score": 10.0,
      "is_critical": true,
      "is_weaponizable": true,
      "is_high_priority_project": true,
      "vulnerable_code": "CWE-125 static arguments_ty ast_for_arguments ( struct compiling * c , const node * n ) { int i , j , k , nposargs = 0 , nkwonlyargs = 0 ; int nposdefaults = 0 , found_default = 0 ; asdl_seq * posargs , * posdefaults , * kwonlyargs , * kwdefaults ; arg_ty vararg = NULL , kwarg = NULL ; arg_ty arg ; node * ch ; if ( TYPE ( n ) == parameters ) { if ( NCH ( n ) == 2 ) return arguments ( NULL , NULL , NULL , NULL , NULL , NULL , c -> c_arena ) ; n = CHILD ( n , 1 ) ; } assert ( TYPE ( n ) == typedargslist || TYPE ( n ) == varargslist ) ; for ( i = 0 ; i < NCH ( n ) ; i ++ ) { ch = CHILD ( n , i ) ; if ( TYPE ( ch ) == STAR ) { i ++ ; if ( i < NCH ( n ) && ( TYPE ( CHILD ( n , i ) ) == tfpdef || TYPE ( CHILD ( n , i ) ) == vfpdef ) ) { i ++ ; } break ; } if ( TYPE ( ch ) == DOUBLESTAR ) break ; if ( TYPE ( ch ) == vfpdef || TYPE ( ch ) == tfpdef ) nposargs ++ ; if ( TYPE ( ch ) == EQUAL ) nposdefaults ++ ; } for ( ; i < NCH ( n ) ; ++ i ) { ch = CHILD ( n , i ) ; if ( TYPE ( ch ) == DOUBLESTAR ) break ; if ( TYPE ( ch ) == tfpdef || TYPE ( ch ) == vfpdef ) nkwonlyargs ++ ; } posargs = ( nposargs ? _Ta3_asdl_seq_new ( nposargs , c -> c_arena ) : NULL ) ; if ( ! posargs && nposargs ) return NULL ; kwonlyargs = ( nkwonlyargs ? _Ta3_asdl_seq_new ( nkwonlyargs , c -> c_arena ) : NULL ) ; if ( ! kwonlyargs && nkwonlyargs ) return NULL ; posdefaults = ( nposdefaults ? _Ta3_asdl_seq_new ( nposdefaults , c -> c_arena ) : NULL ) ; if ( ! posdefaults && nposdefaults ) return NULL ; kwdefaults = ( nkwonlyargs ? _Ta3_asdl_seq_new ( nkwonlyargs , c -> c_arena ) : NULL ) ; if ( ! kwdefaults && nkwonlyargs ) return NULL ; <S2SV_StartBug> if ( nposargs + nkwonlyargs > 255 ) { <S2SV_EndBug> ast_error ( c , n , \"more<S2SV_blank>than<S2SV_blank>255<S2SV_blank>arguments\" ) ; return NULL ; } i = 0 ; j = 0 ; k = 0 ; while ( i < NCH ( n ) ) { ch = CHILD ( n , i ) ; switch ( TYPE ( ch ) ) { case tfpdef : case vfpdef : if ( i + 1 < NCH ( n ) && TYPE ( CHILD ( n , i + 1 ) ) == EQUAL ) { expr_ty expression = ast_for_expr ( c , CHILD ( n , i + 2 ) ) ; if ( ! expression ) return NULL ; assert ( posdefaults != NULL ) ; asdl_seq_SET ( posdefaults , j ++ , expression ) ; i += 2 ; found_default = 1 ; } else if ( found_default ) { ast_error ( c , n , \"non-default<S2SV_blank>argument<S2SV_blank>follows<S2SV_blank>default<S2SV_blank>argument\" ) ; return NULL ; } arg = ast_for_arg ( c , ch ) ; if ( ! arg ) return NULL ; asdl_seq_SET ( posargs , k ++ , arg ) ; i += 1 ; <S2SV_StartBug> if ( i < NCH ( n ) && TYPE ( CHILD ( n , i ) ) == COMMA ) <S2SV_EndBug> i += 1 ; break ; case STAR : if ( i + 1 >= NCH ( n ) || ( i + 2 == NCH ( n ) && ( TYPE ( CHILD ( n , i + 1 ) ) == COMMA || TYPE ( CHILD ( n , i + 1 ) ) == TYPE_COMMENT ) ) ) { ast_error ( c , CHILD ( n , i ) , \"named<S2SV_blank>arguments<S2SV_blank>must<S2SV_blank>follow<S2SV_blank>bare<S2SV_blank>*\" ) ; return NULL ; } ch = CHILD ( n , i + 1 ) ; if ( TYPE ( ch ) == COMMA ) { int res = 0 ; i += 2 ; <S2SV_StartBug> if ( i < NCH ( n ) && TYPE ( CHILD ( n , i ) ) == TYPE_COMMENT ) { <S2SV_EndBug> ast_error ( c , CHILD ( n , i ) , \"bare<S2SV_blank>*<S2SV_blank>has<S2SV_blank>associated<S2SV_blank>type<S2SV_blank>comment\" ) ; return NULL ; } res = handle_keywordonly_args ( c , n , i , kwonlyargs , kwdefaults ) ; if ( res == - 1 ) return NULL ; i = res ; } else { vararg = ast_for_arg ( c , ch ) ; if ( ! vararg ) return NULL ; i += 2 ; <S2SV_StartBug> if ( i < NCH ( n ) && TYPE ( CHILD ( n , i ) ) == COMMA ) <S2SV_EndBug> i += 1 ; <S2SV_StartBug> if ( i < NCH ( n ) && TYPE ( CHILD ( n , i ) ) == TYPE_COMMENT ) { <S2SV_EndBug> vararg -> type_comment = NEW_TYPE_COMMENT ( CHILD ( n , i ) ) ; i += 1 ; } if ( i < NCH ( n ) && ( TYPE ( CHILD ( n , i ) ) == tfpdef || TYPE ( CHILD ( n , i ) ) == vfpdef ) ) { int res = 0 ; res = handle_keywordonly_args ( c , n , i , kwonlyargs , kwdefaults ) ; if ( res == - 1 ) return NULL ; i = res ; } } break ; case DOUBLESTAR : ch = CHILD ( n , i + 1 ) ; assert ( TYPE ( ch ) == tfpdef || TYPE ( ch ) == vfpdef ) ; kwarg = ast_for_arg ( c , ch ) ; if ( ! kwarg ) return NULL ; i += 2 ; <S2SV_StartBug> if ( i < NCH ( n ) && TYPE ( CHILD ( n , i ) ) == COMMA ) <S2SV_EndBug> i += 1 ; break ; case TYPE_COMMENT : assert ( i ) ; if ( kwarg ) arg = kwarg ; arg -> type_comment = NEW_TYPE_COMMENT ( ch ) ; i += 1 ; break ; default : PyErr_Format ( PyExc_SystemError , \"unexpected<S2SV_blank>node<S2SV_blank>in<S2SV_blank>varargslist:<S2SV_blank>%d<S2SV_blank>@<S2SV_blank>%d\" , TYPE ( ch ) , i ) ; return NULL ; } } return arguments ( posargs , vararg , kwonlyargs , kwdefaults , kwarg , posdefaults , c -> c_arena ) ; }\n",
      "fixed_code": "<S2SV_ModStart> return NULL ; <S2SV_ModEnd> i = 0 <S2SV_ModStart> ; if ( <S2SV_ModEnd> TYPE ( CHILD <S2SV_ModStart> ; if ( <S2SV_ModEnd> TYPE ( CHILD <S2SV_ModStart> ; if ( <S2SV_ModEnd> TYPE ( CHILD <S2SV_ModStart> ; if ( <S2SV_ModEnd> TYPE ( CHILD <S2SV_ModStart> ; if ( <S2SV_ModEnd> TYPE ( CHILD\n",
      "source_code_length": 4617,
      "target_code_length": 300,
      "vulnerability_patterns": {
        "buffer_overflow": 1,
        "null_pointer": 10,
        "total": 11
      },
      "total_patterns": 11,
      "original_address": "https://github.com/python/typed_ast/commit/156afcb26c198e162504a57caddfe0acd9ed7dce",
      "discovery_time": "2019-11-26T15:15Z",
      "project_commit_id": "python@typed_ast/156afcb26c198e162504a57caddfe0acd9ed7dce",
      "extraction_time": "2025-08-31T15:41:49.176609",
      "label": 1,
      "vulnerability_type": "out-of-bounds_read",
      "difficulty_level": "expert",
      "risk_factors": [
        "memory_corruption",
        "critical_infrastructure",
        "buffer_overflow",
        "information_disclosure",
        "integer_overflow"
      ],
      "attack_vectors": [
        "memory_manipulation",
        "malicious_input",
        "code_analysis",
        "buffer_overflow",
        "reverse_engineering",
        "fuzzing"
      ],
      "mitigation_strategies": [
        "safe_string_functions",
        "dynamic_analysis",
        "code_review",
        "static_analysis",
        "memory_safety_checks",
        "input_validation",
        "fuzzing",
        "bounds_checking",
        "secure_coding_practices"
      ],
      "code_differences": {
        "has_differences": true,
        "source_lines": 2,
        "target_lines": 2,
        "character_differences": 4317,
        "similarity_percentage": 9.70873786407767
      },
      "vulnerability_location": {
        "vulnerability_present": true,
        "fix_applied": true,
        "code_changed": true,
        "estimated_lines_changed": 0
      }
    },
    {
      "cve_id": "CVE-2016-5688",
      "cwe_id": "CWE-119",
      "cwe_name": "Buffer Overflow",
      "project": "ImageMagick",
      "severity": "critical",
      "weaponization_score": 10.0,
      "is_critical": true,
      "is_weaponizable": true,
      "is_high_priority_project": true,
      "vulnerable_code": "CWE-119 static Image * ReadWPGImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { typedef struct { size_t FileId ; MagickOffsetType DataOffset ; unsigned int ProductType ; unsigned int FileType ; unsigned char MajorVersion ; unsigned char MinorVersion ; unsigned int EncryptKey ; unsigned int Reserved ; } WPGHeader ; typedef struct { unsigned char RecType ; size_t RecordLength ; } WPGRecord ; typedef struct { unsigned char Class ; unsigned char RecType ; size_t Extension ; size_t RecordLength ; } WPG2Record ; typedef struct { unsigned HorizontalUnits ; unsigned VerticalUnits ; unsigned char PosSizePrecision ; } WPG2Start ; typedef struct { unsigned int Width ; unsigned int Height ; unsigned int Depth ; unsigned int HorzRes ; unsigned int VertRes ; } WPGBitmapType1 ; typedef struct { unsigned int Width ; unsigned int Height ; unsigned char Depth ; unsigned char Compression ; } WPG2BitmapType1 ; typedef struct { unsigned int RotAngle ; unsigned int LowLeftX ; unsigned int LowLeftY ; unsigned int UpRightX ; unsigned int UpRightY ; unsigned int Width ; unsigned int Height ; unsigned int Depth ; unsigned int HorzRes ; unsigned int VertRes ; } WPGBitmapType2 ; typedef struct { unsigned int StartIndex ; unsigned int NumOfEntries ; } WPGColorMapRec ; Image * image ; unsigned int status ; WPGHeader Header ; WPGRecord Rec ; WPG2Record Rec2 ; WPG2Start StartWPG ; WPGBitmapType1 BitmapHeader1 ; WPG2BitmapType1 Bitmap2Header1 ; WPGBitmapType2 BitmapHeader2 ; WPGColorMapRec WPG_Palette ; int i , bpp , WPG2Flags ; ssize_t ldblk ; size_t one ; unsigned char * BImgBuff ; tCTM CTM ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickCoreSignature ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickCoreSignature ) ; one = 1 ; image = AcquireImage ( image_info , exception ) ; image -> depth = 8 ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } Header . FileId = ReadBlobLSBLong ( image ) ; Header . DataOffset = ( MagickOffsetType ) ReadBlobLSBLong ( image ) ; Header . ProductType = ReadBlobLSBShort ( image ) ; Header . FileType = ReadBlobLSBShort ( image ) ; Header . MajorVersion = ReadBlobByte ( image ) ; Header . MinorVersion = ReadBlobByte ( image ) ; Header . EncryptKey = ReadBlobLSBShort ( image ) ; Header . Reserved = ReadBlobLSBShort ( image ) ; if ( Header . FileId != 0x435057FF || ( Header . ProductType >> 8 ) != 0x16 ) ThrowReaderException ( CorruptImageError , \"ImproperImageHeader\" ) ; if ( Header . EncryptKey != 0 ) ThrowReaderException ( CoderError , \"EncryptedWPGImageFileNotSupported\" ) ; image -> columns = 1 ; image -> rows = 1 ; image -> colors = 0 ; bpp = 0 ; BitmapHeader2 . RotAngle = 0 ; switch ( Header . FileType ) { case 1 : while ( ! EOFBlob ( image ) ) { ( void ) SeekBlob ( image , Header . DataOffset , SEEK_SET ) ; if ( EOFBlob ( image ) ) break ; Rec . RecType = ( i = ReadBlobByte ( image ) ) ; if ( i == EOF ) break ; Rd_WP_DWORD ( image , & Rec . RecordLength ) ; if ( EOFBlob ( image ) ) break ; Header . DataOffset = TellBlob ( image ) + Rec . RecordLength ; switch ( Rec . RecType ) { case 0x0B : BitmapHeader1 . Width = ReadBlobLSBShort ( image ) ; BitmapHeader1 . Height = ReadBlobLSBShort ( image ) ; if ( ( BitmapHeader1 . Width == 0 ) || ( BitmapHeader1 . Height == 0 ) ) ThrowReaderException ( CorruptImageError , \"ImproperImageHeader\" ) ; BitmapHeader1 . Depth = ReadBlobLSBShort ( image ) ; BitmapHeader1 . HorzRes = ReadBlobLSBShort ( image ) ; BitmapHeader1 . VertRes = ReadBlobLSBShort ( image ) ; if ( BitmapHeader1 . HorzRes && BitmapHeader1 . VertRes ) { image -> units = PixelsPerCentimeterResolution ; image -> resolution . x = BitmapHeader1 . HorzRes / 470.0 ; image -> resolution . y = BitmapHeader1 . VertRes / 470.0 ; } image -> columns = BitmapHeader1 . Width ; image -> rows = BitmapHeader1 . Height ; bpp = BitmapHeader1 . Depth ; goto UnpackRaster ; case 0x0E : WPG_Palette . StartIndex = ReadBlobLSBShort ( image ) ; WPG_Palette . NumOfEntries = ReadBlobLSBShort ( image ) ; image -> colors = WPG_Palette . NumOfEntries ; if ( ! AcquireImageColormap ( image , image -> colors , exception ) ) goto NoMemory ; for ( i = WPG_Palette . StartIndex ; i < ( int ) WPG_Palette . NumOfEntries ; i ++ ) { image -> colormap [ i ] . red = ScaleCharToQuantum ( ( unsigned char ) ReadBlobByte ( image ) ) ; image -> colormap [ i ] . green = ScaleCharToQuantum ( ( unsigned char ) ReadBlobByte ( image ) ) ; image -> colormap [ i ] . blue = ScaleCharToQuantum ( ( unsigned char ) ReadBlobByte ( image ) ) ; } break ; case 0x11 : if ( Rec . RecordLength > 8 ) image = ExtractPostscript ( image , image_info , TellBlob ( image ) + 8 , ( ssize_t ) Rec . RecordLength - 8 , exception ) ; break ; case 0x14 : BitmapHeader2 . RotAngle = ReadBlobLSBShort ( image ) ; BitmapHeader2 . LowLeftX = ReadBlobLSBShort ( image ) ; BitmapHeader2 . LowLeftY = ReadBlobLSBShort ( image ) ; BitmapHeader2 . UpRightX = ReadBlobLSBShort ( image ) ; BitmapHeader2 . UpRightY = ReadBlobLSBShort ( image ) ; BitmapHeader2 . Width = ReadBlobLSBShort ( image ) ; BitmapHeader2 . Height = ReadBlobLSBShort ( image ) ; if ( ( BitmapHeader2 . Width == 0 ) || ( BitmapHeader2 . Height == 0 ) ) ThrowReaderException ( CorruptImageError , \"ImproperImageHeader\" ) ; BitmapHeader2 . Depth = ReadBlobLSBShort ( image ) ; BitmapHeader2 . HorzRes = ReadBlobLSBShort ( image ) ; BitmapHeader2 . VertRes = ReadBlobLSBShort ( image ) ; image -> units = PixelsPerCentimeterResolution ; image -> page . width = ( unsigned int ) ( ( BitmapHeader2 . LowLeftX - BitmapHeader2 . UpRightX ) / 470.0 ) ; image -> page . height = ( unsigned int ) ( ( BitmapHeader2 . LowLeftX - BitmapHeader2 . UpRightY ) / 470.0 ) ; image -> page . x = ( int ) ( BitmapHeader2 . LowLeftX / 470.0 ) ; image -> page . y = ( int ) ( BitmapHeader2 . LowLeftX / 470.0 ) ; if ( BitmapHeader2 . HorzRes && BitmapHeader2 . VertRes ) { image -> resolution . x = BitmapHeader2 . HorzRes / 470.0 ; image -> resolution . y = BitmapHeader2 . VertRes / 470.0 ; } image -> columns = BitmapHeader2 . Width ; image -> rows = BitmapHeader2 . Height ; bpp = BitmapHeader2 . Depth ; <S2SV_StartBug> UnpackRaster : <S2SV_EndBug> if ( ( image -> colors == 0 ) && ( bpp != 24 ) ) { image -> colors = one << bpp ; if ( ! AcquireImageColormap ( image , image -> colors , exception ) ) { NoMemory : ThrowReaderException ( ResourceLimitError , \"MemoryAllocationFailed\" ) ; } for ( i = 0 ; ( i < ( int ) image -> colors ) && ( i < 256 ) ; i ++ ) { image -> colormap [ i ] . red = ScaleCharToQuantum ( WPG1_Palette [ i ] . Red ) ; image -> colormap [ i ] . green = ScaleCharToQuantum ( WPG1_Palette [ i ] . Green ) ; image -> colormap [ i ] . blue = ScaleCharToQuantum ( WPG1_Palette [ i ] . Blue ) ; } } else { if ( bpp < 24 ) if ( ( image -> colors < ( one << bpp ) ) && ( bpp != 24 ) ) image -> colormap = ( PixelInfo * ) ResizeQuantumMemory ( image -> colormap , ( size_t ) ( one << bpp ) , sizeof ( * image -> colormap ) ) ; } if ( bpp == 1 ) { if ( image -> colormap [ 0 ] . red == 0 && image -> colormap [ 0 ] . green == 0 && image -> colormap [ 0 ] . blue == 0 && image -> colormap [ 1 ] . red == 0 && image -> colormap [ 1 ] . green == 0 && image -> colormap [ 1 ] . blue == 0 ) { image -> colormap [ 1 ] . red = image -> colormap [ 1 ] . green = image -> colormap [ 1 ] . blue = QuantumRange ; } } if ( UnpackWPGRaster ( image , bpp , exception ) < 0 ) { DecompressionFailed : ThrowReaderException ( CoderError , \"UnableToDecompressImage\" ) ; } if ( Rec . RecType == 0x14 && BitmapHeader2 . RotAngle != 0 && ! image_info -> ping ) { if ( BitmapHeader2 . RotAngle & 0x8000 ) { Image * flop_image ; flop_image = FlopImage ( image , exception ) ; if ( flop_image != ( Image * ) NULL ) { DuplicateBlob ( flop_image , image ) ; ( void ) RemoveLastImageFromList ( & image ) ; AppendImageToList ( & image , flop_image ) ; } } if ( BitmapHeader2 . RotAngle & 0x2000 ) { Image * flip_image ; flip_image = FlipImage ( image , exception ) ; if ( flip_image != ( Image * ) NULL ) { DuplicateBlob ( flip_image , image ) ; ( void ) RemoveLastImageFromList ( & image ) ; AppendImageToList ( & image , flip_image ) ; } } if ( BitmapHeader2 . RotAngle & 0x0FFF ) { Image * rotate_image ; rotate_image = RotateImage ( image , ( BitmapHeader2 . RotAngle & 0x0FFF ) , exception ) ; if ( rotate_image != ( Image * ) NULL ) { DuplicateBlob ( rotate_image , image ) ; ( void ) RemoveLastImageFromList ( & image ) ; AppendImageToList ( & image , rotate_image ) ; } } } AcquireNextImage ( image_info , image , exception ) ; image -> depth = 8 ; if ( image -> next == ( Image * ) NULL ) goto Finish ; image = SyncNextImageInList ( image ) ; image -> columns = image -> rows = 1 ; image -> colors = 0 ; break ; case 0x1B : if ( Rec . RecordLength > 0x3C ) image = ExtractPostscript ( image , image_info , TellBlob ( image ) + 0x3C , ( ssize_t ) Rec . RecordLength - 0x3C , exception ) ; break ; } } break ; case 2 : ( void ) memset ( CTM , 0 , sizeof ( CTM ) ) ; StartWPG . PosSizePrecision = 0 ; while ( ! EOFBlob ( image ) ) { ( void ) SeekBlob ( image , Header . DataOffset , SEEK_SET ) ; if ( EOFBlob ( image ) ) break ; Rec2 . Class = ( i = ReadBlobByte ( image ) ) ; if ( i == EOF ) break ; Rec2 . RecType = ( i = ReadBlobByte ( image ) ) ; if ( i == EOF ) break ; Rd_WP_DWORD ( image , & Rec2 . Extension ) ; Rd_WP_DWORD ( image , & Rec2 . RecordLength ) ; if ( EOFBlob ( image ) ) break ; Header . DataOffset = TellBlob ( image ) + Rec2 . RecordLength ; switch ( Rec2 . RecType ) { case 1 : StartWPG . HorizontalUnits = ReadBlobLSBShort ( image ) ; StartWPG . VerticalUnits = ReadBlobLSBShort ( image ) ; StartWPG . PosSizePrecision = ReadBlobByte ( image ) ; break ; case 0x0C : WPG_Palette . StartIndex = ReadBlobLSBShort ( image ) ; WPG_Palette . NumOfEntries = ReadBlobLSBShort ( image ) ; image -> colors = WPG_Palette . NumOfEntries ; if ( AcquireImageColormap ( image , image -> colors , exception ) == MagickFalse ) ThrowReaderException ( ResourceLimitError , \"MemoryAllocationFailed\" ) ; for ( i = WPG_Palette . StartIndex ; i < ( int ) WPG_Palette . NumOfEntries ; i ++ ) { image -> colormap [ i ] . red = ScaleCharToQuantum ( ( char ) ReadBlobByte ( image ) ) ; image -> colormap [ i ] . green = ScaleCharToQuantum ( ( char ) ReadBlobByte ( image ) ) ; image -> colormap [ i ] . blue = ScaleCharToQuantum ( ( char ) ReadBlobByte ( image ) ) ; ( void ) ReadBlobByte ( image ) ; } break ; case 0x0E : Bitmap2Header1 . Width = ReadBlobLSBShort ( image ) ; Bitmap2Header1 . Height = ReadBlobLSBShort ( image ) ; if ( ( Bitmap2Header1 . Width == 0 ) || ( Bitmap2Header1 . Height == 0 ) ) ThrowReaderException ( CorruptImageError , \"ImproperImageHeader\" ) ; Bitmap2Header1 . Depth = ReadBlobByte ( image ) ; Bitmap2Header1 . Compression = ReadBlobByte ( image ) ; if ( Bitmap2Header1 . Compression > 1 ) continue ; switch ( Bitmap2Header1 . Depth ) { case 1 : bpp = 1 ; break ; case 2 : bpp = 2 ; break ; case 3 : bpp = 4 ; break ; case 4 : bpp = 8 ; break ; case 8 : bpp = 24 ; break ; default : continue ; } image -> columns = Bitmap2Header1 . Width ; <S2SV_StartBug> image -> rows = Bitmap2Header1 . Height ; <S2SV_EndBug> if ( ( image -> colors == 0 ) && ( bpp != 24 ) ) { size_t one ; one = 1 ; image -> colors = one << bpp ; if ( ! AcquireImageColormap ( image , image -> colors , exception ) ) goto NoMemory ; } else { if ( bpp < 24 ) if ( image -> colors < ( one << bpp ) && bpp != 24 ) image -> colormap = ( PixelInfo * ) ResizeQuantumMemory ( image -> colormap , ( size_t ) ( one << bpp ) , sizeof ( * image -> colormap ) ) ; } switch ( Bitmap2Header1 . Compression ) { case 0 : { ldblk = ( ssize_t ) ( ( bpp * image -> columns + 7 ) / 8 ) ; BImgBuff = ( unsigned char * ) AcquireQuantumMemory ( ( size_t ) ldblk + 1 , sizeof ( * BImgBuff ) ) ; if ( BImgBuff == ( unsigned char * ) NULL ) goto NoMemory ; for ( i = 0 ; i < ( ssize_t ) image -> rows ; i ++ ) { ( void ) ReadBlob ( image , ldblk , BImgBuff ) ; InsertRow ( image , BImgBuff , i , bpp , exception ) ; } if ( BImgBuff ) BImgBuff = ( unsigned char * ) RelinquishMagickMemory ( BImgBuff ) ; break ; } case 1 : { if ( UnpackWPG2Raster ( image , bpp , exception ) < 0 ) goto DecompressionFailed ; break ; } } if ( CTM [ 0 ] [ 0 ] < 0 && ! image_info -> ping ) { Image * flop_image ; flop_image = FlopImage ( image , exception ) ; if ( flop_image != ( Image * ) NULL ) { DuplicateBlob ( flop_image , image ) ; ( void ) RemoveLastImageFromList ( & image ) ; AppendImageToList ( & image , flop_image ) ; } } if ( CTM [ 1 ] [ 1 ] < 0 && ! image_info -> ping ) { Image * flip_image ; flip_image = FlipImage ( image , exception ) ; if ( flip_image != ( Image * ) NULL ) { DuplicateBlob ( flip_image , image ) ; ( void ) RemoveLastImageFromList ( & image ) ; AppendImageToList ( & image , flip_image ) ; } } AcquireNextImage ( image_info , image , exception ) ; image -> depth = 8 ; if ( image -> next == ( Image * ) NULL ) goto Finish ; image = SyncNextImageInList ( image ) ; image -> columns = image -> rows = 1 ; image -> colors = 0 ; break ; case 0x12 : i = ReadBlobLSBShort ( image ) ; if ( Rec2 . RecordLength > ( unsigned int ) i ) image = ExtractPostscript ( image , image_info , TellBlob ( image ) + i , ( ssize_t ) ( Rec2 . RecordLength - i - 2 ) , exception ) ; break ; case 0x1B : WPG2Flags = LoadWPG2Flags ( image , StartWPG . PosSizePrecision , NULL , & CTM ) ; ( void ) WPG2Flags ; break ; } } break ; default : { ThrowReaderException ( CoderError , \"DataEncodingSchemeIsNotSupported\" ) ; } } <S2SV_StartBug> status = SetImageExtent ( image , image -> columns , image -> rows , exception ) ; <S2SV_EndBug> if ( status == MagickFalse ) return ( DestroyImageList ( image ) ) ; Finish : ( void ) CloseBlob ( image ) ; { Image * p ; ssize_t scene = 0 ; p = image ; image = NULL ; while ( p != ( Image * ) NULL ) { Image * tmp = p ; if ( ( p -> rows == 0 ) || ( p -> columns == 0 ) ) { p = p -> previous ; DeleteImageFromList ( & tmp ) ; } else { image = p ; p = p -> previous ; } } for ( p = image ; p != ( Image * ) NULL ; p = p -> next ) p -> scene = ( size_t ) scene ++ ; } if ( image == ( Image * ) NULL ) ThrowReaderException ( CorruptImageError , \"ImageFileDoesNotContainAnyImageData\" ) ; return ( image ) ; }\n",
      "fixed_code": "<S2SV_ModStart> ; UnpackRaster : status = SetImageExtent ( image , image -> columns , image -> rows , exception ) ; if ( status == MagickFalse ) break ; <S2SV_ModStart> Bitmap2Header1 . Height ; status = SetImageExtent ( image , image -> columns , image -> rows , exception ) ; if ( status == MagickFalse ) break <S2SV_ModStart> ; } } <S2SV_ModEnd> Finish : (\n",
      "source_code_length": 14394,
      "target_code_length": 360,
      "vulnerability_patterns": {
        "buffer_overflow": 1,
        "use_after_free": 1,
        "integer_overflow": 5,
        "null_pointer": 82,
        "total": 89
      },
      "total_patterns": 89,
      "original_address": "https://github.com/ImageMagick/ImageMagick/commit/fc43974d34318c834fbf78570ca1a3764ed8c7d7",
      "discovery_time": "2016-12-13T15:59Z",
      "project_commit_id": "ImageMagick@ImageMagick/fc43974d34318c834fbf78570ca1a3764ed8c7d7",
      "extraction_time": "2025-08-31T15:41:49.176664",
      "label": 1,
      "vulnerability_type": "buffer_overflow",
      "difficulty_level": "expert",
      "risk_factors": [
        "memory_corruption",
        "critical_infrastructure",
        "arbitrary_code_execution",
        "buffer_overflow",
        "system_crash",
        "use_after_free"
      ],
      "attack_vectors": [
        "memory_manipulation",
        "malicious_input",
        "code_analysis",
        "buffer_overflow",
        "reverse_engineering",
        "fuzzing"
      ],
      "mitigation_strategies": [
        "safe_string_functions",
        "dynamic_analysis",
        "code_review",
        "static_analysis",
        "memory_safety_checks",
        "input_validation",
        "fuzzing",
        "bounds_checking",
        "secure_coding_practices"
      ],
      "code_differences": {
        "has_differences": true,
        "source_lines": 2,
        "target_lines": 2,
        "character_differences": 14034,
        "similarity_percentage": 10.267857142857142
      },
      "vulnerability_location": {
        "vulnerability_present": true,
        "fix_applied": true,
        "code_changed": true,
        "estimated_lines_changed": 0
      }
    },
    {
      "cve_id": "CVE-2018-14360",
      "cwe_id": "CWE-119",
      "cwe_name": "Buffer Overflow",
      "project": "neomutt",
      "severity": "critical",
      "weaponization_score": 10.0,
      "is_critical": true,
      "is_weaponizable": true,
      "is_high_priority_project": true,
      "vulnerable_code": "CWE-119 int nntp_add_group ( char * line , void * data ) { struct NntpServer * nserv = data ; struct NntpData * nntp_data = NULL ; <S2SV_StartBug> char group [ LONG_STRING ] ; <S2SV_EndBug> char desc [ HUGE_STRING ] = \"\" ; char mod ; anum_t first , last ; if ( ! nserv || ! line ) return 0 ; <S2SV_StartBug> if ( sscanf ( line , \"%s<S2SV_blank>\" ANUM \"<S2SV_blank>\" ANUM \"<S2SV_blank>%c<S2SV_blank>%[^\\\\n]\" , group , & last , & first , & mod , desc ) < 4 ) <S2SV_EndBug> <S2SV_StartBug> return 0 ; <S2SV_EndBug> nntp_data = nntp_data_find ( nserv , group ) ; nntp_data -> deleted = false ; nntp_data -> first_message = first ; nntp_data -> last_message = last ; nntp_data -> allowed = ( mod == 'y' ) || ( mod == 'm' ) ; mutt_str_replace ( & nntp_data -> desc , desc ) ; if ( nntp_data -> newsrc_ent || nntp_data -> last_cached ) nntp_group_unread_stat ( nntp_data ) ; else if ( nntp_data -> last_message && nntp_data -> first_message <= nntp_data -> last_message ) nntp_data -> unread = nntp_data -> last_message - nntp_data -> first_message + 1 ; else nntp_data -> unread = 0 ; return 0 ; }\n",
      "fixed_code": "<S2SV_ModStart> [ LONG_STRING ] = \"\" <S2SV_ModStart> ( line , \"%1023s<S2SV_blank>\" <S2SV_ModEnd> ANUM \"<S2SV_blank>\" ANUM <S2SV_ModStart> ANUM \"<S2SV_blank>\" ANUM \"<S2SV_blank>%c<S2SV_blank>%8191[^\\\\n]\" <S2SV_ModEnd> , group , <S2SV_ModStart> < 4 ) { mutt_debug ( 4 , \"Cannot<S2SV_blank>parse<S2SV_blank>server<S2SV_blank>line:<S2SV_blank>%s\\\\n\" , line ) ; <S2SV_ModStart> return 0 ; }\n",
      "source_code_length": 1092,
      "target_code_length": 386,
      "vulnerability_patterns": {
        "use_after_free": 2,
        "null_pointer": 14,
        "total": 16
      },
      "total_patterns": 16,
      "original_address": "https://github.com/neomutt/neomutt/commit/6296f7153f0c9d5e5cd3aaf08f9731e56621bdd3",
      "discovery_time": "2018-07-17T17:29Z",
      "project_commit_id": "neomutt@neomutt/6296f7153f0c9d5e5cd3aaf08f9731e56621bdd3",
      "extraction_time": "2025-08-31T15:41:49.176775",
      "label": 1,
      "vulnerability_type": "buffer_overflow",
      "difficulty_level": "expert",
      "risk_factors": [
        "memory_corruption",
        "critical_infrastructure",
        "arbitrary_code_execution",
        "system_crash",
        "use_after_free"
      ],
      "attack_vectors": [
        "memory_manipulation",
        "malicious_input",
        "code_analysis",
        "buffer_overflow",
        "reverse_engineering",
        "fuzzing"
      ],
      "mitigation_strategies": [
        "safe_string_functions",
        "dynamic_analysis",
        "code_review",
        "static_analysis",
        "memory_safety_checks",
        "input_validation",
        "fuzzing",
        "bounds_checking",
        "secure_coding_practices"
      ],
      "code_differences": {
        "has_differences": true,
        "source_lines": 2,
        "target_lines": 2,
        "character_differences": 706,
        "similarity_percentage": 25.675675675675674
      },
      "vulnerability_location": {
        "vulnerability_present": true,
        "fix_applied": true,
        "code_changed": true,
        "estimated_lines_changed": 0
      }
    },
    {
      "cve_id": "CVE-2015-2697",
      "cwe_id": "CWE-119",
      "cwe_name": "Buffer Overflow",
      "project": "krb5",
      "severity": "critical",
      "weaponization_score": 10.0,
      "is_critical": true,
      "is_weaponizable": true,
      "is_high_priority_project": true,
      "vulnerable_code": "CWE-119 static krb5_error_code build_principal_va ( krb5_context context , krb5_principal princ , unsigned int rlen , const char * realm , va_list ap ) { krb5_error_code retval = 0 ; char * r = NULL ; krb5_data * data = NULL ; krb5_int32 count = 0 ; krb5_int32 size = 2 ; char * component = NULL ; data = malloc ( size * sizeof ( krb5_data ) ) ; if ( ! data ) { retval = ENOMEM ; } <S2SV_StartBug> if ( ! retval ) { <S2SV_EndBug> r = strdup ( realm ) ; if ( ! r ) { retval = ENOMEM ; } } while ( ! retval && ( component = va_arg ( ap , char * ) ) ) { if ( count == size ) { krb5_data * new_data = NULL ; size *= 2 ; new_data = realloc ( data , size * sizeof ( krb5_data ) ) ; if ( new_data ) { data = new_data ; } else { retval = ENOMEM ; } } if ( ! retval ) { data [ count ] . length = strlen ( component ) ; data [ count ] . data = strdup ( component ) ; if ( ! data [ count ] . data ) { retval = ENOMEM ; } count ++ ; } } if ( ! retval ) { princ -> type = KRB5_NT_UNKNOWN ; princ -> magic = KV5M_PRINCIPAL ; princ -> realm = make_data ( r , rlen ) ; princ -> data = data ; princ -> length = count ; r = NULL ; data = NULL ; } if ( data ) { while ( -- count >= 0 ) { free ( data [ count ] . data ) ; } free ( data ) ; } free ( r ) ; return retval ; }\n",
      "fixed_code": "<S2SV_ModStart> ! retval ) r = k5memdup0 ( realm , rlen , & retval ) ; <S2SV_ModEnd> while ( !\n",
      "source_code_length": 1253,
      "target_code_length": 95,
      "vulnerability_patterns": {
        "use_after_free": 9,
        "integer_overflow": 3,
        "null_pointer": 15,
        "memory_leak": 2,
        "total": 29
      },
      "total_patterns": 29,
      "original_address": "https://github.com/krb5/krb5/commit/f0c094a1b745d91ef2f9a4eae2149aac026a5789",
      "discovery_time": "2015-11-09T03:59Z",
      "project_commit_id": "krb5@krb5/f0c094a1b745d91ef2f9a4eae2149aac026a5789",
      "extraction_time": "2025-08-31T15:41:49.176806",
      "label": 1,
      "vulnerability_type": "buffer_overflow",
      "difficulty_level": "expert",
      "risk_factors": [
        "memory_corruption",
        "critical_infrastructure",
        "arbitrary_code_execution",
        "system_crash",
        "use_after_free"
      ],
      "attack_vectors": [
        "memory_manipulation",
        "malicious_input",
        "code_analysis",
        "buffer_overflow",
        "reverse_engineering",
        "fuzzing"
      ],
      "mitigation_strategies": [
        "safe_string_functions",
        "dynamic_analysis",
        "code_review",
        "static_analysis",
        "memory_safety_checks",
        "input_validation",
        "fuzzing",
        "bounds_checking",
        "secure_coding_practices"
      ],
      "code_differences": {
        "has_differences": true,
        "source_lines": 2,
        "target_lines": 2,
        "character_differences": 1158,
        "similarity_percentage": 15.492957746478872
      },
      "vulnerability_location": {
        "vulnerability_present": true,
        "fix_applied": true,
        "code_changed": true,
        "estimated_lines_changed": 0
      }
    },
    {
      "cve_id": "CVE-2019-15683",
      "cwe_id": "CWE-787",
      "cwe_name": "Out-of-bounds Write",
      "project": "TurboVNC",
      "severity": "critical",
      "weaponization_score": 10.0,
      "is_critical": true,
      "is_weaponizable": true,
      "is_high_priority_project": false,
      "vulnerable_code": "CWE-787 static void rfbProcessClientNormalMessage ( rfbClientPtr cl ) { int n ; rfbClientToServerMsg msg ; char * str ; READ ( ( char * ) & msg , 1 ) switch ( msg . type ) { case rfbSetPixelFormat : READ ( ( ( char * ) & msg ) + 1 , sz_rfbSetPixelFormatMsg - 1 ) cl -> format . bitsPerPixel = msg . spf . format . bitsPerPixel ; cl -> format . depth = msg . spf . format . depth ; cl -> format . bigEndian = ( msg . spf . format . bigEndian ? 1 : 0 ) ; cl -> format . trueColour = ( msg . spf . format . trueColour ? 1 : 0 ) ; cl -> format . redMax = Swap16IfLE ( msg . spf . format . redMax ) ; cl -> format . greenMax = Swap16IfLE ( msg . spf . format . greenMax ) ; cl -> format . blueMax = Swap16IfLE ( msg . spf . format . blueMax ) ; cl -> format . redShift = msg . spf . format . redShift ; cl -> format . greenShift = msg . spf . format . greenShift ; cl -> format . blueShift = msg . spf . format . blueShift ; cl -> readyForSetColourMapEntries = TRUE ; rfbSetTranslateFunction ( cl ) ; return ; case rfbFixColourMapEntries : READ ( ( ( char * ) & msg ) + 1 , sz_rfbFixColourMapEntriesMsg - 1 ) rfbLog ( \"rfbProcessClientNormalMessage:<S2SV_blank>FixColourMapEntries<S2SV_blank>unsupported\\\\n\" ) ; rfbCloseClient ( cl ) ; return ; case rfbSetEncodings : { int i ; CARD32 enc ; Bool firstFence = ! cl -> enableFence ; Bool firstCU = ! cl -> enableCU ; Bool firstGII = ! cl -> enableGII ; Bool logTightCompressLevel = FALSE ; READ ( ( ( char * ) & msg ) + 1 , sz_rfbSetEncodingsMsg - 1 ) msg . se . nEncodings = Swap16IfLE ( msg . se . nEncodings ) ; cl -> preferredEncoding = - 1 ; cl -> useCopyRect = FALSE ; cl -> enableCursorShapeUpdates = FALSE ; cl -> enableCursorPosUpdates = FALSE ; cl -> enableLastRectEncoding = FALSE ; cl -> tightCompressLevel = TIGHT_DEFAULT_COMPRESSION ; cl -> tightSubsampLevel = TIGHT_DEFAULT_SUBSAMP ; cl -> tightQualityLevel = - 1 ; cl -> imageQualityLevel = - 1 ; for ( i = 0 ; i < msg . se . nEncodings ; i ++ ) { READ ( ( char * ) & enc , 4 ) enc = Swap32IfLE ( enc ) ; switch ( enc ) { case rfbEncodingCopyRect : cl -> useCopyRect = TRUE ; break ; case rfbEncodingRaw : if ( cl -> preferredEncoding == - 1 ) { cl -> preferredEncoding = enc ; rfbLog ( \"Using<S2SV_blank>raw<S2SV_blank>encoding<S2SV_blank>for<S2SV_blank>client<S2SV_blank>%s\\\\n\" , cl -> host ) ; } break ; case rfbEncodingRRE : if ( cl -> preferredEncoding == - 1 ) { cl -> preferredEncoding = enc ; rfbLog ( \"Using<S2SV_blank>rre<S2SV_blank>encoding<S2SV_blank>for<S2SV_blank>client<S2SV_blank>%s\\\\n\" , cl -> host ) ; } break ; case rfbEncodingCoRRE : if ( cl -> preferredEncoding == - 1 ) { cl -> preferredEncoding = enc ; rfbLog ( \"Using<S2SV_blank>CoRRE<S2SV_blank>encoding<S2SV_blank>for<S2SV_blank>client<S2SV_blank>%s\\\\n\" , cl -> host ) ; } break ; case rfbEncodingHextile : if ( cl -> preferredEncoding == - 1 ) { cl -> preferredEncoding = enc ; rfbLog ( \"Using<S2SV_blank>hextile<S2SV_blank>encoding<S2SV_blank>for<S2SV_blank>client<S2SV_blank>%s\\\\n\" , cl -> host ) ; } break ; case rfbEncodingZlib : if ( cl -> preferredEncoding == - 1 ) { cl -> preferredEncoding = enc ; rfbLog ( \"Using<S2SV_blank>zlib<S2SV_blank>encoding<S2SV_blank>for<S2SV_blank>client<S2SV_blank>%s\\\\n\" , cl -> host ) ; } break ; case rfbEncodingZRLE : if ( cl -> preferredEncoding == - 1 ) { cl -> preferredEncoding = enc ; rfbLog ( \"Using<S2SV_blank>ZRLE<S2SV_blank>encoding<S2SV_blank>for<S2SV_blank>client<S2SV_blank>%s\\\\n\" , cl -> host ) ; } break ; case rfbEncodingZYWRLE : if ( cl -> preferredEncoding == - 1 ) { cl -> preferredEncoding = enc ; rfbLog ( \"Using<S2SV_blank>ZYWRLE<S2SV_blank>encoding<S2SV_blank>for<S2SV_blank>client<S2SV_blank>%s\\\\n\" , cl -> host ) ; } break ; case rfbEncodingTight : if ( cl -> preferredEncoding == - 1 ) { cl -> preferredEncoding = enc ; rfbLog ( \"Using<S2SV_blank>tight<S2SV_blank>encoding<S2SV_blank>for<S2SV_blank>client<S2SV_blank>%s\\\\n\" , cl -> host ) ; } break ; case rfbEncodingXCursor : if ( ! cl -> enableCursorShapeUpdates ) { rfbLog ( \"Enabling<S2SV_blank>X-style<S2SV_blank>cursor<S2SV_blank>updates<S2SV_blank>for<S2SV_blank>client<S2SV_blank>%s\\\\n\" , cl -> host ) ; cl -> enableCursorShapeUpdates = TRUE ; cl -> useRichCursorEncoding = FALSE ; cl -> cursorWasChanged = TRUE ; } break ; case rfbEncodingRichCursor : if ( ! cl -> enableCursorShapeUpdates ) { rfbLog ( \"Enabling<S2SV_blank>full-color<S2SV_blank>cursor<S2SV_blank>updates<S2SV_blank>for<S2SV_blank>client<S2SV_blank>%s\\\\n\" , cl -> host ) ; cl -> enableCursorShapeUpdates = TRUE ; cl -> useRichCursorEncoding = TRUE ; cl -> cursorWasChanged = TRUE ; } break ; case rfbEncodingPointerPos : if ( ! cl -> enableCursorPosUpdates ) { rfbLog ( \"Enabling<S2SV_blank>cursor<S2SV_blank>position<S2SV_blank>updates<S2SV_blank>for<S2SV_blank>client<S2SV_blank>%s\\\\n\" , cl -> host ) ; cl -> enableCursorPosUpdates = TRUE ; cl -> cursorWasMoved = TRUE ; cl -> cursorX = - 1 ; cl -> cursorY = - 1 ; } break ; case rfbEncodingLastRect : if ( ! cl -> enableLastRectEncoding ) { rfbLog ( \"Enabling<S2SV_blank>LastRect<S2SV_blank>protocol<S2SV_blank>extension<S2SV_blank>for<S2SV_blank>client<S2SV_blank>%s\\\\n\" , cl -> host ) ; cl -> enableLastRectEncoding = TRUE ; } break ; case rfbEncodingFence : if ( ! cl -> enableFence ) { rfbLog ( \"Enabling<S2SV_blank>Fence<S2SV_blank>protocol<S2SV_blank>extension<S2SV_blank>for<S2SV_blank>client<S2SV_blank>%s\\\\n\" , cl -> host ) ; cl -> enableFence = TRUE ; } break ; case rfbEncodingContinuousUpdates : if ( ! cl -> enableCU ) { rfbLog ( \"Enabling<S2SV_blank>Continuous<S2SV_blank>Updates<S2SV_blank>protocol<S2SV_blank>extension<S2SV_blank>for<S2SV_blank>client<S2SV_blank>%s\\\\n\" , cl -> host ) ; cl -> enableCU = TRUE ; } break ; case rfbEncodingNewFBSize : if ( ! cl -> enableDesktopSize ) { if ( ! rfbAuthDisableRemoteResize ) { rfbLog ( \"Enabling<S2SV_blank>Desktop<S2SV_blank>Size<S2SV_blank>protocol<S2SV_blank>extension<S2SV_blank>for<S2SV_blank>client<S2SV_blank>%s\\\\n\" , cl -> host ) ; cl -> enableDesktopSize = TRUE ; } else rfbLog ( \"WARNING:<S2SV_blank>Remote<S2SV_blank>desktop<S2SV_blank>resizing<S2SV_blank>disabled<S2SV_blank>per<S2SV_blank>system<S2SV_blank>policy.\\\\n\" ) ; } break ; case rfbEncodingExtendedDesktopSize : if ( ! cl -> enableExtDesktopSize ) { if ( ! rfbAuthDisableRemoteResize ) { rfbLog ( \"Enabling<S2SV_blank>Extended<S2SV_blank>Desktop<S2SV_blank>Size<S2SV_blank>protocol<S2SV_blank>extension<S2SV_blank>for<S2SV_blank>client<S2SV_blank>%s\\\\n\" , cl -> host ) ; cl -> enableExtDesktopSize = TRUE ; } else rfbLog ( \"WARNING:<S2SV_blank>Remote<S2SV_blank>desktop<S2SV_blank>resizing<S2SV_blank>disabled<S2SV_blank>per<S2SV_blank>system<S2SV_blank>policy.\\\\n\" ) ; } break ; case rfbEncodingGII : if ( ! cl -> enableGII ) { rfbLog ( \"Enabling<S2SV_blank>GII<S2SV_blank>extension<S2SV_blank>for<S2SV_blank>client<S2SV_blank>%s\\\\n\" , cl -> host ) ; cl -> enableGII = TRUE ; } break ; default : if ( enc >= ( CARD32 ) rfbEncodingCompressLevel0 && enc <= ( CARD32 ) rfbEncodingCompressLevel9 ) { cl -> zlibCompressLevel = enc & 0x0F ; cl -> tightCompressLevel = enc & 0x0F ; if ( cl -> preferredEncoding == rfbEncodingTight ) logTightCompressLevel = TRUE ; else rfbLog ( \"Using<S2SV_blank>compression<S2SV_blank>level<S2SV_blank>%d<S2SV_blank>for<S2SV_blank>client<S2SV_blank>%s\\\\n\" , cl -> tightCompressLevel , cl -> host ) ; if ( rfbInterframe == - 1 ) { if ( cl -> tightCompressLevel >= 5 ) { if ( ! InterframeOn ( cl ) ) { rfbCloseClient ( cl ) ; return ; } } else InterframeOff ( cl ) ; } } else if ( enc >= ( CARD32 ) rfbEncodingSubsamp1X && enc <= ( CARD32 ) rfbEncodingSubsampGray ) { cl -> tightSubsampLevel = enc & 0xFF ; rfbLog ( \"Using<S2SV_blank>JPEG<S2SV_blank>subsampling<S2SV_blank>%d<S2SV_blank>for<S2SV_blank>client<S2SV_blank>%s\\\\n\" , cl -> tightSubsampLevel , cl -> host ) ; } else if ( enc >= ( CARD32 ) rfbEncodingQualityLevel0 && enc <= ( CARD32 ) rfbEncodingQualityLevel9 ) { cl -> tightQualityLevel = JPEG_QUAL [ enc & 0x0F ] ; cl -> tightSubsampLevel = JPEG_SUBSAMP [ enc & 0x0F ] ; cl -> imageQualityLevel = enc & 0x0F ; if ( cl -> preferredEncoding == rfbEncodingTight ) rfbLog ( \"Using<S2SV_blank>JPEG<S2SV_blank>subsampling<S2SV_blank>%d,<S2SV_blank>Q%d<S2SV_blank>for<S2SV_blank>client<S2SV_blank>%s\\\\n\" , cl -> tightSubsampLevel , cl -> tightQualityLevel , cl -> host ) ; else rfbLog ( \"Using<S2SV_blank>image<S2SV_blank>quality<S2SV_blank>level<S2SV_blank>%d<S2SV_blank>for<S2SV_blank>client<S2SV_blank>%s\\\\n\" , cl -> imageQualityLevel , cl -> host ) ; } else if ( enc >= ( CARD32 ) rfbEncodingFineQualityLevel0 + 1 && enc <= ( CARD32 ) rfbEncodingFineQualityLevel100 ) { cl -> tightQualityLevel = enc & 0xFF ; rfbLog ( \"Using<S2SV_blank>JPEG<S2SV_blank>quality<S2SV_blank>%d<S2SV_blank>for<S2SV_blank>client<S2SV_blank>%s\\\\n\" , cl -> tightQualityLevel , cl -> host ) ; } else { rfbLog ( \"rfbProcessClientNormalMessage:<S2SV_blank>ignoring<S2SV_blank>unknown<S2SV_blank>encoding<S2SV_blank>%d<S2SV_blank>(%x)\\\\n\" , ( int ) enc , ( int ) enc ) ; } } } if ( cl -> preferredEncoding == - 1 ) cl -> preferredEncoding = rfbEncodingTight ; if ( cl -> preferredEncoding == rfbEncodingTight && logTightCompressLevel ) rfbLog ( \"Using<S2SV_blank>Tight<S2SV_blank>compression<S2SV_blank>level<S2SV_blank>%d<S2SV_blank>for<S2SV_blank>client<S2SV_blank>%s\\\\n\" , rfbTightCompressLevel ( cl ) , cl -> host ) ; if ( cl -> enableCursorPosUpdates && ! cl -> enableCursorShapeUpdates ) { rfbLog ( \"Disabling<S2SV_blank>cursor<S2SV_blank>position<S2SV_blank>updates<S2SV_blank>for<S2SV_blank>client<S2SV_blank>%s\\\\n\" , cl -> host ) ; cl -> enableCursorPosUpdates = FALSE ; } if ( cl -> enableFence && firstFence ) { if ( ! rfbSendFence ( cl , rfbFenceFlagRequest , 0 , NULL ) ) return ; } if ( cl -> enableCU && cl -> enableFence && firstCU ) { if ( ! rfbSendEndOfCU ( cl ) ) return ; } if ( cl -> enableGII && firstGII ) { rfbGIIServerVersionMsg msg ; msg . type = rfbGIIServer ; msg . endianAndSubType = rfbGIIVersion | rfbGIIBE ; msg . length = Swap16IfLE ( sz_rfbGIIServerVersionMsg - 4 ) ; msg . maximumVersion = msg . minimumVersion = Swap16IfLE ( 1 ) ; if ( WriteExact ( cl , ( char * ) & msg , sz_rfbGIIServerVersionMsg ) < 0 ) { rfbLogPerror ( \"rfbProcessClientNormalMessage:<S2SV_blank>write\" ) ; rfbCloseClient ( cl ) ; return ; } } return ; } case rfbFramebufferUpdateRequest : { RegionRec tmpRegion ; BoxRec box ; READ ( ( ( char * ) & msg ) + 1 , sz_rfbFramebufferUpdateRequestMsg - 1 ) box . x1 = Swap16IfLE ( msg . fur . x ) ; box . y1 = Swap16IfLE ( msg . fur . y ) ; box . x2 = box . x1 + Swap16IfLE ( msg . fur . w ) ; box . y2 = box . y1 + Swap16IfLE ( msg . fur . h ) ; SAFE_REGION_INIT ( pScreen , & tmpRegion , & box , 0 ) ; if ( ! msg . fur . incremental || ! cl -> continuousUpdates ) REGION_UNION ( pScreen , & cl -> requestedRegion , & cl -> requestedRegion , & tmpRegion ) ; if ( ! cl -> readyForSetColourMapEntries ) { cl -> readyForSetColourMapEntries = TRUE ; if ( ! cl -> format . trueColour ) { if ( ! rfbSetClientColourMap ( cl , 0 , 0 ) ) { REGION_UNINIT ( pScreen , & tmpRegion ) ; return ; } } } if ( ! msg . fur . incremental ) { REGION_UNION ( pScreen , & cl -> modifiedRegion , & cl -> modifiedRegion , & tmpRegion ) ; REGION_SUBTRACT ( pScreen , & cl -> copyRegion , & cl -> copyRegion , & tmpRegion ) ; REGION_UNION ( pScreen , & cl -> ifRegion , & cl -> ifRegion , & tmpRegion ) ; cl -> pendingExtDesktopResize = TRUE ; } if ( FB_UPDATE_PENDING ( cl ) && ( ! cl -> deferredUpdateScheduled || rfbDeferUpdateTime == 0 || gettime ( ) - cl -> deferredUpdateStart >= ( double ) rfbDeferUpdateTime ) ) { if ( rfbSendFramebufferUpdate ( cl ) ) cl -> deferredUpdateScheduled = FALSE ; } REGION_UNINIT ( pScreen , & tmpRegion ) ; return ; } case rfbKeyEvent : cl -> rfbKeyEventsRcvd ++ ; READ ( ( ( char * ) & msg ) + 1 , sz_rfbKeyEventMsg - 1 ) if ( ! rfbViewOnly && ! cl -> viewOnly ) KeyEvent ( ( KeySym ) Swap32IfLE ( msg . ke . key ) , msg . ke . down ) ; return ; case rfbPointerEvent : cl -> rfbPointerEventsRcvd ++ ; READ ( ( ( char * ) & msg ) + 1 , sz_rfbPointerEventMsg - 1 ) if ( pointerClient && ( pointerClient != cl ) ) return ; if ( msg . pe . buttonMask == 0 ) pointerClient = NULL ; else pointerClient = cl ; if ( ! rfbViewOnly && ! cl -> viewOnly ) { cl -> cursorX = ( int ) Swap16IfLE ( msg . pe . x ) ; cl -> cursorY = ( int ) Swap16IfLE ( msg . pe . y ) ; PtrAddEvent ( msg . pe . buttonMask , cl -> cursorX , cl -> cursorY , cl ) ; } return ; case rfbClientCutText : { int ignoredBytes = 0 ; READ ( ( ( char * ) & msg ) + 1 , sz_rfbClientCutTextMsg - 1 ) msg . cct . length = Swap32IfLE ( msg . cct . length ) ; if ( msg . cct . length > rfbMaxClipboard ) { rfbLog ( \"Truncating<S2SV_blank>%d-byte<S2SV_blank>clipboard<S2SV_blank>update<S2SV_blank>to<S2SV_blank>%d<S2SV_blank>bytes.\\\\n\" , msg . cct . length , rfbMaxClipboard ) ; ignoredBytes = msg . cct . length - rfbMaxClipboard ; msg . cct . length = rfbMaxClipboard ; } if ( msg . cct . length <= 0 ) return ; str = ( char * ) malloc ( msg . cct . length ) ; if ( str == NULL ) { rfbLogPerror ( \"rfbProcessClientNormalMessage:<S2SV_blank>rfbClientCutText<S2SV_blank>out<S2SV_blank>of<S2SV_blank>memory\" ) ; rfbCloseClient ( cl ) ; return ; } if ( ( n = ReadExact ( cl , str , msg . cct . length ) ) <= 0 ) { if ( n != 0 ) rfbLogPerror ( \"rfbProcessClientNormalMessage:<S2SV_blank>read\" ) ; free ( str ) ; rfbCloseClient ( cl ) ; return ; } if ( ignoredBytes > 0 ) { if ( ( n = SkipExact ( cl , ignoredBytes ) ) <= 0 ) { if ( n != 0 ) rfbLogPerror ( \"rfbProcessClientNormalMessage:<S2SV_blank>read\" ) ; free ( str ) ; rfbCloseClient ( cl ) ; return ; } } if ( ! rfbViewOnly && ! cl -> viewOnly && ! rfbAuthDisableCBRecv ) { vncClientCutText ( str , msg . cct . length ) ; if ( rfbSyncCutBuffer ) rfbSetXCutText ( str , msg . cct . length ) ; } free ( str ) ; return ; } case rfbEnableContinuousUpdates : { BoxRec box ; READ ( ( ( char * ) & msg ) + 1 , sz_rfbEnableContinuousUpdatesMsg - 1 ) if ( ! cl -> enableFence || ! cl -> enableCU ) { rfbLog ( \"Ignoring<S2SV_blank>request<S2SV_blank>to<S2SV_blank>enable<S2SV_blank>continuous<S2SV_blank>updates<S2SV_blank>because<S2SV_blank>the<S2SV_blank>client<S2SV_blank>does<S2SV_blank>not\\\\n\" ) ; rfbLog ( \"support<S2SV_blank>the<S2SV_blank>flow<S2SV_blank>control<S2SV_blank>extensions.\\\\n\" ) ; return ; } box . x1 = Swap16IfLE ( msg . ecu . x ) ; box . y1 = Swap16IfLE ( msg . ecu . y ) ; box . x2 = box . x1 + Swap16IfLE ( msg . ecu . w ) ; box . y2 = box . y1 + Swap16IfLE ( msg . ecu . h ) ; SAFE_REGION_INIT ( pScreen , & cl -> cuRegion , & box , 0 ) ; cl -> continuousUpdates = msg . ecu . enable ; if ( cl -> continuousUpdates ) { REGION_EMPTY ( pScreen , & cl -> requestedRegion ) ; if ( ! rfbSendFramebufferUpdate ( cl ) ) return ; } else { if ( ! rfbSendEndOfCU ( cl ) ) return ; } rfbLog ( \"Continuous<S2SV_blank>updates<S2SV_blank>%s\\\\n\" , cl -> continuousUpdates ? \"enabled\" : \"disabled\" ) ; return ; } case rfbFence : { CARD32 flags ; char data [ 64 ] ; READ ( ( ( char * ) & msg ) + 1 , sz_rfbFenceMsg - 1 ) flags = Swap32IfLE ( msg . f . flags ) ; <S2SV_StartBug> READ ( data , msg . f . length ) <S2SV_EndBug> <S2SV_StartBug> if ( msg . f . length > sizeof ( data ) ) <S2SV_EndBug> rfbLog ( \"Ignoring<S2SV_blank>fence.<S2SV_blank><S2SV_blank>Payload<S2SV_blank>of<S2SV_blank>%d<S2SV_blank>bytes<S2SV_blank>is<S2SV_blank>too<S2SV_blank>large.\\\\n\" , msg . f . length ) ; <S2SV_StartBug> else <S2SV_EndBug> <S2SV_StartBug> HandleFence ( cl , flags , msg . f . length , data ) ; <S2SV_EndBug> return ; } # define EDSERROR ( format , args ... ) { if ( ! strlen ( errMsg ) ) snprintf ( errMsg , 256 , \"Desktop<S2SV_blank>resize<S2SV_blank>ERROR:<S2SV_blank>\" format \"\\\\n\" , args ) ; result = rfbEDSResultInvalid ; } case rfbSetDesktopSize : { int i ; struct xorg_list newScreens ; rfbClientPtr cl2 ; int result = rfbEDSResultSuccess ; char errMsg [ 256 ] = \"\\\\0\" ; ScreenPtr pScreen = screenInfo . screens [ 0 ] ; READ ( ( ( char * ) & msg ) + 1 , sz_rfbSetDesktopSizeMsg - 1 ) if ( msg . sds . numScreens < 1 ) EDSERROR ( \"Requested<S2SV_blank>number<S2SV_blank>of<S2SV_blank>screens<S2SV_blank>%d<S2SV_blank>is<S2SV_blank>invalid\" , msg . sds . numScreens ) ; msg . sds . w = Swap16IfLE ( msg . sds . w ) ; msg . sds . h = Swap16IfLE ( msg . sds . h ) ; if ( msg . sds . w < 1 || msg . sds . h < 1 ) EDSERROR ( \"Requested<S2SV_blank>framebuffer<S2SV_blank>dimensions<S2SV_blank>%dx%d<S2SV_blank>are<S2SV_blank>invalid\" , msg . sds . w , msg . sds . h ) ; xorg_list_init ( & newScreens ) ; for ( i = 0 ; i < msg . sds . numScreens ; i ++ ) { rfbScreenInfo * screen = rfbNewScreen ( 0 , 0 , 0 , 0 , 0 , 0 ) ; READ ( ( char * ) & screen -> s , sizeof ( rfbScreenDesc ) ) screen -> s . id = Swap32IfLE ( screen -> s . id ) ; screen -> s . x = Swap16IfLE ( screen -> s . x ) ; screen -> s . y = Swap16IfLE ( screen -> s . y ) ; screen -> s . w = Swap16IfLE ( screen -> s . w ) ; screen -> s . h = Swap16IfLE ( screen -> s . h ) ; screen -> s . flags = Swap32IfLE ( screen -> s . flags ) ; if ( screen -> s . w < 1 || screen -> s . h < 1 ) EDSERROR ( \"Screen<S2SV_blank>0x%.8x<S2SV_blank>requested<S2SV_blank>dimensions<S2SV_blank>%dx%d<S2SV_blank>are<S2SV_blank>invalid\" , ( unsigned int ) screen -> s . id , screen -> s . w , screen -> s . h ) ; if ( screen -> s . x >= msg . sds . w || screen -> s . y >= msg . sds . h || screen -> s . x + screen -> s . w > msg . sds . w || screen -> s . y + screen -> s . h > msg . sds . h ) EDSERROR ( \"Screen<S2SV_blank>0x%.8x<S2SV_blank>requested<S2SV_blank>geometry<S2SV_blank>%dx%d+%d+%d<S2SV_blank>exceeds<S2SV_blank>requested<S2SV_blank>framebuffer<S2SV_blank>dimensions\" , ( unsigned int ) screen -> s . id , screen -> s . w , screen -> s . h , screen -> s . x , screen -> s . y ) ; if ( rfbFindScreenID ( & newScreens , screen -> s . id ) ) { EDSERROR ( \"Screen<S2SV_blank>0x%.8x<S2SV_blank>duplicate<S2SV_blank>ID\" , ( unsigned int ) screen -> s . id ) ; free ( screen ) ; } else rfbAddScreen ( & newScreens , screen ) ; } if ( cl -> viewOnly ) { rfbLog ( \"NOTICE:<S2SV_blank>Ignoring<S2SV_blank>remote<S2SV_blank>desktop<S2SV_blank>resize<S2SV_blank>request<S2SV_blank>from<S2SV_blank>a<S2SV_blank>view-only<S2SV_blank>client.\\\\n\" ) ; result = rfbEDSResultProhibited ; } else if ( result == rfbEDSResultSuccess ) { result = ResizeDesktop ( pScreen , cl , msg . sds . w , msg . sds . h , & newScreens ) ; if ( result == rfbEDSResultSuccess ) return ; } else rfbLog ( errMsg ) ; rfbRemoveScreens ( & newScreens ) ; for ( cl2 = rfbClientHead ; cl2 ; cl2 = cl2 -> next ) { if ( cl2 == cl ) { cl2 -> pendingExtDesktopResize = TRUE ; cl2 -> reason = rfbEDSReasonClient ; cl2 -> result = result ; rfbSendFramebufferUpdate ( cl2 ) ; break ; } } return ; } case rfbGIIClient : { CARD8 endianAndSubType , littleEndian , subType ; READ ( ( char * ) & endianAndSubType , 1 ) ; littleEndian = ( endianAndSubType & rfbGIIBE ) ? 0 : 1 ; subType = endianAndSubType & ~ rfbGIIBE ; switch ( subType ) { case rfbGIIVersion : READ ( ( char * ) & msg . giicv . length , sz_rfbGIIClientVersionMsg - 2 ) ; if ( littleEndian != * ( const char * ) & rfbEndianTest ) { msg . giicv . length = Swap16 ( msg . giicv . length ) ; msg . giicv . version = Swap16 ( msg . giicv . version ) ; } if ( msg . giicv . length != sz_rfbGIIClientVersionMsg - 4 || msg . giicv . version < 1 ) { rfbLog ( \"ERROR:<S2SV_blank>Malformed<S2SV_blank>GII<S2SV_blank>client<S2SV_blank>version<S2SV_blank>message\\\\n\" ) ; rfbCloseClient ( cl ) ; return ; } rfbLog ( \"Client<S2SV_blank>supports<S2SV_blank>GII<S2SV_blank>version<S2SV_blank>%d\\\\n\" , msg . giicv . version ) ; break ; case rfbGIIDeviceCreate : { int i ; rfbDevInfo dev ; rfbGIIDeviceCreatedMsg dcmsg ; memset ( & dev , 0 , sizeof ( dev ) ) ; dcmsg . deviceOrigin = 0 ; READ ( ( char * ) & msg . giidc . length , sz_rfbGIIDeviceCreateMsg - 2 ) ; if ( littleEndian != * ( const char * ) & rfbEndianTest ) { msg . giidc . length = Swap16 ( msg . giidc . length ) ; msg . giidc . vendorID = Swap32 ( msg . giidc . vendorID ) ; msg . giidc . productID = Swap32 ( msg . giidc . productID ) ; msg . giidc . canGenerate = Swap32 ( msg . giidc . canGenerate ) ; msg . giidc . numRegisters = Swap32 ( msg . giidc . numRegisters ) ; msg . giidc . numValuators = Swap32 ( msg . giidc . numValuators ) ; msg . giidc . numButtons = Swap32 ( msg . giidc . numButtons ) ; } rfbLog ( \"GII<S2SV_blank>Device<S2SV_blank>Create:<S2SV_blank>%s\\\\n\" , msg . giidc . deviceName ) ; # ifdef GII_DEBUG rfbLog ( \"<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Vendor<S2SV_blank>ID:<S2SV_blank>%d\\\\n\" , msg . giidc . vendorID ) ; rfbLog ( \"<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Product<S2SV_blank>ID:<S2SV_blank>%d\\\\n\" , msg . giidc . productID ) ; rfbLog ( \"<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Event<S2SV_blank>mask:<S2SV_blank>%.8x\\\\n\" , msg . giidc . canGenerate ) ; rfbLog ( \"<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Registers:<S2SV_blank>%d\\\\n\" , msg . giidc . numRegisters ) ; rfbLog ( \"<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Valuators:<S2SV_blank>%d\\\\n\" , msg . giidc . numValuators ) ; rfbLog ( \"<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Buttons:<S2SV_blank>%d\\\\n\" , msg . giidc . numButtons ) ; # endif if ( msg . giidc . length != sz_rfbGIIDeviceCreateMsg - 4 + msg . giidc . numValuators * sz_rfbGIIValuator ) { rfbLog ( \"ERROR:<S2SV_blank>Malformed<S2SV_blank>GII<S2SV_blank>device<S2SV_blank>create<S2SV_blank>message\\\\n\" ) ; rfbCloseClient ( cl ) ; return ; } if ( msg . giidc . numButtons > MAX_BUTTONS ) { rfbLog ( \"GII<S2SV_blank>device<S2SV_blank>create<S2SV_blank>ERROR:<S2SV_blank>%d<S2SV_blank>buttons<S2SV_blank>exceeds<S2SV_blank>max<S2SV_blank>of<S2SV_blank>%d\\\\n\" , msg . giidc . numButtons , MAX_BUTTONS ) ; SKIP ( msg . giidc . numValuators * sz_rfbGIIValuator ) ; goto sendMessage ; } if ( msg . giidc . numValuators > MAX_VALUATORS ) { rfbLog ( \"GII<S2SV_blank>device<S2SV_blank>create<S2SV_blank>ERROR:<S2SV_blank>%d<S2SV_blank>valuators<S2SV_blank>exceeds<S2SV_blank>max<S2SV_blank>of<S2SV_blank>%d\\\\n\" , msg . giidc . numValuators , MAX_VALUATORS ) ; SKIP ( msg . giidc . numValuators * sz_rfbGIIValuator ) ; goto sendMessage ; } memcpy ( & dev . name , msg . giidc . deviceName , 32 ) ; dev . numButtons = msg . giidc . numButtons ; dev . numValuators = msg . giidc . numValuators ; dev . eventMask = msg . giidc . canGenerate ; dev . mode = ( dev . eventMask & rfbGIIValuatorAbsoluteMask ) ? Absolute : Relative ; dev . productID = msg . giidc . productID ; if ( dev . mode == Relative ) { rfbLog ( \"GII<S2SV_blank>device<S2SV_blank>create<S2SV_blank>ERROR:<S2SV_blank>relative<S2SV_blank>valuators<S2SV_blank>not<S2SV_blank>supported<S2SV_blank>(yet)\\\\n\" ) ; SKIP ( msg . giidc . numValuators * sz_rfbGIIValuator ) ; goto sendMessage ; } for ( i = 0 ; i < dev . numValuators ; i ++ ) { rfbGIIValuator * v = & dev . valuators [ i ] ; READ ( ( char * ) v , sz_rfbGIIValuator ) ; if ( littleEndian != * ( const char * ) & rfbEndianTest ) { v -> index = Swap32 ( v -> index ) ; v -> rangeMin = Swap32 ( ( CARD32 ) v -> rangeMin ) ; v -> rangeCenter = Swap32 ( ( CARD32 ) v -> rangeCenter ) ; v -> rangeMax = Swap32 ( ( CARD32 ) v -> rangeMax ) ; v -> siUnit = Swap32 ( v -> siUnit ) ; v -> siAdd = Swap32 ( ( CARD32 ) v -> siAdd ) ; v -> siMul = Swap32 ( ( CARD32 ) v -> siMul ) ; v -> siDiv = Swap32 ( ( CARD32 ) v -> siDiv ) ; v -> siShift = Swap32 ( ( CARD32 ) v -> siShift ) ; } # ifdef GII_DEBUG rfbLog ( \"<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Valuator:<S2SV_blank>%s<S2SV_blank>(%s)\\\\n\" , v -> longName , v -> shortName ) ; rfbLog ( \"<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Index:<S2SV_blank>%d\\\\n\" , v -> index ) ; rfbLog ( \"<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Range:<S2SV_blank>min<S2SV_blank>=<S2SV_blank>%d,<S2SV_blank>center<S2SV_blank>=<S2SV_blank>%d,<S2SV_blank>max<S2SV_blank>=<S2SV_blank>%d\\\\n\" , v -> rangeMin , v -> rangeCenter , v -> rangeMax ) ; rfbLog ( \"<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>SI<S2SV_blank>unit:<S2SV_blank>%d\\\\n\" , v -> siUnit ) ; rfbLog ( \"<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>SI<S2SV_blank>add:<S2SV_blank>%d\\\\n\" , v -> siAdd ) ; rfbLog ( \"<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>SI<S2SV_blank>multiply:<S2SV_blank>%d\\\\n\" , v -> siMul ) ; rfbLog ( \"<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>SI<S2SV_blank>divide:<S2SV_blank>%d\\\\n\" , v -> siDiv ) ; rfbLog ( \"<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>SI<S2SV_blank>shift:<S2SV_blank>%d\\\\n\" , v -> siShift ) ; # endif } for ( i = 0 ; i < cl -> numDevices ; i ++ ) { if ( ! strcmp ( dev . name , cl -> devices [ i ] . name ) ) { rfbLog ( \"Device<S2SV_blank>\\\\\\'%s\\\\\\'<S2SV_blank>already<S2SV_blank>exists<S2SV_blank>with<S2SV_blank>GII<S2SV_blank>device<S2SV_blank>ID<S2SV_blank>%d\\\\n\" , dev . name , i + 1 ) ; dcmsg . deviceOrigin = Swap32IfLE ( i + 1 ) ; goto sendMessage ; } } if ( rfbVirtualTablet || AddExtInputDevice ( & dev ) ) { memcpy ( & cl -> devices [ cl -> numDevices ] , & dev , sizeof ( dev ) ) ; cl -> numDevices ++ ; dcmsg . deviceOrigin = Swap32IfLE ( cl -> numDevices ) ; } rfbLog ( \"GII<S2SV_blank>device<S2SV_blank>ID<S2SV_blank>=<S2SV_blank>%d\\\\n\" , cl -> numDevices ) ; sendMessage : dcmsg . type = rfbGIIServer ; dcmsg . endianAndSubType = rfbGIIDeviceCreate | rfbGIIBE ; dcmsg . length = Swap16IfLE ( sz_rfbGIIDeviceCreatedMsg - 4 ) ; if ( WriteExact ( cl , ( char * ) & dcmsg , sz_rfbGIIDeviceCreatedMsg ) < 0 ) { rfbLogPerror ( \"rfbProcessClientNormalMessage:<S2SV_blank>write\" ) ; rfbCloseClient ( cl ) ; return ; } break ; } case rfbGIIDeviceDestroy : READ ( ( char * ) & msg . giidd . length , sz_rfbGIIDeviceDestroyMsg - 2 ) ; if ( littleEndian != * ( const char * ) & rfbEndianTest ) { msg . giidd . length = Swap16 ( msg . giidd . length ) ; msg . giidd . deviceOrigin = Swap32 ( msg . giidd . deviceOrigin ) ; } if ( msg . giidd . length != sz_rfbGIIDeviceDestroyMsg - 4 ) { rfbLog ( \"ERROR:<S2SV_blank>Malformed<S2SV_blank>GII<S2SV_blank>device<S2SV_blank>create<S2SV_blank>message\\\\n\" ) ; rfbCloseClient ( cl ) ; return ; } RemoveExtInputDevice ( cl , msg . giidd . deviceOrigin - 1 ) ; break ; case rfbGIIEvent : { CARD16 length ; READ ( ( char * ) & length , sizeof ( CARD16 ) ) ; if ( littleEndian != * ( const char * ) & rfbEndianTest ) length = Swap16 ( length ) ; while ( length > 0 ) { CARD8 eventSize , eventType ; READ ( ( char * ) & eventSize , 1 ) ; READ ( ( char * ) & eventType , 1 ) ; switch ( eventType ) { case rfbGIIButtonPress : case rfbGIIButtonRelease : { rfbGIIButtonEvent b ; rfbDevInfo * dev ; READ ( ( char * ) & b . pad , sz_rfbGIIButtonEvent - 2 ) ; if ( littleEndian != * ( const char * ) & rfbEndianTest ) { b . deviceOrigin = Swap32 ( b . deviceOrigin ) ; b . buttonNumber = Swap32 ( b . buttonNumber ) ; } if ( eventSize != sz_rfbGIIButtonEvent || b . deviceOrigin <= 0 || b . buttonNumber < 1 ) { rfbLog ( \"ERROR:<S2SV_blank>Malformed<S2SV_blank>GII<S2SV_blank>button<S2SV_blank>event\\\\n\" ) ; rfbCloseClient ( cl ) ; return ; } if ( eventSize > length ) { rfbLog ( \"ERROR:<S2SV_blank>Malformed<S2SV_blank>GII<S2SV_blank>event<S2SV_blank>message\\\\n\" ) ; rfbCloseClient ( cl ) ; return ; } length -= eventSize ; if ( b . deviceOrigin < 1 || b . deviceOrigin > cl -> numDevices ) { rfbLog ( \"ERROR:<S2SV_blank>GII<S2SV_blank>button<S2SV_blank>event<S2SV_blank>from<S2SV_blank>non-existent<S2SV_blank>device<S2SV_blank>%d\\\\n\" , b . deviceOrigin ) ; rfbCloseClient ( cl ) ; return ; } dev = & cl -> devices [ b . deviceOrigin - 1 ] ; if ( ( eventType == rfbGIIButtonPress && ( dev -> eventMask & rfbGIIButtonPressMask ) == 0 ) || ( eventType == rfbGIIButtonRelease && ( dev -> eventMask & rfbGIIButtonReleaseMask ) == 0 ) ) { rfbLog ( \"ERROR:<S2SV_blank>Device<S2SV_blank>%d<S2SV_blank>can\\'t<S2SV_blank>generate<S2SV_blank>GII<S2SV_blank>button<S2SV_blank>events\\\\n\" , b . deviceOrigin ) ; rfbCloseClient ( cl ) ; return ; } if ( b . buttonNumber > dev -> numButtons ) { rfbLog ( \"ERROR:<S2SV_blank>GII<S2SV_blank>button<S2SV_blank>%d<S2SV_blank>event<S2SV_blank>for<S2SV_blank>device<S2SV_blank>%d<S2SV_blank>exceeds<S2SV_blank>button<S2SV_blank>count<S2SV_blank>(%d)\\\\n\" , b . buttonNumber , b . deviceOrigin , dev -> numButtons ) ; rfbCloseClient ( cl ) ; return ; } # ifdef GII_DEBUG rfbLog ( \"Device<S2SV_blank>%d<S2SV_blank>button<S2SV_blank>%d<S2SV_blank>%s\\\\n\" , b . deviceOrigin , b . buttonNumber , eventType == rfbGIIButtonPress ? \"PRESS\" : \"release\" ) ; fflush ( stderr ) ; # endif ExtInputAddEvent ( dev , eventType == rfbGIIButtonPress ? ButtonPress : ButtonRelease , b . buttonNumber ) ; break ; } case rfbGIIValuatorRelative : case rfbGIIValuatorAbsolute : { rfbGIIValuatorEvent v ; int i ; rfbDevInfo * dev ; READ ( ( char * ) & v . pad , sz_rfbGIIValuatorEvent - 2 ) ; if ( littleEndian != * ( const char * ) & rfbEndianTest ) { v . deviceOrigin = Swap32 ( v . deviceOrigin ) ; v . first = Swap32 ( v . first ) ; v . count = Swap32 ( v . count ) ; } if ( eventSize != sz_rfbGIIValuatorEvent + sizeof ( int ) * v . count ) { rfbLog ( \"ERROR:<S2SV_blank>Malformed<S2SV_blank>GII<S2SV_blank>valuator<S2SV_blank>event\\\\n\" ) ; rfbCloseClient ( cl ) ; return ; } if ( eventSize > length ) { rfbLog ( \"ERROR:<S2SV_blank>Malformed<S2SV_blank>GII<S2SV_blank>event<S2SV_blank>message\\\\n\" ) ; rfbCloseClient ( cl ) ; return ; } length -= eventSize ; if ( v . deviceOrigin < 1 || v . deviceOrigin > cl -> numDevices ) { rfbLog ( \"ERROR:<S2SV_blank>GII<S2SV_blank>valuator<S2SV_blank>event<S2SV_blank>from<S2SV_blank>non-existent<S2SV_blank>device<S2SV_blank>%d\\\\n\" , v . deviceOrigin ) ; rfbCloseClient ( cl ) ; return ; } dev = & cl -> devices [ v . deviceOrigin - 1 ] ; if ( ( eventType == rfbGIIValuatorRelative && ( dev -> eventMask & rfbGIIValuatorRelativeMask ) == 0 ) || ( eventType == rfbGIIValuatorAbsolute && ( dev -> eventMask & rfbGIIValuatorAbsoluteMask ) == 0 ) ) { rfbLog ( \"ERROR:<S2SV_blank>Device<S2SV_blank>%d<S2SV_blank>cannot<S2SV_blank>generate<S2SV_blank>GII<S2SV_blank>valuator<S2SV_blank>events\\\\n\" , v . deviceOrigin ) ; rfbCloseClient ( cl ) ; return ; } if ( v . first + v . count > dev -> numValuators ) { rfbLog ( \"ERROR:<S2SV_blank>GII<S2SV_blank>valuator<S2SV_blank>event<S2SV_blank>for<S2SV_blank>device<S2SV_blank>%d<S2SV_blank>exceeds<S2SV_blank>valuator<S2SV_blank>count<S2SV_blank>(%d)\\\\n\" , v . deviceOrigin , dev -> numValuators ) ; rfbCloseClient ( cl ) ; return ; } # ifdef GII_DEBUG rfbLog ( \"Device<S2SV_blank>%d<S2SV_blank>Valuator<S2SV_blank>%s<S2SV_blank>first=%d<S2SV_blank>count=%d:\\\\n\" , v . deviceOrigin , eventType == rfbGIIValuatorRelative ? \"rel\" : \"ABS\" , v . first , v . count ) ; # endif for ( i = v . first ; i < v . first + v . count ; i ++ ) { READ ( ( char * ) & dev -> values [ i ] , sizeof ( int ) ) ; if ( littleEndian != * ( const char * ) & rfbEndianTest ) dev -> values [ i ] = Swap32 ( ( CARD32 ) dev -> values [ i ] ) ; # ifdef GII_DEBUG fprintf ( stderr , \"v[%d]=%d<S2SV_blank>\" , i , dev -> values [ i ] ) ; # endif } # ifdef GII_DEBUG fprintf ( stderr , \"\\\\n\" ) ; # endif if ( v . count > 0 ) { dev -> valFirst = v . first ; dev -> valCount = v . count ; dev -> mode = eventType == rfbGIIValuatorAbsolute ? Absolute : Relative ; ExtInputAddEvent ( dev , MotionNotify , 0 ) ; } break ; } default : rfbLog ( \"ERROR:<S2SV_blank>This<S2SV_blank>server<S2SV_blank>cannot<S2SV_blank>handle<S2SV_blank>GII<S2SV_blank>event<S2SV_blank>type<S2SV_blank>%d\\\\n\" , eventType ) ; rfbCloseClient ( cl ) ; return ; } } if ( length != 0 ) { rfbLog ( \"ERROR:<S2SV_blank>Malformed<S2SV_blank>GII<S2SV_blank>event<S2SV_blank>message\\\\n\" ) ; rfbCloseClient ( cl ) ; return ; } break ; } } return ; } default : rfbLog ( \"rfbProcessClientNormalMessage:<S2SV_blank>unknown<S2SV_blank>message<S2SV_blank>type<S2SV_blank>%d\\\\n\" , msg . type ) ; rfbLog ( \"<S2SV_blank>...<S2SV_blank>closing<S2SV_blank>connection\\\\n\" ) ; rfbCloseClient ( cl ) ; return ; } }\n",
      "fixed_code": "<S2SV_ModStart> flags ) ; <S2SV_ModEnd> if ( msg <S2SV_ModStart> data ) ) { <S2SV_ModStart> length ) ; SKIP ( msg . f . length ) } else { READ ( data , msg . f . length ) <S2SV_ModEnd> HandleFence ( cl <S2SV_ModStart> data ) ; }\n",
      "source_code_length": 32118,
      "target_code_length": 229,
      "vulnerability_patterns": {
        "buffer_overflow": 3,
        "use_after_free": 11,
        "integer_overflow": 10,
        "format_string": 3,
        "null_pointer": 243,
        "sql_injection": 7,
        "memory_leak": 1,
        "total": 278
      },
      "total_patterns": 278,
      "original_address": "https://github.com/TurboVNC/turbovnc/commit/cea98166008301e614e0d36776bf9435a536136e",
      "discovery_time": "2019-10-29T19:15Z",
      "project_commit_id": "TurboVNC@turbovnc/cea98166008301e614e0d36776bf9435a536136e",
      "extraction_time": "2025-08-31T15:41:49.176835",
      "label": 1,
      "vulnerability_type": "out-of-bounds_write",
      "difficulty_level": "expert",
      "risk_factors": [
        "memory_corruption",
        "sql_injection",
        "arbitrary_code_execution",
        "buffer_overflow",
        "system_crash",
        "use_after_free"
      ],
      "attack_vectors": [
        "memory_manipulation",
        "malicious_input",
        "code_analysis",
        "buffer_overflow",
        "reverse_engineering",
        "fuzzing"
      ],
      "mitigation_strategies": [
        "safe_string_functions",
        "dynamic_analysis",
        "code_review",
        "static_analysis",
        "memory_safety_checks",
        "input_validation",
        "fuzzing",
        "bounds_checking",
        "secure_coding_practices"
      ],
      "code_differences": {
        "has_differences": true,
        "source_lines": 2,
        "target_lines": 2,
        "character_differences": 31889,
        "similarity_percentage": 3.7815126050420167
      },
      "vulnerability_location": {
        "vulnerability_present": true,
        "fix_applied": true,
        "code_changed": true,
        "estimated_lines_changed": 0
      }
    },
    {
      "cve_id": "CVE-2011-2517",
      "cwe_id": "CWE-119",
      "cwe_name": "Buffer Overflow",
      "project": "torvalds",
      "severity": "critical",
      "weaponization_score": 10.0,
      "is_critical": true,
      "is_weaponizable": true,
      "is_high_priority_project": false,
      "vulnerable_code": "CWE-119 static int nl80211_trigger_scan ( struct sk_buff * skb , struct genl_info * info ) { struct cfg80211_registered_device * rdev = info -> user_ptr [ 0 ] ; struct net_device * dev = info -> user_ptr [ 1 ] ; struct cfg80211_scan_request * request ; struct nlattr * attr ; struct wiphy * wiphy ; int err , tmp , n_ssids = 0 , n_channels , i ; enum ieee80211_band band ; size_t ie_len ; if ( ! is_valid_ie_attr ( info -> attrs [ NL80211_ATTR_IE ] ) ) return - EINVAL ; wiphy = & rdev -> wiphy ; if ( ! rdev -> ops -> scan ) return - EOPNOTSUPP ; if ( rdev -> scan_req ) return - EBUSY ; if ( info -> attrs [ NL80211_ATTR_SCAN_FREQUENCIES ] ) { n_channels = validate_scan_freqs ( info -> attrs [ NL80211_ATTR_SCAN_FREQUENCIES ] ) ; if ( ! n_channels ) return - EINVAL ; } else { n_channels = 0 ; for ( band = 0 ; band < IEEE80211_NUM_BANDS ; band ++ ) if ( wiphy -> bands [ band ] ) n_channels += wiphy -> bands [ band ] -> n_channels ; } if ( info -> attrs [ NL80211_ATTR_SCAN_SSIDS ] ) nla_for_each_nested ( attr , info -> attrs [ NL80211_ATTR_SCAN_SSIDS ] , tmp ) n_ssids ++ ; if ( n_ssids > wiphy -> max_scan_ssids ) return - EINVAL ; if ( info -> attrs [ NL80211_ATTR_IE ] ) ie_len = nla_len ( info -> attrs [ NL80211_ATTR_IE ] ) ; else ie_len = 0 ; if ( ie_len > wiphy -> max_scan_ie_len ) return - EINVAL ; request = kzalloc ( sizeof ( * request ) + sizeof ( * request -> ssids ) * n_ssids + sizeof ( * request -> channels ) * n_channels + ie_len , GFP_KERNEL ) ; if ( ! request ) return - ENOMEM ; if ( n_ssids ) request -> ssids = ( void * ) & request -> channels [ n_channels ] ; request -> n_ssids = n_ssids ; if ( ie_len ) { if ( request -> ssids ) request -> ie = ( void * ) ( request -> ssids + n_ssids ) ; else request -> ie = ( void * ) ( request -> channels + n_channels ) ; } i = 0 ; if ( info -> attrs [ NL80211_ATTR_SCAN_FREQUENCIES ] ) { nla_for_each_nested ( attr , info -> attrs [ NL80211_ATTR_SCAN_FREQUENCIES ] , tmp ) { struct ieee80211_channel * chan ; chan = ieee80211_get_channel ( wiphy , nla_get_u32 ( attr ) ) ; if ( ! chan ) { err = - EINVAL ; goto out_free ; } if ( chan -> flags & IEEE80211_CHAN_DISABLED ) continue ; request -> channels [ i ] = chan ; i ++ ; } } else { for ( band = 0 ; band < IEEE80211_NUM_BANDS ; band ++ ) { int j ; if ( ! wiphy -> bands [ band ] ) continue ; for ( j = 0 ; j < wiphy -> bands [ band ] -> n_channels ; j ++ ) { struct ieee80211_channel * chan ; chan = & wiphy -> bands [ band ] -> channels [ j ] ; if ( chan -> flags & IEEE80211_CHAN_DISABLED ) continue ; request -> channels [ i ] = chan ; i ++ ; } } } if ( ! i ) { err = - EINVAL ; goto out_free ; } request -> n_channels = i ; i = 0 ; if ( info -> attrs [ NL80211_ATTR_SCAN_SSIDS ] ) { <S2SV_StartBug> nla_for_each_nested ( attr , info -> attrs [ NL80211_ATTR_SCAN_SSIDS ] , tmp ) { <S2SV_EndBug> if ( request -> ssids [ i ] . ssid_len > IEEE80211_MAX_SSID_LEN ) { err = - EINVAL ; goto out_free ; } memcpy ( request -> ssids [ i ] . ssid , nla_data ( attr ) , nla_len ( attr ) ) ; <S2SV_StartBug> request -> ssids [ i ] . ssid_len = nla_len ( attr ) ; <S2SV_EndBug> i ++ ; } } if ( info -> attrs [ NL80211_ATTR_IE ] ) { request -> ie_len = nla_len ( info -> attrs [ NL80211_ATTR_IE ] ) ; memcpy ( ( void * ) request -> ie , nla_data ( info -> attrs [ NL80211_ATTR_IE ] ) , request -> ie_len ) ; } request -> dev = dev ; request -> wiphy = & rdev -> wiphy ; rdev -> scan_req = request ; err = rdev -> ops -> scan ( & rdev -> wiphy , dev , request ) ; if ( ! err ) { nl80211_send_scan_start ( rdev , dev ) ; dev_hold ( dev ) ; } else { out_free : rdev -> scan_req = NULL ; kfree ( request ) ; } return err ; }\n",
      "fixed_code": "<S2SV_ModStart> tmp ) { request -> ssids [ i ] . ssid_len = nla_len ( attr ) ; <S2SV_ModStart> ) ) ; <S2SV_ModEnd> i ++ ;\n",
      "source_code_length": 3635,
      "target_code_length": 122,
      "vulnerability_patterns": {
        "buffer_overflow": 2,
        "use_after_free": 1,
        "integer_overflow": 8,
        "null_pointer": 69,
        "total": 80
      },
      "total_patterns": 80,
      "original_address": "https://github.com/torvalds/linux/commit/208c72f4fe44fe09577e7975ba0e7fa0278f3d03",
      "discovery_time": "2012-05-24T23:55Z",
      "project_commit_id": "torvalds@linux/208c72f4fe44fe09577e7975ba0e7fa0278f3d03",
      "extraction_time": "2025-08-31T15:41:49.177042",
      "label": 1,
      "vulnerability_type": "buffer_overflow",
      "difficulty_level": "expert",
      "risk_factors": [
        "memory_corruption",
        "arbitrary_code_execution",
        "buffer_overflow",
        "system_crash",
        "use_after_free"
      ],
      "attack_vectors": [
        "memory_manipulation",
        "malicious_input",
        "code_analysis",
        "buffer_overflow",
        "reverse_engineering",
        "fuzzing"
      ],
      "mitigation_strategies": [
        "safe_string_functions",
        "dynamic_analysis",
        "code_review",
        "static_analysis",
        "memory_safety_checks",
        "input_validation",
        "fuzzing",
        "bounds_checking",
        "secure_coding_practices"
      ],
      "code_differences": {
        "has_differences": true,
        "source_lines": 2,
        "target_lines": 2,
        "character_differences": 3513,
        "similarity_percentage": 16.19047619047619
      },
      "vulnerability_location": {
        "vulnerability_present": true,
        "fix_applied": true,
        "code_changed": true,
        "estimated_lines_changed": 0
      }
    },
    {
      "cve_id": "CVE-2011-2517",
      "cwe_id": "CWE-119",
      "cwe_name": "Buffer Overflow",
      "project": "torvalds",
      "severity": "critical",
      "weaponization_score": 10.0,
      "is_critical": true,
      "is_weaponizable": true,
      "is_high_priority_project": false,
      "vulnerable_code": "CWE-119 static int nl80211_trigger_scan ( struct sk_buff * skb , struct genl_info * info ) { struct cfg80211_registered_device * rdev = info -> user_ptr [ 0 ] ; struct net_device * dev = info -> user_ptr [ 1 ] ; struct cfg80211_scan_request * request ; struct nlattr * attr ; struct wiphy * wiphy ; int err , tmp , n_ssids = 0 , n_channels , i ; enum ieee80211_band band ; size_t ie_len ; if ( ! is_valid_ie_attr ( info -> attrs [ NL80211_ATTR_IE ] ) ) return - EINVAL ; wiphy = & rdev -> wiphy ; if ( ! rdev -> ops -> scan ) return - EOPNOTSUPP ; if ( rdev -> scan_req ) return - EBUSY ; if ( info -> attrs [ NL80211_ATTR_SCAN_FREQUENCIES ] ) { n_channels = validate_scan_freqs ( info -> attrs [ NL80211_ATTR_SCAN_FREQUENCIES ] ) ; if ( ! n_channels ) return - EINVAL ; } else { n_channels = 0 ; for ( band = 0 ; band < IEEE80211_NUM_BANDS ; band ++ ) if ( wiphy -> bands [ band ] ) n_channels += wiphy -> bands [ band ] -> n_channels ; } if ( info -> attrs [ NL80211_ATTR_SCAN_SSIDS ] ) nla_for_each_nested ( attr , info -> attrs [ NL80211_ATTR_SCAN_SSIDS ] , tmp ) n_ssids ++ ; if ( n_ssids > wiphy -> max_scan_ssids ) return - EINVAL ; if ( info -> attrs [ NL80211_ATTR_IE ] ) ie_len = nla_len ( info -> attrs [ NL80211_ATTR_IE ] ) ; else ie_len = 0 ; if ( ie_len > wiphy -> max_scan_ie_len ) return - EINVAL ; request = kzalloc ( sizeof ( * request ) + sizeof ( * request -> ssids ) * n_ssids + sizeof ( * request -> channels ) * n_channels + ie_len , GFP_KERNEL ) ; if ( ! request ) return - ENOMEM ; if ( n_ssids ) request -> ssids = ( void * ) & request -> channels [ n_channels ] ; request -> n_ssids = n_ssids ; if ( ie_len ) { if ( request -> ssids ) request -> ie = ( void * ) ( request -> ssids + n_ssids ) ; else request -> ie = ( void * ) ( request -> channels + n_channels ) ; } i = 0 ; if ( info -> attrs [ NL80211_ATTR_SCAN_FREQUENCIES ] ) { nla_for_each_nested ( attr , info -> attrs [ NL80211_ATTR_SCAN_FREQUENCIES ] , tmp ) { struct ieee80211_channel * chan ; chan = ieee80211_get_channel ( wiphy , nla_get_u32 ( attr ) ) ; if ( ! chan ) { err = - EINVAL ; goto out_free ; } if ( chan -> flags & IEEE80211_CHAN_DISABLED ) continue ; request -> channels [ i ] = chan ; i ++ ; } } else { for ( band = 0 ; band < IEEE80211_NUM_BANDS ; band ++ ) { int j ; if ( ! wiphy -> bands [ band ] ) continue ; for ( j = 0 ; j < wiphy -> bands [ band ] -> n_channels ; j ++ ) { struct ieee80211_channel * chan ; chan = & wiphy -> bands [ band ] -> channels [ j ] ; if ( chan -> flags & IEEE80211_CHAN_DISABLED ) continue ; request -> channels [ i ] = chan ; i ++ ; } } } if ( ! i ) { err = - EINVAL ; goto out_free ; } request -> n_channels = i ; i = 0 ; if ( info -> attrs [ NL80211_ATTR_SCAN_SSIDS ] ) { <S2SV_StartBug> nla_for_each_nested ( attr , info -> attrs [ NL80211_ATTR_SCAN_SSIDS ] , tmp ) { <S2SV_EndBug> if ( request -> ssids [ i ] . ssid_len > IEEE80211_MAX_SSID_LEN ) { err = - EINVAL ; goto out_free ; } memcpy ( request -> ssids [ i ] . ssid , nla_data ( attr ) , nla_len ( attr ) ) ; <S2SV_StartBug> request -> ssids [ i ] . ssid_len = nla_len ( attr ) ; <S2SV_EndBug> i ++ ; } } if ( info -> attrs [ NL80211_ATTR_IE ] ) { request -> ie_len = nla_len ( info -> attrs [ NL80211_ATTR_IE ] ) ; memcpy ( ( void * ) request -> ie , nla_data ( info -> attrs [ NL80211_ATTR_IE ] ) , request -> ie_len ) ; } request -> dev = dev ; request -> wiphy = & rdev -> wiphy ; rdev -> scan_req = request ; err = rdev -> ops -> scan ( & rdev -> wiphy , dev , request ) ; if ( ! err ) { nl80211_send_scan_start ( rdev , dev ) ; dev_hold ( dev ) ; } else { out_free : rdev -> scan_req = NULL ; kfree ( request ) ; } return err ; }\n",
      "fixed_code": "<S2SV_ModStart> tmp ) { request -> ssids [ i ] . ssid_len = nla_len ( attr ) ; <S2SV_ModStart> ) ) ; <S2SV_ModEnd> i ++ ;\n",
      "source_code_length": 3635,
      "target_code_length": 122,
      "vulnerability_patterns": {
        "buffer_overflow": 2,
        "use_after_free": 1,
        "integer_overflow": 8,
        "null_pointer": 72,
        "total": 83
      },
      "total_patterns": 83,
      "original_address": "https://github.com/torvalds/linux/commit/208c72f4fe44fe09577e7975ba0e7fa0278f3d03",
      "discovery_time": "2012-05-24T23:55Z",
      "project_commit_id": "torvalds@linux/208c72f4fe44fe09577e7975ba0e7fa0278f3d03",
      "extraction_time": "2025-08-31T15:41:49.177091",
      "label": 1,
      "vulnerability_type": "buffer_overflow",
      "difficulty_level": "expert",
      "risk_factors": [
        "memory_corruption",
        "arbitrary_code_execution",
        "buffer_overflow",
        "system_crash",
        "use_after_free"
      ],
      "attack_vectors": [
        "memory_manipulation",
        "malicious_input",
        "code_analysis",
        "buffer_overflow",
        "reverse_engineering",
        "fuzzing"
      ],
      "mitigation_strategies": [
        "safe_string_functions",
        "dynamic_analysis",
        "code_review",
        "static_analysis",
        "memory_safety_checks",
        "input_validation",
        "fuzzing",
        "bounds_checking",
        "secure_coding_practices"
      ],
      "code_differences": {
        "has_differences": true,
        "source_lines": 2,
        "target_lines": 2,
        "character_differences": 3513,
        "similarity_percentage": 16.19047619047619
      },
      "vulnerability_location": {
        "vulnerability_present": true,
        "fix_applied": true,
        "code_changed": true,
        "estimated_lines_changed": 0
      }
    },
    {
      "cve_id": "CVE-2017-7854",
      "cwe_id": "CWE-125",
      "cwe_name": "Out-of-bounds Read",
      "project": "radare",
      "severity": "critical",
      "weaponization_score": 10.0,
      "is_critical": true,
      "is_weaponizable": true,
      "is_high_priority_project": true,
      "vulnerable_code": "CWE-125 static RList * r_bin_wasm_get_data_entries ( RBinWasmObj * bin , RBinWasmSection * sec ) { RList * ret = NULL ; RBinWasmDataEntry * ptr = NULL ; <S2SV_StartBug> if ( ! ( ret = r_list_newf ( ( RListFree ) free ) ) ) { <S2SV_EndBug> return NULL ; } ut8 * buf = bin -> buf -> buf + ( ut32 ) sec -> payload_data ; <S2SV_StartBug> ut32 len = sec -> payload_len ; <S2SV_EndBug> ut32 count = sec -> count ; ut32 i = 0 , r = 0 ; size_t n = 0 ; <S2SV_StartBug> while ( i < len && r < count ) { <S2SV_EndBug> if ( ! ( ptr = R_NEW0 ( RBinWasmDataEntry ) ) ) { return ret ; } if ( ! ( consume_u32 ( buf + i , buf + len , & ptr -> index , & i ) ) ) { <S2SV_StartBug> free ( ptr ) ; <S2SV_EndBug> return ret ; } if ( ! ( n = consume_init_expr ( buf + i , buf + len , R_BIN_WASM_END_OF_CODE , NULL , & i ) ) ) { <S2SV_StartBug> free ( ptr ) ; <S2SV_EndBug> return ret ; } ptr -> offset . len = n ; if ( ! ( consume_u32 ( buf + i , buf + len , & ptr -> size , & i ) ) ) { <S2SV_StartBug> free ( ptr ) ; <S2SV_EndBug> return ret ; } ptr -> data = sec -> payload_data + i ; r_list_append ( ret , ptr ) ; r += 1 ; } return ret ; <S2SV_StartBug> } <S2SV_EndBug>\n",
      "fixed_code": "<S2SV_ModStart> = NULL ; ut32 len = sec -> payload_len ; <S2SV_ModStart> -> payload_data ; int buflen = bin -> buf -> length - ( ut32 ) sec -> payload_data <S2SV_ModEnd> ; ut32 count <S2SV_ModStart> i < len && len < buflen <S2SV_ModStart> ) ) { goto beach ; } if ( i + 4 >= buflen ) { goto beach <S2SV_ModEnd> ; } if <S2SV_ModStart> ) ) { goto beach <S2SV_ModEnd> ; } ptr <S2SV_ModStart> ) ) { goto beach ; } if ( i + 4 >= buflen ) { goto beach <S2SV_ModEnd> ; } ptr <S2SV_ModStart> return ret ; beach : free ( ptr ) ; return ret ;\n",
      "source_code_length": 1150,
      "target_code_length": 532,
      "vulnerability_patterns": {
        "use_after_free": 4,
        "integer_overflow": 1,
        "null_pointer": 8,
        "total": 13
      },
      "total_patterns": 13,
      "original_address": "https://github.com/radare/radare2/commit/d2632f6483a3ceb5d8e0a5fb11142c51c43978b4",
      "discovery_time": "2017-04-13T16:59Z",
      "project_commit_id": "radare@radare2/d2632f6483a3ceb5d8e0a5fb11142c51c43978b4",
      "extraction_time": "2025-08-31T15:41:49.177125",
      "label": 1,
      "vulnerability_type": "out-of-bounds_read",
      "difficulty_level": "expert",
      "risk_factors": [
        "memory_corruption",
        "critical_infrastructure",
        "information_disclosure",
        "use_after_free",
        "integer_overflow"
      ],
      "attack_vectors": [
        "memory_manipulation",
        "malicious_input",
        "code_analysis",
        "buffer_overflow",
        "reverse_engineering",
        "fuzzing"
      ],
      "mitigation_strategies": [
        "safe_string_functions",
        "dynamic_analysis",
        "code_review",
        "static_analysis",
        "memory_safety_checks",
        "input_validation",
        "fuzzing",
        "bounds_checking",
        "secure_coding_practices"
      ],
      "code_differences": {
        "has_differences": true,
        "source_lines": 2,
        "target_lines": 2,
        "character_differences": 618,
        "similarity_percentage": 36.231884057971016
      },
      "vulnerability_location": {
        "vulnerability_present": true,
        "fix_applied": true,
        "code_changed": true,
        "estimated_lines_changed": 0
      }
    },
    {
      "cve_id": "CVE-2018-20456",
      "cwe_id": "CWE-125",
      "cwe_name": "Out-of-bounds Read",
      "project": "radare",
      "severity": "critical",
      "weaponization_score": 10.0,
      "is_critical": true,
      "is_weaponizable": true,
      "is_high_priority_project": true,
      "vulnerable_code": "CWE-125 static int parseOperand ( RAsm * a , const char * str , Operand * op , bool isrepop ) { size_t pos , nextpos = 0 ; x86newTokenType last_type ; int size_token = 1 ; bool explicit_size = false ; int reg_index = 0 ; op -> type = 0 ; while ( size_token ) { pos = nextpos ; last_type = getToken ( str , & pos , & nextpos ) ; if ( ! r_str_ncasecmp ( str + pos , \"ptr\" , 3 ) ) { continue ; } else if ( ! r_str_ncasecmp ( str + pos , \"byte\" , 4 ) ) { op -> type |= OT_MEMORY | OT_BYTE ; op -> dest_size = OT_BYTE ; explicit_size = true ; } else if ( ! r_str_ncasecmp ( str + pos , \"word\" , 4 ) ) { op -> type |= OT_MEMORY | OT_WORD ; op -> dest_size = OT_WORD ; explicit_size = true ; } else if ( ! r_str_ncasecmp ( str + pos , \"dword\" , 5 ) ) { op -> type |= OT_MEMORY | OT_DWORD ; op -> dest_size = OT_DWORD ; explicit_size = true ; } else if ( ! r_str_ncasecmp ( str + pos , \"qword\" , 5 ) ) { op -> type |= OT_MEMORY | OT_QWORD ; op -> dest_size = OT_QWORD ; explicit_size = true ; } else if ( ! r_str_ncasecmp ( str + pos , \"oword\" , 5 ) ) { op -> type |= OT_MEMORY | OT_OWORD ; op -> dest_size = OT_OWORD ; explicit_size = true ; } else if ( ! r_str_ncasecmp ( str + pos , \"tbyte\" , 5 ) ) { op -> type |= OT_MEMORY | OT_TBYTE ; op -> dest_size = OT_TBYTE ; explicit_size = true ; } else { size_token = 0 ; } } if ( str [ pos ] == '[' ) { if ( ! op -> type ) { op -> type = OT_MEMORY ; } op -> offset = op -> scale [ 0 ] = op -> scale [ 1 ] = 0 ; ut64 temp = 1 ; Register reg = X86R_UNDEFINED ; bool first_reg = true ; while ( str [ pos ] != ']' ) { if ( pos > nextpos ) { break ; } pos = nextpos ; if ( ! str [ pos ] ) { break ; } last_type = getToken ( str , & pos , & nextpos ) ; if ( last_type == TT_SPECIAL ) { if ( str [ pos ] == '+' || str [ pos ] == '-' || str [ pos ] == ']' ) { if ( reg != X86R_UNDEFINED ) { <S2SV_StartBug> op -> regs [ reg_index ] = reg ; <S2SV_EndBug> op -> scale [ reg_index ] = temp ; <S2SV_StartBug> ++ reg_index ; <S2SV_EndBug> } else { <S2SV_StartBug> op -> offset += temp ; <S2SV_EndBug> <S2SV_StartBug> op -> regs [ reg_index ] = X86R_UNDEFINED ; <S2SV_EndBug> } temp = 1 ; reg = X86R_UNDEFINED ; } else if ( str [ pos ] == '*' ) { } } else if ( last_type == TT_WORD ) { ut32 reg_type = 0 ; if ( reg != X86R_UNDEFINED ) { op -> type = 0 ; } nextpos = pos ; reg = parseReg ( a , str , & nextpos , & reg_type ) ; if ( first_reg ) { op -> extended = false ; if ( reg > 8 ) { op -> extended = true ; op -> reg = reg - 9 ; } first_reg = false ; } else if ( reg > 8 ) { op -> reg = reg - 9 ; } if ( reg_type & OT_REGTYPE & OT_SEGMENTREG ) { op -> reg = reg ; op -> type = reg_type ; parse_segment_offset ( a , str , & nextpos , op , reg_index ) ; return nextpos ; } if ( ! explicit_size ) { op -> type |= reg_type ; } op -> reg_size = reg_type ; op -> explicit_size = explicit_size ; if ( ! ( reg_type & OT_GPREG ) ) { op -> type = 0 ; } } else { char * p = strchr ( str , '+' ) ; op -> offset_sign = 1 ; if ( ! p ) { p = strchr ( str , '-' ) ; if ( p ) { op -> offset_sign = - 1 ; } } char * plus = strchr ( str , '+' ) ; char * minus = strchr ( str , '-' ) ; char * closeB = strchr ( str , ']' ) ; if ( plus && minus && plus < closeB && minus < closeB ) { op -> offset_sign = - 1 ; } char * tmp ; tmp = malloc ( strlen ( str + pos ) + 1 ) ; strcpy ( tmp , str + pos ) ; strtok ( tmp , \"+-\" ) ; st64 read = getnum ( a , tmp ) ; free ( tmp ) ; temp *= read ; } } } else if ( last_type == TT_WORD ) { nextpos = pos ; RFlagItem * flag ; if ( isrepop ) { op -> is_good_flag = false ; strncpy ( op -> rep_op , str , MAX_REPOP_LENGTH - 1 ) ; op -> rep_op [ MAX_REPOP_LENGTH - 1 ] = '\\\\0' ; return nextpos ; } op -> reg = parseReg ( a , str , & nextpos , & op -> type ) ; op -> extended = false ; if ( op -> reg > 8 ) { op -> extended = true ; op -> reg -= 9 ; } if ( op -> type & OT_REGTYPE & OT_SEGMENTREG ) { parse_segment_offset ( a , str , & nextpos , op , reg_index ) ; return nextpos ; } if ( op -> reg == X86R_UNDEFINED ) { op -> is_good_flag = false ; if ( a -> num && a -> num -> value == 0 ) { return nextpos ; } op -> type = OT_CONSTANT ; RCore * core = a -> num ? ( RCore * ) ( a -> num -> userptr ) : NULL ; if ( core && ( flag = r_flag_get ( core -> flags , str ) ) ) { op -> is_good_flag = true ; } char * p = strchr ( str , '-' ) ; if ( p ) { op -> sign = - 1 ; str = ++ p ; } op -> immediate = getnum ( a , str ) ; } else if ( op -> reg < X86R_UNDEFINED ) { strncpy ( op -> rep_op , str , MAX_REPOP_LENGTH - 1 ) ; op -> rep_op [ MAX_REPOP_LENGTH - 1 ] = '\\\\0' ; } } else { op -> type = OT_CONSTANT ; op -> sign = 1 ; char * p = strchr ( str , '-' ) ; if ( p ) { op -> sign = - 1 ; str = ++ p ; } op -> immediate = getnum ( a , str ) ; } return nextpos ; }\n",
      "fixed_code": "<S2SV_ModStart> X86R_UNDEFINED ) { if ( reg_index < 2 ) { <S2SV_ModStart> = temp ; } <S2SV_ModStart> += temp ; if ( reg_index < 2 ) { <S2SV_ModStart> = X86R_UNDEFINED ; }\n",
      "source_code_length": 4703,
      "target_code_length": 171,
      "vulnerability_patterns": {
        "buffer_overflow": 3,
        "use_after_free": 2,
        "integer_overflow": 6,
        "null_pointer": 70,
        "memory_leak": 1,
        "total": 82
      },
      "total_patterns": 82,
      "original_address": "https://github.com/radare/radare2/commit/9b46d38dd3c4de6048a488b655c7319f845af185",
      "discovery_time": "2018-12-25T19:29Z",
      "project_commit_id": "radare@radare2/9b46d38dd3c4de6048a488b655c7319f845af185",
      "extraction_time": "2025-08-31T15:41:49.177161",
      "label": 1,
      "vulnerability_type": "out-of-bounds_read",
      "difficulty_level": "expert",
      "risk_factors": [
        "memory_corruption",
        "critical_infrastructure",
        "buffer_overflow",
        "information_disclosure",
        "use_after_free",
        "integer_overflow"
      ],
      "attack_vectors": [
        "memory_manipulation",
        "malicious_input",
        "code_analysis",
        "buffer_overflow",
        "reverse_engineering",
        "fuzzing"
      ],
      "mitigation_strategies": [
        "safe_string_functions",
        "dynamic_analysis",
        "code_review",
        "static_analysis",
        "memory_safety_checks",
        "input_validation",
        "fuzzing",
        "bounds_checking",
        "secure_coding_practices"
      ],
      "code_differences": {
        "has_differences": true,
        "source_lines": 2,
        "target_lines": 2,
        "character_differences": 4532,
        "similarity_percentage": 8.21917808219178
      },
      "vulnerability_location": {
        "vulnerability_present": true,
        "fix_applied": true,
        "code_changed": true,
        "estimated_lines_changed": 0
      }
    },
    {
      "cve_id": "CVE-2018-16840",
      "cwe_id": "CWE-416",
      "cwe_name": "Use After Free",
      "project": "curl",
      "severity": "critical",
      "weaponization_score": 10.0,
      "is_critical": true,
      "is_weaponizable": true,
      "is_high_priority_project": true,
      "vulnerable_code": "CWE-416 CURLcode Curl_close ( struct Curl_easy * data ) { struct Curl_multi * m ; if ( ! data ) return CURLE_OK ; Curl_expire_clear ( data ) ; m = data -> multi ; if ( m ) curl_multi_remove_handle ( data -> multi , data ) ; <S2SV_StartBug> if ( data -> multi_easy ) <S2SV_EndBug> <S2SV_StartBug> curl_multi_cleanup ( data -> multi_easy ) ; <S2SV_EndBug> Curl_llist_destroy ( & data -> state . timeoutlist , NULL ) ; data -> magic = 0 ; if ( data -> state . rangestringalloc ) free ( data -> state . range ) ; Curl_free_request_state ( data ) ; Curl_ssl_close_all ( data ) ; Curl_safefree ( data -> state . first_host ) ; Curl_safefree ( data -> state . scratch ) ; Curl_ssl_free_certinfo ( data ) ; free ( data -> req . newurl ) ; data -> req . newurl = NULL ; if ( data -> change . referer_alloc ) { Curl_safefree ( data -> change . referer ) ; data -> change . referer_alloc = FALSE ; } data -> change . referer = NULL ; Curl_up_free ( data ) ; Curl_safefree ( data -> state . buffer ) ; Curl_safefree ( data -> state . headerbuff ) ; Curl_safefree ( data -> state . ulbuf ) ; Curl_flush_cookies ( data , 1 ) ; Curl_digest_cleanup ( data ) ; Curl_safefree ( data -> info . contenttype ) ; Curl_safefree ( data -> info . wouldredirect ) ; Curl_resolver_cleanup ( data -> state . resolver ) ; Curl_http2_cleanup_dependencies ( data ) ; Curl_convert_close ( data ) ; if ( data -> share ) { Curl_share_lock ( data , CURL_LOCK_DATA_SHARE , CURL_LOCK_ACCESS_SINGLE ) ; data -> share -> dirty -- ; Curl_share_unlock ( data , CURL_LOCK_DATA_SHARE ) ; } Curl_wildcard_dtor ( & data -> wildcard ) ; Curl_freeset ( data ) ; free ( data ) ; return CURLE_OK ; }\n",
      "fixed_code": "<S2SV_ModStart> -> multi_easy ) { <S2SV_ModStart> multi_easy ) ; data -> multi_easy = NULL ; }\n",
      "source_code_length": 1651,
      "target_code_length": 95,
      "vulnerability_patterns": {
        "use_after_free": 5,
        "integer_overflow": 1,
        "null_pointer": 28,
        "total": 34
      },
      "total_patterns": 34,
      "original_address": "https://github.com/curl/curl/commit/81d135d67155c5295b1033679c606165d4e28f3f",
      "discovery_time": "2018-10-31T18:29Z",
      "project_commit_id": "curl@curl/81d135d67155c5295b1033679c606165d4e28f3f",
      "extraction_time": "2025-08-31T15:41:49.177224",
      "label": 1,
      "vulnerability_type": "use_after_free",
      "difficulty_level": "expert",
      "risk_factors": [
        "denial_of_service",
        "memory_corruption",
        "critical_infrastructure",
        "system_crash",
        "use_after_free"
      ],
      "attack_vectors": [
        "memory_manipulation",
        "null_pointer",
        "code_analysis",
        "reverse_engineering",
        "use_after_free",
        "fuzzing"
      ],
      "mitigation_strategies": [
        "null_pointer_checks",
        "fuzzing",
        "dynamic_analysis",
        "memory_management",
        "static_analysis",
        "use_after_free_prevention",
        "code_review",
        "secure_coding_practices"
      ],
      "code_differences": {
        "has_differences": true,
        "source_lines": 2,
        "target_lines": 2,
        "character_differences": 1556,
        "similarity_percentage": 11.842105263157894
      },
      "vulnerability_location": {
        "vulnerability_present": true,
        "fix_applied": true,
        "code_changed": true,
        "estimated_lines_changed": 0
      }
    },
    {
      "cve_id": "CVE-2018-11378",
      "cwe_id": "CWE-119",
      "cwe_name": "Buffer Overflow",
      "project": "radare",
      "severity": "critical",
      "weaponization_score": 10.0,
      "is_critical": true,
      "is_weaponizable": true,
      "is_high_priority_project": true,
      "vulnerable_code": "CWE-119 int wasm_dis ( WasmOp * op , const unsigned char * buf , int buf_len ) { op -> len = 1 ; op -> op = buf [ 0 ] ; if ( op -> op > 0xbf ) { return 1 ; } WasmOpDef * opdef = & opcodes [ op -> op ] ; switch ( op -> op ) { case WASM_OP_TRAP : case WASM_OP_NOP : case WASM_OP_ELSE : case WASM_OP_RETURN : case WASM_OP_DROP : case WASM_OP_SELECT : case WASM_OP_I32EQZ : case WASM_OP_I32EQ : case WASM_OP_I32NE : case WASM_OP_I32LTS : case WASM_OP_I32LTU : case WASM_OP_I32GTS : case WASM_OP_I32GTU : case WASM_OP_I32LES : case WASM_OP_I32LEU : case WASM_OP_I32GES : case WASM_OP_I32GEU : case WASM_OP_I64EQZ : case WASM_OP_I64EQ : case WASM_OP_I64NE : case WASM_OP_I64LTS : case WASM_OP_I64LTU : case WASM_OP_I64GTS : case WASM_OP_I64GTU : case WASM_OP_I64LES : case WASM_OP_I64LEU : case WASM_OP_I64GES : case WASM_OP_I64GEU : case WASM_OP_F32EQ : case WASM_OP_F32NE : case WASM_OP_F32LT : case WASM_OP_F32GT : case WASM_OP_F32LE : case WASM_OP_F32GE : case WASM_OP_F64EQ : case WASM_OP_F64NE : case WASM_OP_F64LT : case WASM_OP_F64GT : case WASM_OP_F64LE : case WASM_OP_F64GE : case WASM_OP_I32CLZ : case WASM_OP_I32CTZ : case WASM_OP_I32POPCNT : case WASM_OP_I32ADD : case WASM_OP_I32SUB : case WASM_OP_I32MUL : case WASM_OP_I32DIVS : case WASM_OP_I32DIVU : case WASM_OP_I32REMS : case WASM_OP_I32REMU : case WASM_OP_I32AND : case WASM_OP_I32OR : case WASM_OP_I32XOR : case WASM_OP_I32SHL : case WASM_OP_I32SHRS : case WASM_OP_I32SHRU : case WASM_OP_I32ROTL : case WASM_OP_I32ROTR : case WASM_OP_I64CLZ : case WASM_OP_I64CTZ : case WASM_OP_I64POPCNT : case WASM_OP_I64ADD : case WASM_OP_I64SUB : case WASM_OP_I64MUL : case WASM_OP_I64DIVS : case WASM_OP_I64DIVU : case WASM_OP_I64REMS : case WASM_OP_I64REMU : case WASM_OP_I64AND : case WASM_OP_I64OR : case WASM_OP_I64XOR : case WASM_OP_I64SHL : case WASM_OP_I64SHRS : case WASM_OP_I64SHRU : case WASM_OP_I64ROTL : case WASM_OP_I64ROTR : case WASM_OP_F32ABS : case WASM_OP_F32NEG : case WASM_OP_F32CEIL : case WASM_OP_F32FLOOR : case WASM_OP_F32TRUNC : case WASM_OP_F32NEAREST : case WASM_OP_F32SQRT : case WASM_OP_F32ADD : case WASM_OP_F32SUB : case WASM_OP_F32MUL : case WASM_OP_F32DIV : case WASM_OP_F32MIN : case WASM_OP_F32MAX : case WASM_OP_F32COPYSIGN : case WASM_OP_F64ABS : case WASM_OP_F64NEG : case WASM_OP_F64CEIL : case WASM_OP_F64FLOOR : case WASM_OP_F64TRUNC : case WASM_OP_F64NEAREST : case WASM_OP_F64SQRT : case WASM_OP_F64ADD : case WASM_OP_F64SUB : case WASM_OP_F64MUL : case WASM_OP_F64DIV : case WASM_OP_F64MIN : case WASM_OP_F64MAX : case WASM_OP_F64COPYSIGN : case WASM_OP_I32WRAPI64 : case WASM_OP_I32TRUNCSF32 : case WASM_OP_I32TRUNCUF32 : case WASM_OP_I32TRUNCSF64 : case WASM_OP_I32TRUNCUF64 : case WASM_OP_I64EXTENDSI32 : case WASM_OP_I64EXTENDUI32 : case WASM_OP_I64TRUNCSF32 : case WASM_OP_I64TRUNCUF32 : case WASM_OP_I64TRUNCSF64 : case WASM_OP_I64TRUNCUF64 : case WASM_OP_F32CONVERTSI32 : case WASM_OP_F32CONVERTUI32 : case WASM_OP_F32CONVERTSI64 : case WASM_OP_F32CONVERTUI64 : case WASM_OP_F32DEMOTEF64 : case WASM_OP_F64CONVERTSI32 : case WASM_OP_F64CONVERTUI32 : case WASM_OP_F64CONVERTSI64 : case WASM_OP_F64CONVERTUI64 : case WASM_OP_F64PROMOTEF32 : case WASM_OP_I32REINTERPRETF32 : case WASM_OP_I64REINTERPRETF64 : case WASM_OP_F32REINTERPRETI32 : case WASM_OP_F64REINTERPRETI64 : case WASM_OP_END : { snprintf ( op -> txt , R_ASM_BUFSIZE , \"%s\" , opdef -> txt ) ; } break ; case WASM_OP_BLOCK : case WASM_OP_LOOP : case WASM_OP_IF : { st32 val = 0 ; size_t n = read_i32_leb128 ( buf + 1 , buf + buf_len , & val ) ; if ( ! ( n > 0 && n < buf_len ) ) goto err ; switch ( 0x80 - val ) { case R_BIN_WASM_VALUETYPE_EMPTY : snprintf ( op -> txt , R_ASM_BUFSIZE , \"%s\" , opdef -> txt ) ; break ; case R_BIN_WASM_VALUETYPE_i32 : snprintf ( op -> txt , R_ASM_BUFSIZE , \"%s<S2SV_blank>(result<S2SV_blank>i32)\" , opdef -> txt ) ; break ; case R_BIN_WASM_VALUETYPE_i64 : snprintf ( op -> txt , R_ASM_BUFSIZE , \"%s<S2SV_blank>(result<S2SV_blank>i64)\" , opdef -> txt ) ; break ; case R_BIN_WASM_VALUETYPE_f32 : snprintf ( op -> txt , R_ASM_BUFSIZE , \"%s<S2SV_blank>(result<S2SV_blank>f32)\" , opdef -> txt ) ; break ; case R_BIN_WASM_VALUETYPE_f64 : snprintf ( op -> txt , R_ASM_BUFSIZE , \"%s<S2SV_blank>(result<S2SV_blank>f64)\" , opdef -> txt ) ; break ; default : snprintf ( op -> txt , R_ASM_BUFSIZE , \"%s<S2SV_blank>(result<S2SV_blank>?)\" , opdef -> txt ) ; break ; } op -> len += n ; } break ; case WASM_OP_BR : case WASM_OP_BRIF : case WASM_OP_CALL : { ut32 val = 0 ; size_t n = read_u32_leb128 ( buf + 1 , buf + buf_len , & val ) ; if ( ! ( n > 0 && n < buf_len ) ) goto err ; snprintf ( op -> txt , R_ASM_BUFSIZE , \"%s<S2SV_blank>%d\" , opdef -> txt , val ) ; op -> len += n ; } break ; case WASM_OP_BRTABLE : { ut32 count = 0 , * table = NULL , def = 0 ; size_t n = read_u32_leb128 ( buf + 1 , buf + buf_len , & count ) ; if ( ! ( n > 0 && n < buf_len ) ) { goto err ; } if ( ! ( table = calloc ( count , sizeof ( ut32 ) ) ) ) { goto err ; } int i = 0 ; op -> len += n ; for ( i = 0 ; i < count ; i ++ ) { n = read_u32_leb128 ( buf + op -> len , buf + buf_len , & table [ i ] ) ; if ( ! ( op -> len + n <= buf_len ) ) { goto beach ; } op -> len += n ; } n = read_u32_leb128 ( buf + op -> len , buf + buf_len , & def ) ; if ( ! ( n > 0 && n + op -> len < buf_len ) ) { goto beach ; } op -> len += n ; snprintf ( op -> txt , R_ASM_BUFSIZE , \"%s<S2SV_blank>%d<S2SV_blank>\" , opdef -> txt , count ) ; <S2SV_StartBug> for ( i = 0 ; i < count && strlen ( op -> txt ) + 10 < R_ASM_BUFSIZE ; i ++ ) { <S2SV_EndBug> <S2SV_StartBug> int optxtlen = strlen ( op -> txt ) ; <S2SV_EndBug> snprintf ( op -> txt + optxtlen , R_ASM_BUFSIZE - optxtlen , \"%d<S2SV_blank>\" , table [ i ] ) ; <S2SV_StartBug> } <S2SV_EndBug> <S2SV_StartBug> snprintf ( op -> txt + strlen ( op -> txt ) , R_ASM_BUFSIZE , \"%d\" , def ) ; <S2SV_EndBug> free ( table ) ; break ; beach : free ( table ) ; goto err ; } break ; case WASM_OP_CALLINDIRECT : { ut32 val = 0 , reserved = 0 ; size_t n = read_u32_leb128 ( buf + 1 , buf + buf_len , & val ) ; if ( ! ( n > 0 && n < buf_len ) ) goto err ; op -> len += n ; n = read_u32_leb128 ( buf + op -> len , buf + buf_len , & reserved ) ; if ( ! ( n == 1 && op -> len + n <= buf_len ) ) goto err ; reserved &= 0x1 ; snprintf ( op -> txt , R_ASM_BUFSIZE , \"%s<S2SV_blank>%d<S2SV_blank>%d\" , opdef -> txt , val , reserved ) ; op -> len += n ; } break ; case WASM_OP_GETLOCAL : case WASM_OP_SETLOCAL : case WASM_OP_TEELOCAL : case WASM_OP_GETGLOBAL : case WASM_OP_SETGLOBAL : { ut32 val = 0 ; size_t n = read_u32_leb128 ( buf + 1 , buf + buf_len , & val ) ; if ( ! ( n > 0 && n < buf_len ) ) goto err ; snprintf ( op -> txt , R_ASM_BUFSIZE , \"%s<S2SV_blank>%d\" , opdef -> txt , val ) ; op -> len += n ; } break ; case WASM_OP_I32LOAD : case WASM_OP_I64LOAD : case WASM_OP_F32LOAD : case WASM_OP_F64LOAD : case WASM_OP_I32LOAD8S : case WASM_OP_I32LOAD8U : case WASM_OP_I32LOAD16S : case WASM_OP_I32LOAD16U : case WASM_OP_I64LOAD8S : case WASM_OP_I64LOAD8U : case WASM_OP_I64LOAD16S : case WASM_OP_I64LOAD16U : case WASM_OP_I64LOAD32S : case WASM_OP_I64LOAD32U : case WASM_OP_I32STORE : case WASM_OP_I64STORE : case WASM_OP_F32STORE : case WASM_OP_F64STORE : case WASM_OP_I32STORE8 : case WASM_OP_I32STORE16 : case WASM_OP_I64STORE8 : case WASM_OP_I64STORE16 : case WASM_OP_I64STORE32 : { ut32 flag = 0 , offset = 0 ; size_t n = read_u32_leb128 ( buf + 1 , buf + buf_len , & flag ) ; if ( ! ( n > 0 && n < buf_len ) ) goto err ; op -> len += n ; n = read_u32_leb128 ( buf + op -> len , buf + buf_len , & offset ) ; if ( ! ( n > 0 && op -> len + n <= buf_len ) ) goto err ; snprintf ( op -> txt , R_ASM_BUFSIZE , \"%s<S2SV_blank>%d<S2SV_blank>%d\" , opdef -> txt , flag , offset ) ; op -> len += n ; } break ; case WASM_OP_CURRENTMEMORY : case WASM_OP_GROWMEMORY : { ut32 reserved = 0 ; size_t n = read_u32_leb128 ( buf + 1 , buf + buf_len , & reserved ) ; if ( ! ( n == 1 && n < buf_len ) ) goto err ; reserved &= 0x1 ; snprintf ( op -> txt , R_ASM_BUFSIZE , \"%s<S2SV_blank>%d\" , opdef -> txt , reserved ) ; op -> len += n ; } break ; case WASM_OP_I32CONST : { st32 val = 0 ; size_t n = read_i32_leb128 ( buf + 1 , buf + buf_len , & val ) ; if ( ! ( n > 0 && n < buf_len ) ) goto err ; snprintf ( op -> txt , R_ASM_BUFSIZE , \"%s<S2SV_blank>%\" PFMT32d , opdef -> txt , val ) ; op -> len += n ; } break ; case WASM_OP_I64CONST : { st64 val = 0 ; size_t n = read_i64_leb128 ( buf + 1 , buf + buf_len , & val ) ; if ( ! ( n > 0 && n < buf_len ) ) goto err ; snprintf ( op -> txt , R_ASM_BUFSIZE , \"%s<S2SV_blank>%\" PFMT64d , opdef -> txt , val ) ; op -> len += n ; } break ; case WASM_OP_F32CONST : { ut32 val = 0 ; size_t n = read_u32_leb128 ( buf + 1 , buf + buf_len , & val ) ; if ( ! ( n > 0 && n < buf_len ) ) goto err ; long double d = ( long double ) val ; snprintf ( op -> txt , R_ASM_BUFSIZE , \"%s<S2SV_blank>%\" LDBLFMT , opdef -> txt , d ) ; op -> len += n ; } break ; case WASM_OP_F64CONST : { ut64 val = 0 ; size_t n = read_u64_leb128 ( buf + 1 , buf + buf_len , & val ) ; if ( ! ( n > 0 && n < buf_len ) ) goto err ; long double d = ( long double ) val ; snprintf ( op -> txt , R_ASM_BUFSIZE , \"%s<S2SV_blank>%\" LDBLFMT , opdef -> txt , d ) ; op -> len += n ; } break ; default : goto err ; } return op -> len ; err : op -> len = 1 ; snprintf ( op -> txt , R_ASM_BUFSIZE , \"invalid\" ) ; return op -> len ; }\n",
      "fixed_code": "<S2SV_ModStart> count ) ; char * txt = op -> txt ; int txtLen = strlen ( op -> txt ) ; int txtLeft = R_ASM_BUFSIZE - txtLen ; txt += txtLen ; <S2SV_ModStart> < count && txtLen <S2SV_ModEnd> + 10 < <S2SV_ModStart> ++ ) { snprintf ( txt , txtLeft <S2SV_ModEnd> , \"%d<S2SV_blank>\" , <S2SV_ModStart> ] ) ; txtLen = strlen ( txt ) ; txt += txtLen ; txtLeft -= txtLen ; <S2SV_ModStart> } snprintf ( txt , txtLeft - 1 <S2SV_ModEnd> , \"%d\" ,\n",
      "source_code_length": 9298,
      "target_code_length": 434,
      "vulnerability_patterns": {
        "use_after_free": 3,
        "integer_overflow": 17,
        "format_string": 20,
        "null_pointer": 71,
        "memory_leak": 1,
        "total": 112
      },
      "total_patterns": 112,
      "original_address": "https://github.com/radare/radare2/commit/bd276ef2fd8ac3401e65be7c126a43175ccfbcd7",
      "discovery_time": "2018-05-22T19:29Z",
      "project_commit_id": "radare@radare2/bd276ef2fd8ac3401e65be7c126a43175ccfbcd7",
      "extraction_time": "2025-08-31T15:41:49.177257",
      "label": 1,
      "vulnerability_type": "buffer_overflow",
      "difficulty_level": "expert",
      "risk_factors": [
        "memory_corruption",
        "critical_infrastructure",
        "arbitrary_code_execution",
        "system_crash",
        "use_after_free"
      ],
      "attack_vectors": [
        "memory_manipulation",
        "malicious_input",
        "code_analysis",
        "buffer_overflow",
        "reverse_engineering",
        "fuzzing"
      ],
      "mitigation_strategies": [
        "safe_string_functions",
        "dynamic_analysis",
        "code_review",
        "static_analysis",
        "memory_safety_checks",
        "input_validation",
        "fuzzing",
        "bounds_checking",
        "secure_coding_practices"
      ],
      "code_differences": {
        "has_differences": true,
        "source_lines": 2,
        "target_lines": 2,
        "character_differences": 8864,
        "similarity_percentage": 9.859154929577464
      },
      "vulnerability_location": {
        "vulnerability_present": true,
        "fix_applied": true,
        "code_changed": true,
        "estimated_lines_changed": 0
      }
    },
    {
      "cve_id": "CVE-2013-1929",
      "cwe_id": "CWE-119",
      "cwe_name": "Buffer Overflow",
      "project": "torvalds",
      "severity": "critical",
      "weaponization_score": 10.0,
      "is_critical": true,
      "is_weaponizable": true,
      "is_high_priority_project": false,
      "vulnerable_code": "CWE-119 static void tg3_read_vpd ( struct tg3 * tp ) { u8 * vpd_data ; unsigned int block_end , rosize , len ; u32 vpdlen ; int j , i = 0 ; vpd_data = ( u8 * ) tg3_vpd_readblock ( tp , & vpdlen ) ; if ( ! vpd_data ) goto out_no_vpd ; i = pci_vpd_find_tag ( vpd_data , 0 , vpdlen , PCI_VPD_LRDT_RO_DATA ) ; if ( i < 0 ) goto out_not_found ; rosize = pci_vpd_lrdt_size ( & vpd_data [ i ] ) ; block_end = i + PCI_VPD_LRDT_TAG_SIZE + rosize ; i += PCI_VPD_LRDT_TAG_SIZE ; if ( block_end > vpdlen ) goto out_not_found ; j = pci_vpd_find_info_keyword ( vpd_data , i , rosize , PCI_VPD_RO_KEYWORD_MFR_ID ) ; if ( j > 0 ) { len = pci_vpd_info_field_size ( & vpd_data [ j ] ) ; j += PCI_VPD_INFO_FLD_HDR_SIZE ; if ( j + len > block_end || len != 4 || memcmp ( & vpd_data [ j ] , \"1028\" , 4 ) ) goto partno ; j = pci_vpd_find_info_keyword ( vpd_data , i , rosize , PCI_VPD_RO_KEYWORD_VENDOR0 ) ; if ( j < 0 ) goto partno ; len = pci_vpd_info_field_size ( & vpd_data [ j ] ) ; j += PCI_VPD_INFO_FLD_HDR_SIZE ; if ( j + len > block_end ) goto partno ; <S2SV_StartBug> memcpy ( tp -> fw_ver , & vpd_data [ j ] , len ) ; <S2SV_EndBug> <S2SV_StartBug> strncat ( tp -> fw_ver , \"<S2SV_blank>bc<S2SV_blank>\" , vpdlen - len - 1 ) ; <S2SV_EndBug> } partno : i = pci_vpd_find_info_keyword ( vpd_data , i , rosize , PCI_VPD_RO_KEYWORD_PARTNO ) ; if ( i < 0 ) goto out_not_found ; len = pci_vpd_info_field_size ( & vpd_data [ i ] ) ; i += PCI_VPD_INFO_FLD_HDR_SIZE ; if ( len > TG3_BPN_SIZE || ( len + i ) > vpdlen ) goto out_not_found ; memcpy ( tp -> board_part_number , & vpd_data [ i ] , len ) ; out_not_found : kfree ( vpd_data ) ; if ( tp -> board_part_number [ 0 ] ) return ; out_no_vpd : if ( tg3_asic_rev ( tp ) == ASIC_REV_5717 ) { if ( tp -> pdev -> device == TG3PCI_DEVICE_TIGON3_5717 || tp -> pdev -> device == TG3PCI_DEVICE_TIGON3_5717_C ) strcpy ( tp -> board_part_number , \"BCM5717\" ) ; else if ( tp -> pdev -> device == TG3PCI_DEVICE_TIGON3_5718 ) strcpy ( tp -> board_part_number , \"BCM5718\" ) ; else goto nomatch ; } else if ( tg3_asic_rev ( tp ) == ASIC_REV_57780 ) { if ( tp -> pdev -> device == TG3PCI_DEVICE_TIGON3_57780 ) strcpy ( tp -> board_part_number , \"BCM57780\" ) ; else if ( tp -> pdev -> device == TG3PCI_DEVICE_TIGON3_57760 ) strcpy ( tp -> board_part_number , \"BCM57760\" ) ; else if ( tp -> pdev -> device == TG3PCI_DEVICE_TIGON3_57790 ) strcpy ( tp -> board_part_number , \"BCM57790\" ) ; else if ( tp -> pdev -> device == TG3PCI_DEVICE_TIGON3_57788 ) strcpy ( tp -> board_part_number , \"BCM57788\" ) ; else goto nomatch ; } else if ( tg3_asic_rev ( tp ) == ASIC_REV_57765 ) { if ( tp -> pdev -> device == TG3PCI_DEVICE_TIGON3_57761 ) strcpy ( tp -> board_part_number , \"BCM57761\" ) ; else if ( tp -> pdev -> device == TG3PCI_DEVICE_TIGON3_57765 ) strcpy ( tp -> board_part_number , \"BCM57765\" ) ; else if ( tp -> pdev -> device == TG3PCI_DEVICE_TIGON3_57781 ) strcpy ( tp -> board_part_number , \"BCM57781\" ) ; else if ( tp -> pdev -> device == TG3PCI_DEVICE_TIGON3_57785 ) strcpy ( tp -> board_part_number , \"BCM57785\" ) ; else if ( tp -> pdev -> device == TG3PCI_DEVICE_TIGON3_57791 ) strcpy ( tp -> board_part_number , \"BCM57791\" ) ; else if ( tp -> pdev -> device == TG3PCI_DEVICE_TIGON3_57795 ) strcpy ( tp -> board_part_number , \"BCM57795\" ) ; else goto nomatch ; } else if ( tg3_asic_rev ( tp ) == ASIC_REV_57766 ) { if ( tp -> pdev -> device == TG3PCI_DEVICE_TIGON3_57762 ) strcpy ( tp -> board_part_number , \"BCM57762\" ) ; else if ( tp -> pdev -> device == TG3PCI_DEVICE_TIGON3_57766 ) strcpy ( tp -> board_part_number , \"BCM57766\" ) ; else if ( tp -> pdev -> device == TG3PCI_DEVICE_TIGON3_57782 ) strcpy ( tp -> board_part_number , \"BCM57782\" ) ; else if ( tp -> pdev -> device == TG3PCI_DEVICE_TIGON3_57786 ) strcpy ( tp -> board_part_number , \"BCM57786\" ) ; else goto nomatch ; } else if ( tg3_asic_rev ( tp ) == ASIC_REV_5906 ) { strcpy ( tp -> board_part_number , \"BCM95906\" ) ; } else { nomatch : strcpy ( tp -> board_part_number , \"none\" ) ; } }\n",
      "fixed_code": "<S2SV_ModStart> goto partno ; if ( len >= sizeof <S2SV_ModEnd> ( tp -> <S2SV_ModStart> tp -> fw_ver ) ) len = sizeof <S2SV_ModEnd> ( tp -> <S2SV_ModStart> tp -> fw_ver ) - 1 ; memset ( tp -> fw_ver , 0 , sizeof ( tp -> fw_ver ) ) ; snprintf ( tp -> fw_ver , sizeof ( tp -> fw_ver ) , \"%.*s<S2SV_blank>bc<S2SV_blank>\" , len , & vpd_data [ j ] <S2SV_ModEnd> ) ; }\n",
      "source_code_length": 3973,
      "target_code_length": 362,
      "vulnerability_patterns": {
        "buffer_overflow": 21,
        "use_after_free": 1,
        "integer_overflow": 4,
        "null_pointer": 58,
        "total": 84
      },
      "total_patterns": 84,
      "original_address": "https://github.com/torvalds/linux/commit/715230a44310a8cf66fbfb5a46f9a62a9b2de424",
      "discovery_time": "2013-06-07T14:03Z",
      "project_commit_id": "torvalds@linux/715230a44310a8cf66fbfb5a46f9a62a9b2de424",
      "extraction_time": "2025-08-31T15:41:49.177346",
      "label": 1,
      "vulnerability_type": "buffer_overflow",
      "difficulty_level": "expert",
      "risk_factors": [
        "memory_corruption",
        "arbitrary_code_execution",
        "buffer_overflow",
        "system_crash",
        "use_after_free"
      ],
      "attack_vectors": [
        "memory_manipulation",
        "malicious_input",
        "code_analysis",
        "buffer_overflow",
        "reverse_engineering",
        "fuzzing"
      ],
      "mitigation_strategies": [
        "safe_string_functions",
        "dynamic_analysis",
        "code_review",
        "static_analysis",
        "memory_safety_checks",
        "input_validation",
        "fuzzing",
        "bounds_checking",
        "secure_coding_practices"
      ],
      "code_differences": {
        "has_differences": true,
        "source_lines": 2,
        "target_lines": 2,
        "character_differences": 3611,
        "similarity_percentage": 16.93548387096774
      },
      "vulnerability_location": {
        "vulnerability_present": true,
        "fix_applied": true,
        "code_changed": true,
        "estimated_lines_changed": 0
      }
    },
    {
      "cve_id": "CVE-2016-7133",
      "cwe_id": "CWE-190",
      "cwe_name": "Integer Overflow",
      "project": "php",
      "severity": "critical",
      "weaponization_score": 10.0,
      "is_critical": true,
      "is_weaponizable": true,
      "is_high_priority_project": true,
      "vulnerable_code": "CWE-190 static void * zend_mm_realloc_heap ( zend_mm_heap * heap , void * ptr , size_t size , size_t copy_size ZEND_FILE_LINE_DC ZEND_FILE_LINE_ORIG_DC ) { size_t page_offset ; size_t old_size ; size_t new_size ; void * ret ; # if ZEND_DEBUG size_t real_size ; zend_mm_debug_info * dbg ; # endif page_offset = ZEND_MM_ALIGNED_OFFSET ( ptr , ZEND_MM_CHUNK_SIZE ) ; if ( UNEXPECTED ( page_offset == 0 ) ) { if ( UNEXPECTED ( ptr == NULL ) ) { return zend_mm_alloc_heap ( heap , size ZEND_FILE_LINE_RELAY_CC ZEND_FILE_LINE_ORIG_RELAY_CC ) ; } old_size = zend_mm_get_huge_block_size ( heap , ptr ZEND_FILE_LINE_RELAY_CC ZEND_FILE_LINE_ORIG_RELAY_CC ) ; # if ZEND_DEBUG real_size = size ; size = ZEND_MM_ALIGNED_SIZE ( size ) + ZEND_MM_ALIGNED_SIZE ( sizeof ( zend_mm_debug_info ) ) ; # endif if ( size > ZEND_MM_MAX_LARGE_SIZE ) { # if ZEND_DEBUG size = real_size ; # endif # ifdef ZEND_WIN32 new_size = ZEND_MM_ALIGNED_SIZE_EX ( size , MAX ( REAL_PAGE_SIZE , ZEND_MM_CHUNK_SIZE ) ) ; # else new_size = ZEND_MM_ALIGNED_SIZE_EX ( size , REAL_PAGE_SIZE ) ; # endif if ( new_size == old_size ) { # if ZEND_DEBUG zend_mm_change_huge_block_size ( heap , ptr , new_size , real_size ZEND_FILE_LINE_RELAY_CC ZEND_FILE_LINE_ORIG_RELAY_CC ) ; # else zend_mm_change_huge_block_size ( heap , ptr , new_size ZEND_FILE_LINE_RELAY_CC ZEND_FILE_LINE_ORIG_RELAY_CC ) ; # endif return ptr ; } else if ( new_size < old_size ) { if ( zend_mm_chunk_truncate ( heap , ptr , old_size , new_size ) ) { # if ZEND_MM_STAT || ZEND_MM_LIMIT heap -> real_size -= old_size - new_size ; # endif # if ZEND_MM_STAT heap -> size -= old_size - new_size ; # endif # if ZEND_DEBUG zend_mm_change_huge_block_size ( heap , ptr , new_size , real_size ZEND_FILE_LINE_RELAY_CC ZEND_FILE_LINE_ORIG_RELAY_CC ) ; # else zend_mm_change_huge_block_size ( heap , ptr , new_size ZEND_FILE_LINE_RELAY_CC ZEND_FILE_LINE_ORIG_RELAY_CC ) ; # endif return ptr ; } } else { # if ZEND_MM_LIMIT if ( UNEXPECTED ( heap -> real_size + ( new_size - old_size ) > heap -> limit ) ) { if ( zend_mm_gc ( heap ) && heap -> real_size + ( new_size - old_size ) <= heap -> limit ) { } else if ( heap -> overflow == 0 ) { # if ZEND_DEBUG zend_mm_safe_error ( heap , \"Allowed<S2SV_blank>memory<S2SV_blank>size<S2SV_blank>of<S2SV_blank>%zu<S2SV_blank>bytes<S2SV_blank>exhausted<S2SV_blank>at<S2SV_blank>%s:%d<S2SV_blank>(tried<S2SV_blank>to<S2SV_blank>allocate<S2SV_blank>%zu<S2SV_blank>bytes)\" , heap -> limit , __zend_filename , __zend_lineno , size ) ; # else zend_mm_safe_error ( heap , \"Allowed<S2SV_blank>memory<S2SV_blank>size<S2SV_blank>of<S2SV_blank>%zu<S2SV_blank>bytes<S2SV_blank>exhausted<S2SV_blank>(tried<S2SV_blank>to<S2SV_blank>allocate<S2SV_blank>%zu<S2SV_blank>bytes)\" , heap -> limit , size ) ; # endif return NULL ; } } # endif if ( zend_mm_chunk_extend ( heap , ptr , old_size , new_size ) ) { # if ZEND_MM_STAT || ZEND_MM_LIMIT heap -> real_size += new_size - old_size ; # endif # if ZEND_MM_STAT heap -> real_peak = MAX ( heap -> real_peak , heap -> real_size ) ; heap -> size += new_size - old_size ; heap -> peak = MAX ( heap -> peak , heap -> size ) ; # endif # if ZEND_DEBUG zend_mm_change_huge_block_size ( heap , ptr , new_size , real_size ZEND_FILE_LINE_RELAY_CC ZEND_FILE_LINE_ORIG_RELAY_CC ) ; # else zend_mm_change_huge_block_size ( heap , ptr , new_size ZEND_FILE_LINE_RELAY_CC ZEND_FILE_LINE_ORIG_RELAY_CC ) ; # endif return ptr ; } } } } else { zend_mm_chunk * chunk = ( zend_mm_chunk * ) ZEND_MM_ALIGNED_BASE ( ptr , ZEND_MM_CHUNK_SIZE ) ; int page_num = ( int ) ( page_offset / ZEND_MM_PAGE_SIZE ) ; zend_mm_page_info info = chunk -> map [ page_num ] ; # if ZEND_DEBUG size_t real_size = size ; size = ZEND_MM_ALIGNED_SIZE ( size ) + ZEND_MM_ALIGNED_SIZE ( sizeof ( zend_mm_debug_info ) ) ; # endif ZEND_MM_CHECK ( chunk -> heap == heap , \"zend_mm_heap<S2SV_blank>corrupted\" ) ; if ( info & ZEND_MM_IS_SRUN ) { <S2SV_StartBug> int old_bin_num , bin_num ; <S2SV_EndBug> old_bin_num = ZEND_MM_SRUN_BIN_NUM ( info ) ; old_size = bin_data_size [ old_bin_num ] ; <S2SV_StartBug> bin_num = ZEND_MM_SMALL_SIZE_TO_BIN ( size ) ; <S2SV_EndBug> if ( old_bin_num == bin_num ) { # if ZEND_DEBUG dbg = zend_mm_get_debug_info ( heap , ptr ) ; dbg -> size = real_size ; dbg -> filename = __zend_filename ; dbg -> orig_filename = __zend_orig_filename ; dbg -> lineno = __zend_lineno ; dbg -> orig_lineno = __zend_orig_lineno ; # endif <S2SV_StartBug> return ptr ; <S2SV_EndBug> } } else { ZEND_MM_CHECK ( ZEND_MM_ALIGNED_OFFSET ( page_offset , ZEND_MM_PAGE_SIZE ) == 0 , \"zend_mm_heap<S2SV_blank>corrupted\" ) ; old_size = ZEND_MM_LRUN_PAGES ( info ) * ZEND_MM_PAGE_SIZE ; if ( size > ZEND_MM_MAX_SMALL_SIZE && size <= ZEND_MM_MAX_LARGE_SIZE ) { new_size = ZEND_MM_ALIGNED_SIZE_EX ( size , ZEND_MM_PAGE_SIZE ) ; if ( new_size == old_size ) { # if ZEND_DEBUG dbg = zend_mm_get_debug_info ( heap , ptr ) ; dbg -> size = real_size ; dbg -> filename = __zend_filename ; dbg -> orig_filename = __zend_orig_filename ; dbg -> lineno = __zend_lineno ; dbg -> orig_lineno = __zend_orig_lineno ; # endif return ptr ; } else if ( new_size < old_size ) { int new_pages_count = ( int ) ( new_size / ZEND_MM_PAGE_SIZE ) ; int rest_pages_count = ( int ) ( ( old_size - new_size ) / ZEND_MM_PAGE_SIZE ) ; # if ZEND_MM_STAT heap -> size -= rest_pages_count * ZEND_MM_PAGE_SIZE ; # endif chunk -> map [ page_num ] = ZEND_MM_LRUN ( new_pages_count ) ; chunk -> free_pages += rest_pages_count ; zend_mm_bitset_reset_range ( chunk -> free_map , page_num + new_pages_count , rest_pages_count ) ; # if ZEND_DEBUG dbg = zend_mm_get_debug_info ( heap , ptr ) ; dbg -> size = real_size ; dbg -> filename = __zend_filename ; dbg -> orig_filename = __zend_orig_filename ; dbg -> lineno = __zend_lineno ; dbg -> orig_lineno = __zend_orig_lineno ; # endif return ptr ; } else { int new_pages_count = ( int ) ( new_size / ZEND_MM_PAGE_SIZE ) ; int old_pages_count = ( int ) ( old_size / ZEND_MM_PAGE_SIZE ) ; if ( page_num + new_pages_count <= ZEND_MM_PAGES && zend_mm_bitset_is_free_range ( chunk -> free_map , page_num + old_pages_count , new_pages_count - old_pages_count ) ) { # if ZEND_MM_STAT do { size_t size = heap -> size + ( new_size - old_size ) ; size_t peak = MAX ( heap -> peak , size ) ; heap -> size = size ; heap -> peak = peak ; } while ( 0 ) ; # endif chunk -> free_pages -= new_pages_count - old_pages_count ; zend_mm_bitset_set_range ( chunk -> free_map , page_num + old_pages_count , new_pages_count - old_pages_count ) ; chunk -> map [ page_num ] = ZEND_MM_LRUN ( new_pages_count ) ; # if ZEND_DEBUG dbg = zend_mm_get_debug_info ( heap , ptr ) ; dbg -> size = real_size ; dbg -> filename = __zend_filename ; dbg -> orig_filename = __zend_orig_filename ; dbg -> lineno = __zend_lineno ; dbg -> orig_lineno = __zend_orig_lineno ; # endif return ptr ; } } } } # if ZEND_DEBUG size = real_size ; # endif } # if ZEND_MM_STAT do { size_t orig_peak = heap -> peak ; size_t orig_real_peak = heap -> real_peak ; # endif ret = zend_mm_alloc_heap ( heap , size ZEND_FILE_LINE_RELAY_CC ZEND_FILE_LINE_ORIG_RELAY_CC ) ; memcpy ( ret , ptr , MIN ( old_size , copy_size ) ) ; zend_mm_free_heap ( heap , ptr ZEND_FILE_LINE_RELAY_CC ZEND_FILE_LINE_ORIG_RELAY_CC ) ; # if ZEND_MM_STAT heap -> peak = MAX ( orig_peak , heap -> size ) ; heap -> real_peak = MAX ( orig_real_peak , heap -> real_size ) ; } while ( 0 ) ; # endif return ret ; }\n",
      "fixed_code": "<S2SV_ModStart> { int old_bin_num <S2SV_ModEnd> = ZEND_MM_SRUN_BIN_NUM ( <S2SV_ModStart> old_bin_num ] ; if ( size <= ZEND_MM_MAX_SMALL_SIZE ) { int <S2SV_ModStart> return ptr ; }\n",
      "source_code_length": 7359,
      "target_code_length": 180,
      "vulnerability_patterns": {
        "buffer_overflow": 1,
        "use_after_free": 35,
        "integer_overflow": 7,
        "null_pointer": 57,
        "total": 100
      },
      "total_patterns": 100,
      "original_address": "https://github.com/php/php-src/commit/c2a13ced4272f2e65d2773e2ea6ca11c1ce4a911?w=1",
      "discovery_time": "2016-09-12T01:59Z",
      "project_commit_id": "php@php-src/c2a13ced4272f2e65d2773e2ea6ca11c1ce4a911",
      "extraction_time": "2025-08-31T15:41:49.177404",
      "label": 1,
      "vulnerability_type": "integer_overflow",
      "difficulty_level": "expert",
      "risk_factors": [
        "memory_corruption",
        "critical_infrastructure",
        "buffer_overflow",
        "information_disclosure",
        "use_after_free",
        "integer_overflow"
      ],
      "attack_vectors": [
        "fuzzing",
        "code_analysis",
        "reverse_engineering"
      ],
      "mitigation_strategies": [
        "dynamic_analysis",
        "static_analysis",
        "fuzzing",
        "code_review",
        "secure_coding_practices"
      ],
      "code_differences": {
        "has_differences": true,
        "source_lines": 2,
        "target_lines": 2,
        "character_differences": 7179,
        "similarity_percentage": 12.598425196850393
      },
      "vulnerability_location": {
        "vulnerability_present": true,
        "fix_applied": true,
        "code_changed": true,
        "estimated_lines_changed": 0
      }
    },
    {
      "cve_id": "CVE-2013-1929",
      "cwe_id": "CWE-119",
      "cwe_name": "Buffer Overflow",
      "project": "torvalds",
      "severity": "critical",
      "weaponization_score": 10.0,
      "is_critical": true,
      "is_weaponizable": true,
      "is_high_priority_project": false,
      "vulnerable_code": "CWE-119 static void tg3_read_vpd ( struct tg3 * tp ) { u8 * vpd_data ; unsigned int block_end , rosize , len ; u32 vpdlen ; int j , i = 0 ; vpd_data = ( u8 * ) tg3_vpd_readblock ( tp , & vpdlen ) ; if ( ! vpd_data ) goto out_no_vpd ; i = pci_vpd_find_tag ( vpd_data , 0 , vpdlen , PCI_VPD_LRDT_RO_DATA ) ; if ( i < 0 ) goto out_not_found ; rosize = pci_vpd_lrdt_size ( & vpd_data [ i ] ) ; block_end = i + PCI_VPD_LRDT_TAG_SIZE + rosize ; i += PCI_VPD_LRDT_TAG_SIZE ; if ( block_end > vpdlen ) goto out_not_found ; j = pci_vpd_find_info_keyword ( vpd_data , i , rosize , PCI_VPD_RO_KEYWORD_MFR_ID ) ; if ( j > 0 ) { len = pci_vpd_info_field_size ( & vpd_data [ j ] ) ; j += PCI_VPD_INFO_FLD_HDR_SIZE ; if ( j + len > block_end || len != 4 || memcmp ( & vpd_data [ j ] , \"1028\" , 4 ) ) goto partno ; j = pci_vpd_find_info_keyword ( vpd_data , i , rosize , PCI_VPD_RO_KEYWORD_VENDOR0 ) ; if ( j < 0 ) goto partno ; len = pci_vpd_info_field_size ( & vpd_data [ j ] ) ; j += PCI_VPD_INFO_FLD_HDR_SIZE ; if ( j + len > block_end ) goto partno ; <S2SV_StartBug> memcpy ( tp -> fw_ver , & vpd_data [ j ] , len ) ; <S2SV_EndBug> <S2SV_StartBug> strncat ( tp -> fw_ver , \"<S2SV_blank>bc<S2SV_blank>\" , vpdlen - len - 1 ) ; <S2SV_EndBug> } partno : i = pci_vpd_find_info_keyword ( vpd_data , i , rosize , PCI_VPD_RO_KEYWORD_PARTNO ) ; if ( i < 0 ) goto out_not_found ; len = pci_vpd_info_field_size ( & vpd_data [ i ] ) ; i += PCI_VPD_INFO_FLD_HDR_SIZE ; if ( len > TG3_BPN_SIZE || ( len + i ) > vpdlen ) goto out_not_found ; memcpy ( tp -> board_part_number , & vpd_data [ i ] , len ) ; out_not_found : kfree ( vpd_data ) ; if ( tp -> board_part_number [ 0 ] ) return ; out_no_vpd : if ( tg3_asic_rev ( tp ) == ASIC_REV_5717 ) { if ( tp -> pdev -> device == TG3PCI_DEVICE_TIGON3_5717 || tp -> pdev -> device == TG3PCI_DEVICE_TIGON3_5717_C ) strcpy ( tp -> board_part_number , \"BCM5717\" ) ; else if ( tp -> pdev -> device == TG3PCI_DEVICE_TIGON3_5718 ) strcpy ( tp -> board_part_number , \"BCM5718\" ) ; else goto nomatch ; } else if ( tg3_asic_rev ( tp ) == ASIC_REV_57780 ) { if ( tp -> pdev -> device == TG3PCI_DEVICE_TIGON3_57780 ) strcpy ( tp -> board_part_number , \"BCM57780\" ) ; else if ( tp -> pdev -> device == TG3PCI_DEVICE_TIGON3_57760 ) strcpy ( tp -> board_part_number , \"BCM57760\" ) ; else if ( tp -> pdev -> device == TG3PCI_DEVICE_TIGON3_57790 ) strcpy ( tp -> board_part_number , \"BCM57790\" ) ; else if ( tp -> pdev -> device == TG3PCI_DEVICE_TIGON3_57788 ) strcpy ( tp -> board_part_number , \"BCM57788\" ) ; else goto nomatch ; } else if ( tg3_asic_rev ( tp ) == ASIC_REV_57765 ) { if ( tp -> pdev -> device == TG3PCI_DEVICE_TIGON3_57761 ) strcpy ( tp -> board_part_number , \"BCM57761\" ) ; else if ( tp -> pdev -> device == TG3PCI_DEVICE_TIGON3_57765 ) strcpy ( tp -> board_part_number , \"BCM57765\" ) ; else if ( tp -> pdev -> device == TG3PCI_DEVICE_TIGON3_57781 ) strcpy ( tp -> board_part_number , \"BCM57781\" ) ; else if ( tp -> pdev -> device == TG3PCI_DEVICE_TIGON3_57785 ) strcpy ( tp -> board_part_number , \"BCM57785\" ) ; else if ( tp -> pdev -> device == TG3PCI_DEVICE_TIGON3_57791 ) strcpy ( tp -> board_part_number , \"BCM57791\" ) ; else if ( tp -> pdev -> device == TG3PCI_DEVICE_TIGON3_57795 ) strcpy ( tp -> board_part_number , \"BCM57795\" ) ; else goto nomatch ; } else if ( tg3_asic_rev ( tp ) == ASIC_REV_57766 ) { if ( tp -> pdev -> device == TG3PCI_DEVICE_TIGON3_57762 ) strcpy ( tp -> board_part_number , \"BCM57762\" ) ; else if ( tp -> pdev -> device == TG3PCI_DEVICE_TIGON3_57766 ) strcpy ( tp -> board_part_number , \"BCM57766\" ) ; else if ( tp -> pdev -> device == TG3PCI_DEVICE_TIGON3_57782 ) strcpy ( tp -> board_part_number , \"BCM57782\" ) ; else if ( tp -> pdev -> device == TG3PCI_DEVICE_TIGON3_57786 ) strcpy ( tp -> board_part_number , \"BCM57786\" ) ; else goto nomatch ; } else if ( tg3_asic_rev ( tp ) == ASIC_REV_5906 ) { strcpy ( tp -> board_part_number , \"BCM95906\" ) ; } else { nomatch : strcpy ( tp -> board_part_number , \"none\" ) ; } }\n",
      "fixed_code": "<S2SV_ModStart> goto partno ; if ( len >= sizeof <S2SV_ModEnd> ( tp -> <S2SV_ModStart> tp -> fw_ver ) ) len = sizeof <S2SV_ModEnd> ( tp -> <S2SV_ModStart> tp -> fw_ver ) - 1 ; memset ( tp -> fw_ver , 0 , sizeof ( tp -> fw_ver ) ) ; snprintf ( tp -> fw_ver , sizeof ( tp -> fw_ver ) , \"%.*s<S2SV_blank>bc<S2SV_blank>\" , len , & vpd_data [ j ] <S2SV_ModEnd> ) ; }\n",
      "source_code_length": 3973,
      "target_code_length": 362,
      "vulnerability_patterns": {
        "buffer_overflow": 21,
        "use_after_free": 1,
        "integer_overflow": 4,
        "null_pointer": 58,
        "total": 84
      },
      "total_patterns": 84,
      "original_address": "https://github.com/torvalds/linux/commit/715230a44310a8cf66fbfb5a46f9a62a9b2de424",
      "discovery_time": "2013-06-07T14:03Z",
      "project_commit_id": "torvalds@linux/715230a44310a8cf66fbfb5a46f9a62a9b2de424",
      "extraction_time": "2025-08-31T15:41:49.177474",
      "label": 1,
      "vulnerability_type": "buffer_overflow",
      "difficulty_level": "expert",
      "risk_factors": [
        "memory_corruption",
        "arbitrary_code_execution",
        "buffer_overflow",
        "system_crash",
        "use_after_free"
      ],
      "attack_vectors": [
        "memory_manipulation",
        "malicious_input",
        "code_analysis",
        "buffer_overflow",
        "reverse_engineering",
        "fuzzing"
      ],
      "mitigation_strategies": [
        "safe_string_functions",
        "dynamic_analysis",
        "code_review",
        "static_analysis",
        "memory_safety_checks",
        "input_validation",
        "fuzzing",
        "bounds_checking",
        "secure_coding_practices"
      ],
      "code_differences": {
        "has_differences": true,
        "source_lines": 2,
        "target_lines": 2,
        "character_differences": 3611,
        "similarity_percentage": 16.93548387096774
      },
      "vulnerability_location": {
        "vulnerability_present": true,
        "fix_applied": true,
        "code_changed": true,
        "estimated_lines_changed": 0
      }
    },
    {
      "cve_id": "CVE-2016-3062",
      "cwe_id": "CWE-119",
      "cwe_name": "Buffer Overflow",
      "project": "FFmpeg",
      "severity": "critical",
      "weaponization_score": 10.0,
      "is_critical": true,
      "is_weaponizable": true,
      "is_high_priority_project": true,
      "vulnerable_code": "CWE-119 static int mov_read_dref ( MOVContext * c , AVIOContext * pb , MOVAtom atom ) { AVStream * st ; MOVStreamContext * sc ; int entries , i , j ; if ( c -> fc -> nb_streams < 1 ) return 0 ; st = c -> fc -> streams [ c -> fc -> nb_streams - 1 ] ; sc = st -> priv_data ; avio_rb32 ( pb ) ; entries = avio_rb32 ( pb ) ; if ( entries >= UINT_MAX / sizeof ( * sc -> drefs ) ) return AVERROR_INVALIDDATA ; av_free ( sc -> drefs ) ; <S2SV_StartBug> sc -> drefs = av_mallocz ( entries * sizeof ( * sc -> drefs ) ) ; <S2SV_EndBug> if ( ! sc -> drefs ) return AVERROR ( ENOMEM ) ; sc -> drefs_count = entries ; for ( i = 0 ; i < sc -> drefs_count ; i ++ ) { MOVDref * dref = & sc -> drefs [ i ] ; uint32_t size = avio_rb32 ( pb ) ; int64_t next = avio_tell ( pb ) + size - 4 ; if ( size < 12 ) return AVERROR_INVALIDDATA ; dref -> type = avio_rl32 ( pb ) ; avio_rb32 ( pb ) ; av_dlog ( c -> fc , \"type<S2SV_blank>%.4s<S2SV_blank>size<S2SV_blank>%d\\\\n\" , ( char * ) & dref -> type , size ) ; if ( dref -> type == MKTAG ( 'a' , 'l' , 'i' , 's' ) && size > 150 ) { uint16_t volume_len , len ; int16_t type ; avio_skip ( pb , 10 ) ; volume_len = avio_r8 ( pb ) ; volume_len = FFMIN ( volume_len , 27 ) ; avio_read ( pb , dref -> volume , 27 ) ; dref -> volume [ volume_len ] = 0 ; av_log ( c -> fc , AV_LOG_DEBUG , \"volume<S2SV_blank>%s,<S2SV_blank>len<S2SV_blank>%d\\\\n\" , dref -> volume , volume_len ) ; avio_skip ( pb , 12 ) ; len = avio_r8 ( pb ) ; len = FFMIN ( len , 63 ) ; avio_read ( pb , dref -> filename , 63 ) ; dref -> filename [ len ] = 0 ; av_log ( c -> fc , AV_LOG_DEBUG , \"filename<S2SV_blank>%s,<S2SV_blank>len<S2SV_blank>%d\\\\n\" , dref -> filename , len ) ; avio_skip ( pb , 16 ) ; dref -> nlvl_from = avio_rb16 ( pb ) ; dref -> nlvl_to = avio_rb16 ( pb ) ; av_log ( c -> fc , AV_LOG_DEBUG , \"nlvl<S2SV_blank>from<S2SV_blank>%d,<S2SV_blank>nlvl<S2SV_blank>to<S2SV_blank>%d\\\\n\" , dref -> nlvl_from , dref -> nlvl_to ) ; avio_skip ( pb , 16 ) ; for ( type = 0 ; type != - 1 && avio_tell ( pb ) < next ; ) { if ( url_feof ( pb ) ) return AVERROR_EOF ; type = avio_rb16 ( pb ) ; len = avio_rb16 ( pb ) ; av_log ( c -> fc , AV_LOG_DEBUG , \"type<S2SV_blank>%d,<S2SV_blank>len<S2SV_blank>%d\\\\n\" , type , len ) ; if ( len & 1 ) len += 1 ; if ( type == 2 ) { av_free ( dref -> path ) ; dref -> path = av_mallocz ( len + 1 ) ; if ( ! dref -> path ) return AVERROR ( ENOMEM ) ; avio_read ( pb , dref -> path , len ) ; if ( len > volume_len && ! strncmp ( dref -> path , dref -> volume , volume_len ) ) { len -= volume_len ; memmove ( dref -> path , dref -> path + volume_len , len ) ; dref -> path [ len ] = 0 ; } for ( j = 0 ; j < len ; j ++ ) if ( dref -> path [ j ] == ':' ) dref -> path [ j ] = '/' ; av_log ( c -> fc , AV_LOG_DEBUG , \"path<S2SV_blank>%s\\\\n\" , dref -> path ) ; } else if ( type == 0 ) { av_free ( dref -> dir ) ; dref -> dir = av_malloc ( len + 1 ) ; if ( ! dref -> dir ) return AVERROR ( ENOMEM ) ; avio_read ( pb , dref -> dir , len ) ; dref -> dir [ len ] = 0 ; for ( j = 0 ; j < len ; j ++ ) if ( dref -> dir [ j ] == ':' ) dref -> dir [ j ] = '/' ; av_log ( c -> fc , AV_LOG_DEBUG , \"dir<S2SV_blank>%s\\\\n\" , dref -> dir ) ; } else avio_skip ( pb , len ) ; } } avio_seek ( pb , next , SEEK_SET ) ; } return 0 ; }\n",
      "fixed_code": "<S2SV_ModStart> ; sc -> drefs_count = 0 ; sc ->\n",
      "source_code_length": 3233,
      "target_code_length": 48,
      "vulnerability_patterns": {
        "buffer_overflow": 1,
        "integer_overflow": 5,
        "null_pointer": 55,
        "total": 61
      },
      "total_patterns": 61,
      "original_address": "https://github.com/FFmpeg/FFmpeg/commit/689e59b7ffed34eba6159dcc78e87133862e3746",
      "discovery_time": "2016-06-16T18:59Z",
      "project_commit_id": "FFmpeg@FFmpeg/689e59b7ffed34eba6159dcc78e87133862e3746",
      "extraction_time": "2025-08-31T15:41:49.177519",
      "label": 1,
      "vulnerability_type": "buffer_overflow",
      "difficulty_level": "expert",
      "risk_factors": [
        "memory_corruption",
        "critical_infrastructure",
        "arbitrary_code_execution",
        "buffer_overflow",
        "system_crash"
      ],
      "attack_vectors": [
        "memory_manipulation",
        "malicious_input",
        "code_analysis",
        "buffer_overflow",
        "reverse_engineering",
        "fuzzing"
      ],
      "mitigation_strategies": [
        "safe_string_functions",
        "dynamic_analysis",
        "code_review",
        "static_analysis",
        "memory_safety_checks",
        "input_validation",
        "fuzzing",
        "bounds_checking",
        "secure_coding_practices"
      ],
      "code_differences": {
        "has_differences": true,
        "source_lines": 2,
        "target_lines": 2,
        "character_differences": 3185,
        "similarity_percentage": 4.918032786885246
      },
      "vulnerability_location": {
        "vulnerability_present": true,
        "fix_applied": true,
        "code_changed": true,
        "estimated_lines_changed": 0
      }
    },
    {
      "cve_id": "CVE-2016-10066",
      "cwe_id": "CWE-119",
      "cwe_name": "Buffer Overflow",
      "project": "ImageMagick",
      "severity": "critical",
      "weaponization_score": 10.0,
      "is_critical": true,
      "is_weaponizable": true,
      "is_high_priority_project": true,
      "vulnerable_code": "CWE-119 static Image * ReadAAIImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { Image * image ; MagickBooleanType status ; register ssize_t x ; register PixelPacket * q ; register unsigned char * p ; size_t height , length , width ; ssize_t count , y ; unsigned char * pixels ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickSignature ) ; if ( image_info -> debug != MagickFalse ) ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , \"%s\" , image_info -> filename ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickSignature ) ; image = AcquireImage ( image_info ) ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } width = ReadBlobLSBLong ( image ) ; height = ReadBlobLSBLong ( image ) ; if ( EOFBlob ( image ) != MagickFalse ) ThrowReaderException ( CorruptImageError , \"ImproperImageHeader\" ) ; if ( ( width == 0UL ) || ( height == 0UL ) ) ThrowReaderException ( CorruptImageError , \"ImproperImageHeader\" ) ; do { image -> columns = width ; image -> rows = height ; image -> depth = 8 ; if ( ( image_info -> ping != MagickFalse ) && ( image_info -> number_scenes != 0 ) ) if ( image -> scene >= ( image_info -> scene + image_info -> number_scenes - 1 ) ) break ; <S2SV_StartBug> pixels = ( unsigned char * ) AcquireQuantumMemory ( image -> columns , <S2SV_EndBug> 4 * sizeof ( * pixels ) ) ; if ( pixels == ( unsigned char * ) NULL ) ThrowReaderException ( ResourceLimitError , \"MemoryAllocationFailed\" ) ; length = ( size_t ) 4 * image -> columns ; for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { count = ReadBlob ( image , length , pixels ) ; if ( ( size_t ) count != length ) ThrowReaderException ( CorruptImageError , \"UnableToReadImageData\" ) ; p = pixels ; q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( PixelPacket * ) NULL ) break ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { SetPixelBlue ( q , ScaleCharToQuantum ( * p ++ ) ) ; SetPixelGreen ( q , ScaleCharToQuantum ( * p ++ ) ) ; SetPixelRed ( q , ScaleCharToQuantum ( * p ++ ) ) ; if ( * p == 254 ) * p = 255 ; SetPixelAlpha ( q , ScaleCharToQuantum ( * p ++ ) ) ; if ( q -> opacity != OpaqueOpacity ) image -> matte = MagickTrue ; q ++ ; } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ; if ( status == MagickFalse ) break ; } } pixels = ( unsigned char * ) RelinquishMagickMemory ( pixels ) ; if ( EOFBlob ( image ) != MagickFalse ) { ThrowFileException ( exception , CorruptImageError , \"UnexpectedEndOfFile\" , image -> filename ) ; break ; } if ( image_info -> number_scenes != 0 ) if ( image -> scene >= ( image_info -> scene + image_info -> number_scenes - 1 ) ) break ; width = ReadBlobLSBLong ( image ) ; height = ReadBlobLSBLong ( image ) ; if ( ( width != 0UL ) && ( height != 0UL ) ) { AcquireNextImage ( image_info , image ) ; if ( GetNextImageInList ( image ) == ( Image * ) NULL ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } image = SyncNextImageInList ( image ) ; status = SetImageProgress ( image , LoadImagesTag , TellBlob ( image ) , GetBlobSize ( image ) ) ; if ( status == MagickFalse ) break ; } } while ( ( width != 0UL ) && ( height != 0UL ) ) ; ( void ) CloseBlob ( image ) ; return ( GetFirstImageInList ( image ) ) ; }\n",
      "fixed_code": "<S2SV_ModStart> ) break ; status = SetImageExtent ( image , image -> columns , image -> rows ) ; if ( status == MagickFalse ) { InheritException ( exception , & image -> exception ) ; return ( DestroyImageList ( image ) ) ; }\n",
      "source_code_length": 3617,
      "target_code_length": 226,
      "vulnerability_patterns": {
        "buffer_overflow": 1,
        "integer_overflow": 16,
        "null_pointer": 44,
        "total": 61
      },
      "total_patterns": 61,
      "original_address": "https://github.com/ImageMagick/ImageMagick/commit/f6e9d0d9955e85bdd7540b251cd50d598dacc5e6",
      "discovery_time": "2017-03-03T17:59Z",
      "project_commit_id": "ImageMagick@ImageMagick/f6e9d0d9955e85bdd7540b251cd50d598dacc5e6",
      "extraction_time": "2025-08-31T15:41:49.177556",
      "label": 1,
      "vulnerability_type": "buffer_overflow",
      "difficulty_level": "expert",
      "risk_factors": [
        "memory_corruption",
        "critical_infrastructure",
        "arbitrary_code_execution",
        "buffer_overflow",
        "system_crash"
      ],
      "attack_vectors": [
        "memory_manipulation",
        "malicious_input",
        "code_analysis",
        "buffer_overflow",
        "reverse_engineering",
        "fuzzing"
      ],
      "mitigation_strategies": [
        "safe_string_functions",
        "dynamic_analysis",
        "code_review",
        "static_analysis",
        "memory_safety_checks",
        "input_validation",
        "fuzzing",
        "bounds_checking",
        "secure_coding_practices"
      ],
      "code_differences": {
        "has_differences": true,
        "source_lines": 2,
        "target_lines": 2,
        "character_differences": 3391,
        "similarity_percentage": 15.447154471544716
      },
      "vulnerability_location": {
        "vulnerability_present": true,
        "fix_applied": true,
        "code_changed": true,
        "estimated_lines_changed": 0
      }
    },
    {
      "cve_id": "CVE-2014-5354",
      "cwe_id": "CWE-000",
      "cwe_name": "Unknown/Uncategorized",
      "project": "krb5",
      "severity": "critical",
      "weaponization_score": 10.0,
      "is_critical": true,
      "is_weaponizable": true,
      "is_high_priority_project": true,
      "vulnerable_code": "CWE-000 krb5_error_code krb5_ldap_put_principal ( krb5_context context , krb5_db_entry * entry , char * * db_args ) { int l = 0 , kerberos_principal_object_type = 0 ; unsigned int ntrees = 0 , tre = 0 ; krb5_error_code st = 0 , tempst = 0 ; LDAP * ld = NULL ; LDAPMessage * result = NULL , * ent = NULL ; char * * subtreelist = NULL ; char * user = NULL , * subtree = NULL , * principal_dn = NULL ; char * * values = NULL , * strval [ 10 ] = { NULL } , errbuf [ 1024 ] ; char * filtuser = NULL ; struct berval * * bersecretkey = NULL ; LDAPMod * * mods = NULL ; krb5_boolean create_standalone_prinicipal = FALSE ; krb5_boolean krb_identity_exists = FALSE , establish_links = FALSE ; char * standalone_principal_dn = NULL ; krb5_tl_data * tl_data = NULL ; krb5_key_data * * keys = NULL ; kdb5_dal_handle * dal_handle = NULL ; krb5_ldap_context * ldap_context = NULL ; krb5_ldap_server_handle * ldap_server_handle = NULL ; osa_princ_ent_rec princ_ent = { 0 } ; xargs_t xargs = { 0 } ; char * polname = NULL ; OPERATION optype ; krb5_boolean found_entry = FALSE ; krb5_clear_error_message ( context ) ; SETUP_CONTEXT ( ) ; if ( ldap_context -> lrparams == NULL || ldap_context -> container_dn == NULL ) return EINVAL ; GET_HANDLE ( ) ; if ( ! is_principal_in_realm ( ldap_context , entry -> princ ) ) { st = EINVAL ; k5_setmsg ( context , st , _ ( \"Principal<S2SV_blank>does<S2SV_blank>not<S2SV_blank>belong<S2SV_blank>to<S2SV_blank>the<S2SV_blank>default<S2SV_blank>realm\" ) ) ; goto cleanup ; } if ( ( ( st = krb5_unparse_name ( context , entry -> princ , & user ) ) != 0 ) || ( ( st = krb5_ldap_unparse_principal_name ( user ) ) != 0 ) ) goto cleanup ; filtuser = ldap_filter_correct ( user ) ; if ( filtuser == NULL ) { st = ENOMEM ; goto cleanup ; } if ( entry -> mask & KADM5_PRINCIPAL ) optype = ADD_PRINCIPAL ; else optype = MODIFY_PRINCIPAL ; if ( ( ( st = krb5_get_princ_type ( context , entry , & kerberos_principal_object_type ) ) != 0 ) || ( ( st = krb5_get_userdn ( context , entry , & principal_dn ) ) != 0 ) ) goto cleanup ; if ( ( st = process_db_args ( context , db_args , & xargs , optype ) ) != 0 ) goto cleanup ; if ( entry -> mask & KADM5_LOAD ) { unsigned int tree = 0 ; int numlentries = 0 ; char * filter = NULL ; if ( asprintf ( & filter , FILTER \"%s))\" , filtuser ) < 0 ) { filter = NULL ; st = ENOMEM ; goto cleanup ; } if ( ( st = krb5_get_subtree_info ( ldap_context , & subtreelist , & ntrees ) ) != 0 ) goto cleanup ; found_entry = FALSE ; for ( tree = 0 ; found_entry == FALSE && tree < ntrees ; ++ tree ) { if ( principal_dn == NULL ) { LDAP_SEARCH_1 ( subtreelist [ tree ] , ldap_context -> lrparams -> search_scope , filter , principal_attributes , IGNORE_STATUS ) ; } else { LDAP_SEARCH_1 ( principal_dn , LDAP_SCOPE_BASE , filter , principal_attributes , IGNORE_STATUS ) ; } if ( st == LDAP_SUCCESS ) { numlentries = ldap_count_entries ( ld , result ) ; if ( numlentries > 1 ) { free ( filter ) ; st = EINVAL ; k5_setmsg ( context , st , _ ( \"operation<S2SV_blank>can<S2SV_blank>not<S2SV_blank>continue,<S2SV_blank>more<S2SV_blank>than<S2SV_blank>one<S2SV_blank>\" \"entry<S2SV_blank>with<S2SV_blank>principal<S2SV_blank>name<S2SV_blank>\\\\\"%s\\\\\"<S2SV_blank>found\" ) , user ) ; goto cleanup ; } else if ( numlentries == 1 ) { found_entry = TRUE ; if ( principal_dn == NULL ) { ent = ldap_first_entry ( ld , result ) ; if ( ent != NULL ) { if ( ( principal_dn = ldap_get_dn ( ld , ent ) ) == NULL ) { ldap_get_option ( ld , LDAP_OPT_RESULT_CODE , & st ) ; st = set_ldap_error ( context , st , 0 ) ; free ( filter ) ; goto cleanup ; } } } } } else if ( st != LDAP_NO_SUCH_OBJECT ) { st = set_ldap_error ( context , st , 0 ) ; free ( filter ) ; goto cleanup ; } ldap_msgfree ( result ) ; result = NULL ; } free ( filter ) ; if ( found_entry == FALSE && principal_dn != NULL ) { create_standalone_prinicipal = TRUE ; standalone_principal_dn = strdup ( principal_dn ) ; CHECK_NULL ( standalone_principal_dn ) ; } } if ( principal_dn == NULL && xargs . dn == NULL ) { if ( entry -> princ -> length == 2 && entry -> princ -> data [ 0 ] . length == strlen ( \"krbtgt\" ) && strncmp ( entry -> princ -> data [ 0 ] . data , \"krbtgt\" , entry -> princ -> data [ 0 ] . length ) == 0 ) { subtree = strdup ( ldap_context -> lrparams -> realmdn ) ; } else if ( xargs . containerdn ) { if ( ( st = checkattributevalue ( ld , xargs . containerdn , NULL , NULL , NULL ) ) != 0 ) { if ( st == KRB5_KDB_NOENTRY || st == KRB5_KDB_CONSTRAINT_VIOLATION ) { int ost = st ; st = EINVAL ; k5_prependmsg ( context , ost , st , _ ( \"\\'%s\\'<S2SV_blank>not<S2SV_blank>found\" ) , xargs . containerdn ) ; } goto cleanup ; } subtree = strdup ( xargs . containerdn ) ; } else if ( ldap_context -> lrparams -> containerref && strlen ( ldap_context -> lrparams -> containerref ) != 0 ) { subtree = strdup ( ldap_context -> lrparams -> containerref ) ; } else { subtree = strdup ( ldap_context -> lrparams -> realmdn ) ; } CHECK_NULL ( subtree ) ; if ( asprintf ( & standalone_principal_dn , \"krbprincipalname=%s,%s\" , filtuser , subtree ) < 0 ) standalone_principal_dn = NULL ; CHECK_NULL ( standalone_principal_dn ) ; create_standalone_prinicipal = TRUE ; free ( subtree ) ; subtree = NULL ; } if ( xargs . dn_from_kbd == TRUE ) { int dnlen = 0 , subtreelen = 0 ; char * dn = NULL ; krb5_boolean outofsubtree = TRUE ; if ( xargs . dn != NULL ) { dn = xargs . dn ; } else if ( xargs . linkdn != NULL ) { dn = xargs . linkdn ; } else if ( standalone_principal_dn != NULL ) { dn = standalone_principal_dn ; } if ( subtreelist == NULL ) { st = krb5_get_subtree_info ( ldap_context , & subtreelist , & ntrees ) ; if ( st ) goto cleanup ; } for ( tre = 0 ; tre < ntrees ; ++ tre ) { if ( subtreelist [ tre ] == NULL || strlen ( subtreelist [ tre ] ) == 0 ) { outofsubtree = FALSE ; break ; } else { dnlen = strlen ( dn ) ; subtreelen = strlen ( subtreelist [ tre ] ) ; if ( ( dnlen >= subtreelen ) && ( strcasecmp ( ( dn + dnlen - subtreelen ) , subtreelist [ tre ] ) == 0 ) ) { outofsubtree = FALSE ; break ; } } } if ( outofsubtree == TRUE ) { st = EINVAL ; k5_setmsg ( context , st , _ ( \"DN<S2SV_blank>is<S2SV_blank>out<S2SV_blank>of<S2SV_blank>the<S2SV_blank>realm<S2SV_blank>subtree\" ) ) ; goto cleanup ; } if ( standalone_principal_dn == NULL ) { char * attributes [ ] = { \"krbticketpolicyreference\" , \"krbprincipalname\" , NULL } ; ldap_msgfree ( result ) ; result = NULL ; LDAP_SEARCH_1 ( dn , LDAP_SCOPE_BASE , 0 , attributes , IGNORE_STATUS ) ; if ( st == LDAP_SUCCESS ) { ent = ldap_first_entry ( ld , result ) ; if ( ent != NULL ) { if ( ( values = ldap_get_values ( ld , ent , \"krbticketpolicyreference\" ) ) != NULL ) { ldap_value_free ( values ) ; } if ( ( values = ldap_get_values ( ld , ent , \"krbprincipalname\" ) ) != NULL ) { krb_identity_exists = TRUE ; ldap_value_free ( values ) ; } } } else { st = set_ldap_error ( context , st , OP_SEARCH ) ; goto cleanup ; } } } if ( xargs . dn != NULL && krb_identity_exists == TRUE ) { st = EINVAL ; snprintf ( errbuf , sizeof ( errbuf ) , _ ( \"ldap<S2SV_blank>object<S2SV_blank>is<S2SV_blank>already<S2SV_blank>kerberized\" ) ) ; k5_setmsg ( context , st , \"%s\" , errbuf ) ; goto cleanup ; } if ( xargs . linkdn != NULL ) { if ( optype == MODIFY_PRINCIPAL && kerberos_principal_object_type != KDB_STANDALONE_PRINCIPAL_OBJECT ) { st = EINVAL ; snprintf ( errbuf , sizeof ( errbuf ) , _ ( \"link<S2SV_blank>information<S2SV_blank>can<S2SV_blank>not<S2SV_blank>be<S2SV_blank>set/updated<S2SV_blank>as<S2SV_blank>the<S2SV_blank>\" \"kerberos<S2SV_blank>principal<S2SV_blank>belongs<S2SV_blank>to<S2SV_blank>an<S2SV_blank>ldap<S2SV_blank>object\" ) ) ; k5_setmsg ( context , st , \"%s\" , errbuf ) ; goto cleanup ; } { char * * linkdns = NULL ; int j = 0 ; if ( ( st = krb5_get_linkdn ( context , entry , & linkdns ) ) != 0 ) { snprintf ( errbuf , sizeof ( errbuf ) , _ ( \"Failed<S2SV_blank>getting<S2SV_blank>object<S2SV_blank>references\" ) ) ; k5_setmsg ( context , st , \"%s\" , errbuf ) ; goto cleanup ; } if ( linkdns != NULL ) { st = EINVAL ; snprintf ( errbuf , sizeof ( errbuf ) , _ ( \"kerberos<S2SV_blank>principal<S2SV_blank>is<S2SV_blank>already<S2SV_blank>linked<S2SV_blank>to<S2SV_blank>a<S2SV_blank>ldap<S2SV_blank>\" \"object\" ) ) ; k5_setmsg ( context , st , \"%s\" , errbuf ) ; for ( j = 0 ; linkdns [ j ] != NULL ; ++ j ) free ( linkdns [ j ] ) ; free ( linkdns ) ; goto cleanup ; } } establish_links = TRUE ; } if ( entry -> mask & KADM5_LAST_SUCCESS ) { memset ( strval , 0 , sizeof ( strval ) ) ; if ( ( strval [ 0 ] = getstringtime ( entry -> last_success ) ) == NULL ) goto cleanup ; if ( ( st = krb5_add_str_mem_ldap_mod ( & mods , \"krbLastSuccessfulAuth\" , LDAP_MOD_REPLACE , strval ) ) != 0 ) { free ( strval [ 0 ] ) ; goto cleanup ; } free ( strval [ 0 ] ) ; } if ( entry -> mask & KADM5_LAST_FAILED ) { memset ( strval , 0 , sizeof ( strval ) ) ; if ( ( strval [ 0 ] = getstringtime ( entry -> last_failed ) ) == NULL ) goto cleanup ; if ( ( st = krb5_add_str_mem_ldap_mod ( & mods , \"krbLastFailedAuth\" , LDAP_MOD_REPLACE , strval ) ) != 0 ) { free ( strval [ 0 ] ) ; goto cleanup ; } free ( strval [ 0 ] ) ; } if ( entry -> mask & KADM5_FAIL_AUTH_COUNT ) { krb5_kvno fail_auth_count ; fail_auth_count = entry -> fail_auth_count ; if ( entry -> mask & KADM5_FAIL_AUTH_COUNT_INCREMENT ) fail_auth_count ++ ; st = krb5_add_int_mem_ldap_mod ( & mods , \"krbLoginFailedCount\" , LDAP_MOD_REPLACE , fail_auth_count ) ; if ( st != 0 ) goto cleanup ; } else if ( entry -> mask & KADM5_FAIL_AUTH_COUNT_INCREMENT ) { int attr_mask = 0 ; krb5_boolean has_fail_count ; st = krb5_get_attributes_mask ( context , entry , & attr_mask ) ; if ( st != 0 ) goto cleanup ; has_fail_count = ( ( attr_mask & KDB_FAIL_AUTH_COUNT_ATTR ) != 0 ) ; # ifdef LDAP_MOD_INCREMENT if ( ldap_server_handle -> server_info -> modify_increment && has_fail_count ) { st = krb5_add_int_mem_ldap_mod ( & mods , \"krbLoginFailedCount\" , LDAP_MOD_INCREMENT , 1 ) ; if ( st != 0 ) goto cleanup ; } else { # endif if ( has_fail_count ) { st = krb5_add_int_mem_ldap_mod ( & mods , \"krbLoginFailedCount\" , LDAP_MOD_DELETE , entry -> fail_auth_count ) ; if ( st != 0 ) goto cleanup ; } st = krb5_add_int_mem_ldap_mod ( & mods , \"krbLoginFailedCount\" , LDAP_MOD_ADD , entry -> fail_auth_count + 1 ) ; if ( st != 0 ) goto cleanup ; # ifdef LDAP_MOD_INCREMENT } # endif } else if ( optype == ADD_PRINCIPAL ) { st = krb5_add_int_mem_ldap_mod ( & mods , \"krbLoginFailedCount\" , LDAP_MOD_ADD , 0 ) ; } if ( entry -> mask & KADM5_MAX_LIFE ) { if ( ( st = krb5_add_int_mem_ldap_mod ( & mods , \"krbmaxticketlife\" , LDAP_MOD_REPLACE , entry -> max_life ) ) != 0 ) goto cleanup ; } if ( entry -> mask & KADM5_MAX_RLIFE ) { if ( ( st = krb5_add_int_mem_ldap_mod ( & mods , \"krbmaxrenewableage\" , LDAP_MOD_REPLACE , entry -> max_renewable_life ) ) != 0 ) goto cleanup ; } if ( entry -> mask & KADM5_ATTRIBUTES ) { if ( ( st = krb5_add_int_mem_ldap_mod ( & mods , \"krbticketflags\" , LDAP_MOD_REPLACE , entry -> attributes ) ) != 0 ) goto cleanup ; } if ( entry -> mask & KADM5_PRINCIPAL ) { memset ( strval , 0 , sizeof ( strval ) ) ; strval [ 0 ] = user ; if ( ( st = krb5_add_str_mem_ldap_mod ( & mods , \"krbprincipalname\" , LDAP_MOD_REPLACE , strval ) ) != 0 ) goto cleanup ; } if ( entry -> mask & KADM5_PRINC_EXPIRE_TIME ) { memset ( strval , 0 , sizeof ( strval ) ) ; if ( ( strval [ 0 ] = getstringtime ( entry -> expiration ) ) == NULL ) goto cleanup ; if ( ( st = krb5_add_str_mem_ldap_mod ( & mods , \"krbprincipalexpiration\" , LDAP_MOD_REPLACE , strval ) ) != 0 ) { free ( strval [ 0 ] ) ; goto cleanup ; } free ( strval [ 0 ] ) ; } if ( entry -> mask & KADM5_PW_EXPIRATION ) { memset ( strval , 0 , sizeof ( strval ) ) ; if ( ( strval [ 0 ] = getstringtime ( entry -> pw_expiration ) ) == NULL ) goto cleanup ; if ( ( st = krb5_add_str_mem_ldap_mod ( & mods , \"krbpasswordexpiration\" , LDAP_MOD_REPLACE , strval ) ) != 0 ) { free ( strval [ 0 ] ) ; goto cleanup ; } free ( strval [ 0 ] ) ; } if ( entry -> mask & KADM5_POLICY ) { memset ( & princ_ent , 0 , sizeof ( princ_ent ) ) ; for ( tl_data = entry -> tl_data ; tl_data ; tl_data = tl_data -> tl_data_next ) { if ( tl_data -> tl_data_type == KRB5_TL_KADM_DATA ) { if ( ( st = krb5_lookup_tl_kadm_data ( tl_data , & princ_ent ) ) != 0 ) { goto cleanup ; } break ; } } if ( princ_ent . aux_attributes & KADM5_POLICY ) { memset ( strval , 0 , sizeof ( strval ) ) ; if ( ( st = krb5_ldap_name_to_policydn ( context , princ_ent . policy , & polname ) ) != 0 ) goto cleanup ; strval [ 0 ] = polname ; if ( ( st = krb5_add_str_mem_ldap_mod ( & mods , \"krbpwdpolicyreference\" , LDAP_MOD_REPLACE , strval ) ) != 0 ) goto cleanup ; } else { st = EINVAL ; k5_setmsg ( context , st , \"Password<S2SV_blank>policy<S2SV_blank>value<S2SV_blank>null\" ) ; goto cleanup ; } } else if ( entry -> mask & KADM5_LOAD && found_entry == TRUE ) { if ( ( st = krb5_add_str_mem_ldap_mod ( & mods , \"krbpwdpolicyreference\" , LDAP_MOD_REPLACE , NULL ) ) != 0 ) goto cleanup ; } if ( entry -> mask & KADM5_POLICY_CLR ) { if ( ( st = krb5_add_str_mem_ldap_mod ( & mods , \"krbpwdpolicyreference\" , LDAP_MOD_DELETE , NULL ) ) != 0 ) goto cleanup ; } if ( entry -> mask & KADM5_KEY_DATA || entry -> mask & KADM5_KVNO ) { krb5_kvno mkvno ; if ( ( st = krb5_dbe_lookup_mkvno ( context , entry , & mkvno ) ) != 0 ) goto cleanup ; bersecretkey = krb5_encode_krbsecretkey ( entry -> key_data , entry -> n_key_data , mkvno ) ; <S2SV_StartBug> if ( ( st = krb5_add_ber_mem_ldap_mod ( & mods , \"krbprincipalkey\" , <S2SV_EndBug> <S2SV_StartBug> LDAP_MOD_REPLACE | LDAP_MOD_BVALUES , bersecretkey ) ) != 0 ) <S2SV_EndBug> goto cleanup ; if ( ! ( entry -> mask & KADM5_PRINCIPAL ) ) { memset ( strval , 0 , sizeof ( strval ) ) ; if ( ( strval [ 0 ] = getstringtime ( entry -> pw_expiration ) ) == NULL ) goto cleanup ; if ( ( st = krb5_add_str_mem_ldap_mod ( & mods , \"krbpasswordexpiration\" , LDAP_MOD_REPLACE , strval ) ) != 0 ) { free ( strval [ 0 ] ) ; goto cleanup ; } free ( strval [ 0 ] ) ; } { krb5_timestamp last_pw_changed ; if ( ( st = krb5_dbe_lookup_last_pwd_change ( context , entry , & last_pw_changed ) ) != 0 ) goto cleanup ; memset ( strval , 0 , sizeof ( strval ) ) ; if ( ( strval [ 0 ] = getstringtime ( last_pw_changed ) ) == NULL ) goto cleanup ; if ( ( st = krb5_add_str_mem_ldap_mod ( & mods , \"krbLastPwdChange\" , LDAP_MOD_REPLACE , strval ) ) != 0 ) { free ( strval [ 0 ] ) ; goto cleanup ; } free ( strval [ 0 ] ) ; } } if ( entry -> tl_data != NULL ) { int count = 0 ; struct berval * * ber_tl_data = NULL ; krb5_tl_data * ptr ; krb5_timestamp unlock_time ; for ( ptr = entry -> tl_data ; ptr != NULL ; ptr = ptr -> tl_data_next ) { if ( ptr -> tl_data_type == KRB5_TL_LAST_PWD_CHANGE # ifdef SECURID || ptr -> tl_data_type == KRB5_TL_DB_ARGS # endif || ptr -> tl_data_type == KRB5_TL_KADM_DATA || ptr -> tl_data_type == KDB_TL_USER_INFO || ptr -> tl_data_type == KRB5_TL_CONSTRAINED_DELEGATION_ACL || ptr -> tl_data_type == KRB5_TL_LAST_ADMIN_UNLOCK ) continue ; count ++ ; } if ( count != 0 ) { int j ; ber_tl_data = ( struct berval * * ) calloc ( count + 1 , sizeof ( struct berval * ) ) ; if ( ber_tl_data == NULL ) { st = ENOMEM ; goto cleanup ; } for ( j = 0 , ptr = entry -> tl_data ; ptr != NULL ; ptr = ptr -> tl_data_next ) { if ( ptr -> tl_data_type == KRB5_TL_LAST_PWD_CHANGE # ifdef SECURID || ptr -> tl_data_type == KRB5_TL_DB_ARGS # endif || ptr -> tl_data_type == KRB5_TL_KADM_DATA || ptr -> tl_data_type == KDB_TL_USER_INFO || ptr -> tl_data_type == KRB5_TL_CONSTRAINED_DELEGATION_ACL || ptr -> tl_data_type == KRB5_TL_LAST_ADMIN_UNLOCK ) continue ; if ( ( st = tl_data2berval ( ptr , & ber_tl_data [ j ] ) ) != 0 ) break ; j ++ ; } if ( st == 0 ) { ber_tl_data [ count ] = NULL ; st = krb5_add_ber_mem_ldap_mod ( & mods , \"krbExtraData\" , LDAP_MOD_REPLACE | LDAP_MOD_BVALUES , ber_tl_data ) ; } for ( j = 0 ; ber_tl_data [ j ] != NULL ; j ++ ) { free ( ber_tl_data [ j ] -> bv_val ) ; free ( ber_tl_data [ j ] ) ; } free ( ber_tl_data ) ; if ( st != 0 ) goto cleanup ; } if ( ( st = krb5_dbe_lookup_last_admin_unlock ( context , entry , & unlock_time ) ) != 0 ) goto cleanup ; if ( unlock_time != 0 ) { memset ( strval , 0 , sizeof ( strval ) ) ; if ( ( strval [ 0 ] = getstringtime ( unlock_time ) ) == NULL ) goto cleanup ; if ( ( st = krb5_add_str_mem_ldap_mod ( & mods , \"krbLastAdminUnlock\" , LDAP_MOD_REPLACE , strval ) ) != 0 ) { free ( strval [ 0 ] ) ; goto cleanup ; } free ( strval [ 0 ] ) ; } } if ( xargs . tktpolicydn != NULL ) { int tmask = 0 ; if ( strlen ( xargs . tktpolicydn ) != 0 ) { st = checkattributevalue ( ld , xargs . tktpolicydn , \"objectclass\" , policyclass , & tmask ) ; CHECK_CLASS_VALIDITY ( st , tmask , _ ( \"ticket<S2SV_blank>policy<S2SV_blank>object<S2SV_blank>value:<S2SV_blank>\" ) ) ; strval [ 0 ] = xargs . tktpolicydn ; strval [ 1 ] = NULL ; if ( ( st = krb5_add_str_mem_ldap_mod ( & mods , \"krbticketpolicyreference\" , LDAP_MOD_REPLACE , strval ) ) != 0 ) goto cleanup ; } else { if ( ( st = krb5_add_str_mem_ldap_mod ( & mods , \"krbticketpolicyreference\" , LDAP_MOD_DELETE , NULL ) ) != 0 ) goto cleanup ; } } if ( establish_links == TRUE ) { memset ( strval , 0 , sizeof ( strval ) ) ; strval [ 0 ] = xargs . linkdn ; if ( ( st = krb5_add_str_mem_ldap_mod ( & mods , \"krbObjectReferences\" , LDAP_MOD_REPLACE , strval ) ) != 0 ) goto cleanup ; } if ( mods == NULL ) goto cleanup ; if ( create_standalone_prinicipal == TRUE ) { memset ( strval , 0 , sizeof ( strval ) ) ; strval [ 0 ] = \"krbprincipal\" ; strval [ 1 ] = \"krbprincipalaux\" ; strval [ 2 ] = \"krbTicketPolicyAux\" ; if ( ( st = krb5_add_str_mem_ldap_mod ( & mods , \"objectclass\" , LDAP_MOD_ADD , strval ) ) != 0 ) goto cleanup ; st = ldap_add_ext_s ( ld , standalone_principal_dn , mods , NULL , NULL ) ; if ( st == LDAP_ALREADY_EXISTS && entry -> mask & KADM5_LOAD ) { st = ldap_delete_ext_s ( ld , standalone_principal_dn , NULL , NULL ) ; if ( st != LDAP_SUCCESS ) { snprintf ( errbuf , sizeof ( errbuf ) , _ ( \"Principal<S2SV_blank>delete<S2SV_blank>failed<S2SV_blank>(trying<S2SV_blank>to<S2SV_blank>replace<S2SV_blank>\" \"entry):<S2SV_blank>%s\" ) , ldap_err2string ( st ) ) ; st = translate_ldap_error ( st , OP_ADD ) ; k5_setmsg ( context , st , \"%s\" , errbuf ) ; goto cleanup ; } else { st = ldap_add_ext_s ( ld , standalone_principal_dn , mods , NULL , NULL ) ; } } if ( st != LDAP_SUCCESS ) { snprintf ( errbuf , sizeof ( errbuf ) , _ ( \"Principal<S2SV_blank>add<S2SV_blank>failed:<S2SV_blank>%s\" ) , ldap_err2string ( st ) ) ; st = translate_ldap_error ( st , OP_ADD ) ; k5_setmsg ( context , st , \"%s\" , errbuf ) ; goto cleanup ; } } else { { char * attrvalues [ ] = { \"krbprincipalaux\" , \"krbTicketPolicyAux\" , NULL } ; int p , q , r = 0 , amask = 0 ; if ( ( st = checkattributevalue ( ld , ( xargs . dn ) ? xargs . dn : principal_dn , \"objectclass\" , attrvalues , & amask ) ) != 0 ) goto cleanup ; memset ( strval , 0 , sizeof ( strval ) ) ; for ( p = 1 , q = 0 ; p <= 2 ; p <<= 1 , ++ q ) { if ( ( p & amask ) == 0 ) strval [ r ++ ] = attrvalues [ q ] ; } if ( r != 0 ) { if ( ( st = krb5_add_str_mem_ldap_mod ( & mods , \"objectclass\" , LDAP_MOD_ADD , strval ) ) != 0 ) goto cleanup ; } } if ( xargs . dn != NULL ) st = ldap_modify_ext_s ( ld , xargs . dn , mods , NULL , NULL ) ; else st = ldap_modify_ext_s ( ld , principal_dn , mods , NULL , NULL ) ; if ( st != LDAP_SUCCESS ) { snprintf ( errbuf , sizeof ( errbuf ) , _ ( \"User<S2SV_blank>modification<S2SV_blank>failed:<S2SV_blank>%s\" ) , ldap_err2string ( st ) ) ; st = translate_ldap_error ( st , OP_MOD ) ; k5_setmsg ( context , st , \"%s\" , errbuf ) ; goto cleanup ; } if ( entry -> mask & KADM5_FAIL_AUTH_COUNT_INCREMENT ) entry -> fail_auth_count ++ ; } cleanup : if ( user ) free ( user ) ; if ( filtuser ) free ( filtuser ) ; free_xargs ( xargs ) ; if ( standalone_principal_dn ) free ( standalone_principal_dn ) ; if ( principal_dn ) free ( principal_dn ) ; if ( polname != NULL ) free ( polname ) ; for ( tre = 0 ; tre < ntrees ; tre ++ ) free ( subtreelist [ tre ] ) ; free ( subtreelist ) ; if ( subtree ) free ( subtree ) ; if ( bersecretkey ) { for ( l = 0 ; bersecretkey [ l ] ; ++ l ) { if ( bersecretkey [ l ] -> bv_val ) free ( bersecretkey [ l ] -> bv_val ) ; free ( bersecretkey [ l ] ) ; } free ( bersecretkey ) ; } if ( keys ) free ( keys ) ; ldap_mods_free ( mods , 1 ) ; ldap_osa_free_princ_ent ( & princ_ent ) ; ldap_msgfree ( result ) ; krb5_ldap_put_handle_to_pool ( ldap_context , ldap_server_handle ) ; return ( st ) ; }\n",
      "fixed_code": "<S2SV_ModStart> ; if ( bersecretkey == NULL ) { st = ENOMEM ; goto cleanup ; } if ( bersecretkey [ 0 ] != NULL || ! create_standalone_prinicipal ) { <S2SV_ModEnd> st = krb5_add_ber_mem_ldap_mod <S2SV_ModStart> , bersecretkey ) ; if ( st != 0 ) goto cleanup ; } <S2SV_ModEnd> if ( !\n",
      "source_code_length": 20383,
      "target_code_length": 282,
      "vulnerability_patterns": {
        "buffer_overflow": 13,
        "use_after_free": 38,
        "integer_overflow": 12,
        "format_string": 7,
        "null_pointer": 91,
        "sql_injection": 1,
        "memory_leak": 1,
        "total": 163
      },
      "total_patterns": 163,
      "original_address": "https://github.com/krb5/krb5/commit/04038bf3633c4b909b5ded3072dc88c8c419bf16",
      "discovery_time": "2014-12-16T23:59Z",
      "project_commit_id": "krb5@krb5/04038bf3633c4b909b5ded3072dc88c8c419bf16",
      "extraction_time": "2025-08-31T15:41:49.177633",
      "label": 1,
      "vulnerability_type": "unknown/uncategorized",
      "difficulty_level": "expert",
      "risk_factors": [
        "critical_infrastructure",
        "sql_injection",
        "buffer_overflow",
        "use_after_free"
      ],
      "attack_vectors": [
        "fuzzing",
        "code_analysis",
        "reverse_engineering"
      ],
      "mitigation_strategies": [
        "dynamic_analysis",
        "static_analysis",
        "fuzzing",
        "code_review",
        "secure_coding_practices"
      ],
      "code_differences": {
        "has_differences": true,
        "source_lines": 2,
        "target_lines": 2,
        "character_differences": 20101,
        "similarity_percentage": 7.371794871794872
      },
      "vulnerability_location": {
        "vulnerability_present": true,
        "fix_applied": true,
        "code_changed": true,
        "estimated_lines_changed": 0
      }
    },
    {
      "cve_id": "CVE-2017-6194",
      "cwe_id": "CWE-119",
      "cwe_name": "Buffer Overflow",
      "project": "radare",
      "severity": "critical",
      "weaponization_score": 10.0,
      "is_critical": true,
      "is_weaponizable": true,
      "is_high_priority_project": true,
      "vulnerable_code": "CWE-119 static RList * relocs ( RBinFile * arch ) { struct r_bin_bflt_obj * obj = ( struct r_bin_bflt_obj * ) arch -> o -> bin_obj ; RList * list = r_list_newf ( ( RListFree ) free ) ; int i , len , n_got , amount ; if ( ! list || ! obj ) { r_list_free ( list ) ; return NULL ; } if ( obj -> hdr -> flags & FLAT_FLAG_GOTPIC ) { n_got = get_ngot_entries ( obj ) ; if ( n_got ) { amount = n_got * sizeof ( ut32 ) ; if ( amount < n_got || amount > UT32_MAX ) { goto out_error ; } <S2SV_StartBug> struct reloc_struct_t * got_table = calloc ( 1 , n_got * sizeof ( ut32 ) ) ; <S2SV_EndBug> if ( got_table ) { ut32 offset = 0 ; for ( i = 0 ; i < n_got ; offset += 4 , i ++ ) { ut32 got_entry ; if ( obj -> hdr -> data_start + offset + 4 > obj -> size || obj -> hdr -> data_start + offset + 4 < offset ) { break ; } len = r_buf_read_at ( obj -> b , obj -> hdr -> data_start + offset , ( ut8 * ) & got_entry , sizeof ( ut32 ) ) ; if ( ! VALID_GOT_ENTRY ( got_entry ) || len != sizeof ( ut32 ) ) { break ; } got_table [ i ] . addr_to_patch = got_entry ; got_table [ i ] . data_offset = got_entry + BFLT_HDR_SIZE ; } obj -> n_got = n_got ; obj -> got_table = got_table ; } } } if ( obj -> hdr -> reloc_count > 0 ) { int n_reloc = obj -> hdr -> reloc_count ; amount = n_reloc * sizeof ( struct reloc_struct_t ) ; if ( amount < n_reloc || amount > UT32_MAX ) { goto out_error ; } struct reloc_struct_t * reloc_table = calloc ( 1 , amount + 1 ) ; if ( ! reloc_table ) { goto out_error ; } amount = n_reloc * sizeof ( ut32 ) ; if ( amount < n_reloc || amount > UT32_MAX ) { free ( reloc_table ) ; goto out_error ; } ut32 * reloc_pointer_table = calloc ( 1 , amount + 1 ) ; if ( ! reloc_pointer_table ) { free ( reloc_table ) ; goto out_error ; } if ( obj -> hdr -> reloc_start + amount > obj -> size || obj -> hdr -> reloc_start + amount < amount ) { free ( reloc_table ) ; free ( reloc_pointer_table ) ; goto out_error ; } len = r_buf_read_at ( obj -> b , obj -> hdr -> reloc_start , ( ut8 * ) reloc_pointer_table , amount ) ; if ( len != amount ) { free ( reloc_table ) ; free ( reloc_pointer_table ) ; goto out_error ; } for ( i = 0 ; i < obj -> hdr -> reloc_count ; i ++ ) { ut32 reloc_offset = r_swap_ut32 ( reloc_pointer_table [ i ] ) + BFLT_HDR_SIZE ; if ( reloc_offset < obj -> hdr -> bss_end && reloc_offset < obj -> size ) { ut32 reloc_fixed , reloc_data_offset ; if ( reloc_offset + sizeof ( ut32 ) > obj -> size || reloc_offset + sizeof ( ut32 ) < reloc_offset ) { free ( reloc_table ) ; free ( reloc_pointer_table ) ; goto out_error ; } len = r_buf_read_at ( obj -> b , reloc_offset , ( ut8 * ) & reloc_fixed , sizeof ( ut32 ) ) ; if ( len != sizeof ( ut32 ) ) { eprintf ( \"problem<S2SV_blank>while<S2SV_blank>reading<S2SV_blank>relocation<S2SV_blank>entries\\\\n\" ) ; free ( reloc_table ) ; free ( reloc_pointer_table ) ; goto out_error ; } reloc_data_offset = r_swap_ut32 ( reloc_fixed ) + BFLT_HDR_SIZE ; reloc_table [ i ] . addr_to_patch = reloc_offset ; reloc_table [ i ] . data_offset = reloc_data_offset ; RBinReloc * reloc = R_NEW0 ( RBinReloc ) ; if ( reloc ) { reloc -> type = R_BIN_RELOC_32 ; reloc -> paddr = reloc_table [ i ] . addr_to_patch ; reloc -> vaddr = reloc -> paddr ; r_list_append ( list , reloc ) ; } } } free ( reloc_pointer_table ) ; obj -> reloc_table = reloc_table ; } return list ; out_error : r_list_free ( list ) ; return NULL ; }\n",
      "fixed_code": "<S2SV_ModStart> * sizeof ( struct reloc_struct_t <S2SV_ModEnd> ) ) ;\n",
      "source_code_length": 3359,
      "target_code_length": 69,
      "vulnerability_patterns": {
        "use_after_free": 14,
        "integer_overflow": 3,
        "null_pointer": 42,
        "memory_leak": 3,
        "total": 62
      },
      "total_patterns": 62,
      "original_address": "https://github.com/radare/radare2/commit/72794dc3523bbd5bb370de3c5857cb736c387e18",
      "discovery_time": "2017-04-03T05:59Z",
      "project_commit_id": "radare@radare2/72794dc3523bbd5bb370de3c5857cb736c387e18",
      "extraction_time": "2025-08-31T15:41:49.177820",
      "label": 1,
      "vulnerability_type": "buffer_overflow",
      "difficulty_level": "expert",
      "risk_factors": [
        "memory_corruption",
        "critical_infrastructure",
        "arbitrary_code_execution",
        "system_crash",
        "use_after_free"
      ],
      "attack_vectors": [
        "memory_manipulation",
        "malicious_input",
        "code_analysis",
        "buffer_overflow",
        "reverse_engineering",
        "fuzzing"
      ],
      "mitigation_strategies": [
        "safe_string_functions",
        "dynamic_analysis",
        "code_review",
        "static_analysis",
        "memory_safety_checks",
        "input_validation",
        "fuzzing",
        "bounds_checking",
        "secure_coding_practices"
      ],
      "code_differences": {
        "has_differences": true,
        "source_lines": 2,
        "target_lines": 2,
        "character_differences": 3290,
        "similarity_percentage": 7.07070707070707
      },
      "vulnerability_location": {
        "vulnerability_present": true,
        "fix_applied": true,
        "code_changed": true,
        "estimated_lines_changed": 0
      }
    },
    {
      "cve_id": "CVE-2016-10070",
      "cwe_id": "CWE-125",
      "cwe_name": "Out-of-bounds Read",
      "project": "ImageMagick",
      "severity": "critical",
      "weaponization_score": 10.0,
      "is_critical": true,
      "is_weaponizable": true,
      "is_high_priority_project": true,
      "vulnerable_code": "CWE-125 static Image * ReadMATImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { Image * image , * image2 = NULL , * rotated_image ; register Quantum * q ; unsigned int status ; MATHeader MATLAB_HDR ; size_t size ; size_t CellType ; QuantumInfo * quantum_info ; ImageInfo * clone_info ; int i ; ssize_t ldblk ; unsigned char * BImgBuff = NULL ; double MinVal , MaxVal ; unsigned z , z2 ; unsigned Frames ; int logging ; int sample_size ; MagickOffsetType filepos = 0x80 ; BlobInfo * blob ; size_t one ; unsigned int ( * ReadBlobXXXLong ) ( Image * image ) ; unsigned short ( * ReadBlobXXXShort ) ( Image * image ) ; void ( * ReadBlobDoublesXXX ) ( Image * image , size_t len , double * data ) ; void ( * ReadBlobFloatsXXX ) ( Image * image , size_t len , float * data ) ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickCoreSignature ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickCoreSignature ) ; logging = LogMagickEvent ( CoderEvent , GetMagickModule ( ) , \"enter\" ) ; image = AcquireImage ( image_info , exception ) ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } clone_info = CloneImageInfo ( image_info ) ; if ( ReadBlob ( image , 124 , ( unsigned char * ) & MATLAB_HDR . identific ) != 124 ) ThrowReaderException ( CorruptImageError , \"ImproperImageHeader\" ) ; MATLAB_HDR . Version = ReadBlobLSBShort ( image ) ; if ( ReadBlob ( image , 2 , ( unsigned char * ) & MATLAB_HDR . EndianIndicator ) != 2 ) ThrowReaderException ( CorruptImageError , \"ImproperImageHeader\" ) ; if ( logging ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , \"<S2SV_blank><S2SV_blank>Endian<S2SV_blank>%c%c\" , MATLAB_HDR . EndianIndicator [ 0 ] , MATLAB_HDR . EndianIndicator [ 1 ] ) ; if ( ! strncmp ( MATLAB_HDR . EndianIndicator , \"IM\" , 2 ) ) { ReadBlobXXXLong = ReadBlobLSBLong ; ReadBlobXXXShort = ReadBlobLSBShort ; ReadBlobDoublesXXX = ReadBlobDoublesLSB ; ReadBlobFloatsXXX = ReadBlobFloatsLSB ; image -> endian = LSBEndian ; } else if ( ! strncmp ( MATLAB_HDR . EndianIndicator , \"MI\" , 2 ) ) { ReadBlobXXXLong = ReadBlobMSBLong ; ReadBlobXXXShort = ReadBlobMSBShort ; ReadBlobDoublesXXX = ReadBlobDoublesMSB ; ReadBlobFloatsXXX = ReadBlobFloatsMSB ; image -> endian = MSBEndian ; } else goto MATLAB_KO ; if ( strncmp ( MATLAB_HDR . identific , \"MATLAB\" , 6 ) ) MATLAB_KO : ThrowReaderException ( CorruptImageError , \"ImproperImageHeader\" ) ; filepos = TellBlob ( image ) ; while ( ! EOFBlob ( image ) ) { Frames = 1 ; ( void ) SeekBlob ( image , filepos , SEEK_SET ) ; MATLAB_HDR . DataType = ReadBlobXXXLong ( image ) ; if ( EOFBlob ( image ) ) break ; MATLAB_HDR . ObjectSize = ReadBlobXXXLong ( image ) ; if ( EOFBlob ( image ) ) break ; filepos += MATLAB_HDR . ObjectSize + 4 + 4 ; image2 = image ; # if defined ( MAGICKCORE_ZLIB_DELEGATE ) if ( MATLAB_HDR . DataType == miCOMPRESSED ) { image2 = DecompressBlock ( image , MATLAB_HDR . ObjectSize , clone_info , exception ) ; if ( image2 == NULL ) continue ; MATLAB_HDR . DataType = ReadBlobXXXLong ( image2 ) ; } # endif if ( MATLAB_HDR . DataType != miMATRIX ) continue ; MATLAB_HDR . unknown1 = ReadBlobXXXLong ( image2 ) ; MATLAB_HDR . unknown2 = ReadBlobXXXLong ( image2 ) ; MATLAB_HDR . unknown5 = ReadBlobXXXLong ( image2 ) ; MATLAB_HDR . StructureClass = MATLAB_HDR . unknown5 & 0xFF ; MATLAB_HDR . StructureFlag = ( MATLAB_HDR . unknown5 >> 8 ) & 0xFF ; MATLAB_HDR . unknown3 = ReadBlobXXXLong ( image2 ) ; if ( image != image2 ) MATLAB_HDR . unknown4 = ReadBlobXXXLong ( image2 ) ; MATLAB_HDR . unknown4 = ReadBlobXXXLong ( image2 ) ; MATLAB_HDR . DimFlag = ReadBlobXXXLong ( image2 ) ; MATLAB_HDR . SizeX = ReadBlobXXXLong ( image2 ) ; MATLAB_HDR . SizeY = ReadBlobXXXLong ( image2 ) ; switch ( MATLAB_HDR . DimFlag ) { case 8 : z2 = z = 1 ; break ; case 12 : z2 = z = ReadBlobXXXLong ( image2 ) ; ( void ) ReadBlobXXXLong ( image2 ) ; if ( z != 3 ) ThrowReaderException ( CoderError , \"MultidimensionalMatricesAreNotSupported\" ) ; break ; case 16 : z2 = z = ReadBlobXXXLong ( image2 ) ; if ( z != 3 && z != 1 ) ThrowReaderException ( CoderError , \"MultidimensionalMatricesAreNotSupported\" ) ; Frames = ReadBlobXXXLong ( image2 ) ; break ; default : ThrowReaderException ( CoderError , \"MultidimensionalMatricesAreNotSupported\" ) ; } MATLAB_HDR . Flag1 = ReadBlobXXXShort ( image2 ) ; MATLAB_HDR . NameFlag = ReadBlobXXXShort ( image2 ) ; if ( logging ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , \"MATLAB_HDR.StructureClass<S2SV_blank>%d\" , MATLAB_HDR . StructureClass ) ; if ( MATLAB_HDR . StructureClass != mxCHAR_CLASS && MATLAB_HDR . StructureClass != mxSINGLE_CLASS && MATLAB_HDR . StructureClass != mxDOUBLE_CLASS && MATLAB_HDR . StructureClass != mxINT8_CLASS && MATLAB_HDR . StructureClass != mxUINT8_CLASS && MATLAB_HDR . StructureClass != mxINT16_CLASS && MATLAB_HDR . StructureClass != mxUINT16_CLASS && MATLAB_HDR . StructureClass != mxINT32_CLASS && MATLAB_HDR . StructureClass != mxUINT32_CLASS && MATLAB_HDR . StructureClass != mxINT64_CLASS && MATLAB_HDR . StructureClass != mxUINT64_CLASS ) ThrowReaderException ( CoderError , \"UnsupportedCellTypeInTheMatrix\" ) ; switch ( MATLAB_HDR . NameFlag ) { case 0 : size = ReadBlobXXXLong ( image2 ) ; size = 4 * ( ssize_t ) ( ( size + 3 + 1 ) / 4 ) ; ( void ) SeekBlob ( image2 , size , SEEK_CUR ) ; break ; case 1 : case 2 : case 3 : case 4 : ( void ) ReadBlob ( image2 , 4 , ( unsigned char * ) & size ) ; break ; default : goto MATLAB_KO ; } CellType = ReadBlobXXXLong ( image2 ) ; if ( logging ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , \"MATLAB_HDR.CellType:<S2SV_blank>%.20g\" , ( double ) CellType ) ; ( void ) ReadBlob ( image2 , 4 , ( unsigned char * ) & size ) ; NEXT_FRAME : switch ( CellType ) { case miINT8 : case miUINT8 : sample_size = 8 ; if ( MATLAB_HDR . StructureFlag & FLAG_LOGICAL ) image -> depth = 1 ; else image -> depth = 8 ; ldblk = ( ssize_t ) MATLAB_HDR . SizeX ; break ; case miINT16 : case miUINT16 : sample_size = 16 ; image -> depth = 16 ; ldblk = ( ssize_t ) ( 2 * MATLAB_HDR . SizeX ) ; break ; case miINT32 : case miUINT32 : sample_size = 32 ; image -> depth = 32 ; ldblk = ( ssize_t ) ( 4 * MATLAB_HDR . SizeX ) ; break ; case miINT64 : case miUINT64 : sample_size = 64 ; image -> depth = 64 ; ldblk = ( ssize_t ) ( 8 * MATLAB_HDR . SizeX ) ; break ; case miSINGLE : sample_size = 32 ; image -> depth = 32 ; ( void ) SetImageOption ( clone_info , \"quantum:format\" , \"floating-point\" ) ; if ( MATLAB_HDR . StructureFlag & FLAG_COMPLEX ) { } ldblk = ( ssize_t ) ( 4 * MATLAB_HDR . SizeX ) ; break ; case miDOUBLE : sample_size = 64 ; image -> depth = 64 ; ( void ) SetImageOption ( clone_info , \"quantum:format\" , \"floating-point\" ) ; DisableMSCWarning ( 4127 ) if ( sizeof ( double ) != 8 ) RestoreMSCWarning ThrowReaderException ( CoderError , \"IncompatibleSizeOfDouble\" ) ; if ( MATLAB_HDR . StructureFlag & FLAG_COMPLEX ) { } ldblk = ( ssize_t ) ( 8 * MATLAB_HDR . SizeX ) ; break ; default : ThrowReaderException ( CoderError , \"UnsupportedCellTypeInTheMatrix\" ) ; } ( void ) sample_size ; image -> columns = MATLAB_HDR . SizeX ; image -> rows = MATLAB_HDR . SizeY ; quantum_info = AcquireQuantumInfo ( clone_info , image ) ; if ( quantum_info == ( QuantumInfo * ) NULL ) ThrowReaderException ( ResourceLimitError , \"MemoryAllocationFailed\" ) ; one = 1 ; image -> colors = one << image -> depth ; if ( image -> columns == 0 || image -> rows == 0 ) goto MATLAB_KO ; if ( ( MATLAB_HDR . DimFlag == 8 ) && ( ( MATLAB_HDR . StructureFlag & FLAG_COMPLEX ) == 0 ) ) { image -> type = GrayscaleType ; SetImageColorspace ( image , GRAYColorspace , exception ) ; } if ( image_info -> ping ) { size_t temp = image -> columns ; image -> columns = image -> rows ; image -> rows = temp ; goto done_reading ; } status = SetImageExtent ( image , image -> columns , image -> rows , exception ) ; if ( status == MagickFalse ) return ( DestroyImageList ( image ) ) ; BImgBuff = ( unsigned char * ) AcquireQuantumMemory ( ( size_t ) ( ldblk ) , sizeof ( double ) ) ; if ( BImgBuff == NULL ) ThrowReaderException ( ResourceLimitError , \"MemoryAllocationFailed\" ) ; MinVal = 0 ; MaxVal = 0 ; if ( CellType == miDOUBLE || CellType == miSINGLE ) { CalcMinMax ( image2 , image_info -> endian , MATLAB_HDR . SizeX , MATLAB_HDR . SizeY , CellType , ldblk , BImgBuff , & quantum_info -> minimum , & quantum_info -> maximum ) ; } if ( z == 1 ) z = 0 ; do { for ( i = 0 ; i < ( ssize_t ) MATLAB_HDR . SizeY ; i ++ ) { q = GetAuthenticPixels ( image , 0 , MATLAB_HDR . SizeY - i - 1 , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) { if ( logging ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , \"<S2SV_blank><S2SV_blank>MAT<S2SV_blank>set<S2SV_blank>image<S2SV_blank>pixels<S2SV_blank>returns<S2SV_blank>unexpected<S2SV_blank>NULL<S2SV_blank>on<S2SV_blank>a<S2SV_blank>row<S2SV_blank>%u.\" , ( unsigned ) ( MATLAB_HDR . SizeY - i - 1 ) ) ; goto done_reading ; } if ( ReadBlob ( image2 , ldblk , ( unsigned char * ) BImgBuff ) != ( ssize_t ) ldblk ) { if ( logging ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , \"<S2SV_blank><S2SV_blank>MAT<S2SV_blank>cannot<S2SV_blank>read<S2SV_blank>scanrow<S2SV_blank>%u<S2SV_blank>from<S2SV_blank>a<S2SV_blank>file.\" , ( unsigned ) ( MATLAB_HDR . SizeY - i - 1 ) ) ; goto ExitLoop ; } if ( ( CellType == miINT8 || CellType == miUINT8 ) && ( MATLAB_HDR . StructureFlag & FLAG_LOGICAL ) ) { FixLogical ( ( unsigned char * ) BImgBuff , ldblk ) ; if ( ImportQuantumPixels ( image , ( CacheView * ) NULL , quantum_info , z2qtype [ z ] , BImgBuff , exception ) <= 0 ) { ImportQuantumPixelsFailed : if ( logging ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , \"<S2SV_blank><S2SV_blank>MAT<S2SV_blank>failed<S2SV_blank>to<S2SV_blank>ImportQuantumPixels<S2SV_blank>for<S2SV_blank>a<S2SV_blank>row<S2SV_blank>%u\" , ( unsigned ) ( MATLAB_HDR . SizeY - i - 1 ) ) ; break ; } } else { if ( ImportQuantumPixels ( image , ( CacheView * ) NULL , quantum_info , z2qtype [ z ] , BImgBuff , exception ) <= 0 ) goto ImportQuantumPixelsFailed ; if ( z <= 1 && ( CellType == miINT8 || CellType == miINT16 || CellType == miINT32 || CellType == miINT64 ) ) FixSignedValues ( image , q , MATLAB_HDR . SizeX ) ; } if ( ! SyncAuthenticPixels ( image , exception ) ) { if ( logging ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , \"<S2SV_blank><S2SV_blank>MAT<S2SV_blank>failed<S2SV_blank>to<S2SV_blank>sync<S2SV_blank>image<S2SV_blank>pixels<S2SV_blank>for<S2SV_blank>a<S2SV_blank>row<S2SV_blank>%u\" , ( unsigned ) ( MATLAB_HDR . SizeY - i - 1 ) ) ; goto ExitLoop ; } } } while ( z -- >= 2 ) ; <S2SV_StartBug> ExitLoop : <S2SV_EndBug> if ( MATLAB_HDR . StructureFlag & FLAG_COMPLEX ) { CellType = ReadBlobXXXLong ( image2 ) ; i = ReadBlobXXXLong ( image2 ) ; if ( CellType == miDOUBLE || CellType == miSINGLE ) { CalcMinMax ( image2 , image_info -> endian , MATLAB_HDR . SizeX , MATLAB_HDR . SizeY , CellType , ldblk , BImgBuff , & MinVal , & MaxVal ) ; } if ( CellType == miDOUBLE ) for ( i = 0 ; i < ( ssize_t ) MATLAB_HDR . SizeY ; i ++ ) { ReadBlobDoublesXXX ( image2 , ldblk , ( double * ) BImgBuff ) ; InsertComplexDoubleRow ( image , ( double * ) BImgBuff , i , MinVal , MaxVal , exception ) ; } if ( CellType == miSINGLE ) for ( i = 0 ; i < ( ssize_t ) MATLAB_HDR . SizeY ; i ++ ) { ReadBlobFloatsXXX ( image2 , ldblk , ( float * ) BImgBuff ) ; InsertComplexFloatRow ( image , ( float * ) BImgBuff , i , MinVal , MaxVal , exception ) ; } } if ( ( MATLAB_HDR . DimFlag == 8 ) && ( ( MATLAB_HDR . StructureFlag & FLAG_COMPLEX ) == 0 ) ) image -> type = GrayscaleType ; if ( image -> depth == 1 ) image -> type = BilevelType ; if ( image2 == image ) image2 = NULL ; rotated_image = RotateImage ( image , 90.0 , exception ) ; if ( rotated_image != ( Image * ) NULL ) { rotated_image -> page . x = 0 ; rotated_image -> page . y = 0 ; blob = rotated_image -> blob ; rotated_image -> blob = image -> blob ; rotated_image -> colors = image -> colors ; image -> blob = blob ; AppendImageToList ( & image , rotated_image ) ; DeleteImageFromList ( & image ) ; } done_reading : if ( image2 != NULL ) if ( image2 != image ) { DeleteImageFromList ( & image2 ) ; if ( clone_info ) { if ( clone_info -> file ) { fclose ( clone_info -> file ) ; clone_info -> file = NULL ; ( void ) remove_utf8 ( clone_info -> filename ) ; } } } AcquireNextImage ( image_info , image , exception ) ; if ( image -> next == ( Image * ) NULL ) break ; image = SyncNextImageInList ( image ) ; image -> columns = image -> rows = 0 ; image -> colors = 0 ; RelinquishMagickMemory ( BImgBuff ) ; BImgBuff = NULL ; if ( -- Frames > 0 ) { z = z2 ; if ( image2 == NULL ) image2 = image ; goto NEXT_FRAME ; } if ( ( image2 != NULL ) && ( image2 != image ) ) { DeleteImageFromList ( & image2 ) ; if ( clone_info ) { if ( clone_info -> file ) { fclose ( clone_info -> file ) ; clone_info -> file = NULL ; ( void ) remove_utf8 ( clone_info -> filename ) ; } } } } clone_info = DestroyImageInfo ( clone_info ) ; RelinquishMagickMemory ( BImgBuff ) ; CloseBlob ( image ) ; { Image * p ; ssize_t scene = 0 ; p = image ; image = NULL ; while ( p != ( Image * ) NULL ) { Image * tmp = p ; if ( ( p -> rows == 0 ) || ( p -> columns == 0 ) ) { p = p -> previous ; DeleteImageFromList ( & tmp ) ; } else { image = p ; p = p -> previous ; } } for ( p = image ; p != ( Image * ) NULL ; p = p -> next ) p -> scene = scene ++ ; } if ( clone_info != NULL ) { if ( clone_info -> file ) { fclose ( clone_info -> file ) ; clone_info -> file = NULL ; ( void ) remove_utf8 ( clone_info -> filename ) ; } DestroyImageInfo ( clone_info ) ; clone_info = NULL ; } if ( logging ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , \"return\" ) ; if ( image == NULL ) ThrowReaderException ( CorruptImageError , \"ImproperImageHeader\" ) ; return ( image ) ; }\n",
      "fixed_code": "<S2SV_ModStart> 2 ) ; quantum_info = DestroyQuantumInfo ( quantum_info ) ;\n",
      "source_code_length": 14012,
      "target_code_length": 75,
      "vulnerability_patterns": {
        "use_after_free": 4,
        "integer_overflow": 7,
        "null_pointer": 67,
        "total": 78
      },
      "total_patterns": 78,
      "original_address": "https://github.com/ImageMagick/ImageMagick/commit/a6240a163cb787909703d9fc649cf861f60ddd7c",
      "discovery_time": "2017-03-03T18:59Z",
      "project_commit_id": "ImageMagick@ImageMagick/a6240a163cb787909703d9fc649cf861f60ddd7c",
      "extraction_time": "2025-08-31T15:41:49.177874",
      "label": 1,
      "vulnerability_type": "out-of-bounds_read",
      "difficulty_level": "expert",
      "risk_factors": [
        "memory_corruption",
        "critical_infrastructure",
        "information_disclosure",
        "use_after_free",
        "integer_overflow"
      ],
      "attack_vectors": [
        "memory_manipulation",
        "malicious_input",
        "code_analysis",
        "buffer_overflow",
        "reverse_engineering",
        "fuzzing"
      ],
      "mitigation_strategies": [
        "safe_string_functions",
        "dynamic_analysis",
        "code_review",
        "static_analysis",
        "memory_safety_checks",
        "input_validation",
        "fuzzing",
        "bounds_checking",
        "secure_coding_practices"
      ],
      "code_differences": {
        "has_differences": true,
        "source_lines": 2,
        "target_lines": 2,
        "character_differences": 13937,
        "similarity_percentage": 2.2058823529411766
      },
      "vulnerability_location": {
        "vulnerability_present": true,
        "fix_applied": true,
        "code_changed": true,
        "estimated_lines_changed": 0
      }
    },
    {
      "cve_id": "CVE-2013-7018",
      "cwe_id": "CWE-119",
      "cwe_name": "Buffer Overflow",
      "project": "FFmpeg",
      "severity": "critical",
      "weaponization_score": 10.0,
      "is_critical": true,
      "is_weaponizable": true,
      "is_high_priority_project": true,
      "vulnerable_code": "CWE-119 static int decode_cblk ( Jpeg2000DecoderContext * s , Jpeg2000CodingStyle * codsty , Jpeg2000T1Context * t1 , Jpeg2000Cblk * cblk , int width , int height , int bandpos ) { int passno = cblk -> npasses , pass_t = 2 , bpno = cblk -> nonzerobits - 1 , y ; int clnpass_cnt = 0 ; int bpass_csty_symbol = codsty -> cblk_style & JPEG2000_CBLK_BYPASS ; <S2SV_StartBug> int vert_causal_ctx_csty_symbol = codsty -> cblk_style & JPEG2000_CBLK_VSC ; <S2SV_EndBug> for ( y = 0 ; y < height ; y ++ ) memset ( t1 -> data [ y ] , 0 , width * sizeof ( * * t1 -> data ) ) ; if ( ! cblk -> length ) return 0 ; for ( y = 0 ; y < height + 2 ; y ++ ) memset ( t1 -> flags [ y ] , 0 , ( width + 2 ) * sizeof ( * * t1 -> flags ) ) ; cblk -> data [ cblk -> length ] = 0xff ; cblk -> data [ cblk -> length + 1 ] = 0xff ; ff_mqc_initdec ( & t1 -> mqc , cblk -> data ) ; while ( passno -- ) { switch ( pass_t ) { case 0 : decode_sigpass ( t1 , width , height , bpno + 1 , bandpos , bpass_csty_symbol && ( clnpass_cnt >= 4 ) , vert_causal_ctx_csty_symbol ) ; break ; case 1 : decode_refpass ( t1 , width , height , bpno + 1 ) ; if ( bpass_csty_symbol && clnpass_cnt >= 4 ) ff_mqc_initdec ( & t1 -> mqc , cblk -> data ) ; break ; case 2 : decode_clnpass ( s , t1 , width , height , bpno + 1 , bandpos , codsty -> cblk_style & JPEG2000_CBLK_SEGSYM , vert_causal_ctx_csty_symbol ) ; clnpass_cnt = clnpass_cnt + 1 ; if ( bpass_csty_symbol && clnpass_cnt >= 4 ) ff_mqc_initdec ( & t1 -> mqc , cblk -> data ) ; break ; } pass_t ++ ; if ( pass_t == 3 ) { bpno -- ; pass_t = 0 ; } } return 0 ; }\n",
      "fixed_code": "<S2SV_ModStart> cblk_style & JPEG2000_CBLK_VSC ; av_assert0 ( width <= JPEG2000_MAX_CBLKW ) ; av_assert0 ( height <= JPEG2000_MAX_CBLKH )\n",
      "source_code_length": 1568,
      "target_code_length": 138,
      "vulnerability_patterns": {
        "buffer_overflow": 2,
        "integer_overflow": 5,
        "null_pointer": 20,
        "total": 27
      },
      "total_patterns": 27,
      "original_address": "https://github.com/FFmpeg/FFmpeg/commit/9a271a9368eaabf99e6c2046103acb33957e63b7",
      "discovery_time": "2013-12-09T16:36Z",
      "project_commit_id": "FFmpeg@FFmpeg/9a271a9368eaabf99e6c2046103acb33957e63b7",
      "extraction_time": "2025-08-31T15:41:49.178000",
      "label": 1,
      "vulnerability_type": "buffer_overflow",
      "difficulty_level": "expert",
      "risk_factors": [
        "memory_corruption",
        "critical_infrastructure",
        "arbitrary_code_execution",
        "buffer_overflow",
        "system_crash"
      ],
      "attack_vectors": [
        "memory_manipulation",
        "malicious_input",
        "code_analysis",
        "buffer_overflow",
        "reverse_engineering",
        "fuzzing"
      ],
      "mitigation_strategies": [
        "safe_string_functions",
        "dynamic_analysis",
        "code_review",
        "static_analysis",
        "memory_safety_checks",
        "input_validation",
        "fuzzing",
        "bounds_checking",
        "secure_coding_practices"
      ],
      "code_differences": {
        "has_differences": true,
        "source_lines": 2,
        "target_lines": 2,
        "character_differences": 1430,
        "similarity_percentage": 10.0
      },
      "vulnerability_location": {
        "vulnerability_present": true,
        "fix_applied": true,
        "code_changed": true,
        "estimated_lines_changed": 0
      }
    },
    {
      "cve_id": "CVE-2019-14934",
      "cwe_id": "CWE-787",
      "cwe_name": "Out-of-bounds Write",
      "project": "enferex",
      "severity": "critical",
      "weaponization_score": 10.0,
      "is_critical": true,
      "is_weaponizable": true,
      "is_high_priority_project": false,
      "vulnerable_code": "CWE-787 pdf_t * pdf_new ( const char * name ) { const char * n ; pdf_t * pdf ; <S2SV_StartBug> pdf = calloc ( 1 , sizeof ( pdf_t ) ) ; <S2SV_EndBug> if ( name ) { if ( ( n = strrchr ( name , '/' ) ) ) ++ n ; else n = name ; <S2SV_StartBug> pdf -> name = malloc ( strlen ( n ) + 1 ) ; <S2SV_EndBug> strcpy ( pdf -> name , n ) ; } else { <S2SV_StartBug> pdf -> name = malloc ( strlen ( \"Unknown\" ) + 1 ) ; <S2SV_EndBug> strcpy ( pdf -> name , \"Unknown\" ) ; } return pdf ; }\n",
      "fixed_code": "<S2SV_ModStart> ; pdf = safe_calloc ( <S2SV_ModEnd> sizeof ( pdf_t <S2SV_ModStart> -> name = safe_calloc <S2SV_ModEnd> ( strlen ( <S2SV_ModStart> -> name = safe_calloc <S2SV_ModEnd> ( strlen (\n",
      "source_code_length": 472,
      "target_code_length": 193,
      "vulnerability_patterns": {
        "buffer_overflow": 2,
        "use_after_free": 2,
        "integer_overflow": 4,
        "null_pointer": 6,
        "memory_leak": 2,
        "total": 16
      },
      "total_patterns": 16,
      "original_address": "https://github.com/enferex/pdfresurrect/commit/0c4120fffa3dffe97b95c486a120eded82afe8a6",
      "discovery_time": "2019-08-11T22:15Z",
      "project_commit_id": "enferex@pdfresurrect/0c4120fffa3dffe97b95c486a120eded82afe8a6",
      "extraction_time": "2025-08-31T15:41:49.178033",
      "label": 1,
      "vulnerability_type": "out-of-bounds_write",
      "difficulty_level": "expert",
      "risk_factors": [
        "memory_corruption",
        "arbitrary_code_execution",
        "buffer_overflow",
        "system_crash",
        "use_after_free"
      ],
      "attack_vectors": [
        "memory_manipulation",
        "malicious_input",
        "code_analysis",
        "buffer_overflow",
        "reverse_engineering",
        "fuzzing"
      ],
      "mitigation_strategies": [
        "safe_string_functions",
        "dynamic_analysis",
        "code_review",
        "static_analysis",
        "memory_safety_checks",
        "input_validation",
        "fuzzing",
        "bounds_checking",
        "secure_coding_practices"
      ],
      "code_differences": {
        "has_differences": true,
        "source_lines": 2,
        "target_lines": 2,
        "character_differences": 279,
        "similarity_percentage": 25.0
      },
      "vulnerability_location": {
        "vulnerability_present": true,
        "fix_applied": true,
        "code_changed": true,
        "estimated_lines_changed": 0
      }
    },
    {
      "cve_id": "CVE-2018-20763",
      "cwe_id": "CWE-787",
      "cwe_name": "Out-of-bounds Write",
      "project": "gpac",
      "severity": "critical",
      "weaponization_score": 10.0,
      "is_critical": true,
      "is_weaponizable": true,
      "is_high_priority_project": false,
      "vulnerable_code": "CWE-787 int mp4client_main ( int argc , char * * argv ) { char c ; const char * str ; int ret_val = 0 ; u32 i , times [ 100 ] , nb_times , dump_mode ; u32 simulation_time_in_ms = 0 ; u32 initial_service_id = 0 ; Bool auto_exit = GF_FALSE ; Bool logs_set = GF_FALSE ; Bool start_fs = GF_FALSE ; Bool use_rtix = GF_FALSE ; Bool pause_at_first = GF_FALSE ; Bool no_cfg_save = GF_FALSE ; Bool is_cfg_only = GF_FALSE ; Double play_from = 0 ; # ifdef GPAC_MEMORY_TRACKING GF_MemTrackerType mem_track = GF_MemTrackerNone ; # endif Double fps = GF_IMPORT_DEFAULT_FPS ; Bool fill_ar , visible , do_uncache , has_command ; char * url_arg , * out_arg , * the_cfg , * rti_file , * views , * mosaic ; FILE * logfile = NULL ; Float scale = 1 ; # ifndef WIN32 dlopen ( NULL , RTLD_NOW | RTLD_GLOBAL ) ; # endif strcpy ( the_url , \".\" ) ; memset ( & user , 0 , sizeof ( GF_User ) ) ; dump_mode = DUMP_NONE ; fill_ar = visible = do_uncache = has_command = GF_FALSE ; url_arg = out_arg = the_cfg = rti_file = views = mosaic = NULL ; nb_times = 0 ; times [ 0 ] = 0 ; for ( i = 1 ; i < ( u32 ) argc ; i ++ ) { char * arg = argv [ i ] ; if ( ! strcmp ( arg , \"-c\" ) || ! strcmp ( arg , \"-cfg\" ) ) { the_cfg = argv [ i + 1 ] ; i ++ ; } else if ( ! strcmp ( arg , \"-mem-track\" ) || ! strcmp ( arg , \"-mem-track-stack\" ) ) { # ifdef GPAC_MEMORY_TRACKING mem_track = ! strcmp ( arg , \"-mem-track-stack\" ) ? GF_MemTrackerBackTrace : GF_MemTrackerSimple ; # else fprintf ( stderr , \"WARNING<S2SV_blank>-<S2SV_blank>GPAC<S2SV_blank>not<S2SV_blank>compiled<S2SV_blank>with<S2SV_blank>Memory<S2SV_blank>Tracker<S2SV_blank>-<S2SV_blank>ignoring<S2SV_blank>\\\\\"%s\\\\\"\\\\n\" , arg ) ; # endif } else if ( ! strcmp ( arg , \"-gui\" ) ) { gui_mode = 1 ; } else if ( ! strcmp ( arg , \"-guid\" ) ) { gui_mode = 2 ; } else if ( ! strcmp ( arg , \"-h\" ) || ! strcmp ( arg , \"-help\" ) ) { PrintUsage ( ) ; return 0 ; } } # ifdef GPAC_MEMORY_TRACKING gf_sys_init ( mem_track ) ; # else gf_sys_init ( GF_MemTrackerNone ) ; # endif gf_sys_set_args ( argc , ( const char * * ) argv ) ; cfg_file = gf_cfg_init ( the_cfg , NULL ) ; if ( ! cfg_file ) { fprintf ( stderr , \"Error:<S2SV_blank>Configuration<S2SV_blank>File<S2SV_blank>not<S2SV_blank>found\\\\n\" ) ; return 1 ; } if ( gf_log_set_tools_levels ( gf_cfg_get_key ( cfg_file , \"General\" , \"Logs\" ) ) != GF_OK ) { return 1 ; } if ( gf_cfg_get_key ( cfg_file , \"General\" , \"Logs\" ) != NULL ) { logs_set = GF_TRUE ; } if ( ! gui_mode ) { str = gf_cfg_get_key ( cfg_file , \"General\" , \"ForceGUI\" ) ; if ( str && ! strcmp ( str , \"yes\" ) ) gui_mode = 1 ; } for ( i = 1 ; i < ( u32 ) argc ; i ++ ) { char * arg = argv [ i ] ; if ( ! strcmp ( arg , \"-rti\" ) ) { rti_file = argv [ i + 1 ] ; i ++ ; } else if ( ! strcmp ( arg , \"-rtix\" ) ) { rti_file = argv [ i + 1 ] ; i ++ ; use_rtix = GF_TRUE ; } else if ( ! stricmp ( arg , \"-size\" ) ) { if ( sscanf ( argv [ i + 1 ] , \"%dx%d\" , & forced_width , & forced_height ) != 2 ) { forced_width = forced_height = 0 ; } i ++ ; } else if ( ! strcmp ( arg , \"-quiet\" ) ) { be_quiet = 1 ; } else if ( ! strcmp ( arg , \"-strict-error\" ) ) { gf_log_set_strict_error ( 1 ) ; } else if ( ! strcmp ( arg , \"-log-file\" ) || ! strcmp ( arg , \"-lf\" ) ) { logfile = gf_fopen ( argv [ i + 1 ] , \"wt\" ) ; gf_log_set_callback ( logfile , on_gpac_log ) ; i ++ ; } else if ( ! strcmp ( arg , \"-logs\" ) ) { if ( gf_log_set_tools_levels ( argv [ i + 1 ] ) != GF_OK ) { return 1 ; } logs_set = GF_TRUE ; i ++ ; } else if ( ! strcmp ( arg , \"-log-clock\" ) || ! strcmp ( arg , \"-lc\" ) ) { log_time_start = 1 ; } else if ( ! strcmp ( arg , \"-log-utc\" ) || ! strcmp ( arg , \"-lu\" ) ) { log_utc_time = 1 ; } # if defined ( __DARWIN__ ) || defined ( __APPLE__ ) else if ( ! strcmp ( arg , \"-thread\" ) ) threading_flags = 0 ; # else else if ( ! strcmp ( arg , \"-no-thread\" ) ) threading_flags = GF_TERM_NO_DECODER_THREAD | GF_TERM_NO_COMPOSITOR_THREAD | GF_TERM_WINDOW_NO_THREAD ; # endif else if ( ! strcmp ( arg , \"-no-cthread\" ) || ! strcmp ( arg , \"-no-compositor-thread\" ) ) threading_flags |= GF_TERM_NO_COMPOSITOR_THREAD ; else if ( ! strcmp ( arg , \"-no-audio\" ) ) no_audio = 1 ; else if ( ! strcmp ( arg , \"-no-regulation\" ) ) no_regulation = 1 ; else if ( ! strcmp ( arg , \"-fs\" ) ) start_fs = 1 ; else if ( ! strcmp ( arg , \"-opt\" ) ) { set_cfg_option ( argv [ i + 1 ] ) ; i ++ ; } else if ( ! strcmp ( arg , \"-conf\" ) ) { set_cfg_option ( argv [ i + 1 ] ) ; is_cfg_only = GF_TRUE ; i ++ ; } else if ( ! strcmp ( arg , \"-ifce\" ) ) { gf_cfg_set_key ( cfg_file , \"Network\" , \"DefaultMCastInterface\" , argv [ i + 1 ] ) ; i ++ ; } else if ( ! stricmp ( arg , \"-help\" ) ) { PrintUsage ( ) ; return 1 ; } else if ( ! stricmp ( arg , \"-noprog\" ) ) { no_prog = 1 ; gf_set_progress_callback ( NULL , progress_quiet ) ; } else if ( ! stricmp ( arg , \"-no-save\" ) || ! stricmp ( arg , \"--no-save\" ) ) { no_cfg_save = 1 ; } else if ( ! stricmp ( arg , \"-ntp-shift\" ) ) { s32 shift = atoi ( argv [ i + 1 ] ) ; i ++ ; gf_net_set_ntp_shift ( shift ) ; } else if ( ! stricmp ( arg , \"-run-for\" ) ) { simulation_time_in_ms = atoi ( argv [ i + 1 ] ) * 1000 ; if ( ! simulation_time_in_ms ) simulation_time_in_ms = 1 ; i ++ ; } else if ( ! strcmp ( arg , \"-out\" ) ) { out_arg = argv [ i + 1 ] ; i ++ ; } else if ( ! stricmp ( arg , \"-fps\" ) ) { fps = atof ( argv [ i + 1 ] ) ; i ++ ; } else if ( ! strcmp ( arg , \"-avi\" ) || ! strcmp ( arg , \"-sha\" ) ) { dump_mode &= 0xFFFF0000 ; if ( ! strcmp ( arg , \"-sha\" ) ) dump_mode |= DUMP_SHA1 ; else dump_mode |= DUMP_AVI ; if ( ( url_arg || ( i + 2 < ( u32 ) argc ) ) && get_time_list ( argv [ i + 1 ] , times , & nb_times ) ) { if ( ! strcmp ( arg , \"-avi\" ) && ( nb_times != 2 ) ) { fprintf ( stderr , \"Only<S2SV_blank>one<S2SV_blank>time<S2SV_blank>arg<S2SV_blank>found<S2SV_blank>for<S2SV_blank>-avi<S2SV_blank>-<S2SV_blank>check<S2SV_blank>usage\\\\n\" ) ; return 1 ; } i ++ ; } } else if ( ! strcmp ( arg , \"-rgbds\" ) ) { dump_mode |= DUMP_RGB_DEPTH_SHAPE ; } else if ( ! strcmp ( arg , \"-rgbd\" ) ) { dump_mode |= DUMP_RGB_DEPTH ; } else if ( ! strcmp ( arg , \"-depth\" ) ) { dump_mode |= DUMP_DEPTH_ONLY ; } else if ( ! strcmp ( arg , \"-bmp\" ) ) { dump_mode &= 0xFFFF0000 ; dump_mode |= DUMP_BMP ; if ( ( url_arg || ( i + 2 < ( u32 ) argc ) ) && get_time_list ( argv [ i + 1 ] , times , & nb_times ) ) i ++ ; } else if ( ! strcmp ( arg , \"-png\" ) ) { dump_mode &= 0xFFFF0000 ; dump_mode |= DUMP_PNG ; if ( ( url_arg || ( i + 2 < ( u32 ) argc ) ) && get_time_list ( argv [ i + 1 ] , times , & nb_times ) ) i ++ ; } else if ( ! strcmp ( arg , \"-raw\" ) ) { dump_mode &= 0xFFFF0000 ; dump_mode |= DUMP_RAW ; if ( ( url_arg || ( i + 2 < ( u32 ) argc ) ) && get_time_list ( argv [ i + 1 ] , times , & nb_times ) ) i ++ ; } else if ( ! stricmp ( arg , \"-scale\" ) ) { sscanf ( argv [ i + 1 ] , \"%f\" , & scale ) ; i ++ ; } else if ( ! strcmp ( arg , \"-c\" ) || ! strcmp ( arg , \"-cfg\" ) ) { i ++ ; } if ( ! gui_mode ) { if ( arg [ 0 ] != '-' ) { if ( url_arg ) { fprintf ( stderr , \"Several<S2SV_blank>input<S2SV_blank>URLs<S2SV_blank>provided<S2SV_blank>(\\\\\"%s\\\\\",<S2SV_blank>\\\\\"%s\\\\\").<S2SV_blank>Check<S2SV_blank>your<S2SV_blank>command-line.\\\\n\" , url_arg , arg ) ; return 1 ; } url_arg = arg ; } else if ( ! strcmp ( arg , \"-loop\" ) ) loop_at_end = 1 ; else if ( ! strcmp ( arg , \"-bench\" ) ) bench_mode = 1 ; else if ( ! strcmp ( arg , \"-vbench\" ) ) bench_mode = 2 ; else if ( ! strcmp ( arg , \"-sbench\" ) ) bench_mode = 3 ; else if ( ! strcmp ( arg , \"-no-addon\" ) ) enable_add_ons = GF_FALSE ; else if ( ! strcmp ( arg , \"-pause\" ) ) pause_at_first = 1 ; else if ( ! strcmp ( arg , \"-play-from\" ) ) { play_from = atof ( ( const char * ) argv [ i + 1 ] ) ; i ++ ; } else if ( ! strcmp ( arg , \"-speed\" ) ) { playback_speed = FLT2FIX ( atof ( ( const char * ) argv [ i + 1 ] ) ) ; if ( playback_speed <= 0 ) playback_speed = FIX_ONE ; i ++ ; } else if ( ! strcmp ( arg , \"-no-wnd\" ) ) user . init_flags |= GF_TERM_WINDOWLESS ; else if ( ! strcmp ( arg , \"-no-back\" ) ) user . init_flags |= GF_TERM_WINDOW_TRANSPARENT ; else if ( ! strcmp ( arg , \"-align\" ) ) { if ( argv [ i + 1 ] [ 0 ] == 'm' ) align_mode = 1 ; else if ( argv [ i + 1 ] [ 0 ] == 'b' ) align_mode = 2 ; align_mode <<= 8 ; if ( argv [ i + 1 ] [ 1 ] == 'm' ) align_mode |= 1 ; else if ( argv [ i + 1 ] [ 1 ] == 'r' ) align_mode |= 2 ; i ++ ; } else if ( ! strcmp ( arg , \"-fill\" ) ) { fill_ar = GF_TRUE ; } else if ( ! strcmp ( arg , \"-show\" ) ) { visible = 1 ; } else if ( ! strcmp ( arg , \"-uncache\" ) ) { do_uncache = GF_TRUE ; } else if ( ! strcmp ( arg , \"-exit\" ) ) auto_exit = GF_TRUE ; else if ( ! stricmp ( arg , \"-views\" ) ) { views = argv [ i + 1 ] ; i ++ ; } else if ( ! stricmp ( arg , \"-mosaic\" ) ) { mosaic = argv [ i + 1 ] ; i ++ ; } else if ( ! stricmp ( arg , \"-com\" ) ) { has_command = GF_TRUE ; i ++ ; } else if ( ! stricmp ( arg , \"-service\" ) ) { initial_service_id = atoi ( argv [ i + 1 ] ) ; i ++ ; } } } if ( is_cfg_only ) { gf_cfg_del ( cfg_file ) ; fprintf ( stderr , \"GPAC<S2SV_blank>Config<S2SV_blank>updated\\\\n\" ) ; return 0 ; } if ( do_uncache ) { const char * cache_dir = gf_cfg_get_key ( cfg_file , \"General\" , \"CacheDirectory\" ) ; do_flatten_cache ( cache_dir ) ; fprintf ( stderr , \"GPAC<S2SV_blank>Cache<S2SV_blank>dir<S2SV_blank>%s<S2SV_blank>flattened\\\\n\" , cache_dir ) ; gf_cfg_del ( cfg_file ) ; return 0 ; } if ( dump_mode && ! url_arg ) { FILE * test ; url_arg = ( char * ) gf_cfg_get_key ( cfg_file , \"General\" , \"StartupFile\" ) ; test = url_arg ? gf_fopen ( url_arg , \"rt\" ) : NULL ; if ( ! test ) url_arg = NULL ; else gf_fclose ( test ) ; if ( ! url_arg ) { fprintf ( stderr , \"Missing<S2SV_blank>argument<S2SV_blank>for<S2SV_blank>dump\\\\n\" ) ; PrintUsage ( ) ; if ( logfile ) gf_fclose ( logfile ) ; return 1 ; } } if ( ! gui_mode && ! url_arg && ( gf_cfg_get_key ( cfg_file , \"General\" , \"StartupFile\" ) != NULL ) ) { gui_mode = 1 ; } # ifdef WIN32 if ( gui_mode == 1 ) { const char * opt ; TCHAR buffer [ 1024 ] ; DWORD res = GetCurrentDirectory ( 1024 , buffer ) ; buffer [ res ] = 0 ; opt = gf_cfg_get_key ( cfg_file , \"General\" , \"ModulesDirectory\" ) ; if ( strstr ( opt , buffer ) ) { gui_mode = 1 ; } else { gui_mode = 2 ; } } # endif if ( gui_mode == 1 ) { hide_shell ( 1 ) ; } if ( gui_mode ) { no_prog = 1 ; gf_set_progress_callback ( NULL , progress_quiet ) ; } if ( ! url_arg && simulation_time_in_ms ) simulation_time_in_ms += gf_sys_clock ( ) ; # if defined ( __DARWIN__ ) || defined ( __APPLE__ ) carbon_init ( ) ; # endif if ( dump_mode ) rti_file = NULL ; if ( ! logs_set ) { gf_log_set_tool_level ( GF_LOG_ALL , GF_LOG_WARNING ) ; } if ( rti_file || logfile || log_utc_time || log_time_start ) gf_log_set_callback ( NULL , on_gpac_log ) ; if ( rti_file ) init_rti_logs ( rti_file , url_arg , use_rtix ) ; { GF_SystemRTInfo rti ; if ( gf_sys_get_rti ( 0 , & rti , 0 ) ) fprintf ( stderr , \"System<S2SV_blank>info:<S2SV_blank>%d<S2SV_blank>MB<S2SV_blank>RAM<S2SV_blank>-<S2SV_blank>%d<S2SV_blank>cores\\\\n\" , ( u32 ) ( rti . physical_memory / 1024 / 1024 ) , rti . nb_cores ) ; } if ( dump_mode ) { user . init_flags |= GF_TERM_NO_DECODER_THREAD | GF_TERM_NO_COMPOSITOR_THREAD | GF_TERM_NO_REGULATION ; if ( ! visible ) user . init_flags |= GF_TERM_INIT_HIDE ; gf_cfg_set_key ( cfg_file , \"Audio\" , \"DriverName\" , \"Raw<S2SV_blank>Audio<S2SV_blank>Output\" ) ; no_cfg_save = GF_TRUE ; } else { init_w = forced_width ; init_h = forced_height ; } user . modules = gf_modules_new ( NULL , cfg_file ) ; if ( user . modules ) i = gf_modules_get_count ( user . modules ) ; if ( ! i || ! user . modules ) { fprintf ( stderr , \"Error:<S2SV_blank>no<S2SV_blank>modules<S2SV_blank>found<S2SV_blank>-<S2SV_blank>exiting\\\\n\" ) ; if ( user . modules ) gf_modules_del ( user . modules ) ; gf_cfg_del ( cfg_file ) ; gf_sys_close ( ) ; if ( logfile ) gf_fclose ( logfile ) ; return 1 ; } fprintf ( stderr , \"Modules<S2SV_blank>Found<S2SV_blank>:<S2SV_blank>%d<S2SV_blank>\\\\n\" , i ) ; str = gf_cfg_get_key ( cfg_file , \"General\" , \"GPACVersion\" ) ; if ( ! str || strcmp ( str , GPAC_FULL_VERSION ) ) { gf_cfg_del_section ( cfg_file , \"PluginsCache\" ) ; gf_cfg_set_key ( cfg_file , \"General\" , \"GPACVersion\" , GPAC_FULL_VERSION ) ; } user . config = cfg_file ; user . EventProc = GPAC_EventProc ; user . opaque = user . modules ; if ( threading_flags ) user . init_flags |= threading_flags ; if ( no_audio ) user . init_flags |= GF_TERM_NO_AUDIO ; if ( no_regulation ) user . init_flags |= GF_TERM_NO_REGULATION ; if ( threading_flags & ( GF_TERM_NO_DECODER_THREAD | GF_TERM_NO_COMPOSITOR_THREAD ) ) term_step = GF_TRUE ; if ( dump_mode ) user . init_flags |= GF_TERM_USE_AUDIO_HW_CLOCK ; if ( bench_mode ) { gf_cfg_discard_changes ( user . config ) ; auto_exit = GF_TRUE ; gf_cfg_set_key ( user . config , \"Audio\" , \"DriverName\" , \"Raw<S2SV_blank>Audio<S2SV_blank>Output\" ) ; if ( bench_mode != 2 ) { gf_cfg_set_key ( user . config , \"Video\" , \"DriverName\" , \"Raw<S2SV_blank>Video<S2SV_blank>Output\" ) ; gf_cfg_set_key ( user . config , \"RAWVideo\" , \"RawOutput\" , \"null\" ) ; gf_cfg_set_key ( user . config , \"Compositor\" , \"OpenGLMode\" , \"disable\" ) ; } else { gf_cfg_set_key ( user . config , \"Video\" , \"DisableVSync\" , \"yes\" ) ; } } { char dim [ 50 ] ; sprintf ( dim , \"%d\" , forced_width ) ; gf_cfg_set_key ( user . config , \"Compositor\" , \"DefaultWidth\" , forced_width ? dim : NULL ) ; sprintf ( dim , \"%d\" , forced_height ) ; gf_cfg_set_key ( user . config , \"Compositor\" , \"DefaultHeight\" , forced_height ? dim : NULL ) ; } fprintf ( stderr , \"Loading<S2SV_blank>GPAC<S2SV_blank>Terminal\\\\n\" ) ; i = gf_sys_clock ( ) ; term = gf_term_new ( & user ) ; if ( ! term ) { fprintf ( stderr , \"\\\\nInit<S2SV_blank>error<S2SV_blank>-<S2SV_blank>check<S2SV_blank>you<S2SV_blank>have<S2SV_blank>at<S2SV_blank>least<S2SV_blank>one<S2SV_blank>video<S2SV_blank>out<S2SV_blank>and<S2SV_blank>one<S2SV_blank>rasterizer...\\\\nFound<S2SV_blank>modules:\\\\n\" ) ; list_modules ( user . modules ) ; gf_modules_del ( user . modules ) ; gf_cfg_discard_changes ( cfg_file ) ; gf_cfg_del ( cfg_file ) ; gf_sys_close ( ) ; if ( logfile ) gf_fclose ( logfile ) ; return 1 ; } fprintf ( stderr , \"Terminal<S2SV_blank>Loaded<S2SV_blank>in<S2SV_blank>%d<S2SV_blank>ms\\\\n\" , gf_sys_clock ( ) - i ) ; if ( bench_mode ) { display_rti = 2 ; gf_term_set_option ( term , GF_OPT_VIDEO_BENCH , ( bench_mode == 3 ) ? 2 : 1 ) ; if ( bench_mode == 1 ) bench_mode = 2 ; } if ( dump_mode ) { if ( fill_ar ) gf_term_set_option ( term , GF_OPT_ASPECT_RATIO , GF_ASPECT_RATIO_FILL_SCREEN ) ; } else { str = gf_cfg_get_key ( cfg_file , \"Video\" , \"DriverName\" ) ; if ( ! bench_mode && ! strcmp ( str , \"Raw<S2SV_blank>Video<S2SV_blank>Output\" ) ) fprintf ( stderr , \"WARNING:<S2SV_blank>using<S2SV_blank>raw<S2SV_blank>output<S2SV_blank>video<S2SV_blank>(memory<S2SV_blank>only)<S2SV_blank>-<S2SV_blank>no<S2SV_blank>display<S2SV_blank>used\\\\n\" ) ; str = gf_cfg_get_key ( cfg_file , \"Audio\" , \"DriverName\" ) ; if ( ! str || ! strcmp ( str , \"No<S2SV_blank>Audio<S2SV_blank>Output<S2SV_blank>Available\" ) ) fprintf ( stderr , \"WARNING:<S2SV_blank>no<S2SV_blank>audio<S2SV_blank>output<S2SV_blank>available<S2SV_blank>-<S2SV_blank>make<S2SV_blank>sure<S2SV_blank>no<S2SV_blank>other<S2SV_blank>program<S2SV_blank>is<S2SV_blank>locking<S2SV_blank>the<S2SV_blank>sound<S2SV_blank>card\\\\n\" ) ; str = gf_cfg_get_key ( cfg_file , \"General\" , \"NoMIMETypeFetch\" ) ; no_mime_check = ( str && ! stricmp ( str , \"yes\" ) ) ? 1 : 0 ; } str = gf_cfg_get_key ( cfg_file , \"HTTPProxy\" , \"Enabled\" ) ; if ( str && ! strcmp ( str , \"yes\" ) ) { str = gf_cfg_get_key ( cfg_file , \"HTTPProxy\" , \"Name\" ) ; if ( str ) fprintf ( stderr , \"HTTP<S2SV_blank>Proxy<S2SV_blank>%s<S2SV_blank>enabled\\\\n\" , str ) ; } if ( rti_file ) { str = gf_cfg_get_key ( cfg_file , \"General\" , \"RTIRefreshPeriod\" ) ; if ( str ) { rti_update_time_ms = atoi ( str ) ; } else { gf_cfg_set_key ( cfg_file , \"General\" , \"RTIRefreshPeriod\" , \"200\" ) ; } UpdateRTInfo ( \"At<S2SV_blank>GPAC<S2SV_blank>load<S2SV_blank>time\\\\n\" ) ; } Run = 1 ; if ( dump_mode ) { if ( ! nb_times ) { times [ 0 ] = 0 ; nb_times ++ ; } ret_val = dump_file ( url_arg , out_arg , dump_mode , fps , forced_width , forced_height , scale , times , nb_times ) ; Run = 0 ; } else if ( views ) { } else if ( ! gui_mode && url_arg ) { char * ext ; if ( strlen ( url_arg ) >= sizeof ( the_url ) ) { fprintf ( stderr , \"Input<S2SV_blank>url<S2SV_blank>%s<S2SV_blank>is<S2SV_blank>too<S2SV_blank>long,<S2SV_blank>truncating<S2SV_blank>to<S2SV_blank>%d<S2SV_blank>chars.\\\\n\" , url_arg , ( int ) ( sizeof ( the_url ) - 1 ) ) ; strncpy ( the_url , url_arg , sizeof ( the_url ) - 1 ) ; the_url [ sizeof ( the_url ) - 1 ] = 0 ; } else { strcpy ( the_url , url_arg ) ; } ext = strrchr ( the_url , '.' ) ; if ( ext && ( ! stricmp ( ext , \".m3u\" ) || ! stricmp ( ext , \".pls\" ) ) ) { GF_Err e = GF_OK ; fprintf ( stderr , \"Opening<S2SV_blank>Playlist<S2SV_blank>%s\\\\n\" , the_url ) ; strcpy ( pl_path , the_url ) ; if ( ! strncmp ( \"http:\" , the_url , 5 ) ) { GF_DownloadSession * sess = gf_dm_sess_new ( term -> downloader , the_url , GF_NETIO_SESSION_NOT_THREADED , NULL , NULL , & e ) ; if ( sess ) { e = gf_dm_sess_process ( sess ) ; if ( ! e ) { strncpy ( the_url , gf_dm_sess_get_cache_name ( sess ) , sizeof ( the_url ) - 1 ) ; <S2SV_StartBug> the_url [ sizeof ( the_cfg ) - 1 ] = 0 ; <S2SV_EndBug> } gf_dm_sess_del ( sess ) ; } } playlist = e ? NULL : gf_fopen ( the_url , \"rt\" ) ; readonly_playlist = 1 ; if ( playlist ) { request_next_playlist_item = GF_TRUE ; } else { if ( e ) fprintf ( stderr , \"Failed<S2SV_blank>to<S2SV_blank>open<S2SV_blank>playlist<S2SV_blank>%s:<S2SV_blank>%s\\\\n\" , the_url , gf_error_to_string ( e ) ) ; fprintf ( stderr , \"Hit<S2SV_blank>\\'h\\'<S2SV_blank>for<S2SV_blank>help\\\\n\\\\n\" ) ; } } else { fprintf ( stderr , \"Opening<S2SV_blank>URL<S2SV_blank>%s\\\\n\" , the_url ) ; if ( pause_at_first ) fprintf ( stderr , \"[Status:<S2SV_blank>Paused]\\\\n\" ) ; gf_term_connect_from_time ( term , the_url , ( u64 ) ( play_from * 1000 ) , pause_at_first ) ; } } else { fprintf ( stderr , \"Hit<S2SV_blank>\\'h\\'<S2SV_blank>for<S2SV_blank>help\\\\n\\\\n\" ) ; str = gf_cfg_get_key ( cfg_file , \"General\" , \"StartupFile\" ) ; if ( str ) { strncpy ( the_url , \"MP4Client<S2SV_blank>\" GPAC_FULL_VERSION , sizeof ( the_url ) - 1 ) ; the_url [ sizeof ( the_url ) - 1 ] = 0 ; gf_term_connect ( term , str ) ; startup_file = 1 ; is_connected = 1 ; } } if ( gui_mode == 2 ) gui_mode = 0 ; if ( start_fs ) gf_term_set_option ( term , GF_OPT_FULLSCREEN , 1 ) ; if ( views ) { char szTemp [ 4046 ] ; sprintf ( szTemp , \"views://%s\" , views ) ; gf_term_connect ( term , szTemp ) ; } if ( mosaic ) { char szTemp [ 4046 ] ; sprintf ( szTemp , \"mosaic://%s\" , mosaic ) ; gf_term_connect ( term , szTemp ) ; } if ( bench_mode ) { rti_update_time_ms = 500 ; bench_mode_start = gf_sys_clock ( ) ; } while ( Run ) { if ( ( gui_mode == 1 ) || ! gf_prompt_has_input ( ) ) { if ( reload ) { reload = 0 ; gf_term_disconnect ( term ) ; gf_term_connect ( term , startup_file ? gf_cfg_get_key ( cfg_file , \"General\" , \"StartupFile\" ) : the_url ) ; } if ( restart && gf_term_get_option ( term , GF_OPT_IS_OVER ) ) { restart = 0 ; gf_term_play_from_time ( term , 0 , 0 ) ; } if ( request_next_playlist_item ) { c = '\\\\n' ; request_next_playlist_item = 0 ; goto force_input ; } if ( has_command && is_connected ) { has_command = GF_FALSE ; for ( i = 0 ; i < ( u32 ) argc ; i ++ ) { if ( ! strcmp ( argv [ i ] , \"-com\" ) ) { gf_term_scene_update ( term , NULL , argv [ i + 1 ] ) ; i ++ ; } } } if ( initial_service_id && is_connected ) { GF_ObjectManager * root_od = gf_term_get_root_object ( term ) ; if ( root_od ) { gf_term_select_service ( term , root_od , initial_service_id ) ; initial_service_id = 0 ; } } if ( ! use_rtix || display_rti ) UpdateRTInfo ( NULL ) ; if ( term_step ) { gf_term_process_step ( term ) ; } else { gf_sleep ( rti_update_time_ms ) ; } if ( auto_exit && eos_seen && gf_term_get_option ( term , GF_OPT_IS_OVER ) ) { Run = GF_FALSE ; } if ( simulation_time_in_ms && ( ( gf_term_get_elapsed_time_in_ms ( term ) > simulation_time_in_ms ) || ( ! url_arg && gf_sys_clock ( ) > simulation_time_in_ms ) ) ) { Run = GF_FALSE ; } continue ; } c = gf_prompt_get_char ( ) ; force_input : switch ( c ) { case 'q' : { GF_Event evt ; memset ( & evt , 0 , sizeof ( GF_Event ) ) ; evt . type = GF_EVENT_QUIT ; gf_term_send_event ( term , & evt ) ; } break ; case 'X' : exit ( 0 ) ; break ; case 'Q' : break ; case 'o' : startup_file = 0 ; gf_term_disconnect ( term ) ; fprintf ( stderr , \"Enter<S2SV_blank>the<S2SV_blank>absolute<S2SV_blank>URL\\\\n\" ) ; if ( 1 > scanf ( \"%s\" , the_url ) ) { fprintf ( stderr , \"Cannot<S2SV_blank>read<S2SV_blank>absolute<S2SV_blank>URL,<S2SV_blank>aborting\\\\n\" ) ; break ; } if ( rti_file ) init_rti_logs ( rti_file , the_url , use_rtix ) ; gf_term_connect ( term , the_url ) ; break ; case 'O' : gf_term_disconnect ( term ) ; fprintf ( stderr , \"Enter<S2SV_blank>the<S2SV_blank>absolute<S2SV_blank>URL<S2SV_blank>to<S2SV_blank>the<S2SV_blank>playlist\\\\n\" ) ; if ( 1 > scanf ( \"%s\" , the_url ) ) { fprintf ( stderr , \"Cannot<S2SV_blank>read<S2SV_blank>the<S2SV_blank>absolute<S2SV_blank>URL,<S2SV_blank>aborting.\\\\n\" ) ; break ; } playlist = gf_fopen ( the_url , \"rt\" ) ; if ( playlist ) { if ( 1 > fscanf ( playlist , \"%s\" , the_url ) ) { fprintf ( stderr , \"Cannot<S2SV_blank>read<S2SV_blank>any<S2SV_blank>URL<S2SV_blank>from<S2SV_blank>playlist,<S2SV_blank>aborting.\\\\n\" ) ; gf_fclose ( playlist ) ; break ; } fprintf ( stderr , \"Opening<S2SV_blank>URL<S2SV_blank>%s\\\\n\" , the_url ) ; gf_term_connect ( term , the_url ) ; } break ; case '\\\\n' : case 'N' : if ( playlist ) { int res ; gf_term_disconnect ( term ) ; res = fscanf ( playlist , \"%s\" , the_url ) ; if ( ( res == EOF ) && loop_at_end ) { fseek ( playlist , 0 , SEEK_SET ) ; res = fscanf ( playlist , \"%s\" , the_url ) ; } if ( res == EOF ) { fprintf ( stderr , \"No<S2SV_blank>more<S2SV_blank>items<S2SV_blank>-<S2SV_blank>exiting\\\\n\" ) ; Run = 0 ; } else if ( the_url [ 0 ] == '#' ) { request_next_playlist_item = GF_TRUE ; } else { fprintf ( stderr , \"Opening<S2SV_blank>URL<S2SV_blank>%s\\\\n\" , the_url ) ; gf_term_connect_with_path ( term , the_url , pl_path ) ; } } break ; case 'P' : if ( playlist ) { u32 count ; gf_term_disconnect ( term ) ; if ( 1 > scanf ( \"%u\" , & count ) ) { fprintf ( stderr , \"Cannot<S2SV_blank>read<S2SV_blank>number,<S2SV_blank>aborting.\\\\n\" ) ; break ; } while ( count ) { if ( fscanf ( playlist , \"%s\" , the_url ) ) { fprintf ( stderr , \"Failed<S2SV_blank>to<S2SV_blank>read<S2SV_blank>line,<S2SV_blank>aborting\\\\n\" ) ; break ; } count -- ; } fprintf ( stderr , \"Opening<S2SV_blank>URL<S2SV_blank>%s\\\\n\" , the_url ) ; gf_term_connect ( term , the_url ) ; } break ; case 'r' : if ( is_connected ) reload = 1 ; break ; case 'D' : if ( is_connected ) gf_term_disconnect ( term ) ; break ; case 'p' : if ( is_connected ) { Bool is_pause = gf_term_get_option ( term , GF_OPT_PLAY_STATE ) ; fprintf ( stderr , \"[Status:<S2SV_blank>%s]\\\\n\" , is_pause ? \"Playing\" : \"Paused\" ) ; gf_term_set_option ( term , GF_OPT_PLAY_STATE , is_pause ? GF_STATE_PLAYING : GF_STATE_PAUSED ) ; } break ; case 's' : if ( is_connected ) { gf_term_set_option ( term , GF_OPT_PLAY_STATE , GF_STATE_STEP_PAUSE ) ; fprintf ( stderr , \"Step<S2SV_blank>time:<S2SV_blank>\" ) ; PrintTime ( gf_term_get_time_in_ms ( term ) ) ; fprintf ( stderr , \"\\\\n\" ) ; } break ; case 'z' : case 'T' : if ( ! CanSeek || ( Duration <= 2000 ) ) { fprintf ( stderr , \"scene<S2SV_blank>not<S2SV_blank>seekable\\\\n\" ) ; } else { Double res ; s32 seekTo ; fprintf ( stderr , \"Duration:<S2SV_blank>\" ) ; PrintTime ( Duration ) ; res = gf_term_get_time_in_ms ( term ) ; if ( c == 'z' ) { res *= 100 ; res /= ( s64 ) Duration ; fprintf ( stderr , \"<S2SV_blank>(current<S2SV_blank>%.2f<S2SV_blank>%%)\\\\nEnter<S2SV_blank>Seek<S2SV_blank>percentage:\\\\n\" , res ) ; if ( scanf ( \"%d\" , & seekTo ) == 1 ) { if ( seekTo > 100 ) seekTo = 100 ; res = ( Double ) ( s64 ) Duration ; res /= 100 ; res *= seekTo ; gf_term_play_from_time ( term , ( u64 ) ( s64 ) res , 0 ) ; } } else { u32 r , h , m , s ; fprintf ( stderr , \"<S2SV_blank>-<S2SV_blank>Current<S2SV_blank>Time:<S2SV_blank>\" ) ; PrintTime ( ( u64 ) res ) ; fprintf ( stderr , \"\\\\nEnter<S2SV_blank>seek<S2SV_blank>time<S2SV_blank>(Format:<S2SV_blank>s,<S2SV_blank>m:s<S2SV_blank>or<S2SV_blank>h:m:s):\\\\n\" ) ; h = m = s = 0 ; r = scanf ( \"%d:%d:%d\" , & h , & m , & s ) ; if ( r == 2 ) { s = m ; m = h ; h = 0 ; } else if ( r == 1 ) { s = h ; m = h = 0 ; } if ( r && ( r <= 3 ) ) { u64 time = h * 3600 + m * 60 + s ; gf_term_play_from_time ( term , time * 1000 , 0 ) ; } } } break ; case 't' : { if ( is_connected ) { fprintf ( stderr , \"Current<S2SV_blank>Time:<S2SV_blank>\" ) ; PrintTime ( gf_term_get_time_in_ms ( term ) ) ; fprintf ( stderr , \"<S2SV_blank>-<S2SV_blank>Duration:<S2SV_blank>\" ) ; PrintTime ( Duration ) ; fprintf ( stderr , \"\\\\n\" ) ; } } break ; case 'w' : if ( is_connected ) PrintWorldInfo ( term ) ; break ; case 'v' : if ( is_connected ) PrintODList ( term , NULL , 0 , 0 , \"Root\" ) ; break ; case 'i' : if ( is_connected ) { u32 ID ; fprintf ( stderr , \"Enter<S2SV_blank>OD<S2SV_blank>ID<S2SV_blank>(0<S2SV_blank>for<S2SV_blank>main<S2SV_blank>OD):<S2SV_blank>\" ) ; fflush ( stderr ) ; if ( scanf ( \"%ud\" , & ID ) == 1 ) { ViewOD ( term , ID , ( u32 ) - 1 , NULL ) ; } else { char str_url [ GF_MAX_PATH ] ; if ( scanf ( \"%s\" , str_url ) == 1 ) ViewOD ( term , 0 , ( u32 ) - 1 , str_url ) ; } } break ; case 'j' : if ( is_connected ) { u32 num ; do { fprintf ( stderr , \"Enter<S2SV_blank>OD<S2SV_blank>number<S2SV_blank>(0<S2SV_blank>for<S2SV_blank>main<S2SV_blank>OD):<S2SV_blank>\" ) ; fflush ( stderr ) ; } while ( 1 > scanf ( \"%ud\" , & num ) ) ; ViewOD ( term , ( u32 ) - 1 , num , NULL ) ; } break ; case 'b' : if ( is_connected ) ViewODs ( term , 1 ) ; break ; case 'm' : if ( is_connected ) ViewODs ( term , 0 ) ; break ; case 'l' : list_modules ( user . modules ) ; break ; case 'n' : if ( is_connected ) set_navigation ( ) ; break ; case 'x' : if ( is_connected ) gf_term_set_option ( term , GF_OPT_NAVIGATION_TYPE , 0 ) ; break ; case 'd' : if ( is_connected ) { GF_ObjectManager * odm = NULL ; char radname [ GF_MAX_PATH ] , * sExt ; GF_Err e ; u32 i , count , odid ; Bool xml_dump , std_out ; radname [ 0 ] = 0 ; do { fprintf ( stderr , \"Enter<S2SV_blank>Inline<S2SV_blank>OD<S2SV_blank>ID<S2SV_blank>if<S2SV_blank>any<S2SV_blank>or<S2SV_blank>0<S2SV_blank>:<S2SV_blank>\" ) ; fflush ( stderr ) ; } while ( 1 > scanf ( \"%ud\" , & odid ) ) ; if ( odid ) { GF_ObjectManager * root_odm = gf_term_get_root_object ( term ) ; if ( ! root_odm ) break ; count = gf_term_get_object_count ( term , root_odm ) ; for ( i = 0 ; i < count ; i ++ ) { GF_MediaInfo info ; odm = gf_term_get_object ( term , root_odm , i ) ; if ( gf_term_get_object_info ( term , odm , & info ) == GF_OK ) { if ( info . od -> objectDescriptorID == odid ) break ; } odm = NULL ; } } do { fprintf ( stderr , \"Enter<S2SV_blank>file<S2SV_blank>radical<S2SV_blank>name<S2SV_blank>(+\\\\\\'.x\\\\\\'<S2SV_blank>for<S2SV_blank>XML<S2SV_blank>dumping)<S2SV_blank>-<S2SV_blank>\\\\\"std\\\\\"<S2SV_blank>for<S2SV_blank>stderr:<S2SV_blank>\" ) ; fflush ( stderr ) ; } while ( 1 > scanf ( \"%s\" , radname ) ) ; sExt = strrchr ( radname , '.' ) ; xml_dump = 0 ; if ( sExt ) { if ( ! stricmp ( sExt , \".x\" ) ) xml_dump = 1 ; sExt [ 0 ] = 0 ; } std_out = strnicmp ( radname , \"std\" , 3 ) ? 0 : 1 ; e = gf_term_dump_scene ( term , std_out ? NULL : radname , NULL , xml_dump , 0 , odm ) ; fprintf ( stderr , \"Dump<S2SV_blank>done<S2SV_blank>(%s)\\\\n\" , gf_error_to_string ( e ) ) ; } break ; case 'c' : PrintGPACConfig ( ) ; break ; case '3' : { Bool use_3d = ! gf_term_get_option ( term , GF_OPT_USE_OPENGL ) ; if ( gf_term_set_option ( term , GF_OPT_USE_OPENGL , use_3d ) == GF_OK ) { fprintf ( stderr , \"Using<S2SV_blank>%s<S2SV_blank>for<S2SV_blank>2D<S2SV_blank>drawing\\\\n\" , use_3d ? \"OpenGL\" : \"2D<S2SV_blank>rasterizer\" ) ; } } break ; case 'k' : { Bool opt = gf_term_get_option ( term , GF_OPT_STRESS_MODE ) ; opt = ! opt ; fprintf ( stderr , \"Turning<S2SV_blank>stress<S2SV_blank>mode<S2SV_blank>%s\\\\n\" , opt ? \"on\" : \"off\" ) ; gf_term_set_option ( term , GF_OPT_STRESS_MODE , opt ) ; } break ; case '4' : gf_term_set_option ( term , GF_OPT_ASPECT_RATIO , GF_ASPECT_RATIO_4_3 ) ; break ; case '5' : gf_term_set_option ( term , GF_OPT_ASPECT_RATIO , GF_ASPECT_RATIO_16_9 ) ; break ; case '6' : gf_term_set_option ( term , GF_OPT_ASPECT_RATIO , GF_ASPECT_RATIO_FILL_SCREEN ) ; break ; case '7' : gf_term_set_option ( term , GF_OPT_ASPECT_RATIO , GF_ASPECT_RATIO_KEEP ) ; break ; case 'C' : switch ( gf_term_get_option ( term , GF_OPT_MEDIA_CACHE ) ) { case GF_MEDIA_CACHE_DISABLED : gf_term_set_option ( term , GF_OPT_MEDIA_CACHE , GF_MEDIA_CACHE_ENABLED ) ; break ; case GF_MEDIA_CACHE_ENABLED : gf_term_set_option ( term , GF_OPT_MEDIA_CACHE , GF_MEDIA_CACHE_DISABLED ) ; break ; case GF_MEDIA_CACHE_RUNNING : fprintf ( stderr , \"Streaming<S2SV_blank>Cache<S2SV_blank>is<S2SV_blank>running<S2SV_blank>-<S2SV_blank>please<S2SV_blank>stop<S2SV_blank>it<S2SV_blank>first\\\\n\" ) ; continue ; } switch ( gf_term_get_option ( term , GF_OPT_MEDIA_CACHE ) ) { case GF_MEDIA_CACHE_ENABLED : fprintf ( stderr , \"Streaming<S2SV_blank>Cache<S2SV_blank>Enabled\\\\n\" ) ; break ; case GF_MEDIA_CACHE_DISABLED : fprintf ( stderr , \"Streaming<S2SV_blank>Cache<S2SV_blank>Disabled\\\\n\" ) ; break ; case GF_MEDIA_CACHE_RUNNING : fprintf ( stderr , \"Streaming<S2SV_blank>Cache<S2SV_blank>Running\\\\n\" ) ; break ; } break ; case 'S' : case 'A' : if ( gf_term_get_option ( term , GF_OPT_MEDIA_CACHE ) == GF_MEDIA_CACHE_RUNNING ) { gf_term_set_option ( term , GF_OPT_MEDIA_CACHE , ( c == 'S' ) ? GF_MEDIA_CACHE_DISABLED : GF_MEDIA_CACHE_DISCARD ) ; fprintf ( stderr , \"Streaming<S2SV_blank>Cache<S2SV_blank>stopped\\\\n\" ) ; } else { fprintf ( stderr , \"Streaming<S2SV_blank>Cache<S2SV_blank>not<S2SV_blank>running\\\\n\" ) ; } break ; case 'R' : display_rti = ! display_rti ; ResetCaption ( ) ; break ; case 'F' : if ( display_rti ) display_rti = 0 ; else display_rti = 2 ; ResetCaption ( ) ; break ; case 'u' : { GF_Err e ; char szCom [ 8192 ] ; fprintf ( stderr , \"Enter<S2SV_blank>command<S2SV_blank>to<S2SV_blank>send:\\\\n\" ) ; fflush ( stdin ) ; szCom [ 0 ] = 0 ; if ( 1 > scanf ( \"%[^\\\\t\\\\n]\" , szCom ) ) { fprintf ( stderr , \"Cannot<S2SV_blank>read<S2SV_blank>command<S2SV_blank>to<S2SV_blank>send,<S2SV_blank>aborting.\\\\n\" ) ; break ; } e = gf_term_scene_update ( term , NULL , szCom ) ; if ( e ) fprintf ( stderr , \"Processing<S2SV_blank>command<S2SV_blank>failed:<S2SV_blank>%s\\\\n\" , gf_error_to_string ( e ) ) ; } break ; case 'e' : { GF_Err e ; char jsCode [ 8192 ] ; fprintf ( stderr , \"Enter<S2SV_blank>JavaScript<S2SV_blank>code<S2SV_blank>to<S2SV_blank>evaluate:\\\\n\" ) ; fflush ( stdin ) ; jsCode [ 0 ] = 0 ; if ( 1 > scanf ( \"%[^\\\\t\\\\n]\" , jsCode ) ) { fprintf ( stderr , \"Cannot<S2SV_blank>read<S2SV_blank>code<S2SV_blank>to<S2SV_blank>evaluate,<S2SV_blank>aborting.\\\\n\" ) ; break ; } e = gf_term_scene_update ( term , \"application/ecmascript\" , jsCode ) ; if ( e ) fprintf ( stderr , \"Processing<S2SV_blank>JS<S2SV_blank>code<S2SV_blank>failed:<S2SV_blank>%s\\\\n\" , gf_error_to_string ( e ) ) ; } break ; case 'L' : { char szLog [ 1024 ] , * cur_logs ; cur_logs = gf_log_get_tools_levels ( ) ; fprintf ( stderr , \"Enter<S2SV_blank>new<S2SV_blank>log<S2SV_blank>level<S2SV_blank>(current<S2SV_blank>tools<S2SV_blank>%s):\\\\n\" , cur_logs ) ; gf_free ( cur_logs ) ; if ( scanf ( \"%s\" , szLog ) < 1 ) { fprintf ( stderr , \"Cannot<S2SV_blank>read<S2SV_blank>new<S2SV_blank>log<S2SV_blank>level,<S2SV_blank>aborting.\\\\n\" ) ; break ; } gf_log_modify_tools_levels ( szLog ) ; } break ; case 'g' : { GF_SystemRTInfo rti ; gf_sys_get_rti ( rti_update_time_ms , & rti , 0 ) ; fprintf ( stderr , \"GPAC<S2SV_blank>allocated<S2SV_blank>memory<S2SV_blank>\" LLD \"\\\\n\" , rti . gpac_memory ) ; } break ; case 'M' : { u32 size ; do { fprintf ( stderr , \"Enter<S2SV_blank>new<S2SV_blank>video<S2SV_blank>cache<S2SV_blank>memory<S2SV_blank>in<S2SV_blank>kBytes<S2SV_blank>(current<S2SV_blank>%ud):\\\\n\" , gf_term_get_option ( term , GF_OPT_VIDEO_CACHE_SIZE ) ) ; } while ( 1 > scanf ( \"%ud\" , & size ) ) ; gf_term_set_option ( term , GF_OPT_VIDEO_CACHE_SIZE , size ) ; } break ; case 'H' : { u32 http_bitrate = gf_term_get_option ( term , GF_OPT_HTTP_MAX_RATE ) ; do { fprintf ( stderr , \"Enter<S2SV_blank>new<S2SV_blank>http<S2SV_blank>bitrate<S2SV_blank>in<S2SV_blank>bps<S2SV_blank>(0<S2SV_blank>for<S2SV_blank>none)<S2SV_blank>-<S2SV_blank>current<S2SV_blank>limit:<S2SV_blank>%d\\\\n\" , http_bitrate ) ; } while ( 1 > scanf ( \"%ud\" , & http_bitrate ) ) ; gf_term_set_option ( term , GF_OPT_HTTP_MAX_RATE , http_bitrate ) ; } break ; case 'E' : gf_term_set_option ( term , GF_OPT_RELOAD_CONFIG , 1 ) ; break ; case 'B' : switch_bench ( ! bench_mode ) ; break ; case 'Y' : { char szOpt [ 8192 ] ; fprintf ( stderr , \"Enter<S2SV_blank>option<S2SV_blank>to<S2SV_blank>set<S2SV_blank>(Section:Name=Value):\\\\n\" ) ; fflush ( stdin ) ; szOpt [ 0 ] = 0 ; if ( 1 > scanf ( \"%[^\\\\t\\\\n]\" , szOpt ) ) { fprintf ( stderr , \"Cannot<S2SV_blank>read<S2SV_blank>option\\\\n\" ) ; break ; } set_cfg_option ( szOpt ) ; } break ; case 'Z' : { char szFileName [ 100 ] ; u32 nb_pass , nb_views , offscreen_view = 0 ; GF_VideoSurface fb ; GF_Err e ; nb_pass = 1 ; nb_views = gf_term_get_option ( term , GF_OPT_NUM_STEREO_VIEWS ) ; if ( nb_views > 1 ) { fprintf ( stderr , \"Auto-stereo<S2SV_blank>mode<S2SV_blank>detected<S2SV_blank>-<S2SV_blank>type<S2SV_blank>number<S2SV_blank>of<S2SV_blank>view<S2SV_blank>to<S2SV_blank>dump<S2SV_blank>(0<S2SV_blank>is<S2SV_blank>main<S2SV_blank>output,<S2SV_blank>1<S2SV_blank>to<S2SV_blank>%d<S2SV_blank>offscreen<S2SV_blank>view,<S2SV_blank>%d<S2SV_blank>for<S2SV_blank>all<S2SV_blank>offscreen,<S2SV_blank>%d<S2SV_blank>for<S2SV_blank>all<S2SV_blank>offscreen<S2SV_blank>and<S2SV_blank>main)\\\\n\" , nb_views , nb_views + 1 , nb_views + 2 ) ; if ( scanf ( \"%d\" , & offscreen_view ) != 1 ) { offscreen_view = 0 ; } if ( offscreen_view == nb_views + 1 ) { offscreen_view = 1 ; nb_pass = nb_views ; } else if ( offscreen_view == nb_views + 2 ) { offscreen_view = 0 ; nb_pass = nb_views + 1 ; } } while ( nb_pass ) { nb_pass -- ; if ( offscreen_view ) { sprintf ( szFileName , \"view%d_dump.png\" , offscreen_view ) ; e = gf_term_get_offscreen_buffer ( term , & fb , offscreen_view - 1 , 0 ) ; } else { sprintf ( szFileName , \"gpac_video_dump_\" LLU \".png\" , gf_net_get_utc ( ) ) ; e = gf_term_get_screen_buffer ( term , & fb ) ; } offscreen_view ++ ; if ( e ) { fprintf ( stderr , \"Error<S2SV_blank>dumping<S2SV_blank>screen<S2SV_blank>buffer<S2SV_blank>%s\\\\n\" , gf_error_to_string ( e ) ) ; nb_pass = 0 ; } else { # ifndef GPAC_DISABLE_AV_PARSERS u32 dst_size = fb . width * fb . height * 4 ; char * dst = ( char * ) gf_malloc ( sizeof ( char ) * dst_size ) ; e = gf_img_png_enc ( fb . video_buffer , fb . width , fb . height , fb . pitch_y , fb . pixel_format , dst , & dst_size ) ; if ( e ) { fprintf ( stderr , \"Error<S2SV_blank>encoding<S2SV_blank>PNG<S2SV_blank>%s\\\\n\" , gf_error_to_string ( e ) ) ; nb_pass = 0 ; } else { FILE * png = gf_fopen ( szFileName , \"wb\" ) ; if ( ! png ) { fprintf ( stderr , \"Error<S2SV_blank>writing<S2SV_blank>file<S2SV_blank>%s\\\\n\" , szFileName ) ; nb_pass = 0 ; } else { gf_fwrite ( dst , dst_size , 1 , png ) ; gf_fclose ( png ) ; fprintf ( stderr , \"Dump<S2SV_blank>to<S2SV_blank>%s\\\\n\" , szFileName ) ; } } if ( dst ) gf_free ( dst ) ; gf_term_release_screen_buffer ( term , & fb ) ; # endif } } fprintf ( stderr , \"Done:<S2SV_blank>%s\\\\n\" , szFileName ) ; } break ; case 'G' : { GF_ObjectManager * root_od , * odm ; u32 index ; char szOpt [ 8192 ] ; fprintf ( stderr , \"Enter<S2SV_blank>0-based<S2SV_blank>index<S2SV_blank>of<S2SV_blank>object<S2SV_blank>to<S2SV_blank>select<S2SV_blank>or<S2SV_blank>service<S2SV_blank>ID:\\\\n\" ) ; fflush ( stdin ) ; szOpt [ 0 ] = 0 ; if ( 1 > scanf ( \"%[^\\\\t\\\\n]\" , szOpt ) ) { fprintf ( stderr , \"Cannot<S2SV_blank>read<S2SV_blank>OD<S2SV_blank>ID\\\\n\" ) ; break ; } index = atoi ( szOpt ) ; odm = NULL ; root_od = gf_term_get_root_object ( term ) ; if ( root_od ) { if ( gf_term_find_service ( term , root_od , index ) ) { gf_term_select_service ( term , root_od , index ) ; } else { fprintf ( stderr , \"Cannot<S2SV_blank>find<S2SV_blank>service<S2SV_blank>%d<S2SV_blank>-<S2SV_blank>trying<S2SV_blank>with<S2SV_blank>object<S2SV_blank>index\\\\n\" , index ) ; odm = gf_term_get_object ( term , root_od , index ) ; if ( odm ) { gf_term_select_object ( term , odm ) ; } else { fprintf ( stderr , \"Cannot<S2SV_blank>find<S2SV_blank>object<S2SV_blank>at<S2SV_blank>index<S2SV_blank>%d\\\\n\" , index ) ; } } } } break ; case 'h' : PrintHelp ( ) ; break ; default : break ; } } if ( bench_mode ) { PrintAVInfo ( GF_TRUE ) ; } if ( simulation_time_in_ms ) { gf_log_set_strict_error ( 0 ) ; } i = gf_sys_clock ( ) ; gf_term_disconnect ( term ) ; if ( rti_file ) UpdateRTInfo ( \"Disconnected\\\\n\" ) ; fprintf ( stderr , \"Deleting<S2SV_blank>terminal...<S2SV_blank>\" ) ; if ( playlist ) gf_fclose ( playlist ) ; # if defined ( __DARWIN__ ) || defined ( __APPLE__ ) carbon_uninit ( ) ; # endif gf_term_del ( term ) ; fprintf ( stderr , \"done<S2SV_blank>(in<S2SV_blank>%d<S2SV_blank>ms)<S2SV_blank>-<S2SV_blank>ran<S2SV_blank>for<S2SV_blank>%d<S2SV_blank>ms\\\\n\" , gf_sys_clock ( ) - i , gf_sys_clock ( ) ) ; fprintf ( stderr , \"GPAC<S2SV_blank>cleanup<S2SV_blank>...\\\\n\" ) ; gf_modules_del ( user . modules ) ; if ( no_cfg_save ) gf_cfg_discard_changes ( cfg_file ) ; gf_cfg_del ( cfg_file ) ; gf_sys_close ( ) ; if ( rti_logs ) gf_fclose ( rti_logs ) ; if ( logfile ) gf_fclose ( logfile ) ; if ( gui_mode ) { hide_shell ( 2 ) ; } # ifdef GPAC_MEMORY_TRACKING if ( mem_track && ( gf_memory_size ( ) || gf_file_handles_count ( ) ) ) { gf_log_set_tool_level ( GF_LOG_MEMORY , GF_LOG_INFO ) ; gf_memory_print ( ) ; return 2 ; } # endif return ret_val ; }\n",
      "fixed_code": "<S2SV_ModStart> [ sizeof ( the_url <S2SV_ModEnd> ) - 1\n",
      "source_code_length": 37793,
      "target_code_length": 55,
      "vulnerability_patterns": {
        "buffer_overflow": 14,
        "use_after_free": 4,
        "integer_overflow": 41,
        "format_string": 90,
        "null_pointer": 28,
        "sql_injection": 1,
        "total": 178
      },
      "total_patterns": 178,
      "original_address": "https://github.com/gpac/gpac/commit/1c449a34fe0b50aaffb881bfb9d7c5ab0bb18cdd",
      "discovery_time": "2019-02-06T23:29Z",
      "project_commit_id": "gpac@gpac/1c449a34fe0b50aaffb881bfb9d7c5ab0bb18cdd",
      "extraction_time": "2025-08-31T15:41:49.178058",
      "label": 1,
      "vulnerability_type": "out-of-bounds_write",
      "difficulty_level": "expert",
      "risk_factors": [
        "memory_corruption",
        "sql_injection",
        "arbitrary_code_execution",
        "buffer_overflow",
        "system_crash",
        "use_after_free"
      ],
      "attack_vectors": [
        "memory_manipulation",
        "malicious_input",
        "code_analysis",
        "buffer_overflow",
        "reverse_engineering",
        "fuzzing"
      ],
      "mitigation_strategies": [
        "safe_string_functions",
        "dynamic_analysis",
        "code_review",
        "static_analysis",
        "memory_safety_checks",
        "input_validation",
        "fuzzing",
        "bounds_checking",
        "secure_coding_practices"
      ],
      "code_differences": {
        "has_differences": true,
        "source_lines": 2,
        "target_lines": 2,
        "character_differences": 37738,
        "similarity_percentage": 1.0189228529839884
      },
      "vulnerability_location": {
        "vulnerability_present": true,
        "fix_applied": true,
        "code_changed": true,
        "estimated_lines_changed": 0
      }
    },
    {
      "cve_id": "CVE-2016-5842",
      "cwe_id": "CWE-125",
      "cwe_name": "Out-of-bounds Read",
      "project": "ImageMagick",
      "severity": "critical",
      "weaponization_score": 10.0,
      "is_critical": true,
      "is_weaponizable": true,
      "is_high_priority_project": true,
      "vulnerable_code": "CWE-125 static MagickBooleanType GetEXIFProperty ( const Image * image , const char * property , ExceptionInfo * exception ) { # define MaxDirectoryStack 16 # define EXIF_DELIMITER \"\\\\n\" # define EXIF_NUM_FORMATS 12 # define EXIF_FMT_BYTE 1 # define EXIF_FMT_STRING 2 # define EXIF_FMT_USHORT 3 # define EXIF_FMT_ULONG 4 # define EXIF_FMT_URATIONAL 5 # define EXIF_FMT_SBYTE 6 # define EXIF_FMT_UNDEFINED 7 # define EXIF_FMT_SSHORT 8 # define EXIF_FMT_SLONG 9 # define EXIF_FMT_SRATIONAL 10 # define EXIF_FMT_SINGLE 11 # define EXIF_FMT_DOUBLE 12 # define TAG_EXIF_OFFSET 0x8769 # define TAG_GPS_OFFSET 0x8825 # define TAG_INTEROP_OFFSET 0xa005 <S2SV_StartBug> # define EXIFMultipleValues ( size , format , arg ) { ssize_t component ; size_t length ; unsigned char * p1 ; length = 0 ; p1 = p ; for ( component = 0 ; component < components ; component ++ ) { length += FormatLocaleString ( buffer + length , MagickPathExtent - length , format \",<S2SV_blank>\" , arg ) ; if ( length >= ( MagickPathExtent - 1 ) ) length = MagickPathExtent - 1 ; p1 += size ; } if ( length > 1 ) buffer [ length - 2 ] = '\\\\0' ; value = AcquireString ( buffer ) ; } <S2SV_EndBug> <S2SV_StartBug> # define EXIFMultipleFractions ( size , format , arg1 , arg2 ) { ssize_t component ; size_t length ; unsigned char * p1 ; length = 0 ; p1 = p ; for ( component = 0 ; component < components ; component ++ ) { length += FormatLocaleString ( buffer + length , MagickPathExtent - length , format \",<S2SV_blank>\" , ( arg1 ) , ( arg2 ) ) ; if ( length >= ( MagickPathExtent - 1 ) ) length = MagickPathExtent - 1 ; p1 += size ; } if ( length > 1 ) buffer [ length - 2 ] = '\\\\0' ; value = AcquireString ( buffer ) ; } <S2SV_EndBug> typedef struct _DirectoryInfo { const unsigned char * directory ; size_t entry ; ssize_t offset ; } DirectoryInfo ; typedef struct _TagInfo { size_t tag ; const char * description ; } TagInfo ; static TagInfo EXIFTag [ ] = { { 0x001 , \"exif:InteroperabilityIndex\" } , { 0x002 , \"exif:InteroperabilityVersion\" } , { 0x100 , \"exif:ImageWidth\" } , { 0x101 , \"exif:ImageLength\" } , { 0x102 , \"exif:BitsPerSample\" } , { 0x103 , \"exif:Compression\" } , { 0x106 , \"exif:PhotometricInterpretation\" } , { 0x10a , \"exif:FillOrder\" } , { 0x10d , \"exif:DocumentName\" } , { 0x10e , \"exif:ImageDescription\" } , { 0x10f , \"exif:Make\" } , { 0x110 , \"exif:Model\" } , { 0x111 , \"exif:StripOffsets\" } , { 0x112 , \"exif:Orientation\" } , { 0x115 , \"exif:SamplesPerPixel\" } , { 0x116 , \"exif:RowsPerStrip\" } , { 0x117 , \"exif:StripByteCounts\" } , { 0x11a , \"exif:XResolution\" } , { 0x11b , \"exif:YResolution\" } , { 0x11c , \"exif:PlanarConfiguration\" } , { 0x11d , \"exif:PageName\" } , { 0x11e , \"exif:XPosition\" } , { 0x11f , \"exif:YPosition\" } , { 0x118 , \"exif:MinSampleValue\" } , { 0x119 , \"exif:MaxSampleValue\" } , { 0x120 , \"exif:FreeOffsets\" } , { 0x121 , \"exif:FreeByteCounts\" } , { 0x122 , \"exif:GrayResponseUnit\" } , { 0x123 , \"exif:GrayResponseCurve\" } , { 0x124 , \"exif:T4Options\" } , { 0x125 , \"exif:T6Options\" } , { 0x128 , \"exif:ResolutionUnit\" } , { 0x12d , \"exif:TransferFunction\" } , { 0x131 , \"exif:Software\" } , { 0x132 , \"exif:DateTime\" } , { 0x13b , \"exif:Artist\" } , { 0x13e , \"exif:WhitePoint\" } , { 0x13f , \"exif:PrimaryChromaticities\" } , { 0x140 , \"exif:ColorMap\" } , { 0x141 , \"exif:HalfToneHints\" } , { 0x142 , \"exif:TileWidth\" } , { 0x143 , \"exif:TileLength\" } , { 0x144 , \"exif:TileOffsets\" } , { 0x145 , \"exif:TileByteCounts\" } , { 0x14a , \"exif:SubIFD\" } , { 0x14c , \"exif:InkSet\" } , { 0x14d , \"exif:InkNames\" } , { 0x14e , \"exif:NumberOfInks\" } , { 0x150 , \"exif:DotRange\" } , { 0x151 , \"exif:TargetPrinter\" } , { 0x152 , \"exif:ExtraSample\" } , { 0x153 , \"exif:SampleFormat\" } , { 0x154 , \"exif:SMinSampleValue\" } , { 0x155 , \"exif:SMaxSampleValue\" } , { 0x156 , \"exif:TransferRange\" } , { 0x157 , \"exif:ClipPath\" } , { 0x158 , \"exif:XClipPathUnits\" } , { 0x159 , \"exif:YClipPathUnits\" } , { 0x15a , \"exif:Indexed\" } , { 0x15b , \"exif:JPEGTables\" } , { 0x15f , \"exif:OPIProxy\" } , { 0x200 , \"exif:JPEGProc\" } , { 0x201 , \"exif:JPEGInterchangeFormat\" } , { 0x202 , \"exif:JPEGInterchangeFormatLength\" } , { 0x203 , \"exif:JPEGRestartInterval\" } , { 0x205 , \"exif:JPEGLosslessPredictors\" } , { 0x206 , \"exif:JPEGPointTransforms\" } , { 0x207 , \"exif:JPEGQTables\" } , { 0x208 , \"exif:JPEGDCTables\" } , { 0x209 , \"exif:JPEGACTables\" } , { 0x211 , \"exif:YCbCrCoefficients\" } , { 0x212 , \"exif:YCbCrSubSampling\" } , { 0x213 , \"exif:YCbCrPositioning\" } , { 0x214 , \"exif:ReferenceBlackWhite\" } , { 0x2bc , \"exif:ExtensibleMetadataPlatform\" } , { 0x301 , \"exif:Gamma\" } , { 0x302 , \"exif:ICCProfileDescriptor\" } , { 0x303 , \"exif:SRGBRenderingIntent\" } , { 0x320 , \"exif:ImageTitle\" } , { 0x5001 , \"exif:ResolutionXUnit\" } , { 0x5002 , \"exif:ResolutionYUnit\" } , { 0x5003 , \"exif:ResolutionXLengthUnit\" } , { 0x5004 , \"exif:ResolutionYLengthUnit\" } , { 0x5005 , \"exif:PrintFlags\" } , { 0x5006 , \"exif:PrintFlagsVersion\" } , { 0x5007 , \"exif:PrintFlagsCrop\" } , { 0x5008 , \"exif:PrintFlagsBleedWidth\" } , { 0x5009 , \"exif:PrintFlagsBleedWidthScale\" } , { 0x500A , \"exif:HalftoneLPI\" } , { 0x500B , \"exif:HalftoneLPIUnit\" } , { 0x500C , \"exif:HalftoneDegree\" } , { 0x500D , \"exif:HalftoneShape\" } , { 0x500E , \"exif:HalftoneMisc\" } , { 0x500F , \"exif:HalftoneScreen\" } , { 0x5010 , \"exif:JPEGQuality\" } , { 0x5011 , \"exif:GridSize\" } , { 0x5012 , \"exif:ThumbnailFormat\" } , { 0x5013 , \"exif:ThumbnailWidth\" } , { 0x5014 , \"exif:ThumbnailHeight\" } , { 0x5015 , \"exif:ThumbnailColorDepth\" } , { 0x5016 , \"exif:ThumbnailPlanes\" } , { 0x5017 , \"exif:ThumbnailRawBytes\" } , { 0x5018 , \"exif:ThumbnailSize\" } , { 0x5019 , \"exif:ThumbnailCompressedSize\" } , { 0x501a , \"exif:ColorTransferFunction\" } , { 0x501b , \"exif:ThumbnailData\" } , { 0x5020 , \"exif:ThumbnailImageWidth\" } , { 0x5021 , \"exif:ThumbnailImageHeight\" } , { 0x5022 , \"exif:ThumbnailBitsPerSample\" } , { 0x5023 , \"exif:ThumbnailCompression\" } , { 0x5024 , \"exif:ThumbnailPhotometricInterp\" } , { 0x5025 , \"exif:ThumbnailImageDescription\" } , { 0x5026 , \"exif:ThumbnailEquipMake\" } , { 0x5027 , \"exif:ThumbnailEquipModel\" } , { 0x5028 , \"exif:ThumbnailStripOffsets\" } , { 0x5029 , \"exif:ThumbnailOrientation\" } , { 0x502a , \"exif:ThumbnailSamplesPerPixel\" } , { 0x502b , \"exif:ThumbnailRowsPerStrip\" } , { 0x502c , \"exif:ThumbnailStripBytesCount\" } , { 0x502d , \"exif:ThumbnailResolutionX\" } , { 0x502e , \"exif:ThumbnailResolutionY\" } , { 0x502f , \"exif:ThumbnailPlanarConfig\" } , { 0x5030 , \"exif:ThumbnailResolutionUnit\" } , { 0x5031 , \"exif:ThumbnailTransferFunction\" } , { 0x5032 , \"exif:ThumbnailSoftwareUsed\" } , { 0x5033 , \"exif:ThumbnailDateTime\" } , { 0x5034 , \"exif:ThumbnailArtist\" } , { 0x5035 , \"exif:ThumbnailWhitePoint\" } , { 0x5036 , \"exif:ThumbnailPrimaryChromaticities\" } , { 0x5037 , \"exif:ThumbnailYCbCrCoefficients\" } , { 0x5038 , \"exif:ThumbnailYCbCrSubsampling\" } , { 0x5039 , \"exif:ThumbnailYCbCrPositioning\" } , { 0x503A , \"exif:ThumbnailRefBlackWhite\" } , { 0x503B , \"exif:ThumbnailCopyRight\" } , { 0x5090 , \"exif:LuminanceTable\" } , { 0x5091 , \"exif:ChrominanceTable\" } , { 0x5100 , \"exif:FrameDelay\" } , { 0x5101 , \"exif:LoopCount\" } , { 0x5110 , \"exif:PixelUnit\" } , { 0x5111 , \"exif:PixelPerUnitX\" } , { 0x5112 , \"exif:PixelPerUnitY\" } , { 0x5113 , \"exif:PaletteHistogram\" } , { 0x1000 , \"exif:RelatedImageFileFormat\" } , { 0x1001 , \"exif:RelatedImageLength\" } , { 0x1002 , \"exif:RelatedImageWidth\" } , { 0x800d , \"exif:ImageID\" } , { 0x80e3 , \"exif:Matteing\" } , { 0x80e4 , \"exif:DataType\" } , { 0x80e5 , \"exif:ImageDepth\" } , { 0x80e6 , \"exif:TileDepth\" } , { 0x828d , \"exif:CFARepeatPatternDim\" } , { 0x828e , \"exif:CFAPattern2\" } , { 0x828f , \"exif:BatteryLevel\" } , { 0x8298 , \"exif:Copyright\" } , { 0x829a , \"exif:ExposureTime\" } , { 0x829d , \"exif:FNumber\" } , { 0x83bb , \"exif:IPTC/NAA\" } , { 0x84e3 , \"exif:IT8RasterPadding\" } , { 0x84e5 , \"exif:IT8ColorTable\" } , { 0x8649 , \"exif:ImageResourceInformation\" } , { 0x8769 , \"exif:ExifOffset\" } , { 0x8773 , \"exif:InterColorProfile\" } , { 0x8822 , \"exif:ExposureProgram\" } , { 0x8824 , \"exif:SpectralSensitivity\" } , { 0x8825 , \"exif:GPSInfo\" } , { 0x8827 , \"exif:ISOSpeedRatings\" } , { 0x8828 , \"exif:OECF\" } , { 0x8829 , \"exif:Interlace\" } , { 0x882a , \"exif:TimeZoneOffset\" } , { 0x882b , \"exif:SelfTimerMode\" } , { 0x9000 , \"exif:ExifVersion\" } , { 0x9003 , \"exif:DateTimeOriginal\" } , { 0x9004 , \"exif:DateTimeDigitized\" } , { 0x9101 , \"exif:ComponentsConfiguration\" } , { 0x9102 , \"exif:CompressedBitsPerPixel\" } , { 0x9201 , \"exif:ShutterSpeedValue\" } , { 0x9202 , \"exif:ApertureValue\" } , { 0x9203 , \"exif:BrightnessValue\" } , { 0x9204 , \"exif:ExposureBiasValue\" } , { 0x9205 , \"exif:MaxApertureValue\" } , { 0x9206 , \"exif:SubjectDistance\" } , { 0x9207 , \"exif:MeteringMode\" } , { 0x9208 , \"exif:LightSource\" } , { 0x9209 , \"exif:Flash\" } , { 0x920a , \"exif:FocalLength\" } , { 0x920b , \"exif:FlashEnergy\" } , { 0x920c , \"exif:SpatialFrequencyResponse\" } , { 0x920d , \"exif:Noise\" } , { 0x9211 , \"exif:ImageNumber\" } , { 0x9212 , \"exif:SecurityClassification\" } , { 0x9213 , \"exif:ImageHistory\" } , { 0x9214 , \"exif:SubjectArea\" } , { 0x9215 , \"exif:ExposureIndex\" } , { 0x9216 , \"exif:TIFF-EPStandardID\" } , { 0x927c , \"exif:MakerNote\" } , { 0x9C9b , \"exif:WinXP-Title\" } , { 0x9C9c , \"exif:WinXP-Comments\" } , { 0x9C9d , \"exif:WinXP-Author\" } , { 0x9C9e , \"exif:WinXP-Keywords\" } , { 0x9C9f , \"exif:WinXP-Subject\" } , { 0x9286 , \"exif:UserComment\" } , { 0x9290 , \"exif:SubSecTime\" } , { 0x9291 , \"exif:SubSecTimeOriginal\" } , { 0x9292 , \"exif:SubSecTimeDigitized\" } , { 0xa000 , \"exif:FlashPixVersion\" } , { 0xa001 , \"exif:ColorSpace\" } , { 0xa002 , \"exif:ExifImageWidth\" } , { 0xa003 , \"exif:ExifImageLength\" } , { 0xa004 , \"exif:RelatedSoundFile\" } , { 0xa005 , \"exif:InteroperabilityOffset\" } , { 0xa20b , \"exif:FlashEnergy\" } , { 0xa20c , \"exif:SpatialFrequencyResponse\" } , { 0xa20d , \"exif:Noise\" } , { 0xa20e , \"exif:FocalPlaneXResolution\" } , { 0xa20f , \"exif:FocalPlaneYResolution\" } , { 0xa210 , \"exif:FocalPlaneResolutionUnit\" } , { 0xa214 , \"exif:SubjectLocation\" } , { 0xa215 , \"exif:ExposureIndex\" } , { 0xa216 , \"exif:TIFF/EPStandardID\" } , { 0xa217 , \"exif:SensingMethod\" } , { 0xa300 , \"exif:FileSource\" } , { 0xa301 , \"exif:SceneType\" } , { 0xa302 , \"exif:CFAPattern\" } , { 0xa401 , \"exif:CustomRendered\" } , { 0xa402 , \"exif:ExposureMode\" } , { 0xa403 , \"exif:WhiteBalance\" } , { 0xa404 , \"exif:DigitalZoomRatio\" } , { 0xa405 , \"exif:FocalLengthIn35mmFilm\" } , { 0xa406 , \"exif:SceneCaptureType\" } , { 0xa407 , \"exif:GainControl\" } , { 0xa408 , \"exif:Contrast\" } , { 0xa409 , \"exif:Saturation\" } , { 0xa40a , \"exif:Sharpness\" } , { 0xa40b , \"exif:DeviceSettingDescription\" } , { 0xa40c , \"exif:SubjectDistanceRange\" } , { 0xa420 , \"exif:ImageUniqueID\" } , { 0xc4a5 , \"exif:PrintImageMatching\" } , { 0xa500 , \"exif:Gamma\" } , { 0xc640 , \"exif:CR2Slice\" } , { 0x10000 , \"exif:GPSVersionID\" } , { 0x10001 , \"exif:GPSLatitudeRef\" } , { 0x10002 , \"exif:GPSLatitude\" } , { 0x10003 , \"exif:GPSLongitudeRef\" } , { 0x10004 , \"exif:GPSLongitude\" } , { 0x10005 , \"exif:GPSAltitudeRef\" } , { 0x10006 , \"exif:GPSAltitude\" } , { 0x10007 , \"exif:GPSTimeStamp\" } , { 0x10008 , \"exif:GPSSatellites\" } , { 0x10009 , \"exif:GPSStatus\" } , { 0x1000a , \"exif:GPSMeasureMode\" } , { 0x1000b , \"exif:GPSDop\" } , { 0x1000c , \"exif:GPSSpeedRef\" } , { 0x1000d , \"exif:GPSSpeed\" } , { 0x1000e , \"exif:GPSTrackRef\" } , { 0x1000f , \"exif:GPSTrack\" } , { 0x10010 , \"exif:GPSImgDirectionRef\" } , { 0x10011 , \"exif:GPSImgDirection\" } , { 0x10012 , \"exif:GPSMapDatum\" } , { 0x10013 , \"exif:GPSDestLatitudeRef\" } , { 0x10014 , \"exif:GPSDestLatitude\" } , { 0x10015 , \"exif:GPSDestLongitudeRef\" } , { 0x10016 , \"exif:GPSDestLongitude\" } , { 0x10017 , \"exif:GPSDestBearingRef\" } , { 0x10018 , \"exif:GPSDestBearing\" } , { 0x10019 , \"exif:GPSDestDistanceRef\" } , { 0x1001a , \"exif:GPSDestDistance\" } , { 0x1001b , \"exif:GPSProcessingMethod\" } , { 0x1001c , \"exif:GPSAreaInformation\" } , { 0x1001d , \"exif:GPSDateStamp\" } , { 0x1001e , \"exif:GPSDifferential\" } , { 0x00000 , ( const char * ) NULL } } ; const StringInfo * profile ; const unsigned char * directory , * exif ; DirectoryInfo directory_stack [ MaxDirectoryStack ] ; EndianType endian ; MagickBooleanType status ; register ssize_t i ; size_t entry , length , number_entries , tag , tag_value ; SplayTreeInfo * exif_resources ; ssize_t all , id , level , offset , tag_offset ; static int tag_bytes [ ] = { 0 , 1 , 1 , 2 , 4 , 8 , 1 , 1 , 2 , 4 , 8 , 4 , 8 } ; profile = GetImageProfile ( image , \"exif\" ) ; if ( profile == ( const StringInfo * ) NULL ) return ( MagickFalse ) ; if ( ( property == ( const char * ) NULL ) || ( * property == '\\\\0' ) ) return ( MagickFalse ) ; while ( isspace ( ( int ) ( ( unsigned char ) * property ) ) != 0 ) property ++ ; if ( strlen ( property ) <= 5 ) return ( MagickFalse ) ; all = 0 ; tag = ( ~ 0UL ) ; switch ( * ( property + 5 ) ) { case '*' : { tag = 0 ; all = 1 ; break ; } case '!' : { tag = 0 ; all = 2 ; break ; } case '#' : case '@' : { int c ; size_t n ; tag = ( * ( property + 5 ) == '@' ) ? 1UL : 0UL ; property += 6 ; n = strlen ( property ) ; if ( n != 4 ) return ( MagickFalse ) ; n /= 4 ; do { for ( i = ( ssize_t ) n - 1L ; i >= 0 ; i -- ) { c = ( * property ++ ) ; tag <<= 4 ; if ( ( c >= '0' ) && ( c <= '9' ) ) tag |= ( c - '0' ) ; else if ( ( c >= 'A' ) && ( c <= 'F' ) ) tag |= ( c - ( 'A' - 10 ) ) ; else if ( ( c >= 'a' ) && ( c <= 'f' ) ) tag |= ( c - ( 'a' - 10 ) ) ; else return ( MagickFalse ) ; } } while ( * property != '\\\\0' ) ; break ; } default : { for ( i = 0 ; ; i ++ ) { if ( EXIFTag [ i ] . tag == 0 ) break ; if ( LocaleCompare ( EXIFTag [ i ] . description , property ) == 0 ) { tag = ( size_t ) EXIFTag [ i ] . tag ; break ; } } break ; } } if ( tag == ( ~ 0UL ) ) return ( MagickFalse ) ; length = GetStringInfoLength ( profile ) ; exif = GetStringInfoDatum ( profile ) ; while ( length != 0 ) { if ( ReadPropertyByte ( & exif , & length ) != 0x45 ) continue ; if ( ReadPropertyByte ( & exif , & length ) != 0x78 ) continue ; if ( ReadPropertyByte ( & exif , & length ) != 0x69 ) continue ; if ( ReadPropertyByte ( & exif , & length ) != 0x66 ) continue ; if ( ReadPropertyByte ( & exif , & length ) != 0x00 ) continue ; if ( ReadPropertyByte ( & exif , & length ) != 0x00 ) continue ; break ; } if ( length < 16 ) return ( MagickFalse ) ; id = ( ssize_t ) ReadPropertySignedShort ( LSBEndian , exif ) ; endian = LSBEndian ; if ( id == 0x4949 ) endian = LSBEndian ; else if ( id == 0x4D4D ) endian = MSBEndian ; else return ( MagickFalse ) ; if ( ReadPropertyUnsignedShort ( endian , exif + 2 ) != 0x002a ) return ( MagickFalse ) ; offset = ( ssize_t ) ReadPropertySignedLong ( endian , exif + 4 ) ; if ( ( offset < 0 ) || ( size_t ) offset >= length ) return ( MagickFalse ) ; status = MagickFalse ; directory = exif + offset ; level = 0 ; entry = 0 ; tag_offset = 0 ; exif_resources = NewSplayTree ( ( int ( * ) ( const void * , const void * ) ) NULL , ( void * ( * ) ( void * ) ) NULL , ( void * ( * ) ( void * ) ) NULL ) ; do { if ( level > 0 ) { level -- ; directory = directory_stack [ level ] . directory ; entry = directory_stack [ level ] . entry ; tag_offset = directory_stack [ level ] . offset ; } if ( ( directory < exif ) || ( directory > ( exif + length - 2 ) ) ) break ; number_entries = ( size_t ) ReadPropertyUnsignedShort ( endian , directory ) ; for ( ; entry < number_entries ; entry ++ ) { register unsigned char * p , * q ; size_t format ; ssize_t number_bytes , components ; q = ( unsigned char * ) ( directory + ( 12 * entry ) + 2 ) ; <S2SV_StartBug> if ( GetValueFromSplayTree ( exif_resources , q ) == q ) <S2SV_EndBug> break ; ( void ) AddValueToSplayTree ( exif_resources , q , q ) ; tag_value = ( size_t ) ReadPropertyUnsignedShort ( endian , q ) + tag_offset ; format = ( size_t ) ReadPropertyUnsignedShort ( endian , q + 2 ) ; if ( format >= ( sizeof ( tag_bytes ) / sizeof ( * tag_bytes ) ) ) break ; <S2SV_StartBug> components = ( ssize_t ) ReadPropertySignedLong ( endian , q + 4 ) ; <S2SV_EndBug> number_bytes = ( size_t ) components * tag_bytes [ format ] ; if ( number_bytes < components ) break ; if ( number_bytes <= 4 ) p = q + 8 ; else { ssize_t offset ; offset = ( ssize_t ) ReadPropertySignedLong ( endian , q + 8 ) ; if ( ( offset < 0 ) || ( size_t ) offset >= length ) continue ; if ( ( ssize_t ) ( offset + number_bytes ) < offset ) continue ; if ( ( size_t ) ( offset + number_bytes ) > length ) continue ; p = ( unsigned char * ) ( exif + offset ) ; } if ( ( all != 0 ) || ( tag == ( size_t ) tag_value ) ) { char buffer [ MagickPathExtent ] , * value ; value = ( char * ) NULL ; * buffer = '\\\\0' ; switch ( format ) { case EXIF_FMT_BYTE : case EXIF_FMT_UNDEFINED : { EXIFMultipleValues ( 1 , \"%.20g\" , ( double ) ( * ( unsigned char * ) p1 ) ) ; break ; } case EXIF_FMT_SBYTE : { EXIFMultipleValues ( 1 , \"%.20g\" , ( double ) ( * ( signed char * ) p1 ) ) ; break ; } case EXIF_FMT_SSHORT : { EXIFMultipleValues ( 2 , \"%hd\" , ReadPropertySignedShort ( endian , p1 ) ) ; break ; } case EXIF_FMT_USHORT : { EXIFMultipleValues ( 2 , \"%hu\" , ReadPropertyUnsignedShort ( endian , p1 ) ) ; break ; } case EXIF_FMT_ULONG : { EXIFMultipleValues ( 4 , \"%.20g\" , ( double ) ReadPropertyUnsignedLong ( endian , p1 ) ) ; break ; } case EXIF_FMT_SLONG : { EXIFMultipleValues ( 4 , \"%.20g\" , ( double ) ReadPropertySignedLong ( endian , p1 ) ) ; break ; } case EXIF_FMT_URATIONAL : { EXIFMultipleFractions ( 8 , \"%.20g/%.20g\" , ( double ) ReadPropertyUnsignedLong ( endian , p1 ) , ( double ) ReadPropertyUnsignedLong ( endian , p1 + 4 ) ) ; break ; } case EXIF_FMT_SRATIONAL : { EXIFMultipleFractions ( 8 , \"%.20g/%.20g\" , ( double ) ReadPropertySignedLong ( endian , p1 ) , ( double ) ReadPropertySignedLong ( endian , p1 + 4 ) ) ; break ; } case EXIF_FMT_SINGLE : { EXIFMultipleValues ( 4 , \"%f\" , ( double ) * ( float * ) p1 ) ; break ; } case EXIF_FMT_DOUBLE : { EXIFMultipleValues ( 8 , \"%f\" , * ( double * ) p1 ) ; break ; } default : case EXIF_FMT_STRING : { value = ( char * ) NULL ; if ( ~ ( ( size_t ) number_bytes ) >= 1 ) value = ( char * ) AcquireQuantumMemory ( ( size_t ) number_bytes + 1UL , sizeof ( * value ) ) ; if ( value != ( char * ) NULL ) { register ssize_t i ; for ( i = 0 ; i < ( ssize_t ) number_bytes ; i ++ ) { value [ i ] = '.' ; if ( ( isprint ( ( int ) p [ i ] ) != 0 ) || ( p [ i ] == '\\\\0' ) ) value [ i ] = ( char ) p [ i ] ; } value [ i ] = '\\\\0' ; } break ; } } if ( value != ( char * ) NULL ) { char * key ; register const char * p ; key = AcquireString ( property ) ; switch ( all ) { case 1 : { const char * description ; register ssize_t i ; description = \"unknown\" ; for ( i = 0 ; ; i ++ ) { if ( EXIFTag [ i ] . tag == 0 ) break ; if ( EXIFTag [ i ] . tag == tag_value ) { description = EXIFTag [ i ] . description ; break ; } } ( void ) FormatLocaleString ( key , MagickPathExtent , \"%s\" , description ) ; if ( level == 2 ) ( void ) SubstituteString ( & key , \"exif:\" , \"exif:thumbnail:\" ) ; break ; } case 2 : { if ( tag_value < 0x10000 ) ( void ) FormatLocaleString ( key , MagickPathExtent , \"#%04lx\" , ( unsigned long ) tag_value ) ; else if ( tag_value < 0x20000 ) ( void ) FormatLocaleString ( key , MagickPathExtent , \"@%04lx\" , ( unsigned long ) ( tag_value & 0xffff ) ) ; else ( void ) FormatLocaleString ( key , MagickPathExtent , \"unknown\" ) ; break ; } default : { if ( level == 2 ) ( void ) SubstituteString ( & key , \"exif:\" , \"exif:thumbnail:\" ) ; } } p = ( const char * ) NULL ; if ( image -> properties != ( void * ) NULL ) p = ( const char * ) GetValueFromSplayTree ( ( SplayTreeInfo * ) image -> properties , key ) ; if ( p == ( const char * ) NULL ) ( void ) SetImageProperty ( ( Image * ) image , key , value , exception ) ; value = DestroyString ( value ) ; key = DestroyString ( key ) ; status = MagickTrue ; } } if ( ( tag_value == TAG_EXIF_OFFSET ) || ( tag_value == TAG_INTEROP_OFFSET ) || ( tag_value == TAG_GPS_OFFSET ) ) { ssize_t offset ; offset = ( ssize_t ) ReadPropertySignedLong ( endian , p ) ; if ( ( ( size_t ) offset < length ) && ( level < ( MaxDirectoryStack - 2 ) ) ) { ssize_t tag_offset1 ; tag_offset1 = ( ssize_t ) ( ( tag_value == TAG_GPS_OFFSET ) ? 0x10000 : 0 ) ; directory_stack [ level ] . directory = directory ; entry ++ ; directory_stack [ level ] . entry = entry ; directory_stack [ level ] . offset = tag_offset ; level ++ ; directory_stack [ level ] . directory = exif + offset ; directory_stack [ level ] . offset = tag_offset1 ; directory_stack [ level ] . entry = 0 ; level ++ ; if ( ( directory + 2 + ( 12 * number_entries ) ) > ( exif + length ) ) break ; offset = ( ssize_t ) ReadPropertySignedLong ( endian , directory + 2 + ( 12 * number_entries ) ) ; if ( ( offset != 0 ) && ( ( size_t ) offset < length ) && ( level < ( MaxDirectoryStack - 2 ) ) ) { directory_stack [ level ] . directory = exif + offset ; directory_stack [ level ] . entry = 0 ; directory_stack [ level ] . offset = tag_offset1 ; level ++ ; } } break ; } } } while ( level > 0 ) ; exif_resources = DestroySplayTree ( exif_resources ) ; return ( status ) ; }\n",
      "fixed_code": "<S2SV_ModStart> , arg ) \\\\\\n{ <S2SV_ModEnd> ssize_t component ; <S2SV_ModStart> buffer ) ; \\\\\\n} <S2SV_ModEnd> # define EXIFMultipleFractions <S2SV_ModStart> , arg2 ) \\\\\\n{ <S2SV_ModEnd> ssize_t component ; <S2SV_ModStart> buffer ) ; \\\\\\n} <S2SV_ModEnd> typedef struct _DirectoryInfo <S2SV_ModStart> ; if ( q > ( exif + length - 12 ) ) break ; if ( <S2SV_ModStart> + 4 ) ; if ( components < 0 ) break\n",
      "source_code_length": 21036,
      "target_code_length": 401,
      "vulnerability_patterns": {
        "use_after_free": 1,
        "integer_overflow": 20,
        "null_pointer": 2,
        "total": 23
      },
      "total_patterns": 23,
      "original_address": "https://github.com/ImageMagick/ImageMagick/commit/d8ab7f046587f2e9f734b687ba7e6e10147c294b",
      "discovery_time": "2016-12-13T15:59Z",
      "project_commit_id": "ImageMagick@ImageMagick/d8ab7f046587f2e9f734b687ba7e6e10147c294b",
      "extraction_time": "2025-08-31T15:41:49.178325",
      "label": 1,
      "vulnerability_type": "out-of-bounds_read",
      "difficulty_level": "expert",
      "risk_factors": [
        "memory_corruption",
        "critical_infrastructure",
        "information_disclosure",
        "use_after_free",
        "integer_overflow"
      ],
      "attack_vectors": [
        "memory_manipulation",
        "malicious_input",
        "code_analysis",
        "buffer_overflow",
        "reverse_engineering",
        "fuzzing"
      ],
      "mitigation_strategies": [
        "safe_string_functions",
        "dynamic_analysis",
        "code_review",
        "static_analysis",
        "memory_safety_checks",
        "input_validation",
        "fuzzing",
        "bounds_checking",
        "secure_coding_practices"
      ],
      "code_differences": {
        "has_differences": true,
        "source_lines": 2,
        "target_lines": 2,
        "character_differences": 20635,
        "similarity_percentage": 3.689064558629776
      },
      "vulnerability_location": {
        "vulnerability_present": true,
        "fix_applied": true,
        "code_changed": true,
        "estimated_lines_changed": 0
      }
    },
    {
      "cve_id": "CVE-2015-0206",
      "cwe_id": "CWE-119",
      "cwe_name": "Buffer Overflow",
      "project": "openssl",
      "severity": "critical",
      "weaponization_score": 10.0,
      "is_critical": true,
      "is_weaponizable": true,
      "is_high_priority_project": true,
      "vulnerable_code": "CWE-119 int dtls1_read_bytes ( SSL * s , int type , unsigned char * buf , int len , int peek ) { int al , i , j , ret ; unsigned int n ; SSL3_RECORD * rr ; void ( * cb ) ( const SSL * ssl , int type2 , int val ) = NULL ; if ( s -> s3 -> rbuf . buf == NULL ) if ( ! ssl3_setup_buffers ( s ) ) return ( - 1 ) ; if ( ( type && ( type != SSL3_RT_APPLICATION_DATA ) && ( type != SSL3_RT_HANDSHAKE ) ) || ( peek && ( type != SSL3_RT_APPLICATION_DATA ) ) ) { SSLerr ( SSL_F_DTLS1_READ_BYTES , ERR_R_INTERNAL_ERROR ) ; return - 1 ; } if ( ( ret = have_handshake_fragment ( s , type , buf , len , peek ) ) ) return ret ; # ifndef OPENSSL_NO_SCTP if ( ( ! s -> in_handshake && SSL_in_init ( s ) ) || ( BIO_dgram_is_sctp ( SSL_get_rbio ( s ) ) && ( s -> state == DTLS1_SCTP_ST_SR_READ_SOCK || s -> state == DTLS1_SCTP_ST_CR_READ_SOCK ) && s -> s3 -> in_read_app_data != 2 ) ) # else if ( ! s -> in_handshake && SSL_in_init ( s ) ) # endif { i = s -> handshake_func ( s ) ; if ( i < 0 ) return ( i ) ; if ( i == 0 ) { SSLerr ( SSL_F_DTLS1_READ_BYTES , SSL_R_SSL_HANDSHAKE_FAILURE ) ; return ( - 1 ) ; } } start : s -> rwstate = SSL_NOTHING ; rr = & ( s -> s3 -> rrec ) ; if ( s -> state == SSL_ST_OK && rr -> length == 0 ) { pitem * item ; item = pqueue_pop ( s -> d1 -> buffered_app_data . q ) ; if ( item ) { # ifndef OPENSSL_NO_SCTP if ( BIO_dgram_is_sctp ( SSL_get_rbio ( s ) ) ) { DTLS1_RECORD_DATA * rdata = ( DTLS1_RECORD_DATA * ) item -> data ; BIO_ctrl ( SSL_get_rbio ( s ) , BIO_CTRL_DGRAM_SCTP_SET_RCVINFO , sizeof ( rdata -> recordinfo ) , & rdata -> recordinfo ) ; } # endif dtls1_copy_record ( s , item ) ; OPENSSL_free ( item -> data ) ; pitem_free ( item ) ; } } if ( dtls1_handle_timeout ( s ) > 0 ) goto start ; if ( ( rr -> length == 0 ) || ( s -> rstate == SSL_ST_READ_BODY ) ) { ret = dtls1_get_record ( s ) ; if ( ret <= 0 ) { ret = dtls1_read_failed ( s , ret ) ; if ( ret <= 0 ) return ( ret ) ; else goto start ; } } if ( s -> d1 -> listen && rr -> type != SSL3_RT_HANDSHAKE ) { rr -> length = 0 ; goto start ; } if ( s -> s3 -> change_cipher_spec && ( rr -> type != SSL3_RT_HANDSHAKE ) ) { <S2SV_StartBug> dtls1_buffer_record ( s , & ( s -> d1 -> buffered_app_data ) , rr -> seq_num ) ; <S2SV_EndBug> rr -> length = 0 ; goto start ; } if ( s -> shutdown & SSL_RECEIVED_SHUTDOWN ) { rr -> length = 0 ; s -> rwstate = SSL_NOTHING ; return ( 0 ) ; } if ( type == rr -> type ) { if ( SSL_in_init ( s ) && ( type == SSL3_RT_APPLICATION_DATA ) && ( s -> enc_read_ctx == NULL ) ) { al = SSL_AD_UNEXPECTED_MESSAGE ; SSLerr ( SSL_F_DTLS1_READ_BYTES , SSL_R_APP_DATA_IN_HANDSHAKE ) ; goto f_err ; } if ( len <= 0 ) return ( len ) ; if ( ( unsigned int ) len > rr -> length ) n = rr -> length ; else n = ( unsigned int ) len ; memcpy ( buf , & ( rr -> data [ rr -> off ] ) , n ) ; if ( ! peek ) { rr -> length -= n ; rr -> off += n ; if ( rr -> length == 0 ) { s -> rstate = SSL_ST_READ_HEADER ; rr -> off = 0 ; } } # ifndef OPENSSL_NO_SCTP if ( BIO_dgram_is_sctp ( SSL_get_rbio ( s ) ) && rr -> type == SSL3_RT_APPLICATION_DATA && ( s -> state == DTLS1_SCTP_ST_SR_READ_SOCK || s -> state == DTLS1_SCTP_ST_CR_READ_SOCK ) ) { s -> rwstate = SSL_READING ; BIO_clear_retry_flags ( SSL_get_rbio ( s ) ) ; BIO_set_retry_read ( SSL_get_rbio ( s ) ) ; } if ( BIO_dgram_is_sctp ( SSL_get_rbio ( s ) ) && s -> d1 -> shutdown_received && ! BIO_dgram_sctp_msg_waiting ( SSL_get_rbio ( s ) ) ) { s -> shutdown |= SSL_RECEIVED_SHUTDOWN ; return ( 0 ) ; } # endif return ( n ) ; } { unsigned int k , dest_maxlen = 0 ; unsigned char * dest = NULL ; unsigned int * dest_len = NULL ; if ( rr -> type == SSL3_RT_HANDSHAKE ) { dest_maxlen = sizeof s -> d1 -> handshake_fragment ; dest = s -> d1 -> handshake_fragment ; dest_len = & s -> d1 -> handshake_fragment_len ; } else if ( rr -> type == SSL3_RT_ALERT ) { dest_maxlen = sizeof ( s -> d1 -> alert_fragment ) ; dest = s -> d1 -> alert_fragment ; dest_len = & s -> d1 -> alert_fragment_len ; } # ifndef OPENSSL_NO_HEARTBEATS else if ( rr -> type == TLS1_RT_HEARTBEAT ) { dtls1_process_heartbeat ( s ) ; rr -> length = 0 ; s -> rwstate = SSL_READING ; BIO_clear_retry_flags ( SSL_get_rbio ( s ) ) ; BIO_set_retry_read ( SSL_get_rbio ( s ) ) ; return ( - 1 ) ; } # endif else if ( rr -> type != SSL3_RT_CHANGE_CIPHER_SPEC ) { if ( rr -> type == SSL3_RT_APPLICATION_DATA ) { BIO * bio ; s -> s3 -> in_read_app_data = 2 ; bio = SSL_get_rbio ( s ) ; s -> rwstate = SSL_READING ; BIO_clear_retry_flags ( bio ) ; BIO_set_retry_read ( bio ) ; return ( - 1 ) ; } al = SSL_AD_UNEXPECTED_MESSAGE ; SSLerr ( SSL_F_DTLS1_READ_BYTES , SSL_R_UNEXPECTED_RECORD ) ; goto f_err ; } if ( dest_maxlen > 0 ) { if ( rr -> length < dest_maxlen ) { # ifdef DTLS1_AD_MISSING_HANDSHAKE_MESSAGE FIX ME # endif s -> rstate = SSL_ST_READ_HEADER ; rr -> length = 0 ; goto start ; } for ( k = 0 ; k < dest_maxlen ; k ++ ) { dest [ k ] = rr -> data [ rr -> off ++ ] ; rr -> length -- ; } * dest_len = dest_maxlen ; } } if ( ( ! s -> server ) && ( s -> d1 -> handshake_fragment_len >= DTLS1_HM_HEADER_LENGTH ) && ( s -> d1 -> handshake_fragment [ 0 ] == SSL3_MT_HELLO_REQUEST ) && ( s -> session != NULL ) && ( s -> session -> cipher != NULL ) ) { s -> d1 -> handshake_fragment_len = 0 ; if ( ( s -> d1 -> handshake_fragment [ 1 ] != 0 ) || ( s -> d1 -> handshake_fragment [ 2 ] != 0 ) || ( s -> d1 -> handshake_fragment [ 3 ] != 0 ) ) { al = SSL_AD_DECODE_ERROR ; SSLerr ( SSL_F_DTLS1_READ_BYTES , SSL_R_BAD_HELLO_REQUEST ) ; goto err ; } if ( s -> msg_callback ) s -> msg_callback ( 0 , s -> version , SSL3_RT_HANDSHAKE , s -> d1 -> handshake_fragment , 4 , s , s -> msg_callback_arg ) ; if ( SSL_is_init_finished ( s ) && ! ( s -> s3 -> flags & SSL3_FLAGS_NO_RENEGOTIATE_CIPHERS ) && ! s -> s3 -> renegotiate ) { s -> d1 -> handshake_read_seq ++ ; s -> new_session = 1 ; ssl3_renegotiate ( s ) ; if ( ssl3_renegotiate_check ( s ) ) { i = s -> handshake_func ( s ) ; if ( i < 0 ) return ( i ) ; if ( i == 0 ) { SSLerr ( SSL_F_DTLS1_READ_BYTES , SSL_R_SSL_HANDSHAKE_FAILURE ) ; return ( - 1 ) ; } if ( ! ( s -> mode & SSL_MODE_AUTO_RETRY ) ) { if ( s -> s3 -> rbuf . left == 0 ) { BIO * bio ; s -> rwstate = SSL_READING ; bio = SSL_get_rbio ( s ) ; BIO_clear_retry_flags ( bio ) ; BIO_set_retry_read ( bio ) ; return ( - 1 ) ; } } } } goto start ; } if ( s -> d1 -> alert_fragment_len >= DTLS1_AL_HEADER_LENGTH ) { int alert_level = s -> d1 -> alert_fragment [ 0 ] ; int alert_descr = s -> d1 -> alert_fragment [ 1 ] ; s -> d1 -> alert_fragment_len = 0 ; if ( s -> msg_callback ) s -> msg_callback ( 0 , s -> version , SSL3_RT_ALERT , s -> d1 -> alert_fragment , 2 , s , s -> msg_callback_arg ) ; if ( s -> info_callback != NULL ) cb = s -> info_callback ; else if ( s -> ctx -> info_callback != NULL ) cb = s -> ctx -> info_callback ; if ( cb != NULL ) { j = ( alert_level << 8 ) | alert_descr ; cb ( s , SSL_CB_READ_ALERT , j ) ; } if ( alert_level == 1 ) { s -> s3 -> warn_alert = alert_descr ; if ( alert_descr == SSL_AD_CLOSE_NOTIFY ) { # ifndef OPENSSL_NO_SCTP if ( BIO_dgram_is_sctp ( SSL_get_rbio ( s ) ) && BIO_dgram_sctp_msg_waiting ( SSL_get_rbio ( s ) ) ) { s -> d1 -> shutdown_received = 1 ; s -> rwstate = SSL_READING ; BIO_clear_retry_flags ( SSL_get_rbio ( s ) ) ; BIO_set_retry_read ( SSL_get_rbio ( s ) ) ; return - 1 ; } # endif s -> shutdown |= SSL_RECEIVED_SHUTDOWN ; return ( 0 ) ; } # if 0 if ( alert_descr == DTLS1_AD_MISSING_HANDSHAKE_MESSAGE ) { unsigned short seq ; unsigned int frag_off ; unsigned char * p = & ( s -> d1 -> alert_fragment [ 2 ] ) ; n2s ( p , seq ) ; n2l3 ( p , frag_off ) ; dtls1_retransmit_message ( s , dtls1_get_queue_priority ( frag -> msg_header . seq , 0 ) , frag_off , & found ) ; if ( ! found && SSL_in_init ( s ) ) { ssl3_send_alert ( s , SSL3_AL_WARNING , DTLS1_AD_MISSING_HANDSHAKE_MESSAGE ) ; } } # endif } else if ( alert_level == 2 ) { char tmp [ 16 ] ; s -> rwstate = SSL_NOTHING ; s -> s3 -> fatal_alert = alert_descr ; SSLerr ( SSL_F_DTLS1_READ_BYTES , SSL_AD_REASON_OFFSET + alert_descr ) ; BIO_snprintf ( tmp , sizeof tmp , \"%d\" , alert_descr ) ; ERR_add_error_data ( 2 , \"SSL<S2SV_blank>alert<S2SV_blank>number<S2SV_blank>\" , tmp ) ; s -> shutdown |= SSL_RECEIVED_SHUTDOWN ; SSL_CTX_remove_session ( s -> ctx , s -> session ) ; return ( 0 ) ; } else { al = SSL_AD_ILLEGAL_PARAMETER ; SSLerr ( SSL_F_DTLS1_READ_BYTES , SSL_R_UNKNOWN_ALERT_TYPE ) ; goto f_err ; } goto start ; } if ( s -> shutdown & SSL_SENT_SHUTDOWN ) { s -> rwstate = SSL_NOTHING ; rr -> length = 0 ; return ( 0 ) ; } if ( rr -> type == SSL3_RT_CHANGE_CIPHER_SPEC ) { struct ccs_header_st ccs_hdr ; unsigned int ccs_hdr_len = DTLS1_CCS_HEADER_LENGTH ; dtls1_get_ccs_header ( rr -> data , & ccs_hdr ) ; if ( s -> version == DTLS1_BAD_VER ) ccs_hdr_len = 3 ; if ( ( rr -> length != ccs_hdr_len ) || ( rr -> off != 0 ) || ( rr -> data [ 0 ] != SSL3_MT_CCS ) ) { i = SSL_AD_ILLEGAL_PARAMETER ; SSLerr ( SSL_F_DTLS1_READ_BYTES , SSL_R_BAD_CHANGE_CIPHER_SPEC ) ; goto err ; } rr -> length = 0 ; if ( s -> msg_callback ) s -> msg_callback ( 0 , s -> version , SSL3_RT_CHANGE_CIPHER_SPEC , rr -> data , 1 , s , s -> msg_callback_arg ) ; if ( ! s -> d1 -> change_cipher_spec_ok ) { goto start ; } s -> d1 -> change_cipher_spec_ok = 0 ; s -> s3 -> change_cipher_spec = 1 ; if ( ! ssl3_do_change_cipher_spec ( s ) ) goto err ; dtls1_reset_seq_numbers ( s , SSL3_CC_READ ) ; if ( s -> version == DTLS1_BAD_VER ) s -> d1 -> handshake_read_seq ++ ; # ifndef OPENSSL_NO_SCTP BIO_ctrl ( SSL_get_wbio ( s ) , BIO_CTRL_DGRAM_SCTP_AUTH_CCS_RCVD , 1 , NULL ) ; # endif goto start ; } if ( ( s -> d1 -> handshake_fragment_len >= DTLS1_HM_HEADER_LENGTH ) && ! s -> in_handshake ) { struct hm_header_st msg_hdr ; dtls1_get_message_header ( rr -> data , & msg_hdr ) ; if ( rr -> epoch != s -> d1 -> r_epoch ) { rr -> length = 0 ; goto start ; } if ( msg_hdr . type == SSL3_MT_FINISHED ) { if ( dtls1_check_timeout_num ( s ) < 0 ) return - 1 ; dtls1_retransmit_buffered_messages ( s ) ; rr -> length = 0 ; goto start ; } if ( ( ( s -> state & SSL_ST_MASK ) == SSL_ST_OK ) && ! ( s -> s3 -> flags & SSL3_FLAGS_NO_RENEGOTIATE_CIPHERS ) ) { # if 0 s -> state = SSL_ST_BEFORE | ( s -> server ) ? SSL_ST_ACCEPT : SSL_ST_CONNECT ; # else s -> state = s -> server ? SSL_ST_ACCEPT : SSL_ST_CONNECT ; # endif s -> renegotiate = 1 ; s -> new_session = 1 ; } i = s -> handshake_func ( s ) ; if ( i < 0 ) return ( i ) ; if ( i == 0 ) { SSLerr ( SSL_F_DTLS1_READ_BYTES , SSL_R_SSL_HANDSHAKE_FAILURE ) ; return ( - 1 ) ; } if ( ! ( s -> mode & SSL_MODE_AUTO_RETRY ) ) { if ( s -> s3 -> rbuf . left == 0 ) { BIO * bio ; s -> rwstate = SSL_READING ; bio = SSL_get_rbio ( s ) ; BIO_clear_retry_flags ( bio ) ; BIO_set_retry_read ( bio ) ; return ( - 1 ) ; } } goto start ; } switch ( rr -> type ) { default : # ifndef OPENSSL_NO_TLS if ( s -> version == TLS1_VERSION ) { rr -> length = 0 ; goto start ; } # endif al = SSL_AD_UNEXPECTED_MESSAGE ; SSLerr ( SSL_F_DTLS1_READ_BYTES , SSL_R_UNEXPECTED_RECORD ) ; goto f_err ; case SSL3_RT_CHANGE_CIPHER_SPEC : case SSL3_RT_ALERT : case SSL3_RT_HANDSHAKE : al = SSL_AD_UNEXPECTED_MESSAGE ; SSLerr ( SSL_F_DTLS1_READ_BYTES , ERR_R_INTERNAL_ERROR ) ; goto f_err ; case SSL3_RT_APPLICATION_DATA : if ( s -> s3 -> in_read_app_data && ( s -> s3 -> total_renegotiations != 0 ) && ( ( ( s -> state & SSL_ST_CONNECT ) && ( s -> state >= SSL3_ST_CW_CLNT_HELLO_A ) && ( s -> state <= SSL3_ST_CR_SRVR_HELLO_A ) ) || ( ( s -> state & SSL_ST_ACCEPT ) && ( s -> state <= SSL3_ST_SW_HELLO_REQ_A ) && ( s -> state >= SSL3_ST_SR_CLNT_HELLO_A ) ) ) ) { s -> s3 -> in_read_app_data = 2 ; return ( - 1 ) ; } else { al = SSL_AD_UNEXPECTED_MESSAGE ; SSLerr ( SSL_F_DTLS1_READ_BYTES , SSL_R_UNEXPECTED_RECORD ) ; goto f_err ; } } f_err : ssl3_send_alert ( s , SSL3_AL_FATAL , al ) ; err : return ( - 1 ) ; }\n",
      "fixed_code": "<S2SV_ModStart> ) ) { if ( <S2SV_ModStart> -> seq_num ) < 0 ) { SSLerr ( SSL_F_DTLS1_READ_BYTES , ERR_R_INTERNAL_ERROR ) ; return - 1 ; } <S2SV_ModEnd> rr -> length\n",
      "source_code_length": 11724,
      "target_code_length": 165,
      "vulnerability_patterns": {
        "buffer_overflow": 1,
        "integer_overflow": 4,
        "null_pointer": 55,
        "total": 60
      },
      "total_patterns": 60,
      "original_address": "https://github.com/openssl/openssl/commit/103b171d8fc282ef435f8de9afbf7782e312961f",
      "discovery_time": "2015-01-09T02:59Z",
      "project_commit_id": "openssl@openssl/103b171d8fc282ef435f8de9afbf7782e312961f",
      "extraction_time": "2025-08-31T15:41:49.178471",
      "label": 1,
      "vulnerability_type": "buffer_overflow",
      "difficulty_level": "expert",
      "risk_factors": [
        "memory_corruption",
        "critical_infrastructure",
        "arbitrary_code_execution",
        "buffer_overflow",
        "system_crash"
      ],
      "attack_vectors": [
        "memory_manipulation",
        "malicious_input",
        "code_analysis",
        "buffer_overflow",
        "reverse_engineering",
        "fuzzing"
      ],
      "mitigation_strategies": [
        "safe_string_functions",
        "dynamic_analysis",
        "code_review",
        "static_analysis",
        "memory_safety_checks",
        "input_validation",
        "fuzzing",
        "bounds_checking",
        "secure_coding_practices"
      ],
      "code_differences": {
        "has_differences": true,
        "source_lines": 2,
        "target_lines": 2,
        "character_differences": 11559,
        "similarity_percentage": 7.480314960629922
      },
      "vulnerability_location": {
        "vulnerability_present": true,
        "fix_applied": true,
        "code_changed": true,
        "estimated_lines_changed": 0
      }
    },
    {
      "cve_id": "CVE-2019-14934",
      "cwe_id": "CWE-787",
      "cwe_name": "Out-of-bounds Write",
      "project": "enferex",
      "severity": "critical",
      "weaponization_score": 10.0,
      "is_critical": true,
      "is_weaponizable": true,
      "is_high_priority_project": false,
      "vulnerable_code": "CWE-787 pdf_t * pdf_new ( const char * name ) { const char * n ; pdf_t * pdf ; <S2SV_StartBug> pdf = calloc ( 1 , sizeof ( pdf_t ) ) ; <S2SV_EndBug> if ( name ) { if ( ( n = strrchr ( name , '/' ) ) ) ++ n ; else n = name ; <S2SV_StartBug> pdf -> name = malloc ( strlen ( n ) + 1 ) ; <S2SV_EndBug> strcpy ( pdf -> name , n ) ; } else { <S2SV_StartBug> pdf -> name = malloc ( strlen ( \"Unknown\" ) + 1 ) ; <S2SV_EndBug> strcpy ( pdf -> name , \"Unknown\" ) ; } return pdf ; }\n",
      "fixed_code": "<S2SV_ModStart> ; pdf = safe_calloc ( <S2SV_ModEnd> sizeof ( pdf_t <S2SV_ModStart> -> name = safe_calloc <S2SV_ModEnd> ( strlen ( <S2SV_ModStart> -> name = safe_calloc <S2SV_ModEnd> ( strlen (\n",
      "source_code_length": 472,
      "target_code_length": 193,
      "vulnerability_patterns": {
        "buffer_overflow": 2,
        "use_after_free": 15,
        "format_string": 2,
        "null_pointer": 2,
        "sql_injection": 1,
        "memory_leak": 1,
        "total": 23
      },
      "total_patterns": 23,
      "original_address": "https://github.com/enferex/pdfresurrect/commit/0c4120fffa3dffe97b95c486a120eded82afe8a6",
      "discovery_time": "2019-08-11T22:15Z",
      "project_commit_id": "enferex@pdfresurrect/0c4120fffa3dffe97b95c486a120eded82afe8a6",
      "extraction_time": "2025-08-31T15:41:49.178571",
      "label": 1,
      "vulnerability_type": "out-of-bounds_write",
      "difficulty_level": "expert",
      "risk_factors": [
        "memory_corruption",
        "sql_injection",
        "arbitrary_code_execution",
        "buffer_overflow",
        "system_crash",
        "use_after_free"
      ],
      "attack_vectors": [
        "memory_manipulation",
        "malicious_input",
        "code_analysis",
        "buffer_overflow",
        "reverse_engineering",
        "fuzzing"
      ],
      "mitigation_strategies": [
        "safe_string_functions",
        "dynamic_analysis",
        "code_review",
        "static_analysis",
        "memory_safety_checks",
        "input_validation",
        "fuzzing",
        "bounds_checking",
        "secure_coding_practices"
      ],
      "code_differences": {
        "has_differences": true,
        "source_lines": 2,
        "target_lines": 2,
        "character_differences": 279,
        "similarity_percentage": 25.0
      },
      "vulnerability_location": {
        "vulnerability_present": true,
        "fix_applied": true,
        "code_changed": true,
        "estimated_lines_changed": 0
      }
    },
    {
      "cve_id": "CVE-2019-15946",
      "cwe_id": "CWE-119",
      "cwe_name": "Buffer Overflow",
      "project": "OpenSC",
      "severity": "critical",
      "weaponization_score": 10.0,
      "is_critical": true,
      "is_weaponizable": true,
      "is_high_priority_project": false,
      "vulnerable_code": "CWE-119 static int asn1_decode_entry ( sc_context_t * ctx , struct sc_asn1_entry * entry , const u8 * obj , size_t objlen , int depth ) { void * parm = entry -> parm ; int ( * callback_func ) ( sc_context_t * nctx , void * arg , const u8 * nobj , size_t nobjlen , int ndepth ) ; size_t * len = ( size_t * ) entry -> arg ; int r = 0 ; callback_func = parm ; sc_debug ( ctx , SC_LOG_DEBUG_ASN1 , \"%*.*sdecoding<S2SV_blank>\\'%s\\',<S2SV_blank>raw<S2SV_blank>data:%s%s\\\\n\" , depth , depth , \"\" , entry -> name , sc_dump_hex ( obj , objlen > 16 ? 16 : objlen ) , objlen > 16 ? \"...\" : \"\" ) ; switch ( entry -> type ) { case SC_ASN1_STRUCT : if ( parm != NULL ) r = asn1_decode ( ctx , ( struct sc_asn1_entry * ) parm , obj , objlen , NULL , NULL , 0 , depth + 1 ) ; break ; case SC_ASN1_NULL : break ; case SC_ASN1_BOOLEAN : if ( parm != NULL ) { if ( objlen != 1 ) { sc_debug ( ctx , SC_LOG_DEBUG_ASN1 , \"invalid<S2SV_blank>ASN.1<S2SV_blank>object<S2SV_blank>length:<S2SV_blank>%\" SC_FORMAT_LEN_SIZE_T \"u\\\\n\" , objlen ) ; r = SC_ERROR_INVALID_ASN1_OBJECT ; } else * ( ( int * ) parm ) = obj [ 0 ] ? 1 : 0 ; } break ; case SC_ASN1_INTEGER : case SC_ASN1_ENUMERATED : if ( parm != NULL ) { r = sc_asn1_decode_integer ( obj , objlen , ( int * ) entry -> parm ) ; sc_debug ( ctx , SC_LOG_DEBUG_ASN1 , \"%*.*sdecoding<S2SV_blank>\\'%s\\'<S2SV_blank>returned<S2SV_blank>%d\\\\n\" , depth , depth , \"\" , entry -> name , * ( ( int * ) entry -> parm ) ) ; } break ; case SC_ASN1_BIT_STRING_NI : case SC_ASN1_BIT_STRING : if ( parm != NULL ) { int invert = entry -> type == SC_ASN1_BIT_STRING ? 1 : 0 ; assert ( len != NULL ) ; if ( objlen < 1 ) { r = SC_ERROR_INVALID_ASN1_OBJECT ; break ; } if ( entry -> flags & SC_ASN1_ALLOC ) { u8 * * buf = ( u8 * * ) parm ; * buf = malloc ( objlen - 1 ) ; if ( * buf == NULL ) { r = SC_ERROR_OUT_OF_MEMORY ; break ; } * len = objlen - 1 ; parm = * buf ; } r = decode_bit_string ( obj , objlen , ( u8 * ) parm , * len , invert ) ; if ( r >= 0 ) { * len = r ; r = 0 ; } } break ; case SC_ASN1_BIT_FIELD : if ( parm != NULL ) r = decode_bit_field ( obj , objlen , ( u8 * ) parm , * len ) ; break ; case SC_ASN1_OCTET_STRING : if ( parm != NULL ) { size_t c ; assert ( len != NULL ) ; if ( ( entry -> flags & SC_ASN1_UNSIGNED ) <S2SV_StartBug> && obj [ 0 ] == 0x00 && objlen > 1 ) { <S2SV_EndBug> objlen -- ; obj ++ ; } if ( entry -> flags & SC_ASN1_ALLOC ) { u8 * * buf = ( u8 * * ) parm ; * buf = malloc ( objlen ) ; if ( * buf == NULL ) { r = SC_ERROR_OUT_OF_MEMORY ; break ; } c = * len = objlen ; parm = * buf ; } else c = objlen > * len ? * len : objlen ; memcpy ( parm , obj , c ) ; * len = c ; } break ; case SC_ASN1_GENERALIZEDTIME : if ( parm != NULL ) { size_t c ; assert ( len != NULL ) ; if ( entry -> flags & SC_ASN1_ALLOC ) { u8 * * buf = ( u8 * * ) parm ; * buf = malloc ( objlen ) ; if ( * buf == NULL ) { r = SC_ERROR_OUT_OF_MEMORY ; break ; } c = * len = objlen ; parm = * buf ; } else c = objlen > * len ? * len : objlen ; memcpy ( parm , obj , c ) ; * len = c ; } break ; case SC_ASN1_OBJECT : if ( parm != NULL ) r = sc_asn1_decode_object_id ( obj , objlen , ( struct sc_object_id * ) parm ) ; break ; case SC_ASN1_PRINTABLESTRING : case SC_ASN1_UTF8STRING : if ( parm != NULL ) { assert ( len != NULL ) ; if ( entry -> flags & SC_ASN1_ALLOC ) { u8 * * buf = ( u8 * * ) parm ; * buf = malloc ( objlen + 1 ) ; if ( * buf == NULL ) { r = SC_ERROR_OUT_OF_MEMORY ; break ; } * len = objlen + 1 ; parm = * buf ; } r = sc_asn1_decode_utf8string ( obj , objlen , ( u8 * ) parm , len ) ; if ( entry -> flags & SC_ASN1_ALLOC ) { * len -= 1 ; } } break ; case SC_ASN1_PATH : if ( entry -> parm != NULL ) r = asn1_decode_path ( ctx , obj , objlen , ( sc_path_t * ) parm , depth ) ; break ; case SC_ASN1_PKCS15_ID : if ( entry -> parm != NULL ) { struct sc_pkcs15_id * id = ( struct sc_pkcs15_id * ) parm ; size_t c = objlen > sizeof ( id -> value ) ? sizeof ( id -> value ) : objlen ; memcpy ( id -> value , obj , c ) ; id -> len = c ; } break ; case SC_ASN1_PKCS15_OBJECT : if ( entry -> parm != NULL ) r = asn1_decode_p15_object ( ctx , obj , objlen , ( struct sc_asn1_pkcs15_object * ) parm , depth ) ; break ; case SC_ASN1_ALGORITHM_ID : if ( entry -> parm != NULL ) r = sc_asn1_decode_algorithm_id ( ctx , obj , objlen , ( struct sc_algorithm_id * ) parm , depth ) ; break ; case SC_ASN1_SE_INFO : if ( entry -> parm != NULL ) r = asn1_decode_se_info ( ctx , obj , objlen , ( sc_pkcs15_sec_env_info_t * * * ) entry -> parm , len , depth ) ; break ; case SC_ASN1_CALLBACK : if ( entry -> parm != NULL ) r = callback_func ( ctx , entry -> arg , obj , objlen , depth ) ; break ; default : sc_debug ( ctx , SC_LOG_DEBUG_ASN1 , \"invalid<S2SV_blank>ASN.1<S2SV_blank>type:<S2SV_blank>%d\\\\n\" , entry -> type ) ; return SC_ERROR_INVALID_ASN1_OBJECT ; } if ( r ) { sc_debug ( ctx , SC_LOG_DEBUG_ASN1 , \"decoding<S2SV_blank>of<S2SV_blank>ASN.1<S2SV_blank>object<S2SV_blank>\\'%s\\'<S2SV_blank>failed:<S2SV_blank>%s\\\\n\" , entry -> name , sc_strerror ( r ) ) ; return r ; } entry -> flags |= SC_ASN1_PRESENT ; return 0 ; }\n",
      "fixed_code": "<S2SV_ModStart> SC_ASN1_UNSIGNED ) && objlen > 1 && <S2SV_ModStart> ] == 0x00 <S2SV_ModEnd> ) { objlen\n",
      "source_code_length": 5039,
      "target_code_length": 103,
      "vulnerability_patterns": {
        "buffer_overflow": 3,
        "use_after_free": 4,
        "integer_overflow": 3,
        "null_pointer": 29,
        "memory_leak": 4,
        "total": 43
      },
      "total_patterns": 43,
      "original_address": "https://github.com/OpenSC/OpenSC/commit/a3fc7693f3a035a8a7921cffb98432944bb42740",
      "discovery_time": "2019-09-05T17:15Z",
      "project_commit_id": "OpenSC@OpenSC/a3fc7693f3a035a8a7921cffb98432944bb42740",
      "extraction_time": "2025-08-31T15:41:49.178600",
      "label": 1,
      "vulnerability_type": "buffer_overflow",
      "difficulty_level": "expert",
      "risk_factors": [
        "memory_corruption",
        "arbitrary_code_execution",
        "buffer_overflow",
        "system_crash",
        "use_after_free"
      ],
      "attack_vectors": [
        "memory_manipulation",
        "malicious_input",
        "code_analysis",
        "buffer_overflow",
        "reverse_engineering",
        "fuzzing"
      ],
      "mitigation_strategies": [
        "safe_string_functions",
        "dynamic_analysis",
        "code_review",
        "static_analysis",
        "memory_safety_checks",
        "input_validation",
        "fuzzing",
        "bounds_checking",
        "secure_coding_practices"
      ],
      "code_differences": {
        "has_differences": true,
        "source_lines": 2,
        "target_lines": 2,
        "character_differences": 4936,
        "similarity_percentage": 7.575757575757576
      },
      "vulnerability_location": {
        "vulnerability_present": true,
        "fix_applied": true,
        "code_changed": true,
        "estimated_lines_changed": 0
      }
    },
    {
      "cve_id": "CVE-2020-14954",
      "cwe_id": "CWE-74",
      "cwe_name": "Command Injection",
      "project": "neomutt",
      "severity": "critical",
      "weaponization_score": 10.0,
      "is_critical": true,
      "is_weaponizable": true,
      "is_high_priority_project": true,
      "vulnerable_code": "CWE-74 int nntp_open_connection ( struct NntpAccountData * adata ) { struct Connection * conn = adata -> conn ; char buf [ 256 ] ; int cap ; bool posting = false , auth = true ; if ( adata -> status == NNTP_OK ) return 0 ; if ( adata -> status == NNTP_BYE ) return - 1 ; adata -> status = NNTP_NONE ; if ( mutt_socket_open ( conn ) < 0 ) return - 1 ; if ( mutt_socket_readln ( buf , sizeof ( buf ) , conn ) < 0 ) return nntp_connect_error ( adata ) ; if ( mutt_str_startswith ( buf , \"200\" , CASE_MATCH ) ) posting = true ; else if ( ! mutt_str_startswith ( buf , \"201\" , CASE_MATCH ) ) { mutt_socket_close ( conn ) ; mutt_str_remove_trailing_ws ( buf ) ; mutt_error ( \"%s\" , buf ) ; return - 1 ; } cap = nntp_capabilities ( adata ) ; if ( cap < 0 ) return - 1 ; if ( cap > 0 ) { if ( ( mutt_socket_send ( conn , \"MODE<S2SV_blank>READER\\\\r\\\\n\" ) < 0 ) || ( mutt_socket_readln ( buf , sizeof ( buf ) , conn ) < 0 ) ) { return nntp_connect_error ( adata ) ; } if ( mutt_str_startswith ( buf , \"200\" , CASE_MATCH ) ) posting = true ; else if ( mutt_str_startswith ( buf , \"201\" , CASE_MATCH ) ) posting = false ; else if ( adata -> hasCAPABILITIES ) { mutt_socket_close ( conn ) ; mutt_error ( _ ( \"Could<S2SV_blank>not<S2SV_blank>switch<S2SV_blank>to<S2SV_blank>reader<S2SV_blank>mode\" ) ) ; return - 1 ; } if ( adata -> hasCAPABILITIES ) { cap = nntp_capabilities ( adata ) ; if ( cap < 0 ) return - 1 ; } } mutt_message ( _ ( \"Connected<S2SV_blank>to<S2SV_blank>%s.<S2SV_blank>%s\" ) , conn -> account . host , posting ? _ ( \"Posting<S2SV_blank>is<S2SV_blank>ok\" ) : _ ( \"Posting<S2SV_blank>is<S2SV_blank>NOT<S2SV_blank>ok\" ) ) ; mutt_sleep ( 1 ) ; # ifdef USE_SSL if ( ( adata -> use_tls != 1 ) && ( adata -> hasSTARTTLS || C_SslForceTls ) ) { if ( adata -> use_tls == 0 ) { adata -> use_tls = C_SslForceTls || query_quadoption ( C_SslStarttls , _ ( \"Secure<S2SV_blank>connection<S2SV_blank>with<S2SV_blank>TLS?\" ) ) == MUTT_YES ? 2 : 1 ; } if ( adata -> use_tls == 2 ) { if ( ( mutt_socket_send ( conn , \"STARTTLS\\\\r\\\\n\" ) < 0 ) || ( mutt_socket_readln ( buf , sizeof ( buf ) , conn ) < 0 ) ) { return nntp_connect_error ( adata ) ; <S2SV_StartBug> } <S2SV_EndBug> if ( ! mutt_str_startswith ( buf , \"382\" , CASE_MATCH ) ) { adata -> use_tls = 0 ; mutt_error ( \"STARTTLS:<S2SV_blank>%s\" , buf ) ; } else if ( mutt_ssl_starttls ( conn ) ) { adata -> use_tls = 0 ; adata -> status = NNTP_NONE ; mutt_socket_close ( adata -> conn ) ; mutt_error ( _ ( \"Could<S2SV_blank>not<S2SV_blank>negotiate<S2SV_blank>TLS<S2SV_blank>connection\" ) ) ; return - 1 ; } else { cap = nntp_capabilities ( adata ) ; if ( cap < 0 ) return - 1 ; } } } # endif if ( conn -> account . flags & MUTT_ACCT_USER ) { if ( ! conn -> account . user [ 0 ] ) auth = false ; } else { if ( ( mutt_socket_send ( conn , \"STAT\\\\r\\\\n\" ) < 0 ) || ( mutt_socket_readln ( buf , sizeof ( buf ) , conn ) < 0 ) ) { return nntp_connect_error ( adata ) ; } if ( ! mutt_str_startswith ( buf , \"480\" , CASE_MATCH ) ) auth = false ; } if ( auth && ( nntp_auth ( adata ) < 0 ) ) return - 1 ; if ( adata -> hasCAPABILITIES && ( auth || ( cap > 0 ) ) ) { cap = nntp_capabilities ( adata ) ; if ( cap < 0 ) return - 1 ; if ( cap > 0 ) { mutt_socket_close ( conn ) ; mutt_error ( _ ( \"Could<S2SV_blank>not<S2SV_blank>switch<S2SV_blank>to<S2SV_blank>reader<S2SV_blank>mode\" ) ) ; return - 1 ; } } if ( nntp_attempt_features ( adata ) < 0 ) return - 1 ; adata -> status = NNTP_OK ; return 0 ; }\n",
      "fixed_code": "<S2SV_ModStart> ) ; } mutt_socket_empty ( conn ) ;\n",
      "source_code_length": 3436,
      "target_code_length": 51,
      "vulnerability_patterns": {
        "use_after_free": 2,
        "null_pointer": 19,
        "total": 21
      },
      "total_patterns": 21,
      "original_address": "https://github.com/neomutt/neomutt/commit/fb013ec666759cb8a9e294347c7b4c1f597639cc",
      "discovery_time": "2020-06-21T17:15Z",
      "project_commit_id": "neomutt@neomutt/fb013ec666759cb8a9e294347c7b4c1f597639cc",
      "extraction_time": "2025-08-31T15:41:49.178645",
      "label": 1,
      "vulnerability_type": "command_injection",
      "difficulty_level": "expert",
      "risk_factors": [
        "critical_infrastructure",
        "command_injection",
        "arbitrary_code_execution",
        "use_after_free",
        "remote_code_execution"
      ],
      "attack_vectors": [
        "command_injection",
        "system_commands",
        "code_analysis",
        "reverse_engineering",
        "fuzzing",
        "user_input"
      ],
      "mitigation_strategies": [
        "fuzzing",
        "dynamic_analysis",
        "command_whitelisting",
        "static_analysis",
        "secure_coding_practices",
        "privilege_separation",
        "input_sanitization",
        "code_review",
        "input_validation"
      ],
      "code_differences": {
        "has_differences": true,
        "source_lines": 2,
        "target_lines": 2,
        "character_differences": 3385,
        "similarity_percentage": 4.901960784313726
      },
      "vulnerability_location": {
        "vulnerability_present": true,
        "fix_applied": true,
        "code_changed": true,
        "estimated_lines_changed": 0
      }
    },
    {
      "cve_id": "CVE-2019-19275",
      "cwe_id": "CWE-125",
      "cwe_name": "Out-of-bounds Read",
      "project": "python",
      "severity": "critical",
      "weaponization_score": 9.7,
      "is_critical": true,
      "is_weaponizable": true,
      "is_high_priority_project": true,
      "vulnerable_code": "CWE-125 static arguments_ty ast_for_arguments ( struct compiling * c , const node * n ) { int i , j , k , nposargs = 0 , nkwonlyargs = 0 ; int nposdefaults = 0 , found_default = 0 ; asdl_seq * posargs , * posdefaults , * kwonlyargs , * kwdefaults ; arg_ty vararg = NULL , kwarg = NULL ; arg_ty arg ; node * ch ; if ( TYPE ( n ) == parameters ) { if ( NCH ( n ) == 2 ) return arguments ( NULL , NULL , NULL , NULL , NULL , NULL , c -> c_arena ) ; n = CHILD ( n , 1 ) ; } assert ( TYPE ( n ) == typedargslist || TYPE ( n ) == varargslist ) ; for ( i = 0 ; i < NCH ( n ) ; i ++ ) { ch = CHILD ( n , i ) ; if ( TYPE ( ch ) == STAR ) { i ++ ; if ( i < NCH ( n ) && ( TYPE ( CHILD ( n , i ) ) == tfpdef || TYPE ( CHILD ( n , i ) ) == vfpdef ) ) { i ++ ; } break ; } if ( TYPE ( ch ) == DOUBLESTAR ) break ; if ( TYPE ( ch ) == vfpdef || TYPE ( ch ) == tfpdef ) nposargs ++ ; if ( TYPE ( ch ) == EQUAL ) nposdefaults ++ ; } for ( ; i < NCH ( n ) ; ++ i ) { ch = CHILD ( n , i ) ; if ( TYPE ( ch ) == DOUBLESTAR ) break ; if ( TYPE ( ch ) == tfpdef || TYPE ( ch ) == vfpdef ) nkwonlyargs ++ ; } posargs = ( nposargs ? _Ta3_asdl_seq_new ( nposargs , c -> c_arena ) : NULL ) ; if ( ! posargs && nposargs ) return NULL ; kwonlyargs = ( nkwonlyargs ? _Ta3_asdl_seq_new ( nkwonlyargs , c -> c_arena ) : NULL ) ; if ( ! kwonlyargs && nkwonlyargs ) return NULL ; posdefaults = ( nposdefaults ? _Ta3_asdl_seq_new ( nposdefaults , c -> c_arena ) : NULL ) ; if ( ! posdefaults && nposdefaults ) return NULL ; kwdefaults = ( nkwonlyargs ? _Ta3_asdl_seq_new ( nkwonlyargs , c -> c_arena ) : NULL ) ; if ( ! kwdefaults && nkwonlyargs ) return NULL ; <S2SV_StartBug> if ( nposargs + nkwonlyargs > 255 ) { <S2SV_EndBug> ast_error ( c , n , \"more<S2SV_blank>than<S2SV_blank>255<S2SV_blank>arguments\" ) ; return NULL ; } i = 0 ; j = 0 ; k = 0 ; while ( i < NCH ( n ) ) { ch = CHILD ( n , i ) ; switch ( TYPE ( ch ) ) { case tfpdef : case vfpdef : if ( i + 1 < NCH ( n ) && TYPE ( CHILD ( n , i + 1 ) ) == EQUAL ) { expr_ty expression = ast_for_expr ( c , CHILD ( n , i + 2 ) ) ; if ( ! expression ) return NULL ; assert ( posdefaults != NULL ) ; asdl_seq_SET ( posdefaults , j ++ , expression ) ; i += 2 ; found_default = 1 ; } else if ( found_default ) { ast_error ( c , n , \"non-default<S2SV_blank>argument<S2SV_blank>follows<S2SV_blank>default<S2SV_blank>argument\" ) ; return NULL ; } arg = ast_for_arg ( c , ch ) ; if ( ! arg ) return NULL ; asdl_seq_SET ( posargs , k ++ , arg ) ; i += 1 ; <S2SV_StartBug> if ( i < NCH ( n ) && TYPE ( CHILD ( n , i ) ) == COMMA ) <S2SV_EndBug> i += 1 ; break ; case STAR : if ( i + 1 >= NCH ( n ) || ( i + 2 == NCH ( n ) && ( TYPE ( CHILD ( n , i + 1 ) ) == COMMA || TYPE ( CHILD ( n , i + 1 ) ) == TYPE_COMMENT ) ) ) { ast_error ( c , CHILD ( n , i ) , \"named<S2SV_blank>arguments<S2SV_blank>must<S2SV_blank>follow<S2SV_blank>bare<S2SV_blank>*\" ) ; return NULL ; } ch = CHILD ( n , i + 1 ) ; if ( TYPE ( ch ) == COMMA ) { int res = 0 ; i += 2 ; <S2SV_StartBug> if ( i < NCH ( n ) && TYPE ( CHILD ( n , i ) ) == TYPE_COMMENT ) { <S2SV_EndBug> ast_error ( c , CHILD ( n , i ) , \"bare<S2SV_blank>*<S2SV_blank>has<S2SV_blank>associated<S2SV_blank>type<S2SV_blank>comment\" ) ; return NULL ; } res = handle_keywordonly_args ( c , n , i , kwonlyargs , kwdefaults ) ; if ( res == - 1 ) return NULL ; i = res ; } else { vararg = ast_for_arg ( c , ch ) ; if ( ! vararg ) return NULL ; i += 2 ; <S2SV_StartBug> if ( i < NCH ( n ) && TYPE ( CHILD ( n , i ) ) == COMMA ) <S2SV_EndBug> i += 1 ; <S2SV_StartBug> if ( i < NCH ( n ) && TYPE ( CHILD ( n , i ) ) == TYPE_COMMENT ) { <S2SV_EndBug> vararg -> type_comment = NEW_TYPE_COMMENT ( CHILD ( n , i ) ) ; i += 1 ; } if ( i < NCH ( n ) && ( TYPE ( CHILD ( n , i ) ) == tfpdef || TYPE ( CHILD ( n , i ) ) == vfpdef ) ) { int res = 0 ; res = handle_keywordonly_args ( c , n , i , kwonlyargs , kwdefaults ) ; if ( res == - 1 ) return NULL ; i = res ; } } break ; case DOUBLESTAR : ch = CHILD ( n , i + 1 ) ; assert ( TYPE ( ch ) == tfpdef || TYPE ( ch ) == vfpdef ) ; kwarg = ast_for_arg ( c , ch ) ; if ( ! kwarg ) return NULL ; i += 2 ; <S2SV_StartBug> if ( i < NCH ( n ) && TYPE ( CHILD ( n , i ) ) == COMMA ) <S2SV_EndBug> i += 1 ; break ; case TYPE_COMMENT : assert ( i ) ; if ( kwarg ) arg = kwarg ; arg -> type_comment = NEW_TYPE_COMMENT ( ch ) ; i += 1 ; break ; default : PyErr_Format ( PyExc_SystemError , \"unexpected<S2SV_blank>node<S2SV_blank>in<S2SV_blank>varargslist:<S2SV_blank>%d<S2SV_blank>@<S2SV_blank>%d\" , TYPE ( ch ) , i ) ; return NULL ; } } return arguments ( posargs , vararg , kwonlyargs , kwdefaults , kwarg , posdefaults , c -> c_arena ) ; }\n",
      "fixed_code": "<S2SV_ModStart> return NULL ; <S2SV_ModEnd> i = 0 <S2SV_ModStart> ; if ( <S2SV_ModEnd> TYPE ( CHILD <S2SV_ModStart> ; if ( <S2SV_ModEnd> TYPE ( CHILD <S2SV_ModStart> ; if ( <S2SV_ModEnd> TYPE ( CHILD <S2SV_ModStart> ; if ( <S2SV_ModEnd> TYPE ( CHILD <S2SV_ModStart> ; if ( <S2SV_ModEnd> TYPE ( CHILD\n",
      "source_code_length": 4617,
      "target_code_length": 300,
      "vulnerability_patterns": {
        "use_after_free": 1,
        "null_pointer": 8,
        "total": 9
      },
      "total_patterns": 9,
      "original_address": "https://github.com/python/typed_ast/commit/156afcb26c198e162504a57caddfe0acd9ed7dce",
      "discovery_time": "2019-11-26T15:15Z",
      "project_commit_id": "python@typed_ast/156afcb26c198e162504a57caddfe0acd9ed7dce",
      "extraction_time": "2025-08-31T15:41:49.178677",
      "label": 1,
      "vulnerability_type": "out-of-bounds_read",
      "difficulty_level": "expert",
      "risk_factors": [
        "memory_corruption",
        "critical_infrastructure",
        "information_disclosure",
        "use_after_free",
        "integer_overflow"
      ],
      "attack_vectors": [
        "memory_manipulation",
        "malicious_input",
        "code_analysis",
        "buffer_overflow",
        "reverse_engineering",
        "fuzzing"
      ],
      "mitigation_strategies": [
        "safe_string_functions",
        "dynamic_analysis",
        "code_review",
        "static_analysis",
        "memory_safety_checks",
        "input_validation",
        "fuzzing",
        "bounds_checking",
        "secure_coding_practices"
      ],
      "code_differences": {
        "has_differences": true,
        "source_lines": 2,
        "target_lines": 2,
        "character_differences": 4317,
        "similarity_percentage": 9.70873786407767
      },
      "vulnerability_location": {
        "vulnerability_present": true,
        "fix_applied": true,
        "code_changed": true,
        "estimated_lines_changed": 0
      }
    },
    {
      "cve_id": "CVE-2017-6435",
      "cwe_id": "CWE-119",
      "cwe_name": "Buffer Overflow",
      "project": "libimobiledevice",
      "severity": "critical",
      "weaponization_score": 9.7,
      "is_critical": true,
      "is_weaponizable": true,
      "is_high_priority_project": false,
      "vulnerable_code": "CWE-119 static plist_t parse_string_node ( const char * * bnode , uint64_t size ) { plist_data_t data = plist_new_plist_data ( ) ; data -> type = PLIST_STRING ; data -> strval = ( char * ) malloc ( sizeof ( char ) * ( size + 1 ) ) ; <S2SV_StartBug> memcpy ( data -> strval , * bnode , size ) ; <S2SV_EndBug> data -> strval [ size ] = '\\\\0' ; data -> length = strlen ( data -> strval ) ; return node_create ( NULL , data ) ; }\n",
      "fixed_code": "<S2SV_ModStart> ) ) ; if ( ! data -> strval ) { plist_free_data ( data ) ; PLIST_BIN_ERR ( \"%s:<S2SV_blank>Could<S2SV_blank>not<S2SV_blank>allocate<S2SV_blank>%\" PRIu64 \"<S2SV_blank>bytes\\\\n\" , __func__ , sizeof ( char ) * ( size + 1 ) ) ; return NULL ; }\n",
      "source_code_length": 426,
      "target_code_length": 256,
      "vulnerability_patterns": {
        "buffer_overflow": 1,
        "use_after_free": 1,
        "null_pointer": 6,
        "memory_leak": 1,
        "total": 9
      },
      "total_patterns": 9,
      "original_address": "https://github.com/libimobiledevice/libplist/commit/fbd8494d5e4e46bf2e90cb6116903e404374fb56",
      "discovery_time": "2017-03-15T14:59Z",
      "project_commit_id": "libimobiledevice@libplist/fbd8494d5e4e46bf2e90cb6116903e404374fb56",
      "extraction_time": "2025-08-31T15:41:49.178733",
      "label": 1,
      "vulnerability_type": "buffer_overflow",
      "difficulty_level": "expert",
      "risk_factors": [
        "memory_corruption",
        "arbitrary_code_execution",
        "buffer_overflow",
        "system_crash",
        "use_after_free"
      ],
      "attack_vectors": [
        "memory_manipulation",
        "malicious_input",
        "code_analysis",
        "buffer_overflow",
        "reverse_engineering",
        "fuzzing"
      ],
      "mitigation_strategies": [
        "safe_string_functions",
        "dynamic_analysis",
        "code_review",
        "static_analysis",
        "memory_safety_checks",
        "input_validation",
        "fuzzing",
        "bounds_checking",
        "secure_coding_practices"
      ],
      "code_differences": {
        "has_differences": true,
        "source_lines": 2,
        "target_lines": 2,
        "character_differences": 170,
        "similarity_percentage": 35.41666666666667
      },
      "vulnerability_location": {
        "vulnerability_present": true,
        "fix_applied": true,
        "code_changed": true,
        "estimated_lines_changed": 0
      }
    },
    {
      "cve_id": "CVE-2017-15265",
      "cwe_id": "CWE-416",
      "cwe_name": "Use After Free",
      "project": "torvalds",
      "severity": "critical",
      "weaponization_score": 9.5,
      "is_critical": true,
      "is_weaponizable": true,
      "is_high_priority_project": false,
      "vulnerable_code": "CWE-416 struct snd_seq_client_port * snd_seq_create_port ( struct snd_seq_client * client , int port ) { unsigned long flags ; struct snd_seq_client_port * new_port , * p ; int num = - 1 ; if ( snd_BUG_ON ( ! client ) ) return NULL ; if ( client -> num_ports >= SNDRV_SEQ_MAX_PORTS ) { pr_warn ( \"ALSA:<S2SV_blank>seq:<S2SV_blank>too<S2SV_blank>many<S2SV_blank>ports<S2SV_blank>for<S2SV_blank>client<S2SV_blank>%d\\\\n\" , client -> number ) ; return NULL ; } new_port = kzalloc ( sizeof ( * new_port ) , GFP_KERNEL ) ; if ( ! new_port ) return NULL ; new_port -> addr . client = client -> number ; new_port -> addr . port = - 1 ; new_port -> owner = THIS_MODULE ; sprintf ( new_port -> name , \"port-%d\" , num ) ; snd_use_lock_init ( & new_port -> use_lock ) ; port_subs_info_init ( & new_port -> c_src ) ; port_subs_info_init ( & new_port -> c_dest ) ; <S2SV_StartBug> num = port >= 0 ? port : 0 ; <S2SV_EndBug> mutex_lock ( & client -> ports_mutex ) ; write_lock_irqsave ( & client -> ports_lock , flags ) ; list_for_each_entry ( p , & client -> ports_list_head , list ) { if ( p -> addr . port > num ) break ; if ( port < 0 ) num = p -> addr . port + 1 ; } list_add_tail ( & new_port -> list , & p -> list ) ; client -> num_ports ++ ; new_port -> addr . port = num ; <S2SV_StartBug> write_unlock_irqrestore ( & client -> ports_lock , flags ) ; <S2SV_EndBug> <S2SV_StartBug> mutex_unlock ( & client -> ports_mutex ) ; <S2SV_EndBug> sprintf ( new_port -> name , \"port-%d\" , num ) ; return new_port ; }\n",
      "fixed_code": "<S2SV_ModStart> c_dest ) ; snd_use_lock_use ( & new_port -> use_lock ) ; <S2SV_ModStart> = num ; sprintf ( new_port -> name , \"port-%d\" , num ) ; <S2SV_ModStart> client -> ports_mutex <S2SV_ModEnd> ) ; return\n",
      "source_code_length": 1500,
      "target_code_length": 209,
      "vulnerability_patterns": {
        "buffer_overflow": 2,
        "use_after_free": 15,
        "integer_overflow": 1,
        "format_string": 2,
        "null_pointer": 24,
        "total": 44
      },
      "total_patterns": 44,
      "original_address": "https://github.com/torvalds/linux/commit/71105998845fb012937332fe2e806d443c09e026",
      "discovery_time": "2017-10-16T18:29Z",
      "project_commit_id": "torvalds@linux/71105998845fb012937332fe2e806d443c09e026",
      "extraction_time": "2025-08-31T15:41:49.178745",
      "label": 1,
      "vulnerability_type": "use_after_free",
      "difficulty_level": "expert",
      "risk_factors": [
        "denial_of_service",
        "memory_corruption",
        "buffer_overflow",
        "system_crash",
        "use_after_free"
      ],
      "attack_vectors": [
        "memory_manipulation",
        "null_pointer",
        "code_analysis",
        "reverse_engineering",
        "use_after_free",
        "fuzzing"
      ],
      "mitigation_strategies": [
        "null_pointer_checks",
        "fuzzing",
        "dynamic_analysis",
        "memory_management",
        "static_analysis",
        "use_after_free_prevention",
        "code_review",
        "secure_coding_practices"
      ],
      "code_differences": {
        "has_differences": true,
        "source_lines": 2,
        "target_lines": 2,
        "character_differences": 1291,
        "similarity_percentage": 22.666666666666664
      },
      "vulnerability_location": {
        "vulnerability_present": true,
        "fix_applied": true,
        "code_changed": true,
        "estimated_lines_changed": 0
      }
    },
    {
      "cve_id": "CVE-2018-16643",
      "cwe_id": "CWE-20",
      "cwe_name": "Improper Input Validation",
      "project": "ImageMagick",
      "severity": "critical",
      "weaponization_score": 9.5,
      "is_critical": true,
      "is_weaponizable": true,
      "is_high_priority_project": true,
      "vulnerable_code": "CWE-20 static Image * ReadDCMImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { <S2SV_StartBug> # define ThrowDCMException ( exception , message ) { if ( info . scale != ( Quantum * ) NULL ) info . scale = ( Quantum * ) RelinquishMagickMemory ( info . scale ) ; if ( data != ( unsigned char * ) NULL ) data = ( unsigned char * ) RelinquishMagickMemory ( data ) ; if ( graymap != ( int * ) NULL ) graymap = ( int * ) RelinquishMagickMemory ( graymap ) ; if ( bluemap != ( int * ) NULL ) bluemap = ( int * ) RelinquishMagickMemory ( bluemap ) ; if ( greenmap != ( int * ) NULL ) greenmap = ( int * ) RelinquishMagickMemory ( greenmap ) ; if ( redmap != ( int * ) NULL ) redmap = ( int * ) RelinquishMagickMemory ( redmap ) ; if ( stream_info -> offsets != ( ssize_t * ) NULL ) stream_info -> offsets = ( ssize_t * ) RelinquishMagickMemory ( stream_info -> offsets ) ; if ( stream_info != ( DCMStreamInfo * ) NULL ) stream_info = ( DCMStreamInfo * ) RelinquishMagickMemory ( stream_info ) ; ThrowReaderException ( ( exception ) , ( message ) ) ; } <S2SV_EndBug> char explicit_vr [ MagickPathExtent ] , implicit_vr [ MagickPathExtent ] , magick [ MagickPathExtent ] , photometric [ MagickPathExtent ] ; DCMInfo info ; DCMStreamInfo * stream_info ; Image * image ; int * bluemap , datum , * greenmap , * graymap , * redmap ; MagickBooleanType explicit_file , explicit_retry , use_explicit ; MagickOffsetType offset ; register unsigned char * p ; register ssize_t i ; size_t colors , height , length , number_scenes , quantum , status , width ; ssize_t count , scene ; unsigned char * data ; unsigned short group , element ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickCoreSignature ) ; if ( image_info -> debug != MagickFalse ) ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , \"%s\" , image_info -> filename ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickCoreSignature ) ; image = AcquireImage ( image_info , exception ) ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } image -> depth = 8UL ; image -> endian = LSBEndian ; ( void ) memset ( & info , 0 , sizeof ( info ) ) ; data = ( unsigned char * ) NULL ; graymap = ( int * ) NULL ; redmap = ( int * ) NULL ; greenmap = ( int * ) NULL ; bluemap = ( int * ) NULL ; stream_info = ( DCMStreamInfo * ) AcquireMagickMemory ( sizeof ( * stream_info ) ) ; if ( stream_info == ( DCMStreamInfo * ) NULL ) ThrowDCMException ( ResourceLimitError , \"MemoryAllocationFailed\" ) ; ( void ) memset ( stream_info , 0 , sizeof ( * stream_info ) ) ; count = ReadBlob ( image , 128 , ( unsigned char * ) magick ) ; if ( count != 128 ) ThrowDCMException ( CorruptImageError , \"ImproperImageHeader\" ) ; count = ReadBlob ( image , 4 , ( unsigned char * ) magick ) ; if ( ( count != 4 ) || ( LocaleNCompare ( magick , \"DICM\" , 4 ) != 0 ) ) { offset = SeekBlob ( image , 0L , SEEK_SET ) ; if ( offset < 0 ) ThrowDCMException ( CorruptImageError , \"ImproperImageHeader\" ) ; } ( void ) CopyMagickString ( photometric , \"MONOCHROME1<S2SV_blank>\" , MagickPathExtent ) ; info . bits_allocated = 8 ; info . bytes_per_pixel = 1 ; info . depth = 8 ; info . mask = 0xffff ; info . max_value = 255UL ; info . samples_per_pixel = 1 ; info . signed_data = ( ~ 0UL ) ; info . rescale_slope = 1.0 ; data = ( unsigned char * ) NULL ; element = 0 ; explicit_vr [ 2 ] = '\\\\0' ; explicit_file = MagickFalse ; colors = 0 ; redmap = ( int * ) NULL ; greenmap = ( int * ) NULL ; bluemap = ( int * ) NULL ; graymap = ( int * ) NULL ; height = 0 ; number_scenes = 1 ; use_explicit = MagickFalse ; explicit_retry = MagickFalse ; width = 0 ; while ( TellBlob ( image ) < ( MagickOffsetType ) GetBlobSize ( image ) ) { for ( group = 0 ; ( group != 0x7FE0 ) || ( element != 0x0010 ) ; ) { image -> offset = ( ssize_t ) TellBlob ( image ) ; group = ReadBlobLSBShort ( image ) ; element = ReadBlobLSBShort ( image ) ; if ( ( group == 0xfffc ) && ( element == 0xfffc ) ) break ; if ( ( group != 0x0002 ) && ( image -> endian == MSBEndian ) ) { group = ( unsigned short ) ( ( group << 8 ) | ( ( group >> 8 ) & 0xFF ) ) ; element = ( unsigned short ) ( ( element << 8 ) | ( ( element >> 8 ) & 0xFF ) ) ; } quantum = 0 ; for ( i = 0 ; dicom_info [ i ] . group < 0xffff ; i ++ ) if ( ( group == dicom_info [ i ] . group ) && ( element == dicom_info [ i ] . element ) ) break ; ( void ) CopyMagickString ( implicit_vr , dicom_info [ i ] . vr , MagickPathExtent ) ; count = ReadBlob ( image , 2 , ( unsigned char * ) explicit_vr ) ; if ( count != 2 ) ThrowDCMException ( CorruptImageError , \"ImproperImageHeader\" ) ; if ( ( explicit_file == MagickFalse ) && ( group != 0x0002 ) ) explicit_file = ( isupper ( ( unsigned char ) * explicit_vr ) != MagickFalse ) && ( isupper ( ( unsigned char ) * ( explicit_vr + 1 ) ) != MagickFalse ) ? MagickTrue : MagickFalse ; use_explicit = ( ( group == 0x0002 ) && ( explicit_retry == MagickFalse ) ) || ( explicit_file != MagickFalse ) ? MagickTrue : MagickFalse ; if ( ( use_explicit != MagickFalse ) && ( strncmp ( implicit_vr , \"xs\" , 2 ) == 0 ) ) ( void ) CopyMagickString ( implicit_vr , explicit_vr , MagickPathExtent ) ; if ( ( use_explicit == MagickFalse ) || ( strncmp ( implicit_vr , \"!!\" , 2 ) == 0 ) ) { offset = SeekBlob ( image , ( MagickOffsetType ) - 2 , SEEK_CUR ) ; if ( offset < 0 ) ThrowDCMException ( CorruptImageError , \"ImproperImageHeader\" ) ; quantum = 4 ; } else { quantum = 2 ; if ( ( strncmp ( explicit_vr , \"OB\" , 2 ) == 0 ) || ( strncmp ( explicit_vr , \"UN\" , 2 ) == 0 ) || ( strncmp ( explicit_vr , \"OW\" , 2 ) == 0 ) || ( strncmp ( explicit_vr , \"SQ\" , 2 ) == 0 ) ) { ( void ) ReadBlobLSBShort ( image ) ; quantum = 4 ; } } datum = 0 ; if ( quantum == 4 ) { if ( group == 0x0002 ) datum = ReadBlobLSBSignedLong ( image ) ; else datum = ReadBlobSignedLong ( image ) ; } else if ( quantum == 2 ) { if ( group == 0x0002 ) datum = ReadBlobLSBSignedShort ( image ) ; else datum = ReadBlobSignedShort ( image ) ; } quantum = 0 ; length = 1 ; if ( datum != 0 ) { if ( ( strncmp ( implicit_vr , \"OW\" , 2 ) == 0 ) || ( strncmp ( implicit_vr , \"SS\" , 2 ) == 0 ) || ( strncmp ( implicit_vr , \"US\" , 2 ) == 0 ) ) quantum = 2 ; else if ( ( strncmp ( implicit_vr , \"FL\" , 2 ) == 0 ) || ( strncmp ( implicit_vr , \"OF\" , 2 ) == 0 ) || ( strncmp ( implicit_vr , \"SL\" , 2 ) == 0 ) || ( strncmp ( implicit_vr , \"UL\" , 2 ) == 0 ) ) quantum = 4 ; else if ( strncmp ( implicit_vr , \"FD\" , 2 ) == 0 ) quantum = 8 ; else quantum = 1 ; if ( datum != ~ 0 ) length = ( size_t ) datum / quantum ; else { quantum = 0 ; length = 0 ; } } if ( image_info -> verbose != MagickFalse ) { if ( use_explicit == MagickFalse ) explicit_vr [ 0 ] = '\\\\0' ; for ( i = 0 ; dicom_info [ i ] . description != ( char * ) NULL ; i ++ ) if ( ( group == dicom_info [ i ] . group ) && ( element == dicom_info [ i ] . element ) ) break ; ( void ) FormatLocaleFile ( stdout , \"0x%04lX<S2SV_blank>%4ld<S2SV_blank>%s-%s<S2SV_blank>(0x%04lx,0x%04lx)\" , ( unsigned long ) image -> offset , ( long ) length , implicit_vr , explicit_vr , ( unsigned long ) group , ( unsigned long ) element ) ; if ( dicom_info [ i ] . description != ( char * ) NULL ) ( void ) FormatLocaleFile ( stdout , \"<S2SV_blank>%s\" , dicom_info [ i ] . description ) ; ( void ) FormatLocaleFile ( stdout , \":<S2SV_blank>\" ) ; } if ( ( group == 0x7FE0 ) && ( element == 0x0010 ) ) { if ( image_info -> verbose != MagickFalse ) ( void ) FormatLocaleFile ( stdout , \"\\\\n\" ) ; break ; } data = ( unsigned char * ) NULL ; if ( ( length == 1 ) && ( quantum == 1 ) ) datum = ReadBlobByte ( image ) ; else if ( ( length == 1 ) && ( quantum == 2 ) ) { if ( group == 0x0002 ) datum = ReadBlobLSBSignedShort ( image ) ; else datum = ReadBlobSignedShort ( image ) ; } else if ( ( length == 1 ) && ( quantum == 4 ) ) { if ( group == 0x0002 ) datum = ReadBlobLSBSignedLong ( image ) ; else datum = ReadBlobSignedLong ( image ) ; } else if ( ( quantum != 0 ) && ( length != 0 ) ) { if ( length > ( size_t ) GetBlobSize ( image ) ) ThrowDCMException ( CorruptImageError , \"InsufficientImageDataInFile\" ) ; if ( ~ length >= 1 ) data = ( unsigned char * ) AcquireQuantumMemory ( length + 1 , quantum * sizeof ( * data ) ) ; if ( data == ( unsigned char * ) NULL ) ThrowDCMException ( ResourceLimitError , \"MemoryAllocationFailed\" ) ; count = ReadBlob ( image , ( size_t ) quantum * length , data ) ; if ( count != ( ssize_t ) ( quantum * length ) ) { if ( image_info -> verbose != MagickFalse ) ( void ) FormatLocaleFile ( stdout , \"count=%d<S2SV_blank>quantum=%d<S2SV_blank>\" \"length=%d<S2SV_blank>group=%d\\\\n\" , ( int ) count , ( int ) quantum , ( int ) length , ( int ) group ) ; ThrowDCMException ( CorruptImageError , \"InsufficientImageDataInFile\" ) ; } data [ length * quantum ] = '\\\\0' ; } if ( ( ( ( unsigned int ) group << 16 ) | element ) == 0xFFFEE0DD ) { if ( data != ( unsigned char * ) NULL ) data = ( unsigned char * ) RelinquishMagickMemory ( data ) ; continue ; } switch ( group ) { case 0x0002 : { switch ( element ) { case 0x0010 : { char transfer_syntax [ MagickPathExtent ] ; if ( ( datum == 0 ) && ( explicit_retry == MagickFalse ) ) { explicit_retry = MagickTrue ; ( void ) SeekBlob ( image , ( MagickOffsetType ) 0 , SEEK_SET ) ; group = 0 ; element = 0 ; if ( image_info -> verbose != MagickFalse ) ( void ) FormatLocaleFile ( stdout , \"Corrupted<S2SV_blank>image<S2SV_blank>-<S2SV_blank>trying<S2SV_blank>explicit<S2SV_blank>format\\\\n\" ) ; break ; } * transfer_syntax = '\\\\0' ; if ( data != ( unsigned char * ) NULL ) ( void ) CopyMagickString ( transfer_syntax , ( char * ) data , MagickPathExtent ) ; if ( image_info -> verbose != MagickFalse ) ( void ) FormatLocaleFile ( stdout , \"transfer_syntax=%s\\\\n\" , ( const char * ) transfer_syntax ) ; if ( strncmp ( transfer_syntax , \"1.2.840.10008.1.2\" , 17 ) == 0 ) { int subtype , type ; type = 1 ; subtype = 0 ; if ( strlen ( transfer_syntax ) > 17 ) { count = ( ssize_t ) sscanf ( transfer_syntax + 17 , \".%d.%d\" , & type , & subtype ) ; if ( count < 1 ) ThrowDCMException ( CorruptImageError , \"ImproperImageHeader\" ) ; } switch ( type ) { case 1 : { image -> endian = LSBEndian ; break ; } case 2 : { image -> endian = MSBEndian ; break ; } case 4 : { if ( ( subtype >= 80 ) && ( subtype <= 81 ) ) image -> compression = JPEGCompression ; else if ( ( subtype >= 90 ) && ( subtype <= 93 ) ) image -> compression = JPEG2000Compression ; else image -> compression = JPEGCompression ; break ; } case 5 : { image -> compression = RLECompression ; break ; } } } break ; } default : break ; } break ; } case 0x0028 : { switch ( element ) { case 0x0002 : { info . samples_per_pixel = ( size_t ) datum ; if ( ( info . samples_per_pixel == 0 ) || ( info . samples_per_pixel > 4 ) ) ThrowDCMException ( CorruptImageError , \"ImproperImageHeader\" ) ; break ; } case 0x0004 : { if ( data == ( unsigned char * ) NULL ) break ; for ( i = 0 ; i < ( ssize_t ) MagickMin ( length , MagickPathExtent - 1 ) ; i ++ ) photometric [ i ] = ( char ) data [ i ] ; photometric [ i ] = '\\\\0' ; info . polarity = LocaleCompare ( photometric , \"MONOCHROME1<S2SV_blank>\" ) == 0 ? MagickTrue : MagickFalse ; break ; } case 0x0006 : { if ( datum == 1 ) image -> interlace = PlaneInterlace ; break ; } case 0x0008 : { if ( data == ( unsigned char * ) NULL ) break ; number_scenes = StringToUnsignedLong ( ( char * ) data ) ; break ; } case 0x0010 : { height = ( size_t ) datum ; break ; } case 0x0011 : { width = ( size_t ) datum ; break ; } case 0x0100 : { info . bits_allocated = ( size_t ) datum ; info . bytes_per_pixel = 1 ; if ( datum > 8 ) info . bytes_per_pixel = 2 ; info . depth = info . bits_allocated ; if ( ( info . depth == 0 ) || ( info . depth > 32 ) ) ThrowDCMException ( CorruptImageError , \"ImproperImageHeader\" ) ; info . max_value = ( 1UL << info . bits_allocated ) - 1 ; image -> depth = info . depth ; break ; } case 0x0101 : { info . significant_bits = ( size_t ) datum ; info . bytes_per_pixel = 1 ; if ( info . significant_bits > 8 ) info . bytes_per_pixel = 2 ; info . depth = info . significant_bits ; if ( ( info . depth == 0 ) || ( info . depth > 16 ) ) ThrowDCMException ( CorruptImageError , \"ImproperImageHeader\" ) ; info . max_value = ( 1UL << info . significant_bits ) - 1 ; info . mask = ( size_t ) GetQuantumRange ( info . significant_bits ) ; image -> depth = info . depth ; break ; } case 0x0102 : { break ; } case 0x0103 : { info . signed_data = ( size_t ) datum ; break ; } case 0x1050 : { if ( data != ( unsigned char * ) NULL ) info . window_center = StringToDouble ( ( char * ) data , ( char * * ) NULL ) ; break ; } case 0x1051 : { if ( data != ( unsigned char * ) NULL ) info . window_width = StringToDouble ( ( char * ) data , ( char * * ) NULL ) ; break ; } case 0x1052 : { if ( data != ( unsigned char * ) NULL ) info . rescale_intercept = StringToDouble ( ( char * ) data , ( char * * ) NULL ) ; break ; } case 0x1053 : { if ( data != ( unsigned char * ) NULL ) info . rescale_slope = StringToDouble ( ( char * ) data , ( char * * ) NULL ) ; break ; } case 0x1200 : case 0x3006 : { if ( data == ( unsigned char * ) NULL ) break ; colors = ( size_t ) ( length / info . bytes_per_pixel ) ; datum = ( int ) colors ; if ( graymap != ( int * ) NULL ) graymap = ( int * ) RelinquishMagickMemory ( graymap ) ; graymap = ( int * ) AcquireQuantumMemory ( MagickMax ( colors , 65536 ) , sizeof ( * graymap ) ) ; if ( graymap == ( int * ) NULL ) ThrowDCMException ( ResourceLimitError , \"MemoryAllocationFailed\" ) ; ( void ) memset ( graymap , 0 , MagickMax ( colors , 65536 ) * sizeof ( * graymap ) ) ; for ( i = 0 ; i < ( ssize_t ) colors ; i ++ ) if ( info . bytes_per_pixel == 1 ) graymap [ i ] = ( int ) data [ i ] ; else graymap [ i ] = ( int ) ( ( short * ) data ) [ i ] ; break ; } case 0x1201 : { unsigned short index ; if ( data == ( unsigned char * ) NULL ) break ; colors = ( size_t ) ( length / 2 ) ; datum = ( int ) colors ; if ( redmap != ( int * ) NULL ) redmap = ( int * ) RelinquishMagickMemory ( redmap ) ; redmap = ( int * ) AcquireQuantumMemory ( MagickMax ( colors , 65536 ) , sizeof ( * redmap ) ) ; if ( redmap == ( int * ) NULL ) ThrowDCMException ( ResourceLimitError , \"MemoryAllocationFailed\" ) ; ( void ) memset ( redmap , 0 , MagickMax ( colors , 65536 ) * sizeof ( * redmap ) ) ; p = data ; for ( i = 0 ; i < ( ssize_t ) colors ; i ++ ) { if ( image -> endian == MSBEndian ) index = ( unsigned short ) ( ( * p << 8 ) | * ( p + 1 ) ) ; else index = ( unsigned short ) ( * p | ( * ( p + 1 ) << 8 ) ) ; redmap [ i ] = ( int ) index ; p += 2 ; } break ; } case 0x1202 : { unsigned short index ; if ( data == ( unsigned char * ) NULL ) break ; colors = ( size_t ) ( length / 2 ) ; datum = ( int ) colors ; if ( greenmap != ( int * ) NULL ) greenmap = ( int * ) RelinquishMagickMemory ( greenmap ) ; greenmap = ( int * ) AcquireQuantumMemory ( MagickMax ( colors , 65536 ) , sizeof ( * greenmap ) ) ; if ( greenmap == ( int * ) NULL ) ThrowDCMException ( ResourceLimitError , \"MemoryAllocationFailed\" ) ; ( void ) memset ( greenmap , 0 , MagickMax ( colors , 65536 ) * sizeof ( * greenmap ) ) ; p = data ; for ( i = 0 ; i < ( ssize_t ) colors ; i ++ ) { if ( image -> endian == MSBEndian ) index = ( unsigned short ) ( ( * p << 8 ) | * ( p + 1 ) ) ; else index = ( unsigned short ) ( * p | ( * ( p + 1 ) << 8 ) ) ; greenmap [ i ] = ( int ) index ; p += 2 ; } break ; } case 0x1203 : { unsigned short index ; if ( data == ( unsigned char * ) NULL ) break ; colors = ( size_t ) ( length / 2 ) ; datum = ( int ) colors ; if ( bluemap != ( int * ) NULL ) bluemap = ( int * ) RelinquishMagickMemory ( bluemap ) ; bluemap = ( int * ) AcquireQuantumMemory ( MagickMax ( colors , 65536 ) , sizeof ( * bluemap ) ) ; if ( bluemap == ( int * ) NULL ) ThrowDCMException ( ResourceLimitError , \"MemoryAllocationFailed\" ) ; ( void ) memset ( bluemap , 0 , MagickMax ( colors , 65536 ) * sizeof ( * bluemap ) ) ; p = data ; for ( i = 0 ; i < ( ssize_t ) colors ; i ++ ) { if ( image -> endian == MSBEndian ) index = ( unsigned short ) ( ( * p << 8 ) | * ( p + 1 ) ) ; else index = ( unsigned short ) ( * p | ( * ( p + 1 ) << 8 ) ) ; bluemap [ i ] = ( int ) index ; p += 2 ; } break ; } default : break ; } break ; } case 0x2050 : { switch ( element ) { case 0x0020 : { if ( ( data != ( unsigned char * ) NULL ) && ( strncmp ( ( char * ) data , \"INVERSE\" , 7 ) == 0 ) ) info . polarity = MagickTrue ; break ; } default : break ; } break ; } default : break ; } if ( data != ( unsigned char * ) NULL ) { char * attribute ; for ( i = 0 ; dicom_info [ i ] . description != ( char * ) NULL ; i ++ ) if ( ( group == dicom_info [ i ] . group ) && ( element == dicom_info [ i ] . element ) ) break ; if ( dicom_info [ i ] . description != ( char * ) NULL ) { attribute = AcquireString ( \"dcm:\" ) ; ( void ) ConcatenateString ( & attribute , dicom_info [ i ] . description ) ; for ( i = 0 ; i < ( ssize_t ) MagickMax ( length , 4 ) ; i ++ ) if ( isprint ( ( int ) data [ i ] ) == MagickFalse ) break ; if ( ( i == ( ssize_t ) length ) || ( length > 4 ) ) { ( void ) SubstituteString ( & attribute , \"<S2SV_blank>\" , \"\" ) ; ( void ) SetImageProperty ( image , attribute , ( char * ) data , exception ) ; } attribute = DestroyString ( attribute ) ; } } if ( image_info -> verbose != MagickFalse ) { if ( data == ( unsigned char * ) NULL ) ( void ) FormatLocaleFile ( stdout , \"%d\\\\n\" , datum ) ; else { for ( i = 0 ; i < ( ssize_t ) MagickMax ( length , 4 ) ; i ++ ) if ( isprint ( ( int ) data [ i ] ) == MagickFalse ) break ; if ( ( i != ( ssize_t ) length ) && ( length <= 4 ) ) { ssize_t j ; datum = 0 ; for ( j = ( ssize_t ) length - 1 ; j >= 0 ; j -- ) datum = ( 256 * datum + data [ j ] ) ; ( void ) FormatLocaleFile ( stdout , \"%d\" , datum ) ; } else for ( i = 0 ; i < ( ssize_t ) length ; i ++ ) if ( isprint ( ( int ) data [ i ] ) != MagickFalse ) ( void ) FormatLocaleFile ( stdout , \"%c\" , data [ i ] ) ; else ( void ) FormatLocaleFile ( stdout , \"%c\" , '.' ) ; ( void ) FormatLocaleFile ( stdout , \"\\\\n\" ) ; } } if ( data != ( unsigned char * ) NULL ) data = ( unsigned char * ) RelinquishMagickMemory ( data ) ; if ( EOFBlob ( image ) != MagickFalse ) { ThrowFileException ( exception , CorruptImageError , \"UnexpectedEndOfFile\" , image -> filename ) ; break ; } } if ( ( group == 0xfffc ) && ( element == 0xfffc ) ) { Image * last ; last = RemoveLastImageFromList ( & image ) ; if ( last != ( Image * ) NULL ) last = DestroyImage ( last ) ; break ; } if ( ( width == 0 ) || ( height == 0 ) ) ThrowDCMException ( CorruptImageError , \"ImproperImageHeader\" ) ; image -> columns = ( size_t ) width ; image -> rows = ( size_t ) height ; if ( info . signed_data == 0xffff ) info . signed_data = ( size_t ) ( info . significant_bits == 16 ? 1 : 0 ) ; if ( ( image -> compression == JPEGCompression ) || ( image -> compression == JPEG2000Compression ) ) { Image * images ; ImageInfo * read_info ; int c ; for ( i = 0 ; i < ( ssize_t ) stream_info -> remaining ; i ++ ) if ( ReadBlobByte ( image ) == EOF ) break ; ( void ) ( ( ( ssize_t ) ReadBlobLSBShort ( image ) << 16 ) | ReadBlobLSBShort ( image ) ) ; length = ( size_t ) ReadBlobLSBLong ( image ) ; if ( length > ( size_t ) GetBlobSize ( image ) ) ThrowDCMException ( CorruptImageError , \"InsufficientImageDataInFile\" ) ; stream_info -> offset_count = length >> 2 ; if ( stream_info -> offset_count != 0 ) { if ( stream_info -> offsets != ( ssize_t * ) NULL ) stream_info -> offsets = ( ssize_t * ) RelinquishMagickMemory ( stream_info -> offsets ) ; stream_info -> offsets = ( ssize_t * ) AcquireQuantumMemory ( stream_info -> offset_count , sizeof ( * stream_info -> offsets ) ) ; if ( stream_info -> offsets == ( ssize_t * ) NULL ) ThrowDCMException ( ResourceLimitError , \"MemoryAllocationFailed\" ) ; for ( i = 0 ; i < ( ssize_t ) stream_info -> offset_count ; i ++ ) stream_info -> offsets [ i ] = ( ssize_t ) ReadBlobLSBSignedLong ( image ) ; offset = TellBlob ( image ) ; for ( i = 0 ; i < ( ssize_t ) stream_info -> offset_count ; i ++ ) stream_info -> offsets [ i ] += offset ; } read_info = CloneImageInfo ( image_info ) ; SetImageInfoBlob ( read_info , ( void * ) NULL , 0 ) ; images = NewImageList ( ) ; for ( scene = 0 ; scene < ( ssize_t ) number_scenes ; scene ++ ) { char filename [ MagickPathExtent ] ; const char * property ; FILE * file ; Image * jpeg_image ; int unique_file ; unsigned int tag ; tag = ( ( unsigned int ) ReadBlobLSBShort ( image ) << 16 ) | ReadBlobLSBShort ( image ) ; length = ( size_t ) ReadBlobLSBLong ( image ) ; if ( tag == 0xFFFEE0DD ) break ; if ( tag != 0xFFFEE000 ) { read_info = DestroyImageInfo ( read_info ) ; ThrowDCMException ( CorruptImageError , \"ImproperImageHeader\" ) ; } file = ( FILE * ) NULL ; unique_file = AcquireUniqueFileResource ( filename ) ; if ( unique_file != - 1 ) file = fdopen ( unique_file , \"wb\" ) ; if ( file == ( FILE * ) NULL ) { ( void ) RelinquishUniqueFileResource ( filename ) ; ThrowFileException ( exception , FileOpenError , \"UnableToCreateTemporaryFile\" , filename ) ; break ; } for ( c = EOF ; length != 0 ; length -- ) { c = ReadBlobByte ( image ) ; if ( c == EOF ) { ThrowFileException ( exception , CorruptImageError , \"UnexpectedEndOfFile\" , image -> filename ) ; break ; } <S2SV_StartBug> ( void ) fputc ( c , file ) ; <S2SV_EndBug> } ( void ) fclose ( file ) ; if ( c == EOF ) break ; ( void ) FormatLocaleString ( read_info -> filename , MagickPathExtent , \"jpeg:%s\" , filename ) ; if ( image -> compression == JPEG2000Compression ) ( void ) FormatLocaleString ( read_info -> filename , MagickPathExtent , \"j2k:%s\" , filename ) ; jpeg_image = ReadImage ( read_info , exception ) ; if ( jpeg_image != ( Image * ) NULL ) { ResetImagePropertyIterator ( image ) ; property = GetNextImageProperty ( image ) ; while ( property != ( const char * ) NULL ) { ( void ) SetImageProperty ( jpeg_image , property , GetImageProperty ( image , property , exception ) , exception ) ; property = GetNextImageProperty ( image ) ; } AppendImageToList ( & images , jpeg_image ) ; } ( void ) RelinquishUniqueFileResource ( filename ) ; } read_info = DestroyImageInfo ( read_info ) ; if ( stream_info -> offsets != ( ssize_t * ) NULL ) stream_info -> offsets = ( ssize_t * ) RelinquishMagickMemory ( stream_info -> offsets ) ; stream_info = ( DCMStreamInfo * ) RelinquishMagickMemory ( stream_info ) ; if ( info . scale != ( Quantum * ) NULL ) info . scale = ( Quantum * ) RelinquishMagickMemory ( info . scale ) ; if ( graymap != ( int * ) NULL ) graymap = ( int * ) RelinquishMagickMemory ( graymap ) ; if ( bluemap != ( int * ) NULL ) bluemap = ( int * ) RelinquishMagickMemory ( bluemap ) ; if ( greenmap != ( int * ) NULL ) greenmap = ( int * ) RelinquishMagickMemory ( greenmap ) ; if ( redmap != ( int * ) NULL ) redmap = ( int * ) RelinquishMagickMemory ( redmap ) ; image = DestroyImageList ( image ) ; return ( GetFirstImageInList ( images ) ) ; } if ( info . depth != ( 1UL * MAGICKCORE_QUANTUM_DEPTH ) ) { QuantumAny range ; length = ( size_t ) ( GetQuantumRange ( info . depth ) + 1 ) ; if ( length > ( size_t ) GetBlobSize ( image ) ) ThrowDCMException ( CorruptImageError , \"InsufficientImageDataInFile\" ) ; if ( info . scale != ( Quantum * ) NULL ) info . scale = ( Quantum * ) RelinquishMagickMemory ( info . scale ) ; info . scale = ( Quantum * ) AcquireQuantumMemory ( MagickMax ( length , 256 ) , sizeof ( * info . scale ) ) ; if ( info . scale == ( Quantum * ) NULL ) ThrowDCMException ( ResourceLimitError , \"MemoryAllocationFailed\" ) ; ( void ) memset ( info . scale , 0 , MagickMax ( length , 256 ) * sizeof ( * info . scale ) ) ; range = GetQuantumRange ( info . depth ) ; for ( i = 0 ; i <= ( ssize_t ) GetQuantumRange ( info . depth ) ; i ++ ) info . scale [ i ] = ScaleAnyToQuantum ( ( size_t ) i , range ) ; } if ( image -> compression == RLECompression ) { unsigned int tag ; for ( i = 0 ; i < ( ssize_t ) stream_info -> remaining ; i ++ ) { int c ; c = ReadBlobByte ( image ) ; if ( c == EOF ) break ; } tag = ( ( unsigned int ) ReadBlobLSBShort ( image ) << 16 ) | ReadBlobLSBShort ( image ) ; ( void ) tag ; length = ( size_t ) ReadBlobLSBLong ( image ) ; if ( length > ( size_t ) GetBlobSize ( image ) ) ThrowDCMException ( CorruptImageError , \"InsufficientImageDataInFile\" ) ; stream_info -> offset_count = length >> 2 ; if ( stream_info -> offset_count != 0 ) { stream_info -> offsets = ( ssize_t * ) AcquireQuantumMemory ( stream_info -> offset_count , sizeof ( * stream_info -> offsets ) ) ; if ( stream_info -> offsets == ( ssize_t * ) NULL ) ThrowDCMException ( ResourceLimitError , \"MemoryAllocationFailed\" ) ; for ( i = 0 ; i < ( ssize_t ) stream_info -> offset_count ; i ++ ) { stream_info -> offsets [ i ] = ( ssize_t ) ReadBlobLSBSignedLong ( image ) ; if ( EOFBlob ( image ) != MagickFalse ) break ; } offset = TellBlob ( image ) + 8 ; for ( i = 0 ; i < ( ssize_t ) stream_info -> offset_count ; i ++ ) stream_info -> offsets [ i ] += offset ; } } for ( scene = 0 ; scene < ( ssize_t ) number_scenes ; scene ++ ) { if ( image_info -> ping != MagickFalse ) break ; image -> columns = ( size_t ) width ; image -> rows = ( size_t ) height ; image -> depth = info . depth ; status = SetImageExtent ( image , image -> columns , image -> rows , exception ) ; if ( status == MagickFalse ) break ; image -> colorspace = RGBColorspace ; ( void ) SetImageBackgroundColor ( image , exception ) ; if ( ( image -> colormap == ( PixelInfo * ) NULL ) && ( info . samples_per_pixel == 1 ) ) { int index ; size_t one ; one = 1 ; if ( colors == 0 ) colors = one << info . depth ; if ( AcquireImageColormap ( image , colors , exception ) == MagickFalse ) ThrowDCMException ( ResourceLimitError , \"MemoryAllocationFailed\" ) ; if ( redmap != ( int * ) NULL ) for ( i = 0 ; i < ( ssize_t ) colors ; i ++ ) { index = redmap [ i ] ; if ( ( info . scale != ( Quantum * ) NULL ) && ( index >= 0 ) && ( index <= ( int ) info . max_value ) ) index = ( int ) info . scale [ index ] ; image -> colormap [ i ] . red = ( MagickRealType ) index ; } if ( greenmap != ( int * ) NULL ) for ( i = 0 ; i < ( ssize_t ) colors ; i ++ ) { index = greenmap [ i ] ; if ( ( info . scale != ( Quantum * ) NULL ) && ( index >= 0 ) && ( index <= ( int ) info . max_value ) ) index = ( int ) info . scale [ index ] ; image -> colormap [ i ] . green = ( MagickRealType ) index ; } if ( bluemap != ( int * ) NULL ) for ( i = 0 ; i < ( ssize_t ) colors ; i ++ ) { index = bluemap [ i ] ; if ( ( info . scale != ( Quantum * ) NULL ) && ( index >= 0 ) && ( index <= ( int ) info . max_value ) ) index = ( int ) info . scale [ index ] ; image -> colormap [ i ] . blue = ( MagickRealType ) index ; } if ( graymap != ( int * ) NULL ) for ( i = 0 ; i < ( ssize_t ) colors ; i ++ ) { index = graymap [ i ] ; if ( ( info . scale != ( Quantum * ) NULL ) && ( index >= 0 ) && ( index <= ( int ) info . max_value ) ) index = ( int ) info . scale [ index ] ; image -> colormap [ i ] . red = ( MagickRealType ) index ; image -> colormap [ i ] . green = ( MagickRealType ) index ; image -> colormap [ i ] . blue = ( MagickRealType ) index ; } } if ( image -> compression == RLECompression ) { unsigned int tag ; for ( i = 0 ; i < ( ssize_t ) stream_info -> remaining ; i ++ ) { int c ; c = ReadBlobByte ( image ) ; if ( c == EOF ) break ; } tag = ( ( unsigned int ) ReadBlobLSBShort ( image ) << 16 ) | ReadBlobLSBShort ( image ) ; stream_info -> remaining = ( size_t ) ReadBlobLSBLong ( image ) ; if ( ( tag != 0xFFFEE000 ) || ( stream_info -> remaining <= 64 ) || ( EOFBlob ( image ) != MagickFalse ) ) { if ( stream_info -> offsets != ( ssize_t * ) NULL ) stream_info -> offsets = ( ssize_t * ) RelinquishMagickMemory ( stream_info -> offsets ) ; ThrowDCMException ( CorruptImageError , \"ImproperImageHeader\" ) ; } stream_info -> count = 0 ; stream_info -> segment_count = ReadBlobLSBLong ( image ) ; for ( i = 0 ; i < 15 ; i ++ ) stream_info -> segments [ i ] = ( ssize_t ) ReadBlobLSBSignedLong ( image ) ; stream_info -> remaining -= 64 ; if ( stream_info -> segment_count > 1 ) { info . bytes_per_pixel = 1 ; info . depth = 8 ; if ( stream_info -> offset_count > 0 ) ( void ) SeekBlob ( image , ( MagickOffsetType ) stream_info -> offsets [ 0 ] + stream_info -> segments [ 0 ] , SEEK_SET ) ; } } if ( ( info . samples_per_pixel > 1 ) && ( image -> interlace == PlaneInterlace ) ) { register ssize_t x ; register Quantum * q ; ssize_t y ; for ( i = 0 ; i < ( ssize_t ) info . samples_per_pixel ; i ++ ) { for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { q = GetAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { switch ( ( int ) i ) { case 0 : { SetPixelRed ( image , ScaleCharToQuantum ( ( unsigned char ) ReadDCMByte ( stream_info , image ) ) , q ) ; break ; } case 1 : { SetPixelGreen ( image , ScaleCharToQuantum ( ( unsigned char ) ReadDCMByte ( stream_info , image ) ) , q ) ; break ; } case 2 : { SetPixelBlue ( image , ScaleCharToQuantum ( ( unsigned char ) ReadDCMByte ( stream_info , image ) ) , q ) ; break ; } case 3 : { SetPixelAlpha ( image , ScaleCharToQuantum ( ( unsigned char ) ReadDCMByte ( stream_info , image ) ) , q ) ; break ; } default : break ; } q += GetPixelChannels ( image ) ; } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ; if ( status == MagickFalse ) break ; } } } } else { const char * option ; option = GetImageOption ( image_info , \"dcm:display-range\" ) ; if ( option != ( const char * ) NULL ) { if ( LocaleCompare ( option , \"reset\" ) == 0 ) info . window_width = 0 ; } option = GetImageOption ( image_info , \"dcm:window\" ) ; if ( option != ( char * ) NULL ) { GeometryInfo geometry_info ; MagickStatusType flags ; flags = ParseGeometry ( option , & geometry_info ) ; if ( flags & RhoValue ) info . window_center = geometry_info . rho ; if ( flags & SigmaValue ) info . window_width = geometry_info . sigma ; info . rescale = MagickTrue ; } option = GetImageOption ( image_info , \"dcm:rescale\" ) ; if ( option != ( char * ) NULL ) info . rescale = IsStringTrue ( option ) ; if ( ( info . window_center != 0 ) && ( info . window_width == 0 ) ) info . window_width = info . window_center ; status = ReadDCMPixels ( image , & info , stream_info , MagickTrue , exception ) ; if ( ( status != MagickFalse ) && ( stream_info -> segment_count > 1 ) ) { if ( stream_info -> offset_count > 0 ) ( void ) SeekBlob ( image , ( MagickOffsetType ) stream_info -> offsets [ 0 ] + stream_info -> segments [ 1 ] , SEEK_SET ) ; ( void ) ReadDCMPixels ( image , & info , stream_info , MagickFalse , exception ) ; } } if ( SetImageGray ( image , exception ) != MagickFalse ) ( void ) SetImageColorspace ( image , GRAYColorspace , exception ) ; if ( EOFBlob ( image ) != MagickFalse ) { ThrowFileException ( exception , CorruptImageError , \"UnexpectedEndOfFile\" , image -> filename ) ; break ; } if ( image_info -> number_scenes != 0 ) if ( image -> scene >= ( image_info -> scene + image_info -> number_scenes - 1 ) ) break ; if ( scene < ( ssize_t ) ( number_scenes - 1 ) ) { AcquireNextImage ( image_info , image , exception ) ; if ( GetNextImageInList ( image ) == ( Image * ) NULL ) { status = MagickFalse ; break ; } image = SyncNextImageInList ( image ) ; status = SetImageProgress ( image , LoadImagesTag , TellBlob ( image ) , GetBlobSize ( image ) ) ; if ( status == MagickFalse ) break ; } } if ( TellBlob ( image ) < ( MagickOffsetType ) GetBlobSize ( image ) ) { AcquireNextImage ( image_info , image , exception ) ; if ( GetNextImageInList ( image ) == ( Image * ) NULL ) { status = MagickFalse ; break ; } image = SyncNextImageInList ( image ) ; status = SetImageProgress ( image , LoadImagesTag , TellBlob ( image ) , GetBlobSize ( image ) ) ; if ( status == MagickFalse ) break ; } } if ( stream_info -> offsets != ( ssize_t * ) NULL ) stream_info -> offsets = ( ssize_t * ) RelinquishMagickMemory ( stream_info -> offsets ) ; stream_info = ( DCMStreamInfo * ) RelinquishMagickMemory ( stream_info ) ; if ( info . scale != ( Quantum * ) NULL ) info . scale = ( Quantum * ) RelinquishMagickMemory ( info . scale ) ; if ( graymap != ( int * ) NULL ) graymap = ( int * ) RelinquishMagickMemory ( graymap ) ; if ( bluemap != ( int * ) NULL ) bluemap = ( int * ) RelinquishMagickMemory ( bluemap ) ; if ( greenmap != ( int * ) NULL ) greenmap = ( int * ) RelinquishMagickMemory ( greenmap ) ; if ( redmap != ( int * ) NULL ) redmap = ( int * ) RelinquishMagickMemory ( redmap ) ; ( void ) CloseBlob ( image ) ; if ( status == MagickFalse ) return ( DestroyImageList ( image ) ) ; return ( GetFirstImageInList ( image ) ) ; }\n",
      "fixed_code": "<S2SV_ModStart> , message ) \\\\\\n{ <S2SV_ModEnd> if ( info <S2SV_ModStart> ) ) ; \\\\\\n} <S2SV_ModEnd> char explicit_vr [ <S2SV_ModStart> break ; } if ( <S2SV_ModEnd> fputc ( c <S2SV_ModStart> , file ) != c ) break\n",
      "source_code_length": 32856,
      "target_code_length": 212,
      "vulnerability_patterns": {
        "buffer_overflow": 7,
        "use_after_free": 1,
        "integer_overflow": 38,
        "null_pointer": 115,
        "total": 161
      },
      "total_patterns": 161,
      "original_address": "https://github.com/ImageMagick/ImageMagick/commit/6b6bff054d569a77973f2140c0e86366e6168a6c",
      "discovery_time": "2018-09-06T22:29Z",
      "project_commit_id": "ImageMagick@ImageMagick/6b6bff054d569a77973f2140c0e86366e6168a6c",
      "extraction_time": "2025-08-31T15:41:49.178767",
      "label": 1,
      "vulnerability_type": "improper_input_validation",
      "difficulty_level": "expert",
      "risk_factors": [
        "critical_infrastructure",
        "buffer_overflow",
        "use_after_free"
      ],
      "attack_vectors": [
        "fuzzing",
        "code_analysis",
        "reverse_engineering"
      ],
      "mitigation_strategies": [
        "dynamic_analysis",
        "static_analysis",
        "fuzzing",
        "code_review",
        "secure_coding_practices"
      ],
      "code_differences": {
        "has_differences": true,
        "source_lines": 2,
        "target_lines": 2,
        "character_differences": 32644,
        "similarity_percentage": 4.092071611253197
      },
      "vulnerability_location": {
        "vulnerability_present": true,
        "fix_applied": true,
        "code_changed": true,
        "estimated_lines_changed": 0
      }
    },
    {
      "cve_id": "CVE-2017-3733",
      "cwe_id": "CWE-20",
      "cwe_name": "Improper Input Validation",
      "project": "openssl",
      "severity": "critical",
      "weaponization_score": 9.5,
      "is_critical": true,
      "is_weaponizable": true,
      "is_high_priority_project": true,
      "vulnerable_code": "CWE-20 int tls1_change_cipher_state ( SSL * s , int which ) { unsigned char * p , * mac_secret ; unsigned char tmp1 [ EVP_MAX_KEY_LENGTH ] ; unsigned char tmp2 [ EVP_MAX_KEY_LENGTH ] ; unsigned char iv1 [ EVP_MAX_IV_LENGTH * 2 ] ; unsigned char iv2 [ EVP_MAX_IV_LENGTH * 2 ] ; unsigned char * ms , * key , * iv ; EVP_CIPHER_CTX * dd ; const EVP_CIPHER * c ; # ifndef OPENSSL_NO_COMP const SSL_COMP * comp ; # endif const EVP_MD * m ; int mac_type ; int * mac_secret_size ; EVP_MD_CTX * mac_ctx ; EVP_PKEY * mac_key ; int n , i , j , k , cl ; int reuse_dd = 0 ; c = s -> s3 -> tmp . new_sym_enc ; m = s -> s3 -> tmp . new_hash ; mac_type = s -> s3 -> tmp . new_mac_pkey_type ; # ifndef OPENSSL_NO_COMP comp = s -> s3 -> tmp . new_compression ; # endif if ( which & SSL3_CC_READ ) { <S2SV_StartBug> if ( s -> s3 -> tmp . new_cipher -> algorithm2 & TLS1_STREAM_MAC ) <S2SV_EndBug> s -> mac_flags |= SSL_MAC_FLAG_READ_MAC_STREAM ; else s -> mac_flags &= ~ SSL_MAC_FLAG_READ_MAC_STREAM ; if ( s -> enc_read_ctx != NULL ) reuse_dd = 1 ; else if ( ( s -> enc_read_ctx = EVP_CIPHER_CTX_new ( ) ) == NULL ) goto err ; else EVP_CIPHER_CTX_reset ( s -> enc_read_ctx ) ; dd = s -> enc_read_ctx ; mac_ctx = ssl_replace_hash ( & s -> read_hash , NULL ) ; if ( mac_ctx == NULL ) goto err ; # ifndef OPENSSL_NO_COMP COMP_CTX_free ( s -> expand ) ; s -> expand = NULL ; if ( comp != NULL ) { s -> expand = COMP_CTX_new ( comp -> method ) ; if ( s -> expand == NULL ) { SSLerr ( SSL_F_TLS1_CHANGE_CIPHER_STATE , SSL_R_COMPRESSION_LIBRARY_ERROR ) ; goto err2 ; } } # endif if ( ! SSL_IS_DTLS ( s ) ) RECORD_LAYER_reset_read_sequence ( & s -> rlayer ) ; mac_secret = & ( s -> s3 -> read_mac_secret [ 0 ] ) ; mac_secret_size = & ( s -> s3 -> read_mac_secret_size ) ; <S2SV_StartBug> } else { <S2SV_EndBug> if ( s -> s3 -> tmp . new_cipher -> algorithm2 & TLS1_STREAM_MAC ) s -> mac_flags |= SSL_MAC_FLAG_WRITE_MAC_STREAM ; else s -> mac_flags &= ~ SSL_MAC_FLAG_WRITE_MAC_STREAM ; if ( s -> enc_write_ctx != NULL && ! SSL_IS_DTLS ( s ) ) reuse_dd = 1 ; else if ( ( s -> enc_write_ctx = EVP_CIPHER_CTX_new ( ) ) == NULL ) goto err ; dd = s -> enc_write_ctx ; if ( SSL_IS_DTLS ( s ) ) { mac_ctx = EVP_MD_CTX_new ( ) ; if ( mac_ctx == NULL ) goto err ; s -> write_hash = mac_ctx ; } else { mac_ctx = ssl_replace_hash ( & s -> write_hash , NULL ) ; if ( mac_ctx == NULL ) goto err ; } # ifndef OPENSSL_NO_COMP COMP_CTX_free ( s -> compress ) ; s -> compress = NULL ; if ( comp != NULL ) { s -> compress = COMP_CTX_new ( comp -> method ) ; if ( s -> compress == NULL ) { SSLerr ( SSL_F_TLS1_CHANGE_CIPHER_STATE , SSL_R_COMPRESSION_LIBRARY_ERROR ) ; goto err2 ; } } # endif if ( ! SSL_IS_DTLS ( s ) ) RECORD_LAYER_reset_write_sequence ( & s -> rlayer ) ; mac_secret = & ( s -> s3 -> write_mac_secret [ 0 ] ) ; mac_secret_size = & ( s -> s3 -> write_mac_secret_size ) ; } if ( reuse_dd ) EVP_CIPHER_CTX_reset ( dd ) ; p = s -> s3 -> tmp . key_block ; i = * mac_secret_size = s -> s3 -> tmp . new_mac_secret_size ; cl = EVP_CIPHER_key_length ( c ) ; j = cl ; if ( EVP_CIPHER_mode ( c ) == EVP_CIPH_GCM_MODE ) k = EVP_GCM_TLS_FIXED_IV_LEN ; else if ( EVP_CIPHER_mode ( c ) == EVP_CIPH_CCM_MODE ) k = EVP_CCM_TLS_FIXED_IV_LEN ; else k = EVP_CIPHER_iv_length ( c ) ; if ( ( which == SSL3_CHANGE_CIPHER_CLIENT_WRITE ) || ( which == SSL3_CHANGE_CIPHER_SERVER_READ ) ) { ms = & ( p [ 0 ] ) ; n = i + i ; key = & ( p [ n ] ) ; n += j + j ; iv = & ( p [ n ] ) ; n += k + k ; } else { n = i ; ms = & ( p [ n ] ) ; n += i + j ; key = & ( p [ n ] ) ; n += j + k ; iv = & ( p [ n ] ) ; n += k ; } if ( n > s -> s3 -> tmp . key_block_length ) { SSLerr ( SSL_F_TLS1_CHANGE_CIPHER_STATE , ERR_R_INTERNAL_ERROR ) ; goto err2 ; } memcpy ( mac_secret , ms , i ) ; if ( ! ( EVP_CIPHER_flags ( c ) & EVP_CIPH_FLAG_AEAD_CIPHER ) ) { mac_key = EVP_PKEY_new_mac_key ( mac_type , NULL , mac_secret , * mac_secret_size ) ; if ( mac_key == NULL || EVP_DigestSignInit ( mac_ctx , NULL , m , NULL , mac_key ) <= 0 ) { EVP_PKEY_free ( mac_key ) ; SSLerr ( SSL_F_TLS1_CHANGE_CIPHER_STATE , ERR_R_INTERNAL_ERROR ) ; goto err2 ; } EVP_PKEY_free ( mac_key ) ; } # ifdef SSL_DEBUG printf ( \"which<S2SV_blank>=<S2SV_blank>%04X\\\\nmac<S2SV_blank>key=\" , which ) ; { int z ; for ( z = 0 ; z < i ; z ++ ) printf ( \"%02X%c\" , ms [ z ] , ( ( z + 1 ) % 16 ) ? '<S2SV_blank>' : '\\\\n' ) ; } # endif if ( EVP_CIPHER_mode ( c ) == EVP_CIPH_GCM_MODE ) { if ( ! EVP_CipherInit_ex ( dd , c , NULL , key , NULL , ( which & SSL3_CC_WRITE ) ) || ! EVP_CIPHER_CTX_ctrl ( dd , EVP_CTRL_GCM_SET_IV_FIXED , k , iv ) ) { SSLerr ( SSL_F_TLS1_CHANGE_CIPHER_STATE , ERR_R_INTERNAL_ERROR ) ; goto err2 ; } } else if ( EVP_CIPHER_mode ( c ) == EVP_CIPH_CCM_MODE ) { int taglen ; if ( s -> s3 -> tmp . new_cipher -> algorithm_enc & ( SSL_AES128CCM8 | SSL_AES256CCM8 ) ) taglen = 8 ; else taglen = 16 ; if ( ! EVP_CipherInit_ex ( dd , c , NULL , NULL , NULL , ( which & SSL3_CC_WRITE ) ) || ! EVP_CIPHER_CTX_ctrl ( dd , EVP_CTRL_AEAD_SET_IVLEN , 12 , NULL ) || ! EVP_CIPHER_CTX_ctrl ( dd , EVP_CTRL_AEAD_SET_TAG , taglen , NULL ) || ! EVP_CIPHER_CTX_ctrl ( dd , EVP_CTRL_CCM_SET_IV_FIXED , k , iv ) || ! EVP_CipherInit_ex ( dd , NULL , NULL , key , NULL , - 1 ) ) { SSLerr ( SSL_F_TLS1_CHANGE_CIPHER_STATE , ERR_R_INTERNAL_ERROR ) ; goto err2 ; } } else { if ( ! EVP_CipherInit_ex ( dd , c , NULL , key , iv , ( which & SSL3_CC_WRITE ) ) ) { SSLerr ( SSL_F_TLS1_CHANGE_CIPHER_STATE , ERR_R_INTERNAL_ERROR ) ; goto err2 ; } } if ( ( EVP_CIPHER_flags ( c ) & EVP_CIPH_FLAG_AEAD_CIPHER ) && * mac_secret_size && ! EVP_CIPHER_CTX_ctrl ( dd , EVP_CTRL_AEAD_SET_MAC_KEY , * mac_secret_size , mac_secret ) ) { SSLerr ( SSL_F_TLS1_CHANGE_CIPHER_STATE , ERR_R_INTERNAL_ERROR ) ; goto err2 ; } # ifdef OPENSSL_SSL_TRACE_CRYPTO if ( s -> msg_callback ) { int wh = which & SSL3_CC_WRITE ? TLS1_RT_CRYPTO_WRITE : 0 ; if ( * mac_secret_size ) s -> msg_callback ( 2 , s -> version , wh | TLS1_RT_CRYPTO_MAC , mac_secret , * mac_secret_size , s , s -> msg_callback_arg ) ; if ( c -> key_len ) s -> msg_callback ( 2 , s -> version , wh | TLS1_RT_CRYPTO_KEY , key , c -> key_len , s , s -> msg_callback_arg ) ; if ( k ) { if ( EVP_CIPHER_mode ( c ) == EVP_CIPH_GCM_MODE ) wh |= TLS1_RT_CRYPTO_FIXED_IV ; else wh |= TLS1_RT_CRYPTO_IV ; s -> msg_callback ( 2 , s -> version , wh , iv , k , s , s -> msg_callback_arg ) ; } } # endif # ifdef SSL_DEBUG printf ( \"which<S2SV_blank>=<S2SV_blank>%04X\\\\nkey=\" , which ) ; { int z ; for ( z = 0 ; z < EVP_CIPHER_key_length ( c ) ; z ++ ) printf ( \"%02X%c\" , key [ z ] , ( ( z + 1 ) % 16 ) ? '<S2SV_blank>' : '\\\\n' ) ; } printf ( \"\\\\niv=\" ) ; { int z ; for ( z = 0 ; z < k ; z ++ ) printf ( \"%02X%c\" , iv [ z ] , ( ( z + 1 ) % 16 ) ? '<S2SV_blank>' : '\\\\n' ) ; } printf ( \"\\\\n\" ) ; # endif OPENSSL_cleanse ( tmp1 , sizeof ( tmp1 ) ) ; OPENSSL_cleanse ( tmp2 , sizeof ( tmp1 ) ) ; OPENSSL_cleanse ( iv1 , sizeof ( iv1 ) ) ; OPENSSL_cleanse ( iv2 , sizeof ( iv2 ) ) ; return ( 1 ) ; err : SSLerr ( SSL_F_TLS1_CHANGE_CIPHER_STATE , ERR_R_MALLOC_FAILURE ) ; err2 : OPENSSL_cleanse ( tmp1 , sizeof ( tmp1 ) ) ; OPENSSL_cleanse ( tmp2 , sizeof ( tmp1 ) ) ; OPENSSL_cleanse ( iv1 , sizeof ( iv1 ) ) ; OPENSSL_cleanse ( iv2 , sizeof ( iv2 ) ) ; return ( 0 ) ; }\n",
      "fixed_code": "<S2SV_ModStart> ( s -> tlsext_use_etm ) s -> s3 -> flags |= TLS1_FLAGS_ENCRYPT_THEN_MAC_READ ; else s -> s3 -> flags &= ~ TLS1_FLAGS_ENCRYPT_THEN_MAC_READ ; if ( s -> <S2SV_ModStart> } else { if ( s -> tlsext_use_etm ) s -> s3 -> flags |= TLS1_FLAGS_ENCRYPT_THEN_MAC_WRITE ; else s -> s3 -> flags &= ~ TLS1_FLAGS_ENCRYPT_THEN_MAC_WRITE ;\n",
      "source_code_length": 7181,
      "target_code_length": 338,
      "vulnerability_patterns": {
        "buffer_overflow": 1,
        "use_after_free": 8,
        "integer_overflow": 8,
        "format_string": 7,
        "null_pointer": 72,
        "total": 96
      },
      "total_patterns": 96,
      "original_address": "https://github.com/openssl/openssl/commit/4ad93618d26a3ea23d36ad5498ff4f59eff3a4d2",
      "discovery_time": "2017-05-04T19:29Z",
      "project_commit_id": "openssl@openssl/4ad93618d26a3ea23d36ad5498ff4f59eff3a4d2",
      "extraction_time": "2025-08-31T15:41:49.178992",
      "label": 1,
      "vulnerability_type": "improper_input_validation",
      "difficulty_level": "expert",
      "risk_factors": [
        "critical_infrastructure",
        "buffer_overflow",
        "use_after_free"
      ],
      "attack_vectors": [
        "fuzzing",
        "code_analysis",
        "reverse_engineering"
      ],
      "mitigation_strategies": [
        "dynamic_analysis",
        "static_analysis",
        "fuzzing",
        "code_review",
        "secure_coding_practices"
      ],
      "code_differences": {
        "has_differences": true,
        "source_lines": 2,
        "target_lines": 2,
        "character_differences": 6843,
        "similarity_percentage": 6.842105263157896
      },
      "vulnerability_location": {
        "vulnerability_present": true,
        "fix_applied": true,
        "code_changed": true,
        "estimated_lines_changed": 0
      }
    },
    {
      "cve_id": "CVE-2017-9454",
      "cwe_id": "CWE-125",
      "cwe_name": "Out-of-bounds Read",
      "project": "resiprocate",
      "severity": "critical",
      "weaponization_score": 9.5,
      "is_critical": true,
      "is_weaponizable": true,
      "is_high_priority_project": false,
      "vulnerable_code": "CWE-125 int ares_parse_a_reply ( const unsigned char * abuf , int alen , struct hostent * * host ) { unsigned int qdcount , ancount ; int status , i , rr_type , rr_class , rr_len , naddrs ; long int len ; int naliases ; const unsigned char * aptr ; char * hostname , * rr_name , * rr_data , * * aliases ; struct in_addr * addrs ; struct hostent * hostent ; * host = NULL ; if ( alen < HFIXEDSZ ) return ARES_EBADRESP ; qdcount = DNS_HEADER_QDCOUNT ( abuf ) ; ancount = DNS_HEADER_ANCOUNT ( abuf ) ; if ( qdcount != 1 ) return ARES_EBADRESP ; aptr = abuf + HFIXEDSZ ; status = ares_expand_name ( aptr , abuf , alen , & hostname , & len ) ; if ( status != ARES_SUCCESS ) return status ; if ( aptr + len + QFIXEDSZ > abuf + alen ) { free ( hostname ) ; return ARES_EBADRESP ; } aptr += len + QFIXEDSZ ; addrs = malloc ( ancount * sizeof ( struct in_addr ) ) ; if ( ! addrs ) { free ( hostname ) ; return ARES_ENOMEM ; } aliases = malloc ( ( ancount + 1 ) * sizeof ( char * ) ) ; if ( ! aliases ) { free ( hostname ) ; free ( addrs ) ; return ARES_ENOMEM ; } naddrs = 0 ; naliases = 0 ; for ( i = 0 ; i < ( int ) ancount ; i ++ ) { status = ares_expand_name ( aptr , abuf , alen , & rr_name , & len ) ; if ( status != ARES_SUCCESS ) break ; aptr += len ; if ( aptr + RRFIXEDSZ > abuf + alen ) { free ( rr_name ) ; status = ARES_EBADRESP ; break ; } rr_type = DNS_RR_TYPE ( aptr ) ; rr_class = DNS_RR_CLASS ( aptr ) ; rr_len = DNS_RR_LEN ( aptr ) ; <S2SV_StartBug> aptr += RRFIXEDSZ ; <S2SV_EndBug> if ( rr_class == C_IN && rr_type == T_A && rr_len == sizeof ( struct in_addr ) && strcasecmp ( rr_name , hostname ) == 0 ) { memcpy ( & addrs [ naddrs ] , aptr , sizeof ( struct in_addr ) ) ; naddrs ++ ; status = ARES_SUCCESS ; } if ( rr_class == C_IN && rr_type == T_CNAME ) { aliases [ naliases ] = rr_name ; naliases ++ ; status = ares_expand_name ( aptr , abuf , alen , & rr_data , & len ) ; if ( status != ARES_SUCCESS ) break ; free ( hostname ) ; hostname = rr_data ; } else free ( rr_name ) ; aptr += rr_len ; if ( aptr > abuf + alen ) { status = ARES_EBADRESP ; break ; } } if ( status == ARES_SUCCESS && naddrs == 0 ) status = ARES_ENODATA ; if ( status == ARES_SUCCESS ) { aliases [ naliases ] = NULL ; hostent = malloc ( sizeof ( struct hostent ) ) ; if ( hostent ) { hostent -> h_addr_list = malloc ( ( naddrs + 1 ) * sizeof ( char * ) ) ; if ( hostent -> h_addr_list ) { hostent -> h_name = hostname ; hostent -> h_aliases = aliases ; hostent -> h_addrtype = AF_INET ; hostent -> h_length = sizeof ( struct in_addr ) ; for ( i = 0 ; i < naddrs ; i ++ ) hostent -> h_addr_list [ i ] = ( char * ) & addrs [ i ] ; hostent -> h_addr_list [ naddrs ] = NULL ; * host = hostent ; return ARES_SUCCESS ; } free ( hostent ) ; } status = ARES_ENOMEM ; } for ( i = 0 ; i < naliases ; i ++ ) free ( aliases [ i ] ) ; free ( aliases ) ; free ( addrs ) ; free ( hostname ) ; return status ; }\n",
      "fixed_code": "<S2SV_ModStart> += RRFIXEDSZ ; if ( aptr + rr_len > abuf + alen ) { free ( rr_name ) ; status = ARES_EBADRESP ; break ; }\n",
      "source_code_length": 2886,
      "target_code_length": 122,
      "vulnerability_patterns": {
        "buffer_overflow": 1,
        "use_after_free": 16,
        "integer_overflow": 9,
        "null_pointer": 12,
        "memory_leak": 4,
        "total": 42
      },
      "total_patterns": 42,
      "original_address": "https://github.com/resiprocate/resiprocate/commit/d67a9ca6fd06ca65d23e313bdbad1ef4dd3aa0df",
      "discovery_time": "2017-08-18T14:29Z",
      "project_commit_id": "resiprocate@resiprocate/d67a9ca6fd06ca65d23e313bdbad1ef4dd3aa0df",
      "extraction_time": "2025-08-31T15:41:49.179067",
      "label": 1,
      "vulnerability_type": "out-of-bounds_read",
      "difficulty_level": "expert",
      "risk_factors": [
        "memory_corruption",
        "buffer_overflow",
        "information_disclosure",
        "use_after_free",
        "integer_overflow"
      ],
      "attack_vectors": [
        "memory_manipulation",
        "malicious_input",
        "code_analysis",
        "buffer_overflow",
        "reverse_engineering",
        "fuzzing"
      ],
      "mitigation_strategies": [
        "safe_string_functions",
        "dynamic_analysis",
        "code_review",
        "static_analysis",
        "memory_safety_checks",
        "input_validation",
        "fuzzing",
        "bounds_checking",
        "secure_coding_practices"
      ],
      "code_differences": {
        "has_differences": true,
        "source_lines": 2,
        "target_lines": 2,
        "character_differences": 2764,
        "similarity_percentage": 22.727272727272727
      },
      "vulnerability_location": {
        "vulnerability_present": true,
        "fix_applied": true,
        "code_changed": true,
        "estimated_lines_changed": 0
      }
    },
    {
      "cve_id": "CVE-2019-20503",
      "cwe_id": "CWE-125",
      "cwe_name": "Out-of-bounds Read",
      "project": "sctplab",
      "severity": "critical",
      "weaponization_score": 9.5,
      "is_critical": true,
      "is_weaponizable": true,
      "is_high_priority_project": false,
      "vulnerable_code": "CWE-125 int sctp_load_addresses_from_init ( struct sctp_tcb * stcb , struct mbuf * m , int offset , int limit , struct sockaddr * src , struct sockaddr * dst , struct sockaddr * altsa , uint16_t port ) { struct sctp_inpcb * inp ; struct sctp_nets * net , * nnet , * net_tmp ; struct sctp_paramhdr * phdr , param_buf ; struct sctp_tcb * stcb_tmp ; uint16_t ptype , plen ; struct sockaddr * sa ; uint8_t random_store [ SCTP_PARAM_BUFFER_SIZE ] ; struct sctp_auth_random * p_random = NULL ; uint16_t random_len = 0 ; uint8_t hmacs_store [ SCTP_PARAM_BUFFER_SIZE ] ; struct sctp_auth_hmac_algo * hmacs = NULL ; uint16_t hmacs_len = 0 ; uint8_t saw_asconf = 0 ; uint8_t saw_asconf_ack = 0 ; uint8_t chunks_store [ SCTP_PARAM_BUFFER_SIZE ] ; struct sctp_auth_chunk_list * chunks = NULL ; uint16_t num_chunks = 0 ; sctp_key_t * new_key ; uint32_t keylen ; int got_random = 0 , got_hmacs = 0 , got_chklist = 0 ; uint8_t peer_supports_ecn ; uint8_t peer_supports_prsctp ; uint8_t peer_supports_auth ; uint8_t peer_supports_asconf ; uint8_t peer_supports_asconf_ack ; uint8_t peer_supports_reconfig ; uint8_t peer_supports_nrsack ; uint8_t peer_supports_pktdrop ; uint8_t peer_supports_idata ; # ifdef INET struct sockaddr_in sin ; # endif # ifdef INET6 struct sockaddr_in6 sin6 ; # endif # ifdef INET memset ( & sin , 0 , sizeof ( sin ) ) ; sin . sin_family = AF_INET ; # ifdef HAVE_SIN_LEN sin . sin_len = sizeof ( sin ) ; # endif sin . sin_port = stcb -> rport ; # endif # ifdef INET6 memset ( & sin6 , 0 , sizeof ( sin6 ) ) ; sin6 . sin6_family = AF_INET6 ; # ifdef HAVE_SIN6_LEN sin6 . sin6_len = sizeof ( struct sockaddr_in6 ) ; # endif sin6 . sin6_port = stcb -> rport ; # endif if ( altsa ) { sa = altsa ; } else { sa = src ; } peer_supports_idata = 0 ; peer_supports_ecn = 0 ; peer_supports_prsctp = 0 ; peer_supports_auth = 0 ; peer_supports_asconf = 0 ; peer_supports_reconfig = 0 ; peer_supports_nrsack = 0 ; peer_supports_pktdrop = 0 ; TAILQ_FOREACH ( net , & stcb -> asoc . nets , sctp_next ) { net -> dest_state |= SCTP_ADDR_NOT_IN_ASSOC ; } inp = stcb -> sctp_ep ; atomic_add_int ( & stcb -> asoc . refcnt , 1 ) ; stcb_tmp = sctp_findassociation_ep_addr ( & inp , sa , & net_tmp , dst , stcb ) ; atomic_add_int ( & stcb -> asoc . refcnt , - 1 ) ; if ( ( stcb_tmp == NULL && inp == stcb -> sctp_ep ) || inp == NULL ) { switch ( sa -> sa_family ) { # ifdef INET case AF_INET : if ( stcb -> asoc . scope . ipv4_addr_legal ) { if ( sctp_add_remote_addr ( stcb , sa , NULL , port , SCTP_DONOT_SETSCOPE , SCTP_LOAD_ADDR_2 ) ) { return ( - 1 ) ; } } break ; # endif # ifdef INET6 case AF_INET6 : if ( stcb -> asoc . scope . ipv6_addr_legal ) { if ( sctp_add_remote_addr ( stcb , sa , NULL , port , SCTP_DONOT_SETSCOPE , SCTP_LOAD_ADDR_3 ) ) { return ( - 2 ) ; } } break ; # endif # if defined ( __Userspace__ ) case AF_CONN : if ( stcb -> asoc . scope . conn_addr_legal ) { if ( sctp_add_remote_addr ( stcb , sa , NULL , port , SCTP_DONOT_SETSCOPE , SCTP_LOAD_ADDR_3 ) ) { return ( - 2 ) ; } } break ; # endif default : break ; } } else { if ( net_tmp != NULL && stcb_tmp == stcb ) { net_tmp -> dest_state &= ~ SCTP_ADDR_NOT_IN_ASSOC ; } else if ( stcb_tmp != stcb ) { if ( stcb_tmp ) SCTP_TCB_UNLOCK ( stcb_tmp ) ; return ( - 3 ) ; } } if ( stcb -> asoc . state == 0 ) { return ( - 4 ) ; } phdr = sctp_get_next_param ( m , offset , & param_buf , sizeof ( param_buf ) ) ; while ( phdr ) { ptype = ntohs ( phdr -> param_type ) ; plen = ntohs ( phdr -> param_length ) ; if ( offset + plen > limit ) { break ; } <S2SV_StartBug> if ( plen == 0 ) { <S2SV_EndBug> break ; } # ifdef INET if ( ptype == SCTP_IPV4_ADDRESS ) { if ( stcb -> asoc . scope . ipv4_addr_legal ) { struct sctp_ipv4addr_param * p4 , p4_buf ; phdr = sctp_get_next_param ( m , offset , ( struct sctp_paramhdr * ) & p4_buf , sizeof ( p4_buf ) ) ; if ( plen != sizeof ( struct sctp_ipv4addr_param ) || phdr == NULL ) { return ( - 5 ) ; } p4 = ( struct sctp_ipv4addr_param * ) phdr ; sin . sin_addr . s_addr = p4 -> addr ; if ( IN_MULTICAST ( ntohl ( sin . sin_addr . s_addr ) ) ) { goto next_param ; } if ( ( sin . sin_addr . s_addr == INADDR_BROADCAST ) || ( sin . sin_addr . s_addr == INADDR_ANY ) ) { goto next_param ; } sa = ( struct sockaddr * ) & sin ; inp = stcb -> sctp_ep ; atomic_add_int ( & stcb -> asoc . refcnt , 1 ) ; stcb_tmp = sctp_findassociation_ep_addr ( & inp , sa , & net , dst , stcb ) ; atomic_add_int ( & stcb -> asoc . refcnt , - 1 ) ; if ( ( stcb_tmp == NULL && inp == stcb -> sctp_ep ) || inp == NULL ) { add_it_now : if ( stcb -> asoc . state == 0 ) { return ( - 7 ) ; } if ( sctp_add_remote_addr ( stcb , sa , NULL , port , SCTP_DONOT_SETSCOPE , SCTP_LOAD_ADDR_4 ) ) { return ( - 8 ) ; } } else if ( stcb_tmp == stcb ) { if ( stcb -> asoc . state == 0 ) { return ( - 10 ) ; } if ( net != NULL ) { net -> dest_state &= ~ SCTP_ADDR_NOT_IN_ASSOC ; } } else { if ( stcb_tmp ) { if ( SCTP_GET_STATE ( stcb_tmp ) == SCTP_STATE_COOKIE_WAIT ) { struct mbuf * op_err ; char msg [ SCTP_DIAG_INFO_LEN ] ; snprintf ( msg , sizeof ( msg ) , \"%s:%d<S2SV_blank>at<S2SV_blank>%s\" , __FILE__ , __LINE__ , __func__ ) ; op_err = sctp_generate_cause ( SCTP_BASE_SYSCTL ( sctp_diag_info_code ) , msg ) ; sctp_abort_an_association ( stcb_tmp -> sctp_ep , stcb_tmp , op_err , SCTP_SO_NOT_LOCKED ) ; goto add_it_now ; } SCTP_TCB_UNLOCK ( stcb_tmp ) ; } if ( stcb -> asoc . state == 0 ) { return ( - 12 ) ; } return ( - 13 ) ; } } } else # endif # ifdef INET6 if ( ptype == SCTP_IPV6_ADDRESS ) { if ( stcb -> asoc . scope . ipv6_addr_legal ) { struct sctp_ipv6addr_param * p6 , p6_buf ; phdr = sctp_get_next_param ( m , offset , ( struct sctp_paramhdr * ) & p6_buf , sizeof ( p6_buf ) ) ; if ( plen != sizeof ( struct sctp_ipv6addr_param ) || phdr == NULL ) { return ( - 14 ) ; } p6 = ( struct sctp_ipv6addr_param * ) phdr ; memcpy ( ( caddr_t ) & sin6 . sin6_addr , p6 -> addr , sizeof ( p6 -> addr ) ) ; if ( IN6_IS_ADDR_MULTICAST ( & sin6 . sin6_addr ) ) { goto next_param ; } if ( IN6_IS_ADDR_LINKLOCAL ( & sin6 . sin6_addr ) ) { goto next_param ; } sa = ( struct sockaddr * ) & sin6 ; inp = stcb -> sctp_ep ; atomic_add_int ( & stcb -> asoc . refcnt , 1 ) ; stcb_tmp = sctp_findassociation_ep_addr ( & inp , sa , & net , dst , stcb ) ; atomic_add_int ( & stcb -> asoc . refcnt , - 1 ) ; if ( stcb_tmp == NULL && ( inp == stcb -> sctp_ep || inp == NULL ) ) { add_it_now6 : if ( stcb -> asoc . state == 0 ) { return ( - 16 ) ; } if ( sctp_add_remote_addr ( stcb , sa , NULL , port , SCTP_DONOT_SETSCOPE , SCTP_LOAD_ADDR_5 ) ) { return ( - 17 ) ; } } else if ( stcb_tmp == stcb ) { if ( stcb -> asoc . state == 0 ) { return ( - 19 ) ; } if ( net != NULL ) { net -> dest_state &= ~ SCTP_ADDR_NOT_IN_ASSOC ; } } else { if ( stcb_tmp ) { if ( SCTP_GET_STATE ( stcb_tmp ) == SCTP_STATE_COOKIE_WAIT ) { struct mbuf * op_err ; char msg [ SCTP_DIAG_INFO_LEN ] ; snprintf ( msg , sizeof ( msg ) , \"%s:%d<S2SV_blank>at<S2SV_blank>%s\" , __FILE__ , __LINE__ , __func__ ) ; op_err = sctp_generate_cause ( SCTP_BASE_SYSCTL ( sctp_diag_info_code ) , msg ) ; sctp_abort_an_association ( stcb_tmp -> sctp_ep , stcb_tmp , op_err , SCTP_SO_NOT_LOCKED ) ; goto add_it_now6 ; } SCTP_TCB_UNLOCK ( stcb_tmp ) ; } if ( stcb -> asoc . state == 0 ) { return ( - 21 ) ; } return ( - 22 ) ; } } } else # endif if ( ptype == SCTP_ECN_CAPABLE ) { peer_supports_ecn = 1 ; } else if ( ptype == SCTP_ULP_ADAPTATION ) { if ( stcb -> asoc . state != SCTP_STATE_OPEN ) { struct sctp_adaptation_layer_indication ai , * aip ; phdr = sctp_get_next_param ( m , offset , ( struct sctp_paramhdr * ) & ai , sizeof ( ai ) ) ; aip = ( struct sctp_adaptation_layer_indication * ) phdr ; if ( aip ) { stcb -> asoc . peers_adaptation = ntohl ( aip -> indication ) ; stcb -> asoc . adaptation_needed = 1 ; } } } else if ( ptype == SCTP_SET_PRIM_ADDR ) { struct sctp_asconf_addr_param lstore , * fee ; int lptype ; struct sockaddr * lsa = NULL ; # ifdef INET struct sctp_asconf_addrv4_param * fii ; # endif if ( stcb -> asoc . asconf_supported == 0 ) { return ( - 100 ) ; } if ( plen > sizeof ( lstore ) ) { return ( - 23 ) ; } <S2SV_StartBug> phdr = sctp_get_next_param ( m , offset , <S2SV_EndBug> ( struct sctp_paramhdr * ) & lstore , plen ) ; if ( phdr == NULL ) { return ( - 24 ) ; } fee = ( struct sctp_asconf_addr_param * ) phdr ; lptype = ntohs ( fee -> addrp . ph . param_type ) ; switch ( lptype ) { # ifdef INET case SCTP_IPV4_ADDRESS : if ( plen != sizeof ( struct sctp_asconf_addrv4_param ) ) { SCTP_PRINTF ( \"Sizeof<S2SV_blank>setprim<S2SV_blank>in<S2SV_blank>init/init<S2SV_blank>ack<S2SV_blank>not<S2SV_blank>%d<S2SV_blank>but<S2SV_blank>%d<S2SV_blank>-<S2SV_blank>ignored\\\\n\" , ( int ) sizeof ( struct sctp_asconf_addrv4_param ) , plen ) ; } else { fii = ( struct sctp_asconf_addrv4_param * ) fee ; sin . sin_addr . s_addr = fii -> addrp . addr ; lsa = ( struct sockaddr * ) & sin ; } break ; # endif # ifdef INET6 case SCTP_IPV6_ADDRESS : if ( plen != sizeof ( struct sctp_asconf_addr_param ) ) { SCTP_PRINTF ( \"Sizeof<S2SV_blank>setprim<S2SV_blank>(v6)<S2SV_blank>in<S2SV_blank>init/init<S2SV_blank>ack<S2SV_blank>not<S2SV_blank>%d<S2SV_blank>but<S2SV_blank>%d<S2SV_blank>-<S2SV_blank>ignored\\\\n\" , ( int ) sizeof ( struct sctp_asconf_addr_param ) , plen ) ; } else { memcpy ( sin6 . sin6_addr . s6_addr , fee -> addrp . addr , sizeof ( fee -> addrp . addr ) ) ; lsa = ( struct sockaddr * ) & sin6 ; } break ; # endif default : break ; } if ( lsa ) { ( void ) sctp_set_primary_addr ( stcb , sa , NULL ) ; } } else if ( ptype == SCTP_HAS_NAT_SUPPORT ) { stcb -> asoc . peer_supports_nat = 1 ; } else if ( ptype == SCTP_PRSCTP_SUPPORTED ) { peer_supports_prsctp = 1 ; } else if ( ptype == SCTP_SUPPORTED_CHUNK_EXT ) { struct sctp_supported_chunk_types_param * pr_supported ; uint8_t local_store [ SCTP_PARAM_BUFFER_SIZE ] ; int num_ent , i ; if ( plen > sizeof ( local_store ) ) { return ( - 35 ) ; } phdr = sctp_get_next_param ( m , offset , ( struct sctp_paramhdr * ) & local_store , plen ) ; if ( phdr == NULL ) { return ( - 25 ) ; } pr_supported = ( struct sctp_supported_chunk_types_param * ) phdr ; num_ent = plen - sizeof ( struct sctp_paramhdr ) ; for ( i = 0 ; i < num_ent ; i ++ ) { switch ( pr_supported -> chunk_types [ i ] ) { case SCTP_ASCONF : peer_supports_asconf = 1 ; break ; case SCTP_ASCONF_ACK : peer_supports_asconf_ack = 1 ; break ; case SCTP_FORWARD_CUM_TSN : peer_supports_prsctp = 1 ; break ; case SCTP_PACKET_DROPPED : peer_supports_pktdrop = 1 ; break ; case SCTP_NR_SELECTIVE_ACK : peer_supports_nrsack = 1 ; break ; case SCTP_STREAM_RESET : peer_supports_reconfig = 1 ; break ; case SCTP_AUTHENTICATION : peer_supports_auth = 1 ; break ; case SCTP_IDATA : peer_supports_idata = 1 ; break ; default : break ; } } } else if ( ptype == SCTP_RANDOM ) { if ( plen > sizeof ( random_store ) ) break ; if ( got_random ) { goto next_param ; } phdr = sctp_get_next_param ( m , offset , ( struct sctp_paramhdr * ) random_store , plen ) ; if ( phdr == NULL ) return ( - 26 ) ; p_random = ( struct sctp_auth_random * ) phdr ; random_len = plen - sizeof ( * p_random ) ; if ( random_len != SCTP_AUTH_RANDOM_SIZE_REQUIRED ) { SCTPDBG ( SCTP_DEBUG_AUTH1 , \"SCTP:<S2SV_blank>invalid<S2SV_blank>RANDOM<S2SV_blank>len\\\\n\" ) ; return ( - 27 ) ; } got_random = 1 ; } else if ( ptype == SCTP_HMAC_LIST ) { uint16_t num_hmacs ; uint16_t i ; if ( plen > sizeof ( hmacs_store ) ) break ; if ( got_hmacs ) { goto next_param ; } phdr = sctp_get_next_param ( m , offset , ( struct sctp_paramhdr * ) hmacs_store , plen ) ; if ( phdr == NULL ) return ( - 28 ) ; hmacs = ( struct sctp_auth_hmac_algo * ) phdr ; hmacs_len = plen - sizeof ( * hmacs ) ; num_hmacs = hmacs_len / sizeof ( hmacs -> hmac_ids [ 0 ] ) ; if ( sctp_verify_hmac_param ( hmacs , num_hmacs ) ) { return ( - 29 ) ; } if ( stcb -> asoc . peer_hmacs != NULL ) sctp_free_hmaclist ( stcb -> asoc . peer_hmacs ) ; stcb -> asoc . peer_hmacs = sctp_alloc_hmaclist ( num_hmacs ) ; if ( stcb -> asoc . peer_hmacs != NULL ) { for ( i = 0 ; i < num_hmacs ; i ++ ) { ( void ) sctp_auth_add_hmacid ( stcb -> asoc . peer_hmacs , ntohs ( hmacs -> hmac_ids [ i ] ) ) ; } } got_hmacs = 1 ; } else if ( ptype == SCTP_CHUNK_LIST ) { int i ; if ( plen > sizeof ( chunks_store ) ) break ; if ( got_chklist ) { goto next_param ; } phdr = sctp_get_next_param ( m , offset , ( struct sctp_paramhdr * ) chunks_store , plen ) ; if ( phdr == NULL ) return ( - 30 ) ; chunks = ( struct sctp_auth_chunk_list * ) phdr ; num_chunks = plen - sizeof ( * chunks ) ; if ( stcb -> asoc . peer_auth_chunks != NULL ) sctp_clear_chunklist ( stcb -> asoc . peer_auth_chunks ) ; else stcb -> asoc . peer_auth_chunks = sctp_alloc_chunklist ( ) ; for ( i = 0 ; i < num_chunks ; i ++ ) { ( void ) sctp_auth_add_chunk ( chunks -> chunk_types [ i ] , stcb -> asoc . peer_auth_chunks ) ; if ( chunks -> chunk_types [ i ] == SCTP_ASCONF ) saw_asconf = 1 ; if ( chunks -> chunk_types [ i ] == SCTP_ASCONF_ACK ) saw_asconf_ack = 1 ; } got_chklist = 1 ; } else if ( ( ptype == SCTP_HEARTBEAT_INFO ) || ( ptype == SCTP_STATE_COOKIE ) || ( ptype == SCTP_UNRECOG_PARAM ) || ( ptype == SCTP_COOKIE_PRESERVE ) || ( ptype == SCTP_SUPPORTED_ADDRTYPE ) || ( ptype == SCTP_ADD_IP_ADDRESS ) || ( ptype == SCTP_DEL_IP_ADDRESS ) || ( ptype == SCTP_ERROR_CAUSE_IND ) || ( ptype == SCTP_SUCCESS_REPORT ) ) { ; } else { if ( ( ptype & 0x8000 ) == 0x0000 ) { break ; } } next_param : offset += SCTP_SIZE32 ( plen ) ; if ( offset >= limit ) { break ; } phdr = sctp_get_next_param ( m , offset , & param_buf , sizeof ( param_buf ) ) ; } TAILQ_FOREACH_SAFE ( net , & stcb -> asoc . nets , sctp_next , nnet ) { if ( ( net -> dest_state & SCTP_ADDR_NOT_IN_ASSOC ) == SCTP_ADDR_NOT_IN_ASSOC ) { stcb -> asoc . numnets -- ; TAILQ_REMOVE ( & stcb -> asoc . nets , net , sctp_next ) ; sctp_free_remote_addr ( net ) ; if ( net == stcb -> asoc . primary_destination ) { stcb -> asoc . primary_destination = NULL ; sctp_select_primary_destination ( stcb ) ; } } } if ( ( stcb -> asoc . ecn_supported == 1 ) && ( peer_supports_ecn == 0 ) ) { stcb -> asoc . ecn_supported = 0 ; } if ( ( stcb -> asoc . prsctp_supported == 1 ) && ( peer_supports_prsctp == 0 ) ) { stcb -> asoc . prsctp_supported = 0 ; } if ( ( stcb -> asoc . auth_supported == 1 ) && ( ( peer_supports_auth == 0 ) || ( got_random == 0 ) || ( got_hmacs == 0 ) ) ) { stcb -> asoc . auth_supported = 0 ; } if ( ( stcb -> asoc . asconf_supported == 1 ) && ( ( peer_supports_asconf == 0 ) || ( peer_supports_asconf_ack == 0 ) || ( stcb -> asoc . auth_supported == 0 ) || ( saw_asconf == 0 ) || ( saw_asconf_ack == 0 ) ) ) { stcb -> asoc . asconf_supported = 0 ; } if ( ( stcb -> asoc . reconfig_supported == 1 ) && ( peer_supports_reconfig == 0 ) ) { stcb -> asoc . reconfig_supported = 0 ; } if ( ( stcb -> asoc . idata_supported == 1 ) && ( peer_supports_idata == 0 ) ) { stcb -> asoc . idata_supported = 0 ; } if ( ( stcb -> asoc . nrsack_supported == 1 ) && ( peer_supports_nrsack == 0 ) ) { stcb -> asoc . nrsack_supported = 0 ; } if ( ( stcb -> asoc . pktdrop_supported == 1 ) && ( peer_supports_pktdrop == 0 ) ) { stcb -> asoc . pktdrop_supported = 0 ; } if ( ( peer_supports_auth == 0 ) && ( got_chklist == 1 ) ) { return ( - 31 ) ; } if ( ( peer_supports_asconf == 1 ) && ( peer_supports_auth == 0 ) ) { return ( - 32 ) ; } else if ( ( peer_supports_asconf == 1 ) && ( peer_supports_auth == 1 ) && ( ( saw_asconf == 0 ) || ( saw_asconf_ack == 0 ) ) ) { return ( - 33 ) ; } keylen = sizeof ( * p_random ) + random_len + sizeof ( * hmacs ) + hmacs_len ; if ( chunks != NULL ) { keylen += sizeof ( * chunks ) + num_chunks ; } new_key = sctp_alloc_key ( keylen ) ; if ( new_key != NULL ) { if ( p_random != NULL ) { keylen = sizeof ( * p_random ) + random_len ; memcpy ( new_key -> key , p_random , keylen ) ; } else { keylen = 0 ; } if ( chunks != NULL ) { memcpy ( new_key -> key + keylen , chunks , sizeof ( * chunks ) + num_chunks ) ; keylen += sizeof ( * chunks ) + num_chunks ; } if ( hmacs != NULL ) { memcpy ( new_key -> key + keylen , hmacs , sizeof ( * hmacs ) + hmacs_len ) ; } } else { return ( - 34 ) ; } if ( stcb -> asoc . authinfo . peer_random != NULL ) sctp_free_key ( stcb -> asoc . authinfo . peer_random ) ; stcb -> asoc . authinfo . peer_random = new_key ; sctp_clear_cachedkeys ( stcb , stcb -> asoc . authinfo . assoc_keyid ) ; sctp_clear_cachedkeys ( stcb , stcb -> asoc . authinfo . recv_keyid ) ; return ( 0 ) ; }\n",
      "fixed_code": "<S2SV_ModStart> if ( plen < sizeof ( struct sctp_paramhdr ) <S2SV_ModEnd> ) { break <S2SV_ModStart> ) ; } if ( plen < sizeof ( struct sctp_asconf_addrv4_param ) ) { return ( - 101 ) ; }\n",
      "source_code_length": 16330,
      "target_code_length": 186,
      "vulnerability_patterns": {
        "buffer_overflow": 7,
        "use_after_free": 7,
        "integer_overflow": 7,
        "format_string": 2,
        "null_pointer": 100,
        "total": 123
      },
      "total_patterns": 123,
      "original_address": "https://github.com/sctplab/usrsctp/commit/790a7a2555aefb392a5a69923f1e9d17b4968467",
      "discovery_time": "2020-03-06T20:15Z",
      "project_commit_id": "sctplab@usrsctp/790a7a2555aefb392a5a69923f1e9d17b4968467",
      "extraction_time": "2025-08-31T15:41:49.179110",
      "label": 1,
      "vulnerability_type": "out-of-bounds_read",
      "difficulty_level": "expert",
      "risk_factors": [
        "memory_corruption",
        "buffer_overflow",
        "information_disclosure",
        "use_after_free",
        "integer_overflow"
      ],
      "attack_vectors": [
        "memory_manipulation",
        "malicious_input",
        "code_analysis",
        "buffer_overflow",
        "reverse_engineering",
        "fuzzing"
      ],
      "mitigation_strategies": [
        "safe_string_functions",
        "dynamic_analysis",
        "code_review",
        "static_analysis",
        "memory_safety_checks",
        "input_validation",
        "fuzzing",
        "bounds_checking",
        "secure_coding_practices"
      ],
      "code_differences": {
        "has_differences": true,
        "source_lines": 2,
        "target_lines": 2,
        "character_differences": 16144,
        "similarity_percentage": 4.62962962962963
      },
      "vulnerability_location": {
        "vulnerability_present": true,
        "fix_applied": true,
        "code_changed": true,
        "estimated_lines_changed": 0
      }
    },
    {
      "cve_id": "CVE-2018-16425",
      "cwe_id": "CWE-415",
      "cwe_name": "Double Free",
      "project": "OpenSC",
      "severity": "critical",
      "weaponization_score": 9.5,
      "is_critical": true,
      "is_weaponizable": true,
      "is_high_priority_project": false,
      "vulnerable_code": "CWE-415 int sc_file_set_sec_attr ( sc_file_t * file , const u8 * sec_attr , size_t sec_attr_len ) { u8 * tmp ; if ( ! sc_file_valid ( file ) ) { return SC_ERROR_INVALID_ARGUMENTS ; } <S2SV_StartBug> if ( sec_attr == NULL ) { <S2SV_EndBug> if ( file -> sec_attr != NULL ) free ( file -> sec_attr ) ; file -> sec_attr = NULL ; file -> sec_attr_len = 0 ; return 0 ; } tmp = ( u8 * ) realloc ( file -> sec_attr , sec_attr_len ) ; if ( ! tmp ) { if ( file -> sec_attr ) free ( file -> sec_attr ) ; file -> sec_attr = NULL ; file -> sec_attr_len = 0 ; return SC_ERROR_OUT_OF_MEMORY ; } file -> sec_attr = tmp ; memcpy ( file -> sec_attr , sec_attr , sec_attr_len ) ; file -> sec_attr_len = sec_attr_len ; return 0 ; }\n",
      "fixed_code": "<S2SV_ModStart> sec_attr == NULL || sec_attr_len\n",
      "source_code_length": 712,
      "target_code_length": 49,
      "vulnerability_patterns": {
        "buffer_overflow": 1,
        "use_after_free": 3,
        "null_pointer": 15,
        "memory_leak": 1,
        "total": 20
      },
      "total_patterns": 20,
      "original_address": "https://github.com/OpenSC/OpenSC/commit/360e95d45ac4123255a4c796db96337f332160ad",
      "discovery_time": "2018-09-04T00:29Z",
      "project_commit_id": "OpenSC@OpenSC/360e95d45ac4123255a4c796db96337f332160ad",
      "extraction_time": "2025-08-31T15:41:49.179252",
      "label": 1,
      "vulnerability_type": "double_free",
      "difficulty_level": "expert",
      "risk_factors": [
        "denial_of_service",
        "memory_corruption",
        "buffer_overflow",
        "system_crash",
        "use_after_free"
      ],
      "attack_vectors": [
        "memory_manipulation",
        "null_pointer",
        "code_analysis",
        "reverse_engineering",
        "use_after_free",
        "fuzzing"
      ],
      "mitigation_strategies": [
        "null_pointer_checks",
        "fuzzing",
        "dynamic_analysis",
        "memory_management",
        "static_analysis",
        "use_after_free_prevention",
        "code_review",
        "secure_coding_practices"
      ],
      "code_differences": {
        "has_differences": true,
        "source_lines": 2,
        "target_lines": 2,
        "character_differences": 663,
        "similarity_percentage": 10.81081081081081
      },
      "vulnerability_location": {
        "vulnerability_present": true,
        "fix_applied": true,
        "code_changed": true,
        "estimated_lines_changed": 0
      }
    },
    {
      "cve_id": "CVE-2020-13111",
      "cwe_id": "CWE-119",
      "cwe_name": "Buffer Overflow",
      "project": "naviserver",
      "severity": "critical",
      "weaponization_score": 9.5,
      "is_critical": true,
      "is_weaponizable": true,
      "is_high_priority_project": false,
      "vulnerable_code": "CWE-119 <S2SV_StartBug> static bool <S2SV_EndBug> ChunkedDecode ( Request * reqPtr , bool update ) { const Tcl_DString * bufPtr ; const char * end , * chunkStart ; <S2SV_StartBug> bool success = NS_TRUE ; <S2SV_EndBug> NS_NONNULL_ASSERT ( reqPtr != NULL ) ; bufPtr = & reqPtr -> buffer ; end = bufPtr -> string + bufPtr -> length ; chunkStart = bufPtr -> string + reqPtr -> chunkStartOff ; while ( reqPtr -> chunkStartOff < ( size_t ) bufPtr -> length ) { char * p = strstr ( chunkStart , \"\\\\r\\\\n\" ) ; <S2SV_StartBug> size_t chunk_length ; <S2SV_EndBug> if ( p == NULL ) { Ns_Log ( DriverDebug , \"ChunkedDecode:<S2SV_blank>chunk<S2SV_blank>did<S2SV_blank>not<S2SV_blank>find<S2SV_blank>end-of-line\" ) ; <S2SV_StartBug> success = NS_FALSE ; <S2SV_EndBug> break ; } * p = '\\\\0' ; <S2SV_StartBug> chunk_length = ( size_t ) strtol ( chunkStart , NULL , 16 ) ; <S2SV_EndBug> * p = '\\\\r' ; <S2SV_StartBug> if ( p + 2 + chunk_length > end ) { <S2SV_EndBug> Ns_Log ( DriverDebug , \"ChunkedDecode:<S2SV_blank>chunk<S2SV_blank>length<S2SV_blank>past<S2SV_blank>end<S2SV_blank>of<S2SV_blank>buffer\" ) ; <S2SV_StartBug> success = NS_FALSE ; <S2SV_EndBug> break ; } if ( update ) { char * writeBuffer = bufPtr -> string + reqPtr -> chunkWriteOff ; <S2SV_StartBug> memmove ( writeBuffer , p + 2 , chunk_length ) ; <S2SV_EndBug> <S2SV_StartBug> reqPtr -> chunkWriteOff += chunk_length ; <S2SV_EndBug> <S2SV_StartBug> * ( writeBuffer + chunk_length ) = '\\\\0' ; <S2SV_EndBug> } <S2SV_StartBug> reqPtr -> chunkStartOff += ( size_t ) ( p - chunkStart ) + 4u + chunk_length ; <S2SV_EndBug> chunkStart = bufPtr -> string + reqPtr -> chunkStartOff ; } <S2SV_StartBug> return success ; <S2SV_EndBug> }\n",
      "fixed_code": "<S2SV_ModStart> <S2SV_null> <S2SV_null> static SockState <S2SV_ModEnd> ChunkedDecode ( Request <S2SV_ModStart> * chunkStart ; SockState result = SOCK_READY <S2SV_ModEnd> ; NS_NONNULL_ASSERT ( <S2SV_ModStart> \"\\\\r\\\\n\" ) ; long chunkLength <S2SV_ModEnd> ; if ( <S2SV_ModStart> \"ChunkedDecode:<S2SV_blank>chunk<S2SV_blank>did<S2SV_blank>not<S2SV_blank>find<S2SV_blank>end-of-line\" ) ; result = SOCK_MORE <S2SV_ModEnd> ; break ; <S2SV_ModStart> = '\\\\0' ; chunkLength = <S2SV_ModEnd> strtol ( chunkStart <S2SV_ModStart> ; if ( chunkLength < 0 ) { Ns_Log ( Warning , \"ChunkedDecode:<S2SV_blank>negative<S2SV_blank>chunk<S2SV_blank>length\" ) ; result = SOCK_BADREQUEST ; break ; } * p = '\\\\r' ; if ( <S2SV_ModStart> + 2 + chunkLength <S2SV_ModEnd> > end ) <S2SV_ModStart> \"ChunkedDecode:<S2SV_blank>chunk<S2SV_blank>length<S2SV_blank>past<S2SV_blank>end<S2SV_blank>of<S2SV_blank>buffer\" ) ; result = SOCK_MORE <S2SV_ModEnd> ; break ; <S2SV_ModStart> + 2 , ( size_t ) chunkLength <S2SV_ModEnd> ) ; reqPtr <S2SV_ModStart> -> chunkWriteOff += ( size_t ) chunkLength <S2SV_ModEnd> ; * ( <S2SV_ModStart> ( writeBuffer + chunkLength <S2SV_ModEnd> ) = '\\\\0' <S2SV_ModStart> + 4u + ( size_t ) chunkLength <S2SV_ModEnd> ; chunkStart = <S2SV_ModStart> ; } return result <S2SV_ModEnd> ; } <S2SV_null>\n",
      "source_code_length": 1679,
      "target_code_length": 1283,
      "vulnerability_patterns": {
        "buffer_overflow": 1,
        "integer_overflow": 2,
        "null_pointer": 14,
        "sql_injection": 2,
        "total": 19
      },
      "total_patterns": 19,
      "original_address": "https://bitbucket.org/naviserver/naviserver/commit/a5c3079f1d8996d5f34c9384a440acf3519ca3bb",
      "discovery_time": "2020-05-16T15:15Z",
      "project_commit_id": "naviserver@naviserver/a5c3079f1d8996d5f34c9384a440acf3519ca3bb",
      "extraction_time": "2025-08-31T15:41:49.179272",
      "label": 1,
      "vulnerability_type": "buffer_overflow",
      "difficulty_level": "expert",
      "risk_factors": [
        "memory_corruption",
        "sql_injection",
        "arbitrary_code_execution",
        "buffer_overflow",
        "system_crash"
      ],
      "attack_vectors": [
        "memory_manipulation",
        "malicious_input",
        "code_analysis",
        "buffer_overflow",
        "reverse_engineering",
        "fuzzing"
      ],
      "mitigation_strategies": [
        "safe_string_functions",
        "dynamic_analysis",
        "code_review",
        "static_analysis",
        "memory_safety_checks",
        "input_validation",
        "fuzzing",
        "bounds_checking",
        "secure_coding_practices"
      ],
      "code_differences": {
        "has_differences": true,
        "source_lines": 2,
        "target_lines": 2,
        "character_differences": 396,
        "similarity_percentage": 47.368421052631575
      },
      "vulnerability_location": {
        "vulnerability_present": true,
        "fix_applied": true,
        "code_changed": true,
        "estimated_lines_changed": 0
      }
    },
    {
      "cve_id": "CVE-2016-4998",
      "cwe_id": "CWE-119",
      "cwe_name": "Buffer Overflow",
      "project": "torvalds",
      "severity": "critical",
      "weaponization_score": 9.5,
      "is_critical": true,
      "is_weaponizable": true,
      "is_high_priority_project": false,
      "vulnerable_code": "CWE-119 static inline int check_entry_size_and_hooks ( struct arpt_entry * e , struct xt_table_info * newinfo , const unsigned char * base , const unsigned char * limit , const unsigned int * hook_entries , const unsigned int * underflows , unsigned int valid_hooks ) { unsigned int h ; int err ; if ( ( unsigned long ) e % __alignof__ ( struct arpt_entry ) != 0 || <S2SV_StartBug> ( unsigned char * ) e + sizeof ( struct arpt_entry ) >= limit ) { <S2SV_EndBug> duprintf ( \"Bad<S2SV_blank>offset<S2SV_blank>%p\\\\n\" , e ) ; return - EINVAL ; } if ( e -> next_offset < sizeof ( struct arpt_entry ) + sizeof ( struct xt_entry_target ) ) { duprintf ( \"checking:<S2SV_blank>element<S2SV_blank>%p<S2SV_blank>size<S2SV_blank>%u\\\\n\" , e , e -> next_offset ) ; return - EINVAL ; } err = check_entry ( e ) ; if ( err ) return err ; for ( h = 0 ; h < NF_ARP_NUMHOOKS ; h ++ ) { if ( ! ( valid_hooks & ( 1 << h ) ) ) continue ; if ( ( unsigned char * ) e - base == hook_entries [ h ] ) newinfo -> hook_entry [ h ] = hook_entries [ h ] ; if ( ( unsigned char * ) e - base == underflows [ h ] ) { if ( ! check_underflow ( e ) ) { pr_err ( \"Underflows<S2SV_blank>must<S2SV_blank>be<S2SV_blank>unconditional<S2SV_blank>and<S2SV_blank>\" \"use<S2SV_blank>the<S2SV_blank>STANDARD<S2SV_blank>target<S2SV_blank>with<S2SV_blank>\" \"ACCEPT/DROP\\\\n\" ) ; return - EINVAL ; } newinfo -> underflow [ h ] = underflows [ h ] ; } } e -> counters = ( ( struct xt_counters ) { 0 , 0 } ) ; e -> comefrom = 0 ; return 0 ; }\n",
      "fixed_code": "<S2SV_ModStart> arpt_entry ) >= limit || ( unsigned char * ) e + e -> next_offset >\n",
      "source_code_length": 1487,
      "target_code_length": 84,
      "vulnerability_patterns": {
        "use_after_free": 3,
        "integer_overflow": 1,
        "null_pointer": 6,
        "sql_injection": 1,
        "total": 11
      },
      "total_patterns": 11,
      "original_address": "https://github.com/torvalds/linux/commit/6e94e0cfb0887e4013b3b930fa6ab1fe6bb6ba91",
      "discovery_time": "2016-07-03T21:59Z",
      "project_commit_id": "torvalds@linux/6e94e0cfb0887e4013b3b930fa6ab1fe6bb6ba91",
      "extraction_time": "2025-08-31T15:41:49.179311",
      "label": 1,
      "vulnerability_type": "buffer_overflow",
      "difficulty_level": "expert",
      "risk_factors": [
        "memory_corruption",
        "sql_injection",
        "arbitrary_code_execution",
        "system_crash",
        "use_after_free"
      ],
      "attack_vectors": [
        "memory_manipulation",
        "malicious_input",
        "code_analysis",
        "buffer_overflow",
        "reverse_engineering",
        "fuzzing"
      ],
      "mitigation_strategies": [
        "safe_string_functions",
        "dynamic_analysis",
        "code_review",
        "static_analysis",
        "memory_safety_checks",
        "input_validation",
        "fuzzing",
        "bounds_checking",
        "secure_coding_practices"
      ],
      "code_differences": {
        "has_differences": true,
        "source_lines": 2,
        "target_lines": 2,
        "character_differences": 1403,
        "similarity_percentage": 17.56756756756757
      },
      "vulnerability_location": {
        "vulnerability_present": true,
        "fix_applied": true,
        "code_changed": true,
        "estimated_lines_changed": 0
      }
    },
    {
      "cve_id": "CVE-2019-3817",
      "cwe_id": "CWE-416",
      "cwe_name": "Use After Free",
      "project": "rpm-software-management",
      "severity": "critical",
      "weaponization_score": 9.5,
      "is_critical": true,
      "is_weaponizable": true,
      "is_high_priority_project": false,
      "vulnerable_code": "CWE-416 void comps_mrtree_unite ( COMPS_MRTree * rt1 , COMPS_MRTree * rt2 ) { COMPS_HSList * tmplist , * tmp_subnodes ; COMPS_HSListItem * it , * it2 ; struct Pair { COMPS_HSList * subnodes ; char * key ; <S2SV_StartBug> char added ; <S2SV_EndBug> } * pair , * parent_pair ; pair = malloc ( sizeof ( struct Pair ) ) ; pair -> subnodes = rt2 -> subnodes ; pair -> key = NULL ; tmplist = comps_hslist_create ( ) ; comps_hslist_init ( tmplist , NULL , NULL , & free ) ; comps_hslist_append ( tmplist , pair , 0 ) ; while ( tmplist -> first != NULL ) { it = tmplist -> first ; comps_hslist_remove ( tmplist , tmplist -> first ) ; tmp_subnodes = ( ( struct Pair * ) it -> data ) -> subnodes ; parent_pair = ( struct Pair * ) it -> data ; free ( it ) ; <S2SV_StartBug> pair -> added = 0 ; <S2SV_EndBug> for ( it = tmp_subnodes -> first ; it != NULL ; it = it -> next ) { pair = malloc ( sizeof ( struct Pair ) ) ; pair -> subnodes = ( ( COMPS_MRTreeData * ) it -> data ) -> subnodes ; if ( parent_pair -> key != NULL ) { pair -> key = malloc ( sizeof ( char ) * ( strlen ( ( ( COMPS_MRTreeData * ) it -> data ) -> key ) + strlen ( parent_pair -> key ) + 1 ) ) ; memcpy ( pair -> key , parent_pair -> key , sizeof ( char ) * strlen ( parent_pair -> key ) ) ; memcpy ( pair -> key + strlen ( parent_pair -> key ) , ( ( COMPS_MRTreeData * ) it -> data ) -> key , sizeof ( char ) * ( strlen ( ( ( COMPS_MRTreeData * ) it -> data ) -> key ) + 1 ) ) ; } else { pair -> key = malloc ( sizeof ( char ) * ( strlen ( ( ( COMPS_MRTreeData * ) it -> data ) -> key ) + 1 ) ) ; memcpy ( pair -> key , ( ( COMPS_MRTreeData * ) it -> data ) -> key , sizeof ( char ) * ( strlen ( ( ( COMPS_MRTreeData * ) it -> data ) -> key ) + 1 ) ) ; } if ( ( ( COMPS_MRTreeData * ) it -> data ) -> data -> first != NULL ) { for ( it2 = ( ( COMPS_MRTreeData * ) it -> data ) -> data -> first ; it2 != NULL ; it2 = it2 -> next ) { comps_mrtree_set ( rt1 , pair -> key , it2 -> data ) ; } if ( ( ( COMPS_MRTreeData * ) it -> data ) -> subnodes -> first ) { comps_hslist_append ( tmplist , pair , 0 ) ; } else { free ( pair -> key ) ; free ( pair ) ; } } else { if ( ( ( COMPS_MRTreeData * ) it -> data ) -> subnodes -> first ) { comps_hslist_append ( tmplist , pair , 0 ) ; } else { free ( pair -> key ) ; free ( pair ) ; } } } free ( parent_pair -> key ) ; free ( parent_pair ) ; } comps_hslist_destroy ( & tmplist ) ; }\n",
      "fixed_code": "<S2SV_ModStart> * key ; <S2SV_ModEnd> } * pair <S2SV_ModStart> it ) ; <S2SV_ModEnd> for ( it\n",
      "source_code_length": 2383,
      "target_code_length": 93,
      "vulnerability_patterns": {
        "buffer_overflow": 3,
        "use_after_free": 11,
        "null_pointer": 55,
        "memory_leak": 4,
        "total": 73
      },
      "total_patterns": 73,
      "original_address": "https://github.com/rpm-software-management/libcomps/commit/e3a5d056633677959ad924a51758876d415e7046",
      "discovery_time": "2019-03-27T13:29Z",
      "project_commit_id": "rpm-software-management@libcomps/e3a5d056633677959ad924a51758876d415e7046",
      "extraction_time": "2025-08-31T15:41:49.179340",
      "label": 1,
      "vulnerability_type": "use_after_free",
      "difficulty_level": "expert",
      "risk_factors": [
        "denial_of_service",
        "memory_corruption",
        "buffer_overflow",
        "system_crash",
        "use_after_free"
      ],
      "attack_vectors": [
        "memory_manipulation",
        "null_pointer",
        "code_analysis",
        "reverse_engineering",
        "use_after_free",
        "fuzzing"
      ],
      "mitigation_strategies": [
        "null_pointer_checks",
        "fuzzing",
        "dynamic_analysis",
        "memory_management",
        "static_analysis",
        "use_after_free_prevention",
        "code_review",
        "secure_coding_practices"
      ],
      "code_differences": {
        "has_differences": true,
        "source_lines": 2,
        "target_lines": 2,
        "character_differences": 2290,
        "similarity_percentage": 15.517241379310345
      },
      "vulnerability_location": {
        "vulnerability_present": true,
        "fix_applied": true,
        "code_changed": true,
        "estimated_lines_changed": 0
      }
    },
    {
      "cve_id": "CVE-2016-7915",
      "cwe_id": "CWE-125",
      "cwe_name": "Out-of-bounds Read",
      "project": "torvalds",
      "severity": "critical",
      "weaponization_score": 9.5,
      "is_critical": true,
      "is_weaponizable": true,
      "is_high_priority_project": false,
      "vulnerable_code": "CWE-125 static void hid_input_field ( struct hid_device * hid , struct hid_field * field , __u8 * data , int interrupt ) { unsigned n ; unsigned count = field -> report_count ; unsigned offset = field -> report_offset ; unsigned size = field -> report_size ; __s32 min = field -> logical_minimum ; __s32 max = field -> logical_maximum ; __s32 * value ; value = kmalloc ( sizeof ( __s32 ) * count , GFP_ATOMIC ) ; if ( ! value ) return ; for ( n = 0 ; n < count ; n ++ ) { value [ n ] = min < 0 ? snto32 ( hid_field_extract ( hid , data , offset + n * size , size ) , size ) : hid_field_extract ( hid , data , offset + n * size , size ) ; if ( ! ( field -> flags & HID_MAIN_ITEM_VARIABLE ) && <S2SV_StartBug> value [ n ] >= min && value [ n ] <= max && <S2SV_EndBug> field -> usage [ value [ n ] - min ] . hid == HID_UP_KEYBOARD + 1 ) goto exit ; } for ( n = 0 ; n < count ; n ++ ) { if ( HID_MAIN_ITEM_VARIABLE & field -> flags ) { hid_process_event ( hid , field , & field -> usage [ n ] , value [ n ] , interrupt ) ; continue ; } if ( field -> value [ n ] >= min && field -> value [ n ] <= max <S2SV_StartBug> && field -> usage [ field -> value [ n ] - min ] . hid <S2SV_EndBug> && search ( value , field -> value [ n ] , count ) ) hid_process_event ( hid , field , & field -> usage [ field -> value [ n ] - min ] , 0 , interrupt ) ; if ( value [ n ] >= min && value [ n ] <= max <S2SV_StartBug> && field -> usage [ value [ n ] - min ] . hid <S2SV_EndBug> && search ( field -> value , value [ n ] , count ) ) hid_process_event ( hid , field , & field -> usage [ value [ n ] - min ] , 1 , interrupt ) ; } memcpy ( field -> value , value , count * sizeof ( __s32 ) ) ; exit : kfree ( value ) ; }\n",
      "fixed_code": "<S2SV_ModStart> ] <= max && value [ n ] - min < field -> maxusage <S2SV_ModStart> && field -> value [ n ] - min < field -> maxusage && field -> <S2SV_ModStart> <= max && value [ n ] - min < field -> maxusage &&\n",
      "source_code_length": 1696,
      "target_code_length": 211,
      "vulnerability_patterns": {
        "buffer_overflow": 1,
        "use_after_free": 1,
        "integer_overflow": 2,
        "null_pointer": 22,
        "memory_leak": 1,
        "total": 27
      },
      "total_patterns": 27,
      "original_address": "https://github.com/torvalds/linux/commit/50220dead1650609206efe91f0cc116132d59b3f",
      "discovery_time": "2016-11-16T05:59Z",
      "project_commit_id": "torvalds@linux/50220dead1650609206efe91f0cc116132d59b3f",
      "extraction_time": "2025-08-31T15:41:49.179379",
      "label": 1,
      "vulnerability_type": "out-of-bounds_read",
      "difficulty_level": "expert",
      "risk_factors": [
        "memory_corruption",
        "buffer_overflow",
        "information_disclosure",
        "use_after_free",
        "integer_overflow"
      ],
      "attack_vectors": [
        "memory_manipulation",
        "malicious_input",
        "code_analysis",
        "buffer_overflow",
        "reverse_engineering",
        "fuzzing"
      ],
      "mitigation_strategies": [
        "safe_string_functions",
        "dynamic_analysis",
        "code_review",
        "static_analysis",
        "memory_safety_checks",
        "input_validation",
        "fuzzing",
        "bounds_checking",
        "secure_coding_practices"
      ],
      "code_differences": {
        "has_differences": true,
        "source_lines": 2,
        "target_lines": 2,
        "character_differences": 1485,
        "similarity_percentage": 15.789473684210526
      },
      "vulnerability_location": {
        "vulnerability_present": true,
        "fix_applied": true,
        "code_changed": true,
        "estimated_lines_changed": 0
      }
    },
    {
      "cve_id": "CVE-2016-4998",
      "cwe_id": "CWE-119",
      "cwe_name": "Buffer Overflow",
      "project": "torvalds",
      "severity": "critical",
      "weaponization_score": 9.5,
      "is_critical": true,
      "is_weaponizable": true,
      "is_high_priority_project": false,
      "vulnerable_code": "CWE-119 static inline int check_entry_size_and_hooks ( struct arpt_entry * e , struct xt_table_info * newinfo , const unsigned char * base , const unsigned char * limit , const unsigned int * hook_entries , const unsigned int * underflows , unsigned int valid_hooks ) { unsigned int h ; int err ; if ( ( unsigned long ) e % __alignof__ ( struct arpt_entry ) != 0 || <S2SV_StartBug> ( unsigned char * ) e + sizeof ( struct arpt_entry ) >= limit ) { <S2SV_EndBug> duprintf ( \"Bad<S2SV_blank>offset<S2SV_blank>%p\\\\n\" , e ) ; return - EINVAL ; } if ( e -> next_offset < sizeof ( struct arpt_entry ) + sizeof ( struct xt_entry_target ) ) { duprintf ( \"checking:<S2SV_blank>element<S2SV_blank>%p<S2SV_blank>size<S2SV_blank>%u\\\\n\" , e , e -> next_offset ) ; return - EINVAL ; } err = check_entry ( e ) ; if ( err ) return err ; for ( h = 0 ; h < NF_ARP_NUMHOOKS ; h ++ ) { if ( ! ( valid_hooks & ( 1 << h ) ) ) continue ; if ( ( unsigned char * ) e - base == hook_entries [ h ] ) newinfo -> hook_entry [ h ] = hook_entries [ h ] ; if ( ( unsigned char * ) e - base == underflows [ h ] ) { if ( ! check_underflow ( e ) ) { pr_err ( \"Underflows<S2SV_blank>must<S2SV_blank>be<S2SV_blank>unconditional<S2SV_blank>and<S2SV_blank>\" \"use<S2SV_blank>the<S2SV_blank>STANDARD<S2SV_blank>target<S2SV_blank>with<S2SV_blank>\" \"ACCEPT/DROP\\\\n\" ) ; return - EINVAL ; } newinfo -> underflow [ h ] = underflows [ h ] ; } } e -> counters = ( ( struct xt_counters ) { 0 , 0 } ) ; e -> comefrom = 0 ; return 0 ; }\n",
      "fixed_code": "<S2SV_ModStart> arpt_entry ) >= limit || ( unsigned char * ) e + e -> next_offset >\n",
      "source_code_length": 1487,
      "target_code_length": 84,
      "vulnerability_patterns": {
        "use_after_free": 3,
        "integer_overflow": 1,
        "null_pointer": 6,
        "sql_injection": 1,
        "total": 11
      },
      "total_patterns": 11,
      "original_address": "https://github.com/torvalds/linux/commit/6e94e0cfb0887e4013b3b930fa6ab1fe6bb6ba91",
      "discovery_time": "2016-07-03T21:59Z",
      "project_commit_id": "torvalds@linux/6e94e0cfb0887e4013b3b930fa6ab1fe6bb6ba91",
      "extraction_time": "2025-08-31T15:41:49.179414",
      "label": 1,
      "vulnerability_type": "buffer_overflow",
      "difficulty_level": "expert",
      "risk_factors": [
        "memory_corruption",
        "sql_injection",
        "arbitrary_code_execution",
        "system_crash",
        "use_after_free"
      ],
      "attack_vectors": [
        "memory_manipulation",
        "malicious_input",
        "code_analysis",
        "buffer_overflow",
        "reverse_engineering",
        "fuzzing"
      ],
      "mitigation_strategies": [
        "safe_string_functions",
        "dynamic_analysis",
        "code_review",
        "static_analysis",
        "memory_safety_checks",
        "input_validation",
        "fuzzing",
        "bounds_checking",
        "secure_coding_practices"
      ],
      "code_differences": {
        "has_differences": true,
        "source_lines": 2,
        "target_lines": 2,
        "character_differences": 1403,
        "similarity_percentage": 17.56756756756757
      },
      "vulnerability_location": {
        "vulnerability_present": true,
        "fix_applied": true,
        "code_changed": true,
        "estimated_lines_changed": 0
      }
    },
    {
      "cve_id": "CVE-2019-3817",
      "cwe_id": "CWE-416",
      "cwe_name": "Use After Free",
      "project": "rpm-software-management",
      "severity": "critical",
      "weaponization_score": 9.5,
      "is_critical": true,
      "is_weaponizable": true,
      "is_high_priority_project": false,
      "vulnerable_code": "CWE-416 void comps_mrtree_unite ( COMPS_MRTree * rt1 , COMPS_MRTree * rt2 ) { COMPS_HSList * tmplist , * tmp_subnodes ; COMPS_HSListItem * it , * it2 ; struct Pair { COMPS_HSList * subnodes ; char * key ; <S2SV_StartBug> char added ; <S2SV_EndBug> } * pair , * parent_pair ; pair = malloc ( sizeof ( struct Pair ) ) ; pair -> subnodes = rt2 -> subnodes ; pair -> key = NULL ; tmplist = comps_hslist_create ( ) ; comps_hslist_init ( tmplist , NULL , NULL , & free ) ; comps_hslist_append ( tmplist , pair , 0 ) ; while ( tmplist -> first != NULL ) { it = tmplist -> first ; comps_hslist_remove ( tmplist , tmplist -> first ) ; tmp_subnodes = ( ( struct Pair * ) it -> data ) -> subnodes ; parent_pair = ( struct Pair * ) it -> data ; free ( it ) ; <S2SV_StartBug> pair -> added = 0 ; <S2SV_EndBug> for ( it = tmp_subnodes -> first ; it != NULL ; it = it -> next ) { pair = malloc ( sizeof ( struct Pair ) ) ; pair -> subnodes = ( ( COMPS_MRTreeData * ) it -> data ) -> subnodes ; if ( parent_pair -> key != NULL ) { pair -> key = malloc ( sizeof ( char ) * ( strlen ( ( ( COMPS_MRTreeData * ) it -> data ) -> key ) + strlen ( parent_pair -> key ) + 1 ) ) ; memcpy ( pair -> key , parent_pair -> key , sizeof ( char ) * strlen ( parent_pair -> key ) ) ; memcpy ( pair -> key + strlen ( parent_pair -> key ) , ( ( COMPS_MRTreeData * ) it -> data ) -> key , sizeof ( char ) * ( strlen ( ( ( COMPS_MRTreeData * ) it -> data ) -> key ) + 1 ) ) ; } else { pair -> key = malloc ( sizeof ( char ) * ( strlen ( ( ( COMPS_MRTreeData * ) it -> data ) -> key ) + 1 ) ) ; memcpy ( pair -> key , ( ( COMPS_MRTreeData * ) it -> data ) -> key , sizeof ( char ) * ( strlen ( ( ( COMPS_MRTreeData * ) it -> data ) -> key ) + 1 ) ) ; } if ( ( ( COMPS_MRTreeData * ) it -> data ) -> data -> first != NULL ) { for ( it2 = ( ( COMPS_MRTreeData * ) it -> data ) -> data -> first ; it2 != NULL ; it2 = it2 -> next ) { comps_mrtree_set ( rt1 , pair -> key , it2 -> data ) ; } if ( ( ( COMPS_MRTreeData * ) it -> data ) -> subnodes -> first ) { comps_hslist_append ( tmplist , pair , 0 ) ; } else { free ( pair -> key ) ; free ( pair ) ; } } else { if ( ( ( COMPS_MRTreeData * ) it -> data ) -> subnodes -> first ) { comps_hslist_append ( tmplist , pair , 0 ) ; } else { free ( pair -> key ) ; free ( pair ) ; } } } free ( parent_pair -> key ) ; free ( parent_pair ) ; } comps_hslist_destroy ( & tmplist ) ; }\n",
      "fixed_code": "<S2SV_ModStart> * key ; <S2SV_ModEnd> } * pair <S2SV_ModStart> it ) ; <S2SV_ModEnd> for ( it\n",
      "source_code_length": 2383,
      "target_code_length": 93,
      "vulnerability_patterns": {
        "buffer_overflow": 3,
        "use_after_free": 11,
        "null_pointer": 55,
        "memory_leak": 4,
        "total": 73
      },
      "total_patterns": 73,
      "original_address": "https://github.com/rpm-software-management/libcomps/commit/e3a5d056633677959ad924a51758876d415e7046",
      "discovery_time": "2019-03-27T13:29Z",
      "project_commit_id": "rpm-software-management@libcomps/e3a5d056633677959ad924a51758876d415e7046",
      "extraction_time": "2025-08-31T15:41:49.179436",
      "label": 1,
      "vulnerability_type": "use_after_free",
      "difficulty_level": "expert",
      "risk_factors": [
        "denial_of_service",
        "memory_corruption",
        "buffer_overflow",
        "system_crash",
        "use_after_free"
      ],
      "attack_vectors": [
        "memory_manipulation",
        "null_pointer",
        "code_analysis",
        "reverse_engineering",
        "use_after_free",
        "fuzzing"
      ],
      "mitigation_strategies": [
        "null_pointer_checks",
        "fuzzing",
        "dynamic_analysis",
        "memory_management",
        "static_analysis",
        "use_after_free_prevention",
        "code_review",
        "secure_coding_practices"
      ],
      "code_differences": {
        "has_differences": true,
        "source_lines": 2,
        "target_lines": 2,
        "character_differences": 2290,
        "similarity_percentage": 15.517241379310345
      },
      "vulnerability_location": {
        "vulnerability_present": true,
        "fix_applied": true,
        "code_changed": true,
        "estimated_lines_changed": 0
      }
    },
    {
      "cve_id": "CVE-2018-12896",
      "cwe_id": "CWE-190",
      "cwe_name": "Integer Overflow",
      "project": "torvalds",
      "severity": "critical",
      "weaponization_score": 9.5,
      "is_critical": true,
      "is_weaponizable": true,
      "is_high_priority_project": false,
      "vulnerable_code": "CWE-190 static void common_hrtimer_rearm ( struct k_itimer * timr ) { struct hrtimer * timer = & timr -> it . real . timer ; if ( ! timr -> it_interval ) return ; <S2SV_StartBug> timr -> it_overrun += ( unsigned int ) hrtimer_forward ( timer , <S2SV_EndBug> timer -> base -> get_time ( ) , timr -> it_interval ) ; hrtimer_restart ( timer ) ; }\n",
      "fixed_code": "<S2SV_ModStart> -> it_overrun += <S2SV_ModEnd> hrtimer_forward ( timer\n",
      "source_code_length": 344,
      "target_code_length": 71,
      "vulnerability_patterns": {
        "buffer_overflow": 1,
        "use_after_free": 34,
        "null_pointer": 42,
        "total": 77
      },
      "total_patterns": 77,
      "original_address": "https://github.com/torvalds/linux/commit/78c9c4dfbf8c04883941445a195276bb4bb92c76",
      "discovery_time": "2018-07-02T17:29Z",
      "project_commit_id": "torvalds@linux/78c9c4dfbf8c04883941445a195276bb4bb92c76",
      "extraction_time": "2025-08-31T15:41:49.179469",
      "label": 1,
      "vulnerability_type": "integer_overflow",
      "difficulty_level": "expert",
      "risk_factors": [
        "memory_corruption",
        "buffer_overflow",
        "information_disclosure",
        "use_after_free",
        "integer_overflow"
      ],
      "attack_vectors": [
        "fuzzing",
        "code_analysis",
        "reverse_engineering"
      ],
      "mitigation_strategies": [
        "dynamic_analysis",
        "static_analysis",
        "fuzzing",
        "code_review",
        "secure_coding_practices"
      ],
      "code_differences": {
        "has_differences": true,
        "source_lines": 2,
        "target_lines": 2,
        "character_differences": 273,
        "similarity_percentage": 15.789473684210526
      },
      "vulnerability_location": {
        "vulnerability_present": true,
        "fix_applied": true,
        "code_changed": true,
        "estimated_lines_changed": 0
      }
    },
    {
      "cve_id": "CVE-2016-4300",
      "cwe_id": "CWE-190",
      "cwe_name": "Integer Overflow",
      "project": "libarchive",
      "severity": "critical",
      "weaponization_score": 9.5,
      "is_critical": true,
      "is_weaponizable": true,
      "is_high_priority_project": false,
      "vulnerable_code": "CWE-190 static int read_SubStreamsInfo ( struct archive_read * a , struct _7z_substream_info * ss , struct _7z_folder * f , size_t numFolders ) { const unsigned char * p ; uint64_t * usizes ; size_t unpack_streams ; int type ; unsigned i ; uint32_t numDigests ; memset ( ss , 0 , sizeof ( * ss ) ) ; for ( i = 0 ; i < numFolders ; i ++ ) f [ i ] . numUnpackStreams = 1 ; if ( ( p = header_bytes ( a , 1 ) ) == NULL ) return ( - 1 ) ; type = * p ; if ( type == kNumUnPackStream ) { unpack_streams = 0 ; for ( i = 0 ; i < numFolders ; i ++ ) { if ( parse_7zip_uint64 ( a , & ( f [ i ] . numUnpackStreams ) ) < 0 ) return ( - 1 ) ; if ( UMAX_ENTRY < f [ i ] . numUnpackStreams ) return ( - 1 ) ; <S2SV_StartBug> unpack_streams += ( size_t ) f [ i ] . numUnpackStreams ; <S2SV_EndBug> } if ( ( p = header_bytes ( a , 1 ) ) == NULL ) return ( - 1 ) ; type = * p ; } else unpack_streams = numFolders ; ss -> unpack_streams = unpack_streams ; if ( unpack_streams ) { ss -> unpackSizes = calloc ( unpack_streams , sizeof ( * ss -> unpackSizes ) ) ; ss -> digestsDefined = calloc ( unpack_streams , sizeof ( * ss -> digestsDefined ) ) ; ss -> digests = calloc ( unpack_streams , sizeof ( * ss -> digests ) ) ; if ( ss -> unpackSizes == NULL || ss -> digestsDefined == NULL || ss -> digests == NULL ) return ( - 1 ) ; } usizes = ss -> unpackSizes ; for ( i = 0 ; i < numFolders ; i ++ ) { unsigned pack ; uint64_t sum ; if ( f [ i ] . numUnpackStreams == 0 ) continue ; sum = 0 ; if ( type == kSize ) { for ( pack = 1 ; pack < f [ i ] . numUnpackStreams ; pack ++ ) { if ( parse_7zip_uint64 ( a , usizes ) < 0 ) return ( - 1 ) ; sum += * usizes ++ ; } } * usizes ++ = folder_uncompressed_size ( & f [ i ] ) - sum ; } if ( type == kSize ) { if ( ( p = header_bytes ( a , 1 ) ) == NULL ) return ( - 1 ) ; type = * p ; } for ( i = 0 ; i < unpack_streams ; i ++ ) { ss -> digestsDefined [ i ] = 0 ; ss -> digests [ i ] = 0 ; } numDigests = 0 ; for ( i = 0 ; i < numFolders ; i ++ ) { if ( f [ i ] . numUnpackStreams != 1 || ! f [ i ] . digest_defined ) numDigests += ( uint32_t ) f [ i ] . numUnpackStreams ; } if ( type == kCRC ) { struct _7z_digests tmpDigests ; unsigned char * digestsDefined = ss -> digestsDefined ; uint32_t * digests = ss -> digests ; int di = 0 ; memset ( & tmpDigests , 0 , sizeof ( tmpDigests ) ) ; if ( read_Digests ( a , & ( tmpDigests ) , numDigests ) < 0 ) { free_Digest ( & tmpDigests ) ; return ( - 1 ) ; } for ( i = 0 ; i < numFolders ; i ++ ) { if ( f [ i ] . numUnpackStreams == 1 && f [ i ] . digest_defined ) { * digestsDefined ++ = 1 ; * digests ++ = f [ i ] . digest ; } else { unsigned j ; for ( j = 0 ; j < f [ i ] . numUnpackStreams ; j ++ , di ++ ) { * digestsDefined ++ = tmpDigests . defineds [ di ] ; * digests ++ = tmpDigests . digests [ di ] ; } } } free_Digest ( & tmpDigests ) ; if ( ( p = header_bytes ( a , 1 ) ) == NULL ) return ( - 1 ) ; type = * p ; } if ( type != kEnd ) return ( - 1 ) ; return ( 0 ) ; }\n",
      "fixed_code": "<S2SV_ModStart> 1 ) ; if ( unpack_streams > SIZE_MAX - UMAX_ENTRY ) { return ( - 1 ) ; }\n",
      "source_code_length": 2947,
      "target_code_length": 89,
      "vulnerability_patterns": {
        "buffer_overflow": 2,
        "use_after_free": 3,
        "integer_overflow": 18,
        "null_pointer": 15,
        "memory_leak": 3,
        "total": 41
      },
      "total_patterns": 41,
      "original_address": "https://github.com/libarchive/libarchive/commit/e79ef306afe332faf22e9b442a2c6b59cb175573",
      "discovery_time": "2016-09-21T14:25Z",
      "project_commit_id": "libarchive@libarchive/e79ef306afe332faf22e9b442a2c6b59cb175573",
      "extraction_time": "2025-08-31T15:41:49.179492",
      "label": 1,
      "vulnerability_type": "integer_overflow",
      "difficulty_level": "expert",
      "risk_factors": [
        "memory_corruption",
        "buffer_overflow",
        "information_disclosure",
        "use_after_free",
        "integer_overflow"
      ],
      "attack_vectors": [
        "fuzzing",
        "code_analysis",
        "reverse_engineering"
      ],
      "mitigation_strategies": [
        "dynamic_analysis",
        "static_analysis",
        "fuzzing",
        "code_review",
        "secure_coding_practices"
      ],
      "code_differences": {
        "has_differences": true,
        "source_lines": 2,
        "target_lines": 2,
        "character_differences": 2858,
        "similarity_percentage": 12.941176470588237
      },
      "vulnerability_location": {
        "vulnerability_present": true,
        "fix_applied": true,
        "code_changed": true,
        "estimated_lines_changed": 0
      }
    },
    {
      "cve_id": "CVE-2016-4998",
      "cwe_id": "CWE-119",
      "cwe_name": "Buffer Overflow",
      "project": "torvalds",
      "severity": "critical",
      "weaponization_score": 9.5,
      "is_critical": true,
      "is_weaponizable": true,
      "is_high_priority_project": false,
      "vulnerable_code": "CWE-119 static inline int check_entry_size_and_hooks ( struct arpt_entry * e , struct xt_table_info * newinfo , const unsigned char * base , const unsigned char * limit , const unsigned int * hook_entries , const unsigned int * underflows , unsigned int valid_hooks ) { unsigned int h ; int err ; if ( ( unsigned long ) e % __alignof__ ( struct arpt_entry ) != 0 || <S2SV_StartBug> ( unsigned char * ) e + sizeof ( struct arpt_entry ) >= limit ) { <S2SV_EndBug> duprintf ( \"Bad<S2SV_blank>offset<S2SV_blank>%p\\\\n\" , e ) ; return - EINVAL ; } if ( e -> next_offset < sizeof ( struct arpt_entry ) + sizeof ( struct xt_entry_target ) ) { duprintf ( \"checking:<S2SV_blank>element<S2SV_blank>%p<S2SV_blank>size<S2SV_blank>%u\\\\n\" , e , e -> next_offset ) ; return - EINVAL ; } err = check_entry ( e ) ; if ( err ) return err ; for ( h = 0 ; h < NF_ARP_NUMHOOKS ; h ++ ) { if ( ! ( valid_hooks & ( 1 << h ) ) ) continue ; if ( ( unsigned char * ) e - base == hook_entries [ h ] ) newinfo -> hook_entry [ h ] = hook_entries [ h ] ; if ( ( unsigned char * ) e - base == underflows [ h ] ) { if ( ! check_underflow ( e ) ) { pr_err ( \"Underflows<S2SV_blank>must<S2SV_blank>be<S2SV_blank>unconditional<S2SV_blank>and<S2SV_blank>\" \"use<S2SV_blank>the<S2SV_blank>STANDARD<S2SV_blank>target<S2SV_blank>with<S2SV_blank>\" \"ACCEPT/DROP\\\\n\" ) ; return - EINVAL ; } newinfo -> underflow [ h ] = underflows [ h ] ; } } e -> counters = ( ( struct xt_counters ) { 0 , 0 } ) ; e -> comefrom = 0 ; return 0 ; }\n",
      "fixed_code": "<S2SV_ModStart> arpt_entry ) >= limit || ( unsigned char * ) e + e -> next_offset >\n",
      "source_code_length": 1487,
      "target_code_length": 84,
      "vulnerability_patterns": {
        "use_after_free": 3,
        "integer_overflow": 1,
        "null_pointer": 6,
        "sql_injection": 1,
        "total": 11
      },
      "total_patterns": 11,
      "original_address": "https://github.com/torvalds/linux/commit/6e94e0cfb0887e4013b3b930fa6ab1fe6bb6ba91",
      "discovery_time": "2016-07-03T21:59Z",
      "project_commit_id": "torvalds@linux/6e94e0cfb0887e4013b3b930fa6ab1fe6bb6ba91",
      "extraction_time": "2025-08-31T15:41:49.179535",
      "label": 1,
      "vulnerability_type": "buffer_overflow",
      "difficulty_level": "expert",
      "risk_factors": [
        "memory_corruption",
        "sql_injection",
        "arbitrary_code_execution",
        "system_crash",
        "use_after_free"
      ],
      "attack_vectors": [
        "memory_manipulation",
        "malicious_input",
        "code_analysis",
        "buffer_overflow",
        "reverse_engineering",
        "fuzzing"
      ],
      "mitigation_strategies": [
        "safe_string_functions",
        "dynamic_analysis",
        "code_review",
        "static_analysis",
        "memory_safety_checks",
        "input_validation",
        "fuzzing",
        "bounds_checking",
        "secure_coding_practices"
      ],
      "code_differences": {
        "has_differences": true,
        "source_lines": 2,
        "target_lines": 2,
        "character_differences": 1403,
        "similarity_percentage": 17.56756756756757
      },
      "vulnerability_location": {
        "vulnerability_present": true,
        "fix_applied": true,
        "code_changed": true,
        "estimated_lines_changed": 0
      }
    },
    {
      "cve_id": "CVE-2017-14502",
      "cwe_id": "CWE-125",
      "cwe_name": "Out-of-bounds Read",
      "project": "libarchive",
      "severity": "critical",
      "weaponization_score": 9.5,
      "is_critical": true,
      "is_weaponizable": true,
      "is_high_priority_project": false,
      "vulnerable_code": "CWE-125 static int read_header ( struct archive_read * a , struct archive_entry * entry , char head_type ) { const void * h ; const char * p , * endp ; struct rar * rar ; struct rar_header rar_header ; struct rar_file_header file_header ; int64_t header_size ; unsigned filename_size , end ; char * filename ; char * strp ; char packed_size [ 8 ] ; char unp_size [ 8 ] ; int ttime ; struct archive_string_conv * sconv , * fn_sconv ; unsigned long crc32_val ; int ret = ( ARCHIVE_OK ) , ret2 ; rar = ( struct rar * ) ( a -> format -> data ) ; sconv = rar -> opt_sconv ; if ( sconv == NULL ) { if ( ! rar -> init_default_conversion ) { rar -> sconv_default = archive_string_default_conversion_for_read ( & ( a -> archive ) ) ; rar -> init_default_conversion = 1 ; } sconv = rar -> sconv_default ; } if ( ( h = __archive_read_ahead ( a , 7 , NULL ) ) == NULL ) return ( ARCHIVE_FATAL ) ; p = h ; memcpy ( & rar_header , p , sizeof ( rar_header ) ) ; rar -> file_flags = archive_le16dec ( rar_header . flags ) ; header_size = archive_le16dec ( rar_header . size ) ; if ( header_size < ( int64_t ) sizeof ( file_header ) + 7 ) { archive_set_error ( & a -> archive , ARCHIVE_ERRNO_FILE_FORMAT , \"Invalid<S2SV_blank>header<S2SV_blank>size\" ) ; return ( ARCHIVE_FATAL ) ; } crc32_val = crc32 ( 0 , ( const unsigned char * ) p + 2 , 7 - 2 ) ; __archive_read_consume ( a , 7 ) ; if ( ! ( rar -> file_flags & FHD_SOLID ) ) { rar -> compression_method = 0 ; rar -> packed_size = 0 ; rar -> unp_size = 0 ; rar -> mtime = 0 ; rar -> ctime = 0 ; rar -> atime = 0 ; rar -> arctime = 0 ; rar -> mode = 0 ; memset ( & rar -> salt , 0 , sizeof ( rar -> salt ) ) ; rar -> atime = 0 ; rar -> ansec = 0 ; rar -> ctime = 0 ; rar -> cnsec = 0 ; rar -> mtime = 0 ; rar -> mnsec = 0 ; rar -> arctime = 0 ; rar -> arcnsec = 0 ; } else { archive_set_error ( & a -> archive , ARCHIVE_ERRNO_FILE_FORMAT , \"RAR<S2SV_blank>solid<S2SV_blank>archive<S2SV_blank>support<S2SV_blank>unavailable.\" ) ; return ( ARCHIVE_FATAL ) ; } if ( ( h = __archive_read_ahead ( a , ( size_t ) header_size - 7 , NULL ) ) == NULL ) return ( ARCHIVE_FATAL ) ; crc32_val = crc32 ( crc32_val , h , ( unsigned ) ( header_size - 7 ) ) ; if ( ( crc32_val & 0xffff ) != archive_le16dec ( rar_header . crc ) ) { archive_set_error ( & a -> archive , ARCHIVE_ERRNO_FILE_FORMAT , \"Header<S2SV_blank>CRC<S2SV_blank>error\" ) ; return ( ARCHIVE_FATAL ) ; } p = h ; endp = p + header_size - 7 ; memcpy ( & file_header , p , sizeof ( file_header ) ) ; p += sizeof ( file_header ) ; rar -> compression_method = file_header . method ; ttime = archive_le32dec ( file_header . file_time ) ; rar -> mtime = get_time ( ttime ) ; rar -> file_crc = archive_le32dec ( file_header . file_crc ) ; if ( rar -> file_flags & FHD_PASSWORD ) { archive_entry_set_is_data_encrypted ( entry , 1 ) ; rar -> has_encrypted_entries = 1 ; archive_set_error ( & a -> archive , ARCHIVE_ERRNO_FILE_FORMAT , \"RAR<S2SV_blank>encryption<S2SV_blank>support<S2SV_blank>unavailable.\" ) ; } if ( rar -> file_flags & FHD_LARGE ) { memcpy ( packed_size , file_header . pack_size , 4 ) ; memcpy ( packed_size + 4 , p , 4 ) ; p += 4 ; memcpy ( unp_size , file_header . unp_size , 4 ) ; memcpy ( unp_size + 4 , p , 4 ) ; p += 4 ; rar -> packed_size = archive_le64dec ( & packed_size ) ; rar -> unp_size = archive_le64dec ( & unp_size ) ; } else { rar -> packed_size = archive_le32dec ( file_header . pack_size ) ; rar -> unp_size = archive_le32dec ( file_header . unp_size ) ; } if ( rar -> packed_size < 0 || rar -> unp_size < 0 ) { archive_set_error ( & a -> archive , ARCHIVE_ERRNO_FILE_FORMAT , \"Invalid<S2SV_blank>sizes<S2SV_blank>specified.\" ) ; return ( ARCHIVE_FATAL ) ; } rar -> bytes_remaining = rar -> packed_size ; if ( head_type == NEWSUB_HEAD ) { size_t distance = p - ( const char * ) h ; header_size += rar -> packed_size ; if ( ( h = __archive_read_ahead ( a , ( size_t ) header_size - 7 , NULL ) ) == NULL ) return ( ARCHIVE_FATAL ) ; p = h ; endp = p + header_size - 7 ; p += distance ; } filename_size = archive_le16dec ( file_header . name_size ) ; if ( p + filename_size > endp ) { archive_set_error ( & a -> archive , ARCHIVE_ERRNO_FILE_FORMAT , \"Invalid<S2SV_blank>filename<S2SV_blank>size\" ) ; return ( ARCHIVE_FATAL ) ; } if ( rar -> filename_allocated < filename_size * 2 + 2 ) { char * newptr ; size_t newsize = filename_size * 2 + 2 ; newptr = realloc ( rar -> filename , newsize ) ; if ( newptr == NULL ) { archive_set_error ( & a -> archive , ENOMEM , \"Couldn\\'t<S2SV_blank>allocate<S2SV_blank>memory.\" ) ; return ( ARCHIVE_FATAL ) ; } rar -> filename = newptr ; rar -> filename_allocated = newsize ; } filename = rar -> filename ; memcpy ( filename , p , filename_size ) ; filename [ filename_size ] = '\\\\0' ; if ( rar -> file_flags & FHD_UNICODE ) { if ( filename_size != strlen ( filename ) ) { unsigned char highbyte , flagbits , flagbyte ; unsigned fn_end , offset ; end = filename_size ; fn_end = filename_size * 2 ; filename_size = 0 ; offset = ( unsigned ) strlen ( filename ) + 1 ; highbyte = * ( p + offset ++ ) ; flagbits = 0 ; flagbyte = 0 ; while ( offset < end && filename_size < fn_end ) { if ( ! flagbits ) { flagbyte = * ( p + offset ++ ) ; flagbits = 8 ; } flagbits -= 2 ; switch ( ( flagbyte >> flagbits ) & 3 ) { case 0 : filename [ filename_size ++ ] = '\\\\0' ; filename [ filename_size ++ ] = * ( p + offset ++ ) ; break ; case 1 : filename [ filename_size ++ ] = highbyte ; filename [ filename_size ++ ] = * ( p + offset ++ ) ; break ; case 2 : filename [ filename_size ++ ] = * ( p + offset + 1 ) ; filename [ filename_size ++ ] = * ( p + offset ) ; offset += 2 ; break ; case 3 : { char extra , high ; uint8_t length = * ( p + offset ++ ) ; if ( length & 0x80 ) { extra = * ( p + offset ++ ) ; high = ( char ) highbyte ; } else extra = high = 0 ; length = ( length & 0x7f ) + 2 ; while ( length && filename_size < fn_end ) { unsigned cp = filename_size >> 1 ; filename [ filename_size ++ ] = high ; filename [ filename_size ++ ] = p [ cp ] + extra ; length -- ; } } break ; } } if ( filename_size > fn_end ) { archive_set_error ( & a -> archive , ARCHIVE_ERRNO_FILE_FORMAT , \"Invalid<S2SV_blank>filename\" ) ; return ( ARCHIVE_FATAL ) ; } filename [ filename_size ++ ] = '\\\\0' ; <S2SV_StartBug> filename [ filename_size ++ ] = '\\\\0' ; <S2SV_EndBug> if ( rar -> sconv_utf16be == NULL ) { rar -> sconv_utf16be = archive_string_conversion_from_charset ( & a -> archive , \"UTF-16BE\" , 1 ) ; if ( rar -> sconv_utf16be == NULL ) return ( ARCHIVE_FATAL ) ; } fn_sconv = rar -> sconv_utf16be ; strp = filename ; while ( memcmp ( strp , \"\\\\x00\\\\x00\" , 2 ) ) { if ( ! memcmp ( strp , \"\\\\x00\\\\\\\\\" , 2 ) ) * ( strp + 1 ) = '/' ; strp += 2 ; } p += offset ; } else { if ( rar -> sconv_utf8 == NULL ) { rar -> sconv_utf8 = archive_string_conversion_from_charset ( & a -> archive , \"UTF-8\" , 1 ) ; if ( rar -> sconv_utf8 == NULL ) return ( ARCHIVE_FATAL ) ; } fn_sconv = rar -> sconv_utf8 ; while ( ( strp = strchr ( filename , '\\\\\\\\' ) ) != NULL ) * strp = '/' ; p += filename_size ; } } else { fn_sconv = sconv ; while ( ( strp = strchr ( filename , '\\\\\\\\' ) ) != NULL ) * strp = '/' ; p += filename_size ; } if ( rar -> filename_save && filename_size == rar -> filename_save_size && ! memcmp ( rar -> filename , rar -> filename_save , filename_size + 1 ) ) { __archive_read_consume ( a , header_size - 7 ) ; rar -> cursor ++ ; if ( rar -> cursor >= rar -> nodes ) { rar -> nodes ++ ; if ( ( rar -> dbo = realloc ( rar -> dbo , sizeof ( * rar -> dbo ) * rar -> nodes ) ) == NULL ) { archive_set_error ( & a -> archive , ENOMEM , \"Couldn\\'t<S2SV_blank>allocate<S2SV_blank>memory.\" ) ; return ( ARCHIVE_FATAL ) ; } rar -> dbo [ rar -> cursor ] . header_size = header_size ; rar -> dbo [ rar -> cursor ] . start_offset = - 1 ; rar -> dbo [ rar -> cursor ] . end_offset = - 1 ; } if ( rar -> dbo [ rar -> cursor ] . start_offset < 0 ) { rar -> dbo [ rar -> cursor ] . start_offset = a -> filter -> position ; rar -> dbo [ rar -> cursor ] . end_offset = rar -> dbo [ rar -> cursor ] . start_offset + rar -> packed_size ; } return ret ; } rar -> filename_save = ( char * ) realloc ( rar -> filename_save , filename_size + 1 ) ; memcpy ( rar -> filename_save , rar -> filename , filename_size + 1 ) ; rar -> filename_save_size = filename_size ; free ( rar -> dbo ) ; if ( ( rar -> dbo = calloc ( 1 , sizeof ( * rar -> dbo ) ) ) == NULL ) { archive_set_error ( & a -> archive , ENOMEM , \"Couldn\\'t<S2SV_blank>allocate<S2SV_blank>memory.\" ) ; return ( ARCHIVE_FATAL ) ; } rar -> dbo [ 0 ] . header_size = header_size ; rar -> dbo [ 0 ] . start_offset = - 1 ; rar -> dbo [ 0 ] . end_offset = - 1 ; rar -> cursor = 0 ; rar -> nodes = 1 ; if ( rar -> file_flags & FHD_SALT ) { if ( p + 8 > endp ) { archive_set_error ( & a -> archive , ARCHIVE_ERRNO_FILE_FORMAT , \"Invalid<S2SV_blank>header<S2SV_blank>size\" ) ; return ( ARCHIVE_FATAL ) ; } memcpy ( rar -> salt , p , 8 ) ; p += 8 ; } if ( rar -> file_flags & FHD_EXTTIME ) { if ( read_exttime ( p , rar , endp ) < 0 ) { archive_set_error ( & a -> archive , ARCHIVE_ERRNO_FILE_FORMAT , \"Invalid<S2SV_blank>header<S2SV_blank>size\" ) ; return ( ARCHIVE_FATAL ) ; } } __archive_read_consume ( a , header_size - 7 ) ; rar -> dbo [ 0 ] . start_offset = a -> filter -> position ; rar -> dbo [ 0 ] . end_offset = rar -> dbo [ 0 ] . start_offset + rar -> packed_size ; switch ( file_header . host_os ) { case OS_MSDOS : case OS_OS2 : case OS_WIN32 : rar -> mode = archive_le32dec ( file_header . file_attr ) ; if ( rar -> mode & FILE_ATTRIBUTE_DIRECTORY ) rar -> mode = AE_IFDIR | S_IXUSR | S_IXGRP | S_IXOTH ; else rar -> mode = AE_IFREG ; rar -> mode |= S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH ; break ; case OS_UNIX : case OS_MAC_OS : case OS_BEOS : rar -> mode = archive_le32dec ( file_header . file_attr ) ; break ; default : archive_set_error ( & a -> archive , ARCHIVE_ERRNO_FILE_FORMAT , \"Unknown<S2SV_blank>file<S2SV_blank>attributes<S2SV_blank>from<S2SV_blank>RAR<S2SV_blank>file\\'s<S2SV_blank>host<S2SV_blank>OS\" ) ; return ( ARCHIVE_FATAL ) ; } rar -> bytes_uncopied = rar -> bytes_unconsumed = 0 ; rar -> lzss . position = rar -> offset = 0 ; rar -> offset_seek = 0 ; rar -> dictionary_size = 0 ; rar -> offset_outgoing = 0 ; rar -> br . cache_avail = 0 ; rar -> br . avail_in = 0 ; rar -> crc_calculated = 0 ; rar -> entry_eof = 0 ; rar -> valid = 1 ; rar -> is_ppmd_block = 0 ; rar -> start_new_table = 1 ; free ( rar -> unp_buffer ) ; rar -> unp_buffer = NULL ; rar -> unp_offset = 0 ; rar -> unp_buffer_size = UNP_BUFFER_SIZE ; memset ( rar -> lengthtable , 0 , sizeof ( rar -> lengthtable ) ) ; __archive_ppmd7_functions . Ppmd7_Free ( & rar -> ppmd7_context , & g_szalloc ) ; rar -> ppmd_valid = rar -> ppmd_eod = 0 ; if ( head_type == NEWSUB_HEAD ) return ret ; archive_entry_set_mtime ( entry , rar -> mtime , rar -> mnsec ) ; archive_entry_set_ctime ( entry , rar -> ctime , rar -> cnsec ) ; archive_entry_set_atime ( entry , rar -> atime , rar -> ansec ) ; archive_entry_set_size ( entry , rar -> unp_size ) ; archive_entry_set_mode ( entry , rar -> mode ) ; if ( archive_entry_copy_pathname_l ( entry , filename , filename_size , fn_sconv ) ) { if ( errno == ENOMEM ) { archive_set_error ( & a -> archive , ENOMEM , \"Can\\'t<S2SV_blank>allocate<S2SV_blank>memory<S2SV_blank>for<S2SV_blank>Pathname\" ) ; return ( ARCHIVE_FATAL ) ; } archive_set_error ( & a -> archive , ARCHIVE_ERRNO_FILE_FORMAT , \"Pathname<S2SV_blank>cannot<S2SV_blank>be<S2SV_blank>converted<S2SV_blank>from<S2SV_blank>%s<S2SV_blank>to<S2SV_blank>current<S2SV_blank>locale.\" , archive_string_conversion_charset_name ( fn_sconv ) ) ; ret = ( ARCHIVE_WARN ) ; } if ( ( ( rar -> mode ) & AE_IFMT ) == AE_IFLNK ) { rar -> bytes_remaining = 0 ; archive_entry_set_size ( entry , 0 ) ; if ( ( ret2 = read_symlink_stored ( a , entry , sconv ) ) < ( ARCHIVE_WARN ) ) return ret2 ; if ( ret > ret2 ) ret = ret2 ; } if ( rar -> bytes_remaining == 0 ) rar -> entry_eof = 1 ; return ret ; }\n",
      "fixed_code": "<S2SV_ModStart> filename [ filename_size <S2SV_ModEnd> ] = '\\\\0'\n",
      "source_code_length": 11930,
      "target_code_length": 65,
      "vulnerability_patterns": {
        "buffer_overflow": 11,
        "use_after_free": 15,
        "integer_overflow": 31,
        "null_pointer": 170,
        "memory_leak": 4,
        "total": 231
      },
      "total_patterns": 231,
      "original_address": "https://github.com/libarchive/libarchive/commit/5562545b5562f6d12a4ef991fae158bf4ccf92b6",
      "discovery_time": "2017-09-17T18:29Z",
      "project_commit_id": "libarchive@libarchive/5562545b5562f6d12a4ef991fae158bf4ccf92b6",
      "extraction_time": "2025-08-31T15:41:49.179563",
      "label": 1,
      "vulnerability_type": "out-of-bounds_read",
      "difficulty_level": "expert",
      "risk_factors": [
        "memory_corruption",
        "buffer_overflow",
        "information_disclosure",
        "use_after_free",
        "integer_overflow"
      ],
      "attack_vectors": [
        "memory_manipulation",
        "malicious_input",
        "code_analysis",
        "buffer_overflow",
        "reverse_engineering",
        "fuzzing"
      ],
      "mitigation_strategies": [
        "safe_string_functions",
        "dynamic_analysis",
        "code_review",
        "static_analysis",
        "memory_safety_checks",
        "input_validation",
        "fuzzing",
        "bounds_checking",
        "secure_coding_practices"
      ],
      "code_differences": {
        "has_differences": true,
        "source_lines": 2,
        "target_lines": 2,
        "character_differences": 11865,
        "similarity_percentage": 2.4
      },
      "vulnerability_location": {
        "vulnerability_present": true,
        "fix_applied": true,
        "code_changed": true,
        "estimated_lines_changed": 0
      }
    },
    {
      "cve_id": "CVE-2020-26570",
      "cwe_id": "CWE-787",
      "cwe_name": "Out-of-bounds Write",
      "project": "OpenSC",
      "severity": "critical",
      "weaponization_score": 9.5,
      "is_critical": true,
      "is_weaponizable": true,
      "is_high_priority_project": false,
      "vulnerable_code": "CWE-787 static int sc_oberthur_read_file ( struct sc_pkcs15_card * p15card , const char * in_path , unsigned char * * out , size_t * out_len , int verify_pin ) { struct sc_context * ctx = p15card -> card -> ctx ; struct sc_card * card = p15card -> card ; struct sc_file * file = NULL ; struct sc_path path ; size_t sz ; int rv ; LOG_FUNC_CALLED ( ctx ) ; if ( ! in_path || ! out || ! out_len ) LOG_TEST_RET ( ctx , SC_ERROR_INVALID_ARGUMENTS , \"Cannot<S2SV_blank>read<S2SV_blank>oberthur<S2SV_blank>file\" ) ; sc_log ( ctx , \"read<S2SV_blank>file<S2SV_blank>\\'%s\\';<S2SV_blank>verify_pin:%i\" , in_path , verify_pin ) ; * out = NULL ; * out_len = 0 ; sc_format_path ( in_path , & path ) ; rv = sc_select_file ( card , & path , & file ) ; if ( rv != SC_SUCCESS ) { sc_file_free ( file ) ; LOG_TEST_RET ( ctx , rv , \"Cannot<S2SV_blank>select<S2SV_blank>oberthur<S2SV_blank>file<S2SV_blank>to<S2SV_blank>read\" ) ; } if ( file -> ef_structure == SC_FILE_EF_TRANSPARENT ) sz = file -> size ; else sz = ( file -> record_length + 2 ) * file -> record_count ; * out = calloc ( sz , 1 ) ; if ( * out == NULL ) { sc_file_free ( file ) ; LOG_TEST_RET ( ctx , SC_ERROR_OUT_OF_MEMORY , \"Cannot<S2SV_blank>read<S2SV_blank>oberthur<S2SV_blank>file\" ) ; } if ( file -> ef_structure == SC_FILE_EF_TRANSPARENT ) { rv = sc_read_binary ( card , 0 , * out , sz , 0 ) ; } else { <S2SV_StartBug> int rec ; <S2SV_EndBug> int offs = 0 ; <S2SV_StartBug> int rec_len = file -> record_length ; <S2SV_EndBug> <S2SV_StartBug> for ( rec = 1 ; ; rec ++ ) { <S2SV_EndBug> rv = sc_read_record ( card , rec , * out + offs + 2 , rec_len , SC_RECORD_BY_REC_NR ) ; if ( rv == SC_ERROR_RECORD_NOT_FOUND ) { rv = 0 ; break ; } else if ( rv < 0 ) { break ; } rec_len = rv ; * ( * out + offs ) = 'R' ; * ( * out + offs + 1 ) = rv ; offs += rv + 2 ; } sz = offs ; } sc_log ( ctx , \"read<S2SV_blank>oberthur<S2SV_blank>file<S2SV_blank>result<S2SV_blank>%i\" , rv ) ; if ( verify_pin && rv == SC_ERROR_SECURITY_STATUS_NOT_SATISFIED ) { struct sc_pkcs15_object * objs [ 0x10 ] , * pin_obj = NULL ; const struct sc_acl_entry * acl = sc_file_get_acl_entry ( file , SC_AC_OP_READ ) ; int ii ; rv = sc_pkcs15_get_objects ( p15card , SC_PKCS15_TYPE_AUTH_PIN , objs , 0x10 ) ; if ( rv != SC_SUCCESS ) { sc_file_free ( file ) ; LOG_TEST_RET ( ctx , rv , \"Cannot<S2SV_blank>read<S2SV_blank>oberthur<S2SV_blank>file:<S2SV_blank>get<S2SV_blank>AUTH<S2SV_blank>objects<S2SV_blank>error\" ) ; } for ( ii = 0 ; ii < rv ; ii ++ ) { struct sc_pkcs15_auth_info * auth_info = ( struct sc_pkcs15_auth_info * ) objs [ ii ] -> data ; sc_log ( ctx , \"compare<S2SV_blank>PIN/ACL<S2SV_blank>refs:%i/%i,<S2SV_blank>method:%i/%i\" , auth_info -> attrs . pin . reference , acl -> key_ref , auth_info -> auth_method , acl -> method ) ; if ( auth_info -> attrs . pin . reference == ( int ) acl -> key_ref && auth_info -> auth_method == ( unsigned ) acl -> method ) { pin_obj = objs [ ii ] ; break ; } } if ( ! pin_obj || ! pin_obj -> content . value ) { rv = SC_ERROR_SECURITY_STATUS_NOT_SATISFIED ; } else { rv = sc_pkcs15_verify_pin ( p15card , pin_obj , pin_obj -> content . value , pin_obj -> content . len ) ; if ( ! rv ) rv = sc_oberthur_read_file ( p15card , in_path , out , out_len , 0 ) ; } } ; sc_file_free ( file ) ; if ( rv < 0 ) { free ( * out ) ; * out = NULL ; * out_len = 0 ; } * out_len = sz ; LOG_FUNC_RETURN ( ctx , rv ) ; }\n",
      "fixed_code": "<S2SV_ModStart> } else { size_t rec ; size_t <S2SV_ModEnd> offs = 0 <S2SV_ModStart> = 0 ; size_t <S2SV_ModEnd> rec_len = file <S2SV_ModStart> ++ ) { if ( rec > file -> record_count ) { rv = 0 ; break ; }\n",
      "source_code_length": 3365,
      "target_code_length": 204,
      "vulnerability_patterns": {
        "use_after_free": 2,
        "integer_overflow": 3,
        "null_pointer": 23,
        "sql_injection": 1,
        "memory_leak": 1,
        "total": 30
      },
      "total_patterns": 30,
      "original_address": "https://github.com/OpenSC/OpenSC/commit/6903aebfddc466d966c7b865fae34572bf3ed23e",
      "discovery_time": "2020-10-06T02:15Z",
      "project_commit_id": "OpenSC@OpenSC/6903aebfddc466d966c7b865fae34572bf3ed23e",
      "extraction_time": "2025-08-31T15:41:49.179672",
      "label": 1,
      "vulnerability_type": "out-of-bounds_write",
      "difficulty_level": "expert",
      "risk_factors": [
        "memory_corruption",
        "sql_injection",
        "arbitrary_code_execution",
        "system_crash",
        "use_after_free"
      ],
      "attack_vectors": [
        "memory_manipulation",
        "malicious_input",
        "code_analysis",
        "buffer_overflow",
        "reverse_engineering",
        "fuzzing"
      ],
      "mitigation_strategies": [
        "safe_string_functions",
        "dynamic_analysis",
        "code_review",
        "static_analysis",
        "memory_safety_checks",
        "input_validation",
        "fuzzing",
        "bounds_checking",
        "secure_coding_practices"
      ],
      "code_differences": {
        "has_differences": true,
        "source_lines": 2,
        "target_lines": 2,
        "character_differences": 3161,
        "similarity_percentage": 16.379310344827587
      },
      "vulnerability_location": {
        "vulnerability_present": true,
        "fix_applied": true,
        "code_changed": true,
        "estimated_lines_changed": 0
      }
    },
    {
      "cve_id": "CVE-2017-16359",
      "cwe_id": "CWE-476",
      "cwe_name": "NULL Pointer Dereference",
      "project": "radare",
      "severity": "critical",
      "weaponization_score": 9.5,
      "is_critical": true,
      "is_weaponizable": true,
      "is_high_priority_project": true,
      "vulnerable_code": "CWE-476 static Sdb * store_versioninfo_gnu_verdef ( ELFOBJ * bin , Elf_ ( Shdr ) * shdr , int sz ) { const char * section_name = \"\" ; const char * link_section_name = \"\" ; char * end = NULL ; Elf_ ( Shdr ) * link_shdr = NULL ; ut8 dfs [ sizeof ( Elf_ ( Verdef ) ) ] = { 0 } ; Sdb * sdb ; int cnt , i ; if ( shdr -> sh_link > bin -> ehdr . e_shnum ) { return false ; } link_shdr = & bin -> shdr [ shdr -> sh_link ] ; if ( ( int ) shdr -> sh_size < 1 ) { return false ; } Elf_ ( Verdef ) * defs = calloc ( shdr -> sh_size , sizeof ( char ) ) ; if ( ! defs ) { return false ; } if ( bin -> shstrtab && shdr -> sh_name < bin -> shstrtab_size ) { section_name = & bin -> shstrtab [ shdr -> sh_name ] ; } if ( link_shdr && bin -> shstrtab && link_shdr -> sh_name < bin -> shstrtab_size ) { link_section_name = & bin -> shstrtab [ link_shdr -> sh_name ] ; } if ( ! defs ) { bprintf ( \"Warning:<S2SV_blank>Cannot<S2SV_blank>allocate<S2SV_blank>memory<S2SV_blank>(Check<S2SV_blank>Elf_(Verdef))\\\\n\" ) ; return NULL ; } sdb = sdb_new0 ( ) ; end = ( char * ) defs + shdr -> sh_size ; sdb_set ( sdb , \"section_name\" , section_name , 0 ) ; sdb_num_set ( sdb , \"entries\" , shdr -> sh_info , 0 ) ; sdb_num_set ( sdb , \"addr\" , shdr -> sh_addr , 0 ) ; sdb_num_set ( sdb , \"offset\" , shdr -> sh_offset , 0 ) ; sdb_num_set ( sdb , \"link\" , shdr -> sh_link , 0 ) ; sdb_set ( sdb , \"link_section_name\" , link_section_name , 0 ) ; for ( cnt = 0 , i = 0 ; i >= 0 && cnt < shdr -> sh_info && ( ( char * ) defs + i < end ) ; ++ cnt ) { Sdb * sdb_verdef = sdb_new0 ( ) ; char * vstart = ( ( char * ) defs ) + i ; <S2SV_StartBug> char key [ 32 ] = { 0 } ; <S2SV_EndBug> Elf_ ( Verdef ) * verdef = ( Elf_ ( Verdef ) * ) vstart ; Elf_ ( Verdaux ) aux = { 0 } ; int j = 0 ; int isum = 0 ; r_buf_read_at ( bin -> b , shdr -> sh_offset + i , dfs , sizeof ( Elf_ ( Verdef ) ) ) ; verdef -> vd_version = READ16 ( dfs , j ) verdef -> vd_flags = READ16 ( dfs , j ) verdef -> vd_ndx = READ16 ( dfs , j ) verdef -> vd_cnt = READ16 ( dfs , j ) verdef -> vd_hash = READ32 ( dfs , j ) verdef -> vd_aux = READ32 ( dfs , j ) verdef -> vd_next = READ32 ( dfs , j ) int vdaux = verdef -> vd_aux ; <S2SV_StartBug> if ( vdaux < 1 || vstart + vdaux < vstart ) { <S2SV_EndBug> sdb_free ( sdb_verdef ) ; goto out_error ; } <S2SV_StartBug> vstart += vdaux ; <S2SV_EndBug> if ( vstart > end || vstart + sizeof ( Elf_ ( Verdaux ) ) > end ) { sdb_free ( sdb_verdef ) ; goto out_error ; } j = 0 ; aux . vda_name = READ32 ( vstart , j ) aux . vda_next = READ32 ( vstart , j ) isum = i + verdef -> vd_aux ; if ( aux . vda_name > bin -> dynstr_size ) { sdb_free ( sdb_verdef ) ; goto out_error ; } sdb_num_set ( sdb_verdef , \"idx\" , i , 0 ) ; sdb_num_set ( sdb_verdef , \"vd_version\" , verdef -> vd_version , 0 ) ; sdb_num_set ( sdb_verdef , \"vd_ndx\" , verdef -> vd_ndx , 0 ) ; sdb_num_set ( sdb_verdef , \"vd_cnt\" , verdef -> vd_cnt , 0 ) ; sdb_set ( sdb_verdef , \"vda_name\" , & bin -> dynstr [ aux . vda_name ] , 0 ) ; sdb_set ( sdb_verdef , \"flags\" , get_ver_flags ( verdef -> vd_flags ) , 0 ) ; for ( j = 1 ; j < verdef -> vd_cnt ; ++ j ) { int k ; Sdb * sdb_parent = sdb_new0 ( ) ; isum += aux . vda_next ; vstart += aux . vda_next ; <S2SV_StartBug> if ( vstart > end || vstart + sizeof ( Elf_ ( Verdaux ) ) > end ) { <S2SV_EndBug> sdb_free ( sdb_verdef ) ; sdb_free ( sdb_parent ) ; goto out_error ; } k = 0 ; aux . vda_name = READ32 ( vstart , k ) aux . vda_next = READ32 ( vstart , k ) if ( aux . vda_name > bin -> dynstr_size ) { sdb_free ( sdb_verdef ) ; sdb_free ( sdb_parent ) ; goto out_error ; } sdb_num_set ( sdb_parent , \"idx\" , isum , 0 ) ; sdb_num_set ( sdb_parent , \"parent\" , j , 0 ) ; sdb_set ( sdb_parent , \"vda_name\" , & bin -> dynstr [ aux . vda_name ] , 0 ) ; snprintf ( key , sizeof ( key ) , \"parent%d\" , j - 1 ) ; sdb_ns_set ( sdb_verdef , key , sdb_parent ) ; } snprintf ( key , sizeof ( key ) , \"verdef%d\" , cnt ) ; sdb_ns_set ( sdb , key , sdb_verdef ) ; if ( ! verdef -> vd_next ) { sdb_free ( sdb_verdef ) ; goto out_error ; } if ( ( st32 ) verdef -> vd_next < 1 ) { eprintf ( \"Warning:<S2SV_blank>Invalid<S2SV_blank>vd_next<S2SV_blank>in<S2SV_blank>the<S2SV_blank>ELF<S2SV_blank>version\\\\n\" ) ; break ; } i += verdef -> vd_next ; } free ( defs ) ; return sdb ; out_error : free ( defs ) ; sdb_free ( sdb ) ; return NULL ; }\n",
      "fixed_code": "<S2SV_ModStart> + i ; size_t vstart_off = i ; <S2SV_ModStart> < 1 || shdr -> sh_size - vstart_off < vdaux <S2SV_ModEnd> ) { sdb_free <S2SV_ModStart> ; } vstart += vdaux ; vstart_off <S2SV_ModStart> . vda_next ; vstart_off += aux . vda_next ;\n",
      "source_code_length": 4299,
      "target_code_length": 242,
      "vulnerability_patterns": {
        "use_after_free": 3,
        "integer_overflow": 6,
        "format_string": 2,
        "null_pointer": 49,
        "memory_leak": 1,
        "total": 61
      },
      "total_patterns": 61,
      "original_address": "https://github.com/radare/radare2/commit/fbaf24bce7ea4211e4608b3ab6c1b45702cb243d",
      "discovery_time": "2017-11-01T17:29Z",
      "project_commit_id": "radare@radare2/fbaf24bce7ea4211e4608b3ab6c1b45702cb243d",
      "extraction_time": "2025-08-31T15:41:49.179723",
      "label": 1,
      "vulnerability_type": "null_pointer_dereference",
      "difficulty_level": "expert",
      "risk_factors": [
        "denial_of_service",
        "memory_corruption",
        "critical_infrastructure",
        "system_crash",
        "use_after_free"
      ],
      "attack_vectors": [
        "memory_manipulation",
        "null_pointer",
        "code_analysis",
        "reverse_engineering",
        "use_after_free",
        "fuzzing"
      ],
      "mitigation_strategies": [
        "null_pointer_checks",
        "fuzzing",
        "dynamic_analysis",
        "memory_management",
        "static_analysis",
        "use_after_free_prevention",
        "code_review",
        "secure_coding_practices"
      ],
      "code_differences": {
        "has_differences": true,
        "source_lines": 2,
        "target_lines": 2,
        "character_differences": 4057,
        "similarity_percentage": 15.909090909090908
      },
      "vulnerability_location": {
        "vulnerability_present": true,
        "fix_applied": true,
        "code_changed": true,
        "estimated_lines_changed": 0
      }
    },
    {
      "cve_id": "CVE-2016-4300",
      "cwe_id": "CWE-190",
      "cwe_name": "Integer Overflow",
      "project": "libarchive",
      "severity": "critical",
      "weaponization_score": 9.5,
      "is_critical": true,
      "is_weaponizable": true,
      "is_high_priority_project": false,
      "vulnerable_code": "CWE-190 static int read_SubStreamsInfo ( struct archive_read * a , struct _7z_substream_info * ss , struct _7z_folder * f , size_t numFolders ) { const unsigned char * p ; uint64_t * usizes ; size_t unpack_streams ; int type ; unsigned i ; uint32_t numDigests ; memset ( ss , 0 , sizeof ( * ss ) ) ; for ( i = 0 ; i < numFolders ; i ++ ) f [ i ] . numUnpackStreams = 1 ; if ( ( p = header_bytes ( a , 1 ) ) == NULL ) return ( - 1 ) ; type = * p ; if ( type == kNumUnPackStream ) { unpack_streams = 0 ; for ( i = 0 ; i < numFolders ; i ++ ) { if ( parse_7zip_uint64 ( a , & ( f [ i ] . numUnpackStreams ) ) < 0 ) return ( - 1 ) ; if ( UMAX_ENTRY < f [ i ] . numUnpackStreams ) return ( - 1 ) ; <S2SV_StartBug> unpack_streams += ( size_t ) f [ i ] . numUnpackStreams ; <S2SV_EndBug> } if ( ( p = header_bytes ( a , 1 ) ) == NULL ) return ( - 1 ) ; type = * p ; } else unpack_streams = numFolders ; ss -> unpack_streams = unpack_streams ; if ( unpack_streams ) { ss -> unpackSizes = calloc ( unpack_streams , sizeof ( * ss -> unpackSizes ) ) ; ss -> digestsDefined = calloc ( unpack_streams , sizeof ( * ss -> digestsDefined ) ) ; ss -> digests = calloc ( unpack_streams , sizeof ( * ss -> digests ) ) ; if ( ss -> unpackSizes == NULL || ss -> digestsDefined == NULL || ss -> digests == NULL ) return ( - 1 ) ; } usizes = ss -> unpackSizes ; for ( i = 0 ; i < numFolders ; i ++ ) { unsigned pack ; uint64_t sum ; if ( f [ i ] . numUnpackStreams == 0 ) continue ; sum = 0 ; if ( type == kSize ) { for ( pack = 1 ; pack < f [ i ] . numUnpackStreams ; pack ++ ) { if ( parse_7zip_uint64 ( a , usizes ) < 0 ) return ( - 1 ) ; sum += * usizes ++ ; } } * usizes ++ = folder_uncompressed_size ( & f [ i ] ) - sum ; } if ( type == kSize ) { if ( ( p = header_bytes ( a , 1 ) ) == NULL ) return ( - 1 ) ; type = * p ; } for ( i = 0 ; i < unpack_streams ; i ++ ) { ss -> digestsDefined [ i ] = 0 ; ss -> digests [ i ] = 0 ; } numDigests = 0 ; for ( i = 0 ; i < numFolders ; i ++ ) { if ( f [ i ] . numUnpackStreams != 1 || ! f [ i ] . digest_defined ) numDigests += ( uint32_t ) f [ i ] . numUnpackStreams ; } if ( type == kCRC ) { struct _7z_digests tmpDigests ; unsigned char * digestsDefined = ss -> digestsDefined ; uint32_t * digests = ss -> digests ; int di = 0 ; memset ( & tmpDigests , 0 , sizeof ( tmpDigests ) ) ; if ( read_Digests ( a , & ( tmpDigests ) , numDigests ) < 0 ) { free_Digest ( & tmpDigests ) ; return ( - 1 ) ; } for ( i = 0 ; i < numFolders ; i ++ ) { if ( f [ i ] . numUnpackStreams == 1 && f [ i ] . digest_defined ) { * digestsDefined ++ = 1 ; * digests ++ = f [ i ] . digest ; } else { unsigned j ; for ( j = 0 ; j < f [ i ] . numUnpackStreams ; j ++ , di ++ ) { * digestsDefined ++ = tmpDigests . defineds [ di ] ; * digests ++ = tmpDigests . digests [ di ] ; } } } free_Digest ( & tmpDigests ) ; if ( ( p = header_bytes ( a , 1 ) ) == NULL ) return ( - 1 ) ; type = * p ; } if ( type != kEnd ) return ( - 1 ) ; return ( 0 ) ; }\n",
      "fixed_code": "<S2SV_ModStart> 1 ) ; if ( unpack_streams > SIZE_MAX - UMAX_ENTRY ) { return ( - 1 ) ; }\n",
      "source_code_length": 2947,
      "target_code_length": 89,
      "vulnerability_patterns": {
        "buffer_overflow": 2,
        "use_after_free": 3,
        "integer_overflow": 18,
        "null_pointer": 15,
        "memory_leak": 3,
        "total": 41
      },
      "total_patterns": 41,
      "original_address": "https://github.com/libarchive/libarchive/commit/e79ef306afe332faf22e9b442a2c6b59cb175573",
      "discovery_time": "2016-09-21T14:25Z",
      "project_commit_id": "libarchive@libarchive/e79ef306afe332faf22e9b442a2c6b59cb175573",
      "extraction_time": "2025-08-31T15:41:49.179778",
      "label": 1,
      "vulnerability_type": "integer_overflow",
      "difficulty_level": "expert",
      "risk_factors": [
        "memory_corruption",
        "buffer_overflow",
        "information_disclosure",
        "use_after_free",
        "integer_overflow"
      ],
      "attack_vectors": [
        "fuzzing",
        "code_analysis",
        "reverse_engineering"
      ],
      "mitigation_strategies": [
        "dynamic_analysis",
        "static_analysis",
        "fuzzing",
        "code_review",
        "secure_coding_practices"
      ],
      "code_differences": {
        "has_differences": true,
        "source_lines": 2,
        "target_lines": 2,
        "character_differences": 2858,
        "similarity_percentage": 12.941176470588237
      },
      "vulnerability_location": {
        "vulnerability_present": true,
        "fix_applied": true,
        "code_changed": true,
        "estimated_lines_changed": 0
      }
    },
    {
      "cve_id": "CVE-2016-3134",
      "cwe_id": "CWE-119",
      "cwe_name": "Buffer Overflow",
      "project": "torvalds",
      "severity": "critical",
      "weaponization_score": 9.5,
      "is_critical": true,
      "is_weaponizable": true,
      "is_high_priority_project": false,
      "vulnerable_code": "CWE-119 static bool check_underflow ( const struct ip6t_entry * e ) { const struct xt_entry_target * t ; unsigned int verdict ; <S2SV_StartBug> if ( ! unconditional ( & e -> ipv6 ) ) <S2SV_EndBug> return false ; t = ip6t_get_target_c ( e ) ; if ( strcmp ( t -> u . user . name , XT_STANDARD_TARGET ) != 0 ) return false ; verdict = ( ( struct xt_standard_target * ) t ) -> verdict ; verdict = - verdict - 1 ; return verdict == NF_DROP || verdict == NF_ACCEPT ; }\n",
      "fixed_code": "<S2SV_ModStart> ! unconditional ( e <S2SV_ModEnd> ) ) return\n",
      "source_code_length": 463,
      "target_code_length": 61,
      "vulnerability_patterns": {
        "use_after_free": 3,
        "integer_overflow": 1,
        "null_pointer": 7,
        "sql_injection": 1,
        "total": 12
      },
      "total_patterns": 12,
      "original_address": "https://github.com/torvalds/linux/commit/54d83fc74aa9ec72794373cb47432c5f7fb1a309",
      "discovery_time": "2016-04-27T17:59Z",
      "project_commit_id": "torvalds@linux/54d83fc74aa9ec72794373cb47432c5f7fb1a309",
      "extraction_time": "2025-08-31T15:41:49.179815",
      "label": 1,
      "vulnerability_type": "buffer_overflow",
      "difficulty_level": "expert",
      "risk_factors": [
        "memory_corruption",
        "sql_injection",
        "arbitrary_code_execution",
        "system_crash",
        "use_after_free"
      ],
      "attack_vectors": [
        "memory_manipulation",
        "malicious_input",
        "code_analysis",
        "buffer_overflow",
        "reverse_engineering",
        "fuzzing"
      ],
      "mitigation_strategies": [
        "safe_string_functions",
        "dynamic_analysis",
        "code_review",
        "static_analysis",
        "memory_safety_checks",
        "input_validation",
        "fuzzing",
        "bounds_checking",
        "secure_coding_practices"
      ],
      "code_differences": {
        "has_differences": true,
        "source_lines": 2,
        "target_lines": 2,
        "character_differences": 402,
        "similarity_percentage": 12.244897959183673
      },
      "vulnerability_location": {
        "vulnerability_present": true,
        "fix_applied": true,
        "code_changed": true,
        "estimated_lines_changed": 0
      }
    },
    {
      "cve_id": "CVE-2019-13300",
      "cwe_id": "CWE-787",
      "cwe_name": "Out-of-bounds Write",
      "project": "ImageMagick",
      "severity": "critical",
      "weaponization_score": 9.3,
      "is_critical": true,
      "is_weaponizable": true,
      "is_high_priority_project": true,
      "vulnerable_code": "CWE-787 <S2SV_StartBug> static PixelChannels * * AcquirePixelThreadSet ( const Image * image ) <S2SV_EndBug> { PixelChannels * * pixels ; register ssize_t i ; size_t <S2SV_StartBug> number_threads ; <S2SV_EndBug> number_threads = ( size_t ) GetMagickResourceLimit ( ThreadResource ) ; pixels = ( PixelChannels * * ) AcquireQuantumMemory ( number_threads , sizeof ( * pixels ) ) ; if ( pixels == ( PixelChannels * * ) NULL ) return ( ( PixelChannels * * ) NULL ) ; ( void ) memset ( pixels , 0 , number_threads * sizeof ( * pixels ) ) ; <S2SV_StartBug> for ( i = 0 ; i < ( ssize_t ) number_threads ; i ++ ) <S2SV_EndBug> { register ssize_t j ; <S2SV_StartBug> pixels [ i ] = ( PixelChannels * ) AcquireQuantumMemory ( image -> columns , <S2SV_EndBug> sizeof ( * * pixels ) ) ; if ( pixels [ i ] == ( PixelChannels * ) NULL ) return ( DestroyPixelThreadSet ( pixels ) ) ; <S2SV_StartBug> for ( j = 0 ; j < ( ssize_t ) image -> columns ; j ++ ) <S2SV_EndBug> { register ssize_t k ; for ( k = 0 ; k < MaxPixelChannels ; k ++ ) pixels [ i ] [ j ] . channel [ k ] = 0.0 ; } } return ( pixels ) ; }\n",
      "fixed_code": "<S2SV_ModStart> const Image * images ) { const Image * next ; <S2SV_ModEnd> PixelChannels * * <S2SV_ModStart> i ; size_t columns , <S2SV_ModStart> ) ) ; columns = images -> columns ; for ( next = images ; next != ( Image * ) NULL ; next = next -> next ) columns = MagickMax ( next -> columns , columns ) ; <S2SV_ModStart> ) AcquireQuantumMemory ( columns , <S2SV_ModEnd> sizeof ( * <S2SV_ModStart> ( ssize_t ) <S2SV_ModEnd> columns ; j\n",
      "source_code_length": 1092,
      "target_code_length": 436,
      "vulnerability_patterns": {
        "buffer_overflow": 1,
        "integer_overflow": 3,
        "null_pointer": 2,
        "total": 6
      },
      "total_patterns": 6,
      "original_address": "https://github.com/ImageMagick/ImageMagick/commit/a906fe9298bf89e01d5272023db687935068849a",
      "discovery_time": "2019-07-05T01:15Z",
      "project_commit_id": "ImageMagick@ImageMagick/a906fe9298bf89e01d5272023db687935068849a",
      "extraction_time": "2025-08-31T15:41:49.179831",
      "label": 1,
      "vulnerability_type": "out-of-bounds_write",
      "difficulty_level": "expert",
      "risk_factors": [
        "memory_corruption",
        "critical_infrastructure",
        "arbitrary_code_execution",
        "buffer_overflow",
        "system_crash"
      ],
      "attack_vectors": [
        "memory_manipulation",
        "malicious_input",
        "code_analysis",
        "buffer_overflow",
        "reverse_engineering",
        "fuzzing"
      ],
      "mitigation_strategies": [
        "safe_string_functions",
        "dynamic_analysis",
        "code_review",
        "static_analysis",
        "memory_safety_checks",
        "input_validation",
        "fuzzing",
        "bounds_checking",
        "secure_coding_practices"
      ],
      "code_differences": {
        "has_differences": true,
        "source_lines": 2,
        "target_lines": 2,
        "character_differences": 656,
        "similarity_percentage": 37.03703703703704
      },
      "vulnerability_location": {
        "vulnerability_present": true,
        "fix_applied": true,
        "code_changed": true,
        "estimated_lines_changed": 0
      }
    },
    {
      "cve_id": "CVE-2016-10066",
      "cwe_id": "CWE-119",
      "cwe_name": "Buffer Overflow",
      "project": "ImageMagick",
      "severity": "critical",
      "weaponization_score": 9.0,
      "is_critical": true,
      "is_weaponizable": true,
      "is_high_priority_project": true,
      "vulnerable_code": "CWE-119 static Image * ReadAAIImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { Image * image ; MagickBooleanType status ; register ssize_t x ; register PixelPacket * q ; register unsigned char * p ; size_t height , length , width ; ssize_t count , y ; unsigned char * pixels ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickSignature ) ; if ( image_info -> debug != MagickFalse ) ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , \"%s\" , image_info -> filename ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickSignature ) ; image = AcquireImage ( image_info ) ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } width = ReadBlobLSBLong ( image ) ; height = ReadBlobLSBLong ( image ) ; if ( EOFBlob ( image ) != MagickFalse ) ThrowReaderException ( CorruptImageError , \"ImproperImageHeader\" ) ; if ( ( width == 0UL ) || ( height == 0UL ) ) ThrowReaderException ( CorruptImageError , \"ImproperImageHeader\" ) ; do { image -> columns = width ; image -> rows = height ; image -> depth = 8 ; if ( ( image_info -> ping != MagickFalse ) && ( image_info -> number_scenes != 0 ) ) if ( image -> scene >= ( image_info -> scene + image_info -> number_scenes - 1 ) ) break ; <S2SV_StartBug> pixels = ( unsigned char * ) AcquireQuantumMemory ( image -> columns , <S2SV_EndBug> 4 * sizeof ( * pixels ) ) ; if ( pixels == ( unsigned char * ) NULL ) ThrowReaderException ( ResourceLimitError , \"MemoryAllocationFailed\" ) ; length = ( size_t ) 4 * image -> columns ; for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { count = ReadBlob ( image , length , pixels ) ; if ( ( size_t ) count != length ) ThrowReaderException ( CorruptImageError , \"UnableToReadImageData\" ) ; p = pixels ; q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( PixelPacket * ) NULL ) break ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { SetPixelBlue ( q , ScaleCharToQuantum ( * p ++ ) ) ; SetPixelGreen ( q , ScaleCharToQuantum ( * p ++ ) ) ; SetPixelRed ( q , ScaleCharToQuantum ( * p ++ ) ) ; if ( * p == 254 ) * p = 255 ; SetPixelAlpha ( q , ScaleCharToQuantum ( * p ++ ) ) ; if ( q -> opacity != OpaqueOpacity ) image -> matte = MagickTrue ; q ++ ; } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ; if ( status == MagickFalse ) break ; } } pixels = ( unsigned char * ) RelinquishMagickMemory ( pixels ) ; if ( EOFBlob ( image ) != MagickFalse ) { ThrowFileException ( exception , CorruptImageError , \"UnexpectedEndOfFile\" , image -> filename ) ; break ; } if ( image_info -> number_scenes != 0 ) if ( image -> scene >= ( image_info -> scene + image_info -> number_scenes - 1 ) ) break ; width = ReadBlobLSBLong ( image ) ; height = ReadBlobLSBLong ( image ) ; if ( ( width != 0UL ) && ( height != 0UL ) ) { AcquireNextImage ( image_info , image ) ; if ( GetNextImageInList ( image ) == ( Image * ) NULL ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } image = SyncNextImageInList ( image ) ; status = SetImageProgress ( image , LoadImagesTag , TellBlob ( image ) , GetBlobSize ( image ) ) ; if ( status == MagickFalse ) break ; } } while ( ( width != 0UL ) && ( height != 0UL ) ) ; ( void ) CloseBlob ( image ) ; return ( GetFirstImageInList ( image ) ) ; }\n",
      "fixed_code": "<S2SV_ModStart> ) break ; status = SetImageExtent ( image , image -> columns , image -> rows ) ; if ( status == MagickFalse ) { InheritException ( exception , & image -> exception ) ; return ( DestroyImageList ( image ) ) ; }\n",
      "source_code_length": 3617,
      "target_code_length": 226,
      "vulnerability_patterns": {
        "integer_overflow": 7,
        "null_pointer": 26,
        "total": 33
      },
      "total_patterns": 33,
      "original_address": "https://github.com/ImageMagick/ImageMagick/commit/f6e9d0d9955e85bdd7540b251cd50d598dacc5e6",
      "discovery_time": "2017-03-03T17:59Z",
      "project_commit_id": "ImageMagick@ImageMagick/f6e9d0d9955e85bdd7540b251cd50d598dacc5e6",
      "extraction_time": "2025-08-31T15:41:49.179852",
      "label": 1,
      "vulnerability_type": "buffer_overflow",
      "difficulty_level": "expert",
      "risk_factors": [
        "system_crash",
        "memory_corruption",
        "critical_infrastructure",
        "arbitrary_code_execution"
      ],
      "attack_vectors": [
        "memory_manipulation",
        "malicious_input",
        "code_analysis",
        "buffer_overflow",
        "reverse_engineering",
        "fuzzing"
      ],
      "mitigation_strategies": [
        "safe_string_functions",
        "dynamic_analysis",
        "code_review",
        "static_analysis",
        "memory_safety_checks",
        "input_validation",
        "fuzzing",
        "bounds_checking",
        "secure_coding_practices"
      ],
      "code_differences": {
        "has_differences": true,
        "source_lines": 2,
        "target_lines": 2,
        "character_differences": 3391,
        "similarity_percentage": 15.447154471544716
      },
      "vulnerability_location": {
        "vulnerability_present": true,
        "fix_applied": true,
        "code_changed": true,
        "estimated_lines_changed": 0
      }
    },
    {
      "cve_id": "CVE-2016-10066",
      "cwe_id": "CWE-119",
      "cwe_name": "Buffer Overflow",
      "project": "ImageMagick",
      "severity": "critical",
      "weaponization_score": 9.0,
      "is_critical": true,
      "is_weaponizable": true,
      "is_high_priority_project": true,
      "vulnerable_code": "CWE-119 static Image * ReadAAIImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { Image * image ; MagickBooleanType status ; register ssize_t x ; register PixelPacket * q ; register unsigned char * p ; size_t height , length , width ; ssize_t count , y ; unsigned char * pixels ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickSignature ) ; if ( image_info -> debug != MagickFalse ) ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , \"%s\" , image_info -> filename ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickSignature ) ; image = AcquireImage ( image_info ) ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } width = ReadBlobLSBLong ( image ) ; height = ReadBlobLSBLong ( image ) ; if ( EOFBlob ( image ) != MagickFalse ) ThrowReaderException ( CorruptImageError , \"ImproperImageHeader\" ) ; if ( ( width == 0UL ) || ( height == 0UL ) ) ThrowReaderException ( CorruptImageError , \"ImproperImageHeader\" ) ; do { image -> columns = width ; image -> rows = height ; image -> depth = 8 ; if ( ( image_info -> ping != MagickFalse ) && ( image_info -> number_scenes != 0 ) ) if ( image -> scene >= ( image_info -> scene + image_info -> number_scenes - 1 ) ) break ; <S2SV_StartBug> pixels = ( unsigned char * ) AcquireQuantumMemory ( image -> columns , <S2SV_EndBug> 4 * sizeof ( * pixels ) ) ; if ( pixels == ( unsigned char * ) NULL ) ThrowReaderException ( ResourceLimitError , \"MemoryAllocationFailed\" ) ; length = ( size_t ) 4 * image -> columns ; for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { count = ReadBlob ( image , length , pixels ) ; if ( ( size_t ) count != length ) ThrowReaderException ( CorruptImageError , \"UnableToReadImageData\" ) ; p = pixels ; q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( PixelPacket * ) NULL ) break ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { SetPixelBlue ( q , ScaleCharToQuantum ( * p ++ ) ) ; SetPixelGreen ( q , ScaleCharToQuantum ( * p ++ ) ) ; SetPixelRed ( q , ScaleCharToQuantum ( * p ++ ) ) ; if ( * p == 254 ) * p = 255 ; SetPixelAlpha ( q , ScaleCharToQuantum ( * p ++ ) ) ; if ( q -> opacity != OpaqueOpacity ) image -> matte = MagickTrue ; q ++ ; } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ; if ( status == MagickFalse ) break ; } } pixels = ( unsigned char * ) RelinquishMagickMemory ( pixels ) ; if ( EOFBlob ( image ) != MagickFalse ) { ThrowFileException ( exception , CorruptImageError , \"UnexpectedEndOfFile\" , image -> filename ) ; break ; } if ( image_info -> number_scenes != 0 ) if ( image -> scene >= ( image_info -> scene + image_info -> number_scenes - 1 ) ) break ; width = ReadBlobLSBLong ( image ) ; height = ReadBlobLSBLong ( image ) ; if ( ( width != 0UL ) && ( height != 0UL ) ) { AcquireNextImage ( image_info , image ) ; if ( GetNextImageInList ( image ) == ( Image * ) NULL ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } image = SyncNextImageInList ( image ) ; status = SetImageProgress ( image , LoadImagesTag , TellBlob ( image ) , GetBlobSize ( image ) ) ; if ( status == MagickFalse ) break ; } } while ( ( width != 0UL ) && ( height != 0UL ) ) ; ( void ) CloseBlob ( image ) ; return ( GetFirstImageInList ( image ) ) ; }\n",
      "fixed_code": "<S2SV_ModStart> ) break ; status = SetImageExtent ( image , image -> columns , image -> rows ) ; if ( status == MagickFalse ) { InheritException ( exception , & image -> exception ) ; return ( DestroyImageList ( image ) ) ; }\n",
      "source_code_length": 3617,
      "target_code_length": 226,
      "vulnerability_patterns": {
        "integer_overflow": 12,
        "null_pointer": 56,
        "total": 68
      },
      "total_patterns": 68,
      "original_address": "https://github.com/ImageMagick/ImageMagick/commit/f6e9d0d9955e85bdd7540b251cd50d598dacc5e6",
      "discovery_time": "2017-03-03T17:59Z",
      "project_commit_id": "ImageMagick@ImageMagick/f6e9d0d9955e85bdd7540b251cd50d598dacc5e6",
      "extraction_time": "2025-08-31T15:41:49.179889",
      "label": 1,
      "vulnerability_type": "buffer_overflow",
      "difficulty_level": "expert",
      "risk_factors": [
        "system_crash",
        "memory_corruption",
        "critical_infrastructure",
        "arbitrary_code_execution"
      ],
      "attack_vectors": [
        "memory_manipulation",
        "malicious_input",
        "code_analysis",
        "buffer_overflow",
        "reverse_engineering",
        "fuzzing"
      ],
      "mitigation_strategies": [
        "safe_string_functions",
        "dynamic_analysis",
        "code_review",
        "static_analysis",
        "memory_safety_checks",
        "input_validation",
        "fuzzing",
        "bounds_checking",
        "secure_coding_practices"
      ],
      "code_differences": {
        "has_differences": true,
        "source_lines": 2,
        "target_lines": 2,
        "character_differences": 3391,
        "similarity_percentage": 15.447154471544716
      },
      "vulnerability_location": {
        "vulnerability_present": true,
        "fix_applied": true,
        "code_changed": true,
        "estimated_lines_changed": 0
      }
    },
    {
      "cve_id": "CVE-2016-5356",
      "cwe_id": "CWE-119",
      "cwe_name": "Buffer Overflow",
      "project": "wireshark",
      "severity": "critical",
      "weaponization_score": 9.0,
      "is_critical": true,
      "is_weaponizable": true,
      "is_high_priority_project": true,
      "vulnerable_code": "CWE-119 static gboolean parse_cosine_packet ( FILE_T fh , struct wtap_pkthdr * phdr , Buffer * buf , char * line , int * err , gchar * * err_info ) { union wtap_pseudo_header * pseudo_header = & phdr -> pseudo_header ; int num_items_scanned ; <S2SV_StartBug> int yy , mm , dd , hr , min , sec , csec ; <S2SV_EndBug> guint pkt_len ; int pro , off , pri , rm , error ; guint code1 , code2 ; char if_name [ COSINE_MAX_IF_NAME_LEN ] = \"\" , direction [ 6 ] = \"\" ; struct tm tm ; guint8 * pd ; int i , hex_lines , n , caplen = 0 ; if ( sscanf ( line , \"%4d-%2d-%2d,%2d:%2d:%2d.%9d:\" , & yy , & mm , & dd , & hr , & min , & sec , & csec ) == 7 ) { num_items_scanned = sscanf ( line , <S2SV_StartBug> \"%4d-%2d-%2d,%2d:%2d:%2d.%9d:<S2SV_blank>%5s<S2SV_blank>(%127[A-Za-z0-9/:]),<S2SV_blank>Length:%9u,<S2SV_blank>Pro:%9d,<S2SV_blank>Off:%9d,<S2SV_blank>Pri:%9d,<S2SV_blank>RM:%9d,<S2SV_blank>Err:%9d<S2SV_blank>[%8x,<S2SV_blank>%8x]\" , <S2SV_EndBug> & yy , & mm , & dd , & hr , & min , & sec , & csec , direction , if_name , & pkt_len , & pro , & off , & pri , & rm , & error , & code1 , & code2 ) ; if ( num_items_scanned != 17 ) { * err = WTAP_ERR_BAD_FILE ; * err_info = g_strdup ( \"cosine:<S2SV_blank>purported<S2SV_blank>control<S2SV_blank>blade<S2SV_blank>line<S2SV_blank>doesn\\'t<S2SV_blank>have<S2SV_blank>code<S2SV_blank>values\" ) ; return FALSE ; } } else { num_items_scanned = sscanf ( line , <S2SV_StartBug> \"%5s<S2SV_blank>(%127[A-Za-z0-9/:]),<S2SV_blank>Length:%9u,<S2SV_blank>Pro:%9d,<S2SV_blank>Off:%9d,<S2SV_blank>Pri:%9d,<S2SV_blank>RM:%9d,<S2SV_blank>Err:%9d<S2SV_blank>[%8x,<S2SV_blank>%8x]\" , <S2SV_EndBug> direction , if_name , & pkt_len , & pro , & off , & pri , & rm , & error , & code1 , & code2 ) ; if ( num_items_scanned != 10 ) { * err = WTAP_ERR_BAD_FILE ; * err_info = g_strdup ( \"cosine:<S2SV_blank>header<S2SV_blank>line<S2SV_blank>is<S2SV_blank>neither<S2SV_blank>control<S2SV_blank>blade<S2SV_blank>nor<S2SV_blank>PE<S2SV_blank>output\" ) ; return FALSE ; } <S2SV_StartBug> yy = mm = dd = hr = min = sec = csec = 0 ; <S2SV_EndBug> } if ( pkt_len > WTAP_MAX_PACKET_SIZE ) { * err = WTAP_ERR_BAD_FILE ; * err_info = g_strdup_printf ( \"cosine:<S2SV_blank>File<S2SV_blank>has<S2SV_blank>%u-byte<S2SV_blank>packet,<S2SV_blank>bigger<S2SV_blank>than<S2SV_blank>maximum<S2SV_blank>of<S2SV_blank>%u\" , pkt_len , WTAP_MAX_PACKET_SIZE ) ; return FALSE ; } phdr -> rec_type = REC_TYPE_PACKET ; phdr -> presence_flags = WTAP_HAS_TS | WTAP_HAS_CAP_LEN ; tm . tm_year = yy - 1900 ; tm . tm_mon = mm - 1 ; tm . tm_mday = dd ; tm . tm_hour = hr ; tm . tm_min = min ; tm . tm_sec = sec ; tm . tm_isdst = - 1 ; phdr -> ts . secs = mktime ( & tm ) ; phdr -> ts . nsecs = csec * 10000000 ; phdr -> len = pkt_len ; if ( strncmp ( if_name , \"TEST:\" , 5 ) == 0 ) { pseudo_header -> cosine . encap = COSINE_ENCAP_TEST ; } else if ( strncmp ( if_name , \"PPoATM:\" , 7 ) == 0 ) { pseudo_header -> cosine . encap = COSINE_ENCAP_PPoATM ; } else if ( strncmp ( if_name , \"PPoFR:\" , 6 ) == 0 ) { pseudo_header -> cosine . encap = COSINE_ENCAP_PPoFR ; } else if ( strncmp ( if_name , \"ATM:\" , 4 ) == 0 ) { pseudo_header -> cosine . encap = COSINE_ENCAP_ATM ; } else if ( strncmp ( if_name , \"FR:\" , 3 ) == 0 ) { pseudo_header -> cosine . encap = COSINE_ENCAP_FR ; } else if ( strncmp ( if_name , \"HDLC:\" , 5 ) == 0 ) { pseudo_header -> cosine . encap = COSINE_ENCAP_HDLC ; } else if ( strncmp ( if_name , \"PPP:\" , 4 ) == 0 ) { pseudo_header -> cosine . encap = COSINE_ENCAP_PPP ; } else if ( strncmp ( if_name , \"ETH:\" , 4 ) == 0 ) { pseudo_header -> cosine . encap = COSINE_ENCAP_ETH ; } else { pseudo_header -> cosine . encap = COSINE_ENCAP_UNKNOWN ; } if ( strncmp ( direction , \"l2-tx\" , 5 ) == 0 ) { pseudo_header -> cosine . direction = COSINE_DIR_TX ; } else if ( strncmp ( direction , \"l2-rx\" , 5 ) == 0 ) { pseudo_header -> cosine . direction = COSINE_DIR_RX ; } g_strlcpy ( pseudo_header -> cosine . if_name , if_name , COSINE_MAX_IF_NAME_LEN ) ; pseudo_header -> cosine . pro = pro ; pseudo_header -> cosine . off = off ; pseudo_header -> cosine . pri = pri ; pseudo_header -> cosine . rm = rm ; pseudo_header -> cosine . err = error ; ws_buffer_assure_space ( buf , pkt_len ) ; pd = ws_buffer_start_ptr ( buf ) ; hex_lines = pkt_len / 16 + ( ( pkt_len % 16 ) ? 1 : 0 ) ; for ( i = 0 ; i < hex_lines ; i ++ ) { if ( file_gets ( line , COSINE_LINE_LENGTH , fh ) == NULL ) { * err = file_error ( fh , err_info ) ; if ( * err == 0 ) { * err = WTAP_ERR_SHORT_READ ; } return FALSE ; } if ( empty_line ( line ) ) { break ; } if ( ( n = parse_single_hex_dump_line ( line , pd , i * 16 ) ) == - 1 ) { * err = WTAP_ERR_BAD_FILE ; * err_info = g_strdup ( \"cosine:<S2SV_blank>hex<S2SV_blank>dump<S2SV_blank>line<S2SV_blank>doesn\\'t<S2SV_blank>have<S2SV_blank>16<S2SV_blank>numbers\" ) ; return FALSE ; } caplen += n ; } phdr -> caplen = caplen ; return TRUE ; }\n",
      "fixed_code": "<S2SV_ModStart> sec , csec , <S2SV_ModEnd> pkt_len ; int <S2SV_ModStart> ( line , \"%4d-%2d-%2d,%2d:%2d:%2d.%9d:<S2SV_blank>%5s<S2SV_blank>(%127[A-Za-z0-9/:]),<S2SV_blank>Length:%9d,<S2SV_blank>Pro:%9d,<S2SV_blank>Off:%9d,<S2SV_blank>Pri:%9d,<S2SV_blank>RM:%9d,<S2SV_blank>Err:%9d<S2SV_blank>[%8x,<S2SV_blank>%8x]\" <S2SV_ModEnd> , & yy <S2SV_ModStart> ( line , \"%5s<S2SV_blank>(%127[A-Za-z0-9/:]),<S2SV_blank>Length:%9d,<S2SV_blank>Pro:%9d,<S2SV_blank>Off:%9d,<S2SV_blank>Pri:%9d,<S2SV_blank>RM:%9d,<S2SV_blank>Err:%9d<S2SV_blank>[%8x,<S2SV_blank>%8x]\" <S2SV_ModEnd> , direction , <S2SV_ModStart> csec = 0 ; } if ( pkt_len < 0 ) { * err = WTAP_ERR_BAD_FILE ; * err_info = g_strdup ( \"cosine:<S2SV_blank>packet<S2SV_blank>header<S2SV_blank>has<S2SV_blank>a<S2SV_blank>negative<S2SV_blank>packet<S2SV_blank>length\" ) ; return FALSE\n",
      "source_code_length": 4854,
      "target_code_length": 829,
      "vulnerability_patterns": {
        "integer_overflow": 2,
        "null_pointer": 24,
        "total": 26
      },
      "total_patterns": 26,
      "original_address": "https://github.com/wireshark/wireshark/commit/a66628e425db725df1ac52a3c573a03357060ddd",
      "discovery_time": "2016-08-07T16:59Z",
      "project_commit_id": "wireshark@wireshark/a66628e425db725df1ac52a3c573a03357060ddd",
      "extraction_time": "2025-08-31T15:41:49.179916",
      "label": 1,
      "vulnerability_type": "buffer_overflow",
      "difficulty_level": "expert",
      "risk_factors": [
        "system_crash",
        "memory_corruption",
        "critical_infrastructure",
        "arbitrary_code_execution"
      ],
      "attack_vectors": [
        "memory_manipulation",
        "malicious_input",
        "code_analysis",
        "buffer_overflow",
        "reverse_engineering",
        "fuzzing"
      ],
      "mitigation_strategies": [
        "safe_string_functions",
        "dynamic_analysis",
        "code_review",
        "static_analysis",
        "memory_safety_checks",
        "input_validation",
        "fuzzing",
        "bounds_checking",
        "secure_coding_practices"
      ],
      "code_differences": {
        "has_differences": true,
        "source_lines": 2,
        "target_lines": 2,
        "character_differences": 4025,
        "similarity_percentage": 15.337423312883436
      },
      "vulnerability_location": {
        "vulnerability_present": true,
        "fix_applied": true,
        "code_changed": true,
        "estimated_lines_changed": 0
      }
    },
    {
      "cve_id": "CVE-2017-7865",
      "cwe_id": "CWE-787",
      "cwe_name": "Out-of-bounds Write",
      "project": "FFmpeg",
      "severity": "critical",
      "weaponization_score": 9.0,
      "is_critical": true,
      "is_weaponizable": true,
      "is_high_priority_project": true,
      "vulnerable_code": "CWE-787 void avcodec_align_dimensions2 ( AVCodecContext * s , int * width , int * height , int linesize_align [ AV_NUM_DATA_POINTERS ] ) { int i ; int w_align = 1 ; int h_align = 1 ; AVPixFmtDescriptor const * desc = av_pix_fmt_desc_get ( s -> pix_fmt ) ; if ( desc ) { w_align = 1 << desc -> log2_chroma_w ; h_align = 1 << desc -> log2_chroma_h ; } switch ( s -> pix_fmt ) { case AV_PIX_FMT_YUV420P : case AV_PIX_FMT_YUYV422 : case AV_PIX_FMT_YVYU422 : case AV_PIX_FMT_UYVY422 : case AV_PIX_FMT_YUV422P : case AV_PIX_FMT_YUV440P : case AV_PIX_FMT_YUV444P : case AV_PIX_FMT_GBRP : case AV_PIX_FMT_GBRAP : case AV_PIX_FMT_GRAY8 : case AV_PIX_FMT_GRAY16BE : case AV_PIX_FMT_GRAY16LE : case AV_PIX_FMT_YUVJ420P : case AV_PIX_FMT_YUVJ422P : case AV_PIX_FMT_YUVJ440P : case AV_PIX_FMT_YUVJ444P : case AV_PIX_FMT_YUVA420P : case AV_PIX_FMT_YUVA422P : case AV_PIX_FMT_YUVA444P : case AV_PIX_FMT_YUV420P9LE : case AV_PIX_FMT_YUV420P9BE : case AV_PIX_FMT_YUV420P10LE : case AV_PIX_FMT_YUV420P10BE : case AV_PIX_FMT_YUV420P12LE : case AV_PIX_FMT_YUV420P12BE : case AV_PIX_FMT_YUV420P14LE : case AV_PIX_FMT_YUV420P14BE : case AV_PIX_FMT_YUV420P16LE : case AV_PIX_FMT_YUV420P16BE : case AV_PIX_FMT_YUVA420P9LE : case AV_PIX_FMT_YUVA420P9BE : case AV_PIX_FMT_YUVA420P10LE : case AV_PIX_FMT_YUVA420P10BE : case AV_PIX_FMT_YUVA420P16LE : case AV_PIX_FMT_YUVA420P16BE : case AV_PIX_FMT_YUV422P9LE : case AV_PIX_FMT_YUV422P9BE : case AV_PIX_FMT_YUV422P10LE : case AV_PIX_FMT_YUV422P10BE : case AV_PIX_FMT_YUV422P12LE : case AV_PIX_FMT_YUV422P12BE : case AV_PIX_FMT_YUV422P14LE : case AV_PIX_FMT_YUV422P14BE : case AV_PIX_FMT_YUV422P16LE : case AV_PIX_FMT_YUV422P16BE : case AV_PIX_FMT_YUVA422P9LE : case AV_PIX_FMT_YUVA422P9BE : case AV_PIX_FMT_YUVA422P10LE : case AV_PIX_FMT_YUVA422P10BE : case AV_PIX_FMT_YUVA422P16LE : case AV_PIX_FMT_YUVA422P16BE : case AV_PIX_FMT_YUV440P10LE : case AV_PIX_FMT_YUV440P10BE : case AV_PIX_FMT_YUV440P12LE : case AV_PIX_FMT_YUV440P12BE : case AV_PIX_FMT_YUV444P9LE : case AV_PIX_FMT_YUV444P9BE : case AV_PIX_FMT_YUV444P10LE : case AV_PIX_FMT_YUV444P10BE : case AV_PIX_FMT_YUV444P12LE : case AV_PIX_FMT_YUV444P12BE : case AV_PIX_FMT_YUV444P14LE : case AV_PIX_FMT_YUV444P14BE : case AV_PIX_FMT_YUV444P16LE : case AV_PIX_FMT_YUV444P16BE : case AV_PIX_FMT_YUVA444P9LE : case AV_PIX_FMT_YUVA444P9BE : case AV_PIX_FMT_YUVA444P10LE : case AV_PIX_FMT_YUVA444P10BE : case AV_PIX_FMT_YUVA444P16LE : case AV_PIX_FMT_YUVA444P16BE : case AV_PIX_FMT_GBRP9LE : case AV_PIX_FMT_GBRP9BE : case AV_PIX_FMT_GBRP10LE : case AV_PIX_FMT_GBRP10BE : case AV_PIX_FMT_GBRP12LE : case AV_PIX_FMT_GBRP12BE : case AV_PIX_FMT_GBRP14LE : case AV_PIX_FMT_GBRP14BE : case AV_PIX_FMT_GBRP16LE : case AV_PIX_FMT_GBRP16BE : case AV_PIX_FMT_GBRAP12LE : case AV_PIX_FMT_GBRAP12BE : case AV_PIX_FMT_GBRAP16LE : case AV_PIX_FMT_GBRAP16BE : w_align = 16 ; h_align = 16 * 2 ; break ; case AV_PIX_FMT_YUV411P : case AV_PIX_FMT_YUVJ411P : case AV_PIX_FMT_UYYVYY411 : w_align = 32 ; h_align = 16 * 2 ; break ; case AV_PIX_FMT_YUV410P : if ( s -> codec_id == AV_CODEC_ID_SVQ1 ) { w_align = 64 ; h_align = 64 ; } break ; case AV_PIX_FMT_RGB555 : if ( s -> codec_id == AV_CODEC_ID_RPZA ) { w_align = 4 ; h_align = 4 ; } <S2SV_StartBug> break ; <S2SV_EndBug> case AV_PIX_FMT_PAL8 : case AV_PIX_FMT_BGR8 : case AV_PIX_FMT_RGB8 : if ( s -> codec_id == AV_CODEC_ID_SMC || s -> codec_id == AV_CODEC_ID_CINEPAK ) { w_align = 4 ; h_align = 4 ; } <S2SV_StartBug> if ( s -> codec_id == AV_CODEC_ID_JV ) { <S2SV_EndBug> w_align = 8 ; h_align = 8 ; } break ; case AV_PIX_FMT_BGR24 : if ( ( s -> codec_id == AV_CODEC_ID_MSZH ) || ( s -> codec_id == AV_CODEC_ID_ZLIB ) ) { w_align = 4 ; h_align = 4 ; } break ; case AV_PIX_FMT_RGB24 : if ( s -> codec_id == AV_CODEC_ID_CINEPAK ) { w_align = 4 ; h_align = 4 ; } break ; default : break ; } if ( s -> codec_id == AV_CODEC_ID_IFF_ILBM ) { w_align = FFMAX ( w_align , 8 ) ; } * width = FFALIGN ( * width , w_align ) ; * height = FFALIGN ( * height , h_align ) ; if ( s -> codec_id == AV_CODEC_ID_H264 || s -> lowres ) { * height += 2 ; * width = FFMAX ( * width , 32 ) ; } for ( i = 0 ; i < 4 ; i ++ ) linesize_align [ i ] = STRIDE_ALIGN ; }\n",
      "fixed_code": "<S2SV_ModStart> 4 ; } if ( s -> codec_id == AV_CODEC_ID_INTERPLAY_VIDEO ) { w_align = 8 ; h_align = 8 ; } <S2SV_ModStart> codec_id == AV_CODEC_ID_JV || s -> codec_id == AV_CODEC_ID_INTERPLAY_VIDEO\n",
      "source_code_length": 4145,
      "target_code_length": 197,
      "vulnerability_patterns": {
        "integer_overflow": 2,
        "null_pointer": 15,
        "total": 17
      },
      "total_patterns": 17,
      "original_address": "https://github.com/FFmpeg/FFmpeg/commit/2080bc33717955a0e4268e738acf8c1eeddbf8cb",
      "discovery_time": "2017-04-14T04:59Z",
      "project_commit_id": "FFmpeg@FFmpeg/2080bc33717955a0e4268e738acf8c1eeddbf8cb",
      "extraction_time": "2025-08-31T15:41:49.179968",
      "label": 1,
      "vulnerability_type": "out-of-bounds_write",
      "difficulty_level": "expert",
      "risk_factors": [
        "system_crash",
        "memory_corruption",
        "critical_infrastructure",
        "arbitrary_code_execution"
      ],
      "attack_vectors": [
        "memory_manipulation",
        "malicious_input",
        "code_analysis",
        "buffer_overflow",
        "reverse_engineering",
        "fuzzing"
      ],
      "mitigation_strategies": [
        "safe_string_functions",
        "dynamic_analysis",
        "code_review",
        "static_analysis",
        "memory_safety_checks",
        "input_validation",
        "fuzzing",
        "bounds_checking",
        "secure_coding_practices"
      ],
      "code_differences": {
        "has_differences": true,
        "source_lines": 2,
        "target_lines": 2,
        "character_differences": 3948,
        "similarity_percentage": 10.303030303030303
      },
      "vulnerability_location": {
        "vulnerability_present": true,
        "fix_applied": true,
        "code_changed": true,
        "estimated_lines_changed": 0
      }
    },
    {
      "cve_id": "CVE-2015-8957",
      "cwe_id": "CWE-119",
      "cwe_name": "Buffer Overflow",
      "project": "ImageMagick",
      "severity": "critical",
      "weaponization_score": 9.0,
      "is_critical": true,
      "is_weaponizable": true,
      "is_high_priority_project": true,
      "vulnerable_code": "CWE-119 static Image * ReadSUNImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { # define RMT_EQUAL_RGB 1 # define RMT_NONE 0 # define RMT_RAW 2 # define RT_STANDARD 1 # define RT_ENCODED 2 # define RT_FORMAT_RGB 3 typedef struct _SUNInfo { unsigned int magic , width , height , depth , length , type , maptype , maplength ; } SUNInfo ; Image * image ; int bit ; MagickBooleanType status ; MagickSizeType number_pixels ; register Quantum * q ; register ssize_t i , x ; register unsigned char * p ; size_t bytes_per_line , extent , length ; ssize_t count , y ; SUNInfo sun_info ; unsigned char * sun_data , * sun_pixels ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickSignature ) ; if ( image_info -> debug != MagickFalse ) ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , \"%s\" , image_info -> filename ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickSignature ) ; image = AcquireImage ( image_info , exception ) ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } ( void ) ResetMagickMemory ( & sun_info , 0 , sizeof ( sun_info ) ) ; sun_info . magic = ReadBlobMSBLong ( image ) ; do { if ( sun_info . magic != 0x59a66a95 ) ThrowReaderException ( CorruptImageError , \"ImproperImageHeader\" ) ; sun_info . width = ReadBlobMSBLong ( image ) ; sun_info . height = ReadBlobMSBLong ( image ) ; sun_info . depth = ReadBlobMSBLong ( image ) ; sun_info . length = ReadBlobMSBLong ( image ) ; sun_info . type = ReadBlobMSBLong ( image ) ; sun_info . maptype = ReadBlobMSBLong ( image ) ; sun_info . maplength = ReadBlobMSBLong ( image ) ; extent = sun_info . height * sun_info . width ; if ( ( sun_info . height != 0 ) && ( sun_info . width != extent / sun_info . height ) ) ThrowReaderException ( CorruptImageError , \"ImproperImageHeader\" ) ; if ( ( sun_info . type != RT_STANDARD ) && ( sun_info . type != RT_ENCODED ) && ( sun_info . type != RT_FORMAT_RGB ) ) ThrowReaderException ( CorruptImageError , \"ImproperImageHeader\" ) ; if ( ( sun_info . maptype == RMT_NONE ) && ( sun_info . maplength != 0 ) ) ThrowReaderException ( CorruptImageError , \"ImproperImageHeader\" ) ; if ( ( sun_info . depth == 0 ) || ( sun_info . depth > 32 ) ) ThrowReaderException ( CorruptImageError , \"ImproperImageHeader\" ) ; if ( ( sun_info . maptype != RMT_NONE ) && ( sun_info . maptype != RMT_EQUAL_RGB ) && ( sun_info . maptype != RMT_RAW ) ) ThrowReaderException ( CoderError , \"ColormapTypeNotSupported\" ) ; image -> columns = sun_info . width ; image -> rows = sun_info . height ; image -> depth = sun_info . depth <= 8 ? sun_info . depth : MAGICKCORE_QUANTUM_DEPTH ; if ( sun_info . depth < 24 ) { size_t one ; image -> colors = sun_info . maplength ; one = 1 ; if ( sun_info . maptype == RMT_NONE ) image -> colors = one << sun_info . depth ; if ( sun_info . maptype == RMT_EQUAL_RGB ) image -> colors = sun_info . maplength / 3 ; if ( AcquireImageColormap ( image , image -> colors , exception ) == MagickFalse ) ThrowReaderException ( ResourceLimitError , \"MemoryAllocationFailed\" ) ; } switch ( sun_info . maptype ) <S2SV_StartBug> { <S2SV_EndBug> case RMT_EQUAL_RGB : { unsigned char * sun_colormap ; sun_colormap = ( unsigned char * ) AcquireQuantumMemory ( image -> colors , sizeof ( * sun_colormap ) ) ; if ( sun_colormap == ( unsigned char * ) NULL ) ThrowReaderException ( ResourceLimitError , \"MemoryAllocationFailed\" ) ; count = ReadBlob ( image , image -> colors , sun_colormap ) ; if ( count != ( ssize_t ) image -> colors ) ThrowReaderException ( CorruptImageError , \"UnexpectedEndOfFile\" ) ; for ( i = 0 ; i < ( ssize_t ) image -> colors ; i ++ ) image -> colormap [ i ] . red = ( MagickRealType ) ScaleCharToQuantum ( sun_colormap [ i ] ) ; count = ReadBlob ( image , image -> colors , sun_colormap ) ; if ( count != ( ssize_t ) image -> colors ) ThrowReaderException ( CorruptImageError , \"UnexpectedEndOfFile\" ) ; for ( i = 0 ; i < ( ssize_t ) image -> colors ; i ++ ) image -> colormap [ i ] . green = ( MagickRealType ) ScaleCharToQuantum ( sun_colormap [ i ] ) ; count = ReadBlob ( image , image -> colors , sun_colormap ) ; if ( count != ( ssize_t ) image -> colors ) ThrowReaderException ( CorruptImageError , \"UnexpectedEndOfFile\" ) ; for ( i = 0 ; i < ( ssize_t ) image -> colors ; i ++ ) image -> colormap [ i ] . blue = ( MagickRealType ) ScaleCharToQuantum ( sun_colormap [ i ] ) ; sun_colormap = ( unsigned char * ) RelinquishMagickMemory ( sun_colormap ) ; break ; } case RMT_RAW : { unsigned char * sun_colormap ; sun_colormap = ( unsigned char * ) AcquireQuantumMemory ( sun_info . maplength , sizeof ( * sun_colormap ) ) ; if ( sun_colormap == ( unsigned char * ) NULL ) ThrowReaderException ( ResourceLimitError , \"MemoryAllocationFailed\" ) ; count = ReadBlob ( image , sun_info . maplength , sun_colormap ) ; if ( count != ( ssize_t ) sun_info . maplength ) ThrowReaderException ( CorruptImageError , \"UnexpectedEndOfFile\" ) ; sun_colormap = ( unsigned char * ) RelinquishMagickMemory ( sun_colormap ) ; break ; } default : ThrowReaderException ( CoderError , \"ColormapTypeNotSupported\" ) ; } image -> alpha_trait = sun_info . depth == 32 ? BlendPixelTrait : UndefinedPixelTrait ; image -> columns = sun_info . width ; image -> rows = sun_info . height ; if ( image_info -> ping != MagickFalse ) { ( void ) CloseBlob ( image ) ; return ( GetFirstImageInList ( image ) ) ; } status = SetImageExtent ( image , image -> columns , image -> rows , exception ) ; if ( status == MagickFalse ) return ( DestroyImageList ( image ) ) ; if ( ( sun_info . length * sizeof ( * sun_data ) ) / sizeof ( * sun_data ) != sun_info . length || ! sun_info . length ) ThrowReaderException ( ResourceLimitError , \"MemoryAllocationFailed\" ) ; number_pixels = ( MagickSizeType ) image -> columns * image -> rows ; if ( ( sun_info . type != RT_ENCODED ) && ( sun_info . depth >= 8 ) && ( ( number_pixels * ( ( sun_info . depth + 7 ) / 8 ) ) > sun_info . length ) ) ThrowReaderException ( CorruptImageError , \"ImproperImageHeader\" ) ; bytes_per_line = sun_info . width * sun_info . depth ; sun_data = ( unsigned char * ) AcquireQuantumMemory ( ( size_t ) MagickMax ( sun_info . length , bytes_per_line * sun_info . width ) , sizeof ( * sun_data ) ) ; if ( sun_data == ( unsigned char * ) NULL ) ThrowReaderException ( ResourceLimitError , \"MemoryAllocationFailed\" ) ; count = ( ssize_t ) ReadBlob ( image , sun_info . length , sun_data ) ; if ( count != ( ssize_t ) sun_info . length ) ThrowReaderException ( CorruptImageError , \"UnableToReadImageData\" ) ; sun_pixels = sun_data ; bytes_per_line = 0 ; if ( sun_info . type == RT_ENCODED ) { size_t height ; height = sun_info . height ; if ( ( height == 0 ) || ( sun_info . width == 0 ) || ( sun_info . depth == 0 ) || ( ( bytes_per_line / sun_info . depth ) != sun_info . width ) ) ThrowReaderException ( ResourceLimitError , \"MemoryAllocationFailed\" ) ; bytes_per_line += 15 ; bytes_per_line <<= 1 ; if ( ( bytes_per_line >> 1 ) != ( sun_info . width * sun_info . depth + 15 ) ) ThrowReaderException ( ResourceLimitError , \"MemoryAllocationFailed\" ) ; bytes_per_line >>= 4 ; sun_pixels = ( unsigned char * ) AcquireQuantumMemory ( height , bytes_per_line * sizeof ( * sun_pixels ) ) ; if ( sun_pixels == ( unsigned char * ) NULL ) ThrowReaderException ( ResourceLimitError , \"MemoryAllocationFailed\" ) ; ( void ) DecodeImage ( sun_data , sun_info . length , sun_pixels , bytes_per_line * height ) ; sun_data = ( unsigned char * ) RelinquishMagickMemory ( sun_data ) ; } p = sun_pixels ; if ( sun_info . depth == 1 ) for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; for ( x = 0 ; x < ( ( ssize_t ) image -> columns - 7 ) ; x += 8 ) { for ( bit = 7 ; bit >= 0 ; bit -- ) { SetPixelIndex ( image , ( Quantum ) ( ( * p ) & ( 0x01 << bit ) ? 0x00 : 0x01 ) , q ) ; q += GetPixelChannels ( image ) ; } p ++ ; } if ( ( image -> columns % 8 ) != 0 ) { for ( bit = 7 ; bit >= ( int ) ( 8 - ( image -> columns % 8 ) ) ; bit -- ) { SetPixelIndex ( image , ( Quantum ) ( ( * p ) & ( 0x01 << bit ) ? 0x00 : 0x01 ) , q ) ; q += GetPixelChannels ( image ) ; } p ++ ; } if ( ( ( ( image -> columns / 8 ) + ( image -> columns % 8 ? 1 : 0 ) ) % 2 ) != 0 ) p ++ ; if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ; if ( status == MagickFalse ) break ; } } else if ( image -> storage_class == PseudoClass ) { if ( bytes_per_line == 0 ) bytes_per_line = image -> columns ; length = image -> rows * ( image -> columns + image -> columns % 2 ) ; if ( ( ( sun_info . type == RT_ENCODED ) && ( length > ( bytes_per_line * image -> rows ) ) ) || ( ( sun_info . type != RT_ENCODED ) && ( length > sun_info . length ) ) ) ThrowReaderException ( CorruptImageError , \"UnableToReadImageData\" ) ; for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { SetPixelIndex ( image , * p ++ , q ) ; q += GetPixelChannels ( image ) ; } if ( ( image -> columns % 2 ) != 0 ) p ++ ; if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ; if ( status == MagickFalse ) break ; } } } else { size_t bytes_per_pixel ; bytes_per_pixel = 3 ; if ( image -> alpha_trait != UndefinedPixelTrait ) bytes_per_pixel ++ ; if ( bytes_per_line == 0 ) bytes_per_line = bytes_per_pixel * image -> columns ; length = image -> rows * ( bytes_per_line + image -> columns % 2 ) ; if ( ( ( sun_info . type == RT_ENCODED ) && ( length > ( bytes_per_line * image -> rows ) ) ) || ( ( sun_info . type != RT_ENCODED ) && ( length > sun_info . length ) ) ) ThrowReaderException ( CorruptImageError , \"UnableToReadImageData\" ) ; for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { if ( image -> alpha_trait != UndefinedPixelTrait ) SetPixelAlpha ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; if ( sun_info . type == RT_STANDARD ) { SetPixelBlue ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; SetPixelGreen ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; SetPixelRed ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; } else { SetPixelRed ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; SetPixelGreen ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; SetPixelBlue ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; } if ( image -> colors != 0 ) { SetPixelRed ( image , ClampToQuantum ( image -> colormap [ ( ssize_t ) GetPixelRed ( image , q ) ] . red ) , q ) ; SetPixelGreen ( image , ClampToQuantum ( image -> colormap [ ( ssize_t ) GetPixelGreen ( image , q ) ] . green ) , q ) ; SetPixelBlue ( image , ClampToQuantum ( image -> colormap [ ( ssize_t ) GetPixelBlue ( image , q ) ] . blue ) , q ) ; } q += GetPixelChannels ( image ) ; } if ( ( ( bytes_per_pixel * image -> columns ) % 2 ) != 0 ) p ++ ; if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ; if ( status == MagickFalse ) break ; } } } if ( image -> storage_class == PseudoClass ) ( void ) SyncImage ( image , exception ) ; sun_pixels = ( unsigned char * ) RelinquishMagickMemory ( sun_pixels ) ; if ( EOFBlob ( image ) != MagickFalse ) { ThrowFileException ( exception , CorruptImageError , \"UnexpectedEndOfFile\" , image -> filename ) ; break ; } if ( image_info -> number_scenes != 0 ) if ( image -> scene >= ( image_info -> scene + image_info -> number_scenes - 1 ) ) break ; sun_info . magic = ReadBlobMSBLong ( image ) ; if ( sun_info . magic == 0x59a66a95 ) { AcquireNextImage ( image_info , image , exception ) ; if ( GetNextImageInList ( image ) == ( Image * ) NULL ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } image = SyncNextImageInList ( image ) ; status = SetImageProgress ( image , LoadImagesTag , TellBlob ( image ) , GetBlobSize ( image ) ) ; if ( status == MagickFalse ) break ; } } while ( sun_info . magic == 0x59a66a95 ) ; ( void ) CloseBlob ( image ) ; return ( GetFirstImageInList ( image ) ) ; }\n",
      "fixed_code": "<S2SV_ModStart> maptype ) { case RMT_NONE : break ;\n",
      "source_code_length": 12787,
      "target_code_length": 52,
      "vulnerability_patterns": {
        "integer_overflow": 30,
        "null_pointer": 75,
        "total": 105
      },
      "total_patterns": 105,
      "original_address": "https://github.com/ImageMagick/ImageMagick/commit/450bd716ed3b9186dd10f9e60f630a3d9eeea2a4",
      "discovery_time": "2017-04-20T18:59Z",
      "project_commit_id": "ImageMagick@ImageMagick/450bd716ed3b9186dd10f9e60f630a3d9eeea2a4",
      "extraction_time": "2025-08-31T15:41:49.180008",
      "label": 1,
      "vulnerability_type": "buffer_overflow",
      "difficulty_level": "expert",
      "risk_factors": [
        "system_crash",
        "memory_corruption",
        "critical_infrastructure",
        "arbitrary_code_execution"
      ],
      "attack_vectors": [
        "memory_manipulation",
        "malicious_input",
        "code_analysis",
        "buffer_overflow",
        "reverse_engineering",
        "fuzzing"
      ],
      "mitigation_strategies": [
        "safe_string_functions",
        "dynamic_analysis",
        "code_review",
        "static_analysis",
        "memory_safety_checks",
        "input_validation",
        "fuzzing",
        "bounds_checking",
        "secure_coding_practices"
      ],
      "code_differences": {
        "has_differences": true,
        "source_lines": 2,
        "target_lines": 2,
        "character_differences": 12735,
        "similarity_percentage": 4.060913705583756
      },
      "vulnerability_location": {
        "vulnerability_present": true,
        "fix_applied": true,
        "code_changed": true,
        "estimated_lines_changed": 0
      }
    },
    {
      "cve_id": "CVE-2015-0206",
      "cwe_id": "CWE-119",
      "cwe_name": "Buffer Overflow",
      "project": "openssl",
      "severity": "critical",
      "weaponization_score": 9.0,
      "is_critical": true,
      "is_weaponizable": true,
      "is_high_priority_project": true,
      "vulnerable_code": "CWE-119 int dtls1_read_bytes ( SSL * s , int type , unsigned char * buf , int len , int peek ) { int al , i , j , ret ; unsigned int n ; SSL3_RECORD * rr ; void ( * cb ) ( const SSL * ssl , int type2 , int val ) = NULL ; if ( s -> s3 -> rbuf . buf == NULL ) if ( ! ssl3_setup_buffers ( s ) ) return ( - 1 ) ; if ( ( type && ( type != SSL3_RT_APPLICATION_DATA ) && ( type != SSL3_RT_HANDSHAKE ) ) || ( peek && ( type != SSL3_RT_APPLICATION_DATA ) ) ) { SSLerr ( SSL_F_DTLS1_READ_BYTES , ERR_R_INTERNAL_ERROR ) ; return - 1 ; } if ( ( ret = have_handshake_fragment ( s , type , buf , len , peek ) ) ) return ret ; # ifndef OPENSSL_NO_SCTP if ( ( ! s -> in_handshake && SSL_in_init ( s ) ) || ( BIO_dgram_is_sctp ( SSL_get_rbio ( s ) ) && ( s -> state == DTLS1_SCTP_ST_SR_READ_SOCK || s -> state == DTLS1_SCTP_ST_CR_READ_SOCK ) && s -> s3 -> in_read_app_data != 2 ) ) # else if ( ! s -> in_handshake && SSL_in_init ( s ) ) # endif { i = s -> handshake_func ( s ) ; if ( i < 0 ) return ( i ) ; if ( i == 0 ) { SSLerr ( SSL_F_DTLS1_READ_BYTES , SSL_R_SSL_HANDSHAKE_FAILURE ) ; return ( - 1 ) ; } } start : s -> rwstate = SSL_NOTHING ; rr = & ( s -> s3 -> rrec ) ; if ( s -> state == SSL_ST_OK && rr -> length == 0 ) { pitem * item ; item = pqueue_pop ( s -> d1 -> buffered_app_data . q ) ; if ( item ) { # ifndef OPENSSL_NO_SCTP if ( BIO_dgram_is_sctp ( SSL_get_rbio ( s ) ) ) { DTLS1_RECORD_DATA * rdata = ( DTLS1_RECORD_DATA * ) item -> data ; BIO_ctrl ( SSL_get_rbio ( s ) , BIO_CTRL_DGRAM_SCTP_SET_RCVINFO , sizeof ( rdata -> recordinfo ) , & rdata -> recordinfo ) ; } # endif dtls1_copy_record ( s , item ) ; OPENSSL_free ( item -> data ) ; pitem_free ( item ) ; } } if ( dtls1_handle_timeout ( s ) > 0 ) goto start ; if ( ( rr -> length == 0 ) || ( s -> rstate == SSL_ST_READ_BODY ) ) { ret = dtls1_get_record ( s ) ; if ( ret <= 0 ) { ret = dtls1_read_failed ( s , ret ) ; if ( ret <= 0 ) return ( ret ) ; else goto start ; } } if ( s -> d1 -> listen && rr -> type != SSL3_RT_HANDSHAKE ) { rr -> length = 0 ; goto start ; } if ( s -> s3 -> change_cipher_spec && ( rr -> type != SSL3_RT_HANDSHAKE ) ) { <S2SV_StartBug> dtls1_buffer_record ( s , & ( s -> d1 -> buffered_app_data ) , rr -> seq_num ) ; <S2SV_EndBug> rr -> length = 0 ; goto start ; } if ( s -> shutdown & SSL_RECEIVED_SHUTDOWN ) { rr -> length = 0 ; s -> rwstate = SSL_NOTHING ; return ( 0 ) ; } if ( type == rr -> type ) { if ( SSL_in_init ( s ) && ( type == SSL3_RT_APPLICATION_DATA ) && ( s -> enc_read_ctx == NULL ) ) { al = SSL_AD_UNEXPECTED_MESSAGE ; SSLerr ( SSL_F_DTLS1_READ_BYTES , SSL_R_APP_DATA_IN_HANDSHAKE ) ; goto f_err ; } if ( len <= 0 ) return ( len ) ; if ( ( unsigned int ) len > rr -> length ) n = rr -> length ; else n = ( unsigned int ) len ; memcpy ( buf , & ( rr -> data [ rr -> off ] ) , n ) ; if ( ! peek ) { rr -> length -= n ; rr -> off += n ; if ( rr -> length == 0 ) { s -> rstate = SSL_ST_READ_HEADER ; rr -> off = 0 ; } } # ifndef OPENSSL_NO_SCTP if ( BIO_dgram_is_sctp ( SSL_get_rbio ( s ) ) && rr -> type == SSL3_RT_APPLICATION_DATA && ( s -> state == DTLS1_SCTP_ST_SR_READ_SOCK || s -> state == DTLS1_SCTP_ST_CR_READ_SOCK ) ) { s -> rwstate = SSL_READING ; BIO_clear_retry_flags ( SSL_get_rbio ( s ) ) ; BIO_set_retry_read ( SSL_get_rbio ( s ) ) ; } if ( BIO_dgram_is_sctp ( SSL_get_rbio ( s ) ) && s -> d1 -> shutdown_received && ! BIO_dgram_sctp_msg_waiting ( SSL_get_rbio ( s ) ) ) { s -> shutdown |= SSL_RECEIVED_SHUTDOWN ; return ( 0 ) ; } # endif return ( n ) ; } { unsigned int k , dest_maxlen = 0 ; unsigned char * dest = NULL ; unsigned int * dest_len = NULL ; if ( rr -> type == SSL3_RT_HANDSHAKE ) { dest_maxlen = sizeof s -> d1 -> handshake_fragment ; dest = s -> d1 -> handshake_fragment ; dest_len = & s -> d1 -> handshake_fragment_len ; } else if ( rr -> type == SSL3_RT_ALERT ) { dest_maxlen = sizeof ( s -> d1 -> alert_fragment ) ; dest = s -> d1 -> alert_fragment ; dest_len = & s -> d1 -> alert_fragment_len ; } # ifndef OPENSSL_NO_HEARTBEATS else if ( rr -> type == TLS1_RT_HEARTBEAT ) { dtls1_process_heartbeat ( s ) ; rr -> length = 0 ; s -> rwstate = SSL_READING ; BIO_clear_retry_flags ( SSL_get_rbio ( s ) ) ; BIO_set_retry_read ( SSL_get_rbio ( s ) ) ; return ( - 1 ) ; } # endif else if ( rr -> type != SSL3_RT_CHANGE_CIPHER_SPEC ) { if ( rr -> type == SSL3_RT_APPLICATION_DATA ) { BIO * bio ; s -> s3 -> in_read_app_data = 2 ; bio = SSL_get_rbio ( s ) ; s -> rwstate = SSL_READING ; BIO_clear_retry_flags ( bio ) ; BIO_set_retry_read ( bio ) ; return ( - 1 ) ; } al = SSL_AD_UNEXPECTED_MESSAGE ; SSLerr ( SSL_F_DTLS1_READ_BYTES , SSL_R_UNEXPECTED_RECORD ) ; goto f_err ; } if ( dest_maxlen > 0 ) { if ( rr -> length < dest_maxlen ) { # ifdef DTLS1_AD_MISSING_HANDSHAKE_MESSAGE FIX ME # endif s -> rstate = SSL_ST_READ_HEADER ; rr -> length = 0 ; goto start ; } for ( k = 0 ; k < dest_maxlen ; k ++ ) { dest [ k ] = rr -> data [ rr -> off ++ ] ; rr -> length -- ; } * dest_len = dest_maxlen ; } } if ( ( ! s -> server ) && ( s -> d1 -> handshake_fragment_len >= DTLS1_HM_HEADER_LENGTH ) && ( s -> d1 -> handshake_fragment [ 0 ] == SSL3_MT_HELLO_REQUEST ) && ( s -> session != NULL ) && ( s -> session -> cipher != NULL ) ) { s -> d1 -> handshake_fragment_len = 0 ; if ( ( s -> d1 -> handshake_fragment [ 1 ] != 0 ) || ( s -> d1 -> handshake_fragment [ 2 ] != 0 ) || ( s -> d1 -> handshake_fragment [ 3 ] != 0 ) ) { al = SSL_AD_DECODE_ERROR ; SSLerr ( SSL_F_DTLS1_READ_BYTES , SSL_R_BAD_HELLO_REQUEST ) ; goto err ; } if ( s -> msg_callback ) s -> msg_callback ( 0 , s -> version , SSL3_RT_HANDSHAKE , s -> d1 -> handshake_fragment , 4 , s , s -> msg_callback_arg ) ; if ( SSL_is_init_finished ( s ) && ! ( s -> s3 -> flags & SSL3_FLAGS_NO_RENEGOTIATE_CIPHERS ) && ! s -> s3 -> renegotiate ) { s -> d1 -> handshake_read_seq ++ ; s -> new_session = 1 ; ssl3_renegotiate ( s ) ; if ( ssl3_renegotiate_check ( s ) ) { i = s -> handshake_func ( s ) ; if ( i < 0 ) return ( i ) ; if ( i == 0 ) { SSLerr ( SSL_F_DTLS1_READ_BYTES , SSL_R_SSL_HANDSHAKE_FAILURE ) ; return ( - 1 ) ; } if ( ! ( s -> mode & SSL_MODE_AUTO_RETRY ) ) { if ( s -> s3 -> rbuf . left == 0 ) { BIO * bio ; s -> rwstate = SSL_READING ; bio = SSL_get_rbio ( s ) ; BIO_clear_retry_flags ( bio ) ; BIO_set_retry_read ( bio ) ; return ( - 1 ) ; } } } } goto start ; } if ( s -> d1 -> alert_fragment_len >= DTLS1_AL_HEADER_LENGTH ) { int alert_level = s -> d1 -> alert_fragment [ 0 ] ; int alert_descr = s -> d1 -> alert_fragment [ 1 ] ; s -> d1 -> alert_fragment_len = 0 ; if ( s -> msg_callback ) s -> msg_callback ( 0 , s -> version , SSL3_RT_ALERT , s -> d1 -> alert_fragment , 2 , s , s -> msg_callback_arg ) ; if ( s -> info_callback != NULL ) cb = s -> info_callback ; else if ( s -> ctx -> info_callback != NULL ) cb = s -> ctx -> info_callback ; if ( cb != NULL ) { j = ( alert_level << 8 ) | alert_descr ; cb ( s , SSL_CB_READ_ALERT , j ) ; } if ( alert_level == 1 ) { s -> s3 -> warn_alert = alert_descr ; if ( alert_descr == SSL_AD_CLOSE_NOTIFY ) { # ifndef OPENSSL_NO_SCTP if ( BIO_dgram_is_sctp ( SSL_get_rbio ( s ) ) && BIO_dgram_sctp_msg_waiting ( SSL_get_rbio ( s ) ) ) { s -> d1 -> shutdown_received = 1 ; s -> rwstate = SSL_READING ; BIO_clear_retry_flags ( SSL_get_rbio ( s ) ) ; BIO_set_retry_read ( SSL_get_rbio ( s ) ) ; return - 1 ; } # endif s -> shutdown |= SSL_RECEIVED_SHUTDOWN ; return ( 0 ) ; } # if 0 if ( alert_descr == DTLS1_AD_MISSING_HANDSHAKE_MESSAGE ) { unsigned short seq ; unsigned int frag_off ; unsigned char * p = & ( s -> d1 -> alert_fragment [ 2 ] ) ; n2s ( p , seq ) ; n2l3 ( p , frag_off ) ; dtls1_retransmit_message ( s , dtls1_get_queue_priority ( frag -> msg_header . seq , 0 ) , frag_off , & found ) ; if ( ! found && SSL_in_init ( s ) ) { ssl3_send_alert ( s , SSL3_AL_WARNING , DTLS1_AD_MISSING_HANDSHAKE_MESSAGE ) ; } } # endif } else if ( alert_level == 2 ) { char tmp [ 16 ] ; s -> rwstate = SSL_NOTHING ; s -> s3 -> fatal_alert = alert_descr ; SSLerr ( SSL_F_DTLS1_READ_BYTES , SSL_AD_REASON_OFFSET + alert_descr ) ; BIO_snprintf ( tmp , sizeof tmp , \"%d\" , alert_descr ) ; ERR_add_error_data ( 2 , \"SSL<S2SV_blank>alert<S2SV_blank>number<S2SV_blank>\" , tmp ) ; s -> shutdown |= SSL_RECEIVED_SHUTDOWN ; SSL_CTX_remove_session ( s -> ctx , s -> session ) ; return ( 0 ) ; } else { al = SSL_AD_ILLEGAL_PARAMETER ; SSLerr ( SSL_F_DTLS1_READ_BYTES , SSL_R_UNKNOWN_ALERT_TYPE ) ; goto f_err ; } goto start ; } if ( s -> shutdown & SSL_SENT_SHUTDOWN ) { s -> rwstate = SSL_NOTHING ; rr -> length = 0 ; return ( 0 ) ; } if ( rr -> type == SSL3_RT_CHANGE_CIPHER_SPEC ) { struct ccs_header_st ccs_hdr ; unsigned int ccs_hdr_len = DTLS1_CCS_HEADER_LENGTH ; dtls1_get_ccs_header ( rr -> data , & ccs_hdr ) ; if ( s -> version == DTLS1_BAD_VER ) ccs_hdr_len = 3 ; if ( ( rr -> length != ccs_hdr_len ) || ( rr -> off != 0 ) || ( rr -> data [ 0 ] != SSL3_MT_CCS ) ) { i = SSL_AD_ILLEGAL_PARAMETER ; SSLerr ( SSL_F_DTLS1_READ_BYTES , SSL_R_BAD_CHANGE_CIPHER_SPEC ) ; goto err ; } rr -> length = 0 ; if ( s -> msg_callback ) s -> msg_callback ( 0 , s -> version , SSL3_RT_CHANGE_CIPHER_SPEC , rr -> data , 1 , s , s -> msg_callback_arg ) ; if ( ! s -> d1 -> change_cipher_spec_ok ) { goto start ; } s -> d1 -> change_cipher_spec_ok = 0 ; s -> s3 -> change_cipher_spec = 1 ; if ( ! ssl3_do_change_cipher_spec ( s ) ) goto err ; dtls1_reset_seq_numbers ( s , SSL3_CC_READ ) ; if ( s -> version == DTLS1_BAD_VER ) s -> d1 -> handshake_read_seq ++ ; # ifndef OPENSSL_NO_SCTP BIO_ctrl ( SSL_get_wbio ( s ) , BIO_CTRL_DGRAM_SCTP_AUTH_CCS_RCVD , 1 , NULL ) ; # endif goto start ; } if ( ( s -> d1 -> handshake_fragment_len >= DTLS1_HM_HEADER_LENGTH ) && ! s -> in_handshake ) { struct hm_header_st msg_hdr ; dtls1_get_message_header ( rr -> data , & msg_hdr ) ; if ( rr -> epoch != s -> d1 -> r_epoch ) { rr -> length = 0 ; goto start ; } if ( msg_hdr . type == SSL3_MT_FINISHED ) { if ( dtls1_check_timeout_num ( s ) < 0 ) return - 1 ; dtls1_retransmit_buffered_messages ( s ) ; rr -> length = 0 ; goto start ; } if ( ( ( s -> state & SSL_ST_MASK ) == SSL_ST_OK ) && ! ( s -> s3 -> flags & SSL3_FLAGS_NO_RENEGOTIATE_CIPHERS ) ) { # if 0 s -> state = SSL_ST_BEFORE | ( s -> server ) ? SSL_ST_ACCEPT : SSL_ST_CONNECT ; # else s -> state = s -> server ? SSL_ST_ACCEPT : SSL_ST_CONNECT ; # endif s -> renegotiate = 1 ; s -> new_session = 1 ; } i = s -> handshake_func ( s ) ; if ( i < 0 ) return ( i ) ; if ( i == 0 ) { SSLerr ( SSL_F_DTLS1_READ_BYTES , SSL_R_SSL_HANDSHAKE_FAILURE ) ; return ( - 1 ) ; } if ( ! ( s -> mode & SSL_MODE_AUTO_RETRY ) ) { if ( s -> s3 -> rbuf . left == 0 ) { BIO * bio ; s -> rwstate = SSL_READING ; bio = SSL_get_rbio ( s ) ; BIO_clear_retry_flags ( bio ) ; BIO_set_retry_read ( bio ) ; return ( - 1 ) ; } } goto start ; } switch ( rr -> type ) { default : # ifndef OPENSSL_NO_TLS if ( s -> version == TLS1_VERSION ) { rr -> length = 0 ; goto start ; } # endif al = SSL_AD_UNEXPECTED_MESSAGE ; SSLerr ( SSL_F_DTLS1_READ_BYTES , SSL_R_UNEXPECTED_RECORD ) ; goto f_err ; case SSL3_RT_CHANGE_CIPHER_SPEC : case SSL3_RT_ALERT : case SSL3_RT_HANDSHAKE : al = SSL_AD_UNEXPECTED_MESSAGE ; SSLerr ( SSL_F_DTLS1_READ_BYTES , ERR_R_INTERNAL_ERROR ) ; goto f_err ; case SSL3_RT_APPLICATION_DATA : if ( s -> s3 -> in_read_app_data && ( s -> s3 -> total_renegotiations != 0 ) && ( ( ( s -> state & SSL_ST_CONNECT ) && ( s -> state >= SSL3_ST_CW_CLNT_HELLO_A ) && ( s -> state <= SSL3_ST_CR_SRVR_HELLO_A ) ) || ( ( s -> state & SSL_ST_ACCEPT ) && ( s -> state <= SSL3_ST_SW_HELLO_REQ_A ) && ( s -> state >= SSL3_ST_SR_CLNT_HELLO_A ) ) ) ) { s -> s3 -> in_read_app_data = 2 ; return ( - 1 ) ; } else { al = SSL_AD_UNEXPECTED_MESSAGE ; SSLerr ( SSL_F_DTLS1_READ_BYTES , SSL_R_UNEXPECTED_RECORD ) ; goto f_err ; } } f_err : ssl3_send_alert ( s , SSL3_AL_FATAL , al ) ; err : return ( - 1 ) ; }\n",
      "fixed_code": "<S2SV_ModStart> ) ) { if ( <S2SV_ModStart> -> seq_num ) < 0 ) { SSLerr ( SSL_F_DTLS1_READ_BYTES , ERR_R_INTERNAL_ERROR ) ; return - 1 ; } <S2SV_ModEnd> rr -> length\n",
      "source_code_length": 11724,
      "target_code_length": 165,
      "vulnerability_patterns": {
        "integer_overflow": 3,
        "format_string": 3,
        "null_pointer": 42,
        "total": 48
      },
      "total_patterns": 48,
      "original_address": "https://github.com/openssl/openssl/commit/103b171d8fc282ef435f8de9afbf7782e312961f",
      "discovery_time": "2015-01-09T02:59Z",
      "project_commit_id": "openssl@openssl/103b171d8fc282ef435f8de9afbf7782e312961f",
      "extraction_time": "2025-08-31T15:41:49.180103",
      "label": 1,
      "vulnerability_type": "buffer_overflow",
      "difficulty_level": "expert",
      "risk_factors": [
        "system_crash",
        "memory_corruption",
        "critical_infrastructure",
        "arbitrary_code_execution"
      ],
      "attack_vectors": [
        "memory_manipulation",
        "malicious_input",
        "code_analysis",
        "buffer_overflow",
        "reverse_engineering",
        "fuzzing"
      ],
      "mitigation_strategies": [
        "safe_string_functions",
        "dynamic_analysis",
        "code_review",
        "static_analysis",
        "memory_safety_checks",
        "input_validation",
        "fuzzing",
        "bounds_checking",
        "secure_coding_practices"
      ],
      "code_differences": {
        "has_differences": true,
        "source_lines": 2,
        "target_lines": 2,
        "character_differences": 11559,
        "similarity_percentage": 7.480314960629922
      },
      "vulnerability_location": {
        "vulnerability_present": true,
        "fix_applied": true,
        "code_changed": true,
        "estimated_lines_changed": 0
      }
    },
    {
      "cve_id": "CVE-2013-4263",
      "cwe_id": "CWE-119",
      "cwe_name": "Buffer Overflow",
      "project": "FFmpeg",
      "severity": "critical",
      "weaponization_score": 9.0,
      "is_critical": true,
      "is_weaponizable": true,
      "is_high_priority_project": true,
      "vulnerable_code": "CWE-119 static int filter_frame ( AVFilterLink * inlink , AVFrame * inpic ) { KerndeintContext * kerndeint = inlink -> dst -> priv ; AVFilterLink * outlink = inlink -> dst -> outputs [ 0 ] ; AVFrame * outpic ; const uint8_t * prvp ; const uint8_t * prvpp ; const uint8_t * prvpn ; const uint8_t * prvppp ; const uint8_t * prvpnn ; const uint8_t * prvp4p ; const uint8_t * prvp4n ; const uint8_t * srcp ; const uint8_t * srcpp ; const uint8_t * srcpn ; const uint8_t * srcppp ; const uint8_t * srcpnn ; const uint8_t * srcp3p ; const uint8_t * srcp3n ; const uint8_t * srcp4p ; const uint8_t * srcp4n ; uint8_t * dstp , * dstp_saved ; const uint8_t * srcp_saved ; int src_linesize , psrc_linesize , dst_linesize , bwidth ; int x , y , plane , val , hi , lo , g , h , n = kerndeint -> frame ++ ; double valf ; const int thresh = kerndeint -> thresh ; const int order = kerndeint -> order ; const int map = kerndeint -> map ; const int sharp = kerndeint -> sharp ; const int twoway = kerndeint -> twoway ; const int is_packed_rgb = kerndeint -> is_packed_rgb ; outpic = ff_get_video_buffer ( outlink , outlink -> w , outlink -> h ) ; if ( ! outpic ) { av_frame_free ( & inpic ) ; return AVERROR ( ENOMEM ) ; } av_frame_copy_props ( outpic , inpic ) ; outpic -> interlaced_frame = 0 ; <S2SV_StartBug> for ( plane = 0 ; inpic -> data [ plane ] && plane < 4 ; plane ++ ) { <S2SV_EndBug> h = plane == 0 ? inlink -> h : FF_CEIL_RSHIFT ( inlink -> h , kerndeint -> vsub ) ; bwidth = kerndeint -> tmp_bwidth [ plane ] ; srcp = srcp_saved = inpic -> data [ plane ] ; src_linesize = inpic -> linesize [ plane ] ; psrc_linesize = kerndeint -> tmp_linesize [ plane ] ; dstp = dstp_saved = outpic -> data [ plane ] ; dst_linesize = outpic -> linesize [ plane ] ; srcp = srcp_saved + ( 1 - order ) * src_linesize ; dstp = dstp_saved + ( 1 - order ) * dst_linesize ; for ( y = 0 ; y < h ; y += 2 ) { memcpy ( dstp , srcp , bwidth ) ; srcp += 2 * src_linesize ; dstp += 2 * dst_linesize ; } memcpy ( dstp_saved + order * dst_linesize , srcp_saved + ( 1 - order ) * src_linesize , bwidth ) ; memcpy ( dstp_saved + ( 2 + order ) * dst_linesize , srcp_saved + ( 3 - order ) * src_linesize , bwidth ) ; memcpy ( dstp_saved + ( h - 2 + order ) * dst_linesize , srcp_saved + ( h - 1 - order ) * src_linesize , bwidth ) ; memcpy ( dstp_saved + ( h - 4 + order ) * dst_linesize , srcp_saved + ( h - 3 - order ) * src_linesize , bwidth ) ; prvp = kerndeint -> tmp_data [ plane ] + 5 * psrc_linesize - ( 1 - order ) * psrc_linesize ; prvpp = prvp - psrc_linesize ; prvppp = prvp - 2 * psrc_linesize ; prvp4p = prvp - 4 * psrc_linesize ; prvpn = prvp + psrc_linesize ; prvpnn = prvp + 2 * psrc_linesize ; prvp4n = prvp + 4 * psrc_linesize ; srcp = srcp_saved + 5 * src_linesize - ( 1 - order ) * src_linesize ; srcpp = srcp - src_linesize ; srcppp = srcp - 2 * src_linesize ; srcp3p = srcp - 3 * src_linesize ; srcp4p = srcp - 4 * src_linesize ; srcpn = srcp + src_linesize ; srcpnn = srcp + 2 * src_linesize ; srcp3n = srcp + 3 * src_linesize ; srcp4n = srcp + 4 * src_linesize ; dstp = dstp_saved + 5 * dst_linesize - ( 1 - order ) * dst_linesize ; for ( y = 5 - ( 1 - order ) ; y <= h - 5 - ( 1 - order ) ; y += 2 ) { for ( x = 0 ; x < bwidth ; x ++ ) { if ( thresh == 0 || n == 0 || ( abs ( ( int ) prvp [ x ] - ( int ) srcp [ x ] ) > thresh ) || ( abs ( ( int ) prvpp [ x ] - ( int ) srcpp [ x ] ) > thresh ) || ( abs ( ( int ) prvpn [ x ] - ( int ) srcpn [ x ] ) > thresh ) ) { if ( map ) { g = x & ~ 3 ; if ( is_packed_rgb ) { AV_WB32 ( dstp + g , 0xffffffff ) ; x = g + 3 ; } else if ( inlink -> format == AV_PIX_FMT_YUYV422 ) { AV_WB32 ( dstp + g , 0xeb80eb80 ) ; x = g + 3 ; } else { dstp [ x ] = plane == 0 ? 235 : 128 ; } } else { if ( is_packed_rgb ) { hi = 255 ; lo = 0 ; } else if ( inlink -> format == AV_PIX_FMT_YUYV422 ) { hi = x & 1 ? 240 : 235 ; lo = 16 ; } else { hi = plane == 0 ? 235 : 240 ; lo = 16 ; } if ( sharp ) { if ( twoway ) { valf = + 0.526 * ( ( int ) srcpp [ x ] + ( int ) srcpn [ x ] ) + 0.170 * ( ( int ) srcp [ x ] + ( int ) prvp [ x ] ) - 0.116 * ( ( int ) srcppp [ x ] + ( int ) srcpnn [ x ] + ( int ) prvppp [ x ] + ( int ) prvpnn [ x ] ) - 0.026 * ( ( int ) srcp3p [ x ] + ( int ) srcp3n [ x ] ) + 0.031 * ( ( int ) srcp4p [ x ] + ( int ) srcp4n [ x ] + ( int ) prvp4p [ x ] + ( int ) prvp4n [ x ] ) ; } else { valf = + 0.526 * ( ( int ) srcpp [ x ] + ( int ) srcpn [ x ] ) + 0.170 * ( ( int ) prvp [ x ] ) - 0.116 * ( ( int ) prvppp [ x ] + ( int ) prvpnn [ x ] ) - 0.026 * ( ( int ) srcp3p [ x ] + ( int ) srcp3n [ x ] ) + 0.031 * ( ( int ) prvp4p [ x ] + ( int ) prvp4p [ x ] ) ; } dstp [ x ] = av_clip ( valf , lo , hi ) ; } else { if ( twoway ) { val = ( 8 * ( ( int ) srcpp [ x ] + ( int ) srcpn [ x ] ) + 2 * ( ( int ) srcp [ x ] + ( int ) prvp [ x ] ) - ( int ) ( srcppp [ x ] ) - ( int ) ( srcpnn [ x ] ) - ( int ) ( prvppp [ x ] ) - ( int ) ( prvpnn [ x ] ) ) >> 4 ; } else { val = ( 8 * ( ( int ) srcpp [ x ] + ( int ) srcpn [ x ] ) + 2 * ( ( int ) prvp [ x ] ) - ( int ) ( prvppp [ x ] ) - ( int ) ( prvpnn [ x ] ) ) >> 4 ; } dstp [ x ] = av_clip ( val , lo , hi ) ; } } } else { dstp [ x ] = srcp [ x ] ; } } prvp += 2 * psrc_linesize ; prvpp += 2 * psrc_linesize ; prvppp += 2 * psrc_linesize ; prvpn += 2 * psrc_linesize ; prvpnn += 2 * psrc_linesize ; prvp4p += 2 * psrc_linesize ; prvp4n += 2 * psrc_linesize ; srcp += 2 * src_linesize ; srcpp += 2 * src_linesize ; srcppp += 2 * src_linesize ; srcp3p += 2 * src_linesize ; srcp4p += 2 * src_linesize ; srcpn += 2 * src_linesize ; srcpnn += 2 * src_linesize ; srcp3n += 2 * src_linesize ; srcp4n += 2 * src_linesize ; dstp += 2 * dst_linesize ; } srcp = inpic -> data [ plane ] ; dstp = kerndeint -> tmp_data [ plane ] ; av_image_copy_plane ( dstp , psrc_linesize , srcp , src_linesize , bwidth , h ) ; } av_frame_free ( & inpic ) ; return ff_filter_frame ( outlink , outpic ) ; }\n",
      "fixed_code": "<S2SV_ModStart> = 0 ; <S2SV_ModEnd> plane < 4 <S2SV_ModStart> plane < 4 && inpic -> data [ plane ] && inpic -> linesize [ plane ]\n",
      "source_code_length": 5860,
      "target_code_length": 130,
      "vulnerability_patterns": {
        "integer_overflow": 1,
        "null_pointer": 29,
        "total": 30
      },
      "total_patterns": 30,
      "original_address": "https://github.com/FFmpeg/FFmpeg/commit/e43a0a232dbf6d3c161823c2e07c52e76227a1bc",
      "discovery_time": "2013-11-23T17:55Z",
      "project_commit_id": "FFmpeg@FFmpeg/e43a0a232dbf6d3c161823c2e07c52e76227a1bc",
      "extraction_time": "2025-08-31T15:41:49.180201",
      "label": 1,
      "vulnerability_type": "buffer_overflow",
      "difficulty_level": "expert",
      "risk_factors": [
        "system_crash",
        "memory_corruption",
        "critical_infrastructure",
        "arbitrary_code_execution"
      ],
      "attack_vectors": [
        "memory_manipulation",
        "malicious_input",
        "code_analysis",
        "buffer_overflow",
        "reverse_engineering",
        "fuzzing"
      ],
      "mitigation_strategies": [
        "safe_string_functions",
        "dynamic_analysis",
        "code_review",
        "static_analysis",
        "memory_safety_checks",
        "input_validation",
        "fuzzing",
        "bounds_checking",
        "secure_coding_practices"
      ],
      "code_differences": {
        "has_differences": true,
        "source_lines": 2,
        "target_lines": 2,
        "character_differences": 5730,
        "similarity_percentage": 9.701492537313433
      },
      "vulnerability_location": {
        "vulnerability_present": true,
        "fix_applied": true,
        "code_changed": true,
        "estimated_lines_changed": 0
      }
    },
    {
      "cve_id": "CVE-2016-10191",
      "cwe_id": "CWE-119",
      "cwe_name": "Buffer Overflow",
      "project": "FFmpeg",
      "severity": "critical",
      "weaponization_score": 9.0,
      "is_critical": true,
      "is_weaponizable": true,
      "is_high_priority_project": true,
      "vulnerable_code": "CWE-119 static int rtmp_packet_read_one_chunk ( URLContext * h , RTMPPacket * p , int chunk_size , RTMPPacket * * prev_pkt_ptr , int * nb_prev_pkt , uint8_t hdr ) { uint8_t buf [ 16 ] ; int channel_id , timestamp , size ; uint32_t ts_field ; uint32_t extra = 0 ; enum RTMPPacketType type ; int written = 0 ; int ret , toread ; RTMPPacket * prev_pkt ; written ++ ; channel_id = hdr & 0x3F ; if ( channel_id < 2 ) { buf [ 1 ] = 0 ; if ( ffurl_read_complete ( h , buf , channel_id + 1 ) != channel_id + 1 ) return AVERROR ( EIO ) ; written += channel_id + 1 ; channel_id = AV_RL16 ( buf ) + 64 ; } if ( ( ret = ff_rtmp_check_alloc_array ( prev_pkt_ptr , nb_prev_pkt , channel_id ) ) < 0 ) return ret ; prev_pkt = * prev_pkt_ptr ; size = prev_pkt [ channel_id ] . size ; type = prev_pkt [ channel_id ] . type ; extra = prev_pkt [ channel_id ] . extra ; hdr >>= 6 ; if ( hdr == RTMP_PS_ONEBYTE ) { ts_field = prev_pkt [ channel_id ] . ts_field ; } else { if ( ffurl_read_complete ( h , buf , 3 ) != 3 ) return AVERROR ( EIO ) ; written += 3 ; ts_field = AV_RB24 ( buf ) ; if ( hdr != RTMP_PS_FOURBYTES ) { if ( ffurl_read_complete ( h , buf , 3 ) != 3 ) return AVERROR ( EIO ) ; written += 3 ; size = AV_RB24 ( buf ) ; if ( ffurl_read_complete ( h , buf , 1 ) != 1 ) return AVERROR ( EIO ) ; written ++ ; type = buf [ 0 ] ; if ( hdr == RTMP_PS_TWELVEBYTES ) { if ( ffurl_read_complete ( h , buf , 4 ) != 4 ) return AVERROR ( EIO ) ; written += 4 ; extra = AV_RL32 ( buf ) ; } } } if ( ts_field == 0xFFFFFF ) { if ( ffurl_read_complete ( h , buf , 4 ) != 4 ) return AVERROR ( EIO ) ; timestamp = AV_RB32 ( buf ) ; } else { timestamp = ts_field ; } if ( hdr != RTMP_PS_TWELVEBYTES ) timestamp += prev_pkt [ channel_id ] . timestamp ; <S2SV_StartBug> if ( ! prev_pkt [ channel_id ] . read ) { <S2SV_EndBug> if ( ( ret = ff_rtmp_packet_create ( p , channel_id , type , timestamp , size ) ) < 0 ) return ret ; p -> read = written ; p -> offset = 0 ; prev_pkt [ channel_id ] . ts_field = ts_field ; prev_pkt [ channel_id ] . timestamp = timestamp ; } else { RTMPPacket * prev = & prev_pkt [ channel_id ] ; p -> data = prev -> data ; p -> size = prev -> size ; p -> channel_id = prev -> channel_id ; p -> type = prev -> type ; p -> ts_field = prev -> ts_field ; p -> extra = prev -> extra ; p -> offset = prev -> offset ; p -> read = prev -> read + written ; p -> timestamp = prev -> timestamp ; prev -> data = NULL ; } p -> extra = extra ; prev_pkt [ channel_id ] . channel_id = channel_id ; prev_pkt [ channel_id ] . type = type ; prev_pkt [ channel_id ] . size = size ; prev_pkt [ channel_id ] . extra = extra ; size = size - p -> offset ; toread = FFMIN ( size , chunk_size ) ; if ( ffurl_read_complete ( h , p -> data + p -> offset , toread ) != toread ) { ff_rtmp_packet_destroy ( p ) ; return AVERROR ( EIO ) ; } size -= toread ; p -> read += toread ; p -> offset += toread ; if ( size > 0 ) { RTMPPacket * prev = & prev_pkt [ channel_id ] ; prev -> data = p -> data ; prev -> read = p -> read ; prev -> offset = p -> offset ; p -> data = NULL ; return AVERROR ( EAGAIN ) ; } prev_pkt [ channel_id ] . read = 0 ; return p -> read ; }\n",
      "fixed_code": "<S2SV_ModStart> ; if ( prev_pkt [ channel_id ] . read && size != prev_pkt [ channel_id ] . size ) { av_log ( NULL , AV_LOG_ERROR , \"RTMP<S2SV_blank>packet<S2SV_blank>size<S2SV_blank>mismatch<S2SV_blank>%d<S2SV_blank>!=<S2SV_blank>%d\\\\n\" , size , prev_pkt [ channel_id ] . size ) ; ff_rtmp_packet_destroy ( & prev_pkt [ channel_id ] ) ; prev_pkt [ channel_id ] . read = 0 ; } if (\n",
      "source_code_length": 3129,
      "target_code_length": 380,
      "vulnerability_patterns": {
        "integer_overflow": 10,
        "null_pointer": 35,
        "total": 45
      },
      "total_patterns": 45,
      "original_address": "https://github.com/FFmpeg/FFmpeg/commit/7d57ca4d9a75562fa32e40766211de150f8b3ee7",
      "discovery_time": "2017-02-09T15:59Z",
      "project_commit_id": "FFmpeg@FFmpeg/7d57ca4d9a75562fa32e40766211de150f8b3ee7",
      "extraction_time": "2025-08-31T15:41:49.180265",
      "label": 1,
      "vulnerability_type": "buffer_overflow",
      "difficulty_level": "expert",
      "risk_factors": [
        "system_crash",
        "memory_corruption",
        "critical_infrastructure",
        "arbitrary_code_execution"
      ],
      "attack_vectors": [
        "memory_manipulation",
        "malicious_input",
        "code_analysis",
        "buffer_overflow",
        "reverse_engineering",
        "fuzzing"
      ],
      "mitigation_strategies": [
        "safe_string_functions",
        "dynamic_analysis",
        "code_review",
        "static_analysis",
        "memory_safety_checks",
        "input_validation",
        "fuzzing",
        "bounds_checking",
        "secure_coding_practices"
      ],
      "code_differences": {
        "has_differences": true,
        "source_lines": 2,
        "target_lines": 2,
        "character_differences": 2749,
        "similarity_percentage": 21.978021978021978
      },
      "vulnerability_location": {
        "vulnerability_present": true,
        "fix_applied": true,
        "code_changed": true,
        "estimated_lines_changed": 0
      }
    },
    {
      "cve_id": "CVE-2020-23930",
      "cwe_id": "CWE-476",
      "cwe_name": "NULL Pointer Dereference",
      "project": "gpac",
      "severity": "critical",
      "weaponization_score": 9.0,
      "is_critical": true,
      "is_weaponizable": true,
      "is_high_priority_project": false,
      "vulnerable_code": "CWE-476 int mp4boxMain ( int argc , char * * argv ) { u32 i , j ; const char * gpac_profile = \"0\" ; GF_Err e = GF_OK ; nb_tsel_acts = nb_add = nb_cat = nb_track_act = nb_sdp_ex = max_ptime = nb_meta_act = rtp_rate = major_brand = nb_alt_brand_add = nb_alt_brand_rem = car_dur = minor_version = 0 ; split_duration = 0.0 ; split_start = - 1.0 ; interleaving_time = 0 ; dash_duration = dash_subduration = 0.0 ; import_fps . num = import_fps . den = 0 ; import_flags = 0 ; split_size = 0 ; movie_time = 0 ; dump_nal = dump_saps = dump_saps_mode = force_new = 0 ; FullInter = HintInter = encode = do_scene_log = old_interleave = do_saf = do_hash = verbose = do_mpd_rip = merge_vtt_cues = get_nb_tracks = GF_FALSE ; # ifndef GPAC_DISABLE_SCENE_DUMP dump_mode = GF_SM_DUMP_NONE ; # endif Frag = force_ocr = remove_sys_tracks = agg_samples = remove_hint = keep_sys_tracks = remove_root_od = single_group = clean_groups = compress_moov = GF_FALSE ; conv_type = HintIt = needSave = print_sdp = regular_iod = dump_std = open_edit = dump_rtp = dump_cr = dump_srt = dump_ttxt = dump_m2ts = dump_cart = import_subtitle = force_cat = pack_wgt = dash_live = GF_FALSE ; no_fragments_defaults = GF_FALSE ; single_traf_per_moof = hls_clock = GF_FALSE ; tfdt_per_traf = GF_FALSE ; dump_nal_type = 0 ; dump_isom = 0 ; print_info = 0 ; align_cat = GF_TRUE ; subsegs_per_sidx = 0 ; track_dump_type = 0 ; crypt = 0 ; time_shift_depth = 0 ; file = NULL ; itunes_tags = pes_dump = NULL ; seg_name = dash_ctx_file = NULL ; compress_top_boxes = NULL ; initial_moof_sn = 0 ; initial_tfdt = 0 ; # ifndef GPAC_DISABLE_SCENE_ENCODER memset ( & smenc_opts , 0 , sizeof ( smenc_opts ) ) ; # endif trackID = stat_level = hint_flags = 0 ; program_number = 0 ; info_track_id = 0 ; do_flat = 0 ; inName = outName = mediaSource = input_ctx = output_ctx = drm_file = avi2raw = cprt = chap_file = pack_file = raw_cat = high_dynamc_range_filename = use_init_seg = box_patch_filename = NULL ; # ifndef GPAC_DISABLE_SWF_IMPORT swf_flags = GF_SM_SWF_SPLIT_TIMELINE ; # endif swf_flatten_angle = 0.0f ; tmpdir = NULL ; for ( i = 1 ; i < ( u32 ) argc ; i ++ ) { if ( ! strcmp ( argv [ i ] , \"-mem-track\" ) || ! strcmp ( argv [ i ] , \"-mem-track-stack\" ) ) { # ifdef GPAC_MEMORY_TRACKING mem_track = ! strcmp ( argv [ i ] , \"-mem-track-stack\" ) ? GF_MemTrackerBackTrace : GF_MemTrackerSimple ; # else fprintf ( stderr , \"WARNING<S2SV_blank>-<S2SV_blank>GPAC<S2SV_blank>not<S2SV_blank>compiled<S2SV_blank>with<S2SV_blank>Memory<S2SV_blank>Tracker<S2SV_blank>-<S2SV_blank>ignoring<S2SV_blank>\\\\\"%s\\\\\"\\\\n\" , argv [ i ] ) ; # endif break ; } else if ( ! strcmp ( argv [ i ] , \"-p\" ) ) { if ( i + 1 < ( u32 ) argc ) gpac_profile = argv [ i + 1 ] ; else { fprintf ( stderr , \"Bad<S2SV_blank>argument<S2SV_blank>for<S2SV_blank>-p,<S2SV_blank>expecting<S2SV_blank>profile<S2SV_blank>name<S2SV_blank>but<S2SV_blank>no<S2SV_blank>more<S2SV_blank>args\\\\n\" ) ; return 1 ; } } else if ( ! strncmp ( argv [ i ] , \"-p=\" , 3 ) ) gpac_profile = argv [ i ] + 3 ; } # ifdef _TWO_DIGIT_EXPONENT _set_output_format ( _TWO_DIGIT_EXPONENT ) ; # endif gf_sys_init ( mem_track , gpac_profile ) ; if ( argc < 2 ) { fprintf ( stderr , \"Not<S2SV_blank>enough<S2SV_blank>arguments<S2SV_blank>-<S2SV_blank>check<S2SV_blank>usage<S2SV_blank>with<S2SV_blank>-h\\\\n\" \"MP4Box<S2SV_blank>-<S2SV_blank>GPAC<S2SV_blank>version<S2SV_blank>%s\\\\n\" \"%s\\\\n\" , gf_gpac_version ( ) , gf_gpac_copyright ( ) ) ; gf_sys_close ( ) ; return 0 ; } helpout = stdout ; i = mp4box_parse_args ( argc , argv ) ; if ( i ) { return mp4box_cleanup ( i - 1 ) ; } if ( ! inName && dump_std ) inName = \"std\" ; if ( ! inName ) { if ( has_next_arg ) { fprintf ( stderr , \"Broken<S2SV_blank>argument<S2SV_blank>specifier<S2SV_blank>or<S2SV_blank>file<S2SV_blank>name<S2SV_blank>missing<S2SV_blank>-<S2SV_blank>check<S2SV_blank>usage<S2SV_blank>with<S2SV_blank>-h\\\\n\" ) ; } else { PrintUsage ( ) ; } return mp4box_cleanup ( 1 ) ; } if ( ! strcmp ( inName , \"std\" ) ) dump_std = 2 ; if ( ! strcmp ( inName , \"stdb\" ) ) { inName = \"std\" ; dump_std = 1 ; } if ( ! interleaving_time ) { if ( dash_duration ) interleaving_time = dash_duration ; else if ( ! do_flat ) { interleaving_time = DEFAULT_INTERLEAVING_IN_SEC ; } } if ( dump_std ) outName = \"std\" ; if ( dump_std == 2 ) { # ifdef WIN32 if ( _setmode ( _fileno ( stdout ) , _O_BINARY ) == - 1 ) # else if ( freopen ( NULL , \"wb\" , stdout ) == NULL ) # endif { fprintf ( stderr , \"Fatal<S2SV_blank>error:<S2SV_blank>cannot<S2SV_blank>reopen<S2SV_blank>stdout<S2SV_blank>in<S2SV_blank>binary<S2SV_blank>mode.\\\\n\" ) ; return mp4box_cleanup ( 1 ) ; } } # if ! defined ( GPAC_DISABLE_STREAMING ) && ! defined ( GPAC_DISABLE_SENG ) if ( live_scene ) { int ret = live_session ( argc , argv ) ; return mp4box_cleanup ( ret ) ; } # endif GF_LOG_Level level = verbose ? GF_LOG_DEBUG : GF_LOG_INFO ; gf_log_set_tool_level ( GF_LOG_CONTAINER , level ) ; gf_log_set_tool_level ( GF_LOG_SCENE , level ) ; gf_log_set_tool_level ( GF_LOG_PARSER , level ) ; gf_log_set_tool_level ( GF_LOG_AUTHOR , level ) ; gf_log_set_tool_level ( GF_LOG_CODING , level ) ; gf_log_set_tool_level ( GF_LOG_DASH , level ) ; # ifdef GPAC_MEMORY_TRACKING if ( mem_track ) gf_log_set_tool_level ( GF_LOG_MEMORY , level ) ; # endif e = gf_sys_set_args ( argc , ( const char * * ) argv ) ; if ( e ) { fprintf ( stderr , \"Error<S2SV_blank>assigning<S2SV_blank>libgpac<S2SV_blank>arguments:<S2SV_blank>%s\\\\n\" , gf_error_to_string ( e ) ) ; return mp4box_cleanup ( 1 ) ; } if ( raw_cat ) { char chunk [ 4096 ] ; FILE * fin , * fout ; s64 to_copy , done ; fin = gf_fopen ( raw_cat , \"rb\" ) ; if ( ! fin ) return mp4box_cleanup ( 1 ) ; fout = gf_fopen ( inName , \"a+b\" ) ; if ( ! fout ) { gf_fclose ( fin ) ; return mp4box_cleanup ( 1 ) ; } gf_fseek ( fin , 0 , SEEK_END ) ; to_copy = gf_ftell ( fin ) ; gf_fseek ( fin , 0 , SEEK_SET ) ; done = 0 ; while ( 1 ) { u32 nb_bytes = ( u32 ) gf_fread ( chunk , 4096 , fin ) ; gf_fwrite ( chunk , nb_bytes , fout ) ; done += nb_bytes ; fprintf ( stderr , \"Appending<S2SV_blank>file<S2SV_blank>%s<S2SV_blank>-<S2SV_blank>%02.2f<S2SV_blank>done\\\\r\" , raw_cat , 100.0 * done / to_copy ) ; if ( done >= to_copy ) break ; } gf_fclose ( fin ) ; gf_fclose ( fout ) ; return mp4box_cleanup ( 0 ) ; } if ( compress_top_boxes ) { if ( size_top_box ) { u64 top_size = do_size_top_boxes ( inName , compress_top_boxes , size_top_box ) ; fprintf ( stdout , LLU \"\\\\n\" , top_size ) ; return mp4box_cleanup ( e ? 1 : 0 ) ; } else { e = do_compress_top_boxes ( inName , outName , compress_top_boxes , comp_top_box_version , comp_lzma ) ; return mp4box_cleanup ( e ? 1 : 0 ) ; } } if ( do_mpd_rip ) { e = rip_mpd ( inName , outName ) ; return mp4box_cleanup ( e ? 1 : 0 ) ; } # ifndef GPAC_DISABLE_CORE_TOOLS if ( do_wget != NULL ) { e = gf_dm_wget ( do_wget , inName , 0 , 0 , NULL ) ; if ( e != GF_OK ) { fprintf ( stderr , \"Cannot<S2SV_blank>retrieve<S2SV_blank>%s:<S2SV_blank>%s\\\\n\" , do_wget , gf_error_to_string ( e ) ) ; return mp4box_cleanup ( 1 ) ; } return mp4box_cleanup ( 0 ) ; } # endif if ( udp_dest ) { GF_Socket * sock = gf_sk_new ( GF_SOCK_TYPE_UDP ) ; u16 port = 2345 ; char * sep = strrchr ( udp_dest , ':' ) ; if ( sep ) { sep [ 0 ] = 0 ; port = atoi ( sep + 1 ) ; } e = gf_sk_bind ( sock , \"127.0.0.1\" , 0 , udp_dest , port , 0 ) ; if ( sep ) sep [ 0 ] = ':' ; if ( e ) fprintf ( stderr , \"Failed<S2SV_blank>to<S2SV_blank>bind<S2SV_blank>socket<S2SV_blank>to<S2SV_blank>%s:<S2SV_blank>%s\\\\n\" , udp_dest , gf_error_to_string ( e ) ) ; else { e = gf_sk_send ( sock , ( u8 * ) inName , ( u32 ) strlen ( inName ) ) ; if ( e ) fprintf ( stderr , \"Failed<S2SV_blank>to<S2SV_blank>send<S2SV_blank>datagram:<S2SV_blank>%s\\\\n\" , gf_error_to_string ( e ) ) ; } gf_sk_del ( sock ) ; return 0 ; } # ifndef GPAC_DISABLE_MPD if ( do_mpd ) { Bool remote = GF_FALSE ; GF_MPD * mpd ; char * mpd_base_url = NULL ; if ( ! strnicmp ( inName , \"http://\" , 7 ) || ! strnicmp ( inName , \"https://\" , 8 ) ) { # if ! defined ( GPAC_DISABLE_CORE_TOOLS ) e = gf_dm_wget ( inName , \"tmp_main.m3u8\" , 0 , 0 , & mpd_base_url ) ; if ( e != GF_OK ) { fprintf ( stderr , \"Cannot<S2SV_blank>retrieve<S2SV_blank>M3U8<S2SV_blank>(%s):<S2SV_blank>%s\\\\n\" , inName , gf_error_to_string ( e ) ) ; if ( mpd_base_url ) gf_free ( mpd_base_url ) ; return mp4box_cleanup ( 1 ) ; } remote = GF_TRUE ; # else gf_free ( mpd_base_url ) ; fprintf ( stderr , \"HTTP<S2SV_blank>Downloader<S2SV_blank>disabled<S2SV_blank>in<S2SV_blank>this<S2SV_blank>build\\\\n\" ) ; return mp4box_cleanup ( 1 ) ; # endif if ( outName ) strcpy ( outfile , outName ) ; else { const char * sep = gf_file_basename ( inName ) ; char * ext = gf_file_ext_start ( sep ) ; if ( ext ) ext [ 0 ] = 0 ; sprintf ( outfile , \"%s.mpd\" , sep ) ; if ( ext ) ext [ 0 ] = '.' ; } } else { if ( outName ) strcpy ( outfile , outName ) ; else { char * dst = strdup ( inName ) ; char * ext = strstr ( dst , \".m3u8\" ) ; if ( ext ) ext [ 0 ] = 0 ; sprintf ( outfile , \"%s.mpd\" , dst ) ; gf_free ( dst ) ; } } mpd = gf_mpd_new ( ) ; if ( ! mpd ) { e = GF_OUT_OF_MEM ; fprintf ( stderr , \"[DASH]<S2SV_blank>Error:<S2SV_blank>MPD<S2SV_blank>creation<S2SV_blank>problem<S2SV_blank>%s\\\\n\" , gf_error_to_string ( e ) ) ; mp4box_cleanup ( 1 ) ; } FILE * f = gf_fopen ( remote ? \"tmp_main.m3u8\" : inName , \"r\" ) ; u32 manif_type = 0 ; if ( f ) { char szDATA [ 1000 ] ; s32 read ; szDATA [ 999 ] = 0 ; read = ( s32 ) gf_fread ( szDATA , 999 , f ) ; if ( read < 0 ) read = 0 ; szDATA [ read ] = 0 ; gf_fclose ( f ) ; if ( strstr ( szDATA , \"SmoothStreamingMedia\" ) ) manif_type = 2 ; else if ( strstr ( szDATA , \"#EXTM3U\" ) ) manif_type = 1 ; } if ( manif_type == 1 ) { e = gf_m3u8_to_mpd ( remote ? \"tmp_main.m3u8\" : inName , mpd_base_url ? mpd_base_url : inName , outfile , 0 , \"video/mp2t\" , GF_TRUE , use_url_template , segment_timeline , NULL , mpd , GF_TRUE , GF_TRUE ) ; } else if ( manif_type == 2 ) { e = gf_mpd_smooth_to_mpd ( remote ? \"tmp_main.m3u8\" : inName , mpd , mpd_base_url ? mpd_base_url : inName ) ; } else { e = GF_NOT_SUPPORTED ; } if ( ! e ) gf_mpd_write_file ( mpd , outfile ) ; if ( mpd ) gf_mpd_del ( mpd ) ; if ( mpd_base_url ) gf_free ( mpd_base_url ) ; if ( remote ) { gf_file_delete ( \"tmp_main.m3u8\" ) ; } if ( e != GF_OK ) { fprintf ( stderr , \"Error<S2SV_blank>converting<S2SV_blank>%s<S2SV_blank>(%s)<S2SV_blank>to<S2SV_blank>MPD<S2SV_blank>(%s):<S2SV_blank>%s\\\\n\" , ( manif_type == 1 ) ? \"HLS\" : \"Smooth\" , inName , outfile , gf_error_to_string ( e ) ) ; return mp4box_cleanup ( 1 ) ; } else { fprintf ( stderr , \"Done<S2SV_blank>converting<S2SV_blank>%s<S2SV_blank>(%s)<S2SV_blank>to<S2SV_blank>MPD<S2SV_blank>(%s)\\\\n\" , ( manif_type == 1 ) ? \"HLS\" : \"Smooth\" , inName , outfile ) ; return mp4box_cleanup ( 0 ) ; } } # endif if ( dash_duration && ! nb_dash_inputs ) { dash_inputs = set_dash_input ( dash_inputs , inName , & nb_dash_inputs ) ; } if ( do_saf && ! encode ) { switch ( get_file_type_by_ext ( inName ) ) { case GF_FILE_TYPE_BT_WRL_X3DV : case GF_FILE_TYPE_XMT_X3D : case GF_FILE_TYPE_SVG : encode = GF_TRUE ; break ; case GF_FILE_TYPE_NOT_SUPPORTED : case GF_FILE_TYPE_ISO_MEDIA : case GF_FILE_TYPE_SWF : case GF_FILE_TYPE_LSR_SAF : break ; } } # ifndef GPAC_DISABLE_SCENE_DUMP if ( dump_mode == GF_SM_DUMP_SVG ) { if ( strstr ( inName , \".srt\" ) || strstr ( inName , \".ttxt\" ) ) import_subtitle = 2 ; } # endif if ( import_subtitle && ! trackID ) { # ifndef GPAC_DISABLE_MEDIA_IMPORT GF_MediaImporter import ; file = gf_isom_open ( \"ttxt_convert\" , GF_ISOM_OPEN_WRITE , NULL ) ; if ( timescale && file ) gf_isom_set_timescale ( file , timescale ) ; memset ( & import , 0 , sizeof ( GF_MediaImporter ) ) ; import . dest = file ; import . in_name = inName ; e = gf_media_import ( & import ) ; if ( e ) { fprintf ( stderr , \"Error<S2SV_blank>importing<S2SV_blank>%s:<S2SV_blank>%s\\\\n\" , inName , gf_error_to_string ( e ) ) ; gf_isom_delete ( file ) ; gf_file_delete ( \"ttxt_convert\" ) ; return mp4box_cleanup ( 1 ) ; } strcpy ( outfile , inName ) ; if ( strchr ( outfile , '.' ) ) { while ( outfile [ strlen ( outfile ) - 1 ] != '.' ) outfile [ strlen ( outfile ) - 1 ] = 0 ; outfile [ strlen ( outfile ) - 1 ] = 0 ; } # ifndef GPAC_DISABLE_ISOM_DUMP dump_isom_timed_text ( file , gf_isom_get_track_id ( file , 1 ) , dump_std ? NULL : ( outName ? outName : outfile ) , outName ? GF_TRUE : GF_FALSE , GF_TRUE , ( import_subtitle == 2 ) ? GF_TEXTDUMPTYPE_SVG : ( dump_srt ? GF_TEXTDUMPTYPE_SRT : GF_TEXTDUMPTYPE_TTXT ) ) ; # endif gf_isom_delete ( file ) ; gf_file_delete ( \"ttxt_convert\" ) ; if ( e ) { fprintf ( stderr , \"Error<S2SV_blank>converting<S2SV_blank>%s:<S2SV_blank>%s\\\\n\" , inName , gf_error_to_string ( e ) ) ; return mp4box_cleanup ( 1 ) ; } return mp4box_cleanup ( 0 ) ; # else fprintf ( stderr , \"Feature<S2SV_blank>not<S2SV_blank>supported\\\\n\" ) ; return mp4box_cleanup ( 1 ) ; # endif } # if ! defined ( GPAC_DISABLE_MEDIA_IMPORT ) && ! defined ( GPAC_DISABLE_ISOM_WRITE ) if ( nb_add || nb_cat ) { u32 ipass , nb_pass = 1 ; char * mux_args = NULL ; GF_FilterSession * fs = NULL ; if ( nb_add ) { GF_ISOOpenMode open_mode = GF_ISOM_OPEN_EDIT ; if ( force_new ) { open_mode = ( do_flat || ( force_new == 2 ) ) ? GF_ISOM_OPEN_WRITE : GF_ISOM_WRITE_EDIT ; } else { FILE * test = gf_fopen ( inName , \"rb\" ) ; if ( ! test ) { open_mode = ( do_flat ) ? GF_ISOM_OPEN_WRITE : GF_ISOM_WRITE_EDIT ; if ( ! outName ) outName = inName ; } else { gf_fclose ( test ) ; if ( ! gf_isom_probe_file ( inName ) ) { open_mode = ( do_flat ) ? GF_ISOM_OPEN_WRITE : GF_ISOM_WRITE_EDIT ; if ( ! outName ) outName = inName ; } } } open_edit = do_flat ? GF_FALSE : GF_TRUE ; file = gf_isom_open ( inName , open_mode , tmpdir ) ; if ( ! file ) { fprintf ( stderr , \"Cannot<S2SV_blank>open<S2SV_blank>destination<S2SV_blank>file<S2SV_blank>%s:<S2SV_blank>%s\\\\n\" , inName , gf_error_to_string ( gf_isom_last_error ( NULL ) ) ) ; return mp4box_cleanup ( 1 ) ; } if ( freeze_box_order ) gf_isom_freeze_order ( file ) ; } if ( do_flat && interleaving_time ) { char szSubArg [ 100 ] ; gf_isom_set_storage_mode ( file , GF_ISOM_STORE_FASTSTART ) ; do_flat = 2 ; nb_pass = 2 ; fs = gf_fs_new_defaults ( 0 ) ; if ( ! fs ) { fprintf ( stderr , \"Error<S2SV_blank>creating<S2SV_blank>filter<S2SV_blank>session\\\\n\" ) ; gf_isom_delete ( file ) ; return mp4box_cleanup ( 1 ) ; } gf_dynstrcat ( & mux_args , \"mp4mx:importer:store=fstart\" , \":\" ) ; sprintf ( szSubArg , \"file=%p\" , file ) ; gf_dynstrcat ( & mux_args , szSubArg , \":\" ) ; sprintf ( szSubArg , \"cdur=%g\" , interleaving_time ) ; gf_dynstrcat ( & mux_args , szSubArg , \":\" ) ; } for ( ipass = 0 ; ipass < nb_pass ; ipass ++ ) { u32 tk_idx = 1 ; for ( i = 0 ; i < ( u32 ) argc ; i ++ ) { char * margs = NULL ; if ( ! strcmp ( argv [ i ] , \"-add\" ) ) { char * src = argv [ i + 1 ] ; while ( src ) { char * loc_src = src ; char * sep = NULL ; while ( 1 ) { char * opt_sep ; sep = strchr ( loc_src , '+' ) ; if ( ! sep ) break ; sep [ 0 ] = 0 ; if ( strstr ( src , \"://\" ) ) break ; opt_sep = gf_url_colon_suffix ( src ) ; if ( opt_sep ) opt_sep [ 0 ] = 0 ; if ( gf_file_exists ( src ) ) { if ( opt_sep ) opt_sep [ 0 ] = ':' ; break ; } if ( opt_sep ) opt_sep [ 0 ] = ':' ; sep [ 0 ] = '+' ; loc_src = sep + 1 ; } e = import_file ( file , src , import_flags , import_fps , agg_samples , fs , ( fs && ( ipass == 0 ) ) ? & margs : NULL , tk_idx ) ; tk_idx ++ ; if ( margs ) { gf_dynstrcat ( & mux_args , margs , \":\" ) ; gf_free ( margs ) ; } if ( e ) { fprintf ( stderr , \"Error<S2SV_blank>importing<S2SV_blank>%s:<S2SV_blank>%s\\\\n\" , argv [ i + 1 ] , gf_error_to_string ( e ) ) ; gf_isom_delete ( file ) ; if ( fs ) gf_fs_del ( fs ) ; return mp4box_cleanup ( 1 ) ; } if ( sep ) { sep [ 0 ] = '+' ; src = sep + 1 ; } else { break ; } } i ++ ; } else if ( ! strcmp ( argv [ i ] , \"-cat\" ) || ! strcmp ( argv [ i ] , \"-catx\" ) || ! strcmp ( argv [ i ] , \"-catpl\" ) ) { if ( nb_pass == 2 ) { fprintf ( stderr , \"Cannot<S2SV_blank>cat<S2SV_blank>files<S2SV_blank>when<S2SV_blank>using<S2SV_blank>-newfs<S2SV_blank>mode\\\\n\" ) ; return mp4box_cleanup ( 1 ) ; } if ( ! file ) { u8 open_mode = GF_ISOM_OPEN_EDIT ; if ( force_new ) { open_mode = ( do_flat ) ? GF_ISOM_OPEN_WRITE : GF_ISOM_WRITE_EDIT ; } else { FILE * test = gf_fopen ( inName , \"rb\" ) ; if ( ! test ) { open_mode = ( do_flat ) ? GF_ISOM_OPEN_WRITE : GF_ISOM_WRITE_EDIT ; if ( ! outName ) outName = inName ; } else gf_fclose ( test ) ; } open_edit = GF_TRUE ; file = gf_isom_open ( inName , open_mode , tmpdir ) ; if ( ! file ) { fprintf ( stderr , \"Cannot<S2SV_blank>open<S2SV_blank>destination<S2SV_blank>file<S2SV_blank>%s:<S2SV_blank>%s\\\\n\" , inName , gf_error_to_string ( gf_isom_last_error ( NULL ) ) ) ; return mp4box_cleanup ( 1 ) ; } } e = cat_isomedia_file ( file , argv [ i + 1 ] , import_flags , import_fps , agg_samples , tmpdir , force_cat , align_cat , ! strcmp ( argv [ i ] , \"-catx\" ) ? GF_TRUE : GF_FALSE , ! strcmp ( argv [ i ] , \"-catpl\" ) ? GF_TRUE : GF_FALSE ) ; if ( e ) { fprintf ( stderr , \"Error<S2SV_blank>appending<S2SV_blank>%s:<S2SV_blank>%s\\\\n\" , argv [ i + 1 ] , gf_error_to_string ( e ) ) ; gf_isom_delete ( file ) ; return mp4box_cleanup ( 1 ) ; } i ++ ; } } if ( ( nb_pass == 2 ) && ! ipass ) { GF_Filter * mux_filter = gf_fs_load_filter ( fs , mux_args , NULL ) ; gf_free ( mux_args ) ; if ( ! mux_filter ) { fprintf ( stderr , \"Error<S2SV_blank>loadin<S2SV_blank>isobmff<S2SV_blank>mux<S2SV_blank>filter\\\\n\" ) ; gf_isom_delete ( file ) ; gf_fs_del ( fs ) ; return mp4box_cleanup ( 1 ) ; } e = gf_fs_run ( fs ) ; if ( e == GF_EOS ) e = GF_OK ; if ( ! e ) e = gf_fs_get_last_connect_error ( fs ) ; if ( ! e ) e = gf_fs_get_last_process_error ( fs ) ; if ( e ) { fprintf ( stderr , \"Error<S2SV_blank>importing<S2SV_blank>sources:<S2SV_blank>%s\\\\n\" , gf_error_to_string ( e ) ) ; gf_isom_delete ( file ) ; gf_fs_del ( fs ) ; return mp4box_cleanup ( 1 ) ; } } } if ( fs ) { if ( fs_dump_flags & 1 ) gf_fs_print_stats ( fs ) ; if ( fs_dump_flags & 2 ) gf_fs_print_connections ( fs ) ; gf_fs_del ( fs ) ; } # ifndef GPAC_DISABLE_AV_PARSERS if ( ! keep_sys_tracks ) remove_systems_tracks ( file ) ; # endif needSave = GF_TRUE ; } # endif # if ! defined ( GPAC_DISABLE_ISOM_WRITE ) && ! defined ( GPAC_DISABLE_SCENE_ENCODER ) && ! defined ( GPAC_DISABLE_MEDIA_IMPORT ) else if ( chunk_mode ) { if ( ! inName ) { fprintf ( stderr , \"chunk<S2SV_blank>encoding<S2SV_blank>syntax:<S2SV_blank>[-outctx<S2SV_blank>outDump]<S2SV_blank>-inctx<S2SV_blank>inScene<S2SV_blank>auFile\\\\n\" ) ; return mp4box_cleanup ( 1 ) ; } e = EncodeFileChunk ( inName , outName ? outName : inName , input_ctx , output_ctx , tmpdir ) ; if ( e ) { fprintf ( stderr , \"Error<S2SV_blank>encoding<S2SV_blank>chunk<S2SV_blank>file<S2SV_blank>%s\\\\n\" , gf_error_to_string ( e ) ) ; return mp4box_cleanup ( 1 ) ; } goto exit ; } # endif else if ( encode ) { # if ! defined ( GPAC_DISABLE_ISOM_WRITE ) && ! defined ( GPAC_DISABLE_SCENE_ENCODER ) && ! defined ( GPAC_DISABLE_MEDIA_IMPORT ) FILE * logs = NULL ; if ( do_scene_log ) { char alogfile [ GF_MAX_PATH ] ; strcpy ( alogfile , inName ) ; if ( strchr ( alogfile , '.' ) ) { while ( alogfile [ strlen ( alogfile ) - 1 ] != '.' ) alogfile [ strlen ( alogfile ) - 1 ] = 0 ; alogfile [ strlen ( alogfile ) - 1 ] = 0 ; } strcat ( alogfile , \"_enc.logs\" ) ; logs = gf_fopen ( alogfile , \"wt\" ) ; } strcpy ( outfile , outName ? outName : inName ) ; if ( strchr ( outfile , '.' ) ) { while ( outfile [ strlen ( outfile ) - 1 ] != '.' ) outfile [ strlen ( outfile ) - 1 ] = 0 ; outfile [ strlen ( outfile ) - 1 ] = 0 ; } strcat ( outfile , \".mp4\" ) ; file = gf_isom_open ( outfile , GF_ISOM_WRITE_EDIT , tmpdir ) ; smenc_opts . mediaSource = mediaSource ? mediaSource : outfile ; e = EncodeFile ( inName , file , & smenc_opts , logs ) ; if ( logs ) gf_fclose ( logs ) ; if ( e ) goto err_exit ; needSave = GF_TRUE ; if ( do_saf ) { needSave = GF_FALSE ; open_edit = GF_FALSE ; } # endif } # ifndef GPAC_DISABLE_ISOM_WRITE else if ( pack_file ) { char * fileName = gf_url_colon_suffix ( pack_file ) ; if ( fileName && ( ( fileName - pack_file ) == 4 ) ) { fileName [ 0 ] = 0 ; file = package_file ( fileName + 1 , pack_file , tmpdir , pack_wgt ) ; fileName [ 0 ] = ':' ; } else { file = package_file ( pack_file , NULL , tmpdir , pack_wgt ) ; if ( ! file ) { fprintf ( stderr , \"Failed<S2SV_blank>to<S2SV_blank>package<S2SV_blank>file\\\\n\" ) ; return mp4box_cleanup ( 1 ) ; } } if ( ! outName ) outName = inName ; needSave = GF_TRUE ; open_edit = GF_TRUE ; } # endif if ( dash_duration ) { Bool del_file = GF_FALSE ; char szMPD [ GF_MAX_PATH ] , * sep ; char szStateFile [ GF_MAX_PATH ] ; Bool dyn_state_file = GF_FALSE ; u32 do_abort = 0 ; GF_DASHSegmenter * dasher = NULL ; if ( crypt ) { fprintf ( stderr , \"MP4Box<S2SV_blank>cannot<S2SV_blank>crypt<S2SV_blank>and<S2SV_blank>DASH<S2SV_blank>on<S2SV_blank>the<S2SV_blank>same<S2SV_blank>pass.<S2SV_blank>Please<S2SV_blank>encrypt<S2SV_blank>your<S2SV_blank>content<S2SV_blank>first.\\\\n\" ) ; return mp4box_cleanup ( 1 ) ; } strcpy ( outfile , outName ? outName : gf_url_get_resource_name ( inName ) ) ; sep = strrchr ( outfile , '.' ) ; if ( sep ) sep [ 0 ] = 0 ; if ( ! outName ) strcat ( outfile , \"_dash\" ) ; strcpy ( szMPD , outfile ) ; if ( outName && sep ) { sep [ 0 ] = '.' ; strcat ( szMPD , sep ) ; } else { strcat ( szMPD , \".mpd\" ) ; } if ( ( dash_subduration > 0 ) && ( dash_duration > dash_subduration ) ) { fprintf ( stderr , \"Warning:<S2SV_blank>-subdur<S2SV_blank>parameter<S2SV_blank>(%g<S2SV_blank>s)<S2SV_blank>should<S2SV_blank>be<S2SV_blank>greater<S2SV_blank>than<S2SV_blank>segment<S2SV_blank>duration<S2SV_blank>(%g<S2SV_blank>s),<S2SV_blank>using<S2SV_blank>segment<S2SV_blank>duration<S2SV_blank>instead\\\\n\" , dash_subduration , dash_duration ) ; dash_subduration = dash_duration ; } if ( dash_mode && dash_live ) fprintf ( stderr , \"Live<S2SV_blank>DASH-ing<S2SV_blank>-<S2SV_blank>press<S2SV_blank>\\'q\\'<S2SV_blank>to<S2SV_blank>quit,<S2SV_blank>\\'s\\'<S2SV_blank>to<S2SV_blank>save<S2SV_blank>context<S2SV_blank>and<S2SV_blank>quit\\\\n\" ) ; if ( ! dash_ctx_file && dash_live ) { u32 r1 ; u64 add = ( u64 ) ( intptr_t ) & dasher ; add ^= gf_net_get_utc ( ) ; r1 = ( u32 ) add ^ ( u32 ) ( add / 0xFFFFFFFF ) ; r1 ^= gf_rand ( ) ; sprintf ( szStateFile , \"%s/dasher_%X.xml\" , gf_get_default_cache_directory ( ) , r1 ) ; dash_ctx_file = szStateFile ; dyn_state_file = GF_TRUE ; } else if ( dash_ctx_file ) { if ( force_new ) gf_file_delete ( dash_ctx_file ) ; } if ( dash_profile == GF_DASH_PROFILE_AUTO ) dash_profile = dash_mode ? GF_DASH_PROFILE_LIVE : GF_DASH_PROFILE_FULL ; if ( ! dash_mode ) { time_shift_depth = 0 ; mpd_update_time = 0 ; } else if ( ( dash_profile >= GF_DASH_PROFILE_MAIN ) && ! use_url_template && ! mpd_update_time ) { mpd_update_time = ( Double ) ( dash_subduration ? dash_subduration : dash_duration ) ; fprintf ( stderr , \"Using<S2SV_blank>default<S2SV_blank>MPD<S2SV_blank>refresh<S2SV_blank>of<S2SV_blank>%g<S2SV_blank>seconds\\\\n\" , mpd_update_time ) ; } if ( file && needSave ) { gf_isom_close ( file ) ; file = NULL ; del_file = GF_TRUE ; } dasher = gf_dasher_new ( szMPD , dash_profile , tmpdir , dash_scale , dash_ctx_file ) ; if ( ! dasher ) { return mp4box_cleanup ( 1 ) ; } e = gf_dasher_set_info ( dasher , dash_title , cprt , dash_more_info , dash_source , NULL ) ; if ( e ) { fprintf ( stderr , \"DASH<S2SV_blank>Error:<S2SV_blank>%s\\\\n\" , gf_error_to_string ( e ) ) ; gf_dasher_del ( dasher ) ; return mp4box_cleanup ( 1 ) ; } gf_dasher_set_start_date ( dasher , dash_start_date ) ; gf_dasher_set_location ( dasher , dash_source ) ; for ( i = 0 ; i < nb_mpd_base_urls ; i ++ ) { e = gf_dasher_add_base_url ( dasher , mpd_base_urls [ i ] ) ; if ( e ) { fprintf ( stderr , \"DASH<S2SV_blank>Error:<S2SV_blank>%s\\\\n\" , gf_error_to_string ( e ) ) ; gf_dasher_del ( dasher ) ; return mp4box_cleanup ( 1 ) ; } } if ( segment_timeline && ! use_url_template ) { fprintf ( stderr , \"DASH<S2SV_blank>Warning:<S2SV_blank>using<S2SV_blank>-segment-timeline<S2SV_blank>with<S2SV_blank>no<S2SV_blank>-url-template.<S2SV_blank>Forcing<S2SV_blank>URL<S2SV_blank>template.\\\\n\" ) ; use_url_template = GF_TRUE ; } e = gf_dasher_enable_url_template ( dasher , ( Bool ) use_url_template , seg_name , seg_ext , init_seg_ext ) ; if ( ! e ) e = gf_dasher_enable_segment_timeline ( dasher , segment_timeline ) ; if ( ! e ) e = gf_dasher_enable_single_segment ( dasher , single_segment ) ; if ( ! e ) e = gf_dasher_enable_single_file ( dasher , single_file ) ; if ( ! e ) e = gf_dasher_set_switch_mode ( dasher , bitstream_switching_mode ) ; if ( ! e ) e = gf_dasher_set_durations ( dasher , dash_duration , interleaving_time , dash_subduration ) ; if ( ! e ) e = gf_dasher_enable_rap_splitting ( dasher , seg_at_rap , frag_at_rap ) ; if ( ! e ) e = gf_dasher_set_segment_marker ( dasher , segment_marker ) ; if ( ! e ) e = gf_dasher_enable_sidx ( dasher , ( subsegs_per_sidx >= 0 ) ? 1 : 0 , ( u32 ) subsegs_per_sidx , daisy_chain_sidx , use_ssix ) ; if ( ! e ) e = gf_dasher_set_dynamic_mode ( dasher , dash_mode , mpd_update_time , time_shift_depth , mpd_live_duration ) ; if ( ! e ) e = gf_dasher_set_min_buffer ( dasher , min_buffer ) ; if ( ! e ) e = gf_dasher_set_ast_offset ( dasher , ast_offset_ms ) ; if ( ! e ) e = gf_dasher_enable_memory_fragmenting ( dasher , memory_frags ) ; if ( ! e ) e = gf_dasher_set_initial_isobmf ( dasher , initial_moof_sn , initial_tfdt ) ; if ( ! e ) e = gf_dasher_configure_isobmf_default ( dasher , no_fragments_defaults , pssh_mode , samplegroups_in_traf , single_traf_per_moof , tfdt_per_traf , mvex_after_traks , sdtp_in_traf ) ; if ( ! e ) e = gf_dasher_enable_utc_ref ( dasher , insert_utc ) ; if ( ! e ) e = gf_dasher_enable_real_time ( dasher , frag_real_time ) ; if ( ! e ) e = gf_dasher_set_content_protection_location_mode ( dasher , cp_location_mode ) ; if ( ! e ) e = gf_dasher_set_profile_extension ( dasher , dash_profile_extension ) ; if ( ! e ) e = gf_dasher_enable_cached_inputs ( dasher , no_cache ) ; if ( ! e ) e = gf_dasher_enable_loop_inputs ( dasher , ! no_loop ) ; if ( ! e ) e = gf_dasher_set_split_mode ( dasher , dash_split_mode ) ; if ( ! e ) e = gf_dasher_set_hls_clock ( dasher , hls_clock ) ; if ( ! e && dash_cues ) e = gf_dasher_set_cues ( dasher , dash_cues , strict_cues ) ; if ( ! e && fs_dump_flags ) e = gf_dasher_print_session_info ( dasher , fs_dump_flags ) ; for ( i = 0 ; i < nb_dash_inputs ; i ++ ) { if ( ! e ) e = gf_dasher_add_input ( dasher , & dash_inputs [ i ] ) ; } if ( e ) { fprintf ( stderr , \"DASH<S2SV_blank>Setup<S2SV_blank>Error:<S2SV_blank>%s\\\\n\" , gf_error_to_string ( e ) ) ; gf_dasher_del ( dasher ) ; return mp4box_cleanup ( 1 ) ; } dash_cumulated_time = 0 ; while ( 1 ) { if ( run_for && ( dash_cumulated_time >= run_for ) ) { fprintf ( stderr , \"Done<S2SV_blank>running,<S2SV_blank>computing<S2SV_blank>static<S2SV_blank>MPD\\\\n\" ) ; do_abort = 3 ; } dash_prev_time = gf_sys_clock ( ) ; if ( do_abort >= 2 ) { e = gf_dasher_set_dynamic_mode ( dasher , GF_DASH_DYNAMIC_LAST , 0 , time_shift_depth , mpd_live_duration ) ; } if ( ! e ) e = gf_dasher_process ( dasher ) ; if ( ! dash_live && ( e == GF_EOS ) ) { fprintf ( stderr , \"Nothing<S2SV_blank>to<S2SV_blank>dash,<S2SV_blank>too<S2SV_blank>early<S2SV_blank>...\\\\n\" ) ; e = GF_OK ; } if ( do_abort ) break ; if ( dash_live && ( e == GF_IO_ERR ) ) { fprintf ( stderr , \"Error<S2SV_blank>dashing<S2SV_blank>file<S2SV_blank>(%s)<S2SV_blank>but<S2SV_blank>continuing<S2SV_blank>...\\\\n\" , gf_error_to_string ( e ) ) ; e = GF_OK ; } if ( e ) break ; if ( dash_live ) { u64 ms_in_session = 0 ; u32 slept = gf_sys_clock ( ) ; u32 sleep_for = gf_dasher_next_update_time ( dasher , & ms_in_session ) ; fprintf ( stderr , \"Next<S2SV_blank>generation<S2SV_blank>scheduled<S2SV_blank>in<S2SV_blank>%u<S2SV_blank>ms<S2SV_blank>(DASH<S2SV_blank>time<S2SV_blank>\" LLU \"<S2SV_blank>ms)\\\\r\" , sleep_for , ms_in_session ) ; if ( run_for && ( ms_in_session >= run_for ) ) { dash_cumulated_time = 1 + run_for ; continue ; } while ( 1 ) { if ( gf_prompt_has_input ( ) ) { char c = ( char ) gf_prompt_get_char ( ) ; if ( c == 'X' ) { do_abort = 1 ; break ; } if ( c == 'q' ) { do_abort = 2 ; break ; } if ( c == 's' ) { do_abort = 3 ; break ; } } if ( dash_mode == GF_DASH_DYNAMIC_DEBUG ) { break ; } if ( ! sleep_for ) break ; gf_sleep ( sleep_for / 10 ) ; sleep_for = gf_dasher_next_update_time ( dasher , NULL ) ; if ( sleep_for <= 1 ) { dash_now_time = gf_sys_clock ( ) ; dash_cumulated_time += ( dash_now_time - dash_prev_time ) ; fprintf ( stderr , \"Slept<S2SV_blank>for<S2SV_blank>%d<S2SV_blank>ms<S2SV_blank>before<S2SV_blank>generation,<S2SV_blank>dash<S2SV_blank>cumulated<S2SV_blank>time<S2SV_blank>%d\\\\n\" , dash_now_time - slept , dash_cumulated_time ) ; break ; } } } else { break ; } } gf_dasher_del ( dasher ) ; if ( ! run_for && dash_ctx_file && ( do_abort == 3 ) && ( dyn_state_file ) && ! gf_sys_is_test_mode ( ) ) { char szName [ 1024 ] ; fprintf ( stderr , \"Enter<S2SV_blank>file<S2SV_blank>name<S2SV_blank>to<S2SV_blank>save<S2SV_blank>dash<S2SV_blank>context:\\\\n\" ) ; if ( scanf ( \"%1023s\" , szName ) == 1 ) { gf_file_move ( dash_ctx_file , szName ) ; } } if ( e ) fprintf ( stderr , \"Error<S2SV_blank>DASHing<S2SV_blank>file:<S2SV_blank>%s\\\\n\" , gf_error_to_string ( e ) ) ; if ( file ) gf_isom_delete ( file ) ; if ( del_file ) gf_file_delete ( inName ) ; if ( e ) return mp4box_cleanup ( 1 ) ; goto exit ; } else if ( ! file && ! do_hash # ifndef GPAC_DISABLE_MEDIA_EXPORT && ! ( track_dump_type & GF_EXPORT_AVI_NATIVE ) # endif ) { FILE * st = gf_fopen ( inName , \"rb\" ) ; Bool file_exists = 0 ; GF_ISOOpenMode omode ; if ( st ) { file_exists = 1 ; gf_fclose ( st ) ; } switch ( get_file_type_by_ext ( inName ) ) { case 1 : omode = ( u8 ) ( force_new ? GF_ISOM_WRITE_EDIT : ( open_edit ? GF_ISOM_OPEN_EDIT : ( ( ( dump_isom > 0 ) || print_info ) ? GF_ISOM_OPEN_READ_DUMP : GF_ISOM_OPEN_READ ) ) ) ; if ( crypt ) { omode = GF_ISOM_OPEN_READ ; if ( use_init_seg ) file = gf_isom_open ( use_init_seg , GF_ISOM_OPEN_READ , tmpdir ) ; } if ( ! crypt && use_init_seg ) { file = gf_isom_open ( use_init_seg , GF_ISOM_OPEN_READ_DUMP , tmpdir ) ; if ( file ) { e = gf_isom_open_segment ( file , inName , 0 , 0 , 0 ) ; if ( e ) { fprintf ( stderr , \"Error<S2SV_blank>opening<S2SV_blank>segment<S2SV_blank>%s:<S2SV_blank>%s\\\\n\" , inName , gf_error_to_string ( e ) ) ; gf_isom_delete ( file ) ; file = NULL ; } } } if ( ! file ) file = gf_isom_open ( inName , omode , tmpdir ) ; if ( ! file && ( gf_isom_last_error ( NULL ) == GF_ISOM_INCOMPLETE_FILE ) && ! open_edit ) { u64 missing_bytes ; e = gf_isom_open_progressive ( inName , 0 , 0 , GF_FALSE , & file , & missing_bytes ) ; fprintf ( stderr , \"Truncated<S2SV_blank>file<S2SV_blank>-<S2SV_blank>missing<S2SV_blank>\" LLD \"<S2SV_blank>bytes\\\\n\" , missing_bytes ) ; } if ( ! file ) { if ( open_edit && nb_meta_act ) { file = gf_isom_open ( inName , GF_ISOM_WRITE_EDIT , tmpdir ) ; if ( ! outName && file ) outName = inName ; } if ( ! file ) { fprintf ( stderr , \"Error<S2SV_blank>opening<S2SV_blank>file<S2SV_blank>%s:<S2SV_blank>%s\\\\n\" , inName , gf_error_to_string ( gf_isom_last_error ( NULL ) ) ) ; return mp4box_cleanup ( 1 ) ; } } if ( freeze_box_order ) gf_isom_freeze_order ( file ) ; break ; case 2 : case 3 : case 4 : case 5 : break ; case 6 : # ifndef GPAC_DISABLE_SCENE_DUMP if ( ( dump_mode == GF_SM_DUMP_LASER ) || ( dump_mode == GF_SM_DUMP_SVG ) ) { break ; } # endif default : if ( ! open_edit && file_exists && ! gf_isom_probe_file ( inName ) && track_dump_type ) { } # ifndef GPAC_DISABLE_ISOM_WRITE else if ( ! open_edit && file_exists # ifndef GPAC_DISABLE_SCENE_DUMP && dump_mode == GF_SM_DUMP_NONE # endif ) { # ifndef GPAC_DISABLE_MEDIA_IMPORT if ( dvbhdemux ) { GF_MediaImporter import ; file = gf_isom_open ( \"ttxt_convert\" , GF_ISOM_OPEN_WRITE , NULL ) ; memset ( & import , 0 , sizeof ( GF_MediaImporter ) ) ; import . dest = file ; import . in_name = inName ; import . flags = GF_IMPORT_MPE_DEMUX ; e = gf_media_import ( & import ) ; if ( e ) { fprintf ( stderr , \"Error<S2SV_blank>importing<S2SV_blank>%s:<S2SV_blank>%s\\\\n\" , inName , gf_error_to_string ( e ) ) ; gf_isom_delete ( file ) ; gf_file_delete ( \"ttxt_convert\" ) ; return mp4box_cleanup ( 1 ) ; } } # endif if ( dump_m2ts ) { # ifndef GPAC_DISABLE_MPEG2TS dump_mpeg2_ts ( inName , pes_dump , program_number ) ; # endif } else if ( dump_timestamps ) { # ifndef GPAC_DISABLE_MPEG2TS dump_mpeg2_ts ( inName , pes_dump , program_number ) ; # endif # ifndef GPAC_DISABLE_CORE_TOOLS } else if ( do_bin_xml ) { xml_bs_to_bin ( inName , outName , dump_std ) ; # endif } else if ( do_hash ) { hash_file ( inName , dump_std ) ; } else if ( print_info ) { # ifndef GPAC_DISABLE_MEDIA_IMPORT convert_file_info ( inName , info_track_id ) ; # endif } else { fprintf ( stderr , \"Input<S2SV_blank>%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>an<S2SV_blank>MP4<S2SV_blank>file,<S2SV_blank>operation<S2SV_blank>not<S2SV_blank>allowed\\\\n\" , inName ) ; return mp4box_cleanup ( 1 ) ; } goto exit ; } # endif else if ( open_edit ) { file = gf_isom_open ( inName , GF_ISOM_WRITE_EDIT , tmpdir ) ; if ( ! outName && file ) outName = inName ; } else if ( ! file_exists ) { fprintf ( stderr , \"Error<S2SV_blank>creating<S2SV_blank>file<S2SV_blank>%s:<S2SV_blank>%s\\\\n\" , inName , gf_error_to_string ( GF_URL_ERROR ) ) ; return mp4box_cleanup ( 1 ) ; } else { fprintf ( stderr , \"Cannot<S2SV_blank>open<S2SV_blank>%s<S2SV_blank>-<S2SV_blank>extension<S2SV_blank>not<S2SV_blank>supported\\\\n\" , inName ) ; return mp4box_cleanup ( 1 ) ; } } } if ( high_dynamc_range_filename ) { e = parse_high_dynamc_range_xml_desc ( file , high_dynamc_range_filename ) ; if ( e ) goto err_exit ; } if ( file && keep_utc && open_edit ) { gf_isom_keep_utc_times ( file , 1 ) ; } strcpy ( outfile , outName ? outName : inName ) ; { char * szExt = gf_file_ext_start ( outfile ) ; if ( szExt ) { if ( ! stricmp ( szExt , \".3gp\" ) || ! stricmp ( szExt , \".3gpp\" ) || ! stricmp ( szExt , \".3g2\" ) ) conv_type = GF_ISOM_CONV_TYPE_3GPP ; else if ( ! stricmp ( szExt , \".m4a\" ) || ! stricmp ( szExt , \".m4v\" ) ) conv_type = GF_ISOM_CONV_TYPE_IPOD ; else if ( ! stricmp ( szExt , \".psp\" ) ) conv_type = GF_ISOM_CONV_TYPE_PSP ; else if ( ! stricmp ( szExt , \".mov\" ) || ! stricmp ( szExt , \".qt\" ) ) conv_type = GF_ISOM_CONV_TYPE_MOV ; * szExt = 0 ; } } # ifndef GPAC_DISABLE_MEDIA_EXPORT if ( track_dump_type & GF_EXPORT_AVI_NATIVE ) { char szFile [ GF_MAX_PATH + 24 ] ; GF_MediaExporter mdump ; memset ( & mdump , 0 , sizeof ( mdump ) ) ; mdump . in_name = inName ; mdump . flags = GF_EXPORT_AVI_NATIVE ; mdump . trackID = trackID ; if ( dump_std ) { mdump . out_name = \"std\" ; } else if ( outName ) { mdump . out_name = outName ; } else if ( trackID > 2 ) { sprintf ( szFile , \"%s_audio%d\" , outfile , trackID - 1 ) ; mdump . out_name = szFile ; } else { sprintf ( szFile , \"%s_%s\" , outfile , ( trackID == 1 ) ? \"video\" : \"audio\" ) ; mdump . out_name = szFile ; } mdump . print_stats_graph = fs_dump_flags ; e = gf_media_export ( & mdump ) ; if ( e ) goto err_exit ; goto exit ; } if ( ! open_edit && track_dump_type && ! gf_isom_probe_file ( inName ) ) { GF_MediaExporter mdump ; char szFile [ GF_MAX_PATH + 24 ] ; for ( i = 0 ; i < nb_track_act ; i ++ ) { TrackAction * tka = & tracks [ i ] ; if ( tka -> act_type != TRAC_ACTION_RAW_EXTRACT ) continue ; memset ( & mdump , 0 , sizeof ( mdump ) ) ; mdump . in_name = inName ; mdump . flags = tka -> dump_type ; mdump . trackID = tka -> trackID ; mdump . sample_num = tka -> sample_num ; if ( outName ) { mdump . out_name = outName ; mdump . flags |= GF_EXPORT_MERGE ; } else if ( nb_track_act > 1 ) { sprintf ( szFile , \"%s_track%d\" , outfile , mdump . trackID ) ; mdump . out_name = szFile ; } else { mdump . out_name = outfile ; } mdump . print_stats_graph = fs_dump_flags ; e = gf_media_export ( & mdump ) ; if ( e ) goto err_exit ; } goto exit ; } # endif # ifndef GPAC_DISABLE_SCENE_DUMP if ( dump_mode != GF_SM_DUMP_NONE ) { e = dump_isom_scene ( inName , dump_std ? NULL : ( outName ? outName : outfile ) , outName ? GF_TRUE : GF_FALSE , dump_mode , do_scene_log , no_odf_conf ) ; if ( e ) goto err_exit ; } # endif # ifndef GPAC_DISABLE_SCENE_STATS if ( stat_level ) dump_isom_scene_stats ( inName , dump_std ? NULL : ( outName ? outName : outfile ) , outName ? GF_TRUE : GF_FALSE , stat_level ) ; # endif # ifndef GPAC_DISABLE_ISOM_HINTING if ( ! HintIt && print_sdp ) dump_isom_sdp ( file , dump_std ? NULL : ( outName ? outName : outfile ) , outName ? GF_TRUE : GF_FALSE ) ; # endif if ( get_nb_tracks ) { fprintf ( stdout , \"%d\\\\n\" , gf_isom_get_track_count ( file ) ) ; } if ( print_info ) { if ( ! file ) { fprintf ( stderr , \"Cannot<S2SV_blank>print<S2SV_blank>info<S2SV_blank>on<S2SV_blank>a<S2SV_blank>non<S2SV_blank>ISOM<S2SV_blank>file<S2SV_blank>(%s)\\\\n\" , inName ) ; } else { if ( info_track_id ) DumpTrackInfo ( file , info_track_id , 1 , ( print_info == 2 ) ? GF_TRUE : GF_FALSE ) ; else DumpMovieInfo ( file ) ; } } # ifndef GPAC_DISABLE_ISOM_DUMP if ( dump_isom ) { e = dump_isom_xml ( file , dump_std ? NULL : ( outName ? outName : outfile ) , outName ? GF_TRUE : GF_FALSE , ( dump_isom == 2 ) ? GF_TRUE : GF_FALSE , merge_vtt_cues , use_init_seg ? GF_TRUE : GF_FALSE , ( dump_isom == 3 ) ? GF_TRUE : GF_FALSE ) ; if ( e ) goto err_exit ; } if ( dump_cr ) dump_isom_ismacryp ( file , dump_std ? NULL : ( outName ? outName : outfile ) , outName ? GF_TRUE : GF_FALSE ) ; if ( ( dump_ttxt || dump_srt ) && trackID ) { if ( trackID == ( u32 ) - 1 ) { for ( j = 0 ; j < gf_isom_get_track_count ( file ) ; j ++ ) { trackID = gf_isom_get_track_id ( file , j + 1 ) ; dump_isom_timed_text ( file , trackID , dump_std ? NULL : ( outName ? outName : outfile ) , outName ? GF_TRUE : GF_FALSE , GF_FALSE , dump_srt ? GF_TEXTDUMPTYPE_SRT : GF_TEXTDUMPTYPE_TTXT ) ; } } else { dump_isom_timed_text ( file , trackID , dump_std ? NULL : ( outName ? outName : outfile ) , outName ? GF_TRUE : GF_FALSE , GF_FALSE , dump_srt ? GF_TEXTDUMPTYPE_SRT : GF_TEXTDUMPTYPE_TTXT ) ; } } # ifndef GPAC_DISABLE_ISOM_HINTING if ( dump_rtp ) dump_isom_rtp ( file , dump_std ? NULL : ( outName ? outName : outfile ) , outName ? GF_TRUE : GF_FALSE ) ; # endif # endif if ( dump_timestamps ) dump_isom_timestamps ( file , dump_std ? NULL : ( outName ? outName : outfile ) , outName ? GF_TRUE : GF_FALSE , dump_timestamps ) ; if ( dump_nal ) dump_isom_nal ( file , dump_nal , dump_std ? NULL : ( outName ? outName : outfile ) , outName ? GF_TRUE : GF_FALSE , dump_nal_type ) ; if ( dump_saps ) dump_isom_saps ( file , dump_saps , dump_saps_mode , dump_std ? NULL : ( outName ? outName : outfile ) , outName ? GF_TRUE : GF_FALSE ) ; if ( do_hash ) { e = hash_file ( inName , dump_std ) ; if ( e ) goto err_exit ; } # ifndef GPAC_DISABLE_CORE_TOOLS if ( do_bin_xml ) { e = xml_bs_to_bin ( inName , outName , dump_std ) ; if ( e ) goto err_exit ; } # endif if ( dump_cart ) dump_isom_cover_art ( file , dump_std ? NULL : ( outName ? outName : outfile ) , outName ? GF_TRUE : GF_FALSE ) ; if ( dump_chap ) dump_isom_chapters ( file , dump_std ? NULL : ( outName ? outName : outfile ) , outName ? GF_TRUE : GF_FALSE , dump_chap ) ; if ( dump_udta_type ) dump_isom_udta ( file , dump_std ? NULL : ( outName ? outName : outfile ) , outName ? GF_TRUE : GF_FALSE , dump_udta_type , dump_udta_track ) ; if ( dump_iod ) { GF_InitialObjectDescriptor * iod = ( GF_InitialObjectDescriptor * ) gf_isom_get_root_od ( file ) ; if ( ! iod ) { <S2SV_StartBug> fprintf ( stderr , \"File<S2SV_blank>%s<S2SV_blank>has<S2SV_blank>no<S2SV_blank>IOD\" , inName ) ; <S2SV_EndBug> } else { char szName [ GF_MAX_PATH + 10 ] ; FILE * iodf ; sprintf ( szName , \"%s.iod\" , outfile ) ; iodf = gf_fopen ( szName , \"wb\" ) ; if ( ! iodf ) { fprintf ( stderr , \"Cannot<S2SV_blank>open<S2SV_blank>destination<S2SV_blank>%s\\\\n\" , szName ) ; } else { u8 * desc ; u32 size ; GF_BitStream * bs = gf_bs_from_file ( iodf , GF_BITSTREAM_WRITE ) ; if ( gf_odf_desc_write ( ( GF_Descriptor * ) iod , & desc , & size ) == GF_OK ) { gf_fwrite ( desc , size , iodf ) ; gf_free ( desc ) ; } else { fprintf ( stderr , \"Error<S2SV_blank>writing<S2SV_blank>IOD<S2SV_blank>%s\\\\n\" , szName ) ; } gf_fclose ( iodf ) ; gf_bs_del ( bs ) ; } gf_odf_desc_del ( ( GF_Descriptor * ) iod ) ; } } # if ! defined ( GPAC_DISABLE_ISOM_WRITE ) && ! defined ( GPAC_DISABLE_MEDIA_IMPORT ) if ( split_duration || split_size || split_range_str ) { split_isomedia_file ( file , split_duration , split_size , inName , interleaving_time , split_start , adjust_split_end , outName , tmpdir , seg_at_rap , split_range_str ) ; open_edit = GF_FALSE ; needSave = GF_FALSE ; } # endif # ifndef GPAC_DISABLE_MEDIA_EXPORT if ( track_dump_type ) { char szFile [ GF_MAX_PATH + 24 ] ; GF_MediaExporter mdump ; for ( i = 0 ; i < nb_track_act ; i ++ ) { TrackAction * tka = & tracks [ i ] ; if ( tka -> act_type != TRAC_ACTION_RAW_EXTRACT ) continue ; memset ( & mdump , 0 , sizeof ( mdump ) ) ; mdump . file = file ; mdump . flags = tka -> dump_type ; mdump . trackID = tka -> trackID ; mdump . sample_num = tka -> sample_num ; if ( tka -> out_name ) { mdump . out_name = tka -> out_name ; } else if ( outName ) { mdump . out_name = outName ; mdump . flags |= GF_EXPORT_MERGE ; mdump . flags |= GF_EXPORT_NO_FILE_EXT ; } else if ( mdump . trackID ) { sprintf ( szFile , \"%s_track%d\" , outfile , mdump . trackID ) ; mdump . out_name = szFile ; } else { sprintf ( szFile , \"%s_export\" , outfile ) ; mdump . out_name = szFile ; } if ( tka -> trackID == ( u32 ) - 1 ) { for ( j = 0 ; j < gf_isom_get_track_count ( file ) ; j ++ ) { mdump . trackID = gf_isom_get_track_id ( file , j + 1 ) ; sprintf ( szFile , \"%s_track%d\" , outfile , mdump . trackID ) ; mdump . out_name = szFile ; mdump . print_stats_graph = fs_dump_flags ; e = gf_media_export ( & mdump ) ; if ( e ) goto err_exit ; } } else { mdump . print_stats_graph = fs_dump_flags ; e = gf_media_export ( & mdump ) ; if ( e ) goto err_exit ; } } } else if ( do_saf ) { GF_MediaExporter mdump ; memset ( & mdump , 0 , sizeof ( mdump ) ) ; mdump . file = file ; mdump . flags = GF_EXPORT_SAF ; mdump . out_name = outfile ; mdump . print_stats_graph = fs_dump_flags ; e = gf_media_export ( & mdump ) ; if ( e ) goto err_exit ; } # endif for ( i = 0 ; i < nb_meta_act ; i ++ ) { u32 tk = 0 ; # ifndef GPAC_DISABLE_ISOM_WRITE Bool self_ref ; # endif MetaAction * meta = & metas [ i ] ; if ( meta -> trackID ) tk = gf_isom_get_track_by_id ( file , meta -> trackID ) ; switch ( meta -> act_type ) { # ifndef GPAC_DISABLE_ISOM_WRITE case META_ACTION_SET_TYPE : e = gf_isom_set_meta_type ( file , meta -> root_meta , tk , meta -> meta_4cc ) ; gf_isom_modify_alternate_brand ( file , GF_ISOM_BRAND_ISO2 , GF_TRUE ) ; needSave = GF_TRUE ; break ; case META_ACTION_ADD_ITEM : self_ref = ! stricmp ( meta -> szPath , \"NULL\" ) || ! stricmp ( meta -> szPath , \"this\" ) || ! stricmp ( meta -> szPath , \"self\" ) ; e = gf_isom_add_meta_item ( file , meta -> root_meta , tk , self_ref , self_ref ? NULL : meta -> szPath , meta -> szName , meta -> item_id , meta -> item_type , meta -> mime_type , meta -> enc_type , meta -> use_dref ? meta -> szPath : NULL , NULL , meta -> image_props ) ; if ( meta -> ref_type ) { e = gf_isom_meta_add_item_ref ( file , meta -> root_meta , tk , meta -> item_id , meta -> ref_item_id , meta -> ref_type , NULL ) ; } needSave = GF_TRUE ; break ; case META_ACTION_ADD_IMAGE_ITEM : { u32 old_tk_count = gf_isom_get_track_count ( file ) ; GF_Fraction _frac = { 0 , 0 } ; e = import_file ( file , meta -> szPath , 0 , _frac , 0 , NULL , NULL , 0 ) ; if ( e == GF_OK ) { u32 meta_type = gf_isom_get_meta_type ( file , meta -> root_meta , tk ) ; if ( ! meta_type ) { e = gf_isom_set_meta_type ( file , meta -> root_meta , tk , GF_META_ITEM_TYPE_PICT ) ; } else { if ( meta_type != GF_META_ITEM_TYPE_PICT ) { GF_LOG ( GF_LOG_ERROR , GF_LOG_CONTAINER , ( \"Warning:<S2SV_blank>file<S2SV_blank>already<S2SV_blank>has<S2SV_blank>a<S2SV_blank>root<S2SV_blank>\\'meta\\'<S2SV_blank>box<S2SV_blank>of<S2SV_blank>type<S2SV_blank>%s\\\\n\" , gf_4cc_to_str ( meta_type ) ) ) ; e = GF_BAD_PARAM ; } } if ( e == GF_OK ) { if ( ! meta -> item_id ) { e = gf_isom_meta_get_next_item_id ( file , meta -> root_meta , tk , & meta -> item_id ) ; } if ( e == GF_OK ) { e = gf_isom_iff_create_image_item_from_track ( file , meta -> root_meta , tk , 1 , meta -> szName , meta -> item_id , meta -> image_props , NULL ) ; if ( e == GF_OK && meta -> primary ) { e = gf_isom_set_meta_primary_item ( file , meta -> root_meta , tk , meta -> item_id ) ; } if ( e == GF_OK && meta -> ref_type ) { e = gf_isom_meta_add_item_ref ( file , meta -> root_meta , tk , meta -> item_id , meta -> ref_item_id , meta -> ref_type , NULL ) ; } } } } gf_isom_remove_track ( file , old_tk_count + 1 ) ; needSave = GF_TRUE ; } break ; case META_ACTION_REM_ITEM : e = gf_isom_remove_meta_item ( file , meta -> root_meta , tk , meta -> item_id ) ; needSave = GF_TRUE ; break ; case META_ACTION_SET_PRIMARY_ITEM : e = gf_isom_set_meta_primary_item ( file , meta -> root_meta , tk , meta -> item_id ) ; needSave = GF_TRUE ; break ; case META_ACTION_SET_XML : case META_ACTION_SET_BINARY_XML : e = gf_isom_set_meta_xml ( file , meta -> root_meta , tk , meta -> szPath , NULL , 0 , ( meta -> act_type == META_ACTION_SET_BINARY_XML ) ? 1 : 0 ) ; needSave = GF_TRUE ; break ; case META_ACTION_REM_XML : if ( gf_isom_get_meta_item_count ( file , meta -> root_meta , tk ) ) { e = gf_isom_remove_meta_xml ( file , meta -> root_meta , tk ) ; needSave = GF_TRUE ; } else { fprintf ( stderr , \"No<S2SV_blank>meta<S2SV_blank>box<S2SV_blank>in<S2SV_blank>input<S2SV_blank>file\\\\n\" ) ; } break ; case META_ACTION_DUMP_ITEM : if ( gf_isom_get_meta_item_count ( file , meta -> root_meta , tk ) ) { e = gf_isom_extract_meta_item ( file , meta -> root_meta , tk , meta -> item_id , strlen ( meta -> szPath ) ? meta -> szPath : NULL ) ; } else { fprintf ( stderr , \"No<S2SV_blank>meta<S2SV_blank>box<S2SV_blank>in<S2SV_blank>input<S2SV_blank>file\\\\n\" ) ; } break ; # endif case META_ACTION_DUMP_XML : if ( gf_isom_has_meta_xml ( file , meta -> root_meta , tk ) ) { e = gf_isom_extract_meta_xml ( file , meta -> root_meta , tk , meta -> szPath , NULL ) ; } else { fprintf ( stderr , \"No<S2SV_blank>meta<S2SV_blank>box<S2SV_blank>in<S2SV_blank>input<S2SV_blank>file\\\\n\" ) ; } break ; default : break ; } if ( meta -> image_props ) { gf_free ( meta -> image_props ) ; meta -> image_props = NULL ; } if ( e ) goto err_exit ; } if ( ! open_edit && ! needSave ) { if ( file ) gf_isom_delete ( file ) ; goto exit ; } # ifndef GPAC_DISABLE_ISOM_WRITE if ( clean_groups ) { e = gf_isom_reset_switch_parameters ( file ) ; if ( e ) goto err_exit ; needSave = GF_TRUE ; } for ( i = 0 ; i < nb_tsel_acts ; i ++ ) { switch ( tsel_acts [ i ] . act_type ) { case TSEL_ACTION_SET_PARAM : e = gf_isom_set_track_switch_parameter ( file , gf_isom_get_track_by_id ( file , tsel_acts [ i ] . trackID ) , tsel_acts [ i ] . refTrackID ? gf_isom_get_track_by_id ( file , tsel_acts [ i ] . refTrackID ) : 0 , tsel_acts [ i ] . is_switchGroup ? 1 : 0 , & tsel_acts [ i ] . switchGroupID , tsel_acts [ i ] . criteria , tsel_acts [ i ] . nb_criteria ) ; if ( e == GF_BAD_PARAM ) { u32 alternateGroupID , nb_groups ; gf_isom_get_track_switch_group_count ( file , gf_isom_get_track_by_id ( file , tsel_acts [ i ] . trackID ) , & alternateGroupID , & nb_groups ) ; if ( alternateGroupID ) fprintf ( stderr , \"Hint:<S2SV_blank>for<S2SV_blank>adding<S2SV_blank>more<S2SV_blank>tracks<S2SV_blank>to<S2SV_blank>group,<S2SV_blank>using:<S2SV_blank>-group-add<S2SV_blank>-refTrack=ID1:[criteria:]trackID=ID2\\\\n\" ) ; else fprintf ( stderr , \"Hint:<S2SV_blank>for<S2SV_blank>creates<S2SV_blank>a<S2SV_blank>new<S2SV_blank>grouping<S2SV_blank>information,<S2SV_blank>using<S2SV_blank>-group-add<S2SV_blank>-trackID=ID1:[criteria:]trackID=ID2\\\\n\" ) ; } if ( e ) goto err_exit ; needSave = GF_TRUE ; break ; case TSEL_ACTION_REMOVE_TSEL : e = gf_isom_reset_track_switch_parameter ( file , gf_isom_get_track_by_id ( file , tsel_acts [ i ] . trackID ) , 0 ) ; if ( e ) goto err_exit ; needSave = GF_TRUE ; break ; case TSEL_ACTION_REMOVE_ALL_TSEL_IN_GROUP : e = gf_isom_reset_track_switch_parameter ( file , gf_isom_get_track_by_id ( file , tsel_acts [ i ] . trackID ) , 1 ) ; if ( e ) goto err_exit ; needSave = GF_TRUE ; break ; default : break ; } } if ( remove_sys_tracks ) { # ifndef GPAC_DISABLE_AV_PARSERS remove_systems_tracks ( file ) ; # endif needSave = GF_TRUE ; if ( conv_type < GF_ISOM_CONV_TYPE_ISMA_EX ) conv_type = 0 ; } if ( remove_root_od ) { gf_isom_remove_root_od ( file ) ; needSave = GF_TRUE ; } # ifndef GPAC_DISABLE_ISOM_HINTING if ( remove_hint ) { for ( i = 0 ; i < gf_isom_get_track_count ( file ) ; i ++ ) { if ( gf_isom_get_media_type ( file , i + 1 ) == GF_ISOM_MEDIA_HINT ) { fprintf ( stderr , \"Removing<S2SV_blank>hint<S2SV_blank>track<S2SV_blank>ID<S2SV_blank>%d\\\\n\" , gf_isom_get_track_id ( file , i + 1 ) ) ; gf_isom_remove_track ( file , i + 1 ) ; i -- ; } } gf_isom_sdp_clean ( file ) ; needSave = GF_TRUE ; } # endif if ( timescale && ( timescale != gf_isom_get_timescale ( file ) ) ) { gf_isom_set_timescale ( file , timescale ) ; needSave = GF_TRUE ; } if ( ! encode ) { if ( ! file ) { fprintf ( stderr , \"Nothing<S2SV_blank>to<S2SV_blank>do<S2SV_blank>-<S2SV_blank>exiting\\\\n\" ) ; goto exit ; } if ( outName ) { strcpy ( outfile , outName ) ; } else { char * rel_name = strrchr ( inName , GF_PATH_SEPARATOR ) ; if ( ! rel_name ) rel_name = strrchr ( inName , '/' ) ; strcpy ( outfile , \"\" ) ; if ( tmpdir ) { strcpy ( outfile , tmpdir ) ; if ( ! strchr ( \"\\\\\\\\/\" , tmpdir [ strlen ( tmpdir ) - 1 ] ) ) strcat ( outfile , \"/\" ) ; } if ( ! pack_file ) strcat ( outfile , \"out_\" ) ; strcat ( outfile , rel_name ? rel_name + 1 : inName ) ; if ( pack_file ) { strcpy ( outfile , rel_name ? rel_name + 1 : inName ) ; rel_name = strrchr ( outfile , '.' ) ; if ( rel_name ) rel_name [ 0 ] = 0 ; strcat ( outfile , \".m21\" ) ; } } # ifndef GPAC_DISABLE_MEDIA_IMPORT if ( ( conv_type == GF_ISOM_CONV_TYPE_ISMA ) || ( conv_type == GF_ISOM_CONV_TYPE_ISMA_EX ) ) { fprintf ( stderr , \"Converting<S2SV_blank>to<S2SV_blank>ISMA<S2SV_blank>Audio-Video<S2SV_blank>MP4<S2SV_blank>file...\\\\n\" ) ; e = gf_media_make_isma ( file , crypt ? 1 : 0 , GF_FALSE , ( conv_type == GF_ISOM_CONV_TYPE_ISMA_EX ) ? 1 : 0 ) ; if ( e ) goto err_exit ; needSave = GF_TRUE ; } if ( conv_type == GF_ISOM_CONV_TYPE_3GPP ) { fprintf ( stderr , \"Converting<S2SV_blank>to<S2SV_blank>3GP<S2SV_blank>file...\\\\n\" ) ; e = gf_media_make_3gpp ( file ) ; if ( e ) goto err_exit ; needSave = GF_TRUE ; } if ( conv_type == GF_ISOM_CONV_TYPE_PSP ) { fprintf ( stderr , \"Converting<S2SV_blank>to<S2SV_blank>PSP<S2SV_blank>file...\\\\n\" ) ; e = gf_media_make_psp ( file ) ; if ( e ) goto err_exit ; needSave = GF_TRUE ; } if ( conv_type == GF_ISOM_CONV_TYPE_MOV ) { e = gf_media_check_qt_prores ( file ) ; if ( e ) goto err_exit ; needSave = GF_TRUE ; if ( interleaving_time ) interleaving_time = 0.5 ; } # endif if ( conv_type == GF_ISOM_CONV_TYPE_IPOD ) { u32 ipod_major_brand = 0 ; fprintf ( stderr , \"Setting<S2SV_blank>up<S2SV_blank>iTunes/iPod<S2SV_blank>file...\\\\n\" ) ; for ( i = 0 ; i < gf_isom_get_track_count ( file ) ; i ++ ) { u32 mType = gf_isom_get_media_type ( file , i + 1 ) ; switch ( mType ) { case GF_ISOM_MEDIA_VISUAL : case GF_ISOM_MEDIA_AUXV : case GF_ISOM_MEDIA_PICT : ipod_major_brand = GF_ISOM_BRAND_M4V ; gf_isom_set_ipod_compatible ( file , i + 1 ) ; break ; case GF_ISOM_MEDIA_AUDIO : if ( ! ipod_major_brand ) ipod_major_brand = GF_ISOM_BRAND_M4A ; else gf_isom_modify_alternate_brand ( file , GF_ISOM_BRAND_M4A , GF_TRUE ) ; break ; case GF_ISOM_MEDIA_TEXT : if ( gf_isom_get_media_subtype ( file , i + 1 , 1 ) == GF_ISOM_SUBTYPE_TX3G ) { Bool is_chap = 0 ; for ( j = 0 ; j < gf_isom_get_track_count ( file ) ; j ++ ) { s32 count = gf_isom_get_reference_count ( file , j + 1 , GF_ISOM_REF_CHAP ) ; if ( count > 0 ) { u32 tk , k ; for ( k = 0 ; k < ( u32 ) count ; k ++ ) { gf_isom_get_reference ( file , j + 1 , GF_ISOM_REF_CHAP , k + 1 , & tk ) ; if ( tk == i + 1 ) { is_chap = 1 ; break ; } } if ( is_chap ) break ; } if ( is_chap ) break ; } if ( ! is_chap ) gf_isom_set_media_type ( file , i + 1 , GF_ISOM_MEDIA_SUBT ) ; } break ; } } gf_isom_set_brand_info ( file , ipod_major_brand , 1 ) ; gf_isom_modify_alternate_brand ( file , GF_ISOM_BRAND_MP42 , GF_TRUE ) ; needSave = GF_TRUE ; } } else if ( outName ) { strcpy ( outfile , outName ) ; } for ( j = 0 ; j < nb_track_act ; j ++ ) { TrackAction * tka = & tracks [ j ] ; u32 track = tka -> trackID ? gf_isom_get_track_by_id ( file , tka -> trackID ) : 0 ; timescale = gf_isom_get_timescale ( file ) ; switch ( tka -> act_type ) { case TRAC_ACTION_REM_TRACK : e = gf_isom_remove_track ( file , track ) ; if ( e ) { fprintf ( stderr , \"Error<S2SV_blank>Removing<S2SV_blank>track<S2SV_blank>ID<S2SV_blank>%d:<S2SV_blank>%s\\\\n\" , tka -> trackID , gf_error_to_string ( e ) ) ; } else { fprintf ( stderr , \"Removing<S2SV_blank>track<S2SV_blank>ID<S2SV_blank>%d\\\\n\" , tka -> trackID ) ; } needSave = GF_TRUE ; break ; case TRAC_ACTION_SET_LANGUAGE : for ( i = 0 ; i < gf_isom_get_track_count ( file ) ; i ++ ) { if ( track && ( track != i + 1 ) ) continue ; e = gf_isom_set_media_language ( file , i + 1 , tka -> lang ) ; if ( e ) goto err_exit ; needSave = GF_TRUE ; } needSave = GF_TRUE ; break ; case TRAC_ACTION_SET_KIND : for ( i = 0 ; i < gf_isom_get_track_count ( file ) ; i ++ ) { if ( track && ( track != i + 1 ) ) continue ; e = gf_isom_add_track_kind ( file , i + 1 , tka -> kind_scheme , tka -> kind_value ) ; if ( e ) goto err_exit ; needSave = GF_TRUE ; } needSave = GF_TRUE ; break ; case TRAC_ACTION_REM_KIND : for ( i = 0 ; i < gf_isom_get_track_count ( file ) ; i ++ ) { if ( track && ( track != i + 1 ) ) continue ; e = gf_isom_remove_track_kind ( file , i + 1 , tka -> kind_scheme , tka -> kind_value ) ; if ( e ) goto err_exit ; needSave = GF_TRUE ; } needSave = GF_TRUE ; break ; case TRAC_ACTION_SET_DELAY : if ( tka -> delay_ms ) { u64 tk_dur ; gf_isom_remove_edits ( file , track ) ; tk_dur = gf_isom_get_track_duration ( file , track ) ; if ( gf_isom_get_edits_count ( file , track ) ) needSave = GF_TRUE ; if ( tka -> delay_ms > 0 ) { gf_isom_append_edit ( file , track , ( timescale * tka -> delay_ms ) / 1000 , 0 , GF_ISOM_EDIT_EMPTY ) ; gf_isom_append_edit ( file , track , tk_dur , 0 , GF_ISOM_EDIT_NORMAL ) ; needSave = GF_TRUE ; } else { u64 to_skip = ( timescale * ( - tka -> delay_ms ) ) / 1000 ; if ( to_skip < tk_dur ) { u64 media_time = ( - tka -> delay_ms ) * gf_isom_get_media_timescale ( file , track ) / 1000 ; gf_isom_append_edit ( file , track , tk_dur - to_skip , media_time , GF_ISOM_EDIT_NORMAL ) ; needSave = GF_TRUE ; } else { fprintf ( stderr , \"Warning:<S2SV_blank>request<S2SV_blank>negative<S2SV_blank>delay<S2SV_blank>longer<S2SV_blank>than<S2SV_blank>track<S2SV_blank>duration<S2SV_blank>-<S2SV_blank>ignoring\\\\n\" ) ; } } } else if ( gf_isom_get_edits_count ( file , track ) ) { gf_isom_remove_edits ( file , track ) ; needSave = GF_TRUE ; } break ; case TRAC_ACTION_SET_KMS_URI : for ( i = 0 ; i < gf_isom_get_track_count ( file ) ; i ++ ) { if ( track && ( track != i + 1 ) ) continue ; if ( ! gf_isom_is_media_encrypted ( file , i + 1 , 1 ) ) continue ; if ( ! gf_isom_is_ismacryp_media ( file , i + 1 , 1 ) ) continue ; e = gf_isom_change_ismacryp_protection ( file , i + 1 , 1 , NULL , ( char * ) tka -> kms ) ; if ( e ) goto err_exit ; needSave = GF_TRUE ; } break ; case TRAC_ACTION_SET_ID : if ( ! tka -> trackID && ( gf_isom_get_track_count ( file ) == 1 ) ) { fprintf ( stderr , \"Warning:<S2SV_blank>track<S2SV_blank>id<S2SV_blank>is<S2SV_blank>not<S2SV_blank>specified,<S2SV_blank>but<S2SV_blank>file<S2SV_blank>has<S2SV_blank>only<S2SV_blank>one<S2SV_blank>track<S2SV_blank>-<S2SV_blank>assume<S2SV_blank>that<S2SV_blank>you<S2SV_blank>want<S2SV_blank>to<S2SV_blank>change<S2SV_blank>id<S2SV_blank>for<S2SV_blank>this<S2SV_blank>track\\\\n\" ) ; track = 1 ; } if ( track ) { u32 newTrack ; newTrack = gf_isom_get_track_by_id ( file , tka -> newTrackID ) ; if ( newTrack != 0 ) { fprintf ( stderr , \"Error:<S2SV_blank>Cannot<S2SV_blank>set<S2SV_blank>track<S2SV_blank>id<S2SV_blank>with<S2SV_blank>value<S2SV_blank>%d<S2SV_blank>because<S2SV_blank>a<S2SV_blank>track<S2SV_blank>already<S2SV_blank>exists<S2SV_blank>-<S2SV_blank>ignoring\" , tka -> newTrackID ) ; } else { e = gf_isom_set_track_id ( file , track , tka -> newTrackID ) ; needSave = GF_TRUE ; } } else { fprintf ( stderr , \"Error:<S2SV_blank>Cannot<S2SV_blank>change<S2SV_blank>id<S2SV_blank>for<S2SV_blank>track<S2SV_blank>%d<S2SV_blank>because<S2SV_blank>it<S2SV_blank>does<S2SV_blank>not<S2SV_blank>exist<S2SV_blank>-<S2SV_blank>ignoring\" , tka -> trackID ) ; } break ; case TRAC_ACTION_SWAP_ID : if ( track ) { u32 tk1 , tk2 ; tk1 = gf_isom_get_track_by_id ( file , tka -> trackID ) ; tk2 = gf_isom_get_track_by_id ( file , tka -> newTrackID ) ; if ( ! tk1 || ! tk2 ) { fprintf ( stderr , \"Error:<S2SV_blank>Cannot<S2SV_blank>swap<S2SV_blank>track<S2SV_blank>IDs<S2SV_blank>because<S2SV_blank>not<S2SV_blank>existing<S2SV_blank>-<S2SV_blank>ignoring\" ) ; } else { e = gf_isom_set_track_id ( file , tk2 , 0 ) ; if ( ! e ) e = gf_isom_set_track_id ( file , tk1 , tka -> newTrackID ) ; if ( ! e ) e = gf_isom_set_track_id ( file , tk2 , tka -> trackID ) ; needSave = GF_TRUE ; } } else { fprintf ( stderr , \"Error:<S2SV_blank>Cannot<S2SV_blank>change<S2SV_blank>id<S2SV_blank>for<S2SV_blank>track<S2SV_blank>%d<S2SV_blank>because<S2SV_blank>it<S2SV_blank>does<S2SV_blank>not<S2SV_blank>exist<S2SV_blank>-<S2SV_blank>ignoring\" , tka -> trackID ) ; } break ; case TRAC_ACTION_SET_PAR : e = gf_media_change_par ( file , track , tka -> par_num , tka -> par_den , tka -> force_par , tka -> rewrite_bs ) ; needSave = GF_TRUE ; break ; case TRAC_ACTION_SET_CLAP : e = gf_isom_set_clean_aperture ( file , track , 1 , tka -> clap_wnum , tka -> clap_wden , tka -> clap_hnum , tka -> clap_hden , tka -> clap_honum , tka -> clap_hoden , tka -> clap_vonum , tka -> clap_voden ) ; needSave = GF_TRUE ; break ; case TRAC_ACTION_SET_MX : e = gf_isom_set_track_matrix ( file , track , tka -> mx ) ; needSave = GF_TRUE ; break ; case TRAC_ACTION_SET_HANDLER_NAME : e = gf_isom_set_handler_name ( file , track , tka -> hdl_name ) ; needSave = GF_TRUE ; break ; case TRAC_ACTION_ENABLE : if ( ! gf_isom_is_track_enabled ( file , track ) ) { e = gf_isom_set_track_enabled ( file , track , GF_TRUE ) ; needSave = GF_TRUE ; } break ; case TRAC_ACTION_DISABLE : if ( gf_isom_is_track_enabled ( file , track ) ) { e = gf_isom_set_track_enabled ( file , track , GF_FALSE ) ; needSave = GF_TRUE ; } break ; case TRAC_ACTION_REFERENCE : e = gf_isom_set_track_reference ( file , track , GF_4CC ( tka -> lang [ 0 ] , tka -> lang [ 1 ] , tka -> lang [ 2 ] , tka -> lang [ 3 ] ) , ( u32 ) tka -> delay_ms ) ; needSave = GF_TRUE ; break ; case TRAC_ACTION_REM_NON_RAP : fprintf ( stderr , \"Removing<S2SV_blank>non-rap<S2SV_blank>samples<S2SV_blank>from<S2SV_blank>track<S2SV_blank>%d\\\\n\" , tka -> trackID ) ; e = gf_media_remove_non_rap ( file , track , GF_FALSE ) ; needSave = GF_TRUE ; break ; case TRAC_ACTION_REM_NON_REFS : fprintf ( stderr , \"Removing<S2SV_blank>non-reference<S2SV_blank>samples<S2SV_blank>from<S2SV_blank>track<S2SV_blank>%d\\\\n\" , tka -> trackID ) ; e = gf_media_remove_non_rap ( file , track , GF_TRUE ) ; needSave = GF_TRUE ; break ; case TRAC_ACTION_SET_UDTA : fprintf ( stderr , \"Assigning<S2SV_blank>udta<S2SV_blank>box\\\\n\" ) ; e = set_file_udta ( file , track , tka -> udta_type , tka -> src_name , tka -> sample_num ? GF_TRUE : GF_FALSE ) ; if ( e ) goto err_exit ; needSave = GF_TRUE ; break ; default : break ; } if ( e ) goto err_exit ; } if ( itunes_tags ) { char * tags = itunes_tags ; while ( tags ) { char * val ; char * sep = gf_url_colon_suffix ( tags ) ; u32 tlen , itag = 0 ; if ( sep ) { while ( sep ) { for ( itag = 0 ; itag < nb_itunes_tags ; itag ++ ) { if ( ! strnicmp ( sep + 1 , itags [ itag ] . name , strlen ( itags [ itag ] . name ) ) ) break ; } if ( itag < nb_itunes_tags ) { break ; } sep = gf_url_colon_suffix ( sep + 1 ) ; } if ( sep ) sep [ 0 ] = 0 ; } for ( itag = 0 ; itag < nb_itunes_tags ; itag ++ ) { if ( ! strnicmp ( tags , itags [ itag ] . name , strlen ( itags [ itag ] . name ) ) ) { break ; } } if ( itag == nb_itunes_tags ) { fprintf ( stderr , \"Invalid<S2SV_blank>iTune<S2SV_blank>tag<S2SV_blank>format<S2SV_blank>\\\\\"%s\\\\\"<S2SV_blank>-<S2SV_blank>ignoring\\\\n\" , tags ) ; tags = NULL ; continue ; } itag = itags [ itag ] . code ; val = strchr ( tags , '=' ) ; if ( ! val ) { fprintf ( stderr , \"Invalid<S2SV_blank>iTune<S2SV_blank>tag<S2SV_blank>format<S2SV_blank>\\\\\"%s\\\\\"<S2SV_blank>(expecting<S2SV_blank>\\'=\\')<S2SV_blank>-<S2SV_blank>ignoring\\\\n\" , tags ) ; tags = NULL ; continue ; } val ++ ; if ( ( val [ 0 ] == ':' ) || ! val [ 0 ] || ! stricmp ( val , \"NULL\" ) ) val = NULL ; tlen = val ? ( u32 ) strlen ( val ) : 0 ; switch ( itag ) { case GF_ISOM_ITUNE_COVER_ART : { u8 * d = NULL ; e = GF_OK ; if ( val ) { char * ext ; e = gf_file_load_data ( val , ( u8 * * ) & d , & tlen ) ; ext = strrchr ( val , '.' ) ; if ( ! stricmp ( ext , \".png\" ) ) tlen |= 0x80000000 ; } if ( ! e ) e = gf_isom_apple_set_tag ( file , GF_ISOM_ITUNE_COVER_ART , d , tlen ) ; if ( d ) gf_free ( d ) ; } break ; case GF_ISOM_ITUNE_TEMPO : gf_isom_apple_set_tag ( file , itag , NULL , val ? atoi ( val ) : 0 ) ; break ; case GF_ISOM_ITUNE_GENRE : { u8 _v = gf_id3_get_genre_tag ( val ) ; if ( _v ) { gf_isom_apple_set_tag ( file , itag , NULL , _v ) ; } else { if ( ! val ) val = \"\" ; gf_isom_apple_set_tag ( file , itag , ( u8 * ) val , ( u32 ) strlen ( val ) ) ; } } break ; case GF_ISOM_ITUNE_DISK : case GF_ISOM_ITUNE_TRACKNUMBER : { u32 n , t ; char _t [ 8 ] ; n = t = 0 ; if ( val ) { memset ( _t , 0 , sizeof ( char ) * 8 ) ; tlen = ( itag == GF_ISOM_ITUNE_DISK ) ? 6 : 8 ; if ( sscanf ( val , \"%u/%u\" , & n , & t ) == 2 ) { _t [ 3 ] = n ; _t [ 2 ] = n >> 8 ; _t [ 5 ] = t ; _t [ 4 ] = t >> 8 ; } else if ( sscanf ( val , \"%u\" , & n ) == 1 ) { _t [ 3 ] = n ; _t [ 2 ] = n >> 8 ; } else tlen = 0 ; } if ( ! val || tlen ) gf_isom_apple_set_tag ( file , itag , val ? ( u8 * ) _t : NULL , tlen ) ; } break ; case GF_ISOM_ITUNE_GAPLESS : case GF_ISOM_ITUNE_COMPILATION : { u8 _t [ 1 ] ; if ( val && ! stricmp ( val , \"yes\" ) ) _t [ 0 ] = 1 ; else _t [ 0 ] = 0 ; gf_isom_apple_set_tag ( file , itag , _t , 1 ) ; } break ; default : gf_isom_apple_set_tag ( file , itag , ( u8 * ) val , tlen ) ; break ; } needSave = GF_TRUE ; if ( sep ) { sep [ 0 ] = ':' ; tags = sep + 1 ; } else { tags = NULL ; } } } if ( movie_time ) { gf_isom_set_creation_time ( file , movie_time ) ; for ( i = 0 ; i < gf_isom_get_track_count ( file ) ; i ++ ) { gf_isom_set_track_creation_time ( file , i + 1 , movie_time ) ; } needSave = GF_TRUE ; } if ( cprt ) { e = gf_isom_set_copyright ( file , \"und\" , cprt ) ; needSave = GF_TRUE ; if ( e ) goto err_exit ; } if ( chap_file ) { # ifndef GPAC_DISABLE_MEDIA_IMPORT e = gf_media_import_chapters ( file , chap_file , import_fps , chap_qt ) ; needSave = GF_TRUE ; # else fprintf ( stderr , \"Warning:<S2SV_blank>GPAC<S2SV_blank>compiled<S2SV_blank>without<S2SV_blank>Media<S2SV_blank>Import,<S2SV_blank>chapters<S2SV_blank>can\\'t<S2SV_blank>be<S2SV_blank>imported\\\\n\" ) ; e = GF_NOT_SUPPORTED ; # endif if ( e ) goto err_exit ; } if ( major_brand ) { gf_isom_set_brand_info ( file , major_brand , minor_version ) ; needSave = GF_TRUE ; } for ( i = 0 ; i < nb_alt_brand_add ; i ++ ) { gf_isom_modify_alternate_brand ( file , brand_add [ i ] , GF_TRUE ) ; needSave = GF_TRUE ; } for ( i = 0 ; i < nb_alt_brand_rem ; i ++ ) { gf_isom_modify_alternate_brand ( file , brand_rem [ i ] , GF_FALSE ) ; needSave = GF_TRUE ; } if ( box_patch_filename ) { e = gf_isom_apply_box_patch ( file , box_patch_trackID , box_patch_filename , GF_FALSE ) ; if ( e ) { fprintf ( stderr , \"Failed<S2SV_blank>to<S2SV_blank>apply<S2SV_blank>box<S2SV_blank>patch<S2SV_blank>%s:<S2SV_blank>%s\\\\n\" , box_patch_filename , gf_error_to_string ( e ) ) ; goto err_exit ; } needSave = GF_TRUE ; } # ifndef GPAC_DISABLE_CRYPTO if ( crypt ) { if ( ! drm_file ) { fprintf ( stderr , \"Missing<S2SV_blank>DRM<S2SV_blank>file<S2SV_blank>location<S2SV_blank>-<S2SV_blank>usage<S2SV_blank>\\'-%s<S2SV_blank>drm_file<S2SV_blank>input_file\\\\n\" , ( crypt == 1 ) ? \"crypt\" : \"decrypt\" ) ; e = GF_BAD_PARAM ; goto err_exit ; } if ( get_file_type_by_ext ( inName ) != GF_FILE_TYPE_ISO_MEDIA ) { fprintf ( stderr , \"MP4Box<S2SV_blank>can<S2SV_blank>crypt<S2SV_blank>only<S2SV_blank>ISOMedia<S2SV_blank>File\\\\n\" ) ; e = GF_BAD_PARAM ; goto err_exit ; } if ( crypt == 1 ) { if ( use_init_seg ) { e = gf_crypt_fragment ( file , drm_file , outfile , inName , fs_dump_flags ) ; } else { e = gf_crypt_file ( file , drm_file , outfile , interleaving_time , fs_dump_flags ) ; } } else if ( crypt == 2 ) { if ( use_init_seg ) { e = gf_decrypt_fragment ( file , drm_file , outfile , inName , fs_dump_flags ) ; } else { e = gf_decrypt_file ( file , drm_file , outfile , interleaving_time , fs_dump_flags ) ; } } if ( e ) goto err_exit ; needSave = outName ? GF_FALSE : GF_TRUE ; if ( ! Frag && ! HintIt && ! FullInter && ! force_co64 ) { char szName [ GF_MAX_PATH ] ; strcpy ( szName , gf_isom_get_filename ( file ) ) ; gf_isom_delete ( file ) ; file = NULL ; if ( ! outName ) { e = gf_file_move ( outfile , szName ) ; if ( e ) goto err_exit ; } goto exit ; } } # endif # ifndef GPAC_DISABLE_ISOM_FRAGMENTS if ( Frag ) { if ( ! interleaving_time ) interleaving_time = DEFAULT_INTERLEAVING_IN_SEC ; if ( HintIt ) fprintf ( stderr , \"Warning:<S2SV_blank>cannot<S2SV_blank>hint<S2SV_blank>and<S2SV_blank>fragment<S2SV_blank>-<S2SV_blank>ignoring<S2SV_blank>hint\\\\n\" ) ; fprintf ( stderr , \"Fragmenting<S2SV_blank>file<S2SV_blank>(%.3f<S2SV_blank>seconds<S2SV_blank>fragments)\\\\n\" , interleaving_time ) ; e = gf_media_fragment_file ( file , outfile , interleaving_time , use_mfra ) ; if ( e ) fprintf ( stderr , \"Error<S2SV_blank>while<S2SV_blank>fragmenting<S2SV_blank>file:<S2SV_blank>%s\\\\n\" , gf_error_to_string ( e ) ) ; if ( ! e && ! outName ) { if ( gf_file_exists ( inName ) && gf_file_delete ( inName ) ) fprintf ( stderr , \"Error<S2SV_blank>removing<S2SV_blank>file<S2SV_blank>%s\\\\n\" , inName ) ; else if ( gf_file_move ( outfile , inName ) ) fprintf ( stderr , \"Error<S2SV_blank>renaming<S2SV_blank>file<S2SV_blank>%s<S2SV_blank>to<S2SV_blank>%s\\\\n\" , outfile , inName ) ; } if ( e ) goto err_exit ; gf_isom_delete ( file ) ; goto exit ; } # endif # ifndef GPAC_DISABLE_ISOM_HINTING if ( HintIt ) { if ( force_ocr ) SetupClockReferences ( file ) ; fprintf ( stderr , \"Hinting<S2SV_blank>file<S2SV_blank>with<S2SV_blank>Path-MTU<S2SV_blank>%d<S2SV_blank>Bytes\\\\n\" , MTUSize ) ; MTUSize -= 12 ; e = HintFile ( file , MTUSize , max_ptime , rtp_rate , hint_flags , HintCopy , HintInter , regular_iod , single_group , hint_no_offset ) ; if ( e ) goto err_exit ; needSave = GF_TRUE ; if ( print_sdp ) dump_isom_sdp ( file , dump_std ? NULL : ( outName ? outName : outfile ) , outName ? GF_TRUE : GF_FALSE ) ; } # endif # if ! defined ( GPAC_DISABLE_ISOM_HINTING ) && ! defined ( GPAC_DISABLE_SENG ) for ( i = 0 ; i < nb_sdp_ex ; i ++ ) { if ( sdp_lines [ i ] . trackID ) { u32 track = gf_isom_get_track_by_id ( file , sdp_lines [ i ] . trackID ) ; if ( gf_isom_get_media_type ( file , track ) != GF_ISOM_MEDIA_HINT ) { s32 ref_count ; u32 k , count = gf_isom_get_track_count ( file ) ; for ( j = 0 ; j < count ; j ++ ) { if ( gf_isom_get_media_type ( file , j + 1 ) != GF_ISOM_MEDIA_HINT ) continue ; ref_count = gf_isom_get_reference_count ( file , j + 1 , GF_ISOM_REF_HINT ) ; if ( ref_count < 0 ) continue ; for ( k = 0 ; k < ( u32 ) ref_count ; k ++ ) { u32 refTk ; if ( gf_isom_get_reference ( file , j + 1 , GF_ISOM_REF_HINT , k + 1 , & refTk ) ) continue ; if ( refTk == track ) { track = j + 1 ; j = count ; break ; } } } } gf_isom_sdp_add_track_line ( file , track , sdp_lines [ i ] . line ) ; needSave = GF_TRUE ; } else { gf_isom_sdp_add_line ( file , sdp_lines [ i ] . line ) ; needSave = GF_TRUE ; } } # endif if ( FullInter ) { e = gf_isom_set_storage_mode ( file , GF_ISOM_STORE_TIGHT ) ; } else if ( do_flat ) { e = gf_isom_set_storage_mode ( file , ( do_flat == 1 ) ? GF_ISOM_STORE_FLAT : GF_ISOM_STORE_STREAMABLE ) ; needSave = GF_TRUE ; } else { e = gf_isom_make_interleave ( file , interleaving_time ) ; if ( ! e && old_interleave ) e = gf_isom_set_storage_mode ( file , GF_ISOM_STORE_INTERLEAVED ) ; } if ( force_co64 ) gf_isom_force_64bit_chunk_offset ( file , GF_TRUE ) ; if ( compress_moov ) gf_isom_enable_compression ( file , GF_ISO_COMP_MOOV , GF_FALSE ) ; if ( e ) goto err_exit ; if ( ! encode && ! force_new ) gf_isom_set_final_name ( file , outfile ) ; if ( needSave ) { if ( ! gf_sys_is_quiet ( ) ) { if ( outName ) { gf_isom_set_final_name ( file , outfile ) ; } else if ( encode || pack_file ) { fprintf ( stderr , \"Saving<S2SV_blank>to<S2SV_blank>%s:<S2SV_blank>\" , gf_isom_get_filename ( file ) ) ; } else { fprintf ( stderr , \"Saving<S2SV_blank>%s:<S2SV_blank>\" , inName ) ; } if ( HintIt && FullInter ) fprintf ( stderr , \"Hinted<S2SV_blank>file<S2SV_blank>-<S2SV_blank>Full<S2SV_blank>Interleaving\\\\n\" ) ; else if ( FullInter ) fprintf ( stderr , \"Full<S2SV_blank>Interleaving\\\\n\" ) ; else if ( ( force_new == 2 ) && interleaving_time ) fprintf ( stderr , \"Fast-start<S2SV_blank>interleaved<S2SV_blank>storage\\\\n\" ) ; else if ( do_flat || ! interleaving_time ) fprintf ( stderr , \"Flat<S2SV_blank>storage\\\\n\" ) ; else fprintf ( stderr , \"%.3f<S2SV_blank>secs<S2SV_blank>Interleaving%s\\\\n\" , interleaving_time , old_interleave ? \"<S2SV_blank>-<S2SV_blank>no<S2SV_blank>drift<S2SV_blank>control\" : \"\" ) ; } else { if ( outName ) gf_isom_set_final_name ( file , outfile ) ; } e = gf_isom_close ( file ) ; file = NULL ; if ( ! e && ! outName && ! encode && ! force_new && ! pack_file ) { if ( gf_file_exists ( inName ) ) { e = gf_file_delete ( inName ) ; if ( e ) { fprintf ( stderr , \"Error<S2SV_blank>removing<S2SV_blank>file<S2SV_blank>%s\\\\n\" , inName ) ; } } e = gf_file_move ( outfile , inName ) ; if ( e ) { fprintf ( stderr , \"Error<S2SV_blank>renaming<S2SV_blank>file<S2SV_blank>%s<S2SV_blank>to<S2SV_blank>%s\\\\n\" , outfile , inName ) ; } } } else { gf_isom_delete ( file ) ; } if ( e ) { fprintf ( stderr , \"Error:<S2SV_blank>%s\\\\n\" , gf_error_to_string ( e ) ) ; goto err_exit ; } goto exit ; # else gf_isom_delete ( file ) ; fprintf ( stderr , \"Error:<S2SV_blank>Read-only<S2SV_blank>version<S2SV_blank>of<S2SV_blank>MP4Box.\\\\n\" ) ; return mp4box_cleanup ( 1 ) ; # endif err_exit : if ( file ) gf_isom_delete ( file ) ; fprintf ( stderr , \"\\\\n\\\\tError:<S2SV_blank>%s\\\\n\" , gf_error_to_string ( e ) ) ; return mp4box_cleanup ( 1 ) ; exit : mp4box_cleanup ( 0 ) ; # ifdef GPAC_MEMORY_TRACKING if ( mem_track && ( gf_memory_size ( ) || gf_file_handles_count ( ) ) ) { gf_log_set_tool_level ( GF_LOG_MEMORY , GF_LOG_INFO ) ; gf_memory_print ( ) ; return 2 ; } # endif return 0 ; }\n",
      "fixed_code": "<S2SV_ModStart> ( stderr , \"File<S2SV_blank>%s<S2SV_blank>has<S2SV_blank>no<S2SV_blank>IOD\\\\n\" <S2SV_ModEnd> , inName )\n",
      "source_code_length": 70814,
      "target_code_length": 120,
      "vulnerability_patterns": {
        "buffer_overflow": 43,
        "use_after_free": 10,
        "integer_overflow": 36,
        "format_string": 115,
        "null_pointer": 270,
        "total": 474
      },
      "total_patterns": 474,
      "original_address": "https://github.com/gpac/gpac/commit/9eeac00b38348c664dfeae2525bba0cf1bc32349",
      "discovery_time": "2021-04-21T18:15Z",
      "project_commit_id": "gpac@gpac/9eeac00b38348c664dfeae2525bba0cf1bc32349",
      "extraction_time": "2025-08-31T15:41:49.180315",
      "label": 1,
      "vulnerability_type": "null_pointer_dereference",
      "difficulty_level": "expert",
      "risk_factors": [
        "denial_of_service",
        "memory_corruption",
        "buffer_overflow",
        "system_crash",
        "use_after_free"
      ],
      "attack_vectors": [
        "memory_manipulation",
        "null_pointer",
        "code_analysis",
        "reverse_engineering",
        "use_after_free",
        "fuzzing"
      ],
      "mitigation_strategies": [
        "null_pointer_checks",
        "fuzzing",
        "dynamic_analysis",
        "memory_management",
        "static_analysis",
        "use_after_free_prevention",
        "code_review",
        "secure_coding_practices"
      ],
      "code_differences": {
        "has_differences": true,
        "source_lines": 2,
        "target_lines": 2,
        "character_differences": 70694,
        "similarity_percentage": 0.4807692307692308
      },
      "vulnerability_location": {
        "vulnerability_present": true,
        "fix_applied": true,
        "code_changed": true,
        "estimated_lines_changed": 0
      }
    },
    {
      "cve_id": "CVE-2019-19645",
      "cwe_id": "CWE-674",
      "cwe_name": "Uncontrolled Recursion",
      "project": "sqlite",
      "severity": "critical",
      "weaponization_score": 9.0,
      "is_critical": true,
      "is_weaponizable": true,
      "is_high_priority_project": true,
      "vulnerable_code": "CWE-674 static int renameUnmapSelectCb ( Walker * pWalker , Select * p ) { Parse * pParse = pWalker -> pParse ; int i ; if ( pParse -> nErr ) return WRC_Abort ; <S2SV_StartBug> if ( ALWAYS ( p -> pEList ) ) { <S2SV_EndBug> ExprList * pList = p -> pEList ; for ( i = 0 ; i < pList -> nExpr ; i ++ ) { if ( pList -> a [ i ] . zName ) { sqlite3RenameTokenRemap ( pParse , 0 , ( void * ) pList -> a [ i ] . zName ) ; } } } if ( ALWAYS ( p -> pSrc ) ) { SrcList * pSrc = p -> pSrc ; for ( i = 0 ; i < pSrc -> nSrc ; i ++ ) { sqlite3RenameTokenRemap ( pParse , 0 , ( void * ) pSrc -> a [ i ] . zName ) ; } } renameWalkWith ( pWalker , p ) ; return WRC_Continue ; }\n",
      "fixed_code": "<S2SV_ModStart> ; if ( p -> selFlags & SF_View ) return WRC_Prune ; if (\n",
      "source_code_length": 659,
      "target_code_length": 73,
      "vulnerability_patterns": {
        "integer_overflow": 2,
        "null_pointer": 11,
        "sql_injection": 1,
        "total": 14
      },
      "total_patterns": 14,
      "original_address": "https://github.com/sqlite/sqlite/commit/38096961c7cd109110ac21d3ed7dad7e0cb0ae06",
      "discovery_time": "2019-12-09T16:15Z",
      "project_commit_id": "sqlite@sqlite/38096961c7cd109110ac21d3ed7dad7e0cb0ae06",
      "extraction_time": "2025-08-31T15:41:49.180821",
      "label": 1,
      "vulnerability_type": "uncontrolled_recursion",
      "difficulty_level": "expert",
      "risk_factors": [
        "critical_infrastructure",
        "sql_injection"
      ],
      "attack_vectors": [
        "fuzzing",
        "code_analysis",
        "reverse_engineering"
      ],
      "mitigation_strategies": [
        "dynamic_analysis",
        "static_analysis",
        "fuzzing",
        "code_review",
        "secure_coding_practices"
      ],
      "code_differences": {
        "has_differences": true,
        "source_lines": 2,
        "target_lines": 2,
        "character_differences": 586,
        "similarity_percentage": 13.461538461538462
      },
      "vulnerability_location": {
        "vulnerability_present": true,
        "fix_applied": true,
        "code_changed": true,
        "estimated_lines_changed": 0
      }
    },
    {
      "cve_id": "CVE-2014-3631",
      "cwe_id": "CWE-000",
      "cwe_name": "Unknown/Uncategorized",
      "project": "torvalds",
      "severity": "critical",
      "weaponization_score": 8.5,
      "is_critical": true,
      "is_weaponizable": true,
      "is_high_priority_project": false,
      "vulnerable_code": "CWE-000 int assoc_array_gc ( struct assoc_array * array , const struct assoc_array_ops * ops , bool ( * iterator ) ( void * object , void * iterator_data ) , void * iterator_data ) { struct assoc_array_shortcut * shortcut , * new_s ; struct assoc_array_node * node , * new_n ; struct assoc_array_edit * edit ; struct assoc_array_ptr * cursor , * ptr ; struct assoc_array_ptr * new_root , * new_parent , * * new_ptr_pp ; unsigned long nr_leaves_on_tree ; int keylen , slot , nr_free , next_slot , i ; pr_devel ( \"-->%s()\\\\n\" , __func__ ) ; if ( ! array -> root ) return 0 ; edit = kzalloc ( sizeof ( struct assoc_array_edit ) , GFP_KERNEL ) ; if ( ! edit ) return - ENOMEM ; edit -> array = array ; edit -> ops = ops ; edit -> ops_for_excised_subtree = ops ; edit -> set [ 0 ] . ptr = & array -> root ; edit -> excised_subtree = array -> root ; new_root = new_parent = NULL ; new_ptr_pp = & new_root ; cursor = array -> root ; descend : if ( assoc_array_ptr_is_shortcut ( cursor ) ) { shortcut = assoc_array_ptr_to_shortcut ( cursor ) ; keylen = round_up ( shortcut -> skip_to_level , ASSOC_ARRAY_KEY_CHUNK_SIZE ) ; keylen >>= ASSOC_ARRAY_KEY_CHUNK_SHIFT ; new_s = kmalloc ( sizeof ( struct assoc_array_shortcut ) + keylen * sizeof ( unsigned long ) , GFP_KERNEL ) ; if ( ! new_s ) goto enomem ; pr_devel ( \"dup<S2SV_blank>shortcut<S2SV_blank>%p<S2SV_blank>-><S2SV_blank>%p\\\\n\" , shortcut , new_s ) ; memcpy ( new_s , shortcut , ( sizeof ( struct assoc_array_shortcut ) + keylen * sizeof ( unsigned long ) ) ) ; new_s -> back_pointer = new_parent ; new_s -> parent_slot = shortcut -> parent_slot ; * new_ptr_pp = new_parent = assoc_array_shortcut_to_ptr ( new_s ) ; new_ptr_pp = & new_s -> next_node ; cursor = shortcut -> next_node ; } node = assoc_array_ptr_to_node ( cursor ) ; new_n = kzalloc ( sizeof ( struct assoc_array_node ) , GFP_KERNEL ) ; if ( ! new_n ) goto enomem ; pr_devel ( \"dup<S2SV_blank>node<S2SV_blank>%p<S2SV_blank>-><S2SV_blank>%p\\\\n\" , node , new_n ) ; new_n -> back_pointer = new_parent ; new_n -> parent_slot = node -> parent_slot ; * new_ptr_pp = new_parent = assoc_array_node_to_ptr ( new_n ) ; new_ptr_pp = NULL ; slot = 0 ; continue_node : for ( ; slot < ASSOC_ARRAY_FAN_OUT ; slot ++ ) { ptr = node -> slots [ slot ] ; if ( ! ptr ) continue ; if ( assoc_array_ptr_is_leaf ( ptr ) ) { if ( iterator ( assoc_array_ptr_to_leaf ( ptr ) , iterator_data ) ) new_n -> slots [ slot ] = ptr ; continue ; } new_ptr_pp = & new_n -> slots [ slot ] ; cursor = ptr ; goto descend ; } pr_devel ( \"--<S2SV_blank>compress<S2SV_blank>node<S2SV_blank>%p<S2SV_blank>--\\\\n\" , new_n ) ; new_n -> nr_leaves_on_branch = 0 ; nr_free = 0 ; for ( slot = 0 ; slot < ASSOC_ARRAY_FAN_OUT ; slot ++ ) { ptr = new_n -> slots [ slot ] ; if ( ! ptr ) nr_free ++ ; else if ( assoc_array_ptr_is_leaf ( ptr ) ) new_n -> nr_leaves_on_branch ++ ; } pr_devel ( \"free=%d,<S2SV_blank>leaves=%lu\\\\n\" , nr_free , new_n -> nr_leaves_on_branch ) ; next_slot = 0 ; for ( slot = 0 ; slot < ASSOC_ARRAY_FAN_OUT ; slot ++ ) { struct assoc_array_shortcut * s ; struct assoc_array_node * child ; ptr = new_n -> slots [ slot ] ; if ( ! ptr || assoc_array_ptr_is_leaf ( ptr ) ) continue ; s = NULL ; if ( assoc_array_ptr_is_shortcut ( ptr ) ) { s = assoc_array_ptr_to_shortcut ( ptr ) ; ptr = s -> next_node ; } child = assoc_array_ptr_to_node ( ptr ) ; new_n -> nr_leaves_on_branch += child -> nr_leaves_on_branch ; if ( child -> nr_leaves_on_branch <= nr_free + 1 ) { pr_devel ( \"[%d]<S2SV_blank>fold<S2SV_blank>node<S2SV_blank>%lu/%d<S2SV_blank>[nx<S2SV_blank>%d]\\\\n\" , slot , child -> nr_leaves_on_branch , nr_free + 1 , next_slot ) ; BUG_ON ( s ) ; new_n -> slots [ slot ] = NULL ; nr_free ++ ; if ( slot < next_slot ) next_slot = slot ; for ( i = 0 ; i < ASSOC_ARRAY_FAN_OUT ; i ++ ) { struct assoc_array_ptr * p = child -> slots [ i ] ; if ( ! p ) continue ; BUG_ON ( assoc_array_ptr_is_meta ( p ) ) ; while ( new_n -> slots [ next_slot ] ) next_slot ++ ; BUG_ON ( next_slot >= ASSOC_ARRAY_FAN_OUT ) ; new_n -> slots [ next_slot ++ ] = p ; nr_free -- ; } kfree ( child ) ; } else { pr_devel ( \"[%d]<S2SV_blank>retain<S2SV_blank>node<S2SV_blank>%lu/%d<S2SV_blank>[nx<S2SV_blank>%d]\\\\n\" , slot , child -> nr_leaves_on_branch , nr_free + 1 , next_slot ) ; } } pr_devel ( \"after:<S2SV_blank>%lu\\\\n\" , new_n -> nr_leaves_on_branch ) ; nr_leaves_on_tree = new_n -> nr_leaves_on_branch ; if ( nr_free == ASSOC_ARRAY_FAN_OUT - 1 ) { for ( slot = 0 ; slot < ASSOC_ARRAY_FAN_OUT ; slot ++ ) if ( ( ptr = new_n -> slots [ slot ] ) ) break ; if ( assoc_array_ptr_is_meta ( ptr ) && assoc_array_ptr_is_shortcut ( ptr ) ) { pr_devel ( \"excise<S2SV_blank>node<S2SV_blank>%p<S2SV_blank>with<S2SV_blank>1<S2SV_blank>shortcut\\\\n\" , new_n ) ; new_s = assoc_array_ptr_to_shortcut ( ptr ) ; new_parent = new_n -> back_pointer ; slot = new_n -> parent_slot ; kfree ( new_n ) ; if ( ! new_parent ) { new_s -> back_pointer = NULL ; new_s -> parent_slot = 0 ; new_root = ptr ; goto gc_complete ; } if ( assoc_array_ptr_is_shortcut ( new_parent ) ) { struct assoc_array_shortcut * s = assoc_array_ptr_to_shortcut ( new_parent ) ; pr_devel ( \"excise<S2SV_blank>preceding<S2SV_blank>shortcut\\\\n\" ) ; new_parent = new_s -> back_pointer = s -> back_pointer ; slot = new_s -> parent_slot = s -> parent_slot ; kfree ( s ) ; if ( ! new_parent ) { new_s -> back_pointer = NULL ; new_s -> parent_slot = 0 ; new_root = ptr ; goto gc_complete ; } } new_s -> back_pointer = new_parent ; new_s -> parent_slot = slot ; new_n = assoc_array_ptr_to_node ( new_parent ) ; new_n -> slots [ slot ] = ptr ; goto ascend_old_tree ; } } ptr = new_n -> back_pointer ; if ( ! ptr ) goto gc_complete ; if ( assoc_array_ptr_is_shortcut ( ptr ) ) { new_s = assoc_array_ptr_to_shortcut ( ptr ) ; new_parent = new_s -> back_pointer ; slot = new_s -> parent_slot ; if ( new_n -> nr_leaves_on_branch <= ASSOC_ARRAY_FAN_OUT ) { struct assoc_array_node * n ; pr_devel ( \"excise<S2SV_blank>shortcut\\\\n\" ) ; new_n -> back_pointer = new_parent ; new_n -> parent_slot = slot ; kfree ( new_s ) ; if ( ! new_parent ) { new_root = assoc_array_node_to_ptr ( new_n ) ; goto gc_complete ; } n = assoc_array_ptr_to_node ( new_parent ) ; n -> slots [ slot ] = assoc_array_node_to_ptr ( new_n ) ; } } else { new_parent = ptr ; } new_n = assoc_array_ptr_to_node ( new_parent ) ; ascend_old_tree : ptr = node -> back_pointer ; if ( assoc_array_ptr_is_shortcut ( ptr ) ) { shortcut = assoc_array_ptr_to_shortcut ( ptr ) ; slot = shortcut -> parent_slot ; cursor = shortcut -> back_pointer ; <S2SV_StartBug> } else { <S2SV_EndBug> slot = node -> parent_slot ; cursor = ptr ; } <S2SV_StartBug> BUG_ON ( ! ptr ) ; <S2SV_EndBug> node = assoc_array_ptr_to_node ( cursor ) ; slot ++ ; goto continue_node ; gc_complete : edit -> set [ 0 ] . to = new_root ; assoc_array_apply_edit ( edit ) ; array -> nr_leaves_on_tree = nr_leaves_on_tree ; return 0 ; enomem : pr_devel ( \"enomem\\\\n\" ) ; assoc_array_destroy_subtree ( new_root , edit -> ops ) ; kfree ( edit ) ; return - ENOMEM ; }\n",
      "fixed_code": "<S2SV_ModStart> -> back_pointer ; if ( ! cursor ) goto gc_complete ; <S2SV_ModStart> BUG_ON ( ! cursor <S2SV_ModEnd> ) ; node\n",
      "source_code_length": 6980,
      "target_code_length": 126,
      "vulnerability_patterns": {
        "buffer_overflow": 1,
        "use_after_free": 97,
        "integer_overflow": 16,
        "null_pointer": 86,
        "memory_leak": 1,
        "total": 201
      },
      "total_patterns": 201,
      "original_address": "https://github.com/torvalds/linux/commit/95389b08d93d5c06ec63ab49bd732b0069b7c35e",
      "discovery_time": "2014-09-28T10:55Z",
      "project_commit_id": "torvalds@linux/95389b08d93d5c06ec63ab49bd732b0069b7c35e",
      "extraction_time": "2025-08-31T15:41:49.180835",
      "label": 1,
      "vulnerability_type": "unknown/uncategorized",
      "difficulty_level": "advanced",
      "risk_factors": [
        "buffer_overflow",
        "use_after_free"
      ],
      "attack_vectors": [
        "fuzzing",
        "code_analysis",
        "reverse_engineering"
      ],
      "mitigation_strategies": [
        "dynamic_analysis",
        "static_analysis",
        "fuzzing",
        "code_review",
        "secure_coding_practices"
      ],
      "code_differences": {
        "has_differences": true,
        "source_lines": 2,
        "target_lines": 2,
        "character_differences": 6854,
        "similarity_percentage": 8.955223880597014
      },
      "vulnerability_location": {
        "vulnerability_present": true,
        "fix_applied": true,
        "code_changed": true,
        "estimated_lines_changed": 0
      }
    },
    {
      "cve_id": "CVE-2016-1621",
      "cwe_id": "CWE-119",
      "cwe_name": "Buffer Overflow",
      "project": "external",
      "severity": "critical",
      "weaponization_score": 8.5,
      "is_critical": true,
      "is_weaponizable": true,
      "is_high_priority_project": false,
      "vulnerable_code": "CWE-119 int main ( int argc , char * * argv ) { int frame_cnt = 0 ; FILE * outfile = NULL ; vpx_codec_ctx_t codec ; const VpxInterface * decoder = NULL ; VpxVideoReader * reader = NULL ; const VpxVideoInfo * info = NULL ; int n = 0 ; int m = 0 ; int is_range = 0 ; char * nptr = NULL ; exec_name = argv [ 0 ] ; if ( argc != 4 ) die ( \"Invalid<S2SV_blank>number<S2SV_blank>of<S2SV_blank>arguments.\" ) ; reader = vpx_video_reader_open ( argv [ 1 ] ) ; if ( ! reader ) die ( \"Failed<S2SV_blank>to<S2SV_blank>open<S2SV_blank>%s<S2SV_blank>for<S2SV_blank>reading.\" , argv [ 1 ] ) ; if ( ! ( outfile = fopen ( argv [ 2 ] , \"wb\" ) ) ) die ( \"Failed<S2SV_blank>to<S2SV_blank>open<S2SV_blank>%s<S2SV_blank>for<S2SV_blank>writing.\" , argv [ 2 ] ) ; n = strtol ( argv [ 3 ] , & nptr , 0 ) ; m = strtol ( nptr + 1 , NULL , 0 ) ; is_range = ( * nptr == '-' ) ; if ( ! n || ! m || ( * nptr != '-' && * nptr != '/' ) ) die ( \"Couldn\\'t<S2SV_blank>parse<S2SV_blank>pattern<S2SV_blank>%s.\\\\n\" , argv [ 3 ] ) ; info = vpx_video_reader_get_info ( reader ) ; decoder = get_vpx_decoder_by_fourcc ( info -> codec_fourcc ) ; if ( ! decoder ) die ( \"Unknown<S2SV_blank>input<S2SV_blank>codec.\" ) ; <S2SV_StartBug> printf ( \"Using<S2SV_blank>%s\\\\n\" , vpx_codec_iface_name ( decoder -> interface ( ) ) ) ; <S2SV_EndBug> <S2SV_StartBug> if ( vpx_codec_dec_init ( & codec , decoder -> interface ( ) , NULL , 0 ) ) <S2SV_EndBug> die_codec ( & codec , \"Failed<S2SV_blank>to<S2SV_blank>initialize<S2SV_blank>decoder.\" ) ; while ( vpx_video_reader_read_frame ( reader ) ) { vpx_codec_iter_t iter = NULL ; vpx_image_t * img = NULL ; size_t frame_size = 0 ; int skip ; const unsigned char * frame = vpx_video_reader_get_frame ( reader , & frame_size ) ; if ( vpx_codec_decode ( & codec , frame , ( unsigned int ) frame_size , NULL , 0 ) ) die_codec ( & codec , \"Failed<S2SV_blank>to<S2SV_blank>decode<S2SV_blank>frame.\" ) ; ++ frame_cnt ; skip = ( is_range && frame_cnt >= n && frame_cnt <= m ) || ( ! is_range && m - ( frame_cnt - 1 ) % m <= n ) ; if ( ! skip ) { putc ( '.' , stdout ) ; while ( ( img = vpx_codec_get_frame ( & codec , & iter ) ) != NULL ) vpx_img_write ( img , outfile ) ; } else { putc ( 'X' , stdout ) ; } fflush ( stdout ) ; } printf ( \"Processed<S2SV_blank>%d<S2SV_blank>frames.\\\\n\" , frame_cnt ) ; if ( vpx_codec_destroy ( & codec ) ) die_codec ( & codec , \"Failed<S2SV_blank>to<S2SV_blank>destroy<S2SV_blank>codec.\" ) ; printf ( \"Play:<S2SV_blank>ffplay<S2SV_blank>-f<S2SV_blank>rawvideo<S2SV_blank>-pix_fmt<S2SV_blank>yuv420p<S2SV_blank>-s<S2SV_blank>%dx%d<S2SV_blank>%s\\\\n\" , info -> frame_width , info -> frame_height , argv [ 2 ] ) ; vpx_video_reader_close ( reader ) ; fclose ( outfile ) ; return EXIT_SUCCESS ; }\n",
      "fixed_code": "<S2SV_ModStart> ( decoder -> codec_interface <S2SV_ModEnd> ( ) ) <S2SV_ModStart> , decoder -> codec_interface <S2SV_ModEnd> ( ) ,\n",
      "source_code_length": 2710,
      "target_code_length": 130,
      "vulnerability_patterns": {
        "buffer_overflow": 1,
        "integer_overflow": 11,
        "null_pointer": 158,
        "total": 170
      },
      "total_patterns": 170,
      "original_address": "https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426",
      "discovery_time": "2016-03-12T21:59Z",
      "project_commit_id": "external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426",
      "extraction_time": "2025-08-31T15:41:49.180887",
      "label": 1,
      "vulnerability_type": "buffer_overflow",
      "difficulty_level": "advanced",
      "risk_factors": [
        "system_crash",
        "memory_corruption",
        "buffer_overflow",
        "arbitrary_code_execution"
      ],
      "attack_vectors": [
        "memory_manipulation",
        "malicious_input",
        "code_analysis",
        "buffer_overflow",
        "reverse_engineering",
        "fuzzing"
      ],
      "mitigation_strategies": [
        "safe_string_functions",
        "dynamic_analysis",
        "code_review",
        "static_analysis",
        "memory_safety_checks",
        "input_validation",
        "fuzzing",
        "bounds_checking",
        "secure_coding_practices"
      ],
      "code_differences": {
        "has_differences": true,
        "source_lines": 2,
        "target_lines": 2,
        "character_differences": 2580,
        "similarity_percentage": 4.464285714285714
      },
      "vulnerability_location": {
        "vulnerability_present": true,
        "fix_applied": true,
        "code_changed": true,
        "estimated_lines_changed": 0
      }
    },
    {
      "cve_id": "CVE-2019-1010297",
      "cwe_id": "CWE-119",
      "cwe_name": "Buffer Overflow",
      "project": "OP-TEE",
      "severity": "critical",
      "weaponization_score": 8.5,
      "is_critical": true,
      "is_weaponizable": true,
      "is_high_priority_project": false,
      "vulnerable_code": "CWE-119 TEE_Result syscall_cryp_derive_key ( unsigned long state , const struct utee_attribute * usr_params , unsigned long param_count , unsigned long derived_key ) { TEE_Result res = TEE_ERROR_NOT_SUPPORTED ; struct tee_ta_session * sess ; struct tee_obj * ko ; struct tee_obj * so ; struct tee_cryp_state * cs ; struct tee_cryp_obj_secret * sk ; const struct tee_cryp_obj_type_props * type_props ; TEE_Attribute * params = NULL ; struct user_ta_ctx * utc ; res = tee_ta_get_current_session ( & sess ) ; if ( res != TEE_SUCCESS ) return res ; utc = to_user_ta_ctx ( sess -> ctx ) ; res = tee_svc_cryp_get_state ( sess , tee_svc_uref_to_vaddr ( state ) , & cs ) ; if ( res != TEE_SUCCESS ) return res ; <S2SV_StartBug> params = malloc ( sizeof ( TEE_Attribute ) * param_count ) ; <S2SV_EndBug> if ( ! params ) return TEE_ERROR_OUT_OF_MEMORY ; res = copy_in_attrs ( utc , usr_params , param_count , params ) ; if ( res != TEE_SUCCESS ) goto out ; res = tee_obj_get ( utc , cs -> key1 , & ko ) ; if ( res != TEE_SUCCESS ) goto out ; res = tee_obj_get ( utc , tee_svc_uref_to_vaddr ( derived_key ) , & so ) ; if ( res != TEE_SUCCESS ) goto out ; sk = so -> attr ; type_props = tee_svc_find_type_props ( so -> info . objectType ) ; if ( ! type_props ) { res = TEE_ERROR_NOT_SUPPORTED ; goto out ; } if ( cs -> algo == TEE_ALG_DH_DERIVE_SHARED_SECRET ) { size_t alloc_size ; struct bignum * pub ; struct bignum * ss ; if ( param_count != 1 || params [ 0 ] . attributeID != TEE_ATTR_DH_PUBLIC_VALUE ) { res = TEE_ERROR_BAD_PARAMETERS ; goto out ; } alloc_size = params [ 0 ] . content . ref . length * 8 ; pub = crypto_bignum_allocate ( alloc_size ) ; ss = crypto_bignum_allocate ( alloc_size ) ; if ( pub && ss ) { crypto_bignum_bin2bn ( params [ 0 ] . content . ref . buffer , params [ 0 ] . content . ref . length , pub ) ; res = crypto_acipher_dh_shared_secret ( ko -> attr , pub , ss ) ; if ( res == TEE_SUCCESS ) { sk -> key_size = crypto_bignum_num_bytes ( ss ) ; crypto_bignum_bn2bin ( ss , ( uint8_t * ) ( sk + 1 ) ) ; so -> info . handleFlags |= TEE_HANDLE_FLAG_INITIALIZED ; set_attribute ( so , type_props , TEE_ATTR_SECRET_VALUE ) ; } } else { res = TEE_ERROR_OUT_OF_MEMORY ; } crypto_bignum_free ( pub ) ; crypto_bignum_free ( ss ) ; } else if ( TEE_ALG_GET_MAIN_ALG ( cs -> algo ) == TEE_MAIN_ALGO_ECDH ) { size_t alloc_size ; struct ecc_public_key key_public ; uint8_t * pt_secret ; unsigned long pt_secret_len ; if ( param_count != 2 || params [ 0 ] . attributeID != TEE_ATTR_ECC_PUBLIC_VALUE_X || params [ 1 ] . attributeID != TEE_ATTR_ECC_PUBLIC_VALUE_Y ) { res = TEE_ERROR_BAD_PARAMETERS ; goto out ; } switch ( cs -> algo ) { case TEE_ALG_ECDH_P192 : alloc_size = 192 ; break ; case TEE_ALG_ECDH_P224 : alloc_size = 224 ; break ; case TEE_ALG_ECDH_P256 : alloc_size = 256 ; break ; case TEE_ALG_ECDH_P384 : alloc_size = 384 ; break ; case TEE_ALG_ECDH_P521 : alloc_size = 521 ; break ; default : res = TEE_ERROR_NOT_IMPLEMENTED ; goto out ; } res = crypto_acipher_alloc_ecc_public_key ( & key_public , alloc_size ) ; if ( res != TEE_SUCCESS ) goto out ; key_public . curve = ( ( struct ecc_keypair * ) ko -> attr ) -> curve ; crypto_bignum_bin2bn ( params [ 0 ] . content . ref . buffer , params [ 0 ] . content . ref . length , key_public . x ) ; crypto_bignum_bin2bn ( params [ 1 ] . content . ref . buffer , params [ 1 ] . content . ref . length , key_public . y ) ; pt_secret = ( uint8_t * ) ( sk + 1 ) ; pt_secret_len = sk -> alloc_size ; res = crypto_acipher_ecc_shared_secret ( ko -> attr , & key_public , pt_secret , & pt_secret_len ) ; if ( res == TEE_SUCCESS ) { sk -> key_size = pt_secret_len ; so -> info . handleFlags |= TEE_HANDLE_FLAG_INITIALIZED ; set_attribute ( so , type_props , TEE_ATTR_SECRET_VALUE ) ; } crypto_acipher_free_ecc_public_key ( & key_public ) ; } # if defined ( CFG_CRYPTO_HKDF ) else if ( TEE_ALG_GET_MAIN_ALG ( cs -> algo ) == TEE_MAIN_ALGO_HKDF ) { void * salt , * info ; size_t salt_len , info_len , okm_len ; uint32_t hash_id = TEE_ALG_GET_DIGEST_HASH ( cs -> algo ) ; struct tee_cryp_obj_secret * ik = ko -> attr ; const uint8_t * ikm = ( const uint8_t * ) ( ik + 1 ) ; res = get_hkdf_params ( params , param_count , & salt , & salt_len , & info , & info_len , & okm_len ) ; if ( res != TEE_SUCCESS ) goto out ; if ( okm_len > ik -> alloc_size ) { res = TEE_ERROR_BAD_PARAMETERS ; goto out ; } res = tee_cryp_hkdf ( hash_id , ikm , ik -> key_size , salt , salt_len , info , info_len , ( uint8_t * ) ( sk + 1 ) , okm_len ) ; if ( res == TEE_SUCCESS ) { sk -> key_size = okm_len ; so -> info . handleFlags |= TEE_HANDLE_FLAG_INITIALIZED ; set_attribute ( so , type_props , TEE_ATTR_SECRET_VALUE ) ; } } # endif # if defined ( CFG_CRYPTO_CONCAT_KDF ) else if ( TEE_ALG_GET_MAIN_ALG ( cs -> algo ) == TEE_MAIN_ALGO_CONCAT_KDF ) { void * info ; size_t info_len , derived_key_len ; uint32_t hash_id = TEE_ALG_GET_DIGEST_HASH ( cs -> algo ) ; struct tee_cryp_obj_secret * ss = ko -> attr ; const uint8_t * shared_secret = ( const uint8_t * ) ( ss + 1 ) ; res = get_concat_kdf_params ( params , param_count , & info , & info_len , & derived_key_len ) ; if ( res != TEE_SUCCESS ) goto out ; if ( derived_key_len > ss -> alloc_size ) { res = TEE_ERROR_BAD_PARAMETERS ; goto out ; } res = tee_cryp_concat_kdf ( hash_id , shared_secret , ss -> key_size , info , info_len , ( uint8_t * ) ( sk + 1 ) , derived_key_len ) ; if ( res == TEE_SUCCESS ) { sk -> key_size = derived_key_len ; so -> info . handleFlags |= TEE_HANDLE_FLAG_INITIALIZED ; set_attribute ( so , type_props , TEE_ATTR_SECRET_VALUE ) ; } } # endif # if defined ( CFG_CRYPTO_PBKDF2 ) else if ( TEE_ALG_GET_MAIN_ALG ( cs -> algo ) == TEE_MAIN_ALGO_PBKDF2 ) { void * salt ; size_t salt_len , iteration_count , derived_key_len ; uint32_t hash_id = TEE_ALG_GET_DIGEST_HASH ( cs -> algo ) ; struct tee_cryp_obj_secret * ss = ko -> attr ; const uint8_t * password = ( const uint8_t * ) ( ss + 1 ) ; res = get_pbkdf2_params ( params , param_count , & salt , & salt_len , & derived_key_len , & iteration_count ) ; if ( res != TEE_SUCCESS ) goto out ; if ( derived_key_len > ss -> alloc_size ) { res = TEE_ERROR_BAD_PARAMETERS ; goto out ; } res = tee_cryp_pbkdf2 ( hash_id , password , ss -> key_size , salt , salt_len , iteration_count , ( uint8_t * ) ( sk + 1 ) , derived_key_len ) ; if ( res == TEE_SUCCESS ) { sk -> key_size = derived_key_len ; so -> info . handleFlags |= TEE_HANDLE_FLAG_INITIALIZED ; set_attribute ( so , type_props , TEE_ATTR_SECRET_VALUE ) ; } } # endif else res = TEE_ERROR_NOT_SUPPORTED ; out : free ( params ) ; return res ; }\n",
      "fixed_code": "<S2SV_ModStart> return res ; size_t alloc_size = 0 ; if ( MUL_OVERFLOW ( sizeof ( TEE_Attribute ) , param_count , & alloc_size ) ) return TEE_ERROR_OVERFLOW ; <S2SV_ModStart> = malloc ( alloc_size <S2SV_ModEnd> ) ; if\n",
      "source_code_length": 6556,
      "target_code_length": 218,
      "vulnerability_patterns": {
        "use_after_free": 2,
        "null_pointer": 41,
        "memory_leak": 1,
        "total": 44
      },
      "total_patterns": 44,
      "original_address": "https://github.com/OP-TEE/optee_os/commit/a637243270fc1faae16de059091795c32d86e65e",
      "discovery_time": "2019-07-15T18:15Z",
      "project_commit_id": "OP-TEE@optee_os/a637243270fc1faae16de059091795c32d86e65e",
      "extraction_time": "2025-08-31T15:41:49.180913",
      "label": 1,
      "vulnerability_type": "buffer_overflow",
      "difficulty_level": "advanced",
      "risk_factors": [
        "system_crash",
        "memory_corruption",
        "arbitrary_code_execution",
        "use_after_free"
      ],
      "attack_vectors": [
        "memory_manipulation",
        "malicious_input",
        "code_analysis",
        "buffer_overflow",
        "reverse_engineering",
        "fuzzing"
      ],
      "mitigation_strategies": [
        "safe_string_functions",
        "dynamic_analysis",
        "code_review",
        "static_analysis",
        "memory_safety_checks",
        "input_validation",
        "fuzzing",
        "bounds_checking",
        "secure_coding_practices"
      ],
      "code_differences": {
        "has_differences": true,
        "source_lines": 2,
        "target_lines": 2,
        "character_differences": 6338,
        "similarity_percentage": 9.467455621301776
      },
      "vulnerability_location": {
        "vulnerability_present": true,
        "fix_applied": true,
        "code_changed": true,
        "estimated_lines_changed": 0
      }
    },
    {
      "cve_id": "CVE-2016-1621",
      "cwe_id": "CWE-119",
      "cwe_name": "Buffer Overflow",
      "project": "external",
      "severity": "critical",
      "weaponization_score": 8.5,
      "is_critical": true,
      "is_weaponizable": true,
      "is_high_priority_project": false,
      "vulnerable_code": "CWE-119 int main ( int argc , char * * argv ) { int frame_cnt = 0 ; FILE * outfile = NULL ; vpx_codec_ctx_t codec ; const VpxInterface * decoder = NULL ; VpxVideoReader * reader = NULL ; const VpxVideoInfo * info = NULL ; int n = 0 ; int m = 0 ; int is_range = 0 ; char * nptr = NULL ; exec_name = argv [ 0 ] ; if ( argc != 4 ) die ( \"Invalid<S2SV_blank>number<S2SV_blank>of<S2SV_blank>arguments.\" ) ; reader = vpx_video_reader_open ( argv [ 1 ] ) ; if ( ! reader ) die ( \"Failed<S2SV_blank>to<S2SV_blank>open<S2SV_blank>%s<S2SV_blank>for<S2SV_blank>reading.\" , argv [ 1 ] ) ; if ( ! ( outfile = fopen ( argv [ 2 ] , \"wb\" ) ) ) die ( \"Failed<S2SV_blank>to<S2SV_blank>open<S2SV_blank>%s<S2SV_blank>for<S2SV_blank>writing.\" , argv [ 2 ] ) ; n = strtol ( argv [ 3 ] , & nptr , 0 ) ; m = strtol ( nptr + 1 , NULL , 0 ) ; is_range = ( * nptr == '-' ) ; if ( ! n || ! m || ( * nptr != '-' && * nptr != '/' ) ) die ( \"Couldn\\'t<S2SV_blank>parse<S2SV_blank>pattern<S2SV_blank>%s.\\\\n\" , argv [ 3 ] ) ; info = vpx_video_reader_get_info ( reader ) ; decoder = get_vpx_decoder_by_fourcc ( info -> codec_fourcc ) ; if ( ! decoder ) die ( \"Unknown<S2SV_blank>input<S2SV_blank>codec.\" ) ; <S2SV_StartBug> printf ( \"Using<S2SV_blank>%s\\\\n\" , vpx_codec_iface_name ( decoder -> interface ( ) ) ) ; <S2SV_EndBug> <S2SV_StartBug> if ( vpx_codec_dec_init ( & codec , decoder -> interface ( ) , NULL , 0 ) ) <S2SV_EndBug> die_codec ( & codec , \"Failed<S2SV_blank>to<S2SV_blank>initialize<S2SV_blank>decoder.\" ) ; while ( vpx_video_reader_read_frame ( reader ) ) { vpx_codec_iter_t iter = NULL ; vpx_image_t * img = NULL ; size_t frame_size = 0 ; int skip ; const unsigned char * frame = vpx_video_reader_get_frame ( reader , & frame_size ) ; if ( vpx_codec_decode ( & codec , frame , ( unsigned int ) frame_size , NULL , 0 ) ) die_codec ( & codec , \"Failed<S2SV_blank>to<S2SV_blank>decode<S2SV_blank>frame.\" ) ; ++ frame_cnt ; skip = ( is_range && frame_cnt >= n && frame_cnt <= m ) || ( ! is_range && m - ( frame_cnt - 1 ) % m <= n ) ; if ( ! skip ) { putc ( '.' , stdout ) ; while ( ( img = vpx_codec_get_frame ( & codec , & iter ) ) != NULL ) vpx_img_write ( img , outfile ) ; } else { putc ( 'X' , stdout ) ; } fflush ( stdout ) ; } printf ( \"Processed<S2SV_blank>%d<S2SV_blank>frames.\\\\n\" , frame_cnt ) ; if ( vpx_codec_destroy ( & codec ) ) die_codec ( & codec , \"Failed<S2SV_blank>to<S2SV_blank>destroy<S2SV_blank>codec.\" ) ; printf ( \"Play:<S2SV_blank>ffplay<S2SV_blank>-f<S2SV_blank>rawvideo<S2SV_blank>-pix_fmt<S2SV_blank>yuv420p<S2SV_blank>-s<S2SV_blank>%dx%d<S2SV_blank>%s\\\\n\" , info -> frame_width , info -> frame_height , argv [ 2 ] ) ; vpx_video_reader_close ( reader ) ; fclose ( outfile ) ; return EXIT_SUCCESS ; }\n",
      "fixed_code": "<S2SV_ModStart> ( decoder -> codec_interface <S2SV_ModEnd> ( ) ) <S2SV_ModStart> , decoder -> codec_interface <S2SV_ModEnd> ( ) ,\n",
      "source_code_length": 2710,
      "target_code_length": 130,
      "vulnerability_patterns": {
        "buffer_overflow": 3,
        "integer_overflow": 1,
        "null_pointer": 30,
        "total": 34
      },
      "total_patterns": 34,
      "original_address": "https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426",
      "discovery_time": "2016-03-12T21:59Z",
      "project_commit_id": "external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426",
      "extraction_time": "2025-08-31T15:41:49.180982",
      "label": 1,
      "vulnerability_type": "buffer_overflow",
      "difficulty_level": "advanced",
      "risk_factors": [
        "system_crash",
        "memory_corruption",
        "buffer_overflow",
        "arbitrary_code_execution"
      ],
      "attack_vectors": [
        "memory_manipulation",
        "malicious_input",
        "code_analysis",
        "buffer_overflow",
        "reverse_engineering",
        "fuzzing"
      ],
      "mitigation_strategies": [
        "safe_string_functions",
        "dynamic_analysis",
        "code_review",
        "static_analysis",
        "memory_safety_checks",
        "input_validation",
        "fuzzing",
        "bounds_checking",
        "secure_coding_practices"
      ],
      "code_differences": {
        "has_differences": true,
        "source_lines": 2,
        "target_lines": 2,
        "character_differences": 2580,
        "similarity_percentage": 4.464285714285714
      },
      "vulnerability_location": {
        "vulnerability_present": true,
        "fix_applied": true,
        "code_changed": true,
        "estimated_lines_changed": 0
      }
    },
    {
      "cve_id": "CVE-2018-15858",
      "cwe_id": "CWE-476",
      "cwe_name": "NULL Pointer Dereference",
      "project": "xkbcommon",
      "severity": "critical",
      "weaponization_score": 8.5,
      "is_critical": true,
      "is_weaponizable": true,
      "is_high_priority_project": false,
      "vulnerable_code": "CWE-476 static bool CopyKeyAliasesToKeymap ( struct xkb_keymap * keymap , KeyNamesInfo * info ) { AliasInfo * alias ; unsigned i , num_key_aliases ; struct xkb_key_alias * key_aliases ; num_key_aliases = 0 ; darray_foreach ( alias , info -> aliases ) { if ( ! XkbKeyByName ( keymap , alias -> real , false ) ) { log_vrb ( info -> ctx , 5 , \"Attempt<S2SV_blank>to<S2SV_blank>alias<S2SV_blank>%s<S2SV_blank>to<S2SV_blank>non-existent<S2SV_blank>key<S2SV_blank>%s;<S2SV_blank>Ignored\\\\n\" , KeyNameText ( info -> ctx , alias -> alias ) , KeyNameText ( info -> ctx , alias -> real ) ) ; alias -> real = XKB_ATOM_NONE ; continue ; } if ( XkbKeyByName ( keymap , alias -> alias , false ) ) { log_vrb ( info -> ctx , 5 , \"Attempt<S2SV_blank>to<S2SV_blank>create<S2SV_blank>alias<S2SV_blank>with<S2SV_blank>the<S2SV_blank>name<S2SV_blank>of<S2SV_blank>a<S2SV_blank>real<S2SV_blank>key;<S2SV_blank>\" \"Alias<S2SV_blank>\\\\\"%s<S2SV_blank>=<S2SV_blank>%s\\\\\"<S2SV_blank>ignored\\\\n\" , KeyNameText ( info -> ctx , alias -> alias ) , KeyNameText ( info -> ctx , alias -> real ) ) ; alias -> real = XKB_ATOM_NONE ; continue ; } num_key_aliases ++ ; } key_aliases = NULL ; if ( num_key_aliases > 0 ) { key_aliases = calloc ( num_key_aliases , sizeof ( * key_aliases ) ) ; if ( ! key_aliases ) return false ; <S2SV_StartBug> } <S2SV_EndBug> i = 0 ; darray_foreach ( alias , info -> aliases ) { if ( alias -> real != XKB_ATOM_NONE ) { key_aliases [ i ] . alias = alias -> alias ; key_aliases [ i ] . real = alias -> real ; i ++ ; } } <S2SV_StartBug> keymap -> num_key_aliases = num_key_aliases ; <S2SV_EndBug> keymap -> key_aliases = key_aliases ; return true ; }\n",
      "fixed_code": "<S2SV_ModStart> return false ; <S2SV_ModEnd> i = 0 <S2SV_ModStart> ; } } }\n",
      "source_code_length": 1642,
      "target_code_length": 75,
      "vulnerability_patterns": {
        "use_after_free": 1,
        "integer_overflow": 2,
        "null_pointer": 23,
        "sql_injection": 1,
        "memory_leak": 1,
        "total": 28
      },
      "total_patterns": 28,
      "original_address": "https://github.com/xkbcommon/libxkbcommon/commit/badb428e63387140720f22486b3acbd3d738859f",
      "discovery_time": "2018-08-25T21:29Z",
      "project_commit_id": "xkbcommon@libxkbcommon/badb428e63387140720f22486b3acbd3d738859f",
      "extraction_time": "2025-08-31T15:41:49.181005",
      "label": 1,
      "vulnerability_type": "null_pointer_dereference",
      "difficulty_level": "advanced",
      "risk_factors": [
        "denial_of_service",
        "memory_corruption",
        "sql_injection",
        "system_crash",
        "use_after_free"
      ],
      "attack_vectors": [
        "memory_manipulation",
        "null_pointer",
        "code_analysis",
        "reverse_engineering",
        "use_after_free",
        "fuzzing"
      ],
      "mitigation_strategies": [
        "null_pointer_checks",
        "fuzzing",
        "dynamic_analysis",
        "memory_management",
        "static_analysis",
        "use_after_free_prevention",
        "code_review",
        "secure_coding_practices"
      ],
      "code_differences": {
        "has_differences": true,
        "source_lines": 2,
        "target_lines": 2,
        "character_differences": 1567,
        "similarity_percentage": 12.280701754385964
      },
      "vulnerability_location": {
        "vulnerability_present": true,
        "fix_applied": true,
        "code_changed": true,
        "estimated_lines_changed": 0
      }
    },
    {
      "cve_id": "CVE-2016-1621",
      "cwe_id": "CWE-119",
      "cwe_name": "Buffer Overflow",
      "project": "external",
      "severity": "critical",
      "weaponization_score": 8.5,
      "is_critical": true,
      "is_weaponizable": true,
      "is_high_priority_project": false,
      "vulnerable_code": "CWE-119 int main ( int argc , char * * argv ) { int frame_cnt = 0 ; FILE * outfile = NULL ; vpx_codec_ctx_t codec ; const VpxInterface * decoder = NULL ; VpxVideoReader * reader = NULL ; const VpxVideoInfo * info = NULL ; int n = 0 ; int m = 0 ; int is_range = 0 ; char * nptr = NULL ; exec_name = argv [ 0 ] ; if ( argc != 4 ) die ( \"Invalid<S2SV_blank>number<S2SV_blank>of<S2SV_blank>arguments.\" ) ; reader = vpx_video_reader_open ( argv [ 1 ] ) ; if ( ! reader ) die ( \"Failed<S2SV_blank>to<S2SV_blank>open<S2SV_blank>%s<S2SV_blank>for<S2SV_blank>reading.\" , argv [ 1 ] ) ; if ( ! ( outfile = fopen ( argv [ 2 ] , \"wb\" ) ) ) die ( \"Failed<S2SV_blank>to<S2SV_blank>open<S2SV_blank>%s<S2SV_blank>for<S2SV_blank>writing.\" , argv [ 2 ] ) ; n = strtol ( argv [ 3 ] , & nptr , 0 ) ; m = strtol ( nptr + 1 , NULL , 0 ) ; is_range = ( * nptr == '-' ) ; if ( ! n || ! m || ( * nptr != '-' && * nptr != '/' ) ) die ( \"Couldn\\'t<S2SV_blank>parse<S2SV_blank>pattern<S2SV_blank>%s.\\\\n\" , argv [ 3 ] ) ; info = vpx_video_reader_get_info ( reader ) ; decoder = get_vpx_decoder_by_fourcc ( info -> codec_fourcc ) ; if ( ! decoder ) die ( \"Unknown<S2SV_blank>input<S2SV_blank>codec.\" ) ; <S2SV_StartBug> printf ( \"Using<S2SV_blank>%s\\\\n\" , vpx_codec_iface_name ( decoder -> interface ( ) ) ) ; <S2SV_EndBug> <S2SV_StartBug> if ( vpx_codec_dec_init ( & codec , decoder -> interface ( ) , NULL , 0 ) ) <S2SV_EndBug> die_codec ( & codec , \"Failed<S2SV_blank>to<S2SV_blank>initialize<S2SV_blank>decoder.\" ) ; while ( vpx_video_reader_read_frame ( reader ) ) { vpx_codec_iter_t iter = NULL ; vpx_image_t * img = NULL ; size_t frame_size = 0 ; int skip ; const unsigned char * frame = vpx_video_reader_get_frame ( reader , & frame_size ) ; if ( vpx_codec_decode ( & codec , frame , ( unsigned int ) frame_size , NULL , 0 ) ) die_codec ( & codec , \"Failed<S2SV_blank>to<S2SV_blank>decode<S2SV_blank>frame.\" ) ; ++ frame_cnt ; skip = ( is_range && frame_cnt >= n && frame_cnt <= m ) || ( ! is_range && m - ( frame_cnt - 1 ) % m <= n ) ; if ( ! skip ) { putc ( '.' , stdout ) ; while ( ( img = vpx_codec_get_frame ( & codec , & iter ) ) != NULL ) vpx_img_write ( img , outfile ) ; } else { putc ( 'X' , stdout ) ; } fflush ( stdout ) ; } printf ( \"Processed<S2SV_blank>%d<S2SV_blank>frames.\\\\n\" , frame_cnt ) ; if ( vpx_codec_destroy ( & codec ) ) die_codec ( & codec , \"Failed<S2SV_blank>to<S2SV_blank>destroy<S2SV_blank>codec.\" ) ; printf ( \"Play:<S2SV_blank>ffplay<S2SV_blank>-f<S2SV_blank>rawvideo<S2SV_blank>-pix_fmt<S2SV_blank>yuv420p<S2SV_blank>-s<S2SV_blank>%dx%d<S2SV_blank>%s\\\\n\" , info -> frame_width , info -> frame_height , argv [ 2 ] ) ; vpx_video_reader_close ( reader ) ; fclose ( outfile ) ; return EXIT_SUCCESS ; }\n",
      "fixed_code": "<S2SV_ModStart> ( decoder -> codec_interface <S2SV_ModEnd> ( ) ) <S2SV_ModStart> , decoder -> codec_interface <S2SV_ModEnd> ( ) ,\n",
      "source_code_length": 2710,
      "target_code_length": 130,
      "vulnerability_patterns": {
        "buffer_overflow": 2,
        "integer_overflow": 5,
        "null_pointer": 17,
        "total": 24
      },
      "total_patterns": 24,
      "original_address": "https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426",
      "discovery_time": "2016-03-12T21:59Z",
      "project_commit_id": "external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426",
      "extraction_time": "2025-08-31T15:41:49.181022",
      "label": 1,
      "vulnerability_type": "buffer_overflow",
      "difficulty_level": "advanced",
      "risk_factors": [
        "system_crash",
        "memory_corruption",
        "buffer_overflow",
        "arbitrary_code_execution"
      ],
      "attack_vectors": [
        "memory_manipulation",
        "malicious_input",
        "code_analysis",
        "buffer_overflow",
        "reverse_engineering",
        "fuzzing"
      ],
      "mitigation_strategies": [
        "safe_string_functions",
        "dynamic_analysis",
        "code_review",
        "static_analysis",
        "memory_safety_checks",
        "input_validation",
        "fuzzing",
        "bounds_checking",
        "secure_coding_practices"
      ],
      "code_differences": {
        "has_differences": true,
        "source_lines": 2,
        "target_lines": 2,
        "character_differences": 2580,
        "similarity_percentage": 4.464285714285714
      },
      "vulnerability_location": {
        "vulnerability_present": true,
        "fix_applied": true,
        "code_changed": true,
        "estimated_lines_changed": 0
      }
    },
    {
      "cve_id": "CVE-2019-19275",
      "cwe_id": "CWE-125",
      "cwe_name": "Out-of-bounds Read",
      "project": "python",
      "severity": "critical",
      "weaponization_score": 8.5,
      "is_critical": true,
      "is_weaponizable": true,
      "is_high_priority_project": true,
      "vulnerable_code": "CWE-125 static arguments_ty ast_for_arguments ( struct compiling * c , const node * n ) { int i , j , k , nposargs = 0 , nkwonlyargs = 0 ; int nposdefaults = 0 , found_default = 0 ; asdl_seq * posargs , * posdefaults , * kwonlyargs , * kwdefaults ; arg_ty vararg = NULL , kwarg = NULL ; arg_ty arg ; node * ch ; if ( TYPE ( n ) == parameters ) { if ( NCH ( n ) == 2 ) return arguments ( NULL , NULL , NULL , NULL , NULL , NULL , c -> c_arena ) ; n = CHILD ( n , 1 ) ; } assert ( TYPE ( n ) == typedargslist || TYPE ( n ) == varargslist ) ; for ( i = 0 ; i < NCH ( n ) ; i ++ ) { ch = CHILD ( n , i ) ; if ( TYPE ( ch ) == STAR ) { i ++ ; if ( i < NCH ( n ) && ( TYPE ( CHILD ( n , i ) ) == tfpdef || TYPE ( CHILD ( n , i ) ) == vfpdef ) ) { i ++ ; } break ; } if ( TYPE ( ch ) == DOUBLESTAR ) break ; if ( TYPE ( ch ) == vfpdef || TYPE ( ch ) == tfpdef ) nposargs ++ ; if ( TYPE ( ch ) == EQUAL ) nposdefaults ++ ; } for ( ; i < NCH ( n ) ; ++ i ) { ch = CHILD ( n , i ) ; if ( TYPE ( ch ) == DOUBLESTAR ) break ; if ( TYPE ( ch ) == tfpdef || TYPE ( ch ) == vfpdef ) nkwonlyargs ++ ; } posargs = ( nposargs ? _Ta3_asdl_seq_new ( nposargs , c -> c_arena ) : NULL ) ; if ( ! posargs && nposargs ) return NULL ; kwonlyargs = ( nkwonlyargs ? _Ta3_asdl_seq_new ( nkwonlyargs , c -> c_arena ) : NULL ) ; if ( ! kwonlyargs && nkwonlyargs ) return NULL ; posdefaults = ( nposdefaults ? _Ta3_asdl_seq_new ( nposdefaults , c -> c_arena ) : NULL ) ; if ( ! posdefaults && nposdefaults ) return NULL ; kwdefaults = ( nkwonlyargs ? _Ta3_asdl_seq_new ( nkwonlyargs , c -> c_arena ) : NULL ) ; if ( ! kwdefaults && nkwonlyargs ) return NULL ; <S2SV_StartBug> if ( nposargs + nkwonlyargs > 255 ) { <S2SV_EndBug> ast_error ( c , n , \"more<S2SV_blank>than<S2SV_blank>255<S2SV_blank>arguments\" ) ; return NULL ; } i = 0 ; j = 0 ; k = 0 ; while ( i < NCH ( n ) ) { ch = CHILD ( n , i ) ; switch ( TYPE ( ch ) ) { case tfpdef : case vfpdef : if ( i + 1 < NCH ( n ) && TYPE ( CHILD ( n , i + 1 ) ) == EQUAL ) { expr_ty expression = ast_for_expr ( c , CHILD ( n , i + 2 ) ) ; if ( ! expression ) return NULL ; assert ( posdefaults != NULL ) ; asdl_seq_SET ( posdefaults , j ++ , expression ) ; i += 2 ; found_default = 1 ; } else if ( found_default ) { ast_error ( c , n , \"non-default<S2SV_blank>argument<S2SV_blank>follows<S2SV_blank>default<S2SV_blank>argument\" ) ; return NULL ; } arg = ast_for_arg ( c , ch ) ; if ( ! arg ) return NULL ; asdl_seq_SET ( posargs , k ++ , arg ) ; i += 1 ; <S2SV_StartBug> if ( i < NCH ( n ) && TYPE ( CHILD ( n , i ) ) == COMMA ) <S2SV_EndBug> i += 1 ; break ; case STAR : if ( i + 1 >= NCH ( n ) || ( i + 2 == NCH ( n ) && ( TYPE ( CHILD ( n , i + 1 ) ) == COMMA || TYPE ( CHILD ( n , i + 1 ) ) == TYPE_COMMENT ) ) ) { ast_error ( c , CHILD ( n , i ) , \"named<S2SV_blank>arguments<S2SV_blank>must<S2SV_blank>follow<S2SV_blank>bare<S2SV_blank>*\" ) ; return NULL ; } ch = CHILD ( n , i + 1 ) ; if ( TYPE ( ch ) == COMMA ) { int res = 0 ; i += 2 ; <S2SV_StartBug> if ( i < NCH ( n ) && TYPE ( CHILD ( n , i ) ) == TYPE_COMMENT ) { <S2SV_EndBug> ast_error ( c , CHILD ( n , i ) , \"bare<S2SV_blank>*<S2SV_blank>has<S2SV_blank>associated<S2SV_blank>type<S2SV_blank>comment\" ) ; return NULL ; } res = handle_keywordonly_args ( c , n , i , kwonlyargs , kwdefaults ) ; if ( res == - 1 ) return NULL ; i = res ; } else { vararg = ast_for_arg ( c , ch ) ; if ( ! vararg ) return NULL ; i += 2 ; <S2SV_StartBug> if ( i < NCH ( n ) && TYPE ( CHILD ( n , i ) ) == COMMA ) <S2SV_EndBug> i += 1 ; <S2SV_StartBug> if ( i < NCH ( n ) && TYPE ( CHILD ( n , i ) ) == TYPE_COMMENT ) { <S2SV_EndBug> vararg -> type_comment = NEW_TYPE_COMMENT ( CHILD ( n , i ) ) ; i += 1 ; } if ( i < NCH ( n ) && ( TYPE ( CHILD ( n , i ) ) == tfpdef || TYPE ( CHILD ( n , i ) ) == vfpdef ) ) { int res = 0 ; res = handle_keywordonly_args ( c , n , i , kwonlyargs , kwdefaults ) ; if ( res == - 1 ) return NULL ; i = res ; } } break ; case DOUBLESTAR : ch = CHILD ( n , i + 1 ) ; assert ( TYPE ( ch ) == tfpdef || TYPE ( ch ) == vfpdef ) ; kwarg = ast_for_arg ( c , ch ) ; if ( ! kwarg ) return NULL ; i += 2 ; <S2SV_StartBug> if ( i < NCH ( n ) && TYPE ( CHILD ( n , i ) ) == COMMA ) <S2SV_EndBug> i += 1 ; break ; case TYPE_COMMENT : assert ( i ) ; if ( kwarg ) arg = kwarg ; arg -> type_comment = NEW_TYPE_COMMENT ( ch ) ; i += 1 ; break ; default : PyErr_Format ( PyExc_SystemError , \"unexpected<S2SV_blank>node<S2SV_blank>in<S2SV_blank>varargslist:<S2SV_blank>%d<S2SV_blank>@<S2SV_blank>%d\" , TYPE ( ch ) , i ) ; return NULL ; } } return arguments ( posargs , vararg , kwonlyargs , kwdefaults , kwarg , posdefaults , c -> c_arena ) ; }\n",
      "fixed_code": "<S2SV_ModStart> return NULL ; <S2SV_ModEnd> i = 0 <S2SV_ModStart> ; if ( <S2SV_ModEnd> TYPE ( CHILD <S2SV_ModStart> ; if ( <S2SV_ModEnd> TYPE ( CHILD <S2SV_ModStart> ; if ( <S2SV_ModEnd> TYPE ( CHILD <S2SV_ModStart> ; if ( <S2SV_ModEnd> TYPE ( CHILD <S2SV_ModStart> ; if ( <S2SV_ModEnd> TYPE ( CHILD\n",
      "source_code_length": 4617,
      "target_code_length": 300,
      "vulnerability_patterns": {
        "integer_overflow": 4,
        "null_pointer": 14,
        "total": 18
      },
      "total_patterns": 18,
      "original_address": "https://github.com/python/typed_ast/commit/156afcb26c198e162504a57caddfe0acd9ed7dce",
      "discovery_time": "2019-11-26T15:15Z",
      "project_commit_id": "python@typed_ast/156afcb26c198e162504a57caddfe0acd9ed7dce",
      "extraction_time": "2025-08-31T15:41:49.181055",
      "label": 1,
      "vulnerability_type": "out-of-bounds_read",
      "difficulty_level": "advanced",
      "risk_factors": [
        "information_disclosure",
        "memory_corruption",
        "integer_overflow",
        "critical_infrastructure"
      ],
      "attack_vectors": [
        "memory_manipulation",
        "malicious_input",
        "code_analysis",
        "buffer_overflow",
        "reverse_engineering",
        "fuzzing"
      ],
      "mitigation_strategies": [
        "safe_string_functions",
        "dynamic_analysis",
        "code_review",
        "static_analysis",
        "memory_safety_checks",
        "input_validation",
        "fuzzing",
        "bounds_checking",
        "secure_coding_practices"
      ],
      "code_differences": {
        "has_differences": true,
        "source_lines": 2,
        "target_lines": 2,
        "character_differences": 4317,
        "similarity_percentage": 9.70873786407767
      },
      "vulnerability_location": {
        "vulnerability_present": true,
        "fix_applied": true,
        "code_changed": true,
        "estimated_lines_changed": 0
      }
    },
    {
      "cve_id": "CVE-2016-1621",
      "cwe_id": "CWE-119",
      "cwe_name": "Buffer Overflow",
      "project": "external",
      "severity": "critical",
      "weaponization_score": 8.5,
      "is_critical": true,
      "is_weaponizable": true,
      "is_high_priority_project": false,
      "vulnerable_code": "CWE-119 int main ( int argc , char * * argv ) { int frame_cnt = 0 ; FILE * outfile = NULL ; vpx_codec_ctx_t codec ; const VpxInterface * decoder = NULL ; VpxVideoReader * reader = NULL ; const VpxVideoInfo * info = NULL ; int n = 0 ; int m = 0 ; int is_range = 0 ; char * nptr = NULL ; exec_name = argv [ 0 ] ; if ( argc != 4 ) die ( \"Invalid<S2SV_blank>number<S2SV_blank>of<S2SV_blank>arguments.\" ) ; reader = vpx_video_reader_open ( argv [ 1 ] ) ; if ( ! reader ) die ( \"Failed<S2SV_blank>to<S2SV_blank>open<S2SV_blank>%s<S2SV_blank>for<S2SV_blank>reading.\" , argv [ 1 ] ) ; if ( ! ( outfile = fopen ( argv [ 2 ] , \"wb\" ) ) ) die ( \"Failed<S2SV_blank>to<S2SV_blank>open<S2SV_blank>%s<S2SV_blank>for<S2SV_blank>writing.\" , argv [ 2 ] ) ; n = strtol ( argv [ 3 ] , & nptr , 0 ) ; m = strtol ( nptr + 1 , NULL , 0 ) ; is_range = ( * nptr == '-' ) ; if ( ! n || ! m || ( * nptr != '-' && * nptr != '/' ) ) die ( \"Couldn\\'t<S2SV_blank>parse<S2SV_blank>pattern<S2SV_blank>%s.\\\\n\" , argv [ 3 ] ) ; info = vpx_video_reader_get_info ( reader ) ; decoder = get_vpx_decoder_by_fourcc ( info -> codec_fourcc ) ; if ( ! decoder ) die ( \"Unknown<S2SV_blank>input<S2SV_blank>codec.\" ) ; <S2SV_StartBug> printf ( \"Using<S2SV_blank>%s\\\\n\" , vpx_codec_iface_name ( decoder -> interface ( ) ) ) ; <S2SV_EndBug> <S2SV_StartBug> if ( vpx_codec_dec_init ( & codec , decoder -> interface ( ) , NULL , 0 ) ) <S2SV_EndBug> die_codec ( & codec , \"Failed<S2SV_blank>to<S2SV_blank>initialize<S2SV_blank>decoder.\" ) ; while ( vpx_video_reader_read_frame ( reader ) ) { vpx_codec_iter_t iter = NULL ; vpx_image_t * img = NULL ; size_t frame_size = 0 ; int skip ; const unsigned char * frame = vpx_video_reader_get_frame ( reader , & frame_size ) ; if ( vpx_codec_decode ( & codec , frame , ( unsigned int ) frame_size , NULL , 0 ) ) die_codec ( & codec , \"Failed<S2SV_blank>to<S2SV_blank>decode<S2SV_blank>frame.\" ) ; ++ frame_cnt ; skip = ( is_range && frame_cnt >= n && frame_cnt <= m ) || ( ! is_range && m - ( frame_cnt - 1 ) % m <= n ) ; if ( ! skip ) { putc ( '.' , stdout ) ; while ( ( img = vpx_codec_get_frame ( & codec , & iter ) ) != NULL ) vpx_img_write ( img , outfile ) ; } else { putc ( 'X' , stdout ) ; } fflush ( stdout ) ; } printf ( \"Processed<S2SV_blank>%d<S2SV_blank>frames.\\\\n\" , frame_cnt ) ; if ( vpx_codec_destroy ( & codec ) ) die_codec ( & codec , \"Failed<S2SV_blank>to<S2SV_blank>destroy<S2SV_blank>codec.\" ) ; printf ( \"Play:<S2SV_blank>ffplay<S2SV_blank>-f<S2SV_blank>rawvideo<S2SV_blank>-pix_fmt<S2SV_blank>yuv420p<S2SV_blank>-s<S2SV_blank>%dx%d<S2SV_blank>%s\\\\n\" , info -> frame_width , info -> frame_height , argv [ 2 ] ) ; vpx_video_reader_close ( reader ) ; fclose ( outfile ) ; return EXIT_SUCCESS ; }\n",
      "fixed_code": "<S2SV_ModStart> ( decoder -> codec_interface <S2SV_ModEnd> ( ) ) <S2SV_ModStart> , decoder -> codec_interface <S2SV_ModEnd> ( ) ,\n",
      "source_code_length": 2710,
      "target_code_length": 130,
      "vulnerability_patterns": {
        "use_after_free": 2,
        "integer_overflow": 3,
        "null_pointer": 14,
        "total": 19
      },
      "total_patterns": 19,
      "original_address": "https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426",
      "discovery_time": "2016-03-12T21:59Z",
      "project_commit_id": "external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426",
      "extraction_time": "2025-08-31T15:41:49.181108",
      "label": 1,
      "vulnerability_type": "buffer_overflow",
      "difficulty_level": "advanced",
      "risk_factors": [
        "system_crash",
        "memory_corruption",
        "arbitrary_code_execution",
        "use_after_free"
      ],
      "attack_vectors": [
        "memory_manipulation",
        "malicious_input",
        "code_analysis",
        "buffer_overflow",
        "reverse_engineering",
        "fuzzing"
      ],
      "mitigation_strategies": [
        "safe_string_functions",
        "dynamic_analysis",
        "code_review",
        "static_analysis",
        "memory_safety_checks",
        "input_validation",
        "fuzzing",
        "bounds_checking",
        "secure_coding_practices"
      ],
      "code_differences": {
        "has_differences": true,
        "source_lines": 2,
        "target_lines": 2,
        "character_differences": 2580,
        "similarity_percentage": 4.464285714285714
      },
      "vulnerability_location": {
        "vulnerability_present": true,
        "fix_applied": true,
        "code_changed": true,
        "estimated_lines_changed": 0
      }
    },
    {
      "cve_id": "CVE-2016-1621",
      "cwe_id": "CWE-119",
      "cwe_name": "Buffer Overflow",
      "project": "external",
      "severity": "critical",
      "weaponization_score": 8.5,
      "is_critical": true,
      "is_weaponizable": true,
      "is_high_priority_project": false,
      "vulnerable_code": "CWE-119 int main ( int argc , char * * argv ) { int frame_cnt = 0 ; FILE * outfile = NULL ; vpx_codec_ctx_t codec ; const VpxInterface * decoder = NULL ; VpxVideoReader * reader = NULL ; const VpxVideoInfo * info = NULL ; int n = 0 ; int m = 0 ; int is_range = 0 ; char * nptr = NULL ; exec_name = argv [ 0 ] ; if ( argc != 4 ) die ( \"Invalid<S2SV_blank>number<S2SV_blank>of<S2SV_blank>arguments.\" ) ; reader = vpx_video_reader_open ( argv [ 1 ] ) ; if ( ! reader ) die ( \"Failed<S2SV_blank>to<S2SV_blank>open<S2SV_blank>%s<S2SV_blank>for<S2SV_blank>reading.\" , argv [ 1 ] ) ; if ( ! ( outfile = fopen ( argv [ 2 ] , \"wb\" ) ) ) die ( \"Failed<S2SV_blank>to<S2SV_blank>open<S2SV_blank>%s<S2SV_blank>for<S2SV_blank>writing.\" , argv [ 2 ] ) ; n = strtol ( argv [ 3 ] , & nptr , 0 ) ; m = strtol ( nptr + 1 , NULL , 0 ) ; is_range = ( * nptr == '-' ) ; if ( ! n || ! m || ( * nptr != '-' && * nptr != '/' ) ) die ( \"Couldn\\'t<S2SV_blank>parse<S2SV_blank>pattern<S2SV_blank>%s.\\\\n\" , argv [ 3 ] ) ; info = vpx_video_reader_get_info ( reader ) ; decoder = get_vpx_decoder_by_fourcc ( info -> codec_fourcc ) ; if ( ! decoder ) die ( \"Unknown<S2SV_blank>input<S2SV_blank>codec.\" ) ; <S2SV_StartBug> printf ( \"Using<S2SV_blank>%s\\\\n\" , vpx_codec_iface_name ( decoder -> interface ( ) ) ) ; <S2SV_EndBug> <S2SV_StartBug> if ( vpx_codec_dec_init ( & codec , decoder -> interface ( ) , NULL , 0 ) ) <S2SV_EndBug> die_codec ( & codec , \"Failed<S2SV_blank>to<S2SV_blank>initialize<S2SV_blank>decoder.\" ) ; while ( vpx_video_reader_read_frame ( reader ) ) { vpx_codec_iter_t iter = NULL ; vpx_image_t * img = NULL ; size_t frame_size = 0 ; int skip ; const unsigned char * frame = vpx_video_reader_get_frame ( reader , & frame_size ) ; if ( vpx_codec_decode ( & codec , frame , ( unsigned int ) frame_size , NULL , 0 ) ) die_codec ( & codec , \"Failed<S2SV_blank>to<S2SV_blank>decode<S2SV_blank>frame.\" ) ; ++ frame_cnt ; skip = ( is_range && frame_cnt >= n && frame_cnt <= m ) || ( ! is_range && m - ( frame_cnt - 1 ) % m <= n ) ; if ( ! skip ) { putc ( '.' , stdout ) ; while ( ( img = vpx_codec_get_frame ( & codec , & iter ) ) != NULL ) vpx_img_write ( img , outfile ) ; } else { putc ( 'X' , stdout ) ; } fflush ( stdout ) ; } printf ( \"Processed<S2SV_blank>%d<S2SV_blank>frames.\\\\n\" , frame_cnt ) ; if ( vpx_codec_destroy ( & codec ) ) die_codec ( & codec , \"Failed<S2SV_blank>to<S2SV_blank>destroy<S2SV_blank>codec.\" ) ; printf ( \"Play:<S2SV_blank>ffplay<S2SV_blank>-f<S2SV_blank>rawvideo<S2SV_blank>-pix_fmt<S2SV_blank>yuv420p<S2SV_blank>-s<S2SV_blank>%dx%d<S2SV_blank>%s\\\\n\" , info -> frame_width , info -> frame_height , argv [ 2 ] ) ; vpx_video_reader_close ( reader ) ; fclose ( outfile ) ; return EXIT_SUCCESS ; }\n",
      "fixed_code": "<S2SV_ModStart> ( decoder -> codec_interface <S2SV_ModEnd> ( ) ) <S2SV_ModStart> , decoder -> codec_interface <S2SV_ModEnd> ( ) ,\n",
      "source_code_length": 2710,
      "target_code_length": 130,
      "vulnerability_patterns": {
        "buffer_overflow": 2,
        "null_pointer": 16,
        "total": 18
      },
      "total_patterns": 18,
      "original_address": "https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426",
      "discovery_time": "2016-03-12T21:59Z",
      "project_commit_id": "external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426",
      "extraction_time": "2025-08-31T15:41:49.181128",
      "label": 1,
      "vulnerability_type": "buffer_overflow",
      "difficulty_level": "advanced",
      "risk_factors": [
        "system_crash",
        "memory_corruption",
        "buffer_overflow",
        "arbitrary_code_execution"
      ],
      "attack_vectors": [
        "memory_manipulation",
        "malicious_input",
        "code_analysis",
        "buffer_overflow",
        "reverse_engineering",
        "fuzzing"
      ],
      "mitigation_strategies": [
        "safe_string_functions",
        "dynamic_analysis",
        "code_review",
        "static_analysis",
        "memory_safety_checks",
        "input_validation",
        "fuzzing",
        "bounds_checking",
        "secure_coding_practices"
      ],
      "code_differences": {
        "has_differences": true,
        "source_lines": 2,
        "target_lines": 2,
        "character_differences": 2580,
        "similarity_percentage": 4.464285714285714
      },
      "vulnerability_location": {
        "vulnerability_present": true,
        "fix_applied": true,
        "code_changed": true,
        "estimated_lines_changed": 0
      }
    },
    {
      "cve_id": "CVE-2019-1010297",
      "cwe_id": "CWE-119",
      "cwe_name": "Buffer Overflow",
      "project": "OP-TEE",
      "severity": "critical",
      "weaponization_score": 8.5,
      "is_critical": true,
      "is_weaponizable": true,
      "is_high_priority_project": false,
      "vulnerable_code": "CWE-119 TEE_Result syscall_cryp_derive_key ( unsigned long state , const struct utee_attribute * usr_params , unsigned long param_count , unsigned long derived_key ) { TEE_Result res = TEE_ERROR_NOT_SUPPORTED ; struct tee_ta_session * sess ; struct tee_obj * ko ; struct tee_obj * so ; struct tee_cryp_state * cs ; struct tee_cryp_obj_secret * sk ; const struct tee_cryp_obj_type_props * type_props ; TEE_Attribute * params = NULL ; struct user_ta_ctx * utc ; res = tee_ta_get_current_session ( & sess ) ; if ( res != TEE_SUCCESS ) return res ; utc = to_user_ta_ctx ( sess -> ctx ) ; res = tee_svc_cryp_get_state ( sess , tee_svc_uref_to_vaddr ( state ) , & cs ) ; if ( res != TEE_SUCCESS ) return res ; <S2SV_StartBug> params = malloc ( sizeof ( TEE_Attribute ) * param_count ) ; <S2SV_EndBug> if ( ! params ) return TEE_ERROR_OUT_OF_MEMORY ; res = copy_in_attrs ( utc , usr_params , param_count , params ) ; if ( res != TEE_SUCCESS ) goto out ; res = tee_obj_get ( utc , cs -> key1 , & ko ) ; if ( res != TEE_SUCCESS ) goto out ; res = tee_obj_get ( utc , tee_svc_uref_to_vaddr ( derived_key ) , & so ) ; if ( res != TEE_SUCCESS ) goto out ; sk = so -> attr ; type_props = tee_svc_find_type_props ( so -> info . objectType ) ; if ( ! type_props ) { res = TEE_ERROR_NOT_SUPPORTED ; goto out ; } if ( cs -> algo == TEE_ALG_DH_DERIVE_SHARED_SECRET ) { size_t alloc_size ; struct bignum * pub ; struct bignum * ss ; if ( param_count != 1 || params [ 0 ] . attributeID != TEE_ATTR_DH_PUBLIC_VALUE ) { res = TEE_ERROR_BAD_PARAMETERS ; goto out ; } alloc_size = params [ 0 ] . content . ref . length * 8 ; pub = crypto_bignum_allocate ( alloc_size ) ; ss = crypto_bignum_allocate ( alloc_size ) ; if ( pub && ss ) { crypto_bignum_bin2bn ( params [ 0 ] . content . ref . buffer , params [ 0 ] . content . ref . length , pub ) ; res = crypto_acipher_dh_shared_secret ( ko -> attr , pub , ss ) ; if ( res == TEE_SUCCESS ) { sk -> key_size = crypto_bignum_num_bytes ( ss ) ; crypto_bignum_bn2bin ( ss , ( uint8_t * ) ( sk + 1 ) ) ; so -> info . handleFlags |= TEE_HANDLE_FLAG_INITIALIZED ; set_attribute ( so , type_props , TEE_ATTR_SECRET_VALUE ) ; } } else { res = TEE_ERROR_OUT_OF_MEMORY ; } crypto_bignum_free ( pub ) ; crypto_bignum_free ( ss ) ; } else if ( TEE_ALG_GET_MAIN_ALG ( cs -> algo ) == TEE_MAIN_ALGO_ECDH ) { size_t alloc_size ; struct ecc_public_key key_public ; uint8_t * pt_secret ; unsigned long pt_secret_len ; if ( param_count != 2 || params [ 0 ] . attributeID != TEE_ATTR_ECC_PUBLIC_VALUE_X || params [ 1 ] . attributeID != TEE_ATTR_ECC_PUBLIC_VALUE_Y ) { res = TEE_ERROR_BAD_PARAMETERS ; goto out ; } switch ( cs -> algo ) { case TEE_ALG_ECDH_P192 : alloc_size = 192 ; break ; case TEE_ALG_ECDH_P224 : alloc_size = 224 ; break ; case TEE_ALG_ECDH_P256 : alloc_size = 256 ; break ; case TEE_ALG_ECDH_P384 : alloc_size = 384 ; break ; case TEE_ALG_ECDH_P521 : alloc_size = 521 ; break ; default : res = TEE_ERROR_NOT_IMPLEMENTED ; goto out ; } res = crypto_acipher_alloc_ecc_public_key ( & key_public , alloc_size ) ; if ( res != TEE_SUCCESS ) goto out ; key_public . curve = ( ( struct ecc_keypair * ) ko -> attr ) -> curve ; crypto_bignum_bin2bn ( params [ 0 ] . content . ref . buffer , params [ 0 ] . content . ref . length , key_public . x ) ; crypto_bignum_bin2bn ( params [ 1 ] . content . ref . buffer , params [ 1 ] . content . ref . length , key_public . y ) ; pt_secret = ( uint8_t * ) ( sk + 1 ) ; pt_secret_len = sk -> alloc_size ; res = crypto_acipher_ecc_shared_secret ( ko -> attr , & key_public , pt_secret , & pt_secret_len ) ; if ( res == TEE_SUCCESS ) { sk -> key_size = pt_secret_len ; so -> info . handleFlags |= TEE_HANDLE_FLAG_INITIALIZED ; set_attribute ( so , type_props , TEE_ATTR_SECRET_VALUE ) ; } crypto_acipher_free_ecc_public_key ( & key_public ) ; } # if defined ( CFG_CRYPTO_HKDF ) else if ( TEE_ALG_GET_MAIN_ALG ( cs -> algo ) == TEE_MAIN_ALGO_HKDF ) { void * salt , * info ; size_t salt_len , info_len , okm_len ; uint32_t hash_id = TEE_ALG_GET_DIGEST_HASH ( cs -> algo ) ; struct tee_cryp_obj_secret * ik = ko -> attr ; const uint8_t * ikm = ( const uint8_t * ) ( ik + 1 ) ; res = get_hkdf_params ( params , param_count , & salt , & salt_len , & info , & info_len , & okm_len ) ; if ( res != TEE_SUCCESS ) goto out ; if ( okm_len > ik -> alloc_size ) { res = TEE_ERROR_BAD_PARAMETERS ; goto out ; } res = tee_cryp_hkdf ( hash_id , ikm , ik -> key_size , salt , salt_len , info , info_len , ( uint8_t * ) ( sk + 1 ) , okm_len ) ; if ( res == TEE_SUCCESS ) { sk -> key_size = okm_len ; so -> info . handleFlags |= TEE_HANDLE_FLAG_INITIALIZED ; set_attribute ( so , type_props , TEE_ATTR_SECRET_VALUE ) ; } } # endif # if defined ( CFG_CRYPTO_CONCAT_KDF ) else if ( TEE_ALG_GET_MAIN_ALG ( cs -> algo ) == TEE_MAIN_ALGO_CONCAT_KDF ) { void * info ; size_t info_len , derived_key_len ; uint32_t hash_id = TEE_ALG_GET_DIGEST_HASH ( cs -> algo ) ; struct tee_cryp_obj_secret * ss = ko -> attr ; const uint8_t * shared_secret = ( const uint8_t * ) ( ss + 1 ) ; res = get_concat_kdf_params ( params , param_count , & info , & info_len , & derived_key_len ) ; if ( res != TEE_SUCCESS ) goto out ; if ( derived_key_len > ss -> alloc_size ) { res = TEE_ERROR_BAD_PARAMETERS ; goto out ; } res = tee_cryp_concat_kdf ( hash_id , shared_secret , ss -> key_size , info , info_len , ( uint8_t * ) ( sk + 1 ) , derived_key_len ) ; if ( res == TEE_SUCCESS ) { sk -> key_size = derived_key_len ; so -> info . handleFlags |= TEE_HANDLE_FLAG_INITIALIZED ; set_attribute ( so , type_props , TEE_ATTR_SECRET_VALUE ) ; } } # endif # if defined ( CFG_CRYPTO_PBKDF2 ) else if ( TEE_ALG_GET_MAIN_ALG ( cs -> algo ) == TEE_MAIN_ALGO_PBKDF2 ) { void * salt ; size_t salt_len , iteration_count , derived_key_len ; uint32_t hash_id = TEE_ALG_GET_DIGEST_HASH ( cs -> algo ) ; struct tee_cryp_obj_secret * ss = ko -> attr ; const uint8_t * password = ( const uint8_t * ) ( ss + 1 ) ; res = get_pbkdf2_params ( params , param_count , & salt , & salt_len , & derived_key_len , & iteration_count ) ; if ( res != TEE_SUCCESS ) goto out ; if ( derived_key_len > ss -> alloc_size ) { res = TEE_ERROR_BAD_PARAMETERS ; goto out ; } res = tee_cryp_pbkdf2 ( hash_id , password , ss -> key_size , salt , salt_len , iteration_count , ( uint8_t * ) ( sk + 1 ) , derived_key_len ) ; if ( res == TEE_SUCCESS ) { sk -> key_size = derived_key_len ; so -> info . handleFlags |= TEE_HANDLE_FLAG_INITIALIZED ; set_attribute ( so , type_props , TEE_ATTR_SECRET_VALUE ) ; } } # endif else res = TEE_ERROR_NOT_SUPPORTED ; out : free ( params ) ; return res ; }\n",
      "fixed_code": "<S2SV_ModStart> return res ; size_t alloc_size = 0 ; if ( MUL_OVERFLOW ( sizeof ( TEE_Attribute ) , param_count , & alloc_size ) ) return TEE_ERROR_OVERFLOW ; <S2SV_ModStart> = malloc ( alloc_size <S2SV_ModEnd> ) ; if\n",
      "source_code_length": 6556,
      "target_code_length": 218,
      "vulnerability_patterns": {
        "use_after_free": 2,
        "null_pointer": 41,
        "memory_leak": 1,
        "total": 44
      },
      "total_patterns": 44,
      "original_address": "https://github.com/OP-TEE/optee_os/commit/a637243270fc1faae16de059091795c32d86e65e",
      "discovery_time": "2019-07-15T18:15Z",
      "project_commit_id": "OP-TEE@optee_os/a637243270fc1faae16de059091795c32d86e65e",
      "extraction_time": "2025-08-31T15:41:49.181145",
      "label": 1,
      "vulnerability_type": "buffer_overflow",
      "difficulty_level": "advanced",
      "risk_factors": [
        "system_crash",
        "memory_corruption",
        "arbitrary_code_execution",
        "use_after_free"
      ],
      "attack_vectors": [
        "memory_manipulation",
        "malicious_input",
        "code_analysis",
        "buffer_overflow",
        "reverse_engineering",
        "fuzzing"
      ],
      "mitigation_strategies": [
        "safe_string_functions",
        "dynamic_analysis",
        "code_review",
        "static_analysis",
        "memory_safety_checks",
        "input_validation",
        "fuzzing",
        "bounds_checking",
        "secure_coding_practices"
      ],
      "code_differences": {
        "has_differences": true,
        "source_lines": 2,
        "target_lines": 2,
        "character_differences": 6338,
        "similarity_percentage": 9.467455621301776
      },
      "vulnerability_location": {
        "vulnerability_present": true,
        "fix_applied": true,
        "code_changed": true,
        "estimated_lines_changed": 0
      }
    },
    {
      "cve_id": "CVE-2017-0587",
      "cwe_id": "CWE-119",
      "cwe_name": "Buffer Overflow",
      "project": "external",
      "severity": "critical",
      "weaponization_score": 8.5,
      "is_critical": true,
      "is_weaponizable": true,
      "is_high_priority_project": false,
      "vulnerable_code": "CWE-119 IV_API_CALL_STATUS_T impeg2d_api_entity ( iv_obj_t * ps_dechdl , void * pv_api_ip , void * pv_api_op ) { iv_obj_t * ps_dec_handle ; dec_state_t * ps_dec_state ; dec_state_multi_core_t * ps_dec_state_multi_core ; impeg2d_video_decode_ip_t * ps_dec_ip ; impeg2d_video_decode_op_t * ps_dec_op ; WORD32 bytes_remaining ; pic_buf_t * ps_disp_pic ; ps_dec_ip = ( impeg2d_video_decode_ip_t * ) pv_api_ip ; ps_dec_op = ( impeg2d_video_decode_op_t * ) pv_api_op ; memset ( ps_dec_op , 0 , sizeof ( impeg2d_video_decode_op_t ) ) ; ps_dec_op -> s_ivd_video_decode_op_t . u4_size = sizeof ( impeg2d_video_decode_op_t ) ; ps_dec_op -> s_ivd_video_decode_op_t . u4_output_present = 0 ; bytes_remaining = ps_dec_ip -> s_ivd_video_decode_ip_t . u4_num_Bytes ; ps_dec_handle = ( iv_obj_t * ) ps_dechdl ; if ( ps_dechdl == NULL ) { return ( IV_FAIL ) ; } ps_dec_state_multi_core = ps_dec_handle -> pv_codec_handle ; ps_dec_state = ps_dec_state_multi_core -> ps_dec_state [ 0 ] ; ps_dec_state -> ps_disp_frm_buf = & ( ps_dec_op -> s_ivd_video_decode_op_t . s_disp_frm_buf ) ; if ( 0 == ps_dec_state -> u4_share_disp_buf ) { ps_dec_state -> ps_disp_frm_buf -> pv_y_buf = ps_dec_ip -> s_ivd_video_decode_ip_t . s_out_buffer . pu1_bufs [ 0 ] ; ps_dec_state -> ps_disp_frm_buf -> pv_u_buf = ps_dec_ip -> s_ivd_video_decode_ip_t . s_out_buffer . pu1_bufs [ 1 ] ; ps_dec_state -> ps_disp_frm_buf -> pv_v_buf = ps_dec_ip -> s_ivd_video_decode_ip_t . s_out_buffer . pu1_bufs [ 2 ] ; } ps_dec_state -> ps_disp_pic = NULL ; ps_dec_state -> i4_frame_decoded = 0 ; ps_dec_op -> s_ivd_video_decode_op_t . u4_num_bytes_consumed = 0 ; ps_dec_op -> s_ivd_video_decode_op_t . u4_error_code = IV_SUCCESS ; if ( ( ps_dec_ip -> s_ivd_video_decode_ip_t . pv_stream_buffer == NULL ) && ( ps_dec_state -> u1_flushfrm == 0 ) ) { ps_dec_op -> s_ivd_video_decode_op_t . u4_error_code |= 1 << IVD_UNSUPPORTEDPARAM ; ps_dec_op -> s_ivd_video_decode_op_t . u4_error_code |= IVD_DEC_FRM_BS_BUF_NULL ; return IV_FAIL ; } if ( ps_dec_state -> u4_num_frames_decoded > NUM_FRAMES_LIMIT ) { ps_dec_op -> s_ivd_video_decode_op_t . u4_error_code = IMPEG2D_SAMPLE_VERSION_LIMIT_ERR ; return ( IV_FAIL ) ; } if ( ( ( 0 == ps_dec_state -> u2_header_done ) || ( ps_dec_state -> u2_decode_header == 1 ) ) && ( ps_dec_state -> u1_flushfrm == 0 ) ) { impeg2d_dec_hdr ( ps_dec_state , ps_dec_ip , ps_dec_op ) ; bytes_remaining -= ps_dec_op -> s_ivd_video_decode_op_t . u4_num_bytes_consumed ; } <S2SV_StartBug> if ( ( 1 != ps_dec_state -> u2_decode_header ) && ( ( bytes_remaining > 0 ) || ps_dec_state -> u1_flushfrm ) ) <S2SV_EndBug> { if ( ps_dec_state -> u1_flushfrm ) { if ( ps_dec_state -> aps_ref_pics [ 1 ] != NULL ) { impeg2_disp_mgr_add ( & ps_dec_state -> s_disp_mgr , ps_dec_state -> aps_ref_pics [ 1 ] , ps_dec_state -> aps_ref_pics [ 1 ] -> i4_buf_id ) ; impeg2_buf_mgr_release ( ps_dec_state -> pv_pic_buf_mg , ps_dec_state -> aps_ref_pics [ 1 ] -> i4_buf_id , BUF_MGR_REF ) ; impeg2_buf_mgr_release ( ps_dec_state -> pv_pic_buf_mg , ps_dec_state -> aps_ref_pics [ 0 ] -> i4_buf_id , BUF_MGR_REF ) ; ps_dec_state -> aps_ref_pics [ 1 ] = NULL ; ps_dec_state -> aps_ref_pics [ 0 ] = NULL ; } else if ( ps_dec_state -> aps_ref_pics [ 0 ] != NULL ) { impeg2_disp_mgr_add ( & ps_dec_state -> s_disp_mgr , ps_dec_state -> aps_ref_pics [ 0 ] , ps_dec_state -> aps_ref_pics [ 0 ] -> i4_buf_id ) ; impeg2_buf_mgr_release ( ps_dec_state -> pv_pic_buf_mg , ps_dec_state -> aps_ref_pics [ 0 ] -> i4_buf_id , BUF_MGR_REF ) ; ps_dec_state -> aps_ref_pics [ 0 ] = NULL ; } ps_dec_ip -> s_ivd_video_decode_ip_t . u4_size = sizeof ( impeg2d_video_decode_ip_t ) ; ps_dec_op -> s_ivd_video_decode_op_t . u4_size = sizeof ( impeg2d_video_decode_op_t ) ; ps_disp_pic = impeg2_disp_mgr_get ( & ps_dec_state -> s_disp_mgr , & ps_dec_state -> i4_disp_buf_id ) ; ps_dec_state -> ps_disp_pic = ps_disp_pic ; if ( ps_disp_pic == NULL ) { ps_dec_op -> s_ivd_video_decode_op_t . u4_output_present = 0 ; } else { WORD32 fmt_conv ; if ( 0 == ps_dec_state -> u4_share_disp_buf ) { ps_dec_op -> s_ivd_video_decode_op_t . s_disp_frm_buf . pv_y_buf = ps_dec_ip -> s_ivd_video_decode_ip_t . s_out_buffer . pu1_bufs [ 0 ] ; ps_dec_op -> s_ivd_video_decode_op_t . s_disp_frm_buf . pv_u_buf = ps_dec_ip -> s_ivd_video_decode_ip_t . s_out_buffer . pu1_bufs [ 1 ] ; ps_dec_op -> s_ivd_video_decode_op_t . s_disp_frm_buf . pv_v_buf = ps_dec_ip -> s_ivd_video_decode_ip_t . s_out_buffer . pu1_bufs [ 2 ] ; fmt_conv = 1 ; } else { ps_dec_op -> s_ivd_video_decode_op_t . s_disp_frm_buf . pv_y_buf = ps_disp_pic -> pu1_y ; if ( IV_YUV_420P == ps_dec_state -> i4_chromaFormat ) { ps_dec_op -> s_ivd_video_decode_op_t . s_disp_frm_buf . pv_u_buf = ps_disp_pic -> pu1_u ; ps_dec_op -> s_ivd_video_decode_op_t . s_disp_frm_buf . pv_v_buf = ps_disp_pic -> pu1_v ; fmt_conv = 0 ; } else { UWORD8 * pu1_buf ; pu1_buf = ps_dec_state -> as_disp_buffers [ ps_disp_pic -> i4_buf_id ] . pu1_bufs [ 1 ] ; ps_dec_op -> s_ivd_video_decode_op_t . s_disp_frm_buf . pv_u_buf = pu1_buf ; pu1_buf = ps_dec_state -> as_disp_buffers [ ps_disp_pic -> i4_buf_id ] . pu1_bufs [ 2 ] ; ps_dec_op -> s_ivd_video_decode_op_t . s_disp_frm_buf . pv_v_buf = pu1_buf ; fmt_conv = 1 ; } } if ( fmt_conv == 1 ) { iv_yuv_buf_t * ps_dst ; ps_dst = & ( ps_dec_op -> s_ivd_video_decode_op_t . s_disp_frm_buf ) ; if ( ps_dec_state -> u4_deinterlace && ( 0 == ps_dec_state -> u2_progressive_frame ) ) { impeg2d_deinterlace ( ps_dec_state , ps_disp_pic , ps_dst , 0 , ps_dec_state -> u2_vertical_size ) ; } else { impeg2d_format_convert ( ps_dec_state , ps_disp_pic , ps_dst , 0 , ps_dec_state -> u2_vertical_size ) ; } } if ( ps_dec_state -> u4_deinterlace ) { if ( ps_dec_state -> ps_deint_pic ) { impeg2_buf_mgr_release ( ps_dec_state -> pv_pic_buf_mg , ps_dec_state -> ps_deint_pic -> i4_buf_id , MPEG2_BUF_MGR_DEINT ) ; } ps_dec_state -> ps_deint_pic = ps_disp_pic ; } if ( 0 == ps_dec_state -> u4_share_disp_buf ) impeg2_buf_mgr_release ( ps_dec_state -> pv_pic_buf_mg , ps_disp_pic -> i4_buf_id , BUF_MGR_DISP ) ; ps_dec_op -> s_ivd_video_decode_op_t . u4_pic_ht = ps_dec_state -> u2_vertical_size ; ps_dec_op -> s_ivd_video_decode_op_t . u4_pic_wd = ps_dec_state -> u2_horizontal_size ; ps_dec_op -> s_ivd_video_decode_op_t . u4_output_present = 1 ; ps_dec_op -> s_ivd_video_decode_op_t . u4_disp_buf_id = ps_disp_pic -> i4_buf_id ; ps_dec_op -> s_ivd_video_decode_op_t . u4_ts = ps_disp_pic -> u4_ts ; ps_dec_op -> s_ivd_video_decode_op_t . e_output_format = ( IV_COLOR_FORMAT_T ) ps_dec_state -> i4_chromaFormat ; ps_dec_op -> s_ivd_video_decode_op_t . u4_is_ref_flag = ( B_PIC != ps_dec_state -> e_pic_type ) ; ps_dec_op -> s_ivd_video_decode_op_t . u4_progressive_frame_flag = IV_PROGRESSIVE ; ps_dec_op -> s_ivd_video_decode_op_t . s_disp_frm_buf . u4_y_wd = ps_dec_state -> u2_horizontal_size ; ps_dec_op -> s_ivd_video_decode_op_t . s_disp_frm_buf . u4_y_strd = ps_dec_state -> u4_frm_buf_stride ; ps_dec_op -> s_ivd_video_decode_op_t . s_disp_frm_buf . u4_y_ht = ps_dec_state -> u2_vertical_size ; ps_dec_op -> s_ivd_video_decode_op_t . s_disp_frm_buf . u4_u_wd = ps_dec_state -> u2_horizontal_size >> 1 ; ps_dec_op -> s_ivd_video_decode_op_t . s_disp_frm_buf . u4_u_strd = ps_dec_state -> u4_frm_buf_stride >> 1 ; ps_dec_op -> s_ivd_video_decode_op_t . s_disp_frm_buf . u4_u_ht = ps_dec_state -> u2_vertical_size >> 1 ; ps_dec_op -> s_ivd_video_decode_op_t . s_disp_frm_buf . u4_v_wd = ps_dec_state -> u2_horizontal_size >> 1 ; ps_dec_op -> s_ivd_video_decode_op_t . s_disp_frm_buf . u4_v_strd = ps_dec_state -> u4_frm_buf_stride >> 1 ; ps_dec_op -> s_ivd_video_decode_op_t . s_disp_frm_buf . u4_v_ht = ps_dec_state -> u2_vertical_size >> 1 ; ps_dec_op -> s_ivd_video_decode_op_t . s_disp_frm_buf . u4_size = sizeof ( ps_dec_op -> s_ivd_video_decode_op_t . s_disp_frm_buf ) ; switch ( ps_dec_state -> i4_chromaFormat ) { case IV_YUV_420SP_UV : case IV_YUV_420SP_VU : ps_dec_op -> s_ivd_video_decode_op_t . s_disp_frm_buf . u4_u_wd = ps_dec_state -> u2_horizontal_size ; ps_dec_op -> s_ivd_video_decode_op_t . s_disp_frm_buf . u4_u_strd = ps_dec_state -> u4_frm_buf_stride ; break ; case IV_YUV_422ILE : ps_dec_op -> s_ivd_video_decode_op_t . s_disp_frm_buf . u4_u_wd = 0 ; ps_dec_op -> s_ivd_video_decode_op_t . s_disp_frm_buf . u4_u_ht = 0 ; ps_dec_op -> s_ivd_video_decode_op_t . s_disp_frm_buf . u4_v_wd = 0 ; ps_dec_op -> s_ivd_video_decode_op_t . s_disp_frm_buf . u4_v_ht = 0 ; break ; default : break ; } } if ( ps_dec_op -> s_ivd_video_decode_op_t . u4_output_present ) { if ( 1 == ps_dec_op -> s_ivd_video_decode_op_t . u4_output_present ) { INSERT_LOGO ( ps_dec_ip -> s_ivd_video_decode_ip_t . s_out_buffer . pu1_bufs [ 0 ] , ps_dec_ip -> s_ivd_video_decode_ip_t . s_out_buffer . pu1_bufs [ 1 ] , ps_dec_ip -> s_ivd_video_decode_ip_t . s_out_buffer . pu1_bufs [ 2 ] , ps_dec_state -> u4_frm_buf_stride , ps_dec_state -> u2_horizontal_size , ps_dec_state -> u2_vertical_size , ps_dec_state -> i4_chromaFormat , ps_dec_state -> u2_horizontal_size , ps_dec_state -> u2_vertical_size ) ; } return ( IV_SUCCESS ) ; } else { ps_dec_state -> u1_flushfrm = 0 ; return ( IV_FAIL ) ; } } else if ( ps_dec_state -> u1_flushfrm == 0 ) { ps_dec_ip -> s_ivd_video_decode_ip_t . u4_size = sizeof ( impeg2d_video_decode_ip_t ) ; ps_dec_op -> s_ivd_video_decode_op_t . u4_size = sizeof ( impeg2d_video_decode_op_t ) ; if ( ps_dec_ip -> s_ivd_video_decode_ip_t . u4_num_Bytes < 4 ) { ps_dec_op -> s_ivd_video_decode_op_t . u4_num_bytes_consumed = ps_dec_ip -> s_ivd_video_decode_ip_t . u4_num_Bytes ; return ( IV_FAIL ) ; } if ( 1 == ps_dec_state -> u4_share_disp_buf ) { if ( 0 == impeg2_buf_mgr_check_free ( ps_dec_state -> pv_pic_buf_mg ) ) { ps_dec_op -> s_ivd_video_decode_op_t . u4_error_code = ( IMPEG2D_ERROR_CODES_T ) IVD_DEC_REF_BUF_NULL ; return IV_FAIL ; } } ps_dec_op -> s_ivd_video_decode_op_t . e_output_format = ( IV_COLOR_FORMAT_T ) ps_dec_state -> i4_chromaFormat ; ps_dec_op -> s_ivd_video_decode_op_t . u4_is_ref_flag = ( B_PIC != ps_dec_state -> e_pic_type ) ; ps_dec_op -> s_ivd_video_decode_op_t . u4_progressive_frame_flag = IV_PROGRESSIVE ; if ( 0 == ps_dec_state -> u4_frm_buf_stride ) { ps_dec_state -> u4_frm_buf_stride = ( ps_dec_state -> u2_horizontal_size ) ; } ps_dec_op -> s_ivd_video_decode_op_t . s_disp_frm_buf . u4_y_wd = ps_dec_state -> u2_horizontal_size ; ps_dec_op -> s_ivd_video_decode_op_t . s_disp_frm_buf . u4_y_strd = ps_dec_state -> u4_frm_buf_stride ; ps_dec_op -> s_ivd_video_decode_op_t . s_disp_frm_buf . u4_y_ht = ps_dec_state -> u2_vertical_size ; ps_dec_op -> s_ivd_video_decode_op_t . s_disp_frm_buf . u4_u_wd = ps_dec_state -> u2_horizontal_size >> 1 ; ps_dec_op -> s_ivd_video_decode_op_t . s_disp_frm_buf . u4_u_strd = ps_dec_state -> u4_frm_buf_stride >> 1 ; ps_dec_op -> s_ivd_video_decode_op_t . s_disp_frm_buf . u4_u_ht = ps_dec_state -> u2_vertical_size >> 1 ; ps_dec_op -> s_ivd_video_decode_op_t . s_disp_frm_buf . u4_v_wd = ps_dec_state -> u2_horizontal_size >> 1 ; ps_dec_op -> s_ivd_video_decode_op_t . s_disp_frm_buf . u4_v_strd = ps_dec_state -> u4_frm_buf_stride >> 1 ; ps_dec_op -> s_ivd_video_decode_op_t . s_disp_frm_buf . u4_v_ht = ps_dec_state -> u2_vertical_size >> 1 ; ps_dec_op -> s_ivd_video_decode_op_t . s_disp_frm_buf . u4_size = sizeof ( ps_dec_op -> s_ivd_video_decode_op_t . s_disp_frm_buf ) ; switch ( ps_dec_state -> i4_chromaFormat ) { case IV_YUV_420SP_UV : case IV_YUV_420SP_VU : ps_dec_op -> s_ivd_video_decode_op_t . s_disp_frm_buf . u4_u_wd = ps_dec_state -> u2_horizontal_size ; ps_dec_op -> s_ivd_video_decode_op_t . s_disp_frm_buf . u4_u_strd = ps_dec_state -> u4_frm_buf_stride ; break ; case IV_YUV_422ILE : ps_dec_op -> s_ivd_video_decode_op_t . s_disp_frm_buf . u4_u_wd = 0 ; ps_dec_op -> s_ivd_video_decode_op_t . s_disp_frm_buf . u4_u_ht = 0 ; ps_dec_op -> s_ivd_video_decode_op_t . s_disp_frm_buf . u4_v_wd = 0 ; ps_dec_op -> s_ivd_video_decode_op_t . s_disp_frm_buf . u4_v_ht = 0 ; break ; default : break ; } if ( ps_dec_state -> u1_flushfrm == 0 ) { ps_dec_state -> u1_flushcnt = 0 ; impeg2d_dec_frm ( ps_dec_state , ps_dec_ip , ps_dec_op ) ; if ( IVD_ERROR_NONE == ps_dec_op -> s_ivd_video_decode_op_t . u4_error_code ) { if ( ps_dec_state -> u1_first_frame_done == 0 ) { ps_dec_state -> u1_first_frame_done = 1 ; } if ( ps_dec_state -> ps_disp_pic ) { ps_dec_op -> s_ivd_video_decode_op_t . u4_output_present = 1 ; switch ( ps_dec_state -> ps_disp_pic -> e_pic_type ) { case I_PIC : ps_dec_op -> s_ivd_video_decode_op_t . e_pic_type = IV_I_FRAME ; break ; case P_PIC : ps_dec_op -> s_ivd_video_decode_op_t . e_pic_type = IV_P_FRAME ; break ; case B_PIC : ps_dec_op -> s_ivd_video_decode_op_t . e_pic_type = IV_B_FRAME ; break ; case D_PIC : ps_dec_op -> s_ivd_video_decode_op_t . e_pic_type = IV_I_FRAME ; break ; default : ps_dec_op -> s_ivd_video_decode_op_t . e_pic_type = IV_FRAMETYPE_DEFAULT ; break ; } } else { ps_dec_op -> s_ivd_video_decode_op_t . u4_output_present = 0 ; ps_dec_op -> s_ivd_video_decode_op_t . e_pic_type = IV_NA_FRAME ; } ps_dec_state -> u4_num_frames_decoded ++ ; } } else { ps_dec_state -> u1_flushcnt ++ ; } } if ( ps_dec_state -> ps_disp_pic ) { ps_dec_op -> s_ivd_video_decode_op_t . u4_disp_buf_id = ps_dec_state -> ps_disp_pic -> i4_buf_id ; ps_dec_op -> s_ivd_video_decode_op_t . u4_ts = ps_dec_state -> ps_disp_pic -> u4_ts ; if ( 0 == ps_dec_state -> u4_share_disp_buf ) { impeg2_buf_mgr_release ( ps_dec_state -> pv_pic_buf_mg , ps_dec_state -> ps_disp_pic -> i4_buf_id , BUF_MGR_DISP ) ; } } if ( ps_dec_state -> u4_deinterlace ) { if ( ps_dec_state -> ps_deint_pic ) { impeg2_buf_mgr_release ( ps_dec_state -> pv_pic_buf_mg , ps_dec_state -> ps_deint_pic -> i4_buf_id , MPEG2_BUF_MGR_DEINT ) ; } ps_dec_state -> ps_deint_pic = ps_dec_state -> ps_disp_pic ; } if ( 1 == ps_dec_op -> s_ivd_video_decode_op_t . u4_output_present ) { INSERT_LOGO ( ps_dec_ip -> s_ivd_video_decode_ip_t . s_out_buffer . pu1_bufs [ 0 ] , ps_dec_ip -> s_ivd_video_decode_ip_t . s_out_buffer . pu1_bufs [ 1 ] , ps_dec_ip -> s_ivd_video_decode_ip_t . s_out_buffer . pu1_bufs [ 2 ] , ps_dec_state -> u4_frm_buf_stride , ps_dec_state -> u2_horizontal_size , ps_dec_state -> u2_vertical_size , ps_dec_state -> i4_chromaFormat , ps_dec_state -> u2_horizontal_size , ps_dec_state -> u2_vertical_size ) ; } } ps_dec_op -> s_ivd_video_decode_op_t . u4_progressive_frame_flag = 1 ; ps_dec_op -> s_ivd_video_decode_op_t . e4_fld_type = ps_dec_state -> s_disp_op . e4_fld_type ; if ( ps_dec_op -> s_ivd_video_decode_op_t . u4_error_code ) return IV_FAIL ; else return IV_SUCCESS ; }\n",
      "fixed_code": "<S2SV_ModStart> u2_decode_header ) && ( <S2SV_ModStart> bytes_remaining > 0 ) && ( 1 == ps_dec_state -> u2_header_done )\n",
      "source_code_length": 14475,
      "target_code_length": 121,
      "vulnerability_patterns": {
        "buffer_overflow": 1,
        "integer_overflow": 3,
        "null_pointer": 249,
        "total": 253
      },
      "total_patterns": 253,
      "original_address": "https://android.googlesource.com/platform/external/libmpeg2/+/a86eb798d077b9b25c8f8c77e3c02c2f287c1ce7",
      "discovery_time": "2017-05-12T15:29Z",
      "project_commit_id": "external@libmpeg2/a86eb798d077b9b25c8f8c77e3c02c2f287c1ce7",
      "extraction_time": "2025-08-31T15:41:49.181198",
      "label": 1,
      "vulnerability_type": "buffer_overflow",
      "difficulty_level": "advanced",
      "risk_factors": [
        "system_crash",
        "memory_corruption",
        "buffer_overflow",
        "arbitrary_code_execution"
      ],
      "attack_vectors": [
        "memory_manipulation",
        "malicious_input",
        "code_analysis",
        "buffer_overflow",
        "reverse_engineering",
        "fuzzing"
      ],
      "mitigation_strategies": [
        "safe_string_functions",
        "dynamic_analysis",
        "code_review",
        "static_analysis",
        "memory_safety_checks",
        "input_validation",
        "fuzzing",
        "bounds_checking",
        "secure_coding_practices"
      ],
      "code_differences": {
        "has_differences": true,
        "source_lines": 2,
        "target_lines": 2,
        "character_differences": 14354,
        "similarity_percentage": 7.361963190184049
      },
      "vulnerability_location": {
        "vulnerability_present": true,
        "fix_applied": true,
        "code_changed": true,
        "estimated_lines_changed": 0
      }
    },
    {
      "cve_id": "CVE-2014-9728",
      "cwe_id": "CWE-119",
      "cwe_name": "Buffer Overflow",
      "project": "torvalds",
      "severity": "critical",
      "weaponization_score": 8.5,
      "is_critical": true,
      "is_weaponizable": true,
      "is_high_priority_project": false,
      "vulnerable_code": "CWE-119 static int udf_pc_to_char ( struct super_block * sb , unsigned char * from , int fromlen , unsigned char * to , int tolen ) { struct pathComponent * pc ; int elen = 0 ; int comp_len ; unsigned char * p = to ; tolen -- ; while ( elen < fromlen ) { pc = ( struct pathComponent * ) ( from + elen ) ; <S2SV_StartBug> switch ( pc -> componentType ) { <S2SV_EndBug> case 1 : if ( pc -> lengthComponentIdent > 0 ) <S2SV_StartBug> break ; <S2SV_EndBug> case 2 : if ( tolen == 0 ) return - ENAMETOOLONG ; p = to ; * p ++ = '/' ; tolen -- ; break ; case 3 : if ( tolen < 3 ) return - ENAMETOOLONG ; memcpy ( p , \"../\" , 3 ) ; p += 3 ; tolen -= 3 ; break ; case 4 : if ( tolen < 2 ) return - ENAMETOOLONG ; memcpy ( p , \"./\" , 2 ) ; p += 2 ; tolen -= 2 ; break ; <S2SV_StartBug> case 5 : <S2SV_EndBug> comp_len = udf_get_filename ( sb , pc -> componentIdent , pc -> lengthComponentIdent , p , tolen ) ; p += comp_len ; tolen -= comp_len ; if ( tolen == 0 ) return - ENAMETOOLONG ; * p ++ = '/' ; tolen -- ; break ; } <S2SV_StartBug> elen += sizeof ( struct pathComponent ) + pc -> lengthComponentIdent ; <S2SV_EndBug> } if ( p > to + 1 ) p [ - 1 ] = '\\\\0' ; else p [ 0 ] = '\\\\0' ; return 0 ; }\n",
      "fixed_code": "<S2SV_ModStart> elen ) ; elen += sizeof ( struct pathComponent ) ; <S2SV_ModStart> > 0 ) { elen += pc -> lengthComponentIdent ; break ; } <S2SV_ModEnd> case 2 : <S2SV_ModStart> case 5 : elen += pc -> lengthComponentIdent ; if ( elen > fromlen ) return - EIO ; <S2SV_ModStart> break ; } <S2SV_ModEnd> } if (\n",
      "source_code_length": 1191,
      "target_code_length": 307,
      "vulnerability_patterns": {
        "buffer_overflow": 2,
        "integer_overflow": 12,
        "null_pointer": 5,
        "total": 19
      },
      "total_patterns": 19,
      "original_address": "https://github.com/torvalds/linux/commit/e237ec37ec154564f8690c5bd1795339955eeef9",
      "discovery_time": "2015-08-31T10:59Z",
      "project_commit_id": "torvalds@linux/e237ec37ec154564f8690c5bd1795339955eeef9",
      "extraction_time": "2025-08-31T15:41:49.181289",
      "label": 1,
      "vulnerability_type": "buffer_overflow",
      "difficulty_level": "advanced",
      "risk_factors": [
        "system_crash",
        "memory_corruption",
        "buffer_overflow",
        "arbitrary_code_execution"
      ],
      "attack_vectors": [
        "memory_manipulation",
        "malicious_input",
        "code_analysis",
        "buffer_overflow",
        "reverse_engineering",
        "fuzzing"
      ],
      "mitigation_strategies": [
        "safe_string_functions",
        "dynamic_analysis",
        "code_review",
        "static_analysis",
        "memory_safety_checks",
        "input_validation",
        "fuzzing",
        "bounds_checking",
        "secure_coding_practices"
      ],
      "code_differences": {
        "has_differences": true,
        "source_lines": 2,
        "target_lines": 2,
        "character_differences": 884,
        "similarity_percentage": 35.294117647058826
      },
      "vulnerability_location": {
        "vulnerability_present": true,
        "fix_applied": true,
        "code_changed": true,
        "estimated_lines_changed": 0
      }
    },
    {
      "cve_id": "CVE-2017-12644",
      "cwe_id": "CWE-772",
      "cwe_name": "Missing Release of Memory",
      "project": "ImageMagick",
      "severity": "critical",
      "weaponization_score": 8.5,
      "is_critical": true,
      "is_weaponizable": true,
      "is_high_priority_project": true,
      "vulnerable_code": "CWE-772 static Image * ReadDCMImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { <S2SV_StartBug> # define ThrowDCMException ( exception , message ) { if ( data != ( unsigned char * ) NULL ) data = ( unsigned char * ) RelinquishMagickMemory ( data ) ; if ( stream_info != ( DCMStreamInfo * ) NULL ) stream_info = ( DCMStreamInfo * ) RelinquishMagickMemory ( stream_info ) ; ThrowReaderException ( ( exception ) , ( message ) ) ; } <S2SV_EndBug> char explicit_vr [ MaxTextExtent ] , implicit_vr [ MaxTextExtent ] , magick [ MaxTextExtent ] , photometric [ MaxTextExtent ] ; DCMInfo info ; DCMStreamInfo * stream_info ; Image * image ; int * bluemap , datum , * greenmap , * graymap , * redmap ; MagickBooleanType explicit_file , explicit_retry , sequence , use_explicit ; MagickOffsetType offset ; register unsigned char * p ; register ssize_t i ; size_t colors , height , length , number_scenes , quantum , status , width ; ssize_t count , scene ; unsigned char * data ; unsigned short group , element ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickSignature ) ; if ( image_info -> debug != MagickFalse ) ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , \"%s\" , image_info -> filename ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickSignature ) ; image = AcquireImage ( image_info ) ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } image -> depth = 8UL ; image -> endian = LSBEndian ; data = ( unsigned char * ) NULL ; stream_info = ( DCMStreamInfo * ) AcquireMagickMemory ( sizeof ( * stream_info ) ) ; if ( stream_info == ( DCMStreamInfo * ) NULL ) ThrowDCMException ( ResourceLimitError , \"MemoryAllocationFailed\" ) ; ( void ) ResetMagickMemory ( stream_info , 0 , sizeof ( * stream_info ) ) ; count = ReadBlob ( image , 128 , ( unsigned char * ) magick ) ; if ( count != 128 ) ThrowDCMException ( CorruptImageError , \"ImproperImageHeader\" ) ; count = ReadBlob ( image , 4 , ( unsigned char * ) magick ) ; if ( ( count != 4 ) || ( LocaleNCompare ( magick , \"DICM\" , 4 ) != 0 ) ) { offset = SeekBlob ( image , 0L , SEEK_SET ) ; if ( offset < 0 ) ThrowDCMException ( CorruptImageError , \"ImproperImageHeader\" ) ; } ( void ) CopyMagickString ( photometric , \"MONOCHROME1<S2SV_blank>\" , MaxTextExtent ) ; info . polarity = MagickFalse ; info . scale = ( Quantum * ) NULL ; info . bits_allocated = 8 ; info . bytes_per_pixel = 1 ; info . depth = 8 ; info . mask = 0xffff ; info . max_value = 255UL ; info . samples_per_pixel = 1 ; info . signed_data = ( ~ 0UL ) ; info . significant_bits = 0 ; info . rescale = MagickFalse ; info . rescale_intercept = 0.0 ; info . rescale_slope = 1.0 ; info . window_center = 0.0 ; info . window_width = 0.0 ; data = ( unsigned char * ) NULL ; element = 0 ; explicit_vr [ 2 ] = '\\\\0' ; explicit_file = MagickFalse ; colors = 0 ; redmap = ( int * ) NULL ; greenmap = ( int * ) NULL ; bluemap = ( int * ) NULL ; graymap = ( int * ) NULL ; height = 0 ; number_scenes = 1 ; sequence = MagickFalse ; use_explicit = MagickFalse ; explicit_retry = MagickFalse ; width = 0 ; for ( group = 0 ; ( group != 0x7FE0 ) || ( element != 0x0010 ) || ( sequence != MagickFalse ) ; ) { image -> offset = ( ssize_t ) TellBlob ( image ) ; group = ReadBlobLSBShort ( image ) ; element = ReadBlobLSBShort ( image ) ; if ( ( group != 0x0002 ) && ( image -> endian == MSBEndian ) ) { group = ( unsigned short ) ( ( group << 8 ) | ( ( group >> 8 ) & 0xFF ) ) ; element = ( unsigned short ) ( ( element << 8 ) | ( ( element >> 8 ) & 0xFF ) ) ; } quantum = 0 ; for ( i = 0 ; dicom_info [ i ] . group < 0xffff ; i ++ ) if ( ( group == dicom_info [ i ] . group ) && ( element == dicom_info [ i ] . element ) ) break ; ( void ) CopyMagickString ( implicit_vr , dicom_info [ i ] . vr , MaxTextExtent ) ; count = ReadBlob ( image , 2 , ( unsigned char * ) explicit_vr ) ; if ( count != 2 ) ThrowDCMException ( CorruptImageError , \"ImproperImageHeader\" ) ; if ( ( explicit_file == MagickFalse ) && ( group != 0x0002 ) ) explicit_file = ( isupper ( ( unsigned char ) * explicit_vr ) != MagickFalse ) && ( isupper ( ( unsigned char ) * ( explicit_vr + 1 ) ) != MagickFalse ) ? MagickTrue : MagickFalse ; use_explicit = ( ( group == 0x0002 ) && ( explicit_retry == MagickFalse ) ) || ( explicit_file != MagickFalse ) ? MagickTrue : MagickFalse ; if ( ( use_explicit != MagickFalse ) && ( strncmp ( implicit_vr , \"xs\" , 2 ) == 0 ) ) ( void ) CopyMagickString ( implicit_vr , explicit_vr , MaxTextExtent ) ; if ( ( use_explicit == MagickFalse ) || ( strncmp ( implicit_vr , \"!!\" , 2 ) == 0 ) ) { offset = SeekBlob ( image , ( MagickOffsetType ) - 2 , SEEK_CUR ) ; if ( offset < 0 ) ThrowDCMException ( CorruptImageError , \"ImproperImageHeader\" ) ; quantum = 4 ; } else { quantum = 2 ; if ( ( strncmp ( explicit_vr , \"OB\" , 2 ) == 0 ) || ( strncmp ( explicit_vr , \"UN\" , 2 ) == 0 ) || ( strncmp ( explicit_vr , \"OW\" , 2 ) == 0 ) || ( strncmp ( explicit_vr , \"SQ\" , 2 ) == 0 ) ) { ( void ) ReadBlobLSBShort ( image ) ; quantum = 4 ; } } datum = 0 ; if ( quantum == 4 ) { if ( group == 0x0002 ) datum = ReadBlobLSBSignedLong ( image ) ; else datum = ReadBlobSignedLong ( image ) ; } else if ( quantum == 2 ) { if ( group == 0x0002 ) datum = ReadBlobLSBSignedShort ( image ) ; else datum = ReadBlobSignedShort ( image ) ; } quantum = 0 ; length = 1 ; if ( datum != 0 ) { if ( ( strncmp ( implicit_vr , \"SS\" , 2 ) == 0 ) || ( strncmp ( implicit_vr , \"US\" , 2 ) == 0 ) ) quantum = 2 ; else if ( ( strncmp ( implicit_vr , \"UL\" , 2 ) == 0 ) || ( strncmp ( implicit_vr , \"SL\" , 2 ) == 0 ) || ( strncmp ( implicit_vr , \"FL\" , 2 ) == 0 ) ) quantum = 4 ; else if ( strncmp ( implicit_vr , \"FD\" , 2 ) != 0 ) quantum = 1 ; else quantum = 8 ; if ( datum != ~ 0 ) length = ( size_t ) datum / quantum ; else { quantum = 0 ; length = 0 ; } } if ( image_info -> verbose != MagickFalse ) { if ( use_explicit == MagickFalse ) explicit_vr [ 0 ] = '\\\\0' ; for ( i = 0 ; dicom_info [ i ] . description != ( char * ) NULL ; i ++ ) if ( ( group == dicom_info [ i ] . group ) && ( element == dicom_info [ i ] . element ) ) break ; ( void ) FormatLocaleFile ( stdout , \"0x%04lX<S2SV_blank>%4ld<S2SV_blank>%s-%s<S2SV_blank>(0x%04lx,0x%04lx)\" , ( unsigned long ) image -> offset , ( long ) length , implicit_vr , explicit_vr , ( unsigned long ) group , ( unsigned long ) element ) ; if ( dicom_info [ i ] . description != ( char * ) NULL ) ( void ) FormatLocaleFile ( stdout , \"<S2SV_blank>%s\" , dicom_info [ i ] . description ) ; ( void ) FormatLocaleFile ( stdout , \":<S2SV_blank>\" ) ; } if ( ( sequence == MagickFalse ) && ( group == 0x7FE0 ) && ( element == 0x0010 ) ) { if ( image_info -> verbose != MagickFalse ) ( void ) FormatLocaleFile ( stdout , \"\\\\n\" ) ; break ; } data = ( unsigned char * ) NULL ; if ( ( length == 1 ) && ( quantum == 1 ) ) datum = ReadBlobByte ( image ) ; else if ( ( length == 1 ) && ( quantum == 2 ) ) { if ( group == 0x0002 ) datum = ReadBlobLSBSignedShort ( image ) ; else datum = ReadBlobSignedShort ( image ) ; } else if ( ( length == 1 ) && ( quantum == 4 ) ) { if ( group == 0x0002 ) datum = ReadBlobLSBSignedLong ( image ) ; else datum = ReadBlobSignedLong ( image ) ; } else if ( ( quantum != 0 ) && ( length != 0 ) ) { if ( length > GetBlobSize ( image ) ) <S2SV_StartBug> ThrowReaderException ( CorruptImageError , <S2SV_EndBug> \"InsufficientImageDataInFile\" ) ; if ( ~ length >= 1 ) data = ( unsigned char * ) AcquireQuantumMemory ( length + 1 , quantum * sizeof ( * data ) ) ; if ( data == ( unsigned char * ) NULL ) ThrowDCMException ( ResourceLimitError , \"MemoryAllocationFailed\" ) ; count = ReadBlob ( image , ( size_t ) quantum * length , data ) ; if ( count != ( ssize_t ) ( quantum * length ) ) { if ( image_info -> verbose != MagickFalse ) ( void ) FormatLocaleFile ( stdout , \"count=%d<S2SV_blank>quantum=%d<S2SV_blank>\" \"length=%d<S2SV_blank>group=%d\\\\n\" , ( int ) count , ( int ) quantum , ( int ) length , ( int ) group ) ; ThrowDCMException ( CorruptImageError , \"InsufficientImageDataInFile\" ) ; } data [ length * quantum ] = '\\\\0' ; } else if ( ( unsigned int ) datum == 0xFFFFFFFFU ) { sequence = MagickTrue ; continue ; } if ( ( unsigned int ) ( ( group << 16 ) | element ) == 0xFFFEE0DD ) { if ( data != ( unsigned char * ) NULL ) data = ( unsigned char * ) RelinquishMagickMemory ( data ) ; sequence = MagickFalse ; continue ; } if ( sequence != MagickFalse ) { if ( data != ( unsigned char * ) NULL ) data = ( unsigned char * ) RelinquishMagickMemory ( data ) ; continue ; } switch ( group ) { case 0x0002 : { switch ( element ) { case 0x0010 : { char transfer_syntax [ MaxTextExtent ] ; if ( ( datum == 0 ) && ( explicit_retry == MagickFalse ) ) { explicit_retry = MagickTrue ; ( void ) SeekBlob ( image , ( MagickOffsetType ) 0 , SEEK_SET ) ; group = 0 ; element = 0 ; if ( image_info -> verbose != MagickFalse ) ( void ) FormatLocaleFile ( stdout , \"Corrupted<S2SV_blank>image<S2SV_blank>-<S2SV_blank>trying<S2SV_blank>explicit<S2SV_blank>format\\\\n\" ) ; break ; } * transfer_syntax = '\\\\0' ; if ( data != ( unsigned char * ) NULL ) ( void ) CopyMagickString ( transfer_syntax , ( char * ) data , MaxTextExtent ) ; if ( image_info -> verbose != MagickFalse ) ( void ) FormatLocaleFile ( stdout , \"transfer_syntax=%s\\\\n\" , ( const char * ) transfer_syntax ) ; if ( strncmp ( transfer_syntax , \"1.2.840.10008.1.2\" , 17 ) == 0 ) { int count , subtype , type ; type = 1 ; subtype = 0 ; if ( strlen ( transfer_syntax ) > 17 ) { count = sscanf ( transfer_syntax + 17 , \".%d.%d\" , & type , & subtype ) ; if ( count < 1 ) ThrowDCMException ( CorruptImageError , \"ImproperImageHeader\" ) ; } switch ( type ) { case 1 : { image -> endian = LSBEndian ; break ; } case 2 : { image -> endian = MSBEndian ; break ; } case 4 : { if ( ( subtype >= 80 ) && ( subtype <= 81 ) ) image -> compression = JPEGCompression ; else if ( ( subtype >= 90 ) && ( subtype <= 93 ) ) image -> compression = JPEG2000Compression ; else image -> compression = JPEGCompression ; break ; } case 5 : { image -> compression = RLECompression ; break ; } } } break ; } default : break ; } break ; } case 0x0028 : { switch ( element ) { case 0x0002 : { info . samples_per_pixel = ( size_t ) datum ; break ; } case 0x0004 : { if ( data == ( unsigned char * ) NULL ) break ; for ( i = 0 ; i < ( ssize_t ) MagickMin ( length , MaxTextExtent - 1 ) ; i ++ ) photometric [ i ] = ( char ) data [ i ] ; photometric [ i ] = '\\\\0' ; info . polarity = LocaleCompare ( photometric , \"MONOCHROME1<S2SV_blank>\" ) == 0 ? MagickTrue : MagickFalse ; break ; } case 0x0006 : { if ( datum == 1 ) image -> interlace = PlaneInterlace ; break ; } case 0x0008 : { if ( data == ( unsigned char * ) NULL ) break ; number_scenes = StringToUnsignedLong ( ( char * ) data ) ; break ; } case 0x0010 : { height = ( size_t ) datum ; break ; } case 0x0011 : { width = ( size_t ) datum ; break ; } case 0x0100 : { info . bits_allocated = ( size_t ) datum ; info . bytes_per_pixel = 1 ; if ( datum > 8 ) info . bytes_per_pixel = 2 ; info . depth = info . bits_allocated ; if ( info . depth > 32 ) ThrowDCMException ( CorruptImageError , \"ImproperImageHeader\" ) ; info . max_value = ( 1UL << info . bits_allocated ) - 1 ; image -> depth = info . depth ; break ; } case 0x0101 : { info . significant_bits = ( size_t ) datum ; info . bytes_per_pixel = 1 ; if ( info . significant_bits > 8 ) info . bytes_per_pixel = 2 ; info . depth = info . significant_bits ; if ( info . depth > 32 ) ThrowDCMException ( CorruptImageError , \"ImproperImageHeader\" ) ; info . max_value = ( 1UL << info . significant_bits ) - 1 ; info . mask = ( size_t ) GetQuantumRange ( info . significant_bits ) ; image -> depth = info . depth ; break ; } case 0x0102 : { break ; } case 0x0103 : { info . signed_data = ( size_t ) datum ; break ; } case 0x1050 : { if ( data != ( unsigned char * ) NULL ) info . window_center = StringToDouble ( ( char * ) data , ( char * * ) NULL ) ; break ; } case 0x1051 : { if ( data != ( unsigned char * ) NULL ) info . window_width = StringToDouble ( ( char * ) data , ( char * * ) NULL ) ; break ; } case 0x1052 : { if ( data != ( unsigned char * ) NULL ) info . rescale_intercept = StringToDouble ( ( char * ) data , ( char * * ) NULL ) ; break ; } case 0x1053 : { if ( data != ( unsigned char * ) NULL ) info . rescale_slope = StringToDouble ( ( char * ) data , ( char * * ) NULL ) ; break ; } case 0x1200 : case 0x3006 : { if ( data == ( unsigned char * ) NULL ) break ; colors = ( size_t ) ( length / info . bytes_per_pixel ) ; datum = ( int ) colors ; graymap = ( int * ) AcquireQuantumMemory ( ( size_t ) colors , sizeof ( * graymap ) ) ; if ( graymap == ( int * ) NULL ) ThrowDCMException ( ResourceLimitError , \"MemoryAllocationFailed\" ) ; for ( i = 0 ; i < ( ssize_t ) colors ; i ++ ) if ( info . bytes_per_pixel == 1 ) graymap [ i ] = ( int ) data [ i ] ; else graymap [ i ] = ( int ) ( ( short * ) data ) [ i ] ; break ; } case 0x1201 : { unsigned short index ; if ( data == ( unsigned char * ) NULL ) break ; colors = ( size_t ) ( length / 2 ) ; datum = ( int ) colors ; redmap = ( int * ) AcquireQuantumMemory ( ( size_t ) colors , sizeof ( * redmap ) ) ; if ( redmap == ( int * ) NULL ) ThrowDCMException ( ResourceLimitError , \"MemoryAllocationFailed\" ) ; p = data ; for ( i = 0 ; i < ( ssize_t ) colors ; i ++ ) { if ( image -> endian == MSBEndian ) index = ( unsigned short ) ( ( * p << 8 ) | * ( p + 1 ) ) ; else index = ( unsigned short ) ( * p | ( * ( p + 1 ) << 8 ) ) ; redmap [ i ] = ( int ) index ; p += 2 ; } break ; } case 0x1202 : { unsigned short index ; if ( data == ( unsigned char * ) NULL ) break ; colors = ( size_t ) ( length / 2 ) ; datum = ( int ) colors ; greenmap = ( int * ) AcquireQuantumMemory ( ( size_t ) colors , sizeof ( * greenmap ) ) ; if ( greenmap == ( int * ) NULL ) ThrowDCMException ( ResourceLimitError , \"MemoryAllocationFailed\" ) ; p = data ; for ( i = 0 ; i < ( ssize_t ) colors ; i ++ ) { if ( image -> endian == MSBEndian ) index = ( unsigned short ) ( ( * p << 8 ) | * ( p + 1 ) ) ; else index = ( unsigned short ) ( * p | ( * ( p + 1 ) << 8 ) ) ; greenmap [ i ] = ( int ) index ; p += 2 ; } break ; } case 0x1203 : { unsigned short index ; if ( data == ( unsigned char * ) NULL ) break ; colors = ( size_t ) ( length / 2 ) ; datum = ( int ) colors ; bluemap = ( int * ) AcquireQuantumMemory ( ( size_t ) colors , sizeof ( * bluemap ) ) ; if ( bluemap == ( int * ) NULL ) ThrowDCMException ( ResourceLimitError , \"MemoryAllocationFailed\" ) ; p = data ; for ( i = 0 ; i < ( ssize_t ) colors ; i ++ ) { if ( image -> endian == MSBEndian ) index = ( unsigned short ) ( ( * p << 8 ) | * ( p + 1 ) ) ; else index = ( unsigned short ) ( * p | ( * ( p + 1 ) << 8 ) ) ; bluemap [ i ] = ( int ) index ; p += 2 ; } break ; } default : break ; } break ; } case 0x2050 : { switch ( element ) { case 0x0020 : { if ( ( data != ( unsigned char * ) NULL ) && ( strncmp ( ( char * ) data , \"INVERSE\" , 7 ) == 0 ) ) info . polarity = MagickTrue ; break ; } default : break ; } break ; } default : break ; } if ( data != ( unsigned char * ) NULL ) { char * attribute ; for ( i = 0 ; dicom_info [ i ] . description != ( char * ) NULL ; i ++ ) if ( ( group == dicom_info [ i ] . group ) && ( element == dicom_info [ i ] . element ) ) break ; if ( dicom_info [ i ] . description != ( char * ) NULL ) { attribute = AcquireString ( \"dcm:\" ) ; ( void ) ConcatenateString ( & attribute , dicom_info [ i ] . description ) ; for ( i = 0 ; i < ( ssize_t ) MagickMax ( length , 4 ) ; i ++ ) if ( isprint ( ( int ) data [ i ] ) == MagickFalse ) break ; if ( ( i == ( ssize_t ) length ) || ( length > 4 ) ) { ( void ) SubstituteString ( & attribute , \"<S2SV_blank>\" , \"\" ) ; ( void ) SetImageProperty ( image , attribute , ( char * ) data ) ; } attribute = DestroyString ( attribute ) ; } } if ( image_info -> verbose != MagickFalse ) { if ( data == ( unsigned char * ) NULL ) ( void ) FormatLocaleFile ( stdout , \"%d\\\\n\" , datum ) ; else { for ( i = 0 ; i < ( ssize_t ) MagickMax ( length , 4 ) ; i ++ ) if ( isprint ( ( int ) data [ i ] ) == MagickFalse ) break ; if ( ( i != ( ssize_t ) length ) && ( length <= 4 ) ) { ssize_t j ; datum = 0 ; for ( j = ( ssize_t ) length - 1 ; j >= 0 ; j -- ) datum = ( 256 * datum + data [ j ] ) ; ( void ) FormatLocaleFile ( stdout , \"%d\" , datum ) ; } else for ( i = 0 ; i < ( ssize_t ) length ; i ++ ) if ( isprint ( ( int ) data [ i ] ) != MagickFalse ) ( void ) FormatLocaleFile ( stdout , \"%c\" , data [ i ] ) ; else ( void ) FormatLocaleFile ( stdout , \"%c\" , '.' ) ; ( void ) FormatLocaleFile ( stdout , \"\\\\n\" ) ; } } if ( data != ( unsigned char * ) NULL ) data = ( unsigned char * ) RelinquishMagickMemory ( data ) ; if ( EOFBlob ( image ) != MagickFalse ) { ThrowFileException ( exception , CorruptImageError , \"UnexpectedEndOfFile\" , image -> filename ) ; break ; } } if ( ( width == 0 ) || ( height == 0 ) ) ThrowDCMException ( CorruptImageError , \"ImproperImageHeader\" ) ; image -> columns = ( size_t ) width ; image -> rows = ( size_t ) height ; if ( info . signed_data == 0xffff ) info . signed_data = ( size_t ) ( info . significant_bits == 16 ? 1 : 0 ) ; if ( ( image -> compression == JPEGCompression ) || ( image -> compression == JPEG2000Compression ) ) { Image * images ; ImageInfo * read_info ; int c ; size_t length ; unsigned int tag ; for ( i = 0 ; i < ( ssize_t ) stream_info -> remaining ; i ++ ) ( void ) ReadBlobByte ( image ) ; tag = ( ReadBlobLSBShort ( image ) << 16 ) | ReadBlobLSBShort ( image ) ; ( void ) tag ; length = ( size_t ) ReadBlobLSBLong ( image ) ; stream_info -> offset_count = length >> 2 ; if ( stream_info -> offset_count != 0 ) { MagickOffsetType offset ; stream_info -> offsets = ( ssize_t * ) AcquireQuantumMemory ( stream_info -> offset_count , sizeof ( * stream_info -> offsets ) ) ; if ( stream_info -> offsets == ( ssize_t * ) NULL ) ThrowDCMException ( ResourceLimitError , \"MemoryAllocationFailed\" ) ; for ( i = 0 ; i < ( ssize_t ) stream_info -> offset_count ; i ++ ) stream_info -> offsets [ i ] = ( ssize_t ) ReadBlobLSBSignedLong ( image ) ; offset = TellBlob ( image ) ; for ( i = 0 ; i < ( ssize_t ) stream_info -> offset_count ; i ++ ) stream_info -> offsets [ i ] += offset ; } read_info = CloneImageInfo ( image_info ) ; SetImageInfoBlob ( read_info , ( void * ) NULL , 0 ) ; images = NewImageList ( ) ; for ( scene = 0 ; scene < ( ssize_t ) number_scenes ; scene ++ ) { char filename [ MaxTextExtent ] ; const char * property ; FILE * file ; Image * jpeg_image ; int unique_file ; unsigned int tag ; tag = ( ReadBlobLSBShort ( image ) << 16 ) | ReadBlobLSBShort ( image ) ; length = ( size_t ) ReadBlobLSBLong ( image ) ; if ( tag == 0xFFFEE0DD ) break ; if ( tag != 0xFFFEE000 ) ThrowDCMException ( CorruptImageError , \"ImproperImageHeader\" ) ; file = ( FILE * ) NULL ; unique_file = AcquireUniqueFileResource ( filename ) ; if ( unique_file != - 1 ) file = fdopen ( unique_file , \"wb\" ) ; if ( file == ( FILE * ) NULL ) { ( void ) RelinquishUniqueFileResource ( filename ) ; ThrowFileException ( exception , FileOpenError , \"UnableToCreateTemporaryFile\" , filename ) ; break ; } for ( ; length != 0 ; length -- ) { c = ReadBlobByte ( image ) ; if ( c == EOF ) { ThrowFileException ( exception , CorruptImageError , \"UnexpectedEndOfFile\" , image -> filename ) ; break ; } ( void ) fputc ( c , file ) ; } ( void ) fclose ( file ) ; ( void ) FormatLocaleString ( read_info -> filename , MaxTextExtent , \"jpeg:%s\" , filename ) ; if ( image -> compression == JPEG2000Compression ) ( void ) FormatLocaleString ( read_info -> filename , MaxTextExtent , \"j2k:%s\" , filename ) ; jpeg_image = ReadImage ( read_info , exception ) ; if ( jpeg_image != ( Image * ) NULL ) { ResetImagePropertyIterator ( image ) ; property = GetNextImageProperty ( image ) ; while ( property != ( const char * ) NULL ) { ( void ) SetImageProperty ( jpeg_image , property , GetImageProperty ( image , property ) ) ; property = GetNextImageProperty ( image ) ; } AppendImageToList ( & images , jpeg_image ) ; } ( void ) RelinquishUniqueFileResource ( filename ) ; } read_info = DestroyImageInfo ( read_info ) ; image = DestroyImage ( image ) ; return ( GetFirstImageInList ( images ) ) ; } if ( info . depth != ( 1UL * MAGICKCORE_QUANTUM_DEPTH ) ) { QuantumAny range ; size_t length ; length = ( size_t ) ( GetQuantumRange ( info . depth ) + 1 ) ; info . scale = ( Quantum * ) AcquireQuantumMemory ( length , sizeof ( * info . scale ) ) ; if ( info . scale == ( Quantum * ) NULL ) ThrowDCMException ( ResourceLimitError , \"MemoryAllocationFailed\" ) ; range = GetQuantumRange ( info . depth ) ; for ( i = 0 ; i <= ( ssize_t ) GetQuantumRange ( info . depth ) ; i ++ ) info . scale [ i ] = ScaleAnyToQuantum ( ( size_t ) i , range ) ; } if ( image -> compression == RLECompression ) { size_t length ; unsigned int tag ; for ( i = 0 ; i < ( ssize_t ) stream_info -> remaining ; i ++ ) ( void ) ReadBlobByte ( image ) ; tag = ( ReadBlobLSBShort ( image ) << 16 ) | ReadBlobLSBShort ( image ) ; ( void ) tag ; length = ( size_t ) ReadBlobLSBLong ( image ) ; stream_info -> offset_count = length >> 2 ; if ( stream_info -> offset_count != 0 ) { MagickOffsetType offset ; stream_info -> offsets = ( ssize_t * ) AcquireQuantumMemory ( stream_info -> offset_count , sizeof ( * stream_info -> offsets ) ) ; if ( stream_info -> offsets == ( ssize_t * ) NULL ) ThrowDCMException ( ResourceLimitError , \"MemoryAllocationFailed\" ) ; for ( i = 0 ; i < ( ssize_t ) stream_info -> offset_count ; i ++ ) stream_info -> offsets [ i ] = ( ssize_t ) ReadBlobLSBSignedLong ( image ) ; offset = TellBlob ( image ) + 8 ; for ( i = 0 ; i < ( ssize_t ) stream_info -> offset_count ; i ++ ) stream_info -> offsets [ i ] += offset ; } } for ( scene = 0 ; scene < ( ssize_t ) number_scenes ; scene ++ ) { if ( image_info -> ping != MagickFalse ) break ; image -> columns = ( size_t ) width ; image -> rows = ( size_t ) height ; image -> depth = info . depth ; status = SetImageExtent ( image , image -> columns , image -> rows ) ; if ( status == MagickFalse ) { InheritException ( exception , & image -> exception ) ; break ; } image -> colorspace = RGBColorspace ; if ( ( image -> colormap == ( PixelPacket * ) NULL ) && ( info . samples_per_pixel == 1 ) ) { int index ; size_t one ; one = 1 ; if ( colors == 0 ) colors = one << info . depth ; if ( AcquireImageColormap ( image , colors ) == MagickFalse ) ThrowDCMException ( ResourceLimitError , \"MemoryAllocationFailed\" ) ; if ( redmap != ( int * ) NULL ) for ( i = 0 ; i < ( ssize_t ) colors ; i ++ ) { index = redmap [ i ] ; if ( ( info . scale != ( Quantum * ) NULL ) && ( index <= ( int ) info . max_value ) ) index = ( int ) info . scale [ index ] ; image -> colormap [ i ] . red = ( Quantum ) index ; } if ( greenmap != ( int * ) NULL ) for ( i = 0 ; i < ( ssize_t ) colors ; i ++ ) { index = greenmap [ i ] ; if ( ( info . scale != ( Quantum * ) NULL ) && ( index <= ( int ) info . max_value ) ) index = ( int ) info . scale [ index ] ; image -> colormap [ i ] . green = ( Quantum ) index ; } if ( bluemap != ( int * ) NULL ) for ( i = 0 ; i < ( ssize_t ) colors ; i ++ ) { index = bluemap [ i ] ; if ( ( info . scale != ( Quantum * ) NULL ) && ( index <= ( int ) info . max_value ) ) index = ( int ) info . scale [ index ] ; image -> colormap [ i ] . blue = ( Quantum ) index ; } if ( graymap != ( int * ) NULL ) for ( i = 0 ; i < ( ssize_t ) colors ; i ++ ) { index = graymap [ i ] ; if ( ( info . scale != ( Quantum * ) NULL ) && ( index <= ( int ) info . max_value ) ) index = ( int ) info . scale [ index ] ; image -> colormap [ i ] . red = ( Quantum ) index ; image -> colormap [ i ] . green = ( Quantum ) index ; image -> colormap [ i ] . blue = ( Quantum ) index ; } } if ( image -> compression == RLECompression ) { unsigned int tag ; for ( i = 0 ; i < ( ssize_t ) stream_info -> remaining ; i ++ ) ( void ) ReadBlobByte ( image ) ; tag = ( ReadBlobLSBShort ( image ) << 16 ) | ReadBlobLSBShort ( image ) ; stream_info -> remaining = ( size_t ) ReadBlobLSBLong ( image ) ; if ( ( tag != 0xFFFEE000 ) || ( stream_info -> remaining <= 64 ) || ( EOFBlob ( image ) != MagickFalse ) ) ThrowDCMException ( CorruptImageError , \"ImproperImageHeader\" ) ; stream_info -> count = 0 ; stream_info -> segment_count = ReadBlobLSBLong ( image ) ; for ( i = 0 ; i < 15 ; i ++ ) stream_info -> segments [ i ] = ( ssize_t ) ReadBlobLSBSignedLong ( image ) ; stream_info -> remaining -= 64 ; if ( stream_info -> segment_count > 1 ) { info . bytes_per_pixel = 1 ; info . depth = 8 ; if ( stream_info -> offset_count > 0 ) ( void ) SeekBlob ( image , stream_info -> offsets [ 0 ] + stream_info -> segments [ 0 ] , SEEK_SET ) ; } } if ( ( info . samples_per_pixel > 1 ) && ( image -> interlace == PlaneInterlace ) ) { register ssize_t x ; register PixelPacket * q ; ssize_t y ; for ( i = 0 ; i < ( ssize_t ) info . samples_per_pixel ; i ++ ) { for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { q = GetAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( PixelPacket * ) NULL ) break ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { switch ( ( int ) i ) { case 0 : { SetPixelRed ( q , ScaleCharToQuantum ( ( unsigned char ) ReadDCMByte ( stream_info , image ) ) ) ; break ; } case 1 : { SetPixelGreen ( q , ScaleCharToQuantum ( ( unsigned char ) ReadDCMByte ( stream_info , image ) ) ) ; break ; } case 2 : { SetPixelBlue ( q , ScaleCharToQuantum ( ( unsigned char ) ReadDCMByte ( stream_info , image ) ) ) ; break ; } case 3 : { SetPixelAlpha ( q , ScaleCharToQuantum ( ( unsigned char ) ReadDCMByte ( stream_info , image ) ) ) ; break ; } default : break ; } q ++ ; } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ; if ( status == MagickFalse ) break ; } } } } else { const char * option ; option = GetImageOption ( image_info , \"dcm:display-range\" ) ; if ( option != ( const char * ) NULL ) { if ( LocaleCompare ( option , \"reset\" ) == 0 ) info . window_width = 0 ; } option = GetImageOption ( image_info , \"dcm:window\" ) ; if ( option != ( char * ) NULL ) { GeometryInfo geometry_info ; MagickStatusType flags ; flags = ParseGeometry ( option , & geometry_info ) ; if ( flags & RhoValue ) info . window_center = geometry_info . rho ; if ( flags & SigmaValue ) info . window_width = geometry_info . sigma ; info . rescale = MagickTrue ; } option = GetImageOption ( image_info , \"dcm:rescale\" ) ; if ( option != ( char * ) NULL ) info . rescale = IsStringTrue ( option ) ; if ( ( info . window_center != 0 ) && ( info . window_width == 0 ) ) info . window_width = info . window_center ; status = ReadDCMPixels ( image , & info , stream_info , MagickTrue , exception ) ; if ( ( status != MagickFalse ) && ( stream_info -> segment_count > 1 ) ) { if ( stream_info -> offset_count > 0 ) ( void ) SeekBlob ( image , stream_info -> offsets [ 0 ] + stream_info -> segments [ 1 ] , SEEK_SET ) ; ( void ) ReadDCMPixels ( image , & info , stream_info , MagickFalse , exception ) ; } } if ( SetImageGray ( image , exception ) != MagickFalse ) ( void ) SetImageColorspace ( image , GRAYColorspace ) ; if ( EOFBlob ( image ) != MagickFalse ) { ThrowFileException ( exception , CorruptImageError , \"UnexpectedEndOfFile\" , image -> filename ) ; break ; } if ( image_info -> number_scenes != 0 ) if ( image -> scene >= ( image_info -> scene + image_info -> number_scenes - 1 ) ) break ; if ( scene < ( ssize_t ) ( number_scenes - 1 ) ) { AcquireNextImage ( image_info , image ) ; if ( GetNextImageInList ( image ) == ( Image * ) NULL ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } image = SyncNextImageInList ( image ) ; status = SetImageProgress ( image , LoadImagesTag , TellBlob ( image ) , GetBlobSize ( image ) ) ; if ( status == MagickFalse ) break ; } } if ( stream_info -> offsets != ( ssize_t * ) NULL ) stream_info -> offsets = ( ssize_t * ) RelinquishMagickMemory ( stream_info -> offsets ) ; stream_info = ( DCMStreamInfo * ) RelinquishMagickMemory ( stream_info ) ; if ( info . scale != ( Quantum * ) NULL ) info . scale = ( Quantum * ) RelinquishMagickMemory ( info . scale ) ; if ( graymap != ( int * ) NULL ) graymap = ( int * ) RelinquishMagickMemory ( graymap ) ; if ( bluemap != ( int * ) NULL ) bluemap = ( int * ) RelinquishMagickMemory ( bluemap ) ; if ( greenmap != ( int * ) NULL ) greenmap = ( int * ) RelinquishMagickMemory ( greenmap ) ; if ( redmap != ( int * ) NULL ) redmap = ( int * ) RelinquishMagickMemory ( redmap ) ; ( void ) CloseBlob ( image ) ; return ( GetFirstImageInList ( image ) ) ; }\n",
      "fixed_code": "<S2SV_ModStart> , message ) \\\\\\n{ <S2SV_ModEnd> if ( data <S2SV_ModStart> ) ) ; \\\\\\n} <S2SV_ModEnd> char explicit_vr [ <S2SV_ModStart> image ) ) ThrowDCMException <S2SV_ModEnd> ( CorruptImageError ,\n",
      "source_code_length": 28784,
      "target_code_length": 199,
      "vulnerability_patterns": {
        "use_after_free": 1,
        "integer_overflow": 38,
        "null_pointer": 104,
        "total": 143
      },
      "total_patterns": 143,
      "original_address": "https://github.com/ImageMagick/ImageMagick/commit/9f375e7080a2c1044cd546854d0548b4bfb429d0",
      "discovery_time": "2017-08-07T15:29Z",
      "project_commit_id": "ImageMagick@ImageMagick/9f375e7080a2c1044cd546854d0548b4bfb429d0",
      "extraction_time": "2025-08-31T15:41:49.181317",
      "label": 1,
      "vulnerability_type": "missing_release_of_memory",
      "difficulty_level": "advanced",
      "risk_factors": [
        "critical_infrastructure",
        "use_after_free"
      ],
      "attack_vectors": [
        "fuzzing",
        "code_analysis",
        "reverse_engineering"
      ],
      "mitigation_strategies": [
        "dynamic_analysis",
        "static_analysis",
        "fuzzing",
        "code_review",
        "secure_coding_practices"
      ],
      "code_differences": {
        "has_differences": true,
        "source_lines": 2,
        "target_lines": 2,
        "character_differences": 28585,
        "similarity_percentage": 3.359173126614987
      },
      "vulnerability_location": {
        "vulnerability_present": true,
        "fix_applied": true,
        "code_changed": true,
        "estimated_lines_changed": 0
      }
    },
    {
      "cve_id": "CVE-2019-19275",
      "cwe_id": "CWE-125",
      "cwe_name": "Out-of-bounds Read",
      "project": "python",
      "severity": "critical",
      "weaponization_score": 8.5,
      "is_critical": true,
      "is_weaponizable": true,
      "is_high_priority_project": true,
      "vulnerable_code": "CWE-125 static arguments_ty ast_for_arguments ( struct compiling * c , const node * n ) { int i , j , k , nposargs = 0 , nkwonlyargs = 0 ; int nposdefaults = 0 , found_default = 0 ; asdl_seq * posargs , * posdefaults , * kwonlyargs , * kwdefaults ; arg_ty vararg = NULL , kwarg = NULL ; arg_ty arg ; node * ch ; if ( TYPE ( n ) == parameters ) { if ( NCH ( n ) == 2 ) return arguments ( NULL , NULL , NULL , NULL , NULL , NULL , c -> c_arena ) ; n = CHILD ( n , 1 ) ; } assert ( TYPE ( n ) == typedargslist || TYPE ( n ) == varargslist ) ; for ( i = 0 ; i < NCH ( n ) ; i ++ ) { ch = CHILD ( n , i ) ; if ( TYPE ( ch ) == STAR ) { i ++ ; if ( i < NCH ( n ) && ( TYPE ( CHILD ( n , i ) ) == tfpdef || TYPE ( CHILD ( n , i ) ) == vfpdef ) ) { i ++ ; } break ; } if ( TYPE ( ch ) == DOUBLESTAR ) break ; if ( TYPE ( ch ) == vfpdef || TYPE ( ch ) == tfpdef ) nposargs ++ ; if ( TYPE ( ch ) == EQUAL ) nposdefaults ++ ; } for ( ; i < NCH ( n ) ; ++ i ) { ch = CHILD ( n , i ) ; if ( TYPE ( ch ) == DOUBLESTAR ) break ; if ( TYPE ( ch ) == tfpdef || TYPE ( ch ) == vfpdef ) nkwonlyargs ++ ; } posargs = ( nposargs ? _Ta3_asdl_seq_new ( nposargs , c -> c_arena ) : NULL ) ; if ( ! posargs && nposargs ) return NULL ; kwonlyargs = ( nkwonlyargs ? _Ta3_asdl_seq_new ( nkwonlyargs , c -> c_arena ) : NULL ) ; if ( ! kwonlyargs && nkwonlyargs ) return NULL ; posdefaults = ( nposdefaults ? _Ta3_asdl_seq_new ( nposdefaults , c -> c_arena ) : NULL ) ; if ( ! posdefaults && nposdefaults ) return NULL ; kwdefaults = ( nkwonlyargs ? _Ta3_asdl_seq_new ( nkwonlyargs , c -> c_arena ) : NULL ) ; if ( ! kwdefaults && nkwonlyargs ) return NULL ; <S2SV_StartBug> if ( nposargs + nkwonlyargs > 255 ) { <S2SV_EndBug> ast_error ( c , n , \"more<S2SV_blank>than<S2SV_blank>255<S2SV_blank>arguments\" ) ; return NULL ; } i = 0 ; j = 0 ; k = 0 ; while ( i < NCH ( n ) ) { ch = CHILD ( n , i ) ; switch ( TYPE ( ch ) ) { case tfpdef : case vfpdef : if ( i + 1 < NCH ( n ) && TYPE ( CHILD ( n , i + 1 ) ) == EQUAL ) { expr_ty expression = ast_for_expr ( c , CHILD ( n , i + 2 ) ) ; if ( ! expression ) return NULL ; assert ( posdefaults != NULL ) ; asdl_seq_SET ( posdefaults , j ++ , expression ) ; i += 2 ; found_default = 1 ; } else if ( found_default ) { ast_error ( c , n , \"non-default<S2SV_blank>argument<S2SV_blank>follows<S2SV_blank>default<S2SV_blank>argument\" ) ; return NULL ; } arg = ast_for_arg ( c , ch ) ; if ( ! arg ) return NULL ; asdl_seq_SET ( posargs , k ++ , arg ) ; i += 1 ; <S2SV_StartBug> if ( i < NCH ( n ) && TYPE ( CHILD ( n , i ) ) == COMMA ) <S2SV_EndBug> i += 1 ; break ; case STAR : if ( i + 1 >= NCH ( n ) || ( i + 2 == NCH ( n ) && ( TYPE ( CHILD ( n , i + 1 ) ) == COMMA || TYPE ( CHILD ( n , i + 1 ) ) == TYPE_COMMENT ) ) ) { ast_error ( c , CHILD ( n , i ) , \"named<S2SV_blank>arguments<S2SV_blank>must<S2SV_blank>follow<S2SV_blank>bare<S2SV_blank>*\" ) ; return NULL ; } ch = CHILD ( n , i + 1 ) ; if ( TYPE ( ch ) == COMMA ) { int res = 0 ; i += 2 ; <S2SV_StartBug> if ( i < NCH ( n ) && TYPE ( CHILD ( n , i ) ) == TYPE_COMMENT ) { <S2SV_EndBug> ast_error ( c , CHILD ( n , i ) , \"bare<S2SV_blank>*<S2SV_blank>has<S2SV_blank>associated<S2SV_blank>type<S2SV_blank>comment\" ) ; return NULL ; } res = handle_keywordonly_args ( c , n , i , kwonlyargs , kwdefaults ) ; if ( res == - 1 ) return NULL ; i = res ; } else { vararg = ast_for_arg ( c , ch ) ; if ( ! vararg ) return NULL ; i += 2 ; <S2SV_StartBug> if ( i < NCH ( n ) && TYPE ( CHILD ( n , i ) ) == COMMA ) <S2SV_EndBug> i += 1 ; <S2SV_StartBug> if ( i < NCH ( n ) && TYPE ( CHILD ( n , i ) ) == TYPE_COMMENT ) { <S2SV_EndBug> vararg -> type_comment = NEW_TYPE_COMMENT ( CHILD ( n , i ) ) ; i += 1 ; } if ( i < NCH ( n ) && ( TYPE ( CHILD ( n , i ) ) == tfpdef || TYPE ( CHILD ( n , i ) ) == vfpdef ) ) { int res = 0 ; res = handle_keywordonly_args ( c , n , i , kwonlyargs , kwdefaults ) ; if ( res == - 1 ) return NULL ; i = res ; } } break ; case DOUBLESTAR : ch = CHILD ( n , i + 1 ) ; assert ( TYPE ( ch ) == tfpdef || TYPE ( ch ) == vfpdef ) ; kwarg = ast_for_arg ( c , ch ) ; if ( ! kwarg ) return NULL ; i += 2 ; <S2SV_StartBug> if ( i < NCH ( n ) && TYPE ( CHILD ( n , i ) ) == COMMA ) <S2SV_EndBug> i += 1 ; break ; case TYPE_COMMENT : assert ( i ) ; if ( kwarg ) arg = kwarg ; arg -> type_comment = NEW_TYPE_COMMENT ( ch ) ; i += 1 ; break ; default : PyErr_Format ( PyExc_SystemError , \"unexpected<S2SV_blank>node<S2SV_blank>in<S2SV_blank>varargslist:<S2SV_blank>%d<S2SV_blank>@<S2SV_blank>%d\" , TYPE ( ch ) , i ) ; return NULL ; } } return arguments ( posargs , vararg , kwonlyargs , kwdefaults , kwarg , posdefaults , c -> c_arena ) ; }\n",
      "fixed_code": "<S2SV_ModStart> return NULL ; <S2SV_ModEnd> i = 0 <S2SV_ModStart> ; if ( <S2SV_ModEnd> TYPE ( CHILD <S2SV_ModStart> ; if ( <S2SV_ModEnd> TYPE ( CHILD <S2SV_ModStart> ; if ( <S2SV_ModEnd> TYPE ( CHILD <S2SV_ModStart> ; if ( <S2SV_ModEnd> TYPE ( CHILD <S2SV_ModStart> ; if ( <S2SV_ModEnd> TYPE ( CHILD\n",
      "source_code_length": 4617,
      "target_code_length": 300,
      "vulnerability_patterns": {
        "null_pointer": 24,
        "total": 24
      },
      "total_patterns": 24,
      "original_address": "https://github.com/python/typed_ast/commit/156afcb26c198e162504a57caddfe0acd9ed7dce",
      "discovery_time": "2019-11-26T15:15Z",
      "project_commit_id": "python@typed_ast/156afcb26c198e162504a57caddfe0acd9ed7dce",
      "extraction_time": "2025-08-31T15:41:49.181540",
      "label": 1,
      "vulnerability_type": "out-of-bounds_read",
      "difficulty_level": "advanced",
      "risk_factors": [
        "information_disclosure",
        "memory_corruption",
        "integer_overflow",
        "critical_infrastructure"
      ],
      "attack_vectors": [
        "memory_manipulation",
        "malicious_input",
        "code_analysis",
        "buffer_overflow",
        "reverse_engineering",
        "fuzzing"
      ],
      "mitigation_strategies": [
        "safe_string_functions",
        "dynamic_analysis",
        "code_review",
        "static_analysis",
        "memory_safety_checks",
        "input_validation",
        "fuzzing",
        "bounds_checking",
        "secure_coding_practices"
      ],
      "code_differences": {
        "has_differences": true,
        "source_lines": 2,
        "target_lines": 2,
        "character_differences": 4317,
        "similarity_percentage": 9.70873786407767
      },
      "vulnerability_location": {
        "vulnerability_present": true,
        "fix_applied": true,
        "code_changed": true,
        "estimated_lines_changed": 0
      }
    },
    {
      "cve_id": "CVE-2018-9496",
      "cwe_id": "CWE-787",
      "cwe_name": "Out-of-bounds Write",
      "project": "external",
      "severity": "critical",
      "weaponization_score": 8.5,
      "is_critical": true,
      "is_weaponizable": true,
      "is_high_priority_project": false,
      "vulnerable_code": "CWE-787 WORD32 ixheaacd_real_synth_filt ( ia_esbr_hbe_txposer_struct * ptr_hbe_txposer , WORD32 num_columns , FLOAT32 qmf_buf_real [ ] [ 64 ] , FLOAT32 qmf_buf_imag [ ] [ 64 ] ) { WORD32 i , j , k , l , idx ; FLOAT32 g [ 640 ] ; FLOAT32 w [ 640 ] ; FLOAT32 synth_out [ 128 ] ; FLOAT32 accu_r ; WORD32 synth_size = ptr_hbe_txposer -> synth_size ; FLOAT32 * ptr_cos_tab_trans_qmf = ( FLOAT32 * ) & ixheaacd_cos_table_trans_qmf [ 0 ] [ 0 ] + ptr_hbe_txposer -> k_start * 32 ; FLOAT32 * buffer = ptr_hbe_txposer -> synth_buf ; for ( idx = 0 ; idx < num_columns ; idx ++ ) { FLOAT32 loc_qmf_buf [ 64 ] ; FLOAT32 * synth_buf_r = loc_qmf_buf ; FLOAT32 * out_buf = ptr_hbe_txposer -> ptr_input_buf + ( idx + 1 ) * ptr_hbe_txposer -> synth_size ; FLOAT32 * synth_cos_tab = ptr_hbe_txposer -> synth_cos_tab ; const FLOAT32 * interp_window_coeff = ptr_hbe_txposer -> synth_wind_coeff ; if ( ptr_hbe_txposer -> k_start < 0 ) return - 1 ; for ( k = 0 ; k < synth_size ; k ++ ) { WORD32 ki = ptr_hbe_txposer -> k_start + k ; synth_buf_r [ k ] = ( FLOAT32 ) ( ptr_cos_tab_trans_qmf [ ( k << 1 ) + 0 ] * qmf_buf_real [ idx ] [ ki ] + ptr_cos_tab_trans_qmf [ ( k << 1 ) + 1 ] * qmf_buf_imag [ idx ] [ ki ] ) ; synth_buf_r [ k + ptr_hbe_txposer -> synth_size ] = 0 ; } for ( l = ( 20 * synth_size - 1 ) ; l >= 2 * synth_size ; l -- ) { buffer [ l ] = buffer [ l - 2 * synth_size ] ; } if ( synth_size == 20 ) { FLOAT32 * psynth_cos_tab = synth_cos_tab ; for ( l = 0 ; l < ( synth_size + 1 ) ; l ++ ) { accu_r = 0.0 ; for ( k = 0 ; k < synth_size ; k ++ ) { accu_r += synth_buf_r [ k ] * psynth_cos_tab [ k ] ; } buffer [ 0 + l ] = accu_r ; buffer [ synth_size - l ] = accu_r ; psynth_cos_tab = psynth_cos_tab + synth_size ; } for ( l = ( synth_size + 1 ) ; l < ( 2 * synth_size - synth_size / 2 ) ; l ++ ) { accu_r = 0.0 ; for ( k = 0 ; k < synth_size ; k ++ ) { accu_r += synth_buf_r [ k ] * psynth_cos_tab [ k ] ; } buffer [ 0 + l ] = accu_r ; buffer [ 3 * synth_size - l ] = - accu_r ; psynth_cos_tab = psynth_cos_tab + synth_size ; } accu_r = 0.0 ; for ( k = 0 ; k < synth_size ; k ++ ) { accu_r += synth_buf_r [ k ] * psynth_cos_tab [ k ] ; } buffer [ 3 * synth_size >> 1 ] = accu_r ; } else { FLOAT32 tmp ; FLOAT32 * ptr_u = synth_out ; WORD32 kmax = ( synth_size >> 1 ) ; FLOAT32 * syn_buf = & buffer [ kmax ] ; kmax += synth_size ; <S2SV_StartBug> if ( ixheaacd_real_synth_fft != NULL ) <S2SV_EndBug> <S2SV_StartBug> ( * ixheaacd_real_synth_fft ) ( synth_buf_r , synth_out , synth_size * 2 ) ; <S2SV_EndBug> else return - 1 ; for ( k = 0 ; k < kmax ; k ++ ) { tmp = ( ( * ptr_u ++ ) * ( * synth_cos_tab ++ ) ) ; tmp -= ( ( * ptr_u ++ ) * ( * synth_cos_tab ++ ) ) ; * syn_buf ++ = tmp ; } syn_buf = & buffer [ 0 ] ; kmax -= synth_size ; for ( k = 0 ; k < kmax ; k ++ ) { tmp = ( ( * ptr_u ++ ) * ( * synth_cos_tab ++ ) ) ; tmp -= ( ( * ptr_u ++ ) * ( * synth_cos_tab ++ ) ) ; * syn_buf ++ = tmp ; } } for ( i = 0 ; i < 5 ; i ++ ) { memcpy ( & g [ ( 2 * i + 0 ) * synth_size ] , & buffer [ ( 4 * i + 0 ) * synth_size ] , sizeof ( FLOAT32 ) * synth_size ) ; memcpy ( & g [ ( 2 * i + 1 ) * synth_size ] , & buffer [ ( 4 * i + 3 ) * synth_size ] , sizeof ( FLOAT32 ) * synth_size ) ; } for ( k = 0 ; k < 10 * synth_size ; k ++ ) { w [ k ] = g [ k ] * interp_window_coeff [ k ] ; } for ( i = 0 ; i < synth_size ; i ++ ) { accu_r = 0.0 ; for ( j = 0 ; j < 10 ; j ++ ) { accu_r = accu_r + w [ synth_size * j + i ] ; } out_buf [ i ] = ( FLOAT32 ) accu_r ; } } return 0 ; }\n",
      "fixed_code": "<S2SV_ModStart> ; if ( ptr_hbe_txposer -> <S2SV_ModStart> ) ( * ( ptr_hbe_txposer -> ixheaacd_real_synth_fft ) ) <S2SV_ModEnd> ( synth_buf_r ,\n",
      "source_code_length": 3454,
      "target_code_length": 143,
      "vulnerability_patterns": {
        "buffer_overflow": 2,
        "integer_overflow": 31,
        "null_pointer": 10,
        "total": 43
      },
      "total_patterns": 43,
      "original_address": "https://android.googlesource.com/platform/external/libxaac/+/04e8cd58f075bec5892e369c8deebca9c67e855c",
      "discovery_time": "2018-10-02T19:29Z",
      "project_commit_id": "external@libxaac/04e8cd58f075bec5892e369c8deebca9c67e855c",
      "extraction_time": "2025-08-31T15:41:49.181587",
      "label": 1,
      "vulnerability_type": "out-of-bounds_write",
      "difficulty_level": "advanced",
      "risk_factors": [
        "system_crash",
        "memory_corruption",
        "buffer_overflow",
        "arbitrary_code_execution"
      ],
      "attack_vectors": [
        "memory_manipulation",
        "malicious_input",
        "code_analysis",
        "buffer_overflow",
        "reverse_engineering",
        "fuzzing"
      ],
      "mitigation_strategies": [
        "safe_string_functions",
        "dynamic_analysis",
        "code_review",
        "static_analysis",
        "memory_safety_checks",
        "input_validation",
        "fuzzing",
        "bounds_checking",
        "secure_coding_practices"
      ],
      "code_differences": {
        "has_differences": true,
        "source_lines": 2,
        "target_lines": 2,
        "character_differences": 3311,
        "similarity_percentage": 11.363636363636363
      },
      "vulnerability_location": {
        "vulnerability_present": true,
        "fix_applied": true,
        "code_changed": true,
        "estimated_lines_changed": 0
      }
    },
    {
      "cve_id": "CVE-2018-16391",
      "cwe_id": "CWE-119",
      "cwe_name": "Buffer Overflow",
      "project": "OpenSC",
      "severity": "critical",
      "weaponization_score": 8.5,
      "is_critical": true,
      "is_weaponizable": true,
      "is_high_priority_project": false,
      "vulnerable_code": "CWE-119 static int tcos_select_file ( sc_card_t * card , const sc_path_t * in_path , sc_file_t * * file_out ) { sc_context_t * ctx ; sc_apdu_t apdu ; sc_file_t * file = NULL ; u8 buf [ SC_MAX_APDU_BUFFER_SIZE ] , pathbuf [ SC_MAX_PATH_SIZE ] , * path = pathbuf ; unsigned int i ; int r , pathlen ; assert ( card != NULL && in_path != NULL ) ; ctx = card -> ctx ; memcpy ( path , in_path -> value , in_path -> len ) ; pathlen = in_path -> len ; sc_format_apdu ( card , & apdu , SC_APDU_CASE_4_SHORT , 0xA4 , 0 , 0x04 ) ; switch ( in_path -> type ) { case SC_PATH_TYPE_FILE_ID : if ( pathlen != 2 ) return SC_ERROR_INVALID_ARGUMENTS ; case SC_PATH_TYPE_FROM_CURRENT : apdu . p1 = 9 ; break ; case SC_PATH_TYPE_DF_NAME : apdu . p1 = 4 ; break ; case SC_PATH_TYPE_PATH : apdu . p1 = 8 ; if ( pathlen >= 2 && memcmp ( path , \"\\\\x3F\\\\x00\" , 2 ) == 0 ) path += 2 , pathlen -= 2 ; if ( pathlen == 0 ) apdu . p1 = 0 ; break ; case SC_PATH_TYPE_PARENT : apdu . p1 = 3 ; pathlen = 0 ; break ; default : SC_FUNC_RETURN ( ctx , SC_LOG_DEBUG_VERBOSE , SC_ERROR_INVALID_ARGUMENTS ) ; } if ( pathlen == 0 ) apdu . cse = SC_APDU_CASE_2_SHORT ; apdu . lc = pathlen ; apdu . data = path ; apdu . datalen = pathlen ; if ( file_out != NULL ) { apdu . resp = buf ; apdu . resplen = sizeof ( buf ) ; apdu . le = 256 ; } else { apdu . resplen = 0 ; apdu . le = 0 ; apdu . p2 = 0x0C ; apdu . cse = ( pathlen == 0 ) ? SC_APDU_CASE_1 : SC_APDU_CASE_3_SHORT ; } r = sc_transmit_apdu ( card , & apdu ) ; SC_TEST_RET ( ctx , SC_LOG_DEBUG_NORMAL , r , \"APDU<S2SV_blank>transmit<S2SV_blank>failed\" ) ; r = sc_check_sw ( card , apdu . sw1 , apdu . sw2 ) ; if ( r || file_out == NULL ) SC_FUNC_RETURN ( ctx , SC_LOG_DEBUG_VERBOSE , r ) ; if ( apdu . resplen < 1 || apdu . resp [ 0 ] != 0x62 ) { sc_debug ( ctx , SC_LOG_DEBUG_NORMAL , \"received<S2SV_blank>invalid<S2SV_blank>template<S2SV_blank>%02X\\\\n\" , apdu . resp [ 0 ] ) ; SC_FUNC_RETURN ( ctx , SC_LOG_DEBUG_VERBOSE , SC_ERROR_UNKNOWN_DATA_RECEIVED ) ; } file = sc_file_new ( ) ; if ( file == NULL ) SC_FUNC_RETURN ( ctx , SC_LOG_DEBUG_NORMAL , SC_ERROR_OUT_OF_MEMORY ) ; * file_out = file ; file -> path = * in_path ; for ( i = 2 ; i + 1 < apdu . resplen && i + 1 + apdu . resp [ i + 1 ] < apdu . resplen ; i += 2 + apdu . resp [ i + 1 ] ) { <S2SV_StartBug> int j , len = apdu . resp [ i + 1 ] ; <S2SV_EndBug> unsigned char type = apdu . resp [ i ] , * d = apdu . resp + i + 2 ; switch ( type ) { case 0x80 : case 0x81 : file -> size = 0 ; for ( j = 0 ; j < len ; ++ j ) file -> size = ( file -> size << 8 ) | d [ j ] ; break ; case 0x82 : file -> shareable = ( d [ 0 ] & 0x40 ) ? 1 : 0 ; file -> ef_structure = d [ 0 ] & 7 ; switch ( ( d [ 0 ] >> 3 ) & 7 ) { case 0 : file -> type = SC_FILE_TYPE_WORKING_EF ; break ; case 7 : file -> type = SC_FILE_TYPE_DF ; break ; default : sc_debug ( ctx , SC_LOG_DEBUG_NORMAL , \"invalid<S2SV_blank>file<S2SV_blank>type<S2SV_blank>%02X<S2SV_blank>in<S2SV_blank>file<S2SV_blank>descriptor\\\\n\" , d [ 0 ] ) ; SC_FUNC_RETURN ( ctx , SC_LOG_DEBUG_VERBOSE , SC_ERROR_UNKNOWN_DATA_RECEIVED ) ; } break ; case 0x83 : file -> id = ( d [ 0 ] << 8 ) | d [ 1 ] ; break ; case 0x84 : <S2SV_StartBug> memcpy ( file -> name , d , len ) ; <S2SV_EndBug> <S2SV_StartBug> file -> namelen = len ; <S2SV_EndBug> break ; case 0x86 : sc_file_set_sec_attr ( file , d , len ) ; break ; default : if ( len > 0 ) sc_file_set_prop_attr ( file , d , len ) ; } } file -> magic = SC_FILE_MAGIC ; parse_sec_attr ( card , file , file -> sec_attr , file -> sec_attr_len ) ; return 0 ; }\n",
      "fixed_code": "<S2SV_ModStart> ] ) { size_t <S2SV_ModEnd> j , len <S2SV_ModStart> case 0x84 : file -> namelen = MIN ( sizeof file -> name , len ) ; <S2SV_ModStart> , d , <S2SV_ModEnd> file -> namelen <S2SV_ModStart> file -> namelen ) <S2SV_ModEnd> ; break ;\n",
      "source_code_length": 3513,
      "target_code_length": 243,
      "vulnerability_patterns": {
        "buffer_overflow": 2,
        "integer_overflow": 4,
        "null_pointer": 20,
        "total": 26
      },
      "total_patterns": 26,
      "original_address": "https://github.com/OpenSC/OpenSC/commit/360e95d45ac4123255a4c796db96337f332160ad#diff-477b7a40136bb418b10ce271c8664536",
      "discovery_time": "2018-09-03T14:29Z",
      "project_commit_id": "OpenSC@OpenSC/360e95d45ac4123255a4c796db96337f332160ad",
      "extraction_time": "2025-08-31T15:41:49.181625",
      "label": 1,
      "vulnerability_type": "buffer_overflow",
      "difficulty_level": "advanced",
      "risk_factors": [
        "system_crash",
        "memory_corruption",
        "buffer_overflow",
        "arbitrary_code_execution"
      ],
      "attack_vectors": [
        "memory_manipulation",
        "malicious_input",
        "code_analysis",
        "buffer_overflow",
        "reverse_engineering",
        "fuzzing"
      ],
      "mitigation_strategies": [
        "safe_string_functions",
        "dynamic_analysis",
        "code_review",
        "static_analysis",
        "memory_safety_checks",
        "input_validation",
        "fuzzing",
        "bounds_checking",
        "secure_coding_practices"
      ],
      "code_differences": {
        "has_differences": true,
        "source_lines": 2,
        "target_lines": 2,
        "character_differences": 3270,
        "similarity_percentage": 12.582781456953644
      },
      "vulnerability_location": {
        "vulnerability_present": true,
        "fix_applied": true,
        "code_changed": true,
        "estimated_lines_changed": 0
      }
    },
    {
      "cve_id": "CVE-2017-8062",
      "cwe_id": "CWE-119",
      "cwe_name": "Buffer Overflow",
      "project": "torvalds",
      "severity": "critical",
      "weaponization_score": 8.5,
      "is_critical": true,
      "is_weaponizable": true,
      "is_high_priority_project": false,
      "vulnerable_code": "CWE-119 static int tt_s2_4600_frontend_attach ( struct dvb_usb_adapter * adap ) { struct dvb_usb_device * d = adap -> dev ; <S2SV_StartBug> struct dw2102_state * state = d -> priv ; <S2SV_EndBug> u8 obuf [ 3 ] = { 0xe , 0x80 , 0 } ; u8 ibuf [ ] = { 0 } ; struct i2c_adapter * i2c_adapter ; struct i2c_client * client ; struct i2c_board_info board_info ; struct m88ds3103_platform_data m88ds3103_pdata = { } ; struct ts2020_config ts2020_config = { } ; <S2SV_StartBug> if ( dvb_usb_generic_rw ( d , obuf , 3 , ibuf , 1 , 0 ) < 0 ) <S2SV_EndBug> err ( \"command<S2SV_blank>0x0e<S2SV_blank>transfer<S2SV_blank>failed.\" ) ; <S2SV_StartBug> obuf [ 0 ] = 0xe ; <S2SV_EndBug> <S2SV_StartBug> obuf [ 1 ] = 0x02 ; <S2SV_EndBug> <S2SV_StartBug> obuf [ 2 ] = 1 ; <S2SV_EndBug> <S2SV_StartBug> if ( dvb_usb_generic_rw ( d , obuf , 3 , ibuf , 1 , 0 ) < 0 ) <S2SV_EndBug> err ( \"command<S2SV_blank>0x0e<S2SV_blank>transfer<S2SV_blank>failed.\" ) ; msleep ( 300 ) ; <S2SV_StartBug> obuf [ 0 ] = 0xe ; <S2SV_EndBug> <S2SV_StartBug> obuf [ 1 ] = 0x83 ; <S2SV_EndBug> <S2SV_StartBug> obuf [ 2 ] = 0 ; <S2SV_EndBug> <S2SV_StartBug> if ( dvb_usb_generic_rw ( d , obuf , 3 , ibuf , 1 , 0 ) < 0 ) <S2SV_EndBug> err ( \"command<S2SV_blank>0x0e<S2SV_blank>transfer<S2SV_blank>failed.\" ) ; <S2SV_StartBug> obuf [ 0 ] = 0xe ; <S2SV_EndBug> <S2SV_StartBug> obuf [ 1 ] = 0x83 ; <S2SV_EndBug> <S2SV_StartBug> obuf [ 2 ] = 1 ; <S2SV_EndBug> <S2SV_StartBug> if ( dvb_usb_generic_rw ( d , obuf , 3 , ibuf , 1 , 0 ) < 0 ) <S2SV_EndBug> err ( \"command<S2SV_blank>0x0e<S2SV_blank>transfer<S2SV_blank>failed.\" ) ; <S2SV_StartBug> obuf [ 0 ] = 0x51 ; <S2SV_EndBug> <S2SV_StartBug> if ( dvb_usb_generic_rw ( d , obuf , 1 , ibuf , 1 , 0 ) < 0 ) <S2SV_EndBug> <S2SV_StartBug> err ( \"command<S2SV_blank>0x51<S2SV_blank>transfer<S2SV_blank>failed.\" ) ; <S2SV_EndBug> m88ds3103_pdata . clk = 27000000 ; m88ds3103_pdata . i2c_wr_max = 33 ; m88ds3103_pdata . ts_mode = M88DS3103_TS_CI ; m88ds3103_pdata . ts_clk = 16000 ; m88ds3103_pdata . ts_clk_pol = 0 ; m88ds3103_pdata . spec_inv = 0 ; m88ds3103_pdata . agc = 0x99 ; m88ds3103_pdata . agc_inv = 0 ; m88ds3103_pdata . clk_out = M88DS3103_CLOCK_OUT_ENABLED ; m88ds3103_pdata . envelope_mode = 0 ; m88ds3103_pdata . lnb_hv_pol = 1 ; m88ds3103_pdata . lnb_en_pol = 0 ; memset ( & board_info , 0 , sizeof ( board_info ) ) ; strlcpy ( board_info . type , \"m88ds3103\" , I2C_NAME_SIZE ) ; board_info . addr = 0x68 ; board_info . platform_data = & m88ds3103_pdata ; request_module ( \"m88ds3103\" ) ; client = i2c_new_device ( & d -> i2c_adap , & board_info ) ; if ( client == NULL || client -> dev . driver == NULL ) return - ENODEV ; if ( ! try_module_get ( client -> dev . driver -> owner ) ) { i2c_unregister_device ( client ) ; return - ENODEV ; } adap -> fe_adap [ 0 ] . fe = m88ds3103_pdata . get_dvb_frontend ( client ) ; i2c_adapter = m88ds3103_pdata . get_i2c_adapter ( client ) ; state -> i2c_client_demod = client ; ts2020_config . fe = adap -> fe_adap [ 0 ] . fe ; memset ( & board_info , 0 , sizeof ( board_info ) ) ; strlcpy ( board_info . type , \"ts2022\" , I2C_NAME_SIZE ) ; board_info . addr = 0x60 ; board_info . platform_data = & ts2020_config ; request_module ( \"ts2020\" ) ; client = i2c_new_device ( i2c_adapter , & board_info ) ; if ( client == NULL || client -> dev . driver == NULL ) { dvb_frontend_detach ( adap -> fe_adap [ 0 ] . fe ) ; return - ENODEV ; } if ( ! try_module_get ( client -> dev . driver -> owner ) ) { i2c_unregister_device ( client ) ; dvb_frontend_detach ( adap -> fe_adap [ 0 ] . fe ) ; return - ENODEV ; } adap -> fe_adap [ 0 ] . fe -> ops . read_signal_strength = adap -> fe_adap [ 0 ] . fe -> ops . tuner_ops . get_rf_strength ; state -> i2c_client_tuner = client ; state -> fe_read_status = adap -> fe_adap [ 0 ] . fe -> ops . read_status ; adap -> fe_adap [ 0 ] . fe -> ops . read_status = tt_s2_4600_read_status ; state -> last_lock = 0 ; return 0 ; }\n",
      "fixed_code": "<S2SV_ModStart> d -> priv <S2SV_ModEnd> ; struct i2c_adapter <S2SV_ModStart> { } ; mutex_lock ( & d -> data_mutex ) ; state -> data [ 0 ] = 0xe ; state -> data [ 1 ] = 0x80 ; state -> data [ 2 ] = 0x0 ; <S2SV_ModStart> ( d , state -> data <S2SV_ModEnd> , 3 , <S2SV_ModStart> , 3 , state -> data <S2SV_ModEnd> , 1 , <S2SV_ModStart> \"command<S2SV_blank>0x0e<S2SV_blank>transfer<S2SV_blank>failed.\" ) ; state -> data <S2SV_ModEnd> [ 0 ] <S2SV_ModStart> = 0xe ; state -> data <S2SV_ModEnd> [ 1 ] <S2SV_ModStart> = 0x02 ; state -> data <S2SV_ModEnd> [ 2 ] <S2SV_ModStart> ( d , state -> data <S2SV_ModEnd> , 3 , <S2SV_ModStart> , 3 , state -> data <S2SV_ModEnd> , 1 , <S2SV_ModStart> 300 ) ; state -> data <S2SV_ModEnd> [ 0 ] <S2SV_ModStart> = 0xe ; state -> data <S2SV_ModEnd> [ 1 ] <S2SV_ModStart> = 0x83 ; state -> data <S2SV_ModEnd> [ 2 ] <S2SV_ModStart> ( d , state -> data <S2SV_ModEnd> , 3 , <S2SV_ModStart> , 3 , state -> data <S2SV_ModEnd> , 1 , <S2SV_ModStart> \"command<S2SV_blank>0x0e<S2SV_blank>transfer<S2SV_blank>failed.\" ) ; state -> data <S2SV_ModEnd> [ 0 ] <S2SV_ModStart> = 0xe ; state -> data <S2SV_ModEnd> [ 1 ] <S2SV_ModStart> = 0x83 ; state -> data <S2SV_ModEnd> [ 2 ] <S2SV_ModStart> ( d , state -> data <S2SV_ModEnd> , 3 , <S2SV_ModStart> , 3 , state -> data <S2SV_ModEnd> , 1 , <S2SV_ModStart> \"command<S2SV_blank>0x0e<S2SV_blank>transfer<S2SV_blank>failed.\" ) ; state -> data <S2SV_ModEnd> [ 0 ] <S2SV_ModStart> ( d , state -> data , 1 , state -> data <S2SV_ModEnd> , 1 , <S2SV_ModStart> err ( \"command<S2SV_blank>0x51<S2SV_blank>transfer<S2SV_blank>failed.\" ) ; mutex_unlock ( & d -> data_mutex\n",
      "source_code_length": 3899,
      "target_code_length": 1617,
      "vulnerability_patterns": {
        "buffer_overflow": 2,
        "null_pointer": 25,
        "total": 27
      },
      "total_patterns": 27,
      "original_address": "https://github.com/torvalds/linux/commit/606142af57dad981b78707234cfbd15f9f7b7125",
      "discovery_time": "2017-04-23T05:59Z",
      "project_commit_id": "torvalds@linux/606142af57dad981b78707234cfbd15f9f7b7125",
      "extraction_time": "2025-08-31T15:41:49.181666",
      "label": 1,
      "vulnerability_type": "buffer_overflow",
      "difficulty_level": "advanced",
      "risk_factors": [
        "system_crash",
        "memory_corruption",
        "buffer_overflow",
        "arbitrary_code_execution"
      ],
      "attack_vectors": [
        "memory_manipulation",
        "malicious_input",
        "code_analysis",
        "buffer_overflow",
        "reverse_engineering",
        "fuzzing"
      ],
      "mitigation_strategies": [
        "safe_string_functions",
        "dynamic_analysis",
        "code_review",
        "static_analysis",
        "memory_safety_checks",
        "input_validation",
        "fuzzing",
        "bounds_checking",
        "secure_coding_practices"
      ],
      "code_differences": {
        "has_differences": true,
        "source_lines": 2,
        "target_lines": 2,
        "character_differences": 2282,
        "similarity_percentage": 22.950819672131146
      },
      "vulnerability_location": {
        "vulnerability_present": true,
        "fix_applied": true,
        "code_changed": true,
        "estimated_lines_changed": 0
      }
    },
    {
      "cve_id": "CVE-2015-8631",
      "cwe_id": "CWE-772",
      "cwe_name": "Missing Release of Memory",
      "project": "krb5",
      "severity": "critical",
      "weaponization_score": 8.5,
      "is_critical": true,
      "is_weaponizable": true,
      "is_high_priority_project": true,
      "vulnerable_code": "CWE-772 gprincs_ret * get_princs_2_svc ( gprincs_arg * arg , struct svc_req * rqstp ) { static gprincs_ret ret ; char * prime_arg ; <S2SV_StartBug> gss_buffer_desc client_name , <S2SV_EndBug> service_name ; OM_uint32 minor_stat ; kadm5_server_handle_t handle ; const char * errmsg = NULL ; xdr_free ( xdr_gprincs_ret , & ret ) ; if ( ( ret . code = new_server_handle ( arg -> api_version , rqstp , & handle ) ) ) goto exit_func ; if ( ( ret . code = check_handle ( ( void * ) handle ) ) ) goto exit_func ; ret . api_version = handle -> api_version ; if ( setup_gss_names ( rqstp , & client_name , & service_name ) < 0 ) { ret . code = KADM5_FAILURE ; goto exit_func ; } prime_arg = arg -> exp ; if ( prime_arg == NULL ) prime_arg = \"*\" ; if ( CHANGEPW_SERVICE ( rqstp ) || ! kadm5int_acl_check ( handle -> context , rqst2name ( rqstp ) , ACL_LIST , NULL , NULL ) ) { ret . code = KADM5_AUTH_LIST ; log_unauth ( \"kadm5_get_principals\" , prime_arg , & client_name , & service_name , rqstp ) ; } else { ret . code = kadm5_get_principals ( ( void * ) handle , arg -> exp , & ret . princs , & ret . count ) ; if ( ret . code != 0 ) errmsg = krb5_get_error_message ( handle -> context , ret . code ) ; log_done ( \"kadm5_get_principals\" , prime_arg , errmsg , & client_name , & service_name , rqstp ) ; if ( errmsg != NULL ) krb5_free_error_message ( handle -> context , errmsg ) ; } <S2SV_StartBug> gss_release_buffer ( & minor_stat , & client_name ) ; <S2SV_EndBug> gss_release_buffer ( & minor_stat , & service_name ) ; exit_func : free_server_handle ( handle ) ; return & ret ; }\n",
      "fixed_code": "<S2SV_ModStart> ; gss_buffer_desc client_name = GSS_C_EMPTY_BUFFER ; gss_buffer_desc service_name = GSS_C_EMPTY_BUFFER <S2SV_ModEnd> ; OM_uint32 minor_stat <S2SV_ModStart> ) ; } exit_func : gss_release_buffer ( & minor_stat , & client_name ) ; gss_release_buffer ( & minor_stat , & service_name ) ; <S2SV_ModEnd> free_server_handle ( handle\n",
      "source_code_length": 1577,
      "target_code_length": 341,
      "vulnerability_patterns": {
        "use_after_free": 2,
        "null_pointer": 11,
        "total": 13
      },
      "total_patterns": 13,
      "original_address": "https://github.com/krb5/krb5/commit/83ed75feba32e46f736fcce0d96a0445f29b96c2",
      "discovery_time": "2016-02-13T02:59Z",
      "project_commit_id": "krb5@krb5/83ed75feba32e46f736fcce0d96a0445f29b96c2",
      "extraction_time": "2025-08-31T15:41:49.181708",
      "label": 1,
      "vulnerability_type": "missing_release_of_memory",
      "difficulty_level": "advanced",
      "risk_factors": [
        "critical_infrastructure",
        "use_after_free"
      ],
      "attack_vectors": [
        "fuzzing",
        "code_analysis",
        "reverse_engineering"
      ],
      "mitigation_strategies": [
        "dynamic_analysis",
        "static_analysis",
        "fuzzing",
        "code_review",
        "secure_coding_practices"
      ],
      "code_differences": {
        "has_differences": true,
        "source_lines": 2,
        "target_lines": 2,
        "character_differences": 1236,
        "similarity_percentage": 22.07792207792208
      },
      "vulnerability_location": {
        "vulnerability_present": true,
        "fix_applied": true,
        "code_changed": true,
        "estimated_lines_changed": 0
      }
    },
    {
      "cve_id": "CVE-2016-9537",
      "cwe_id": "CWE-119",
      "cwe_name": "Buffer Overflow",
      "project": "vadz",
      "severity": "critical",
      "weaponization_score": 8.5,
      "is_critical": true,
      "is_weaponizable": true,
      "is_high_priority_project": false,
      "vulnerable_code": "CWE-119 tsize_t t2p_readwrite_pdf_image ( T2P * t2p , TIFF * input , TIFF * output ) { tsize_t written = 0 ; unsigned char * buffer = NULL ; unsigned char * samplebuffer = NULL ; tsize_t bufferoffset = 0 ; tsize_t samplebufferoffset = 0 ; tsize_t read = 0 ; tstrip_t i = 0 ; tstrip_t j = 0 ; tstrip_t stripcount = 0 ; tsize_t stripsize = 0 ; tsize_t sepstripcount = 0 ; tsize_t sepstripsize = 0 ; # ifdef OJPEG_SUPPORT toff_t inputoffset = 0 ; uint16 h_samp = 1 ; uint16 v_samp = 1 ; uint16 ri = 1 ; uint32 rows = 0 ; # endif # ifdef JPEG_SUPPORT unsigned char * jpt ; float * xfloatp ; uint64 * sbc ; unsigned char * stripbuffer ; tsize_t striplength = 0 ; uint32 max_striplength = 0 ; # endif if ( t2p -> t2p_error != T2P_ERR_OK ) return ( 0 ) ; if ( t2p -> pdf_transcode == T2P_TRANSCODE_RAW ) { # ifdef CCITT_SUPPORT if ( t2p -> pdf_compression == T2P_COMPRESS_G4 ) { buffer = ( unsigned char * ) _TIFFmalloc ( t2p -> tiff_datasize ) ; if ( buffer == NULL ) { TIFFError ( TIFF2PDF_MODULE , \"Can\\'t<S2SV_blank>allocate<S2SV_blank>%lu<S2SV_blank>bytes<S2SV_blank>of<S2SV_blank>memory<S2SV_blank>for<S2SV_blank>\" \"t2p_readwrite_pdf_image,<S2SV_blank>%s\" , ( unsigned long ) t2p -> tiff_datasize , TIFFFileName ( input ) ) ; t2p -> t2p_error = T2P_ERR_ERROR ; return ( 0 ) ; } TIFFReadRawStrip ( input , 0 , ( tdata_t ) buffer , t2p -> tiff_datasize ) ; if ( t2p -> tiff_fillorder == FILLORDER_LSB2MSB ) { TIFFReverseBits ( buffer , t2p -> tiff_datasize ) ; } t2pWriteFile ( output , ( tdata_t ) buffer , t2p -> tiff_datasize ) ; _TIFFfree ( buffer ) ; return ( t2p -> tiff_datasize ) ; } # endif # ifdef ZIP_SUPPORT if ( t2p -> pdf_compression == T2P_COMPRESS_ZIP ) { buffer = ( unsigned char * ) _TIFFmalloc ( t2p -> tiff_datasize ) ; if ( buffer == NULL ) { TIFFError ( TIFF2PDF_MODULE , \"Can\\'t<S2SV_blank>allocate<S2SV_blank>%lu<S2SV_blank>bytes<S2SV_blank>of<S2SV_blank>memory<S2SV_blank>for<S2SV_blank>t2p_readwrite_pdf_image,<S2SV_blank>%s\" , ( unsigned long ) t2p -> tiff_datasize , TIFFFileName ( input ) ) ; t2p -> t2p_error = T2P_ERR_ERROR ; return ( 0 ) ; } memset ( buffer , 0 , t2p -> tiff_datasize ) ; TIFFReadRawStrip ( input , 0 , ( tdata_t ) buffer , t2p -> tiff_datasize ) ; if ( t2p -> tiff_fillorder == FILLORDER_LSB2MSB ) { TIFFReverseBits ( buffer , t2p -> tiff_datasize ) ; } t2pWriteFile ( output , ( tdata_t ) buffer , t2p -> tiff_datasize ) ; _TIFFfree ( buffer ) ; return ( t2p -> tiff_datasize ) ; } # endif # ifdef OJPEG_SUPPORT if ( t2p -> tiff_compression == COMPRESSION_OJPEG ) { if ( t2p -> tiff_dataoffset != 0 ) { buffer = ( unsigned char * ) _TIFFmalloc ( t2p -> tiff_datasize ) ; if ( buffer == NULL ) { TIFFError ( TIFF2PDF_MODULE , \"Can\\'t<S2SV_blank>allocate<S2SV_blank>%lu<S2SV_blank>bytes<S2SV_blank>of<S2SV_blank>memory<S2SV_blank>for<S2SV_blank>t2p_readwrite_pdf_image,<S2SV_blank>%s\" , ( unsigned long ) t2p -> tiff_datasize , TIFFFileName ( input ) ) ; t2p -> t2p_error = T2P_ERR_ERROR ; return ( 0 ) ; } memset ( buffer , 0 , t2p -> tiff_datasize ) ; if ( t2p -> pdf_ojpegiflength == 0 ) { inputoffset = t2pSeekFile ( input , 0 , SEEK_CUR ) ; t2pSeekFile ( input , t2p -> tiff_dataoffset , SEEK_SET ) ; t2pReadFile ( input , ( tdata_t ) buffer , t2p -> tiff_datasize ) ; t2pSeekFile ( input , inputoffset , SEEK_SET ) ; t2pWriteFile ( output , ( tdata_t ) buffer , t2p -> tiff_datasize ) ; _TIFFfree ( buffer ) ; return ( t2p -> tiff_datasize ) ; } else { inputoffset = t2pSeekFile ( input , 0 , SEEK_CUR ) ; t2pSeekFile ( input , t2p -> tiff_dataoffset , SEEK_SET ) ; bufferoffset = t2pReadFile ( input , ( tdata_t ) buffer , t2p -> pdf_ojpegiflength ) ; t2p -> pdf_ojpegiflength = 0 ; t2pSeekFile ( input , inputoffset , SEEK_SET ) ; TIFFGetField ( input , TIFFTAG_YCBCRSUBSAMPLING , & h_samp , & v_samp ) ; buffer [ bufferoffset ++ ] = 0xff ; buffer [ bufferoffset ++ ] = 0xdd ; buffer [ bufferoffset ++ ] = 0x00 ; buffer [ bufferoffset ++ ] = 0x04 ; h_samp *= 8 ; v_samp *= 8 ; ri = ( t2p -> tiff_width + h_samp - 1 ) / h_samp ; TIFFGetField ( input , TIFFTAG_ROWSPERSTRIP , & rows ) ; ri *= ( rows + v_samp - 1 ) / v_samp ; buffer [ bufferoffset ++ ] = ( ri >> 8 ) & 0xff ; buffer [ bufferoffset ++ ] = ri & 0xff ; stripcount = TIFFNumberOfStrips ( input ) ; for ( i = 0 ; i < stripcount ; i ++ ) { if ( i != 0 ) { buffer [ bufferoffset ++ ] = 0xff ; buffer [ bufferoffset ++ ] = ( 0xd0 | ( ( i - 1 ) % 8 ) ) ; } bufferoffset += TIFFReadRawStrip ( input , i , ( tdata_t ) & ( ( ( unsigned char * ) buffer ) [ bufferoffset ] ) , - 1 ) ; } t2pWriteFile ( output , ( tdata_t ) buffer , bufferoffset ) ; _TIFFfree ( buffer ) ; return ( bufferoffset ) ; } } else { if ( ! t2p -> pdf_ojpegdata ) { TIFFError ( TIFF2PDF_MODULE , \"No<S2SV_blank>support<S2SV_blank>for<S2SV_blank>OJPEG<S2SV_blank>image<S2SV_blank>%s<S2SV_blank>with<S2SV_blank>bad<S2SV_blank>tables\" , TIFFFileName ( input ) ) ; t2p -> t2p_error = T2P_ERR_ERROR ; return ( 0 ) ; } buffer = ( unsigned char * ) _TIFFmalloc ( t2p -> tiff_datasize ) ; if ( buffer == NULL ) { TIFFError ( TIFF2PDF_MODULE , \"Can\\'t<S2SV_blank>allocate<S2SV_blank>%lu<S2SV_blank>bytes<S2SV_blank>of<S2SV_blank>memory<S2SV_blank>for<S2SV_blank>t2p_readwrite_pdf_image,<S2SV_blank>%s\" , ( unsigned long ) t2p -> tiff_datasize , TIFFFileName ( input ) ) ; t2p -> t2p_error = T2P_ERR_ERROR ; return ( 0 ) ; } memset ( buffer , 0 , t2p -> tiff_datasize ) ; _TIFFmemcpy ( buffer , t2p -> pdf_ojpegdata , t2p -> pdf_ojpegdatalength ) ; bufferoffset = t2p -> pdf_ojpegdatalength ; stripcount = TIFFNumberOfStrips ( input ) ; for ( i = 0 ; i < stripcount ; i ++ ) { if ( i != 0 ) { buffer [ bufferoffset ++ ] = 0xff ; buffer [ bufferoffset ++ ] = ( 0xd0 | ( ( i - 1 ) % 8 ) ) ; } bufferoffset += TIFFReadRawStrip ( input , i , ( tdata_t ) & ( ( ( unsigned char * ) buffer ) [ bufferoffset ] ) , - 1 ) ; } if ( ! ( ( buffer [ bufferoffset - 1 ] == 0xd9 ) && ( buffer [ bufferoffset - 2 ] == 0xff ) ) ) { buffer [ bufferoffset ++ ] = 0xff ; buffer [ bufferoffset ++ ] = 0xd9 ; } t2pWriteFile ( output , ( tdata_t ) buffer , bufferoffset ) ; _TIFFfree ( buffer ) ; return ( bufferoffset ) ; # if 0 TIFFError ( TIFF2PDF_MODULE , \"No<S2SV_blank>support<S2SV_blank>for<S2SV_blank>OJPEG<S2SV_blank>image<S2SV_blank>%s<S2SV_blank>with<S2SV_blank>no<S2SV_blank>JPEG<S2SV_blank>File<S2SV_blank>Interchange<S2SV_blank>offset\" , TIFFFileName ( input ) ) ; t2p -> t2p_error = T2P_ERR_ERROR ; return ( 0 ) ; # endif } } # endif # ifdef JPEG_SUPPORT if ( t2p -> tiff_compression == COMPRESSION_JPEG ) { uint32 count = 0 ; buffer = ( unsigned char * ) _TIFFmalloc ( t2p -> tiff_datasize ) ; if ( buffer == NULL ) { TIFFError ( TIFF2PDF_MODULE , \"Can\\'t<S2SV_blank>allocate<S2SV_blank>%lu<S2SV_blank>bytes<S2SV_blank>of<S2SV_blank>memory<S2SV_blank>for<S2SV_blank>t2p_readwrite_pdf_image,<S2SV_blank>%s\" , ( unsigned long ) t2p -> tiff_datasize , TIFFFileName ( input ) ) ; t2p -> t2p_error = T2P_ERR_ERROR ; return ( 0 ) ; } memset ( buffer , 0 , t2p -> tiff_datasize ) ; if ( TIFFGetField ( input , TIFFTAG_JPEGTABLES , & count , & jpt ) != 0 ) { if ( count > 4 ) { _TIFFmemcpy ( buffer , jpt , count ) ; bufferoffset += count - 2 ; } } stripcount = TIFFNumberOfStrips ( input ) ; TIFFGetField ( input , TIFFTAG_STRIPBYTECOUNTS , & sbc ) ; for ( i = 0 ; i < stripcount ; i ++ ) { if ( sbc [ i ] > max_striplength ) max_striplength = sbc [ i ] ; } stripbuffer = ( unsigned char * ) _TIFFmalloc ( max_striplength ) ; if ( stripbuffer == NULL ) { TIFFError ( TIFF2PDF_MODULE , \"Can\\'t<S2SV_blank>allocate<S2SV_blank>%u<S2SV_blank>bytes<S2SV_blank>of<S2SV_blank>memory<S2SV_blank>for<S2SV_blank>t2p_readwrite_pdf_image,<S2SV_blank>%s\" , max_striplength , TIFFFileName ( input ) ) ; _TIFFfree ( buffer ) ; t2p -> t2p_error = T2P_ERR_ERROR ; return ( 0 ) ; } for ( i = 0 ; i < stripcount ; i ++ ) { striplength = TIFFReadRawStrip ( input , i , ( tdata_t ) stripbuffer , - 1 ) ; if ( ! t2p_process_jpeg_strip ( stripbuffer , & striplength , buffer , <S2SV_StartBug> & bufferoffset , <S2SV_EndBug> i , t2p -> tiff_length ) ) { TIFFError ( TIFF2PDF_MODULE , \"Can\\'t<S2SV_blank>process<S2SV_blank>JPEG<S2SV_blank>data<S2SV_blank>in<S2SV_blank>input<S2SV_blank>file<S2SV_blank>%s\" , TIFFFileName ( input ) ) ; _TIFFfree ( samplebuffer ) ; _TIFFfree ( buffer ) ; t2p -> t2p_error = T2P_ERR_ERROR ; return ( 0 ) ; } } buffer [ bufferoffset ++ ] = 0xff ; buffer [ bufferoffset ++ ] = 0xd9 ; t2pWriteFile ( output , ( tdata_t ) buffer , bufferoffset ) ; _TIFFfree ( stripbuffer ) ; _TIFFfree ( buffer ) ; return ( bufferoffset ) ; } # endif ( void ) 0 ; } if ( t2p -> pdf_sample == T2P_SAMPLE_NOTHING ) { buffer = ( unsigned char * ) _TIFFmalloc ( t2p -> tiff_datasize ) ; if ( buffer == NULL ) { TIFFError ( TIFF2PDF_MODULE , \"Can\\'t<S2SV_blank>allocate<S2SV_blank>%lu<S2SV_blank>bytes<S2SV_blank>of<S2SV_blank>memory<S2SV_blank>for<S2SV_blank>t2p_readwrite_pdf_image,<S2SV_blank>%s\" , ( unsigned long ) t2p -> tiff_datasize , TIFFFileName ( input ) ) ; t2p -> t2p_error = T2P_ERR_ERROR ; return ( 0 ) ; } memset ( buffer , 0 , t2p -> tiff_datasize ) ; stripsize = TIFFStripSize ( input ) ; stripcount = TIFFNumberOfStrips ( input ) ; for ( i = 0 ; i < stripcount ; i ++ ) { read = TIFFReadEncodedStrip ( input , i , ( tdata_t ) & buffer [ bufferoffset ] , TIFFmin ( stripsize , t2p -> tiff_datasize - bufferoffset ) ) ; if ( read == - 1 ) { TIFFError ( TIFF2PDF_MODULE , \"Error<S2SV_blank>on<S2SV_blank>decoding<S2SV_blank>strip<S2SV_blank>%u<S2SV_blank>of<S2SV_blank>%s\" , i , TIFFFileName ( input ) ) ; _TIFFfree ( buffer ) ; t2p -> t2p_error = T2P_ERR_ERROR ; return ( 0 ) ; } bufferoffset += read ; } } else { if ( t2p -> pdf_sample & T2P_SAMPLE_PLANAR_SEPARATE_TO_CONTIG ) { sepstripsize = TIFFStripSize ( input ) ; sepstripcount = TIFFNumberOfStrips ( input ) ; stripsize = sepstripsize * t2p -> tiff_samplesperpixel ; stripcount = sepstripcount / t2p -> tiff_samplesperpixel ; buffer = ( unsigned char * ) _TIFFmalloc ( t2p -> tiff_datasize ) ; if ( buffer == NULL ) { TIFFError ( TIFF2PDF_MODULE , \"Can\\'t<S2SV_blank>allocate<S2SV_blank>%lu<S2SV_blank>bytes<S2SV_blank>of<S2SV_blank>memory<S2SV_blank>for<S2SV_blank>t2p_readwrite_pdf_image,<S2SV_blank>%s\" , ( unsigned long ) t2p -> tiff_datasize , TIFFFileName ( input ) ) ; t2p -> t2p_error = T2P_ERR_ERROR ; return ( 0 ) ; } memset ( buffer , 0 , t2p -> tiff_datasize ) ; samplebuffer = ( unsigned char * ) _TIFFmalloc ( stripsize ) ; if ( samplebuffer == NULL ) { TIFFError ( TIFF2PDF_MODULE , \"Can\\'t<S2SV_blank>allocate<S2SV_blank>%lu<S2SV_blank>bytes<S2SV_blank>of<S2SV_blank>memory<S2SV_blank>for<S2SV_blank>t2p_readwrite_pdf_image,<S2SV_blank>%s\" , ( unsigned long ) t2p -> tiff_datasize , TIFFFileName ( input ) ) ; t2p -> t2p_error = T2P_ERR_ERROR ; _TIFFfree ( buffer ) ; return ( 0 ) ; } for ( i = 0 ; i < stripcount ; i ++ ) { samplebufferoffset = 0 ; for ( j = 0 ; j < t2p -> tiff_samplesperpixel ; j ++ ) { read = TIFFReadEncodedStrip ( input , i + j * stripcount , ( tdata_t ) & ( samplebuffer [ samplebufferoffset ] ) , TIFFmin ( sepstripsize , stripsize - samplebufferoffset ) ) ; if ( read == - 1 ) { TIFFError ( TIFF2PDF_MODULE , \"Error<S2SV_blank>on<S2SV_blank>decoding<S2SV_blank>strip<S2SV_blank>%u<S2SV_blank>of<S2SV_blank>%s\" , i + j * stripcount , TIFFFileName ( input ) ) ; _TIFFfree ( buffer ) ; t2p -> t2p_error = T2P_ERR_ERROR ; return ( 0 ) ; } samplebufferoffset += read ; } t2p_sample_planar_separate_to_contig ( t2p , & ( buffer [ bufferoffset ] ) , samplebuffer , samplebufferoffset ) ; bufferoffset += samplebufferoffset ; } _TIFFfree ( samplebuffer ) ; goto dataready ; } buffer = ( unsigned char * ) _TIFFmalloc ( t2p -> tiff_datasize ) ; if ( buffer == NULL ) { TIFFError ( TIFF2PDF_MODULE , \"Can\\'t<S2SV_blank>allocate<S2SV_blank>%lu<S2SV_blank>bytes<S2SV_blank>of<S2SV_blank>memory<S2SV_blank>for<S2SV_blank>t2p_readwrite_pdf_image,<S2SV_blank>%s\" , ( unsigned long ) t2p -> tiff_datasize , TIFFFileName ( input ) ) ; t2p -> t2p_error = T2P_ERR_ERROR ; return ( 0 ) ; } memset ( buffer , 0 , t2p -> tiff_datasize ) ; stripsize = TIFFStripSize ( input ) ; stripcount = TIFFNumberOfStrips ( input ) ; for ( i = 0 ; i < stripcount ; i ++ ) { read = TIFFReadEncodedStrip ( input , i , ( tdata_t ) & buffer [ bufferoffset ] , TIFFmin ( stripsize , t2p -> tiff_datasize - bufferoffset ) ) ; if ( read == - 1 ) { TIFFError ( TIFF2PDF_MODULE , \"Error<S2SV_blank>on<S2SV_blank>decoding<S2SV_blank>strip<S2SV_blank>%u<S2SV_blank>of<S2SV_blank>%s\" , i , TIFFFileName ( input ) ) ; _TIFFfree ( samplebuffer ) ; _TIFFfree ( buffer ) ; t2p -> t2p_error = T2P_ERR_ERROR ; return ( 0 ) ; } bufferoffset += read ; } if ( t2p -> pdf_sample & T2P_SAMPLE_REALIZE_PALETTE ) { samplebuffer = ( unsigned char * ) _TIFFrealloc ( ( tdata_t ) buffer , t2p -> tiff_datasize * t2p -> tiff_samplesperpixel ) ; if ( samplebuffer == NULL ) { TIFFError ( TIFF2PDF_MODULE , \"Can\\'t<S2SV_blank>allocate<S2SV_blank>%lu<S2SV_blank>bytes<S2SV_blank>of<S2SV_blank>memory<S2SV_blank>for<S2SV_blank>t2p_readwrite_pdf_image,<S2SV_blank>%s\" , ( unsigned long ) t2p -> tiff_datasize , TIFFFileName ( input ) ) ; t2p -> t2p_error = T2P_ERR_ERROR ; _TIFFfree ( buffer ) ; return ( 0 ) ; } else { buffer = samplebuffer ; t2p -> tiff_datasize *= t2p -> tiff_samplesperpixel ; } t2p_sample_realize_palette ( t2p , buffer ) ; } if ( t2p -> pdf_sample & T2P_SAMPLE_RGBA_TO_RGB ) { t2p -> tiff_datasize = t2p_sample_rgba_to_rgb ( ( tdata_t ) buffer , t2p -> tiff_width * t2p -> tiff_length ) ; } if ( t2p -> pdf_sample & T2P_SAMPLE_RGBAA_TO_RGB ) { t2p -> tiff_datasize = t2p_sample_rgbaa_to_rgb ( ( tdata_t ) buffer , t2p -> tiff_width * t2p -> tiff_length ) ; } if ( t2p -> pdf_sample & T2P_SAMPLE_YCBCR_TO_RGB ) { samplebuffer = ( unsigned char * ) _TIFFrealloc ( ( tdata_t ) buffer , t2p -> tiff_width * t2p -> tiff_length * 4 ) ; if ( samplebuffer == NULL ) { TIFFError ( TIFF2PDF_MODULE , \"Can\\'t<S2SV_blank>allocate<S2SV_blank>%lu<S2SV_blank>bytes<S2SV_blank>of<S2SV_blank>memory<S2SV_blank>for<S2SV_blank>t2p_readwrite_pdf_image,<S2SV_blank>%s\" , ( unsigned long ) t2p -> tiff_datasize , TIFFFileName ( input ) ) ; t2p -> t2p_error = T2P_ERR_ERROR ; _TIFFfree ( buffer ) ; return ( 0 ) ; } else { buffer = samplebuffer ; } if ( ! TIFFReadRGBAImageOriented ( input , t2p -> tiff_width , t2p -> tiff_length , ( uint32 * ) buffer , ORIENTATION_TOPLEFT , 0 ) ) { TIFFError ( TIFF2PDF_MODULE , \"Can\\'t<S2SV_blank>use<S2SV_blank>TIFFReadRGBAImageOriented<S2SV_blank>to<S2SV_blank>extract<S2SV_blank>RGB<S2SV_blank>image<S2SV_blank>from<S2SV_blank>%s\" , TIFFFileName ( input ) ) ; t2p -> t2p_error = T2P_ERR_ERROR ; return ( 0 ) ; } t2p -> tiff_datasize = t2p_sample_abgr_to_rgb ( ( tdata_t ) buffer , t2p -> tiff_width * t2p -> tiff_length ) ; } if ( t2p -> pdf_sample & T2P_SAMPLE_LAB_SIGNED_TO_UNSIGNED ) { t2p -> tiff_datasize = t2p_sample_lab_signed_to_unsigned ( ( tdata_t ) buffer , t2p -> tiff_width * t2p -> tiff_length ) ; } } dataready : t2p_disable ( output ) ; TIFFSetField ( output , TIFFTAG_PHOTOMETRIC , t2p -> tiff_photometric ) ; TIFFSetField ( output , TIFFTAG_BITSPERSAMPLE , t2p -> tiff_bitspersample ) ; TIFFSetField ( output , TIFFTAG_SAMPLESPERPIXEL , t2p -> tiff_samplesperpixel ) ; TIFFSetField ( output , TIFFTAG_IMAGEWIDTH , t2p -> tiff_width ) ; TIFFSetField ( output , TIFFTAG_IMAGELENGTH , t2p -> tiff_length ) ; TIFFSetField ( output , TIFFTAG_ROWSPERSTRIP , t2p -> tiff_length ) ; TIFFSetField ( output , TIFFTAG_PLANARCONFIG , PLANARCONFIG_CONTIG ) ; TIFFSetField ( output , TIFFTAG_FILLORDER , FILLORDER_MSB2LSB ) ; switch ( t2p -> pdf_compression ) { case T2P_COMPRESS_NONE : TIFFSetField ( output , TIFFTAG_COMPRESSION , COMPRESSION_NONE ) ; break ; # ifdef CCITT_SUPPORT case T2P_COMPRESS_G4 : TIFFSetField ( output , TIFFTAG_COMPRESSION , COMPRESSION_CCITTFAX4 ) ; break ; # endif # ifdef JPEG_SUPPORT case T2P_COMPRESS_JPEG : if ( t2p -> tiff_photometric == PHOTOMETRIC_YCBCR ) { uint16 hor = 0 , ver = 0 ; if ( TIFFGetField ( input , TIFFTAG_YCBCRSUBSAMPLING , & hor , & ver ) != 0 ) { if ( hor != 0 && ver != 0 ) { TIFFSetField ( output , TIFFTAG_YCBCRSUBSAMPLING , hor , ver ) ; } } if ( TIFFGetField ( input , TIFFTAG_REFERENCEBLACKWHITE , & xfloatp ) != 0 ) { TIFFSetField ( output , TIFFTAG_REFERENCEBLACKWHITE , xfloatp ) ; } } if ( TIFFSetField ( output , TIFFTAG_COMPRESSION , COMPRESSION_JPEG ) == 0 ) { TIFFError ( TIFF2PDF_MODULE , \"Unable<S2SV_blank>to<S2SV_blank>use<S2SV_blank>JPEG<S2SV_blank>compression<S2SV_blank>for<S2SV_blank>input<S2SV_blank>%s<S2SV_blank>and<S2SV_blank>output<S2SV_blank>%s\" , TIFFFileName ( input ) , TIFFFileName ( output ) ) ; _TIFFfree ( buffer ) ; t2p -> t2p_error = T2P_ERR_ERROR ; return ( 0 ) ; } TIFFSetField ( output , TIFFTAG_JPEGTABLESMODE , 0 ) ; if ( t2p -> pdf_colorspace & ( T2P_CS_RGB | T2P_CS_LAB ) ) { TIFFSetField ( output , TIFFTAG_PHOTOMETRIC , PHOTOMETRIC_YCBCR ) ; if ( t2p -> tiff_photometric != PHOTOMETRIC_YCBCR ) { TIFFSetField ( output , TIFFTAG_JPEGCOLORMODE , JPEGCOLORMODE_RGB ) ; } else { TIFFSetField ( output , TIFFTAG_JPEGCOLORMODE , JPEGCOLORMODE_RAW ) ; } } if ( t2p -> pdf_colorspace & T2P_CS_GRAY ) { ( void ) 0 ; } if ( t2p -> pdf_colorspace & T2P_CS_CMYK ) { ( void ) 0 ; } if ( t2p -> pdf_defaultcompressionquality != 0 ) { TIFFSetField ( output , TIFFTAG_JPEGQUALITY , t2p -> pdf_defaultcompressionquality ) ; } break ; # endif # ifdef ZIP_SUPPORT case T2P_COMPRESS_ZIP : TIFFSetField ( output , TIFFTAG_COMPRESSION , COMPRESSION_DEFLATE ) ; if ( t2p -> pdf_defaultcompressionquality % 100 != 0 ) { TIFFSetField ( output , TIFFTAG_PREDICTOR , t2p -> pdf_defaultcompressionquality % 100 ) ; } if ( t2p -> pdf_defaultcompressionquality / 100 != 0 ) { TIFFSetField ( output , TIFFTAG_ZIPQUALITY , ( t2p -> pdf_defaultcompressionquality / 100 ) ) ; } break ; # endif default : break ; } t2p_enable ( output ) ; t2p -> outputwritten = 0 ; # ifdef JPEG_SUPPORT if ( t2p -> pdf_compression == T2P_COMPRESS_JPEG && t2p -> tiff_photometric == PHOTOMETRIC_YCBCR ) { bufferoffset = TIFFWriteEncodedStrip ( output , ( tstrip_t ) 0 , buffer , stripsize * stripcount ) ; } else # endif { bufferoffset = TIFFWriteEncodedStrip ( output , ( tstrip_t ) 0 , buffer , t2p -> tiff_datasize ) ; } if ( buffer != NULL ) { _TIFFfree ( buffer ) ; buffer = NULL ; } if ( bufferoffset == ( tsize_t ) - 1 ) { TIFFError ( TIFF2PDF_MODULE , \"Error<S2SV_blank>writing<S2SV_blank>encoded<S2SV_blank>strip<S2SV_blank>to<S2SV_blank>output<S2SV_blank>PDF<S2SV_blank>%s\" , TIFFFileName ( output ) ) ; t2p -> t2p_error = T2P_ERR_ERROR ; return ( 0 ) ; } written = t2p -> outputwritten ; return ( written ) ; }\n",
      "fixed_code": "<S2SV_ModStart> , buffer , t2p -> tiff_datasize ,\n",
      "source_code_length": 18499,
      "target_code_length": 50,
      "vulnerability_patterns": {
        "buffer_overflow": 7,
        "integer_overflow": 33,
        "null_pointer": 145,
        "total": 185
      },
      "total_patterns": 185,
      "original_address": "https://github.com/vadz/libtiff/commit/83a4b92815ea04969d494416eaae3d4c6b338e4a",
      "discovery_time": "2016-11-22T19:59Z",
      "project_commit_id": "vadz@libtiff/83a4b92815ea04969d494416eaae3d4c6b338e4a",
      "extraction_time": "2025-08-31T15:41:49.181734",
      "label": 1,
      "vulnerability_type": "buffer_overflow",
      "difficulty_level": "advanced",
      "risk_factors": [
        "system_crash",
        "memory_corruption",
        "buffer_overflow",
        "arbitrary_code_execution"
      ],
      "attack_vectors": [
        "memory_manipulation",
        "malicious_input",
        "code_analysis",
        "buffer_overflow",
        "reverse_engineering",
        "fuzzing"
      ],
      "mitigation_strategies": [
        "safe_string_functions",
        "dynamic_analysis",
        "code_review",
        "static_analysis",
        "memory_safety_checks",
        "input_validation",
        "fuzzing",
        "bounds_checking",
        "secure_coding_practices"
      ],
      "code_differences": {
        "has_differences": true,
        "source_lines": 2,
        "target_lines": 2,
        "character_differences": 18449,
        "similarity_percentage": 2.314814814814815
      },
      "vulnerability_location": {
        "vulnerability_present": true,
        "fix_applied": true,
        "code_changed": true,
        "estimated_lines_changed": 0
      }
    },
    {
      "cve_id": "CVE-2019-19275",
      "cwe_id": "CWE-125",
      "cwe_name": "Out-of-bounds Read",
      "project": "python",
      "severity": "critical",
      "weaponization_score": 8.5,
      "is_critical": true,
      "is_weaponizable": true,
      "is_high_priority_project": true,
      "vulnerable_code": "CWE-125 static arguments_ty ast_for_arguments ( struct compiling * c , const node * n ) { int i , j , k , nposargs = 0 , nkwonlyargs = 0 ; int nposdefaults = 0 , found_default = 0 ; asdl_seq * posargs , * posdefaults , * kwonlyargs , * kwdefaults ; arg_ty vararg = NULL , kwarg = NULL ; arg_ty arg ; node * ch ; if ( TYPE ( n ) == parameters ) { if ( NCH ( n ) == 2 ) return arguments ( NULL , NULL , NULL , NULL , NULL , NULL , c -> c_arena ) ; n = CHILD ( n , 1 ) ; } assert ( TYPE ( n ) == typedargslist || TYPE ( n ) == varargslist ) ; for ( i = 0 ; i < NCH ( n ) ; i ++ ) { ch = CHILD ( n , i ) ; if ( TYPE ( ch ) == STAR ) { i ++ ; if ( i < NCH ( n ) && ( TYPE ( CHILD ( n , i ) ) == tfpdef || TYPE ( CHILD ( n , i ) ) == vfpdef ) ) { i ++ ; } break ; } if ( TYPE ( ch ) == DOUBLESTAR ) break ; if ( TYPE ( ch ) == vfpdef || TYPE ( ch ) == tfpdef ) nposargs ++ ; if ( TYPE ( ch ) == EQUAL ) nposdefaults ++ ; } for ( ; i < NCH ( n ) ; ++ i ) { ch = CHILD ( n , i ) ; if ( TYPE ( ch ) == DOUBLESTAR ) break ; if ( TYPE ( ch ) == tfpdef || TYPE ( ch ) == vfpdef ) nkwonlyargs ++ ; } posargs = ( nposargs ? _Ta3_asdl_seq_new ( nposargs , c -> c_arena ) : NULL ) ; if ( ! posargs && nposargs ) return NULL ; kwonlyargs = ( nkwonlyargs ? _Ta3_asdl_seq_new ( nkwonlyargs , c -> c_arena ) : NULL ) ; if ( ! kwonlyargs && nkwonlyargs ) return NULL ; posdefaults = ( nposdefaults ? _Ta3_asdl_seq_new ( nposdefaults , c -> c_arena ) : NULL ) ; if ( ! posdefaults && nposdefaults ) return NULL ; kwdefaults = ( nkwonlyargs ? _Ta3_asdl_seq_new ( nkwonlyargs , c -> c_arena ) : NULL ) ; if ( ! kwdefaults && nkwonlyargs ) return NULL ; <S2SV_StartBug> if ( nposargs + nkwonlyargs > 255 ) { <S2SV_EndBug> ast_error ( c , n , \"more<S2SV_blank>than<S2SV_blank>255<S2SV_blank>arguments\" ) ; return NULL ; } i = 0 ; j = 0 ; k = 0 ; while ( i < NCH ( n ) ) { ch = CHILD ( n , i ) ; switch ( TYPE ( ch ) ) { case tfpdef : case vfpdef : if ( i + 1 < NCH ( n ) && TYPE ( CHILD ( n , i + 1 ) ) == EQUAL ) { expr_ty expression = ast_for_expr ( c , CHILD ( n , i + 2 ) ) ; if ( ! expression ) return NULL ; assert ( posdefaults != NULL ) ; asdl_seq_SET ( posdefaults , j ++ , expression ) ; i += 2 ; found_default = 1 ; } else if ( found_default ) { ast_error ( c , n , \"non-default<S2SV_blank>argument<S2SV_blank>follows<S2SV_blank>default<S2SV_blank>argument\" ) ; return NULL ; } arg = ast_for_arg ( c , ch ) ; if ( ! arg ) return NULL ; asdl_seq_SET ( posargs , k ++ , arg ) ; i += 1 ; <S2SV_StartBug> if ( i < NCH ( n ) && TYPE ( CHILD ( n , i ) ) == COMMA ) <S2SV_EndBug> i += 1 ; break ; case STAR : if ( i + 1 >= NCH ( n ) || ( i + 2 == NCH ( n ) && ( TYPE ( CHILD ( n , i + 1 ) ) == COMMA || TYPE ( CHILD ( n , i + 1 ) ) == TYPE_COMMENT ) ) ) { ast_error ( c , CHILD ( n , i ) , \"named<S2SV_blank>arguments<S2SV_blank>must<S2SV_blank>follow<S2SV_blank>bare<S2SV_blank>*\" ) ; return NULL ; } ch = CHILD ( n , i + 1 ) ; if ( TYPE ( ch ) == COMMA ) { int res = 0 ; i += 2 ; <S2SV_StartBug> if ( i < NCH ( n ) && TYPE ( CHILD ( n , i ) ) == TYPE_COMMENT ) { <S2SV_EndBug> ast_error ( c , CHILD ( n , i ) , \"bare<S2SV_blank>*<S2SV_blank>has<S2SV_blank>associated<S2SV_blank>type<S2SV_blank>comment\" ) ; return NULL ; } res = handle_keywordonly_args ( c , n , i , kwonlyargs , kwdefaults ) ; if ( res == - 1 ) return NULL ; i = res ; } else { vararg = ast_for_arg ( c , ch ) ; if ( ! vararg ) return NULL ; i += 2 ; <S2SV_StartBug> if ( i < NCH ( n ) && TYPE ( CHILD ( n , i ) ) == COMMA ) <S2SV_EndBug> i += 1 ; <S2SV_StartBug> if ( i < NCH ( n ) && TYPE ( CHILD ( n , i ) ) == TYPE_COMMENT ) { <S2SV_EndBug> vararg -> type_comment = NEW_TYPE_COMMENT ( CHILD ( n , i ) ) ; i += 1 ; } if ( i < NCH ( n ) && ( TYPE ( CHILD ( n , i ) ) == tfpdef || TYPE ( CHILD ( n , i ) ) == vfpdef ) ) { int res = 0 ; res = handle_keywordonly_args ( c , n , i , kwonlyargs , kwdefaults ) ; if ( res == - 1 ) return NULL ; i = res ; } } break ; case DOUBLESTAR : ch = CHILD ( n , i + 1 ) ; assert ( TYPE ( ch ) == tfpdef || TYPE ( ch ) == vfpdef ) ; kwarg = ast_for_arg ( c , ch ) ; if ( ! kwarg ) return NULL ; i += 2 ; <S2SV_StartBug> if ( i < NCH ( n ) && TYPE ( CHILD ( n , i ) ) == COMMA ) <S2SV_EndBug> i += 1 ; break ; case TYPE_COMMENT : assert ( i ) ; if ( kwarg ) arg = kwarg ; arg -> type_comment = NEW_TYPE_COMMENT ( ch ) ; i += 1 ; break ; default : PyErr_Format ( PyExc_SystemError , \"unexpected<S2SV_blank>node<S2SV_blank>in<S2SV_blank>varargslist:<S2SV_blank>%d<S2SV_blank>@<S2SV_blank>%d\" , TYPE ( ch ) , i ) ; return NULL ; } } return arguments ( posargs , vararg , kwonlyargs , kwdefaults , kwarg , posdefaults , c -> c_arena ) ; }\n",
      "fixed_code": "<S2SV_ModStart> return NULL ; <S2SV_ModEnd> i = 0 <S2SV_ModStart> ; if ( <S2SV_ModEnd> TYPE ( CHILD <S2SV_ModStart> ; if ( <S2SV_ModEnd> TYPE ( CHILD <S2SV_ModStart> ; if ( <S2SV_ModEnd> TYPE ( CHILD <S2SV_ModStart> ; if ( <S2SV_ModEnd> TYPE ( CHILD <S2SV_ModStart> ; if ( <S2SV_ModEnd> TYPE ( CHILD\n",
      "source_code_length": 4617,
      "target_code_length": 300,
      "vulnerability_patterns": {
        "null_pointer": 10,
        "total": 10
      },
      "total_patterns": 10,
      "original_address": "https://github.com/python/typed_ast/commit/156afcb26c198e162504a57caddfe0acd9ed7dce",
      "discovery_time": "2019-11-26T15:15Z",
      "project_commit_id": "python@typed_ast/156afcb26c198e162504a57caddfe0acd9ed7dce",
      "extraction_time": "2025-08-31T15:41:49.181836",
      "label": 1,
      "vulnerability_type": "out-of-bounds_read",
      "difficulty_level": "advanced",
      "risk_factors": [
        "information_disclosure",
        "memory_corruption",
        "integer_overflow",
        "critical_infrastructure"
      ],
      "attack_vectors": [
        "memory_manipulation",
        "malicious_input",
        "code_analysis",
        "buffer_overflow",
        "reverse_engineering",
        "fuzzing"
      ],
      "mitigation_strategies": [
        "safe_string_functions",
        "dynamic_analysis",
        "code_review",
        "static_analysis",
        "memory_safety_checks",
        "input_validation",
        "fuzzing",
        "bounds_checking",
        "secure_coding_practices"
      ],
      "code_differences": {
        "has_differences": true,
        "source_lines": 2,
        "target_lines": 2,
        "character_differences": 4317,
        "similarity_percentage": 9.70873786407767
      },
      "vulnerability_location": {
        "vulnerability_present": true,
        "fix_applied": true,
        "code_changed": true,
        "estimated_lines_changed": 0
      }
    },
    {
      "cve_id": "CVE-2015-8631",
      "cwe_id": "CWE-772",
      "cwe_name": "Missing Release of Memory",
      "project": "krb5",
      "severity": "critical",
      "weaponization_score": 8.5,
      "is_critical": true,
      "is_weaponizable": true,
      "is_high_priority_project": true,
      "vulnerable_code": "CWE-772 gprincs_ret * get_princs_2_svc ( gprincs_arg * arg , struct svc_req * rqstp ) { static gprincs_ret ret ; char * prime_arg ; <S2SV_StartBug> gss_buffer_desc client_name , <S2SV_EndBug> service_name ; OM_uint32 minor_stat ; kadm5_server_handle_t handle ; const char * errmsg = NULL ; xdr_free ( xdr_gprincs_ret , & ret ) ; if ( ( ret . code = new_server_handle ( arg -> api_version , rqstp , & handle ) ) ) goto exit_func ; if ( ( ret . code = check_handle ( ( void * ) handle ) ) ) goto exit_func ; ret . api_version = handle -> api_version ; if ( setup_gss_names ( rqstp , & client_name , & service_name ) < 0 ) { ret . code = KADM5_FAILURE ; goto exit_func ; } prime_arg = arg -> exp ; if ( prime_arg == NULL ) prime_arg = \"*\" ; if ( CHANGEPW_SERVICE ( rqstp ) || ! kadm5int_acl_check ( handle -> context , rqst2name ( rqstp ) , ACL_LIST , NULL , NULL ) ) { ret . code = KADM5_AUTH_LIST ; log_unauth ( \"kadm5_get_principals\" , prime_arg , & client_name , & service_name , rqstp ) ; } else { ret . code = kadm5_get_principals ( ( void * ) handle , arg -> exp , & ret . princs , & ret . count ) ; if ( ret . code != 0 ) errmsg = krb5_get_error_message ( handle -> context , ret . code ) ; log_done ( \"kadm5_get_principals\" , prime_arg , errmsg , & client_name , & service_name , rqstp ) ; if ( errmsg != NULL ) krb5_free_error_message ( handle -> context , errmsg ) ; } <S2SV_StartBug> gss_release_buffer ( & minor_stat , & client_name ) ; <S2SV_EndBug> gss_release_buffer ( & minor_stat , & service_name ) ; exit_func : free_server_handle ( handle ) ; return & ret ; }\n",
      "fixed_code": "<S2SV_ModStart> ; gss_buffer_desc client_name = GSS_C_EMPTY_BUFFER ; gss_buffer_desc service_name = GSS_C_EMPTY_BUFFER <S2SV_ModEnd> ; OM_uint32 minor_stat <S2SV_ModStart> ) ; } exit_func : gss_release_buffer ( & minor_stat , & client_name ) ; gss_release_buffer ( & minor_stat , & service_name ) ; <S2SV_ModEnd> free_server_handle ( handle\n",
      "source_code_length": 1577,
      "target_code_length": 341,
      "vulnerability_patterns": {
        "use_after_free": 2,
        "null_pointer": 13,
        "total": 15
      },
      "total_patterns": 15,
      "original_address": "https://github.com/krb5/krb5/commit/83ed75feba32e46f736fcce0d96a0445f29b96c2",
      "discovery_time": "2016-02-13T02:59Z",
      "project_commit_id": "krb5@krb5/83ed75feba32e46f736fcce0d96a0445f29b96c2",
      "extraction_time": "2025-08-31T15:41:49.181872",
      "label": 1,
      "vulnerability_type": "missing_release_of_memory",
      "difficulty_level": "advanced",
      "risk_factors": [
        "critical_infrastructure",
        "use_after_free"
      ],
      "attack_vectors": [
        "fuzzing",
        "code_analysis",
        "reverse_engineering"
      ],
      "mitigation_strategies": [
        "dynamic_analysis",
        "static_analysis",
        "fuzzing",
        "code_review",
        "secure_coding_practices"
      ],
      "code_differences": {
        "has_differences": true,
        "source_lines": 2,
        "target_lines": 2,
        "character_differences": 1236,
        "similarity_percentage": 22.07792207792208
      },
      "vulnerability_location": {
        "vulnerability_present": true,
        "fix_applied": true,
        "code_changed": true,
        "estimated_lines_changed": 0
      }
    },
    {
      "cve_id": "CVE-2019-14495",
      "cwe_id": "CWE-787",
      "cwe_name": "Out-of-bounds Write",
      "project": "z3APA3A",
      "severity": "critical",
      "weaponization_score": 8.5,
      "is_critical": true,
      "is_weaponizable": true,
      "is_high_priority_project": false,
      "vulnerable_code": "CWE-787 void * adminchild ( struct clientparam * param ) { int i , res ; char * buf ; char username [ 256 ] ; char * sb ; char * req = NULL ; struct printparam pp ; <S2SV_StartBug> int contentlen = 0 ; <S2SV_EndBug> int isform = 0 ; pp . inbuf = 0 ; pp . cp = param ; buf = myalloc ( LINESIZE ) ; if ( ! buf ) { RETURN ( 555 ) ; } i = sockgetlinebuf ( param , CLIENT , ( unsigned char * ) buf , LINESIZE - 1 , '\\\\n' , conf . timeouts [ STRING_S ] ) ; if ( i < 5 || ( ( buf [ 0 ] != 'G' || buf [ 1 ] != 'E' || buf [ 2 ] != 'T' || buf [ 3 ] != '<S2SV_blank>' || buf [ 4 ] != '/' ) && ( buf [ 0 ] != 'P' || buf [ 1 ] != 'O' || buf [ 2 ] != 'S' || buf [ 3 ] != 'T' || buf [ 4 ] != '<S2SV_blank>' || buf [ 5 ] != '/' ) ) ) { RETURN ( 701 ) ; } buf [ i ] = 0 ; sb = strchr ( buf + 5 , '<S2SV_blank>' ) ; if ( ! sb ) { RETURN ( 702 ) ; } * sb = 0 ; req = mystrdup ( buf + ( ( * buf == 'P' ) ? 6 : 5 ) ) ; while ( ( i = sockgetlinebuf ( param , CLIENT , ( unsigned char * ) buf , LINESIZE - 1 , '\\\\n' , conf . timeouts [ STRING_S ] ) ) > 2 ) { buf [ i ] = 0 ; if ( i > 19 && ( ! strncasecmp ( buf , \"authorization\" , 13 ) ) ) { sb = strchr ( buf , ':' ) ; if ( ! sb ) continue ; ++ sb ; while ( isspace ( * sb ) ) sb ++ ; if ( ! * sb || strncasecmp ( sb , \"basic\" , 5 ) ) { continue ; } sb += 5 ; while ( isspace ( * sb ) ) sb ++ ; i = de64 ( ( unsigned char * ) sb , ( unsigned char * ) username , 255 ) ; if ( i <= 0 ) continue ; username [ i ] = 0 ; sb = strchr ( ( char * ) username , ':' ) ; if ( sb ) { * sb = 0 ; if ( param -> password ) myfree ( param -> password ) ; param -> password = ( unsigned char * ) mystrdup ( sb + 1 ) ; } if ( param -> username ) myfree ( param -> username ) ; param -> username = ( unsigned char * ) mystrdup ( username ) ; continue ; } else if ( i > 15 && ( ! strncasecmp ( buf , \"content-length:\" , 15 ) ) ) { sb = buf + 15 ; while ( isspace ( * sb ) ) sb ++ ; <S2SV_StartBug> contentlen = atoi ( sb ) ; <S2SV_EndBug> } else if ( i > 13 && ( ! strncasecmp ( buf , \"content-type:\" , 13 ) ) ) { sb = buf + 13 ; while ( isspace ( * sb ) ) sb ++ ; if ( ! strncasecmp ( sb , \"x-www-form-urlencoded\" , 21 ) ) isform = 1 ; } } param -> operation = ADMIN ; if ( isform && contentlen ) { printstr ( & pp , \"HTTP/1.0<S2SV_blank>100<S2SV_blank>Continue\\\\r\\\\n\\\\r\\\\n\" ) ; stdpr ( & pp , NULL , 0 ) ; } res = ( * param -> srv -> authfunc ) ( param ) ; if ( res && res != 10 ) { printstr ( & pp , authreq ) ; RETURN ( res ) ; } if ( param -> srv -> singlepacket || param -> redirected ) { if ( * req == 'C' ) req [ 1 ] = 0 ; else * req = 0 ; } sprintf ( buf , ok , conf . stringtable ? ( char * ) conf . stringtable [ 2 ] : \"3proxy\" , conf . stringtable ? ( char * ) conf . stringtable [ 2 ] : \"3[APA3A]<S2SV_blank>tiny<S2SV_blank>proxy\" , conf . stringtable ? ( char * ) conf . stringtable [ 3 ] : \"\" ) ; if ( * req != 'S' ) printstr ( & pp , buf ) ; switch ( * req ) { case 'C' : printstr ( & pp , counters ) ; { struct trafcount * cp ; int num = 0 ; for ( cp = conf . trafcounter ; cp ; cp = cp -> next , num ++ ) { int inbuf = 0 ; if ( cp -> ace && ( param -> srv -> singlepacket || param -> redirected ) ) { if ( ! ACLmatches ( cp -> ace , param ) ) continue ; } if ( req [ 1 ] == 'S' && atoi ( req + 2 ) == num ) cp -> disabled = 0 ; if ( req [ 1 ] == 'D' && atoi ( req + 2 ) == num ) cp -> disabled = 1 ; inbuf += sprintf ( buf , \"<tr>\" \"<td>%s</td><td><A<S2SV_blank>HREF=\\\\\\'/C%c%d\\\\\\'>%s</A></td><td>\" , ( cp -> comment ) ? cp -> comment : \"&nbsp;\" , ( cp -> disabled ) ? 'S' : 'D' , num , ( cp -> disabled ) ? \"NO\" : \"YES\" ) ; if ( ! cp -> ace || ! cp -> ace -> users ) { inbuf += sprintf ( buf + inbuf , \"<center>ANY</center>\" ) ; } else { inbuf += printuserlist ( buf + inbuf , LINESIZE - 800 , cp -> ace -> users , \",<br<S2SV_blank>/>\\\\r\\\\n\" ) ; } inbuf += sprintf ( buf + inbuf , \"</td><td>\" ) ; if ( ! cp -> ace || ! cp -> ace -> src ) { inbuf += sprintf ( buf + inbuf , \"<center>ANY</center>\" ) ; } else { inbuf += printiplist ( buf + inbuf , LINESIZE - 512 , cp -> ace -> src , \",<br<S2SV_blank>/>\\\\r\\\\n\" ) ; } inbuf += sprintf ( buf + inbuf , \"</td><td>\" ) ; if ( ! cp -> ace || ! cp -> ace -> dst ) { inbuf += sprintf ( buf + inbuf , \"<center>ANY</center>\" ) ; } else { inbuf += printiplist ( buf + inbuf , LINESIZE - 512 , cp -> ace -> dst , \",<br<S2SV_blank>/>\\\\r\\\\n\" ) ; } inbuf += sprintf ( buf + inbuf , \"</td><td>\" ) ; if ( ! cp -> ace || ! cp -> ace -> ports ) { inbuf += sprintf ( buf + inbuf , \"<center>ANY</center>\" ) ; } else { inbuf += printportlist ( buf + inbuf , LINESIZE - 128 , cp -> ace -> ports , \",<br<S2SV_blank>/>\\\\r\\\\n\" ) ; } if ( cp -> type == NONE ) { inbuf += sprintf ( buf + inbuf , \"</td><td<S2SV_blank>colspan=\\\\\\'6\\\\\\'<S2SV_blank>align=\\\\\\'center\\\\\\'>exclude<S2SV_blank>from<S2SV_blank>limitation</td></tr>\\\\r\\\\n\" ) ; } else { inbuf += sprintf ( buf + inbuf , \"</td><td>%\" PRINTF_INT64_MODIFIER \"u</td>\" \"<td>MB%s</td>\" \"<td>%\" PRINTF_INT64_MODIFIER \"u</td>\" \"<td>%s</td>\" , cp -> traflim64 / ( 1024 * 1024 ) , rotations [ cp -> type ] , cp -> traf64 , cp -> cleared ? ctime ( & cp -> cleared ) : \"never\" ) ; inbuf += sprintf ( buf + inbuf , \"<td>%s</td>\" \"<td>%i</td>\" \"</tr>\\\\r\\\\n\" , cp -> updated ? ctime ( & cp -> updated ) : \"never\" , cp -> number ) ; } printstr ( & pp , buf ) ; } } printstr ( & pp , counterstail ) ; break ; case 'R' : conf . needreload = 1 ; printstr ( & pp , \"<h3>Reload<S2SV_blank>scheduled</h3>\" ) ; break ; case 'S' : { if ( req [ 1 ] == 'X' ) { printstr ( & pp , style ) ; break ; } printstr ( & pp , xml ) ; printval ( conf . services , TYPE_SERVER , 0 , & pp ) ; printstr ( & pp , postxml ) ; } break ; case 'F' : { FILE * fp ; char buf [ 256 ] ; fp = confopen ( ) ; if ( ! fp ) { printstr ( & pp , \"<h3><font<S2SV_blank>color=\\\\\"red\\\\\">Failed<S2SV_blank>to<S2SV_blank>open<S2SV_blank>config<S2SV_blank>file</font></h3>\" ) ; break ; } printstr ( & pp , \"<h3>Please<S2SV_blank>be<S2SV_blank>careful<S2SV_blank>editing<S2SV_blank>config<S2SV_blank>file<S2SV_blank>remotely</h3>\" ) ; <S2SV_StartBug> printstr ( & pp , \"<form<S2SV_blank>method=\\\\\"POST\\\\\"<S2SV_blank>action=\\\\\"/U\\\\\"><textarea<S2SV_blank>cols=\\\\\"80\\\\\"<S2SV_blank>rows=\\\\\"30\\\\\"<S2SV_blank>name=\\\\\"conffile\\\\\">\" ) ; <S2SV_EndBug> while ( fgets ( buf , 256 , fp ) ) { printstr ( & pp , buf ) ; } if ( ! writable ) fclose ( fp ) ; printstr ( & pp , \"</textarea><br><input<S2SV_blank>type=\\\\\"Submit\\\\\"></form>\" ) ; break ; } case 'U' : { <S2SV_StartBug> int l = 0 ; <S2SV_EndBug> int error = 0 ; <S2SV_StartBug> if ( ! writable || fseek ( writable , 0 , 0 ) ) { <S2SV_EndBug> error = 1 ; } <S2SV_StartBug> while ( ( i = sockgetlinebuf ( param , CLIENT , ( unsigned char * ) buf , LINESIZE - 1 , '+' , conf . timeouts [ STRING_S ] ) ) > 0 ) { <S2SV_EndBug> if ( i > ( contentlen - l ) ) i = ( contentlen - l ) ; <S2SV_StartBug> buf [ i ] = 0 ; <S2SV_EndBug> if ( ! l ) { if ( strncasecmp ( buf , \"conffile=\" , 9 ) ) error = 1 ; } <S2SV_StartBug> if ( ! error ) { <S2SV_EndBug> decodeurl ( ( unsigned char * ) buf , 1 ) ; fprintf ( writable , \"%s\" , l ? buf : buf + 9 ) ; } <S2SV_StartBug> l += i ; <S2SV_EndBug> if ( l >= contentlen ) break ; } if ( writable && ! error ) { fflush ( writable ) ; # ifndef _WINCE ftruncate ( fileno ( writable ) , ftell ( writable ) ) ; # endif } printstr ( & pp , error ? \"<h3><font<S2SV_blank>color=\\\\\"red\\\\\">Config<S2SV_blank>file<S2SV_blank>is<S2SV_blank>not<S2SV_blank>writable</font></h3>Make<S2SV_blank>sure<S2SV_blank>you<S2SV_blank>have<S2SV_blank>\\\\\"writable\\\\\"<S2SV_blank>command<S2SV_blank>in<S2SV_blank>configuration<S2SV_blank>file\" : \"<h3>Configuration<S2SV_blank>updated</h3>\" ) ; } break ; default : printstr ( & pp , ( char * ) conf . stringtable [ WEBBANNERS ] ) ; break ; } if ( * req != 'S' ) printstr ( & pp , tail ) ; CLEANRET : printstr ( & pp , NULL ) ; if ( buf ) myfree ( buf ) ; ( * param -> srv -> logfunc ) ( param , ( unsigned char * ) req ) ; if ( req ) myfree ( req ) ; freeparam ( param ) ; return ( NULL ) ; }\n",
      "fixed_code": "<S2SV_ModStart> printparam pp ; unsigned <S2SV_ModEnd> contentlen = 0 <S2SV_ModStart> sb ++ ; sscanf ( sb , \"%u\" , & contentlen ) ; if ( contentlen > LINESIZE * 1024 ) contentlen = 0 <S2SV_ModEnd> ; } else <S2SV_ModStart> & pp , \"<form<S2SV_blank>method=\\\\\"POST\\\\\"<S2SV_blank>action=\\\\\"/U\\\\\"<S2SV_blank>enctype=\\\\\"application/x-www-form-urlencoded\\\\\"><textarea<S2SV_blank>cols=\\\\\"80\\\\\"<S2SV_blank>rows=\\\\\"30\\\\\"<S2SV_blank>name=\\\\\"conffile\\\\\">\" <S2SV_ModEnd> ) ; while <S2SV_ModStart> 'U' : { unsigned <S2SV_ModEnd> l = 0 <S2SV_ModStart> ! writable || ! contentlen || <S2SV_ModStart> } while ( l < contentlen && <S2SV_ModStart> ) buf , ( contentlen - l ) > <S2SV_ModStart> LINESIZE - 1 ? LINESIZE - 1 : contentlen - l <S2SV_ModStart> l ) ; if ( ! l ) { if ( i < 9 || <S2SV_ModEnd> strncasecmp ( buf <S2SV_ModStart> error ) { buf [ i ] = 0 ; <S2SV_ModStart> l += i <S2SV_ModEnd> ; } if\n",
      "source_code_length": 7928,
      "target_code_length": 884,
      "vulnerability_patterns": {
        "buffer_overflow": 13,
        "integer_overflow": 23,
        "format_string": 13,
        "null_pointer": 69,
        "total": 118
      },
      "total_patterns": 118,
      "original_address": "https://github.com/z3APA3A/3proxy/commit/3b67dc844789dc0f00e934270c7b349bcb547865",
      "discovery_time": "2019-08-01T17:15Z",
      "project_commit_id": "z3APA3A@3proxy/3b67dc844789dc0f00e934270c7b349bcb547865",
      "extraction_time": "2025-08-31T15:41:49.181894",
      "label": 1,
      "vulnerability_type": "out-of-bounds_write",
      "difficulty_level": "advanced",
      "risk_factors": [
        "system_crash",
        "memory_corruption",
        "buffer_overflow",
        "arbitrary_code_execution"
      ],
      "attack_vectors": [
        "memory_manipulation",
        "malicious_input",
        "code_analysis",
        "buffer_overflow",
        "reverse_engineering",
        "fuzzing"
      ],
      "mitigation_strategies": [
        "safe_string_functions",
        "dynamic_analysis",
        "code_review",
        "static_analysis",
        "memory_safety_checks",
        "input_validation",
        "fuzzing",
        "bounds_checking",
        "secure_coding_practices"
      ],
      "code_differences": {
        "has_differences": true,
        "source_lines": 2,
        "target_lines": 2,
        "character_differences": 7044,
        "similarity_percentage": 17.982456140350877
      },
      "vulnerability_location": {
        "vulnerability_present": true,
        "fix_applied": true,
        "code_changed": true,
        "estimated_lines_changed": 0
      }
    },
    {
      "cve_id": "CVE-2019-19275",
      "cwe_id": "CWE-125",
      "cwe_name": "Out-of-bounds Read",
      "project": "python",
      "severity": "critical",
      "weaponization_score": 8.5,
      "is_critical": true,
      "is_weaponizable": true,
      "is_high_priority_project": true,
      "vulnerable_code": "CWE-125 static arguments_ty ast_for_arguments ( struct compiling * c , const node * n ) { int i , j , k , nposargs = 0 , nkwonlyargs = 0 ; int nposdefaults = 0 , found_default = 0 ; asdl_seq * posargs , * posdefaults , * kwonlyargs , * kwdefaults ; arg_ty vararg = NULL , kwarg = NULL ; arg_ty arg ; node * ch ; if ( TYPE ( n ) == parameters ) { if ( NCH ( n ) == 2 ) return arguments ( NULL , NULL , NULL , NULL , NULL , NULL , c -> c_arena ) ; n = CHILD ( n , 1 ) ; } assert ( TYPE ( n ) == typedargslist || TYPE ( n ) == varargslist ) ; for ( i = 0 ; i < NCH ( n ) ; i ++ ) { ch = CHILD ( n , i ) ; if ( TYPE ( ch ) == STAR ) { i ++ ; if ( i < NCH ( n ) && ( TYPE ( CHILD ( n , i ) ) == tfpdef || TYPE ( CHILD ( n , i ) ) == vfpdef ) ) { i ++ ; } break ; } if ( TYPE ( ch ) == DOUBLESTAR ) break ; if ( TYPE ( ch ) == vfpdef || TYPE ( ch ) == tfpdef ) nposargs ++ ; if ( TYPE ( ch ) == EQUAL ) nposdefaults ++ ; } for ( ; i < NCH ( n ) ; ++ i ) { ch = CHILD ( n , i ) ; if ( TYPE ( ch ) == DOUBLESTAR ) break ; if ( TYPE ( ch ) == tfpdef || TYPE ( ch ) == vfpdef ) nkwonlyargs ++ ; } posargs = ( nposargs ? _Ta3_asdl_seq_new ( nposargs , c -> c_arena ) : NULL ) ; if ( ! posargs && nposargs ) return NULL ; kwonlyargs = ( nkwonlyargs ? _Ta3_asdl_seq_new ( nkwonlyargs , c -> c_arena ) : NULL ) ; if ( ! kwonlyargs && nkwonlyargs ) return NULL ; posdefaults = ( nposdefaults ? _Ta3_asdl_seq_new ( nposdefaults , c -> c_arena ) : NULL ) ; if ( ! posdefaults && nposdefaults ) return NULL ; kwdefaults = ( nkwonlyargs ? _Ta3_asdl_seq_new ( nkwonlyargs , c -> c_arena ) : NULL ) ; if ( ! kwdefaults && nkwonlyargs ) return NULL ; <S2SV_StartBug> if ( nposargs + nkwonlyargs > 255 ) { <S2SV_EndBug> ast_error ( c , n , \"more<S2SV_blank>than<S2SV_blank>255<S2SV_blank>arguments\" ) ; return NULL ; } i = 0 ; j = 0 ; k = 0 ; while ( i < NCH ( n ) ) { ch = CHILD ( n , i ) ; switch ( TYPE ( ch ) ) { case tfpdef : case vfpdef : if ( i + 1 < NCH ( n ) && TYPE ( CHILD ( n , i + 1 ) ) == EQUAL ) { expr_ty expression = ast_for_expr ( c , CHILD ( n , i + 2 ) ) ; if ( ! expression ) return NULL ; assert ( posdefaults != NULL ) ; asdl_seq_SET ( posdefaults , j ++ , expression ) ; i += 2 ; found_default = 1 ; } else if ( found_default ) { ast_error ( c , n , \"non-default<S2SV_blank>argument<S2SV_blank>follows<S2SV_blank>default<S2SV_blank>argument\" ) ; return NULL ; } arg = ast_for_arg ( c , ch ) ; if ( ! arg ) return NULL ; asdl_seq_SET ( posargs , k ++ , arg ) ; i += 1 ; <S2SV_StartBug> if ( i < NCH ( n ) && TYPE ( CHILD ( n , i ) ) == COMMA ) <S2SV_EndBug> i += 1 ; break ; case STAR : if ( i + 1 >= NCH ( n ) || ( i + 2 == NCH ( n ) && ( TYPE ( CHILD ( n , i + 1 ) ) == COMMA || TYPE ( CHILD ( n , i + 1 ) ) == TYPE_COMMENT ) ) ) { ast_error ( c , CHILD ( n , i ) , \"named<S2SV_blank>arguments<S2SV_blank>must<S2SV_blank>follow<S2SV_blank>bare<S2SV_blank>*\" ) ; return NULL ; } ch = CHILD ( n , i + 1 ) ; if ( TYPE ( ch ) == COMMA ) { int res = 0 ; i += 2 ; <S2SV_StartBug> if ( i < NCH ( n ) && TYPE ( CHILD ( n , i ) ) == TYPE_COMMENT ) { <S2SV_EndBug> ast_error ( c , CHILD ( n , i ) , \"bare<S2SV_blank>*<S2SV_blank>has<S2SV_blank>associated<S2SV_blank>type<S2SV_blank>comment\" ) ; return NULL ; } res = handle_keywordonly_args ( c , n , i , kwonlyargs , kwdefaults ) ; if ( res == - 1 ) return NULL ; i = res ; } else { vararg = ast_for_arg ( c , ch ) ; if ( ! vararg ) return NULL ; i += 2 ; <S2SV_StartBug> if ( i < NCH ( n ) && TYPE ( CHILD ( n , i ) ) == COMMA ) <S2SV_EndBug> i += 1 ; <S2SV_StartBug> if ( i < NCH ( n ) && TYPE ( CHILD ( n , i ) ) == TYPE_COMMENT ) { <S2SV_EndBug> vararg -> type_comment = NEW_TYPE_COMMENT ( CHILD ( n , i ) ) ; i += 1 ; } if ( i < NCH ( n ) && ( TYPE ( CHILD ( n , i ) ) == tfpdef || TYPE ( CHILD ( n , i ) ) == vfpdef ) ) { int res = 0 ; res = handle_keywordonly_args ( c , n , i , kwonlyargs , kwdefaults ) ; if ( res == - 1 ) return NULL ; i = res ; } } break ; case DOUBLESTAR : ch = CHILD ( n , i + 1 ) ; assert ( TYPE ( ch ) == tfpdef || TYPE ( ch ) == vfpdef ) ; kwarg = ast_for_arg ( c , ch ) ; if ( ! kwarg ) return NULL ; i += 2 ; <S2SV_StartBug> if ( i < NCH ( n ) && TYPE ( CHILD ( n , i ) ) == COMMA ) <S2SV_EndBug> i += 1 ; break ; case TYPE_COMMENT : assert ( i ) ; if ( kwarg ) arg = kwarg ; arg -> type_comment = NEW_TYPE_COMMENT ( ch ) ; i += 1 ; break ; default : PyErr_Format ( PyExc_SystemError , \"unexpected<S2SV_blank>node<S2SV_blank>in<S2SV_blank>varargslist:<S2SV_blank>%d<S2SV_blank>@<S2SV_blank>%d\" , TYPE ( ch ) , i ) ; return NULL ; } } return arguments ( posargs , vararg , kwonlyargs , kwdefaults , kwarg , posdefaults , c -> c_arena ) ; }\n",
      "fixed_code": "<S2SV_ModStart> return NULL ; <S2SV_ModEnd> i = 0 <S2SV_ModStart> ; if ( <S2SV_ModEnd> TYPE ( CHILD <S2SV_ModStart> ; if ( <S2SV_ModEnd> TYPE ( CHILD <S2SV_ModStart> ; if ( <S2SV_ModEnd> TYPE ( CHILD <S2SV_ModStart> ; if ( <S2SV_ModEnd> TYPE ( CHILD <S2SV_ModStart> ; if ( <S2SV_ModEnd> TYPE ( CHILD\n",
      "source_code_length": 4617,
      "target_code_length": 300,
      "vulnerability_patterns": {
        "integer_overflow": 1,
        "null_pointer": 11,
        "total": 12
      },
      "total_patterns": 12,
      "original_address": "https://github.com/python/typed_ast/commit/156afcb26c198e162504a57caddfe0acd9ed7dce",
      "discovery_time": "2019-11-26T15:15Z",
      "project_commit_id": "python@typed_ast/156afcb26c198e162504a57caddfe0acd9ed7dce",
      "extraction_time": "2025-08-31T15:41:49.181967",
      "label": 1,
      "vulnerability_type": "out-of-bounds_read",
      "difficulty_level": "advanced",
      "risk_factors": [
        "information_disclosure",
        "memory_corruption",
        "integer_overflow",
        "critical_infrastructure"
      ],
      "attack_vectors": [
        "memory_manipulation",
        "malicious_input",
        "code_analysis",
        "buffer_overflow",
        "reverse_engineering",
        "fuzzing"
      ],
      "mitigation_strategies": [
        "safe_string_functions",
        "dynamic_analysis",
        "code_review",
        "static_analysis",
        "memory_safety_checks",
        "input_validation",
        "fuzzing",
        "bounds_checking",
        "secure_coding_practices"
      ],
      "code_differences": {
        "has_differences": true,
        "source_lines": 2,
        "target_lines": 2,
        "character_differences": 4317,
        "similarity_percentage": 9.70873786407767
      },
      "vulnerability_location": {
        "vulnerability_present": true,
        "fix_applied": true,
        "code_changed": true,
        "estimated_lines_changed": 0
      }
    },
    {
      "cve_id": "CVE-2016-1621",
      "cwe_id": "CWE-119",
      "cwe_name": "Buffer Overflow",
      "project": "external",
      "severity": "critical",
      "weaponization_score": 8.5,
      "is_critical": true,
      "is_weaponizable": true,
      "is_high_priority_project": false,
      "vulnerable_code": "CWE-119 int main ( int argc , char * * argv ) { int frame_cnt = 0 ; FILE * outfile = NULL ; vpx_codec_ctx_t codec ; const VpxInterface * decoder = NULL ; VpxVideoReader * reader = NULL ; const VpxVideoInfo * info = NULL ; int n = 0 ; int m = 0 ; int is_range = 0 ; char * nptr = NULL ; exec_name = argv [ 0 ] ; if ( argc != 4 ) die ( \"Invalid<S2SV_blank>number<S2SV_blank>of<S2SV_blank>arguments.\" ) ; reader = vpx_video_reader_open ( argv [ 1 ] ) ; if ( ! reader ) die ( \"Failed<S2SV_blank>to<S2SV_blank>open<S2SV_blank>%s<S2SV_blank>for<S2SV_blank>reading.\" , argv [ 1 ] ) ; if ( ! ( outfile = fopen ( argv [ 2 ] , \"wb\" ) ) ) die ( \"Failed<S2SV_blank>to<S2SV_blank>open<S2SV_blank>%s<S2SV_blank>for<S2SV_blank>writing.\" , argv [ 2 ] ) ; n = strtol ( argv [ 3 ] , & nptr , 0 ) ; m = strtol ( nptr + 1 , NULL , 0 ) ; is_range = ( * nptr == '-' ) ; if ( ! n || ! m || ( * nptr != '-' && * nptr != '/' ) ) die ( \"Couldn\\'t<S2SV_blank>parse<S2SV_blank>pattern<S2SV_blank>%s.\\\\n\" , argv [ 3 ] ) ; info = vpx_video_reader_get_info ( reader ) ; decoder = get_vpx_decoder_by_fourcc ( info -> codec_fourcc ) ; if ( ! decoder ) die ( \"Unknown<S2SV_blank>input<S2SV_blank>codec.\" ) ; <S2SV_StartBug> printf ( \"Using<S2SV_blank>%s\\\\n\" , vpx_codec_iface_name ( decoder -> interface ( ) ) ) ; <S2SV_EndBug> <S2SV_StartBug> if ( vpx_codec_dec_init ( & codec , decoder -> interface ( ) , NULL , 0 ) ) <S2SV_EndBug> die_codec ( & codec , \"Failed<S2SV_blank>to<S2SV_blank>initialize<S2SV_blank>decoder.\" ) ; while ( vpx_video_reader_read_frame ( reader ) ) { vpx_codec_iter_t iter = NULL ; vpx_image_t * img = NULL ; size_t frame_size = 0 ; int skip ; const unsigned char * frame = vpx_video_reader_get_frame ( reader , & frame_size ) ; if ( vpx_codec_decode ( & codec , frame , ( unsigned int ) frame_size , NULL , 0 ) ) die_codec ( & codec , \"Failed<S2SV_blank>to<S2SV_blank>decode<S2SV_blank>frame.\" ) ; ++ frame_cnt ; skip = ( is_range && frame_cnt >= n && frame_cnt <= m ) || ( ! is_range && m - ( frame_cnt - 1 ) % m <= n ) ; if ( ! skip ) { putc ( '.' , stdout ) ; while ( ( img = vpx_codec_get_frame ( & codec , & iter ) ) != NULL ) vpx_img_write ( img , outfile ) ; } else { putc ( 'X' , stdout ) ; } fflush ( stdout ) ; } printf ( \"Processed<S2SV_blank>%d<S2SV_blank>frames.\\\\n\" , frame_cnt ) ; if ( vpx_codec_destroy ( & codec ) ) die_codec ( & codec , \"Failed<S2SV_blank>to<S2SV_blank>destroy<S2SV_blank>codec.\" ) ; printf ( \"Play:<S2SV_blank>ffplay<S2SV_blank>-f<S2SV_blank>rawvideo<S2SV_blank>-pix_fmt<S2SV_blank>yuv420p<S2SV_blank>-s<S2SV_blank>%dx%d<S2SV_blank>%s\\\\n\" , info -> frame_width , info -> frame_height , argv [ 2 ] ) ; vpx_video_reader_close ( reader ) ; fclose ( outfile ) ; return EXIT_SUCCESS ; }\n",
      "fixed_code": "<S2SV_ModStart> ( decoder -> codec_interface <S2SV_ModEnd> ( ) ) <S2SV_ModStart> , decoder -> codec_interface <S2SV_ModEnd> ( ) ,\n",
      "source_code_length": 2710,
      "target_code_length": 130,
      "vulnerability_patterns": {
        "use_after_free": 3,
        "integer_overflow": 2,
        "format_string": 1,
        "null_pointer": 71,
        "total": 77
      },
      "total_patterns": 77,
      "original_address": "https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426",
      "discovery_time": "2016-03-12T21:59Z",
      "project_commit_id": "external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426",
      "extraction_time": "2025-08-31T15:41:49.182021",
      "label": 1,
      "vulnerability_type": "buffer_overflow",
      "difficulty_level": "advanced",
      "risk_factors": [
        "system_crash",
        "memory_corruption",
        "arbitrary_code_execution",
        "use_after_free"
      ],
      "attack_vectors": [
        "memory_manipulation",
        "malicious_input",
        "code_analysis",
        "buffer_overflow",
        "reverse_engineering",
        "fuzzing"
      ],
      "mitigation_strategies": [
        "safe_string_functions",
        "dynamic_analysis",
        "code_review",
        "static_analysis",
        "memory_safety_checks",
        "input_validation",
        "fuzzing",
        "bounds_checking",
        "secure_coding_practices"
      ],
      "code_differences": {
        "has_differences": true,
        "source_lines": 2,
        "target_lines": 2,
        "character_differences": 2580,
        "similarity_percentage": 4.464285714285714
      },
      "vulnerability_location": {
        "vulnerability_present": true,
        "fix_applied": true,
        "code_changed": true,
        "estimated_lines_changed": 0
      }
    },
    {
      "cve_id": "CVE-2016-3138",
      "cwe_id": "CWE-000",
      "cwe_name": "Unknown/Uncategorized",
      "project": "torvalds",
      "severity": "critical",
      "weaponization_score": 8.5,
      "is_critical": true,
      "is_weaponizable": true,
      "is_high_priority_project": false,
      "vulnerable_code": "CWE-000 static int acm_probe ( struct usb_interface * intf , const struct usb_device_id * id ) { struct usb_cdc_union_desc * union_header = NULL ; struct usb_cdc_country_functional_desc * cfd = NULL ; unsigned char * buffer = intf -> altsetting -> extra ; int buflen = intf -> altsetting -> extralen ; struct usb_interface * control_interface ; struct usb_interface * data_interface ; struct usb_endpoint_descriptor * epctrl = NULL ; struct usb_endpoint_descriptor * epread = NULL ; struct usb_endpoint_descriptor * epwrite = NULL ; struct usb_device * usb_dev = interface_to_usbdev ( intf ) ; struct acm * acm ; int minor ; int ctrlsize , readsize ; u8 * buf ; u8 ac_management_function = 0 ; u8 call_management_function = 0 ; int call_interface_num = - 1 ; int data_interface_num = - 1 ; unsigned long quirks ; int num_rx_buf ; int i ; unsigned int elength = 0 ; int combined_interfaces = 0 ; struct device * tty_dev ; int rv = - ENOMEM ; quirks = ( unsigned long ) id -> driver_info ; if ( quirks == IGNORE_DEVICE ) return - ENODEV ; num_rx_buf = ( quirks == SINGLE_RX_URB ) ? 1 : ACM_NR ; if ( quirks == NO_UNION_NORMAL ) { data_interface = usb_ifnum_to_if ( usb_dev , 1 ) ; <S2SV_StartBug> control_interface = usb_ifnum_to_if ( usb_dev , 0 ) ; <S2SV_EndBug> goto skip_normal_probe ; } if ( ! buffer ) { dev_err ( & intf -> dev , \"Weird<S2SV_blank>descriptor<S2SV_blank>references\\\\n\" ) ; return - EINVAL ; } if ( ! buflen ) { if ( intf -> cur_altsetting -> endpoint && intf -> cur_altsetting -> endpoint -> extralen && intf -> cur_altsetting -> endpoint -> extra ) { dev_dbg ( & intf -> dev , \"Seeking<S2SV_blank>extra<S2SV_blank>descriptors<S2SV_blank>on<S2SV_blank>endpoint\\\\n\" ) ; buflen = intf -> cur_altsetting -> endpoint -> extralen ; buffer = intf -> cur_altsetting -> endpoint -> extra ; } else { dev_err ( & intf -> dev , \"Zero<S2SV_blank>length<S2SV_blank>descriptor<S2SV_blank>references\\\\n\" ) ; return - EINVAL ; } } while ( buflen > 0 ) { elength = buffer [ 0 ] ; if ( ! elength ) { dev_err ( & intf -> dev , \"skipping<S2SV_blank>garbage<S2SV_blank>byte\\\\n\" ) ; elength = 1 ; goto next_desc ; } if ( buffer [ 1 ] != USB_DT_CS_INTERFACE ) { dev_err ( & intf -> dev , \"skipping<S2SV_blank>garbage\\\\n\" ) ; goto next_desc ; } switch ( buffer [ 2 ] ) { case USB_CDC_UNION_TYPE : if ( elength < sizeof ( struct usb_cdc_union_desc ) ) goto next_desc ; if ( union_header ) { dev_err ( & intf -> dev , \"More<S2SV_blank>than<S2SV_blank>one<S2SV_blank>\" \"union<S2SV_blank>descriptor,<S2SV_blank>skipping<S2SV_blank>...\\\\n\" ) ; goto next_desc ; } union_header = ( struct usb_cdc_union_desc * ) buffer ; break ; case USB_CDC_COUNTRY_TYPE : if ( elength < sizeof ( struct usb_cdc_country_functional_desc ) ) goto next_desc ; cfd = ( struct usb_cdc_country_functional_desc * ) buffer ; break ; case USB_CDC_HEADER_TYPE : break ; case USB_CDC_ACM_TYPE : if ( elength < 4 ) goto next_desc ; ac_management_function = buffer [ 3 ] ; break ; case USB_CDC_CALL_MANAGEMENT_TYPE : if ( elength < 5 ) goto next_desc ; call_management_function = buffer [ 3 ] ; call_interface_num = buffer [ 4 ] ; break ; default : dev_dbg ( & intf -> dev , \"Ignoring<S2SV_blank>descriptor:<S2SV_blank>\" \"type<S2SV_blank>%02x,<S2SV_blank>length<S2SV_blank>%ud\\\\n\" , buffer [ 2 ] , elength ) ; break ; } next_desc : buflen -= elength ; buffer += elength ; } if ( ! union_header ) { if ( call_interface_num > 0 ) { dev_dbg ( & intf -> dev , \"No<S2SV_blank>union<S2SV_blank>descriptor,<S2SV_blank>using<S2SV_blank>call<S2SV_blank>management<S2SV_blank>descriptor\\\\n\" ) ; if ( quirks & NO_DATA_INTERFACE ) data_interface = usb_ifnum_to_if ( usb_dev , 0 ) ; else data_interface = usb_ifnum_to_if ( usb_dev , ( data_interface_num = call_interface_num ) ) ; control_interface = intf ; } else { if ( intf -> cur_altsetting -> desc . bNumEndpoints != 3 ) { dev_dbg ( & intf -> dev , \"No<S2SV_blank>union<S2SV_blank>descriptor,<S2SV_blank>giving<S2SV_blank>up\\\\n\" ) ; return - ENODEV ; } else { dev_warn ( & intf -> dev , \"No<S2SV_blank>union<S2SV_blank>descriptor,<S2SV_blank>testing<S2SV_blank>for<S2SV_blank>castrated<S2SV_blank>device\\\\n\" ) ; combined_interfaces = 1 ; control_interface = data_interface = intf ; goto look_for_collapsed_interface ; } } } else { control_interface = usb_ifnum_to_if ( usb_dev , union_header -> bMasterInterface0 ) ; data_interface = usb_ifnum_to_if ( usb_dev , ( data_interface_num = union_header -> bSlaveInterface0 ) ) ; } if ( ! control_interface || ! data_interface ) { dev_dbg ( & intf -> dev , \"no<S2SV_blank>interfaces\\\\n\" ) ; return - ENODEV ; } if ( data_interface_num != call_interface_num ) dev_dbg ( & intf -> dev , \"Separate<S2SV_blank>call<S2SV_blank>control<S2SV_blank>interface.<S2SV_blank>That<S2SV_blank>is<S2SV_blank>not<S2SV_blank>fully<S2SV_blank>supported.\\\\n\" ) ; if ( control_interface == data_interface ) { dev_warn ( & intf -> dev , \"Control<S2SV_blank>and<S2SV_blank>data<S2SV_blank>interfaces<S2SV_blank>are<S2SV_blank>not<S2SV_blank>separated!\\\\n\" ) ; combined_interfaces = 1 ; quirks |= NO_CAP_LINE ; if ( data_interface -> cur_altsetting -> desc . bNumEndpoints != 3 ) { dev_err ( & intf -> dev , \"This<S2SV_blank>needs<S2SV_blank>exactly<S2SV_blank>3<S2SV_blank>endpoints\\\\n\" ) ; return - EINVAL ; } look_for_collapsed_interface : for ( i = 0 ; i < 3 ; i ++ ) { struct usb_endpoint_descriptor * ep ; ep = & data_interface -> cur_altsetting -> endpoint [ i ] . desc ; if ( usb_endpoint_is_int_in ( ep ) ) epctrl = ep ; else if ( usb_endpoint_is_bulk_out ( ep ) ) epwrite = ep ; else if ( usb_endpoint_is_bulk_in ( ep ) ) epread = ep ; else return - EINVAL ; } if ( ! epctrl || ! epread || ! epwrite ) return - ENODEV ; else goto made_compressed_probe ; } skip_normal_probe : if ( data_interface -> cur_altsetting -> desc . bInterfaceClass != CDC_DATA_INTERFACE_TYPE ) { if ( control_interface -> cur_altsetting -> desc . bInterfaceClass == CDC_DATA_INTERFACE_TYPE ) { dev_dbg ( & intf -> dev , \"Your<S2SV_blank>device<S2SV_blank>has<S2SV_blank>switched<S2SV_blank>interfaces.\\\\n\" ) ; swap ( control_interface , data_interface ) ; } else { return - EINVAL ; } } if ( ! combined_interfaces && intf != control_interface ) return - ENODEV ; if ( ! combined_interfaces && usb_interface_claimed ( data_interface ) ) { dev_dbg ( & intf -> dev , \"The<S2SV_blank>data<S2SV_blank>interface<S2SV_blank>isn\\'t<S2SV_blank>available\\\\n\" ) ; return - EBUSY ; } if ( data_interface -> cur_altsetting -> desc . bNumEndpoints < 2 || control_interface -> cur_altsetting -> desc . bNumEndpoints == 0 ) return - EINVAL ; epctrl = & control_interface -> cur_altsetting -> endpoint [ 0 ] . desc ; epread = & data_interface -> cur_altsetting -> endpoint [ 0 ] . desc ; epwrite = & data_interface -> cur_altsetting -> endpoint [ 1 ] . desc ; if ( ! usb_endpoint_dir_in ( epread ) ) { dev_dbg ( & intf -> dev , \"The<S2SV_blank>data<S2SV_blank>interface<S2SV_blank>has<S2SV_blank>switched<S2SV_blank>endpoints\\\\n\" ) ; swap ( epread , epwrite ) ; } made_compressed_probe : dev_dbg ( & intf -> dev , \"interfaces<S2SV_blank>are<S2SV_blank>valid\\\\n\" ) ; acm = kzalloc ( sizeof ( struct acm ) , GFP_KERNEL ) ; if ( acm == NULL ) goto alloc_fail ; minor = acm_alloc_minor ( acm ) ; if ( minor < 0 ) { dev_err ( & intf -> dev , \"no<S2SV_blank>more<S2SV_blank>free<S2SV_blank>acm<S2SV_blank>devices\\\\n\" ) ; kfree ( acm ) ; return - ENODEV ; } ctrlsize = usb_endpoint_maxp ( epctrl ) ; readsize = usb_endpoint_maxp ( epread ) * ( quirks == SINGLE_RX_URB ? 1 : 2 ) ; acm -> combined_interfaces = combined_interfaces ; acm -> writesize = usb_endpoint_maxp ( epwrite ) * 20 ; acm -> control = control_interface ; acm -> data = data_interface ; acm -> minor = minor ; acm -> dev = usb_dev ; acm -> ctrl_caps = ac_management_function ; if ( quirks & NO_CAP_LINE ) acm -> ctrl_caps &= ~ USB_CDC_CAP_LINE ; acm -> ctrlsize = ctrlsize ; acm -> readsize = readsize ; acm -> rx_buflimit = num_rx_buf ; INIT_WORK ( & acm -> work , acm_softint ) ; init_waitqueue_head ( & acm -> wioctl ) ; spin_lock_init ( & acm -> write_lock ) ; spin_lock_init ( & acm -> read_lock ) ; mutex_init ( & acm -> mutex ) ; acm -> rx_endpoint = usb_rcvbulkpipe ( usb_dev , epread -> bEndpointAddress ) ; acm -> is_int_ep = usb_endpoint_xfer_int ( epread ) ; if ( acm -> is_int_ep ) acm -> bInterval = epread -> bInterval ; tty_port_init ( & acm -> port ) ; acm -> port . ops = & acm_port_ops ; init_usb_anchor ( & acm -> delayed ) ; acm -> quirks = quirks ; buf = usb_alloc_coherent ( usb_dev , ctrlsize , GFP_KERNEL , & acm -> ctrl_dma ) ; if ( ! buf ) goto alloc_fail2 ; acm -> ctrl_buffer = buf ; if ( acm_write_buffers_alloc ( acm ) < 0 ) goto alloc_fail4 ; acm -> ctrlurb = usb_alloc_urb ( 0 , GFP_KERNEL ) ; if ( ! acm -> ctrlurb ) goto alloc_fail5 ; for ( i = 0 ; i < num_rx_buf ; i ++ ) { struct acm_rb * rb = & ( acm -> read_buffers [ i ] ) ; struct urb * urb ; rb -> base = usb_alloc_coherent ( acm -> dev , readsize , GFP_KERNEL , & rb -> dma ) ; if ( ! rb -> base ) goto alloc_fail6 ; rb -> index = i ; rb -> instance = acm ; urb = usb_alloc_urb ( 0 , GFP_KERNEL ) ; if ( ! urb ) goto alloc_fail6 ; urb -> transfer_flags |= URB_NO_TRANSFER_DMA_MAP ; urb -> transfer_dma = rb -> dma ; if ( acm -> is_int_ep ) { usb_fill_int_urb ( urb , acm -> dev , acm -> rx_endpoint , rb -> base , acm -> readsize , acm_read_bulk_callback , rb , acm -> bInterval ) ; } else { usb_fill_bulk_urb ( urb , acm -> dev , acm -> rx_endpoint , rb -> base , acm -> readsize , acm_read_bulk_callback , rb ) ; } acm -> read_urbs [ i ] = urb ; __set_bit ( i , & acm -> read_urbs_free ) ; } for ( i = 0 ; i < ACM_NW ; i ++ ) { struct acm_wb * snd = & ( acm -> wb [ i ] ) ; snd -> urb = usb_alloc_urb ( 0 , GFP_KERNEL ) ; if ( snd -> urb == NULL ) goto alloc_fail7 ; if ( usb_endpoint_xfer_int ( epwrite ) ) usb_fill_int_urb ( snd -> urb , usb_dev , usb_sndintpipe ( usb_dev , epwrite -> bEndpointAddress ) , NULL , acm -> writesize , acm_write_bulk , snd , epwrite -> bInterval ) ; else usb_fill_bulk_urb ( snd -> urb , usb_dev , usb_sndbulkpipe ( usb_dev , epwrite -> bEndpointAddress ) , NULL , acm -> writesize , acm_write_bulk , snd ) ; snd -> urb -> transfer_flags |= URB_NO_TRANSFER_DMA_MAP ; if ( quirks & SEND_ZERO_PACKET ) snd -> urb -> transfer_flags |= URB_ZERO_PACKET ; snd -> instance = acm ; } usb_set_intfdata ( intf , acm ) ; i = device_create_file ( & intf -> dev , & dev_attr_bmCapabilities ) ; if ( i < 0 ) goto alloc_fail7 ; if ( cfd ) { acm -> country_codes = kmalloc ( cfd -> bLength - 4 , GFP_KERNEL ) ; if ( ! acm -> country_codes ) goto skip_countries ; acm -> country_code_size = cfd -> bLength - 4 ; memcpy ( acm -> country_codes , ( u8 * ) & cfd -> wCountyCode0 , cfd -> bLength - 4 ) ; acm -> country_rel_date = cfd -> iCountryCodeRelDate ; i = device_create_file ( & intf -> dev , & dev_attr_wCountryCodes ) ; if ( i < 0 ) { kfree ( acm -> country_codes ) ; acm -> country_codes = NULL ; acm -> country_code_size = 0 ; goto skip_countries ; } i = device_create_file ( & intf -> dev , & dev_attr_iCountryCodeRelDate ) ; if ( i < 0 ) { device_remove_file ( & intf -> dev , & dev_attr_wCountryCodes ) ; kfree ( acm -> country_codes ) ; acm -> country_codes = NULL ; acm -> country_code_size = 0 ; goto skip_countries ; } } skip_countries : usb_fill_int_urb ( acm -> ctrlurb , usb_dev , usb_rcvintpipe ( usb_dev , epctrl -> bEndpointAddress ) , acm -> ctrl_buffer , ctrlsize , acm_ctrl_irq , acm , epctrl -> bInterval ? epctrl -> bInterval : 16 ) ; acm -> ctrlurb -> transfer_flags |= URB_NO_TRANSFER_DMA_MAP ; acm -> ctrlurb -> transfer_dma = acm -> ctrl_dma ; dev_info ( & intf -> dev , \"ttyACM%d:<S2SV_blank>USB<S2SV_blank>ACM<S2SV_blank>device\\\\n\" , minor ) ; acm -> line . dwDTERate = cpu_to_le32 ( 9600 ) ; acm -> line . bDataBits = 8 ; acm_set_line ( acm , & acm -> line ) ; usb_driver_claim_interface ( & acm_driver , data_interface , acm ) ; usb_set_intfdata ( data_interface , acm ) ; usb_get_intf ( control_interface ) ; tty_dev = tty_port_register_device ( & acm -> port , acm_tty_driver , minor , & control_interface -> dev ) ; if ( IS_ERR ( tty_dev ) ) { rv = PTR_ERR ( tty_dev ) ; goto alloc_fail8 ; } if ( quirks & CLEAR_HALT_CONDITIONS ) { usb_clear_halt ( usb_dev , usb_rcvbulkpipe ( usb_dev , epread -> bEndpointAddress ) ) ; usb_clear_halt ( usb_dev , usb_sndbulkpipe ( usb_dev , epwrite -> bEndpointAddress ) ) ; } return 0 ; alloc_fail8 : if ( acm -> country_codes ) { device_remove_file ( & acm -> control -> dev , & dev_attr_wCountryCodes ) ; device_remove_file ( & acm -> control -> dev , & dev_attr_iCountryCodeRelDate ) ; kfree ( acm -> country_codes ) ; } device_remove_file ( & acm -> control -> dev , & dev_attr_bmCapabilities ) ; alloc_fail7 : usb_set_intfdata ( intf , NULL ) ; for ( i = 0 ; i < ACM_NW ; i ++ ) usb_free_urb ( acm -> wb [ i ] . urb ) ; alloc_fail6 : for ( i = 0 ; i < num_rx_buf ; i ++ ) usb_free_urb ( acm -> read_urbs [ i ] ) ; acm_read_buffers_free ( acm ) ; usb_free_urb ( acm -> ctrlurb ) ; alloc_fail5 : acm_write_buffers_free ( acm ) ; alloc_fail4 : usb_free_coherent ( usb_dev , ctrlsize , acm -> ctrl_buffer , acm -> ctrl_dma ) ; alloc_fail2 : acm_release_minor ( acm ) ; kfree ( acm ) ; alloc_fail : return rv ; }\n",
      "fixed_code": "<S2SV_ModStart> , 0 ) ; if ( ! data_interface || ! control_interface ) return - ENODEV\n",
      "source_code_length": 13147,
      "target_code_length": 87,
      "vulnerability_patterns": {
        "buffer_overflow": 1,
        "use_after_free": 5,
        "integer_overflow": 7,
        "null_pointer": 191,
        "memory_leak": 1,
        "total": 205
      },
      "total_patterns": 205,
      "original_address": "https://github.com/torvalds/linux/commit/8835ba4a39cf53f705417b3b3a94eb067673f2c9",
      "discovery_time": "2016-05-02T10:59Z",
      "project_commit_id": "torvalds@linux/8835ba4a39cf53f705417b3b3a94eb067673f2c9",
      "extraction_time": "2025-08-31T15:41:49.182050",
      "label": 1,
      "vulnerability_type": "unknown/uncategorized",
      "difficulty_level": "advanced",
      "risk_factors": [
        "buffer_overflow",
        "use_after_free"
      ],
      "attack_vectors": [
        "fuzzing",
        "code_analysis",
        "reverse_engineering"
      ],
      "mitigation_strategies": [
        "dynamic_analysis",
        "static_analysis",
        "fuzzing",
        "code_review",
        "secure_coding_practices"
      ],
      "code_differences": {
        "has_differences": true,
        "source_lines": 2,
        "target_lines": 2,
        "character_differences": 13060,
        "similarity_percentage": 4.7272727272727275
      },
      "vulnerability_location": {
        "vulnerability_present": true,
        "fix_applied": true,
        "code_changed": true,
        "estimated_lines_changed": 0
      }
    },
    {
      "cve_id": "CVE-2020-14954",
      "cwe_id": "CWE-74",
      "cwe_name": "Command Injection",
      "project": "neomutt",
      "severity": "critical",
      "weaponization_score": 8.5,
      "is_critical": true,
      "is_weaponizable": true,
      "is_high_priority_project": true,
      "vulnerable_code": "CWE-74 int nntp_open_connection ( struct NntpAccountData * adata ) { struct Connection * conn = adata -> conn ; char buf [ 256 ] ; int cap ; bool posting = false , auth = true ; if ( adata -> status == NNTP_OK ) return 0 ; if ( adata -> status == NNTP_BYE ) return - 1 ; adata -> status = NNTP_NONE ; if ( mutt_socket_open ( conn ) < 0 ) return - 1 ; if ( mutt_socket_readln ( buf , sizeof ( buf ) , conn ) < 0 ) return nntp_connect_error ( adata ) ; if ( mutt_str_startswith ( buf , \"200\" , CASE_MATCH ) ) posting = true ; else if ( ! mutt_str_startswith ( buf , \"201\" , CASE_MATCH ) ) { mutt_socket_close ( conn ) ; mutt_str_remove_trailing_ws ( buf ) ; mutt_error ( \"%s\" , buf ) ; return - 1 ; } cap = nntp_capabilities ( adata ) ; if ( cap < 0 ) return - 1 ; if ( cap > 0 ) { if ( ( mutt_socket_send ( conn , \"MODE<S2SV_blank>READER\\\\r\\\\n\" ) < 0 ) || ( mutt_socket_readln ( buf , sizeof ( buf ) , conn ) < 0 ) ) { return nntp_connect_error ( adata ) ; } if ( mutt_str_startswith ( buf , \"200\" , CASE_MATCH ) ) posting = true ; else if ( mutt_str_startswith ( buf , \"201\" , CASE_MATCH ) ) posting = false ; else if ( adata -> hasCAPABILITIES ) { mutt_socket_close ( conn ) ; mutt_error ( _ ( \"Could<S2SV_blank>not<S2SV_blank>switch<S2SV_blank>to<S2SV_blank>reader<S2SV_blank>mode\" ) ) ; return - 1 ; } if ( adata -> hasCAPABILITIES ) { cap = nntp_capabilities ( adata ) ; if ( cap < 0 ) return - 1 ; } } mutt_message ( _ ( \"Connected<S2SV_blank>to<S2SV_blank>%s.<S2SV_blank>%s\" ) , conn -> account . host , posting ? _ ( \"Posting<S2SV_blank>is<S2SV_blank>ok\" ) : _ ( \"Posting<S2SV_blank>is<S2SV_blank>NOT<S2SV_blank>ok\" ) ) ; mutt_sleep ( 1 ) ; # ifdef USE_SSL if ( ( adata -> use_tls != 1 ) && ( adata -> hasSTARTTLS || C_SslForceTls ) ) { if ( adata -> use_tls == 0 ) { adata -> use_tls = C_SslForceTls || query_quadoption ( C_SslStarttls , _ ( \"Secure<S2SV_blank>connection<S2SV_blank>with<S2SV_blank>TLS?\" ) ) == MUTT_YES ? 2 : 1 ; } if ( adata -> use_tls == 2 ) { if ( ( mutt_socket_send ( conn , \"STARTTLS\\\\r\\\\n\" ) < 0 ) || ( mutt_socket_readln ( buf , sizeof ( buf ) , conn ) < 0 ) ) { return nntp_connect_error ( adata ) ; <S2SV_StartBug> } <S2SV_EndBug> if ( ! mutt_str_startswith ( buf , \"382\" , CASE_MATCH ) ) { adata -> use_tls = 0 ; mutt_error ( \"STARTTLS:<S2SV_blank>%s\" , buf ) ; } else if ( mutt_ssl_starttls ( conn ) ) { adata -> use_tls = 0 ; adata -> status = NNTP_NONE ; mutt_socket_close ( adata -> conn ) ; mutt_error ( _ ( \"Could<S2SV_blank>not<S2SV_blank>negotiate<S2SV_blank>TLS<S2SV_blank>connection\" ) ) ; return - 1 ; } else { cap = nntp_capabilities ( adata ) ; if ( cap < 0 ) return - 1 ; } } } # endif if ( conn -> account . flags & MUTT_ACCT_USER ) { if ( ! conn -> account . user [ 0 ] ) auth = false ; } else { if ( ( mutt_socket_send ( conn , \"STAT\\\\r\\\\n\" ) < 0 ) || ( mutt_socket_readln ( buf , sizeof ( buf ) , conn ) < 0 ) ) { return nntp_connect_error ( adata ) ; } if ( ! mutt_str_startswith ( buf , \"480\" , CASE_MATCH ) ) auth = false ; } if ( auth && ( nntp_auth ( adata ) < 0 ) ) return - 1 ; if ( adata -> hasCAPABILITIES && ( auth || ( cap > 0 ) ) ) { cap = nntp_capabilities ( adata ) ; if ( cap < 0 ) return - 1 ; if ( cap > 0 ) { mutt_socket_close ( conn ) ; mutt_error ( _ ( \"Could<S2SV_blank>not<S2SV_blank>switch<S2SV_blank>to<S2SV_blank>reader<S2SV_blank>mode\" ) ) ; return - 1 ; } } if ( nntp_attempt_features ( adata ) < 0 ) return - 1 ; adata -> status = NNTP_OK ; return 0 ; }\n",
      "fixed_code": "<S2SV_ModStart> ) ; } mutt_socket_empty ( conn ) ;\n",
      "source_code_length": 3436,
      "target_code_length": 51,
      "vulnerability_patterns": {
        "null_pointer": 5,
        "total": 5
      },
      "total_patterns": 5,
      "original_address": "https://github.com/neomutt/neomutt/commit/fb013ec666759cb8a9e294347c7b4c1f597639cc",
      "discovery_time": "2020-06-21T17:15Z",
      "project_commit_id": "neomutt@neomutt/fb013ec666759cb8a9e294347c7b4c1f597639cc",
      "extraction_time": "2025-08-31T15:41:49.182141",
      "label": 1,
      "vulnerability_type": "command_injection",
      "difficulty_level": "advanced",
      "risk_factors": [
        "command_injection",
        "arbitrary_code_execution",
        "critical_infrastructure",
        "remote_code_execution"
      ],
      "attack_vectors": [
        "command_injection",
        "system_commands",
        "code_analysis",
        "reverse_engineering",
        "fuzzing",
        "user_input"
      ],
      "mitigation_strategies": [
        "fuzzing",
        "dynamic_analysis",
        "command_whitelisting",
        "static_analysis",
        "secure_coding_practices",
        "privilege_separation",
        "input_sanitization",
        "code_review",
        "input_validation"
      ],
      "code_differences": {
        "has_differences": true,
        "source_lines": 2,
        "target_lines": 2,
        "character_differences": 3385,
        "similarity_percentage": 4.901960784313726
      },
      "vulnerability_location": {
        "vulnerability_present": true,
        "fix_applied": true,
        "code_changed": true,
        "estimated_lines_changed": 0
      }
    },
    {
      "cve_id": "CVE-2019-9278",
      "cwe_id": "CWE-787",
      "cwe_name": "Out-of-bounds Write",
      "project": "libexif",
      "severity": "critical",
      "weaponization_score": 8.5,
      "is_critical": true,
      "is_weaponizable": true,
      "is_high_priority_project": false,
      "vulnerable_code": "CWE-787 static int exif_data_load_data_entry ( ExifData * data , ExifEntry * entry , const unsigned char * d , unsigned int size , unsigned int offset ) { unsigned int s , doff ; entry -> tag = exif_get_short ( d + offset + 0 , data -> priv -> order ) ; entry -> format = exif_get_short ( d + offset + 2 , data -> priv -> order ) ; entry -> components = exif_get_long ( d + offset + 4 , data -> priv -> order ) ; exif_log ( data -> priv -> log , EXIF_LOG_CODE_DEBUG , \"ExifData\" , \"Loading<S2SV_blank>entry<S2SV_blank>0x%x<S2SV_blank>(\\'%s\\')...\" , entry -> tag , exif_tag_get_name ( entry -> tag ) ) ; s = exif_format_get_size ( entry -> format ) * entry -> components ; if ( ( s < entry -> components ) || ( s == 0 ) ) { return 0 ; } if ( s > 4 ) doff = exif_get_long ( d + offset + 8 , data -> priv -> order ) ; else doff = offset + 8 ; <S2SV_StartBug> if ( ( doff + s < doff ) || ( doff + s < s ) || ( doff + s > size ) ) { <S2SV_EndBug> exif_log ( data -> priv -> log , EXIF_LOG_CODE_DEBUG , \"ExifData\" , <S2SV_StartBug> \"Tag<S2SV_blank>data<S2SV_blank>past<S2SV_blank>end<S2SV_blank>of<S2SV_blank>buffer<S2SV_blank>(%u<S2SV_blank>><S2SV_blank>%u)\" , doff + s , size ) ; <S2SV_EndBug> return 0 ; } entry -> data = exif_data_alloc ( data , s ) ; if ( entry -> data ) { entry -> size = s ; memcpy ( entry -> data , d + doff , s ) ; } else { EXIF_LOG_NO_MEMORY ( data -> priv -> log , \"ExifData\" , s ) ; return 0 ; } if ( entry -> tag == EXIF_TAG_MAKER_NOTE ) { if ( ! entry -> data ) { exif_log ( data -> priv -> log , EXIF_LOG_CODE_DEBUG , \"ExifData\" , \"MakerNote<S2SV_blank>found<S2SV_blank>with<S2SV_blank>empty<S2SV_blank>data\" ) ; } else if ( entry -> size > 6 ) { exif_log ( data -> priv -> log , EXIF_LOG_CODE_DEBUG , \"ExifData\" , \"MakerNote<S2SV_blank>found<S2SV_blank>(%02x<S2SV_blank>%02x<S2SV_blank>%02x<S2SV_blank>%02x<S2SV_blank>\" \"%02x<S2SV_blank>%02x<S2SV_blank>%02x...).\" , entry -> data [ 0 ] , entry -> data [ 1 ] , entry -> data [ 2 ] , entry -> data [ 3 ] , entry -> data [ 4 ] , entry -> data [ 5 ] , entry -> data [ 6 ] ) ; } data -> priv -> offset_mnote = doff ; } return 1 ; }\n",
      "fixed_code": "<S2SV_ModStart> ; if ( doff >= size ) { exif_log ( data -> priv -> log , EXIF_LOG_CODE_DEBUG , \"ExifData\" , \"Tag<S2SV_blank>starts<S2SV_blank>past<S2SV_blank>end<S2SV_blank>of<S2SV_blank>buffer<S2SV_blank>(%u<S2SV_blank>><S2SV_blank>%u)\" , doff , size ) ; return 0 ; } if ( <S2SV_ModEnd> s > size <S2SV_ModStart> s > size - doff <S2SV_ModEnd> ) { exif_log <S2SV_ModStart> , \"ExifData\" , \"Tag<S2SV_blank>data<S2SV_blank>goes<S2SV_blank>past<S2SV_blank>end<S2SV_blank>of<S2SV_blank>buffer<S2SV_blank>(%u<S2SV_blank>><S2SV_blank>%u)\" <S2SV_ModEnd> , doff +\n",
      "source_code_length": 2104,
      "target_code_length": 554,
      "vulnerability_patterns": {
        "buffer_overflow": 1,
        "null_pointer": 42,
        "total": 43
      },
      "total_patterns": 43,
      "original_address": "https://github.com/libexif/libexif/commit/75aa73267fdb1e0ebfbc00369e7312bac43d0566",
      "discovery_time": "2019-09-27T19:15Z",
      "project_commit_id": "libexif@libexif/75aa73267fdb1e0ebfbc00369e7312bac43d0566",
      "extraction_time": "2025-08-31T15:41:49.182179",
      "label": 1,
      "vulnerability_type": "out-of-bounds_write",
      "difficulty_level": "advanced",
      "risk_factors": [
        "system_crash",
        "memory_corruption",
        "buffer_overflow",
        "arbitrary_code_execution"
      ],
      "attack_vectors": [
        "memory_manipulation",
        "malicious_input",
        "code_analysis",
        "buffer_overflow",
        "reverse_engineering",
        "fuzzing"
      ],
      "mitigation_strategies": [
        "safe_string_functions",
        "dynamic_analysis",
        "code_review",
        "static_analysis",
        "memory_safety_checks",
        "input_validation",
        "fuzzing",
        "bounds_checking",
        "secure_coding_practices"
      ],
      "code_differences": {
        "has_differences": true,
        "source_lines": 2,
        "target_lines": 2,
        "character_differences": 1550,
        "similarity_percentage": 28.000000000000004
      },
      "vulnerability_location": {
        "vulnerability_present": true,
        "fix_applied": true,
        "code_changed": true,
        "estimated_lines_changed": 0
      }
    },
    {
      "cve_id": "CVE-2012-5532",
      "cwe_id": "CWE-000",
      "cwe_name": "Unknown/Uncategorized",
      "project": "torvalds",
      "severity": "critical",
      "weaponization_score": 8.5,
      "is_critical": true,
      "is_weaponizable": true,
      "is_high_priority_project": false,
      "vulnerable_code": "CWE-000 int main ( void ) { int fd , len , sock_opt ; int error ; struct cn_msg * message ; struct pollfd pfd ; struct nlmsghdr * incoming_msg ; struct cn_msg * incoming_cn_msg ; struct hv_kvp_msg * hv_msg ; char * p ; char * key_value ; char * key_name ; int op ; int pool ; char * if_name ; struct hv_kvp_ipaddr_value * kvp_ip_val ; daemon ( 1 , 0 ) ; openlog ( \"KVP\" , 0 , LOG_USER ) ; syslog ( LOG_INFO , \"KVP<S2SV_blank>starting;<S2SV_blank>pid<S2SV_blank>is:%d\" , getpid ( ) ) ; kvp_get_os_info ( ) ; if ( kvp_file_init ( ) ) { syslog ( LOG_ERR , \"Failed<S2SV_blank>to<S2SV_blank>initialize<S2SV_blank>the<S2SV_blank>pools\" ) ; exit ( EXIT_FAILURE ) ; } fd = socket ( AF_NETLINK , SOCK_DGRAM , NETLINK_CONNECTOR ) ; if ( fd < 0 ) { syslog ( LOG_ERR , \"netlink<S2SV_blank>socket<S2SV_blank>creation<S2SV_blank>failed;<S2SV_blank>error:%d\" , fd ) ; exit ( EXIT_FAILURE ) ; } addr . nl_family = AF_NETLINK ; addr . nl_pad = 0 ; addr . nl_pid = 0 ; addr . nl_groups = CN_KVP_IDX ; error = bind ( fd , ( struct sockaddr * ) & addr , sizeof ( addr ) ) ; if ( error < 0 ) { syslog ( LOG_ERR , \"bind<S2SV_blank>failed;<S2SV_blank>error:%d\" , error ) ; close ( fd ) ; exit ( EXIT_FAILURE ) ; } sock_opt = addr . nl_groups ; setsockopt ( fd , 270 , 1 , & sock_opt , sizeof ( sock_opt ) ) ; message = ( struct cn_msg * ) kvp_send_buffer ; message -> id . idx = CN_KVP_IDX ; message -> id . val = CN_KVP_VAL ; hv_msg = ( struct hv_kvp_msg * ) message -> data ; hv_msg -> kvp_hdr . operation = KVP_OP_REGISTER1 ; message -> ack = 0 ; message -> len = sizeof ( struct hv_kvp_msg ) ; len = netlink_send ( fd , message ) ; if ( len < 0 ) { syslog ( LOG_ERR , \"netlink_send<S2SV_blank>failed;<S2SV_blank>error:%d\" , len ) ; close ( fd ) ; exit ( EXIT_FAILURE ) ; } pfd . fd = fd ; while ( 1 ) { struct sockaddr * addr_p = ( struct sockaddr * ) & addr ; socklen_t addr_l = sizeof ( addr ) ; pfd . events = POLLIN ; pfd . revents = 0 ; poll ( & pfd , 1 , - 1 ) ; len = recvfrom ( fd , kvp_recv_buffer , sizeof ( kvp_recv_buffer ) , 0 , addr_p , & addr_l ) ; <S2SV_StartBug> if ( len < 0 || addr . nl_pid ) { <S2SV_EndBug> syslog ( LOG_ERR , \"recvfrom<S2SV_blank>failed;<S2SV_blank>pid:%u<S2SV_blank>error:%d<S2SV_blank>%s\" , addr . nl_pid , errno , strerror ( errno ) ) ; close ( fd ) ; return - 1 ; } <S2SV_StartBug> incoming_msg = ( struct nlmsghdr * ) kvp_recv_buffer ; <S2SV_EndBug> incoming_cn_msg = ( struct cn_msg * ) NLMSG_DATA ( incoming_msg ) ; hv_msg = ( struct hv_kvp_msg * ) incoming_cn_msg -> data ; op = hv_msg -> kvp_hdr . operation ; pool = hv_msg -> kvp_hdr . pool ; hv_msg -> error = HV_S_OK ; if ( ( in_hand_shake ) && ( op == KVP_OP_REGISTER1 ) ) { in_hand_shake = 0 ; p = ( char * ) hv_msg -> body . kvp_register . version ; lic_version = malloc ( strlen ( p ) + 1 ) ; if ( lic_version ) { strcpy ( lic_version , p ) ; syslog ( LOG_INFO , \"KVP<S2SV_blank>LIC<S2SV_blank>Version:<S2SV_blank>%s\" , lic_version ) ; } else { syslog ( LOG_ERR , \"malloc<S2SV_blank>failed\" ) ; } continue ; } switch ( op ) { case KVP_OP_GET_IP_INFO : kvp_ip_val = & hv_msg -> body . kvp_ip_val ; if_name = kvp_mac_to_if_name ( ( char * ) kvp_ip_val -> adapter_id ) ; if ( if_name == NULL ) { hv_msg -> error = HV_E_FAIL ; break ; } error = kvp_get_ip_info ( 0 , if_name , KVP_OP_GET_IP_INFO , kvp_ip_val , ( MAX_IP_ADDR_SIZE * 2 ) ) ; if ( error ) hv_msg -> error = error ; free ( if_name ) ; break ; case KVP_OP_SET_IP_INFO : kvp_ip_val = & hv_msg -> body . kvp_ip_val ; if_name = kvp_get_if_name ( ( char * ) kvp_ip_val -> adapter_id ) ; if ( if_name == NULL ) { hv_msg -> error = HV_GUID_NOTFOUND ; break ; } error = kvp_set_ip_info ( if_name , kvp_ip_val ) ; if ( error ) hv_msg -> error = error ; free ( if_name ) ; break ; case KVP_OP_SET : if ( kvp_key_add_or_modify ( pool , hv_msg -> body . kvp_set . data . key , hv_msg -> body . kvp_set . data . key_size , hv_msg -> body . kvp_set . data . value , hv_msg -> body . kvp_set . data . value_size ) ) hv_msg -> error = HV_S_CONT ; break ; case KVP_OP_GET : if ( kvp_get_value ( pool , hv_msg -> body . kvp_set . data . key , hv_msg -> body . kvp_set . data . key_size , hv_msg -> body . kvp_set . data . value , hv_msg -> body . kvp_set . data . value_size ) ) hv_msg -> error = HV_S_CONT ; break ; case KVP_OP_DELETE : if ( kvp_key_delete ( pool , hv_msg -> body . kvp_delete . key , hv_msg -> body . kvp_delete . key_size ) ) hv_msg -> error = HV_S_CONT ; break ; default : break ; } if ( op != KVP_OP_ENUMERATE ) goto kvp_done ; if ( pool != KVP_POOL_AUTO ) { if ( kvp_pool_enumerate ( pool , hv_msg -> body . kvp_enum_data . index , hv_msg -> body . kvp_enum_data . data . key , HV_KVP_EXCHANGE_MAX_KEY_SIZE , hv_msg -> body . kvp_enum_data . data . value , HV_KVP_EXCHANGE_MAX_VALUE_SIZE ) ) hv_msg -> error = HV_S_CONT ; goto kvp_done ; } hv_msg = ( struct hv_kvp_msg * ) incoming_cn_msg -> data ; key_name = ( char * ) hv_msg -> body . kvp_enum_data . data . key ; key_value = ( char * ) hv_msg -> body . kvp_enum_data . data . value ; switch ( hv_msg -> body . kvp_enum_data . index ) { case FullyQualifiedDomainName : kvp_get_domain_name ( key_value , HV_KVP_EXCHANGE_MAX_VALUE_SIZE ) ; strcpy ( key_name , \"FullyQualifiedDomainName\" ) ; break ; case IntegrationServicesVersion : strcpy ( key_name , \"IntegrationServicesVersion\" ) ; strcpy ( key_value , lic_version ) ; break ; case NetworkAddressIPv4 : kvp_get_ip_info ( AF_INET , NULL , KVP_OP_ENUMERATE , key_value , HV_KVP_EXCHANGE_MAX_VALUE_SIZE ) ; strcpy ( key_name , \"NetworkAddressIPv4\" ) ; break ; case NetworkAddressIPv6 : kvp_get_ip_info ( AF_INET6 , NULL , KVP_OP_ENUMERATE , key_value , HV_KVP_EXCHANGE_MAX_VALUE_SIZE ) ; strcpy ( key_name , \"NetworkAddressIPv6\" ) ; break ; case OSBuildNumber : strcpy ( key_value , os_build ) ; strcpy ( key_name , \"OSBuildNumber\" ) ; break ; case OSName : strcpy ( key_value , os_name ) ; strcpy ( key_name , \"OSName\" ) ; break ; case OSMajorVersion : strcpy ( key_value , os_major ) ; strcpy ( key_name , \"OSMajorVersion\" ) ; break ; case OSMinorVersion : strcpy ( key_value , os_minor ) ; strcpy ( key_name , \"OSMinorVersion\" ) ; break ; case OSVersion : strcpy ( key_value , os_version ) ; strcpy ( key_name , \"OSVersion\" ) ; break ; case ProcessorArchitecture : strcpy ( key_value , processor_arch ) ; strcpy ( key_name , \"ProcessorArchitecture\" ) ; break ; default : hv_msg -> error = HV_S_CONT ; break ; } kvp_done : incoming_cn_msg -> id . idx = CN_KVP_IDX ; incoming_cn_msg -> id . val = CN_KVP_VAL ; incoming_cn_msg -> ack = 0 ; incoming_cn_msg -> len = sizeof ( struct hv_kvp_msg ) ; len = netlink_send ( fd , incoming_cn_msg ) ; if ( len < 0 ) { syslog ( LOG_ERR , \"net_link<S2SV_blank>send<S2SV_blank>failed;<S2SV_blank>error:%d\" , len ) ; exit ( EXIT_FAILURE ) ; } } }\n",
      "fixed_code": "<S2SV_ModStart> len < 0 <S2SV_ModEnd> ) { syslog <S2SV_ModStart> 1 ; } if ( addr . nl_pid ) { syslog ( LOG_WARNING , \"Received<S2SV_blank>packet<S2SV_blank>from<S2SV_blank>untrusted<S2SV_blank>pid:%u\" , addr . nl_pid ) ; continue ; }\n",
      "source_code_length": 6735,
      "target_code_length": 234,
      "vulnerability_patterns": {
        "buffer_overflow": 18,
        "use_after_free": 3,
        "null_pointer": 47,
        "memory_leak": 1,
        "total": 69
      },
      "total_patterns": 69,
      "original_address": "https://github.com/torvalds/linux/commit/95a69adab9acfc3981c504737a2b6578e4d846ef",
      "discovery_time": "2012-12-27T11:47Z",
      "project_commit_id": "torvalds@linux/95a69adab9acfc3981c504737a2b6578e4d846ef",
      "extraction_time": "2025-08-31T15:41:49.182211",
      "label": 1,
      "vulnerability_type": "unknown/uncategorized",
      "difficulty_level": "advanced",
      "risk_factors": [
        "buffer_overflow",
        "use_after_free"
      ],
      "attack_vectors": [
        "fuzzing",
        "code_analysis",
        "reverse_engineering"
      ],
      "mitigation_strategies": [
        "dynamic_analysis",
        "static_analysis",
        "fuzzing",
        "code_review",
        "secure_coding_practices"
      ],
      "code_differences": {
        "has_differences": true,
        "source_lines": 2,
        "target_lines": 2,
        "character_differences": 6501,
        "similarity_percentage": 8.16326530612245
      },
      "vulnerability_location": {
        "vulnerability_present": true,
        "fix_applied": true,
        "code_changed": true,
        "estimated_lines_changed": 0
      }
    },
    {
      "cve_id": "CVE-2016-1621",
      "cwe_id": "CWE-119",
      "cwe_name": "Buffer Overflow",
      "project": "external",
      "severity": "critical",
      "weaponization_score": 8.5,
      "is_critical": true,
      "is_weaponizable": true,
      "is_high_priority_project": false,
      "vulnerable_code": "CWE-119 int main ( int argc , char * * argv ) { int frame_cnt = 0 ; FILE * outfile = NULL ; vpx_codec_ctx_t codec ; const VpxInterface * decoder = NULL ; VpxVideoReader * reader = NULL ; const VpxVideoInfo * info = NULL ; int n = 0 ; int m = 0 ; int is_range = 0 ; char * nptr = NULL ; exec_name = argv [ 0 ] ; if ( argc != 4 ) die ( \"Invalid<S2SV_blank>number<S2SV_blank>of<S2SV_blank>arguments.\" ) ; reader = vpx_video_reader_open ( argv [ 1 ] ) ; if ( ! reader ) die ( \"Failed<S2SV_blank>to<S2SV_blank>open<S2SV_blank>%s<S2SV_blank>for<S2SV_blank>reading.\" , argv [ 1 ] ) ; if ( ! ( outfile = fopen ( argv [ 2 ] , \"wb\" ) ) ) die ( \"Failed<S2SV_blank>to<S2SV_blank>open<S2SV_blank>%s<S2SV_blank>for<S2SV_blank>writing.\" , argv [ 2 ] ) ; n = strtol ( argv [ 3 ] , & nptr , 0 ) ; m = strtol ( nptr + 1 , NULL , 0 ) ; is_range = ( * nptr == '-' ) ; if ( ! n || ! m || ( * nptr != '-' && * nptr != '/' ) ) die ( \"Couldn\\'t<S2SV_blank>parse<S2SV_blank>pattern<S2SV_blank>%s.\\\\n\" , argv [ 3 ] ) ; info = vpx_video_reader_get_info ( reader ) ; decoder = get_vpx_decoder_by_fourcc ( info -> codec_fourcc ) ; if ( ! decoder ) die ( \"Unknown<S2SV_blank>input<S2SV_blank>codec.\" ) ; <S2SV_StartBug> printf ( \"Using<S2SV_blank>%s\\\\n\" , vpx_codec_iface_name ( decoder -> interface ( ) ) ) ; <S2SV_EndBug> <S2SV_StartBug> if ( vpx_codec_dec_init ( & codec , decoder -> interface ( ) , NULL , 0 ) ) <S2SV_EndBug> die_codec ( & codec , \"Failed<S2SV_blank>to<S2SV_blank>initialize<S2SV_blank>decoder.\" ) ; while ( vpx_video_reader_read_frame ( reader ) ) { vpx_codec_iter_t iter = NULL ; vpx_image_t * img = NULL ; size_t frame_size = 0 ; int skip ; const unsigned char * frame = vpx_video_reader_get_frame ( reader , & frame_size ) ; if ( vpx_codec_decode ( & codec , frame , ( unsigned int ) frame_size , NULL , 0 ) ) die_codec ( & codec , \"Failed<S2SV_blank>to<S2SV_blank>decode<S2SV_blank>frame.\" ) ; ++ frame_cnt ; skip = ( is_range && frame_cnt >= n && frame_cnt <= m ) || ( ! is_range && m - ( frame_cnt - 1 ) % m <= n ) ; if ( ! skip ) { putc ( '.' , stdout ) ; while ( ( img = vpx_codec_get_frame ( & codec , & iter ) ) != NULL ) vpx_img_write ( img , outfile ) ; } else { putc ( 'X' , stdout ) ; } fflush ( stdout ) ; } printf ( \"Processed<S2SV_blank>%d<S2SV_blank>frames.\\\\n\" , frame_cnt ) ; if ( vpx_codec_destroy ( & codec ) ) die_codec ( & codec , \"Failed<S2SV_blank>to<S2SV_blank>destroy<S2SV_blank>codec.\" ) ; printf ( \"Play:<S2SV_blank>ffplay<S2SV_blank>-f<S2SV_blank>rawvideo<S2SV_blank>-pix_fmt<S2SV_blank>yuv420p<S2SV_blank>-s<S2SV_blank>%dx%d<S2SV_blank>%s\\\\n\" , info -> frame_width , info -> frame_height , argv [ 2 ] ) ; vpx_video_reader_close ( reader ) ; fclose ( outfile ) ; return EXIT_SUCCESS ; }\n",
      "fixed_code": "<S2SV_ModStart> ( decoder -> codec_interface <S2SV_ModEnd> ( ) ) <S2SV_ModStart> , decoder -> codec_interface <S2SV_ModEnd> ( ) ,\n",
      "source_code_length": 2710,
      "target_code_length": 130,
      "vulnerability_patterns": {
        "buffer_overflow": 4,
        "null_pointer": 21,
        "total": 25
      },
      "total_patterns": 25,
      "original_address": "https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426",
      "discovery_time": "2016-03-12T21:59Z",
      "project_commit_id": "external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426",
      "extraction_time": "2025-08-31T15:41:49.182265",
      "label": 1,
      "vulnerability_type": "buffer_overflow",
      "difficulty_level": "advanced",
      "risk_factors": [
        "system_crash",
        "memory_corruption",
        "buffer_overflow",
        "arbitrary_code_execution"
      ],
      "attack_vectors": [
        "memory_manipulation",
        "malicious_input",
        "code_analysis",
        "buffer_overflow",
        "reverse_engineering",
        "fuzzing"
      ],
      "mitigation_strategies": [
        "safe_string_functions",
        "dynamic_analysis",
        "code_review",
        "static_analysis",
        "memory_safety_checks",
        "input_validation",
        "fuzzing",
        "bounds_checking",
        "secure_coding_practices"
      ],
      "code_differences": {
        "has_differences": true,
        "source_lines": 2,
        "target_lines": 2,
        "character_differences": 2580,
        "similarity_percentage": 4.464285714285714
      },
      "vulnerability_location": {
        "vulnerability_present": true,
        "fix_applied": true,
        "code_changed": true,
        "estimated_lines_changed": 0
      }
    },
    {
      "cve_id": "CVE-2016-2507",
      "cwe_id": "CWE-119",
      "cwe_name": "Buffer Overflow",
      "project": "frameworks",
      "severity": "critical",
      "weaponization_score": 8.5,
      "is_critical": true,
      "is_weaponizable": true,
      "is_high_priority_project": false,
      "vulnerable_code": "CWE-119 u32 h264bsdActivateParamSets ( storage_t * pStorage , u32 ppsId , u32 isIdr ) { u32 tmp ; u32 flag ; ASSERT ( pStorage ) ; ASSERT ( ppsId < MAX_NUM_PIC_PARAM_SETS ) ; if ( ( pStorage -> pps [ ppsId ] == NULL ) || ( pStorage -> sps [ pStorage -> pps [ ppsId ] -> seqParameterSetId ] == NULL ) ) { return ( HANTRO_NOK ) ; } tmp = CheckPps ( pStorage -> pps [ ppsId ] , pStorage -> sps [ pStorage -> pps [ ppsId ] -> seqParameterSetId ] ) ; if ( tmp != HANTRO_OK ) return ( tmp ) ; if ( pStorage -> activePpsId == MAX_NUM_PIC_PARAM_SETS ) { pStorage -> activePpsId = ppsId ; pStorage -> activePps = pStorage -> pps [ ppsId ] ; pStorage -> activeSpsId = pStorage -> activePps -> seqParameterSetId ; pStorage -> activeSps = pStorage -> sps [ pStorage -> activeSpsId ] ; <S2SV_StartBug> pStorage -> picSizeInMbs = <S2SV_EndBug> pStorage -> activeSps -> picWidthInMbs * <S2SV_StartBug> pStorage -> activeSps -> picHeightInMbs ; <S2SV_EndBug> pStorage -> currImage -> width = pStorage -> activeSps -> picWidthInMbs ; pStorage -> currImage -> height = pStorage -> activeSps -> picHeightInMbs ; pStorage -> pendingActivation = HANTRO_TRUE ; } else if ( pStorage -> pendingActivation ) { pStorage -> pendingActivation = HANTRO_FALSE ; FREE ( pStorage -> mb ) ; FREE ( pStorage -> sliceGroupMap ) ; ALLOCATE ( pStorage -> mb , pStorage -> picSizeInMbs , mbStorage_t ) ; ALLOCATE ( pStorage -> sliceGroupMap , pStorage -> picSizeInMbs , u32 ) ; if ( pStorage -> mb == NULL || pStorage -> sliceGroupMap == NULL ) return ( MEMORY_ALLOCATION_ERROR ) ; H264SwDecMemset ( pStorage -> mb , 0 , pStorage -> picSizeInMbs * sizeof ( mbStorage_t ) ) ; h264bsdInitMbNeighbours ( pStorage -> mb , pStorage -> activeSps -> picWidthInMbs , pStorage -> picSizeInMbs ) ; if ( pStorage -> noReordering || pStorage -> activeSps -> picOrderCntType == 2 || ( pStorage -> activeSps -> vuiParametersPresentFlag && pStorage -> activeSps -> vuiParameters -> bitstreamRestrictionFlag && ! pStorage -> activeSps -> vuiParameters -> numReorderFrames ) ) flag = HANTRO_TRUE ; else flag = HANTRO_FALSE ; tmp = h264bsdResetDpb ( pStorage -> dpb , pStorage -> activeSps -> picWidthInMbs * pStorage -> activeSps -> picHeightInMbs , pStorage -> activeSps -> maxDpbSize , pStorage -> activeSps -> numRefFrames , pStorage -> activeSps -> maxFrameNum , flag ) ; if ( tmp != HANTRO_OK ) return ( tmp ) ; } else if ( ppsId != pStorage -> activePpsId ) { if ( pStorage -> pps [ ppsId ] -> seqParameterSetId != pStorage -> activeSpsId ) { DEBUG ( ( \"SEQ<S2SV_blank>PARAM<S2SV_blank>SET<S2SV_blank>CHANGING...\\\\n\" ) ) ; if ( isIdr ) { pStorage -> activePpsId = ppsId ; pStorage -> activePps = pStorage -> pps [ ppsId ] ; pStorage -> activeSpsId = pStorage -> activePps -> seqParameterSetId ; pStorage -> activeSps = pStorage -> sps [ pStorage -> activeSpsId ] ; pStorage -> picSizeInMbs = pStorage -> activeSps -> picWidthInMbs * pStorage -> activeSps -> picHeightInMbs ; pStorage -> currImage -> width = pStorage -> activeSps -> picWidthInMbs ; pStorage -> currImage -> height = pStorage -> activeSps -> picHeightInMbs ; pStorage -> pendingActivation = HANTRO_TRUE ; } else { DEBUG ( ( \"TRYING<S2SV_blank>TO<S2SV_blank>CHANGE<S2SV_blank>SPS<S2SV_blank>IN<S2SV_blank>NON-IDR<S2SV_blank>SLICE\\\\n\" ) ) ; return ( HANTRO_NOK ) ; } } else { pStorage -> activePpsId = ppsId ; pStorage -> activePps = pStorage -> pps [ ppsId ] ; } } return ( HANTRO_OK ) ; }\n",
      "fixed_code": "<S2SV_ModStart> activeSpsId ] ; if ( pStorage -> activeSps -> picWidthInMbs == 0 ) { pStorage -> picSizeInMbs = 0 ; } else if ( pStorage -> activeSps -> picHeightInMbs > UINT32_MAX / pStorage -> activeSps -> picWidthInMbs ) { return ( MEMORY_ALLOCATION_ERROR ) ; } else { <S2SV_ModStart> -> picHeightInMbs ; }\n",
      "source_code_length": 3406,
      "target_code_length": 310,
      "vulnerability_patterns": {
        "use_after_free": 2,
        "null_pointer": 100,
        "total": 102
      },
      "total_patterns": 102,
      "original_address": "https://android.googlesource.com/platform/frameworks/av/+/60547808ca4e9cfac50028c00c58a6ceb2319301",
      "discovery_time": "2016-07-11T01:59Z",
      "project_commit_id": "frameworks@av/60547808ca4e9cfac50028c00c58a6ceb2319301",
      "extraction_time": "2025-08-31T15:41:49.182294",
      "label": 1,
      "vulnerability_type": "buffer_overflow",
      "difficulty_level": "advanced",
      "risk_factors": [
        "system_crash",
        "memory_corruption",
        "arbitrary_code_execution",
        "use_after_free"
      ],
      "attack_vectors": [
        "memory_manipulation",
        "malicious_input",
        "code_analysis",
        "buffer_overflow",
        "reverse_engineering",
        "fuzzing"
      ],
      "mitigation_strategies": [
        "safe_string_functions",
        "dynamic_analysis",
        "code_review",
        "static_analysis",
        "memory_safety_checks",
        "input_validation",
        "fuzzing",
        "bounds_checking",
        "secure_coding_practices"
      ],
      "code_differences": {
        "has_differences": true,
        "source_lines": 2,
        "target_lines": 2,
        "character_differences": 3096,
        "similarity_percentage": 24.390243902439025
      },
      "vulnerability_location": {
        "vulnerability_present": true,
        "fix_applied": true,
        "code_changed": true,
        "estimated_lines_changed": 0
      }
    },
    {
      "cve_id": "CVE-2016-7515",
      "cwe_id": "CWE-125",
      "cwe_name": "Out-of-bounds Read",
      "project": "ImageMagick",
      "severity": "critical",
      "weaponization_score": 8.5,
      "is_critical": true,
      "is_weaponizable": true,
      "is_high_priority_project": true,
      "vulnerable_code": "CWE-125 static Image * ReadRLEImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { # define SkipLinesOp 0x01 # define SetColorOp 0x02 # define SkipPixelsOp 0x03 # define ByteDataOp 0x05 # define RunDataOp 0x06 # define EOFOp 0x07 char magick [ 12 ] ; Image * image ; int opcode , operand , status ; MagickStatusType flags ; MagickSizeType number_pixels ; MemoryInfo * pixel_info ; Quantum index ; register ssize_t x ; register Quantum * q ; register ssize_t i ; register unsigned char * p ; size_t bits_per_pixel , map_length , number_colormaps , <S2SV_StartBug> number_planes , <S2SV_EndBug> one , offset , pixel_info_length ; ssize_t count , y ; unsigned char background_color [ 256 ] , * colormap , pixel , plane , * pixels ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickCoreSignature ) ; if ( image_info -> debug != MagickFalse ) ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , \"%s\" , image_info -> filename ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickCoreSignature ) ; image = AcquireImage ( image_info , exception ) ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) return ( DestroyImageList ( image ) ) ; count = ReadBlob ( image , 2 , ( unsigned char * ) magick ) ; if ( ( count != 2 ) || ( memcmp ( magick , \"\\\\122\\\\314\" , 2 ) != 0 ) ) ThrowReaderException ( CorruptImageError , \"ImproperImageHeader\" ) ; do { image -> page . x = ReadBlobLSBShort ( image ) ; image -> page . y = ReadBlobLSBShort ( image ) ; image -> columns = ReadBlobLSBShort ( image ) ; image -> rows = ReadBlobLSBShort ( image ) ; flags = ( MagickStatusType ) ReadBlobByte ( image ) ; image -> alpha_trait = flags & 0x04 ? BlendPixelTrait : UndefinedPixelTrait ; number_planes = ( size_t ) ReadBlobByte ( image ) ; bits_per_pixel = ( size_t ) ReadBlobByte ( image ) ; number_colormaps = ( size_t ) ReadBlobByte ( image ) ; map_length = ( unsigned char ) ReadBlobByte ( image ) ; if ( map_length >= 64 ) ThrowReaderException ( CorruptImageError , \"ImproperImageHeader\" ) ; one = 1 ; map_length = one << map_length ; if ( ( number_planes == 0 ) || ( number_planes == 2 ) || ( bits_per_pixel != 8 ) || ( image -> columns == 0 ) ) ThrowReaderException ( CorruptImageError , \"ImproperImageHeader\" ) ; if ( flags & 0x02 ) { for ( i = 0 ; i < ( ssize_t ) number_planes ; i ++ ) background_color [ i ] = 0 ; ( void ) ReadBlobByte ( image ) ; } else { p = background_color ; for ( i = 0 ; i < ( ssize_t ) number_planes ; i ++ ) * p ++ = ( unsigned char ) ReadBlobByte ( image ) ; } if ( ( number_planes & 0x01 ) == 0 ) ( void ) ReadBlobByte ( image ) ; if ( EOFBlob ( image ) != MagickFalse ) { ThrowFileException ( exception , CorruptImageError , \"UnexpectedEndOfFile\" , image -> filename ) ; break ; } colormap = ( unsigned char * ) NULL ; if ( number_colormaps != 0 ) { colormap = ( unsigned char * ) AcquireQuantumMemory ( number_colormaps , 3 * map_length * sizeof ( * colormap ) ) ; if ( colormap == ( unsigned char * ) NULL ) ThrowReaderException ( ResourceLimitError , \"MemoryAllocationFailed\" ) ; p = colormap ; for ( i = 0 ; i < ( ssize_t ) number_colormaps ; i ++ ) for ( x = 0 ; x < ( ssize_t ) map_length ; x ++ ) * p ++ = ( unsigned char ) ScaleShortToQuantum ( ReadBlobLSBShort ( image ) ) ; } if ( ( flags & 0x08 ) != 0 ) { char * comment ; size_t length ; length = ReadBlobLSBShort ( image ) ; if ( length != 0 ) { comment = ( char * ) AcquireQuantumMemory ( length , sizeof ( * comment ) ) ; if ( comment == ( char * ) NULL ) ThrowReaderException ( ResourceLimitError , \"MemoryAllocationFailed\" ) ; count = ReadBlob ( image , length - 1 , ( unsigned char * ) comment ) ; comment [ length - 1 ] = '\\\\0' ; ( void ) SetImageProperty ( image , \"comment\" , comment , exception ) ; comment = DestroyString ( comment ) ; if ( ( length & 0x01 ) == 0 ) ( void ) ReadBlobByte ( image ) ; } } if ( ( image_info -> ping != MagickFalse ) && ( image_info -> number_scenes != 0 ) ) if ( image -> scene >= ( image_info -> scene + image_info -> number_scenes - 1 ) ) break ; status = SetImageExtent ( image , image -> columns , image -> rows , exception ) ; if ( status == MagickFalse ) return ( DestroyImageList ( image ) ) ; if ( image -> alpha_trait != UndefinedPixelTrait ) number_planes ++ ; number_pixels = ( MagickSizeType ) image -> columns * image -> rows ; <S2SV_StartBug> if ( ( number_pixels * number_planes ) != ( size_t ) ( number_pixels * number_planes ) ) <S2SV_EndBug> ThrowReaderException ( ResourceLimitError , \"MemoryAllocationFailed\" ) ; <S2SV_StartBug> pixel_info_length = image -> columns * image -> rows * MagickMax ( number_planes , 4 ) ; <S2SV_EndBug> pixel_info = AcquireVirtualMemory ( pixel_info_length , sizeof ( * pixels ) ) ; if ( pixel_info == ( MemoryInfo * ) NULL ) ThrowReaderException ( ResourceLimitError , \"MemoryAllocationFailed\" ) ; pixels = ( unsigned char * ) GetVirtualMemoryBlob ( pixel_info ) ; if ( ( flags & 0x01 ) && ! ( flags & 0x02 ) ) { ssize_t j ; p = pixels ; for ( i = 0 ; i < ( ssize_t ) number_pixels ; i ++ ) { if ( image -> alpha_trait == UndefinedPixelTrait ) for ( j = 0 ; j < ( ssize_t ) number_planes ; j ++ ) * p ++ = background_color [ j ] ; else { for ( j = 0 ; j < ( ssize_t ) ( number_planes - 1 ) ; j ++ ) * p ++ = background_color [ j ] ; * p ++ = 0 ; } } } plane = 0 ; x = 0 ; y = 0 ; opcode = ReadBlobByte ( image ) ; do { switch ( opcode & 0x3f ) { case SkipLinesOp : { operand = ReadBlobByte ( image ) ; if ( opcode & 0x40 ) operand = ( int ) ReadBlobLSBShort ( image ) ; x = 0 ; y += operand ; break ; } case SetColorOp : { operand = ReadBlobByte ( image ) ; plane = ( unsigned char ) operand ; if ( plane == 255 ) plane = ( unsigned char ) ( number_planes - 1 ) ; x = 0 ; break ; } case SkipPixelsOp : { operand = ReadBlobByte ( image ) ; if ( opcode & 0x40 ) operand = ( int ) ReadBlobLSBShort ( image ) ; x += operand ; break ; } case ByteDataOp : { operand = ReadBlobByte ( image ) ; if ( opcode & 0x40 ) operand = ( int ) ReadBlobLSBShort ( image ) ; offset = ( ( image -> rows - y - 1 ) * image -> columns * number_planes ) + x * number_planes + plane ; operand ++ ; if ( offset + ( ( size_t ) operand * number_planes ) > pixel_info_length ) { if ( number_colormaps != 0 ) colormap = ( unsigned char * ) RelinquishMagickMemory ( colormap ) ; pixel_info = RelinquishVirtualMemory ( pixel_info ) ; ThrowReaderException ( CorruptImageError , \"UnableToReadImageData\" ) ; } p = pixels + offset ; for ( i = 0 ; i < ( ssize_t ) operand ; i ++ ) { pixel = ( unsigned char ) ReadBlobByte ( image ) ; if ( ( y < ( ssize_t ) image -> rows ) && ( ( x + i ) < ( ssize_t ) image -> columns ) ) * p = pixel ; p += number_planes ; } if ( operand & 0x01 ) ( void ) ReadBlobByte ( image ) ; x += operand ; break ; } case RunDataOp : { operand = ReadBlobByte ( image ) ; if ( opcode & 0x40 ) operand = ( int ) ReadBlobLSBShort ( image ) ; pixel = ( unsigned char ) ReadBlobByte ( image ) ; ( void ) ReadBlobByte ( image ) ; offset = ( ( image -> rows - y - 1 ) * image -> columns * number_planes ) + x * number_planes + plane ; operand ++ ; if ( offset + ( ( size_t ) operand * number_planes ) > pixel_info_length ) { if ( number_colormaps != 0 ) colormap = ( unsigned char * ) RelinquishMagickMemory ( colormap ) ; pixel_info = RelinquishVirtualMemory ( pixel_info ) ; ThrowReaderException ( CorruptImageError , \"UnableToReadImageData\" ) ; } p = pixels + offset ; for ( i = 0 ; i < ( ssize_t ) operand ; i ++ ) { if ( ( y < ( ssize_t ) image -> rows ) && ( ( x + i ) < ( ssize_t ) image -> columns ) ) * p = pixel ; p += number_planes ; } x += operand ; break ; } default : break ; } opcode = ReadBlobByte ( image ) ; } while ( ( ( opcode & 0x3f ) != EOFOp ) && ( opcode != EOF ) ) ; if ( number_colormaps != 0 ) { MagickStatusType mask ; mask = ( MagickStatusType ) ( map_length - 1 ) ; p = pixels ; x = ( ssize_t ) number_planes ; if ( number_colormaps == 1 ) for ( i = 0 ; i < ( ssize_t ) number_pixels ; i ++ ) { if ( IsValidColormapIndex ( image , * p & mask , & index , exception ) == MagickFalse ) break ; * p = colormap [ ( ssize_t ) index ] ; p ++ ; } else if ( ( number_planes >= 3 ) && ( number_colormaps >= 3 ) ) for ( i = 0 ; i < ( ssize_t ) number_pixels ; i ++ ) for ( x = 0 ; x < ( ssize_t ) number_planes ; x ++ ) { if ( IsValidColormapIndex ( image , ( size_t ) ( x * map_length + ( * p & mask ) ) , & index , exception ) == MagickFalse ) break ; * p = colormap [ ( ssize_t ) index ] ; p ++ ; } if ( ( i < ( ssize_t ) number_pixels ) || ( x < ( ssize_t ) number_planes ) ) { colormap = ( unsigned char * ) RelinquishMagickMemory ( colormap ) ; pixel_info = RelinquishVirtualMemory ( pixel_info ) ; ThrowReaderException ( CorruptImageError , \"UnableToReadImageData\" ) ; } } if ( number_planes >= 3 ) { p = pixels ; for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { SetPixelRed ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; SetPixelGreen ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; SetPixelBlue ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; if ( image -> alpha_trait != UndefinedPixelTrait ) SetPixelAlpha ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; q += GetPixelChannels ( image ) ; } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ; if ( status == MagickFalse ) break ; } } } else { if ( number_colormaps == 0 ) map_length = 256 ; if ( AcquireImageColormap ( image , map_length , exception ) == MagickFalse ) ThrowReaderException ( ResourceLimitError , \"MemoryAllocationFailed\" ) ; p = colormap ; if ( number_colormaps == 1 ) for ( i = 0 ; i < ( ssize_t ) image -> colors ; i ++ ) { image -> colormap [ i ] . red = ( MagickRealType ) ScaleCharToQuantum ( ( unsigned char ) i ) ; image -> colormap [ i ] . green = ( MagickRealType ) ScaleCharToQuantum ( ( unsigned char ) i ) ; image -> colormap [ i ] . blue = ( MagickRealType ) ScaleCharToQuantum ( ( unsigned char ) i ) ; } else if ( number_colormaps > 1 ) for ( i = 0 ; i < ( ssize_t ) image -> colors ; i ++ ) { image -> colormap [ i ] . red = ( MagickRealType ) ScaleCharToQuantum ( * p ) ; image -> colormap [ i ] . green = ( MagickRealType ) ScaleCharToQuantum ( * ( p + map_length ) ) ; image -> colormap [ i ] . blue = ( MagickRealType ) ScaleCharToQuantum ( * ( p + map_length * 2 ) ) ; p ++ ; } p = pixels ; if ( image -> alpha_trait == UndefinedPixelTrait ) { for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { SetPixelIndex ( image , * p ++ , q ) ; q += GetPixelChannels ( image ) ; } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ; if ( status == MagickFalse ) break ; } } ( void ) SyncImage ( image , exception ) ; } else { for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { if ( IsValidColormapIndex ( image , ( ssize_t ) * p ++ , & index , exception ) == MagickFalse ) break ; SetPixelRed ( image , ClampToQuantum ( image -> colormap [ ( ssize_t ) index ] . red ) , q ) ; if ( IsValidColormapIndex ( image , ( ssize_t ) * p ++ , & index , exception ) == MagickFalse ) break ; SetPixelGreen ( image , ClampToQuantum ( image -> colormap [ ( ssize_t ) index ] . green ) , q ) ; if ( IsValidColormapIndex ( image , ( ssize_t ) * p ++ , & index , exception ) == MagickFalse ) break ; SetPixelBlue ( image , ClampToQuantum ( image -> colormap [ ( ssize_t ) index ] . blue ) , q ) ; SetPixelAlpha ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; q += GetPixelChannels ( image ) ; } if ( x < ( ssize_t ) image -> columns ) break ; if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ; if ( status == MagickFalse ) break ; } } image -> colormap = ( PixelInfo * ) RelinquishMagickMemory ( image -> colormap ) ; image -> storage_class = DirectClass ; image -> colors = 0 ; } } if ( number_colormaps != 0 ) colormap = ( unsigned char * ) RelinquishMagickMemory ( colormap ) ; pixel_info = RelinquishVirtualMemory ( pixel_info ) ; if ( EOFBlob ( image ) != MagickFalse ) { ThrowFileException ( exception , CorruptImageError , \"UnexpectedEndOfFile\" , image -> filename ) ; break ; } if ( image_info -> number_scenes != 0 ) if ( image -> scene >= ( image_info -> scene + image_info -> number_scenes - 1 ) ) break ; ( void ) ReadBlobByte ( image ) ; count = ReadBlob ( image , 2 , ( unsigned char * ) magick ) ; if ( ( count != 0 ) && ( memcmp ( magick , \"\\\\122\\\\314\" , 2 ) == 0 ) ) { AcquireNextImage ( image_info , image , exception ) ; if ( GetNextImageInList ( image ) == ( Image * ) NULL ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } image = SyncNextImageInList ( image ) ; status = SetImageProgress ( image , LoadImagesTag , TellBlob ( image ) , GetBlobSize ( image ) ) ; if ( status == MagickFalse ) break ; } } while ( ( count != 0 ) && ( memcmp ( magick , \"\\\\122\\\\314\" , 2 ) == 0 ) ) ; ( void ) CloseBlob ( image ) ; return ( GetFirstImageInList ( image ) ) ; }\n",
      "fixed_code": "<S2SV_ModStart> number_colormaps , number_planes , number_planes_filled <S2SV_ModStart> -> rows ; number_planes_filled = ( number_planes % 2 == 0 ) ? number_planes : number_planes + 1 ; <S2SV_ModStart> ( number_pixels * number_planes_filled <S2SV_ModEnd> ) != ( <S2SV_ModStart> ( number_pixels * number_planes_filled <S2SV_ModEnd> ) ) ThrowReaderException <S2SV_ModStart> -> rows * number_planes_filled <S2SV_ModEnd> ; pixel_info =\n",
      "source_code_length": 13833,
      "target_code_length": 432,
      "vulnerability_patterns": {
        "integer_overflow": 49,
        "null_pointer": 70,
        "total": 119
      },
      "total_patterns": 119,
      "original_address": "https://github.com/ImageMagick/ImageMagick/commit/2ad6d33493750a28a5a655d319a8e0b16c392de1",
      "discovery_time": "2017-04-19T14:59Z",
      "project_commit_id": "ImageMagick@ImageMagick/2ad6d33493750a28a5a655d319a8e0b16c392de1",
      "extraction_time": "2025-08-31T15:41:49.182335",
      "label": 1,
      "vulnerability_type": "out-of-bounds_read",
      "difficulty_level": "advanced",
      "risk_factors": [
        "information_disclosure",
        "memory_corruption",
        "integer_overflow",
        "critical_infrastructure"
      ],
      "attack_vectors": [
        "memory_manipulation",
        "malicious_input",
        "code_analysis",
        "buffer_overflow",
        "reverse_engineering",
        "fuzzing"
      ],
      "mitigation_strategies": [
        "safe_string_functions",
        "dynamic_analysis",
        "code_review",
        "static_analysis",
        "memory_safety_checks",
        "input_validation",
        "fuzzing",
        "bounds_checking",
        "secure_coding_practices"
      ],
      "code_differences": {
        "has_differences": true,
        "source_lines": 2,
        "target_lines": 2,
        "character_differences": 13401,
        "similarity_percentage": 10.096153846153847
      },
      "vulnerability_location": {
        "vulnerability_present": true,
        "fix_applied": true,
        "code_changed": true,
        "estimated_lines_changed": 0
      }
    },
    {
      "cve_id": "CVE-2019-19275",
      "cwe_id": "CWE-125",
      "cwe_name": "Out-of-bounds Read",
      "project": "python",
      "severity": "critical",
      "weaponization_score": 8.5,
      "is_critical": true,
      "is_weaponizable": true,
      "is_high_priority_project": true,
      "vulnerable_code": "CWE-125 static arguments_ty ast_for_arguments ( struct compiling * c , const node * n ) { int i , j , k , nposargs = 0 , nkwonlyargs = 0 ; int nposdefaults = 0 , found_default = 0 ; asdl_seq * posargs , * posdefaults , * kwonlyargs , * kwdefaults ; arg_ty vararg = NULL , kwarg = NULL ; arg_ty arg ; node * ch ; if ( TYPE ( n ) == parameters ) { if ( NCH ( n ) == 2 ) return arguments ( NULL , NULL , NULL , NULL , NULL , NULL , c -> c_arena ) ; n = CHILD ( n , 1 ) ; } assert ( TYPE ( n ) == typedargslist || TYPE ( n ) == varargslist ) ; for ( i = 0 ; i < NCH ( n ) ; i ++ ) { ch = CHILD ( n , i ) ; if ( TYPE ( ch ) == STAR ) { i ++ ; if ( i < NCH ( n ) && ( TYPE ( CHILD ( n , i ) ) == tfpdef || TYPE ( CHILD ( n , i ) ) == vfpdef ) ) { i ++ ; } break ; } if ( TYPE ( ch ) == DOUBLESTAR ) break ; if ( TYPE ( ch ) == vfpdef || TYPE ( ch ) == tfpdef ) nposargs ++ ; if ( TYPE ( ch ) == EQUAL ) nposdefaults ++ ; } for ( ; i < NCH ( n ) ; ++ i ) { ch = CHILD ( n , i ) ; if ( TYPE ( ch ) == DOUBLESTAR ) break ; if ( TYPE ( ch ) == tfpdef || TYPE ( ch ) == vfpdef ) nkwonlyargs ++ ; } posargs = ( nposargs ? _Ta3_asdl_seq_new ( nposargs , c -> c_arena ) : NULL ) ; if ( ! posargs && nposargs ) return NULL ; kwonlyargs = ( nkwonlyargs ? _Ta3_asdl_seq_new ( nkwonlyargs , c -> c_arena ) : NULL ) ; if ( ! kwonlyargs && nkwonlyargs ) return NULL ; posdefaults = ( nposdefaults ? _Ta3_asdl_seq_new ( nposdefaults , c -> c_arena ) : NULL ) ; if ( ! posdefaults && nposdefaults ) return NULL ; kwdefaults = ( nkwonlyargs ? _Ta3_asdl_seq_new ( nkwonlyargs , c -> c_arena ) : NULL ) ; if ( ! kwdefaults && nkwonlyargs ) return NULL ; <S2SV_StartBug> if ( nposargs + nkwonlyargs > 255 ) { <S2SV_EndBug> ast_error ( c , n , \"more<S2SV_blank>than<S2SV_blank>255<S2SV_blank>arguments\" ) ; return NULL ; } i = 0 ; j = 0 ; k = 0 ; while ( i < NCH ( n ) ) { ch = CHILD ( n , i ) ; switch ( TYPE ( ch ) ) { case tfpdef : case vfpdef : if ( i + 1 < NCH ( n ) && TYPE ( CHILD ( n , i + 1 ) ) == EQUAL ) { expr_ty expression = ast_for_expr ( c , CHILD ( n , i + 2 ) ) ; if ( ! expression ) return NULL ; assert ( posdefaults != NULL ) ; asdl_seq_SET ( posdefaults , j ++ , expression ) ; i += 2 ; found_default = 1 ; } else if ( found_default ) { ast_error ( c , n , \"non-default<S2SV_blank>argument<S2SV_blank>follows<S2SV_blank>default<S2SV_blank>argument\" ) ; return NULL ; } arg = ast_for_arg ( c , ch ) ; if ( ! arg ) return NULL ; asdl_seq_SET ( posargs , k ++ , arg ) ; i += 1 ; <S2SV_StartBug> if ( i < NCH ( n ) && TYPE ( CHILD ( n , i ) ) == COMMA ) <S2SV_EndBug> i += 1 ; break ; case STAR : if ( i + 1 >= NCH ( n ) || ( i + 2 == NCH ( n ) && ( TYPE ( CHILD ( n , i + 1 ) ) == COMMA || TYPE ( CHILD ( n , i + 1 ) ) == TYPE_COMMENT ) ) ) { ast_error ( c , CHILD ( n , i ) , \"named<S2SV_blank>arguments<S2SV_blank>must<S2SV_blank>follow<S2SV_blank>bare<S2SV_blank>*\" ) ; return NULL ; } ch = CHILD ( n , i + 1 ) ; if ( TYPE ( ch ) == COMMA ) { int res = 0 ; i += 2 ; <S2SV_StartBug> if ( i < NCH ( n ) && TYPE ( CHILD ( n , i ) ) == TYPE_COMMENT ) { <S2SV_EndBug> ast_error ( c , CHILD ( n , i ) , \"bare<S2SV_blank>*<S2SV_blank>has<S2SV_blank>associated<S2SV_blank>type<S2SV_blank>comment\" ) ; return NULL ; } res = handle_keywordonly_args ( c , n , i , kwonlyargs , kwdefaults ) ; if ( res == - 1 ) return NULL ; i = res ; } else { vararg = ast_for_arg ( c , ch ) ; if ( ! vararg ) return NULL ; i += 2 ; <S2SV_StartBug> if ( i < NCH ( n ) && TYPE ( CHILD ( n , i ) ) == COMMA ) <S2SV_EndBug> i += 1 ; <S2SV_StartBug> if ( i < NCH ( n ) && TYPE ( CHILD ( n , i ) ) == TYPE_COMMENT ) { <S2SV_EndBug> vararg -> type_comment = NEW_TYPE_COMMENT ( CHILD ( n , i ) ) ; i += 1 ; } if ( i < NCH ( n ) && ( TYPE ( CHILD ( n , i ) ) == tfpdef || TYPE ( CHILD ( n , i ) ) == vfpdef ) ) { int res = 0 ; res = handle_keywordonly_args ( c , n , i , kwonlyargs , kwdefaults ) ; if ( res == - 1 ) return NULL ; i = res ; } } break ; case DOUBLESTAR : ch = CHILD ( n , i + 1 ) ; assert ( TYPE ( ch ) == tfpdef || TYPE ( ch ) == vfpdef ) ; kwarg = ast_for_arg ( c , ch ) ; if ( ! kwarg ) return NULL ; i += 2 ; <S2SV_StartBug> if ( i < NCH ( n ) && TYPE ( CHILD ( n , i ) ) == COMMA ) <S2SV_EndBug> i += 1 ; break ; case TYPE_COMMENT : assert ( i ) ; if ( kwarg ) arg = kwarg ; arg -> type_comment = NEW_TYPE_COMMENT ( ch ) ; i += 1 ; break ; default : PyErr_Format ( PyExc_SystemError , \"unexpected<S2SV_blank>node<S2SV_blank>in<S2SV_blank>varargslist:<S2SV_blank>%d<S2SV_blank>@<S2SV_blank>%d\" , TYPE ( ch ) , i ) ; return NULL ; } } return arguments ( posargs , vararg , kwonlyargs , kwdefaults , kwarg , posdefaults , c -> c_arena ) ; }\n",
      "fixed_code": "<S2SV_ModStart> return NULL ; <S2SV_ModEnd> i = 0 <S2SV_ModStart> ; if ( <S2SV_ModEnd> TYPE ( CHILD <S2SV_ModStart> ; if ( <S2SV_ModEnd> TYPE ( CHILD <S2SV_ModStart> ; if ( <S2SV_ModEnd> TYPE ( CHILD <S2SV_ModStart> ; if ( <S2SV_ModEnd> TYPE ( CHILD <S2SV_ModStart> ; if ( <S2SV_ModEnd> TYPE ( CHILD\n",
      "source_code_length": 4617,
      "target_code_length": 300,
      "vulnerability_patterns": {
        "null_pointer": 16,
        "total": 16
      },
      "total_patterns": 16,
      "original_address": "https://github.com/python/typed_ast/commit/156afcb26c198e162504a57caddfe0acd9ed7dce",
      "discovery_time": "2019-11-26T15:15Z",
      "project_commit_id": "python@typed_ast/156afcb26c198e162504a57caddfe0acd9ed7dce",
      "extraction_time": "2025-08-31T15:41:49.182436",
      "label": 1,
      "vulnerability_type": "out-of-bounds_read",
      "difficulty_level": "advanced",
      "risk_factors": [
        "information_disclosure",
        "memory_corruption",
        "integer_overflow",
        "critical_infrastructure"
      ],
      "attack_vectors": [
        "memory_manipulation",
        "malicious_input",
        "code_analysis",
        "buffer_overflow",
        "reverse_engineering",
        "fuzzing"
      ],
      "mitigation_strategies": [
        "safe_string_functions",
        "dynamic_analysis",
        "code_review",
        "static_analysis",
        "memory_safety_checks",
        "input_validation",
        "fuzzing",
        "bounds_checking",
        "secure_coding_practices"
      ],
      "code_differences": {
        "has_differences": true,
        "source_lines": 2,
        "target_lines": 2,
        "character_differences": 4317,
        "similarity_percentage": 9.70873786407767
      },
      "vulnerability_location": {
        "vulnerability_present": true,
        "fix_applied": true,
        "code_changed": true,
        "estimated_lines_changed": 0
      }
    },
    {
      "cve_id": "CVE-2012-2745",
      "cwe_id": "CWE-119",
      "cwe_name": "Buffer Overflow",
      "project": "torvalds",
      "severity": "critical",
      "weaponization_score": 8.5,
      "is_critical": true,
      "is_weaponizable": true,
      "is_high_priority_project": false,
      "vulnerable_code": "CWE-119 int copy_creds ( struct task_struct * p , unsigned long clone_flags ) { # ifdef CONFIG_KEYS struct thread_group_cred * tgcred ; # endif struct cred * new ; int ret ; <S2SV_StartBug> if ( <S2SV_EndBug> # ifdef CONFIG_KEYS ! p -> cred -> thread_keyring && # endif clone_flags & CLONE_THREAD ) { p -> real_cred = get_cred ( p -> cred ) ; get_cred ( p -> cred ) ; alter_cred_subscribers ( p -> cred , 2 ) ; kdebug ( \"share_creds(%p{%d,%d})\" , p -> cred , atomic_read ( & p -> cred -> usage ) , read_cred_subscribers ( p -> cred ) ) ; atomic_inc ( & p -> cred -> user -> processes ) ; return 0 ; } new = prepare_creds ( ) ; if ( ! new ) return - ENOMEM ; if ( clone_flags & CLONE_NEWUSER ) { ret = create_user_ns ( new ) ; if ( ret < 0 ) goto error_put ; } new -> user_ns = new -> user -> user_ns ; # ifdef CONFIG_KEYS if ( new -> thread_keyring ) { key_put ( new -> thread_keyring ) ; new -> thread_keyring = NULL ; if ( clone_flags & CLONE_THREAD ) install_thread_keyring_to_cred ( new ) ; } if ( ! ( clone_flags & CLONE_THREAD ) ) { tgcred = kmalloc ( sizeof ( * tgcred ) , GFP_KERNEL ) ; if ( ! tgcred ) { ret = - ENOMEM ; goto error_put ; } atomic_set ( & tgcred -> usage , 1 ) ; spin_lock_init ( & tgcred -> lock ) ; tgcred -> process_keyring = NULL ; tgcred -> session_keyring = key_get ( new -> tgcred -> session_keyring ) ; release_tgcred ( new ) ; new -> tgcred = tgcred ; } # endif atomic_inc ( & new -> user -> processes ) ; p -> cred = p -> real_cred = get_cred ( new ) ; alter_cred_subscribers ( new , 2 ) ; validate_creds ( new ) ; return 0 ; error_put : put_cred ( new ) ; return ret ; }\n",
      "fixed_code": "<S2SV_ModStart> int ret ; p -> replacement_session_keyring = NULL ;\n",
      "source_code_length": 1607,
      "target_code_length": 68,
      "vulnerability_patterns": {
        "use_after_free": 18,
        "null_pointer": 34,
        "memory_leak": 1,
        "total": 53
      },
      "total_patterns": 53,
      "original_address": "https://github.com/torvalds/linux/commit/79549c6dfda0603dba9a70a53467ce62d9335c33",
      "discovery_time": "2012-08-09T10:29Z",
      "project_commit_id": "torvalds@linux/79549c6dfda0603dba9a70a53467ce62d9335c33",
      "extraction_time": "2025-08-31T15:41:49.182475",
      "label": 1,
      "vulnerability_type": "buffer_overflow",
      "difficulty_level": "advanced",
      "risk_factors": [
        "system_crash",
        "memory_corruption",
        "arbitrary_code_execution",
        "use_after_free"
      ],
      "attack_vectors": [
        "memory_manipulation",
        "malicious_input",
        "code_analysis",
        "buffer_overflow",
        "reverse_engineering",
        "fuzzing"
      ],
      "mitigation_strategies": [
        "safe_string_functions",
        "dynamic_analysis",
        "code_review",
        "static_analysis",
        "memory_safety_checks",
        "input_validation",
        "fuzzing",
        "bounds_checking",
        "secure_coding_practices"
      ],
      "code_differences": {
        "has_differences": true,
        "source_lines": 2,
        "target_lines": 2,
        "character_differences": 1539,
        "similarity_percentage": 9.090909090909092
      },
      "vulnerability_location": {
        "vulnerability_present": true,
        "fix_applied": true,
        "code_changed": true,
        "estimated_lines_changed": 0
      }
    },
    {
      "cve_id": "CVE-2012-3364",
      "cwe_id": "CWE-119",
      "cwe_name": "Buffer Overflow",
      "project": "torvalds",
      "severity": "critical",
      "weaponization_score": 8.5,
      "is_critical": true,
      "is_weaponizable": true,
      "is_high_priority_project": false,
      "vulnerable_code": "CWE-119 static __u8 * nci_extract_rf_params_nfcf_passive_poll ( struct nci_dev * ndev , struct rf_tech_specific_params_nfcf_poll * nfcf_poll , __u8 * data ) { nfcf_poll -> bit_rate = * data ++ ; <S2SV_StartBug> nfcf_poll -> sensf_res_len = * data ++ ; <S2SV_EndBug> pr_debug ( \"bit_rate<S2SV_blank>%d,<S2SV_blank>sensf_res_len<S2SV_blank>%d\\\\n\" , nfcf_poll -> bit_rate , nfcf_poll -> sensf_res_len ) ; memcpy ( nfcf_poll -> sensf_res , data , nfcf_poll -> sensf_res_len ) ; data += nfcf_poll -> sensf_res_len ; return data ; }\n",
      "fixed_code": "<S2SV_ModStart> -> sensf_res_len = min_t ( __u8 , <S2SV_ModStart> * data ++ , NFC_SENSF_RES_MAXSIZE )\n",
      "source_code_length": 527,
      "target_code_length": 102,
      "vulnerability_patterns": {
        "buffer_overflow": 1,
        "integer_overflow": 3,
        "null_pointer": 7,
        "total": 11
      },
      "total_patterns": 11,
      "original_address": "https://github.com/torvalds/linux/commit/67de956ff5dc1d4f321e16cfbd63f5be3b691b43",
      "discovery_time": "2013-01-22T23:55Z",
      "project_commit_id": "torvalds@linux/67de956ff5dc1d4f321e16cfbd63f5be3b691b43",
      "extraction_time": "2025-08-31T15:41:49.182503",
      "label": 1,
      "vulnerability_type": "buffer_overflow",
      "difficulty_level": "advanced",
      "risk_factors": [
        "system_crash",
        "memory_corruption",
        "buffer_overflow",
        "arbitrary_code_execution"
      ],
      "attack_vectors": [
        "memory_manipulation",
        "malicious_input",
        "code_analysis",
        "buffer_overflow",
        "reverse_engineering",
        "fuzzing"
      ],
      "mitigation_strategies": [
        "safe_string_functions",
        "dynamic_analysis",
        "code_review",
        "static_analysis",
        "memory_safety_checks",
        "input_validation",
        "fuzzing",
        "bounds_checking",
        "secure_coding_practices"
      ],
      "code_differences": {
        "has_differences": true,
        "source_lines": 2,
        "target_lines": 2,
        "character_differences": 425,
        "similarity_percentage": 30.303030303030305
      },
      "vulnerability_location": {
        "vulnerability_present": true,
        "fix_applied": true,
        "code_changed": true,
        "estimated_lines_changed": 0
      }
    },
    {
      "cve_id": "CVE-2016-1621",
      "cwe_id": "CWE-119",
      "cwe_name": "Buffer Overflow",
      "project": "external",
      "severity": "critical",
      "weaponization_score": 8.5,
      "is_critical": true,
      "is_weaponizable": true,
      "is_high_priority_project": false,
      "vulnerable_code": "CWE-119 int main ( int argc , char * * argv ) { int frame_cnt = 0 ; FILE * outfile = NULL ; vpx_codec_ctx_t codec ; const VpxInterface * decoder = NULL ; VpxVideoReader * reader = NULL ; const VpxVideoInfo * info = NULL ; int n = 0 ; int m = 0 ; int is_range = 0 ; char * nptr = NULL ; exec_name = argv [ 0 ] ; if ( argc != 4 ) die ( \"Invalid<S2SV_blank>number<S2SV_blank>of<S2SV_blank>arguments.\" ) ; reader = vpx_video_reader_open ( argv [ 1 ] ) ; if ( ! reader ) die ( \"Failed<S2SV_blank>to<S2SV_blank>open<S2SV_blank>%s<S2SV_blank>for<S2SV_blank>reading.\" , argv [ 1 ] ) ; if ( ! ( outfile = fopen ( argv [ 2 ] , \"wb\" ) ) ) die ( \"Failed<S2SV_blank>to<S2SV_blank>open<S2SV_blank>%s<S2SV_blank>for<S2SV_blank>writing.\" , argv [ 2 ] ) ; n = strtol ( argv [ 3 ] , & nptr , 0 ) ; m = strtol ( nptr + 1 , NULL , 0 ) ; is_range = ( * nptr == '-' ) ; if ( ! n || ! m || ( * nptr != '-' && * nptr != '/' ) ) die ( \"Couldn\\'t<S2SV_blank>parse<S2SV_blank>pattern<S2SV_blank>%s.\\\\n\" , argv [ 3 ] ) ; info = vpx_video_reader_get_info ( reader ) ; decoder = get_vpx_decoder_by_fourcc ( info -> codec_fourcc ) ; if ( ! decoder ) die ( \"Unknown<S2SV_blank>input<S2SV_blank>codec.\" ) ; <S2SV_StartBug> printf ( \"Using<S2SV_blank>%s\\\\n\" , vpx_codec_iface_name ( decoder -> interface ( ) ) ) ; <S2SV_EndBug> <S2SV_StartBug> if ( vpx_codec_dec_init ( & codec , decoder -> interface ( ) , NULL , 0 ) ) <S2SV_EndBug> die_codec ( & codec , \"Failed<S2SV_blank>to<S2SV_blank>initialize<S2SV_blank>decoder.\" ) ; while ( vpx_video_reader_read_frame ( reader ) ) { vpx_codec_iter_t iter = NULL ; vpx_image_t * img = NULL ; size_t frame_size = 0 ; int skip ; const unsigned char * frame = vpx_video_reader_get_frame ( reader , & frame_size ) ; if ( vpx_codec_decode ( & codec , frame , ( unsigned int ) frame_size , NULL , 0 ) ) die_codec ( & codec , \"Failed<S2SV_blank>to<S2SV_blank>decode<S2SV_blank>frame.\" ) ; ++ frame_cnt ; skip = ( is_range && frame_cnt >= n && frame_cnt <= m ) || ( ! is_range && m - ( frame_cnt - 1 ) % m <= n ) ; if ( ! skip ) { putc ( '.' , stdout ) ; while ( ( img = vpx_codec_get_frame ( & codec , & iter ) ) != NULL ) vpx_img_write ( img , outfile ) ; } else { putc ( 'X' , stdout ) ; } fflush ( stdout ) ; } printf ( \"Processed<S2SV_blank>%d<S2SV_blank>frames.\\\\n\" , frame_cnt ) ; if ( vpx_codec_destroy ( & codec ) ) die_codec ( & codec , \"Failed<S2SV_blank>to<S2SV_blank>destroy<S2SV_blank>codec.\" ) ; printf ( \"Play:<S2SV_blank>ffplay<S2SV_blank>-f<S2SV_blank>rawvideo<S2SV_blank>-pix_fmt<S2SV_blank>yuv420p<S2SV_blank>-s<S2SV_blank>%dx%d<S2SV_blank>%s\\\\n\" , info -> frame_width , info -> frame_height , argv [ 2 ] ) ; vpx_video_reader_close ( reader ) ; fclose ( outfile ) ; return EXIT_SUCCESS ; }\n",
      "fixed_code": "<S2SV_ModStart> ( decoder -> codec_interface <S2SV_ModEnd> ( ) ) <S2SV_ModStart> , decoder -> codec_interface <S2SV_ModEnd> ( ) ,\n",
      "source_code_length": 2710,
      "target_code_length": 130,
      "vulnerability_patterns": {
        "use_after_free": 1,
        "format_string": 1,
        "null_pointer": 19,
        "total": 21
      },
      "total_patterns": 21,
      "original_address": "https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426",
      "discovery_time": "2016-03-12T21:59Z",
      "project_commit_id": "external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426",
      "extraction_time": "2025-08-31T15:41:49.182513",
      "label": 1,
      "vulnerability_type": "buffer_overflow",
      "difficulty_level": "advanced",
      "risk_factors": [
        "system_crash",
        "memory_corruption",
        "arbitrary_code_execution",
        "use_after_free"
      ],
      "attack_vectors": [
        "memory_manipulation",
        "malicious_input",
        "code_analysis",
        "buffer_overflow",
        "reverse_engineering",
        "fuzzing"
      ],
      "mitigation_strategies": [
        "safe_string_functions",
        "dynamic_analysis",
        "code_review",
        "static_analysis",
        "memory_safety_checks",
        "input_validation",
        "fuzzing",
        "bounds_checking",
        "secure_coding_practices"
      ],
      "code_differences": {
        "has_differences": true,
        "source_lines": 2,
        "target_lines": 2,
        "character_differences": 2580,
        "similarity_percentage": 4.464285714285714
      },
      "vulnerability_location": {
        "vulnerability_present": true,
        "fix_applied": true,
        "code_changed": true,
        "estimated_lines_changed": 0
      }
    },
    {
      "cve_id": "CVE-2014-0063",
      "cwe_id": "CWE-119",
      "cwe_name": "Buffer Overflow",
      "project": "postgres",
      "severity": "critical",
      "weaponization_score": 8.5,
      "is_critical": true,
      "is_weaponizable": true,
      "is_high_priority_project": false,
      "vulnerable_code": "CWE-119 static int DecodeNumberField ( int len , char * str , int fmask , int * tmask , struct tm * tm , fsec_t * fsec , int * is2digits ) { char * cp ; if ( ( cp = strchr ( str , '.' ) ) != NULL ) { # ifdef HAVE_INT64_TIMESTAMP <S2SV_StartBug> char fstr [ MAXDATELEN + 1 ] ; <S2SV_EndBug> strcpy ( fstr , ( cp + 1 ) ) ; strcpy ( fstr + strlen ( fstr ) , \"000000\" ) ; * ( fstr + 6 ) = '\\\\0' ; * fsec = strtol ( fstr , NULL , 10 ) ; # else * fsec = strtod ( cp , NULL ) ; # endif * cp = '\\\\0' ; len = strlen ( str ) ; } else if ( ( fmask & DTK_DATE_M ) != DTK_DATE_M ) { if ( len == 8 ) { * tmask = DTK_DATE_M ; tm -> tm_mday = atoi ( str + 6 ) ; * ( str + 6 ) = '\\\\0' ; tm -> tm_mon = atoi ( str + 4 ) ; * ( str + 4 ) = '\\\\0' ; tm -> tm_year = atoi ( str + 0 ) ; return DTK_DATE ; } else if ( len == 6 ) { * tmask = DTK_DATE_M ; tm -> tm_mday = atoi ( str + 4 ) ; * ( str + 4 ) = '\\\\0' ; tm -> tm_mon = atoi ( str + 2 ) ; * ( str + 2 ) = '\\\\0' ; tm -> tm_year = atoi ( str + 0 ) ; * is2digits = TRUE ; return DTK_DATE ; } else if ( len == 5 ) { * tmask = DTK_DATE_M ; tm -> tm_mday = atoi ( str + 2 ) ; * ( str + 2 ) = '\\\\0' ; tm -> tm_mon = 1 ; tm -> tm_year = atoi ( str + 0 ) ; * is2digits = TRUE ; return DTK_DATE ; } } if ( ( fmask & DTK_TIME_M ) != DTK_TIME_M ) { if ( len == 6 ) { * tmask = DTK_TIME_M ; tm -> tm_sec = atoi ( str + 4 ) ; * ( str + 4 ) = '\\\\0' ; tm -> tm_min = atoi ( str + 2 ) ; * ( str + 2 ) = '\\\\0' ; tm -> tm_hour = atoi ( str + 0 ) ; return DTK_TIME ; } else if ( len == 4 ) { * tmask = DTK_TIME_M ; tm -> tm_sec = 0 ; tm -> tm_min = atoi ( str + 2 ) ; * ( str + 2 ) = '\\\\0' ; tm -> tm_hour = atoi ( str + 0 ) ; return DTK_TIME ; } } return - 1 ; }\n",
      "fixed_code": "<S2SV_ModStart> char fstr [ 7 ] ; int i ; cp ++ ; for ( i = 0 ; i < 6 ; i ++ ) fstr [ i ] = * cp != '\\\\0' ? * cp ++ : '0' ; fstr [ i ] <S2SV_ModEnd> = '\\\\0' ;\n",
      "source_code_length": 1677,
      "target_code_length": 159,
      "vulnerability_patterns": {
        "buffer_overflow": 2,
        "null_pointer": 15,
        "total": 17
      },
      "total_patterns": 17,
      "original_address": "https://github.com/postgres/postgres/commit/4318daecc959886d001a6e79c6ea853e8b1dfb4b",
      "discovery_time": "2014-03-31T14:58Z",
      "project_commit_id": "postgres@postgres/4318daecc959886d001a6e79c6ea853e8b1dfb4b",
      "extraction_time": "2025-08-31T15:41:49.182540",
      "label": 1,
      "vulnerability_type": "buffer_overflow",
      "difficulty_level": "advanced",
      "risk_factors": [
        "system_crash",
        "memory_corruption",
        "buffer_overflow",
        "arbitrary_code_execution"
      ],
      "attack_vectors": [
        "memory_manipulation",
        "malicious_input",
        "code_analysis",
        "buffer_overflow",
        "reverse_engineering",
        "fuzzing"
      ],
      "mitigation_strategies": [
        "safe_string_functions",
        "dynamic_analysis",
        "code_review",
        "static_analysis",
        "memory_safety_checks",
        "input_validation",
        "fuzzing",
        "bounds_checking",
        "secure_coding_practices"
      ],
      "code_differences": {
        "has_differences": true,
        "source_lines": 2,
        "target_lines": 2,
        "character_differences": 1518,
        "similarity_percentage": 18.51851851851852
      },
      "vulnerability_location": {
        "vulnerability_present": true,
        "fix_applied": true,
        "code_changed": true,
        "estimated_lines_changed": 0
      }
    },
    {
      "cve_id": "CVE-2017-0810",
      "cwe_id": "CWE-119",
      "cwe_name": "Buffer Overflow",
      "project": "external",
      "severity": "critical",
      "weaponization_score": 8.5,
      "is_critical": true,
      "is_weaponizable": true,
      "is_high_priority_project": false,
      "vulnerable_code": "CWE-119 IMPEG2D_ERROR_CODES_T impeg2d_dec_p_b_slice ( dec_state_t * ps_dec ) { WORD16 * pi2_vld_out ; UWORD32 i ; yuv_buf_t * ps_cur_frm_buf = & ps_dec -> s_cur_frm_buf ; UWORD32 u4_frm_offset = 0 ; const dec_mb_params_t * ps_dec_mb_params ; IMPEG2D_ERROR_CODES_T e_error = ( IMPEG2D_ERROR_CODES_T ) IVD_ERROR_NONE ; pi2_vld_out = ps_dec -> ai2_vld_buf ; memset ( ps_dec -> ai2_pred_mv , 0 , sizeof ( ps_dec -> ai2_pred_mv ) ) ; ps_dec -> u2_prev_intra_mb = 0 ; ps_dec -> u2_first_mb = 1 ; ps_dec -> u2_picture_width = ps_dec -> u2_frame_width ; if ( ps_dec -> u2_picture_structure != FRAME_PICTURE ) { ps_dec -> u2_picture_width <<= 1 ; if ( ps_dec -> u2_picture_structure == BOTTOM_FIELD ) { u4_frm_offset = ps_dec -> u2_frame_width ; } } do { UWORD32 u4_x_offset , u4_y_offset ; WORD32 ret ; UWORD32 u4_x_dst_offset = 0 ; UWORD32 u4_y_dst_offset = 0 ; UWORD8 * pu1_out_p ; UWORD8 * pu1_pred ; WORD32 u4_pred_strd ; IMPEG2D_TRACE_MB_START ( ps_dec -> u2_mb_x , ps_dec -> u2_mb_y ) ; if ( ps_dec -> e_pic_type == B_PIC ) ret = impeg2d_dec_pnb_mb_params ( ps_dec ) ; else ret = impeg2d_dec_p_mb_params ( ps_dec ) ; if ( ret ) <S2SV_StartBug> return IMPEG2D_MB_TEX_DECODE_ERR ; <S2SV_EndBug> IMPEG2D_TRACE_MB_START ( ps_dec -> u2_mb_x , ps_dec -> u2_mb_y ) ; u4_x_dst_offset = u4_frm_offset + ( ps_dec -> u2_mb_x << 4 ) ; u4_y_dst_offset = ( ps_dec -> u2_mb_y << 4 ) * ps_dec -> u2_picture_width ; pu1_out_p = ps_cur_frm_buf -> pu1_y + u4_x_dst_offset + u4_y_dst_offset ; if ( ps_dec -> u2_prev_intra_mb == 0 ) { UWORD32 offset_x , offset_y , stride ; UWORD16 index = ( ps_dec -> u2_motion_type ) ; if ( ps_dec -> e_mb_pred == BIDIRECT ) { ps_dec_mb_params = & ps_dec -> ps_func_bi_direct [ index ] ; } else { ps_dec_mb_params = & ps_dec -> ps_func_forw_or_back [ index ] ; } stride = ps_dec -> u2_picture_width ; offset_x = u4_frm_offset + ( ps_dec -> u2_mb_x << 4 ) ; offset_y = ( ps_dec -> u2_mb_y << 4 ) ; ps_dec -> s_dest_buf . pu1_y = ps_cur_frm_buf -> pu1_y + offset_y * stride + offset_x ; stride = stride >> 1 ; ps_dec -> s_dest_buf . pu1_u = ps_cur_frm_buf -> pu1_u + ( offset_y >> 1 ) * stride + ( offset_x >> 1 ) ; ps_dec -> s_dest_buf . pu1_v = ps_cur_frm_buf -> pu1_v + ( offset_y >> 1 ) * stride + ( offset_x >> 1 ) ; PROFILE_DISABLE_MC_IF0 ps_dec_mb_params -> pf_mc ( ps_dec ) ; } for ( i = 0 ; i < NUM_LUMA_BLKS ; ++ i ) { if ( ( ps_dec -> u2_cbp & ( 1 << ( BLOCKS_IN_MB - 1 - i ) ) ) != 0 ) { e_error = ps_dec -> pf_vld_inv_quant ( ps_dec , pi2_vld_out , ps_dec -> pu1_inv_scan_matrix , ps_dec -> u2_prev_intra_mb , Y_LUMA , 0 ) ; if ( ( IMPEG2D_ERROR_CODES_T ) IVD_ERROR_NONE != e_error ) { return e_error ; } u4_x_offset = gai2_impeg2_blk_x_off [ i ] ; if ( ps_dec -> u2_field_dct == 0 ) u4_y_offset = gai2_impeg2_blk_y_off_frm [ i ] ; else u4_y_offset = gai2_impeg2_blk_y_off_fld [ i ] ; IMPEG2D_IDCT_INP_STATISTICS ( pi2_vld_out , ps_dec -> u4_non_zero_cols , ps_dec -> u4_non_zero_rows ) ; PROFILE_DISABLE_IDCT_IF0 { WORD32 idx ; if ( 1 == ( ps_dec -> u4_non_zero_cols | ps_dec -> u4_non_zero_rows ) ) idx = 0 ; else idx = 1 ; if ( 0 == ps_dec -> u2_prev_intra_mb ) { pu1_pred = pu1_out_p + u4_y_offset * ps_dec -> u2_picture_width + u4_x_offset ; u4_pred_strd = ps_dec -> u2_picture_width << ps_dec -> u2_field_dct ; } else { pu1_pred = ( UWORD8 * ) gau1_impeg2_zerobuf ; u4_pred_strd = 8 ; } ps_dec -> pf_idct_recon [ idx * 2 + ps_dec -> i4_last_value_one ] ( pi2_vld_out , ps_dec -> ai2_idct_stg1 , pu1_pred , pu1_out_p + u4_y_offset * ps_dec -> u2_picture_width + u4_x_offset , 8 , u4_pred_strd , ps_dec -> u2_picture_width << ps_dec -> u2_field_dct , ~ ps_dec -> u4_non_zero_cols , ~ ps_dec -> u4_non_zero_rows ) ; } } } u4_x_dst_offset >>= 1 ; u4_y_dst_offset >>= 2 ; if ( ( ps_dec -> u2_cbp & 0x02 ) != 0 ) { pu1_out_p = ps_cur_frm_buf -> pu1_u + u4_x_dst_offset + u4_y_dst_offset ; e_error = ps_dec -> pf_vld_inv_quant ( ps_dec , pi2_vld_out , ps_dec -> pu1_inv_scan_matrix , ps_dec -> u2_prev_intra_mb , U_CHROMA , 0 ) ; if ( ( IMPEG2D_ERROR_CODES_T ) IVD_ERROR_NONE != e_error ) { return e_error ; } IMPEG2D_IDCT_INP_STATISTICS ( pi2_vld_out , ps_dec -> u4_non_zero_cols , ps_dec -> u4_non_zero_rows ) ; PROFILE_DISABLE_IDCT_IF0 { WORD32 idx ; if ( 1 == ( ps_dec -> u4_non_zero_cols | ps_dec -> u4_non_zero_rows ) ) idx = 0 ; else idx = 1 ; if ( 0 == ps_dec -> u2_prev_intra_mb ) { pu1_pred = pu1_out_p ; u4_pred_strd = ps_dec -> u2_picture_width >> 1 ; } else { pu1_pred = ( UWORD8 * ) gau1_impeg2_zerobuf ; u4_pred_strd = 8 ; } ps_dec -> pf_idct_recon [ idx * 2 + ps_dec -> i4_last_value_one ] ( pi2_vld_out , ps_dec -> ai2_idct_stg1 , pu1_pred , pu1_out_p , 8 , u4_pred_strd , ps_dec -> u2_picture_width >> 1 , ~ ps_dec -> u4_non_zero_cols , ~ ps_dec -> u4_non_zero_rows ) ; } } if ( ( ps_dec -> u2_cbp & 0x01 ) != 0 ) { pu1_out_p = ps_cur_frm_buf -> pu1_v + u4_x_dst_offset + u4_y_dst_offset ; e_error = ps_dec -> pf_vld_inv_quant ( ps_dec , pi2_vld_out , ps_dec -> pu1_inv_scan_matrix , ps_dec -> u2_prev_intra_mb , V_CHROMA , 0 ) ; if ( ( IMPEG2D_ERROR_CODES_T ) IVD_ERROR_NONE != e_error ) { return e_error ; } IMPEG2D_IDCT_INP_STATISTICS ( pi2_vld_out , ps_dec -> u4_non_zero_cols , ps_dec -> u4_non_zero_rows ) ; PROFILE_DISABLE_IDCT_IF0 { WORD32 idx ; if ( 1 == ( ps_dec -> u4_non_zero_cols | ps_dec -> u4_non_zero_rows ) ) idx = 0 ; else idx = 1 ; if ( 0 == ps_dec -> u2_prev_intra_mb ) { pu1_pred = pu1_out_p ; u4_pred_strd = ps_dec -> u2_picture_width >> 1 ; } else { pu1_pred = ( UWORD8 * ) gau1_impeg2_zerobuf ; u4_pred_strd = 8 ; } ps_dec -> pf_idct_recon [ idx * 2 + ps_dec -> i4_last_value_one ] ( pi2_vld_out , ps_dec -> ai2_idct_stg1 , pu1_pred , pu1_out_p , 8 , u4_pred_strd , ps_dec -> u2_picture_width >> 1 , ~ ps_dec -> u4_non_zero_cols , ~ ps_dec -> u4_non_zero_rows ) ; } } ps_dec -> u2_num_mbs_left -- ; ps_dec -> u2_first_mb = 0 ; ps_dec -> u2_mb_x ++ ; if ( ps_dec -> s_bit_stream . u4_offset > ps_dec -> s_bit_stream . u4_max_offset ) { return IMPEG2D_BITSTREAM_BUFF_EXCEEDED_ERR ; } else if ( ps_dec -> u2_mb_x == ps_dec -> u2_num_horiz_mb ) { ps_dec -> u2_mb_x = 0 ; ps_dec -> u2_mb_y ++ ; } } while ( ps_dec -> u2_num_mbs_left != 0 && impeg2d_bit_stream_nxt ( & ps_dec -> s_bit_stream , 23 ) != 0x0 ) ; return e_error ; }\n",
      "fixed_code": "<S2SV_ModStart> return IMPEG2D_MB_TEX_DECODE_ERR ; if ( 0 >= ps_dec -> u2_num_mbs_left ) { break ; }\n",
      "source_code_length": 6187,
      "target_code_length": 101,
      "vulnerability_patterns": {
        "buffer_overflow": 1,
        "integer_overflow": 4,
        "null_pointer": 102,
        "total": 107
      },
      "total_patterns": 107,
      "original_address": "https://android.googlesource.com/platform/external/libmpeg2/+/7737780815fe523ad7b0e49456eb75d27a30818a",
      "discovery_time": "2017-10-04T01:29Z",
      "project_commit_id": "external@libmpeg2/7737780815fe523ad7b0e49456eb75d27a30818a",
      "extraction_time": "2025-08-31T15:41:49.182578",
      "label": 1,
      "vulnerability_type": "buffer_overflow",
      "difficulty_level": "advanced",
      "risk_factors": [
        "system_crash",
        "memory_corruption",
        "buffer_overflow",
        "arbitrary_code_execution"
      ],
      "attack_vectors": [
        "memory_manipulation",
        "malicious_input",
        "code_analysis",
        "buffer_overflow",
        "reverse_engineering",
        "fuzzing"
      ],
      "mitigation_strategies": [
        "safe_string_functions",
        "dynamic_analysis",
        "code_review",
        "static_analysis",
        "memory_safety_checks",
        "input_validation",
        "fuzzing",
        "bounds_checking",
        "secure_coding_practices"
      ],
      "code_differences": {
        "has_differences": true,
        "source_lines": 2,
        "target_lines": 2,
        "character_differences": 6086,
        "similarity_percentage": 8.633093525179856
      },
      "vulnerability_location": {
        "vulnerability_present": true,
        "fix_applied": true,
        "code_changed": true,
        "estimated_lines_changed": 0
      }
    },
    {
      "cve_id": "CVE-2016-1621",
      "cwe_id": "CWE-119",
      "cwe_name": "Buffer Overflow",
      "project": "external",
      "severity": "critical",
      "weaponization_score": 8.5,
      "is_critical": true,
      "is_weaponizable": true,
      "is_high_priority_project": false,
      "vulnerable_code": "CWE-119 int main ( int argc , char * * argv ) { int frame_cnt = 0 ; FILE * outfile = NULL ; vpx_codec_ctx_t codec ; const VpxInterface * decoder = NULL ; VpxVideoReader * reader = NULL ; const VpxVideoInfo * info = NULL ; int n = 0 ; int m = 0 ; int is_range = 0 ; char * nptr = NULL ; exec_name = argv [ 0 ] ; if ( argc != 4 ) die ( \"Invalid<S2SV_blank>number<S2SV_blank>of<S2SV_blank>arguments.\" ) ; reader = vpx_video_reader_open ( argv [ 1 ] ) ; if ( ! reader ) die ( \"Failed<S2SV_blank>to<S2SV_blank>open<S2SV_blank>%s<S2SV_blank>for<S2SV_blank>reading.\" , argv [ 1 ] ) ; if ( ! ( outfile = fopen ( argv [ 2 ] , \"wb\" ) ) ) die ( \"Failed<S2SV_blank>to<S2SV_blank>open<S2SV_blank>%s<S2SV_blank>for<S2SV_blank>writing.\" , argv [ 2 ] ) ; n = strtol ( argv [ 3 ] , & nptr , 0 ) ; m = strtol ( nptr + 1 , NULL , 0 ) ; is_range = ( * nptr == '-' ) ; if ( ! n || ! m || ( * nptr != '-' && * nptr != '/' ) ) die ( \"Couldn\\'t<S2SV_blank>parse<S2SV_blank>pattern<S2SV_blank>%s.\\\\n\" , argv [ 3 ] ) ; info = vpx_video_reader_get_info ( reader ) ; decoder = get_vpx_decoder_by_fourcc ( info -> codec_fourcc ) ; if ( ! decoder ) die ( \"Unknown<S2SV_blank>input<S2SV_blank>codec.\" ) ; <S2SV_StartBug> printf ( \"Using<S2SV_blank>%s\\\\n\" , vpx_codec_iface_name ( decoder -> interface ( ) ) ) ; <S2SV_EndBug> <S2SV_StartBug> if ( vpx_codec_dec_init ( & codec , decoder -> interface ( ) , NULL , 0 ) ) <S2SV_EndBug> die_codec ( & codec , \"Failed<S2SV_blank>to<S2SV_blank>initialize<S2SV_blank>decoder.\" ) ; while ( vpx_video_reader_read_frame ( reader ) ) { vpx_codec_iter_t iter = NULL ; vpx_image_t * img = NULL ; size_t frame_size = 0 ; int skip ; const unsigned char * frame = vpx_video_reader_get_frame ( reader , & frame_size ) ; if ( vpx_codec_decode ( & codec , frame , ( unsigned int ) frame_size , NULL , 0 ) ) die_codec ( & codec , \"Failed<S2SV_blank>to<S2SV_blank>decode<S2SV_blank>frame.\" ) ; ++ frame_cnt ; skip = ( is_range && frame_cnt >= n && frame_cnt <= m ) || ( ! is_range && m - ( frame_cnt - 1 ) % m <= n ) ; if ( ! skip ) { putc ( '.' , stdout ) ; while ( ( img = vpx_codec_get_frame ( & codec , & iter ) ) != NULL ) vpx_img_write ( img , outfile ) ; } else { putc ( 'X' , stdout ) ; } fflush ( stdout ) ; } printf ( \"Processed<S2SV_blank>%d<S2SV_blank>frames.\\\\n\" , frame_cnt ) ; if ( vpx_codec_destroy ( & codec ) ) die_codec ( & codec , \"Failed<S2SV_blank>to<S2SV_blank>destroy<S2SV_blank>codec.\" ) ; printf ( \"Play:<S2SV_blank>ffplay<S2SV_blank>-f<S2SV_blank>rawvideo<S2SV_blank>-pix_fmt<S2SV_blank>yuv420p<S2SV_blank>-s<S2SV_blank>%dx%d<S2SV_blank>%s\\\\n\" , info -> frame_width , info -> frame_height , argv [ 2 ] ) ; vpx_video_reader_close ( reader ) ; fclose ( outfile ) ; return EXIT_SUCCESS ; }\n",
      "fixed_code": "<S2SV_ModStart> ( decoder -> codec_interface <S2SV_ModEnd> ( ) ) <S2SV_ModStart> , decoder -> codec_interface <S2SV_ModEnd> ( ) ,\n",
      "source_code_length": 2710,
      "target_code_length": 130,
      "vulnerability_patterns": {
        "use_after_free": 3,
        "integer_overflow": 3,
        "format_string": 1,
        "null_pointer": 66,
        "total": 73
      },
      "total_patterns": 73,
      "original_address": "https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426",
      "discovery_time": "2016-03-12T21:59Z",
      "project_commit_id": "external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426",
      "extraction_time": "2025-08-31T15:41:49.182625",
      "label": 1,
      "vulnerability_type": "buffer_overflow",
      "difficulty_level": "advanced",
      "risk_factors": [
        "system_crash",
        "memory_corruption",
        "arbitrary_code_execution",
        "use_after_free"
      ],
      "attack_vectors": [
        "memory_manipulation",
        "malicious_input",
        "code_analysis",
        "buffer_overflow",
        "reverse_engineering",
        "fuzzing"
      ],
      "mitigation_strategies": [
        "safe_string_functions",
        "dynamic_analysis",
        "code_review",
        "static_analysis",
        "memory_safety_checks",
        "input_validation",
        "fuzzing",
        "bounds_checking",
        "secure_coding_practices"
      ],
      "code_differences": {
        "has_differences": true,
        "source_lines": 2,
        "target_lines": 2,
        "character_differences": 2580,
        "similarity_percentage": 4.464285714285714
      },
      "vulnerability_location": {
        "vulnerability_present": true,
        "fix_applied": true,
        "code_changed": true,
        "estimated_lines_changed": 0
      }
    },
    {
      "cve_id": "CVE-2018-1999010",
      "cwe_id": "CWE-125",
      "cwe_name": "Out-of-bounds Read",
      "project": "FFmpeg",
      "severity": "critical",
      "weaponization_score": 8.5,
      "is_critical": true,
      "is_weaponizable": true,
      "is_high_priority_project": true,
      "vulnerable_code": "CWE-125 int ff_mms_asf_header_parser ( MMSContext * mms ) { uint8_t * p = mms -> asf_header ; uint8_t * end ; int flags , stream_id ; mms -> stream_num = 0 ; if ( mms -> asf_header_size < sizeof ( ff_asf_guid ) * 2 + 22 || memcmp ( p , ff_asf_header , sizeof ( ff_asf_guid ) ) ) { av_log ( NULL , AV_LOG_ERROR , \"Corrupt<S2SV_blank>stream<S2SV_blank>(invalid<S2SV_blank>ASF<S2SV_blank>header,<S2SV_blank>size=%d)\\\\n\" , mms -> asf_header_size ) ; return AVERROR_INVALIDDATA ; } end = mms -> asf_header + mms -> asf_header_size ; p += sizeof ( ff_asf_guid ) + 14 ; while ( end - p >= sizeof ( ff_asf_guid ) + 8 ) { uint64_t chunksize ; if ( ! memcmp ( p , ff_asf_data_header , sizeof ( ff_asf_guid ) ) ) { chunksize = 50 ; } else { chunksize = AV_RL64 ( p + sizeof ( ff_asf_guid ) ) ; } if ( ! chunksize || chunksize > end - p ) { av_log ( NULL , AV_LOG_ERROR , \"Corrupt<S2SV_blank>stream<S2SV_blank>(header<S2SV_blank>chunksize<S2SV_blank>%\" PRId64 \"<S2SV_blank>is<S2SV_blank>invalid)\\\\n\" , chunksize ) ; return AVERROR_INVALIDDATA ; } if ( ! memcmp ( p , ff_asf_file_header , sizeof ( ff_asf_guid ) ) ) { if ( end - p > sizeof ( ff_asf_guid ) * 2 + 68 ) { mms -> asf_packet_len = AV_RL32 ( p + sizeof ( ff_asf_guid ) * 2 + 64 ) ; if ( mms -> asf_packet_len <= 0 || mms -> asf_packet_len > sizeof ( mms -> in_buffer ) ) { av_log ( NULL , AV_LOG_ERROR , \"Corrupt<S2SV_blank>stream<S2SV_blank>(too<S2SV_blank>large<S2SV_blank>pkt_len<S2SV_blank>%d)\\\\n\" , mms -> asf_packet_len ) ; return AVERROR_INVALIDDATA ; } } } else if ( ! memcmp ( p , ff_asf_stream_header , sizeof ( ff_asf_guid ) ) ) { <S2SV_StartBug> flags = AV_RL16 ( p + sizeof ( ff_asf_guid ) * 3 + 24 ) ; <S2SV_EndBug> stream_id = flags & 0x7F ; if ( mms -> stream_num < MMS_MAX_STREAMS && 46 + mms -> stream_num * 6 < sizeof ( mms -> out_buffer ) ) { mms -> streams = av_fast_realloc ( mms -> streams , & mms -> nb_streams_allocated , ( mms -> stream_num + 1 ) * sizeof ( MMSStream ) ) ; if ( ! mms -> streams ) return AVERROR ( ENOMEM ) ; mms -> streams [ mms -> stream_num ] . id = stream_id ; mms -> stream_num ++ ; } else { av_log ( NULL , AV_LOG_ERROR , \"Corrupt<S2SV_blank>stream<S2SV_blank>(too<S2SV_blank>many<S2SV_blank>A/V<S2SV_blank>streams)\\\\n\" ) ; return AVERROR_INVALIDDATA ; } <S2SV_StartBug> } else if ( ! memcmp ( p , ff_asf_ext_stream_header , sizeof ( ff_asf_guid ) ) ) { <S2SV_EndBug> if ( end - p >= 88 ) { int stream_count = AV_RL16 ( p + 84 ) , ext_len_count = AV_RL16 ( p + 86 ) ; uint64_t skip_bytes = 88 ; while ( stream_count -- ) { if ( end - p < skip_bytes + 4 ) { av_log ( NULL , AV_LOG_ERROR , \"Corrupt<S2SV_blank>stream<S2SV_blank>(next<S2SV_blank>stream<S2SV_blank>name<S2SV_blank>length<S2SV_blank>is<S2SV_blank>not<S2SV_blank>in<S2SV_blank>the<S2SV_blank>buffer)\\\\n\" ) ; return AVERROR_INVALIDDATA ; } skip_bytes += 4 + AV_RL16 ( p + skip_bytes + 2 ) ; } while ( ext_len_count -- ) { if ( end - p < skip_bytes + 22 ) { av_log ( NULL , AV_LOG_ERROR , \"Corrupt<S2SV_blank>stream<S2SV_blank>(next<S2SV_blank>extension<S2SV_blank>system<S2SV_blank>info<S2SV_blank>length<S2SV_blank>is<S2SV_blank>not<S2SV_blank>in<S2SV_blank>the<S2SV_blank>buffer)\\\\n\" ) ; return AVERROR_INVALIDDATA ; } skip_bytes += 22 + AV_RL32 ( p + skip_bytes + 18 ) ; } if ( end - p < skip_bytes ) { av_log ( NULL , AV_LOG_ERROR , \"Corrupt<S2SV_blank>stream<S2SV_blank>(the<S2SV_blank>last<S2SV_blank>extension<S2SV_blank>system<S2SV_blank>info<S2SV_blank>length<S2SV_blank>is<S2SV_blank>invalid)\\\\n\" ) ; return AVERROR_INVALIDDATA ; } if ( chunksize - skip_bytes > 24 ) chunksize = skip_bytes ; } } else if ( ! memcmp ( p , ff_asf_head1_guid , sizeof ( ff_asf_guid ) ) ) { chunksize = 46 ; <S2SV_StartBug> } <S2SV_EndBug> p += chunksize ; } return 0 ; }\n",
      "fixed_code": "<S2SV_ModStart> ) ) { if ( end - p >= ( sizeof ( ff_asf_guid ) * 3 + 26 ) ) { <S2SV_ModStart> ; } } } <S2SV_ModStart> = 46 ; if ( chunksize > end - p ) { av_log ( NULL , AV_LOG_ERROR , \"Corrupt<S2SV_blank>stream<S2SV_blank>(header<S2SV_blank>chunksize<S2SV_blank>%\" PRId64 \"<S2SV_blank>is<S2SV_blank>invalid)\\\\n\" , chunksize ) ; return AVERROR_INVALIDDATA ; }\n",
      "source_code_length": 3718,
      "target_code_length": 360,
      "vulnerability_patterns": {
        "integer_overflow": 7,
        "null_pointer": 22,
        "total": 29
      },
      "total_patterns": 29,
      "original_address": "https://github.com/FFmpeg/FFmpeg/commit/cced03dd667a5df6df8fd40d8de0bff477ee02e8",
      "discovery_time": "2018-07-23T15:29Z",
      "project_commit_id": "FFmpeg@FFmpeg/cced03dd667a5df6df8fd40d8de0bff477ee02e8",
      "extraction_time": "2025-08-31T15:41:49.182649",
      "label": 1,
      "vulnerability_type": "out-of-bounds_read",
      "difficulty_level": "advanced",
      "risk_factors": [
        "information_disclosure",
        "memory_corruption",
        "integer_overflow",
        "critical_infrastructure"
      ],
      "attack_vectors": [
        "memory_manipulation",
        "malicious_input",
        "code_analysis",
        "buffer_overflow",
        "reverse_engineering",
        "fuzzing"
      ],
      "mitigation_strategies": [
        "safe_string_functions",
        "dynamic_analysis",
        "code_review",
        "static_analysis",
        "memory_safety_checks",
        "input_validation",
        "fuzzing",
        "bounds_checking",
        "secure_coding_practices"
      ],
      "code_differences": {
        "has_differences": true,
        "source_lines": 2,
        "target_lines": 2,
        "character_differences": 3358,
        "similarity_percentage": 26.41509433962264
      },
      "vulnerability_location": {
        "vulnerability_present": true,
        "fix_applied": true,
        "code_changed": true,
        "estimated_lines_changed": 0
      }
    },
    {
      "cve_id": "CVE-2016-7529",
      "cwe_id": "CWE-125",
      "cwe_name": "Out-of-bounds Read",
      "project": "ImageMagick",
      "severity": "critical",
      "weaponization_score": 8.5,
      "is_critical": true,
      "is_weaponizable": true,
      "is_high_priority_project": true,
      "vulnerable_code": "CWE-125 static MagickBooleanType load_tile ( Image * image , Image * tile_image , XCFDocInfo * inDocInfo , XCFLayerInfo * inLayerInfo , size_t data_length , ExceptionInfo * exception ) { ssize_t y ; register ssize_t x ; register Quantum * q ; ssize_t count ; unsigned char * graydata ; XCFPixelInfo * xcfdata , * xcfodata ; <S2SV_StartBug> xcfdata = ( XCFPixelInfo * ) AcquireQuantumMemory ( data_length , sizeof ( * xcfdata ) ) ; <S2SV_EndBug> if ( xcfdata == ( XCFPixelInfo * ) NULL ) ThrowBinaryException ( ResourceLimitError , \"MemoryAllocationFailed\" , image -> filename ) ; xcfodata = xcfdata ; graydata = ( unsigned char * ) xcfdata ; count = ReadBlob ( image , data_length , ( unsigned char * ) xcfdata ) ; if ( count != ( ssize_t ) data_length ) ThrowBinaryException ( CorruptImageError , \"NotEnoughPixelData\" , image -> filename ) ; for ( y = 0 ; y < ( ssize_t ) tile_image -> rows ; y ++ ) { q = GetAuthenticPixels ( tile_image , 0 , y , tile_image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; if ( inDocInfo -> image_type == GIMP_GRAY ) { for ( x = 0 ; x < ( ssize_t ) tile_image -> columns ; x ++ ) { SetPixelGray ( tile_image , ScaleCharToQuantum ( * graydata ) , q ) ; SetPixelAlpha ( tile_image , ScaleCharToQuantum ( ( unsigned char ) inLayerInfo -> alpha ) , q ) ; graydata ++ ; q += GetPixelChannels ( tile_image ) ; } } else if ( inDocInfo -> image_type == GIMP_RGB ) { for ( x = 0 ; x < ( ssize_t ) tile_image -> columns ; x ++ ) { SetPixelRed ( tile_image , ScaleCharToQuantum ( xcfdata -> red ) , q ) ; SetPixelGreen ( tile_image , ScaleCharToQuantum ( xcfdata -> green ) , q ) ; SetPixelBlue ( tile_image , ScaleCharToQuantum ( xcfdata -> blue ) , q ) ; SetPixelAlpha ( tile_image , xcfdata -> alpha == 255U ? TransparentAlpha : ScaleCharToQuantum ( ( unsigned char ) inLayerInfo -> alpha ) , q ) ; xcfdata ++ ; q += GetPixelChannels ( tile_image ) ; } } if ( SyncAuthenticPixels ( tile_image , exception ) == MagickFalse ) break ; } xcfodata = ( XCFPixelInfo * ) RelinquishMagickMemory ( xcfodata ) ; return MagickTrue ; }\n",
      "fixed_code": "<S2SV_ModStart> ) AcquireQuantumMemory ( MagickMax ( data_length , tile_image -> columns * tile_image -> rows ) <S2SV_ModEnd> , sizeof (\n",
      "source_code_length": 2073,
      "target_code_length": 137,
      "vulnerability_patterns": {
        "integer_overflow": 7,
        "null_pointer": 14,
        "total": 21
      },
      "total_patterns": 21,
      "original_address": "https://github.com/ImageMagick/ImageMagick/commit/a2e1064f288a353bc5fef7f79ccb7683759e775c",
      "discovery_time": "2017-04-19T14:59Z",
      "project_commit_id": "ImageMagick@ImageMagick/a2e1064f288a353bc5fef7f79ccb7683759e775c",
      "extraction_time": "2025-08-31T15:41:49.182692",
      "label": 1,
      "vulnerability_type": "out-of-bounds_read",
      "difficulty_level": "advanced",
      "risk_factors": [
        "information_disclosure",
        "memory_corruption",
        "integer_overflow",
        "critical_infrastructure"
      ],
      "attack_vectors": [
        "memory_manipulation",
        "malicious_input",
        "code_analysis",
        "buffer_overflow",
        "reverse_engineering",
        "fuzzing"
      ],
      "mitigation_strategies": [
        "safe_string_functions",
        "dynamic_analysis",
        "code_review",
        "static_analysis",
        "memory_safety_checks",
        "input_validation",
        "fuzzing",
        "bounds_checking",
        "secure_coding_practices"
      ],
      "code_differences": {
        "has_differences": true,
        "source_lines": 2,
        "target_lines": 2,
        "character_differences": 1936,
        "similarity_percentage": 12.359550561797752
      },
      "vulnerability_location": {
        "vulnerability_present": true,
        "fix_applied": true,
        "code_changed": true,
        "estimated_lines_changed": 0
      }
    },
    {
      "cve_id": "CVE-2019-11339",
      "cwe_id": "CWE-125",
      "cwe_name": "Out-of-bounds Read",
      "project": "FFmpeg",
      "severity": "critical",
      "weaponization_score": 8.5,
      "is_critical": true,
      "is_weaponizable": true,
      "is_high_priority_project": true,
      "vulnerable_code": "CWE-125 static int decode_studio_vop_header ( Mpeg4DecContext * ctx , GetBitContext * gb ) { MpegEncContext * s = & ctx -> m ; if ( get_bits_left ( gb ) <= 32 ) return 0 ; s -> partitioned_frame = 0 ; <S2SV_StartBug> s -> decode_mb = mpeg4_decode_studio_mb ; <S2SV_EndBug> decode_smpte_tc ( ctx , gb ) ; skip_bits ( gb , 10 ) ; skip_bits ( gb , 2 ) ; s -> pict_type = get_bits ( gb , 2 ) + AV_PICTURE_TYPE_I ; if ( get_bits1 ( gb ) ) { skip_bits1 ( gb ) ; skip_bits1 ( gb ) ; s -> progressive_frame = get_bits1 ( gb ) ^ 1 ; } if ( s -> pict_type == AV_PICTURE_TYPE_I ) { if ( get_bits1 ( gb ) ) reset_studio_dc_predictors ( s ) ; } if ( ctx -> shape != BIN_ONLY_SHAPE ) { s -> alternate_scan = get_bits1 ( gb ) ; s -> frame_pred_frame_dct = get_bits1 ( gb ) ; s -> dct_precision = get_bits ( gb , 2 ) ; s -> intra_dc_precision = get_bits ( gb , 2 ) ; s -> q_scale_type = get_bits1 ( gb ) ; } if ( s -> alternate_scan ) { ff_init_scantable ( s -> idsp . idct_permutation , & s -> inter_scantable , ff_alternate_vertical_scan ) ; ff_init_scantable ( s -> idsp . idct_permutation , & s -> intra_scantable , ff_alternate_vertical_scan ) ; ff_init_scantable ( s -> idsp . idct_permutation , & s -> intra_h_scantable , ff_alternate_vertical_scan ) ; ff_init_scantable ( s -> idsp . idct_permutation , & s -> intra_v_scantable , ff_alternate_vertical_scan ) ; } else { ff_init_scantable ( s -> idsp . idct_permutation , & s -> inter_scantable , ff_zigzag_direct ) ; ff_init_scantable ( s -> idsp . idct_permutation , & s -> intra_scantable , ff_zigzag_direct ) ; ff_init_scantable ( s -> idsp . idct_permutation , & s -> intra_h_scantable , ff_alternate_horizontal_scan ) ; ff_init_scantable ( s -> idsp . idct_permutation , & s -> intra_v_scantable , ff_alternate_vertical_scan ) ; } mpeg4_load_default_matrices ( s ) ; next_start_code_studio ( gb ) ; extension_and_user_data ( s , gb , 4 ) ; return 0 ; }\n",
      "fixed_code": "<S2SV_ModStart> ; s -> interlaced_dct = 0 ; s ->\n",
      "source_code_length": 1900,
      "target_code_length": 49,
      "vulnerability_patterns": {
        "null_pointer": 29,
        "total": 29
      },
      "total_patterns": 29,
      "original_address": "https://github.com/FFmpeg/FFmpeg/commit/1f686d023b95219db933394a7704ad9aa5f01cbb",
      "discovery_time": "2019-04-19T00:29Z",
      "project_commit_id": "FFmpeg@FFmpeg/1f686d023b95219db933394a7704ad9aa5f01cbb",
      "extraction_time": "2025-08-31T15:41:49.182726",
      "label": 1,
      "vulnerability_type": "out-of-bounds_read",
      "difficulty_level": "advanced",
      "risk_factors": [
        "information_disclosure",
        "memory_corruption",
        "integer_overflow",
        "critical_infrastructure"
      ],
      "attack_vectors": [
        "memory_manipulation",
        "malicious_input",
        "code_analysis",
        "buffer_overflow",
        "reverse_engineering",
        "fuzzing"
      ],
      "mitigation_strategies": [
        "safe_string_functions",
        "dynamic_analysis",
        "code_review",
        "static_analysis",
        "memory_safety_checks",
        "input_validation",
        "fuzzing",
        "bounds_checking",
        "secure_coding_practices"
      ],
      "code_differences": {
        "has_differences": true,
        "source_lines": 2,
        "target_lines": 2,
        "character_differences": 1851,
        "similarity_percentage": 6.8493150684931505
      },
      "vulnerability_location": {
        "vulnerability_present": true,
        "fix_applied": true,
        "code_changed": true,
        "estimated_lines_changed": 0
      }
    },
    {
      "cve_id": "CVE-2016-1246",
      "cwe_id": "CWE-119",
      "cwe_name": "Buffer Overflow",
      "project": "perl5-dbi",
      "severity": "critical",
      "weaponization_score": 8.5,
      "is_critical": true,
      "is_weaponizable": true,
      "is_high_priority_project": false,
      "vulnerable_code": "CWE-119 int dbd_bind_ph ( SV * sth , imp_sth_t * imp_sth , SV * param , SV * value , IV sql_type , SV * attribs , int is_inout , IV maxlen ) { dTHX ; int rc ; int param_num = SvIV ( param ) ; int idx = param_num - 1 ; <S2SV_StartBug> char err_msg [ 64 ] ; <S2SV_EndBug> D_imp_xxh ( sth ) ; # if MYSQL_VERSION_ID >= SERVER_PREPARE_VERSION STRLEN slen ; char * buffer = NULL ; int buffer_is_null = 0 ; int buffer_length = slen ; unsigned int buffer_type = 0 ; IV tmp ; # endif D_imp_dbh_from_sth ; ASYNC_CHECK_RETURN ( sth , FALSE ) ; if ( DBIc_TRACE_LEVEL ( imp_xxh ) >= 2 ) PerlIO_printf ( DBIc_LOGPIO ( imp_xxh ) , \"<S2SV_blank><S2SV_blank><S2SV_blank>Called:<S2SV_blank>dbd_bind_ph\\\\n\" ) ; attribs = attribs ; maxlen = maxlen ; if ( param_num <= 0 || param_num > DBIc_NUM_PARAMS ( imp_sth ) ) { do_error ( sth , JW_ERR_ILLEGAL_PARAM_NUM , \"Illegal<S2SV_blank>parameter<S2SV_blank>number\" , NULL ) ; return FALSE ; } if ( SvOK ( value ) && ( sql_type == SQL_NUMERIC || sql_type == SQL_DECIMAL || sql_type == SQL_INTEGER || sql_type == SQL_SMALLINT || sql_type == SQL_FLOAT || sql_type == SQL_REAL || sql_type == SQL_DOUBLE ) ) { if ( ! looks_like_number ( value ) ) { <S2SV_StartBug> sprintf ( err_msg , <S2SV_EndBug> \"Binding<S2SV_blank>non-numeric<S2SV_blank>field<S2SV_blank>%d,<S2SV_blank>value<S2SV_blank>%s<S2SV_blank>as<S2SV_blank>a<S2SV_blank>numeric!\" , <S2SV_StartBug> param_num , neatsvpv ( value , 0 ) ) ; <S2SV_EndBug> do_error ( sth , JW_ERR_ILLEGAL_PARAM_NUM , err_msg , NULL ) ; } } if ( is_inout ) { do_error ( sth , JW_ERR_NOT_IMPLEMENTED , \"Output<S2SV_blank>parameters<S2SV_blank>not<S2SV_blank>implemented\" , NULL ) ; return FALSE ; } rc = bind_param ( & imp_sth -> params [ idx ] , value , sql_type ) ; # if MYSQL_VERSION_ID >= SERVER_PREPARE_VERSION if ( imp_sth -> use_server_side_prepare ) { switch ( sql_type ) { case SQL_NUMERIC : case SQL_INTEGER : case SQL_SMALLINT : case SQL_BIGINT : case SQL_TINYINT : buffer_type = MYSQL_TYPE_LONG ; break ; case SQL_DOUBLE : case SQL_DECIMAL : case SQL_FLOAT : case SQL_REAL : buffer_type = MYSQL_TYPE_DOUBLE ; break ; case SQL_CHAR : case SQL_VARCHAR : case SQL_DATE : case SQL_TIME : case SQL_TIMESTAMP : case SQL_LONGVARCHAR : case SQL_BINARY : case SQL_VARBINARY : case SQL_LONGVARBINARY : buffer_type = MYSQL_TYPE_BLOB ; break ; default : buffer_type = MYSQL_TYPE_STRING ; } buffer_is_null = ! ( SvOK ( imp_sth -> params [ idx ] . value ) && imp_sth -> params [ idx ] . value ) ; if ( ! buffer_is_null ) { switch ( buffer_type ) { case MYSQL_TYPE_LONG : if ( ! SvIOK ( imp_sth -> params [ idx ] . value ) && DBIc_TRACE_LEVEL ( imp_xxh ) >= 2 ) PerlIO_printf ( DBIc_LOGPIO ( imp_xxh ) , \"\\\\t\\\\tTRY<S2SV_blank>TO<S2SV_blank>BIND<S2SV_blank>AN<S2SV_blank>INT<S2SV_blank>NUMBER\\\\n\" ) ; buffer_length = sizeof imp_sth -> fbind [ idx ] . numeric_val . lval ; tmp = SvIV ( imp_sth -> params [ idx ] . value ) ; if ( tmp > INT32_MAX ) croak ( \"Could<S2SV_blank>not<S2SV_blank>bind<S2SV_blank>%ld:<S2SV_blank>Integer<S2SV_blank>too<S2SV_blank>large<S2SV_blank>for<S2SV_blank>MYSQL_TYPE_LONG\" , tmp ) ; imp_sth -> fbind [ idx ] . numeric_val . lval = tmp ; buffer = ( void * ) & ( imp_sth -> fbind [ idx ] . numeric_val . lval ) ; if ( DBIc_TRACE_LEVEL ( imp_xxh ) >= 2 ) PerlIO_printf ( DBIc_LOGPIO ( imp_xxh ) , \"<S2SV_blank><S2SV_blank><S2SV_blank>SCALAR<S2SV_blank>type<S2SV_blank>%d<S2SV_blank>->%\" PRId32 \"<-<S2SV_blank>IS<S2SV_blank>A<S2SV_blank>INT<S2SV_blank>NUMBER\\\\n\" , ( int ) sql_type , * ( int32_t * ) buffer ) ; break ; case MYSQL_TYPE_DOUBLE : if ( ! SvNOK ( imp_sth -> params [ idx ] . value ) && DBIc_TRACE_LEVEL ( imp_xxh ) >= 2 ) PerlIO_printf ( DBIc_LOGPIO ( imp_xxh ) , \"\\\\t\\\\tTRY<S2SV_blank>TO<S2SV_blank>BIND<S2SV_blank>A<S2SV_blank>FLOAT<S2SV_blank>NUMBER\\\\n\" ) ; buffer_length = sizeof imp_sth -> fbind [ idx ] . numeric_val . dval ; imp_sth -> fbind [ idx ] . numeric_val . dval = SvNV ( imp_sth -> params [ idx ] . value ) ; buffer = ( char * ) & ( imp_sth -> fbind [ idx ] . numeric_val . dval ) ; if ( DBIc_TRACE_LEVEL ( imp_xxh ) >= 2 ) PerlIO_printf ( DBIc_LOGPIO ( imp_xxh ) , \"<S2SV_blank><S2SV_blank><S2SV_blank>SCALAR<S2SV_blank>type<S2SV_blank>%d<S2SV_blank>->%f<-<S2SV_blank>IS<S2SV_blank>A<S2SV_blank>FLOAT<S2SV_blank>NUMBER\\\\n\" , ( int ) sql_type , ( double ) ( * buffer ) ) ; break ; case MYSQL_TYPE_BLOB : if ( DBIc_TRACE_LEVEL ( imp_xxh ) >= 2 ) PerlIO_printf ( DBIc_LOGPIO ( imp_xxh ) , \"<S2SV_blank><S2SV_blank><S2SV_blank>SCALAR<S2SV_blank>type<S2SV_blank>BLOB\\\\n\" ) ; break ; case MYSQL_TYPE_STRING : if ( DBIc_TRACE_LEVEL ( imp_xxh ) >= 2 ) PerlIO_printf ( DBIc_LOGPIO ( imp_xxh ) , \"<S2SV_blank><S2SV_blank><S2SV_blank>SCALAR<S2SV_blank>type<S2SV_blank>STRING<S2SV_blank>%d,<S2SV_blank>buffertype=%d\\\\n\" , ( int ) sql_type , buffer_type ) ; break ; default : croak ( \"Bug<S2SV_blank>in<S2SV_blank>DBD::Mysql<S2SV_blank>file<S2SV_blank>dbdimp.c#dbd_bind_ph:<S2SV_blank>do<S2SV_blank>not<S2SV_blank>know<S2SV_blank>how<S2SV_blank>to<S2SV_blank>handle<S2SV_blank>unknown<S2SV_blank>buffer<S2SV_blank>type.\" ) ; } if ( buffer_type == MYSQL_TYPE_STRING || buffer_type == MYSQL_TYPE_BLOB ) { buffer = SvPV ( imp_sth -> params [ idx ] . value , slen ) ; buffer_length = slen ; if ( DBIc_TRACE_LEVEL ( imp_xxh ) >= 2 ) PerlIO_printf ( DBIc_LOGPIO ( imp_xxh ) , \"<S2SV_blank>SCALAR<S2SV_blank>type<S2SV_blank>%d<S2SV_blank>->length<S2SV_blank>%d<-<S2SV_blank>IS<S2SV_blank>A<S2SV_blank>STRING<S2SV_blank>or<S2SV_blank>BLOB\\\\n\" , ( int ) sql_type , buffer_length ) ; } } else { buffer = NULL ; if ( DBIc_TRACE_LEVEL ( imp_xxh ) >= 2 ) PerlIO_printf ( DBIc_LOGPIO ( imp_xxh ) , \"<S2SV_blank><S2SV_blank><S2SV_blank>SCALAR<S2SV_blank>NULL<S2SV_blank>VALUE:<S2SV_blank>buffer<S2SV_blank>type<S2SV_blank>is:<S2SV_blank>%d\\\\n\" , buffer_type ) ; } if ( imp_sth -> bind [ idx ] . buffer_type != buffer_type ) { if ( DBIc_TRACE_LEVEL ( imp_xxh ) >= 2 ) PerlIO_printf ( DBIc_LOGPIO ( imp_xxh ) , \"<S2SV_blank><S2SV_blank><S2SV_blank>FORCE<S2SV_blank>REBIND:<S2SV_blank>buffer<S2SV_blank>type<S2SV_blank>changed<S2SV_blank>from<S2SV_blank>%d<S2SV_blank>to<S2SV_blank>%d,<S2SV_blank>sql-type=%d\\\\n\" , ( int ) imp_sth -> bind [ idx ] . buffer_type , buffer_type , ( int ) sql_type ) ; imp_sth -> has_been_bound = 0 ; } if ( imp_sth -> has_been_bound == 0 ) { imp_sth -> bind [ idx ] . buffer_type = buffer_type ; imp_sth -> bind [ idx ] . buffer = buffer ; imp_sth -> bind [ idx ] . buffer_length = buffer_length ; } else { imp_sth -> stmt -> params [ idx ] . buffer = buffer ; imp_sth -> stmt -> params [ idx ] . buffer_length = buffer_length ; } imp_sth -> fbind [ idx ] . length = buffer_length ; imp_sth -> fbind [ idx ] . is_null = buffer_is_null ; } # endif return rc ; }\n",
      "fixed_code": "<S2SV_ModStart> 1 ; char * err_msg <S2SV_ModEnd> ; D_imp_xxh ( <S2SV_ModStart> ) ) { err_msg = SvPVX ( sv_2mortal ( newSVpvf ( <S2SV_ModEnd> \"Binding<S2SV_blank>non-numeric<S2SV_blank>field<S2SV_blank>%d,<S2SV_blank>value<S2SV_blank>%s<S2SV_blank>as<S2SV_blank>a<S2SV_blank>numeric!\" , param_num <S2SV_ModStart> value , 0 ) )\n",
      "source_code_length": 6668,
      "target_code_length": 326,
      "vulnerability_patterns": {
        "buffer_overflow": 1,
        "format_string": 1,
        "null_pointer": 31,
        "total": 33
      },
      "total_patterns": 33,
      "original_address": "https://github.com/perl5-dbi/DBD-mysql/commit/7c164a0c86cec6ee95df1d141e67b0e85dfdefd2",
      "discovery_time": "2016-10-05T16:59Z",
      "project_commit_id": "perl5-dbi@DBD-mysql/7c164a0c86cec6ee95df1d141e67b0e85dfdefd2",
      "extraction_time": "2025-08-31T15:41:49.182756",
      "label": 1,
      "vulnerability_type": "buffer_overflow",
      "difficulty_level": "advanced",
      "risk_factors": [
        "system_crash",
        "memory_corruption",
        "buffer_overflow",
        "arbitrary_code_execution"
      ],
      "attack_vectors": [
        "memory_manipulation",
        "malicious_input",
        "code_analysis",
        "buffer_overflow",
        "reverse_engineering",
        "fuzzing"
      ],
      "mitigation_strategies": [
        "safe_string_functions",
        "dynamic_analysis",
        "code_review",
        "static_analysis",
        "memory_safety_checks",
        "input_validation",
        "fuzzing",
        "bounds_checking",
        "secure_coding_practices"
      ],
      "code_differences": {
        "has_differences": true,
        "source_lines": 2,
        "target_lines": 2,
        "character_differences": 6342,
        "similarity_percentage": 9.868421052631579
      },
      "vulnerability_location": {
        "vulnerability_present": true,
        "fix_applied": true,
        "code_changed": true,
        "estimated_lines_changed": 0
      }
    },
    {
      "cve_id": "CVE-2016-1621",
      "cwe_id": "CWE-119",
      "cwe_name": "Buffer Overflow",
      "project": "external",
      "severity": "critical",
      "weaponization_score": 8.5,
      "is_critical": true,
      "is_weaponizable": true,
      "is_high_priority_project": false,
      "vulnerable_code": "CWE-119 int main ( int argc , char * * argv ) { int frame_cnt = 0 ; FILE * outfile = NULL ; vpx_codec_ctx_t codec ; const VpxInterface * decoder = NULL ; VpxVideoReader * reader = NULL ; const VpxVideoInfo * info = NULL ; int n = 0 ; int m = 0 ; int is_range = 0 ; char * nptr = NULL ; exec_name = argv [ 0 ] ; if ( argc != 4 ) die ( \"Invalid<S2SV_blank>number<S2SV_blank>of<S2SV_blank>arguments.\" ) ; reader = vpx_video_reader_open ( argv [ 1 ] ) ; if ( ! reader ) die ( \"Failed<S2SV_blank>to<S2SV_blank>open<S2SV_blank>%s<S2SV_blank>for<S2SV_blank>reading.\" , argv [ 1 ] ) ; if ( ! ( outfile = fopen ( argv [ 2 ] , \"wb\" ) ) ) die ( \"Failed<S2SV_blank>to<S2SV_blank>open<S2SV_blank>%s<S2SV_blank>for<S2SV_blank>writing.\" , argv [ 2 ] ) ; n = strtol ( argv [ 3 ] , & nptr , 0 ) ; m = strtol ( nptr + 1 , NULL , 0 ) ; is_range = ( * nptr == '-' ) ; if ( ! n || ! m || ( * nptr != '-' && * nptr != '/' ) ) die ( \"Couldn\\'t<S2SV_blank>parse<S2SV_blank>pattern<S2SV_blank>%s.\\\\n\" , argv [ 3 ] ) ; info = vpx_video_reader_get_info ( reader ) ; decoder = get_vpx_decoder_by_fourcc ( info -> codec_fourcc ) ; if ( ! decoder ) die ( \"Unknown<S2SV_blank>input<S2SV_blank>codec.\" ) ; <S2SV_StartBug> printf ( \"Using<S2SV_blank>%s\\\\n\" , vpx_codec_iface_name ( decoder -> interface ( ) ) ) ; <S2SV_EndBug> <S2SV_StartBug> if ( vpx_codec_dec_init ( & codec , decoder -> interface ( ) , NULL , 0 ) ) <S2SV_EndBug> die_codec ( & codec , \"Failed<S2SV_blank>to<S2SV_blank>initialize<S2SV_blank>decoder.\" ) ; while ( vpx_video_reader_read_frame ( reader ) ) { vpx_codec_iter_t iter = NULL ; vpx_image_t * img = NULL ; size_t frame_size = 0 ; int skip ; const unsigned char * frame = vpx_video_reader_get_frame ( reader , & frame_size ) ; if ( vpx_codec_decode ( & codec , frame , ( unsigned int ) frame_size , NULL , 0 ) ) die_codec ( & codec , \"Failed<S2SV_blank>to<S2SV_blank>decode<S2SV_blank>frame.\" ) ; ++ frame_cnt ; skip = ( is_range && frame_cnt >= n && frame_cnt <= m ) || ( ! is_range && m - ( frame_cnt - 1 ) % m <= n ) ; if ( ! skip ) { putc ( '.' , stdout ) ; while ( ( img = vpx_codec_get_frame ( & codec , & iter ) ) != NULL ) vpx_img_write ( img , outfile ) ; } else { putc ( 'X' , stdout ) ; } fflush ( stdout ) ; } printf ( \"Processed<S2SV_blank>%d<S2SV_blank>frames.\\\\n\" , frame_cnt ) ; if ( vpx_codec_destroy ( & codec ) ) die_codec ( & codec , \"Failed<S2SV_blank>to<S2SV_blank>destroy<S2SV_blank>codec.\" ) ; printf ( \"Play:<S2SV_blank>ffplay<S2SV_blank>-f<S2SV_blank>rawvideo<S2SV_blank>-pix_fmt<S2SV_blank>yuv420p<S2SV_blank>-s<S2SV_blank>%dx%d<S2SV_blank>%s\\\\n\" , info -> frame_width , info -> frame_height , argv [ 2 ] ) ; vpx_video_reader_close ( reader ) ; fclose ( outfile ) ; return EXIT_SUCCESS ; }\n",
      "fixed_code": "<S2SV_ModStart> ( decoder -> codec_interface <S2SV_ModEnd> ( ) ) <S2SV_ModStart> , decoder -> codec_interface <S2SV_ModEnd> ( ) ,\n",
      "source_code_length": 2710,
      "target_code_length": 130,
      "vulnerability_patterns": {
        "use_after_free": 4,
        "null_pointer": 8,
        "total": 12
      },
      "total_patterns": 12,
      "original_address": "https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426",
      "discovery_time": "2016-03-12T21:59Z",
      "project_commit_id": "external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426",
      "extraction_time": "2025-08-31T15:41:49.182802",
      "label": 1,
      "vulnerability_type": "buffer_overflow",
      "difficulty_level": "advanced",
      "risk_factors": [
        "system_crash",
        "memory_corruption",
        "arbitrary_code_execution",
        "use_after_free"
      ],
      "attack_vectors": [
        "memory_manipulation",
        "malicious_input",
        "code_analysis",
        "buffer_overflow",
        "reverse_engineering",
        "fuzzing"
      ],
      "mitigation_strategies": [
        "safe_string_functions",
        "dynamic_analysis",
        "code_review",
        "static_analysis",
        "memory_safety_checks",
        "input_validation",
        "fuzzing",
        "bounds_checking",
        "secure_coding_practices"
      ],
      "code_differences": {
        "has_differences": true,
        "source_lines": 2,
        "target_lines": 2,
        "character_differences": 2580,
        "similarity_percentage": 4.464285714285714
      },
      "vulnerability_location": {
        "vulnerability_present": true,
        "fix_applied": true,
        "code_changed": true,
        "estimated_lines_changed": 0
      }
    },
    {
      "cve_id": "CVE-2016-1621",
      "cwe_id": "CWE-119",
      "cwe_name": "Buffer Overflow",
      "project": "external",
      "severity": "critical",
      "weaponization_score": 8.5,
      "is_critical": true,
      "is_weaponizable": true,
      "is_high_priority_project": false,
      "vulnerable_code": "CWE-119 int main ( int argc , char * * argv ) { int frame_cnt = 0 ; FILE * outfile = NULL ; vpx_codec_ctx_t codec ; const VpxInterface * decoder = NULL ; VpxVideoReader * reader = NULL ; const VpxVideoInfo * info = NULL ; int n = 0 ; int m = 0 ; int is_range = 0 ; char * nptr = NULL ; exec_name = argv [ 0 ] ; if ( argc != 4 ) die ( \"Invalid<S2SV_blank>number<S2SV_blank>of<S2SV_blank>arguments.\" ) ; reader = vpx_video_reader_open ( argv [ 1 ] ) ; if ( ! reader ) die ( \"Failed<S2SV_blank>to<S2SV_blank>open<S2SV_blank>%s<S2SV_blank>for<S2SV_blank>reading.\" , argv [ 1 ] ) ; if ( ! ( outfile = fopen ( argv [ 2 ] , \"wb\" ) ) ) die ( \"Failed<S2SV_blank>to<S2SV_blank>open<S2SV_blank>%s<S2SV_blank>for<S2SV_blank>writing.\" , argv [ 2 ] ) ; n = strtol ( argv [ 3 ] , & nptr , 0 ) ; m = strtol ( nptr + 1 , NULL , 0 ) ; is_range = ( * nptr == '-' ) ; if ( ! n || ! m || ( * nptr != '-' && * nptr != '/' ) ) die ( \"Couldn\\'t<S2SV_blank>parse<S2SV_blank>pattern<S2SV_blank>%s.\\\\n\" , argv [ 3 ] ) ; info = vpx_video_reader_get_info ( reader ) ; decoder = get_vpx_decoder_by_fourcc ( info -> codec_fourcc ) ; if ( ! decoder ) die ( \"Unknown<S2SV_blank>input<S2SV_blank>codec.\" ) ; <S2SV_StartBug> printf ( \"Using<S2SV_blank>%s\\\\n\" , vpx_codec_iface_name ( decoder -> interface ( ) ) ) ; <S2SV_EndBug> <S2SV_StartBug> if ( vpx_codec_dec_init ( & codec , decoder -> interface ( ) , NULL , 0 ) ) <S2SV_EndBug> die_codec ( & codec , \"Failed<S2SV_blank>to<S2SV_blank>initialize<S2SV_blank>decoder.\" ) ; while ( vpx_video_reader_read_frame ( reader ) ) { vpx_codec_iter_t iter = NULL ; vpx_image_t * img = NULL ; size_t frame_size = 0 ; int skip ; const unsigned char * frame = vpx_video_reader_get_frame ( reader , & frame_size ) ; if ( vpx_codec_decode ( & codec , frame , ( unsigned int ) frame_size , NULL , 0 ) ) die_codec ( & codec , \"Failed<S2SV_blank>to<S2SV_blank>decode<S2SV_blank>frame.\" ) ; ++ frame_cnt ; skip = ( is_range && frame_cnt >= n && frame_cnt <= m ) || ( ! is_range && m - ( frame_cnt - 1 ) % m <= n ) ; if ( ! skip ) { putc ( '.' , stdout ) ; while ( ( img = vpx_codec_get_frame ( & codec , & iter ) ) != NULL ) vpx_img_write ( img , outfile ) ; } else { putc ( 'X' , stdout ) ; } fflush ( stdout ) ; } printf ( \"Processed<S2SV_blank>%d<S2SV_blank>frames.\\\\n\" , frame_cnt ) ; if ( vpx_codec_destroy ( & codec ) ) die_codec ( & codec , \"Failed<S2SV_blank>to<S2SV_blank>destroy<S2SV_blank>codec.\" ) ; printf ( \"Play:<S2SV_blank>ffplay<S2SV_blank>-f<S2SV_blank>rawvideo<S2SV_blank>-pix_fmt<S2SV_blank>yuv420p<S2SV_blank>-s<S2SV_blank>%dx%d<S2SV_blank>%s\\\\n\" , info -> frame_width , info -> frame_height , argv [ 2 ] ) ; vpx_video_reader_close ( reader ) ; fclose ( outfile ) ; return EXIT_SUCCESS ; }\n",
      "fixed_code": "<S2SV_ModStart> ( decoder -> codec_interface <S2SV_ModEnd> ( ) ) <S2SV_ModStart> , decoder -> codec_interface <S2SV_ModEnd> ( ) ,\n",
      "source_code_length": 2710,
      "target_code_length": 130,
      "vulnerability_patterns": {
        "buffer_overflow": 1,
        "integer_overflow": 2,
        "null_pointer": 34,
        "total": 37
      },
      "total_patterns": 37,
      "original_address": "https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426",
      "discovery_time": "2016-03-12T21:59Z",
      "project_commit_id": "external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426",
      "extraction_time": "2025-08-31T15:41:49.182819",
      "label": 1,
      "vulnerability_type": "buffer_overflow",
      "difficulty_level": "advanced",
      "risk_factors": [
        "system_crash",
        "memory_corruption",
        "buffer_overflow",
        "arbitrary_code_execution"
      ],
      "attack_vectors": [
        "memory_manipulation",
        "malicious_input",
        "code_analysis",
        "buffer_overflow",
        "reverse_engineering",
        "fuzzing"
      ],
      "mitigation_strategies": [
        "safe_string_functions",
        "dynamic_analysis",
        "code_review",
        "static_analysis",
        "memory_safety_checks",
        "input_validation",
        "fuzzing",
        "bounds_checking",
        "secure_coding_practices"
      ],
      "code_differences": {
        "has_differences": true,
        "source_lines": 2,
        "target_lines": 2,
        "character_differences": 2580,
        "similarity_percentage": 4.464285714285714
      },
      "vulnerability_location": {
        "vulnerability_present": true,
        "fix_applied": true,
        "code_changed": true,
        "estimated_lines_changed": 0
      }
    },
    {
      "cve_id": "CVE-2016-1621",
      "cwe_id": "CWE-119",
      "cwe_name": "Buffer Overflow",
      "project": "external",
      "severity": "critical",
      "weaponization_score": 8.5,
      "is_critical": true,
      "is_weaponizable": true,
      "is_high_priority_project": false,
      "vulnerable_code": "CWE-119 int main ( int argc , char * * argv ) { int frame_cnt = 0 ; FILE * outfile = NULL ; vpx_codec_ctx_t codec ; const VpxInterface * decoder = NULL ; VpxVideoReader * reader = NULL ; const VpxVideoInfo * info = NULL ; int n = 0 ; int m = 0 ; int is_range = 0 ; char * nptr = NULL ; exec_name = argv [ 0 ] ; if ( argc != 4 ) die ( \"Invalid<S2SV_blank>number<S2SV_blank>of<S2SV_blank>arguments.\" ) ; reader = vpx_video_reader_open ( argv [ 1 ] ) ; if ( ! reader ) die ( \"Failed<S2SV_blank>to<S2SV_blank>open<S2SV_blank>%s<S2SV_blank>for<S2SV_blank>reading.\" , argv [ 1 ] ) ; if ( ! ( outfile = fopen ( argv [ 2 ] , \"wb\" ) ) ) die ( \"Failed<S2SV_blank>to<S2SV_blank>open<S2SV_blank>%s<S2SV_blank>for<S2SV_blank>writing.\" , argv [ 2 ] ) ; n = strtol ( argv [ 3 ] , & nptr , 0 ) ; m = strtol ( nptr + 1 , NULL , 0 ) ; is_range = ( * nptr == '-' ) ; if ( ! n || ! m || ( * nptr != '-' && * nptr != '/' ) ) die ( \"Couldn\\'t<S2SV_blank>parse<S2SV_blank>pattern<S2SV_blank>%s.\\\\n\" , argv [ 3 ] ) ; info = vpx_video_reader_get_info ( reader ) ; decoder = get_vpx_decoder_by_fourcc ( info -> codec_fourcc ) ; if ( ! decoder ) die ( \"Unknown<S2SV_blank>input<S2SV_blank>codec.\" ) ; <S2SV_StartBug> printf ( \"Using<S2SV_blank>%s\\\\n\" , vpx_codec_iface_name ( decoder -> interface ( ) ) ) ; <S2SV_EndBug> <S2SV_StartBug> if ( vpx_codec_dec_init ( & codec , decoder -> interface ( ) , NULL , 0 ) ) <S2SV_EndBug> die_codec ( & codec , \"Failed<S2SV_blank>to<S2SV_blank>initialize<S2SV_blank>decoder.\" ) ; while ( vpx_video_reader_read_frame ( reader ) ) { vpx_codec_iter_t iter = NULL ; vpx_image_t * img = NULL ; size_t frame_size = 0 ; int skip ; const unsigned char * frame = vpx_video_reader_get_frame ( reader , & frame_size ) ; if ( vpx_codec_decode ( & codec , frame , ( unsigned int ) frame_size , NULL , 0 ) ) die_codec ( & codec , \"Failed<S2SV_blank>to<S2SV_blank>decode<S2SV_blank>frame.\" ) ; ++ frame_cnt ; skip = ( is_range && frame_cnt >= n && frame_cnt <= m ) || ( ! is_range && m - ( frame_cnt - 1 ) % m <= n ) ; if ( ! skip ) { putc ( '.' , stdout ) ; while ( ( img = vpx_codec_get_frame ( & codec , & iter ) ) != NULL ) vpx_img_write ( img , outfile ) ; } else { putc ( 'X' , stdout ) ; } fflush ( stdout ) ; } printf ( \"Processed<S2SV_blank>%d<S2SV_blank>frames.\\\\n\" , frame_cnt ) ; if ( vpx_codec_destroy ( & codec ) ) die_codec ( & codec , \"Failed<S2SV_blank>to<S2SV_blank>destroy<S2SV_blank>codec.\" ) ; printf ( \"Play:<S2SV_blank>ffplay<S2SV_blank>-f<S2SV_blank>rawvideo<S2SV_blank>-pix_fmt<S2SV_blank>yuv420p<S2SV_blank>-s<S2SV_blank>%dx%d<S2SV_blank>%s\\\\n\" , info -> frame_width , info -> frame_height , argv [ 2 ] ) ; vpx_video_reader_close ( reader ) ; fclose ( outfile ) ; return EXIT_SUCCESS ; }\n",
      "fixed_code": "<S2SV_ModStart> ( decoder -> codec_interface <S2SV_ModEnd> ( ) ) <S2SV_ModStart> , decoder -> codec_interface <S2SV_ModEnd> ( ) ,\n",
      "source_code_length": 2710,
      "target_code_length": 130,
      "vulnerability_patterns": {
        "buffer_overflow": 2,
        "integer_overflow": 2,
        "null_pointer": 7,
        "total": 11
      },
      "total_patterns": 11,
      "original_address": "https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426",
      "discovery_time": "2016-03-12T21:59Z",
      "project_commit_id": "external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426",
      "extraction_time": "2025-08-31T15:41:49.182834",
      "label": 1,
      "vulnerability_type": "buffer_overflow",
      "difficulty_level": "advanced",
      "risk_factors": [
        "system_crash",
        "memory_corruption",
        "buffer_overflow",
        "arbitrary_code_execution"
      ],
      "attack_vectors": [
        "memory_manipulation",
        "malicious_input",
        "code_analysis",
        "buffer_overflow",
        "reverse_engineering",
        "fuzzing"
      ],
      "mitigation_strategies": [
        "safe_string_functions",
        "dynamic_analysis",
        "code_review",
        "static_analysis",
        "memory_safety_checks",
        "input_validation",
        "fuzzing",
        "bounds_checking",
        "secure_coding_practices"
      ],
      "code_differences": {
        "has_differences": true,
        "source_lines": 2,
        "target_lines": 2,
        "character_differences": 2580,
        "similarity_percentage": 4.464285714285714
      },
      "vulnerability_location": {
        "vulnerability_present": true,
        "fix_applied": true,
        "code_changed": true,
        "estimated_lines_changed": 0
      }
    },
    {
      "cve_id": "CVE-2016-1621",
      "cwe_id": "CWE-119",
      "cwe_name": "Buffer Overflow",
      "project": "external",
      "severity": "critical",
      "weaponization_score": 8.5,
      "is_critical": true,
      "is_weaponizable": true,
      "is_high_priority_project": false,
      "vulnerable_code": "CWE-119 int main ( int argc , char * * argv ) { int frame_cnt = 0 ; FILE * outfile = NULL ; vpx_codec_ctx_t codec ; const VpxInterface * decoder = NULL ; VpxVideoReader * reader = NULL ; const VpxVideoInfo * info = NULL ; int n = 0 ; int m = 0 ; int is_range = 0 ; char * nptr = NULL ; exec_name = argv [ 0 ] ; if ( argc != 4 ) die ( \"Invalid<S2SV_blank>number<S2SV_blank>of<S2SV_blank>arguments.\" ) ; reader = vpx_video_reader_open ( argv [ 1 ] ) ; if ( ! reader ) die ( \"Failed<S2SV_blank>to<S2SV_blank>open<S2SV_blank>%s<S2SV_blank>for<S2SV_blank>reading.\" , argv [ 1 ] ) ; if ( ! ( outfile = fopen ( argv [ 2 ] , \"wb\" ) ) ) die ( \"Failed<S2SV_blank>to<S2SV_blank>open<S2SV_blank>%s<S2SV_blank>for<S2SV_blank>writing.\" , argv [ 2 ] ) ; n = strtol ( argv [ 3 ] , & nptr , 0 ) ; m = strtol ( nptr + 1 , NULL , 0 ) ; is_range = ( * nptr == '-' ) ; if ( ! n || ! m || ( * nptr != '-' && * nptr != '/' ) ) die ( \"Couldn\\'t<S2SV_blank>parse<S2SV_blank>pattern<S2SV_blank>%s.\\\\n\" , argv [ 3 ] ) ; info = vpx_video_reader_get_info ( reader ) ; decoder = get_vpx_decoder_by_fourcc ( info -> codec_fourcc ) ; if ( ! decoder ) die ( \"Unknown<S2SV_blank>input<S2SV_blank>codec.\" ) ; <S2SV_StartBug> printf ( \"Using<S2SV_blank>%s\\\\n\" , vpx_codec_iface_name ( decoder -> interface ( ) ) ) ; <S2SV_EndBug> <S2SV_StartBug> if ( vpx_codec_dec_init ( & codec , decoder -> interface ( ) , NULL , 0 ) ) <S2SV_EndBug> die_codec ( & codec , \"Failed<S2SV_blank>to<S2SV_blank>initialize<S2SV_blank>decoder.\" ) ; while ( vpx_video_reader_read_frame ( reader ) ) { vpx_codec_iter_t iter = NULL ; vpx_image_t * img = NULL ; size_t frame_size = 0 ; int skip ; const unsigned char * frame = vpx_video_reader_get_frame ( reader , & frame_size ) ; if ( vpx_codec_decode ( & codec , frame , ( unsigned int ) frame_size , NULL , 0 ) ) die_codec ( & codec , \"Failed<S2SV_blank>to<S2SV_blank>decode<S2SV_blank>frame.\" ) ; ++ frame_cnt ; skip = ( is_range && frame_cnt >= n && frame_cnt <= m ) || ( ! is_range && m - ( frame_cnt - 1 ) % m <= n ) ; if ( ! skip ) { putc ( '.' , stdout ) ; while ( ( img = vpx_codec_get_frame ( & codec , & iter ) ) != NULL ) vpx_img_write ( img , outfile ) ; } else { putc ( 'X' , stdout ) ; } fflush ( stdout ) ; } printf ( \"Processed<S2SV_blank>%d<S2SV_blank>frames.\\\\n\" , frame_cnt ) ; if ( vpx_codec_destroy ( & codec ) ) die_codec ( & codec , \"Failed<S2SV_blank>to<S2SV_blank>destroy<S2SV_blank>codec.\" ) ; printf ( \"Play:<S2SV_blank>ffplay<S2SV_blank>-f<S2SV_blank>rawvideo<S2SV_blank>-pix_fmt<S2SV_blank>yuv420p<S2SV_blank>-s<S2SV_blank>%dx%d<S2SV_blank>%s\\\\n\" , info -> frame_width , info -> frame_height , argv [ 2 ] ) ; vpx_video_reader_close ( reader ) ; fclose ( outfile ) ; return EXIT_SUCCESS ; }\n",
      "fixed_code": "<S2SV_ModStart> ( decoder -> codec_interface <S2SV_ModEnd> ( ) ) <S2SV_ModStart> , decoder -> codec_interface <S2SV_ModEnd> ( ) ,\n",
      "source_code_length": 2710,
      "target_code_length": 130,
      "vulnerability_patterns": {
        "use_after_free": 2,
        "integer_overflow": 2,
        "null_pointer": 5,
        "memory_leak": 2,
        "total": 11
      },
      "total_patterns": 11,
      "original_address": "https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426",
      "discovery_time": "2016-03-12T21:59Z",
      "project_commit_id": "external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426",
      "extraction_time": "2025-08-31T15:41:49.182848",
      "label": 1,
      "vulnerability_type": "buffer_overflow",
      "difficulty_level": "advanced",
      "risk_factors": [
        "system_crash",
        "memory_corruption",
        "arbitrary_code_execution",
        "use_after_free"
      ],
      "attack_vectors": [
        "memory_manipulation",
        "malicious_input",
        "code_analysis",
        "buffer_overflow",
        "reverse_engineering",
        "fuzzing"
      ],
      "mitigation_strategies": [
        "safe_string_functions",
        "dynamic_analysis",
        "code_review",
        "static_analysis",
        "memory_safety_checks",
        "input_validation",
        "fuzzing",
        "bounds_checking",
        "secure_coding_practices"
      ],
      "code_differences": {
        "has_differences": true,
        "source_lines": 2,
        "target_lines": 2,
        "character_differences": 2580,
        "similarity_percentage": 4.464285714285714
      },
      "vulnerability_location": {
        "vulnerability_present": true,
        "fix_applied": true,
        "code_changed": true,
        "estimated_lines_changed": 0
      }
    },
    {
      "cve_id": "CVE-2017-8062",
      "cwe_id": "CWE-119",
      "cwe_name": "Buffer Overflow",
      "project": "torvalds",
      "severity": "critical",
      "weaponization_score": 8.5,
      "is_critical": true,
      "is_weaponizable": true,
      "is_high_priority_project": false,
      "vulnerable_code": "CWE-119 static int tt_s2_4600_frontend_attach ( struct dvb_usb_adapter * adap ) { struct dvb_usb_device * d = adap -> dev ; <S2SV_StartBug> struct dw2102_state * state = d -> priv ; <S2SV_EndBug> u8 obuf [ 3 ] = { 0xe , 0x80 , 0 } ; u8 ibuf [ ] = { 0 } ; struct i2c_adapter * i2c_adapter ; struct i2c_client * client ; struct i2c_board_info board_info ; struct m88ds3103_platform_data m88ds3103_pdata = { } ; struct ts2020_config ts2020_config = { } ; <S2SV_StartBug> if ( dvb_usb_generic_rw ( d , obuf , 3 , ibuf , 1 , 0 ) < 0 ) <S2SV_EndBug> err ( \"command<S2SV_blank>0x0e<S2SV_blank>transfer<S2SV_blank>failed.\" ) ; <S2SV_StartBug> obuf [ 0 ] = 0xe ; <S2SV_EndBug> <S2SV_StartBug> obuf [ 1 ] = 0x02 ; <S2SV_EndBug> <S2SV_StartBug> obuf [ 2 ] = 1 ; <S2SV_EndBug> <S2SV_StartBug> if ( dvb_usb_generic_rw ( d , obuf , 3 , ibuf , 1 , 0 ) < 0 ) <S2SV_EndBug> err ( \"command<S2SV_blank>0x0e<S2SV_blank>transfer<S2SV_blank>failed.\" ) ; msleep ( 300 ) ; <S2SV_StartBug> obuf [ 0 ] = 0xe ; <S2SV_EndBug> <S2SV_StartBug> obuf [ 1 ] = 0x83 ; <S2SV_EndBug> <S2SV_StartBug> obuf [ 2 ] = 0 ; <S2SV_EndBug> <S2SV_StartBug> if ( dvb_usb_generic_rw ( d , obuf , 3 , ibuf , 1 , 0 ) < 0 ) <S2SV_EndBug> err ( \"command<S2SV_blank>0x0e<S2SV_blank>transfer<S2SV_blank>failed.\" ) ; <S2SV_StartBug> obuf [ 0 ] = 0xe ; <S2SV_EndBug> <S2SV_StartBug> obuf [ 1 ] = 0x83 ; <S2SV_EndBug> <S2SV_StartBug> obuf [ 2 ] = 1 ; <S2SV_EndBug> <S2SV_StartBug> if ( dvb_usb_generic_rw ( d , obuf , 3 , ibuf , 1 , 0 ) < 0 ) <S2SV_EndBug> err ( \"command<S2SV_blank>0x0e<S2SV_blank>transfer<S2SV_blank>failed.\" ) ; <S2SV_StartBug> obuf [ 0 ] = 0x51 ; <S2SV_EndBug> <S2SV_StartBug> if ( dvb_usb_generic_rw ( d , obuf , 1 , ibuf , 1 , 0 ) < 0 ) <S2SV_EndBug> <S2SV_StartBug> err ( \"command<S2SV_blank>0x51<S2SV_blank>transfer<S2SV_blank>failed.\" ) ; <S2SV_EndBug> m88ds3103_pdata . clk = 27000000 ; m88ds3103_pdata . i2c_wr_max = 33 ; m88ds3103_pdata . ts_mode = M88DS3103_TS_CI ; m88ds3103_pdata . ts_clk = 16000 ; m88ds3103_pdata . ts_clk_pol = 0 ; m88ds3103_pdata . spec_inv = 0 ; m88ds3103_pdata . agc = 0x99 ; m88ds3103_pdata . agc_inv = 0 ; m88ds3103_pdata . clk_out = M88DS3103_CLOCK_OUT_ENABLED ; m88ds3103_pdata . envelope_mode = 0 ; m88ds3103_pdata . lnb_hv_pol = 1 ; m88ds3103_pdata . lnb_en_pol = 0 ; memset ( & board_info , 0 , sizeof ( board_info ) ) ; strlcpy ( board_info . type , \"m88ds3103\" , I2C_NAME_SIZE ) ; board_info . addr = 0x68 ; board_info . platform_data = & m88ds3103_pdata ; request_module ( \"m88ds3103\" ) ; client = i2c_new_device ( & d -> i2c_adap , & board_info ) ; if ( client == NULL || client -> dev . driver == NULL ) return - ENODEV ; if ( ! try_module_get ( client -> dev . driver -> owner ) ) { i2c_unregister_device ( client ) ; return - ENODEV ; } adap -> fe_adap [ 0 ] . fe = m88ds3103_pdata . get_dvb_frontend ( client ) ; i2c_adapter = m88ds3103_pdata . get_i2c_adapter ( client ) ; state -> i2c_client_demod = client ; ts2020_config . fe = adap -> fe_adap [ 0 ] . fe ; memset ( & board_info , 0 , sizeof ( board_info ) ) ; strlcpy ( board_info . type , \"ts2022\" , I2C_NAME_SIZE ) ; board_info . addr = 0x60 ; board_info . platform_data = & ts2020_config ; request_module ( \"ts2020\" ) ; client = i2c_new_device ( i2c_adapter , & board_info ) ; if ( client == NULL || client -> dev . driver == NULL ) { dvb_frontend_detach ( adap -> fe_adap [ 0 ] . fe ) ; return - ENODEV ; } if ( ! try_module_get ( client -> dev . driver -> owner ) ) { i2c_unregister_device ( client ) ; dvb_frontend_detach ( adap -> fe_adap [ 0 ] . fe ) ; return - ENODEV ; } adap -> fe_adap [ 0 ] . fe -> ops . read_signal_strength = adap -> fe_adap [ 0 ] . fe -> ops . tuner_ops . get_rf_strength ; state -> i2c_client_tuner = client ; state -> fe_read_status = adap -> fe_adap [ 0 ] . fe -> ops . read_status ; adap -> fe_adap [ 0 ] . fe -> ops . read_status = tt_s2_4600_read_status ; state -> last_lock = 0 ; return 0 ; }\n",
      "fixed_code": "<S2SV_ModStart> d -> priv <S2SV_ModEnd> ; struct i2c_adapter <S2SV_ModStart> { } ; mutex_lock ( & d -> data_mutex ) ; state -> data [ 0 ] = 0xe ; state -> data [ 1 ] = 0x80 ; state -> data [ 2 ] = 0x0 ; <S2SV_ModStart> ( d , state -> data <S2SV_ModEnd> , 3 , <S2SV_ModStart> , 3 , state -> data <S2SV_ModEnd> , 1 , <S2SV_ModStart> \"command<S2SV_blank>0x0e<S2SV_blank>transfer<S2SV_blank>failed.\" ) ; state -> data <S2SV_ModEnd> [ 0 ] <S2SV_ModStart> = 0xe ; state -> data <S2SV_ModEnd> [ 1 ] <S2SV_ModStart> = 0x02 ; state -> data <S2SV_ModEnd> [ 2 ] <S2SV_ModStart> ( d , state -> data <S2SV_ModEnd> , 3 , <S2SV_ModStart> , 3 , state -> data <S2SV_ModEnd> , 1 , <S2SV_ModStart> 300 ) ; state -> data <S2SV_ModEnd> [ 0 ] <S2SV_ModStart> = 0xe ; state -> data <S2SV_ModEnd> [ 1 ] <S2SV_ModStart> = 0x83 ; state -> data <S2SV_ModEnd> [ 2 ] <S2SV_ModStart> ( d , state -> data <S2SV_ModEnd> , 3 , <S2SV_ModStart> , 3 , state -> data <S2SV_ModEnd> , 1 , <S2SV_ModStart> \"command<S2SV_blank>0x0e<S2SV_blank>transfer<S2SV_blank>failed.\" ) ; state -> data <S2SV_ModEnd> [ 0 ] <S2SV_ModStart> = 0xe ; state -> data <S2SV_ModEnd> [ 1 ] <S2SV_ModStart> = 0x83 ; state -> data <S2SV_ModEnd> [ 2 ] <S2SV_ModStart> ( d , state -> data <S2SV_ModEnd> , 3 , <S2SV_ModStart> , 3 , state -> data <S2SV_ModEnd> , 1 , <S2SV_ModStart> \"command<S2SV_blank>0x0e<S2SV_blank>transfer<S2SV_blank>failed.\" ) ; state -> data <S2SV_ModEnd> [ 0 ] <S2SV_ModStart> ( d , state -> data , 1 , state -> data <S2SV_ModEnd> , 1 , <S2SV_ModStart> err ( \"command<S2SV_blank>0x51<S2SV_blank>transfer<S2SV_blank>failed.\" ) ; mutex_unlock ( & d -> data_mutex\n",
      "source_code_length": 3899,
      "target_code_length": 1617,
      "vulnerability_patterns": {
        "buffer_overflow": 2,
        "null_pointer": 25,
        "total": 27
      },
      "total_patterns": 27,
      "original_address": "https://github.com/torvalds/linux/commit/606142af57dad981b78707234cfbd15f9f7b7125",
      "discovery_time": "2017-04-23T05:59Z",
      "project_commit_id": "torvalds@linux/606142af57dad981b78707234cfbd15f9f7b7125",
      "extraction_time": "2025-08-31T15:41:49.182866",
      "label": 1,
      "vulnerability_type": "buffer_overflow",
      "difficulty_level": "advanced",
      "risk_factors": [
        "system_crash",
        "memory_corruption",
        "buffer_overflow",
        "arbitrary_code_execution"
      ],
      "attack_vectors": [
        "memory_manipulation",
        "malicious_input",
        "code_analysis",
        "buffer_overflow",
        "reverse_engineering",
        "fuzzing"
      ],
      "mitigation_strategies": [
        "safe_string_functions",
        "dynamic_analysis",
        "code_review",
        "static_analysis",
        "memory_safety_checks",
        "input_validation",
        "fuzzing",
        "bounds_checking",
        "secure_coding_practices"
      ],
      "code_differences": {
        "has_differences": true,
        "source_lines": 2,
        "target_lines": 2,
        "character_differences": 2282,
        "similarity_percentage": 22.950819672131146
      },
      "vulnerability_location": {
        "vulnerability_present": true,
        "fix_applied": true,
        "code_changed": true,
        "estimated_lines_changed": 0
      }
    },
    {
      "cve_id": "CVE-2018-20748",
      "cwe_id": "CWE-787",
      "cwe_name": "Out-of-bounds Write",
      "project": "LibVNC",
      "severity": "critical",
      "weaponization_score": 8.5,
      "is_critical": true,
      "is_weaponizable": true,
      "is_high_priority_project": false,
      "vulnerable_code": "CWE-787 rfbBool HandleRFBServerMessage ( rfbClient * client ) { rfbServerToClientMsg msg ; if ( client -> serverPort == - 1 ) client -> vncRec -> readTimestamp = TRUE ; if ( ! ReadFromRFBServer ( client , ( char * ) & msg , 1 ) ) return FALSE ; switch ( msg . type ) { case rfbSetColourMapEntries : { break ; } case rfbFramebufferUpdate : { rfbFramebufferUpdateRectHeader rect ; int linesToRead ; int bytesPerLine ; int i ; if ( ! ReadFromRFBServer ( client , ( ( char * ) & msg . fu ) + 1 , sz_rfbFramebufferUpdateMsg - 1 ) ) return FALSE ; msg . fu . nRects = rfbClientSwap16IfLE ( msg . fu . nRects ) ; for ( i = 0 ; i < msg . fu . nRects ; i ++ ) { if ( ! ReadFromRFBServer ( client , ( char * ) & rect , sz_rfbFramebufferUpdateRectHeader ) ) return FALSE ; rect . encoding = rfbClientSwap32IfLE ( rect . encoding ) ; if ( rect . encoding == rfbEncodingLastRect ) break ; rect . r . x = rfbClientSwap16IfLE ( rect . r . x ) ; rect . r . y = rfbClientSwap16IfLE ( rect . r . y ) ; rect . r . w = rfbClientSwap16IfLE ( rect . r . w ) ; rect . r . h = rfbClientSwap16IfLE ( rect . r . h ) ; if ( rect . encoding == rfbEncodingXCursor || rect . encoding == rfbEncodingRichCursor ) { if ( ! HandleCursorShape ( client , rect . r . x , rect . r . y , rect . r . w , rect . r . h , rect . encoding ) ) { return FALSE ; } continue ; } if ( rect . encoding == rfbEncodingPointerPos ) { if ( ! client -> HandleCursorPos ( client , rect . r . x , rect . r . y ) ) { return FALSE ; } continue ; } if ( rect . encoding == rfbEncodingKeyboardLedState ) { client -> KeyboardLedStateEnabled = 1 ; if ( client -> HandleKeyboardLedState != NULL ) client -> HandleKeyboardLedState ( client , rect . r . x , 0 ) ; client -> CurrentKeyboardLedState = rect . r . x ; continue ; } if ( rect . encoding == rfbEncodingNewFBSize ) { client -> width = rect . r . w ; client -> height = rect . r . h ; client -> updateRect . x = client -> updateRect . y = 0 ; client -> updateRect . w = client -> width ; client -> updateRect . h = client -> height ; if ( ! client -> MallocFrameBuffer ( client ) ) return FALSE ; SendFramebufferUpdateRequest ( client , 0 , 0 , rect . r . w , rect . r . h , FALSE ) ; rfbClientLog ( \"Got<S2SV_blank>new<S2SV_blank>framebuffer<S2SV_blank>size:<S2SV_blank>%dx%d\\\\n\" , rect . r . w , rect . r . h ) ; continue ; } if ( rect . encoding == rfbEncodingSupportedMessages ) { int loop ; if ( ! ReadFromRFBServer ( client , ( char * ) & client -> supportedMessages , sz_rfbSupportedMessages ) ) return FALSE ; rfbClientLog ( \"client2server<S2SV_blank>supported<S2SV_blank>messages<S2SV_blank>(bit<S2SV_blank>flags)\\\\n\" ) ; for ( loop = 0 ; loop < 32 ; loop += 8 ) rfbClientLog ( \"%02X:<S2SV_blank>%04x<S2SV_blank>%04x<S2SV_blank>%04x<S2SV_blank>%04x<S2SV_blank>-<S2SV_blank>%04x<S2SV_blank>%04x<S2SV_blank>%04x<S2SV_blank>%04x\\\\n\" , loop , client -> supportedMessages . client2server [ loop ] , client -> supportedMessages . client2server [ loop + 1 ] , client -> supportedMessages . client2server [ loop + 2 ] , client -> supportedMessages . client2server [ loop + 3 ] , client -> supportedMessages . client2server [ loop + 4 ] , client -> supportedMessages . client2server [ loop + 5 ] , client -> supportedMessages . client2server [ loop + 6 ] , client -> supportedMessages . client2server [ loop + 7 ] ) ; rfbClientLog ( \"server2client<S2SV_blank>supported<S2SV_blank>messages<S2SV_blank>(bit<S2SV_blank>flags)\\\\n\" ) ; for ( loop = 0 ; loop < 32 ; loop += 8 ) rfbClientLog ( \"%02X:<S2SV_blank>%04x<S2SV_blank>%04x<S2SV_blank>%04x<S2SV_blank>%04x<S2SV_blank>-<S2SV_blank>%04x<S2SV_blank>%04x<S2SV_blank>%04x<S2SV_blank>%04x\\\\n\" , loop , client -> supportedMessages . server2client [ loop ] , client -> supportedMessages . server2client [ loop + 1 ] , client -> supportedMessages . server2client [ loop + 2 ] , client -> supportedMessages . server2client [ loop + 3 ] , client -> supportedMessages . server2client [ loop + 4 ] , client -> supportedMessages . server2client [ loop + 5 ] , client -> supportedMessages . server2client [ loop + 6 ] , client -> supportedMessages . server2client [ loop + 7 ] ) ; continue ; } if ( rect . encoding == rfbEncodingSupportedEncodings ) { char * buffer ; buffer = malloc ( rect . r . w ) ; if ( ! ReadFromRFBServer ( client , buffer , rect . r . w ) ) { free ( buffer ) ; return FALSE ; } free ( buffer ) ; continue ; } if ( rect . encoding == rfbEncodingServerIdentity ) { char * buffer ; buffer = malloc ( rect . r . w + 1 ) ; if ( ! ReadFromRFBServer ( client , buffer , rect . r . w ) ) { free ( buffer ) ; return FALSE ; } buffer [ rect . r . w ] = 0 ; rfbClientLog ( \"Connected<S2SV_blank>to<S2SV_blank>Server<S2SV_blank>\\\\\"%s\\\\\"\\\\n\" , buffer ) ; free ( buffer ) ; continue ; } if ( rect . encoding != rfbEncodingUltraZip ) { if ( ( rect . r . x + rect . r . w > client -> width ) || ( rect . r . y + rect . r . h > client -> height ) ) { rfbClientLog ( \"Rect<S2SV_blank>too<S2SV_blank>large:<S2SV_blank>%dx%d<S2SV_blank>at<S2SV_blank>(%d,<S2SV_blank>%d)\\\\n\" , rect . r . w , rect . r . h , rect . r . x , rect . r . y ) ; return FALSE ; } client -> SoftCursorLockArea ( client , rect . r . x , rect . r . y , rect . r . w , rect . r . h ) ; } switch ( rect . encoding ) { case rfbEncodingRaw : { int y = rect . r . y , h = rect . r . h ; bytesPerLine = rect . r . w * client -> format . bitsPerPixel / 8 ; linesToRead = bytesPerLine ? ( RFB_BUFFER_SIZE / bytesPerLine ) : 0 ; while ( linesToRead && h > 0 ) { if ( linesToRead > h ) linesToRead = h ; if ( ! ReadFromRFBServer ( client , client -> buffer , bytesPerLine * linesToRead ) ) return FALSE ; client -> GotBitmap ( client , ( uint8_t * ) client -> buffer , rect . r . x , y , rect . r . w , linesToRead ) ; h -= linesToRead ; y += linesToRead ; } break ; } case rfbEncodingCopyRect : { rfbCopyRect cr ; if ( ! ReadFromRFBServer ( client , ( char * ) & cr , sz_rfbCopyRect ) ) return FALSE ; cr . srcX = rfbClientSwap16IfLE ( cr . srcX ) ; cr . srcY = rfbClientSwap16IfLE ( cr . srcY ) ; client -> SoftCursorLockArea ( client , cr . srcX , cr . srcY , rect . r . w , rect . r . h ) ; client -> GotCopyRect ( client , cr . srcX , cr . srcY , rect . r . w , rect . r . h , rect . r . x , rect . r . y ) ; break ; } case rfbEncodingRRE : { switch ( client -> format . bitsPerPixel ) { case 8 : if ( ! HandleRRE8 ( client , rect . r . x , rect . r . y , rect . r . w , rect . r . h ) ) return FALSE ; break ; case 16 : if ( ! HandleRRE16 ( client , rect . r . x , rect . r . y , rect . r . w , rect . r . h ) ) return FALSE ; break ; case 32 : if ( ! HandleRRE32 ( client , rect . r . x , rect . r . y , rect . r . w , rect . r . h ) ) return FALSE ; break ; } break ; } case rfbEncodingCoRRE : { switch ( client -> format . bitsPerPixel ) { case 8 : if ( ! HandleCoRRE8 ( client , rect . r . x , rect . r . y , rect . r . w , rect . r . h ) ) return FALSE ; break ; case 16 : if ( ! HandleCoRRE16 ( client , rect . r . x , rect . r . y , rect . r . w , rect . r . h ) ) return FALSE ; break ; case 32 : if ( ! HandleCoRRE32 ( client , rect . r . x , rect . r . y , rect . r . w , rect . r . h ) ) return FALSE ; break ; } break ; } case rfbEncodingHextile : { switch ( client -> format . bitsPerPixel ) { case 8 : if ( ! HandleHextile8 ( client , rect . r . x , rect . r . y , rect . r . w , rect . r . h ) ) return FALSE ; break ; case 16 : if ( ! HandleHextile16 ( client , rect . r . x , rect . r . y , rect . r . w , rect . r . h ) ) return FALSE ; break ; case 32 : if ( ! HandleHextile32 ( client , rect . r . x , rect . r . y , rect . r . w , rect . r . h ) ) return FALSE ; break ; } break ; } case rfbEncodingUltra : { switch ( client -> format . bitsPerPixel ) { case 8 : if ( ! HandleUltra8 ( client , rect . r . x , rect . r . y , rect . r . w , rect . r . h ) ) return FALSE ; break ; case 16 : if ( ! HandleUltra16 ( client , rect . r . x , rect . r . y , rect . r . w , rect . r . h ) ) return FALSE ; break ; case 32 : if ( ! HandleUltra32 ( client , rect . r . x , rect . r . y , rect . r . w , rect . r . h ) ) return FALSE ; break ; } break ; } case rfbEncodingUltraZip : { switch ( client -> format . bitsPerPixel ) { case 8 : if ( ! HandleUltraZip8 ( client , rect . r . x , rect . r . y , rect . r . w , rect . r . h ) ) return FALSE ; break ; case 16 : if ( ! HandleUltraZip16 ( client , rect . r . x , rect . r . y , rect . r . w , rect . r . h ) ) return FALSE ; break ; case 32 : if ( ! HandleUltraZip32 ( client , rect . r . x , rect . r . y , rect . r . w , rect . r . h ) ) return FALSE ; break ; } break ; } case rfbEncodingTRLE : { switch ( client -> format . bitsPerPixel ) { case 8 : if ( ! HandleTRLE8 ( client , rect . r . x , rect . r . y , rect . r . w , rect . r . h ) ) return FALSE ; break ; case 16 : if ( client -> si . format . greenMax > 0x1F ) { if ( ! HandleTRLE16 ( client , rect . r . x , rect . r . y , rect . r . w , rect . r . h ) ) return FALSE ; } else { if ( ! HandleTRLE15 ( client , rect . r . x , rect . r . y , rect . r . w , rect . r . h ) ) return FALSE ; } break ; case 32 : { uint32_t maxColor = ( client -> format . redMax << client -> format . redShift ) | ( client -> format . greenMax << client -> format . greenShift ) | ( client -> format . blueMax << client -> format . blueShift ) ; if ( ( client -> format . bigEndian && ( maxColor & 0xff ) == 0 ) || ( ! client -> format . bigEndian && ( maxColor & 0xff000000 ) == 0 ) ) { if ( ! HandleTRLE24 ( client , rect . r . x , rect . r . y , rect . r . w , rect . r . h ) ) return FALSE ; } else if ( ! client -> format . bigEndian && ( maxColor & 0xff ) == 0 ) { if ( ! HandleTRLE24Up ( client , rect . r . x , rect . r . y , rect . r . w , rect . r . h ) ) return FALSE ; } else if ( client -> format . bigEndian && ( maxColor & 0xff000000 ) == 0 ) { if ( ! HandleTRLE24Down ( client , rect . r . x , rect . r . y , rect . r . w , rect . r . h ) ) return FALSE ; } else if ( ! HandleTRLE32 ( client , rect . r . x , rect . r . y , rect . r . w , rect . r . h ) ) return FALSE ; break ; } } break ; } # ifdef LIBVNCSERVER_HAVE_LIBZ case rfbEncodingZlib : { switch ( client -> format . bitsPerPixel ) { case 8 : if ( ! HandleZlib8 ( client , rect . r . x , rect . r . y , rect . r . w , rect . r . h ) ) return FALSE ; break ; case 16 : if ( ! HandleZlib16 ( client , rect . r . x , rect . r . y , rect . r . w , rect . r . h ) ) return FALSE ; break ; case 32 : if ( ! HandleZlib32 ( client , rect . r . x , rect . r . y , rect . r . w , rect . r . h ) ) return FALSE ; break ; } break ; } # ifdef LIBVNCSERVER_HAVE_LIBJPEG case rfbEncodingTight : { switch ( client -> format . bitsPerPixel ) { case 8 : if ( ! HandleTight8 ( client , rect . r . x , rect . r . y , rect . r . w , rect . r . h ) ) return FALSE ; break ; case 16 : if ( ! HandleTight16 ( client , rect . r . x , rect . r . y , rect . r . w , rect . r . h ) ) return FALSE ; break ; case 32 : if ( ! HandleTight32 ( client , rect . r . x , rect . r . y , rect . r . w , rect . r . h ) ) return FALSE ; break ; } break ; } # endif case rfbEncodingZRLE : client -> appData . qualityLevel = 9 ; case rfbEncodingZYWRLE : { switch ( client -> format . bitsPerPixel ) { case 8 : if ( ! HandleZRLE8 ( client , rect . r . x , rect . r . y , rect . r . w , rect . r . h ) ) return FALSE ; break ; case 16 : if ( client -> si . format . greenMax > 0x1F ) { if ( ! HandleZRLE16 ( client , rect . r . x , rect . r . y , rect . r . w , rect . r . h ) ) return FALSE ; } else { if ( ! HandleZRLE15 ( client , rect . r . x , rect . r . y , rect . r . w , rect . r . h ) ) return FALSE ; } break ; case 32 : { uint32_t maxColor = ( client -> format . redMax << client -> format . redShift ) | ( client -> format . greenMax << client -> format . greenShift ) | ( client -> format . blueMax << client -> format . blueShift ) ; if ( ( client -> format . bigEndian && ( maxColor & 0xff ) == 0 ) || ( ! client -> format . bigEndian && ( maxColor & 0xff000000 ) == 0 ) ) { if ( ! HandleZRLE24 ( client , rect . r . x , rect . r . y , rect . r . w , rect . r . h ) ) return FALSE ; } else if ( ! client -> format . bigEndian && ( maxColor & 0xff ) == 0 ) { if ( ! HandleZRLE24Up ( client , rect . r . x , rect . r . y , rect . r . w , rect . r . h ) ) return FALSE ; } else if ( client -> format . bigEndian && ( maxColor & 0xff000000 ) == 0 ) { if ( ! HandleZRLE24Down ( client , rect . r . x , rect . r . y , rect . r . w , rect . r . h ) ) return FALSE ; } else if ( ! HandleZRLE32 ( client , rect . r . x , rect . r . y , rect . r . w , rect . r . h ) ) return FALSE ; break ; } } break ; } # endif default : { rfbBool handled = FALSE ; rfbClientProtocolExtension * e ; for ( e = rfbClientExtensions ; ! handled && e ; e = e -> next ) if ( e -> handleEncoding && e -> handleEncoding ( client , & rect ) ) handled = TRUE ; if ( ! handled ) { rfbClientLog ( \"Unknown<S2SV_blank>rect<S2SV_blank>encoding<S2SV_blank>%d\\\\n\" , ( int ) rect . encoding ) ; return FALSE ; } } } client -> SoftCursorUnlockScreen ( client ) ; client -> GotFrameBufferUpdate ( client , rect . r . x , rect . r . y , rect . r . w , rect . r . h ) ; } if ( ! SendIncrementalFramebufferUpdateRequest ( client ) ) return FALSE ; if ( client -> FinishedFrameBufferUpdate ) client -> FinishedFrameBufferUpdate ( client ) ; break ; } case rfbBell : { client -> Bell ( client ) ; break ; } case rfbServerCutText : { char * buffer ; if ( ! ReadFromRFBServer ( client , ( ( char * ) & msg ) + 1 , sz_rfbServerCutTextMsg - 1 ) ) return FALSE ; msg . sct . length = rfbClientSwap32IfLE ( msg . sct . length ) ; if ( msg . sct . length > 1 << 20 ) { rfbClientErr ( \"Ignoring<S2SV_blank>too<S2SV_blank>big<S2SV_blank>cut<S2SV_blank>text<S2SV_blank>length<S2SV_blank>sent<S2SV_blank>by<S2SV_blank>server:<S2SV_blank>%u<S2SV_blank>B<S2SV_blank>><S2SV_blank>1<S2SV_blank>MB\\\\n\" , ( unsigned int ) msg . sct . length ) ; return FALSE ; } <S2SV_StartBug> buffer = malloc ( ( uint64_t ) msg . sct . length + 1 ) ; <S2SV_EndBug> if ( ! ReadFromRFBServer ( client , buffer , msg . sct . length ) ) { free ( buffer ) ; return FALSE ; } buffer [ msg . sct . length ] = 0 ; if ( client -> GotXCutText ) client -> GotXCutText ( client , buffer , msg . sct . length ) ; free ( buffer ) ; break ; } case rfbTextChat : { char * buffer = NULL ; if ( ! ReadFromRFBServer ( client , ( ( char * ) & msg ) + 1 , sz_rfbTextChatMsg - 1 ) ) return FALSE ; msg . tc . length = rfbClientSwap32IfLE ( msg . sct . length ) ; switch ( msg . tc . length ) { case rfbTextChatOpen : rfbClientLog ( \"Received<S2SV_blank>TextChat<S2SV_blank>Open\\\\n\" ) ; if ( client -> HandleTextChat != NULL ) client -> HandleTextChat ( client , ( int ) rfbTextChatOpen , NULL ) ; break ; case rfbTextChatClose : rfbClientLog ( \"Received<S2SV_blank>TextChat<S2SV_blank>Close\\\\n\" ) ; if ( client -> HandleTextChat != NULL ) client -> HandleTextChat ( client , ( int ) rfbTextChatClose , NULL ) ; break ; case rfbTextChatFinished : rfbClientLog ( \"Received<S2SV_blank>TextChat<S2SV_blank>Finished\\\\n\" ) ; if ( client -> HandleTextChat != NULL ) client -> HandleTextChat ( client , ( int ) rfbTextChatFinished , NULL ) ; break ; default : buffer = malloc ( msg . tc . length + 1 ) ; if ( ! ReadFromRFBServer ( client , buffer , msg . tc . length ) ) { free ( buffer ) ; return FALSE ; } buffer [ msg . tc . length ] = 0 ; rfbClientLog ( \"Received<S2SV_blank>TextChat<S2SV_blank>\\\\\"%s\\\\\"\\\\n\" , buffer ) ; if ( client -> HandleTextChat != NULL ) client -> HandleTextChat ( client , ( int ) msg . tc . length , buffer ) ; free ( buffer ) ; break ; } break ; } case rfbXvp : { if ( ! ReadFromRFBServer ( client , ( ( char * ) & msg ) + 1 , sz_rfbXvpMsg - 1 ) ) return FALSE ; SetClient2Server ( client , rfbXvp ) ; SetServer2Client ( client , rfbXvp ) ; if ( client -> HandleXvpMsg ) client -> HandleXvpMsg ( client , msg . xvp . version , msg . xvp . code ) ; break ; } case rfbResizeFrameBuffer : { if ( ! ReadFromRFBServer ( client , ( ( char * ) & msg ) + 1 , sz_rfbResizeFrameBufferMsg - 1 ) ) return FALSE ; client -> width = rfbClientSwap16IfLE ( msg . rsfb . framebufferWidth ) ; client -> height = rfbClientSwap16IfLE ( msg . rsfb . framebufferHeigth ) ; client -> updateRect . x = client -> updateRect . y = 0 ; client -> updateRect . w = client -> width ; client -> updateRect . h = client -> height ; if ( ! client -> MallocFrameBuffer ( client ) ) return FALSE ; SendFramebufferUpdateRequest ( client , 0 , 0 , client -> width , client -> height , FALSE ) ; rfbClientLog ( \"Got<S2SV_blank>new<S2SV_blank>framebuffer<S2SV_blank>size:<S2SV_blank>%dx%d\\\\n\" , client -> width , client -> height ) ; break ; } case rfbPalmVNCReSizeFrameBuffer : { if ( ! ReadFromRFBServer ( client , ( ( char * ) & msg ) + 1 , sz_rfbPalmVNCReSizeFrameBufferMsg - 1 ) ) return FALSE ; client -> width = rfbClientSwap16IfLE ( msg . prsfb . buffer_w ) ; client -> height = rfbClientSwap16IfLE ( msg . prsfb . buffer_h ) ; client -> updateRect . x = client -> updateRect . y = 0 ; client -> updateRect . w = client -> width ; client -> updateRect . h = client -> height ; if ( ! client -> MallocFrameBuffer ( client ) ) return FALSE ; SendFramebufferUpdateRequest ( client , 0 , 0 , client -> width , client -> height , FALSE ) ; rfbClientLog ( \"Got<S2SV_blank>new<S2SV_blank>framebuffer<S2SV_blank>size:<S2SV_blank>%dx%d\\\\n\" , client -> width , client -> height ) ; break ; } default : { rfbBool handled = FALSE ; rfbClientProtocolExtension * e ; for ( e = rfbClientExtensions ; ! handled && e ; e = e -> next ) if ( e -> handleMessage && e -> handleMessage ( client , & msg ) ) handled = TRUE ; if ( ! handled ) { char buffer [ 256 ] ; rfbClientLog ( \"Unknown<S2SV_blank>message<S2SV_blank>type<S2SV_blank>%d<S2SV_blank>from<S2SV_blank>VNC<S2SV_blank>server\\\\n\" , msg . type ) ; ReadFromRFBServer ( client , buffer , 256 ) ; return FALSE ; } } } return TRUE ; }\n",
      "fixed_code": "<S2SV_ModStart> = malloc ( <S2SV_ModEnd> msg . sct\n",
      "source_code_length": 17817,
      "target_code_length": 51,
      "vulnerability_patterns": {
        "use_after_free": 15,
        "integer_overflow": 5,
        "null_pointer": 128,
        "memory_leak": 4,
        "total": 152
      },
      "total_patterns": 152,
      "original_address": "https://github.com/LibVNC/libvncserver/commit/a64c3b37af9a6c8f8009d7516874b8d266b42bae",
      "discovery_time": "2019-01-30T18:29Z",
      "project_commit_id": "LibVNC@libvncserver/a64c3b37af9a6c8f8009d7516874b8d266b42bae",
      "extraction_time": "2025-08-31T15:41:49.182918",
      "label": 1,
      "vulnerability_type": "out-of-bounds_write",
      "difficulty_level": "advanced",
      "risk_factors": [
        "system_crash",
        "memory_corruption",
        "arbitrary_code_execution",
        "use_after_free"
      ],
      "attack_vectors": [
        "memory_manipulation",
        "malicious_input",
        "code_analysis",
        "buffer_overflow",
        "reverse_engineering",
        "fuzzing"
      ],
      "mitigation_strategies": [
        "safe_string_functions",
        "dynamic_analysis",
        "code_review",
        "static_analysis",
        "memory_safety_checks",
        "input_validation",
        "fuzzing",
        "bounds_checking",
        "secure_coding_practices"
      ],
      "code_differences": {
        "has_differences": true,
        "source_lines": 2,
        "target_lines": 2,
        "character_differences": 17766,
        "similarity_percentage": 2.307692307692308
      },
      "vulnerability_location": {
        "vulnerability_present": true,
        "fix_applied": true,
        "code_changed": true,
        "estimated_lines_changed": 0
      }
    },
    {
      "cve_id": "CVE-2019-19275",
      "cwe_id": "CWE-125",
      "cwe_name": "Out-of-bounds Read",
      "project": "python",
      "severity": "critical",
      "weaponization_score": 8.5,
      "is_critical": true,
      "is_weaponizable": true,
      "is_high_priority_project": true,
      "vulnerable_code": "CWE-125 static arguments_ty ast_for_arguments ( struct compiling * c , const node * n ) { int i , j , k , nposargs = 0 , nkwonlyargs = 0 ; int nposdefaults = 0 , found_default = 0 ; asdl_seq * posargs , * posdefaults , * kwonlyargs , * kwdefaults ; arg_ty vararg = NULL , kwarg = NULL ; arg_ty arg ; node * ch ; if ( TYPE ( n ) == parameters ) { if ( NCH ( n ) == 2 ) return arguments ( NULL , NULL , NULL , NULL , NULL , NULL , c -> c_arena ) ; n = CHILD ( n , 1 ) ; } assert ( TYPE ( n ) == typedargslist || TYPE ( n ) == varargslist ) ; for ( i = 0 ; i < NCH ( n ) ; i ++ ) { ch = CHILD ( n , i ) ; if ( TYPE ( ch ) == STAR ) { i ++ ; if ( i < NCH ( n ) && ( TYPE ( CHILD ( n , i ) ) == tfpdef || TYPE ( CHILD ( n , i ) ) == vfpdef ) ) { i ++ ; } break ; } if ( TYPE ( ch ) == DOUBLESTAR ) break ; if ( TYPE ( ch ) == vfpdef || TYPE ( ch ) == tfpdef ) nposargs ++ ; if ( TYPE ( ch ) == EQUAL ) nposdefaults ++ ; } for ( ; i < NCH ( n ) ; ++ i ) { ch = CHILD ( n , i ) ; if ( TYPE ( ch ) == DOUBLESTAR ) break ; if ( TYPE ( ch ) == tfpdef || TYPE ( ch ) == vfpdef ) nkwonlyargs ++ ; } posargs = ( nposargs ? _Ta3_asdl_seq_new ( nposargs , c -> c_arena ) : NULL ) ; if ( ! posargs && nposargs ) return NULL ; kwonlyargs = ( nkwonlyargs ? _Ta3_asdl_seq_new ( nkwonlyargs , c -> c_arena ) : NULL ) ; if ( ! kwonlyargs && nkwonlyargs ) return NULL ; posdefaults = ( nposdefaults ? _Ta3_asdl_seq_new ( nposdefaults , c -> c_arena ) : NULL ) ; if ( ! posdefaults && nposdefaults ) return NULL ; kwdefaults = ( nkwonlyargs ? _Ta3_asdl_seq_new ( nkwonlyargs , c -> c_arena ) : NULL ) ; if ( ! kwdefaults && nkwonlyargs ) return NULL ; <S2SV_StartBug> if ( nposargs + nkwonlyargs > 255 ) { <S2SV_EndBug> ast_error ( c , n , \"more<S2SV_blank>than<S2SV_blank>255<S2SV_blank>arguments\" ) ; return NULL ; } i = 0 ; j = 0 ; k = 0 ; while ( i < NCH ( n ) ) { ch = CHILD ( n , i ) ; switch ( TYPE ( ch ) ) { case tfpdef : case vfpdef : if ( i + 1 < NCH ( n ) && TYPE ( CHILD ( n , i + 1 ) ) == EQUAL ) { expr_ty expression = ast_for_expr ( c , CHILD ( n , i + 2 ) ) ; if ( ! expression ) return NULL ; assert ( posdefaults != NULL ) ; asdl_seq_SET ( posdefaults , j ++ , expression ) ; i += 2 ; found_default = 1 ; } else if ( found_default ) { ast_error ( c , n , \"non-default<S2SV_blank>argument<S2SV_blank>follows<S2SV_blank>default<S2SV_blank>argument\" ) ; return NULL ; } arg = ast_for_arg ( c , ch ) ; if ( ! arg ) return NULL ; asdl_seq_SET ( posargs , k ++ , arg ) ; i += 1 ; <S2SV_StartBug> if ( i < NCH ( n ) && TYPE ( CHILD ( n , i ) ) == COMMA ) <S2SV_EndBug> i += 1 ; break ; case STAR : if ( i + 1 >= NCH ( n ) || ( i + 2 == NCH ( n ) && ( TYPE ( CHILD ( n , i + 1 ) ) == COMMA || TYPE ( CHILD ( n , i + 1 ) ) == TYPE_COMMENT ) ) ) { ast_error ( c , CHILD ( n , i ) , \"named<S2SV_blank>arguments<S2SV_blank>must<S2SV_blank>follow<S2SV_blank>bare<S2SV_blank>*\" ) ; return NULL ; } ch = CHILD ( n , i + 1 ) ; if ( TYPE ( ch ) == COMMA ) { int res = 0 ; i += 2 ; <S2SV_StartBug> if ( i < NCH ( n ) && TYPE ( CHILD ( n , i ) ) == TYPE_COMMENT ) { <S2SV_EndBug> ast_error ( c , CHILD ( n , i ) , \"bare<S2SV_blank>*<S2SV_blank>has<S2SV_blank>associated<S2SV_blank>type<S2SV_blank>comment\" ) ; return NULL ; } res = handle_keywordonly_args ( c , n , i , kwonlyargs , kwdefaults ) ; if ( res == - 1 ) return NULL ; i = res ; } else { vararg = ast_for_arg ( c , ch ) ; if ( ! vararg ) return NULL ; i += 2 ; <S2SV_StartBug> if ( i < NCH ( n ) && TYPE ( CHILD ( n , i ) ) == COMMA ) <S2SV_EndBug> i += 1 ; <S2SV_StartBug> if ( i < NCH ( n ) && TYPE ( CHILD ( n , i ) ) == TYPE_COMMENT ) { <S2SV_EndBug> vararg -> type_comment = NEW_TYPE_COMMENT ( CHILD ( n , i ) ) ; i += 1 ; } if ( i < NCH ( n ) && ( TYPE ( CHILD ( n , i ) ) == tfpdef || TYPE ( CHILD ( n , i ) ) == vfpdef ) ) { int res = 0 ; res = handle_keywordonly_args ( c , n , i , kwonlyargs , kwdefaults ) ; if ( res == - 1 ) return NULL ; i = res ; } } break ; case DOUBLESTAR : ch = CHILD ( n , i + 1 ) ; assert ( TYPE ( ch ) == tfpdef || TYPE ( ch ) == vfpdef ) ; kwarg = ast_for_arg ( c , ch ) ; if ( ! kwarg ) return NULL ; i += 2 ; <S2SV_StartBug> if ( i < NCH ( n ) && TYPE ( CHILD ( n , i ) ) == COMMA ) <S2SV_EndBug> i += 1 ; break ; case TYPE_COMMENT : assert ( i ) ; if ( kwarg ) arg = kwarg ; arg -> type_comment = NEW_TYPE_COMMENT ( ch ) ; i += 1 ; break ; default : PyErr_Format ( PyExc_SystemError , \"unexpected<S2SV_blank>node<S2SV_blank>in<S2SV_blank>varargslist:<S2SV_blank>%d<S2SV_blank>@<S2SV_blank>%d\" , TYPE ( ch ) , i ) ; return NULL ; } } return arguments ( posargs , vararg , kwonlyargs , kwdefaults , kwarg , posdefaults , c -> c_arena ) ; }\n",
      "fixed_code": "<S2SV_ModStart> return NULL ; <S2SV_ModEnd> i = 0 <S2SV_ModStart> ; if ( <S2SV_ModEnd> TYPE ( CHILD <S2SV_ModStart> ; if ( <S2SV_ModEnd> TYPE ( CHILD <S2SV_ModStart> ; if ( <S2SV_ModEnd> TYPE ( CHILD <S2SV_ModStart> ; if ( <S2SV_ModEnd> TYPE ( CHILD <S2SV_ModStart> ; if ( <S2SV_ModEnd> TYPE ( CHILD\n",
      "source_code_length": 4617,
      "target_code_length": 300,
      "vulnerability_patterns": {
        "null_pointer": 16,
        "total": 16
      },
      "total_patterns": 16,
      "original_address": "https://github.com/python/typed_ast/commit/156afcb26c198e162504a57caddfe0acd9ed7dce",
      "discovery_time": "2019-11-26T15:15Z",
      "project_commit_id": "python@typed_ast/156afcb26c198e162504a57caddfe0acd9ed7dce",
      "extraction_time": "2025-08-31T15:41:49.183037",
      "label": 1,
      "vulnerability_type": "out-of-bounds_read",
      "difficulty_level": "advanced",
      "risk_factors": [
        "information_disclosure",
        "memory_corruption",
        "integer_overflow",
        "critical_infrastructure"
      ],
      "attack_vectors": [
        "memory_manipulation",
        "malicious_input",
        "code_analysis",
        "buffer_overflow",
        "reverse_engineering",
        "fuzzing"
      ],
      "mitigation_strategies": [
        "safe_string_functions",
        "dynamic_analysis",
        "code_review",
        "static_analysis",
        "memory_safety_checks",
        "input_validation",
        "fuzzing",
        "bounds_checking",
        "secure_coding_practices"
      ],
      "code_differences": {
        "has_differences": true,
        "source_lines": 2,
        "target_lines": 2,
        "character_differences": 4317,
        "similarity_percentage": 9.70873786407767
      },
      "vulnerability_location": {
        "vulnerability_present": true,
        "fix_applied": true,
        "code_changed": true,
        "estimated_lines_changed": 0
      }
    },
    {
      "cve_id": "CVE-2016-2385",
      "cwe_id": "CWE-119",
      "cwe_name": "Buffer Overflow",
      "project": "kamailio",
      "severity": "critical",
      "weaponization_score": 8.5,
      "is_critical": true,
      "is_weaponizable": true,
      "is_high_priority_project": false,
      "vulnerable_code": "CWE-119 int encode_msg ( struct sip_msg * msg , char * payload , int len ) { int i , j , k , u , request ; unsigned short int h ; struct hdr_field * hf ; struct msg_start * ms ; struct sip_uri miuri ; char * myerror = NULL ; ptrdiff_t diff ; if ( len < MAX_ENCODED_MSG + MAX_MESSAGE_LEN ) return - 1 ; if ( parse_headers ( msg , HDR_EOH_F , 0 ) < 0 ) { myerror = \"in<S2SV_blank>parse_headers\" ; goto error ; } memset ( payload , 0 , len ) ; ms = & msg -> first_line ; if ( ms -> type == SIP_REQUEST ) request = 1 ; else if ( ms -> type == SIP_REPLY ) request = 0 ; else { myerror = \"message<S2SV_blank>is<S2SV_blank>neither<S2SV_blank>request<S2SV_blank>nor<S2SV_blank>response\" ; goto error ; } if ( request ) { for ( h = 0 ; h < 32 ; j = ( 0x01 << h ) , h ++ ) if ( j & ms -> u . request . method_value ) break ; } else { h = ( unsigned short ) ( ms -> u . reply . statuscode ) ; } if ( h == 32 ) { myerror = \"unknown<S2SV_blank>message<S2SV_blank>type\\\\n\" ; goto error ; } h = htons ( h ) ; memcpy ( payload , & h , 2 ) ; h = htons ( ( unsigned short int ) msg -> len ) ; memcpy ( & payload [ MSG_LEN_IDX ] , & h , 2 ) ; if ( 0 > ( diff = ( get_body ( msg ) - ( msg -> buf ) ) ) ) { myerror = \"body<S2SV_blank>starts<S2SV_blank>before<S2SV_blank>the<S2SV_blank>message<S2SV_blank>(uh<S2SV_blank>?)\" ; goto error ; } else h = htons ( ( unsigned short int ) diff ) ; memcpy ( payload + CONTENT_IDX , & h , 2 ) ; payload [ METHOD_CODE_IDX ] = ( unsigned char ) ( request ? ( ms -> u . request . method . s - msg -> buf ) : ( ms -> u . reply . status . s - msg -> buf ) ) ; payload [ METHOD_CODE_IDX + 1 ] = ( unsigned char ) ( request ? ( ms -> u . request . method . len ) : ( ms -> u . reply . status . len ) ) ; payload [ URI_REASON_IDX ] = ( unsigned char ) ( request ? ( ms -> u . request . uri . s - msg -> buf ) : ( ms -> u . reply . reason . s - msg -> buf ) ) ; payload [ URI_REASON_IDX + 1 ] = ( unsigned char ) ( request ? ( ms -> u . request . uri . len ) : ( ms -> u . reply . reason . len ) ) ; payload [ VERSION_IDX ] = ( unsigned char ) ( request ? ( ms -> u . request . version . s - msg -> buf ) : ( ms -> u . reply . version . s - msg -> buf ) ) ; if ( request ) { if ( parse_uri ( ms -> u . request . uri . s , ms -> u . request . uri . len , & miuri ) < 0 ) { LM_ERR ( \"<%.*s>\\\\n\" , ms -> u . request . uri . len , ms -> u . request . uri . s ) ; myerror = \"while<S2SV_blank>parsing<S2SV_blank>the<S2SV_blank>R-URI\" ; goto error ; } if ( 0 > ( j = encode_uri2 ( msg -> buf , ms -> u . request . method . s - msg -> buf + ms -> len , ms -> u . request . uri , & miuri , ( unsigned char * ) & payload [ REQUEST_URI_IDX + 1 ] ) ) ) { myerror = \"ENCODE_MSG:<S2SV_blank>ERROR<S2SV_blank>while<S2SV_blank>encoding<S2SV_blank>the<S2SV_blank>R-URI\" ; goto error ; } payload [ REQUEST_URI_IDX ] = ( unsigned char ) j ; k = REQUEST_URI_IDX + 1 + j ; } else k = REQUEST_URI_IDX ; u = k ; k ++ ; for ( i = 0 , hf = msg -> headers ; hf ; hf = hf -> next , i ++ ) ; i ++ ; j = k + 3 * i ; for ( i = 0 , hf = msg -> headers ; hf ; hf = hf -> next , k += 3 ) { payload [ k ] = ( unsigned char ) ( hf -> type & 0xFF ) ; h = htons ( j ) ; memcpy ( & payload [ k + 1 ] , & h , 2 ) ; if ( 0 > ( i = encode_header ( msg , hf , ( unsigned char * ) ( payload + j ) , MAX_ENCODED_MSG + MAX_MESSAGE_LEN - j ) ) ) { LM_ERR ( \"encoding<S2SV_blank>header<S2SV_blank>%.*s\\\\n\" , hf -> name . len , hf -> name . s ) ; goto error ; k -= 3 ; continue ; } j += ( unsigned short int ) i ; } payload [ u ] = ( unsigned char ) ( ( k - u - 1 ) / 3 ) ; j = htons ( j ) ; memcpy ( & payload [ k + 1 ] , & j , 2 ) ; k += 3 ; j = ntohs ( j ) ; <S2SV_StartBug> memcpy ( & payload [ j ] , msg -> buf , msg -> len ) ; <S2SV_EndBug> LM_DBG ( \"msglen<S2SV_blank>=<S2SV_blank>%d,msg<S2SV_blank>starts<S2SV_blank>at<S2SV_blank>%d\\\\n\" , msg -> len , j ) ; j = htons ( j ) ; memcpy ( & payload [ MSG_START_IDX ] , & j , 2 ) ; return GET_PAY_SIZE ( payload ) ; error : LM_ERR ( \"%s\\\\n\" , myerror ) ; return - 1 ; }\n",
      "fixed_code": "<S2SV_ModStart> j ) ; if ( len < j + msg -> len + 1 ) { LM_ERR ( \"not<S2SV_blank>enough<S2SV_blank>space<S2SV_blank>to<S2SV_blank>encode<S2SV_blank>sip<S2SV_blank>message\\\\n\" ) ; return - 1 ; }\n",
      "source_code_length": 3984,
      "target_code_length": 194,
      "vulnerability_patterns": {
        "buffer_overflow": 8,
        "integer_overflow": 8,
        "null_pointer": 42,
        "total": 58
      },
      "total_patterns": 58,
      "original_address": "https://github.com/kamailio/kamailio/commit/f50c9c853e7809810099c970780c30b0765b0643",
      "discovery_time": "2016-04-11T15:59Z",
      "project_commit_id": "kamailio@kamailio/f50c9c853e7809810099c970780c30b0765b0643",
      "extraction_time": "2025-08-31T15:41:49.183085",
      "label": 1,
      "vulnerability_type": "buffer_overflow",
      "difficulty_level": "advanced",
      "risk_factors": [
        "system_crash",
        "memory_corruption",
        "buffer_overflow",
        "arbitrary_code_execution"
      ],
      "attack_vectors": [
        "memory_manipulation",
        "malicious_input",
        "code_analysis",
        "buffer_overflow",
        "reverse_engineering",
        "fuzzing"
      ],
      "mitigation_strategies": [
        "safe_string_functions",
        "dynamic_analysis",
        "code_review",
        "static_analysis",
        "memory_safety_checks",
        "input_validation",
        "fuzzing",
        "bounds_checking",
        "secure_coding_practices"
      ],
      "code_differences": {
        "has_differences": true,
        "source_lines": 2,
        "target_lines": 2,
        "character_differences": 3790,
        "similarity_percentage": 13.333333333333334
      },
      "vulnerability_location": {
        "vulnerability_present": true,
        "fix_applied": true,
        "code_changed": true,
        "estimated_lines_changed": 0
      }
    },
    {
      "cve_id": "CVE-2017-9077",
      "cwe_id": "CWE-000",
      "cwe_name": "Unknown/Uncategorized",
      "project": "torvalds",
      "severity": "critical",
      "weaponization_score": 8.5,
      "is_critical": true,
      "is_weaponizable": true,
      "is_high_priority_project": false,
      "vulnerable_code": "CWE-000 static struct sock * tcp_v6_syn_recv_sock ( const struct sock * sk , struct sk_buff * skb , struct request_sock * req , struct dst_entry * dst , struct request_sock * req_unhash , bool * own_req ) { struct inet_request_sock * ireq ; struct ipv6_pinfo * newnp ; const struct ipv6_pinfo * np = inet6_sk ( sk ) ; struct ipv6_txoptions * opt ; struct tcp6_sock * newtcp6sk ; struct inet_sock * newinet ; struct tcp_sock * newtp ; struct sock * newsk ; # ifdef CONFIG_TCP_MD5SIG struct tcp_md5sig_key * key ; # endif struct flowi6 fl6 ; if ( skb -> protocol == htons ( ETH_P_IP ) ) { newsk = tcp_v4_syn_recv_sock ( sk , skb , req , dst , req_unhash , own_req ) ; if ( ! newsk ) return NULL ; newtcp6sk = ( struct tcp6_sock * ) newsk ; inet_sk ( newsk ) -> pinet6 = & newtcp6sk -> inet6 ; newinet = inet_sk ( newsk ) ; newnp = inet6_sk ( newsk ) ; newtp = tcp_sk ( newsk ) ; memcpy ( newnp , np , sizeof ( struct ipv6_pinfo ) ) ; newnp -> saddr = newsk -> sk_v6_rcv_saddr ; inet_csk ( newsk ) -> icsk_af_ops = & ipv6_mapped ; newsk -> sk_backlog_rcv = tcp_v4_do_rcv ; # ifdef CONFIG_TCP_MD5SIG newtp -> af_specific = & tcp_sock_ipv6_mapped_specific ; # endif <S2SV_StartBug> newnp -> ipv6_ac_list = NULL ; <S2SV_EndBug> newnp -> ipv6_fl_list = NULL ; newnp -> pktoptions = NULL ; newnp -> opt = NULL ; newnp -> mcast_oif = tcp_v6_iif ( skb ) ; newnp -> mcast_hops = ipv6_hdr ( skb ) -> hop_limit ; newnp -> rcv_flowinfo = ip6_flowinfo ( ipv6_hdr ( skb ) ) ; if ( np -> repflow ) newnp -> flow_label = ip6_flowlabel ( ipv6_hdr ( skb ) ) ; tcp_sync_mss ( newsk , inet_csk ( newsk ) -> icsk_pmtu_cookie ) ; return newsk ; } ireq = inet_rsk ( req ) ; if ( sk_acceptq_is_full ( sk ) ) goto out_overflow ; if ( ! dst ) { dst = inet6_csk_route_req ( sk , & fl6 , req , IPPROTO_TCP ) ; if ( ! dst ) goto out ; } newsk = tcp_create_openreq_child ( sk , req , skb ) ; if ( ! newsk ) goto out_nonewsk ; newsk -> sk_gso_type = SKB_GSO_TCPV6 ; ip6_dst_store ( newsk , dst , NULL , NULL ) ; inet6_sk_rx_dst_set ( newsk , skb ) ; newtcp6sk = ( struct tcp6_sock * ) newsk ; inet_sk ( newsk ) -> pinet6 = & newtcp6sk -> inet6 ; newtp = tcp_sk ( newsk ) ; newinet = inet_sk ( newsk ) ; newnp = inet6_sk ( newsk ) ; memcpy ( newnp , np , sizeof ( struct ipv6_pinfo ) ) ; newsk -> sk_v6_daddr = ireq -> ir_v6_rmt_addr ; newnp -> saddr = ireq -> ir_v6_loc_addr ; newsk -> sk_v6_rcv_saddr = ireq -> ir_v6_loc_addr ; newsk -> sk_bound_dev_if = ireq -> ir_iif ; <S2SV_StartBug> newinet -> inet_opt = NULL ; <S2SV_EndBug> newnp -> ipv6_ac_list = NULL ; newnp -> ipv6_fl_list = NULL ; newnp -> rxopt . all = np -> rxopt . all ; newnp -> pktoptions = NULL ; newnp -> opt = NULL ; newnp -> mcast_oif = tcp_v6_iif ( skb ) ; newnp -> mcast_hops = ipv6_hdr ( skb ) -> hop_limit ; newnp -> rcv_flowinfo = ip6_flowinfo ( ipv6_hdr ( skb ) ) ; if ( np -> repflow ) newnp -> flow_label = ip6_flowlabel ( ipv6_hdr ( skb ) ) ; opt = ireq -> ipv6_opt ; if ( ! opt ) opt = rcu_dereference ( np -> opt ) ; if ( opt ) { opt = ipv6_dup_options ( newsk , opt ) ; RCU_INIT_POINTER ( newnp -> opt , opt ) ; } inet_csk ( newsk ) -> icsk_ext_hdr_len = 0 ; if ( opt ) inet_csk ( newsk ) -> icsk_ext_hdr_len = opt -> opt_nflen + opt -> opt_flen ; tcp_ca_openreq_child ( newsk , dst ) ; tcp_sync_mss ( newsk , dst_mtu ( dst ) ) ; newtp -> advmss = tcp_mss_clamp ( tcp_sk ( sk ) , dst_metric_advmss ( dst ) ) ; tcp_initialize_rcv_mss ( newsk ) ; newinet -> inet_daddr = newinet -> inet_saddr = LOOPBACK4_IPV6 ; newinet -> inet_rcv_saddr = LOOPBACK4_IPV6 ; # ifdef CONFIG_TCP_MD5SIG key = tcp_v6_md5_do_lookup ( sk , & newsk -> sk_v6_daddr ) ; if ( key ) { tcp_md5_do_add ( newsk , ( union tcp_md5_addr * ) & newsk -> sk_v6_daddr , AF_INET6 , key -> key , key -> keylen , sk_gfp_mask ( sk , GFP_ATOMIC ) ) ; } # endif if ( __inet_inherit_port ( sk , newsk ) < 0 ) { inet_csk_prepare_forced_close ( newsk ) ; tcp_done ( newsk ) ; goto out ; } * own_req = inet_ehash_nolisten ( newsk , req_to_sk ( req_unhash ) ) ; if ( * own_req ) { tcp_move_syn ( newtp , req ) ; if ( ireq -> pktopts ) { newnp -> pktoptions = skb_clone ( ireq -> pktopts , sk_gfp_mask ( sk , GFP_ATOMIC ) ) ; consume_skb ( ireq -> pktopts ) ; ireq -> pktopts = NULL ; if ( newnp -> pktoptions ) { tcp_v6_restore_cb ( newnp -> pktoptions ) ; skb_set_owner_r ( newnp -> pktoptions , newsk ) ; } } } return newsk ; out_overflow : __NET_INC_STATS ( sock_net ( sk ) , LINUX_MIB_LISTENOVERFLOWS ) ; out_nonewsk : dst_release ( dst ) ; out : tcp_listendrop ( sk ) ; return NULL ; }\n",
      "fixed_code": "<S2SV_ModStart> endif newnp -> ipv6_mc_list = NULL ; newnp -> <S2SV_ModStart> newinet -> inet_opt = NULL ; newnp -> ipv6_mc_list\n",
      "source_code_length": 4491,
      "target_code_length": 129,
      "vulnerability_patterns": {
        "buffer_overflow": 2,
        "use_after_free": 89,
        "null_pointer": 76,
        "total": 167
      },
      "total_patterns": 167,
      "original_address": "https://github.com/torvalds/linux/commit/83eaddab4378db256d00d295bda6ca997cd13a52",
      "discovery_time": "2017-05-19T14:29Z",
      "project_commit_id": "torvalds@linux/83eaddab4378db256d00d295bda6ca997cd13a52",
      "extraction_time": "2025-08-31T15:41:49.183135",
      "label": 1,
      "vulnerability_type": "unknown/uncategorized",
      "difficulty_level": "advanced",
      "risk_factors": [
        "buffer_overflow",
        "use_after_free"
      ],
      "attack_vectors": [
        "fuzzing",
        "code_analysis",
        "reverse_engineering"
      ],
      "mitigation_strategies": [
        "dynamic_analysis",
        "static_analysis",
        "fuzzing",
        "code_review",
        "secure_coding_practices"
      ],
      "code_differences": {
        "has_differences": true,
        "source_lines": 2,
        "target_lines": 2,
        "character_differences": 4362,
        "similarity_percentage": 5.031446540880504
      },
      "vulnerability_location": {
        "vulnerability_present": true,
        "fix_applied": true,
        "code_changed": true,
        "estimated_lines_changed": 0
      }
    },
    {
      "cve_id": "CVE-2017-14173",
      "cwe_id": "CWE-190",
      "cwe_name": "Integer Overflow",
      "project": "ImageMagick",
      "severity": "critical",
      "weaponization_score": 8.5,
      "is_critical": true,
      "is_weaponizable": true,
      "is_high_priority_project": true,
      "vulnerable_code": "CWE-190 static Image * ReadTXTImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { char colorspace [ MaxTextExtent ] , text [ MaxTextExtent ] ; Image * image ; IndexPacket * indexes ; long x_offset , y_offset ; MagickBooleanType status ; MagickPixelPacket pixel ; QuantumAny range ; register ssize_t i , x ; register PixelPacket * q ; ssize_t count , type , y ; unsigned long depth , height , max_value , width ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickSignature ) ; if ( image_info -> debug != MagickFalse ) ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , \"%s\" , image_info -> filename ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickSignature ) ; image = AcquireImage ( image_info ) ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } ( void ) ResetMagickMemory ( text , 0 , sizeof ( text ) ) ; ( void ) ReadBlobString ( image , text ) ; if ( LocaleNCompare ( ( char * ) text , MagickID , strlen ( MagickID ) ) != 0 ) ThrowReaderException ( CorruptImageError , \"ImproperImageHeader\" ) ; do { width = 0 ; height = 0 ; max_value = 0 ; * colorspace = '\\\\0' ; count = ( ssize_t ) sscanf ( text + 32 , \"%lu,%lu,%lu,%s\" , & width , & height , & max_value , colorspace ) ; if ( ( count != 4 ) || ( width == 0 ) || ( height == 0 ) || ( max_value == 0 ) ) ThrowReaderException ( CorruptImageError , \"ImproperImageHeader\" ) ; image -> columns = width ; image -> rows = height ; <S2SV_StartBug> for ( depth = 1 ; ( GetQuantumRange ( depth ) + 1 ) < max_value ; depth ++ ) <S2SV_EndBug> <S2SV_StartBug> if ( depth >= 64 ) <S2SV_EndBug> break ; image -> depth = depth ; status = SetImageExtent ( image , image -> columns , image -> rows ) ; if ( status == MagickFalse ) { InheritException ( exception , & image -> exception ) ; return ( DestroyImageList ( image ) ) ; } LocaleLower ( colorspace ) ; i = ( ssize_t ) strlen ( colorspace ) - 1 ; image -> matte = MagickFalse ; if ( ( i > 0 ) && ( colorspace [ i ] == 'a' ) ) { colorspace [ i ] = '\\\\0' ; image -> matte = MagickTrue ; } type = ParseCommandOption ( MagickColorspaceOptions , MagickFalse , colorspace ) ; if ( type < 0 ) ThrowReaderException ( CorruptImageError , \"ImproperImageHeader\" ) ; image -> colorspace = ( ColorspaceType ) type ; ( void ) ResetMagickMemory ( & pixel , 0 , sizeof ( pixel ) ) ; ( void ) SetImageBackgroundColor ( image ) ; range = GetQuantumRange ( image -> depth ) ; for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { double blue , green , index , opacity , red ; red = 0.0 ; green = 0.0 ; blue = 0.0 ; index = 0.0 ; opacity = 0.0 ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { if ( ReadBlobString ( image , text ) == ( char * ) NULL ) break ; switch ( image -> colorspace ) { case GRAYColorspace : { if ( image -> matte != MagickFalse ) { ( void ) sscanf ( text , \"%ld,%ld:<S2SV_blank>(%lf%*[%,]%lf%*[%,]\" , & x_offset , & y_offset , & red , & opacity ) ; green = red ; blue = red ; break ; } ( void ) sscanf ( text , \"%ld,%ld:<S2SV_blank>(%lf%*[%,]\" , & x_offset , & y_offset , & red ) ; green = red ; blue = red ; break ; } case CMYKColorspace : { if ( image -> matte != MagickFalse ) { ( void ) sscanf ( text , \"%ld,%ld:<S2SV_blank>(%lf%*[%,]%lf%*[%,]%lf%*[%,]%lf%*[%,]%lf%*[%,]\" , & x_offset , & y_offset , & red , & green , & blue , & index , & opacity ) ; break ; } ( void ) sscanf ( text , \"%ld,%ld:<S2SV_blank>(%lf%*[%,]%lf%*[%,]%lf%*[%,]%lf%*[%,]\" , & x_offset , & y_offset , & red , & green , & blue , & index ) ; break ; } default : { if ( image -> matte != MagickFalse ) { ( void ) sscanf ( text , \"%ld,%ld:<S2SV_blank>(%lf%*[%,]%lf%*[%,]%lf%*[%,]%lf%*[%,]\" , & x_offset , & y_offset , & red , & green , & blue , & opacity ) ; break ; } ( void ) sscanf ( text , \"%ld,%ld:<S2SV_blank>(%lf%*[%,]%lf%*[%,]%lf%*[%,]\" , & x_offset , & y_offset , & red , & green , & blue ) ; break ; } } if ( strchr ( text , '%' ) != ( char * ) NULL ) { red *= 0.01 * range ; green *= 0.01 * range ; blue *= 0.01 * range ; index *= 0.01 * range ; opacity *= 0.01 * range ; } if ( image -> colorspace == LabColorspace ) { green += ( range + 1 ) / 2.0 ; blue += ( range + 1 ) / 2.0 ; } pixel . red = ( MagickRealType ) ScaleAnyToQuantum ( ( QuantumAny ) ( red + 0.5 ) , range ) ; pixel . green = ( MagickRealType ) ScaleAnyToQuantum ( ( QuantumAny ) ( green + 0.5 ) , range ) ; pixel . blue = ( MagickRealType ) ScaleAnyToQuantum ( ( QuantumAny ) ( blue + 0.5 ) , range ) ; pixel . index = ( MagickRealType ) ScaleAnyToQuantum ( ( QuantumAny ) ( index + 0.5 ) , range ) ; pixel . opacity = ( MagickRealType ) ScaleAnyToQuantum ( ( QuantumAny ) ( opacity + 0.5 ) , range ) ; q = GetAuthenticPixels ( image , ( ssize_t ) x_offset , ( ssize_t ) y_offset , 1 , 1 , exception ) ; if ( q == ( PixelPacket * ) NULL ) continue ; SetPixelRed ( q , pixel . red ) ; SetPixelGreen ( q , pixel . green ) ; SetPixelBlue ( q , pixel . blue ) ; if ( image -> colorspace == CMYKColorspace ) { indexes = GetAuthenticIndexQueue ( image ) ; SetPixelIndex ( indexes , pixel . index ) ; } if ( image -> matte != MagickFalse ) SetPixelAlpha ( q , pixel . opacity ) ; if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; } } if ( EOFBlob ( image ) != MagickFalse ) { ThrowFileException ( exception , CorruptImageError , \"UnexpectedEndOfFile\" , image -> filename ) ; break ; } ( void ) ReadBlobString ( image , text ) ; if ( LocaleNCompare ( ( char * ) text , MagickID , strlen ( MagickID ) ) == 0 ) { AcquireNextImage ( image_info , image ) ; if ( GetNextImageInList ( image ) == ( Image * ) NULL ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } image = SyncNextImageInList ( image ) ; status = SetImageProgress ( image , LoadImagesTag , TellBlob ( image ) , GetBlobSize ( image ) ) ; if ( status == MagickFalse ) break ; } } while ( LocaleNCompare ( ( char * ) text , MagickID , strlen ( MagickID ) ) == 0 ) ; ( void ) CloseBlob ( image ) ; return ( GetFirstImageInList ( image ) ) ; }\n",
      "fixed_code": "<S2SV_ModStart> = height ; if ( ( max_value == 0 ) || ( max_value > 4294967295 ) ) ThrowReaderException ( CorruptImageError , \"ImproperImageHeader\" ) ; <S2SV_ModStart> depth ++ ) <S2SV_ModEnd> ; image ->\n",
      "source_code_length": 6146,
      "target_code_length": 204,
      "vulnerability_patterns": {
        "integer_overflow": 10,
        "null_pointer": 24,
        "total": 34
      },
      "total_patterns": 34,
      "original_address": "https://github.com/ImageMagick/ImageMagick/commit/48bcf7c39302cdf9b0d9202ad03bf1b95152c44d",
      "discovery_time": "2017-09-07T06:29Z",
      "project_commit_id": "ImageMagick@ImageMagick/48bcf7c39302cdf9b0d9202ad03bf1b95152c44d",
      "extraction_time": "2025-08-31T15:41:49.183194",
      "label": 1,
      "vulnerability_type": "integer_overflow",
      "difficulty_level": "advanced",
      "risk_factors": [
        "information_disclosure",
        "memory_corruption",
        "integer_overflow",
        "critical_infrastructure"
      ],
      "attack_vectors": [
        "fuzzing",
        "code_analysis",
        "reverse_engineering"
      ],
      "mitigation_strategies": [
        "dynamic_analysis",
        "static_analysis",
        "fuzzing",
        "code_review",
        "secure_coding_practices"
      ],
      "code_differences": {
        "has_differences": true,
        "source_lines": 2,
        "target_lines": 2,
        "character_differences": 5942,
        "similarity_percentage": 11.242603550295858
      },
      "vulnerability_location": {
        "vulnerability_present": true,
        "fix_applied": true,
        "code_changed": true,
        "estimated_lines_changed": 0
      }
    },
    {
      "cve_id": "CVE-2016-3951",
      "cwe_id": "CWE-000",
      "cwe_name": "Unknown/Uncategorized",
      "project": "torvalds",
      "severity": "critical",
      "weaponization_score": 8.5,
      "is_critical": true,
      "is_weaponizable": true,
      "is_high_priority_project": false,
      "vulnerable_code": "CWE-000 int usbnet_probe ( struct usb_interface * udev , const struct usb_device_id * prod ) { struct usbnet * dev ; struct net_device * net ; struct usb_host_interface * interface ; struct driver_info * info ; struct usb_device * xdev ; int status ; const char * name ; struct usb_driver * driver = to_usb_driver ( udev -> dev . driver ) ; if ( ! driver -> supports_autosuspend ) { driver -> supports_autosuspend = 1 ; pm_runtime_enable ( & udev -> dev ) ; } name = udev -> dev . driver -> name ; info = ( struct driver_info * ) prod -> driver_info ; if ( ! info ) { dev_dbg ( & udev -> dev , \"blacklisted<S2SV_blank>by<S2SV_blank>%s\\\\n\" , name ) ; return - ENODEV ; } xdev = interface_to_usbdev ( udev ) ; interface = udev -> cur_altsetting ; status = - ENOMEM ; net = alloc_etherdev ( sizeof ( * dev ) ) ; if ( ! net ) goto out ; SET_NETDEV_DEV ( net , & udev -> dev ) ; dev = netdev_priv ( net ) ; dev -> udev = xdev ; dev -> intf = udev ; dev -> driver_info = info ; dev -> driver_name = name ; dev -> msg_enable = netif_msg_init ( msg_level , NETIF_MSG_DRV | NETIF_MSG_PROBE | NETIF_MSG_LINK ) ; init_waitqueue_head ( & dev -> wait ) ; skb_queue_head_init ( & dev -> rxq ) ; skb_queue_head_init ( & dev -> txq ) ; skb_queue_head_init ( & dev -> done ) ; skb_queue_head_init ( & dev -> rxq_pause ) ; dev -> bh . func = usbnet_bh ; dev -> bh . data = ( unsigned long ) dev ; INIT_WORK ( & dev -> kevent , usbnet_deferred_kevent ) ; init_usb_anchor ( & dev -> deferred ) ; dev -> delay . function = usbnet_bh ; dev -> delay . data = ( unsigned long ) dev ; init_timer ( & dev -> delay ) ; mutex_init ( & dev -> phy_mutex ) ; mutex_init ( & dev -> interrupt_mutex ) ; dev -> interrupt_count = 0 ; dev -> net = net ; strcpy ( net -> name , \"usb%d\" ) ; memcpy ( net -> dev_addr , node_id , sizeof node_id ) ; dev -> hard_mtu = net -> mtu + net -> hard_header_len ; net -> netdev_ops = & usbnet_netdev_ops ; net -> watchdog_timeo = TX_TIMEOUT_JIFFIES ; net -> ethtool_ops = & usbnet_ethtool_ops ; if ( info -> bind ) { status = info -> bind ( dev , udev ) ; if ( status < 0 ) goto out1 ; if ( ( dev -> driver_info -> flags & FLAG_ETHER ) != 0 && ( ( dev -> driver_info -> flags & FLAG_POINTTOPOINT ) == 0 || ( net -> dev_addr [ 0 ] & 0x02 ) == 0 ) ) strcpy ( net -> name , \"eth%d\" ) ; if ( ( dev -> driver_info -> flags & FLAG_WLAN ) != 0 ) strcpy ( net -> name , \"wlan%d\" ) ; if ( ( dev -> driver_info -> flags & FLAG_WWAN ) != 0 ) strcpy ( net -> name , \"wwan%d\" ) ; if ( ( dev -> driver_info -> flags & FLAG_NOARP ) != 0 ) net -> flags |= IFF_NOARP ; if ( net -> mtu > ( dev -> hard_mtu - net -> hard_header_len ) ) net -> mtu = dev -> hard_mtu - net -> hard_header_len ; } else if ( ! info -> in || ! info -> out ) status = usbnet_get_endpoints ( dev , udev ) ; else { dev -> in = usb_rcvbulkpipe ( xdev , info -> in ) ; dev -> out = usb_sndbulkpipe ( xdev , info -> out ) ; if ( ! ( info -> flags & FLAG_NO_SETINT ) ) status = usb_set_interface ( xdev , interface -> desc . bInterfaceNumber , interface -> desc . bAlternateSetting ) ; else status = 0 ; } if ( status >= 0 && dev -> status ) status = init_status ( dev , udev ) ; if ( status < 0 ) goto out3 ; if ( ! dev -> rx_urb_size ) dev -> rx_urb_size = dev -> hard_mtu ; dev -> maxpacket = usb_maxpacket ( dev -> udev , dev -> out , 1 ) ; if ( ether_addr_equal ( net -> dev_addr , node_id ) ) net -> addr_assign_type = NET_ADDR_RANDOM ; if ( ( dev -> driver_info -> flags & FLAG_WLAN ) != 0 ) SET_NETDEV_DEVTYPE ( net , & wlan_type ) ; if ( ( dev -> driver_info -> flags & FLAG_WWAN ) != 0 ) SET_NETDEV_DEVTYPE ( net , & wwan_type ) ; usbnet_update_max_qlen ( dev ) ; if ( dev -> can_dma_sg && ! ( info -> flags & FLAG_SEND_ZLP ) && ! ( info -> flags & FLAG_MULTI_PACKET ) ) { dev -> padding_pkt = kzalloc ( 1 , GFP_KERNEL ) ; if ( ! dev -> padding_pkt ) { status = - ENOMEM ; goto out4 ; } } status = register_netdev ( net ) ; if ( status ) goto out5 ; netif_info ( dev , probe , dev -> net , \"register<S2SV_blank>\\'%s\\'<S2SV_blank>at<S2SV_blank>usb-%s-%s,<S2SV_blank>%s,<S2SV_blank>%pM\\\\n\" , udev -> dev . driver -> name , xdev -> bus -> bus_name , xdev -> devpath , dev -> driver_info -> description , net -> dev_addr ) ; usb_set_intfdata ( udev , dev ) ; netif_device_attach ( net ) ; if ( dev -> driver_info -> flags & FLAG_LINK_INTR ) usbnet_link_change ( dev , 0 , 0 ) ; return 0 ; out5 : kfree ( dev -> padding_pkt ) ; out4 : usb_free_urb ( dev -> interrupt ) ; out3 : if ( info -> unbind ) info -> unbind ( dev , udev ) ; out1 : <S2SV_StartBug> free_netdev ( net ) ; <S2SV_EndBug> out : return status ; }\n",
      "fixed_code": "<S2SV_ModStart> ; out1 : cancel_work_sync ( & dev -> kevent ) ; del_timer_sync ( & dev -> delay ) ;\n",
      "source_code_length": 4573,
      "target_code_length": 100,
      "vulnerability_patterns": {
        "buffer_overflow": 5,
        "use_after_free": 1,
        "null_pointer": 108,
        "total": 114
      },
      "total_patterns": 114,
      "original_address": "https://github.com/torvalds/linux/commit/1666984c8625b3db19a9abc298931d35ab7bc64b",
      "discovery_time": "2016-05-02T10:59Z",
      "project_commit_id": "torvalds@linux/1666984c8625b3db19a9abc298931d35ab7bc64b",
      "extraction_time": "2025-08-31T15:41:49.183260",
      "label": 1,
      "vulnerability_type": "unknown/uncategorized",
      "difficulty_level": "advanced",
      "risk_factors": [
        "buffer_overflow",
        "use_after_free"
      ],
      "attack_vectors": [
        "fuzzing",
        "code_analysis",
        "reverse_engineering"
      ],
      "mitigation_strategies": [
        "dynamic_analysis",
        "static_analysis",
        "fuzzing",
        "code_review",
        "secure_coding_practices"
      ],
      "code_differences": {
        "has_differences": true,
        "source_lines": 2,
        "target_lines": 2,
        "character_differences": 4473,
        "similarity_percentage": 5.524861878453039
      },
      "vulnerability_location": {
        "vulnerability_present": true,
        "fix_applied": true,
        "code_changed": true,
        "estimated_lines_changed": 0
      }
    },
    {
      "cve_id": "CVE-2014-3185",
      "cwe_id": "CWE-119",
      "cwe_name": "Buffer Overflow",
      "project": "torvalds",
      "severity": "critical",
      "weaponization_score": 8.5,
      "is_critical": true,
      "is_weaponizable": true,
      "is_high_priority_project": false,
      "vulnerable_code": "CWE-119 static void command_port_read_callback ( struct urb * urb ) { struct usb_serial_port * command_port = urb -> context ; struct whiteheat_command_private * command_info ; int status = urb -> status ; unsigned char * data = urb -> transfer_buffer ; int result ; command_info = usb_get_serial_port_data ( command_port ) ; if ( ! command_info ) { dev_dbg ( & urb -> dev -> dev , \"%s<S2SV_blank>-<S2SV_blank>command_info<S2SV_blank>is<S2SV_blank>NULL,<S2SV_blank>exiting.\\\\n\" , __func__ ) ; return ; } <S2SV_StartBug> if ( status ) { <S2SV_EndBug> dev_dbg ( & urb -> dev -> dev , \"%s<S2SV_blank>-<S2SV_blank>nonzero<S2SV_blank>urb<S2SV_blank>status:<S2SV_blank>%d\\\\n\" , __func__ , status ) ; if ( status != - ENOENT ) command_info -> command_finished = WHITEHEAT_CMD_FAILURE ; wake_up ( & command_info -> wait_command ) ; return ; } usb_serial_debug_data ( & command_port -> dev , __func__ , urb -> actual_length , data ) ; if ( data [ 0 ] == WHITEHEAT_CMD_COMPLETE ) { command_info -> command_finished = WHITEHEAT_CMD_COMPLETE ; wake_up ( & command_info -> wait_command ) ; } else if ( data [ 0 ] == WHITEHEAT_CMD_FAILURE ) { command_info -> command_finished = WHITEHEAT_CMD_FAILURE ; wake_up ( & command_info -> wait_command ) ; } else if ( data [ 0 ] == WHITEHEAT_EVENT ) { dev_dbg ( & urb -> dev -> dev , \"%s<S2SV_blank>-<S2SV_blank>event<S2SV_blank>received\\\\n\" , __func__ ) ; <S2SV_StartBug> } else if ( data [ 0 ] == WHITEHEAT_GET_DTR_RTS ) { <S2SV_EndBug> memcpy ( command_info -> result_buffer , & data [ 1 ] , <S2SV_StartBug> urb -> actual_length - 1 ) ; <S2SV_EndBug> command_info -> command_finished = WHITEHEAT_CMD_COMPLETE ; wake_up ( & command_info -> wait_command ) ; } else dev_dbg ( & urb -> dev -> dev , \"%s<S2SV_blank>-<S2SV_blank>bad<S2SV_blank>reply<S2SV_blank>from<S2SV_blank>firmware\\\\n\" , __func__ ) ; result = usb_submit_urb ( command_port -> read_urb , GFP_ATOMIC ) ; if ( result ) dev_dbg ( & urb -> dev -> dev , \"%s<S2SV_blank>-<S2SV_blank>failed<S2SV_blank>resubmitting<S2SV_blank>read<S2SV_blank>urb,<S2SV_blank>error<S2SV_blank>%d\\\\n\" , __func__ , result ) ; }\n",
      "fixed_code": "<S2SV_ModStart> } if ( ! urb -> actual_length ) { dev_dbg ( & urb -> dev -> dev , \"%s<S2SV_blank>-<S2SV_blank>empty<S2SV_blank>response,<S2SV_blank>exiting.\\\\n\" , __func__ ) ; return ; } if ( <S2SV_ModStart> else if ( ( <S2SV_ModStart> == WHITEHEAT_GET_DTR_RTS ) && ( <S2SV_ModEnd> urb -> actual_length <S2SV_ModStart> actual_length - 1 <= sizeof ( command_info -> result_buffer ) ) ) { memcpy ( command_info -> result_buffer , & data [ 1 ] , urb -> actual_length - 1\n",
      "source_code_length": 2095,
      "target_code_length": 468,
      "vulnerability_patterns": {
        "buffer_overflow": 1,
        "null_pointer": 28,
        "total": 29
      },
      "total_patterns": 29,
      "original_address": "https://github.com/torvalds/linux/commit/6817ae225cd650fb1c3295d769298c38b1eba818",
      "discovery_time": "2014-09-28T10:55Z",
      "project_commit_id": "torvalds@linux/6817ae225cd650fb1c3295d769298c38b1eba818",
      "extraction_time": "2025-08-31T15:41:49.183315",
      "label": 1,
      "vulnerability_type": "buffer_overflow",
      "difficulty_level": "advanced",
      "risk_factors": [
        "system_crash",
        "memory_corruption",
        "buffer_overflow",
        "arbitrary_code_execution"
      ],
      "attack_vectors": [
        "memory_manipulation",
        "malicious_input",
        "code_analysis",
        "buffer_overflow",
        "reverse_engineering",
        "fuzzing"
      ],
      "mitigation_strategies": [
        "safe_string_functions",
        "dynamic_analysis",
        "code_review",
        "static_analysis",
        "memory_safety_checks",
        "input_validation",
        "fuzzing",
        "bounds_checking",
        "secure_coding_practices"
      ],
      "code_differences": {
        "has_differences": true,
        "source_lines": 2,
        "target_lines": 2,
        "character_differences": 1627,
        "similarity_percentage": 38.028169014084504
      },
      "vulnerability_location": {
        "vulnerability_present": true,
        "fix_applied": true,
        "code_changed": true,
        "estimated_lines_changed": 0
      }
    },
    {
      "cve_id": "CVE-2016-7101",
      "cwe_id": "CWE-125",
      "cwe_name": "Out-of-bounds Read",
      "project": "ImageMagick",
      "severity": "critical",
      "weaponization_score": 8.5,
      "is_critical": true,
      "is_weaponizable": true,
      "is_high_priority_project": true,
      "vulnerable_code": "CWE-125 static Image * ReadSGIImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { Image * image ; MagickBooleanType status ; MagickSizeType number_pixels ; MemoryInfo * pixel_info ; register Quantum * q ; register ssize_t i , x ; register unsigned char * p ; SGIInfo iris_info ; size_t bytes_per_pixel , quantum ; ssize_t count , y , z ; unsigned char * pixels ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickCoreSignature ) ; if ( image_info -> debug != MagickFalse ) ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , \"%s\" , image_info -> filename ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickCoreSignature ) ; image = AcquireImage ( image_info , exception ) ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } iris_info . magic = ReadBlobMSBShort ( image ) ; do { if ( iris_info . magic != 0x01DA ) ThrowReaderException ( CorruptImageError , \"ImproperImageHeader\" ) ; iris_info . storage = ( unsigned char ) ReadBlobByte ( image ) ; switch ( iris_info . storage ) { case 0x00 : image -> compression = NoCompression ; break ; case 0x01 : image -> compression = RLECompression ; break ; default : ThrowReaderException ( CorruptImageError , \"ImproperImageHeader\" ) ; } iris_info . bytes_per_pixel = ( unsigned char ) ReadBlobByte ( image ) ; if ( ( iris_info . bytes_per_pixel == 0 ) || ( iris_info . bytes_per_pixel > 2 ) ) ThrowReaderException ( CorruptImageError , \"ImproperImageHeader\" ) ; iris_info . dimension = ReadBlobMSBShort ( image ) ; iris_info . columns = ReadBlobMSBShort ( image ) ; iris_info . rows = ReadBlobMSBShort ( image ) ; iris_info . depth = ReadBlobMSBShort ( image ) ; if ( ( iris_info . depth == 0 ) || ( iris_info . depth > 4 ) ) ThrowReaderException ( CorruptImageError , \"ImproperImageHeader\" ) ; iris_info . minimum_value = ReadBlobMSBLong ( image ) ; iris_info . maximum_value = ReadBlobMSBLong ( image ) ; iris_info . sans = ReadBlobMSBLong ( image ) ; <S2SV_StartBug> ( void ) ReadBlob ( image , sizeof ( iris_info . name ) , ( unsigned char * ) <S2SV_EndBug> <S2SV_StartBug> iris_info . name ) ; <S2SV_EndBug> iris_info . name [ sizeof ( iris_info . name ) - 1 ] = '\\\\0' ; if ( * iris_info . name != '\\\\0' ) ( void ) SetImageProperty ( image , \"label\" , iris_info . name , exception ) ; iris_info . pixel_format = ReadBlobMSBLong ( image ) ; if ( iris_info . pixel_format != 0 ) ThrowReaderException ( CorruptImageError , \"ImproperImageHeader\" ) ; count = ReadBlob ( image , sizeof ( iris_info . filler ) , iris_info . filler ) ; <S2SV_StartBug> ( void ) count ; <S2SV_EndBug> image -> columns = iris_info . columns ; image -> rows = iris_info . rows ; image -> depth = ( size_t ) MagickMin ( iris_info . depth , MAGICKCORE_QUANTUM_DEPTH ) ; if ( iris_info . pixel_format == 0 ) image -> depth = ( size_t ) MagickMin ( ( size_t ) 8 * iris_info . bytes_per_pixel , MAGICKCORE_QUANTUM_DEPTH ) ; if ( iris_info . depth < 3 ) { image -> storage_class = PseudoClass ; image -> colors = iris_info . bytes_per_pixel > 1 ? 65535 : 256 ; } <S2SV_StartBug> if ( EOFBlob ( image ) != MagickFalse ) <S2SV_EndBug> ThrowReaderException ( CorruptImageError , \"ImproperImageHeader\" ) ; if ( ( image_info -> ping != MagickFalse ) && ( image_info -> number_scenes != 0 ) ) if ( image -> scene >= ( image_info -> scene + image_info -> number_scenes - 1 ) ) break ; status = SetImageExtent ( image , image -> columns , image -> rows , exception ) ; if ( status == MagickFalse ) return ( DestroyImageList ( image ) ) ; bytes_per_pixel = ( size_t ) iris_info . bytes_per_pixel ; number_pixels = ( MagickSizeType ) iris_info . columns * iris_info . rows ; if ( ( 4 * bytes_per_pixel * number_pixels ) != ( ( MagickSizeType ) ( size_t ) ( 4 * bytes_per_pixel * number_pixels ) ) ) ThrowReaderException ( ResourceLimitError , \"MemoryAllocationFailed\" ) ; pixel_info = AcquireVirtualMemory ( iris_info . columns , iris_info . rows * 4 * bytes_per_pixel * sizeof ( * pixels ) ) ; if ( pixel_info == ( MemoryInfo * ) NULL ) ThrowReaderException ( ResourceLimitError , \"MemoryAllocationFailed\" ) ; pixels = ( unsigned char * ) GetVirtualMemoryBlob ( pixel_info ) ; if ( ( int ) iris_info . storage != 0x01 ) { unsigned char * scanline ; scanline = ( unsigned char * ) AcquireQuantumMemory ( iris_info . columns , bytes_per_pixel * sizeof ( * scanline ) ) ; if ( scanline == ( unsigned char * ) NULL ) ThrowReaderException ( ResourceLimitError , \"MemoryAllocationFailed\" ) ; for ( z = 0 ; z < ( ssize_t ) iris_info . depth ; z ++ ) { p = pixels + bytes_per_pixel * z ; for ( y = 0 ; y < ( ssize_t ) iris_info . rows ; y ++ ) { count = ReadBlob ( image , bytes_per_pixel * iris_info . columns , scanline ) ; if ( EOFBlob ( image ) != MagickFalse ) break ; if ( bytes_per_pixel == 2 ) for ( x = 0 ; x < ( ssize_t ) iris_info . columns ; x ++ ) { * p = scanline [ 2 * x ] ; * ( p + 1 ) = scanline [ 2 * x + 1 ] ; p += 8 ; } else for ( x = 0 ; x < ( ssize_t ) iris_info . columns ; x ++ ) { * p = scanline [ x ] ; p += 4 ; } } } scanline = ( unsigned char * ) RelinquishMagickMemory ( scanline ) ; } else { MemoryInfo * packet_info ; size_t * runlength ; ssize_t offset , * offsets ; unsigned char * packets ; unsigned int data_order ; offsets = ( ssize_t * ) AcquireQuantumMemory ( ( size_t ) iris_info . rows , iris_info . depth * sizeof ( * offsets ) ) ; runlength = ( size_t * ) AcquireQuantumMemory ( iris_info . rows , iris_info . depth * sizeof ( * runlength ) ) ; packet_info = AcquireVirtualMemory ( ( size_t ) iris_info . columns + 10UL , 4UL * sizeof ( * packets ) ) ; if ( ( offsets == ( ssize_t * ) NULL ) || ( runlength == ( size_t * ) NULL ) || ( packet_info == ( MemoryInfo * ) NULL ) ) { if ( offsets == ( ssize_t * ) NULL ) offsets = ( ssize_t * ) RelinquishMagickMemory ( offsets ) ; if ( runlength == ( size_t * ) NULL ) runlength = ( size_t * ) RelinquishMagickMemory ( runlength ) ; if ( packet_info == ( MemoryInfo * ) NULL ) packet_info = RelinquishVirtualMemory ( packet_info ) ; ThrowReaderException ( ResourceLimitError , \"MemoryAllocationFailed\" ) ; } packets = ( unsigned char * ) GetVirtualMemoryBlob ( packet_info ) ; for ( i = 0 ; i < ( ssize_t ) ( iris_info . rows * iris_info . depth ) ; i ++ ) offsets [ i ] = ReadBlobMSBSignedLong ( image ) ; for ( i = 0 ; i < ( ssize_t ) ( iris_info . rows * iris_info . depth ) ; i ++ ) { runlength [ i ] = ReadBlobMSBLong ( image ) ; if ( runlength [ i ] > ( 4 * ( size_t ) iris_info . columns + 10 ) ) ThrowReaderException ( CorruptImageError , \"ImproperImageHeader\" ) ; } offset = 0 ; data_order = 0 ; for ( y = 0 ; ( ( y < ( ssize_t ) iris_info . rows ) && ( data_order == 0 ) ) ; y ++ ) for ( z = 0 ; ( ( z < ( ssize_t ) iris_info . depth ) && ( data_order == 0 ) ) ; z ++ ) { if ( offsets [ y + z * iris_info . rows ] < offset ) data_order = 1 ; offset = offsets [ y + z * iris_info . rows ] ; } offset = ( ssize_t ) TellBlob ( image ) ; if ( data_order == 1 ) { for ( z = 0 ; z < ( ssize_t ) iris_info . depth ; z ++ ) { p = pixels ; for ( y = 0 ; y < ( ssize_t ) iris_info . rows ; y ++ ) { if ( offset != offsets [ y + z * iris_info . rows ] ) { offset = offsets [ y + z * iris_info . rows ] ; offset = ( ssize_t ) SeekBlob ( image , ( ssize_t ) offset , SEEK_SET ) ; } count = ReadBlob ( image , ( size_t ) runlength [ y + z * iris_info . rows ] , packets ) ; if ( EOFBlob ( image ) != MagickFalse ) break ; offset += ( ssize_t ) runlength [ y + z * iris_info . rows ] ; status = SGIDecode ( bytes_per_pixel , ( ssize_t ) ( runlength [ y + z * iris_info . rows ] / bytes_per_pixel ) , packets , 1L * iris_info . columns , p + bytes_per_pixel * z ) ; if ( status == MagickFalse ) ThrowReaderException ( CorruptImageError , \"ImproperImageHeader\" ) ; p += ( iris_info . columns * 4 * bytes_per_pixel ) ; } } } else { MagickOffsetType position ; position = TellBlob ( image ) ; p = pixels ; for ( y = 0 ; y < ( ssize_t ) iris_info . rows ; y ++ ) { for ( z = 0 ; z < ( ssize_t ) iris_info . depth ; z ++ ) { if ( offset != offsets [ y + z * iris_info . rows ] ) { offset = offsets [ y + z * iris_info . rows ] ; offset = ( ssize_t ) SeekBlob ( image , ( ssize_t ) offset , SEEK_SET ) ; } count = ReadBlob ( image , ( size_t ) runlength [ y + z * iris_info . rows ] , packets ) ; if ( EOFBlob ( image ) != MagickFalse ) break ; offset += ( ssize_t ) runlength [ y + z * iris_info . rows ] ; status = SGIDecode ( bytes_per_pixel , ( ssize_t ) ( runlength [ y + z * iris_info . rows ] / bytes_per_pixel ) , packets , 1L * iris_info . columns , p + bytes_per_pixel * z ) ; if ( status == MagickFalse ) ThrowReaderException ( CorruptImageError , \"ImproperImageHeader\" ) ; } p += ( iris_info . columns * 4 * bytes_per_pixel ) ; } offset = ( ssize_t ) SeekBlob ( image , position , SEEK_SET ) ; } packet_info = RelinquishVirtualMemory ( packet_info ) ; runlength = ( size_t * ) RelinquishMagickMemory ( runlength ) ; offsets = ( ssize_t * ) RelinquishMagickMemory ( offsets ) ; } image -> alpha_trait = iris_info . depth == 4 ? BlendPixelTrait : UndefinedPixelTrait ; image -> columns = iris_info . columns ; image -> rows = iris_info . rows ; if ( image -> storage_class == DirectClass ) { if ( bytes_per_pixel == 2 ) { for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { p = pixels + ( image -> rows - y - 1 ) * 8 * image -> columns ; q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { SetPixelRed ( image , ScaleShortToQuantum ( ( unsigned short ) ( ( * ( p + 0 ) << 8 ) | ( * ( p + 1 ) ) ) ) , q ) ; SetPixelGreen ( image , ScaleShortToQuantum ( ( unsigned short ) ( ( * ( p + 2 ) << 8 ) | ( * ( p + 3 ) ) ) ) , q ) ; SetPixelBlue ( image , ScaleShortToQuantum ( ( unsigned short ) ( ( * ( p + 4 ) << 8 ) | ( * ( p + 5 ) ) ) ) , q ) ; SetPixelAlpha ( image , OpaqueAlpha , q ) ; if ( image -> alpha_trait != UndefinedPixelTrait ) SetPixelAlpha ( image , ScaleShortToQuantum ( ( unsigned short ) ( ( * ( p + 6 ) << 8 ) | ( * ( p + 7 ) ) ) ) , q ) ; p += 8 ; q += GetPixelChannels ( image ) ; } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ; if ( status == MagickFalse ) break ; } } } else for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { p = pixels + ( image -> rows - y - 1 ) * 4 * image -> columns ; q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { SetPixelRed ( image , ScaleCharToQuantum ( * p ) , q ) ; SetPixelGreen ( image , ScaleCharToQuantum ( * ( p + 1 ) ) , q ) ; SetPixelBlue ( image , ScaleCharToQuantum ( * ( p + 2 ) ) , q ) ; SetPixelAlpha ( image , OpaqueAlpha , q ) ; if ( image -> alpha_trait != UndefinedPixelTrait ) SetPixelAlpha ( image , ScaleCharToQuantum ( * ( p + 3 ) ) , q ) ; p += 4 ; q += GetPixelChannels ( image ) ; } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ; if ( status == MagickFalse ) break ; } } } else { if ( AcquireImageColormap ( image , image -> colors , exception ) == MagickFalse ) ThrowReaderException ( ResourceLimitError , \"MemoryAllocationFailed\" ) ; if ( bytes_per_pixel == 2 ) { for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { p = pixels + ( image -> rows - y - 1 ) * 8 * image -> columns ; q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { quantum = ( * p << 8 ) ; quantum |= ( * ( p + 1 ) ) ; SetPixelIndex ( image , ( Quantum ) quantum , q ) ; p += 8 ; q += GetPixelChannels ( image ) ; } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ; if ( status == MagickFalse ) break ; } } } else for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { p = pixels + ( image -> rows - y - 1 ) * 4 * image -> columns ; q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { SetPixelIndex ( image , * p , q ) ; p += 4 ; q += GetPixelChannels ( image ) ; } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ; if ( status == MagickFalse ) break ; } } ( void ) SyncImage ( image , exception ) ; } pixel_info = RelinquishVirtualMemory ( pixel_info ) ; if ( EOFBlob ( image ) != MagickFalse ) { ThrowFileException ( exception , CorruptImageError , \"UnexpectedEndOfFile\" , image -> filename ) ; break ; } if ( image_info -> number_scenes != 0 ) if ( image -> scene >= ( image_info -> scene + image_info -> number_scenes - 1 ) ) break ; iris_info . magic = ReadBlobMSBShort ( image ) ; if ( iris_info . magic == 0x01DA ) { AcquireNextImage ( image_info , image , exception ) ; if ( GetNextImageInList ( image ) == ( Image * ) NULL ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } image = SyncNextImageInList ( image ) ; status = SetImageProgress ( image , LoadImagesTag , TellBlob ( image ) , GetBlobSize ( image ) ) ; if ( status == MagickFalse ) break ; } } while ( iris_info . magic == 0x01DA ) ; ( void ) CloseBlob ( image ) ; return ( GetFirstImageInList ( image ) ) ; }\n",
      "fixed_code": "<S2SV_ModStart> image ) ; count = <S2SV_ModEnd> ReadBlob ( image <S2SV_ModStart> iris_info . name ) ; if ( count != sizeof ( iris_info . name ) ) ThrowReaderException ( CorruptImageError , \"ImproperImageHeader\" <S2SV_ModStart> filler ) ; if ( count != sizeof ( iris_info . filler ) ) ThrowReaderException ( CorruptImageError , \"ImproperImageHeader\" ) <S2SV_ModEnd> ; image -> <S2SV_ModStart> } if ( <S2SV_ModEnd> ( image_info ->\n",
      "source_code_length": 13938,
      "target_code_length": 429,
      "vulnerability_patterns": {
        "integer_overflow": 34,
        "null_pointer": 59,
        "total": 93
      },
      "total_patterns": 93,
      "original_address": "https://github.com/ImageMagick/ImageMagick/commit/8f8959033e4e59418d6506b345829af1f7a71127",
      "discovery_time": "2017-01-18T17:59Z",
      "project_commit_id": "ImageMagick@ImageMagick/8f8959033e4e59418d6506b345829af1f7a71127",
      "extraction_time": "2025-08-31T15:41:49.183352",
      "label": 1,
      "vulnerability_type": "out-of-bounds_read",
      "difficulty_level": "advanced",
      "risk_factors": [
        "information_disclosure",
        "memory_corruption",
        "integer_overflow",
        "critical_infrastructure"
      ],
      "attack_vectors": [
        "memory_manipulation",
        "malicious_input",
        "code_analysis",
        "buffer_overflow",
        "reverse_engineering",
        "fuzzing"
      ],
      "mitigation_strategies": [
        "safe_string_functions",
        "dynamic_analysis",
        "code_review",
        "static_analysis",
        "memory_safety_checks",
        "input_validation",
        "fuzzing",
        "bounds_checking",
        "secure_coding_practices"
      ],
      "code_differences": {
        "has_differences": true,
        "source_lines": 2,
        "target_lines": 2,
        "character_differences": 13509,
        "similarity_percentage": 10.552763819095476
      },
      "vulnerability_location": {
        "vulnerability_present": true,
        "fix_applied": true,
        "code_changed": true,
        "estimated_lines_changed": 0
      }
    },
    {
      "cve_id": "CVE-2016-1621",
      "cwe_id": "CWE-119",
      "cwe_name": "Buffer Overflow",
      "project": "external",
      "severity": "critical",
      "weaponization_score": 8.5,
      "is_critical": true,
      "is_weaponizable": true,
      "is_high_priority_project": false,
      "vulnerable_code": "CWE-119 int main ( int argc , char * * argv ) { int frame_cnt = 0 ; FILE * outfile = NULL ; vpx_codec_ctx_t codec ; const VpxInterface * decoder = NULL ; VpxVideoReader * reader = NULL ; const VpxVideoInfo * info = NULL ; int n = 0 ; int m = 0 ; int is_range = 0 ; char * nptr = NULL ; exec_name = argv [ 0 ] ; if ( argc != 4 ) die ( \"Invalid<S2SV_blank>number<S2SV_blank>of<S2SV_blank>arguments.\" ) ; reader = vpx_video_reader_open ( argv [ 1 ] ) ; if ( ! reader ) die ( \"Failed<S2SV_blank>to<S2SV_blank>open<S2SV_blank>%s<S2SV_blank>for<S2SV_blank>reading.\" , argv [ 1 ] ) ; if ( ! ( outfile = fopen ( argv [ 2 ] , \"wb\" ) ) ) die ( \"Failed<S2SV_blank>to<S2SV_blank>open<S2SV_blank>%s<S2SV_blank>for<S2SV_blank>writing.\" , argv [ 2 ] ) ; n = strtol ( argv [ 3 ] , & nptr , 0 ) ; m = strtol ( nptr + 1 , NULL , 0 ) ; is_range = ( * nptr == '-' ) ; if ( ! n || ! m || ( * nptr != '-' && * nptr != '/' ) ) die ( \"Couldn\\'t<S2SV_blank>parse<S2SV_blank>pattern<S2SV_blank>%s.\\\\n\" , argv [ 3 ] ) ; info = vpx_video_reader_get_info ( reader ) ; decoder = get_vpx_decoder_by_fourcc ( info -> codec_fourcc ) ; if ( ! decoder ) die ( \"Unknown<S2SV_blank>input<S2SV_blank>codec.\" ) ; <S2SV_StartBug> printf ( \"Using<S2SV_blank>%s\\\\n\" , vpx_codec_iface_name ( decoder -> interface ( ) ) ) ; <S2SV_EndBug> <S2SV_StartBug> if ( vpx_codec_dec_init ( & codec , decoder -> interface ( ) , NULL , 0 ) ) <S2SV_EndBug> die_codec ( & codec , \"Failed<S2SV_blank>to<S2SV_blank>initialize<S2SV_blank>decoder.\" ) ; while ( vpx_video_reader_read_frame ( reader ) ) { vpx_codec_iter_t iter = NULL ; vpx_image_t * img = NULL ; size_t frame_size = 0 ; int skip ; const unsigned char * frame = vpx_video_reader_get_frame ( reader , & frame_size ) ; if ( vpx_codec_decode ( & codec , frame , ( unsigned int ) frame_size , NULL , 0 ) ) die_codec ( & codec , \"Failed<S2SV_blank>to<S2SV_blank>decode<S2SV_blank>frame.\" ) ; ++ frame_cnt ; skip = ( is_range && frame_cnt >= n && frame_cnt <= m ) || ( ! is_range && m - ( frame_cnt - 1 ) % m <= n ) ; if ( ! skip ) { putc ( '.' , stdout ) ; while ( ( img = vpx_codec_get_frame ( & codec , & iter ) ) != NULL ) vpx_img_write ( img , outfile ) ; } else { putc ( 'X' , stdout ) ; } fflush ( stdout ) ; } printf ( \"Processed<S2SV_blank>%d<S2SV_blank>frames.\\\\n\" , frame_cnt ) ; if ( vpx_codec_destroy ( & codec ) ) die_codec ( & codec , \"Failed<S2SV_blank>to<S2SV_blank>destroy<S2SV_blank>codec.\" ) ; printf ( \"Play:<S2SV_blank>ffplay<S2SV_blank>-f<S2SV_blank>rawvideo<S2SV_blank>-pix_fmt<S2SV_blank>yuv420p<S2SV_blank>-s<S2SV_blank>%dx%d<S2SV_blank>%s\\\\n\" , info -> frame_width , info -> frame_height , argv [ 2 ] ) ; vpx_video_reader_close ( reader ) ; fclose ( outfile ) ; return EXIT_SUCCESS ; }\n",
      "fixed_code": "<S2SV_ModStart> ( decoder -> codec_interface <S2SV_ModEnd> ( ) ) <S2SV_ModStart> , decoder -> codec_interface <S2SV_ModEnd> ( ) ,\n",
      "source_code_length": 2710,
      "target_code_length": 130,
      "vulnerability_patterns": {
        "buffer_overflow": 1,
        "integer_overflow": 7,
        "null_pointer": 23,
        "total": 31
      },
      "total_patterns": 31,
      "original_address": "https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426",
      "discovery_time": "2016-03-12T21:59Z",
      "project_commit_id": "external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426",
      "extraction_time": "2025-08-31T15:41:49.183447",
      "label": 1,
      "vulnerability_type": "buffer_overflow",
      "difficulty_level": "advanced",
      "risk_factors": [
        "system_crash",
        "memory_corruption",
        "buffer_overflow",
        "arbitrary_code_execution"
      ],
      "attack_vectors": [
        "memory_manipulation",
        "malicious_input",
        "code_analysis",
        "buffer_overflow",
        "reverse_engineering",
        "fuzzing"
      ],
      "mitigation_strategies": [
        "safe_string_functions",
        "dynamic_analysis",
        "code_review",
        "static_analysis",
        "memory_safety_checks",
        "input_validation",
        "fuzzing",
        "bounds_checking",
        "secure_coding_practices"
      ],
      "code_differences": {
        "has_differences": true,
        "source_lines": 2,
        "target_lines": 2,
        "character_differences": 2580,
        "similarity_percentage": 4.464285714285714
      },
      "vulnerability_location": {
        "vulnerability_present": true,
        "fix_applied": true,
        "code_changed": true,
        "estimated_lines_changed": 0
      }
    },
    {
      "cve_id": "CVE-2012-3364",
      "cwe_id": "CWE-119",
      "cwe_name": "Buffer Overflow",
      "project": "torvalds",
      "severity": "critical",
      "weaponization_score": 8.5,
      "is_critical": true,
      "is_weaponizable": true,
      "is_high_priority_project": false,
      "vulnerable_code": "CWE-119 static __u8 * nci_extract_rf_params_nfcf_passive_poll ( struct nci_dev * ndev , struct rf_tech_specific_params_nfcf_poll * nfcf_poll , __u8 * data ) { nfcf_poll -> bit_rate = * data ++ ; <S2SV_StartBug> nfcf_poll -> sensf_res_len = * data ++ ; <S2SV_EndBug> pr_debug ( \"bit_rate<S2SV_blank>%d,<S2SV_blank>sensf_res_len<S2SV_blank>%d\\\\n\" , nfcf_poll -> bit_rate , nfcf_poll -> sensf_res_len ) ; memcpy ( nfcf_poll -> sensf_res , data , nfcf_poll -> sensf_res_len ) ; data += nfcf_poll -> sensf_res_len ; return data ; }\n",
      "fixed_code": "<S2SV_ModStart> -> sensf_res_len = min_t ( __u8 , <S2SV_ModStart> * data ++ , NFC_SENSF_RES_MAXSIZE )\n",
      "source_code_length": 527,
      "target_code_length": 102,
      "vulnerability_patterns": {
        "buffer_overflow": 2,
        "integer_overflow": 2,
        "null_pointer": 14,
        "total": 18
      },
      "total_patterns": 18,
      "original_address": "https://github.com/torvalds/linux/commit/67de956ff5dc1d4f321e16cfbd63f5be3b691b43",
      "discovery_time": "2013-01-22T23:55Z",
      "project_commit_id": "torvalds@linux/67de956ff5dc1d4f321e16cfbd63f5be3b691b43",
      "extraction_time": "2025-08-31T15:41:49.183490",
      "label": 1,
      "vulnerability_type": "buffer_overflow",
      "difficulty_level": "advanced",
      "risk_factors": [
        "system_crash",
        "memory_corruption",
        "buffer_overflow",
        "arbitrary_code_execution"
      ],
      "attack_vectors": [
        "memory_manipulation",
        "malicious_input",
        "code_analysis",
        "buffer_overflow",
        "reverse_engineering",
        "fuzzing"
      ],
      "mitigation_strategies": [
        "safe_string_functions",
        "dynamic_analysis",
        "code_review",
        "static_analysis",
        "memory_safety_checks",
        "input_validation",
        "fuzzing",
        "bounds_checking",
        "secure_coding_practices"
      ],
      "code_differences": {
        "has_differences": true,
        "source_lines": 2,
        "target_lines": 2,
        "character_differences": 425,
        "similarity_percentage": 30.303030303030305
      },
      "vulnerability_location": {
        "vulnerability_present": true,
        "fix_applied": true,
        "code_changed": true,
        "estimated_lines_changed": 0
      }
    },
    {
      "cve_id": "CVE-2019-11339",
      "cwe_id": "CWE-125",
      "cwe_name": "Out-of-bounds Read",
      "project": "FFmpeg",
      "severity": "critical",
      "weaponization_score": 8.5,
      "is_critical": true,
      "is_weaponizable": true,
      "is_high_priority_project": true,
      "vulnerable_code": "CWE-125 static int decode_studio_vop_header ( Mpeg4DecContext * ctx , GetBitContext * gb ) { MpegEncContext * s = & ctx -> m ; if ( get_bits_left ( gb ) <= 32 ) return 0 ; s -> partitioned_frame = 0 ; <S2SV_StartBug> s -> decode_mb = mpeg4_decode_studio_mb ; <S2SV_EndBug> decode_smpte_tc ( ctx , gb ) ; skip_bits ( gb , 10 ) ; skip_bits ( gb , 2 ) ; s -> pict_type = get_bits ( gb , 2 ) + AV_PICTURE_TYPE_I ; if ( get_bits1 ( gb ) ) { skip_bits1 ( gb ) ; skip_bits1 ( gb ) ; s -> progressive_frame = get_bits1 ( gb ) ^ 1 ; } if ( s -> pict_type == AV_PICTURE_TYPE_I ) { if ( get_bits1 ( gb ) ) reset_studio_dc_predictors ( s ) ; } if ( ctx -> shape != BIN_ONLY_SHAPE ) { s -> alternate_scan = get_bits1 ( gb ) ; s -> frame_pred_frame_dct = get_bits1 ( gb ) ; s -> dct_precision = get_bits ( gb , 2 ) ; s -> intra_dc_precision = get_bits ( gb , 2 ) ; s -> q_scale_type = get_bits1 ( gb ) ; } if ( s -> alternate_scan ) { ff_init_scantable ( s -> idsp . idct_permutation , & s -> inter_scantable , ff_alternate_vertical_scan ) ; ff_init_scantable ( s -> idsp . idct_permutation , & s -> intra_scantable , ff_alternate_vertical_scan ) ; ff_init_scantable ( s -> idsp . idct_permutation , & s -> intra_h_scantable , ff_alternate_vertical_scan ) ; ff_init_scantable ( s -> idsp . idct_permutation , & s -> intra_v_scantable , ff_alternate_vertical_scan ) ; } else { ff_init_scantable ( s -> idsp . idct_permutation , & s -> inter_scantable , ff_zigzag_direct ) ; ff_init_scantable ( s -> idsp . idct_permutation , & s -> intra_scantable , ff_zigzag_direct ) ; ff_init_scantable ( s -> idsp . idct_permutation , & s -> intra_h_scantable , ff_alternate_horizontal_scan ) ; ff_init_scantable ( s -> idsp . idct_permutation , & s -> intra_v_scantable , ff_alternate_vertical_scan ) ; } mpeg4_load_default_matrices ( s ) ; next_start_code_studio ( gb ) ; extension_and_user_data ( s , gb , 4 ) ; return 0 ; }\n",
      "fixed_code": "<S2SV_ModStart> ; s -> interlaced_dct = 0 ; s ->\n",
      "source_code_length": 1900,
      "target_code_length": 49,
      "vulnerability_patterns": {
        "null_pointer": 29,
        "total": 29
      },
      "total_patterns": 29,
      "original_address": "https://github.com/FFmpeg/FFmpeg/commit/1f686d023b95219db933394a7704ad9aa5f01cbb",
      "discovery_time": "2019-04-19T00:29Z",
      "project_commit_id": "FFmpeg@FFmpeg/1f686d023b95219db933394a7704ad9aa5f01cbb",
      "extraction_time": "2025-08-31T15:41:49.183519",
      "label": 1,
      "vulnerability_type": "out-of-bounds_read",
      "difficulty_level": "advanced",
      "risk_factors": [
        "information_disclosure",
        "memory_corruption",
        "integer_overflow",
        "critical_infrastructure"
      ],
      "attack_vectors": [
        "memory_manipulation",
        "malicious_input",
        "code_analysis",
        "buffer_overflow",
        "reverse_engineering",
        "fuzzing"
      ],
      "mitigation_strategies": [
        "safe_string_functions",
        "dynamic_analysis",
        "code_review",
        "static_analysis",
        "memory_safety_checks",
        "input_validation",
        "fuzzing",
        "bounds_checking",
        "secure_coding_practices"
      ],
      "code_differences": {
        "has_differences": true,
        "source_lines": 2,
        "target_lines": 2,
        "character_differences": 1851,
        "similarity_percentage": 6.8493150684931505
      },
      "vulnerability_location": {
        "vulnerability_present": true,
        "fix_applied": true,
        "code_changed": true,
        "estimated_lines_changed": 0
      }
    },
    {
      "cve_id": "CVE-2014-4343",
      "cwe_id": "CWE-415",
      "cwe_name": "Double Free",
      "project": "krb5",
      "severity": "critical",
      "weaponization_score": 8.5,
      "is_critical": true,
      "is_weaponizable": true,
      "is_high_priority_project": true,
      "vulnerable_code": "CWE-415 static OM_uint32 init_ctx_reselect ( OM_uint32 * minor_status , spnego_gss_ctx_id_t sc , OM_uint32 acc_negState , gss_OID supportedMech , gss_buffer_t * responseToken , gss_buffer_t * mechListMIC , OM_uint32 * negState , send_token_flag * tokflag ) { OM_uint32 tmpmin ; <S2SV_StartBug> size_t i ; <S2SV_EndBug> generic_gss_release_oid ( & tmpmin , & sc -> internal_mech ) ; gss_delete_sec_context ( & tmpmin , & sc -> ctx_handle , GSS_C_NO_BUFFER ) ; for ( i = 0 ; i < sc -> mech_set -> count ; i ++ ) { if ( g_OID_equal ( supportedMech , & sc -> mech_set -> elements [ i ] ) ) break ; } if ( i == sc -> mech_set -> count ) return GSS_S_DEFECTIVE_TOKEN ; sc -> internal_mech = & sc -> mech_set -> elements [ i ] ; if ( acc_negState != REQUEST_MIC ) return GSS_S_DEFECTIVE_TOKEN ; sc -> mech_complete = 0 ; sc -> mic_reqd = 1 ; * negState = REQUEST_MIC ; * tokflag = CONT_TOKEN_SEND ; return GSS_S_CONTINUE_NEEDED ; }\n",
      "fixed_code": "<S2SV_ModStart> ; size_t i <S2SV_ModEnd> ; gss_delete_sec_context (\n",
      "source_code_length": 925,
      "target_code_length": 68,
      "vulnerability_patterns": {
        "integer_overflow": 1,
        "null_pointer": 13,
        "total": 14
      },
      "total_patterns": 14,
      "original_address": "https://github.com/krb5/krb5/commit/f18ddf5d82de0ab7591a36e465bc24225776940f",
      "discovery_time": "2014-08-14T05:01Z",
      "project_commit_id": "krb5@krb5/f18ddf5d82de0ab7591a36e465bc24225776940f",
      "extraction_time": "2025-08-31T15:41:49.183554",
      "label": 1,
      "vulnerability_type": "double_free",
      "difficulty_level": "advanced",
      "risk_factors": [
        "system_crash",
        "denial_of_service",
        "memory_corruption",
        "critical_infrastructure"
      ],
      "attack_vectors": [
        "memory_manipulation",
        "null_pointer",
        "code_analysis",
        "reverse_engineering",
        "use_after_free",
        "fuzzing"
      ],
      "mitigation_strategies": [
        "null_pointer_checks",
        "fuzzing",
        "dynamic_analysis",
        "memory_management",
        "static_analysis",
        "use_after_free_prevention",
        "code_review",
        "secure_coding_practices"
      ],
      "code_differences": {
        "has_differences": true,
        "source_lines": 2,
        "target_lines": 2,
        "character_differences": 857,
        "similarity_percentage": 8.333333333333332
      },
      "vulnerability_location": {
        "vulnerability_present": true,
        "fix_applied": true,
        "code_changed": true,
        "estimated_lines_changed": 0
      }
    },
    {
      "cve_id": "CVE-2016-1621",
      "cwe_id": "CWE-119",
      "cwe_name": "Buffer Overflow",
      "project": "external",
      "severity": "critical",
      "weaponization_score": 8.5,
      "is_critical": true,
      "is_weaponizable": true,
      "is_high_priority_project": false,
      "vulnerable_code": "CWE-119 int main ( int argc , char * * argv ) { int frame_cnt = 0 ; FILE * outfile = NULL ; vpx_codec_ctx_t codec ; const VpxInterface * decoder = NULL ; VpxVideoReader * reader = NULL ; const VpxVideoInfo * info = NULL ; int n = 0 ; int m = 0 ; int is_range = 0 ; char * nptr = NULL ; exec_name = argv [ 0 ] ; if ( argc != 4 ) die ( \"Invalid<S2SV_blank>number<S2SV_blank>of<S2SV_blank>arguments.\" ) ; reader = vpx_video_reader_open ( argv [ 1 ] ) ; if ( ! reader ) die ( \"Failed<S2SV_blank>to<S2SV_blank>open<S2SV_blank>%s<S2SV_blank>for<S2SV_blank>reading.\" , argv [ 1 ] ) ; if ( ! ( outfile = fopen ( argv [ 2 ] , \"wb\" ) ) ) die ( \"Failed<S2SV_blank>to<S2SV_blank>open<S2SV_blank>%s<S2SV_blank>for<S2SV_blank>writing.\" , argv [ 2 ] ) ; n = strtol ( argv [ 3 ] , & nptr , 0 ) ; m = strtol ( nptr + 1 , NULL , 0 ) ; is_range = ( * nptr == '-' ) ; if ( ! n || ! m || ( * nptr != '-' && * nptr != '/' ) ) die ( \"Couldn\\'t<S2SV_blank>parse<S2SV_blank>pattern<S2SV_blank>%s.\\\\n\" , argv [ 3 ] ) ; info = vpx_video_reader_get_info ( reader ) ; decoder = get_vpx_decoder_by_fourcc ( info -> codec_fourcc ) ; if ( ! decoder ) die ( \"Unknown<S2SV_blank>input<S2SV_blank>codec.\" ) ; <S2SV_StartBug> printf ( \"Using<S2SV_blank>%s\\\\n\" , vpx_codec_iface_name ( decoder -> interface ( ) ) ) ; <S2SV_EndBug> <S2SV_StartBug> if ( vpx_codec_dec_init ( & codec , decoder -> interface ( ) , NULL , 0 ) ) <S2SV_EndBug> die_codec ( & codec , \"Failed<S2SV_blank>to<S2SV_blank>initialize<S2SV_blank>decoder.\" ) ; while ( vpx_video_reader_read_frame ( reader ) ) { vpx_codec_iter_t iter = NULL ; vpx_image_t * img = NULL ; size_t frame_size = 0 ; int skip ; const unsigned char * frame = vpx_video_reader_get_frame ( reader , & frame_size ) ; if ( vpx_codec_decode ( & codec , frame , ( unsigned int ) frame_size , NULL , 0 ) ) die_codec ( & codec , \"Failed<S2SV_blank>to<S2SV_blank>decode<S2SV_blank>frame.\" ) ; ++ frame_cnt ; skip = ( is_range && frame_cnt >= n && frame_cnt <= m ) || ( ! is_range && m - ( frame_cnt - 1 ) % m <= n ) ; if ( ! skip ) { putc ( '.' , stdout ) ; while ( ( img = vpx_codec_get_frame ( & codec , & iter ) ) != NULL ) vpx_img_write ( img , outfile ) ; } else { putc ( 'X' , stdout ) ; } fflush ( stdout ) ; } printf ( \"Processed<S2SV_blank>%d<S2SV_blank>frames.\\\\n\" , frame_cnt ) ; if ( vpx_codec_destroy ( & codec ) ) die_codec ( & codec , \"Failed<S2SV_blank>to<S2SV_blank>destroy<S2SV_blank>codec.\" ) ; printf ( \"Play:<S2SV_blank>ffplay<S2SV_blank>-f<S2SV_blank>rawvideo<S2SV_blank>-pix_fmt<S2SV_blank>yuv420p<S2SV_blank>-s<S2SV_blank>%dx%d<S2SV_blank>%s\\\\n\" , info -> frame_width , info -> frame_height , argv [ 2 ] ) ; vpx_video_reader_close ( reader ) ; fclose ( outfile ) ; return EXIT_SUCCESS ; }\n",
      "fixed_code": "<S2SV_ModStart> ( decoder -> codec_interface <S2SV_ModEnd> ( ) ) <S2SV_ModStart> , decoder -> codec_interface <S2SV_ModEnd> ( ) ,\n",
      "source_code_length": 2710,
      "target_code_length": 130,
      "vulnerability_patterns": {
        "buffer_overflow": 1,
        "integer_overflow": 6,
        "null_pointer": 10,
        "total": 17
      },
      "total_patterns": 17,
      "original_address": "https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426",
      "discovery_time": "2016-03-12T21:59Z",
      "project_commit_id": "external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426",
      "extraction_time": "2025-08-31T15:41:49.183568",
      "label": 1,
      "vulnerability_type": "buffer_overflow",
      "difficulty_level": "advanced",
      "risk_factors": [
        "system_crash",
        "memory_corruption",
        "buffer_overflow",
        "arbitrary_code_execution"
      ],
      "attack_vectors": [
        "memory_manipulation",
        "malicious_input",
        "code_analysis",
        "buffer_overflow",
        "reverse_engineering",
        "fuzzing"
      ],
      "mitigation_strategies": [
        "safe_string_functions",
        "dynamic_analysis",
        "code_review",
        "static_analysis",
        "memory_safety_checks",
        "input_validation",
        "fuzzing",
        "bounds_checking",
        "secure_coding_practices"
      ],
      "code_differences": {
        "has_differences": true,
        "source_lines": 2,
        "target_lines": 2,
        "character_differences": 2580,
        "similarity_percentage": 4.464285714285714
      },
      "vulnerability_location": {
        "vulnerability_present": true,
        "fix_applied": true,
        "code_changed": true,
        "estimated_lines_changed": 0
      }
    },
    {
      "cve_id": "CVE-2016-1621",
      "cwe_id": "CWE-119",
      "cwe_name": "Buffer Overflow",
      "project": "external",
      "severity": "critical",
      "weaponization_score": 8.5,
      "is_critical": true,
      "is_weaponizable": true,
      "is_high_priority_project": false,
      "vulnerable_code": "CWE-119 int main ( int argc , char * * argv ) { int frame_cnt = 0 ; FILE * outfile = NULL ; vpx_codec_ctx_t codec ; const VpxInterface * decoder = NULL ; VpxVideoReader * reader = NULL ; const VpxVideoInfo * info = NULL ; int n = 0 ; int m = 0 ; int is_range = 0 ; char * nptr = NULL ; exec_name = argv [ 0 ] ; if ( argc != 4 ) die ( \"Invalid<S2SV_blank>number<S2SV_blank>of<S2SV_blank>arguments.\" ) ; reader = vpx_video_reader_open ( argv [ 1 ] ) ; if ( ! reader ) die ( \"Failed<S2SV_blank>to<S2SV_blank>open<S2SV_blank>%s<S2SV_blank>for<S2SV_blank>reading.\" , argv [ 1 ] ) ; if ( ! ( outfile = fopen ( argv [ 2 ] , \"wb\" ) ) ) die ( \"Failed<S2SV_blank>to<S2SV_blank>open<S2SV_blank>%s<S2SV_blank>for<S2SV_blank>writing.\" , argv [ 2 ] ) ; n = strtol ( argv [ 3 ] , & nptr , 0 ) ; m = strtol ( nptr + 1 , NULL , 0 ) ; is_range = ( * nptr == '-' ) ; if ( ! n || ! m || ( * nptr != '-' && * nptr != '/' ) ) die ( \"Couldn\\'t<S2SV_blank>parse<S2SV_blank>pattern<S2SV_blank>%s.\\\\n\" , argv [ 3 ] ) ; info = vpx_video_reader_get_info ( reader ) ; decoder = get_vpx_decoder_by_fourcc ( info -> codec_fourcc ) ; if ( ! decoder ) die ( \"Unknown<S2SV_blank>input<S2SV_blank>codec.\" ) ; <S2SV_StartBug> printf ( \"Using<S2SV_blank>%s\\\\n\" , vpx_codec_iface_name ( decoder -> interface ( ) ) ) ; <S2SV_EndBug> <S2SV_StartBug> if ( vpx_codec_dec_init ( & codec , decoder -> interface ( ) , NULL , 0 ) ) <S2SV_EndBug> die_codec ( & codec , \"Failed<S2SV_blank>to<S2SV_blank>initialize<S2SV_blank>decoder.\" ) ; while ( vpx_video_reader_read_frame ( reader ) ) { vpx_codec_iter_t iter = NULL ; vpx_image_t * img = NULL ; size_t frame_size = 0 ; int skip ; const unsigned char * frame = vpx_video_reader_get_frame ( reader , & frame_size ) ; if ( vpx_codec_decode ( & codec , frame , ( unsigned int ) frame_size , NULL , 0 ) ) die_codec ( & codec , \"Failed<S2SV_blank>to<S2SV_blank>decode<S2SV_blank>frame.\" ) ; ++ frame_cnt ; skip = ( is_range && frame_cnt >= n && frame_cnt <= m ) || ( ! is_range && m - ( frame_cnt - 1 ) % m <= n ) ; if ( ! skip ) { putc ( '.' , stdout ) ; while ( ( img = vpx_codec_get_frame ( & codec , & iter ) ) != NULL ) vpx_img_write ( img , outfile ) ; } else { putc ( 'X' , stdout ) ; } fflush ( stdout ) ; } printf ( \"Processed<S2SV_blank>%d<S2SV_blank>frames.\\\\n\" , frame_cnt ) ; if ( vpx_codec_destroy ( & codec ) ) die_codec ( & codec , \"Failed<S2SV_blank>to<S2SV_blank>destroy<S2SV_blank>codec.\" ) ; printf ( \"Play:<S2SV_blank>ffplay<S2SV_blank>-f<S2SV_blank>rawvideo<S2SV_blank>-pix_fmt<S2SV_blank>yuv420p<S2SV_blank>-s<S2SV_blank>%dx%d<S2SV_blank>%s\\\\n\" , info -> frame_width , info -> frame_height , argv [ 2 ] ) ; vpx_video_reader_close ( reader ) ; fclose ( outfile ) ; return EXIT_SUCCESS ; }\n",
      "fixed_code": "<S2SV_ModStart> ( decoder -> codec_interface <S2SV_ModEnd> ( ) ) <S2SV_ModStart> , decoder -> codec_interface <S2SV_ModEnd> ( ) ,\n",
      "source_code_length": 2710,
      "target_code_length": 130,
      "vulnerability_patterns": {
        "buffer_overflow": 1,
        "integer_overflow": 1,
        "null_pointer": 8,
        "total": 10
      },
      "total_patterns": 10,
      "original_address": "https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426",
      "discovery_time": "2016-03-12T21:59Z",
      "project_commit_id": "external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426",
      "extraction_time": "2025-08-31T15:41:49.183584",
      "label": 1,
      "vulnerability_type": "buffer_overflow",
      "difficulty_level": "advanced",
      "risk_factors": [
        "system_crash",
        "memory_corruption",
        "buffer_overflow",
        "arbitrary_code_execution"
      ],
      "attack_vectors": [
        "memory_manipulation",
        "malicious_input",
        "code_analysis",
        "buffer_overflow",
        "reverse_engineering",
        "fuzzing"
      ],
      "mitigation_strategies": [
        "safe_string_functions",
        "dynamic_analysis",
        "code_review",
        "static_analysis",
        "memory_safety_checks",
        "input_validation",
        "fuzzing",
        "bounds_checking",
        "secure_coding_practices"
      ],
      "code_differences": {
        "has_differences": true,
        "source_lines": 2,
        "target_lines": 2,
        "character_differences": 2580,
        "similarity_percentage": 4.464285714285714
      },
      "vulnerability_location": {
        "vulnerability_present": true,
        "fix_applied": true,
        "code_changed": true,
        "estimated_lines_changed": 0
      }
    },
    {
      "cve_id": "CVE-2018-1999010",
      "cwe_id": "CWE-125",
      "cwe_name": "Out-of-bounds Read",
      "project": "FFmpeg",
      "severity": "critical",
      "weaponization_score": 8.5,
      "is_critical": true,
      "is_weaponizable": true,
      "is_high_priority_project": true,
      "vulnerable_code": "CWE-125 int ff_mms_asf_header_parser ( MMSContext * mms ) { uint8_t * p = mms -> asf_header ; uint8_t * end ; int flags , stream_id ; mms -> stream_num = 0 ; if ( mms -> asf_header_size < sizeof ( ff_asf_guid ) * 2 + 22 || memcmp ( p , ff_asf_header , sizeof ( ff_asf_guid ) ) ) { av_log ( NULL , AV_LOG_ERROR , \"Corrupt<S2SV_blank>stream<S2SV_blank>(invalid<S2SV_blank>ASF<S2SV_blank>header,<S2SV_blank>size=%d)\\\\n\" , mms -> asf_header_size ) ; return AVERROR_INVALIDDATA ; } end = mms -> asf_header + mms -> asf_header_size ; p += sizeof ( ff_asf_guid ) + 14 ; while ( end - p >= sizeof ( ff_asf_guid ) + 8 ) { uint64_t chunksize ; if ( ! memcmp ( p , ff_asf_data_header , sizeof ( ff_asf_guid ) ) ) { chunksize = 50 ; } else { chunksize = AV_RL64 ( p + sizeof ( ff_asf_guid ) ) ; } if ( ! chunksize || chunksize > end - p ) { av_log ( NULL , AV_LOG_ERROR , \"Corrupt<S2SV_blank>stream<S2SV_blank>(header<S2SV_blank>chunksize<S2SV_blank>%\" PRId64 \"<S2SV_blank>is<S2SV_blank>invalid)\\\\n\" , chunksize ) ; return AVERROR_INVALIDDATA ; } if ( ! memcmp ( p , ff_asf_file_header , sizeof ( ff_asf_guid ) ) ) { if ( end - p > sizeof ( ff_asf_guid ) * 2 + 68 ) { mms -> asf_packet_len = AV_RL32 ( p + sizeof ( ff_asf_guid ) * 2 + 64 ) ; if ( mms -> asf_packet_len <= 0 || mms -> asf_packet_len > sizeof ( mms -> in_buffer ) ) { av_log ( NULL , AV_LOG_ERROR , \"Corrupt<S2SV_blank>stream<S2SV_blank>(too<S2SV_blank>large<S2SV_blank>pkt_len<S2SV_blank>%d)\\\\n\" , mms -> asf_packet_len ) ; return AVERROR_INVALIDDATA ; } } } else if ( ! memcmp ( p , ff_asf_stream_header , sizeof ( ff_asf_guid ) ) ) { <S2SV_StartBug> flags = AV_RL16 ( p + sizeof ( ff_asf_guid ) * 3 + 24 ) ; <S2SV_EndBug> stream_id = flags & 0x7F ; if ( mms -> stream_num < MMS_MAX_STREAMS && 46 + mms -> stream_num * 6 < sizeof ( mms -> out_buffer ) ) { mms -> streams = av_fast_realloc ( mms -> streams , & mms -> nb_streams_allocated , ( mms -> stream_num + 1 ) * sizeof ( MMSStream ) ) ; if ( ! mms -> streams ) return AVERROR ( ENOMEM ) ; mms -> streams [ mms -> stream_num ] . id = stream_id ; mms -> stream_num ++ ; } else { av_log ( NULL , AV_LOG_ERROR , \"Corrupt<S2SV_blank>stream<S2SV_blank>(too<S2SV_blank>many<S2SV_blank>A/V<S2SV_blank>streams)\\\\n\" ) ; return AVERROR_INVALIDDATA ; } <S2SV_StartBug> } else if ( ! memcmp ( p , ff_asf_ext_stream_header , sizeof ( ff_asf_guid ) ) ) { <S2SV_EndBug> if ( end - p >= 88 ) { int stream_count = AV_RL16 ( p + 84 ) , ext_len_count = AV_RL16 ( p + 86 ) ; uint64_t skip_bytes = 88 ; while ( stream_count -- ) { if ( end - p < skip_bytes + 4 ) { av_log ( NULL , AV_LOG_ERROR , \"Corrupt<S2SV_blank>stream<S2SV_blank>(next<S2SV_blank>stream<S2SV_blank>name<S2SV_blank>length<S2SV_blank>is<S2SV_blank>not<S2SV_blank>in<S2SV_blank>the<S2SV_blank>buffer)\\\\n\" ) ; return AVERROR_INVALIDDATA ; } skip_bytes += 4 + AV_RL16 ( p + skip_bytes + 2 ) ; } while ( ext_len_count -- ) { if ( end - p < skip_bytes + 22 ) { av_log ( NULL , AV_LOG_ERROR , \"Corrupt<S2SV_blank>stream<S2SV_blank>(next<S2SV_blank>extension<S2SV_blank>system<S2SV_blank>info<S2SV_blank>length<S2SV_blank>is<S2SV_blank>not<S2SV_blank>in<S2SV_blank>the<S2SV_blank>buffer)\\\\n\" ) ; return AVERROR_INVALIDDATA ; } skip_bytes += 22 + AV_RL32 ( p + skip_bytes + 18 ) ; } if ( end - p < skip_bytes ) { av_log ( NULL , AV_LOG_ERROR , \"Corrupt<S2SV_blank>stream<S2SV_blank>(the<S2SV_blank>last<S2SV_blank>extension<S2SV_blank>system<S2SV_blank>info<S2SV_blank>length<S2SV_blank>is<S2SV_blank>invalid)\\\\n\" ) ; return AVERROR_INVALIDDATA ; } if ( chunksize - skip_bytes > 24 ) chunksize = skip_bytes ; } } else if ( ! memcmp ( p , ff_asf_head1_guid , sizeof ( ff_asf_guid ) ) ) { chunksize = 46 ; <S2SV_StartBug> } <S2SV_EndBug> p += chunksize ; } return 0 ; }\n",
      "fixed_code": "<S2SV_ModStart> ) ) { if ( end - p >= ( sizeof ( ff_asf_guid ) * 3 + 26 ) ) { <S2SV_ModStart> ; } } } <S2SV_ModStart> = 46 ; if ( chunksize > end - p ) { av_log ( NULL , AV_LOG_ERROR , \"Corrupt<S2SV_blank>stream<S2SV_blank>(header<S2SV_blank>chunksize<S2SV_blank>%\" PRId64 \"<S2SV_blank>is<S2SV_blank>invalid)\\\\n\" , chunksize ) ; return AVERROR_INVALIDDATA ; }\n",
      "source_code_length": 3718,
      "target_code_length": 360,
      "vulnerability_patterns": {
        "integer_overflow": 7,
        "null_pointer": 22,
        "total": 29
      },
      "total_patterns": 29,
      "original_address": "https://github.com/FFmpeg/FFmpeg/commit/cced03dd667a5df6df8fd40d8de0bff477ee02e8",
      "discovery_time": "2018-07-23T15:29Z",
      "project_commit_id": "FFmpeg@FFmpeg/cced03dd667a5df6df8fd40d8de0bff477ee02e8",
      "extraction_time": "2025-08-31T15:41:49.183605",
      "label": 1,
      "vulnerability_type": "out-of-bounds_read",
      "difficulty_level": "advanced",
      "risk_factors": [
        "information_disclosure",
        "memory_corruption",
        "integer_overflow",
        "critical_infrastructure"
      ],
      "attack_vectors": [
        "memory_manipulation",
        "malicious_input",
        "code_analysis",
        "buffer_overflow",
        "reverse_engineering",
        "fuzzing"
      ],
      "mitigation_strategies": [
        "safe_string_functions",
        "dynamic_analysis",
        "code_review",
        "static_analysis",
        "memory_safety_checks",
        "input_validation",
        "fuzzing",
        "bounds_checking",
        "secure_coding_practices"
      ],
      "code_differences": {
        "has_differences": true,
        "source_lines": 2,
        "target_lines": 2,
        "character_differences": 3358,
        "similarity_percentage": 26.41509433962264
      },
      "vulnerability_location": {
        "vulnerability_present": true,
        "fix_applied": true,
        "code_changed": true,
        "estimated_lines_changed": 0
      }
    },
    {
      "cve_id": "CVE-2015-4036",
      "cwe_id": "CWE-119",
      "cwe_name": "Buffer Overflow",
      "project": "torvalds",
      "severity": "critical",
      "weaponization_score": 8.5,
      "is_critical": true,
      "is_weaponizable": true,
      "is_high_priority_project": false,
      "vulnerable_code": "CWE-119 static void vhost_scsi_send_evt ( struct vhost_scsi * vs , struct vhost_scsi_tpg * tpg , struct se_lun * lun , u32 event , u32 reason ) { struct vhost_scsi_evt * evt ; evt = vhost_scsi_allocate_evt ( vs , event , reason ) ; if ( ! evt ) return ; if ( tpg && lun ) { evt -> event . lun [ 0 ] = 0x01 ; <S2SV_StartBug> evt -> event . lun [ 1 ] = tpg -> tport_tpgt & 0xFF ; <S2SV_EndBug> if ( lun -> unpacked_lun >= 256 ) evt -> event . lun [ 2 ] = lun -> unpacked_lun >> 8 | 0x40 ; evt -> event . lun [ 3 ] = lun -> unpacked_lun & 0xFF ; } llist_add ( & evt -> list , & vs -> vs_event_list ) ; vhost_work_queue ( & vs -> dev , & vs -> vs_event_work ) ; }\n",
      "fixed_code": "<S2SV_ModStart> tpg -> tport_tpgt <S2SV_ModEnd> ; if (\n",
      "source_code_length": 660,
      "target_code_length": 55,
      "vulnerability_patterns": {
        "use_after_free": 1,
        "null_pointer": 10,
        "total": 11
      },
      "total_patterns": 11,
      "original_address": "https://github.com/torvalds/linux/commit/59c816c1f24df0204e01851431d3bab3eb76719c",
      "discovery_time": "2015-08-31T20:59Z",
      "project_commit_id": "torvalds@linux/59c816c1f24df0204e01851431d3bab3eb76719c",
      "extraction_time": "2025-08-31T15:41:49.183648",
      "label": 1,
      "vulnerability_type": "buffer_overflow",
      "difficulty_level": "advanced",
      "risk_factors": [
        "system_crash",
        "memory_corruption",
        "arbitrary_code_execution",
        "use_after_free"
      ],
      "attack_vectors": [
        "memory_manipulation",
        "malicious_input",
        "code_analysis",
        "buffer_overflow",
        "reverse_engineering",
        "fuzzing"
      ],
      "mitigation_strategies": [
        "safe_string_functions",
        "dynamic_analysis",
        "code_review",
        "static_analysis",
        "memory_safety_checks",
        "input_validation",
        "fuzzing",
        "bounds_checking",
        "secure_coding_practices"
      ],
      "code_differences": {
        "has_differences": true,
        "source_lines": 2,
        "target_lines": 2,
        "character_differences": 605,
        "similarity_percentage": 10.344827586206897
      },
      "vulnerability_location": {
        "vulnerability_present": true,
        "fix_applied": true,
        "code_changed": true,
        "estimated_lines_changed": 0
      }
    },
    {
      "cve_id": "CVE-2018-20748",
      "cwe_id": "CWE-787",
      "cwe_name": "Out-of-bounds Write",
      "project": "LibVNC",
      "severity": "critical",
      "weaponization_score": 8.5,
      "is_critical": true,
      "is_weaponizable": true,
      "is_high_priority_project": false,
      "vulnerable_code": "CWE-787 rfbBool HandleRFBServerMessage ( rfbClient * client ) { rfbServerToClientMsg msg ; if ( client -> serverPort == - 1 ) client -> vncRec -> readTimestamp = TRUE ; if ( ! ReadFromRFBServer ( client , ( char * ) & msg , 1 ) ) return FALSE ; switch ( msg . type ) { case rfbSetColourMapEntries : { break ; } case rfbFramebufferUpdate : { rfbFramebufferUpdateRectHeader rect ; int linesToRead ; int bytesPerLine ; int i ; if ( ! ReadFromRFBServer ( client , ( ( char * ) & msg . fu ) + 1 , sz_rfbFramebufferUpdateMsg - 1 ) ) return FALSE ; msg . fu . nRects = rfbClientSwap16IfLE ( msg . fu . nRects ) ; for ( i = 0 ; i < msg . fu . nRects ; i ++ ) { if ( ! ReadFromRFBServer ( client , ( char * ) & rect , sz_rfbFramebufferUpdateRectHeader ) ) return FALSE ; rect . encoding = rfbClientSwap32IfLE ( rect . encoding ) ; if ( rect . encoding == rfbEncodingLastRect ) break ; rect . r . x = rfbClientSwap16IfLE ( rect . r . x ) ; rect . r . y = rfbClientSwap16IfLE ( rect . r . y ) ; rect . r . w = rfbClientSwap16IfLE ( rect . r . w ) ; rect . r . h = rfbClientSwap16IfLE ( rect . r . h ) ; if ( rect . encoding == rfbEncodingXCursor || rect . encoding == rfbEncodingRichCursor ) { if ( ! HandleCursorShape ( client , rect . r . x , rect . r . y , rect . r . w , rect . r . h , rect . encoding ) ) { return FALSE ; } continue ; } if ( rect . encoding == rfbEncodingPointerPos ) { if ( ! client -> HandleCursorPos ( client , rect . r . x , rect . r . y ) ) { return FALSE ; } continue ; } if ( rect . encoding == rfbEncodingKeyboardLedState ) { client -> KeyboardLedStateEnabled = 1 ; if ( client -> HandleKeyboardLedState != NULL ) client -> HandleKeyboardLedState ( client , rect . r . x , 0 ) ; client -> CurrentKeyboardLedState = rect . r . x ; continue ; } if ( rect . encoding == rfbEncodingNewFBSize ) { client -> width = rect . r . w ; client -> height = rect . r . h ; client -> updateRect . x = client -> updateRect . y = 0 ; client -> updateRect . w = client -> width ; client -> updateRect . h = client -> height ; if ( ! client -> MallocFrameBuffer ( client ) ) return FALSE ; SendFramebufferUpdateRequest ( client , 0 , 0 , rect . r . w , rect . r . h , FALSE ) ; rfbClientLog ( \"Got<S2SV_blank>new<S2SV_blank>framebuffer<S2SV_blank>size:<S2SV_blank>%dx%d\\\\n\" , rect . r . w , rect . r . h ) ; continue ; } if ( rect . encoding == rfbEncodingSupportedMessages ) { int loop ; if ( ! ReadFromRFBServer ( client , ( char * ) & client -> supportedMessages , sz_rfbSupportedMessages ) ) return FALSE ; rfbClientLog ( \"client2server<S2SV_blank>supported<S2SV_blank>messages<S2SV_blank>(bit<S2SV_blank>flags)\\\\n\" ) ; for ( loop = 0 ; loop < 32 ; loop += 8 ) rfbClientLog ( \"%02X:<S2SV_blank>%04x<S2SV_blank>%04x<S2SV_blank>%04x<S2SV_blank>%04x<S2SV_blank>-<S2SV_blank>%04x<S2SV_blank>%04x<S2SV_blank>%04x<S2SV_blank>%04x\\\\n\" , loop , client -> supportedMessages . client2server [ loop ] , client -> supportedMessages . client2server [ loop + 1 ] , client -> supportedMessages . client2server [ loop + 2 ] , client -> supportedMessages . client2server [ loop + 3 ] , client -> supportedMessages . client2server [ loop + 4 ] , client -> supportedMessages . client2server [ loop + 5 ] , client -> supportedMessages . client2server [ loop + 6 ] , client -> supportedMessages . client2server [ loop + 7 ] ) ; rfbClientLog ( \"server2client<S2SV_blank>supported<S2SV_blank>messages<S2SV_blank>(bit<S2SV_blank>flags)\\\\n\" ) ; for ( loop = 0 ; loop < 32 ; loop += 8 ) rfbClientLog ( \"%02X:<S2SV_blank>%04x<S2SV_blank>%04x<S2SV_blank>%04x<S2SV_blank>%04x<S2SV_blank>-<S2SV_blank>%04x<S2SV_blank>%04x<S2SV_blank>%04x<S2SV_blank>%04x\\\\n\" , loop , client -> supportedMessages . server2client [ loop ] , client -> supportedMessages . server2client [ loop + 1 ] , client -> supportedMessages . server2client [ loop + 2 ] , client -> supportedMessages . server2client [ loop + 3 ] , client -> supportedMessages . server2client [ loop + 4 ] , client -> supportedMessages . server2client [ loop + 5 ] , client -> supportedMessages . server2client [ loop + 6 ] , client -> supportedMessages . server2client [ loop + 7 ] ) ; continue ; } if ( rect . encoding == rfbEncodingSupportedEncodings ) { char * buffer ; buffer = malloc ( rect . r . w ) ; if ( ! ReadFromRFBServer ( client , buffer , rect . r . w ) ) { free ( buffer ) ; return FALSE ; } free ( buffer ) ; continue ; } if ( rect . encoding == rfbEncodingServerIdentity ) { char * buffer ; buffer = malloc ( rect . r . w + 1 ) ; if ( ! ReadFromRFBServer ( client , buffer , rect . r . w ) ) { free ( buffer ) ; return FALSE ; } buffer [ rect . r . w ] = 0 ; rfbClientLog ( \"Connected<S2SV_blank>to<S2SV_blank>Server<S2SV_blank>\\\\\"%s\\\\\"\\\\n\" , buffer ) ; free ( buffer ) ; continue ; } if ( rect . encoding != rfbEncodingUltraZip ) { if ( ( rect . r . x + rect . r . w > client -> width ) || ( rect . r . y + rect . r . h > client -> height ) ) { rfbClientLog ( \"Rect<S2SV_blank>too<S2SV_blank>large:<S2SV_blank>%dx%d<S2SV_blank>at<S2SV_blank>(%d,<S2SV_blank>%d)\\\\n\" , rect . r . w , rect . r . h , rect . r . x , rect . r . y ) ; return FALSE ; } client -> SoftCursorLockArea ( client , rect . r . x , rect . r . y , rect . r . w , rect . r . h ) ; } switch ( rect . encoding ) { case rfbEncodingRaw : { int y = rect . r . y , h = rect . r . h ; bytesPerLine = rect . r . w * client -> format . bitsPerPixel / 8 ; linesToRead = bytesPerLine ? ( RFB_BUFFER_SIZE / bytesPerLine ) : 0 ; while ( linesToRead && h > 0 ) { if ( linesToRead > h ) linesToRead = h ; if ( ! ReadFromRFBServer ( client , client -> buffer , bytesPerLine * linesToRead ) ) return FALSE ; client -> GotBitmap ( client , ( uint8_t * ) client -> buffer , rect . r . x , y , rect . r . w , linesToRead ) ; h -= linesToRead ; y += linesToRead ; } break ; } case rfbEncodingCopyRect : { rfbCopyRect cr ; if ( ! ReadFromRFBServer ( client , ( char * ) & cr , sz_rfbCopyRect ) ) return FALSE ; cr . srcX = rfbClientSwap16IfLE ( cr . srcX ) ; cr . srcY = rfbClientSwap16IfLE ( cr . srcY ) ; client -> SoftCursorLockArea ( client , cr . srcX , cr . srcY , rect . r . w , rect . r . h ) ; client -> GotCopyRect ( client , cr . srcX , cr . srcY , rect . r . w , rect . r . h , rect . r . x , rect . r . y ) ; break ; } case rfbEncodingRRE : { switch ( client -> format . bitsPerPixel ) { case 8 : if ( ! HandleRRE8 ( client , rect . r . x , rect . r . y , rect . r . w , rect . r . h ) ) return FALSE ; break ; case 16 : if ( ! HandleRRE16 ( client , rect . r . x , rect . r . y , rect . r . w , rect . r . h ) ) return FALSE ; break ; case 32 : if ( ! HandleRRE32 ( client , rect . r . x , rect . r . y , rect . r . w , rect . r . h ) ) return FALSE ; break ; } break ; } case rfbEncodingCoRRE : { switch ( client -> format . bitsPerPixel ) { case 8 : if ( ! HandleCoRRE8 ( client , rect . r . x , rect . r . y , rect . r . w , rect . r . h ) ) return FALSE ; break ; case 16 : if ( ! HandleCoRRE16 ( client , rect . r . x , rect . r . y , rect . r . w , rect . r . h ) ) return FALSE ; break ; case 32 : if ( ! HandleCoRRE32 ( client , rect . r . x , rect . r . y , rect . r . w , rect . r . h ) ) return FALSE ; break ; } break ; } case rfbEncodingHextile : { switch ( client -> format . bitsPerPixel ) { case 8 : if ( ! HandleHextile8 ( client , rect . r . x , rect . r . y , rect . r . w , rect . r . h ) ) return FALSE ; break ; case 16 : if ( ! HandleHextile16 ( client , rect . r . x , rect . r . y , rect . r . w , rect . r . h ) ) return FALSE ; break ; case 32 : if ( ! HandleHextile32 ( client , rect . r . x , rect . r . y , rect . r . w , rect . r . h ) ) return FALSE ; break ; } break ; } case rfbEncodingUltra : { switch ( client -> format . bitsPerPixel ) { case 8 : if ( ! HandleUltra8 ( client , rect . r . x , rect . r . y , rect . r . w , rect . r . h ) ) return FALSE ; break ; case 16 : if ( ! HandleUltra16 ( client , rect . r . x , rect . r . y , rect . r . w , rect . r . h ) ) return FALSE ; break ; case 32 : if ( ! HandleUltra32 ( client , rect . r . x , rect . r . y , rect . r . w , rect . r . h ) ) return FALSE ; break ; } break ; } case rfbEncodingUltraZip : { switch ( client -> format . bitsPerPixel ) { case 8 : if ( ! HandleUltraZip8 ( client , rect . r . x , rect . r . y , rect . r . w , rect . r . h ) ) return FALSE ; break ; case 16 : if ( ! HandleUltraZip16 ( client , rect . r . x , rect . r . y , rect . r . w , rect . r . h ) ) return FALSE ; break ; case 32 : if ( ! HandleUltraZip32 ( client , rect . r . x , rect . r . y , rect . r . w , rect . r . h ) ) return FALSE ; break ; } break ; } case rfbEncodingTRLE : { switch ( client -> format . bitsPerPixel ) { case 8 : if ( ! HandleTRLE8 ( client , rect . r . x , rect . r . y , rect . r . w , rect . r . h ) ) return FALSE ; break ; case 16 : if ( client -> si . format . greenMax > 0x1F ) { if ( ! HandleTRLE16 ( client , rect . r . x , rect . r . y , rect . r . w , rect . r . h ) ) return FALSE ; } else { if ( ! HandleTRLE15 ( client , rect . r . x , rect . r . y , rect . r . w , rect . r . h ) ) return FALSE ; } break ; case 32 : { uint32_t maxColor = ( client -> format . redMax << client -> format . redShift ) | ( client -> format . greenMax << client -> format . greenShift ) | ( client -> format . blueMax << client -> format . blueShift ) ; if ( ( client -> format . bigEndian && ( maxColor & 0xff ) == 0 ) || ( ! client -> format . bigEndian && ( maxColor & 0xff000000 ) == 0 ) ) { if ( ! HandleTRLE24 ( client , rect . r . x , rect . r . y , rect . r . w , rect . r . h ) ) return FALSE ; } else if ( ! client -> format . bigEndian && ( maxColor & 0xff ) == 0 ) { if ( ! HandleTRLE24Up ( client , rect . r . x , rect . r . y , rect . r . w , rect . r . h ) ) return FALSE ; } else if ( client -> format . bigEndian && ( maxColor & 0xff000000 ) == 0 ) { if ( ! HandleTRLE24Down ( client , rect . r . x , rect . r . y , rect . r . w , rect . r . h ) ) return FALSE ; } else if ( ! HandleTRLE32 ( client , rect . r . x , rect . r . y , rect . r . w , rect . r . h ) ) return FALSE ; break ; } } break ; } # ifdef LIBVNCSERVER_HAVE_LIBZ case rfbEncodingZlib : { switch ( client -> format . bitsPerPixel ) { case 8 : if ( ! HandleZlib8 ( client , rect . r . x , rect . r . y , rect . r . w , rect . r . h ) ) return FALSE ; break ; case 16 : if ( ! HandleZlib16 ( client , rect . r . x , rect . r . y , rect . r . w , rect . r . h ) ) return FALSE ; break ; case 32 : if ( ! HandleZlib32 ( client , rect . r . x , rect . r . y , rect . r . w , rect . r . h ) ) return FALSE ; break ; } break ; } # ifdef LIBVNCSERVER_HAVE_LIBJPEG case rfbEncodingTight : { switch ( client -> format . bitsPerPixel ) { case 8 : if ( ! HandleTight8 ( client , rect . r . x , rect . r . y , rect . r . w , rect . r . h ) ) return FALSE ; break ; case 16 : if ( ! HandleTight16 ( client , rect . r . x , rect . r . y , rect . r . w , rect . r . h ) ) return FALSE ; break ; case 32 : if ( ! HandleTight32 ( client , rect . r . x , rect . r . y , rect . r . w , rect . r . h ) ) return FALSE ; break ; } break ; } # endif case rfbEncodingZRLE : client -> appData . qualityLevel = 9 ; case rfbEncodingZYWRLE : { switch ( client -> format . bitsPerPixel ) { case 8 : if ( ! HandleZRLE8 ( client , rect . r . x , rect . r . y , rect . r . w , rect . r . h ) ) return FALSE ; break ; case 16 : if ( client -> si . format . greenMax > 0x1F ) { if ( ! HandleZRLE16 ( client , rect . r . x , rect . r . y , rect . r . w , rect . r . h ) ) return FALSE ; } else { if ( ! HandleZRLE15 ( client , rect . r . x , rect . r . y , rect . r . w , rect . r . h ) ) return FALSE ; } break ; case 32 : { uint32_t maxColor = ( client -> format . redMax << client -> format . redShift ) | ( client -> format . greenMax << client -> format . greenShift ) | ( client -> format . blueMax << client -> format . blueShift ) ; if ( ( client -> format . bigEndian && ( maxColor & 0xff ) == 0 ) || ( ! client -> format . bigEndian && ( maxColor & 0xff000000 ) == 0 ) ) { if ( ! HandleZRLE24 ( client , rect . r . x , rect . r . y , rect . r . w , rect . r . h ) ) return FALSE ; } else if ( ! client -> format . bigEndian && ( maxColor & 0xff ) == 0 ) { if ( ! HandleZRLE24Up ( client , rect . r . x , rect . r . y , rect . r . w , rect . r . h ) ) return FALSE ; } else if ( client -> format . bigEndian && ( maxColor & 0xff000000 ) == 0 ) { if ( ! HandleZRLE24Down ( client , rect . r . x , rect . r . y , rect . r . w , rect . r . h ) ) return FALSE ; } else if ( ! HandleZRLE32 ( client , rect . r . x , rect . r . y , rect . r . w , rect . r . h ) ) return FALSE ; break ; } } break ; } # endif default : { rfbBool handled = FALSE ; rfbClientProtocolExtension * e ; for ( e = rfbClientExtensions ; ! handled && e ; e = e -> next ) if ( e -> handleEncoding && e -> handleEncoding ( client , & rect ) ) handled = TRUE ; if ( ! handled ) { rfbClientLog ( \"Unknown<S2SV_blank>rect<S2SV_blank>encoding<S2SV_blank>%d\\\\n\" , ( int ) rect . encoding ) ; return FALSE ; } } } client -> SoftCursorUnlockScreen ( client ) ; client -> GotFrameBufferUpdate ( client , rect . r . x , rect . r . y , rect . r . w , rect . r . h ) ; } if ( ! SendIncrementalFramebufferUpdateRequest ( client ) ) return FALSE ; if ( client -> FinishedFrameBufferUpdate ) client -> FinishedFrameBufferUpdate ( client ) ; break ; } case rfbBell : { client -> Bell ( client ) ; break ; } case rfbServerCutText : { char * buffer ; if ( ! ReadFromRFBServer ( client , ( ( char * ) & msg ) + 1 , sz_rfbServerCutTextMsg - 1 ) ) return FALSE ; msg . sct . length = rfbClientSwap32IfLE ( msg . sct . length ) ; if ( msg . sct . length > 1 << 20 ) { rfbClientErr ( \"Ignoring<S2SV_blank>too<S2SV_blank>big<S2SV_blank>cut<S2SV_blank>text<S2SV_blank>length<S2SV_blank>sent<S2SV_blank>by<S2SV_blank>server:<S2SV_blank>%u<S2SV_blank>B<S2SV_blank>><S2SV_blank>1<S2SV_blank>MB\\\\n\" , ( unsigned int ) msg . sct . length ) ; return FALSE ; } <S2SV_StartBug> buffer = malloc ( ( uint64_t ) msg . sct . length + 1 ) ; <S2SV_EndBug> if ( ! ReadFromRFBServer ( client , buffer , msg . sct . length ) ) { free ( buffer ) ; return FALSE ; } buffer [ msg . sct . length ] = 0 ; if ( client -> GotXCutText ) client -> GotXCutText ( client , buffer , msg . sct . length ) ; free ( buffer ) ; break ; } case rfbTextChat : { char * buffer = NULL ; if ( ! ReadFromRFBServer ( client , ( ( char * ) & msg ) + 1 , sz_rfbTextChatMsg - 1 ) ) return FALSE ; msg . tc . length = rfbClientSwap32IfLE ( msg . sct . length ) ; switch ( msg . tc . length ) { case rfbTextChatOpen : rfbClientLog ( \"Received<S2SV_blank>TextChat<S2SV_blank>Open\\\\n\" ) ; if ( client -> HandleTextChat != NULL ) client -> HandleTextChat ( client , ( int ) rfbTextChatOpen , NULL ) ; break ; case rfbTextChatClose : rfbClientLog ( \"Received<S2SV_blank>TextChat<S2SV_blank>Close\\\\n\" ) ; if ( client -> HandleTextChat != NULL ) client -> HandleTextChat ( client , ( int ) rfbTextChatClose , NULL ) ; break ; case rfbTextChatFinished : rfbClientLog ( \"Received<S2SV_blank>TextChat<S2SV_blank>Finished\\\\n\" ) ; if ( client -> HandleTextChat != NULL ) client -> HandleTextChat ( client , ( int ) rfbTextChatFinished , NULL ) ; break ; default : buffer = malloc ( msg . tc . length + 1 ) ; if ( ! ReadFromRFBServer ( client , buffer , msg . tc . length ) ) { free ( buffer ) ; return FALSE ; } buffer [ msg . tc . length ] = 0 ; rfbClientLog ( \"Received<S2SV_blank>TextChat<S2SV_blank>\\\\\"%s\\\\\"\\\\n\" , buffer ) ; if ( client -> HandleTextChat != NULL ) client -> HandleTextChat ( client , ( int ) msg . tc . length , buffer ) ; free ( buffer ) ; break ; } break ; } case rfbXvp : { if ( ! ReadFromRFBServer ( client , ( ( char * ) & msg ) + 1 , sz_rfbXvpMsg - 1 ) ) return FALSE ; SetClient2Server ( client , rfbXvp ) ; SetServer2Client ( client , rfbXvp ) ; if ( client -> HandleXvpMsg ) client -> HandleXvpMsg ( client , msg . xvp . version , msg . xvp . code ) ; break ; } case rfbResizeFrameBuffer : { if ( ! ReadFromRFBServer ( client , ( ( char * ) & msg ) + 1 , sz_rfbResizeFrameBufferMsg - 1 ) ) return FALSE ; client -> width = rfbClientSwap16IfLE ( msg . rsfb . framebufferWidth ) ; client -> height = rfbClientSwap16IfLE ( msg . rsfb . framebufferHeigth ) ; client -> updateRect . x = client -> updateRect . y = 0 ; client -> updateRect . w = client -> width ; client -> updateRect . h = client -> height ; if ( ! client -> MallocFrameBuffer ( client ) ) return FALSE ; SendFramebufferUpdateRequest ( client , 0 , 0 , client -> width , client -> height , FALSE ) ; rfbClientLog ( \"Got<S2SV_blank>new<S2SV_blank>framebuffer<S2SV_blank>size:<S2SV_blank>%dx%d\\\\n\" , client -> width , client -> height ) ; break ; } case rfbPalmVNCReSizeFrameBuffer : { if ( ! ReadFromRFBServer ( client , ( ( char * ) & msg ) + 1 , sz_rfbPalmVNCReSizeFrameBufferMsg - 1 ) ) return FALSE ; client -> width = rfbClientSwap16IfLE ( msg . prsfb . buffer_w ) ; client -> height = rfbClientSwap16IfLE ( msg . prsfb . buffer_h ) ; client -> updateRect . x = client -> updateRect . y = 0 ; client -> updateRect . w = client -> width ; client -> updateRect . h = client -> height ; if ( ! client -> MallocFrameBuffer ( client ) ) return FALSE ; SendFramebufferUpdateRequest ( client , 0 , 0 , client -> width , client -> height , FALSE ) ; rfbClientLog ( \"Got<S2SV_blank>new<S2SV_blank>framebuffer<S2SV_blank>size:<S2SV_blank>%dx%d\\\\n\" , client -> width , client -> height ) ; break ; } default : { rfbBool handled = FALSE ; rfbClientProtocolExtension * e ; for ( e = rfbClientExtensions ; ! handled && e ; e = e -> next ) if ( e -> handleMessage && e -> handleMessage ( client , & msg ) ) handled = TRUE ; if ( ! handled ) { char buffer [ 256 ] ; rfbClientLog ( \"Unknown<S2SV_blank>message<S2SV_blank>type<S2SV_blank>%d<S2SV_blank>from<S2SV_blank>VNC<S2SV_blank>server\\\\n\" , msg . type ) ; ReadFromRFBServer ( client , buffer , 256 ) ; return FALSE ; } } } return TRUE ; }\n",
      "fixed_code": "<S2SV_ModStart> = malloc ( <S2SV_ModEnd> msg . sct\n",
      "source_code_length": 17817,
      "target_code_length": 51,
      "vulnerability_patterns": {
        "use_after_free": 15,
        "integer_overflow": 5,
        "null_pointer": 128,
        "memory_leak": 4,
        "total": 152
      },
      "total_patterns": 152,
      "original_address": "https://github.com/LibVNC/libvncserver/commit/a64c3b37af9a6c8f8009d7516874b8d266b42bae",
      "discovery_time": "2019-01-30T18:29Z",
      "project_commit_id": "LibVNC@libvncserver/a64c3b37af9a6c8f8009d7516874b8d266b42bae",
      "extraction_time": "2025-08-31T15:41:49.183671",
      "label": 1,
      "vulnerability_type": "out-of-bounds_write",
      "difficulty_level": "advanced",
      "risk_factors": [
        "system_crash",
        "memory_corruption",
        "arbitrary_code_execution",
        "use_after_free"
      ],
      "attack_vectors": [
        "memory_manipulation",
        "malicious_input",
        "code_analysis",
        "buffer_overflow",
        "reverse_engineering",
        "fuzzing"
      ],
      "mitigation_strategies": [
        "safe_string_functions",
        "dynamic_analysis",
        "code_review",
        "static_analysis",
        "memory_safety_checks",
        "input_validation",
        "fuzzing",
        "bounds_checking",
        "secure_coding_practices"
      ],
      "code_differences": {
        "has_differences": true,
        "source_lines": 2,
        "target_lines": 2,
        "character_differences": 17766,
        "similarity_percentage": 2.307692307692308
      },
      "vulnerability_location": {
        "vulnerability_present": true,
        "fix_applied": true,
        "code_changed": true,
        "estimated_lines_changed": 0
      }
    },
    {
      "cve_id": "CVE-2016-3134",
      "cwe_id": "CWE-119",
      "cwe_name": "Buffer Overflow",
      "project": "torvalds",
      "severity": "critical",
      "weaponization_score": 8.5,
      "is_critical": true,
      "is_weaponizable": true,
      "is_high_priority_project": false,
      "vulnerable_code": "CWE-119 static bool check_underflow ( const struct ip6t_entry * e ) { const struct xt_entry_target * t ; unsigned int verdict ; <S2SV_StartBug> if ( ! unconditional ( & e -> ipv6 ) ) <S2SV_EndBug> return false ; t = ip6t_get_target_c ( e ) ; if ( strcmp ( t -> u . user . name , XT_STANDARD_TARGET ) != 0 ) return false ; verdict = ( ( struct xt_standard_target * ) t ) -> verdict ; verdict = - verdict - 1 ; return verdict == NF_DROP || verdict == NF_ACCEPT ; }\n",
      "fixed_code": "<S2SV_ModStart> ! unconditional ( e <S2SV_ModEnd> ) ) return\n",
      "source_code_length": 463,
      "target_code_length": 61,
      "vulnerability_patterns": {
        "use_after_free": 11,
        "integer_overflow": 2,
        "null_pointer": 25,
        "total": 38
      },
      "total_patterns": 38,
      "original_address": "https://github.com/torvalds/linux/commit/54d83fc74aa9ec72794373cb47432c5f7fb1a309",
      "discovery_time": "2016-04-27T17:59Z",
      "project_commit_id": "torvalds@linux/54d83fc74aa9ec72794373cb47432c5f7fb1a309",
      "extraction_time": "2025-08-31T15:41:49.183783",
      "label": 1,
      "vulnerability_type": "buffer_overflow",
      "difficulty_level": "advanced",
      "risk_factors": [
        "system_crash",
        "memory_corruption",
        "arbitrary_code_execution",
        "use_after_free"
      ],
      "attack_vectors": [
        "memory_manipulation",
        "malicious_input",
        "code_analysis",
        "buffer_overflow",
        "reverse_engineering",
        "fuzzing"
      ],
      "mitigation_strategies": [
        "safe_string_functions",
        "dynamic_analysis",
        "code_review",
        "static_analysis",
        "memory_safety_checks",
        "input_validation",
        "fuzzing",
        "bounds_checking",
        "secure_coding_practices"
      ],
      "code_differences": {
        "has_differences": true,
        "source_lines": 2,
        "target_lines": 2,
        "character_differences": 402,
        "similarity_percentage": 12.244897959183673
      },
      "vulnerability_location": {
        "vulnerability_present": true,
        "fix_applied": true,
        "code_changed": true,
        "estimated_lines_changed": 0
      }
    },
    {
      "cve_id": "CVE-2016-5829",
      "cwe_id": "CWE-119",
      "cwe_name": "Buffer Overflow",
      "project": "torvalds",
      "severity": "critical",
      "weaponization_score": 8.5,
      "is_critical": true,
      "is_weaponizable": true,
      "is_high_priority_project": false,
      "vulnerable_code": "CWE-119 static noinline int hiddev_ioctl_usage ( struct hiddev * hiddev , unsigned int cmd , void __user * user_arg ) { struct hid_device * hid = hiddev -> hid ; struct hiddev_report_info rinfo ; struct hiddev_usage_ref_multi * uref_multi = NULL ; struct hiddev_usage_ref * uref ; struct hid_report * report ; struct hid_field * field ; int i ; uref_multi = kmalloc ( sizeof ( struct hiddev_usage_ref_multi ) , GFP_KERNEL ) ; if ( ! uref_multi ) return - ENOMEM ; uref = & uref_multi -> uref ; if ( cmd == HIDIOCGUSAGES || cmd == HIDIOCSUSAGES ) { if ( copy_from_user ( uref_multi , user_arg , sizeof ( * uref_multi ) ) ) goto fault ; } else { if ( copy_from_user ( uref , user_arg , sizeof ( * uref ) ) ) goto fault ; } switch ( cmd ) { case HIDIOCGUCODE : rinfo . report_type = uref -> report_type ; rinfo . report_id = uref -> report_id ; if ( ( report = hiddev_lookup_report ( hid , & rinfo ) ) == NULL ) goto inval ; if ( uref -> field_index >= report -> maxfield ) goto inval ; field = report -> field [ uref -> field_index ] ; if ( uref -> usage_index >= field -> maxusage ) goto inval ; uref -> usage_code = field -> usage [ uref -> usage_index ] . hid ; if ( copy_to_user ( user_arg , uref , sizeof ( * uref ) ) ) goto fault ; goto goodreturn ; default : if ( cmd != HIDIOCGUSAGE && cmd != HIDIOCGUSAGES && uref -> report_type == HID_REPORT_TYPE_INPUT ) goto inval ; if ( uref -> report_id == HID_REPORT_ID_UNKNOWN ) { field = hiddev_lookup_usage ( hid , uref ) ; if ( field == NULL ) goto inval ; } else { rinfo . report_type = uref -> report_type ; rinfo . report_id = uref -> report_id ; if ( ( report = hiddev_lookup_report ( hid , & rinfo ) ) == NULL ) goto inval ; if ( uref -> field_index >= report -> maxfield ) goto inval ; field = report -> field [ uref -> field_index ] ; if ( cmd == HIDIOCGCOLLECTIONINDEX ) { if ( uref -> usage_index >= field -> maxusage ) goto inval ; } else if ( uref -> usage_index >= field -> report_count ) goto inval ; <S2SV_StartBug> else if ( ( cmd == HIDIOCGUSAGES || cmd == HIDIOCSUSAGES ) && <S2SV_EndBug> ( uref_multi -> num_values > HID_MAX_MULTI_USAGES || uref -> usage_index + uref_multi -> num_values > field -> report_count ) ) goto inval ; <S2SV_StartBug> } <S2SV_EndBug> switch ( cmd ) { case HIDIOCGUSAGE : uref -> value = field -> value [ uref -> usage_index ] ; if ( copy_to_user ( user_arg , uref , sizeof ( * uref ) ) ) goto fault ; goto goodreturn ; case HIDIOCSUSAGE : field -> value [ uref -> usage_index ] = uref -> value ; goto goodreturn ; case HIDIOCGCOLLECTIONINDEX : i = field -> usage [ uref -> usage_index ] . collection_index ; kfree ( uref_multi ) ; return i ; case HIDIOCGUSAGES : for ( i = 0 ; i < uref_multi -> num_values ; i ++ ) uref_multi -> values [ i ] = field -> value [ uref -> usage_index + i ] ; if ( copy_to_user ( user_arg , uref_multi , sizeof ( * uref_multi ) ) ) goto fault ; goto goodreturn ; case HIDIOCSUSAGES : for ( i = 0 ; i < uref_multi -> num_values ; i ++ ) field -> value [ uref -> usage_index + i ] = uref_multi -> values [ i ] ; goto goodreturn ; } goodreturn : kfree ( uref_multi ) ; return 0 ; fault : kfree ( uref_multi ) ; return - EFAULT ; inval : kfree ( uref_multi ) ; return - EINVAL ; } }\n",
      "fixed_code": "<S2SV_ModStart> goto inval ; } <S2SV_ModEnd> if ( ( <S2SV_ModStart> goto inval ; <S2SV_ModEnd> switch ( cmd\n",
      "source_code_length": 3203,
      "target_code_length": 108,
      "vulnerability_patterns": {
        "use_after_free": 4,
        "integer_overflow": 2,
        "null_pointer": 48,
        "memory_leak": 1,
        "total": 55
      },
      "total_patterns": 55,
      "original_address": "https://github.com/torvalds/linux/commit/93a2001bdfd5376c3dc2158653034c20392d15c5",
      "discovery_time": "2016-06-27T10:59Z",
      "project_commit_id": "torvalds@linux/93a2001bdfd5376c3dc2158653034c20392d15c5",
      "extraction_time": "2025-08-31T15:41:49.183808",
      "label": 1,
      "vulnerability_type": "buffer_overflow",
      "difficulty_level": "advanced",
      "risk_factors": [
        "system_crash",
        "memory_corruption",
        "arbitrary_code_execution",
        "use_after_free"
      ],
      "attack_vectors": [
        "memory_manipulation",
        "malicious_input",
        "code_analysis",
        "buffer_overflow",
        "reverse_engineering",
        "fuzzing"
      ],
      "mitigation_strategies": [
        "safe_string_functions",
        "dynamic_analysis",
        "code_review",
        "static_analysis",
        "memory_safety_checks",
        "input_validation",
        "fuzzing",
        "bounds_checking",
        "secure_coding_practices"
      ],
      "code_differences": {
        "has_differences": true,
        "source_lines": 2,
        "target_lines": 2,
        "character_differences": 3095,
        "similarity_percentage": 8.0
      },
      "vulnerability_location": {
        "vulnerability_present": true,
        "fix_applied": true,
        "code_changed": true,
        "estimated_lines_changed": 0
      }
    },
    {
      "cve_id": "CVE-2019-19275",
      "cwe_id": "CWE-125",
      "cwe_name": "Out-of-bounds Read",
      "project": "python",
      "severity": "critical",
      "weaponization_score": 8.5,
      "is_critical": true,
      "is_weaponizable": true,
      "is_high_priority_project": true,
      "vulnerable_code": "CWE-125 static arguments_ty ast_for_arguments ( struct compiling * c , const node * n ) { int i , j , k , nposargs = 0 , nkwonlyargs = 0 ; int nposdefaults = 0 , found_default = 0 ; asdl_seq * posargs , * posdefaults , * kwonlyargs , * kwdefaults ; arg_ty vararg = NULL , kwarg = NULL ; arg_ty arg ; node * ch ; if ( TYPE ( n ) == parameters ) { if ( NCH ( n ) == 2 ) return arguments ( NULL , NULL , NULL , NULL , NULL , NULL , c -> c_arena ) ; n = CHILD ( n , 1 ) ; } assert ( TYPE ( n ) == typedargslist || TYPE ( n ) == varargslist ) ; for ( i = 0 ; i < NCH ( n ) ; i ++ ) { ch = CHILD ( n , i ) ; if ( TYPE ( ch ) == STAR ) { i ++ ; if ( i < NCH ( n ) && ( TYPE ( CHILD ( n , i ) ) == tfpdef || TYPE ( CHILD ( n , i ) ) == vfpdef ) ) { i ++ ; } break ; } if ( TYPE ( ch ) == DOUBLESTAR ) break ; if ( TYPE ( ch ) == vfpdef || TYPE ( ch ) == tfpdef ) nposargs ++ ; if ( TYPE ( ch ) == EQUAL ) nposdefaults ++ ; } for ( ; i < NCH ( n ) ; ++ i ) { ch = CHILD ( n , i ) ; if ( TYPE ( ch ) == DOUBLESTAR ) break ; if ( TYPE ( ch ) == tfpdef || TYPE ( ch ) == vfpdef ) nkwonlyargs ++ ; } posargs = ( nposargs ? _Ta3_asdl_seq_new ( nposargs , c -> c_arena ) : NULL ) ; if ( ! posargs && nposargs ) return NULL ; kwonlyargs = ( nkwonlyargs ? _Ta3_asdl_seq_new ( nkwonlyargs , c -> c_arena ) : NULL ) ; if ( ! kwonlyargs && nkwonlyargs ) return NULL ; posdefaults = ( nposdefaults ? _Ta3_asdl_seq_new ( nposdefaults , c -> c_arena ) : NULL ) ; if ( ! posdefaults && nposdefaults ) return NULL ; kwdefaults = ( nkwonlyargs ? _Ta3_asdl_seq_new ( nkwonlyargs , c -> c_arena ) : NULL ) ; if ( ! kwdefaults && nkwonlyargs ) return NULL ; <S2SV_StartBug> if ( nposargs + nkwonlyargs > 255 ) { <S2SV_EndBug> ast_error ( c , n , \"more<S2SV_blank>than<S2SV_blank>255<S2SV_blank>arguments\" ) ; return NULL ; } i = 0 ; j = 0 ; k = 0 ; while ( i < NCH ( n ) ) { ch = CHILD ( n , i ) ; switch ( TYPE ( ch ) ) { case tfpdef : case vfpdef : if ( i + 1 < NCH ( n ) && TYPE ( CHILD ( n , i + 1 ) ) == EQUAL ) { expr_ty expression = ast_for_expr ( c , CHILD ( n , i + 2 ) ) ; if ( ! expression ) return NULL ; assert ( posdefaults != NULL ) ; asdl_seq_SET ( posdefaults , j ++ , expression ) ; i += 2 ; found_default = 1 ; } else if ( found_default ) { ast_error ( c , n , \"non-default<S2SV_blank>argument<S2SV_blank>follows<S2SV_blank>default<S2SV_blank>argument\" ) ; return NULL ; } arg = ast_for_arg ( c , ch ) ; if ( ! arg ) return NULL ; asdl_seq_SET ( posargs , k ++ , arg ) ; i += 1 ; <S2SV_StartBug> if ( i < NCH ( n ) && TYPE ( CHILD ( n , i ) ) == COMMA ) <S2SV_EndBug> i += 1 ; break ; case STAR : if ( i + 1 >= NCH ( n ) || ( i + 2 == NCH ( n ) && ( TYPE ( CHILD ( n , i + 1 ) ) == COMMA || TYPE ( CHILD ( n , i + 1 ) ) == TYPE_COMMENT ) ) ) { ast_error ( c , CHILD ( n , i ) , \"named<S2SV_blank>arguments<S2SV_blank>must<S2SV_blank>follow<S2SV_blank>bare<S2SV_blank>*\" ) ; return NULL ; } ch = CHILD ( n , i + 1 ) ; if ( TYPE ( ch ) == COMMA ) { int res = 0 ; i += 2 ; <S2SV_StartBug> if ( i < NCH ( n ) && TYPE ( CHILD ( n , i ) ) == TYPE_COMMENT ) { <S2SV_EndBug> ast_error ( c , CHILD ( n , i ) , \"bare<S2SV_blank>*<S2SV_blank>has<S2SV_blank>associated<S2SV_blank>type<S2SV_blank>comment\" ) ; return NULL ; } res = handle_keywordonly_args ( c , n , i , kwonlyargs , kwdefaults ) ; if ( res == - 1 ) return NULL ; i = res ; } else { vararg = ast_for_arg ( c , ch ) ; if ( ! vararg ) return NULL ; i += 2 ; <S2SV_StartBug> if ( i < NCH ( n ) && TYPE ( CHILD ( n , i ) ) == COMMA ) <S2SV_EndBug> i += 1 ; <S2SV_StartBug> if ( i < NCH ( n ) && TYPE ( CHILD ( n , i ) ) == TYPE_COMMENT ) { <S2SV_EndBug> vararg -> type_comment = NEW_TYPE_COMMENT ( CHILD ( n , i ) ) ; i += 1 ; } if ( i < NCH ( n ) && ( TYPE ( CHILD ( n , i ) ) == tfpdef || TYPE ( CHILD ( n , i ) ) == vfpdef ) ) { int res = 0 ; res = handle_keywordonly_args ( c , n , i , kwonlyargs , kwdefaults ) ; if ( res == - 1 ) return NULL ; i = res ; } } break ; case DOUBLESTAR : ch = CHILD ( n , i + 1 ) ; assert ( TYPE ( ch ) == tfpdef || TYPE ( ch ) == vfpdef ) ; kwarg = ast_for_arg ( c , ch ) ; if ( ! kwarg ) return NULL ; i += 2 ; <S2SV_StartBug> if ( i < NCH ( n ) && TYPE ( CHILD ( n , i ) ) == COMMA ) <S2SV_EndBug> i += 1 ; break ; case TYPE_COMMENT : assert ( i ) ; if ( kwarg ) arg = kwarg ; arg -> type_comment = NEW_TYPE_COMMENT ( ch ) ; i += 1 ; break ; default : PyErr_Format ( PyExc_SystemError , \"unexpected<S2SV_blank>node<S2SV_blank>in<S2SV_blank>varargslist:<S2SV_blank>%d<S2SV_blank>@<S2SV_blank>%d\" , TYPE ( ch ) , i ) ; return NULL ; } } return arguments ( posargs , vararg , kwonlyargs , kwdefaults , kwarg , posdefaults , c -> c_arena ) ; }\n",
      "fixed_code": "<S2SV_ModStart> return NULL ; <S2SV_ModEnd> i = 0 <S2SV_ModStart> ; if ( <S2SV_ModEnd> TYPE ( CHILD <S2SV_ModStart> ; if ( <S2SV_ModEnd> TYPE ( CHILD <S2SV_ModStart> ; if ( <S2SV_ModEnd> TYPE ( CHILD <S2SV_ModStart> ; if ( <S2SV_ModEnd> TYPE ( CHILD <S2SV_ModStart> ; if ( <S2SV_ModEnd> TYPE ( CHILD\n",
      "source_code_length": 4617,
      "target_code_length": 300,
      "vulnerability_patterns": {
        "null_pointer": 10,
        "total": 10
      },
      "total_patterns": 10,
      "original_address": "https://github.com/python/typed_ast/commit/156afcb26c198e162504a57caddfe0acd9ed7dce",
      "discovery_time": "2019-11-26T15:15Z",
      "project_commit_id": "python@typed_ast/156afcb26c198e162504a57caddfe0acd9ed7dce",
      "extraction_time": "2025-08-31T15:41:49.183841",
      "label": 1,
      "vulnerability_type": "out-of-bounds_read",
      "difficulty_level": "advanced",
      "risk_factors": [
        "information_disclosure",
        "memory_corruption",
        "integer_overflow",
        "critical_infrastructure"
      ],
      "attack_vectors": [
        "memory_manipulation",
        "malicious_input",
        "code_analysis",
        "buffer_overflow",
        "reverse_engineering",
        "fuzzing"
      ],
      "mitigation_strategies": [
        "safe_string_functions",
        "dynamic_analysis",
        "code_review",
        "static_analysis",
        "memory_safety_checks",
        "input_validation",
        "fuzzing",
        "bounds_checking",
        "secure_coding_practices"
      ],
      "code_differences": {
        "has_differences": true,
        "source_lines": 2,
        "target_lines": 2,
        "character_differences": 4317,
        "similarity_percentage": 9.70873786407767
      },
      "vulnerability_location": {
        "vulnerability_present": true,
        "fix_applied": true,
        "code_changed": true,
        "estimated_lines_changed": 0
      }
    },
    {
      "cve_id": "CVE-2020-15173",
      "cwe_id": "CWE-119",
      "cwe_name": "Buffer Overflow",
      "project": "accel-ppp",
      "severity": "critical",
      "weaponization_score": 8.5,
      "is_critical": true,
      "is_weaponizable": true,
      "is_high_priority_project": false,
      "vulnerable_code": "CWE-119 int l2tp_packet_send ( int sock , struct l2tp_packet_t * pack ) { <S2SV_StartBug> uint8_t * buf = mempool_alloc ( buf_pool ) ; <S2SV_EndBug> struct l2tp_avp_t * avp ; struct l2tp_attr_t * attr ; <S2SV_StartBug> uint8_t * ptr ; <S2SV_EndBug> <S2SV_StartBug> int n ; <S2SV_EndBug> int len = sizeof ( pack -> hdr ) ; if ( ! buf ) { log_emerg ( \"l2tp:<S2SV_blank>out<S2SV_blank>of<S2SV_blank>memory\\\\n\" ) ; return - 1 ; } memset ( buf , 0 , L2TP_MAX_PACKET_SIZE ) ; <S2SV_StartBug> ptr = buf + sizeof ( pack -> hdr ) ; <S2SV_EndBug> list_for_each_entry ( attr , & pack -> attrs , entry ) { if ( len + sizeof ( * avp ) + attr -> length >= L2TP_MAX_PACKET_SIZE ) { log_error ( \"l2tp:<S2SV_blank>cann\\'t<S2SV_blank>send<S2SV_blank>packet<S2SV_blank>(exceeds<S2SV_blank>maximum<S2SV_blank>size)\\\\n\" ) ; mempool_free ( buf ) ; return - 1 ; } avp = ( struct l2tp_avp_t * ) ptr ; avp -> type = htons ( attr -> attr -> id ) ; <S2SV_StartBug> avp -> M = attr -> M ; <S2SV_EndBug> avp -> H = attr -> H ; <S2SV_StartBug> avp -> length = sizeof ( * avp ) + attr -> length ; <S2SV_EndBug> * ( uint16_t * ) ptr = htons ( * ( uint16_t * ) ptr ) ; if ( attr -> H ) memcpy ( avp -> val , attr -> val . octets , attr -> length ) ; else switch ( attr -> attr -> type ) { case ATTR_TYPE_INT16 : * ( int16_t * ) avp -> val = htons ( attr -> val . int16 ) ; break ; case ATTR_TYPE_INT32 : * ( int32_t * ) avp -> val = htonl ( attr -> val . int32 ) ; break ; case ATTR_TYPE_INT64 : * ( uint64_t * ) avp -> val = htobe64 ( attr -> val . uint64 ) ; break ; case ATTR_TYPE_STRING : case ATTR_TYPE_OCTETS : memcpy ( avp -> val , attr -> val . string , attr -> length ) ; break ; } ptr += sizeof ( * avp ) + attr -> length ; len += sizeof ( * avp ) + attr -> length ; } pack -> hdr . length = htons ( len ) ; memcpy ( buf , & pack -> hdr , sizeof ( pack -> hdr ) ) ; <S2SV_StartBug> n = sendto ( sock , buf , ntohs ( pack -> hdr . length ) , 0 , <S2SV_EndBug> & pack -> addr , sizeof ( pack -> addr ) ) ; mempool_free ( buf ) ; if ( n < 0 ) { if ( errno == EAGAIN ) { if ( conf_verbose ) log_warn ( \"l2tp:<S2SV_blank>buffer<S2SV_blank>overflow<S2SV_blank>(packet<S2SV_blank>lost)\\\\n\" ) ; } else { if ( conf_verbose ) log_warn ( \"l2tp:<S2SV_blank>sendto:<S2SV_blank>%s\\\\n\" , strerror ( errno ) ) ; return - 1 ; } } <S2SV_StartBug> if ( n != ntohs ( pack -> hdr . length ) ) { <S2SV_EndBug> if ( conf_verbose ) <S2SV_StartBug> log_warn ( \"l2tp:<S2SV_blank>short<S2SV_blank>write<S2SV_blank>(%i/%i)\\\\n\" , n , ntohs ( pack -> hdr . length ) ) ; <S2SV_EndBug> } return 0 ; }\n",
      "fixed_code": "<S2SV_ModStart> pack ) { struct l2tp_hdr_t * hdr <S2SV_ModEnd> ; struct l2tp_avp_t <S2SV_ModStart> ; uint8_t * buf , * <S2SV_ModStart> ; int n , len ; buf = mempool_alloc ( buf_pool <S2SV_ModEnd> ) ; if <S2SV_ModStart> L2TP_MAX_PACKET_SIZE ) ; hdr = ( struct l2tp_hdr_t * ) buf ; ptr = ( uint8_t * ) ( hdr + 1 ) ; len = <S2SV_ModEnd> sizeof ( pack <S2SV_ModStart> ; avp -> flags = htons ( ( attr -> M ? L2TP_AVP_FLAG_M : 0 ) | ( attr -> H ? L2TP_AVP_FLAG_H : 0 ) | ( ( <S2SV_ModEnd> sizeof ( * <S2SV_ModStart> attr -> length ) & L2TP_AVP_LEN_MASK ) <S2SV_ModEnd> ) ; if <S2SV_ModStart> ) ) ; hdr -> flags = htons ( pack -> hdr . flags ) ; <S2SV_ModStart> , buf , len <S2SV_ModEnd> , 0 , <S2SV_ModStart> ( n != len <S2SV_ModEnd> ) { if <S2SV_ModStart> , n , len <S2SV_ModEnd> ) ; }\n",
      "source_code_length": 2546,
      "target_code_length": 781,
      "vulnerability_patterns": {
        "buffer_overflow": 4,
        "integer_overflow": 2,
        "null_pointer": 40,
        "total": 46
      },
      "total_patterns": 46,
      "original_address": "https://github.com/accel-ppp/accel-ppp/commit/2324bcd5ba12cf28f47357a8f03cd41b7c04c52b",
      "discovery_time": "2020-09-09T23:15Z",
      "project_commit_id": "accel-ppp@accel-ppp/2324bcd5ba12cf28f47357a8f03cd41b7c04c52b",
      "extraction_time": "2025-08-31T15:41:49.183889",
      "label": 1,
      "vulnerability_type": "buffer_overflow",
      "difficulty_level": "advanced",
      "risk_factors": [
        "system_crash",
        "memory_corruption",
        "buffer_overflow",
        "arbitrary_code_execution"
      ],
      "attack_vectors": [
        "memory_manipulation",
        "malicious_input",
        "code_analysis",
        "buffer_overflow",
        "reverse_engineering",
        "fuzzing"
      ],
      "mitigation_strategies": [
        "safe_string_functions",
        "dynamic_analysis",
        "code_review",
        "static_analysis",
        "memory_safety_checks",
        "input_validation",
        "fuzzing",
        "bounds_checking",
        "secure_coding_practices"
      ],
      "code_differences": {
        "has_differences": true,
        "source_lines": 2,
        "target_lines": 2,
        "character_differences": 1765,
        "similarity_percentage": 35.57692307692308
      },
      "vulnerability_location": {
        "vulnerability_present": true,
        "fix_applied": true,
        "code_changed": true,
        "estimated_lines_changed": 0
      }
    },
    {
      "cve_id": "CVE-2016-1621",
      "cwe_id": "CWE-119",
      "cwe_name": "Buffer Overflow",
      "project": "external",
      "severity": "critical",
      "weaponization_score": 8.5,
      "is_critical": true,
      "is_weaponizable": true,
      "is_high_priority_project": false,
      "vulnerable_code": "CWE-119 int main ( int argc , char * * argv ) { int frame_cnt = 0 ; FILE * outfile = NULL ; vpx_codec_ctx_t codec ; const VpxInterface * decoder = NULL ; VpxVideoReader * reader = NULL ; const VpxVideoInfo * info = NULL ; int n = 0 ; int m = 0 ; int is_range = 0 ; char * nptr = NULL ; exec_name = argv [ 0 ] ; if ( argc != 4 ) die ( \"Invalid<S2SV_blank>number<S2SV_blank>of<S2SV_blank>arguments.\" ) ; reader = vpx_video_reader_open ( argv [ 1 ] ) ; if ( ! reader ) die ( \"Failed<S2SV_blank>to<S2SV_blank>open<S2SV_blank>%s<S2SV_blank>for<S2SV_blank>reading.\" , argv [ 1 ] ) ; if ( ! ( outfile = fopen ( argv [ 2 ] , \"wb\" ) ) ) die ( \"Failed<S2SV_blank>to<S2SV_blank>open<S2SV_blank>%s<S2SV_blank>for<S2SV_blank>writing.\" , argv [ 2 ] ) ; n = strtol ( argv [ 3 ] , & nptr , 0 ) ; m = strtol ( nptr + 1 , NULL , 0 ) ; is_range = ( * nptr == '-' ) ; if ( ! n || ! m || ( * nptr != '-' && * nptr != '/' ) ) die ( \"Couldn\\'t<S2SV_blank>parse<S2SV_blank>pattern<S2SV_blank>%s.\\\\n\" , argv [ 3 ] ) ; info = vpx_video_reader_get_info ( reader ) ; decoder = get_vpx_decoder_by_fourcc ( info -> codec_fourcc ) ; if ( ! decoder ) die ( \"Unknown<S2SV_blank>input<S2SV_blank>codec.\" ) ; <S2SV_StartBug> printf ( \"Using<S2SV_blank>%s\\\\n\" , vpx_codec_iface_name ( decoder -> interface ( ) ) ) ; <S2SV_EndBug> <S2SV_StartBug> if ( vpx_codec_dec_init ( & codec , decoder -> interface ( ) , NULL , 0 ) ) <S2SV_EndBug> die_codec ( & codec , \"Failed<S2SV_blank>to<S2SV_blank>initialize<S2SV_blank>decoder.\" ) ; while ( vpx_video_reader_read_frame ( reader ) ) { vpx_codec_iter_t iter = NULL ; vpx_image_t * img = NULL ; size_t frame_size = 0 ; int skip ; const unsigned char * frame = vpx_video_reader_get_frame ( reader , & frame_size ) ; if ( vpx_codec_decode ( & codec , frame , ( unsigned int ) frame_size , NULL , 0 ) ) die_codec ( & codec , \"Failed<S2SV_blank>to<S2SV_blank>decode<S2SV_blank>frame.\" ) ; ++ frame_cnt ; skip = ( is_range && frame_cnt >= n && frame_cnt <= m ) || ( ! is_range && m - ( frame_cnt - 1 ) % m <= n ) ; if ( ! skip ) { putc ( '.' , stdout ) ; while ( ( img = vpx_codec_get_frame ( & codec , & iter ) ) != NULL ) vpx_img_write ( img , outfile ) ; } else { putc ( 'X' , stdout ) ; } fflush ( stdout ) ; } printf ( \"Processed<S2SV_blank>%d<S2SV_blank>frames.\\\\n\" , frame_cnt ) ; if ( vpx_codec_destroy ( & codec ) ) die_codec ( & codec , \"Failed<S2SV_blank>to<S2SV_blank>destroy<S2SV_blank>codec.\" ) ; printf ( \"Play:<S2SV_blank>ffplay<S2SV_blank>-f<S2SV_blank>rawvideo<S2SV_blank>-pix_fmt<S2SV_blank>yuv420p<S2SV_blank>-s<S2SV_blank>%dx%d<S2SV_blank>%s\\\\n\" , info -> frame_width , info -> frame_height , argv [ 2 ] ) ; vpx_video_reader_close ( reader ) ; fclose ( outfile ) ; return EXIT_SUCCESS ; }\n",
      "fixed_code": "<S2SV_ModStart> ( decoder -> codec_interface <S2SV_ModEnd> ( ) ) <S2SV_ModStart> , decoder -> codec_interface <S2SV_ModEnd> ( ) ,\n",
      "source_code_length": 2710,
      "target_code_length": 130,
      "vulnerability_patterns": {
        "buffer_overflow": 1,
        "null_pointer": 12,
        "total": 13
      },
      "total_patterns": 13,
      "original_address": "https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426",
      "discovery_time": "2016-03-12T21:59Z",
      "project_commit_id": "external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426",
      "extraction_time": "2025-08-31T15:41:49.183924",
      "label": 1,
      "vulnerability_type": "buffer_overflow",
      "difficulty_level": "advanced",
      "risk_factors": [
        "system_crash",
        "memory_corruption",
        "buffer_overflow",
        "arbitrary_code_execution"
      ],
      "attack_vectors": [
        "memory_manipulation",
        "malicious_input",
        "code_analysis",
        "buffer_overflow",
        "reverse_engineering",
        "fuzzing"
      ],
      "mitigation_strategies": [
        "safe_string_functions",
        "dynamic_analysis",
        "code_review",
        "static_analysis",
        "memory_safety_checks",
        "input_validation",
        "fuzzing",
        "bounds_checking",
        "secure_coding_practices"
      ],
      "code_differences": {
        "has_differences": true,
        "source_lines": 2,
        "target_lines": 2,
        "character_differences": 2580,
        "similarity_percentage": 4.464285714285714
      },
      "vulnerability_location": {
        "vulnerability_present": true,
        "fix_applied": true,
        "code_changed": true,
        "estimated_lines_changed": 0
      }
    },
    {
      "cve_id": "CVE-2016-4804",
      "cwe_id": "CWE-119",
      "cwe_name": "Buffer Overflow",
      "project": "dosfstools",
      "severity": "critical",
      "weaponization_score": 8.5,
      "is_critical": true,
      "is_weaponizable": true,
      "is_high_priority_project": false,
      "vulnerable_code": "CWE-119 static void dump_boot ( DOS_FS * fs , struct boot_sector * b , unsigned lss ) { unsigned short sectors ; printf ( \"Boot<S2SV_blank>sector<S2SV_blank>contents:\\\\n\" ) ; if ( ! atari_format ) { char id [ 9 ] ; strncpy ( id , ( const char * ) b -> system_id , 8 ) ; id [ 8 ] = 0 ; printf ( \"System<S2SV_blank>ID<S2SV_blank>\\\\\"%s\\\\\"\\\\n\" , id ) ; } else { printf ( \"Serial<S2SV_blank>number<S2SV_blank>0x%x\\\\n\" , b -> system_id [ 5 ] | ( b -> system_id [ 6 ] << 8 ) | ( b -> system_id [ 7 ] << 16 ) ) ; } printf ( \"Media<S2SV_blank>byte<S2SV_blank>0x%02x<S2SV_blank>(%s)\\\\n\" , b -> media , get_media_descr ( b -> media ) ) ; printf ( \"%10d<S2SV_blank>bytes<S2SV_blank>per<S2SV_blank>logical<S2SV_blank>sector\\\\n\" , GET_UNALIGNED_W ( b -> sector_size ) ) ; printf ( \"%10d<S2SV_blank>bytes<S2SV_blank>per<S2SV_blank>cluster\\\\n\" , fs -> cluster_size ) ; printf ( \"%10d<S2SV_blank>reserved<S2SV_blank>sector%s\\\\n\" , le16toh ( b -> reserved ) , le16toh ( b -> reserved ) == 1 ? \"\" : \"s\" ) ; printf ( \"First<S2SV_blank>FAT<S2SV_blank>starts<S2SV_blank>at<S2SV_blank>byte<S2SV_blank>%llu<S2SV_blank>(sector<S2SV_blank>%llu)\\\\n\" , ( unsigned long long ) fs -> fat_start , ( unsigned long long ) fs -> fat_start / lss ) ; printf ( \"%10d<S2SV_blank>FATs,<S2SV_blank>%d<S2SV_blank>bit<S2SV_blank>entries\\\\n\" , b -> fats , fs -> fat_bits ) ; <S2SV_StartBug> printf ( \"%10d<S2SV_blank>bytes<S2SV_blank>per<S2SV_blank>FAT<S2SV_blank>(=<S2SV_blank>%u<S2SV_blank>sectors)\\\\n\" , fs -> fat_size , <S2SV_EndBug> <S2SV_StartBug> fs -> fat_size / lss ) ; <S2SV_EndBug> if ( ! fs -> root_cluster ) { printf ( \"Root<S2SV_blank>directory<S2SV_blank>starts<S2SV_blank>at<S2SV_blank>byte<S2SV_blank>%llu<S2SV_blank>(sector<S2SV_blank>%llu)\\\\n\" , ( unsigned long long ) fs -> root_start , ( unsigned long long ) fs -> root_start / lss ) ; printf ( \"%10d<S2SV_blank>root<S2SV_blank>directory<S2SV_blank>entries\\\\n\" , fs -> root_entries ) ; } else { printf ( \"Root<S2SV_blank>directory<S2SV_blank>start<S2SV_blank>at<S2SV_blank>cluster<S2SV_blank>%lu<S2SV_blank>(arbitrary<S2SV_blank>size)\\\\n\" , ( unsigned long ) fs -> root_cluster ) ; } printf ( \"Data<S2SV_blank>area<S2SV_blank>starts<S2SV_blank>at<S2SV_blank>byte<S2SV_blank>%llu<S2SV_blank>(sector<S2SV_blank>%llu)\\\\n\" , ( unsigned long long ) fs -> data_start , ( unsigned long long ) fs -> data_start / lss ) ; printf ( \"%10lu<S2SV_blank>data<S2SV_blank>clusters<S2SV_blank>(%llu<S2SV_blank>bytes)\\\\n\" , ( unsigned long ) fs -> data_clusters , ( unsigned long long ) fs -> data_clusters * fs -> cluster_size ) ; printf ( \"%u<S2SV_blank>sectors/track,<S2SV_blank>%u<S2SV_blank>heads\\\\n\" , le16toh ( b -> secs_track ) , le16toh ( b -> heads ) ) ; printf ( \"%10u<S2SV_blank>hidden<S2SV_blank>sectors\\\\n\" , atari_format ? ( ( ( unsigned char * ) & b -> hidden ) [ 0 ] | ( ( unsigned char * ) & b -> hidden ) [ 1 ] << 8 ) : le32toh ( b -> hidden ) ) ; sectors = GET_UNALIGNED_W ( b -> sectors ) ; printf ( \"%10u<S2SV_blank>sectors<S2SV_blank>total\\\\n\" , sectors ? sectors : le32toh ( b -> total_sect ) ) ; }\n",
      "fixed_code": "<S2SV_ModStart> ; printf ( \"%10lld<S2SV_blank>bytes<S2SV_blank>per<S2SV_blank>FAT<S2SV_blank>(=<S2SV_blank>%llu<S2SV_blank>sectors)\\\\n\" , ( long long ) <S2SV_ModEnd> fs -> fat_size <S2SV_ModStart> -> fat_size , ( long long )\n",
      "source_code_length": 3033,
      "target_code_length": 225,
      "vulnerability_patterns": {
        "buffer_overflow": 1,
        "format_string": 18,
        "null_pointer": 35,
        "total": 54
      },
      "total_patterns": 54,
      "original_address": "https://github.com/dosfstools/dosfstools/commit/e8eff147e9da1185f9afd5b25948153a3b97cf52",
      "discovery_time": "2016-06-03T14:59Z",
      "project_commit_id": "dosfstools@dosfstools/e8eff147e9da1185f9afd5b25948153a3b97cf52",
      "extraction_time": "2025-08-31T15:41:49.183956",
      "label": 1,
      "vulnerability_type": "buffer_overflow",
      "difficulty_level": "advanced",
      "risk_factors": [
        "system_crash",
        "memory_corruption",
        "buffer_overflow",
        "arbitrary_code_execution"
      ],
      "attack_vectors": [
        "memory_manipulation",
        "malicious_input",
        "code_analysis",
        "buffer_overflow",
        "reverse_engineering",
        "fuzzing"
      ],
      "mitigation_strategies": [
        "safe_string_functions",
        "dynamic_analysis",
        "code_review",
        "static_analysis",
        "memory_safety_checks",
        "input_validation",
        "fuzzing",
        "bounds_checking",
        "secure_coding_practices"
      ],
      "code_differences": {
        "has_differences": true,
        "source_lines": 2,
        "target_lines": 2,
        "character_differences": 2808,
        "similarity_percentage": 9.375
      },
      "vulnerability_location": {
        "vulnerability_present": true,
        "fix_applied": true,
        "code_changed": true,
        "estimated_lines_changed": 0
      }
    },
    {
      "cve_id": "CVE-2019-15785",
      "cwe_id": "CWE-119",
      "cwe_name": "Buffer Overflow",
      "project": "fontforge",
      "severity": "critical",
      "weaponization_score": 8.5,
      "is_critical": true,
      "is_weaponizable": true,
      "is_high_priority_project": false,
      "vulnerable_code": "CWE-119 static void GTextFieldSave ( GTextField * gt , int utf8 ) { unichar_t * ret ; char * cret ; FILE * file ; unichar_t * pt ; if ( _ggadget_use_gettext ) { char * temp = GWidgetOpenFile8 ( _ ( \"Save\" ) , NULL , \"*.{txt,py}\" , NULL , NULL ) ; ret = utf82u_copy ( temp ) ; free ( temp ) ; } else ret = GWidgetSaveAsFile ( GStringGetResource ( _STR_Save , NULL ) , NULL , txt , NULL , NULL ) ; if ( ret == NULL ) return ; cret = u2def_copy ( ret ) ; free ( ret ) ; file = fopen ( cret , \"w\" ) ; if ( file == NULL ) { if ( _ggadget_use_gettext ) GWidgetError8 ( _ ( \"Could<S2SV_blank>not<S2SV_blank>open<S2SV_blank>file\" ) , _ ( \"Could<S2SV_blank>not<S2SV_blank>open<S2SV_blank>%.100s\" ) , cret ) ; else GWidgetError ( errort , error , cret ) ; free ( cret ) ; return ; } free ( cret ) ; if ( utf8 ) { putc ( 0xef , file ) ; putc ( 0xbb , file ) ; putc ( 0xbf , file ) ; for ( pt = gt -> text ; * pt ; ++ pt ) { if ( * pt < 0x80 ) putc ( * pt , file ) ; else if ( * pt < 0x800 ) { putc ( 0xc0 | ( * pt >> 6 ) , file ) ; putc ( 0x80 | ( * pt & 0x3f ) , file ) ; } else if ( * pt >= 0xd800 && * pt < 0xdc00 && pt [ 1 ] >= 0xdc00 && pt [ 1 ] < 0xe000 ) { int u = ( ( * pt >> 6 ) & 0xf ) + 1 , y = ( ( * pt & 3 ) << 4 ) | ( ( pt [ 1 ] >> 6 ) & 0xf ) ; putc ( 0xf0 | ( u >> 2 ) , file ) ; putc ( 0x80 | ( ( u & 3 ) << 4 ) | ( ( * pt >> 2 ) & 0xf ) , file ) ; putc ( 0x80 | y , file ) ; putc ( 0x80 | ( pt [ 1 ] & 0x3f ) , file ) ; } else { putc ( 0xe0 | ( * pt >> 12 ) , file ) ; putc ( 0x80 | ( ( * pt >> 6 ) & 0x3f ) , file ) ; putc ( 0x80 | ( * pt & 0x3f ) , file ) ; } } } else { putc ( 0xfeff >> 8 , file ) ; putc ( 0xfeff & 0xff , file ) ; for ( pt = gt -> text ; * pt ; ++ pt ) { putc ( * pt >> 8 , file ) ; putc ( * pt & 0xff , file ) ; } } fclose ( file ) ; <S2SV_StartBug> } <S2SV_EndBug>\n",
      "fixed_code": "<S2SV_ModStart> file ) ; GTextFieldSaved ( gt ) ;\n",
      "source_code_length": 1795,
      "target_code_length": 50,
      "vulnerability_patterns": {
        "use_after_free": 4,
        "integer_overflow": 2,
        "null_pointer": 4,
        "total": 10
      },
      "total_patterns": 10,
      "original_address": "https://github.com/fontforge/fontforge/commit/626f751752875a0ddd74b9e217b6f4828713573c",
      "discovery_time": "2019-08-29T13:15Z",
      "project_commit_id": "fontforge@fontforge/626f751752875a0ddd74b9e217b6f4828713573c",
      "extraction_time": "2025-08-31T15:41:49.183997",
      "label": 1,
      "vulnerability_type": "buffer_overflow",
      "difficulty_level": "advanced",
      "risk_factors": [
        "system_crash",
        "memory_corruption",
        "arbitrary_code_execution",
        "use_after_free"
      ],
      "attack_vectors": [
        "memory_manipulation",
        "malicious_input",
        "code_analysis",
        "buffer_overflow",
        "reverse_engineering",
        "fuzzing"
      ],
      "mitigation_strategies": [
        "safe_string_functions",
        "dynamic_analysis",
        "code_review",
        "static_analysis",
        "memory_safety_checks",
        "input_validation",
        "fuzzing",
        "bounds_checking",
        "secure_coding_practices"
      ],
      "code_differences": {
        "has_differences": true,
        "source_lines": 2,
        "target_lines": 2,
        "character_differences": 1745,
        "similarity_percentage": 5.376344086021505
      },
      "vulnerability_location": {
        "vulnerability_present": true,
        "fix_applied": true,
        "code_changed": true,
        "estimated_lines_changed": 0
      }
    },
    {
      "cve_id": "CVE-2013-1860",
      "cwe_id": "CWE-119",
      "cwe_name": "Buffer Overflow",
      "project": "torvalds",
      "severity": "critical",
      "weaponization_score": 8.5,
      "is_critical": true,
      "is_weaponizable": true,
      "is_high_priority_project": false,
      "vulnerable_code": "CWE-119 static void wdm_in_callback ( struct urb * urb ) { struct wdm_device * desc = urb -> context ; int status = urb -> status ; <S2SV_StartBug> spin_lock ( & desc -> iuspin ) ; <S2SV_EndBug> clear_bit ( WDM_RESPONDING , & desc -> flags ) ; if ( status ) { switch ( status ) { case - ENOENT : dev_dbg ( & desc -> intf -> dev , \"nonzero<S2SV_blank>urb<S2SV_blank>status<S2SV_blank>received:<S2SV_blank>-ENOENT\" ) ; goto skip_error ; case - ECONNRESET : dev_dbg ( & desc -> intf -> dev , \"nonzero<S2SV_blank>urb<S2SV_blank>status<S2SV_blank>received:<S2SV_blank>-ECONNRESET\" ) ; goto skip_error ; case - ESHUTDOWN : dev_dbg ( & desc -> intf -> dev , \"nonzero<S2SV_blank>urb<S2SV_blank>status<S2SV_blank>received:<S2SV_blank>-ESHUTDOWN\" ) ; goto skip_error ; case - EPIPE : dev_err ( & desc -> intf -> dev , \"nonzero<S2SV_blank>urb<S2SV_blank>status<S2SV_blank>received:<S2SV_blank>-EPIPE\\\\n\" ) ; break ; default : dev_err ( & desc -> intf -> dev , \"Unexpected<S2SV_blank>error<S2SV_blank>%d\\\\n\" , status ) ; break ; } } desc -> rerr = status ; <S2SV_StartBug> desc -> reslength = urb -> actual_length ; <S2SV_EndBug> <S2SV_StartBug> memmove ( desc -> ubuf + desc -> length , desc -> inbuf , desc -> reslength ) ; <S2SV_EndBug> desc -> length += desc -> reslength ; skip_error : wake_up ( & desc -> wait ) ; set_bit ( WDM_READ , & desc -> flags ) ; spin_unlock ( & desc -> iuspin ) ; }\n",
      "fixed_code": "<S2SV_ModStart> -> status ; int length = urb -> actual_length ; <S2SV_ModStart> = status ; if ( length + desc -> length > desc -> wMaxCommand ) { set_bit ( WDM_OVERFLOW , & desc -> flags ) ; } else { if ( ! test_bit ( WDM_OVERFLOW , & desc -> flags ) ) { <S2SV_ModEnd> memmove ( desc <S2SV_ModStart> -> inbuf , length ) ; desc -> length += length ; <S2SV_ModStart> desc -> reslength = length ; } } <S2SV_ModEnd> skip_error : wake_up\n",
      "source_code_length": 1386,
      "target_code_length": 433,
      "vulnerability_patterns": {
        "buffer_overflow": 1,
        "integer_overflow": 1,
        "null_pointer": 26,
        "total": 28
      },
      "total_patterns": 28,
      "original_address": "https://github.com/torvalds/linux/commit/c0f5ecee4e741667b2493c742b60b6218d40b3aa",
      "discovery_time": "2013-03-22T11:59Z",
      "project_commit_id": "torvalds@linux/c0f5ecee4e741667b2493c742b60b6218d40b3aa",
      "extraction_time": "2025-08-31T15:41:49.184036",
      "label": 1,
      "vulnerability_type": "buffer_overflow",
      "difficulty_level": "advanced",
      "risk_factors": [
        "system_crash",
        "memory_corruption",
        "buffer_overflow",
        "arbitrary_code_execution"
      ],
      "attack_vectors": [
        "memory_manipulation",
        "malicious_input",
        "code_analysis",
        "buffer_overflow",
        "reverse_engineering",
        "fuzzing"
      ],
      "mitigation_strategies": [
        "safe_string_functions",
        "dynamic_analysis",
        "code_review",
        "static_analysis",
        "memory_safety_checks",
        "input_validation",
        "fuzzing",
        "bounds_checking",
        "secure_coding_practices"
      ],
      "code_differences": {
        "has_differences": true,
        "source_lines": 2,
        "target_lines": 2,
        "character_differences": 953,
        "similarity_percentage": 36.11111111111111
      },
      "vulnerability_location": {
        "vulnerability_present": true,
        "fix_applied": true,
        "code_changed": true,
        "estimated_lines_changed": 0
      }
    },
    {
      "cve_id": "CVE-2018-20762",
      "cwe_id": "CWE-119",
      "cwe_name": "Buffer Overflow",
      "project": "gpac",
      "severity": "critical",
      "weaponization_score": 8.5,
      "is_critical": true,
      "is_weaponizable": true,
      "is_high_priority_project": false,
      "vulnerable_code": "CWE-119 static Bool FFD_CanHandleURL ( GF_InputService * plug , const char * url ) { Bool has_audio , has_video ; s32 i ; AVFormatContext * ctx ; AVOutputFormat * fmt_out ; Bool ret = GF_FALSE ; <S2SV_StartBug> char * ext , szName [ 1000 ] , szExt [ 20 ] ; <S2SV_EndBug> const char * szExtList ; FFDemux * ffd ; if ( ! plug || ! url ) return GF_FALSE ; if ( ! strnicmp ( url , \"rtsp://\" , 7 ) ) return GF_FALSE ; if ( ! strnicmp ( url , \"rtspu://\" , 8 ) ) return GF_FALSE ; if ( ! strnicmp ( url , \"rtp://\" , 6 ) ) return GF_FALSE ; if ( ! strnicmp ( url , \"plato://\" , 8 ) ) return GF_FALSE ; if ( ! strnicmp ( url , \"udp://\" , 6 ) ) return GF_FALSE ; if ( ! strnicmp ( url , \"tcp://\" , 6 ) ) return GF_FALSE ; if ( ! strnicmp ( url , \"data:\" , 5 ) ) return GF_FALSE ; ffd = ( FFDemux * ) plug -> priv ; <S2SV_StartBug> strcpy ( szName , url ) ; <S2SV_EndBug> ext = strrchr ( szName , '#' ) ; if ( ext ) ext [ 0 ] = 0 ; ext = strrchr ( szName , '?' ) ; if ( ext ) ext [ 0 ] = 0 ; ext = strrchr ( szName , '.' ) ; if ( ext && strlen ( ext ) > 19 ) ext = NULL ; <S2SV_StartBug> if ( ext && strlen ( ext ) > 1 ) { <S2SV_EndBug> strcpy ( szExt , & ext [ 1 ] ) ; strlwr ( szExt ) ; # ifndef FFMPEG_DEMUX_ENABLE_MPEG2TS if ( strstr ( \"ts<S2SV_blank>m2t<S2SV_blank>mts<S2SV_blank>dmb<S2SV_blank>trp\" , szExt ) ) return GF_FALSE ; # endif if ( ! strcmp ( szExt , \"mp4\" ) || ! strcmp ( szExt , \"mpg4\" ) || ! strcmp ( szExt , \"m4a\" ) || ! strcmp ( szExt , \"m21\" ) || ! strcmp ( szExt , \"m4v\" ) || ! strcmp ( szExt , \"m4a\" ) || ! strcmp ( szExt , \"m4s\" ) || ! strcmp ( szExt , \"3gs\" ) || ! strcmp ( szExt , \"3gp\" ) || ! strcmp ( szExt , \"3gpp\" ) || ! strcmp ( szExt , \"3gp2\" ) || ! strcmp ( szExt , \"3g2\" ) || ! strcmp ( szExt , \"mp3\" ) || ! strcmp ( szExt , \"ac3\" ) || ! strcmp ( szExt , \"amr\" ) || ! strcmp ( szExt , \"bt\" ) || ! strcmp ( szExt , \"wrl\" ) || ! strcmp ( szExt , \"x3dv\" ) || ! strcmp ( szExt , \"xmt\" ) || ! strcmp ( szExt , \"xmta\" ) || ! strcmp ( szExt , \"x3d\" ) || ! strcmp ( szExt , \"jpg\" ) || ! strcmp ( szExt , \"jpeg\" ) || ! strcmp ( szExt , \"png\" ) ) return GF_FALSE ; { u32 i ; for ( i = 0 ; FFD_MIME_TYPES [ i ] ; i += 3 ) { if ( gf_service_check_mime_register ( plug , FFD_MIME_TYPES [ i ] , FFD_MIME_TYPES [ i + 1 ] , FFD_MIME_TYPES [ i + 2 ] , ext ) ) return GF_TRUE ; } } } ffd_parse_options ( ffd , url ) ; ctx = NULL ; if ( open_file ( & ctx , szName , NULL , ffd -> options ? & ffd -> options : NULL ) < 0 ) { AVInputFormat * av_in = NULL ; if ( ext && ! strcmp ( szExt , \"cmp\" ) ) av_in = av_find_input_format ( \"m4v\" ) ; if ( open_file ( & ctx , szName , av_in , ffd -> options ? & ffd -> options : NULL ) < 0 ) { return GF_FALSE ; } } if ( ! ctx ) goto exit ; if ( av_find_stream_info ( ctx ) < 0 ) goto exit ; has_video = has_audio = GF_FALSE ; for ( i = 0 ; i < ( s32 ) ctx -> nb_streams ; i ++ ) { AVCodecContext * enc = ctx -> streams [ i ] -> codec ; switch ( enc -> codec_type ) { case AVMEDIA_TYPE_AUDIO : if ( ! has_audio ) has_audio = GF_TRUE ; break ; case AVMEDIA_TYPE_VIDEO : if ( ! has_video ) has_video = GF_TRUE ; break ; default : break ; } } if ( ! has_audio && ! has_video ) goto exit ; ret = GF_TRUE ; # if ( ( LIBAVFORMAT_VERSION_MAJOR == 52 ) && ( LIBAVFORMAT_VERSION_MINOR <= 47 ) ) || ( LIBAVFORMAT_VERSION_MAJOR < 52 ) fmt_out = guess_stream_format ( NULL , url , NULL ) ; # else fmt_out = av_guess_format ( NULL , url , NULL ) ; # endif if ( fmt_out ) gf_service_register_mime ( plug , fmt_out -> mime_type , fmt_out -> extensions , fmt_out -> name ) ; else { ext = strrchr ( szName , '.' ) ; if ( ext ) { strcpy ( szExt , & ext [ 1 ] ) ; strlwr ( szExt ) ; szExtList = gf_modules_get_option ( ( GF_BaseInterface * ) plug , \"MimeTypes\" , \"application/x-ffmpeg\" ) ; if ( ! szExtList ) { gf_service_register_mime ( plug , \"application/x-ffmpeg\" , szExt , \"Other<S2SV_blank>Movies<S2SV_blank>(FFMPEG)\" ) ; } else if ( ! strstr ( szExtList , szExt ) ) { u32 len ; char * buf ; len = ( u32 ) ( strlen ( szExtList ) + strlen ( szExt ) + 10 ) ; buf = ( char * ) gf_malloc ( sizeof ( char ) * len ) ; sprintf ( buf , \"\\\\\"%s<S2SV_blank>\" , szExt ) ; strcat ( buf , & szExtList [ 1 ] ) ; gf_modules_set_option ( ( GF_BaseInterface * ) plug , \"MimeTypes\" , \"application/x-ffmpeg\" , buf ) ; gf_free ( buf ) ; } } } exit : # if FF_API_CLOSE_INPUT_FILE if ( ctx ) av_close_input_file ( ctx ) ; # else if ( ctx ) avformat_close_input ( & ctx ) ; # endif return ret ; }\n",
      "fixed_code": "<S2SV_ModStart> , szName [ 1024 <S2SV_ModEnd> ] , szExt <S2SV_ModStart> -> priv ; if ( strlen ( url ) >= sizeof ( szName ) ) return GF_FALSE ; <S2SV_ModStart> ) > 1 && strlen ( ext ) <= sizeof ( szExt )\n",
      "source_code_length": 4401,
      "target_code_length": 203,
      "vulnerability_patterns": {
        "buffer_overflow": 5,
        "integer_overflow": 2,
        "format_string": 1,
        "null_pointer": 20,
        "total": 28
      },
      "total_patterns": 28,
      "original_address": "https://github.com/gpac/gpac/commit/35ab4475a7df9b2a4bcab235e379c0c3ec543658",
      "discovery_time": "2019-02-06T23:29Z",
      "project_commit_id": "gpac@gpac/35ab4475a7df9b2a4bcab235e379c0c3ec543658",
      "extraction_time": "2025-08-31T15:41:49.184073",
      "label": 1,
      "vulnerability_type": "buffer_overflow",
      "difficulty_level": "advanced",
      "risk_factors": [
        "system_crash",
        "memory_corruption",
        "buffer_overflow",
        "arbitrary_code_execution"
      ],
      "attack_vectors": [
        "memory_manipulation",
        "malicious_input",
        "code_analysis",
        "buffer_overflow",
        "reverse_engineering",
        "fuzzing"
      ],
      "mitigation_strategies": [
        "safe_string_functions",
        "dynamic_analysis",
        "code_review",
        "static_analysis",
        "memory_safety_checks",
        "input_validation",
        "fuzzing",
        "bounds_checking",
        "secure_coding_practices"
      ],
      "code_differences": {
        "has_differences": true,
        "source_lines": 2,
        "target_lines": 2,
        "character_differences": 4198,
        "similarity_percentage": 12.280701754385964
      },
      "vulnerability_location": {
        "vulnerability_present": true,
        "fix_applied": true,
        "code_changed": true,
        "estimated_lines_changed": 0
      }
    },
    {
      "cve_id": "CVE-2016-9535",
      "cwe_id": "CWE-119",
      "cwe_name": "Buffer Overflow",
      "project": "vadz",
      "severity": "critical",
      "weaponization_score": 8.5,
      "is_critical": true,
      "is_weaponizable": true,
      "is_high_priority_project": false,
      "vulnerable_code": "CWE-119 static int fpAcc ( TIFF * tif , uint8 * cp0 , tmsize_t cc ) { tmsize_t stride = PredictorState ( tif ) -> stride ; uint32 bps = tif -> tif_dir . td_bitspersample / 8 ; tmsize_t wc = cc / bps ; tmsize_t count = cc ; uint8 * cp = ( uint8 * ) cp0 ; <S2SV_StartBug> uint8 * tmp = ( uint8 * ) _TIFFmalloc ( cc ) ; <S2SV_EndBug> if ( cc % ( bps * stride ) != 0 ) { TIFFErrorExt ( tif -> tif_clientdata , \"fpAcc\" , \"%s\" , \"cc%(bps*stride))!=0\" ) ; return 0 ; } <S2SV_StartBug> if ( ! tmp ) <S2SV_EndBug> return 0 ; while ( count > stride ) { REPEAT4 ( stride , cp [ stride ] = ( unsigned char ) ( ( cp [ stride ] + cp [ 0 ] ) & 0xff ) ; cp ++ ) count -= stride ; } _TIFFmemcpy ( tmp , cp0 , cc ) ; cp = ( uint8 * ) cp0 ; for ( count = 0 ; count < wc ; count ++ ) { uint32 byte ; for ( byte = 0 ; byte < bps ; byte ++ ) { # if WORDS_BIGENDIAN cp [ bps * count + byte ] = tmp [ byte * wc + count ] ; # else cp [ bps * count + byte ] = tmp [ ( bps - byte - 1 ) * wc + count ] ; # endif } } _TIFFfree ( tmp ) ; return 1 ; }\n",
      "fixed_code": "<S2SV_ModStart> uint8 * tmp <S2SV_ModEnd> ; if ( <S2SV_ModStart> 0 ; } tmp = ( uint8 * ) _TIFFmalloc ( cc ) ;\n",
      "source_code_length": 1021,
      "target_code_length": 110,
      "vulnerability_patterns": {
        "buffer_overflow": 1,
        "integer_overflow": 2,
        "null_pointer": 7,
        "total": 10
      },
      "total_patterns": 10,
      "original_address": "https://github.com/vadz/libtiff/commit/6a984bf7905c6621281588431f384e79d11a2e33",
      "discovery_time": "2016-11-22T19:59Z",
      "project_commit_id": "vadz@libtiff/6a984bf7905c6621281588431f384e79d11a2e33",
      "extraction_time": "2025-08-31T15:41:49.184117",
      "label": 1,
      "vulnerability_type": "buffer_overflow",
      "difficulty_level": "advanced",
      "risk_factors": [
        "system_crash",
        "memory_corruption",
        "buffer_overflow",
        "arbitrary_code_execution"
      ],
      "attack_vectors": [
        "memory_manipulation",
        "malicious_input",
        "code_analysis",
        "buffer_overflow",
        "reverse_engineering",
        "fuzzing"
      ],
      "mitigation_strategies": [
        "safe_string_functions",
        "dynamic_analysis",
        "code_review",
        "static_analysis",
        "memory_safety_checks",
        "input_validation",
        "fuzzing",
        "bounds_checking",
        "secure_coding_practices"
      ],
      "code_differences": {
        "has_differences": true,
        "source_lines": 2,
        "target_lines": 2,
        "character_differences": 911,
        "similarity_percentage": 16.901408450704224
      },
      "vulnerability_location": {
        "vulnerability_present": true,
        "fix_applied": true,
        "code_changed": true,
        "estimated_lines_changed": 0
      }
    },
    {
      "cve_id": "CVE-2016-1621",
      "cwe_id": "CWE-119",
      "cwe_name": "Buffer Overflow",
      "project": "external",
      "severity": "critical",
      "weaponization_score": 8.5,
      "is_critical": true,
      "is_weaponizable": true,
      "is_high_priority_project": false,
      "vulnerable_code": "CWE-119 int main ( int argc , char * * argv ) { int frame_cnt = 0 ; FILE * outfile = NULL ; vpx_codec_ctx_t codec ; const VpxInterface * decoder = NULL ; VpxVideoReader * reader = NULL ; const VpxVideoInfo * info = NULL ; int n = 0 ; int m = 0 ; int is_range = 0 ; char * nptr = NULL ; exec_name = argv [ 0 ] ; if ( argc != 4 ) die ( \"Invalid<S2SV_blank>number<S2SV_blank>of<S2SV_blank>arguments.\" ) ; reader = vpx_video_reader_open ( argv [ 1 ] ) ; if ( ! reader ) die ( \"Failed<S2SV_blank>to<S2SV_blank>open<S2SV_blank>%s<S2SV_blank>for<S2SV_blank>reading.\" , argv [ 1 ] ) ; if ( ! ( outfile = fopen ( argv [ 2 ] , \"wb\" ) ) ) die ( \"Failed<S2SV_blank>to<S2SV_blank>open<S2SV_blank>%s<S2SV_blank>for<S2SV_blank>writing.\" , argv [ 2 ] ) ; n = strtol ( argv [ 3 ] , & nptr , 0 ) ; m = strtol ( nptr + 1 , NULL , 0 ) ; is_range = ( * nptr == '-' ) ; if ( ! n || ! m || ( * nptr != '-' && * nptr != '/' ) ) die ( \"Couldn\\'t<S2SV_blank>parse<S2SV_blank>pattern<S2SV_blank>%s.\\\\n\" , argv [ 3 ] ) ; info = vpx_video_reader_get_info ( reader ) ; decoder = get_vpx_decoder_by_fourcc ( info -> codec_fourcc ) ; if ( ! decoder ) die ( \"Unknown<S2SV_blank>input<S2SV_blank>codec.\" ) ; <S2SV_StartBug> printf ( \"Using<S2SV_blank>%s\\\\n\" , vpx_codec_iface_name ( decoder -> interface ( ) ) ) ; <S2SV_EndBug> <S2SV_StartBug> if ( vpx_codec_dec_init ( & codec , decoder -> interface ( ) , NULL , 0 ) ) <S2SV_EndBug> die_codec ( & codec , \"Failed<S2SV_blank>to<S2SV_blank>initialize<S2SV_blank>decoder.\" ) ; while ( vpx_video_reader_read_frame ( reader ) ) { vpx_codec_iter_t iter = NULL ; vpx_image_t * img = NULL ; size_t frame_size = 0 ; int skip ; const unsigned char * frame = vpx_video_reader_get_frame ( reader , & frame_size ) ; if ( vpx_codec_decode ( & codec , frame , ( unsigned int ) frame_size , NULL , 0 ) ) die_codec ( & codec , \"Failed<S2SV_blank>to<S2SV_blank>decode<S2SV_blank>frame.\" ) ; ++ frame_cnt ; skip = ( is_range && frame_cnt >= n && frame_cnt <= m ) || ( ! is_range && m - ( frame_cnt - 1 ) % m <= n ) ; if ( ! skip ) { putc ( '.' , stdout ) ; while ( ( img = vpx_codec_get_frame ( & codec , & iter ) ) != NULL ) vpx_img_write ( img , outfile ) ; } else { putc ( 'X' , stdout ) ; } fflush ( stdout ) ; } printf ( \"Processed<S2SV_blank>%d<S2SV_blank>frames.\\\\n\" , frame_cnt ) ; if ( vpx_codec_destroy ( & codec ) ) die_codec ( & codec , \"Failed<S2SV_blank>to<S2SV_blank>destroy<S2SV_blank>codec.\" ) ; printf ( \"Play:<S2SV_blank>ffplay<S2SV_blank>-f<S2SV_blank>rawvideo<S2SV_blank>-pix_fmt<S2SV_blank>yuv420p<S2SV_blank>-s<S2SV_blank>%dx%d<S2SV_blank>%s\\\\n\" , info -> frame_width , info -> frame_height , argv [ 2 ] ) ; vpx_video_reader_close ( reader ) ; fclose ( outfile ) ; return EXIT_SUCCESS ; }\n",
      "fixed_code": "<S2SV_ModStart> ( decoder -> codec_interface <S2SV_ModEnd> ( ) ) <S2SV_ModStart> , decoder -> codec_interface <S2SV_ModEnd> ( ) ,\n",
      "source_code_length": 2710,
      "target_code_length": 130,
      "vulnerability_patterns": {
        "buffer_overflow": 4,
        "integer_overflow": 21,
        "null_pointer": 196,
        "total": 221
      },
      "total_patterns": 221,
      "original_address": "https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426",
      "discovery_time": "2016-03-12T21:59Z",
      "project_commit_id": "external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426",
      "extraction_time": "2025-08-31T15:41:49.184134",
      "label": 1,
      "vulnerability_type": "buffer_overflow",
      "difficulty_level": "advanced",
      "risk_factors": [
        "system_crash",
        "memory_corruption",
        "buffer_overflow",
        "arbitrary_code_execution"
      ],
      "attack_vectors": [
        "memory_manipulation",
        "malicious_input",
        "code_analysis",
        "buffer_overflow",
        "reverse_engineering",
        "fuzzing"
      ],
      "mitigation_strategies": [
        "safe_string_functions",
        "dynamic_analysis",
        "code_review",
        "static_analysis",
        "memory_safety_checks",
        "input_validation",
        "fuzzing",
        "bounds_checking",
        "secure_coding_practices"
      ],
      "code_differences": {
        "has_differences": true,
        "source_lines": 2,
        "target_lines": 2,
        "character_differences": 2580,
        "similarity_percentage": 4.464285714285714
      },
      "vulnerability_location": {
        "vulnerability_present": true,
        "fix_applied": true,
        "code_changed": true,
        "estimated_lines_changed": 0
      }
    },
    {
      "cve_id": "CVE-2016-1621",
      "cwe_id": "CWE-119",
      "cwe_name": "Buffer Overflow",
      "project": "external",
      "severity": "critical",
      "weaponization_score": 8.5,
      "is_critical": true,
      "is_weaponizable": true,
      "is_high_priority_project": false,
      "vulnerable_code": "CWE-119 int main ( int argc , char * * argv ) { int frame_cnt = 0 ; FILE * outfile = NULL ; vpx_codec_ctx_t codec ; const VpxInterface * decoder = NULL ; VpxVideoReader * reader = NULL ; const VpxVideoInfo * info = NULL ; int n = 0 ; int m = 0 ; int is_range = 0 ; char * nptr = NULL ; exec_name = argv [ 0 ] ; if ( argc != 4 ) die ( \"Invalid<S2SV_blank>number<S2SV_blank>of<S2SV_blank>arguments.\" ) ; reader = vpx_video_reader_open ( argv [ 1 ] ) ; if ( ! reader ) die ( \"Failed<S2SV_blank>to<S2SV_blank>open<S2SV_blank>%s<S2SV_blank>for<S2SV_blank>reading.\" , argv [ 1 ] ) ; if ( ! ( outfile = fopen ( argv [ 2 ] , \"wb\" ) ) ) die ( \"Failed<S2SV_blank>to<S2SV_blank>open<S2SV_blank>%s<S2SV_blank>for<S2SV_blank>writing.\" , argv [ 2 ] ) ; n = strtol ( argv [ 3 ] , & nptr , 0 ) ; m = strtol ( nptr + 1 , NULL , 0 ) ; is_range = ( * nptr == '-' ) ; if ( ! n || ! m || ( * nptr != '-' && * nptr != '/' ) ) die ( \"Couldn\\'t<S2SV_blank>parse<S2SV_blank>pattern<S2SV_blank>%s.\\\\n\" , argv [ 3 ] ) ; info = vpx_video_reader_get_info ( reader ) ; decoder = get_vpx_decoder_by_fourcc ( info -> codec_fourcc ) ; if ( ! decoder ) die ( \"Unknown<S2SV_blank>input<S2SV_blank>codec.\" ) ; <S2SV_StartBug> printf ( \"Using<S2SV_blank>%s\\\\n\" , vpx_codec_iface_name ( decoder -> interface ( ) ) ) ; <S2SV_EndBug> <S2SV_StartBug> if ( vpx_codec_dec_init ( & codec , decoder -> interface ( ) , NULL , 0 ) ) <S2SV_EndBug> die_codec ( & codec , \"Failed<S2SV_blank>to<S2SV_blank>initialize<S2SV_blank>decoder.\" ) ; while ( vpx_video_reader_read_frame ( reader ) ) { vpx_codec_iter_t iter = NULL ; vpx_image_t * img = NULL ; size_t frame_size = 0 ; int skip ; const unsigned char * frame = vpx_video_reader_get_frame ( reader , & frame_size ) ; if ( vpx_codec_decode ( & codec , frame , ( unsigned int ) frame_size , NULL , 0 ) ) die_codec ( & codec , \"Failed<S2SV_blank>to<S2SV_blank>decode<S2SV_blank>frame.\" ) ; ++ frame_cnt ; skip = ( is_range && frame_cnt >= n && frame_cnt <= m ) || ( ! is_range && m - ( frame_cnt - 1 ) % m <= n ) ; if ( ! skip ) { putc ( '.' , stdout ) ; while ( ( img = vpx_codec_get_frame ( & codec , & iter ) ) != NULL ) vpx_img_write ( img , outfile ) ; } else { putc ( 'X' , stdout ) ; } fflush ( stdout ) ; } printf ( \"Processed<S2SV_blank>%d<S2SV_blank>frames.\\\\n\" , frame_cnt ) ; if ( vpx_codec_destroy ( & codec ) ) die_codec ( & codec , \"Failed<S2SV_blank>to<S2SV_blank>destroy<S2SV_blank>codec.\" ) ; printf ( \"Play:<S2SV_blank>ffplay<S2SV_blank>-f<S2SV_blank>rawvideo<S2SV_blank>-pix_fmt<S2SV_blank>yuv420p<S2SV_blank>-s<S2SV_blank>%dx%d<S2SV_blank>%s\\\\n\" , info -> frame_width , info -> frame_height , argv [ 2 ] ) ; vpx_video_reader_close ( reader ) ; fclose ( outfile ) ; return EXIT_SUCCESS ; }\n",
      "fixed_code": "<S2SV_ModStart> ( decoder -> codec_interface <S2SV_ModEnd> ( ) ) <S2SV_ModStart> , decoder -> codec_interface <S2SV_ModEnd> ( ) ,\n",
      "source_code_length": 2710,
      "target_code_length": 130,
      "vulnerability_patterns": {
        "buffer_overflow": 1,
        "integer_overflow": 3,
        "null_pointer": 38,
        "total": 42
      },
      "total_patterns": 42,
      "original_address": "https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426",
      "discovery_time": "2016-03-12T21:59Z",
      "project_commit_id": "external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426",
      "extraction_time": "2025-08-31T15:41:49.184149",
      "label": 1,
      "vulnerability_type": "buffer_overflow",
      "difficulty_level": "advanced",
      "risk_factors": [
        "system_crash",
        "memory_corruption",
        "buffer_overflow",
        "arbitrary_code_execution"
      ],
      "attack_vectors": [
        "memory_manipulation",
        "malicious_input",
        "code_analysis",
        "buffer_overflow",
        "reverse_engineering",
        "fuzzing"
      ],
      "mitigation_strategies": [
        "safe_string_functions",
        "dynamic_analysis",
        "code_review",
        "static_analysis",
        "memory_safety_checks",
        "input_validation",
        "fuzzing",
        "bounds_checking",
        "secure_coding_practices"
      ],
      "code_differences": {
        "has_differences": true,
        "source_lines": 2,
        "target_lines": 2,
        "character_differences": 2580,
        "similarity_percentage": 4.464285714285714
      },
      "vulnerability_location": {
        "vulnerability_present": true,
        "fix_applied": true,
        "code_changed": true,
        "estimated_lines_changed": 0
      }
    },
    {
      "cve_id": "CVE-2018-20762",
      "cwe_id": "CWE-119",
      "cwe_name": "Buffer Overflow",
      "project": "gpac",
      "severity": "critical",
      "weaponization_score": 8.5,
      "is_critical": true,
      "is_weaponizable": true,
      "is_high_priority_project": false,
      "vulnerable_code": "CWE-119 static Bool FFD_CanHandleURL ( GF_InputService * plug , const char * url ) { Bool has_audio , has_video ; s32 i ; AVFormatContext * ctx ; AVOutputFormat * fmt_out ; Bool ret = GF_FALSE ; <S2SV_StartBug> char * ext , szName [ 1000 ] , szExt [ 20 ] ; <S2SV_EndBug> const char * szExtList ; FFDemux * ffd ; if ( ! plug || ! url ) return GF_FALSE ; if ( ! strnicmp ( url , \"rtsp://\" , 7 ) ) return GF_FALSE ; if ( ! strnicmp ( url , \"rtspu://\" , 8 ) ) return GF_FALSE ; if ( ! strnicmp ( url , \"rtp://\" , 6 ) ) return GF_FALSE ; if ( ! strnicmp ( url , \"plato://\" , 8 ) ) return GF_FALSE ; if ( ! strnicmp ( url , \"udp://\" , 6 ) ) return GF_FALSE ; if ( ! strnicmp ( url , \"tcp://\" , 6 ) ) return GF_FALSE ; if ( ! strnicmp ( url , \"data:\" , 5 ) ) return GF_FALSE ; ffd = ( FFDemux * ) plug -> priv ; <S2SV_StartBug> strcpy ( szName , url ) ; <S2SV_EndBug> ext = strrchr ( szName , '#' ) ; if ( ext ) ext [ 0 ] = 0 ; ext = strrchr ( szName , '?' ) ; if ( ext ) ext [ 0 ] = 0 ; ext = strrchr ( szName , '.' ) ; if ( ext && strlen ( ext ) > 19 ) ext = NULL ; <S2SV_StartBug> if ( ext && strlen ( ext ) > 1 ) { <S2SV_EndBug> strcpy ( szExt , & ext [ 1 ] ) ; strlwr ( szExt ) ; # ifndef FFMPEG_DEMUX_ENABLE_MPEG2TS if ( strstr ( \"ts<S2SV_blank>m2t<S2SV_blank>mts<S2SV_blank>dmb<S2SV_blank>trp\" , szExt ) ) return GF_FALSE ; # endif if ( ! strcmp ( szExt , \"mp4\" ) || ! strcmp ( szExt , \"mpg4\" ) || ! strcmp ( szExt , \"m4a\" ) || ! strcmp ( szExt , \"m21\" ) || ! strcmp ( szExt , \"m4v\" ) || ! strcmp ( szExt , \"m4a\" ) || ! strcmp ( szExt , \"m4s\" ) || ! strcmp ( szExt , \"3gs\" ) || ! strcmp ( szExt , \"3gp\" ) || ! strcmp ( szExt , \"3gpp\" ) || ! strcmp ( szExt , \"3gp2\" ) || ! strcmp ( szExt , \"3g2\" ) || ! strcmp ( szExt , \"mp3\" ) || ! strcmp ( szExt , \"ac3\" ) || ! strcmp ( szExt , \"amr\" ) || ! strcmp ( szExt , \"bt\" ) || ! strcmp ( szExt , \"wrl\" ) || ! strcmp ( szExt , \"x3dv\" ) || ! strcmp ( szExt , \"xmt\" ) || ! strcmp ( szExt , \"xmta\" ) || ! strcmp ( szExt , \"x3d\" ) || ! strcmp ( szExt , \"jpg\" ) || ! strcmp ( szExt , \"jpeg\" ) || ! strcmp ( szExt , \"png\" ) ) return GF_FALSE ; { u32 i ; for ( i = 0 ; FFD_MIME_TYPES [ i ] ; i += 3 ) { if ( gf_service_check_mime_register ( plug , FFD_MIME_TYPES [ i ] , FFD_MIME_TYPES [ i + 1 ] , FFD_MIME_TYPES [ i + 2 ] , ext ) ) return GF_TRUE ; } } } ffd_parse_options ( ffd , url ) ; ctx = NULL ; if ( open_file ( & ctx , szName , NULL , ffd -> options ? & ffd -> options : NULL ) < 0 ) { AVInputFormat * av_in = NULL ; if ( ext && ! strcmp ( szExt , \"cmp\" ) ) av_in = av_find_input_format ( \"m4v\" ) ; if ( open_file ( & ctx , szName , av_in , ffd -> options ? & ffd -> options : NULL ) < 0 ) { return GF_FALSE ; } } if ( ! ctx ) goto exit ; if ( av_find_stream_info ( ctx ) < 0 ) goto exit ; has_video = has_audio = GF_FALSE ; for ( i = 0 ; i < ( s32 ) ctx -> nb_streams ; i ++ ) { AVCodecContext * enc = ctx -> streams [ i ] -> codec ; switch ( enc -> codec_type ) { case AVMEDIA_TYPE_AUDIO : if ( ! has_audio ) has_audio = GF_TRUE ; break ; case AVMEDIA_TYPE_VIDEO : if ( ! has_video ) has_video = GF_TRUE ; break ; default : break ; } } if ( ! has_audio && ! has_video ) goto exit ; ret = GF_TRUE ; # if ( ( LIBAVFORMAT_VERSION_MAJOR == 52 ) && ( LIBAVFORMAT_VERSION_MINOR <= 47 ) ) || ( LIBAVFORMAT_VERSION_MAJOR < 52 ) fmt_out = guess_stream_format ( NULL , url , NULL ) ; # else fmt_out = av_guess_format ( NULL , url , NULL ) ; # endif if ( fmt_out ) gf_service_register_mime ( plug , fmt_out -> mime_type , fmt_out -> extensions , fmt_out -> name ) ; else { ext = strrchr ( szName , '.' ) ; if ( ext ) { strcpy ( szExt , & ext [ 1 ] ) ; strlwr ( szExt ) ; szExtList = gf_modules_get_option ( ( GF_BaseInterface * ) plug , \"MimeTypes\" , \"application/x-ffmpeg\" ) ; if ( ! szExtList ) { gf_service_register_mime ( plug , \"application/x-ffmpeg\" , szExt , \"Other<S2SV_blank>Movies<S2SV_blank>(FFMPEG)\" ) ; } else if ( ! strstr ( szExtList , szExt ) ) { u32 len ; char * buf ; len = ( u32 ) ( strlen ( szExtList ) + strlen ( szExt ) + 10 ) ; buf = ( char * ) gf_malloc ( sizeof ( char ) * len ) ; sprintf ( buf , \"\\\\\"%s<S2SV_blank>\" , szExt ) ; strcat ( buf , & szExtList [ 1 ] ) ; gf_modules_set_option ( ( GF_BaseInterface * ) plug , \"MimeTypes\" , \"application/x-ffmpeg\" , buf ) ; gf_free ( buf ) ; } } } exit : # if FF_API_CLOSE_INPUT_FILE if ( ctx ) av_close_input_file ( ctx ) ; # else if ( ctx ) avformat_close_input ( & ctx ) ; # endif return ret ; }\n",
      "fixed_code": "<S2SV_ModStart> , szName [ 1024 <S2SV_ModEnd> ] , szExt <S2SV_ModStart> -> priv ; if ( strlen ( url ) >= sizeof ( szName ) ) return GF_FALSE ; <S2SV_ModStart> ) > 1 && strlen ( ext ) <= sizeof ( szExt )\n",
      "source_code_length": 4401,
      "target_code_length": 203,
      "vulnerability_patterns": {
        "buffer_overflow": 5,
        "integer_overflow": 2,
        "format_string": 1,
        "null_pointer": 20,
        "total": 28
      },
      "total_patterns": 28,
      "original_address": "https://github.com/gpac/gpac/commit/35ab4475a7df9b2a4bcab235e379c0c3ec543658",
      "discovery_time": "2019-02-06T23:29Z",
      "project_commit_id": "gpac@gpac/35ab4475a7df9b2a4bcab235e379c0c3ec543658",
      "extraction_time": "2025-08-31T15:41:49.184180",
      "label": 1,
      "vulnerability_type": "buffer_overflow",
      "difficulty_level": "advanced",
      "risk_factors": [
        "system_crash",
        "memory_corruption",
        "buffer_overflow",
        "arbitrary_code_execution"
      ],
      "attack_vectors": [
        "memory_manipulation",
        "malicious_input",
        "code_analysis",
        "buffer_overflow",
        "reverse_engineering",
        "fuzzing"
      ],
      "mitigation_strategies": [
        "safe_string_functions",
        "dynamic_analysis",
        "code_review",
        "static_analysis",
        "memory_safety_checks",
        "input_validation",
        "fuzzing",
        "bounds_checking",
        "secure_coding_practices"
      ],
      "code_differences": {
        "has_differences": true,
        "source_lines": 2,
        "target_lines": 2,
        "character_differences": 4198,
        "similarity_percentage": 12.280701754385964
      },
      "vulnerability_location": {
        "vulnerability_present": true,
        "fix_applied": true,
        "code_changed": true,
        "estimated_lines_changed": 0
      }
    },
    {
      "cve_id": "CVE-2016-3820",
      "cwe_id": "CWE-119",
      "cwe_name": "Buffer Overflow",
      "project": "external",
      "severity": "critical",
      "weaponization_score": 8.5,
      "is_critical": true,
      "is_weaponizable": true,
      "is_high_priority_project": false,
      "vulnerable_code": "CWE-119 WORD32 ih264d_parse_nal_unit ( iv_obj_t * dec_hdl , ivd_video_decode_op_t * ps_dec_op , UWORD8 * pu1_buf , UWORD32 u4_length ) { dec_bit_stream_t * ps_bitstrm ; dec_struct_t * ps_dec = ( dec_struct_t * ) dec_hdl -> pv_codec_handle ; ivd_video_decode_ip_t * ps_dec_in = ( ivd_video_decode_ip_t * ) ps_dec -> pv_dec_in ; dec_slice_params_t * ps_cur_slice = ps_dec -> ps_cur_slice ; UWORD8 u1_first_byte , u1_nal_ref_idc ; UWORD8 u1_nal_unit_type ; WORD32 i_status = OK ; ps_bitstrm = ps_dec -> ps_bitstrm ; if ( pu1_buf ) { if ( u4_length ) { ps_dec_op -> u4_frame_decoded_flag = 0 ; ih264d_process_nal_unit ( ps_dec -> ps_bitstrm , pu1_buf , u4_length ) ; SWITCHOFFTRACE ; u1_first_byte = ih264d_get_bits_h264 ( ps_bitstrm , 8 ) ; if ( NAL_FORBIDDEN_BIT ( u1_first_byte ) ) { H264_DEC_DEBUG_PRINT ( \"\\\\nForbidden<S2SV_blank>bit<S2SV_blank>set<S2SV_blank>in<S2SV_blank>Nal<S2SV_blank>Unit,<S2SV_blank>Let\\'s<S2SV_blank>try\\\\n\" ) ; } <S2SV_StartBug> u1_nal_unit_type = NAL_UNIT_TYPE ( u1_first_byte ) ; <S2SV_EndBug> ps_dec -> u1_nal_unit_type = u1_nal_unit_type ; u1_nal_ref_idc = ( UWORD8 ) ( NAL_REF_IDC ( u1_first_byte ) ) ; switch ( u1_nal_unit_type ) { case SLICE_DATA_PARTITION_A_NAL : case SLICE_DATA_PARTITION_B_NAL : case SLICE_DATA_PARTITION_C_NAL : if ( ! ps_dec -> i4_decode_header ) ih264d_parse_slice_partition ( ps_dec , ps_bitstrm ) ; break ; case IDR_SLICE_NAL : case SLICE_NAL : DEBUG_THREADS_PRINTF ( \"Decoding<S2SV_blank><S2SV_blank>a<S2SV_blank>slice<S2SV_blank>NAL\\\\n\" ) ; if ( ! ps_dec -> i4_decode_header ) { if ( ps_dec -> i4_header_decoded == 3 ) { ps_dec -> u4_slice_start_code_found = 1 ; ih264d_rbsp_to_sodb ( ps_dec -> ps_bitstrm ) ; i_status = ih264d_parse_decode_slice ( ( UWORD8 ) ( u1_nal_unit_type == IDR_SLICE_NAL ) , u1_nal_ref_idc , ps_dec ) ; if ( ( ps_dec -> u4_first_slice_in_pic != 0 ) && ( ( ps_dec -> ps_dec_err_status -> u1_err_flag & REJECT_CUR_PIC ) == 0 ) ) { ps_dec -> u4_first_slice_in_pic = 1 ; } if ( i_status != OK ) { return i_status ; } } else { H264_DEC_DEBUG_PRINT ( \"\\\\nSlice<S2SV_blank>NAL<S2SV_blank>Supplied<S2SV_blank>but<S2SV_blank>no<S2SV_blank>header<S2SV_blank>has<S2SV_blank>been<S2SV_blank>supplied\\\\n\" ) ; } } break ; case SEI_NAL : if ( ! ps_dec -> i4_decode_header ) { ih264d_rbsp_to_sodb ( ps_dec -> ps_bitstrm ) ; i_status = ih264d_parse_sei_message ( ps_dec , ps_bitstrm ) ; if ( i_status != OK ) return i_status ; ih264d_parse_sei ( ps_dec , ps_bitstrm ) ; } break ; case SEQ_PARAM_NAL : ih264d_rbsp_to_sodb ( ps_dec -> ps_bitstrm ) ; i_status = ih264d_parse_sps ( ps_dec , ps_bitstrm ) ; if ( i_status == ERROR_INV_SPS_PPS_T ) return i_status ; if ( ! i_status ) ps_dec -> i4_header_decoded |= 0x1 ; break ; case PIC_PARAM_NAL : ih264d_rbsp_to_sodb ( ps_dec -> ps_bitstrm ) ; i_status = ih264d_parse_pps ( ps_dec , ps_bitstrm ) ; if ( i_status == ERROR_INV_SPS_PPS_T ) return i_status ; if ( ! i_status ) ps_dec -> i4_header_decoded |= 0x2 ; break ; case ACCESS_UNIT_DELIMITER_RBSP : if ( ! ps_dec -> i4_decode_header ) { ih264d_access_unit_delimiter_rbsp ( ps_dec ) ; } break ; case END_OF_STREAM_RBSP : if ( ! ps_dec -> i4_decode_header ) { ih264d_parse_end_of_stream ( ps_dec ) ; } break ; case FILLER_DATA_NAL : if ( ! ps_dec -> i4_decode_header ) { ih264d_parse_filler_data ( ps_dec , ps_bitstrm ) ; } break ; default : H264_DEC_DEBUG_PRINT ( \"\\\\nUnknown<S2SV_blank>NAL<S2SV_blank>type<S2SV_blank>%d\\\\n\" , u1_nal_unit_type ) ; break ; } } } return i_status ; }\n",
      "fixed_code": "<S2SV_ModStart> u1_first_byte ) ; if ( ( ps_dec -> u2_total_mbs_coded != 0 ) && ( u1_nal_unit_type > IDR_SLICE_NAL ) ) { return ERROR_INCOMPLETE_FRAME ; }\n",
      "source_code_length": 3448,
      "target_code_length": 155,
      "vulnerability_patterns": {
        "buffer_overflow": 5,
        "integer_overflow": 21,
        "null_pointer": 337,
        "total": 363
      },
      "total_patterns": 363,
      "original_address": "https://android.googlesource.com/platform/external/libavc/+/a78887bcffbc2995cf9ed72e0697acf560875e9e",
      "discovery_time": "2016-08-05T20:59Z",
      "project_commit_id": "external@libavc/a78887bcffbc2995cf9ed72e0697acf560875e9e",
      "extraction_time": "2025-08-31T15:41:49.184230",
      "label": 1,
      "vulnerability_type": "buffer_overflow",
      "difficulty_level": "advanced",
      "risk_factors": [
        "system_crash",
        "memory_corruption",
        "buffer_overflow",
        "arbitrary_code_execution"
      ],
      "attack_vectors": [
        "memory_manipulation",
        "malicious_input",
        "code_analysis",
        "buffer_overflow",
        "reverse_engineering",
        "fuzzing"
      ],
      "mitigation_strategies": [
        "safe_string_functions",
        "dynamic_analysis",
        "code_review",
        "static_analysis",
        "memory_safety_checks",
        "input_validation",
        "fuzzing",
        "bounds_checking",
        "secure_coding_practices"
      ],
      "code_differences": {
        "has_differences": true,
        "source_lines": 2,
        "target_lines": 2,
        "character_differences": 3293,
        "similarity_percentage": 14.563106796116504
      },
      "vulnerability_location": {
        "vulnerability_present": true,
        "fix_applied": true,
        "code_changed": true,
        "estimated_lines_changed": 0
      }
    },
    {
      "cve_id": "CVE-2015-3905",
      "cwe_id": "CWE-119",
      "cwe_name": "Buffer Overflow",
      "project": "kohler",
      "severity": "critical",
      "weaponization_score": 8.5,
      "is_critical": true,
      "is_weaponizable": true,
      "is_high_priority_project": false,
      "vulnerable_code": "CWE-119 int main ( int argc , char * argv [ ] ) { int i , c ; FILE * ifp = 0 , * ofp = 0 ; const char * ifp_filename = \"<stdin>\" ; const char * ofp_filename = \"<stdout>\" ; const char * set_font_name = 0 ; struct font_reader fr ; uint32_t rfork_len ; int raw = 0 , macbinary = 1 , applesingle = 0 , appledouble = 0 , binhex = 0 ; Clp_Parser * clp = Clp_NewParser ( argc , ( const char * const * ) argv , sizeof ( options ) / sizeof ( options [ 0 ] ) , options ) ; program_name = Clp_ProgramName ( clp ) ; while ( 1 ) { int opt = Clp_Next ( clp ) ; switch ( opt ) { case RAW_OPT : raw = 1 ; macbinary = applesingle = appledouble = binhex = 0 ; break ; case MACBINARY_OPT : macbinary = 1 ; raw = applesingle = appledouble = binhex = 0 ; break ; case APPLESINGLE_OPT : applesingle = 1 ; raw = macbinary = appledouble = binhex = 0 ; break ; case APPLEDOUBLE_OPT : appledouble = 1 ; raw = macbinary = applesingle = binhex = 0 ; break ; case BINHEX_OPT : binhex = 1 ; raw = macbinary = applesingle = appledouble = 0 ; break ; output_file : case OUTPUT_OPT : if ( ofp ) fatal_error ( \"output<S2SV_blank>file<S2SV_blank>already<S2SV_blank>specified\" ) ; if ( strcmp ( clp -> vstr , \"-\" ) == 0 ) ofp = stdout ; else { ofp_filename = clp -> vstr ; ofp = fopen ( ofp_filename , \"wb\" ) ; if ( ! ofp ) fatal_error ( \"%s:<S2SV_blank>%s\" , ofp_filename , strerror ( errno ) ) ; } break ; case FILENAME_OPT : if ( set_font_name ) fatal_error ( \"Macintosh<S2SV_blank>font<S2SV_blank>filename<S2SV_blank>already<S2SV_blank>specified\" ) ; set_font_name = clp -> vstr ; break ; case HELP_OPT : usage ( ) ; exit ( 0 ) ; break ; case VERSION_OPT : printf ( \"t1mac<S2SV_blank>(LCDF<S2SV_blank>t1utils)<S2SV_blank>%s\\\\n\" , VERSION ) ; <S2SV_StartBug> printf ( \"Copyright<S2SV_blank>(C)<S2SV_blank>2000-2010<S2SV_blank>Eddie<S2SV_blank>Kohler<S2SV_blank>et<S2SV_blank>al.\\\\n\\\\\\n<S2SV_blank>This<S2SV_blank>is<S2SV_blank>free<S2SV_blank>software;<S2SV_blank>see<S2SV_blank>the<S2SV_blank>source<S2SV_blank>for<S2SV_blank>copying<S2SV_blank>conditions.\\\\n\\\\\\n<S2SV_blank>There<S2SV_blank>is<S2SV_blank>NO<S2SV_blank>warranty,<S2SV_blank>not<S2SV_blank>even<S2SV_blank>for<S2SV_blank>merchantability<S2SV_blank>or<S2SV_blank>fitness<S2SV_blank>for<S2SV_blank>a\\\\n\\\\\\n<S2SV_blank>particular<S2SV_blank>purpose.\\\\n\" ) ; <S2SV_EndBug> exit ( 0 ) ; break ; case Clp_NotOption : if ( ifp && ofp ) fatal_error ( \"too<S2SV_blank>many<S2SV_blank>arguments\" ) ; else if ( ifp ) goto output_file ; if ( strcmp ( clp -> vstr , \"-\" ) == 0 ) ifp = stdin ; else { ifp_filename = clp -> vstr ; ifp = fopen ( clp -> vstr , \"r\" ) ; if ( ! ifp ) fatal_error ( \"%s:<S2SV_blank>%s\" , clp -> vstr , strerror ( errno ) ) ; } break ; case Clp_Done : goto done ; case Clp_BadOption : short_usage ( ) ; exit ( 1 ) ; break ; } } done : if ( ! ifp ) ifp = stdin ; if ( ! ofp ) ofp = stdout ; # if defined ( _MSDOS ) || defined ( _WIN32 ) _setmode ( _fileno ( ofp ) , _O_BINARY ) ; # endif fr . output_ascii = t1mac_output_ascii ; fr . output_binary = t1mac_output_binary ; fr . output_end = t1mac_output_end ; rfork_f = tmpfile ( ) ; if ( ! rfork_f ) fatal_error ( \"cannot<S2SV_blank>open<S2SV_blank>temorary<S2SV_blank>file:<S2SV_blank>%s\" , strerror ( errno ) ) ; for ( i = 0 ; i < RFORK_HEADERLEN ; i ++ ) putc ( 0 , rfork_f ) ; init_current_post ( ) ; c = getc ( ifp ) ; ungetc ( c , ifp ) ; if ( c == PFB_MARKER ) process_pfb ( ifp , ifp_filename , & fr ) ; else if ( c == '%' ) process_pfa ( ifp , ifp_filename , & fr ) ; else fatal_error ( \"%s<S2SV_blank>does<S2SV_blank>not<S2SV_blank>start<S2SV_blank>with<S2SV_blank>font<S2SV_blank>marker<S2SV_blank>(`%%\\'<S2SV_blank>or<S2SV_blank>0x80)\" , ifp_filename ) ; if ( ifp != stdin ) fclose ( ifp ) ; if ( nrsrc == 0 ) error ( \"no<S2SV_blank>POST<S2SV_blank>resources<S2SV_blank>written<S2SV_blank>--<S2SV_blank>are<S2SV_blank>you<S2SV_blank>sure<S2SV_blank>this<S2SV_blank>was<S2SV_blank>a<S2SV_blank>font?\" ) ; output_new_rsrc ( \"ICN#\" , 256 , 32 , ( const char * ) icon_bw_data , 256 ) ; output_new_rsrc ( \"FREF\" , 256 , 32 , \"LWFN\\\\0\\\\0\\\\0\" , 7 ) ; output_new_rsrc ( \"BNDL\" , 256 , 32 , \"T1UT\\\\0\\\\0\\\\0\\\\1FREF\\\\0\\\\0\\\\0\\\\0\\\\1\\\\0ICN#\\\\0\\\\0\\\\0\\\\0\\\\1\\\\0\" , 28 ) ; output_new_rsrc ( \"icl8\" , 256 , 32 , ( const char * ) icon_8_data , 1024 ) ; output_new_rsrc ( \"icl4\" , 256 , 32 , ( const char * ) icon_4_data , 512 ) ; output_new_rsrc ( \"ics#\" , 256 , 32 , ( const char * ) small_icon_bw_data , 64 ) ; output_new_rsrc ( \"ics8\" , 256 , 32 , ( const char * ) small_icon_8_data , 256 ) ; output_new_rsrc ( \"ics4\" , 256 , 32 , ( const char * ) small_icon_4_data , 128 ) ; output_new_rsrc ( \"T1UT\" , 0 , 0 , \"DConverted<S2SV_blank>by<S2SV_blank>t1mac<S2SV_blank>(t1utils)<S2SV_blank>\\\\251Eddie<S2SV_blank>Kohler<S2SV_blank>http://www.lcdf.org/type/\" , 69 ) ; rfork_len = complete_rfork ( ) ; if ( ! set_font_name && font_name ) { int part = 0 , len = 0 ; char * x , * s ; for ( x = s = font_name ; * s ; s ++ ) <S2SV_StartBug> if ( isupper ( * s ) || isdigit ( * s ) ) { <S2SV_EndBug> * x ++ = * s ; part ++ ; len = 1 ; <S2SV_StartBug> } else if ( islower ( * s ) ) { <S2SV_EndBug> if ( len < ( part <= 1 ? 5 : 3 ) ) * x ++ = * s ; len ++ ; } * x ++ = 0 ; set_font_name = font_name ; } else if ( ! set_font_name ) set_font_name = \"Unknown<S2SV_blank>Font\" ; if ( macbinary ) output_macbinary ( rfork_f , rfork_len , set_font_name , ofp ) ; else if ( raw ) output_raw ( rfork_f , rfork_len , ofp ) ; else if ( applesingle || appledouble ) output_applesingle ( rfork_f , rfork_len , set_font_name , ofp , appledouble ) ; else if ( binhex ) output_binhex ( rfork_f , rfork_len , set_font_name , ofp ) ; else fatal_error ( \"strange<S2SV_blank>output<S2SV_blank>format\" ) ; fclose ( rfork_f ) ; if ( ofp != stdout ) fclose ( ofp ) ; return 0 ; }\n",
      "fixed_code": "<S2SV_ModStart> ; printf ( \"Copyright<S2SV_blank>(C)<S2SV_blank>2000-2010<S2SV_blank>Eddie<S2SV_blank>Kohler<S2SV_blank>et<S2SV_blank>al.\\\\n\\\\\\nThis<S2SV_blank>is<S2SV_blank>free<S2SV_blank>software;<S2SV_blank>see<S2SV_blank>the<S2SV_blank>source<S2SV_blank>for<S2SV_blank>copying<S2SV_blank>conditions.\\\\n\\\\\\nThere<S2SV_blank>is<S2SV_blank>NO<S2SV_blank>warranty,<S2SV_blank>not<S2SV_blank>even<S2SV_blank>for<S2SV_blank>merchantability<S2SV_blank>or<S2SV_blank>fitness<S2SV_blank>for<S2SV_blank>a\\\\n\\\\\\nparticular<S2SV_blank>purpose.\\\\n\" <S2SV_ModEnd> ) ; exit <S2SV_ModStart> ( isupper ( ( unsigned char ) <S2SV_ModStart> || isdigit ( ( unsigned char ) <S2SV_ModStart> ( islower ( ( unsigned char )\n",
      "source_code_length": 5733,
      "target_code_length": 703,
      "vulnerability_patterns": {
        "buffer_overflow": 1,
        "integer_overflow": 7,
        "null_pointer": 6,
        "total": 14
      },
      "total_patterns": 14,
      "original_address": "https://github.com/kohler/t1utils/commit/6b9d1aafcb61a3663c883663eb19ccdbfcde8d33",
      "discovery_time": "2015-06-08T14:59Z",
      "project_commit_id": "kohler@t1utils/6b9d1aafcb61a3663c883663eb19ccdbfcde8d33",
      "extraction_time": "2025-08-31T15:41:49.184263",
      "label": 1,
      "vulnerability_type": "buffer_overflow",
      "difficulty_level": "advanced",
      "risk_factors": [
        "system_crash",
        "memory_corruption",
        "buffer_overflow",
        "arbitrary_code_execution"
      ],
      "attack_vectors": [
        "memory_manipulation",
        "malicious_input",
        "code_analysis",
        "buffer_overflow",
        "reverse_engineering",
        "fuzzing"
      ],
      "mitigation_strategies": [
        "safe_string_functions",
        "dynamic_analysis",
        "code_review",
        "static_analysis",
        "memory_safety_checks",
        "input_validation",
        "fuzzing",
        "bounds_checking",
        "secure_coding_practices"
      ],
      "code_differences": {
        "has_differences": true,
        "source_lines": 2,
        "target_lines": 2,
        "character_differences": 5030,
        "similarity_percentage": 5.291005291005291
      },
      "vulnerability_location": {
        "vulnerability_present": true,
        "fix_applied": true,
        "code_changed": true,
        "estimated_lines_changed": 0
      }
    },
    {
      "cve_id": "CVE-2016-4804",
      "cwe_id": "CWE-119",
      "cwe_name": "Buffer Overflow",
      "project": "dosfstools",
      "severity": "critical",
      "weaponization_score": 8.5,
      "is_critical": true,
      "is_weaponizable": true,
      "is_high_priority_project": false,
      "vulnerable_code": "CWE-119 static void dump_boot ( DOS_FS * fs , struct boot_sector * b , unsigned lss ) { unsigned short sectors ; printf ( \"Boot<S2SV_blank>sector<S2SV_blank>contents:\\\\n\" ) ; if ( ! atari_format ) { char id [ 9 ] ; strncpy ( id , ( const char * ) b -> system_id , 8 ) ; id [ 8 ] = 0 ; printf ( \"System<S2SV_blank>ID<S2SV_blank>\\\\\"%s\\\\\"\\\\n\" , id ) ; } else { printf ( \"Serial<S2SV_blank>number<S2SV_blank>0x%x\\\\n\" , b -> system_id [ 5 ] | ( b -> system_id [ 6 ] << 8 ) | ( b -> system_id [ 7 ] << 16 ) ) ; } printf ( \"Media<S2SV_blank>byte<S2SV_blank>0x%02x<S2SV_blank>(%s)\\\\n\" , b -> media , get_media_descr ( b -> media ) ) ; printf ( \"%10d<S2SV_blank>bytes<S2SV_blank>per<S2SV_blank>logical<S2SV_blank>sector\\\\n\" , GET_UNALIGNED_W ( b -> sector_size ) ) ; printf ( \"%10d<S2SV_blank>bytes<S2SV_blank>per<S2SV_blank>cluster\\\\n\" , fs -> cluster_size ) ; printf ( \"%10d<S2SV_blank>reserved<S2SV_blank>sector%s\\\\n\" , le16toh ( b -> reserved ) , le16toh ( b -> reserved ) == 1 ? \"\" : \"s\" ) ; printf ( \"First<S2SV_blank>FAT<S2SV_blank>starts<S2SV_blank>at<S2SV_blank>byte<S2SV_blank>%llu<S2SV_blank>(sector<S2SV_blank>%llu)\\\\n\" , ( unsigned long long ) fs -> fat_start , ( unsigned long long ) fs -> fat_start / lss ) ; printf ( \"%10d<S2SV_blank>FATs,<S2SV_blank>%d<S2SV_blank>bit<S2SV_blank>entries\\\\n\" , b -> fats , fs -> fat_bits ) ; <S2SV_StartBug> printf ( \"%10d<S2SV_blank>bytes<S2SV_blank>per<S2SV_blank>FAT<S2SV_blank>(=<S2SV_blank>%u<S2SV_blank>sectors)\\\\n\" , fs -> fat_size , <S2SV_EndBug> <S2SV_StartBug> fs -> fat_size / lss ) ; <S2SV_EndBug> if ( ! fs -> root_cluster ) { printf ( \"Root<S2SV_blank>directory<S2SV_blank>starts<S2SV_blank>at<S2SV_blank>byte<S2SV_blank>%llu<S2SV_blank>(sector<S2SV_blank>%llu)\\\\n\" , ( unsigned long long ) fs -> root_start , ( unsigned long long ) fs -> root_start / lss ) ; printf ( \"%10d<S2SV_blank>root<S2SV_blank>directory<S2SV_blank>entries\\\\n\" , fs -> root_entries ) ; } else { printf ( \"Root<S2SV_blank>directory<S2SV_blank>start<S2SV_blank>at<S2SV_blank>cluster<S2SV_blank>%lu<S2SV_blank>(arbitrary<S2SV_blank>size)\\\\n\" , ( unsigned long ) fs -> root_cluster ) ; } printf ( \"Data<S2SV_blank>area<S2SV_blank>starts<S2SV_blank>at<S2SV_blank>byte<S2SV_blank>%llu<S2SV_blank>(sector<S2SV_blank>%llu)\\\\n\" , ( unsigned long long ) fs -> data_start , ( unsigned long long ) fs -> data_start / lss ) ; printf ( \"%10lu<S2SV_blank>data<S2SV_blank>clusters<S2SV_blank>(%llu<S2SV_blank>bytes)\\\\n\" , ( unsigned long ) fs -> data_clusters , ( unsigned long long ) fs -> data_clusters * fs -> cluster_size ) ; printf ( \"%u<S2SV_blank>sectors/track,<S2SV_blank>%u<S2SV_blank>heads\\\\n\" , le16toh ( b -> secs_track ) , le16toh ( b -> heads ) ) ; printf ( \"%10u<S2SV_blank>hidden<S2SV_blank>sectors\\\\n\" , atari_format ? ( ( ( unsigned char * ) & b -> hidden ) [ 0 ] | ( ( unsigned char * ) & b -> hidden ) [ 1 ] << 8 ) : le32toh ( b -> hidden ) ) ; sectors = GET_UNALIGNED_W ( b -> sectors ) ; printf ( \"%10u<S2SV_blank>sectors<S2SV_blank>total\\\\n\" , sectors ? sectors : le32toh ( b -> total_sect ) ) ; }\n",
      "fixed_code": "<S2SV_ModStart> ; printf ( \"%10lld<S2SV_blank>bytes<S2SV_blank>per<S2SV_blank>FAT<S2SV_blank>(=<S2SV_blank>%llu<S2SV_blank>sectors)\\\\n\" , ( long long ) <S2SV_ModEnd> fs -> fat_size <S2SV_ModStart> -> fat_size , ( long long )\n",
      "source_code_length": 3033,
      "target_code_length": 225,
      "vulnerability_patterns": {
        "buffer_overflow": 1,
        "format_string": 18,
        "null_pointer": 35,
        "total": 54
      },
      "total_patterns": 54,
      "original_address": "https://github.com/dosfstools/dosfstools/commit/e8eff147e9da1185f9afd5b25948153a3b97cf52",
      "discovery_time": "2016-06-03T14:59Z",
      "project_commit_id": "dosfstools@dosfstools/e8eff147e9da1185f9afd5b25948153a3b97cf52",
      "extraction_time": "2025-08-31T15:41:49.184324",
      "label": 1,
      "vulnerability_type": "buffer_overflow",
      "difficulty_level": "advanced",
      "risk_factors": [
        "system_crash",
        "memory_corruption",
        "buffer_overflow",
        "arbitrary_code_execution"
      ],
      "attack_vectors": [
        "memory_manipulation",
        "malicious_input",
        "code_analysis",
        "buffer_overflow",
        "reverse_engineering",
        "fuzzing"
      ],
      "mitigation_strategies": [
        "safe_string_functions",
        "dynamic_analysis",
        "code_review",
        "static_analysis",
        "memory_safety_checks",
        "input_validation",
        "fuzzing",
        "bounds_checking",
        "secure_coding_practices"
      ],
      "code_differences": {
        "has_differences": true,
        "source_lines": 2,
        "target_lines": 2,
        "character_differences": 2808,
        "similarity_percentage": 9.375
      },
      "vulnerability_location": {
        "vulnerability_present": true,
        "fix_applied": true,
        "code_changed": true,
        "estimated_lines_changed": 0
      }
    },
    {
      "cve_id": "CVE-2014-0069",
      "cwe_id": "CWE-119",
      "cwe_name": "Buffer Overflow",
      "project": "torvalds",
      "severity": "critical",
      "weaponization_score": 8.5,
      "is_critical": true,
      "is_weaponizable": true,
      "is_high_priority_project": false,
      "vulnerable_code": "CWE-119 static ssize_t cifs_iovec_write ( struct file * file , const struct iovec * iov , unsigned long nr_segs , loff_t * poffset ) { unsigned long nr_pages , i ; <S2SV_StartBug> size_t copied , len , cur_len ; <S2SV_EndBug> ssize_t total_written = 0 ; loff_t offset ; struct iov_iter it ; struct cifsFileInfo * open_file ; struct cifs_tcon * tcon ; struct cifs_sb_info * cifs_sb ; struct cifs_writedata * wdata , * tmp ; struct list_head wdata_list ; int rc ; pid_t pid ; len = iov_length ( iov , nr_segs ) ; if ( ! len ) return 0 ; rc = generic_write_checks ( file , poffset , & len , 0 ) ; if ( rc ) return rc ; INIT_LIST_HEAD ( & wdata_list ) ; cifs_sb = CIFS_SB ( file -> f_path . dentry -> d_sb ) ; open_file = file -> private_data ; tcon = tlink_tcon ( open_file -> tlink ) ; if ( ! tcon -> ses -> server -> ops -> async_writev ) return - ENOSYS ; offset = * poffset ; if ( cifs_sb -> mnt_cifs_flags & CIFS_MOUNT_RWPIDFORWARD ) pid = open_file -> pid ; else pid = current -> tgid ; iov_iter_init ( & it , iov , nr_segs , len , 0 ) ; do { size_t save_len ; nr_pages = get_numpages ( cifs_sb -> wsize , len , & cur_len ) ; wdata = cifs_writedata_alloc ( nr_pages , cifs_uncached_writev_complete ) ; if ( ! wdata ) { rc = - ENOMEM ; break ; } rc = cifs_write_allocate_pages ( wdata -> pages , nr_pages ) ; if ( rc ) { kfree ( wdata ) ; break ; } save_len = cur_len ; for ( i = 0 ; i < nr_pages ; i ++ ) { <S2SV_StartBug> copied = min_t ( const size_t , cur_len , PAGE_SIZE ) ; <S2SV_EndBug> copied = iov_iter_copy_from_user ( wdata -> pages [ i ] , & it , <S2SV_StartBug> 0 , copied ) ; <S2SV_EndBug> cur_len -= copied ; iov_iter_advance ( & it , copied ) ; <S2SV_StartBug> } <S2SV_EndBug> <S2SV_StartBug> cur_len = save_len - cur_len ; <S2SV_EndBug> wdata -> sync_mode = WB_SYNC_ALL ; wdata -> nr_pages = nr_pages ; wdata -> offset = ( __u64 ) offset ; wdata -> cfile = cifsFileInfo_get ( open_file ) ; wdata -> pid = pid ; wdata -> bytes = cur_len ; wdata -> pagesz = PAGE_SIZE ; wdata -> tailsz = cur_len - ( ( nr_pages - 1 ) * PAGE_SIZE ) ; rc = cifs_uncached_retry_writev ( wdata ) ; if ( rc ) { kref_put ( & wdata -> refcount , cifs_uncached_writedata_release ) ; break ; } list_add_tail ( & wdata -> list , & wdata_list ) ; offset += cur_len ; len -= cur_len ; } while ( len > 0 ) ; if ( ! list_empty ( & wdata_list ) ) rc = 0 ; restart_loop : list_for_each_entry_safe ( wdata , tmp , & wdata_list , list ) { if ( ! rc ) { rc = wait_for_completion_killable ( & wdata -> done ) ; if ( rc ) rc = - EINTR ; else if ( wdata -> result ) rc = wdata -> result ; else total_written += wdata -> bytes ; if ( rc == - EAGAIN ) { rc = cifs_uncached_retry_writev ( wdata ) ; goto restart_loop ; } } list_del_init ( & wdata -> list ) ; kref_put ( & wdata -> refcount , cifs_uncached_writedata_release ) ; } if ( total_written > 0 ) * poffset += total_written ; cifs_stats_bytes_written ( tcon , total_written ) ; return total_written ? total_written : ( ssize_t ) rc ; }\n",
      "fixed_code": "<S2SV_ModStart> i ; size_t bytes , <S2SV_ModStart> ++ ) { bytes <S2SV_ModEnd> = min_t ( <S2SV_ModStart> , 0 , bytes <S2SV_ModEnd> ) ; cur_len <S2SV_ModStart> copied ) ; if ( copied < bytes ) break ; <S2SV_ModStart> save_len - cur_len ; if ( ! cur_len ) { for ( i = 0 ; i < nr_pages ; i ++ ) put_page ( wdata -> pages [ i ] ) ; kfree ( wdata ) ; rc = - EFAULT ; break ; } for ( ; nr_pages > i + 1 ; nr_pages -- ) put_page ( wdata -> pages [ nr_pages - 1 ] )\n",
      "source_code_length": 2969,
      "target_code_length": 457,
      "vulnerability_patterns": {
        "use_after_free": 1,
        "integer_overflow": 6,
        "null_pointer": 36,
        "total": 43
      },
      "total_patterns": 43,
      "original_address": "https://github.com/torvalds/linux/commit/5d81de8e8667da7135d3a32a964087c0faf5483f",
      "discovery_time": "2014-02-28T06:18Z",
      "project_commit_id": "torvalds@linux/5d81de8e8667da7135d3a32a964087c0faf5483f",
      "extraction_time": "2025-08-31T15:41:49.184363",
      "label": 1,
      "vulnerability_type": "buffer_overflow",
      "difficulty_level": "advanced",
      "risk_factors": [
        "system_crash",
        "memory_corruption",
        "arbitrary_code_execution",
        "use_after_free"
      ],
      "attack_vectors": [
        "memory_manipulation",
        "malicious_input",
        "code_analysis",
        "buffer_overflow",
        "reverse_engineering",
        "fuzzing"
      ],
      "mitigation_strategies": [
        "safe_string_functions",
        "dynamic_analysis",
        "code_review",
        "static_analysis",
        "memory_safety_checks",
        "input_validation",
        "fuzzing",
        "bounds_checking",
        "secure_coding_practices"
      ],
      "code_differences": {
        "has_differences": true,
        "source_lines": 2,
        "target_lines": 2,
        "character_differences": 2512,
        "similarity_percentage": 23.357664233576642
      },
      "vulnerability_location": {
        "vulnerability_present": true,
        "fix_applied": true,
        "code_changed": true,
        "estimated_lines_changed": 0
      }
    },
    {
      "cve_id": "CVE-2013-4263",
      "cwe_id": "CWE-119",
      "cwe_name": "Buffer Overflow",
      "project": "FFmpeg",
      "severity": "critical",
      "weaponization_score": 8.4,
      "is_critical": true,
      "is_weaponizable": true,
      "is_high_priority_project": true,
      "vulnerable_code": "CWE-119 static int filter_frame ( AVFilterLink * inlink , AVFrame * inpic ) { KerndeintContext * kerndeint = inlink -> dst -> priv ; AVFilterLink * outlink = inlink -> dst -> outputs [ 0 ] ; AVFrame * outpic ; const uint8_t * prvp ; const uint8_t * prvpp ; const uint8_t * prvpn ; const uint8_t * prvppp ; const uint8_t * prvpnn ; const uint8_t * prvp4p ; const uint8_t * prvp4n ; const uint8_t * srcp ; const uint8_t * srcpp ; const uint8_t * srcpn ; const uint8_t * srcppp ; const uint8_t * srcpnn ; const uint8_t * srcp3p ; const uint8_t * srcp3n ; const uint8_t * srcp4p ; const uint8_t * srcp4n ; uint8_t * dstp , * dstp_saved ; const uint8_t * srcp_saved ; int src_linesize , psrc_linesize , dst_linesize , bwidth ; int x , y , plane , val , hi , lo , g , h , n = kerndeint -> frame ++ ; double valf ; const int thresh = kerndeint -> thresh ; const int order = kerndeint -> order ; const int map = kerndeint -> map ; const int sharp = kerndeint -> sharp ; const int twoway = kerndeint -> twoway ; const int is_packed_rgb = kerndeint -> is_packed_rgb ; outpic = ff_get_video_buffer ( outlink , outlink -> w , outlink -> h ) ; if ( ! outpic ) { av_frame_free ( & inpic ) ; return AVERROR ( ENOMEM ) ; } av_frame_copy_props ( outpic , inpic ) ; outpic -> interlaced_frame = 0 ; <S2SV_StartBug> for ( plane = 0 ; inpic -> data [ plane ] && plane < 4 ; plane ++ ) { <S2SV_EndBug> h = plane == 0 ? inlink -> h : FF_CEIL_RSHIFT ( inlink -> h , kerndeint -> vsub ) ; bwidth = kerndeint -> tmp_bwidth [ plane ] ; srcp = srcp_saved = inpic -> data [ plane ] ; src_linesize = inpic -> linesize [ plane ] ; psrc_linesize = kerndeint -> tmp_linesize [ plane ] ; dstp = dstp_saved = outpic -> data [ plane ] ; dst_linesize = outpic -> linesize [ plane ] ; srcp = srcp_saved + ( 1 - order ) * src_linesize ; dstp = dstp_saved + ( 1 - order ) * dst_linesize ; for ( y = 0 ; y < h ; y += 2 ) { memcpy ( dstp , srcp , bwidth ) ; srcp += 2 * src_linesize ; dstp += 2 * dst_linesize ; } memcpy ( dstp_saved + order * dst_linesize , srcp_saved + ( 1 - order ) * src_linesize , bwidth ) ; memcpy ( dstp_saved + ( 2 + order ) * dst_linesize , srcp_saved + ( 3 - order ) * src_linesize , bwidth ) ; memcpy ( dstp_saved + ( h - 2 + order ) * dst_linesize , srcp_saved + ( h - 1 - order ) * src_linesize , bwidth ) ; memcpy ( dstp_saved + ( h - 4 + order ) * dst_linesize , srcp_saved + ( h - 3 - order ) * src_linesize , bwidth ) ; prvp = kerndeint -> tmp_data [ plane ] + 5 * psrc_linesize - ( 1 - order ) * psrc_linesize ; prvpp = prvp - psrc_linesize ; prvppp = prvp - 2 * psrc_linesize ; prvp4p = prvp - 4 * psrc_linesize ; prvpn = prvp + psrc_linesize ; prvpnn = prvp + 2 * psrc_linesize ; prvp4n = prvp + 4 * psrc_linesize ; srcp = srcp_saved + 5 * src_linesize - ( 1 - order ) * src_linesize ; srcpp = srcp - src_linesize ; srcppp = srcp - 2 * src_linesize ; srcp3p = srcp - 3 * src_linesize ; srcp4p = srcp - 4 * src_linesize ; srcpn = srcp + src_linesize ; srcpnn = srcp + 2 * src_linesize ; srcp3n = srcp + 3 * src_linesize ; srcp4n = srcp + 4 * src_linesize ; dstp = dstp_saved + 5 * dst_linesize - ( 1 - order ) * dst_linesize ; for ( y = 5 - ( 1 - order ) ; y <= h - 5 - ( 1 - order ) ; y += 2 ) { for ( x = 0 ; x < bwidth ; x ++ ) { if ( thresh == 0 || n == 0 || ( abs ( ( int ) prvp [ x ] - ( int ) srcp [ x ] ) > thresh ) || ( abs ( ( int ) prvpp [ x ] - ( int ) srcpp [ x ] ) > thresh ) || ( abs ( ( int ) prvpn [ x ] - ( int ) srcpn [ x ] ) > thresh ) ) { if ( map ) { g = x & ~ 3 ; if ( is_packed_rgb ) { AV_WB32 ( dstp + g , 0xffffffff ) ; x = g + 3 ; } else if ( inlink -> format == AV_PIX_FMT_YUYV422 ) { AV_WB32 ( dstp + g , 0xeb80eb80 ) ; x = g + 3 ; } else { dstp [ x ] = plane == 0 ? 235 : 128 ; } } else { if ( is_packed_rgb ) { hi = 255 ; lo = 0 ; } else if ( inlink -> format == AV_PIX_FMT_YUYV422 ) { hi = x & 1 ? 240 : 235 ; lo = 16 ; } else { hi = plane == 0 ? 235 : 240 ; lo = 16 ; } if ( sharp ) { if ( twoway ) { valf = + 0.526 * ( ( int ) srcpp [ x ] + ( int ) srcpn [ x ] ) + 0.170 * ( ( int ) srcp [ x ] + ( int ) prvp [ x ] ) - 0.116 * ( ( int ) srcppp [ x ] + ( int ) srcpnn [ x ] + ( int ) prvppp [ x ] + ( int ) prvpnn [ x ] ) - 0.026 * ( ( int ) srcp3p [ x ] + ( int ) srcp3n [ x ] ) + 0.031 * ( ( int ) srcp4p [ x ] + ( int ) srcp4n [ x ] + ( int ) prvp4p [ x ] + ( int ) prvp4n [ x ] ) ; } else { valf = + 0.526 * ( ( int ) srcpp [ x ] + ( int ) srcpn [ x ] ) + 0.170 * ( ( int ) prvp [ x ] ) - 0.116 * ( ( int ) prvppp [ x ] + ( int ) prvpnn [ x ] ) - 0.026 * ( ( int ) srcp3p [ x ] + ( int ) srcp3n [ x ] ) + 0.031 * ( ( int ) prvp4p [ x ] + ( int ) prvp4p [ x ] ) ; } dstp [ x ] = av_clip ( valf , lo , hi ) ; } else { if ( twoway ) { val = ( 8 * ( ( int ) srcpp [ x ] + ( int ) srcpn [ x ] ) + 2 * ( ( int ) srcp [ x ] + ( int ) prvp [ x ] ) - ( int ) ( srcppp [ x ] ) - ( int ) ( srcpnn [ x ] ) - ( int ) ( prvppp [ x ] ) - ( int ) ( prvpnn [ x ] ) ) >> 4 ; } else { val = ( 8 * ( ( int ) srcpp [ x ] + ( int ) srcpn [ x ] ) + 2 * ( ( int ) prvp [ x ] ) - ( int ) ( prvppp [ x ] ) - ( int ) ( prvpnn [ x ] ) ) >> 4 ; } dstp [ x ] = av_clip ( val , lo , hi ) ; } } } else { dstp [ x ] = srcp [ x ] ; } } prvp += 2 * psrc_linesize ; prvpp += 2 * psrc_linesize ; prvppp += 2 * psrc_linesize ; prvpn += 2 * psrc_linesize ; prvpnn += 2 * psrc_linesize ; prvp4p += 2 * psrc_linesize ; prvp4n += 2 * psrc_linesize ; srcp += 2 * src_linesize ; srcpp += 2 * src_linesize ; srcppp += 2 * src_linesize ; srcp3p += 2 * src_linesize ; srcp4p += 2 * src_linesize ; srcpn += 2 * src_linesize ; srcpnn += 2 * src_linesize ; srcp3n += 2 * src_linesize ; srcp4n += 2 * src_linesize ; dstp += 2 * dst_linesize ; } srcp = inpic -> data [ plane ] ; dstp = kerndeint -> tmp_data [ plane ] ; av_image_copy_plane ( dstp , psrc_linesize , srcp , src_linesize , bwidth , h ) ; } av_frame_free ( & inpic ) ; return ff_filter_frame ( outlink , outpic ) ; }\n",
      "fixed_code": "<S2SV_ModStart> = 0 ; <S2SV_ModEnd> plane < 4 <S2SV_ModStart> plane < 4 && inpic -> data [ plane ] && inpic -> linesize [ plane ]\n",
      "source_code_length": 5860,
      "target_code_length": 130,
      "vulnerability_patterns": {
        "integer_overflow": 1,
        "null_pointer": 7,
        "total": 8
      },
      "total_patterns": 8,
      "original_address": "https://github.com/FFmpeg/FFmpeg/commit/e43a0a232dbf6d3c161823c2e07c52e76227a1bc",
      "discovery_time": "2013-11-23T17:55Z",
      "project_commit_id": "FFmpeg@FFmpeg/e43a0a232dbf6d3c161823c2e07c52e76227a1bc",
      "extraction_time": "2025-08-31T15:41:49.184406",
      "label": 1,
      "vulnerability_type": "buffer_overflow",
      "difficulty_level": "advanced",
      "risk_factors": [
        "system_crash",
        "memory_corruption",
        "critical_infrastructure",
        "arbitrary_code_execution"
      ],
      "attack_vectors": [
        "memory_manipulation",
        "malicious_input",
        "code_analysis",
        "buffer_overflow",
        "reverse_engineering",
        "fuzzing"
      ],
      "mitigation_strategies": [
        "safe_string_functions",
        "dynamic_analysis",
        "code_review",
        "static_analysis",
        "memory_safety_checks",
        "input_validation",
        "fuzzing",
        "bounds_checking",
        "secure_coding_practices"
      ],
      "code_differences": {
        "has_differences": true,
        "source_lines": 2,
        "target_lines": 2,
        "character_differences": 5730,
        "similarity_percentage": 9.701492537313433
      },
      "vulnerability_location": {
        "vulnerability_present": true,
        "fix_applied": true,
        "code_changed": true,
        "estimated_lines_changed": 0
      }
    },
    {
      "cve_id": "CVE-2015-8631",
      "cwe_id": "CWE-772",
      "cwe_name": "Missing Release of Memory",
      "project": "krb5",
      "severity": "critical",
      "weaponization_score": 8.2,
      "is_critical": true,
      "is_weaponizable": true,
      "is_high_priority_project": true,
      "vulnerable_code": "CWE-772 gprincs_ret * get_princs_2_svc ( gprincs_arg * arg , struct svc_req * rqstp ) { static gprincs_ret ret ; char * prime_arg ; <S2SV_StartBug> gss_buffer_desc client_name , <S2SV_EndBug> service_name ; OM_uint32 minor_stat ; kadm5_server_handle_t handle ; const char * errmsg = NULL ; xdr_free ( xdr_gprincs_ret , & ret ) ; if ( ( ret . code = new_server_handle ( arg -> api_version , rqstp , & handle ) ) ) goto exit_func ; if ( ( ret . code = check_handle ( ( void * ) handle ) ) ) goto exit_func ; ret . api_version = handle -> api_version ; if ( setup_gss_names ( rqstp , & client_name , & service_name ) < 0 ) { ret . code = KADM5_FAILURE ; goto exit_func ; } prime_arg = arg -> exp ; if ( prime_arg == NULL ) prime_arg = \"*\" ; if ( CHANGEPW_SERVICE ( rqstp ) || ! kadm5int_acl_check ( handle -> context , rqst2name ( rqstp ) , ACL_LIST , NULL , NULL ) ) { ret . code = KADM5_AUTH_LIST ; log_unauth ( \"kadm5_get_principals\" , prime_arg , & client_name , & service_name , rqstp ) ; } else { ret . code = kadm5_get_principals ( ( void * ) handle , arg -> exp , & ret . princs , & ret . count ) ; if ( ret . code != 0 ) errmsg = krb5_get_error_message ( handle -> context , ret . code ) ; log_done ( \"kadm5_get_principals\" , prime_arg , errmsg , & client_name , & service_name , rqstp ) ; if ( errmsg != NULL ) krb5_free_error_message ( handle -> context , errmsg ) ; } <S2SV_StartBug> gss_release_buffer ( & minor_stat , & client_name ) ; <S2SV_EndBug> gss_release_buffer ( & minor_stat , & service_name ) ; exit_func : free_server_handle ( handle ) ; return & ret ; }\n",
      "fixed_code": "<S2SV_ModStart> ; gss_buffer_desc client_name = GSS_C_EMPTY_BUFFER ; gss_buffer_desc service_name = GSS_C_EMPTY_BUFFER <S2SV_ModEnd> ; OM_uint32 minor_stat <S2SV_ModStart> ) ; } exit_func : gss_release_buffer ( & minor_stat , & client_name ) ; gss_release_buffer ( & minor_stat , & service_name ) ; <S2SV_ModEnd> free_server_handle ( handle\n",
      "source_code_length": 1577,
      "target_code_length": 341,
      "vulnerability_patterns": {
        "use_after_free": 1,
        "null_pointer": 8,
        "total": 9
      },
      "total_patterns": 9,
      "original_address": "https://github.com/krb5/krb5/commit/83ed75feba32e46f736fcce0d96a0445f29b96c2",
      "discovery_time": "2016-02-13T02:59Z",
      "project_commit_id": "krb5@krb5/83ed75feba32e46f736fcce0d96a0445f29b96c2",
      "extraction_time": "2025-08-31T15:41:49.184456",
      "label": 1,
      "vulnerability_type": "missing_release_of_memory",
      "difficulty_level": "advanced",
      "risk_factors": [
        "critical_infrastructure",
        "use_after_free"
      ],
      "attack_vectors": [
        "fuzzing",
        "code_analysis",
        "reverse_engineering"
      ],
      "mitigation_strategies": [
        "dynamic_analysis",
        "static_analysis",
        "fuzzing",
        "code_review",
        "secure_coding_practices"
      ],
      "code_differences": {
        "has_differences": true,
        "source_lines": 2,
        "target_lines": 2,
        "character_differences": 1236,
        "similarity_percentage": 22.07792207792208
      },
      "vulnerability_location": {
        "vulnerability_present": true,
        "fix_applied": true,
        "code_changed": true,
        "estimated_lines_changed": 0
      }
    },
    {
      "cve_id": "CVE-2015-8631",
      "cwe_id": "CWE-772",
      "cwe_name": "Missing Release of Memory",
      "project": "krb5",
      "severity": "critical",
      "weaponization_score": 8.2,
      "is_critical": true,
      "is_weaponizable": true,
      "is_high_priority_project": true,
      "vulnerable_code": "CWE-772 gprincs_ret * get_princs_2_svc ( gprincs_arg * arg , struct svc_req * rqstp ) { static gprincs_ret ret ; char * prime_arg ; <S2SV_StartBug> gss_buffer_desc client_name , <S2SV_EndBug> service_name ; OM_uint32 minor_stat ; kadm5_server_handle_t handle ; const char * errmsg = NULL ; xdr_free ( xdr_gprincs_ret , & ret ) ; if ( ( ret . code = new_server_handle ( arg -> api_version , rqstp , & handle ) ) ) goto exit_func ; if ( ( ret . code = check_handle ( ( void * ) handle ) ) ) goto exit_func ; ret . api_version = handle -> api_version ; if ( setup_gss_names ( rqstp , & client_name , & service_name ) < 0 ) { ret . code = KADM5_FAILURE ; goto exit_func ; } prime_arg = arg -> exp ; if ( prime_arg == NULL ) prime_arg = \"*\" ; if ( CHANGEPW_SERVICE ( rqstp ) || ! kadm5int_acl_check ( handle -> context , rqst2name ( rqstp ) , ACL_LIST , NULL , NULL ) ) { ret . code = KADM5_AUTH_LIST ; log_unauth ( \"kadm5_get_principals\" , prime_arg , & client_name , & service_name , rqstp ) ; } else { ret . code = kadm5_get_principals ( ( void * ) handle , arg -> exp , & ret . princs , & ret . count ) ; if ( ret . code != 0 ) errmsg = krb5_get_error_message ( handle -> context , ret . code ) ; log_done ( \"kadm5_get_principals\" , prime_arg , errmsg , & client_name , & service_name , rqstp ) ; if ( errmsg != NULL ) krb5_free_error_message ( handle -> context , errmsg ) ; } <S2SV_StartBug> gss_release_buffer ( & minor_stat , & client_name ) ; <S2SV_EndBug> gss_release_buffer ( & minor_stat , & service_name ) ; exit_func : free_server_handle ( handle ) ; return & ret ; }\n",
      "fixed_code": "<S2SV_ModStart> ; gss_buffer_desc client_name = GSS_C_EMPTY_BUFFER ; gss_buffer_desc service_name = GSS_C_EMPTY_BUFFER <S2SV_ModEnd> ; OM_uint32 minor_stat <S2SV_ModStart> ) ; } exit_func : gss_release_buffer ( & minor_stat , & client_name ) ; gss_release_buffer ( & minor_stat , & service_name ) ; <S2SV_ModEnd> free_server_handle ( handle\n",
      "source_code_length": 1577,
      "target_code_length": 341,
      "vulnerability_patterns": {
        "use_after_free": 2,
        "null_pointer": 7,
        "total": 9
      },
      "total_patterns": 9,
      "original_address": "https://github.com/krb5/krb5/commit/83ed75feba32e46f736fcce0d96a0445f29b96c2",
      "discovery_time": "2016-02-13T02:59Z",
      "project_commit_id": "krb5@krb5/83ed75feba32e46f736fcce0d96a0445f29b96c2",
      "extraction_time": "2025-08-31T15:41:49.184474",
      "label": 1,
      "vulnerability_type": "missing_release_of_memory",
      "difficulty_level": "advanced",
      "risk_factors": [
        "critical_infrastructure",
        "use_after_free"
      ],
      "attack_vectors": [
        "fuzzing",
        "code_analysis",
        "reverse_engineering"
      ],
      "mitigation_strategies": [
        "dynamic_analysis",
        "static_analysis",
        "fuzzing",
        "code_review",
        "secure_coding_practices"
      ],
      "code_differences": {
        "has_differences": true,
        "source_lines": 2,
        "target_lines": 2,
        "character_differences": 1236,
        "similarity_percentage": 22.07792207792208
      },
      "vulnerability_location": {
        "vulnerability_present": true,
        "fix_applied": true,
        "code_changed": true,
        "estimated_lines_changed": 0
      }
    },
    {
      "cve_id": "CVE-2013-2850",
      "cwe_id": "CWE-119",
      "cwe_name": "Buffer Overflow",
      "project": "torvalds",
      "severity": "critical",
      "weaponization_score": 8.2,
      "is_critical": true,
      "is_weaponizable": true,
      "is_high_priority_project": false,
      "vulnerable_code": "CWE-119 static int iscsi_add_notunderstood_response ( char * key , char * value , struct iscsi_param_list * param_list ) { struct iscsi_extra_response * extra_response ; if ( strlen ( value ) > VALUE_MAXLEN ) { pr_err ( \"Value<S2SV_blank>for<S2SV_blank>notunderstood<S2SV_blank>key<S2SV_blank>\\\\\"%s\\\\\"<S2SV_blank>exceeds<S2SV_blank>%d,\" \"<S2SV_blank>protocol<S2SV_blank>error.\\\\n\" , key , VALUE_MAXLEN ) ; return - 1 ; } extra_response = kzalloc ( sizeof ( struct iscsi_extra_response ) , GFP_KERNEL ) ; if ( ! extra_response ) { pr_err ( \"Unable<S2SV_blank>to<S2SV_blank>allocate<S2SV_blank>memory<S2SV_blank>for\" \"<S2SV_blank>struct<S2SV_blank>iscsi_extra_response.\\\\n\" ) ; return - 1 ; } INIT_LIST_HEAD ( & extra_response -> er_list ) ; <S2SV_StartBug> strncpy ( extra_response -> key , key , strlen ( key ) + 1 ) ; <S2SV_EndBug> strncpy ( extra_response -> value , NOTUNDERSTOOD , <S2SV_StartBug> strlen ( NOTUNDERSTOOD ) + 1 ) ; <S2SV_EndBug> list_add_tail ( & extra_response -> er_list , & param_list -> extra_response_list ) ; return 0 ; }\n",
      "fixed_code": "<S2SV_ModStart> er_list ) ; strlcpy <S2SV_ModEnd> ( extra_response -> <S2SV_ModStart> , key , sizeof ( extra_response -> key ) ) ; strlcpy <S2SV_ModEnd> ( extra_response -> <S2SV_ModStart> , NOTUNDERSTOOD , sizeof ( extra_response -> value ) <S2SV_ModEnd> ) ; list_add_tail\n",
      "source_code_length": 1047,
      "target_code_length": 274,
      "vulnerability_patterns": {
        "buffer_overflow": 2,
        "null_pointer": 7,
        "total": 9
      },
      "total_patterns": 9,
      "original_address": "https://github.com/torvalds/linux/commit/cea4dcfdad926a27a18e188720efe0f2c9403456",
      "discovery_time": "2013-06-07T14:03Z",
      "project_commit_id": "torvalds@linux/cea4dcfdad926a27a18e188720efe0f2c9403456",
      "extraction_time": "2025-08-31T15:41:49.184500",
      "label": 1,
      "vulnerability_type": "buffer_overflow",
      "difficulty_level": "advanced",
      "risk_factors": [
        "system_crash",
        "memory_corruption",
        "buffer_overflow",
        "arbitrary_code_execution"
      ],
      "attack_vectors": [
        "memory_manipulation",
        "malicious_input",
        "code_analysis",
        "buffer_overflow",
        "reverse_engineering",
        "fuzzing"
      ],
      "mitigation_strategies": [
        "safe_string_functions",
        "dynamic_analysis",
        "code_review",
        "static_analysis",
        "memory_safety_checks",
        "input_validation",
        "fuzzing",
        "bounds_checking",
        "secure_coding_practices"
      ],
      "code_differences": {
        "has_differences": true,
        "source_lines": 2,
        "target_lines": 2,
        "character_differences": 773,
        "similarity_percentage": 23.52941176470588
      },
      "vulnerability_location": {
        "vulnerability_present": true,
        "fix_applied": true,
        "code_changed": true,
        "estimated_lines_changed": 0
      }
    },
    {
      "cve_id": "CVE-2014-9496",
      "cwe_id": "CWE-000",
      "cwe_name": "Unknown/Uncategorized",
      "project": "erikd",
      "severity": "critical",
      "weaponization_score": 8.2,
      "is_critical": true,
      "is_weaponizable": true,
      "is_high_priority_project": false,
      "vulnerable_code": "CWE-000 static int sd2_parse_rsrc_fork ( SF_PRIVATE * psf ) { SD2_RSRC rsrc ; int k , marker , error = 0 ; psf_use_rsrc ( psf , SF_TRUE ) ; memset ( & rsrc , 0 , sizeof ( rsrc ) ) ; rsrc . rsrc_len = psf_get_filelen ( psf ) ; psf_log_printf ( psf , \"Resource<S2SV_blank>length<S2SV_blank>:<S2SV_blank>%d<S2SV_blank>(0x%04X)\\\\n\" , rsrc . rsrc_len , rsrc . rsrc_len ) ; if ( rsrc . rsrc_len > SIGNED_SIZEOF ( psf -> header ) ) { rsrc . rsrc_data = calloc ( 1 , rsrc . rsrc_len ) ; rsrc . need_to_free_rsrc_data = SF_TRUE ; } else { rsrc . rsrc_data = psf -> header ; rsrc . need_to_free_rsrc_data = SF_FALSE ; } ; psf_fread ( rsrc . rsrc_data , rsrc . rsrc_len , 1 , psf ) ; psf -> headindex = psf -> headend = rsrc . rsrc_len ; rsrc . data_offset = read_rsrc_int ( & rsrc , 0 ) ; rsrc . map_offset = read_rsrc_int ( & rsrc , 4 ) ; rsrc . data_length = read_rsrc_int ( & rsrc , 8 ) ; rsrc . map_length = read_rsrc_int ( & rsrc , 12 ) ; if ( rsrc . data_offset == 0x51607 && rsrc . map_offset == 0x20000 ) { psf_log_printf ( psf , \"Trying<S2SV_blank>offset<S2SV_blank>of<S2SV_blank>0x52<S2SV_blank>bytes.\\\\n\" ) ; rsrc . data_offset = read_rsrc_int ( & rsrc , 0x52 + 0 ) + 0x52 ; rsrc . map_offset = read_rsrc_int ( & rsrc , 0x52 + 4 ) + 0x52 ; rsrc . data_length = read_rsrc_int ( & rsrc , 0x52 + 8 ) ; rsrc . map_length = read_rsrc_int ( & rsrc , 0x52 + 12 ) ; } ; psf_log_printf ( psf , \"<S2SV_blank><S2SV_blank>data<S2SV_blank>offset<S2SV_blank>:<S2SV_blank>0x%04X\\\\n<S2SV_blank><S2SV_blank>map<S2SV_blank><S2SV_blank>offset<S2SV_blank>:<S2SV_blank>0x%04X\\\\n\" \"<S2SV_blank><S2SV_blank>data<S2SV_blank>length<S2SV_blank>:<S2SV_blank>0x%04X\\\\n<S2SV_blank><S2SV_blank>map<S2SV_blank><S2SV_blank>length<S2SV_blank>:<S2SV_blank>0x%04X\\\\n\" , rsrc . data_offset , rsrc . map_offset , rsrc . data_length , rsrc . map_length ) ; if ( rsrc . data_offset > rsrc . rsrc_len ) { psf_log_printf ( psf , \"Error<S2SV_blank>:<S2SV_blank>rsrc.data_offset<S2SV_blank>(%d,<S2SV_blank>0x%x)<S2SV_blank>><S2SV_blank>len\\\\n\" , rsrc . data_offset , rsrc . data_offset ) ; error = SFE_SD2_BAD_DATA_OFFSET ; goto parse_rsrc_fork_cleanup ; } ; if ( rsrc . map_offset > rsrc . rsrc_len ) { psf_log_printf ( psf , \"Error<S2SV_blank>:<S2SV_blank>rsrc.map_offset<S2SV_blank>><S2SV_blank>len\\\\n\" ) ; error = SFE_SD2_BAD_MAP_OFFSET ; goto parse_rsrc_fork_cleanup ; } ; if ( rsrc . data_length > rsrc . rsrc_len ) { psf_log_printf ( psf , \"Error<S2SV_blank>:<S2SV_blank>rsrc.data_length<S2SV_blank>><S2SV_blank>len\\\\n\" ) ; error = SFE_SD2_BAD_DATA_LENGTH ; goto parse_rsrc_fork_cleanup ; } ; if ( rsrc . map_length > rsrc . rsrc_len ) { psf_log_printf ( psf , \"Error<S2SV_blank>:<S2SV_blank>rsrc.map_length<S2SV_blank>><S2SV_blank>len\\\\n\" ) ; error = SFE_SD2_BAD_MAP_LENGTH ; goto parse_rsrc_fork_cleanup ; } ; if ( rsrc . data_offset + rsrc . data_length != rsrc . map_offset || rsrc . map_offset + rsrc . map_length != rsrc . rsrc_len ) { psf_log_printf ( psf , \"Error<S2SV_blank>:<S2SV_blank>This<S2SV_blank>does<S2SV_blank>not<S2SV_blank>look<S2SV_blank>like<S2SV_blank>a<S2SV_blank>MacOSX<S2SV_blank>resource<S2SV_blank>fork.\\\\n\" ) ; error = SFE_SD2_BAD_RSRC ; goto parse_rsrc_fork_cleanup ; } ; if ( rsrc . map_offset + 28 >= rsrc . rsrc_len ) { psf_log_printf ( psf , \"Bad<S2SV_blank>map<S2SV_blank>offset<S2SV_blank>(%d<S2SV_blank>+<S2SV_blank>28<S2SV_blank>><S2SV_blank>%d).\\\\n\" , rsrc . map_offset , rsrc . rsrc_len ) ; error = SFE_SD2_BAD_RSRC ; goto parse_rsrc_fork_cleanup ; } ; rsrc . string_offset = rsrc . map_offset + read_rsrc_short ( & rsrc , rsrc . map_offset + 26 ) ; if ( rsrc . string_offset > rsrc . rsrc_len ) { psf_log_printf ( psf , \"Bad<S2SV_blank>string<S2SV_blank>offset<S2SV_blank>(%d).\\\\n\" , rsrc . string_offset ) ; error = SFE_SD2_BAD_RSRC ; goto parse_rsrc_fork_cleanup ; } ; rsrc . type_offset = rsrc . map_offset + 30 ; <S2SV_StartBug> rsrc . type_count = read_rsrc_short ( & rsrc , rsrc . map_offset + 28 ) + 1 ; <S2SV_EndBug> if ( rsrc . type_count < 1 ) { psf_log_printf ( psf , \"Bad<S2SV_blank>type<S2SV_blank>count.\\\\n\" ) ; error = SFE_SD2_BAD_RSRC ; goto parse_rsrc_fork_cleanup ; } ; rsrc . item_offset = rsrc . type_offset + rsrc . type_count * 8 ; if ( rsrc . item_offset < 0 || rsrc . item_offset > rsrc . rsrc_len ) { psf_log_printf ( psf , \"Bad<S2SV_blank>item<S2SV_blank>offset<S2SV_blank>(%d).\\\\n\" , rsrc . item_offset ) ; error = SFE_SD2_BAD_RSRC ; goto parse_rsrc_fork_cleanup ; } ; rsrc . str_index = - 1 ; for ( k = 0 ; k < rsrc . type_count ; k ++ ) <S2SV_StartBug> { marker = read_rsrc_marker ( & rsrc , rsrc . type_offset + k * 8 ) ; <S2SV_EndBug> if ( marker == STR_MARKER ) { rsrc . str_index = k ; rsrc . str_count = read_rsrc_short ( & rsrc , rsrc . type_offset + k * 8 + 4 ) + 1 ; error = parse_str_rsrc ( psf , & rsrc ) ; goto parse_rsrc_fork_cleanup ; } ; } ; psf_log_printf ( psf , \"No<S2SV_blank>\\'STR<S2SV_blank>\\'<S2SV_blank>resource.\\\\n\" ) ; error = SFE_SD2_BAD_RSRC ; parse_rsrc_fork_cleanup : psf_use_rsrc ( psf , SF_FALSE ) ; if ( rsrc . need_to_free_rsrc_data ) free ( rsrc . rsrc_data ) ; return error ; }\n",
      "fixed_code": "<S2SV_ModStart> + 30 ; if ( rsrc . map_offset + 28 > rsrc . rsrc_len ) { psf_log_printf ( psf , \"Bad<S2SV_blank>map<S2SV_blank>offset.\\\\n\" ) ; goto parse_rsrc_fork_cleanup ; } ; <S2SV_ModStart> ++ ) { if ( <S2SV_ModEnd> rsrc . type_offset <S2SV_ModStart> k * 8 > rsrc . rsrc_len ) { psf_log_printf ( psf , \"Bad<S2SV_blank>rsrc<S2SV_blank>marker.\\\\n\" ) ; goto parse_rsrc_fork_cleanup ; } ; marker = read_rsrc_marker ( & rsrc , rsrc . type_offset + k * 8\n",
      "source_code_length": 5047,
      "target_code_length": 453,
      "vulnerability_patterns": {
        "buffer_overflow": 1,
        "use_after_free": 2,
        "integer_overflow": 1,
        "null_pointer": 4,
        "memory_leak": 1,
        "total": 9
      },
      "total_patterns": 9,
      "original_address": "https://github.com/erikd/libsndfile/commit/dbe14f00030af5d3577f4cabbf9861db59e9c378",
      "discovery_time": "2015-01-16T16:59Z",
      "project_commit_id": "erikd@libsndfile/dbe14f00030af5d3577f4cabbf9861db59e9c378",
      "extraction_time": "2025-08-31T15:41:49.184532",
      "label": 1,
      "vulnerability_type": "unknown/uncategorized",
      "difficulty_level": "advanced",
      "risk_factors": [
        "buffer_overflow",
        "use_after_free"
      ],
      "attack_vectors": [
        "fuzzing",
        "code_analysis",
        "reverse_engineering"
      ],
      "mitigation_strategies": [
        "dynamic_analysis",
        "static_analysis",
        "fuzzing",
        "code_review",
        "secure_coding_practices"
      ],
      "code_differences": {
        "has_differences": true,
        "source_lines": 2,
        "target_lines": 2,
        "character_differences": 4594,
        "similarity_percentage": 26.168224299065418
      },
      "vulnerability_location": {
        "vulnerability_present": true,
        "fix_applied": true,
        "code_changed": true,
        "estimated_lines_changed": 0
      }
    },
    {
      "cve_id": "CVE-2017-3735",
      "cwe_id": "CWE-119",
      "cwe_name": "Buffer Overflow",
      "project": "openssl",
      "severity": "critical",
      "weaponization_score": 8.1,
      "is_critical": true,
      "is_weaponizable": true,
      "is_high_priority_project": true,
      "vulnerable_code": "CWE-119 unsigned int X509v3_addr_get_afi ( const IPAddressFamily * f ) { <S2SV_StartBug> return ( ( f != NULL && <S2SV_EndBug> <S2SV_StartBug> f -> addressFamily != NULL && f -> addressFamily -> data != NULL ) <S2SV_EndBug> <S2SV_StartBug> ? ( ( f -> addressFamily -> data [ 0 ] << 8 ) | ( f -> addressFamily -> data [ 1 ] ) ) <S2SV_EndBug> : 0 ) ; }\n",
      "fixed_code": "<S2SV_ModStart> f ) { if ( f == NULL || <S2SV_ModEnd> f -> addressFamily <S2SV_ModStart> f -> addressFamily == NULL || <S2SV_ModEnd> f -> addressFamily <S2SV_ModStart> addressFamily -> data == NULL || f -> addressFamily -> length < 2 ) return 0 ; return <S2SV_ModEnd> ( f -> <S2SV_ModStart> 8 ) | <S2SV_ModEnd> f -> addressFamily <S2SV_ModStart> [ 1 ] <S2SV_ModEnd> ; } <S2SV_null>\n",
      "source_code_length": 351,
      "target_code_length": 382,
      "vulnerability_patterns": {
        "null_pointer": 7,
        "total": 7
      },
      "total_patterns": 7,
      "original_address": "https://github.com/openssl/openssl/commit/068b963bb7afc57f5bdd723de0dd15e7795d5822",
      "discovery_time": "2017-08-28T19:29Z",
      "project_commit_id": "openssl@openssl/068b963bb7afc57f5bdd723de0dd15e7795d5822",
      "extraction_time": "2025-08-31T15:41:49.184570",
      "label": 1,
      "vulnerability_type": "buffer_overflow",
      "difficulty_level": "advanced",
      "risk_factors": [
        "system_crash",
        "memory_corruption",
        "critical_infrastructure",
        "arbitrary_code_execution"
      ],
      "attack_vectors": [
        "memory_manipulation",
        "malicious_input",
        "code_analysis",
        "buffer_overflow",
        "reverse_engineering",
        "fuzzing"
      ],
      "mitigation_strategies": [
        "safe_string_functions",
        "dynamic_analysis",
        "code_review",
        "static_analysis",
        "memory_safety_checks",
        "input_validation",
        "fuzzing",
        "bounds_checking",
        "secure_coding_practices"
      ],
      "code_differences": {
        "has_differences": true,
        "source_lines": 2,
        "target_lines": 2,
        "character_differences": 31,
        "similarity_percentage": 42.5
      },
      "vulnerability_location": {
        "vulnerability_present": true,
        "fix_applied": true,
        "code_changed": true,
        "estimated_lines_changed": 0
      }
    },
    {
      "cve_id": "CVE-2016-10190",
      "cwe_id": "CWE-119",
      "cwe_name": "Buffer Overflow",
      "project": "FFmpeg",
      "severity": "critical",
      "weaponization_score": 8.1,
      "is_critical": true,
      "is_weaponizable": true,
      "is_high_priority_project": true,
      "vulnerable_code": "CWE-119 static int process_line ( URLContext * h , char * line , int line_count , int * new_location ) { HTTPContext * s = h -> priv_data ; const char * auto_method = h -> flags & AVIO_FLAG_READ ? \"POST\" : \"GET\" ; char * tag , * p , * end , * method , * resource , * version ; int ret ; if ( line [ 0 ] == '\\\\0' ) { s -> end_header = 1 ; return 0 ; } p = line ; if ( line_count == 0 ) { if ( s -> is_connected_server ) { method = p ; while ( * p && ! av_isspace ( * p ) ) p ++ ; * ( p ++ ) = '\\\\0' ; av_log ( h , AV_LOG_TRACE , \"Received<S2SV_blank>method:<S2SV_blank>%s\\\\n\" , method ) ; if ( s -> method ) { if ( av_strcasecmp ( s -> method , method ) ) { av_log ( h , AV_LOG_ERROR , \"Received<S2SV_blank>and<S2SV_blank>expected<S2SV_blank>HTTP<S2SV_blank>method<S2SV_blank>do<S2SV_blank>not<S2SV_blank>match.<S2SV_blank>(%s<S2SV_blank>expected,<S2SV_blank>%s<S2SV_blank>received)\\\\n\" , s -> method , method ) ; return ff_http_averror ( 400 , AVERROR ( EIO ) ) ; } } else { av_log ( h , AV_LOG_TRACE , \"Autodetected<S2SV_blank>%s<S2SV_blank>HTTP<S2SV_blank>method\\\\n\" , auto_method ) ; if ( av_strcasecmp ( auto_method , method ) ) { av_log ( h , AV_LOG_ERROR , \"Received<S2SV_blank>and<S2SV_blank>autodetected<S2SV_blank>HTTP<S2SV_blank>method<S2SV_blank>did<S2SV_blank>not<S2SV_blank>match<S2SV_blank>\" \"(%s<S2SV_blank>autodetected<S2SV_blank>%s<S2SV_blank>received)\\\\n\" , auto_method , method ) ; return ff_http_averror ( 400 , AVERROR ( EIO ) ) ; } if ( ! ( s -> method = av_strdup ( method ) ) ) return AVERROR ( ENOMEM ) ; } while ( av_isspace ( * p ) ) p ++ ; resource = p ; while ( ! av_isspace ( * p ) ) p ++ ; * ( p ++ ) = '\\\\0' ; av_log ( h , AV_LOG_TRACE , \"Requested<S2SV_blank>resource:<S2SV_blank>%s\\\\n\" , resource ) ; if ( ! ( s -> resource = av_strdup ( resource ) ) ) return AVERROR ( ENOMEM ) ; while ( av_isspace ( * p ) ) p ++ ; version = p ; while ( * p && ! av_isspace ( * p ) ) p ++ ; * p = '\\\\0' ; if ( av_strncasecmp ( version , \"HTTP/\" , 5 ) ) { av_log ( h , AV_LOG_ERROR , \"Malformed<S2SV_blank>HTTP<S2SV_blank>version<S2SV_blank>string.\\\\n\" ) ; return ff_http_averror ( 400 , AVERROR ( EIO ) ) ; } av_log ( h , AV_LOG_TRACE , \"HTTP<S2SV_blank>version<S2SV_blank>string:<S2SV_blank>%s\\\\n\" , version ) ; } else { while ( ! av_isspace ( * p ) && * p != '\\\\0' ) p ++ ; while ( av_isspace ( * p ) ) p ++ ; s -> http_code = strtol ( p , & end , 10 ) ; av_log ( h , AV_LOG_TRACE , \"http_code=%d\\\\n\" , s -> http_code ) ; if ( ( ret = check_http_code ( h , s -> http_code , end ) ) < 0 ) return ret ; } } else { while ( * p != '\\\\0' && * p != ':' ) p ++ ; if ( * p != ':' ) return 1 ; * p = '\\\\0' ; tag = line ; p ++ ; while ( av_isspace ( * p ) ) p ++ ; if ( ! av_strcasecmp ( tag , \"Location\" ) ) { if ( ( ret = parse_location ( s , p ) ) < 0 ) return ret ; * new_location = 1 ; <S2SV_StartBug> } else if ( ! av_strcasecmp ( tag , \"Content-Length\" ) && s -> filesize == - 1 ) { <S2SV_EndBug> <S2SV_StartBug> s -> filesize = strtoll ( p , NULL , 10 ) ; <S2SV_EndBug> } else if ( ! av_strcasecmp ( tag , \"Content-Range\" ) ) { parse_content_range ( h , p ) ; } else if ( ! av_strcasecmp ( tag , \"Accept-Ranges\" ) && ! strncmp ( p , \"bytes\" , 5 ) && s -> seekable == - 1 ) { h -> is_streamed = 0 ; } else if ( ! av_strcasecmp ( tag , \"Transfer-Encoding\" ) && ! av_strncasecmp ( p , \"chunked\" , 7 ) ) { <S2SV_StartBug> s -> filesize = - 1 ; <S2SV_EndBug> s -> chunksize = 0 ; } else if ( ! av_strcasecmp ( tag , \"WWW-Authenticate\" ) ) { <S2SV_StartBug> ff_http_auth_handle_header ( & s -> auth_state , tag , p ) ; <S2SV_EndBug> } else if ( ! av_strcasecmp ( tag , \"Authentication-Info\" ) ) { ff_http_auth_handle_header ( & s -> auth_state , tag , p ) ; } else if ( ! av_strcasecmp ( tag , \"Proxy-Authenticate\" ) ) { ff_http_auth_handle_header ( & s -> proxy_auth_state , tag , p ) ; } else if ( ! av_strcasecmp ( tag , \"Connection\" ) ) { if ( ! strcmp ( p , \"close\" ) ) s -> willclose = 1 ; } else if ( ! av_strcasecmp ( tag , \"Server\" ) ) { if ( ! av_strcasecmp ( p , \"AkamaiGHost\" ) ) { s -> is_akamai = 1 ; } else if ( ! av_strncasecmp ( p , \"MediaGateway\" , 12 ) ) { s -> is_mediagateway = 1 ; } } else if ( ! av_strcasecmp ( tag , \"Content-Type\" ) ) { av_free ( s -> mime_type ) ; s -> mime_type = av_strdup ( p ) ; } else if ( ! av_strcasecmp ( tag , \"Set-Cookie\" ) ) { if ( parse_cookie ( s , p , & s -> cookie_dict ) ) av_log ( h , AV_LOG_WARNING , \"Unable<S2SV_blank>to<S2SV_blank>parse<S2SV_blank>\\'%s\\'\\\\n\" , p ) ; } else if ( ! av_strcasecmp ( tag , \"Icy-MetaInt\" ) ) { <S2SV_StartBug> s -> icy_metaint = strtoll ( p , NULL , 10 ) ; <S2SV_EndBug> } else if ( ! av_strncasecmp ( tag , \"Icy-\" , 4 ) ) { if ( ( ret = parse_icy ( s , tag , p ) ) < 0 ) return ret ; } else if ( ! av_strcasecmp ( tag , \"Content-Encoding\" ) ) { if ( ( ret = parse_content_encoding ( h , p ) ) < 0 ) return ret ; } } return 1 ; }\n",
      "fixed_code": "<S2SV_ModStart> -> filesize == UINT64_MAX <S2SV_ModEnd> ) { s <S2SV_ModStart> -> filesize = strtoull <S2SV_ModEnd> ( p , <S2SV_ModStart> -> filesize = UINT64_MAX ; s -> chunksize = 0 ; } else if ( ! av_strcasecmp ( tag , \"WWW-Authenticate\" ) ) { ff_http_auth_handle_header ( & s -> auth_state , tag , p ) ; } else if ( ! av_strcasecmp ( tag , \"Authentication-Info\" ) ) { ff_http_auth_handle_header ( & s -> auth_state , tag , p ) ; } else if ( ! av_strcasecmp ( tag , \"Proxy-Authenticate\" ) ) { ff_http_auth_handle_header ( & s -> proxy_auth_state , tag , p ) ; } else if ( ! av_strcasecmp ( tag , \"Connection\" ) ) { if ( ! strcmp ( p , \"close\" ) ) s -> willclose = 1 ; } else if ( ! av_strcasecmp ( tag , \"Server\" ) ) { if ( ! av_strcasecmp ( p , \"AkamaiGHost\" ) ) { s -> is_akamai = 1 ; } else if ( ! av_strncasecmp ( p , \"MediaGateway\" , 12 ) ) { s -> is_mediagateway = 1 ; } } else if ( ! av_strcasecmp ( tag , \"Content-Type\" ) ) { av_free ( s -> mime_type ) ; s -> mime_type = av_strdup ( p ) ; } else if ( ! av_strcasecmp ( tag , \"Set-Cookie\" ) ) { if ( parse_cookie ( s , p , <S2SV_ModEnd> & s -> <S2SV_ModStart> & s -> <S2SV_ModEnd> cookie_dict ) ) <S2SV_ModStart> -> icy_metaint = strtoull <S2SV_ModEnd> ( p ,\n",
      "source_code_length": 4836,
      "target_code_length": 1219,
      "vulnerability_patterns": {
        "null_pointer": 7,
        "total": 7
      },
      "total_patterns": 7,
      "original_address": "https://github.com/FFmpeg/FFmpeg/commit/2a05c8f813de6f2278827734bf8102291e7484aa",
      "discovery_time": "2017-02-09T15:59Z",
      "project_commit_id": "FFmpeg@FFmpeg/2a05c8f813de6f2278827734bf8102291e7484aa",
      "extraction_time": "2025-08-31T15:41:49.184588",
      "label": 1,
      "vulnerability_type": "buffer_overflow",
      "difficulty_level": "advanced",
      "risk_factors": [
        "system_crash",
        "memory_corruption",
        "critical_infrastructure",
        "arbitrary_code_execution"
      ],
      "attack_vectors": [
        "memory_manipulation",
        "malicious_input",
        "code_analysis",
        "buffer_overflow",
        "reverse_engineering",
        "fuzzing"
      ],
      "mitigation_strategies": [
        "safe_string_functions",
        "dynamic_analysis",
        "code_review",
        "static_analysis",
        "memory_safety_checks",
        "input_validation",
        "fuzzing",
        "bounds_checking",
        "secure_coding_practices"
      ],
      "code_differences": {
        "has_differences": true,
        "source_lines": 2,
        "target_lines": 2,
        "character_differences": 3617,
        "similarity_percentage": 33.33333333333333
      },
      "vulnerability_location": {
        "vulnerability_present": true,
        "fix_applied": true,
        "code_changed": true,
        "estimated_lines_changed": 0
      }
    },
    {
      "cve_id": "CVE-2019-15919",
      "cwe_id": "CWE-416",
      "cwe_name": "Use After Free",
      "project": "torvalds",
      "severity": "critical",
      "weaponization_score": 8.0,
      "is_critical": true,
      "is_weaponizable": true,
      "is_high_priority_project": false,
      "vulnerable_code": "CWE-416 int SMB2_write ( const unsigned int xid , struct cifs_io_parms * io_parms , unsigned int * nbytes , struct kvec * iov , int n_vec ) { struct smb_rqst rqst ; int rc = 0 ; struct smb2_write_req * req = NULL ; struct smb2_write_rsp * rsp = NULL ; int resp_buftype ; struct kvec rsp_iov ; int flags = 0 ; unsigned int total_len ; * nbytes = 0 ; if ( n_vec < 1 ) return rc ; rc = smb2_plain_req_init ( SMB2_WRITE , io_parms -> tcon , ( void * * ) & req , & total_len ) ; if ( rc ) return rc ; if ( io_parms -> tcon -> ses -> server == NULL ) return - ECONNABORTED ; if ( smb3_encryption_required ( io_parms -> tcon ) ) flags |= CIFS_TRANSFORM_REQ ; req -> sync_hdr . ProcessId = cpu_to_le32 ( io_parms -> pid ) ; req -> PersistentFileId = io_parms -> persistent_fid ; req -> VolatileFileId = io_parms -> volatile_fid ; req -> WriteChannelInfoOffset = 0 ; req -> WriteChannelInfoLength = 0 ; req -> Channel = 0 ; req -> Length = cpu_to_le32 ( io_parms -> length ) ; req -> Offset = cpu_to_le64 ( io_parms -> offset ) ; req -> DataOffset = cpu_to_le16 ( offsetof ( struct smb2_write_req , Buffer ) ) ; req -> RemainingBytes = 0 ; trace_smb3_write_enter ( xid , io_parms -> persistent_fid , io_parms -> tcon -> tid , io_parms -> tcon -> ses -> Suid , io_parms -> offset , io_parms -> length ) ; iov [ 0 ] . iov_base = ( char * ) req ; iov [ 0 ] . iov_len = total_len - 1 ; memset ( & rqst , 0 , sizeof ( struct smb_rqst ) ) ; rqst . rq_iov = iov ; rqst . rq_nvec = n_vec + 1 ; rc = cifs_send_recv ( xid , io_parms -> tcon -> ses , & rqst , & resp_buftype , flags , & rsp_iov ) ; <S2SV_StartBug> cifs_small_buf_release ( req ) ; <S2SV_EndBug> rsp = ( struct smb2_write_rsp * ) rsp_iov . iov_base ; if ( rc ) { trace_smb3_write_err ( xid , req -> PersistentFileId , io_parms -> tcon -> tid , io_parms -> tcon -> ses -> Suid , io_parms -> offset , io_parms -> length , rc ) ; cifs_stats_fail_inc ( io_parms -> tcon , SMB2_WRITE_HE ) ; cifs_dbg ( VFS , \"Send<S2SV_blank>error<S2SV_blank>in<S2SV_blank>write<S2SV_blank>=<S2SV_blank>%d\\\\n\" , rc ) ; } else { * nbytes = le32_to_cpu ( rsp -> DataLength ) ; trace_smb3_write_done ( xid , req -> PersistentFileId , io_parms -> tcon -> tid , io_parms -> tcon -> ses -> Suid , io_parms -> offset , * nbytes ) ; } <S2SV_StartBug> free_rsp_buf ( resp_buftype , rsp ) ; <S2SV_EndBug> return rc ; }\n",
      "fixed_code": "<S2SV_ModStart> rsp_iov ) ; <S2SV_ModEnd> rsp = ( <S2SV_ModStart> ) ; } cifs_small_buf_release ( req ) ;\n",
      "source_code_length": 2333,
      "target_code_length": 105,
      "vulnerability_patterns": {
        "buffer_overflow": 1,
        "null_pointer": 47,
        "total": 48
      },
      "total_patterns": 48,
      "original_address": "https://github.com/torvalds/linux/commit/6a3eb3360667170988f8a6477f6686242061488a",
      "discovery_time": "2019-09-04T19:15Z",
      "project_commit_id": "torvalds@linux/6a3eb3360667170988f8a6477f6686242061488a",
      "extraction_time": "2025-08-31T15:41:49.184639",
      "label": 1,
      "vulnerability_type": "use_after_free",
      "difficulty_level": "advanced",
      "risk_factors": [
        "system_crash",
        "denial_of_service",
        "memory_corruption",
        "buffer_overflow"
      ],
      "attack_vectors": [
        "memory_manipulation",
        "null_pointer",
        "code_analysis",
        "reverse_engineering",
        "use_after_free",
        "fuzzing"
      ],
      "mitigation_strategies": [
        "null_pointer_checks",
        "fuzzing",
        "dynamic_analysis",
        "memory_management",
        "static_analysis",
        "use_after_free_prevention",
        "code_review",
        "secure_coding_practices"
      ],
      "code_differences": {
        "has_differences": true,
        "source_lines": 2,
        "target_lines": 2,
        "character_differences": 2228,
        "similarity_percentage": 8.653846153846153
      },
      "vulnerability_location": {
        "vulnerability_present": true,
        "fix_applied": true,
        "code_changed": true,
        "estimated_lines_changed": 0
      }
    },
    {
      "cve_id": "CVE-2018-1000127",
      "cwe_id": "CWE-190",
      "cwe_name": "Integer Overflow",
      "project": "memcached",
      "severity": "critical",
      "weaponization_score": 8.0,
      "is_critical": true,
      "is_weaponizable": true,
      "is_high_priority_project": false,
      "vulnerable_code": "CWE-190 static inline void process_get_command ( conn * c , token_t * tokens , size_t ntokens , bool return_cas ) { char * key ; size_t nkey ; int i = 0 ; item * it ; token_t * key_token = & tokens [ KEY_TOKEN ] ; char * suffix ; assert ( c != NULL ) ; do { while ( key_token -> length != 0 ) { key = key_token -> value ; nkey = key_token -> length ; if ( nkey > KEY_MAX_LENGTH ) { out_string ( c , \"CLIENT_ERROR<S2SV_blank>bad<S2SV_blank>command<S2SV_blank>line<S2SV_blank>format\" ) ; while ( i -- > 0 ) { item_remove ( * ( c -> ilist + i ) ) ; } return ; } <S2SV_StartBug> it = item_get ( key , nkey , c , DO_UPDATE ) ; <S2SV_EndBug> if ( settings . detail_enabled ) { stats_prefix_record_get ( key , nkey , NULL != it ) ; } if ( it ) { if ( i >= c -> isize ) { item * * new_list = realloc ( c -> ilist , sizeof ( item * ) * c -> isize * 2 ) ; if ( new_list ) { c -> isize *= 2 ; c -> ilist = new_list ; } else { STATS_LOCK ( ) ; stats . malloc_fails ++ ; STATS_UNLOCK ( ) ; item_remove ( it ) ; break ; } } if ( return_cas || ! settings . inline_ascii_response ) { MEMCACHED_COMMAND_GET ( c -> sfd , ITEM_key ( it ) , it -> nkey , it -> nbytes , ITEM_get_cas ( it ) ) ; if ( i >= c -> suffixsize ) { char * * new_suffix_list = realloc ( c -> suffixlist , sizeof ( char * ) * c -> suffixsize * 2 ) ; if ( new_suffix_list ) { c -> suffixsize *= 2 ; c -> suffixlist = new_suffix_list ; } else { STATS_LOCK ( ) ; stats . malloc_fails ++ ; STATS_UNLOCK ( ) ; item_remove ( it ) ; break ; } } suffix = do_cache_alloc ( c -> thread -> suffix_cache ) ; if ( suffix == NULL ) { STATS_LOCK ( ) ; stats . malloc_fails ++ ; STATS_UNLOCK ( ) ; out_of_memory ( c , \"SERVER_ERROR<S2SV_blank>out<S2SV_blank>of<S2SV_blank>memory<S2SV_blank>making<S2SV_blank>CAS<S2SV_blank>suffix\" ) ; item_remove ( it ) ; while ( i -- > 0 ) { item_remove ( * ( c -> ilist + i ) ) ; } return ; } * ( c -> suffixlist + i ) = suffix ; int suffix_len = make_ascii_get_suffix ( suffix , it , return_cas ) ; if ( add_iov ( c , \"VALUE<S2SV_blank>\" , 6 ) != 0 || add_iov ( c , ITEM_key ( it ) , it -> nkey ) != 0 || ( settings . inline_ascii_response && add_iov ( c , ITEM_suffix ( it ) , it -> nsuffix - 2 ) != 0 ) || add_iov ( c , suffix , suffix_len ) != 0 ) { item_remove ( it ) ; break ; } if ( ( it -> it_flags & ITEM_CHUNKED ) == 0 ) { add_iov ( c , ITEM_data ( it ) , it -> nbytes ) ; } else if ( add_chunked_item_iovs ( c , it , it -> nbytes ) != 0 ) { item_remove ( it ) ; break ; } } else { MEMCACHED_COMMAND_GET ( c -> sfd , ITEM_key ( it ) , it -> nkey , it -> nbytes , ITEM_get_cas ( it ) ) ; if ( add_iov ( c , \"VALUE<S2SV_blank>\" , 6 ) != 0 || add_iov ( c , ITEM_key ( it ) , it -> nkey ) != 0 ) { item_remove ( it ) ; break ; } if ( ( it -> it_flags & ITEM_CHUNKED ) == 0 ) { if ( add_iov ( c , ITEM_suffix ( it ) , it -> nsuffix + it -> nbytes ) != 0 ) { item_remove ( it ) ; break ; } } else if ( add_iov ( c , ITEM_suffix ( it ) , it -> nsuffix ) != 0 || add_chunked_item_iovs ( c , it , it -> nbytes ) != 0 ) { item_remove ( it ) ; break ; } } if ( settings . verbose > 1 ) { int ii ; fprintf ( stderr , \">%d<S2SV_blank>sending<S2SV_blank>key<S2SV_blank>\" , c -> sfd ) ; for ( ii = 0 ; ii < it -> nkey ; ++ ii ) { fprintf ( stderr , \"%c\" , key [ ii ] ) ; } fprintf ( stderr , \"\\\\n\" ) ; } pthread_mutex_lock ( & c -> thread -> stats . mutex ) ; c -> thread -> stats . slab_stats [ ITEM_clsid ( it ) ] . get_hits ++ ; c -> thread -> stats . get_cmds ++ ; pthread_mutex_unlock ( & c -> thread -> stats . mutex ) ; * ( c -> ilist + i ) = it ; i ++ ; } else { pthread_mutex_lock ( & c -> thread -> stats . mutex ) ; c -> thread -> stats . get_misses ++ ; c -> thread -> stats . get_cmds ++ ; pthread_mutex_unlock ( & c -> thread -> stats . mutex ) ; MEMCACHED_COMMAND_GET ( c -> sfd , key , nkey , - 1 , 0 ) ; } key_token ++ ; } if ( key_token -> value != NULL ) { ntokens = tokenize_command ( key_token -> value , tokens , MAX_TOKENS ) ; key_token = tokens ; } } while ( key_token -> value != NULL ) ; c -> icurr = c -> ilist ; c -> ileft = i ; if ( return_cas || ! settings . inline_ascii_response ) { c -> suffixcurr = c -> suffixlist ; c -> suffixleft = i ; } if ( settings . verbose > 1 ) fprintf ( stderr , \">%d<S2SV_blank>END\\\\n\" , c -> sfd ) ; if ( key_token -> value != NULL || add_iov ( c , \"END\\\\r\\\\n\" , 5 ) != 0 || ( IS_UDP ( c -> transport ) && build_udp_headers ( c ) != 0 ) ) { out_of_memory ( c , \"SERVER_ERROR<S2SV_blank>out<S2SV_blank>of<S2SV_blank>memory<S2SV_blank>writing<S2SV_blank>get<S2SV_blank>response\" ) ; } else { conn_set_state ( c , conn_mwrite ) ; c -> msgcurr = 0 ; } }\n",
      "fixed_code": "<S2SV_ModStart> } it = limited_get <S2SV_ModEnd> ( key , <S2SV_ModStart> nkey , c <S2SV_ModEnd> ) ; if\n",
      "source_code_length": 4580,
      "target_code_length": 103,
      "vulnerability_patterns": {
        "use_after_free": 8,
        "integer_overflow": 14,
        "format_string": 4,
        "null_pointer": 69,
        "memory_leak": 2,
        "total": 97
      },
      "total_patterns": 97,
      "original_address": "https://github.com/memcached/memcached/commit/a8c4a82787b8b6c256d61bd5c42fb7f92d1bae00",
      "discovery_time": "2018-03-13T21:29Z",
      "project_commit_id": "memcached@memcached/a8c4a82787b8b6c256d61bd5c42fb7f92d1bae00",
      "extraction_time": "2025-08-31T15:41:49.184665",
      "label": 1,
      "vulnerability_type": "integer_overflow",
      "difficulty_level": "advanced",
      "risk_factors": [
        "information_disclosure",
        "memory_corruption",
        "integer_overflow",
        "use_after_free"
      ],
      "attack_vectors": [
        "fuzzing",
        "code_analysis",
        "reverse_engineering"
      ],
      "mitigation_strategies": [
        "dynamic_analysis",
        "static_analysis",
        "fuzzing",
        "code_review",
        "secure_coding_practices"
      ],
      "code_differences": {
        "has_differences": true,
        "source_lines": 2,
        "target_lines": 2,
        "character_differences": 4477,
        "similarity_percentage": 7.746478873239436
      },
      "vulnerability_location": {
        "vulnerability_present": true,
        "fix_applied": true,
        "code_changed": true,
        "estimated_lines_changed": 0
      }
    },
    {
      "cve_id": "CVE-2018-14363",
      "cwe_id": "CWE-22",
      "cwe_name": "Path Traversal",
      "project": "neomutt",
      "severity": "critical",
      "weaponization_score": 8.0,
      "is_critical": true,
      "is_weaponizable": true,
      "is_high_priority_project": true,
      "vulnerable_code": "CWE-22 static int pop_sync_mailbox ( struct Context * ctx , int * index_hint ) { int i , j , ret = 0 ; char buf [ LONG_STRING ] ; struct PopData * pop_data = ( struct PopData * ) ctx -> data ; struct Progress progress ; # ifdef USE_HCACHE header_cache_t * hc = NULL ; # endif pop_data -> check_time = 0 ; while ( true ) { if ( pop_reconnect ( ctx ) < 0 ) return - 1 ; mutt_progress_init ( & progress , _ ( \"Marking<S2SV_blank>messages<S2SV_blank>deleted...\" ) , MUTT_PROGRESS_MSG , WriteInc , ctx -> deleted ) ; # ifdef USE_HCACHE hc = pop_hcache_open ( pop_data , ctx -> path ) ; # endif for ( i = 0 , j = 0 , ret = 0 ; ret == 0 && i < ctx -> msgcount ; i ++ ) { if ( ctx -> hdrs [ i ] -> deleted && ctx -> hdrs [ i ] -> refno != - 1 ) { j ++ ; if ( ! ctx -> quiet ) mutt_progress_update ( & progress , j , - 1 ) ; snprintf ( buf , sizeof ( buf ) , \"DELE<S2SV_blank>%d\\\\r\\\\n\" , ctx -> hdrs [ i ] -> refno ) ; ret = pop_query ( pop_data , buf , sizeof ( buf ) ) ; if ( ret == 0 ) { <S2SV_StartBug> mutt_bcache_del ( pop_data -> bcache , ctx -> hdrs [ i ] -> data ) ; <S2SV_EndBug> # ifdef USE_HCACHE mutt_hcache_delete ( hc , ctx -> hdrs [ i ] -> data , strlen ( ctx -> hdrs [ i ] -> data ) ) ; # endif } } # ifdef USE_HCACHE if ( ctx -> hdrs [ i ] -> changed ) { mutt_hcache_store ( hc , ctx -> hdrs [ i ] -> data , strlen ( ctx -> hdrs [ i ] -> data ) , ctx -> hdrs [ i ] , 0 ) ; } # endif } # ifdef USE_HCACHE mutt_hcache_close ( hc ) ; # endif if ( ret == 0 ) { mutt_str_strfcpy ( buf , \"QUIT\\\\r\\\\n\" , sizeof ( buf ) ) ; ret = pop_query ( pop_data , buf , sizeof ( buf ) ) ; } if ( ret == 0 ) { pop_data -> clear_cache = true ; pop_clear_cache ( pop_data ) ; pop_data -> status = POP_DISCONNECTED ; return 0 ; } if ( ret == - 2 ) { mutt_error ( \"%s\" , pop_data -> err_msg ) ; return - 1 ; } } }\n",
      "fixed_code": "<S2SV_ModStart> -> bcache , cache_id ( <S2SV_ModStart> ] -> data )\n",
      "source_code_length": 1799,
      "target_code_length": 67,
      "vulnerability_patterns": {
        "use_after_free": 3,
        "integer_overflow": 2,
        "format_string": 1,
        "null_pointer": 29,
        "total": 35
      },
      "total_patterns": 35,
      "original_address": "https://github.com/neomutt/neomutt/commit/9bfab35522301794483f8f9ed60820bdec9be59e",
      "discovery_time": "2018-07-17T17:29Z",
      "project_commit_id": "neomutt@neomutt/9bfab35522301794483f8f9ed60820bdec9be59e",
      "extraction_time": "2025-08-31T15:41:49.184708",
      "label": 1,
      "vulnerability_type": "path_traversal",
      "difficulty_level": "advanced",
      "risk_factors": [
        "critical_infrastructure",
        "file_upload",
        "unauthorized_access",
        "data_manipulation",
        "use_after_free"
      ],
      "attack_vectors": [
        "malicious_input",
        "code_analysis",
        "path_traversal",
        "reverse_engineering",
        "fuzzing",
        "sql_queries"
      ],
      "mitigation_strategies": [
        "access_control",
        "parameterized_queries",
        "dynamic_analysis",
        "path_validation",
        "static_analysis",
        "input_validation",
        "fuzzing",
        "code_review",
        "secure_coding_practices"
      ],
      "code_differences": {
        "has_differences": true,
        "source_lines": 2,
        "target_lines": 2,
        "character_differences": 1732,
        "similarity_percentage": 7.608695652173914
      },
      "vulnerability_location": {
        "vulnerability_present": true,
        "fix_applied": true,
        "code_changed": true,
        "estimated_lines_changed": 0
      }
    },
    {
      "cve_id": "CVE-2012-2744",
      "cwe_id": "CWE-000",
      "cwe_name": "Unknown/Uncategorized",
      "project": "torvalds",
      "severity": "critical",
      "weaponization_score": 8.0,
      "is_critical": true,
      "is_weaponizable": true,
      "is_high_priority_project": false,
      "vulnerable_code": "CWE-000 struct sk_buff * nf_ct_frag6_gather ( struct sk_buff * skb , u32 user ) { struct sk_buff * clone ; struct net_device * dev = skb -> dev ; struct frag_hdr * fhdr ; struct nf_ct_frag6_queue * fq ; struct ipv6hdr * hdr ; int fhoff , nhoff ; u8 prevhdr ; struct sk_buff * ret_skb = NULL ; if ( ipv6_hdr ( skb ) -> payload_len == 0 ) { pr_debug ( \"payload<S2SV_blank>len<S2SV_blank>=<S2SV_blank>0\\\\n\" ) ; return skb ; } if ( find_prev_fhdr ( skb , & prevhdr , & nhoff , & fhoff ) < 0 ) return skb ; clone = skb_clone ( skb , GFP_ATOMIC ) ; if ( clone == NULL ) { pr_debug ( \"Can\\'t<S2SV_blank>clone<S2SV_blank>skb\\\\n\" ) ; return skb ; } NFCT_FRAG6_CB ( clone ) -> orig = skb ; if ( ! pskb_may_pull ( clone , fhoff + sizeof ( * fhdr ) ) ) { pr_debug ( \"message<S2SV_blank>is<S2SV_blank>too<S2SV_blank>short.\\\\n\" ) ; goto ret_orig ; } skb_set_transport_header ( clone , fhoff ) ; hdr = ipv6_hdr ( clone ) ; fhdr = ( struct frag_hdr * ) skb_transport_header ( clone ) ; <S2SV_StartBug> if ( ! ( fhdr -> frag_off & htons ( 0xFFF9 ) ) ) { <S2SV_EndBug> pr_debug ( \"Invalid<S2SV_blank>fragment<S2SV_blank>offset\\\\n\" ) ; goto ret_orig ; } if ( atomic_read ( & nf_init_frags . mem ) > nf_init_frags . high_thresh ) nf_ct_frag6_evictor ( ) ; fq = fq_find ( fhdr -> identification , user , & hdr -> saddr , & hdr -> daddr ) ; if ( fq == NULL ) { pr_debug ( \"Can\\'t<S2SV_blank>find<S2SV_blank>and<S2SV_blank>can\\'t<S2SV_blank>create<S2SV_blank>new<S2SV_blank>queue\\\\n\" ) ; goto ret_orig ; } spin_lock_bh ( & fq -> q . lock ) ; if ( nf_ct_frag6_queue ( fq , clone , fhdr , nhoff ) < 0 ) { spin_unlock_bh ( & fq -> q . lock ) ; pr_debug ( \"Can\\'t<S2SV_blank>insert<S2SV_blank>skb<S2SV_blank>to<S2SV_blank>queue\\\\n\" ) ; fq_put ( fq ) ; goto ret_orig ; } if ( fq -> q . last_in == ( INET_FRAG_FIRST_IN | INET_FRAG_LAST_IN ) && fq -> q . meat == fq -> q . len ) { ret_skb = nf_ct_frag6_reasm ( fq , dev ) ; if ( ret_skb == NULL ) pr_debug ( \"Can\\'t<S2SV_blank>reassemble<S2SV_blank>fragmented<S2SV_blank>packets\\\\n\" ) ; } spin_unlock_bh ( & fq -> q . lock ) ; fq_put ( fq ) ; return ret_skb ; ret_orig : kfree_skb ( clone ) ; return skb ; }\n",
      "fixed_code": "<S2SV_ModStart> ; if ( <S2SV_ModEnd> atomic_read ( &\n",
      "source_code_length": 2128,
      "target_code_length": 53,
      "vulnerability_patterns": {
        "use_after_free": 1,
        "null_pointer": 16,
        "sql_injection": 2,
        "total": 19
      },
      "total_patterns": 19,
      "original_address": "https://github.com/torvalds/linux/commit/9e2dcf72023d1447f09c47d77c99b0c49659e5ce",
      "discovery_time": "2012-08-09T10:29Z",
      "project_commit_id": "torvalds@linux/9e2dcf72023d1447f09c47d77c99b0c49659e5ce",
      "extraction_time": "2025-08-31T15:41:49.184733",
      "label": 1,
      "vulnerability_type": "unknown/uncategorized",
      "difficulty_level": "advanced",
      "risk_factors": [
        "sql_injection",
        "use_after_free"
      ],
      "attack_vectors": [
        "fuzzing",
        "code_analysis",
        "reverse_engineering"
      ],
      "mitigation_strategies": [
        "dynamic_analysis",
        "static_analysis",
        "fuzzing",
        "code_review",
        "secure_coding_practices"
      ],
      "code_differences": {
        "has_differences": true,
        "source_lines": 2,
        "target_lines": 2,
        "character_differences": 2075,
        "similarity_percentage": 5.319148936170213
      },
      "vulnerability_location": {
        "vulnerability_present": true,
        "fix_applied": true,
        "code_changed": true,
        "estimated_lines_changed": 0
      }
    },
    {
      "cve_id": "CVE-2016-5691",
      "cwe_id": "CWE-20",
      "cwe_name": "Improper Input Validation",
      "project": "ImageMagick",
      "severity": "critical",
      "weaponization_score": 8.0,
      "is_critical": true,
      "is_weaponizable": true,
      "is_high_priority_project": true,
      "vulnerable_code": "CWE-20 static Image * ReadDCMImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { char explicit_vr [ MagickPathExtent ] , implicit_vr [ MagickPathExtent ] , magick [ MagickPathExtent ] , photometric [ MagickPathExtent ] ; DCMStreamInfo * stream_info ; Image * image ; int * bluemap , datum , * greenmap , * graymap , index , * redmap ; MagickBooleanType explicit_file , explicit_retry , polarity , sequence , use_explicit ; MagickOffsetType offset ; Quantum * scale ; register ssize_t i , x ; register Quantum * q ; register unsigned char * p ; size_t bits_allocated , bytes_per_pixel , colors , depth , height , length , mask , max_value , number_scenes , quantum , samples_per_pixel , signed_data , significant_bits , status , width , window_width ; ssize_t count , rescale_intercept , rescale_slope , scene , window_center , y ; unsigned char * data ; unsigned short group , element ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickCoreSignature ) ; if ( image_info -> debug != MagickFalse ) ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , \"%s\" , image_info -> filename ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickCoreSignature ) ; image = AcquireImage ( image_info , exception ) ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } image -> depth = 8UL ; image -> endian = LSBEndian ; stream_info = ( DCMStreamInfo * ) AcquireMagickMemory ( sizeof ( * stream_info ) ) ; if ( stream_info == ( DCMStreamInfo * ) NULL ) ThrowReaderException ( ResourceLimitError , \"MemoryAllocationFailed\" ) ; ( void ) ResetMagickMemory ( stream_info , 0 , sizeof ( * stream_info ) ) ; count = ReadBlob ( image , 128 , ( unsigned char * ) magick ) ; if ( count != 128 ) ThrowReaderException ( CorruptImageError , \"ImproperImageHeader\" ) ; count = ReadBlob ( image , 4 , ( unsigned char * ) magick ) ; if ( ( count != 4 ) || ( LocaleNCompare ( magick , \"DICM\" , 4 ) != 0 ) ) { offset = SeekBlob ( image , 0L , SEEK_SET ) ; if ( offset < 0 ) ThrowReaderException ( CorruptImageError , \"ImproperImageHeader\" ) ; } ( void ) CopyMagickString ( photometric , \"MONOCHROME1<S2SV_blank>\" , MagickPathExtent ) ; bits_allocated = 8 ; bytes_per_pixel = 1 ; polarity = MagickFalse ; data = ( unsigned char * ) NULL ; depth = 8 ; element = 0 ; explicit_vr [ 2 ] = '\\\\0' ; explicit_file = MagickFalse ; colors = 0 ; redmap = ( int * ) NULL ; greenmap = ( int * ) NULL ; bluemap = ( int * ) NULL ; graymap = ( int * ) NULL ; height = 0 ; max_value = 255UL ; mask = 0xffff ; number_scenes = 1 ; rescale_intercept = 0 ; rescale_slope = 1 ; samples_per_pixel = 1 ; scale = ( Quantum * ) NULL ; sequence = MagickFalse ; signed_data = ( ~ 0UL ) ; significant_bits = 0 ; use_explicit = MagickFalse ; explicit_retry = MagickFalse ; width = 0 ; window_center = 0 ; window_width = 0 ; for ( group = 0 ; ( group != 0x7FE0 ) || ( element != 0x0010 ) || ( sequence != MagickFalse ) ; ) { image -> offset = ( ssize_t ) TellBlob ( image ) ; group = ReadBlobLSBShort ( image ) ; element = ReadBlobLSBShort ( image ) ; if ( ( group != 0x0002 ) && ( image -> endian == MSBEndian ) ) { group = ( unsigned short ) ( ( group << 8 ) | ( ( group >> 8 ) & 0xFF ) ) ; element = ( unsigned short ) ( ( element << 8 ) | ( ( element >> 8 ) & 0xFF ) ) ; } quantum = 0 ; for ( i = 0 ; dicom_info [ i ] . group < 0xffff ; i ++ ) if ( ( group == dicom_info [ i ] . group ) && ( element == dicom_info [ i ] . element ) ) break ; ( void ) CopyMagickString ( implicit_vr , dicom_info [ i ] . vr , MagickPathExtent ) ; count = ReadBlob ( image , 2 , ( unsigned char * ) explicit_vr ) ; if ( count != 2 ) ThrowReaderException ( CorruptImageError , \"ImproperImageHeader\" ) ; if ( ( explicit_file == MagickFalse ) && ( group != 0x0002 ) ) explicit_file = ( isupper ( ( unsigned char ) * explicit_vr ) != MagickFalse ) && ( isupper ( ( unsigned char ) * ( explicit_vr + 1 ) ) != MagickFalse ) ? MagickTrue : MagickFalse ; use_explicit = ( ( group == 0x0002 ) && ( explicit_retry == MagickFalse ) ) || ( explicit_file != MagickFalse ) ? MagickTrue : MagickFalse ; if ( ( use_explicit != MagickFalse ) && ( strncmp ( implicit_vr , \"xs\" , 2 ) == 0 ) ) ( void ) CopyMagickString ( implicit_vr , explicit_vr , MagickPathExtent ) ; if ( ( use_explicit == MagickFalse ) || ( strncmp ( implicit_vr , \"!!\" , 2 ) == 0 ) ) { offset = SeekBlob ( image , ( MagickOffsetType ) - 2 , SEEK_CUR ) ; if ( offset < 0 ) ThrowReaderException ( CorruptImageError , \"ImproperImageHeader\" ) ; quantum = 4 ; } else { quantum = 2 ; if ( ( strncmp ( explicit_vr , \"OB\" , 2 ) == 0 ) || ( strncmp ( explicit_vr , \"UN\" , 2 ) == 0 ) || ( strncmp ( explicit_vr , \"OW\" , 2 ) == 0 ) || ( strncmp ( explicit_vr , \"SQ\" , 2 ) == 0 ) ) { ( void ) ReadBlobLSBShort ( image ) ; quantum = 4 ; } } datum = 0 ; if ( quantum == 4 ) { if ( group == 0x0002 ) datum = ReadBlobLSBSignedLong ( image ) ; else datum = ReadBlobSignedLong ( image ) ; } else if ( quantum == 2 ) { if ( group == 0x0002 ) datum = ReadBlobLSBSignedShort ( image ) ; else datum = ReadBlobSignedShort ( image ) ; } quantum = 0 ; length = 1 ; if ( datum != 0 ) { if ( ( strncmp ( implicit_vr , \"SS\" , 2 ) == 0 ) || ( strncmp ( implicit_vr , \"US\" , 2 ) == 0 ) ) quantum = 2 ; else if ( ( strncmp ( implicit_vr , \"UL\" , 2 ) == 0 ) || ( strncmp ( implicit_vr , \"SL\" , 2 ) == 0 ) || ( strncmp ( implicit_vr , \"FL\" , 2 ) == 0 ) ) quantum = 4 ; else if ( strncmp ( implicit_vr , \"FD\" , 2 ) != 0 ) quantum = 1 ; else quantum = 8 ; if ( datum != ~ 0 ) length = ( size_t ) datum / quantum ; else { quantum = 0 ; length = 0 ; } } if ( image_info -> verbose != MagickFalse ) { if ( use_explicit == MagickFalse ) explicit_vr [ 0 ] = '\\\\0' ; for ( i = 0 ; dicom_info [ i ] . description != ( char * ) NULL ; i ++ ) if ( ( group == dicom_info [ i ] . group ) && ( element == dicom_info [ i ] . element ) ) break ; ( void ) FormatLocaleFile ( stdout , \"0x%04lX<S2SV_blank>%4ld<S2SV_blank>%s-%s<S2SV_blank>(0x%04lx,0x%04lx)\" , ( unsigned long ) image -> offset , ( long ) length , implicit_vr , explicit_vr , ( unsigned long ) group , ( unsigned long ) element ) ; if ( dicom_info [ i ] . description != ( char * ) NULL ) ( void ) FormatLocaleFile ( stdout , \"<S2SV_blank>%s\" , dicom_info [ i ] . description ) ; ( void ) FormatLocaleFile ( stdout , \":<S2SV_blank>\" ) ; } if ( ( sequence == MagickFalse ) && ( group == 0x7FE0 ) && ( element == 0x0010 ) ) { if ( image_info -> verbose != MagickFalse ) ( void ) FormatLocaleFile ( stdout , \"\\\\n\" ) ; break ; } data = ( unsigned char * ) NULL ; if ( ( length == 1 ) && ( quantum == 1 ) ) datum = ReadBlobByte ( image ) ; else if ( ( length == 1 ) && ( quantum == 2 ) ) { if ( group == 0x0002 ) datum = ReadBlobLSBSignedShort ( image ) ; else datum = ReadBlobSignedShort ( image ) ; } else if ( ( length == 1 ) && ( quantum == 4 ) ) { if ( group == 0x0002 ) datum = ReadBlobLSBSignedLong ( image ) ; else datum = ReadBlobSignedLong ( image ) ; } else if ( ( quantum != 0 ) && ( length != 0 ) ) { if ( ~ length >= 1 ) data = ( unsigned char * ) AcquireQuantumMemory ( length + 1 , quantum * sizeof ( * data ) ) ; if ( data == ( unsigned char * ) NULL ) ThrowReaderException ( ResourceLimitError , \"MemoryAllocationFailed\" ) ; count = ReadBlob ( image , ( size_t ) quantum * length , data ) ; if ( count != ( ssize_t ) ( quantum * length ) ) { if ( image_info -> verbose != MagickFalse ) ( void ) FormatLocaleFile ( stdout , \"count=%d<S2SV_blank>quantum=%d<S2SV_blank>\" \"length=%d<S2SV_blank>group=%d\\\\n\" , ( int ) count , ( int ) quantum , ( int ) length , ( int ) group ) ; ThrowReaderException ( CorruptImageError , \"InsufficientImageDataInFile\" ) ; } data [ length * quantum ] = '\\\\0' ; } else if ( ( unsigned int ) datum == 0xFFFFFFFFU ) { sequence = MagickTrue ; continue ; } if ( ( unsigned int ) ( ( group << 16 ) | element ) == 0xFFFEE0DD ) { if ( data != ( unsigned char * ) NULL ) data = ( unsigned char * ) RelinquishMagickMemory ( data ) ; sequence = MagickFalse ; continue ; } if ( sequence != MagickFalse ) { if ( data != ( unsigned char * ) NULL ) data = ( unsigned char * ) RelinquishMagickMemory ( data ) ; continue ; } switch ( group ) { case 0x0002 : { switch ( element ) { case 0x0010 : { char transfer_syntax [ MagickPathExtent ] ; if ( ( datum == 0 ) && ( explicit_retry == MagickFalse ) ) { explicit_retry = MagickTrue ; ( void ) SeekBlob ( image , ( MagickOffsetType ) 0 , SEEK_SET ) ; group = 0 ; element = 0 ; if ( image_info -> verbose != MagickFalse ) ( void ) FormatLocaleFile ( stdout , \"Corrupted<S2SV_blank>image<S2SV_blank>-<S2SV_blank>trying<S2SV_blank>explicit<S2SV_blank>format\\\\n\" ) ; break ; } * transfer_syntax = '\\\\0' ; if ( data != ( unsigned char * ) NULL ) ( void ) CopyMagickString ( transfer_syntax , ( char * ) data , MagickPathExtent ) ; if ( image_info -> verbose != MagickFalse ) ( void ) FormatLocaleFile ( stdout , \"transfer_syntax=%s\\\\n\" , ( const char * ) transfer_syntax ) ; if ( strncmp ( transfer_syntax , \"1.2.840.10008.1.2\" , 17 ) == 0 ) { int count , subtype , type ; type = 1 ; subtype = 0 ; if ( strlen ( transfer_syntax ) > 17 ) { count = sscanf ( transfer_syntax + 17 , \".%d.%d\" , & type , & subtype ) ; if ( count < 1 ) ThrowReaderException ( CorruptImageError , \"ImproperImageHeader\" ) ; } switch ( type ) { case 1 : { image -> endian = LSBEndian ; break ; } case 2 : { image -> endian = MSBEndian ; break ; } case 4 : { if ( ( subtype >= 80 ) && ( subtype <= 81 ) ) image -> compression = JPEGCompression ; else if ( ( subtype >= 90 ) && ( subtype <= 93 ) ) image -> compression = JPEG2000Compression ; else image -> compression = JPEGCompression ; break ; } case 5 : { image -> compression = RLECompression ; break ; } } } break ; } default : break ; } break ; } case 0x0028 : { switch ( element ) { case 0x0002 : { samples_per_pixel = ( size_t ) datum ; break ; } case 0x0004 : { <S2SV_StartBug> for ( i = 0 ; i < ( ssize_t ) MagickMin ( length , MagickPathExtent - 1 ) ; i ++ ) <S2SV_EndBug> photometric [ i ] = ( char ) data [ i ] ; photometric [ i ] = '\\\\0' ; polarity = LocaleCompare ( photometric , \"MONOCHROME1<S2SV_blank>\" ) == 0 ? MagickTrue : MagickFalse ; break ; } case 0x0006 : { if ( datum == 1 ) image -> interlace = PlaneInterlace ; break ; } case 0x0008 : <S2SV_StartBug> { <S2SV_EndBug> number_scenes = StringToUnsignedLong ( ( char * ) data ) ; break ; } case 0x0010 : { height = ( size_t ) datum ; break ; } case 0x0011 : { width = ( size_t ) datum ; break ; } case 0x0100 : { bits_allocated = ( size_t ) datum ; bytes_per_pixel = 1 ; if ( datum > 8 ) bytes_per_pixel = 2 ; depth = bits_allocated ; if ( depth > 32 ) ThrowReaderException ( CorruptImageError , \"ImproperImageHeader\" ) ; max_value = ( 1UL << bits_allocated ) - 1 ; break ; } case 0x0101 : { significant_bits = ( size_t ) datum ; bytes_per_pixel = 1 ; if ( significant_bits > 8 ) bytes_per_pixel = 2 ; depth = significant_bits ; if ( depth > 32 ) ThrowReaderException ( CorruptImageError , \"ImproperImageHeader\" ) ; max_value = ( 1UL << significant_bits ) - 1 ; mask = ( size_t ) GetQuantumRange ( significant_bits ) ; break ; } case 0x0102 : { break ; } case 0x0103 : { signed_data = ( size_t ) datum ; break ; } case 0x1050 : { if ( data != ( unsigned char * ) NULL ) window_center = ( ssize_t ) StringToLong ( ( char * ) data ) ; break ; } case 0x1051 : { if ( data != ( unsigned char * ) NULL ) window_width = StringToUnsignedLong ( ( char * ) data ) ; break ; } case 0x1052 : { if ( data != ( unsigned char * ) NULL ) rescale_intercept = ( ssize_t ) StringToLong ( ( char * ) data ) ; break ; } case 0x1053 : { if ( data != ( unsigned char * ) NULL ) rescale_slope = ( ssize_t ) StringToLong ( ( char * ) data ) ; break ; } case 0x1200 : case 0x3006 : { if ( data == ( unsigned char * ) NULL ) break ; colors = ( size_t ) ( length / bytes_per_pixel ) ; datum = ( int ) colors ; graymap = ( int * ) AcquireQuantumMemory ( ( size_t ) colors , sizeof ( * graymap ) ) ; if ( graymap == ( int * ) NULL ) ThrowReaderException ( ResourceLimitError , \"MemoryAllocationFailed\" ) ; for ( i = 0 ; i < ( ssize_t ) colors ; i ++ ) if ( bytes_per_pixel == 1 ) graymap [ i ] = ( int ) data [ i ] ; else graymap [ i ] = ( int ) ( ( short * ) data ) [ i ] ; break ; } case 0x1201 : { unsigned short index ; if ( data == ( unsigned char * ) NULL ) break ; colors = ( size_t ) ( length / 2 ) ; datum = ( int ) colors ; redmap = ( int * ) AcquireQuantumMemory ( ( size_t ) colors , sizeof ( * redmap ) ) ; if ( redmap == ( int * ) NULL ) ThrowReaderException ( ResourceLimitError , \"MemoryAllocationFailed\" ) ; p = data ; for ( i = 0 ; i < ( ssize_t ) colors ; i ++ ) { if ( image -> endian == MSBEndian ) index = ( unsigned short ) ( ( * p << 8 ) | * ( p + 1 ) ) ; else index = ( unsigned short ) ( * p | ( * ( p + 1 ) << 8 ) ) ; redmap [ i ] = ( int ) index ; p += 2 ; } break ; } case 0x1202 : { unsigned short index ; if ( data == ( unsigned char * ) NULL ) break ; colors = ( size_t ) ( length / 2 ) ; datum = ( int ) colors ; greenmap = ( int * ) AcquireQuantumMemory ( ( size_t ) colors , sizeof ( * greenmap ) ) ; if ( greenmap == ( int * ) NULL ) ThrowReaderException ( ResourceLimitError , \"MemoryAllocationFailed\" ) ; p = data ; for ( i = 0 ; i < ( ssize_t ) colors ; i ++ ) { if ( image -> endian == MSBEndian ) index = ( unsigned short ) ( ( * p << 8 ) | * ( p + 1 ) ) ; else index = ( unsigned short ) ( * p | ( * ( p + 1 ) << 8 ) ) ; greenmap [ i ] = ( int ) index ; p += 2 ; } break ; } case 0x1203 : { unsigned short index ; if ( data == ( unsigned char * ) NULL ) break ; colors = ( size_t ) ( length / 2 ) ; datum = ( int ) colors ; bluemap = ( int * ) AcquireQuantumMemory ( ( size_t ) colors , sizeof ( * bluemap ) ) ; if ( bluemap == ( int * ) NULL ) ThrowReaderException ( ResourceLimitError , \"MemoryAllocationFailed\" ) ; p = data ; for ( i = 0 ; i < ( ssize_t ) colors ; i ++ ) { if ( image -> endian == MSBEndian ) index = ( unsigned short ) ( ( * p << 8 ) | * ( p + 1 ) ) ; else index = ( unsigned short ) ( * p | ( * ( p + 1 ) << 8 ) ) ; bluemap [ i ] = ( int ) index ; p += 2 ; } break ; } default : break ; } break ; } case 0x2050 : { switch ( element ) { case 0x0020 : { if ( ( data != ( unsigned char * ) NULL ) && ( strncmp ( ( char * ) data , \"INVERSE\" , 7 ) == 0 ) ) polarity = MagickTrue ; break ; } default : break ; } break ; } default : break ; } if ( data != ( unsigned char * ) NULL ) { char * attribute ; for ( i = 0 ; dicom_info [ i ] . description != ( char * ) NULL ; i ++ ) if ( ( group == dicom_info [ i ] . group ) && ( element == dicom_info [ i ] . element ) ) break ; if ( dicom_info [ i ] . description != ( char * ) NULL ) { attribute = AcquireString ( \"dcm:\" ) ; ( void ) ConcatenateString ( & attribute , dicom_info [ i ] . description ) ; for ( i = 0 ; i < ( ssize_t ) MagickMax ( length , 4 ) ; i ++ ) if ( isprint ( ( int ) data [ i ] ) == MagickFalse ) break ; if ( ( i == ( ssize_t ) length ) || ( length > 4 ) ) { ( void ) SubstituteString ( & attribute , \"<S2SV_blank>\" , \"\" ) ; ( void ) SetImageProperty ( image , attribute , ( char * ) data , exception ) ; } attribute = DestroyString ( attribute ) ; } } if ( image_info -> verbose != MagickFalse ) { if ( data == ( unsigned char * ) NULL ) ( void ) FormatLocaleFile ( stdout , \"%d\\\\n\" , datum ) ; else { for ( i = 0 ; i < ( ssize_t ) MagickMax ( length , 4 ) ; i ++ ) if ( isprint ( ( int ) data [ i ] ) == MagickFalse ) break ; if ( ( i != ( ssize_t ) length ) && ( length <= 4 ) ) { ssize_t j ; datum = 0 ; for ( j = ( ssize_t ) length - 1 ; j >= 0 ; j -- ) datum = ( 256 * datum + data [ j ] ) ; ( void ) FormatLocaleFile ( stdout , \"%d\" , datum ) ; } else for ( i = 0 ; i < ( ssize_t ) length ; i ++ ) if ( isprint ( ( int ) data [ i ] ) != MagickFalse ) ( void ) FormatLocaleFile ( stdout , \"%c\" , data [ i ] ) ; else ( void ) FormatLocaleFile ( stdout , \"%c\" , '.' ) ; ( void ) FormatLocaleFile ( stdout , \"\\\\n\" ) ; } } if ( data != ( unsigned char * ) NULL ) data = ( unsigned char * ) RelinquishMagickMemory ( data ) ; if ( EOFBlob ( image ) != MagickFalse ) { ThrowFileException ( exception , CorruptImageError , \"UnexpectedEndOfFile\" , image -> filename ) ; break ; } } if ( ( width == 0 ) || ( height == 0 ) ) ThrowReaderException ( CorruptImageError , \"ImproperImageHeader\" ) ; image -> columns = ( size_t ) width ; image -> rows = ( size_t ) height ; if ( signed_data == 0xffff ) signed_data = ( size_t ) ( significant_bits == 16 ? 1 : 0 ) ; if ( ( image -> compression == JPEGCompression ) || ( image -> compression == JPEG2000Compression ) ) { Image * images ; ImageInfo * read_info ; int c ; size_t length ; unsigned int tag ; for ( i = 0 ; i < ( ssize_t ) stream_info -> remaining ; i ++ ) ( void ) ReadBlobByte ( image ) ; tag = ( ReadBlobLSBShort ( image ) << 16 ) | ReadBlobLSBShort ( image ) ; ( void ) tag ; length = ( size_t ) ReadBlobLSBLong ( image ) ; stream_info -> offset_count = length >> 2 ; if ( stream_info -> offset_count != 0 ) { MagickOffsetType offset ; stream_info -> offsets = ( ssize_t * ) AcquireQuantumMemory ( stream_info -> offset_count , sizeof ( * stream_info -> offsets ) ) ; if ( stream_info -> offsets == ( ssize_t * ) NULL ) ThrowReaderException ( ResourceLimitError , \"MemoryAllocationFailed\" ) ; for ( i = 0 ; i < ( ssize_t ) stream_info -> offset_count ; i ++ ) stream_info -> offsets [ i ] = ( ssize_t ) ReadBlobLSBSignedLong ( image ) ; offset = TellBlob ( image ) ; for ( i = 0 ; i < ( ssize_t ) stream_info -> offset_count ; i ++ ) stream_info -> offsets [ i ] += offset ; } read_info = CloneImageInfo ( image_info ) ; SetImageInfoBlob ( read_info , ( void * ) NULL , 0 ) ; images = NewImageList ( ) ; for ( scene = 0 ; scene < ( ssize_t ) number_scenes ; scene ++ ) { char filename [ MagickPathExtent ] ; const char * property ; FILE * file ; Image * jpeg_image ; int unique_file ; unsigned int tag ; tag = ( ReadBlobLSBShort ( image ) << 16 ) | ReadBlobLSBShort ( image ) ; length = ( size_t ) ReadBlobLSBLong ( image ) ; if ( tag == 0xFFFEE0DD ) break ; if ( tag != 0xFFFEE000 ) ThrowReaderException ( CorruptImageError , \"ImproperImageHeader\" ) ; file = ( FILE * ) NULL ; unique_file = AcquireUniqueFileResource ( filename ) ; if ( unique_file != - 1 ) file = fdopen ( unique_file , \"wb\" ) ; if ( file == ( FILE * ) NULL ) { ( void ) RelinquishUniqueFileResource ( filename ) ; ThrowFileException ( exception , FileOpenError , \"UnableToCreateTemporaryFile\" , filename ) ; break ; } for ( ; length != 0 ; length -- ) { c = ReadBlobByte ( image ) ; if ( c == EOF ) { ThrowFileException ( exception , CorruptImageError , \"UnexpectedEndOfFile\" , image -> filename ) ; break ; } ( void ) fputc ( c , file ) ; } ( void ) fclose ( file ) ; ( void ) FormatLocaleString ( read_info -> filename , MagickPathExtent , \"jpeg:%s\" , filename ) ; if ( image -> compression == JPEG2000Compression ) ( void ) FormatLocaleString ( read_info -> filename , MagickPathExtent , \"j2k:%s\" , filename ) ; jpeg_image = ReadImage ( read_info , exception ) ; if ( jpeg_image != ( Image * ) NULL ) { ResetImagePropertyIterator ( image ) ; property = GetNextImageProperty ( image ) ; while ( property != ( const char * ) NULL ) { ( void ) SetImageProperty ( jpeg_image , property , GetImageProperty ( image , property , exception ) , exception ) ; property = GetNextImageProperty ( image ) ; } AppendImageToList ( & images , jpeg_image ) ; } ( void ) RelinquishUniqueFileResource ( filename ) ; } read_info = DestroyImageInfo ( read_info ) ; image = DestroyImage ( image ) ; return ( GetFirstImageInList ( images ) ) ; } if ( depth != ( 1UL * MAGICKCORE_QUANTUM_DEPTH ) ) { QuantumAny range ; size_t length ; length = ( size_t ) ( GetQuantumRange ( depth ) + 1 ) ; scale = ( Quantum * ) AcquireQuantumMemory ( length , sizeof ( * scale ) ) ; if ( scale == ( Quantum * ) NULL ) ThrowReaderException ( ResourceLimitError , \"MemoryAllocationFailed\" ) ; range = GetQuantumRange ( depth ) ; <S2SV_StartBug> for ( i = 0 ; i < ( ssize_t ) ( GetQuantumRange ( depth ) + 1 ) ; i ++ ) <S2SV_EndBug> scale [ i ] = ScaleAnyToQuantum ( ( size_t ) i , range ) ; } if ( image -> compression == RLECompression ) { size_t length ; unsigned int tag ; for ( i = 0 ; i < ( ssize_t ) stream_info -> remaining ; i ++ ) ( void ) ReadBlobByte ( image ) ; tag = ( ReadBlobLSBShort ( image ) << 16 ) | ReadBlobLSBShort ( image ) ; ( void ) tag ; length = ( size_t ) ReadBlobLSBLong ( image ) ; stream_info -> offset_count = length >> 2 ; if ( stream_info -> offset_count != 0 ) { MagickOffsetType offset ; stream_info -> offsets = ( ssize_t * ) AcquireQuantumMemory ( stream_info -> offset_count , sizeof ( * stream_info -> offsets ) ) ; if ( stream_info -> offsets == ( ssize_t * ) NULL ) ThrowReaderException ( ResourceLimitError , \"MemoryAllocationFailed\" ) ; for ( i = 0 ; i < ( ssize_t ) stream_info -> offset_count ; i ++ ) stream_info -> offsets [ i ] = ( ssize_t ) ReadBlobLSBSignedLong ( image ) ; offset = TellBlob ( image ) ; for ( i = 0 ; i < ( ssize_t ) stream_info -> offset_count ; i ++ ) stream_info -> offsets [ i ] += offset ; } } for ( scene = 0 ; scene < ( ssize_t ) number_scenes ; scene ++ ) { if ( image_info -> ping != MagickFalse ) break ; image -> columns = ( size_t ) width ; image -> rows = ( size_t ) height ; image -> depth = depth ; status = SetImageExtent ( image , image -> columns , image -> rows , exception ) ; if ( status == MagickFalse ) break ; image -> colorspace = RGBColorspace ; if ( ( image -> colormap == ( PixelInfo * ) NULL ) && ( samples_per_pixel == 1 ) ) { size_t one ; one = 1 ; if ( colors == 0 ) colors = one << depth ; if ( AcquireImageColormap ( image , one << depth , exception ) == MagickFalse ) ThrowReaderException ( ResourceLimitError , \"MemoryAllocationFailed\" ) ; if ( redmap != ( int * ) NULL ) for ( i = 0 ; i < ( ssize_t ) colors ; i ++ ) { index = redmap [ i ] ; if ( ( scale != ( Quantum * ) NULL ) && ( index <= ( int ) max_value ) ) index = ( int ) scale [ index ] ; image -> colormap [ i ] . red = ( MagickRealType ) index ; } if ( greenmap != ( int * ) NULL ) for ( i = 0 ; i < ( ssize_t ) colors ; i ++ ) { index = greenmap [ i ] ; if ( ( scale != ( Quantum * ) NULL ) && ( index <= ( int ) max_value ) ) index = ( int ) scale [ index ] ; image -> colormap [ i ] . green = ( MagickRealType ) index ; } if ( bluemap != ( int * ) NULL ) for ( i = 0 ; i < ( ssize_t ) colors ; i ++ ) { index = bluemap [ i ] ; if ( ( scale != ( Quantum * ) NULL ) && ( index <= ( int ) max_value ) ) index = ( int ) scale [ index ] ; image -> colormap [ i ] . blue = ( MagickRealType ) index ; } if ( graymap != ( int * ) NULL ) for ( i = 0 ; i < ( ssize_t ) colors ; i ++ ) { index = graymap [ i ] ; if ( ( scale != ( Quantum * ) NULL ) && ( index <= ( int ) max_value ) ) index = ( int ) scale [ index ] ; image -> colormap [ i ] . red = ( MagickRealType ) index ; image -> colormap [ i ] . green = ( MagickRealType ) index ; image -> colormap [ i ] . blue = ( MagickRealType ) index ; } } if ( image -> compression == RLECompression ) { unsigned int tag ; for ( i = 0 ; i < ( ssize_t ) stream_info -> remaining ; i ++ ) ( void ) ReadBlobByte ( image ) ; tag = ( ReadBlobLSBShort ( image ) << 16 ) | ReadBlobLSBShort ( image ) ; stream_info -> remaining = ( size_t ) ReadBlobLSBLong ( image ) ; if ( ( tag != 0xFFFEE000 ) || ( stream_info -> remaining <= 64 ) || ( EOFBlob ( image ) != MagickFalse ) ) ThrowReaderException ( CorruptImageError , \"ImproperImageHeader\" ) ; stream_info -> count = 0 ; stream_info -> segment_count = ReadBlobLSBLong ( image ) ; if ( stream_info -> segment_count > 1 ) { bytes_per_pixel = 1 ; depth = 8 ; } for ( i = 0 ; i < 15 ; i ++ ) stream_info -> segments [ i ] = ( ssize_t ) ReadBlobLSBSignedLong ( image ) ; stream_info -> remaining -= 64 ; } if ( ( samples_per_pixel > 1 ) && ( image -> interlace == PlaneInterlace ) ) { for ( i = 0 ; i < ( ssize_t ) samples_per_pixel ; i ++ ) { for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { q = GetAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { switch ( ( int ) i ) { case 0 : { SetPixelRed ( image , ScaleCharToQuantum ( ( unsigned char ) ReadDCMByte ( stream_info , image ) ) , q ) ; break ; } case 1 : { SetPixelGreen ( image , ScaleCharToQuantum ( ( unsigned char ) ReadDCMByte ( stream_info , image ) ) , q ) ; break ; } case 2 : { SetPixelBlue ( image , ScaleCharToQuantum ( ( unsigned char ) ReadDCMByte ( stream_info , image ) ) , q ) ; break ; } case 3 : { SetPixelAlpha ( image , ScaleCharToQuantum ( ( unsigned char ) ReadDCMByte ( stream_info , image ) ) , q ) ; break ; } default : break ; } q += GetPixelChannels ( image ) ; } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ; if ( status == MagickFalse ) break ; } } } } else { const char * option ; int byte ; PixelPacket pixel ; byte = 0 ; i = 0 ; if ( ( window_center != 0 ) && ( window_width == 0 ) ) window_width = ( size_t ) window_center ; option = GetImageOption ( image_info , \"dcm:display-range\" ) ; if ( option != ( const char * ) NULL ) { if ( LocaleCompare ( option , \"reset\" ) == 0 ) window_width = 0 ; } ( void ) ResetMagickMemory ( & pixel , 0 , sizeof ( pixel ) ) ; for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { if ( samples_per_pixel == 1 ) { int pixel_value ; if ( bytes_per_pixel == 1 ) pixel_value = polarity != MagickFalse ? ( ( int ) max_value - ReadDCMByte ( stream_info , image ) ) : ReadDCMByte ( stream_info , image ) ; else if ( ( bits_allocated != 12 ) || ( significant_bits != 12 ) ) { if ( signed_data ) pixel_value = ReadDCMSignedShort ( stream_info , image ) ; else pixel_value = ReadDCMShort ( stream_info , image ) ; if ( polarity != MagickFalse ) pixel_value = ( int ) max_value - pixel_value ; } else { if ( ( i & 0x01 ) != 0 ) pixel_value = ( ReadDCMByte ( stream_info , image ) << 8 ) | byte ; else { pixel_value = ReadDCMSignedShort ( stream_info , image ) ; byte = ( int ) ( pixel_value & 0x0f ) ; pixel_value >>= 4 ; } i ++ ; } index = ( pixel_value * rescale_slope ) + rescale_intercept ; if ( window_width == 0 ) { if ( signed_data == 1 ) index -= 32767 ; } else { ssize_t window_max , window_min ; window_min = ( ssize_t ) ceil ( ( double ) window_center - ( window_width - 1.0 ) / 2.0 - 0.5 ) ; window_max = ( ssize_t ) floor ( ( double ) window_center + ( window_width - 1.0 ) / 2.0 + 0.5 ) ; if ( ( ssize_t ) index <= window_min ) index = 0 ; else if ( ( ssize_t ) index > window_max ) index = ( int ) max_value ; else index = ( int ) ( max_value * ( ( ( index - window_center - 0.5 ) / ( window_width - 1 ) ) + 0.5 ) ) ; } index &= mask ; index = ( int ) ConstrainColormapIndex ( image , ( size_t ) index , exception ) ; SetPixelIndex ( image , ( Quantum ) index , q ) ; pixel . red = ( unsigned int ) image -> colormap [ index ] . red ; pixel . green = ( unsigned int ) image -> colormap [ index ] . green ; pixel . blue = ( unsigned int ) image -> colormap [ index ] . blue ; } else { if ( bytes_per_pixel == 1 ) { pixel . red = ( unsigned int ) ReadDCMByte ( stream_info , image ) ; pixel . green = ( unsigned int ) ReadDCMByte ( stream_info , image ) ; pixel . blue = ( unsigned int ) ReadDCMByte ( stream_info , image ) ; } else { pixel . red = ReadDCMShort ( stream_info , image ) ; pixel . green = ReadDCMShort ( stream_info , image ) ; pixel . blue = ReadDCMShort ( stream_info , image ) ; } pixel . red &= mask ; pixel . green &= mask ; pixel . blue &= mask ; if ( scale != ( Quantum * ) NULL ) { <S2SV_StartBug> pixel . red = scale [ pixel . red ] ; <S2SV_EndBug> <S2SV_StartBug> pixel . green = scale [ pixel . green ] ; <S2SV_EndBug> <S2SV_StartBug> pixel . blue = scale [ pixel . blue ] ; <S2SV_EndBug> } } SetPixelRed ( image , ( Quantum ) pixel . red , q ) ; SetPixelGreen ( image , ( Quantum ) pixel . green , q ) ; SetPixelBlue ( image , ( Quantum ) pixel . blue , q ) ; q += GetPixelChannels ( image ) ; } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ; if ( status == MagickFalse ) break ; } } if ( stream_info -> segment_count > 1 ) for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { if ( samples_per_pixel == 1 ) { int pixel_value ; if ( bytes_per_pixel == 1 ) pixel_value = polarity != MagickFalse ? ( ( int ) max_value - ReadDCMByte ( stream_info , image ) ) : ReadDCMByte ( stream_info , image ) ; else if ( ( bits_allocated != 12 ) || ( significant_bits != 12 ) ) { pixel_value = ( int ) ( polarity != MagickFalse ? ( max_value - ReadDCMShort ( stream_info , image ) ) : ReadDCMShort ( stream_info , image ) ) ; if ( signed_data == 1 ) pixel_value = ( ( signed short ) pixel_value ) ; } else { if ( ( i & 0x01 ) != 0 ) pixel_value = ( ReadDCMByte ( stream_info , image ) << 8 ) | byte ; else { pixel_value = ReadDCMShort ( stream_info , image ) ; byte = ( int ) ( pixel_value & 0x0f ) ; pixel_value >>= 4 ; } i ++ ; } index = ( pixel_value * rescale_slope ) + rescale_intercept ; if ( window_width == 0 ) { if ( signed_data == 1 ) index -= 32767 ; } else { ssize_t window_max , window_min ; window_min = ( ssize_t ) ceil ( ( double ) window_center - ( window_width - 1.0 ) / 2.0 - 0.5 ) ; window_max = ( ssize_t ) floor ( ( double ) window_center + ( window_width - 1.0 ) / 2.0 + 0.5 ) ; if ( ( ssize_t ) index <= window_min ) index = 0 ; else if ( ( ssize_t ) index > window_max ) index = ( int ) max_value ; else index = ( int ) ( max_value * ( ( ( index - window_center - 0.5 ) / ( window_width - 1 ) ) + 0.5 ) ) ; } index &= mask ; index = ( int ) ConstrainColormapIndex ( image , ( size_t ) index , exception ) ; SetPixelIndex ( image , ( Quantum ) ( ( ( size_t ) GetPixelIndex ( image , q ) ) | ( ( ( size_t ) index ) << 8 ) ) , q ) ; pixel . red = ( unsigned int ) image -> colormap [ index ] . red ; pixel . green = ( unsigned int ) image -> colormap [ index ] . green ; pixel . blue = ( unsigned int ) image -> colormap [ index ] . blue ; } else { if ( bytes_per_pixel == 1 ) { pixel . red = ( unsigned int ) ReadDCMByte ( stream_info , image ) ; pixel . green = ( unsigned int ) ReadDCMByte ( stream_info , image ) ; pixel . blue = ( unsigned int ) ReadDCMByte ( stream_info , image ) ; } else { pixel . red = ReadDCMShort ( stream_info , image ) ; pixel . green = ReadDCMShort ( stream_info , image ) ; pixel . blue = ReadDCMShort ( stream_info , image ) ; } pixel . red &= mask ; pixel . green &= mask ; pixel . blue &= mask ; if ( scale != ( Quantum * ) NULL ) { pixel . red = scale [ pixel . red ] ; pixel . green = scale [ pixel . green ] ; pixel . blue = scale [ pixel . blue ] ; } } SetPixelRed ( image , ( Quantum ) ( ( ( size_t ) GetPixelRed ( image , q ) ) | ( ( ( size_t ) pixel . red ) << 8 ) ) , q ) ; SetPixelGreen ( image , ( Quantum ) ( ( ( size_t ) GetPixelGreen ( image , q ) ) | ( ( ( size_t ) pixel . green ) << 8 ) ) , q ) ; SetPixelBlue ( image , ( Quantum ) ( ( ( size_t ) GetPixelBlue ( image , q ) ) | ( ( ( size_t ) pixel . blue ) << 8 ) ) , q ) ; q += GetPixelChannels ( image ) ; } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ; if ( status == MagickFalse ) break ; } } } if ( SetImageGray ( image , exception ) != MagickFalse ) ( void ) SetImageColorspace ( image , GRAYColorspace , exception ) ; if ( EOFBlob ( image ) != MagickFalse ) { ThrowFileException ( exception , CorruptImageError , \"UnexpectedEndOfFile\" , image -> filename ) ; break ; } if ( image_info -> number_scenes != 0 ) if ( image -> scene >= ( image_info -> scene + image_info -> number_scenes - 1 ) ) break ; if ( scene < ( ssize_t ) ( number_scenes - 1 ) ) { AcquireNextImage ( image_info , image , exception ) ; if ( GetNextImageInList ( image ) == ( Image * ) NULL ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } image = SyncNextImageInList ( image ) ; status = SetImageProgress ( image , LoadImagesTag , TellBlob ( image ) , GetBlobSize ( image ) ) ; if ( status == MagickFalse ) break ; } } if ( stream_info -> offsets != ( ssize_t * ) NULL ) stream_info -> offsets = ( ssize_t * ) RelinquishMagickMemory ( stream_info -> offsets ) ; stream_info = ( DCMStreamInfo * ) RelinquishMagickMemory ( stream_info ) ; if ( scale != ( Quantum * ) NULL ) scale = ( Quantum * ) RelinquishMagickMemory ( scale ) ; if ( graymap != ( int * ) NULL ) graymap = ( int * ) RelinquishMagickMemory ( graymap ) ; if ( bluemap != ( int * ) NULL ) bluemap = ( int * ) RelinquishMagickMemory ( bluemap ) ; if ( greenmap != ( int * ) NULL ) greenmap = ( int * ) RelinquishMagickMemory ( greenmap ) ; if ( redmap != ( int * ) NULL ) redmap = ( int * ) RelinquishMagickMemory ( redmap ) ; ( void ) CloseBlob ( image ) ; return ( GetFirstImageInList ( image ) ) ; }\n",
      "fixed_code": "<S2SV_ModStart> 0x0004 : { if ( data == ( unsigned char * ) NULL ) break ; <S2SV_ModStart> 0x0008 : { if ( data == ( unsigned char * ) NULL ) break ; <S2SV_ModStart> 0 ; i <= <S2SV_ModEnd> ( ssize_t ) <S2SV_ModStart> ( ssize_t ) <S2SV_ModEnd> GetQuantumRange ( depth <S2SV_ModStart> GetQuantumRange ( depth <S2SV_ModEnd> ) ; i <S2SV_ModStart> NULL ) { if ( pixel . red <= GetQuantumRange ( depth ) ) <S2SV_ModStart> red ] ; if ( pixel . green <= GetQuantumRange ( depth ) ) <S2SV_ModStart> green ] ; if ( pixel . blue <= GetQuantumRange ( depth ) )\n",
      "source_code_length": 33522,
      "target_code_length": 549,
      "vulnerability_patterns": {
        "use_after_free": 1,
        "integer_overflow": 48,
        "null_pointer": 111,
        "total": 160
      },
      "total_patterns": 160,
      "original_address": "https://github.com/ImageMagick/ImageMagick/commit/5511ef530576ed18fd636baa3bb4eda3d667665d",
      "discovery_time": "2016-12-13T15:59Z",
      "project_commit_id": "ImageMagick@ImageMagick/5511ef530576ed18fd636baa3bb4eda3d667665d",
      "extraction_time": "2025-08-31T15:41:49.184756",
      "label": 1,
      "vulnerability_type": "improper_input_validation",
      "difficulty_level": "advanced",
      "risk_factors": [
        "critical_infrastructure",
        "use_after_free"
      ],
      "attack_vectors": [
        "fuzzing",
        "code_analysis",
        "reverse_engineering"
      ],
      "mitigation_strategies": [
        "dynamic_analysis",
        "static_analysis",
        "fuzzing",
        "code_review",
        "secure_coding_practices"
      ],
      "code_differences": {
        "has_differences": true,
        "source_lines": 2,
        "target_lines": 2,
        "character_differences": 32973,
        "similarity_percentage": 6.887755102040815
      },
      "vulnerability_location": {
        "vulnerability_present": true,
        "fix_applied": true,
        "code_changed": true,
        "estimated_lines_changed": 0
      }
    },
    {
      "cve_id": "CVE-2018-13406",
      "cwe_id": "CWE-190",
      "cwe_name": "Integer Overflow",
      "project": "torvalds",
      "severity": "critical",
      "weaponization_score": 8.0,
      "is_critical": true,
      "is_weaponizable": true,
      "is_high_priority_project": false,
      "vulnerable_code": "CWE-190 static int uvesafb_setcmap ( struct fb_cmap * cmap , struct fb_info * info ) { struct uvesafb_pal_entry * entries ; int shift = 16 - dac_width ; int i , err = 0 ; if ( info -> var . bits_per_pixel == 8 ) { if ( cmap -> start + cmap -> len > info -> cmap . start + info -> cmap . len || cmap -> start < info -> cmap . start ) return - EINVAL ; <S2SV_StartBug> entries = kmalloc ( sizeof ( * entries ) * cmap -> len , GFP_KERNEL ) ; <S2SV_EndBug> if ( ! entries ) return - ENOMEM ; for ( i = 0 ; i < cmap -> len ; i ++ ) { entries [ i ] . red = cmap -> red [ i ] >> shift ; entries [ i ] . green = cmap -> green [ i ] >> shift ; entries [ i ] . blue = cmap -> blue [ i ] >> shift ; entries [ i ] . pad = 0 ; } err = uvesafb_setpalette ( entries , cmap -> len , cmap -> start , info ) ; kfree ( entries ) ; } else { for ( i = 0 ; i < cmap -> len ; i ++ ) { err |= uvesafb_setcolreg ( cmap -> start + i , cmap -> red [ i ] , cmap -> green [ i ] , cmap -> blue [ i ] , 0 , info ) ; } } return err ; }\n",
      "fixed_code": "<S2SV_ModStart> ; entries = kmalloc_array ( cmap -> len , <S2SV_ModEnd> sizeof ( * <S2SV_ModStart> * entries ) , <S2SV_ModEnd> GFP_KERNEL ) ;\n",
      "source_code_length": 1004,
      "target_code_length": 142,
      "vulnerability_patterns": {
        "use_after_free": 1,
        "integer_overflow": 2,
        "null_pointer": 21,
        "memory_leak": 1,
        "total": 25
      },
      "total_patterns": 25,
      "original_address": "https://github.com/torvalds/linux/commit/9f645bcc566a1e9f921bdae7528a01ced5bc3713",
      "discovery_time": "2018-07-06T14:29Z",
      "project_commit_id": "torvalds@linux/9f645bcc566a1e9f921bdae7528a01ced5bc3713",
      "extraction_time": "2025-08-31T15:41:49.184980",
      "label": 1,
      "vulnerability_type": "integer_overflow",
      "difficulty_level": "advanced",
      "risk_factors": [
        "information_disclosure",
        "memory_corruption",
        "integer_overflow",
        "use_after_free"
      ],
      "attack_vectors": [
        "fuzzing",
        "code_analysis",
        "reverse_engineering"
      ],
      "mitigation_strategies": [
        "dynamic_analysis",
        "static_analysis",
        "fuzzing",
        "code_review",
        "secure_coding_practices"
      ],
      "code_differences": {
        "has_differences": true,
        "source_lines": 2,
        "target_lines": 2,
        "character_differences": 862,
        "similarity_percentage": 18.461538461538463
      },
      "vulnerability_location": {
        "vulnerability_present": true,
        "fix_applied": true,
        "code_changed": true,
        "estimated_lines_changed": 0
      }
    },
    {
      "cve_id": "CVE-2017-18120",
      "cwe_id": "CWE-415",
      "cwe_name": "Double Free",
      "project": "kohler",
      "severity": "critical",
      "weaponization_score": 8.0,
      "is_critical": true,
      "is_weaponizable": true,
      "is_high_priority_project": false,
      "vulnerable_code": "CWE-415 static Gif_Stream * read_gif ( Gif_Reader * grr , int read_flags , const char * landmark , Gif_ReadErrorHandler handler ) { Gif_Stream * gfs ; Gif_Image * gfi ; Gif_Context gfc ; int unknown_block_type = 0 ; if ( gifgetc ( grr ) != 'G' || gifgetc ( grr ) != 'I' || gifgetc ( grr ) != 'F' ) return 0 ; ( void ) gifgetc ( grr ) ; ( void ) gifgetc ( grr ) ; ( void ) gifgetc ( grr ) ; gfs = Gif_NewStream ( ) ; gfi = Gif_NewImage ( ) ; gfc . stream = gfs ; gfc . prefix = Gif_NewArray ( Gif_Code , GIF_MAX_CODE ) ; gfc . suffix = Gif_NewArray ( uint8_t , GIF_MAX_CODE ) ; gfc . length = Gif_NewArray ( uint16_t , GIF_MAX_CODE ) ; gfc . handler = handler ; gfc . gfi = gfi ; gfc . errors [ 0 ] = gfc . errors [ 1 ] = 0 ; if ( ! gfs || ! gfi || ! gfc . prefix || ! gfc . suffix || ! gfc . length ) goto done ; gfs -> landmark = landmark ; GIF_DEBUG ( ( \"\\\\nGIF<S2SV_blank>\" ) ) ; if ( ! read_logical_screen_descriptor ( gfs , grr ) ) goto done ; GIF_DEBUG ( ( \"logscrdesc<S2SV_blank>\" ) ) ; while ( ! gifeof ( grr ) ) { uint8_t block = gifgetbyte ( grr ) ; switch ( block ) { case ',' : GIF_DEBUG ( ( \"imageread<S2SV_blank>%d<S2SV_blank>\" , gfs -> nimages ) ) ; gfi -> identifier = last_name ; last_name = 0 ; if ( ! Gif_AddImage ( gfs , gfi ) ) goto done ; else if ( ! read_image ( grr , & gfc , gfi , read_flags ) ) { Gif_RemoveImage ( gfs , gfs -> nimages - 1 ) ; gfi = 0 ; goto done ; } gfc . gfi = gfi = Gif_NewImage ( ) ; if ( ! gfi ) goto done ; break ; case ';' : GIF_DEBUG ( ( \"term\\\\n\" ) ) ; goto done ; case '!' : block = gifgetbyte ( grr ) ; GIF_DEBUG ( ( \"ext(0x%02X)<S2SV_blank>\" , block ) ) ; switch ( block ) { case 0xF9 : read_graphic_control_extension ( & gfc , gfi , grr ) ; break ; case 0xCE : last_name = suck_data ( last_name , 0 , grr ) ; break ; case 0xFE : if ( ! read_comment_extension ( gfi , grr ) ) goto done ; break ; case 0xFF : read_application_extension ( & gfc , grr ) ; break ; default : read_unknown_extension ( & gfc , grr , block , 0 , 0 ) ; break ; } break ; default : if ( ! unknown_block_type ) { char buf [ 256 ] ; sprintf ( buf , \"unknown<S2SV_blank>block<S2SV_blank>type<S2SV_blank>%d<S2SV_blank>at<S2SV_blank>file<S2SV_blank>offset<S2SV_blank>%u\" , block , grr -> pos - 1 ) ; gif_read_error ( & gfc , 1 , buf ) ; unknown_block_type = 1 ; } break ; } } done : if ( gfs && gfi ) { Gif_Extension * gfex ; gfs -> end_comment = gfi -> comment ; gfi -> comment = 0 ; gfs -> end_extension_list = gfi -> extension_list ; gfi -> extension_list = 0 ; for ( gfex = gfs -> end_extension_list ; gfex ; gfex = gfex -> next ) gfex -> image = NULL ; } Gif_DeleteImage ( gfi ) ; Gif_DeleteArray ( last_name ) ; Gif_DeleteArray ( gfc . prefix ) ; Gif_DeleteArray ( gfc . suffix ) ; Gif_DeleteArray ( gfc . length ) ; gfc . gfi = 0 ; <S2SV_StartBug> if ( gfs ) <S2SV_EndBug> gfs -> errors = gfc . errors [ 1 ] ; if ( gfs && gfc . errors [ 1 ] == 0 && ! ( read_flags & GIF_READ_TRAILING_GARBAGE_OK ) && ! grr -> eofer ( grr ) ) gif_read_error ( & gfc , 0 , \"trailing<S2SV_blank>garbage<S2SV_blank>after<S2SV_blank>GIF<S2SV_blank>ignored\" ) ; gif_read_error ( & gfc , - 1 , 0 ) ; return gfs ; }\n",
      "fixed_code": "<S2SV_ModStart> = 0 ; last_name = 0 ;\n",
      "source_code_length": 3122,
      "target_code_length": 38,
      "vulnerability_patterns": {
        "buffer_overflow": 1,
        "format_string": 1,
        "null_pointer": 20,
        "total": 22
      },
      "total_patterns": 22,
      "original_address": "https://github.com/kohler/gifsicle/commit/118a46090c50829dc543179019e6140e1235f909",
      "discovery_time": "2018-02-02T09:29Z",
      "project_commit_id": "kohler@gifsicle/118a46090c50829dc543179019e6140e1235f909",
      "extraction_time": "2025-08-31T15:41:49.184999",
      "label": 1,
      "vulnerability_type": "double_free",
      "difficulty_level": "advanced",
      "risk_factors": [
        "system_crash",
        "denial_of_service",
        "memory_corruption",
        "buffer_overflow"
      ],
      "attack_vectors": [
        "memory_manipulation",
        "null_pointer",
        "code_analysis",
        "reverse_engineering",
        "use_after_free",
        "fuzzing"
      ],
      "mitigation_strategies": [
        "null_pointer_checks",
        "fuzzing",
        "dynamic_analysis",
        "memory_management",
        "static_analysis",
        "use_after_free_prevention",
        "code_review",
        "secure_coding_practices"
      ],
      "code_differences": {
        "has_differences": true,
        "source_lines": 2,
        "target_lines": 2,
        "character_differences": 3084,
        "similarity_percentage": 3.3333333333333335
      },
      "vulnerability_location": {
        "vulnerability_present": true,
        "fix_applied": true,
        "code_changed": true,
        "estimated_lines_changed": 0
      }
    },
    {
      "cve_id": "CVE-2019-19925",
      "cwe_id": "CWE-434",
      "cwe_name": "Unrestricted Upload",
      "project": "sqlite",
      "severity": "critical",
      "weaponization_score": 8.0,
      "is_critical": true,
      "is_weaponizable": true,
      "is_high_priority_project": true,
      "vulnerable_code": "CWE-434 static int zipfileUpdate ( sqlite3_vtab * pVtab , int nVal , sqlite3_value * * apVal , sqlite_int64 * pRowid ) { ZipfileTab * pTab = ( ZipfileTab * ) pVtab ; int rc = SQLITE_OK ; ZipfileEntry * pNew = 0 ; u32 mode = 0 ; u32 mTime = 0 ; i64 sz = 0 ; const char * zPath = 0 ; int nPath = 0 ; const u8 * pData = 0 ; int nData = 0 ; int iMethod = 0 ; u8 * pFree = 0 ; char * zFree = 0 ; ZipfileEntry * pOld = 0 ; ZipfileEntry * pOld2 = 0 ; int bUpdate = 0 ; int bIsDir = 0 ; u32 iCrc32 = 0 ; if ( pTab -> pWriteFd == 0 ) { rc = zipfileBegin ( pVtab ) ; if ( rc != SQLITE_OK ) return rc ; } if ( sqlite3_value_type ( apVal [ 0 ] ) != SQLITE_NULL ) { const char * zDelete = ( const char * ) sqlite3_value_text ( apVal [ 0 ] ) ; int nDelete = ( int ) strlen ( zDelete ) ; if ( nVal > 1 ) { const char * zUpdate = ( const char * ) sqlite3_value_text ( apVal [ 1 ] ) ; if ( zUpdate && zipfileComparePath ( zUpdate , zDelete , nDelete ) != 0 ) { bUpdate = 1 ; } } for ( pOld = pTab -> pFirstEntry ; 1 ; pOld = pOld -> pNext ) { if ( zipfileComparePath ( pOld -> cds . zFile , zDelete , nDelete ) == 0 ) { break ; } assert ( pOld -> pNext ) ; } } if ( nVal > 1 ) { if ( sqlite3_value_type ( apVal [ 5 ] ) != SQLITE_NULL ) { zipfileTableErr ( pTab , \"sz<S2SV_blank>must<S2SV_blank>be<S2SV_blank>NULL\" ) ; rc = SQLITE_CONSTRAINT ; } if ( sqlite3_value_type ( apVal [ 6 ] ) != SQLITE_NULL ) { zipfileTableErr ( pTab , \"rawdata<S2SV_blank>must<S2SV_blank>be<S2SV_blank>NULL\" ) ; rc = SQLITE_CONSTRAINT ; } if ( rc == SQLITE_OK ) { if ( sqlite3_value_type ( apVal [ 7 ] ) == SQLITE_NULL ) { bIsDir = 1 ; } else { const u8 * aIn = sqlite3_value_blob ( apVal [ 7 ] ) ; int nIn = sqlite3_value_bytes ( apVal [ 7 ] ) ; int bAuto = sqlite3_value_type ( apVal [ 8 ] ) == SQLITE_NULL ; iMethod = sqlite3_value_int ( apVal [ 8 ] ) ; sz = nIn ; pData = aIn ; nData = nIn ; if ( iMethod != 0 && iMethod != 8 ) { zipfileTableErr ( pTab , \"unknown<S2SV_blank>compression<S2SV_blank>method:<S2SV_blank>%d\" , iMethod ) ; rc = SQLITE_CONSTRAINT ; } else { if ( bAuto || iMethod ) { int nCmp ; rc = zipfileDeflate ( aIn , nIn , & pFree , & nCmp , & pTab -> base . zErrMsg ) ; if ( rc == SQLITE_OK ) { if ( iMethod || nCmp < nIn ) { iMethod = 8 ; pData = pFree ; nData = nCmp ; } } } iCrc32 = crc32 ( 0 , aIn , nIn ) ; } } } if ( rc == SQLITE_OK ) { rc = zipfileGetMode ( apVal [ 3 ] , bIsDir , & mode , & pTab -> base . zErrMsg ) ; } if ( rc == SQLITE_OK ) { zPath = ( const char * ) sqlite3_value_text ( apVal [ 2 ] ) ; <S2SV_StartBug> nPath = ( int ) strlen ( zPath ) ; <S2SV_EndBug> mTime = zipfileGetTime ( apVal [ 4 ] ) ; } if ( rc == SQLITE_OK && bIsDir ) { if ( zPath [ nPath - 1 ] != '/' ) { zFree = sqlite3_mprintf ( \"%s/\" , zPath ) ; if ( zFree == 0 ) { rc = SQLITE_NOMEM ; } zPath = ( const char * ) zFree ; nPath ++ ; } } if ( ( pOld == 0 || bUpdate ) && rc == SQLITE_OK ) { ZipfileEntry * p ; for ( p = pTab -> pFirstEntry ; p ; p = p -> pNext ) { if ( zipfileComparePath ( p -> cds . zFile , zPath , nPath ) == 0 ) { switch ( sqlite3_vtab_on_conflict ( pTab -> db ) ) { case SQLITE_IGNORE : { goto zipfile_update_done ; } case SQLITE_REPLACE : { pOld2 = p ; break ; } default : { zipfileTableErr ( pTab , \"duplicate<S2SV_blank>name:<S2SV_blank>\\\\\"%s\\\\\"\" , zPath ) ; rc = SQLITE_CONSTRAINT ; break ; } } break ; } } } if ( rc == SQLITE_OK ) { pNew = zipfileNewEntry ( zPath ) ; if ( pNew == 0 ) { rc = SQLITE_NOMEM ; } else { pNew -> cds . iVersionMadeBy = ZIPFILE_NEWENTRY_MADEBY ; pNew -> cds . iVersionExtract = ZIPFILE_NEWENTRY_REQUIRED ; pNew -> cds . flags = ZIPFILE_NEWENTRY_FLAGS ; pNew -> cds . iCompression = ( u16 ) iMethod ; zipfileMtimeToDos ( & pNew -> cds , mTime ) ; pNew -> cds . crc32 = iCrc32 ; pNew -> cds . szCompressed = nData ; pNew -> cds . szUncompressed = ( u32 ) sz ; pNew -> cds . iExternalAttr = ( mode << 16 ) ; pNew -> cds . iOffset = ( u32 ) pTab -> szCurrent ; pNew -> cds . nFile = ( u16 ) nPath ; pNew -> mUnixTime = ( u32 ) mTime ; rc = zipfileAppendEntry ( pTab , pNew , pData , nData ) ; zipfileAddEntry ( pTab , pOld , pNew ) ; } } } if ( rc == SQLITE_OK && ( pOld || pOld2 ) ) { ZipfileCsr * pCsr ; for ( pCsr = pTab -> pCsrList ; pCsr ; pCsr = pCsr -> pCsrNext ) { if ( pCsr -> pCurrent && ( pCsr -> pCurrent == pOld || pCsr -> pCurrent == pOld2 ) ) { pCsr -> pCurrent = pCsr -> pCurrent -> pNext ; pCsr -> bNoop = 1 ; } } zipfileRemoveEntryFromList ( pTab , pOld ) ; zipfileRemoveEntryFromList ( pTab , pOld2 ) ; } zipfile_update_done : sqlite3_free ( pFree ) ; sqlite3_free ( zFree ) ; return rc ; }\n",
      "fixed_code": "<S2SV_ModStart> ] ) ; if ( zPath == 0 ) zPath = \"\" ;\n",
      "source_code_length": 4532,
      "target_code_length": 53,
      "vulnerability_patterns": {
        "integer_overflow": 1,
        "null_pointer": 33,
        "total": 34
      },
      "total_patterns": 34,
      "original_address": "https://github.com/sqlite/sqlite/commit/54d501092d88c0cf89bec4279951f548fb0b8618",
      "discovery_time": "2019-12-24T17:15Z",
      "project_commit_id": "sqlite@sqlite/54d501092d88c0cf89bec4279951f548fb0b8618",
      "extraction_time": "2025-08-31T15:41:49.185033",
      "label": 1,
      "vulnerability_type": "unrestricted_upload",
      "difficulty_level": "advanced",
      "risk_factors": [
        "file_upload",
        "unauthorized_access",
        "data_manipulation",
        "critical_infrastructure"
      ],
      "attack_vectors": [
        "fuzzing",
        "code_analysis",
        "reverse_engineering"
      ],
      "mitigation_strategies": [
        "dynamic_analysis",
        "static_analysis",
        "fuzzing",
        "code_review",
        "secure_coding_practices"
      ],
      "code_differences": {
        "has_differences": true,
        "source_lines": 2,
        "target_lines": 2,
        "character_differences": 4479,
        "similarity_percentage": 5.844155844155844
      },
      "vulnerability_location": {
        "vulnerability_present": true,
        "fix_applied": true,
        "code_changed": true,
        "estimated_lines_changed": 0
      }
    },
    {
      "cve_id": "CVE-2019-1010065",
      "cwe_id": "CWE-190",
      "cwe_name": "Integer Overflow",
      "project": "sleuthkit",
      "severity": "critical",
      "weaponization_score": 8.0,
      "is_critical": true,
      "is_weaponizable": true,
      "is_high_priority_project": false,
      "vulnerable_code": "CWE-190 uint8_t hfs_cat_traverse ( HFS_INFO * hfs , TSK_HFS_BTREE_CB a_cb , void * ptr ) { TSK_FS_INFO * fs = & ( hfs -> fs_info ) ; uint32_t cur_node ; char * node ; uint16_t nodesize ; uint8_t is_done = 0 ; tsk_error_reset ( ) ; nodesize = tsk_getu16 ( fs -> endian , hfs -> catalog_header . nodesize ) ; if ( ( node = ( char * ) tsk_malloc ( nodesize ) ) == NULL ) return 1 ; cur_node = tsk_getu32 ( fs -> endian , hfs -> catalog_header . rootNode ) ; if ( cur_node == 0 ) { if ( tsk_verbose ) tsk_fprintf ( stderr , \"hfs_cat_traverse:<S2SV_blank>\" \"empty<S2SV_blank>extents<S2SV_blank>btree\\\\n\" ) ; free ( node ) ; return 1 ; } if ( tsk_verbose ) tsk_fprintf ( stderr , \"hfs_cat_traverse:<S2SV_blank>starting<S2SV_blank>at<S2SV_blank>\" \"root<S2SV_blank>node<S2SV_blank>%\" PRIu32 \";<S2SV_blank>nodesize<S2SV_blank>=<S2SV_blank>%\" PRIu16 \"\\\\n\" , cur_node , nodesize ) ; is_done = 0 ; while ( is_done == 0 ) { TSK_OFF_T cur_off ; uint16_t num_rec ; ssize_t cnt ; hfs_btree_node * node_desc ; if ( cur_node > tsk_getu32 ( fs -> endian , hfs -> catalog_header . totalNodes ) ) { tsk_error_set_errno ( TSK_ERR_FS_GENFS ) ; tsk_error_set_errstr ( \"hfs_cat_traverse:<S2SV_blank>Node<S2SV_blank>%d<S2SV_blank>too<S2SV_blank>large<S2SV_blank>for<S2SV_blank>file\" , cur_node ) ; free ( node ) ; return 1 ; } cur_off = cur_node * nodesize ; cnt = tsk_fs_attr_read ( hfs -> catalog_attr , cur_off , node , nodesize , 0 ) ; if ( cnt != nodesize ) { if ( cnt >= 0 ) { tsk_error_reset ( ) ; tsk_error_set_errno ( TSK_ERR_FS_READ ) ; } tsk_error_set_errstr2 ( \"hfs_cat_traverse:<S2SV_blank>Error<S2SV_blank>reading<S2SV_blank>node<S2SV_blank>%d<S2SV_blank>at<S2SV_blank>offset<S2SV_blank>%\" PRIuOFF , cur_node , cur_off ) ; free ( node ) ; return 1 ; } if ( nodesize < sizeof ( hfs_btree_node ) ) { tsk_error_set_errno ( TSK_ERR_FS_GENFS ) ; tsk_error_set_errstr ( \"hfs_cat_traverse:<S2SV_blank>Node<S2SV_blank>size<S2SV_blank>%d<S2SV_blank>is<S2SV_blank>too<S2SV_blank>small<S2SV_blank>to<S2SV_blank>be<S2SV_blank>valid\" , nodesize ) ; free ( node ) ; return 1 ; } node_desc = ( hfs_btree_node * ) node ; num_rec = tsk_getu16 ( fs -> endian , node_desc -> num_rec ) ; if ( tsk_verbose ) tsk_fprintf ( stderr , \"hfs_cat_traverse:<S2SV_blank>node<S2SV_blank>%\" PRIu32 \"<S2SV_blank>@<S2SV_blank>%\" PRIu64 \"<S2SV_blank>has<S2SV_blank>%\" PRIu16 \"<S2SV_blank>records\\\\n\" , cur_node , cur_off , num_rec ) ; if ( num_rec == 0 ) { tsk_error_set_errno ( TSK_ERR_FS_GENFS ) ; tsk_error_set_errstr ( \"hfs_cat_traverse:<S2SV_blank>zero<S2SV_blank>records<S2SV_blank>in<S2SV_blank>node<S2SV_blank>%\" PRIu32 , cur_node ) ; free ( node ) ; return 1 ; } if ( node_desc -> type == HFS_BT_NODE_TYPE_IDX ) { uint32_t next_node = 0 ; int rec ; for ( rec = 0 ; rec < num_rec ; ++ rec ) { size_t rec_off ; hfs_btree_key_cat * key ; uint8_t retval ; <S2SV_StartBug> uint16_t keylen ; <S2SV_EndBug> rec_off = tsk_getu16 ( fs -> endian , & node [ nodesize - ( rec + 1 ) * 2 ] ) ; if ( rec_off > nodesize ) { tsk_error_set_errno ( TSK_ERR_FS_GENFS ) ; tsk_error_set_errstr ( \"hfs_cat_traverse:<S2SV_blank>offset<S2SV_blank>of<S2SV_blank>record<S2SV_blank>%d<S2SV_blank>in<S2SV_blank>index<S2SV_blank>node<S2SV_blank>%d<S2SV_blank>too<S2SV_blank>large<S2SV_blank>(%d<S2SV_blank>vs<S2SV_blank>%\" PRIu16 \")\" , rec , cur_node , ( int ) rec_off , nodesize ) ; free ( node ) ; return 1 ; } key = ( hfs_btree_key_cat * ) & node [ rec_off ] ; keylen = 2 + tsk_getu16 ( hfs -> fs_info . endian , key -> key_len ) ; if ( ( keylen ) > nodesize ) { tsk_error_set_errno ( TSK_ERR_FS_GENFS ) ; tsk_error_set_errstr ( \"hfs_cat_traverse:<S2SV_blank>length<S2SV_blank>of<S2SV_blank>key<S2SV_blank>%d<S2SV_blank>in<S2SV_blank>index<S2SV_blank>node<S2SV_blank>%d<S2SV_blank>too<S2SV_blank>large<S2SV_blank>(%d<S2SV_blank>vs<S2SV_blank>%\" PRIu16 \")\" , rec , cur_node , keylen , nodesize ) ; free ( node ) ; return 1 ; } retval = a_cb ( hfs , HFS_BT_NODE_TYPE_IDX , key , cur_off + rec_off , ptr ) ; if ( retval == HFS_BTREE_CB_ERR ) { tsk_error_set_errno ( TSK_ERR_FS_GENFS ) ; tsk_error_set_errstr2 ( \"hfs_cat_traverse:<S2SV_blank>Callback<S2SV_blank>returned<S2SV_blank>error\" ) ; free ( node ) ; return 1 ; } else if ( ( retval == HFS_BTREE_CB_IDX_LT ) || ( next_node == 0 ) ) { hfs_btree_index_record * idx_rec ; int keylen = 2 + hfs_get_idxkeylen ( hfs , tsk_getu16 ( fs -> endian , key -> key_len ) , & ( hfs -> catalog_header ) ) ; if ( rec_off + keylen > nodesize ) { tsk_error_set_errno ( TSK_ERR_FS_GENFS ) ; tsk_error_set_errstr ( \"hfs_cat_traverse:<S2SV_blank>offset<S2SV_blank>of<S2SV_blank>record<S2SV_blank>and<S2SV_blank>keylength<S2SV_blank>%d<S2SV_blank>in<S2SV_blank>index<S2SV_blank>node<S2SV_blank>%d<S2SV_blank>too<S2SV_blank>large<S2SV_blank>(%d<S2SV_blank>vs<S2SV_blank>%\" PRIu16 \")\" , rec , cur_node , ( int ) rec_off + keylen , nodesize ) ; free ( node ) ; return 1 ; } idx_rec = ( hfs_btree_index_record * ) & node [ rec_off + keylen ] ; next_node = tsk_getu32 ( fs -> endian , idx_rec -> childNode ) ; } if ( retval == HFS_BTREE_CB_IDX_EQGT ) { break ; } } if ( next_node == 0 ) { tsk_error_set_errno ( TSK_ERR_FS_GENFS ) ; tsk_error_set_errstr ( \"hfs_cat_traverse:<S2SV_blank>did<S2SV_blank>not<S2SV_blank>find<S2SV_blank>any<S2SV_blank>keys<S2SV_blank>in<S2SV_blank>index<S2SV_blank>node<S2SV_blank>%d\" , cur_node ) ; is_done = 1 ; break ; } if ( next_node == cur_node ) { tsk_error_set_errno ( TSK_ERR_FS_GENFS ) ; tsk_error_set_errstr ( \"hfs_cat_traverse:<S2SV_blank>node<S2SV_blank>%d<S2SV_blank>references<S2SV_blank>itself<S2SV_blank>as<S2SV_blank>next<S2SV_blank>node\" , cur_node ) ; is_done = 1 ; break ; } cur_node = next_node ; } else if ( node_desc -> type == HFS_BT_NODE_TYPE_LEAF ) { int rec ; for ( rec = 0 ; rec < num_rec ; ++ rec ) { size_t rec_off ; hfs_btree_key_cat * key ; uint8_t retval ; <S2SV_StartBug> uint16_t keylen ; <S2SV_EndBug> rec_off = tsk_getu16 ( fs -> endian , & node [ nodesize - ( rec + 1 ) * 2 ] ) ; if ( rec_off > nodesize ) { tsk_error_set_errno ( TSK_ERR_FS_GENFS ) ; tsk_error_set_errstr ( \"hfs_cat_traverse:<S2SV_blank>offset<S2SV_blank>of<S2SV_blank>record<S2SV_blank>%d<S2SV_blank>in<S2SV_blank>leaf<S2SV_blank>node<S2SV_blank>%d<S2SV_blank>too<S2SV_blank>large<S2SV_blank>(%d<S2SV_blank>vs<S2SV_blank>%\" PRIu16 \")\" , rec , cur_node , ( int ) rec_off , nodesize ) ; free ( node ) ; return 1 ; } key = ( hfs_btree_key_cat * ) & node [ rec_off ] ; keylen = 2 + tsk_getu16 ( hfs -> fs_info . endian , key -> key_len ) ; if ( ( keylen ) > nodesize ) { tsk_error_set_errno ( TSK_ERR_FS_GENFS ) ; tsk_error_set_errstr ( \"hfs_cat_traverse:<S2SV_blank>length<S2SV_blank>of<S2SV_blank>key<S2SV_blank>%d<S2SV_blank>in<S2SV_blank>leaf<S2SV_blank>node<S2SV_blank>%d<S2SV_blank>too<S2SV_blank>large<S2SV_blank>(%d<S2SV_blank>vs<S2SV_blank>%\" PRIu16 \")\" , rec , cur_node , keylen , nodesize ) ; free ( node ) ; return 1 ; } retval = a_cb ( hfs , HFS_BT_NODE_TYPE_LEAF , key , cur_off + rec_off , ptr ) ; if ( retval == HFS_BTREE_CB_LEAF_STOP ) { is_done = 1 ; break ; } else if ( retval == HFS_BTREE_CB_ERR ) { tsk_error_set_errno ( TSK_ERR_FS_GENFS ) ; tsk_error_set_errstr2 ( \"hfs_cat_traverse:<S2SV_blank>Callback<S2SV_blank>returned<S2SV_blank>error\" ) ; free ( node ) ; return 1 ; } } if ( is_done == 0 ) { cur_node = tsk_getu32 ( fs -> endian , node_desc -> flink ) ; if ( cur_node == 0 ) { is_done = 1 ; } if ( tsk_verbose ) tsk_fprintf ( stderr , \"hfs_cat_traverse:<S2SV_blank>moving<S2SV_blank>forward<S2SV_blank>to<S2SV_blank>next<S2SV_blank>leaf\" ) ; } } else { tsk_error_set_errno ( TSK_ERR_FS_GENFS ) ; tsk_error_set_errstr ( \"hfs_cat_traverse:<S2SV_blank>btree<S2SV_blank>node<S2SV_blank>%\" PRIu32 \"<S2SV_blank>(%\" PRIu64 \")<S2SV_blank>is<S2SV_blank>neither<S2SV_blank>index<S2SV_blank>nor<S2SV_blank>leaf<S2SV_blank>(%\" PRIu8 \")\" , cur_node , cur_off , node_desc -> type ) ; free ( node ) ; return 1 ; } } free ( node ) ; return 0 ; }\n",
      "fixed_code": "<S2SV_ModStart> uint8_t retval ; int <S2SV_ModEnd> keylen ; rec_off <S2SV_ModStart> uint8_t retval ; int <S2SV_ModEnd> keylen ; rec_off\n",
      "source_code_length": 7851,
      "target_code_length": 136,
      "vulnerability_patterns": {
        "use_after_free": 14,
        "integer_overflow": 2,
        "null_pointer": 26,
        "total": 42
      },
      "total_patterns": 42,
      "original_address": "https://github.com/sleuthkit/sleuthkit/commit/114cd3d0aac8bd1aeaf4b33840feb0163d342d5b",
      "discovery_time": "2019-07-18T17:15Z",
      "project_commit_id": "sleuthkit@sleuthkit/114cd3d0aac8bd1aeaf4b33840feb0163d342d5b",
      "extraction_time": "2025-08-31T15:41:49.185077",
      "label": 1,
      "vulnerability_type": "integer_overflow",
      "difficulty_level": "advanced",
      "risk_factors": [
        "information_disclosure",
        "memory_corruption",
        "integer_overflow",
        "use_after_free"
      ],
      "attack_vectors": [
        "fuzzing",
        "code_analysis",
        "reverse_engineering"
      ],
      "mitigation_strategies": [
        "dynamic_analysis",
        "static_analysis",
        "fuzzing",
        "code_review",
        "secure_coding_practices"
      ],
      "code_differences": {
        "has_differences": true,
        "source_lines": 2,
        "target_lines": 2,
        "character_differences": 7715,
        "similarity_percentage": 4.411764705882353
      },
      "vulnerability_location": {
        "vulnerability_present": true,
        "fix_applied": true,
        "code_changed": true,
        "estimated_lines_changed": 0
      }
    },
    {
      "cve_id": "CVE-2016-10764",
      "cwe_id": "CWE-119",
      "cwe_name": "Buffer Overflow",
      "project": "torvalds",
      "severity": "critical",
      "weaponization_score": 8.0,
      "is_critical": true,
      "is_weaponizable": true,
      "is_high_priority_project": false,
      "vulnerable_code": "CWE-119 static int cqspi_setup_flash ( struct cqspi_st * cqspi , struct device_node * np ) { struct platform_device * pdev = cqspi -> pdev ; struct device * dev = & pdev -> dev ; struct cqspi_flash_pdata * f_pdata ; struct spi_nor * nor ; struct mtd_info * mtd ; unsigned int cs ; int i , ret ; for_each_available_child_of_node ( dev -> of_node , np ) { if ( of_property_read_u32 ( np , \"reg\" , & cs ) ) { dev_err ( dev , \"Couldn\\'t<S2SV_blank>determine<S2SV_blank>chip<S2SV_blank>select.\\\\n\" ) ; goto err ; } <S2SV_StartBug> if ( cs > CQSPI_MAX_CHIPSELECT ) { <S2SV_EndBug> dev_err ( dev , \"Chip<S2SV_blank>select<S2SV_blank>%d<S2SV_blank>out<S2SV_blank>of<S2SV_blank>range.\\\\n\" , cs ) ; goto err ; } f_pdata = & cqspi -> f_pdata [ cs ] ; f_pdata -> cqspi = cqspi ; f_pdata -> cs = cs ; ret = cqspi_of_get_flash_pdata ( pdev , f_pdata , np ) ; if ( ret ) goto err ; nor = & f_pdata -> nor ; mtd = & nor -> mtd ; mtd -> priv = nor ; nor -> dev = dev ; spi_nor_set_flash_node ( nor , np ) ; nor -> priv = f_pdata ; nor -> read_reg = cqspi_read_reg ; nor -> write_reg = cqspi_write_reg ; nor -> read = cqspi_read ; nor -> write = cqspi_write ; nor -> erase = cqspi_erase ; nor -> prepare = cqspi_prep ; nor -> unprepare = cqspi_unprep ; mtd -> name = devm_kasprintf ( dev , GFP_KERNEL , \"%s.%d\" , dev_name ( dev ) , cs ) ; if ( ! mtd -> name ) { ret = - ENOMEM ; goto err ; } ret = spi_nor_scan ( nor , NULL , SPI_NOR_QUAD ) ; if ( ret ) goto err ; ret = mtd_device_register ( mtd , NULL , 0 ) ; if ( ret ) goto err ; f_pdata -> registered = true ; } return 0 ; err : for ( i = 0 ; i < CQSPI_MAX_CHIPSELECT ; i ++ ) if ( cqspi -> f_pdata [ i ] . registered ) mtd_device_unregister ( & cqspi -> f_pdata [ i ] . nor . mtd ) ; return ret ; }\n",
      "fixed_code": "<S2SV_ModStart> if ( cs >= <S2SV_ModEnd> CQSPI_MAX_CHIPSELECT ) {\n",
      "source_code_length": 1737,
      "target_code_length": 66,
      "vulnerability_patterns": {
        "integer_overflow": 1,
        "null_pointer": 23,
        "sql_injection": 2,
        "total": 26
      },
      "total_patterns": 26,
      "original_address": "https://github.com/torvalds/linux/commit/193e87143c290ec16838f5368adc0e0bc94eb931",
      "discovery_time": "2019-07-27T22:15Z",
      "project_commit_id": "torvalds@linux/193e87143c290ec16838f5368adc0e0bc94eb931",
      "extraction_time": "2025-08-31T15:41:49.185126",
      "label": 1,
      "vulnerability_type": "buffer_overflow",
      "difficulty_level": "advanced",
      "risk_factors": [
        "system_crash",
        "memory_corruption",
        "sql_injection",
        "arbitrary_code_execution"
      ],
      "attack_vectors": [
        "memory_manipulation",
        "malicious_input",
        "code_analysis",
        "buffer_overflow",
        "reverse_engineering",
        "fuzzing"
      ],
      "mitigation_strategies": [
        "safe_string_functions",
        "dynamic_analysis",
        "code_review",
        "static_analysis",
        "memory_safety_checks",
        "input_validation",
        "fuzzing",
        "bounds_checking",
        "secure_coding_practices"
      ],
      "code_differences": {
        "has_differences": true,
        "source_lines": 2,
        "target_lines": 2,
        "character_differences": 1671,
        "similarity_percentage": 6.593406593406594
      },
      "vulnerability_location": {
        "vulnerability_present": true,
        "fix_applied": true,
        "code_changed": true,
        "estimated_lines_changed": 0
      }
    },
    {
      "cve_id": "CVE-2016-9084",
      "cwe_id": "CWE-190",
      "cwe_name": "Integer Overflow",
      "project": "torvalds",
      "severity": "critical",
      "weaponization_score": 8.0,
      "is_critical": true,
      "is_weaponizable": true,
      "is_high_priority_project": false,
      "vulnerable_code": "CWE-190 static int vfio_msi_enable ( struct vfio_pci_device * vdev , int nvec , bool msix ) { struct pci_dev * pdev = vdev -> pdev ; unsigned int flag = msix ? PCI_IRQ_MSIX : PCI_IRQ_MSI ; int ret ; if ( ! is_irq_none ( vdev ) ) return - EINVAL ; <S2SV_StartBug> vdev -> ctx = kzalloc ( nvec * sizeof ( struct vfio_pci_irq_ctx ) , GFP_KERNEL ) ; <S2SV_EndBug> if ( ! vdev -> ctx ) return - ENOMEM ; ret = pci_alloc_irq_vectors ( pdev , 1 , nvec , flag ) ; if ( ret < nvec ) { if ( ret > 0 ) pci_free_irq_vectors ( pdev ) ; kfree ( vdev -> ctx ) ; return ret ; } vdev -> num_ctx = nvec ; vdev -> irq_type = msix ? VFIO_PCI_MSIX_IRQ_INDEX : VFIO_PCI_MSI_IRQ_INDEX ; if ( ! msix ) { vdev -> msi_qmax = fls ( nvec * 2 - 1 ) - 1 ; } return 0 ; }\n",
      "fixed_code": "<S2SV_ModStart> -> ctx = kcalloc ( nvec , <S2SV_ModEnd> sizeof ( struct\n",
      "source_code_length": 741,
      "target_code_length": 72,
      "vulnerability_patterns": {
        "use_after_free": 1,
        "null_pointer": 9,
        "total": 10
      },
      "total_patterns": 10,
      "original_address": "https://github.com/torvalds/linux/commit/05692d7005a364add85c6e25a6c4447ce08f913a",
      "discovery_time": "2016-11-28T03:59Z",
      "project_commit_id": "torvalds@linux/05692d7005a364add85c6e25a6c4447ce08f913a",
      "extraction_time": "2025-08-31T15:41:49.185151",
      "label": 1,
      "vulnerability_type": "integer_overflow",
      "difficulty_level": "advanced",
      "risk_factors": [
        "information_disclosure",
        "memory_corruption",
        "integer_overflow",
        "use_after_free"
      ],
      "attack_vectors": [
        "fuzzing",
        "code_analysis",
        "reverse_engineering"
      ],
      "mitigation_strategies": [
        "dynamic_analysis",
        "static_analysis",
        "fuzzing",
        "code_review",
        "secure_coding_practices"
      ],
      "code_differences": {
        "has_differences": true,
        "source_lines": 2,
        "target_lines": 2,
        "character_differences": 669,
        "similarity_percentage": 13.559322033898304
      },
      "vulnerability_location": {
        "vulnerability_present": true,
        "fix_applied": true,
        "code_changed": true,
        "estimated_lines_changed": 0
      }
    },
    {
      "cve_id": "CVE-2020-13112",
      "cwe_id": "CWE-125",
      "cwe_name": "Out-of-bounds Read",
      "project": "libexif",
      "severity": "critical",
      "weaponization_score": 8.0,
      "is_critical": true,
      "is_weaponizable": true,
      "is_high_priority_project": false,
      "vulnerable_code": "CWE-125 static void exif_mnote_data_canon_load ( ExifMnoteData * ne , const unsigned char * buf , unsigned int buf_size ) { ExifMnoteDataCanon * n = ( ExifMnoteDataCanon * ) ne ; ExifShort c ; size_t i , tcount , o , datao ; if ( ! n || ! buf || ! buf_size ) { exif_log ( ne -> log , EXIF_LOG_CODE_CORRUPT_DATA , \"ExifMnoteCanon\" , \"Short<S2SV_blank>MakerNote\" ) ; return ; } datao = 6 + n -> offset ; <S2SV_StartBug> if ( ( datao + 2 < datao ) || ( datao + 2 < 2 ) || ( datao + 2 > buf_size ) ) { <S2SV_EndBug> exif_log ( ne -> log , EXIF_LOG_CODE_CORRUPT_DATA , \"ExifMnoteCanon\" , \"Short<S2SV_blank>MakerNote\" ) ; return ; } c = exif_get_short ( buf + datao , n -> order ) ; datao += 2 ; exif_mnote_data_canon_clear ( n ) ; n -> entries = exif_mem_alloc ( ne -> mem , sizeof ( MnoteCanonEntry ) * c ) ; if ( ! n -> entries ) { EXIF_LOG_NO_MEMORY ( ne -> log , \"ExifMnoteCanon\" , sizeof ( MnoteCanonEntry ) * c ) ; return ; } tcount = 0 ; for ( i = c , o = datao ; i ; -- i , o += 12 ) { size_t s ; <S2SV_StartBug> if ( ( o + 12 < o ) || ( o + 12 < 12 ) || ( o + 12 > buf_size ) ) { <S2SV_EndBug> exif_log ( ne -> log , EXIF_LOG_CODE_CORRUPT_DATA , <S2SV_StartBug> \"ExifMnoteCanon\" , \"Short<S2SV_blank>MakerNote\" ) ; <S2SV_EndBug> break ; } n -> entries [ tcount ] . tag = exif_get_short ( buf + o , n -> order ) ; <S2SV_StartBug> n -> entries [ tcount ] . format = exif_get_short ( buf + o + 2 , n -> order ) ; <S2SV_EndBug> <S2SV_StartBug> n -> entries [ tcount ] . components = exif_get_long ( buf + o + 4 , n -> order ) ; <S2SV_EndBug> n -> entries [ tcount ] . order = n -> order ; exif_log ( ne -> log , EXIF_LOG_CODE_DEBUG , \"ExifMnoteCanon\" , \"Loading<S2SV_blank>entry<S2SV_blank>0x%x<S2SV_blank>(\\'%s\\')...\" , n -> entries [ tcount ] . tag , mnote_canon_tag_get_name ( n -> entries [ tcount ] . tag ) ) ; s = exif_format_get_size ( n -> entries [ tcount ] . format ) * n -> entries [ tcount ] . components ; n -> entries [ tcount ] . size = s ; if ( ! s ) { exif_log ( ne -> log , EXIF_LOG_CODE_CORRUPT_DATA , \"ExifMnoteCanon\" , \"Invalid<S2SV_blank>zero-length<S2SV_blank>tag<S2SV_blank>size\" ) ; continue ; } else { size_t dataofs = o + 8 ; if ( s > 4 ) dataofs = exif_get_long ( buf + dataofs , n -> order ) + 6 ; <S2SV_StartBug> if ( ( dataofs + s < s ) || ( dataofs + s < dataofs ) || ( dataofs + s > buf_size ) ) { <S2SV_EndBug> exif_log ( ne -> log , EXIF_LOG_CODE_DEBUG , \"ExifMnoteCanon\" , \"Tag<S2SV_blank>data<S2SV_blank>past<S2SV_blank>end<S2SV_blank>of<S2SV_blank>buffer<S2SV_blank>(%u<S2SV_blank>><S2SV_blank>%u)\" , ( unsigned ) ( dataofs + s ) , buf_size ) ; continue ; } n -> entries [ tcount ] . data = exif_mem_alloc ( ne -> mem , s ) ; if ( ! n -> entries [ tcount ] . data ) { EXIF_LOG_NO_MEMORY ( ne -> log , \"ExifMnoteCanon\" , s ) ; continue ; } memcpy ( n -> entries [ tcount ] . data , buf + dataofs , s ) ; } ++ tcount ; } n -> count = tcount ; }\n",
      "fixed_code": "<S2SV_ModStart> ; if ( CHECKOVERFLOW ( datao , buf_size , 2 <S2SV_ModEnd> ) ) { <S2SV_ModStart> ; if ( CHECKOVERFLOW ( o , buf_size , 12 ) ) { exif_log ( ne -> log , EXIF_LOG_CODE_CORRUPT_DATA , \"ExifMnoteCanon\" , \"Short<S2SV_blank>MakerNote\" ) ; break ; } n -> entries [ tcount ] . tag = exif_get_short ( buf + o , n -> order ) ; n -> entries [ tcount ] . format = exif_get_short ( buf + o + 2 , n -> order ) ; n -> entries [ tcount ] . components = exif_get_long ( buf + o + 4 , n -> order ) ; n -> entries [ tcount ] . order = n -> order ; exif_log ( ne -> log , EXIF_LOG_CODE_DEBUG , \"ExifMnoteCanon\" , \"Loading<S2SV_blank>entry<S2SV_blank>0x%x<S2SV_blank>(\\'%s\\')...\" , n -> entries [ tcount ] . tag , mnote_canon_tag_get_name ( n -> entries [ tcount ] . tag ) ) ; if ( exif_format_get_size ( n -> entries [ tcount ] . format ) && buf_size / exif_format_get_size ( n -> entries [ tcount ] . format ) < n -> entries [ tcount ] . components <S2SV_ModEnd> ) { exif_log <S2SV_ModStart> , \"ExifMnoteCanon\" , \"Tag<S2SV_blank>size<S2SV_blank>overflow<S2SV_blank>detected<S2SV_blank>(%u<S2SV_blank>*<S2SV_blank>%lu)\" , exif_format_get_size ( <S2SV_ModEnd> n -> entries <S2SV_ModStart> ] . format ) , <S2SV_ModEnd> n -> entries <S2SV_ModStart> ] . components ) ; continue ; } <S2SV_ModEnd> s = exif_format_get_size <S2SV_ModStart> ; if ( CHECKOVERFLOW ( dataofs , buf_size , s ) ) { exif_log ( ne -> log , EXIF_LOG_CODE_DEBUG , \"ExifMnoteCanon\" , \"Tag<S2SV_blank>data<S2SV_blank>past<S2SV_blank>end<S2SV_blank>of<S2SV_blank>buffer<S2SV_blank>(%u<S2SV_blank>><S2SV_blank>%u)\" , ( unsigned ) <S2SV_ModEnd> ( dataofs + <S2SV_ModStart> dataofs + s ) , buf_size ) ; continue ; } n -> entries [ tcount ] . data = exif_mem_alloc ( ne -> mem , s ) ; if ( ! n -> entries [ tcount ] . data ) { EXIF_LOG_NO_MEMORY ( ne -> log , \"ExifMnoteCanon\" , s ) ; continue ; } memcpy ( n -> entries [ tcount ] . data , buf + dataofs <S2SV_ModEnd> , s )\n",
      "source_code_length": 2880,
      "target_code_length": 1927,
      "vulnerability_patterns": {
        "buffer_overflow": 1,
        "integer_overflow": 4,
        "null_pointer": 34,
        "total": 39
      },
      "total_patterns": 39,
      "original_address": "https://github.com/libexif/libexif/commit/435e21f05001fb03f9f186fa7cbc69454afd00d1",
      "discovery_time": "2020-05-21T16:15Z",
      "project_commit_id": "libexif@libexif/435e21f05001fb03f9f186fa7cbc69454afd00d1",
      "extraction_time": "2025-08-31T15:41:49.185172",
      "label": 1,
      "vulnerability_type": "out-of-bounds_read",
      "difficulty_level": "advanced",
      "risk_factors": [
        "information_disclosure",
        "memory_corruption",
        "integer_overflow",
        "buffer_overflow"
      ],
      "attack_vectors": [
        "memory_manipulation",
        "malicious_input",
        "code_analysis",
        "buffer_overflow",
        "reverse_engineering",
        "fuzzing"
      ],
      "mitigation_strategies": [
        "safe_string_functions",
        "dynamic_analysis",
        "code_review",
        "static_analysis",
        "memory_safety_checks",
        "input_validation",
        "fuzzing",
        "bounds_checking",
        "secure_coding_practices"
      ],
      "code_differences": {
        "has_differences": true,
        "source_lines": 2,
        "target_lines": 2,
        "character_differences": 953,
        "similarity_percentage": 56.52173913043478
      },
      "vulnerability_location": {
        "vulnerability_present": true,
        "fix_applied": true,
        "code_changed": true,
        "estimated_lines_changed": 0
      }
    },
    {
      "cve_id": "CVE-2020-11046",
      "cwe_id": "CWE-119",
      "cwe_name": "Buffer Overflow",
      "project": "FreeRDP",
      "severity": "critical",
      "weaponization_score": 8.0,
      "is_critical": true,
      "is_weaponizable": true,
      "is_high_priority_project": false,
      "vulnerable_code": "CWE-119 BOOL update_recv ( rdpUpdate * update , wStream * s ) { BOOL rc = FALSE ; UINT16 updateType ; rdpContext * context = update -> context ; if ( Stream_GetRemainingLength ( s ) < 2 ) { WLog_ERR ( TAG , \"Stream_GetRemainingLength(s)<S2SV_blank><<S2SV_blank>2\" ) ; return FALSE ; } Stream_Read_UINT16 ( s , updateType ) ; WLog_Print ( update -> log , WLOG_TRACE , \"%s<S2SV_blank>Update<S2SV_blank>Data<S2SV_blank>PDU\" , UPDATE_TYPE_STRINGS [ updateType ] ) ; if ( ! update_begin_paint ( update ) ) goto fail ; switch ( updateType ) { case UPDATE_TYPE_ORDERS : rc = update_recv_orders ( update , s ) ; break ; case UPDATE_TYPE_BITMAP : { BITMAP_UPDATE * bitmap_update = update_read_bitmap_update ( update , s ) ; if ( ! bitmap_update ) { WLog_ERR ( TAG , \"UPDATE_TYPE_BITMAP<S2SV_blank>-<S2SV_blank>update_read_bitmap_update()<S2SV_blank>failed\" ) ; goto fail ; } rc = IFCALLRESULT ( FALSE , update -> BitmapUpdate , context , bitmap_update ) ; free_bitmap_update ( update -> context , bitmap_update ) ; } break ; case UPDATE_TYPE_PALETTE : { PALETTE_UPDATE * palette_update = update_read_palette ( update , s ) ; if ( ! palette_update ) { WLog_ERR ( TAG , \"UPDATE_TYPE_PALETTE<S2SV_blank>-<S2SV_blank>update_read_palette()<S2SV_blank>failed\" ) ; goto fail ; } rc = IFCALLRESULT ( FALSE , update -> Palette , context , palette_update ) ; free_palette_update ( context , palette_update ) ; } break ; case UPDATE_TYPE_SYNCHRONIZE : <S2SV_StartBug> update_read_synchronize ( update , s ) ; <S2SV_EndBug> rc = IFCALLRESULT ( TRUE , update -> Synchronize , context ) ; break ; default : break ; } fail : if ( ! update_end_paint ( update ) ) rc = FALSE ; if ( ! rc ) { WLog_ERR ( TAG , \"UPDATE_TYPE<S2SV_blank>%s<S2SV_blank>[%\" PRIu16 \"]<S2SV_blank>failed\" , update_type_to_string ( updateType ) , updateType ) ; return FALSE ; } return TRUE ; }\n",
      "fixed_code": "<S2SV_ModStart> case UPDATE_TYPE_SYNCHRONIZE : if ( ! <S2SV_ModStart> , s ) ) goto fail\n",
      "source_code_length": 1842,
      "target_code_length": 88,
      "vulnerability_patterns": {
        "null_pointer": 12,
        "sql_injection": 14,
        "total": 26
      },
      "total_patterns": 26,
      "original_address": "https://github.com/FreeRDP/FreeRDP/commit/ed53cd148f43cbab905eaa0f5308c2bf3c48cc37",
      "discovery_time": "2020-05-07T19:15Z",
      "project_commit_id": "FreeRDP@FreeRDP/ed53cd148f43cbab905eaa0f5308c2bf3c48cc37",
      "extraction_time": "2025-08-31T15:41:49.185219",
      "label": 1,
      "vulnerability_type": "buffer_overflow",
      "difficulty_level": "advanced",
      "risk_factors": [
        "system_crash",
        "memory_corruption",
        "sql_injection",
        "arbitrary_code_execution"
      ],
      "attack_vectors": [
        "memory_manipulation",
        "malicious_input",
        "code_analysis",
        "buffer_overflow",
        "reverse_engineering",
        "fuzzing"
      ],
      "mitigation_strategies": [
        "safe_string_functions",
        "dynamic_analysis",
        "code_review",
        "static_analysis",
        "memory_safety_checks",
        "input_validation",
        "fuzzing",
        "bounds_checking",
        "secure_coding_practices"
      ],
      "code_differences": {
        "has_differences": true,
        "source_lines": 2,
        "target_lines": 2,
        "character_differences": 1754,
        "similarity_percentage": 14.473684210526317
      },
      "vulnerability_location": {
        "vulnerability_present": true,
        "fix_applied": true,
        "code_changed": true,
        "estimated_lines_changed": 0
      }
    },
    {
      "cve_id": "CVE-2017-7277",
      "cwe_id": "CWE-125",
      "cwe_name": "Out-of-bounds Read",
      "project": "torvalds",
      "severity": "critical",
      "weaponization_score": 8.0,
      "is_critical": true,
      "is_weaponizable": true,
      "is_high_priority_project": false,
      "vulnerable_code": "CWE-125 void __sock_recv_timestamp ( struct msghdr * msg , struct sock * sk , struct sk_buff * skb ) { int need_software_tstamp = sock_flag ( sk , SOCK_RCVTSTAMP ) ; struct scm_timestamping tss ; int empty = 1 ; struct skb_shared_hwtstamps * shhwtstamps = skb_hwtstamps ( skb ) ; if ( need_software_tstamp && skb -> tstamp == 0 ) __net_timestamp ( skb ) ; if ( need_software_tstamp ) { if ( ! sock_flag ( sk , SOCK_RCVTSTAMPNS ) ) { struct timeval tv ; skb_get_timestamp ( skb , & tv ) ; put_cmsg ( msg , SOL_SOCKET , SCM_TIMESTAMP , sizeof ( tv ) , & tv ) ; } else { struct timespec ts ; skb_get_timestampns ( skb , & ts ) ; put_cmsg ( msg , SOL_SOCKET , SCM_TIMESTAMPNS , sizeof ( ts ) , & ts ) ; } } memset ( & tss , 0 , sizeof ( tss ) ) ; if ( ( sk -> sk_tsflags & SOF_TIMESTAMPING_SOFTWARE ) && ktime_to_timespec_cond ( skb -> tstamp , tss . ts + 0 ) ) empty = 0 ; if ( shhwtstamps && ( sk -> sk_tsflags & SOF_TIMESTAMPING_RAW_HARDWARE ) && ktime_to_timespec_cond ( shhwtstamps -> hwtstamp , tss . ts + 2 ) ) empty = 0 ; if ( ! empty ) { put_cmsg ( msg , SOL_SOCKET , SCM_TIMESTAMPING , sizeof ( tss ) , & tss ) ; <S2SV_StartBug> if ( skb -> len && ( sk -> sk_tsflags & SOF_TIMESTAMPING_OPT_STATS ) ) <S2SV_EndBug> put_cmsg ( msg , SOL_SOCKET , SCM_TIMESTAMPING_OPT_STATS , skb -> len , skb -> data ) ; } }\n",
      "fixed_code": "<S2SV_ModStart> ; if ( skb_is_err_queue ( skb ) &&\n",
      "source_code_length": 1312,
      "target_code_length": 51,
      "vulnerability_patterns": {
        "buffer_overflow": 1,
        "null_pointer": 11,
        "total": 12
      },
      "total_patterns": 12,
      "original_address": "https://github.com/torvalds/linux/commit/8605330aac5a5785630aec8f64378a54891937cc",
      "discovery_time": "2017-03-28T06:59Z",
      "project_commit_id": "torvalds@linux/8605330aac5a5785630aec8f64378a54891937cc",
      "extraction_time": "2025-08-31T15:41:49.185242",
      "label": 1,
      "vulnerability_type": "out-of-bounds_read",
      "difficulty_level": "advanced",
      "risk_factors": [
        "information_disclosure",
        "memory_corruption",
        "integer_overflow",
        "buffer_overflow"
      ],
      "attack_vectors": [
        "memory_manipulation",
        "malicious_input",
        "code_analysis",
        "buffer_overflow",
        "reverse_engineering",
        "fuzzing"
      ],
      "mitigation_strategies": [
        "safe_string_functions",
        "dynamic_analysis",
        "code_review",
        "static_analysis",
        "memory_safety_checks",
        "input_validation",
        "fuzzing",
        "bounds_checking",
        "secure_coding_practices"
      ],
      "code_differences": {
        "has_differences": true,
        "source_lines": 2,
        "target_lines": 2,
        "character_differences": 1261,
        "similarity_percentage": 8.695652173913043
      },
      "vulnerability_location": {
        "vulnerability_present": true,
        "fix_applied": true,
        "code_changed": true,
        "estimated_lines_changed": 0
      }
    },
    {
      "cve_id": "CVE-2019-11338",
      "cwe_id": "CWE-476",
      "cwe_name": "NULL Pointer Dereference",
      "project": "FFmpeg",
      "severity": "critical",
      "weaponization_score": 8.0,
      "is_critical": true,
      "is_weaponizable": true,
      "is_high_priority_project": true,
      "vulnerable_code": "CWE-476 static int hls_slice_header ( HEVCContext * s ) { GetBitContext * gb = & s -> HEVClc -> gb ; SliceHeader * sh = & s -> sh ; int i , ret ; <S2SV_StartBug> sh -> first_slice_in_pic_flag = get_bits1 ( gb ) ; <S2SV_EndBug> if ( ( IS_IDR ( s ) || IS_BLA ( s ) ) && sh -> first_slice_in_pic_flag ) { s -> seq_decode = ( s -> seq_decode + 1 ) & 0xff ; s -> max_ra = INT_MAX ; if ( IS_IDR ( s ) ) ff_hevc_clear_refs ( s ) ; } sh -> no_output_of_prior_pics_flag = 0 ; if ( IS_IRAP ( s ) ) sh -> no_output_of_prior_pics_flag = get_bits1 ( gb ) ; sh -> pps_id = get_ue_golomb_long ( gb ) ; if ( sh -> pps_id >= HEVC_MAX_PPS_COUNT || ! s -> ps . pps_list [ sh -> pps_id ] ) { av_log ( s -> avctx , AV_LOG_ERROR , \"PPS<S2SV_blank>id<S2SV_blank>out<S2SV_blank>of<S2SV_blank>range:<S2SV_blank>%d\\\\n\" , sh -> pps_id ) ; return AVERROR_INVALIDDATA ; } if ( ! sh -> first_slice_in_pic_flag && s -> ps . pps != ( HEVCPPS * ) s -> ps . pps_list [ sh -> pps_id ] -> data ) { av_log ( s -> avctx , AV_LOG_ERROR , \"PPS<S2SV_blank>changed<S2SV_blank>between<S2SV_blank>slices.\\\\n\" ) ; return AVERROR_INVALIDDATA ; } s -> ps . pps = ( HEVCPPS * ) s -> ps . pps_list [ sh -> pps_id ] -> data ; if ( s -> nal_unit_type == HEVC_NAL_CRA_NUT && s -> last_eos == 1 ) sh -> no_output_of_prior_pics_flag = 1 ; if ( s -> ps . sps != ( HEVCSPS * ) s -> ps . sps_list [ s -> ps . pps -> sps_id ] -> data ) { const HEVCSPS * sps = ( HEVCSPS * ) s -> ps . sps_list [ s -> ps . pps -> sps_id ] -> data ; const HEVCSPS * last_sps = s -> ps . sps ; enum AVPixelFormat pix_fmt ; if ( last_sps && IS_IRAP ( s ) && s -> nal_unit_type != HEVC_NAL_CRA_NUT ) { if ( sps -> width != last_sps -> width || sps -> height != last_sps -> height || sps -> temporal_layer [ sps -> max_sub_layers - 1 ] . max_dec_pic_buffering != last_sps -> temporal_layer [ last_sps -> max_sub_layers - 1 ] . max_dec_pic_buffering ) sh -> no_output_of_prior_pics_flag = 0 ; } ff_hevc_clear_refs ( s ) ; ret = set_sps ( s , sps , sps -> pix_fmt ) ; if ( ret < 0 ) return ret ; pix_fmt = get_format ( s , sps ) ; if ( pix_fmt < 0 ) return pix_fmt ; s -> avctx -> pix_fmt = pix_fmt ; s -> seq_decode = ( s -> seq_decode + 1 ) & 0xff ; s -> max_ra = INT_MAX ; } sh -> dependent_slice_segment_flag = 0 ; if ( ! sh -> first_slice_in_pic_flag ) { int slice_address_length ; if ( s -> ps . pps -> dependent_slice_segments_enabled_flag ) sh -> dependent_slice_segment_flag = get_bits1 ( gb ) ; slice_address_length = av_ceil_log2 ( s -> ps . sps -> ctb_width * s -> ps . sps -> ctb_height ) ; sh -> slice_segment_addr = get_bitsz ( gb , slice_address_length ) ; if ( sh -> slice_segment_addr >= s -> ps . sps -> ctb_width * s -> ps . sps -> ctb_height ) { av_log ( s -> avctx , AV_LOG_ERROR , \"Invalid<S2SV_blank>slice<S2SV_blank>segment<S2SV_blank>address:<S2SV_blank>%u.\\\\n\" , sh -> slice_segment_addr ) ; return AVERROR_INVALIDDATA ; } if ( ! sh -> dependent_slice_segment_flag ) { sh -> slice_addr = sh -> slice_segment_addr ; s -> slice_idx ++ ; } } else { sh -> slice_segment_addr = sh -> slice_addr = 0 ; s -> slice_idx = 0 ; s -> slice_initialized = 0 ; } if ( ! sh -> dependent_slice_segment_flag ) { s -> slice_initialized = 0 ; for ( i = 0 ; i < s -> ps . pps -> num_extra_slice_header_bits ; i ++ ) skip_bits ( gb , 1 ) ; sh -> slice_type = get_ue_golomb_long ( gb ) ; if ( ! ( sh -> slice_type == HEVC_SLICE_I || sh -> slice_type == HEVC_SLICE_P || sh -> slice_type == HEVC_SLICE_B ) ) { av_log ( s -> avctx , AV_LOG_ERROR , \"Unknown<S2SV_blank>slice<S2SV_blank>type:<S2SV_blank>%d.\\\\n\" , sh -> slice_type ) ; return AVERROR_INVALIDDATA ; } if ( IS_IRAP ( s ) && sh -> slice_type != HEVC_SLICE_I ) { av_log ( s -> avctx , AV_LOG_ERROR , \"Inter<S2SV_blank>slices<S2SV_blank>in<S2SV_blank>an<S2SV_blank>IRAP<S2SV_blank>frame.\\\\n\" ) ; return AVERROR_INVALIDDATA ; } sh -> pic_output_flag = 1 ; if ( s -> ps . pps -> output_flag_present_flag ) sh -> pic_output_flag = get_bits1 ( gb ) ; if ( s -> ps . sps -> separate_colour_plane_flag ) sh -> colour_plane_id = get_bits ( gb , 2 ) ; if ( ! IS_IDR ( s ) ) { int poc , pos ; sh -> pic_order_cnt_lsb = get_bits ( gb , s -> ps . sps -> log2_max_poc_lsb ) ; poc = ff_hevc_compute_poc ( s -> ps . sps , s -> pocTid0 , sh -> pic_order_cnt_lsb , s -> nal_unit_type ) ; if ( ! sh -> first_slice_in_pic_flag && poc != s -> poc ) { av_log ( s -> avctx , AV_LOG_WARNING , \"Ignoring<S2SV_blank>POC<S2SV_blank>change<S2SV_blank>between<S2SV_blank>slices:<S2SV_blank>%d<S2SV_blank>-><S2SV_blank>%d\\\\n\" , s -> poc , poc ) ; if ( s -> avctx -> err_recognition & AV_EF_EXPLODE ) return AVERROR_INVALIDDATA ; poc = s -> poc ; } s -> poc = poc ; sh -> short_term_ref_pic_set_sps_flag = get_bits1 ( gb ) ; pos = get_bits_left ( gb ) ; if ( ! sh -> short_term_ref_pic_set_sps_flag ) { ret = ff_hevc_decode_short_term_rps ( gb , s -> avctx , & sh -> slice_rps , s -> ps . sps , 1 ) ; if ( ret < 0 ) return ret ; sh -> short_term_rps = & sh -> slice_rps ; } else { int numbits , rps_idx ; if ( ! s -> ps . sps -> nb_st_rps ) { av_log ( s -> avctx , AV_LOG_ERROR , \"No<S2SV_blank>ref<S2SV_blank>lists<S2SV_blank>in<S2SV_blank>the<S2SV_blank>SPS.\\\\n\" ) ; return AVERROR_INVALIDDATA ; } numbits = av_ceil_log2 ( s -> ps . sps -> nb_st_rps ) ; rps_idx = numbits > 0 ? get_bits ( gb , numbits ) : 0 ; sh -> short_term_rps = & s -> ps . sps -> st_rps [ rps_idx ] ; } sh -> short_term_ref_pic_set_size = pos - get_bits_left ( gb ) ; pos = get_bits_left ( gb ) ; ret = decode_lt_rps ( s , & sh -> long_term_rps , gb ) ; if ( ret < 0 ) { av_log ( s -> avctx , AV_LOG_WARNING , \"Invalid<S2SV_blank>long<S2SV_blank>term<S2SV_blank>RPS.\\\\n\" ) ; if ( s -> avctx -> err_recognition & AV_EF_EXPLODE ) return AVERROR_INVALIDDATA ; } sh -> long_term_ref_pic_set_size = pos - get_bits_left ( gb ) ; if ( s -> ps . sps -> sps_temporal_mvp_enabled_flag ) sh -> slice_temporal_mvp_enabled_flag = get_bits1 ( gb ) ; else sh -> slice_temporal_mvp_enabled_flag = 0 ; } else { s -> sh . short_term_rps = NULL ; s -> poc = 0 ; } if ( sh -> first_slice_in_pic_flag && s -> temporal_id == 0 && s -> nal_unit_type != HEVC_NAL_TRAIL_N && s -> nal_unit_type != HEVC_NAL_TSA_N && s -> nal_unit_type != HEVC_NAL_STSA_N && s -> nal_unit_type != HEVC_NAL_RADL_N && s -> nal_unit_type != HEVC_NAL_RADL_R && s -> nal_unit_type != HEVC_NAL_RASL_N && s -> nal_unit_type != HEVC_NAL_RASL_R ) s -> pocTid0 = s -> poc ; if ( s -> ps . sps -> sao_enabled ) { sh -> slice_sample_adaptive_offset_flag [ 0 ] = get_bits1 ( gb ) ; if ( s -> ps . sps -> chroma_format_idc ) { sh -> slice_sample_adaptive_offset_flag [ 1 ] = sh -> slice_sample_adaptive_offset_flag [ 2 ] = get_bits1 ( gb ) ; } } else { sh -> slice_sample_adaptive_offset_flag [ 0 ] = 0 ; sh -> slice_sample_adaptive_offset_flag [ 1 ] = 0 ; sh -> slice_sample_adaptive_offset_flag [ 2 ] = 0 ; } sh -> nb_refs [ L0 ] = sh -> nb_refs [ L1 ] = 0 ; if ( sh -> slice_type == HEVC_SLICE_P || sh -> slice_type == HEVC_SLICE_B ) { int nb_refs ; sh -> nb_refs [ L0 ] = s -> ps . pps -> num_ref_idx_l0_default_active ; if ( sh -> slice_type == HEVC_SLICE_B ) sh -> nb_refs [ L1 ] = s -> ps . pps -> num_ref_idx_l1_default_active ; if ( get_bits1 ( gb ) ) { sh -> nb_refs [ L0 ] = get_ue_golomb_long ( gb ) + 1 ; if ( sh -> slice_type == HEVC_SLICE_B ) sh -> nb_refs [ L1 ] = get_ue_golomb_long ( gb ) + 1 ; } if ( sh -> nb_refs [ L0 ] > HEVC_MAX_REFS || sh -> nb_refs [ L1 ] > HEVC_MAX_REFS ) { av_log ( s -> avctx , AV_LOG_ERROR , \"Too<S2SV_blank>many<S2SV_blank>refs:<S2SV_blank>%d/%d.\\\\n\" , sh -> nb_refs [ L0 ] , sh -> nb_refs [ L1 ] ) ; return AVERROR_INVALIDDATA ; } sh -> rpl_modification_flag [ 0 ] = 0 ; sh -> rpl_modification_flag [ 1 ] = 0 ; nb_refs = ff_hevc_frame_nb_refs ( s ) ; if ( ! nb_refs ) { av_log ( s -> avctx , AV_LOG_ERROR , \"Zero<S2SV_blank>refs<S2SV_blank>for<S2SV_blank>a<S2SV_blank>frame<S2SV_blank>with<S2SV_blank>P<S2SV_blank>or<S2SV_blank>B<S2SV_blank>slices.\\\\n\" ) ; return AVERROR_INVALIDDATA ; } if ( s -> ps . pps -> lists_modification_present_flag && nb_refs > 1 ) { sh -> rpl_modification_flag [ 0 ] = get_bits1 ( gb ) ; if ( sh -> rpl_modification_flag [ 0 ] ) { for ( i = 0 ; i < sh -> nb_refs [ L0 ] ; i ++ ) sh -> list_entry_lx [ 0 ] [ i ] = get_bits ( gb , av_ceil_log2 ( nb_refs ) ) ; } if ( sh -> slice_type == HEVC_SLICE_B ) { sh -> rpl_modification_flag [ 1 ] = get_bits1 ( gb ) ; if ( sh -> rpl_modification_flag [ 1 ] == 1 ) for ( i = 0 ; i < sh -> nb_refs [ L1 ] ; i ++ ) sh -> list_entry_lx [ 1 ] [ i ] = get_bits ( gb , av_ceil_log2 ( nb_refs ) ) ; } } if ( sh -> slice_type == HEVC_SLICE_B ) sh -> mvd_l1_zero_flag = get_bits1 ( gb ) ; if ( s -> ps . pps -> cabac_init_present_flag ) sh -> cabac_init_flag = get_bits1 ( gb ) ; else sh -> cabac_init_flag = 0 ; sh -> collocated_ref_idx = 0 ; if ( sh -> slice_temporal_mvp_enabled_flag ) { sh -> collocated_list = L0 ; if ( sh -> slice_type == HEVC_SLICE_B ) sh -> collocated_list = ! get_bits1 ( gb ) ; if ( sh -> nb_refs [ sh -> collocated_list ] > 1 ) { sh -> collocated_ref_idx = get_ue_golomb_long ( gb ) ; if ( sh -> collocated_ref_idx >= sh -> nb_refs [ sh -> collocated_list ] ) { av_log ( s -> avctx , AV_LOG_ERROR , \"Invalid<S2SV_blank>collocated_ref_idx:<S2SV_blank>%d.\\\\n\" , sh -> collocated_ref_idx ) ; return AVERROR_INVALIDDATA ; } } } if ( ( s -> ps . pps -> weighted_pred_flag && sh -> slice_type == HEVC_SLICE_P ) || ( s -> ps . pps -> weighted_bipred_flag && sh -> slice_type == HEVC_SLICE_B ) ) { int ret = pred_weight_table ( s , gb ) ; if ( ret < 0 ) return ret ; } sh -> max_num_merge_cand = 5 - get_ue_golomb_long ( gb ) ; if ( sh -> max_num_merge_cand < 1 || sh -> max_num_merge_cand > 5 ) { av_log ( s -> avctx , AV_LOG_ERROR , \"Invalid<S2SV_blank>number<S2SV_blank>of<S2SV_blank>merging<S2SV_blank>MVP<S2SV_blank>candidates:<S2SV_blank>%d.\\\\n\" , sh -> max_num_merge_cand ) ; return AVERROR_INVALIDDATA ; } } sh -> slice_qp_delta = get_se_golomb ( gb ) ; if ( s -> ps . pps -> pic_slice_level_chroma_qp_offsets_present_flag ) { sh -> slice_cb_qp_offset = get_se_golomb ( gb ) ; sh -> slice_cr_qp_offset = get_se_golomb ( gb ) ; } else { sh -> slice_cb_qp_offset = 0 ; sh -> slice_cr_qp_offset = 0 ; } if ( s -> ps . pps -> chroma_qp_offset_list_enabled_flag ) sh -> cu_chroma_qp_offset_enabled_flag = get_bits1 ( gb ) ; else sh -> cu_chroma_qp_offset_enabled_flag = 0 ; if ( s -> ps . pps -> deblocking_filter_control_present_flag ) { int deblocking_filter_override_flag = 0 ; if ( s -> ps . pps -> deblocking_filter_override_enabled_flag ) deblocking_filter_override_flag = get_bits1 ( gb ) ; if ( deblocking_filter_override_flag ) { sh -> disable_deblocking_filter_flag = get_bits1 ( gb ) ; if ( ! sh -> disable_deblocking_filter_flag ) { int beta_offset_div2 = get_se_golomb ( gb ) ; int tc_offset_div2 = get_se_golomb ( gb ) ; if ( beta_offset_div2 < - 6 || beta_offset_div2 > 6 || tc_offset_div2 < - 6 || tc_offset_div2 > 6 ) { av_log ( s -> avctx , AV_LOG_ERROR , \"Invalid<S2SV_blank>deblock<S2SV_blank>filter<S2SV_blank>offsets:<S2SV_blank>%d,<S2SV_blank>%d\\\\n\" , beta_offset_div2 , tc_offset_div2 ) ; return AVERROR_INVALIDDATA ; } sh -> beta_offset = beta_offset_div2 * 2 ; sh -> tc_offset = tc_offset_div2 * 2 ; } } else { sh -> disable_deblocking_filter_flag = s -> ps . pps -> disable_dbf ; sh -> beta_offset = s -> ps . pps -> beta_offset ; sh -> tc_offset = s -> ps . pps -> tc_offset ; } } else { sh -> disable_deblocking_filter_flag = 0 ; sh -> beta_offset = 0 ; sh -> tc_offset = 0 ; } if ( s -> ps . pps -> seq_loop_filter_across_slices_enabled_flag && ( sh -> slice_sample_adaptive_offset_flag [ 0 ] || sh -> slice_sample_adaptive_offset_flag [ 1 ] || ! sh -> disable_deblocking_filter_flag ) ) { sh -> slice_loop_filter_across_slices_enabled_flag = get_bits1 ( gb ) ; } else { sh -> slice_loop_filter_across_slices_enabled_flag = s -> ps . pps -> seq_loop_filter_across_slices_enabled_flag ; } } else if ( ! s -> slice_initialized ) { av_log ( s -> avctx , AV_LOG_ERROR , \"Independent<S2SV_blank>slice<S2SV_blank>segment<S2SV_blank>missing.\\\\n\" ) ; return AVERROR_INVALIDDATA ; } sh -> num_entry_point_offsets = 0 ; if ( s -> ps . pps -> tiles_enabled_flag || s -> ps . pps -> entropy_coding_sync_enabled_flag ) { unsigned num_entry_point_offsets = get_ue_golomb_long ( gb ) ; if ( num_entry_point_offsets > get_bits_left ( gb ) ) { av_log ( s -> avctx , AV_LOG_ERROR , \"num_entry_point_offsets<S2SV_blank>%d<S2SV_blank>is<S2SV_blank>invalid\\\\n\" , num_entry_point_offsets ) ; return AVERROR_INVALIDDATA ; } sh -> num_entry_point_offsets = num_entry_point_offsets ; if ( sh -> num_entry_point_offsets > 0 ) { int offset_len = get_ue_golomb_long ( gb ) + 1 ; if ( offset_len < 1 || offset_len > 32 ) { sh -> num_entry_point_offsets = 0 ; av_log ( s -> avctx , AV_LOG_ERROR , \"offset_len<S2SV_blank>%d<S2SV_blank>is<S2SV_blank>invalid\\\\n\" , offset_len ) ; return AVERROR_INVALIDDATA ; } av_freep ( & sh -> entry_point_offset ) ; av_freep ( & sh -> offset ) ; av_freep ( & sh -> size ) ; sh -> entry_point_offset = av_malloc_array ( sh -> num_entry_point_offsets , sizeof ( unsigned ) ) ; sh -> offset = av_malloc_array ( sh -> num_entry_point_offsets , sizeof ( int ) ) ; sh -> size = av_malloc_array ( sh -> num_entry_point_offsets , sizeof ( int ) ) ; if ( ! sh -> entry_point_offset || ! sh -> offset || ! sh -> size ) { sh -> num_entry_point_offsets = 0 ; av_log ( s -> avctx , AV_LOG_ERROR , \"Failed<S2SV_blank>to<S2SV_blank>allocate<S2SV_blank>memory\\\\n\" ) ; return AVERROR ( ENOMEM ) ; } for ( i = 0 ; i < sh -> num_entry_point_offsets ; i ++ ) { unsigned val = get_bits_long ( gb , offset_len ) ; sh -> entry_point_offset [ i ] = val + 1 ; } if ( s -> threads_number > 1 && ( s -> ps . pps -> num_tile_rows > 1 || s -> ps . pps -> num_tile_columns > 1 ) ) { s -> enable_parallel_tiles = 0 ; s -> threads_number = 1 ; } else s -> enable_parallel_tiles = 0 ; } else s -> enable_parallel_tiles = 0 ; } if ( s -> ps . pps -> slice_header_extension_present_flag ) { unsigned int length = get_ue_golomb_long ( gb ) ; if ( length * 8LL > get_bits_left ( gb ) ) { av_log ( s -> avctx , AV_LOG_ERROR , \"too<S2SV_blank>many<S2SV_blank>slice_header_extension_data_bytes\\\\n\" ) ; return AVERROR_INVALIDDATA ; } for ( i = 0 ; i < length ; i ++ ) skip_bits ( gb , 8 ) ; } sh -> slice_qp = 26U + s -> ps . pps -> pic_init_qp_minus26 + sh -> slice_qp_delta ; if ( sh -> slice_qp > 51 || sh -> slice_qp < - s -> ps . sps -> qp_bd_offset ) { av_log ( s -> avctx , AV_LOG_ERROR , \"The<S2SV_blank>slice_qp<S2SV_blank>%d<S2SV_blank>is<S2SV_blank>outside<S2SV_blank>the<S2SV_blank>valid<S2SV_blank>range<S2SV_blank>\" \"[%d,<S2SV_blank>51].\\\\n\" , sh -> slice_qp , - s -> ps . sps -> qp_bd_offset ) ; return AVERROR_INVALIDDATA ; } sh -> slice_ctb_addr_rs = sh -> slice_segment_addr ; if ( ! s -> sh . slice_ctb_addr_rs && s -> sh . dependent_slice_segment_flag ) { av_log ( s -> avctx , AV_LOG_ERROR , \"Impossible<S2SV_blank>slice<S2SV_blank>segment.\\\\n\" ) ; return AVERROR_INVALIDDATA ; } if ( get_bits_left ( gb ) < 0 ) { av_log ( s -> avctx , AV_LOG_ERROR , \"Overread<S2SV_blank>slice<S2SV_blank>header<S2SV_blank>by<S2SV_blank>%d<S2SV_blank>bits\\\\n\" , - get_bits_left ( gb ) ) ; return AVERROR_INVALIDDATA ; } s -> HEVClc -> first_qp_group = ! s -> sh . dependent_slice_segment_flag ; if ( ! s -> ps . pps -> cu_qp_delta_enabled_flag ) s -> HEVClc -> qp_y = s -> sh . slice_qp ; s -> slice_initialized = 1 ; s -> HEVClc -> tu . cu_qp_offset_cb = 0 ; s -> HEVClc -> tu . cu_qp_offset_cr = 0 ; return 0 ; }\n",
      "fixed_code": "<S2SV_ModStart> gb ) ; if ( s -> ref && sh -> first_slice_in_pic_flag ) { av_log ( s -> avctx , AV_LOG_ERROR , \"Two<S2SV_blank>slices<S2SV_blank>reporting<S2SV_blank>being<S2SV_blank>the<S2SV_blank>first<S2SV_blank>in<S2SV_blank>the<S2SV_blank>same<S2SV_blank>frame.\\\\n\" ) ; return 1 ; }\n",
      "source_code_length": 15405,
      "target_code_length": 288,
      "vulnerability_patterns": {
        "integer_overflow": 6,
        "null_pointer": 339,
        "total": 345
      },
      "total_patterns": 345,
      "original_address": "https://github.com/FFmpeg/FFmpeg/commit/54655623a82632e7624714d7b2a3e039dc5faa7e",
      "discovery_time": "2019-04-19T00:29Z",
      "project_commit_id": "FFmpeg@FFmpeg/54655623a82632e7624714d7b2a3e039dc5faa7e",
      "extraction_time": "2025-08-31T15:41:49.185265",
      "label": 1,
      "vulnerability_type": "null_pointer_dereference",
      "difficulty_level": "advanced",
      "risk_factors": [
        "system_crash",
        "denial_of_service",
        "memory_corruption",
        "critical_infrastructure"
      ],
      "attack_vectors": [
        "memory_manipulation",
        "null_pointer",
        "code_analysis",
        "reverse_engineering",
        "use_after_free",
        "fuzzing"
      ],
      "mitigation_strategies": [
        "null_pointer_checks",
        "fuzzing",
        "dynamic_analysis",
        "memory_management",
        "static_analysis",
        "use_after_free_prevention",
        "code_review",
        "secure_coding_practices"
      ],
      "code_differences": {
        "has_differences": true,
        "source_lines": 2,
        "target_lines": 2,
        "character_differences": 15117,
        "similarity_percentage": 7.258064516129033
      },
      "vulnerability_location": {
        "vulnerability_present": true,
        "fix_applied": true,
        "code_changed": true,
        "estimated_lines_changed": 0
      }
    },
    {
      "cve_id": "CVE-2016-10088",
      "cwe_id": "CWE-416",
      "cwe_name": "Use After Free",
      "project": "torvalds",
      "severity": "critical",
      "weaponization_score": 8.0,
      "is_critical": true,
      "is_weaponizable": true,
      "is_high_priority_project": false,
      "vulnerable_code": "CWE-416 static ssize_t sg_write ( struct file * filp , const char __user * buf , size_t count , loff_t * ppos ) { int mxsize , cmd_size , k ; int input_size , blocking ; unsigned char opcode ; Sg_device * sdp ; Sg_fd * sfp ; Sg_request * srp ; struct sg_header old_hdr ; sg_io_hdr_t * hp ; unsigned char cmnd [ SG_MAX_CDB_SIZE ] ; <S2SV_StartBug> if ( ( ! ( sfp = ( Sg_fd * ) filp -> private_data ) ) || ( ! ( sdp = sfp -> parentdp ) ) ) <S2SV_EndBug> return - ENXIO ; SCSI_LOG_TIMEOUT ( 3 , sg_printk ( KERN_INFO , sdp , \"sg_write:<S2SV_blank>count=%d\\\\n\" , ( int ) count ) ) ; if ( atomic_read ( & sdp -> detaching ) ) return - ENODEV ; if ( ! ( ( filp -> f_flags & O_NONBLOCK ) || scsi_block_when_processing_errors ( sdp -> device ) ) ) return - ENXIO ; if ( ! access_ok ( VERIFY_READ , buf , count ) ) return - EFAULT ; if ( count < SZ_SG_HEADER ) return - EIO ; if ( __copy_from_user ( & old_hdr , buf , SZ_SG_HEADER ) ) return - EFAULT ; blocking = ! ( filp -> f_flags & O_NONBLOCK ) ; if ( old_hdr . reply_len < 0 ) return sg_new_write ( sfp , filp , buf , count , blocking , 0 , 0 , NULL ) ; if ( count < ( SZ_SG_HEADER + 6 ) ) return - EIO ; if ( ! ( srp = sg_add_request ( sfp ) ) ) { SCSI_LOG_TIMEOUT ( 1 , sg_printk ( KERN_INFO , sdp , \"sg_write:<S2SV_blank>queue<S2SV_blank>full\\\\n\" ) ) ; return - EDOM ; } buf += SZ_SG_HEADER ; __get_user ( opcode , buf ) ; if ( sfp -> next_cmd_len > 0 ) { cmd_size = sfp -> next_cmd_len ; sfp -> next_cmd_len = 0 ; } else { cmd_size = COMMAND_SIZE ( opcode ) ; if ( ( opcode >= 0xc0 ) && old_hdr . twelve_byte ) cmd_size = 12 ; } SCSI_LOG_TIMEOUT ( 4 , sg_printk ( KERN_INFO , sdp , \"sg_write:<S2SV_blank><S2SV_blank><S2SV_blank>scsi<S2SV_blank>opcode=0x%02x,<S2SV_blank>cmd_size=%d\\\\n\" , ( int ) opcode , cmd_size ) ) ; input_size = count - cmd_size ; mxsize = ( input_size > old_hdr . reply_len ) ? input_size : old_hdr . reply_len ; mxsize -= SZ_SG_HEADER ; input_size -= SZ_SG_HEADER ; if ( input_size < 0 ) { sg_remove_request ( sfp , srp ) ; return - EIO ; } hp = & srp -> header ; hp -> interface_id = '\\\\0' ; hp -> cmd_len = ( unsigned char ) cmd_size ; hp -> iovec_count = 0 ; hp -> mx_sb_len = 0 ; if ( input_size > 0 ) hp -> dxfer_direction = ( old_hdr . reply_len > SZ_SG_HEADER ) ? SG_DXFER_TO_FROM_DEV : SG_DXFER_TO_DEV ; else hp -> dxfer_direction = ( mxsize > 0 ) ? SG_DXFER_FROM_DEV : SG_DXFER_NONE ; hp -> dxfer_len = mxsize ; if ( ( hp -> dxfer_direction == SG_DXFER_TO_DEV ) || ( hp -> dxfer_direction == SG_DXFER_TO_FROM_DEV ) ) hp -> dxferp = ( char __user * ) buf + cmd_size ; else hp -> dxferp = NULL ; hp -> sbp = NULL ; hp -> timeout = old_hdr . reply_len ; hp -> flags = input_size ; hp -> pack_id = old_hdr . pack_id ; hp -> usr_ptr = NULL ; if ( __copy_from_user ( cmnd , buf , cmd_size ) ) return - EFAULT ; if ( hp -> dxfer_direction == SG_DXFER_TO_FROM_DEV ) { static char cmd [ TASK_COMM_LEN ] ; if ( strcmp ( current -> comm , cmd ) ) { printk_ratelimited ( KERN_WARNING \"sg_write:<S2SV_blank>data<S2SV_blank>in/out<S2SV_blank>%d/%d<S2SV_blank>bytes<S2SV_blank>\" \"for<S2SV_blank>SCSI<S2SV_blank>command<S2SV_blank>0x%x--<S2SV_blank>guessing<S2SV_blank>\" \"data<S2SV_blank>in;\\\\n<S2SV_blank><S2SV_blank><S2SV_blank>program<S2SV_blank>%s<S2SV_blank>not<S2SV_blank>setting<S2SV_blank>\" \"count<S2SV_blank>and/or<S2SV_blank>reply_len<S2SV_blank>properly\\\\n\" , old_hdr . reply_len - ( int ) SZ_SG_HEADER , input_size , ( unsigned int ) cmnd [ 0 ] , current -> comm ) ; strcpy ( cmd , current -> comm ) ; } } k = sg_common_write ( sfp , srp , cmnd , sfp -> timeout , blocking ) ; return ( k < 0 ) ? k : count ; }\n",
      "fixed_code": "<S2SV_ModStart> ; if ( unlikely ( segment_eq ( get_fs ( ) , KERNEL_DS ) ) ) return - EINVAL ; if (\n",
      "source_code_length": 3588,
      "target_code_length": 99,
      "vulnerability_patterns": {
        "buffer_overflow": 1,
        "integer_overflow": 4,
        "null_pointer": 31,
        "total": 36
      },
      "total_patterns": 36,
      "original_address": "https://github.com/torvalds/linux/commit/128394eff343fc6d2f32172f03e24829539c5835",
      "discovery_time": "2016-12-30T18:59Z",
      "project_commit_id": "torvalds@linux/128394eff343fc6d2f32172f03e24829539c5835",
      "extraction_time": "2025-08-31T15:41:49.185381",
      "label": 1,
      "vulnerability_type": "use_after_free",
      "difficulty_level": "advanced",
      "risk_factors": [
        "system_crash",
        "denial_of_service",
        "memory_corruption",
        "buffer_overflow"
      ],
      "attack_vectors": [
        "memory_manipulation",
        "null_pointer",
        "code_analysis",
        "reverse_engineering",
        "use_after_free",
        "fuzzing"
      ],
      "mitigation_strategies": [
        "null_pointer_checks",
        "fuzzing",
        "dynamic_analysis",
        "memory_management",
        "static_analysis",
        "use_after_free_prevention",
        "code_review",
        "secure_coding_practices"
      ],
      "code_differences": {
        "has_differences": true,
        "source_lines": 2,
        "target_lines": 2,
        "character_differences": 3489,
        "similarity_percentage": 4.929577464788732
      },
      "vulnerability_location": {
        "vulnerability_present": true,
        "fix_applied": true,
        "code_changed": true,
        "estimated_lines_changed": 0
      }
    },
    {
      "cve_id": "CVE-2019-6978",
      "cwe_id": "CWE-415",
      "cwe_name": "Double Free",
      "project": "php",
      "severity": "critical",
      "weaponization_score": 8.0,
      "is_critical": true,
      "is_weaponizable": true,
      "is_high_priority_project": true,
      "vulnerable_code": "CWE-415 void * gdImageGifPtr ( gdImagePtr im , int * size ) { void * rv ; gdIOCtx * out = gdNewDynamicCtx ( 2048 , NULL ) ; <S2SV_StartBug> gdImageGifCtx ( im , out ) ; <S2SV_EndBug> <S2SV_StartBug> rv = gdDPExtractData ( out , size ) ; <S2SV_EndBug> out -> gd_free ( out ) ; return rv ; }\n",
      "fixed_code": "<S2SV_ModStart> NULL ) ; if ( ! _gdImageGifCtx <S2SV_ModEnd> ( im , <S2SV_ModStart> , out ) ) { <S2SV_ModEnd> rv = gdDPExtractData <S2SV_ModStart> size ) ; } else { rv = NULL ; }\n",
      "source_code_length": 290,
      "target_code_length": 179,
      "vulnerability_patterns": {
        "integer_overflow": 3,
        "null_pointer": 1,
        "sql_injection": 1,
        "total": 5
      },
      "total_patterns": 5,
      "original_address": "https://github.com/php/php-src/commit/089f7c0bc28d399b0420aa6ef058e4c1c120b2ae",
      "discovery_time": "2019-01-28T08:29Z",
      "project_commit_id": "php@php-src/089f7c0bc28d399b0420aa6ef058e4c1c120b2ae",
      "extraction_time": "2025-08-31T15:41:49.185416",
      "label": 1,
      "vulnerability_type": "double_free",
      "difficulty_level": "advanced",
      "risk_factors": [
        "denial_of_service",
        "memory_corruption",
        "critical_infrastructure",
        "sql_injection",
        "system_crash"
      ],
      "attack_vectors": [
        "memory_manipulation",
        "null_pointer",
        "code_analysis",
        "reverse_engineering",
        "use_after_free",
        "fuzzing"
      ],
      "mitigation_strategies": [
        "null_pointer_checks",
        "fuzzing",
        "dynamic_analysis",
        "memory_management",
        "static_analysis",
        "use_after_free_prevention",
        "code_review",
        "secure_coding_practices"
      ],
      "code_differences": {
        "has_differences": true,
        "source_lines": 2,
        "target_lines": 2,
        "character_differences": 111,
        "similarity_percentage": 38.23529411764706
      },
      "vulnerability_location": {
        "vulnerability_present": true,
        "fix_applied": true,
        "code_changed": true,
        "estimated_lines_changed": 0
      }
    },
    {
      "cve_id": "CVE-2013-7015",
      "cwe_id": "CWE-20",
      "cwe_name": "Improper Input Validation",
      "project": "FFmpeg",
      "severity": "critical",
      "weaponization_score": 8.0,
      "is_critical": true,
      "is_weaponizable": true,
      "is_high_priority_project": true,
      "vulnerable_code": "CWE-20 static int flashsv_decode_frame ( AVCodecContext * avctx , void * data , int * got_frame , AVPacket * avpkt ) { int buf_size = avpkt -> size ; FlashSVContext * s = avctx -> priv_data ; int h_blocks , v_blocks , h_part , v_part , i , j , ret ; GetBitContext gb ; int last_blockwidth = s -> block_width ; int last_blockheight = s -> block_height ; if ( buf_size == 0 ) return 0 ; if ( buf_size < 4 ) return - 1 ; init_get_bits ( & gb , avpkt -> data , buf_size * 8 ) ; s -> block_width = 16 * ( get_bits ( & gb , 4 ) + 1 ) ; s -> image_width = get_bits ( & gb , 12 ) ; s -> block_height = 16 * ( get_bits ( & gb , 4 ) + 1 ) ; s -> image_height = get_bits ( & gb , 12 ) ; if ( last_blockwidth != s -> block_width || last_blockheight != s -> block_height ) av_freep ( & s -> blocks ) ; if ( s -> ver == 2 ) { skip_bits ( & gb , 6 ) ; if ( get_bits1 ( & gb ) ) { avpriv_request_sample ( avctx , \"iframe\" ) ; return AVERROR_PATCHWELCOME ; } if ( get_bits1 ( & gb ) ) { avpriv_request_sample ( avctx , \"Custom<S2SV_blank>palette\" ) ; return AVERROR_PATCHWELCOME ; } } h_blocks = s -> image_width / s -> block_width ; h_part = s -> image_width % s -> block_width ; v_blocks = s -> image_height / s -> block_height ; v_part = s -> image_height % s -> block_height ; if ( s -> block_size < s -> block_width * s -> block_height ) { int tmpblock_size = 3 * s -> block_width * s -> block_height ; s -> tmpblock = av_realloc ( s -> tmpblock , tmpblock_size ) ; if ( ! s -> tmpblock ) { av_log ( avctx , AV_LOG_ERROR , \"Can\\'t<S2SV_blank>allocate<S2SV_blank>decompression<S2SV_blank>buffer.\\\\n\" ) ; return AVERROR ( ENOMEM ) ; } if ( s -> ver == 2 ) { s -> deflate_block_size = calc_deflate_block_size ( tmpblock_size ) ; if ( s -> deflate_block_size <= 0 ) { av_log ( avctx , AV_LOG_ERROR , \"Can\\'t<S2SV_blank>determine<S2SV_blank>deflate<S2SV_blank>buffer<S2SV_blank>size.\\\\n\" ) ; return - 1 ; } s -> deflate_block = av_realloc ( s -> deflate_block , s -> deflate_block_size ) ; if ( ! s -> deflate_block ) { av_log ( avctx , AV_LOG_ERROR , \"Can\\'t<S2SV_blank>allocate<S2SV_blank>deflate<S2SV_blank>buffer.\\\\n\" ) ; return AVERROR ( ENOMEM ) ; } } } s -> block_size = s -> block_width * s -> block_height ; if ( avctx -> width == 0 && avctx -> height == 0 ) { avcodec_set_dimensions ( avctx , s -> image_width , s -> image_height ) ; } if ( avctx -> width != s -> image_width || avctx -> height != s -> image_height ) { av_log ( avctx , AV_LOG_ERROR , \"Frame<S2SV_blank>width<S2SV_blank>or<S2SV_blank>height<S2SV_blank>differs<S2SV_blank>from<S2SV_blank>first<S2SV_blank>frame!\\\\n\" ) ; av_log ( avctx , AV_LOG_ERROR , \"fh<S2SV_blank>=<S2SV_blank>%d,<S2SV_blank>fv<S2SV_blank>%d<S2SV_blank><S2SV_blank>vs<S2SV_blank><S2SV_blank>ch<S2SV_blank>=<S2SV_blank>%d,<S2SV_blank>cv<S2SV_blank>=<S2SV_blank>%d\\\\n\" , avctx -> height , avctx -> width , s -> image_height , s -> image_width ) ; return AVERROR_INVALIDDATA ; } s -> is_keyframe = ( avpkt -> flags & AV_PKT_FLAG_KEY ) && ( s -> ver == 2 ) ; if ( s -> is_keyframe ) { s -> keyframedata = av_realloc ( s -> keyframedata , avpkt -> size ) ; memcpy ( s -> keyframedata , avpkt -> data , avpkt -> size ) ; } if ( s -> ver == 2 && ! s -> blocks ) s -> blocks = av_mallocz ( ( v_blocks + ! ! v_part ) * ( h_blocks + ! ! h_part ) * sizeof ( s -> blocks [ 0 ] ) ) ; av_dlog ( avctx , \"image:<S2SV_blank>%dx%d<S2SV_blank>block:<S2SV_blank>%dx%d<S2SV_blank>num:<S2SV_blank>%dx%d<S2SV_blank>part:<S2SV_blank>%dx%d\\\\n\" , s -> image_width , s -> image_height , s -> block_width , s -> block_height , h_blocks , v_blocks , h_part , v_part ) ; if ( ( ret = ff_reget_buffer ( avctx , & s -> frame ) ) < 0 ) return ret ; for ( j = 0 ; j < v_blocks + ( v_part ? 1 : 0 ) ; j ++ ) { int y_pos = j * s -> block_height ; int cur_blk_height = ( j < v_blocks ) ? s -> block_height : v_part ; for ( i = 0 ; i < h_blocks + ( h_part ? 1 : 0 ) ; i ++ ) { int x_pos = i * s -> block_width ; int cur_blk_width = ( i < h_blocks ) ? s -> block_width : h_part ; int has_diff = 0 ; int size = get_bits ( & gb , 16 ) ; s -> color_depth = 0 ; s -> zlibprime_curr = 0 ; s -> zlibprime_prev = 0 ; s -> diff_start = 0 ; s -> diff_height = cur_blk_height ; if ( 8 * size > get_bits_left ( & gb ) ) { av_frame_unref ( & s -> frame ) ; return AVERROR_INVALIDDATA ; } if ( s -> ver == 2 && size ) { skip_bits ( & gb , 3 ) ; s -> color_depth = get_bits ( & gb , 2 ) ; has_diff = get_bits1 ( & gb ) ; s -> zlibprime_curr = get_bits1 ( & gb ) ; s -> zlibprime_prev = get_bits1 ( & gb ) ; if ( s -> color_depth != 0 && s -> color_depth != 2 ) { av_log ( avctx , AV_LOG_ERROR , \"%dx%d<S2SV_blank>invalid<S2SV_blank>color<S2SV_blank>depth<S2SV_blank>%d\\\\n\" , i , j , s -> color_depth ) ; return AVERROR_INVALIDDATA ; } if ( has_diff ) { if ( ! s -> keyframe ) { av_log ( avctx , AV_LOG_ERROR , \"inter<S2SV_blank>frame<S2SV_blank>without<S2SV_blank>keyframe\\\\n\" ) ; return AVERROR_INVALIDDATA ; } s -> diff_start = get_bits ( & gb , 8 ) ; s -> diff_height = get_bits ( & gb , 8 ) ; <S2SV_StartBug> av_log ( avctx , AV_LOG_DEBUG , <S2SV_EndBug> \"%dx%d<S2SV_blank>diff<S2SV_blank>start<S2SV_blank>%d<S2SV_blank>height<S2SV_blank>%d\\\\n\" , i , j , s -> diff_start , s -> diff_height ) ; size -= 2 ; } if ( s -> zlibprime_prev ) av_log ( avctx , AV_LOG_DEBUG , \"%dx%d<S2SV_blank>zlibprime_prev\\\\n\" , i , j ) ; if ( s -> zlibprime_curr ) { int col = get_bits ( & gb , 8 ) ; int row = get_bits ( & gb , 8 ) ; av_log ( avctx , AV_LOG_DEBUG , \"%dx%d<S2SV_blank>zlibprime_curr<S2SV_blank>%dx%d\\\\n\" , i , j , col , row ) ; size -= 2 ; avpriv_request_sample ( avctx , \"zlibprime_curr\" ) ; return AVERROR_PATCHWELCOME ; } if ( ! s -> blocks && ( s -> zlibprime_curr || s -> zlibprime_prev ) ) { av_log ( avctx , AV_LOG_ERROR , \"no<S2SV_blank>data<S2SV_blank>available<S2SV_blank>for<S2SV_blank>zlib<S2SV_blank>\" \"priming\\\\n\" ) ; return AVERROR_INVALIDDATA ; } size -- ; } if ( has_diff ) { int k ; int off = ( s -> image_height - y_pos - 1 ) * s -> frame . linesize [ 0 ] ; for ( k = 0 ; k < cur_blk_height ; k ++ ) memcpy ( s -> frame . data [ 0 ] + off - k * s -> frame . linesize [ 0 ] + x_pos * 3 , s -> keyframe + off - k * s -> frame . linesize [ 0 ] + x_pos * 3 , cur_blk_width * 3 ) ; } if ( size ) { if ( flashsv_decode_block ( avctx , avpkt , & gb , size , cur_blk_width , cur_blk_height , x_pos , y_pos , i + j * ( h_blocks + ! ! h_part ) ) ) av_log ( avctx , AV_LOG_ERROR , \"error<S2SV_blank>in<S2SV_blank>decompression<S2SV_blank>of<S2SV_blank>block<S2SV_blank>%dx%d\\\\n\" , i , j ) ; } } } if ( s -> is_keyframe && s -> ver == 2 ) { if ( ! s -> keyframe ) { s -> keyframe = av_malloc ( s -> frame . linesize [ 0 ] * avctx -> height ) ; if ( ! s -> keyframe ) { av_log ( avctx , AV_LOG_ERROR , \"Cannot<S2SV_blank>allocate<S2SV_blank>image<S2SV_blank>data\\\\n\" ) ; return AVERROR ( ENOMEM ) ; } } memcpy ( s -> keyframe , s -> frame . data [ 0 ] , s -> frame . linesize [ 0 ] * avctx -> height ) ; } if ( ( ret = av_frame_ref ( data , & s -> frame ) ) < 0 ) return ret ; * got_frame = 1 ; if ( ( get_bits_count ( & gb ) / 8 ) != buf_size ) av_log ( avctx , AV_LOG_ERROR , \"buffer<S2SV_blank>not<S2SV_blank>fully<S2SV_blank>consumed<S2SV_blank>(%d<S2SV_blank>!=<S2SV_blank>%d)\\\\n\" , buf_size , ( get_bits_count ( & gb ) / 8 ) ) ; return buf_size ; }\n",
      "fixed_code": "<S2SV_ModStart> 8 ) ; if ( s -> diff_start + s -> diff_height > cur_blk_height ) { av_log ( avctx , AV_LOG_ERROR , \"Block<S2SV_blank>parameters<S2SV_blank>invalid\\\\n\" ) ; return AVERROR_INVALIDDATA ; }\n",
      "source_code_length": 7237,
      "target_code_length": 202,
      "vulnerability_patterns": {
        "buffer_overflow": 3,
        "integer_overflow": 6,
        "null_pointer": 115,
        "total": 124
      },
      "total_patterns": 124,
      "original_address": "https://github.com/FFmpeg/FFmpeg/commit/880c73cd76109697447fbfbaa8e5ee5683309446",
      "discovery_time": "2013-12-09T16:36Z",
      "project_commit_id": "FFmpeg@FFmpeg/880c73cd76109697447fbfbaa8e5ee5683309446",
      "extraction_time": "2025-08-31T15:41:49.185433",
      "label": 1,
      "vulnerability_type": "improper_input_validation",
      "difficulty_level": "advanced",
      "risk_factors": [
        "critical_infrastructure",
        "buffer_overflow"
      ],
      "attack_vectors": [
        "fuzzing",
        "code_analysis",
        "reverse_engineering"
      ],
      "mitigation_strategies": [
        "dynamic_analysis",
        "static_analysis",
        "fuzzing",
        "code_review",
        "secure_coding_practices"
      ],
      "code_differences": {
        "has_differences": true,
        "source_lines": 2,
        "target_lines": 2,
        "character_differences": 7035,
        "similarity_percentage": 13.071895424836603
      },
      "vulnerability_location": {
        "vulnerability_present": true,
        "fix_applied": true,
        "code_changed": true,
        "estimated_lines_changed": 0
      }
    },
    {
      "cve_id": "CVE-2018-13301",
      "cwe_id": "CWE-476",
      "cwe_name": "NULL Pointer Dereference",
      "project": "FFmpeg",
      "severity": "critical",
      "weaponization_score": 8.0,
      "is_critical": true,
      "is_weaponizable": true,
      "is_high_priority_project": true,
      "vulnerable_code": "CWE-476 int ff_mpeg4_decode_picture_header ( Mpeg4DecContext * ctx , GetBitContext * gb ) { MpegEncContext * s = & ctx -> m ; unsigned startcode , v ; int ret ; int vol = 0 ; align_get_bits ( gb ) ; if ( ! s -> studio_profile && s -> avctx -> bits_per_raw_sample != 8 ) s -> avctx -> bits_per_raw_sample = 0 ; if ( s -> codec_tag == AV_RL32 ( \"WV1F\" ) && show_bits ( gb , 24 ) == 0x575630 ) { skip_bits ( gb , 24 ) ; if ( get_bits ( gb , 8 ) == 0xF0 ) goto end ; } startcode = 0xff ; for ( ; ; ) { if ( get_bits_count ( gb ) >= gb -> size_in_bits ) { if ( gb -> size_in_bits == 8 && ( ctx -> divx_version >= 0 || ctx -> xvid_build >= 0 ) || s -> codec_tag == AV_RL32 ( \"QMP4\" ) ) { av_log ( s -> avctx , AV_LOG_VERBOSE , \"frame<S2SV_blank>skip<S2SV_blank>%d\\\\n\" , gb -> size_in_bits ) ; return FRAME_SKIPPED ; } else return AVERROR_INVALIDDATA ; } v = get_bits ( gb , 8 ) ; startcode = ( ( startcode << 8 ) | v ) & 0xffffffff ; if ( ( startcode & 0xFFFFFF00 ) != 0x100 ) continue ; if ( s -> avctx -> debug & FF_DEBUG_STARTCODE ) { av_log ( s -> avctx , AV_LOG_DEBUG , \"startcode:<S2SV_blank>%3X<S2SV_blank>\" , startcode ) ; if ( startcode <= 0x11F ) av_log ( s -> avctx , AV_LOG_DEBUG , \"Video<S2SV_blank>Object<S2SV_blank>Start\" ) ; else if ( startcode <= 0x12F ) av_log ( s -> avctx , AV_LOG_DEBUG , \"Video<S2SV_blank>Object<S2SV_blank>Layer<S2SV_blank>Start\" ) ; else if ( startcode <= 0x13F ) av_log ( s -> avctx , AV_LOG_DEBUG , \"Reserved\" ) ; else if ( startcode <= 0x15F ) av_log ( s -> avctx , AV_LOG_DEBUG , \"FGS<S2SV_blank>bp<S2SV_blank>start\" ) ; else if ( startcode <= 0x1AF ) av_log ( s -> avctx , AV_LOG_DEBUG , \"Reserved\" ) ; else if ( startcode == 0x1B0 ) av_log ( s -> avctx , AV_LOG_DEBUG , \"Visual<S2SV_blank>Object<S2SV_blank>Seq<S2SV_blank>Start\" ) ; else if ( startcode == 0x1B1 ) av_log ( s -> avctx , AV_LOG_DEBUG , \"Visual<S2SV_blank>Object<S2SV_blank>Seq<S2SV_blank>End\" ) ; else if ( startcode == 0x1B2 ) av_log ( s -> avctx , AV_LOG_DEBUG , \"User<S2SV_blank>Data\" ) ; else if ( startcode == 0x1B3 ) av_log ( s -> avctx , AV_LOG_DEBUG , \"Group<S2SV_blank>of<S2SV_blank>VOP<S2SV_blank>start\" ) ; else if ( startcode == 0x1B4 ) av_log ( s -> avctx , AV_LOG_DEBUG , \"Video<S2SV_blank>Session<S2SV_blank>Error\" ) ; else if ( startcode == 0x1B5 ) av_log ( s -> avctx , AV_LOG_DEBUG , \"Visual<S2SV_blank>Object<S2SV_blank>Start\" ) ; else if ( startcode == 0x1B6 ) av_log ( s -> avctx , AV_LOG_DEBUG , \"Video<S2SV_blank>Object<S2SV_blank>Plane<S2SV_blank>start\" ) ; else if ( startcode == 0x1B7 ) av_log ( s -> avctx , AV_LOG_DEBUG , \"slice<S2SV_blank>start\" ) ; else if ( startcode == 0x1B8 ) av_log ( s -> avctx , AV_LOG_DEBUG , \"extension<S2SV_blank>start\" ) ; else if ( startcode == 0x1B9 ) av_log ( s -> avctx , AV_LOG_DEBUG , \"fgs<S2SV_blank>start\" ) ; else if ( startcode == 0x1BA ) av_log ( s -> avctx , AV_LOG_DEBUG , \"FBA<S2SV_blank>Object<S2SV_blank>start\" ) ; else if ( startcode == 0x1BB ) av_log ( s -> avctx , AV_LOG_DEBUG , \"FBA<S2SV_blank>Object<S2SV_blank>Plane<S2SV_blank>start\" ) ; else if ( startcode == 0x1BC ) av_log ( s -> avctx , AV_LOG_DEBUG , \"Mesh<S2SV_blank>Object<S2SV_blank>start\" ) ; else if ( startcode == 0x1BD ) av_log ( s -> avctx , AV_LOG_DEBUG , \"Mesh<S2SV_blank>Object<S2SV_blank>Plane<S2SV_blank>start\" ) ; else if ( startcode == 0x1BE ) av_log ( s -> avctx , AV_LOG_DEBUG , \"Still<S2SV_blank>Texture<S2SV_blank>Object<S2SV_blank>start\" ) ; else if ( startcode == 0x1BF ) av_log ( s -> avctx , AV_LOG_DEBUG , \"Texture<S2SV_blank>Spatial<S2SV_blank>Layer<S2SV_blank>start\" ) ; else if ( startcode == 0x1C0 ) av_log ( s -> avctx , AV_LOG_DEBUG , \"Texture<S2SV_blank>SNR<S2SV_blank>Layer<S2SV_blank>start\" ) ; else if ( startcode == 0x1C1 ) av_log ( s -> avctx , AV_LOG_DEBUG , \"Texture<S2SV_blank>Tile<S2SV_blank>start\" ) ; else if ( startcode == 0x1C2 ) av_log ( s -> avctx , AV_LOG_DEBUG , \"Texture<S2SV_blank>Shape<S2SV_blank>Layer<S2SV_blank>start\" ) ; else if ( startcode == 0x1C3 ) av_log ( s -> avctx , AV_LOG_DEBUG , \"stuffing<S2SV_blank>start\" ) ; else if ( startcode <= 0x1C5 ) av_log ( s -> avctx , AV_LOG_DEBUG , \"reserved\" ) ; else if ( startcode <= 0x1FF ) av_log ( s -> avctx , AV_LOG_DEBUG , \"System<S2SV_blank>start\" ) ; av_log ( s -> avctx , AV_LOG_DEBUG , \"<S2SV_blank>at<S2SV_blank>%d\\\\n\" , get_bits_count ( gb ) ) ; } if ( startcode >= 0x120 && startcode <= 0x12F ) { if ( vol ) { av_log ( s -> avctx , AV_LOG_WARNING , \"Ignoring<S2SV_blank>multiple<S2SV_blank>VOL<S2SV_blank>headers\\\\n\" ) ; continue ; } vol ++ ; if ( ( ret = decode_vol_header ( ctx , gb ) ) < 0 ) return ret ; } else if ( startcode == USER_DATA_STARTCODE ) { decode_user_data ( ctx , gb ) ; } else if ( startcode == GOP_STARTCODE ) { mpeg4_decode_gop_header ( s , gb ) ; } else if ( startcode == VOS_STARTCODE ) { <S2SV_StartBug> mpeg4_decode_profile_level ( s , gb ) ; <S2SV_EndBug> if ( s -> avctx -> profile == FF_PROFILE_MPEG4_SIMPLE_STUDIO && <S2SV_StartBug> ( s -> avctx -> level > 0 && s -> avctx -> level < 9 ) ) { <S2SV_EndBug> s -> studio_profile = 1 ; next_start_code_studio ( gb ) ; extension_and_user_data ( s , gb , 0 ) ; <S2SV_StartBug> } <S2SV_EndBug> } else if ( startcode == VISUAL_OBJ_STARTCODE ) { if ( s -> studio_profile ) { if ( ( ret = decode_studiovisualobject ( ctx , gb ) ) < 0 ) return ret ; } else mpeg4_decode_visual_object ( s , gb ) ; } else if ( startcode == VOP_STARTCODE ) { break ; } align_get_bits ( gb ) ; startcode = 0xff ; } end : if ( s -> avctx -> flags & AV_CODEC_FLAG_LOW_DELAY ) s -> low_delay = 1 ; s -> avctx -> has_b_frames = ! s -> low_delay ; if ( s -> studio_profile ) { <S2SV_StartBug> if ( ! s -> avctx -> bits_per_raw_sample ) { <S2SV_EndBug> av_log ( s -> avctx , AV_LOG_ERROR , \"Missing<S2SV_blank>VOL<S2SV_blank>header\\\\n\" ) ; return AVERROR_INVALIDDATA ; } return decode_studio_vop_header ( ctx , gb ) ; } else return decode_vop_header ( ctx , gb ) ; }\n",
      "fixed_code": "<S2SV_ModStart> VOS_STARTCODE ) { int profile , level ; <S2SV_ModStart> s , gb , & profile , & level ) ; if ( <S2SV_ModEnd> profile == FF_PROFILE_MPEG4_SIMPLE_STUDIO <S2SV_ModStart> FF_PROFILE_MPEG4_SIMPLE_STUDIO && ( <S2SV_ModEnd> level > 0 <S2SV_ModStart> > 0 && <S2SV_ModEnd> level < 9 <S2SV_ModStart> ) ; } else if ( s -> studio_profile ) { avpriv_request_sample ( s -> avctx , \"Mixes<S2SV_blank>studio<S2SV_blank>and<S2SV_blank>non<S2SV_blank>studio<S2SV_blank>profile\\\\n\" ) ; return AVERROR_PATCHWELCOME ; } s -> avctx -> profile = profile ; s -> avctx -> level = level ; <S2SV_ModStart> studio_profile ) { av_assert0 ( s -> avctx -> profile == FF_PROFILE_MPEG4_SIMPLE_STUDIO ) ;\n",
      "source_code_length": 5860,
      "target_code_length": 686,
      "vulnerability_patterns": {
        "integer_overflow": 1,
        "null_pointer": 64,
        "total": 65
      },
      "total_patterns": 65,
      "original_address": "https://github.com/FFmpeg/FFmpeg/commit/2aa9047486dbff12d9e040f917e5f799ed2fd78b",
      "discovery_time": "2018-07-05T17:29Z",
      "project_commit_id": "FFmpeg@FFmpeg/2aa9047486dbff12d9e040f917e5f799ed2fd78b",
      "extraction_time": "2025-08-31T15:41:49.185511",
      "label": 1,
      "vulnerability_type": "null_pointer_dereference",
      "difficulty_level": "advanced",
      "risk_factors": [
        "system_crash",
        "denial_of_service",
        "memory_corruption",
        "critical_infrastructure"
      ],
      "attack_vectors": [
        "memory_manipulation",
        "null_pointer",
        "code_analysis",
        "reverse_engineering",
        "use_after_free",
        "fuzzing"
      ],
      "mitigation_strategies": [
        "null_pointer_checks",
        "fuzzing",
        "dynamic_analysis",
        "memory_management",
        "static_analysis",
        "use_after_free_prevention",
        "code_review",
        "secure_coding_practices"
      ],
      "code_differences": {
        "has_differences": true,
        "source_lines": 2,
        "target_lines": 2,
        "character_differences": 5174,
        "similarity_percentage": 15.88235294117647
      },
      "vulnerability_location": {
        "vulnerability_present": true,
        "fix_applied": true,
        "code_changed": true,
        "estimated_lines_changed": 0
      }
    },
    {
      "cve_id": "CVE-2015-8871",
      "cwe_id": "CWE-416",
      "cwe_name": "Use After Free",
      "project": "uclouvain",
      "severity": "critical",
      "weaponization_score": 8.0,
      "is_critical": true,
      "is_weaponizable": true,
      "is_high_priority_project": false,
      "vulnerable_code": "CWE-416 static OPJ_BOOL opj_j2k_write_mco ( opj_j2k_t * p_j2k , struct opj_stream_private * p_stream , struct opj_event_mgr * p_manager ) { OPJ_BYTE * l_current_data = 00 ; OPJ_UINT32 l_mco_size ; opj_tcp_t * l_tcp = 00 ; opj_simple_mcc_decorrelation_data_t * l_mcc_record ; OPJ_UINT32 i ; assert ( p_j2k != 00 ) ; assert ( p_manager != 00 ) ; assert ( p_stream != 00 ) ; l_tcp = & ( p_j2k -> m_cp . tcps [ p_j2k -> m_current_tile_number ] ) ; <S2SV_StartBug> l_current_data = p_j2k -> m_specific_param . m_encoder . m_header_tile_data ; <S2SV_EndBug> l_mco_size = 5 + l_tcp -> m_nb_mcc_records ; if ( l_mco_size > p_j2k -> m_specific_param . m_encoder . m_header_tile_data_size ) { OPJ_BYTE * new_header_tile_data = ( OPJ_BYTE * ) opj_realloc ( p_j2k -> m_specific_param . m_encoder . m_header_tile_data , l_mco_size ) ; if ( ! new_header_tile_data ) { opj_free ( p_j2k -> m_specific_param . m_encoder . m_header_tile_data ) ; p_j2k -> m_specific_param . m_encoder . m_header_tile_data = NULL ; p_j2k -> m_specific_param . m_encoder . m_header_tile_data_size = 0 ; opj_event_msg ( p_manager , EVT_ERROR , \"Not<S2SV_blank>enough<S2SV_blank>memory<S2SV_blank>to<S2SV_blank>write<S2SV_blank>MCO<S2SV_blank>marker\\\\n\" ) ; return OPJ_FALSE ; } p_j2k -> m_specific_param . m_encoder . m_header_tile_data = new_header_tile_data ; p_j2k -> m_specific_param . m_encoder . m_header_tile_data_size = l_mco_size ; } <S2SV_StartBug> opj_write_bytes ( l_current_data , J2K_MS_MCO , 2 ) ; <S2SV_EndBug> l_current_data += 2 ; opj_write_bytes ( l_current_data , l_mco_size - 2 , 2 ) ; l_current_data += 2 ; opj_write_bytes ( l_current_data , l_tcp -> m_nb_mcc_records , 1 ) ; ++ l_current_data ; l_mcc_record = l_tcp -> m_mcc_records ; for ( i = 0 ; i < l_tcp -> m_nb_mcc_records ; ++ i ) { opj_write_bytes ( l_current_data , l_mcc_record -> m_index , 1 ) ; ++ l_current_data ; ++ l_mcc_record ; } if ( opj_stream_write_data ( p_stream , p_j2k -> m_specific_param . m_encoder . m_header_tile_data , l_mco_size , p_manager ) != l_mco_size ) { return OPJ_FALSE ; } return OPJ_TRUE ; }\n",
      "fixed_code": "<S2SV_ModStart> ] ) ; <S2SV_ModEnd> l_mco_size = 5 <S2SV_ModStart> l_mco_size ; } l_current_data = p_j2k -> m_specific_param . m_encoder . m_header_tile_data ;\n",
      "source_code_length": 2067,
      "target_code_length": 160,
      "vulnerability_patterns": {
        "use_after_free": 3,
        "integer_overflow": 6,
        "null_pointer": 18,
        "total": 27
      },
      "total_patterns": 27,
      "original_address": "https://github.com/uclouvain/openjpeg/commit/940100c28ae28931722290794889cf84a92c5f6f",
      "discovery_time": "2016-09-21T14:25Z",
      "project_commit_id": "uclouvain@openjpeg/940100c28ae28931722290794889cf84a92c5f6f",
      "extraction_time": "2025-08-31T15:41:49.185588",
      "label": 1,
      "vulnerability_type": "use_after_free",
      "difficulty_level": "advanced",
      "risk_factors": [
        "system_crash",
        "denial_of_service",
        "memory_corruption",
        "use_after_free"
      ],
      "attack_vectors": [
        "memory_manipulation",
        "null_pointer",
        "code_analysis",
        "reverse_engineering",
        "use_after_free",
        "fuzzing"
      ],
      "mitigation_strategies": [
        "null_pointer_checks",
        "fuzzing",
        "dynamic_analysis",
        "memory_management",
        "static_analysis",
        "use_after_free_prevention",
        "code_review",
        "secure_coding_practices"
      ],
      "code_differences": {
        "has_differences": true,
        "source_lines": 2,
        "target_lines": 2,
        "character_differences": 1907,
        "similarity_percentage": 18.421052631578945
      },
      "vulnerability_location": {
        "vulnerability_present": true,
        "fix_applied": true,
        "code_changed": true,
        "estimated_lines_changed": 0
      }
    },
    {
      "cve_id": "CVE-2019-5827",
      "cwe_id": "CWE-190",
      "cwe_name": "Integer Overflow",
      "project": "chromium",
      "severity": "critical",
      "weaponization_score": 8.0,
      "is_critical": true,
      "is_weaponizable": true,
      "is_high_priority_project": false,
      "vulnerable_code": "CWE-190 static int vdbePmaReadBlob ( PmaReader * p , int nByte , u8 * * ppOut ) { int iBuf ; int nAvail ; if ( p -> aMap ) { * ppOut = & p -> aMap [ p -> iReadOff ] ; p -> iReadOff += nByte ; return SQLITE_OK ; } assert ( p -> aBuffer ) ; iBuf = p -> iReadOff % p -> nBuffer ; if ( iBuf == 0 ) { int nRead ; int rc ; if ( ( p -> iEof - p -> iReadOff ) > ( i64 ) p -> nBuffer ) { nRead = p -> nBuffer ; } else { nRead = ( int ) ( p -> iEof - p -> iReadOff ) ; } assert ( nRead > 0 ) ; rc = sqlite3OsRead ( p -> pFd , p -> aBuffer , nRead , p -> iReadOff ) ; assert ( rc != SQLITE_IOERR_SHORT_READ ) ; if ( rc != SQLITE_OK ) return rc ; } nAvail = p -> nBuffer - iBuf ; if ( nByte <= nAvail ) { * ppOut = & p -> aBuffer [ iBuf ] ; p -> iReadOff += nByte ; } else { int nRem ; if ( p -> nAlloc < nByte ) { u8 * aNew ; <S2SV_StartBug> int nNew = MAX ( 128 , p -> nAlloc * 2 ) ; <S2SV_EndBug> while ( nByte > nNew ) nNew = nNew * 2 ; aNew = sqlite3Realloc ( p -> aAlloc , nNew ) ; if ( ! aNew ) return SQLITE_NOMEM_BKPT ; p -> nAlloc = nNew ; p -> aAlloc = aNew ; } memcpy ( p -> aAlloc , & p -> aBuffer [ iBuf ] , nAvail ) ; p -> iReadOff += nAvail ; nRem = nByte - nAvail ; while ( nRem > 0 ) { int rc ; int nCopy ; u8 * aNext ; nCopy = nRem ; if ( nRem > p -> nBuffer ) nCopy = p -> nBuffer ; rc = vdbePmaReadBlob ( p , nCopy , & aNext ) ; if ( rc != SQLITE_OK ) return rc ; assert ( aNext != p -> aAlloc ) ; memcpy ( & p -> aAlloc [ nByte - nRem ] , aNext , nCopy ) ; nRem -= nCopy ; } * ppOut = p -> aAlloc ; } return SQLITE_OK ; }\n",
      "fixed_code": "<S2SV_ModStart> * aNew ; sqlite3_int64 <S2SV_ModEnd> nNew = MAX <S2SV_ModStart> ( 128 , 2 * ( sqlite3_int64 ) <S2SV_ModStart> p -> nAlloc <S2SV_ModEnd> ) ; while\n",
      "source_code_length": 1532,
      "target_code_length": 162,
      "vulnerability_patterns": {
        "buffer_overflow": 2,
        "integer_overflow": 4,
        "null_pointer": 34,
        "total": 40
      },
      "total_patterns": 40,
      "original_address": "https://github.com/chromium/chromium/commit/517ac71c9ee27f856f9becde8abea7d1604af9d4",
      "discovery_time": "2019-06-27T17:15Z",
      "project_commit_id": "chromium@chromium/517ac71c9ee27f856f9becde8abea7d1604af9d4",
      "extraction_time": "2025-08-31T15:41:49.185615",
      "label": 1,
      "vulnerability_type": "integer_overflow",
      "difficulty_level": "advanced",
      "risk_factors": [
        "information_disclosure",
        "memory_corruption",
        "integer_overflow",
        "buffer_overflow"
      ],
      "attack_vectors": [
        "fuzzing",
        "code_analysis",
        "reverse_engineering"
      ],
      "mitigation_strategies": [
        "dynamic_analysis",
        "static_analysis",
        "fuzzing",
        "code_review",
        "secure_coding_practices"
      ],
      "code_differences": {
        "has_differences": true,
        "source_lines": 2,
        "target_lines": 2,
        "character_differences": 1370,
        "similarity_percentage": 21.73913043478261
      },
      "vulnerability_location": {
        "vulnerability_present": true,
        "fix_applied": true,
        "code_changed": true,
        "estimated_lines_changed": 0
      }
    },
    {
      "cve_id": "CVE-2016-10145",
      "cwe_id": "CWE-189",
      "cwe_name": "Unknown",
      "project": "ImageMagick",
      "severity": "critical",
      "weaponization_score": 8.0,
      "is_critical": true,
      "is_weaponizable": true,
      "is_high_priority_project": true,
      "vulnerable_code": "CWE-189 static Image * ExtractPostscript ( Image * image , const ImageInfo * image_info , MagickOffsetType PS_Offset , ssize_t PS_Size , ExceptionInfo * exception ) { char postscript_file [ MaxTextExtent ] ; const MagicInfo * magic_info ; FILE * ps_file ; ImageInfo * clone_info ; Image * image2 ; unsigned char magick [ 2 * MaxTextExtent ] ; if ( ( clone_info = CloneImageInfo ( image_info ) ) == NULL ) return ( image ) ; clone_info -> blob = ( void * ) NULL ; clone_info -> length = 0 ; ( void ) AcquireUniqueFilename ( postscript_file ) ; ps_file = fopen_utf8 ( postscript_file , \"wb\" ) ; if ( ps_file == ( FILE * ) NULL ) goto FINISH ; ( void ) SeekBlob ( image , PS_Offset , SEEK_SET ) ; ( void ) ReadBlob ( image , 2 * MaxTextExtent , magick ) ; ( void ) SeekBlob ( image , PS_Offset , SEEK_SET ) ; while ( PS_Size -- > 0 ) { ( void ) fputc ( ReadBlobByte ( image ) , ps_file ) ; } ( void ) fclose ( ps_file ) ; magic_info = GetMagicInfo ( magick , 2 * MaxTextExtent , exception ) ; if ( magic_info == ( const MagicInfo * ) NULL ) goto FINISH_UNL ; if ( exception -> severity != UndefinedException ) goto FINISH_UNL ; if ( magic_info -> name == ( char * ) NULL ) goto FINISH_UNL ; <S2SV_StartBug> ( void ) strncpy ( clone_info -> magick , magic_info -> name , MaxTextExtent ) ; <S2SV_EndBug> FormatLocaleString ( clone_info -> filename , MaxTextExtent , \"%s\" , postscript_file ) ; image2 = ReadImage ( clone_info , exception ) ; if ( ! image2 ) goto FINISH_UNL ; ( void ) CopyMagickString ( image2 -> filename , image -> filename , MaxTextExtent ) ; ( void ) CopyMagickString ( image2 -> magick_filename , image -> magick_filename , MaxTextExtent ) ; ( void ) CopyMagickString ( image2 -> magick , image -> magick , MaxTextExtent ) ; image2 -> depth = image -> depth ; DestroyBlob ( image2 ) ; image2 -> blob = ReferenceBlob ( image -> blob ) ; if ( ( image -> rows == 0 ) || ( image -> columns == 0 ) ) DeleteImageFromList ( & image ) ; AppendImageToList ( & image , image2 ) ; FINISH_UNL : ( void ) RelinquishUniqueFileResource ( postscript_file ) ; FINISH : DestroyImageInfo ( clone_info ) ; return ( image ) ; }\n",
      "fixed_code": "<S2SV_ModStart> name , MaxTextExtent - 1\n",
      "source_code_length": 2123,
      "target_code_length": 41,
      "vulnerability_patterns": {
        "buffer_overflow": 1,
        "use_after_free": 1,
        "integer_overflow": 1,
        "null_pointer": 21,
        "total": 24
      },
      "total_patterns": 24,
      "original_address": "https://github.com/ImageMagick/ImageMagick/commit/d23beebe7b1179fb75db1e85fbca3100e49593d9",
      "discovery_time": "2017-03-24T15:59Z",
      "project_commit_id": "ImageMagick@ImageMagick/d23beebe7b1179fb75db1e85fbca3100e49593d9",
      "extraction_time": "2025-08-31T15:41:49.185644",
      "label": 1,
      "vulnerability_type": "unknown",
      "difficulty_level": "advanced",
      "risk_factors": [
        "critical_infrastructure",
        "buffer_overflow",
        "use_after_free"
      ],
      "attack_vectors": [
        "fuzzing",
        "code_analysis",
        "reverse_engineering"
      ],
      "mitigation_strategies": [
        "dynamic_analysis",
        "static_analysis",
        "fuzzing",
        "code_review",
        "secure_coding_practices"
      ],
      "code_differences": {
        "has_differences": true,
        "source_lines": 2,
        "target_lines": 2,
        "character_differences": 2082,
        "similarity_percentage": 3.296703296703297
      },
      "vulnerability_location": {
        "vulnerability_present": true,
        "fix_applied": true,
        "code_changed": true,
        "estimated_lines_changed": 0
      }
    },
    {
      "cve_id": "CVE-2016-3183",
      "cwe_id": "CWE-125",
      "cwe_name": "Out-of-bounds Read",
      "project": "uclouvain",
      "severity": "critical",
      "weaponization_score": 8.0,
      "is_critical": true,
      "is_weaponizable": true,
      "is_high_priority_project": false,
      "vulnerable_code": "CWE-125 static void sycc422_to_rgb ( opj_image_t * img ) { int * d0 , * d1 , * d2 , * r , * g , * b ; const int * y , * cb , * cr ; <S2SV_StartBug> unsigned int maxw , maxh , max ; <S2SV_EndBug> int offset , upb ; <S2SV_StartBug> unsigned int i , j ; <S2SV_EndBug> upb = ( int ) img -> comps [ 0 ] . prec ; offset = 1 << ( upb - 1 ) ; upb = ( 1 << upb ) - 1 ; <S2SV_StartBug> maxw = ( unsigned int ) img -> comps [ 0 ] . w ; maxh = ( unsigned int ) img -> comps [ 0 ] . h ; <S2SV_EndBug> max = maxw * maxh ; y = img -> comps [ 0 ] . data ; cb = img -> comps [ 1 ] . data ; cr = img -> comps [ 2 ] . data ; <S2SV_StartBug> d0 = r = ( int * ) malloc ( sizeof ( int ) * ( size_t ) max ) ; <S2SV_EndBug> <S2SV_StartBug> d1 = g = ( int * ) malloc ( sizeof ( int ) * ( size_t ) max ) ; <S2SV_EndBug> <S2SV_StartBug> d2 = b = ( int * ) malloc ( sizeof ( int ) * ( size_t ) max ) ; <S2SV_EndBug> if ( r == NULL || g == NULL || b == NULL ) goto fails ; <S2SV_StartBug> for ( i = 0U ; i < maxh ; ++ i ) <S2SV_EndBug> { <S2SV_StartBug> for ( j = 0U ; j < ( maxw & ~ ( unsigned int ) 1U ) ; j += 2U ) <S2SV_EndBug> { sycc_to_rgb ( offset , upb , * y , * cb , * cr , r , g , b ) ; ++ y ; ++ r ; ++ g ; ++ b ; sycc_to_rgb ( offset , upb , * y , * cb , * cr , r , g , b ) ; ++ y ; ++ r ; ++ g ; ++ b ; ++ cb ; ++ cr ; } <S2SV_StartBug> if ( j < maxw ) { <S2SV_EndBug> sycc_to_rgb ( offset , upb , * y , * cb , * cr , r , g , b ) ; ++ y ; ++ r ; ++ g ; ++ b ; ++ cb ; ++ cr ; } } free ( img -> comps [ 0 ] . data ) ; img -> comps [ 0 ] . data = d0 ; free ( img -> comps [ 1 ] . data ) ; img -> comps [ 1 ] . data = d1 ; free ( img -> comps [ 2 ] . data ) ; img -> comps [ 2 ] . data = d2 ; <S2SV_StartBug> # if defined ( USE_JPWL ) || defined ( USE_MJ2 ) <S2SV_EndBug> <S2SV_StartBug> img -> comps [ 1 ] . w = maxw ; img -> comps [ 1 ] . h = maxh ; <S2SV_EndBug> <S2SV_StartBug> img -> comps [ 2 ] . w = maxw ; img -> comps [ 2 ] . h = maxh ; <S2SV_EndBug> # else img -> comps [ 1 ] . w = ( OPJ_UINT32 ) maxw ; img -> comps [ 1 ] . h = ( OPJ_UINT32 ) maxh ; <S2SV_StartBug> img -> comps [ 2 ] . w = ( OPJ_UINT32 ) maxw ; img -> comps [ 2 ] . h = ( OPJ_UINT32 ) maxh ; <S2SV_EndBug> # endif img -> comps [ 1 ] . dx = img -> comps [ 0 ] . dx ; img -> comps [ 2 ] . dx = img -> comps [ 0 ] . dx ; img -> comps [ 1 ] . dy = img -> comps [ 0 ] . dy ; <S2SV_StartBug> img -> comps [ 2 ] . dy = img -> comps [ 0 ] . dy ; <S2SV_EndBug> return ; fails : <S2SV_StartBug> if ( r ) free ( r ) ; <S2SV_EndBug> <S2SV_StartBug> if ( g ) free ( g ) ; <S2SV_EndBug> <S2SV_StartBug> if ( b ) free ( b ) ; <S2SV_EndBug> }\n",
      "fixed_code": "<S2SV_ModStart> * cr ; size_t <S2SV_ModEnd> maxw , maxh <S2SV_ModStart> maxh , max , offx , loopmaxw <S2SV_ModStart> , upb ; size_t i <S2SV_ModEnd> ; upb = <S2SV_ModStart> maxw = ( size_t <S2SV_ModEnd> ) img -> <S2SV_ModStart> maxh = ( size_t <S2SV_ModEnd> ) img -> <S2SV_ModStart> int ) * <S2SV_ModEnd> max ) ; <S2SV_ModStart> int ) * <S2SV_ModEnd> max ) ; <S2SV_ModStart> int ) * <S2SV_ModEnd> max ) ; <S2SV_ModStart> goto fails ; offx = img -> x0 & 1U ; loopmaxw = maxw - offx ; <S2SV_ModStart> i ) { size_t j ; if ( offx > 0U ) { sycc_to_rgb ( offset , upb , * y , 0 , 0 , r , g , b ) ; ++ y ; ++ r ; ++ g ; ++ b ; } <S2SV_ModStart> j < ( loopmaxw <S2SV_ModEnd> & ~ ( <S2SV_ModStart> & ~ ( size_t <S2SV_ModEnd> ) 1U ) <S2SV_ModStart> ( j < loopmaxw <S2SV_ModEnd> ) { sycc_to_rgb <S2SV_ModStart> = d2 ; <S2SV_ModEnd> img -> comps <S2SV_ModStart> . w = img -> comps [ 2 ] . w = img -> comps [ 0 ] . w ; <S2SV_ModEnd> img -> comps <S2SV_ModStart> . h = <S2SV_ModEnd> img -> comps <S2SV_ModStart> 2 ] . h = img -> comps [ 0 ] . h ; img -> comps [ 1 ] . dx = <S2SV_ModEnd> img -> comps <S2SV_ModStart> 2 ] . dx = img -> comps [ 0 ] . dx ; img -> comps [ 1 ] . dy = <S2SV_ModEnd> img -> comps <S2SV_ModStart> 2 ] . <S2SV_ModEnd> dy = img <S2SV_ModStart> ; img -> color_space = OPJ_CLRSPC_SRGB <S2SV_ModEnd> ; return ; <S2SV_ModStart> ; fails : <S2SV_ModEnd> free ( r <S2SV_ModStart> r ) ; <S2SV_ModEnd> free ( g <S2SV_ModStart> g ) ; <S2SV_ModEnd> free ( b\n",
      "source_code_length": 2587,
      "target_code_length": 1455,
      "vulnerability_patterns": {
        "use_after_free": 9,
        "integer_overflow": 18,
        "null_pointer": 28,
        "memory_leak": 3,
        "total": 58
      },
      "total_patterns": 58,
      "original_address": "https://github.com/uclouvain/openjpeg/commit/15f081c89650dccee4aa4ae66f614c3fdb268767",
      "discovery_time": "2017-02-03T16:59Z",
      "project_commit_id": "uclouvain@openjpeg/15f081c89650dccee4aa4ae66f614c3fdb268767",
      "extraction_time": "2025-08-31T15:41:49.185676",
      "label": 1,
      "vulnerability_type": "out-of-bounds_read",
      "difficulty_level": "advanced",
      "risk_factors": [
        "information_disclosure",
        "memory_corruption",
        "integer_overflow",
        "use_after_free"
      ],
      "attack_vectors": [
        "memory_manipulation",
        "malicious_input",
        "code_analysis",
        "buffer_overflow",
        "reverse_engineering",
        "fuzzing"
      ],
      "mitigation_strategies": [
        "safe_string_functions",
        "dynamic_analysis",
        "code_review",
        "static_analysis",
        "memory_safety_checks",
        "input_validation",
        "fuzzing",
        "bounds_checking",
        "secure_coding_practices"
      ],
      "code_differences": {
        "has_differences": true,
        "source_lines": 2,
        "target_lines": 2,
        "character_differences": 1132,
        "similarity_percentage": 56.81818181818182
      },
      "vulnerability_location": {
        "vulnerability_present": true,
        "fix_applied": true,
        "code_changed": true,
        "estimated_lines_changed": 0
      }
    },
    {
      "cve_id": "CVE-2016-9262",
      "cwe_id": "CWE-190",
      "cwe_name": "Integer Overflow",
      "project": "mdadams",
      "severity": "critical",
      "weaponization_score": 8.0,
      "is_critical": true,
      "is_weaponizable": true,
      "is_high_priority_project": false,
      "vulnerable_code": "CWE-190 static long mem_seek ( jas_stream_obj_t * obj , long offset , int origin ) { jas_stream_memobj_t * m = ( jas_stream_memobj_t * ) obj ; <S2SV_StartBug> long newpos ; <S2SV_EndBug> JAS_DBGLOG ( 100 , ( \"mem_seek(%p,<S2SV_blank>%ld,<S2SV_blank>%d)\\\\n\" , obj , offset , origin ) ) ; switch ( origin ) { case SEEK_SET : newpos = offset ; break ; case SEEK_END : newpos = m -> len_ - offset ; break ; case SEEK_CUR : newpos = m -> pos_ + offset ; break ; default : abort ( ) ; break ; } if ( newpos < 0 ) { return - 1 ; } m -> pos_ = newpos ; return m -> pos_ ; }\n",
      "fixed_code": "<S2SV_ModStart> ) obj ; size_t <S2SV_ModEnd> newpos ; JAS_DBGLOG\n",
      "source_code_length": 566,
      "target_code_length": 65,
      "vulnerability_patterns": {
        "use_after_free": 6,
        "null_pointer": 4,
        "total": 10
      },
      "total_patterns": 10,
      "original_address": "https://github.com/mdadams/jasper/commit/634ce8e8a5accc0fa05dd2c20d42b4749d4b2735",
      "discovery_time": "2017-03-23T18:59Z",
      "project_commit_id": "mdadams@jasper/634ce8e8a5accc0fa05dd2c20d42b4749d4b2735",
      "extraction_time": "2025-08-31T15:41:49.185732",
      "label": 1,
      "vulnerability_type": "integer_overflow",
      "difficulty_level": "advanced",
      "risk_factors": [
        "information_disclosure",
        "memory_corruption",
        "integer_overflow",
        "use_after_free"
      ],
      "attack_vectors": [
        "fuzzing",
        "code_analysis",
        "reverse_engineering"
      ],
      "mitigation_strategies": [
        "dynamic_analysis",
        "static_analysis",
        "fuzzing",
        "code_review",
        "secure_coding_practices"
      ],
      "code_differences": {
        "has_differences": true,
        "source_lines": 2,
        "target_lines": 2,
        "character_differences": 501,
        "similarity_percentage": 10.638297872340425
      },
      "vulnerability_location": {
        "vulnerability_present": true,
        "fix_applied": true,
        "code_changed": true,
        "estimated_lines_changed": 0
      }
    },
    {
      "cve_id": "CVE-2019-15919",
      "cwe_id": "CWE-416",
      "cwe_name": "Use After Free",
      "project": "torvalds",
      "severity": "critical",
      "weaponization_score": 8.0,
      "is_critical": true,
      "is_weaponizable": true,
      "is_high_priority_project": false,
      "vulnerable_code": "CWE-416 int SMB2_write ( const unsigned int xid , struct cifs_io_parms * io_parms , unsigned int * nbytes , struct kvec * iov , int n_vec ) { struct smb_rqst rqst ; int rc = 0 ; struct smb2_write_req * req = NULL ; struct smb2_write_rsp * rsp = NULL ; int resp_buftype ; struct kvec rsp_iov ; int flags = 0 ; unsigned int total_len ; * nbytes = 0 ; if ( n_vec < 1 ) return rc ; rc = smb2_plain_req_init ( SMB2_WRITE , io_parms -> tcon , ( void * * ) & req , & total_len ) ; if ( rc ) return rc ; if ( io_parms -> tcon -> ses -> server == NULL ) return - ECONNABORTED ; if ( smb3_encryption_required ( io_parms -> tcon ) ) flags |= CIFS_TRANSFORM_REQ ; req -> sync_hdr . ProcessId = cpu_to_le32 ( io_parms -> pid ) ; req -> PersistentFileId = io_parms -> persistent_fid ; req -> VolatileFileId = io_parms -> volatile_fid ; req -> WriteChannelInfoOffset = 0 ; req -> WriteChannelInfoLength = 0 ; req -> Channel = 0 ; req -> Length = cpu_to_le32 ( io_parms -> length ) ; req -> Offset = cpu_to_le64 ( io_parms -> offset ) ; req -> DataOffset = cpu_to_le16 ( offsetof ( struct smb2_write_req , Buffer ) ) ; req -> RemainingBytes = 0 ; trace_smb3_write_enter ( xid , io_parms -> persistent_fid , io_parms -> tcon -> tid , io_parms -> tcon -> ses -> Suid , io_parms -> offset , io_parms -> length ) ; iov [ 0 ] . iov_base = ( char * ) req ; iov [ 0 ] . iov_len = total_len - 1 ; memset ( & rqst , 0 , sizeof ( struct smb_rqst ) ) ; rqst . rq_iov = iov ; rqst . rq_nvec = n_vec + 1 ; rc = cifs_send_recv ( xid , io_parms -> tcon -> ses , & rqst , & resp_buftype , flags , & rsp_iov ) ; <S2SV_StartBug> cifs_small_buf_release ( req ) ; <S2SV_EndBug> rsp = ( struct smb2_write_rsp * ) rsp_iov . iov_base ; if ( rc ) { trace_smb3_write_err ( xid , req -> PersistentFileId , io_parms -> tcon -> tid , io_parms -> tcon -> ses -> Suid , io_parms -> offset , io_parms -> length , rc ) ; cifs_stats_fail_inc ( io_parms -> tcon , SMB2_WRITE_HE ) ; cifs_dbg ( VFS , \"Send<S2SV_blank>error<S2SV_blank>in<S2SV_blank>write<S2SV_blank>=<S2SV_blank>%d\\\\n\" , rc ) ; } else { * nbytes = le32_to_cpu ( rsp -> DataLength ) ; trace_smb3_write_done ( xid , req -> PersistentFileId , io_parms -> tcon -> tid , io_parms -> tcon -> ses -> Suid , io_parms -> offset , * nbytes ) ; } <S2SV_StartBug> free_rsp_buf ( resp_buftype , rsp ) ; <S2SV_EndBug> return rc ; }\n",
      "fixed_code": "<S2SV_ModStart> rsp_iov ) ; <S2SV_ModEnd> rsp = ( <S2SV_ModStart> ) ; } cifs_small_buf_release ( req ) ;\n",
      "source_code_length": 2333,
      "target_code_length": 105,
      "vulnerability_patterns": {
        "buffer_overflow": 1,
        "null_pointer": 47,
        "total": 48
      },
      "total_patterns": 48,
      "original_address": "https://github.com/torvalds/linux/commit/6a3eb3360667170988f8a6477f6686242061488a",
      "discovery_time": "2019-09-04T19:15Z",
      "project_commit_id": "torvalds@linux/6a3eb3360667170988f8a6477f6686242061488a",
      "extraction_time": "2025-08-31T15:41:49.185743",
      "label": 1,
      "vulnerability_type": "use_after_free",
      "difficulty_level": "advanced",
      "risk_factors": [
        "system_crash",
        "denial_of_service",
        "memory_corruption",
        "buffer_overflow"
      ],
      "attack_vectors": [
        "memory_manipulation",
        "null_pointer",
        "code_analysis",
        "reverse_engineering",
        "use_after_free",
        "fuzzing"
      ],
      "mitigation_strategies": [
        "null_pointer_checks",
        "fuzzing",
        "dynamic_analysis",
        "memory_management",
        "static_analysis",
        "use_after_free_prevention",
        "code_review",
        "secure_coding_practices"
      ],
      "code_differences": {
        "has_differences": true,
        "source_lines": 2,
        "target_lines": 2,
        "character_differences": 2228,
        "similarity_percentage": 8.653846153846153
      },
      "vulnerability_location": {
        "vulnerability_present": true,
        "fix_applied": true,
        "code_changed": true,
        "estimated_lines_changed": 0
      }
    },
    {
      "cve_id": "CVE-2016-5354",
      "cwe_id": "CWE-476",
      "cwe_name": "NULL Pointer Dereference",
      "project": "wireshark",
      "severity": "critical",
      "weaponization_score": 8.0,
      "is_critical": true,
      "is_weaponizable": true,
      "is_high_priority_project": true,
      "vulnerable_code": "CWE-476 static gint dissect_ac_if_hdr_body ( tvbuff_t * tvb , gint offset , packet_info * pinfo _U_ , proto_tree * tree , usb_conv_info_t * usb_conv_info ) { gint offset_start ; guint16 bcdADC ; guint8 ver_major ; double ver ; guint8 if_in_collection , i ; audio_conv_info_t * audio_conv_info ; offset_start = offset ; bcdADC = tvb_get_letohs ( tvb , offset ) ; ver_major = USB_AUDIO_BCD44_TO_DEC ( bcdADC >> 8 ) ; ver = ver_major + USB_AUDIO_BCD44_TO_DEC ( bcdADC & 0xFF ) / 100.0 ; proto_tree_add_double_format_value ( tree , hf_ac_if_hdr_ver , tvb , offset , 2 , ver , \"%2.2f\" , ver ) ; audio_conv_info = ( audio_conv_info_t * ) usb_conv_info -> class_data ; if ( ! audio_conv_info ) { audio_conv_info = wmem_new ( wmem_file_scope ( ) , audio_conv_info_t ) ; usb_conv_info -> class_data = audio_conv_info ; <S2SV_StartBug> } <S2SV_EndBug> audio_conv_info -> ver_major = ver_major ; offset += 2 ; if ( ver_major == 1 ) { proto_tree_add_item ( tree , hf_ac_if_hdr_total_len , tvb , offset , 2 , ENC_LITTLE_ENDIAN ) ; offset += 2 ; if_in_collection = tvb_get_guint8 ( tvb , offset ) ; proto_tree_add_item ( tree , hf_ac_if_hdr_bInCollection , tvb , offset , 1 , ENC_LITTLE_ENDIAN ) ; offset ++ ; for ( i = 0 ; i < if_in_collection ; i ++ ) { proto_tree_add_item ( tree , hf_ac_if_hdr_if_num , tvb , offset , 1 , ENC_LITTLE_ENDIAN ) ; offset ++ ; } } return offset - offset_start ; }\n",
      "fixed_code": "<S2SV_ModStart> = audio_conv_info ; usb_conv_info -> class_data_type = USB_CONV_AUDIO ; } else if ( usb_conv_info -> class_data_type != USB_CONV_AUDIO ) { return 0 ;\n",
      "source_code_length": 1383,
      "target_code_length": 166,
      "vulnerability_patterns": {
        "integer_overflow": 5,
        "null_pointer": 5,
        "total": 10
      },
      "total_patterns": 10,
      "original_address": "https://github.com/wireshark/wireshark/commit/2cb5985bf47bdc8bea78d28483ed224abdd33dc6",
      "discovery_time": "2016-08-07T16:59Z",
      "project_commit_id": "wireshark@wireshark/2cb5985bf47bdc8bea78d28483ed224abdd33dc6",
      "extraction_time": "2025-08-31T15:41:49.185777",
      "label": 1,
      "vulnerability_type": "null_pointer_dereference",
      "difficulty_level": "advanced",
      "risk_factors": [
        "system_crash",
        "denial_of_service",
        "memory_corruption",
        "critical_infrastructure"
      ],
      "attack_vectors": [
        "memory_manipulation",
        "null_pointer",
        "code_analysis",
        "reverse_engineering",
        "use_after_free",
        "fuzzing"
      ],
      "mitigation_strategies": [
        "null_pointer_checks",
        "fuzzing",
        "dynamic_analysis",
        "memory_management",
        "static_analysis",
        "use_after_free_prevention",
        "code_review",
        "secure_coding_practices"
      ],
      "code_differences": {
        "has_differences": true,
        "source_lines": 2,
        "target_lines": 2,
        "character_differences": 1217,
        "similarity_percentage": 16.216216216216218
      },
      "vulnerability_location": {
        "vulnerability_present": true,
        "fix_applied": true,
        "code_changed": true,
        "estimated_lines_changed": 0
      }
    },
    {
      "cve_id": "CVE-2018-16425",
      "cwe_id": "CWE-415",
      "cwe_name": "Double Free",
      "project": "OpenSC",
      "severity": "critical",
      "weaponization_score": 8.0,
      "is_critical": true,
      "is_weaponizable": true,
      "is_high_priority_project": false,
      "vulnerable_code": "CWE-415 int sc_file_set_sec_attr ( sc_file_t * file , const u8 * sec_attr , size_t sec_attr_len ) { u8 * tmp ; if ( ! sc_file_valid ( file ) ) { return SC_ERROR_INVALID_ARGUMENTS ; } <S2SV_StartBug> if ( sec_attr == NULL ) { <S2SV_EndBug> if ( file -> sec_attr != NULL ) free ( file -> sec_attr ) ; file -> sec_attr = NULL ; file -> sec_attr_len = 0 ; return 0 ; } tmp = ( u8 * ) realloc ( file -> sec_attr , sec_attr_len ) ; if ( ! tmp ) { if ( file -> sec_attr ) free ( file -> sec_attr ) ; file -> sec_attr = NULL ; file -> sec_attr_len = 0 ; return SC_ERROR_OUT_OF_MEMORY ; } file -> sec_attr = tmp ; memcpy ( file -> sec_attr , sec_attr , sec_attr_len ) ; file -> sec_attr_len = sec_attr_len ; return 0 ; }\n",
      "fixed_code": "<S2SV_ModStart> sec_attr == NULL || sec_attr_len\n",
      "source_code_length": 712,
      "target_code_length": 49,
      "vulnerability_patterns": {
        "buffer_overflow": 15,
        "format_string": 5,
        "null_pointer": 13,
        "total": 33
      },
      "total_patterns": 33,
      "original_address": "https://github.com/OpenSC/OpenSC/commit/360e95d45ac4123255a4c796db96337f332160ad",
      "discovery_time": "2018-09-04T00:29Z",
      "project_commit_id": "OpenSC@OpenSC/360e95d45ac4123255a4c796db96337f332160ad",
      "extraction_time": "2025-08-31T15:41:49.185799",
      "label": 1,
      "vulnerability_type": "double_free",
      "difficulty_level": "advanced",
      "risk_factors": [
        "system_crash",
        "denial_of_service",
        "memory_corruption",
        "buffer_overflow"
      ],
      "attack_vectors": [
        "memory_manipulation",
        "null_pointer",
        "code_analysis",
        "reverse_engineering",
        "use_after_free",
        "fuzzing"
      ],
      "mitigation_strategies": [
        "null_pointer_checks",
        "fuzzing",
        "dynamic_analysis",
        "memory_management",
        "static_analysis",
        "use_after_free_prevention",
        "code_review",
        "secure_coding_practices"
      ],
      "code_differences": {
        "has_differences": true,
        "source_lines": 2,
        "target_lines": 2,
        "character_differences": 663,
        "similarity_percentage": 10.81081081081081
      },
      "vulnerability_location": {
        "vulnerability_present": true,
        "fix_applied": true,
        "code_changed": true,
        "estimated_lines_changed": 0
      }
    },
    {
      "cve_id": "CVE-2017-18120",
      "cwe_id": "CWE-415",
      "cwe_name": "Double Free",
      "project": "kohler",
      "severity": "critical",
      "weaponization_score": 8.0,
      "is_critical": true,
      "is_weaponizable": true,
      "is_high_priority_project": false,
      "vulnerable_code": "CWE-415 static Gif_Stream * read_gif ( Gif_Reader * grr , int read_flags , const char * landmark , Gif_ReadErrorHandler handler ) { Gif_Stream * gfs ; Gif_Image * gfi ; Gif_Context gfc ; int unknown_block_type = 0 ; if ( gifgetc ( grr ) != 'G' || gifgetc ( grr ) != 'I' || gifgetc ( grr ) != 'F' ) return 0 ; ( void ) gifgetc ( grr ) ; ( void ) gifgetc ( grr ) ; ( void ) gifgetc ( grr ) ; gfs = Gif_NewStream ( ) ; gfi = Gif_NewImage ( ) ; gfc . stream = gfs ; gfc . prefix = Gif_NewArray ( Gif_Code , GIF_MAX_CODE ) ; gfc . suffix = Gif_NewArray ( uint8_t , GIF_MAX_CODE ) ; gfc . length = Gif_NewArray ( uint16_t , GIF_MAX_CODE ) ; gfc . handler = handler ; gfc . gfi = gfi ; gfc . errors [ 0 ] = gfc . errors [ 1 ] = 0 ; if ( ! gfs || ! gfi || ! gfc . prefix || ! gfc . suffix || ! gfc . length ) goto done ; gfs -> landmark = landmark ; GIF_DEBUG ( ( \"\\\\nGIF<S2SV_blank>\" ) ) ; if ( ! read_logical_screen_descriptor ( gfs , grr ) ) goto done ; GIF_DEBUG ( ( \"logscrdesc<S2SV_blank>\" ) ) ; while ( ! gifeof ( grr ) ) { uint8_t block = gifgetbyte ( grr ) ; switch ( block ) { case ',' : GIF_DEBUG ( ( \"imageread<S2SV_blank>%d<S2SV_blank>\" , gfs -> nimages ) ) ; gfi -> identifier = last_name ; last_name = 0 ; if ( ! Gif_AddImage ( gfs , gfi ) ) goto done ; else if ( ! read_image ( grr , & gfc , gfi , read_flags ) ) { Gif_RemoveImage ( gfs , gfs -> nimages - 1 ) ; gfi = 0 ; goto done ; } gfc . gfi = gfi = Gif_NewImage ( ) ; if ( ! gfi ) goto done ; break ; case ';' : GIF_DEBUG ( ( \"term\\\\n\" ) ) ; goto done ; case '!' : block = gifgetbyte ( grr ) ; GIF_DEBUG ( ( \"ext(0x%02X)<S2SV_blank>\" , block ) ) ; switch ( block ) { case 0xF9 : read_graphic_control_extension ( & gfc , gfi , grr ) ; break ; case 0xCE : last_name = suck_data ( last_name , 0 , grr ) ; break ; case 0xFE : if ( ! read_comment_extension ( gfi , grr ) ) goto done ; break ; case 0xFF : read_application_extension ( & gfc , grr ) ; break ; default : read_unknown_extension ( & gfc , grr , block , 0 , 0 ) ; break ; } break ; default : if ( ! unknown_block_type ) { char buf [ 256 ] ; sprintf ( buf , \"unknown<S2SV_blank>block<S2SV_blank>type<S2SV_blank>%d<S2SV_blank>at<S2SV_blank>file<S2SV_blank>offset<S2SV_blank>%u\" , block , grr -> pos - 1 ) ; gif_read_error ( & gfc , 1 , buf ) ; unknown_block_type = 1 ; } break ; } } done : if ( gfs && gfi ) { Gif_Extension * gfex ; gfs -> end_comment = gfi -> comment ; gfi -> comment = 0 ; gfs -> end_extension_list = gfi -> extension_list ; gfi -> extension_list = 0 ; for ( gfex = gfs -> end_extension_list ; gfex ; gfex = gfex -> next ) gfex -> image = NULL ; } Gif_DeleteImage ( gfi ) ; Gif_DeleteArray ( last_name ) ; Gif_DeleteArray ( gfc . prefix ) ; Gif_DeleteArray ( gfc . suffix ) ; Gif_DeleteArray ( gfc . length ) ; gfc . gfi = 0 ; <S2SV_StartBug> if ( gfs ) <S2SV_EndBug> gfs -> errors = gfc . errors [ 1 ] ; if ( gfs && gfc . errors [ 1 ] == 0 && ! ( read_flags & GIF_READ_TRAILING_GARBAGE_OK ) && ! grr -> eofer ( grr ) ) gif_read_error ( & gfc , 0 , \"trailing<S2SV_blank>garbage<S2SV_blank>after<S2SV_blank>GIF<S2SV_blank>ignored\" ) ; gif_read_error ( & gfc , - 1 , 0 ) ; return gfs ; }\n",
      "fixed_code": "<S2SV_ModStart> = 0 ; last_name = 0 ;\n",
      "source_code_length": 3122,
      "target_code_length": 38,
      "vulnerability_patterns": {
        "buffer_overflow": 1,
        "format_string": 1,
        "null_pointer": 20,
        "total": 22
      },
      "total_patterns": 22,
      "original_address": "https://github.com/kohler/gifsicle/commit/118a46090c50829dc543179019e6140e1235f909",
      "discovery_time": "2018-02-02T09:29Z",
      "project_commit_id": "kohler@gifsicle/118a46090c50829dc543179019e6140e1235f909",
      "extraction_time": "2025-08-31T15:41:49.185812",
      "label": 1,
      "vulnerability_type": "double_free",
      "difficulty_level": "advanced",
      "risk_factors": [
        "system_crash",
        "denial_of_service",
        "memory_corruption",
        "buffer_overflow"
      ],
      "attack_vectors": [
        "memory_manipulation",
        "null_pointer",
        "code_analysis",
        "reverse_engineering",
        "use_after_free",
        "fuzzing"
      ],
      "mitigation_strategies": [
        "null_pointer_checks",
        "fuzzing",
        "dynamic_analysis",
        "memory_management",
        "static_analysis",
        "use_after_free_prevention",
        "code_review",
        "secure_coding_practices"
      ],
      "code_differences": {
        "has_differences": true,
        "source_lines": 2,
        "target_lines": 2,
        "character_differences": 3084,
        "similarity_percentage": 3.3333333333333335
      },
      "vulnerability_location": {
        "vulnerability_present": true,
        "fix_applied": true,
        "code_changed": true,
        "estimated_lines_changed": 0
      }
    },
    {
      "cve_id": "CVE-2016-5351",
      "cwe_id": "CWE-20",
      "cwe_name": "Improper Input Validation",
      "project": "wireshark",
      "severity": "critical",
      "weaponization_score": 8.0,
      "is_critical": true,
      "is_weaponizable": true,
      "is_high_priority_project": true,
      "vulnerable_code": "CWE-20 static INT AirPDcapScanForKeys ( PAIRPDCAP_CONTEXT ctx , const guint8 * data , const guint mac_header_len , const guint tot_len , AIRPDCAP_SEC_ASSOCIATION_ID id ) { const UCHAR * addr ; guint bodyLength ; PAIRPDCAP_SEC_ASSOCIATION sta_sa ; PAIRPDCAP_SEC_ASSOCIATION sa ; guint offset = 0 ; const guint8 dot1x_header [ ] = { 0xAA , 0xAA , 0x03 , 0x00 , 0x00 , 0x00 , 0x88 , 0x8E } ; const guint8 bt_dot1x_header [ ] = { 0xAA , 0xAA , 0x03 , 0x00 , 0x19 , 0x58 , 0x00 , 0x03 } ; const guint8 tdls_header [ ] = { 0xAA , 0xAA , 0x03 , 0x00 , 0x00 , 0x00 , 0x89 , 0x0D , 0x02 , 0X0C } ; const EAPOL_RSN_KEY * pEAPKey ; # ifdef _DEBUG # define MSGBUF_LEN 255 CHAR msgbuf [ MSGBUF_LEN ] ; # endif AIRPDCAP_DEBUG_TRACE_START ( \"AirPDcapScanForKeys\" ) ; offset = mac_header_len ; if ( memcmp ( data + offset , dot1x_header , 8 ) == 0 || memcmp ( data + offset , bt_dot1x_header , 8 ) == 0 ) { AIRPDCAP_DEBUG_PRINT_LINE ( \"AirPDcapScanForKeys\" , \"Authentication:<S2SV_blank>EAPOL<S2SV_blank>packet\" , AIRPDCAP_DEBUG_LEVEL_3 ) ; offset += 8 ; if ( data [ offset + 1 ] != 3 ) { AIRPDCAP_DEBUG_PRINT_LINE ( \"AirPDcapScanForKeys\" , \"Not<S2SV_blank>EAPOL-Key\" , AIRPDCAP_DEBUG_LEVEL_3 ) ; return AIRPDCAP_RET_NO_VALID_HANDSHAKE ; } bodyLength = pntoh16 ( data + offset + 2 ) ; <S2SV_StartBug> if ( ( tot_len - offset - 4 ) < bodyLength ) { <S2SV_EndBug> AIRPDCAP_DEBUG_PRINT_LINE ( \"AirPDcapScanForKeys\" , \"EAPOL<S2SV_blank>body<S2SV_blank>too<S2SV_blank>short\" , AIRPDCAP_DEBUG_LEVEL_3 ) ; return AIRPDCAP_RET_NO_VALID_HANDSHAKE ; } offset += 4 ; pEAPKey = ( const EAPOL_RSN_KEY * ) ( data + offset ) ; if ( pEAPKey -> type != AIRPDCAP_RSN_WPA2_KEY_DESCRIPTOR && pEAPKey -> type != AIRPDCAP_RSN_WPA_KEY_DESCRIPTOR ) { AIRPDCAP_DEBUG_PRINT_LINE ( \"AirPDcapScanForKeys\" , \"Not<S2SV_blank>valid<S2SV_blank>key<S2SV_blank>descriptor<S2SV_blank>type\" , AIRPDCAP_DEBUG_LEVEL_3 ) ; return AIRPDCAP_RET_NO_VALID_HANDSHAKE ; } offset += 1 ; sa = AirPDcapGetSaPtr ( ctx , & id ) ; if ( sa == NULL ) { AIRPDCAP_DEBUG_PRINT_LINE ( \"AirPDcapScanForKeys\" , \"No<S2SV_blank>SA<S2SV_blank>for<S2SV_blank>BSSID<S2SV_blank>found\" , AIRPDCAP_DEBUG_LEVEL_3 ) ; return AIRPDCAP_RET_REQ_DATA ; } if ( AirPDcapRsna4WHandshake ( ctx , data , sa , offset , tot_len ) == AIRPDCAP_RET_SUCCESS_HANDSHAKE ) return AIRPDCAP_RET_SUCCESS_HANDSHAKE ; if ( mac_header_len + GROUP_KEY_PAYLOAD_LEN_MIN > tot_len ) { AIRPDCAP_DEBUG_PRINT_LINE ( \"AirPDcapScanForKeys\" , \"Message<S2SV_blank>too<S2SV_blank>short<S2SV_blank>for<S2SV_blank>Group<S2SV_blank>Key\" , AIRPDCAP_DEBUG_LEVEL_3 ) ; return AIRPDCAP_RET_NO_VALID_HANDSHAKE ; } if ( AIRPDCAP_EAP_KEY ( data [ offset + 1 ] ) != 0 || AIRPDCAP_EAP_ACK ( data [ offset + 1 ] ) != 1 || AIRPDCAP_EAP_MIC ( data [ offset ] ) != 1 || AIRPDCAP_EAP_SEC ( data [ offset ] ) != 1 ) { AIRPDCAP_DEBUG_PRINT_LINE ( \"AirPDcapScanForKeys\" , \"Key<S2SV_blank>bitfields<S2SV_blank>not<S2SV_blank>correct<S2SV_blank>for<S2SV_blank>Group<S2SV_blank>Key\" , AIRPDCAP_DEBUG_LEVEL_3 ) ; return AIRPDCAP_RET_NO_VALID_HANDSHAKE ; } memcpy ( id . sta , broadcast_mac , AIRPDCAP_MAC_LEN ) ; sa = AirPDcapGetSaPtr ( ctx , & id ) ; if ( sa == NULL ) { return AIRPDCAP_RET_REQ_DATA ; } if ( ( addr = AirPDcapGetStaAddress ( ( const AIRPDCAP_MAC_FRAME_ADDR4 * ) ( data ) ) ) != NULL ) { memcpy ( id . sta , addr , AIRPDCAP_MAC_LEN ) ; # ifdef _DEBUG g_snprintf ( msgbuf , MSGBUF_LEN , \"ST_MAC:<S2SV_blank>%2X.%2X.%2X.%2X.%2X.%2X\\\\t\" , id . sta [ 0 ] , id . sta [ 1 ] , id . sta [ 2 ] , id . sta [ 3 ] , id . sta [ 4 ] , id . sta [ 5 ] ) ; # endif AIRPDCAP_DEBUG_PRINT_LINE ( \"AirPDcapScanForKeys\" , msgbuf , AIRPDCAP_DEBUG_LEVEL_3 ) ; } else { AIRPDCAP_DEBUG_PRINT_LINE ( \"AirPDcapScanForKeys\" , \"SA<S2SV_blank>not<S2SV_blank>found\" , AIRPDCAP_DEBUG_LEVEL_5 ) ; return AIRPDCAP_RET_REQ_DATA ; } sta_sa = AirPDcapGetSaPtr ( ctx , & id ) ; if ( sta_sa == NULL ) { return AIRPDCAP_RET_REQ_DATA ; } return ( AirPDcapDecryptWPABroadcastKey ( pEAPKey , sta_sa -> wpa . ptk + 16 , sa , tot_len - offset + 1 ) ) ; } else if ( memcmp ( data + offset , tdls_header , 10 ) == 0 ) { const guint8 * initiator , * responder ; guint8 action ; guint status , offset_rsne = 0 , offset_fte = 0 , offset_link = 0 , offset_timeout = 0 ; AIRPDCAP_DEBUG_PRINT_LINE ( \"AirPDcapScanForKeys\" , \"Authentication:<S2SV_blank>TDLS<S2SV_blank>Action<S2SV_blank>Frame\" , AIRPDCAP_DEBUG_LEVEL_3 ) ; offset += 10 ; action = data [ offset ] ; if ( action != 1 && action != 2 ) { AIRPDCAP_DEBUG_PRINT_LINE ( \"AirPDcapScanForKeys\" , \"Not<S2SV_blank>Response<S2SV_blank>nor<S2SV_blank>confirm\" , AIRPDCAP_DEBUG_LEVEL_3 ) ; return AIRPDCAP_RET_NO_VALID_HANDSHAKE ; } offset ++ ; status = pntoh16 ( data + offset ) ; if ( status != 0 ) { AIRPDCAP_DEBUG_PRINT_LINE ( \"AirPDcapScanForKeys\" , \"TDLS<S2SV_blank>setup<S2SV_blank>not<S2SV_blank>successfull\" , AIRPDCAP_DEBUG_LEVEL_3 ) ; return AIRPDCAP_RET_NO_VALID_HANDSHAKE ; } offset += 5 ; while ( offset < ( tot_len - 2 ) ) { if ( data [ offset ] == 48 ) { offset_rsne = offset ; } else if ( data [ offset ] == 55 ) { offset_fte = offset ; } else if ( data [ offset ] == 56 ) { offset_timeout = offset ; } else if ( data [ offset ] == 101 ) { offset_link = offset ; } if ( tot_len < offset + data [ offset + 1 ] + 2 ) { return AIRPDCAP_RET_NO_VALID_HANDSHAKE ; } offset += data [ offset + 1 ] + 2 ; } if ( offset_rsne == 0 || offset_fte == 0 || offset_timeout == 0 || offset_link == 0 ) { AIRPDCAP_DEBUG_PRINT_LINE ( \"AirPDcapScanForKeys\" , \"Cannot<S2SV_blank>Find<S2SV_blank>all<S2SV_blank>necessary<S2SV_blank>IEs\" , AIRPDCAP_DEBUG_LEVEL_3 ) ; return AIRPDCAP_RET_NO_VALID_HANDSHAKE ; } AIRPDCAP_DEBUG_PRINT_LINE ( \"AirPDcapScanForKeys\" , \"Found<S2SV_blank>RSNE/Fast<S2SV_blank>BSS/Timeout<S2SV_blank>Interval/Link<S2SV_blank>IEs\" , AIRPDCAP_DEBUG_LEVEL_3 ) ; initiator = & data [ offset_link + 8 ] ; responder = & data [ offset_link + 14 ] ; if ( memcmp ( initiator , responder , AIRPDCAP_MAC_LEN ) < 0 ) { memcpy ( id . sta , initiator , AIRPDCAP_MAC_LEN ) ; memcpy ( id . bssid , responder , AIRPDCAP_MAC_LEN ) ; } else { memcpy ( id . sta , responder , AIRPDCAP_MAC_LEN ) ; memcpy ( id . bssid , initiator , AIRPDCAP_MAC_LEN ) ; } sa = AirPDcapGetSaPtr ( ctx , & id ) ; if ( sa == NULL ) { return AIRPDCAP_RET_REQ_DATA ; } if ( sa -> validKey ) { if ( memcmp ( sa -> wpa . nonce , data + offset_fte + 52 , AIRPDCAP_WPA_NONCE_LEN ) == 0 ) { return AIRPDCAP_RET_SUCCESS_HANDSHAKE ; } else { AIRPDCAP_SEC_ASSOCIATION * tmp_sa = g_new ( AIRPDCAP_SEC_ASSOCIATION , 1 ) ; memcpy ( tmp_sa , sa , sizeof ( AIRPDCAP_SEC_ASSOCIATION ) ) ; sa -> next = tmp_sa ; sa -> validKey = FALSE ; } } if ( AirPDcapTDLSDeriveKey ( sa , data , offset_rsne , offset_fte , offset_timeout , offset_link , action ) == AIRPDCAP_RET_SUCCESS ) { AIRPDCAP_DEBUG_TRACE_END ( \"AirPDcapScanForKeys\" ) ; return AIRPDCAP_RET_SUCCESS_HANDSHAKE ; } } else { AIRPDCAP_DEBUG_PRINT_LINE ( \"AirPDcapScanForKeys\" , \"Skipping:<S2SV_blank>not<S2SV_blank>an<S2SV_blank>EAPOL<S2SV_blank>packet\" , AIRPDCAP_DEBUG_LEVEL_3 ) ; } AIRPDCAP_DEBUG_TRACE_END ( \"AirPDcapScanForKeys\" ) ; return AIRPDCAP_RET_NO_VALID_HANDSHAKE ; }\n",
      "fixed_code": "<S2SV_ModStart> if ( ( ( <S2SV_ModStart> ) < bodyLength ) || ( bodyLength < sizeof ( EAPOL_RSN_KEY ) )\n",
      "source_code_length": 7064,
      "target_code_length": 103,
      "vulnerability_patterns": {
        "buffer_overflow": 7,
        "integer_overflow": 7,
        "null_pointer": 11,
        "total": 25
      },
      "total_patterns": 25,
      "original_address": "https://github.com/wireshark/wireshark/commit/9b0b20b8d5f8c9f7839d58ff6c5900f7e19283b4",
      "discovery_time": "2016-08-07T16:59Z",
      "project_commit_id": "wireshark@wireshark/9b0b20b8d5f8c9f7839d58ff6c5900f7e19283b4",
      "extraction_time": "2025-08-31T15:41:49.185851",
      "label": 1,
      "vulnerability_type": "improper_input_validation",
      "difficulty_level": "advanced",
      "risk_factors": [
        "critical_infrastructure",
        "buffer_overflow"
      ],
      "attack_vectors": [
        "fuzzing",
        "code_analysis",
        "reverse_engineering"
      ],
      "mitigation_strategies": [
        "dynamic_analysis",
        "static_analysis",
        "fuzzing",
        "code_review",
        "secure_coding_practices"
      ],
      "code_differences": {
        "has_differences": true,
        "source_lines": 2,
        "target_lines": 2,
        "character_differences": 6961,
        "similarity_percentage": 5.063291139240507
      },
      "vulnerability_location": {
        "vulnerability_present": true,
        "fix_applied": true,
        "code_changed": true,
        "estimated_lines_changed": 0
      }
    },
    {
      "cve_id": "CVE-2019-5827",
      "cwe_id": "CWE-190",
      "cwe_name": "Integer Overflow",
      "project": "chromium",
      "severity": "critical",
      "weaponization_score": 8.0,
      "is_critical": true,
      "is_weaponizable": true,
      "is_high_priority_project": false,
      "vulnerable_code": "CWE-190 static int vdbePmaReadBlob ( PmaReader * p , int nByte , u8 * * ppOut ) { int iBuf ; int nAvail ; if ( p -> aMap ) { * ppOut = & p -> aMap [ p -> iReadOff ] ; p -> iReadOff += nByte ; return SQLITE_OK ; } assert ( p -> aBuffer ) ; iBuf = p -> iReadOff % p -> nBuffer ; if ( iBuf == 0 ) { int nRead ; int rc ; if ( ( p -> iEof - p -> iReadOff ) > ( i64 ) p -> nBuffer ) { nRead = p -> nBuffer ; } else { nRead = ( int ) ( p -> iEof - p -> iReadOff ) ; } assert ( nRead > 0 ) ; rc = sqlite3OsRead ( p -> pFd , p -> aBuffer , nRead , p -> iReadOff ) ; assert ( rc != SQLITE_IOERR_SHORT_READ ) ; if ( rc != SQLITE_OK ) return rc ; } nAvail = p -> nBuffer - iBuf ; if ( nByte <= nAvail ) { * ppOut = & p -> aBuffer [ iBuf ] ; p -> iReadOff += nByte ; } else { int nRem ; if ( p -> nAlloc < nByte ) { u8 * aNew ; <S2SV_StartBug> int nNew = MAX ( 128 , p -> nAlloc * 2 ) ; <S2SV_EndBug> while ( nByte > nNew ) nNew = nNew * 2 ; aNew = sqlite3Realloc ( p -> aAlloc , nNew ) ; if ( ! aNew ) return SQLITE_NOMEM_BKPT ; p -> nAlloc = nNew ; p -> aAlloc = aNew ; } memcpy ( p -> aAlloc , & p -> aBuffer [ iBuf ] , nAvail ) ; p -> iReadOff += nAvail ; nRem = nByte - nAvail ; while ( nRem > 0 ) { int rc ; int nCopy ; u8 * aNext ; nCopy = nRem ; if ( nRem > p -> nBuffer ) nCopy = p -> nBuffer ; rc = vdbePmaReadBlob ( p , nCopy , & aNext ) ; if ( rc != SQLITE_OK ) return rc ; assert ( aNext != p -> aAlloc ) ; memcpy ( & p -> aAlloc [ nByte - nRem ] , aNext , nCopy ) ; nRem -= nCopy ; } * ppOut = p -> aAlloc ; } return SQLITE_OK ; }\n",
      "fixed_code": "<S2SV_ModStart> * aNew ; sqlite3_int64 <S2SV_ModEnd> nNew = MAX <S2SV_ModStart> ( 128 , 2 * ( sqlite3_int64 ) <S2SV_ModStart> p -> nAlloc <S2SV_ModEnd> ) ; while\n",
      "source_code_length": 1532,
      "target_code_length": 162,
      "vulnerability_patterns": {
        "buffer_overflow": 1,
        "integer_overflow": 2,
        "null_pointer": 52,
        "total": 55
      },
      "total_patterns": 55,
      "original_address": "https://github.com/chromium/chromium/commit/517ac71c9ee27f856f9becde8abea7d1604af9d4",
      "discovery_time": "2019-06-27T17:15Z",
      "project_commit_id": "chromium@chromium/517ac71c9ee27f856f9becde8abea7d1604af9d4",
      "extraction_time": "2025-08-31T15:41:49.185904",
      "label": 1,
      "vulnerability_type": "integer_overflow",
      "difficulty_level": "advanced",
      "risk_factors": [
        "information_disclosure",
        "memory_corruption",
        "integer_overflow",
        "buffer_overflow"
      ],
      "attack_vectors": [
        "fuzzing",
        "code_analysis",
        "reverse_engineering"
      ],
      "mitigation_strategies": [
        "dynamic_analysis",
        "static_analysis",
        "fuzzing",
        "code_review",
        "secure_coding_practices"
      ],
      "code_differences": {
        "has_differences": true,
        "source_lines": 2,
        "target_lines": 2,
        "character_differences": 1370,
        "similarity_percentage": 21.73913043478261
      },
      "vulnerability_location": {
        "vulnerability_present": true,
        "fix_applied": true,
        "code_changed": true,
        "estimated_lines_changed": 0
      }
    },
    {
      "cve_id": "CVE-2011-3346",
      "cwe_id": "CWE-119",
      "cwe_name": "Buffer Overflow",
      "project": "bonzini",
      "severity": "critical",
      "weaponization_score": 8.0,
      "is_critical": true,
      "is_weaponizable": true,
      "is_high_priority_project": false,
      "vulnerable_code": "CWE-119 static void scsi_free_request ( SCSIRequest * req ) { SCSIDiskReq * r = DO_UPCAST ( SCSIDiskReq , req , req ) ; <S2SV_StartBug> qemu_vfree ( r -> iov . iov_base ) ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug>\n",
      "fixed_code": "<S2SV_ModStart> req ) ; if ( r -> iov . iov_base ) { <S2SV_ModStart> ) ; } }\n",
      "source_code_length": 219,
      "target_code_length": 77,
      "vulnerability_patterns": {
        "integer_overflow": 1,
        "format_string": 2,
        "null_pointer": 55,
        "sql_injection": 2,
        "total": 60
      },
      "total_patterns": 60,
      "original_address": "https://github.com/bonzini/qemu/commit/7285477ab11831b1cf56e45878a89170dd06d9b9",
      "discovery_time": "2014-04-01T06:35Z",
      "project_commit_id": "bonzini@qemu/7285477ab11831b1cf56e45878a89170dd06d9b9",
      "extraction_time": "2025-08-31T15:41:49.185927",
      "label": 1,
      "vulnerability_type": "buffer_overflow",
      "difficulty_level": "advanced",
      "risk_factors": [
        "system_crash",
        "memory_corruption",
        "sql_injection",
        "arbitrary_code_execution"
      ],
      "attack_vectors": [
        "memory_manipulation",
        "malicious_input",
        "code_analysis",
        "buffer_overflow",
        "reverse_engineering",
        "fuzzing"
      ],
      "mitigation_strategies": [
        "safe_string_functions",
        "dynamic_analysis",
        "code_review",
        "static_analysis",
        "memory_safety_checks",
        "input_validation",
        "fuzzing",
        "bounds_checking",
        "secure_coding_practices"
      ],
      "code_differences": {
        "has_differences": true,
        "source_lines": 2,
        "target_lines": 2,
        "character_differences": 142,
        "similarity_percentage": 42.30769230769231
      },
      "vulnerability_location": {
        "vulnerability_present": true,
        "fix_applied": true,
        "code_changed": true,
        "estimated_lines_changed": 0
      }
    },
    {
      "cve_id": "CVE-2019-15920",
      "cwe_id": "CWE-416",
      "cwe_name": "Use After Free",
      "project": "torvalds",
      "severity": "critical",
      "weaponization_score": 8.0,
      "is_critical": true,
      "is_weaponizable": true,
      "is_high_priority_project": false,
      "vulnerable_code": "CWE-416 int SMB2_read ( const unsigned int xid , struct cifs_io_parms * io_parms , unsigned int * nbytes , char * * buf , int * buf_type ) { struct smb_rqst rqst ; int resp_buftype , rc = - EACCES ; struct smb2_read_plain_req * req = NULL ; struct smb2_read_rsp * rsp = NULL ; struct kvec iov [ 1 ] ; struct kvec rsp_iov ; unsigned int total_len ; int flags = CIFS_LOG_ERROR ; struct cifs_ses * ses = io_parms -> tcon -> ses ; * nbytes = 0 ; rc = smb2_new_read_req ( ( void * * ) & req , & total_len , io_parms , NULL , 0 , 0 ) ; if ( rc ) return rc ; if ( smb3_encryption_required ( io_parms -> tcon ) ) flags |= CIFS_TRANSFORM_REQ ; iov [ 0 ] . iov_base = ( char * ) req ; iov [ 0 ] . iov_len = total_len ; memset ( & rqst , 0 , sizeof ( struct smb_rqst ) ) ; rqst . rq_iov = iov ; rqst . rq_nvec = 1 ; rc = cifs_send_recv ( xid , ses , & rqst , & resp_buftype , flags , & rsp_iov ) ; <S2SV_StartBug> cifs_small_buf_release ( req ) ; <S2SV_EndBug> rsp = ( struct smb2_read_rsp * ) rsp_iov . iov_base ; if ( rc ) { if ( rc != - ENODATA ) { cifs_stats_fail_inc ( io_parms -> tcon , SMB2_READ_HE ) ; cifs_dbg ( VFS , \"Send<S2SV_blank>error<S2SV_blank>in<S2SV_blank>read<S2SV_blank>=<S2SV_blank>%d\\\\n\" , rc ) ; trace_smb3_read_err ( xid , req -> PersistentFileId , io_parms -> tcon -> tid , ses -> Suid , io_parms -> offset , io_parms -> length , rc ) ; } else trace_smb3_read_done ( xid , req -> PersistentFileId , io_parms -> tcon -> tid , ses -> Suid , io_parms -> offset , 0 ) ; free_rsp_buf ( resp_buftype , rsp_iov . iov_base ) ; return rc == - ENODATA ? 0 : rc ; } else trace_smb3_read_done ( xid , req -> PersistentFileId , io_parms -> tcon -> tid , ses -> Suid , io_parms -> offset , io_parms -> length ) ; <S2SV_StartBug> * nbytes = le32_to_cpu ( rsp -> DataLength ) ; <S2SV_EndBug> if ( ( * nbytes > CIFS_MAX_MSGSIZE ) || ( * nbytes > io_parms -> length ) ) { cifs_dbg ( FYI , \"bad<S2SV_blank>length<S2SV_blank>%d<S2SV_blank>for<S2SV_blank>count<S2SV_blank>%d\\\\n\" , * nbytes , io_parms -> length ) ; rc = - EIO ; * nbytes = 0 ; } if ( * buf ) { memcpy ( * buf , ( char * ) rsp + rsp -> DataOffset , * nbytes ) ; free_rsp_buf ( resp_buftype , rsp_iov . iov_base ) ; } else if ( resp_buftype != CIFS_NO_BUFFER ) { * buf = rsp_iov . iov_base ; if ( resp_buftype == CIFS_SMALL_BUFFER ) * buf_type = CIFS_SMALL_BUFFER ; else if ( resp_buftype == CIFS_LARGE_BUFFER ) * buf_type = CIFS_LARGE_BUFFER ; } return rc ; }\n",
      "fixed_code": "<S2SV_ModStart> rsp_iov ) ; <S2SV_ModEnd> rsp = ( <S2SV_ModStart> length ) ; cifs_small_buf_release ( req ) ;\n",
      "source_code_length": 2419,
      "target_code_length": 110,
      "vulnerability_patterns": {
        "buffer_overflow": 2,
        "null_pointer": 25,
        "total": 27
      },
      "total_patterns": 27,
      "original_address": "https://github.com/torvalds/linux/commit/088aaf17aa79300cab14dbee2569c58cfafd7d6e",
      "discovery_time": "2019-09-04T19:15Z",
      "project_commit_id": "torvalds@linux/088aaf17aa79300cab14dbee2569c58cfafd7d6e",
      "extraction_time": "2025-08-31T15:41:49.185946",
      "label": 1,
      "vulnerability_type": "use_after_free",
      "difficulty_level": "advanced",
      "risk_factors": [
        "system_crash",
        "denial_of_service",
        "memory_corruption",
        "buffer_overflow"
      ],
      "attack_vectors": [
        "memory_manipulation",
        "null_pointer",
        "code_analysis",
        "reverse_engineering",
        "use_after_free",
        "fuzzing"
      ],
      "mitigation_strategies": [
        "null_pointer_checks",
        "fuzzing",
        "dynamic_analysis",
        "memory_management",
        "static_analysis",
        "use_after_free_prevention",
        "code_review",
        "secure_coding_practices"
      ],
      "code_differences": {
        "has_differences": true,
        "source_lines": 2,
        "target_lines": 2,
        "character_differences": 2309,
        "similarity_percentage": 9.0
      },
      "vulnerability_location": {
        "vulnerability_present": true,
        "fix_applied": true,
        "code_changed": true,
        "estimated_lines_changed": 0
      }
    },
    {
      "cve_id": "CVE-2017-5923",
      "cwe_id": "CWE-125",
      "cwe_name": "Out-of-bounds Read",
      "project": "VirusTotal",
      "severity": "critical",
      "weaponization_score": 8.0,
      "is_critical": true,
      "is_weaponizable": true,
      "is_high_priority_project": false,
      "vulnerable_code": "CWE-125 int yyparse ( void * yyscanner , YR_COMPILER * compiler ) { int yychar ; YY_INITIAL_VALUE ( static YYSTYPE yyval_default ; ) YYSTYPE yylval YY_INITIAL_VALUE ( = yyval_default ) ; int yynerrs ; int yystate ; int yyerrstatus ; yytype_int16 yyssa [ YYINITDEPTH ] ; yytype_int16 * yyss ; yytype_int16 * yyssp ; YYSTYPE yyvsa [ YYINITDEPTH ] ; YYSTYPE * yyvs ; YYSTYPE * yyvsp ; YYSIZE_T yystacksize ; int yyn ; int yyresult ; int yytoken = 0 ; YYSTYPE yyval ; # if YYERROR_VERBOSE char yymsgbuf [ 128 ] ; char * yymsg = yymsgbuf ; YYSIZE_T yymsg_alloc = sizeof yymsgbuf ; # endif # define YYPOPSTACK ( N ) ( yyvsp -= ( N ) , yyssp -= ( N ) ) int yylen = 0 ; yyssp = yyss = yyssa ; yyvsp = yyvs = yyvsa ; yystacksize = YYINITDEPTH ; YYDPRINTF ( ( stderr , \"Starting<S2SV_blank>parse\\\\n\" ) ) ; yystate = 0 ; yyerrstatus = 0 ; yynerrs = 0 ; yychar = YYEMPTY ; goto yysetstate ; yynewstate : yyssp ++ ; yysetstate : * yyssp = yystate ; if ( yyss + yystacksize - 1 <= yyssp ) { YYSIZE_T yysize = yyssp - yyss + 1 ; # ifdef yyoverflow { YYSTYPE * yyvs1 = yyvs ; yytype_int16 * yyss1 = yyss ; yyoverflow ( YY_ ( \"memory<S2SV_blank>exhausted\" ) , & yyss1 , yysize * sizeof ( * yyssp ) , & yyvs1 , yysize * sizeof ( * yyvsp ) , & yystacksize ) ; yyss = yyss1 ; yyvs = yyvs1 ; } # else # ifndef YYSTACK_RELOCATE goto yyexhaustedlab ; # else if ( YYMAXDEPTH <= yystacksize ) goto yyexhaustedlab ; yystacksize *= 2 ; if ( YYMAXDEPTH < yystacksize ) yystacksize = YYMAXDEPTH ; { yytype_int16 * yyss1 = yyss ; union yyalloc * yyptr = ( union yyalloc * ) YYSTACK_ALLOC ( YYSTACK_BYTES ( yystacksize ) ) ; if ( ! yyptr ) goto yyexhaustedlab ; YYSTACK_RELOCATE ( yyss_alloc , yyss ) ; YYSTACK_RELOCATE ( yyvs_alloc , yyvs ) ; # undef YYSTACK_RELOCATE if ( yyss1 != yyssa ) YYSTACK_FREE ( yyss1 ) ; } # endif # endif yyssp = yyss + yysize - 1 ; yyvsp = yyvs + yysize - 1 ; YYDPRINTF ( ( stderr , \"Stack<S2SV_blank>size<S2SV_blank>increased<S2SV_blank>to<S2SV_blank>%lu\\\\n\" , ( unsigned long int ) yystacksize ) ) ; if ( yyss + yystacksize - 1 <= yyssp ) YYABORT ; } YYDPRINTF ( ( stderr , \"Entering<S2SV_blank>state<S2SV_blank>%d\\\\n\" , yystate ) ) ; if ( yystate == YYFINAL ) YYACCEPT ; goto yybackup ; yybackup : yyn = yypact [ yystate ] ; if ( yypact_value_is_default ( yyn ) ) goto yydefault ; if ( yychar == YYEMPTY ) { YYDPRINTF ( ( stderr , \"Reading<S2SV_blank>a<S2SV_blank>token:<S2SV_blank>\" ) ) ; yychar = yylex ( & yylval , yyscanner , compiler ) ; } if ( yychar <= YYEOF ) { yychar = yytoken = YYEOF ; YYDPRINTF ( ( stderr , \"Now<S2SV_blank>at<S2SV_blank>end<S2SV_blank>of<S2SV_blank>input.\\\\n\" ) ) ; } else { yytoken = YYTRANSLATE ( yychar ) ; YY_SYMBOL_PRINT ( \"Next<S2SV_blank>token<S2SV_blank>is\" , yytoken , & yylval , & yylloc ) ; } yyn += yytoken ; if ( yyn < 0 || YYLAST < yyn || yycheck [ yyn ] != yytoken ) goto yydefault ; yyn = yytable [ yyn ] ; if ( yyn <= 0 ) { if ( yytable_value_is_error ( yyn ) ) goto yyerrlab ; yyn = - yyn ; goto yyreduce ; } if ( yyerrstatus ) yyerrstatus -- ; YY_SYMBOL_PRINT ( \"Shifting\" , yytoken , & yylval , & yylloc ) ; yychar = YYEMPTY ; yystate = yyn ; YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN * ++ yyvsp = yylval ; YY_IGNORE_MAYBE_UNINITIALIZED_END goto yynewstate ; yydefault : yyn = yydefact [ yystate ] ; if ( yyn == 0 ) goto yyerrlab ; goto yyreduce ; yyreduce : yylen = yyr2 [ yyn ] ; yyval = yyvsp [ 1 - yylen ] ; YY_REDUCE_PRINT ( yyn ) ; switch ( yyn ) { case 8 : # line 230 \"grammar.y\" { int result = yr_parser_reduce_import ( yyscanner , ( yyvsp [ 0 ] . sized_string ) ) ; yr_free ( ( yyvsp [ 0 ] . sized_string ) ) ; ERROR_IF ( result != ERROR_SUCCESS ) ; } # line 1661 \"grammar.c\" break ; case 9 : # line 242 \"grammar.y\" { YR_RULE * rule = yr_parser_reduce_rule_declaration_phase_1 ( yyscanner , ( int32_t ) ( yyvsp [ - 2 ] . integer ) , ( yyvsp [ 0 ] . c_string ) ) ; ERROR_IF ( rule == NULL ) ; ( yyval . rule ) = rule ; } # line 1674 \"grammar.c\" break ; case 10 : # line 251 \"grammar.y\" { YR_RULE * rule = ( yyvsp [ - 4 ] . rule ) ; rule -> tags = ( yyvsp [ - 3 ] . c_string ) ; rule -> metas = ( yyvsp [ - 1 ] . meta ) ; rule -> strings = ( yyvsp [ 0 ] . string ) ; } # line 1686 \"grammar.c\" break ; case 11 : # line 259 \"grammar.y\" { YR_RULE * rule = ( yyvsp [ - 7 ] . rule ) ; compiler -> last_result = yr_parser_reduce_rule_declaration_phase_2 ( yyscanner , rule ) ; yr_free ( ( yyvsp [ - 8 ] . c_string ) ) ; ERROR_IF ( compiler -> last_result != ERROR_SUCCESS ) ; } # line 1701 \"grammar.c\" break ; case 12 : # line 274 \"grammar.y\" { ( yyval . meta ) = NULL ; } # line 1709 \"grammar.c\" break ; case 13 : # line 278 \"grammar.y\" { YR_META null_meta ; memset ( & null_meta , 0xFF , sizeof ( YR_META ) ) ; null_meta . type = META_TYPE_NULL ; compiler -> last_result = yr_arena_write_data ( compiler -> metas_arena , & null_meta , sizeof ( YR_META ) , NULL ) ; ( yyval . meta ) = ( yyvsp [ 0 ] . meta ) ; ERROR_IF ( compiler -> last_result != ERROR_SUCCESS ) ; } # line 1736 \"grammar.c\" break ; case 14 : # line 305 \"grammar.y\" { ( yyval . string ) = NULL ; } # line 1744 \"grammar.c\" break ; case 15 : # line 309 \"grammar.y\" { YR_STRING null_string ; memset ( & null_string , 0xFF , sizeof ( YR_STRING ) ) ; null_string . g_flags = STRING_GFLAGS_NULL ; compiler -> last_result = yr_arena_write_data ( compiler -> strings_arena , & null_string , sizeof ( YR_STRING ) , NULL ) ; ERROR_IF ( compiler -> last_result != ERROR_SUCCESS ) ; ( yyval . string ) = ( yyvsp [ 0 ] . string ) ; } # line 1771 \"grammar.c\" break ; case 17 : # line 340 \"grammar.y\" { ( yyval . integer ) = 0 ; } # line 1777 \"grammar.c\" break ; case 18 : # line 341 \"grammar.y\" { ( yyval . integer ) = ( yyvsp [ - 1 ] . integer ) | ( yyvsp [ 0 ] . integer ) ; } # line 1783 \"grammar.c\" break ; case 19 : # line 346 \"grammar.y\" { ( yyval . integer ) = RULE_GFLAGS_PRIVATE ; } # line 1789 \"grammar.c\" break ; case 20 : # line 347 \"grammar.y\" { ( yyval . integer ) = RULE_GFLAGS_GLOBAL ; } # line 1795 \"grammar.c\" break ; case 21 : # line 353 \"grammar.y\" { ( yyval . c_string ) = NULL ; } # line 1803 \"grammar.c\" break ; case 22 : # line 357 \"grammar.y\" { compiler -> last_result = yr_arena_write_string ( yyget_extra ( yyscanner ) -> sz_arena , \"\" , NULL ) ; ERROR_IF ( compiler -> last_result != ERROR_SUCCESS ) ; ( yyval . c_string ) = ( yyvsp [ 0 ] . c_string ) ; } # line 1821 \"grammar.c\" break ; case 23 : # line 375 \"grammar.y\" { char * identifier ; compiler -> last_result = yr_arena_write_string ( yyget_extra ( yyscanner ) -> sz_arena , ( yyvsp [ 0 ] . c_string ) , & identifier ) ; yr_free ( ( yyvsp [ 0 ] . c_string ) ) ; ERROR_IF ( compiler -> last_result != ERROR_SUCCESS ) ; ( yyval . c_string ) = identifier ; } # line 1838 \"grammar.c\" break ; case 24 : # line 388 \"grammar.y\" { char * tag_name = ( yyvsp [ - 1 ] . c_string ) ; size_t tag_length = tag_name != NULL ? strlen ( tag_name ) : 0 ; while ( tag_length > 0 ) { if ( strcmp ( tag_name , ( yyvsp [ 0 ] . c_string ) ) == 0 ) { yr_compiler_set_error_extra_info ( compiler , tag_name ) ; compiler -> last_result = ERROR_DUPLICATED_TAG_IDENTIFIER ; break ; } tag_name = ( char * ) yr_arena_next_address ( yyget_extra ( yyscanner ) -> sz_arena , tag_name , tag_length + 1 ) ; tag_length = tag_name != NULL ? strlen ( tag_name ) : 0 ; } if ( compiler -> last_result == ERROR_SUCCESS ) compiler -> last_result = yr_arena_write_string ( yyget_extra ( yyscanner ) -> sz_arena , ( yyvsp [ 0 ] . c_string ) , NULL ) ; yr_free ( ( yyvsp [ 0 ] . c_string ) ) ; ERROR_IF ( compiler -> last_result != ERROR_SUCCESS ) ; ( yyval . c_string ) = ( yyvsp [ - 1 ] . c_string ) ; } # line 1874 \"grammar.c\" break ; case 25 : # line 424 \"grammar.y\" { ( yyval . meta ) = ( yyvsp [ 0 ] . meta ) ; } # line 1880 \"grammar.c\" break ; case 26 : # line 425 \"grammar.y\" { ( yyval . meta ) = ( yyvsp [ - 1 ] . meta ) ; } # line 1886 \"grammar.c\" break ; case 27 : # line 431 \"grammar.y\" { SIZED_STRING * sized_string = ( yyvsp [ 0 ] . sized_string ) ; ( yyval . meta ) = yr_parser_reduce_meta_declaration ( yyscanner , META_TYPE_STRING , ( yyvsp [ - 2 ] . c_string ) , sized_string -> c_string , 0 ) ; yr_free ( ( yyvsp [ - 2 ] . c_string ) ) ; yr_free ( ( yyvsp [ 0 ] . sized_string ) ) ; ERROR_IF ( ( yyval . meta ) == NULL ) ; } # line 1906 \"grammar.c\" break ; case 28 : # line 447 \"grammar.y\" { ( yyval . meta ) = yr_parser_reduce_meta_declaration ( yyscanner , META_TYPE_INTEGER , ( yyvsp [ - 2 ] . c_string ) , NULL , ( yyvsp [ 0 ] . integer ) ) ; yr_free ( ( yyvsp [ - 2 ] . c_string ) ) ; ERROR_IF ( ( yyval . meta ) == NULL ) ; } # line 1923 \"grammar.c\" break ; case 29 : # line 460 \"grammar.y\" { ( yyval . meta ) = yr_parser_reduce_meta_declaration ( yyscanner , META_TYPE_INTEGER , ( yyvsp [ - 3 ] . c_string ) , NULL , - ( yyvsp [ 0 ] . integer ) ) ; yr_free ( ( yyvsp [ - 3 ] . c_string ) ) ; ERROR_IF ( ( yyval . meta ) == NULL ) ; } # line 1940 \"grammar.c\" break ; case 30 : # line 473 \"grammar.y\" { ( yyval . meta ) = yr_parser_reduce_meta_declaration ( yyscanner , META_TYPE_BOOLEAN , ( yyvsp [ - 2 ] . c_string ) , NULL , TRUE ) ; yr_free ( ( yyvsp [ - 2 ] . c_string ) ) ; ERROR_IF ( ( yyval . meta ) == NULL ) ; } # line 1957 \"grammar.c\" break ; case 31 : # line 486 \"grammar.y\" { ( yyval . meta ) = yr_parser_reduce_meta_declaration ( yyscanner , META_TYPE_BOOLEAN , ( yyvsp [ - 2 ] . c_string ) , NULL , FALSE ) ; yr_free ( ( yyvsp [ - 2 ] . c_string ) ) ; ERROR_IF ( ( yyval . meta ) == NULL ) ; } # line 1974 \"grammar.c\" break ; case 32 : # line 502 \"grammar.y\" { ( yyval . string ) = ( yyvsp [ 0 ] . string ) ; } # line 1980 \"grammar.c\" break ; case 33 : # line 503 \"grammar.y\" { ( yyval . string ) = ( yyvsp [ - 1 ] . string ) ; } # line 1986 \"grammar.c\" break ; case 34 : # line 509 \"grammar.y\" { compiler -> error_line = yyget_lineno ( yyscanner ) ; } # line 1994 \"grammar.c\" break ; case 35 : # line 513 \"grammar.y\" { ( yyval . string ) = yr_parser_reduce_string_declaration ( yyscanner , ( int32_t ) ( yyvsp [ 0 ] . integer ) , ( yyvsp [ - 4 ] . c_string ) , ( yyvsp [ - 1 ] . sized_string ) ) ; yr_free ( ( yyvsp [ - 4 ] . c_string ) ) ; yr_free ( ( yyvsp [ - 1 ] . sized_string ) ) ; ERROR_IF ( ( yyval . string ) == NULL ) ; compiler -> error_line = 0 ; } # line 2009 \"grammar.c\" break ; case 36 : # line 524 \"grammar.y\" { compiler -> error_line = yyget_lineno ( yyscanner ) ; } # line 2017 \"grammar.c\" break ; case 37 : # line 528 \"grammar.y\" { ( yyval . string ) = yr_parser_reduce_string_declaration ( yyscanner , ( int32_t ) ( yyvsp [ 0 ] . integer ) | STRING_GFLAGS_REGEXP , ( yyvsp [ - 4 ] . c_string ) , ( yyvsp [ - 1 ] . sized_string ) ) ; yr_free ( ( yyvsp [ - 4 ] . c_string ) ) ; yr_free ( ( yyvsp [ - 1 ] . sized_string ) ) ; ERROR_IF ( ( yyval . string ) == NULL ) ; compiler -> error_line = 0 ; } # line 2033 \"grammar.c\" break ; case 38 : # line 540 \"grammar.y\" { ( yyval . string ) = yr_parser_reduce_string_declaration ( yyscanner , STRING_GFLAGS_HEXADECIMAL , ( yyvsp [ - 2 ] . c_string ) , ( yyvsp [ 0 ] . sized_string ) ) ; yr_free ( ( yyvsp [ - 2 ] . c_string ) ) ; yr_free ( ( yyvsp [ 0 ] . sized_string ) ) ; ERROR_IF ( ( yyval . string ) == NULL ) ; } # line 2047 \"grammar.c\" break ; case 39 : # line 553 \"grammar.y\" { ( yyval . integer ) = 0 ; } # line 2053 \"grammar.c\" break ; case 40 : # line 554 \"grammar.y\" { ( yyval . integer ) = ( yyvsp [ - 1 ] . integer ) | ( yyvsp [ 0 ] . integer ) ; } # line 2059 \"grammar.c\" break ; case 41 : # line 559 \"grammar.y\" { ( yyval . integer ) = STRING_GFLAGS_WIDE ; } # line 2065 \"grammar.c\" break ; case 42 : # line 560 \"grammar.y\" { ( yyval . integer ) = STRING_GFLAGS_ASCII ; } # line 2071 \"grammar.c\" break ; case 43 : # line 561 \"grammar.y\" { ( yyval . integer ) = STRING_GFLAGS_NO_CASE ; } # line 2077 \"grammar.c\" break ; case 44 : # line 562 \"grammar.y\" { ( yyval . integer ) = STRING_GFLAGS_FULL_WORD ; } # line 2083 \"grammar.c\" break ; case 45 : # line 568 \"grammar.y\" { int var_index = yr_parser_lookup_loop_variable ( yyscanner , ( yyvsp [ 0 ] . c_string ) ) ; if ( var_index >= 0 ) { compiler -> last_result = yr_parser_emit_with_arg ( yyscanner , OP_PUSH_M , LOOP_LOCAL_VARS * var_index , NULL , NULL ) ; ( yyval . expression ) . type = EXPRESSION_TYPE_INTEGER ; ( yyval . expression ) . value . integer = UNDEFINED ; ( yyval . expression ) . identifier = compiler -> loop_identifier [ var_index ] ; } else { YR_OBJECT * object = ( YR_OBJECT * ) yr_hash_table_lookup ( compiler -> objects_table , ( yyvsp [ 0 ] . c_string ) , NULL ) ; if ( object == NULL ) { char * ns = compiler -> current_namespace -> name ; object = ( YR_OBJECT * ) yr_hash_table_lookup ( compiler -> objects_table , ( yyvsp [ 0 ] . c_string ) , ns ) ; } if ( object != NULL ) { char * id ; compiler -> last_result = yr_arena_write_string ( compiler -> sz_arena , ( yyvsp [ 0 ] . c_string ) , & id ) ; if ( compiler -> last_result == ERROR_SUCCESS ) compiler -> last_result = yr_parser_emit_with_arg_reloc ( yyscanner , OP_OBJ_LOAD , id , NULL , NULL ) ; ( yyval . expression ) . type = EXPRESSION_TYPE_OBJECT ; ( yyval . expression ) . value . object = object ; ( yyval . expression ) . identifier = object -> identifier ; } else { YR_RULE * rule = ( YR_RULE * ) yr_hash_table_lookup ( compiler -> rules_table , ( yyvsp [ 0 ] . c_string ) , compiler -> current_namespace -> name ) ; if ( rule != NULL ) { compiler -> last_result = yr_parser_emit_with_arg_reloc ( yyscanner , OP_PUSH_RULE , rule , NULL , NULL ) ; ( yyval . expression ) . type = EXPRESSION_TYPE_BOOLEAN ; ( yyval . expression ) . value . integer = UNDEFINED ; ( yyval . expression ) . identifier = rule -> identifier ; } else { yr_compiler_set_error_extra_info ( compiler , ( yyvsp [ 0 ] . c_string ) ) ; compiler -> last_result = ERROR_UNDEFINED_IDENTIFIER ; } } } yr_free ( ( yyvsp [ 0 ] . c_string ) ) ; ERROR_IF ( compiler -> last_result != ERROR_SUCCESS ) ; } # line 2172 \"grammar.c\" break ; case 46 : # line 653 \"grammar.y\" { YR_OBJECT * field = NULL ; if ( ( yyvsp [ - 2 ] . expression ) . type == EXPRESSION_TYPE_OBJECT && ( yyvsp [ - 2 ] . expression ) . value . object -> type == OBJECT_TYPE_STRUCTURE ) { field = yr_object_lookup_field ( ( yyvsp [ - 2 ] . expression ) . value . object , ( yyvsp [ 0 ] . c_string ) ) ; if ( field != NULL ) { char * ident ; compiler -> last_result = yr_arena_write_string ( compiler -> sz_arena , ( yyvsp [ 0 ] . c_string ) , & ident ) ; if ( compiler -> last_result == ERROR_SUCCESS ) compiler -> last_result = yr_parser_emit_with_arg_reloc ( yyscanner , OP_OBJ_FIELD , ident , NULL , NULL ) ; ( yyval . expression ) . type = EXPRESSION_TYPE_OBJECT ; ( yyval . expression ) . value . object = field ; ( yyval . expression ) . identifier = field -> identifier ; } else { yr_compiler_set_error_extra_info ( compiler , ( yyvsp [ 0 ] . c_string ) ) ; compiler -> last_result = ERROR_INVALID_FIELD_NAME ; } } else { yr_compiler_set_error_extra_info ( compiler , ( yyvsp [ - 2 ] . expression ) . identifier ) ; compiler -> last_result = ERROR_NOT_A_STRUCTURE ; } yr_free ( ( yyvsp [ 0 ] . c_string ) ) ; ERROR_IF ( compiler -> last_result != ERROR_SUCCESS ) ; } # line 2222 \"grammar.c\" break ; case 47 : # line 699 \"grammar.y\" { YR_OBJECT_ARRAY * array ; YR_OBJECT_DICTIONARY * dict ; if ( ( yyvsp [ - 3 ] . expression ) . type == EXPRESSION_TYPE_OBJECT && ( yyvsp [ - 3 ] . expression ) . value . object -> type == OBJECT_TYPE_ARRAY ) { if ( ( yyvsp [ - 1 ] . expression ) . type != EXPRESSION_TYPE_INTEGER ) { yr_compiler_set_error_extra_info ( compiler , \"array<S2SV_blank>indexes<S2SV_blank>must<S2SV_blank>be<S2SV_blank>of<S2SV_blank>integer<S2SV_blank>type\" ) ; compiler -> last_result = ERROR_WRONG_TYPE ; } ERROR_IF ( compiler -> last_result != ERROR_SUCCESS ) ; compiler -> last_result = yr_parser_emit ( yyscanner , OP_INDEX_ARRAY , NULL ) ; array = ( YR_OBJECT_ARRAY * ) ( yyvsp [ - 3 ] . expression ) . value . object ; ( yyval . expression ) . type = EXPRESSION_TYPE_OBJECT ; ( yyval . expression ) . value . object = array -> prototype_item ; ( yyval . expression ) . identifier = array -> identifier ; } else if ( ( yyvsp [ - 3 ] . expression ) . type == EXPRESSION_TYPE_OBJECT && ( yyvsp [ - 3 ] . expression ) . value . object -> type == OBJECT_TYPE_DICTIONARY ) { if ( ( yyvsp [ - 1 ] . expression ) . type != EXPRESSION_TYPE_STRING ) { yr_compiler_set_error_extra_info ( compiler , \"dictionary<S2SV_blank>keys<S2SV_blank>must<S2SV_blank>be<S2SV_blank>of<S2SV_blank>string<S2SV_blank>type\" ) ; compiler -> last_result = ERROR_WRONG_TYPE ; } ERROR_IF ( compiler -> last_result != ERROR_SUCCESS ) ; compiler -> last_result = yr_parser_emit ( yyscanner , OP_LOOKUP_DICT , NULL ) ; dict = ( YR_OBJECT_DICTIONARY * ) ( yyvsp [ - 3 ] . expression ) . value . object ; ( yyval . expression ) . type = EXPRESSION_TYPE_OBJECT ; ( yyval . expression ) . value . object = dict -> prototype_item ; ( yyval . expression ) . identifier = dict -> identifier ; } else { yr_compiler_set_error_extra_info ( compiler , ( yyvsp [ - 3 ] . expression ) . identifier ) ; compiler -> last_result = ERROR_NOT_INDEXABLE ; } ERROR_IF ( compiler -> last_result != ERROR_SUCCESS ) ; } # line 2283 \"grammar.c\" break ; case 48 : # line 757 \"grammar.y\" { YR_OBJECT_FUNCTION * function ; char * args_fmt ; if ( ( yyvsp [ - 3 ] . expression ) . type == EXPRESSION_TYPE_OBJECT && ( yyvsp [ - 3 ] . expression ) . value . object -> type == OBJECT_TYPE_FUNCTION ) { compiler -> last_result = yr_parser_check_types ( compiler , ( YR_OBJECT_FUNCTION * ) ( yyvsp [ - 3 ] . expression ) . value . object , ( yyvsp [ - 1 ] . c_string ) ) ; if ( compiler -> last_result == ERROR_SUCCESS ) compiler -> last_result = yr_arena_write_string ( compiler -> sz_arena , ( yyvsp [ - 1 ] . c_string ) , & args_fmt ) ; if ( compiler -> last_result == ERROR_SUCCESS ) compiler -> last_result = yr_parser_emit_with_arg_reloc ( yyscanner , OP_CALL , args_fmt , NULL , NULL ) ; function = ( YR_OBJECT_FUNCTION * ) ( yyvsp [ - 3 ] . expression ) . value . object ; ( yyval . expression ) . type = EXPRESSION_TYPE_OBJECT ; ( yyval . expression ) . value . object = function -> return_obj ; ( yyval . expression ) . identifier = function -> identifier ; } else { yr_compiler_set_error_extra_info ( compiler , ( yyvsp [ - 3 ] . expression ) . identifier ) ; compiler -> last_result = ERROR_NOT_A_FUNCTION ; } yr_free ( ( yyvsp [ - 1 ] . c_string ) ) ; ERROR_IF ( compiler -> last_result != ERROR_SUCCESS ) ; } # line 2328 \"grammar.c\" break ; case 49 : # line 801 \"grammar.y\" { ( yyval . c_string ) = yr_strdup ( \"\" ) ; } # line 2334 \"grammar.c\" break ; case 50 : # line 802 \"grammar.y\" { ( yyval . c_string ) = ( yyvsp [ 0 ] . c_string ) ; } # line 2340 \"grammar.c\" break ; case 51 : # line 807 \"grammar.y\" { ( yyval . c_string ) = ( char * ) yr_malloc ( MAX_FUNCTION_ARGS + 1 ) ; switch ( ( yyvsp [ 0 ] . expression ) . type ) { case EXPRESSION_TYPE_INTEGER : strlcpy ( ( yyval . c_string ) , \"i\" , MAX_FUNCTION_ARGS ) ; break ; case EXPRESSION_TYPE_FLOAT : strlcpy ( ( yyval . c_string ) , \"f\" , MAX_FUNCTION_ARGS ) ; break ; case EXPRESSION_TYPE_BOOLEAN : strlcpy ( ( yyval . c_string ) , \"b\" , MAX_FUNCTION_ARGS ) ; break ; case EXPRESSION_TYPE_STRING : strlcpy ( ( yyval . c_string ) , \"s\" , MAX_FUNCTION_ARGS ) ; break ; case EXPRESSION_TYPE_REGEXP : strlcpy ( ( yyval . c_string ) , \"r\" , MAX_FUNCTION_ARGS ) ; break ; <S2SV_StartBug> } <S2SV_EndBug> ERROR_IF ( ( yyval . c_string ) == NULL ) ; } <S2SV_StartBug> # line 2369 \"grammar.c\" <S2SV_EndBug> break ; case 52 : <S2SV_StartBug> # line 832 \"grammar.y\" <S2SV_EndBug> { if ( strlen ( ( yyvsp [ - 2 ] . c_string ) ) == MAX_FUNCTION_ARGS ) { compiler -> last_result = ERROR_TOO_MANY_ARGUMENTS ; } else { switch ( ( yyvsp [ 0 ] . expression ) . type ) { case EXPRESSION_TYPE_INTEGER : strlcat ( ( yyvsp [ - 2 ] . c_string ) , \"i\" , MAX_FUNCTION_ARGS ) ; break ; case EXPRESSION_TYPE_FLOAT : strlcat ( ( yyvsp [ - 2 ] . c_string ) , \"f\" , MAX_FUNCTION_ARGS ) ; break ; case EXPRESSION_TYPE_BOOLEAN : strlcat ( ( yyvsp [ - 2 ] . c_string ) , \"b\" , MAX_FUNCTION_ARGS ) ; break ; case EXPRESSION_TYPE_STRING : strlcat ( ( yyvsp [ - 2 ] . c_string ) , \"s\" , MAX_FUNCTION_ARGS ) ; break ; case EXPRESSION_TYPE_REGEXP : strlcat ( ( yyvsp [ - 2 ] . c_string ) , \"r\" , MAX_FUNCTION_ARGS ) ; break ; <S2SV_StartBug> } <S2SV_EndBug> } ERROR_IF ( compiler -> last_result != ERROR_SUCCESS ) ; ( yyval . c_string ) = ( yyvsp [ - 2 ] . c_string ) ; } <S2SV_StartBug> # line 2405 \"grammar.c\" <S2SV_EndBug> break ; case 53 : <S2SV_StartBug> # line 868 \"grammar.y\" <S2SV_EndBug> { SIZED_STRING * sized_string = ( yyvsp [ 0 ] . sized_string ) ; RE * re ; RE_ERROR error ; int re_flags = 0 ; if ( sized_string -> flags & SIZED_STRING_FLAGS_NO_CASE ) re_flags |= RE_FLAGS_NO_CASE ; if ( sized_string -> flags & SIZED_STRING_FLAGS_DOT_ALL ) re_flags |= RE_FLAGS_DOT_ALL ; compiler -> last_result = yr_re_compile ( sized_string -> c_string , re_flags , compiler -> re_code_arena , & re , & error ) ; yr_free ( ( yyvsp [ 0 ] . sized_string ) ) ; if ( compiler -> last_result == ERROR_INVALID_REGULAR_EXPRESSION ) yr_compiler_set_error_extra_info ( compiler , error . message ) ; ERROR_IF ( compiler -> last_result != ERROR_SUCCESS ) ; if ( compiler -> last_result == ERROR_SUCCESS ) compiler -> last_result = yr_parser_emit_with_arg_reloc ( yyscanner , OP_PUSH , re -> root_node -> forward_code , NULL , NULL ) ; yr_re_destroy ( re ) ; ERROR_IF ( compiler -> last_result != ERROR_SUCCESS ) ; ( yyval . expression ) . type = EXPRESSION_TYPE_REGEXP ; } <S2SV_StartBug> # line 2451 \"grammar.c\" <S2SV_EndBug> break ; case 54 : <S2SV_StartBug> # line 914 \"grammar.y\" <S2SV_EndBug> { if ( ( yyvsp [ 0 ] . expression ) . type == EXPRESSION_TYPE_STRING ) { if ( ( yyvsp [ 0 ] . expression ) . value . sized_string != NULL ) { yywarning ( yyscanner , \"Using<S2SV_blank>literal<S2SV_blank>string<S2SV_blank>\\\\\"%s\\\\\"<S2SV_blank>in<S2SV_blank>a<S2SV_blank>boolean<S2SV_blank>operation.\" , ( yyvsp [ 0 ] . expression ) . value . sized_string -> c_string ) ; } compiler -> last_result = yr_parser_emit ( yyscanner , OP_STR_TO_BOOL , NULL ) ; ERROR_IF ( compiler -> last_result != ERROR_SUCCESS ) ; } ( yyval . expression ) . type = EXPRESSION_TYPE_BOOLEAN ; } <S2SV_StartBug> # line 2474 \"grammar.c\" <S2SV_EndBug> break ; case 55 : <S2SV_StartBug> # line 936 \"grammar.y\" <S2SV_EndBug> { compiler -> last_result = yr_parser_emit_with_arg ( yyscanner , OP_PUSH , 1 , NULL , NULL ) ; ERROR_IF ( compiler -> last_result != ERROR_SUCCESS ) ; ( yyval . expression ) . type = EXPRESSION_TYPE_BOOLEAN ; } <S2SV_StartBug> # line 2487 \"grammar.c\" <S2SV_EndBug> break ; case 56 : <S2SV_StartBug> # line 945 \"grammar.y\" <S2SV_EndBug> { compiler -> last_result = yr_parser_emit_with_arg ( yyscanner , OP_PUSH , 0 , NULL , NULL ) ; ERROR_IF ( compiler -> last_result != ERROR_SUCCESS ) ; ( yyval . expression ) . type = EXPRESSION_TYPE_BOOLEAN ; } <S2SV_StartBug> # line 2500 \"grammar.c\" <S2SV_EndBug> break ; case 57 : <S2SV_StartBug> # line 954 \"grammar.y\" <S2SV_EndBug> { CHECK_TYPE ( ( yyvsp [ - 2 ] . expression ) , EXPRESSION_TYPE_STRING , \"matches\" ) ; CHECK_TYPE ( ( yyvsp [ 0 ] . expression ) , EXPRESSION_TYPE_REGEXP , \"matches\" ) ; if ( compiler -> last_result == ERROR_SUCCESS ) compiler -> last_result = yr_parser_emit ( yyscanner , OP_MATCHES , NULL ) ; ERROR_IF ( compiler -> last_result != ERROR_SUCCESS ) ; ( yyval . expression ) . type = EXPRESSION_TYPE_BOOLEAN ; } <S2SV_StartBug> # line 2519 \"grammar.c\" <S2SV_EndBug> break ; case 58 : <S2SV_StartBug> # line 969 \"grammar.y\" <S2SV_EndBug> { CHECK_TYPE ( ( yyvsp [ - 2 ] . expression ) , EXPRESSION_TYPE_STRING , \"contains\" ) ; CHECK_TYPE ( ( yyvsp [ 0 ] . expression ) , EXPRESSION_TYPE_STRING , \"contains\" ) ; compiler -> last_result = yr_parser_emit ( yyscanner , OP_CONTAINS , NULL ) ; ERROR_IF ( compiler -> last_result != ERROR_SUCCESS ) ; ( yyval . expression ) . type = EXPRESSION_TYPE_BOOLEAN ; } <S2SV_StartBug> # line 2535 \"grammar.c\" <S2SV_EndBug> break ; case 59 : <S2SV_StartBug> # line 981 \"grammar.y\" <S2SV_EndBug> { int result = yr_parser_reduce_string_identifier ( yyscanner , ( yyvsp [ 0 ] . c_string ) , OP_FOUND , UNDEFINED ) ; yr_free ( ( yyvsp [ 0 ] . c_string ) ) ; ERROR_IF ( result != ERROR_SUCCESS ) ; ( yyval . expression ) . type = EXPRESSION_TYPE_BOOLEAN ; } <S2SV_StartBug> # line 2553 \"grammar.c\" <S2SV_EndBug> break ; case 60 : <S2SV_StartBug> # line 995 \"grammar.y\" <S2SV_EndBug> { CHECK_TYPE ( ( yyvsp [ 0 ] . expression ) , EXPRESSION_TYPE_INTEGER , \"at\" ) ; compiler -> last_result = yr_parser_reduce_string_identifier ( yyscanner , ( yyvsp [ - 2 ] . c_string ) , OP_FOUND_AT , ( yyvsp [ 0 ] . expression ) . value . integer ) ; yr_free ( ( yyvsp [ - 2 ] . c_string ) ) ; ERROR_IF ( compiler -> last_result != ERROR_SUCCESS ) ; ( yyval . expression ) . type = EXPRESSION_TYPE_BOOLEAN ; } <S2SV_StartBug> # line 2570 \"grammar.c\" <S2SV_EndBug> break ; case 61 : <S2SV_StartBug> # line 1008 \"grammar.y\" <S2SV_EndBug> { compiler -> last_result = yr_parser_reduce_string_identifier ( yyscanner , ( yyvsp [ - 2 ] . c_string ) , OP_FOUND_IN , UNDEFINED ) ; yr_free ( ( yyvsp [ - 2 ] . c_string ) ) ; ERROR_IF ( compiler -> last_result != ERROR_SUCCESS ) ; ( yyval . expression ) . type = EXPRESSION_TYPE_BOOLEAN ; } <S2SV_StartBug> # line 2585 \"grammar.c\" <S2SV_EndBug> break ; case 62 : <S2SV_StartBug> # line 1019 \"grammar.y\" <S2SV_EndBug> { if ( compiler -> loop_depth > 0 ) { compiler -> loop_depth -- ; compiler -> loop_identifier [ compiler -> loop_depth ] = NULL ; } <S2SV_StartBug> } <S2SV_EndBug> # line 2597 \"grammar.c\" break ; case 63 : <S2SV_StartBug> # line 1027 \"grammar.y\" <S2SV_EndBug> { int var_index ; if ( compiler -> loop_depth == MAX_LOOP_NESTING ) compiler -> last_result = ERROR_LOOP_NESTING_LIMIT_EXCEEDED ; ERROR_IF ( compiler -> last_result != ERROR_SUCCESS ) ; var_index = yr_parser_lookup_loop_variable ( yyscanner , ( yyvsp [ - 1 ] . c_string ) ) ; if ( var_index >= 0 ) { yr_compiler_set_error_extra_info ( compiler , ( yyvsp [ - 1 ] . c_string ) ) ; compiler -> last_result = ERROR_DUPLICATED_LOOP_IDENTIFIER ; } ERROR_IF ( compiler -> last_result != ERROR_SUCCESS ) ; compiler -> last_result = yr_parser_emit_with_arg ( yyscanner , OP_PUSH , UNDEFINED , NULL , NULL ) ; ERROR_IF ( compiler -> last_result != ERROR_SUCCESS ) ; } <S2SV_StartBug> # line 2631 \"grammar.c\" <S2SV_EndBug> break ; case 64 : <S2SV_StartBug> # line 1057 \"grammar.y\" <S2SV_EndBug> { int mem_offset = LOOP_LOCAL_VARS * compiler -> loop_depth ; uint8_t * addr ; yr_parser_emit_with_arg ( yyscanner , OP_CLEAR_M , mem_offset + 1 , NULL , NULL ) ; yr_parser_emit_with_arg ( yyscanner , OP_CLEAR_M , mem_offset + 2 , NULL , NULL ) ; if ( ( yyvsp [ - 1 ] . integer ) == INTEGER_SET_ENUMERATION ) { yr_parser_emit_with_arg ( yyscanner , OP_POP_M , mem_offset , & addr , NULL ) ; } else { yr_parser_emit_with_arg ( yyscanner , OP_POP_M , mem_offset + 3 , & addr , NULL ) ; yr_parser_emit_with_arg ( yyscanner , OP_POP_M , mem_offset , NULL , NULL ) ; } compiler -> loop_address [ compiler -> loop_depth ] = addr ; compiler -> loop_identifier [ compiler -> loop_depth ] = ( yyvsp [ - 4 ] . c_string ) ; compiler -> loop_depth ++ ; } <S2SV_StartBug> # line 2670 \"grammar.c\" <S2SV_EndBug> break ; case 65 : <S2SV_StartBug> # line 1092 \"grammar.y\" <S2SV_EndBug> { int mem_offset ; compiler -> loop_depth -- ; mem_offset = LOOP_LOCAL_VARS * compiler -> loop_depth ; yr_parser_emit_with_arg ( yyscanner , OP_ADD_M , mem_offset + 1 , NULL , NULL ) ; yr_parser_emit_with_arg ( yyscanner , OP_INCR_M , mem_offset + 2 , NULL , NULL ) ; if ( ( yyvsp [ - 5 ] . integer ) == INTEGER_SET_ENUMERATION ) { yr_parser_emit_with_arg_reloc ( yyscanner , OP_JNUNDEF , compiler -> loop_address [ compiler -> loop_depth ] , NULL , NULL ) ; } else { yr_parser_emit_with_arg ( yyscanner , OP_INCR_M , mem_offset , NULL , NULL ) ; yr_parser_emit_with_arg ( yyscanner , OP_PUSH_M , mem_offset , NULL , NULL ) ; yr_parser_emit_with_arg ( yyscanner , OP_PUSH_M , mem_offset + 3 , NULL , NULL ) ; yr_parser_emit_with_arg_reloc ( yyscanner , OP_JLE , compiler -> loop_address [ compiler -> loop_depth ] , NULL , NULL ) ; yr_parser_emit ( yyscanner , OP_POP , NULL ) ; yr_parser_emit ( yyscanner , OP_POP , NULL ) ; } yr_parser_emit ( yyscanner , OP_POP , NULL ) ; yr_parser_emit_with_arg ( yyscanner , OP_SWAPUNDEF , mem_offset + 2 , NULL , NULL ) ; yr_parser_emit_with_arg ( yyscanner , OP_PUSH_M , mem_offset + 1 , NULL , NULL ) ; yr_parser_emit ( yyscanner , OP_INT_LE , NULL ) ; compiler -> loop_identifier [ compiler -> loop_depth ] = NULL ; yr_free ( ( yyvsp [ - 8 ] . c_string ) ) ; ( yyval . expression ) . type = EXPRESSION_TYPE_BOOLEAN ; } <S2SV_StartBug> # line 2753 \"grammar.c\" <S2SV_EndBug> break ; case 66 : <S2SV_StartBug> # line 1171 \"grammar.y\" <S2SV_EndBug> { int mem_offset = LOOP_LOCAL_VARS * compiler -> loop_depth ; uint8_t * addr ; if ( compiler -> loop_depth == MAX_LOOP_NESTING ) compiler -> last_result = ERROR_LOOP_NESTING_LIMIT_EXCEEDED ; if ( compiler -> loop_for_of_mem_offset != - 1 ) compiler -> last_result = ERROR_NESTED_FOR_OF_LOOP ; ERROR_IF ( compiler -> last_result != ERROR_SUCCESS ) ; yr_parser_emit_with_arg ( yyscanner , OP_CLEAR_M , mem_offset + 1 , NULL , NULL ) ; yr_parser_emit_with_arg ( yyscanner , OP_CLEAR_M , mem_offset + 2 , NULL , NULL ) ; yr_parser_emit_with_arg ( yyscanner , OP_POP_M , mem_offset , & addr , NULL ) ; compiler -> loop_for_of_mem_offset = mem_offset ; compiler -> loop_address [ compiler -> loop_depth ] = addr ; compiler -> loop_identifier [ compiler -> loop_depth ] = NULL ; compiler -> loop_depth ++ ; } <S2SV_StartBug> # line 2787 \"grammar.c\" <S2SV_EndBug> break ; case 67 : <S2SV_StartBug> # line 1201 \"grammar.y\" <S2SV_EndBug> { int mem_offset ; compiler -> loop_depth -- ; compiler -> loop_for_of_mem_offset = - 1 ; mem_offset = LOOP_LOCAL_VARS * compiler -> loop_depth ; yr_parser_emit_with_arg ( yyscanner , OP_ADD_M , mem_offset + 1 , NULL , NULL ) ; yr_parser_emit_with_arg ( yyscanner , OP_INCR_M , mem_offset + 2 , NULL , NULL ) ; yr_parser_emit_with_arg_reloc ( yyscanner , OP_JNUNDEF , compiler -> loop_address [ compiler -> loop_depth ] , NULL , NULL ) ; yr_parser_emit ( yyscanner , OP_POP , NULL ) ; yr_parser_emit_with_arg ( yyscanner , OP_SWAPUNDEF , mem_offset + 2 , NULL , NULL ) ; yr_parser_emit_with_arg ( yyscanner , OP_PUSH_M , mem_offset + 1 , NULL , NULL ) ; yr_parser_emit ( yyscanner , OP_INT_LE , NULL ) ; ( yyval . expression ) . type = EXPRESSION_TYPE_BOOLEAN ; } <S2SV_StartBug> # line 2840 \"grammar.c\" <S2SV_EndBug> break ; case 68 : <S2SV_StartBug> # line 1250 \"grammar.y\" <S2SV_EndBug> { yr_parser_emit ( yyscanner , OP_OF , NULL ) ; ( yyval . expression ) . type = EXPRESSION_TYPE_BOOLEAN ; } <S2SV_StartBug> # line 2850 \"grammar.c\" <S2SV_EndBug> break ; case 69 : <S2SV_StartBug> # line 1256 \"grammar.y\" <S2SV_EndBug> { yr_parser_emit ( yyscanner , OP_NOT , NULL ) ; ( yyval . expression ) . type = EXPRESSION_TYPE_BOOLEAN ; } <S2SV_StartBug> # line 2860 \"grammar.c\" <S2SV_EndBug> break ; case 70 : <S2SV_StartBug> # line 1262 \"grammar.y\" <S2SV_EndBug> { YR_FIXUP * fixup ; void * jmp_destination_addr ; compiler -> last_result = yr_parser_emit_with_arg_reloc ( yyscanner , OP_JFALSE , 0 , NULL , & jmp_destination_addr ) ; ERROR_IF ( compiler -> last_result != ERROR_SUCCESS ) ; fixup = ( YR_FIXUP * ) yr_malloc ( sizeof ( YR_FIXUP ) ) ; if ( fixup == NULL ) compiler -> last_error = ERROR_INSUFFICIENT_MEMORY ; ERROR_IF ( compiler -> last_result != ERROR_SUCCESS ) ; fixup -> address = jmp_destination_addr ; fixup -> next = compiler -> fixup_stack_head ; compiler -> fixup_stack_head = fixup ; } <S2SV_StartBug> # line 2890 \"grammar.c\" <S2SV_EndBug> break ; case 71 : <S2SV_StartBug> # line 1288 \"grammar.y\" <S2SV_EndBug> { YR_FIXUP * fixup ; uint8_t * and_addr ; compiler -> last_result = yr_arena_reserve_memory ( compiler -> code_arena , 2 ) ; ERROR_IF ( compiler -> last_result != ERROR_SUCCESS ) ; compiler -> last_result = yr_parser_emit ( yyscanner , OP_AND , & and_addr ) ; ERROR_IF ( compiler -> last_result != ERROR_SUCCESS ) ; fixup = compiler -> fixup_stack_head ; * ( void * * ) ( fixup -> address ) = ( void * ) ( and_addr + 1 ) ; compiler -> fixup_stack_head = fixup -> next ; yr_free ( fixup ) ; ( yyval . expression ) . type = EXPRESSION_TYPE_BOOLEAN ; } <S2SV_StartBug> # line 2930 \"grammar.c\" <S2SV_EndBug> break ; case 72 : <S2SV_StartBug> # line 1324 \"grammar.y\" <S2SV_EndBug> { YR_FIXUP * fixup ; void * jmp_destination_addr ; compiler -> last_result = yr_parser_emit_with_arg_reloc ( yyscanner , OP_JTRUE , 0 , NULL , & jmp_destination_addr ) ; ERROR_IF ( compiler -> last_result != ERROR_SUCCESS ) ; fixup = ( YR_FIXUP * ) yr_malloc ( sizeof ( YR_FIXUP ) ) ; if ( fixup == NULL ) compiler -> last_error = ERROR_INSUFFICIENT_MEMORY ; ERROR_IF ( compiler -> last_result != ERROR_SUCCESS ) ; fixup -> address = jmp_destination_addr ; fixup -> next = compiler -> fixup_stack_head ; compiler -> fixup_stack_head = fixup ; } <S2SV_StartBug> # line 2959 \"grammar.c\" <S2SV_EndBug> break ; case 73 : <S2SV_StartBug> # line 1349 \"grammar.y\" <S2SV_EndBug> { YR_FIXUP * fixup ; uint8_t * or_addr ; compiler -> last_result = yr_arena_reserve_memory ( compiler -> code_arena , 2 ) ; ERROR_IF ( compiler -> last_result != ERROR_SUCCESS ) ; compiler -> last_result = yr_parser_emit ( yyscanner , OP_OR , & or_addr ) ; ERROR_IF ( compiler -> last_result != ERROR_SUCCESS ) ; fixup = compiler -> fixup_stack_head ; * ( void * * ) ( fixup -> address ) = ( void * ) ( or_addr + 1 ) ; compiler -> fixup_stack_head = fixup -> next ; yr_free ( fixup ) ; ( yyval . expression ) . type = EXPRESSION_TYPE_BOOLEAN ; } <S2SV_StartBug> # line 2999 \"grammar.c\" <S2SV_EndBug> break ; case 74 : <S2SV_StartBug> # line 1385 \"grammar.y\" <S2SV_EndBug> { compiler -> last_result = yr_parser_reduce_operation ( yyscanner , \"<\" , ( yyvsp [ - 2 ] . expression ) , ( yyvsp [ 0 ] . expression ) ) ; ERROR_IF ( compiler -> last_result != ERROR_SUCCESS ) ; ( yyval . expression ) . type = EXPRESSION_TYPE_BOOLEAN ; } <S2SV_StartBug> # line 3012 \"grammar.c\" <S2SV_EndBug> break ; case 75 : <S2SV_StartBug> # line 1394 \"grammar.y\" <S2SV_EndBug> { compiler -> last_result = yr_parser_reduce_operation ( yyscanner , \">\" , ( yyvsp [ - 2 ] . expression ) , ( yyvsp [ 0 ] . expression ) ) ; ERROR_IF ( compiler -> last_result != ERROR_SUCCESS ) ; ( yyval . expression ) . type = EXPRESSION_TYPE_BOOLEAN ; } <S2SV_StartBug> # line 3025 \"grammar.c\" <S2SV_EndBug> break ; case 76 : <S2SV_StartBug> # line 1403 \"grammar.y\" <S2SV_EndBug> { compiler -> last_result = yr_parser_reduce_operation ( yyscanner , \"<=\" , ( yyvsp [ - 2 ] . expression ) , ( yyvsp [ 0 ] . expression ) ) ; ERROR_IF ( compiler -> last_result != ERROR_SUCCESS ) ; ( yyval . expression ) . type = EXPRESSION_TYPE_BOOLEAN ; } <S2SV_StartBug> # line 3038 \"grammar.c\" <S2SV_EndBug> break ; case 77 : <S2SV_StartBug> # line 1412 \"grammar.y\" <S2SV_EndBug> { compiler -> last_result = yr_parser_reduce_operation ( yyscanner , \">=\" , ( yyvsp [ - 2 ] . expression ) , ( yyvsp [ 0 ] . expression ) ) ; ERROR_IF ( compiler -> last_result != ERROR_SUCCESS ) ; ( yyval . expression ) . type = EXPRESSION_TYPE_BOOLEAN ; } <S2SV_StartBug> # line 3051 \"grammar.c\" <S2SV_EndBug> break ; case 78 : <S2SV_StartBug> # line 1421 \"grammar.y\" <S2SV_EndBug> { compiler -> last_result = yr_parser_reduce_operation ( yyscanner , \"==\" , ( yyvsp [ - 2 ] . expression ) , ( yyvsp [ 0 ] . expression ) ) ; ERROR_IF ( compiler -> last_result != ERROR_SUCCESS ) ; ( yyval . expression ) . type = EXPRESSION_TYPE_BOOLEAN ; } <S2SV_StartBug> # line 3064 \"grammar.c\" <S2SV_EndBug> break ; case 79 : <S2SV_StartBug> # line 1430 \"grammar.y\" <S2SV_EndBug> { compiler -> last_result = yr_parser_reduce_operation ( yyscanner , \"!=\" , ( yyvsp [ - 2 ] . expression ) , ( yyvsp [ 0 ] . expression ) ) ; ERROR_IF ( compiler -> last_result != ERROR_SUCCESS ) ; ( yyval . expression ) . type = EXPRESSION_TYPE_BOOLEAN ; } <S2SV_StartBug> # line 3077 \"grammar.c\" <S2SV_EndBug> break ; case 80 : <S2SV_StartBug> # line 1439 \"grammar.y\" <S2SV_EndBug> { ( yyval . expression ) = ( yyvsp [ 0 ] . expression ) ; } <S2SV_StartBug> # line 3085 \"grammar.c\" <S2SV_EndBug> break ; case 81 : <S2SV_StartBug> # line 1443 \"grammar.y\" <S2SV_EndBug> { ( yyval . expression ) = ( yyvsp [ - 1 ] . expression ) ; } <S2SV_StartBug> # line 3093 \"grammar.c\" <S2SV_EndBug> break ; case 82 : <S2SV_StartBug> # line 1450 \"grammar.y\" <S2SV_EndBug> { ( yyval . integer ) = INTEGER_SET_ENUMERATION ; } <S2SV_StartBug> # line 3099 \"grammar.c\" <S2SV_EndBug> break ; case 83 : <S2SV_StartBug> # line 1451 \"grammar.y\" <S2SV_EndBug> { ( yyval . integer ) = INTEGER_SET_RANGE ; } <S2SV_StartBug> # line 3105 \"grammar.c\" <S2SV_EndBug> break ; case 84 : <S2SV_StartBug> # line 1457 \"grammar.y\" <S2SV_EndBug> { if ( ( yyvsp [ - 3 ] . expression ) . type != EXPRESSION_TYPE_INTEGER ) { yr_compiler_set_error_extra_info ( compiler , \"wrong<S2SV_blank>type<S2SV_blank>for<S2SV_blank>range\\'s<S2SV_blank>lower<S2SV_blank>bound\" ) ; compiler -> last_result = ERROR_WRONG_TYPE ; } if ( ( yyvsp [ - 1 ] . expression ) . type != EXPRESSION_TYPE_INTEGER ) { yr_compiler_set_error_extra_info ( compiler , \"wrong<S2SV_blank>type<S2SV_blank>for<S2SV_blank>range\\'s<S2SV_blank>upper<S2SV_blank>bound\" ) ; compiler -> last_result = ERROR_WRONG_TYPE ; } ERROR_IF ( compiler -> last_result != ERROR_SUCCESS ) ; } <S2SV_StartBug> # line 3127 \"grammar.c\" <S2SV_EndBug> break ; case 85 : <S2SV_StartBug> # line 1479 \"grammar.y\" <S2SV_EndBug> { if ( ( yyvsp [ 0 ] . expression ) . type != EXPRESSION_TYPE_INTEGER ) { yr_compiler_set_error_extra_info ( compiler , \"wrong<S2SV_blank>type<S2SV_blank>for<S2SV_blank>enumeration<S2SV_blank>item\" ) ; compiler -> last_result = ERROR_WRONG_TYPE ; } ERROR_IF ( compiler -> last_result != ERROR_SUCCESS ) ; } <S2SV_StartBug> # line 3143 \"grammar.c\" <S2SV_EndBug> break ; case 86 : <S2SV_StartBug> # line 1491 \"grammar.y\" <S2SV_EndBug> { if ( ( yyvsp [ 0 ] . expression ) . type != EXPRESSION_TYPE_INTEGER ) { yr_compiler_set_error_extra_info ( compiler , \"wrong<S2SV_blank>type<S2SV_blank>for<S2SV_blank>enumeration<S2SV_blank>item\" ) ; compiler -> last_result = ERROR_WRONG_TYPE ; } ERROR_IF ( compiler -> last_result != ERROR_SUCCESS ) ; } <S2SV_StartBug> # line 3158 \"grammar.c\" <S2SV_EndBug> break ; case 87 : <S2SV_StartBug> # line 1506 \"grammar.y\" <S2SV_EndBug> { yr_parser_emit_with_arg ( yyscanner , OP_PUSH , UNDEFINED , NULL , NULL ) ; } <S2SV_StartBug> # line 3167 \"grammar.c\" <S2SV_EndBug> break ; case 89 : <S2SV_StartBug> # line 1512 \"grammar.y\" <S2SV_EndBug> { yr_parser_emit_with_arg ( yyscanner , OP_PUSH , UNDEFINED , NULL , NULL ) ; yr_parser_emit_pushes_for_strings ( yyscanner , \"$*\" ) ; ERROR_IF ( compiler -> last_result != ERROR_SUCCESS ) ; } <S2SV_StartBug> # line 3178 \"grammar.c\" <S2SV_EndBug> break ; case 92 : <S2SV_StartBug> # line 1529 \"grammar.y\" <S2SV_EndBug> { yr_parser_emit_pushes_for_strings ( yyscanner , ( yyvsp [ 0 ] . c_string ) ) ; yr_free ( ( yyvsp [ 0 ] . c_string ) ) ; ERROR_IF ( compiler -> last_result != ERROR_SUCCESS ) ; } <S2SV_StartBug> # line 3189 \"grammar.c\" <S2SV_EndBug> break ; case 93 : <S2SV_StartBug> # line 1536 \"grammar.y\" <S2SV_EndBug> { yr_parser_emit_pushes_for_strings ( yyscanner , ( yyvsp [ 0 ] . c_string ) ) ; yr_free ( ( yyvsp [ 0 ] . c_string ) ) ; ERROR_IF ( compiler -> last_result != ERROR_SUCCESS ) ; } <S2SV_StartBug> # line 3200 \"grammar.c\" <S2SV_EndBug> break ; case 95 : <S2SV_StartBug> # line 1548 \"grammar.y\" <S2SV_EndBug> { yr_parser_emit_with_arg ( yyscanner , OP_PUSH , UNDEFINED , NULL , NULL ) ; } <S2SV_StartBug> # line 3208 \"grammar.c\" <S2SV_EndBug> break ; case 96 : <S2SV_StartBug> # line 1552 \"grammar.y\" <S2SV_EndBug> { yr_parser_emit_with_arg ( yyscanner , OP_PUSH , 1 , NULL , NULL ) ; } <S2SV_StartBug> # line 3216 \"grammar.c\" <S2SV_EndBug> break ; case 97 : <S2SV_StartBug> # line 1560 \"grammar.y\" <S2SV_EndBug> { ( yyval . expression ) = ( yyvsp [ - 1 ] . expression ) ; } <S2SV_StartBug> # line 3224 \"grammar.c\" <S2SV_EndBug> break ; case 98 : <S2SV_StartBug> # line 1564 \"grammar.y\" <S2SV_EndBug> { compiler -> last_result = yr_parser_emit ( yyscanner , OP_FILESIZE , NULL ) ; ERROR_IF ( compiler -> last_result != ERROR_SUCCESS ) ; ( yyval . expression ) . type = EXPRESSION_TYPE_INTEGER ; ( yyval . expression ) . value . integer = UNDEFINED ; } <S2SV_StartBug> # line 3238 \"grammar.c\" <S2SV_EndBug> break ; case 99 : <S2SV_StartBug> # line 1574 \"grammar.y\" <S2SV_EndBug> { yywarning ( yyscanner , \"Using<S2SV_blank>deprecated<S2SV_blank>\\\\\"entrypoint\\\\\"<S2SV_blank>keyword.<S2SV_blank>Use<S2SV_blank>the<S2SV_blank>\\\\\"entry_point\\\\\"<S2SV_blank>\" \"function<S2SV_blank>from<S2SV_blank>PE<S2SV_blank>module<S2SV_blank>instead.\" ) ; compiler -> last_result = yr_parser_emit ( yyscanner , OP_ENTRYPOINT , NULL ) ; ERROR_IF ( compiler -> last_result != ERROR_SUCCESS ) ; ( yyval . expression ) . type = EXPRESSION_TYPE_INTEGER ; ( yyval . expression ) . value . integer = UNDEFINED ; } <S2SV_StartBug> # line 3256 \"grammar.c\" <S2SV_EndBug> break ; case 100 : <S2SV_StartBug> # line 1588 \"grammar.y\" <S2SV_EndBug> { CHECK_TYPE ( ( yyvsp [ - 1 ] . expression ) , EXPRESSION_TYPE_INTEGER , \"intXXXX<S2SV_blank>or<S2SV_blank>uintXXXX\" ) ; compiler -> last_result = yr_parser_emit ( yyscanner , ( uint8_t ) ( OP_READ_INT + ( yyvsp [ - 3 ] . integer ) ) , NULL ) ; ERROR_IF ( compiler -> last_result != ERROR_SUCCESS ) ; ( yyval . expression ) . type = EXPRESSION_TYPE_INTEGER ; ( yyval . expression ) . value . integer = UNDEFINED ; } <S2SV_StartBug> # line 3276 \"grammar.c\" <S2SV_EndBug> break ; case 101 : <S2SV_StartBug> # line 1604 \"grammar.y\" <S2SV_EndBug> { compiler -> last_result = yr_parser_emit_with_arg ( yyscanner , OP_PUSH , ( yyvsp [ 0 ] . integer ) , NULL , NULL ) ; ERROR_IF ( compiler -> last_result != ERROR_SUCCESS ) ; ( yyval . expression ) . type = EXPRESSION_TYPE_INTEGER ; ( yyval . expression ) . value . integer = ( yyvsp [ 0 ] . integer ) ; } <S2SV_StartBug> # line 3290 \"grammar.c\" <S2SV_EndBug> break ; case 102 : <S2SV_StartBug> # line 1614 \"grammar.y\" <S2SV_EndBug> { compiler -> last_result = yr_parser_emit_with_arg_double ( yyscanner , OP_PUSH , ( yyvsp [ 0 ] . double_ ) , NULL , NULL ) ; ERROR_IF ( compiler -> last_result != ERROR_SUCCESS ) ; ( yyval . expression ) . type = EXPRESSION_TYPE_FLOAT ; } <S2SV_StartBug> # line 3303 \"grammar.c\" <S2SV_EndBug> break ; case 103 : <S2SV_StartBug> # line 1623 \"grammar.y\" <S2SV_EndBug> { SIZED_STRING * sized_string ; compiler -> last_result = yr_arena_write_data ( compiler -> sz_arena , ( yyvsp [ 0 ] . sized_string ) , ( yyvsp [ 0 ] . sized_string ) -> length + sizeof ( SIZED_STRING ) , ( void * * ) & sized_string ) ; yr_free ( ( yyvsp [ 0 ] . sized_string ) ) ; if ( compiler -> last_result == ERROR_SUCCESS ) compiler -> last_result = yr_parser_emit_with_arg_reloc ( yyscanner , OP_PUSH , sized_string , NULL , NULL ) ; ERROR_IF ( compiler -> last_result != ERROR_SUCCESS ) ; ( yyval . expression ) . type = EXPRESSION_TYPE_STRING ; ( yyval . expression ) . value . sized_string = sized_string ; } <S2SV_StartBug> # line 3332 \"grammar.c\" <S2SV_EndBug> break ; case 104 : <S2SV_StartBug> # line 1648 \"grammar.y\" <S2SV_EndBug> { compiler -> last_result = yr_parser_reduce_string_identifier ( yyscanner , ( yyvsp [ 0 ] . c_string ) , OP_COUNT , UNDEFINED ) ; yr_free ( ( yyvsp [ 0 ] . c_string ) ) ; ERROR_IF ( compiler -> last_result != ERROR_SUCCESS ) ; ( yyval . expression ) . type = EXPRESSION_TYPE_INTEGER ; ( yyval . expression ) . value . integer = UNDEFINED ; } <S2SV_StartBug> # line 3348 \"grammar.c\" <S2SV_EndBug> break ; case 105 : <S2SV_StartBug> # line 1660 \"grammar.y\" <S2SV_EndBug> { compiler -> last_result = yr_parser_reduce_string_identifier ( yyscanner , ( yyvsp [ - 3 ] . c_string ) , OP_OFFSET , UNDEFINED ) ; yr_free ( ( yyvsp [ - 3 ] . c_string ) ) ; ERROR_IF ( compiler -> last_result != ERROR_SUCCESS ) ; ( yyval . expression ) . type = EXPRESSION_TYPE_INTEGER ; ( yyval . expression ) . value . integer = UNDEFINED ; } <S2SV_StartBug> # line 3364 \"grammar.c\" <S2SV_EndBug> break ; case 106 : <S2SV_StartBug> # line 1672 \"grammar.y\" <S2SV_EndBug> { compiler -> last_result = yr_parser_emit_with_arg ( yyscanner , OP_PUSH , 1 , NULL , NULL ) ; if ( compiler -> last_result == ERROR_SUCCESS ) compiler -> last_result = yr_parser_reduce_string_identifier ( yyscanner , ( yyvsp [ 0 ] . c_string ) , OP_OFFSET , UNDEFINED ) ; yr_free ( ( yyvsp [ 0 ] . c_string ) ) ; ERROR_IF ( compiler -> last_result != ERROR_SUCCESS ) ; ( yyval . expression ) . type = EXPRESSION_TYPE_INTEGER ; ( yyval . expression ) . value . integer = UNDEFINED ; } <S2SV_StartBug> # line 3384 \"grammar.c\" <S2SV_EndBug> break ; case 107 : <S2SV_StartBug> # line 1688 \"grammar.y\" <S2SV_EndBug> { compiler -> last_result = yr_parser_reduce_string_identifier ( yyscanner , ( yyvsp [ - 3 ] . c_string ) , OP_LENGTH , UNDEFINED ) ; yr_free ( ( yyvsp [ - 3 ] . c_string ) ) ; ERROR_IF ( compiler -> last_result != ERROR_SUCCESS ) ; ( yyval . expression ) . type = EXPRESSION_TYPE_INTEGER ; ( yyval . expression ) . value . integer = UNDEFINED ; } <S2SV_StartBug> # line 3400 \"grammar.c\" <S2SV_EndBug> break ; case 108 : <S2SV_StartBug> # line 1700 \"grammar.y\" <S2SV_EndBug> { compiler -> last_result = yr_parser_emit_with_arg ( yyscanner , OP_PUSH , 1 , NULL , NULL ) ; if ( compiler -> last_result == ERROR_SUCCESS ) compiler -> last_result = yr_parser_reduce_string_identifier ( yyscanner , ( yyvsp [ 0 ] . c_string ) , OP_LENGTH , UNDEFINED ) ; yr_free ( ( yyvsp [ 0 ] . c_string ) ) ; ERROR_IF ( compiler -> last_result != ERROR_SUCCESS ) ; ( yyval . expression ) . type = EXPRESSION_TYPE_INTEGER ; ( yyval . expression ) . value . integer = UNDEFINED ; } <S2SV_StartBug> # line 3420 \"grammar.c\" <S2SV_EndBug> break ; case 109 : <S2SV_StartBug> # line 1716 \"grammar.y\" <S2SV_EndBug> { if ( ( yyvsp [ 0 ] . expression ) . type == EXPRESSION_TYPE_INTEGER ) { ( yyval . expression ) . type = EXPRESSION_TYPE_INTEGER ; ( yyval . expression ) . value . integer = UNDEFINED ; } else if ( ( yyvsp [ 0 ] . expression ) . type == EXPRESSION_TYPE_BOOLEAN ) { ( yyval . expression ) . type = EXPRESSION_TYPE_BOOLEAN ; ( yyval . expression ) . value . integer = UNDEFINED ; } else if ( ( yyvsp [ 0 ] . expression ) . type == EXPRESSION_TYPE_OBJECT ) { compiler -> last_result = yr_parser_emit ( yyscanner , OP_OBJ_VALUE , NULL ) ; switch ( ( yyvsp [ 0 ] . expression ) . value . object -> type ) { case OBJECT_TYPE_INTEGER : ( yyval . expression ) . type = EXPRESSION_TYPE_INTEGER ; ( yyval . expression ) . value . integer = UNDEFINED ; break ; case OBJECT_TYPE_FLOAT : ( yyval . expression ) . type = EXPRESSION_TYPE_FLOAT ; break ; case OBJECT_TYPE_STRING : ( yyval . expression ) . type = EXPRESSION_TYPE_STRING ; ( yyval . expression ) . value . sized_string = NULL ; break ; default : yr_compiler_set_error_extra_info_fmt ( compiler , \"wrong<S2SV_blank>usage<S2SV_blank>of<S2SV_blank>identifier<S2SV_blank>\\\\\"%s\\\\\"\" , ( yyvsp [ 0 ] . expression ) . identifier ) ; compiler -> last_result = ERROR_WRONG_TYPE ; } } else { assert ( FALSE ) ; } ERROR_IF ( compiler -> last_result != ERROR_SUCCESS ) ; } <S2SV_StartBug> # line 3469 \"grammar.c\" <S2SV_EndBug> break ; case 110 : <S2SV_StartBug> # line 1761 \"grammar.y\" <S2SV_EndBug> { CHECK_TYPE ( ( yyvsp [ 0 ] . expression ) , EXPRESSION_TYPE_INTEGER | EXPRESSION_TYPE_FLOAT , \"-\" ) ; if ( ( yyvsp [ 0 ] . expression ) . type == EXPRESSION_TYPE_INTEGER ) { ( yyval . expression ) . type = EXPRESSION_TYPE_INTEGER ; ( yyval . expression ) . value . integer = ( ( yyvsp [ 0 ] . expression ) . value . integer == UNDEFINED ) ? UNDEFINED : - ( ( yyvsp [ 0 ] . expression ) . value . integer ) ; compiler -> last_result = yr_parser_emit ( yyscanner , OP_INT_MINUS , NULL ) ; } else if ( ( yyvsp [ 0 ] . expression ) . type == EXPRESSION_TYPE_FLOAT ) { ( yyval . expression ) . type = EXPRESSION_TYPE_FLOAT ; compiler -> last_result = yr_parser_emit ( yyscanner , OP_DBL_MINUS , NULL ) ; } ERROR_IF ( compiler -> last_result != ERROR_SUCCESS ) ; } <S2SV_StartBug> # line 3492 \"grammar.c\" <S2SV_EndBug> break ; case 111 : <S2SV_StartBug> # line 1780 \"grammar.y\" <S2SV_EndBug> { compiler -> last_result = yr_parser_reduce_operation ( yyscanner , \"+\" , ( yyvsp [ - 2 ] . expression ) , ( yyvsp [ 0 ] . expression ) ) ; ERROR_IF ( compiler -> last_result != ERROR_SUCCESS ) ; if ( ( yyvsp [ - 2 ] . expression ) . type == EXPRESSION_TYPE_INTEGER && ( yyvsp [ 0 ] . expression ) . type == EXPRESSION_TYPE_INTEGER ) { ( yyval . expression ) . value . integer = OPERATION ( + , ( yyvsp [ - 2 ] . expression ) . value . integer , ( yyvsp [ 0 ] . expression ) . value . integer ) ; ( yyval . expression ) . type = EXPRESSION_TYPE_INTEGER ; } else { ( yyval . expression ) . type = EXPRESSION_TYPE_FLOAT ; } } <S2SV_StartBug> # line 3514 \"grammar.c\" <S2SV_EndBug> break ; case 112 : <S2SV_StartBug> # line 1798 \"grammar.y\" <S2SV_EndBug> { compiler -> last_result = yr_parser_reduce_operation ( yyscanner , \"-\" , ( yyvsp [ - 2 ] . expression ) , ( yyvsp [ 0 ] . expression ) ) ; ERROR_IF ( compiler -> last_result != ERROR_SUCCESS ) ; if ( ( yyvsp [ - 2 ] . expression ) . type == EXPRESSION_TYPE_INTEGER && ( yyvsp [ 0 ] . expression ) . type == EXPRESSION_TYPE_INTEGER ) { ( yyval . expression ) . value . integer = OPERATION ( - , ( yyvsp [ - 2 ] . expression ) . value . integer , ( yyvsp [ 0 ] . expression ) . value . integer ) ; ( yyval . expression ) . type = EXPRESSION_TYPE_INTEGER ; } else { ( yyval . expression ) . type = EXPRESSION_TYPE_FLOAT ; } } <S2SV_StartBug> # line 3536 \"grammar.c\" <S2SV_EndBug> break ; case 113 : <S2SV_StartBug> # line 1816 \"grammar.y\" <S2SV_EndBug> { compiler -> last_result = yr_parser_reduce_operation ( yyscanner , \"*\" , ( yyvsp [ - 2 ] . expression ) , ( yyvsp [ 0 ] . expression ) ) ; ERROR_IF ( compiler -> last_result != ERROR_SUCCESS ) ; if ( ( yyvsp [ - 2 ] . expression ) . type == EXPRESSION_TYPE_INTEGER && ( yyvsp [ 0 ] . expression ) . type == EXPRESSION_TYPE_INTEGER ) { ( yyval . expression ) . value . integer = OPERATION ( * , ( yyvsp [ - 2 ] . expression ) . value . integer , ( yyvsp [ 0 ] . expression ) . value . integer ) ; ( yyval . expression ) . type = EXPRESSION_TYPE_INTEGER ; } else { ( yyval . expression ) . type = EXPRESSION_TYPE_FLOAT ; } } <S2SV_StartBug> # line 3558 \"grammar.c\" <S2SV_EndBug> break ; case 114 : <S2SV_StartBug> # line 1834 \"grammar.y\" <S2SV_EndBug> { compiler -> last_result = yr_parser_reduce_operation ( yyscanner , \"\\\\\\\\\" , ( yyvsp [ - 2 ] . expression ) , ( yyvsp [ 0 ] . expression ) ) ; ERROR_IF ( compiler -> last_result != ERROR_SUCCESS ) ; if ( ( yyvsp [ - 2 ] . expression ) . type == EXPRESSION_TYPE_INTEGER && ( yyvsp [ 0 ] . expression ) . type == EXPRESSION_TYPE_INTEGER ) { if ( ( yyvsp [ 0 ] . expression ) . value . integer != 0 ) { ( yyval . expression ) . value . integer = OPERATION ( / , ( yyvsp [ - 2 ] . expression ) . value . integer , ( yyvsp [ 0 ] . expression ) . value . integer ) ; ( yyval . expression ) . type = EXPRESSION_TYPE_INTEGER ; } else { compiler -> last_result = ERROR_DIVISION_BY_ZERO ; ERROR_IF ( compiler -> last_result != ERROR_SUCCESS ) ; } } else { ( yyval . expression ) . type = EXPRESSION_TYPE_FLOAT ; } } <S2SV_StartBug> # line 3588 \"grammar.c\" <S2SV_EndBug> break ; case 115 : <S2SV_StartBug> # line 1860 \"grammar.y\" <S2SV_EndBug> { CHECK_TYPE ( ( yyvsp [ - 2 ] . expression ) , EXPRESSION_TYPE_INTEGER , \"%\" ) ; CHECK_TYPE ( ( yyvsp [ 0 ] . expression ) , EXPRESSION_TYPE_INTEGER , \"%\" ) ; yr_parser_emit ( yyscanner , OP_MOD , NULL ) ; if ( ( yyvsp [ 0 ] . expression ) . value . integer != 0 ) { ( yyval . expression ) . value . integer = OPERATION ( % , ( yyvsp [ - 2 ] . expression ) . value . integer , ( yyvsp [ 0 ] . expression ) . value . integer ) ; ( yyval . expression ) . type = EXPRESSION_TYPE_INTEGER ; } else { compiler -> last_result = ERROR_DIVISION_BY_ZERO ; ERROR_IF ( compiler -> last_result != ERROR_SUCCESS ) ; } } <S2SV_StartBug> # line 3610 \"grammar.c\" <S2SV_EndBug> break ; case 116 : <S2SV_StartBug> # line 1878 \"grammar.y\" <S2SV_EndBug> { CHECK_TYPE ( ( yyvsp [ - 2 ] . expression ) , EXPRESSION_TYPE_INTEGER , \"^\" ) ; CHECK_TYPE ( ( yyvsp [ 0 ] . expression ) , EXPRESSION_TYPE_INTEGER , \"^\" ) ; yr_parser_emit ( yyscanner , OP_BITWISE_XOR , NULL ) ; ( yyval . expression ) . type = EXPRESSION_TYPE_INTEGER ; ( yyval . expression ) . value . integer = OPERATION ( ^ , ( yyvsp [ - 2 ] . expression ) . value . integer , ( yyvsp [ 0 ] . expression ) . value . integer ) ; } <S2SV_StartBug> # line 3624 \"grammar.c\" <S2SV_EndBug> break ; case 117 : <S2SV_StartBug> # line 1888 \"grammar.y\" <S2SV_EndBug> { CHECK_TYPE ( ( yyvsp [ - 2 ] . expression ) , EXPRESSION_TYPE_INTEGER , \"^\" ) ; CHECK_TYPE ( ( yyvsp [ 0 ] . expression ) , EXPRESSION_TYPE_INTEGER , \"^\" ) ; yr_parser_emit ( yyscanner , OP_BITWISE_AND , NULL ) ; ( yyval . expression ) . type = EXPRESSION_TYPE_INTEGER ; ( yyval . expression ) . value . integer = OPERATION ( & , ( yyvsp [ - 2 ] . expression ) . value . integer , ( yyvsp [ 0 ] . expression ) . value . integer ) ; } <S2SV_StartBug> # line 3638 \"grammar.c\" <S2SV_EndBug> break ; case 118 : <S2SV_StartBug> # line 1898 \"grammar.y\" <S2SV_EndBug> { CHECK_TYPE ( ( yyvsp [ - 2 ] . expression ) , EXPRESSION_TYPE_INTEGER , \"|\" ) ; CHECK_TYPE ( ( yyvsp [ 0 ] . expression ) , EXPRESSION_TYPE_INTEGER , \"|\" ) ; yr_parser_emit ( yyscanner , OP_BITWISE_OR , NULL ) ; ( yyval . expression ) . type = EXPRESSION_TYPE_INTEGER ; ( yyval . expression ) . value . integer = OPERATION ( | , ( yyvsp [ - 2 ] . expression ) . value . integer , ( yyvsp [ 0 ] . expression ) . value . integer ) ; } <S2SV_StartBug> # line 3652 \"grammar.c\" <S2SV_EndBug> break ; case 119 : <S2SV_StartBug> # line 1908 \"grammar.y\" <S2SV_EndBug> { CHECK_TYPE ( ( yyvsp [ 0 ] . expression ) , EXPRESSION_TYPE_INTEGER , \"~\" ) ; yr_parser_emit ( yyscanner , OP_BITWISE_NOT , NULL ) ; ( yyval . expression ) . type = EXPRESSION_TYPE_INTEGER ; ( yyval . expression ) . value . integer = ( ( yyvsp [ 0 ] . expression ) . value . integer == UNDEFINED ) ? UNDEFINED : ~ ( ( yyvsp [ 0 ] . expression ) . value . integer ) ; } <S2SV_StartBug> # line 3666 \"grammar.c\" <S2SV_EndBug> break ; case 120 : <S2SV_StartBug> # line 1918 \"grammar.y\" <S2SV_EndBug> { CHECK_TYPE ( ( yyvsp [ - 2 ] . expression ) , EXPRESSION_TYPE_INTEGER , \"<<\" ) ; CHECK_TYPE ( ( yyvsp [ 0 ] . expression ) , EXPRESSION_TYPE_INTEGER , \"<<\" ) ; yr_parser_emit ( yyscanner , OP_SHL , NULL ) ; ( yyval . expression ) . type = EXPRESSION_TYPE_INTEGER ; ( yyval . expression ) . value . integer = OPERATION ( << , ( yyvsp [ - 2 ] . expression ) . value . integer , ( yyvsp [ 0 ] . expression ) . value . integer ) ; } <S2SV_StartBug> # line 3680 \"grammar.c\" <S2SV_EndBug> break ; case 121 : <S2SV_StartBug> # line 1928 \"grammar.y\" <S2SV_EndBug> { CHECK_TYPE ( ( yyvsp [ - 2 ] . expression ) , EXPRESSION_TYPE_INTEGER , \">>\" ) ; CHECK_TYPE ( ( yyvsp [ 0 ] . expression ) , EXPRESSION_TYPE_INTEGER , \">>\" ) ; yr_parser_emit ( yyscanner , OP_SHR , NULL ) ; ( yyval . expression ) . type = EXPRESSION_TYPE_INTEGER ; ( yyval . expression ) . value . integer = OPERATION ( >> , ( yyvsp [ - 2 ] . expression ) . value . integer , ( yyvsp [ 0 ] . expression ) . value . integer ) ; } <S2SV_StartBug> # line 3694 \"grammar.c\" <S2SV_EndBug> break ; case 122 : <S2SV_StartBug> # line 1938 \"grammar.y\" <S2SV_EndBug> { ( yyval . expression ) = ( yyvsp [ 0 ] . expression ) ; } <S2SV_StartBug> # line 3702 \"grammar.c\" <S2SV_EndBug> break ; <S2SV_StartBug> # line 3706 \"grammar.c\" <S2SV_EndBug> default : break ; } YY_SYMBOL_PRINT ( \"-><S2SV_blank>$$<S2SV_blank>=\" , yyr1 [ yyn ] , & yyval , & yyloc ) ; YYPOPSTACK ( yylen ) ; yylen = 0 ; YY_STACK_PRINT ( yyss , yyssp ) ; * ++ yyvsp = yyval ; yyn = yyr1 [ yyn ] ; yystate = yypgoto [ yyn - YYNTOKENS ] + * yyssp ; if ( 0 <= yystate && yystate <= YYLAST && yycheck [ yystate ] == * yyssp ) yystate = yytable [ yystate ] ; else yystate = yydefgoto [ yyn - YYNTOKENS ] ; goto yynewstate ; yyerrlab : yytoken = yychar == YYEMPTY ? YYEMPTY : YYTRANSLATE ( yychar ) ; if ( ! yyerrstatus ) { ++ yynerrs ; # if ! YYERROR_VERBOSE yyerror ( yyscanner , compiler , YY_ ( \"syntax<S2SV_blank>error\" ) ) ; # else # define YYSYNTAX_ERROR yysyntax_error ( & yymsg_alloc , & yymsg , yyssp , yytoken ) { char const * yymsgp = YY_ ( \"syntax<S2SV_blank>error\" ) ; int yysyntax_error_status ; yysyntax_error_status = YYSYNTAX_ERROR ; if ( yysyntax_error_status == 0 ) yymsgp = yymsg ; else if ( yysyntax_error_status == 1 ) { if ( yymsg != yymsgbuf ) YYSTACK_FREE ( yymsg ) ; yymsg = ( char * ) YYSTACK_ALLOC ( yymsg_alloc ) ; if ( ! yymsg ) { yymsg = yymsgbuf ; yymsg_alloc = sizeof yymsgbuf ; yysyntax_error_status = 2 ; } else { yysyntax_error_status = YYSYNTAX_ERROR ; yymsgp = yymsg ; } } yyerror ( yyscanner , compiler , yymsgp ) ; if ( yysyntax_error_status == 2 ) goto yyexhaustedlab ; } # undef YYSYNTAX_ERROR # endif } if ( yyerrstatus == 3 ) { if ( yychar <= YYEOF ) { if ( yychar == YYEOF ) YYABORT ; } else { yydestruct ( \"Error:<S2SV_blank>discarding\" , yytoken , & yylval , yyscanner , compiler ) ; yychar = YYEMPTY ; } } goto yyerrlab1 ; yyerrorlab : if ( 0 ) goto yyerrorlab ; YYPOPSTACK ( yylen ) ; yylen = 0 ; YY_STACK_PRINT ( yyss , yyssp ) ; yystate = * yyssp ; goto yyerrlab1 ; yyerrlab1 : yyerrstatus = 3 ; for ( ; ; ) { yyn = yypact [ yystate ] ; if ( ! yypact_value_is_default ( yyn ) ) { yyn += YYTERROR ; if ( 0 <= yyn && yyn <= YYLAST && yycheck [ yyn ] == YYTERROR ) { yyn = yytable [ yyn ] ; if ( 0 < yyn ) break ; } } if ( yyssp == yyss ) YYABORT ; yydestruct ( \"Error:<S2SV_blank>popping\" , yystos [ yystate ] , yyvsp , yyscanner , compiler ) ; YYPOPSTACK ( 1 ) ; yystate = * yyssp ; YY_STACK_PRINT ( yyss , yyssp ) ; } YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN * ++ yyvsp = yylval ; YY_IGNORE_MAYBE_UNINITIALIZED_END YY_SYMBOL_PRINT ( \"Shifting\" , yystos [ yyn ] , yyvsp , yylsp ) ; yystate = yyn ; goto yynewstate ; yyacceptlab : yyresult = 0 ; goto yyreturn ; yyabortlab : yyresult = 1 ; goto yyreturn ; # if ! defined yyoverflow || YYERROR_VERBOSE yyexhaustedlab : yyerror ( yyscanner , compiler , YY_ ( \"memory<S2SV_blank>exhausted\" ) ) ; yyresult = 2 ; # endif yyreturn : if ( yychar != YYEMPTY ) { yytoken = YYTRANSLATE ( yychar ) ; yydestruct ( \"Cleanup:<S2SV_blank>discarding<S2SV_blank>lookahead\" , yytoken , & yylval , yyscanner , compiler ) ; } YYPOPSTACK ( yylen ) ; YY_STACK_PRINT ( yyss , yyssp ) ; while ( yyssp != yyss ) { yydestruct ( \"Cleanup:<S2SV_blank>popping\" , yystos [ * yyssp ] , yyvsp , yyscanner , compiler ) ; YYPOPSTACK ( 1 ) ; } # ifndef yyoverflow if ( yyss != yyssa ) YYSTACK_FREE ( yyss ) ; # endif # if YYERROR_VERBOSE if ( yymsg != yymsgbuf ) YYSTACK_FREE ( yymsg ) ; # endif return yyresult ; }\n",
      "fixed_code": "<S2SV_ModStart> ; break ; default : assert ( FALSE ) ; <S2SV_ModStart> } # line 2371 <S2SV_ModEnd> \"grammar.c\" break ; <S2SV_ModStart> : # line 834 <S2SV_ModEnd> \"grammar.y\" { if <S2SV_ModStart> ; break ; default : assert ( FALSE ) ; <S2SV_ModStart> } # line 2409 <S2SV_ModEnd> \"grammar.c\" break ; <S2SV_ModStart> : # line 872 <S2SV_ModEnd> \"grammar.y\" { SIZED_STRING <S2SV_ModStart> } # line 2455 <S2SV_ModEnd> \"grammar.c\" break ; <S2SV_ModStart> : # line 918 <S2SV_ModEnd> \"grammar.y\" { if <S2SV_ModStart> } # line 2478 <S2SV_ModEnd> \"grammar.c\" break ; <S2SV_ModStart> : # line 940 <S2SV_ModEnd> \"grammar.y\" { compiler <S2SV_ModStart> } # line 2491 <S2SV_ModEnd> \"grammar.c\" break ; <S2SV_ModStart> : # line 949 <S2SV_ModEnd> \"grammar.y\" { compiler <S2SV_ModStart> } # line 2504 <S2SV_ModEnd> \"grammar.c\" break ; <S2SV_ModStart> : # line 958 <S2SV_ModEnd> \"grammar.y\" { CHECK_TYPE <S2SV_ModStart> } # line 2523 <S2SV_ModEnd> \"grammar.c\" break ; <S2SV_ModStart> : # line 973 <S2SV_ModEnd> \"grammar.y\" { CHECK_TYPE <S2SV_ModStart> } # line 2539 <S2SV_ModEnd> \"grammar.c\" break ; <S2SV_ModStart> : # line 985 <S2SV_ModEnd> \"grammar.y\" { int <S2SV_ModStart> } # line 2557 <S2SV_ModEnd> \"grammar.c\" break ; <S2SV_ModStart> : # line 999 <S2SV_ModEnd> \"grammar.y\" { CHECK_TYPE <S2SV_ModStart> } # line 2574 <S2SV_ModEnd> \"grammar.c\" break ; <S2SV_ModStart> : # line 1012 <S2SV_ModEnd> \"grammar.y\" { compiler <S2SV_ModStart> } # line 2589 <S2SV_ModEnd> \"grammar.c\" break ; <S2SV_ModStart> : # line 1023 <S2SV_ModEnd> \"grammar.y\" { if <S2SV_ModStart> NULL ; } YYERROR ; } # line 2603 <S2SV_ModEnd> \"grammar.c\" break ; <S2SV_ModStart> : # line 1033 <S2SV_ModEnd> \"grammar.y\" { int <S2SV_ModStart> } # line 2637 <S2SV_ModEnd> \"grammar.c\" break ; <S2SV_ModStart> : # line 1063 <S2SV_ModEnd> \"grammar.y\" { int <S2SV_ModStart> } # line 2676 <S2SV_ModEnd> \"grammar.c\" break ; <S2SV_ModStart> : # line 1098 <S2SV_ModEnd> \"grammar.y\" { int <S2SV_ModStart> } # line 2759 <S2SV_ModEnd> \"grammar.c\" break ; <S2SV_ModStart> : # line 1177 <S2SV_ModEnd> \"grammar.y\" { int <S2SV_ModStart> } # line 2793 <S2SV_ModEnd> \"grammar.c\" break ; <S2SV_ModStart> : # line 1207 <S2SV_ModEnd> \"grammar.y\" { int <S2SV_ModStart> } # line 2846 <S2SV_ModEnd> \"grammar.c\" break ; <S2SV_ModStart> : # line 1256 <S2SV_ModEnd> \"grammar.y\" { yr_parser_emit <S2SV_ModStart> } # line 2856 <S2SV_ModEnd> \"grammar.c\" break ; <S2SV_ModStart> : # line 1262 <S2SV_ModEnd> \"grammar.y\" { yr_parser_emit <S2SV_ModStart> } # line 2866 <S2SV_ModEnd> \"grammar.c\" break ; <S2SV_ModStart> : # line 1268 <S2SV_ModEnd> \"grammar.y\" { YR_FIXUP <S2SV_ModStart> } # line 2896 <S2SV_ModEnd> \"grammar.c\" break ; <S2SV_ModStart> : # line 1294 <S2SV_ModEnd> \"grammar.y\" { YR_FIXUP <S2SV_ModStart> } # line 2936 <S2SV_ModEnd> \"grammar.c\" break ; <S2SV_ModStart> : # line 1330 <S2SV_ModEnd> \"grammar.y\" { YR_FIXUP <S2SV_ModStart> } # line 2965 <S2SV_ModEnd> \"grammar.c\" break ; <S2SV_ModStart> : # line 1355 <S2SV_ModEnd> \"grammar.y\" { YR_FIXUP <S2SV_ModStart> } # line 3005 <S2SV_ModEnd> \"grammar.c\" break ; <S2SV_ModStart> : # line 1391 <S2SV_ModEnd> \"grammar.y\" { compiler <S2SV_ModStart> } # line 3018 <S2SV_ModEnd> \"grammar.c\" break ; <S2SV_ModStart> : # line 1400 <S2SV_ModEnd> \"grammar.y\" { compiler <S2SV_ModStart> } # line 3031 <S2SV_ModEnd> \"grammar.c\" break ; <S2SV_ModStart> : # line 1409 <S2SV_ModEnd> \"grammar.y\" { compiler <S2SV_ModStart> } # line 3044 <S2SV_ModEnd> \"grammar.c\" break ; <S2SV_ModStart> : # line 1418 <S2SV_ModEnd> \"grammar.y\" { compiler <S2SV_ModStart> } # line 3057 <S2SV_ModEnd> \"grammar.c\" break ; <S2SV_ModStart> : # line 1427 <S2SV_ModEnd> \"grammar.y\" { compiler <S2SV_ModStart> } # line 3070 <S2SV_ModEnd> \"grammar.c\" break ; <S2SV_ModStart> : # line 1436 <S2SV_ModEnd> \"grammar.y\" { compiler <S2SV_ModStart> } # line 3083 <S2SV_ModEnd> \"grammar.c\" break ; <S2SV_ModStart> : # line 1445 <S2SV_ModEnd> \"grammar.y\" { ( <S2SV_ModStart> } # line 3091 <S2SV_ModEnd> \"grammar.c\" break ; <S2SV_ModStart> : # line 1449 <S2SV_ModEnd> \"grammar.y\" { ( <S2SV_ModStart> } # line 3099 <S2SV_ModEnd> \"grammar.c\" break ; <S2SV_ModStart> : # line 1456 <S2SV_ModEnd> \"grammar.y\" { ( <S2SV_ModStart> } # line 3105 <S2SV_ModEnd> \"grammar.c\" break ; <S2SV_ModStart> : # line 1457 <S2SV_ModEnd> \"grammar.y\" { ( <S2SV_ModStart> } # line 3111 <S2SV_ModEnd> \"grammar.c\" break ; <S2SV_ModStart> : # line 1463 <S2SV_ModEnd> \"grammar.y\" { if <S2SV_ModStart> } # line 3133 <S2SV_ModEnd> \"grammar.c\" break ; <S2SV_ModStart> : # line 1485 <S2SV_ModEnd> \"grammar.y\" { if <S2SV_ModStart> } # line 3149 <S2SV_ModEnd> \"grammar.c\" break ; <S2SV_ModStart> : # line 1497 <S2SV_ModEnd> \"grammar.y\" { if <S2SV_ModStart> } # line 3164 <S2SV_ModEnd> \"grammar.c\" break ; <S2SV_ModStart> : # line 1512 <S2SV_ModEnd> \"grammar.y\" { yr_parser_emit_with_arg <S2SV_ModStart> } # line 3173 <S2SV_ModEnd> \"grammar.c\" break ; <S2SV_ModStart> : # line 1518 <S2SV_ModEnd> \"grammar.y\" { yr_parser_emit_with_arg <S2SV_ModStart> } # line 3184 <S2SV_ModEnd> \"grammar.c\" break ; <S2SV_ModStart> : # line 1535 <S2SV_ModEnd> \"grammar.y\" { yr_parser_emit_pushes_for_strings <S2SV_ModStart> } # line 3195 <S2SV_ModEnd> \"grammar.c\" break ; <S2SV_ModStart> : # line 1542 <S2SV_ModEnd> \"grammar.y\" { yr_parser_emit_pushes_for_strings <S2SV_ModStart> } # line 3206 <S2SV_ModEnd> \"grammar.c\" break ; <S2SV_ModStart> : # line 1554 <S2SV_ModEnd> \"grammar.y\" { yr_parser_emit_with_arg <S2SV_ModStart> } # line 3214 <S2SV_ModEnd> \"grammar.c\" break ; <S2SV_ModStart> : # line 1558 <S2SV_ModEnd> \"grammar.y\" { yr_parser_emit_with_arg <S2SV_ModStart> } # line 3222 <S2SV_ModEnd> \"grammar.c\" break ; <S2SV_ModStart> : # line 1566 <S2SV_ModEnd> \"grammar.y\" { ( <S2SV_ModStart> } # line 3230 <S2SV_ModEnd> \"grammar.c\" break ; <S2SV_ModStart> : # line 1570 <S2SV_ModEnd> \"grammar.y\" { compiler <S2SV_ModStart> } # line 3244 <S2SV_ModEnd> \"grammar.c\" break ; <S2SV_ModStart> : # line 1580 <S2SV_ModEnd> \"grammar.y\" { yywarning <S2SV_ModStart> } # line 3262 <S2SV_ModEnd> \"grammar.c\" break ; <S2SV_ModStart> : # line 1594 <S2SV_ModEnd> \"grammar.y\" { CHECK_TYPE <S2SV_ModStart> } # line 3282 <S2SV_ModEnd> \"grammar.c\" break ; <S2SV_ModStart> : # line 1610 <S2SV_ModEnd> \"grammar.y\" { compiler <S2SV_ModStart> } # line 3296 <S2SV_ModEnd> \"grammar.c\" break ; <S2SV_ModStart> : # line 1620 <S2SV_ModEnd> \"grammar.y\" { compiler <S2SV_ModStart> } # line 3309 <S2SV_ModEnd> \"grammar.c\" break ; <S2SV_ModStart> : # line 1629 <S2SV_ModEnd> \"grammar.y\" { SIZED_STRING <S2SV_ModStart> } # line 3338 <S2SV_ModEnd> \"grammar.c\" break ; <S2SV_ModStart> : # line 1654 <S2SV_ModEnd> \"grammar.y\" { compiler <S2SV_ModStart> } # line 3354 <S2SV_ModEnd> \"grammar.c\" break ; <S2SV_ModStart> : # line 1666 <S2SV_ModEnd> \"grammar.y\" { compiler <S2SV_ModStart> } # line 3370 <S2SV_ModEnd> \"grammar.c\" break ; <S2SV_ModStart> : # line 1678 <S2SV_ModEnd> \"grammar.y\" { compiler <S2SV_ModStart> } # line 3390 <S2SV_ModEnd> \"grammar.c\" break ; <S2SV_ModStart> : # line 1694 <S2SV_ModEnd> \"grammar.y\" { compiler <S2SV_ModStart> } # line 3406 <S2SV_ModEnd> \"grammar.c\" break ; <S2SV_ModStart> : # line 1706 <S2SV_ModEnd> \"grammar.y\" { compiler <S2SV_ModStart> } # line 3426 <S2SV_ModEnd> \"grammar.c\" break ; <S2SV_ModStart> : # line 1722 <S2SV_ModEnd> \"grammar.y\" { if <S2SV_ModStart> } # line 3475 <S2SV_ModEnd> \"grammar.c\" break ; <S2SV_ModStart> : # line 1767 <S2SV_ModEnd> \"grammar.y\" { CHECK_TYPE <S2SV_ModStart> } # line 3498 <S2SV_ModEnd> \"grammar.c\" break ; <S2SV_ModStart> : # line 1786 <S2SV_ModEnd> \"grammar.y\" { compiler <S2SV_ModStart> } # line 3520 <S2SV_ModEnd> \"grammar.c\" break ; <S2SV_ModStart> : # line 1804 <S2SV_ModEnd> \"grammar.y\" { compiler <S2SV_ModStart> } # line 3542 <S2SV_ModEnd> \"grammar.c\" break ; <S2SV_ModStart> : # line 1822 <S2SV_ModEnd> \"grammar.y\" { compiler <S2SV_ModStart> } # line 3564 <S2SV_ModEnd> \"grammar.c\" break ; <S2SV_ModStart> : # line 1840 <S2SV_ModEnd> \"grammar.y\" { compiler <S2SV_ModStart> } # line 3594 <S2SV_ModEnd> \"grammar.c\" break ; <S2SV_ModStart> : # line 1866 <S2SV_ModEnd> \"grammar.y\" { CHECK_TYPE <S2SV_ModStart> } # line 3616 <S2SV_ModEnd> \"grammar.c\" break ; <S2SV_ModStart> : # line 1884 <S2SV_ModEnd> \"grammar.y\" { CHECK_TYPE <S2SV_ModStart> } # line 3630 <S2SV_ModEnd> \"grammar.c\" break ; <S2SV_ModStart> : # line 1894 <S2SV_ModEnd> \"grammar.y\" { CHECK_TYPE <S2SV_ModStart> } # line 3644 <S2SV_ModEnd> \"grammar.c\" break ; <S2SV_ModStart> : # line 1904 <S2SV_ModEnd> \"grammar.y\" { CHECK_TYPE <S2SV_ModStart> } # line 3658 <S2SV_ModEnd> \"grammar.c\" break ; <S2SV_ModStart> : # line 1914 <S2SV_ModEnd> \"grammar.y\" { CHECK_TYPE <S2SV_ModStart> } # line 3672 <S2SV_ModEnd> \"grammar.c\" break ; <S2SV_ModStart> : # line 1924 <S2SV_ModEnd> \"grammar.y\" { CHECK_TYPE <S2SV_ModStart> } # line 3686 <S2SV_ModEnd> \"grammar.c\" break ; <S2SV_ModStart> : # line 1934 <S2SV_ModEnd> \"grammar.y\" { CHECK_TYPE <S2SV_ModStart> } # line 3700 <S2SV_ModEnd> \"grammar.c\" break ; <S2SV_ModStart> : # line 1944 <S2SV_ModEnd> \"grammar.y\" { ( <S2SV_ModStart> } # line 3708 <S2SV_ModEnd> \"grammar.c\" break ; <S2SV_ModStart> ; # line 3712 <S2SV_ModEnd> \"grammar.c\" default :\n",
      "source_code_length": 58626,
      "target_code_length": 9068,
      "vulnerability_patterns": {
        "buffer_overflow": 2,
        "integer_overflow": 16,
        "null_pointer": 266,
        "total": 284
      },
      "total_patterns": 284,
      "original_address": "https://github.com/VirusTotal/yara/commit/ab906da53ff2a68c6fd6d1fa73f2b7c7bf0bc636",
      "discovery_time": "2017-04-03T05:59Z",
      "project_commit_id": "VirusTotal@yara/ab906da53ff2a68c6fd6d1fa73f2b7c7bf0bc636",
      "extraction_time": "2025-08-31T15:41:49.185987",
      "label": 1,
      "vulnerability_type": "out-of-bounds_read",
      "difficulty_level": "advanced",
      "risk_factors": [
        "information_disclosure",
        "memory_corruption",
        "integer_overflow",
        "buffer_overflow"
      ],
      "attack_vectors": [
        "memory_manipulation",
        "malicious_input",
        "code_analysis",
        "buffer_overflow",
        "reverse_engineering",
        "fuzzing"
      ],
      "mitigation_strategies": [
        "safe_string_functions",
        "dynamic_analysis",
        "code_review",
        "static_analysis",
        "memory_safety_checks",
        "input_validation",
        "fuzzing",
        "bounds_checking",
        "secure_coding_practices"
      ],
      "code_differences": {
        "has_differences": true,
        "source_lines": 2,
        "target_lines": 2,
        "character_differences": 49558,
        "similarity_percentage": 3.4178610804851157
      },
      "vulnerability_location": {
        "vulnerability_present": true,
        "fix_applied": true,
        "code_changed": true,
        "estimated_lines_changed": 0
      }
    },
    {
      "cve_id": "CVE-2016-9557",
      "cwe_id": "CWE-190",
      "cwe_name": "Integer Overflow",
      "project": "mdadams",
      "severity": "critical",
      "weaponization_score": 8.0,
      "is_critical": true,
      "is_weaponizable": true,
      "is_high_priority_project": false,
      "vulnerable_code": "CWE-190 <S2SV_StartBug> void jas_seq2d_bindsub ( jas_matrix_t * s , jas_matrix_t * s1 , int xstart , <S2SV_EndBug> int ystart , int xend , int yend ) { jas_matrix_bindsub ( s , s1 , ystart - s1 -> ystart_ , xstart - s1 -> xstart_ , yend - s1 -> ystart_ - 1 , xend - s1 -> xstart_ - 1 ) ; }\n",
      "fixed_code": "<S2SV_ModStart> * s1 , jas_matind_t xstart , jas_matind_t ystart , jas_matind_t xend , jas_matind_t <S2SV_ModEnd> yend ) {\n",
      "source_code_length": 290,
      "target_code_length": 123,
      "vulnerability_patterns": {
        "use_after_free": 6,
        "integer_overflow": 10,
        "null_pointer": 148,
        "total": 164
      },
      "total_patterns": 164,
      "original_address": "https://github.com/mdadams/jasper/commit/d42b2388f7f8e0332c846675133acea151fc557a",
      "discovery_time": "2017-03-23T18:59Z",
      "project_commit_id": "mdadams@jasper/d42b2388f7f8e0332c846675133acea151fc557a",
      "extraction_time": "2025-08-31T15:41:49.186371",
      "label": 1,
      "vulnerability_type": "integer_overflow",
      "difficulty_level": "advanced",
      "risk_factors": [
        "information_disclosure",
        "memory_corruption",
        "integer_overflow",
        "use_after_free"
      ],
      "attack_vectors": [
        "fuzzing",
        "code_analysis",
        "reverse_engineering"
      ],
      "mitigation_strategies": [
        "dynamic_analysis",
        "static_analysis",
        "fuzzing",
        "code_review",
        "secure_coding_practices"
      ],
      "code_differences": {
        "has_differences": true,
        "source_lines": 2,
        "target_lines": 2,
        "character_differences": 167,
        "similarity_percentage": 31.03448275862069
      },
      "vulnerability_location": {
        "vulnerability_present": true,
        "fix_applied": true,
        "code_changed": true,
        "estimated_lines_changed": 0
      }
    },
    {
      "cve_id": "CVE-2016-5358",
      "cwe_id": "CWE-20",
      "cwe_name": "Improper Input Validation",
      "project": "wireshark",
      "severity": "critical",
      "weaponization_score": 8.0,
      "is_critical": true,
      "is_weaponizable": true,
      "is_high_priority_project": true,
      "vulnerable_code": "CWE-20 static void dissect_rpcap_packet ( tvbuff_t * tvb , packet_info * pinfo , proto_tree * top_tree , proto_tree * parent_tree , gint offset , proto_item * top_item ) { proto_tree * tree ; proto_item * ti ; nstime_t ts ; tvbuff_t * new_tvb ; guint caplen , len , frame_no ; <S2SV_StartBug> gint reported_length_remaining ; <S2SV_EndBug> ti = proto_tree_add_item ( parent_tree , hf_packet , tvb , offset , 20 , ENC_NA ) ; tree = proto_item_add_subtree ( ti , ett_packet ) ; ts . secs = tvb_get_ntohl ( tvb , offset ) ; ts . nsecs = tvb_get_ntohl ( tvb , offset + 4 ) * 1000 ; proto_tree_add_time ( tree , hf_timestamp , tvb , offset , 8 , & ts ) ; offset += 8 ; caplen = tvb_get_ntohl ( tvb , offset ) ; ti = proto_tree_add_item ( tree , hf_caplen , tvb , offset , 4 , ENC_BIG_ENDIAN ) ; offset += 4 ; len = tvb_get_ntohl ( tvb , offset ) ; proto_tree_add_item ( tree , hf_len , tvb , offset , 4 , ENC_BIG_ENDIAN ) ; offset += 4 ; frame_no = tvb_get_ntohl ( tvb , offset ) ; proto_tree_add_item ( tree , hf_npkt , tvb , offset , 4 , ENC_BIG_ENDIAN ) ; offset += 4 ; proto_item_append_text ( ti , \",<S2SV_blank>Frame<S2SV_blank>%u\" , frame_no ) ; proto_item_append_text ( top_item , \"<S2SV_blank>Frame<S2SV_blank>%u\" , frame_no ) ; reported_length_remaining = tvb_reported_length_remaining ( tvb , offset ) ; if ( caplen > ( guint ) reported_length_remaining ) { expert_add_info ( pinfo , ti , & ei_caplen_too_big ) ; return ; } new_tvb = tvb_new_subset ( tvb , offset , caplen , len ) ; if ( decode_content && linktype != WTAP_ENCAP_UNKNOWN ) { <S2SV_StartBug> dissector_try_uint ( wtap_encap_dissector_table , linktype , new_tvb , pinfo , top_tree ) ; <S2SV_EndBug> if ( ! info_added ) { col_prepend_fence_fstr ( pinfo -> cinfo , COL_PROTOCOL , \"R|\" ) ; col_prepend_fence_fstr ( pinfo -> cinfo , COL_INFO , \"Remote<S2SV_blank>|<S2SV_blank>\" ) ; info_added = TRUE ; register_frame_end_routine ( pinfo , rpcap_frame_end ) ; } } else { if ( linktype == WTAP_ENCAP_UNKNOWN ) { proto_item_append_text ( ti , \",<S2SV_blank>Unknown<S2SV_blank>link-layer<S2SV_blank>type\" ) ; } call_dissector ( data_handle , new_tvb , pinfo , top_tree ) ; } }\n",
      "fixed_code": "<S2SV_ModStart> ; gint reported_length_remaining ; struct eth_phdr eth ; void * phdr <S2SV_ModStart> WTAP_ENCAP_UNKNOWN ) { switch ( linktype ) { case WTAP_ENCAP_ETHERNET : eth . fcs_len = - 1 ; phdr = & eth ; break ; default : phdr = NULL ; break ; } dissector_try_uint_new <S2SV_ModEnd> ( wtap_encap_dissector_table , <S2SV_ModStart> pinfo , top_tree , TRUE , phdr\n",
      "source_code_length": 2139,
      "target_code_length": 367,
      "vulnerability_patterns": {
        "use_after_free": 4,
        "integer_overflow": 4,
        "null_pointer": 4,
        "total": 12
      },
      "total_patterns": 12,
      "original_address": "https://github.com/wireshark/wireshark/commit/2c13e97d656c1c0ac4d76eb9d307664aae0e0cf7",
      "discovery_time": "2016-08-07T16:59Z",
      "project_commit_id": "wireshark@wireshark/2c13e97d656c1c0ac4d76eb9d307664aae0e0cf7",
      "extraction_time": "2025-08-31T15:41:49.186394",
      "label": 1,
      "vulnerability_type": "improper_input_validation",
      "difficulty_level": "advanced",
      "risk_factors": [
        "critical_infrastructure",
        "use_after_free"
      ],
      "attack_vectors": [
        "fuzzing",
        "code_analysis",
        "reverse_engineering"
      ],
      "mitigation_strategies": [
        "dynamic_analysis",
        "static_analysis",
        "fuzzing",
        "code_review",
        "secure_coding_practices"
      ],
      "code_differences": {
        "has_differences": true,
        "source_lines": 2,
        "target_lines": 2,
        "character_differences": 1772,
        "similarity_percentage": 17.59259259259259
      },
      "vulnerability_location": {
        "vulnerability_present": true,
        "fix_applied": true,
        "code_changed": true,
        "estimated_lines_changed": 0
      }
    },
    {
      "cve_id": "CVE-2012-0044",
      "cwe_id": "CWE-190",
      "cwe_name": "Integer Overflow",
      "project": "torvalds",
      "severity": "critical",
      "weaponization_score": 8.0,
      "is_critical": true,
      "is_weaponizable": true,
      "is_high_priority_project": false,
      "vulnerable_code": "CWE-190 int drm_mode_dirtyfb_ioctl ( struct drm_device * dev , void * data , struct drm_file * file_priv ) { struct drm_clip_rect __user * clips_ptr ; struct drm_clip_rect * clips = NULL ; struct drm_mode_fb_dirty_cmd * r = data ; struct drm_mode_object * obj ; struct drm_framebuffer * fb ; unsigned flags ; int num_clips ; int ret = 0 ; if ( ! drm_core_check_feature ( dev , DRIVER_MODESET ) ) return - EINVAL ; mutex_lock ( & dev -> mode_config . mutex ) ; obj = drm_mode_object_find ( dev , r -> fb_id , DRM_MODE_OBJECT_FB ) ; if ( ! obj ) { DRM_ERROR ( \"invalid<S2SV_blank>framebuffer<S2SV_blank>id\\\\n\" ) ; ret = - EINVAL ; goto out_err1 ; } fb = obj_to_fb ( obj ) ; num_clips = r -> num_clips ; clips_ptr = ( struct drm_clip_rect * ) ( unsigned long ) r -> clips_ptr ; if ( ! num_clips != ! clips_ptr ) { ret = - EINVAL ; goto out_err1 ; } flags = DRM_MODE_FB_DIRTY_FLAGS & r -> flags ; if ( flags & DRM_MODE_FB_DIRTY_ANNOTATE_COPY && ( num_clips % 2 ) ) { ret = - EINVAL ; goto out_err1 ; } if ( num_clips && clips_ptr ) { <S2SV_StartBug> clips = kzalloc ( num_clips * sizeof ( * clips ) , GFP_KERNEL ) ; <S2SV_EndBug> if ( ! clips ) { ret = - ENOMEM ; goto out_err1 ; } ret = copy_from_user ( clips , clips_ptr , num_clips * sizeof ( * clips ) ) ; if ( ret ) { ret = - EFAULT ; goto out_err2 ; } } if ( fb -> funcs -> dirty ) { ret = fb -> funcs -> dirty ( fb , file_priv , flags , r -> color , clips , num_clips ) ; } else { ret = - ENOSYS ; goto out_err2 ; } out_err2 : kfree ( clips ) ; out_err1 : mutex_unlock ( & dev -> mode_config . mutex ) ; return ret ; }\n",
      "fixed_code": "<S2SV_ModStart> clips_ptr ) { if ( num_clips < 0 || num_clips > DRM_MODE_FB_DIRTY_MAX_CLIPS ) { ret = - EINVAL ; goto out_err1 ; }\n",
      "source_code_length": 1572,
      "target_code_length": 131,
      "vulnerability_patterns": {
        "use_after_free": 1,
        "null_pointer": 15,
        "total": 16
      },
      "total_patterns": 16,
      "original_address": "https://github.com/torvalds/linux/commit/a5cd335165e31db9dbab636fd29895d41da55dd2",
      "discovery_time": "2012-05-17T11:00Z",
      "project_commit_id": "torvalds@linux/a5cd335165e31db9dbab636fd29895d41da55dd2",
      "extraction_time": "2025-08-31T15:41:49.186431",
      "label": 1,
      "vulnerability_type": "integer_overflow",
      "difficulty_level": "advanced",
      "risk_factors": [
        "information_disclosure",
        "memory_corruption",
        "integer_overflow",
        "use_after_free"
      ],
      "attack_vectors": [
        "fuzzing",
        "code_analysis",
        "reverse_engineering"
      ],
      "mitigation_strategies": [
        "dynamic_analysis",
        "static_analysis",
        "fuzzing",
        "code_review",
        "secure_coding_practices"
      ],
      "code_differences": {
        "has_differences": true,
        "source_lines": 2,
        "target_lines": 2,
        "character_differences": 1441,
        "similarity_percentage": 17.857142857142858
      },
      "vulnerability_location": {
        "vulnerability_present": true,
        "fix_applied": true,
        "code_changed": true,
        "estimated_lines_changed": 0
      }
    },
    {
      "cve_id": "CVE-2017-3733",
      "cwe_id": "CWE-20",
      "cwe_name": "Improper Input Validation",
      "project": "openssl",
      "severity": "critical",
      "weaponization_score": 8.0,
      "is_critical": true,
      "is_weaponizable": true,
      "is_high_priority_project": true,
      "vulnerable_code": "CWE-20 int tls1_change_cipher_state ( SSL * s , int which ) { unsigned char * p , * mac_secret ; unsigned char tmp1 [ EVP_MAX_KEY_LENGTH ] ; unsigned char tmp2 [ EVP_MAX_KEY_LENGTH ] ; unsigned char iv1 [ EVP_MAX_IV_LENGTH * 2 ] ; unsigned char iv2 [ EVP_MAX_IV_LENGTH * 2 ] ; unsigned char * ms , * key , * iv ; EVP_CIPHER_CTX * dd ; const EVP_CIPHER * c ; # ifndef OPENSSL_NO_COMP const SSL_COMP * comp ; # endif const EVP_MD * m ; int mac_type ; int * mac_secret_size ; EVP_MD_CTX * mac_ctx ; EVP_PKEY * mac_key ; int n , i , j , k , cl ; int reuse_dd = 0 ; c = s -> s3 -> tmp . new_sym_enc ; m = s -> s3 -> tmp . new_hash ; mac_type = s -> s3 -> tmp . new_mac_pkey_type ; # ifndef OPENSSL_NO_COMP comp = s -> s3 -> tmp . new_compression ; # endif if ( which & SSL3_CC_READ ) { <S2SV_StartBug> if ( s -> s3 -> tmp . new_cipher -> algorithm2 & TLS1_STREAM_MAC ) <S2SV_EndBug> s -> mac_flags |= SSL_MAC_FLAG_READ_MAC_STREAM ; else s -> mac_flags &= ~ SSL_MAC_FLAG_READ_MAC_STREAM ; if ( s -> enc_read_ctx != NULL ) reuse_dd = 1 ; else if ( ( s -> enc_read_ctx = EVP_CIPHER_CTX_new ( ) ) == NULL ) goto err ; else EVP_CIPHER_CTX_reset ( s -> enc_read_ctx ) ; dd = s -> enc_read_ctx ; mac_ctx = ssl_replace_hash ( & s -> read_hash , NULL ) ; if ( mac_ctx == NULL ) goto err ; # ifndef OPENSSL_NO_COMP COMP_CTX_free ( s -> expand ) ; s -> expand = NULL ; if ( comp != NULL ) { s -> expand = COMP_CTX_new ( comp -> method ) ; if ( s -> expand == NULL ) { SSLerr ( SSL_F_TLS1_CHANGE_CIPHER_STATE , SSL_R_COMPRESSION_LIBRARY_ERROR ) ; goto err2 ; } } # endif if ( ! SSL_IS_DTLS ( s ) ) RECORD_LAYER_reset_read_sequence ( & s -> rlayer ) ; mac_secret = & ( s -> s3 -> read_mac_secret [ 0 ] ) ; mac_secret_size = & ( s -> s3 -> read_mac_secret_size ) ; <S2SV_StartBug> } else { <S2SV_EndBug> if ( s -> s3 -> tmp . new_cipher -> algorithm2 & TLS1_STREAM_MAC ) s -> mac_flags |= SSL_MAC_FLAG_WRITE_MAC_STREAM ; else s -> mac_flags &= ~ SSL_MAC_FLAG_WRITE_MAC_STREAM ; if ( s -> enc_write_ctx != NULL && ! SSL_IS_DTLS ( s ) ) reuse_dd = 1 ; else if ( ( s -> enc_write_ctx = EVP_CIPHER_CTX_new ( ) ) == NULL ) goto err ; dd = s -> enc_write_ctx ; if ( SSL_IS_DTLS ( s ) ) { mac_ctx = EVP_MD_CTX_new ( ) ; if ( mac_ctx == NULL ) goto err ; s -> write_hash = mac_ctx ; } else { mac_ctx = ssl_replace_hash ( & s -> write_hash , NULL ) ; if ( mac_ctx == NULL ) goto err ; } # ifndef OPENSSL_NO_COMP COMP_CTX_free ( s -> compress ) ; s -> compress = NULL ; if ( comp != NULL ) { s -> compress = COMP_CTX_new ( comp -> method ) ; if ( s -> compress == NULL ) { SSLerr ( SSL_F_TLS1_CHANGE_CIPHER_STATE , SSL_R_COMPRESSION_LIBRARY_ERROR ) ; goto err2 ; } } # endif if ( ! SSL_IS_DTLS ( s ) ) RECORD_LAYER_reset_write_sequence ( & s -> rlayer ) ; mac_secret = & ( s -> s3 -> write_mac_secret [ 0 ] ) ; mac_secret_size = & ( s -> s3 -> write_mac_secret_size ) ; } if ( reuse_dd ) EVP_CIPHER_CTX_reset ( dd ) ; p = s -> s3 -> tmp . key_block ; i = * mac_secret_size = s -> s3 -> tmp . new_mac_secret_size ; cl = EVP_CIPHER_key_length ( c ) ; j = cl ; if ( EVP_CIPHER_mode ( c ) == EVP_CIPH_GCM_MODE ) k = EVP_GCM_TLS_FIXED_IV_LEN ; else if ( EVP_CIPHER_mode ( c ) == EVP_CIPH_CCM_MODE ) k = EVP_CCM_TLS_FIXED_IV_LEN ; else k = EVP_CIPHER_iv_length ( c ) ; if ( ( which == SSL3_CHANGE_CIPHER_CLIENT_WRITE ) || ( which == SSL3_CHANGE_CIPHER_SERVER_READ ) ) { ms = & ( p [ 0 ] ) ; n = i + i ; key = & ( p [ n ] ) ; n += j + j ; iv = & ( p [ n ] ) ; n += k + k ; } else { n = i ; ms = & ( p [ n ] ) ; n += i + j ; key = & ( p [ n ] ) ; n += j + k ; iv = & ( p [ n ] ) ; n += k ; } if ( n > s -> s3 -> tmp . key_block_length ) { SSLerr ( SSL_F_TLS1_CHANGE_CIPHER_STATE , ERR_R_INTERNAL_ERROR ) ; goto err2 ; } memcpy ( mac_secret , ms , i ) ; if ( ! ( EVP_CIPHER_flags ( c ) & EVP_CIPH_FLAG_AEAD_CIPHER ) ) { mac_key = EVP_PKEY_new_mac_key ( mac_type , NULL , mac_secret , * mac_secret_size ) ; if ( mac_key == NULL || EVP_DigestSignInit ( mac_ctx , NULL , m , NULL , mac_key ) <= 0 ) { EVP_PKEY_free ( mac_key ) ; SSLerr ( SSL_F_TLS1_CHANGE_CIPHER_STATE , ERR_R_INTERNAL_ERROR ) ; goto err2 ; } EVP_PKEY_free ( mac_key ) ; } # ifdef SSL_DEBUG printf ( \"which<S2SV_blank>=<S2SV_blank>%04X\\\\nmac<S2SV_blank>key=\" , which ) ; { int z ; for ( z = 0 ; z < i ; z ++ ) printf ( \"%02X%c\" , ms [ z ] , ( ( z + 1 ) % 16 ) ? '<S2SV_blank>' : '\\\\n' ) ; } # endif if ( EVP_CIPHER_mode ( c ) == EVP_CIPH_GCM_MODE ) { if ( ! EVP_CipherInit_ex ( dd , c , NULL , key , NULL , ( which & SSL3_CC_WRITE ) ) || ! EVP_CIPHER_CTX_ctrl ( dd , EVP_CTRL_GCM_SET_IV_FIXED , k , iv ) ) { SSLerr ( SSL_F_TLS1_CHANGE_CIPHER_STATE , ERR_R_INTERNAL_ERROR ) ; goto err2 ; } } else if ( EVP_CIPHER_mode ( c ) == EVP_CIPH_CCM_MODE ) { int taglen ; if ( s -> s3 -> tmp . new_cipher -> algorithm_enc & ( SSL_AES128CCM8 | SSL_AES256CCM8 ) ) taglen = 8 ; else taglen = 16 ; if ( ! EVP_CipherInit_ex ( dd , c , NULL , NULL , NULL , ( which & SSL3_CC_WRITE ) ) || ! EVP_CIPHER_CTX_ctrl ( dd , EVP_CTRL_AEAD_SET_IVLEN , 12 , NULL ) || ! EVP_CIPHER_CTX_ctrl ( dd , EVP_CTRL_AEAD_SET_TAG , taglen , NULL ) || ! EVP_CIPHER_CTX_ctrl ( dd , EVP_CTRL_CCM_SET_IV_FIXED , k , iv ) || ! EVP_CipherInit_ex ( dd , NULL , NULL , key , NULL , - 1 ) ) { SSLerr ( SSL_F_TLS1_CHANGE_CIPHER_STATE , ERR_R_INTERNAL_ERROR ) ; goto err2 ; } } else { if ( ! EVP_CipherInit_ex ( dd , c , NULL , key , iv , ( which & SSL3_CC_WRITE ) ) ) { SSLerr ( SSL_F_TLS1_CHANGE_CIPHER_STATE , ERR_R_INTERNAL_ERROR ) ; goto err2 ; } } if ( ( EVP_CIPHER_flags ( c ) & EVP_CIPH_FLAG_AEAD_CIPHER ) && * mac_secret_size && ! EVP_CIPHER_CTX_ctrl ( dd , EVP_CTRL_AEAD_SET_MAC_KEY , * mac_secret_size , mac_secret ) ) { SSLerr ( SSL_F_TLS1_CHANGE_CIPHER_STATE , ERR_R_INTERNAL_ERROR ) ; goto err2 ; } # ifdef OPENSSL_SSL_TRACE_CRYPTO if ( s -> msg_callback ) { int wh = which & SSL3_CC_WRITE ? TLS1_RT_CRYPTO_WRITE : 0 ; if ( * mac_secret_size ) s -> msg_callback ( 2 , s -> version , wh | TLS1_RT_CRYPTO_MAC , mac_secret , * mac_secret_size , s , s -> msg_callback_arg ) ; if ( c -> key_len ) s -> msg_callback ( 2 , s -> version , wh | TLS1_RT_CRYPTO_KEY , key , c -> key_len , s , s -> msg_callback_arg ) ; if ( k ) { if ( EVP_CIPHER_mode ( c ) == EVP_CIPH_GCM_MODE ) wh |= TLS1_RT_CRYPTO_FIXED_IV ; else wh |= TLS1_RT_CRYPTO_IV ; s -> msg_callback ( 2 , s -> version , wh , iv , k , s , s -> msg_callback_arg ) ; } } # endif # ifdef SSL_DEBUG printf ( \"which<S2SV_blank>=<S2SV_blank>%04X\\\\nkey=\" , which ) ; { int z ; for ( z = 0 ; z < EVP_CIPHER_key_length ( c ) ; z ++ ) printf ( \"%02X%c\" , key [ z ] , ( ( z + 1 ) % 16 ) ? '<S2SV_blank>' : '\\\\n' ) ; } printf ( \"\\\\niv=\" ) ; { int z ; for ( z = 0 ; z < k ; z ++ ) printf ( \"%02X%c\" , iv [ z ] , ( ( z + 1 ) % 16 ) ? '<S2SV_blank>' : '\\\\n' ) ; } printf ( \"\\\\n\" ) ; # endif OPENSSL_cleanse ( tmp1 , sizeof ( tmp1 ) ) ; OPENSSL_cleanse ( tmp2 , sizeof ( tmp1 ) ) ; OPENSSL_cleanse ( iv1 , sizeof ( iv1 ) ) ; OPENSSL_cleanse ( iv2 , sizeof ( iv2 ) ) ; return ( 1 ) ; err : SSLerr ( SSL_F_TLS1_CHANGE_CIPHER_STATE , ERR_R_MALLOC_FAILURE ) ; err2 : OPENSSL_cleanse ( tmp1 , sizeof ( tmp1 ) ) ; OPENSSL_cleanse ( tmp2 , sizeof ( tmp1 ) ) ; OPENSSL_cleanse ( iv1 , sizeof ( iv1 ) ) ; OPENSSL_cleanse ( iv2 , sizeof ( iv2 ) ) ; return ( 0 ) ; }\n",
      "fixed_code": "<S2SV_ModStart> ( s -> tlsext_use_etm ) s -> s3 -> flags |= TLS1_FLAGS_ENCRYPT_THEN_MAC_READ ; else s -> s3 -> flags &= ~ TLS1_FLAGS_ENCRYPT_THEN_MAC_READ ; if ( s -> <S2SV_ModStart> } else { if ( s -> tlsext_use_etm ) s -> s3 -> flags |= TLS1_FLAGS_ENCRYPT_THEN_MAC_WRITE ; else s -> s3 -> flags &= ~ TLS1_FLAGS_ENCRYPT_THEN_MAC_WRITE ;\n",
      "source_code_length": 7181,
      "target_code_length": 338,
      "vulnerability_patterns": {
        "buffer_overflow": 1,
        "integer_overflow": 14,
        "null_pointer": 53,
        "total": 68
      },
      "total_patterns": 68,
      "original_address": "https://github.com/openssl/openssl/commit/4ad93618d26a3ea23d36ad5498ff4f59eff3a4d2",
      "discovery_time": "2017-05-04T19:29Z",
      "project_commit_id": "openssl@openssl/4ad93618d26a3ea23d36ad5498ff4f59eff3a4d2",
      "extraction_time": "2025-08-31T15:41:49.186453",
      "label": 1,
      "vulnerability_type": "improper_input_validation",
      "difficulty_level": "advanced",
      "risk_factors": [
        "critical_infrastructure",
        "buffer_overflow"
      ],
      "attack_vectors": [
        "fuzzing",
        "code_analysis",
        "reverse_engineering"
      ],
      "mitigation_strategies": [
        "dynamic_analysis",
        "static_analysis",
        "fuzzing",
        "code_review",
        "secure_coding_practices"
      ],
      "code_differences": {
        "has_differences": true,
        "source_lines": 2,
        "target_lines": 2,
        "character_differences": 6843,
        "similarity_percentage": 6.842105263157896
      },
      "vulnerability_location": {
        "vulnerability_present": true,
        "fix_applied": true,
        "code_changed": true,
        "estimated_lines_changed": 0
      }
    },
    {
      "cve_id": "CVE-2013-7015",
      "cwe_id": "CWE-20",
      "cwe_name": "Improper Input Validation",
      "project": "FFmpeg",
      "severity": "critical",
      "weaponization_score": 8.0,
      "is_critical": true,
      "is_weaponizable": true,
      "is_high_priority_project": true,
      "vulnerable_code": "CWE-20 static int flashsv_decode_frame ( AVCodecContext * avctx , void * data , int * got_frame , AVPacket * avpkt ) { int buf_size = avpkt -> size ; FlashSVContext * s = avctx -> priv_data ; int h_blocks , v_blocks , h_part , v_part , i , j , ret ; GetBitContext gb ; int last_blockwidth = s -> block_width ; int last_blockheight = s -> block_height ; if ( buf_size == 0 ) return 0 ; if ( buf_size < 4 ) return - 1 ; init_get_bits ( & gb , avpkt -> data , buf_size * 8 ) ; s -> block_width = 16 * ( get_bits ( & gb , 4 ) + 1 ) ; s -> image_width = get_bits ( & gb , 12 ) ; s -> block_height = 16 * ( get_bits ( & gb , 4 ) + 1 ) ; s -> image_height = get_bits ( & gb , 12 ) ; if ( last_blockwidth != s -> block_width || last_blockheight != s -> block_height ) av_freep ( & s -> blocks ) ; if ( s -> ver == 2 ) { skip_bits ( & gb , 6 ) ; if ( get_bits1 ( & gb ) ) { avpriv_request_sample ( avctx , \"iframe\" ) ; return AVERROR_PATCHWELCOME ; } if ( get_bits1 ( & gb ) ) { avpriv_request_sample ( avctx , \"Custom<S2SV_blank>palette\" ) ; return AVERROR_PATCHWELCOME ; } } h_blocks = s -> image_width / s -> block_width ; h_part = s -> image_width % s -> block_width ; v_blocks = s -> image_height / s -> block_height ; v_part = s -> image_height % s -> block_height ; if ( s -> block_size < s -> block_width * s -> block_height ) { int tmpblock_size = 3 * s -> block_width * s -> block_height ; s -> tmpblock = av_realloc ( s -> tmpblock , tmpblock_size ) ; if ( ! s -> tmpblock ) { av_log ( avctx , AV_LOG_ERROR , \"Can\\'t<S2SV_blank>allocate<S2SV_blank>decompression<S2SV_blank>buffer.\\\\n\" ) ; return AVERROR ( ENOMEM ) ; } if ( s -> ver == 2 ) { s -> deflate_block_size = calc_deflate_block_size ( tmpblock_size ) ; if ( s -> deflate_block_size <= 0 ) { av_log ( avctx , AV_LOG_ERROR , \"Can\\'t<S2SV_blank>determine<S2SV_blank>deflate<S2SV_blank>buffer<S2SV_blank>size.\\\\n\" ) ; return - 1 ; } s -> deflate_block = av_realloc ( s -> deflate_block , s -> deflate_block_size ) ; if ( ! s -> deflate_block ) { av_log ( avctx , AV_LOG_ERROR , \"Can\\'t<S2SV_blank>allocate<S2SV_blank>deflate<S2SV_blank>buffer.\\\\n\" ) ; return AVERROR ( ENOMEM ) ; } } } s -> block_size = s -> block_width * s -> block_height ; if ( avctx -> width == 0 && avctx -> height == 0 ) { avcodec_set_dimensions ( avctx , s -> image_width , s -> image_height ) ; } if ( avctx -> width != s -> image_width || avctx -> height != s -> image_height ) { av_log ( avctx , AV_LOG_ERROR , \"Frame<S2SV_blank>width<S2SV_blank>or<S2SV_blank>height<S2SV_blank>differs<S2SV_blank>from<S2SV_blank>first<S2SV_blank>frame!\\\\n\" ) ; av_log ( avctx , AV_LOG_ERROR , \"fh<S2SV_blank>=<S2SV_blank>%d,<S2SV_blank>fv<S2SV_blank>%d<S2SV_blank><S2SV_blank>vs<S2SV_blank><S2SV_blank>ch<S2SV_blank>=<S2SV_blank>%d,<S2SV_blank>cv<S2SV_blank>=<S2SV_blank>%d\\\\n\" , avctx -> height , avctx -> width , s -> image_height , s -> image_width ) ; return AVERROR_INVALIDDATA ; } s -> is_keyframe = ( avpkt -> flags & AV_PKT_FLAG_KEY ) && ( s -> ver == 2 ) ; if ( s -> is_keyframe ) { s -> keyframedata = av_realloc ( s -> keyframedata , avpkt -> size ) ; memcpy ( s -> keyframedata , avpkt -> data , avpkt -> size ) ; } if ( s -> ver == 2 && ! s -> blocks ) s -> blocks = av_mallocz ( ( v_blocks + ! ! v_part ) * ( h_blocks + ! ! h_part ) * sizeof ( s -> blocks [ 0 ] ) ) ; av_dlog ( avctx , \"image:<S2SV_blank>%dx%d<S2SV_blank>block:<S2SV_blank>%dx%d<S2SV_blank>num:<S2SV_blank>%dx%d<S2SV_blank>part:<S2SV_blank>%dx%d\\\\n\" , s -> image_width , s -> image_height , s -> block_width , s -> block_height , h_blocks , v_blocks , h_part , v_part ) ; if ( ( ret = ff_reget_buffer ( avctx , & s -> frame ) ) < 0 ) return ret ; for ( j = 0 ; j < v_blocks + ( v_part ? 1 : 0 ) ; j ++ ) { int y_pos = j * s -> block_height ; int cur_blk_height = ( j < v_blocks ) ? s -> block_height : v_part ; for ( i = 0 ; i < h_blocks + ( h_part ? 1 : 0 ) ; i ++ ) { int x_pos = i * s -> block_width ; int cur_blk_width = ( i < h_blocks ) ? s -> block_width : h_part ; int has_diff = 0 ; int size = get_bits ( & gb , 16 ) ; s -> color_depth = 0 ; s -> zlibprime_curr = 0 ; s -> zlibprime_prev = 0 ; s -> diff_start = 0 ; s -> diff_height = cur_blk_height ; if ( 8 * size > get_bits_left ( & gb ) ) { av_frame_unref ( & s -> frame ) ; return AVERROR_INVALIDDATA ; } if ( s -> ver == 2 && size ) { skip_bits ( & gb , 3 ) ; s -> color_depth = get_bits ( & gb , 2 ) ; has_diff = get_bits1 ( & gb ) ; s -> zlibprime_curr = get_bits1 ( & gb ) ; s -> zlibprime_prev = get_bits1 ( & gb ) ; if ( s -> color_depth != 0 && s -> color_depth != 2 ) { av_log ( avctx , AV_LOG_ERROR , \"%dx%d<S2SV_blank>invalid<S2SV_blank>color<S2SV_blank>depth<S2SV_blank>%d\\\\n\" , i , j , s -> color_depth ) ; return AVERROR_INVALIDDATA ; } if ( has_diff ) { if ( ! s -> keyframe ) { av_log ( avctx , AV_LOG_ERROR , \"inter<S2SV_blank>frame<S2SV_blank>without<S2SV_blank>keyframe\\\\n\" ) ; return AVERROR_INVALIDDATA ; } s -> diff_start = get_bits ( & gb , 8 ) ; s -> diff_height = get_bits ( & gb , 8 ) ; <S2SV_StartBug> av_log ( avctx , AV_LOG_DEBUG , <S2SV_EndBug> \"%dx%d<S2SV_blank>diff<S2SV_blank>start<S2SV_blank>%d<S2SV_blank>height<S2SV_blank>%d\\\\n\" , i , j , s -> diff_start , s -> diff_height ) ; size -= 2 ; } if ( s -> zlibprime_prev ) av_log ( avctx , AV_LOG_DEBUG , \"%dx%d<S2SV_blank>zlibprime_prev\\\\n\" , i , j ) ; if ( s -> zlibprime_curr ) { int col = get_bits ( & gb , 8 ) ; int row = get_bits ( & gb , 8 ) ; av_log ( avctx , AV_LOG_DEBUG , \"%dx%d<S2SV_blank>zlibprime_curr<S2SV_blank>%dx%d\\\\n\" , i , j , col , row ) ; size -= 2 ; avpriv_request_sample ( avctx , \"zlibprime_curr\" ) ; return AVERROR_PATCHWELCOME ; } if ( ! s -> blocks && ( s -> zlibprime_curr || s -> zlibprime_prev ) ) { av_log ( avctx , AV_LOG_ERROR , \"no<S2SV_blank>data<S2SV_blank>available<S2SV_blank>for<S2SV_blank>zlib<S2SV_blank>\" \"priming\\\\n\" ) ; return AVERROR_INVALIDDATA ; } size -- ; } if ( has_diff ) { int k ; int off = ( s -> image_height - y_pos - 1 ) * s -> frame . linesize [ 0 ] ; for ( k = 0 ; k < cur_blk_height ; k ++ ) memcpy ( s -> frame . data [ 0 ] + off - k * s -> frame . linesize [ 0 ] + x_pos * 3 , s -> keyframe + off - k * s -> frame . linesize [ 0 ] + x_pos * 3 , cur_blk_width * 3 ) ; } if ( size ) { if ( flashsv_decode_block ( avctx , avpkt , & gb , size , cur_blk_width , cur_blk_height , x_pos , y_pos , i + j * ( h_blocks + ! ! h_part ) ) ) av_log ( avctx , AV_LOG_ERROR , \"error<S2SV_blank>in<S2SV_blank>decompression<S2SV_blank>of<S2SV_blank>block<S2SV_blank>%dx%d\\\\n\" , i , j ) ; } } } if ( s -> is_keyframe && s -> ver == 2 ) { if ( ! s -> keyframe ) { s -> keyframe = av_malloc ( s -> frame . linesize [ 0 ] * avctx -> height ) ; if ( ! s -> keyframe ) { av_log ( avctx , AV_LOG_ERROR , \"Cannot<S2SV_blank>allocate<S2SV_blank>image<S2SV_blank>data\\\\n\" ) ; return AVERROR ( ENOMEM ) ; } } memcpy ( s -> keyframe , s -> frame . data [ 0 ] , s -> frame . linesize [ 0 ] * avctx -> height ) ; } if ( ( ret = av_frame_ref ( data , & s -> frame ) ) < 0 ) return ret ; * got_frame = 1 ; if ( ( get_bits_count ( & gb ) / 8 ) != buf_size ) av_log ( avctx , AV_LOG_ERROR , \"buffer<S2SV_blank>not<S2SV_blank>fully<S2SV_blank>consumed<S2SV_blank>(%d<S2SV_blank>!=<S2SV_blank>%d)\\\\n\" , buf_size , ( get_bits_count ( & gb ) / 8 ) ) ; return buf_size ; }\n",
      "fixed_code": "<S2SV_ModStart> 8 ) ; if ( s -> diff_start + s -> diff_height > cur_blk_height ) { av_log ( avctx , AV_LOG_ERROR , \"Block<S2SV_blank>parameters<S2SV_blank>invalid\\\\n\" ) ; return AVERROR_INVALIDDATA ; }\n",
      "source_code_length": 7237,
      "target_code_length": 202,
      "vulnerability_patterns": {
        "buffer_overflow": 3,
        "integer_overflow": 6,
        "null_pointer": 115,
        "total": 124
      },
      "total_patterns": 124,
      "original_address": "https://github.com/FFmpeg/FFmpeg/commit/880c73cd76109697447fbfbaa8e5ee5683309446",
      "discovery_time": "2013-12-09T16:36Z",
      "project_commit_id": "FFmpeg@FFmpeg/880c73cd76109697447fbfbaa8e5ee5683309446",
      "extraction_time": "2025-08-31T15:41:49.186518",
      "label": 1,
      "vulnerability_type": "improper_input_validation",
      "difficulty_level": "advanced",
      "risk_factors": [
        "critical_infrastructure",
        "buffer_overflow"
      ],
      "attack_vectors": [
        "fuzzing",
        "code_analysis",
        "reverse_engineering"
      ],
      "mitigation_strategies": [
        "dynamic_analysis",
        "static_analysis",
        "fuzzing",
        "code_review",
        "secure_coding_practices"
      ],
      "code_differences": {
        "has_differences": true,
        "source_lines": 2,
        "target_lines": 2,
        "character_differences": 7035,
        "similarity_percentage": 13.071895424836603
      },
      "vulnerability_location": {
        "vulnerability_present": true,
        "fix_applied": true,
        "code_changed": true,
        "estimated_lines_changed": 0
      }
    },
    {
      "cve_id": "CVE-2017-12894",
      "cwe_id": "CWE-125",
      "cwe_name": "Out-of-bounds Read",
      "project": "the-tcpdump-group",
      "severity": "critical",
      "weaponization_score": 8.0,
      "is_critical": true,
      "is_weaponizable": true,
      "is_high_priority_project": false,
      "vulnerable_code": "CWE-125 const char * le64addr_string ( netdissect_options * ndo , const u_char * ep ) { const unsigned int len = 8 ; register u_int i ; register char * cp ; <S2SV_StartBug> register struct enamemem * tp ; <S2SV_EndBug> char buf [ BUFSIZE ] ; tp = lookup_bytestring ( ndo , ep , len ) ; <S2SV_StartBug> if ( tp -> e_name ) <S2SV_EndBug> <S2SV_StartBug> return ( tp -> e_name ) ; <S2SV_EndBug> cp = buf ; for ( i = len ; i > 0 ; -- i ) { * cp ++ = hex [ * ( ep + i - 1 ) >> 4 ] ; * cp ++ = hex [ * ( ep + i - 1 ) & 0xf ] ; * cp ++ = ':' ; } cp -- ; * cp = '\\\\0' ; <S2SV_StartBug> tp -> e_name = strdup ( buf ) ; <S2SV_EndBug> <S2SV_StartBug> if ( tp -> e_name == NULL ) <S2SV_EndBug> ( * ndo -> ndo_error ) ( ndo , \"le64addr_string:<S2SV_blank>strdup(buf)\" ) ; <S2SV_StartBug> return ( tp -> e_name ) ; <S2SV_EndBug> }\n",
      "fixed_code": "<S2SV_ModStart> ; register struct bsnamemem <S2SV_ModEnd> * tp ; <S2SV_ModStart> ( tp -> bs_name <S2SV_ModEnd> ) return ( <S2SV_ModStart> ( tp -> bs_name <S2SV_ModEnd> ) ; cp <S2SV_ModStart> ; tp -> bs_name <S2SV_ModEnd> = strdup ( <S2SV_ModStart> ( tp -> bs_name <S2SV_ModEnd> == NULL ) <S2SV_ModStart> ( tp -> bs_name <S2SV_ModEnd> ) ; }\n",
      "source_code_length": 817,
      "target_code_length": 340,
      "vulnerability_patterns": {
        "use_after_free": 1,
        "integer_overflow": 8,
        "null_pointer": 6,
        "memory_leak": 1,
        "total": 16
      },
      "total_patterns": 16,
      "original_address": "https://github.com/the-tcpdump-group/tcpdump/commit/730fc35968c5433b9e2a829779057f4f9495dc51",
      "discovery_time": "2017-09-14T06:29Z",
      "project_commit_id": "the-tcpdump-group@tcpdump/730fc35968c5433b9e2a829779057f4f9495dc51",
      "extraction_time": "2025-08-31T15:41:49.186576",
      "label": 1,
      "vulnerability_type": "out-of-bounds_read",
      "difficulty_level": "advanced",
      "risk_factors": [
        "information_disclosure",
        "memory_corruption",
        "integer_overflow",
        "use_after_free"
      ],
      "attack_vectors": [
        "memory_manipulation",
        "malicious_input",
        "code_analysis",
        "buffer_overflow",
        "reverse_engineering",
        "fuzzing"
      ],
      "mitigation_strategies": [
        "safe_string_functions",
        "dynamic_analysis",
        "code_review",
        "static_analysis",
        "memory_safety_checks",
        "input_validation",
        "fuzzing",
        "bounds_checking",
        "secure_coding_practices"
      ],
      "code_differences": {
        "has_differences": true,
        "source_lines": 2,
        "target_lines": 2,
        "character_differences": 477,
        "similarity_percentage": 24.193548387096776
      },
      "vulnerability_location": {
        "vulnerability_present": true,
        "fix_applied": true,
        "code_changed": true,
        "estimated_lines_changed": 0
      }
    },
    {
      "cve_id": "CVE-2018-16790",
      "cwe_id": "CWE-125",
      "cwe_name": "Out-of-bounds Read",
      "project": "mongodb",
      "severity": "critical",
      "weaponization_score": 8.0,
      "is_critical": true,
      "is_weaponizable": true,
      "is_high_priority_project": false,
      "vulnerable_code": "CWE-125 static bool _bson_iter_next_internal ( bson_iter_t * iter , uint32_t next_keylen , const char * * key , uint32_t * bson_type , bool * unsupported ) { const uint8_t * data ; uint32_t o ; unsigned int len ; BSON_ASSERT ( iter ) ; * unsupported = false ; if ( ! iter -> raw ) { * key = NULL ; * bson_type = BSON_TYPE_EOD ; return false ; } data = iter -> raw ; len = iter -> len ; iter -> off = iter -> next_off ; iter -> type = iter -> off ; iter -> key = iter -> off + 1 ; iter -> d1 = 0 ; iter -> d2 = 0 ; iter -> d3 = 0 ; iter -> d4 = 0 ; if ( next_keylen == 0 ) { for ( o = iter -> key ; o < len ; o ++ ) { if ( ! data [ o ] ) { iter -> d1 = ++ o ; goto fill_data_fields ; } } } else { o = iter -> key + next_keylen + 1 ; iter -> d1 = o ; goto fill_data_fields ; } goto mark_invalid ; fill_data_fields : * key = bson_iter_key_unsafe ( iter ) ; * bson_type = ITER_TYPE ( iter ) ; switch ( * bson_type ) { case BSON_TYPE_DATE_TIME : case BSON_TYPE_DOUBLE : case BSON_TYPE_INT64 : case BSON_TYPE_TIMESTAMP : iter -> next_off = o + 8 ; break ; case BSON_TYPE_CODE : case BSON_TYPE_SYMBOL : case BSON_TYPE_UTF8 : { uint32_t l ; if ( ( o + 4 ) >= len ) { iter -> err_off = o ; goto mark_invalid ; } iter -> d2 = o + 4 ; memcpy ( & l , iter -> raw + iter -> d1 , sizeof ( l ) ) ; l = BSON_UINT32_FROM_LE ( l ) ; if ( l > ( len - ( o + 4 ) ) ) { iter -> err_off = o ; goto mark_invalid ; } iter -> next_off = o + 4 + l ; if ( BSON_UNLIKELY ( ( l == 0 ) || ( iter -> next_off >= len ) ) ) { iter -> err_off = o ; goto mark_invalid ; } if ( BSON_UNLIKELY ( ( iter -> raw + iter -> d2 ) [ l - 1 ] != '\\\\0' ) ) { iter -> err_off = o + 4 + l - 1 ; goto mark_invalid ; } } break ; case BSON_TYPE_BINARY : { bson_subtype_t subtype ; uint32_t l ; if ( o >= ( len - 4 ) ) { iter -> err_off = o ; goto mark_invalid ; } iter -> d2 = o + 4 ; iter -> d3 = o + 5 ; memcpy ( & l , iter -> raw + iter -> d1 , sizeof ( l ) ) ; l = BSON_UINT32_FROM_LE ( l ) ; <S2SV_StartBug> if ( l >= ( len - o ) ) { <S2SV_EndBug> iter -> err_off = o ; goto mark_invalid ; } subtype = * ( iter -> raw + iter -> d2 ) ; if ( subtype == BSON_SUBTYPE_BINARY_DEPRECATED ) { int32_t binary_len ; if ( l < 4 ) { iter -> err_off = o ; goto mark_invalid ; } memcpy ( & binary_len , ( iter -> raw + iter -> d3 ) , sizeof ( binary_len ) ) ; binary_len = BSON_UINT32_FROM_LE ( binary_len ) ; if ( binary_len + 4 != l ) { iter -> err_off = iter -> d3 ; goto mark_invalid ; } } iter -> next_off = o + 5 + l ; } break ; case BSON_TYPE_ARRAY : case BSON_TYPE_DOCUMENT : { uint32_t l ; if ( o >= ( len - 4 ) ) { iter -> err_off = o ; goto mark_invalid ; } memcpy ( & l , iter -> raw + iter -> d1 , sizeof ( l ) ) ; l = BSON_UINT32_FROM_LE ( l ) ; if ( ( l > len ) || ( l > ( len - o ) ) ) { iter -> err_off = o ; goto mark_invalid ; } iter -> next_off = o + l ; } break ; case BSON_TYPE_OID : iter -> next_off = o + 12 ; break ; case BSON_TYPE_BOOL : { char val ; if ( iter -> d1 >= len ) { iter -> err_off = o ; goto mark_invalid ; } memcpy ( & val , iter -> raw + iter -> d1 , 1 ) ; if ( val != 0x00 && val != 0x01 ) { iter -> err_off = o ; goto mark_invalid ; } iter -> next_off = o + 1 ; } break ; case BSON_TYPE_REGEX : { bool eor = false ; bool eoo = false ; for ( ; o < len ; o ++ ) { if ( ! data [ o ] ) { iter -> d2 = ++ o ; eor = true ; break ; } } if ( ! eor ) { iter -> err_off = iter -> next_off ; goto mark_invalid ; } for ( ; o < len ; o ++ ) { if ( ! data [ o ] ) { eoo = true ; break ; } } if ( ! eoo ) { iter -> err_off = iter -> next_off ; goto mark_invalid ; } iter -> next_off = o + 1 ; } break ; case BSON_TYPE_DBPOINTER : { uint32_t l ; if ( o >= ( len - 4 ) ) { iter -> err_off = o ; goto mark_invalid ; } iter -> d2 = o + 4 ; memcpy ( & l , iter -> raw + iter -> d1 , sizeof ( l ) ) ; l = BSON_UINT32_FROM_LE ( l ) ; if ( l == 0 || l > ( len - o - 4 ) ) { iter -> err_off = o ; goto mark_invalid ; } if ( * ( iter -> raw + o + l + 3 ) ) { iter -> err_off = o + l + 3 ; goto mark_invalid ; } iter -> d3 = o + 4 + l ; iter -> next_off = o + 4 + l + 12 ; } break ; case BSON_TYPE_CODEWSCOPE : { uint32_t l ; uint32_t doclen ; if ( ( len < 19 ) || ( o >= ( len - 14 ) ) ) { iter -> err_off = o ; goto mark_invalid ; } iter -> d2 = o + 4 ; iter -> d3 = o + 8 ; memcpy ( & l , iter -> raw + iter -> d1 , sizeof ( l ) ) ; l = BSON_UINT32_FROM_LE ( l ) ; if ( ( l < 14 ) || ( l >= ( len - o ) ) ) { iter -> err_off = o ; goto mark_invalid ; } iter -> next_off = o + l ; if ( iter -> next_off >= len ) { iter -> err_off = o ; goto mark_invalid ; } memcpy ( & l , iter -> raw + iter -> d2 , sizeof ( l ) ) ; l = BSON_UINT32_FROM_LE ( l ) ; if ( l == 0 || l >= ( len - o - 4 - 4 ) ) { iter -> err_off = o ; goto mark_invalid ; } if ( ( o + 4 + 4 + l + 4 ) >= iter -> next_off ) { iter -> err_off = o + 4 ; goto mark_invalid ; } iter -> d4 = o + 4 + 4 + l ; memcpy ( & doclen , iter -> raw + iter -> d4 , sizeof ( doclen ) ) ; doclen = BSON_UINT32_FROM_LE ( doclen ) ; if ( ( o + 4 + 4 + l + doclen ) != iter -> next_off ) { iter -> err_off = o + 4 + 4 + l ; goto mark_invalid ; } } break ; case BSON_TYPE_INT32 : iter -> next_off = o + 4 ; break ; case BSON_TYPE_DECIMAL128 : iter -> next_off = o + 16 ; break ; case BSON_TYPE_MAXKEY : case BSON_TYPE_MINKEY : case BSON_TYPE_NULL : case BSON_TYPE_UNDEFINED : iter -> next_off = o ; break ; default : * unsupported = true ; case BSON_TYPE_EOD : iter -> err_off = o ; goto mark_invalid ; } if ( iter -> next_off >= len ) { iter -> err_off = o ; goto mark_invalid ; } iter -> err_off = 0 ; return true ; mark_invalid : iter -> raw = NULL ; iter -> len = 0 ; iter -> next_off = 0 ; return false ; }\n",
      "fixed_code": "<S2SV_ModStart> len - o - 4\n",
      "source_code_length": 5611,
      "target_code_length": 28,
      "vulnerability_patterns": {
        "buffer_overflow": 9,
        "integer_overflow": 5,
        "null_pointer": 103,
        "total": 117
      },
      "total_patterns": 117,
      "original_address": "https://github.com/mongodb/mongo-c-driver/commit/0d9a4d98bfdf4acd2c0138d4aaeb4e2e0934bd84",
      "discovery_time": "2018-09-10T05:29Z",
      "project_commit_id": "mongodb@mongo-c-driver/0d9a4d98bfdf4acd2c0138d4aaeb4e2e0934bd84",
      "extraction_time": "2025-08-31T15:41:49.186607",
      "label": 1,
      "vulnerability_type": "out-of-bounds_read",
      "difficulty_level": "advanced",
      "risk_factors": [
        "information_disclosure",
        "memory_corruption",
        "integer_overflow",
        "buffer_overflow"
      ],
      "attack_vectors": [
        "memory_manipulation",
        "malicious_input",
        "code_analysis",
        "buffer_overflow",
        "reverse_engineering",
        "fuzzing"
      ],
      "mitigation_strategies": [
        "safe_string_functions",
        "dynamic_analysis",
        "code_review",
        "static_analysis",
        "memory_safety_checks",
        "input_validation",
        "fuzzing",
        "bounds_checking",
        "secure_coding_practices"
      ],
      "code_differences": {
        "has_differences": true,
        "source_lines": 2,
        "target_lines": 2,
        "character_differences": 5583,
        "similarity_percentage": 3.3057851239669422
      },
      "vulnerability_location": {
        "vulnerability_present": true,
        "fix_applied": true,
        "code_changed": true,
        "estimated_lines_changed": 0
      }
    },
    {
      "cve_id": "CVE-2016-1621",
      "cwe_id": "CWE-119",
      "cwe_name": "Buffer Overflow",
      "project": "external",
      "severity": "critical",
      "weaponization_score": 8.0,
      "is_critical": true,
      "is_weaponizable": true,
      "is_high_priority_project": false,
      "vulnerable_code": "CWE-119 int main ( int argc , char * * argv ) { int frame_cnt = 0 ; FILE * outfile = NULL ; vpx_codec_ctx_t codec ; const VpxInterface * decoder = NULL ; VpxVideoReader * reader = NULL ; const VpxVideoInfo * info = NULL ; int n = 0 ; int m = 0 ; int is_range = 0 ; char * nptr = NULL ; exec_name = argv [ 0 ] ; if ( argc != 4 ) die ( \"Invalid<S2SV_blank>number<S2SV_blank>of<S2SV_blank>arguments.\" ) ; reader = vpx_video_reader_open ( argv [ 1 ] ) ; if ( ! reader ) die ( \"Failed<S2SV_blank>to<S2SV_blank>open<S2SV_blank>%s<S2SV_blank>for<S2SV_blank>reading.\" , argv [ 1 ] ) ; if ( ! ( outfile = fopen ( argv [ 2 ] , \"wb\" ) ) ) die ( \"Failed<S2SV_blank>to<S2SV_blank>open<S2SV_blank>%s<S2SV_blank>for<S2SV_blank>writing.\" , argv [ 2 ] ) ; n = strtol ( argv [ 3 ] , & nptr , 0 ) ; m = strtol ( nptr + 1 , NULL , 0 ) ; is_range = ( * nptr == '-' ) ; if ( ! n || ! m || ( * nptr != '-' && * nptr != '/' ) ) die ( \"Couldn\\'t<S2SV_blank>parse<S2SV_blank>pattern<S2SV_blank>%s.\\\\n\" , argv [ 3 ] ) ; info = vpx_video_reader_get_info ( reader ) ; decoder = get_vpx_decoder_by_fourcc ( info -> codec_fourcc ) ; if ( ! decoder ) die ( \"Unknown<S2SV_blank>input<S2SV_blank>codec.\" ) ; <S2SV_StartBug> printf ( \"Using<S2SV_blank>%s\\\\n\" , vpx_codec_iface_name ( decoder -> interface ( ) ) ) ; <S2SV_EndBug> <S2SV_StartBug> if ( vpx_codec_dec_init ( & codec , decoder -> interface ( ) , NULL , 0 ) ) <S2SV_EndBug> die_codec ( & codec , \"Failed<S2SV_blank>to<S2SV_blank>initialize<S2SV_blank>decoder.\" ) ; while ( vpx_video_reader_read_frame ( reader ) ) { vpx_codec_iter_t iter = NULL ; vpx_image_t * img = NULL ; size_t frame_size = 0 ; int skip ; const unsigned char * frame = vpx_video_reader_get_frame ( reader , & frame_size ) ; if ( vpx_codec_decode ( & codec , frame , ( unsigned int ) frame_size , NULL , 0 ) ) die_codec ( & codec , \"Failed<S2SV_blank>to<S2SV_blank>decode<S2SV_blank>frame.\" ) ; ++ frame_cnt ; skip = ( is_range && frame_cnt >= n && frame_cnt <= m ) || ( ! is_range && m - ( frame_cnt - 1 ) % m <= n ) ; if ( ! skip ) { putc ( '.' , stdout ) ; while ( ( img = vpx_codec_get_frame ( & codec , & iter ) ) != NULL ) vpx_img_write ( img , outfile ) ; } else { putc ( 'X' , stdout ) ; } fflush ( stdout ) ; } printf ( \"Processed<S2SV_blank>%d<S2SV_blank>frames.\\\\n\" , frame_cnt ) ; if ( vpx_codec_destroy ( & codec ) ) die_codec ( & codec , \"Failed<S2SV_blank>to<S2SV_blank>destroy<S2SV_blank>codec.\" ) ; printf ( \"Play:<S2SV_blank>ffplay<S2SV_blank>-f<S2SV_blank>rawvideo<S2SV_blank>-pix_fmt<S2SV_blank>yuv420p<S2SV_blank>-s<S2SV_blank>%dx%d<S2SV_blank>%s\\\\n\" , info -> frame_width , info -> frame_height , argv [ 2 ] ) ; vpx_video_reader_close ( reader ) ; fclose ( outfile ) ; return EXIT_SUCCESS ; }\n",
      "fixed_code": "<S2SV_ModStart> ( decoder -> codec_interface <S2SV_ModEnd> ( ) ) <S2SV_ModStart> , decoder -> codec_interface <S2SV_ModEnd> ( ) ,\n",
      "source_code_length": 2710,
      "target_code_length": 130,
      "vulnerability_patterns": {
        "integer_overflow": 4,
        "null_pointer": 12,
        "sql_injection": 6,
        "total": 22
      },
      "total_patterns": 22,
      "original_address": "https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426",
      "discovery_time": "2016-03-12T21:59Z",
      "project_commit_id": "external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426",
      "extraction_time": "2025-08-31T15:41:49.186656",
      "label": 1,
      "vulnerability_type": "buffer_overflow",
      "difficulty_level": "advanced",
      "risk_factors": [
        "system_crash",
        "memory_corruption",
        "sql_injection",
        "arbitrary_code_execution"
      ],
      "attack_vectors": [
        "memory_manipulation",
        "malicious_input",
        "code_analysis",
        "buffer_overflow",
        "reverse_engineering",
        "fuzzing"
      ],
      "mitigation_strategies": [
        "safe_string_functions",
        "dynamic_analysis",
        "code_review",
        "static_analysis",
        "memory_safety_checks",
        "input_validation",
        "fuzzing",
        "bounds_checking",
        "secure_coding_practices"
      ],
      "code_differences": {
        "has_differences": true,
        "source_lines": 2,
        "target_lines": 2,
        "character_differences": 2580,
        "similarity_percentage": 4.464285714285714
      },
      "vulnerability_location": {
        "vulnerability_present": true,
        "fix_applied": true,
        "code_changed": true,
        "estimated_lines_changed": 0
      }
    },
    {
      "cve_id": "CVE-2019-15918",
      "cwe_id": "CWE-125",
      "cwe_name": "Out-of-bounds Read",
      "project": "torvalds",
      "severity": "critical",
      "weaponization_score": 8.0,
      "is_critical": true,
      "is_weaponizable": true,
      "is_high_priority_project": false,
      "vulnerable_code": "CWE-125 int SMB2_negotiate ( const unsigned int xid , struct cifs_ses * ses ) { struct smb_rqst rqst ; struct smb2_negotiate_req * req ; struct smb2_negotiate_rsp * rsp ; struct kvec iov [ 1 ] ; struct kvec rsp_iov ; int rc = 0 ; int resp_buftype ; struct TCP_Server_Info * server = ses -> server ; int blob_offset , blob_length ; char * security_blob ; int flags = CIFS_NEG_OP ; unsigned int total_len ; cifs_dbg ( FYI , \"Negotiate<S2SV_blank>protocol\\\\n\" ) ; if ( ! server ) { WARN ( 1 , \"%s:<S2SV_blank>server<S2SV_blank>is<S2SV_blank>NULL!\\\\n\" , __func__ ) ; return - EIO ; } rc = smb2_plain_req_init ( SMB2_NEGOTIATE , NULL , ( void * * ) & req , & total_len ) ; if ( rc ) return rc ; req -> sync_hdr . SessionId = 0 ; memset ( server -> preauth_sha_hash , 0 , SMB2_PREAUTH_HASH_SIZE ) ; memset ( ses -> preauth_sha_hash , 0 , SMB2_PREAUTH_HASH_SIZE ) ; if ( strcmp ( ses -> server -> vals -> version_string , SMB3ANY_VERSION_STRING ) == 0 ) { req -> Dialects [ 0 ] = cpu_to_le16 ( SMB30_PROT_ID ) ; req -> Dialects [ 1 ] = cpu_to_le16 ( SMB302_PROT_ID ) ; req -> DialectCount = cpu_to_le16 ( 2 ) ; total_len += 4 ; } else if ( strcmp ( ses -> server -> vals -> version_string , SMBDEFAULT_VERSION_STRING ) == 0 ) { req -> Dialects [ 0 ] = cpu_to_le16 ( SMB21_PROT_ID ) ; req -> Dialects [ 1 ] = cpu_to_le16 ( SMB30_PROT_ID ) ; req -> Dialects [ 2 ] = cpu_to_le16 ( SMB302_PROT_ID ) ; req -> Dialects [ 3 ] = cpu_to_le16 ( SMB311_PROT_ID ) ; req -> DialectCount = cpu_to_le16 ( 4 ) ; total_len += 8 ; } else { req -> Dialects [ 0 ] = cpu_to_le16 ( ses -> server -> vals -> protocol_id ) ; req -> DialectCount = cpu_to_le16 ( 1 ) ; total_len += 2 ; } if ( ses -> sign ) req -> SecurityMode = cpu_to_le16 ( SMB2_NEGOTIATE_SIGNING_REQUIRED ) ; else if ( global_secflags & CIFSSEC_MAY_SIGN ) req -> SecurityMode = cpu_to_le16 ( SMB2_NEGOTIATE_SIGNING_ENABLED ) ; else req -> SecurityMode = 0 ; req -> Capabilities = cpu_to_le32 ( ses -> server -> vals -> req_capabilities ) ; if ( ses -> server -> vals -> protocol_id == SMB20_PROT_ID ) memset ( req -> ClientGUID , 0 , SMB2_CLIENT_GUID_SIZE ) ; else { memcpy ( req -> ClientGUID , server -> client_guid , SMB2_CLIENT_GUID_SIZE ) ; if ( ( ses -> server -> vals -> protocol_id == SMB311_PROT_ID ) || ( strcmp ( ses -> server -> vals -> version_string , SMBDEFAULT_VERSION_STRING ) == 0 ) ) assemble_neg_contexts ( req , & total_len ) ; } iov [ 0 ] . iov_base = ( char * ) req ; iov [ 0 ] . iov_len = total_len ; memset ( & rqst , 0 , sizeof ( struct smb_rqst ) ) ; rqst . rq_iov = iov ; rqst . rq_nvec = 1 ; rc = cifs_send_recv ( xid , ses , & rqst , & resp_buftype , flags , & rsp_iov ) ; cifs_small_buf_release ( req ) ; rsp = ( struct smb2_negotiate_rsp * ) rsp_iov . iov_base ; if ( rc == - EOPNOTSUPP ) { cifs_dbg ( VFS , \"Dialect<S2SV_blank>not<S2SV_blank>supported<S2SV_blank>by<S2SV_blank>server.<S2SV_blank>Consider<S2SV_blank>\" \"specifying<S2SV_blank>vers=1.0<S2SV_blank>or<S2SV_blank>vers=2.0<S2SV_blank>on<S2SV_blank>mount<S2SV_blank>for<S2SV_blank>accessing\" \"<S2SV_blank>older<S2SV_blank>servers\\\\n\" ) ; goto neg_exit ; } else if ( rc != 0 ) goto neg_exit ; if ( strcmp ( ses -> server -> vals -> version_string , SMB3ANY_VERSION_STRING ) == 0 ) { if ( rsp -> DialectRevision == cpu_to_le16 ( SMB20_PROT_ID ) ) { cifs_dbg ( VFS , \"SMB2<S2SV_blank>dialect<S2SV_blank>returned<S2SV_blank>but<S2SV_blank>not<S2SV_blank>requested\\\\n\" ) ; return - EIO ; } else if ( rsp -> DialectRevision == cpu_to_le16 ( SMB21_PROT_ID ) ) { cifs_dbg ( VFS , \"SMB2.1<S2SV_blank>dialect<S2SV_blank>returned<S2SV_blank>but<S2SV_blank>not<S2SV_blank>requested\\\\n\" ) ; return - EIO ; } } else if ( strcmp ( ses -> server -> vals -> version_string , SMBDEFAULT_VERSION_STRING ) == 0 ) { if ( rsp -> DialectRevision == cpu_to_le16 ( SMB20_PROT_ID ) ) { cifs_dbg ( VFS , \"SMB2<S2SV_blank>dialect<S2SV_blank>returned<S2SV_blank>but<S2SV_blank>not<S2SV_blank>requested\\\\n\" ) ; return - EIO ; } else if ( rsp -> DialectRevision == cpu_to_le16 ( SMB21_PROT_ID ) ) { ses -> server -> ops = & smb21_operations ; <S2SV_StartBug> } else if ( rsp -> DialectRevision == cpu_to_le16 ( SMB311_PROT_ID ) ) <S2SV_EndBug> <S2SV_StartBug> ses -> server -> ops = & smb311_operations ; <S2SV_EndBug> } else if ( le16_to_cpu ( rsp -> DialectRevision ) != ses -> server -> vals -> protocol_id ) { cifs_dbg ( VFS , \"Illegal<S2SV_blank>0x%x<S2SV_blank>dialect<S2SV_blank>returned:<S2SV_blank>not<S2SV_blank>requested\\\\n\" , le16_to_cpu ( rsp -> DialectRevision ) ) ; return - EIO ; } cifs_dbg ( FYI , \"mode<S2SV_blank>0x%x\\\\n\" , rsp -> SecurityMode ) ; if ( rsp -> DialectRevision == cpu_to_le16 ( SMB20_PROT_ID ) ) cifs_dbg ( FYI , \"negotiated<S2SV_blank>smb2.0<S2SV_blank>dialect\\\\n\" ) ; else if ( rsp -> DialectRevision == cpu_to_le16 ( SMB21_PROT_ID ) ) cifs_dbg ( FYI , \"negotiated<S2SV_blank>smb2.1<S2SV_blank>dialect\\\\n\" ) ; else if ( rsp -> DialectRevision == cpu_to_le16 ( SMB30_PROT_ID ) ) cifs_dbg ( FYI , \"negotiated<S2SV_blank>smb3.0<S2SV_blank>dialect\\\\n\" ) ; else if ( rsp -> DialectRevision == cpu_to_le16 ( SMB302_PROT_ID ) ) cifs_dbg ( FYI , \"negotiated<S2SV_blank>smb3.02<S2SV_blank>dialect\\\\n\" ) ; else if ( rsp -> DialectRevision == cpu_to_le16 ( SMB311_PROT_ID ) ) cifs_dbg ( FYI , \"negotiated<S2SV_blank>smb3.1.1<S2SV_blank>dialect\\\\n\" ) ; else { cifs_dbg ( VFS , \"Illegal<S2SV_blank>dialect<S2SV_blank>returned<S2SV_blank>by<S2SV_blank>server<S2SV_blank>0x%x\\\\n\" , le16_to_cpu ( rsp -> DialectRevision ) ) ; rc = - EIO ; goto neg_exit ; } server -> dialect = le16_to_cpu ( rsp -> DialectRevision ) ; memcpy ( server -> preauth_sha_hash , ses -> preauth_sha_hash , SMB2_PREAUTH_HASH_SIZE ) ; server -> negflavor = CIFS_NEGFLAVOR_EXTENDED ; server -> maxBuf = min_t ( unsigned int , le32_to_cpu ( rsp -> MaxTransactSize ) , SMB2_MAX_BUFFER_SIZE ) ; server -> max_read = le32_to_cpu ( rsp -> MaxReadSize ) ; server -> max_write = le32_to_cpu ( rsp -> MaxWriteSize ) ; server -> sec_mode = le16_to_cpu ( rsp -> SecurityMode ) ; if ( ( server -> sec_mode & SMB2_SEC_MODE_FLAGS_ALL ) != server -> sec_mode ) cifs_dbg ( FYI , \"Server<S2SV_blank>returned<S2SV_blank>unexpected<S2SV_blank>security<S2SV_blank>mode<S2SV_blank>0x%x\\\\n\" , server -> sec_mode ) ; server -> capabilities = le32_to_cpu ( rsp -> Capabilities ) ; server -> capabilities |= SMB2_NT_FIND | SMB2_LARGE_FILES ; security_blob = smb2_get_data_area_len ( & blob_offset , & blob_length , ( struct smb2_sync_hdr * ) rsp ) ; if ( blob_length == 0 ) { cifs_dbg ( FYI , \"missing<S2SV_blank>security<S2SV_blank>blob<S2SV_blank>on<S2SV_blank>negprot\\\\n\" ) ; server -> sec_ntlmssp = true ; } rc = cifs_enable_signing ( server , ses -> sign ) ; if ( rc ) goto neg_exit ; if ( blob_length ) { rc = decode_negTokenInit ( security_blob , blob_length , server ) ; if ( rc == 1 ) rc = 0 ; else if ( rc == 0 ) rc = - EIO ; } if ( rsp -> DialectRevision == cpu_to_le16 ( SMB311_PROT_ID ) ) { if ( rsp -> NegotiateContextCount ) rc = smb311_decode_neg_context ( rsp , server , rsp_iov . iov_len ) ; else cifs_dbg ( VFS , \"Missing<S2SV_blank>expected<S2SV_blank>negotiate<S2SV_blank>contexts\\\\n\" ) ; } neg_exit : free_rsp_buf ( resp_buftype , rsp ) ; return rc ; }\n",
      "fixed_code": "<S2SV_ModStart> & smb21_operations ; ses -> server -> vals = & smb21_values ; <S2SV_ModStart> SMB311_PROT_ID ) ) { <S2SV_ModStart> & smb311_operations ; ses -> server -> vals = & smb311_values ; }\n",
      "source_code_length": 7143,
      "target_code_length": 197,
      "vulnerability_patterns": {
        "buffer_overflow": 6,
        "integer_overflow": 3,
        "null_pointer": 95,
        "total": 104
      },
      "total_patterns": 104,
      "original_address": "https://github.com/torvalds/linux/commit/b57a55e2200ede754e4dc9cce4ba9402544b9365",
      "discovery_time": "2019-09-04T19:15Z",
      "project_commit_id": "torvalds@linux/b57a55e2200ede754e4dc9cce4ba9402544b9365",
      "extraction_time": "2025-08-31T15:41:49.186694",
      "label": 1,
      "vulnerability_type": "out-of-bounds_read",
      "difficulty_level": "advanced",
      "risk_factors": [
        "information_disclosure",
        "memory_corruption",
        "integer_overflow",
        "buffer_overflow"
      ],
      "attack_vectors": [
        "memory_manipulation",
        "malicious_input",
        "code_analysis",
        "buffer_overflow",
        "reverse_engineering",
        "fuzzing"
      ],
      "mitigation_strategies": [
        "safe_string_functions",
        "dynamic_analysis",
        "code_review",
        "static_analysis",
        "memory_safety_checks",
        "input_validation",
        "fuzzing",
        "bounds_checking",
        "secure_coding_practices"
      ],
      "code_differences": {
        "has_differences": true,
        "source_lines": 2,
        "target_lines": 2,
        "character_differences": 6946,
        "similarity_percentage": 7.784431137724551
      },
      "vulnerability_location": {
        "vulnerability_present": true,
        "fix_applied": true,
        "code_changed": true,
        "estimated_lines_changed": 0
      }
    },
    {
      "cve_id": "CVE-2017-17052",
      "cwe_id": "CWE-416",
      "cwe_name": "Use After Free",
      "project": "torvalds",
      "severity": "critical",
      "weaponization_score": 8.0,
      "is_critical": true,
      "is_weaponizable": true,
      "is_high_priority_project": false,
      "vulnerable_code": "CWE-416 static struct mm_struct * mm_init ( struct mm_struct * mm , struct task_struct * p , struct user_namespace * user_ns ) { mm -> mmap = NULL ; mm -> mm_rb = RB_ROOT ; mm -> vmacache_seqnum = 0 ; atomic_set ( & mm -> mm_users , 1 ) ; atomic_set ( & mm -> mm_count , 1 ) ; init_rwsem ( & mm -> mmap_sem ) ; INIT_LIST_HEAD ( & mm -> mmlist ) ; mm -> core_state = NULL ; atomic_long_set ( & mm -> nr_ptes , 0 ) ; mm_nr_pmds_init ( mm ) ; mm -> map_count = 0 ; mm -> locked_vm = 0 ; mm -> pinned_vm = 0 ; memset ( & mm -> rss_stat , 0 , sizeof ( mm -> rss_stat ) ) ; spin_lock_init ( & mm -> page_table_lock ) ; mm_init_cpumask ( mm ) ; mm_init_aio ( mm ) ; mm_init_owner ( mm , p ) ; <S2SV_StartBug> mmu_notifier_mm_init ( mm ) ; <S2SV_EndBug> init_tlb_flush_pending ( mm ) ; # if defined ( CONFIG_TRANSPARENT_HUGEPAGE ) && ! USE_SPLIT_PMD_PTLOCKS mm -> pmd_huge_pte = NULL ; # endif if ( current -> mm ) { mm -> flags = current -> mm -> flags & MMF_INIT_MASK ; mm -> def_flags = current -> mm -> def_flags & VM_INIT_DEF_MASK ; } else { mm -> flags = default_dump_filter ; mm -> def_flags = 0 ; } if ( mm_alloc_pgd ( mm ) ) goto fail_nopgd ; if ( init_new_context ( p , mm ) ) goto fail_nocontext ; mm -> user_ns = get_user_ns ( user_ns ) ; return mm ; fail_nocontext : mm_free_pgd ( mm ) ; fail_nopgd : free_mm ( mm ) ; return NULL ; }\n",
      "fixed_code": "<S2SV_ModStart> p ) ; RCU_INIT_POINTER ( mm -> exe_file , NULL ) ;\n",
      "source_code_length": 1339,
      "target_code_length": 67,
      "vulnerability_patterns": {
        "buffer_overflow": 1,
        "null_pointer": 26,
        "total": 27
      },
      "total_patterns": 27,
      "original_address": "https://github.com/torvalds/linux/commit/2b7e8665b4ff51c034c55df3cff76518d1a9ee3a",
      "discovery_time": "2017-11-29T03:29Z",
      "project_commit_id": "torvalds@linux/2b7e8665b4ff51c034c55df3cff76518d1a9ee3a",
      "extraction_time": "2025-08-31T15:41:49.186763",
      "label": 1,
      "vulnerability_type": "use_after_free",
      "difficulty_level": "advanced",
      "risk_factors": [
        "system_crash",
        "denial_of_service",
        "memory_corruption",
        "buffer_overflow"
      ],
      "attack_vectors": [
        "memory_manipulation",
        "null_pointer",
        "code_analysis",
        "reverse_engineering",
        "use_after_free",
        "fuzzing"
      ],
      "mitigation_strategies": [
        "null_pointer_checks",
        "fuzzing",
        "dynamic_analysis",
        "memory_management",
        "static_analysis",
        "use_after_free_prevention",
        "code_review",
        "secure_coding_practices"
      ],
      "code_differences": {
        "has_differences": true,
        "source_lines": 2,
        "target_lines": 2,
        "character_differences": 1272,
        "similarity_percentage": 9.75609756097561
      },
      "vulnerability_location": {
        "vulnerability_present": true,
        "fix_applied": true,
        "code_changed": true,
        "estimated_lines_changed": 0
      }
    },
    {
      "cve_id": "CVE-2015-7515",
      "cwe_id": "CWE-000",
      "cwe_name": "Unknown/Uncategorized",
      "project": "torvalds",
      "severity": "critical",
      "weaponization_score": 8.0,
      "is_critical": true,
      "is_weaponizable": true,
      "is_high_priority_project": false,
      "vulnerable_code": "CWE-000 static int aiptek_probe ( struct usb_interface * intf , const struct usb_device_id * id ) { struct usb_device * usbdev = interface_to_usbdev ( intf ) ; struct usb_endpoint_descriptor * endpoint ; struct aiptek * aiptek ; struct input_dev * inputdev ; int i ; int speeds [ ] = { 0 , AIPTEK_PROGRAMMABLE_DELAY_50 , AIPTEK_PROGRAMMABLE_DELAY_400 , AIPTEK_PROGRAMMABLE_DELAY_25 , AIPTEK_PROGRAMMABLE_DELAY_100 , AIPTEK_PROGRAMMABLE_DELAY_200 , AIPTEK_PROGRAMMABLE_DELAY_300 } ; int err = - ENOMEM ; speeds [ 0 ] = programmableDelay ; aiptek = kzalloc ( sizeof ( struct aiptek ) , GFP_KERNEL ) ; inputdev = input_allocate_device ( ) ; if ( ! aiptek || ! inputdev ) { dev_warn ( & intf -> dev , \"cannot<S2SV_blank>allocate<S2SV_blank>memory<S2SV_blank>or<S2SV_blank>input<S2SV_blank>device\\\\n\" ) ; goto fail1 ; } aiptek -> data = usb_alloc_coherent ( usbdev , AIPTEK_PACKET_LENGTH , GFP_ATOMIC , & aiptek -> data_dma ) ; if ( ! aiptek -> data ) { dev_warn ( & intf -> dev , \"cannot<S2SV_blank>allocate<S2SV_blank>usb<S2SV_blank>buffer\\\\n\" ) ; goto fail1 ; } aiptek -> urb = usb_alloc_urb ( 0 , GFP_KERNEL ) ; if ( ! aiptek -> urb ) { dev_warn ( & intf -> dev , \"cannot<S2SV_blank>allocate<S2SV_blank>urb\\\\n\" ) ; goto fail2 ; } aiptek -> inputdev = inputdev ; aiptek -> usbdev = usbdev ; aiptek -> intf = intf ; aiptek -> ifnum = intf -> altsetting [ 0 ] . desc . bInterfaceNumber ; aiptek -> inDelay = 0 ; aiptek -> endDelay = 0 ; aiptek -> previousJitterable = 0 ; aiptek -> lastMacro = - 1 ; aiptek -> curSetting . pointerMode = AIPTEK_POINTER_EITHER_MODE ; aiptek -> curSetting . coordinateMode = AIPTEK_COORDINATE_ABSOLUTE_MODE ; aiptek -> curSetting . toolMode = AIPTEK_TOOL_BUTTON_PEN_MODE ; aiptek -> curSetting . xTilt = AIPTEK_TILT_DISABLE ; aiptek -> curSetting . yTilt = AIPTEK_TILT_DISABLE ; aiptek -> curSetting . mouseButtonLeft = AIPTEK_MOUSE_LEFT_BUTTON ; aiptek -> curSetting . mouseButtonMiddle = AIPTEK_MOUSE_MIDDLE_BUTTON ; aiptek -> curSetting . mouseButtonRight = AIPTEK_MOUSE_RIGHT_BUTTON ; aiptek -> curSetting . stylusButtonUpper = AIPTEK_STYLUS_UPPER_BUTTON ; aiptek -> curSetting . stylusButtonLower = AIPTEK_STYLUS_LOWER_BUTTON ; aiptek -> curSetting . jitterDelay = jitterDelay ; aiptek -> curSetting . programmableDelay = programmableDelay ; aiptek -> newSetting = aiptek -> curSetting ; usb_make_path ( usbdev , aiptek -> features . usbPath , sizeof ( aiptek -> features . usbPath ) ) ; strlcat ( aiptek -> features . usbPath , \"/input0\" , sizeof ( aiptek -> features . usbPath ) ) ; inputdev -> name = \"Aiptek\" ; inputdev -> phys = aiptek -> features . usbPath ; usb_to_input_id ( usbdev , & inputdev -> id ) ; inputdev -> dev . parent = & intf -> dev ; input_set_drvdata ( inputdev , aiptek ) ; inputdev -> open = aiptek_open ; inputdev -> close = aiptek_close ; for ( i = 0 ; i < ARRAY_SIZE ( eventTypes ) ; ++ i ) __set_bit ( eventTypes [ i ] , inputdev -> evbit ) ; for ( i = 0 ; i < ARRAY_SIZE ( absEvents ) ; ++ i ) __set_bit ( absEvents [ i ] , inputdev -> absbit ) ; for ( i = 0 ; i < ARRAY_SIZE ( relEvents ) ; ++ i ) __set_bit ( relEvents [ i ] , inputdev -> relbit ) ; __set_bit ( MSC_SERIAL , inputdev -> mscbit ) ; for ( i = 0 ; i < ARRAY_SIZE ( buttonEvents ) ; ++ i ) __set_bit ( buttonEvents [ i ] , inputdev -> keybit ) ; for ( i = 0 ; i < ARRAY_SIZE ( macroKeyEvents ) ; ++ i ) __set_bit ( macroKeyEvents [ i ] , inputdev -> keybit ) ; input_set_abs_params ( inputdev , ABS_X , 0 , 2999 , 0 , 0 ) ; input_set_abs_params ( inputdev , ABS_Y , 0 , 2249 , 0 , 0 ) ; input_set_abs_params ( inputdev , ABS_PRESSURE , 0 , 511 , 0 , 0 ) ; input_set_abs_params ( inputdev , ABS_TILT_X , AIPTEK_TILT_MIN , AIPTEK_TILT_MAX , 0 , 0 ) ; input_set_abs_params ( inputdev , ABS_TILT_Y , AIPTEK_TILT_MIN , AIPTEK_TILT_MAX , 0 , 0 ) ; input_set_abs_params ( inputdev , ABS_WHEEL , AIPTEK_WHEEL_MIN , AIPTEK_WHEEL_MAX - 1 , 0 , 0 ) ; <S2SV_StartBug> endpoint = & intf -> altsetting [ 0 ] . endpoint [ 0 ] . desc ; <S2SV_EndBug> usb_fill_int_urb ( aiptek -> urb , aiptek -> usbdev , usb_rcvintpipe ( aiptek -> usbdev , endpoint -> bEndpointAddress ) , aiptek -> data , 8 , aiptek_irq , aiptek , endpoint -> bInterval ) ; aiptek -> urb -> transfer_dma = aiptek -> data_dma ; aiptek -> urb -> transfer_flags |= URB_NO_TRANSFER_DMA_MAP ; for ( i = 0 ; i < ARRAY_SIZE ( speeds ) ; ++ i ) { aiptek -> curSetting . programmableDelay = speeds [ i ] ; ( void ) aiptek_program_tablet ( aiptek ) ; if ( input_abs_get_max ( aiptek -> inputdev , ABS_X ) > 0 ) { dev_info ( & intf -> dev , \"Aiptek<S2SV_blank>using<S2SV_blank>%d<S2SV_blank>ms<S2SV_blank>programming<S2SV_blank>speed\\\\n\" , aiptek -> curSetting . programmableDelay ) ; break ; } } if ( i == ARRAY_SIZE ( speeds ) ) { dev_info ( & intf -> dev , \"Aiptek<S2SV_blank>tried<S2SV_blank>all<S2SV_blank>speeds,<S2SV_blank>no<S2SV_blank>sane<S2SV_blank>response\\\\n\" ) ; <S2SV_StartBug> goto fail3 ; <S2SV_EndBug> } usb_set_intfdata ( intf , aiptek ) ; err = sysfs_create_group ( & intf -> dev . kobj , & aiptek_attribute_group ) ; if ( err ) { dev_warn ( & intf -> dev , \"cannot<S2SV_blank>create<S2SV_blank>sysfs<S2SV_blank>group<S2SV_blank>err:<S2SV_blank>%d\\\\n\" , err ) ; goto fail3 ; } err = input_register_device ( aiptek -> inputdev ) ; if ( err ) { dev_warn ( & intf -> dev , \"input_register_device<S2SV_blank>returned<S2SV_blank>err:<S2SV_blank>%d\\\\n\" , err ) ; goto fail4 ; } return 0 ; fail4 : sysfs_remove_group ( & intf -> dev . kobj , & aiptek_attribute_group ) ; fail3 : usb_free_urb ( aiptek -> urb ) ; fail2 : usb_free_coherent ( usbdev , AIPTEK_PACKET_LENGTH , aiptek -> data , aiptek -> data_dma ) ; fail1 : usb_set_intfdata ( intf , NULL ) ; input_free_device ( inputdev ) ; kfree ( aiptek ) ; return err ; }\n",
      "fixed_code": "<S2SV_ModStart> 0 ) ; if ( intf -> altsetting [ 0 ] . desc . bNumEndpoints < 1 ) { dev_err ( & intf -> dev , \"interface<S2SV_blank>has<S2SV_blank>%d<S2SV_blank>endpoints,<S2SV_blank>but<S2SV_blank>must<S2SV_blank>have<S2SV_blank>minimum<S2SV_blank>1\\\\n\" , intf -> altsetting [ 0 ] . desc . bNumEndpoints ) ; err = - EINVAL ; goto fail3 ; } <S2SV_ModStart> \"Aiptek<S2SV_blank>tried<S2SV_blank>all<S2SV_blank>speeds,<S2SV_blank>no<S2SV_blank>sane<S2SV_blank>response\\\\n\" ) ; err = - EINVAL ;\n",
      "source_code_length": 5703,
      "target_code_length": 490,
      "vulnerability_patterns": {
        "use_after_free": 2,
        "integer_overflow": 6,
        "null_pointer": 74,
        "sql_injection": 1,
        "total": 83
      },
      "total_patterns": 83,
      "original_address": "https://github.com/torvalds/linux/commit/8e20cf2bce122ce9262d6034ee5d5b76fbb92f96",
      "discovery_time": "2016-04-27T17:59Z",
      "project_commit_id": "torvalds@linux/8e20cf2bce122ce9262d6034ee5d5b76fbb92f96",
      "extraction_time": "2025-08-31T15:41:49.186798",
      "label": 1,
      "vulnerability_type": "unknown/uncategorized",
      "difficulty_level": "advanced",
      "risk_factors": [
        "sql_injection",
        "use_after_free"
      ],
      "attack_vectors": [
        "fuzzing",
        "code_analysis",
        "reverse_engineering"
      ],
      "mitigation_strategies": [
        "dynamic_analysis",
        "static_analysis",
        "fuzzing",
        "code_review",
        "secure_coding_practices"
      ],
      "code_differences": {
        "has_differences": true,
        "source_lines": 2,
        "target_lines": 2,
        "character_differences": 5213,
        "similarity_percentage": 13.513513513513514
      },
      "vulnerability_location": {
        "vulnerability_present": true,
        "fix_applied": true,
        "code_changed": true,
        "estimated_lines_changed": 0
      }
    },
    {
      "cve_id": "CVE-2017-15924",
      "cwe_id": "CWE-78",
      "cwe_name": "OS Command Injection",
      "project": "shadowsocks",
      "severity": "critical",
      "weaponization_score": 8.0,
      "is_critical": true,
      "is_weaponizable": true,
      "is_high_priority_project": false,
      "vulnerable_code": "CWE-78 static void <S2SV_StartBug> build_config ( char * prefix , struct server * server ) <S2SV_EndBug> { char * path = NULL ; int path_size = strlen ( prefix ) + strlen ( server -> port ) + 20 ; path = ss_malloc ( path_size ) ; snprintf ( path , path_size , \"%s/.shadowsocks_%s.conf\" , prefix , server -> port ) ; FILE * f = fopen ( path , \"w+\" ) ; if ( f == NULL ) { if ( verbose ) { LOGE ( \"unable<S2SV_blank>to<S2SV_blank>open<S2SV_blank>config<S2SV_blank>file\" ) ; } ss_free ( path ) ; return ; } fprintf ( f , \"{\\\\n\" ) ; fprintf ( f , \"\\\\\"server_port\\\\\":%d,\\\\n\" , atoi ( server -> port ) ) ; <S2SV_StartBug> fprintf ( f , \"\\\\\"password\\\\\":\\\\\"%s\\\\\"\" , server -> password ) ; <S2SV_EndBug> if ( server -> fast_open [ 0 ] ) fprintf ( f , \",\\\\n\\\\\"fast_open\\\\\":<S2SV_blank>%s\" , server -> fast_open ) ; if ( server -> mode ) fprintf ( f , \",\\\\n\\\\\"mode\\\\\":\\\\\"%s\\\\\"\" , server -> mode ) ; <S2SV_StartBug> if ( server -> method ) fprintf ( f , \",\\\\n\\\\\"method\\\\\":\\\\\"%s\\\\\"\" , server -> method ) ; <S2SV_EndBug> if ( server -> plugin ) fprintf ( f , \",\\\\n\\\\\"plugin\\\\\":\\\\\"%s\\\\\"\" , server -> plugin ) ; if ( server -> plugin_opts ) fprintf ( f , \",\\\\n\\\\\"plugin_opts\\\\\":\\\\\"%s\\\\\"\" , server -> plugin_opts ) ; fprintf ( f , \"\\\\n}\\\\n\" ) ; fclose ( f ) ; ss_free ( path ) ; }\n",
      "fixed_code": "<S2SV_ModStart> prefix , struct manager_ctx * manager , struct <S2SV_ModStart> server -> password ) ; if ( server -> method ) fprintf ( f , \",\\\\n\\\\\"method\\\\\":\\\\\"%s\\\\\"\" , server -> method ) ; else if ( manager -> method ) fprintf ( f , \",\\\\n\\\\\"method\\\\\":\\\\\"%s\\\\\"\" , manager -> method <S2SV_ModStart> ( server -> <S2SV_ModEnd> plugin ) fprintf\n",
      "source_code_length": 1263,
      "target_code_length": 342,
      "vulnerability_patterns": {
        "format_string": 10,
        "null_pointer": 15,
        "total": 25
      },
      "total_patterns": 25,
      "original_address": "https://github.com/shadowsocks/shadowsocks-libev/commit/c67d275803dc6ea22c558d06b1f7ba9f94cd8de3",
      "discovery_time": "2017-10-27T16:29Z",
      "project_commit_id": "shadowsocks@shadowsocks-libev/c67d275803dc6ea22c558d06b1f7ba9f94cd8de3",
      "extraction_time": "2025-08-31T15:41:49.186891",
      "label": 1,
      "vulnerability_type": "os_command_injection",
      "difficulty_level": "advanced",
      "risk_factors": [
        "command_injection",
        "arbitrary_code_execution",
        "remote_code_execution"
      ],
      "attack_vectors": [
        "command_injection",
        "system_commands",
        "code_analysis",
        "reverse_engineering",
        "fuzzing",
        "user_input"
      ],
      "mitigation_strategies": [
        "fuzzing",
        "dynamic_analysis",
        "command_whitelisting",
        "static_analysis",
        "secure_coding_practices",
        "privilege_separation",
        "input_sanitization",
        "code_review",
        "input_validation"
      ],
      "code_differences": {
        "has_differences": true,
        "source_lines": 2,
        "target_lines": 2,
        "character_differences": 921,
        "similarity_percentage": 23.88059701492537
      },
      "vulnerability_location": {
        "vulnerability_present": true,
        "fix_applied": true,
        "code_changed": true,
        "estimated_lines_changed": 0
      }
    },
    {
      "cve_id": "CVE-2019-15026",
      "cwe_id": "CWE-125",
      "cwe_name": "Out-of-bounds Read",
      "project": "memcached",
      "severity": "critical",
      "weaponization_score": 8.0,
      "is_critical": true,
      "is_weaponizable": true,
      "is_high_priority_project": false,
      "vulnerable_code": "CWE-125 static inline void get_conn_text ( const conn * c , const int af , char * addr , struct sockaddr * sock_addr ) { char addr_text [ MAXPATHLEN ] ; addr_text [ 0 ] = '\\\\0' ; const char * protoname = \"?\" ; unsigned short port = 0 ; <S2SV_StartBug> switch ( af ) { <S2SV_EndBug> case AF_INET : ( void ) inet_ntop ( af , & ( ( struct sockaddr_in * ) sock_addr ) -> sin_addr , addr_text , sizeof ( addr_text ) - 1 ) ; port = ntohs ( ( ( struct sockaddr_in * ) sock_addr ) -> sin_port ) ; protoname = IS_UDP ( c -> transport ) ? \"udp\" : \"tcp\" ; break ; case AF_INET6 : addr_text [ 0 ] = '[' ; addr_text [ 1 ] = '\\\\0' ; if ( inet_ntop ( af , & ( ( struct sockaddr_in6 * ) sock_addr ) -> sin6_addr , addr_text + 1 , sizeof ( addr_text ) - 2 ) ) { strcat ( addr_text , \"]\" ) ; } port = ntohs ( ( ( struct sockaddr_in6 * ) sock_addr ) -> sin6_port ) ; protoname = IS_UDP ( c -> transport ) ? \"udp6\" : \"tcp6\" ; break ; case AF_UNIX : <S2SV_StartBug> strncpy ( addr_text , <S2SV_EndBug> <S2SV_StartBug> ( ( struct sockaddr_un * ) sock_addr ) -> sun_path , <S2SV_EndBug> sizeof ( addr_text ) - 1 ) ; addr_text [ sizeof ( addr_text ) - 1 ] = '\\\\0' ; protoname = \"unix\" ; break ; } if ( strlen ( addr_text ) < 2 ) { sprintf ( addr_text , \"<AF<S2SV_blank>%d>\" , af ) ; } if ( port ) { sprintf ( addr , \"%s:%s:%u\" , protoname , addr_text , port ) ; } else { sprintf ( addr , \"%s:%s\" , protoname , addr_text ) ; } }\n",
      "fixed_code": "<S2SV_ModStart> = 0 ; size_t pathlen = 0 ; <S2SV_ModStart> case AF_UNIX : pathlen = sizeof ( <S2SV_ModEnd> ( ( struct <S2SV_ModStart> ) -> sun_path ) ; if ( MAXPATHLEN <= pathlen ) { pathlen = MAXPATHLEN - 1 ; } strncpy ( addr_text , ( ( struct sockaddr_un * ) sock_addr ) -> sun_path , pathlen ) ; addr_text [ pathlen <S2SV_ModEnd> ] = '\\\\0'\n",
      "source_code_length": 1404,
      "target_code_length": 343,
      "vulnerability_patterns": {
        "buffer_overflow": 5,
        "format_string": 3,
        "null_pointer": 7,
        "total": 15
      },
      "total_patterns": 15,
      "original_address": "https://github.com/memcached/memcached/commit/554b56687a19300a75ec24184746b5512580c819",
      "discovery_time": "2019-08-30T15:15Z",
      "project_commit_id": "memcached@memcached/554b56687a19300a75ec24184746b5512580c819",
      "extraction_time": "2025-08-31T15:41:49.186952",
      "label": 1,
      "vulnerability_type": "out-of-bounds_read",
      "difficulty_level": "advanced",
      "risk_factors": [
        "information_disclosure",
        "memory_corruption",
        "integer_overflow",
        "buffer_overflow"
      ],
      "attack_vectors": [
        "memory_manipulation",
        "malicious_input",
        "code_analysis",
        "buffer_overflow",
        "reverse_engineering",
        "fuzzing"
      ],
      "mitigation_strategies": [
        "safe_string_functions",
        "dynamic_analysis",
        "code_review",
        "static_analysis",
        "memory_safety_checks",
        "input_validation",
        "fuzzing",
        "bounds_checking",
        "secure_coding_practices"
      ],
      "code_differences": {
        "has_differences": true,
        "source_lines": 2,
        "target_lines": 2,
        "character_differences": 1061,
        "similarity_percentage": 31.76470588235294
      },
      "vulnerability_location": {
        "vulnerability_present": true,
        "fix_applied": true,
        "code_changed": true,
        "estimated_lines_changed": 0
      }
    },
    {
      "cve_id": "CVE-2017-9465",
      "cwe_id": "CWE-125",
      "cwe_name": "Out-of-bounds Read",
      "project": "VirusTotal",
      "severity": "critical",
      "weaponization_score": 8.0,
      "is_critical": true,
      "is_weaponizable": true,
      "is_high_priority_project": false,
      "vulnerable_code": "CWE-125 int _yr_scan_match_callback ( uint8_t * match_data , int32_t match_length , int flags , void * args ) { CALLBACK_ARGS * callback_args = ( CALLBACK_ARGS * ) args ; YR_STRING * string = callback_args -> string ; YR_MATCH * new_match ; int result = ERROR_SUCCESS ; int tidx = callback_args -> context -> tidx ; size_t match_offset = match_data - callback_args -> data ; <S2SV_StartBug> match_length += callback_args -> forward_matches ; <S2SV_EndBug> if ( callback_args -> full_word ) { if ( flags & RE_FLAGS_WIDE ) { if ( match_offset >= 2 && * ( match_data - 1 ) == 0 && isalnum ( * ( match_data - 2 ) ) ) return ERROR_SUCCESS ; if ( match_offset + match_length + 1 < callback_args -> data_size && * ( match_data + match_length + 1 ) == 0 && isalnum ( * ( match_data + match_length ) ) ) return ERROR_SUCCESS ; } else { if ( match_offset >= 1 && isalnum ( * ( match_data - 1 ) ) ) return ERROR_SUCCESS ; if ( match_offset + match_length < callback_args -> data_size && isalnum ( * ( match_data + match_length ) ) ) return ERROR_SUCCESS ; } } if ( STRING_IS_CHAIN_PART ( string ) ) { result = _yr_scan_verify_chained_string_match ( string , callback_args -> context , match_data , callback_args -> data_base , match_offset , match_length ) ; } else { if ( string -> matches [ tidx ] . count == 0 ) { FAIL_ON_ERROR ( yr_arena_write_data ( callback_args -> context -> matching_strings_arena , & string , sizeof ( string ) , NULL ) ) ; } FAIL_ON_ERROR ( yr_arena_allocate_memory ( callback_args -> context -> matches_arena , sizeof ( YR_MATCH ) , ( void * * ) & new_match ) ) ; new_match -> data_length = yr_min ( match_length , MAX_MATCH_DATA ) ; FAIL_ON_ERROR ( yr_arena_write_data ( callback_args -> context -> matches_arena , match_data , new_match -> data_length , ( void * * ) & new_match -> data ) ) ; if ( result == ERROR_SUCCESS ) { new_match -> base = callback_args -> data_base ; new_match -> offset = match_offset ; new_match -> match_length = match_length ; new_match -> prev = NULL ; new_match -> next = NULL ; FAIL_ON_ERROR ( _yr_scan_add_match_to_list ( new_match , & string -> matches [ tidx ] , STRING_IS_GREEDY_REGEXP ( string ) ) ) ; } } return result ; }\n",
      "fixed_code": "<S2SV_ModStart> callback_args -> forward_matches ; assert ( match_offset + match_length <= callback_args -> data_size )\n",
      "source_code_length": 2179,
      "target_code_length": 120,
      "vulnerability_patterns": {
        "use_after_free": 11,
        "integer_overflow": 1,
        "null_pointer": 27,
        "total": 39
      },
      "total_patterns": 39,
      "original_address": "https://github.com/VirusTotal/yara/commit/992480c30f75943e9cd6245bb2015c7737f9b661",
      "discovery_time": "2017-06-06T21:29Z",
      "project_commit_id": "VirusTotal@yara/992480c30f75943e9cd6245bb2015c7737f9b661",
      "extraction_time": "2025-08-31T15:41:49.187004",
      "label": 1,
      "vulnerability_type": "out-of-bounds_read",
      "difficulty_level": "advanced",
      "risk_factors": [
        "information_disclosure",
        "memory_corruption",
        "integer_overflow",
        "use_after_free"
      ],
      "attack_vectors": [
        "memory_manipulation",
        "malicious_input",
        "code_analysis",
        "buffer_overflow",
        "reverse_engineering",
        "fuzzing"
      ],
      "mitigation_strategies": [
        "safe_string_functions",
        "dynamic_analysis",
        "code_review",
        "static_analysis",
        "memory_safety_checks",
        "input_validation",
        "fuzzing",
        "bounds_checking",
        "secure_coding_practices"
      ],
      "code_differences": {
        "has_differences": true,
        "source_lines": 2,
        "target_lines": 2,
        "character_differences": 2059,
        "similarity_percentage": 12.5
      },
      "vulnerability_location": {
        "vulnerability_present": true,
        "fix_applied": true,
        "code_changed": true,
        "estimated_lines_changed": 0
      }
    },
    {
      "cve_id": "CVE-2016-3183",
      "cwe_id": "CWE-125",
      "cwe_name": "Out-of-bounds Read",
      "project": "uclouvain",
      "severity": "critical",
      "weaponization_score": 8.0,
      "is_critical": true,
      "is_weaponizable": true,
      "is_high_priority_project": false,
      "vulnerable_code": "CWE-125 static void sycc422_to_rgb ( opj_image_t * img ) { int * d0 , * d1 , * d2 , * r , * g , * b ; const int * y , * cb , * cr ; <S2SV_StartBug> unsigned int maxw , maxh , max ; <S2SV_EndBug> int offset , upb ; <S2SV_StartBug> unsigned int i , j ; <S2SV_EndBug> upb = ( int ) img -> comps [ 0 ] . prec ; offset = 1 << ( upb - 1 ) ; upb = ( 1 << upb ) - 1 ; <S2SV_StartBug> maxw = ( unsigned int ) img -> comps [ 0 ] . w ; maxh = ( unsigned int ) img -> comps [ 0 ] . h ; <S2SV_EndBug> max = maxw * maxh ; y = img -> comps [ 0 ] . data ; cb = img -> comps [ 1 ] . data ; cr = img -> comps [ 2 ] . data ; <S2SV_StartBug> d0 = r = ( int * ) malloc ( sizeof ( int ) * ( size_t ) max ) ; <S2SV_EndBug> <S2SV_StartBug> d1 = g = ( int * ) malloc ( sizeof ( int ) * ( size_t ) max ) ; <S2SV_EndBug> <S2SV_StartBug> d2 = b = ( int * ) malloc ( sizeof ( int ) * ( size_t ) max ) ; <S2SV_EndBug> if ( r == NULL || g == NULL || b == NULL ) goto fails ; <S2SV_StartBug> for ( i = 0U ; i < maxh ; ++ i ) <S2SV_EndBug> { <S2SV_StartBug> for ( j = 0U ; j < ( maxw & ~ ( unsigned int ) 1U ) ; j += 2U ) <S2SV_EndBug> { sycc_to_rgb ( offset , upb , * y , * cb , * cr , r , g , b ) ; ++ y ; ++ r ; ++ g ; ++ b ; sycc_to_rgb ( offset , upb , * y , * cb , * cr , r , g , b ) ; ++ y ; ++ r ; ++ g ; ++ b ; ++ cb ; ++ cr ; } <S2SV_StartBug> if ( j < maxw ) { <S2SV_EndBug> sycc_to_rgb ( offset , upb , * y , * cb , * cr , r , g , b ) ; ++ y ; ++ r ; ++ g ; ++ b ; ++ cb ; ++ cr ; } } free ( img -> comps [ 0 ] . data ) ; img -> comps [ 0 ] . data = d0 ; free ( img -> comps [ 1 ] . data ) ; img -> comps [ 1 ] . data = d1 ; free ( img -> comps [ 2 ] . data ) ; img -> comps [ 2 ] . data = d2 ; <S2SV_StartBug> # if defined ( USE_JPWL ) || defined ( USE_MJ2 ) <S2SV_EndBug> <S2SV_StartBug> img -> comps [ 1 ] . w = maxw ; img -> comps [ 1 ] . h = maxh ; <S2SV_EndBug> <S2SV_StartBug> img -> comps [ 2 ] . w = maxw ; img -> comps [ 2 ] . h = maxh ; <S2SV_EndBug> # else img -> comps [ 1 ] . w = ( OPJ_UINT32 ) maxw ; img -> comps [ 1 ] . h = ( OPJ_UINT32 ) maxh ; <S2SV_StartBug> img -> comps [ 2 ] . w = ( OPJ_UINT32 ) maxw ; img -> comps [ 2 ] . h = ( OPJ_UINT32 ) maxh ; <S2SV_EndBug> # endif img -> comps [ 1 ] . dx = img -> comps [ 0 ] . dx ; img -> comps [ 2 ] . dx = img -> comps [ 0 ] . dx ; img -> comps [ 1 ] . dy = img -> comps [ 0 ] . dy ; <S2SV_StartBug> img -> comps [ 2 ] . dy = img -> comps [ 0 ] . dy ; <S2SV_EndBug> return ; fails : <S2SV_StartBug> if ( r ) free ( r ) ; <S2SV_EndBug> <S2SV_StartBug> if ( g ) free ( g ) ; <S2SV_EndBug> <S2SV_StartBug> if ( b ) free ( b ) ; <S2SV_EndBug> }\n",
      "fixed_code": "<S2SV_ModStart> * cr ; size_t <S2SV_ModEnd> maxw , maxh <S2SV_ModStart> maxh , max , offx , loopmaxw <S2SV_ModStart> , upb ; size_t i <S2SV_ModEnd> ; upb = <S2SV_ModStart> maxw = ( size_t <S2SV_ModEnd> ) img -> <S2SV_ModStart> maxh = ( size_t <S2SV_ModEnd> ) img -> <S2SV_ModStart> int ) * <S2SV_ModEnd> max ) ; <S2SV_ModStart> int ) * <S2SV_ModEnd> max ) ; <S2SV_ModStart> int ) * <S2SV_ModEnd> max ) ; <S2SV_ModStart> goto fails ; offx = img -> x0 & 1U ; loopmaxw = maxw - offx ; <S2SV_ModStart> i ) { size_t j ; if ( offx > 0U ) { sycc_to_rgb ( offset , upb , * y , 0 , 0 , r , g , b ) ; ++ y ; ++ r ; ++ g ; ++ b ; } <S2SV_ModStart> j < ( loopmaxw <S2SV_ModEnd> & ~ ( <S2SV_ModStart> & ~ ( size_t <S2SV_ModEnd> ) 1U ) <S2SV_ModStart> ( j < loopmaxw <S2SV_ModEnd> ) { sycc_to_rgb <S2SV_ModStart> = d2 ; <S2SV_ModEnd> img -> comps <S2SV_ModStart> . w = img -> comps [ 2 ] . w = img -> comps [ 0 ] . w ; <S2SV_ModEnd> img -> comps <S2SV_ModStart> . h = <S2SV_ModEnd> img -> comps <S2SV_ModStart> 2 ] . h = img -> comps [ 0 ] . h ; img -> comps [ 1 ] . dx = <S2SV_ModEnd> img -> comps <S2SV_ModStart> 2 ] . dx = img -> comps [ 0 ] . dx ; img -> comps [ 1 ] . dy = <S2SV_ModEnd> img -> comps <S2SV_ModStart> 2 ] . <S2SV_ModEnd> dy = img <S2SV_ModStart> ; img -> color_space = OPJ_CLRSPC_SRGB <S2SV_ModEnd> ; return ; <S2SV_ModStart> ; fails : <S2SV_ModEnd> free ( r <S2SV_ModStart> r ) ; <S2SV_ModEnd> free ( g <S2SV_ModStart> g ) ; <S2SV_ModEnd> free ( b\n",
      "source_code_length": 2587,
      "target_code_length": 1455,
      "vulnerability_patterns": {
        "use_after_free": 9,
        "integer_overflow": 7,
        "null_pointer": 12,
        "memory_leak": 3,
        "total": 31
      },
      "total_patterns": 31,
      "original_address": "https://github.com/uclouvain/openjpeg/commit/15f081c89650dccee4aa4ae66f614c3fdb268767",
      "discovery_time": "2017-02-03T16:59Z",
      "project_commit_id": "uclouvain@openjpeg/15f081c89650dccee4aa4ae66f614c3fdb268767",
      "extraction_time": "2025-08-31T15:41:49.187039",
      "label": 1,
      "vulnerability_type": "out-of-bounds_read",
      "difficulty_level": "advanced",
      "risk_factors": [
        "information_disclosure",
        "memory_corruption",
        "integer_overflow",
        "use_after_free"
      ],
      "attack_vectors": [
        "memory_manipulation",
        "malicious_input",
        "code_analysis",
        "buffer_overflow",
        "reverse_engineering",
        "fuzzing"
      ],
      "mitigation_strategies": [
        "safe_string_functions",
        "dynamic_analysis",
        "code_review",
        "static_analysis",
        "memory_safety_checks",
        "input_validation",
        "fuzzing",
        "bounds_checking",
        "secure_coding_practices"
      ],
      "code_differences": {
        "has_differences": true,
        "source_lines": 2,
        "target_lines": 2,
        "character_differences": 1132,
        "similarity_percentage": 56.81818181818182
      },
      "vulnerability_location": {
        "vulnerability_present": true,
        "fix_applied": true,
        "code_changed": true,
        "estimated_lines_changed": 0
      }
    },
    {
      "cve_id": "CVE-2018-16643",
      "cwe_id": "CWE-20",
      "cwe_name": "Improper Input Validation",
      "project": "ImageMagick",
      "severity": "critical",
      "weaponization_score": 8.0,
      "is_critical": true,
      "is_weaponizable": true,
      "is_high_priority_project": true,
      "vulnerable_code": "CWE-20 static Image * ReadDCMImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { <S2SV_StartBug> # define ThrowDCMException ( exception , message ) { if ( info . scale != ( Quantum * ) NULL ) info . scale = ( Quantum * ) RelinquishMagickMemory ( info . scale ) ; if ( data != ( unsigned char * ) NULL ) data = ( unsigned char * ) RelinquishMagickMemory ( data ) ; if ( graymap != ( int * ) NULL ) graymap = ( int * ) RelinquishMagickMemory ( graymap ) ; if ( bluemap != ( int * ) NULL ) bluemap = ( int * ) RelinquishMagickMemory ( bluemap ) ; if ( greenmap != ( int * ) NULL ) greenmap = ( int * ) RelinquishMagickMemory ( greenmap ) ; if ( redmap != ( int * ) NULL ) redmap = ( int * ) RelinquishMagickMemory ( redmap ) ; if ( stream_info -> offsets != ( ssize_t * ) NULL ) stream_info -> offsets = ( ssize_t * ) RelinquishMagickMemory ( stream_info -> offsets ) ; if ( stream_info != ( DCMStreamInfo * ) NULL ) stream_info = ( DCMStreamInfo * ) RelinquishMagickMemory ( stream_info ) ; ThrowReaderException ( ( exception ) , ( message ) ) ; } <S2SV_EndBug> char explicit_vr [ MagickPathExtent ] , implicit_vr [ MagickPathExtent ] , magick [ MagickPathExtent ] , photometric [ MagickPathExtent ] ; DCMInfo info ; DCMStreamInfo * stream_info ; Image * image ; int * bluemap , datum , * greenmap , * graymap , * redmap ; MagickBooleanType explicit_file , explicit_retry , use_explicit ; MagickOffsetType offset ; register unsigned char * p ; register ssize_t i ; size_t colors , height , length , number_scenes , quantum , status , width ; ssize_t count , scene ; unsigned char * data ; unsigned short group , element ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickCoreSignature ) ; if ( image_info -> debug != MagickFalse ) ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , \"%s\" , image_info -> filename ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickCoreSignature ) ; image = AcquireImage ( image_info , exception ) ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } image -> depth = 8UL ; image -> endian = LSBEndian ; ( void ) memset ( & info , 0 , sizeof ( info ) ) ; data = ( unsigned char * ) NULL ; graymap = ( int * ) NULL ; redmap = ( int * ) NULL ; greenmap = ( int * ) NULL ; bluemap = ( int * ) NULL ; stream_info = ( DCMStreamInfo * ) AcquireMagickMemory ( sizeof ( * stream_info ) ) ; if ( stream_info == ( DCMStreamInfo * ) NULL ) ThrowDCMException ( ResourceLimitError , \"MemoryAllocationFailed\" ) ; ( void ) memset ( stream_info , 0 , sizeof ( * stream_info ) ) ; count = ReadBlob ( image , 128 , ( unsigned char * ) magick ) ; if ( count != 128 ) ThrowDCMException ( CorruptImageError , \"ImproperImageHeader\" ) ; count = ReadBlob ( image , 4 , ( unsigned char * ) magick ) ; if ( ( count != 4 ) || ( LocaleNCompare ( magick , \"DICM\" , 4 ) != 0 ) ) { offset = SeekBlob ( image , 0L , SEEK_SET ) ; if ( offset < 0 ) ThrowDCMException ( CorruptImageError , \"ImproperImageHeader\" ) ; } ( void ) CopyMagickString ( photometric , \"MONOCHROME1<S2SV_blank>\" , MagickPathExtent ) ; info . bits_allocated = 8 ; info . bytes_per_pixel = 1 ; info . depth = 8 ; info . mask = 0xffff ; info . max_value = 255UL ; info . samples_per_pixel = 1 ; info . signed_data = ( ~ 0UL ) ; info . rescale_slope = 1.0 ; data = ( unsigned char * ) NULL ; element = 0 ; explicit_vr [ 2 ] = '\\\\0' ; explicit_file = MagickFalse ; colors = 0 ; redmap = ( int * ) NULL ; greenmap = ( int * ) NULL ; bluemap = ( int * ) NULL ; graymap = ( int * ) NULL ; height = 0 ; number_scenes = 1 ; use_explicit = MagickFalse ; explicit_retry = MagickFalse ; width = 0 ; while ( TellBlob ( image ) < ( MagickOffsetType ) GetBlobSize ( image ) ) { for ( group = 0 ; ( group != 0x7FE0 ) || ( element != 0x0010 ) ; ) { image -> offset = ( ssize_t ) TellBlob ( image ) ; group = ReadBlobLSBShort ( image ) ; element = ReadBlobLSBShort ( image ) ; if ( ( group == 0xfffc ) && ( element == 0xfffc ) ) break ; if ( ( group != 0x0002 ) && ( image -> endian == MSBEndian ) ) { group = ( unsigned short ) ( ( group << 8 ) | ( ( group >> 8 ) & 0xFF ) ) ; element = ( unsigned short ) ( ( element << 8 ) | ( ( element >> 8 ) & 0xFF ) ) ; } quantum = 0 ; for ( i = 0 ; dicom_info [ i ] . group < 0xffff ; i ++ ) if ( ( group == dicom_info [ i ] . group ) && ( element == dicom_info [ i ] . element ) ) break ; ( void ) CopyMagickString ( implicit_vr , dicom_info [ i ] . vr , MagickPathExtent ) ; count = ReadBlob ( image , 2 , ( unsigned char * ) explicit_vr ) ; if ( count != 2 ) ThrowDCMException ( CorruptImageError , \"ImproperImageHeader\" ) ; if ( ( explicit_file == MagickFalse ) && ( group != 0x0002 ) ) explicit_file = ( isupper ( ( unsigned char ) * explicit_vr ) != MagickFalse ) && ( isupper ( ( unsigned char ) * ( explicit_vr + 1 ) ) != MagickFalse ) ? MagickTrue : MagickFalse ; use_explicit = ( ( group == 0x0002 ) && ( explicit_retry == MagickFalse ) ) || ( explicit_file != MagickFalse ) ? MagickTrue : MagickFalse ; if ( ( use_explicit != MagickFalse ) && ( strncmp ( implicit_vr , \"xs\" , 2 ) == 0 ) ) ( void ) CopyMagickString ( implicit_vr , explicit_vr , MagickPathExtent ) ; if ( ( use_explicit == MagickFalse ) || ( strncmp ( implicit_vr , \"!!\" , 2 ) == 0 ) ) { offset = SeekBlob ( image , ( MagickOffsetType ) - 2 , SEEK_CUR ) ; if ( offset < 0 ) ThrowDCMException ( CorruptImageError , \"ImproperImageHeader\" ) ; quantum = 4 ; } else { quantum = 2 ; if ( ( strncmp ( explicit_vr , \"OB\" , 2 ) == 0 ) || ( strncmp ( explicit_vr , \"UN\" , 2 ) == 0 ) || ( strncmp ( explicit_vr , \"OW\" , 2 ) == 0 ) || ( strncmp ( explicit_vr , \"SQ\" , 2 ) == 0 ) ) { ( void ) ReadBlobLSBShort ( image ) ; quantum = 4 ; } } datum = 0 ; if ( quantum == 4 ) { if ( group == 0x0002 ) datum = ReadBlobLSBSignedLong ( image ) ; else datum = ReadBlobSignedLong ( image ) ; } else if ( quantum == 2 ) { if ( group == 0x0002 ) datum = ReadBlobLSBSignedShort ( image ) ; else datum = ReadBlobSignedShort ( image ) ; } quantum = 0 ; length = 1 ; if ( datum != 0 ) { if ( ( strncmp ( implicit_vr , \"OW\" , 2 ) == 0 ) || ( strncmp ( implicit_vr , \"SS\" , 2 ) == 0 ) || ( strncmp ( implicit_vr , \"US\" , 2 ) == 0 ) ) quantum = 2 ; else if ( ( strncmp ( implicit_vr , \"FL\" , 2 ) == 0 ) || ( strncmp ( implicit_vr , \"OF\" , 2 ) == 0 ) || ( strncmp ( implicit_vr , \"SL\" , 2 ) == 0 ) || ( strncmp ( implicit_vr , \"UL\" , 2 ) == 0 ) ) quantum = 4 ; else if ( strncmp ( implicit_vr , \"FD\" , 2 ) == 0 ) quantum = 8 ; else quantum = 1 ; if ( datum != ~ 0 ) length = ( size_t ) datum / quantum ; else { quantum = 0 ; length = 0 ; } } if ( image_info -> verbose != MagickFalse ) { if ( use_explicit == MagickFalse ) explicit_vr [ 0 ] = '\\\\0' ; for ( i = 0 ; dicom_info [ i ] . description != ( char * ) NULL ; i ++ ) if ( ( group == dicom_info [ i ] . group ) && ( element == dicom_info [ i ] . element ) ) break ; ( void ) FormatLocaleFile ( stdout , \"0x%04lX<S2SV_blank>%4ld<S2SV_blank>%s-%s<S2SV_blank>(0x%04lx,0x%04lx)\" , ( unsigned long ) image -> offset , ( long ) length , implicit_vr , explicit_vr , ( unsigned long ) group , ( unsigned long ) element ) ; if ( dicom_info [ i ] . description != ( char * ) NULL ) ( void ) FormatLocaleFile ( stdout , \"<S2SV_blank>%s\" , dicom_info [ i ] . description ) ; ( void ) FormatLocaleFile ( stdout , \":<S2SV_blank>\" ) ; } if ( ( group == 0x7FE0 ) && ( element == 0x0010 ) ) { if ( image_info -> verbose != MagickFalse ) ( void ) FormatLocaleFile ( stdout , \"\\\\n\" ) ; break ; } data = ( unsigned char * ) NULL ; if ( ( length == 1 ) && ( quantum == 1 ) ) datum = ReadBlobByte ( image ) ; else if ( ( length == 1 ) && ( quantum == 2 ) ) { if ( group == 0x0002 ) datum = ReadBlobLSBSignedShort ( image ) ; else datum = ReadBlobSignedShort ( image ) ; } else if ( ( length == 1 ) && ( quantum == 4 ) ) { if ( group == 0x0002 ) datum = ReadBlobLSBSignedLong ( image ) ; else datum = ReadBlobSignedLong ( image ) ; } else if ( ( quantum != 0 ) && ( length != 0 ) ) { if ( length > ( size_t ) GetBlobSize ( image ) ) ThrowDCMException ( CorruptImageError , \"InsufficientImageDataInFile\" ) ; if ( ~ length >= 1 ) data = ( unsigned char * ) AcquireQuantumMemory ( length + 1 , quantum * sizeof ( * data ) ) ; if ( data == ( unsigned char * ) NULL ) ThrowDCMException ( ResourceLimitError , \"MemoryAllocationFailed\" ) ; count = ReadBlob ( image , ( size_t ) quantum * length , data ) ; if ( count != ( ssize_t ) ( quantum * length ) ) { if ( image_info -> verbose != MagickFalse ) ( void ) FormatLocaleFile ( stdout , \"count=%d<S2SV_blank>quantum=%d<S2SV_blank>\" \"length=%d<S2SV_blank>group=%d\\\\n\" , ( int ) count , ( int ) quantum , ( int ) length , ( int ) group ) ; ThrowDCMException ( CorruptImageError , \"InsufficientImageDataInFile\" ) ; } data [ length * quantum ] = '\\\\0' ; } if ( ( ( ( unsigned int ) group << 16 ) | element ) == 0xFFFEE0DD ) { if ( data != ( unsigned char * ) NULL ) data = ( unsigned char * ) RelinquishMagickMemory ( data ) ; continue ; } switch ( group ) { case 0x0002 : { switch ( element ) { case 0x0010 : { char transfer_syntax [ MagickPathExtent ] ; if ( ( datum == 0 ) && ( explicit_retry == MagickFalse ) ) { explicit_retry = MagickTrue ; ( void ) SeekBlob ( image , ( MagickOffsetType ) 0 , SEEK_SET ) ; group = 0 ; element = 0 ; if ( image_info -> verbose != MagickFalse ) ( void ) FormatLocaleFile ( stdout , \"Corrupted<S2SV_blank>image<S2SV_blank>-<S2SV_blank>trying<S2SV_blank>explicit<S2SV_blank>format\\\\n\" ) ; break ; } * transfer_syntax = '\\\\0' ; if ( data != ( unsigned char * ) NULL ) ( void ) CopyMagickString ( transfer_syntax , ( char * ) data , MagickPathExtent ) ; if ( image_info -> verbose != MagickFalse ) ( void ) FormatLocaleFile ( stdout , \"transfer_syntax=%s\\\\n\" , ( const char * ) transfer_syntax ) ; if ( strncmp ( transfer_syntax , \"1.2.840.10008.1.2\" , 17 ) == 0 ) { int subtype , type ; type = 1 ; subtype = 0 ; if ( strlen ( transfer_syntax ) > 17 ) { count = ( ssize_t ) sscanf ( transfer_syntax + 17 , \".%d.%d\" , & type , & subtype ) ; if ( count < 1 ) ThrowDCMException ( CorruptImageError , \"ImproperImageHeader\" ) ; } switch ( type ) { case 1 : { image -> endian = LSBEndian ; break ; } case 2 : { image -> endian = MSBEndian ; break ; } case 4 : { if ( ( subtype >= 80 ) && ( subtype <= 81 ) ) image -> compression = JPEGCompression ; else if ( ( subtype >= 90 ) && ( subtype <= 93 ) ) image -> compression = JPEG2000Compression ; else image -> compression = JPEGCompression ; break ; } case 5 : { image -> compression = RLECompression ; break ; } } } break ; } default : break ; } break ; } case 0x0028 : { switch ( element ) { case 0x0002 : { info . samples_per_pixel = ( size_t ) datum ; if ( ( info . samples_per_pixel == 0 ) || ( info . samples_per_pixel > 4 ) ) ThrowDCMException ( CorruptImageError , \"ImproperImageHeader\" ) ; break ; } case 0x0004 : { if ( data == ( unsigned char * ) NULL ) break ; for ( i = 0 ; i < ( ssize_t ) MagickMin ( length , MagickPathExtent - 1 ) ; i ++ ) photometric [ i ] = ( char ) data [ i ] ; photometric [ i ] = '\\\\0' ; info . polarity = LocaleCompare ( photometric , \"MONOCHROME1<S2SV_blank>\" ) == 0 ? MagickTrue : MagickFalse ; break ; } case 0x0006 : { if ( datum == 1 ) image -> interlace = PlaneInterlace ; break ; } case 0x0008 : { if ( data == ( unsigned char * ) NULL ) break ; number_scenes = StringToUnsignedLong ( ( char * ) data ) ; break ; } case 0x0010 : { height = ( size_t ) datum ; break ; } case 0x0011 : { width = ( size_t ) datum ; break ; } case 0x0100 : { info . bits_allocated = ( size_t ) datum ; info . bytes_per_pixel = 1 ; if ( datum > 8 ) info . bytes_per_pixel = 2 ; info . depth = info . bits_allocated ; if ( ( info . depth == 0 ) || ( info . depth > 32 ) ) ThrowDCMException ( CorruptImageError , \"ImproperImageHeader\" ) ; info . max_value = ( 1UL << info . bits_allocated ) - 1 ; image -> depth = info . depth ; break ; } case 0x0101 : { info . significant_bits = ( size_t ) datum ; info . bytes_per_pixel = 1 ; if ( info . significant_bits > 8 ) info . bytes_per_pixel = 2 ; info . depth = info . significant_bits ; if ( ( info . depth == 0 ) || ( info . depth > 16 ) ) ThrowDCMException ( CorruptImageError , \"ImproperImageHeader\" ) ; info . max_value = ( 1UL << info . significant_bits ) - 1 ; info . mask = ( size_t ) GetQuantumRange ( info . significant_bits ) ; image -> depth = info . depth ; break ; } case 0x0102 : { break ; } case 0x0103 : { info . signed_data = ( size_t ) datum ; break ; } case 0x1050 : { if ( data != ( unsigned char * ) NULL ) info . window_center = StringToDouble ( ( char * ) data , ( char * * ) NULL ) ; break ; } case 0x1051 : { if ( data != ( unsigned char * ) NULL ) info . window_width = StringToDouble ( ( char * ) data , ( char * * ) NULL ) ; break ; } case 0x1052 : { if ( data != ( unsigned char * ) NULL ) info . rescale_intercept = StringToDouble ( ( char * ) data , ( char * * ) NULL ) ; break ; } case 0x1053 : { if ( data != ( unsigned char * ) NULL ) info . rescale_slope = StringToDouble ( ( char * ) data , ( char * * ) NULL ) ; break ; } case 0x1200 : case 0x3006 : { if ( data == ( unsigned char * ) NULL ) break ; colors = ( size_t ) ( length / info . bytes_per_pixel ) ; datum = ( int ) colors ; if ( graymap != ( int * ) NULL ) graymap = ( int * ) RelinquishMagickMemory ( graymap ) ; graymap = ( int * ) AcquireQuantumMemory ( MagickMax ( colors , 65536 ) , sizeof ( * graymap ) ) ; if ( graymap == ( int * ) NULL ) ThrowDCMException ( ResourceLimitError , \"MemoryAllocationFailed\" ) ; ( void ) memset ( graymap , 0 , MagickMax ( colors , 65536 ) * sizeof ( * graymap ) ) ; for ( i = 0 ; i < ( ssize_t ) colors ; i ++ ) if ( info . bytes_per_pixel == 1 ) graymap [ i ] = ( int ) data [ i ] ; else graymap [ i ] = ( int ) ( ( short * ) data ) [ i ] ; break ; } case 0x1201 : { unsigned short index ; if ( data == ( unsigned char * ) NULL ) break ; colors = ( size_t ) ( length / 2 ) ; datum = ( int ) colors ; if ( redmap != ( int * ) NULL ) redmap = ( int * ) RelinquishMagickMemory ( redmap ) ; redmap = ( int * ) AcquireQuantumMemory ( MagickMax ( colors , 65536 ) , sizeof ( * redmap ) ) ; if ( redmap == ( int * ) NULL ) ThrowDCMException ( ResourceLimitError , \"MemoryAllocationFailed\" ) ; ( void ) memset ( redmap , 0 , MagickMax ( colors , 65536 ) * sizeof ( * redmap ) ) ; p = data ; for ( i = 0 ; i < ( ssize_t ) colors ; i ++ ) { if ( image -> endian == MSBEndian ) index = ( unsigned short ) ( ( * p << 8 ) | * ( p + 1 ) ) ; else index = ( unsigned short ) ( * p | ( * ( p + 1 ) << 8 ) ) ; redmap [ i ] = ( int ) index ; p += 2 ; } break ; } case 0x1202 : { unsigned short index ; if ( data == ( unsigned char * ) NULL ) break ; colors = ( size_t ) ( length / 2 ) ; datum = ( int ) colors ; if ( greenmap != ( int * ) NULL ) greenmap = ( int * ) RelinquishMagickMemory ( greenmap ) ; greenmap = ( int * ) AcquireQuantumMemory ( MagickMax ( colors , 65536 ) , sizeof ( * greenmap ) ) ; if ( greenmap == ( int * ) NULL ) ThrowDCMException ( ResourceLimitError , \"MemoryAllocationFailed\" ) ; ( void ) memset ( greenmap , 0 , MagickMax ( colors , 65536 ) * sizeof ( * greenmap ) ) ; p = data ; for ( i = 0 ; i < ( ssize_t ) colors ; i ++ ) { if ( image -> endian == MSBEndian ) index = ( unsigned short ) ( ( * p << 8 ) | * ( p + 1 ) ) ; else index = ( unsigned short ) ( * p | ( * ( p + 1 ) << 8 ) ) ; greenmap [ i ] = ( int ) index ; p += 2 ; } break ; } case 0x1203 : { unsigned short index ; if ( data == ( unsigned char * ) NULL ) break ; colors = ( size_t ) ( length / 2 ) ; datum = ( int ) colors ; if ( bluemap != ( int * ) NULL ) bluemap = ( int * ) RelinquishMagickMemory ( bluemap ) ; bluemap = ( int * ) AcquireQuantumMemory ( MagickMax ( colors , 65536 ) , sizeof ( * bluemap ) ) ; if ( bluemap == ( int * ) NULL ) ThrowDCMException ( ResourceLimitError , \"MemoryAllocationFailed\" ) ; ( void ) memset ( bluemap , 0 , MagickMax ( colors , 65536 ) * sizeof ( * bluemap ) ) ; p = data ; for ( i = 0 ; i < ( ssize_t ) colors ; i ++ ) { if ( image -> endian == MSBEndian ) index = ( unsigned short ) ( ( * p << 8 ) | * ( p + 1 ) ) ; else index = ( unsigned short ) ( * p | ( * ( p + 1 ) << 8 ) ) ; bluemap [ i ] = ( int ) index ; p += 2 ; } break ; } default : break ; } break ; } case 0x2050 : { switch ( element ) { case 0x0020 : { if ( ( data != ( unsigned char * ) NULL ) && ( strncmp ( ( char * ) data , \"INVERSE\" , 7 ) == 0 ) ) info . polarity = MagickTrue ; break ; } default : break ; } break ; } default : break ; } if ( data != ( unsigned char * ) NULL ) { char * attribute ; for ( i = 0 ; dicom_info [ i ] . description != ( char * ) NULL ; i ++ ) if ( ( group == dicom_info [ i ] . group ) && ( element == dicom_info [ i ] . element ) ) break ; if ( dicom_info [ i ] . description != ( char * ) NULL ) { attribute = AcquireString ( \"dcm:\" ) ; ( void ) ConcatenateString ( & attribute , dicom_info [ i ] . description ) ; for ( i = 0 ; i < ( ssize_t ) MagickMax ( length , 4 ) ; i ++ ) if ( isprint ( ( int ) data [ i ] ) == MagickFalse ) break ; if ( ( i == ( ssize_t ) length ) || ( length > 4 ) ) { ( void ) SubstituteString ( & attribute , \"<S2SV_blank>\" , \"\" ) ; ( void ) SetImageProperty ( image , attribute , ( char * ) data , exception ) ; } attribute = DestroyString ( attribute ) ; } } if ( image_info -> verbose != MagickFalse ) { if ( data == ( unsigned char * ) NULL ) ( void ) FormatLocaleFile ( stdout , \"%d\\\\n\" , datum ) ; else { for ( i = 0 ; i < ( ssize_t ) MagickMax ( length , 4 ) ; i ++ ) if ( isprint ( ( int ) data [ i ] ) == MagickFalse ) break ; if ( ( i != ( ssize_t ) length ) && ( length <= 4 ) ) { ssize_t j ; datum = 0 ; for ( j = ( ssize_t ) length - 1 ; j >= 0 ; j -- ) datum = ( 256 * datum + data [ j ] ) ; ( void ) FormatLocaleFile ( stdout , \"%d\" , datum ) ; } else for ( i = 0 ; i < ( ssize_t ) length ; i ++ ) if ( isprint ( ( int ) data [ i ] ) != MagickFalse ) ( void ) FormatLocaleFile ( stdout , \"%c\" , data [ i ] ) ; else ( void ) FormatLocaleFile ( stdout , \"%c\" , '.' ) ; ( void ) FormatLocaleFile ( stdout , \"\\\\n\" ) ; } } if ( data != ( unsigned char * ) NULL ) data = ( unsigned char * ) RelinquishMagickMemory ( data ) ; if ( EOFBlob ( image ) != MagickFalse ) { ThrowFileException ( exception , CorruptImageError , \"UnexpectedEndOfFile\" , image -> filename ) ; break ; } } if ( ( group == 0xfffc ) && ( element == 0xfffc ) ) { Image * last ; last = RemoveLastImageFromList ( & image ) ; if ( last != ( Image * ) NULL ) last = DestroyImage ( last ) ; break ; } if ( ( width == 0 ) || ( height == 0 ) ) ThrowDCMException ( CorruptImageError , \"ImproperImageHeader\" ) ; image -> columns = ( size_t ) width ; image -> rows = ( size_t ) height ; if ( info . signed_data == 0xffff ) info . signed_data = ( size_t ) ( info . significant_bits == 16 ? 1 : 0 ) ; if ( ( image -> compression == JPEGCompression ) || ( image -> compression == JPEG2000Compression ) ) { Image * images ; ImageInfo * read_info ; int c ; for ( i = 0 ; i < ( ssize_t ) stream_info -> remaining ; i ++ ) if ( ReadBlobByte ( image ) == EOF ) break ; ( void ) ( ( ( ssize_t ) ReadBlobLSBShort ( image ) << 16 ) | ReadBlobLSBShort ( image ) ) ; length = ( size_t ) ReadBlobLSBLong ( image ) ; if ( length > ( size_t ) GetBlobSize ( image ) ) ThrowDCMException ( CorruptImageError , \"InsufficientImageDataInFile\" ) ; stream_info -> offset_count = length >> 2 ; if ( stream_info -> offset_count != 0 ) { if ( stream_info -> offsets != ( ssize_t * ) NULL ) stream_info -> offsets = ( ssize_t * ) RelinquishMagickMemory ( stream_info -> offsets ) ; stream_info -> offsets = ( ssize_t * ) AcquireQuantumMemory ( stream_info -> offset_count , sizeof ( * stream_info -> offsets ) ) ; if ( stream_info -> offsets == ( ssize_t * ) NULL ) ThrowDCMException ( ResourceLimitError , \"MemoryAllocationFailed\" ) ; for ( i = 0 ; i < ( ssize_t ) stream_info -> offset_count ; i ++ ) stream_info -> offsets [ i ] = ( ssize_t ) ReadBlobLSBSignedLong ( image ) ; offset = TellBlob ( image ) ; for ( i = 0 ; i < ( ssize_t ) stream_info -> offset_count ; i ++ ) stream_info -> offsets [ i ] += offset ; } read_info = CloneImageInfo ( image_info ) ; SetImageInfoBlob ( read_info , ( void * ) NULL , 0 ) ; images = NewImageList ( ) ; for ( scene = 0 ; scene < ( ssize_t ) number_scenes ; scene ++ ) { char filename [ MagickPathExtent ] ; const char * property ; FILE * file ; Image * jpeg_image ; int unique_file ; unsigned int tag ; tag = ( ( unsigned int ) ReadBlobLSBShort ( image ) << 16 ) | ReadBlobLSBShort ( image ) ; length = ( size_t ) ReadBlobLSBLong ( image ) ; if ( tag == 0xFFFEE0DD ) break ; if ( tag != 0xFFFEE000 ) { read_info = DestroyImageInfo ( read_info ) ; ThrowDCMException ( CorruptImageError , \"ImproperImageHeader\" ) ; } file = ( FILE * ) NULL ; unique_file = AcquireUniqueFileResource ( filename ) ; if ( unique_file != - 1 ) file = fdopen ( unique_file , \"wb\" ) ; if ( file == ( FILE * ) NULL ) { ( void ) RelinquishUniqueFileResource ( filename ) ; ThrowFileException ( exception , FileOpenError , \"UnableToCreateTemporaryFile\" , filename ) ; break ; } for ( c = EOF ; length != 0 ; length -- ) { c = ReadBlobByte ( image ) ; if ( c == EOF ) { ThrowFileException ( exception , CorruptImageError , \"UnexpectedEndOfFile\" , image -> filename ) ; break ; } <S2SV_StartBug> ( void ) fputc ( c , file ) ; <S2SV_EndBug> } ( void ) fclose ( file ) ; if ( c == EOF ) break ; ( void ) FormatLocaleString ( read_info -> filename , MagickPathExtent , \"jpeg:%s\" , filename ) ; if ( image -> compression == JPEG2000Compression ) ( void ) FormatLocaleString ( read_info -> filename , MagickPathExtent , \"j2k:%s\" , filename ) ; jpeg_image = ReadImage ( read_info , exception ) ; if ( jpeg_image != ( Image * ) NULL ) { ResetImagePropertyIterator ( image ) ; property = GetNextImageProperty ( image ) ; while ( property != ( const char * ) NULL ) { ( void ) SetImageProperty ( jpeg_image , property , GetImageProperty ( image , property , exception ) , exception ) ; property = GetNextImageProperty ( image ) ; } AppendImageToList ( & images , jpeg_image ) ; } ( void ) RelinquishUniqueFileResource ( filename ) ; } read_info = DestroyImageInfo ( read_info ) ; if ( stream_info -> offsets != ( ssize_t * ) NULL ) stream_info -> offsets = ( ssize_t * ) RelinquishMagickMemory ( stream_info -> offsets ) ; stream_info = ( DCMStreamInfo * ) RelinquishMagickMemory ( stream_info ) ; if ( info . scale != ( Quantum * ) NULL ) info . scale = ( Quantum * ) RelinquishMagickMemory ( info . scale ) ; if ( graymap != ( int * ) NULL ) graymap = ( int * ) RelinquishMagickMemory ( graymap ) ; if ( bluemap != ( int * ) NULL ) bluemap = ( int * ) RelinquishMagickMemory ( bluemap ) ; if ( greenmap != ( int * ) NULL ) greenmap = ( int * ) RelinquishMagickMemory ( greenmap ) ; if ( redmap != ( int * ) NULL ) redmap = ( int * ) RelinquishMagickMemory ( redmap ) ; image = DestroyImageList ( image ) ; return ( GetFirstImageInList ( images ) ) ; } if ( info . depth != ( 1UL * MAGICKCORE_QUANTUM_DEPTH ) ) { QuantumAny range ; length = ( size_t ) ( GetQuantumRange ( info . depth ) + 1 ) ; if ( length > ( size_t ) GetBlobSize ( image ) ) ThrowDCMException ( CorruptImageError , \"InsufficientImageDataInFile\" ) ; if ( info . scale != ( Quantum * ) NULL ) info . scale = ( Quantum * ) RelinquishMagickMemory ( info . scale ) ; info . scale = ( Quantum * ) AcquireQuantumMemory ( MagickMax ( length , 256 ) , sizeof ( * info . scale ) ) ; if ( info . scale == ( Quantum * ) NULL ) ThrowDCMException ( ResourceLimitError , \"MemoryAllocationFailed\" ) ; ( void ) memset ( info . scale , 0 , MagickMax ( length , 256 ) * sizeof ( * info . scale ) ) ; range = GetQuantumRange ( info . depth ) ; for ( i = 0 ; i <= ( ssize_t ) GetQuantumRange ( info . depth ) ; i ++ ) info . scale [ i ] = ScaleAnyToQuantum ( ( size_t ) i , range ) ; } if ( image -> compression == RLECompression ) { unsigned int tag ; for ( i = 0 ; i < ( ssize_t ) stream_info -> remaining ; i ++ ) { int c ; c = ReadBlobByte ( image ) ; if ( c == EOF ) break ; } tag = ( ( unsigned int ) ReadBlobLSBShort ( image ) << 16 ) | ReadBlobLSBShort ( image ) ; ( void ) tag ; length = ( size_t ) ReadBlobLSBLong ( image ) ; if ( length > ( size_t ) GetBlobSize ( image ) ) ThrowDCMException ( CorruptImageError , \"InsufficientImageDataInFile\" ) ; stream_info -> offset_count = length >> 2 ; if ( stream_info -> offset_count != 0 ) { stream_info -> offsets = ( ssize_t * ) AcquireQuantumMemory ( stream_info -> offset_count , sizeof ( * stream_info -> offsets ) ) ; if ( stream_info -> offsets == ( ssize_t * ) NULL ) ThrowDCMException ( ResourceLimitError , \"MemoryAllocationFailed\" ) ; for ( i = 0 ; i < ( ssize_t ) stream_info -> offset_count ; i ++ ) { stream_info -> offsets [ i ] = ( ssize_t ) ReadBlobLSBSignedLong ( image ) ; if ( EOFBlob ( image ) != MagickFalse ) break ; } offset = TellBlob ( image ) + 8 ; for ( i = 0 ; i < ( ssize_t ) stream_info -> offset_count ; i ++ ) stream_info -> offsets [ i ] += offset ; } } for ( scene = 0 ; scene < ( ssize_t ) number_scenes ; scene ++ ) { if ( image_info -> ping != MagickFalse ) break ; image -> columns = ( size_t ) width ; image -> rows = ( size_t ) height ; image -> depth = info . depth ; status = SetImageExtent ( image , image -> columns , image -> rows , exception ) ; if ( status == MagickFalse ) break ; image -> colorspace = RGBColorspace ; ( void ) SetImageBackgroundColor ( image , exception ) ; if ( ( image -> colormap == ( PixelInfo * ) NULL ) && ( info . samples_per_pixel == 1 ) ) { int index ; size_t one ; one = 1 ; if ( colors == 0 ) colors = one << info . depth ; if ( AcquireImageColormap ( image , colors , exception ) == MagickFalse ) ThrowDCMException ( ResourceLimitError , \"MemoryAllocationFailed\" ) ; if ( redmap != ( int * ) NULL ) for ( i = 0 ; i < ( ssize_t ) colors ; i ++ ) { index = redmap [ i ] ; if ( ( info . scale != ( Quantum * ) NULL ) && ( index >= 0 ) && ( index <= ( int ) info . max_value ) ) index = ( int ) info . scale [ index ] ; image -> colormap [ i ] . red = ( MagickRealType ) index ; } if ( greenmap != ( int * ) NULL ) for ( i = 0 ; i < ( ssize_t ) colors ; i ++ ) { index = greenmap [ i ] ; if ( ( info . scale != ( Quantum * ) NULL ) && ( index >= 0 ) && ( index <= ( int ) info . max_value ) ) index = ( int ) info . scale [ index ] ; image -> colormap [ i ] . green = ( MagickRealType ) index ; } if ( bluemap != ( int * ) NULL ) for ( i = 0 ; i < ( ssize_t ) colors ; i ++ ) { index = bluemap [ i ] ; if ( ( info . scale != ( Quantum * ) NULL ) && ( index >= 0 ) && ( index <= ( int ) info . max_value ) ) index = ( int ) info . scale [ index ] ; image -> colormap [ i ] . blue = ( MagickRealType ) index ; } if ( graymap != ( int * ) NULL ) for ( i = 0 ; i < ( ssize_t ) colors ; i ++ ) { index = graymap [ i ] ; if ( ( info . scale != ( Quantum * ) NULL ) && ( index >= 0 ) && ( index <= ( int ) info . max_value ) ) index = ( int ) info . scale [ index ] ; image -> colormap [ i ] . red = ( MagickRealType ) index ; image -> colormap [ i ] . green = ( MagickRealType ) index ; image -> colormap [ i ] . blue = ( MagickRealType ) index ; } } if ( image -> compression == RLECompression ) { unsigned int tag ; for ( i = 0 ; i < ( ssize_t ) stream_info -> remaining ; i ++ ) { int c ; c = ReadBlobByte ( image ) ; if ( c == EOF ) break ; } tag = ( ( unsigned int ) ReadBlobLSBShort ( image ) << 16 ) | ReadBlobLSBShort ( image ) ; stream_info -> remaining = ( size_t ) ReadBlobLSBLong ( image ) ; if ( ( tag != 0xFFFEE000 ) || ( stream_info -> remaining <= 64 ) || ( EOFBlob ( image ) != MagickFalse ) ) { if ( stream_info -> offsets != ( ssize_t * ) NULL ) stream_info -> offsets = ( ssize_t * ) RelinquishMagickMemory ( stream_info -> offsets ) ; ThrowDCMException ( CorruptImageError , \"ImproperImageHeader\" ) ; } stream_info -> count = 0 ; stream_info -> segment_count = ReadBlobLSBLong ( image ) ; for ( i = 0 ; i < 15 ; i ++ ) stream_info -> segments [ i ] = ( ssize_t ) ReadBlobLSBSignedLong ( image ) ; stream_info -> remaining -= 64 ; if ( stream_info -> segment_count > 1 ) { info . bytes_per_pixel = 1 ; info . depth = 8 ; if ( stream_info -> offset_count > 0 ) ( void ) SeekBlob ( image , ( MagickOffsetType ) stream_info -> offsets [ 0 ] + stream_info -> segments [ 0 ] , SEEK_SET ) ; } } if ( ( info . samples_per_pixel > 1 ) && ( image -> interlace == PlaneInterlace ) ) { register ssize_t x ; register Quantum * q ; ssize_t y ; for ( i = 0 ; i < ( ssize_t ) info . samples_per_pixel ; i ++ ) { for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { q = GetAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { switch ( ( int ) i ) { case 0 : { SetPixelRed ( image , ScaleCharToQuantum ( ( unsigned char ) ReadDCMByte ( stream_info , image ) ) , q ) ; break ; } case 1 : { SetPixelGreen ( image , ScaleCharToQuantum ( ( unsigned char ) ReadDCMByte ( stream_info , image ) ) , q ) ; break ; } case 2 : { SetPixelBlue ( image , ScaleCharToQuantum ( ( unsigned char ) ReadDCMByte ( stream_info , image ) ) , q ) ; break ; } case 3 : { SetPixelAlpha ( image , ScaleCharToQuantum ( ( unsigned char ) ReadDCMByte ( stream_info , image ) ) , q ) ; break ; } default : break ; } q += GetPixelChannels ( image ) ; } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ; if ( status == MagickFalse ) break ; } } } } else { const char * option ; option = GetImageOption ( image_info , \"dcm:display-range\" ) ; if ( option != ( const char * ) NULL ) { if ( LocaleCompare ( option , \"reset\" ) == 0 ) info . window_width = 0 ; } option = GetImageOption ( image_info , \"dcm:window\" ) ; if ( option != ( char * ) NULL ) { GeometryInfo geometry_info ; MagickStatusType flags ; flags = ParseGeometry ( option , & geometry_info ) ; if ( flags & RhoValue ) info . window_center = geometry_info . rho ; if ( flags & SigmaValue ) info . window_width = geometry_info . sigma ; info . rescale = MagickTrue ; } option = GetImageOption ( image_info , \"dcm:rescale\" ) ; if ( option != ( char * ) NULL ) info . rescale = IsStringTrue ( option ) ; if ( ( info . window_center != 0 ) && ( info . window_width == 0 ) ) info . window_width = info . window_center ; status = ReadDCMPixels ( image , & info , stream_info , MagickTrue , exception ) ; if ( ( status != MagickFalse ) && ( stream_info -> segment_count > 1 ) ) { if ( stream_info -> offset_count > 0 ) ( void ) SeekBlob ( image , ( MagickOffsetType ) stream_info -> offsets [ 0 ] + stream_info -> segments [ 1 ] , SEEK_SET ) ; ( void ) ReadDCMPixels ( image , & info , stream_info , MagickFalse , exception ) ; } } if ( SetImageGray ( image , exception ) != MagickFalse ) ( void ) SetImageColorspace ( image , GRAYColorspace , exception ) ; if ( EOFBlob ( image ) != MagickFalse ) { ThrowFileException ( exception , CorruptImageError , \"UnexpectedEndOfFile\" , image -> filename ) ; break ; } if ( image_info -> number_scenes != 0 ) if ( image -> scene >= ( image_info -> scene + image_info -> number_scenes - 1 ) ) break ; if ( scene < ( ssize_t ) ( number_scenes - 1 ) ) { AcquireNextImage ( image_info , image , exception ) ; if ( GetNextImageInList ( image ) == ( Image * ) NULL ) { status = MagickFalse ; break ; } image = SyncNextImageInList ( image ) ; status = SetImageProgress ( image , LoadImagesTag , TellBlob ( image ) , GetBlobSize ( image ) ) ; if ( status == MagickFalse ) break ; } } if ( TellBlob ( image ) < ( MagickOffsetType ) GetBlobSize ( image ) ) { AcquireNextImage ( image_info , image , exception ) ; if ( GetNextImageInList ( image ) == ( Image * ) NULL ) { status = MagickFalse ; break ; } image = SyncNextImageInList ( image ) ; status = SetImageProgress ( image , LoadImagesTag , TellBlob ( image ) , GetBlobSize ( image ) ) ; if ( status == MagickFalse ) break ; } } if ( stream_info -> offsets != ( ssize_t * ) NULL ) stream_info -> offsets = ( ssize_t * ) RelinquishMagickMemory ( stream_info -> offsets ) ; stream_info = ( DCMStreamInfo * ) RelinquishMagickMemory ( stream_info ) ; if ( info . scale != ( Quantum * ) NULL ) info . scale = ( Quantum * ) RelinquishMagickMemory ( info . scale ) ; if ( graymap != ( int * ) NULL ) graymap = ( int * ) RelinquishMagickMemory ( graymap ) ; if ( bluemap != ( int * ) NULL ) bluemap = ( int * ) RelinquishMagickMemory ( bluemap ) ; if ( greenmap != ( int * ) NULL ) greenmap = ( int * ) RelinquishMagickMemory ( greenmap ) ; if ( redmap != ( int * ) NULL ) redmap = ( int * ) RelinquishMagickMemory ( redmap ) ; ( void ) CloseBlob ( image ) ; if ( status == MagickFalse ) return ( DestroyImageList ( image ) ) ; return ( GetFirstImageInList ( image ) ) ; }\n",
      "fixed_code": "<S2SV_ModStart> , message ) \\\\\\n{ <S2SV_ModEnd> if ( info <S2SV_ModStart> ) ) ; \\\\\\n} <S2SV_ModEnd> char explicit_vr [ <S2SV_ModStart> break ; } if ( <S2SV_ModEnd> fputc ( c <S2SV_ModStart> , file ) != c ) break\n",
      "source_code_length": 32856,
      "target_code_length": 212,
      "vulnerability_patterns": {
        "buffer_overflow": 1,
        "integer_overflow": 2,
        "null_pointer": 13,
        "total": 16
      },
      "total_patterns": 16,
      "original_address": "https://github.com/ImageMagick/ImageMagick/commit/6b6bff054d569a77973f2140c0e86366e6168a6c",
      "discovery_time": "2018-09-06T22:29Z",
      "project_commit_id": "ImageMagick@ImageMagick/6b6bff054d569a77973f2140c0e86366e6168a6c",
      "extraction_time": "2025-08-31T15:41:49.187084",
      "label": 1,
      "vulnerability_type": "improper_input_validation",
      "difficulty_level": "advanced",
      "risk_factors": [
        "critical_infrastructure",
        "buffer_overflow"
      ],
      "attack_vectors": [
        "fuzzing",
        "code_analysis",
        "reverse_engineering"
      ],
      "mitigation_strategies": [
        "dynamic_analysis",
        "static_analysis",
        "fuzzing",
        "code_review",
        "secure_coding_practices"
      ],
      "code_differences": {
        "has_differences": true,
        "source_lines": 2,
        "target_lines": 2,
        "character_differences": 32644,
        "similarity_percentage": 4.092071611253197
      },
      "vulnerability_location": {
        "vulnerability_present": true,
        "fix_applied": true,
        "code_changed": true,
        "estimated_lines_changed": 0
      }
    },
    {
      "cve_id": "CVE-2017-7487",
      "cwe_id": "CWE-416",
      "cwe_name": "Use After Free",
      "project": "torvalds",
      "severity": "critical",
      "weaponization_score": 8.0,
      "is_critical": true,
      "is_weaponizable": true,
      "is_high_priority_project": false,
      "vulnerable_code": "CWE-416 static int ipxitf_ioctl ( unsigned int cmd , void __user * arg ) { int rc = - EINVAL ; struct ifreq ifr ; int val ; switch ( cmd ) { case SIOCSIFADDR : { struct sockaddr_ipx * sipx ; struct ipx_interface_definition f ; rc = - EFAULT ; if ( copy_from_user ( & ifr , arg , sizeof ( ifr ) ) ) break ; sipx = ( struct sockaddr_ipx * ) & ifr . ifr_addr ; rc = - EINVAL ; if ( sipx -> sipx_family != AF_IPX ) break ; f . ipx_network = sipx -> sipx_network ; memcpy ( f . ipx_device , ifr . ifr_name , sizeof ( f . ipx_device ) ) ; memcpy ( f . ipx_node , sipx -> sipx_node , IPX_NODE_LEN ) ; f . ipx_dlink_type = sipx -> sipx_type ; f . ipx_special = sipx -> sipx_special ; if ( sipx -> sipx_action == IPX_DLTITF ) rc = ipxitf_delete ( & f ) ; else rc = ipxitf_create ( & f ) ; break ; } case SIOCGIFADDR : { struct sockaddr_ipx * sipx ; struct ipx_interface * ipxif ; struct net_device * dev ; rc = - EFAULT ; if ( copy_from_user ( & ifr , arg , sizeof ( ifr ) ) ) break ; sipx = ( struct sockaddr_ipx * ) & ifr . ifr_addr ; dev = __dev_get_by_name ( & init_net , ifr . ifr_name ) ; rc = - ENODEV ; if ( ! dev ) break ; ipxif = ipxitf_find_using_phys ( dev , ipx_map_frame_type ( sipx -> sipx_type ) ) ; rc = - EADDRNOTAVAIL ; if ( ! ipxif ) break ; sipx -> sipx_family = AF_IPX ; sipx -> sipx_network = ipxif -> if_netnum ; memcpy ( sipx -> sipx_node , ipxif -> if_node , sizeof ( sipx -> sipx_node ) ) ; <S2SV_StartBug> rc = - EFAULT ; <S2SV_EndBug> <S2SV_StartBug> if ( copy_to_user ( arg , & ifr , sizeof ( ifr ) ) ) <S2SV_EndBug> break ; <S2SV_StartBug> ipxitf_put ( ipxif ) ; <S2SV_EndBug> rc = 0 ; break ; } case SIOCAIPXITFCRT : rc = - EFAULT ; if ( get_user ( val , ( unsigned char __user * ) arg ) ) break ; rc = 0 ; ipxcfg_auto_create_interfaces = val ; break ; case SIOCAIPXPRISLT : rc = - EFAULT ; if ( get_user ( val , ( unsigned char __user * ) arg ) ) break ; rc = 0 ; ipxcfg_set_auto_select ( val ) ; break ; } return rc ; }\n",
      "fixed_code": "<S2SV_ModStart> ; rc = 0 ; if ( copy_to_user ( arg , & ifr , sizeof ( ifr ) ) ) rc = <S2SV_ModStart> - EFAULT ; <S2SV_ModEnd> ipxitf_put ( ipxif <S2SV_ModStart> ( ipxif ) <S2SV_ModEnd> ; break ;\n",
      "source_code_length": 1945,
      "target_code_length": 195,
      "vulnerability_patterns": {
        "buffer_overflow": 3,
        "null_pointer": 17,
        "total": 20
      },
      "total_patterns": 20,
      "original_address": "https://github.com/torvalds/linux/commit/ee0d8d8482345ff97a75a7d747efc309f13b0d80",
      "discovery_time": "2017-05-14T22:29Z",
      "project_commit_id": "torvalds@linux/ee0d8d8482345ff97a75a7d747efc309f13b0d80",
      "extraction_time": "2025-08-31T15:41:49.187365",
      "label": 1,
      "vulnerability_type": "use_after_free",
      "difficulty_level": "advanced",
      "risk_factors": [
        "system_crash",
        "denial_of_service",
        "memory_corruption",
        "buffer_overflow"
      ],
      "attack_vectors": [
        "memory_manipulation",
        "null_pointer",
        "code_analysis",
        "reverse_engineering",
        "use_after_free",
        "fuzzing"
      ],
      "mitigation_strategies": [
        "null_pointer_checks",
        "fuzzing",
        "dynamic_analysis",
        "memory_management",
        "static_analysis",
        "use_after_free_prevention",
        "code_review",
        "secure_coding_practices"
      ],
      "code_differences": {
        "has_differences": true,
        "source_lines": 2,
        "target_lines": 2,
        "character_differences": 1750,
        "similarity_percentage": 20.0
      },
      "vulnerability_location": {
        "vulnerability_present": true,
        "fix_applied": true,
        "code_changed": true,
        "estimated_lines_changed": 0
      }
    },
    {
      "cve_id": "CVE-2017-18344",
      "cwe_id": "CWE-125",
      "cwe_name": "Out-of-bounds Read",
      "project": "torvalds",
      "severity": "critical",
      "weaponization_score": 8.0,
      "is_critical": true,
      "is_weaponizable": true,
      "is_high_priority_project": false,
      "vulnerable_code": "CWE-125 int common_timer_set ( struct k_itimer * timr , int flags , struct itimerspec64 * new_setting , struct itimerspec64 * old_setting ) { const struct k_clock * kc = timr -> kclock ; bool sigev_none ; ktime_t expires ; if ( old_setting ) common_timer_get ( timr , old_setting ) ; timr -> it_interval = 0 ; if ( kc -> timer_try_to_cancel ( timr ) < 0 ) return TIMER_RETRY ; timr -> it_active = 0 ; timr -> it_requeue_pending = ( timr -> it_requeue_pending + 2 ) & ~ REQUEUE_PENDING ; timr -> it_overrun_last = 0 ; if ( ! new_setting -> it_value . tv_sec && ! new_setting -> it_value . tv_nsec ) return 0 ; timr -> it_interval = timespec64_to_ktime ( new_setting -> it_interval ) ; expires = timespec64_to_ktime ( new_setting -> it_value ) ; <S2SV_StartBug> sigev_none = ( timr -> it_sigev_notify & ~ SIGEV_THREAD_ID ) == SIGEV_NONE ; <S2SV_EndBug> kc -> timer_arm ( timr , expires , flags & TIMER_ABSTIME , sigev_none ) ; timr -> it_active = ! sigev_none ; return 0 ; }\n",
      "fixed_code": "<S2SV_ModStart> ; sigev_none = <S2SV_ModEnd> timr -> it_sigev_notify <S2SV_ModStart> timr -> it_sigev_notify <S2SV_ModEnd> == SIGEV_NONE ;\n",
      "source_code_length": 973,
      "target_code_length": 139,
      "vulnerability_patterns": {
        "use_after_free": 5,
        "null_pointer": 15,
        "total": 20
      },
      "total_patterns": 20,
      "original_address": "https://github.com/torvalds/linux/commit/cef31d9af908243421258f1df35a4a644604efbe",
      "discovery_time": "2018-07-26T19:29Z",
      "project_commit_id": "torvalds@linux/cef31d9af908243421258f1df35a4a644604efbe",
      "extraction_time": "2025-08-31T15:41:49.187414",
      "label": 1,
      "vulnerability_type": "out-of-bounds_read",
      "difficulty_level": "advanced",
      "risk_factors": [
        "information_disclosure",
        "memory_corruption",
        "integer_overflow",
        "use_after_free"
      ],
      "attack_vectors": [
        "memory_manipulation",
        "malicious_input",
        "code_analysis",
        "buffer_overflow",
        "reverse_engineering",
        "fuzzing"
      ],
      "mitigation_strategies": [
        "safe_string_functions",
        "dynamic_analysis",
        "code_review",
        "static_analysis",
        "memory_safety_checks",
        "input_validation",
        "fuzzing",
        "bounds_checking",
        "secure_coding_practices"
      ],
      "code_differences": {
        "has_differences": true,
        "source_lines": 2,
        "target_lines": 2,
        "character_differences": 834,
        "similarity_percentage": 13.333333333333334
      },
      "vulnerability_location": {
        "vulnerability_present": true,
        "fix_applied": true,
        "code_changed": true,
        "estimated_lines_changed": 0
      }
    },
    {
      "cve_id": "CVE-2019-11811",
      "cwe_id": "CWE-416",
      "cwe_name": "Use After Free",
      "project": "torvalds",
      "severity": "critical",
      "weaponization_score": 8.0,
      "is_critical": true,
      "is_weaponizable": true,
      "is_high_priority_project": false,
      "vulnerable_code": "CWE-416 static int try_smi_init ( struct smi_info * new_smi ) { int rv = 0 ; int i ; char * init_name = NULL ; pr_info ( \"Trying<S2SV_blank>%s-specified<S2SV_blank>%s<S2SV_blank>state<S2SV_blank>machine<S2SV_blank>at<S2SV_blank>%s<S2SV_blank>address<S2SV_blank>0x%lx,<S2SV_blank>slave<S2SV_blank>address<S2SV_blank>0x%x,<S2SV_blank>irq<S2SV_blank>%d\\\\n\" , ipmi_addr_src_to_str ( new_smi -> io . addr_source ) , si_to_str [ new_smi -> io . si_type ] , addr_space_to_str [ new_smi -> io . addr_type ] , new_smi -> io . addr_data , new_smi -> io . slave_addr , new_smi -> io . irq ) ; switch ( new_smi -> io . si_type ) { case SI_KCS : new_smi -> handlers = & kcs_smi_handlers ; break ; case SI_SMIC : new_smi -> handlers = & smic_smi_handlers ; break ; case SI_BT : new_smi -> handlers = & bt_smi_handlers ; break ; default : rv = - EIO ; goto out_err ; } new_smi -> si_num = smi_num ; if ( ! new_smi -> io . dev ) { init_name = kasprintf ( GFP_KERNEL , \"ipmi_si.%d\" , new_smi -> si_num ) ; new_smi -> pdev = platform_device_alloc ( \"ipmi_si\" , new_smi -> si_num ) ; if ( ! new_smi -> pdev ) { pr_err ( \"Unable<S2SV_blank>to<S2SV_blank>allocate<S2SV_blank>platform<S2SV_blank>device\\\\n\" ) ; rv = - ENOMEM ; goto out_err ; } new_smi -> io . dev = & new_smi -> pdev -> dev ; new_smi -> io . dev -> driver = & ipmi_platform_driver . driver ; new_smi -> io . dev -> init_name = init_name ; } new_smi -> si_sm = kmalloc ( new_smi -> handlers -> size ( ) , GFP_KERNEL ) ; if ( ! new_smi -> si_sm ) { rv = - ENOMEM ; goto out_err ; } new_smi -> io . io_size = new_smi -> handlers -> init_data ( new_smi -> si_sm , & new_smi -> io ) ; rv = new_smi -> io . io_setup ( & new_smi -> io ) ; if ( rv ) { dev_err ( new_smi -> io . dev , \"Could<S2SV_blank>not<S2SV_blank>set<S2SV_blank>up<S2SV_blank>I/O<S2SV_blank>space\\\\n\" ) ; goto out_err ; } if ( new_smi -> handlers -> detect ( new_smi -> si_sm ) ) { if ( new_smi -> io . addr_source ) dev_err ( new_smi -> io . dev , \"Interface<S2SV_blank>detection<S2SV_blank>failed\\\\n\" ) ; rv = - ENODEV ; goto out_err ; } rv = try_get_dev_id ( new_smi ) ; if ( rv ) { if ( new_smi -> io . addr_source ) dev_err ( new_smi -> io . dev , \"There<S2SV_blank>appears<S2SV_blank>to<S2SV_blank>be<S2SV_blank>no<S2SV_blank>BMC<S2SV_blank>at<S2SV_blank>this<S2SV_blank>location\\\\n\" ) ; goto out_err ; } setup_oem_data_handler ( new_smi ) ; setup_xaction_handlers ( new_smi ) ; check_for_broken_irqs ( new_smi ) ; new_smi -> waiting_msg = NULL ; new_smi -> curr_msg = NULL ; atomic_set ( & new_smi -> req_events , 0 ) ; new_smi -> run_to_completion = false ; for ( i = 0 ; i < SI_NUM_STATS ; i ++ ) atomic_set ( & new_smi -> stats [ i ] , 0 ) ; new_smi -> interrupt_disabled = true ; atomic_set ( & new_smi -> need_watch , 0 ) ; rv = try_enable_event_buffer ( new_smi ) ; if ( rv == 0 ) new_smi -> has_event_buffer = true ; start_clear_flags ( new_smi ) ; if ( new_smi -> io . irq ) { new_smi -> interrupt_disabled = false ; atomic_set ( & new_smi -> req_events , 1 ) ; } if ( new_smi -> pdev && ! new_smi -> pdev_registered ) { rv = platform_device_add ( new_smi -> pdev ) ; if ( rv ) { dev_err ( new_smi -> io . dev , \"Unable<S2SV_blank>to<S2SV_blank>register<S2SV_blank>system<S2SV_blank>interface<S2SV_blank>device:<S2SV_blank>%d\\\\n\" , rv ) ; goto out_err ; } new_smi -> pdev_registered = true ; } dev_set_drvdata ( new_smi -> io . dev , new_smi ) ; rv = device_add_group ( new_smi -> io . dev , & ipmi_si_dev_attr_group ) ; if ( rv ) { dev_err ( new_smi -> io . dev , \"Unable<S2SV_blank>to<S2SV_blank>add<S2SV_blank>device<S2SV_blank>attributes:<S2SV_blank>error<S2SV_blank>%d\\\\n\" , rv ) ; goto out_err ; } new_smi -> dev_group_added = true ; rv = ipmi_register_smi ( & handlers , new_smi , new_smi -> io . dev , new_smi -> io . slave_addr ) ; if ( rv ) { dev_err ( new_smi -> io . dev , \"Unable<S2SV_blank>to<S2SV_blank>register<S2SV_blank>device:<S2SV_blank>error<S2SV_blank>%d\\\\n\" , rv ) ; goto out_err ; } smi_num ++ ; dev_info ( new_smi -> io . dev , \"IPMI<S2SV_blank>%s<S2SV_blank>interface<S2SV_blank>initialized\\\\n\" , si_to_str [ new_smi -> io . si_type ] ) ; WARN_ON ( new_smi -> io . dev -> init_name != NULL ) ; out_err : <S2SV_StartBug> kfree ( init_name ) ; <S2SV_EndBug> return rv ; }\n",
      "fixed_code": "<S2SV_ModStart> ; out_err : if ( rv && new_smi -> io . io_cleanup ) { new_smi -> io . io_cleanup ( & new_smi -> io ) ; new_smi -> io . io_cleanup = NULL ; }\n",
      "source_code_length": 4218,
      "target_code_length": 157,
      "vulnerability_patterns": {
        "use_after_free": 72,
        "integer_overflow": 2,
        "null_pointer": 69,
        "memory_leak": 1,
        "total": 144
      },
      "total_patterns": 144,
      "original_address": "https://github.com/torvalds/linux/commit/401e7e88d4ef80188ffa07095ac00456f901b8c4",
      "discovery_time": "2019-05-07T14:29Z",
      "project_commit_id": "torvalds@linux/401e7e88d4ef80188ffa07095ac00456f901b8c4",
      "extraction_time": "2025-08-31T15:41:49.187448",
      "label": 1,
      "vulnerability_type": "use_after_free",
      "difficulty_level": "advanced",
      "risk_factors": [
        "system_crash",
        "denial_of_service",
        "memory_corruption",
        "use_after_free"
      ],
      "attack_vectors": [
        "memory_manipulation",
        "null_pointer",
        "code_analysis",
        "reverse_engineering",
        "use_after_free",
        "fuzzing"
      ],
      "mitigation_strategies": [
        "null_pointer_checks",
        "fuzzing",
        "dynamic_analysis",
        "memory_management",
        "static_analysis",
        "use_after_free_prevention",
        "code_review",
        "secure_coding_practices"
      ],
      "code_differences": {
        "has_differences": true,
        "source_lines": 2,
        "target_lines": 2,
        "character_differences": 4061,
        "similarity_percentage": 13.492063492063492
      },
      "vulnerability_location": {
        "vulnerability_present": true,
        "fix_applied": true,
        "code_changed": true,
        "estimated_lines_changed": 0
      }
    },
    {
      "cve_id": "CVE-2017-6497",
      "cwe_id": "CWE-476",
      "cwe_name": "NULL Pointer Dereference",
      "project": "ImageMagick",
      "severity": "critical",
      "weaponization_score": 8.0,
      "is_critical": true,
      "is_weaponizable": true,
      "is_high_priority_project": true,
      "vulnerable_code": "CWE-476 static MagickBooleanType ReadPSDChannel ( Image * image , const ImageInfo * image_info , const PSDInfo * psd_info , LayerInfo * layer_info , const size_t channel , const PSDCompressionType compression , ExceptionInfo * exception ) { Image * channel_image , * mask ; MagickOffsetType offset ; MagickBooleanType status ; channel_image = image ; mask = ( Image * ) NULL ; if ( layer_info -> channel_info [ channel ] . type < - 1 ) { const char * option ; option = GetImageOption ( image_info , \"psd:preserve-opacity-mask\" ) ; if ( ( layer_info -> channel_info [ channel ] . type != - 2 ) || ( layer_info -> mask . flags > 2 ) || ( ( layer_info -> mask . flags & 0x02 ) && ( IsStringTrue ( option ) == MagickFalse ) ) ) { SeekBlob ( image , layer_info -> channel_info [ channel ] . size - 2 , SEEK_CUR ) ; return ( MagickTrue ) ; } mask = CloneImage ( image , layer_info -> mask . page . width , layer_info -> mask . page . height , MagickFalse , exception ) ; <S2SV_StartBug> mask -> matte = MagickFalse ; <S2SV_EndBug> <S2SV_StartBug> channel_image = mask ; <S2SV_EndBug> } offset = TellBlob ( image ) ; status = MagickTrue ; switch ( compression ) { case Raw : status = ReadPSDChannelRaw ( channel_image , psd_info -> channels , layer_info -> channel_info [ channel ] . type , exception ) ; break ; case RLE : { MagickOffsetType * sizes ; sizes = ReadPSDRLESizes ( channel_image , psd_info , channel_image -> rows ) ; if ( sizes == ( MagickOffsetType * ) NULL ) ThrowBinaryException ( ResourceLimitError , \"MemoryAllocationFailed\" , image -> filename ) ; status = ReadPSDChannelRLE ( channel_image , psd_info , layer_info -> channel_info [ channel ] . type , sizes , exception ) ; sizes = ( MagickOffsetType * ) RelinquishMagickMemory ( sizes ) ; } break ; case ZipWithPrediction : case ZipWithoutPrediction : # ifdef MAGICKCORE_ZLIB_DELEGATE status = ReadPSDChannelZip ( channel_image , layer_info -> channels , layer_info -> channel_info [ channel ] . type , compression , layer_info -> channel_info [ channel ] . size - 2 , exception ) ; # else ( void ) ThrowMagickException ( exception , GetMagickModule ( ) , MissingDelegateWarning , \"DelegateLibrarySupportNotBuiltIn\" , \"\\'%s\\'<S2SV_blank>(ZLIB)\" , image -> filename ) ; # endif break ; default : ( void ) ThrowMagickException ( exception , GetMagickModule ( ) , TypeWarning , \"CompressionNotSupported\" , \"\\'%.20g\\'\" , ( double ) compression ) ; break ; } SeekBlob ( image , offset + layer_info -> channel_info [ channel ] . size - 2 , SEEK_SET ) ; if ( status == MagickFalse ) { if ( mask != ( Image * ) NULL ) DestroyImage ( mask ) ; ThrowBinaryException ( CoderError , \"UnableToDecompressImage\" , image -> filename ) ; } layer_info -> mask . image = mask ; return ( status ) ; }\n",
      "fixed_code": "<S2SV_ModStart> exception ) ; if ( mask != ( Image * ) NULL ) { <S2SV_ModStart> = mask ; }\n",
      "source_code_length": 2745,
      "target_code_length": 91,
      "vulnerability_patterns": {
        "null_pointer": 20,
        "total": 20
      },
      "total_patterns": 20,
      "original_address": "https://github.com/ImageMagick/ImageMagick/commit/7f2dc7a1afc067d0c89f12c82bcdec0445fb1b94",
      "discovery_time": "2017-03-06T02:59Z",
      "project_commit_id": "ImageMagick@ImageMagick/7f2dc7a1afc067d0c89f12c82bcdec0445fb1b94",
      "extraction_time": "2025-08-31T15:41:49.187524",
      "label": 1,
      "vulnerability_type": "null_pointer_dereference",
      "difficulty_level": "advanced",
      "risk_factors": [
        "system_crash",
        "denial_of_service",
        "memory_corruption",
        "critical_infrastructure"
      ],
      "attack_vectors": [
        "memory_manipulation",
        "null_pointer",
        "code_analysis",
        "reverse_engineering",
        "use_after_free",
        "fuzzing"
      ],
      "mitigation_strategies": [
        "null_pointer_checks",
        "fuzzing",
        "dynamic_analysis",
        "memory_management",
        "static_analysis",
        "use_after_free_prevention",
        "code_review",
        "secure_coding_practices"
      ],
      "code_differences": {
        "has_differences": true,
        "source_lines": 2,
        "target_lines": 2,
        "character_differences": 2654,
        "similarity_percentage": 11.504424778761061
      },
      "vulnerability_location": {
        "vulnerability_present": true,
        "fix_applied": true,
        "code_changed": true,
        "estimated_lines_changed": 0
      }
    },
    {
      "cve_id": "CVE-2017-8063",
      "cwe_id": "CWE-119",
      "cwe_name": "Buffer Overflow",
      "project": "torvalds",
      "severity": "critical",
      "weaponization_score": 7.9,
      "is_critical": true,
      "is_weaponizable": true,
      "is_high_priority_project": false,
      "vulnerable_code": "CWE-119 static int cxusb_ctrl_msg ( struct dvb_usb_device * d , u8 cmd , u8 * wbuf , int wlen , u8 * rbuf , int rlen ) { struct cxusb_state * st = d -> priv ; <S2SV_StartBug> int ret , wo ; <S2SV_EndBug> if ( 1 + wlen > MAX_XFER_SIZE ) { warn ( \"i2c<S2SV_blank>wr:<S2SV_blank>len=%d<S2SV_blank>is<S2SV_blank>too<S2SV_blank>big!\\\\n\" , wlen ) ; return - EOPNOTSUPP ; } <S2SV_StartBug> wo = ( rbuf == NULL || rlen == 0 ) ; <S2SV_EndBug> mutex_lock ( & d -> data_mutex ) ; st -> data [ 0 ] = cmd ; memcpy ( & st -> data [ 1 ] , wbuf , wlen ) ; <S2SV_StartBug> if ( wo ) <S2SV_EndBug> ret = dvb_usb_generic_write ( d , st -> data , 1 + wlen ) ; else ret = dvb_usb_generic_rw ( d , st -> data , 1 + wlen , <S2SV_StartBug> rbuf , rlen , 0 ) ; <S2SV_EndBug> mutex_unlock ( & d -> data_mutex ) ; return ret ; }\n",
      "fixed_code": "<S2SV_ModStart> ; int ret <S2SV_ModEnd> ; if ( <S2SV_ModStart> EOPNOTSUPP ; } if ( rlen > MAX_XFER_SIZE ) { warn ( \"i2c<S2SV_blank>rd:<S2SV_blank>len=%d<S2SV_blank>is<S2SV_blank>too<S2SV_blank>big!\\\\n\" , rlen ) ; return - EOPNOTSUPP ; } <S2SV_ModEnd> mutex_lock ( & <S2SV_ModStart> wlen ) ; <S2SV_ModEnd> ret = dvb_usb_generic_rw <S2SV_ModStart> + wlen , st -> data <S2SV_ModEnd> , rlen , <S2SV_ModStart> rlen , 0 ) ; if ( ! ret && rbuf && rlen ) memcpy ( rbuf , st -> data , rlen\n",
      "source_code_length": 802,
      "target_code_length": 481,
      "vulnerability_patterns": {
        "buffer_overflow": 1,
        "null_pointer": 7,
        "total": 8
      },
      "total_patterns": 8,
      "original_address": "https://github.com/torvalds/linux/commit/3f190e3aec212fc8c61e202c51400afa7384d4bc",
      "discovery_time": "2017-04-23T05:59Z",
      "project_commit_id": "torvalds@linux/3f190e3aec212fc8c61e202c51400afa7384d4bc",
      "extraction_time": "2025-08-31T15:41:49.187564",
      "label": 1,
      "vulnerability_type": "buffer_overflow",
      "difficulty_level": "advanced",
      "risk_factors": [
        "system_crash",
        "memory_corruption",
        "buffer_overflow",
        "arbitrary_code_execution"
      ],
      "attack_vectors": [
        "memory_manipulation",
        "malicious_input",
        "code_analysis",
        "buffer_overflow",
        "reverse_engineering",
        "fuzzing"
      ],
      "mitigation_strategies": [
        "safe_string_functions",
        "dynamic_analysis",
        "code_review",
        "static_analysis",
        "memory_safety_checks",
        "input_validation",
        "fuzzing",
        "bounds_checking",
        "secure_coding_practices"
      ],
      "code_differences": {
        "has_differences": true,
        "source_lines": 2,
        "target_lines": 2,
        "character_differences": 321,
        "similarity_percentage": 47.45762711864407
      },
      "vulnerability_location": {
        "vulnerability_present": true,
        "fix_applied": true,
        "code_changed": true,
        "estimated_lines_changed": 0
      }
    },
    {
      "cve_id": "CVE-2019-19275",
      "cwe_id": "CWE-125",
      "cwe_name": "Out-of-bounds Read",
      "project": "python",
      "severity": "critical",
      "weaponization_score": 7.9,
      "is_critical": true,
      "is_weaponizable": true,
      "is_high_priority_project": true,
      "vulnerable_code": "CWE-125 static arguments_ty ast_for_arguments ( struct compiling * c , const node * n ) { int i , j , k , nposargs = 0 , nkwonlyargs = 0 ; int nposdefaults = 0 , found_default = 0 ; asdl_seq * posargs , * posdefaults , * kwonlyargs , * kwdefaults ; arg_ty vararg = NULL , kwarg = NULL ; arg_ty arg ; node * ch ; if ( TYPE ( n ) == parameters ) { if ( NCH ( n ) == 2 ) return arguments ( NULL , NULL , NULL , NULL , NULL , NULL , c -> c_arena ) ; n = CHILD ( n , 1 ) ; } assert ( TYPE ( n ) == typedargslist || TYPE ( n ) == varargslist ) ; for ( i = 0 ; i < NCH ( n ) ; i ++ ) { ch = CHILD ( n , i ) ; if ( TYPE ( ch ) == STAR ) { i ++ ; if ( i < NCH ( n ) && ( TYPE ( CHILD ( n , i ) ) == tfpdef || TYPE ( CHILD ( n , i ) ) == vfpdef ) ) { i ++ ; } break ; } if ( TYPE ( ch ) == DOUBLESTAR ) break ; if ( TYPE ( ch ) == vfpdef || TYPE ( ch ) == tfpdef ) nposargs ++ ; if ( TYPE ( ch ) == EQUAL ) nposdefaults ++ ; } for ( ; i < NCH ( n ) ; ++ i ) { ch = CHILD ( n , i ) ; if ( TYPE ( ch ) == DOUBLESTAR ) break ; if ( TYPE ( ch ) == tfpdef || TYPE ( ch ) == vfpdef ) nkwonlyargs ++ ; } posargs = ( nposargs ? _Ta3_asdl_seq_new ( nposargs , c -> c_arena ) : NULL ) ; if ( ! posargs && nposargs ) return NULL ; kwonlyargs = ( nkwonlyargs ? _Ta3_asdl_seq_new ( nkwonlyargs , c -> c_arena ) : NULL ) ; if ( ! kwonlyargs && nkwonlyargs ) return NULL ; posdefaults = ( nposdefaults ? _Ta3_asdl_seq_new ( nposdefaults , c -> c_arena ) : NULL ) ; if ( ! posdefaults && nposdefaults ) return NULL ; kwdefaults = ( nkwonlyargs ? _Ta3_asdl_seq_new ( nkwonlyargs , c -> c_arena ) : NULL ) ; if ( ! kwdefaults && nkwonlyargs ) return NULL ; <S2SV_StartBug> if ( nposargs + nkwonlyargs > 255 ) { <S2SV_EndBug> ast_error ( c , n , \"more<S2SV_blank>than<S2SV_blank>255<S2SV_blank>arguments\" ) ; return NULL ; } i = 0 ; j = 0 ; k = 0 ; while ( i < NCH ( n ) ) { ch = CHILD ( n , i ) ; switch ( TYPE ( ch ) ) { case tfpdef : case vfpdef : if ( i + 1 < NCH ( n ) && TYPE ( CHILD ( n , i + 1 ) ) == EQUAL ) { expr_ty expression = ast_for_expr ( c , CHILD ( n , i + 2 ) ) ; if ( ! expression ) return NULL ; assert ( posdefaults != NULL ) ; asdl_seq_SET ( posdefaults , j ++ , expression ) ; i += 2 ; found_default = 1 ; } else if ( found_default ) { ast_error ( c , n , \"non-default<S2SV_blank>argument<S2SV_blank>follows<S2SV_blank>default<S2SV_blank>argument\" ) ; return NULL ; } arg = ast_for_arg ( c , ch ) ; if ( ! arg ) return NULL ; asdl_seq_SET ( posargs , k ++ , arg ) ; i += 1 ; <S2SV_StartBug> if ( i < NCH ( n ) && TYPE ( CHILD ( n , i ) ) == COMMA ) <S2SV_EndBug> i += 1 ; break ; case STAR : if ( i + 1 >= NCH ( n ) || ( i + 2 == NCH ( n ) && ( TYPE ( CHILD ( n , i + 1 ) ) == COMMA || TYPE ( CHILD ( n , i + 1 ) ) == TYPE_COMMENT ) ) ) { ast_error ( c , CHILD ( n , i ) , \"named<S2SV_blank>arguments<S2SV_blank>must<S2SV_blank>follow<S2SV_blank>bare<S2SV_blank>*\" ) ; return NULL ; } ch = CHILD ( n , i + 1 ) ; if ( TYPE ( ch ) == COMMA ) { int res = 0 ; i += 2 ; <S2SV_StartBug> if ( i < NCH ( n ) && TYPE ( CHILD ( n , i ) ) == TYPE_COMMENT ) { <S2SV_EndBug> ast_error ( c , CHILD ( n , i ) , \"bare<S2SV_blank>*<S2SV_blank>has<S2SV_blank>associated<S2SV_blank>type<S2SV_blank>comment\" ) ; return NULL ; } res = handle_keywordonly_args ( c , n , i , kwonlyargs , kwdefaults ) ; if ( res == - 1 ) return NULL ; i = res ; } else { vararg = ast_for_arg ( c , ch ) ; if ( ! vararg ) return NULL ; i += 2 ; <S2SV_StartBug> if ( i < NCH ( n ) && TYPE ( CHILD ( n , i ) ) == COMMA ) <S2SV_EndBug> i += 1 ; <S2SV_StartBug> if ( i < NCH ( n ) && TYPE ( CHILD ( n , i ) ) == TYPE_COMMENT ) { <S2SV_EndBug> vararg -> type_comment = NEW_TYPE_COMMENT ( CHILD ( n , i ) ) ; i += 1 ; } if ( i < NCH ( n ) && ( TYPE ( CHILD ( n , i ) ) == tfpdef || TYPE ( CHILD ( n , i ) ) == vfpdef ) ) { int res = 0 ; res = handle_keywordonly_args ( c , n , i , kwonlyargs , kwdefaults ) ; if ( res == - 1 ) return NULL ; i = res ; } } break ; case DOUBLESTAR : ch = CHILD ( n , i + 1 ) ; assert ( TYPE ( ch ) == tfpdef || TYPE ( ch ) == vfpdef ) ; kwarg = ast_for_arg ( c , ch ) ; if ( ! kwarg ) return NULL ; i += 2 ; <S2SV_StartBug> if ( i < NCH ( n ) && TYPE ( CHILD ( n , i ) ) == COMMA ) <S2SV_EndBug> i += 1 ; break ; case TYPE_COMMENT : assert ( i ) ; if ( kwarg ) arg = kwarg ; arg -> type_comment = NEW_TYPE_COMMENT ( ch ) ; i += 1 ; break ; default : PyErr_Format ( PyExc_SystemError , \"unexpected<S2SV_blank>node<S2SV_blank>in<S2SV_blank>varargslist:<S2SV_blank>%d<S2SV_blank>@<S2SV_blank>%d\" , TYPE ( ch ) , i ) ; return NULL ; } } return arguments ( posargs , vararg , kwonlyargs , kwdefaults , kwarg , posdefaults , c -> c_arena ) ; }\n",
      "fixed_code": "<S2SV_ModStart> return NULL ; <S2SV_ModEnd> i = 0 <S2SV_ModStart> ; if ( <S2SV_ModEnd> TYPE ( CHILD <S2SV_ModStart> ; if ( <S2SV_ModEnd> TYPE ( CHILD <S2SV_ModStart> ; if ( <S2SV_ModEnd> TYPE ( CHILD <S2SV_ModStart> ; if ( <S2SV_ModEnd> TYPE ( CHILD <S2SV_ModStart> ; if ( <S2SV_ModEnd> TYPE ( CHILD\n",
      "source_code_length": 4617,
      "target_code_length": 300,
      "vulnerability_patterns": {
        "integer_overflow": 1,
        "null_pointer": 7,
        "total": 8
      },
      "total_patterns": 8,
      "original_address": "https://github.com/python/typed_ast/commit/156afcb26c198e162504a57caddfe0acd9ed7dce",
      "discovery_time": "2019-11-26T15:15Z",
      "project_commit_id": "python@typed_ast/156afcb26c198e162504a57caddfe0acd9ed7dce",
      "extraction_time": "2025-08-31T15:41:49.187585",
      "label": 1,
      "vulnerability_type": "out-of-bounds_read",
      "difficulty_level": "advanced",
      "risk_factors": [
        "information_disclosure",
        "memory_corruption",
        "integer_overflow",
        "critical_infrastructure"
      ],
      "attack_vectors": [
        "memory_manipulation",
        "malicious_input",
        "code_analysis",
        "buffer_overflow",
        "reverse_engineering",
        "fuzzing"
      ],
      "mitigation_strategies": [
        "safe_string_functions",
        "dynamic_analysis",
        "code_review",
        "static_analysis",
        "memory_safety_checks",
        "input_validation",
        "fuzzing",
        "bounds_checking",
        "secure_coding_practices"
      ],
      "code_differences": {
        "has_differences": true,
        "source_lines": 2,
        "target_lines": 2,
        "character_differences": 4317,
        "similarity_percentage": 9.70873786407767
      },
      "vulnerability_location": {
        "vulnerability_present": true,
        "fix_applied": true,
        "code_changed": true,
        "estimated_lines_changed": 0
      }
    },
    {
      "cve_id": "CVE-2017-7866",
      "cwe_id": "CWE-787",
      "cwe_name": "Out-of-bounds Write",
      "project": "FFmpeg",
      "severity": "critical",
      "weaponization_score": 7.8,
      "is_critical": true,
      "is_weaponizable": true,
      "is_high_priority_project": true,
      "vulnerable_code": "CWE-787 static int decode_zbuf ( AVBPrint * bp , const uint8_t * data , const uint8_t * data_end ) { z_stream zstream ; unsigned char * buf ; unsigned buf_size ; int ret ; zstream . zalloc = ff_png_zalloc ; zstream . zfree = ff_png_zfree ; zstream . opaque = NULL ; if ( inflateInit ( & zstream ) != Z_OK ) return AVERROR_EXTERNAL ; zstream . next_in = ( unsigned char * ) data ; zstream . avail_in = data_end - data ; av_bprint_init ( bp , 0 , - 1 ) ; while ( zstream . avail_in > 0 ) { <S2SV_StartBug> av_bprint_get_buffer ( bp , 1 , & buf , & buf_size ) ; <S2SV_EndBug> if ( ! buf_size ) { ret = AVERROR ( ENOMEM ) ; goto fail ; } zstream . next_out = buf ; <S2SV_StartBug> zstream . avail_out = buf_size ; <S2SV_EndBug> ret = inflate ( & zstream , Z_PARTIAL_FLUSH ) ; if ( ret != Z_OK && ret != Z_STREAM_END ) { ret = AVERROR_EXTERNAL ; goto fail ; } bp -> len += zstream . next_out - buf ; if ( ret == Z_STREAM_END ) break ; } inflateEnd ( & zstream ) ; bp -> str [ bp -> len ] = 0 ; return 0 ; fail : inflateEnd ( & zstream ) ; av_bprint_finalize ( bp , NULL ) ; return ret ; }\n",
      "fixed_code": "<S2SV_ModStart> ( bp , 2 , & buf , & buf_size ) ; if ( buf_size < 2 <S2SV_ModEnd> ) { ret <S2SV_ModStart> avail_out = buf_size - 1\n",
      "source_code_length": 1084,
      "target_code_length": 131,
      "vulnerability_patterns": {
        "integer_overflow": 1,
        "null_pointer": 5,
        "total": 6
      },
      "total_patterns": 6,
      "original_address": "https://github.com/FFmpeg/FFmpeg/commit/e371f031b942d73e02c090170975561fabd5c264",
      "discovery_time": "2017-04-14T04:59Z",
      "project_commit_id": "FFmpeg@FFmpeg/e371f031b942d73e02c090170975561fabd5c264",
      "extraction_time": "2025-08-31T15:41:49.187644",
      "label": 1,
      "vulnerability_type": "out-of-bounds_write",
      "difficulty_level": "advanced",
      "risk_factors": [
        "system_crash",
        "memory_corruption",
        "critical_infrastructure",
        "arbitrary_code_execution"
      ],
      "attack_vectors": [
        "memory_manipulation",
        "malicious_input",
        "code_analysis",
        "buffer_overflow",
        "reverse_engineering",
        "fuzzing"
      ],
      "mitigation_strategies": [
        "safe_string_functions",
        "dynamic_analysis",
        "code_review",
        "static_analysis",
        "memory_safety_checks",
        "input_validation",
        "fuzzing",
        "bounds_checking",
        "secure_coding_practices"
      ],
      "code_differences": {
        "has_differences": true,
        "source_lines": 2,
        "target_lines": 2,
        "character_differences": 953,
        "similarity_percentage": 19.736842105263158
      },
      "vulnerability_location": {
        "vulnerability_present": true,
        "fix_applied": true,
        "code_changed": true,
        "estimated_lines_changed": 0
      }
    },
    {
      "cve_id": "CVE-2017-10661",
      "cwe_id": "CWE-416",
      "cwe_name": "Use After Free",
      "project": "torvalds",
      "severity": "critical",
      "weaponization_score": 7.699999999999999,
      "is_critical": true,
      "is_weaponizable": true,
      "is_high_priority_project": false,
      "vulnerable_code": "CWE-416 SYSCALL_DEFINE2 ( timerfd_create , int , clockid , int , flags ) { int ufd ; struct timerfd_ctx * ctx ; BUILD_BUG_ON ( TFD_CLOEXEC != O_CLOEXEC ) ; BUILD_BUG_ON ( TFD_NONBLOCK != O_NONBLOCK ) ; if ( ( flags & ~ TFD_CREATE_FLAGS ) || ( clockid != CLOCK_MONOTONIC && clockid != CLOCK_REALTIME && clockid != CLOCK_REALTIME_ALARM && clockid != CLOCK_BOOTTIME && clockid != CLOCK_BOOTTIME_ALARM ) ) return - EINVAL ; if ( ! capable ( CAP_WAKE_ALARM ) && ( clockid == CLOCK_REALTIME_ALARM || clockid == CLOCK_BOOTTIME_ALARM ) ) return - EPERM ; ctx = kzalloc ( sizeof ( * ctx ) , GFP_KERNEL ) ; if ( ! ctx ) return - ENOMEM ; init_waitqueue_head ( & ctx -> wqh ) ; <S2SV_StartBug> ctx -> clockid = clockid ; <S2SV_EndBug> if ( isalarm ( ctx ) ) alarm_init ( & ctx -> t . alarm , ctx -> clockid == CLOCK_REALTIME_ALARM ? ALARM_REALTIME : ALARM_BOOTTIME , timerfd_alarmproc ) ; else hrtimer_init ( & ctx -> t . tmr , clockid , HRTIMER_MODE_ABS ) ; ctx -> moffs = ktime_mono_to_real ( 0 ) ; ufd = anon_inode_getfd ( \"[timerfd]\" , & timerfd_fops , ctx , O_RDWR | ( flags & TFD_SHARED_FCNTL_FLAGS ) ) ; if ( ufd < 0 ) kfree ( ctx ) ; return ufd ; }\n",
      "fixed_code": "<S2SV_ModStart> wqh ) ; spin_lock_init ( & ctx -> cancel_lock ) ;\n",
      "source_code_length": 1146,
      "target_code_length": 66,
      "vulnerability_patterns": {
        "use_after_free": 1,
        "null_pointer": 8,
        "total": 9
      },
      "total_patterns": 9,
      "original_address": "https://github.com/torvalds/linux/commit/1e38da300e1e395a15048b0af1e5305bd91402f6",
      "discovery_time": "2017-08-19T18:29Z",
      "project_commit_id": "torvalds@linux/1e38da300e1e395a15048b0af1e5305bd91402f6",
      "extraction_time": "2025-08-31T15:41:49.187674",
      "label": 1,
      "vulnerability_type": "use_after_free",
      "difficulty_level": "advanced",
      "risk_factors": [
        "system_crash",
        "denial_of_service",
        "memory_corruption",
        "use_after_free"
      ],
      "attack_vectors": [
        "memory_manipulation",
        "null_pointer",
        "code_analysis",
        "reverse_engineering",
        "use_after_free",
        "fuzzing"
      ],
      "mitigation_strategies": [
        "null_pointer_checks",
        "fuzzing",
        "dynamic_analysis",
        "memory_management",
        "static_analysis",
        "use_after_free_prevention",
        "code_review",
        "secure_coding_practices"
      ],
      "code_differences": {
        "has_differences": true,
        "source_lines": 2,
        "target_lines": 2,
        "character_differences": 1080,
        "similarity_percentage": 8.75
      },
      "vulnerability_location": {
        "vulnerability_present": true,
        "fix_applied": true,
        "code_changed": true,
        "estimated_lines_changed": 0
      }
    },
    {
      "cve_id": "CVE-2014-8884",
      "cwe_id": "CWE-119",
      "cwe_name": "Buffer Overflow",
      "project": "torvalds",
      "severity": "critical",
      "weaponization_score": 7.6,
      "is_critical": true,
      "is_weaponizable": true,
      "is_high_priority_project": false,
      "vulnerable_code": "CWE-119 static int ttusbdecfe_dvbs_diseqc_send_master_cmd ( struct dvb_frontend * fe , struct dvb_diseqc_master_cmd * cmd ) { struct ttusbdecfe_state * state = ( struct ttusbdecfe_state * ) fe -> demodulator_priv ; u8 b [ ] = { 0x00 , 0xff , 0x00 , 0x00 , 0x00 , 0x00 , 0x00 , 0x00 , 0x00 , 0x00 } ; <S2SV_StartBug> memcpy ( & b [ 4 ] , cmd -> msg , cmd -> msg_len ) ; <S2SV_EndBug> state -> config -> send_command ( fe , 0x72 , sizeof ( b ) - ( 6 - cmd -> msg_len ) , b , NULL , NULL ) ; return 0 ; }\n",
      "fixed_code": "<S2SV_ModStart> 0x00 } ; if ( cmd -> msg_len > sizeof ( b ) - 4 ) return - EINVAL ;\n",
      "source_code_length": 502,
      "target_code_length": 84,
      "vulnerability_patterns": {
        "buffer_overflow": 1,
        "null_pointer": 6,
        "total": 7
      },
      "total_patterns": 7,
      "original_address": "https://github.com/torvalds/linux/commit/f2e323ec96077642d397bb1c355def536d489d16",
      "discovery_time": "2014-11-30T01:59Z",
      "project_commit_id": "torvalds@linux/f2e323ec96077642d397bb1c355def536d489d16",
      "extraction_time": "2025-08-31T15:41:49.187701",
      "label": 1,
      "vulnerability_type": "buffer_overflow",
      "difficulty_level": "advanced",
      "risk_factors": [
        "system_crash",
        "memory_corruption",
        "buffer_overflow",
        "arbitrary_code_execution"
      ],
      "attack_vectors": [
        "memory_manipulation",
        "malicious_input",
        "code_analysis",
        "buffer_overflow",
        "reverse_engineering",
        "fuzzing"
      ],
      "mitigation_strategies": [
        "safe_string_functions",
        "dynamic_analysis",
        "code_review",
        "static_analysis",
        "memory_safety_checks",
        "input_validation",
        "fuzzing",
        "bounds_checking",
        "secure_coding_practices"
      ],
      "code_differences": {
        "has_differences": true,
        "source_lines": 2,
        "target_lines": 2,
        "character_differences": 418,
        "similarity_percentage": 27.659574468085108
      },
      "vulnerability_location": {
        "vulnerability_present": true,
        "fix_applied": true,
        "code_changed": true,
        "estimated_lines_changed": 0
      }
    },
    {
      "cve_id": "CVE-2018-11379",
      "cwe_id": "CWE-125",
      "cwe_name": "Out-of-bounds Read",
      "project": "radare",
      "severity": "critical",
      "weaponization_score": 7.6,
      "is_critical": true,
      "is_weaponizable": true,
      "is_high_priority_project": true,
      "vulnerable_code": "CWE-125 static void get_nb10 ( ut8 * dbg_data , SCV_NB10_HEADER * res ) { const int nb10sz = 16 ; <S2SV_StartBug> memcpy ( res , dbg_data , nb10sz ) ; <S2SV_EndBug> res -> file_name = ( ut8 * ) strdup ( ( const char * ) dbg_data + nb10sz ) ; }\n",
      "fixed_code": "<S2SV_ModStart> = 16 ; <S2SV_ModEnd> } <S2SV_null> <S2SV_null>\n",
      "source_code_length": 244,
      "target_code_length": 63,
      "vulnerability_patterns": {
        "buffer_overflow": 1,
        "null_pointer": 1,
        "total": 2
      },
      "total_patterns": 2,
      "original_address": "https://github.com/radare/radare2/commit/4e1cf0d3e6f6fe2552a269def0af1cd2403e266c",
      "discovery_time": "2018-05-22T19:29Z",
      "project_commit_id": "radare@radare2/4e1cf0d3e6f6fe2552a269def0af1cd2403e266c",
      "extraction_time": "2025-08-31T15:41:49.187727",
      "label": 1,
      "vulnerability_type": "out-of-bounds_read",
      "difficulty_level": "advanced",
      "risk_factors": [
        "memory_corruption",
        "critical_infrastructure",
        "buffer_overflow",
        "information_disclosure",
        "integer_overflow"
      ],
      "attack_vectors": [
        "memory_manipulation",
        "malicious_input",
        "code_analysis",
        "buffer_overflow",
        "reverse_engineering",
        "fuzzing"
      ],
      "mitigation_strategies": [
        "safe_string_functions",
        "dynamic_analysis",
        "code_review",
        "static_analysis",
        "memory_safety_checks",
        "input_validation",
        "fuzzing",
        "bounds_checking",
        "secure_coding_practices"
      ],
      "code_differences": {
        "has_differences": true,
        "source_lines": 2,
        "target_lines": 2,
        "character_differences": 181,
        "similarity_percentage": 12.903225806451612
      },
      "vulnerability_location": {
        "vulnerability_present": true,
        "fix_applied": true,
        "code_changed": true,
        "estimated_lines_changed": 0
      }
    },
    {
      "cve_id": "CVE-2018-5333",
      "cwe_id": "CWE-476",
      "cwe_name": "NULL Pointer Dereference",
      "project": "torvalds",
      "severity": "critical",
      "weaponization_score": 7.5,
      "is_critical": true,
      "is_weaponizable": true,
      "is_high_priority_project": false,
      "vulnerable_code": "CWE-476 int rds_cmsg_atomic ( struct rds_sock * rs , struct rds_message * rm , struct cmsghdr * cmsg ) { struct page * page = NULL ; struct rds_atomic_args * args ; int ret = 0 ; if ( cmsg -> cmsg_len < CMSG_LEN ( sizeof ( struct rds_atomic_args ) ) || rm -> atomic . op_active ) return - EINVAL ; args = CMSG_DATA ( cmsg ) ; switch ( cmsg -> cmsg_type ) { case RDS_CMSG_ATOMIC_FADD : rm -> atomic . op_type = RDS_ATOMIC_TYPE_FADD ; rm -> atomic . op_m_fadd . add = args -> fadd . add ; rm -> atomic . op_m_fadd . nocarry_mask = 0 ; break ; case RDS_CMSG_MASKED_ATOMIC_FADD : rm -> atomic . op_type = RDS_ATOMIC_TYPE_FADD ; rm -> atomic . op_m_fadd . add = args -> m_fadd . add ; rm -> atomic . op_m_fadd . nocarry_mask = args -> m_fadd . nocarry_mask ; break ; case RDS_CMSG_ATOMIC_CSWP : rm -> atomic . op_type = RDS_ATOMIC_TYPE_CSWP ; rm -> atomic . op_m_cswp . compare = args -> cswp . compare ; rm -> atomic . op_m_cswp . swap = args -> cswp . swap ; rm -> atomic . op_m_cswp . compare_mask = ~ 0 ; rm -> atomic . op_m_cswp . swap_mask = ~ 0 ; break ; case RDS_CMSG_MASKED_ATOMIC_CSWP : rm -> atomic . op_type = RDS_ATOMIC_TYPE_CSWP ; rm -> atomic . op_m_cswp . compare = args -> m_cswp . compare ; rm -> atomic . op_m_cswp . swap = args -> m_cswp . swap ; rm -> atomic . op_m_cswp . compare_mask = args -> m_cswp . compare_mask ; rm -> atomic . op_m_cswp . swap_mask = args -> m_cswp . swap_mask ; break ; default : BUG ( ) ; } rm -> atomic . op_notify = ! ! ( args -> flags & RDS_RDMA_NOTIFY_ME ) ; rm -> atomic . op_silent = ! ! ( args -> flags & RDS_RDMA_SILENT ) ; rm -> atomic . op_active = 1 ; rm -> atomic . op_recverr = rs -> rs_recverr ; rm -> atomic . op_sg = rds_message_alloc_sgs ( rm , 1 ) ; if ( ! rm -> atomic . op_sg ) { ret = - ENOMEM ; goto err ; } if ( args -> local_addr & 0x7 ) { ret = - EFAULT ; goto err ; } ret = rds_pin_pages ( args -> local_addr , 1 , & page , 1 ) ; if ( ret != 1 ) goto err ; ret = 0 ; sg_set_page ( rm -> atomic . op_sg , page , 8 , offset_in_page ( args -> local_addr ) ) ; if ( rm -> atomic . op_notify || rm -> atomic . op_recverr ) { rm -> atomic . op_notifier = kmalloc ( sizeof ( * rm -> atomic . op_notifier ) , GFP_KERNEL ) ; if ( ! rm -> atomic . op_notifier ) { ret = - ENOMEM ; goto err ; } rm -> atomic . op_notifier -> n_user_token = args -> user_token ; rm -> atomic . op_notifier -> n_status = RDS_RDMA_SUCCESS ; } rm -> atomic . op_rkey = rds_rdma_cookie_key ( args -> cookie ) ; rm -> atomic . op_remote_addr = args -> remote_addr + rds_rdma_cookie_offset ( args -> cookie ) ; return ret ; err : if ( page ) put_page ( page ) ; <S2SV_StartBug> kfree ( rm -> atomic . op_notifier ) ; <S2SV_EndBug> return ret ; }\n",
      "fixed_code": "<S2SV_ModStart> page ) ; rm -> atomic . op_active = 0 ;\n",
      "source_code_length": 2680,
      "target_code_length": 56,
      "vulnerability_patterns": {
        "use_after_free": 1,
        "null_pointer": 57,
        "memory_leak": 1,
        "total": 59
      },
      "total_patterns": 59,
      "original_address": "https://github.com/torvalds/linux/commit/7d11f77f84b27cef452cee332f4e469503084737",
      "discovery_time": "2018-01-11T07:29Z",
      "project_commit_id": "torvalds@linux/7d11f77f84b27cef452cee332f4e469503084737",
      "extraction_time": "2025-08-31T15:41:49.187736",
      "label": 1,
      "vulnerability_type": "null_pointer_dereference",
      "difficulty_level": "advanced",
      "risk_factors": [
        "system_crash",
        "denial_of_service",
        "memory_corruption",
        "use_after_free"
      ],
      "attack_vectors": [
        "memory_manipulation",
        "null_pointer",
        "code_analysis",
        "reverse_engineering",
        "use_after_free",
        "fuzzing"
      ],
      "mitigation_strategies": [
        "null_pointer_checks",
        "fuzzing",
        "dynamic_analysis",
        "memory_management",
        "static_analysis",
        "use_after_free_prevention",
        "code_review",
        "secure_coding_practices"
      ],
      "code_differences": {
        "has_differences": true,
        "source_lines": 2,
        "target_lines": 2,
        "character_differences": 2624,
        "similarity_percentage": 9.345794392523365
      },
      "vulnerability_location": {
        "vulnerability_present": true,
        "fix_applied": true,
        "code_changed": true,
        "estimated_lines_changed": 0
      }
    },
    {
      "cve_id": "CVE-2017-17862",
      "cwe_id": "CWE-20",
      "cwe_name": "Improper Input Validation",
      "project": "torvalds",
      "severity": "critical",
      "weaponization_score": 7.5,
      "is_critical": true,
      "is_weaponizable": true,
      "is_high_priority_project": false,
      "vulnerable_code": "CWE-20 int bpf_check ( struct bpf_prog * * prog , union bpf_attr * attr ) { struct bpf_verifier_env * env ; struct bpf_verifer_log * log ; int ret = - EINVAL ; if ( ARRAY_SIZE ( bpf_verifier_ops ) == 0 ) return - EINVAL ; env = kzalloc ( sizeof ( struct bpf_verifier_env ) , GFP_KERNEL ) ; if ( ! env ) return - ENOMEM ; log = & env -> log ; env -> insn_aux_data = vzalloc ( sizeof ( struct bpf_insn_aux_data ) * ( * prog ) -> len ) ; ret = - ENOMEM ; if ( ! env -> insn_aux_data ) goto err_free_env ; env -> prog = * prog ; env -> ops = bpf_verifier_ops [ env -> prog -> type ] ; mutex_lock ( & bpf_verifier_lock ) ; if ( attr -> log_level || attr -> log_buf || attr -> log_size ) { log -> level = attr -> log_level ; log -> ubuf = ( char __user * ) ( unsigned long ) attr -> log_buf ; log -> len_total = attr -> log_size ; ret = - EINVAL ; if ( log -> len_total < 128 || log -> len_total > UINT_MAX >> 8 || ! log -> level || ! log -> ubuf ) goto err_unlock ; } env -> strict_alignment = ! ! ( attr -> prog_flags & BPF_F_STRICT_ALIGNMENT ) ; if ( ! IS_ENABLED ( CONFIG_HAVE_EFFICIENT_UNALIGNED_ACCESS ) ) env -> strict_alignment = true ; if ( env -> prog -> aux -> offload ) { ret = bpf_prog_offload_verifier_prep ( env ) ; if ( ret ) goto err_unlock ; } ret = replace_map_fd_with_map_ptr ( env ) ; if ( ret < 0 ) goto skip_full_check ; env -> explored_states = kcalloc ( env -> prog -> len , sizeof ( struct bpf_verifier_state_list * ) , GFP_USER ) ; ret = - ENOMEM ; if ( ! env -> explored_states ) goto skip_full_check ; ret = check_cfg ( env ) ; if ( ret < 0 ) goto skip_full_check ; env -> allow_ptr_leaks = capable ( CAP_SYS_ADMIN ) ; ret = do_check ( env ) ; if ( env -> cur_state ) { free_verifier_state ( env -> cur_state , true ) ; env -> cur_state = NULL ; } skip_full_check : while ( ! pop_stack ( env , NULL , NULL ) ) ; free_states ( env ) ; if ( ret == 0 ) <S2SV_StartBug> ret = convert_ctx_accesses ( env ) ; <S2SV_EndBug> if ( ret == 0 ) ret = fixup_bpf_calls ( env ) ; if ( log -> level && bpf_verifier_log_full ( log ) ) ret = - ENOSPC ; if ( log -> level && ! log -> ubuf ) { ret = - EFAULT ; goto err_release_maps ; } if ( ret == 0 && env -> used_map_cnt ) { env -> prog -> aux -> used_maps = kmalloc_array ( env -> used_map_cnt , sizeof ( env -> used_maps [ 0 ] ) , GFP_KERNEL ) ; if ( ! env -> prog -> aux -> used_maps ) { ret = - ENOMEM ; goto err_release_maps ; } memcpy ( env -> prog -> aux -> used_maps , env -> used_maps , sizeof ( env -> used_maps [ 0 ] ) * env -> used_map_cnt ) ; env -> prog -> aux -> used_map_cnt = env -> used_map_cnt ; convert_pseudo_ld_imm64 ( env ) ; } err_release_maps : if ( ! env -> prog -> aux -> used_maps ) release_maps ( env ) ; * prog = env -> prog ; err_unlock : mutex_unlock ( & bpf_verifier_lock ) ; vfree ( env -> insn_aux_data ) ; err_free_env : kfree ( env ) ; return ret ; }\n",
      "fixed_code": "<S2SV_ModStart> == 0 ) sanitize_dead_code ( env ) ; if ( ret == 0 )\n",
      "source_code_length": 2844,
      "target_code_length": 68,
      "vulnerability_patterns": {
        "buffer_overflow": 1,
        "use_after_free": 2,
        "null_pointer": 64,
        "memory_leak": 1,
        "total": 68
      },
      "total_patterns": 68,
      "original_address": "https://github.com/torvalds/linux/commit/c131187db2d3fa2f8bf32fdf4e9a4ef805168467",
      "discovery_time": "2017-12-27T17:08Z",
      "project_commit_id": "torvalds@linux/c131187db2d3fa2f8bf32fdf4e9a4ef805168467",
      "extraction_time": "2025-08-31T15:41:49.187765",
      "label": 1,
      "vulnerability_type": "improper_input_validation",
      "difficulty_level": "advanced",
      "risk_factors": [
        "buffer_overflow",
        "use_after_free"
      ],
      "attack_vectors": [
        "fuzzing",
        "code_analysis",
        "reverse_engineering"
      ],
      "mitigation_strategies": [
        "dynamic_analysis",
        "static_analysis",
        "fuzzing",
        "code_review",
        "secure_coding_practices"
      ],
      "code_differences": {
        "has_differences": true,
        "source_lines": 2,
        "target_lines": 2,
        "character_differences": 2776,
        "similarity_percentage": 7.017543859649122
      },
      "vulnerability_location": {
        "vulnerability_present": true,
        "fix_applied": true,
        "code_changed": true,
        "estimated_lines_changed": 0
      }
    },
    {
      "cve_id": "CVE-2016-9436",
      "cwe_id": "CWE-20",
      "cwe_name": "Improper Input Validation",
      "project": "tats",
      "severity": "critical",
      "weaponization_score": 7.5,
      "is_critical": true,
      "is_weaponizable": true,
      "is_high_priority_project": false,
      "vulnerable_code": "CWE-20 int HTMLtagproc1 ( struct parsed_tag * tag , struct html_feed_environ * h_env ) { char * p , * q , * r ; int i , w , x , y , z , count , width ; struct readbuffer * obuf = h_env -> obuf ; struct environment * envs = h_env -> envs ; Str tmp ; int hseq ; int cmd ; # ifdef ID_EXT char * id = NULL ; # endif cmd = tag -> tagid ; if ( obuf -> flag & RB_PRE ) { switch ( cmd ) { case HTML_NOBR : case HTML_N_NOBR : case HTML_PRE_INT : case HTML_N_PRE_INT : return 1 ; } } switch ( cmd ) { case HTML_B : obuf -> in_bold ++ ; if ( obuf -> in_bold > 1 ) return 1 ; return 0 ; case HTML_N_B : if ( obuf -> in_bold == 1 && close_effect0 ( obuf , HTML_B ) ) obuf -> in_bold = 0 ; if ( obuf -> in_bold > 0 ) { obuf -> in_bold -- ; if ( obuf -> in_bold == 0 ) return 0 ; } return 1 ; case HTML_I : obuf -> in_italic ++ ; if ( obuf -> in_italic > 1 ) return 1 ; return 0 ; case HTML_N_I : if ( obuf -> in_italic == 1 && close_effect0 ( obuf , HTML_I ) ) obuf -> in_italic = 0 ; if ( obuf -> in_italic > 0 ) { obuf -> in_italic -- ; if ( obuf -> in_italic == 0 ) return 0 ; } return 1 ; case HTML_U : obuf -> in_under ++ ; if ( obuf -> in_under > 1 ) return 1 ; return 0 ; case HTML_N_U : if ( obuf -> in_under == 1 && close_effect0 ( obuf , HTML_U ) ) obuf -> in_under = 0 ; if ( obuf -> in_under > 0 ) { obuf -> in_under -- ; if ( obuf -> in_under == 0 ) return 0 ; } return 1 ; case HTML_EM : HTMLlineproc1 ( \"<i>\" , h_env ) ; return 1 ; case HTML_N_EM : HTMLlineproc1 ( \"</i>\" , h_env ) ; return 1 ; case HTML_STRONG : HTMLlineproc1 ( \"<b>\" , h_env ) ; return 1 ; case HTML_N_STRONG : HTMLlineproc1 ( \"</b>\" , h_env ) ; return 1 ; case HTML_Q : HTMLlineproc1 ( \"`\" , h_env ) ; return 1 ; case HTML_N_Q : HTMLlineproc1 ( \"\\'\" , h_env ) ; return 1 ; case HTML_P : case HTML_N_P : CLOSE_A ; if ( ! ( obuf -> flag & RB_IGNORE_P ) ) { flushline ( h_env , obuf , envs [ h_env -> envc ] . indent , 1 , h_env -> limit ) ; do_blankline ( h_env , obuf , envs [ h_env -> envc ] . indent , 0 , h_env -> limit ) ; } obuf -> flag |= RB_IGNORE_P ; if ( cmd == HTML_P ) { set_alignment ( obuf , tag ) ; obuf -> flag |= RB_P ; } return 1 ; case HTML_BR : flushline ( h_env , obuf , envs [ h_env -> envc ] . indent , 1 , h_env -> limit ) ; h_env -> blank_lines = 0 ; return 1 ; case HTML_H : if ( ! ( obuf -> flag & ( RB_PREMODE | RB_IGNORE_P ) ) ) { flushline ( h_env , obuf , envs [ h_env -> envc ] . indent , 0 , h_env -> limit ) ; do_blankline ( h_env , obuf , envs [ h_env -> envc ] . indent , 0 , h_env -> limit ) ; } HTMLlineproc1 ( \"<b>\" , h_env ) ; set_alignment ( obuf , tag ) ; return 1 ; case HTML_N_H : HTMLlineproc1 ( \"</b>\" , h_env ) ; if ( ! ( obuf -> flag & RB_PREMODE ) ) { flushline ( h_env , obuf , envs [ h_env -> envc ] . indent , 0 , h_env -> limit ) ; } do_blankline ( h_env , obuf , envs [ h_env -> envc ] . indent , 0 , h_env -> limit ) ; RB_RESTORE_FLAG ( obuf ) ; close_anchor ( h_env , obuf ) ; obuf -> flag |= RB_IGNORE_P ; return 1 ; case HTML_UL : case HTML_OL : case HTML_BLQ : CLOSE_A ; if ( ! ( obuf -> flag & RB_IGNORE_P ) ) { flushline ( h_env , obuf , envs [ h_env -> envc ] . indent , 0 , h_env -> limit ) ; if ( ! ( obuf -> flag & RB_PREMODE ) && ( h_env -> envc == 0 || cmd == HTML_BLQ ) ) do_blankline ( h_env , obuf , envs [ h_env -> envc ] . indent , 0 , h_env -> limit ) ; } PUSH_ENV ( cmd ) ; if ( cmd == HTML_UL || cmd == HTML_OL ) { if ( parsedtag_get_value ( tag , ATTR_START , & count ) ) { envs [ h_env -> envc ] . count = count - 1 ; } } if ( cmd == HTML_OL ) { envs [ h_env -> envc ] . type = '1' ; if ( parsedtag_get_value ( tag , ATTR_TYPE , & p ) ) { envs [ h_env -> envc ] . type = ( int ) * p ; } } if ( cmd == HTML_UL ) envs [ h_env -> envc ] . type = ul_type ( tag , 0 ) ; flushline ( h_env , obuf , envs [ h_env -> envc ] . indent , 0 , h_env -> limit ) ; return 1 ; case HTML_N_UL : case HTML_N_OL : case HTML_N_DL : case HTML_N_BLQ : CLOSE_DT ; CLOSE_A ; if ( h_env -> envc > 0 ) { flushline ( h_env , obuf , envs [ h_env -> envc - 1 ] . indent , 0 , h_env -> limit ) ; POP_ENV ; if ( ! ( obuf -> flag & RB_PREMODE ) && ( h_env -> envc == 0 || cmd == HTML_N_DL || cmd == HTML_N_BLQ ) ) { do_blankline ( h_env , obuf , envs [ h_env -> envc ] . indent , INDENT_INCR , h_env -> limit ) ; obuf -> flag |= RB_IGNORE_P ; } } close_anchor ( h_env , obuf ) ; return 1 ; case HTML_DL : CLOSE_A ; if ( ! ( obuf -> flag & RB_IGNORE_P ) ) { flushline ( h_env , obuf , envs [ h_env -> envc ] . indent , 0 , h_env -> limit ) ; if ( ! ( obuf -> flag & RB_PREMODE ) ) do_blankline ( h_env , obuf , envs [ h_env -> envc ] . indent , 0 , h_env -> limit ) ; } PUSH_ENV ( cmd ) ; if ( parsedtag_exists ( tag , ATTR_COMPACT ) ) envs [ h_env -> envc ] . env = HTML_DL_COMPACT ; obuf -> flag |= RB_IGNORE_P ; return 1 ; case HTML_LI : CLOSE_A ; CLOSE_DT ; if ( h_env -> envc > 0 ) { Str num ; flushline ( h_env , obuf , envs [ h_env -> envc - 1 ] . indent , 0 , h_env -> limit ) ; envs [ h_env -> envc ] . count ++ ; if ( parsedtag_get_value ( tag , ATTR_VALUE , & p ) ) { count = atoi ( p ) ; if ( count > 0 ) envs [ h_env -> envc ] . count = count ; else envs [ h_env -> envc ] . count = 0 ; } switch ( envs [ h_env -> envc ] . env ) { case HTML_UL : envs [ h_env -> envc ] . type = ul_type ( tag , envs [ h_env -> envc ] . type ) ; for ( i = 0 ; i < INDENT_INCR - 3 ; i ++ ) push_charp ( obuf , 1 , NBSP , PC_ASCII ) ; tmp = Strnew ( ) ; switch ( envs [ h_env -> envc ] . type ) { case 'd' : push_symbol ( tmp , UL_SYMBOL_DISC , symbol_width , 1 ) ; break ; case 'c' : push_symbol ( tmp , UL_SYMBOL_CIRCLE , symbol_width , 1 ) ; break ; case 's' : push_symbol ( tmp , UL_SYMBOL_SQUARE , symbol_width , 1 ) ; break ; default : push_symbol ( tmp , UL_SYMBOL ( ( h_env -> envc_real - 1 ) % MAX_UL_LEVEL ) , symbol_width , 1 ) ; break ; } if ( symbol_width == 1 ) push_charp ( obuf , 1 , NBSP , PC_ASCII ) ; push_str ( obuf , symbol_width , tmp , PC_ASCII ) ; push_charp ( obuf , 1 , NBSP , PC_ASCII ) ; set_space_to_prevchar ( obuf -> prevchar ) ; break ; case HTML_OL : if ( parsedtag_get_value ( tag , ATTR_TYPE , & p ) ) envs [ h_env -> envc ] . type = ( int ) * p ; switch ( ( envs [ h_env -> envc ] . count > 0 ) ? envs [ h_env -> envc ] . type : '1' ) { case 'i' : num = romanNumeral ( envs [ h_env -> envc ] . count ) ; break ; case 'I' : num = romanNumeral ( envs [ h_env -> envc ] . count ) ; Strupper ( num ) ; break ; case 'a' : num = romanAlphabet ( envs [ h_env -> envc ] . count ) ; break ; case 'A' : num = romanAlphabet ( envs [ h_env -> envc ] . count ) ; Strupper ( num ) ; break ; default : num = Sprintf ( \"%d\" , envs [ h_env -> envc ] . count ) ; break ; } if ( INDENT_INCR >= 4 ) Strcat_charp ( num , \".<S2SV_blank>\" ) ; else Strcat_char ( num , '.' ) ; push_spaces ( obuf , 1 , INDENT_INCR - num -> length ) ; push_str ( obuf , num -> length , num , PC_ASCII ) ; if ( INDENT_INCR >= 4 ) set_space_to_prevchar ( obuf -> prevchar ) ; break ; default : push_spaces ( obuf , 1 , INDENT_INCR ) ; break ; } } else { flushline ( h_env , obuf , 0 , 0 , h_env -> limit ) ; } obuf -> flag |= RB_IGNORE_P ; return 1 ; case HTML_DT : CLOSE_A ; if ( h_env -> envc == 0 || ( h_env -> envc_real < h_env -> nenv && envs [ h_env -> envc ] . env != HTML_DL && envs [ h_env -> envc ] . env != HTML_DL_COMPACT ) ) { PUSH_ENV ( HTML_DL ) ; } if ( h_env -> envc > 0 ) { flushline ( h_env , obuf , envs [ h_env -> envc - 1 ] . indent , 0 , h_env -> limit ) ; } if ( ! ( obuf -> flag & RB_IN_DT ) ) { HTMLlineproc1 ( \"<b>\" , h_env ) ; obuf -> flag |= RB_IN_DT ; } obuf -> flag |= RB_IGNORE_P ; return 1 ; case HTML_DD : CLOSE_A ; CLOSE_DT ; <S2SV_StartBug> if ( envs [ h_env -> envc ] . env == HTML_DL_COMPACT ) { <S2SV_EndBug> if ( obuf -> pos > envs [ h_env -> envc ] . indent ) flushline ( h_env , obuf , envs [ h_env -> envc ] . indent , 0 , h_env -> limit ) ; else push_spaces ( obuf , 1 , envs [ h_env -> envc ] . indent - obuf -> pos ) ; } else flushline ( h_env , obuf , envs [ h_env -> envc ] . indent , 0 , h_env -> limit ) ; return 1 ; case HTML_TITLE : close_anchor ( h_env , obuf ) ; process_title ( tag ) ; obuf -> flag |= RB_TITLE ; obuf -> end_tag = HTML_N_TITLE ; return 1 ; case HTML_N_TITLE : if ( ! ( obuf -> flag & RB_TITLE ) ) return 1 ; obuf -> flag &= ~ RB_TITLE ; obuf -> end_tag = 0 ; tmp = process_n_title ( tag ) ; if ( tmp ) HTMLlineproc1 ( tmp -> ptr , h_env ) ; return 1 ; case HTML_TITLE_ALT : if ( parsedtag_get_value ( tag , ATTR_TITLE , & p ) ) h_env -> title = html_unquote ( p ) ; return 0 ; case HTML_FRAMESET : PUSH_ENV ( cmd ) ; push_charp ( obuf , 9 , \"--FRAME--\" , PC_ASCII ) ; flushline ( h_env , obuf , envs [ h_env -> envc ] . indent , 0 , h_env -> limit ) ; return 0 ; case HTML_N_FRAMESET : if ( h_env -> envc > 0 ) { POP_ENV ; flushline ( h_env , obuf , envs [ h_env -> envc ] . indent , 0 , h_env -> limit ) ; } return 0 ; case HTML_NOFRAMES : CLOSE_A ; flushline ( h_env , obuf , envs [ h_env -> envc ] . indent , 0 , h_env -> limit ) ; obuf -> flag |= ( RB_NOFRAMES | RB_IGNORE_P ) ; return 1 ; case HTML_N_NOFRAMES : CLOSE_A ; flushline ( h_env , obuf , envs [ h_env -> envc ] . indent , 0 , h_env -> limit ) ; obuf -> flag &= ~ RB_NOFRAMES ; return 1 ; case HTML_FRAME : q = r = NULL ; parsedtag_get_value ( tag , ATTR_SRC , & q ) ; parsedtag_get_value ( tag , ATTR_NAME , & r ) ; if ( q ) { q = html_quote ( q ) ; push_tag ( obuf , Sprintf ( \"<a<S2SV_blank>hseq=\\\\\"%d\\\\\"<S2SV_blank>href=\\\\\"%s\\\\\">\" , cur_hseq ++ , q ) -> ptr , HTML_A ) ; if ( r ) q = html_quote ( r ) ; push_charp ( obuf , get_strwidth ( q ) , q , PC_ASCII ) ; push_tag ( obuf , \"</a>\" , HTML_N_A ) ; } flushline ( h_env , obuf , envs [ h_env -> envc ] . indent , 0 , h_env -> limit ) ; return 0 ; case HTML_HR : close_anchor ( h_env , obuf ) ; tmp = process_hr ( tag , h_env -> limit , envs [ h_env -> envc ] . indent ) ; HTMLlineproc1 ( tmp -> ptr , h_env ) ; set_space_to_prevchar ( obuf -> prevchar ) ; return 1 ; case HTML_PRE : x = parsedtag_exists ( tag , ATTR_FOR_TABLE ) ; CLOSE_A ; if ( ! ( obuf -> flag & RB_IGNORE_P ) ) { flushline ( h_env , obuf , envs [ h_env -> envc ] . indent , 0 , h_env -> limit ) ; if ( ! x ) do_blankline ( h_env , obuf , envs [ h_env -> envc ] . indent , 0 , h_env -> limit ) ; } else fillline ( obuf , envs [ h_env -> envc ] . indent ) ; obuf -> flag |= ( RB_PRE | RB_IGNORE_P ) ; return 1 ; case HTML_N_PRE : flushline ( h_env , obuf , envs [ h_env -> envc ] . indent , 0 , h_env -> limit ) ; if ( ! ( obuf -> flag & RB_IGNORE_P ) ) { do_blankline ( h_env , obuf , envs [ h_env -> envc ] . indent , 0 , h_env -> limit ) ; obuf -> flag |= RB_IGNORE_P ; h_env -> blank_lines ++ ; } obuf -> flag &= ~ RB_PRE ; close_anchor ( h_env , obuf ) ; return 1 ; case HTML_PRE_INT : i = obuf -> line -> length ; append_tags ( obuf ) ; if ( ! ( obuf -> flag & RB_SPECIAL ) ) { set_breakpoint ( obuf , obuf -> line -> length - i ) ; } obuf -> flag |= RB_PRE_INT ; return 0 ; case HTML_N_PRE_INT : push_tag ( obuf , \"</pre_int>\" , HTML_N_PRE_INT ) ; obuf -> flag &= ~ RB_PRE_INT ; if ( ! ( obuf -> flag & RB_SPECIAL ) && obuf -> pos > obuf -> bp . pos ) { set_prevchar ( obuf -> prevchar , \"\" , 0 ) ; obuf -> prev_ctype = PC_CTRL ; } return 1 ; case HTML_NOBR : obuf -> flag |= RB_NOBR ; obuf -> nobr_level ++ ; return 0 ; case HTML_N_NOBR : if ( obuf -> nobr_level > 0 ) obuf -> nobr_level -- ; if ( obuf -> nobr_level == 0 ) obuf -> flag &= ~ RB_NOBR ; return 0 ; case HTML_PRE_PLAIN : CLOSE_A ; if ( ! ( obuf -> flag & RB_IGNORE_P ) ) { flushline ( h_env , obuf , envs [ h_env -> envc ] . indent , 0 , h_env -> limit ) ; do_blankline ( h_env , obuf , envs [ h_env -> envc ] . indent , 0 , h_env -> limit ) ; } obuf -> flag |= ( RB_PRE | RB_IGNORE_P ) ; return 1 ; case HTML_N_PRE_PLAIN : CLOSE_A ; if ( ! ( obuf -> flag & RB_IGNORE_P ) ) { flushline ( h_env , obuf , envs [ h_env -> envc ] . indent , 0 , h_env -> limit ) ; do_blankline ( h_env , obuf , envs [ h_env -> envc ] . indent , 0 , h_env -> limit ) ; obuf -> flag |= RB_IGNORE_P ; } obuf -> flag &= ~ RB_PRE ; return 1 ; case HTML_LISTING : case HTML_XMP : case HTML_PLAINTEXT : CLOSE_A ; if ( ! ( obuf -> flag & RB_IGNORE_P ) ) { flushline ( h_env , obuf , envs [ h_env -> envc ] . indent , 0 , h_env -> limit ) ; do_blankline ( h_env , obuf , envs [ h_env -> envc ] . indent , 0 , h_env -> limit ) ; } obuf -> flag |= ( RB_PLAIN | RB_IGNORE_P ) ; switch ( cmd ) { case HTML_LISTING : obuf -> end_tag = HTML_N_LISTING ; break ; case HTML_XMP : obuf -> end_tag = HTML_N_XMP ; break ; case HTML_PLAINTEXT : obuf -> end_tag = MAX_HTMLTAG ; break ; } return 1 ; case HTML_N_LISTING : case HTML_N_XMP : CLOSE_A ; if ( ! ( obuf -> flag & RB_IGNORE_P ) ) { flushline ( h_env , obuf , envs [ h_env -> envc ] . indent , 0 , h_env -> limit ) ; do_blankline ( h_env , obuf , envs [ h_env -> envc ] . indent , 0 , h_env -> limit ) ; obuf -> flag |= RB_IGNORE_P ; } obuf -> flag &= ~ RB_PLAIN ; obuf -> end_tag = 0 ; return 1 ; case HTML_SCRIPT : obuf -> flag |= RB_SCRIPT ; obuf -> end_tag = HTML_N_SCRIPT ; return 1 ; case HTML_STYLE : obuf -> flag |= RB_STYLE ; obuf -> end_tag = HTML_N_STYLE ; return 1 ; case HTML_N_SCRIPT : obuf -> flag &= ~ RB_SCRIPT ; obuf -> end_tag = 0 ; return 1 ; case HTML_N_STYLE : obuf -> flag &= ~ RB_STYLE ; obuf -> end_tag = 0 ; return 1 ; case HTML_A : if ( obuf -> anchor . url ) close_anchor ( h_env , obuf ) ; hseq = 0 ; if ( parsedtag_get_value ( tag , ATTR_HREF , & p ) ) obuf -> anchor . url = Strnew_charp ( p ) -> ptr ; if ( parsedtag_get_value ( tag , ATTR_TARGET , & p ) ) obuf -> anchor . target = Strnew_charp ( p ) -> ptr ; if ( parsedtag_get_value ( tag , ATTR_REFERER , & p ) ) obuf -> anchor . referer = Strnew_charp ( p ) -> ptr ; if ( parsedtag_get_value ( tag , ATTR_TITLE , & p ) ) obuf -> anchor . title = Strnew_charp ( p ) -> ptr ; if ( parsedtag_get_value ( tag , ATTR_ACCESSKEY , & p ) ) obuf -> anchor . accesskey = ( unsigned char ) * p ; if ( parsedtag_get_value ( tag , ATTR_HSEQ , & hseq ) ) obuf -> anchor . hseq = hseq ; if ( hseq == 0 && obuf -> anchor . url ) { obuf -> anchor . hseq = cur_hseq ; tmp = process_anchor ( tag , h_env -> tagbuf -> ptr ) ; push_tag ( obuf , tmp -> ptr , HTML_A ) ; if ( displayLinkNumber ) HTMLlineproc1 ( getLinkNumberStr ( - 1 ) -> ptr , h_env ) ; return 1 ; } return 0 ; case HTML_N_A : close_anchor ( h_env , obuf ) ; return 1 ; case HTML_IMG : tmp = process_img ( tag , h_env -> limit ) ; HTMLlineproc1 ( tmp -> ptr , h_env ) ; return 1 ; case HTML_IMG_ALT : if ( parsedtag_get_value ( tag , ATTR_SRC , & p ) ) obuf -> img_alt = Strnew_charp ( p ) ; # ifdef USE_IMAGE i = 0 ; if ( parsedtag_get_value ( tag , ATTR_TOP_MARGIN , & i ) ) { if ( i > obuf -> top_margin ) obuf -> top_margin = i ; } i = 0 ; if ( parsedtag_get_value ( tag , ATTR_BOTTOM_MARGIN , & i ) ) { if ( i > obuf -> bottom_margin ) obuf -> bottom_margin = i ; } # endif return 0 ; case HTML_N_IMG_ALT : if ( obuf -> img_alt ) { if ( ! close_effect0 ( obuf , HTML_IMG_ALT ) ) push_tag ( obuf , \"</img_alt>\" , HTML_N_IMG_ALT ) ; obuf -> img_alt = NULL ; } return 1 ; case HTML_INPUT_ALT : i = 0 ; if ( parsedtag_get_value ( tag , ATTR_TOP_MARGIN , & i ) ) { if ( i > obuf -> top_margin ) obuf -> top_margin = i ; } i = 0 ; if ( parsedtag_get_value ( tag , ATTR_BOTTOM_MARGIN , & i ) ) { if ( i > obuf -> bottom_margin ) obuf -> bottom_margin = i ; } if ( parsedtag_get_value ( tag , ATTR_HSEQ , & hseq ) ) { obuf -> input_alt . hseq = hseq ; } if ( parsedtag_get_value ( tag , ATTR_FID , & i ) ) { obuf -> input_alt . fid = i ; } if ( parsedtag_get_value ( tag , ATTR_TYPE , & p ) ) { obuf -> input_alt . type = Strnew_charp ( p ) ; } if ( parsedtag_get_value ( tag , ATTR_VALUE , & p ) ) { obuf -> input_alt . value = Strnew_charp ( p ) ; } if ( parsedtag_get_value ( tag , ATTR_NAME , & p ) ) { obuf -> input_alt . name = Strnew_charp ( p ) ; } obuf -> input_alt . in = 1 ; return 0 ; case HTML_N_INPUT_ALT : if ( obuf -> input_alt . in ) { if ( ! close_effect0 ( obuf , HTML_INPUT_ALT ) ) push_tag ( obuf , \"</input_alt>\" , HTML_N_INPUT_ALT ) ; obuf -> input_alt . hseq = 0 ; obuf -> input_alt . fid = - 1 ; obuf -> input_alt . in = 0 ; obuf -> input_alt . type = NULL ; obuf -> input_alt . name = NULL ; obuf -> input_alt . value = NULL ; } return 1 ; case HTML_TABLE : close_anchor ( h_env , obuf ) ; obuf -> table_level ++ ; if ( obuf -> table_level >= MAX_TABLE ) break ; w = BORDER_NONE ; x = 2 ; y = 1 ; z = 0 ; width = 0 ; if ( parsedtag_exists ( tag , ATTR_BORDER ) ) { if ( parsedtag_get_value ( tag , ATTR_BORDER , & w ) ) { if ( w > 2 ) w = BORDER_THICK ; else if ( w < 0 ) { w = BORDER_THIN ; } } else w = BORDER_THIN ; } if ( DisplayBorders && w == BORDER_NONE ) w = BORDER_THIN ; if ( parsedtag_get_value ( tag , ATTR_WIDTH , & i ) ) { if ( obuf -> table_level == 0 ) width = REAL_WIDTH ( i , h_env -> limit - envs [ h_env -> envc ] . indent ) ; else width = RELATIVE_WIDTH ( i ) ; } if ( parsedtag_exists ( tag , ATTR_HBORDER ) ) w = BORDER_NOWIN ; # define MAX_CELLSPACING 1000 # define MAX_CELLPADDING 1000 # define MAX_VSPACE 1000 parsedtag_get_value ( tag , ATTR_CELLSPACING , & x ) ; parsedtag_get_value ( tag , ATTR_CELLPADDING , & y ) ; parsedtag_get_value ( tag , ATTR_VSPACE , & z ) ; if ( x > MAX_CELLSPACING ) x = MAX_CELLSPACING ; if ( y > MAX_CELLPADDING ) y = MAX_CELLPADDING ; if ( z > MAX_VSPACE ) z = MAX_VSPACE ; # ifdef ID_EXT parsedtag_get_value ( tag , ATTR_ID , & id ) ; # endif tables [ obuf -> table_level ] = begin_table ( w , x , y , z ) ; # ifdef ID_EXT if ( id != NULL ) tables [ obuf -> table_level ] -> id = Strnew_charp ( id ) ; # endif table_mode [ obuf -> table_level ] . pre_mode = 0 ; table_mode [ obuf -> table_level ] . indent_level = 0 ; table_mode [ obuf -> table_level ] . nobr_level = 0 ; table_mode [ obuf -> table_level ] . caption = 0 ; table_mode [ obuf -> table_level ] . end_tag = 0 ; # ifndef TABLE_EXPAND tables [ obuf -> table_level ] -> total_width = width ; # else tables [ obuf -> table_level ] -> real_width = width ; tables [ obuf -> table_level ] -> total_width = 0 ; # endif return 1 ; case HTML_N_TABLE : return 1 ; case HTML_CENTER : CLOSE_A ; if ( ! ( obuf -> flag & ( RB_PREMODE | RB_IGNORE_P ) ) ) flushline ( h_env , obuf , envs [ h_env -> envc ] . indent , 0 , h_env -> limit ) ; RB_SAVE_FLAG ( obuf ) ; RB_SET_ALIGN ( obuf , RB_CENTER ) ; return 1 ; case HTML_N_CENTER : CLOSE_A ; if ( ! ( obuf -> flag & RB_PREMODE ) ) flushline ( h_env , obuf , envs [ h_env -> envc ] . indent , 0 , h_env -> limit ) ; RB_RESTORE_FLAG ( obuf ) ; return 1 ; case HTML_DIV : CLOSE_A ; if ( ! ( obuf -> flag & RB_IGNORE_P ) ) flushline ( h_env , obuf , envs [ h_env -> envc ] . indent , 0 , h_env -> limit ) ; set_alignment ( obuf , tag ) ; return 1 ; case HTML_N_DIV : CLOSE_A ; flushline ( h_env , obuf , envs [ h_env -> envc ] . indent , 0 , h_env -> limit ) ; RB_RESTORE_FLAG ( obuf ) ; return 1 ; case HTML_DIV_INT : CLOSE_P ; if ( ! ( obuf -> flag & RB_IGNORE_P ) ) flushline ( h_env , obuf , envs [ h_env -> envc ] . indent , 0 , h_env -> limit ) ; set_alignment ( obuf , tag ) ; return 1 ; case HTML_N_DIV_INT : CLOSE_P ; flushline ( h_env , obuf , envs [ h_env -> envc ] . indent , 0 , h_env -> limit ) ; RB_RESTORE_FLAG ( obuf ) ; return 1 ; case HTML_FORM : CLOSE_A ; if ( ! ( obuf -> flag & RB_IGNORE_P ) ) flushline ( h_env , obuf , envs [ h_env -> envc ] . indent , 0 , h_env -> limit ) ; tmp = process_form ( tag ) ; if ( tmp ) HTMLlineproc1 ( tmp -> ptr , h_env ) ; return 1 ; case HTML_N_FORM : CLOSE_A ; flushline ( h_env , obuf , envs [ h_env -> envc ] . indent , 0 , h_env -> limit ) ; obuf -> flag |= RB_IGNORE_P ; process_n_form ( ) ; return 1 ; case HTML_INPUT : close_anchor ( h_env , obuf ) ; tmp = process_input ( tag ) ; if ( tmp ) HTMLlineproc1 ( tmp -> ptr , h_env ) ; return 1 ; case HTML_BUTTON : tmp = process_button ( tag ) ; if ( tmp ) HTMLlineproc1 ( tmp -> ptr , h_env ) ; return 1 ; case HTML_N_BUTTON : tmp = process_n_button ( ) ; if ( tmp ) HTMLlineproc1 ( tmp -> ptr , h_env ) ; return 1 ; case HTML_SELECT : close_anchor ( h_env , obuf ) ; tmp = process_select ( tag ) ; if ( tmp ) HTMLlineproc1 ( tmp -> ptr , h_env ) ; obuf -> flag |= RB_INSELECT ; obuf -> end_tag = HTML_N_SELECT ; return 1 ; case HTML_N_SELECT : obuf -> flag &= ~ RB_INSELECT ; obuf -> end_tag = 0 ; tmp = process_n_select ( ) ; if ( tmp ) HTMLlineproc1 ( tmp -> ptr , h_env ) ; return 1 ; case HTML_OPTION : return 1 ; case HTML_TEXTAREA : close_anchor ( h_env , obuf ) ; tmp = process_textarea ( tag , h_env -> limit ) ; if ( tmp ) HTMLlineproc1 ( tmp -> ptr , h_env ) ; obuf -> flag |= RB_INTXTA ; obuf -> end_tag = HTML_N_TEXTAREA ; return 1 ; case HTML_N_TEXTAREA : obuf -> flag &= ~ RB_INTXTA ; obuf -> end_tag = 0 ; tmp = process_n_textarea ( ) ; if ( tmp ) HTMLlineproc1 ( tmp -> ptr , h_env ) ; return 1 ; case HTML_ISINDEX : p = \"\" ; q = \"!CURRENT_URL!\" ; parsedtag_get_value ( tag , ATTR_PROMPT , & p ) ; parsedtag_get_value ( tag , ATTR_ACTION , & q ) ; tmp = Strnew_m_charp ( \"<form<S2SV_blank>method=get<S2SV_blank>action=\\\\\"\" , html_quote ( q ) , \"\\\\\">\" , html_quote ( p ) , \"<input<S2SV_blank>type=text<S2SV_blank>name=\\\\\"\\\\\"<S2SV_blank>accept></form>\" , NULL ) ; HTMLlineproc1 ( tmp -> ptr , h_env ) ; return 1 ; case HTML_META : p = q = r = NULL ; parsedtag_get_value ( tag , ATTR_HTTP_EQUIV , & p ) ; parsedtag_get_value ( tag , ATTR_CONTENT , & q ) ; # ifdef USE_M17N parsedtag_get_value ( tag , ATTR_CHARSET , & r ) ; if ( r ) { SKIP_BLANKS ( r ) ; meta_charset = wc_guess_charset ( r , 0 ) ; } else if ( p && q && ! strcasecmp ( p , \"Content-Type\" ) && ( q = strcasestr ( q , \"charset\" ) ) != NULL ) { q += 7 ; SKIP_BLANKS ( q ) ; if ( * q == '=' ) { q ++ ; SKIP_BLANKS ( q ) ; meta_charset = wc_guess_charset ( q , 0 ) ; } } else # endif if ( p && q && ! strcasecmp ( p , \"refresh\" ) ) { int refresh_interval ; tmp = NULL ; refresh_interval = getMetaRefreshParam ( q , & tmp ) ; if ( tmp ) { q = html_quote ( tmp -> ptr ) ; tmp = Sprintf ( \"Refresh<S2SV_blank>(%d<S2SV_blank>sec)<S2SV_blank><a<S2SV_blank>href=\\\\\"%s\\\\\">%s</a>\" , refresh_interval , q , q ) ; } else if ( refresh_interval > 0 ) tmp = Sprintf ( \"Refresh<S2SV_blank>(%d<S2SV_blank>sec)\" , refresh_interval ) ; if ( tmp ) { HTMLlineproc1 ( tmp -> ptr , h_env ) ; do_blankline ( h_env , obuf , envs [ h_env -> envc ] . indent , 0 , h_env -> limit ) ; if ( ! is_redisplay && ! ( ( obuf -> flag & RB_NOFRAMES ) && RenderFrame ) ) { tag -> need_reconstruct = TRUE ; return 0 ; } } } return 1 ; case HTML_BASE : # if defined ( USE_M17N ) || defined ( USE_IMAGE ) p = NULL ; if ( parsedtag_get_value ( tag , ATTR_HREF , & p ) ) { cur_baseURL = New ( ParsedURL ) ; parseURL ( p , cur_baseURL , NULL ) ; } # endif case HTML_MAP : case HTML_N_MAP : case HTML_AREA : return 0 ; case HTML_DEL : switch ( displayInsDel ) { case DISPLAY_INS_DEL_SIMPLE : obuf -> flag |= RB_DEL ; break ; case DISPLAY_INS_DEL_NORMAL : HTMLlineproc1 ( \"<U>[DEL:</U>\" , h_env ) ; break ; case DISPLAY_INS_DEL_FONTIFY : obuf -> in_strike ++ ; if ( obuf -> in_strike == 1 ) { push_tag ( obuf , \"<s>\" , HTML_S ) ; } break ; } return 1 ; case HTML_N_DEL : switch ( displayInsDel ) { case DISPLAY_INS_DEL_SIMPLE : obuf -> flag &= ~ RB_DEL ; break ; case DISPLAY_INS_DEL_NORMAL : HTMLlineproc1 ( \"<U>:DEL]</U>\" , h_env ) ; case DISPLAY_INS_DEL_FONTIFY : if ( obuf -> in_strike == 0 ) return 1 ; if ( obuf -> in_strike == 1 && close_effect0 ( obuf , HTML_S ) ) obuf -> in_strike = 0 ; if ( obuf -> in_strike > 0 ) { obuf -> in_strike -- ; if ( obuf -> in_strike == 0 ) { push_tag ( obuf , \"</s>\" , HTML_N_S ) ; } } break ; } return 1 ; case HTML_S : switch ( displayInsDel ) { case DISPLAY_INS_DEL_SIMPLE : obuf -> flag |= RB_S ; break ; case DISPLAY_INS_DEL_NORMAL : HTMLlineproc1 ( \"<U>[S:</U>\" , h_env ) ; break ; case DISPLAY_INS_DEL_FONTIFY : obuf -> in_strike ++ ; if ( obuf -> in_strike == 1 ) { push_tag ( obuf , \"<s>\" , HTML_S ) ; } break ; } return 1 ; case HTML_N_S : switch ( displayInsDel ) { case DISPLAY_INS_DEL_SIMPLE : obuf -> flag &= ~ RB_S ; break ; case DISPLAY_INS_DEL_NORMAL : HTMLlineproc1 ( \"<U>:S]</U>\" , h_env ) ; break ; case DISPLAY_INS_DEL_FONTIFY : if ( obuf -> in_strike == 0 ) return 1 ; if ( obuf -> in_strike == 1 && close_effect0 ( obuf , HTML_S ) ) obuf -> in_strike = 0 ; if ( obuf -> in_strike > 0 ) { obuf -> in_strike -- ; if ( obuf -> in_strike == 0 ) { push_tag ( obuf , \"</s>\" , HTML_N_S ) ; } } } return 1 ; case HTML_INS : switch ( displayInsDel ) { case DISPLAY_INS_DEL_SIMPLE : break ; case DISPLAY_INS_DEL_NORMAL : HTMLlineproc1 ( \"<U>[INS:</U>\" , h_env ) ; break ; case DISPLAY_INS_DEL_FONTIFY : obuf -> in_ins ++ ; if ( obuf -> in_ins == 1 ) { push_tag ( obuf , \"<ins>\" , HTML_INS ) ; } break ; } return 1 ; case HTML_N_INS : switch ( displayInsDel ) { case DISPLAY_INS_DEL_SIMPLE : break ; case DISPLAY_INS_DEL_NORMAL : HTMLlineproc1 ( \"<U>:INS]</U>\" , h_env ) ; break ; case DISPLAY_INS_DEL_FONTIFY : if ( obuf -> in_ins == 0 ) return 1 ; if ( obuf -> in_ins == 1 && close_effect0 ( obuf , HTML_INS ) ) obuf -> in_ins = 0 ; if ( obuf -> in_ins > 0 ) { obuf -> in_ins -- ; if ( obuf -> in_ins == 0 ) { push_tag ( obuf , \"</ins>\" , HTML_N_INS ) ; } } break ; } return 1 ; case HTML_SUP : if ( ! ( obuf -> flag & ( RB_DEL | RB_S ) ) ) HTMLlineproc1 ( \"^\" , h_env ) ; return 1 ; case HTML_N_SUP : return 1 ; case HTML_SUB : if ( ! ( obuf -> flag & ( RB_DEL | RB_S ) ) ) HTMLlineproc1 ( \"[\" , h_env ) ; return 1 ; case HTML_N_SUB : if ( ! ( obuf -> flag & ( RB_DEL | RB_S ) ) ) HTMLlineproc1 ( \"]\" , h_env ) ; return 1 ; case HTML_FONT : case HTML_N_FONT : case HTML_NOP : return 1 ; case HTML_BGSOUND : if ( view_unseenobject ) { if ( parsedtag_get_value ( tag , ATTR_SRC , & p ) ) { Str s ; q = html_quote ( p ) ; s = Sprintf ( \"<A<S2SV_blank>HREF=\\\\\"%s\\\\\">bgsound(%s)</A>\" , q , q ) ; HTMLlineproc1 ( s -> ptr , h_env ) ; } } return 1 ; case HTML_EMBED : if ( view_unseenobject ) { if ( parsedtag_get_value ( tag , ATTR_SRC , & p ) ) { Str s ; q = html_quote ( p ) ; s = Sprintf ( \"<A<S2SV_blank>HREF=\\\\\"%s\\\\\">embed(%s)</A>\" , q , q ) ; HTMLlineproc1 ( s -> ptr , h_env ) ; } } return 1 ; case HTML_APPLET : if ( view_unseenobject ) { if ( parsedtag_get_value ( tag , ATTR_ARCHIVE , & p ) ) { Str s ; q = html_quote ( p ) ; s = Sprintf ( \"<A<S2SV_blank>HREF=\\\\\"%s\\\\\">applet<S2SV_blank>archive(%s)</A>\" , q , q ) ; HTMLlineproc1 ( s -> ptr , h_env ) ; } } return 1 ; case HTML_BODY : if ( view_unseenobject ) { if ( parsedtag_get_value ( tag , ATTR_BACKGROUND , & p ) ) { Str s ; q = html_quote ( p ) ; s = Sprintf ( \"<IMG<S2SV_blank>SRC=\\\\\"%s\\\\\"<S2SV_blank>ALT=\\\\\"bg<S2SV_blank>image(%s)\\\\\"><BR>\" , q , q ) ; HTMLlineproc1 ( s -> ptr , h_env ) ; } } case HTML_N_HEAD : if ( obuf -> flag & RB_TITLE ) HTMLlineproc1 ( \"</title>\" , h_env ) ; case HTML_HEAD : case HTML_N_BODY : return 1 ; default : return 0 ; } return 0 ; }\n",
      "fixed_code": "<S2SV_ModStart> ; if ( h_env -> envc == 0 || ( h_env -> envc_real < h_env -> nenv && envs [ h_env -> envc ] . env != HTML_DL && envs [ h_env -> envc ] . env != HTML_DL_COMPACT ) ) { PUSH_ENV ( HTML_DL ) ; } if (\n",
      "source_code_length": 26678,
      "target_code_length": 212,
      "vulnerability_patterns": {
        "buffer_overflow": 8,
        "use_after_free": 1,
        "integer_overflow": 23,
        "format_string": 8,
        "null_pointer": 362,
        "total": 402
      },
      "total_patterns": 402,
      "original_address": "https://github.com/tats/w3m/commit/33509cc81ec5f2ba44eb6fd98bd5c1b5873e46bd",
      "discovery_time": "2017-01-20T15:59Z",
      "project_commit_id": "tats@w3m/33509cc81ec5f2ba44eb6fd98bd5c1b5873e46bd",
      "extraction_time": "2025-08-31T15:41:49.187798",
      "label": 1,
      "vulnerability_type": "improper_input_validation",
      "difficulty_level": "advanced",
      "risk_factors": [
        "buffer_overflow",
        "use_after_free"
      ],
      "attack_vectors": [
        "fuzzing",
        "code_analysis",
        "reverse_engineering"
      ],
      "mitigation_strategies": [
        "dynamic_analysis",
        "static_analysis",
        "fuzzing",
        "code_review",
        "secure_coding_practices"
      ],
      "code_differences": {
        "has_differences": true,
        "source_lines": 2,
        "target_lines": 2,
        "character_differences": 26466,
        "similarity_percentage": 5.605381165919283
      },
      "vulnerability_location": {
        "vulnerability_present": true,
        "fix_applied": true,
        "code_changed": true,
        "estimated_lines_changed": 0
      }
    },
    {
      "cve_id": "CVE-2013-4119",
      "cwe_id": "CWE-476",
      "cwe_name": "NULL Pointer Dereference",
      "project": "FreeRDP",
      "severity": "critical",
      "weaponization_score": 7.5,
      "is_critical": true,
      "is_weaponizable": true,
      "is_high_priority_project": false,
      "vulnerable_code": "CWE-476 rdpCredssp * credssp_new ( freerdp * instance , rdpTransport * transport , rdpSettings * settings ) { rdpCredssp * credssp ; credssp = ( rdpCredssp * ) malloc ( sizeof ( rdpCredssp ) ) ; ZeroMemory ( credssp , sizeof ( rdpCredssp ) ) ; if ( credssp != NULL ) { HKEY hKey ; LONG status ; DWORD dwType ; DWORD dwSize ; credssp -> instance = instance ; credssp -> settings = settings ; credssp -> server = settings -> ServerMode ; credssp -> transport = transport ; credssp -> send_seq_num = 0 ; credssp -> recv_seq_num = 0 ; ZeroMemory ( & credssp -> negoToken , sizeof ( SecBuffer ) ) ; ZeroMemory ( & credssp -> pubKeyAuth , sizeof ( SecBuffer ) ) ; <S2SV_StartBug> ZeroMemory ( & credssp -> authInfo , sizeof ( SecBuffer ) ) ; <S2SV_EndBug> if ( credssp -> server ) { status = RegOpenKeyEx ( HKEY_LOCAL_MACHINE , _T ( \"Software\\\\\\\\FreeRDP\\\\\\\\Server\" ) , 0 , KEY_READ | KEY_WOW64_64KEY , & hKey ) ; if ( status == ERROR_SUCCESS ) { status = RegQueryValueEx ( hKey , _T ( \"SspiModule\" ) , NULL , & dwType , NULL , & dwSize ) ; if ( status == ERROR_SUCCESS ) { credssp -> SspiModule = ( LPTSTR ) malloc ( dwSize + sizeof ( TCHAR ) ) ; status = RegQueryValueEx ( hKey , _T ( \"SspiModule\" ) , NULL , & dwType , ( BYTE * ) credssp -> SspiModule , & dwSize ) ; if ( status == ERROR_SUCCESS ) { _tprintf ( _T ( \"Using<S2SV_blank>SSPI<S2SV_blank>Module:<S2SV_blank>%s\\\\n\" ) , credssp -> SspiModule ) ; RegCloseKey ( hKey ) ; } } } } } return credssp ; }\n",
      "fixed_code": "<S2SV_ModStart> ( SecBuffer ) ) ; SecInvalidateHandle ( & credssp -> context\n",
      "source_code_length": 1454,
      "target_code_length": 77,
      "vulnerability_patterns": {
        "use_after_free": 2,
        "null_pointer": 14,
        "memory_leak": 2,
        "total": 18
      },
      "total_patterns": 18,
      "original_address": "https://github.com/FreeRDP/FreeRDP/commit/0773bb9303d24473fe1185d85a424dfe159aff53",
      "discovery_time": "2016-10-03T21:59Z",
      "project_commit_id": "FreeRDP@FreeRDP/0773bb9303d24473fe1185d85a424dfe159aff53",
      "extraction_time": "2025-08-31T15:41:49.188001",
      "label": 1,
      "vulnerability_type": "null_pointer_dereference",
      "difficulty_level": "advanced",
      "risk_factors": [
        "system_crash",
        "denial_of_service",
        "memory_corruption",
        "use_after_free"
      ],
      "attack_vectors": [
        "memory_manipulation",
        "null_pointer",
        "code_analysis",
        "reverse_engineering",
        "use_after_free",
        "fuzzing"
      ],
      "mitigation_strategies": [
        "null_pointer_checks",
        "fuzzing",
        "dynamic_analysis",
        "memory_management",
        "static_analysis",
        "use_after_free_prevention",
        "code_review",
        "secure_coding_practices"
      ],
      "code_differences": {
        "has_differences": true,
        "source_lines": 2,
        "target_lines": 2,
        "character_differences": 1377,
        "similarity_percentage": 10.44776119402985
      },
      "vulnerability_location": {
        "vulnerability_present": true,
        "fix_applied": true,
        "code_changed": true,
        "estimated_lines_changed": 0
      }
    },
    {
      "cve_id": "CVE-2019-10672",
      "cwe_id": "CWE-20",
      "cwe_name": "Improper Input Validation",
      "project": "hoene",
      "severity": "critical",
      "weaponization_score": 7.5,
      "is_critical": true,
      "is_weaponizable": true,
      "is_high_priority_project": false,
      "vulnerable_code": "CWE-20 int treeRead ( struct READER * reader , struct DATAOBJECT * data ) { int i , j , err , olen , elements , size , x , y , z , b , e , dy , dz , sx , sy , sz , dzy , szy ; char * input , * output ; uint8_t node_type , node_level ; uint16_t entries_used ; uint32_t size_of_chunk ; uint32_t filter_mask ; uint64_t address_of_left_sibling , address_of_right_sibling , start [ 4 ] , child_pointer , key , store ; char buf [ 4 ] ; UNUSED ( node_level ) ; UNUSED ( address_of_right_sibling ) ; UNUSED ( address_of_left_sibling ) ; UNUSED ( key ) ; if ( data -> ds . dimensionality > 3 ) { log ( \"TREE<S2SV_blank>dimensions<S2SV_blank>><S2SV_blank>3\" ) ; return MYSOFA_INVALID_FORMAT ; } if ( fread ( buf , 1 , 4 , reader -> fhd ) != 4 || strncmp ( buf , \"TREE\" , 4 ) ) { log ( \"cannot<S2SV_blank>read<S2SV_blank>signature<S2SV_blank>of<S2SV_blank>TREE\\\\n\" ) ; return MYSOFA_INVALID_FORMAT ; } log ( \"%08lX<S2SV_blank>%.4s\\\\n\" , ( uint64_t ) ftell ( reader -> fhd ) - 4 , buf ) ; node_type = ( uint8_t ) fgetc ( reader -> fhd ) ; node_level = ( uint8_t ) fgetc ( reader -> fhd ) ; entries_used = ( uint16_t ) readValue ( reader , 2 ) ; if ( entries_used > 0x1000 ) return MYSOFA_UNSUPPORTED_FORMAT ; address_of_left_sibling = readValue ( reader , reader -> superblock . size_of_offsets ) ; address_of_right_sibling = readValue ( reader , reader -> superblock . size_of_offsets ) ; elements = 1 ; for ( j = 0 ; j < data -> ds . dimensionality ; j ++ ) elements *= data -> datalayout_chunk [ j ] ; dy = data -> datalayout_chunk [ 1 ] ; dz = data -> datalayout_chunk [ 2 ] ; sx = data -> ds . dimension_size [ 0 ] ; sy = data -> ds . dimension_size [ 1 ] ; sz = data -> ds . dimension_size [ 2 ] ; dzy = dz * dy ; szy = sz * sy ; size = data -> datalayout_chunk [ data -> ds . dimensionality ] ; log ( \"elements<S2SV_blank>%d<S2SV_blank>size<S2SV_blank>%d\\\\n\" , elements , size ) ; if ( ! ( output = malloc ( elements * size ) ) ) { return MYSOFA_NO_MEMORY ; } for ( e = 0 ; e < entries_used * 2 ; e ++ ) { if ( node_type == 0 ) { key = readValue ( reader , reader -> superblock . size_of_lengths ) ; } else { size_of_chunk = ( uint32_t ) readValue ( reader , 4 ) ; filter_mask = ( uint32_t ) readValue ( reader , 4 ) ; if ( filter_mask ) { log ( \"TREE<S2SV_blank>all<S2SV_blank>filters<S2SV_blank>must<S2SV_blank>be<S2SV_blank>enabled\\\\n\" ) ; free ( output ) ; return MYSOFA_INVALID_FORMAT ; } for ( j = 0 ; j < data -> ds . dimensionality ; j ++ ) { start [ j ] = readValue ( reader , 8 ) ; log ( \"start<S2SV_blank>%d<S2SV_blank>%lu\\\\n\" , j , start [ j ] ) ; } if ( readValue ( reader , 8 ) ) { break ; } child_pointer = readValue ( reader , reader -> superblock . size_of_offsets ) ; log ( \"<S2SV_blank>data<S2SV_blank>at<S2SV_blank>%lX<S2SV_blank>len<S2SV_blank>%u\\\\n\" , child_pointer , size_of_chunk ) ; store = ftell ( reader -> fhd ) ; if ( fseek ( reader -> fhd , child_pointer , SEEK_SET ) < 0 ) { free ( output ) ; return errno ; } if ( ! ( input = malloc ( size_of_chunk ) ) ) { free ( output ) ; return MYSOFA_NO_MEMORY ; } if ( fread ( input , 1 , size_of_chunk , reader -> fhd ) != size_of_chunk ) { free ( output ) ; free ( input ) ; return MYSOFA_INVALID_FORMAT ; } olen = elements * size ; err = gunzip ( size_of_chunk , input , & olen , output ) ; free ( input ) ; log ( \"<S2SV_blank><S2SV_blank><S2SV_blank>gunzip<S2SV_blank>%d<S2SV_blank>%d<S2SV_blank>%d\\\\n\" , err , olen , elements * size ) ; if ( err || olen != elements * size ) { free ( output ) ; return MYSOFA_INVALID_FORMAT ; } switch ( data -> ds . dimensionality ) { case 1 : for ( i = 0 ; i < olen ; i ++ ) { b = i / elements ; x = i % elements + start [ 0 ] ; <S2SV_StartBug> if ( x < sx ) { <S2SV_EndBug> <S2SV_StartBug> j = x * size + b ; <S2SV_EndBug> ( ( char * ) data -> data ) [ j ] = output [ i ] ; } } break ; case 2 : for ( i = 0 ; i < olen ; i ++ ) { b = i / elements ; x = i % elements ; y = x % dy + start [ 1 ] ; x = x / dy + start [ 0 ] ; <S2SV_StartBug> if ( y < sy && x < sx ) { <S2SV_EndBug> <S2SV_StartBug> j = ( ( x * sy + y ) * size ) + b ; <S2SV_EndBug> ( ( char * ) data -> data ) [ j ] = output [ i ] ; } } break ; case 3 : for ( i = 0 ; i < olen ; i ++ ) { b = i / elements ; x = i % elements ; z = x % dz + start [ 2 ] ; y = ( x / dz ) % dy + start [ 1 ] ; x = ( x / dzy ) + start [ 0 ] ; <S2SV_StartBug> if ( z < sz && y < sy && x < sx ) { <S2SV_EndBug> j = ( x * szy + y * sz + z ) * size + b ; <S2SV_StartBug> ( ( char * ) data -> data ) [ j ] = output [ i ] ; <S2SV_EndBug> } } break ; default : log ( \"invalid<S2SV_blank>dim\\\\n\" ) ; return MYSOFA_INTERNAL_ERROR ; } if ( fseek ( reader -> fhd , store , SEEK_SET ) < 0 ) { free ( output ) ; return errno ; } } } free ( output ) ; if ( fseek ( reader -> fhd , 4 , SEEK_CUR ) < 0 ) return errno ; return MYSOFA_OK ; }\n",
      "fixed_code": "<S2SV_ModStart> 0 ] ; <S2SV_ModEnd> j = x <S2SV_ModStart> + b ; if ( j >= 0 && j < elements * size ) { <S2SV_ModStart> 0 ] ; <S2SV_ModEnd> j = ( <S2SV_ModStart> + b ; if ( j >= 0 && j < elements * size ) { <S2SV_ModStart> 0 ] ; <S2SV_ModEnd> j = ( <S2SV_ModStart> + b ; if ( j >= 0 && j < elements * size ) {\n",
      "source_code_length": 4770,
      "target_code_length": 309,
      "vulnerability_patterns": {
        "buffer_overflow": 2,
        "use_after_free": 11,
        "integer_overflow": 7,
        "null_pointer": 28,
        "memory_leak": 2,
        "total": 50
      },
      "total_patterns": 50,
      "original_address": "https://github.com/hoene/libmysofa/commit/d39a171e9c6a1c44dbdf43f9db6c3fbd887e38c1",
      "discovery_time": "2019-03-31T17:29Z",
      "project_commit_id": "hoene@libmysofa/d39a171e9c6a1c44dbdf43f9db6c3fbd887e38c1",
      "extraction_time": "2025-08-31T15:41:49.188022",
      "label": 1,
      "vulnerability_type": "improper_input_validation",
      "difficulty_level": "advanced",
      "risk_factors": [
        "buffer_overflow",
        "use_after_free"
      ],
      "attack_vectors": [
        "fuzzing",
        "code_analysis",
        "reverse_engineering"
      ],
      "mitigation_strategies": [
        "dynamic_analysis",
        "static_analysis",
        "fuzzing",
        "code_review",
        "secure_coding_practices"
      ],
      "code_differences": {
        "has_differences": true,
        "source_lines": 2,
        "target_lines": 2,
        "character_differences": 4461,
        "similarity_percentage": 13.178294573643413
      },
      "vulnerability_location": {
        "vulnerability_present": true,
        "fix_applied": true,
        "code_changed": true,
        "estimated_lines_changed": 0
      }
    },
    {
      "cve_id": "CVE-2016-8887",
      "cwe_id": "CWE-476",
      "cwe_name": "NULL Pointer Dereference",
      "project": "mdadams",
      "severity": "critical",
      "weaponization_score": 7.5,
      "is_critical": true,
      "is_weaponizable": true,
      "is_high_priority_project": false,
      "vulnerable_code": "CWE-476 jas_image_t * jp2_decode ( jas_stream_t * in , char * optstr ) { jp2_box_t * box ; int found ; jas_image_t * image ; jp2_dec_t * dec ; bool samedtype ; int dtype ; unsigned int i ; jp2_cmap_t * cmapd ; jp2_pclr_t * pclrd ; jp2_cdef_t * cdefd ; unsigned int channo ; int newcmptno ; int_fast32_t * lutents ; # if 0 jp2_cdefchan_t * cdefent ; int cmptno ; # endif jp2_cmapent_t * cmapent ; jas_icchdr_t icchdr ; jas_iccprof_t * iccprof ; dec = 0 ; box = 0 ; image = 0 ; if ( ! ( dec = jp2_dec_create ( ) ) ) { goto error ; } if ( ! ( box = jp2_box_get ( in ) ) ) { jas_eprintf ( \"error:<S2SV_blank>cannot<S2SV_blank>get<S2SV_blank>box\\\\n\" ) ; goto error ; } if ( box -> type != JP2_BOX_JP ) { jas_eprintf ( \"error:<S2SV_blank>expecting<S2SV_blank>signature<S2SV_blank>box\\\\n\" ) ; goto error ; } if ( box -> data . jp . magic != JP2_JP_MAGIC ) { jas_eprintf ( \"incorrect<S2SV_blank>magic<S2SV_blank>number\\\\n\" ) ; goto error ; } jp2_box_destroy ( box ) ; box = 0 ; if ( ! ( box = jp2_box_get ( in ) ) ) { goto error ; } if ( box -> type != JP2_BOX_FTYP ) { jas_eprintf ( \"expecting<S2SV_blank>file<S2SV_blank>type<S2SV_blank>box\\\\n\" ) ; goto error ; } jp2_box_destroy ( box ) ; box = 0 ; found = 0 ; while ( ( box = jp2_box_get ( in ) ) ) { if ( jas_getdbglevel ( ) >= 1 ) { <S2SV_StartBug> jas_eprintf ( \"box<S2SV_blank>type<S2SV_blank>%s\\\\n\" , box -> info -> name ) ; <S2SV_EndBug> } switch ( box -> type ) { case JP2_BOX_JP2C : found = 1 ; break ; case JP2_BOX_IHDR : if ( ! dec -> ihdr ) { dec -> ihdr = box ; box = 0 ; } break ; case JP2_BOX_BPCC : if ( ! dec -> bpcc ) { dec -> bpcc = box ; box = 0 ; } break ; case JP2_BOX_CDEF : if ( ! dec -> cdef ) { dec -> cdef = box ; box = 0 ; } break ; case JP2_BOX_PCLR : if ( ! dec -> pclr ) { dec -> pclr = box ; box = 0 ; } break ; case JP2_BOX_CMAP : if ( ! dec -> cmap ) { dec -> cmap = box ; box = 0 ; } break ; case JP2_BOX_COLR : if ( ! dec -> colr ) { dec -> colr = box ; box = 0 ; } break ; } if ( box ) { jp2_box_destroy ( box ) ; box = 0 ; } if ( found ) { break ; } } if ( ! found ) { jas_eprintf ( \"error:<S2SV_blank>no<S2SV_blank>code<S2SV_blank>stream<S2SV_blank>found\\\\n\" ) ; goto error ; } if ( ! ( dec -> image = jpc_decode ( in , optstr ) ) ) { jas_eprintf ( \"error:<S2SV_blank>cannot<S2SV_blank>decode<S2SV_blank>code<S2SV_blank>stream\\\\n\" ) ; goto error ; } if ( ! dec -> ihdr ) { jas_eprintf ( \"error:<S2SV_blank>missing<S2SV_blank>IHDR<S2SV_blank>box\\\\n\" ) ; goto error ; } if ( dec -> ihdr -> data . ihdr . numcmpts != JAS_CAST ( uint , jas_image_numcmpts ( dec -> image ) ) ) { jas_eprintf ( \"warning:<S2SV_blank>number<S2SV_blank>of<S2SV_blank>components<S2SV_blank>mismatch\\\\n\" ) ; } if ( ! jas_image_numcmpts ( dec -> image ) ) { jas_eprintf ( \"error:<S2SV_blank>no<S2SV_blank>components\\\\n\" ) ; goto error ; } samedtype = true ; dtype = jas_image_cmptdtype ( dec -> image , 0 ) ; for ( i = 1 ; i < JAS_CAST ( uint , jas_image_numcmpts ( dec -> image ) ) ; ++ i ) { if ( jas_image_cmptdtype ( dec -> image , i ) != dtype ) { samedtype = false ; break ; } } if ( ( samedtype && dec -> ihdr -> data . ihdr . bpc != JP2_DTYPETOBPC ( dtype ) ) || ( ! samedtype && dec -> ihdr -> data . ihdr . bpc != JP2_IHDR_BPCNULL ) ) { jas_eprintf ( \"warning:<S2SV_blank>component<S2SV_blank>data<S2SV_blank>type<S2SV_blank>mismatch\\\\n\" ) ; } if ( dec -> ihdr -> data . ihdr . comptype != JP2_IHDR_COMPTYPE ) { jas_eprintf ( \"error:<S2SV_blank>unsupported<S2SV_blank>compression<S2SV_blank>type\\\\n\" ) ; goto error ; } if ( dec -> bpcc ) { if ( dec -> bpcc -> data . bpcc . numcmpts != JAS_CAST ( uint , jas_image_numcmpts ( dec -> image ) ) ) { jas_eprintf ( \"warning:<S2SV_blank>number<S2SV_blank>of<S2SV_blank>components<S2SV_blank>mismatch\\\\n\" ) ; } if ( ! samedtype ) { for ( i = 0 ; i < JAS_CAST ( uint , jas_image_numcmpts ( dec -> image ) ) ; ++ i ) { if ( jas_image_cmptdtype ( dec -> image , i ) != JP2_BPCTODTYPE ( dec -> bpcc -> data . bpcc . bpcs [ i ] ) ) { jas_eprintf ( \"warning:<S2SV_blank>component<S2SV_blank>data<S2SV_blank>type<S2SV_blank>mismatch\\\\n\" ) ; } } } else { jas_eprintf ( \"warning:<S2SV_blank>superfluous<S2SV_blank>BPCC<S2SV_blank>box\\\\n\" ) ; } } if ( ! dec -> colr ) { jas_eprintf ( \"error:<S2SV_blank>no<S2SV_blank>COLR<S2SV_blank>box\\\\n\" ) ; goto error ; } switch ( dec -> colr -> data . colr . method ) { case JP2_COLR_ENUM : jas_image_setclrspc ( dec -> image , jp2_getcs ( & dec -> colr -> data . colr ) ) ; break ; case JP2_COLR_ICC : iccprof = jas_iccprof_createfrombuf ( dec -> colr -> data . colr . iccp , dec -> colr -> data . colr . iccplen ) ; if ( ! iccprof ) { jas_eprintf ( \"error:<S2SV_blank>failed<S2SV_blank>to<S2SV_blank>parse<S2SV_blank>ICC<S2SV_blank>profile\\\\n\" ) ; goto error ; } jas_iccprof_gethdr ( iccprof , & icchdr ) ; jas_eprintf ( \"ICC<S2SV_blank>Profile<S2SV_blank>CS<S2SV_blank>%08x\\\\n\" , icchdr . colorspc ) ; jas_image_setclrspc ( dec -> image , fromiccpcs ( icchdr . colorspc ) ) ; dec -> image -> cmprof_ = jas_cmprof_createfromiccprof ( iccprof ) ; assert ( dec -> image -> cmprof_ ) ; jas_iccprof_destroy ( iccprof ) ; break ; } if ( dec -> cmap && ! dec -> pclr ) { jas_eprintf ( \"warning:<S2SV_blank>missing<S2SV_blank>PCLR<S2SV_blank>box<S2SV_blank>or<S2SV_blank>superfluous<S2SV_blank>CMAP<S2SV_blank>box\\\\n\" ) ; jp2_box_destroy ( dec -> cmap ) ; dec -> cmap = 0 ; } if ( ! dec -> cmap && dec -> pclr ) { jas_eprintf ( \"warning:<S2SV_blank>missing<S2SV_blank>CMAP<S2SV_blank>box<S2SV_blank>or<S2SV_blank>superfluous<S2SV_blank>PCLR<S2SV_blank>box\\\\n\" ) ; jp2_box_destroy ( dec -> pclr ) ; dec -> pclr = 0 ; } dec -> numchans = dec -> cmap ? dec -> cmap -> data . cmap . numchans : JAS_CAST ( uint , jas_image_numcmpts ( dec -> image ) ) ; if ( dec -> cmap ) { for ( i = 0 ; i < dec -> numchans ; ++ i ) { if ( dec -> cmap -> data . cmap . ents [ i ] . cmptno >= JAS_CAST ( uint , jas_image_numcmpts ( dec -> image ) ) ) { jas_eprintf ( \"error:<S2SV_blank>invalid<S2SV_blank>component<S2SV_blank>number<S2SV_blank>in<S2SV_blank>CMAP<S2SV_blank>box\\\\n\" ) ; goto error ; } if ( dec -> cmap -> data . cmap . ents [ i ] . pcol >= dec -> pclr -> data . pclr . numchans ) { jas_eprintf ( \"error:<S2SV_blank>invalid<S2SV_blank>CMAP<S2SV_blank>LUT<S2SV_blank>index\\\\n\" ) ; goto error ; } } } if ( ! ( dec -> chantocmptlut = jas_alloc2 ( dec -> numchans , sizeof ( uint_fast16_t ) ) ) ) { jas_eprintf ( \"error:<S2SV_blank>no<S2SV_blank>memory\\\\n\" ) ; goto error ; } if ( ! dec -> cmap ) { for ( i = 0 ; i < dec -> numchans ; ++ i ) { dec -> chantocmptlut [ i ] = i ; } } else { cmapd = & dec -> cmap -> data . cmap ; pclrd = & dec -> pclr -> data . pclr ; cdefd = & dec -> cdef -> data . cdef ; for ( channo = 0 ; channo < cmapd -> numchans ; ++ channo ) { cmapent = & cmapd -> ents [ channo ] ; if ( cmapent -> map == JP2_CMAP_DIRECT ) { dec -> chantocmptlut [ channo ] = channo ; } else if ( cmapent -> map == JP2_CMAP_PALETTE ) { lutents = jas_alloc2 ( pclrd -> numlutents , sizeof ( int_fast32_t ) ) ; for ( i = 0 ; i < pclrd -> numlutents ; ++ i ) { lutents [ i ] = pclrd -> lutdata [ cmapent -> pcol + i * pclrd -> numchans ] ; } newcmptno = jas_image_numcmpts ( dec -> image ) ; jas_image_depalettize ( dec -> image , cmapent -> cmptno , pclrd -> numlutents , lutents , JP2_BPCTODTYPE ( pclrd -> bpc [ cmapent -> pcol ] ) , newcmptno ) ; dec -> chantocmptlut [ channo ] = newcmptno ; jas_free ( lutents ) ; # if 0 if ( dec -> cdef ) { cdefent = jp2_cdef_lookup ( cdefd , channo ) ; if ( ! cdefent ) { abort ( ) ; } jas_image_setcmpttype ( dec -> image , newcmptno , jp2_getct ( jas_image_clrspc ( dec -> image ) , cdefent -> type , cdefent -> assoc ) ) ; } else { jas_image_setcmpttype ( dec -> image , newcmptno , jp2_getct ( jas_image_clrspc ( dec -> image ) , 0 , channo + 1 ) ) ; } # endif } } } for ( i = 0 ; i < JAS_CAST ( uint , jas_image_numcmpts ( dec -> image ) ) ; ++ i ) { jas_image_setcmpttype ( dec -> image , i , JAS_IMAGE_CT_UNKNOWN ) ; } if ( dec -> cdef ) { for ( i = 0 ; i < dec -> numchans ; ++ i ) { if ( dec -> cdef -> data . cdef . ents [ i ] . channo >= dec -> numchans ) { jas_eprintf ( \"error:<S2SV_blank>invalid<S2SV_blank>channel<S2SV_blank>number<S2SV_blank>in<S2SV_blank>CDEF<S2SV_blank>box\\\\n\" ) ; goto error ; } jas_image_setcmpttype ( dec -> image , dec -> chantocmptlut [ dec -> cdef -> data . cdef . ents [ i ] . channo ] , jp2_getct ( jas_image_clrspc ( dec -> image ) , dec -> cdef -> data . cdef . ents [ i ] . type , dec -> cdef -> data . cdef . ents [ i ] . assoc ) ) ; } } else { for ( i = 0 ; i < dec -> numchans ; ++ i ) { jas_image_setcmpttype ( dec -> image , dec -> chantocmptlut [ i ] , jp2_getct ( jas_image_clrspc ( dec -> image ) , 0 , i + 1 ) ) ; } } for ( i = jas_image_numcmpts ( dec -> image ) ; i > 0 ; -- i ) { if ( jas_image_cmpttype ( dec -> image , i - 1 ) == JAS_IMAGE_CT_UNKNOWN ) { jas_image_delcmpt ( dec -> image , i - 1 ) ; } } if ( ! jas_image_numcmpts ( dec -> image ) ) { jas_eprintf ( \"error:<S2SV_blank>no<S2SV_blank>components\\\\n\" ) ; goto error ; } # if 0 jas_eprintf ( \"no<S2SV_blank>of<S2SV_blank>components<S2SV_blank>is<S2SV_blank>%d\\\\n\" , jas_image_numcmpts ( dec -> image ) ) ; # endif image = dec -> image ; dec -> image = 0 ; jp2_dec_destroy ( dec ) ; return image ; error : if ( box ) { jp2_box_destroy ( box ) ; } if ( dec ) { jp2_dec_destroy ( dec ) ; } return 0 ; }\n",
      "fixed_code": "<S2SV_ModStart> { jas_eprintf ( \"got<S2SV_blank>box<S2SV_blank>type<S2SV_blank>%s\\\\n\" <S2SV_ModEnd> , box ->\n",
      "source_code_length": 9287,
      "target_code_length": 109,
      "vulnerability_patterns": {
        "use_after_free": 6,
        "integer_overflow": 10,
        "null_pointer": 148,
        "total": 164
      },
      "total_patterns": 164,
      "original_address": "https://github.com/mdadams/jasper/commit/e24bdc716c3327b067c551bc6cfb97fd2370358d",
      "discovery_time": "2017-03-23T18:59Z",
      "project_commit_id": "mdadams@jasper/e24bdc716c3327b067c551bc6cfb97fd2370358d",
      "extraction_time": "2025-08-31T15:41:49.188073",
      "label": 1,
      "vulnerability_type": "null_pointer_dereference",
      "difficulty_level": "advanced",
      "risk_factors": [
        "system_crash",
        "denial_of_service",
        "memory_corruption",
        "use_after_free"
      ],
      "attack_vectors": [
        "memory_manipulation",
        "null_pointer",
        "code_analysis",
        "reverse_engineering",
        "use_after_free",
        "fuzzing"
      ],
      "mitigation_strategies": [
        "null_pointer_checks",
        "fuzzing",
        "dynamic_analysis",
        "memory_management",
        "static_analysis",
        "use_after_free_prevention",
        "code_review",
        "secure_coding_practices"
      ],
      "code_differences": {
        "has_differences": true,
        "source_lines": 2,
        "target_lines": 2,
        "character_differences": 9178,
        "similarity_percentage": 3.1914893617021276
      },
      "vulnerability_location": {
        "vulnerability_present": true,
        "fix_applied": true,
        "code_changed": true,
        "estimated_lines_changed": 0
      }
    },
    {
      "cve_id": "CVE-2017-9438",
      "cwe_id": "CWE-674",
      "cwe_name": "Uncontrolled Recursion",
      "project": "VirusTotal",
      "severity": "critical",
      "weaponization_score": 7.5,
      "is_critical": true,
      "is_weaponizable": true,
      "is_high_priority_project": false,
      "vulnerable_code": "CWE-674 int yyparse ( void * yyscanner , HEX_LEX_ENVIRONMENT * lex_env ) { int yychar ; YY_INITIAL_VALUE ( static YYSTYPE yyval_default ; ) YYSTYPE yylval YY_INITIAL_VALUE ( = yyval_default ) ; int yynerrs ; int yystate ; int yyerrstatus ; yytype_int16 yyssa [ YYINITDEPTH ] ; yytype_int16 * yyss ; yytype_int16 * yyssp ; YYSTYPE yyvsa [ YYINITDEPTH ] ; YYSTYPE * yyvs ; YYSTYPE * yyvsp ; YYSIZE_T yystacksize ; int yyn ; int yyresult ; int yytoken = 0 ; YYSTYPE yyval ; # if YYERROR_VERBOSE char yymsgbuf [ 128 ] ; char * yymsg = yymsgbuf ; YYSIZE_T yymsg_alloc = sizeof yymsgbuf ; # endif # define YYPOPSTACK ( N ) ( yyvsp -= ( N ) , yyssp -= ( N ) ) int yylen = 0 ; yyssp = yyss = yyssa ; yyvsp = yyvs = yyvsa ; yystacksize = YYINITDEPTH ; YYDPRINTF ( ( stderr , \"Starting<S2SV_blank>parse\\\\n\" ) ) ; yystate = 0 ; yyerrstatus = 0 ; yynerrs = 0 ; yychar = YYEMPTY ; goto yysetstate ; yynewstate : yyssp ++ ; yysetstate : * yyssp = yystate ; if ( yyss + yystacksize - 1 <= yyssp ) { YYSIZE_T yysize = yyssp - yyss + 1 ; # ifdef yyoverflow { YYSTYPE * yyvs1 = yyvs ; yytype_int16 * yyss1 = yyss ; yyoverflow ( YY_ ( \"memory<S2SV_blank>exhausted\" ) , & yyss1 , yysize * sizeof ( * yyssp ) , & yyvs1 , yysize * sizeof ( * yyvsp ) , & yystacksize ) ; yyss = yyss1 ; yyvs = yyvs1 ; } # else # ifndef YYSTACK_RELOCATE goto yyexhaustedlab ; # else if ( YYMAXDEPTH <= yystacksize ) goto yyexhaustedlab ; yystacksize *= 2 ; if ( YYMAXDEPTH < yystacksize ) yystacksize = YYMAXDEPTH ; { yytype_int16 * yyss1 = yyss ; union yyalloc * yyptr = ( union yyalloc * ) YYSTACK_ALLOC ( YYSTACK_BYTES ( yystacksize ) ) ; if ( ! yyptr ) goto yyexhaustedlab ; YYSTACK_RELOCATE ( yyss_alloc , yyss ) ; YYSTACK_RELOCATE ( yyvs_alloc , yyvs ) ; # undef YYSTACK_RELOCATE if ( yyss1 != yyssa ) YYSTACK_FREE ( yyss1 ) ; } # endif # endif yyssp = yyss + yysize - 1 ; yyvsp = yyvs + yysize - 1 ; YYDPRINTF ( ( stderr , \"Stack<S2SV_blank>size<S2SV_blank>increased<S2SV_blank>to<S2SV_blank>%lu\\\\n\" , ( unsigned long int ) yystacksize ) ) ; if ( yyss + yystacksize - 1 <= yyssp ) YYABORT ; } YYDPRINTF ( ( stderr , \"Entering<S2SV_blank>state<S2SV_blank>%d\\\\n\" , yystate ) ) ; if ( yystate == YYFINAL ) YYACCEPT ; goto yybackup ; yybackup : yyn = yypact [ yystate ] ; if ( yypact_value_is_default ( yyn ) ) goto yydefault ; if ( yychar == YYEMPTY ) { YYDPRINTF ( ( stderr , \"Reading<S2SV_blank>a<S2SV_blank>token:<S2SV_blank>\" ) ) ; yychar = yylex ( & yylval , yyscanner , lex_env ) ; } if ( yychar <= YYEOF ) { yychar = yytoken = YYEOF ; YYDPRINTF ( ( stderr , \"Now<S2SV_blank>at<S2SV_blank>end<S2SV_blank>of<S2SV_blank>input.\\\\n\" ) ) ; } else { yytoken = YYTRANSLATE ( yychar ) ; YY_SYMBOL_PRINT ( \"Next<S2SV_blank>token<S2SV_blank>is\" , yytoken , & yylval , & yylloc ) ; } yyn += yytoken ; if ( yyn < 0 || YYLAST < yyn || yycheck [ yyn ] != yytoken ) goto yydefault ; yyn = yytable [ yyn ] ; if ( yyn <= 0 ) { if ( yytable_value_is_error ( yyn ) ) goto yyerrlab ; yyn = - yyn ; goto yyreduce ; } if ( yyerrstatus ) yyerrstatus -- ; YY_SYMBOL_PRINT ( \"Shifting\" , yytoken , & yylval , & yylloc ) ; yychar = YYEMPTY ; yystate = yyn ; YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN * ++ yyvsp = yylval ; YY_IGNORE_MAYBE_UNINITIALIZED_END goto yynewstate ; yydefault : yyn = yydefact [ yystate ] ; if ( yyn == 0 ) goto yyerrlab ; goto yyreduce ; yyreduce : yylen = yyr2 [ yyn ] ; yyval = yyvsp [ 1 - yylen ] ; YY_REDUCE_PRINT ( yyn ) ; switch ( yyn ) { case 2 : <S2SV_StartBug> # line 106 \"hex_grammar.y\" <S2SV_EndBug> { RE_AST * re_ast = yyget_extra ( yyscanner ) ; re_ast -> root_node = ( yyvsp [ - 1 ] . re_node ) ; } <S2SV_StartBug> # line 1330 \"hex_grammar.c\" <S2SV_EndBug> break ; case 3 : <S2SV_StartBug> # line 115 \"hex_grammar.y\" <S2SV_EndBug> { ( yyval . re_node ) = ( yyvsp [ 0 ] . re_node ) ; } <S2SV_StartBug> # line 1338 \"hex_grammar.c\" <S2SV_EndBug> break ; case 4 : <S2SV_StartBug> # line 119 \"hex_grammar.y\" <S2SV_EndBug> { ( yyval . re_node ) = yr_re_node_create ( RE_NODE_CONCAT , ( yyvsp [ - 1 ] . re_node ) , ( yyvsp [ 0 ] . re_node ) ) ; DESTROY_NODE_IF ( ( yyval . re_node ) == NULL , ( yyvsp [ - 1 ] . re_node ) ) ; DESTROY_NODE_IF ( ( yyval . re_node ) == NULL , ( yyvsp [ 0 ] . re_node ) ) ; ERROR_IF ( ( yyval . re_node ) == NULL , ERROR_INSUFFICIENT_MEMORY ) ; } <S2SV_StartBug> # line 1351 \"hex_grammar.c\" <S2SV_EndBug> break ; case 5 : <S2SV_StartBug> # line 128 \"hex_grammar.y\" <S2SV_EndBug> { RE_NODE * new_concat ; RE_NODE * leftmost_concat = NULL ; <S2SV_StartBug> RE_NODE * leftmost_node = ( yyvsp [ - 1 ] . re_node ) ; <S2SV_EndBug> ( yyval . re_node ) = NULL ; while ( leftmost_node -> type == RE_NODE_CONCAT ) { leftmost_concat = leftmost_node ; leftmost_node = leftmost_node -> left ; } new_concat = yr_re_node_create ( RE_NODE_CONCAT , ( yyvsp [ - 2 ] . re_node ) , leftmost_node ) ; if ( new_concat != NULL ) { if ( leftmost_concat != NULL ) { leftmost_concat -> left = new_concat ; ( yyval . re_node ) = yr_re_node_create ( RE_NODE_CONCAT , ( yyvsp [ - 1 ] . re_node ) , ( yyvsp [ 0 ] . re_node ) ) ; } else { ( yyval . re_node ) = yr_re_node_create ( RE_NODE_CONCAT , new_concat , ( yyvsp [ 0 ] . re_node ) ) ; } } DESTROY_NODE_IF ( ( yyval . re_node ) == NULL , ( yyvsp [ - 2 ] . re_node ) ) ; DESTROY_NODE_IF ( ( yyval . re_node ) == NULL , ( yyvsp [ - 1 ] . re_node ) ) ; DESTROY_NODE_IF ( ( yyval . re_node ) == NULL , ( yyvsp [ 0 ] . re_node ) ) ; ERROR_IF ( ( yyval . re_node ) == NULL , ERROR_INSUFFICIENT_MEMORY ) ; } <S2SV_StartBug> # line 1413 \"hex_grammar.c\" <S2SV_EndBug> break ; case 6 : <S2SV_StartBug> # line 190 \"hex_grammar.y\" <S2SV_EndBug> { ( yyval . re_node ) = ( yyvsp [ 0 ] . re_node ) ; } <S2SV_StartBug> # line 1421 \"hex_grammar.c\" <S2SV_EndBug> break ; case 7 : <S2SV_StartBug> # line 194 \"hex_grammar.y\" <S2SV_EndBug> { ( yyval . re_node ) = yr_re_node_create ( RE_NODE_CONCAT , ( yyvsp [ - 1 ] . re_node ) , ( yyvsp [ 0 ] . re_node ) ) ; DESTROY_NODE_IF ( ( yyval . re_node ) == NULL , ( yyvsp [ - 1 ] . re_node ) ) ; DESTROY_NODE_IF ( ( yyval . re_node ) == NULL , ( yyvsp [ 0 ] . re_node ) ) ; ERROR_IF ( ( yyval . re_node ) == NULL , ERROR_INSUFFICIENT_MEMORY ) ; } <S2SV_StartBug> # line 1434 \"hex_grammar.c\" <S2SV_EndBug> break ; case 8 : <S2SV_StartBug> # line 207 \"hex_grammar.y\" <S2SV_EndBug> { ( yyval . re_node ) = ( yyvsp [ 0 ] . re_node ) ; } <S2SV_StartBug> # line 1442 \"hex_grammar.c\" <S2SV_EndBug> break ; case 9 : <S2SV_StartBug> # line 211 \"hex_grammar.y\" <S2SV_EndBug> { ( yyval . re_node ) = ( yyvsp [ 0 ] . re_node ) ; ( yyval . re_node ) -> greedy = FALSE ; } <S2SV_StartBug> # line 1451 \"hex_grammar.c\" <S2SV_EndBug> break ; case 10 : <S2SV_StartBug> # line 220 \"hex_grammar.y\" <S2SV_EndBug> { lex_env -> token_count ++ ; if ( lex_env -> token_count > MAX_HEX_STRING_TOKENS ) { yr_re_node_destroy ( ( yyvsp [ 0 ] . re_node ) ) ; yyerror ( yyscanner , lex_env , \"string<S2SV_blank>too<S2SV_blank>long\" ) ; YYABORT ; } ( yyval . re_node ) = ( yyvsp [ 0 ] . re_node ) ; } <S2SV_StartBug> # line 1468 \"hex_grammar.c\" <S2SV_EndBug> break ; case 11 : <S2SV_StartBug> # line 233 \"hex_grammar.y\" <S2SV_EndBug> { lex_env -> inside_or ++ ; } <S2SV_StartBug> # line 1476 \"hex_grammar.c\" <S2SV_EndBug> break ; case 12 : <S2SV_StartBug> # line 237 \"hex_grammar.y\" <S2SV_EndBug> { ( yyval . re_node ) = ( yyvsp [ - 1 ] . re_node ) ; lex_env -> inside_or -- ; } <S2SV_StartBug> # line 1485 \"hex_grammar.c\" <S2SV_EndBug> break ; case 13 : <S2SV_StartBug> # line 246 \"hex_grammar.y\" <S2SV_EndBug> { if ( ( yyvsp [ - 1 ] . integer ) <= 0 ) { yyerror ( yyscanner , lex_env , \"invalid<S2SV_blank>jump<S2SV_blank>length\" ) ; YYABORT ; } if ( lex_env -> inside_or && ( yyvsp [ - 1 ] . integer ) > STRING_CHAINING_THRESHOLD ) { yyerror ( yyscanner , lex_env , \"jumps<S2SV_blank>over<S2SV_blank>\" STR ( STRING_CHAINING_THRESHOLD ) \"<S2SV_blank>now<S2SV_blank>allowed<S2SV_blank>inside<S2SV_blank>alternation<S2SV_blank>(|)\" ) ; YYABORT ; } ( yyval . re_node ) = yr_re_node_create ( RE_NODE_RANGE_ANY , NULL , NULL ) ; ERROR_IF ( ( yyval . re_node ) == NULL , ERROR_INSUFFICIENT_MEMORY ) ; ( yyval . re_node ) -> start = ( int ) ( yyvsp [ - 1 ] . integer ) ; ( yyval . re_node ) -> end = ( int ) ( yyvsp [ - 1 ] . integer ) ; } <S2SV_StartBug> # line 1512 \"hex_grammar.c\" <S2SV_EndBug> break ; case 14 : <S2SV_StartBug> # line 269 \"hex_grammar.y\" <S2SV_EndBug> { if ( lex_env -> inside_or && ( ( yyvsp [ - 3 ] . integer ) > STRING_CHAINING_THRESHOLD || ( yyvsp [ - 1 ] . integer ) > STRING_CHAINING_THRESHOLD ) ) { yyerror ( yyscanner , lex_env , \"jumps<S2SV_blank>over<S2SV_blank>\" STR ( STRING_CHAINING_THRESHOLD ) \"<S2SV_blank>now<S2SV_blank>allowed<S2SV_blank>inside<S2SV_blank>alternation<S2SV_blank>(|)\" ) ; YYABORT ; } if ( ( yyvsp [ - 3 ] . integer ) < 0 || ( yyvsp [ - 1 ] . integer ) < 0 ) { yyerror ( yyscanner , lex_env , \"invalid<S2SV_blank>negative<S2SV_blank>jump<S2SV_blank>length\" ) ; YYABORT ; } if ( ( yyvsp [ - 3 ] . integer ) > ( yyvsp [ - 1 ] . integer ) ) { yyerror ( yyscanner , lex_env , \"invalid<S2SV_blank>jump<S2SV_blank>range\" ) ; YYABORT ; } ( yyval . re_node ) = yr_re_node_create ( RE_NODE_RANGE_ANY , NULL , NULL ) ; ERROR_IF ( ( yyval . re_node ) == NULL , ERROR_INSUFFICIENT_MEMORY ) ; ( yyval . re_node ) -> start = ( int ) ( yyvsp [ - 3 ] . integer ) ; ( yyval . re_node ) -> end = ( int ) ( yyvsp [ - 1 ] . integer ) ; } <S2SV_StartBug> # line 1548 \"hex_grammar.c\" <S2SV_EndBug> break ; case 15 : <S2SV_StartBug> # line 301 \"hex_grammar.y\" <S2SV_EndBug> { if ( lex_env -> inside_or ) { yyerror ( yyscanner , lex_env , \"unbounded<S2SV_blank>jumps<S2SV_blank>not<S2SV_blank>allowed<S2SV_blank>inside<S2SV_blank>alternation<S2SV_blank>(|)\" ) ; YYABORT ; } if ( ( yyvsp [ - 2 ] . integer ) < 0 ) { yyerror ( yyscanner , lex_env , \"invalid<S2SV_blank>negative<S2SV_blank>jump<S2SV_blank>length\" ) ; YYABORT ; } ( yyval . re_node ) = yr_re_node_create ( RE_NODE_RANGE_ANY , NULL , NULL ) ; ERROR_IF ( ( yyval . re_node ) == NULL , ERROR_INSUFFICIENT_MEMORY ) ; ( yyval . re_node ) -> start = ( int ) ( yyvsp [ - 2 ] . integer ) ; ( yyval . re_node ) -> end = INT_MAX ; } <S2SV_StartBug> # line 1574 \"hex_grammar.c\" <S2SV_EndBug> break ; case 16 : <S2SV_StartBug> # line 323 \"hex_grammar.y\" <S2SV_EndBug> { if ( lex_env -> inside_or ) { yyerror ( yyscanner , lex_env , \"unbounded<S2SV_blank>jumps<S2SV_blank>not<S2SV_blank>allowed<S2SV_blank>inside<S2SV_blank>alternation<S2SV_blank>(|)\" ) ; YYABORT ; } ( yyval . re_node ) = yr_re_node_create ( RE_NODE_RANGE_ANY , NULL , NULL ) ; ERROR_IF ( ( yyval . re_node ) == NULL , ERROR_INSUFFICIENT_MEMORY ) ; ( yyval . re_node ) -> start = 0 ; ( yyval . re_node ) -> end = INT_MAX ; } <S2SV_StartBug> # line 1594 \"hex_grammar.c\" <S2SV_EndBug> break ; case 17 : <S2SV_StartBug> # line 343 \"hex_grammar.y\" <S2SV_EndBug> { ( yyval . re_node ) = ( yyvsp [ 0 ] . re_node ) ; } <S2SV_StartBug> # line 1602 \"hex_grammar.c\" <S2SV_EndBug> break ; case 18 : <S2SV_StartBug> # line 347 \"hex_grammar.y\" <S2SV_EndBug> { mark_as_not_fast_regexp ( ) ; <S2SV_StartBug> ( yyval . re_node ) = yr_re_node_create ( RE_NODE_ALT , ( yyvsp [ - 2 ] . re_node ) , ( yyvsp [ 0 ] . re_node ) ) ; <S2SV_EndBug> DESTROY_NODE_IF ( ( yyval . re_node ) == NULL , ( yyvsp [ - 2 ] . re_node ) ) ; DESTROY_NODE_IF ( ( yyval . re_node ) == NULL , ( yyvsp [ 0 ] . re_node ) ) ; ERROR_IF ( ( yyval . re_node ) == NULL , ERROR_INSUFFICIENT_MEMORY ) ; } <S2SV_StartBug> # line 1617 \"hex_grammar.c\" <S2SV_EndBug> break ; case 19 : <S2SV_StartBug> # line 361 \"hex_grammar.y\" <S2SV_EndBug> { ( yyval . re_node ) = yr_re_node_create ( RE_NODE_LITERAL , NULL , NULL ) ; ERROR_IF ( ( yyval . re_node ) == NULL , ERROR_INSUFFICIENT_MEMORY ) ; ( yyval . re_node ) -> value = ( int ) ( yyvsp [ 0 ] . integer ) ; } <S2SV_StartBug> # line 1629 \"hex_grammar.c\" <S2SV_EndBug> break ; case 20 : <S2SV_StartBug> # line 369 \"hex_grammar.y\" <S2SV_EndBug> { uint8_t mask = ( uint8_t ) ( ( yyvsp [ 0 ] . integer ) >> 8 ) ; if ( mask == 0x00 ) { ( yyval . re_node ) = yr_re_node_create ( RE_NODE_ANY , NULL , NULL ) ; ERROR_IF ( ( yyval . re_node ) == NULL , ERROR_INSUFFICIENT_MEMORY ) ; } else { ( yyval . re_node ) = yr_re_node_create ( RE_NODE_MASKED_LITERAL , NULL , NULL ) ; ERROR_IF ( ( yyval . re_node ) == NULL , ERROR_INSUFFICIENT_MEMORY ) ; ( yyval . re_node ) -> value = ( yyvsp [ 0 ] . integer ) & 0xFF ; ( yyval . re_node ) -> mask = mask ; } } <S2SV_StartBug> # line 1653 \"hex_grammar.c\" <S2SV_EndBug> break ; <S2SV_StartBug> # line 1657 \"hex_grammar.c\" <S2SV_EndBug> default : break ; } YY_SYMBOL_PRINT ( \"-><S2SV_blank>$$<S2SV_blank>=\" , yyr1 [ yyn ] , & yyval , & yyloc ) ; YYPOPSTACK ( yylen ) ; yylen = 0 ; YY_STACK_PRINT ( yyss , yyssp ) ; * ++ yyvsp = yyval ; yyn = yyr1 [ yyn ] ; yystate = yypgoto [ yyn - YYNTOKENS ] + * yyssp ; if ( 0 <= yystate && yystate <= YYLAST && yycheck [ yystate ] == * yyssp ) yystate = yytable [ yystate ] ; else yystate = yydefgoto [ yyn - YYNTOKENS ] ; goto yynewstate ; yyerrlab : yytoken = yychar == YYEMPTY ? YYEMPTY : YYTRANSLATE ( yychar ) ; if ( ! yyerrstatus ) { ++ yynerrs ; # if ! YYERROR_VERBOSE yyerror ( yyscanner , lex_env , YY_ ( \"syntax<S2SV_blank>error\" ) ) ; # else # define YYSYNTAX_ERROR yysyntax_error ( & yymsg_alloc , & yymsg , yyssp , yytoken ) { char const * yymsgp = YY_ ( \"syntax<S2SV_blank>error\" ) ; int yysyntax_error_status ; yysyntax_error_status = YYSYNTAX_ERROR ; if ( yysyntax_error_status == 0 ) yymsgp = yymsg ; else if ( yysyntax_error_status == 1 ) { if ( yymsg != yymsgbuf ) YYSTACK_FREE ( yymsg ) ; yymsg = ( char * ) YYSTACK_ALLOC ( yymsg_alloc ) ; if ( ! yymsg ) { yymsg = yymsgbuf ; yymsg_alloc = sizeof yymsgbuf ; yysyntax_error_status = 2 ; } else { yysyntax_error_status = YYSYNTAX_ERROR ; yymsgp = yymsg ; } } yyerror ( yyscanner , lex_env , yymsgp ) ; if ( yysyntax_error_status == 2 ) goto yyexhaustedlab ; } # undef YYSYNTAX_ERROR # endif } if ( yyerrstatus == 3 ) { if ( yychar <= YYEOF ) { if ( yychar == YYEOF ) YYABORT ; } else { yydestruct ( \"Error:<S2SV_blank>discarding\" , yytoken , & yylval , yyscanner , lex_env ) ; yychar = YYEMPTY ; } } goto yyerrlab1 ; yyerrorlab : if ( 0 ) goto yyerrorlab ; YYPOPSTACK ( yylen ) ; yylen = 0 ; YY_STACK_PRINT ( yyss , yyssp ) ; yystate = * yyssp ; goto yyerrlab1 ; yyerrlab1 : yyerrstatus = 3 ; for ( ; ; ) { yyn = yypact [ yystate ] ; if ( ! yypact_value_is_default ( yyn ) ) { yyn += YYTERROR ; if ( 0 <= yyn && yyn <= YYLAST && yycheck [ yyn ] == YYTERROR ) { yyn = yytable [ yyn ] ; if ( 0 < yyn ) break ; } } if ( yyssp == yyss ) YYABORT ; yydestruct ( \"Error:<S2SV_blank>popping\" , yystos [ yystate ] , yyvsp , yyscanner , lex_env ) ; YYPOPSTACK ( 1 ) ; yystate = * yyssp ; YY_STACK_PRINT ( yyss , yyssp ) ; } YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN * ++ yyvsp = yylval ; YY_IGNORE_MAYBE_UNINITIALIZED_END YY_SYMBOL_PRINT ( \"Shifting\" , yystos [ yyn ] , yyvsp , yylsp ) ; yystate = yyn ; goto yynewstate ; yyacceptlab : yyresult = 0 ; goto yyreturn ; yyabortlab : yyresult = 1 ; goto yyreturn ; # if ! defined yyoverflow || YYERROR_VERBOSE yyexhaustedlab : yyerror ( yyscanner , lex_env , YY_ ( \"memory<S2SV_blank>exhausted\" ) ) ; yyresult = 2 ; # endif yyreturn : if ( yychar != YYEMPTY ) { yytoken = YYTRANSLATE ( yychar ) ; yydestruct ( \"Cleanup:<S2SV_blank>discarding<S2SV_blank>lookahead\" , yytoken , & yylval , yyscanner , lex_env ) ; } YYPOPSTACK ( yylen ) ; YY_STACK_PRINT ( yyss , yyssp ) ; while ( yyssp != yyss ) { yydestruct ( \"Cleanup:<S2SV_blank>popping\" , yystos [ * yyssp ] , yyvsp , yyscanner , lex_env ) ; YYPOPSTACK ( 1 ) ; } # ifndef yyoverflow if ( yyss != yyssa ) YYSTACK_FREE ( yyss ) ; # endif # if YYERROR_VERBOSE if ( yymsg != yymsgbuf ) YYSTACK_FREE ( yymsg ) ; # endif return yyresult ; }\n",
      "fixed_code": "<S2SV_ModStart> : # line 113 <S2SV_ModEnd> \"hex_grammar.y\" { RE_AST <S2SV_ModStart> } # line 1337 <S2SV_ModEnd> \"hex_grammar.c\" break ; <S2SV_ModStart> : # line 122 <S2SV_ModEnd> \"hex_grammar.y\" { ( <S2SV_ModStart> } # line 1345 <S2SV_ModEnd> \"hex_grammar.c\" break ; <S2SV_ModStart> : # line 126 \"hex_grammar.y\" { incr_ast_levels ( ) ; <S2SV_ModEnd> ( yyval . <S2SV_ModStart> } # line 1360 <S2SV_ModEnd> \"hex_grammar.c\" break ; <S2SV_ModStart> : # line 137 <S2SV_ModEnd> \"hex_grammar.y\" { RE_NODE <S2SV_ModStart> ] . re_node ) ; incr_ast_levels ( <S2SV_ModStart> } # line 1424 <S2SV_ModEnd> \"hex_grammar.c\" break ; <S2SV_ModStart> : # line 201 <S2SV_ModEnd> \"hex_grammar.y\" { ( <S2SV_ModStart> } # line 1432 <S2SV_ModEnd> \"hex_grammar.c\" break ; <S2SV_ModStart> : # line 205 \"hex_grammar.y\" { incr_ast_levels ( ) ; <S2SV_ModEnd> ( yyval . <S2SV_ModStart> } # line 1447 <S2SV_ModEnd> \"hex_grammar.c\" break ; <S2SV_ModStart> : # line 220 <S2SV_ModEnd> \"hex_grammar.y\" { ( <S2SV_ModStart> } # line 1455 <S2SV_ModEnd> \"hex_grammar.c\" break ; <S2SV_ModStart> : # line 224 <S2SV_ModEnd> \"hex_grammar.y\" { ( <S2SV_ModStart> } # line 1464 <S2SV_ModEnd> \"hex_grammar.c\" break ; <S2SV_ModStart> : # line 233 <S2SV_ModEnd> \"hex_grammar.y\" { lex_env <S2SV_ModStart> } # line 1481 <S2SV_ModEnd> \"hex_grammar.c\" break ; <S2SV_ModStart> : # line 246 <S2SV_ModEnd> \"hex_grammar.y\" { lex_env <S2SV_ModStart> } # line 1489 <S2SV_ModEnd> \"hex_grammar.c\" break ; <S2SV_ModStart> : # line 250 <S2SV_ModEnd> \"hex_grammar.y\" { ( <S2SV_ModStart> } # line 1498 <S2SV_ModEnd> \"hex_grammar.c\" break ; <S2SV_ModStart> : # line 259 <S2SV_ModEnd> \"hex_grammar.y\" { if <S2SV_ModStart> } # line 1525 <S2SV_ModEnd> \"hex_grammar.c\" break ; <S2SV_ModStart> : # line 282 <S2SV_ModEnd> \"hex_grammar.y\" { if <S2SV_ModStart> } # line 1561 <S2SV_ModEnd> \"hex_grammar.c\" break ; <S2SV_ModStart> : # line 314 <S2SV_ModEnd> \"hex_grammar.y\" { if <S2SV_ModStart> } # line 1587 <S2SV_ModEnd> \"hex_grammar.c\" break ; <S2SV_ModStart> : # line 336 <S2SV_ModEnd> \"hex_grammar.y\" { if <S2SV_ModStart> } # line 1607 <S2SV_ModEnd> \"hex_grammar.c\" break ; <S2SV_ModStart> : # line 356 <S2SV_ModEnd> \"hex_grammar.y\" { ( <S2SV_ModStart> } # line 1615 <S2SV_ModEnd> \"hex_grammar.c\" break ; <S2SV_ModStart> : # line 360 <S2SV_ModEnd> \"hex_grammar.y\" { mark_as_not_fast_regexp <S2SV_ModStart> ( ) ; incr_ast_levels ( ) ; <S2SV_ModStart> } # line 1631 <S2SV_ModEnd> \"hex_grammar.c\" break ; <S2SV_ModStart> : # line 375 <S2SV_ModEnd> \"hex_grammar.y\" { ( <S2SV_ModStart> } # line 1643 <S2SV_ModEnd> \"hex_grammar.c\" break ; <S2SV_ModStart> : # line 383 <S2SV_ModEnd> \"hex_grammar.y\" { uint8_t <S2SV_ModStart> } # line 1667 <S2SV_ModEnd> \"hex_grammar.c\" break ; <S2SV_ModStart> ; # line 1671 <S2SV_ModEnd> \"hex_grammar.c\" default :\n",
      "source_code_length": 15605,
      "target_code_length": 2768,
      "vulnerability_patterns": {
        "use_after_free": 5,
        "integer_overflow": 14,
        "null_pointer": 30,
        "total": 49
      },
      "total_patterns": 49,
      "original_address": "https://github.com/VirusTotal/yara/commit/10e8bd3071677dd1fa76beeef4bc2fc427cea5e7",
      "discovery_time": "2017-06-05T17:29Z",
      "project_commit_id": "VirusTotal@yara/10e8bd3071677dd1fa76beeef4bc2fc427cea5e7",
      "extraction_time": "2025-08-31T15:41:49.188154",
      "label": 1,
      "vulnerability_type": "uncontrolled_recursion",
      "difficulty_level": "advanced",
      "risk_factors": [
        "use_after_free"
      ],
      "attack_vectors": [
        "fuzzing",
        "code_analysis",
        "reverse_engineering"
      ],
      "mitigation_strategies": [
        "dynamic_analysis",
        "static_analysis",
        "fuzzing",
        "code_review",
        "secure_coding_practices"
      ],
      "code_differences": {
        "has_differences": true,
        "source_lines": 2,
        "target_lines": 2,
        "character_differences": 12837,
        "similarity_percentage": 7.836990595611286
      },
      "vulnerability_location": {
        "vulnerability_present": true,
        "fix_applied": true,
        "code_changed": true,
        "estimated_lines_changed": 0
      }
    },
    {
      "cve_id": "CVE-2020-14397",
      "cwe_id": "CWE-476",
      "cwe_name": "NULL Pointer Dereference",
      "project": "LibVNC",
      "severity": "critical",
      "weaponization_score": 7.5,
      "is_critical": true,
      "is_weaponizable": true,
      "is_high_priority_project": false,
      "vulnerable_code": "CWE-476 static void <S2SV_StartBug> sraSpanInsertBefore ( sraSpan * newspan , sraSpan * before ) { <S2SV_EndBug> newspan -> _next = before ; newspan -> _prev = before -> _prev ; before -> _prev -> _next = newspan ; before -> _prev = newspan ; <S2SV_StartBug> } <S2SV_EndBug>\n",
      "fixed_code": "<S2SV_ModStart> , sraSpan * before ) { if ( newspan && <S2SV_ModStart> newspan ; } }\n",
      "source_code_length": 275,
      "target_code_length": 85,
      "vulnerability_patterns": {
        "use_after_free": 5,
        "null_pointer": 6,
        "total": 11
      },
      "total_patterns": 11,
      "original_address": "https://github.com/LibVNC/libvncserver/commit/38e98ee61d74f5f5ab4aa4c77146faad1962d6d0",
      "discovery_time": "2020-06-17T16:15Z",
      "project_commit_id": "LibVNC@libvncserver/38e98ee61d74f5f5ab4aa4c77146faad1962d6d0",
      "extraction_time": "2025-08-31T15:41:49.188317",
      "label": 1,
      "vulnerability_type": "null_pointer_dereference",
      "difficulty_level": "advanced",
      "risk_factors": [
        "system_crash",
        "denial_of_service",
        "memory_corruption",
        "use_after_free"
      ],
      "attack_vectors": [
        "memory_manipulation",
        "null_pointer",
        "code_analysis",
        "reverse_engineering",
        "use_after_free",
        "fuzzing"
      ],
      "mitigation_strategies": [
        "null_pointer_checks",
        "fuzzing",
        "dynamic_analysis",
        "memory_management",
        "static_analysis",
        "use_after_free_prevention",
        "code_review",
        "secure_coding_practices"
      ],
      "code_differences": {
        "has_differences": true,
        "source_lines": 2,
        "target_lines": 2,
        "character_differences": 190,
        "similarity_percentage": 43.47826086956522
      },
      "vulnerability_location": {
        "vulnerability_present": true,
        "fix_applied": true,
        "code_changed": true,
        "estimated_lines_changed": 0
      }
    },
    {
      "cve_id": "CVE-2016-9436",
      "cwe_id": "CWE-20",
      "cwe_name": "Improper Input Validation",
      "project": "tats",
      "severity": "critical",
      "weaponization_score": 7.5,
      "is_critical": true,
      "is_weaponizable": true,
      "is_high_priority_project": false,
      "vulnerable_code": "CWE-20 int HTMLtagproc1 ( struct parsed_tag * tag , struct html_feed_environ * h_env ) { char * p , * q , * r ; int i , w , x , y , z , count , width ; struct readbuffer * obuf = h_env -> obuf ; struct environment * envs = h_env -> envs ; Str tmp ; int hseq ; int cmd ; # ifdef ID_EXT char * id = NULL ; # endif cmd = tag -> tagid ; if ( obuf -> flag & RB_PRE ) { switch ( cmd ) { case HTML_NOBR : case HTML_N_NOBR : case HTML_PRE_INT : case HTML_N_PRE_INT : return 1 ; } } switch ( cmd ) { case HTML_B : obuf -> in_bold ++ ; if ( obuf -> in_bold > 1 ) return 1 ; return 0 ; case HTML_N_B : if ( obuf -> in_bold == 1 && close_effect0 ( obuf , HTML_B ) ) obuf -> in_bold = 0 ; if ( obuf -> in_bold > 0 ) { obuf -> in_bold -- ; if ( obuf -> in_bold == 0 ) return 0 ; } return 1 ; case HTML_I : obuf -> in_italic ++ ; if ( obuf -> in_italic > 1 ) return 1 ; return 0 ; case HTML_N_I : if ( obuf -> in_italic == 1 && close_effect0 ( obuf , HTML_I ) ) obuf -> in_italic = 0 ; if ( obuf -> in_italic > 0 ) { obuf -> in_italic -- ; if ( obuf -> in_italic == 0 ) return 0 ; } return 1 ; case HTML_U : obuf -> in_under ++ ; if ( obuf -> in_under > 1 ) return 1 ; return 0 ; case HTML_N_U : if ( obuf -> in_under == 1 && close_effect0 ( obuf , HTML_U ) ) obuf -> in_under = 0 ; if ( obuf -> in_under > 0 ) { obuf -> in_under -- ; if ( obuf -> in_under == 0 ) return 0 ; } return 1 ; case HTML_EM : HTMLlineproc1 ( \"<i>\" , h_env ) ; return 1 ; case HTML_N_EM : HTMLlineproc1 ( \"</i>\" , h_env ) ; return 1 ; case HTML_STRONG : HTMLlineproc1 ( \"<b>\" , h_env ) ; return 1 ; case HTML_N_STRONG : HTMLlineproc1 ( \"</b>\" , h_env ) ; return 1 ; case HTML_Q : HTMLlineproc1 ( \"`\" , h_env ) ; return 1 ; case HTML_N_Q : HTMLlineproc1 ( \"\\'\" , h_env ) ; return 1 ; case HTML_P : case HTML_N_P : CLOSE_A ; if ( ! ( obuf -> flag & RB_IGNORE_P ) ) { flushline ( h_env , obuf , envs [ h_env -> envc ] . indent , 1 , h_env -> limit ) ; do_blankline ( h_env , obuf , envs [ h_env -> envc ] . indent , 0 , h_env -> limit ) ; } obuf -> flag |= RB_IGNORE_P ; if ( cmd == HTML_P ) { set_alignment ( obuf , tag ) ; obuf -> flag |= RB_P ; } return 1 ; case HTML_BR : flushline ( h_env , obuf , envs [ h_env -> envc ] . indent , 1 , h_env -> limit ) ; h_env -> blank_lines = 0 ; return 1 ; case HTML_H : if ( ! ( obuf -> flag & ( RB_PREMODE | RB_IGNORE_P ) ) ) { flushline ( h_env , obuf , envs [ h_env -> envc ] . indent , 0 , h_env -> limit ) ; do_blankline ( h_env , obuf , envs [ h_env -> envc ] . indent , 0 , h_env -> limit ) ; } HTMLlineproc1 ( \"<b>\" , h_env ) ; set_alignment ( obuf , tag ) ; return 1 ; case HTML_N_H : HTMLlineproc1 ( \"</b>\" , h_env ) ; if ( ! ( obuf -> flag & RB_PREMODE ) ) { flushline ( h_env , obuf , envs [ h_env -> envc ] . indent , 0 , h_env -> limit ) ; } do_blankline ( h_env , obuf , envs [ h_env -> envc ] . indent , 0 , h_env -> limit ) ; RB_RESTORE_FLAG ( obuf ) ; close_anchor ( h_env , obuf ) ; obuf -> flag |= RB_IGNORE_P ; return 1 ; case HTML_UL : case HTML_OL : case HTML_BLQ : CLOSE_A ; if ( ! ( obuf -> flag & RB_IGNORE_P ) ) { flushline ( h_env , obuf , envs [ h_env -> envc ] . indent , 0 , h_env -> limit ) ; if ( ! ( obuf -> flag & RB_PREMODE ) && ( h_env -> envc == 0 || cmd == HTML_BLQ ) ) do_blankline ( h_env , obuf , envs [ h_env -> envc ] . indent , 0 , h_env -> limit ) ; } PUSH_ENV ( cmd ) ; if ( cmd == HTML_UL || cmd == HTML_OL ) { if ( parsedtag_get_value ( tag , ATTR_START , & count ) ) { envs [ h_env -> envc ] . count = count - 1 ; } } if ( cmd == HTML_OL ) { envs [ h_env -> envc ] . type = '1' ; if ( parsedtag_get_value ( tag , ATTR_TYPE , & p ) ) { envs [ h_env -> envc ] . type = ( int ) * p ; } } if ( cmd == HTML_UL ) envs [ h_env -> envc ] . type = ul_type ( tag , 0 ) ; flushline ( h_env , obuf , envs [ h_env -> envc ] . indent , 0 , h_env -> limit ) ; return 1 ; case HTML_N_UL : case HTML_N_OL : case HTML_N_DL : case HTML_N_BLQ : CLOSE_DT ; CLOSE_A ; if ( h_env -> envc > 0 ) { flushline ( h_env , obuf , envs [ h_env -> envc - 1 ] . indent , 0 , h_env -> limit ) ; POP_ENV ; if ( ! ( obuf -> flag & RB_PREMODE ) && ( h_env -> envc == 0 || cmd == HTML_N_DL || cmd == HTML_N_BLQ ) ) { do_blankline ( h_env , obuf , envs [ h_env -> envc ] . indent , INDENT_INCR , h_env -> limit ) ; obuf -> flag |= RB_IGNORE_P ; } } close_anchor ( h_env , obuf ) ; return 1 ; case HTML_DL : CLOSE_A ; if ( ! ( obuf -> flag & RB_IGNORE_P ) ) { flushline ( h_env , obuf , envs [ h_env -> envc ] . indent , 0 , h_env -> limit ) ; if ( ! ( obuf -> flag & RB_PREMODE ) ) do_blankline ( h_env , obuf , envs [ h_env -> envc ] . indent , 0 , h_env -> limit ) ; } PUSH_ENV ( cmd ) ; if ( parsedtag_exists ( tag , ATTR_COMPACT ) ) envs [ h_env -> envc ] . env = HTML_DL_COMPACT ; obuf -> flag |= RB_IGNORE_P ; return 1 ; case HTML_LI : CLOSE_A ; CLOSE_DT ; if ( h_env -> envc > 0 ) { Str num ; flushline ( h_env , obuf , envs [ h_env -> envc - 1 ] . indent , 0 , h_env -> limit ) ; envs [ h_env -> envc ] . count ++ ; if ( parsedtag_get_value ( tag , ATTR_VALUE , & p ) ) { count = atoi ( p ) ; if ( count > 0 ) envs [ h_env -> envc ] . count = count ; else envs [ h_env -> envc ] . count = 0 ; } switch ( envs [ h_env -> envc ] . env ) { case HTML_UL : envs [ h_env -> envc ] . type = ul_type ( tag , envs [ h_env -> envc ] . type ) ; for ( i = 0 ; i < INDENT_INCR - 3 ; i ++ ) push_charp ( obuf , 1 , NBSP , PC_ASCII ) ; tmp = Strnew ( ) ; switch ( envs [ h_env -> envc ] . type ) { case 'd' : push_symbol ( tmp , UL_SYMBOL_DISC , symbol_width , 1 ) ; break ; case 'c' : push_symbol ( tmp , UL_SYMBOL_CIRCLE , symbol_width , 1 ) ; break ; case 's' : push_symbol ( tmp , UL_SYMBOL_SQUARE , symbol_width , 1 ) ; break ; default : push_symbol ( tmp , UL_SYMBOL ( ( h_env -> envc_real - 1 ) % MAX_UL_LEVEL ) , symbol_width , 1 ) ; break ; } if ( symbol_width == 1 ) push_charp ( obuf , 1 , NBSP , PC_ASCII ) ; push_str ( obuf , symbol_width , tmp , PC_ASCII ) ; push_charp ( obuf , 1 , NBSP , PC_ASCII ) ; set_space_to_prevchar ( obuf -> prevchar ) ; break ; case HTML_OL : if ( parsedtag_get_value ( tag , ATTR_TYPE , & p ) ) envs [ h_env -> envc ] . type = ( int ) * p ; switch ( ( envs [ h_env -> envc ] . count > 0 ) ? envs [ h_env -> envc ] . type : '1' ) { case 'i' : num = romanNumeral ( envs [ h_env -> envc ] . count ) ; break ; case 'I' : num = romanNumeral ( envs [ h_env -> envc ] . count ) ; Strupper ( num ) ; break ; case 'a' : num = romanAlphabet ( envs [ h_env -> envc ] . count ) ; break ; case 'A' : num = romanAlphabet ( envs [ h_env -> envc ] . count ) ; Strupper ( num ) ; break ; default : num = Sprintf ( \"%d\" , envs [ h_env -> envc ] . count ) ; break ; } if ( INDENT_INCR >= 4 ) Strcat_charp ( num , \".<S2SV_blank>\" ) ; else Strcat_char ( num , '.' ) ; push_spaces ( obuf , 1 , INDENT_INCR - num -> length ) ; push_str ( obuf , num -> length , num , PC_ASCII ) ; if ( INDENT_INCR >= 4 ) set_space_to_prevchar ( obuf -> prevchar ) ; break ; default : push_spaces ( obuf , 1 , INDENT_INCR ) ; break ; } } else { flushline ( h_env , obuf , 0 , 0 , h_env -> limit ) ; } obuf -> flag |= RB_IGNORE_P ; return 1 ; case HTML_DT : CLOSE_A ; if ( h_env -> envc == 0 || ( h_env -> envc_real < h_env -> nenv && envs [ h_env -> envc ] . env != HTML_DL && envs [ h_env -> envc ] . env != HTML_DL_COMPACT ) ) { PUSH_ENV ( HTML_DL ) ; } if ( h_env -> envc > 0 ) { flushline ( h_env , obuf , envs [ h_env -> envc - 1 ] . indent , 0 , h_env -> limit ) ; } if ( ! ( obuf -> flag & RB_IN_DT ) ) { HTMLlineproc1 ( \"<b>\" , h_env ) ; obuf -> flag |= RB_IN_DT ; } obuf -> flag |= RB_IGNORE_P ; return 1 ; case HTML_DD : CLOSE_A ; CLOSE_DT ; <S2SV_StartBug> if ( envs [ h_env -> envc ] . env == HTML_DL_COMPACT ) { <S2SV_EndBug> if ( obuf -> pos > envs [ h_env -> envc ] . indent ) flushline ( h_env , obuf , envs [ h_env -> envc ] . indent , 0 , h_env -> limit ) ; else push_spaces ( obuf , 1 , envs [ h_env -> envc ] . indent - obuf -> pos ) ; } else flushline ( h_env , obuf , envs [ h_env -> envc ] . indent , 0 , h_env -> limit ) ; return 1 ; case HTML_TITLE : close_anchor ( h_env , obuf ) ; process_title ( tag ) ; obuf -> flag |= RB_TITLE ; obuf -> end_tag = HTML_N_TITLE ; return 1 ; case HTML_N_TITLE : if ( ! ( obuf -> flag & RB_TITLE ) ) return 1 ; obuf -> flag &= ~ RB_TITLE ; obuf -> end_tag = 0 ; tmp = process_n_title ( tag ) ; if ( tmp ) HTMLlineproc1 ( tmp -> ptr , h_env ) ; return 1 ; case HTML_TITLE_ALT : if ( parsedtag_get_value ( tag , ATTR_TITLE , & p ) ) h_env -> title = html_unquote ( p ) ; return 0 ; case HTML_FRAMESET : PUSH_ENV ( cmd ) ; push_charp ( obuf , 9 , \"--FRAME--\" , PC_ASCII ) ; flushline ( h_env , obuf , envs [ h_env -> envc ] . indent , 0 , h_env -> limit ) ; return 0 ; case HTML_N_FRAMESET : if ( h_env -> envc > 0 ) { POP_ENV ; flushline ( h_env , obuf , envs [ h_env -> envc ] . indent , 0 , h_env -> limit ) ; } return 0 ; case HTML_NOFRAMES : CLOSE_A ; flushline ( h_env , obuf , envs [ h_env -> envc ] . indent , 0 , h_env -> limit ) ; obuf -> flag |= ( RB_NOFRAMES | RB_IGNORE_P ) ; return 1 ; case HTML_N_NOFRAMES : CLOSE_A ; flushline ( h_env , obuf , envs [ h_env -> envc ] . indent , 0 , h_env -> limit ) ; obuf -> flag &= ~ RB_NOFRAMES ; return 1 ; case HTML_FRAME : q = r = NULL ; parsedtag_get_value ( tag , ATTR_SRC , & q ) ; parsedtag_get_value ( tag , ATTR_NAME , & r ) ; if ( q ) { q = html_quote ( q ) ; push_tag ( obuf , Sprintf ( \"<a<S2SV_blank>hseq=\\\\\"%d\\\\\"<S2SV_blank>href=\\\\\"%s\\\\\">\" , cur_hseq ++ , q ) -> ptr , HTML_A ) ; if ( r ) q = html_quote ( r ) ; push_charp ( obuf , get_strwidth ( q ) , q , PC_ASCII ) ; push_tag ( obuf , \"</a>\" , HTML_N_A ) ; } flushline ( h_env , obuf , envs [ h_env -> envc ] . indent , 0 , h_env -> limit ) ; return 0 ; case HTML_HR : close_anchor ( h_env , obuf ) ; tmp = process_hr ( tag , h_env -> limit , envs [ h_env -> envc ] . indent ) ; HTMLlineproc1 ( tmp -> ptr , h_env ) ; set_space_to_prevchar ( obuf -> prevchar ) ; return 1 ; case HTML_PRE : x = parsedtag_exists ( tag , ATTR_FOR_TABLE ) ; CLOSE_A ; if ( ! ( obuf -> flag & RB_IGNORE_P ) ) { flushline ( h_env , obuf , envs [ h_env -> envc ] . indent , 0 , h_env -> limit ) ; if ( ! x ) do_blankline ( h_env , obuf , envs [ h_env -> envc ] . indent , 0 , h_env -> limit ) ; } else fillline ( obuf , envs [ h_env -> envc ] . indent ) ; obuf -> flag |= ( RB_PRE | RB_IGNORE_P ) ; return 1 ; case HTML_N_PRE : flushline ( h_env , obuf , envs [ h_env -> envc ] . indent , 0 , h_env -> limit ) ; if ( ! ( obuf -> flag & RB_IGNORE_P ) ) { do_blankline ( h_env , obuf , envs [ h_env -> envc ] . indent , 0 , h_env -> limit ) ; obuf -> flag |= RB_IGNORE_P ; h_env -> blank_lines ++ ; } obuf -> flag &= ~ RB_PRE ; close_anchor ( h_env , obuf ) ; return 1 ; case HTML_PRE_INT : i = obuf -> line -> length ; append_tags ( obuf ) ; if ( ! ( obuf -> flag & RB_SPECIAL ) ) { set_breakpoint ( obuf , obuf -> line -> length - i ) ; } obuf -> flag |= RB_PRE_INT ; return 0 ; case HTML_N_PRE_INT : push_tag ( obuf , \"</pre_int>\" , HTML_N_PRE_INT ) ; obuf -> flag &= ~ RB_PRE_INT ; if ( ! ( obuf -> flag & RB_SPECIAL ) && obuf -> pos > obuf -> bp . pos ) { set_prevchar ( obuf -> prevchar , \"\" , 0 ) ; obuf -> prev_ctype = PC_CTRL ; } return 1 ; case HTML_NOBR : obuf -> flag |= RB_NOBR ; obuf -> nobr_level ++ ; return 0 ; case HTML_N_NOBR : if ( obuf -> nobr_level > 0 ) obuf -> nobr_level -- ; if ( obuf -> nobr_level == 0 ) obuf -> flag &= ~ RB_NOBR ; return 0 ; case HTML_PRE_PLAIN : CLOSE_A ; if ( ! ( obuf -> flag & RB_IGNORE_P ) ) { flushline ( h_env , obuf , envs [ h_env -> envc ] . indent , 0 , h_env -> limit ) ; do_blankline ( h_env , obuf , envs [ h_env -> envc ] . indent , 0 , h_env -> limit ) ; } obuf -> flag |= ( RB_PRE | RB_IGNORE_P ) ; return 1 ; case HTML_N_PRE_PLAIN : CLOSE_A ; if ( ! ( obuf -> flag & RB_IGNORE_P ) ) { flushline ( h_env , obuf , envs [ h_env -> envc ] . indent , 0 , h_env -> limit ) ; do_blankline ( h_env , obuf , envs [ h_env -> envc ] . indent , 0 , h_env -> limit ) ; obuf -> flag |= RB_IGNORE_P ; } obuf -> flag &= ~ RB_PRE ; return 1 ; case HTML_LISTING : case HTML_XMP : case HTML_PLAINTEXT : CLOSE_A ; if ( ! ( obuf -> flag & RB_IGNORE_P ) ) { flushline ( h_env , obuf , envs [ h_env -> envc ] . indent , 0 , h_env -> limit ) ; do_blankline ( h_env , obuf , envs [ h_env -> envc ] . indent , 0 , h_env -> limit ) ; } obuf -> flag |= ( RB_PLAIN | RB_IGNORE_P ) ; switch ( cmd ) { case HTML_LISTING : obuf -> end_tag = HTML_N_LISTING ; break ; case HTML_XMP : obuf -> end_tag = HTML_N_XMP ; break ; case HTML_PLAINTEXT : obuf -> end_tag = MAX_HTMLTAG ; break ; } return 1 ; case HTML_N_LISTING : case HTML_N_XMP : CLOSE_A ; if ( ! ( obuf -> flag & RB_IGNORE_P ) ) { flushline ( h_env , obuf , envs [ h_env -> envc ] . indent , 0 , h_env -> limit ) ; do_blankline ( h_env , obuf , envs [ h_env -> envc ] . indent , 0 , h_env -> limit ) ; obuf -> flag |= RB_IGNORE_P ; } obuf -> flag &= ~ RB_PLAIN ; obuf -> end_tag = 0 ; return 1 ; case HTML_SCRIPT : obuf -> flag |= RB_SCRIPT ; obuf -> end_tag = HTML_N_SCRIPT ; return 1 ; case HTML_STYLE : obuf -> flag |= RB_STYLE ; obuf -> end_tag = HTML_N_STYLE ; return 1 ; case HTML_N_SCRIPT : obuf -> flag &= ~ RB_SCRIPT ; obuf -> end_tag = 0 ; return 1 ; case HTML_N_STYLE : obuf -> flag &= ~ RB_STYLE ; obuf -> end_tag = 0 ; return 1 ; case HTML_A : if ( obuf -> anchor . url ) close_anchor ( h_env , obuf ) ; hseq = 0 ; if ( parsedtag_get_value ( tag , ATTR_HREF , & p ) ) obuf -> anchor . url = Strnew_charp ( p ) -> ptr ; if ( parsedtag_get_value ( tag , ATTR_TARGET , & p ) ) obuf -> anchor . target = Strnew_charp ( p ) -> ptr ; if ( parsedtag_get_value ( tag , ATTR_REFERER , & p ) ) obuf -> anchor . referer = Strnew_charp ( p ) -> ptr ; if ( parsedtag_get_value ( tag , ATTR_TITLE , & p ) ) obuf -> anchor . title = Strnew_charp ( p ) -> ptr ; if ( parsedtag_get_value ( tag , ATTR_ACCESSKEY , & p ) ) obuf -> anchor . accesskey = ( unsigned char ) * p ; if ( parsedtag_get_value ( tag , ATTR_HSEQ , & hseq ) ) obuf -> anchor . hseq = hseq ; if ( hseq == 0 && obuf -> anchor . url ) { obuf -> anchor . hseq = cur_hseq ; tmp = process_anchor ( tag , h_env -> tagbuf -> ptr ) ; push_tag ( obuf , tmp -> ptr , HTML_A ) ; if ( displayLinkNumber ) HTMLlineproc1 ( getLinkNumberStr ( - 1 ) -> ptr , h_env ) ; return 1 ; } return 0 ; case HTML_N_A : close_anchor ( h_env , obuf ) ; return 1 ; case HTML_IMG : tmp = process_img ( tag , h_env -> limit ) ; HTMLlineproc1 ( tmp -> ptr , h_env ) ; return 1 ; case HTML_IMG_ALT : if ( parsedtag_get_value ( tag , ATTR_SRC , & p ) ) obuf -> img_alt = Strnew_charp ( p ) ; # ifdef USE_IMAGE i = 0 ; if ( parsedtag_get_value ( tag , ATTR_TOP_MARGIN , & i ) ) { if ( i > obuf -> top_margin ) obuf -> top_margin = i ; } i = 0 ; if ( parsedtag_get_value ( tag , ATTR_BOTTOM_MARGIN , & i ) ) { if ( i > obuf -> bottom_margin ) obuf -> bottom_margin = i ; } # endif return 0 ; case HTML_N_IMG_ALT : if ( obuf -> img_alt ) { if ( ! close_effect0 ( obuf , HTML_IMG_ALT ) ) push_tag ( obuf , \"</img_alt>\" , HTML_N_IMG_ALT ) ; obuf -> img_alt = NULL ; } return 1 ; case HTML_INPUT_ALT : i = 0 ; if ( parsedtag_get_value ( tag , ATTR_TOP_MARGIN , & i ) ) { if ( i > obuf -> top_margin ) obuf -> top_margin = i ; } i = 0 ; if ( parsedtag_get_value ( tag , ATTR_BOTTOM_MARGIN , & i ) ) { if ( i > obuf -> bottom_margin ) obuf -> bottom_margin = i ; } if ( parsedtag_get_value ( tag , ATTR_HSEQ , & hseq ) ) { obuf -> input_alt . hseq = hseq ; } if ( parsedtag_get_value ( tag , ATTR_FID , & i ) ) { obuf -> input_alt . fid = i ; } if ( parsedtag_get_value ( tag , ATTR_TYPE , & p ) ) { obuf -> input_alt . type = Strnew_charp ( p ) ; } if ( parsedtag_get_value ( tag , ATTR_VALUE , & p ) ) { obuf -> input_alt . value = Strnew_charp ( p ) ; } if ( parsedtag_get_value ( tag , ATTR_NAME , & p ) ) { obuf -> input_alt . name = Strnew_charp ( p ) ; } obuf -> input_alt . in = 1 ; return 0 ; case HTML_N_INPUT_ALT : if ( obuf -> input_alt . in ) { if ( ! close_effect0 ( obuf , HTML_INPUT_ALT ) ) push_tag ( obuf , \"</input_alt>\" , HTML_N_INPUT_ALT ) ; obuf -> input_alt . hseq = 0 ; obuf -> input_alt . fid = - 1 ; obuf -> input_alt . in = 0 ; obuf -> input_alt . type = NULL ; obuf -> input_alt . name = NULL ; obuf -> input_alt . value = NULL ; } return 1 ; case HTML_TABLE : close_anchor ( h_env , obuf ) ; obuf -> table_level ++ ; if ( obuf -> table_level >= MAX_TABLE ) break ; w = BORDER_NONE ; x = 2 ; y = 1 ; z = 0 ; width = 0 ; if ( parsedtag_exists ( tag , ATTR_BORDER ) ) { if ( parsedtag_get_value ( tag , ATTR_BORDER , & w ) ) { if ( w > 2 ) w = BORDER_THICK ; else if ( w < 0 ) { w = BORDER_THIN ; } } else w = BORDER_THIN ; } if ( DisplayBorders && w == BORDER_NONE ) w = BORDER_THIN ; if ( parsedtag_get_value ( tag , ATTR_WIDTH , & i ) ) { if ( obuf -> table_level == 0 ) width = REAL_WIDTH ( i , h_env -> limit - envs [ h_env -> envc ] . indent ) ; else width = RELATIVE_WIDTH ( i ) ; } if ( parsedtag_exists ( tag , ATTR_HBORDER ) ) w = BORDER_NOWIN ; # define MAX_CELLSPACING 1000 # define MAX_CELLPADDING 1000 # define MAX_VSPACE 1000 parsedtag_get_value ( tag , ATTR_CELLSPACING , & x ) ; parsedtag_get_value ( tag , ATTR_CELLPADDING , & y ) ; parsedtag_get_value ( tag , ATTR_VSPACE , & z ) ; if ( x > MAX_CELLSPACING ) x = MAX_CELLSPACING ; if ( y > MAX_CELLPADDING ) y = MAX_CELLPADDING ; if ( z > MAX_VSPACE ) z = MAX_VSPACE ; # ifdef ID_EXT parsedtag_get_value ( tag , ATTR_ID , & id ) ; # endif tables [ obuf -> table_level ] = begin_table ( w , x , y , z ) ; # ifdef ID_EXT if ( id != NULL ) tables [ obuf -> table_level ] -> id = Strnew_charp ( id ) ; # endif table_mode [ obuf -> table_level ] . pre_mode = 0 ; table_mode [ obuf -> table_level ] . indent_level = 0 ; table_mode [ obuf -> table_level ] . nobr_level = 0 ; table_mode [ obuf -> table_level ] . caption = 0 ; table_mode [ obuf -> table_level ] . end_tag = 0 ; # ifndef TABLE_EXPAND tables [ obuf -> table_level ] -> total_width = width ; # else tables [ obuf -> table_level ] -> real_width = width ; tables [ obuf -> table_level ] -> total_width = 0 ; # endif return 1 ; case HTML_N_TABLE : return 1 ; case HTML_CENTER : CLOSE_A ; if ( ! ( obuf -> flag & ( RB_PREMODE | RB_IGNORE_P ) ) ) flushline ( h_env , obuf , envs [ h_env -> envc ] . indent , 0 , h_env -> limit ) ; RB_SAVE_FLAG ( obuf ) ; RB_SET_ALIGN ( obuf , RB_CENTER ) ; return 1 ; case HTML_N_CENTER : CLOSE_A ; if ( ! ( obuf -> flag & RB_PREMODE ) ) flushline ( h_env , obuf , envs [ h_env -> envc ] . indent , 0 , h_env -> limit ) ; RB_RESTORE_FLAG ( obuf ) ; return 1 ; case HTML_DIV : CLOSE_A ; if ( ! ( obuf -> flag & RB_IGNORE_P ) ) flushline ( h_env , obuf , envs [ h_env -> envc ] . indent , 0 , h_env -> limit ) ; set_alignment ( obuf , tag ) ; return 1 ; case HTML_N_DIV : CLOSE_A ; flushline ( h_env , obuf , envs [ h_env -> envc ] . indent , 0 , h_env -> limit ) ; RB_RESTORE_FLAG ( obuf ) ; return 1 ; case HTML_DIV_INT : CLOSE_P ; if ( ! ( obuf -> flag & RB_IGNORE_P ) ) flushline ( h_env , obuf , envs [ h_env -> envc ] . indent , 0 , h_env -> limit ) ; set_alignment ( obuf , tag ) ; return 1 ; case HTML_N_DIV_INT : CLOSE_P ; flushline ( h_env , obuf , envs [ h_env -> envc ] . indent , 0 , h_env -> limit ) ; RB_RESTORE_FLAG ( obuf ) ; return 1 ; case HTML_FORM : CLOSE_A ; if ( ! ( obuf -> flag & RB_IGNORE_P ) ) flushline ( h_env , obuf , envs [ h_env -> envc ] . indent , 0 , h_env -> limit ) ; tmp = process_form ( tag ) ; if ( tmp ) HTMLlineproc1 ( tmp -> ptr , h_env ) ; return 1 ; case HTML_N_FORM : CLOSE_A ; flushline ( h_env , obuf , envs [ h_env -> envc ] . indent , 0 , h_env -> limit ) ; obuf -> flag |= RB_IGNORE_P ; process_n_form ( ) ; return 1 ; case HTML_INPUT : close_anchor ( h_env , obuf ) ; tmp = process_input ( tag ) ; if ( tmp ) HTMLlineproc1 ( tmp -> ptr , h_env ) ; return 1 ; case HTML_BUTTON : tmp = process_button ( tag ) ; if ( tmp ) HTMLlineproc1 ( tmp -> ptr , h_env ) ; return 1 ; case HTML_N_BUTTON : tmp = process_n_button ( ) ; if ( tmp ) HTMLlineproc1 ( tmp -> ptr , h_env ) ; return 1 ; case HTML_SELECT : close_anchor ( h_env , obuf ) ; tmp = process_select ( tag ) ; if ( tmp ) HTMLlineproc1 ( tmp -> ptr , h_env ) ; obuf -> flag |= RB_INSELECT ; obuf -> end_tag = HTML_N_SELECT ; return 1 ; case HTML_N_SELECT : obuf -> flag &= ~ RB_INSELECT ; obuf -> end_tag = 0 ; tmp = process_n_select ( ) ; if ( tmp ) HTMLlineproc1 ( tmp -> ptr , h_env ) ; return 1 ; case HTML_OPTION : return 1 ; case HTML_TEXTAREA : close_anchor ( h_env , obuf ) ; tmp = process_textarea ( tag , h_env -> limit ) ; if ( tmp ) HTMLlineproc1 ( tmp -> ptr , h_env ) ; obuf -> flag |= RB_INTXTA ; obuf -> end_tag = HTML_N_TEXTAREA ; return 1 ; case HTML_N_TEXTAREA : obuf -> flag &= ~ RB_INTXTA ; obuf -> end_tag = 0 ; tmp = process_n_textarea ( ) ; if ( tmp ) HTMLlineproc1 ( tmp -> ptr , h_env ) ; return 1 ; case HTML_ISINDEX : p = \"\" ; q = \"!CURRENT_URL!\" ; parsedtag_get_value ( tag , ATTR_PROMPT , & p ) ; parsedtag_get_value ( tag , ATTR_ACTION , & q ) ; tmp = Strnew_m_charp ( \"<form<S2SV_blank>method=get<S2SV_blank>action=\\\\\"\" , html_quote ( q ) , \"\\\\\">\" , html_quote ( p ) , \"<input<S2SV_blank>type=text<S2SV_blank>name=\\\\\"\\\\\"<S2SV_blank>accept></form>\" , NULL ) ; HTMLlineproc1 ( tmp -> ptr , h_env ) ; return 1 ; case HTML_META : p = q = r = NULL ; parsedtag_get_value ( tag , ATTR_HTTP_EQUIV , & p ) ; parsedtag_get_value ( tag , ATTR_CONTENT , & q ) ; # ifdef USE_M17N parsedtag_get_value ( tag , ATTR_CHARSET , & r ) ; if ( r ) { SKIP_BLANKS ( r ) ; meta_charset = wc_guess_charset ( r , 0 ) ; } else if ( p && q && ! strcasecmp ( p , \"Content-Type\" ) && ( q = strcasestr ( q , \"charset\" ) ) != NULL ) { q += 7 ; SKIP_BLANKS ( q ) ; if ( * q == '=' ) { q ++ ; SKIP_BLANKS ( q ) ; meta_charset = wc_guess_charset ( q , 0 ) ; } } else # endif if ( p && q && ! strcasecmp ( p , \"refresh\" ) ) { int refresh_interval ; tmp = NULL ; refresh_interval = getMetaRefreshParam ( q , & tmp ) ; if ( tmp ) { q = html_quote ( tmp -> ptr ) ; tmp = Sprintf ( \"Refresh<S2SV_blank>(%d<S2SV_blank>sec)<S2SV_blank><a<S2SV_blank>href=\\\\\"%s\\\\\">%s</a>\" , refresh_interval , q , q ) ; } else if ( refresh_interval > 0 ) tmp = Sprintf ( \"Refresh<S2SV_blank>(%d<S2SV_blank>sec)\" , refresh_interval ) ; if ( tmp ) { HTMLlineproc1 ( tmp -> ptr , h_env ) ; do_blankline ( h_env , obuf , envs [ h_env -> envc ] . indent , 0 , h_env -> limit ) ; if ( ! is_redisplay && ! ( ( obuf -> flag & RB_NOFRAMES ) && RenderFrame ) ) { tag -> need_reconstruct = TRUE ; return 0 ; } } } return 1 ; case HTML_BASE : # if defined ( USE_M17N ) || defined ( USE_IMAGE ) p = NULL ; if ( parsedtag_get_value ( tag , ATTR_HREF , & p ) ) { cur_baseURL = New ( ParsedURL ) ; parseURL ( p , cur_baseURL , NULL ) ; } # endif case HTML_MAP : case HTML_N_MAP : case HTML_AREA : return 0 ; case HTML_DEL : switch ( displayInsDel ) { case DISPLAY_INS_DEL_SIMPLE : obuf -> flag |= RB_DEL ; break ; case DISPLAY_INS_DEL_NORMAL : HTMLlineproc1 ( \"<U>[DEL:</U>\" , h_env ) ; break ; case DISPLAY_INS_DEL_FONTIFY : obuf -> in_strike ++ ; if ( obuf -> in_strike == 1 ) { push_tag ( obuf , \"<s>\" , HTML_S ) ; } break ; } return 1 ; case HTML_N_DEL : switch ( displayInsDel ) { case DISPLAY_INS_DEL_SIMPLE : obuf -> flag &= ~ RB_DEL ; break ; case DISPLAY_INS_DEL_NORMAL : HTMLlineproc1 ( \"<U>:DEL]</U>\" , h_env ) ; case DISPLAY_INS_DEL_FONTIFY : if ( obuf -> in_strike == 0 ) return 1 ; if ( obuf -> in_strike == 1 && close_effect0 ( obuf , HTML_S ) ) obuf -> in_strike = 0 ; if ( obuf -> in_strike > 0 ) { obuf -> in_strike -- ; if ( obuf -> in_strike == 0 ) { push_tag ( obuf , \"</s>\" , HTML_N_S ) ; } } break ; } return 1 ; case HTML_S : switch ( displayInsDel ) { case DISPLAY_INS_DEL_SIMPLE : obuf -> flag |= RB_S ; break ; case DISPLAY_INS_DEL_NORMAL : HTMLlineproc1 ( \"<U>[S:</U>\" , h_env ) ; break ; case DISPLAY_INS_DEL_FONTIFY : obuf -> in_strike ++ ; if ( obuf -> in_strike == 1 ) { push_tag ( obuf , \"<s>\" , HTML_S ) ; } break ; } return 1 ; case HTML_N_S : switch ( displayInsDel ) { case DISPLAY_INS_DEL_SIMPLE : obuf -> flag &= ~ RB_S ; break ; case DISPLAY_INS_DEL_NORMAL : HTMLlineproc1 ( \"<U>:S]</U>\" , h_env ) ; break ; case DISPLAY_INS_DEL_FONTIFY : if ( obuf -> in_strike == 0 ) return 1 ; if ( obuf -> in_strike == 1 && close_effect0 ( obuf , HTML_S ) ) obuf -> in_strike = 0 ; if ( obuf -> in_strike > 0 ) { obuf -> in_strike -- ; if ( obuf -> in_strike == 0 ) { push_tag ( obuf , \"</s>\" , HTML_N_S ) ; } } } return 1 ; case HTML_INS : switch ( displayInsDel ) { case DISPLAY_INS_DEL_SIMPLE : break ; case DISPLAY_INS_DEL_NORMAL : HTMLlineproc1 ( \"<U>[INS:</U>\" , h_env ) ; break ; case DISPLAY_INS_DEL_FONTIFY : obuf -> in_ins ++ ; if ( obuf -> in_ins == 1 ) { push_tag ( obuf , \"<ins>\" , HTML_INS ) ; } break ; } return 1 ; case HTML_N_INS : switch ( displayInsDel ) { case DISPLAY_INS_DEL_SIMPLE : break ; case DISPLAY_INS_DEL_NORMAL : HTMLlineproc1 ( \"<U>:INS]</U>\" , h_env ) ; break ; case DISPLAY_INS_DEL_FONTIFY : if ( obuf -> in_ins == 0 ) return 1 ; if ( obuf -> in_ins == 1 && close_effect0 ( obuf , HTML_INS ) ) obuf -> in_ins = 0 ; if ( obuf -> in_ins > 0 ) { obuf -> in_ins -- ; if ( obuf -> in_ins == 0 ) { push_tag ( obuf , \"</ins>\" , HTML_N_INS ) ; } } break ; } return 1 ; case HTML_SUP : if ( ! ( obuf -> flag & ( RB_DEL | RB_S ) ) ) HTMLlineproc1 ( \"^\" , h_env ) ; return 1 ; case HTML_N_SUP : return 1 ; case HTML_SUB : if ( ! ( obuf -> flag & ( RB_DEL | RB_S ) ) ) HTMLlineproc1 ( \"[\" , h_env ) ; return 1 ; case HTML_N_SUB : if ( ! ( obuf -> flag & ( RB_DEL | RB_S ) ) ) HTMLlineproc1 ( \"]\" , h_env ) ; return 1 ; case HTML_FONT : case HTML_N_FONT : case HTML_NOP : return 1 ; case HTML_BGSOUND : if ( view_unseenobject ) { if ( parsedtag_get_value ( tag , ATTR_SRC , & p ) ) { Str s ; q = html_quote ( p ) ; s = Sprintf ( \"<A<S2SV_blank>HREF=\\\\\"%s\\\\\">bgsound(%s)</A>\" , q , q ) ; HTMLlineproc1 ( s -> ptr , h_env ) ; } } return 1 ; case HTML_EMBED : if ( view_unseenobject ) { if ( parsedtag_get_value ( tag , ATTR_SRC , & p ) ) { Str s ; q = html_quote ( p ) ; s = Sprintf ( \"<A<S2SV_blank>HREF=\\\\\"%s\\\\\">embed(%s)</A>\" , q , q ) ; HTMLlineproc1 ( s -> ptr , h_env ) ; } } return 1 ; case HTML_APPLET : if ( view_unseenobject ) { if ( parsedtag_get_value ( tag , ATTR_ARCHIVE , & p ) ) { Str s ; q = html_quote ( p ) ; s = Sprintf ( \"<A<S2SV_blank>HREF=\\\\\"%s\\\\\">applet<S2SV_blank>archive(%s)</A>\" , q , q ) ; HTMLlineproc1 ( s -> ptr , h_env ) ; } } return 1 ; case HTML_BODY : if ( view_unseenobject ) { if ( parsedtag_get_value ( tag , ATTR_BACKGROUND , & p ) ) { Str s ; q = html_quote ( p ) ; s = Sprintf ( \"<IMG<S2SV_blank>SRC=\\\\\"%s\\\\\"<S2SV_blank>ALT=\\\\\"bg<S2SV_blank>image(%s)\\\\\"><BR>\" , q , q ) ; HTMLlineproc1 ( s -> ptr , h_env ) ; } } case HTML_N_HEAD : if ( obuf -> flag & RB_TITLE ) HTMLlineproc1 ( \"</title>\" , h_env ) ; case HTML_HEAD : case HTML_N_BODY : return 1 ; default : return 0 ; } return 0 ; }\n",
      "fixed_code": "<S2SV_ModStart> ; if ( h_env -> envc == 0 || ( h_env -> envc_real < h_env -> nenv && envs [ h_env -> envc ] . env != HTML_DL && envs [ h_env -> envc ] . env != HTML_DL_COMPACT ) ) { PUSH_ENV ( HTML_DL ) ; } if (\n",
      "source_code_length": 26678,
      "target_code_length": 212,
      "vulnerability_patterns": {
        "buffer_overflow": 8,
        "use_after_free": 1,
        "integer_overflow": 23,
        "format_string": 8,
        "null_pointer": 362,
        "total": 402
      },
      "total_patterns": 402,
      "original_address": "https://github.com/tats/w3m/commit/33509cc81ec5f2ba44eb6fd98bd5c1b5873e46bd",
      "discovery_time": "2017-01-20T15:59Z",
      "project_commit_id": "tats@w3m/33509cc81ec5f2ba44eb6fd98bd5c1b5873e46bd",
      "extraction_time": "2025-08-31T15:41:49.188327",
      "label": 1,
      "vulnerability_type": "improper_input_validation",
      "difficulty_level": "advanced",
      "risk_factors": [
        "buffer_overflow",
        "use_after_free"
      ],
      "attack_vectors": [
        "fuzzing",
        "code_analysis",
        "reverse_engineering"
      ],
      "mitigation_strategies": [
        "dynamic_analysis",
        "static_analysis",
        "fuzzing",
        "code_review",
        "secure_coding_practices"
      ],
      "code_differences": {
        "has_differences": true,
        "source_lines": 2,
        "target_lines": 2,
        "character_differences": 26466,
        "similarity_percentage": 5.605381165919283
      },
      "vulnerability_location": {
        "vulnerability_present": true,
        "fix_applied": true,
        "code_changed": true,
        "estimated_lines_changed": 0
      }
    },
    {
      "cve_id": "CVE-2018-7492",
      "cwe_id": "CWE-476",
      "cwe_name": "NULL Pointer Dereference",
      "project": "torvalds",
      "severity": "critical",
      "weaponization_score": 7.5,
      "is_critical": true,
      "is_weaponizable": true,
      "is_high_priority_project": false,
      "vulnerable_code": "CWE-476 static int __rds_rdma_map ( struct rds_sock * rs , struct rds_get_mr_args * args , u64 * cookie_ret , struct rds_mr * * mr_ret ) { struct rds_mr * mr = NULL , * found ; unsigned int nr_pages ; struct page * * pages = NULL ; struct scatterlist * sg ; void * trans_private ; unsigned long flags ; rds_rdma_cookie_t cookie ; unsigned int nents ; long i ; int ret ; <S2SV_StartBug> if ( rs -> rs_bound_addr == 0 ) { <S2SV_EndBug> ret = - ENOTCONN ; goto out ; } if ( ! rs -> rs_transport -> get_mr ) { ret = - EOPNOTSUPP ; goto out ; } nr_pages = rds_pages_in_vec ( & args -> vec ) ; if ( nr_pages == 0 ) { ret = - EINVAL ; goto out ; } if ( ( nr_pages - 1 ) > ( RDS_MAX_MSG_SIZE >> PAGE_SHIFT ) ) { ret = - EMSGSIZE ; goto out ; } rdsdebug ( \"RDS:<S2SV_blank>get_mr<S2SV_blank>addr<S2SV_blank>%llx<S2SV_blank>len<S2SV_blank>%llu<S2SV_blank>nr_pages<S2SV_blank>%u\\\\n\" , args -> vec . addr , args -> vec . bytes , nr_pages ) ; pages = kcalloc ( nr_pages , sizeof ( struct page * ) , GFP_KERNEL ) ; if ( ! pages ) { ret = - ENOMEM ; goto out ; } mr = kzalloc ( sizeof ( struct rds_mr ) , GFP_KERNEL ) ; if ( ! mr ) { ret = - ENOMEM ; goto out ; } refcount_set ( & mr -> r_refcount , 1 ) ; RB_CLEAR_NODE ( & mr -> r_rb_node ) ; mr -> r_trans = rs -> rs_transport ; mr -> r_sock = rs ; if ( args -> flags & RDS_RDMA_USE_ONCE ) mr -> r_use_once = 1 ; if ( args -> flags & RDS_RDMA_INVALIDATE ) mr -> r_invalidate = 1 ; if ( args -> flags & RDS_RDMA_READWRITE ) mr -> r_write = 1 ; ret = rds_pin_pages ( args -> vec . addr , nr_pages , pages , 1 ) ; if ( ret < 0 ) goto out ; nents = ret ; sg = kcalloc ( nents , sizeof ( * sg ) , GFP_KERNEL ) ; if ( ! sg ) { ret = - ENOMEM ; goto out ; } WARN_ON ( ! nents ) ; sg_init_table ( sg , nents ) ; for ( i = 0 ; i < nents ; i ++ ) sg_set_page ( & sg [ i ] , pages [ i ] , PAGE_SIZE , 0 ) ; rdsdebug ( \"RDS:<S2SV_blank>trans_private<S2SV_blank>nents<S2SV_blank>is<S2SV_blank>%u\\\\n\" , nents ) ; trans_private = rs -> rs_transport -> get_mr ( sg , nents , rs , & mr -> r_key ) ; if ( IS_ERR ( trans_private ) ) { for ( i = 0 ; i < nents ; i ++ ) put_page ( sg_page ( & sg [ i ] ) ) ; kfree ( sg ) ; ret = PTR_ERR ( trans_private ) ; goto out ; } mr -> r_trans_private = trans_private ; rdsdebug ( \"RDS:<S2SV_blank>get_mr<S2SV_blank>put_user<S2SV_blank>key<S2SV_blank>is<S2SV_blank>%x<S2SV_blank>cookie_addr<S2SV_blank>%p\\\\n\" , mr -> r_key , ( void * ) ( unsigned long ) args -> cookie_addr ) ; cookie = rds_rdma_make_cookie ( mr -> r_key , args -> vec . addr & ~ PAGE_MASK ) ; if ( cookie_ret ) * cookie_ret = cookie ; if ( args -> cookie_addr && put_user ( cookie , ( u64 __user * ) ( unsigned long ) args -> cookie_addr ) ) { ret = - EFAULT ; goto out ; } spin_lock_irqsave ( & rs -> rs_rdma_lock , flags ) ; found = rds_mr_tree_walk ( & rs -> rs_rdma_keys , mr -> r_key , mr ) ; spin_unlock_irqrestore ( & rs -> rs_rdma_lock , flags ) ; BUG_ON ( found && found != mr ) ; rdsdebug ( \"RDS:<S2SV_blank>get_mr<S2SV_blank>key<S2SV_blank>is<S2SV_blank>%x\\\\n\" , mr -> r_key ) ; if ( mr_ret ) { refcount_inc ( & mr -> r_refcount ) ; * mr_ret = mr ; } ret = 0 ; out : kfree ( pages ) ; if ( mr ) rds_mr_put ( mr ) ; return ret ; }\n",
      "fixed_code": "<S2SV_ModStart> rs_bound_addr == 0 || ! rs -> rs_transport\n",
      "source_code_length": 3165,
      "target_code_length": 59,
      "vulnerability_patterns": {
        "use_after_free": 2,
        "integer_overflow": 2,
        "null_pointer": 40,
        "total": 44
      },
      "total_patterns": 44,
      "original_address": "https://github.com/torvalds/linux/commit/f3069c6d33f6ae63a1668737bc78aaaa51bff7ca",
      "discovery_time": "2018-02-26T20:29Z",
      "project_commit_id": "torvalds@linux/f3069c6d33f6ae63a1668737bc78aaaa51bff7ca",
      "extraction_time": "2025-08-31T15:41:49.188549",
      "label": 1,
      "vulnerability_type": "null_pointer_dereference",
      "difficulty_level": "advanced",
      "risk_factors": [
        "system_crash",
        "denial_of_service",
        "memory_corruption",
        "use_after_free"
      ],
      "attack_vectors": [
        "memory_manipulation",
        "null_pointer",
        "code_analysis",
        "reverse_engineering",
        "use_after_free",
        "fuzzing"
      ],
      "mitigation_strategies": [
        "null_pointer_checks",
        "fuzzing",
        "dynamic_analysis",
        "memory_management",
        "static_analysis",
        "use_after_free_prevention",
        "code_review",
        "secure_coding_practices"
      ],
      "code_differences": {
        "has_differences": true,
        "source_lines": 2,
        "target_lines": 2,
        "character_differences": 3106,
        "similarity_percentage": 5.511811023622047
      },
      "vulnerability_location": {
        "vulnerability_present": true,
        "fix_applied": true,
        "code_changed": true,
        "estimated_lines_changed": 0
      }
    },
    {
      "cve_id": "CVE-2018-19824",
      "cwe_id": "CWE-416",
      "cwe_name": "Use After Free",
      "project": "torvalds",
      "severity": "critical",
      "weaponization_score": 7.5,
      "is_critical": true,
      "is_weaponizable": true,
      "is_high_priority_project": false,
      "vulnerable_code": "CWE-416 static int usb_audio_probe ( struct usb_interface * intf , const struct usb_device_id * usb_id ) { struct usb_device * dev = interface_to_usbdev ( intf ) ; const struct snd_usb_audio_quirk * quirk = ( const struct snd_usb_audio_quirk * ) usb_id -> driver_info ; struct snd_usb_audio * chip ; int i , err ; struct usb_host_interface * alts ; int ifnum ; u32 id ; alts = & intf -> altsetting [ 0 ] ; ifnum = get_iface_desc ( alts ) -> bInterfaceNumber ; id = USB_ID ( le16_to_cpu ( dev -> descriptor . idVendor ) , le16_to_cpu ( dev -> descriptor . idProduct ) ) ; if ( get_alias_id ( dev , & id ) ) quirk = get_alias_quirk ( dev , id ) ; if ( quirk && quirk -> ifnum >= 0 && ifnum != quirk -> ifnum ) return - ENXIO ; err = snd_usb_apply_boot_quirk ( dev , intf , quirk , id ) ; if ( err < 0 ) return err ; chip = NULL ; mutex_lock ( & register_mutex ) ; for ( i = 0 ; i < SNDRV_CARDS ; i ++ ) { if ( usb_chip [ i ] && usb_chip [ i ] -> dev == dev ) { if ( atomic_read ( & usb_chip [ i ] -> shutdown ) ) { dev_err ( & dev -> dev , \"USB<S2SV_blank>device<S2SV_blank>is<S2SV_blank>in<S2SV_blank>the<S2SV_blank>shutdown<S2SV_blank>state,<S2SV_blank>cannot<S2SV_blank>create<S2SV_blank>a<S2SV_blank>card<S2SV_blank>instance\\\\n\" ) ; err = - EIO ; goto __error ; } chip = usb_chip [ i ] ; atomic_inc ( & chip -> active ) ; break ; } } if ( ! chip ) { for ( i = 0 ; i < SNDRV_CARDS ; i ++ ) if ( ! usb_chip [ i ] && ( vid [ i ] == - 1 || vid [ i ] == USB_ID_VENDOR ( id ) ) && ( pid [ i ] == - 1 || pid [ i ] == USB_ID_PRODUCT ( id ) ) ) { if ( enable [ i ] ) { err = snd_usb_audio_create ( intf , dev , i , quirk , id , & chip ) ; if ( err < 0 ) goto __error ; chip -> pm_intf = intf ; break ; } else if ( vid [ i ] != - 1 || pid [ i ] != - 1 ) { dev_info ( & dev -> dev , \"device<S2SV_blank>(%04x:%04x)<S2SV_blank>is<S2SV_blank>disabled\\\\n\" , USB_ID_VENDOR ( id ) , USB_ID_PRODUCT ( id ) ) ; err = - ENOENT ; goto __error ; } } if ( ! chip ) { dev_err ( & dev -> dev , \"no<S2SV_blank>available<S2SV_blank>usb<S2SV_blank>audio<S2SV_blank>device\\\\n\" ) ; err = - ENODEV ; goto __error ; } } dev_set_drvdata ( & dev -> dev , chip ) ; if ( ! chip -> ctrl_intf ) chip -> ctrl_intf = alts ; chip -> txfr_quirk = 0 ; err = 1 ; if ( quirk && quirk -> ifnum != QUIRK_NO_INTERFACE ) { err = snd_usb_create_quirk ( chip , intf , & usb_audio_driver , quirk ) ; if ( err < 0 ) goto __error ; } if ( err > 0 ) { err = snd_usb_create_streams ( chip , ifnum ) ; if ( err < 0 ) goto __error ; err = snd_usb_create_mixer ( chip , ifnum , ignore_ctl_error ) ; if ( err < 0 ) goto __error ; } err = snd_card_register ( chip -> card ) ; if ( err < 0 ) goto __error ; usb_chip [ chip -> index ] = chip ; chip -> num_interfaces ++ ; usb_set_intfdata ( intf , chip ) ; atomic_dec ( & chip -> active ) ; mutex_unlock ( & register_mutex ) ; return 0 ; __error : if ( chip ) { <S2SV_StartBug> if ( ! chip -> num_interfaces ) <S2SV_EndBug> snd_card_free ( chip -> card ) ; <S2SV_StartBug> atomic_dec ( & chip -> active ) ; <S2SV_EndBug> } mutex_unlock ( & register_mutex ) ; return err ; }\n",
      "fixed_code": "<S2SV_ModStart> chip ) { atomic_dec ( & chip -> active ) ; <S2SV_ModStart> card ) ; <S2SV_ModEnd> } mutex_unlock (\n",
      "source_code_length": 3063,
      "target_code_length": 115,
      "vulnerability_patterns": {
        "integer_overflow": 3,
        "null_pointer": 30,
        "sql_injection": 1,
        "total": 34
      },
      "total_patterns": 34,
      "original_address": "https://github.com/torvalds/linux/commit/5f8cf712582617d523120df67d392059eaf2fc4b",
      "discovery_time": "2018-12-03T17:29Z",
      "project_commit_id": "torvalds@linux/5f8cf712582617d523120df67d392059eaf2fc4b",
      "extraction_time": "2025-08-31T15:41:49.188611",
      "label": 1,
      "vulnerability_type": "use_after_free",
      "difficulty_level": "advanced",
      "risk_factors": [
        "system_crash",
        "denial_of_service",
        "memory_corruption",
        "sql_injection"
      ],
      "attack_vectors": [
        "memory_manipulation",
        "null_pointer",
        "code_analysis",
        "reverse_engineering",
        "use_after_free",
        "fuzzing"
      ],
      "mitigation_strategies": [
        "null_pointer_checks",
        "fuzzing",
        "dynamic_analysis",
        "memory_management",
        "static_analysis",
        "use_after_free_prevention",
        "code_review",
        "secure_coding_practices"
      ],
      "code_differences": {
        "has_differences": true,
        "source_lines": 2,
        "target_lines": 2,
        "character_differences": 2948,
        "similarity_percentage": 10.434782608695652
      },
      "vulnerability_location": {
        "vulnerability_present": true,
        "fix_applied": true,
        "code_changed": true,
        "estimated_lines_changed": 0
      }
    },
    {
      "cve_id": "CVE-2019-12818",
      "cwe_id": "CWE-476",
      "cwe_name": "NULL Pointer Dereference",
      "project": "torvalds",
      "severity": "critical",
      "weaponization_score": 7.5,
      "is_critical": true,
      "is_weaponizable": true,
      "is_high_priority_project": false,
      "vulnerable_code": "CWE-476 int nfc_llcp_send_cc ( struct nfc_llcp_sock * sock ) { struct nfc_llcp_local * local ; struct sk_buff * skb ; u8 * miux_tlv = NULL , miux_tlv_length ; u8 * rw_tlv = NULL , rw_tlv_length , rw ; int err ; u16 size = 0 ; __be16 miux ; pr_debug ( \"Sending<S2SV_blank>CC\\\\n\" ) ; local = sock -> local ; if ( local == NULL ) return - ENODEV ; miux = be16_to_cpu ( sock -> miux ) > LLCP_MAX_MIUX ? local -> miux : sock -> miux ; rw = sock -> rw > LLCP_MAX_RW ? local -> rw : sock -> rw ; miux_tlv = nfc_llcp_build_tlv ( LLCP_TLV_MIUX , ( u8 * ) & miux , 0 , & miux_tlv_length ) ; <S2SV_StartBug> size += miux_tlv_length ; <S2SV_EndBug> rw_tlv = nfc_llcp_build_tlv ( LLCP_TLV_RW , & rw , 0 , & rw_tlv_length ) ; <S2SV_StartBug> size += rw_tlv_length ; <S2SV_EndBug> skb = llcp_allocate_pdu ( sock , LLCP_PDU_CC , size ) ; if ( skb == NULL ) { err = - ENOMEM ; goto error_tlv ; } llcp_add_tlv ( skb , miux_tlv , miux_tlv_length ) ; llcp_add_tlv ( skb , rw_tlv , rw_tlv_length ) ; skb_queue_tail ( & local -> tx_queue , skb ) ; err = 0 ; error_tlv : if ( err ) pr_err ( \"error<S2SV_blank>%d\\\\n\" , err ) ; kfree ( miux_tlv ) ; kfree ( rw_tlv ) ; return err ; }\n",
      "fixed_code": "<S2SV_ModStart> miux_tlv_length ) ; if ( ! miux_tlv ) { err = - ENOMEM ; goto error_tlv ; } <S2SV_ModStart> rw_tlv_length ) ; if ( ! rw_tlv ) { err = - ENOMEM ; goto error_tlv ; }\n",
      "source_code_length": 1158,
      "target_code_length": 180,
      "vulnerability_patterns": {
        "use_after_free": 2,
        "integer_overflow": 2,
        "null_pointer": 10,
        "total": 14
      },
      "total_patterns": 14,
      "original_address": "https://github.com/torvalds/linux/commit/58bdd544e2933a21a51eecf17c3f5f94038261b5",
      "discovery_time": "2019-06-14T02:29Z",
      "project_commit_id": "torvalds@linux/58bdd544e2933a21a51eecf17c3f5f94038261b5",
      "extraction_time": "2025-08-31T15:41:49.188656",
      "label": 1,
      "vulnerability_type": "null_pointer_dereference",
      "difficulty_level": "advanced",
      "risk_factors": [
        "system_crash",
        "denial_of_service",
        "memory_corruption",
        "use_after_free"
      ],
      "attack_vectors": [
        "memory_manipulation",
        "null_pointer",
        "code_analysis",
        "reverse_engineering",
        "use_after_free",
        "fuzzing"
      ],
      "mitigation_strategies": [
        "null_pointer_checks",
        "fuzzing",
        "dynamic_analysis",
        "memory_management",
        "static_analysis",
        "use_after_free_prevention",
        "code_review",
        "secure_coding_practices"
      ],
      "code_differences": {
        "has_differences": true,
        "source_lines": 2,
        "target_lines": 2,
        "character_differences": 978,
        "similarity_percentage": 24.615384615384617
      },
      "vulnerability_location": {
        "vulnerability_present": true,
        "fix_applied": true,
        "code_changed": true,
        "estimated_lines_changed": 0
      }
    },
    {
      "cve_id": "CVE-2019-19959",
      "cwe_id": "CWE-000",
      "cwe_name": "Unknown/Uncategorized",
      "project": "sqlite",
      "severity": "critical",
      "weaponization_score": 7.5,
      "is_critical": true,
      "is_weaponizable": true,
      "is_high_priority_project": true,
      "vulnerable_code": "CWE-000 static int zipfileUpdate ( sqlite3_vtab * pVtab , int nVal , sqlite3_value * * apVal , sqlite_int64 * pRowid ) { ZipfileTab * pTab = ( ZipfileTab * ) pVtab ; int rc = SQLITE_OK ; ZipfileEntry * pNew = 0 ; u32 mode = 0 ; u32 mTime = 0 ; i64 sz = 0 ; const char * zPath = 0 ; int nPath = 0 ; const u8 * pData = 0 ; int nData = 0 ; int iMethod = 0 ; u8 * pFree = 0 ; char * zFree = 0 ; ZipfileEntry * pOld = 0 ; ZipfileEntry * pOld2 = 0 ; int bUpdate = 0 ; int bIsDir = 0 ; u32 iCrc32 = 0 ; if ( pTab -> pWriteFd == 0 ) { rc = zipfileBegin ( pVtab ) ; if ( rc != SQLITE_OK ) return rc ; } if ( sqlite3_value_type ( apVal [ 0 ] ) != SQLITE_NULL ) { const char * zDelete = ( const char * ) sqlite3_value_text ( apVal [ 0 ] ) ; int nDelete = ( int ) strlen ( zDelete ) ; if ( nVal > 1 ) { const char * zUpdate = ( const char * ) sqlite3_value_text ( apVal [ 1 ] ) ; if ( zUpdate && zipfileComparePath ( zUpdate , zDelete , nDelete ) != 0 ) { bUpdate = 1 ; } } for ( pOld = pTab -> pFirstEntry ; 1 ; pOld = pOld -> pNext ) { if ( zipfileComparePath ( pOld -> cds . zFile , zDelete , nDelete ) == 0 ) { break ; } assert ( pOld -> pNext ) ; } } if ( nVal > 1 ) { if ( sqlite3_value_type ( apVal [ 5 ] ) != SQLITE_NULL ) { zipfileTableErr ( pTab , \"sz<S2SV_blank>must<S2SV_blank>be<S2SV_blank>NULL\" ) ; rc = SQLITE_CONSTRAINT ; } if ( sqlite3_value_type ( apVal [ 6 ] ) != SQLITE_NULL ) { zipfileTableErr ( pTab , \"rawdata<S2SV_blank>must<S2SV_blank>be<S2SV_blank>NULL\" ) ; rc = SQLITE_CONSTRAINT ; } if ( rc == SQLITE_OK ) { if ( sqlite3_value_type ( apVal [ 7 ] ) == SQLITE_NULL ) { bIsDir = 1 ; } else { const u8 * aIn = sqlite3_value_blob ( apVal [ 7 ] ) ; int nIn = sqlite3_value_bytes ( apVal [ 7 ] ) ; int bAuto = sqlite3_value_type ( apVal [ 8 ] ) == SQLITE_NULL ; iMethod = sqlite3_value_int ( apVal [ 8 ] ) ; sz = nIn ; pData = aIn ; nData = nIn ; if ( iMethod != 0 && iMethod != 8 ) { zipfileTableErr ( pTab , \"unknown<S2SV_blank>compression<S2SV_blank>method:<S2SV_blank>%d\" , iMethod ) ; rc = SQLITE_CONSTRAINT ; } else { if ( bAuto || iMethod ) { int nCmp ; rc = zipfileDeflate ( aIn , nIn , & pFree , & nCmp , & pTab -> base . zErrMsg ) ; if ( rc == SQLITE_OK ) { if ( iMethod || nCmp < nIn ) { iMethod = 8 ; pData = pFree ; nData = nCmp ; } } } iCrc32 = crc32 ( 0 , aIn , nIn ) ; } } } if ( rc == SQLITE_OK ) { rc = zipfileGetMode ( apVal [ 3 ] , bIsDir , & mode , & pTab -> base . zErrMsg ) ; } if ( rc == SQLITE_OK ) { zPath = ( const char * ) sqlite3_value_text ( apVal [ 2 ] ) ; if ( zPath == 0 ) zPath = \"\" ; nPath = ( int ) strlen ( zPath ) ; mTime = zipfileGetTime ( apVal [ 4 ] ) ; } if ( rc == SQLITE_OK && bIsDir ) { if ( zPath [ nPath - 1 ] != '/' ) { zFree = sqlite3_mprintf ( \"%s/\" , zPath ) ; if ( zFree == 0 ) { rc = SQLITE_NOMEM ; } zPath = ( const char * ) zFree ; <S2SV_StartBug> nPath ++ ; <S2SV_EndBug> } } if ( ( pOld == 0 || bUpdate ) && rc == SQLITE_OK ) { ZipfileEntry * p ; for ( p = pTab -> pFirstEntry ; p ; p = p -> pNext ) { if ( zipfileComparePath ( p -> cds . zFile , zPath , nPath ) == 0 ) { switch ( sqlite3_vtab_on_conflict ( pTab -> db ) ) { case SQLITE_IGNORE : { goto zipfile_update_done ; } case SQLITE_REPLACE : { pOld2 = p ; break ; } default : { zipfileTableErr ( pTab , \"duplicate<S2SV_blank>name:<S2SV_blank>\\\\\"%s\\\\\"\" , zPath ) ; rc = SQLITE_CONSTRAINT ; break ; } } break ; } } } if ( rc == SQLITE_OK ) { pNew = zipfileNewEntry ( zPath ) ; if ( pNew == 0 ) { rc = SQLITE_NOMEM ; } else { pNew -> cds . iVersionMadeBy = ZIPFILE_NEWENTRY_MADEBY ; pNew -> cds . iVersionExtract = ZIPFILE_NEWENTRY_REQUIRED ; pNew -> cds . flags = ZIPFILE_NEWENTRY_FLAGS ; pNew -> cds . iCompression = ( u16 ) iMethod ; zipfileMtimeToDos ( & pNew -> cds , mTime ) ; pNew -> cds . crc32 = iCrc32 ; pNew -> cds . szCompressed = nData ; pNew -> cds . szUncompressed = ( u32 ) sz ; pNew -> cds . iExternalAttr = ( mode << 16 ) ; pNew -> cds . iOffset = ( u32 ) pTab -> szCurrent ; pNew -> cds . nFile = ( u16 ) nPath ; pNew -> mUnixTime = ( u32 ) mTime ; rc = zipfileAppendEntry ( pTab , pNew , pData , nData ) ; zipfileAddEntry ( pTab , pOld , pNew ) ; } } } if ( rc == SQLITE_OK && ( pOld || pOld2 ) ) { ZipfileCsr * pCsr ; for ( pCsr = pTab -> pCsrList ; pCsr ; pCsr = pCsr -> pCsrNext ) { if ( pCsr -> pCurrent && ( pCsr -> pCurrent == pOld || pCsr -> pCurrent == pOld2 ) ) { pCsr -> pCurrent = pCsr -> pCurrent -> pNext ; pCsr -> bNoop = 1 ; } } zipfileRemoveEntryFromList ( pTab , pOld ) ; zipfileRemoveEntryFromList ( pTab , pOld2 ) ; } zipfile_update_done : sqlite3_free ( pFree ) ; sqlite3_free ( zFree ) ; return rc ; }\n",
      "fixed_code": "<S2SV_ModStart> zFree ; nPath = ( int ) strlen ( zPath ) <S2SV_ModEnd> ; } }\n",
      "source_code_length": 4563,
      "target_code_length": 77,
      "vulnerability_patterns": {
        "integer_overflow": 1,
        "null_pointer": 33,
        "total": 34
      },
      "total_patterns": 34,
      "original_address": "https://github.com/sqlite/sqlite/commit/d8f2d46cbc9925e034a68aaaf60aad788d9373c1",
      "discovery_time": "2020-01-03T22:15Z",
      "project_commit_id": "sqlite@sqlite/d8f2d46cbc9925e034a68aaaf60aad788d9373c1",
      "extraction_time": "2025-08-31T15:41:49.188685",
      "label": 1,
      "vulnerability_type": "unknown/uncategorized",
      "difficulty_level": "advanced",
      "risk_factors": [
        "critical_infrastructure"
      ],
      "attack_vectors": [
        "fuzzing",
        "code_analysis",
        "reverse_engineering"
      ],
      "mitigation_strategies": [
        "dynamic_analysis",
        "static_analysis",
        "fuzzing",
        "code_review",
        "secure_coding_practices"
      ],
      "code_differences": {
        "has_differences": true,
        "source_lines": 2,
        "target_lines": 2,
        "character_differences": 4486,
        "similarity_percentage": 6.451612903225806
      },
      "vulnerability_location": {
        "vulnerability_present": true,
        "fix_applied": true,
        "code_changed": true,
        "estimated_lines_changed": 0
      }
    },
    {
      "cve_id": "CVE-2018-19824",
      "cwe_id": "CWE-416",
      "cwe_name": "Use After Free",
      "project": "torvalds",
      "severity": "critical",
      "weaponization_score": 7.5,
      "is_critical": true,
      "is_weaponizable": true,
      "is_high_priority_project": false,
      "vulnerable_code": "CWE-416 static int usb_audio_probe ( struct usb_interface * intf , const struct usb_device_id * usb_id ) { struct usb_device * dev = interface_to_usbdev ( intf ) ; const struct snd_usb_audio_quirk * quirk = ( const struct snd_usb_audio_quirk * ) usb_id -> driver_info ; struct snd_usb_audio * chip ; int i , err ; struct usb_host_interface * alts ; int ifnum ; u32 id ; alts = & intf -> altsetting [ 0 ] ; ifnum = get_iface_desc ( alts ) -> bInterfaceNumber ; id = USB_ID ( le16_to_cpu ( dev -> descriptor . idVendor ) , le16_to_cpu ( dev -> descriptor . idProduct ) ) ; if ( get_alias_id ( dev , & id ) ) quirk = get_alias_quirk ( dev , id ) ; if ( quirk && quirk -> ifnum >= 0 && ifnum != quirk -> ifnum ) return - ENXIO ; err = snd_usb_apply_boot_quirk ( dev , intf , quirk , id ) ; if ( err < 0 ) return err ; chip = NULL ; mutex_lock ( & register_mutex ) ; for ( i = 0 ; i < SNDRV_CARDS ; i ++ ) { if ( usb_chip [ i ] && usb_chip [ i ] -> dev == dev ) { if ( atomic_read ( & usb_chip [ i ] -> shutdown ) ) { dev_err ( & dev -> dev , \"USB<S2SV_blank>device<S2SV_blank>is<S2SV_blank>in<S2SV_blank>the<S2SV_blank>shutdown<S2SV_blank>state,<S2SV_blank>cannot<S2SV_blank>create<S2SV_blank>a<S2SV_blank>card<S2SV_blank>instance\\\\n\" ) ; err = - EIO ; goto __error ; } chip = usb_chip [ i ] ; atomic_inc ( & chip -> active ) ; break ; } } if ( ! chip ) { for ( i = 0 ; i < SNDRV_CARDS ; i ++ ) if ( ! usb_chip [ i ] && ( vid [ i ] == - 1 || vid [ i ] == USB_ID_VENDOR ( id ) ) && ( pid [ i ] == - 1 || pid [ i ] == USB_ID_PRODUCT ( id ) ) ) { if ( enable [ i ] ) { err = snd_usb_audio_create ( intf , dev , i , quirk , id , & chip ) ; if ( err < 0 ) goto __error ; chip -> pm_intf = intf ; break ; } else if ( vid [ i ] != - 1 || pid [ i ] != - 1 ) { dev_info ( & dev -> dev , \"device<S2SV_blank>(%04x:%04x)<S2SV_blank>is<S2SV_blank>disabled\\\\n\" , USB_ID_VENDOR ( id ) , USB_ID_PRODUCT ( id ) ) ; err = - ENOENT ; goto __error ; } } if ( ! chip ) { dev_err ( & dev -> dev , \"no<S2SV_blank>available<S2SV_blank>usb<S2SV_blank>audio<S2SV_blank>device\\\\n\" ) ; err = - ENODEV ; goto __error ; } } dev_set_drvdata ( & dev -> dev , chip ) ; if ( ! chip -> ctrl_intf ) chip -> ctrl_intf = alts ; chip -> txfr_quirk = 0 ; err = 1 ; if ( quirk && quirk -> ifnum != QUIRK_NO_INTERFACE ) { err = snd_usb_create_quirk ( chip , intf , & usb_audio_driver , quirk ) ; if ( err < 0 ) goto __error ; } if ( err > 0 ) { err = snd_usb_create_streams ( chip , ifnum ) ; if ( err < 0 ) goto __error ; err = snd_usb_create_mixer ( chip , ifnum , ignore_ctl_error ) ; if ( err < 0 ) goto __error ; } err = snd_card_register ( chip -> card ) ; if ( err < 0 ) goto __error ; usb_chip [ chip -> index ] = chip ; chip -> num_interfaces ++ ; usb_set_intfdata ( intf , chip ) ; atomic_dec ( & chip -> active ) ; mutex_unlock ( & register_mutex ) ; return 0 ; __error : if ( chip ) { <S2SV_StartBug> if ( ! chip -> num_interfaces ) <S2SV_EndBug> snd_card_free ( chip -> card ) ; <S2SV_StartBug> atomic_dec ( & chip -> active ) ; <S2SV_EndBug> } mutex_unlock ( & register_mutex ) ; return err ; }\n",
      "fixed_code": "<S2SV_ModStart> chip ) { atomic_dec ( & chip -> active ) ; <S2SV_ModStart> card ) ; <S2SV_ModEnd> } mutex_unlock (\n",
      "source_code_length": 3063,
      "target_code_length": 115,
      "vulnerability_patterns": {
        "integer_overflow": 3,
        "null_pointer": 30,
        "sql_injection": 1,
        "total": 34
      },
      "total_patterns": 34,
      "original_address": "https://github.com/torvalds/linux/commit/5f8cf712582617d523120df67d392059eaf2fc4b",
      "discovery_time": "2018-12-03T17:29Z",
      "project_commit_id": "torvalds@linux/5f8cf712582617d523120df67d392059eaf2fc4b",
      "extraction_time": "2025-08-31T15:41:49.188738",
      "label": 1,
      "vulnerability_type": "use_after_free",
      "difficulty_level": "advanced",
      "risk_factors": [
        "system_crash",
        "denial_of_service",
        "memory_corruption",
        "sql_injection"
      ],
      "attack_vectors": [
        "memory_manipulation",
        "null_pointer",
        "code_analysis",
        "reverse_engineering",
        "use_after_free",
        "fuzzing"
      ],
      "mitigation_strategies": [
        "null_pointer_checks",
        "fuzzing",
        "dynamic_analysis",
        "memory_management",
        "static_analysis",
        "use_after_free_prevention",
        "code_review",
        "secure_coding_practices"
      ],
      "code_differences": {
        "has_differences": true,
        "source_lines": 2,
        "target_lines": 2,
        "character_differences": 2948,
        "similarity_percentage": 10.434782608695652
      },
      "vulnerability_location": {
        "vulnerability_present": true,
        "fix_applied": true,
        "code_changed": true,
        "estimated_lines_changed": 0
      }
    },
    {
      "cve_id": "CVE-2017-13686",
      "cwe_id": "CWE-476",
      "cwe_name": "NULL Pointer Dereference",
      "project": "torvalds",
      "severity": "critical",
      "weaponization_score": 7.5,
      "is_critical": true,
      "is_weaponizable": true,
      "is_high_priority_project": false,
      "vulnerable_code": "CWE-476 static int inet_rtm_getroute ( struct sk_buff * in_skb , struct nlmsghdr * nlh , struct netlink_ext_ack * extack ) { struct net * net = sock_net ( in_skb -> sk ) ; struct rtmsg * rtm ; struct nlattr * tb [ RTA_MAX + 1 ] ; struct fib_result res = { } ; struct rtable * rt = NULL ; struct flowi4 fl4 ; __be32 dst = 0 ; __be32 src = 0 ; u32 iif ; int err ; int mark ; struct sk_buff * skb ; u32 table_id = RT_TABLE_MAIN ; kuid_t uid ; err = nlmsg_parse ( nlh , sizeof ( * rtm ) , tb , RTA_MAX , rtm_ipv4_policy , extack ) ; if ( err < 0 ) goto errout ; rtm = nlmsg_data ( nlh ) ; skb = alloc_skb ( NLMSG_GOODSIZE , GFP_KERNEL ) ; if ( ! skb ) { err = - ENOBUFS ; goto errout ; } skb_reset_mac_header ( skb ) ; skb_reset_network_header ( skb ) ; src = tb [ RTA_SRC ] ? nla_get_in_addr ( tb [ RTA_SRC ] ) : 0 ; dst = tb [ RTA_DST ] ? nla_get_in_addr ( tb [ RTA_DST ] ) : 0 ; iif = tb [ RTA_IIF ] ? nla_get_u32 ( tb [ RTA_IIF ] ) : 0 ; mark = tb [ RTA_MARK ] ? nla_get_u32 ( tb [ RTA_MARK ] ) : 0 ; if ( tb [ RTA_UID ] ) uid = make_kuid ( current_user_ns ( ) , nla_get_u32 ( tb [ RTA_UID ] ) ) ; else uid = ( iif ? INVALID_UID : current_uid ( ) ) ; ip_hdr ( skb ) -> protocol = IPPROTO_UDP ; ip_hdr ( skb ) -> saddr = src ; ip_hdr ( skb ) -> daddr = dst ; skb_reserve ( skb , MAX_HEADER + sizeof ( struct iphdr ) ) ; memset ( & fl4 , 0 , sizeof ( fl4 ) ) ; fl4 . daddr = dst ; fl4 . saddr = src ; fl4 . flowi4_tos = rtm -> rtm_tos ; fl4 . flowi4_oif = tb [ RTA_OIF ] ? nla_get_u32 ( tb [ RTA_OIF ] ) : 0 ; fl4 . flowi4_mark = mark ; fl4 . flowi4_uid = uid ; rcu_read_lock ( ) ; if ( iif ) { struct net_device * dev ; dev = dev_get_by_index_rcu ( net , iif ) ; if ( ! dev ) { err = - ENODEV ; goto errout_free ; } skb -> protocol = htons ( ETH_P_IP ) ; skb -> dev = dev ; skb -> mark = mark ; err = ip_route_input_rcu ( skb , dst , src , rtm -> rtm_tos , dev , & res ) ; rt = skb_rtable ( skb ) ; if ( err == 0 && rt -> dst . error ) err = - rt -> dst . error ; } else { rt = ip_route_output_key_hash_rcu ( net , & fl4 , & res , skb ) ; err = 0 ; if ( IS_ERR ( rt ) ) err = PTR_ERR ( rt ) ; else skb_dst_set ( skb , & rt -> dst ) ; } if ( err ) goto errout_free ; if ( rtm -> rtm_flags & RTM_F_NOTIFY ) rt -> rt_flags |= RTCF_NOTIFY ; if ( rtm -> rtm_flags & RTM_F_LOOKUP_TABLE ) table_id = rt -> rt_table_id ; if ( rtm -> rtm_flags & RTM_F_FIB_MATCH ) <S2SV_StartBug> err = fib_dump_info ( skb , NETLINK_CB ( in_skb ) . portid , <S2SV_EndBug> nlh -> nlmsg_seq , RTM_NEWROUTE , table_id , rt -> rt_type , res . prefix , res . prefixlen , fl4 . flowi4_tos , res . fi , 0 ) ; else err = rt_fill_info ( net , dst , src , table_id , & fl4 , skb , NETLINK_CB ( in_skb ) . portid , nlh -> nlmsg_seq ) ; if ( err < 0 ) goto errout_free ; <S2SV_StartBug> rcu_read_unlock ( ) ; <S2SV_EndBug> err = rtnl_unicast ( skb , net , NETLINK_CB ( in_skb ) . portid ) ; errout : return err ; errout_free : rcu_read_unlock ( ) ; kfree_skb ( skb ) ; goto errout ; }\n",
      "fixed_code": "<S2SV_ModStart> & RTM_F_FIB_MATCH ) { if ( ! res . fi ) { err = fib_props [ res . type ] . error ; if ( ! err ) err = - EHOSTUNREACH ; <S2SV_ModEnd> goto errout_free ; <S2SV_ModStart> goto errout_free ; } err = fib_dump_info ( skb , NETLINK_CB ( in_skb ) . portid , nlh -> nlmsg_seq , RTM_NEWROUTE , table_id , rt -> rt_type , res . prefix , res . prefixlen , fl4 . flowi4_tos , res . fi , 0 ) ; } else { err = rt_fill_info ( net , dst , src , table_id , & fl4 , skb , NETLINK_CB ( in_skb ) . portid , nlh -> nlmsg_seq ) ; } if ( err < 0 ) goto errout_free ;\n",
      "source_code_length": 2946,
      "target_code_length": 559,
      "vulnerability_patterns": {
        "buffer_overflow": 1,
        "null_pointer": 24,
        "total": 25
      },
      "total_patterns": 25,
      "original_address": "https://github.com/torvalds/linux/commit/bc3aae2bbac46dd894c89db5d5e98f7f0ef9e205",
      "discovery_time": "2017-08-24T22:29Z",
      "project_commit_id": "torvalds@linux/bc3aae2bbac46dd894c89db5d5e98f7f0ef9e205",
      "extraction_time": "2025-08-31T15:41:49.188777",
      "label": 1,
      "vulnerability_type": "null_pointer_dereference",
      "difficulty_level": "advanced",
      "risk_factors": [
        "system_crash",
        "denial_of_service",
        "memory_corruption",
        "buffer_overflow"
      ],
      "attack_vectors": [
        "memory_manipulation",
        "null_pointer",
        "code_analysis",
        "reverse_engineering",
        "use_after_free",
        "fuzzing"
      ],
      "mitigation_strategies": [
        "null_pointer_checks",
        "fuzzing",
        "dynamic_analysis",
        "memory_management",
        "static_analysis",
        "use_after_free_prevention",
        "code_review",
        "secure_coding_practices"
      ],
      "code_differences": {
        "has_differences": true,
        "source_lines": 2,
        "target_lines": 2,
        "character_differences": 2387,
        "similarity_percentage": 30.344827586206897
      },
      "vulnerability_location": {
        "vulnerability_present": true,
        "fix_applied": true,
        "code_changed": true,
        "estimated_lines_changed": 0
      }
    },
    {
      "cve_id": "CVE-2011-1080",
      "cwe_id": "CWE-20",
      "cwe_name": "Improper Input Validation",
      "project": "torvalds",
      "severity": "critical",
      "weaponization_score": 7.5,
      "is_critical": true,
      "is_weaponizable": true,
      "is_high_priority_project": false,
      "vulnerable_code": "CWE-20 static int do_replace ( struct net * net , const void __user * user , unsigned int len ) { int ret , countersize ; struct ebt_table_info * newinfo ; struct ebt_replace tmp ; if ( copy_from_user ( & tmp , user , sizeof ( tmp ) ) != 0 ) return - EFAULT ; if ( len != sizeof ( tmp ) + tmp . entries_size ) { BUGPRINT ( \"Wrong<S2SV_blank>len<S2SV_blank>argument\\\\n\" ) ; return - EINVAL ; } if ( tmp . entries_size == 0 ) { BUGPRINT ( \"Entries_size<S2SV_blank>never<S2SV_blank>zero\\\\n\" ) ; return - EINVAL ; } if ( tmp . nentries >= ( ( INT_MAX - sizeof ( struct ebt_table_info ) ) / NR_CPUS - SMP_CACHE_BYTES ) / sizeof ( struct ebt_counter ) ) return - ENOMEM ; if ( tmp . num_counters >= INT_MAX / sizeof ( struct ebt_counter ) ) return - ENOMEM ; <S2SV_StartBug> countersize = COUNTER_OFFSET ( tmp . nentries ) * nr_cpu_ids ; <S2SV_EndBug> newinfo = vmalloc ( sizeof ( * newinfo ) + countersize ) ; if ( ! newinfo ) return - ENOMEM ; if ( countersize ) memset ( newinfo -> counters , 0 , countersize ) ; newinfo -> entries = vmalloc ( tmp . entries_size ) ; if ( ! newinfo -> entries ) { ret = - ENOMEM ; goto free_newinfo ; } if ( copy_from_user ( newinfo -> entries , tmp . entries , tmp . entries_size ) != 0 ) { BUGPRINT ( \"Couldn\\'t<S2SV_blank>copy<S2SV_blank>entries<S2SV_blank>from<S2SV_blank>userspace\\\\n\" ) ; ret = - EFAULT ; goto free_entries ; } ret = do_replace_finish ( net , & tmp , newinfo ) ; if ( ret == 0 ) return ret ; free_entries : vfree ( newinfo -> entries ) ; free_newinfo : vfree ( newinfo ) ; return ret ; }\n",
      "fixed_code": "<S2SV_ModStart> - ENOMEM ; tmp . name [ sizeof ( tmp . name ) - 1 ] = 0 ;\n",
      "source_code_length": 1540,
      "target_code_length": 74,
      "vulnerability_patterns": {
        "buffer_overflow": 1,
        "use_after_free": 13,
        "null_pointer": 7,
        "total": 21
      },
      "total_patterns": 21,
      "original_address": "https://github.com/torvalds/linux/commit/d846f71195d57b0bbb143382647c2c6638b04c5a",
      "discovery_time": "2012-06-21T23:55Z",
      "project_commit_id": "torvalds@linux/d846f71195d57b0bbb143382647c2c6638b04c5a",
      "extraction_time": "2025-08-31T15:41:49.188833",
      "label": 1,
      "vulnerability_type": "improper_input_validation",
      "difficulty_level": "advanced",
      "risk_factors": [
        "buffer_overflow",
        "use_after_free"
      ],
      "attack_vectors": [
        "fuzzing",
        "code_analysis",
        "reverse_engineering"
      ],
      "mitigation_strategies": [
        "dynamic_analysis",
        "static_analysis",
        "fuzzing",
        "code_review",
        "secure_coding_practices"
      ],
      "code_differences": {
        "has_differences": true,
        "source_lines": 2,
        "target_lines": 2,
        "character_differences": 1466,
        "similarity_percentage": 13.513513513513514
      },
      "vulnerability_location": {
        "vulnerability_present": true,
        "fix_applied": true,
        "code_changed": true,
        "estimated_lines_changed": 0
      }
    },
    {
      "cve_id": "CVE-2017-7374",
      "cwe_id": "CWE-476",
      "cwe_name": "NULL Pointer Dereference",
      "project": "torvalds",
      "severity": "critical",
      "weaponization_score": 7.5,
      "is_critical": true,
      "is_weaponizable": true,
      "is_high_priority_project": false,
      "vulnerable_code": "CWE-476 int fscrypt_setup_filename ( struct inode * dir , const struct qstr * iname , int lookup , struct fscrypt_name * fname ) { int ret = 0 , bigname = 0 ; memset ( fname , 0 , sizeof ( struct fscrypt_name ) ) ; fname -> usr_fname = iname ; if ( ! dir -> i_sb -> s_cop -> is_encrypted ( dir ) || fscrypt_is_dot_dotdot ( iname ) ) { fname -> disk_name . name = ( unsigned char * ) iname -> name ; fname -> disk_name . len = iname -> len ; return 0 ; } <S2SV_StartBug> ret = fscrypt_get_crypt_info ( dir ) ; <S2SV_EndBug> if ( ret && ret != - EOPNOTSUPP ) return ret ; if ( dir -> i_crypt_info ) { ret = fscrypt_fname_alloc_buffer ( dir , iname -> len , & fname -> crypto_buf ) ; if ( ret ) return ret ; ret = fname_encrypt ( dir , iname , & fname -> crypto_buf ) ; if ( ret ) goto errout ; fname -> disk_name . name = fname -> crypto_buf . name ; fname -> disk_name . len = fname -> crypto_buf . len ; return 0 ; } if ( ! lookup ) return - ENOKEY ; if ( iname -> name [ 0 ] == '_' ) bigname = 1 ; if ( ( bigname && ( iname -> len != 33 ) ) || ( ! bigname && ( iname -> len > 43 ) ) ) return - ENOENT ; fname -> crypto_buf . name = kmalloc ( 32 , GFP_KERNEL ) ; if ( fname -> crypto_buf . name == NULL ) return - ENOMEM ; ret = digest_decode ( iname -> name + bigname , iname -> len - bigname , fname -> crypto_buf . name ) ; if ( ret < 0 ) { ret = - ENOENT ; goto errout ; } fname -> crypto_buf . len = ret ; if ( bigname ) { memcpy ( & fname -> hash , fname -> crypto_buf . name , 4 ) ; memcpy ( & fname -> minor_hash , fname -> crypto_buf . name + 4 , 4 ) ; } else { fname -> disk_name . name = fname -> crypto_buf . name ; fname -> disk_name . len = fname -> crypto_buf . len ; } return 0 ; errout : fscrypt_fname_free_buffer ( & fname -> crypto_buf ) ; return ret ; }\n",
      "fixed_code": "<S2SV_ModStart> } ret = fscrypt_get_encryption_info <S2SV_ModEnd> ( dir )\n",
      "source_code_length": 1774,
      "target_code_length": 74,
      "vulnerability_patterns": {
        "buffer_overflow": 3,
        "null_pointer": 36,
        "memory_leak": 1,
        "total": 40
      },
      "total_patterns": 40,
      "original_address": "https://github.com/torvalds/linux/commit/1b53cf9815bb4744958d41f3795d5d5a1d365e2d",
      "discovery_time": "2017-03-31T20:59Z",
      "project_commit_id": "torvalds@linux/1b53cf9815bb4744958d41f3795d5d5a1d365e2d",
      "extraction_time": "2025-08-31T15:41:49.188868",
      "label": 1,
      "vulnerability_type": "null_pointer_dereference",
      "difficulty_level": "advanced",
      "risk_factors": [
        "system_crash",
        "denial_of_service",
        "memory_corruption",
        "buffer_overflow"
      ],
      "attack_vectors": [
        "memory_manipulation",
        "null_pointer",
        "code_analysis",
        "reverse_engineering",
        "use_after_free",
        "fuzzing"
      ],
      "mitigation_strategies": [
        "null_pointer_checks",
        "fuzzing",
        "dynamic_analysis",
        "memory_management",
        "static_analysis",
        "use_after_free_prevention",
        "code_review",
        "secure_coding_practices"
      ],
      "code_differences": {
        "has_differences": true,
        "source_lines": 2,
        "target_lines": 2,
        "character_differences": 1700,
        "similarity_percentage": 7.228915662650602
      },
      "vulnerability_location": {
        "vulnerability_present": true,
        "fix_applied": true,
        "code_changed": true,
        "estimated_lines_changed": 0
      }
    },
    {
      "cve_id": "CVE-2016-1541",
      "cwe_id": "CWE-20",
      "cwe_name": "Improper Input Validation",
      "project": "libarchive",
      "severity": "critical",
      "weaponization_score": 7.5,
      "is_critical": true,
      "is_weaponizable": true,
      "is_high_priority_project": false,
      "vulnerable_code": "CWE-20 static int zip_read_mac_metadata ( struct archive_read * a , struct archive_entry * entry , struct zip_entry * rsrc ) { struct zip * zip = ( struct zip * ) a -> format -> data ; unsigned char * metadata , * mp ; int64_t offset = archive_filter_bytes ( & a -> archive , 0 ) ; size_t remaining_bytes , metadata_bytes ; ssize_t hsize ; int ret = ARCHIVE_OK , eof ; switch ( rsrc -> compression ) { <S2SV_StartBug> case 0 : <S2SV_EndBug> # ifdef HAVE_ZLIB_H case 8 : # endif break ; default : archive_set_error ( & a -> archive , ARCHIVE_ERRNO_FILE_FORMAT , \"Unsupported<S2SV_blank>ZIP<S2SV_blank>compression<S2SV_blank>method<S2SV_blank>(%s)\" , compression_name ( rsrc -> compression ) ) ; return ( ARCHIVE_WARN ) ; } if ( rsrc -> uncompressed_size > ( 4 * 1024 * 1024 ) ) { archive_set_error ( & a -> archive , ARCHIVE_ERRNO_FILE_FORMAT , \"Mac<S2SV_blank>metadata<S2SV_blank>is<S2SV_blank>too<S2SV_blank>large:<S2SV_blank>%jd<S2SV_blank>><S2SV_blank>4M<S2SV_blank>bytes\" , <S2SV_StartBug> ( intmax_t ) rsrc -> uncompressed_size ) ; <S2SV_EndBug> return ( ARCHIVE_WARN ) ; } metadata = malloc ( ( size_t ) rsrc -> uncompressed_size ) ; if ( metadata == NULL ) { archive_set_error ( & a -> archive , ENOMEM , \"Can\\'t<S2SV_blank>allocate<S2SV_blank>memory<S2SV_blank>for<S2SV_blank>Mac<S2SV_blank>metadata\" ) ; return ( ARCHIVE_FATAL ) ; } if ( offset < rsrc -> local_header_offset ) __archive_read_consume ( a , rsrc -> local_header_offset - offset ) ; else if ( offset != rsrc -> local_header_offset ) { __archive_read_seek ( a , rsrc -> local_header_offset , SEEK_SET ) ; } hsize = zip_get_local_file_header_size ( a , 0 ) ; __archive_read_consume ( a , hsize ) ; remaining_bytes = ( size_t ) rsrc -> compressed_size ; metadata_bytes = ( size_t ) rsrc -> uncompressed_size ; mp = metadata ; eof = 0 ; while ( ! eof && remaining_bytes ) { const unsigned char * p ; ssize_t bytes_avail ; size_t bytes_used ; p = __archive_read_ahead ( a , 1 , & bytes_avail ) ; if ( p == NULL ) { archive_set_error ( & a -> archive , ARCHIVE_ERRNO_FILE_FORMAT , \"Truncated<S2SV_blank>ZIP<S2SV_blank>file<S2SV_blank>header\" ) ; ret = ARCHIVE_WARN ; goto exit_mac_metadata ; } if ( ( size_t ) bytes_avail > remaining_bytes ) bytes_avail = remaining_bytes ; switch ( rsrc -> compression ) { case 0 : <S2SV_StartBug> memcpy ( mp , p , bytes_avail ) ; <S2SV_EndBug> bytes_used = ( size_t ) bytes_avail ; metadata_bytes -= bytes_used ; mp += bytes_used ; if ( metadata_bytes == 0 ) eof = 1 ; break ; # ifdef HAVE_ZLIB_H case 8 : { int r ; ret = zip_deflate_init ( a , zip ) ; if ( ret != ARCHIVE_OK ) goto exit_mac_metadata ; zip -> stream . next_in = ( Bytef * ) ( uintptr_t ) ( const void * ) p ; zip -> stream . avail_in = ( uInt ) bytes_avail ; zip -> stream . total_in = 0 ; zip -> stream . next_out = mp ; zip -> stream . avail_out = ( uInt ) metadata_bytes ; zip -> stream . total_out = 0 ; r = inflate ( & zip -> stream , 0 ) ; switch ( r ) { case Z_OK : break ; case Z_STREAM_END : eof = 1 ; break ; case Z_MEM_ERROR : archive_set_error ( & a -> archive , ENOMEM , \"Out<S2SV_blank>of<S2SV_blank>memory<S2SV_blank>for<S2SV_blank>ZIP<S2SV_blank>decompression\" ) ; ret = ARCHIVE_FATAL ; goto exit_mac_metadata ; default : archive_set_error ( & a -> archive , ARCHIVE_ERRNO_MISC , \"ZIP<S2SV_blank>decompression<S2SV_blank>failed<S2SV_blank>(%d)\" , r ) ; ret = ARCHIVE_FATAL ; goto exit_mac_metadata ; } bytes_used = zip -> stream . total_in ; metadata_bytes -= zip -> stream . total_out ; mp += zip -> stream . total_out ; break ; } # endif default : bytes_used = 0 ; break ; } __archive_read_consume ( a , bytes_used ) ; remaining_bytes -= bytes_used ; } archive_entry_copy_mac_metadata ( entry , metadata , ( size_t ) rsrc -> uncompressed_size - metadata_bytes ) ; exit_mac_metadata : __archive_read_seek ( a , offset , SEEK_SET ) ; zip -> decompress_init = 0 ; free ( metadata ) ; return ( ret ) ; }\n",
      "fixed_code": "<S2SV_ModStart> case 0 : if ( rsrc -> uncompressed_size != rsrc -> compressed_size ) { archive_set_error ( & a -> archive , ARCHIVE_ERRNO_FILE_FORMAT , \"Malformed<S2SV_blank>OS<S2SV_blank>X<S2SV_blank>metadata<S2SV_blank>entry:<S2SV_blank>inconsistent<S2SV_blank>size\" ) ; return ( ARCHIVE_FATAL ) ; } <S2SV_ModStart> rsrc -> uncompressed_size ) ; return ( ARCHIVE_WARN ) ; } if ( rsrc -> compressed_size > ( 4 * 1024 * 1024 ) ) { archive_set_error ( & a -> archive , ARCHIVE_ERRNO_FILE_FORMAT , \"Mac<S2SV_blank>metadata<S2SV_blank>is<S2SV_blank>too<S2SV_blank>large:<S2SV_blank>%jd<S2SV_blank>><S2SV_blank>4M<S2SV_blank>bytes\" , ( intmax_t ) rsrc -> compressed_size <S2SV_ModStart> case 0 : if ( ( size_t ) bytes_avail > metadata_bytes ) bytes_avail = metadata_bytes ;\n",
      "source_code_length": 3888,
      "target_code_length": 770,
      "vulnerability_patterns": {
        "buffer_overflow": 1,
        "use_after_free": 2,
        "integer_overflow": 5,
        "null_pointer": 35,
        "memory_leak": 1,
        "total": 44
      },
      "total_patterns": 44,
      "original_address": "https://github.com/libarchive/libarchive/commit/d0331e8e5b05b475f20b1f3101fe1ad772d7e7e7",
      "discovery_time": "2016-05-07T10:59Z",
      "project_commit_id": "libarchive@libarchive/d0331e8e5b05b475f20b1f3101fe1ad772d7e7e7",
      "extraction_time": "2025-08-31T15:41:49.188908",
      "label": 1,
      "vulnerability_type": "improper_input_validation",
      "difficulty_level": "advanced",
      "risk_factors": [
        "buffer_overflow",
        "use_after_free"
      ],
      "attack_vectors": [
        "fuzzing",
        "code_analysis",
        "reverse_engineering"
      ],
      "mitigation_strategies": [
        "dynamic_analysis",
        "static_analysis",
        "fuzzing",
        "code_review",
        "secure_coding_practices"
      ],
      "code_differences": {
        "has_differences": true,
        "source_lines": 2,
        "target_lines": 2,
        "character_differences": 3118,
        "similarity_percentage": 26.61290322580645
      },
      "vulnerability_location": {
        "vulnerability_present": true,
        "fix_applied": true,
        "code_changed": true,
        "estimated_lines_changed": 0
      }
    },
    {
      "cve_id": "CVE-2016-8646",
      "cwe_id": "CWE-476",
      "cwe_name": "NULL Pointer Dereference",
      "project": "torvalds",
      "severity": "critical",
      "weaponization_score": 7.5,
      "is_critical": true,
      "is_weaponizable": true,
      "is_high_priority_project": false,
      "vulnerable_code": "CWE-476 static int hash_accept ( struct socket * sock , struct socket * newsock , int flags ) { struct sock * sk = sock -> sk ; struct alg_sock * ask = alg_sk ( sk ) ; struct hash_ctx * ctx = ask -> private ; struct ahash_request * req = & ctx -> req ; char state [ crypto_ahash_statesize ( crypto_ahash_reqtfm ( req ) ) ] ; struct sock * sk2 ; struct alg_sock * ask2 ; struct hash_ctx * ctx2 ; <S2SV_StartBug> int err ; <S2SV_EndBug> <S2SV_StartBug> err = crypto_ahash_export ( req , state ) ; <S2SV_EndBug> if ( err ) return err ; err = af_alg_accept ( ask -> parent , newsock ) ; if ( err ) return err ; sk2 = newsock -> sk ; ask2 = alg_sk ( sk2 ) ; ctx2 = ask2 -> private ; <S2SV_StartBug> ctx2 -> more = 1 ; <S2SV_EndBug> err = crypto_ahash_import ( & ctx2 -> req , state ) ; if ( err ) { sock_orphan ( sk2 ) ; sock_put ( sk2 ) ; } return err ; }\n",
      "fixed_code": "<S2SV_ModStart> * ctx2 ; bool more ; <S2SV_ModStart> int err ; lock_sock ( sk ) ; more = ctx -> more ; err = more ? <S2SV_ModEnd> crypto_ahash_export ( req <S2SV_ModStart> , state ) : 0 ; release_sock ( sk ) <S2SV_ModStart> -> more = more ; if ( ! more ) return err <S2SV_ModEnd> ; err =\n",
      "source_code_length": 852,
      "target_code_length": 288,
      "vulnerability_patterns": {
        "use_after_free": 3,
        "null_pointer": 8,
        "total": 11
      },
      "total_patterns": 11,
      "original_address": "https://github.com/torvalds/linux/commit/4afa5f9617927453ac04b24b584f6c718dfb4f45",
      "discovery_time": "2016-11-28T03:59Z",
      "project_commit_id": "torvalds@linux/4afa5f9617927453ac04b24b584f6c718dfb4f45",
      "extraction_time": "2025-08-31T15:41:49.188967",
      "label": 1,
      "vulnerability_type": "null_pointer_dereference",
      "difficulty_level": "advanced",
      "risk_factors": [
        "system_crash",
        "denial_of_service",
        "memory_corruption",
        "use_after_free"
      ],
      "attack_vectors": [
        "memory_manipulation",
        "null_pointer",
        "code_analysis",
        "reverse_engineering",
        "use_after_free",
        "fuzzing"
      ],
      "mitigation_strategies": [
        "null_pointer_checks",
        "fuzzing",
        "dynamic_analysis",
        "memory_management",
        "static_analysis",
        "use_after_free_prevention",
        "code_review",
        "secure_coding_practices"
      ],
      "code_differences": {
        "has_differences": true,
        "source_lines": 2,
        "target_lines": 2,
        "character_differences": 564,
        "similarity_percentage": 30.508474576271187
      },
      "vulnerability_location": {
        "vulnerability_present": true,
        "fix_applied": true,
        "code_changed": true,
        "estimated_lines_changed": 0
      }
    },
    {
      "cve_id": "CVE-2018-1066",
      "cwe_id": "CWE-476",
      "cwe_name": "NULL Pointer Dereference",
      "project": "torvalds",
      "severity": "critical",
      "weaponization_score": 7.5,
      "is_critical": true,
      "is_weaponizable": true,
      "is_high_priority_project": false,
      "vulnerable_code": "CWE-476 static int SMB2_sess_establish_session ( struct SMB2_sess_data * sess_data ) { int rc = 0 ; struct cifs_ses * ses = sess_data -> ses ; mutex_lock ( & ses -> server -> srv_mutex ) ; <S2SV_StartBug> if ( ses -> server -> sign && ses -> server -> ops -> generate_signingkey ) { <S2SV_EndBug> <S2SV_StartBug> rc = ses -> server -> ops -> generate_signingkey ( ses ) ; <S2SV_EndBug> kfree ( ses -> auth_key . response ) ; ses -> auth_key . response = NULL ; if ( rc ) { cifs_dbg ( FYI , \"SMB3<S2SV_blank>session<S2SV_blank>key<S2SV_blank>generation<S2SV_blank>failed\\\\n\" ) ; mutex_unlock ( & ses -> server -> srv_mutex ) ; <S2SV_StartBug> goto keygen_exit ; <S2SV_EndBug> } } if ( ! ses -> server -> session_estab ) { ses -> server -> sequence_number = 0x2 ; ses -> server -> session_estab = true ; } mutex_unlock ( & ses -> server -> srv_mutex ) ; cifs_dbg ( FYI , \"SMB2/3<S2SV_blank>session<S2SV_blank>established<S2SV_blank>successfully\\\\n\" ) ; spin_lock ( & GlobalMid_Lock ) ; ses -> status = CifsGood ; ses -> need_reconnect = false ; spin_unlock ( & GlobalMid_Lock ) ; <S2SV_StartBug> keygen_exit : <S2SV_EndBug> if ( ! ses -> server -> sign ) { kfree ( ses -> auth_key . response ) ; ses -> auth_key . response = NULL ; } return rc ; }\n",
      "fixed_code": "<S2SV_ModStart> -> server -> <S2SV_ModEnd> ops -> generate_signingkey <S2SV_ModStart> ( ses ) <S2SV_ModEnd> ; if ( <S2SV_ModStart> srv_mutex ) ; return rc <S2SV_ModEnd> ; } } <S2SV_ModStart> GlobalMid_Lock ) ; <S2SV_ModEnd> return rc ;\n",
      "source_code_length": 1246,
      "target_code_length": 236,
      "vulnerability_patterns": {
        "use_after_free": 2,
        "null_pointer": 29,
        "total": 31
      },
      "total_patterns": 31,
      "original_address": "https://github.com/torvalds/linux/commit/cabfb3680f78981d26c078a26e5c748531257ebb",
      "discovery_time": "2018-03-02T08:29Z",
      "project_commit_id": "torvalds@linux/cabfb3680f78981d26c078a26e5c748531257ebb",
      "extraction_time": "2025-08-31T15:41:49.189003",
      "label": 1,
      "vulnerability_type": "null_pointer_dereference",
      "difficulty_level": "advanced",
      "risk_factors": [
        "system_crash",
        "denial_of_service",
        "memory_corruption",
        "use_after_free"
      ],
      "attack_vectors": [
        "memory_manipulation",
        "null_pointer",
        "code_analysis",
        "reverse_engineering",
        "use_after_free",
        "fuzzing"
      ],
      "mitigation_strategies": [
        "null_pointer_checks",
        "fuzzing",
        "dynamic_analysis",
        "memory_management",
        "static_analysis",
        "use_after_free_prevention",
        "code_review",
        "secure_coding_practices"
      ],
      "code_differences": {
        "has_differences": true,
        "source_lines": 2,
        "target_lines": 2,
        "character_differences": 1010,
        "similarity_percentage": 23.728813559322035
      },
      "vulnerability_location": {
        "vulnerability_present": true,
        "fix_applied": true,
        "code_changed": true,
        "estimated_lines_changed": 0
      }
    },
    {
      "cve_id": "CVE-2018-16391",
      "cwe_id": "CWE-119",
      "cwe_name": "Buffer Overflow",
      "project": "OpenSC",
      "severity": "critical",
      "weaponization_score": 7.4,
      "is_critical": true,
      "is_weaponizable": true,
      "is_high_priority_project": false,
      "vulnerable_code": "CWE-119 static int tcos_select_file ( sc_card_t * card , const sc_path_t * in_path , sc_file_t * * file_out ) { sc_context_t * ctx ; sc_apdu_t apdu ; sc_file_t * file = NULL ; u8 buf [ SC_MAX_APDU_BUFFER_SIZE ] , pathbuf [ SC_MAX_PATH_SIZE ] , * path = pathbuf ; unsigned int i ; int r , pathlen ; assert ( card != NULL && in_path != NULL ) ; ctx = card -> ctx ; memcpy ( path , in_path -> value , in_path -> len ) ; pathlen = in_path -> len ; sc_format_apdu ( card , & apdu , SC_APDU_CASE_4_SHORT , 0xA4 , 0 , 0x04 ) ; switch ( in_path -> type ) { case SC_PATH_TYPE_FILE_ID : if ( pathlen != 2 ) return SC_ERROR_INVALID_ARGUMENTS ; case SC_PATH_TYPE_FROM_CURRENT : apdu . p1 = 9 ; break ; case SC_PATH_TYPE_DF_NAME : apdu . p1 = 4 ; break ; case SC_PATH_TYPE_PATH : apdu . p1 = 8 ; if ( pathlen >= 2 && memcmp ( path , \"\\\\x3F\\\\x00\" , 2 ) == 0 ) path += 2 , pathlen -= 2 ; if ( pathlen == 0 ) apdu . p1 = 0 ; break ; case SC_PATH_TYPE_PARENT : apdu . p1 = 3 ; pathlen = 0 ; break ; default : SC_FUNC_RETURN ( ctx , SC_LOG_DEBUG_VERBOSE , SC_ERROR_INVALID_ARGUMENTS ) ; } if ( pathlen == 0 ) apdu . cse = SC_APDU_CASE_2_SHORT ; apdu . lc = pathlen ; apdu . data = path ; apdu . datalen = pathlen ; if ( file_out != NULL ) { apdu . resp = buf ; apdu . resplen = sizeof ( buf ) ; apdu . le = 256 ; } else { apdu . resplen = 0 ; apdu . le = 0 ; apdu . p2 = 0x0C ; apdu . cse = ( pathlen == 0 ) ? SC_APDU_CASE_1 : SC_APDU_CASE_3_SHORT ; } r = sc_transmit_apdu ( card , & apdu ) ; SC_TEST_RET ( ctx , SC_LOG_DEBUG_NORMAL , r , \"APDU<S2SV_blank>transmit<S2SV_blank>failed\" ) ; r = sc_check_sw ( card , apdu . sw1 , apdu . sw2 ) ; if ( r || file_out == NULL ) SC_FUNC_RETURN ( ctx , SC_LOG_DEBUG_VERBOSE , r ) ; if ( apdu . resplen < 1 || apdu . resp [ 0 ] != 0x62 ) { sc_debug ( ctx , SC_LOG_DEBUG_NORMAL , \"received<S2SV_blank>invalid<S2SV_blank>template<S2SV_blank>%02X\\\\n\" , apdu . resp [ 0 ] ) ; SC_FUNC_RETURN ( ctx , SC_LOG_DEBUG_VERBOSE , SC_ERROR_UNKNOWN_DATA_RECEIVED ) ; } file = sc_file_new ( ) ; if ( file == NULL ) SC_FUNC_RETURN ( ctx , SC_LOG_DEBUG_NORMAL , SC_ERROR_OUT_OF_MEMORY ) ; * file_out = file ; file -> path = * in_path ; for ( i = 2 ; i + 1 < apdu . resplen && i + 1 + apdu . resp [ i + 1 ] < apdu . resplen ; i += 2 + apdu . resp [ i + 1 ] ) { <S2SV_StartBug> int j , len = apdu . resp [ i + 1 ] ; <S2SV_EndBug> unsigned char type = apdu . resp [ i ] , * d = apdu . resp + i + 2 ; switch ( type ) { case 0x80 : case 0x81 : file -> size = 0 ; for ( j = 0 ; j < len ; ++ j ) file -> size = ( file -> size << 8 ) | d [ j ] ; break ; case 0x82 : file -> shareable = ( d [ 0 ] & 0x40 ) ? 1 : 0 ; file -> ef_structure = d [ 0 ] & 7 ; switch ( ( d [ 0 ] >> 3 ) & 7 ) { case 0 : file -> type = SC_FILE_TYPE_WORKING_EF ; break ; case 7 : file -> type = SC_FILE_TYPE_DF ; break ; default : sc_debug ( ctx , SC_LOG_DEBUG_NORMAL , \"invalid<S2SV_blank>file<S2SV_blank>type<S2SV_blank>%02X<S2SV_blank>in<S2SV_blank>file<S2SV_blank>descriptor\\\\n\" , d [ 0 ] ) ; SC_FUNC_RETURN ( ctx , SC_LOG_DEBUG_VERBOSE , SC_ERROR_UNKNOWN_DATA_RECEIVED ) ; } break ; case 0x83 : file -> id = ( d [ 0 ] << 8 ) | d [ 1 ] ; break ; case 0x84 : <S2SV_StartBug> memcpy ( file -> name , d , len ) ; <S2SV_EndBug> <S2SV_StartBug> file -> namelen = len ; <S2SV_EndBug> break ; case 0x86 : sc_file_set_sec_attr ( file , d , len ) ; break ; default : if ( len > 0 ) sc_file_set_prop_attr ( file , d , len ) ; } } file -> magic = SC_FILE_MAGIC ; parse_sec_attr ( card , file , file -> sec_attr , file -> sec_attr_len ) ; return 0 ; }\n",
      "fixed_code": "<S2SV_ModStart> ] ) { size_t <S2SV_ModEnd> j , len <S2SV_ModStart> case 0x84 : file -> namelen = MIN ( sizeof file -> name , len ) ; <S2SV_ModStart> , d , <S2SV_ModEnd> file -> namelen <S2SV_ModStart> file -> namelen ) <S2SV_ModEnd> ; break ;\n",
      "source_code_length": 3513,
      "target_code_length": 243,
      "vulnerability_patterns": {
        "integer_overflow": 2,
        "format_string": 3,
        "null_pointer": 2,
        "sql_injection": 1,
        "total": 8
      },
      "total_patterns": 8,
      "original_address": "https://github.com/OpenSC/OpenSC/commit/360e95d45ac4123255a4c796db96337f332160ad#diff-477b7a40136bb418b10ce271c8664536",
      "discovery_time": "2018-09-03T14:29Z",
      "project_commit_id": "OpenSC@OpenSC/360e95d45ac4123255a4c796db96337f332160ad",
      "extraction_time": "2025-08-31T15:41:49.189024",
      "label": 1,
      "vulnerability_type": "buffer_overflow",
      "difficulty_level": "advanced",
      "risk_factors": [
        "system_crash",
        "memory_corruption",
        "sql_injection",
        "arbitrary_code_execution"
      ],
      "attack_vectors": [
        "memory_manipulation",
        "malicious_input",
        "code_analysis",
        "buffer_overflow",
        "reverse_engineering",
        "fuzzing"
      ],
      "mitigation_strategies": [
        "safe_string_functions",
        "dynamic_analysis",
        "code_review",
        "static_analysis",
        "memory_safety_checks",
        "input_validation",
        "fuzzing",
        "bounds_checking",
        "secure_coding_practices"
      ],
      "code_differences": {
        "has_differences": true,
        "source_lines": 2,
        "target_lines": 2,
        "character_differences": 3270,
        "similarity_percentage": 12.582781456953644
      },
      "vulnerability_location": {
        "vulnerability_present": true,
        "fix_applied": true,
        "code_changed": true,
        "estimated_lines_changed": 0
      }
    },
    {
      "cve_id": "CVE-2016-2347",
      "cwe_id": "CWE-190",
      "cwe_name": "Integer Overflow",
      "project": "fragglet",
      "severity": "critical",
      "weaponization_score": 7.4,
      "is_critical": true,
      "is_weaponizable": true,
      "is_high_priority_project": false,
      "vulnerable_code": "CWE-190 static int decode_level3_header ( LHAFileHeader * * header , LHAInputStream * stream ) { unsigned int header_len ; if ( lha_decode_uint16 ( & RAW_DATA ( header , 0 ) ) != 4 ) { return 0 ; } if ( ! extend_raw_data ( header , stream , LEVEL_3_HEADER_LEN - RAW_DATA_LEN ( header ) ) ) { return 0 ; } header_len = lha_decode_uint32 ( & RAW_DATA ( header , 24 ) ) ; <S2SV_StartBug> if ( header_len > LEVEL_3_MAX_HEADER_LEN ) { <S2SV_EndBug> return 0 ; } if ( ! extend_raw_data ( header , stream , header_len - RAW_DATA_LEN ( header ) ) ) { return 0 ; } memcpy ( ( * header ) -> compress_method , & RAW_DATA ( header , 2 ) , 5 ) ; ( * header ) -> compress_method [ 5 ] = '\\\\0' ; ( * header ) -> compressed_length = lha_decode_uint32 ( & RAW_DATA ( header , 7 ) ) ; ( * header ) -> length = lha_decode_uint32 ( & RAW_DATA ( header , 11 ) ) ; ( * header ) -> timestamp = lha_decode_uint32 ( & RAW_DATA ( header , 15 ) ) ; ( * header ) -> crc = lha_decode_uint16 ( & RAW_DATA ( header , 21 ) ) ; ( * header ) -> os_type = RAW_DATA ( header , 23 ) ; if ( ! decode_extended_headers ( header , 28 ) ) { return 0 ; } return 1 ; }\n",
      "fixed_code": "<S2SV_ModStart> header_len > LEVEL_3_MAX_HEADER_LEN || header_len < RAW_DATA_LEN ( header )\n",
      "source_code_length": 1125,
      "target_code_length": 92,
      "vulnerability_patterns": {
        "buffer_overflow": 1,
        "null_pointer": 7,
        "total": 8
      },
      "total_patterns": 8,
      "original_address": "https://github.com/fragglet/lhasa/commit/6fcdb8f1f538b9d63e63a5fa199c5514a15d4564",
      "discovery_time": "2017-04-21T20:59Z",
      "project_commit_id": "fragglet@lhasa/6fcdb8f1f538b9d63e63a5fa199c5514a15d4564",
      "extraction_time": "2025-08-31T15:41:49.189074",
      "label": 1,
      "vulnerability_type": "integer_overflow",
      "difficulty_level": "advanced",
      "risk_factors": [
        "information_disclosure",
        "memory_corruption",
        "integer_overflow",
        "buffer_overflow"
      ],
      "attack_vectors": [
        "fuzzing",
        "code_analysis",
        "reverse_engineering"
      ],
      "mitigation_strategies": [
        "dynamic_analysis",
        "static_analysis",
        "fuzzing",
        "code_review",
        "secure_coding_practices"
      ],
      "code_differences": {
        "has_differences": true,
        "source_lines": 2,
        "target_lines": 2,
        "character_differences": 1033,
        "similarity_percentage": 11.475409836065573
      },
      "vulnerability_location": {
        "vulnerability_present": true,
        "fix_applied": true,
        "code_changed": true,
        "estimated_lines_changed": 0
      }
    },
    {
      "cve_id": "CVE-2016-1621",
      "cwe_id": "CWE-119",
      "cwe_name": "Buffer Overflow",
      "project": "external",
      "severity": "critical",
      "weaponization_score": 7.3,
      "is_critical": true,
      "is_weaponizable": true,
      "is_high_priority_project": false,
      "vulnerable_code": "CWE-119 int main ( int argc , char * * argv ) { int frame_cnt = 0 ; FILE * outfile = NULL ; vpx_codec_ctx_t codec ; const VpxInterface * decoder = NULL ; VpxVideoReader * reader = NULL ; const VpxVideoInfo * info = NULL ; int n = 0 ; int m = 0 ; int is_range = 0 ; char * nptr = NULL ; exec_name = argv [ 0 ] ; if ( argc != 4 ) die ( \"Invalid<S2SV_blank>number<S2SV_blank>of<S2SV_blank>arguments.\" ) ; reader = vpx_video_reader_open ( argv [ 1 ] ) ; if ( ! reader ) die ( \"Failed<S2SV_blank>to<S2SV_blank>open<S2SV_blank>%s<S2SV_blank>for<S2SV_blank>reading.\" , argv [ 1 ] ) ; if ( ! ( outfile = fopen ( argv [ 2 ] , \"wb\" ) ) ) die ( \"Failed<S2SV_blank>to<S2SV_blank>open<S2SV_blank>%s<S2SV_blank>for<S2SV_blank>writing.\" , argv [ 2 ] ) ; n = strtol ( argv [ 3 ] , & nptr , 0 ) ; m = strtol ( nptr + 1 , NULL , 0 ) ; is_range = ( * nptr == '-' ) ; if ( ! n || ! m || ( * nptr != '-' && * nptr != '/' ) ) die ( \"Couldn\\'t<S2SV_blank>parse<S2SV_blank>pattern<S2SV_blank>%s.\\\\n\" , argv [ 3 ] ) ; info = vpx_video_reader_get_info ( reader ) ; decoder = get_vpx_decoder_by_fourcc ( info -> codec_fourcc ) ; if ( ! decoder ) die ( \"Unknown<S2SV_blank>input<S2SV_blank>codec.\" ) ; <S2SV_StartBug> printf ( \"Using<S2SV_blank>%s\\\\n\" , vpx_codec_iface_name ( decoder -> interface ( ) ) ) ; <S2SV_EndBug> <S2SV_StartBug> if ( vpx_codec_dec_init ( & codec , decoder -> interface ( ) , NULL , 0 ) ) <S2SV_EndBug> die_codec ( & codec , \"Failed<S2SV_blank>to<S2SV_blank>initialize<S2SV_blank>decoder.\" ) ; while ( vpx_video_reader_read_frame ( reader ) ) { vpx_codec_iter_t iter = NULL ; vpx_image_t * img = NULL ; size_t frame_size = 0 ; int skip ; const unsigned char * frame = vpx_video_reader_get_frame ( reader , & frame_size ) ; if ( vpx_codec_decode ( & codec , frame , ( unsigned int ) frame_size , NULL , 0 ) ) die_codec ( & codec , \"Failed<S2SV_blank>to<S2SV_blank>decode<S2SV_blank>frame.\" ) ; ++ frame_cnt ; skip = ( is_range && frame_cnt >= n && frame_cnt <= m ) || ( ! is_range && m - ( frame_cnt - 1 ) % m <= n ) ; if ( ! skip ) { putc ( '.' , stdout ) ; while ( ( img = vpx_codec_get_frame ( & codec , & iter ) ) != NULL ) vpx_img_write ( img , outfile ) ; } else { putc ( 'X' , stdout ) ; } fflush ( stdout ) ; } printf ( \"Processed<S2SV_blank>%d<S2SV_blank>frames.\\\\n\" , frame_cnt ) ; if ( vpx_codec_destroy ( & codec ) ) die_codec ( & codec , \"Failed<S2SV_blank>to<S2SV_blank>destroy<S2SV_blank>codec.\" ) ; printf ( \"Play:<S2SV_blank>ffplay<S2SV_blank>-f<S2SV_blank>rawvideo<S2SV_blank>-pix_fmt<S2SV_blank>yuv420p<S2SV_blank>-s<S2SV_blank>%dx%d<S2SV_blank>%s\\\\n\" , info -> frame_width , info -> frame_height , argv [ 2 ] ) ; vpx_video_reader_close ( reader ) ; fclose ( outfile ) ; return EXIT_SUCCESS ; }\n",
      "fixed_code": "<S2SV_ModStart> ( decoder -> codec_interface <S2SV_ModEnd> ( ) ) <S2SV_ModStart> , decoder -> codec_interface <S2SV_ModEnd> ( ) ,\n",
      "source_code_length": 2710,
      "target_code_length": 130,
      "vulnerability_patterns": {
        "buffer_overflow": 2,
        "null_pointer": 4,
        "total": 6
      },
      "total_patterns": 6,
      "original_address": "https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426",
      "discovery_time": "2016-03-12T21:59Z",
      "project_commit_id": "external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426",
      "extraction_time": "2025-08-31T15:41:49.189090",
      "label": 1,
      "vulnerability_type": "buffer_overflow",
      "difficulty_level": "advanced",
      "risk_factors": [
        "system_crash",
        "memory_corruption",
        "buffer_overflow",
        "arbitrary_code_execution"
      ],
      "attack_vectors": [
        "memory_manipulation",
        "malicious_input",
        "code_analysis",
        "buffer_overflow",
        "reverse_engineering",
        "fuzzing"
      ],
      "mitigation_strategies": [
        "safe_string_functions",
        "dynamic_analysis",
        "code_review",
        "static_analysis",
        "memory_safety_checks",
        "input_validation",
        "fuzzing",
        "bounds_checking",
        "secure_coding_practices"
      ],
      "code_differences": {
        "has_differences": true,
        "source_lines": 2,
        "target_lines": 2,
        "character_differences": 2580,
        "similarity_percentage": 4.464285714285714
      },
      "vulnerability_location": {
        "vulnerability_present": true,
        "fix_applied": true,
        "code_changed": true,
        "estimated_lines_changed": 0
      }
    },
    {
      "cve_id": "CVE-2016-1621",
      "cwe_id": "CWE-119",
      "cwe_name": "Buffer Overflow",
      "project": "external",
      "severity": "critical",
      "weaponization_score": 7.3,
      "is_critical": true,
      "is_weaponizable": true,
      "is_high_priority_project": false,
      "vulnerable_code": "CWE-119 int main ( int argc , char * * argv ) { int frame_cnt = 0 ; FILE * outfile = NULL ; vpx_codec_ctx_t codec ; const VpxInterface * decoder = NULL ; VpxVideoReader * reader = NULL ; const VpxVideoInfo * info = NULL ; int n = 0 ; int m = 0 ; int is_range = 0 ; char * nptr = NULL ; exec_name = argv [ 0 ] ; if ( argc != 4 ) die ( \"Invalid<S2SV_blank>number<S2SV_blank>of<S2SV_blank>arguments.\" ) ; reader = vpx_video_reader_open ( argv [ 1 ] ) ; if ( ! reader ) die ( \"Failed<S2SV_blank>to<S2SV_blank>open<S2SV_blank>%s<S2SV_blank>for<S2SV_blank>reading.\" , argv [ 1 ] ) ; if ( ! ( outfile = fopen ( argv [ 2 ] , \"wb\" ) ) ) die ( \"Failed<S2SV_blank>to<S2SV_blank>open<S2SV_blank>%s<S2SV_blank>for<S2SV_blank>writing.\" , argv [ 2 ] ) ; n = strtol ( argv [ 3 ] , & nptr , 0 ) ; m = strtol ( nptr + 1 , NULL , 0 ) ; is_range = ( * nptr == '-' ) ; if ( ! n || ! m || ( * nptr != '-' && * nptr != '/' ) ) die ( \"Couldn\\'t<S2SV_blank>parse<S2SV_blank>pattern<S2SV_blank>%s.\\\\n\" , argv [ 3 ] ) ; info = vpx_video_reader_get_info ( reader ) ; decoder = get_vpx_decoder_by_fourcc ( info -> codec_fourcc ) ; if ( ! decoder ) die ( \"Unknown<S2SV_blank>input<S2SV_blank>codec.\" ) ; <S2SV_StartBug> printf ( \"Using<S2SV_blank>%s\\\\n\" , vpx_codec_iface_name ( decoder -> interface ( ) ) ) ; <S2SV_EndBug> <S2SV_StartBug> if ( vpx_codec_dec_init ( & codec , decoder -> interface ( ) , NULL , 0 ) ) <S2SV_EndBug> die_codec ( & codec , \"Failed<S2SV_blank>to<S2SV_blank>initialize<S2SV_blank>decoder.\" ) ; while ( vpx_video_reader_read_frame ( reader ) ) { vpx_codec_iter_t iter = NULL ; vpx_image_t * img = NULL ; size_t frame_size = 0 ; int skip ; const unsigned char * frame = vpx_video_reader_get_frame ( reader , & frame_size ) ; if ( vpx_codec_decode ( & codec , frame , ( unsigned int ) frame_size , NULL , 0 ) ) die_codec ( & codec , \"Failed<S2SV_blank>to<S2SV_blank>decode<S2SV_blank>frame.\" ) ; ++ frame_cnt ; skip = ( is_range && frame_cnt >= n && frame_cnt <= m ) || ( ! is_range && m - ( frame_cnt - 1 ) % m <= n ) ; if ( ! skip ) { putc ( '.' , stdout ) ; while ( ( img = vpx_codec_get_frame ( & codec , & iter ) ) != NULL ) vpx_img_write ( img , outfile ) ; } else { putc ( 'X' , stdout ) ; } fflush ( stdout ) ; } printf ( \"Processed<S2SV_blank>%d<S2SV_blank>frames.\\\\n\" , frame_cnt ) ; if ( vpx_codec_destroy ( & codec ) ) die_codec ( & codec , \"Failed<S2SV_blank>to<S2SV_blank>destroy<S2SV_blank>codec.\" ) ; printf ( \"Play:<S2SV_blank>ffplay<S2SV_blank>-f<S2SV_blank>rawvideo<S2SV_blank>-pix_fmt<S2SV_blank>yuv420p<S2SV_blank>-s<S2SV_blank>%dx%d<S2SV_blank>%s\\\\n\" , info -> frame_width , info -> frame_height , argv [ 2 ] ) ; vpx_video_reader_close ( reader ) ; fclose ( outfile ) ; return EXIT_SUCCESS ; }\n",
      "fixed_code": "<S2SV_ModStart> ( decoder -> codec_interface <S2SV_ModEnd> ( ) ) <S2SV_ModStart> , decoder -> codec_interface <S2SV_ModEnd> ( ) ,\n",
      "source_code_length": 2710,
      "target_code_length": 130,
      "vulnerability_patterns": {
        "buffer_overflow": 1,
        "integer_overflow": 3,
        "null_pointer": 2,
        "total": 6
      },
      "total_patterns": 6,
      "original_address": "https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426",
      "discovery_time": "2016-03-12T21:59Z",
      "project_commit_id": "external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426",
      "extraction_time": "2025-08-31T15:41:49.189115",
      "label": 1,
      "vulnerability_type": "buffer_overflow",
      "difficulty_level": "advanced",
      "risk_factors": [
        "system_crash",
        "memory_corruption",
        "buffer_overflow",
        "arbitrary_code_execution"
      ],
      "attack_vectors": [
        "memory_manipulation",
        "malicious_input",
        "code_analysis",
        "buffer_overflow",
        "reverse_engineering",
        "fuzzing"
      ],
      "mitigation_strategies": [
        "safe_string_functions",
        "dynamic_analysis",
        "code_review",
        "static_analysis",
        "memory_safety_checks",
        "input_validation",
        "fuzzing",
        "bounds_checking",
        "secure_coding_practices"
      ],
      "code_differences": {
        "has_differences": true,
        "source_lines": 2,
        "target_lines": 2,
        "character_differences": 2580,
        "similarity_percentage": 4.464285714285714
      },
      "vulnerability_location": {
        "vulnerability_present": true,
        "fix_applied": true,
        "code_changed": true,
        "estimated_lines_changed": 0
      }
    },
    {
      "cve_id": "CVE-2016-1621",
      "cwe_id": "CWE-119",
      "cwe_name": "Buffer Overflow",
      "project": "external",
      "severity": "critical",
      "weaponization_score": 7.3,
      "is_critical": true,
      "is_weaponizable": true,
      "is_high_priority_project": false,
      "vulnerable_code": "CWE-119 int main ( int argc , char * * argv ) { int frame_cnt = 0 ; FILE * outfile = NULL ; vpx_codec_ctx_t codec ; const VpxInterface * decoder = NULL ; VpxVideoReader * reader = NULL ; const VpxVideoInfo * info = NULL ; int n = 0 ; int m = 0 ; int is_range = 0 ; char * nptr = NULL ; exec_name = argv [ 0 ] ; if ( argc != 4 ) die ( \"Invalid<S2SV_blank>number<S2SV_blank>of<S2SV_blank>arguments.\" ) ; reader = vpx_video_reader_open ( argv [ 1 ] ) ; if ( ! reader ) die ( \"Failed<S2SV_blank>to<S2SV_blank>open<S2SV_blank>%s<S2SV_blank>for<S2SV_blank>reading.\" , argv [ 1 ] ) ; if ( ! ( outfile = fopen ( argv [ 2 ] , \"wb\" ) ) ) die ( \"Failed<S2SV_blank>to<S2SV_blank>open<S2SV_blank>%s<S2SV_blank>for<S2SV_blank>writing.\" , argv [ 2 ] ) ; n = strtol ( argv [ 3 ] , & nptr , 0 ) ; m = strtol ( nptr + 1 , NULL , 0 ) ; is_range = ( * nptr == '-' ) ; if ( ! n || ! m || ( * nptr != '-' && * nptr != '/' ) ) die ( \"Couldn\\'t<S2SV_blank>parse<S2SV_blank>pattern<S2SV_blank>%s.\\\\n\" , argv [ 3 ] ) ; info = vpx_video_reader_get_info ( reader ) ; decoder = get_vpx_decoder_by_fourcc ( info -> codec_fourcc ) ; if ( ! decoder ) die ( \"Unknown<S2SV_blank>input<S2SV_blank>codec.\" ) ; <S2SV_StartBug> printf ( \"Using<S2SV_blank>%s\\\\n\" , vpx_codec_iface_name ( decoder -> interface ( ) ) ) ; <S2SV_EndBug> <S2SV_StartBug> if ( vpx_codec_dec_init ( & codec , decoder -> interface ( ) , NULL , 0 ) ) <S2SV_EndBug> die_codec ( & codec , \"Failed<S2SV_blank>to<S2SV_blank>initialize<S2SV_blank>decoder.\" ) ; while ( vpx_video_reader_read_frame ( reader ) ) { vpx_codec_iter_t iter = NULL ; vpx_image_t * img = NULL ; size_t frame_size = 0 ; int skip ; const unsigned char * frame = vpx_video_reader_get_frame ( reader , & frame_size ) ; if ( vpx_codec_decode ( & codec , frame , ( unsigned int ) frame_size , NULL , 0 ) ) die_codec ( & codec , \"Failed<S2SV_blank>to<S2SV_blank>decode<S2SV_blank>frame.\" ) ; ++ frame_cnt ; skip = ( is_range && frame_cnt >= n && frame_cnt <= m ) || ( ! is_range && m - ( frame_cnt - 1 ) % m <= n ) ; if ( ! skip ) { putc ( '.' , stdout ) ; while ( ( img = vpx_codec_get_frame ( & codec , & iter ) ) != NULL ) vpx_img_write ( img , outfile ) ; } else { putc ( 'X' , stdout ) ; } fflush ( stdout ) ; } printf ( \"Processed<S2SV_blank>%d<S2SV_blank>frames.\\\\n\" , frame_cnt ) ; if ( vpx_codec_destroy ( & codec ) ) die_codec ( & codec , \"Failed<S2SV_blank>to<S2SV_blank>destroy<S2SV_blank>codec.\" ) ; printf ( \"Play:<S2SV_blank>ffplay<S2SV_blank>-f<S2SV_blank>rawvideo<S2SV_blank>-pix_fmt<S2SV_blank>yuv420p<S2SV_blank>-s<S2SV_blank>%dx%d<S2SV_blank>%s\\\\n\" , info -> frame_width , info -> frame_height , argv [ 2 ] ) ; vpx_video_reader_close ( reader ) ; fclose ( outfile ) ; return EXIT_SUCCESS ; }\n",
      "fixed_code": "<S2SV_ModStart> ( decoder -> codec_interface <S2SV_ModEnd> ( ) ) <S2SV_ModStart> , decoder -> codec_interface <S2SV_ModEnd> ( ) ,\n",
      "source_code_length": 2710,
      "target_code_length": 130,
      "vulnerability_patterns": {
        "use_after_free": 2,
        "integer_overflow": 1,
        "null_pointer": 2,
        "memory_leak": 1,
        "total": 6
      },
      "total_patterns": 6,
      "original_address": "https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426",
      "discovery_time": "2016-03-12T21:59Z",
      "project_commit_id": "external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426",
      "extraction_time": "2025-08-31T15:41:49.189132",
      "label": 1,
      "vulnerability_type": "buffer_overflow",
      "difficulty_level": "advanced",
      "risk_factors": [
        "system_crash",
        "memory_corruption",
        "arbitrary_code_execution",
        "use_after_free"
      ],
      "attack_vectors": [
        "memory_manipulation",
        "malicious_input",
        "code_analysis",
        "buffer_overflow",
        "reverse_engineering",
        "fuzzing"
      ],
      "mitigation_strategies": [
        "safe_string_functions",
        "dynamic_analysis",
        "code_review",
        "static_analysis",
        "memory_safety_checks",
        "input_validation",
        "fuzzing",
        "bounds_checking",
        "secure_coding_practices"
      ],
      "code_differences": {
        "has_differences": true,
        "source_lines": 2,
        "target_lines": 2,
        "character_differences": 2580,
        "similarity_percentage": 4.464285714285714
      },
      "vulnerability_location": {
        "vulnerability_present": true,
        "fix_applied": true,
        "code_changed": true,
        "estimated_lines_changed": 0
      }
    },
    {
      "cve_id": "CVE-2016-5356",
      "cwe_id": "CWE-119",
      "cwe_name": "Buffer Overflow",
      "project": "wireshark",
      "severity": "critical",
      "weaponization_score": 7.2,
      "is_critical": true,
      "is_weaponizable": true,
      "is_high_priority_project": true,
      "vulnerable_code": "CWE-119 static gboolean parse_cosine_packet ( FILE_T fh , struct wtap_pkthdr * phdr , Buffer * buf , char * line , int * err , gchar * * err_info ) { union wtap_pseudo_header * pseudo_header = & phdr -> pseudo_header ; int num_items_scanned ; <S2SV_StartBug> int yy , mm , dd , hr , min , sec , csec ; <S2SV_EndBug> guint pkt_len ; int pro , off , pri , rm , error ; guint code1 , code2 ; char if_name [ COSINE_MAX_IF_NAME_LEN ] = \"\" , direction [ 6 ] = \"\" ; struct tm tm ; guint8 * pd ; int i , hex_lines , n , caplen = 0 ; if ( sscanf ( line , \"%4d-%2d-%2d,%2d:%2d:%2d.%9d:\" , & yy , & mm , & dd , & hr , & min , & sec , & csec ) == 7 ) { num_items_scanned = sscanf ( line , <S2SV_StartBug> \"%4d-%2d-%2d,%2d:%2d:%2d.%9d:<S2SV_blank>%5s<S2SV_blank>(%127[A-Za-z0-9/:]),<S2SV_blank>Length:%9u,<S2SV_blank>Pro:%9d,<S2SV_blank>Off:%9d,<S2SV_blank>Pri:%9d,<S2SV_blank>RM:%9d,<S2SV_blank>Err:%9d<S2SV_blank>[%8x,<S2SV_blank>%8x]\" , <S2SV_EndBug> & yy , & mm , & dd , & hr , & min , & sec , & csec , direction , if_name , & pkt_len , & pro , & off , & pri , & rm , & error , & code1 , & code2 ) ; if ( num_items_scanned != 17 ) { * err = WTAP_ERR_BAD_FILE ; * err_info = g_strdup ( \"cosine:<S2SV_blank>purported<S2SV_blank>control<S2SV_blank>blade<S2SV_blank>line<S2SV_blank>doesn\\'t<S2SV_blank>have<S2SV_blank>code<S2SV_blank>values\" ) ; return FALSE ; } } else { num_items_scanned = sscanf ( line , <S2SV_StartBug> \"%5s<S2SV_blank>(%127[A-Za-z0-9/:]),<S2SV_blank>Length:%9u,<S2SV_blank>Pro:%9d,<S2SV_blank>Off:%9d,<S2SV_blank>Pri:%9d,<S2SV_blank>RM:%9d,<S2SV_blank>Err:%9d<S2SV_blank>[%8x,<S2SV_blank>%8x]\" , <S2SV_EndBug> direction , if_name , & pkt_len , & pro , & off , & pri , & rm , & error , & code1 , & code2 ) ; if ( num_items_scanned != 10 ) { * err = WTAP_ERR_BAD_FILE ; * err_info = g_strdup ( \"cosine:<S2SV_blank>header<S2SV_blank>line<S2SV_blank>is<S2SV_blank>neither<S2SV_blank>control<S2SV_blank>blade<S2SV_blank>nor<S2SV_blank>PE<S2SV_blank>output\" ) ; return FALSE ; } <S2SV_StartBug> yy = mm = dd = hr = min = sec = csec = 0 ; <S2SV_EndBug> } if ( pkt_len > WTAP_MAX_PACKET_SIZE ) { * err = WTAP_ERR_BAD_FILE ; * err_info = g_strdup_printf ( \"cosine:<S2SV_blank>File<S2SV_blank>has<S2SV_blank>%u-byte<S2SV_blank>packet,<S2SV_blank>bigger<S2SV_blank>than<S2SV_blank>maximum<S2SV_blank>of<S2SV_blank>%u\" , pkt_len , WTAP_MAX_PACKET_SIZE ) ; return FALSE ; } phdr -> rec_type = REC_TYPE_PACKET ; phdr -> presence_flags = WTAP_HAS_TS | WTAP_HAS_CAP_LEN ; tm . tm_year = yy - 1900 ; tm . tm_mon = mm - 1 ; tm . tm_mday = dd ; tm . tm_hour = hr ; tm . tm_min = min ; tm . tm_sec = sec ; tm . tm_isdst = - 1 ; phdr -> ts . secs = mktime ( & tm ) ; phdr -> ts . nsecs = csec * 10000000 ; phdr -> len = pkt_len ; if ( strncmp ( if_name , \"TEST:\" , 5 ) == 0 ) { pseudo_header -> cosine . encap = COSINE_ENCAP_TEST ; } else if ( strncmp ( if_name , \"PPoATM:\" , 7 ) == 0 ) { pseudo_header -> cosine . encap = COSINE_ENCAP_PPoATM ; } else if ( strncmp ( if_name , \"PPoFR:\" , 6 ) == 0 ) { pseudo_header -> cosine . encap = COSINE_ENCAP_PPoFR ; } else if ( strncmp ( if_name , \"ATM:\" , 4 ) == 0 ) { pseudo_header -> cosine . encap = COSINE_ENCAP_ATM ; } else if ( strncmp ( if_name , \"FR:\" , 3 ) == 0 ) { pseudo_header -> cosine . encap = COSINE_ENCAP_FR ; } else if ( strncmp ( if_name , \"HDLC:\" , 5 ) == 0 ) { pseudo_header -> cosine . encap = COSINE_ENCAP_HDLC ; } else if ( strncmp ( if_name , \"PPP:\" , 4 ) == 0 ) { pseudo_header -> cosine . encap = COSINE_ENCAP_PPP ; } else if ( strncmp ( if_name , \"ETH:\" , 4 ) == 0 ) { pseudo_header -> cosine . encap = COSINE_ENCAP_ETH ; } else { pseudo_header -> cosine . encap = COSINE_ENCAP_UNKNOWN ; } if ( strncmp ( direction , \"l2-tx\" , 5 ) == 0 ) { pseudo_header -> cosine . direction = COSINE_DIR_TX ; } else if ( strncmp ( direction , \"l2-rx\" , 5 ) == 0 ) { pseudo_header -> cosine . direction = COSINE_DIR_RX ; } g_strlcpy ( pseudo_header -> cosine . if_name , if_name , COSINE_MAX_IF_NAME_LEN ) ; pseudo_header -> cosine . pro = pro ; pseudo_header -> cosine . off = off ; pseudo_header -> cosine . pri = pri ; pseudo_header -> cosine . rm = rm ; pseudo_header -> cosine . err = error ; ws_buffer_assure_space ( buf , pkt_len ) ; pd = ws_buffer_start_ptr ( buf ) ; hex_lines = pkt_len / 16 + ( ( pkt_len % 16 ) ? 1 : 0 ) ; for ( i = 0 ; i < hex_lines ; i ++ ) { if ( file_gets ( line , COSINE_LINE_LENGTH , fh ) == NULL ) { * err = file_error ( fh , err_info ) ; if ( * err == 0 ) { * err = WTAP_ERR_SHORT_READ ; } return FALSE ; } if ( empty_line ( line ) ) { break ; } if ( ( n = parse_single_hex_dump_line ( line , pd , i * 16 ) ) == - 1 ) { * err = WTAP_ERR_BAD_FILE ; * err_info = g_strdup ( \"cosine:<S2SV_blank>hex<S2SV_blank>dump<S2SV_blank>line<S2SV_blank>doesn\\'t<S2SV_blank>have<S2SV_blank>16<S2SV_blank>numbers\" ) ; return FALSE ; } caplen += n ; } phdr -> caplen = caplen ; return TRUE ; }\n",
      "fixed_code": "<S2SV_ModStart> sec , csec , <S2SV_ModEnd> pkt_len ; int <S2SV_ModStart> ( line , \"%4d-%2d-%2d,%2d:%2d:%2d.%9d:<S2SV_blank>%5s<S2SV_blank>(%127[A-Za-z0-9/:]),<S2SV_blank>Length:%9d,<S2SV_blank>Pro:%9d,<S2SV_blank>Off:%9d,<S2SV_blank>Pri:%9d,<S2SV_blank>RM:%9d,<S2SV_blank>Err:%9d<S2SV_blank>[%8x,<S2SV_blank>%8x]\" <S2SV_ModEnd> , & yy <S2SV_ModStart> ( line , \"%5s<S2SV_blank>(%127[A-Za-z0-9/:]),<S2SV_blank>Length:%9d,<S2SV_blank>Pro:%9d,<S2SV_blank>Off:%9d,<S2SV_blank>Pri:%9d,<S2SV_blank>RM:%9d,<S2SV_blank>Err:%9d<S2SV_blank>[%8x,<S2SV_blank>%8x]\" <S2SV_ModEnd> , direction , <S2SV_ModStart> csec = 0 ; } if ( pkt_len < 0 ) { * err = WTAP_ERR_BAD_FILE ; * err_info = g_strdup ( \"cosine:<S2SV_blank>packet<S2SV_blank>header<S2SV_blank>has<S2SV_blank>a<S2SV_blank>negative<S2SV_blank>packet<S2SV_blank>length\" ) ; return FALSE\n",
      "source_code_length": 4854,
      "target_code_length": 829,
      "vulnerability_patterns": {
        "null_pointer": 4,
        "total": 4
      },
      "total_patterns": 4,
      "original_address": "https://github.com/wireshark/wireshark/commit/a66628e425db725df1ac52a3c573a03357060ddd",
      "discovery_time": "2016-08-07T16:59Z",
      "project_commit_id": "wireshark@wireshark/a66628e425db725df1ac52a3c573a03357060ddd",
      "extraction_time": "2025-08-31T15:41:49.189150",
      "label": 1,
      "vulnerability_type": "buffer_overflow",
      "difficulty_level": "advanced",
      "risk_factors": [
        "system_crash",
        "memory_corruption",
        "critical_infrastructure",
        "arbitrary_code_execution"
      ],
      "attack_vectors": [
        "memory_manipulation",
        "malicious_input",
        "code_analysis",
        "buffer_overflow",
        "reverse_engineering",
        "fuzzing"
      ],
      "mitigation_strategies": [
        "safe_string_functions",
        "dynamic_analysis",
        "code_review",
        "static_analysis",
        "memory_safety_checks",
        "input_validation",
        "fuzzing",
        "bounds_checking",
        "secure_coding_practices"
      ],
      "code_differences": {
        "has_differences": true,
        "source_lines": 2,
        "target_lines": 2,
        "character_differences": 4025,
        "similarity_percentage": 15.337423312883436
      },
      "vulnerability_location": {
        "vulnerability_present": true,
        "fix_applied": true,
        "code_changed": true,
        "estimated_lines_changed": 0
      }
    },
    {
      "cve_id": "CVE-2016-5356",
      "cwe_id": "CWE-119",
      "cwe_name": "Buffer Overflow",
      "project": "wireshark",
      "severity": "critical",
      "weaponization_score": 7.2,
      "is_critical": true,
      "is_weaponizable": true,
      "is_high_priority_project": true,
      "vulnerable_code": "CWE-119 static gboolean parse_cosine_packet ( FILE_T fh , struct wtap_pkthdr * phdr , Buffer * buf , char * line , int * err , gchar * * err_info ) { union wtap_pseudo_header * pseudo_header = & phdr -> pseudo_header ; int num_items_scanned ; <S2SV_StartBug> int yy , mm , dd , hr , min , sec , csec ; <S2SV_EndBug> guint pkt_len ; int pro , off , pri , rm , error ; guint code1 , code2 ; char if_name [ COSINE_MAX_IF_NAME_LEN ] = \"\" , direction [ 6 ] = \"\" ; struct tm tm ; guint8 * pd ; int i , hex_lines , n , caplen = 0 ; if ( sscanf ( line , \"%4d-%2d-%2d,%2d:%2d:%2d.%9d:\" , & yy , & mm , & dd , & hr , & min , & sec , & csec ) == 7 ) { num_items_scanned = sscanf ( line , <S2SV_StartBug> \"%4d-%2d-%2d,%2d:%2d:%2d.%9d:<S2SV_blank>%5s<S2SV_blank>(%127[A-Za-z0-9/:]),<S2SV_blank>Length:%9u,<S2SV_blank>Pro:%9d,<S2SV_blank>Off:%9d,<S2SV_blank>Pri:%9d,<S2SV_blank>RM:%9d,<S2SV_blank>Err:%9d<S2SV_blank>[%8x,<S2SV_blank>%8x]\" , <S2SV_EndBug> & yy , & mm , & dd , & hr , & min , & sec , & csec , direction , if_name , & pkt_len , & pro , & off , & pri , & rm , & error , & code1 , & code2 ) ; if ( num_items_scanned != 17 ) { * err = WTAP_ERR_BAD_FILE ; * err_info = g_strdup ( \"cosine:<S2SV_blank>purported<S2SV_blank>control<S2SV_blank>blade<S2SV_blank>line<S2SV_blank>doesn\\'t<S2SV_blank>have<S2SV_blank>code<S2SV_blank>values\" ) ; return FALSE ; } } else { num_items_scanned = sscanf ( line , <S2SV_StartBug> \"%5s<S2SV_blank>(%127[A-Za-z0-9/:]),<S2SV_blank>Length:%9u,<S2SV_blank>Pro:%9d,<S2SV_blank>Off:%9d,<S2SV_blank>Pri:%9d,<S2SV_blank>RM:%9d,<S2SV_blank>Err:%9d<S2SV_blank>[%8x,<S2SV_blank>%8x]\" , <S2SV_EndBug> direction , if_name , & pkt_len , & pro , & off , & pri , & rm , & error , & code1 , & code2 ) ; if ( num_items_scanned != 10 ) { * err = WTAP_ERR_BAD_FILE ; * err_info = g_strdup ( \"cosine:<S2SV_blank>header<S2SV_blank>line<S2SV_blank>is<S2SV_blank>neither<S2SV_blank>control<S2SV_blank>blade<S2SV_blank>nor<S2SV_blank>PE<S2SV_blank>output\" ) ; return FALSE ; } <S2SV_StartBug> yy = mm = dd = hr = min = sec = csec = 0 ; <S2SV_EndBug> } if ( pkt_len > WTAP_MAX_PACKET_SIZE ) { * err = WTAP_ERR_BAD_FILE ; * err_info = g_strdup_printf ( \"cosine:<S2SV_blank>File<S2SV_blank>has<S2SV_blank>%u-byte<S2SV_blank>packet,<S2SV_blank>bigger<S2SV_blank>than<S2SV_blank>maximum<S2SV_blank>of<S2SV_blank>%u\" , pkt_len , WTAP_MAX_PACKET_SIZE ) ; return FALSE ; } phdr -> rec_type = REC_TYPE_PACKET ; phdr -> presence_flags = WTAP_HAS_TS | WTAP_HAS_CAP_LEN ; tm . tm_year = yy - 1900 ; tm . tm_mon = mm - 1 ; tm . tm_mday = dd ; tm . tm_hour = hr ; tm . tm_min = min ; tm . tm_sec = sec ; tm . tm_isdst = - 1 ; phdr -> ts . secs = mktime ( & tm ) ; phdr -> ts . nsecs = csec * 10000000 ; phdr -> len = pkt_len ; if ( strncmp ( if_name , \"TEST:\" , 5 ) == 0 ) { pseudo_header -> cosine . encap = COSINE_ENCAP_TEST ; } else if ( strncmp ( if_name , \"PPoATM:\" , 7 ) == 0 ) { pseudo_header -> cosine . encap = COSINE_ENCAP_PPoATM ; } else if ( strncmp ( if_name , \"PPoFR:\" , 6 ) == 0 ) { pseudo_header -> cosine . encap = COSINE_ENCAP_PPoFR ; } else if ( strncmp ( if_name , \"ATM:\" , 4 ) == 0 ) { pseudo_header -> cosine . encap = COSINE_ENCAP_ATM ; } else if ( strncmp ( if_name , \"FR:\" , 3 ) == 0 ) { pseudo_header -> cosine . encap = COSINE_ENCAP_FR ; } else if ( strncmp ( if_name , \"HDLC:\" , 5 ) == 0 ) { pseudo_header -> cosine . encap = COSINE_ENCAP_HDLC ; } else if ( strncmp ( if_name , \"PPP:\" , 4 ) == 0 ) { pseudo_header -> cosine . encap = COSINE_ENCAP_PPP ; } else if ( strncmp ( if_name , \"ETH:\" , 4 ) == 0 ) { pseudo_header -> cosine . encap = COSINE_ENCAP_ETH ; } else { pseudo_header -> cosine . encap = COSINE_ENCAP_UNKNOWN ; } if ( strncmp ( direction , \"l2-tx\" , 5 ) == 0 ) { pseudo_header -> cosine . direction = COSINE_DIR_TX ; } else if ( strncmp ( direction , \"l2-rx\" , 5 ) == 0 ) { pseudo_header -> cosine . direction = COSINE_DIR_RX ; } g_strlcpy ( pseudo_header -> cosine . if_name , if_name , COSINE_MAX_IF_NAME_LEN ) ; pseudo_header -> cosine . pro = pro ; pseudo_header -> cosine . off = off ; pseudo_header -> cosine . pri = pri ; pseudo_header -> cosine . rm = rm ; pseudo_header -> cosine . err = error ; ws_buffer_assure_space ( buf , pkt_len ) ; pd = ws_buffer_start_ptr ( buf ) ; hex_lines = pkt_len / 16 + ( ( pkt_len % 16 ) ? 1 : 0 ) ; for ( i = 0 ; i < hex_lines ; i ++ ) { if ( file_gets ( line , COSINE_LINE_LENGTH , fh ) == NULL ) { * err = file_error ( fh , err_info ) ; if ( * err == 0 ) { * err = WTAP_ERR_SHORT_READ ; } return FALSE ; } if ( empty_line ( line ) ) { break ; } if ( ( n = parse_single_hex_dump_line ( line , pd , i * 16 ) ) == - 1 ) { * err = WTAP_ERR_BAD_FILE ; * err_info = g_strdup ( \"cosine:<S2SV_blank>hex<S2SV_blank>dump<S2SV_blank>line<S2SV_blank>doesn\\'t<S2SV_blank>have<S2SV_blank>16<S2SV_blank>numbers\" ) ; return FALSE ; } caplen += n ; } phdr -> caplen = caplen ; return TRUE ; }\n",
      "fixed_code": "<S2SV_ModStart> sec , csec , <S2SV_ModEnd> pkt_len ; int <S2SV_ModStart> ( line , \"%4d-%2d-%2d,%2d:%2d:%2d.%9d:<S2SV_blank>%5s<S2SV_blank>(%127[A-Za-z0-9/:]),<S2SV_blank>Length:%9d,<S2SV_blank>Pro:%9d,<S2SV_blank>Off:%9d,<S2SV_blank>Pri:%9d,<S2SV_blank>RM:%9d,<S2SV_blank>Err:%9d<S2SV_blank>[%8x,<S2SV_blank>%8x]\" <S2SV_ModEnd> , & yy <S2SV_ModStart> ( line , \"%5s<S2SV_blank>(%127[A-Za-z0-9/:]),<S2SV_blank>Length:%9d,<S2SV_blank>Pro:%9d,<S2SV_blank>Off:%9d,<S2SV_blank>Pri:%9d,<S2SV_blank>RM:%9d,<S2SV_blank>Err:%9d<S2SV_blank>[%8x,<S2SV_blank>%8x]\" <S2SV_ModEnd> , direction , <S2SV_ModStart> csec = 0 ; } if ( pkt_len < 0 ) { * err = WTAP_ERR_BAD_FILE ; * err_info = g_strdup ( \"cosine:<S2SV_blank>packet<S2SV_blank>header<S2SV_blank>has<S2SV_blank>a<S2SV_blank>negative<S2SV_blank>packet<S2SV_blank>length\" ) ; return FALSE\n",
      "source_code_length": 4854,
      "target_code_length": 829,
      "vulnerability_patterns": {
        "null_pointer": 4,
        "total": 4
      },
      "total_patterns": 4,
      "original_address": "https://github.com/wireshark/wireshark/commit/a66628e425db725df1ac52a3c573a03357060ddd",
      "discovery_time": "2016-08-07T16:59Z",
      "project_commit_id": "wireshark@wireshark/a66628e425db725df1ac52a3c573a03357060ddd",
      "extraction_time": "2025-08-31T15:41:49.189195",
      "label": 1,
      "vulnerability_type": "buffer_overflow",
      "difficulty_level": "advanced",
      "risk_factors": [
        "system_crash",
        "memory_corruption",
        "critical_infrastructure",
        "arbitrary_code_execution"
      ],
      "attack_vectors": [
        "memory_manipulation",
        "malicious_input",
        "code_analysis",
        "buffer_overflow",
        "reverse_engineering",
        "fuzzing"
      ],
      "mitigation_strategies": [
        "safe_string_functions",
        "dynamic_analysis",
        "code_review",
        "static_analysis",
        "memory_safety_checks",
        "input_validation",
        "fuzzing",
        "bounds_checking",
        "secure_coding_practices"
      ],
      "code_differences": {
        "has_differences": true,
        "source_lines": 2,
        "target_lines": 2,
        "character_differences": 4025,
        "similarity_percentage": 15.337423312883436
      },
      "vulnerability_location": {
        "vulnerability_present": true,
        "fix_applied": true,
        "code_changed": true,
        "estimated_lines_changed": 0
      }
    },
    {
      "cve_id": "CVE-2016-5356",
      "cwe_id": "CWE-119",
      "cwe_name": "Buffer Overflow",
      "project": "wireshark",
      "severity": "critical",
      "weaponization_score": 7.2,
      "is_critical": true,
      "is_weaponizable": true,
      "is_high_priority_project": true,
      "vulnerable_code": "CWE-119 static gboolean parse_cosine_packet ( FILE_T fh , struct wtap_pkthdr * phdr , Buffer * buf , char * line , int * err , gchar * * err_info ) { union wtap_pseudo_header * pseudo_header = & phdr -> pseudo_header ; int num_items_scanned ; <S2SV_StartBug> int yy , mm , dd , hr , min , sec , csec ; <S2SV_EndBug> guint pkt_len ; int pro , off , pri , rm , error ; guint code1 , code2 ; char if_name [ COSINE_MAX_IF_NAME_LEN ] = \"\" , direction [ 6 ] = \"\" ; struct tm tm ; guint8 * pd ; int i , hex_lines , n , caplen = 0 ; if ( sscanf ( line , \"%4d-%2d-%2d,%2d:%2d:%2d.%9d:\" , & yy , & mm , & dd , & hr , & min , & sec , & csec ) == 7 ) { num_items_scanned = sscanf ( line , <S2SV_StartBug> \"%4d-%2d-%2d,%2d:%2d:%2d.%9d:<S2SV_blank>%5s<S2SV_blank>(%127[A-Za-z0-9/:]),<S2SV_blank>Length:%9u,<S2SV_blank>Pro:%9d,<S2SV_blank>Off:%9d,<S2SV_blank>Pri:%9d,<S2SV_blank>RM:%9d,<S2SV_blank>Err:%9d<S2SV_blank>[%8x,<S2SV_blank>%8x]\" , <S2SV_EndBug> & yy , & mm , & dd , & hr , & min , & sec , & csec , direction , if_name , & pkt_len , & pro , & off , & pri , & rm , & error , & code1 , & code2 ) ; if ( num_items_scanned != 17 ) { * err = WTAP_ERR_BAD_FILE ; * err_info = g_strdup ( \"cosine:<S2SV_blank>purported<S2SV_blank>control<S2SV_blank>blade<S2SV_blank>line<S2SV_blank>doesn\\'t<S2SV_blank>have<S2SV_blank>code<S2SV_blank>values\" ) ; return FALSE ; } } else { num_items_scanned = sscanf ( line , <S2SV_StartBug> \"%5s<S2SV_blank>(%127[A-Za-z0-9/:]),<S2SV_blank>Length:%9u,<S2SV_blank>Pro:%9d,<S2SV_blank>Off:%9d,<S2SV_blank>Pri:%9d,<S2SV_blank>RM:%9d,<S2SV_blank>Err:%9d<S2SV_blank>[%8x,<S2SV_blank>%8x]\" , <S2SV_EndBug> direction , if_name , & pkt_len , & pro , & off , & pri , & rm , & error , & code1 , & code2 ) ; if ( num_items_scanned != 10 ) { * err = WTAP_ERR_BAD_FILE ; * err_info = g_strdup ( \"cosine:<S2SV_blank>header<S2SV_blank>line<S2SV_blank>is<S2SV_blank>neither<S2SV_blank>control<S2SV_blank>blade<S2SV_blank>nor<S2SV_blank>PE<S2SV_blank>output\" ) ; return FALSE ; } <S2SV_StartBug> yy = mm = dd = hr = min = sec = csec = 0 ; <S2SV_EndBug> } if ( pkt_len > WTAP_MAX_PACKET_SIZE ) { * err = WTAP_ERR_BAD_FILE ; * err_info = g_strdup_printf ( \"cosine:<S2SV_blank>File<S2SV_blank>has<S2SV_blank>%u-byte<S2SV_blank>packet,<S2SV_blank>bigger<S2SV_blank>than<S2SV_blank>maximum<S2SV_blank>of<S2SV_blank>%u\" , pkt_len , WTAP_MAX_PACKET_SIZE ) ; return FALSE ; } phdr -> rec_type = REC_TYPE_PACKET ; phdr -> presence_flags = WTAP_HAS_TS | WTAP_HAS_CAP_LEN ; tm . tm_year = yy - 1900 ; tm . tm_mon = mm - 1 ; tm . tm_mday = dd ; tm . tm_hour = hr ; tm . tm_min = min ; tm . tm_sec = sec ; tm . tm_isdst = - 1 ; phdr -> ts . secs = mktime ( & tm ) ; phdr -> ts . nsecs = csec * 10000000 ; phdr -> len = pkt_len ; if ( strncmp ( if_name , \"TEST:\" , 5 ) == 0 ) { pseudo_header -> cosine . encap = COSINE_ENCAP_TEST ; } else if ( strncmp ( if_name , \"PPoATM:\" , 7 ) == 0 ) { pseudo_header -> cosine . encap = COSINE_ENCAP_PPoATM ; } else if ( strncmp ( if_name , \"PPoFR:\" , 6 ) == 0 ) { pseudo_header -> cosine . encap = COSINE_ENCAP_PPoFR ; } else if ( strncmp ( if_name , \"ATM:\" , 4 ) == 0 ) { pseudo_header -> cosine . encap = COSINE_ENCAP_ATM ; } else if ( strncmp ( if_name , \"FR:\" , 3 ) == 0 ) { pseudo_header -> cosine . encap = COSINE_ENCAP_FR ; } else if ( strncmp ( if_name , \"HDLC:\" , 5 ) == 0 ) { pseudo_header -> cosine . encap = COSINE_ENCAP_HDLC ; } else if ( strncmp ( if_name , \"PPP:\" , 4 ) == 0 ) { pseudo_header -> cosine . encap = COSINE_ENCAP_PPP ; } else if ( strncmp ( if_name , \"ETH:\" , 4 ) == 0 ) { pseudo_header -> cosine . encap = COSINE_ENCAP_ETH ; } else { pseudo_header -> cosine . encap = COSINE_ENCAP_UNKNOWN ; } if ( strncmp ( direction , \"l2-tx\" , 5 ) == 0 ) { pseudo_header -> cosine . direction = COSINE_DIR_TX ; } else if ( strncmp ( direction , \"l2-rx\" , 5 ) == 0 ) { pseudo_header -> cosine . direction = COSINE_DIR_RX ; } g_strlcpy ( pseudo_header -> cosine . if_name , if_name , COSINE_MAX_IF_NAME_LEN ) ; pseudo_header -> cosine . pro = pro ; pseudo_header -> cosine . off = off ; pseudo_header -> cosine . pri = pri ; pseudo_header -> cosine . rm = rm ; pseudo_header -> cosine . err = error ; ws_buffer_assure_space ( buf , pkt_len ) ; pd = ws_buffer_start_ptr ( buf ) ; hex_lines = pkt_len / 16 + ( ( pkt_len % 16 ) ? 1 : 0 ) ; for ( i = 0 ; i < hex_lines ; i ++ ) { if ( file_gets ( line , COSINE_LINE_LENGTH , fh ) == NULL ) { * err = file_error ( fh , err_info ) ; if ( * err == 0 ) { * err = WTAP_ERR_SHORT_READ ; } return FALSE ; } if ( empty_line ( line ) ) { break ; } if ( ( n = parse_single_hex_dump_line ( line , pd , i * 16 ) ) == - 1 ) { * err = WTAP_ERR_BAD_FILE ; * err_info = g_strdup ( \"cosine:<S2SV_blank>hex<S2SV_blank>dump<S2SV_blank>line<S2SV_blank>doesn\\'t<S2SV_blank>have<S2SV_blank>16<S2SV_blank>numbers\" ) ; return FALSE ; } caplen += n ; } phdr -> caplen = caplen ; return TRUE ; }\n",
      "fixed_code": "<S2SV_ModStart> sec , csec , <S2SV_ModEnd> pkt_len ; int <S2SV_ModStart> ( line , \"%4d-%2d-%2d,%2d:%2d:%2d.%9d:<S2SV_blank>%5s<S2SV_blank>(%127[A-Za-z0-9/:]),<S2SV_blank>Length:%9d,<S2SV_blank>Pro:%9d,<S2SV_blank>Off:%9d,<S2SV_blank>Pri:%9d,<S2SV_blank>RM:%9d,<S2SV_blank>Err:%9d<S2SV_blank>[%8x,<S2SV_blank>%8x]\" <S2SV_ModEnd> , & yy <S2SV_ModStart> ( line , \"%5s<S2SV_blank>(%127[A-Za-z0-9/:]),<S2SV_blank>Length:%9d,<S2SV_blank>Pro:%9d,<S2SV_blank>Off:%9d,<S2SV_blank>Pri:%9d,<S2SV_blank>RM:%9d,<S2SV_blank>Err:%9d<S2SV_blank>[%8x,<S2SV_blank>%8x]\" <S2SV_ModEnd> , direction , <S2SV_ModStart> csec = 0 ; } if ( pkt_len < 0 ) { * err = WTAP_ERR_BAD_FILE ; * err_info = g_strdup ( \"cosine:<S2SV_blank>packet<S2SV_blank>header<S2SV_blank>has<S2SV_blank>a<S2SV_blank>negative<S2SV_blank>packet<S2SV_blank>length\" ) ; return FALSE\n",
      "source_code_length": 4854,
      "target_code_length": 829,
      "vulnerability_patterns": {
        "null_pointer": 4,
        "total": 4
      },
      "total_patterns": 4,
      "original_address": "https://github.com/wireshark/wireshark/commit/a66628e425db725df1ac52a3c573a03357060ddd",
      "discovery_time": "2016-08-07T16:59Z",
      "project_commit_id": "wireshark@wireshark/a66628e425db725df1ac52a3c573a03357060ddd",
      "extraction_time": "2025-08-31T15:41:49.189229",
      "label": 1,
      "vulnerability_type": "buffer_overflow",
      "difficulty_level": "advanced",
      "risk_factors": [
        "system_crash",
        "memory_corruption",
        "critical_infrastructure",
        "arbitrary_code_execution"
      ],
      "attack_vectors": [
        "memory_manipulation",
        "malicious_input",
        "code_analysis",
        "buffer_overflow",
        "reverse_engineering",
        "fuzzing"
      ],
      "mitigation_strategies": [
        "safe_string_functions",
        "dynamic_analysis",
        "code_review",
        "static_analysis",
        "memory_safety_checks",
        "input_validation",
        "fuzzing",
        "bounds_checking",
        "secure_coding_practices"
      ],
      "code_differences": {
        "has_differences": true,
        "source_lines": 2,
        "target_lines": 2,
        "character_differences": 4025,
        "similarity_percentage": 15.337423312883436
      },
      "vulnerability_location": {
        "vulnerability_present": true,
        "fix_applied": true,
        "code_changed": true,
        "estimated_lines_changed": 0
      }
    },
    {
      "cve_id": "CVE-2018-8789",
      "cwe_id": "CWE-125",
      "cwe_name": "Out-of-bounds Read",
      "project": "FreeRDP",
      "severity": "critical",
      "weaponization_score": 7.1,
      "is_critical": true,
      "is_weaponizable": true,
      "is_high_priority_project": false,
      "vulnerable_code": "CWE-125 <S2SV_StartBug> void ntlm_free_message_fields_buffer ( NTLM_MESSAGE_FIELDS * fields ) <S2SV_EndBug> { if ( fields ) { if ( fields -> Buffer ) { free ( fields -> Buffer ) ; fields -> Len = 0 ; fields -> MaxLen = 0 ; fields -> Buffer = NULL ; fields -> BufferOffset = 0 ; } } }\n",
      "fixed_code": "<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> static\n",
      "source_code_length": 284,
      "target_code_length": 59,
      "vulnerability_patterns": {
        "use_after_free": 1,
        "null_pointer": 6,
        "total": 7
      },
      "total_patterns": 7,
      "original_address": "https://github.com/FreeRDP/FreeRDP/commit/2ee663f39dc8dac3d9988e847db19b2d7e3ac8c6",
      "discovery_time": "2018-11-29T18:29Z",
      "project_commit_id": "FreeRDP@FreeRDP/2ee663f39dc8dac3d9988e847db19b2d7e3ac8c6",
      "extraction_time": "2025-08-31T15:41:49.189258",
      "label": 1,
      "vulnerability_type": "out-of-bounds_read",
      "difficulty_level": "advanced",
      "risk_factors": [
        "information_disclosure",
        "memory_corruption",
        "integer_overflow",
        "use_after_free"
      ],
      "attack_vectors": [
        "memory_manipulation",
        "malicious_input",
        "code_analysis",
        "buffer_overflow",
        "reverse_engineering",
        "fuzzing"
      ],
      "mitigation_strategies": [
        "safe_string_functions",
        "dynamic_analysis",
        "code_review",
        "static_analysis",
        "memory_safety_checks",
        "input_validation",
        "fuzzing",
        "bounds_checking",
        "secure_coding_practices"
      ],
      "code_differences": {
        "has_differences": true,
        "source_lines": 2,
        "target_lines": 2,
        "character_differences": 225,
        "similarity_percentage": 0.0
      },
      "vulnerability_location": {
        "vulnerability_present": true,
        "fix_applied": true,
        "code_changed": true,
        "estimated_lines_changed": 0
      }
    },
    {
      "cve_id": "CVE-2016-9793",
      "cwe_id": "CWE-119",
      "cwe_name": "Buffer Overflow",
      "project": "torvalds",
      "severity": "critical",
      "weaponization_score": 7.0,
      "is_critical": true,
      "is_weaponizable": true,
      "is_high_priority_project": false,
      "vulnerable_code": "CWE-119 int sock_setsockopt ( struct socket * sock , int level , int optname , char __user * optval , unsigned int optlen ) { struct sock * sk = sock -> sk ; int val ; int valbool ; struct linger ling ; int ret = 0 ; if ( optname == SO_BINDTODEVICE ) return sock_setbindtodevice ( sk , optval , optlen ) ; if ( optlen < sizeof ( int ) ) return - EINVAL ; if ( get_user ( val , ( int __user * ) optval ) ) return - EFAULT ; valbool = val ? 1 : 0 ; lock_sock ( sk ) ; switch ( optname ) { case SO_DEBUG : if ( val && ! capable ( CAP_NET_ADMIN ) ) ret = - EACCES ; else sock_valbool_flag ( sk , SOCK_DBG , valbool ) ; break ; case SO_REUSEADDR : sk -> sk_reuse = ( valbool ? SK_CAN_REUSE : SK_NO_REUSE ) ; break ; case SO_REUSEPORT : sk -> sk_reuseport = valbool ; break ; case SO_TYPE : case SO_PROTOCOL : case SO_DOMAIN : case SO_ERROR : ret = - ENOPROTOOPT ; break ; case SO_DONTROUTE : sock_valbool_flag ( sk , SOCK_LOCALROUTE , valbool ) ; break ; case SO_BROADCAST : sock_valbool_flag ( sk , SOCK_BROADCAST , valbool ) ; break ; case SO_SNDBUF : val = min_t ( u32 , val , sysctl_wmem_max ) ; set_sndbuf : sk -> sk_userlocks |= SOCK_SNDBUF_LOCK ; <S2SV_StartBug> sk -> sk_sndbuf = max_t ( u32 , val * 2 , SOCK_MIN_SNDBUF ) ; <S2SV_EndBug> sk -> sk_write_space ( sk ) ; break ; case SO_SNDBUFFORCE : if ( ! capable ( CAP_NET_ADMIN ) ) { ret = - EPERM ; break ; } goto set_sndbuf ; case SO_RCVBUF : val = min_t ( u32 , val , sysctl_rmem_max ) ; set_rcvbuf : sk -> sk_userlocks |= SOCK_RCVBUF_LOCK ; <S2SV_StartBug> sk -> sk_rcvbuf = max_t ( u32 , val * 2 , SOCK_MIN_RCVBUF ) ; <S2SV_EndBug> break ; case SO_RCVBUFFORCE : if ( ! capable ( CAP_NET_ADMIN ) ) { ret = - EPERM ; break ; } goto set_rcvbuf ; case SO_KEEPALIVE : # ifdef CONFIG_INET if ( sk -> sk_protocol == IPPROTO_TCP && sk -> sk_type == SOCK_STREAM ) tcp_set_keepalive ( sk , valbool ) ; # endif sock_valbool_flag ( sk , SOCK_KEEPOPEN , valbool ) ; break ; case SO_OOBINLINE : sock_valbool_flag ( sk , SOCK_URGINLINE , valbool ) ; break ; case SO_NO_CHECK : sk -> sk_no_check_tx = valbool ; break ; case SO_PRIORITY : if ( ( val >= 0 && val <= 6 ) || ns_capable ( sock_net ( sk ) -> user_ns , CAP_NET_ADMIN ) ) sk -> sk_priority = val ; else ret = - EPERM ; break ; case SO_LINGER : if ( optlen < sizeof ( ling ) ) { ret = - EINVAL ; break ; } if ( copy_from_user ( & ling , optval , sizeof ( ling ) ) ) { ret = - EFAULT ; break ; } if ( ! ling . l_onoff ) sock_reset_flag ( sk , SOCK_LINGER ) ; else { # if ( BITS_PER_LONG == 32 ) if ( ( unsigned int ) ling . l_linger >= MAX_SCHEDULE_TIMEOUT / HZ ) sk -> sk_lingertime = MAX_SCHEDULE_TIMEOUT ; else # endif sk -> sk_lingertime = ( unsigned int ) ling . l_linger * HZ ; sock_set_flag ( sk , SOCK_LINGER ) ; } break ; case SO_BSDCOMPAT : sock_warn_obsolete_bsdism ( \"setsockopt\" ) ; break ; case SO_PASSCRED : if ( valbool ) set_bit ( SOCK_PASSCRED , & sock -> flags ) ; else clear_bit ( SOCK_PASSCRED , & sock -> flags ) ; break ; case SO_TIMESTAMP : case SO_TIMESTAMPNS : if ( valbool ) { if ( optname == SO_TIMESTAMP ) sock_reset_flag ( sk , SOCK_RCVTSTAMPNS ) ; else sock_set_flag ( sk , SOCK_RCVTSTAMPNS ) ; sock_set_flag ( sk , SOCK_RCVTSTAMP ) ; sock_enable_timestamp ( sk , SOCK_TIMESTAMP ) ; } else { sock_reset_flag ( sk , SOCK_RCVTSTAMP ) ; sock_reset_flag ( sk , SOCK_RCVTSTAMPNS ) ; } break ; case SO_TIMESTAMPING : if ( val & ~ SOF_TIMESTAMPING_MASK ) { ret = - EINVAL ; break ; } if ( val & SOF_TIMESTAMPING_OPT_ID && ! ( sk -> sk_tsflags & SOF_TIMESTAMPING_OPT_ID ) ) { if ( sk -> sk_protocol == IPPROTO_TCP && sk -> sk_type == SOCK_STREAM ) { if ( ( 1 << sk -> sk_state ) & ( TCPF_CLOSE | TCPF_LISTEN ) ) { ret = - EINVAL ; break ; } sk -> sk_tskey = tcp_sk ( sk ) -> snd_una ; } else { sk -> sk_tskey = 0 ; } } sk -> sk_tsflags = val ; if ( val & SOF_TIMESTAMPING_RX_SOFTWARE ) sock_enable_timestamp ( sk , SOCK_TIMESTAMPING_RX_SOFTWARE ) ; else sock_disable_timestamp ( sk , ( 1UL << SOCK_TIMESTAMPING_RX_SOFTWARE ) ) ; break ; case SO_RCVLOWAT : if ( val < 0 ) val = INT_MAX ; sk -> sk_rcvlowat = val ? : 1 ; break ; case SO_RCVTIMEO : ret = sock_set_timeout ( & sk -> sk_rcvtimeo , optval , optlen ) ; break ; case SO_SNDTIMEO : ret = sock_set_timeout ( & sk -> sk_sndtimeo , optval , optlen ) ; break ; case SO_ATTACH_FILTER : ret = - EINVAL ; if ( optlen == sizeof ( struct sock_fprog ) ) { struct sock_fprog fprog ; ret = - EFAULT ; if ( copy_from_user ( & fprog , optval , sizeof ( fprog ) ) ) break ; ret = sk_attach_filter ( & fprog , sk ) ; } break ; case SO_ATTACH_BPF : ret = - EINVAL ; if ( optlen == sizeof ( u32 ) ) { u32 ufd ; ret = - EFAULT ; if ( copy_from_user ( & ufd , optval , sizeof ( ufd ) ) ) break ; ret = sk_attach_bpf ( ufd , sk ) ; } break ; case SO_ATTACH_REUSEPORT_CBPF : ret = - EINVAL ; if ( optlen == sizeof ( struct sock_fprog ) ) { struct sock_fprog fprog ; ret = - EFAULT ; if ( copy_from_user ( & fprog , optval , sizeof ( fprog ) ) ) break ; ret = sk_reuseport_attach_filter ( & fprog , sk ) ; } break ; case SO_ATTACH_REUSEPORT_EBPF : ret = - EINVAL ; if ( optlen == sizeof ( u32 ) ) { u32 ufd ; ret = - EFAULT ; if ( copy_from_user ( & ufd , optval , sizeof ( ufd ) ) ) break ; ret = sk_reuseport_attach_bpf ( ufd , sk ) ; } break ; case SO_DETACH_FILTER : ret = sk_detach_filter ( sk ) ; break ; case SO_LOCK_FILTER : if ( sock_flag ( sk , SOCK_FILTER_LOCKED ) && ! valbool ) ret = - EPERM ; else sock_valbool_flag ( sk , SOCK_FILTER_LOCKED , valbool ) ; break ; case SO_PASSSEC : if ( valbool ) set_bit ( SOCK_PASSSEC , & sock -> flags ) ; else clear_bit ( SOCK_PASSSEC , & sock -> flags ) ; break ; case SO_MARK : if ( ! ns_capable ( sock_net ( sk ) -> user_ns , CAP_NET_ADMIN ) ) ret = - EPERM ; else sk -> sk_mark = val ; break ; case SO_RXQ_OVFL : sock_valbool_flag ( sk , SOCK_RXQ_OVFL , valbool ) ; break ; case SO_WIFI_STATUS : sock_valbool_flag ( sk , SOCK_WIFI_STATUS , valbool ) ; break ; case SO_PEEK_OFF : if ( sock -> ops -> set_peek_off ) ret = sock -> ops -> set_peek_off ( sk , val ) ; else ret = - EOPNOTSUPP ; break ; case SO_NOFCS : sock_valbool_flag ( sk , SOCK_NOFCS , valbool ) ; break ; case SO_SELECT_ERR_QUEUE : sock_valbool_flag ( sk , SOCK_SELECT_ERR_QUEUE , valbool ) ; break ; # ifdef CONFIG_NET_RX_BUSY_POLL case SO_BUSY_POLL : if ( ( val > sk -> sk_ll_usec ) && ! capable ( CAP_NET_ADMIN ) ) ret = - EPERM ; else { if ( val < 0 ) ret = - EINVAL ; else sk -> sk_ll_usec = val ; } break ; # endif case SO_MAX_PACING_RATE : sk -> sk_max_pacing_rate = val ; sk -> sk_pacing_rate = min ( sk -> sk_pacing_rate , sk -> sk_max_pacing_rate ) ; break ; case SO_INCOMING_CPU : sk -> sk_incoming_cpu = val ; break ; case SO_CNX_ADVICE : if ( val == 1 ) dst_negative_advice ( sk ) ; break ; default : ret = - ENOPROTOOPT ; break ; } release_sock ( sk ) ; return ret ; }\n",
      "fixed_code": "<S2SV_ModStart> = max_t ( int <S2SV_ModEnd> , val * <S2SV_ModStart> = max_t ( int <S2SV_ModEnd> , val *\n",
      "source_code_length": 6762,
      "target_code_length": 104,
      "vulnerability_patterns": {
        "null_pointer": 43,
        "total": 43
      },
      "total_patterns": 43,
      "original_address": "https://github.com/torvalds/linux/commit/b98b0bc8c431e3ceb4b26b0dfc8db509518fb290",
      "discovery_time": "2016-12-28T07:59Z",
      "project_commit_id": "torvalds@linux/b98b0bc8c431e3ceb4b26b0dfc8db509518fb290",
      "extraction_time": "2025-08-31T15:41:49.189267",
      "label": 1,
      "vulnerability_type": "buffer_overflow",
      "difficulty_level": "advanced",
      "risk_factors": [
        "system_crash",
        "memory_corruption",
        "arbitrary_code_execution"
      ],
      "attack_vectors": [
        "memory_manipulation",
        "malicious_input",
        "code_analysis",
        "buffer_overflow",
        "reverse_engineering",
        "fuzzing"
      ],
      "mitigation_strategies": [
        "safe_string_functions",
        "dynamic_analysis",
        "code_review",
        "static_analysis",
        "memory_safety_checks",
        "input_validation",
        "fuzzing",
        "bounds_checking",
        "secure_coding_practices"
      ],
      "code_differences": {
        "has_differences": true,
        "source_lines": 2,
        "target_lines": 2,
        "character_differences": 6658,
        "similarity_percentage": 3.153153153153153
      },
      "vulnerability_location": {
        "vulnerability_present": true,
        "fix_applied": true,
        "code_changed": true,
        "estimated_lines_changed": 0
      }
    },
    {
      "cve_id": "CVE-2016-1621",
      "cwe_id": "CWE-119",
      "cwe_name": "Buffer Overflow",
      "project": "external",
      "severity": "critical",
      "weaponization_score": 7.0,
      "is_critical": true,
      "is_weaponizable": true,
      "is_high_priority_project": false,
      "vulnerable_code": "CWE-119 int main ( int argc , char * * argv ) { int frame_cnt = 0 ; FILE * outfile = NULL ; vpx_codec_ctx_t codec ; const VpxInterface * decoder = NULL ; VpxVideoReader * reader = NULL ; const VpxVideoInfo * info = NULL ; int n = 0 ; int m = 0 ; int is_range = 0 ; char * nptr = NULL ; exec_name = argv [ 0 ] ; if ( argc != 4 ) die ( \"Invalid<S2SV_blank>number<S2SV_blank>of<S2SV_blank>arguments.\" ) ; reader = vpx_video_reader_open ( argv [ 1 ] ) ; if ( ! reader ) die ( \"Failed<S2SV_blank>to<S2SV_blank>open<S2SV_blank>%s<S2SV_blank>for<S2SV_blank>reading.\" , argv [ 1 ] ) ; if ( ! ( outfile = fopen ( argv [ 2 ] , \"wb\" ) ) ) die ( \"Failed<S2SV_blank>to<S2SV_blank>open<S2SV_blank>%s<S2SV_blank>for<S2SV_blank>writing.\" , argv [ 2 ] ) ; n = strtol ( argv [ 3 ] , & nptr , 0 ) ; m = strtol ( nptr + 1 , NULL , 0 ) ; is_range = ( * nptr == '-' ) ; if ( ! n || ! m || ( * nptr != '-' && * nptr != '/' ) ) die ( \"Couldn\\'t<S2SV_blank>parse<S2SV_blank>pattern<S2SV_blank>%s.\\\\n\" , argv [ 3 ] ) ; info = vpx_video_reader_get_info ( reader ) ; decoder = get_vpx_decoder_by_fourcc ( info -> codec_fourcc ) ; if ( ! decoder ) die ( \"Unknown<S2SV_blank>input<S2SV_blank>codec.\" ) ; <S2SV_StartBug> printf ( \"Using<S2SV_blank>%s\\\\n\" , vpx_codec_iface_name ( decoder -> interface ( ) ) ) ; <S2SV_EndBug> <S2SV_StartBug> if ( vpx_codec_dec_init ( & codec , decoder -> interface ( ) , NULL , 0 ) ) <S2SV_EndBug> die_codec ( & codec , \"Failed<S2SV_blank>to<S2SV_blank>initialize<S2SV_blank>decoder.\" ) ; while ( vpx_video_reader_read_frame ( reader ) ) { vpx_codec_iter_t iter = NULL ; vpx_image_t * img = NULL ; size_t frame_size = 0 ; int skip ; const unsigned char * frame = vpx_video_reader_get_frame ( reader , & frame_size ) ; if ( vpx_codec_decode ( & codec , frame , ( unsigned int ) frame_size , NULL , 0 ) ) die_codec ( & codec , \"Failed<S2SV_blank>to<S2SV_blank>decode<S2SV_blank>frame.\" ) ; ++ frame_cnt ; skip = ( is_range && frame_cnt >= n && frame_cnt <= m ) || ( ! is_range && m - ( frame_cnt - 1 ) % m <= n ) ; if ( ! skip ) { putc ( '.' , stdout ) ; while ( ( img = vpx_codec_get_frame ( & codec , & iter ) ) != NULL ) vpx_img_write ( img , outfile ) ; } else { putc ( 'X' , stdout ) ; } fflush ( stdout ) ; } printf ( \"Processed<S2SV_blank>%d<S2SV_blank>frames.\\\\n\" , frame_cnt ) ; if ( vpx_codec_destroy ( & codec ) ) die_codec ( & codec , \"Failed<S2SV_blank>to<S2SV_blank>destroy<S2SV_blank>codec.\" ) ; printf ( \"Play:<S2SV_blank>ffplay<S2SV_blank>-f<S2SV_blank>rawvideo<S2SV_blank>-pix_fmt<S2SV_blank>yuv420p<S2SV_blank>-s<S2SV_blank>%dx%d<S2SV_blank>%s\\\\n\" , info -> frame_width , info -> frame_height , argv [ 2 ] ) ; vpx_video_reader_close ( reader ) ; fclose ( outfile ) ; return EXIT_SUCCESS ; }\n",
      "fixed_code": "<S2SV_ModStart> ( decoder -> codec_interface <S2SV_ModEnd> ( ) ) <S2SV_ModStart> , decoder -> codec_interface <S2SV_ModEnd> ( ) ,\n",
      "source_code_length": 2710,
      "target_code_length": 130,
      "vulnerability_patterns": {
        "integer_overflow": 1,
        "format_string": 3,
        "null_pointer": 11,
        "total": 15
      },
      "total_patterns": 15,
      "original_address": "https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426",
      "discovery_time": "2016-03-12T21:59Z",
      "project_commit_id": "external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426",
      "extraction_time": "2025-08-31T15:41:49.189324",
      "label": 1,
      "vulnerability_type": "buffer_overflow",
      "difficulty_level": "advanced",
      "risk_factors": [
        "system_crash",
        "memory_corruption",
        "arbitrary_code_execution"
      ],
      "attack_vectors": [
        "memory_manipulation",
        "malicious_input",
        "code_analysis",
        "buffer_overflow",
        "reverse_engineering",
        "fuzzing"
      ],
      "mitigation_strategies": [
        "safe_string_functions",
        "dynamic_analysis",
        "code_review",
        "static_analysis",
        "memory_safety_checks",
        "input_validation",
        "fuzzing",
        "bounds_checking",
        "secure_coding_practices"
      ],
      "code_differences": {
        "has_differences": true,
        "source_lines": 2,
        "target_lines": 2,
        "character_differences": 2580,
        "similarity_percentage": 4.464285714285714
      },
      "vulnerability_location": {
        "vulnerability_present": true,
        "fix_applied": true,
        "code_changed": true,
        "estimated_lines_changed": 0
      }
    },
    {
      "cve_id": "CVE-2015-8952",
      "cwe_id": "CWE-19",
      "cwe_name": "Unknown",
      "project": "torvalds",
      "severity": "critical",
      "weaponization_score": 7.0,
      "is_critical": true,
      "is_weaponizable": true,
      "is_high_priority_project": false,
      "vulnerable_code": "CWE-19 static int ext4_fill_super ( struct super_block * sb , void * data , int silent ) { char * orig_data = kstrdup ( data , GFP_KERNEL ) ; struct buffer_head * bh ; struct ext4_super_block * es = NULL ; struct ext4_sb_info * sbi ; ext4_fsblk_t block ; ext4_fsblk_t sb_block = get_sb_block ( & data ) ; ext4_fsblk_t logical_sb_block ; unsigned long offset = 0 ; unsigned long journal_devnum = 0 ; unsigned long def_mount_opts ; struct inode * root ; const char * descr ; int ret = - ENOMEM ; int blocksize , clustersize ; unsigned int db_count ; unsigned int i ; int needs_recovery , has_huge_files , has_bigalloc ; __u64 blocks_count ; int err = 0 ; unsigned int journal_ioprio = DEFAULT_JOURNAL_IOPRIO ; ext4_group_t first_not_zeroed ; sbi = kzalloc ( sizeof ( * sbi ) , GFP_KERNEL ) ; if ( ! sbi ) goto out_free_orig ; sbi -> s_blockgroup_lock = kzalloc ( sizeof ( struct blockgroup_lock ) , GFP_KERNEL ) ; if ( ! sbi -> s_blockgroup_lock ) { kfree ( sbi ) ; goto out_free_orig ; } sb -> s_fs_info = sbi ; sbi -> s_sb = sb ; sbi -> s_inode_readahead_blks = EXT4_DEF_INODE_READAHEAD_BLKS ; sbi -> s_sb_block = sb_block ; if ( sb -> s_bdev -> bd_part ) sbi -> s_sectors_written_start = part_stat_read ( sb -> s_bdev -> bd_part , sectors [ 1 ] ) ; strreplace ( sb -> s_id , '/' , '!' ) ; ret = - EINVAL ; blocksize = sb_min_blocksize ( sb , EXT4_MIN_BLOCK_SIZE ) ; if ( ! blocksize ) { ext4_msg ( sb , KERN_ERR , \"unable<S2SV_blank>to<S2SV_blank>set<S2SV_blank>blocksize\" ) ; goto out_fail ; } if ( blocksize != EXT4_MIN_BLOCK_SIZE ) { logical_sb_block = sb_block * EXT4_MIN_BLOCK_SIZE ; offset = do_div ( logical_sb_block , blocksize ) ; } else { logical_sb_block = sb_block ; } if ( ! ( bh = sb_bread_unmovable ( sb , logical_sb_block ) ) ) { ext4_msg ( sb , KERN_ERR , \"unable<S2SV_blank>to<S2SV_blank>read<S2SV_blank>superblock\" ) ; goto out_fail ; } es = ( struct ext4_super_block * ) ( bh -> b_data + offset ) ; sbi -> s_es = es ; sb -> s_magic = le16_to_cpu ( es -> s_magic ) ; if ( sb -> s_magic != EXT4_SUPER_MAGIC ) goto cantfind_ext4 ; sbi -> s_kbytes_written = le64_to_cpu ( es -> s_kbytes_written ) ; if ( ext4_has_feature_metadata_csum ( sb ) && ext4_has_feature_gdt_csum ( sb ) ) ext4_warning ( sb , \"metadata_csum<S2SV_blank>and<S2SV_blank>uninit_bg<S2SV_blank>are<S2SV_blank>\" \"redundant<S2SV_blank>flags;<S2SV_blank>please<S2SV_blank>run<S2SV_blank>fsck.\" ) ; if ( ! ext4_verify_csum_type ( sb , es ) ) { ext4_msg ( sb , KERN_ERR , \"VFS:<S2SV_blank>Found<S2SV_blank>ext4<S2SV_blank>filesystem<S2SV_blank>with<S2SV_blank>\" \"unknown<S2SV_blank>checksum<S2SV_blank>algorithm.\" ) ; silent = 1 ; goto cantfind_ext4 ; } if ( ext4_has_feature_metadata_csum ( sb ) ) { sbi -> s_chksum_driver = crypto_alloc_shash ( \"crc32c\" , 0 , 0 ) ; if ( IS_ERR ( sbi -> s_chksum_driver ) ) { ext4_msg ( sb , KERN_ERR , \"Cannot<S2SV_blank>load<S2SV_blank>crc32c<S2SV_blank>driver.\" ) ; ret = PTR_ERR ( sbi -> s_chksum_driver ) ; sbi -> s_chksum_driver = NULL ; goto failed_mount ; } } if ( ! ext4_superblock_csum_verify ( sb , es ) ) { ext4_msg ( sb , KERN_ERR , \"VFS:<S2SV_blank>Found<S2SV_blank>ext4<S2SV_blank>filesystem<S2SV_blank>with<S2SV_blank>\" \"invalid<S2SV_blank>superblock<S2SV_blank>checksum.<S2SV_blank><S2SV_blank>Run<S2SV_blank>e2fsck?\" ) ; silent = 1 ; ret = - EFSBADCRC ; goto cantfind_ext4 ; } if ( ext4_has_feature_csum_seed ( sb ) ) sbi -> s_csum_seed = le32_to_cpu ( es -> s_checksum_seed ) ; else if ( ext4_has_metadata_csum ( sb ) ) sbi -> s_csum_seed = ext4_chksum ( sbi , ~ 0 , es -> s_uuid , sizeof ( es -> s_uuid ) ) ; def_mount_opts = le32_to_cpu ( es -> s_default_mount_opts ) ; set_opt ( sb , INIT_INODE_TABLE ) ; if ( def_mount_opts & EXT4_DEFM_DEBUG ) set_opt ( sb , DEBUG ) ; if ( def_mount_opts & EXT4_DEFM_BSDGROUPS ) set_opt ( sb , GRPID ) ; if ( def_mount_opts & EXT4_DEFM_UID16 ) set_opt ( sb , NO_UID32 ) ; set_opt ( sb , XATTR_USER ) ; # ifdef CONFIG_EXT4_FS_POSIX_ACL set_opt ( sb , POSIX_ACL ) ; # endif if ( ext4_has_metadata_csum ( sb ) ) set_opt ( sb , JOURNAL_CHECKSUM ) ; if ( ( def_mount_opts & EXT4_DEFM_JMODE ) == EXT4_DEFM_JMODE_DATA ) set_opt ( sb , JOURNAL_DATA ) ; else if ( ( def_mount_opts & EXT4_DEFM_JMODE ) == EXT4_DEFM_JMODE_ORDERED ) set_opt ( sb , ORDERED_DATA ) ; else if ( ( def_mount_opts & EXT4_DEFM_JMODE ) == EXT4_DEFM_JMODE_WBACK ) set_opt ( sb , WRITEBACK_DATA ) ; if ( le16_to_cpu ( sbi -> s_es -> s_errors ) == EXT4_ERRORS_PANIC ) set_opt ( sb , ERRORS_PANIC ) ; else if ( le16_to_cpu ( sbi -> s_es -> s_errors ) == EXT4_ERRORS_CONTINUE ) set_opt ( sb , ERRORS_CONT ) ; else set_opt ( sb , ERRORS_RO ) ; set_opt ( sb , BLOCK_VALIDITY ) ; if ( def_mount_opts & EXT4_DEFM_DISCARD ) set_opt ( sb , DISCARD ) ; sbi -> s_resuid = make_kuid ( & init_user_ns , le16_to_cpu ( es -> s_def_resuid ) ) ; sbi -> s_resgid = make_kgid ( & init_user_ns , le16_to_cpu ( es -> s_def_resgid ) ) ; sbi -> s_commit_interval = JBD2_DEFAULT_MAX_COMMIT_AGE * HZ ; sbi -> s_min_batch_time = EXT4_DEF_MIN_BATCH_TIME ; sbi -> s_max_batch_time = EXT4_DEF_MAX_BATCH_TIME ; if ( ( def_mount_opts & EXT4_DEFM_NOBARRIER ) == 0 ) set_opt ( sb , BARRIER ) ; if ( ! IS_EXT3_SB ( sb ) && ! IS_EXT2_SB ( sb ) && ( ( def_mount_opts & EXT4_DEFM_NODELALLOC ) == 0 ) ) set_opt ( sb , DELALLOC ) ; sbi -> s_li_wait_mult = EXT4_DEF_LI_WAIT_MULT ; if ( ! parse_options ( ( char * ) sbi -> s_es -> s_mount_opts , sb , & journal_devnum , & journal_ioprio , 0 ) ) { ext4_msg ( sb , KERN_WARNING , \"failed<S2SV_blank>to<S2SV_blank>parse<S2SV_blank>options<S2SV_blank>in<S2SV_blank>superblock:<S2SV_blank>%s\" , sbi -> s_es -> s_mount_opts ) ; } sbi -> s_def_mount_opt = sbi -> s_mount_opt ; if ( ! parse_options ( ( char * ) data , sb , & journal_devnum , & journal_ioprio , 0 ) ) goto failed_mount ; if ( test_opt ( sb , DATA_FLAGS ) == EXT4_MOUNT_JOURNAL_DATA ) { printk_once ( KERN_WARNING \"EXT4-fs:<S2SV_blank>Warning:<S2SV_blank>mounting<S2SV_blank>\" \"with<S2SV_blank>data=journal<S2SV_blank>disables<S2SV_blank>delayed<S2SV_blank>\" \"allocation<S2SV_blank>and<S2SV_blank>O_DIRECT<S2SV_blank>support!\\\\n\" ) ; if ( test_opt2 ( sb , EXPLICIT_DELALLOC ) ) { ext4_msg ( sb , KERN_ERR , \"can\\'t<S2SV_blank>mount<S2SV_blank>with<S2SV_blank>\" \"both<S2SV_blank>data=journal<S2SV_blank>and<S2SV_blank>delalloc\" ) ; goto failed_mount ; } if ( test_opt ( sb , DIOREAD_NOLOCK ) ) { ext4_msg ( sb , KERN_ERR , \"can\\'t<S2SV_blank>mount<S2SV_blank>with<S2SV_blank>\" \"both<S2SV_blank>data=journal<S2SV_blank>and<S2SV_blank>dioread_nolock\" ) ; goto failed_mount ; } if ( test_opt ( sb , DAX ) ) { ext4_msg ( sb , KERN_ERR , \"can\\'t<S2SV_blank>mount<S2SV_blank>with<S2SV_blank>\" \"both<S2SV_blank>data=journal<S2SV_blank>and<S2SV_blank>dax\" ) ; goto failed_mount ; } if ( test_opt ( sb , DELALLOC ) ) clear_opt ( sb , DELALLOC ) ; } else { sb -> s_iflags |= SB_I_CGROUPWB ; } sb -> s_flags = ( sb -> s_flags & ~ MS_POSIXACL ) | ( test_opt ( sb , POSIX_ACL ) ? MS_POSIXACL : 0 ) ; if ( le32_to_cpu ( es -> s_rev_level ) == EXT4_GOOD_OLD_REV && ( ext4_has_compat_features ( sb ) || ext4_has_ro_compat_features ( sb ) || ext4_has_incompat_features ( sb ) ) ) ext4_msg ( sb , KERN_WARNING , \"feature<S2SV_blank>flags<S2SV_blank>set<S2SV_blank>on<S2SV_blank>rev<S2SV_blank>0<S2SV_blank>fs,<S2SV_blank>\" \"running<S2SV_blank>e2fsck<S2SV_blank>is<S2SV_blank>recommended\" ) ; if ( es -> s_creator_os == cpu_to_le32 ( EXT4_OS_HURD ) ) { set_opt2 ( sb , HURD_COMPAT ) ; if ( ext4_has_feature_64bit ( sb ) ) { ext4_msg ( sb , KERN_ERR , \"The<S2SV_blank>Hurd<S2SV_blank>can\\'t<S2SV_blank>support<S2SV_blank>64-bit<S2SV_blank>file<S2SV_blank>systems\" ) ; goto failed_mount ; } } if ( IS_EXT2_SB ( sb ) ) { if ( ext2_feature_set_ok ( sb ) ) ext4_msg ( sb , KERN_INFO , \"mounting<S2SV_blank>ext2<S2SV_blank>file<S2SV_blank>system<S2SV_blank>\" \"using<S2SV_blank>the<S2SV_blank>ext4<S2SV_blank>subsystem\" ) ; else { ext4_msg ( sb , KERN_ERR , \"couldn\\'t<S2SV_blank>mount<S2SV_blank>as<S2SV_blank>ext2<S2SV_blank>due<S2SV_blank>\" \"to<S2SV_blank>feature<S2SV_blank>incompatibilities\" ) ; goto failed_mount ; } } if ( IS_EXT3_SB ( sb ) ) { if ( ext3_feature_set_ok ( sb ) ) ext4_msg ( sb , KERN_INFO , \"mounting<S2SV_blank>ext3<S2SV_blank>file<S2SV_blank>system<S2SV_blank>\" \"using<S2SV_blank>the<S2SV_blank>ext4<S2SV_blank>subsystem\" ) ; else { ext4_msg ( sb , KERN_ERR , \"couldn\\'t<S2SV_blank>mount<S2SV_blank>as<S2SV_blank>ext3<S2SV_blank>due<S2SV_blank>\" \"to<S2SV_blank>feature<S2SV_blank>incompatibilities\" ) ; goto failed_mount ; } } if ( ! ext4_feature_set_ok ( sb , ( sb -> s_flags & MS_RDONLY ) ) ) goto failed_mount ; blocksize = BLOCK_SIZE << le32_to_cpu ( es -> s_log_block_size ) ; if ( blocksize < EXT4_MIN_BLOCK_SIZE || blocksize > EXT4_MAX_BLOCK_SIZE ) { ext4_msg ( sb , KERN_ERR , \"Unsupported<S2SV_blank>filesystem<S2SV_blank>blocksize<S2SV_blank>%d\" , blocksize ) ; goto failed_mount ; } if ( sbi -> s_mount_opt & EXT4_MOUNT_DAX ) { if ( blocksize != PAGE_SIZE ) { ext4_msg ( sb , KERN_ERR , \"error:<S2SV_blank>unsupported<S2SV_blank>blocksize<S2SV_blank>for<S2SV_blank>dax\" ) ; goto failed_mount ; } if ( ! sb -> s_bdev -> bd_disk -> fops -> direct_access ) { ext4_msg ( sb , KERN_ERR , \"error:<S2SV_blank>device<S2SV_blank>does<S2SV_blank>not<S2SV_blank>support<S2SV_blank>dax\" ) ; goto failed_mount ; } } if ( ext4_has_feature_encrypt ( sb ) && es -> s_encryption_level ) { ext4_msg ( sb , KERN_ERR , \"Unsupported<S2SV_blank>encryption<S2SV_blank>level<S2SV_blank>%d\" , es -> s_encryption_level ) ; goto failed_mount ; } if ( sb -> s_blocksize != blocksize ) { if ( ! sb_set_blocksize ( sb , blocksize ) ) { ext4_msg ( sb , KERN_ERR , \"bad<S2SV_blank>block<S2SV_blank>size<S2SV_blank>%d\" , blocksize ) ; goto failed_mount ; } brelse ( bh ) ; logical_sb_block = sb_block * EXT4_MIN_BLOCK_SIZE ; offset = do_div ( logical_sb_block , blocksize ) ; bh = sb_bread_unmovable ( sb , logical_sb_block ) ; if ( ! bh ) { ext4_msg ( sb , KERN_ERR , \"Can\\'t<S2SV_blank>read<S2SV_blank>superblock<S2SV_blank>on<S2SV_blank>2nd<S2SV_blank>try\" ) ; goto failed_mount ; } es = ( struct ext4_super_block * ) ( bh -> b_data + offset ) ; sbi -> s_es = es ; if ( es -> s_magic != cpu_to_le16 ( EXT4_SUPER_MAGIC ) ) { ext4_msg ( sb , KERN_ERR , \"Magic<S2SV_blank>mismatch,<S2SV_blank>very<S2SV_blank>weird!\" ) ; goto failed_mount ; } } has_huge_files = ext4_has_feature_huge_file ( sb ) ; sbi -> s_bitmap_maxbytes = ext4_max_bitmap_size ( sb -> s_blocksize_bits , has_huge_files ) ; sb -> s_maxbytes = ext4_max_size ( sb -> s_blocksize_bits , has_huge_files ) ; if ( le32_to_cpu ( es -> s_rev_level ) == EXT4_GOOD_OLD_REV ) { sbi -> s_inode_size = EXT4_GOOD_OLD_INODE_SIZE ; sbi -> s_first_ino = EXT4_GOOD_OLD_FIRST_INO ; } else { sbi -> s_inode_size = le16_to_cpu ( es -> s_inode_size ) ; sbi -> s_first_ino = le32_to_cpu ( es -> s_first_ino ) ; if ( ( sbi -> s_inode_size < EXT4_GOOD_OLD_INODE_SIZE ) || ( ! is_power_of_2 ( sbi -> s_inode_size ) ) || ( sbi -> s_inode_size > blocksize ) ) { ext4_msg ( sb , KERN_ERR , \"unsupported<S2SV_blank>inode<S2SV_blank>size:<S2SV_blank>%d\" , sbi -> s_inode_size ) ; goto failed_mount ; } if ( sbi -> s_inode_size > EXT4_GOOD_OLD_INODE_SIZE ) sb -> s_time_gran = 1 << ( EXT4_EPOCH_BITS - 2 ) ; } sbi -> s_desc_size = le16_to_cpu ( es -> s_desc_size ) ; if ( ext4_has_feature_64bit ( sb ) ) { if ( sbi -> s_desc_size < EXT4_MIN_DESC_SIZE_64BIT || sbi -> s_desc_size > EXT4_MAX_DESC_SIZE || ! is_power_of_2 ( sbi -> s_desc_size ) ) { ext4_msg ( sb , KERN_ERR , \"unsupported<S2SV_blank>descriptor<S2SV_blank>size<S2SV_blank>%lu\" , sbi -> s_desc_size ) ; goto failed_mount ; } } else sbi -> s_desc_size = EXT4_MIN_DESC_SIZE ; sbi -> s_blocks_per_group = le32_to_cpu ( es -> s_blocks_per_group ) ; sbi -> s_inodes_per_group = le32_to_cpu ( es -> s_inodes_per_group ) ; if ( EXT4_INODE_SIZE ( sb ) == 0 || EXT4_INODES_PER_GROUP ( sb ) == 0 ) goto cantfind_ext4 ; sbi -> s_inodes_per_block = blocksize / EXT4_INODE_SIZE ( sb ) ; if ( sbi -> s_inodes_per_block == 0 ) goto cantfind_ext4 ; sbi -> s_itb_per_group = sbi -> s_inodes_per_group / sbi -> s_inodes_per_block ; sbi -> s_desc_per_block = blocksize / EXT4_DESC_SIZE ( sb ) ; sbi -> s_sbh = bh ; sbi -> s_mount_state = le16_to_cpu ( es -> s_state ) ; sbi -> s_addr_per_block_bits = ilog2 ( EXT4_ADDR_PER_BLOCK ( sb ) ) ; sbi -> s_desc_per_block_bits = ilog2 ( EXT4_DESC_PER_BLOCK ( sb ) ) ; for ( i = 0 ; i < 4 ; i ++ ) sbi -> s_hash_seed [ i ] = le32_to_cpu ( es -> s_hash_seed [ i ] ) ; sbi -> s_def_hash_version = es -> s_def_hash_version ; if ( ext4_has_feature_dir_index ( sb ) ) { i = le32_to_cpu ( es -> s_flags ) ; if ( i & EXT2_FLAGS_UNSIGNED_HASH ) sbi -> s_hash_unsigned = 3 ; else if ( ( i & EXT2_FLAGS_SIGNED_HASH ) == 0 ) { # ifdef __CHAR_UNSIGNED__ if ( ! ( sb -> s_flags & MS_RDONLY ) ) es -> s_flags |= cpu_to_le32 ( EXT2_FLAGS_UNSIGNED_HASH ) ; sbi -> s_hash_unsigned = 3 ; # else if ( ! ( sb -> s_flags & MS_RDONLY ) ) es -> s_flags |= cpu_to_le32 ( EXT2_FLAGS_SIGNED_HASH ) ; # endif } } clustersize = BLOCK_SIZE << le32_to_cpu ( es -> s_log_cluster_size ) ; has_bigalloc = ext4_has_feature_bigalloc ( sb ) ; if ( has_bigalloc ) { if ( clustersize < blocksize ) { ext4_msg ( sb , KERN_ERR , \"cluster<S2SV_blank>size<S2SV_blank>(%d)<S2SV_blank>smaller<S2SV_blank>than<S2SV_blank>\" \"block<S2SV_blank>size<S2SV_blank>(%d)\" , clustersize , blocksize ) ; goto failed_mount ; } sbi -> s_cluster_bits = le32_to_cpu ( es -> s_log_cluster_size ) - le32_to_cpu ( es -> s_log_block_size ) ; sbi -> s_clusters_per_group = le32_to_cpu ( es -> s_clusters_per_group ) ; if ( sbi -> s_clusters_per_group > blocksize * 8 ) { ext4_msg ( sb , KERN_ERR , \"#clusters<S2SV_blank>per<S2SV_blank>group<S2SV_blank>too<S2SV_blank>big:<S2SV_blank>%lu\" , sbi -> s_clusters_per_group ) ; goto failed_mount ; } if ( sbi -> s_blocks_per_group != ( sbi -> s_clusters_per_group * ( clustersize / blocksize ) ) ) { ext4_msg ( sb , KERN_ERR , \"blocks<S2SV_blank>per<S2SV_blank>group<S2SV_blank>(%lu)<S2SV_blank>and<S2SV_blank>\" \"clusters<S2SV_blank>per<S2SV_blank>group<S2SV_blank>(%lu)<S2SV_blank>inconsistent\" , sbi -> s_blocks_per_group , sbi -> s_clusters_per_group ) ; goto failed_mount ; } } else { if ( clustersize != blocksize ) { ext4_warning ( sb , \"fragment/cluster<S2SV_blank>size<S2SV_blank>(%d)<S2SV_blank>!=<S2SV_blank>\" \"block<S2SV_blank>size<S2SV_blank>(%d)\" , clustersize , blocksize ) ; clustersize = blocksize ; } if ( sbi -> s_blocks_per_group > blocksize * 8 ) { ext4_msg ( sb , KERN_ERR , \"#blocks<S2SV_blank>per<S2SV_blank>group<S2SV_blank>too<S2SV_blank>big:<S2SV_blank>%lu\" , sbi -> s_blocks_per_group ) ; goto failed_mount ; } sbi -> s_clusters_per_group = sbi -> s_blocks_per_group ; sbi -> s_cluster_bits = 0 ; } sbi -> s_cluster_ratio = clustersize / blocksize ; if ( sbi -> s_inodes_per_group > blocksize * 8 ) { ext4_msg ( sb , KERN_ERR , \"#inodes<S2SV_blank>per<S2SV_blank>group<S2SV_blank>too<S2SV_blank>big:<S2SV_blank>%lu\" , sbi -> s_inodes_per_group ) ; goto failed_mount ; } if ( sbi -> s_blocks_per_group == clustersize << 3 ) set_opt2 ( sb , STD_GROUP_SIZE ) ; err = generic_check_addressable ( sb -> s_blocksize_bits , ext4_blocks_count ( es ) ) ; if ( err ) { ext4_msg ( sb , KERN_ERR , \"filesystem\" \"<S2SV_blank>too<S2SV_blank>large<S2SV_blank>to<S2SV_blank>mount<S2SV_blank>safely<S2SV_blank>on<S2SV_blank>this<S2SV_blank>system\" ) ; if ( sizeof ( sector_t ) < 8 ) ext4_msg ( sb , KERN_WARNING , \"CONFIG_LBDAF<S2SV_blank>not<S2SV_blank>enabled\" ) ; goto failed_mount ; } if ( EXT4_BLOCKS_PER_GROUP ( sb ) == 0 ) goto cantfind_ext4 ; blocks_count = sb -> s_bdev -> bd_inode -> i_size >> sb -> s_blocksize_bits ; if ( blocks_count && ext4_blocks_count ( es ) > blocks_count ) { ext4_msg ( sb , KERN_WARNING , \"bad<S2SV_blank>geometry:<S2SV_blank>block<S2SV_blank>count<S2SV_blank>%llu<S2SV_blank>\" \"exceeds<S2SV_blank>size<S2SV_blank>of<S2SV_blank>device<S2SV_blank>(%llu<S2SV_blank>blocks)\" , ext4_blocks_count ( es ) , blocks_count ) ; goto failed_mount ; } if ( le32_to_cpu ( es -> s_first_data_block ) >= ext4_blocks_count ( es ) ) { ext4_msg ( sb , KERN_WARNING , \"bad<S2SV_blank>geometry:<S2SV_blank>first<S2SV_blank>data<S2SV_blank>\" \"block<S2SV_blank>%u<S2SV_blank>is<S2SV_blank>beyond<S2SV_blank>end<S2SV_blank>of<S2SV_blank>filesystem<S2SV_blank>(%llu)\" , le32_to_cpu ( es -> s_first_data_block ) , ext4_blocks_count ( es ) ) ; goto failed_mount ; } blocks_count = ( ext4_blocks_count ( es ) - le32_to_cpu ( es -> s_first_data_block ) + EXT4_BLOCKS_PER_GROUP ( sb ) - 1 ) ; do_div ( blocks_count , EXT4_BLOCKS_PER_GROUP ( sb ) ) ; if ( blocks_count > ( ( uint64_t ) 1 << 32 ) - EXT4_DESC_PER_BLOCK ( sb ) ) { ext4_msg ( sb , KERN_WARNING , \"groups<S2SV_blank>count<S2SV_blank>too<S2SV_blank>large:<S2SV_blank>%u<S2SV_blank>\" \"(block<S2SV_blank>count<S2SV_blank>%llu,<S2SV_blank>first<S2SV_blank>data<S2SV_blank>block<S2SV_blank>%u,<S2SV_blank>\" \"blocks<S2SV_blank>per<S2SV_blank>group<S2SV_blank>%lu)\" , sbi -> s_groups_count , ext4_blocks_count ( es ) , le32_to_cpu ( es -> s_first_data_block ) , EXT4_BLOCKS_PER_GROUP ( sb ) ) ; goto failed_mount ; } sbi -> s_groups_count = blocks_count ; sbi -> s_blockfile_groups = min_t ( ext4_group_t , sbi -> s_groups_count , ( EXT4_MAX_BLOCK_FILE_PHYS / EXT4_BLOCKS_PER_GROUP ( sb ) ) ) ; db_count = ( sbi -> s_groups_count + EXT4_DESC_PER_BLOCK ( sb ) - 1 ) / EXT4_DESC_PER_BLOCK ( sb ) ; sbi -> s_group_desc = ext4_kvmalloc ( db_count * sizeof ( struct buffer_head * ) , GFP_KERNEL ) ; if ( sbi -> s_group_desc == NULL ) { ext4_msg ( sb , KERN_ERR , \"not<S2SV_blank>enough<S2SV_blank>memory\" ) ; ret = - ENOMEM ; goto failed_mount ; } bgl_lock_init ( sbi -> s_blockgroup_lock ) ; for ( i = 0 ; i < db_count ; i ++ ) { block = descriptor_loc ( sb , logical_sb_block , i ) ; sbi -> s_group_desc [ i ] = sb_bread_unmovable ( sb , block ) ; if ( ! sbi -> s_group_desc [ i ] ) { ext4_msg ( sb , KERN_ERR , \"can\\'t<S2SV_blank>read<S2SV_blank>group<S2SV_blank>descriptor<S2SV_blank>%d\" , i ) ; db_count = i ; goto failed_mount2 ; } } if ( ! ext4_check_descriptors ( sb , & first_not_zeroed ) ) { ext4_msg ( sb , KERN_ERR , \"group<S2SV_blank>descriptors<S2SV_blank>corrupted!\" ) ; ret = - EFSCORRUPTED ; goto failed_mount2 ; } sbi -> s_gdb_count = db_count ; get_random_bytes ( & sbi -> s_next_generation , sizeof ( u32 ) ) ; spin_lock_init ( & sbi -> s_next_gen_lock ) ; setup_timer ( & sbi -> s_err_report , print_daily_error_info , ( unsigned long ) sb ) ; if ( ext4_es_register_shrinker ( sbi ) ) goto failed_mount3 ; sbi -> s_stripe = ext4_get_stripe_size ( sbi ) ; sbi -> s_extent_max_zeroout_kb = 32 ; sb -> s_op = & ext4_sops ; sb -> s_export_op = & ext4_export_ops ; sb -> s_xattr = ext4_xattr_handlers ; # ifdef CONFIG_QUOTA sb -> dq_op = & ext4_quota_operations ; if ( ext4_has_feature_quota ( sb ) ) sb -> s_qcop = & dquot_quotactl_sysfile_ops ; else sb -> s_qcop = & ext4_qctl_operations ; sb -> s_quota_types = QTYPE_MASK_USR | QTYPE_MASK_GRP | QTYPE_MASK_PRJ ; # endif memcpy ( sb -> s_uuid , es -> s_uuid , sizeof ( es -> s_uuid ) ) ; INIT_LIST_HEAD ( & sbi -> s_orphan ) ; mutex_init ( & sbi -> s_orphan_lock ) ; sb -> s_root = NULL ; needs_recovery = ( es -> s_last_orphan != 0 || ext4_has_feature_journal_needs_recovery ( sb ) ) ; if ( ext4_has_feature_mmp ( sb ) && ! ( sb -> s_flags & MS_RDONLY ) ) if ( ext4_multi_mount_protect ( sb , le64_to_cpu ( es -> s_mmp_block ) ) ) goto failed_mount3a ; if ( ! test_opt ( sb , NOLOAD ) && ext4_has_feature_journal ( sb ) ) { if ( ext4_load_journal ( sb , es , journal_devnum ) ) goto failed_mount3a ; } else if ( test_opt ( sb , NOLOAD ) && ! ( sb -> s_flags & MS_RDONLY ) && ext4_has_feature_journal_needs_recovery ( sb ) ) { ext4_msg ( sb , KERN_ERR , \"required<S2SV_blank>journal<S2SV_blank>recovery<S2SV_blank>\" \"suppressed<S2SV_blank>and<S2SV_blank>not<S2SV_blank>mounted<S2SV_blank>read-only\" ) ; goto failed_mount_wq ; } else { if ( test_opt2 ( sb , EXPLICIT_JOURNAL_CHECKSUM ) ) { ext4_msg ( sb , KERN_ERR , \"can\\'t<S2SV_blank>mount<S2SV_blank>with<S2SV_blank>\" \"journal_checksum,<S2SV_blank>fs<S2SV_blank>mounted<S2SV_blank>w/o<S2SV_blank>journal\" ) ; goto failed_mount_wq ; } if ( test_opt ( sb , JOURNAL_ASYNC_COMMIT ) ) { ext4_msg ( sb , KERN_ERR , \"can\\'t<S2SV_blank>mount<S2SV_blank>with<S2SV_blank>\" \"journal_async_commit,<S2SV_blank>fs<S2SV_blank>mounted<S2SV_blank>w/o<S2SV_blank>journal\" ) ; goto failed_mount_wq ; } if ( sbi -> s_commit_interval != JBD2_DEFAULT_MAX_COMMIT_AGE * HZ ) { ext4_msg ( sb , KERN_ERR , \"can\\'t<S2SV_blank>mount<S2SV_blank>with<S2SV_blank>\" \"commit=%lu,<S2SV_blank>fs<S2SV_blank>mounted<S2SV_blank>w/o<S2SV_blank>journal\" , sbi -> s_commit_interval / HZ ) ; goto failed_mount_wq ; } if ( EXT4_MOUNT_DATA_FLAGS & ( sbi -> s_mount_opt ^ sbi -> s_def_mount_opt ) ) { ext4_msg ( sb , KERN_ERR , \"can\\'t<S2SV_blank>mount<S2SV_blank>with<S2SV_blank>\" \"data=,<S2SV_blank>fs<S2SV_blank>mounted<S2SV_blank>w/o<S2SV_blank>journal\" ) ; goto failed_mount_wq ; } sbi -> s_def_mount_opt &= EXT4_MOUNT_JOURNAL_CHECKSUM ; clear_opt ( sb , JOURNAL_CHECKSUM ) ; clear_opt ( sb , DATA_FLAGS ) ; sbi -> s_journal = NULL ; needs_recovery = 0 ; goto no_journal ; } if ( ext4_has_feature_64bit ( sb ) && ! jbd2_journal_set_features ( EXT4_SB ( sb ) -> s_journal , 0 , 0 , JBD2_FEATURE_INCOMPAT_64BIT ) ) { ext4_msg ( sb , KERN_ERR , \"Failed<S2SV_blank>to<S2SV_blank>set<S2SV_blank>64-bit<S2SV_blank>journal<S2SV_blank>feature\" ) ; goto failed_mount_wq ; } if ( ! set_journal_csum_feature_set ( sb ) ) { ext4_msg ( sb , KERN_ERR , \"Failed<S2SV_blank>to<S2SV_blank>set<S2SV_blank>journal<S2SV_blank>checksum<S2SV_blank>\" \"feature<S2SV_blank>set\" ) ; goto failed_mount_wq ; } switch ( test_opt ( sb , DATA_FLAGS ) ) { case 0 : if ( jbd2_journal_check_available_features ( sbi -> s_journal , 0 , 0 , JBD2_FEATURE_INCOMPAT_REVOKE ) ) set_opt ( sb , ORDERED_DATA ) ; else set_opt ( sb , JOURNAL_DATA ) ; break ; case EXT4_MOUNT_ORDERED_DATA : case EXT4_MOUNT_WRITEBACK_DATA : if ( ! jbd2_journal_check_available_features ( sbi -> s_journal , 0 , 0 , JBD2_FEATURE_INCOMPAT_REVOKE ) ) { ext4_msg ( sb , KERN_ERR , \"Journal<S2SV_blank>does<S2SV_blank>not<S2SV_blank>support<S2SV_blank>\" \"requested<S2SV_blank>data<S2SV_blank>journaling<S2SV_blank>mode\" ) ; goto failed_mount_wq ; } default : break ; } set_task_ioprio ( sbi -> s_journal -> j_task , journal_ioprio ) ; sbi -> s_journal -> j_commit_callback = ext4_journal_commit_callback ; no_journal : if ( ext4_mballoc_ready ) { <S2SV_StartBug> sbi -> s_mb_cache = ext4_xattr_create_cache ( sb -> s_id ) ; <S2SV_EndBug> if ( ! sbi -> s_mb_cache ) { ext4_msg ( sb , KERN_ERR , \"Failed<S2SV_blank>to<S2SV_blank>create<S2SV_blank>an<S2SV_blank>mb_cache\" ) ; goto failed_mount_wq ; } } if ( ( DUMMY_ENCRYPTION_ENABLED ( sbi ) || ext4_has_feature_encrypt ( sb ) ) && ( blocksize != PAGE_CACHE_SIZE ) ) { ext4_msg ( sb , KERN_ERR , \"Unsupported<S2SV_blank>blocksize<S2SV_blank>for<S2SV_blank>fs<S2SV_blank>encryption\" ) ; goto failed_mount_wq ; } if ( DUMMY_ENCRYPTION_ENABLED ( sbi ) && ! ( sb -> s_flags & MS_RDONLY ) && ! ext4_has_feature_encrypt ( sb ) ) { ext4_set_feature_encrypt ( sb ) ; ext4_commit_super ( sb , 1 ) ; } if ( es -> s_overhead_clusters ) sbi -> s_overhead = le32_to_cpu ( es -> s_overhead_clusters ) ; else { err = ext4_calculate_overhead ( sb ) ; if ( err ) goto failed_mount_wq ; } EXT4_SB ( sb ) -> rsv_conversion_wq = alloc_workqueue ( \"ext4-rsv-conversion\" , WQ_MEM_RECLAIM | WQ_UNBOUND , 1 ) ; if ( ! EXT4_SB ( sb ) -> rsv_conversion_wq ) { printk ( KERN_ERR \"EXT4-fs:<S2SV_blank>failed<S2SV_blank>to<S2SV_blank>create<S2SV_blank>workqueue\\\\n\" ) ; ret = - ENOMEM ; goto failed_mount4 ; } root = ext4_iget ( sb , EXT4_ROOT_INO ) ; if ( IS_ERR ( root ) ) { ext4_msg ( sb , KERN_ERR , \"get<S2SV_blank>root<S2SV_blank>inode<S2SV_blank>failed\" ) ; ret = PTR_ERR ( root ) ; root = NULL ; goto failed_mount4 ; } if ( ! S_ISDIR ( root -> i_mode ) || ! root -> i_blocks || ! root -> i_size ) { ext4_msg ( sb , KERN_ERR , \"corrupt<S2SV_blank>root<S2SV_blank>inode,<S2SV_blank>run<S2SV_blank>e2fsck\" ) ; iput ( root ) ; goto failed_mount4 ; } sb -> s_root = d_make_root ( root ) ; if ( ! sb -> s_root ) { ext4_msg ( sb , KERN_ERR , \"get<S2SV_blank>root<S2SV_blank>dentry<S2SV_blank>failed\" ) ; ret = - ENOMEM ; goto failed_mount4 ; } if ( ext4_setup_super ( sb , es , sb -> s_flags & MS_RDONLY ) ) sb -> s_flags |= MS_RDONLY ; if ( sbi -> s_inode_size > EXT4_GOOD_OLD_INODE_SIZE ) { sbi -> s_want_extra_isize = sizeof ( struct ext4_inode ) - EXT4_GOOD_OLD_INODE_SIZE ; if ( ext4_has_feature_extra_isize ( sb ) ) { if ( sbi -> s_want_extra_isize < le16_to_cpu ( es -> s_want_extra_isize ) ) sbi -> s_want_extra_isize = le16_to_cpu ( es -> s_want_extra_isize ) ; if ( sbi -> s_want_extra_isize < le16_to_cpu ( es -> s_min_extra_isize ) ) sbi -> s_want_extra_isize = le16_to_cpu ( es -> s_min_extra_isize ) ; } } if ( EXT4_GOOD_OLD_INODE_SIZE + sbi -> s_want_extra_isize > sbi -> s_inode_size ) { sbi -> s_want_extra_isize = sizeof ( struct ext4_inode ) - EXT4_GOOD_OLD_INODE_SIZE ; ext4_msg ( sb , KERN_INFO , \"required<S2SV_blank>extra<S2SV_blank>inode<S2SV_blank>space<S2SV_blank>not\" \"available\" ) ; } ext4_set_resv_clusters ( sb ) ; err = ext4_setup_system_zone ( sb ) ; if ( err ) { ext4_msg ( sb , KERN_ERR , \"failed<S2SV_blank>to<S2SV_blank>initialize<S2SV_blank>system<S2SV_blank>\" \"zone<S2SV_blank>(%d)\" , err ) ; goto failed_mount4a ; } ext4_ext_init ( sb ) ; err = ext4_mb_init ( sb ) ; if ( err ) { ext4_msg ( sb , KERN_ERR , \"failed<S2SV_blank>to<S2SV_blank>initialize<S2SV_blank>mballoc<S2SV_blank>(%d)\" , err ) ; goto failed_mount5 ; } block = ext4_count_free_clusters ( sb ) ; ext4_free_blocks_count_set ( sbi -> s_es , EXT4_C2B ( sbi , block ) ) ; err = percpu_counter_init ( & sbi -> s_freeclusters_counter , block , GFP_KERNEL ) ; if ( ! err ) { unsigned long freei = ext4_count_free_inodes ( sb ) ; sbi -> s_es -> s_free_inodes_count = cpu_to_le32 ( freei ) ; err = percpu_counter_init ( & sbi -> s_freeinodes_counter , freei , GFP_KERNEL ) ; } if ( ! err ) err = percpu_counter_init ( & sbi -> s_dirs_counter , ext4_count_dirs ( sb ) , GFP_KERNEL ) ; if ( ! err ) err = percpu_counter_init ( & sbi -> s_dirtyclusters_counter , 0 , GFP_KERNEL ) ; if ( err ) { ext4_msg ( sb , KERN_ERR , \"insufficient<S2SV_blank>memory\" ) ; goto failed_mount6 ; } if ( ext4_has_feature_flex_bg ( sb ) ) if ( ! ext4_fill_flex_info ( sb ) ) { ext4_msg ( sb , KERN_ERR , \"unable<S2SV_blank>to<S2SV_blank>initialize<S2SV_blank>\" \"flex_bg<S2SV_blank>meta<S2SV_blank>info!\" ) ; goto failed_mount6 ; } err = ext4_register_li_request ( sb , first_not_zeroed ) ; if ( err ) goto failed_mount6 ; err = ext4_register_sysfs ( sb ) ; if ( err ) goto failed_mount7 ; # ifdef CONFIG_QUOTA if ( ext4_has_feature_quota ( sb ) && ! ( sb -> s_flags & MS_RDONLY ) ) { err = ext4_enable_quotas ( sb ) ; if ( err ) goto failed_mount8 ; } # endif EXT4_SB ( sb ) -> s_mount_state |= EXT4_ORPHAN_FS ; ext4_orphan_cleanup ( sb , es ) ; EXT4_SB ( sb ) -> s_mount_state &= ~ EXT4_ORPHAN_FS ; if ( needs_recovery ) { ext4_msg ( sb , KERN_INFO , \"recovery<S2SV_blank>complete\" ) ; ext4_mark_recovery_complete ( sb , es ) ; } if ( EXT4_SB ( sb ) -> s_journal ) { if ( test_opt ( sb , DATA_FLAGS ) == EXT4_MOUNT_JOURNAL_DATA ) descr = \"<S2SV_blank>journalled<S2SV_blank>data<S2SV_blank>mode\" ; else if ( test_opt ( sb , DATA_FLAGS ) == EXT4_MOUNT_ORDERED_DATA ) descr = \"<S2SV_blank>ordered<S2SV_blank>data<S2SV_blank>mode\" ; else descr = \"<S2SV_blank>writeback<S2SV_blank>data<S2SV_blank>mode\" ; } else descr = \"out<S2SV_blank>journal\" ; if ( test_opt ( sb , DISCARD ) ) { struct request_queue * q = bdev_get_queue ( sb -> s_bdev ) ; if ( ! blk_queue_discard ( q ) ) ext4_msg ( sb , KERN_WARNING , \"mounting<S2SV_blank>with<S2SV_blank>\\\\\"discard\\\\\"<S2SV_blank>option,<S2SV_blank>but<S2SV_blank>\" \"the<S2SV_blank>device<S2SV_blank>does<S2SV_blank>not<S2SV_blank>support<S2SV_blank>discard\" ) ; } if ( ___ratelimit ( & ext4_mount_msg_ratelimit , \"EXT4-fs<S2SV_blank>mount\" ) ) ext4_msg ( sb , KERN_INFO , \"mounted<S2SV_blank>filesystem<S2SV_blank>with%s.<S2SV_blank>\" \"Opts:<S2SV_blank>%s%s%s\" , descr , sbi -> s_es -> s_mount_opts , * sbi -> s_es -> s_mount_opts ? \";<S2SV_blank>\" : \"\" , orig_data ) ; if ( es -> s_error_count ) mod_timer ( & sbi -> s_err_report , jiffies + 300 * HZ ) ; ratelimit_state_init ( & sbi -> s_err_ratelimit_state , 5 * HZ , 10 ) ; ratelimit_state_init ( & sbi -> s_warning_ratelimit_state , 5 * HZ , 10 ) ; ratelimit_state_init ( & sbi -> s_msg_ratelimit_state , 5 * HZ , 10 ) ; kfree ( orig_data ) ; return 0 ; cantfind_ext4 : if ( ! silent ) ext4_msg ( sb , KERN_ERR , \"VFS:<S2SV_blank>Can\\'t<S2SV_blank>find<S2SV_blank>ext4<S2SV_blank>filesystem\" ) ; goto failed_mount ; # ifdef CONFIG_QUOTA failed_mount8 : ext4_unregister_sysfs ( sb ) ; # endif failed_mount7 : ext4_unregister_li_request ( sb ) ; failed_mount6 : ext4_mb_release ( sb ) ; if ( sbi -> s_flex_groups ) kvfree ( sbi -> s_flex_groups ) ; percpu_counter_destroy ( & sbi -> s_freeclusters_counter ) ; percpu_counter_destroy ( & sbi -> s_freeinodes_counter ) ; percpu_counter_destroy ( & sbi -> s_dirs_counter ) ; percpu_counter_destroy ( & sbi -> s_dirtyclusters_counter ) ; failed_mount5 : ext4_ext_release ( sb ) ; ext4_release_system_zone ( sb ) ; failed_mount4a : dput ( sb -> s_root ) ; sb -> s_root = NULL ; failed_mount4 : ext4_msg ( sb , KERN_ERR , \"mount<S2SV_blank>failed\" ) ; if ( EXT4_SB ( sb ) -> rsv_conversion_wq ) destroy_workqueue ( EXT4_SB ( sb ) -> rsv_conversion_wq ) ; <S2SV_StartBug> failed_mount_wq : <S2SV_EndBug> if ( sbi -> s_journal ) { jbd2_journal_destroy ( sbi -> s_journal ) ; sbi -> s_journal = NULL ; } failed_mount3a : ext4_es_unregister_shrinker ( sbi ) ; failed_mount3 : del_timer_sync ( & sbi -> s_err_report ) ; if ( sbi -> s_mmp_tsk ) kthread_stop ( sbi -> s_mmp_tsk ) ; failed_mount2 : for ( i = 0 ; i < db_count ; i ++ ) brelse ( sbi -> s_group_desc [ i ] ) ; kvfree ( sbi -> s_group_desc ) ; failed_mount : if ( sbi -> s_chksum_driver ) crypto_free_shash ( sbi -> s_chksum_driver ) ; # ifdef CONFIG_QUOTA for ( i = 0 ; i < EXT4_MAXQUOTAS ; i ++ ) kfree ( sbi -> s_qf_names [ i ] ) ; # endif ext4_blkdev_remove ( sbi ) ; brelse ( bh ) ; out_fail : sb -> s_fs_info = NULL ; kfree ( sbi -> s_blockgroup_lock ) ; kfree ( sbi ) ; out_free_orig : kfree ( orig_data ) ; return err ? err : ret ; }\n",
      "fixed_code": "<S2SV_ModStart> = ext4_xattr_create_cache ( <S2SV_ModEnd> ) ; if <S2SV_ModStart> ; failed_mount_wq : if ( sbi -> s_mb_cache ) { ext4_xattr_destroy_cache ( sbi -> s_mb_cache ) ; sbi -> s_mb_cache = NULL ; }\n",
      "source_code_length": 30182,
      "target_code_length": 206,
      "vulnerability_patterns": {
        "buffer_overflow": 1,
        "use_after_free": 6,
        "integer_overflow": 4,
        "null_pointer": 278,
        "sql_injection": 2,
        "total": 291
      },
      "total_patterns": 291,
      "original_address": "https://github.com/torvalds/linux/commit/82939d7999dfc1f1998c4b1c12e2f19edbdff272",
      "discovery_time": "2016-10-16T21:59Z",
      "project_commit_id": "torvalds@linux/82939d7999dfc1f1998c4b1c12e2f19edbdff272",
      "extraction_time": "2025-08-31T15:41:49.189342",
      "label": 1,
      "vulnerability_type": "unknown",
      "difficulty_level": "advanced",
      "risk_factors": [
        "sql_injection",
        "buffer_overflow",
        "use_after_free"
      ],
      "attack_vectors": [
        "fuzzing",
        "code_analysis",
        "reverse_engineering"
      ],
      "mitigation_strategies": [
        "dynamic_analysis",
        "static_analysis",
        "fuzzing",
        "code_review",
        "secure_coding_practices"
      ],
      "code_differences": {
        "has_differences": true,
        "source_lines": 2,
        "target_lines": 2,
        "character_differences": 29976,
        "similarity_percentage": 2.4179620034542317
      },
      "vulnerability_location": {
        "vulnerability_present": true,
        "fix_applied": true,
        "code_changed": true,
        "estimated_lines_changed": 0
      }
    },
    {
      "cve_id": "CVE-2016-2184",
      "cwe_id": "CWE-000",
      "cwe_name": "Unknown/Uncategorized",
      "project": "torvalds",
      "severity": "critical",
      "weaponization_score": 7.0,
      "is_critical": true,
      "is_weaponizable": true,
      "is_high_priority_project": false,
      "vulnerable_code": "CWE-000 static int create_fixed_stream_quirk ( struct snd_usb_audio * chip , struct usb_interface * iface , struct usb_driver * driver , const struct snd_usb_audio_quirk * quirk ) { struct audioformat * fp ; struct usb_host_interface * alts ; struct usb_interface_descriptor * altsd ; int stream , err ; unsigned * rate_table = NULL ; fp = kmemdup ( quirk -> data , sizeof ( * fp ) , GFP_KERNEL ) ; if ( ! fp ) { usb_audio_err ( chip , \"cannot<S2SV_blank>memdup\\\\n\" ) ; return - ENOMEM ; } if ( fp -> nr_rates > MAX_NR_RATES ) { kfree ( fp ) ; return - EINVAL ; } if ( fp -> nr_rates > 0 ) { rate_table = kmemdup ( fp -> rate_table , sizeof ( int ) * fp -> nr_rates , GFP_KERNEL ) ; if ( ! rate_table ) { kfree ( fp ) ; return - ENOMEM ; } fp -> rate_table = rate_table ; } stream = ( fp -> endpoint & USB_DIR_IN ) ? SNDRV_PCM_STREAM_CAPTURE : SNDRV_PCM_STREAM_PLAYBACK ; err = snd_usb_add_audio_stream ( chip , stream , fp ) ; if ( err < 0 ) { kfree ( fp ) ; kfree ( rate_table ) ; return err ; } if ( fp -> iface != get_iface_desc ( & iface -> altsetting [ 0 ] ) -> bInterfaceNumber || fp -> altset_idx >= iface -> num_altsetting ) { kfree ( fp ) ; kfree ( rate_table ) ; return - EINVAL ; } alts = & iface -> altsetting [ fp -> altset_idx ] ; altsd = get_iface_desc ( alts ) ; <S2SV_StartBug> fp -> protocol = altsd -> bInterfaceProtocol ; <S2SV_EndBug> if ( fp -> datainterval == 0 ) fp -> datainterval = snd_usb_parse_datainterval ( chip , alts ) ; if ( fp -> maxpacksize == 0 ) fp -> maxpacksize = le16_to_cpu ( get_endpoint ( alts , 0 ) -> wMaxPacketSize ) ; usb_set_interface ( chip -> dev , fp -> iface , 0 ) ; snd_usb_init_pitch ( chip , fp -> iface , alts , fp ) ; snd_usb_init_sample_rate ( chip , fp -> iface , alts , fp , fp -> rate_max ) ; return 0 ; }\n",
      "fixed_code": "<S2SV_ModStart> alts ) ; if ( altsd -> bNumEndpoints < 1 ) { kfree ( fp ) ; kfree ( rate_table ) ; return - EINVAL ; }\n",
      "source_code_length": 1768,
      "target_code_length": 119,
      "vulnerability_patterns": {
        "use_after_free": 6,
        "null_pointer": 30,
        "total": 36
      },
      "total_patterns": 36,
      "original_address": "https://github.com/torvalds/linux/commit/0f886ca12765d20124bd06291c82951fd49a33be",
      "discovery_time": "2016-04-27T17:59Z",
      "project_commit_id": "torvalds@linux/0f886ca12765d20124bd06291c82951fd49a33be",
      "extraction_time": "2025-08-31T15:41:49.189519",
      "label": 1,
      "vulnerability_type": "unknown/uncategorized",
      "difficulty_level": "advanced",
      "risk_factors": [
        "use_after_free"
      ],
      "attack_vectors": [
        "fuzzing",
        "code_analysis",
        "reverse_engineering"
      ],
      "mitigation_strategies": [
        "dynamic_analysis",
        "static_analysis",
        "fuzzing",
        "code_review",
        "secure_coding_practices"
      ],
      "code_differences": {
        "has_differences": true,
        "source_lines": 2,
        "target_lines": 2,
        "character_differences": 1649,
        "similarity_percentage": 17.97752808988764
      },
      "vulnerability_location": {
        "vulnerability_present": true,
        "fix_applied": true,
        "code_changed": true,
        "estimated_lines_changed": 0
      }
    },
    {
      "cve_id": "CVE-2016-1621",
      "cwe_id": "CWE-119",
      "cwe_name": "Buffer Overflow",
      "project": "external",
      "severity": "critical",
      "weaponization_score": 7.0,
      "is_critical": true,
      "is_weaponizable": true,
      "is_high_priority_project": false,
      "vulnerable_code": "CWE-119 int main ( int argc , char * * argv ) { int frame_cnt = 0 ; FILE * outfile = NULL ; vpx_codec_ctx_t codec ; const VpxInterface * decoder = NULL ; VpxVideoReader * reader = NULL ; const VpxVideoInfo * info = NULL ; int n = 0 ; int m = 0 ; int is_range = 0 ; char * nptr = NULL ; exec_name = argv [ 0 ] ; if ( argc != 4 ) die ( \"Invalid<S2SV_blank>number<S2SV_blank>of<S2SV_blank>arguments.\" ) ; reader = vpx_video_reader_open ( argv [ 1 ] ) ; if ( ! reader ) die ( \"Failed<S2SV_blank>to<S2SV_blank>open<S2SV_blank>%s<S2SV_blank>for<S2SV_blank>reading.\" , argv [ 1 ] ) ; if ( ! ( outfile = fopen ( argv [ 2 ] , \"wb\" ) ) ) die ( \"Failed<S2SV_blank>to<S2SV_blank>open<S2SV_blank>%s<S2SV_blank>for<S2SV_blank>writing.\" , argv [ 2 ] ) ; n = strtol ( argv [ 3 ] , & nptr , 0 ) ; m = strtol ( nptr + 1 , NULL , 0 ) ; is_range = ( * nptr == '-' ) ; if ( ! n || ! m || ( * nptr != '-' && * nptr != '/' ) ) die ( \"Couldn\\'t<S2SV_blank>parse<S2SV_blank>pattern<S2SV_blank>%s.\\\\n\" , argv [ 3 ] ) ; info = vpx_video_reader_get_info ( reader ) ; decoder = get_vpx_decoder_by_fourcc ( info -> codec_fourcc ) ; if ( ! decoder ) die ( \"Unknown<S2SV_blank>input<S2SV_blank>codec.\" ) ; <S2SV_StartBug> printf ( \"Using<S2SV_blank>%s\\\\n\" , vpx_codec_iface_name ( decoder -> interface ( ) ) ) ; <S2SV_EndBug> <S2SV_StartBug> if ( vpx_codec_dec_init ( & codec , decoder -> interface ( ) , NULL , 0 ) ) <S2SV_EndBug> die_codec ( & codec , \"Failed<S2SV_blank>to<S2SV_blank>initialize<S2SV_blank>decoder.\" ) ; while ( vpx_video_reader_read_frame ( reader ) ) { vpx_codec_iter_t iter = NULL ; vpx_image_t * img = NULL ; size_t frame_size = 0 ; int skip ; const unsigned char * frame = vpx_video_reader_get_frame ( reader , & frame_size ) ; if ( vpx_codec_decode ( & codec , frame , ( unsigned int ) frame_size , NULL , 0 ) ) die_codec ( & codec , \"Failed<S2SV_blank>to<S2SV_blank>decode<S2SV_blank>frame.\" ) ; ++ frame_cnt ; skip = ( is_range && frame_cnt >= n && frame_cnt <= m ) || ( ! is_range && m - ( frame_cnt - 1 ) % m <= n ) ; if ( ! skip ) { putc ( '.' , stdout ) ; while ( ( img = vpx_codec_get_frame ( & codec , & iter ) ) != NULL ) vpx_img_write ( img , outfile ) ; } else { putc ( 'X' , stdout ) ; } fflush ( stdout ) ; } printf ( \"Processed<S2SV_blank>%d<S2SV_blank>frames.\\\\n\" , frame_cnt ) ; if ( vpx_codec_destroy ( & codec ) ) die_codec ( & codec , \"Failed<S2SV_blank>to<S2SV_blank>destroy<S2SV_blank>codec.\" ) ; printf ( \"Play:<S2SV_blank>ffplay<S2SV_blank>-f<S2SV_blank>rawvideo<S2SV_blank>-pix_fmt<S2SV_blank>yuv420p<S2SV_blank>-s<S2SV_blank>%dx%d<S2SV_blank>%s\\\\n\" , info -> frame_width , info -> frame_height , argv [ 2 ] ) ; vpx_video_reader_close ( reader ) ; fclose ( outfile ) ; return EXIT_SUCCESS ; }\n",
      "fixed_code": "<S2SV_ModStart> ( decoder -> codec_interface <S2SV_ModEnd> ( ) ) <S2SV_ModStart> , decoder -> codec_interface <S2SV_ModEnd> ( ) ,\n",
      "source_code_length": 2710,
      "target_code_length": 130,
      "vulnerability_patterns": {
        "integer_overflow": 2,
        "null_pointer": 190,
        "total": 192
      },
      "total_patterns": 192,
      "original_address": "https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426",
      "discovery_time": "2016-03-12T21:59Z",
      "project_commit_id": "external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426",
      "extraction_time": "2025-08-31T15:41:49.189543",
      "label": 1,
      "vulnerability_type": "buffer_overflow",
      "difficulty_level": "advanced",
      "risk_factors": [
        "system_crash",
        "memory_corruption",
        "arbitrary_code_execution"
      ],
      "attack_vectors": [
        "memory_manipulation",
        "malicious_input",
        "code_analysis",
        "buffer_overflow",
        "reverse_engineering",
        "fuzzing"
      ],
      "mitigation_strategies": [
        "safe_string_functions",
        "dynamic_analysis",
        "code_review",
        "static_analysis",
        "memory_safety_checks",
        "input_validation",
        "fuzzing",
        "bounds_checking",
        "secure_coding_practices"
      ],
      "code_differences": {
        "has_differences": true,
        "source_lines": 2,
        "target_lines": 2,
        "character_differences": 2580,
        "similarity_percentage": 4.464285714285714
      },
      "vulnerability_location": {
        "vulnerability_present": true,
        "fix_applied": true,
        "code_changed": true,
        "estimated_lines_changed": 0
      }
    },
    {
      "cve_id": "CVE-2015-3905",
      "cwe_id": "CWE-119",
      "cwe_name": "Buffer Overflow",
      "project": "kohler",
      "severity": "critical",
      "weaponization_score": 7.0,
      "is_critical": true,
      "is_weaponizable": true,
      "is_high_priority_project": false,
      "vulnerable_code": "CWE-119 int main ( int argc , char * argv [ ] ) { int i , c ; FILE * ifp = 0 , * ofp = 0 ; const char * ifp_filename = \"<stdin>\" ; const char * ofp_filename = \"<stdout>\" ; const char * set_font_name = 0 ; struct font_reader fr ; uint32_t rfork_len ; int raw = 0 , macbinary = 1 , applesingle = 0 , appledouble = 0 , binhex = 0 ; Clp_Parser * clp = Clp_NewParser ( argc , ( const char * const * ) argv , sizeof ( options ) / sizeof ( options [ 0 ] ) , options ) ; program_name = Clp_ProgramName ( clp ) ; while ( 1 ) { int opt = Clp_Next ( clp ) ; switch ( opt ) { case RAW_OPT : raw = 1 ; macbinary = applesingle = appledouble = binhex = 0 ; break ; case MACBINARY_OPT : macbinary = 1 ; raw = applesingle = appledouble = binhex = 0 ; break ; case APPLESINGLE_OPT : applesingle = 1 ; raw = macbinary = appledouble = binhex = 0 ; break ; case APPLEDOUBLE_OPT : appledouble = 1 ; raw = macbinary = applesingle = binhex = 0 ; break ; case BINHEX_OPT : binhex = 1 ; raw = macbinary = applesingle = appledouble = 0 ; break ; output_file : case OUTPUT_OPT : if ( ofp ) fatal_error ( \"output<S2SV_blank>file<S2SV_blank>already<S2SV_blank>specified\" ) ; if ( strcmp ( clp -> vstr , \"-\" ) == 0 ) ofp = stdout ; else { ofp_filename = clp -> vstr ; ofp = fopen ( ofp_filename , \"wb\" ) ; if ( ! ofp ) fatal_error ( \"%s:<S2SV_blank>%s\" , ofp_filename , strerror ( errno ) ) ; } break ; case FILENAME_OPT : if ( set_font_name ) fatal_error ( \"Macintosh<S2SV_blank>font<S2SV_blank>filename<S2SV_blank>already<S2SV_blank>specified\" ) ; set_font_name = clp -> vstr ; break ; case HELP_OPT : usage ( ) ; exit ( 0 ) ; break ; case VERSION_OPT : printf ( \"t1mac<S2SV_blank>(LCDF<S2SV_blank>t1utils)<S2SV_blank>%s\\\\n\" , VERSION ) ; <S2SV_StartBug> printf ( \"Copyright<S2SV_blank>(C)<S2SV_blank>2000-2010<S2SV_blank>Eddie<S2SV_blank>Kohler<S2SV_blank>et<S2SV_blank>al.\\\\n\\\\\\n<S2SV_blank>This<S2SV_blank>is<S2SV_blank>free<S2SV_blank>software;<S2SV_blank>see<S2SV_blank>the<S2SV_blank>source<S2SV_blank>for<S2SV_blank>copying<S2SV_blank>conditions.\\\\n\\\\\\n<S2SV_blank>There<S2SV_blank>is<S2SV_blank>NO<S2SV_blank>warranty,<S2SV_blank>not<S2SV_blank>even<S2SV_blank>for<S2SV_blank>merchantability<S2SV_blank>or<S2SV_blank>fitness<S2SV_blank>for<S2SV_blank>a\\\\n\\\\\\n<S2SV_blank>particular<S2SV_blank>purpose.\\\\n\" ) ; <S2SV_EndBug> exit ( 0 ) ; break ; case Clp_NotOption : if ( ifp && ofp ) fatal_error ( \"too<S2SV_blank>many<S2SV_blank>arguments\" ) ; else if ( ifp ) goto output_file ; if ( strcmp ( clp -> vstr , \"-\" ) == 0 ) ifp = stdin ; else { ifp_filename = clp -> vstr ; ifp = fopen ( clp -> vstr , \"r\" ) ; if ( ! ifp ) fatal_error ( \"%s:<S2SV_blank>%s\" , clp -> vstr , strerror ( errno ) ) ; } break ; case Clp_Done : goto done ; case Clp_BadOption : short_usage ( ) ; exit ( 1 ) ; break ; } } done : if ( ! ifp ) ifp = stdin ; if ( ! ofp ) ofp = stdout ; # if defined ( _MSDOS ) || defined ( _WIN32 ) _setmode ( _fileno ( ofp ) , _O_BINARY ) ; # endif fr . output_ascii = t1mac_output_ascii ; fr . output_binary = t1mac_output_binary ; fr . output_end = t1mac_output_end ; rfork_f = tmpfile ( ) ; if ( ! rfork_f ) fatal_error ( \"cannot<S2SV_blank>open<S2SV_blank>temorary<S2SV_blank>file:<S2SV_blank>%s\" , strerror ( errno ) ) ; for ( i = 0 ; i < RFORK_HEADERLEN ; i ++ ) putc ( 0 , rfork_f ) ; init_current_post ( ) ; c = getc ( ifp ) ; ungetc ( c , ifp ) ; if ( c == PFB_MARKER ) process_pfb ( ifp , ifp_filename , & fr ) ; else if ( c == '%' ) process_pfa ( ifp , ifp_filename , & fr ) ; else fatal_error ( \"%s<S2SV_blank>does<S2SV_blank>not<S2SV_blank>start<S2SV_blank>with<S2SV_blank>font<S2SV_blank>marker<S2SV_blank>(`%%\\'<S2SV_blank>or<S2SV_blank>0x80)\" , ifp_filename ) ; if ( ifp != stdin ) fclose ( ifp ) ; if ( nrsrc == 0 ) error ( \"no<S2SV_blank>POST<S2SV_blank>resources<S2SV_blank>written<S2SV_blank>--<S2SV_blank>are<S2SV_blank>you<S2SV_blank>sure<S2SV_blank>this<S2SV_blank>was<S2SV_blank>a<S2SV_blank>font?\" ) ; output_new_rsrc ( \"ICN#\" , 256 , 32 , ( const char * ) icon_bw_data , 256 ) ; output_new_rsrc ( \"FREF\" , 256 , 32 , \"LWFN\\\\0\\\\0\\\\0\" , 7 ) ; output_new_rsrc ( \"BNDL\" , 256 , 32 , \"T1UT\\\\0\\\\0\\\\0\\\\1FREF\\\\0\\\\0\\\\0\\\\0\\\\1\\\\0ICN#\\\\0\\\\0\\\\0\\\\0\\\\1\\\\0\" , 28 ) ; output_new_rsrc ( \"icl8\" , 256 , 32 , ( const char * ) icon_8_data , 1024 ) ; output_new_rsrc ( \"icl4\" , 256 , 32 , ( const char * ) icon_4_data , 512 ) ; output_new_rsrc ( \"ics#\" , 256 , 32 , ( const char * ) small_icon_bw_data , 64 ) ; output_new_rsrc ( \"ics8\" , 256 , 32 , ( const char * ) small_icon_8_data , 256 ) ; output_new_rsrc ( \"ics4\" , 256 , 32 , ( const char * ) small_icon_4_data , 128 ) ; output_new_rsrc ( \"T1UT\" , 0 , 0 , \"DConverted<S2SV_blank>by<S2SV_blank>t1mac<S2SV_blank>(t1utils)<S2SV_blank>\\\\251Eddie<S2SV_blank>Kohler<S2SV_blank>http://www.lcdf.org/type/\" , 69 ) ; rfork_len = complete_rfork ( ) ; if ( ! set_font_name && font_name ) { int part = 0 , len = 0 ; char * x , * s ; for ( x = s = font_name ; * s ; s ++ ) <S2SV_StartBug> if ( isupper ( * s ) || isdigit ( * s ) ) { <S2SV_EndBug> * x ++ = * s ; part ++ ; len = 1 ; <S2SV_StartBug> } else if ( islower ( * s ) ) { <S2SV_EndBug> if ( len < ( part <= 1 ? 5 : 3 ) ) * x ++ = * s ; len ++ ; } * x ++ = 0 ; set_font_name = font_name ; } else if ( ! set_font_name ) set_font_name = \"Unknown<S2SV_blank>Font\" ; if ( macbinary ) output_macbinary ( rfork_f , rfork_len , set_font_name , ofp ) ; else if ( raw ) output_raw ( rfork_f , rfork_len , ofp ) ; else if ( applesingle || appledouble ) output_applesingle ( rfork_f , rfork_len , set_font_name , ofp , appledouble ) ; else if ( binhex ) output_binhex ( rfork_f , rfork_len , set_font_name , ofp ) ; else fatal_error ( \"strange<S2SV_blank>output<S2SV_blank>format\" ) ; fclose ( rfork_f ) ; if ( ofp != stdout ) fclose ( ofp ) ; return 0 ; }\n",
      "fixed_code": "<S2SV_ModStart> ; printf ( \"Copyright<S2SV_blank>(C)<S2SV_blank>2000-2010<S2SV_blank>Eddie<S2SV_blank>Kohler<S2SV_blank>et<S2SV_blank>al.\\\\n\\\\\\nThis<S2SV_blank>is<S2SV_blank>free<S2SV_blank>software;<S2SV_blank>see<S2SV_blank>the<S2SV_blank>source<S2SV_blank>for<S2SV_blank>copying<S2SV_blank>conditions.\\\\n\\\\\\nThere<S2SV_blank>is<S2SV_blank>NO<S2SV_blank>warranty,<S2SV_blank>not<S2SV_blank>even<S2SV_blank>for<S2SV_blank>merchantability<S2SV_blank>or<S2SV_blank>fitness<S2SV_blank>for<S2SV_blank>a\\\\n\\\\\\nparticular<S2SV_blank>purpose.\\\\n\" <S2SV_ModEnd> ) ; exit <S2SV_ModStart> ( isupper ( ( unsigned char ) <S2SV_ModStart> || isdigit ( ( unsigned char ) <S2SV_ModStart> ( islower ( ( unsigned char )\n",
      "source_code_length": 5733,
      "target_code_length": 703,
      "vulnerability_patterns": {
        "integer_overflow": 8,
        "format_string": 2,
        "null_pointer": 19,
        "total": 29
      },
      "total_patterns": 29,
      "original_address": "https://github.com/kohler/t1utils/commit/6b9d1aafcb61a3663c883663eb19ccdbfcde8d33",
      "discovery_time": "2015-06-08T14:59Z",
      "project_commit_id": "kohler@t1utils/6b9d1aafcb61a3663c883663eb19ccdbfcde8d33",
      "extraction_time": "2025-08-31T15:41:49.189562",
      "label": 1,
      "vulnerability_type": "buffer_overflow",
      "difficulty_level": "advanced",
      "risk_factors": [
        "system_crash",
        "memory_corruption",
        "arbitrary_code_execution"
      ],
      "attack_vectors": [
        "memory_manipulation",
        "malicious_input",
        "code_analysis",
        "buffer_overflow",
        "reverse_engineering",
        "fuzzing"
      ],
      "mitigation_strategies": [
        "safe_string_functions",
        "dynamic_analysis",
        "code_review",
        "static_analysis",
        "memory_safety_checks",
        "input_validation",
        "fuzzing",
        "bounds_checking",
        "secure_coding_practices"
      ],
      "code_differences": {
        "has_differences": true,
        "source_lines": 2,
        "target_lines": 2,
        "character_differences": 5030,
        "similarity_percentage": 5.291005291005291
      },
      "vulnerability_location": {
        "vulnerability_present": true,
        "fix_applied": true,
        "code_changed": true,
        "estimated_lines_changed": 0
      }
    },
    {
      "cve_id": "CVE-2011-4098",
      "cwe_id": "CWE-119",
      "cwe_name": "Buffer Overflow",
      "project": "torvalds",
      "severity": "critical",
      "weaponization_score": 7.0,
      "is_critical": true,
      "is_weaponizable": true,
      "is_high_priority_project": false,
      "vulnerable_code": "CWE-119 static long gfs2_fallocate ( struct file * file , int mode , loff_t offset , loff_t len ) { struct inode * inode = file -> f_path . dentry -> d_inode ; struct gfs2_sbd * sdp = GFS2_SB ( inode ) ; struct gfs2_inode * ip = GFS2_I ( inode ) ; unsigned int data_blocks = 0 , ind_blocks = 0 , rblocks ; loff_t bytes , max_bytes ; struct gfs2_alloc * al ; int error ; loff_t bsize_mask = ~ ( ( loff_t ) sdp -> sd_sb . sb_bsize - 1 ) ; loff_t next = ( offset + len - 1 ) >> sdp -> sd_sb . sb_bsize_shift ; <S2SV_StartBug> next = ( next + 1 ) << sdp -> sd_sb . sb_bsize_shift ; <S2SV_EndBug> if ( mode & ~ FALLOC_FL_KEEP_SIZE ) return - EOPNOTSUPP ; offset &= bsize_mask ; len = next - offset ; bytes = sdp -> sd_max_rg_data * sdp -> sd_sb . sb_bsize / 2 ; if ( ! bytes ) bytes = UINT_MAX ; bytes &= bsize_mask ; if ( bytes == 0 ) bytes = sdp -> sd_sb . sb_bsize ; gfs2_holder_init ( ip -> i_gl , LM_ST_EXCLUSIVE , 0 , & ip -> i_gh ) ; error = gfs2_glock_nq ( & ip -> i_gh ) ; if ( unlikely ( error ) ) goto out_uninit ; if ( ! gfs2_write_alloc_required ( ip , offset , len ) ) goto out_unlock ; while ( len > 0 ) { if ( len < bytes ) bytes = len ; al = gfs2_alloc_get ( ip ) ; if ( ! al ) { error = - ENOMEM ; goto out_unlock ; } error = gfs2_quota_lock_check ( ip ) ; if ( error ) goto out_alloc_put ; retry : gfs2_write_calc_reserv ( ip , bytes , & data_blocks , & ind_blocks ) ; al -> al_requested = data_blocks + ind_blocks ; error = gfs2_inplace_reserve ( ip ) ; if ( error ) { if ( error == - ENOSPC && bytes > sdp -> sd_sb . sb_bsize ) { bytes >>= 1 ; bytes &= bsize_mask ; if ( bytes == 0 ) bytes = sdp -> sd_sb . sb_bsize ; goto retry ; } goto out_qunlock ; } max_bytes = bytes ; <S2SV_StartBug> calc_max_reserv ( ip , len , & max_bytes , & data_blocks , & ind_blocks ) ; <S2SV_EndBug> al -> al_requested = data_blocks + ind_blocks ; rblocks = RES_DINODE + ind_blocks + RES_STATFS + RES_QUOTA + RES_RG_HDR + gfs2_rg_blocks ( ip ) ; if ( gfs2_is_jdata ( ip ) ) rblocks += data_blocks ? data_blocks : 1 ; error = gfs2_trans_begin ( sdp , rblocks , PAGE_CACHE_SIZE / sdp -> sd_sb . sb_bsize ) ; if ( error ) goto out_trans_fail ; error = fallocate_chunk ( inode , offset , max_bytes , mode ) ; gfs2_trans_end ( sdp ) ; if ( error ) goto out_trans_fail ; len -= max_bytes ; offset += max_bytes ; gfs2_inplace_release ( ip ) ; gfs2_quota_unlock ( ip ) ; gfs2_alloc_put ( ip ) ; } goto out_unlock ; out_trans_fail : gfs2_inplace_release ( ip ) ; out_qunlock : gfs2_quota_unlock ( ip ) ; out_alloc_put : gfs2_alloc_put ( ip ) ; out_unlock : gfs2_glock_dq ( & ip -> i_gh ) ; out_uninit : gfs2_holder_uninit ( & ip -> i_gh ) ; return error ; }\n",
      "fixed_code": "<S2SV_ModStart> . sb_bsize_shift ; loff_t max_chunk_size = UINT_MAX & bsize_mask ; <S2SV_ModStart> ( ip , ( len > max_chunk_size ) ? max_chunk_size : len , <S2SV_ModEnd> & max_bytes ,\n",
      "source_code_length": 2645,
      "target_code_length": 184,
      "vulnerability_patterns": {
        "integer_overflow": 3,
        "null_pointer": 22,
        "total": 25
      },
      "total_patterns": 25,
      "original_address": "https://github.com/torvalds/linux/commit/64dd153c83743af81f20924c6343652d731eeecb",
      "discovery_time": "2013-06-08T13:05Z",
      "project_commit_id": "torvalds@linux/64dd153c83743af81f20924c6343652d731eeecb",
      "extraction_time": "2025-08-31T15:41:49.189611",
      "label": 1,
      "vulnerability_type": "buffer_overflow",
      "difficulty_level": "advanced",
      "risk_factors": [
        "system_crash",
        "memory_corruption",
        "arbitrary_code_execution"
      ],
      "attack_vectors": [
        "memory_manipulation",
        "malicious_input",
        "code_analysis",
        "buffer_overflow",
        "reverse_engineering",
        "fuzzing"
      ],
      "mitigation_strategies": [
        "safe_string_functions",
        "dynamic_analysis",
        "code_review",
        "static_analysis",
        "memory_safety_checks",
        "input_validation",
        "fuzzing",
        "bounds_checking",
        "secure_coding_practices"
      ],
      "code_differences": {
        "has_differences": true,
        "source_lines": 2,
        "target_lines": 2,
        "character_differences": 2461,
        "similarity_percentage": 14.782608695652174
      },
      "vulnerability_location": {
        "vulnerability_present": true,
        "fix_applied": true,
        "code_changed": true,
        "estimated_lines_changed": 0
      }
    },
    {
      "cve_id": "CVE-2021-32020",
      "cwe_id": "CWE-119",
      "cwe_name": "Buffer Overflow",
      "project": "FreeRTOS",
      "severity": "critical",
      "weaponization_score": 7.0,
      "is_critical": true,
      "is_weaponizable": true,
      "is_high_priority_project": false,
      "vulnerable_code": "CWE-119 void * pvPortMalloc ( size_t xWantedSize ) { BlockLink_t * pxBlock , * pxPreviousBlock , * pxNewBlockLink ; void * pvReturn = NULL ; vTaskSuspendAll ( ) ; { if ( pxEnd == NULL ) { prvHeapInit ( ) ; } else { mtCOVERAGE_TEST_MARKER ( ) ; } if ( ( xWantedSize & xBlockAllocatedBit ) == 0 ) { <S2SV_StartBug> if ( xWantedSize > 0 ) <S2SV_EndBug> { xWantedSize += xHeapStructSize ; if ( ( xWantedSize & portBYTE_ALIGNMENT_MASK ) != 0x00 ) { <S2SV_StartBug> xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) ) ; <S2SV_EndBug> configASSERT ( ( xWantedSize & portBYTE_ALIGNMENT_MASK ) == 0 ) ; } else { <S2SV_StartBug> mtCOVERAGE_TEST_MARKER ( ) ; <S2SV_EndBug> } } else { mtCOVERAGE_TEST_MARKER ( ) ; } if ( ( xWantedSize > 0 ) && ( xWantedSize <= xFreeBytesRemaining ) ) { pxPreviousBlock = & xStart ; pxBlock = xStart . pxNextFreeBlock ; while ( ( pxBlock -> xBlockSize < xWantedSize ) && ( pxBlock -> pxNextFreeBlock != NULL ) ) { pxPreviousBlock = pxBlock ; pxBlock = pxBlock -> pxNextFreeBlock ; } if ( pxBlock != pxEnd ) { pvReturn = ( void * ) ( ( ( uint8_t * ) pxPreviousBlock -> pxNextFreeBlock ) + xHeapStructSize ) ; pxPreviousBlock -> pxNextFreeBlock = pxBlock -> pxNextFreeBlock ; if ( ( pxBlock -> xBlockSize - xWantedSize ) > heapMINIMUM_BLOCK_SIZE ) { pxNewBlockLink = ( void * ) ( ( ( uint8_t * ) pxBlock ) + xWantedSize ) ; configASSERT ( ( ( ( size_t ) pxNewBlockLink ) & portBYTE_ALIGNMENT_MASK ) == 0 ) ; pxNewBlockLink -> xBlockSize = pxBlock -> xBlockSize - xWantedSize ; pxBlock -> xBlockSize = xWantedSize ; prvInsertBlockIntoFreeList ( pxNewBlockLink ) ; } else { mtCOVERAGE_TEST_MARKER ( ) ; } xFreeBytesRemaining -= pxBlock -> xBlockSize ; if ( xFreeBytesRemaining < xMinimumEverFreeBytesRemaining ) { xMinimumEverFreeBytesRemaining = xFreeBytesRemaining ; } else { mtCOVERAGE_TEST_MARKER ( ) ; } pxBlock -> xBlockSize |= xBlockAllocatedBit ; pxBlock -> pxNextFreeBlock = NULL ; xNumberOfSuccessfulAllocations ++ ; } else { mtCOVERAGE_TEST_MARKER ( ) ; } } else { mtCOVERAGE_TEST_MARKER ( ) ; } } else { mtCOVERAGE_TEST_MARKER ( ) ; } traceMALLOC ( pvReturn , xWantedSize ) ; } ( void ) xTaskResumeAll ( ) ; # if ( configUSE_MALLOC_FAILED_HOOK == 1 ) { if ( pvReturn == NULL ) { extern void vApplicationMallocFailedHook ( void ) ; vApplicationMallocFailedHook ( ) ; } else { mtCOVERAGE_TEST_MARKER ( ) ; } } # endif configASSERT ( ( ( ( size_t ) pvReturn ) & ( size_t ) portBYTE_ALIGNMENT_MASK ) == 0 ) ; return pvReturn ; }\n",
      "fixed_code": "<S2SV_ModStart> { if ( ( <S2SV_ModStart> xWantedSize > 0 ) && ( ( xWantedSize + xHeapStructSize ) > xWantedSize ) <S2SV_ModStart> 0x00 ) { if ( ( xWantedSize + <S2SV_ModEnd> ( portBYTE_ALIGNMENT - <S2SV_ModStart> portBYTE_ALIGNMENT_MASK ) ) ) > xWantedSize ) { xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) ) <S2SV_ModStart> } else { xWantedSize = 0 ; } } else { mtCOVERAGE_TEST_MARKER ( ) ; } } else { xWantedSize = 0 <S2SV_ModEnd> ; } if\n",
      "source_code_length": 2484,
      "target_code_length": 474,
      "vulnerability_patterns": {
        "integer_overflow": 4,
        "null_pointer": 15,
        "total": 19
      },
      "total_patterns": 19,
      "original_address": "https://github.com/FreeRTOS/FreeRTOS-Kernel/commit/c7a9a01c94987082b223d3e59969ede64363da63",
      "discovery_time": "2021-05-03T22:15Z",
      "project_commit_id": "FreeRTOS@FreeRTOS-Kernel/c7a9a01c94987082b223d3e59969ede64363da63",
      "extraction_time": "2025-08-31T15:41:49.189643",
      "label": 1,
      "vulnerability_type": "buffer_overflow",
      "difficulty_level": "advanced",
      "risk_factors": [
        "system_crash",
        "memory_corruption",
        "arbitrary_code_execution"
      ],
      "attack_vectors": [
        "memory_manipulation",
        "malicious_input",
        "code_analysis",
        "buffer_overflow",
        "reverse_engineering",
        "fuzzing"
      ],
      "mitigation_strategies": [
        "safe_string_functions",
        "dynamic_analysis",
        "code_review",
        "static_analysis",
        "memory_safety_checks",
        "input_validation",
        "fuzzing",
        "bounds_checking",
        "secure_coding_practices"
      ],
      "code_differences": {
        "has_differences": true,
        "source_lines": 2,
        "target_lines": 2,
        "character_differences": 2010,
        "similarity_percentage": 30.0
      },
      "vulnerability_location": {
        "vulnerability_present": true,
        "fix_applied": true,
        "code_changed": true,
        "estimated_lines_changed": 0
      }
    },
    {
      "cve_id": "CVE-2016-1621",
      "cwe_id": "CWE-119",
      "cwe_name": "Buffer Overflow",
      "project": "external",
      "severity": "critical",
      "weaponization_score": 7.0,
      "is_critical": true,
      "is_weaponizable": true,
      "is_high_priority_project": false,
      "vulnerable_code": "CWE-119 int main ( int argc , char * * argv ) { int frame_cnt = 0 ; FILE * outfile = NULL ; vpx_codec_ctx_t codec ; const VpxInterface * decoder = NULL ; VpxVideoReader * reader = NULL ; const VpxVideoInfo * info = NULL ; int n = 0 ; int m = 0 ; int is_range = 0 ; char * nptr = NULL ; exec_name = argv [ 0 ] ; if ( argc != 4 ) die ( \"Invalid<S2SV_blank>number<S2SV_blank>of<S2SV_blank>arguments.\" ) ; reader = vpx_video_reader_open ( argv [ 1 ] ) ; if ( ! reader ) die ( \"Failed<S2SV_blank>to<S2SV_blank>open<S2SV_blank>%s<S2SV_blank>for<S2SV_blank>reading.\" , argv [ 1 ] ) ; if ( ! ( outfile = fopen ( argv [ 2 ] , \"wb\" ) ) ) die ( \"Failed<S2SV_blank>to<S2SV_blank>open<S2SV_blank>%s<S2SV_blank>for<S2SV_blank>writing.\" , argv [ 2 ] ) ; n = strtol ( argv [ 3 ] , & nptr , 0 ) ; m = strtol ( nptr + 1 , NULL , 0 ) ; is_range = ( * nptr == '-' ) ; if ( ! n || ! m || ( * nptr != '-' && * nptr != '/' ) ) die ( \"Couldn\\'t<S2SV_blank>parse<S2SV_blank>pattern<S2SV_blank>%s.\\\\n\" , argv [ 3 ] ) ; info = vpx_video_reader_get_info ( reader ) ; decoder = get_vpx_decoder_by_fourcc ( info -> codec_fourcc ) ; if ( ! decoder ) die ( \"Unknown<S2SV_blank>input<S2SV_blank>codec.\" ) ; <S2SV_StartBug> printf ( \"Using<S2SV_blank>%s\\\\n\" , vpx_codec_iface_name ( decoder -> interface ( ) ) ) ; <S2SV_EndBug> <S2SV_StartBug> if ( vpx_codec_dec_init ( & codec , decoder -> interface ( ) , NULL , 0 ) ) <S2SV_EndBug> die_codec ( & codec , \"Failed<S2SV_blank>to<S2SV_blank>initialize<S2SV_blank>decoder.\" ) ; while ( vpx_video_reader_read_frame ( reader ) ) { vpx_codec_iter_t iter = NULL ; vpx_image_t * img = NULL ; size_t frame_size = 0 ; int skip ; const unsigned char * frame = vpx_video_reader_get_frame ( reader , & frame_size ) ; if ( vpx_codec_decode ( & codec , frame , ( unsigned int ) frame_size , NULL , 0 ) ) die_codec ( & codec , \"Failed<S2SV_blank>to<S2SV_blank>decode<S2SV_blank>frame.\" ) ; ++ frame_cnt ; skip = ( is_range && frame_cnt >= n && frame_cnt <= m ) || ( ! is_range && m - ( frame_cnt - 1 ) % m <= n ) ; if ( ! skip ) { putc ( '.' , stdout ) ; while ( ( img = vpx_codec_get_frame ( & codec , & iter ) ) != NULL ) vpx_img_write ( img , outfile ) ; } else { putc ( 'X' , stdout ) ; } fflush ( stdout ) ; } printf ( \"Processed<S2SV_blank>%d<S2SV_blank>frames.\\\\n\" , frame_cnt ) ; if ( vpx_codec_destroy ( & codec ) ) die_codec ( & codec , \"Failed<S2SV_blank>to<S2SV_blank>destroy<S2SV_blank>codec.\" ) ; printf ( \"Play:<S2SV_blank>ffplay<S2SV_blank>-f<S2SV_blank>rawvideo<S2SV_blank>-pix_fmt<S2SV_blank>yuv420p<S2SV_blank>-s<S2SV_blank>%dx%d<S2SV_blank>%s\\\\n\" , info -> frame_width , info -> frame_height , argv [ 2 ] ) ; vpx_video_reader_close ( reader ) ; fclose ( outfile ) ; return EXIT_SUCCESS ; }\n",
      "fixed_code": "<S2SV_ModStart> ( decoder -> codec_interface <S2SV_ModEnd> ( ) ) <S2SV_ModStart> , decoder -> codec_interface <S2SV_ModEnd> ( ) ,\n",
      "source_code_length": 2710,
      "target_code_length": 130,
      "vulnerability_patterns": {
        "integer_overflow": 5,
        "null_pointer": 81,
        "total": 86
      },
      "total_patterns": 86,
      "original_address": "https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426",
      "discovery_time": "2016-03-12T21:59Z",
      "project_commit_id": "external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426",
      "extraction_time": "2025-08-31T15:41:49.189669",
      "label": 1,
      "vulnerability_type": "buffer_overflow",
      "difficulty_level": "advanced",
      "risk_factors": [
        "system_crash",
        "memory_corruption",
        "arbitrary_code_execution"
      ],
      "attack_vectors": [
        "memory_manipulation",
        "malicious_input",
        "code_analysis",
        "buffer_overflow",
        "reverse_engineering",
        "fuzzing"
      ],
      "mitigation_strategies": [
        "safe_string_functions",
        "dynamic_analysis",
        "code_review",
        "static_analysis",
        "memory_safety_checks",
        "input_validation",
        "fuzzing",
        "bounds_checking",
        "secure_coding_practices"
      ],
      "code_differences": {
        "has_differences": true,
        "source_lines": 2,
        "target_lines": 2,
        "character_differences": 2580,
        "similarity_percentage": 4.464285714285714
      },
      "vulnerability_location": {
        "vulnerability_present": true,
        "fix_applied": true,
        "code_changed": true,
        "estimated_lines_changed": 0
      }
    },
    {
      "cve_id": "CVE-2016-1621",
      "cwe_id": "CWE-119",
      "cwe_name": "Buffer Overflow",
      "project": "external",
      "severity": "critical",
      "weaponization_score": 7.0,
      "is_critical": true,
      "is_weaponizable": true,
      "is_high_priority_project": false,
      "vulnerable_code": "CWE-119 int main ( int argc , char * * argv ) { int frame_cnt = 0 ; FILE * outfile = NULL ; vpx_codec_ctx_t codec ; const VpxInterface * decoder = NULL ; VpxVideoReader * reader = NULL ; const VpxVideoInfo * info = NULL ; int n = 0 ; int m = 0 ; int is_range = 0 ; char * nptr = NULL ; exec_name = argv [ 0 ] ; if ( argc != 4 ) die ( \"Invalid<S2SV_blank>number<S2SV_blank>of<S2SV_blank>arguments.\" ) ; reader = vpx_video_reader_open ( argv [ 1 ] ) ; if ( ! reader ) die ( \"Failed<S2SV_blank>to<S2SV_blank>open<S2SV_blank>%s<S2SV_blank>for<S2SV_blank>reading.\" , argv [ 1 ] ) ; if ( ! ( outfile = fopen ( argv [ 2 ] , \"wb\" ) ) ) die ( \"Failed<S2SV_blank>to<S2SV_blank>open<S2SV_blank>%s<S2SV_blank>for<S2SV_blank>writing.\" , argv [ 2 ] ) ; n = strtol ( argv [ 3 ] , & nptr , 0 ) ; m = strtol ( nptr + 1 , NULL , 0 ) ; is_range = ( * nptr == '-' ) ; if ( ! n || ! m || ( * nptr != '-' && * nptr != '/' ) ) die ( \"Couldn\\'t<S2SV_blank>parse<S2SV_blank>pattern<S2SV_blank>%s.\\\\n\" , argv [ 3 ] ) ; info = vpx_video_reader_get_info ( reader ) ; decoder = get_vpx_decoder_by_fourcc ( info -> codec_fourcc ) ; if ( ! decoder ) die ( \"Unknown<S2SV_blank>input<S2SV_blank>codec.\" ) ; <S2SV_StartBug> printf ( \"Using<S2SV_blank>%s\\\\n\" , vpx_codec_iface_name ( decoder -> interface ( ) ) ) ; <S2SV_EndBug> <S2SV_StartBug> if ( vpx_codec_dec_init ( & codec , decoder -> interface ( ) , NULL , 0 ) ) <S2SV_EndBug> die_codec ( & codec , \"Failed<S2SV_blank>to<S2SV_blank>initialize<S2SV_blank>decoder.\" ) ; while ( vpx_video_reader_read_frame ( reader ) ) { vpx_codec_iter_t iter = NULL ; vpx_image_t * img = NULL ; size_t frame_size = 0 ; int skip ; const unsigned char * frame = vpx_video_reader_get_frame ( reader , & frame_size ) ; if ( vpx_codec_decode ( & codec , frame , ( unsigned int ) frame_size , NULL , 0 ) ) die_codec ( & codec , \"Failed<S2SV_blank>to<S2SV_blank>decode<S2SV_blank>frame.\" ) ; ++ frame_cnt ; skip = ( is_range && frame_cnt >= n && frame_cnt <= m ) || ( ! is_range && m - ( frame_cnt - 1 ) % m <= n ) ; if ( ! skip ) { putc ( '.' , stdout ) ; while ( ( img = vpx_codec_get_frame ( & codec , & iter ) ) != NULL ) vpx_img_write ( img , outfile ) ; } else { putc ( 'X' , stdout ) ; } fflush ( stdout ) ; } printf ( \"Processed<S2SV_blank>%d<S2SV_blank>frames.\\\\n\" , frame_cnt ) ; if ( vpx_codec_destroy ( & codec ) ) die_codec ( & codec , \"Failed<S2SV_blank>to<S2SV_blank>destroy<S2SV_blank>codec.\" ) ; printf ( \"Play:<S2SV_blank>ffplay<S2SV_blank>-f<S2SV_blank>rawvideo<S2SV_blank>-pix_fmt<S2SV_blank>yuv420p<S2SV_blank>-s<S2SV_blank>%dx%d<S2SV_blank>%s\\\\n\" , info -> frame_width , info -> frame_height , argv [ 2 ] ) ; vpx_video_reader_close ( reader ) ; fclose ( outfile ) ; return EXIT_SUCCESS ; }\n",
      "fixed_code": "<S2SV_ModStart> ( decoder -> codec_interface <S2SV_ModEnd> ( ) ) <S2SV_ModStart> , decoder -> codec_interface <S2SV_ModEnd> ( ) ,\n",
      "source_code_length": 2710,
      "target_code_length": 130,
      "vulnerability_patterns": {
        "null_pointer": 13,
        "total": 13
      },
      "total_patterns": 13,
      "original_address": "https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426",
      "discovery_time": "2016-03-12T21:59Z",
      "project_commit_id": "external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426",
      "extraction_time": "2025-08-31T15:41:49.189685",
      "label": 1,
      "vulnerability_type": "buffer_overflow",
      "difficulty_level": "advanced",
      "risk_factors": [
        "system_crash",
        "memory_corruption",
        "arbitrary_code_execution"
      ],
      "attack_vectors": [
        "memory_manipulation",
        "malicious_input",
        "code_analysis",
        "buffer_overflow",
        "reverse_engineering",
        "fuzzing"
      ],
      "mitigation_strategies": [
        "safe_string_functions",
        "dynamic_analysis",
        "code_review",
        "static_analysis",
        "memory_safety_checks",
        "input_validation",
        "fuzzing",
        "bounds_checking",
        "secure_coding_practices"
      ],
      "code_differences": {
        "has_differences": true,
        "source_lines": 2,
        "target_lines": 2,
        "character_differences": 2580,
        "similarity_percentage": 4.464285714285714
      },
      "vulnerability_location": {
        "vulnerability_present": true,
        "fix_applied": true,
        "code_changed": true,
        "estimated_lines_changed": 0
      }
    },
    {
      "cve_id": "CVE-2018-7186",
      "cwe_id": "CWE-119",
      "cwe_name": "Buffer Overflow",
      "project": "DanBloomberg",
      "severity": "critical",
      "weaponization_score": 7.0,
      "is_critical": true,
      "is_weaponizable": true,
      "is_high_priority_project": false,
      "vulnerable_code": "CWE-119 l_int32 gplotAddPlot ( GPLOT * gplot , NUMA * nax , NUMA * nay , l_int32 plotstyle , const char * plottitle ) { <S2SV_StartBug> char buf [ L_BUF_SIZE ] ; <S2SV_EndBug> char emptystring [ ] = \"\" ; char * datastr , * title ; l_int32 n , i ; l_float32 valx , valy , startx , delx ; SARRAY * sa ; PROCNAME ( \"gplotAddPlot\" ) ; if ( ! gplot ) return ERROR_INT ( \"gplot<S2SV_blank>not<S2SV_blank>defined\" , procName , 1 ) ; if ( ! nay ) return ERROR_INT ( \"nay<S2SV_blank>not<S2SV_blank>defined\" , procName , 1 ) ; if ( plotstyle < 0 || plotstyle >= NUM_GPLOT_STYLES ) return ERROR_INT ( \"invalid<S2SV_blank>plotstyle\" , procName , 1 ) ; if ( ( n = numaGetCount ( nay ) ) == 0 ) return ERROR_INT ( \"no<S2SV_blank>points<S2SV_blank>to<S2SV_blank>plot\" , procName , 1 ) ; if ( nax && ( n != numaGetCount ( nax ) ) ) return ERROR_INT ( \"nax<S2SV_blank>and<S2SV_blank>nay<S2SV_blank>sizes<S2SV_blank>differ\" , procName , 1 ) ; if ( n == 1 && plotstyle == GPLOT_LINES ) { L_INFO ( \"only<S2SV_blank>1<S2SV_blank>pt;<S2SV_blank>changing<S2SV_blank>style<S2SV_blank>to<S2SV_blank>points\\\\n\" , procName ) ; plotstyle = GPLOT_POINTS ; } numaGetParameters ( nay , & startx , & delx ) ; numaAddNumber ( gplot -> plotstyles , plotstyle ) ; if ( plottitle ) { title = stringNew ( plottitle ) ; sarrayAddString ( gplot -> plottitles , title , L_INSERT ) ; } else { sarrayAddString ( gplot -> plottitles , emptystring , L_COPY ) ; } gplot -> nplots ++ ; <S2SV_StartBug> snprintf ( buf , L_BUF_SIZE , \"%s.data.%d\" , gplot -> rootname , gplot -> nplots ) ; <S2SV_EndBug> sarrayAddString ( gplot -> datanames , buf , L_COPY ) ; sa = sarrayCreate ( n ) ; for ( i = 0 ; i < n ; i ++ ) { if ( nax ) numaGetFValue ( nax , i , & valx ) ; else valx = startx + i * delx ; numaGetFValue ( nay , i , & valy ) ; <S2SV_StartBug> snprintf ( buf , L_BUF_SIZE , \"%f<S2SV_blank>%f\\\\n\" , valx , valy ) ; <S2SV_EndBug> sarrayAddString ( sa , buf , L_COPY ) ; } datastr = sarrayToString ( sa , 0 ) ; sarrayAddString ( gplot -> plotdata , datastr , L_INSERT ) ; sarrayDestroy ( & sa ) ; return 0 ; }\n",
      "fixed_code": "<S2SV_ModStart> char buf [ L_BUFSIZE <S2SV_ModEnd> ] ; char <S2SV_ModStart> ( buf , L_BUFSIZE <S2SV_ModEnd> , \"%s.data.%d\" , <S2SV_ModStart> ( buf , L_BUFSIZE <S2SV_ModEnd> , \"%f<S2SV_blank>%f\\\\n\" ,\n",
      "source_code_length": 2064,
      "target_code_length": 199,
      "vulnerability_patterns": {
        "integer_overflow": 2,
        "format_string": 2,
        "null_pointer": 12,
        "total": 16
      },
      "total_patterns": 16,
      "original_address": "https://github.com/DanBloomberg/leptonica/commit/ee301cb2029db8a6289c5295daa42bba7715e99a",
      "discovery_time": "2018-02-16T16:29Z",
      "project_commit_id": "DanBloomberg@leptonica/ee301cb2029db8a6289c5295daa42bba7715e99a",
      "extraction_time": "2025-08-31T15:41:49.189703",
      "label": 1,
      "vulnerability_type": "buffer_overflow",
      "difficulty_level": "advanced",
      "risk_factors": [
        "system_crash",
        "memory_corruption",
        "arbitrary_code_execution"
      ],
      "attack_vectors": [
        "memory_manipulation",
        "malicious_input",
        "code_analysis",
        "buffer_overflow",
        "reverse_engineering",
        "fuzzing"
      ],
      "mitigation_strategies": [
        "safe_string_functions",
        "dynamic_analysis",
        "code_review",
        "static_analysis",
        "memory_safety_checks",
        "input_validation",
        "fuzzing",
        "bounds_checking",
        "secure_coding_practices"
      ],
      "code_differences": {
        "has_differences": true,
        "source_lines": 2,
        "target_lines": 2,
        "character_differences": 1865,
        "similarity_percentage": 9.67741935483871
      },
      "vulnerability_location": {
        "vulnerability_present": true,
        "fix_applied": true,
        "code_changed": true,
        "estimated_lines_changed": 0
      }
    },
    {
      "cve_id": "CVE-2016-1621",
      "cwe_id": "CWE-119",
      "cwe_name": "Buffer Overflow",
      "project": "external",
      "severity": "critical",
      "weaponization_score": 7.0,
      "is_critical": true,
      "is_weaponizable": true,
      "is_high_priority_project": false,
      "vulnerable_code": "CWE-119 int main ( int argc , char * * argv ) { int frame_cnt = 0 ; FILE * outfile = NULL ; vpx_codec_ctx_t codec ; const VpxInterface * decoder = NULL ; VpxVideoReader * reader = NULL ; const VpxVideoInfo * info = NULL ; int n = 0 ; int m = 0 ; int is_range = 0 ; char * nptr = NULL ; exec_name = argv [ 0 ] ; if ( argc != 4 ) die ( \"Invalid<S2SV_blank>number<S2SV_blank>of<S2SV_blank>arguments.\" ) ; reader = vpx_video_reader_open ( argv [ 1 ] ) ; if ( ! reader ) die ( \"Failed<S2SV_blank>to<S2SV_blank>open<S2SV_blank>%s<S2SV_blank>for<S2SV_blank>reading.\" , argv [ 1 ] ) ; if ( ! ( outfile = fopen ( argv [ 2 ] , \"wb\" ) ) ) die ( \"Failed<S2SV_blank>to<S2SV_blank>open<S2SV_blank>%s<S2SV_blank>for<S2SV_blank>writing.\" , argv [ 2 ] ) ; n = strtol ( argv [ 3 ] , & nptr , 0 ) ; m = strtol ( nptr + 1 , NULL , 0 ) ; is_range = ( * nptr == '-' ) ; if ( ! n || ! m || ( * nptr != '-' && * nptr != '/' ) ) die ( \"Couldn\\'t<S2SV_blank>parse<S2SV_blank>pattern<S2SV_blank>%s.\\\\n\" , argv [ 3 ] ) ; info = vpx_video_reader_get_info ( reader ) ; decoder = get_vpx_decoder_by_fourcc ( info -> codec_fourcc ) ; if ( ! decoder ) die ( \"Unknown<S2SV_blank>input<S2SV_blank>codec.\" ) ; <S2SV_StartBug> printf ( \"Using<S2SV_blank>%s\\\\n\" , vpx_codec_iface_name ( decoder -> interface ( ) ) ) ; <S2SV_EndBug> <S2SV_StartBug> if ( vpx_codec_dec_init ( & codec , decoder -> interface ( ) , NULL , 0 ) ) <S2SV_EndBug> die_codec ( & codec , \"Failed<S2SV_blank>to<S2SV_blank>initialize<S2SV_blank>decoder.\" ) ; while ( vpx_video_reader_read_frame ( reader ) ) { vpx_codec_iter_t iter = NULL ; vpx_image_t * img = NULL ; size_t frame_size = 0 ; int skip ; const unsigned char * frame = vpx_video_reader_get_frame ( reader , & frame_size ) ; if ( vpx_codec_decode ( & codec , frame , ( unsigned int ) frame_size , NULL , 0 ) ) die_codec ( & codec , \"Failed<S2SV_blank>to<S2SV_blank>decode<S2SV_blank>frame.\" ) ; ++ frame_cnt ; skip = ( is_range && frame_cnt >= n && frame_cnt <= m ) || ( ! is_range && m - ( frame_cnt - 1 ) % m <= n ) ; if ( ! skip ) { putc ( '.' , stdout ) ; while ( ( img = vpx_codec_get_frame ( & codec , & iter ) ) != NULL ) vpx_img_write ( img , outfile ) ; } else { putc ( 'X' , stdout ) ; } fflush ( stdout ) ; } printf ( \"Processed<S2SV_blank>%d<S2SV_blank>frames.\\\\n\" , frame_cnt ) ; if ( vpx_codec_destroy ( & codec ) ) die_codec ( & codec , \"Failed<S2SV_blank>to<S2SV_blank>destroy<S2SV_blank>codec.\" ) ; printf ( \"Play:<S2SV_blank>ffplay<S2SV_blank>-f<S2SV_blank>rawvideo<S2SV_blank>-pix_fmt<S2SV_blank>yuv420p<S2SV_blank>-s<S2SV_blank>%dx%d<S2SV_blank>%s\\\\n\" , info -> frame_width , info -> frame_height , argv [ 2 ] ) ; vpx_video_reader_close ( reader ) ; fclose ( outfile ) ; return EXIT_SUCCESS ; }\n",
      "fixed_code": "<S2SV_ModStart> ( decoder -> codec_interface <S2SV_ModEnd> ( ) ) <S2SV_ModStart> , decoder -> codec_interface <S2SV_ModEnd> ( ) ,\n",
      "source_code_length": 2710,
      "target_code_length": 130,
      "vulnerability_patterns": {
        "integer_overflow": 6,
        "null_pointer": 10,
        "total": 16
      },
      "total_patterns": 16,
      "original_address": "https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426",
      "discovery_time": "2016-03-12T21:59Z",
      "project_commit_id": "external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426",
      "extraction_time": "2025-08-31T15:41:49.189726",
      "label": 1,
      "vulnerability_type": "buffer_overflow",
      "difficulty_level": "advanced",
      "risk_factors": [
        "system_crash",
        "memory_corruption",
        "arbitrary_code_execution"
      ],
      "attack_vectors": [
        "memory_manipulation",
        "malicious_input",
        "code_analysis",
        "buffer_overflow",
        "reverse_engineering",
        "fuzzing"
      ],
      "mitigation_strategies": [
        "safe_string_functions",
        "dynamic_analysis",
        "code_review",
        "static_analysis",
        "memory_safety_checks",
        "input_validation",
        "fuzzing",
        "bounds_checking",
        "secure_coding_practices"
      ],
      "code_differences": {
        "has_differences": true,
        "source_lines": 2,
        "target_lines": 2,
        "character_differences": 2580,
        "similarity_percentage": 4.464285714285714
      },
      "vulnerability_location": {
        "vulnerability_present": true,
        "fix_applied": true,
        "code_changed": true,
        "estimated_lines_changed": 0
      }
    },
    {
      "cve_id": "CVE-2020-12268",
      "cwe_id": "CWE-787",
      "cwe_name": "Out-of-bounds Write",
      "project": "ArtifexSoftware",
      "severity": "critical",
      "weaponization_score": 7.0,
      "is_critical": true,
      "is_weaponizable": true,
      "is_high_priority_project": false,
      "vulnerable_code": "CWE-787 int jbig2_image_compose ( Jbig2Ctx * ctx , Jbig2Image * dst , Jbig2Image * src , int x , int y , Jbig2ComposeOp op ) { uint32_t w , h ; uint32_t shift ; uint32_t leftbyte ; uint8_t * ss ; uint8_t * dd ; uint8_t leftmask , rightmask ; int early = x >= 0 ; int late ; uint32_t bytewidth ; uint32_t syoffset = 0 ; if ( src == NULL ) <S2SV_StartBug> return 0 ; <S2SV_EndBug> w = src -> width ; h = src -> height ; shift = ( x & 7 ) ; ss = src -> data - early ; if ( x < 0 ) { if ( w < ( uint32_t ) - x ) w = 0 ; else w += x ; ss += ( - x - 1 ) >> 3 ; x = 0 ; } if ( y < 0 ) { if ( h < ( uint32_t ) - y ) h = 0 ; else h += y ; syoffset = - y * src -> stride ; y = 0 ; } if ( ( uint32_t ) x + w > dst -> width ) { if ( dst -> width < ( uint32_t ) x ) w = 0 ; else w = dst -> width - x ; } if ( ( uint32_t ) y + h > dst -> height ) { if ( dst -> height < ( uint32_t ) y ) h = 0 ; else h = dst -> height - y ; } # ifdef JBIG2_DEBUG jbig2_error ( ctx , JBIG2_SEVERITY_DEBUG , - 1 , \"compositing<S2SV_blank>%dx%d<S2SV_blank>at<S2SV_blank>(%d,<S2SV_blank>%d)<S2SV_blank>after<S2SV_blank>clipping\" , w , h , x , y ) ; # endif if ( ( w <= 0 ) || ( h <= 0 ) ) { # ifdef JBIG2_DEBUG jbig2_error ( ctx , JBIG2_SEVERITY_DEBUG , - 1 , \"zero<S2SV_blank>clipping<S2SV_blank>region\" ) ; # endif return 0 ; } leftbyte = ( uint32_t ) x >> 3 ; dd = dst -> data + y * dst -> stride + leftbyte ; bytewidth = ( ( ( uint32_t ) x + w - 1 ) >> 3 ) - leftbyte + 1 ; leftmask = 255 >> ( x & 7 ) ; rightmask = ( ( ( x + w ) & 7 ) == 0 ) ? 255 : ~ ( 255 >> ( ( x + w ) & 7 ) ) ; if ( bytewidth == 1 ) leftmask &= rightmask ; late = ( ss + bytewidth >= src -> data + ( ( src -> width + 7 ) >> 3 ) ) ; ss += syoffset ; switch ( op ) { case JBIG2_COMPOSE_OR : jbig2_image_compose_opt_OR ( ss , dd , early , late , leftmask , rightmask , bytewidth , h , shift , dst -> stride , src -> stride ) ; break ; case JBIG2_COMPOSE_AND : jbig2_image_compose_opt_AND ( ss , dd , early , late , leftmask , rightmask , bytewidth , h , shift , dst -> stride , src -> stride ) ; break ; case JBIG2_COMPOSE_XOR : jbig2_image_compose_opt_XOR ( ss , dd , early , late , leftmask , rightmask , bytewidth , h , shift , dst -> stride , src -> stride ) ; break ; case JBIG2_COMPOSE_XNOR : jbig2_image_compose_opt_XNOR ( ss , dd , early , late , leftmask , rightmask , bytewidth , h , shift , dst -> stride , src -> stride ) ; break ; case JBIG2_COMPOSE_REPLACE : jbig2_image_compose_opt_REPLACE ( ss , dd , early , late , leftmask , rightmask , bytewidth , h , shift , dst -> stride , src -> stride ) ; break ; } return 0 ; }\n",
      "fixed_code": "<S2SV_ModStart> return 0 ; if ( ( UINT32_MAX - src -> width < ( x > 0 ? x : - x ) ) || ( UINT32_MAX - src -> height < ( y > 0 ? y : - y ) ) ) { # ifdef JBIG2_DEBUG jbig2_error ( ctx , JBIG2_SEVERITY_DEBUG , - 1 , \"overflow<S2SV_blank>in<S2SV_blank>compose_image\" ) ; # endif return 0 ; }\n",
      "source_code_length": 2575,
      "target_code_length": 288,
      "vulnerability_patterns": {
        "integer_overflow": 4,
        "null_pointer": 25,
        "total": 29
      },
      "total_patterns": 29,
      "original_address": "https://github.com/ArtifexSoftware/jbig2dec/commit/0726320a4b55078e9d8deb590e477d598b3da66e",
      "discovery_time": "2020-04-27T02:15Z",
      "project_commit_id": "ArtifexSoftware@jbig2dec/0726320a4b55078e9d8deb590e477d598b3da66e",
      "extraction_time": "2025-08-31T15:41:49.189743",
      "label": 1,
      "vulnerability_type": "out-of-bounds_write",
      "difficulty_level": "advanced",
      "risk_factors": [
        "system_crash",
        "memory_corruption",
        "arbitrary_code_execution"
      ],
      "attack_vectors": [
        "memory_manipulation",
        "malicious_input",
        "code_analysis",
        "buffer_overflow",
        "reverse_engineering",
        "fuzzing"
      ],
      "mitigation_strategies": [
        "safe_string_functions",
        "dynamic_analysis",
        "code_review",
        "static_analysis",
        "memory_safety_checks",
        "input_validation",
        "fuzzing",
        "bounds_checking",
        "secure_coding_practices"
      ],
      "code_differences": {
        "has_differences": true,
        "source_lines": 2,
        "target_lines": 2,
        "character_differences": 2287,
        "similarity_percentage": 32.58426966292135
      },
      "vulnerability_location": {
        "vulnerability_present": true,
        "fix_applied": true,
        "code_changed": true,
        "estimated_lines_changed": 0
      }
    },
    {
      "cve_id": "CVE-2016-1621",
      "cwe_id": "CWE-119",
      "cwe_name": "Buffer Overflow",
      "project": "external",
      "severity": "critical",
      "weaponization_score": 7.0,
      "is_critical": true,
      "is_weaponizable": true,
      "is_high_priority_project": false,
      "vulnerable_code": "CWE-119 int main ( int argc , char * * argv ) { int frame_cnt = 0 ; FILE * outfile = NULL ; vpx_codec_ctx_t codec ; const VpxInterface * decoder = NULL ; VpxVideoReader * reader = NULL ; const VpxVideoInfo * info = NULL ; int n = 0 ; int m = 0 ; int is_range = 0 ; char * nptr = NULL ; exec_name = argv [ 0 ] ; if ( argc != 4 ) die ( \"Invalid<S2SV_blank>number<S2SV_blank>of<S2SV_blank>arguments.\" ) ; reader = vpx_video_reader_open ( argv [ 1 ] ) ; if ( ! reader ) die ( \"Failed<S2SV_blank>to<S2SV_blank>open<S2SV_blank>%s<S2SV_blank>for<S2SV_blank>reading.\" , argv [ 1 ] ) ; if ( ! ( outfile = fopen ( argv [ 2 ] , \"wb\" ) ) ) die ( \"Failed<S2SV_blank>to<S2SV_blank>open<S2SV_blank>%s<S2SV_blank>for<S2SV_blank>writing.\" , argv [ 2 ] ) ; n = strtol ( argv [ 3 ] , & nptr , 0 ) ; m = strtol ( nptr + 1 , NULL , 0 ) ; is_range = ( * nptr == '-' ) ; if ( ! n || ! m || ( * nptr != '-' && * nptr != '/' ) ) die ( \"Couldn\\'t<S2SV_blank>parse<S2SV_blank>pattern<S2SV_blank>%s.\\\\n\" , argv [ 3 ] ) ; info = vpx_video_reader_get_info ( reader ) ; decoder = get_vpx_decoder_by_fourcc ( info -> codec_fourcc ) ; if ( ! decoder ) die ( \"Unknown<S2SV_blank>input<S2SV_blank>codec.\" ) ; <S2SV_StartBug> printf ( \"Using<S2SV_blank>%s\\\\n\" , vpx_codec_iface_name ( decoder -> interface ( ) ) ) ; <S2SV_EndBug> <S2SV_StartBug> if ( vpx_codec_dec_init ( & codec , decoder -> interface ( ) , NULL , 0 ) ) <S2SV_EndBug> die_codec ( & codec , \"Failed<S2SV_blank>to<S2SV_blank>initialize<S2SV_blank>decoder.\" ) ; while ( vpx_video_reader_read_frame ( reader ) ) { vpx_codec_iter_t iter = NULL ; vpx_image_t * img = NULL ; size_t frame_size = 0 ; int skip ; const unsigned char * frame = vpx_video_reader_get_frame ( reader , & frame_size ) ; if ( vpx_codec_decode ( & codec , frame , ( unsigned int ) frame_size , NULL , 0 ) ) die_codec ( & codec , \"Failed<S2SV_blank>to<S2SV_blank>decode<S2SV_blank>frame.\" ) ; ++ frame_cnt ; skip = ( is_range && frame_cnt >= n && frame_cnt <= m ) || ( ! is_range && m - ( frame_cnt - 1 ) % m <= n ) ; if ( ! skip ) { putc ( '.' , stdout ) ; while ( ( img = vpx_codec_get_frame ( & codec , & iter ) ) != NULL ) vpx_img_write ( img , outfile ) ; } else { putc ( 'X' , stdout ) ; } fflush ( stdout ) ; } printf ( \"Processed<S2SV_blank>%d<S2SV_blank>frames.\\\\n\" , frame_cnt ) ; if ( vpx_codec_destroy ( & codec ) ) die_codec ( & codec , \"Failed<S2SV_blank>to<S2SV_blank>destroy<S2SV_blank>codec.\" ) ; printf ( \"Play:<S2SV_blank>ffplay<S2SV_blank>-f<S2SV_blank>rawvideo<S2SV_blank>-pix_fmt<S2SV_blank>yuv420p<S2SV_blank>-s<S2SV_blank>%dx%d<S2SV_blank>%s\\\\n\" , info -> frame_width , info -> frame_height , argv [ 2 ] ) ; vpx_video_reader_close ( reader ) ; fclose ( outfile ) ; return EXIT_SUCCESS ; }\n",
      "fixed_code": "<S2SV_ModStart> ( decoder -> codec_interface <S2SV_ModEnd> ( ) ) <S2SV_ModStart> , decoder -> codec_interface <S2SV_ModEnd> ( ) ,\n",
      "source_code_length": 2710,
      "target_code_length": 130,
      "vulnerability_patterns": {
        "integer_overflow": 2,
        "null_pointer": 42,
        "total": 44
      },
      "total_patterns": 44,
      "original_address": "https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426",
      "discovery_time": "2016-03-12T21:59Z",
      "project_commit_id": "external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426",
      "extraction_time": "2025-08-31T15:41:49.189774",
      "label": 1,
      "vulnerability_type": "buffer_overflow",
      "difficulty_level": "advanced",
      "risk_factors": [
        "system_crash",
        "memory_corruption",
        "arbitrary_code_execution"
      ],
      "attack_vectors": [
        "memory_manipulation",
        "malicious_input",
        "code_analysis",
        "buffer_overflow",
        "reverse_engineering",
        "fuzzing"
      ],
      "mitigation_strategies": [
        "safe_string_functions",
        "dynamic_analysis",
        "code_review",
        "static_analysis",
        "memory_safety_checks",
        "input_validation",
        "fuzzing",
        "bounds_checking",
        "secure_coding_practices"
      ],
      "code_differences": {
        "has_differences": true,
        "source_lines": 2,
        "target_lines": 2,
        "character_differences": 2580,
        "similarity_percentage": 4.464285714285714
      },
      "vulnerability_location": {
        "vulnerability_present": true,
        "fix_applied": true,
        "code_changed": true,
        "estimated_lines_changed": 0
      }
    },
    {
      "cve_id": "CVE-2016-1621",
      "cwe_id": "CWE-119",
      "cwe_name": "Buffer Overflow",
      "project": "external",
      "severity": "critical",
      "weaponization_score": 7.0,
      "is_critical": true,
      "is_weaponizable": true,
      "is_high_priority_project": false,
      "vulnerable_code": "CWE-119 int main ( int argc , char * * argv ) { int frame_cnt = 0 ; FILE * outfile = NULL ; vpx_codec_ctx_t codec ; const VpxInterface * decoder = NULL ; VpxVideoReader * reader = NULL ; const VpxVideoInfo * info = NULL ; int n = 0 ; int m = 0 ; int is_range = 0 ; char * nptr = NULL ; exec_name = argv [ 0 ] ; if ( argc != 4 ) die ( \"Invalid<S2SV_blank>number<S2SV_blank>of<S2SV_blank>arguments.\" ) ; reader = vpx_video_reader_open ( argv [ 1 ] ) ; if ( ! reader ) die ( \"Failed<S2SV_blank>to<S2SV_blank>open<S2SV_blank>%s<S2SV_blank>for<S2SV_blank>reading.\" , argv [ 1 ] ) ; if ( ! ( outfile = fopen ( argv [ 2 ] , \"wb\" ) ) ) die ( \"Failed<S2SV_blank>to<S2SV_blank>open<S2SV_blank>%s<S2SV_blank>for<S2SV_blank>writing.\" , argv [ 2 ] ) ; n = strtol ( argv [ 3 ] , & nptr , 0 ) ; m = strtol ( nptr + 1 , NULL , 0 ) ; is_range = ( * nptr == '-' ) ; if ( ! n || ! m || ( * nptr != '-' && * nptr != '/' ) ) die ( \"Couldn\\'t<S2SV_blank>parse<S2SV_blank>pattern<S2SV_blank>%s.\\\\n\" , argv [ 3 ] ) ; info = vpx_video_reader_get_info ( reader ) ; decoder = get_vpx_decoder_by_fourcc ( info -> codec_fourcc ) ; if ( ! decoder ) die ( \"Unknown<S2SV_blank>input<S2SV_blank>codec.\" ) ; <S2SV_StartBug> printf ( \"Using<S2SV_blank>%s\\\\n\" , vpx_codec_iface_name ( decoder -> interface ( ) ) ) ; <S2SV_EndBug> <S2SV_StartBug> if ( vpx_codec_dec_init ( & codec , decoder -> interface ( ) , NULL , 0 ) ) <S2SV_EndBug> die_codec ( & codec , \"Failed<S2SV_blank>to<S2SV_blank>initialize<S2SV_blank>decoder.\" ) ; while ( vpx_video_reader_read_frame ( reader ) ) { vpx_codec_iter_t iter = NULL ; vpx_image_t * img = NULL ; size_t frame_size = 0 ; int skip ; const unsigned char * frame = vpx_video_reader_get_frame ( reader , & frame_size ) ; if ( vpx_codec_decode ( & codec , frame , ( unsigned int ) frame_size , NULL , 0 ) ) die_codec ( & codec , \"Failed<S2SV_blank>to<S2SV_blank>decode<S2SV_blank>frame.\" ) ; ++ frame_cnt ; skip = ( is_range && frame_cnt >= n && frame_cnt <= m ) || ( ! is_range && m - ( frame_cnt - 1 ) % m <= n ) ; if ( ! skip ) { putc ( '.' , stdout ) ; while ( ( img = vpx_codec_get_frame ( & codec , & iter ) ) != NULL ) vpx_img_write ( img , outfile ) ; } else { putc ( 'X' , stdout ) ; } fflush ( stdout ) ; } printf ( \"Processed<S2SV_blank>%d<S2SV_blank>frames.\\\\n\" , frame_cnt ) ; if ( vpx_codec_destroy ( & codec ) ) die_codec ( & codec , \"Failed<S2SV_blank>to<S2SV_blank>destroy<S2SV_blank>codec.\" ) ; printf ( \"Play:<S2SV_blank>ffplay<S2SV_blank>-f<S2SV_blank>rawvideo<S2SV_blank>-pix_fmt<S2SV_blank>yuv420p<S2SV_blank>-s<S2SV_blank>%dx%d<S2SV_blank>%s\\\\n\" , info -> frame_width , info -> frame_height , argv [ 2 ] ) ; vpx_video_reader_close ( reader ) ; fclose ( outfile ) ; return EXIT_SUCCESS ; }\n",
      "fixed_code": "<S2SV_ModStart> ( decoder -> codec_interface <S2SV_ModEnd> ( ) ) <S2SV_ModStart> , decoder -> codec_interface <S2SV_ModEnd> ( ) ,\n",
      "source_code_length": 2710,
      "target_code_length": 130,
      "vulnerability_patterns": {
        "integer_overflow": 3,
        "null_pointer": 26,
        "total": 29
      },
      "total_patterns": 29,
      "original_address": "https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426",
      "discovery_time": "2016-03-12T21:59Z",
      "project_commit_id": "external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426",
      "extraction_time": "2025-08-31T15:41:49.189788",
      "label": 1,
      "vulnerability_type": "buffer_overflow",
      "difficulty_level": "advanced",
      "risk_factors": [
        "system_crash",
        "memory_corruption",
        "arbitrary_code_execution"
      ],
      "attack_vectors": [
        "memory_manipulation",
        "malicious_input",
        "code_analysis",
        "buffer_overflow",
        "reverse_engineering",
        "fuzzing"
      ],
      "mitigation_strategies": [
        "safe_string_functions",
        "dynamic_analysis",
        "code_review",
        "static_analysis",
        "memory_safety_checks",
        "input_validation",
        "fuzzing",
        "bounds_checking",
        "secure_coding_practices"
      ],
      "code_differences": {
        "has_differences": true,
        "source_lines": 2,
        "target_lines": 2,
        "character_differences": 2580,
        "similarity_percentage": 4.464285714285714
      },
      "vulnerability_location": {
        "vulnerability_present": true,
        "fix_applied": true,
        "code_changed": true,
        "estimated_lines_changed": 0
      }
    },
    {
      "cve_id": "CVE-2016-1621",
      "cwe_id": "CWE-119",
      "cwe_name": "Buffer Overflow",
      "project": "external",
      "severity": "critical",
      "weaponization_score": 7.0,
      "is_critical": true,
      "is_weaponizable": true,
      "is_high_priority_project": false,
      "vulnerable_code": "CWE-119 int main ( int argc , char * * argv ) { int frame_cnt = 0 ; FILE * outfile = NULL ; vpx_codec_ctx_t codec ; const VpxInterface * decoder = NULL ; VpxVideoReader * reader = NULL ; const VpxVideoInfo * info = NULL ; int n = 0 ; int m = 0 ; int is_range = 0 ; char * nptr = NULL ; exec_name = argv [ 0 ] ; if ( argc != 4 ) die ( \"Invalid<S2SV_blank>number<S2SV_blank>of<S2SV_blank>arguments.\" ) ; reader = vpx_video_reader_open ( argv [ 1 ] ) ; if ( ! reader ) die ( \"Failed<S2SV_blank>to<S2SV_blank>open<S2SV_blank>%s<S2SV_blank>for<S2SV_blank>reading.\" , argv [ 1 ] ) ; if ( ! ( outfile = fopen ( argv [ 2 ] , \"wb\" ) ) ) die ( \"Failed<S2SV_blank>to<S2SV_blank>open<S2SV_blank>%s<S2SV_blank>for<S2SV_blank>writing.\" , argv [ 2 ] ) ; n = strtol ( argv [ 3 ] , & nptr , 0 ) ; m = strtol ( nptr + 1 , NULL , 0 ) ; is_range = ( * nptr == '-' ) ; if ( ! n || ! m || ( * nptr != '-' && * nptr != '/' ) ) die ( \"Couldn\\'t<S2SV_blank>parse<S2SV_blank>pattern<S2SV_blank>%s.\\\\n\" , argv [ 3 ] ) ; info = vpx_video_reader_get_info ( reader ) ; decoder = get_vpx_decoder_by_fourcc ( info -> codec_fourcc ) ; if ( ! decoder ) die ( \"Unknown<S2SV_blank>input<S2SV_blank>codec.\" ) ; <S2SV_StartBug> printf ( \"Using<S2SV_blank>%s\\\\n\" , vpx_codec_iface_name ( decoder -> interface ( ) ) ) ; <S2SV_EndBug> <S2SV_StartBug> if ( vpx_codec_dec_init ( & codec , decoder -> interface ( ) , NULL , 0 ) ) <S2SV_EndBug> die_codec ( & codec , \"Failed<S2SV_blank>to<S2SV_blank>initialize<S2SV_blank>decoder.\" ) ; while ( vpx_video_reader_read_frame ( reader ) ) { vpx_codec_iter_t iter = NULL ; vpx_image_t * img = NULL ; size_t frame_size = 0 ; int skip ; const unsigned char * frame = vpx_video_reader_get_frame ( reader , & frame_size ) ; if ( vpx_codec_decode ( & codec , frame , ( unsigned int ) frame_size , NULL , 0 ) ) die_codec ( & codec , \"Failed<S2SV_blank>to<S2SV_blank>decode<S2SV_blank>frame.\" ) ; ++ frame_cnt ; skip = ( is_range && frame_cnt >= n && frame_cnt <= m ) || ( ! is_range && m - ( frame_cnt - 1 ) % m <= n ) ; if ( ! skip ) { putc ( '.' , stdout ) ; while ( ( img = vpx_codec_get_frame ( & codec , & iter ) ) != NULL ) vpx_img_write ( img , outfile ) ; } else { putc ( 'X' , stdout ) ; } fflush ( stdout ) ; } printf ( \"Processed<S2SV_blank>%d<S2SV_blank>frames.\\\\n\" , frame_cnt ) ; if ( vpx_codec_destroy ( & codec ) ) die_codec ( & codec , \"Failed<S2SV_blank>to<S2SV_blank>destroy<S2SV_blank>codec.\" ) ; printf ( \"Play:<S2SV_blank>ffplay<S2SV_blank>-f<S2SV_blank>rawvideo<S2SV_blank>-pix_fmt<S2SV_blank>yuv420p<S2SV_blank>-s<S2SV_blank>%dx%d<S2SV_blank>%s\\\\n\" , info -> frame_width , info -> frame_height , argv [ 2 ] ) ; vpx_video_reader_close ( reader ) ; fclose ( outfile ) ; return EXIT_SUCCESS ; }\n",
      "fixed_code": "<S2SV_ModStart> ( decoder -> codec_interface <S2SV_ModEnd> ( ) ) <S2SV_ModStart> , decoder -> codec_interface <S2SV_ModEnd> ( ) ,\n",
      "source_code_length": 2710,
      "target_code_length": 130,
      "vulnerability_patterns": {
        "null_pointer": 13,
        "total": 13
      },
      "total_patterns": 13,
      "original_address": "https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426",
      "discovery_time": "2016-03-12T21:59Z",
      "project_commit_id": "external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426",
      "extraction_time": "2025-08-31T15:41:49.189803",
      "label": 1,
      "vulnerability_type": "buffer_overflow",
      "difficulty_level": "advanced",
      "risk_factors": [
        "system_crash",
        "memory_corruption",
        "arbitrary_code_execution"
      ],
      "attack_vectors": [
        "memory_manipulation",
        "malicious_input",
        "code_analysis",
        "buffer_overflow",
        "reverse_engineering",
        "fuzzing"
      ],
      "mitigation_strategies": [
        "safe_string_functions",
        "dynamic_analysis",
        "code_review",
        "static_analysis",
        "memory_safety_checks",
        "input_validation",
        "fuzzing",
        "bounds_checking",
        "secure_coding_practices"
      ],
      "code_differences": {
        "has_differences": true,
        "source_lines": 2,
        "target_lines": 2,
        "character_differences": 2580,
        "similarity_percentage": 4.464285714285714
      },
      "vulnerability_location": {
        "vulnerability_present": true,
        "fix_applied": true,
        "code_changed": true,
        "estimated_lines_changed": 0
      }
    },
    {
      "cve_id": "CVE-2017-16996",
      "cwe_id": "CWE-119",
      "cwe_name": "Buffer Overflow",
      "project": "torvalds",
      "severity": "critical",
      "weaponization_score": 7.0,
      "is_critical": true,
      "is_weaponizable": true,
      "is_high_priority_project": false,
      "vulnerable_code": "CWE-119 static int adjust_scalar_min_max_vals ( struct bpf_verifier_env * env , struct bpf_insn * insn , struct bpf_reg_state * dst_reg , struct bpf_reg_state src_reg ) { struct bpf_reg_state * regs = cur_regs ( env ) ; u8 opcode = BPF_OP ( insn -> code ) ; bool src_known , dst_known ; s64 smin_val , smax_val ; u64 umin_val , umax_val ; if ( BPF_CLASS ( insn -> code ) != BPF_ALU64 ) { <S2SV_StartBug> coerce_reg_to_32 ( dst_reg ) ; <S2SV_EndBug> <S2SV_StartBug> coerce_reg_to_32 ( & src_reg ) ; <S2SV_EndBug> } smin_val = src_reg . smin_value ; smax_val = src_reg . smax_value ; umin_val = src_reg . umin_value ; umax_val = src_reg . umax_value ; src_known = tnum_is_const ( src_reg . var_off ) ; dst_known = tnum_is_const ( dst_reg -> var_off ) ; switch ( opcode ) { case BPF_ADD : if ( signed_add_overflows ( dst_reg -> smin_value , smin_val ) || signed_add_overflows ( dst_reg -> smax_value , smax_val ) ) { dst_reg -> smin_value = S64_MIN ; dst_reg -> smax_value = S64_MAX ; } else { dst_reg -> smin_value += smin_val ; dst_reg -> smax_value += smax_val ; } if ( dst_reg -> umin_value + umin_val < umin_val || dst_reg -> umax_value + umax_val < umax_val ) { dst_reg -> umin_value = 0 ; dst_reg -> umax_value = U64_MAX ; } else { dst_reg -> umin_value += umin_val ; dst_reg -> umax_value += umax_val ; } dst_reg -> var_off = tnum_add ( dst_reg -> var_off , src_reg . var_off ) ; break ; case BPF_SUB : if ( signed_sub_overflows ( dst_reg -> smin_value , smax_val ) || signed_sub_overflows ( dst_reg -> smax_value , smin_val ) ) { dst_reg -> smin_value = S64_MIN ; dst_reg -> smax_value = S64_MAX ; } else { dst_reg -> smin_value -= smax_val ; dst_reg -> smax_value -= smin_val ; } if ( dst_reg -> umin_value < umax_val ) { dst_reg -> umin_value = 0 ; dst_reg -> umax_value = U64_MAX ; } else { dst_reg -> umin_value -= umax_val ; dst_reg -> umax_value -= umin_val ; } dst_reg -> var_off = tnum_sub ( dst_reg -> var_off , src_reg . var_off ) ; break ; case BPF_MUL : dst_reg -> var_off = tnum_mul ( dst_reg -> var_off , src_reg . var_off ) ; if ( smin_val < 0 || dst_reg -> smin_value < 0 ) { __mark_reg_unbounded ( dst_reg ) ; __update_reg_bounds ( dst_reg ) ; break ; } if ( umax_val > U32_MAX || dst_reg -> umax_value > U32_MAX ) { __mark_reg_unbounded ( dst_reg ) ; __update_reg_bounds ( dst_reg ) ; break ; } dst_reg -> umin_value *= umin_val ; dst_reg -> umax_value *= umax_val ; if ( dst_reg -> umax_value > S64_MAX ) { dst_reg -> smin_value = S64_MIN ; dst_reg -> smax_value = S64_MAX ; } else { dst_reg -> smin_value = dst_reg -> umin_value ; dst_reg -> smax_value = dst_reg -> umax_value ; } break ; case BPF_AND : if ( src_known && dst_known ) { __mark_reg_known ( dst_reg , dst_reg -> var_off . value & src_reg . var_off . value ) ; break ; } dst_reg -> var_off = tnum_and ( dst_reg -> var_off , src_reg . var_off ) ; dst_reg -> umin_value = dst_reg -> var_off . value ; dst_reg -> umax_value = min ( dst_reg -> umax_value , umax_val ) ; if ( dst_reg -> smin_value < 0 || smin_val < 0 ) { dst_reg -> smin_value = S64_MIN ; dst_reg -> smax_value = S64_MAX ; } else { dst_reg -> smin_value = dst_reg -> umin_value ; dst_reg -> smax_value = dst_reg -> umax_value ; } __update_reg_bounds ( dst_reg ) ; break ; case BPF_OR : if ( src_known && dst_known ) { __mark_reg_known ( dst_reg , dst_reg -> var_off . value | src_reg . var_off . value ) ; break ; } dst_reg -> var_off = tnum_or ( dst_reg -> var_off , src_reg . var_off ) ; dst_reg -> umin_value = max ( dst_reg -> umin_value , umin_val ) ; dst_reg -> umax_value = dst_reg -> var_off . value | dst_reg -> var_off . mask ; if ( dst_reg -> smin_value < 0 || smin_val < 0 ) { dst_reg -> smin_value = S64_MIN ; dst_reg -> smax_value = S64_MAX ; } else { dst_reg -> smin_value = dst_reg -> umin_value ; dst_reg -> smax_value = dst_reg -> umax_value ; } __update_reg_bounds ( dst_reg ) ; break ; case BPF_LSH : if ( umax_val > 63 ) { mark_reg_unknown ( env , regs , insn -> dst_reg ) ; break ; } dst_reg -> smin_value = S64_MIN ; dst_reg -> smax_value = S64_MAX ; if ( dst_reg -> umax_value > 1ULL << ( 63 - umax_val ) ) { dst_reg -> umin_value = 0 ; dst_reg -> umax_value = U64_MAX ; } else { dst_reg -> umin_value <<= umin_val ; dst_reg -> umax_value <<= umax_val ; } if ( src_known ) dst_reg -> var_off = tnum_lshift ( dst_reg -> var_off , umin_val ) ; else dst_reg -> var_off = tnum_lshift ( tnum_unknown , umin_val ) ; __update_reg_bounds ( dst_reg ) ; break ; case BPF_RSH : if ( umax_val > 63 ) { mark_reg_unknown ( env , regs , insn -> dst_reg ) ; break ; } dst_reg -> smin_value = S64_MIN ; dst_reg -> smax_value = S64_MAX ; if ( src_known ) dst_reg -> var_off = tnum_rshift ( dst_reg -> var_off , umin_val ) ; else dst_reg -> var_off = tnum_rshift ( tnum_unknown , umin_val ) ; dst_reg -> umin_value >>= umax_val ; dst_reg -> umax_value >>= umin_val ; __update_reg_bounds ( dst_reg ) ; break ; default : mark_reg_unknown ( env , regs , insn -> dst_reg ) ; break ; } __reg_deduce_bounds ( dst_reg ) ; __reg_bound_offset ( dst_reg ) ; return 0 ; }\n",
      "fixed_code": "<S2SV_ModStart> BPF_ALU64 ) { coerce_reg_to_size ( dst_reg , 4 ) ; coerce_reg_to_size <S2SV_ModEnd> ( & src_reg <S2SV_ModStart> ( & src_reg , 4\n",
      "source_code_length": 5017,
      "target_code_length": 144,
      "vulnerability_patterns": {
        "integer_overflow": 10,
        "null_pointer": 92,
        "total": 102
      },
      "total_patterns": 102,
      "original_address": "https://github.com/torvalds/linux/commit/0c17d1d2c61936401f4702e1846e2c19b200f958",
      "discovery_time": "2017-12-27T17:08Z",
      "project_commit_id": "torvalds@linux/0c17d1d2c61936401f4702e1846e2c19b200f958",
      "extraction_time": "2025-08-31T15:41:49.189820",
      "label": 1,
      "vulnerability_type": "buffer_overflow",
      "difficulty_level": "advanced",
      "risk_factors": [
        "system_crash",
        "memory_corruption",
        "arbitrary_code_execution"
      ],
      "attack_vectors": [
        "memory_manipulation",
        "malicious_input",
        "code_analysis",
        "buffer_overflow",
        "reverse_engineering",
        "fuzzing"
      ],
      "mitigation_strategies": [
        "safe_string_functions",
        "dynamic_analysis",
        "code_review",
        "static_analysis",
        "memory_safety_checks",
        "input_validation",
        "fuzzing",
        "bounds_checking",
        "secure_coding_practices"
      ],
      "code_differences": {
        "has_differences": true,
        "source_lines": 2,
        "target_lines": 2,
        "character_differences": 4873,
        "similarity_percentage": 8.256880733944955
      },
      "vulnerability_location": {
        "vulnerability_present": true,
        "fix_applied": true,
        "code_changed": true,
        "estimated_lines_changed": 0
      }
    },
    {
      "cve_id": "CVE-2016-1621",
      "cwe_id": "CWE-119",
      "cwe_name": "Buffer Overflow",
      "project": "external",
      "severity": "critical",
      "weaponization_score": 7.0,
      "is_critical": true,
      "is_weaponizable": true,
      "is_high_priority_project": false,
      "vulnerable_code": "CWE-119 int main ( int argc , char * * argv ) { int frame_cnt = 0 ; FILE * outfile = NULL ; vpx_codec_ctx_t codec ; const VpxInterface * decoder = NULL ; VpxVideoReader * reader = NULL ; const VpxVideoInfo * info = NULL ; int n = 0 ; int m = 0 ; int is_range = 0 ; char * nptr = NULL ; exec_name = argv [ 0 ] ; if ( argc != 4 ) die ( \"Invalid<S2SV_blank>number<S2SV_blank>of<S2SV_blank>arguments.\" ) ; reader = vpx_video_reader_open ( argv [ 1 ] ) ; if ( ! reader ) die ( \"Failed<S2SV_blank>to<S2SV_blank>open<S2SV_blank>%s<S2SV_blank>for<S2SV_blank>reading.\" , argv [ 1 ] ) ; if ( ! ( outfile = fopen ( argv [ 2 ] , \"wb\" ) ) ) die ( \"Failed<S2SV_blank>to<S2SV_blank>open<S2SV_blank>%s<S2SV_blank>for<S2SV_blank>writing.\" , argv [ 2 ] ) ; n = strtol ( argv [ 3 ] , & nptr , 0 ) ; m = strtol ( nptr + 1 , NULL , 0 ) ; is_range = ( * nptr == '-' ) ; if ( ! n || ! m || ( * nptr != '-' && * nptr != '/' ) ) die ( \"Couldn\\'t<S2SV_blank>parse<S2SV_blank>pattern<S2SV_blank>%s.\\\\n\" , argv [ 3 ] ) ; info = vpx_video_reader_get_info ( reader ) ; decoder = get_vpx_decoder_by_fourcc ( info -> codec_fourcc ) ; if ( ! decoder ) die ( \"Unknown<S2SV_blank>input<S2SV_blank>codec.\" ) ; <S2SV_StartBug> printf ( \"Using<S2SV_blank>%s\\\\n\" , vpx_codec_iface_name ( decoder -> interface ( ) ) ) ; <S2SV_EndBug> <S2SV_StartBug> if ( vpx_codec_dec_init ( & codec , decoder -> interface ( ) , NULL , 0 ) ) <S2SV_EndBug> die_codec ( & codec , \"Failed<S2SV_blank>to<S2SV_blank>initialize<S2SV_blank>decoder.\" ) ; while ( vpx_video_reader_read_frame ( reader ) ) { vpx_codec_iter_t iter = NULL ; vpx_image_t * img = NULL ; size_t frame_size = 0 ; int skip ; const unsigned char * frame = vpx_video_reader_get_frame ( reader , & frame_size ) ; if ( vpx_codec_decode ( & codec , frame , ( unsigned int ) frame_size , NULL , 0 ) ) die_codec ( & codec , \"Failed<S2SV_blank>to<S2SV_blank>decode<S2SV_blank>frame.\" ) ; ++ frame_cnt ; skip = ( is_range && frame_cnt >= n && frame_cnt <= m ) || ( ! is_range && m - ( frame_cnt - 1 ) % m <= n ) ; if ( ! skip ) { putc ( '.' , stdout ) ; while ( ( img = vpx_codec_get_frame ( & codec , & iter ) ) != NULL ) vpx_img_write ( img , outfile ) ; } else { putc ( 'X' , stdout ) ; } fflush ( stdout ) ; } printf ( \"Processed<S2SV_blank>%d<S2SV_blank>frames.\\\\n\" , frame_cnt ) ; if ( vpx_codec_destroy ( & codec ) ) die_codec ( & codec , \"Failed<S2SV_blank>to<S2SV_blank>destroy<S2SV_blank>codec.\" ) ; printf ( \"Play:<S2SV_blank>ffplay<S2SV_blank>-f<S2SV_blank>rawvideo<S2SV_blank>-pix_fmt<S2SV_blank>yuv420p<S2SV_blank>-s<S2SV_blank>%dx%d<S2SV_blank>%s\\\\n\" , info -> frame_width , info -> frame_height , argv [ 2 ] ) ; vpx_video_reader_close ( reader ) ; fclose ( outfile ) ; return EXIT_SUCCESS ; }\n",
      "fixed_code": "<S2SV_ModStart> ( decoder -> codec_interface <S2SV_ModEnd> ( ) ) <S2SV_ModStart> , decoder -> codec_interface <S2SV_ModEnd> ( ) ,\n",
      "source_code_length": 2710,
      "target_code_length": 130,
      "vulnerability_patterns": {
        "integer_overflow": 1,
        "null_pointer": 41,
        "total": 42
      },
      "total_patterns": 42,
      "original_address": "https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426",
      "discovery_time": "2016-03-12T21:59Z",
      "project_commit_id": "external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426",
      "extraction_time": "2025-08-31T15:41:49.189860",
      "label": 1,
      "vulnerability_type": "buffer_overflow",
      "difficulty_level": "advanced",
      "risk_factors": [
        "system_crash",
        "memory_corruption",
        "arbitrary_code_execution"
      ],
      "attack_vectors": [
        "memory_manipulation",
        "malicious_input",
        "code_analysis",
        "buffer_overflow",
        "reverse_engineering",
        "fuzzing"
      ],
      "mitigation_strategies": [
        "safe_string_functions",
        "dynamic_analysis",
        "code_review",
        "static_analysis",
        "memory_safety_checks",
        "input_validation",
        "fuzzing",
        "bounds_checking",
        "secure_coding_practices"
      ],
      "code_differences": {
        "has_differences": true,
        "source_lines": 2,
        "target_lines": 2,
        "character_differences": 2580,
        "similarity_percentage": 4.464285714285714
      },
      "vulnerability_location": {
        "vulnerability_present": true,
        "fix_applied": true,
        "code_changed": true,
        "estimated_lines_changed": 0
      }
    },
    {
      "cve_id": "CVE-2016-1621",
      "cwe_id": "CWE-119",
      "cwe_name": "Buffer Overflow",
      "project": "external",
      "severity": "critical",
      "weaponization_score": 7.0,
      "is_critical": true,
      "is_weaponizable": true,
      "is_high_priority_project": false,
      "vulnerable_code": "CWE-119 int main ( int argc , char * * argv ) { int frame_cnt = 0 ; FILE * outfile = NULL ; vpx_codec_ctx_t codec ; const VpxInterface * decoder = NULL ; VpxVideoReader * reader = NULL ; const VpxVideoInfo * info = NULL ; int n = 0 ; int m = 0 ; int is_range = 0 ; char * nptr = NULL ; exec_name = argv [ 0 ] ; if ( argc != 4 ) die ( \"Invalid<S2SV_blank>number<S2SV_blank>of<S2SV_blank>arguments.\" ) ; reader = vpx_video_reader_open ( argv [ 1 ] ) ; if ( ! reader ) die ( \"Failed<S2SV_blank>to<S2SV_blank>open<S2SV_blank>%s<S2SV_blank>for<S2SV_blank>reading.\" , argv [ 1 ] ) ; if ( ! ( outfile = fopen ( argv [ 2 ] , \"wb\" ) ) ) die ( \"Failed<S2SV_blank>to<S2SV_blank>open<S2SV_blank>%s<S2SV_blank>for<S2SV_blank>writing.\" , argv [ 2 ] ) ; n = strtol ( argv [ 3 ] , & nptr , 0 ) ; m = strtol ( nptr + 1 , NULL , 0 ) ; is_range = ( * nptr == '-' ) ; if ( ! n || ! m || ( * nptr != '-' && * nptr != '/' ) ) die ( \"Couldn\\'t<S2SV_blank>parse<S2SV_blank>pattern<S2SV_blank>%s.\\\\n\" , argv [ 3 ] ) ; info = vpx_video_reader_get_info ( reader ) ; decoder = get_vpx_decoder_by_fourcc ( info -> codec_fourcc ) ; if ( ! decoder ) die ( \"Unknown<S2SV_blank>input<S2SV_blank>codec.\" ) ; <S2SV_StartBug> printf ( \"Using<S2SV_blank>%s\\\\n\" , vpx_codec_iface_name ( decoder -> interface ( ) ) ) ; <S2SV_EndBug> <S2SV_StartBug> if ( vpx_codec_dec_init ( & codec , decoder -> interface ( ) , NULL , 0 ) ) <S2SV_EndBug> die_codec ( & codec , \"Failed<S2SV_blank>to<S2SV_blank>initialize<S2SV_blank>decoder.\" ) ; while ( vpx_video_reader_read_frame ( reader ) ) { vpx_codec_iter_t iter = NULL ; vpx_image_t * img = NULL ; size_t frame_size = 0 ; int skip ; const unsigned char * frame = vpx_video_reader_get_frame ( reader , & frame_size ) ; if ( vpx_codec_decode ( & codec , frame , ( unsigned int ) frame_size , NULL , 0 ) ) die_codec ( & codec , \"Failed<S2SV_blank>to<S2SV_blank>decode<S2SV_blank>frame.\" ) ; ++ frame_cnt ; skip = ( is_range && frame_cnt >= n && frame_cnt <= m ) || ( ! is_range && m - ( frame_cnt - 1 ) % m <= n ) ; if ( ! skip ) { putc ( '.' , stdout ) ; while ( ( img = vpx_codec_get_frame ( & codec , & iter ) ) != NULL ) vpx_img_write ( img , outfile ) ; } else { putc ( 'X' , stdout ) ; } fflush ( stdout ) ; } printf ( \"Processed<S2SV_blank>%d<S2SV_blank>frames.\\\\n\" , frame_cnt ) ; if ( vpx_codec_destroy ( & codec ) ) die_codec ( & codec , \"Failed<S2SV_blank>to<S2SV_blank>destroy<S2SV_blank>codec.\" ) ; printf ( \"Play:<S2SV_blank>ffplay<S2SV_blank>-f<S2SV_blank>rawvideo<S2SV_blank>-pix_fmt<S2SV_blank>yuv420p<S2SV_blank>-s<S2SV_blank>%dx%d<S2SV_blank>%s\\\\n\" , info -> frame_width , info -> frame_height , argv [ 2 ] ) ; vpx_video_reader_close ( reader ) ; fclose ( outfile ) ; return EXIT_SUCCESS ; }\n",
      "fixed_code": "<S2SV_ModStart> ( decoder -> codec_interface <S2SV_ModEnd> ( ) ) <S2SV_ModStart> , decoder -> codec_interface <S2SV_ModEnd> ( ) ,\n",
      "source_code_length": 2710,
      "target_code_length": 130,
      "vulnerability_patterns": {
        "null_pointer": 15,
        "total": 15
      },
      "total_patterns": 15,
      "original_address": "https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426",
      "discovery_time": "2016-03-12T21:59Z",
      "project_commit_id": "external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426",
      "extraction_time": "2025-08-31T15:41:49.189874",
      "label": 1,
      "vulnerability_type": "buffer_overflow",
      "difficulty_level": "advanced",
      "risk_factors": [
        "system_crash",
        "memory_corruption",
        "arbitrary_code_execution"
      ],
      "attack_vectors": [
        "memory_manipulation",
        "malicious_input",
        "code_analysis",
        "buffer_overflow",
        "reverse_engineering",
        "fuzzing"
      ],
      "mitigation_strategies": [
        "safe_string_functions",
        "dynamic_analysis",
        "code_review",
        "static_analysis",
        "memory_safety_checks",
        "input_validation",
        "fuzzing",
        "bounds_checking",
        "secure_coding_practices"
      ],
      "code_differences": {
        "has_differences": true,
        "source_lines": 2,
        "target_lines": 2,
        "character_differences": 2580,
        "similarity_percentage": 4.464285714285714
      },
      "vulnerability_location": {
        "vulnerability_present": true,
        "fix_applied": true,
        "code_changed": true,
        "estimated_lines_changed": 0
      }
    },
    {
      "cve_id": "CVE-2017-14039",
      "cwe_id": "CWE-787",
      "cwe_name": "Out-of-bounds Write",
      "project": "uclouvain",
      "severity": "critical",
      "weaponization_score": 7.0,
      "is_critical": true,
      "is_weaponizable": true,
      "is_high_priority_project": false,
      "vulnerable_code": "CWE-787 static OPJ_BOOL opj_j2k_write_sod ( opj_j2k_t * p_j2k , opj_tcd_t * p_tile_coder , OPJ_BYTE * p_data , OPJ_UINT32 * p_data_written , OPJ_UINT32 p_total_data_size , const opj_stream_private_t * p_stream , opj_event_mgr_t * p_manager ) { opj_codestream_info_t * l_cstr_info = 00 ; OPJ_UINT32 l_remaining_data ; assert ( p_j2k != 00 ) ; assert ( p_manager != 00 ) ; assert ( p_stream != 00 ) ; OPJ_UNUSED ( p_stream ) ; <S2SV_StartBug> opj_write_bytes ( p_data , J2K_MS_SOD , <S2SV_EndBug> 2 ) ; p_data += 2 ; l_remaining_data = p_total_data_size - 4 ; p_tile_coder -> tp_num = p_j2k -> m_specific_param . m_encoder . m_current_poc_tile_part_number ; p_tile_coder -> cur_tp_num = p_j2k -> m_specific_param . m_encoder . m_current_tile_part_number ; # ifdef USE_JPWL assert ( 0 && \"TODO\" ) ; # endif if ( p_j2k -> m_specific_param . m_encoder . m_current_tile_part_number == 0 ) { p_tile_coder -> tcd_image -> tiles -> packno = 0 ; if ( l_cstr_info ) { l_cstr_info -> packno = 0 ; } } * p_data_written = 0 ; if ( ! opj_tcd_encode_tile ( p_tile_coder , p_j2k -> m_current_tile_number , p_data , p_data_written , l_remaining_data , l_cstr_info , p_manager ) ) { opj_event_msg ( p_manager , EVT_ERROR , \"Cannot<S2SV_blank>encode<S2SV_blank>tile\\\\n\" ) ; return OPJ_FALSE ; } * p_data_written += 2 ; return OPJ_TRUE ; }\n",
      "fixed_code": "<S2SV_ModStart> p_stream ) ; if ( p_total_data_size < 4 ) { opj_event_msg ( p_manager , EVT_ERROR , \"Not<S2SV_blank>enough<S2SV_blank>bytes<S2SV_blank>in<S2SV_blank>output<S2SV_blank>buffer<S2SV_blank>to<S2SV_blank>write<S2SV_blank>SOD<S2SV_blank>marker\\\\n\" ) ; return OPJ_FALSE ; }\n",
      "source_code_length": 1319,
      "target_code_length": 283,
      "vulnerability_patterns": {
        "integer_overflow": 2,
        "null_pointer": 10,
        "total": 12
      },
      "total_patterns": 12,
      "original_address": "https://github.com/uclouvain/openjpeg/commit/c535531f03369623b9b833ef41952c62257b507e",
      "discovery_time": "2017-08-30T22:29Z",
      "project_commit_id": "uclouvain@openjpeg/c535531f03369623b9b833ef41952c62257b507e",
      "extraction_time": "2025-08-31T15:41:49.189893",
      "label": 1,
      "vulnerability_type": "out-of-bounds_write",
      "difficulty_level": "advanced",
      "risk_factors": [
        "system_crash",
        "memory_corruption",
        "arbitrary_code_execution"
      ],
      "attack_vectors": [
        "memory_manipulation",
        "malicious_input",
        "code_analysis",
        "buffer_overflow",
        "reverse_engineering",
        "fuzzing"
      ],
      "mitigation_strategies": [
        "safe_string_functions",
        "dynamic_analysis",
        "code_review",
        "static_analysis",
        "memory_safety_checks",
        "input_validation",
        "fuzzing",
        "bounds_checking",
        "secure_coding_practices"
      ],
      "code_differences": {
        "has_differences": true,
        "source_lines": 2,
        "target_lines": 2,
        "character_differences": 1036,
        "similarity_percentage": 20.54794520547945
      },
      "vulnerability_location": {
        "vulnerability_present": true,
        "fix_applied": true,
        "code_changed": true,
        "estimated_lines_changed": 0
      }
    },
    {
      "cve_id": "CVE-2016-1621",
      "cwe_id": "CWE-119",
      "cwe_name": "Buffer Overflow",
      "project": "external",
      "severity": "critical",
      "weaponization_score": 7.0,
      "is_critical": true,
      "is_weaponizable": true,
      "is_high_priority_project": false,
      "vulnerable_code": "CWE-119 int main ( int argc , char * * argv ) { int frame_cnt = 0 ; FILE * outfile = NULL ; vpx_codec_ctx_t codec ; const VpxInterface * decoder = NULL ; VpxVideoReader * reader = NULL ; const VpxVideoInfo * info = NULL ; int n = 0 ; int m = 0 ; int is_range = 0 ; char * nptr = NULL ; exec_name = argv [ 0 ] ; if ( argc != 4 ) die ( \"Invalid<S2SV_blank>number<S2SV_blank>of<S2SV_blank>arguments.\" ) ; reader = vpx_video_reader_open ( argv [ 1 ] ) ; if ( ! reader ) die ( \"Failed<S2SV_blank>to<S2SV_blank>open<S2SV_blank>%s<S2SV_blank>for<S2SV_blank>reading.\" , argv [ 1 ] ) ; if ( ! ( outfile = fopen ( argv [ 2 ] , \"wb\" ) ) ) die ( \"Failed<S2SV_blank>to<S2SV_blank>open<S2SV_blank>%s<S2SV_blank>for<S2SV_blank>writing.\" , argv [ 2 ] ) ; n = strtol ( argv [ 3 ] , & nptr , 0 ) ; m = strtol ( nptr + 1 , NULL , 0 ) ; is_range = ( * nptr == '-' ) ; if ( ! n || ! m || ( * nptr != '-' && * nptr != '/' ) ) die ( \"Couldn\\'t<S2SV_blank>parse<S2SV_blank>pattern<S2SV_blank>%s.\\\\n\" , argv [ 3 ] ) ; info = vpx_video_reader_get_info ( reader ) ; decoder = get_vpx_decoder_by_fourcc ( info -> codec_fourcc ) ; if ( ! decoder ) die ( \"Unknown<S2SV_blank>input<S2SV_blank>codec.\" ) ; <S2SV_StartBug> printf ( \"Using<S2SV_blank>%s\\\\n\" , vpx_codec_iface_name ( decoder -> interface ( ) ) ) ; <S2SV_EndBug> <S2SV_StartBug> if ( vpx_codec_dec_init ( & codec , decoder -> interface ( ) , NULL , 0 ) ) <S2SV_EndBug> die_codec ( & codec , \"Failed<S2SV_blank>to<S2SV_blank>initialize<S2SV_blank>decoder.\" ) ; while ( vpx_video_reader_read_frame ( reader ) ) { vpx_codec_iter_t iter = NULL ; vpx_image_t * img = NULL ; size_t frame_size = 0 ; int skip ; const unsigned char * frame = vpx_video_reader_get_frame ( reader , & frame_size ) ; if ( vpx_codec_decode ( & codec , frame , ( unsigned int ) frame_size , NULL , 0 ) ) die_codec ( & codec , \"Failed<S2SV_blank>to<S2SV_blank>decode<S2SV_blank>frame.\" ) ; ++ frame_cnt ; skip = ( is_range && frame_cnt >= n && frame_cnt <= m ) || ( ! is_range && m - ( frame_cnt - 1 ) % m <= n ) ; if ( ! skip ) { putc ( '.' , stdout ) ; while ( ( img = vpx_codec_get_frame ( & codec , & iter ) ) != NULL ) vpx_img_write ( img , outfile ) ; } else { putc ( 'X' , stdout ) ; } fflush ( stdout ) ; } printf ( \"Processed<S2SV_blank>%d<S2SV_blank>frames.\\\\n\" , frame_cnt ) ; if ( vpx_codec_destroy ( & codec ) ) die_codec ( & codec , \"Failed<S2SV_blank>to<S2SV_blank>destroy<S2SV_blank>codec.\" ) ; printf ( \"Play:<S2SV_blank>ffplay<S2SV_blank>-f<S2SV_blank>rawvideo<S2SV_blank>-pix_fmt<S2SV_blank>yuv420p<S2SV_blank>-s<S2SV_blank>%dx%d<S2SV_blank>%s\\\\n\" , info -> frame_width , info -> frame_height , argv [ 2 ] ) ; vpx_video_reader_close ( reader ) ; fclose ( outfile ) ; return EXIT_SUCCESS ; }\n",
      "fixed_code": "<S2SV_ModStart> ( decoder -> codec_interface <S2SV_ModEnd> ( ) ) <S2SV_ModStart> , decoder -> codec_interface <S2SV_ModEnd> ( ) ,\n",
      "source_code_length": 2710,
      "target_code_length": 130,
      "vulnerability_patterns": {
        "integer_overflow": 1,
        "format_string": 3,
        "null_pointer": 9,
        "total": 13
      },
      "total_patterns": 13,
      "original_address": "https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426",
      "discovery_time": "2016-03-12T21:59Z",
      "project_commit_id": "external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426",
      "extraction_time": "2025-08-31T15:41:49.189911",
      "label": 1,
      "vulnerability_type": "buffer_overflow",
      "difficulty_level": "advanced",
      "risk_factors": [
        "system_crash",
        "memory_corruption",
        "arbitrary_code_execution"
      ],
      "attack_vectors": [
        "memory_manipulation",
        "malicious_input",
        "code_analysis",
        "buffer_overflow",
        "reverse_engineering",
        "fuzzing"
      ],
      "mitigation_strategies": [
        "safe_string_functions",
        "dynamic_analysis",
        "code_review",
        "static_analysis",
        "memory_safety_checks",
        "input_validation",
        "fuzzing",
        "bounds_checking",
        "secure_coding_practices"
      ],
      "code_differences": {
        "has_differences": true,
        "source_lines": 2,
        "target_lines": 2,
        "character_differences": 2580,
        "similarity_percentage": 4.464285714285714
      },
      "vulnerability_location": {
        "vulnerability_present": true,
        "fix_applied": true,
        "code_changed": true,
        "estimated_lines_changed": 0
      }
    },
    {
      "cve_id": "CVE-2013-7441",
      "cwe_id": "CWE-399",
      "cwe_name": "Unknown",
      "project": "yoe",
      "severity": "critical",
      "weaponization_score": 7.0,
      "is_critical": true,
      "is_weaponizable": true,
      "is_high_priority_project": false,
      "vulnerable_code": "CWE-399 void serveloop ( GArray * servers ) { struct sockaddr_storage addrin ; socklen_t addrinlen = sizeof ( addrin ) ; int i ; int max ; fd_set mset ; fd_set rset ; max = 0 ; FD_ZERO ( & mset ) ; for ( i = 0 ; i < servers -> len ; i ++ ) { int sock ; if ( ( sock = ( g_array_index ( servers , SERVER , i ) ) . socket ) >= 0 ) { FD_SET ( sock , & mset ) ; max = sock > max ? sock : max ; } } for ( i = 0 ; i < modernsocks -> len ; i ++ ) { int sock = g_array_index ( modernsocks , int , i ) ; FD_SET ( sock , & mset ) ; max = sock > max ? sock : max ; } for ( ; ; ) { if ( is_sighup_caught ) { int n ; GError * gerror = NULL ; msg ( LOG_INFO , \"reconfiguration<S2SV_blank>request<S2SV_blank>received\" ) ; is_sighup_caught = 0 ; n = append_new_servers ( servers , & gerror ) ; if ( n == - 1 ) msg ( LOG_ERR , \"failed<S2SV_blank>to<S2SV_blank>append<S2SV_blank>new<S2SV_blank>servers:<S2SV_blank>%s\" , gerror -> message ) ; for ( i = servers -> len - n ; i < servers -> len ; ++ i ) { const SERVER server = g_array_index ( servers , SERVER , i ) ; if ( server . socket >= 0 ) { FD_SET ( server . socket , & mset ) ; max = server . socket > max ? server . socket : max ; } msg ( LOG_INFO , \"reconfigured<S2SV_blank>new<S2SV_blank>server:<S2SV_blank>%s\" , server . servename ) ; } } memcpy ( & rset , & mset , sizeof ( fd_set ) ) ; if ( select ( max + 1 , & rset , NULL , NULL , NULL ) > 0 ) { <S2SV_StartBug> int net ; <S2SV_EndBug> DEBUG ( \"accept,<S2SV_blank>\" ) ; for ( i = 0 ; i < modernsocks -> len ; i ++ ) { int sock = g_array_index ( modernsocks , int , i ) ; if ( ! FD_ISSET ( sock , & rset ) ) { continue ; } <S2SV_StartBug> CLIENT * client ; <S2SV_EndBug> <S2SV_StartBug> if ( ( net = accept ( sock , ( struct sockaddr * ) & addrin , & addrinlen ) ) < 0 ) { <S2SV_EndBug> err_nonfatal ( \"accept:<S2SV_blank>%m\" ) ; continue ; } <S2SV_StartBug> client = negotiate ( net , NULL , servers , NEG_INIT | NEG_MODERN ) ; <S2SV_EndBug> if ( ! client ) { close ( net ) ; continue ; } handle_connection ( servers , net , client -> server , client ) ; } for ( i = 0 ; i < servers -> len ; i ++ ) { SERVER * serve ; serve = & ( g_array_index ( servers , SERVER , i ) ) ; if ( serve -> socket < 0 ) { continue ; } if ( FD_ISSET ( serve -> socket , & rset ) ) { if ( ( net = accept ( serve -> socket , ( struct sockaddr * ) & addrin , & addrinlen ) ) < 0 ) { err_nonfatal ( \"accept:<S2SV_blank>%m\" ) ; continue ; } handle_connection ( servers , net , serve , NULL ) ; } } } } }\n",
      "fixed_code": "<S2SV_ModStart> 0 ) { <S2SV_ModEnd> DEBUG ( \"accept,<S2SV_blank>\" <S2SV_ModStart> continue ; } handle_modern_connection ( servers , sock ) ; } for ( i = 0 ; i < servers -> len ; i ++ ) { int net ; SERVER * serve ; serve = & ( g_array_index ( servers , SERVER , i ) ) ; if ( serve -> socket < 0 ) { continue ; } if ( FD_ISSET ( serve -> socket , & rset ) ) { <S2SV_ModEnd> if ( ( <S2SV_ModStart> = accept ( serve -> socket <S2SV_ModEnd> , ( struct <S2SV_ModStart> continue ; } handle_connection ( servers , net , serve , NULL <S2SV_ModEnd> ) ; }\n",
      "source_code_length": 2473,
      "target_code_length": 545,
      "vulnerability_patterns": {
        "buffer_overflow": 1,
        "use_after_free": 2,
        "integer_overflow": 5,
        "null_pointer": 13,
        "sql_injection": 1,
        "total": 22
      },
      "total_patterns": 22,
      "original_address": "https://github.com/yoe/nbd/commit/741495cb08503fd32a9d22648e63b64390c601f4",
      "discovery_time": "2015-05-29T15:59Z",
      "project_commit_id": "yoe@nbd/741495cb08503fd32a9d22648e63b64390c601f4",
      "extraction_time": "2025-08-31T15:41:49.189930",
      "label": 1,
      "vulnerability_type": "unknown",
      "difficulty_level": "advanced",
      "risk_factors": [
        "sql_injection",
        "buffer_overflow",
        "use_after_free"
      ],
      "attack_vectors": [
        "fuzzing",
        "code_analysis",
        "reverse_engineering"
      ],
      "mitigation_strategies": [
        "dynamic_analysis",
        "static_analysis",
        "fuzzing",
        "code_review",
        "secure_coding_practices"
      ],
      "code_differences": {
        "has_differences": true,
        "source_lines": 2,
        "target_lines": 2,
        "character_differences": 1928,
        "similarity_percentage": 37.362637362637365
      },
      "vulnerability_location": {
        "vulnerability_present": true,
        "fix_applied": true,
        "code_changed": true,
        "estimated_lines_changed": 0
      }
    },
    {
      "cve_id": "CVE-2013-2058",
      "cwe_id": "CWE-119",
      "cwe_name": "Buffer Overflow",
      "project": "torvalds",
      "severity": "critical",
      "weaponization_score": 7.0,
      "is_critical": true,
      "is_weaponizable": true,
      "is_high_priority_project": false,
      "vulnerable_code": "CWE-119 static int host_start ( struct ci13xxx * ci ) { struct usb_hcd * hcd ; struct ehci_hcd * ehci ; int ret ; if ( usb_disabled ( ) ) return - ENODEV ; hcd = usb_create_hcd ( & ci_ehci_hc_driver , ci -> dev , dev_name ( ci -> dev ) ) ; if ( ! hcd ) return - ENOMEM ; dev_set_drvdata ( ci -> dev , ci ) ; hcd -> rsrc_start = ci -> hw_bank . phys ; hcd -> rsrc_len = ci -> hw_bank . size ; hcd -> regs = ci -> hw_bank . abs ; hcd -> has_tt = 1 ; hcd -> power_budget = ci -> platdata -> power_budget ; hcd -> phy = ci -> transceiver ; ehci = hcd_to_ehci ( hcd ) ; ehci -> caps = ci -> hw_bank . cap ; ehci -> has_hostpc = ci -> hw_bank . lpm ; ret = usb_add_hcd ( hcd , 0 , 0 ) ; if ( ret ) usb_put_hcd ( hcd ) ; else ci -> hcd = hcd ; <S2SV_StartBug> return ret ; <S2SV_EndBug> }\n",
      "fixed_code": "<S2SV_ModStart> = hcd ; if ( ci -> platdata -> flags & CI13XXX_DISABLE_STREAMING ) hw_write ( ci , OP_USBMODE , USBMODE_CI_SDIS , USBMODE_CI_SDIS ) ;\n",
      "source_code_length": 782,
      "target_code_length": 150,
      "vulnerability_patterns": {
        "null_pointer": 22,
        "total": 22
      },
      "total_patterns": 22,
      "original_address": "https://github.com/torvalds/linux/commit/929473ea05db455ad88cdc081f2adc556b8dc48f",
      "discovery_time": "2013-11-04T15:55Z",
      "project_commit_id": "torvalds@linux/929473ea05db455ad88cdc081f2adc556b8dc48f",
      "extraction_time": "2025-08-31T15:41:49.189967",
      "label": 1,
      "vulnerability_type": "buffer_overflow",
      "difficulty_level": "advanced",
      "risk_factors": [
        "system_crash",
        "memory_corruption",
        "arbitrary_code_execution"
      ],
      "attack_vectors": [
        "memory_manipulation",
        "malicious_input",
        "code_analysis",
        "buffer_overflow",
        "reverse_engineering",
        "fuzzing"
      ],
      "mitigation_strategies": [
        "safe_string_functions",
        "dynamic_analysis",
        "code_review",
        "static_analysis",
        "memory_safety_checks",
        "input_validation",
        "fuzzing",
        "bounds_checking",
        "secure_coding_practices"
      ],
      "code_differences": {
        "has_differences": true,
        "source_lines": 2,
        "target_lines": 2,
        "character_differences": 632,
        "similarity_percentage": 16.923076923076923
      },
      "vulnerability_location": {
        "vulnerability_present": true,
        "fix_applied": true,
        "code_changed": true,
        "estimated_lines_changed": 0
      }
    },
    {
      "cve_id": "CVE-2013-2234",
      "cwe_id": "CWE-119",
      "cwe_name": "Buffer Overflow",
      "project": "torvalds",
      "severity": "critical",
      "weaponization_score": 7.0,
      "is_critical": true,
      "is_weaponizable": true,
      "is_high_priority_project": false,
      "vulnerable_code": "CWE-119 static int key_notify_sa_flush ( const struct km_event * c ) { struct sk_buff * skb ; struct sadb_msg * hdr ; skb = alloc_skb ( sizeof ( struct sadb_msg ) + 16 , GFP_ATOMIC ) ; if ( ! skb ) return - ENOBUFS ; hdr = ( struct sadb_msg * ) skb_put ( skb , sizeof ( struct sadb_msg ) ) ; hdr -> sadb_msg_satype = pfkey_proto2satype ( c -> data . proto ) ; hdr -> sadb_msg_type = SADB_FLUSH ; hdr -> sadb_msg_seq = c -> seq ; hdr -> sadb_msg_pid = c -> portid ; hdr -> sadb_msg_version = PF_KEY_V2 ; hdr -> sadb_msg_errno = ( uint8_t ) 0 ; hdr -> sadb_msg_len = ( sizeof ( struct sadb_msg ) / sizeof ( uint64_t ) ) ; <S2SV_StartBug> pfkey_broadcast ( skb , GFP_ATOMIC , BROADCAST_ALL , NULL , c -> net ) ; <S2SV_EndBug> return 0 ; }\n",
      "fixed_code": "<S2SV_ModStart> ) ) ; hdr -> sadb_msg_reserved = 0 ;\n",
      "source_code_length": 736,
      "target_code_length": 53,
      "vulnerability_patterns": {
        "null_pointer": 13,
        "total": 13
      },
      "total_patterns": 13,
      "original_address": "https://github.com/torvalds/linux/commit/a5cc68f3d63306d0d288f31edfc2ae6ef8ecd887",
      "discovery_time": "2013-07-04T21:55Z",
      "project_commit_id": "torvalds@linux/a5cc68f3d63306d0d288f31edfc2ae6ef8ecd887",
      "extraction_time": "2025-08-31T15:41:49.189986",
      "label": 1,
      "vulnerability_type": "buffer_overflow",
      "difficulty_level": "advanced",
      "risk_factors": [
        "system_crash",
        "memory_corruption",
        "arbitrary_code_execution"
      ],
      "attack_vectors": [
        "memory_manipulation",
        "malicious_input",
        "code_analysis",
        "buffer_overflow",
        "reverse_engineering",
        "fuzzing"
      ],
      "mitigation_strategies": [
        "safe_string_functions",
        "dynamic_analysis",
        "code_review",
        "static_analysis",
        "memory_safety_checks",
        "input_validation",
        "fuzzing",
        "bounds_checking",
        "secure_coding_practices"
      ],
      "code_differences": {
        "has_differences": true,
        "source_lines": 2,
        "target_lines": 2,
        "character_differences": 683,
        "similarity_percentage": 10.16949152542373
      },
      "vulnerability_location": {
        "vulnerability_present": true,
        "fix_applied": true,
        "code_changed": true,
        "estimated_lines_changed": 0
      }
    },
    {
      "cve_id": "CVE-2016-1621",
      "cwe_id": "CWE-119",
      "cwe_name": "Buffer Overflow",
      "project": "external",
      "severity": "critical",
      "weaponization_score": 7.0,
      "is_critical": true,
      "is_weaponizable": true,
      "is_high_priority_project": false,
      "vulnerable_code": "CWE-119 int main ( int argc , char * * argv ) { int frame_cnt = 0 ; FILE * outfile = NULL ; vpx_codec_ctx_t codec ; const VpxInterface * decoder = NULL ; VpxVideoReader * reader = NULL ; const VpxVideoInfo * info = NULL ; int n = 0 ; int m = 0 ; int is_range = 0 ; char * nptr = NULL ; exec_name = argv [ 0 ] ; if ( argc != 4 ) die ( \"Invalid<S2SV_blank>number<S2SV_blank>of<S2SV_blank>arguments.\" ) ; reader = vpx_video_reader_open ( argv [ 1 ] ) ; if ( ! reader ) die ( \"Failed<S2SV_blank>to<S2SV_blank>open<S2SV_blank>%s<S2SV_blank>for<S2SV_blank>reading.\" , argv [ 1 ] ) ; if ( ! ( outfile = fopen ( argv [ 2 ] , \"wb\" ) ) ) die ( \"Failed<S2SV_blank>to<S2SV_blank>open<S2SV_blank>%s<S2SV_blank>for<S2SV_blank>writing.\" , argv [ 2 ] ) ; n = strtol ( argv [ 3 ] , & nptr , 0 ) ; m = strtol ( nptr + 1 , NULL , 0 ) ; is_range = ( * nptr == '-' ) ; if ( ! n || ! m || ( * nptr != '-' && * nptr != '/' ) ) die ( \"Couldn\\'t<S2SV_blank>parse<S2SV_blank>pattern<S2SV_blank>%s.\\\\n\" , argv [ 3 ] ) ; info = vpx_video_reader_get_info ( reader ) ; decoder = get_vpx_decoder_by_fourcc ( info -> codec_fourcc ) ; if ( ! decoder ) die ( \"Unknown<S2SV_blank>input<S2SV_blank>codec.\" ) ; <S2SV_StartBug> printf ( \"Using<S2SV_blank>%s\\\\n\" , vpx_codec_iface_name ( decoder -> interface ( ) ) ) ; <S2SV_EndBug> <S2SV_StartBug> if ( vpx_codec_dec_init ( & codec , decoder -> interface ( ) , NULL , 0 ) ) <S2SV_EndBug> die_codec ( & codec , \"Failed<S2SV_blank>to<S2SV_blank>initialize<S2SV_blank>decoder.\" ) ; while ( vpx_video_reader_read_frame ( reader ) ) { vpx_codec_iter_t iter = NULL ; vpx_image_t * img = NULL ; size_t frame_size = 0 ; int skip ; const unsigned char * frame = vpx_video_reader_get_frame ( reader , & frame_size ) ; if ( vpx_codec_decode ( & codec , frame , ( unsigned int ) frame_size , NULL , 0 ) ) die_codec ( & codec , \"Failed<S2SV_blank>to<S2SV_blank>decode<S2SV_blank>frame.\" ) ; ++ frame_cnt ; skip = ( is_range && frame_cnt >= n && frame_cnt <= m ) || ( ! is_range && m - ( frame_cnt - 1 ) % m <= n ) ; if ( ! skip ) { putc ( '.' , stdout ) ; while ( ( img = vpx_codec_get_frame ( & codec , & iter ) ) != NULL ) vpx_img_write ( img , outfile ) ; } else { putc ( 'X' , stdout ) ; } fflush ( stdout ) ; } printf ( \"Processed<S2SV_blank>%d<S2SV_blank>frames.\\\\n\" , frame_cnt ) ; if ( vpx_codec_destroy ( & codec ) ) die_codec ( & codec , \"Failed<S2SV_blank>to<S2SV_blank>destroy<S2SV_blank>codec.\" ) ; printf ( \"Play:<S2SV_blank>ffplay<S2SV_blank>-f<S2SV_blank>rawvideo<S2SV_blank>-pix_fmt<S2SV_blank>yuv420p<S2SV_blank>-s<S2SV_blank>%dx%d<S2SV_blank>%s\\\\n\" , info -> frame_width , info -> frame_height , argv [ 2 ] ) ; vpx_video_reader_close ( reader ) ; fclose ( outfile ) ; return EXIT_SUCCESS ; }\n",
      "fixed_code": "<S2SV_ModStart> ( decoder -> codec_interface <S2SV_ModEnd> ( ) ) <S2SV_ModStart> , decoder -> codec_interface <S2SV_ModEnd> ( ) ,\n",
      "source_code_length": 2710,
      "target_code_length": 130,
      "vulnerability_patterns": {
        "integer_overflow": 1,
        "null_pointer": 10,
        "total": 11
      },
      "total_patterns": 11,
      "original_address": "https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426",
      "discovery_time": "2016-03-12T21:59Z",
      "project_commit_id": "external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426",
      "extraction_time": "2025-08-31T15:41:49.189999",
      "label": 1,
      "vulnerability_type": "buffer_overflow",
      "difficulty_level": "advanced",
      "risk_factors": [
        "system_crash",
        "memory_corruption",
        "arbitrary_code_execution"
      ],
      "attack_vectors": [
        "memory_manipulation",
        "malicious_input",
        "code_analysis",
        "buffer_overflow",
        "reverse_engineering",
        "fuzzing"
      ],
      "mitigation_strategies": [
        "safe_string_functions",
        "dynamic_analysis",
        "code_review",
        "static_analysis",
        "memory_safety_checks",
        "input_validation",
        "fuzzing",
        "bounds_checking",
        "secure_coding_practices"
      ],
      "code_differences": {
        "has_differences": true,
        "source_lines": 2,
        "target_lines": 2,
        "character_differences": 2580,
        "similarity_percentage": 4.464285714285714
      },
      "vulnerability_location": {
        "vulnerability_present": true,
        "fix_applied": true,
        "code_changed": true,
        "estimated_lines_changed": 0
      }
    },
    {
      "cve_id": "CVE-2016-1621",
      "cwe_id": "CWE-119",
      "cwe_name": "Buffer Overflow",
      "project": "external",
      "severity": "critical",
      "weaponization_score": 7.0,
      "is_critical": true,
      "is_weaponizable": true,
      "is_high_priority_project": false,
      "vulnerable_code": "CWE-119 int main ( int argc , char * * argv ) { int frame_cnt = 0 ; FILE * outfile = NULL ; vpx_codec_ctx_t codec ; const VpxInterface * decoder = NULL ; VpxVideoReader * reader = NULL ; const VpxVideoInfo * info = NULL ; int n = 0 ; int m = 0 ; int is_range = 0 ; char * nptr = NULL ; exec_name = argv [ 0 ] ; if ( argc != 4 ) die ( \"Invalid<S2SV_blank>number<S2SV_blank>of<S2SV_blank>arguments.\" ) ; reader = vpx_video_reader_open ( argv [ 1 ] ) ; if ( ! reader ) die ( \"Failed<S2SV_blank>to<S2SV_blank>open<S2SV_blank>%s<S2SV_blank>for<S2SV_blank>reading.\" , argv [ 1 ] ) ; if ( ! ( outfile = fopen ( argv [ 2 ] , \"wb\" ) ) ) die ( \"Failed<S2SV_blank>to<S2SV_blank>open<S2SV_blank>%s<S2SV_blank>for<S2SV_blank>writing.\" , argv [ 2 ] ) ; n = strtol ( argv [ 3 ] , & nptr , 0 ) ; m = strtol ( nptr + 1 , NULL , 0 ) ; is_range = ( * nptr == '-' ) ; if ( ! n || ! m || ( * nptr != '-' && * nptr != '/' ) ) die ( \"Couldn\\'t<S2SV_blank>parse<S2SV_blank>pattern<S2SV_blank>%s.\\\\n\" , argv [ 3 ] ) ; info = vpx_video_reader_get_info ( reader ) ; decoder = get_vpx_decoder_by_fourcc ( info -> codec_fourcc ) ; if ( ! decoder ) die ( \"Unknown<S2SV_blank>input<S2SV_blank>codec.\" ) ; <S2SV_StartBug> printf ( \"Using<S2SV_blank>%s\\\\n\" , vpx_codec_iface_name ( decoder -> interface ( ) ) ) ; <S2SV_EndBug> <S2SV_StartBug> if ( vpx_codec_dec_init ( & codec , decoder -> interface ( ) , NULL , 0 ) ) <S2SV_EndBug> die_codec ( & codec , \"Failed<S2SV_blank>to<S2SV_blank>initialize<S2SV_blank>decoder.\" ) ; while ( vpx_video_reader_read_frame ( reader ) ) { vpx_codec_iter_t iter = NULL ; vpx_image_t * img = NULL ; size_t frame_size = 0 ; int skip ; const unsigned char * frame = vpx_video_reader_get_frame ( reader , & frame_size ) ; if ( vpx_codec_decode ( & codec , frame , ( unsigned int ) frame_size , NULL , 0 ) ) die_codec ( & codec , \"Failed<S2SV_blank>to<S2SV_blank>decode<S2SV_blank>frame.\" ) ; ++ frame_cnt ; skip = ( is_range && frame_cnt >= n && frame_cnt <= m ) || ( ! is_range && m - ( frame_cnt - 1 ) % m <= n ) ; if ( ! skip ) { putc ( '.' , stdout ) ; while ( ( img = vpx_codec_get_frame ( & codec , & iter ) ) != NULL ) vpx_img_write ( img , outfile ) ; } else { putc ( 'X' , stdout ) ; } fflush ( stdout ) ; } printf ( \"Processed<S2SV_blank>%d<S2SV_blank>frames.\\\\n\" , frame_cnt ) ; if ( vpx_codec_destroy ( & codec ) ) die_codec ( & codec , \"Failed<S2SV_blank>to<S2SV_blank>destroy<S2SV_blank>codec.\" ) ; printf ( \"Play:<S2SV_blank>ffplay<S2SV_blank>-f<S2SV_blank>rawvideo<S2SV_blank>-pix_fmt<S2SV_blank>yuv420p<S2SV_blank>-s<S2SV_blank>%dx%d<S2SV_blank>%s\\\\n\" , info -> frame_width , info -> frame_height , argv [ 2 ] ) ; vpx_video_reader_close ( reader ) ; fclose ( outfile ) ; return EXIT_SUCCESS ; }\n",
      "fixed_code": "<S2SV_ModStart> ( decoder -> codec_interface <S2SV_ModEnd> ( ) ) <S2SV_ModStart> , decoder -> codec_interface <S2SV_ModEnd> ( ) ,\n",
      "source_code_length": 2710,
      "target_code_length": 130,
      "vulnerability_patterns": {
        "integer_overflow": 1,
        "null_pointer": 14,
        "total": 15
      },
      "total_patterns": 15,
      "original_address": "https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426",
      "discovery_time": "2016-03-12T21:59Z",
      "project_commit_id": "external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426",
      "extraction_time": "2025-08-31T15:41:49.190014",
      "label": 1,
      "vulnerability_type": "buffer_overflow",
      "difficulty_level": "advanced",
      "risk_factors": [
        "system_crash",
        "memory_corruption",
        "arbitrary_code_execution"
      ],
      "attack_vectors": [
        "memory_manipulation",
        "malicious_input",
        "code_analysis",
        "buffer_overflow",
        "reverse_engineering",
        "fuzzing"
      ],
      "mitigation_strategies": [
        "safe_string_functions",
        "dynamic_analysis",
        "code_review",
        "static_analysis",
        "memory_safety_checks",
        "input_validation",
        "fuzzing",
        "bounds_checking",
        "secure_coding_practices"
      ],
      "code_differences": {
        "has_differences": true,
        "source_lines": 2,
        "target_lines": 2,
        "character_differences": 2580,
        "similarity_percentage": 4.464285714285714
      },
      "vulnerability_location": {
        "vulnerability_present": true,
        "fix_applied": true,
        "code_changed": true,
        "estimated_lines_changed": 0
      }
    },
    {
      "cve_id": "CVE-2016-1621",
      "cwe_id": "CWE-119",
      "cwe_name": "Buffer Overflow",
      "project": "external",
      "severity": "critical",
      "weaponization_score": 7.0,
      "is_critical": true,
      "is_weaponizable": true,
      "is_high_priority_project": false,
      "vulnerable_code": "CWE-119 int main ( int argc , char * * argv ) { int frame_cnt = 0 ; FILE * outfile = NULL ; vpx_codec_ctx_t codec ; const VpxInterface * decoder = NULL ; VpxVideoReader * reader = NULL ; const VpxVideoInfo * info = NULL ; int n = 0 ; int m = 0 ; int is_range = 0 ; char * nptr = NULL ; exec_name = argv [ 0 ] ; if ( argc != 4 ) die ( \"Invalid<S2SV_blank>number<S2SV_blank>of<S2SV_blank>arguments.\" ) ; reader = vpx_video_reader_open ( argv [ 1 ] ) ; if ( ! reader ) die ( \"Failed<S2SV_blank>to<S2SV_blank>open<S2SV_blank>%s<S2SV_blank>for<S2SV_blank>reading.\" , argv [ 1 ] ) ; if ( ! ( outfile = fopen ( argv [ 2 ] , \"wb\" ) ) ) die ( \"Failed<S2SV_blank>to<S2SV_blank>open<S2SV_blank>%s<S2SV_blank>for<S2SV_blank>writing.\" , argv [ 2 ] ) ; n = strtol ( argv [ 3 ] , & nptr , 0 ) ; m = strtol ( nptr + 1 , NULL , 0 ) ; is_range = ( * nptr == '-' ) ; if ( ! n || ! m || ( * nptr != '-' && * nptr != '/' ) ) die ( \"Couldn\\'t<S2SV_blank>parse<S2SV_blank>pattern<S2SV_blank>%s.\\\\n\" , argv [ 3 ] ) ; info = vpx_video_reader_get_info ( reader ) ; decoder = get_vpx_decoder_by_fourcc ( info -> codec_fourcc ) ; if ( ! decoder ) die ( \"Unknown<S2SV_blank>input<S2SV_blank>codec.\" ) ; <S2SV_StartBug> printf ( \"Using<S2SV_blank>%s\\\\n\" , vpx_codec_iface_name ( decoder -> interface ( ) ) ) ; <S2SV_EndBug> <S2SV_StartBug> if ( vpx_codec_dec_init ( & codec , decoder -> interface ( ) , NULL , 0 ) ) <S2SV_EndBug> die_codec ( & codec , \"Failed<S2SV_blank>to<S2SV_blank>initialize<S2SV_blank>decoder.\" ) ; while ( vpx_video_reader_read_frame ( reader ) ) { vpx_codec_iter_t iter = NULL ; vpx_image_t * img = NULL ; size_t frame_size = 0 ; int skip ; const unsigned char * frame = vpx_video_reader_get_frame ( reader , & frame_size ) ; if ( vpx_codec_decode ( & codec , frame , ( unsigned int ) frame_size , NULL , 0 ) ) die_codec ( & codec , \"Failed<S2SV_blank>to<S2SV_blank>decode<S2SV_blank>frame.\" ) ; ++ frame_cnt ; skip = ( is_range && frame_cnt >= n && frame_cnt <= m ) || ( ! is_range && m - ( frame_cnt - 1 ) % m <= n ) ; if ( ! skip ) { putc ( '.' , stdout ) ; while ( ( img = vpx_codec_get_frame ( & codec , & iter ) ) != NULL ) vpx_img_write ( img , outfile ) ; } else { putc ( 'X' , stdout ) ; } fflush ( stdout ) ; } printf ( \"Processed<S2SV_blank>%d<S2SV_blank>frames.\\\\n\" , frame_cnt ) ; if ( vpx_codec_destroy ( & codec ) ) die_codec ( & codec , \"Failed<S2SV_blank>to<S2SV_blank>destroy<S2SV_blank>codec.\" ) ; printf ( \"Play:<S2SV_blank>ffplay<S2SV_blank>-f<S2SV_blank>rawvideo<S2SV_blank>-pix_fmt<S2SV_blank>yuv420p<S2SV_blank>-s<S2SV_blank>%dx%d<S2SV_blank>%s\\\\n\" , info -> frame_width , info -> frame_height , argv [ 2 ] ) ; vpx_video_reader_close ( reader ) ; fclose ( outfile ) ; return EXIT_SUCCESS ; }\n",
      "fixed_code": "<S2SV_ModStart> ( decoder -> codec_interface <S2SV_ModEnd> ( ) ) <S2SV_ModStart> , decoder -> codec_interface <S2SV_ModEnd> ( ) ,\n",
      "source_code_length": 2710,
      "target_code_length": 130,
      "vulnerability_patterns": {
        "integer_overflow": 2,
        "null_pointer": 60,
        "total": 62
      },
      "total_patterns": 62,
      "original_address": "https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426",
      "discovery_time": "2016-03-12T21:59Z",
      "project_commit_id": "external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426",
      "extraction_time": "2025-08-31T15:41:49.190029",
      "label": 1,
      "vulnerability_type": "buffer_overflow",
      "difficulty_level": "advanced",
      "risk_factors": [
        "system_crash",
        "memory_corruption",
        "arbitrary_code_execution"
      ],
      "attack_vectors": [
        "memory_manipulation",
        "malicious_input",
        "code_analysis",
        "buffer_overflow",
        "reverse_engineering",
        "fuzzing"
      ],
      "mitigation_strategies": [
        "safe_string_functions",
        "dynamic_analysis",
        "code_review",
        "static_analysis",
        "memory_safety_checks",
        "input_validation",
        "fuzzing",
        "bounds_checking",
        "secure_coding_practices"
      ],
      "code_differences": {
        "has_differences": true,
        "source_lines": 2,
        "target_lines": 2,
        "character_differences": 2580,
        "similarity_percentage": 4.464285714285714
      },
      "vulnerability_location": {
        "vulnerability_present": true,
        "fix_applied": true,
        "code_changed": true,
        "estimated_lines_changed": 0
      }
    },
    {
      "cve_id": "CVE-2016-1621",
      "cwe_id": "CWE-119",
      "cwe_name": "Buffer Overflow",
      "project": "external",
      "severity": "critical",
      "weaponization_score": 7.0,
      "is_critical": true,
      "is_weaponizable": true,
      "is_high_priority_project": false,
      "vulnerable_code": "CWE-119 int main ( int argc , char * * argv ) { int frame_cnt = 0 ; FILE * outfile = NULL ; vpx_codec_ctx_t codec ; const VpxInterface * decoder = NULL ; VpxVideoReader * reader = NULL ; const VpxVideoInfo * info = NULL ; int n = 0 ; int m = 0 ; int is_range = 0 ; char * nptr = NULL ; exec_name = argv [ 0 ] ; if ( argc != 4 ) die ( \"Invalid<S2SV_blank>number<S2SV_blank>of<S2SV_blank>arguments.\" ) ; reader = vpx_video_reader_open ( argv [ 1 ] ) ; if ( ! reader ) die ( \"Failed<S2SV_blank>to<S2SV_blank>open<S2SV_blank>%s<S2SV_blank>for<S2SV_blank>reading.\" , argv [ 1 ] ) ; if ( ! ( outfile = fopen ( argv [ 2 ] , \"wb\" ) ) ) die ( \"Failed<S2SV_blank>to<S2SV_blank>open<S2SV_blank>%s<S2SV_blank>for<S2SV_blank>writing.\" , argv [ 2 ] ) ; n = strtol ( argv [ 3 ] , & nptr , 0 ) ; m = strtol ( nptr + 1 , NULL , 0 ) ; is_range = ( * nptr == '-' ) ; if ( ! n || ! m || ( * nptr != '-' && * nptr != '/' ) ) die ( \"Couldn\\'t<S2SV_blank>parse<S2SV_blank>pattern<S2SV_blank>%s.\\\\n\" , argv [ 3 ] ) ; info = vpx_video_reader_get_info ( reader ) ; decoder = get_vpx_decoder_by_fourcc ( info -> codec_fourcc ) ; if ( ! decoder ) die ( \"Unknown<S2SV_blank>input<S2SV_blank>codec.\" ) ; <S2SV_StartBug> printf ( \"Using<S2SV_blank>%s\\\\n\" , vpx_codec_iface_name ( decoder -> interface ( ) ) ) ; <S2SV_EndBug> <S2SV_StartBug> if ( vpx_codec_dec_init ( & codec , decoder -> interface ( ) , NULL , 0 ) ) <S2SV_EndBug> die_codec ( & codec , \"Failed<S2SV_blank>to<S2SV_blank>initialize<S2SV_blank>decoder.\" ) ; while ( vpx_video_reader_read_frame ( reader ) ) { vpx_codec_iter_t iter = NULL ; vpx_image_t * img = NULL ; size_t frame_size = 0 ; int skip ; const unsigned char * frame = vpx_video_reader_get_frame ( reader , & frame_size ) ; if ( vpx_codec_decode ( & codec , frame , ( unsigned int ) frame_size , NULL , 0 ) ) die_codec ( & codec , \"Failed<S2SV_blank>to<S2SV_blank>decode<S2SV_blank>frame.\" ) ; ++ frame_cnt ; skip = ( is_range && frame_cnt >= n && frame_cnt <= m ) || ( ! is_range && m - ( frame_cnt - 1 ) % m <= n ) ; if ( ! skip ) { putc ( '.' , stdout ) ; while ( ( img = vpx_codec_get_frame ( & codec , & iter ) ) != NULL ) vpx_img_write ( img , outfile ) ; } else { putc ( 'X' , stdout ) ; } fflush ( stdout ) ; } printf ( \"Processed<S2SV_blank>%d<S2SV_blank>frames.\\\\n\" , frame_cnt ) ; if ( vpx_codec_destroy ( & codec ) ) die_codec ( & codec , \"Failed<S2SV_blank>to<S2SV_blank>destroy<S2SV_blank>codec.\" ) ; printf ( \"Play:<S2SV_blank>ffplay<S2SV_blank>-f<S2SV_blank>rawvideo<S2SV_blank>-pix_fmt<S2SV_blank>yuv420p<S2SV_blank>-s<S2SV_blank>%dx%d<S2SV_blank>%s\\\\n\" , info -> frame_width , info -> frame_height , argv [ 2 ] ) ; vpx_video_reader_close ( reader ) ; fclose ( outfile ) ; return EXIT_SUCCESS ; }\n",
      "fixed_code": "<S2SV_ModStart> ( decoder -> codec_interface <S2SV_ModEnd> ( ) ) <S2SV_ModStart> , decoder -> codec_interface <S2SV_ModEnd> ( ) ,\n",
      "source_code_length": 2710,
      "target_code_length": 130,
      "vulnerability_patterns": {
        "integer_overflow": 3,
        "null_pointer": 52,
        "total": 55
      },
      "total_patterns": 55,
      "original_address": "https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426",
      "discovery_time": "2016-03-12T21:59Z",
      "project_commit_id": "external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426",
      "extraction_time": "2025-08-31T15:41:49.190044",
      "label": 1,
      "vulnerability_type": "buffer_overflow",
      "difficulty_level": "advanced",
      "risk_factors": [
        "system_crash",
        "memory_corruption",
        "arbitrary_code_execution"
      ],
      "attack_vectors": [
        "memory_manipulation",
        "malicious_input",
        "code_analysis",
        "buffer_overflow",
        "reverse_engineering",
        "fuzzing"
      ],
      "mitigation_strategies": [
        "safe_string_functions",
        "dynamic_analysis",
        "code_review",
        "static_analysis",
        "memory_safety_checks",
        "input_validation",
        "fuzzing",
        "bounds_checking",
        "secure_coding_practices"
      ],
      "code_differences": {
        "has_differences": true,
        "source_lines": 2,
        "target_lines": 2,
        "character_differences": 2580,
        "similarity_percentage": 4.464285714285714
      },
      "vulnerability_location": {
        "vulnerability_present": true,
        "fix_applied": true,
        "code_changed": true,
        "estimated_lines_changed": 0
      }
    },
    {
      "cve_id": "CVE-2016-2315",
      "cwe_id": "CWE-119",
      "cwe_name": "Buffer Overflow",
      "project": "git",
      "severity": "critical",
      "weaponization_score": 7.0,
      "is_critical": true,
      "is_weaponizable": true,
      "is_high_priority_project": false,
      "vulnerable_code": "CWE-119 static void finish_object ( struct object * obj , <S2SV_StartBug> struct strbuf * path , const char * name , <S2SV_EndBug> void * cb_data ) { struct rev_list_info * info = cb_data ; if ( obj -> type == OBJ_BLOB && ! has_object_file ( & obj -> oid ) ) die ( \"missing<S2SV_blank>blob<S2SV_blank>object<S2SV_blank>\\'%s\\'\" , oid_to_hex ( & obj -> oid ) ) ; if ( info -> revs -> verify_objects && ! obj -> parsed && obj -> type != OBJ_COMMIT ) parse_object ( obj -> oid . hash ) ; }\n",
      "fixed_code": "<S2SV_ModStart> * obj , <S2SV_ModEnd> const char *\n",
      "source_code_length": 486,
      "target_code_length": 51,
      "vulnerability_patterns": {
        "null_pointer": 15,
        "total": 15
      },
      "total_patterns": 15,
      "original_address": "https://github.com/git/git/commit/de1e67d0703894cb6ea782e36abb63976ab07e60",
      "discovery_time": "2016-04-08T14:59Z",
      "project_commit_id": "git@git/de1e67d0703894cb6ea782e36abb63976ab07e60",
      "extraction_time": "2025-08-31T15:41:49.190061",
      "label": 1,
      "vulnerability_type": "buffer_overflow",
      "difficulty_level": "advanced",
      "risk_factors": [
        "system_crash",
        "memory_corruption",
        "arbitrary_code_execution"
      ],
      "attack_vectors": [
        "memory_manipulation",
        "malicious_input",
        "code_analysis",
        "buffer_overflow",
        "reverse_engineering",
        "fuzzing"
      ],
      "mitigation_strategies": [
        "safe_string_functions",
        "dynamic_analysis",
        "code_review",
        "static_analysis",
        "memory_safety_checks",
        "input_validation",
        "fuzzing",
        "bounds_checking",
        "secure_coding_practices"
      ],
      "code_differences": {
        "has_differences": true,
        "source_lines": 2,
        "target_lines": 2,
        "character_differences": 435,
        "similarity_percentage": 10.416666666666668
      },
      "vulnerability_location": {
        "vulnerability_present": true,
        "fix_applied": true,
        "code_changed": true,
        "estimated_lines_changed": 0
      }
    },
    {
      "cve_id": "CVE-2018-16391",
      "cwe_id": "CWE-119",
      "cwe_name": "Buffer Overflow",
      "project": "OpenSC",
      "severity": "critical",
      "weaponization_score": 7.0,
      "is_critical": true,
      "is_weaponizable": true,
      "is_high_priority_project": false,
      "vulnerable_code": "CWE-119 static int tcos_select_file ( sc_card_t * card , const sc_path_t * in_path , sc_file_t * * file_out ) { sc_context_t * ctx ; sc_apdu_t apdu ; sc_file_t * file = NULL ; u8 buf [ SC_MAX_APDU_BUFFER_SIZE ] , pathbuf [ SC_MAX_PATH_SIZE ] , * path = pathbuf ; unsigned int i ; int r , pathlen ; assert ( card != NULL && in_path != NULL ) ; ctx = card -> ctx ; memcpy ( path , in_path -> value , in_path -> len ) ; pathlen = in_path -> len ; sc_format_apdu ( card , & apdu , SC_APDU_CASE_4_SHORT , 0xA4 , 0 , 0x04 ) ; switch ( in_path -> type ) { case SC_PATH_TYPE_FILE_ID : if ( pathlen != 2 ) return SC_ERROR_INVALID_ARGUMENTS ; case SC_PATH_TYPE_FROM_CURRENT : apdu . p1 = 9 ; break ; case SC_PATH_TYPE_DF_NAME : apdu . p1 = 4 ; break ; case SC_PATH_TYPE_PATH : apdu . p1 = 8 ; if ( pathlen >= 2 && memcmp ( path , \"\\\\x3F\\\\x00\" , 2 ) == 0 ) path += 2 , pathlen -= 2 ; if ( pathlen == 0 ) apdu . p1 = 0 ; break ; case SC_PATH_TYPE_PARENT : apdu . p1 = 3 ; pathlen = 0 ; break ; default : SC_FUNC_RETURN ( ctx , SC_LOG_DEBUG_VERBOSE , SC_ERROR_INVALID_ARGUMENTS ) ; } if ( pathlen == 0 ) apdu . cse = SC_APDU_CASE_2_SHORT ; apdu . lc = pathlen ; apdu . data = path ; apdu . datalen = pathlen ; if ( file_out != NULL ) { apdu . resp = buf ; apdu . resplen = sizeof ( buf ) ; apdu . le = 256 ; } else { apdu . resplen = 0 ; apdu . le = 0 ; apdu . p2 = 0x0C ; apdu . cse = ( pathlen == 0 ) ? SC_APDU_CASE_1 : SC_APDU_CASE_3_SHORT ; } r = sc_transmit_apdu ( card , & apdu ) ; SC_TEST_RET ( ctx , SC_LOG_DEBUG_NORMAL , r , \"APDU<S2SV_blank>transmit<S2SV_blank>failed\" ) ; r = sc_check_sw ( card , apdu . sw1 , apdu . sw2 ) ; if ( r || file_out == NULL ) SC_FUNC_RETURN ( ctx , SC_LOG_DEBUG_VERBOSE , r ) ; if ( apdu . resplen < 1 || apdu . resp [ 0 ] != 0x62 ) { sc_debug ( ctx , SC_LOG_DEBUG_NORMAL , \"received<S2SV_blank>invalid<S2SV_blank>template<S2SV_blank>%02X\\\\n\" , apdu . resp [ 0 ] ) ; SC_FUNC_RETURN ( ctx , SC_LOG_DEBUG_VERBOSE , SC_ERROR_UNKNOWN_DATA_RECEIVED ) ; } file = sc_file_new ( ) ; if ( file == NULL ) SC_FUNC_RETURN ( ctx , SC_LOG_DEBUG_NORMAL , SC_ERROR_OUT_OF_MEMORY ) ; * file_out = file ; file -> path = * in_path ; for ( i = 2 ; i + 1 < apdu . resplen && i + 1 + apdu . resp [ i + 1 ] < apdu . resplen ; i += 2 + apdu . resp [ i + 1 ] ) { <S2SV_StartBug> int j , len = apdu . resp [ i + 1 ] ; <S2SV_EndBug> unsigned char type = apdu . resp [ i ] , * d = apdu . resp + i + 2 ; switch ( type ) { case 0x80 : case 0x81 : file -> size = 0 ; for ( j = 0 ; j < len ; ++ j ) file -> size = ( file -> size << 8 ) | d [ j ] ; break ; case 0x82 : file -> shareable = ( d [ 0 ] & 0x40 ) ? 1 : 0 ; file -> ef_structure = d [ 0 ] & 7 ; switch ( ( d [ 0 ] >> 3 ) & 7 ) { case 0 : file -> type = SC_FILE_TYPE_WORKING_EF ; break ; case 7 : file -> type = SC_FILE_TYPE_DF ; break ; default : sc_debug ( ctx , SC_LOG_DEBUG_NORMAL , \"invalid<S2SV_blank>file<S2SV_blank>type<S2SV_blank>%02X<S2SV_blank>in<S2SV_blank>file<S2SV_blank>descriptor\\\\n\" , d [ 0 ] ) ; SC_FUNC_RETURN ( ctx , SC_LOG_DEBUG_VERBOSE , SC_ERROR_UNKNOWN_DATA_RECEIVED ) ; } break ; case 0x83 : file -> id = ( d [ 0 ] << 8 ) | d [ 1 ] ; break ; case 0x84 : <S2SV_StartBug> memcpy ( file -> name , d , len ) ; <S2SV_EndBug> <S2SV_StartBug> file -> namelen = len ; <S2SV_EndBug> break ; case 0x86 : sc_file_set_sec_attr ( file , d , len ) ; break ; default : if ( len > 0 ) sc_file_set_prop_attr ( file , d , len ) ; } } file -> magic = SC_FILE_MAGIC ; parse_sec_attr ( card , file , file -> sec_attr , file -> sec_attr_len ) ; return 0 ; }\n",
      "fixed_code": "<S2SV_ModStart> ] ) { size_t <S2SV_ModEnd> j , len <S2SV_ModStart> case 0x84 : file -> namelen = MIN ( sizeof file -> name , len ) ; <S2SV_ModStart> , d , <S2SV_ModEnd> file -> namelen <S2SV_ModStart> file -> namelen ) <S2SV_ModEnd> ; break ;\n",
      "source_code_length": 3513,
      "target_code_length": 243,
      "vulnerability_patterns": {
        "use_after_free": 1,
        "null_pointer": 3,
        "memory_leak": 1,
        "total": 5
      },
      "total_patterns": 5,
      "original_address": "https://github.com/OpenSC/OpenSC/commit/360e95d45ac4123255a4c796db96337f332160ad#diff-477b7a40136bb418b10ce271c8664536",
      "discovery_time": "2018-09-03T14:29Z",
      "project_commit_id": "OpenSC@OpenSC/360e95d45ac4123255a4c796db96337f332160ad",
      "extraction_time": "2025-08-31T15:41:49.190075",
      "label": 1,
      "vulnerability_type": "buffer_overflow",
      "difficulty_level": "advanced",
      "risk_factors": [
        "system_crash",
        "memory_corruption",
        "arbitrary_code_execution",
        "use_after_free"
      ],
      "attack_vectors": [
        "memory_manipulation",
        "malicious_input",
        "code_analysis",
        "buffer_overflow",
        "reverse_engineering",
        "fuzzing"
      ],
      "mitigation_strategies": [
        "safe_string_functions",
        "dynamic_analysis",
        "code_review",
        "static_analysis",
        "memory_safety_checks",
        "input_validation",
        "fuzzing",
        "bounds_checking",
        "secure_coding_practices"
      ],
      "code_differences": {
        "has_differences": true,
        "source_lines": 2,
        "target_lines": 2,
        "character_differences": 3270,
        "similarity_percentage": 12.582781456953644
      },
      "vulnerability_location": {
        "vulnerability_present": true,
        "fix_applied": true,
        "code_changed": true,
        "estimated_lines_changed": 0
      }
    },
    {
      "cve_id": "CVE-2018-8788",
      "cwe_id": "CWE-787",
      "cwe_name": "Out-of-bounds Write",
      "project": "FreeRDP",
      "severity": "critical",
      "weaponization_score": 7.0,
      "is_critical": true,
      "is_weaponizable": true,
      "is_high_priority_project": false,
      "vulnerable_code": "CWE-787 <S2SV_StartBug> static void nsc_rle_decompress_data ( NSC_CONTEXT * context ) <S2SV_EndBug> { UINT16 i ; BYTE * rle ; UINT32 planeSize ; UINT32 originalSize ; <S2SV_StartBug> rle = context -> Planes ; <S2SV_EndBug> for ( i = 0 ; i < 4 ; i ++ ) { originalSize = context -> OrgByteCount [ i ] ; planeSize = context -> PlaneByteCount [ i ] ; if ( planeSize == 0 ) <S2SV_StartBug> FillMemory ( context -> priv -> PlaneBuffers [ i ] , originalSize , 0xFF ) ; <S2SV_EndBug> <S2SV_StartBug> else if ( planeSize < originalSize ) <S2SV_EndBug> <S2SV_StartBug> nsc_rle_decode ( rle , context -> priv -> PlaneBuffers [ i ] , originalSize ) ; <S2SV_EndBug> else CopyMemory ( context -> priv -> PlaneBuffers [ i ] , rle , originalSize ) ; <S2SV_StartBug> rle += planeSize ; <S2SV_EndBug> } <S2SV_StartBug> } <S2SV_EndBug>\n",
      "fixed_code": "<S2SV_ModStart> <S2SV_null> <S2SV_null> static BOOL <S2SV_ModEnd> nsc_rle_decompress_data ( NSC_CONTEXT <S2SV_ModStart> UINT32 originalSize ; if ( ! context ) return FALSE ; <S2SV_ModStart> == 0 ) { if ( context -> priv -> PlaneBuffersLength < originalSize ) return FALSE ; <S2SV_ModStart> 0xFF ) ; } <S2SV_ModStart> < originalSize ) { if ( ! <S2SV_ModStart> i ] , context -> priv -> PlaneBuffersLength , originalSize ) ) return FALSE ; } else { if ( context -> priv -> PlaneBuffersLength < originalSize ) return FALSE ; <S2SV_ModEnd> CopyMemory ( context <S2SV_ModStart> originalSize ) ; } <S2SV_ModStart> planeSize ; } return TRUE ;\n",
      "source_code_length": 817,
      "target_code_length": 635,
      "vulnerability_patterns": {
        "integer_overflow": 2,
        "null_pointer": 9,
        "total": 11
      },
      "total_patterns": 11,
      "original_address": "https://github.com/FreeRDP/FreeRDP/commit/d1112c279bd1a327e8e4d0b5f371458bf2579659",
      "discovery_time": "2018-11-29T18:29Z",
      "project_commit_id": "FreeRDP@FreeRDP/d1112c279bd1a327e8e4d0b5f371458bf2579659",
      "extraction_time": "2025-08-31T15:41:49.190138",
      "label": 1,
      "vulnerability_type": "out-of-bounds_write",
      "difficulty_level": "advanced",
      "risk_factors": [
        "system_crash",
        "memory_corruption",
        "arbitrary_code_execution"
      ],
      "attack_vectors": [
        "memory_manipulation",
        "malicious_input",
        "code_analysis",
        "buffer_overflow",
        "reverse_engineering",
        "fuzzing"
      ],
      "mitigation_strategies": [
        "safe_string_functions",
        "dynamic_analysis",
        "code_review",
        "static_analysis",
        "memory_safety_checks",
        "input_validation",
        "fuzzing",
        "bounds_checking",
        "secure_coding_practices"
      ],
      "code_differences": {
        "has_differences": true,
        "source_lines": 2,
        "target_lines": 2,
        "character_differences": 182,
        "similarity_percentage": 45.28301886792453
      },
      "vulnerability_location": {
        "vulnerability_present": true,
        "fix_applied": true,
        "code_changed": true,
        "estimated_lines_changed": 0
      }
    },
    {
      "cve_id": "CVE-2017-18193",
      "cwe_id": "CWE-119",
      "cwe_name": "Buffer Overflow",
      "project": "torvalds",
      "severity": "critical",
      "weaponization_score": 7.0,
      "is_critical": true,
      "is_weaponizable": true,
      "is_high_priority_project": false,
      "vulnerable_code": "CWE-119 bool f2fs_init_extent_tree ( struct inode * inode , struct f2fs_extent * i_ext ) { <S2SV_StartBug> struct f2fs_sb_info * sbi = F2FS_I_SB ( inode ) ; <S2SV_EndBug> struct extent_tree * et ; struct extent_node * en ; struct extent_info ei ; if ( ! f2fs_may_extent_tree ( inode ) ) { if ( i_ext && i_ext -> len ) { i_ext -> len = 0 ; return true ; } return false ; } et = __grab_extent_tree ( inode ) ; <S2SV_StartBug> if ( ! i_ext || ! i_ext -> len ) <S2SV_EndBug> return false ; get_extent_info ( & ei , i_ext ) ; write_lock ( & et -> lock ) ; if ( atomic_read ( & et -> node_cnt ) ) goto out ; en = __init_extent_tree ( sbi , et , & ei ) ; if ( en ) { spin_lock ( & sbi -> extent_lock ) ; list_add_tail ( & en -> list , & sbi -> extent_list ) ; spin_unlock ( & sbi -> extent_lock ) ; } out : write_unlock ( & et -> lock ) ; <S2SV_StartBug> return false ; <S2SV_EndBug> }\n",
      "fixed_code": "<S2SV_ModStart> i_ext ) { bool ret = __f2fs_init_extent_tree ( inode , i_ext <S2SV_ModEnd> ) ; if <S2SV_ModStart> if ( ! F2FS_I ( inode ) -> extent_tree ) set_inode_flag ( inode , FI_NO_EXTENT <S2SV_ModEnd> ) ; return <S2SV_ModStart> ) ; return ret <S2SV_ModEnd> ; } <S2SV_null>\n",
      "source_code_length": 879,
      "target_code_length": 279,
      "vulnerability_patterns": {
        "null_pointer": 10,
        "total": 10
      },
      "total_patterns": 10,
      "original_address": "https://github.com/torvalds/linux/commit/dad48e73127ba10279ea33e6dbc8d3905c4d31c0",
      "discovery_time": "2018-02-22T15:29Z",
      "project_commit_id": "torvalds@linux/dad48e73127ba10279ea33e6dbc8d3905c4d31c0",
      "extraction_time": "2025-08-31T15:41:49.190175",
      "label": 1,
      "vulnerability_type": "buffer_overflow",
      "difficulty_level": "advanced",
      "risk_factors": [
        "system_crash",
        "memory_corruption",
        "arbitrary_code_execution"
      ],
      "attack_vectors": [
        "memory_manipulation",
        "malicious_input",
        "code_analysis",
        "buffer_overflow",
        "reverse_engineering",
        "fuzzing"
      ],
      "mitigation_strategies": [
        "safe_string_functions",
        "dynamic_analysis",
        "code_review",
        "static_analysis",
        "memory_safety_checks",
        "input_validation",
        "fuzzing",
        "bounds_checking",
        "secure_coding_practices"
      ],
      "code_differences": {
        "has_differences": true,
        "source_lines": 2,
        "target_lines": 2,
        "character_differences": 600,
        "similarity_percentage": 23.809523809523807
      },
      "vulnerability_location": {
        "vulnerability_present": true,
        "fix_applied": true,
        "code_changed": true,
        "estimated_lines_changed": 0
      }
    },
    {
      "cve_id": "CVE-2016-1621",
      "cwe_id": "CWE-119",
      "cwe_name": "Buffer Overflow",
      "project": "external",
      "severity": "critical",
      "weaponization_score": 7.0,
      "is_critical": true,
      "is_weaponizable": true,
      "is_high_priority_project": false,
      "vulnerable_code": "CWE-119 int main ( int argc , char * * argv ) { int frame_cnt = 0 ; FILE * outfile = NULL ; vpx_codec_ctx_t codec ; const VpxInterface * decoder = NULL ; VpxVideoReader * reader = NULL ; const VpxVideoInfo * info = NULL ; int n = 0 ; int m = 0 ; int is_range = 0 ; char * nptr = NULL ; exec_name = argv [ 0 ] ; if ( argc != 4 ) die ( \"Invalid<S2SV_blank>number<S2SV_blank>of<S2SV_blank>arguments.\" ) ; reader = vpx_video_reader_open ( argv [ 1 ] ) ; if ( ! reader ) die ( \"Failed<S2SV_blank>to<S2SV_blank>open<S2SV_blank>%s<S2SV_blank>for<S2SV_blank>reading.\" , argv [ 1 ] ) ; if ( ! ( outfile = fopen ( argv [ 2 ] , \"wb\" ) ) ) die ( \"Failed<S2SV_blank>to<S2SV_blank>open<S2SV_blank>%s<S2SV_blank>for<S2SV_blank>writing.\" , argv [ 2 ] ) ; n = strtol ( argv [ 3 ] , & nptr , 0 ) ; m = strtol ( nptr + 1 , NULL , 0 ) ; is_range = ( * nptr == '-' ) ; if ( ! n || ! m || ( * nptr != '-' && * nptr != '/' ) ) die ( \"Couldn\\'t<S2SV_blank>parse<S2SV_blank>pattern<S2SV_blank>%s.\\\\n\" , argv [ 3 ] ) ; info = vpx_video_reader_get_info ( reader ) ; decoder = get_vpx_decoder_by_fourcc ( info -> codec_fourcc ) ; if ( ! decoder ) die ( \"Unknown<S2SV_blank>input<S2SV_blank>codec.\" ) ; <S2SV_StartBug> printf ( \"Using<S2SV_blank>%s\\\\n\" , vpx_codec_iface_name ( decoder -> interface ( ) ) ) ; <S2SV_EndBug> <S2SV_StartBug> if ( vpx_codec_dec_init ( & codec , decoder -> interface ( ) , NULL , 0 ) ) <S2SV_EndBug> die_codec ( & codec , \"Failed<S2SV_blank>to<S2SV_blank>initialize<S2SV_blank>decoder.\" ) ; while ( vpx_video_reader_read_frame ( reader ) ) { vpx_codec_iter_t iter = NULL ; vpx_image_t * img = NULL ; size_t frame_size = 0 ; int skip ; const unsigned char * frame = vpx_video_reader_get_frame ( reader , & frame_size ) ; if ( vpx_codec_decode ( & codec , frame , ( unsigned int ) frame_size , NULL , 0 ) ) die_codec ( & codec , \"Failed<S2SV_blank>to<S2SV_blank>decode<S2SV_blank>frame.\" ) ; ++ frame_cnt ; skip = ( is_range && frame_cnt >= n && frame_cnt <= m ) || ( ! is_range && m - ( frame_cnt - 1 ) % m <= n ) ; if ( ! skip ) { putc ( '.' , stdout ) ; while ( ( img = vpx_codec_get_frame ( & codec , & iter ) ) != NULL ) vpx_img_write ( img , outfile ) ; } else { putc ( 'X' , stdout ) ; } fflush ( stdout ) ; } printf ( \"Processed<S2SV_blank>%d<S2SV_blank>frames.\\\\n\" , frame_cnt ) ; if ( vpx_codec_destroy ( & codec ) ) die_codec ( & codec , \"Failed<S2SV_blank>to<S2SV_blank>destroy<S2SV_blank>codec.\" ) ; printf ( \"Play:<S2SV_blank>ffplay<S2SV_blank>-f<S2SV_blank>rawvideo<S2SV_blank>-pix_fmt<S2SV_blank>yuv420p<S2SV_blank>-s<S2SV_blank>%dx%d<S2SV_blank>%s\\\\n\" , info -> frame_width , info -> frame_height , argv [ 2 ] ) ; vpx_video_reader_close ( reader ) ; fclose ( outfile ) ; return EXIT_SUCCESS ; }\n",
      "fixed_code": "<S2SV_ModStart> ( decoder -> codec_interface <S2SV_ModEnd> ( ) ) <S2SV_ModStart> , decoder -> codec_interface <S2SV_ModEnd> ( ) ,\n",
      "source_code_length": 2710,
      "target_code_length": 130,
      "vulnerability_patterns": {
        "integer_overflow": 1,
        "format_string": 1,
        "null_pointer": 17,
        "total": 19
      },
      "total_patterns": 19,
      "original_address": "https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426",
      "discovery_time": "2016-03-12T21:59Z",
      "project_commit_id": "external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426",
      "extraction_time": "2025-08-31T15:41:49.190198",
      "label": 1,
      "vulnerability_type": "buffer_overflow",
      "difficulty_level": "advanced",
      "risk_factors": [
        "system_crash",
        "memory_corruption",
        "arbitrary_code_execution"
      ],
      "attack_vectors": [
        "memory_manipulation",
        "malicious_input",
        "code_analysis",
        "buffer_overflow",
        "reverse_engineering",
        "fuzzing"
      ],
      "mitigation_strategies": [
        "safe_string_functions",
        "dynamic_analysis",
        "code_review",
        "static_analysis",
        "memory_safety_checks",
        "input_validation",
        "fuzzing",
        "bounds_checking",
        "secure_coding_practices"
      ],
      "code_differences": {
        "has_differences": true,
        "source_lines": 2,
        "target_lines": 2,
        "character_differences": 2580,
        "similarity_percentage": 4.464285714285714
      },
      "vulnerability_location": {
        "vulnerability_present": true,
        "fix_applied": true,
        "code_changed": true,
        "estimated_lines_changed": 0
      }
    },
    {
      "cve_id": "CVE-2016-1621",
      "cwe_id": "CWE-119",
      "cwe_name": "Buffer Overflow",
      "project": "external",
      "severity": "critical",
      "weaponization_score": 7.0,
      "is_critical": true,
      "is_weaponizable": true,
      "is_high_priority_project": false,
      "vulnerable_code": "CWE-119 int main ( int argc , char * * argv ) { int frame_cnt = 0 ; FILE * outfile = NULL ; vpx_codec_ctx_t codec ; const VpxInterface * decoder = NULL ; VpxVideoReader * reader = NULL ; const VpxVideoInfo * info = NULL ; int n = 0 ; int m = 0 ; int is_range = 0 ; char * nptr = NULL ; exec_name = argv [ 0 ] ; if ( argc != 4 ) die ( \"Invalid<S2SV_blank>number<S2SV_blank>of<S2SV_blank>arguments.\" ) ; reader = vpx_video_reader_open ( argv [ 1 ] ) ; if ( ! reader ) die ( \"Failed<S2SV_blank>to<S2SV_blank>open<S2SV_blank>%s<S2SV_blank>for<S2SV_blank>reading.\" , argv [ 1 ] ) ; if ( ! ( outfile = fopen ( argv [ 2 ] , \"wb\" ) ) ) die ( \"Failed<S2SV_blank>to<S2SV_blank>open<S2SV_blank>%s<S2SV_blank>for<S2SV_blank>writing.\" , argv [ 2 ] ) ; n = strtol ( argv [ 3 ] , & nptr , 0 ) ; m = strtol ( nptr + 1 , NULL , 0 ) ; is_range = ( * nptr == '-' ) ; if ( ! n || ! m || ( * nptr != '-' && * nptr != '/' ) ) die ( \"Couldn\\'t<S2SV_blank>parse<S2SV_blank>pattern<S2SV_blank>%s.\\\\n\" , argv [ 3 ] ) ; info = vpx_video_reader_get_info ( reader ) ; decoder = get_vpx_decoder_by_fourcc ( info -> codec_fourcc ) ; if ( ! decoder ) die ( \"Unknown<S2SV_blank>input<S2SV_blank>codec.\" ) ; <S2SV_StartBug> printf ( \"Using<S2SV_blank>%s\\\\n\" , vpx_codec_iface_name ( decoder -> interface ( ) ) ) ; <S2SV_EndBug> <S2SV_StartBug> if ( vpx_codec_dec_init ( & codec , decoder -> interface ( ) , NULL , 0 ) ) <S2SV_EndBug> die_codec ( & codec , \"Failed<S2SV_blank>to<S2SV_blank>initialize<S2SV_blank>decoder.\" ) ; while ( vpx_video_reader_read_frame ( reader ) ) { vpx_codec_iter_t iter = NULL ; vpx_image_t * img = NULL ; size_t frame_size = 0 ; int skip ; const unsigned char * frame = vpx_video_reader_get_frame ( reader , & frame_size ) ; if ( vpx_codec_decode ( & codec , frame , ( unsigned int ) frame_size , NULL , 0 ) ) die_codec ( & codec , \"Failed<S2SV_blank>to<S2SV_blank>decode<S2SV_blank>frame.\" ) ; ++ frame_cnt ; skip = ( is_range && frame_cnt >= n && frame_cnt <= m ) || ( ! is_range && m - ( frame_cnt - 1 ) % m <= n ) ; if ( ! skip ) { putc ( '.' , stdout ) ; while ( ( img = vpx_codec_get_frame ( & codec , & iter ) ) != NULL ) vpx_img_write ( img , outfile ) ; } else { putc ( 'X' , stdout ) ; } fflush ( stdout ) ; } printf ( \"Processed<S2SV_blank>%d<S2SV_blank>frames.\\\\n\" , frame_cnt ) ; if ( vpx_codec_destroy ( & codec ) ) die_codec ( & codec , \"Failed<S2SV_blank>to<S2SV_blank>destroy<S2SV_blank>codec.\" ) ; printf ( \"Play:<S2SV_blank>ffplay<S2SV_blank>-f<S2SV_blank>rawvideo<S2SV_blank>-pix_fmt<S2SV_blank>yuv420p<S2SV_blank>-s<S2SV_blank>%dx%d<S2SV_blank>%s\\\\n\" , info -> frame_width , info -> frame_height , argv [ 2 ] ) ; vpx_video_reader_close ( reader ) ; fclose ( outfile ) ; return EXIT_SUCCESS ; }\n",
      "fixed_code": "<S2SV_ModStart> ( decoder -> codec_interface <S2SV_ModEnd> ( ) ) <S2SV_ModStart> , decoder -> codec_interface <S2SV_ModEnd> ( ) ,\n",
      "source_code_length": 2710,
      "target_code_length": 130,
      "vulnerability_patterns": {
        "integer_overflow": 4,
        "null_pointer": 12,
        "total": 16
      },
      "total_patterns": 16,
      "original_address": "https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426",
      "discovery_time": "2016-03-12T21:59Z",
      "project_commit_id": "external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426",
      "extraction_time": "2025-08-31T15:41:49.190215",
      "label": 1,
      "vulnerability_type": "buffer_overflow",
      "difficulty_level": "advanced",
      "risk_factors": [
        "system_crash",
        "memory_corruption",
        "arbitrary_code_execution"
      ],
      "attack_vectors": [
        "memory_manipulation",
        "malicious_input",
        "code_analysis",
        "buffer_overflow",
        "reverse_engineering",
        "fuzzing"
      ],
      "mitigation_strategies": [
        "safe_string_functions",
        "dynamic_analysis",
        "code_review",
        "static_analysis",
        "memory_safety_checks",
        "input_validation",
        "fuzzing",
        "bounds_checking",
        "secure_coding_practices"
      ],
      "code_differences": {
        "has_differences": true,
        "source_lines": 2,
        "target_lines": 2,
        "character_differences": 2580,
        "similarity_percentage": 4.464285714285714
      },
      "vulnerability_location": {
        "vulnerability_present": true,
        "fix_applied": true,
        "code_changed": true,
        "estimated_lines_changed": 0
      }
    },
    {
      "cve_id": "CVE-2014-0205",
      "cwe_id": "CWE-119",
      "cwe_name": "Buffer Overflow",
      "project": "torvalds",
      "severity": "critical",
      "weaponization_score": 7.0,
      "is_critical": true,
      "is_weaponizable": true,
      "is_high_priority_project": false,
      "vulnerable_code": "CWE-119 static int futex_wait ( u32 __user * uaddr , int fshared , u32 val , ktime_t * abs_time , u32 bitset , int clockrt ) { struct hrtimer_sleeper timeout , * to = NULL ; struct restart_block * restart ; struct futex_hash_bucket * hb ; struct futex_q q ; int ret ; if ( ! bitset ) return - EINVAL ; q . pi_state = NULL ; q . bitset = bitset ; q . rt_waiter = NULL ; q . requeue_pi_key = NULL ; if ( abs_time ) { to = & timeout ; hrtimer_init_on_stack ( & to -> timer , clockrt ? CLOCK_REALTIME : CLOCK_MONOTONIC , HRTIMER_MODE_ABS ) ; hrtimer_init_sleeper ( to , current ) ; hrtimer_set_expires_range_ns ( & to -> timer , * abs_time , current -> timer_slack_ns ) ; } retry : ret = futex_wait_setup ( uaddr , val , fshared , & q , & hb ) ; if ( ret ) goto out ; futex_wait_queue_me ( hb , & q , to ) ; ret = 0 ; if ( ! unqueue_me ( & q ) ) <S2SV_StartBug> goto out_put_key ; <S2SV_EndBug> ret = - ETIMEDOUT ; if ( to && ! to -> task ) <S2SV_StartBug> goto out_put_key ; <S2SV_EndBug> <S2SV_StartBug> if ( ! signal_pending ( current ) ) { <S2SV_EndBug> put_futex_key ( fshared , & q . key ) ; goto retry ; <S2SV_StartBug> } <S2SV_EndBug> ret = - ERESTARTSYS ; if ( ! abs_time ) <S2SV_StartBug> goto out_put_key ; <S2SV_EndBug> restart = & current_thread_info ( ) -> restart_block ; restart -> fn = futex_wait_restart ; restart -> futex . uaddr = ( u32 * ) uaddr ; restart -> futex . val = val ; restart -> futex . time = abs_time -> tv64 ; restart -> futex . bitset = bitset ; restart -> futex . flags = FLAGS_HAS_TIMEOUT ; if ( fshared ) restart -> futex . flags |= FLAGS_SHARED ; if ( clockrt ) restart -> futex . flags |= FLAGS_CLOCKRT ; ret = - ERESTART_RESTARTBLOCK ; <S2SV_StartBug> out_put_key : <S2SV_EndBug> put_futex_key ( fshared , & q . key ) ; out : if ( to ) { hrtimer_cancel ( & to -> timer ) ; destroy_hrtimer_on_stack ( & to -> timer ) ; } return ret ; }\n",
      "fixed_code": "<S2SV_ModStart> ) ) goto out <S2SV_ModEnd> ; ret = <S2SV_ModStart> task ) goto out <S2SV_ModEnd> ; if ( <S2SV_ModStart> current ) ) <S2SV_ModEnd> goto retry ; <S2SV_ModStart> goto retry ; <S2SV_ModEnd> ret = - <S2SV_ModStart> abs_time ) goto out <S2SV_ModEnd> ; restart = <S2SV_ModStart> - ERESTART_RESTARTBLOCK ; <S2SV_ModEnd> out : if\n",
      "source_code_length": 1873,
      "target_code_length": 337,
      "vulnerability_patterns": {
        "null_pointer": 20,
        "total": 20
      },
      "total_patterns": 20,
      "original_address": "https://github.com/torvalds/linux/commit/7ada876a8703f23befbb20a7465a702ee39b1704",
      "discovery_time": "2014-09-28T19:55Z",
      "project_commit_id": "torvalds@linux/7ada876a8703f23befbb20a7465a702ee39b1704",
      "extraction_time": "2025-08-31T15:41:49.190238",
      "label": 1,
      "vulnerability_type": "buffer_overflow",
      "difficulty_level": "advanced",
      "risk_factors": [
        "system_crash",
        "memory_corruption",
        "arbitrary_code_execution"
      ],
      "attack_vectors": [
        "memory_manipulation",
        "malicious_input",
        "code_analysis",
        "buffer_overflow",
        "reverse_engineering",
        "fuzzing"
      ],
      "mitigation_strategies": [
        "safe_string_functions",
        "dynamic_analysis",
        "code_review",
        "static_analysis",
        "memory_safety_checks",
        "input_validation",
        "fuzzing",
        "bounds_checking",
        "secure_coding_practices"
      ],
      "code_differences": {
        "has_differences": true,
        "source_lines": 2,
        "target_lines": 2,
        "character_differences": 1536,
        "similarity_percentage": 18.181818181818183
      },
      "vulnerability_location": {
        "vulnerability_present": true,
        "fix_applied": true,
        "code_changed": true,
        "estimated_lines_changed": 0
      }
    },
    {
      "cve_id": "CVE-2018-8788",
      "cwe_id": "CWE-787",
      "cwe_name": "Out-of-bounds Write",
      "project": "FreeRDP",
      "severity": "critical",
      "weaponization_score": 7.0,
      "is_critical": true,
      "is_weaponizable": true,
      "is_high_priority_project": false,
      "vulnerable_code": "CWE-787 <S2SV_StartBug> static void nsc_rle_decompress_data ( NSC_CONTEXT * context ) <S2SV_EndBug> { UINT16 i ; BYTE * rle ; UINT32 planeSize ; UINT32 originalSize ; <S2SV_StartBug> rle = context -> Planes ; <S2SV_EndBug> for ( i = 0 ; i < 4 ; i ++ ) { originalSize = context -> OrgByteCount [ i ] ; planeSize = context -> PlaneByteCount [ i ] ; if ( planeSize == 0 ) <S2SV_StartBug> FillMemory ( context -> priv -> PlaneBuffers [ i ] , originalSize , 0xFF ) ; <S2SV_EndBug> <S2SV_StartBug> else if ( planeSize < originalSize ) <S2SV_EndBug> <S2SV_StartBug> nsc_rle_decode ( rle , context -> priv -> PlaneBuffers [ i ] , originalSize ) ; <S2SV_EndBug> else CopyMemory ( context -> priv -> PlaneBuffers [ i ] , rle , originalSize ) ; <S2SV_StartBug> rle += planeSize ; <S2SV_EndBug> } <S2SV_StartBug> } <S2SV_EndBug>\n",
      "fixed_code": "<S2SV_ModStart> <S2SV_null> <S2SV_null> static BOOL <S2SV_ModEnd> nsc_rle_decompress_data ( NSC_CONTEXT <S2SV_ModStart> UINT32 originalSize ; if ( ! context ) return FALSE ; <S2SV_ModStart> == 0 ) { if ( context -> priv -> PlaneBuffersLength < originalSize ) return FALSE ; <S2SV_ModStart> 0xFF ) ; } <S2SV_ModStart> < originalSize ) { if ( ! <S2SV_ModStart> i ] , context -> priv -> PlaneBuffersLength , originalSize ) ) return FALSE ; } else { if ( context -> priv -> PlaneBuffersLength < originalSize ) return FALSE ; <S2SV_ModEnd> CopyMemory ( context <S2SV_ModStart> originalSize ) ; } <S2SV_ModStart> planeSize ; } return TRUE ;\n",
      "source_code_length": 817,
      "target_code_length": 635,
      "vulnerability_patterns": {
        "integer_overflow": 10,
        "null_pointer": 26,
        "total": 36
      },
      "total_patterns": 36,
      "original_address": "https://github.com/FreeRDP/FreeRDP/commit/d1112c279bd1a327e8e4d0b5f371458bf2579659",
      "discovery_time": "2018-11-29T18:29Z",
      "project_commit_id": "FreeRDP@FreeRDP/d1112c279bd1a327e8e4d0b5f371458bf2579659",
      "extraction_time": "2025-08-31T15:41:49.190268",
      "label": 1,
      "vulnerability_type": "out-of-bounds_write",
      "difficulty_level": "advanced",
      "risk_factors": [
        "system_crash",
        "memory_corruption",
        "arbitrary_code_execution"
      ],
      "attack_vectors": [
        "memory_manipulation",
        "malicious_input",
        "code_analysis",
        "buffer_overflow",
        "reverse_engineering",
        "fuzzing"
      ],
      "mitigation_strategies": [
        "safe_string_functions",
        "dynamic_analysis",
        "code_review",
        "static_analysis",
        "memory_safety_checks",
        "input_validation",
        "fuzzing",
        "bounds_checking",
        "secure_coding_practices"
      ],
      "code_differences": {
        "has_differences": true,
        "source_lines": 2,
        "target_lines": 2,
        "character_differences": 182,
        "similarity_percentage": 45.28301886792453
      },
      "vulnerability_location": {
        "vulnerability_present": true,
        "fix_applied": true,
        "code_changed": true,
        "estimated_lines_changed": 0
      }
    },
    {
      "cve_id": "CVE-2016-1621",
      "cwe_id": "CWE-119",
      "cwe_name": "Buffer Overflow",
      "project": "external",
      "severity": "critical",
      "weaponization_score": 7.0,
      "is_critical": true,
      "is_weaponizable": true,
      "is_high_priority_project": false,
      "vulnerable_code": "CWE-119 int main ( int argc , char * * argv ) { int frame_cnt = 0 ; FILE * outfile = NULL ; vpx_codec_ctx_t codec ; const VpxInterface * decoder = NULL ; VpxVideoReader * reader = NULL ; const VpxVideoInfo * info = NULL ; int n = 0 ; int m = 0 ; int is_range = 0 ; char * nptr = NULL ; exec_name = argv [ 0 ] ; if ( argc != 4 ) die ( \"Invalid<S2SV_blank>number<S2SV_blank>of<S2SV_blank>arguments.\" ) ; reader = vpx_video_reader_open ( argv [ 1 ] ) ; if ( ! reader ) die ( \"Failed<S2SV_blank>to<S2SV_blank>open<S2SV_blank>%s<S2SV_blank>for<S2SV_blank>reading.\" , argv [ 1 ] ) ; if ( ! ( outfile = fopen ( argv [ 2 ] , \"wb\" ) ) ) die ( \"Failed<S2SV_blank>to<S2SV_blank>open<S2SV_blank>%s<S2SV_blank>for<S2SV_blank>writing.\" , argv [ 2 ] ) ; n = strtol ( argv [ 3 ] , & nptr , 0 ) ; m = strtol ( nptr + 1 , NULL , 0 ) ; is_range = ( * nptr == '-' ) ; if ( ! n || ! m || ( * nptr != '-' && * nptr != '/' ) ) die ( \"Couldn\\'t<S2SV_blank>parse<S2SV_blank>pattern<S2SV_blank>%s.\\\\n\" , argv [ 3 ] ) ; info = vpx_video_reader_get_info ( reader ) ; decoder = get_vpx_decoder_by_fourcc ( info -> codec_fourcc ) ; if ( ! decoder ) die ( \"Unknown<S2SV_blank>input<S2SV_blank>codec.\" ) ; <S2SV_StartBug> printf ( \"Using<S2SV_blank>%s\\\\n\" , vpx_codec_iface_name ( decoder -> interface ( ) ) ) ; <S2SV_EndBug> <S2SV_StartBug> if ( vpx_codec_dec_init ( & codec , decoder -> interface ( ) , NULL , 0 ) ) <S2SV_EndBug> die_codec ( & codec , \"Failed<S2SV_blank>to<S2SV_blank>initialize<S2SV_blank>decoder.\" ) ; while ( vpx_video_reader_read_frame ( reader ) ) { vpx_codec_iter_t iter = NULL ; vpx_image_t * img = NULL ; size_t frame_size = 0 ; int skip ; const unsigned char * frame = vpx_video_reader_get_frame ( reader , & frame_size ) ; if ( vpx_codec_decode ( & codec , frame , ( unsigned int ) frame_size , NULL , 0 ) ) die_codec ( & codec , \"Failed<S2SV_blank>to<S2SV_blank>decode<S2SV_blank>frame.\" ) ; ++ frame_cnt ; skip = ( is_range && frame_cnt >= n && frame_cnt <= m ) || ( ! is_range && m - ( frame_cnt - 1 ) % m <= n ) ; if ( ! skip ) { putc ( '.' , stdout ) ; while ( ( img = vpx_codec_get_frame ( & codec , & iter ) ) != NULL ) vpx_img_write ( img , outfile ) ; } else { putc ( 'X' , stdout ) ; } fflush ( stdout ) ; } printf ( \"Processed<S2SV_blank>%d<S2SV_blank>frames.\\\\n\" , frame_cnt ) ; if ( vpx_codec_destroy ( & codec ) ) die_codec ( & codec , \"Failed<S2SV_blank>to<S2SV_blank>destroy<S2SV_blank>codec.\" ) ; printf ( \"Play:<S2SV_blank>ffplay<S2SV_blank>-f<S2SV_blank>rawvideo<S2SV_blank>-pix_fmt<S2SV_blank>yuv420p<S2SV_blank>-s<S2SV_blank>%dx%d<S2SV_blank>%s\\\\n\" , info -> frame_width , info -> frame_height , argv [ 2 ] ) ; vpx_video_reader_close ( reader ) ; fclose ( outfile ) ; return EXIT_SUCCESS ; }\n",
      "fixed_code": "<S2SV_ModStart> ( decoder -> codec_interface <S2SV_ModEnd> ( ) ) <S2SV_ModStart> , decoder -> codec_interface <S2SV_ModEnd> ( ) ,\n",
      "source_code_length": 2710,
      "target_code_length": 130,
      "vulnerability_patterns": {
        "integer_overflow": 4,
        "null_pointer": 42,
        "total": 46
      },
      "total_patterns": 46,
      "original_address": "https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426",
      "discovery_time": "2016-03-12T21:59Z",
      "project_commit_id": "external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426",
      "extraction_time": "2025-08-31T15:41:49.190283",
      "label": 1,
      "vulnerability_type": "buffer_overflow",
      "difficulty_level": "advanced",
      "risk_factors": [
        "system_crash",
        "memory_corruption",
        "arbitrary_code_execution"
      ],
      "attack_vectors": [
        "memory_manipulation",
        "malicious_input",
        "code_analysis",
        "buffer_overflow",
        "reverse_engineering",
        "fuzzing"
      ],
      "mitigation_strategies": [
        "safe_string_functions",
        "dynamic_analysis",
        "code_review",
        "static_analysis",
        "memory_safety_checks",
        "input_validation",
        "fuzzing",
        "bounds_checking",
        "secure_coding_practices"
      ],
      "code_differences": {
        "has_differences": true,
        "source_lines": 2,
        "target_lines": 2,
        "character_differences": 2580,
        "similarity_percentage": 4.464285714285714
      },
      "vulnerability_location": {
        "vulnerability_present": true,
        "fix_applied": true,
        "code_changed": true,
        "estimated_lines_changed": 0
      }
    },
    {
      "cve_id": "CVE-2016-0840",
      "cwe_id": "CWE-119",
      "cwe_name": "Buffer Overflow",
      "project": "external",
      "severity": "critical",
      "weaponization_score": 7.0,
      "is_critical": true,
      "is_weaponizable": true,
      "is_high_priority_project": false,
      "vulnerable_code": "CWE-119 void ih264d_rest_of_residual_cav_chroma_dc_block ( UWORD32 u4_total_coeff_trail_one , dec_bit_stream_t * ps_bitstrm ) { UWORD32 u4_total_zeroes ; WORD16 i ; UWORD32 * pu4_bitstrm_buf = ps_bitstrm -> pu4_buffer ; UWORD32 u4_bitstream_offset = ps_bitstrm -> u4_ofst ; UWORD32 u4_trailing_ones = u4_total_coeff_trail_one & 0xFFFF ; UWORD32 u4_total_coeff = u4_total_coeff_trail_one >> 16 ; <S2SV_StartBug> WORD16 i2_level_arr [ 4 ] ; <S2SV_EndBug> tu_sblk4x4_coeff_data_t * ps_tu_4x4 ; WORD16 * pi2_coeff_data ; dec_struct_t * ps_dec = ( dec_struct_t * ) ps_bitstrm -> pv_codec_handle ; ps_tu_4x4 = ( tu_sblk4x4_coeff_data_t * ) ps_dec -> pv_parse_tu_coeff_data ; ps_tu_4x4 -> u2_sig_coeff_map = 0 ; pi2_coeff_data = & ps_tu_4x4 -> ai2_level [ 0 ] ; i = u4_total_coeff - 1 ; if ( u4_trailing_ones ) { UWORD32 u4_signs , u4_cnt = u4_trailing_ones ; WORD16 ( * ppi2_trlone_lkup ) [ 3 ] = ( WORD16 ( * ) [ 3 ] ) gai2_ih264d_trailing_one_level ; WORD16 * pi2_trlone_lkup ; GETBITS ( u4_signs , u4_bitstream_offset , pu4_bitstrm_buf , u4_cnt ) ; pi2_trlone_lkup = ppi2_trlone_lkup [ ( 1 << u4_cnt ) - 2 + u4_signs ] ; while ( u4_cnt -- ) i2_level_arr [ i -- ] = * pi2_trlone_lkup ++ ; } if ( i >= 0 ) { UWORD32 u4_lev_suffix , u4_suffix_len , u4_lev_suffix_size ; UWORD16 u2_lev_code , u2_abs_value ; UWORD32 u4_lev_prefix ; FIND_ONE_IN_STREAM_32 ( u4_lev_prefix , u4_bitstream_offset , pu4_bitstrm_buf ) ; u2_lev_code = MIN ( 15 , u4_lev_prefix ) ; u2_lev_code += ( 3 == u4_trailing_ones ) ? 0 : ( 2 ) ; if ( 14 == u4_lev_prefix ) u4_lev_suffix_size = 4 ; else if ( 15 <= u4_lev_prefix ) { u2_lev_code += 15 ; u4_lev_suffix_size = u4_lev_prefix - 3 ; } else u4_lev_suffix_size = 0 ; if ( 16 <= u4_lev_prefix ) { u2_lev_code += ( ( 1 << ( u4_lev_prefix - 3 ) ) - 4096 ) ; } if ( u4_lev_suffix_size ) { GETBITS ( u4_lev_suffix , u4_bitstream_offset , pu4_bitstrm_buf , u4_lev_suffix_size ) ; u2_lev_code += u4_lev_suffix ; } u2_abs_value = ( u2_lev_code + 2 ) >> 1 ; i2_level_arr [ i -- ] = ( u2_lev_code & 1 ) ? - u2_abs_value : u2_abs_value ; u4_suffix_len = ( u2_abs_value > 3 ) ? 2 : 1 ; while ( i >= 0 ) { FIND_ONE_IN_STREAM_32 ( u4_lev_prefix , u4_bitstream_offset , pu4_bitstrm_buf ) ; u4_lev_suffix_size = ( 15 <= u4_lev_prefix ) ? ( u4_lev_prefix - 3 ) : u4_suffix_len ; GETBITS ( u4_lev_suffix , u4_bitstream_offset , pu4_bitstrm_buf , u4_lev_suffix_size ) ; u2_lev_code = ( MIN ( u4_lev_prefix , 15 ) << u4_suffix_len ) + u4_lev_suffix ; if ( 16 <= u4_lev_prefix ) { u2_lev_code += ( ( 1 << ( u4_lev_prefix - 3 ) ) - 4096 ) ; } u2_abs_value = ( u2_lev_code + 2 ) >> 1 ; i2_level_arr [ i -- ] = ( u2_lev_code & 1 ) ? - u2_abs_value : u2_abs_value ; u4_suffix_len += ( u2_abs_value > ( 3 << ( u4_suffix_len - 1 ) ) ) ; } } if ( u4_total_coeff < 4 ) { UWORD32 u4_max_ldz = ( 4 - u4_total_coeff ) ; FIND_ONE_IN_STREAM_LEN ( u4_total_zeroes , u4_bitstream_offset , pu4_bitstrm_buf , u4_max_ldz ) ; } else u4_total_zeroes = 0 ; { const UWORD8 * pu1_table_runbefore ; UWORD32 u4_run ; UWORD32 u4_scan_pos = ( u4_total_coeff + u4_total_zeroes - 1 ) ; UWORD32 u4_zeroes_left = u4_total_zeroes ; i = u4_total_coeff - 1 ; pu1_table_runbefore = ( UWORD8 * ) gau1_ih264d_table_run_before ; while ( u4_zeroes_left && i ) { UWORD32 u4_code ; NEXTBITS ( u4_code , u4_bitstream_offset , pu4_bitstrm_buf , 3 ) ; u4_code = pu1_table_runbefore [ u4_code + ( u4_zeroes_left << 3 ) ] ; u4_run = u4_code >> 2 ; FLUSHBITS ( u4_bitstream_offset , ( u4_code & 0x03 ) ) ; SET_BIT ( ps_tu_4x4 -> u2_sig_coeff_map , u4_scan_pos ) ; * pi2_coeff_data ++ = i2_level_arr [ i -- ] ; u4_zeroes_left -= u4_run ; u4_scan_pos -= ( u4_run + 1 ) ; } while ( i >= 0 ) { SET_BIT ( ps_tu_4x4 -> u2_sig_coeff_map , u4_scan_pos ) ; * pi2_coeff_data ++ = i2_level_arr [ i -- ] ; u4_scan_pos -- ; } } { WORD32 offset ; offset = ( UWORD8 * ) pi2_coeff_data - ( UWORD8 * ) ps_tu_4x4 ; offset = ALIGN4 ( offset ) ; ps_dec -> pv_parse_tu_coeff_data = ( void * ) ( ( UWORD8 * ) ps_dec -> pv_parse_tu_coeff_data + offset ) ; } ps_bitstrm -> u4_ofst = u4_bitstream_offset ; }\n",
      "fixed_code": "<S2SV_ModStart> 16 ; WORD16 ai2_level_arr [ 7 ] ; WORD16 * i2_level_arr = & ai2_level_arr [ 3 <S2SV_ModEnd> ] ; tu_sblk4x4_coeff_data_t\n",
      "source_code_length": 4032,
      "target_code_length": 136,
      "vulnerability_patterns": {
        "integer_overflow": 18,
        "null_pointer": 11,
        "total": 29
      },
      "total_patterns": 29,
      "original_address": "https://android.googlesource.com/platform/external/libavc/+/c57fc3703ae2e0d41b1f6580c50015937f2d23c1",
      "discovery_time": "2016-04-18T00:59Z",
      "project_commit_id": "external@libavc/c57fc3703ae2e0d41b1f6580c50015937f2d23c1",
      "extraction_time": "2025-08-31T15:41:49.190306",
      "label": 1,
      "vulnerability_type": "buffer_overflow",
      "difficulty_level": "advanced",
      "risk_factors": [
        "system_crash",
        "memory_corruption",
        "arbitrary_code_execution"
      ],
      "attack_vectors": [
        "memory_manipulation",
        "malicious_input",
        "code_analysis",
        "buffer_overflow",
        "reverse_engineering",
        "fuzzing"
      ],
      "mitigation_strategies": [
        "safe_string_functions",
        "dynamic_analysis",
        "code_review",
        "static_analysis",
        "memory_safety_checks",
        "input_validation",
        "fuzzing",
        "bounds_checking",
        "secure_coding_practices"
      ],
      "code_differences": {
        "has_differences": true,
        "source_lines": 2,
        "target_lines": 2,
        "character_differences": 3896,
        "similarity_percentage": 10.476190476190476
      },
      "vulnerability_location": {
        "vulnerability_present": true,
        "fix_applied": true,
        "code_changed": true,
        "estimated_lines_changed": 0
      }
    },
    {
      "cve_id": "CVE-2018-11506",
      "cwe_id": "CWE-119",
      "cwe_name": "Buffer Overflow",
      "project": "torvalds",
      "severity": "critical",
      "weaponization_score": 7.0,
      "is_critical": true,
      "is_weaponizable": true,
      "is_high_priority_project": false,
      "vulnerable_code": "CWE-119 int sr_do_ioctl ( Scsi_CD * cd , struct packet_command * cgc ) { struct scsi_device * SDev ; struct scsi_sense_hdr sshdr ; int result , err = 0 , retries = 0 ; <S2SV_StartBug> SDev = cd -> device ; <S2SV_EndBug> retry : if ( ! scsi_block_when_processing_errors ( SDev ) ) { err = - ENODEV ; goto out ; } result = scsi_execute ( SDev , cgc -> cmd , cgc -> data_direction , cgc -> buffer , cgc -> buflen , <S2SV_StartBug> ( unsigned char * ) cgc -> sense , & sshdr , <S2SV_EndBug> cgc -> timeout , IOCTL_RETRIES , 0 , 0 , NULL ) ; if ( driver_byte ( result ) != 0 ) { switch ( sshdr . sense_key ) { case UNIT_ATTENTION : SDev -> changed = 1 ; if ( ! cgc -> quiet ) sr_printk ( KERN_INFO , cd , \"disc<S2SV_blank>change<S2SV_blank>detected.\\\\n\" ) ; if ( retries ++ < 10 ) goto retry ; err = - ENOMEDIUM ; break ; case NOT_READY : if ( sshdr . asc == 0x04 && sshdr . ascq == 0x01 ) { if ( ! cgc -> quiet ) sr_printk ( KERN_INFO , cd , \"CDROM<S2SV_blank>not<S2SV_blank>ready<S2SV_blank>yet.\\\\n\" ) ; if ( retries ++ < 10 ) { ssleep ( 2 ) ; goto retry ; } else { err = - ENOMEDIUM ; break ; } } if ( ! cgc -> quiet ) sr_printk ( KERN_INFO , cd , \"CDROM<S2SV_blank>not<S2SV_blank>ready.<S2SV_blank><S2SV_blank>Make<S2SV_blank>sure<S2SV_blank>there<S2SV_blank>\" \"is<S2SV_blank>a<S2SV_blank>disc<S2SV_blank>in<S2SV_blank>the<S2SV_blank>drive.\\\\n\" ) ; err = - ENOMEDIUM ; break ; case ILLEGAL_REQUEST : err = - EIO ; if ( sshdr . asc == 0x20 && sshdr . ascq == 0x00 ) err = - EDRIVE_CANT_DO_THIS ; break ; default : err = - EIO ; } } out : cgc -> stat = err ; return err ; }\n",
      "fixed_code": "<S2SV_ModStart> = 0 ; unsigned char sense_buffer [ SCSI_SENSE_BUFFERSIZE ] , * senseptr = NULL ; <S2SV_ModStart> cd -> device ; if ( cgc -> sense ) senseptr = sense_buffer <S2SV_ModStart> -> buflen , senseptr , & sshdr , cgc -> timeout , IOCTL_RETRIES , 0 , 0 , NULL ) ; if ( cgc -> sense ) memcpy ( cgc -> sense , sense_buffer , sizeof ( * <S2SV_ModEnd> cgc -> sense <S2SV_ModStart> cgc -> sense ) <S2SV_ModEnd> ) ; if\n",
      "source_code_length": 1571,
      "target_code_length": 420,
      "vulnerability_patterns": {
        "integer_overflow": 2,
        "null_pointer": 12,
        "total": 14
      },
      "total_patterns": 14,
      "original_address": "https://github.com/torvalds/linux/commit/f7068114d45ec55996b9040e98111afa56e010fe",
      "discovery_time": "2018-05-28T04:29Z",
      "project_commit_id": "torvalds@linux/f7068114d45ec55996b9040e98111afa56e010fe",
      "extraction_time": "2025-08-31T15:41:49.190349",
      "label": 1,
      "vulnerability_type": "buffer_overflow",
      "difficulty_level": "advanced",
      "risk_factors": [
        "system_crash",
        "memory_corruption",
        "arbitrary_code_execution"
      ],
      "attack_vectors": [
        "memory_manipulation",
        "malicious_input",
        "code_analysis",
        "buffer_overflow",
        "reverse_engineering",
        "fuzzing"
      ],
      "mitigation_strategies": [
        "safe_string_functions",
        "dynamic_analysis",
        "code_review",
        "static_analysis",
        "memory_safety_checks",
        "input_validation",
        "fuzzing",
        "bounds_checking",
        "secure_coding_practices"
      ],
      "code_differences": {
        "has_differences": true,
        "source_lines": 2,
        "target_lines": 2,
        "character_differences": 1151,
        "similarity_percentage": 21.649484536082475
      },
      "vulnerability_location": {
        "vulnerability_present": true,
        "fix_applied": true,
        "code_changed": true,
        "estimated_lines_changed": 0
      }
    },
    {
      "cve_id": "CVE-2016-4303",
      "cwe_id": "CWE-119",
      "cwe_name": "Buffer Overflow",
      "project": "esnet",
      "severity": "critical",
      "weaponization_score": 7.0,
      "is_critical": true,
      "is_weaponizable": true,
      "is_high_priority_project": false,
      "vulnerable_code": "CWE-119 cJSON * cJSON_CreateArray ( void ) { cJSON * item = cJSON_New_Item ( ) ; if ( item ) item -> type = cJSON_Array ; return item ; }\n",
      "fixed_code": "\n",
      "source_code_length": 138,
      "target_code_length": 1,
      "vulnerability_patterns": {
        "integer_overflow": 1,
        "null_pointer": 17,
        "total": 18
      },
      "total_patterns": 18,
      "original_address": "https://github.com/esnet/iperf/commit/91f2fa59e8ed80dfbf400add0164ee0e508e412a",
      "discovery_time": "2016-09-26T14:59Z",
      "project_commit_id": "esnet@iperf/91f2fa59e8ed80dfbf400add0164ee0e508e412a",
      "extraction_time": "2025-08-31T15:41:49.190378",
      "label": 1,
      "vulnerability_type": "buffer_overflow",
      "difficulty_level": "advanced",
      "risk_factors": [
        "system_crash",
        "memory_corruption",
        "arbitrary_code_execution"
      ],
      "attack_vectors": [
        "memory_manipulation",
        "malicious_input",
        "code_analysis",
        "buffer_overflow",
        "reverse_engineering",
        "fuzzing"
      ],
      "mitigation_strategies": [
        "safe_string_functions",
        "dynamic_analysis",
        "code_review",
        "static_analysis",
        "memory_safety_checks",
        "input_validation",
        "fuzzing",
        "bounds_checking",
        "secure_coding_practices"
      ],
      "code_differences": {
        "has_differences": true,
        "source_lines": 2,
        "target_lines": 2,
        "character_differences": 137,
        "similarity_percentage": 0.0
      },
      "vulnerability_location": {
        "vulnerability_present": true,
        "fix_applied": true,
        "code_changed": true,
        "estimated_lines_changed": 0
      }
    },
    {
      "cve_id": "CVE-2016-10012",
      "cwe_id": "CWE-119",
      "cwe_name": "Buffer Overflow",
      "project": "openbsd",
      "severity": "critical",
      "weaponization_score": 7.0,
      "is_critical": true,
      "is_weaponizable": true,
      "is_high_priority_project": false,
      "vulnerable_code": "CWE-119 static void do_ssh2_kex ( void ) { char * myproposal [ PROPOSAL_MAX ] = { KEX_SERVER } ; struct kex * kex ; int r ; myproposal [ PROPOSAL_KEX_ALGS ] = compat_kex_proposal ( options . kex_algorithms ) ; myproposal [ PROPOSAL_ENC_ALGS_CTOS ] = compat_cipher_proposal ( options . ciphers ) ; myproposal [ PROPOSAL_ENC_ALGS_STOC ] = compat_cipher_proposal ( options . ciphers ) ; myproposal [ PROPOSAL_MAC_ALGS_CTOS ] = myproposal [ PROPOSAL_MAC_ALGS_STOC ] = options . macs ; if ( options . compression == COMP_NONE ) { myproposal [ PROPOSAL_COMP_ALGS_CTOS ] = myproposal [ PROPOSAL_COMP_ALGS_STOC ] = \"none\" ; <S2SV_StartBug> } else if ( options . compression == COMP_DELAYED ) { <S2SV_EndBug> myproposal [ PROPOSAL_COMP_ALGS_CTOS ] = myproposal [ PROPOSAL_COMP_ALGS_STOC ] = \"none,zlib@openssh.com\" ; } if ( options . rekey_limit || options . rekey_interval ) packet_set_rekey_limits ( options . rekey_limit , ( time_t ) options . rekey_interval ) ; myproposal [ PROPOSAL_SERVER_HOST_KEY_ALGS ] = compat_pkalg_proposal ( list_hostkey_types ( ) ) ; if ( ( r = kex_setup ( active_state , myproposal ) ) != 0 ) fatal ( \"kex_setup:<S2SV_blank>%s\" , ssh_err ( r ) ) ; kex = active_state -> kex ; # ifdef WITH_OPENSSL kex -> kex [ KEX_DH_GRP1_SHA1 ] = kexdh_server ; kex -> kex [ KEX_DH_GRP14_SHA1 ] = kexdh_server ; kex -> kex [ KEX_DH_GRP14_SHA256 ] = kexdh_server ; kex -> kex [ KEX_DH_GRP16_SHA512 ] = kexdh_server ; kex -> kex [ KEX_DH_GRP18_SHA512 ] = kexdh_server ; kex -> kex [ KEX_DH_GEX_SHA1 ] = kexgex_server ; kex -> kex [ KEX_DH_GEX_SHA256 ] = kexgex_server ; kex -> kex [ KEX_ECDH_SHA2 ] = kexecdh_server ; # endif kex -> kex [ KEX_C25519_SHA256 ] = kexc25519_server ; kex -> server = 1 ; kex -> client_version_string = client_version_string ; kex -> server_version_string = server_version_string ; kex -> load_host_public_key = & get_hostkey_public_by_type ; kex -> load_host_private_key = & get_hostkey_private_by_type ; kex -> host_key_index = & get_hostkey_index ; kex -> sign = sshd_hostkey_sign ; dispatch_run ( DISPATCH_BLOCK , & kex -> done , active_state ) ; session_id2 = kex -> session_id ; session_id2_len = kex -> session_id_len ; # ifdef DEBUG_KEXDH packet_start ( SSH2_MSG_IGNORE ) ; packet_put_cstring ( \"markus\" ) ; packet_send ( ) ; packet_write_wait ( ) ; # endif debug ( \"KEX<S2SV_blank>done\" ) ; }\n",
      "fixed_code": "<S2SV_ModStart> \"none\" ; } <S2SV_ModEnd> if ( options\n",
      "source_code_length": 2334,
      "target_code_length": 54,
      "vulnerability_patterns": {
        "null_pointer": 20,
        "total": 20
      },
      "total_patterns": 20,
      "original_address": "https://github.com/openbsd/src/commit/3095060f479b86288e31c79ecbc5131a66bcd2f9",
      "discovery_time": "2017-01-05T02:59Z",
      "project_commit_id": "openbsd@src/3095060f479b86288e31c79ecbc5131a66bcd2f9",
      "extraction_time": "2025-08-31T15:41:49.190392",
      "label": 1,
      "vulnerability_type": "buffer_overflow",
      "difficulty_level": "advanced",
      "risk_factors": [
        "system_crash",
        "memory_corruption",
        "arbitrary_code_execution"
      ],
      "attack_vectors": [
        "memory_manipulation",
        "malicious_input",
        "code_analysis",
        "buffer_overflow",
        "reverse_engineering",
        "fuzzing"
      ],
      "mitigation_strategies": [
        "safe_string_functions",
        "dynamic_analysis",
        "code_review",
        "static_analysis",
        "memory_safety_checks",
        "input_validation",
        "fuzzing",
        "bounds_checking",
        "secure_coding_practices"
      ],
      "code_differences": {
        "has_differences": true,
        "source_lines": 2,
        "target_lines": 2,
        "character_differences": 2280,
        "similarity_percentage": 5.454545454545454
      },
      "vulnerability_location": {
        "vulnerability_present": true,
        "fix_applied": true,
        "code_changed": true,
        "estimated_lines_changed": 0
      }
    },
    {
      "cve_id": "CVE-2016-1621",
      "cwe_id": "CWE-119",
      "cwe_name": "Buffer Overflow",
      "project": "external",
      "severity": "critical",
      "weaponization_score": 7.0,
      "is_critical": true,
      "is_weaponizable": true,
      "is_high_priority_project": false,
      "vulnerable_code": "CWE-119 int main ( int argc , char * * argv ) { int frame_cnt = 0 ; FILE * outfile = NULL ; vpx_codec_ctx_t codec ; const VpxInterface * decoder = NULL ; VpxVideoReader * reader = NULL ; const VpxVideoInfo * info = NULL ; int n = 0 ; int m = 0 ; int is_range = 0 ; char * nptr = NULL ; exec_name = argv [ 0 ] ; if ( argc != 4 ) die ( \"Invalid<S2SV_blank>number<S2SV_blank>of<S2SV_blank>arguments.\" ) ; reader = vpx_video_reader_open ( argv [ 1 ] ) ; if ( ! reader ) die ( \"Failed<S2SV_blank>to<S2SV_blank>open<S2SV_blank>%s<S2SV_blank>for<S2SV_blank>reading.\" , argv [ 1 ] ) ; if ( ! ( outfile = fopen ( argv [ 2 ] , \"wb\" ) ) ) die ( \"Failed<S2SV_blank>to<S2SV_blank>open<S2SV_blank>%s<S2SV_blank>for<S2SV_blank>writing.\" , argv [ 2 ] ) ; n = strtol ( argv [ 3 ] , & nptr , 0 ) ; m = strtol ( nptr + 1 , NULL , 0 ) ; is_range = ( * nptr == '-' ) ; if ( ! n || ! m || ( * nptr != '-' && * nptr != '/' ) ) die ( \"Couldn\\'t<S2SV_blank>parse<S2SV_blank>pattern<S2SV_blank>%s.\\\\n\" , argv [ 3 ] ) ; info = vpx_video_reader_get_info ( reader ) ; decoder = get_vpx_decoder_by_fourcc ( info -> codec_fourcc ) ; if ( ! decoder ) die ( \"Unknown<S2SV_blank>input<S2SV_blank>codec.\" ) ; <S2SV_StartBug> printf ( \"Using<S2SV_blank>%s\\\\n\" , vpx_codec_iface_name ( decoder -> interface ( ) ) ) ; <S2SV_EndBug> <S2SV_StartBug> if ( vpx_codec_dec_init ( & codec , decoder -> interface ( ) , NULL , 0 ) ) <S2SV_EndBug> die_codec ( & codec , \"Failed<S2SV_blank>to<S2SV_blank>initialize<S2SV_blank>decoder.\" ) ; while ( vpx_video_reader_read_frame ( reader ) ) { vpx_codec_iter_t iter = NULL ; vpx_image_t * img = NULL ; size_t frame_size = 0 ; int skip ; const unsigned char * frame = vpx_video_reader_get_frame ( reader , & frame_size ) ; if ( vpx_codec_decode ( & codec , frame , ( unsigned int ) frame_size , NULL , 0 ) ) die_codec ( & codec , \"Failed<S2SV_blank>to<S2SV_blank>decode<S2SV_blank>frame.\" ) ; ++ frame_cnt ; skip = ( is_range && frame_cnt >= n && frame_cnt <= m ) || ( ! is_range && m - ( frame_cnt - 1 ) % m <= n ) ; if ( ! skip ) { putc ( '.' , stdout ) ; while ( ( img = vpx_codec_get_frame ( & codec , & iter ) ) != NULL ) vpx_img_write ( img , outfile ) ; } else { putc ( 'X' , stdout ) ; } fflush ( stdout ) ; } printf ( \"Processed<S2SV_blank>%d<S2SV_blank>frames.\\\\n\" , frame_cnt ) ; if ( vpx_codec_destroy ( & codec ) ) die_codec ( & codec , \"Failed<S2SV_blank>to<S2SV_blank>destroy<S2SV_blank>codec.\" ) ; printf ( \"Play:<S2SV_blank>ffplay<S2SV_blank>-f<S2SV_blank>rawvideo<S2SV_blank>-pix_fmt<S2SV_blank>yuv420p<S2SV_blank>-s<S2SV_blank>%dx%d<S2SV_blank>%s\\\\n\" , info -> frame_width , info -> frame_height , argv [ 2 ] ) ; vpx_video_reader_close ( reader ) ; fclose ( outfile ) ; return EXIT_SUCCESS ; }\n",
      "fixed_code": "<S2SV_ModStart> ( decoder -> codec_interface <S2SV_ModEnd> ( ) ) <S2SV_ModStart> , decoder -> codec_interface <S2SV_ModEnd> ( ) ,\n",
      "source_code_length": 2710,
      "target_code_length": 130,
      "vulnerability_patterns": {
        "null_pointer": 10,
        "total": 10
      },
      "total_patterns": 10,
      "original_address": "https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426",
      "discovery_time": "2016-03-12T21:59Z",
      "project_commit_id": "external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426",
      "extraction_time": "2025-08-31T15:41:49.190414",
      "label": 1,
      "vulnerability_type": "buffer_overflow",
      "difficulty_level": "advanced",
      "risk_factors": [
        "system_crash",
        "memory_corruption",
        "arbitrary_code_execution"
      ],
      "attack_vectors": [
        "memory_manipulation",
        "malicious_input",
        "code_analysis",
        "buffer_overflow",
        "reverse_engineering",
        "fuzzing"
      ],
      "mitigation_strategies": [
        "safe_string_functions",
        "dynamic_analysis",
        "code_review",
        "static_analysis",
        "memory_safety_checks",
        "input_validation",
        "fuzzing",
        "bounds_checking",
        "secure_coding_practices"
      ],
      "code_differences": {
        "has_differences": true,
        "source_lines": 2,
        "target_lines": 2,
        "character_differences": 2580,
        "similarity_percentage": 4.464285714285714
      },
      "vulnerability_location": {
        "vulnerability_present": true,
        "fix_applied": true,
        "code_changed": true,
        "estimated_lines_changed": 0
      }
    },
    {
      "cve_id": "CVE-2016-0816",
      "cwe_id": "CWE-119",
      "cwe_name": "Buffer Overflow",
      "project": "external",
      "severity": "critical",
      "weaponization_score": 7.0,
      "is_critical": true,
      "is_weaponizable": true,
      "is_high_priority_project": false,
      "vulnerable_code": "CWE-119 WORD32 ih264d_mark_err_slice_skip ( dec_struct_t * ps_dec , WORD32 num_mb_skip , UWORD8 u1_is_idr_slice , UWORD16 u2_frame_num , pocstruct_t * ps_cur_poc , WORD32 prev_slice_err ) { WORD32 i2_cur_mb_addr ; UWORD32 u1_num_mbs , u1_num_mbsNby2 ; UWORD32 u1_mb_idx = ps_dec -> u1_mb_idx ; UWORD32 i2_mb_skip_run ; UWORD32 u1_num_mbs_next , u1_end_of_row ; const UWORD32 i2_pic_wdin_mbs = ps_dec -> u2_frm_wd_in_mbs ; UWORD32 u1_slice_end ; UWORD32 u1_tfr_n_mb ; UWORD32 u1_decode_nmb ; dec_bit_stream_t * const ps_bitstrm = ps_dec -> ps_bitstrm ; dec_slice_params_t * ps_slice = ps_dec -> ps_cur_slice ; UWORD32 * pu4_bitstrm_buf = ps_bitstrm -> pu4_buffer ; UWORD32 * pu4_bitstrm_ofst = & ps_bitstrm -> u4_ofst ; deblk_mb_t * ps_cur_deblk_mb ; dec_mb_info_t * ps_cur_mb_info ; parse_pmbarams_t * ps_parse_mb_data ; UWORD32 u1_inter_mb_type ; UWORD32 u1_deblk_mb_type ; UWORD16 u2_total_mbs_coded ; UWORD32 u1_mbaff = ps_slice -> u1_mbaff_frame_flag ; parse_part_params_t * ps_part_info ; WORD32 ret ; if ( ps_dec -> ps_dec_err_status -> u1_err_flag & REJECT_CUR_PIC ) { ih264d_err_pic_dispbuf_mgr ( ps_dec ) ; return 0 ; } if ( prev_slice_err == 1 ) { ps_dec -> ps_cur_slice -> u2_frame_num = u2_frame_num ; if ( ! ps_dec -> u1_first_slice_in_stream ) { ih264d_end_of_pic ( ps_dec , u1_is_idr_slice , ps_dec -> ps_cur_slice -> u2_frame_num ) ; ps_dec -> s_cur_pic_poc . u2_frame_num = ps_dec -> ps_cur_slice -> u2_frame_num ; } { WORD32 i , j , poc = 0 ; ps_dec -> ps_cur_slice -> u2_first_mb_in_slice = 0 ; ps_dec -> pf_mvpred = ih264d_mvpred_nonmbaff ; ps_dec -> p_form_mb_part_info = ih264d_form_mb_part_info_bp ; ps_dec -> p_motion_compensate = ih264d_motion_compensate_bp ; if ( ps_dec -> ps_cur_pic != NULL ) poc = ps_dec -> ps_cur_pic -> i4_poc + 2 ; j = 0 ; for ( i = 0 ; i < MAX_NUM_PIC_PARAMS ; i ++ ) if ( ps_dec -> ps_pps [ i ] . u1_is_valid == TRUE ) j = i ; { ret = ih264d_start_of_pic ( ps_dec , poc , ps_cur_poc , ps_dec -> ps_cur_slice -> u2_frame_num , & ps_dec -> ps_pps [ j ] ) ; if ( ret != OK ) { return ret ; } } ps_dec -> ps_ref_pic_buf_lx [ 0 ] [ 0 ] -> u1_pic_buf_id = 0 ; ps_dec -> u4_output_present = 0 ; { ih264d_get_next_display_field ( ps_dec , ps_dec -> ps_out_buffer , & ( ps_dec -> s_disp_op ) ) ; if ( 0 != ps_dec -> s_disp_op . u4_error_code ) { ps_dec -> u4_fmt_conv_cur_row = ps_dec -> s_disp_frame_info . u4_y_ht ; } else ps_dec -> u4_output_present = 1 ; } if ( ps_dec -> u1_separate_parse == 1 ) { if ( ps_dec -> u4_dec_thread_created == 0 ) { ithread_create ( ps_dec -> pv_dec_thread_handle , NULL , ( void * ) ih264d_decode_picture_thread , ( void * ) ps_dec ) ; ps_dec -> u4_dec_thread_created = 1 ; } if ( ( ps_dec -> u4_num_cores == 3 ) && ( ( ps_dec -> u4_app_disable_deblk_frm == 0 ) || ps_dec -> i1_recon_in_thread3_flag ) && ( ps_dec -> u4_bs_deblk_thread_created == 0 ) ) { ps_dec -> u4_start_recon_deblk = 0 ; ithread_create ( ps_dec -> pv_bs_deblk_thread_handle , NULL , ( void * ) ih264d_recon_deblk_thread , ( void * ) ps_dec ) ; ps_dec -> u4_bs_deblk_thread_created = 1 ; } } } } else { dec_slice_struct_t * ps_parse_cur_slice ; ps_parse_cur_slice = ps_dec -> ps_dec_slice_buf + ps_dec -> u2_cur_slice_num ; if ( ps_dec -> u1_slice_header_done && ps_parse_cur_slice == ps_dec -> ps_parse_cur_slice ) { u1_num_mbs = ps_dec -> u4_num_mbs_cur_nmb ; if ( u1_num_mbs ) { ps_cur_mb_info = ps_dec -> ps_nmb_info + u1_num_mbs - 1 ; } else { if ( ps_dec -> u1_separate_parse ) { ps_cur_mb_info = ps_dec -> ps_nmb_info - 1 ; } else { ps_cur_mb_info = ps_dec -> ps_nmb_info + ps_dec -> u4_num_mbs_prev_nmb - 1 ; } } ps_dec -> u2_mby = ps_cur_mb_info -> u2_mby ; ps_dec -> u2_mbx = ps_cur_mb_info -> u2_mbx ; ps_dec -> u1_mb_ngbr_availablity = ps_cur_mb_info -> u1_mb_ngbr_availablity ; ps_dec -> pv_parse_tu_coeff_data = ps_dec -> pv_prev_mb_parse_tu_coeff_data ; ps_dec -> u2_cur_mb_addr -- ; ps_dec -> i4_submb_ofst -= SUB_BLK_SIZE ; if ( u1_num_mbs ) { if ( ps_dec -> u1_pr_sl_type == P_SLICE || ps_dec -> u1_pr_sl_type == B_SLICE ) { ps_dec -> pf_mvpred_ref_tfr_nby2mb ( ps_dec , u1_mb_idx , u1_num_mbs ) ; ps_dec -> ps_part = ps_dec -> ps_parse_part_params ; } u1_num_mbs_next = i2_pic_wdin_mbs - ps_dec -> u2_mbx - 1 ; u1_end_of_row = ( ! u1_num_mbs_next ) && ( ! ( u1_mbaff && ( u1_num_mbs & 0x01 ) ) ) ; u1_slice_end = 1 ; u1_tfr_n_mb = 1 ; ps_cur_mb_info -> u1_end_of_slice = u1_slice_end ; if ( ps_dec -> u1_separate_parse ) { ih264d_parse_tfr_nmb ( ps_dec , u1_mb_idx , u1_num_mbs , u1_num_mbs_next , u1_tfr_n_mb , u1_end_of_row ) ; ps_dec -> ps_nmb_info += u1_num_mbs ; } else { ih264d_decode_recon_tfr_nmb ( ps_dec , u1_mb_idx , u1_num_mbs , u1_num_mbs_next , u1_tfr_n_mb , u1_end_of_row ) ; } <S2SV_StartBug> ps_dec -> u1_mb_idx = 0 ; <S2SV_EndBug> ps_dec -> u4_num_mbs_cur_nmb = 0 ; } if ( ps_dec -> u2_total_mbs_coded >= ps_dec -> u2_frm_ht_in_mbs * ps_dec -> u2_frm_wd_in_mbs ) { ps_dec -> u1_pic_decode_done = 1 ; return 0 ; } ps_dec -> u2_cur_slice_num ++ ; ps_dec -> i2_prev_slice_mbx = ps_dec -> u2_mbx ; ps_dec -> i2_prev_slice_mby = ps_dec -> u2_mby ; ps_dec -> ps_parse_cur_slice ++ ; } else { ps_dec -> ps_parse_cur_slice = ps_dec -> ps_dec_slice_buf + ps_dec -> u2_cur_slice_num ; } } { WORD32 num_entries ; WORD32 size ; UWORD8 * pu1_buf ; num_entries = MIN ( MAX_FRAMES , ps_dec -> u4_num_ref_frames_at_init ) ; num_entries = 2 * ( ( 2 * num_entries ) + 1 ) ; size = num_entries * sizeof ( void * ) ; size += PAD_MAP_IDX_POC * sizeof ( void * ) ; pu1_buf = ( UWORD8 * ) ps_dec -> pv_map_ref_idx_to_poc_buf ; pu1_buf += size * ps_dec -> u2_cur_slice_num ; ps_dec -> ps_parse_cur_slice -> ppv_map_ref_idx_to_poc = ( volatile void * * ) pu1_buf ; } ps_dec -> ps_cur_slice -> u2_first_mb_in_slice = ps_dec -> u2_total_mbs_coded << u1_mbaff ; if ( ps_dec -> ps_cur_slice -> u1_field_pic_flag ) ps_dec -> u2_prv_frame_num = ps_dec -> ps_cur_slice -> u2_frame_num ; ps_dec -> ps_parse_cur_slice -> u4_first_mb_in_slice = ps_dec -> u2_total_mbs_coded << u1_mbaff ; ps_dec -> ps_parse_cur_slice -> u2_log2Y_crwd = ps_dec -> ps_cur_slice -> u2_log2Y_crwd ; if ( ps_dec -> u1_separate_parse ) { ps_dec -> ps_parse_cur_slice -> pv_tu_coeff_data_start = ps_dec -> pv_parse_tu_coeff_data ; } else { ps_dec -> pv_proc_tu_coeff_data = ps_dec -> pv_parse_tu_coeff_data ; } u1_inter_mb_type = P_MB ; u1_deblk_mb_type = D_INTER_MB ; ps_dec -> ps_cur_slice -> u1_slice_type = P_SLICE ; ps_dec -> ps_parse_cur_slice -> slice_type = P_SLICE ; ps_dec -> pf_mvpred_ref_tfr_nby2mb = ih264d_mv_pred_ref_tfr_nby2_pmb ; ps_dec -> ps_part = ps_dec -> ps_parse_part_params ; ps_dec -> u1_slice_header_done = 2 ; ps_dec -> u1_qp = ps_slice -> u1_slice_qp ; ih264d_update_qp ( ps_dec , 0 ) ; u1_mb_idx = ps_dec -> u1_mb_idx ; ps_parse_mb_data = ps_dec -> ps_parse_mb_data ; u1_num_mbs = u1_mb_idx ; u1_slice_end = 0 ; u1_tfr_n_mb = 0 ; u1_decode_nmb = 0 ; u1_num_mbsNby2 = 0 ; i2_cur_mb_addr = ps_dec -> u2_total_mbs_coded ; i2_mb_skip_run = num_mb_skip ; while ( ! u1_slice_end ) { UWORD8 u1_mb_type ; if ( i2_cur_mb_addr > ps_dec -> ps_cur_sps -> u2_max_mb_addr ) break ; ps_cur_mb_info = ps_dec -> ps_nmb_info + u1_num_mbs ; ps_dec -> u4_num_mbs_cur_nmb = u1_num_mbs ; ps_cur_mb_info -> u1_Mux = 0 ; ps_dec -> u4_num_pmbair = ( u1_num_mbs >> u1_mbaff ) ; ps_cur_deblk_mb = ps_dec -> ps_deblk_mbn + u1_num_mbs ; ps_cur_mb_info -> u1_end_of_slice = 0 ; ps_parse_mb_data -> u1_num_part = 1 ; ps_parse_mb_data -> u1_isI_mb = 0 ; if ( u1_mbaff ) ih264d_get_mb_info_cavlc_mbaff ( ps_dec , i2_cur_mb_addr , ps_cur_mb_info , i2_mb_skip_run ) ; else ih264d_get_mb_info_cavlc_nonmbaff ( ps_dec , i2_cur_mb_addr , ps_cur_mb_info , i2_mb_skip_run ) ; if ( ps_dec -> u4_app_disable_deblk_frm == 0 ) { ih264d_set_deblocking_parameters ( ps_cur_deblk_mb , ps_slice , ps_dec -> u1_mb_ngbr_availablity , ps_dec -> u1_cur_mb_fld_dec_flag ) ; } ps_dec -> i1_prev_mb_qp_delta = 0 ; ps_dec -> u1_sub_mb_num = 0 ; ps_cur_mb_info -> u1_mb_type = MB_SKIP ; ps_cur_mb_info -> u1_mb_mc_mode = PRED_16x16 ; ps_cur_mb_info -> u1_cbp = 0 ; ps_part_info = ps_dec -> ps_part ; ps_part_info -> u1_is_direct = PART_DIRECT_16x16 ; ps_part_info -> u1_sub_mb_num = 0 ; ps_dec -> ps_part ++ ; ih264d_update_nnz_for_skipmb ( ps_dec , ps_cur_mb_info , CAVLC ) ; ps_cur_mb_info -> ps_curmb -> u1_mb_type = u1_inter_mb_type ; ps_cur_deblk_mb -> u1_mb_type |= u1_deblk_mb_type ; i2_mb_skip_run -- ; ps_cur_deblk_mb -> u1_mb_qp = ps_dec -> u1_qp ; if ( u1_mbaff ) { ih264d_update_mbaff_left_nnz ( ps_dec , ps_cur_mb_info ) ; } i2_cur_mb_addr ++ ; u1_num_mbs ++ ; <S2SV_StartBug> ps_dec -> u2_total_mbs_coded ++ ; <S2SV_EndBug> u1_num_mbsNby2 ++ ; ps_parse_mb_data ++ ; u1_num_mbs_next = i2_pic_wdin_mbs - ps_dec -> u2_mbx - 1 ; u1_end_of_row = ( ! u1_num_mbs_next ) && ( ! ( u1_mbaff && ( u1_num_mbs & 0x01 ) ) ) ; u1_slice_end = ! i2_mb_skip_run ; u1_tfr_n_mb = ( u1_num_mbs == ps_dec -> u1_recon_mb_grp ) || u1_end_of_row || u1_slice_end ; u1_decode_nmb = u1_tfr_n_mb || u1_slice_end ; ps_cur_mb_info -> u1_end_of_slice = u1_slice_end ; if ( u1_decode_nmb ) { ps_dec -> pf_mvpred_ref_tfr_nby2mb ( ps_dec , u1_mb_idx , u1_num_mbs ) ; u1_num_mbsNby2 = 0 ; ps_parse_mb_data = ps_dec -> ps_parse_mb_data ; ps_dec -> ps_part = ps_dec -> ps_parse_part_params ; if ( ps_dec -> u1_separate_parse ) { ih264d_parse_tfr_nmb ( ps_dec , u1_mb_idx , u1_num_mbs , u1_num_mbs_next , u1_tfr_n_mb , u1_end_of_row ) ; ps_dec -> ps_nmb_info += u1_num_mbs ; } else { ih264d_decode_recon_tfr_nmb ( ps_dec , u1_mb_idx , u1_num_mbs , u1_num_mbs_next , u1_tfr_n_mb , u1_end_of_row ) ; } <S2SV_StartBug> if ( u1_tfr_n_mb ) <S2SV_EndBug> u1_num_mbs = 0 ; u1_mb_idx = u1_num_mbs ; ps_dec -> u1_mb_idx = u1_num_mbs ; } } ps_dec -> u4_num_mbs_cur_nmb = 0 ; ps_dec -> ps_cur_slice -> u4_mbs_in_slice = i2_cur_mb_addr - ps_dec -> ps_parse_cur_slice -> u4_first_mb_in_slice ; H264_DEC_DEBUG_PRINT ( \"Mbs<S2SV_blank>in<S2SV_blank>slice:<S2SV_blank>%d\\\\n\" , ps_dec -> ps_cur_slice -> u4_mbs_in_slice ) ; ps_dec -> u2_cur_slice_num ++ ; if ( ps_dec -> u4_first_slice_in_pic != 0 ) ps_dec -> ps_parse_cur_slice ++ ; ps_dec -> i2_prev_slice_mbx = ps_dec -> u2_mbx ; ps_dec -> i2_prev_slice_mby = ps_dec -> u2_mby ; if ( ps_dec -> u2_total_mbs_coded >= ps_dec -> u2_frm_ht_in_mbs * ps_dec -> u2_frm_wd_in_mbs ) { ps_dec -> u1_pic_decode_done = 1 ; } return 0 ; }\n",
      "fixed_code": "<S2SV_ModStart> } ps_dec -> u2_total_mbs_coded += u1_num_mbs ; ps_dec -> <S2SV_ModStart> u1_num_mbs ++ ; <S2SV_ModEnd> u1_num_mbsNby2 ++ ; <S2SV_ModStart> ) ; } ps_dec -> u2_total_mbs_coded += u1_num_mbs ;\n",
      "source_code_length": 10233,
      "target_code_length": 206,
      "vulnerability_patterns": {
        "integer_overflow": 18,
        "null_pointer": 188,
        "total": 206
      },
      "total_patterns": 206,
      "original_address": "https://android.googlesource.com/platform/external/libavc/+/4a524d3a8ae9aa20c36430008e6bd429443f8f1d",
      "discovery_time": "2016-03-12T21:59Z",
      "project_commit_id": "external@libavc/4a524d3a8ae9aa20c36430008e6bd429443f8f1d",
      "extraction_time": "2025-08-31T15:41:49.190440",
      "label": 1,
      "vulnerability_type": "buffer_overflow",
      "difficulty_level": "advanced",
      "risk_factors": [
        "system_crash",
        "memory_corruption",
        "arbitrary_code_execution"
      ],
      "attack_vectors": [
        "memory_manipulation",
        "malicious_input",
        "code_analysis",
        "buffer_overflow",
        "reverse_engineering",
        "fuzzing"
      ],
      "mitigation_strategies": [
        "safe_string_functions",
        "dynamic_analysis",
        "code_review",
        "static_analysis",
        "memory_safety_checks",
        "input_validation",
        "fuzzing",
        "bounds_checking",
        "secure_coding_practices"
      ],
      "code_differences": {
        "has_differences": true,
        "source_lines": 2,
        "target_lines": 2,
        "character_differences": 10027,
        "similarity_percentage": 4.385964912280701
      },
      "vulnerability_location": {
        "vulnerability_present": true,
        "fix_applied": true,
        "code_changed": true,
        "estimated_lines_changed": 0
      }
    },
    {
      "cve_id": "CVE-2016-1621",
      "cwe_id": "CWE-119",
      "cwe_name": "Buffer Overflow",
      "project": "external",
      "severity": "critical",
      "weaponization_score": 7.0,
      "is_critical": true,
      "is_weaponizable": true,
      "is_high_priority_project": false,
      "vulnerable_code": "CWE-119 int main ( int argc , char * * argv ) { int frame_cnt = 0 ; FILE * outfile = NULL ; vpx_codec_ctx_t codec ; const VpxInterface * decoder = NULL ; VpxVideoReader * reader = NULL ; const VpxVideoInfo * info = NULL ; int n = 0 ; int m = 0 ; int is_range = 0 ; char * nptr = NULL ; exec_name = argv [ 0 ] ; if ( argc != 4 ) die ( \"Invalid<S2SV_blank>number<S2SV_blank>of<S2SV_blank>arguments.\" ) ; reader = vpx_video_reader_open ( argv [ 1 ] ) ; if ( ! reader ) die ( \"Failed<S2SV_blank>to<S2SV_blank>open<S2SV_blank>%s<S2SV_blank>for<S2SV_blank>reading.\" , argv [ 1 ] ) ; if ( ! ( outfile = fopen ( argv [ 2 ] , \"wb\" ) ) ) die ( \"Failed<S2SV_blank>to<S2SV_blank>open<S2SV_blank>%s<S2SV_blank>for<S2SV_blank>writing.\" , argv [ 2 ] ) ; n = strtol ( argv [ 3 ] , & nptr , 0 ) ; m = strtol ( nptr + 1 , NULL , 0 ) ; is_range = ( * nptr == '-' ) ; if ( ! n || ! m || ( * nptr != '-' && * nptr != '/' ) ) die ( \"Couldn\\'t<S2SV_blank>parse<S2SV_blank>pattern<S2SV_blank>%s.\\\\n\" , argv [ 3 ] ) ; info = vpx_video_reader_get_info ( reader ) ; decoder = get_vpx_decoder_by_fourcc ( info -> codec_fourcc ) ; if ( ! decoder ) die ( \"Unknown<S2SV_blank>input<S2SV_blank>codec.\" ) ; <S2SV_StartBug> printf ( \"Using<S2SV_blank>%s\\\\n\" , vpx_codec_iface_name ( decoder -> interface ( ) ) ) ; <S2SV_EndBug> <S2SV_StartBug> if ( vpx_codec_dec_init ( & codec , decoder -> interface ( ) , NULL , 0 ) ) <S2SV_EndBug> die_codec ( & codec , \"Failed<S2SV_blank>to<S2SV_blank>initialize<S2SV_blank>decoder.\" ) ; while ( vpx_video_reader_read_frame ( reader ) ) { vpx_codec_iter_t iter = NULL ; vpx_image_t * img = NULL ; size_t frame_size = 0 ; int skip ; const unsigned char * frame = vpx_video_reader_get_frame ( reader , & frame_size ) ; if ( vpx_codec_decode ( & codec , frame , ( unsigned int ) frame_size , NULL , 0 ) ) die_codec ( & codec , \"Failed<S2SV_blank>to<S2SV_blank>decode<S2SV_blank>frame.\" ) ; ++ frame_cnt ; skip = ( is_range && frame_cnt >= n && frame_cnt <= m ) || ( ! is_range && m - ( frame_cnt - 1 ) % m <= n ) ; if ( ! skip ) { putc ( '.' , stdout ) ; while ( ( img = vpx_codec_get_frame ( & codec , & iter ) ) != NULL ) vpx_img_write ( img , outfile ) ; } else { putc ( 'X' , stdout ) ; } fflush ( stdout ) ; } printf ( \"Processed<S2SV_blank>%d<S2SV_blank>frames.\\\\n\" , frame_cnt ) ; if ( vpx_codec_destroy ( & codec ) ) die_codec ( & codec , \"Failed<S2SV_blank>to<S2SV_blank>destroy<S2SV_blank>codec.\" ) ; printf ( \"Play:<S2SV_blank>ffplay<S2SV_blank>-f<S2SV_blank>rawvideo<S2SV_blank>-pix_fmt<S2SV_blank>yuv420p<S2SV_blank>-s<S2SV_blank>%dx%d<S2SV_blank>%s\\\\n\" , info -> frame_width , info -> frame_height , argv [ 2 ] ) ; vpx_video_reader_close ( reader ) ; fclose ( outfile ) ; return EXIT_SUCCESS ; }\n",
      "fixed_code": "<S2SV_ModStart> ( decoder -> codec_interface <S2SV_ModEnd> ( ) ) <S2SV_ModStart> , decoder -> codec_interface <S2SV_ModEnd> ( ) ,\n",
      "source_code_length": 2710,
      "target_code_length": 130,
      "vulnerability_patterns": {
        "integer_overflow": 6,
        "null_pointer": 26,
        "total": 32
      },
      "total_patterns": 32,
      "original_address": "https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426",
      "discovery_time": "2016-03-12T21:59Z",
      "project_commit_id": "external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426",
      "extraction_time": "2025-08-31T15:41:49.190511",
      "label": 1,
      "vulnerability_type": "buffer_overflow",
      "difficulty_level": "advanced",
      "risk_factors": [
        "system_crash",
        "memory_corruption",
        "arbitrary_code_execution"
      ],
      "attack_vectors": [
        "memory_manipulation",
        "malicious_input",
        "code_analysis",
        "buffer_overflow",
        "reverse_engineering",
        "fuzzing"
      ],
      "mitigation_strategies": [
        "safe_string_functions",
        "dynamic_analysis",
        "code_review",
        "static_analysis",
        "memory_safety_checks",
        "input_validation",
        "fuzzing",
        "bounds_checking",
        "secure_coding_practices"
      ],
      "code_differences": {
        "has_differences": true,
        "source_lines": 2,
        "target_lines": 2,
        "character_differences": 2580,
        "similarity_percentage": 4.464285714285714
      },
      "vulnerability_location": {
        "vulnerability_present": true,
        "fix_applied": true,
        "code_changed": true,
        "estimated_lines_changed": 0
      }
    },
    {
      "cve_id": "CVE-2017-12664",
      "cwe_id": "CWE-772",
      "cwe_name": "Missing Release of Memory",
      "project": "ImageMagick",
      "severity": "critical",
      "weaponization_score": 7.0,
      "is_critical": true,
      "is_weaponizable": true,
      "is_high_priority_project": true,
      "vulnerable_code": "CWE-772 static Image * ReadPALMImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { Image * image ; MagickBooleanType status ; MagickOffsetType totalOffset , seekNextDepth ; PixelInfo transpix ; Quantum index ; register ssize_t i , x ; register Quantum * q ; size_t bytes_per_row , flags , bits_per_pixel , version , nextDepthOffset , transparentIndex , compressionType , byte , mask , redbits , greenbits , bluebits , one , pad , size , bit ; ssize_t count , y ; unsigned char <S2SV_StartBug> * lastrow , <S2SV_EndBug> * one_row , * ptr ; unsigned short color16 ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickCoreSignature ) ; if ( image_info -> debug != MagickFalse ) ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , \"%s\" , image_info -> filename ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickCoreSignature ) ; image = AcquireImage ( image_info , exception ) ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) { ( void ) DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } totalOffset = 0 ; do { image -> columns = ReadBlobMSBShort ( image ) ; image -> rows = ReadBlobMSBShort ( image ) ; if ( EOFBlob ( image ) != MagickFalse ) ThrowReaderException ( CorruptImageError , \"ImproperImageHeader\" ) ; if ( ( image -> columns == 0 ) || ( image -> rows == 0 ) ) ThrowReaderException ( CorruptImageError , \"NegativeOrZeroImageSize\" ) ; status = SetImageExtent ( image , image -> columns , image -> rows , exception ) ; if ( status == MagickFalse ) return ( DestroyImageList ( image ) ) ; bytes_per_row = ReadBlobMSBShort ( image ) ; flags = ReadBlobMSBShort ( image ) ; bits_per_pixel = ( size_t ) ReadBlobByte ( image ) ; if ( ( bits_per_pixel != 1 ) && ( bits_per_pixel != 2 ) && ( bits_per_pixel != 4 ) && ( bits_per_pixel != 8 ) && ( bits_per_pixel != 16 ) ) ThrowReaderException ( CorruptImageError , \"UnrecognizedBitsPerPixel\" ) ; version = ( size_t ) ReadBlobByte ( image ) ; if ( ( version != 0 ) && ( version != 1 ) && ( version != 2 ) ) ThrowReaderException ( CorruptImageError , \"FileFormatVersionMismatch\" ) ; nextDepthOffset = ( size_t ) ReadBlobMSBShort ( image ) ; transparentIndex = ( size_t ) ReadBlobByte ( image ) ; compressionType = ( size_t ) ReadBlobByte ( image ) ; if ( ( compressionType != PALM_COMPRESSION_NONE ) && ( compressionType != PALM_COMPRESSION_SCANLINE ) && ( compressionType != PALM_COMPRESSION_RLE ) ) ThrowReaderException ( CorruptImageError , \"UnrecognizedImageCompression\" ) ; pad = ReadBlobMSBShort ( image ) ; ( void ) pad ; one = 1 ; if ( ( bits_per_pixel < 16 ) && ( AcquireImageColormap ( image , one << bits_per_pixel , exception ) == MagickFalse ) ) ThrowReaderException ( ResourceLimitError , \"MemoryAllocationFailed\" ) ; GetPixelInfo ( image , & transpix ) ; if ( bits_per_pixel == 16 ) { redbits = ( size_t ) ReadBlobByte ( image ) ; ( void ) redbits ; greenbits = ( size_t ) ReadBlobByte ( image ) ; ( void ) greenbits ; bluebits = ( size_t ) ReadBlobByte ( image ) ; ( void ) bluebits ; ReadBlobByte ( image ) ; ReadBlobByte ( image ) ; transpix . red = ( double ) ( QuantumRange * ReadBlobByte ( image ) / 31 ) ; transpix . green = ( double ) ( QuantumRange * ReadBlobByte ( image ) / 63 ) ; transpix . blue = ( double ) ( QuantumRange * ReadBlobByte ( image ) / 31 ) ; } if ( bits_per_pixel == 8 ) { ssize_t index ; if ( flags & PALM_HAS_COLORMAP_FLAG ) { count = ( ssize_t ) ReadBlobMSBShort ( image ) ; for ( i = 0 ; i < ( ssize_t ) count ; i ++ ) { ReadBlobByte ( image ) ; index = ConstrainColormapIndex ( image , 255 - i , exception ) ; image -> colormap [ index ] . red = ( MagickRealType ) ScaleCharToQuantum ( ( unsigned char ) ReadBlobByte ( image ) ) ; image -> colormap [ index ] . green = ( MagickRealType ) ScaleCharToQuantum ( ( unsigned char ) ReadBlobByte ( image ) ) ; image -> colormap [ index ] . blue = ( MagickRealType ) ScaleCharToQuantum ( ( unsigned char ) ReadBlobByte ( image ) ) ; } } else for ( i = 0 ; i < ( ssize_t ) ( 1L << bits_per_pixel ) ; i ++ ) { index = ConstrainColormapIndex ( image , 255 - i , exception ) ; image -> colormap [ index ] . red = ( MagickRealType ) ScaleCharToQuantum ( PalmPalette [ i ] [ 0 ] ) ; image -> colormap [ index ] . green = ( MagickRealType ) ScaleCharToQuantum ( PalmPalette [ i ] [ 1 ] ) ; image -> colormap [ index ] . blue = ( MagickRealType ) ScaleCharToQuantum ( PalmPalette [ i ] [ 2 ] ) ; } } if ( flags & PALM_IS_COMPRESSED_FLAG ) size = ReadBlobMSBShort ( image ) ; ( void ) size ; image -> storage_class = DirectClass ; if ( bits_per_pixel < 16 ) { image -> storage_class = PseudoClass ; image -> depth = 8 ; } if ( image_info -> ping != MagickFalse ) { ( void ) CloseBlob ( image ) ; return ( image ) ; } status = SetImageExtent ( image , image -> columns , image -> rows , exception ) ; if ( status == MagickFalse ) return ( DestroyImageList ( image ) ) ; one_row = ( unsigned char * ) AcquireQuantumMemory ( MagickMax ( bytes_per_row , 2 * image -> columns ) , sizeof ( * one_row ) ) ; if ( one_row == ( unsigned char * ) NULL ) ThrowReaderException ( ResourceLimitError , \"MemoryAllocationFailed\" ) ; <S2SV_StartBug> lastrow = ( unsigned char * ) NULL ; <S2SV_EndBug> if ( compressionType == PALM_COMPRESSION_SCANLINE ) { <S2SV_StartBug> lastrow = ( unsigned char * ) AcquireQuantumMemory ( MagickMax ( bytes_per_row , <S2SV_EndBug> <S2SV_StartBug> 2 * image -> columns ) , sizeof ( * lastrow ) ) ; <S2SV_EndBug> if ( lastrow == ( unsigned char * ) NULL ) ThrowReaderException ( ResourceLimitError , \"MemoryAllocationFailed\" ) ; } mask = ( size_t ) ( 1U << bits_per_pixel ) - 1 ; for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { if ( ( flags & PALM_IS_COMPRESSED_FLAG ) == 0 ) { image -> compression = NoCompression ; count = ReadBlob ( image , bytes_per_row , one_row ) ; if ( count != ( ssize_t ) bytes_per_row ) break ; } else { if ( compressionType == PALM_COMPRESSION_RLE ) { image -> compression = RLECompression ; for ( i = 0 ; i < ( ssize_t ) bytes_per_row ; ) { count = ( ssize_t ) ReadBlobByte ( image ) ; if ( count < 0 ) break ; count = MagickMin ( count , ( ssize_t ) bytes_per_row - i ) ; byte = ( size_t ) ReadBlobByte ( image ) ; ( void ) ResetMagickMemory ( one_row + i , ( int ) byte , ( size_t ) count ) ; i += count ; } } else if ( compressionType == PALM_COMPRESSION_SCANLINE ) { size_t one ; one = 1 ; image -> compression = FaxCompression ; for ( i = 0 ; i < ( ssize_t ) bytes_per_row ; i += 8 ) { count = ( ssize_t ) ReadBlobByte ( image ) ; if ( count < 0 ) break ; byte = ( size_t ) MagickMin ( ( ssize_t ) bytes_per_row - i , 8 ) ; for ( bit = 0 ; bit < byte ; bit ++ ) { if ( ( y == 0 ) || ( count & ( one << ( 7 - bit ) ) ) ) one_row [ i + bit ] = ( unsigned char ) ReadBlobByte ( image ) ; else <S2SV_StartBug> one_row [ i + bit ] = lastrow [ i + bit ] ; <S2SV_EndBug> } } <S2SV_StartBug> ( void ) CopyMagickMemory ( lastrow , one_row , bytes_per_row ) ; <S2SV_EndBug> } } ptr = one_row ; q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; if ( bits_per_pixel == 16 ) { if ( image -> columns > ( 2 * bytes_per_row ) ) { one_row = ( unsigned char * ) RelinquishMagickMemory ( one_row ) ; if ( compressionType == PALM_COMPRESSION_SCANLINE ) <S2SV_StartBug> lastrow = ( unsigned char * ) RelinquishMagickMemory ( lastrow ) ; <S2SV_EndBug> ThrowReaderException ( CorruptImageError , \"CorruptImage\" ) ; } for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { color16 = ( * ptr ++ << 8 ) ; color16 |= ( * ptr ++ ) ; SetPixelRed ( image , ( Quantum ) ( ( QuantumRange * ( ( color16 >> 11 ) & 0x1f ) ) / 0x1f ) , q ) ; SetPixelGreen ( image , ( Quantum ) ( ( QuantumRange * ( ( color16 >> 5 ) & 0x3f ) ) / 0x3f ) , q ) ; SetPixelBlue ( image , ( Quantum ) ( ( QuantumRange * ( ( color16 >> 0 ) & 0x1f ) ) / 0x1f ) , q ) ; SetPixelAlpha ( image , OpaqueAlpha , q ) ; q += GetPixelChannels ( image ) ; } } else { bit = 8 - bits_per_pixel ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { if ( ( size_t ) ( ptr - one_row ) >= bytes_per_row ) { one_row = ( unsigned char * ) RelinquishMagickMemory ( one_row ) ; if ( compressionType == PALM_COMPRESSION_SCANLINE ) <S2SV_StartBug> lastrow = ( unsigned char * ) RelinquishMagickMemory ( lastrow ) ; <S2SV_EndBug> ThrowReaderException ( CorruptImageError , \"CorruptImage\" ) ; } index = ( Quantum ) ( mask - ( ( ( * ptr ) & ( mask << bit ) ) >> bit ) ) ; SetPixelIndex ( image , index , q ) ; SetPixelViaPixelInfo ( image , image -> colormap + ( ssize_t ) index , q ) ; if ( bit ) bit -= bits_per_pixel ; else { ptr ++ ; bit = 8 - bits_per_pixel ; } q += GetPixelChannels ( image ) ; } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; } if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ; if ( status == MagickFalse ) break ; } } if ( flags & PALM_HAS_TRANSPARENCY_FLAG ) { ssize_t index = ConstrainColormapIndex ( image , ( ssize_t ) ( mask - transparentIndex ) , exception ) ; if ( bits_per_pixel != 16 ) transpix = image -> colormap [ index ] ; ( void ) TransparentPaintImage ( image , & transpix , ( Quantum ) TransparentAlpha , MagickFalse , exception ) ; } one_row = ( unsigned char * ) RelinquishMagickMemory ( one_row ) ; if ( compressionType == PALM_COMPRESSION_SCANLINE ) <S2SV_StartBug> lastrow = ( unsigned char * ) RelinquishMagickMemory ( lastrow ) ; <S2SV_EndBug> if ( EOFBlob ( image ) != MagickFalse ) { ThrowFileException ( exception , CorruptImageError , \"UnexpectedEndOfFile\" , image -> filename ) ; break ; } if ( image_info -> number_scenes != 0 ) if ( image -> scene >= ( image_info -> scene + image_info -> number_scenes - 1 ) ) break ; if ( nextDepthOffset != 0 ) { totalOffset += ( MagickOffsetType ) ( nextDepthOffset * 4 ) ; if ( totalOffset >= ( MagickOffsetType ) GetBlobSize ( image ) ) ThrowReaderException ( CorruptImageError , \"ImproperImageHeader\" ) else seekNextDepth = SeekBlob ( image , totalOffset , SEEK_SET ) ; if ( seekNextDepth != totalOffset ) ThrowReaderException ( CorruptImageError , \"ImproperImageHeader\" ) ; AcquireNextImage ( image_info , image , exception ) ; if ( GetNextImageInList ( image ) == ( Image * ) NULL ) { ( void ) DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } image = SyncNextImageInList ( image ) ; status = SetImageProgress ( image , LoadImagesTag , TellBlob ( image ) , GetBlobSize ( image ) ) ; if ( status == MagickFalse ) break ; } } while ( nextDepthOffset != 0 ) ; ( void ) CloseBlob ( image ) ; return ( GetFirstImageInList ( image ) ) ; }\n",
      "fixed_code": "<S2SV_ModStart> unsigned char * last_row <S2SV_ModEnd> , * one_row <S2SV_ModStart> \"MemoryAllocationFailed\" ) ; last_row <S2SV_ModEnd> = ( unsigned <S2SV_ModStart> PALM_COMPRESSION_SCANLINE ) { last_row <S2SV_ModEnd> = ( unsigned <S2SV_ModStart> sizeof ( * last_row ) ) ; if ( last_row <S2SV_ModEnd> == ( unsigned <S2SV_ModStart> bit ] = last_row <S2SV_ModEnd> [ i + <S2SV_ModStart> ) CopyMagickMemory ( last_row <S2SV_ModEnd> , one_row , <S2SV_ModStart> == PALM_COMPRESSION_SCANLINE ) last_row <S2SV_ModEnd> = ( unsigned <S2SV_ModStart> ) RelinquishMagickMemory ( last_row <S2SV_ModEnd> ) ; ThrowReaderException <S2SV_ModStart> == PALM_COMPRESSION_SCANLINE ) last_row <S2SV_ModEnd> = ( unsigned <S2SV_ModStart> ) RelinquishMagickMemory ( last_row <S2SV_ModEnd> ) ; ThrowReaderException <S2SV_ModStart> == PALM_COMPRESSION_SCANLINE ) last_row <S2SV_ModEnd> = ( unsigned <S2SV_ModStart> ) RelinquishMagickMemory ( last_row <S2SV_ModEnd> ) ; if\n",
      "source_code_length": 10718,
      "target_code_length": 943,
      "vulnerability_patterns": {
        "integer_overflow": 15,
        "null_pointer": 41,
        "total": 56
      },
      "total_patterns": 56,
      "original_address": "https://github.com/ImageMagick/ImageMagick/commit/0417cea1b6d72f90bd4f1f573f91e42a8ba66a89",
      "discovery_time": "2017-08-07T21:29Z",
      "project_commit_id": "ImageMagick@ImageMagick/0417cea1b6d72f90bd4f1f573f91e42a8ba66a89",
      "extraction_time": "2025-08-31T15:41:49.190536",
      "label": 1,
      "vulnerability_type": "missing_release_of_memory",
      "difficulty_level": "advanced",
      "risk_factors": [
        "critical_infrastructure"
      ],
      "attack_vectors": [
        "fuzzing",
        "code_analysis",
        "reverse_engineering"
      ],
      "mitigation_strategies": [
        "dynamic_analysis",
        "static_analysis",
        "fuzzing",
        "code_review",
        "secure_coding_practices"
      ],
      "code_differences": {
        "has_differences": true,
        "source_lines": 2,
        "target_lines": 2,
        "character_differences": 9775,
        "similarity_percentage": 11.27450980392157
      },
      "vulnerability_location": {
        "vulnerability_present": true,
        "fix_applied": true,
        "code_changed": true,
        "estimated_lines_changed": 0
      }
    },
    {
      "cve_id": "CVE-2016-1621",
      "cwe_id": "CWE-119",
      "cwe_name": "Buffer Overflow",
      "project": "external",
      "severity": "critical",
      "weaponization_score": 7.0,
      "is_critical": true,
      "is_weaponizable": true,
      "is_high_priority_project": false,
      "vulnerable_code": "CWE-119 int main ( int argc , char * * argv ) { int frame_cnt = 0 ; FILE * outfile = NULL ; vpx_codec_ctx_t codec ; const VpxInterface * decoder = NULL ; VpxVideoReader * reader = NULL ; const VpxVideoInfo * info = NULL ; int n = 0 ; int m = 0 ; int is_range = 0 ; char * nptr = NULL ; exec_name = argv [ 0 ] ; if ( argc != 4 ) die ( \"Invalid<S2SV_blank>number<S2SV_blank>of<S2SV_blank>arguments.\" ) ; reader = vpx_video_reader_open ( argv [ 1 ] ) ; if ( ! reader ) die ( \"Failed<S2SV_blank>to<S2SV_blank>open<S2SV_blank>%s<S2SV_blank>for<S2SV_blank>reading.\" , argv [ 1 ] ) ; if ( ! ( outfile = fopen ( argv [ 2 ] , \"wb\" ) ) ) die ( \"Failed<S2SV_blank>to<S2SV_blank>open<S2SV_blank>%s<S2SV_blank>for<S2SV_blank>writing.\" , argv [ 2 ] ) ; n = strtol ( argv [ 3 ] , & nptr , 0 ) ; m = strtol ( nptr + 1 , NULL , 0 ) ; is_range = ( * nptr == '-' ) ; if ( ! n || ! m || ( * nptr != '-' && * nptr != '/' ) ) die ( \"Couldn\\'t<S2SV_blank>parse<S2SV_blank>pattern<S2SV_blank>%s.\\\\n\" , argv [ 3 ] ) ; info = vpx_video_reader_get_info ( reader ) ; decoder = get_vpx_decoder_by_fourcc ( info -> codec_fourcc ) ; if ( ! decoder ) die ( \"Unknown<S2SV_blank>input<S2SV_blank>codec.\" ) ; <S2SV_StartBug> printf ( \"Using<S2SV_blank>%s\\\\n\" , vpx_codec_iface_name ( decoder -> interface ( ) ) ) ; <S2SV_EndBug> <S2SV_StartBug> if ( vpx_codec_dec_init ( & codec , decoder -> interface ( ) , NULL , 0 ) ) <S2SV_EndBug> die_codec ( & codec , \"Failed<S2SV_blank>to<S2SV_blank>initialize<S2SV_blank>decoder.\" ) ; while ( vpx_video_reader_read_frame ( reader ) ) { vpx_codec_iter_t iter = NULL ; vpx_image_t * img = NULL ; size_t frame_size = 0 ; int skip ; const unsigned char * frame = vpx_video_reader_get_frame ( reader , & frame_size ) ; if ( vpx_codec_decode ( & codec , frame , ( unsigned int ) frame_size , NULL , 0 ) ) die_codec ( & codec , \"Failed<S2SV_blank>to<S2SV_blank>decode<S2SV_blank>frame.\" ) ; ++ frame_cnt ; skip = ( is_range && frame_cnt >= n && frame_cnt <= m ) || ( ! is_range && m - ( frame_cnt - 1 ) % m <= n ) ; if ( ! skip ) { putc ( '.' , stdout ) ; while ( ( img = vpx_codec_get_frame ( & codec , & iter ) ) != NULL ) vpx_img_write ( img , outfile ) ; } else { putc ( 'X' , stdout ) ; } fflush ( stdout ) ; } printf ( \"Processed<S2SV_blank>%d<S2SV_blank>frames.\\\\n\" , frame_cnt ) ; if ( vpx_codec_destroy ( & codec ) ) die_codec ( & codec , \"Failed<S2SV_blank>to<S2SV_blank>destroy<S2SV_blank>codec.\" ) ; printf ( \"Play:<S2SV_blank>ffplay<S2SV_blank>-f<S2SV_blank>rawvideo<S2SV_blank>-pix_fmt<S2SV_blank>yuv420p<S2SV_blank>-s<S2SV_blank>%dx%d<S2SV_blank>%s\\\\n\" , info -> frame_width , info -> frame_height , argv [ 2 ] ) ; vpx_video_reader_close ( reader ) ; fclose ( outfile ) ; return EXIT_SUCCESS ; }\n",
      "fixed_code": "<S2SV_ModStart> ( decoder -> codec_interface <S2SV_ModEnd> ( ) ) <S2SV_ModStart> , decoder -> codec_interface <S2SV_ModEnd> ( ) ,\n",
      "source_code_length": 2710,
      "target_code_length": 130,
      "vulnerability_patterns": {
        "integer_overflow": 1,
        "null_pointer": 30,
        "total": 31
      },
      "total_patterns": 31,
      "original_address": "https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426",
      "discovery_time": "2016-03-12T21:59Z",
      "project_commit_id": "external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426",
      "extraction_time": "2025-08-31T15:41:49.190620",
      "label": 1,
      "vulnerability_type": "buffer_overflow",
      "difficulty_level": "advanced",
      "risk_factors": [
        "system_crash",
        "memory_corruption",
        "arbitrary_code_execution"
      ],
      "attack_vectors": [
        "memory_manipulation",
        "malicious_input",
        "code_analysis",
        "buffer_overflow",
        "reverse_engineering",
        "fuzzing"
      ],
      "mitigation_strategies": [
        "safe_string_functions",
        "dynamic_analysis",
        "code_review",
        "static_analysis",
        "memory_safety_checks",
        "input_validation",
        "fuzzing",
        "bounds_checking",
        "secure_coding_practices"
      ],
      "code_differences": {
        "has_differences": true,
        "source_lines": 2,
        "target_lines": 2,
        "character_differences": 2580,
        "similarity_percentage": 4.464285714285714
      },
      "vulnerability_location": {
        "vulnerability_present": true,
        "fix_applied": true,
        "code_changed": true,
        "estimated_lines_changed": 0
      }
    },
    {
      "cve_id": "CVE-2017-18270",
      "cwe_id": "CWE-000",
      "cwe_name": "Unknown/Uncategorized",
      "project": "torvalds",
      "severity": "critical",
      "weaponization_score": 7.0,
      "is_critical": true,
      "is_weaponizable": true,
      "is_high_priority_project": false,
      "vulnerable_code": "CWE-000 struct key * key_alloc ( struct key_type * type , const char * desc , kuid_t uid , kgid_t gid , const struct cred * cred , key_perm_t perm , unsigned long flags , struct key_restriction * restrict_link ) { struct key_user * user = NULL ; struct key * key ; size_t desclen , quotalen ; int ret ; key = ERR_PTR ( - EINVAL ) ; if ( ! desc || ! * desc ) goto error ; if ( type -> vet_description ) { ret = type -> vet_description ( desc ) ; if ( ret < 0 ) { key = ERR_PTR ( ret ) ; goto error ; } } desclen = strlen ( desc ) ; quotalen = desclen + 1 + type -> def_datalen ; user = key_user_lookup ( uid ) ; if ( ! user ) goto no_memory_1 ; if ( ! ( flags & KEY_ALLOC_NOT_IN_QUOTA ) ) { unsigned maxkeys = uid_eq ( uid , GLOBAL_ROOT_UID ) ? key_quota_root_maxkeys : key_quota_maxkeys ; unsigned maxbytes = uid_eq ( uid , GLOBAL_ROOT_UID ) ? key_quota_root_maxbytes : key_quota_maxbytes ; spin_lock ( & user -> lock ) ; if ( ! ( flags & KEY_ALLOC_QUOTA_OVERRUN ) ) { if ( user -> qnkeys + 1 >= maxkeys || user -> qnbytes + quotalen >= maxbytes || user -> qnbytes + quotalen < user -> qnbytes ) goto no_quota ; } user -> qnkeys ++ ; user -> qnbytes += quotalen ; spin_unlock ( & user -> lock ) ; } key = kmem_cache_zalloc ( key_jar , GFP_KERNEL ) ; if ( ! key ) goto no_memory_2 ; key -> index_key . desc_len = desclen ; key -> index_key . description = kmemdup ( desc , desclen + 1 , GFP_KERNEL ) ; if ( ! key -> index_key . description ) goto no_memory_3 ; refcount_set ( & key -> usage , 1 ) ; init_rwsem ( & key -> sem ) ; lockdep_set_class ( & key -> sem , & type -> lock_class ) ; key -> index_key . type = type ; key -> user = user ; key -> quotalen = quotalen ; key -> datalen = type -> def_datalen ; key -> uid = uid ; key -> gid = gid ; key -> perm = perm ; key -> restrict_link = restrict_link ; if ( ! ( flags & KEY_ALLOC_NOT_IN_QUOTA ) ) key -> flags |= 1 << KEY_FLAG_IN_QUOTA ; if ( flags & KEY_ALLOC_BUILT_IN ) key -> flags |= 1 << KEY_FLAG_BUILTIN ; <S2SV_StartBug> # ifdef KEY_DEBUGGING <S2SV_EndBug> key -> magic = KEY_DEBUG_MAGIC ; # endif ret = security_key_alloc ( key , cred , flags ) ; if ( ret < 0 ) goto security_error ; atomic_inc ( & user -> nkeys ) ; key_alloc_serial ( key ) ; error : return key ; security_error : kfree ( key -> description ) ; kmem_cache_free ( key_jar , key ) ; if ( ! ( flags & KEY_ALLOC_NOT_IN_QUOTA ) ) { spin_lock ( & user -> lock ) ; user -> qnkeys -- ; user -> qnbytes -= quotalen ; spin_unlock ( & user -> lock ) ; } key_user_put ( user ) ; key = ERR_PTR ( ret ) ; goto error ; no_memory_3 : kmem_cache_free ( key_jar , key ) ; no_memory_2 : if ( ! ( flags & KEY_ALLOC_NOT_IN_QUOTA ) ) { spin_lock ( & user -> lock ) ; user -> qnkeys -- ; user -> qnbytes -= quotalen ; spin_unlock ( & user -> lock ) ; } key_user_put ( user ) ; no_memory_1 : key = ERR_PTR ( - ENOMEM ) ; goto error ; no_quota : spin_unlock ( & user -> lock ) ; key_user_put ( user ) ; key = ERR_PTR ( - EDQUOT ) ; goto error ; }\n",
      "fixed_code": "<S2SV_ModStart> << KEY_FLAG_BUILTIN ; if ( flags & KEY_ALLOC_UID_KEYRING ) key -> flags |= 1 << KEY_FLAG_UID_KEYRING ;\n",
      "source_code_length": 2953,
      "target_code_length": 119,
      "vulnerability_patterns": {
        "use_after_free": 1,
        "integer_overflow": 6,
        "null_pointer": 45,
        "total": 52
      },
      "total_patterns": 52,
      "original_address": "https://github.com/torvalds/linux/commit/237bbd29f7a049d310d907f4b2716a7feef9abf3",
      "discovery_time": "2018-05-18T16:29Z",
      "project_commit_id": "torvalds@linux/237bbd29f7a049d310d907f4b2716a7feef9abf3",
      "extraction_time": "2025-08-31T15:41:49.190645",
      "label": 1,
      "vulnerability_type": "unknown/uncategorized",
      "difficulty_level": "advanced",
      "risk_factors": [
        "use_after_free"
      ],
      "attack_vectors": [
        "fuzzing",
        "code_analysis",
        "reverse_engineering"
      ],
      "mitigation_strategies": [
        "dynamic_analysis",
        "static_analysis",
        "fuzzing",
        "code_review",
        "secure_coding_practices"
      ],
      "code_differences": {
        "has_differences": true,
        "source_lines": 2,
        "target_lines": 2,
        "character_differences": 2834,
        "similarity_percentage": 9.75609756097561
      },
      "vulnerability_location": {
        "vulnerability_present": true,
        "fix_applied": true,
        "code_changed": true,
        "estimated_lines_changed": 0
      }
    },
    {
      "cve_id": "CVE-2016-1621",
      "cwe_id": "CWE-119",
      "cwe_name": "Buffer Overflow",
      "project": "external",
      "severity": "critical",
      "weaponization_score": 7.0,
      "is_critical": true,
      "is_weaponizable": true,
      "is_high_priority_project": false,
      "vulnerable_code": "CWE-119 int main ( int argc , char * * argv ) { int frame_cnt = 0 ; FILE * outfile = NULL ; vpx_codec_ctx_t codec ; const VpxInterface * decoder = NULL ; VpxVideoReader * reader = NULL ; const VpxVideoInfo * info = NULL ; int n = 0 ; int m = 0 ; int is_range = 0 ; char * nptr = NULL ; exec_name = argv [ 0 ] ; if ( argc != 4 ) die ( \"Invalid<S2SV_blank>number<S2SV_blank>of<S2SV_blank>arguments.\" ) ; reader = vpx_video_reader_open ( argv [ 1 ] ) ; if ( ! reader ) die ( \"Failed<S2SV_blank>to<S2SV_blank>open<S2SV_blank>%s<S2SV_blank>for<S2SV_blank>reading.\" , argv [ 1 ] ) ; if ( ! ( outfile = fopen ( argv [ 2 ] , \"wb\" ) ) ) die ( \"Failed<S2SV_blank>to<S2SV_blank>open<S2SV_blank>%s<S2SV_blank>for<S2SV_blank>writing.\" , argv [ 2 ] ) ; n = strtol ( argv [ 3 ] , & nptr , 0 ) ; m = strtol ( nptr + 1 , NULL , 0 ) ; is_range = ( * nptr == '-' ) ; if ( ! n || ! m || ( * nptr != '-' && * nptr != '/' ) ) die ( \"Couldn\\'t<S2SV_blank>parse<S2SV_blank>pattern<S2SV_blank>%s.\\\\n\" , argv [ 3 ] ) ; info = vpx_video_reader_get_info ( reader ) ; decoder = get_vpx_decoder_by_fourcc ( info -> codec_fourcc ) ; if ( ! decoder ) die ( \"Unknown<S2SV_blank>input<S2SV_blank>codec.\" ) ; <S2SV_StartBug> printf ( \"Using<S2SV_blank>%s\\\\n\" , vpx_codec_iface_name ( decoder -> interface ( ) ) ) ; <S2SV_EndBug> <S2SV_StartBug> if ( vpx_codec_dec_init ( & codec , decoder -> interface ( ) , NULL , 0 ) ) <S2SV_EndBug> die_codec ( & codec , \"Failed<S2SV_blank>to<S2SV_blank>initialize<S2SV_blank>decoder.\" ) ; while ( vpx_video_reader_read_frame ( reader ) ) { vpx_codec_iter_t iter = NULL ; vpx_image_t * img = NULL ; size_t frame_size = 0 ; int skip ; const unsigned char * frame = vpx_video_reader_get_frame ( reader , & frame_size ) ; if ( vpx_codec_decode ( & codec , frame , ( unsigned int ) frame_size , NULL , 0 ) ) die_codec ( & codec , \"Failed<S2SV_blank>to<S2SV_blank>decode<S2SV_blank>frame.\" ) ; ++ frame_cnt ; skip = ( is_range && frame_cnt >= n && frame_cnt <= m ) || ( ! is_range && m - ( frame_cnt - 1 ) % m <= n ) ; if ( ! skip ) { putc ( '.' , stdout ) ; while ( ( img = vpx_codec_get_frame ( & codec , & iter ) ) != NULL ) vpx_img_write ( img , outfile ) ; } else { putc ( 'X' , stdout ) ; } fflush ( stdout ) ; } printf ( \"Processed<S2SV_blank>%d<S2SV_blank>frames.\\\\n\" , frame_cnt ) ; if ( vpx_codec_destroy ( & codec ) ) die_codec ( & codec , \"Failed<S2SV_blank>to<S2SV_blank>destroy<S2SV_blank>codec.\" ) ; printf ( \"Play:<S2SV_blank>ffplay<S2SV_blank>-f<S2SV_blank>rawvideo<S2SV_blank>-pix_fmt<S2SV_blank>yuv420p<S2SV_blank>-s<S2SV_blank>%dx%d<S2SV_blank>%s\\\\n\" , info -> frame_width , info -> frame_height , argv [ 2 ] ) ; vpx_video_reader_close ( reader ) ; fclose ( outfile ) ; return EXIT_SUCCESS ; }\n",
      "fixed_code": "<S2SV_ModStart> ( decoder -> codec_interface <S2SV_ModEnd> ( ) ) <S2SV_ModStart> , decoder -> codec_interface <S2SV_ModEnd> ( ) ,\n",
      "source_code_length": 2710,
      "target_code_length": 130,
      "vulnerability_patterns": {
        "null_pointer": 13,
        "total": 13
      },
      "total_patterns": 13,
      "original_address": "https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426",
      "discovery_time": "2016-03-12T21:59Z",
      "project_commit_id": "external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426",
      "extraction_time": "2025-08-31T15:41:49.190678",
      "label": 1,
      "vulnerability_type": "buffer_overflow",
      "difficulty_level": "advanced",
      "risk_factors": [
        "system_crash",
        "memory_corruption",
        "arbitrary_code_execution"
      ],
      "attack_vectors": [
        "memory_manipulation",
        "malicious_input",
        "code_analysis",
        "buffer_overflow",
        "reverse_engineering",
        "fuzzing"
      ],
      "mitigation_strategies": [
        "safe_string_functions",
        "dynamic_analysis",
        "code_review",
        "static_analysis",
        "memory_safety_checks",
        "input_validation",
        "fuzzing",
        "bounds_checking",
        "secure_coding_practices"
      ],
      "code_differences": {
        "has_differences": true,
        "source_lines": 2,
        "target_lines": 2,
        "character_differences": 2580,
        "similarity_percentage": 4.464285714285714
      },
      "vulnerability_location": {
        "vulnerability_present": true,
        "fix_applied": true,
        "code_changed": true,
        "estimated_lines_changed": 0
      }
    },
    {
      "cve_id": "CVE-2016-0840",
      "cwe_id": "CWE-119",
      "cwe_name": "Buffer Overflow",
      "project": "external",
      "severity": "critical",
      "weaponization_score": 7.0,
      "is_critical": true,
      "is_weaponizable": true,
      "is_high_priority_project": false,
      "vulnerable_code": "CWE-119 void ih264d_rest_of_residual_cav_chroma_dc_block ( UWORD32 u4_total_coeff_trail_one , dec_bit_stream_t * ps_bitstrm ) { UWORD32 u4_total_zeroes ; WORD16 i ; UWORD32 * pu4_bitstrm_buf = ps_bitstrm -> pu4_buffer ; UWORD32 u4_bitstream_offset = ps_bitstrm -> u4_ofst ; UWORD32 u4_trailing_ones = u4_total_coeff_trail_one & 0xFFFF ; UWORD32 u4_total_coeff = u4_total_coeff_trail_one >> 16 ; <S2SV_StartBug> WORD16 i2_level_arr [ 4 ] ; <S2SV_EndBug> tu_sblk4x4_coeff_data_t * ps_tu_4x4 ; WORD16 * pi2_coeff_data ; dec_struct_t * ps_dec = ( dec_struct_t * ) ps_bitstrm -> pv_codec_handle ; ps_tu_4x4 = ( tu_sblk4x4_coeff_data_t * ) ps_dec -> pv_parse_tu_coeff_data ; ps_tu_4x4 -> u2_sig_coeff_map = 0 ; pi2_coeff_data = & ps_tu_4x4 -> ai2_level [ 0 ] ; i = u4_total_coeff - 1 ; if ( u4_trailing_ones ) { UWORD32 u4_signs , u4_cnt = u4_trailing_ones ; WORD16 ( * ppi2_trlone_lkup ) [ 3 ] = ( WORD16 ( * ) [ 3 ] ) gai2_ih264d_trailing_one_level ; WORD16 * pi2_trlone_lkup ; GETBITS ( u4_signs , u4_bitstream_offset , pu4_bitstrm_buf , u4_cnt ) ; pi2_trlone_lkup = ppi2_trlone_lkup [ ( 1 << u4_cnt ) - 2 + u4_signs ] ; while ( u4_cnt -- ) i2_level_arr [ i -- ] = * pi2_trlone_lkup ++ ; } if ( i >= 0 ) { UWORD32 u4_lev_suffix , u4_suffix_len , u4_lev_suffix_size ; UWORD16 u2_lev_code , u2_abs_value ; UWORD32 u4_lev_prefix ; FIND_ONE_IN_STREAM_32 ( u4_lev_prefix , u4_bitstream_offset , pu4_bitstrm_buf ) ; u2_lev_code = MIN ( 15 , u4_lev_prefix ) ; u2_lev_code += ( 3 == u4_trailing_ones ) ? 0 : ( 2 ) ; if ( 14 == u4_lev_prefix ) u4_lev_suffix_size = 4 ; else if ( 15 <= u4_lev_prefix ) { u2_lev_code += 15 ; u4_lev_suffix_size = u4_lev_prefix - 3 ; } else u4_lev_suffix_size = 0 ; if ( 16 <= u4_lev_prefix ) { u2_lev_code += ( ( 1 << ( u4_lev_prefix - 3 ) ) - 4096 ) ; } if ( u4_lev_suffix_size ) { GETBITS ( u4_lev_suffix , u4_bitstream_offset , pu4_bitstrm_buf , u4_lev_suffix_size ) ; u2_lev_code += u4_lev_suffix ; } u2_abs_value = ( u2_lev_code + 2 ) >> 1 ; i2_level_arr [ i -- ] = ( u2_lev_code & 1 ) ? - u2_abs_value : u2_abs_value ; u4_suffix_len = ( u2_abs_value > 3 ) ? 2 : 1 ; while ( i >= 0 ) { FIND_ONE_IN_STREAM_32 ( u4_lev_prefix , u4_bitstream_offset , pu4_bitstrm_buf ) ; u4_lev_suffix_size = ( 15 <= u4_lev_prefix ) ? ( u4_lev_prefix - 3 ) : u4_suffix_len ; GETBITS ( u4_lev_suffix , u4_bitstream_offset , pu4_bitstrm_buf , u4_lev_suffix_size ) ; u2_lev_code = ( MIN ( u4_lev_prefix , 15 ) << u4_suffix_len ) + u4_lev_suffix ; if ( 16 <= u4_lev_prefix ) { u2_lev_code += ( ( 1 << ( u4_lev_prefix - 3 ) ) - 4096 ) ; } u2_abs_value = ( u2_lev_code + 2 ) >> 1 ; i2_level_arr [ i -- ] = ( u2_lev_code & 1 ) ? - u2_abs_value : u2_abs_value ; u4_suffix_len += ( u2_abs_value > ( 3 << ( u4_suffix_len - 1 ) ) ) ; } } if ( u4_total_coeff < 4 ) { UWORD32 u4_max_ldz = ( 4 - u4_total_coeff ) ; FIND_ONE_IN_STREAM_LEN ( u4_total_zeroes , u4_bitstream_offset , pu4_bitstrm_buf , u4_max_ldz ) ; } else u4_total_zeroes = 0 ; { const UWORD8 * pu1_table_runbefore ; UWORD32 u4_run ; UWORD32 u4_scan_pos = ( u4_total_coeff + u4_total_zeroes - 1 ) ; UWORD32 u4_zeroes_left = u4_total_zeroes ; i = u4_total_coeff - 1 ; pu1_table_runbefore = ( UWORD8 * ) gau1_ih264d_table_run_before ; while ( u4_zeroes_left && i ) { UWORD32 u4_code ; NEXTBITS ( u4_code , u4_bitstream_offset , pu4_bitstrm_buf , 3 ) ; u4_code = pu1_table_runbefore [ u4_code + ( u4_zeroes_left << 3 ) ] ; u4_run = u4_code >> 2 ; FLUSHBITS ( u4_bitstream_offset , ( u4_code & 0x03 ) ) ; SET_BIT ( ps_tu_4x4 -> u2_sig_coeff_map , u4_scan_pos ) ; * pi2_coeff_data ++ = i2_level_arr [ i -- ] ; u4_zeroes_left -= u4_run ; u4_scan_pos -= ( u4_run + 1 ) ; } while ( i >= 0 ) { SET_BIT ( ps_tu_4x4 -> u2_sig_coeff_map , u4_scan_pos ) ; * pi2_coeff_data ++ = i2_level_arr [ i -- ] ; u4_scan_pos -- ; } } { WORD32 offset ; offset = ( UWORD8 * ) pi2_coeff_data - ( UWORD8 * ) ps_tu_4x4 ; offset = ALIGN4 ( offset ) ; ps_dec -> pv_parse_tu_coeff_data = ( void * ) ( ( UWORD8 * ) ps_dec -> pv_parse_tu_coeff_data + offset ) ; } ps_bitstrm -> u4_ofst = u4_bitstream_offset ; }\n",
      "fixed_code": "<S2SV_ModStart> 16 ; WORD16 ai2_level_arr [ 7 ] ; WORD16 * i2_level_arr = & ai2_level_arr [ 3 <S2SV_ModEnd> ] ; tu_sblk4x4_coeff_data_t\n",
      "source_code_length": 4032,
      "target_code_length": 136,
      "vulnerability_patterns": {
        "integer_overflow": 22,
        "null_pointer": 12,
        "total": 34
      },
      "total_patterns": 34,
      "original_address": "https://android.googlesource.com/platform/external/libavc/+/c57fc3703ae2e0d41b1f6580c50015937f2d23c1",
      "discovery_time": "2016-04-18T00:59Z",
      "project_commit_id": "external@libavc/c57fc3703ae2e0d41b1f6580c50015937f2d23c1",
      "extraction_time": "2025-08-31T15:41:49.190702",
      "label": 1,
      "vulnerability_type": "buffer_overflow",
      "difficulty_level": "advanced",
      "risk_factors": [
        "system_crash",
        "memory_corruption",
        "arbitrary_code_execution"
      ],
      "attack_vectors": [
        "memory_manipulation",
        "malicious_input",
        "code_analysis",
        "buffer_overflow",
        "reverse_engineering",
        "fuzzing"
      ],
      "mitigation_strategies": [
        "safe_string_functions",
        "dynamic_analysis",
        "code_review",
        "static_analysis",
        "memory_safety_checks",
        "input_validation",
        "fuzzing",
        "bounds_checking",
        "secure_coding_practices"
      ],
      "code_differences": {
        "has_differences": true,
        "source_lines": 2,
        "target_lines": 2,
        "character_differences": 3896,
        "similarity_percentage": 10.476190476190476
      },
      "vulnerability_location": {
        "vulnerability_present": true,
        "fix_applied": true,
        "code_changed": true,
        "estimated_lines_changed": 0
      }
    },
    {
      "cve_id": "CVE-2015-4002",
      "cwe_id": "CWE-119",
      "cwe_name": "Buffer Overflow",
      "project": "torvalds",
      "severity": "critical",
      "weaponization_score": 7.0,
      "is_critical": true,
      "is_weaponizable": true,
      "is_high_priority_project": false,
      "vulnerable_code": "CWE-119 void oz_usb_rx ( struct oz_pd * pd , struct oz_elt * elt ) { struct oz_usb_hdr * usb_hdr = ( struct oz_usb_hdr * ) ( elt + 1 ) ; struct oz_usb_ctx * usb_ctx ; spin_lock_bh ( & pd -> app_lock [ OZ_APPID_USB ] ) ; usb_ctx = ( struct oz_usb_ctx * ) pd -> app_ctx [ OZ_APPID_USB ] ; if ( usb_ctx ) oz_usb_get ( usb_ctx ) ; spin_unlock_bh ( & pd -> app_lock [ OZ_APPID_USB ] ) ; if ( usb_ctx == NULL ) return ; if ( usb_ctx -> stopped ) goto done ; if ( usb_hdr -> elt_seq_num != 0 ) { if ( ( ( usb_ctx -> rx_seq_num - usb_hdr -> elt_seq_num ) & 0x80 ) == 0 ) goto done ; } usb_ctx -> rx_seq_num = usb_hdr -> elt_seq_num ; switch ( usb_hdr -> type ) { case OZ_GET_DESC_RSP : { struct oz_get_desc_rsp * body = ( struct oz_get_desc_rsp * ) usb_hdr ; <S2SV_StartBug> int data_len = elt -> length - <S2SV_EndBug> <S2SV_StartBug> sizeof ( struct oz_get_desc_rsp ) + 1 ; <S2SV_EndBug> u16 offs = le16_to_cpu ( get_unaligned ( & body -> offset ) ) ; u16 total_size = le16_to_cpu ( get_unaligned ( & body -> total_size ) ) ; oz_dbg ( ON , \"USB_REQ_GET_DESCRIPTOR<S2SV_blank>-<S2SV_blank>cnf\\\\n\" ) ; oz_hcd_get_desc_cnf ( usb_ctx -> hport , body -> req_id , body -> rcode , body -> data , data_len , offs , total_size ) ; } break ; case OZ_SET_CONFIG_RSP : { struct oz_set_config_rsp * body = ( struct oz_set_config_rsp * ) usb_hdr ; oz_hcd_control_cnf ( usb_ctx -> hport , body -> req_id , body -> rcode , NULL , 0 ) ; } break ; case OZ_SET_INTERFACE_RSP : { struct oz_set_interface_rsp * body = ( struct oz_set_interface_rsp * ) usb_hdr ; oz_hcd_control_cnf ( usb_ctx -> hport , body -> req_id , body -> rcode , NULL , 0 ) ; } break ; case OZ_VENDOR_CLASS_RSP : { struct oz_vendor_class_rsp * body = ( struct oz_vendor_class_rsp * ) usb_hdr ; oz_hcd_control_cnf ( usb_ctx -> hport , body -> req_id , body -> rcode , body -> data , elt -> length - sizeof ( struct oz_vendor_class_rsp ) + 1 ) ; } break ; case OZ_USB_ENDPOINT_DATA : oz_usb_handle_ep_data ( usb_ctx , usb_hdr , elt -> length ) ; break ; } done : oz_usb_put ( usb_ctx ) ; }\n",
      "fixed_code": "<S2SV_ModStart> ) usb_hdr ; u16 offs , total_size ; u8 data_len ; if ( elt -> length < sizeof ( struct oz_get_desc_rsp ) - 1 ) break ; <S2SV_ModEnd> data_len = elt <S2SV_ModStart> -> length - ( <S2SV_ModStart> ( struct oz_get_desc_rsp ) - 1 ) ; offs = le16_to_cpu ( get_unaligned ( & body -> offset ) ) ; total_size = le16_to_cpu ( get_unaligned ( & body -> total_size ) ) ; oz_dbg ( ON , \"USB_REQ_GET_DESCRIPTOR<S2SV_blank>-<S2SV_blank>cnf\\\\n\" ) ; oz_hcd_get_desc_cnf ( usb_ctx -> hport , body -> req_id , body -> rcode , body -> data , data_len , offs , total_size ) ; } break ; case OZ_SET_CONFIG_RSP : { struct oz_set_config_rsp * body = ( struct oz_set_config_rsp * ) usb_hdr ; oz_hcd_control_cnf ( usb_ctx -> hport , body -> req_id , body -> rcode , NULL , 0 ) ; } break ; case OZ_SET_INTERFACE_RSP : { struct oz_set_interface_rsp * body = ( struct oz_set_interface_rsp * ) usb_hdr ; oz_hcd_control_cnf ( usb_ctx -> hport , body -> req_id , body -> rcode , NULL , 0 ) ; } break ; case OZ_VENDOR_CLASS_RSP : { struct oz_vendor_class_rsp * body = ( struct oz_vendor_class_rsp * ) usb_hdr ; oz_hcd_control_cnf ( usb_ctx -> hport , body -> req_id , body -> rcode , body -> data , elt -> length - sizeof ( struct oz_vendor_class_rsp <S2SV_ModStart> ) + 1 <S2SV_ModEnd> ) ; }\n",
      "source_code_length": 2033,
      "target_code_length": 1276,
      "vulnerability_patterns": {
        "null_pointer": 30,
        "total": 30
      },
      "total_patterns": 30,
      "original_address": "https://github.com/torvalds/linux/commit/d114b9fe78c8d6fc6e70808c2092aa307c36dc8e",
      "discovery_time": "2015-06-07T23:59Z",
      "project_commit_id": "torvalds@linux/d114b9fe78c8d6fc6e70808c2092aa307c36dc8e",
      "extraction_time": "2025-08-31T15:41:49.190744",
      "label": 1,
      "vulnerability_type": "buffer_overflow",
      "difficulty_level": "advanced",
      "risk_factors": [
        "system_crash",
        "memory_corruption",
        "arbitrary_code_execution"
      ],
      "attack_vectors": [
        "memory_manipulation",
        "malicious_input",
        "code_analysis",
        "buffer_overflow",
        "reverse_engineering",
        "fuzzing"
      ],
      "mitigation_strategies": [
        "safe_string_functions",
        "dynamic_analysis",
        "code_review",
        "static_analysis",
        "memory_safety_checks",
        "input_validation",
        "fuzzing",
        "bounds_checking",
        "secure_coding_practices"
      ],
      "code_differences": {
        "has_differences": true,
        "source_lines": 2,
        "target_lines": 2,
        "character_differences": 757,
        "similarity_percentage": 56.32183908045977
      },
      "vulnerability_location": {
        "vulnerability_present": true,
        "fix_applied": true,
        "code_changed": true,
        "estimated_lines_changed": 0
      }
    },
    {
      "cve_id": "CVE-2011-3346",
      "cwe_id": "CWE-119",
      "cwe_name": "Buffer Overflow",
      "project": "bonzini",
      "severity": "critical",
      "weaponization_score": 7.0,
      "is_critical": true,
      "is_weaponizable": true,
      "is_high_priority_project": false,
      "vulnerable_code": "CWE-119 static void scsi_free_request ( SCSIRequest * req ) { SCSIDiskReq * r = DO_UPCAST ( SCSIDiskReq , req , req ) ; <S2SV_StartBug> qemu_vfree ( r -> iov . iov_base ) ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug>\n",
      "fixed_code": "<S2SV_ModStart> req ) ; if ( r -> iov . iov_base ) { <S2SV_ModStart> ) ; } }\n",
      "source_code_length": 219,
      "target_code_length": 77,
      "vulnerability_patterns": {
        "null_pointer": 23,
        "total": 23
      },
      "total_patterns": 23,
      "original_address": "https://github.com/bonzini/qemu/commit/7285477ab11831b1cf56e45878a89170dd06d9b9",
      "discovery_time": "2014-04-01T06:35Z",
      "project_commit_id": "bonzini@qemu/7285477ab11831b1cf56e45878a89170dd06d9b9",
      "extraction_time": "2025-08-31T15:41:49.190780",
      "label": 1,
      "vulnerability_type": "buffer_overflow",
      "difficulty_level": "advanced",
      "risk_factors": [
        "system_crash",
        "memory_corruption",
        "arbitrary_code_execution"
      ],
      "attack_vectors": [
        "memory_manipulation",
        "malicious_input",
        "code_analysis",
        "buffer_overflow",
        "reverse_engineering",
        "fuzzing"
      ],
      "mitigation_strategies": [
        "safe_string_functions",
        "dynamic_analysis",
        "code_review",
        "static_analysis",
        "memory_safety_checks",
        "input_validation",
        "fuzzing",
        "bounds_checking",
        "secure_coding_practices"
      ],
      "code_differences": {
        "has_differences": true,
        "source_lines": 2,
        "target_lines": 2,
        "character_differences": 142,
        "similarity_percentage": 42.30769230769231
      },
      "vulnerability_location": {
        "vulnerability_present": true,
        "fix_applied": true,
        "code_changed": true,
        "estimated_lines_changed": 0
      }
    },
    {
      "cve_id": "CVE-2016-1621",
      "cwe_id": "CWE-119",
      "cwe_name": "Buffer Overflow",
      "project": "external",
      "severity": "critical",
      "weaponization_score": 7.0,
      "is_critical": true,
      "is_weaponizable": true,
      "is_high_priority_project": false,
      "vulnerable_code": "CWE-119 int main ( int argc , char * * argv ) { int frame_cnt = 0 ; FILE * outfile = NULL ; vpx_codec_ctx_t codec ; const VpxInterface * decoder = NULL ; VpxVideoReader * reader = NULL ; const VpxVideoInfo * info = NULL ; int n = 0 ; int m = 0 ; int is_range = 0 ; char * nptr = NULL ; exec_name = argv [ 0 ] ; if ( argc != 4 ) die ( \"Invalid<S2SV_blank>number<S2SV_blank>of<S2SV_blank>arguments.\" ) ; reader = vpx_video_reader_open ( argv [ 1 ] ) ; if ( ! reader ) die ( \"Failed<S2SV_blank>to<S2SV_blank>open<S2SV_blank>%s<S2SV_blank>for<S2SV_blank>reading.\" , argv [ 1 ] ) ; if ( ! ( outfile = fopen ( argv [ 2 ] , \"wb\" ) ) ) die ( \"Failed<S2SV_blank>to<S2SV_blank>open<S2SV_blank>%s<S2SV_blank>for<S2SV_blank>writing.\" , argv [ 2 ] ) ; n = strtol ( argv [ 3 ] , & nptr , 0 ) ; m = strtol ( nptr + 1 , NULL , 0 ) ; is_range = ( * nptr == '-' ) ; if ( ! n || ! m || ( * nptr != '-' && * nptr != '/' ) ) die ( \"Couldn\\'t<S2SV_blank>parse<S2SV_blank>pattern<S2SV_blank>%s.\\\\n\" , argv [ 3 ] ) ; info = vpx_video_reader_get_info ( reader ) ; decoder = get_vpx_decoder_by_fourcc ( info -> codec_fourcc ) ; if ( ! decoder ) die ( \"Unknown<S2SV_blank>input<S2SV_blank>codec.\" ) ; <S2SV_StartBug> printf ( \"Using<S2SV_blank>%s\\\\n\" , vpx_codec_iface_name ( decoder -> interface ( ) ) ) ; <S2SV_EndBug> <S2SV_StartBug> if ( vpx_codec_dec_init ( & codec , decoder -> interface ( ) , NULL , 0 ) ) <S2SV_EndBug> die_codec ( & codec , \"Failed<S2SV_blank>to<S2SV_blank>initialize<S2SV_blank>decoder.\" ) ; while ( vpx_video_reader_read_frame ( reader ) ) { vpx_codec_iter_t iter = NULL ; vpx_image_t * img = NULL ; size_t frame_size = 0 ; int skip ; const unsigned char * frame = vpx_video_reader_get_frame ( reader , & frame_size ) ; if ( vpx_codec_decode ( & codec , frame , ( unsigned int ) frame_size , NULL , 0 ) ) die_codec ( & codec , \"Failed<S2SV_blank>to<S2SV_blank>decode<S2SV_blank>frame.\" ) ; ++ frame_cnt ; skip = ( is_range && frame_cnt >= n && frame_cnt <= m ) || ( ! is_range && m - ( frame_cnt - 1 ) % m <= n ) ; if ( ! skip ) { putc ( '.' , stdout ) ; while ( ( img = vpx_codec_get_frame ( & codec , & iter ) ) != NULL ) vpx_img_write ( img , outfile ) ; } else { putc ( 'X' , stdout ) ; } fflush ( stdout ) ; } printf ( \"Processed<S2SV_blank>%d<S2SV_blank>frames.\\\\n\" , frame_cnt ) ; if ( vpx_codec_destroy ( & codec ) ) die_codec ( & codec , \"Failed<S2SV_blank>to<S2SV_blank>destroy<S2SV_blank>codec.\" ) ; printf ( \"Play:<S2SV_blank>ffplay<S2SV_blank>-f<S2SV_blank>rawvideo<S2SV_blank>-pix_fmt<S2SV_blank>yuv420p<S2SV_blank>-s<S2SV_blank>%dx%d<S2SV_blank>%s\\\\n\" , info -> frame_width , info -> frame_height , argv [ 2 ] ) ; vpx_video_reader_close ( reader ) ; fclose ( outfile ) ; return EXIT_SUCCESS ; }\n",
      "fixed_code": "<S2SV_ModStart> ( decoder -> codec_interface <S2SV_ModEnd> ( ) ) <S2SV_ModStart> , decoder -> codec_interface <S2SV_ModEnd> ( ) ,\n",
      "source_code_length": 2710,
      "target_code_length": 130,
      "vulnerability_patterns": {
        "integer_overflow": 1,
        "format_string": 3,
        "null_pointer": 8,
        "total": 12
      },
      "total_patterns": 12,
      "original_address": "https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426",
      "discovery_time": "2016-03-12T21:59Z",
      "project_commit_id": "external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426",
      "extraction_time": "2025-08-31T15:41:49.190789",
      "label": 1,
      "vulnerability_type": "buffer_overflow",
      "difficulty_level": "advanced",
      "risk_factors": [
        "system_crash",
        "memory_corruption",
        "arbitrary_code_execution"
      ],
      "attack_vectors": [
        "memory_manipulation",
        "malicious_input",
        "code_analysis",
        "buffer_overflow",
        "reverse_engineering",
        "fuzzing"
      ],
      "mitigation_strategies": [
        "safe_string_functions",
        "dynamic_analysis",
        "code_review",
        "static_analysis",
        "memory_safety_checks",
        "input_validation",
        "fuzzing",
        "bounds_checking",
        "secure_coding_practices"
      ],
      "code_differences": {
        "has_differences": true,
        "source_lines": 2,
        "target_lines": 2,
        "character_differences": 2580,
        "similarity_percentage": 4.464285714285714
      },
      "vulnerability_location": {
        "vulnerability_present": true,
        "fix_applied": true,
        "code_changed": true,
        "estimated_lines_changed": 0
      }
    },
    {
      "cve_id": "CVE-2015-1421",
      "cwe_id": "CWE-000",
      "cwe_name": "Unknown/Uncategorized",
      "project": "torvalds",
      "severity": "critical",
      "weaponization_score": 7.0,
      "is_critical": true,
      "is_weaponizable": true,
      "is_high_priority_project": false,
      "vulnerable_code": "CWE-000 void sctp_assoc_update ( struct sctp_association * asoc , struct sctp_association * new ) { struct sctp_transport * trans ; struct list_head * pos , * temp ; asoc -> c = new -> c ; asoc -> peer . rwnd = new -> peer . rwnd ; asoc -> peer . sack_needed = new -> peer . sack_needed ; asoc -> peer . auth_capable = new -> peer . auth_capable ; asoc -> peer . i = new -> peer . i ; sctp_tsnmap_init ( & asoc -> peer . tsn_map , SCTP_TSN_MAP_INITIAL , asoc -> peer . i . initial_tsn , GFP_ATOMIC ) ; list_for_each_safe ( pos , temp , & asoc -> peer . transport_addr_list ) { trans = list_entry ( pos , struct sctp_transport , transports ) ; if ( ! sctp_assoc_lookup_paddr ( new , & trans -> ipaddr ) ) { sctp_assoc_rm_peer ( asoc , trans ) ; continue ; } if ( asoc -> state >= SCTP_STATE_ESTABLISHED ) sctp_transport_reset ( trans ) ; } if ( asoc -> state >= SCTP_STATE_ESTABLISHED ) { asoc -> next_tsn = new -> next_tsn ; asoc -> ctsn_ack_point = new -> ctsn_ack_point ; asoc -> adv_peer_ack_point = new -> adv_peer_ack_point ; sctp_ssnmap_clear ( asoc -> ssnmap ) ; sctp_ulpq_flush ( & asoc -> ulpq ) ; asoc -> overall_error_count = 0 ; } else { list_for_each_entry ( trans , & new -> peer . transport_addr_list , transports ) { if ( ! sctp_assoc_lookup_paddr ( asoc , & trans -> ipaddr ) ) sctp_assoc_add_peer ( asoc , & trans -> ipaddr , GFP_ATOMIC , trans -> state ) ; } asoc -> ctsn_ack_point = asoc -> next_tsn - 1 ; asoc -> adv_peer_ack_point = asoc -> ctsn_ack_point ; if ( ! asoc -> ssnmap ) { asoc -> ssnmap = new -> ssnmap ; new -> ssnmap = NULL ; } if ( ! asoc -> assoc_id ) { sctp_assoc_set_id ( asoc , GFP_ATOMIC ) ; } } kfree ( asoc -> peer . peer_random ) ; asoc -> peer . peer_random = new -> peer . peer_random ; new -> peer . peer_random = NULL ; kfree ( asoc -> peer . peer_chunks ) ; asoc -> peer . peer_chunks = new -> peer . peer_chunks ; new -> peer . peer_chunks = NULL ; kfree ( asoc -> peer . peer_hmacs ) ; asoc -> peer . peer_hmacs = new -> peer . peer_hmacs ; new -> peer . peer_hmacs = NULL ; <S2SV_StartBug> sctp_auth_key_put ( asoc -> asoc_shared_key ) ; <S2SV_EndBug> sctp_auth_asoc_init_active_key ( asoc , GFP_ATOMIC ) ; }\n",
      "fixed_code": "<S2SV_ModStart> = NULL ; <S2SV_ModEnd> sctp_auth_asoc_init_active_key ( asoc\n",
      "source_code_length": 2162,
      "target_code_length": 77,
      "vulnerability_patterns": {
        "use_after_free": 22,
        "null_pointer": 51,
        "total": 73
      },
      "total_patterns": 73,
      "original_address": "https://github.com/torvalds/linux/commit/600ddd6825543962fb807884169e57b580dba208",
      "discovery_time": "2015-03-16T10:59Z",
      "project_commit_id": "torvalds@linux/600ddd6825543962fb807884169e57b580dba208",
      "extraction_time": "2025-08-31T15:41:49.190815",
      "label": 1,
      "vulnerability_type": "unknown/uncategorized",
      "difficulty_level": "advanced",
      "risk_factors": [
        "use_after_free"
      ],
      "attack_vectors": [
        "fuzzing",
        "code_analysis",
        "reverse_engineering"
      ],
      "mitigation_strategies": [
        "dynamic_analysis",
        "static_analysis",
        "fuzzing",
        "code_review",
        "secure_coding_practices"
      ],
      "code_differences": {
        "has_differences": true,
        "source_lines": 2,
        "target_lines": 2,
        "character_differences": 2085,
        "similarity_percentage": 7.894736842105263
      },
      "vulnerability_location": {
        "vulnerability_present": true,
        "fix_applied": true,
        "code_changed": true,
        "estimated_lines_changed": 0
      }
    },
    {
      "cve_id": "CVE-2017-14039",
      "cwe_id": "CWE-787",
      "cwe_name": "Out-of-bounds Write",
      "project": "uclouvain",
      "severity": "critical",
      "weaponization_score": 7.0,
      "is_critical": true,
      "is_weaponizable": true,
      "is_high_priority_project": false,
      "vulnerable_code": "CWE-787 static OPJ_BOOL opj_j2k_write_sod ( opj_j2k_t * p_j2k , opj_tcd_t * p_tile_coder , OPJ_BYTE * p_data , OPJ_UINT32 * p_data_written , OPJ_UINT32 p_total_data_size , const opj_stream_private_t * p_stream , opj_event_mgr_t * p_manager ) { opj_codestream_info_t * l_cstr_info = 00 ; OPJ_UINT32 l_remaining_data ; assert ( p_j2k != 00 ) ; assert ( p_manager != 00 ) ; assert ( p_stream != 00 ) ; OPJ_UNUSED ( p_stream ) ; <S2SV_StartBug> opj_write_bytes ( p_data , J2K_MS_SOD , <S2SV_EndBug> 2 ) ; p_data += 2 ; l_remaining_data = p_total_data_size - 4 ; p_tile_coder -> tp_num = p_j2k -> m_specific_param . m_encoder . m_current_poc_tile_part_number ; p_tile_coder -> cur_tp_num = p_j2k -> m_specific_param . m_encoder . m_current_tile_part_number ; # ifdef USE_JPWL assert ( 0 && \"TODO\" ) ; # endif if ( p_j2k -> m_specific_param . m_encoder . m_current_tile_part_number == 0 ) { p_tile_coder -> tcd_image -> tiles -> packno = 0 ; if ( l_cstr_info ) { l_cstr_info -> packno = 0 ; } } * p_data_written = 0 ; if ( ! opj_tcd_encode_tile ( p_tile_coder , p_j2k -> m_current_tile_number , p_data , p_data_written , l_remaining_data , l_cstr_info , p_manager ) ) { opj_event_msg ( p_manager , EVT_ERROR , \"Cannot<S2SV_blank>encode<S2SV_blank>tile\\\\n\" ) ; return OPJ_FALSE ; } * p_data_written += 2 ; return OPJ_TRUE ; }\n",
      "fixed_code": "<S2SV_ModStart> p_stream ) ; if ( p_total_data_size < 4 ) { opj_event_msg ( p_manager , EVT_ERROR , \"Not<S2SV_blank>enough<S2SV_blank>bytes<S2SV_blank>in<S2SV_blank>output<S2SV_blank>buffer<S2SV_blank>to<S2SV_blank>write<S2SV_blank>SOD<S2SV_blank>marker\\\\n\" ) ; return OPJ_FALSE ; }\n",
      "source_code_length": 1319,
      "target_code_length": 283,
      "vulnerability_patterns": {
        "integer_overflow": 6,
        "null_pointer": 4,
        "total": 10
      },
      "total_patterns": 10,
      "original_address": "https://github.com/uclouvain/openjpeg/commit/c535531f03369623b9b833ef41952c62257b507e",
      "discovery_time": "2017-08-30T22:29Z",
      "project_commit_id": "uclouvain@openjpeg/c535531f03369623b9b833ef41952c62257b507e",
      "extraction_time": "2025-08-31T15:41:49.190841",
      "label": 1,
      "vulnerability_type": "out-of-bounds_write",
      "difficulty_level": "advanced",
      "risk_factors": [
        "system_crash",
        "memory_corruption",
        "arbitrary_code_execution"
      ],
      "attack_vectors": [
        "memory_manipulation",
        "malicious_input",
        "code_analysis",
        "buffer_overflow",
        "reverse_engineering",
        "fuzzing"
      ],
      "mitigation_strategies": [
        "safe_string_functions",
        "dynamic_analysis",
        "code_review",
        "static_analysis",
        "memory_safety_checks",
        "input_validation",
        "fuzzing",
        "bounds_checking",
        "secure_coding_practices"
      ],
      "code_differences": {
        "has_differences": true,
        "source_lines": 2,
        "target_lines": 2,
        "character_differences": 1036,
        "similarity_percentage": 20.54794520547945
      },
      "vulnerability_location": {
        "vulnerability_present": true,
        "fix_applied": true,
        "code_changed": true,
        "estimated_lines_changed": 0
      }
    },
    {
      "cve_id": "CVE-2016-4303",
      "cwe_id": "CWE-119",
      "cwe_name": "Buffer Overflow",
      "project": "esnet",
      "severity": "critical",
      "weaponization_score": 7.0,
      "is_critical": true,
      "is_weaponizable": true,
      "is_high_priority_project": false,
      "vulnerable_code": "CWE-119 cJSON * cJSON_CreateArray ( void ) { cJSON * item = cJSON_New_Item ( ) ; if ( item ) item -> type = cJSON_Array ; return item ; }\n",
      "fixed_code": "\n",
      "source_code_length": 138,
      "target_code_length": 1,
      "vulnerability_patterns": {
        "buffer_overflow": 1,
        "null_pointer": 4,
        "total": 5
      },
      "total_patterns": 5,
      "original_address": "https://github.com/esnet/iperf/commit/91f2fa59e8ed80dfbf400add0164ee0e508e412a",
      "discovery_time": "2016-09-26T14:59Z",
      "project_commit_id": "esnet@iperf/91f2fa59e8ed80dfbf400add0164ee0e508e412a",
      "extraction_time": "2025-08-31T15:41:49.190862",
      "label": 1,
      "vulnerability_type": "buffer_overflow",
      "difficulty_level": "advanced",
      "risk_factors": [
        "system_crash",
        "memory_corruption",
        "buffer_overflow",
        "arbitrary_code_execution"
      ],
      "attack_vectors": [
        "memory_manipulation",
        "malicious_input",
        "code_analysis",
        "buffer_overflow",
        "reverse_engineering",
        "fuzzing"
      ],
      "mitigation_strategies": [
        "safe_string_functions",
        "dynamic_analysis",
        "code_review",
        "static_analysis",
        "memory_safety_checks",
        "input_validation",
        "fuzzing",
        "bounds_checking",
        "secure_coding_practices"
      ],
      "code_differences": {
        "has_differences": true,
        "source_lines": 2,
        "target_lines": 2,
        "character_differences": 137,
        "similarity_percentage": 0.0
      },
      "vulnerability_location": {
        "vulnerability_present": true,
        "fix_applied": true,
        "code_changed": true,
        "estimated_lines_changed": 0
      }
    },
    {
      "cve_id": "CVE-2017-16995",
      "cwe_id": "CWE-119",
      "cwe_name": "Buffer Overflow",
      "project": "torvalds",
      "severity": "critical",
      "weaponization_score": 7.0,
      "is_critical": true,
      "is_weaponizable": true,
      "is_high_priority_project": false,
      "vulnerable_code": "CWE-119 static int check_alu_op ( struct bpf_verifier_env * env , struct bpf_insn * insn ) { struct bpf_reg_state * regs = cur_regs ( env ) ; u8 opcode = BPF_OP ( insn -> code ) ; int err ; if ( opcode == BPF_END || opcode == BPF_NEG ) { if ( opcode == BPF_NEG ) { if ( BPF_SRC ( insn -> code ) != 0 || insn -> src_reg != BPF_REG_0 || insn -> off != 0 || insn -> imm != 0 ) { verbose ( env , \"BPF_NEG<S2SV_blank>uses<S2SV_blank>reserved<S2SV_blank>fields\\\\n\" ) ; return - EINVAL ; } } else { if ( insn -> src_reg != BPF_REG_0 || insn -> off != 0 || ( insn -> imm != 16 && insn -> imm != 32 && insn -> imm != 64 ) || BPF_CLASS ( insn -> code ) == BPF_ALU64 ) { verbose ( env , \"BPF_END<S2SV_blank>uses<S2SV_blank>reserved<S2SV_blank>fields\\\\n\" ) ; return - EINVAL ; } } err = check_reg_arg ( env , insn -> dst_reg , SRC_OP ) ; if ( err ) return err ; if ( is_pointer_value ( env , insn -> dst_reg ) ) { verbose ( env , \"R%d<S2SV_blank>pointer<S2SV_blank>arithmetic<S2SV_blank>prohibited\\\\n\" , insn -> dst_reg ) ; return - EACCES ; } err = check_reg_arg ( env , insn -> dst_reg , DST_OP ) ; if ( err ) return err ; } else if ( opcode == BPF_MOV ) { if ( BPF_SRC ( insn -> code ) == BPF_X ) { if ( insn -> imm != 0 || insn -> off != 0 ) { verbose ( env , \"BPF_MOV<S2SV_blank>uses<S2SV_blank>reserved<S2SV_blank>fields\\\\n\" ) ; return - EINVAL ; } err = check_reg_arg ( env , insn -> src_reg , SRC_OP ) ; if ( err ) return err ; } else { if ( insn -> src_reg != BPF_REG_0 || insn -> off != 0 ) { verbose ( env , \"BPF_MOV<S2SV_blank>uses<S2SV_blank>reserved<S2SV_blank>fields\\\\n\" ) ; return - EINVAL ; } } err = check_reg_arg ( env , insn -> dst_reg , DST_OP ) ; if ( err ) return err ; if ( BPF_SRC ( insn -> code ) == BPF_X ) { if ( BPF_CLASS ( insn -> code ) == BPF_ALU64 ) { regs [ insn -> dst_reg ] = regs [ insn -> src_reg ] ; regs [ insn -> dst_reg ] . live |= REG_LIVE_WRITTEN ; } else { if ( is_pointer_value ( env , insn -> src_reg ) ) { verbose ( env , \"R%d<S2SV_blank>partial<S2SV_blank>copy<S2SV_blank>of<S2SV_blank>pointer\\\\n\" , insn -> src_reg ) ; return - EACCES ; } mark_reg_unknown ( env , regs , insn -> dst_reg ) ; regs [ insn -> dst_reg ] . var_off = tnum_cast ( regs [ insn -> dst_reg ] . var_off , 4 ) ; __update_reg_bounds ( & regs [ insn -> dst_reg ] ) ; } } else { regs [ insn -> dst_reg ] . type = SCALAR_VALUE ; <S2SV_StartBug> __mark_reg_known ( regs + insn -> dst_reg , insn -> imm ) ; <S2SV_EndBug> } } else if ( opcode > BPF_END ) { verbose ( env , \"invalid<S2SV_blank>BPF_ALU<S2SV_blank>opcode<S2SV_blank>%x\\\\n\" , opcode ) ; return - EINVAL ; } else { if ( BPF_SRC ( insn -> code ) == BPF_X ) { if ( insn -> imm != 0 || insn -> off != 0 ) { verbose ( env , \"BPF_ALU<S2SV_blank>uses<S2SV_blank>reserved<S2SV_blank>fields\\\\n\" ) ; return - EINVAL ; } err = check_reg_arg ( env , insn -> src_reg , SRC_OP ) ; if ( err ) return err ; } else { if ( insn -> src_reg != BPF_REG_0 || insn -> off != 0 ) { verbose ( env , \"BPF_ALU<S2SV_blank>uses<S2SV_blank>reserved<S2SV_blank>fields\\\\n\" ) ; return - EINVAL ; } } err = check_reg_arg ( env , insn -> dst_reg , SRC_OP ) ; if ( err ) return err ; if ( ( opcode == BPF_MOD || opcode == BPF_DIV ) && BPF_SRC ( insn -> code ) == BPF_K && insn -> imm == 0 ) { verbose ( env , \"div<S2SV_blank>by<S2SV_blank>zero\\\\n\" ) ; return - EINVAL ; } if ( ( opcode == BPF_LSH || opcode == BPF_RSH || opcode == BPF_ARSH ) && BPF_SRC ( insn -> code ) == BPF_K ) { int size = BPF_CLASS ( insn -> code ) == BPF_ALU64 ? 64 : 32 ; if ( insn -> imm < 0 || insn -> imm >= size ) { verbose ( env , \"invalid<S2SV_blank>shift<S2SV_blank>%d\\\\n\" , insn -> imm ) ; return - EINVAL ; } } err = check_reg_arg ( env , insn -> dst_reg , DST_OP_NO_MARK ) ; if ( err ) return err ; return adjust_reg_min_max_vals ( env , insn ) ; } return 0 ; }\n",
      "fixed_code": "<S2SV_ModStart> = SCALAR_VALUE ; if ( BPF_CLASS ( insn -> code ) == BPF_ALU64 ) { <S2SV_ModStart> -> dst_reg , insn -> imm ) ; } else { __mark_reg_known ( regs + insn -> dst_reg , ( u32 ) insn -> imm ) ; } <S2SV_ModEnd> } } else\n",
      "source_code_length": 3775,
      "target_code_length": 229,
      "vulnerability_patterns": {
        "null_pointer": 51,
        "total": 51
      },
      "total_patterns": 51,
      "original_address": "https://github.com/torvalds/linux/commit/95a762e2c8c942780948091f8f2a4f32fce1ac6f",
      "discovery_time": "2017-12-27T17:08Z",
      "project_commit_id": "torvalds@linux/95a762e2c8c942780948091f8f2a4f32fce1ac6f",
      "extraction_time": "2025-08-31T15:41:49.190878",
      "label": 1,
      "vulnerability_type": "buffer_overflow",
      "difficulty_level": "advanced",
      "risk_factors": [
        "system_crash",
        "memory_corruption",
        "arbitrary_code_execution"
      ],
      "attack_vectors": [
        "memory_manipulation",
        "malicious_input",
        "code_analysis",
        "buffer_overflow",
        "reverse_engineering",
        "fuzzing"
      ],
      "mitigation_strategies": [
        "safe_string_functions",
        "dynamic_analysis",
        "code_review",
        "static_analysis",
        "memory_safety_checks",
        "input_validation",
        "fuzzing",
        "bounds_checking",
        "secure_coding_practices"
      ],
      "code_differences": {
        "has_differences": true,
        "source_lines": 2,
        "target_lines": 2,
        "character_differences": 3546,
        "similarity_percentage": 20.792079207920793
      },
      "vulnerability_location": {
        "vulnerability_present": true,
        "fix_applied": true,
        "code_changed": true,
        "estimated_lines_changed": 0
      }
    },
    {
      "cve_id": "CVE-2015-4036",
      "cwe_id": "CWE-119",
      "cwe_name": "Buffer Overflow",
      "project": "torvalds",
      "severity": "critical",
      "weaponization_score": 7.0,
      "is_critical": true,
      "is_weaponizable": true,
      "is_high_priority_project": false,
      "vulnerable_code": "CWE-119 static void vhost_scsi_send_evt ( struct vhost_scsi * vs , struct vhost_scsi_tpg * tpg , struct se_lun * lun , u32 event , u32 reason ) { struct vhost_scsi_evt * evt ; evt = vhost_scsi_allocate_evt ( vs , event , reason ) ; if ( ! evt ) return ; if ( tpg && lun ) { evt -> event . lun [ 0 ] = 0x01 ; <S2SV_StartBug> evt -> event . lun [ 1 ] = tpg -> tport_tpgt & 0xFF ; <S2SV_EndBug> if ( lun -> unpacked_lun >= 256 ) evt -> event . lun [ 2 ] = lun -> unpacked_lun >> 8 | 0x40 ; evt -> event . lun [ 3 ] = lun -> unpacked_lun & 0xFF ; } llist_add ( & evt -> list , & vs -> vs_event_list ) ; vhost_work_queue ( & vs -> dev , & vs -> vs_event_work ) ; }\n",
      "fixed_code": "<S2SV_ModStart> tpg -> tport_tpgt <S2SV_ModEnd> ; if (\n",
      "source_code_length": 660,
      "target_code_length": 55,
      "vulnerability_patterns": {
        "null_pointer": 14,
        "total": 14
      },
      "total_patterns": 14,
      "original_address": "https://github.com/torvalds/linux/commit/59c816c1f24df0204e01851431d3bab3eb76719c",
      "discovery_time": "2015-08-31T20:59Z",
      "project_commit_id": "torvalds@linux/59c816c1f24df0204e01851431d3bab3eb76719c",
      "extraction_time": "2025-08-31T15:41:49.190927",
      "label": 1,
      "vulnerability_type": "buffer_overflow",
      "difficulty_level": "advanced",
      "risk_factors": [
        "system_crash",
        "memory_corruption",
        "arbitrary_code_execution"
      ],
      "attack_vectors": [
        "memory_manipulation",
        "malicious_input",
        "code_analysis",
        "buffer_overflow",
        "reverse_engineering",
        "fuzzing"
      ],
      "mitigation_strategies": [
        "safe_string_functions",
        "dynamic_analysis",
        "code_review",
        "static_analysis",
        "memory_safety_checks",
        "input_validation",
        "fuzzing",
        "bounds_checking",
        "secure_coding_practices"
      ],
      "code_differences": {
        "has_differences": true,
        "source_lines": 2,
        "target_lines": 2,
        "character_differences": 605,
        "similarity_percentage": 10.344827586206897
      },
      "vulnerability_location": {
        "vulnerability_present": true,
        "fix_applied": true,
        "code_changed": true,
        "estimated_lines_changed": 0
      }
    },
    {
      "cve_id": "CVE-2016-1621",
      "cwe_id": "CWE-119",
      "cwe_name": "Buffer Overflow",
      "project": "external",
      "severity": "critical",
      "weaponization_score": 7.0,
      "is_critical": true,
      "is_weaponizable": true,
      "is_high_priority_project": false,
      "vulnerable_code": "CWE-119 int main ( int argc , char * * argv ) { int frame_cnt = 0 ; FILE * outfile = NULL ; vpx_codec_ctx_t codec ; const VpxInterface * decoder = NULL ; VpxVideoReader * reader = NULL ; const VpxVideoInfo * info = NULL ; int n = 0 ; int m = 0 ; int is_range = 0 ; char * nptr = NULL ; exec_name = argv [ 0 ] ; if ( argc != 4 ) die ( \"Invalid<S2SV_blank>number<S2SV_blank>of<S2SV_blank>arguments.\" ) ; reader = vpx_video_reader_open ( argv [ 1 ] ) ; if ( ! reader ) die ( \"Failed<S2SV_blank>to<S2SV_blank>open<S2SV_blank>%s<S2SV_blank>for<S2SV_blank>reading.\" , argv [ 1 ] ) ; if ( ! ( outfile = fopen ( argv [ 2 ] , \"wb\" ) ) ) die ( \"Failed<S2SV_blank>to<S2SV_blank>open<S2SV_blank>%s<S2SV_blank>for<S2SV_blank>writing.\" , argv [ 2 ] ) ; n = strtol ( argv [ 3 ] , & nptr , 0 ) ; m = strtol ( nptr + 1 , NULL , 0 ) ; is_range = ( * nptr == '-' ) ; if ( ! n || ! m || ( * nptr != '-' && * nptr != '/' ) ) die ( \"Couldn\\'t<S2SV_blank>parse<S2SV_blank>pattern<S2SV_blank>%s.\\\\n\" , argv [ 3 ] ) ; info = vpx_video_reader_get_info ( reader ) ; decoder = get_vpx_decoder_by_fourcc ( info -> codec_fourcc ) ; if ( ! decoder ) die ( \"Unknown<S2SV_blank>input<S2SV_blank>codec.\" ) ; <S2SV_StartBug> printf ( \"Using<S2SV_blank>%s\\\\n\" , vpx_codec_iface_name ( decoder -> interface ( ) ) ) ; <S2SV_EndBug> <S2SV_StartBug> if ( vpx_codec_dec_init ( & codec , decoder -> interface ( ) , NULL , 0 ) ) <S2SV_EndBug> die_codec ( & codec , \"Failed<S2SV_blank>to<S2SV_blank>initialize<S2SV_blank>decoder.\" ) ; while ( vpx_video_reader_read_frame ( reader ) ) { vpx_codec_iter_t iter = NULL ; vpx_image_t * img = NULL ; size_t frame_size = 0 ; int skip ; const unsigned char * frame = vpx_video_reader_get_frame ( reader , & frame_size ) ; if ( vpx_codec_decode ( & codec , frame , ( unsigned int ) frame_size , NULL , 0 ) ) die_codec ( & codec , \"Failed<S2SV_blank>to<S2SV_blank>decode<S2SV_blank>frame.\" ) ; ++ frame_cnt ; skip = ( is_range && frame_cnt >= n && frame_cnt <= m ) || ( ! is_range && m - ( frame_cnt - 1 ) % m <= n ) ; if ( ! skip ) { putc ( '.' , stdout ) ; while ( ( img = vpx_codec_get_frame ( & codec , & iter ) ) != NULL ) vpx_img_write ( img , outfile ) ; } else { putc ( 'X' , stdout ) ; } fflush ( stdout ) ; } printf ( \"Processed<S2SV_blank>%d<S2SV_blank>frames.\\\\n\" , frame_cnt ) ; if ( vpx_codec_destroy ( & codec ) ) die_codec ( & codec , \"Failed<S2SV_blank>to<S2SV_blank>destroy<S2SV_blank>codec.\" ) ; printf ( \"Play:<S2SV_blank>ffplay<S2SV_blank>-f<S2SV_blank>rawvideo<S2SV_blank>-pix_fmt<S2SV_blank>yuv420p<S2SV_blank>-s<S2SV_blank>%dx%d<S2SV_blank>%s\\\\n\" , info -> frame_width , info -> frame_height , argv [ 2 ] ) ; vpx_video_reader_close ( reader ) ; fclose ( outfile ) ; return EXIT_SUCCESS ; }\n",
      "fixed_code": "<S2SV_ModStart> ( decoder -> codec_interface <S2SV_ModEnd> ( ) ) <S2SV_ModStart> , decoder -> codec_interface <S2SV_ModEnd> ( ) ,\n",
      "source_code_length": 2710,
      "target_code_length": 130,
      "vulnerability_patterns": {
        "null_pointer": 14,
        "total": 14
      },
      "total_patterns": 14,
      "original_address": "https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426",
      "discovery_time": "2016-03-12T21:59Z",
      "project_commit_id": "external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426",
      "extraction_time": "2025-08-31T15:41:49.190940",
      "label": 1,
      "vulnerability_type": "buffer_overflow",
      "difficulty_level": "advanced",
      "risk_factors": [
        "system_crash",
        "memory_corruption",
        "arbitrary_code_execution"
      ],
      "attack_vectors": [
        "memory_manipulation",
        "malicious_input",
        "code_analysis",
        "buffer_overflow",
        "reverse_engineering",
        "fuzzing"
      ],
      "mitigation_strategies": [
        "safe_string_functions",
        "dynamic_analysis",
        "code_review",
        "static_analysis",
        "memory_safety_checks",
        "input_validation",
        "fuzzing",
        "bounds_checking",
        "secure_coding_practices"
      ],
      "code_differences": {
        "has_differences": true,
        "source_lines": 2,
        "target_lines": 2,
        "character_differences": 2580,
        "similarity_percentage": 4.464285714285714
      },
      "vulnerability_location": {
        "vulnerability_present": true,
        "fix_applied": true,
        "code_changed": true,
        "estimated_lines_changed": 0
      }
    },
    {
      "cve_id": "CVE-2016-1621",
      "cwe_id": "CWE-119",
      "cwe_name": "Buffer Overflow",
      "project": "external",
      "severity": "critical",
      "weaponization_score": 7.0,
      "is_critical": true,
      "is_weaponizable": true,
      "is_high_priority_project": false,
      "vulnerable_code": "CWE-119 int main ( int argc , char * * argv ) { int frame_cnt = 0 ; FILE * outfile = NULL ; vpx_codec_ctx_t codec ; const VpxInterface * decoder = NULL ; VpxVideoReader * reader = NULL ; const VpxVideoInfo * info = NULL ; int n = 0 ; int m = 0 ; int is_range = 0 ; char * nptr = NULL ; exec_name = argv [ 0 ] ; if ( argc != 4 ) die ( \"Invalid<S2SV_blank>number<S2SV_blank>of<S2SV_blank>arguments.\" ) ; reader = vpx_video_reader_open ( argv [ 1 ] ) ; if ( ! reader ) die ( \"Failed<S2SV_blank>to<S2SV_blank>open<S2SV_blank>%s<S2SV_blank>for<S2SV_blank>reading.\" , argv [ 1 ] ) ; if ( ! ( outfile = fopen ( argv [ 2 ] , \"wb\" ) ) ) die ( \"Failed<S2SV_blank>to<S2SV_blank>open<S2SV_blank>%s<S2SV_blank>for<S2SV_blank>writing.\" , argv [ 2 ] ) ; n = strtol ( argv [ 3 ] , & nptr , 0 ) ; m = strtol ( nptr + 1 , NULL , 0 ) ; is_range = ( * nptr == '-' ) ; if ( ! n || ! m || ( * nptr != '-' && * nptr != '/' ) ) die ( \"Couldn\\'t<S2SV_blank>parse<S2SV_blank>pattern<S2SV_blank>%s.\\\\n\" , argv [ 3 ] ) ; info = vpx_video_reader_get_info ( reader ) ; decoder = get_vpx_decoder_by_fourcc ( info -> codec_fourcc ) ; if ( ! decoder ) die ( \"Unknown<S2SV_blank>input<S2SV_blank>codec.\" ) ; <S2SV_StartBug> printf ( \"Using<S2SV_blank>%s\\\\n\" , vpx_codec_iface_name ( decoder -> interface ( ) ) ) ; <S2SV_EndBug> <S2SV_StartBug> if ( vpx_codec_dec_init ( & codec , decoder -> interface ( ) , NULL , 0 ) ) <S2SV_EndBug> die_codec ( & codec , \"Failed<S2SV_blank>to<S2SV_blank>initialize<S2SV_blank>decoder.\" ) ; while ( vpx_video_reader_read_frame ( reader ) ) { vpx_codec_iter_t iter = NULL ; vpx_image_t * img = NULL ; size_t frame_size = 0 ; int skip ; const unsigned char * frame = vpx_video_reader_get_frame ( reader , & frame_size ) ; if ( vpx_codec_decode ( & codec , frame , ( unsigned int ) frame_size , NULL , 0 ) ) die_codec ( & codec , \"Failed<S2SV_blank>to<S2SV_blank>decode<S2SV_blank>frame.\" ) ; ++ frame_cnt ; skip = ( is_range && frame_cnt >= n && frame_cnt <= m ) || ( ! is_range && m - ( frame_cnt - 1 ) % m <= n ) ; if ( ! skip ) { putc ( '.' , stdout ) ; while ( ( img = vpx_codec_get_frame ( & codec , & iter ) ) != NULL ) vpx_img_write ( img , outfile ) ; } else { putc ( 'X' , stdout ) ; } fflush ( stdout ) ; } printf ( \"Processed<S2SV_blank>%d<S2SV_blank>frames.\\\\n\" , frame_cnt ) ; if ( vpx_codec_destroy ( & codec ) ) die_codec ( & codec , \"Failed<S2SV_blank>to<S2SV_blank>destroy<S2SV_blank>codec.\" ) ; printf ( \"Play:<S2SV_blank>ffplay<S2SV_blank>-f<S2SV_blank>rawvideo<S2SV_blank>-pix_fmt<S2SV_blank>yuv420p<S2SV_blank>-s<S2SV_blank>%dx%d<S2SV_blank>%s\\\\n\" , info -> frame_width , info -> frame_height , argv [ 2 ] ) ; vpx_video_reader_close ( reader ) ; fclose ( outfile ) ; return EXIT_SUCCESS ; }\n",
      "fixed_code": "<S2SV_ModStart> ( decoder -> codec_interface <S2SV_ModEnd> ( ) ) <S2SV_ModStart> , decoder -> codec_interface <S2SV_ModEnd> ( ) ,\n",
      "source_code_length": 2710,
      "target_code_length": 130,
      "vulnerability_patterns": {
        "null_pointer": 20,
        "total": 20
      },
      "total_patterns": 20,
      "original_address": "https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426",
      "discovery_time": "2016-03-12T21:59Z",
      "project_commit_id": "external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426",
      "extraction_time": "2025-08-31T15:41:49.190955",
      "label": 1,
      "vulnerability_type": "buffer_overflow",
      "difficulty_level": "advanced",
      "risk_factors": [
        "system_crash",
        "memory_corruption",
        "arbitrary_code_execution"
      ],
      "attack_vectors": [
        "memory_manipulation",
        "malicious_input",
        "code_analysis",
        "buffer_overflow",
        "reverse_engineering",
        "fuzzing"
      ],
      "mitigation_strategies": [
        "safe_string_functions",
        "dynamic_analysis",
        "code_review",
        "static_analysis",
        "memory_safety_checks",
        "input_validation",
        "fuzzing",
        "bounds_checking",
        "secure_coding_practices"
      ],
      "code_differences": {
        "has_differences": true,
        "source_lines": 2,
        "target_lines": 2,
        "character_differences": 2580,
        "similarity_percentage": 4.464285714285714
      },
      "vulnerability_location": {
        "vulnerability_present": true,
        "fix_applied": true,
        "code_changed": true,
        "estimated_lines_changed": 0
      }
    },
    {
      "cve_id": "CVE-2016-1621",
      "cwe_id": "CWE-119",
      "cwe_name": "Buffer Overflow",
      "project": "external",
      "severity": "critical",
      "weaponization_score": 7.0,
      "is_critical": true,
      "is_weaponizable": true,
      "is_high_priority_project": false,
      "vulnerable_code": "CWE-119 int main ( int argc , char * * argv ) { int frame_cnt = 0 ; FILE * outfile = NULL ; vpx_codec_ctx_t codec ; const VpxInterface * decoder = NULL ; VpxVideoReader * reader = NULL ; const VpxVideoInfo * info = NULL ; int n = 0 ; int m = 0 ; int is_range = 0 ; char * nptr = NULL ; exec_name = argv [ 0 ] ; if ( argc != 4 ) die ( \"Invalid<S2SV_blank>number<S2SV_blank>of<S2SV_blank>arguments.\" ) ; reader = vpx_video_reader_open ( argv [ 1 ] ) ; if ( ! reader ) die ( \"Failed<S2SV_blank>to<S2SV_blank>open<S2SV_blank>%s<S2SV_blank>for<S2SV_blank>reading.\" , argv [ 1 ] ) ; if ( ! ( outfile = fopen ( argv [ 2 ] , \"wb\" ) ) ) die ( \"Failed<S2SV_blank>to<S2SV_blank>open<S2SV_blank>%s<S2SV_blank>for<S2SV_blank>writing.\" , argv [ 2 ] ) ; n = strtol ( argv [ 3 ] , & nptr , 0 ) ; m = strtol ( nptr + 1 , NULL , 0 ) ; is_range = ( * nptr == '-' ) ; if ( ! n || ! m || ( * nptr != '-' && * nptr != '/' ) ) die ( \"Couldn\\'t<S2SV_blank>parse<S2SV_blank>pattern<S2SV_blank>%s.\\\\n\" , argv [ 3 ] ) ; info = vpx_video_reader_get_info ( reader ) ; decoder = get_vpx_decoder_by_fourcc ( info -> codec_fourcc ) ; if ( ! decoder ) die ( \"Unknown<S2SV_blank>input<S2SV_blank>codec.\" ) ; <S2SV_StartBug> printf ( \"Using<S2SV_blank>%s\\\\n\" , vpx_codec_iface_name ( decoder -> interface ( ) ) ) ; <S2SV_EndBug> <S2SV_StartBug> if ( vpx_codec_dec_init ( & codec , decoder -> interface ( ) , NULL , 0 ) ) <S2SV_EndBug> die_codec ( & codec , \"Failed<S2SV_blank>to<S2SV_blank>initialize<S2SV_blank>decoder.\" ) ; while ( vpx_video_reader_read_frame ( reader ) ) { vpx_codec_iter_t iter = NULL ; vpx_image_t * img = NULL ; size_t frame_size = 0 ; int skip ; const unsigned char * frame = vpx_video_reader_get_frame ( reader , & frame_size ) ; if ( vpx_codec_decode ( & codec , frame , ( unsigned int ) frame_size , NULL , 0 ) ) die_codec ( & codec , \"Failed<S2SV_blank>to<S2SV_blank>decode<S2SV_blank>frame.\" ) ; ++ frame_cnt ; skip = ( is_range && frame_cnt >= n && frame_cnt <= m ) || ( ! is_range && m - ( frame_cnt - 1 ) % m <= n ) ; if ( ! skip ) { putc ( '.' , stdout ) ; while ( ( img = vpx_codec_get_frame ( & codec , & iter ) ) != NULL ) vpx_img_write ( img , outfile ) ; } else { putc ( 'X' , stdout ) ; } fflush ( stdout ) ; } printf ( \"Processed<S2SV_blank>%d<S2SV_blank>frames.\\\\n\" , frame_cnt ) ; if ( vpx_codec_destroy ( & codec ) ) die_codec ( & codec , \"Failed<S2SV_blank>to<S2SV_blank>destroy<S2SV_blank>codec.\" ) ; printf ( \"Play:<S2SV_blank>ffplay<S2SV_blank>-f<S2SV_blank>rawvideo<S2SV_blank>-pix_fmt<S2SV_blank>yuv420p<S2SV_blank>-s<S2SV_blank>%dx%d<S2SV_blank>%s\\\\n\" , info -> frame_width , info -> frame_height , argv [ 2 ] ) ; vpx_video_reader_close ( reader ) ; fclose ( outfile ) ; return EXIT_SUCCESS ; }\n",
      "fixed_code": "<S2SV_ModStart> ( decoder -> codec_interface <S2SV_ModEnd> ( ) ) <S2SV_ModStart> , decoder -> codec_interface <S2SV_ModEnd> ( ) ,\n",
      "source_code_length": 2710,
      "target_code_length": 130,
      "vulnerability_patterns": {
        "integer_overflow": 11,
        "null_pointer": 80,
        "total": 91
      },
      "total_patterns": 91,
      "original_address": "https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426",
      "discovery_time": "2016-03-12T21:59Z",
      "project_commit_id": "external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426",
      "extraction_time": "2025-08-31T15:41:49.190970",
      "label": 1,
      "vulnerability_type": "buffer_overflow",
      "difficulty_level": "advanced",
      "risk_factors": [
        "system_crash",
        "memory_corruption",
        "arbitrary_code_execution"
      ],
      "attack_vectors": [
        "memory_manipulation",
        "malicious_input",
        "code_analysis",
        "buffer_overflow",
        "reverse_engineering",
        "fuzzing"
      ],
      "mitigation_strategies": [
        "safe_string_functions",
        "dynamic_analysis",
        "code_review",
        "static_analysis",
        "memory_safety_checks",
        "input_validation",
        "fuzzing",
        "bounds_checking",
        "secure_coding_practices"
      ],
      "code_differences": {
        "has_differences": true,
        "source_lines": 2,
        "target_lines": 2,
        "character_differences": 2580,
        "similarity_percentage": 4.464285714285714
      },
      "vulnerability_location": {
        "vulnerability_present": true,
        "fix_applied": true,
        "code_changed": true,
        "estimated_lines_changed": 0
      }
    },
    {
      "cve_id": "CVE-2016-1621",
      "cwe_id": "CWE-119",
      "cwe_name": "Buffer Overflow",
      "project": "external",
      "severity": "critical",
      "weaponization_score": 7.0,
      "is_critical": true,
      "is_weaponizable": true,
      "is_high_priority_project": false,
      "vulnerable_code": "CWE-119 int main ( int argc , char * * argv ) { int frame_cnt = 0 ; FILE * outfile = NULL ; vpx_codec_ctx_t codec ; const VpxInterface * decoder = NULL ; VpxVideoReader * reader = NULL ; const VpxVideoInfo * info = NULL ; int n = 0 ; int m = 0 ; int is_range = 0 ; char * nptr = NULL ; exec_name = argv [ 0 ] ; if ( argc != 4 ) die ( \"Invalid<S2SV_blank>number<S2SV_blank>of<S2SV_blank>arguments.\" ) ; reader = vpx_video_reader_open ( argv [ 1 ] ) ; if ( ! reader ) die ( \"Failed<S2SV_blank>to<S2SV_blank>open<S2SV_blank>%s<S2SV_blank>for<S2SV_blank>reading.\" , argv [ 1 ] ) ; if ( ! ( outfile = fopen ( argv [ 2 ] , \"wb\" ) ) ) die ( \"Failed<S2SV_blank>to<S2SV_blank>open<S2SV_blank>%s<S2SV_blank>for<S2SV_blank>writing.\" , argv [ 2 ] ) ; n = strtol ( argv [ 3 ] , & nptr , 0 ) ; m = strtol ( nptr + 1 , NULL , 0 ) ; is_range = ( * nptr == '-' ) ; if ( ! n || ! m || ( * nptr != '-' && * nptr != '/' ) ) die ( \"Couldn\\'t<S2SV_blank>parse<S2SV_blank>pattern<S2SV_blank>%s.\\\\n\" , argv [ 3 ] ) ; info = vpx_video_reader_get_info ( reader ) ; decoder = get_vpx_decoder_by_fourcc ( info -> codec_fourcc ) ; if ( ! decoder ) die ( \"Unknown<S2SV_blank>input<S2SV_blank>codec.\" ) ; <S2SV_StartBug> printf ( \"Using<S2SV_blank>%s\\\\n\" , vpx_codec_iface_name ( decoder -> interface ( ) ) ) ; <S2SV_EndBug> <S2SV_StartBug> if ( vpx_codec_dec_init ( & codec , decoder -> interface ( ) , NULL , 0 ) ) <S2SV_EndBug> die_codec ( & codec , \"Failed<S2SV_blank>to<S2SV_blank>initialize<S2SV_blank>decoder.\" ) ; while ( vpx_video_reader_read_frame ( reader ) ) { vpx_codec_iter_t iter = NULL ; vpx_image_t * img = NULL ; size_t frame_size = 0 ; int skip ; const unsigned char * frame = vpx_video_reader_get_frame ( reader , & frame_size ) ; if ( vpx_codec_decode ( & codec , frame , ( unsigned int ) frame_size , NULL , 0 ) ) die_codec ( & codec , \"Failed<S2SV_blank>to<S2SV_blank>decode<S2SV_blank>frame.\" ) ; ++ frame_cnt ; skip = ( is_range && frame_cnt >= n && frame_cnt <= m ) || ( ! is_range && m - ( frame_cnt - 1 ) % m <= n ) ; if ( ! skip ) { putc ( '.' , stdout ) ; while ( ( img = vpx_codec_get_frame ( & codec , & iter ) ) != NULL ) vpx_img_write ( img , outfile ) ; } else { putc ( 'X' , stdout ) ; } fflush ( stdout ) ; } printf ( \"Processed<S2SV_blank>%d<S2SV_blank>frames.\\\\n\" , frame_cnt ) ; if ( vpx_codec_destroy ( & codec ) ) die_codec ( & codec , \"Failed<S2SV_blank>to<S2SV_blank>destroy<S2SV_blank>codec.\" ) ; printf ( \"Play:<S2SV_blank>ffplay<S2SV_blank>-f<S2SV_blank>rawvideo<S2SV_blank>-pix_fmt<S2SV_blank>yuv420p<S2SV_blank>-s<S2SV_blank>%dx%d<S2SV_blank>%s\\\\n\" , info -> frame_width , info -> frame_height , argv [ 2 ] ) ; vpx_video_reader_close ( reader ) ; fclose ( outfile ) ; return EXIT_SUCCESS ; }\n",
      "fixed_code": "<S2SV_ModStart> ( decoder -> codec_interface <S2SV_ModEnd> ( ) ) <S2SV_ModStart> , decoder -> codec_interface <S2SV_ModEnd> ( ) ,\n",
      "source_code_length": 2710,
      "target_code_length": 130,
      "vulnerability_patterns": {
        "integer_overflow": 1,
        "null_pointer": 10,
        "total": 11
      },
      "total_patterns": 11,
      "original_address": "https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426",
      "discovery_time": "2016-03-12T21:59Z",
      "project_commit_id": "external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426",
      "extraction_time": "2025-08-31T15:41:49.190985",
      "label": 1,
      "vulnerability_type": "buffer_overflow",
      "difficulty_level": "advanced",
      "risk_factors": [
        "system_crash",
        "memory_corruption",
        "arbitrary_code_execution"
      ],
      "attack_vectors": [
        "memory_manipulation",
        "malicious_input",
        "code_analysis",
        "buffer_overflow",
        "reverse_engineering",
        "fuzzing"
      ],
      "mitigation_strategies": [
        "safe_string_functions",
        "dynamic_analysis",
        "code_review",
        "static_analysis",
        "memory_safety_checks",
        "input_validation",
        "fuzzing",
        "bounds_checking",
        "secure_coding_practices"
      ],
      "code_differences": {
        "has_differences": true,
        "source_lines": 2,
        "target_lines": 2,
        "character_differences": 2580,
        "similarity_percentage": 4.464285714285714
      },
      "vulnerability_location": {
        "vulnerability_present": true,
        "fix_applied": true,
        "code_changed": true,
        "estimated_lines_changed": 0
      }
    },
    {
      "cve_id": "CVE-2017-7895",
      "cwe_id": "CWE-119",
      "cwe_name": "Buffer Overflow",
      "project": "torvalds",
      "severity": "critical",
      "weaponization_score": 7.0,
      "is_critical": true,
      "is_weaponizable": true,
      "is_high_priority_project": false,
      "vulnerable_code": "CWE-119 int nfs3svc_decode_writeargs ( struct svc_rqst * rqstp , __be32 * p , struct nfsd3_writeargs * args ) { unsigned int len , v , hdr , dlen ; u32 max_blocksize = svc_max_payload ( rqstp ) ; struct kvec * head = rqstp -> rq_arg . head ; struct kvec * tail = rqstp -> rq_arg . tail ; p = decode_fh ( p , & args -> fh ) ; if ( ! p ) return 0 ; p = xdr_decode_hyper ( p , & args -> offset ) ; args -> count = ntohl ( * p ++ ) ; args -> stable = ntohl ( * p ++ ) ; <S2SV_StartBug> len = args -> len = ntohl ( * p ++ ) ; <S2SV_EndBug> if ( args -> count != args -> len ) return 0 ; hdr = ( void * ) p - head -> iov_base ; dlen = head -> iov_len + rqstp -> rq_arg . page_len + tail -> iov_len - hdr ; if ( dlen < XDR_QUADLEN ( len ) * 4 ) return 0 ; if ( args -> count > max_blocksize ) { args -> count = max_blocksize ; len = args -> len = max_blocksize ; } rqstp -> rq_vec [ 0 ] . iov_base = ( void * ) p ; rqstp -> rq_vec [ 0 ] . iov_len = head -> iov_len - hdr ; v = 0 ; while ( len > rqstp -> rq_vec [ v ] . iov_len ) { len -= rqstp -> rq_vec [ v ] . iov_len ; v ++ ; rqstp -> rq_vec [ v ] . iov_base = page_address ( rqstp -> rq_pages [ v ] ) ; rqstp -> rq_vec [ v ] . iov_len = PAGE_SIZE ; } rqstp -> rq_vec [ v ] . iov_len = len ; args -> vlen = v + 1 ; return 1 ; }\n",
      "fixed_code": "<S2SV_ModStart> p ++ ) ; if ( ( void * ) p > head -> iov_base + head -> iov_len ) return 0\n",
      "source_code_length": 1274,
      "target_code_length": 91,
      "vulnerability_patterns": {
        "integer_overflow": 5,
        "null_pointer": 28,
        "total": 33
      },
      "total_patterns": 33,
      "original_address": "https://github.com/torvalds/linux/commit/13bf9fbff0e5e099e2b6f003a0ab8ae145436309",
      "discovery_time": "2017-04-28T10:59Z",
      "project_commit_id": "torvalds@linux/13bf9fbff0e5e099e2b6f003a0ab8ae145436309",
      "extraction_time": "2025-08-31T15:41:49.191012",
      "label": 1,
      "vulnerability_type": "buffer_overflow",
      "difficulty_level": "advanced",
      "risk_factors": [
        "system_crash",
        "memory_corruption",
        "arbitrary_code_execution"
      ],
      "attack_vectors": [
        "memory_manipulation",
        "malicious_input",
        "code_analysis",
        "buffer_overflow",
        "reverse_engineering",
        "fuzzing"
      ],
      "mitigation_strategies": [
        "safe_string_functions",
        "dynamic_analysis",
        "code_review",
        "static_analysis",
        "memory_safety_checks",
        "input_validation",
        "fuzzing",
        "bounds_checking",
        "secure_coding_practices"
      ],
      "code_differences": {
        "has_differences": true,
        "source_lines": 2,
        "target_lines": 2,
        "character_differences": 1183,
        "similarity_percentage": 23.18840579710145
      },
      "vulnerability_location": {
        "vulnerability_present": true,
        "fix_applied": true,
        "code_changed": true,
        "estimated_lines_changed": 0
      }
    },
    {
      "cve_id": "CVE-2018-18397",
      "cwe_id": "CWE-000",
      "cwe_name": "Unknown/Uncategorized",
      "project": "torvalds",
      "severity": "critical",
      "weaponization_score": 7.0,
      "is_critical": true,
      "is_weaponizable": true,
      "is_high_priority_project": false,
      "vulnerable_code": "CWE-000 static int userfaultfd_unregister ( struct userfaultfd_ctx * ctx , unsigned long arg ) { struct mm_struct * mm = ctx -> mm ; struct vm_area_struct * vma , * prev , * cur ; int ret ; struct uffdio_range uffdio_unregister ; unsigned long new_flags ; bool found ; unsigned long start , end , vma_end ; const void __user * buf = ( void __user * ) arg ; ret = - EFAULT ; if ( copy_from_user ( & uffdio_unregister , buf , sizeof ( uffdio_unregister ) ) ) goto out ; ret = validate_range ( mm , uffdio_unregister . start , uffdio_unregister . len ) ; if ( ret ) goto out ; start = uffdio_unregister . start ; end = start + uffdio_unregister . len ; ret = - ENOMEM ; if ( ! mmget_not_zero ( mm ) ) goto out ; down_write ( & mm -> mmap_sem ) ; vma = find_vma_prev ( mm , start , & prev ) ; if ( ! vma ) goto out_unlock ; ret = - EINVAL ; if ( vma -> vm_start >= end ) goto out_unlock ; if ( is_vm_hugetlb_page ( vma ) ) { unsigned long vma_hpagesize = vma_kernel_pagesize ( vma ) ; if ( start & ( vma_hpagesize - 1 ) ) goto out_unlock ; } found = false ; ret = - EINVAL ; for ( cur = vma ; cur && cur -> vm_start < end ; cur = cur -> vm_next ) { cond_resched ( ) ; BUG_ON ( ! ! cur -> vm_userfaultfd_ctx . ctx ^ ! ! ( cur -> vm_flags & ( VM_UFFD_MISSING | VM_UFFD_WP ) ) ) ; if ( ! vma_can_userfault ( cur ) ) goto out_unlock ; found = true ; } BUG_ON ( ! found ) ; if ( vma -> vm_start < start ) prev = vma ; ret = 0 ; do { cond_resched ( ) ; BUG_ON ( ! vma_can_userfault ( vma ) ) ; <S2SV_StartBug> if ( ! vma -> vm_userfaultfd_ctx . ctx ) <S2SV_EndBug> goto skip ; if ( vma -> vm_start > start ) start = vma -> vm_start ; vma_end = min ( end , vma -> vm_end ) ; if ( userfaultfd_missing ( vma ) ) { struct userfaultfd_wake_range range ; range . start = start ; range . len = vma_end - start ; wake_userfault ( vma -> vm_userfaultfd_ctx . ctx , & range ) ; } new_flags = vma -> vm_flags & ~ ( VM_UFFD_MISSING | VM_UFFD_WP ) ; prev = vma_merge ( mm , prev , start , vma_end , new_flags , vma -> anon_vma , vma -> vm_file , vma -> vm_pgoff , vma_policy ( vma ) , NULL_VM_UFFD_CTX ) ; if ( prev ) { vma = prev ; goto next ; } if ( vma -> vm_start < start ) { ret = split_vma ( mm , vma , start , 1 ) ; if ( ret ) break ; } if ( vma -> vm_end > end ) { ret = split_vma ( mm , vma , end , 0 ) ; if ( ret ) break ; } next : vma -> vm_flags = new_flags ; vma -> vm_userfaultfd_ctx = NULL_VM_UFFD_CTX ; skip : prev = vma ; start = vma -> vm_end ; vma = vma -> vm_next ; } while ( vma && vma -> vm_start < end ) ; out_unlock : up_write ( & mm -> mmap_sem ) ; mmput ( mm ) ; out : return ret ; }\n",
      "fixed_code": "<S2SV_ModStart> ) ) ; WARN_ON ( ! ( vma -> vm_flags & VM_MAYWRITE ) ) ;\n",
      "source_code_length": 2587,
      "target_code_length": 72,
      "vulnerability_patterns": {
        "use_after_free": 4,
        "null_pointer": 27,
        "total": 31
      },
      "total_patterns": 31,
      "original_address": "https://github.com/torvalds/linux/commit/29ec90660d68bbdd69507c1c8b4e33aa299278b1",
      "discovery_time": "2018-12-12T10:29Z",
      "project_commit_id": "torvalds@linux/29ec90660d68bbdd69507c1c8b4e33aa299278b1",
      "extraction_time": "2025-08-31T15:41:49.191043",
      "label": 1,
      "vulnerability_type": "unknown/uncategorized",
      "difficulty_level": "advanced",
      "risk_factors": [
        "use_after_free"
      ],
      "attack_vectors": [
        "fuzzing",
        "code_analysis",
        "reverse_engineering"
      ],
      "mitigation_strategies": [
        "dynamic_analysis",
        "static_analysis",
        "fuzzing",
        "code_review",
        "secure_coding_practices"
      ],
      "code_differences": {
        "has_differences": true,
        "source_lines": 2,
        "target_lines": 2,
        "character_differences": 2515,
        "similarity_percentage": 7.339449541284404
      },
      "vulnerability_location": {
        "vulnerability_present": true,
        "fix_applied": true,
        "code_changed": true,
        "estimated_lines_changed": 0
      }
    },
    {
      "cve_id": "CVE-2011-3346",
      "cwe_id": "CWE-119",
      "cwe_name": "Buffer Overflow",
      "project": "bonzini",
      "severity": "critical",
      "weaponization_score": 7.0,
      "is_critical": true,
      "is_weaponizable": true,
      "is_high_priority_project": false,
      "vulnerable_code": "CWE-119 static void scsi_free_request ( SCSIRequest * req ) { SCSIDiskReq * r = DO_UPCAST ( SCSIDiskReq , req , req ) ; <S2SV_StartBug> qemu_vfree ( r -> iov . iov_base ) ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug>\n",
      "fixed_code": "<S2SV_ModStart> req ) ; if ( r -> iov . iov_base ) { <S2SV_ModStart> ) ; } }\n",
      "source_code_length": 219,
      "target_code_length": 77,
      "vulnerability_patterns": {
        "null_pointer": 14,
        "total": 14
      },
      "total_patterns": 14,
      "original_address": "https://github.com/bonzini/qemu/commit/7285477ab11831b1cf56e45878a89170dd06d9b9",
      "discovery_time": "2014-04-01T06:35Z",
      "project_commit_id": "bonzini@qemu/7285477ab11831b1cf56e45878a89170dd06d9b9",
      "extraction_time": "2025-08-31T15:41:49.191076",
      "label": 1,
      "vulnerability_type": "buffer_overflow",
      "difficulty_level": "advanced",
      "risk_factors": [
        "system_crash",
        "memory_corruption",
        "arbitrary_code_execution"
      ],
      "attack_vectors": [
        "memory_manipulation",
        "malicious_input",
        "code_analysis",
        "buffer_overflow",
        "reverse_engineering",
        "fuzzing"
      ],
      "mitigation_strategies": [
        "safe_string_functions",
        "dynamic_analysis",
        "code_review",
        "static_analysis",
        "memory_safety_checks",
        "input_validation",
        "fuzzing",
        "bounds_checking",
        "secure_coding_practices"
      ],
      "code_differences": {
        "has_differences": true,
        "source_lines": 2,
        "target_lines": 2,
        "character_differences": 142,
        "similarity_percentage": 42.30769230769231
      },
      "vulnerability_location": {
        "vulnerability_present": true,
        "fix_applied": true,
        "code_changed": true,
        "estimated_lines_changed": 0
      }
    },
    {
      "cve_id": "CVE-2013-6763",
      "cwe_id": "CWE-119",
      "cwe_name": "Buffer Overflow",
      "project": "torvalds",
      "severity": "critical",
      "weaponization_score": 7.0,
      "is_critical": true,
      "is_weaponizable": true,
      "is_high_priority_project": false,
      "vulnerable_code": "CWE-119 static int uio_mmap_physical ( struct vm_area_struct * vma ) { struct uio_device * idev = vma -> vm_private_data ; int mi = uio_find_mem_index ( vma ) ; <S2SV_StartBug> if ( mi < 0 ) <S2SV_EndBug> return - EINVAL ; vma -> vm_ops = & uio_physical_vm_ops ; vma -> vm_page_prot = pgprot_noncached ( vma -> vm_page_prot ) ; return remap_pfn_range ( vma , vma -> vm_start , <S2SV_StartBug> idev -> info -> mem [ mi ] . addr >> PAGE_SHIFT , <S2SV_EndBug> vma -> vm_end - vma -> vm_start , vma -> vm_page_prot ) ; }\n",
      "fixed_code": "<S2SV_ModStart> vma ) ; struct uio_mem * mem ; <S2SV_ModStart> mi < 0 ) return - EINVAL ; mem = idev -> info -> mem + mi ; if ( vma -> vm_end - vma -> vm_start > mem -> size <S2SV_ModStart> -> vm_start , mem -> <S2SV_ModEnd> addr >> PAGE_SHIFT\n",
      "source_code_length": 517,
      "target_code_length": 244,
      "vulnerability_patterns": {
        "null_pointer": 10,
        "total": 10
      },
      "total_patterns": 10,
      "original_address": "https://github.com/torvalds/linux/commit/7314e613d5ff9f0934f7a0f74ed7973b903315d1",
      "discovery_time": "2013-11-12T14:35Z",
      "project_commit_id": "torvalds@linux/7314e613d5ff9f0934f7a0f74ed7973b903315d1",
      "extraction_time": "2025-08-31T15:41:49.191096",
      "label": 1,
      "vulnerability_type": "buffer_overflow",
      "difficulty_level": "advanced",
      "risk_factors": [
        "system_crash",
        "memory_corruption",
        "arbitrary_code_execution"
      ],
      "attack_vectors": [
        "memory_manipulation",
        "malicious_input",
        "code_analysis",
        "buffer_overflow",
        "reverse_engineering",
        "fuzzing"
      ],
      "mitigation_strategies": [
        "safe_string_functions",
        "dynamic_analysis",
        "code_review",
        "static_analysis",
        "memory_safety_checks",
        "input_validation",
        "fuzzing",
        "bounds_checking",
        "secure_coding_practices"
      ],
      "code_differences": {
        "has_differences": true,
        "source_lines": 2,
        "target_lines": 2,
        "character_differences": 273,
        "similarity_percentage": 47.05882352941176
      },
      "vulnerability_location": {
        "vulnerability_present": true,
        "fix_applied": true,
        "code_changed": true,
        "estimated_lines_changed": 0
      }
    },
    {
      "cve_id": "CVE-2016-2324",
      "cwe_id": "CWE-119",
      "cwe_name": "Buffer Overflow",
      "project": "git",
      "severity": "critical",
      "weaponization_score": 7.0,
      "is_critical": true,
      "is_weaponizable": true,
      "is_high_priority_project": false,
      "vulnerable_code": "CWE-119 static void mark_commit ( struct commit * c , void * data ) { <S2SV_StartBug> mark_object ( & c -> object , NULL , NULL , data ) ; <S2SV_EndBug> }\n",
      "fixed_code": "<S2SV_ModStart> , NULL , <S2SV_ModEnd> data ) ;\n",
      "source_code_length": 155,
      "target_code_length": 48,
      "vulnerability_patterns": {
        "null_pointer": 15,
        "total": 15
      },
      "total_patterns": 15,
      "original_address": "https://github.com/git/git/commit/de1e67d0703894cb6ea782e36abb63976ab07e60",
      "discovery_time": "2016-04-08T14:59Z",
      "project_commit_id": "git@git/de1e67d0703894cb6ea782e36abb63976ab07e60",
      "extraction_time": "2025-08-31T15:41:49.191123",
      "label": 1,
      "vulnerability_type": "buffer_overflow",
      "difficulty_level": "advanced",
      "risk_factors": [
        "system_crash",
        "memory_corruption",
        "arbitrary_code_execution"
      ],
      "attack_vectors": [
        "memory_manipulation",
        "malicious_input",
        "code_analysis",
        "buffer_overflow",
        "reverse_engineering",
        "fuzzing"
      ],
      "mitigation_strategies": [
        "safe_string_functions",
        "dynamic_analysis",
        "code_review",
        "static_analysis",
        "memory_safety_checks",
        "input_validation",
        "fuzzing",
        "bounds_checking",
        "secure_coding_practices"
      ],
      "code_differences": {
        "has_differences": true,
        "source_lines": 2,
        "target_lines": 2,
        "character_differences": 107,
        "similarity_percentage": 20.833333333333336
      },
      "vulnerability_location": {
        "vulnerability_present": true,
        "fix_applied": true,
        "code_changed": true,
        "estimated_lines_changed": 0
      }
    },
    {
      "cve_id": "CVE-2013-2132",
      "cwe_id": "CWE-000",
      "cwe_name": "Unknown/Uncategorized",
      "project": "mongodb",
      "severity": "critical",
      "weaponization_score": 7.0,
      "is_critical": true,
      "is_weaponizable": true,
      "is_high_priority_project": false,
      "vulnerable_code": "CWE-000 static PyObject * get_value ( PyObject * self , const char * buffer , int * position , int type , int max , PyObject * as_class , unsigned char tz_aware , unsigned char uuid_subtype ) { struct module_state * state = GETSTATE ( self ) ; PyObject * value ; PyObject * error ; switch ( type ) { case 1 : { double d ; if ( max < 8 ) { goto invalid ; } memcpy ( & d , buffer + * position , 8 ) ; value = PyFloat_FromDouble ( d ) ; if ( ! value ) { return NULL ; } * position += 8 ; break ; } case 2 : case 14 : { int value_length = ( ( int * ) ( buffer + * position ) ) [ 0 ] - 1 ; if ( max < value_length ) { goto invalid ; } * position += 4 ; value = PyUnicode_DecodeUTF8 ( buffer + * position , value_length , \"strict\" ) ; if ( ! value ) { return NULL ; } * position += value_length + 1 ; break ; } case 3 : { int size ; memcpy ( & size , buffer + * position , 4 ) ; if ( max < size ) { goto invalid ; } value = elements_to_dict ( self , buffer + * position + 4 , size - 5 , as_class , tz_aware , uuid_subtype ) ; if ( ! value ) { return NULL ; } if ( strcmp ( buffer + * position + 5 , \"$ref\" ) == 0 ) { PyObject * dbref ; PyObject * collection = PyDict_GetItemString ( value , \"$ref\" ) ; PyObject * id = PyDict_GetItemString ( value , \"$id\" ) ; PyObject * database = PyDict_GetItemString ( value , \"$db\" ) ; Py_INCREF ( collection ) ; PyDict_DelItemString ( value , \"$ref\" ) ; <S2SV_StartBug> Py_INCREF ( id ) ; <S2SV_EndBug> <S2SV_StartBug> PyDict_DelItemString ( value , \"$id\" ) ; <S2SV_EndBug> if ( database == NULL ) { database = Py_None ; Py_INCREF ( database ) ; } else { Py_INCREF ( database ) ; PyDict_DelItemString ( value , \"$db\" ) ; } dbref = PyObject_CallFunctionObjArgs ( state -> DBRef , collection , id , database , value , NULL ) ; Py_DECREF ( value ) ; value = dbref ; Py_DECREF ( id ) ; Py_DECREF ( collection ) ; Py_DECREF ( database ) ; if ( ! value ) { return NULL ; } } * position += size ; break ; } case 4 : { int size , end ; memcpy ( & size , buffer + * position , 4 ) ; if ( max < size ) { goto invalid ; } end = * position + size - 1 ; * position += 4 ; value = PyList_New ( 0 ) ; if ( ! value ) { return NULL ; } while ( * position < end ) { PyObject * to_append ; int type = ( int ) buffer [ ( * position ) ++ ] ; int key_size = strlen ( buffer + * position ) ; * position += key_size + 1 ; to_append = get_value ( self , buffer , position , type , max - key_size , as_class , tz_aware , uuid_subtype ) ; if ( ! to_append ) { Py_DECREF ( value ) ; return NULL ; } PyList_Append ( value , to_append ) ; Py_DECREF ( to_append ) ; } ( * position ) ++ ; break ; } case 5 : { PyObject * data ; PyObject * st ; int length , subtype ; memcpy ( & length , buffer + * position , 4 ) ; if ( max < length ) { goto invalid ; } subtype = ( unsigned char ) buffer [ * position + 4 ] ; # if PY_MAJOR_VERSION >= 3 if ( subtype == 0 ) { value = PyBytes_FromStringAndSize ( buffer + * position + 5 , length ) ; * position += length + 5 ; break ; } if ( subtype == 2 ) { data = PyBytes_FromStringAndSize ( buffer + * position + 9 , length - 4 ) ; } else { data = PyBytes_FromStringAndSize ( buffer + * position + 5 , length ) ; } # else if ( subtype == 2 ) { data = PyString_FromStringAndSize ( buffer + * position + 9 , length - 4 ) ; } else { data = PyString_FromStringAndSize ( buffer + * position + 5 , length ) ; } # endif if ( ! data ) { return NULL ; } if ( ( subtype == 3 || subtype == 4 ) && state -> UUID ) { PyObject * kwargs ; PyObject * args = PyTuple_New ( 0 ) ; if ( ! args ) { Py_DECREF ( data ) ; return NULL ; } kwargs = PyDict_New ( ) ; if ( ! kwargs ) { Py_DECREF ( data ) ; Py_DECREF ( args ) ; return NULL ; } assert ( length == 16 ) ; if ( uuid_subtype == CSHARP_LEGACY ) { PyDict_SetItemString ( kwargs , \"bytes_le\" , data ) ; } else { if ( uuid_subtype == JAVA_LEGACY ) { char big_endian [ 16 ] ; _fix_java ( buffer + * position + 5 , big_endian ) ; Py_DECREF ( data ) ; # if PY_MAJOR_VERSION >= 3 data = PyBytes_FromStringAndSize ( big_endian , length ) ; # else data = PyString_FromStringAndSize ( big_endian , length ) ; # endif } PyDict_SetItemString ( kwargs , \"bytes\" , data ) ; } value = PyObject_Call ( state -> UUID , args , kwargs ) ; Py_DECREF ( args ) ; Py_DECREF ( kwargs ) ; Py_DECREF ( data ) ; if ( ! value ) { return NULL ; } * position += length + 5 ; break ; } # if PY_MAJOR_VERSION >= 3 st = PyLong_FromLong ( subtype ) ; # else st = PyInt_FromLong ( subtype ) ; # endif if ( ! st ) { Py_DECREF ( data ) ; return NULL ; } value = PyObject_CallFunctionObjArgs ( state -> Binary , data , st , NULL ) ; Py_DECREF ( st ) ; Py_DECREF ( data ) ; if ( ! value ) { return NULL ; } * position += length + 5 ; break ; } case 6 : case 10 : { value = Py_None ; Py_INCREF ( value ) ; break ; } case 7 : { if ( max < 12 ) { goto invalid ; } # if PY_MAJOR_VERSION >= 3 value = PyObject_CallFunction ( state -> ObjectId , \"y#\" , buffer + * position , 12 ) ; # else value = PyObject_CallFunction ( state -> ObjectId , \"s#\" , buffer + * position , 12 ) ; # endif if ( ! value ) { return NULL ; } * position += 12 ; break ; } case 8 : { value = buffer [ ( * position ) ++ ] ? Py_True : Py_False ; Py_INCREF ( value ) ; break ; } case 9 : { PyObject * naive ; PyObject * replace ; PyObject * args ; PyObject * kwargs ; if ( max < 8 ) { goto invalid ; } naive = datetime_from_millis ( * ( long long * ) ( buffer + * position ) ) ; * position += 8 ; if ( ! tz_aware ) { value = naive ; break ; } if ( ! naive ) { return NULL ; } replace = PyObject_GetAttrString ( naive , \"replace\" ) ; Py_DECREF ( naive ) ; if ( ! replace ) { return NULL ; } args = PyTuple_New ( 0 ) ; if ( ! args ) { Py_DECREF ( replace ) ; return NULL ; } kwargs = PyDict_New ( ) ; if ( ! kwargs ) { Py_DECREF ( replace ) ; Py_DECREF ( args ) ; return NULL ; } if ( PyDict_SetItemString ( kwargs , \"tzinfo\" , state -> UTC ) == - 1 ) { Py_DECREF ( replace ) ; Py_DECREF ( args ) ; Py_DECREF ( kwargs ) ; return NULL ; } value = PyObject_Call ( replace , args , kwargs ) ; Py_DECREF ( replace ) ; Py_DECREF ( args ) ; Py_DECREF ( kwargs ) ; break ; } case 11 : { PyObject * pattern ; int flags_length , flags , i ; int pattern_length = strlen ( buffer + * position ) ; if ( max < pattern_length ) { goto invalid ; } pattern = PyUnicode_DecodeUTF8 ( buffer + * position , pattern_length , \"strict\" ) ; if ( ! pattern ) { return NULL ; } * position += pattern_length + 1 ; flags_length = strlen ( buffer + * position ) ; if ( max < pattern_length + flags_length ) { Py_DECREF ( pattern ) ; goto invalid ; } flags = 0 ; for ( i = 0 ; i < flags_length ; i ++ ) { if ( buffer [ * position + i ] == 'i' ) { flags |= 2 ; } else if ( buffer [ * position + i ] == 'l' ) { flags |= 4 ; } else if ( buffer [ * position + i ] == 'm' ) { flags |= 8 ; } else if ( buffer [ * position + i ] == 's' ) { flags |= 16 ; } else if ( buffer [ * position + i ] == 'u' ) { flags |= 32 ; } else if ( buffer [ * position + i ] == 'x' ) { flags |= 64 ; } } * position += flags_length + 1 ; value = PyObject_CallFunction ( state -> RECompile , \"Oi\" , pattern , flags ) ; Py_DECREF ( pattern ) ; break ; } case 12 : { int collection_length ; PyObject * collection ; PyObject * id ; * position += 4 ; collection_length = strlen ( buffer + * position ) ; if ( max < collection_length ) { goto invalid ; } collection = PyUnicode_DecodeUTF8 ( buffer + * position , collection_length , \"strict\" ) ; if ( ! collection ) { return NULL ; } * position += collection_length + 1 ; if ( max < collection_length + 12 ) { Py_DECREF ( collection ) ; goto invalid ; } id = PyObject_CallFunction ( state -> ObjectId , \"s#\" , buffer + * position , 12 ) ; if ( ! id ) { Py_DECREF ( collection ) ; return NULL ; } * position += 12 ; value = PyObject_CallFunctionObjArgs ( state -> DBRef , collection , id , NULL ) ; Py_DECREF ( collection ) ; Py_DECREF ( id ) ; break ; } case 13 : { PyObject * code ; int value_length = ( ( int * ) ( buffer + * position ) ) [ 0 ] - 1 ; if ( max < value_length ) { goto invalid ; } * position += 4 ; code = PyUnicode_DecodeUTF8 ( buffer + * position , value_length , \"strict\" ) ; if ( ! code ) { return NULL ; } * position += value_length + 1 ; value = PyObject_CallFunctionObjArgs ( state -> Code , code , NULL , NULL ) ; Py_DECREF ( code ) ; break ; } case 15 : { int code_length , scope_size ; PyObject * code ; PyObject * scope ; * position += 8 ; code_length = strlen ( buffer + * position ) ; if ( max < 8 + code_length ) { goto invalid ; } code = PyUnicode_DecodeUTF8 ( buffer + * position , code_length , \"strict\" ) ; if ( ! code ) { return NULL ; } * position += code_length + 1 ; memcpy ( & scope_size , buffer + * position , 4 ) ; scope = elements_to_dict ( self , buffer + * position + 4 , scope_size - 5 , ( PyObject * ) & PyDict_Type , tz_aware , uuid_subtype ) ; if ( ! scope ) { Py_DECREF ( code ) ; return NULL ; } * position += scope_size ; value = PyObject_CallFunctionObjArgs ( state -> Code , code , scope , NULL ) ; Py_DECREF ( code ) ; Py_DECREF ( scope ) ; break ; } case 16 : { int i ; if ( max < 4 ) { goto invalid ; } memcpy ( & i , buffer + * position , 4 ) ; # if PY_MAJOR_VERSION >= 3 value = PyLong_FromLong ( i ) ; # else value = PyInt_FromLong ( i ) ; # endif if ( ! value ) { return NULL ; } * position += 4 ; break ; } case 17 : { unsigned int time , inc ; if ( max < 8 ) { goto invalid ; } memcpy ( & inc , buffer + * position , 4 ) ; memcpy ( & time , buffer + * position + 4 , 4 ) ; value = PyObject_CallFunction ( state -> Timestamp , \"II\" , time , inc ) ; if ( ! value ) { return NULL ; } * position += 8 ; break ; } case 18 : { long long ll ; if ( max < 8 ) { goto invalid ; } memcpy ( & ll , buffer + * position , 8 ) ; value = PyLong_FromLongLong ( ll ) ; if ( ! value ) { return NULL ; } * position += 8 ; break ; } case - 1 : { value = PyObject_CallFunctionObjArgs ( state -> MinKey , NULL ) ; break ; } case 127 : { value = PyObject_CallFunctionObjArgs ( state -> MaxKey , NULL ) ; break ; } default : { PyObject * InvalidDocument = _error ( \"InvalidDocument\" ) ; PyErr_SetString ( InvalidDocument , \"no<S2SV_blank>c<S2SV_blank>decoder<S2SV_blank>for<S2SV_blank>this<S2SV_blank>type<S2SV_blank>yet\" ) ; Py_DECREF ( InvalidDocument ) ; return NULL ; } } return value ; invalid : error = _error ( \"InvalidBSON\" ) ; PyErr_SetNone ( error ) ; Py_DECREF ( error ) ; return NULL ; }\n",
      "fixed_code": "<S2SV_ModStart> \"$ref\" ) ; if ( id == NULL ) { id = Py_None ; <S2SV_ModStart> id ) ; } else { Py_INCREF ( id ) ; <S2SV_ModStart> \"$id\" ) ; }\n",
      "source_code_length": 10319,
      "target_code_length": 141,
      "vulnerability_patterns": {
        "buffer_overflow": 9,
        "integer_overflow": 28,
        "null_pointer": 70,
        "total": 107
      },
      "total_patterns": 107,
      "original_address": "https://github.com/mongodb/mongo-python-driver/commit/a060c15ef87e0f0e72974c7c0e57fe811bbd06a2",
      "discovery_time": "2013-08-15T17:55Z",
      "project_commit_id": "mongodb@mongo-python-driver/a060c15ef87e0f0e72974c7c0e57fe811bbd06a2",
      "extraction_time": "2025-08-31T15:41:49.191144",
      "label": 1,
      "vulnerability_type": "unknown/uncategorized",
      "difficulty_level": "advanced",
      "risk_factors": [
        "buffer_overflow"
      ],
      "attack_vectors": [
        "fuzzing",
        "code_analysis",
        "reverse_engineering"
      ],
      "mitigation_strategies": [
        "dynamic_analysis",
        "static_analysis",
        "fuzzing",
        "code_review",
        "secure_coding_practices"
      ],
      "code_differences": {
        "has_differences": true,
        "source_lines": 2,
        "target_lines": 2,
        "character_differences": 10178,
        "similarity_percentage": 7.936507936507936
      },
      "vulnerability_location": {
        "vulnerability_present": true,
        "fix_applied": true,
        "code_changed": true,
        "estimated_lines_changed": 0
      }
    },
    {
      "cve_id": "CVE-2011-4112",
      "cwe_id": "CWE-000",
      "cwe_name": "Unknown/Uncategorized",
      "project": "torvalds",
      "severity": "critical",
      "weaponization_score": 7.0,
      "is_critical": true,
      "is_weaponizable": true,
      "is_high_priority_project": false,
      "vulnerable_code": "CWE-000 void vlan_setup ( struct net_device * dev ) { ether_setup ( dev ) ; dev -> priv_flags |= IFF_802_1Q_VLAN ; <S2SV_StartBug> dev -> priv_flags &= ~ IFF_XMIT_DST_RELEASE ; <S2SV_EndBug> dev -> tx_queue_len = 0 ; dev -> netdev_ops = & vlan_netdev_ops ; dev -> destructor = free_netdev ; dev -> ethtool_ops = & vlan_ethtool_ops ; memset ( dev -> broadcast , 0 , ETH_ALEN ) ; }\n",
      "fixed_code": "<S2SV_ModStart> priv_flags &= ~ ( IFF_XMIT_DST_RELEASE | IFF_TX_SKB_SHARING ) <S2SV_ModEnd> ; dev ->\n",
      "source_code_length": 380,
      "target_code_length": 101,
      "vulnerability_patterns": {
        "buffer_overflow": 1,
        "integer_overflow": 1,
        "null_pointer": 72,
        "total": 74
      },
      "total_patterns": 74,
      "original_address": "https://github.com/torvalds/linux/commit/550fd08c2cebad61c548def135f67aba284c6162",
      "discovery_time": "2012-05-17T11:00Z",
      "project_commit_id": "torvalds@linux/550fd08c2cebad61c548def135f67aba284c6162",
      "extraction_time": "2025-08-31T15:41:49.191231",
      "label": 1,
      "vulnerability_type": "unknown/uncategorized",
      "difficulty_level": "advanced",
      "risk_factors": [
        "buffer_overflow"
      ],
      "attack_vectors": [
        "fuzzing",
        "code_analysis",
        "reverse_engineering"
      ],
      "mitigation_strategies": [
        "dynamic_analysis",
        "static_analysis",
        "fuzzing",
        "code_review",
        "secure_coding_practices"
      ],
      "code_differences": {
        "has_differences": true,
        "source_lines": 2,
        "target_lines": 2,
        "character_differences": 279,
        "similarity_percentage": 22.5
      },
      "vulnerability_location": {
        "vulnerability_present": true,
        "fix_applied": true,
        "code_changed": true,
        "estimated_lines_changed": 0
      }
    },
    {
      "cve_id": "CVE-2017-8070",
      "cwe_id": "CWE-119",
      "cwe_name": "Buffer Overflow",
      "project": "torvalds",
      "severity": "critical",
      "weaponization_score": 7.0,
      "is_critical": true,
      "is_weaponizable": true,
      "is_high_priority_project": false,
      "vulnerable_code": "CWE-119 static int catc_probe ( struct usb_interface * intf , const struct usb_device_id * id ) { struct device * dev = & intf -> dev ; struct usb_device * usbdev = interface_to_usbdev ( intf ) ; struct net_device * netdev ; struct catc * catc ; u8 broadcast [ ETH_ALEN ] ; <S2SV_StartBug> int i , pktsz , ret ; <S2SV_EndBug> if ( usb_set_interface ( usbdev , intf -> altsetting -> desc . bInterfaceNumber , 1 ) ) { dev_err ( dev , \"Can\\'t<S2SV_blank>set<S2SV_blank>altsetting<S2SV_blank>1.\\\\n\" ) ; return - EIO ; } netdev = alloc_etherdev ( sizeof ( struct catc ) ) ; if ( ! netdev ) return - ENOMEM ; catc = netdev_priv ( netdev ) ; netdev -> netdev_ops = & catc_netdev_ops ; netdev -> watchdog_timeo = TX_TIMEOUT ; netdev -> ethtool_ops = & ops ; catc -> usbdev = usbdev ; catc -> netdev = netdev ; spin_lock_init ( & catc -> tx_lock ) ; spin_lock_init ( & catc -> ctrl_lock ) ; init_timer ( & catc -> timer ) ; catc -> timer . data = ( long ) catc ; catc -> timer . function = catc_stats_timer ; catc -> ctrl_urb = usb_alloc_urb ( 0 , GFP_KERNEL ) ; catc -> tx_urb = usb_alloc_urb ( 0 , GFP_KERNEL ) ; catc -> rx_urb = usb_alloc_urb ( 0 , GFP_KERNEL ) ; catc -> irq_urb = usb_alloc_urb ( 0 , GFP_KERNEL ) ; if ( ( ! catc -> ctrl_urb ) || ( ! catc -> tx_urb ) || ( ! catc -> rx_urb ) || ( ! catc -> irq_urb ) ) { dev_err ( & intf -> dev , \"No<S2SV_blank>free<S2SV_blank>urbs<S2SV_blank>available.\\\\n\" ) ; ret = - ENOMEM ; goto fail_free ; } if ( le16_to_cpu ( usbdev -> descriptor . idVendor ) == 0x0423 && le16_to_cpu ( usbdev -> descriptor . idProduct ) == 0xa && le16_to_cpu ( catc -> usbdev -> descriptor . bcdDevice ) == 0x0130 ) { dev_dbg ( dev , \"Testing<S2SV_blank>for<S2SV_blank>f5u011\\\\n\" ) ; catc -> is_f5u011 = 1 ; atomic_set ( & catc -> recq_sz , 0 ) ; pktsz = RX_PKT_SZ ; } else { pktsz = RX_MAX_BURST * ( PKT_SZ + 2 ) ; } usb_fill_control_urb ( catc -> ctrl_urb , usbdev , usb_sndctrlpipe ( usbdev , 0 ) , NULL , NULL , 0 , catc_ctrl_done , catc ) ; usb_fill_bulk_urb ( catc -> tx_urb , usbdev , usb_sndbulkpipe ( usbdev , 1 ) , NULL , 0 , catc_tx_done , catc ) ; usb_fill_bulk_urb ( catc -> rx_urb , usbdev , usb_rcvbulkpipe ( usbdev , 1 ) , catc -> rx_buf , pktsz , catc_rx_done , catc ) ; usb_fill_int_urb ( catc -> irq_urb , usbdev , usb_rcvintpipe ( usbdev , 2 ) , catc -> irq_buf , 2 , catc_irq_done , catc , 1 ) ; if ( ! catc -> is_f5u011 ) { <S2SV_StartBug> dev_dbg ( dev , \"Checking<S2SV_blank>memory<S2SV_blank>size\\\\n\" ) ; <S2SV_EndBug> <S2SV_StartBug> i = 0x12345678 ; <S2SV_EndBug> <S2SV_StartBug> catc_write_mem ( catc , 0x7a80 , & i , 4 ) ; <S2SV_EndBug> <S2SV_StartBug> i = 0x87654321 ; <S2SV_EndBug> <S2SV_StartBug> catc_write_mem ( catc , 0xfa80 , & i , 4 ) ; <S2SV_EndBug> <S2SV_StartBug> catc_read_mem ( catc , 0x7a80 , & i , 4 ) ; <S2SV_EndBug> <S2SV_StartBug> switch ( i ) { <S2SV_EndBug> case 0x12345678 : catc_set_reg ( catc , TxBufCount , 8 ) ; catc_set_reg ( catc , RxBufCount , 32 ) ; dev_dbg ( dev , \"64k<S2SV_blank>Memory\\\\n\" ) ; break ; default : dev_warn ( & intf -> dev , \"Couldn\\'t<S2SV_blank>detect<S2SV_blank>memory<S2SV_blank>size,<S2SV_blank>assuming<S2SV_blank>32k\\\\n\" ) ; case 0x87654321 : catc_set_reg ( catc , TxBufCount , 4 ) ; catc_set_reg ( catc , RxBufCount , 16 ) ; dev_dbg ( dev , \"32k<S2SV_blank>Memory\\\\n\" ) ; break ; <S2SV_StartBug> } <S2SV_EndBug> dev_dbg ( dev , \"Getting<S2SV_blank>MAC<S2SV_blank>from<S2SV_blank>SEEROM.\\\\n\" ) ; catc_get_mac ( catc , netdev -> dev_addr ) ; dev_dbg ( dev , \"Setting<S2SV_blank>MAC<S2SV_blank>into<S2SV_blank>registers.\\\\n\" ) ; for ( i = 0 ; i < 6 ; i ++ ) catc_set_reg ( catc , StationAddr0 - i , netdev -> dev_addr [ i ] ) ; dev_dbg ( dev , \"Filling<S2SV_blank>the<S2SV_blank>multicast<S2SV_blank>list.\\\\n\" ) ; eth_broadcast_addr ( broadcast ) ; catc_multicast ( broadcast , catc -> multicast ) ; catc_multicast ( netdev -> dev_addr , catc -> multicast ) ; catc_write_mem ( catc , 0xfa80 , catc -> multicast , 64 ) ; dev_dbg ( dev , \"Clearing<S2SV_blank>error<S2SV_blank>counters.\\\\n\" ) ; for ( i = 0 ; i < 8 ; i ++ ) catc_set_reg ( catc , EthStats + i , 0 ) ; catc -> last_stats = jiffies ; dev_dbg ( dev , \"Enabling.\\\\n\" ) ; catc_set_reg ( catc , MaxBurst , RX_MAX_BURST ) ; catc_set_reg ( catc , OpModes , OpTxMerge | OpRxMerge | OpLenInclude | Op3MemWaits ) ; catc_set_reg ( catc , LEDCtrl , LEDLink ) ; catc_set_reg ( catc , RxUnit , RxEnable | RxPolarity | RxMultiCast ) ; } else { dev_dbg ( dev , \"Performing<S2SV_blank>reset\\\\n\" ) ; catc_reset ( catc ) ; catc_get_mac ( catc , netdev -> dev_addr ) ; dev_dbg ( dev , \"Setting<S2SV_blank>RX<S2SV_blank>Mode\\\\n\" ) ; catc -> rxmode [ 0 ] = RxEnable | RxPolarity | RxMultiCast ; catc -> rxmode [ 1 ] = 0 ; f5u011_rxmode ( catc , catc -> rxmode ) ; } dev_dbg ( dev , \"Init<S2SV_blank>done.\\\\n\" ) ; printk ( KERN_INFO \"%s:<S2SV_blank>%s<S2SV_blank>USB<S2SV_blank>Ethernet<S2SV_blank>at<S2SV_blank>usb-%s-%s,<S2SV_blank>%pM.\\\\n\" , netdev -> name , ( catc -> is_f5u011 ) ? \"Belkin<S2SV_blank>F5U011\" : \"CATC<S2SV_blank>EL1210A<S2SV_blank>NetMate\" , usbdev -> bus -> bus_name , usbdev -> devpath , netdev -> dev_addr ) ; usb_set_intfdata ( intf , catc ) ; SET_NETDEV_DEV ( netdev , & intf -> dev ) ; ret = register_netdev ( netdev ) ; if ( ret ) goto fail_clear_intfdata ; return 0 ; fail_clear_intfdata : usb_set_intfdata ( intf , NULL ) ; fail_free : usb_free_urb ( catc -> ctrl_urb ) ; usb_free_urb ( catc -> tx_urb ) ; usb_free_urb ( catc -> rx_urb ) ; usb_free_urb ( catc -> irq_urb ) ; free_netdev ( netdev ) ; return ret ; }\n",
      "fixed_code": "<S2SV_ModStart> ] ; int <S2SV_ModEnd> pktsz , ret <S2SV_ModStart> is_f5u011 ) { u32 * buf ; int i ; <S2SV_ModStart> \"Checking<S2SV_blank>memory<S2SV_blank>size\\\\n\" ) ; buf = kmalloc ( 4 , GFP_KERNEL ) ; if ( ! buf ) { ret = - ENOMEM ; goto fail_free ; } * buf <S2SV_ModEnd> = 0x12345678 ; <S2SV_ModStart> , 0x7a80 , buf <S2SV_ModEnd> , 4 ) <S2SV_ModStart> 4 ) ; * buf <S2SV_ModEnd> = 0x87654321 ; <S2SV_ModStart> , 0xfa80 , buf <S2SV_ModEnd> , 4 ) <S2SV_ModStart> , 0x7a80 , buf <S2SV_ModEnd> , 4 ) <S2SV_ModStart> ; switch ( * buf <S2SV_ModEnd> ) { case <S2SV_ModStart> break ; } kfree ( buf ) ;\n",
      "source_code_length": 5485,
      "target_code_length": 597,
      "vulnerability_patterns": {
        "integer_overflow": 2,
        "null_pointer": 60,
        "total": 62
      },
      "total_patterns": 62,
      "original_address": "https://github.com/torvalds/linux/commit/2d6a0e9de03ee658a9adc3bfb2f0ca55dff1e478",
      "discovery_time": "2017-04-23T05:59Z",
      "project_commit_id": "torvalds@linux/2d6a0e9de03ee658a9adc3bfb2f0ca55dff1e478",
      "extraction_time": "2025-08-31T15:41:49.191255",
      "label": 1,
      "vulnerability_type": "buffer_overflow",
      "difficulty_level": "advanced",
      "risk_factors": [
        "system_crash",
        "memory_corruption",
        "arbitrary_code_execution"
      ],
      "attack_vectors": [
        "memory_manipulation",
        "malicious_input",
        "code_analysis",
        "buffer_overflow",
        "reverse_engineering",
        "fuzzing"
      ],
      "mitigation_strategies": [
        "safe_string_functions",
        "dynamic_analysis",
        "code_review",
        "static_analysis",
        "memory_safety_checks",
        "input_validation",
        "fuzzing",
        "bounds_checking",
        "secure_coding_practices"
      ],
      "code_differences": {
        "has_differences": true,
        "source_lines": 2,
        "target_lines": 2,
        "character_differences": 4888,
        "similarity_percentage": 15.07537688442211
      },
      "vulnerability_location": {
        "vulnerability_present": true,
        "fix_applied": true,
        "code_changed": true,
        "estimated_lines_changed": 0
      }
    },
    {
      "cve_id": "CVE-2016-1621",
      "cwe_id": "CWE-119",
      "cwe_name": "Buffer Overflow",
      "project": "external",
      "severity": "critical",
      "weaponization_score": 7.0,
      "is_critical": true,
      "is_weaponizable": true,
      "is_high_priority_project": false,
      "vulnerable_code": "CWE-119 int main ( int argc , char * * argv ) { int frame_cnt = 0 ; FILE * outfile = NULL ; vpx_codec_ctx_t codec ; const VpxInterface * decoder = NULL ; VpxVideoReader * reader = NULL ; const VpxVideoInfo * info = NULL ; int n = 0 ; int m = 0 ; int is_range = 0 ; char * nptr = NULL ; exec_name = argv [ 0 ] ; if ( argc != 4 ) die ( \"Invalid<S2SV_blank>number<S2SV_blank>of<S2SV_blank>arguments.\" ) ; reader = vpx_video_reader_open ( argv [ 1 ] ) ; if ( ! reader ) die ( \"Failed<S2SV_blank>to<S2SV_blank>open<S2SV_blank>%s<S2SV_blank>for<S2SV_blank>reading.\" , argv [ 1 ] ) ; if ( ! ( outfile = fopen ( argv [ 2 ] , \"wb\" ) ) ) die ( \"Failed<S2SV_blank>to<S2SV_blank>open<S2SV_blank>%s<S2SV_blank>for<S2SV_blank>writing.\" , argv [ 2 ] ) ; n = strtol ( argv [ 3 ] , & nptr , 0 ) ; m = strtol ( nptr + 1 , NULL , 0 ) ; is_range = ( * nptr == '-' ) ; if ( ! n || ! m || ( * nptr != '-' && * nptr != '/' ) ) die ( \"Couldn\\'t<S2SV_blank>parse<S2SV_blank>pattern<S2SV_blank>%s.\\\\n\" , argv [ 3 ] ) ; info = vpx_video_reader_get_info ( reader ) ; decoder = get_vpx_decoder_by_fourcc ( info -> codec_fourcc ) ; if ( ! decoder ) die ( \"Unknown<S2SV_blank>input<S2SV_blank>codec.\" ) ; <S2SV_StartBug> printf ( \"Using<S2SV_blank>%s\\\\n\" , vpx_codec_iface_name ( decoder -> interface ( ) ) ) ; <S2SV_EndBug> <S2SV_StartBug> if ( vpx_codec_dec_init ( & codec , decoder -> interface ( ) , NULL , 0 ) ) <S2SV_EndBug> die_codec ( & codec , \"Failed<S2SV_blank>to<S2SV_blank>initialize<S2SV_blank>decoder.\" ) ; while ( vpx_video_reader_read_frame ( reader ) ) { vpx_codec_iter_t iter = NULL ; vpx_image_t * img = NULL ; size_t frame_size = 0 ; int skip ; const unsigned char * frame = vpx_video_reader_get_frame ( reader , & frame_size ) ; if ( vpx_codec_decode ( & codec , frame , ( unsigned int ) frame_size , NULL , 0 ) ) die_codec ( & codec , \"Failed<S2SV_blank>to<S2SV_blank>decode<S2SV_blank>frame.\" ) ; ++ frame_cnt ; skip = ( is_range && frame_cnt >= n && frame_cnt <= m ) || ( ! is_range && m - ( frame_cnt - 1 ) % m <= n ) ; if ( ! skip ) { putc ( '.' , stdout ) ; while ( ( img = vpx_codec_get_frame ( & codec , & iter ) ) != NULL ) vpx_img_write ( img , outfile ) ; } else { putc ( 'X' , stdout ) ; } fflush ( stdout ) ; } printf ( \"Processed<S2SV_blank>%d<S2SV_blank>frames.\\\\n\" , frame_cnt ) ; if ( vpx_codec_destroy ( & codec ) ) die_codec ( & codec , \"Failed<S2SV_blank>to<S2SV_blank>destroy<S2SV_blank>codec.\" ) ; printf ( \"Play:<S2SV_blank>ffplay<S2SV_blank>-f<S2SV_blank>rawvideo<S2SV_blank>-pix_fmt<S2SV_blank>yuv420p<S2SV_blank>-s<S2SV_blank>%dx%d<S2SV_blank>%s\\\\n\" , info -> frame_width , info -> frame_height , argv [ 2 ] ) ; vpx_video_reader_close ( reader ) ; fclose ( outfile ) ; return EXIT_SUCCESS ; }\n",
      "fixed_code": "<S2SV_ModStart> ( decoder -> codec_interface <S2SV_ModEnd> ( ) ) <S2SV_ModStart> , decoder -> codec_interface <S2SV_ModEnd> ( ) ,\n",
      "source_code_length": 2710,
      "target_code_length": 130,
      "vulnerability_patterns": {
        "integer_overflow": 15,
        "null_pointer": 45,
        "total": 60
      },
      "total_patterns": 60,
      "original_address": "https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426",
      "discovery_time": "2016-03-12T21:59Z",
      "project_commit_id": "external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426",
      "extraction_time": "2025-08-31T15:41:49.191308",
      "label": 1,
      "vulnerability_type": "buffer_overflow",
      "difficulty_level": "advanced",
      "risk_factors": [
        "system_crash",
        "memory_corruption",
        "arbitrary_code_execution"
      ],
      "attack_vectors": [
        "memory_manipulation",
        "malicious_input",
        "code_analysis",
        "buffer_overflow",
        "reverse_engineering",
        "fuzzing"
      ],
      "mitigation_strategies": [
        "safe_string_functions",
        "dynamic_analysis",
        "code_review",
        "static_analysis",
        "memory_safety_checks",
        "input_validation",
        "fuzzing",
        "bounds_checking",
        "secure_coding_practices"
      ],
      "code_differences": {
        "has_differences": true,
        "source_lines": 2,
        "target_lines": 2,
        "character_differences": 2580,
        "similarity_percentage": 4.464285714285714
      },
      "vulnerability_location": {
        "vulnerability_present": true,
        "fix_applied": true,
        "code_changed": true,
        "estimated_lines_changed": 0
      }
    },
    {
      "cve_id": "CVE-2017-12847",
      "cwe_id": "CWE-665",
      "cwe_name": "Unknown",
      "project": "NagiosEnterprises",
      "severity": "critical",
      "weaponization_score": 7.0,
      "is_critical": true,
      "is_weaponizable": true,
      "is_high_priority_project": false,
      "vulnerable_code": "CWE-665 int main ( int argc , char * * argv ) { int result ; int error = FALSE ; int display_license = FALSE ; int display_help = FALSE ; int c = 0 ; struct tm * tm , tm_s ; time_t now ; char datestring [ 256 ] ; nagios_macros * mac ; const char * worker_socket = NULL ; int i ; # ifdef HAVE_SIGACTION struct sigaction sig_action ; # endif # ifdef HAVE_GETOPT_H int option_index = 0 ; static struct option long_options [ ] = { { \"help\" , no_argument , 0 , 'h' } , { \"version\" , no_argument , 0 , 'V' } , { \"license\" , no_argument , 0 , 'V' } , { \"verify-config\" , no_argument , 0 , 'v' } , { \"daemon\" , no_argument , 0 , 'd' } , { \"test-scheduling\" , no_argument , 0 , 's' } , { \"precache-objects\" , no_argument , 0 , 'p' } , { \"use-precached-objects\" , no_argument , 0 , 'u' } , { \"enable-timing-point\" , no_argument , 0 , 'T' } , { \"worker\" , required_argument , 0 , 'W' } , { 0 , 0 , 0 , 0 } } ; # define getopt ( argc , argv , o ) getopt_long ( argc , argv , o , long_options , & option_index ) # endif memset ( & loadctl , 0 , sizeof ( loadctl ) ) ; mac = get_global_macros ( ) ; if ( argc < 2 ) error = TRUE ; while ( 1 ) { c = getopt ( argc , argv , \"+hVvdspuxTW\" ) ; if ( c == - 1 || c == EOF ) break ; switch ( c ) { case '?' : case 'h' : display_help = TRUE ; break ; case 'V' : display_license = TRUE ; break ; case 'v' : verify_config ++ ; break ; case 's' : test_scheduling = TRUE ; break ; case 'd' : daemon_mode = TRUE ; break ; case 'p' : precache_objects = TRUE ; break ; case 'u' : use_precached_objects = TRUE ; break ; case 'T' : enable_timing_point = TRUE ; break ; case 'W' : worker_socket = optarg ; break ; case 'x' : printf ( \"Warning:<S2SV_blank>-x<S2SV_blank>is<S2SV_blank>deprecated<S2SV_blank>and<S2SV_blank>will<S2SV_blank>be<S2SV_blank>removed\\\\n\" ) ; break ; default : break ; } } # ifdef DEBUG_MEMORY mtrace ( ) ; # endif if ( worker_socket ) { exit ( nagios_core_worker ( worker_socket ) ) ; } init_main_cfg_vars ( 1 ) ; init_shared_cfg_vars ( 1 ) ; if ( daemon_mode == FALSE ) { printf ( \"\\\\nNagios<S2SV_blank>Core<S2SV_blank>%s\\\\n\" , PROGRAM_VERSION ) ; printf ( \"Copyright<S2SV_blank>(c)<S2SV_blank>2009-present<S2SV_blank>Nagios<S2SV_blank>Core<S2SV_blank>Development<S2SV_blank>Team<S2SV_blank>and<S2SV_blank>Community<S2SV_blank>Contributors\\\\n\" ) ; printf ( \"Copyright<S2SV_blank>(c)<S2SV_blank>1999-2009<S2SV_blank>Ethan<S2SV_blank>Galstad\\\\n\" ) ; printf ( \"Last<S2SV_blank>Modified:<S2SV_blank>%s\\\\n\" , PROGRAM_MODIFICATION_DATE ) ; printf ( \"License:<S2SV_blank>GPL\\\\n\\\\n\" ) ; printf ( \"Website:<S2SV_blank>https://www.nagios.org\\\\n\" ) ; } if ( display_license == TRUE ) { printf ( \"This<S2SV_blank>program<S2SV_blank>is<S2SV_blank>free<S2SV_blank>software;<S2SV_blank>you<S2SV_blank>can<S2SV_blank>redistribute<S2SV_blank>it<S2SV_blank>and/or<S2SV_blank>modify\\\\n\" ) ; printf ( \"it<S2SV_blank>under<S2SV_blank>the<S2SV_blank>terms<S2SV_blank>of<S2SV_blank>the<S2SV_blank>GNU<S2SV_blank>General<S2SV_blank>Public<S2SV_blank>License<S2SV_blank>version<S2SV_blank>2<S2SV_blank>as\\\\n\" ) ; printf ( \"published<S2SV_blank>by<S2SV_blank>the<S2SV_blank>Free<S2SV_blank>Software<S2SV_blank>Foundation.\\\\n\\\\n\" ) ; printf ( \"This<S2SV_blank>program<S2SV_blank>is<S2SV_blank>distributed<S2SV_blank>in<S2SV_blank>the<S2SV_blank>hope<S2SV_blank>that<S2SV_blank>it<S2SV_blank>will<S2SV_blank>be<S2SV_blank>useful,\\\\n\" ) ; printf ( \"but<S2SV_blank>WITHOUT<S2SV_blank>ANY<S2SV_blank>WARRANTY;<S2SV_blank>without<S2SV_blank>even<S2SV_blank>the<S2SV_blank>implied<S2SV_blank>warranty<S2SV_blank>of\\\\n\" ) ; printf ( \"MERCHANTABILITY<S2SV_blank>or<S2SV_blank>FITNESS<S2SV_blank>FOR<S2SV_blank>A<S2SV_blank>PARTICULAR<S2SV_blank>PURPOSE.<S2SV_blank><S2SV_blank>See<S2SV_blank>the\\\\n\" ) ; printf ( \"GNU<S2SV_blank>General<S2SV_blank>Public<S2SV_blank>License<S2SV_blank>for<S2SV_blank>more<S2SV_blank>details.\\\\n\\\\n\" ) ; printf ( \"You<S2SV_blank>should<S2SV_blank>have<S2SV_blank>received<S2SV_blank>a<S2SV_blank>copy<S2SV_blank>of<S2SV_blank>the<S2SV_blank>GNU<S2SV_blank>General<S2SV_blank>Public<S2SV_blank>License\\\\n\" ) ; printf ( \"along<S2SV_blank>with<S2SV_blank>this<S2SV_blank>program;<S2SV_blank>if<S2SV_blank>not,<S2SV_blank>write<S2SV_blank>to<S2SV_blank>the<S2SV_blank>Free<S2SV_blank>Software\\\\n\" ) ; printf ( \"Foundation,<S2SV_blank>Inc.,<S2SV_blank>675<S2SV_blank>Mass<S2SV_blank>Ave,<S2SV_blank>Cambridge,<S2SV_blank>MA<S2SV_blank>02139,<S2SV_blank>USA.\\\\n\\\\n\" ) ; exit ( OK ) ; } if ( optind >= argc ) error = TRUE ; if ( error == TRUE || display_help == TRUE ) { printf ( \"Usage:<S2SV_blank>%s<S2SV_blank>[options]<S2SV_blank><main_config_file>\\\\n\" , argv [ 0 ] ) ; printf ( \"\\\\n\" ) ; printf ( \"Options:\\\\n\" ) ; printf ( \"\\\\n\" ) ; printf ( \"<S2SV_blank><S2SV_blank>-v,<S2SV_blank>--verify-config<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Verify<S2SV_blank>all<S2SV_blank>configuration<S2SV_blank>data<S2SV_blank>(-v<S2SV_blank>-v<S2SV_blank>for<S2SV_blank>more<S2SV_blank>info)\\\\n\" ) ; printf ( \"<S2SV_blank><S2SV_blank>-s,<S2SV_blank>--test-scheduling<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Shows<S2SV_blank>projected/recommended<S2SV_blank>check<S2SV_blank>scheduling<S2SV_blank>and<S2SV_blank>other\\\\n\" ) ; printf ( \"<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>diagnostic<S2SV_blank>info<S2SV_blank>based<S2SV_blank>on<S2SV_blank>the<S2SV_blank>current<S2SV_blank>configuration<S2SV_blank>files.\\\\n\" ) ; printf ( \"<S2SV_blank><S2SV_blank>-T,<S2SV_blank>--enable-timing-point<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Enable<S2SV_blank>timed<S2SV_blank>commentary<S2SV_blank>on<S2SV_blank>initialization\\\\n\" ) ; printf ( \"<S2SV_blank><S2SV_blank>-x,<S2SV_blank>--dont-verify-paths<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Deprecated<S2SV_blank>(Don\\'t<S2SV_blank>check<S2SV_blank>for<S2SV_blank>circular<S2SV_blank>object<S2SV_blank>paths)\\\\n\" ) ; printf ( \"<S2SV_blank><S2SV_blank>-p,<S2SV_blank>--precache-objects<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Precache<S2SV_blank>object<S2SV_blank>configuration\\\\n\" ) ; printf ( \"<S2SV_blank><S2SV_blank>-u,<S2SV_blank>--use-precached-objects<S2SV_blank><S2SV_blank>Use<S2SV_blank>precached<S2SV_blank>object<S2SV_blank>config<S2SV_blank>file\\\\n\" ) ; printf ( \"<S2SV_blank><S2SV_blank>-d,<S2SV_blank>--daemon<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Starts<S2SV_blank>Nagios<S2SV_blank>in<S2SV_blank>daemon<S2SV_blank>mode,<S2SV_blank>instead<S2SV_blank>of<S2SV_blank>as<S2SV_blank>a<S2SV_blank>foreground<S2SV_blank>process\\\\n\" ) ; printf ( \"<S2SV_blank><S2SV_blank>-W,<S2SV_blank>--worker<S2SV_blank>/path/to/socket<S2SV_blank>Act<S2SV_blank>as<S2SV_blank>a<S2SV_blank>worker<S2SV_blank>for<S2SV_blank>an<S2SV_blank>already<S2SV_blank>running<S2SV_blank>daemon\\\\n\" ) ; printf ( \"\\\\n\" ) ; printf ( \"Visit<S2SV_blank>the<S2SV_blank>Nagios<S2SV_blank>website<S2SV_blank>at<S2SV_blank>https://www.nagios.org/<S2SV_blank>for<S2SV_blank>bug<S2SV_blank>fixes,<S2SV_blank>new\\\\n\" ) ; printf ( \"releases,<S2SV_blank>online<S2SV_blank>documentation,<S2SV_blank>FAQs,<S2SV_blank>information<S2SV_blank>on<S2SV_blank>subscribing<S2SV_blank>to\\\\n\" ) ; printf ( \"the<S2SV_blank>mailing<S2SV_blank>lists,<S2SV_blank>and<S2SV_blank>commercial<S2SV_blank>support<S2SV_blank>options<S2SV_blank>for<S2SV_blank>Nagios.\\\\n\" ) ; printf ( \"\\\\n\" ) ; exit ( ERROR ) ; } config_file = nspath_absolute ( argv [ optind ] , NULL ) ; if ( config_file == NULL ) { printf ( \"Error<S2SV_blank>allocating<S2SV_blank>memory.\\\\n\" ) ; exit ( ERROR ) ; } config_file_dir = nspath_absolute_dirname ( config_file , NULL ) ; # ifdef HAVE_SIGACTION sig_action . sa_sigaction = NULL ; sig_action . sa_handler = handle_sigxfsz ; sigfillset ( & sig_action . sa_mask ) ; sig_action . sa_flags = SA_NODEFER | SA_RESTART ; sigaction ( SIGXFSZ , & sig_action , NULL ) ; # else signal ( SIGXFSZ , handle_sigxfsz ) ; # endif if ( verify_config || test_scheduling || precache_objects ) { reset_variables ( ) ; set_loadctl_defaults ( ) ; if ( verify_config ) printf ( \"Reading<S2SV_blank>configuration<S2SV_blank>data...\\\\n\" ) ; result = read_main_config_file ( config_file ) ; if ( result != OK ) { printf ( \"<S2SV_blank><S2SV_blank><S2SV_blank>Error<S2SV_blank>processing<S2SV_blank>main<S2SV_blank>config<S2SV_blank>file!\\\\n\\\\n\" ) ; exit ( EXIT_FAILURE ) ; } if ( verify_config ) printf ( \"<S2SV_blank><S2SV_blank><S2SV_blank>Read<S2SV_blank>main<S2SV_blank>config<S2SV_blank>file<S2SV_blank>okay...\\\\n\" ) ; if ( ( result = drop_privileges ( nagios_user , nagios_group ) ) == ERROR ) { printf ( \"<S2SV_blank><S2SV_blank><S2SV_blank>Failed<S2SV_blank>to<S2SV_blank>drop<S2SV_blank>privileges.<S2SV_blank><S2SV_blank>Aborting.\" ) ; exit ( EXIT_FAILURE ) ; } if ( ! verify_config && test_configured_paths ( ) == ERROR ) { printf ( \"<S2SV_blank><S2SV_blank><S2SV_blank>One<S2SV_blank>or<S2SV_blank>more<S2SV_blank>path<S2SV_blank>problems<S2SV_blank>detected.<S2SV_blank>Aborting.\\\\n\" ) ; exit ( EXIT_FAILURE ) ; } result = read_all_object_data ( config_file ) ; if ( result != OK ) { printf ( \"<S2SV_blank><S2SV_blank><S2SV_blank>Error<S2SV_blank>processing<S2SV_blank>object<S2SV_blank>config<S2SV_blank>files!\\\\n\\\\n\" ) ; if ( ! strstr ( config_file , \"nagios.cfg\" ) ) { printf ( \"\\\\n***><S2SV_blank>The<S2SV_blank>name<S2SV_blank>of<S2SV_blank>the<S2SV_blank>main<S2SV_blank>configuration<S2SV_blank>file<S2SV_blank>looks<S2SV_blank>suspicious...\\\\n\" ) ; printf ( \"\\\\n\" ) ; printf ( \"<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Make<S2SV_blank>sure<S2SV_blank>you<S2SV_blank>are<S2SV_blank>specifying<S2SV_blank>the<S2SV_blank>name<S2SV_blank>of<S2SV_blank>the<S2SV_blank>MAIN<S2SV_blank>configuration<S2SV_blank>file<S2SV_blank>on\\\\n\" ) ; printf ( \"<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>the<S2SV_blank>command<S2SV_blank>line<S2SV_blank>and<S2SV_blank>not<S2SV_blank>the<S2SV_blank>name<S2SV_blank>of<S2SV_blank>another<S2SV_blank>configuration<S2SV_blank>file.<S2SV_blank><S2SV_blank>The\\\\n\" ) ; printf ( \"<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>main<S2SV_blank>configuration<S2SV_blank>file<S2SV_blank>is<S2SV_blank>typically<S2SV_blank>\\'%s\\'\\\\n\" , DEFAULT_CONFIG_FILE ) ; } printf ( \"\\\\n***><S2SV_blank>One<S2SV_blank>or<S2SV_blank>more<S2SV_blank>problems<S2SV_blank>was<S2SV_blank>encountered<S2SV_blank>while<S2SV_blank>processing<S2SV_blank>the<S2SV_blank>config<S2SV_blank>files...\\\\n\" ) ; printf ( \"\\\\n\" ) ; printf ( \"<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Check<S2SV_blank>your<S2SV_blank>configuration<S2SV_blank>file(s)<S2SV_blank>to<S2SV_blank>ensure<S2SV_blank>that<S2SV_blank>they<S2SV_blank>contain<S2SV_blank>valid\\\\n\" ) ; printf ( \"<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>directives<S2SV_blank>and<S2SV_blank>data<S2SV_blank>definitions.<S2SV_blank><S2SV_blank>If<S2SV_blank>you<S2SV_blank>are<S2SV_blank>upgrading<S2SV_blank>from<S2SV_blank>a<S2SV_blank>previous\\\\n\" ) ; printf ( \"<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>version<S2SV_blank>of<S2SV_blank>Nagios,<S2SV_blank>you<S2SV_blank>should<S2SV_blank>be<S2SV_blank>aware<S2SV_blank>that<S2SV_blank>some<S2SV_blank>variables/definitions\\\\n\" ) ; printf ( \"<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>may<S2SV_blank>have<S2SV_blank>been<S2SV_blank>removed<S2SV_blank>or<S2SV_blank>modified<S2SV_blank>in<S2SV_blank>this<S2SV_blank>version.<S2SV_blank><S2SV_blank>Make<S2SV_blank>sure<S2SV_blank>to<S2SV_blank>read\\\\n\" ) ; printf ( \"<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>the<S2SV_blank>HTML<S2SV_blank>documentation<S2SV_blank>regarding<S2SV_blank>the<S2SV_blank>config<S2SV_blank>files,<S2SV_blank>as<S2SV_blank>well<S2SV_blank>as<S2SV_blank>the\\\\n\" ) ; printf ( \"<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>\\'Whats<S2SV_blank>New\\'<S2SV_blank>section<S2SV_blank>to<S2SV_blank>find<S2SV_blank>out<S2SV_blank>what<S2SV_blank>has<S2SV_blank>changed.\\\\n\\\\n\" ) ; exit ( EXIT_FAILURE ) ; } if ( verify_config ) { printf ( \"<S2SV_blank><S2SV_blank><S2SV_blank>Read<S2SV_blank>object<S2SV_blank>config<S2SV_blank>files<S2SV_blank>okay...\\\\n\\\\n\" ) ; printf ( \"Running<S2SV_blank>pre-flight<S2SV_blank>check<S2SV_blank>on<S2SV_blank>configuration<S2SV_blank>data...\\\\n\\\\n\" ) ; } result = pre_flight_check ( ) ; if ( result != OK ) { printf ( \"\\\\n***><S2SV_blank>One<S2SV_blank>or<S2SV_blank>more<S2SV_blank>problems<S2SV_blank>was<S2SV_blank>encountered<S2SV_blank>while<S2SV_blank>running<S2SV_blank>the<S2SV_blank>pre-flight<S2SV_blank>check...\\\\n\" ) ; printf ( \"\\\\n\" ) ; printf ( \"<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Check<S2SV_blank>your<S2SV_blank>configuration<S2SV_blank>file(s)<S2SV_blank>to<S2SV_blank>ensure<S2SV_blank>that<S2SV_blank>they<S2SV_blank>contain<S2SV_blank>valid\\\\n\" ) ; printf ( \"<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>directives<S2SV_blank>and<S2SV_blank>data<S2SV_blank>definitions.<S2SV_blank><S2SV_blank>If<S2SV_blank>you<S2SV_blank>are<S2SV_blank>upgrading<S2SV_blank>from<S2SV_blank>a<S2SV_blank>previous\\\\n\" ) ; printf ( \"<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>version<S2SV_blank>of<S2SV_blank>Nagios,<S2SV_blank>you<S2SV_blank>should<S2SV_blank>be<S2SV_blank>aware<S2SV_blank>that<S2SV_blank>some<S2SV_blank>variables/definitions\\\\n\" ) ; printf ( \"<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>may<S2SV_blank>have<S2SV_blank>been<S2SV_blank>removed<S2SV_blank>or<S2SV_blank>modified<S2SV_blank>in<S2SV_blank>this<S2SV_blank>version.<S2SV_blank><S2SV_blank>Make<S2SV_blank>sure<S2SV_blank>to<S2SV_blank>read\\\\n\" ) ; printf ( \"<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>the<S2SV_blank>HTML<S2SV_blank>documentation<S2SV_blank>regarding<S2SV_blank>the<S2SV_blank>config<S2SV_blank>files,<S2SV_blank>as<S2SV_blank>well<S2SV_blank>as<S2SV_blank>the\\\\n\" ) ; printf ( \"<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>\\'Whats<S2SV_blank>New\\'<S2SV_blank>section<S2SV_blank>to<S2SV_blank>find<S2SV_blank>out<S2SV_blank>what<S2SV_blank>has<S2SV_blank>changed.\\\\n\\\\n\" ) ; exit ( EXIT_FAILURE ) ; } if ( verify_config ) { printf ( \"\\\\nThings<S2SV_blank>look<S2SV_blank>okay<S2SV_blank>-<S2SV_blank>No<S2SV_blank>serious<S2SV_blank>problems<S2SV_blank>were<S2SV_blank>detected<S2SV_blank>during<S2SV_blank>the<S2SV_blank>pre-flight<S2SV_blank>check\\\\n\" ) ; } if ( test_scheduling == TRUE ) { init_event_queue ( ) ; timing_point ( \"Done<S2SV_blank>initializing<S2SV_blank>event<S2SV_blank>queue\\\\n\" ) ; initialize_retention_data ( config_file ) ; read_initial_state_information ( ) ; timing_point ( \"Retention<S2SV_blank>data<S2SV_blank>and<S2SV_blank>initial<S2SV_blank>state<S2SV_blank>parsed\\\\n\" ) ; init_timing_loop ( ) ; timing_point ( \"Timing<S2SV_blank>loop<S2SV_blank>initialized\\\\n\" ) ; display_scheduling_info ( ) ; } if ( precache_objects ) { result = fcache_objects ( object_precache_file ) ; timing_point ( \"Done<S2SV_blank>precaching<S2SV_blank>objects\\\\n\" ) ; if ( result == OK ) { printf ( \"Object<S2SV_blank>precache<S2SV_blank>file<S2SV_blank>created:\\\\n%s\\\\n\" , object_precache_file ) ; } else { printf ( \"Failed<S2SV_blank>to<S2SV_blank>precache<S2SV_blank>objects<S2SV_blank>to<S2SV_blank>\\'%s\\':<S2SV_blank>%s\\\\n\" , object_precache_file , strerror ( errno ) ) ; } } cleanup ( ) ; timing_point ( \"Exiting\\\\n\" ) ; neb_free_module_list ( ) ; free ( config_file_dir ) ; free ( config_file ) ; exit ( result ) ; } else { if ( strchr ( argv [ 0 ] , '/' ) ) nagios_binary_path = nspath_absolute ( argv [ 0 ] , NULL ) ; else nagios_binary_path = strdup ( argv [ 0 ] ) ; if ( ! nagios_binary_path ) { logit ( NSLOG_RUNTIME_ERROR , TRUE , \"Error:<S2SV_blank>Unable<S2SV_blank>to<S2SV_blank>allocate<S2SV_blank>memory<S2SV_blank>for<S2SV_blank>nagios_binary_path\\\\n\" ) ; exit ( EXIT_FAILURE ) ; } if ( ! ( nagios_iobs = iobroker_create ( ) ) ) { logit ( NSLOG_RUNTIME_ERROR , TRUE , \"Error:<S2SV_blank>Failed<S2SV_blank>to<S2SV_blank>create<S2SV_blank>IO<S2SV_blank>broker<S2SV_blank>set:<S2SV_blank>%s\\\\n\" , strerror ( errno ) ) ; exit ( EXIT_FAILURE ) ; } do { wproc_num_workers_spawned = wproc_num_workers_online = 0 ; caught_signal = sigshutdown = FALSE ; sig_id = 0 ; reset_variables ( ) ; timing_point ( \"Variables<S2SV_blank>reset\\\\n\" ) ; nagios_pid = ( int ) getpid ( ) ; result = read_main_config_file ( config_file ) ; if ( result != OK ) { logit ( NSLOG_CONFIG_ERROR , TRUE , \"Error:<S2SV_blank>Failed<S2SV_blank>to<S2SV_blank>process<S2SV_blank>config<S2SV_blank>file<S2SV_blank>\\'%s\\'.<S2SV_blank>Aborting\\\\n\" , config_file ) ; exit ( EXIT_FAILURE ) ; } timing_point ( \"Main<S2SV_blank>config<S2SV_blank>file<S2SV_blank>read\\\\n\" ) ; program_start = time ( NULL ) ; my_free ( mac -> x [ MACRO_PROCESSSTARTTIME ] ) ; asprintf ( & mac -> x [ MACRO_PROCESSSTARTTIME ] , \"%llu\" , ( unsigned long long ) program_start ) ; <S2SV_StartBug> if ( drop_privileges ( nagios_user , nagios_group ) == ERROR ) { <S2SV_EndBug> logit ( NSLOG_PROCESS_INFO | NSLOG_RUNTIME_ERROR | NSLOG_CONFIG_ERROR , TRUE , \"Failed<S2SV_blank>to<S2SV_blank>drop<S2SV_blank>privileges.<S2SV_blank><S2SV_blank>Aborting.\" ) ; cleanup ( ) ; exit ( ERROR ) ; } if ( test_path_access ( nagios_binary_path , X_OK ) ) { logit ( NSLOG_RUNTIME_ERROR , TRUE , \"Error:<S2SV_blank>failed<S2SV_blank>to<S2SV_blank>access()<S2SV_blank>%s:<S2SV_blank>%s\\\\n\" , nagios_binary_path , strerror ( errno ) ) ; logit ( NSLOG_RUNTIME_ERROR , TRUE , \"Error:<S2SV_blank>Spawning<S2SV_blank>workers<S2SV_blank>will<S2SV_blank>be<S2SV_blank>impossible.<S2SV_blank>Aborting.\\\\n\" ) ; exit ( EXIT_FAILURE ) ; } if ( test_configured_paths ( ) == ERROR ) { <S2SV_StartBug> exit ( EXIT_FAILURE ) ; <S2SV_EndBug> } if ( daemon_mode == TRUE && sigrestart == FALSE ) { result = daemon_init ( ) ; if ( result == ERROR ) { logit ( NSLOG_PROCESS_INFO | NSLOG_RUNTIME_ERROR , TRUE , \"Bailing<S2SV_blank>out<S2SV_blank>due<S2SV_blank>to<S2SV_blank>failure<S2SV_blank>to<S2SV_blank>daemonize.<S2SV_blank>(PID=%d)\" , ( int ) getpid ( ) ) ; cleanup ( ) ; exit ( EXIT_FAILURE ) ; } nagios_pid = ( int ) getpid ( ) ; } logit ( NSLOG_PROCESS_INFO , TRUE , \"Nagios<S2SV_blank>%s<S2SV_blank>starting...<S2SV_blank>(PID=%d)\\\\n\" , PROGRAM_VERSION , ( int ) getpid ( ) ) ; now = time ( NULL ) ; tm = localtime_r ( & now , & tm_s ) ; strftime ( datestring , sizeof ( datestring ) , \"%a<S2SV_blank>%b<S2SV_blank>%d<S2SV_blank>%H:%M:%S<S2SV_blank>%Z<S2SV_blank>%Y\" , tm ) ; logit ( NSLOG_PROCESS_INFO , TRUE , \"Local<S2SV_blank>time<S2SV_blank>is<S2SV_blank>%s\" , datestring ) ; write_log_file_info ( NULL ) ; open_debug_log ( ) ; # ifdef USE_EVENT_BROKER neb_init_modules ( ) ; neb_init_callback_list ( ) ; # endif timing_point ( \"NEB<S2SV_blank>module<S2SV_blank>API<S2SV_blank>initialized\\\\n\" ) ; setup_sighandler ( ) ; if ( qh_init ( qh_socket_path ? qh_socket_path : DEFAULT_QUERY_SOCKET ) != OK ) { logit ( NSLOG_RUNTIME_ERROR , TRUE , \"Error:<S2SV_blank>Failed<S2SV_blank>to<S2SV_blank>initialize<S2SV_blank>query<S2SV_blank>handler.<S2SV_blank>Aborting\\\\n\" ) ; exit ( EXIT_FAILURE ) ; } timing_point ( \"Query<S2SV_blank>handler<S2SV_blank>initialized\\\\n\" ) ; nerd_init ( ) ; timing_point ( \"NERD<S2SV_blank>initialized\\\\n\" ) ; if ( init_workers ( num_check_workers ) < 0 ) { logit ( NSLOG_RUNTIME_ERROR , TRUE , \"Failed<S2SV_blank>to<S2SV_blank>spawn<S2SV_blank>workers.<S2SV_blank>Aborting\\\\n\" ) ; exit ( EXIT_FAILURE ) ; } timing_point ( \"%u<S2SV_blank>workers<S2SV_blank>spawned\\\\n\" , wproc_num_workers_spawned ) ; i = 0 ; while ( i < 50 && wproc_num_workers_online < wproc_num_workers_spawned ) { iobroker_poll ( nagios_iobs , 50 ) ; i ++ ; } timing_point ( \"%u<S2SV_blank>workers<S2SV_blank>connected\\\\n\" , wproc_num_workers_online ) ; set_loadctl_defaults ( ) ; # ifdef USE_EVENT_BROKER if ( neb_load_all_modules ( ) != OK ) { logit ( NSLOG_CONFIG_ERROR , ERROR , \"Error:<S2SV_blank>Module<S2SV_blank>loading<S2SV_blank>failed.<S2SV_blank>Aborting.\\\\n\" ) ; if ( daemon_dumps_core ) neb_unload_all_modules ( NEBMODULE_FORCE_UNLOAD , NEBMODULE_NEB_SHUTDOWN ) ; exit ( EXIT_FAILURE ) ; } timing_point ( \"Modules<S2SV_blank>loaded\\\\n\" ) ; broker_program_state ( NEBTYPE_PROCESS_PRELAUNCH , NEBFLAG_NONE , NEBATTR_NONE , NULL ) ; timing_point ( \"First<S2SV_blank>callback<S2SV_blank>made\\\\n\" ) ; # endif if ( result == OK ) result = read_all_object_data ( config_file ) ; if ( result != OK ) logit ( NSLOG_PROCESS_INFO | NSLOG_RUNTIME_ERROR | NSLOG_CONFIG_ERROR , TRUE , \"Bailing<S2SV_blank>out<S2SV_blank>due<S2SV_blank>to<S2SV_blank>one<S2SV_blank>or<S2SV_blank>more<S2SV_blank>errors<S2SV_blank>encountered<S2SV_blank>in<S2SV_blank>the<S2SV_blank>configuration<S2SV_blank>files.<S2SV_blank>Run<S2SV_blank>Nagios<S2SV_blank>from<S2SV_blank>the<S2SV_blank>command<S2SV_blank>line<S2SV_blank>with<S2SV_blank>the<S2SV_blank>-v<S2SV_blank>option<S2SV_blank>to<S2SV_blank>verify<S2SV_blank>your<S2SV_blank>config<S2SV_blank>before<S2SV_blank>restarting.<S2SV_blank>(PID=%d)\" , ( int ) getpid ( ) ) ; else { if ( ( result = pre_flight_check ( ) ) != OK ) logit ( NSLOG_PROCESS_INFO | NSLOG_RUNTIME_ERROR | NSLOG_VERIFICATION_ERROR , TRUE , \"Bailing<S2SV_blank>out<S2SV_blank>due<S2SV_blank>to<S2SV_blank>errors<S2SV_blank>encountered<S2SV_blank>while<S2SV_blank>running<S2SV_blank>the<S2SV_blank>pre-flight<S2SV_blank>check.<S2SV_blank><S2SV_blank>Run<S2SV_blank>Nagios<S2SV_blank>from<S2SV_blank>the<S2SV_blank>command<S2SV_blank>line<S2SV_blank>with<S2SV_blank>the<S2SV_blank>-v<S2SV_blank>option<S2SV_blank>to<S2SV_blank>verify<S2SV_blank>your<S2SV_blank>config<S2SV_blank>before<S2SV_blank>restarting.<S2SV_blank>(PID=%d)\\\\n\" , ( int ) getpid ( ) ) ; } if ( result != OK ) { if ( sigrestart == TRUE ) { cleanup_status_data ( TRUE ) ; } # ifdef USE_EVENT_BROKER broker_program_state ( NEBTYPE_PROCESS_SHUTDOWN , NEBFLAG_PROCESS_INITIATED , NEBATTR_SHUTDOWN_ABNORMAL , NULL ) ; # endif cleanup ( ) ; exit ( ERROR ) ; } timing_point ( \"Object<S2SV_blank>configuration<S2SV_blank>parsed<S2SV_blank>and<S2SV_blank>understood\\\\n\" ) ; fcache_objects ( object_cache_file ) ; timing_point ( \"Objects<S2SV_blank>cached\\\\n\" ) ; init_event_queue ( ) ; timing_point ( \"Event<S2SV_blank>queue<S2SV_blank>initialized\\\\n\" ) ; # ifdef USE_EVENT_BROKER broker_program_state ( NEBTYPE_PROCESS_START , NEBFLAG_NONE , NEBATTR_NONE , NULL ) ; # endif if ( sigrestart == FALSE ) { initialize_status_data ( config_file ) ; timing_point ( \"Status<S2SV_blank>data<S2SV_blank>initialized\\\\n\" ) ; } initialize_downtime_data ( ) ; timing_point ( \"Downtime<S2SV_blank>data<S2SV_blank>initialized\\\\n\" ) ; initialize_retention_data ( config_file ) ; timing_point ( \"Retention<S2SV_blank>data<S2SV_blank>initialized\\\\n\" ) ; read_initial_state_information ( ) ; timing_point ( \"Initial<S2SV_blank>state<S2SV_blank>information<S2SV_blank>read\\\\n\" ) ; initialize_comment_data ( ) ; timing_point ( \"Comment<S2SV_blank>data<S2SV_blank>initialized\\\\n\" ) ; initialize_performance_data ( config_file ) ; timing_point ( \"Performance<S2SV_blank>data<S2SV_blank>initialized\\\\n\" ) ; init_timing_loop ( ) ; timing_point ( \"Event<S2SV_blank>timing<S2SV_blank>loop<S2SV_blank>initialized\\\\n\" ) ; init_check_stats ( ) ; timing_point ( \"check<S2SV_blank>stats<S2SV_blank>initialized\\\\n\" ) ; check_for_nagios_updates ( FALSE , TRUE ) ; timing_point ( \"Update<S2SV_blank>check<S2SV_blank>concluded\\\\n\" ) ; update_all_status_data ( ) ; timing_point ( \"Status<S2SV_blank>data<S2SV_blank>updated\\\\n\" ) ; log_host_states ( INITIAL_STATES , NULL ) ; log_service_states ( INITIAL_STATES , NULL ) ; timing_point ( \"Initial<S2SV_blank>states<S2SV_blank>logged\\\\n\" ) ; sigrestart = FALSE ; launch_command_file_worker ( ) ; timing_point ( \"Command<S2SV_blank>file<S2SV_blank>worker<S2SV_blank>launched\\\\n\" ) ; # ifdef USE_EVENT_BROKER broker_program_state ( NEBTYPE_PROCESS_EVENTLOOPSTART , NEBFLAG_NONE , NEBATTR_NONE , NULL ) ; # endif event_start = time ( NULL ) ; my_free ( mac -> x [ MACRO_EVENTSTARTTIME ] ) ; asprintf ( & mac -> x [ MACRO_EVENTSTARTTIME ] , \"%llu\" , ( unsigned long long ) event_start ) ; timing_point ( \"Entering<S2SV_blank>event<S2SV_blank>execution<S2SV_blank>loop\\\\n\" ) ; event_execution_loop ( ) ; qh_deinit ( qh_socket_path ? qh_socket_path : DEFAULT_QUERY_SOCKET ) ; if ( caught_signal == TRUE ) { if ( sig_id == SIGHUP ) logit ( NSLOG_PROCESS_INFO , TRUE , \"Caught<S2SV_blank>SIGHUP,<S2SV_blank>restarting...\\\\n\" ) ; } # ifdef USE_EVENT_BROKER broker_program_state ( NEBTYPE_PROCESS_EVENTLOOPEND , NEBFLAG_NONE , NEBATTR_NONE , NULL ) ; if ( sigshutdown == TRUE ) broker_program_state ( NEBTYPE_PROCESS_SHUTDOWN , NEBFLAG_USER_INITIATED , NEBATTR_SHUTDOWN_NORMAL , NULL ) ; else if ( sigrestart == TRUE ) broker_program_state ( NEBTYPE_PROCESS_RESTART , NEBFLAG_USER_INITIATED , NEBATTR_RESTART_NORMAL , NULL ) ; # endif save_state_information ( FALSE ) ; cleanup_retention_data ( ) ; cleanup_performance_data ( ) ; cleanup_downtime_data ( ) ; if ( sigrestart == FALSE ) { cleanup_status_data ( TRUE ) ; } free_worker_memory ( WPROC_FORCE ) ; if ( sigshutdown == TRUE ) { iobroker_destroy ( nagios_iobs , IOBROKER_CLOSE_SOCKETS ) ; nagios_iobs = NULL ; logit ( NSLOG_PROCESS_INFO , TRUE , \"Successfully<S2SV_blank>shutdown...<S2SV_blank>(PID=%d)\\\\n\" , ( int ) getpid ( ) ) ; } cleanup ( ) ; close_debug_log ( ) ; } while ( sigrestart == TRUE && sigshutdown == FALSE ) ; if ( daemon_mode == TRUE ) unlink ( lock_file ) ; my_free ( lock_file ) ; my_free ( config_file ) ; my_free ( config_file_dir ) ; my_free ( nagios_binary_path ) ; } return OK ; }\n",
      "fixed_code": "<S2SV_ModStart> ; if ( daemon_mode == TRUE && sigrestart == FALSE ) { result = daemon_init ( ) ; if ( result == ERROR ) { logit ( NSLOG_PROCESS_INFO | NSLOG_RUNTIME_ERROR , TRUE , \"Bailing<S2SV_blank>out<S2SV_blank>due<S2SV_blank>to<S2SV_blank>failure<S2SV_blank>to<S2SV_blank>daemonize.<S2SV_blank>(PID=%d)\" , ( int ) getpid ( ) ) ; cleanup ( ) ; exit ( EXIT_FAILURE ) ; } nagios_pid = ( int ) getpid ( ) ; } if ( <S2SV_ModStart> exit ( EXIT_FAILURE <S2SV_ModEnd> ) ; }\n",
      "source_code_length": 26066,
      "target_code_length": 471,
      "vulnerability_patterns": {
        "buffer_overflow": 1,
        "use_after_free": 5,
        "integer_overflow": 10,
        "format_string": 68,
        "null_pointer": 7,
        "sql_injection": 4,
        "total": 95
      },
      "total_patterns": 95,
      "original_address": "https://github.com/NagiosEnterprises/nagioscore/commit/1b197346d490df2e2d3b1dcce5ac6134ad0c8752",
      "discovery_time": "2017-08-23T21:29Z",
      "project_commit_id": "NagiosEnterprises@nagioscore/1b197346d490df2e2d3b1dcce5ac6134ad0c8752",
      "extraction_time": "2025-08-31T15:41:49.191338",
      "label": 1,
      "vulnerability_type": "unknown",
      "difficulty_level": "advanced",
      "risk_factors": [
        "sql_injection",
        "buffer_overflow",
        "use_after_free"
      ],
      "attack_vectors": [
        "fuzzing",
        "code_analysis",
        "reverse_engineering"
      ],
      "mitigation_strategies": [
        "dynamic_analysis",
        "static_analysis",
        "fuzzing",
        "code_review",
        "secure_coding_practices"
      ],
      "code_differences": {
        "has_differences": true,
        "source_lines": 2,
        "target_lines": 2,
        "character_differences": 25595,
        "similarity_percentage": 7.608695652173914
      },
      "vulnerability_location": {
        "vulnerability_present": true,
        "fix_applied": true,
        "code_changed": true,
        "estimated_lines_changed": 0
      }
    },
    {
      "cve_id": "CVE-2016-1621",
      "cwe_id": "CWE-119",
      "cwe_name": "Buffer Overflow",
      "project": "external",
      "severity": "critical",
      "weaponization_score": 7.0,
      "is_critical": true,
      "is_weaponizable": true,
      "is_high_priority_project": false,
      "vulnerable_code": "CWE-119 int main ( int argc , char * * argv ) { int frame_cnt = 0 ; FILE * outfile = NULL ; vpx_codec_ctx_t codec ; const VpxInterface * decoder = NULL ; VpxVideoReader * reader = NULL ; const VpxVideoInfo * info = NULL ; int n = 0 ; int m = 0 ; int is_range = 0 ; char * nptr = NULL ; exec_name = argv [ 0 ] ; if ( argc != 4 ) die ( \"Invalid<S2SV_blank>number<S2SV_blank>of<S2SV_blank>arguments.\" ) ; reader = vpx_video_reader_open ( argv [ 1 ] ) ; if ( ! reader ) die ( \"Failed<S2SV_blank>to<S2SV_blank>open<S2SV_blank>%s<S2SV_blank>for<S2SV_blank>reading.\" , argv [ 1 ] ) ; if ( ! ( outfile = fopen ( argv [ 2 ] , \"wb\" ) ) ) die ( \"Failed<S2SV_blank>to<S2SV_blank>open<S2SV_blank>%s<S2SV_blank>for<S2SV_blank>writing.\" , argv [ 2 ] ) ; n = strtol ( argv [ 3 ] , & nptr , 0 ) ; m = strtol ( nptr + 1 , NULL , 0 ) ; is_range = ( * nptr == '-' ) ; if ( ! n || ! m || ( * nptr != '-' && * nptr != '/' ) ) die ( \"Couldn\\'t<S2SV_blank>parse<S2SV_blank>pattern<S2SV_blank>%s.\\\\n\" , argv [ 3 ] ) ; info = vpx_video_reader_get_info ( reader ) ; decoder = get_vpx_decoder_by_fourcc ( info -> codec_fourcc ) ; if ( ! decoder ) die ( \"Unknown<S2SV_blank>input<S2SV_blank>codec.\" ) ; <S2SV_StartBug> printf ( \"Using<S2SV_blank>%s\\\\n\" , vpx_codec_iface_name ( decoder -> interface ( ) ) ) ; <S2SV_EndBug> <S2SV_StartBug> if ( vpx_codec_dec_init ( & codec , decoder -> interface ( ) , NULL , 0 ) ) <S2SV_EndBug> die_codec ( & codec , \"Failed<S2SV_blank>to<S2SV_blank>initialize<S2SV_blank>decoder.\" ) ; while ( vpx_video_reader_read_frame ( reader ) ) { vpx_codec_iter_t iter = NULL ; vpx_image_t * img = NULL ; size_t frame_size = 0 ; int skip ; const unsigned char * frame = vpx_video_reader_get_frame ( reader , & frame_size ) ; if ( vpx_codec_decode ( & codec , frame , ( unsigned int ) frame_size , NULL , 0 ) ) die_codec ( & codec , \"Failed<S2SV_blank>to<S2SV_blank>decode<S2SV_blank>frame.\" ) ; ++ frame_cnt ; skip = ( is_range && frame_cnt >= n && frame_cnt <= m ) || ( ! is_range && m - ( frame_cnt - 1 ) % m <= n ) ; if ( ! skip ) { putc ( '.' , stdout ) ; while ( ( img = vpx_codec_get_frame ( & codec , & iter ) ) != NULL ) vpx_img_write ( img , outfile ) ; } else { putc ( 'X' , stdout ) ; } fflush ( stdout ) ; } printf ( \"Processed<S2SV_blank>%d<S2SV_blank>frames.\\\\n\" , frame_cnt ) ; if ( vpx_codec_destroy ( & codec ) ) die_codec ( & codec , \"Failed<S2SV_blank>to<S2SV_blank>destroy<S2SV_blank>codec.\" ) ; printf ( \"Play:<S2SV_blank>ffplay<S2SV_blank>-f<S2SV_blank>rawvideo<S2SV_blank>-pix_fmt<S2SV_blank>yuv420p<S2SV_blank>-s<S2SV_blank>%dx%d<S2SV_blank>%s\\\\n\" , info -> frame_width , info -> frame_height , argv [ 2 ] ) ; vpx_video_reader_close ( reader ) ; fclose ( outfile ) ; return EXIT_SUCCESS ; }\n",
      "fixed_code": "<S2SV_ModStart> ( decoder -> codec_interface <S2SV_ModEnd> ( ) ) <S2SV_ModStart> , decoder -> codec_interface <S2SV_ModEnd> ( ) ,\n",
      "source_code_length": 2710,
      "target_code_length": 130,
      "vulnerability_patterns": {
        "integer_overflow": 2,
        "null_pointer": 18,
        "total": 20
      },
      "total_patterns": 20,
      "original_address": "https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426",
      "discovery_time": "2016-03-12T21:59Z",
      "project_commit_id": "external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426",
      "extraction_time": "2025-08-31T15:41:49.191446",
      "label": 1,
      "vulnerability_type": "buffer_overflow",
      "difficulty_level": "advanced",
      "risk_factors": [
        "system_crash",
        "memory_corruption",
        "arbitrary_code_execution"
      ],
      "attack_vectors": [
        "memory_manipulation",
        "malicious_input",
        "code_analysis",
        "buffer_overflow",
        "reverse_engineering",
        "fuzzing"
      ],
      "mitigation_strategies": [
        "safe_string_functions",
        "dynamic_analysis",
        "code_review",
        "static_analysis",
        "memory_safety_checks",
        "input_validation",
        "fuzzing",
        "bounds_checking",
        "secure_coding_practices"
      ],
      "code_differences": {
        "has_differences": true,
        "source_lines": 2,
        "target_lines": 2,
        "character_differences": 2580,
        "similarity_percentage": 4.464285714285714
      },
      "vulnerability_location": {
        "vulnerability_present": true,
        "fix_applied": true,
        "code_changed": true,
        "estimated_lines_changed": 0
      }
    },
    {
      "cve_id": "CVE-2010-5332",
      "cwe_id": "CWE-119",
      "cwe_name": "Buffer Overflow",
      "project": "torvalds",
      "severity": "critical",
      "weaponization_score": 7.0,
      "is_critical": true,
      "is_weaponizable": true,
      "is_high_priority_project": false,
      "vulnerable_code": "CWE-119 int mlx4_register_vlan ( struct mlx4_dev * dev , u8 port , u16 vlan , int * index ) { struct mlx4_vlan_table * table = & mlx4_priv ( dev ) -> port [ port ] . vlan_table ; int i , err = 0 ; int free = - 1 ; mutex_lock ( & table -> mutex ) ; for ( i = MLX4_VLAN_REGULAR ; i < MLX4_MAX_VLAN_NUM ; i ++ ) { if ( free < 0 && ( table -> refs [ i ] == 0 ) ) { free = i ; continue ; } if ( table -> refs [ i ] && ( vlan == ( MLX4_VLAN_MASK & be32_to_cpu ( table -> entries [ i ] ) ) ) ) { * index = i ; ++ table -> refs [ i ] ; goto out ; <S2SV_StartBug> } <S2SV_EndBug> } if ( table -> total == table -> max ) { err = - ENOSPC ; goto out ; } table -> refs [ free ] = 1 ; table -> entries [ free ] = cpu_to_be32 ( vlan | MLX4_VLAN_VALID ) ; err = mlx4_set_port_vlan_table ( dev , port , table -> entries ) ; if ( unlikely ( err ) ) { mlx4_warn ( dev , \"Failed<S2SV_blank>adding<S2SV_blank>vlan:<S2SV_blank>%u\\\\n\" , vlan ) ; table -> refs [ free ] = 0 ; table -> entries [ free ] = 0 ; goto out ; } * index = free ; ++ table -> total ; out : mutex_unlock ( & table -> mutex ) ; return err ; }\n",
      "fixed_code": "<S2SV_ModStart> out ; } } if ( free < 0 ) { err = - ENOMEM ; goto out ;\n",
      "source_code_length": 1092,
      "target_code_length": 72,
      "vulnerability_patterns": {
        "integer_overflow": 3,
        "null_pointer": 15,
        "total": 18
      },
      "total_patterns": 18,
      "original_address": "https://github.com/torvalds/linux/commit/0926f91083f34d047abc74f1ca4fa6a9c161f7db",
      "discovery_time": "2019-07-27T22:15Z",
      "project_commit_id": "torvalds@linux/0926f91083f34d047abc74f1ca4fa6a9c161f7db",
      "extraction_time": "2025-08-31T15:41:49.191476",
      "label": 1,
      "vulnerability_type": "buffer_overflow",
      "difficulty_level": "advanced",
      "risk_factors": [
        "system_crash",
        "memory_corruption",
        "arbitrary_code_execution"
      ],
      "attack_vectors": [
        "memory_manipulation",
        "malicious_input",
        "code_analysis",
        "buffer_overflow",
        "reverse_engineering",
        "fuzzing"
      ],
      "mitigation_strategies": [
        "safe_string_functions",
        "dynamic_analysis",
        "code_review",
        "static_analysis",
        "memory_safety_checks",
        "input_validation",
        "fuzzing",
        "bounds_checking",
        "secure_coding_practices"
      ],
      "code_differences": {
        "has_differences": true,
        "source_lines": 2,
        "target_lines": 2,
        "character_differences": 1020,
        "similarity_percentage": 20.588235294117645
      },
      "vulnerability_location": {
        "vulnerability_present": true,
        "fix_applied": true,
        "code_changed": true,
        "estimated_lines_changed": 0
      }
    },
    {
      "cve_id": "CVE-2016-1621",
      "cwe_id": "CWE-119",
      "cwe_name": "Buffer Overflow",
      "project": "external",
      "severity": "critical",
      "weaponization_score": 7.0,
      "is_critical": true,
      "is_weaponizable": true,
      "is_high_priority_project": false,
      "vulnerable_code": "CWE-119 int main ( int argc , char * * argv ) { int frame_cnt = 0 ; FILE * outfile = NULL ; vpx_codec_ctx_t codec ; const VpxInterface * decoder = NULL ; VpxVideoReader * reader = NULL ; const VpxVideoInfo * info = NULL ; int n = 0 ; int m = 0 ; int is_range = 0 ; char * nptr = NULL ; exec_name = argv [ 0 ] ; if ( argc != 4 ) die ( \"Invalid<S2SV_blank>number<S2SV_blank>of<S2SV_blank>arguments.\" ) ; reader = vpx_video_reader_open ( argv [ 1 ] ) ; if ( ! reader ) die ( \"Failed<S2SV_blank>to<S2SV_blank>open<S2SV_blank>%s<S2SV_blank>for<S2SV_blank>reading.\" , argv [ 1 ] ) ; if ( ! ( outfile = fopen ( argv [ 2 ] , \"wb\" ) ) ) die ( \"Failed<S2SV_blank>to<S2SV_blank>open<S2SV_blank>%s<S2SV_blank>for<S2SV_blank>writing.\" , argv [ 2 ] ) ; n = strtol ( argv [ 3 ] , & nptr , 0 ) ; m = strtol ( nptr + 1 , NULL , 0 ) ; is_range = ( * nptr == '-' ) ; if ( ! n || ! m || ( * nptr != '-' && * nptr != '/' ) ) die ( \"Couldn\\'t<S2SV_blank>parse<S2SV_blank>pattern<S2SV_blank>%s.\\\\n\" , argv [ 3 ] ) ; info = vpx_video_reader_get_info ( reader ) ; decoder = get_vpx_decoder_by_fourcc ( info -> codec_fourcc ) ; if ( ! decoder ) die ( \"Unknown<S2SV_blank>input<S2SV_blank>codec.\" ) ; <S2SV_StartBug> printf ( \"Using<S2SV_blank>%s\\\\n\" , vpx_codec_iface_name ( decoder -> interface ( ) ) ) ; <S2SV_EndBug> <S2SV_StartBug> if ( vpx_codec_dec_init ( & codec , decoder -> interface ( ) , NULL , 0 ) ) <S2SV_EndBug> die_codec ( & codec , \"Failed<S2SV_blank>to<S2SV_blank>initialize<S2SV_blank>decoder.\" ) ; while ( vpx_video_reader_read_frame ( reader ) ) { vpx_codec_iter_t iter = NULL ; vpx_image_t * img = NULL ; size_t frame_size = 0 ; int skip ; const unsigned char * frame = vpx_video_reader_get_frame ( reader , & frame_size ) ; if ( vpx_codec_decode ( & codec , frame , ( unsigned int ) frame_size , NULL , 0 ) ) die_codec ( & codec , \"Failed<S2SV_blank>to<S2SV_blank>decode<S2SV_blank>frame.\" ) ; ++ frame_cnt ; skip = ( is_range && frame_cnt >= n && frame_cnt <= m ) || ( ! is_range && m - ( frame_cnt - 1 ) % m <= n ) ; if ( ! skip ) { putc ( '.' , stdout ) ; while ( ( img = vpx_codec_get_frame ( & codec , & iter ) ) != NULL ) vpx_img_write ( img , outfile ) ; } else { putc ( 'X' , stdout ) ; } fflush ( stdout ) ; } printf ( \"Processed<S2SV_blank>%d<S2SV_blank>frames.\\\\n\" , frame_cnt ) ; if ( vpx_codec_destroy ( & codec ) ) die_codec ( & codec , \"Failed<S2SV_blank>to<S2SV_blank>destroy<S2SV_blank>codec.\" ) ; printf ( \"Play:<S2SV_blank>ffplay<S2SV_blank>-f<S2SV_blank>rawvideo<S2SV_blank>-pix_fmt<S2SV_blank>yuv420p<S2SV_blank>-s<S2SV_blank>%dx%d<S2SV_blank>%s\\\\n\" , info -> frame_width , info -> frame_height , argv [ 2 ] ) ; vpx_video_reader_close ( reader ) ; fclose ( outfile ) ; return EXIT_SUCCESS ; }\n",
      "fixed_code": "<S2SV_ModStart> ( decoder -> codec_interface <S2SV_ModEnd> ( ) ) <S2SV_ModStart> , decoder -> codec_interface <S2SV_ModEnd> ( ) ,\n",
      "source_code_length": 2710,
      "target_code_length": 130,
      "vulnerability_patterns": {
        "integer_overflow": 11,
        "null_pointer": 65,
        "total": 76
      },
      "total_patterns": 76,
      "original_address": "https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426",
      "discovery_time": "2016-03-12T21:59Z",
      "project_commit_id": "external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426",
      "extraction_time": "2025-08-31T15:41:49.191493",
      "label": 1,
      "vulnerability_type": "buffer_overflow",
      "difficulty_level": "advanced",
      "risk_factors": [
        "system_crash",
        "memory_corruption",
        "arbitrary_code_execution"
      ],
      "attack_vectors": [
        "memory_manipulation",
        "malicious_input",
        "code_analysis",
        "buffer_overflow",
        "reverse_engineering",
        "fuzzing"
      ],
      "mitigation_strategies": [
        "safe_string_functions",
        "dynamic_analysis",
        "code_review",
        "static_analysis",
        "memory_safety_checks",
        "input_validation",
        "fuzzing",
        "bounds_checking",
        "secure_coding_practices"
      ],
      "code_differences": {
        "has_differences": true,
        "source_lines": 2,
        "target_lines": 2,
        "character_differences": 2580,
        "similarity_percentage": 4.464285714285714
      },
      "vulnerability_location": {
        "vulnerability_present": true,
        "fix_applied": true,
        "code_changed": true,
        "estimated_lines_changed": 0
      }
    },
    {
      "cve_id": "CVE-2017-7586",
      "cwe_id": "CWE-119",
      "cwe_name": "Buffer Overflow",
      "project": "erikd",
      "severity": "critical",
      "weaponization_score": 7.0,
      "is_critical": true,
      "is_weaponizable": true,
      "is_high_priority_project": false,
      "vulnerable_code": "CWE-119 int psf_binheader_readf ( SF_PRIVATE * psf , char const * format , ... ) { va_list argptr ; sf_count_t * countptr , countdata ; unsigned char * ucptr , sixteen_bytes [ 16 ] ; unsigned int * intptr , intdata ; unsigned short * shortptr ; char * charptr ; float * floatptr ; double * doubleptr ; char c ; <S2SV_StartBug> int byte_count = 0 , count ; <S2SV_EndBug> if ( ! format ) return psf_ftell ( psf ) ; va_start ( argptr , format ) ; while ( ( c = * format ++ ) ) <S2SV_StartBug> { switch ( c ) <S2SV_EndBug> { case 'e' : psf -> rwf_endian = SF_ENDIAN_LITTLE ; break ; case 'E' : psf -> rwf_endian = SF_ENDIAN_BIG ; break ; case 'm' : intptr = va_arg ( argptr , unsigned int * ) ; <S2SV_StartBug> ucptr = ( unsigned char * ) intptr ; <S2SV_EndBug> byte_count += header_read ( psf , ucptr , sizeof ( int ) ) ; * intptr = GET_MARKER ( ucptr ) ; break ; case 'h' : <S2SV_StartBug> intptr = va_arg ( argptr , unsigned int * ) ; <S2SV_EndBug> ucptr = ( unsigned char * ) intptr ; byte_count += header_read ( psf , sixteen_bytes , sizeof ( sixteen_bytes ) ) ; { int k ; intdata = 0 ; for ( k = 0 ; k < 16 ; k ++ ) intdata ^= sixteen_bytes [ k ] << k ; } * intptr = intdata ; break ; case '1' : charptr = va_arg ( argptr , char * ) ; * charptr = 0 ; byte_count += header_read ( psf , charptr , sizeof ( char ) ) ; break ; case '2' : shortptr = va_arg ( argptr , unsigned short * ) ; * shortptr = 0 ; ucptr = ( unsigned char * ) shortptr ; byte_count += header_read ( psf , ucptr , sizeof ( short ) ) ; if ( psf -> rwf_endian == SF_ENDIAN_BIG ) * shortptr = GET_BE_SHORT ( ucptr ) ; else * shortptr = GET_LE_SHORT ( ucptr ) ; break ; case '3' : intptr = va_arg ( argptr , unsigned int * ) ; * intptr = 0 ; byte_count += header_read ( psf , sixteen_bytes , 3 ) ; if ( psf -> rwf_endian == SF_ENDIAN_BIG ) * intptr = GET_BE_3BYTE ( sixteen_bytes ) ; else * intptr = GET_LE_3BYTE ( sixteen_bytes ) ; break ; case '4' : intptr = va_arg ( argptr , unsigned int * ) ; * intptr = 0 ; ucptr = ( unsigned char * ) intptr ; byte_count += header_read ( psf , ucptr , sizeof ( int ) ) ; if ( psf -> rwf_endian == SF_ENDIAN_BIG ) * intptr = psf_get_be32 ( ucptr , 0 ) ; else * intptr = psf_get_le32 ( ucptr , 0 ) ; break ; case '8' : countptr = va_arg ( argptr , sf_count_t * ) ; * countptr = 0 ; byte_count += header_read ( psf , sixteen_bytes , 8 ) ; if ( psf -> rwf_endian == SF_ENDIAN_BIG ) countdata = psf_get_be64 ( sixteen_bytes , 0 ) ; else countdata = psf_get_le64 ( sixteen_bytes , 0 ) ; * countptr = countdata ; break ; case 'f' : floatptr = va_arg ( argptr , float * ) ; * floatptr = 0.0 ; byte_count += header_read ( psf , floatptr , sizeof ( float ) ) ; if ( psf -> rwf_endian == SF_ENDIAN_BIG ) * floatptr = float32_be_read ( ( unsigned char * ) floatptr ) ; else * floatptr = float32_le_read ( ( unsigned char * ) floatptr ) ; break ; case 'd' : doubleptr = va_arg ( argptr , double * ) ; * doubleptr = 0.0 ; byte_count += header_read ( psf , doubleptr , sizeof ( double ) ) ; if ( psf -> rwf_endian == SF_ENDIAN_BIG ) * doubleptr = double64_be_read ( ( unsigned char * ) doubleptr ) ; else * doubleptr = double64_le_read ( ( unsigned char * ) doubleptr ) ; break ; case 's' : psf_log_printf ( psf , \"Format<S2SV_blank>conversion<S2SV_blank>\\'s\\'<S2SV_blank>not<S2SV_blank>implemented<S2SV_blank>yet.\\\\n\" ) ; break ; case 'b' : charptr = va_arg ( argptr , char * ) ; count = va_arg ( argptr , size_t ) ; <S2SV_StartBug> if ( count > 0 ) <S2SV_EndBug> byte_count += header_read ( psf , charptr , count ) ; break ; <S2SV_StartBug> case 'G' : <S2SV_EndBug> charptr = va_arg ( argptr , char * ) ; count = va_arg ( argptr , size_t ) ; <S2SV_StartBug> if ( count > 0 ) <S2SV_EndBug> byte_count += header_gets ( psf , charptr , count ) ; break ; case 'z' : psf_log_printf ( psf , \"Format<S2SV_blank>conversion<S2SV_blank>\\'z\\'<S2SV_blank>not<S2SV_blank>implemented<S2SV_blank>yet.\\\\n\" ) ; break ; case 'p' : count = va_arg ( argptr , size_t ) ; <S2SV_StartBug> header_seek ( psf , count , SEEK_SET ) ; <S2SV_EndBug> byte_count = count ; break ; case 'j' : count = va_arg ( argptr , size_t ) ; if ( count ) { header_seek ( psf , count , SEEK_CUR ) ; <S2SV_StartBug> byte_count += count ; <S2SV_EndBug> } ; break ; default : psf_log_printf ( psf , \"***<S2SV_blank>Invalid<S2SV_blank>format<S2SV_blank>specifier<S2SV_blank>`%c\\'\\\\n\" , c ) ; psf -> error = SFE_INTERNAL ; break ; } ; } ; va_end ( argptr ) ; return byte_count ; }\n",
      "fixed_code": "<S2SV_ModStart> 0 , count = 0 <S2SV_ModStart> ) ) { if ( psf -> header . indx + 16 >= psf -> header . len && psf_bump_header_allocation ( psf , 16 ) ) return count ; <S2SV_ModStart> * ) ; * intptr = 0 ; <S2SV_ModStart> int * ) ; * intptr = 0 <S2SV_ModStart> size_t ) ; memset ( charptr , 0 , count ) ; byte_count += header_read ( psf , charptr , count ) ; break ; case 'G' : charptr = va_arg ( argptr , char * ) ; count = va_arg ( argptr , size_t ) ; memset ( charptr , 0 , count ) ; if ( psf -> header . indx + count >= psf -> header . len && psf_bump_header_allocation ( psf , count ) ) return 0 ; byte_count += header_gets <S2SV_ModEnd> ( psf , <S2SV_ModStart> break ; case 'z' : psf_log_printf ( psf , \"Format<S2SV_blank>conversion<S2SV_blank>\\'z\\'<S2SV_blank>not<S2SV_blank>implemented<S2SV_blank>yet.\\\\n\" ) ; break ; case 'p' : <S2SV_ModEnd> count = va_arg <S2SV_ModStart> size_t ) ; header_seek ( psf , count , SEEK_SET ) ; byte_count = count ; break ; case 'j' <S2SV_ModEnd> : count = <S2SV_ModStart> , count , <S2SV_ModEnd> SEEK_CUR ) ; <S2SV_ModStart> byte_count += count <S2SV_ModEnd> ; break ;\n",
      "source_code_length": 4424,
      "target_code_length": 1106,
      "vulnerability_patterns": {
        "integer_overflow": 14,
        "null_pointer": 11,
        "total": 25
      },
      "total_patterns": 25,
      "original_address": "https://github.com/erikd/libsndfile/commit/708e996c87c5fae77b104ccfeb8f6db784c32074",
      "discovery_time": "2017-04-07T20:59Z",
      "project_commit_id": "erikd@libsndfile/708e996c87c5fae77b104ccfeb8f6db784c32074",
      "extraction_time": "2025-08-31T15:41:49.191523",
      "label": 1,
      "vulnerability_type": "buffer_overflow",
      "difficulty_level": "advanced",
      "risk_factors": [
        "system_crash",
        "memory_corruption",
        "arbitrary_code_execution"
      ],
      "attack_vectors": [
        "memory_manipulation",
        "malicious_input",
        "code_analysis",
        "buffer_overflow",
        "reverse_engineering",
        "fuzzing"
      ],
      "mitigation_strategies": [
        "safe_string_functions",
        "dynamic_analysis",
        "code_review",
        "static_analysis",
        "memory_safety_checks",
        "input_validation",
        "fuzzing",
        "bounds_checking",
        "secure_coding_practices"
      ],
      "code_differences": {
        "has_differences": true,
        "source_lines": 2,
        "target_lines": 2,
        "character_differences": 3318,
        "similarity_percentage": 29.133858267716533
      },
      "vulnerability_location": {
        "vulnerability_present": true,
        "fix_applied": true,
        "code_changed": true,
        "estimated_lines_changed": 0
      }
    },
    {
      "cve_id": "CVE-2016-1621",
      "cwe_id": "CWE-119",
      "cwe_name": "Buffer Overflow",
      "project": "external",
      "severity": "critical",
      "weaponization_score": 7.0,
      "is_critical": true,
      "is_weaponizable": true,
      "is_high_priority_project": false,
      "vulnerable_code": "CWE-119 int main ( int argc , char * * argv ) { int frame_cnt = 0 ; FILE * outfile = NULL ; vpx_codec_ctx_t codec ; const VpxInterface * decoder = NULL ; VpxVideoReader * reader = NULL ; const VpxVideoInfo * info = NULL ; int n = 0 ; int m = 0 ; int is_range = 0 ; char * nptr = NULL ; exec_name = argv [ 0 ] ; if ( argc != 4 ) die ( \"Invalid<S2SV_blank>number<S2SV_blank>of<S2SV_blank>arguments.\" ) ; reader = vpx_video_reader_open ( argv [ 1 ] ) ; if ( ! reader ) die ( \"Failed<S2SV_blank>to<S2SV_blank>open<S2SV_blank>%s<S2SV_blank>for<S2SV_blank>reading.\" , argv [ 1 ] ) ; if ( ! ( outfile = fopen ( argv [ 2 ] , \"wb\" ) ) ) die ( \"Failed<S2SV_blank>to<S2SV_blank>open<S2SV_blank>%s<S2SV_blank>for<S2SV_blank>writing.\" , argv [ 2 ] ) ; n = strtol ( argv [ 3 ] , & nptr , 0 ) ; m = strtol ( nptr + 1 , NULL , 0 ) ; is_range = ( * nptr == '-' ) ; if ( ! n || ! m || ( * nptr != '-' && * nptr != '/' ) ) die ( \"Couldn\\'t<S2SV_blank>parse<S2SV_blank>pattern<S2SV_blank>%s.\\\\n\" , argv [ 3 ] ) ; info = vpx_video_reader_get_info ( reader ) ; decoder = get_vpx_decoder_by_fourcc ( info -> codec_fourcc ) ; if ( ! decoder ) die ( \"Unknown<S2SV_blank>input<S2SV_blank>codec.\" ) ; <S2SV_StartBug> printf ( \"Using<S2SV_blank>%s\\\\n\" , vpx_codec_iface_name ( decoder -> interface ( ) ) ) ; <S2SV_EndBug> <S2SV_StartBug> if ( vpx_codec_dec_init ( & codec , decoder -> interface ( ) , NULL , 0 ) ) <S2SV_EndBug> die_codec ( & codec , \"Failed<S2SV_blank>to<S2SV_blank>initialize<S2SV_blank>decoder.\" ) ; while ( vpx_video_reader_read_frame ( reader ) ) { vpx_codec_iter_t iter = NULL ; vpx_image_t * img = NULL ; size_t frame_size = 0 ; int skip ; const unsigned char * frame = vpx_video_reader_get_frame ( reader , & frame_size ) ; if ( vpx_codec_decode ( & codec , frame , ( unsigned int ) frame_size , NULL , 0 ) ) die_codec ( & codec , \"Failed<S2SV_blank>to<S2SV_blank>decode<S2SV_blank>frame.\" ) ; ++ frame_cnt ; skip = ( is_range && frame_cnt >= n && frame_cnt <= m ) || ( ! is_range && m - ( frame_cnt - 1 ) % m <= n ) ; if ( ! skip ) { putc ( '.' , stdout ) ; while ( ( img = vpx_codec_get_frame ( & codec , & iter ) ) != NULL ) vpx_img_write ( img , outfile ) ; } else { putc ( 'X' , stdout ) ; } fflush ( stdout ) ; } printf ( \"Processed<S2SV_blank>%d<S2SV_blank>frames.\\\\n\" , frame_cnt ) ; if ( vpx_codec_destroy ( & codec ) ) die_codec ( & codec , \"Failed<S2SV_blank>to<S2SV_blank>destroy<S2SV_blank>codec.\" ) ; printf ( \"Play:<S2SV_blank>ffplay<S2SV_blank>-f<S2SV_blank>rawvideo<S2SV_blank>-pix_fmt<S2SV_blank>yuv420p<S2SV_blank>-s<S2SV_blank>%dx%d<S2SV_blank>%s\\\\n\" , info -> frame_width , info -> frame_height , argv [ 2 ] ) ; vpx_video_reader_close ( reader ) ; fclose ( outfile ) ; return EXIT_SUCCESS ; }\n",
      "fixed_code": "<S2SV_ModStart> ( decoder -> codec_interface <S2SV_ModEnd> ( ) ) <S2SV_ModStart> , decoder -> codec_interface <S2SV_ModEnd> ( ) ,\n",
      "source_code_length": 2710,
      "target_code_length": 130,
      "vulnerability_patterns": {
        "integer_overflow": 5,
        "null_pointer": 95,
        "total": 100
      },
      "total_patterns": 100,
      "original_address": "https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426",
      "discovery_time": "2016-03-12T21:59Z",
      "project_commit_id": "external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426",
      "extraction_time": "2025-08-31T15:41:49.191572",
      "label": 1,
      "vulnerability_type": "buffer_overflow",
      "difficulty_level": "advanced",
      "risk_factors": [
        "system_crash",
        "memory_corruption",
        "arbitrary_code_execution"
      ],
      "attack_vectors": [
        "memory_manipulation",
        "malicious_input",
        "code_analysis",
        "buffer_overflow",
        "reverse_engineering",
        "fuzzing"
      ],
      "mitigation_strategies": [
        "safe_string_functions",
        "dynamic_analysis",
        "code_review",
        "static_analysis",
        "memory_safety_checks",
        "input_validation",
        "fuzzing",
        "bounds_checking",
        "secure_coding_practices"
      ],
      "code_differences": {
        "has_differences": true,
        "source_lines": 2,
        "target_lines": 2,
        "character_differences": 2580,
        "similarity_percentage": 4.464285714285714
      },
      "vulnerability_location": {
        "vulnerability_present": true,
        "fix_applied": true,
        "code_changed": true,
        "estimated_lines_changed": 0
      }
    },
    {
      "cve_id": "CVE-2017-16996",
      "cwe_id": "CWE-119",
      "cwe_name": "Buffer Overflow",
      "project": "torvalds",
      "severity": "critical",
      "weaponization_score": 7.0,
      "is_critical": true,
      "is_weaponizable": true,
      "is_high_priority_project": false,
      "vulnerable_code": "CWE-119 static int adjust_scalar_min_max_vals ( struct bpf_verifier_env * env , struct bpf_insn * insn , struct bpf_reg_state * dst_reg , struct bpf_reg_state src_reg ) { struct bpf_reg_state * regs = cur_regs ( env ) ; u8 opcode = BPF_OP ( insn -> code ) ; bool src_known , dst_known ; s64 smin_val , smax_val ; u64 umin_val , umax_val ; if ( BPF_CLASS ( insn -> code ) != BPF_ALU64 ) { <S2SV_StartBug> coerce_reg_to_32 ( dst_reg ) ; <S2SV_EndBug> <S2SV_StartBug> coerce_reg_to_32 ( & src_reg ) ; <S2SV_EndBug> } smin_val = src_reg . smin_value ; smax_val = src_reg . smax_value ; umin_val = src_reg . umin_value ; umax_val = src_reg . umax_value ; src_known = tnum_is_const ( src_reg . var_off ) ; dst_known = tnum_is_const ( dst_reg -> var_off ) ; switch ( opcode ) { case BPF_ADD : if ( signed_add_overflows ( dst_reg -> smin_value , smin_val ) || signed_add_overflows ( dst_reg -> smax_value , smax_val ) ) { dst_reg -> smin_value = S64_MIN ; dst_reg -> smax_value = S64_MAX ; } else { dst_reg -> smin_value += smin_val ; dst_reg -> smax_value += smax_val ; } if ( dst_reg -> umin_value + umin_val < umin_val || dst_reg -> umax_value + umax_val < umax_val ) { dst_reg -> umin_value = 0 ; dst_reg -> umax_value = U64_MAX ; } else { dst_reg -> umin_value += umin_val ; dst_reg -> umax_value += umax_val ; } dst_reg -> var_off = tnum_add ( dst_reg -> var_off , src_reg . var_off ) ; break ; case BPF_SUB : if ( signed_sub_overflows ( dst_reg -> smin_value , smax_val ) || signed_sub_overflows ( dst_reg -> smax_value , smin_val ) ) { dst_reg -> smin_value = S64_MIN ; dst_reg -> smax_value = S64_MAX ; } else { dst_reg -> smin_value -= smax_val ; dst_reg -> smax_value -= smin_val ; } if ( dst_reg -> umin_value < umax_val ) { dst_reg -> umin_value = 0 ; dst_reg -> umax_value = U64_MAX ; } else { dst_reg -> umin_value -= umax_val ; dst_reg -> umax_value -= umin_val ; } dst_reg -> var_off = tnum_sub ( dst_reg -> var_off , src_reg . var_off ) ; break ; case BPF_MUL : dst_reg -> var_off = tnum_mul ( dst_reg -> var_off , src_reg . var_off ) ; if ( smin_val < 0 || dst_reg -> smin_value < 0 ) { __mark_reg_unbounded ( dst_reg ) ; __update_reg_bounds ( dst_reg ) ; break ; } if ( umax_val > U32_MAX || dst_reg -> umax_value > U32_MAX ) { __mark_reg_unbounded ( dst_reg ) ; __update_reg_bounds ( dst_reg ) ; break ; } dst_reg -> umin_value *= umin_val ; dst_reg -> umax_value *= umax_val ; if ( dst_reg -> umax_value > S64_MAX ) { dst_reg -> smin_value = S64_MIN ; dst_reg -> smax_value = S64_MAX ; } else { dst_reg -> smin_value = dst_reg -> umin_value ; dst_reg -> smax_value = dst_reg -> umax_value ; } break ; case BPF_AND : if ( src_known && dst_known ) { __mark_reg_known ( dst_reg , dst_reg -> var_off . value & src_reg . var_off . value ) ; break ; } dst_reg -> var_off = tnum_and ( dst_reg -> var_off , src_reg . var_off ) ; dst_reg -> umin_value = dst_reg -> var_off . value ; dst_reg -> umax_value = min ( dst_reg -> umax_value , umax_val ) ; if ( dst_reg -> smin_value < 0 || smin_val < 0 ) { dst_reg -> smin_value = S64_MIN ; dst_reg -> smax_value = S64_MAX ; } else { dst_reg -> smin_value = dst_reg -> umin_value ; dst_reg -> smax_value = dst_reg -> umax_value ; } __update_reg_bounds ( dst_reg ) ; break ; case BPF_OR : if ( src_known && dst_known ) { __mark_reg_known ( dst_reg , dst_reg -> var_off . value | src_reg . var_off . value ) ; break ; } dst_reg -> var_off = tnum_or ( dst_reg -> var_off , src_reg . var_off ) ; dst_reg -> umin_value = max ( dst_reg -> umin_value , umin_val ) ; dst_reg -> umax_value = dst_reg -> var_off . value | dst_reg -> var_off . mask ; if ( dst_reg -> smin_value < 0 || smin_val < 0 ) { dst_reg -> smin_value = S64_MIN ; dst_reg -> smax_value = S64_MAX ; } else { dst_reg -> smin_value = dst_reg -> umin_value ; dst_reg -> smax_value = dst_reg -> umax_value ; } __update_reg_bounds ( dst_reg ) ; break ; case BPF_LSH : if ( umax_val > 63 ) { mark_reg_unknown ( env , regs , insn -> dst_reg ) ; break ; } dst_reg -> smin_value = S64_MIN ; dst_reg -> smax_value = S64_MAX ; if ( dst_reg -> umax_value > 1ULL << ( 63 - umax_val ) ) { dst_reg -> umin_value = 0 ; dst_reg -> umax_value = U64_MAX ; } else { dst_reg -> umin_value <<= umin_val ; dst_reg -> umax_value <<= umax_val ; } if ( src_known ) dst_reg -> var_off = tnum_lshift ( dst_reg -> var_off , umin_val ) ; else dst_reg -> var_off = tnum_lshift ( tnum_unknown , umin_val ) ; __update_reg_bounds ( dst_reg ) ; break ; case BPF_RSH : if ( umax_val > 63 ) { mark_reg_unknown ( env , regs , insn -> dst_reg ) ; break ; } dst_reg -> smin_value = S64_MIN ; dst_reg -> smax_value = S64_MAX ; if ( src_known ) dst_reg -> var_off = tnum_rshift ( dst_reg -> var_off , umin_val ) ; else dst_reg -> var_off = tnum_rshift ( tnum_unknown , umin_val ) ; dst_reg -> umin_value >>= umax_val ; dst_reg -> umax_value >>= umin_val ; __update_reg_bounds ( dst_reg ) ; break ; default : mark_reg_unknown ( env , regs , insn -> dst_reg ) ; break ; } __reg_deduce_bounds ( dst_reg ) ; __reg_bound_offset ( dst_reg ) ; return 0 ; }\n",
      "fixed_code": "<S2SV_ModStart> BPF_ALU64 ) { coerce_reg_to_size ( dst_reg , 4 ) ; coerce_reg_to_size <S2SV_ModEnd> ( & src_reg <S2SV_ModStart> ( & src_reg , 4\n",
      "source_code_length": 5017,
      "target_code_length": 144,
      "vulnerability_patterns": {
        "null_pointer": 54,
        "total": 54
      },
      "total_patterns": 54,
      "original_address": "https://github.com/torvalds/linux/commit/0c17d1d2c61936401f4702e1846e2c19b200f958",
      "discovery_time": "2017-12-27T17:08Z",
      "project_commit_id": "torvalds@linux/0c17d1d2c61936401f4702e1846e2c19b200f958",
      "extraction_time": "2025-08-31T15:41:49.191590",
      "label": 1,
      "vulnerability_type": "buffer_overflow",
      "difficulty_level": "advanced",
      "risk_factors": [
        "system_crash",
        "memory_corruption",
        "arbitrary_code_execution"
      ],
      "attack_vectors": [
        "memory_manipulation",
        "malicious_input",
        "code_analysis",
        "buffer_overflow",
        "reverse_engineering",
        "fuzzing"
      ],
      "mitigation_strategies": [
        "safe_string_functions",
        "dynamic_analysis",
        "code_review",
        "static_analysis",
        "memory_safety_checks",
        "input_validation",
        "fuzzing",
        "bounds_checking",
        "secure_coding_practices"
      ],
      "code_differences": {
        "has_differences": true,
        "source_lines": 2,
        "target_lines": 2,
        "character_differences": 4873,
        "similarity_percentage": 8.256880733944955
      },
      "vulnerability_location": {
        "vulnerability_present": true,
        "fix_applied": true,
        "code_changed": true,
        "estimated_lines_changed": 0
      }
    },
    {
      "cve_id": "CVE-2016-0838",
      "cwe_id": "CWE-119",
      "cwe_name": "Buffer Overflow",
      "project": "external",
      "severity": "critical",
      "weaponization_score": 7.0,
      "is_critical": true,
      "is_weaponizable": true,
      "is_high_priority_project": false,
      "vulnerable_code": "CWE-119 void WT_NoiseGenerator ( S_WT_VOICE * pWTVoice , S_WT_INT_FRAME * pWTIntFrame ) { EAS_PCM * pOutputBuffer ; EAS_I32 phaseInc ; EAS_I32 tmp0 ; EAS_I32 tmp1 ; EAS_I32 nInterpolatedSample ; EAS_I32 numSamples ; numSamples = pWTIntFrame -> numSamples ; if ( numSamples <= 0 ) { <S2SV_StartBug> ALOGE ( \"b/26366256\" ) ; <S2SV_EndBug> return ; } pOutputBuffer = pWTIntFrame -> pAudioBuffer ; phaseInc = pWTIntFrame -> frame . phaseIncrement ; tmp0 = ( EAS_I32 ) ( pWTVoice -> phaseAccum ) >> 18 ; tmp1 = ( EAS_I32 ) ( pWTVoice -> loopEnd ) >> 18 ; while ( numSamples -- ) { nInterpolatedSample = MULT_AUDIO_COEF ( tmp0 , ( PHASE_ONE - pWTVoice -> phaseFrac ) ) ; nInterpolatedSample += MULT_AUDIO_COEF ( tmp1 , pWTVoice -> phaseFrac ) ; * pOutputBuffer ++ = ( EAS_PCM ) nInterpolatedSample ; pWTVoice -> phaseFrac += ( EAS_U32 ) phaseInc ; if ( GET_PHASE_INT_PART ( pWTVoice -> phaseFrac ) ) { tmp0 = tmp1 ; pWTVoice -> phaseAccum = pWTVoice -> loopEnd ; pWTVoice -> loopEnd = ( 5 * pWTVoice -> loopEnd + 1 ) ; tmp1 = ( EAS_I32 ) ( pWTVoice -> loopEnd ) >> 18 ; pWTVoice -> phaseFrac = GET_PHASE_FRAC_PART ( pWTVoice -> phaseFrac ) ; } } }\n",
      "fixed_code": "<S2SV_ModStart> ALOGE ( \"b/26366256\" ) ; android_errorWriteLog ( 0x534e4554 , \"26366256\"\n",
      "source_code_length": 1142,
      "target_code_length": 89,
      "vulnerability_patterns": {
        "integer_overflow": 4,
        "null_pointer": 16,
        "total": 20
      },
      "total_patterns": 20,
      "original_address": "https://android.googlesource.com/platform/external/sonivox/+/24d7c408c52143bce7b49de82f3913fd8d1219cf",
      "discovery_time": "2016-04-18T00:59Z",
      "project_commit_id": "external@sonivox/24d7c408c52143bce7b49de82f3913fd8d1219cf",
      "extraction_time": "2025-08-31T15:41:49.191645",
      "label": 1,
      "vulnerability_type": "buffer_overflow",
      "difficulty_level": "advanced",
      "risk_factors": [
        "system_crash",
        "memory_corruption",
        "arbitrary_code_execution"
      ],
      "attack_vectors": [
        "memory_manipulation",
        "malicious_input",
        "code_analysis",
        "buffer_overflow",
        "reverse_engineering",
        "fuzzing"
      ],
      "mitigation_strategies": [
        "safe_string_functions",
        "dynamic_analysis",
        "code_review",
        "static_analysis",
        "memory_safety_checks",
        "input_validation",
        "fuzzing",
        "bounds_checking",
        "secure_coding_practices"
      ],
      "code_differences": {
        "has_differences": true,
        "source_lines": 2,
        "target_lines": 2,
        "character_differences": 1053,
        "similarity_percentage": 10.344827586206897
      },
      "vulnerability_location": {
        "vulnerability_present": true,
        "fix_applied": true,
        "code_changed": true,
        "estimated_lines_changed": 0
      }
    },
    {
      "cve_id": "CVE-2016-1621",
      "cwe_id": "CWE-119",
      "cwe_name": "Buffer Overflow",
      "project": "external",
      "severity": "critical",
      "weaponization_score": 7.0,
      "is_critical": true,
      "is_weaponizable": true,
      "is_high_priority_project": false,
      "vulnerable_code": "CWE-119 int main ( int argc , char * * argv ) { int frame_cnt = 0 ; FILE * outfile = NULL ; vpx_codec_ctx_t codec ; const VpxInterface * decoder = NULL ; VpxVideoReader * reader = NULL ; const VpxVideoInfo * info = NULL ; int n = 0 ; int m = 0 ; int is_range = 0 ; char * nptr = NULL ; exec_name = argv [ 0 ] ; if ( argc != 4 ) die ( \"Invalid<S2SV_blank>number<S2SV_blank>of<S2SV_blank>arguments.\" ) ; reader = vpx_video_reader_open ( argv [ 1 ] ) ; if ( ! reader ) die ( \"Failed<S2SV_blank>to<S2SV_blank>open<S2SV_blank>%s<S2SV_blank>for<S2SV_blank>reading.\" , argv [ 1 ] ) ; if ( ! ( outfile = fopen ( argv [ 2 ] , \"wb\" ) ) ) die ( \"Failed<S2SV_blank>to<S2SV_blank>open<S2SV_blank>%s<S2SV_blank>for<S2SV_blank>writing.\" , argv [ 2 ] ) ; n = strtol ( argv [ 3 ] , & nptr , 0 ) ; m = strtol ( nptr + 1 , NULL , 0 ) ; is_range = ( * nptr == '-' ) ; if ( ! n || ! m || ( * nptr != '-' && * nptr != '/' ) ) die ( \"Couldn\\'t<S2SV_blank>parse<S2SV_blank>pattern<S2SV_blank>%s.\\\\n\" , argv [ 3 ] ) ; info = vpx_video_reader_get_info ( reader ) ; decoder = get_vpx_decoder_by_fourcc ( info -> codec_fourcc ) ; if ( ! decoder ) die ( \"Unknown<S2SV_blank>input<S2SV_blank>codec.\" ) ; <S2SV_StartBug> printf ( \"Using<S2SV_blank>%s\\\\n\" , vpx_codec_iface_name ( decoder -> interface ( ) ) ) ; <S2SV_EndBug> <S2SV_StartBug> if ( vpx_codec_dec_init ( & codec , decoder -> interface ( ) , NULL , 0 ) ) <S2SV_EndBug> die_codec ( & codec , \"Failed<S2SV_blank>to<S2SV_blank>initialize<S2SV_blank>decoder.\" ) ; while ( vpx_video_reader_read_frame ( reader ) ) { vpx_codec_iter_t iter = NULL ; vpx_image_t * img = NULL ; size_t frame_size = 0 ; int skip ; const unsigned char * frame = vpx_video_reader_get_frame ( reader , & frame_size ) ; if ( vpx_codec_decode ( & codec , frame , ( unsigned int ) frame_size , NULL , 0 ) ) die_codec ( & codec , \"Failed<S2SV_blank>to<S2SV_blank>decode<S2SV_blank>frame.\" ) ; ++ frame_cnt ; skip = ( is_range && frame_cnt >= n && frame_cnt <= m ) || ( ! is_range && m - ( frame_cnt - 1 ) % m <= n ) ; if ( ! skip ) { putc ( '.' , stdout ) ; while ( ( img = vpx_codec_get_frame ( & codec , & iter ) ) != NULL ) vpx_img_write ( img , outfile ) ; } else { putc ( 'X' , stdout ) ; } fflush ( stdout ) ; } printf ( \"Processed<S2SV_blank>%d<S2SV_blank>frames.\\\\n\" , frame_cnt ) ; if ( vpx_codec_destroy ( & codec ) ) die_codec ( & codec , \"Failed<S2SV_blank>to<S2SV_blank>destroy<S2SV_blank>codec.\" ) ; printf ( \"Play:<S2SV_blank>ffplay<S2SV_blank>-f<S2SV_blank>rawvideo<S2SV_blank>-pix_fmt<S2SV_blank>yuv420p<S2SV_blank>-s<S2SV_blank>%dx%d<S2SV_blank>%s\\\\n\" , info -> frame_width , info -> frame_height , argv [ 2 ] ) ; vpx_video_reader_close ( reader ) ; fclose ( outfile ) ; return EXIT_SUCCESS ; }\n",
      "fixed_code": "<S2SV_ModStart> ( decoder -> codec_interface <S2SV_ModEnd> ( ) ) <S2SV_ModStart> , decoder -> codec_interface <S2SV_ModEnd> ( ) ,\n",
      "source_code_length": 2710,
      "target_code_length": 130,
      "vulnerability_patterns": {
        "integer_overflow": 5,
        "null_pointer": 23,
        "total": 28
      },
      "total_patterns": 28,
      "original_address": "https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426",
      "discovery_time": "2016-03-12T21:59Z",
      "project_commit_id": "external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426",
      "extraction_time": "2025-08-31T15:41:49.191660",
      "label": 1,
      "vulnerability_type": "buffer_overflow",
      "difficulty_level": "advanced",
      "risk_factors": [
        "system_crash",
        "memory_corruption",
        "arbitrary_code_execution"
      ],
      "attack_vectors": [
        "memory_manipulation",
        "malicious_input",
        "code_analysis",
        "buffer_overflow",
        "reverse_engineering",
        "fuzzing"
      ],
      "mitigation_strategies": [
        "safe_string_functions",
        "dynamic_analysis",
        "code_review",
        "static_analysis",
        "memory_safety_checks",
        "input_validation",
        "fuzzing",
        "bounds_checking",
        "secure_coding_practices"
      ],
      "code_differences": {
        "has_differences": true,
        "source_lines": 2,
        "target_lines": 2,
        "character_differences": 2580,
        "similarity_percentage": 4.464285714285714
      },
      "vulnerability_location": {
        "vulnerability_present": true,
        "fix_applied": true,
        "code_changed": true,
        "estimated_lines_changed": 0
      }
    },
    {
      "cve_id": "CVE-2018-8787",
      "cwe_id": "CWE-787",
      "cwe_name": "Out-of-bounds Write",
      "project": "FreeRDP",
      "severity": "critical",
      "weaponization_score": 7.0,
      "is_critical": true,
      "is_weaponizable": true,
      "is_high_priority_project": false,
      "vulnerable_code": "CWE-190 static BOOL gdi_Bitmap_Decompress ( rdpContext * context , rdpBitmap * bitmap , const BYTE * pSrcData , UINT32 DstWidth , UINT32 DstHeight , UINT32 bpp , UINT32 length , BOOL compressed , UINT32 codecId ) { UINT32 SrcSize = length ; rdpGdi * gdi = context -> gdi ; <S2SV_StartBug> bitmap -> compressed = FALSE ; <S2SV_EndBug> bitmap -> format = gdi -> dstFormat ; <S2SV_StartBug> bitmap -> length = DstWidth * DstHeight * GetBytesPerPixel ( bitmap -> format ) ; <S2SV_EndBug> bitmap -> data = ( BYTE * ) _aligned_malloc ( bitmap -> length , 16 ) ; if ( ! bitmap -> data ) return FALSE ; if ( compressed ) { if ( bpp < 32 ) { if ( ! interleaved_decompress ( context -> codecs -> interleaved , pSrcData , SrcSize , DstWidth , DstHeight , bpp , bitmap -> data , bitmap -> format , 0 , 0 , 0 , DstWidth , DstHeight , & gdi -> palette ) ) return FALSE ; } else { if ( ! planar_decompress ( context -> codecs -> planar , pSrcData , SrcSize , DstWidth , DstHeight , bitmap -> data , bitmap -> format , 0 , 0 , 0 , DstWidth , DstHeight , TRUE ) ) return FALSE ; } } else { const UINT32 SrcFormat = gdi_get_pixel_format ( bpp ) ; const size_t sbpp = GetBytesPerPixel ( SrcFormat ) ; const size_t dbpp = GetBytesPerPixel ( bitmap -> format ) ; if ( ( sbpp == 0 ) || ( dbpp == 0 ) ) return FALSE ; else { const size_t dstSize = SrcSize * dbpp / sbpp ; if ( dstSize < bitmap -> length ) return FALSE ; } if ( ! freerdp_image_copy ( bitmap -> data , bitmap -> format , 0 , 0 , 0 , DstWidth , DstHeight , pSrcData , SrcFormat , 0 , 0 , 0 , & gdi -> palette , FREERDP_FLIP_VERTICAL ) ) return FALSE ; } return TRUE ; }\n",
      "fixed_code": "<S2SV_ModStart> -> gdi ; UINT32 size = DstWidth * DstHeight ; <S2SV_ModStart> -> dstFormat ; if ( ( GetBytesPerPixel ( bitmap -> format ) == 0 ) || ( DstWidth == 0 ) || ( DstHeight == 0 ) || ( DstWidth > UINT32_MAX / DstHeight ) || ( size > ( UINT32_MAX / GetBytesPerPixel ( bitmap -> format ) ) ) ) return FALSE ; size *= GetBytesPerPixel ( bitmap -> format ) ; <S2SV_ModStart> -> length = size <S2SV_ModEnd> ; bitmap ->\n",
      "source_code_length": 1612,
      "target_code_length": 422,
      "vulnerability_patterns": {
        "null_pointer": 23,
        "total": 23
      },
      "total_patterns": 23,
      "original_address": "https://github.com/FreeRDP/FreeRDP/commit/09b9d4f1994a674c4ec85b4947aa656eda1aed8a",
      "discovery_time": "2018-11-29T18:29Z",
      "project_commit_id": "FreeRDP@FreeRDP/09b9d4f1994a674c4ec85b4947aa656eda1aed8a",
      "extraction_time": "2025-08-31T15:41:49.191678",
      "label": 1,
      "vulnerability_type": "out-of-bounds_write",
      "difficulty_level": "advanced",
      "risk_factors": [
        "system_crash",
        "memory_corruption",
        "arbitrary_code_execution"
      ],
      "attack_vectors": [
        "memory_manipulation",
        "malicious_input",
        "code_analysis",
        "buffer_overflow",
        "reverse_engineering",
        "fuzzing"
      ],
      "mitigation_strategies": [
        "safe_string_functions",
        "dynamic_analysis",
        "code_review",
        "static_analysis",
        "memory_safety_checks",
        "input_validation",
        "fuzzing",
        "bounds_checking",
        "secure_coding_practices"
      ],
      "code_differences": {
        "has_differences": true,
        "source_lines": 2,
        "target_lines": 2,
        "character_differences": 1190,
        "similarity_percentage": 30.985915492957744
      },
      "vulnerability_location": {
        "vulnerability_present": true,
        "fix_applied": true,
        "code_changed": true,
        "estimated_lines_changed": 0
      }
    },
    {
      "cve_id": "CVE-2013-1773",
      "cwe_id": "CWE-119",
      "cwe_name": "Buffer Overflow",
      "project": "torvalds",
      "severity": "critical",
      "weaponization_score": 7.0,
      "is_critical": true,
      "is_weaponizable": true,
      "is_high_priority_project": false,
      "vulnerable_code": "CWE-119 static int xlate_to_uni ( const unsigned char * name , int len , unsigned char * outname , int * longlen , int * outlen , int escape , int utf8 , struct nls_table * nls ) { const unsigned char * ip ; unsigned char nc ; unsigned char * op ; unsigned int ec ; int i , k , fill ; int charlen ; if ( utf8 ) { <S2SV_StartBug> * outlen = utf8s_to_utf16s ( name , len , ( wchar_t * ) outname ) ; <S2SV_EndBug> if ( * outlen < 0 ) return * outlen ; else if ( * outlen > FAT_LFN_LEN ) return - ENAMETOOLONG ; op = & outname [ * outlen * sizeof ( wchar_t ) ] ; } else { if ( nls ) { for ( i = 0 , ip = name , op = outname , * outlen = 0 ; i < len && * outlen <= FAT_LFN_LEN ; * outlen += 1 ) { if ( escape && ( * ip == ':' ) ) { if ( i > len - 5 ) return - EINVAL ; ec = 0 ; for ( k = 1 ; k < 5 ; k ++ ) { nc = ip [ k ] ; ec <<= 4 ; if ( nc >= '0' && nc <= '9' ) { ec |= nc - '0' ; continue ; } if ( nc >= 'a' && nc <= 'f' ) { ec |= nc - ( 'a' - 10 ) ; continue ; } if ( nc >= 'A' && nc <= 'F' ) { ec |= nc - ( 'A' - 10 ) ; continue ; } return - EINVAL ; } * op ++ = ec & 0xFF ; * op ++ = ec >> 8 ; ip += 5 ; i += 5 ; } else { if ( ( charlen = nls -> char2uni ( ip , len - i , ( wchar_t * ) op ) ) < 0 ) return - EINVAL ; ip += charlen ; i += charlen ; op += 2 ; } } if ( i < len ) return - ENAMETOOLONG ; } else { for ( i = 0 , ip = name , op = outname , * outlen = 0 ; i < len && * outlen <= FAT_LFN_LEN ; i ++ , * outlen += 1 ) { * op ++ = * ip ++ ; * op ++ = 0 ; } if ( i < len ) return - ENAMETOOLONG ; } } * longlen = * outlen ; if ( * outlen % 13 ) { * op ++ = 0 ; * op ++ = 0 ; * outlen += 1 ; if ( * outlen % 13 ) { fill = 13 - ( * outlen % 13 ) ; for ( i = 0 ; i < fill ; i ++ ) { * op ++ = 0xff ; * op ++ = 0xff ; } * outlen += fill ; } } return 0 ; }\n",
      "fixed_code": "<S2SV_ModStart> , len , UTF16_HOST_ENDIAN , <S2SV_ModStart> * ) outname , FAT_LFN_LEN + 2\n",
      "source_code_length": 1761,
      "target_code_length": 90,
      "vulnerability_patterns": {
        "integer_overflow": 21,
        "null_pointer": 1,
        "total": 22
      },
      "total_patterns": 22,
      "original_address": "https://github.com/torvalds/linux/commit/0720a06a7518c9d0c0125bd5d1f3b6264c55c3dd",
      "discovery_time": "2013-02-28T19:55Z",
      "project_commit_id": "torvalds@linux/0720a06a7518c9d0c0125bd5d1f3b6264c55c3dd",
      "extraction_time": "2025-08-31T15:41:49.191761",
      "label": 1,
      "vulnerability_type": "buffer_overflow",
      "difficulty_level": "advanced",
      "risk_factors": [
        "system_crash",
        "memory_corruption",
        "arbitrary_code_execution"
      ],
      "attack_vectors": [
        "memory_manipulation",
        "malicious_input",
        "code_analysis",
        "buffer_overflow",
        "reverse_engineering",
        "fuzzing"
      ],
      "mitigation_strategies": [
        "safe_string_functions",
        "dynamic_analysis",
        "code_review",
        "static_analysis",
        "memory_safety_checks",
        "input_validation",
        "fuzzing",
        "bounds_checking",
        "secure_coding_practices"
      ],
      "code_differences": {
        "has_differences": true,
        "source_lines": 2,
        "target_lines": 2,
        "character_differences": 1671,
        "similarity_percentage": 8.333333333333332
      },
      "vulnerability_location": {
        "vulnerability_present": true,
        "fix_applied": true,
        "code_changed": true,
        "estimated_lines_changed": 0
      }
    },
    {
      "cve_id": "CVE-2016-1621",
      "cwe_id": "CWE-119",
      "cwe_name": "Buffer Overflow",
      "project": "external",
      "severity": "critical",
      "weaponization_score": 7.0,
      "is_critical": true,
      "is_weaponizable": true,
      "is_high_priority_project": false,
      "vulnerable_code": "CWE-119 int main ( int argc , char * * argv ) { int frame_cnt = 0 ; FILE * outfile = NULL ; vpx_codec_ctx_t codec ; const VpxInterface * decoder = NULL ; VpxVideoReader * reader = NULL ; const VpxVideoInfo * info = NULL ; int n = 0 ; int m = 0 ; int is_range = 0 ; char * nptr = NULL ; exec_name = argv [ 0 ] ; if ( argc != 4 ) die ( \"Invalid<S2SV_blank>number<S2SV_blank>of<S2SV_blank>arguments.\" ) ; reader = vpx_video_reader_open ( argv [ 1 ] ) ; if ( ! reader ) die ( \"Failed<S2SV_blank>to<S2SV_blank>open<S2SV_blank>%s<S2SV_blank>for<S2SV_blank>reading.\" , argv [ 1 ] ) ; if ( ! ( outfile = fopen ( argv [ 2 ] , \"wb\" ) ) ) die ( \"Failed<S2SV_blank>to<S2SV_blank>open<S2SV_blank>%s<S2SV_blank>for<S2SV_blank>writing.\" , argv [ 2 ] ) ; n = strtol ( argv [ 3 ] , & nptr , 0 ) ; m = strtol ( nptr + 1 , NULL , 0 ) ; is_range = ( * nptr == '-' ) ; if ( ! n || ! m || ( * nptr != '-' && * nptr != '/' ) ) die ( \"Couldn\\'t<S2SV_blank>parse<S2SV_blank>pattern<S2SV_blank>%s.\\\\n\" , argv [ 3 ] ) ; info = vpx_video_reader_get_info ( reader ) ; decoder = get_vpx_decoder_by_fourcc ( info -> codec_fourcc ) ; if ( ! decoder ) die ( \"Unknown<S2SV_blank>input<S2SV_blank>codec.\" ) ; <S2SV_StartBug> printf ( \"Using<S2SV_blank>%s\\\\n\" , vpx_codec_iface_name ( decoder -> interface ( ) ) ) ; <S2SV_EndBug> <S2SV_StartBug> if ( vpx_codec_dec_init ( & codec , decoder -> interface ( ) , NULL , 0 ) ) <S2SV_EndBug> die_codec ( & codec , \"Failed<S2SV_blank>to<S2SV_blank>initialize<S2SV_blank>decoder.\" ) ; while ( vpx_video_reader_read_frame ( reader ) ) { vpx_codec_iter_t iter = NULL ; vpx_image_t * img = NULL ; size_t frame_size = 0 ; int skip ; const unsigned char * frame = vpx_video_reader_get_frame ( reader , & frame_size ) ; if ( vpx_codec_decode ( & codec , frame , ( unsigned int ) frame_size , NULL , 0 ) ) die_codec ( & codec , \"Failed<S2SV_blank>to<S2SV_blank>decode<S2SV_blank>frame.\" ) ; ++ frame_cnt ; skip = ( is_range && frame_cnt >= n && frame_cnt <= m ) || ( ! is_range && m - ( frame_cnt - 1 ) % m <= n ) ; if ( ! skip ) { putc ( '.' , stdout ) ; while ( ( img = vpx_codec_get_frame ( & codec , & iter ) ) != NULL ) vpx_img_write ( img , outfile ) ; } else { putc ( 'X' , stdout ) ; } fflush ( stdout ) ; } printf ( \"Processed<S2SV_blank>%d<S2SV_blank>frames.\\\\n\" , frame_cnt ) ; if ( vpx_codec_destroy ( & codec ) ) die_codec ( & codec , \"Failed<S2SV_blank>to<S2SV_blank>destroy<S2SV_blank>codec.\" ) ; printf ( \"Play:<S2SV_blank>ffplay<S2SV_blank>-f<S2SV_blank>rawvideo<S2SV_blank>-pix_fmt<S2SV_blank>yuv420p<S2SV_blank>-s<S2SV_blank>%dx%d<S2SV_blank>%s\\\\n\" , info -> frame_width , info -> frame_height , argv [ 2 ] ) ; vpx_video_reader_close ( reader ) ; fclose ( outfile ) ; return EXIT_SUCCESS ; }\n",
      "fixed_code": "<S2SV_ModStart> ( decoder -> codec_interface <S2SV_ModEnd> ( ) ) <S2SV_ModStart> , decoder -> codec_interface <S2SV_ModEnd> ( ) ,\n",
      "source_code_length": 2710,
      "target_code_length": 130,
      "vulnerability_patterns": {
        "integer_overflow": 5,
        "null_pointer": 7,
        "total": 12
      },
      "total_patterns": 12,
      "original_address": "https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426",
      "discovery_time": "2016-03-12T21:59Z",
      "project_commit_id": "external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426",
      "extraction_time": "2025-08-31T15:41:49.191795",
      "label": 1,
      "vulnerability_type": "buffer_overflow",
      "difficulty_level": "advanced",
      "risk_factors": [
        "system_crash",
        "memory_corruption",
        "arbitrary_code_execution"
      ],
      "attack_vectors": [
        "memory_manipulation",
        "malicious_input",
        "code_analysis",
        "buffer_overflow",
        "reverse_engineering",
        "fuzzing"
      ],
      "mitigation_strategies": [
        "safe_string_functions",
        "dynamic_analysis",
        "code_review",
        "static_analysis",
        "memory_safety_checks",
        "input_validation",
        "fuzzing",
        "bounds_checking",
        "secure_coding_practices"
      ],
      "code_differences": {
        "has_differences": true,
        "source_lines": 2,
        "target_lines": 2,
        "character_differences": 2580,
        "similarity_percentage": 4.464285714285714
      },
      "vulnerability_location": {
        "vulnerability_present": true,
        "fix_applied": true,
        "code_changed": true,
        "estimated_lines_changed": 0
      }
    },
    {
      "cve_id": "CVE-2017-7586",
      "cwe_id": "CWE-119",
      "cwe_name": "Buffer Overflow",
      "project": "erikd",
      "severity": "critical",
      "weaponization_score": 7.0,
      "is_critical": true,
      "is_weaponizable": true,
      "is_high_priority_project": false,
      "vulnerable_code": "CWE-119 int psf_binheader_readf ( SF_PRIVATE * psf , char const * format , ... ) { va_list argptr ; sf_count_t * countptr , countdata ; unsigned char * ucptr , sixteen_bytes [ 16 ] ; unsigned int * intptr , intdata ; unsigned short * shortptr ; char * charptr ; float * floatptr ; double * doubleptr ; char c ; <S2SV_StartBug> int byte_count = 0 , count ; <S2SV_EndBug> if ( ! format ) return psf_ftell ( psf ) ; va_start ( argptr , format ) ; while ( ( c = * format ++ ) ) <S2SV_StartBug> { switch ( c ) <S2SV_EndBug> { case 'e' : psf -> rwf_endian = SF_ENDIAN_LITTLE ; break ; case 'E' : psf -> rwf_endian = SF_ENDIAN_BIG ; break ; case 'm' : intptr = va_arg ( argptr , unsigned int * ) ; <S2SV_StartBug> ucptr = ( unsigned char * ) intptr ; <S2SV_EndBug> byte_count += header_read ( psf , ucptr , sizeof ( int ) ) ; * intptr = GET_MARKER ( ucptr ) ; break ; case 'h' : <S2SV_StartBug> intptr = va_arg ( argptr , unsigned int * ) ; <S2SV_EndBug> ucptr = ( unsigned char * ) intptr ; byte_count += header_read ( psf , sixteen_bytes , sizeof ( sixteen_bytes ) ) ; { int k ; intdata = 0 ; for ( k = 0 ; k < 16 ; k ++ ) intdata ^= sixteen_bytes [ k ] << k ; } * intptr = intdata ; break ; case '1' : charptr = va_arg ( argptr , char * ) ; * charptr = 0 ; byte_count += header_read ( psf , charptr , sizeof ( char ) ) ; break ; case '2' : shortptr = va_arg ( argptr , unsigned short * ) ; * shortptr = 0 ; ucptr = ( unsigned char * ) shortptr ; byte_count += header_read ( psf , ucptr , sizeof ( short ) ) ; if ( psf -> rwf_endian == SF_ENDIAN_BIG ) * shortptr = GET_BE_SHORT ( ucptr ) ; else * shortptr = GET_LE_SHORT ( ucptr ) ; break ; case '3' : intptr = va_arg ( argptr , unsigned int * ) ; * intptr = 0 ; byte_count += header_read ( psf , sixteen_bytes , 3 ) ; if ( psf -> rwf_endian == SF_ENDIAN_BIG ) * intptr = GET_BE_3BYTE ( sixteen_bytes ) ; else * intptr = GET_LE_3BYTE ( sixteen_bytes ) ; break ; case '4' : intptr = va_arg ( argptr , unsigned int * ) ; * intptr = 0 ; ucptr = ( unsigned char * ) intptr ; byte_count += header_read ( psf , ucptr , sizeof ( int ) ) ; if ( psf -> rwf_endian == SF_ENDIAN_BIG ) * intptr = psf_get_be32 ( ucptr , 0 ) ; else * intptr = psf_get_le32 ( ucptr , 0 ) ; break ; case '8' : countptr = va_arg ( argptr , sf_count_t * ) ; * countptr = 0 ; byte_count += header_read ( psf , sixteen_bytes , 8 ) ; if ( psf -> rwf_endian == SF_ENDIAN_BIG ) countdata = psf_get_be64 ( sixteen_bytes , 0 ) ; else countdata = psf_get_le64 ( sixteen_bytes , 0 ) ; * countptr = countdata ; break ; case 'f' : floatptr = va_arg ( argptr , float * ) ; * floatptr = 0.0 ; byte_count += header_read ( psf , floatptr , sizeof ( float ) ) ; if ( psf -> rwf_endian == SF_ENDIAN_BIG ) * floatptr = float32_be_read ( ( unsigned char * ) floatptr ) ; else * floatptr = float32_le_read ( ( unsigned char * ) floatptr ) ; break ; case 'd' : doubleptr = va_arg ( argptr , double * ) ; * doubleptr = 0.0 ; byte_count += header_read ( psf , doubleptr , sizeof ( double ) ) ; if ( psf -> rwf_endian == SF_ENDIAN_BIG ) * doubleptr = double64_be_read ( ( unsigned char * ) doubleptr ) ; else * doubleptr = double64_le_read ( ( unsigned char * ) doubleptr ) ; break ; case 's' : psf_log_printf ( psf , \"Format<S2SV_blank>conversion<S2SV_blank>\\'s\\'<S2SV_blank>not<S2SV_blank>implemented<S2SV_blank>yet.\\\\n\" ) ; break ; case 'b' : charptr = va_arg ( argptr , char * ) ; count = va_arg ( argptr , size_t ) ; <S2SV_StartBug> if ( count > 0 ) <S2SV_EndBug> byte_count += header_read ( psf , charptr , count ) ; break ; <S2SV_StartBug> case 'G' : <S2SV_EndBug> charptr = va_arg ( argptr , char * ) ; count = va_arg ( argptr , size_t ) ; <S2SV_StartBug> if ( count > 0 ) <S2SV_EndBug> byte_count += header_gets ( psf , charptr , count ) ; break ; case 'z' : psf_log_printf ( psf , \"Format<S2SV_blank>conversion<S2SV_blank>\\'z\\'<S2SV_blank>not<S2SV_blank>implemented<S2SV_blank>yet.\\\\n\" ) ; break ; case 'p' : count = va_arg ( argptr , size_t ) ; <S2SV_StartBug> header_seek ( psf , count , SEEK_SET ) ; <S2SV_EndBug> byte_count = count ; break ; case 'j' : count = va_arg ( argptr , size_t ) ; if ( count ) { header_seek ( psf , count , SEEK_CUR ) ; <S2SV_StartBug> byte_count += count ; <S2SV_EndBug> } ; break ; default : psf_log_printf ( psf , \"***<S2SV_blank>Invalid<S2SV_blank>format<S2SV_blank>specifier<S2SV_blank>`%c\\'\\\\n\" , c ) ; psf -> error = SFE_INTERNAL ; break ; } ; } ; va_end ( argptr ) ; return byte_count ; }\n",
      "fixed_code": "<S2SV_ModStart> 0 , count = 0 <S2SV_ModStart> ) ) { if ( psf -> header . indx + 16 >= psf -> header . len && psf_bump_header_allocation ( psf , 16 ) ) return count ; <S2SV_ModStart> * ) ; * intptr = 0 ; <S2SV_ModStart> int * ) ; * intptr = 0 <S2SV_ModStart> size_t ) ; memset ( charptr , 0 , count ) ; byte_count += header_read ( psf , charptr , count ) ; break ; case 'G' : charptr = va_arg ( argptr , char * ) ; count = va_arg ( argptr , size_t ) ; memset ( charptr , 0 , count ) ; if ( psf -> header . indx + count >= psf -> header . len && psf_bump_header_allocation ( psf , count ) ) return 0 ; byte_count += header_gets <S2SV_ModEnd> ( psf , <S2SV_ModStart> break ; case 'z' : psf_log_printf ( psf , \"Format<S2SV_blank>conversion<S2SV_blank>\\'z\\'<S2SV_blank>not<S2SV_blank>implemented<S2SV_blank>yet.\\\\n\" ) ; break ; case 'p' : <S2SV_ModEnd> count = va_arg <S2SV_ModStart> size_t ) ; header_seek ( psf , count , SEEK_SET ) ; byte_count = count ; break ; case 'j' <S2SV_ModEnd> : count = <S2SV_ModStart> , count , <S2SV_ModEnd> SEEK_CUR ) ; <S2SV_ModStart> byte_count += count <S2SV_ModEnd> ; break ;\n",
      "source_code_length": 4424,
      "target_code_length": 1106,
      "vulnerability_patterns": {
        "integer_overflow": 4,
        "null_pointer": 10,
        "total": 14
      },
      "total_patterns": 14,
      "original_address": "https://github.com/erikd/libsndfile/commit/708e996c87c5fae77b104ccfeb8f6db784c32074",
      "discovery_time": "2017-04-07T20:59Z",
      "project_commit_id": "erikd@libsndfile/708e996c87c5fae77b104ccfeb8f6db784c32074",
      "extraction_time": "2025-08-31T15:41:49.191827",
      "label": 1,
      "vulnerability_type": "buffer_overflow",
      "difficulty_level": "advanced",
      "risk_factors": [
        "system_crash",
        "memory_corruption",
        "arbitrary_code_execution"
      ],
      "attack_vectors": [
        "memory_manipulation",
        "malicious_input",
        "code_analysis",
        "buffer_overflow",
        "reverse_engineering",
        "fuzzing"
      ],
      "mitigation_strategies": [
        "safe_string_functions",
        "dynamic_analysis",
        "code_review",
        "static_analysis",
        "memory_safety_checks",
        "input_validation",
        "fuzzing",
        "bounds_checking",
        "secure_coding_practices"
      ],
      "code_differences": {
        "has_differences": true,
        "source_lines": 2,
        "target_lines": 2,
        "character_differences": 3318,
        "similarity_percentage": 29.133858267716533
      },
      "vulnerability_location": {
        "vulnerability_present": true,
        "fix_applied": true,
        "code_changed": true,
        "estimated_lines_changed": 0
      }
    },
    {
      "cve_id": "CVE-2013-1860",
      "cwe_id": "CWE-119",
      "cwe_name": "Buffer Overflow",
      "project": "torvalds",
      "severity": "critical",
      "weaponization_score": 7.0,
      "is_critical": true,
      "is_weaponizable": true,
      "is_high_priority_project": false,
      "vulnerable_code": "CWE-119 static void wdm_in_callback ( struct urb * urb ) { struct wdm_device * desc = urb -> context ; int status = urb -> status ; <S2SV_StartBug> spin_lock ( & desc -> iuspin ) ; <S2SV_EndBug> clear_bit ( WDM_RESPONDING , & desc -> flags ) ; if ( status ) { switch ( status ) { case - ENOENT : dev_dbg ( & desc -> intf -> dev , \"nonzero<S2SV_blank>urb<S2SV_blank>status<S2SV_blank>received:<S2SV_blank>-ENOENT\" ) ; goto skip_error ; case - ECONNRESET : dev_dbg ( & desc -> intf -> dev , \"nonzero<S2SV_blank>urb<S2SV_blank>status<S2SV_blank>received:<S2SV_blank>-ECONNRESET\" ) ; goto skip_error ; case - ESHUTDOWN : dev_dbg ( & desc -> intf -> dev , \"nonzero<S2SV_blank>urb<S2SV_blank>status<S2SV_blank>received:<S2SV_blank>-ESHUTDOWN\" ) ; goto skip_error ; case - EPIPE : dev_err ( & desc -> intf -> dev , \"nonzero<S2SV_blank>urb<S2SV_blank>status<S2SV_blank>received:<S2SV_blank>-EPIPE\\\\n\" ) ; break ; default : dev_err ( & desc -> intf -> dev , \"Unexpected<S2SV_blank>error<S2SV_blank>%d\\\\n\" , status ) ; break ; } } desc -> rerr = status ; <S2SV_StartBug> desc -> reslength = urb -> actual_length ; <S2SV_EndBug> <S2SV_StartBug> memmove ( desc -> ubuf + desc -> length , desc -> inbuf , desc -> reslength ) ; <S2SV_EndBug> desc -> length += desc -> reslength ; skip_error : wake_up ( & desc -> wait ) ; set_bit ( WDM_READ , & desc -> flags ) ; spin_unlock ( & desc -> iuspin ) ; }\n",
      "fixed_code": "<S2SV_ModStart> -> status ; int length = urb -> actual_length ; <S2SV_ModStart> = status ; if ( length + desc -> length > desc -> wMaxCommand ) { set_bit ( WDM_OVERFLOW , & desc -> flags ) ; } else { if ( ! test_bit ( WDM_OVERFLOW , & desc -> flags ) ) { <S2SV_ModEnd> memmove ( desc <S2SV_ModStart> -> inbuf , length ) ; desc -> length += length ; <S2SV_ModStart> desc -> reslength = length ; } } <S2SV_ModEnd> skip_error : wake_up\n",
      "source_code_length": 1386,
      "target_code_length": 433,
      "vulnerability_patterns": {
        "integer_overflow": 3,
        "null_pointer": 35,
        "total": 38
      },
      "total_patterns": 38,
      "original_address": "https://github.com/torvalds/linux/commit/c0f5ecee4e741667b2493c742b60b6218d40b3aa",
      "discovery_time": "2013-03-22T11:59Z",
      "project_commit_id": "torvalds@linux/c0f5ecee4e741667b2493c742b60b6218d40b3aa",
      "extraction_time": "2025-08-31T15:41:49.191885",
      "label": 1,
      "vulnerability_type": "buffer_overflow",
      "difficulty_level": "advanced",
      "risk_factors": [
        "system_crash",
        "memory_corruption",
        "arbitrary_code_execution"
      ],
      "attack_vectors": [
        "memory_manipulation",
        "malicious_input",
        "code_analysis",
        "buffer_overflow",
        "reverse_engineering",
        "fuzzing"
      ],
      "mitigation_strategies": [
        "safe_string_functions",
        "dynamic_analysis",
        "code_review",
        "static_analysis",
        "memory_safety_checks",
        "input_validation",
        "fuzzing",
        "bounds_checking",
        "secure_coding_practices"
      ],
      "code_differences": {
        "has_differences": true,
        "source_lines": 2,
        "target_lines": 2,
        "character_differences": 953,
        "similarity_percentage": 36.11111111111111
      },
      "vulnerability_location": {
        "vulnerability_present": true,
        "fix_applied": true,
        "code_changed": true,
        "estimated_lines_changed": 0
      }
    },
    {
      "cve_id": "CVE-2019-16347",
      "cwe_id": "CWE-787",
      "cwe_name": "Out-of-bounds Write",
      "project": "miniupnp",
      "severity": "critical",
      "weaponization_score": 7.0,
      "is_critical": true,
      "is_weaponizable": true,
      "is_high_priority_project": false,
      "vulnerable_code": "CWE-787 static void WritePixels ( struct ngiflib_img * i , struct ngiflib_decode_context * context , const u8 * pixels , u16 n ) { u16 tocopy ; struct ngiflib_gif * p = i -> parent ; while ( n > 0 ) { tocopy = ( context -> Xtogo < n ) ? context -> Xtogo : n ; if ( ! i -> gce . transparent_flag ) { # ifndef NGIFLIB_INDEXED_ONLY if ( p -> mode & NGIFLIB_MODE_INDEXED ) { # endif ngiflib_memcpy ( context -> frbuff_p . p8 , pixels , tocopy ) ; pixels += tocopy ; context -> frbuff_p . p8 += tocopy ; # ifndef NGIFLIB_INDEXED_ONLY } else { int j ; for ( j = ( int ) tocopy ; j > 0 ; j -- ) { * ( context -> frbuff_p . p32 ++ ) = GifIndexToTrueColor ( i -> palette , * pixels ++ ) ; } } # endif } else { int j ; # ifndef NGIFLIB_INDEXED_ONLY if ( p -> mode & NGIFLIB_MODE_INDEXED ) { # endif for ( j = ( int ) tocopy ; j > 0 ; j -- ) { if ( * pixels != i -> gce . transparent_color ) * context -> frbuff_p . p8 = * pixels ; pixels ++ ; context -> frbuff_p . p8 ++ ; } # ifndef NGIFLIB_INDEXED_ONLY } else { for ( j = ( int ) tocopy ; j > 0 ; j -- ) { if ( * pixels != i -> gce . transparent_color ) { * context -> frbuff_p . p32 = GifIndexToTrueColor ( i -> palette , * pixels ) ; } pixels ++ ; context -> frbuff_p . p32 ++ ; } } # endif } context -> Xtogo -= tocopy ; if ( context -> Xtogo == 0 ) { # ifdef NGIFLIB_ENABLE_CALLBACKS if ( p -> line_cb ) p -> line_cb ( p , context -> line_p , context -> curY ) ; # endif context -> Xtogo = i -> width ; switch ( context -> pass ) { case 0 : context -> curY ++ ; break ; case 1 : context -> curY += 8 ; <S2SV_StartBug> if ( context -> curY >= p -> height ) { <S2SV_EndBug> context -> pass ++ ; context -> curY = i -> posY + 4 ; } break ; case 2 : context -> curY += 8 ; <S2SV_StartBug> if ( context -> curY >= p -> height ) { <S2SV_EndBug> context -> pass ++ ; context -> curY = i -> posY + 2 ; } break ; case 3 : context -> curY += 4 ; <S2SV_StartBug> if ( context -> curY >= p -> height ) { <S2SV_EndBug> context -> pass ++ ; context -> curY = i -> posY + 1 ; } break ; case 4 : context -> curY += 2 ; <S2SV_StartBug> break ; <S2SV_EndBug> } # ifndef NGIFLIB_INDEXED_ONLY if ( p -> mode & NGIFLIB_MODE_INDEXED ) { # endif # ifdef NGIFLIB_ENABLE_CALLBACKS context -> line_p . p8 = p -> frbuff . p8 + ( u32 ) context -> curY * p -> width ; context -> frbuff_p . p8 = context -> line_p . p8 + i -> posX ; # else context -> frbuff_p . p8 = p -> frbuff . p8 + ( u32 ) context -> curY * p -> width + i -> posX ; # endif # ifndef NGIFLIB_INDEXED_ONLY } else { # ifdef NGIFLIB_ENABLE_CALLBACKS context -> line_p . p32 = p -> frbuff . p32 + ( u32 ) context -> curY * p -> width ; context -> frbuff_p . p32 = context -> line_p . p32 + i -> posX ; # else context -> frbuff_p . p32 = p -> frbuff . p32 + ( u32 ) context -> curY * p -> width + i -> posX ; # endif } # endif } n -= tocopy ; } }\n",
      "fixed_code": "<S2SV_ModStart> += 8 ; <S2SV_ModEnd> break ; case <S2SV_ModStart> += 8 ; <S2SV_ModEnd> break ; case <S2SV_ModStart> += 4 ; <S2SV_ModEnd> break ; case <S2SV_ModStart> ; break ; } while ( context -> pass > 0 && context -> pass < 4 && context -> curY >= p -> height ) { switch ( ++ context -> pass ) { case 2 : context -> curY = i -> posY + 4 ; break ; case 3 : context -> curY = i -> posY + 2 ; break ; case 4 : context -> curY = i -> posY + 1 ; break ; }\n",
      "source_code_length": 2828,
      "target_code_length": 454,
      "vulnerability_patterns": {
        "integer_overflow": 21,
        "null_pointer": 71,
        "total": 92
      },
      "total_patterns": 92,
      "original_address": "https://github.com/miniupnp/ngiflib/commit/37d939a6f511d16d4c95678025c235fe62e6417a",
      "discovery_time": "2019-09-16T13:15Z",
      "project_commit_id": "miniupnp@ngiflib/37d939a6f511d16d4c95678025c235fe62e6417a",
      "extraction_time": "2025-08-31T15:41:49.191923",
      "label": 1,
      "vulnerability_type": "out-of-bounds_write",
      "difficulty_level": "advanced",
      "risk_factors": [
        "system_crash",
        "memory_corruption",
        "arbitrary_code_execution"
      ],
      "attack_vectors": [
        "memory_manipulation",
        "malicious_input",
        "code_analysis",
        "buffer_overflow",
        "reverse_engineering",
        "fuzzing"
      ],
      "mitigation_strategies": [
        "safe_string_functions",
        "dynamic_analysis",
        "code_review",
        "static_analysis",
        "memory_safety_checks",
        "input_validation",
        "fuzzing",
        "bounds_checking",
        "secure_coding_practices"
      ],
      "code_differences": {
        "has_differences": true,
        "source_lines": 2,
        "target_lines": 2,
        "character_differences": 2374,
        "similarity_percentage": 34.44444444444444
      },
      "vulnerability_location": {
        "vulnerability_present": true,
        "fix_applied": true,
        "code_changed": true,
        "estimated_lines_changed": 0
      }
    },
    {
      "cve_id": "CVE-2018-8788",
      "cwe_id": "CWE-787",
      "cwe_name": "Out-of-bounds Write",
      "project": "FreeRDP",
      "severity": "critical",
      "weaponization_score": 7.0,
      "is_critical": true,
      "is_weaponizable": true,
      "is_high_priority_project": false,
      "vulnerable_code": "CWE-787 <S2SV_StartBug> static void nsc_rle_decompress_data ( NSC_CONTEXT * context ) <S2SV_EndBug> { UINT16 i ; BYTE * rle ; UINT32 planeSize ; UINT32 originalSize ; <S2SV_StartBug> rle = context -> Planes ; <S2SV_EndBug> for ( i = 0 ; i < 4 ; i ++ ) { originalSize = context -> OrgByteCount [ i ] ; planeSize = context -> PlaneByteCount [ i ] ; if ( planeSize == 0 ) <S2SV_StartBug> FillMemory ( context -> priv -> PlaneBuffers [ i ] , originalSize , 0xFF ) ; <S2SV_EndBug> <S2SV_StartBug> else if ( planeSize < originalSize ) <S2SV_EndBug> <S2SV_StartBug> nsc_rle_decode ( rle , context -> priv -> PlaneBuffers [ i ] , originalSize ) ; <S2SV_EndBug> else CopyMemory ( context -> priv -> PlaneBuffers [ i ] , rle , originalSize ) ; <S2SV_StartBug> rle += planeSize ; <S2SV_EndBug> } <S2SV_StartBug> } <S2SV_EndBug>\n",
      "fixed_code": "<S2SV_ModStart> <S2SV_null> <S2SV_null> static BOOL <S2SV_ModEnd> nsc_rle_decompress_data ( NSC_CONTEXT <S2SV_ModStart> UINT32 originalSize ; if ( ! context ) return FALSE ; <S2SV_ModStart> == 0 ) { if ( context -> priv -> PlaneBuffersLength < originalSize ) return FALSE ; <S2SV_ModStart> 0xFF ) ; } <S2SV_ModStart> < originalSize ) { if ( ! <S2SV_ModStart> i ] , context -> priv -> PlaneBuffersLength , originalSize ) ) return FALSE ; } else { if ( context -> priv -> PlaneBuffersLength < originalSize ) return FALSE ; <S2SV_ModEnd> CopyMemory ( context <S2SV_ModStart> originalSize ) ; } <S2SV_ModStart> planeSize ; } return TRUE ;\n",
      "source_code_length": 817,
      "target_code_length": 635,
      "vulnerability_patterns": {
        "integer_overflow": 8,
        "null_pointer": 10,
        "total": 18
      },
      "total_patterns": 18,
      "original_address": "https://github.com/FreeRDP/FreeRDP/commit/d1112c279bd1a327e8e4d0b5f371458bf2579659",
      "discovery_time": "2018-11-29T18:29Z",
      "project_commit_id": "FreeRDP@FreeRDP/d1112c279bd1a327e8e4d0b5f371458bf2579659",
      "extraction_time": "2025-08-31T15:41:49.191966",
      "label": 1,
      "vulnerability_type": "out-of-bounds_write",
      "difficulty_level": "advanced",
      "risk_factors": [
        "system_crash",
        "memory_corruption",
        "arbitrary_code_execution"
      ],
      "attack_vectors": [
        "memory_manipulation",
        "malicious_input",
        "code_analysis",
        "buffer_overflow",
        "reverse_engineering",
        "fuzzing"
      ],
      "mitigation_strategies": [
        "safe_string_functions",
        "dynamic_analysis",
        "code_review",
        "static_analysis",
        "memory_safety_checks",
        "input_validation",
        "fuzzing",
        "bounds_checking",
        "secure_coding_practices"
      ],
      "code_differences": {
        "has_differences": true,
        "source_lines": 2,
        "target_lines": 2,
        "character_differences": 182,
        "similarity_percentage": 45.28301886792453
      },
      "vulnerability_location": {
        "vulnerability_present": true,
        "fix_applied": true,
        "code_changed": true,
        "estimated_lines_changed": 0
      }
    },
    {
      "cve_id": "CVE-2012-6712",
      "cwe_id": "CWE-119",
      "cwe_name": "Buffer Overflow",
      "project": "torvalds",
      "severity": "critical",
      "weaponization_score": 7.0,
      "is_critical": true,
      "is_weaponizable": true,
      "is_high_priority_project": false,
      "vulnerable_code": "CWE-119 <S2SV_StartBug> static void iwl_sta_ucode_activate ( struct iwl_priv * priv , u8 sta_id ) <S2SV_EndBug> <S2SV_StartBug> { <S2SV_EndBug> if ( ! ( priv -> stations [ sta_id ] . used & IWL_STA_DRIVER_ACTIVE ) ) IWL_ERR ( priv , \"ACTIVATE<S2SV_blank>a<S2SV_blank>non<S2SV_blank>DRIVER<S2SV_blank>active<S2SV_blank>station<S2SV_blank>id<S2SV_blank>%u<S2SV_blank>\" \"addr<S2SV_blank>%pM\\\\n\" , sta_id , priv -> stations [ sta_id ] . sta . sta . addr ) ; if ( priv -> stations [ sta_id ] . used & IWL_STA_UCODE_ACTIVE ) { IWL_DEBUG_ASSOC ( priv , \"STA<S2SV_blank>id<S2SV_blank>%u<S2SV_blank>addr<S2SV_blank>%pM<S2SV_blank>already<S2SV_blank>present<S2SV_blank>in<S2SV_blank>uCode<S2SV_blank>\" \"(according<S2SV_blank>to<S2SV_blank>driver)\\\\n\" , sta_id , priv -> stations [ sta_id ] . sta . sta . addr ) ; } else { priv -> stations [ sta_id ] . used |= IWL_STA_UCODE_ACTIVE ; IWL_DEBUG_ASSOC ( priv , \"Added<S2SV_blank>STA<S2SV_blank>id<S2SV_blank>%u<S2SV_blank>addr<S2SV_blank>%pM<S2SV_blank>to<S2SV_blank>uCode\\\\n\" , sta_id , priv -> stations [ sta_id ] . sta . sta . addr ) ; } <S2SV_StartBug> } <S2SV_EndBug>\n",
      "fixed_code": "<S2SV_ModStart> <S2SV_null> <S2SV_null> static int <S2SV_ModEnd> iwl_sta_ucode_activate ( struct <S2SV_ModStart> sta_id ) { if ( sta_id >= IWLAGN_STATION_COUNT ) { IWL_ERR ( priv , \"invalid<S2SV_blank>sta_id<S2SV_blank>%u\" , sta_id ) ; return - EINVAL ; } <S2SV_ModStart> ) ; } return 0 ;\n",
      "source_code_length": 1110,
      "target_code_length": 289,
      "vulnerability_patterns": {
        "null_pointer": 13,
        "total": 13
      },
      "total_patterns": 13,
      "original_address": "https://github.com/torvalds/linux/commit/2da424b0773cea3db47e1e81db71eeebde8269d4",
      "discovery_time": "2019-07-27T22:15Z",
      "project_commit_id": "torvalds@linux/2da424b0773cea3db47e1e81db71eeebde8269d4",
      "extraction_time": "2025-08-31T15:41:49.191990",
      "label": 1,
      "vulnerability_type": "buffer_overflow",
      "difficulty_level": "advanced",
      "risk_factors": [
        "system_crash",
        "memory_corruption",
        "arbitrary_code_execution"
      ],
      "attack_vectors": [
        "memory_manipulation",
        "malicious_input",
        "code_analysis",
        "buffer_overflow",
        "reverse_engineering",
        "fuzzing"
      ],
      "mitigation_strategies": [
        "safe_string_functions",
        "dynamic_analysis",
        "code_review",
        "static_analysis",
        "memory_safety_checks",
        "input_validation",
        "fuzzing",
        "bounds_checking",
        "secure_coding_practices"
      ],
      "code_differences": {
        "has_differences": true,
        "source_lines": 2,
        "target_lines": 2,
        "character_differences": 821,
        "similarity_percentage": 25.49019607843137
      },
      "vulnerability_location": {
        "vulnerability_present": true,
        "fix_applied": true,
        "code_changed": true,
        "estimated_lines_changed": 0
      }
    },
    {
      "cve_id": "CVE-2016-3820",
      "cwe_id": "CWE-119",
      "cwe_name": "Buffer Overflow",
      "project": "external",
      "severity": "critical",
      "weaponization_score": 7.0,
      "is_critical": true,
      "is_weaponizable": true,
      "is_high_priority_project": false,
      "vulnerable_code": "CWE-119 WORD32 ih264d_parse_nal_unit ( iv_obj_t * dec_hdl , ivd_video_decode_op_t * ps_dec_op , UWORD8 * pu1_buf , UWORD32 u4_length ) { dec_bit_stream_t * ps_bitstrm ; dec_struct_t * ps_dec = ( dec_struct_t * ) dec_hdl -> pv_codec_handle ; ivd_video_decode_ip_t * ps_dec_in = ( ivd_video_decode_ip_t * ) ps_dec -> pv_dec_in ; dec_slice_params_t * ps_cur_slice = ps_dec -> ps_cur_slice ; UWORD8 u1_first_byte , u1_nal_ref_idc ; UWORD8 u1_nal_unit_type ; WORD32 i_status = OK ; ps_bitstrm = ps_dec -> ps_bitstrm ; if ( pu1_buf ) { if ( u4_length ) { ps_dec_op -> u4_frame_decoded_flag = 0 ; ih264d_process_nal_unit ( ps_dec -> ps_bitstrm , pu1_buf , u4_length ) ; SWITCHOFFTRACE ; u1_first_byte = ih264d_get_bits_h264 ( ps_bitstrm , 8 ) ; if ( NAL_FORBIDDEN_BIT ( u1_first_byte ) ) { H264_DEC_DEBUG_PRINT ( \"\\\\nForbidden<S2SV_blank>bit<S2SV_blank>set<S2SV_blank>in<S2SV_blank>Nal<S2SV_blank>Unit,<S2SV_blank>Let\\'s<S2SV_blank>try\\\\n\" ) ; } <S2SV_StartBug> u1_nal_unit_type = NAL_UNIT_TYPE ( u1_first_byte ) ; <S2SV_EndBug> ps_dec -> u1_nal_unit_type = u1_nal_unit_type ; u1_nal_ref_idc = ( UWORD8 ) ( NAL_REF_IDC ( u1_first_byte ) ) ; switch ( u1_nal_unit_type ) { case SLICE_DATA_PARTITION_A_NAL : case SLICE_DATA_PARTITION_B_NAL : case SLICE_DATA_PARTITION_C_NAL : if ( ! ps_dec -> i4_decode_header ) ih264d_parse_slice_partition ( ps_dec , ps_bitstrm ) ; break ; case IDR_SLICE_NAL : case SLICE_NAL : DEBUG_THREADS_PRINTF ( \"Decoding<S2SV_blank><S2SV_blank>a<S2SV_blank>slice<S2SV_blank>NAL\\\\n\" ) ; if ( ! ps_dec -> i4_decode_header ) { if ( ps_dec -> i4_header_decoded == 3 ) { ps_dec -> u4_slice_start_code_found = 1 ; ih264d_rbsp_to_sodb ( ps_dec -> ps_bitstrm ) ; i_status = ih264d_parse_decode_slice ( ( UWORD8 ) ( u1_nal_unit_type == IDR_SLICE_NAL ) , u1_nal_ref_idc , ps_dec ) ; if ( ( ps_dec -> u4_first_slice_in_pic != 0 ) && ( ( ps_dec -> ps_dec_err_status -> u1_err_flag & REJECT_CUR_PIC ) == 0 ) ) { ps_dec -> u4_first_slice_in_pic = 1 ; } if ( i_status != OK ) { return i_status ; } } else { H264_DEC_DEBUG_PRINT ( \"\\\\nSlice<S2SV_blank>NAL<S2SV_blank>Supplied<S2SV_blank>but<S2SV_blank>no<S2SV_blank>header<S2SV_blank>has<S2SV_blank>been<S2SV_blank>supplied\\\\n\" ) ; } } break ; case SEI_NAL : if ( ! ps_dec -> i4_decode_header ) { ih264d_rbsp_to_sodb ( ps_dec -> ps_bitstrm ) ; i_status = ih264d_parse_sei_message ( ps_dec , ps_bitstrm ) ; if ( i_status != OK ) return i_status ; ih264d_parse_sei ( ps_dec , ps_bitstrm ) ; } break ; case SEQ_PARAM_NAL : ih264d_rbsp_to_sodb ( ps_dec -> ps_bitstrm ) ; i_status = ih264d_parse_sps ( ps_dec , ps_bitstrm ) ; if ( i_status == ERROR_INV_SPS_PPS_T ) return i_status ; if ( ! i_status ) ps_dec -> i4_header_decoded |= 0x1 ; break ; case PIC_PARAM_NAL : ih264d_rbsp_to_sodb ( ps_dec -> ps_bitstrm ) ; i_status = ih264d_parse_pps ( ps_dec , ps_bitstrm ) ; if ( i_status == ERROR_INV_SPS_PPS_T ) return i_status ; if ( ! i_status ) ps_dec -> i4_header_decoded |= 0x2 ; break ; case ACCESS_UNIT_DELIMITER_RBSP : if ( ! ps_dec -> i4_decode_header ) { ih264d_access_unit_delimiter_rbsp ( ps_dec ) ; } break ; case END_OF_STREAM_RBSP : if ( ! ps_dec -> i4_decode_header ) { ih264d_parse_end_of_stream ( ps_dec ) ; } break ; case FILLER_DATA_NAL : if ( ! ps_dec -> i4_decode_header ) { ih264d_parse_filler_data ( ps_dec , ps_bitstrm ) ; } break ; default : H264_DEC_DEBUG_PRINT ( \"\\\\nUnknown<S2SV_blank>NAL<S2SV_blank>type<S2SV_blank>%d\\\\n\" , u1_nal_unit_type ) ; break ; } } } return i_status ; }\n",
      "fixed_code": "<S2SV_ModStart> u1_first_byte ) ; if ( ( ps_dec -> u2_total_mbs_coded != 0 ) && ( u1_nal_unit_type > IDR_SLICE_NAL ) ) { return ERROR_INCOMPLETE_FRAME ; }\n",
      "source_code_length": 3448,
      "target_code_length": 155,
      "vulnerability_patterns": {
        "null_pointer": 29,
        "total": 29
      },
      "total_patterns": 29,
      "original_address": "https://android.googlesource.com/platform/external/libavc/+/a78887bcffbc2995cf9ed72e0697acf560875e9e",
      "discovery_time": "2016-08-05T20:59Z",
      "project_commit_id": "external@libavc/a78887bcffbc2995cf9ed72e0697acf560875e9e",
      "extraction_time": "2025-08-31T15:41:49.192023",
      "label": 1,
      "vulnerability_type": "buffer_overflow",
      "difficulty_level": "advanced",
      "risk_factors": [
        "system_crash",
        "memory_corruption",
        "arbitrary_code_execution"
      ],
      "attack_vectors": [
        "memory_manipulation",
        "malicious_input",
        "code_analysis",
        "buffer_overflow",
        "reverse_engineering",
        "fuzzing"
      ],
      "mitigation_strategies": [
        "safe_string_functions",
        "dynamic_analysis",
        "code_review",
        "static_analysis",
        "memory_safety_checks",
        "input_validation",
        "fuzzing",
        "bounds_checking",
        "secure_coding_practices"
      ],
      "code_differences": {
        "has_differences": true,
        "source_lines": 2,
        "target_lines": 2,
        "character_differences": 3293,
        "similarity_percentage": 14.563106796116504
      },
      "vulnerability_location": {
        "vulnerability_present": true,
        "fix_applied": true,
        "code_changed": true,
        "estimated_lines_changed": 0
      }
    },
    {
      "cve_id": "CVE-2015-8324",
      "cwe_id": "CWE-000",
      "cwe_name": "Unknown/Uncategorized",
      "project": "torvalds",
      "severity": "critical",
      "weaponization_score": 7.0,
      "is_critical": true,
      "is_weaponizable": true,
      "is_high_priority_project": false,
      "vulnerable_code": "CWE-000 static int ext4_show_options ( struct seq_file * seq , struct vfsmount * vfs ) { int def_errors ; unsigned long def_mount_opts ; struct super_block * sb = vfs -> mnt_sb ; struct ext4_sb_info * sbi = EXT4_SB ( sb ) ; struct ext4_super_block * es = sbi -> s_es ; def_mount_opts = le32_to_cpu ( es -> s_default_mount_opts ) ; def_errors = le16_to_cpu ( es -> s_errors ) ; if ( sbi -> s_sb_block != 1 ) seq_printf ( seq , \",sb=%llu\" , sbi -> s_sb_block ) ; if ( test_opt ( sb , MINIX_DF ) ) seq_puts ( seq , \",minixdf\" ) ; if ( test_opt ( sb , GRPID ) && ! ( def_mount_opts & EXT4_DEFM_BSDGROUPS ) ) seq_puts ( seq , \",grpid\" ) ; if ( ! test_opt ( sb , GRPID ) && ( def_mount_opts & EXT4_DEFM_BSDGROUPS ) ) seq_puts ( seq , \",nogrpid\" ) ; if ( sbi -> s_resuid != EXT4_DEF_RESUID || le16_to_cpu ( es -> s_def_resuid ) != EXT4_DEF_RESUID ) { seq_printf ( seq , \",resuid=%u\" , sbi -> s_resuid ) ; } if ( sbi -> s_resgid != EXT4_DEF_RESGID || le16_to_cpu ( es -> s_def_resgid ) != EXT4_DEF_RESGID ) { seq_printf ( seq , \",resgid=%u\" , sbi -> s_resgid ) ; } if ( test_opt ( sb , ERRORS_RO ) ) { if ( def_errors == EXT4_ERRORS_PANIC || def_errors == EXT4_ERRORS_CONTINUE ) { seq_puts ( seq , \",errors=remount-ro\" ) ; } } if ( test_opt ( sb , ERRORS_CONT ) && def_errors != EXT4_ERRORS_CONTINUE ) seq_puts ( seq , \",errors=continue\" ) ; if ( test_opt ( sb , ERRORS_PANIC ) && def_errors != EXT4_ERRORS_PANIC ) seq_puts ( seq , \",errors=panic\" ) ; if ( test_opt ( sb , NO_UID32 ) && ! ( def_mount_opts & EXT4_DEFM_UID16 ) ) seq_puts ( seq , \",nouid32\" ) ; if ( test_opt ( sb , DEBUG ) && ! ( def_mount_opts & EXT4_DEFM_DEBUG ) ) seq_puts ( seq , \",debug\" ) ; if ( test_opt ( sb , OLDALLOC ) ) seq_puts ( seq , \",oldalloc\" ) ; # ifdef CONFIG_EXT4_FS_XATTR if ( test_opt ( sb , XATTR_USER ) && ! ( def_mount_opts & EXT4_DEFM_XATTR_USER ) ) seq_puts ( seq , \",user_xattr\" ) ; if ( ! test_opt ( sb , XATTR_USER ) && ( def_mount_opts & EXT4_DEFM_XATTR_USER ) ) { seq_puts ( seq , \",nouser_xattr\" ) ; } # endif # ifdef CONFIG_EXT4_FS_POSIX_ACL if ( test_opt ( sb , POSIX_ACL ) && ! ( def_mount_opts & EXT4_DEFM_ACL ) ) seq_puts ( seq , \",acl\" ) ; if ( ! test_opt ( sb , POSIX_ACL ) && ( def_mount_opts & EXT4_DEFM_ACL ) ) seq_puts ( seq , \",noacl\" ) ; # endif if ( sbi -> s_commit_interval != JBD2_DEFAULT_MAX_COMMIT_AGE * HZ ) { seq_printf ( seq , \",commit=%u\" , ( unsigned ) ( sbi -> s_commit_interval / HZ ) ) ; } if ( sbi -> s_min_batch_time != EXT4_DEF_MIN_BATCH_TIME ) { seq_printf ( seq , \",min_batch_time=%u\" , ( unsigned ) sbi -> s_min_batch_time ) ; } if ( sbi -> s_max_batch_time != EXT4_DEF_MAX_BATCH_TIME ) { seq_printf ( seq , \",max_batch_time=%u\" , ( unsigned ) sbi -> s_min_batch_time ) ; } seq_puts ( seq , \",barrier=\" ) ; seq_puts ( seq , test_opt ( sb , BARRIER ) ? \"1\" : \"0\" ) ; if ( test_opt ( sb , JOURNAL_ASYNC_COMMIT ) ) seq_puts ( seq , \",journal_async_commit\" ) ; if ( test_opt ( sb , NOBH ) ) seq_puts ( seq , \",nobh\" ) ; if ( test_opt ( sb , I_VERSION ) ) seq_puts ( seq , \",i_version\" ) ; if ( ! test_opt ( sb , DELALLOC ) ) seq_puts ( seq , \",nodelalloc\" ) ; if ( sbi -> s_stripe ) seq_printf ( seq , \",stripe=%lu\" , sbi -> s_stripe ) ; if ( test_opt ( sb , DATA_FLAGS ) == EXT4_MOUNT_JOURNAL_DATA ) seq_puts ( seq , \",data=journal\" ) ; else if ( test_opt ( sb , DATA_FLAGS ) == EXT4_MOUNT_ORDERED_DATA ) seq_puts ( seq , \",data=ordered\" ) ; else if ( test_opt ( sb , DATA_FLAGS ) == EXT4_MOUNT_WRITEBACK_DATA ) seq_puts ( seq , \",data=writeback\" ) ; if ( sbi -> s_inode_readahead_blks != EXT4_DEF_INODE_READAHEAD_BLKS ) seq_printf ( seq , \",inode_readahead_blks=%u\" , sbi -> s_inode_readahead_blks ) ; if ( test_opt ( sb , DATA_ERR_ABORT ) ) seq_puts ( seq , \",data_err=abort\" ) ; if ( test_opt ( sb , NO_AUTO_DA_ALLOC ) ) seq_puts ( seq , \",noauto_da_alloc\" ) ; if ( test_opt ( sb , DISCARD ) ) seq_puts ( seq , \",discard\" ) ; if ( test_opt ( sb , NOLOAD ) ) seq_puts ( seq , \",norecovery\" ) ; <S2SV_StartBug> ext4_show_quota_options ( seq , sb ) ; <S2SV_EndBug> return 0 ; }\n",
      "fixed_code": "<S2SV_ModStart> \",norecovery\" ) ; if ( test_opt ( sb , DIOREAD_NOLOCK ) ) seq_puts ( seq , \",dioread_nolock\" ) ;\n",
      "source_code_length": 3998,
      "target_code_length": 113,
      "vulnerability_patterns": {
        "use_after_free": 32,
        "null_pointer": 22,
        "total": 54
      },
      "total_patterns": 54,
      "original_address": "https://github.com/torvalds/linux/commit/744692dc059845b2a3022119871846e74d4f6e11",
      "discovery_time": "2016-05-02T10:59Z",
      "project_commit_id": "torvalds@linux/744692dc059845b2a3022119871846e74d4f6e11",
      "extraction_time": "2025-08-31T15:41:49.192052",
      "label": 1,
      "vulnerability_type": "unknown/uncategorized",
      "difficulty_level": "advanced",
      "risk_factors": [
        "use_after_free"
      ],
      "attack_vectors": [
        "fuzzing",
        "code_analysis",
        "reverse_engineering"
      ],
      "mitigation_strategies": [
        "dynamic_analysis",
        "static_analysis",
        "fuzzing",
        "code_review",
        "secure_coding_practices"
      ],
      "code_differences": {
        "has_differences": true,
        "source_lines": 2,
        "target_lines": 2,
        "character_differences": 3885,
        "similarity_percentage": 6.896551724137931
      },
      "vulnerability_location": {
        "vulnerability_present": true,
        "fix_applied": true,
        "code_changed": true,
        "estimated_lines_changed": 0
      }
    },
    {
      "cve_id": "CVE-2017-9203",
      "cwe_id": "CWE-787",
      "cwe_name": "Out-of-bounds Write",
      "project": "jsummers",
      "severity": "critical",
      "weaponization_score": 7.0,
      "is_critical": true,
      "is_weaponizable": true,
      "is_high_priority_project": false,
      "vulnerable_code": "CWE-787 static int bmpr_read_rle ( struct iwbmprcontext * rctx ) { int retval = 0 ; if ( ! ( rctx -> compression == IWBMP_BI_RLE8 && rctx -> bitcount == 8 ) && ! ( rctx -> compression == IWBMP_BI_RLE4 && rctx -> bitcount == 4 ) ) { iw_set_error ( rctx -> ctx , \"Compression<S2SV_blank>type<S2SV_blank>incompatible<S2SV_blank>with<S2SV_blank>image<S2SV_blank>type\" ) ; <S2SV_StartBug> } <S2SV_EndBug> if ( rctx -> topdown ) { <S2SV_StartBug> iw_set_error ( rctx -> ctx , \"Compression<S2SV_blank>not<S2SV_blank>allowed<S2SV_blank>with<S2SV_blank>top-down<S2SV_blank>images\" ) ; <S2SV_EndBug> } rctx -> img -> imgtype = IW_IMGTYPE_RGBA ; rctx -> img -> bit_depth = 8 ; rctx -> img -> bpr = iw_calc_bytesperrow ( rctx -> width , 32 ) ; rctx -> img -> pixels = ( iw_byte * ) iw_malloc_large ( rctx -> ctx , rctx -> img -> bpr , rctx -> img -> height ) ; if ( ! rctx -> img -> pixels ) goto done ; if ( ! bmpr_read_rle_internal ( rctx ) ) goto done ; if ( ! bmpr_has_transparency ( rctx -> img ) ) { bmpr_strip_alpha ( rctx -> img ) ; } retval = 1 ; done : return retval ; }\n",
      "fixed_code": "<S2SV_ModStart> \"Compression<S2SV_blank>type<S2SV_blank>incompatible<S2SV_blank>with<S2SV_blank>image<S2SV_blank>type\" ) ; goto done ; <S2SV_ModStart> , \"Compression<S2SV_blank>not<S2SV_blank>allowed<S2SV_blank>with<S2SV_blank>top-down<S2SV_blank>images\" ) ; goto done\n",
      "source_code_length": 1069,
      "target_code_length": 269,
      "vulnerability_patterns": {
        "null_pointer": 25,
        "total": 25
      },
      "total_patterns": 25,
      "original_address": "https://github.com/jsummers/imageworsener/commit/a4f247707f08e322f0b41e82c3e06e224240a654",
      "discovery_time": "2017-05-23T04:29Z",
      "project_commit_id": "jsummers@imageworsener/a4f247707f08e322f0b41e82c3e06e224240a654",
      "extraction_time": "2025-08-31T15:41:49.192104",
      "label": 1,
      "vulnerability_type": "out-of-bounds_write",
      "difficulty_level": "advanced",
      "risk_factors": [
        "system_crash",
        "memory_corruption",
        "arbitrary_code_execution"
      ],
      "attack_vectors": [
        "memory_manipulation",
        "malicious_input",
        "code_analysis",
        "buffer_overflow",
        "reverse_engineering",
        "fuzzing"
      ],
      "mitigation_strategies": [
        "safe_string_functions",
        "dynamic_analysis",
        "code_review",
        "static_analysis",
        "memory_safety_checks",
        "input_validation",
        "fuzzing",
        "bounds_checking",
        "secure_coding_practices"
      ],
      "code_differences": {
        "has_differences": true,
        "source_lines": 2,
        "target_lines": 2,
        "character_differences": 800,
        "similarity_percentage": 12.5
      },
      "vulnerability_location": {
        "vulnerability_present": true,
        "fix_applied": true,
        "code_changed": true,
        "estimated_lines_changed": 0
      }
    },
    {
      "cve_id": "CVE-2016-2185",
      "cwe_id": "CWE-000",
      "cwe_name": "Unknown/Uncategorized",
      "project": "torvalds",
      "severity": "critical",
      "weaponization_score": 7.0,
      "is_critical": true,
      "is_weaponizable": true,
      "is_high_priority_project": false,
      "vulnerable_code": "CWE-000 static int ati_remote2_probe ( struct usb_interface * interface , const struct usb_device_id * id ) { struct usb_device * udev = interface_to_usbdev ( interface ) ; struct usb_host_interface * alt = interface -> cur_altsetting ; struct ati_remote2 * ar2 ; int r ; if ( alt -> desc . bInterfaceNumber ) return - ENODEV ; ar2 = kzalloc ( sizeof ( struct ati_remote2 ) , GFP_KERNEL ) ; if ( ! ar2 ) return - ENOMEM ; ar2 -> udev = udev ; <S2SV_StartBug> ar2 -> intf [ 0 ] = interface ; <S2SV_EndBug> ar2 -> ep [ 0 ] = & alt -> endpoint [ 0 ] . desc ; ar2 -> intf [ 1 ] = usb_ifnum_to_if ( udev , 1 ) ; <S2SV_StartBug> r = usb_driver_claim_interface ( & ati_remote2_driver , ar2 -> intf [ 1 ] , ar2 ) ; <S2SV_EndBug> if ( r ) goto fail1 ; alt = ar2 -> intf [ 1 ] -> cur_altsetting ; <S2SV_StartBug> ar2 -> ep [ 1 ] = & alt -> endpoint [ 0 ] . desc ; <S2SV_EndBug> r = ati_remote2_urb_init ( ar2 ) ; if ( r ) <S2SV_StartBug> goto fail2 ; <S2SV_EndBug> ar2 -> channel_mask = channel_mask ; ar2 -> mode_mask = mode_mask ; r = ati_remote2_setup ( ar2 , ar2 -> channel_mask ) ; if ( r ) <S2SV_StartBug> goto fail2 ; <S2SV_EndBug> usb_make_path ( udev , ar2 -> phys , sizeof ( ar2 -> phys ) ) ; strlcat ( ar2 -> phys , \"/input0\" , sizeof ( ar2 -> phys ) ) ; strlcat ( ar2 -> name , \"ATI<S2SV_blank>Remote<S2SV_blank>Wonder<S2SV_blank>II\" , sizeof ( ar2 -> name ) ) ; r = sysfs_create_group ( & udev -> dev . kobj , & ati_remote2_attr_group ) ; if ( r ) <S2SV_StartBug> goto fail2 ; <S2SV_EndBug> r = ati_remote2_input_init ( ar2 ) ; if ( r ) <S2SV_StartBug> goto fail3 ; <S2SV_EndBug> usb_set_intfdata ( interface , ar2 ) ; interface -> needs_remote_wakeup = 1 ; return 0 ; <S2SV_StartBug> fail3 : <S2SV_EndBug> sysfs_remove_group ( & udev -> dev . kobj , & ati_remote2_attr_group ) ; fail2 : <S2SV_StartBug> ati_remote2_urb_cleanup ( ar2 ) ; <S2SV_EndBug> usb_driver_release_interface ( & ati_remote2_driver , ar2 -> intf [ 1 ] ) ; fail1 : kfree ( ar2 ) ; return r ; }\n",
      "fixed_code": "<S2SV_ModStart> = udev ; if ( alt -> desc . bNumEndpoints < 1 || ! alt -> endpoint ) { dev_err ( & interface -> dev , \"%s():<S2SV_blank>interface<S2SV_blank>0<S2SV_blank>must<S2SV_blank>have<S2SV_blank>an<S2SV_blank>endpoint\\\\n\" , __func__ ) ; r = - ENODEV ; goto fail1 ; } <S2SV_ModStart> 1 ) ; if ( ( udev -> actconfig -> desc . bNumInterfaces < 2 ) || ! ar2 -> intf [ 1 ] ) { dev_err ( & interface -> dev , \"%s():<S2SV_blank>need<S2SV_blank>2<S2SV_blank>interfaces,<S2SV_blank>found<S2SV_blank>%d\\\\n\" , __func__ , udev -> actconfig -> desc . bNumInterfaces ) ; r = - ENODEV ; goto fail1 ; } <S2SV_ModStart> -> cur_altsetting ; if ( alt -> desc . bNumEndpoints < 1 || ! alt -> endpoint ) { dev_err ( & interface -> dev , \"%s():<S2SV_blank>interface<S2SV_blank>1<S2SV_blank>must<S2SV_blank>have<S2SV_blank>an<S2SV_blank>endpoint\\\\n\" , __func__ ) ; r = - ENODEV ; goto fail2 ; } <S2SV_ModStart> r ) goto fail3 <S2SV_ModEnd> ; ar2 -> <S2SV_ModStart> r ) goto fail3 <S2SV_ModEnd> ; usb_make_path ( <S2SV_ModStart> r ) goto fail3 <S2SV_ModEnd> ; r = <S2SV_ModStart> r ) goto fail4 <S2SV_ModEnd> ; usb_set_intfdata ( <S2SV_ModStart> return 0 ; fail4 : sysfs_remove_group ( & udev -> dev . kobj , & ati_remote2_attr_group ) ; fail3 : ati_remote2_urb_cleanup ( ar2 <S2SV_ModEnd> ) ; fail2 <S2SV_ModStart> ; fail2 : <S2SV_ModEnd> usb_driver_release_interface ( &\n",
      "source_code_length": 1968,
      "target_code_length": 1356,
      "vulnerability_patterns": {
        "use_after_free": 1,
        "null_pointer": 27,
        "total": 28
      },
      "total_patterns": 28,
      "original_address": "https://github.com/torvalds/linux/commit/950336ba3e4a1ffd2ca60d29f6ef386dd2c7351d",
      "discovery_time": "2016-05-02T10:59Z",
      "project_commit_id": "torvalds@linux/950336ba3e4a1ffd2ca60d29f6ef386dd2c7351d",
      "extraction_time": "2025-08-31T15:41:49.192139",
      "label": 1,
      "vulnerability_type": "unknown/uncategorized",
      "difficulty_level": "advanced",
      "risk_factors": [
        "use_after_free"
      ],
      "attack_vectors": [
        "fuzzing",
        "code_analysis",
        "reverse_engineering"
      ],
      "mitigation_strategies": [
        "dynamic_analysis",
        "static_analysis",
        "fuzzing",
        "code_review",
        "secure_coding_practices"
      ],
      "code_differences": {
        "has_differences": true,
        "source_lines": 2,
        "target_lines": 2,
        "character_differences": 612,
        "similarity_percentage": 44.086021505376344
      },
      "vulnerability_location": {
        "vulnerability_present": true,
        "fix_applied": true,
        "code_changed": true,
        "estimated_lines_changed": 0
      }
    },
    {
      "cve_id": "CVE-2018-20145",
      "cwe_id": "CWE-000",
      "cwe_name": "Unknown/Uncategorized",
      "project": "eclipse",
      "severity": "critical",
      "weaponization_score": 7.0,
      "is_critical": true,
      "is_weaponizable": true,
      "is_high_priority_project": false,
      "vulnerable_code": "CWE-732 int config__parse_args ( struct mosquitto_db * db , struct mosquitto__config * config , int argc , char * argv [ ] ) { int i ; int port_tmp ; for ( i = 1 ; i < argc ; i ++ ) { if ( ! strcmp ( argv [ i ] , \"-c\" ) || ! strcmp ( argv [ i ] , \"--config-file\" ) ) { if ( i < argc - 1 ) { db -> config_file = argv [ i + 1 ] ; if ( config__read ( db , config , false ) ) { log__printf ( NULL , MOSQ_LOG_ERR , \"Error:<S2SV_blank>Unable<S2SV_blank>to<S2SV_blank>open<S2SV_blank>configuration<S2SV_blank>file.\" ) ; return MOSQ_ERR_INVAL ; } } else { log__printf ( NULL , MOSQ_LOG_ERR , \"Error:<S2SV_blank>-c<S2SV_blank>argument<S2SV_blank>given,<S2SV_blank>but<S2SV_blank>no<S2SV_blank>config<S2SV_blank>file<S2SV_blank>specified.\" ) ; return MOSQ_ERR_INVAL ; } i ++ ; } else if ( ! strcmp ( argv [ i ] , \"-d\" ) || ! strcmp ( argv [ i ] , \"--daemon\" ) ) { config -> daemon = true ; } else if ( ! strcmp ( argv [ i ] , \"-h\" ) || ! strcmp ( argv [ i ] , \"--help\" ) ) { print_usage ( ) ; return MOSQ_ERR_INVAL ; } else if ( ! strcmp ( argv [ i ] , \"-p\" ) || ! strcmp ( argv [ i ] , \"--port\" ) ) { if ( i < argc - 1 ) { port_tmp = atoi ( argv [ i + 1 ] ) ; if ( port_tmp < 1 || port_tmp > 65535 ) { log__printf ( NULL , MOSQ_LOG_ERR , \"Error:<S2SV_blank>Invalid<S2SV_blank>port<S2SV_blank>specified<S2SV_blank>(%d).\" , port_tmp ) ; return MOSQ_ERR_INVAL ; } else { if ( config -> default_listener . port ) { log__printf ( NULL , MOSQ_LOG_WARNING , \"Warning:<S2SV_blank>Default<S2SV_blank>listener<S2SV_blank>port<S2SV_blank>specified<S2SV_blank>multiple<S2SV_blank>times.<S2SV_blank>Only<S2SV_blank>the<S2SV_blank>latest<S2SV_blank>will<S2SV_blank>be<S2SV_blank>used.\" ) ; } config -> default_listener . port = port_tmp ; } } else { log__printf ( NULL , MOSQ_LOG_ERR , \"Error:<S2SV_blank>-p<S2SV_blank>argument<S2SV_blank>given,<S2SV_blank>but<S2SV_blank>no<S2SV_blank>port<S2SV_blank>specified.\" ) ; return MOSQ_ERR_INVAL ; } i ++ ; } else if ( ! strcmp ( argv [ i ] , \"-v\" ) || ! strcmp ( argv [ i ] , \"--verbose\" ) ) { db -> verbose = true ; } else { fprintf ( stderr , \"Error:<S2SV_blank>Unknown<S2SV_blank>option<S2SV_blank>\\'%s\\'.\\\\n\" , argv [ i ] ) ; print_usage ( ) ; return MOSQ_ERR_INVAL ; } } if ( config -> listener_count == 0 # ifdef WITH_TLS || config -> default_listener . cafile || config -> default_listener . capath || config -> default_listener . certfile || config -> default_listener . keyfile || config -> default_listener . ciphers || config -> default_listener . psk_hint || config -> default_listener . require_certificate || config -> default_listener . crlfile || config -> default_listener . use_identity_as_username || config -> default_listener . use_subject_as_username # endif || config -> default_listener . use_username_as_clientid || config -> default_listener . host || config -> default_listener . port || config -> default_listener . max_connections != - 1 || config -> default_listener . mount_point || config -> default_listener . protocol != mp_mqtt || config -> default_listener . socket_domain || config -> default_listener . security_options . password_file || config -> default_listener . security_options . psk_file || config -> default_listener . security_options . auth_plugin_config_count || config -> default_listener . security_options . allow_anonymous != - 1 ) { config -> listener_count ++ ; config -> listeners = mosquitto__realloc ( config -> listeners , sizeof ( struct mosquitto__listener ) * config -> listener_count ) ; if ( ! config -> listeners ) { log__printf ( NULL , MOSQ_LOG_ERR , \"Error:<S2SV_blank>Out<S2SV_blank>of<S2SV_blank>memory.\" ) ; return MOSQ_ERR_NOMEM ; } memset ( & config -> listeners [ config -> listener_count - 1 ] , 0 , sizeof ( struct mosquitto__listener ) ) ; if ( config -> default_listener . port ) { config -> listeners [ config -> listener_count - 1 ] . port = config -> default_listener . port ; } else { config -> listeners [ config -> listener_count - 1 ] . port = 1883 ; } if ( config -> default_listener . host ) { config -> listeners [ config -> listener_count - 1 ] . host = config -> default_listener . host ; } else { config -> listeners [ config -> listener_count - 1 ] . host = NULL ; } if ( config -> default_listener . mount_point ) { config -> listeners [ config -> listener_count - 1 ] . mount_point = config -> default_listener . mount_point ; } else { config -> listeners [ config -> listener_count - 1 ] . mount_point = NULL ; } config -> listeners [ config -> listener_count - 1 ] . max_connections = config -> default_listener . max_connections ; config -> listeners [ config -> listener_count - 1 ] . protocol = config -> default_listener . protocol ; config -> listeners [ config -> listener_count - 1 ] . socket_domain = config -> default_listener . socket_domain ; config -> listeners [ config -> listener_count - 1 ] . client_count = 0 ; config -> listeners [ config -> listener_count - 1 ] . socks = NULL ; config -> listeners [ config -> listener_count - 1 ] . sock_count = 0 ; config -> listeners [ config -> listener_count - 1 ] . client_count = 0 ; config -> listeners [ config -> listener_count - 1 ] . use_username_as_clientid = config -> default_listener . use_username_as_clientid ; # ifdef WITH_TLS config -> listeners [ config -> listener_count - 1 ] . tls_version = config -> default_listener . tls_version ; config -> listeners [ config -> listener_count - 1 ] . cafile = config -> default_listener . cafile ; config -> listeners [ config -> listener_count - 1 ] . capath = config -> default_listener . capath ; config -> listeners [ config -> listener_count - 1 ] . certfile = config -> default_listener . certfile ; config -> listeners [ config -> listener_count - 1 ] . keyfile = config -> default_listener . keyfile ; config -> listeners [ config -> listener_count - 1 ] . ciphers = config -> default_listener . ciphers ; config -> listeners [ config -> listener_count - 1 ] . psk_hint = config -> default_listener . psk_hint ; config -> listeners [ config -> listener_count - 1 ] . require_certificate = config -> default_listener . require_certificate ; config -> listeners [ config -> listener_count - 1 ] . ssl_ctx = NULL ; config -> listeners [ config -> listener_count - 1 ] . crlfile = config -> default_listener . crlfile ; config -> listeners [ config -> listener_count - 1 ] . use_identity_as_username = config -> default_listener . use_identity_as_username ; config -> listeners [ config -> listener_count - 1 ] . use_subject_as_username = config -> default_listener . use_subject_as_username ; # endif <S2SV_StartBug> config -> listeners [ config -> listener_count - 1 ] . security_options . password_file = config -> default_listener . security_options . password_file ; <S2SV_EndBug> config -> listeners [ config -> listener_count - 1 ] . security_options . psk_file = config -> default_listener . security_options . psk_file ; config -> listeners [ config -> listener_count - 1 ] . security_options . auth_plugin_configs = config -> default_listener . security_options . auth_plugin_configs ; config -> listeners [ config -> listener_count - 1 ] . security_options . auth_plugin_config_count = config -> default_listener . security_options . auth_plugin_config_count ; config -> listeners [ config -> listener_count - 1 ] . security_options . allow_anonymous = config -> default_listener . security_options . allow_anonymous ; } if ( ! config -> user ) { config -> user = \"mosquitto\" ; } if ( db -> verbose ) { config -> log_type = INT_MAX ; } return config__check ( config ) ; }\n",
      "fixed_code": "<S2SV_ModStart> . security_options . acl_file = config -> default_listener . security_options . acl_file ; config -> listeners [ config -> listener_count - 1 ] . security_options .\n",
      "source_code_length": 7521,
      "target_code_length": 181,
      "vulnerability_patterns": {
        "buffer_overflow": 1,
        "integer_overflow": 9,
        "format_string": 1,
        "null_pointer": 126,
        "total": 137
      },
      "total_patterns": 137,
      "original_address": "https://github.com/eclipse/mosquitto/commit/9097577b49b7fdcf45d30975976dd93808ccc0c4",
      "discovery_time": "2018-12-13T20:29Z",
      "project_commit_id": "eclipse@mosquitto/9097577b49b7fdcf45d30975976dd93808ccc0c4",
      "extraction_time": "2025-08-31T15:41:49.192175",
      "label": 1,
      "vulnerability_type": "unknown/uncategorized",
      "difficulty_level": "advanced",
      "risk_factors": [
        "buffer_overflow"
      ],
      "attack_vectors": [
        "fuzzing",
        "code_analysis",
        "reverse_engineering"
      ],
      "mitigation_strategies": [
        "dynamic_analysis",
        "static_analysis",
        "fuzzing",
        "code_review",
        "secure_coding_practices"
      ],
      "code_differences": {
        "has_differences": true,
        "source_lines": 2,
        "target_lines": 2,
        "character_differences": 7340,
        "similarity_percentage": 10.317460317460316
      },
      "vulnerability_location": {
        "vulnerability_present": true,
        "fix_applied": true,
        "code_changed": true,
        "estimated_lines_changed": 0
      }
    },
    {
      "cve_id": "CVE-2018-13304",
      "cwe_id": "CWE-617",
      "cwe_name": "Reachable Assertion",
      "project": "FFmpeg",
      "severity": "critical",
      "weaponization_score": 7.0,
      "is_critical": true,
      "is_weaponizable": true,
      "is_high_priority_project": true,
      "vulnerable_code": "CWE-617 static enum AVPixelFormat h263_get_format ( AVCodecContext * avctx ) <S2SV_StartBug> { <S2SV_EndBug> if ( avctx -> bits_per_raw_sample > 8 ) { <S2SV_StartBug> av_assert1 ( avctx -> profile == FF_PROFILE_MPEG4_SIMPLE_STUDIO ) ; <S2SV_EndBug> return avctx -> pix_fmt ; } if ( avctx -> codec -> id == AV_CODEC_ID_MSS2 ) return AV_PIX_FMT_YUV420P ; if ( CONFIG_GRAY && ( avctx -> flags & AV_CODEC_FLAG_GRAY ) ) { if ( avctx -> color_range == AVCOL_RANGE_UNSPECIFIED ) avctx -> color_range = AVCOL_RANGE_MPEG ; return AV_PIX_FMT_GRAY8 ; } return avctx -> pix_fmt = ff_get_format ( avctx , avctx -> codec -> pix_fmts ) ; }\n",
      "fixed_code": "<S2SV_ModStart> avctx ) { MpegEncContext * s = avctx -> priv_data ; <S2SV_ModStart> { av_assert1 ( s -> studio_profile <S2SV_ModEnd> ) ; return\n",
      "source_code_length": 625,
      "target_code_length": 144,
      "vulnerability_patterns": {
        "null_pointer": 11,
        "total": 11
      },
      "total_patterns": 11,
      "original_address": "https://github.com/FFmpeg/FFmpeg/commit/bd27a9364ca274ca97f1df6d984e88a0700fb235",
      "discovery_time": "2018-07-05T17:29Z",
      "project_commit_id": "FFmpeg@FFmpeg/bd27a9364ca274ca97f1df6d984e88a0700fb235",
      "extraction_time": "2025-08-31T15:41:49.192242",
      "label": 1,
      "vulnerability_type": "reachable_assertion",
      "difficulty_level": "advanced",
      "risk_factors": [
        "critical_infrastructure"
      ],
      "attack_vectors": [
        "fuzzing",
        "code_analysis",
        "reverse_engineering"
      ],
      "mitigation_strategies": [
        "dynamic_analysis",
        "static_analysis",
        "fuzzing",
        "code_review",
        "secure_coding_practices"
      ],
      "code_differences": {
        "has_differences": true,
        "source_lines": 2,
        "target_lines": 2,
        "character_differences": 481,
        "similarity_percentage": 20.408163265306122
      },
      "vulnerability_location": {
        "vulnerability_present": true,
        "fix_applied": true,
        "code_changed": true,
        "estimated_lines_changed": 0
      }
    }
  ]
}