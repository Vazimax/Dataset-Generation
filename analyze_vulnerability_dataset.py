#!/usr/bin/env python3
"""
Vulnerability Dataset Analyzer
Analyzes the 1000 vulnerability samples to identify the most critical, weaponizable CVEs.
"""

import json
import re
import logging
from typing import List, Dict, Set
from collections import defaultdict, Counter

# Setup logging
logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')
logger = logging.getLogger(__name__)

class VulnerabilityDatasetAnalyzer:
    def __init__(self, dataset_file: str = "top-1000-training-samples.json"):
        self.dataset_file = dataset_file
        self.data = []
        self.cve_analysis = {}
        
        # Critical CWE categories (high weaponizability)
        self.critical_cwes = {
            'CWE-119': 'Buffer Overflow',      # Memory corruption
            'CWE-125': 'Out-of-bounds Read',   # Information disclosure
            'CWE-787': 'Out-of-bounds Write',  # Memory corruption
            'CWE-190': 'Integer Overflow',     # Memory corruption
            'CWE-191': 'Integer Underflow',    # Memory corruption
            'CWE-476': 'NULL Pointer Dereference', # Crash/DoS
            'CWE-415': 'Double Free',          # Memory corruption
            'CWE-416': 'Use After Free',       # Memory corruption
            'CWE-78': 'OS Command Injection',  # Remote code execution
            'CWE-89': 'SQL Injection',         # Data manipulation
            'CWE-20': 'Improper Input Validation', # Various attacks
            'CWE-22': 'Path Traversal',        # File access
            'CWE-287': 'Improper Authentication', # Access control
            'CWE-434': 'Unrestricted Upload',  # Malicious file upload
            'CWE-502': 'Deserialization',      # Remote code execution
        }
        
        # High-priority projects (widely used, critical infrastructure)
        self.high_priority_projects = {
            'openssl', 'sqlite', 'curl', 'zlib', 'libpng', 'libjpeg',
            'linux', 'ffmpeg', 'imagemagick', 'wireshark', 'tcpdump',
            'nginx', 'apache', 'mysql', 'postgresql', 'redis',
            'python', 'php', 'java', 'nodejs', 'golang'
        }
        
    def load_dataset(self):
        """Load the vulnerability dataset"""
        try:
            with open(self.dataset_file, 'r') as f:
                self.data = json.load(f)
            logger.info(f"üìä Loaded {len(self.data)} vulnerability samples")
        except Exception as e:
            logger.error(f"Failed to load dataset: {e}")
            return False
        return True
    
    def analyze_cve(self, sample: Dict) -> Dict:
        """Analyze a single CVE sample"""
        cve_id = sample.get('cve_id', '')
        cwe_id = sample.get('cwe_id', '')
        project = sample.get('project_and_commit_id', '')
        
        if not cve_id or not cwe_id:
            return {}
        
        # Extract project name
        project_name = project.split('@')[0] if '@' in project else project
        
        # Calculate weaponizability score
        weaponization_score = self._calculate_weaponization_score(cwe_id, project_name)
        
        # Analyze source code patterns
        source_code = sample.get('source', '')
        vulnerability_patterns = self._find_vulnerability_patterns(source_code, cwe_id)
        
        return {
            'cve_id': cve_id,
            'cwe_id': cwe_id,
            'cwe_name': self.critical_cwes.get(cwe_id, 'Unknown'),
            'project': project_name,
            'weaponization_score': weaponization_score,
            'vulnerability_patterns': vulnerability_patterns,
            'source_code_length': len(source_code),
            'is_critical': weaponization_score >= 6.0,  # Lowered threshold
            'is_high_priority_project': project_name.lower() in self.high_priority_projects
        }
    
    def _calculate_weaponization_score(self, cwe_id: str, project: str) -> float:
        """Calculate weaponization score based on CWE and project"""
        score = 0.0
        
        # Base score from CWE criticality (adjusted to be less strict)
        if cwe_id in self.critical_cwes:
            if cwe_id in ['CWE-119', 'CWE-787', 'CWE-78', 'CWE-89', 'CWE-502']:
                score += 4.0  # Memory corruption, RCE (was 5.0)
            elif cwe_id in ['CWE-125', 'CWE-190', 'CWE-191', 'CWE-415', 'CWE-416']:
                score += 3.5  # Memory issues, integer problems (was 4.0)
            elif cwe_id in ['CWE-476', 'CWE-434', 'CWE-287']:
                score += 2.5  # Crashes, access control (was 3.0)
            else:
                score += 1.5  # Other vulnerabilities (was 2.0)
        
        # Project priority bonus (increased)
        if project.lower() in self.high_priority_projects:
            score += 3.0  # Was 2.0
        
        # CWE-000 indicates unknown/uncategorized (potentially dangerous)
        if cwe_id == 'CWE-000':
            score += 2.0  # Was 1.0
        
        # Additional scoring for common critical CWEs
        if cwe_id in ['CWE-119', 'CWE-125', 'CWE-787', 'CWE-476']:
            score += 1.0  # Bonus for most common critical CWEs
        
        return min(score, 10.0)
    
    def _find_vulnerability_patterns(self, source_code: str, cwe_id: str) -> List[str]:
        """Find vulnerability patterns in source code"""
        patterns = []
        
        # Buffer overflow patterns
        if cwe_id in ['CWE-119', 'CWE-787']:
            dangerous_functions = [
                r'\bstrcpy\s*\(', r'\bstrcat\s*\(', r'\bsprintf\s*\(',
                r'\bgets\s*\(', r'\bstrncpy\s*\(', r'\bstrncat\s*\(',
                r'\bmemcpy\s*\(', r'\bmemmove\s*\(', r'\bmemset\s*\('
            ]
            for pattern in dangerous_functions:
                if re.search(pattern, source_code):
                    patterns.append(f"Buffer overflow risk: {pattern.strip()}")
        
        # Integer overflow patterns
        if cwe_id in ['CWE-190', 'CWE-191']:
            if re.search(r'\+\+|--|\+=|\-=|\*=|/=', source_code):
                patterns.append("Integer arithmetic operations")
            if re.search(r'\bint\s+\w+\s*[+\-*/]\s*\w+', source_code):
                patterns.append("Integer arithmetic without bounds checking")
        
        # NULL pointer patterns
        if cwe_id == 'CWE-476':
            if re.search(r'->\s*\w+', source_code):
                patterns.append("Pointer dereference operations")
            if re.search(r'\*\w+\s*=', source_code):
                patterns.append("Pointer assignment")
        
        # Command injection patterns
        if cwe_id == 'CWE-78':
            if re.search(r'\bsystem\s*\(|\bexec\s*\(|\bpopen\s*\(', source_code):
                patterns.append("Command execution functions")
        
        # SQL injection patterns
        if cwe_id == 'CWE-89':
            if re.search(r'\bSELECT\b|\bINSERT\b|\bUPDATE\b|\bDELETE\b', source_code, re.IGNORECASE):
                patterns.append("SQL query construction")
        
        return patterns
    
    def analyze_all_cves(self):
        """Analyze all CVEs in the dataset"""
        logger.info("üîç Analyzing all CVEs in the dataset...")
        
        for sample in self.data:
            analysis = self.analyze_cve(sample)
            if analysis:
                cve_id = analysis['cve_id']
                if cve_id not in self.cve_analysis:
                    self.cve_analysis[cve_id] = analysis
                else:
                    # Merge if multiple samples for same CVE
                    existing = self.cve_analysis[cve_id]
                    existing['vulnerability_patterns'].extend(analysis['vulnerability_patterns'])
                    existing['source_code_length'] = max(existing['source_code_length'], analysis['source_code_length'])
        
        logger.info(f"‚úÖ Analyzed {len(self.cve_analysis)} unique CVEs")
    
    def get_critical_cves(self, min_score: float = 6.0, max_count: int = 50) -> List[Dict]:
        """Get the most critical CVEs based on weaponization score"""
        critical_cves = [
            cve for cve in self.cve_analysis.values() 
            if cve['weaponization_score'] >= min_score
        ]
        
        # Sort by weaponization score (descending)
        critical_cves.sort(key=lambda x: x['weaponization_score'], reverse=True)
        
        # Limit to requested count
        return critical_cves[:max_count]
    
    def get_cwe_statistics(self) -> Dict:
        """Get statistics about CWE distribution"""
        cwe_counts = Counter(cve['cwe_id'] for cve in self.cve_analysis.values())
        return dict(cwe_counts.most_common())
    
    def get_project_statistics(self) -> Dict:
        """Get statistics about project distribution"""
        project_counts = Counter(cve['project'] for cve in self.cve_analysis.values())
        return dict(project_counts.most_common())
    
    def generate_report(self, output_file: str = "critical_cves_report.json"):
        """Generate a comprehensive report of critical CVEs"""
        critical_cves = self.get_critical_cves()
        
        report = {
            'summary': {
                'total_cves_analyzed': len(self.cve_analysis),
                'critical_cves_found': len(critical_cves),
                'target_count': 50,
                'success_rate': f"{(len(critical_cves) / 50) * 100:.1f}%"
            },
            'cwe_distribution': self.get_cwe_statistics(),
            'project_distribution': self.get_project_statistics(),
            'critical_cves': critical_cves
        }
        
        # Save report
        with open(output_file, 'w') as f:
            json.dump(report, f, indent=2)
        
        logger.info(f"üìã Report saved to {output_file}")
        return report
    
    def print_summary(self):
        """Print a summary of the analysis"""
        critical_cves = self.get_critical_cves()
        
        print("\n" + "="*80)
        print("üö® CRITICAL VULNERABILITY DATASET ANALYSIS")
        print("="*80)
        print(f"üìä Total CVEs analyzed: {len(self.cve_analysis)}")
        print(f"üéØ Critical CVEs found: {len(critical_cves)}")
        print(f"üìà Success rate: {(len(critical_cves) / 50) * 100:.1f}%")
        
        print(f"\nüî• Top 10 Most Critical CVEs:")
        for i, cve in enumerate(critical_cves[:10], 1):
            print(f"{i:2d}. {cve['cve_id']} - {cve['cwe_name']} ({cve['project']})")
            print(f"    Weaponization Score: {cve['weaponization_score']:.1f}/10.0")
            print(f"    Patterns: {len(cve['vulnerability_patterns'])}")
            print()
        
        print(f"\nüìã CWE Distribution (Top 10):")
        cwe_stats = self.get_cwe_statistics()
        for i, (cwe, count) in enumerate(list(cwe_stats.items())[:10], 1):
            cwe_name = self.critical_cwes.get(cwe, 'Unknown')
            print(f"{i:2d}. {cwe} - {cwe_name}: {count} CVEs")
        
        print(f"\nüèóÔ∏è  Project Distribution (Top 10):")
        project_stats = self.get_project_statistics()
        for i, (project, count) in enumerate(list(project_stats.items())[:10], 1):
            priority = "üî• HIGH" if project.lower() in self.high_priority_projects else "‚ö™ Normal"
            print(f"{i:2d}. {project}: {count} CVEs {priority}")

def main():
    """Main function"""
    analyzer = VulnerabilityDatasetAnalyzer()
    
    # Load and analyze dataset
    if not analyzer.load_dataset():
        return
    
    analyzer.analyze_all_cves()
    
    # Generate report
    report = analyzer.generate_report()
    
    # Print summary
    analyzer.print_summary()
    
    # Check if we have enough critical CVEs
    critical_count = len(report['critical_cves'])
    if critical_count >= 50:
        print(f"\nüéâ SUCCESS! We found {critical_count} critical CVEs!")
        print("This dataset is perfect for our weaponizable CVE collection!")
    else:
        print(f"\n‚ö†Ô∏è  We found {critical_count} critical CVEs, need {50 - critical_count} more")
        print("We may need to combine this with other sources or lower the threshold")

if __name__ == "__main__":
    main()
