[
  {
    "cve_id": "CVE-2016-1621",
    "cwe_id": "CWE-119",
    "cwe_name": "Buffer Overflow",
    "project": "external",
    "severity": "critical",
    "weaponization_score": 10.0,
    "is_critical": true,
    "is_weaponizable": true,
    "is_high_priority_project": false,
    "vulnerable_code": "CWE-119 int main ( int argc , char * * argv ) { int frame_cnt = 0 ; FILE * outfile = NULL ; vpx_codec_ctx_t codec ; const VpxInterface * decoder = NULL ; VpxVideoReader * reader = NULL ; const VpxVideoInfo * info = NULL ; int n = 0 ; int m = 0 ; int is_range = 0 ; char * nptr = NULL ; exec_name = argv [ 0 ] ; if ( argc != 4 ) die ( \"Invalid<S2SV_blank>number<S2SV_blank>of<S2SV_blank>arguments.\" ) ; reader = vpx_video_reader_open ( argv [ 1 ] ) ; if ( ! reader ) die ( \"Failed<S2SV_blank>to<S2SV_blank>open<S2SV_blank>%s<S2SV_blank>for<S2SV_blank>reading.\" , argv [ 1 ] ) ; if ( ! ( outfile = fopen ( argv [ 2 ] , \"wb\" ) ) ) die ( \"Failed<S2SV_blank>to<S2SV_blank>open<S2SV_blank>%s<S2SV_blank>for<S2SV_blank>writing.\" , argv [ 2 ] ) ; n = strtol ( argv [ 3 ] , & nptr , 0 ) ; m = strtol ( nptr + 1 , NULL , 0 ) ; is_range = ( * nptr == '-' ) ; if ( ! n || ! m || ( * nptr != '-' && * nptr != '/' ) ) die ( \"Couldn\\'t<S2SV_blank>parse<S2SV_blank>pattern<S2SV_blank>%s.\\\\n\" , argv [ 3 ] ) ; info = vpx_video_reader_get_info ( reader ) ; decoder = get_vpx_decoder_by_fourcc ( info -> codec_fourcc ) ; if ( ! decoder ) die ( \"Unknown<S2SV_blank>input<S2SV_blank>codec.\" ) ; <S2SV_StartBug> printf ( \"Using<S2SV_blank>%s\\\\n\" , vpx_codec_iface_name ( decoder -> interface ( ) ) ) ; <S2SV_EndBug> <S2SV_StartBug> if ( vpx_codec_dec_init ( & codec , decoder -> interface ( ) , NULL , 0 ) ) <S2SV_EndBug> die_codec ( & codec , \"Failed<S2SV_blank>to<S2SV_blank>initialize<S2SV_blank>decoder.\" ) ; while ( vpx_video_reader_read_frame ( reader ) ) { vpx_codec_iter_t iter = NULL ; vpx_image_t * img = NULL ; size_t frame_size = 0 ; int skip ; const unsigned char * frame = vpx_video_reader_get_frame ( reader , & frame_size ) ; if ( vpx_codec_decode ( & codec , frame , ( unsigned int ) frame_size , NULL , 0 ) ) die_codec ( & codec , \"Failed<S2SV_blank>to<S2SV_blank>decode<S2SV_blank>frame.\" ) ; ++ frame_cnt ; skip = ( is_range && frame_cnt >= n && frame_cnt <= m ) || ( ! is_range && m - ( frame_cnt - 1 ) % m <= n ) ; if ( ! skip ) { putc ( '.' , stdout ) ; while ( ( img = vpx_codec_get_frame ( & codec , & iter ) ) != NULL ) vpx_img_write ( img , outfile ) ; } else { putc ( 'X' , stdout ) ; } fflush ( stdout ) ; } printf ( \"Processed<S2SV_blank>%d<S2SV_blank>frames.\\\\n\" , frame_cnt ) ; if ( vpx_codec_destroy ( & codec ) ) die_codec ( & codec , \"Failed<S2SV_blank>to<S2SV_blank>destroy<S2SV_blank>codec.\" ) ; printf ( \"Play:<S2SV_blank>ffplay<S2SV_blank>-f<S2SV_blank>rawvideo<S2SV_blank>-pix_fmt<S2SV_blank>yuv420p<S2SV_blank>-s<S2SV_blank>%dx%d<S2SV_blank>%s\\\\n\" , info -> frame_width , info -> frame_height , argv [ 2 ] ) ; vpx_video_reader_close ( reader ) ; fclose ( outfile ) ; return EXIT_SUCCESS ; }\n",
    "fixed_code": "<S2SV_ModStart> ( decoder -> codec_interface <S2SV_ModEnd> ( ) ) <S2SV_ModStart> , decoder -> codec_interface <S2SV_ModEnd> ( ) ,\n",
    "source_code_length": 2710,
    "target_code_length": 130,
    "vulnerability_patterns": {
      "buffer_overflow": 2,
      "use_after_free": 6,
      "integer_overflow": 23,
      "null_pointer": 146,
      "total": 177
    },
    "total_patterns": 177,
    "original_address": "https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426",
    "discovery_time": "2016-03-12T21:59Z",
    "project_commit_id": "external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426",
    "extraction_time": "2025-08-31T15:41:49.174025",
    "label": 1,
    "vulnerability_type": "buffer_overflow",
    "difficulty_level": "expert",
    "risk_factors": [
      "memory_corruption",
      "arbitrary_code_execution",
      "buffer_overflow",
      "system_crash",
      "use_after_free"
    ],
    "attack_vectors": [
      "memory_manipulation",
      "malicious_input",
      "code_analysis",
      "buffer_overflow",
      "reverse_engineering",
      "fuzzing"
    ],
    "mitigation_strategies": [
      "safe_string_functions",
      "dynamic_analysis",
      "code_review",
      "static_analysis",
      "memory_safety_checks",
      "input_validation",
      "fuzzing",
      "bounds_checking",
      "secure_coding_practices"
    ],
    "code_differences": {
      "has_differences": true,
      "source_lines": 2,
      "target_lines": 2,
      "character_differences": 2580,
      "similarity_percentage": 4.464285714285714
    },
    "vulnerability_location": {
      "vulnerability_present": true,
      "fix_applied": true,
      "code_changed": true,
      "estimated_lines_changed": 0
    },
    "variants": [
      {
        "variant_id": "CVE-2016-1621_variant_1",
        "source_cve_id": "CVE-2016-1621",
        "variant_number": 1,
        "vulnerable_code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <vpx/vpx_decoder.h>\n#include <vpx/vp8dx.h>\n#include \"vpx_ports/mem_ops.h\"\n#include \"tools_common.h\"\n\n#define DECODER_INITIALIZATION_FLAGS 0\n\ntypedef struct {\n    int start;\n    int end;\n    int step;\n    int mode;\n} FramePattern;\n\nstatic int parse_pattern_argument(const char* pattern_str, FramePattern* pattern) {\n    char* delimiter_ptr = NULL;\n    long start_val = strtol(pattern_str, &delimiter_ptr, 0);\n    if (start_val <= 0) return 0;\n    \n    long end_val = strtol(delimiter_ptr + 1, NULL, 0);\n    if (end_val <= 0) return 0;\n    \n    pattern->start = (int)start_val;\n    pattern->end = (int)end_val;\n    pattern->mode = (*delimiter_ptr == '-') ? 1 : 0;\n    \n    return (*delimiter_ptr == '-' || *delimiter_ptr == '/');\n}\n\nstatic int should_skip_frame(int frame_count, const FramePattern* pattern) {\n    if (pattern->mode) {\n        return (frame_count >= pattern->start && frame_count <= pattern->end);\n    } else {\n        return (pattern->end - (frame_count - 1) % pattern->end <= pattern->start);\n    }\n}\n\nint main(int argc, char** argv) {\n    int frame_counter = 0;\n    FILE* output_file = NULL;\n    vpx_codec_ctx_t decoder_context;\n    const VpxInterface* codec_implementation = NULL;\n    VpxVideoReader* video_reader = NULL;\n    const VpxVideoInfo* video_info = NULL;\n    FramePattern frame_pattern = {0};\n    \n    exec_name = argv[0];\n    \n    if (argc != 4) {\n        die(\"Invalid number of arguments.\");\n    }\n    \n    video_reader = vpx_video_reader_open(argv[1]);\n    if (!video_reader) {\n        die(\"Failed to open %s for reading.\", argv[1]);\n    }\n    \n    output_file = fopen(argv[2], \"wb\");\n    if (!output_file) {\n        die(\"Failed to open %s for writing.\", argv[2]);\n    }\n    \n    if (!parse_pattern_argument(argv[3], &frame_pattern)) {\n        die(\"Couldn't parse pattern %s.\\n\", argv[3]);\n    }\n    \n    video_info = vpx_video_reader_get_info(video_reader);\n    codec_implementation = get_vpx_decoder_by_fourcc(video_info->codec_fourcc);\n    if (!codec_implementation) {\n        die(\"Unknown input codec.\");\n    }\n    \n    printf(\"Using %s\\n\", vpx_codec_iface_name(codec_implementation->interface()));\n    \n    if (vpx_codec_dec_init(&decoder_context, codec_implementation->interface(), \n                          NULL, DECODER_INITIALIZATION_FLAGS)) {\n        die_codec(&decoder_context, \"Failed to initialize decoder.\");\n    }\n    \n    while (vpx_video_reader_read_frame(video_reader)) {\n        vpx_codec_iter_t iterator = NULL;\n        vpx_image_t* decoded_image = NULL;\n        size_t current_frame_size = 0;\n        int skip_current_frame;\n        \n        const unsigned char* frame_data = \n            vpx_video_reader_get_frame(video_reader, &current_frame_size);\n        \n        if (vpx_codec_decode(&decoder_context, frame_data, \n                            (unsigned int)current_frame_size, NULL, 0)) {\n            die_codec(&decoder_context, \"Failed to decode frame.\");\n        }\n        \n        ++frame_counter;\n        \n        skip_current_frame = should_skip_frame(frame_counter, &frame_pattern);\n        \n        if (!skip_current_frame) {\n            putc('.', stdout);\n            while ((decoded_image = vpx_codec_get_frame(&decoder_context, &iterator)) != NULL) {\n                vpx_img_write(decoded_image, output_file);\n            }\n        } else {\n            putc('X', stdout);\n        }\n        \n        fflush(stdout);\n    }\n    \n    printf(\"Processed %d frames.\\n\", frame_counter);\n    \n    if (vpx_codec_destroy(&decoder_context)) {\n        die_codec(&decoder_context, \"Failed to destroy codec.\");\n    }\n    \n    printf(\"Play: ffplay -f rawvideo -pix_fmt yuv420p -s %dx%d %s\\n\",\n           video_info->frame_width, video_info->frame_height, argv[2]);\n    \n    vpx_video_reader_close(video_reader);\n    fclose(output_file);\n    \n    return EXIT_SUCCESS;\n}",
        "fixed_code": "<S2SV_ModStart> ( decoder -> codec_interface <S2SV_ModEnd> ( ) ) <S2SV_ModStart> , decoder -> codec_interface <S2SV_ModEnd> ( ) ,\n",
        "cwe_id": "CWE-119",
        "cvss_score": "critical",
        "weaponization_score": 10.0,
        "project": "external",
        "vulnerability_type": "buffer_overflow",
        "difficulty_level": "expert",
        "risk_factors": [
          "memory_corruption",
          "arbitrary_code_execution",
          "buffer_overflow",
          "system_crash",
          "use_after_free"
        ],
        "attack_vectors": [
          "memory_manipulation",
          "malicious_input",
          "code_analysis",
          "buffer_overflow",
          "reverse_engineering",
          "fuzzing"
        ],
        "mitigation_strategies": [
          "safe_string_functions",
          "dynamic_analysis",
          "code_review",
          "static_analysis",
          "memory_safety_checks",
          "input_validation",
          "fuzzing",
          "bounds_checking",
          "secure_coding_practices"
        ],
        "code_differences": {
          "original_length": 2710,
          "variant_length": 3889,
          "length_difference": 1179,
          "original_lines": 2,
          "variant_lines": 126,
          "line_difference": 124,
          "added_lines": 126,
          "removed_lines": 2,
          "similarity_ratio": 0.13971813911198666
        },
        "vulnerability_location": {
          "vulnerability_present": true,
          "fix_applied": true,
          "code_changed": true,
          "estimated_lines_changed": 0
        },
        "validation_score": 0.75,
        "validation_checks": {
          "code_differences": true,
          "pattern_preservation": true,
          "structure_quality": true,
          "cwe_consistency": false
        },
        "generation_timestamp": "2025-09-02T14:13:41.122817",
        "generation_method": "deepseek_coder_refactoring"
      },
      {
        "variant_id": "CVE-2016-1621_variant_2",
        "source_cve_id": "CVE-2016-1621",
        "variant_number": 2,
        "vulnerable_code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\ntypedef struct VpxInterface VpxInterface;\ntypedef struct VpxVideoReader VpxVideoReader;\ntypedef struct VpxVideoInfo VpxVideoInfo;\ntypedef struct vpx_codec_ctx_t vpx_codec_ctx_t;\ntypedef struct vpx_image_t vpx_image_t;\ntypedef void* vpx_codec_iter_t;\n\nvoid die(const char* format, ...) { exit(EXIT_FAILURE); }\nvoid die_codec(vpx_codec_ctx_t* codec, const char* message) { exit(EXIT_FAILURE); }\nVpxVideoReader* vpx_video_reader_open(const char* filename) { return NULL; }\nconst VpxVideoInfo* vpx_video_reader_get_info(VpxVideoReader* reader) { return NULL; }\nconst VpxInterface* get_vpx_decoder_by_fourcc(unsigned int fourcc) { return NULL; }\nconst char* vpx_codec_iface_name(void* interface) { return \"\"; }\nint vpx_codec_dec_init(vpx_codec_ctx_t* ctx, void* interface, void* config, unsigned int flags) { return 0; }\nint vpx_video_reader_read_frame(VpxVideoReader* reader) { return 0; }\nconst unsigned char* vpx_video_reader_get_frame(VpxVideoReader* reader, size_t* size) { return NULL; }\nint vpx_codec_decode(vpx_codec_ctx_t* ctx, const unsigned char* data, unsigned int len, void* user_priv, long deadline) { return 0; }\nvpx_image_t* vpx_codec_get_frame(vpx_codec_ctx_t* ctx, vpx_codec_iter_t* iter) { return NULL; }\nvoid vpx_img_write(vpx_image_t* img, FILE* file) {}\nint vpx_codec_destroy(vpx_codec_ctx_t* ctx) { return 0; }\nvoid vpx_video_reader_close(VpxVideoReader* reader) {}\n\nchar* exec_name;\n\nint main(int argc_count, char** argument_vector) {\n    int total_frames_processed = 0;\n    FILE* output_file_stream = NULL;\n    vpx_codec_ctx_t decoder_context;\n    const VpxInterface* codec_decoder = NULL;\n    VpxVideoReader* video_reader = NULL;\n    const VpxVideoInfo* video_information = NULL;\n    \n    int start_value = 0;\n    int end_value = 0;\n    int range_mode_enabled = 0;\n    char* string_pointer = NULL;\n    \n    exec_name = argument_vector[0];\n    \n    if (argc_count != 4) {\n        die(\"Invalid number of arguments.\");\n    }\n    \n    video_reader = vpx_video_reader_open(argument_vector[1]);\n    if (!video_reader) {\n        die(\"Failed to open %s for reading.\", argument_vector[1]);\n    }\n    \n    output_file_stream = fopen(argument_vector[2], \"wb\");\n    if (!output_file_stream) {\n        die(\"Failed to open %s for writing.\", argument_vector[2]);\n    }\n    \n    start_value = strtol(argument_vector[3], &string_pointer, 0);\n    end_value = strtol(string_pointer + 1, NULL, 0);\n    range_mode_enabled = (*string_pointer == '-');\n    \n    if (!start_value || !end_value || (*string_pointer != '-' && *string_pointer != '/')) {\n        die(\"Couldn't parse pattern %s.\\n\", argument_vector[3]);\n    }\n    \n    video_information = vpx_video_reader_get_info(video_reader);\n    codec_decoder = get_vpx_decoder_by_fourcc(video_information->codec_fourcc);\n    if (!codec_decoder) {\n        die(\"Unknown input codec.\");\n    }\n    \n    printf(\"Using %s\\n\", vpx_codec_iface_name(codec_decoder->interface()));\n    \n    if (vpx_codec_dec_init(&decoder_context, codec_decoder->interface(), NULL, 0)) {\n        die_codec(&decoder_context, \"Failed to initialize decoder.\");\n    }\n    \n    while (vpx_video_reader_read_frame(video_reader)) {\n        vpx_codec_iter_t iteration_state = NULL;\n        vpx_image_t* decoded_image = NULL;\n        size_t current_frame_size = 0;\n        int should_skip_frame;\n        \n        const unsigned char* frame_data = vpx_video_reader_get_frame(video_reader, &current_frame_size);\n        \n        if (vpx_codec_decode(&decoder_context, frame_data, (unsigned int)current_frame_size, NULL, 0)) {\n            die_codec(&decoder_context, \"Failed to decode frame.\");\n        }\n        \n        ++total_frames_processed;\n        \n        should_skip_frame = (range_mode_enabled && total_frames_processed >= start_value && \n                           total_frames_processed <= end_value) || \n                          (!range_mode_enabled && end_value - (total_frames_processed - 1) % end_value <= start_value);\n        \n        if (!should_skip_frame) {\n            putc('.', stdout);\n            while ((decoded_image = vpx_codec_get_frame(&decoder_context, &iteration_state)) != NULL) {\n                vpx_img_write(decoded_image, output_file_stream);\n            }\n        } else {\n            putc('X', stdout);\n        }\n        \n        fflush(stdout);\n    }\n    \n    printf(\"Processed %d frames.\\n\", total_frames_processed);\n    \n    if (vpx_codec_destroy(&decoder_context)) {\n        die_codec(&decoder_context, \"Failed to destroy codec.\");\n    }\n    \n    printf(\"Play: ffplay -f rawvideo -pix_fmt yuv420p -s %dx%d %s\\n\", \n           video_information->frame_width, video_information->frame_height, argument_vector[2]);\n    \n    vpx_video_reader_close(video_reader);\n    fclose(output_file_stream);\n    \n    return EXIT_SUCCESS;\n}",
        "fixed_code": "<S2SV_ModStart> ( decoder -> codec_interface <S2SV_ModEnd> ( ) ) <S2SV_ModStart> , decoder -> codec_interface <S2SV_ModEnd> ( ) ,\n",
        "cwe_id": "CWE-119",
        "cvss_score": "critical",
        "weaponization_score": 10.0,
        "project": "external",
        "vulnerability_type": "buffer_overflow",
        "difficulty_level": "expert",
        "risk_factors": [
          "memory_corruption",
          "arbitrary_code_execution",
          "buffer_overflow",
          "system_crash",
          "use_after_free"
        ],
        "attack_vectors": [
          "memory_manipulation",
          "malicious_input",
          "code_analysis",
          "buffer_overflow",
          "reverse_engineering",
          "fuzzing"
        ],
        "mitigation_strategies": [
          "safe_string_functions",
          "dynamic_analysis",
          "code_review",
          "static_analysis",
          "memory_safety_checks",
          "input_validation",
          "fuzzing",
          "bounds_checking",
          "secure_coding_practices"
        ],
        "code_differences": {
          "original_length": 2710,
          "variant_length": 4834,
          "length_difference": 2124,
          "original_lines": 2,
          "variant_lines": 121,
          "line_difference": 119,
          "added_lines": 121,
          "removed_lines": 2,
          "similarity_ratio": 0.28525980911983034
        },
        "vulnerability_location": {
          "vulnerability_present": true,
          "fix_applied": true,
          "code_changed": true,
          "estimated_lines_changed": 0
        },
        "validation_score": 0.75,
        "validation_checks": {
          "code_differences": true,
          "pattern_preservation": true,
          "structure_quality": true,
          "cwe_consistency": false
        },
        "generation_timestamp": "2025-09-02T14:14:48.186407",
        "generation_method": "deepseek_coder_refactoring"
      },
      {
        "variant_id": "CVE-2016-1621_variant_3",
        "source_cve_id": "CVE-2016-1621",
        "variant_number": 3,
        "vulnerable_code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\ntypedef struct vpx_codec_ctx_s vpx_codec_ctx_t;\ntypedef struct vpx_image_s vpx_image_t;\ntypedef struct VpxInterface_s VpxInterface;\ntypedef struct VpxVideoReader_s VpxVideoReader;\ntypedef struct VpxVideoInfo_s VpxVideoInfo;\ntypedef void* vpx_codec_iter_t;\n\nconst VpxInterface* get_vpx_decoder_by_fourcc(unsigned int fourcc);\nvoid die(const char* format, ...);\nvoid die_codec(vpx_codec_ctx_t* codec, const char* format, ...);\nVpxVideoReader* vpx_video_reader_open(const char* filename);\nconst VpxVideoInfo* vpx_video_reader_get_info(VpxVideoReader* reader);\nint vpx_video_reader_read_frame(VpxVideoReader* reader);\nconst unsigned char* vpx_video_reader_get_frame(VpxVideoReader* reader, size_t* size);\nvoid vpx_video_reader_close(VpxVideoReader* reader);\nint vpx_codec_dec_init(vpx_codec_ctx_t* codec, void* iface, void* config, unsigned int flags);\nint vpx_codec_decode(vpx_codec_ctx_t* codec, const unsigned char* data, unsigned int len, void* user_priv, long deadline);\nvpx_image_t* vpx_codec_get_frame(vpx_codec_ctx_t* codec, vpx_codec_iter_t* iter);\nint vpx_codec_destroy(vpx_codec_ctx_t* codec);\nvoid vpx_img_write(vpx_image_t* img, FILE* file);\nconst char* vpx_codec_iface_name(void* iface);\n\nchar* exec_name;\n\nint main(int argc, char** argv) {\n    int frame_count = 0;\n    FILE* output_file = NULL;\n    vpx_codec_ctx_t decoder_context;\n    const VpxInterface* decoder_interface = NULL;\n    VpxVideoReader* video_reader = NULL;\n    const VpxVideoInfo* video_info = NULL;\n    \n    int start_val = 0;\n    int end_val = 0;\n    int range_mode = 0;\n    char* parse_ptr = NULL;\n    \n    char** argument_vector = argv;\n    int argument_count = argc;\n    \n    exec_name = argument_vector[0];\n    \n    if (argument_count != 4) {\n        die(\"Invalid number of arguments.\");\n    }\n    \n    video_reader = vpx_video_reader_open(argument_vector[1]);\n    if (!video_reader) {\n        die(\"Failed to open %s for reading.\", argument_vector[1]);\n    }\n    \n    output_file = fopen(argument_vector[2], \"wb\");\n    if (!output_file) {\n        die(\"Failed to open %s for writing.\", argument_vector[2]);\n    }\n    \n    char* pattern_string = argument_vector[3];\n    start_val = strtol(pattern_string, &parse_ptr, 0);\n    \n    if (*parse_ptr == '-' || *parse_ptr == '/') {\n        char* next_ptr = parse_ptr + 1;\n        end_val = strtol(next_ptr, NULL, 0);\n        range_mode = (*parse_ptr == '-');\n    }\n    \n    if (!start_val || !end_val || (*parse_ptr != '-' && *parse_ptr != '/')) {\n        die(\"Couldn't parse pattern %s.\\n\", argument_vector[3]);\n    }\n    \n    video_info = vpx_video_reader_get_info(video_reader);\n    decoder_interface = get_vpx_decoder_by_fourcc(video_info->codec_fourcc);\n    \n    if (!decoder_interface) {\n        die(\"Unknown input codec.\");\n    }\n    \n    printf(\"Using %s\\n\", vpx_codec_iface_name(decoder_interface->interface()));\n    \n    if (vpx_codec_dec_init(&decoder_context, decoder_interface->interface(), NULL, 0)) {\n        die_codec(&decoder_context, \"Failed to initialize decoder.\");\n    }\n    \n    int continue_decoding = 1;\n    while (continue_decoding) {\n        vpx_codec_iter_t iteration_state = NULL;\n        vpx_image_t* decoded_image = NULL;\n        size_t frame_data_size = 0;\n        int should_skip_frame = 0;\n        \n        if (!vpx_video_reader_read_frame(video_reader)) {\n            continue_decoding = 0;\n            break;\n        }\n        \n        const unsigned char* frame_data = vpx_video_reader_get_frame(video_reader, &frame_data_size);\n        \n        if (vpx_codec_decode(&decoder_context, frame_data, (unsigned int)frame_data_size, NULL, 0)) {\n            die_codec(&decoder_context, \"Failed to decode frame.\");\n        }\n        \n        frame_count++;\n        \n        if (range_mode) {\n            should_skip_frame = (frame_count >= start_val) && (frame_count <= end_val);\n        } else {\n            int modulo_result = (frame_count - 1) % end_val;\n            should_skip_frame = (end_val - modulo_result <= start_val);\n        }\n        \n        if (!should_skip_frame) {\n            putc('.', stdout);\n            while ((decoded_image = vpx_codec_get_frame(&decoder_context, &iteration_state)) != NULL) {\n                vpx_img_write(decoded_image, output_file);\n            }\n        } else {\n            putc('X', stdout);\n        }\n        \n        fflush(stdout);\n    }\n    \n    printf(\"Processed %d frames.\\n\", frame_count);\n    \n    if (vpx_codec_destroy(&decoder_context)) {\n        die_codec(&decoder_context, \"Failed to destroy codec.\");\n    }\n    \n    printf(\"Play: ffplay -f rawvideo -pix_fmt yuv420p -s %dx%d %s\\n\", \n           video_info->frame_width, video_info->frame_height, argument_vector[2]);\n    \n    vpx_video_reader_close(video_reader);\n    fclose(output_file);\n    \n    return EXIT_SUCCESS;\n}",
        "fixed_code": "<S2SV_ModStart> ( decoder -> codec_interface <S2SV_ModEnd> ( ) ) <S2SV_ModStart> , decoder -> codec_interface <S2SV_ModEnd> ( ) ,\n",
        "cwe_id": "CWE-119",
        "cvss_score": "critical",
        "weaponization_score": 10.0,
        "project": "external",
        "vulnerability_type": "buffer_overflow",
        "difficulty_level": "expert",
        "risk_factors": [
          "memory_corruption",
          "arbitrary_code_execution",
          "buffer_overflow",
          "system_crash",
          "use_after_free"
        ],
        "attack_vectors": [
          "memory_manipulation",
          "malicious_input",
          "code_analysis",
          "buffer_overflow",
          "reverse_engineering",
          "fuzzing"
        ],
        "mitigation_strategies": [
          "safe_string_functions",
          "dynamic_analysis",
          "code_review",
          "static_analysis",
          "memory_safety_checks",
          "input_validation",
          "fuzzing",
          "bounds_checking",
          "secure_coding_practices"
        ],
        "code_differences": {
          "original_length": 2710,
          "variant_length": 4843,
          "length_difference": 2133,
          "original_lines": 2,
          "variant_lines": 139,
          "line_difference": 137,
          "added_lines": 139,
          "removed_lines": 2,
          "similarity_ratio": 0.2777704223487356
        },
        "vulnerability_location": {
          "vulnerability_present": true,
          "fix_applied": true,
          "code_changed": true,
          "estimated_lines_changed": 0
        },
        "validation_score": 0.75,
        "validation_checks": {
          "code_differences": true,
          "pattern_preservation": true,
          "structure_quality": true,
          "cwe_consistency": false
        },
        "generation_timestamp": "2025-09-02T14:15:55.878012",
        "generation_method": "deepseek_coder_refactoring"
      }
    ],
    "variant_count": 3
  },
  {
    "cve_id": "CVE-2020-14954",
    "cwe_id": "CWE-74",
    "cwe_name": "Command Injection",
    "project": "neomutt",
    "severity": "critical",
    "weaponization_score": 10.0,
    "is_critical": true,
    "is_weaponizable": true,
    "is_high_priority_project": true,
    "vulnerable_code": "CWE-74 int nntp_open_connection ( struct NntpAccountData * adata ) { struct Connection * conn = adata -> conn ; char buf [ 256 ] ; int cap ; bool posting = false , auth = true ; if ( adata -> status == NNTP_OK ) return 0 ; if ( adata -> status == NNTP_BYE ) return - 1 ; adata -> status = NNTP_NONE ; if ( mutt_socket_open ( conn ) < 0 ) return - 1 ; if ( mutt_socket_readln ( buf , sizeof ( buf ) , conn ) < 0 ) return nntp_connect_error ( adata ) ; if ( mutt_str_startswith ( buf , \"200\" , CASE_MATCH ) ) posting = true ; else if ( ! mutt_str_startswith ( buf , \"201\" , CASE_MATCH ) ) { mutt_socket_close ( conn ) ; mutt_str_remove_trailing_ws ( buf ) ; mutt_error ( \"%s\" , buf ) ; return - 1 ; } cap = nntp_capabilities ( adata ) ; if ( cap < 0 ) return - 1 ; if ( cap > 0 ) { if ( ( mutt_socket_send ( conn , \"MODE<S2SV_blank>READER\\\\r\\\\n\" ) < 0 ) || ( mutt_socket_readln ( buf , sizeof ( buf ) , conn ) < 0 ) ) { return nntp_connect_error ( adata ) ; } if ( mutt_str_startswith ( buf , \"200\" , CASE_MATCH ) ) posting = true ; else if ( mutt_str_startswith ( buf , \"201\" , CASE_MATCH ) ) posting = false ; else if ( adata -> hasCAPABILITIES ) { mutt_socket_close ( conn ) ; mutt_error ( _ ( \"Could<S2SV_blank>not<S2SV_blank>switch<S2SV_blank>to<S2SV_blank>reader<S2SV_blank>mode\" ) ) ; return - 1 ; } if ( adata -> hasCAPABILITIES ) { cap = nntp_capabilities ( adata ) ; if ( cap < 0 ) return - 1 ; } } mutt_message ( _ ( \"Connected<S2SV_blank>to<S2SV_blank>%s.<S2SV_blank>%s\" ) , conn -> account . host , posting ? _ ( \"Posting<S2SV_blank>is<S2SV_blank>ok\" ) : _ ( \"Posting<S2SV_blank>is<S2SV_blank>NOT<S2SV_blank>ok\" ) ) ; mutt_sleep ( 1 ) ; # ifdef USE_SSL if ( ( adata -> use_tls != 1 ) && ( adata -> hasSTARTTLS || C_SslForceTls ) ) { if ( adata -> use_tls == 0 ) { adata -> use_tls = C_SslForceTls || query_quadoption ( C_SslStarttls , _ ( \"Secure<S2SV_blank>connection<S2SV_blank>with<S2SV_blank>TLS?\" ) ) == MUTT_YES ? 2 : 1 ; } if ( adata -> use_tls == 2 ) { if ( ( mutt_socket_send ( conn , \"STARTTLS\\\\r\\\\n\" ) < 0 ) || ( mutt_socket_readln ( buf , sizeof ( buf ) , conn ) < 0 ) ) { return nntp_connect_error ( adata ) ; <S2SV_StartBug> } <S2SV_EndBug> if ( ! mutt_str_startswith ( buf , \"382\" , CASE_MATCH ) ) { adata -> use_tls = 0 ; mutt_error ( \"STARTTLS:<S2SV_blank>%s\" , buf ) ; } else if ( mutt_ssl_starttls ( conn ) ) { adata -> use_tls = 0 ; adata -> status = NNTP_NONE ; mutt_socket_close ( adata -> conn ) ; mutt_error ( _ ( \"Could<S2SV_blank>not<S2SV_blank>negotiate<S2SV_blank>TLS<S2SV_blank>connection\" ) ) ; return - 1 ; } else { cap = nntp_capabilities ( adata ) ; if ( cap < 0 ) return - 1 ; } } } # endif if ( conn -> account . flags & MUTT_ACCT_USER ) { if ( ! conn -> account . user [ 0 ] ) auth = false ; } else { if ( ( mutt_socket_send ( conn , \"STAT\\\\r\\\\n\" ) < 0 ) || ( mutt_socket_readln ( buf , sizeof ( buf ) , conn ) < 0 ) ) { return nntp_connect_error ( adata ) ; } if ( ! mutt_str_startswith ( buf , \"480\" , CASE_MATCH ) ) auth = false ; } if ( auth && ( nntp_auth ( adata ) < 0 ) ) return - 1 ; if ( adata -> hasCAPABILITIES && ( auth || ( cap > 0 ) ) ) { cap = nntp_capabilities ( adata ) ; if ( cap < 0 ) return - 1 ; if ( cap > 0 ) { mutt_socket_close ( conn ) ; mutt_error ( _ ( \"Could<S2SV_blank>not<S2SV_blank>switch<S2SV_blank>to<S2SV_blank>reader<S2SV_blank>mode\" ) ) ; return - 1 ; } } if ( nntp_attempt_features ( adata ) < 0 ) return - 1 ; adata -> status = NNTP_OK ; return 0 ; }\n",
    "fixed_code": "<S2SV_ModStart> ) ; } mutt_socket_empty ( conn ) ;\n",
    "source_code_length": 3436,
    "target_code_length": 51,
    "vulnerability_patterns": {
      "null_pointer": 20,
      "total": 20
    },
    "total_patterns": 20,
    "original_address": "https://github.com/neomutt/neomutt/commit/fb013ec666759cb8a9e294347c7b4c1f597639cc",
    "discovery_time": "2020-06-21T17:15Z",
    "project_commit_id": "neomutt@neomutt/fb013ec666759cb8a9e294347c7b4c1f597639cc",
    "extraction_time": "2025-08-31T15:41:49.174087",
    "label": 1,
    "vulnerability_type": "command_injection",
    "difficulty_level": "expert",
    "risk_factors": [
      "command_injection",
      "arbitrary_code_execution",
      "critical_infrastructure",
      "remote_code_execution"
    ],
    "attack_vectors": [
      "command_injection",
      "system_commands",
      "code_analysis",
      "reverse_engineering",
      "fuzzing",
      "user_input"
    ],
    "mitigation_strategies": [
      "fuzzing",
      "dynamic_analysis",
      "command_whitelisting",
      "static_analysis",
      "secure_coding_practices",
      "privilege_separation",
      "input_sanitization",
      "code_review",
      "input_validation"
    ],
    "code_differences": {
      "has_differences": true,
      "source_lines": 2,
      "target_lines": 2,
      "character_differences": 3385,
      "similarity_percentage": 4.901960784313726
    },
    "vulnerability_location": {
      "vulnerability_present": true,
      "fix_applied": true,
      "code_changed": true,
      "estimated_lines_changed": 0
    },
    "variants": [
      {
        "variant_id": "CVE-2020-14954_variant_1",
        "source_cve_id": "CVE-2020-14954",
        "variant_number": 1,
        "vulnerable_code": "int nntp_open_connection(struct NntpAccountData *adata) {\n    struct Connection *conn_ptr = adata->conn;\n    char response_buffer[256];\n    int capability_flags;\n    bool posting_enabled = false, authentication_required = true;\n    \n    if (adata->status == NNTP_OK) return 0;\n    if (adata->status == NNTP_BYE) return -1;\n    \n    adata->status = NNTP_NONE;\n    \n    if (mutt_socket_open(conn_ptr) < 0) return -1;\n    \n    if (mutt_socket_readln(response_buffer, sizeof(response_buffer), conn_ptr) < 0)\n        return nntp_connect_error(adata);\n    \n    char *buf_start = response_buffer;\n    if (mutt_str_startswith(buf_start, \"200\", CASE_MATCH)) {\n        posting_enabled = true;\n    } else if (!mutt_str_startswith(buf_start, \"201\", CASE_MATCH)) {\n        mutt_socket_close(conn_ptr);\n        mutt_str_remove_trailing_ws(response_buffer);\n        mutt_error(\"%s\", response_buffer);\n        return -1;\n    }\n    \n    capability_flags = nntp_capabilities(adata);\n    if (capability_flags < 0) return -1;\n    \n    if (capability_flags > 0) {\n        const char *mode_command = \"MODE<S2SV_blank>READER\\\\r\\\\n\";\n        if ((mutt_socket_send(conn_ptr, mode_command) < 0) || \n            (mutt_socket_readln(response_buffer, sizeof(response_buffer), conn_ptr) < 0)) {\n            return nntp_connect_error(adata);\n        }\n        \n        char *response_ptr = response_buffer;\n        if (mutt_str_startswith(response_ptr, \"200\", CASE_MATCH)) {\n            posting_enabled = true;\n        } else if (mutt_str_startswith(response_ptr, \"201\", CASE_MATCH)) {\n            posting_enabled = false;\n        } else if (adata->hasCAPABILITIES) {\n            mutt_socket_close(conn_ptr);\n            mutt_error(_(\"Could<S2SV_blank>not<S2SV_blank>switch<S2SV_blank>to<S2SV_blank>reader<S2SV_blank>mode\"));\n            return -1;\n        }\n        \n        if (adata->hasCAPABILITIES) {\n            capability_flags = nntp_capabilities(adata);\n            if (capability_flags < 0) return -1;\n        }\n    }\n    \n    const char *posting_status = posting_enabled ? _(\"Posting<S2SV_blank>is<S2SV_blank>ok\") : \n                                                  _(\"Posting<S2SV_blank>is<S2SV_blank>NOT<S2SV_blank>ok\");\n    mutt_message(_(\"Connected<S2SV_blank>to<S2SV_blank>%s.<S2SV_blank>%s\"), \n                 conn_ptr->account.host, posting_status);\n    mutt_sleep(1);\n\n#ifdef USE_SSL\n    int tls_config = adata->use_tls;\n    bool tls_available = adata->hasSTARTTLS || C_SslForceTls;\n    \n    if ((tls_config != 1) && tls_available) {\n        if (tls_config == 0) {\n            int tls_decision = query_quadoption(C_SslStarttls, \n                                              _(\"Secure<S2SV_blank>connection<S2SV_blank>with<S2SV_blank>TLS?\"));\n            adata->use_tls = C_SslForceTls || (tls_decision == MUTT_YES) ? 2 : 1;\n        }\n        \n        if (adata->use_tls == 2) {\n            const char *starttls_cmd = \"STARTTLS\\\\r\\\\n\";\n            if ((mutt_socket_send(conn_ptr, starttls_cmd) < 0) || \n                (mutt_socket_readln(response_buffer, sizeof(response_buffer), conn_ptr) < 0)) {\n                return nntp_connect_error(adata);\n            }\n            \n            char *tls_response = response_buffer;\n            if (!mutt_str_startswith(tls_response, \"382\", CASE_MATCH)) {\n                adata->use_tls = 0;\n                mutt_error(\"STARTTLS:<S2SV_blank>%s\", response_buffer);\n            } else if (mutt_ssl_starttls(conn_ptr)) {\n                adata->use_tls = 0;\n                adata->status = NNTP_NONE;\n                mutt_socket_close(adata->conn);\n                mutt_error(_(\"Could<S2SV_blank>not<S2SV_blank>negotiate<S2SV_blank>TLS<S2SV_blank>connection\"));\n                return -1;\n            } else {\n                capability_flags = nntp_capabilities(adata);\n                if (capability_flags < 0) return -1;\n            }\n        }\n    }\n#endif\n\n    unsigned int account_flags = conn_ptr->account.flags;\n    if (account_flags & MUTT_ACCT_USER) {\n        if (!conn_ptr->account.user[0]) authentication_required = false;\n    } else {\n        const char *stat_cmd = \"STAT\\\\r\\\\n\";\n        if ((mutt_socket_send(conn_ptr, stat_cmd) < 0) || \n            (mutt_socket_readln(response_buffer, sizeof(response_buffer), conn_ptr) < 0)) {\n            return nntp_connect_error(adata);\n        }\n        \n        char *stat_response = response_buffer;\n        if (!mutt_str_startswith(stat_response, \"480\", CASE_MATCH)) \n            authentication_required = false;\n    }\n    \n    if (authentication_required && (nntp_auth(adata) < 0)) return -1;\n    \n    bool has_caps = adata->hasCAPABILITIES;\n    bool auth_or_cap = authentication_required || (capability_flags > 0);\n    \n    if (has_caps && auth_or_cap) {\n        capability_flags = nntp_capabilities(adata);\n        if (capability_flags < 0) return -1;\n        \n        if (capability_flags > 0) {\n            mutt_socket_close(conn_ptr);\n            mutt_error(_(\"Could<S2SV_blank>not<S2SV_blank>switch<S2SV_blank>to<S2SV_blank>reader<S2SV_blank>mode\"));\n            return -1;\n        }\n    }\n    \n    if (nntp_attempt_features(adata) < 0) return -1;\n    \n    adata->status = NNTP_OK;\n    return 0;\n}",
        "fixed_code": "<S2SV_ModStart> ) ; } mutt_socket_empty ( conn ) ;\n",
        "cwe_id": "CWE-74",
        "cvss_score": "critical",
        "weaponization_score": 10.0,
        "project": "neomutt",
        "vulnerability_type": "command_injection",
        "difficulty_level": "expert",
        "risk_factors": [
          "command_injection",
          "arbitrary_code_execution",
          "critical_infrastructure",
          "remote_code_execution"
        ],
        "attack_vectors": [
          "command_injection",
          "system_commands",
          "code_analysis",
          "reverse_engineering",
          "fuzzing",
          "user_input"
        ],
        "mitigation_strategies": [
          "fuzzing",
          "dynamic_analysis",
          "command_whitelisting",
          "static_analysis",
          "secure_coding_practices",
          "privilege_separation",
          "input_sanitization",
          "code_review",
          "input_validation"
        ],
        "code_differences": {
          "original_length": 3436,
          "variant_length": 5190,
          "length_difference": 1754,
          "original_lines": 2,
          "variant_lines": 131,
          "line_difference": 129,
          "added_lines": 131,
          "removed_lines": 2,
          "similarity_ratio": 0.43890563412937633
        },
        "vulnerability_location": {
          "vulnerability_present": true,
          "fix_applied": true,
          "code_changed": true,
          "estimated_lines_changed": 0
        },
        "validation_score": 0.75,
        "validation_checks": {
          "code_differences": true,
          "pattern_preservation": true,
          "structure_quality": true,
          "cwe_consistency": false
        },
        "generation_timestamp": "2025-09-02T14:17:10.532708",
        "generation_method": "deepseek_coder_refactoring"
      },
      {
        "variant_id": "CVE-2020-14954_variant_2",
        "source_cve_id": "CVE-2020-14954",
        "variant_number": 2,
        "vulnerable_code": "int nntp_open_connection(struct NntpAccountData *adata) {\n    struct Connection *conn_ptr = adata->conn;\n    char connection_buffer[256];\n    int capability_flags;\n    bool posting_enabled = false, authentication_required = true;\n    volatile int unused_flag = 0;\n\n    if (adata->status == NNTP_OK) return 0;\n    if (adata->status == NNTP_BYE) return -1;\n\n    adata->status = NNTP_NONE;\n    if (mutt_socket_open(conn_ptr) < 0) return -1;\n\n    if (mutt_socket_readln(connection_buffer, sizeof(connection_buffer), conn_ptr) < 0)\n        return nntp_connect_error(adata);\n\n    char *buf_ptr = connection_buffer;\n    if (mutt_str_startswith(buf_ptr, \"200\", CASE_MATCH)) {\n        posting_enabled = true;\n        unused_flag |= 0x01;\n    } else if (!mutt_str_startswith(buf_ptr, \"201\", CASE_MATCH)) {\n        mutt_socket_close(conn_ptr);\n        mutt_str_remove_trailing_ws(buf_ptr);\n        mutt_error(\"%s\", buf_ptr);\n        return -1;\n    }\n\n    capability_flags = nntp_capabilities(adata);\n    if (capability_flags < 0) return -1;\n\n    if (capability_flags > 0) {\n        const char *mode_command = \"MODE READER\\r\\n\";\n        if ((mutt_socket_send(conn_ptr, mode_command) < 0) || \n            (mutt_socket_readln(connection_buffer, sizeof(connection_buffer), conn_ptr) < 0)) {\n            return nntp_connect_error(adata);\n        }\n\n        char *response_ptr = connection_buffer;\n        if (mutt_str_startswith(response_ptr, \"200\", CASE_MATCH)) {\n            posting_enabled = true;\n            unused_flag |= 0x02;\n        } else if (mutt_str_startswith(response_ptr, \"201\", CASE_MATCH)) {\n            posting_enabled = false;\n        } else if (adata->hasCAPABILITIES) {\n            mutt_socket_close(conn_ptr);\n            mutt_error(_(\"Could not switch to reader mode\"));\n            return -1;\n        }\n\n        if (adata->hasCAPABILITIES) {\n            capability_flags = nntp_capabilities(adata);\n            if (capability_flags < 0) return -1;\n        }\n    }\n\n    mutt_message(_(\"Connected to %s. %s\"), conn_ptr->account.host,\n                 posting_enabled ? _(\"Posting is ok\") : _(\"Posting is NOT ok\"));\n    mutt_sleep(1);\n\n#ifdef USE_SSL\n    int tls_decision = adata->use_tls;\n    if ((tls_decision != 1) && (adata->hasSTARTTLS || C_SslForceTls)) {\n        if (tls_decision == 0) {\n            tls_decision = C_SslForceTls || \n                          query_quadoption(C_SslStarttls, _(\"Secure connection with TLS?\")) == MUTT_YES ? 2 : 1;\n            adata->use_tls = tls_decision;\n        }\n\n        if (tls_decision == 2) {\n            const char *starttls_cmd = \"STARTTLS\\r\\n\";\n            if ((mutt_socket_send(conn_ptr, starttls_cmd) < 0) || \n                (mutt_socket_readln(connection_buffer, sizeof(connection_buffer), conn_ptr) < 0)) {\n                return nntp_connect_error(adata);\n            }\n\n            char *tls_response = connection_buffer;\n            if (!mutt_str_startswith(tls_response, \"382\", CASE_MATCH)) {\n                adata->use_tls = 0;\n                mutt_error(\"STARTTLS: %s\", tls_response);\n            } else if (mutt_ssl_starttls(conn_ptr)) {\n                adata->use_tls = 0;\n                adata->status = NNTP_NONE;\n                mutt_socket_close(adata->conn);\n                mutt_error(_(\"Could not negotiate TLS connection\"));\n                return -1;\n            } else {\n                capability_flags = nntp_capabilities(adata);\n                if (capability_flags < 0) return -1;\n            }\n        }\n    }\n#endif\n\n    struct Account *acc = &conn_ptr->account;\n    if (acc->flags & MUTT_ACCT_USER) {\n        if (!acc->user[0]) authentication_required = false;\n    } else {\n        const char *stat_cmd = \"STAT\\r\\n\";\n        if ((mutt_socket_send(conn_ptr, stat_cmd) < 0) || \n            (mutt_socket_readln(connection_buffer, sizeof(connection_buffer), conn_ptr) < 0)) {\n            return nntp_connect_error(adata);\n        }\n\n        char *stat_response = connection_buffer;\n        if (!mutt_str_startswith(stat_response, \"480\", CASE_MATCH))\n            authentication_required = false;\n    }\n\n    if (authentication_required && (nntp_auth(adata) < 0))\n        return -1;\n\n    if (adata->hasCAPABILITIES && (authentication_required || (capability_flags > 0))) {\n        capability_flags = nntp_capabilities(adata);\n        if (capability_flags < 0) return -1;\n        \n        if (capability_flags > 0) {\n            mutt_socket_close(conn_ptr);\n            mutt_error(_(\"Could not switch to reader mode\"));\n            return -1;\n        }\n    }\n\n    if (nntp_attempt_features(adata) < 0)\n        return -1;\n\n    adata->status = NNTP_OK;\n    return 0;\n}",
        "fixed_code": "<S2SV_ModStart> ) ; } mutt_socket_empty ( conn ) ;\n",
        "cwe_id": "CWE-74",
        "cvss_score": "critical",
        "weaponization_score": 10.0,
        "project": "neomutt",
        "vulnerability_type": "command_injection",
        "difficulty_level": "expert",
        "risk_factors": [
          "command_injection",
          "arbitrary_code_execution",
          "critical_infrastructure",
          "remote_code_execution"
        ],
        "attack_vectors": [
          "command_injection",
          "system_commands",
          "code_analysis",
          "reverse_engineering",
          "fuzzing",
          "user_input"
        ],
        "mitigation_strategies": [
          "fuzzing",
          "dynamic_analysis",
          "command_whitelisting",
          "static_analysis",
          "secure_coding_practices",
          "privilege_separation",
          "input_sanitization",
          "code_review",
          "input_validation"
        ],
        "code_differences": {
          "original_length": 3436,
          "variant_length": 4643,
          "length_difference": 1207,
          "original_lines": 2,
          "variant_lines": 128,
          "line_difference": 126,
          "added_lines": 128,
          "removed_lines": 2,
          "similarity_ratio": 0.41143705904196065
        },
        "vulnerability_location": {
          "vulnerability_present": true,
          "fix_applied": true,
          "code_changed": true,
          "estimated_lines_changed": 0
        },
        "validation_score": 0.75,
        "validation_checks": {
          "code_differences": true,
          "pattern_preservation": true,
          "structure_quality": true,
          "cwe_consistency": false
        },
        "generation_timestamp": "2025-09-02T14:18:15.113003",
        "generation_method": "deepseek_coder_refactoring"
      },
      {
        "variant_id": "CVE-2020-14954_variant_3",
        "source_cve_id": "CVE-2020-14954",
        "variant_number": 3,
        "vulnerable_code": "int nntp_open_connection(struct NntpAccountData *adata) {\n    struct Connection *conn_ptr = adata->conn;\n    char connection_buffer[256];\n    int capability_flags;\n    bool posting_enabled = false, authentication_required = true;\n    volatile int unused_var1 = 0;\n    char *buf_ptr = connection_buffer;\n\n    if (adata->status == NNTP_OK) return unused_var1;\n    if (adata->status == NNTP_BYE) return -1;\n    \n    adata->status = NNTP_NONE;\n    if (mutt_socket_open(conn_ptr) < 0) return -1;\n\n    if (mutt_socket_readln(*(&buf_ptr), sizeof(connection_buffer), conn_ptr) < 0)\n        return nntp_connect_error(adata);\n\n    char *response_check = buf_ptr;\n    while (*response_check) {\n        if (mutt_str_startswith(response_check, \"200\", CASE_MATCH)) {\n            posting_enabled = true;\n            break;\n        } else if (mutt_str_startswith(response_check, \"201\", CASE_MATCH)) {\n            break;\n        }\n        response_check++;\n        if (*response_check == '\\0') {\n            mutt_socket_close(conn_ptr);\n            mutt_str_remove_trailing_ws(buf_ptr);\n            mutt_error(\"%s\", buf_ptr);\n            return -1;\n        }\n    }\n\n    capability_flags = nntp_capabilities(adata);\n    if (capability_flags < 0) return -1;\n\n    if (capability_flags > 0) {\n        const char *mode_command = \"MODE READER\\r\\n\";\n        int send_result = mutt_socket_send(conn_ptr, mode_command);\n        int read_result = mutt_socket_readln(buf_ptr, sizeof(connection_buffer), conn_ptr);\n        \n        if (send_result < 0 || read_result < 0)\n            return nntp_connect_error(adata);\n\n        char *temp = buf_ptr;\n        for (int i = 0; i < 3; i++) {\n            if (mutt_str_startswith(temp, \"200\", CASE_MATCH)) {\n                posting_enabled = true;\n                break;\n            } else if (mutt_str_startswith(temp, \"201\", CASE_MATCH)) {\n                posting_enabled = false;\n                break;\n            }\n            temp++;\n        }\n\n        if (adata->hasCAPABILITIES && !posting_enabled && \n            !mutt_str_startswith(buf_ptr, \"200\", CASE_MATCH) && \n            !mutt_str_startswith(buf_ptr, \"201\", CASE_MATCH)) {\n            mutt_socket_close(conn_ptr);\n            mutt_error(_(\"Could not switch to reader mode\"));\n            return -1;\n        }\n\n        if (adata->hasCAPABILITIES) {\n            capability_flags = nntp_capabilities(adata);\n            if (capability_flags < 0) return -1;\n        }\n    }\n\n    mutt_message(_(\"Connected to %s. %s\"), conn_ptr->account.host,\n                 posting_enabled ? _(\"Posting is ok\") : _(\"Posting is NOT ok\"));\n    mutt_sleep(1);\n\n#ifdef USE_SSL\n    int tls_decision = adata->use_tls;\n    if ((tls_decision != 1) && (adata->hasSTARTTLS || C_SslForceTls)) {\n        if (tls_decision == 0) {\n            tls_decision = C_SslForceTls || \n                query_quadoption(C_SslStarttls, _(\"Secure connection with TLS?\")) == MUTT_YES ? 2 : 1;\n            adata->use_tls = tls_decision;\n        }\n        \n        if (tls_decision == 2) {\n            const char *starttls_cmd = \"STARTTLS\\r\\n\";\n            if ((mutt_socket_send(conn_ptr, starttls_cmd) < 0) || \n                (mutt_socket_readln(buf_ptr, sizeof(connection_buffer), conn_ptr) < 0)) {\n                return nntp_connect_error(adata);\n            }\n            \n            if (!mutt_str_startswith(buf_ptr, \"382\", CASE_MATCH)) {\n                adata->use_tls = 0;\n                mutt_error(\"STARTTLS: %s\", buf_ptr);\n            } else if (mutt_ssl_starttls(conn_ptr)) {\n                adata->use_tls = 0;\n                adata->status = NNTP_NONE;\n                mutt_socket_close(adata->conn);\n                mutt_error(_(\"Could not negotiate TLS connection\"));\n                return -1;\n            } else {\n                capability_flags = nntp_capabilities(adata);\n                if (capability_flags < 0) return -1;\n            }\n        }\n    }\n#endif\n\n    struct Account *acc = &conn_ptr->account;\n    if (acc->flags & MUTT_ACCT_USER) {\n        if (!acc->user[0]) authentication_required = false;\n    } else {\n        const char *stat_cmd = \"STAT\\r\\n\";\n        if ((mutt_socket_send(conn_ptr, stat_cmd) < 0) || \n            (mutt_socket_readln(buf_ptr, sizeof(connection_buffer), conn_ptr) < 0)) {\n            return nntp_connect_error(adata);\n        }\n        \n        char *resp_check = buf_ptr;\n        while (*resp_check && !isdigit(*resp_check)) resp_check++;\n        if (!mutt_str_startswith(resp_check, \"480\", CASE_MATCH))\n            authentication_required = false;\n    }\n\n    if (authentication_required && nntp_auth(adata) < 0)\n        return -1;\n\n    if (adata->hasCAPABILITIES && (authentication_required || capability_flags > 0)) {\n        int new_caps = nntp_capabilities(adata);\n        if (new_caps < 0) return -1;\n        if (new_caps > 0) {\n            mutt_socket_close(conn_ptr);\n            mutt_error(_(\"Could not switch to reader mode\"));\n            return -1;\n        }\n    }\n\n    if (nntp_attempt_features(adata) < 0)\n        return -1;\n\n    adata->status = NNTP_OK;\n    return 0;\n}",
        "fixed_code": "<S2SV_ModStart> ) ; } mutt_socket_empty ( conn ) ;\n",
        "cwe_id": "CWE-74",
        "cvss_score": "critical",
        "weaponization_score": 10.0,
        "project": "neomutt",
        "vulnerability_type": "command_injection",
        "difficulty_level": "expert",
        "risk_factors": [
          "command_injection",
          "arbitrary_code_execution",
          "critical_infrastructure",
          "remote_code_execution"
        ],
        "attack_vectors": [
          "command_injection",
          "system_commands",
          "code_analysis",
          "reverse_engineering",
          "fuzzing",
          "user_input"
        ],
        "mitigation_strategies": [
          "fuzzing",
          "dynamic_analysis",
          "command_whitelisting",
          "static_analysis",
          "secure_coding_practices",
          "privilege_separation",
          "input_sanitization",
          "code_review",
          "input_validation"
        ],
        "code_differences": {
          "original_length": 3436,
          "variant_length": 5075,
          "length_difference": 1639,
          "original_lines": 2,
          "variant_lines": 143,
          "line_difference": 141,
          "added_lines": 143,
          "removed_lines": 2,
          "similarity_ratio": 0.3771589707437434
        },
        "vulnerability_location": {
          "vulnerability_present": true,
          "fix_applied": true,
          "code_changed": true,
          "estimated_lines_changed": 0
        },
        "validation_score": 0.75,
        "validation_checks": {
          "code_differences": true,
          "pattern_preservation": true,
          "structure_quality": true,
          "cwe_consistency": false
        },
        "generation_timestamp": "2025-09-02T14:19:25.992315",
        "generation_method": "deepseek_coder_refactoring"
      }
    ],
    "variant_count": 3
  },
  {
    "cve_id": "CVE-2020-15474",
    "cwe_id": "CWE-787",
    "cwe_name": "Out-of-bounds Write",
    "project": "ntop",
    "severity": "critical",
    "weaponization_score": 10.0,
    "is_critical": true,
    "is_weaponizable": true,
    "is_high_priority_project": false,
    "vulnerable_code": "CWE-787 static void processCertificateElements ( struct ndpi_detection_module_struct * ndpi_struct , struct ndpi_flow_struct * flow , u_int16_t p_offset , u_int16_t certificate_len ) { struct ndpi_packet_struct * packet = & flow -> packet ; u_int num_found = 0 , i ; <S2SV_StartBug> char buffer [ 64 ] = { '\\\\0' } , rdnSeqBuf [ 1024 ] = { '\\\\0' } ; <S2SV_EndBug> u_int rdn_len = 0 ; # ifdef DEBUG_TLS printf ( \"[TLS]<S2SV_blank>%s()<S2SV_blank>[offset:<S2SV_blank>%u][certificate_len:<S2SV_blank>%u]\\\\n\" , __FUNCTION__ , p_offset , certificate_len ) ; # endif for ( i = p_offset ; i < certificate_len ; i ++ ) { if ( ( packet -> payload [ i ] == 0x55 ) && ( packet -> payload [ i + 1 ] == 0x04 ) && ( packet -> payload [ i + 2 ] == 0x03 ) ) { int rc = extractRDNSequence ( packet , i , buffer , sizeof ( buffer ) , rdnSeqBuf , & rdn_len , sizeof ( rdnSeqBuf ) , \"CN\" ) ; if ( rc == - 1 ) break ; # ifdef DEBUG_TLS printf ( \"[TLS]<S2SV_blank>%s()<S2SV_blank>[%s][%s:<S2SV_blank>%s]\\\\n\" , __FUNCTION__ , ( num_found == 0 ) ? \"Subject\" : \"Issuer\" , \"Common<S2SV_blank>Name\" , buffer ) ; # endif } else if ( ( packet -> payload [ i ] == 0x55 ) && ( packet -> payload [ i + 1 ] == 0x04 ) && ( packet -> payload [ i + 2 ] == 0x06 ) ) { int rc = extractRDNSequence ( packet , i , buffer , sizeof ( buffer ) , rdnSeqBuf , & rdn_len , sizeof ( rdnSeqBuf ) , \"C\" ) ; if ( rc == - 1 ) break ; # ifdef DEBUG_TLS printf ( \"[TLS]<S2SV_blank>%s()<S2SV_blank>[%s][%s:<S2SV_blank>%s]\\\\n\" , __FUNCTION__ , ( num_found == 0 ) ? \"Subject\" : \"Issuer\" , \"Country\" , buffer ) ; # endif } else if ( ( packet -> payload [ i ] == 0x55 ) && ( packet -> payload [ i + 1 ] == 0x04 ) && ( packet -> payload [ i + 2 ] == 0x07 ) ) { int rc = extractRDNSequence ( packet , i , buffer , sizeof ( buffer ) , rdnSeqBuf , & rdn_len , sizeof ( rdnSeqBuf ) , \"L\" ) ; if ( rc == - 1 ) break ; # ifdef DEBUG_TLS printf ( \"[TLS]<S2SV_blank>%s()<S2SV_blank>[%s][%s:<S2SV_blank>%s]\\\\n\" , __FUNCTION__ , ( num_found == 0 ) ? \"Subject\" : \"Issuer\" , \"Locality\" , buffer ) ; # endif } else if ( ( packet -> payload [ i ] == 0x55 ) && ( packet -> payload [ i + 1 ] == 0x04 ) && ( packet -> payload [ i + 2 ] == 0x08 ) ) { int rc = extractRDNSequence ( packet , i , buffer , sizeof ( buffer ) , rdnSeqBuf , & rdn_len , sizeof ( rdnSeqBuf ) , \"ST\" ) ; if ( rc == - 1 ) break ; # ifdef DEBUG_TLS printf ( \"[TLS]<S2SV_blank>%s()<S2SV_blank>[%s][%s:<S2SV_blank>%s]\\\\n\" , __FUNCTION__ , ( num_found == 0 ) ? \"Subject\" : \"Issuer\" , \"State<S2SV_blank>or<S2SV_blank>Province\" , buffer ) ; # endif } else if ( ( packet -> payload [ i ] == 0x55 ) && ( packet -> payload [ i + 1 ] == 0x04 ) && ( packet -> payload [ i + 2 ] == 0x0a ) ) { int rc = extractRDNSequence ( packet , i , buffer , sizeof ( buffer ) , rdnSeqBuf , & rdn_len , sizeof ( rdnSeqBuf ) , \"O\" ) ; if ( rc == - 1 ) break ; # ifdef DEBUG_TLS printf ( \"[TLS]<S2SV_blank>%s()<S2SV_blank>[%s][%s:<S2SV_blank>%s]\\\\n\" , __FUNCTION__ , ( num_found == 0 ) ? \"Subject\" : \"Issuer\" , \"Organization<S2SV_blank>Name\" , buffer ) ; # endif } else if ( ( packet -> payload [ i ] == 0x55 ) && ( packet -> payload [ i + 1 ] == 0x04 ) && ( packet -> payload [ i + 2 ] == 0x0b ) ) { int rc = extractRDNSequence ( packet , i , buffer , sizeof ( buffer ) , rdnSeqBuf , & rdn_len , sizeof ( rdnSeqBuf ) , \"OU\" ) ; if ( rc == - 1 ) break ; # ifdef DEBUG_TLS printf ( \"[TLS]<S2SV_blank>%s()<S2SV_blank>[%s][%s:<S2SV_blank>%s]\\\\n\" , __FUNCTION__ , ( num_found == 0 ) ? \"Subject\" : \"Issuer\" , \"Organization<S2SV_blank>Unit\" , buffer ) ; # endif } else if ( ( packet -> payload [ i ] == 0x30 ) && ( packet -> payload [ i + 1 ] == 0x1e ) && ( packet -> payload [ i + 2 ] == 0x17 ) ) { u_int8_t len = packet -> payload [ i + 3 ] ; u_int offset = i + 4 ; if ( num_found == 0 ) { num_found ++ ; # ifdef DEBUG_TLS printf ( \"[TLS]<S2SV_blank>%s()<S2SV_blank>IssuerDN<S2SV_blank>[%s]\\\\n\" , __FUNCTION__ , rdnSeqBuf ) ; # endif if ( rdn_len ) flow -> protos . stun_ssl . ssl . issuerDN = ndpi_strdup ( rdnSeqBuf ) ; rdn_len = 0 ; } if ( ( offset + len ) < packet -> payload_packet_len ) { char utcDate [ 32 ] ; # ifdef DEBUG_TLS u_int j ; printf ( \"[CERTIFICATE]<S2SV_blank>notBefore<S2SV_blank>[len:<S2SV_blank>%u][\" , len ) ; for ( j = 0 ; j < len ; j ++ ) printf ( \"%c\" , packet -> payload [ i + 4 + j ] ) ; printf ( \"]\\\\n\" ) ; # endif if ( len < ( sizeof ( utcDate ) - 1 ) ) { struct tm utc ; utc . tm_isdst = - 1 ; strncpy ( utcDate , ( const char * ) & packet -> payload [ i + 4 ] , len ) ; utcDate [ len ] = '\\\\0' ; if ( strptime ( utcDate , \"%y%m%d%H%M%SZ\" , & utc ) != NULL ) { flow -> protos . stun_ssl . ssl . notBefore = timegm ( & utc ) ; # ifdef DEBUG_TLS printf ( \"[CERTIFICATE]<S2SV_blank>notBefore<S2SV_blank>%u<S2SV_blank>[%s]\\\\n\" , flow -> protos . stun_ssl . ssl . notBefore , utcDate ) ; # endif } } offset += len ; if ( ( offset + 1 ) < packet -> payload_packet_len ) { len = packet -> payload [ offset + 1 ] ; offset += 2 ; if ( ( offset + len ) < packet -> payload_packet_len ) { u_int32_t time_sec = flow -> packet . current_time_ms / 1000 ; # ifdef DEBUG_TLS u_int j ; printf ( \"[CERTIFICATE]<S2SV_blank>notAfter<S2SV_blank>[len:<S2SV_blank>%u][\" , len ) ; for ( j = 0 ; j < len ; j ++ ) printf ( \"%c\" , packet -> payload [ offset + j ] ) ; printf ( \"]\\\\n\" ) ; # endif if ( len < ( sizeof ( utcDate ) - 1 ) ) { struct tm utc ; utc . tm_isdst = - 1 ; strncpy ( utcDate , ( const char * ) & packet -> payload [ offset ] , len ) ; utcDate [ len ] = '\\\\0' ; if ( strptime ( utcDate , \"%y%m%d%H%M%SZ\" , & utc ) != NULL ) { flow -> protos . stun_ssl . ssl . notAfter = timegm ( & utc ) ; # ifdef DEBUG_TLS printf ( \"[CERTIFICATE]<S2SV_blank>notAfter<S2SV_blank>%u<S2SV_blank>[%s]\\\\n\" , flow -> protos . stun_ssl . ssl . notAfter , utcDate ) ; # endif } } if ( ( time_sec < flow -> protos . stun_ssl . ssl . notBefore ) || ( time_sec > flow -> protos . stun_ssl . ssl . notAfter ) ) NDPI_SET_BIT ( flow -> risk , NDPI_TLS_CERTIFICATE_EXPIRED ) ; } } } } else if ( ( packet -> payload [ i ] == 0x55 ) && ( packet -> payload [ i + 1 ] == 0x1d ) && ( packet -> payload [ i + 2 ] == 0x11 ) ) { u_int8_t matched_name = 0 ; # ifdef DEBUG_TLS printf ( \"*******<S2SV_blank>[TLS]<S2SV_blank>Found<S2SV_blank>subjectAltName\\\\n\" ) ; # endif i += 3 ; i ++ ; if ( i < packet -> payload_packet_len ) { i += ( packet -> payload [ i ] & 0x80 ) ? ( packet -> payload [ i ] & 0x7F ) : 0 ; if ( i < packet -> payload_packet_len ) { i += 2 ; if ( i < packet -> payload_packet_len ) { i += ( packet -> payload [ i ] & 0x80 ) ? ( packet -> payload [ i ] & 0x7F ) : 0 ; i ++ ; while ( i < packet -> payload_packet_len ) { if ( packet -> payload [ i ] == 0x82 ) { if ( ( i < ( packet -> payload_packet_len - 1 ) ) && ( ( i + packet -> payload [ i + 1 ] + 2 ) < packet -> payload_packet_len ) ) { u_int8_t len = packet -> payload [ i + 1 ] ; char dNSName [ 256 ] ; i += 2 ; if ( len == 0 ) break ; strncpy ( dNSName , ( const char * ) & packet -> payload [ i ] , len ) ; dNSName [ len ] = '\\\\0' ; cleanupServerName ( dNSName , len ) ; # if DEBUG_TLS printf ( \"[TLS]<S2SV_blank>dNSName<S2SV_blank>%s<S2SV_blank>[%s]\\\\n\" , dNSName , flow -> protos . stun_ssl . ssl . client_requested_server_name ) ; # endif if ( matched_name == 0 ) { if ( ( dNSName [ 0 ] == '*' ) && strstr ( flow -> protos . stun_ssl . ssl . client_requested_server_name , & dNSName [ 1 ] ) ) matched_name = 1 ; else if ( strcmp ( flow -> protos . stun_ssl . ssl . client_requested_server_name , dNSName ) == 0 ) matched_name = 1 ; } if ( flow -> protos . stun_ssl . ssl . server_names == NULL ) flow -> protos . stun_ssl . ssl . server_names = ndpi_strdup ( dNSName ) , flow -> protos . stun_ssl . ssl . server_names_len = strlen ( dNSName ) ; else { u_int16_t dNSName_len = strlen ( dNSName ) ; u_int16_t newstr_len = flow -> protos . stun_ssl . ssl . server_names_len + dNSName_len + 1 ; char * newstr = ( char * ) ndpi_realloc ( flow -> protos . stun_ssl . ssl . server_names , flow -> protos . stun_ssl . ssl . server_names_len + 1 , newstr_len + 1 ) ; if ( newstr ) { flow -> protos . stun_ssl . ssl . server_names = newstr ; flow -> protos . stun_ssl . ssl . server_names [ flow -> protos . stun_ssl . ssl . server_names_len ] = ',' ; strncpy ( & flow -> protos . stun_ssl . ssl . server_names [ flow -> protos . stun_ssl . ssl . server_names_len + 1 ] , dNSName , dNSName_len + 1 ) ; flow -> protos . stun_ssl . ssl . server_names [ newstr_len ] = '\\\\0' ; flow -> protos . stun_ssl . ssl . server_names_len = newstr_len ; } } if ( ! flow -> l4 . tcp . tls . subprotocol_detected ) if ( ndpi_match_hostname_protocol ( ndpi_struct , flow , NDPI_PROTOCOL_TLS , dNSName , len ) ) flow -> l4 . tcp . tls . subprotocol_detected = 1 ; i += len ; } else { # if DEBUG_TLS printf ( \"[TLS]<S2SV_blank>Leftover<S2SV_blank>%u<S2SV_blank>bytes\" , packet -> payload_packet_len - i ) ; # endif break ; } } else { break ; } } if ( ! matched_name ) NDPI_SET_BIT ( flow -> risk , NDPI_TLS_CERTIFICATE_MISMATCH ) ; } } } } } if ( rdn_len ) flow -> protos . stun_ssl . ssl . subjectDN = ndpi_strdup ( rdnSeqBuf ) ; if ( flow -> protos . stun_ssl . ssl . subjectDN && flow -> protos . stun_ssl . ssl . issuerDN && ( ! strcmp ( flow -> protos . stun_ssl . ssl . subjectDN , flow -> protos . stun_ssl . ssl . issuerDN ) ) ) NDPI_SET_BIT ( flow -> risk , NDPI_TLS_SELFSIGNED_CERTIFICATE ) ; # if DEBUG_TLS printf ( \"[TLS]<S2SV_blank>%s()<S2SV_blank>SubjectDN<S2SV_blank>[%s]\\\\n\" , __FUNCTION__ , rdnSeqBuf ) ; # endif }\n",
    "fixed_code": "<S2SV_ModStart> , rdnSeqBuf [ 2048 <S2SV_ModEnd> ] = {\n",
    "source_code_length": 9434,
    "target_code_length": 55,
    "vulnerability_patterns": {
      "buffer_overflow": 4,
      "use_after_free": 7,
      "integer_overflow": 14,
      "format_string": 20,
      "null_pointer": 85,
      "total": 130
    },
    "total_patterns": 130,
    "original_address": "https://github.com/ntop/nDPI/commit/23594f036536468072198a57c59b6e9d63caf6ce",
    "discovery_time": "2020-07-01T11:15Z",
    "project_commit_id": "ntop@nDPI/23594f036536468072198a57c59b6e9d63caf6ce",
    "extraction_time": "2025-08-31T15:41:49.174132",
    "label": 1,
    "vulnerability_type": "out-of-bounds_write",
    "difficulty_level": "expert",
    "risk_factors": [
      "memory_corruption",
      "arbitrary_code_execution",
      "buffer_overflow",
      "system_crash",
      "use_after_free"
    ],
    "attack_vectors": [
      "memory_manipulation",
      "malicious_input",
      "code_analysis",
      "buffer_overflow",
      "reverse_engineering",
      "fuzzing"
    ],
    "mitigation_strategies": [
      "safe_string_functions",
      "dynamic_analysis",
      "code_review",
      "static_analysis",
      "memory_safety_checks",
      "input_validation",
      "fuzzing",
      "bounds_checking",
      "secure_coding_practices"
    ],
    "code_differences": {
      "has_differences": true,
      "source_lines": 2,
      "target_lines": 2,
      "character_differences": 9379,
      "similarity_percentage": 3.428571428571429
    },
    "vulnerability_location": {
      "vulnerability_present": true,
      "fix_applied": true,
      "code_changed": true,
      "estimated_lines_changed": 0
    },
    "variants": [],
    "variant_count": 0
  },
  {
    "cve_id": "CVE-2017-15385",
    "cwe_id": "CWE-119",
    "cwe_name": "Buffer Overflow",
    "project": "radare",
    "severity": "critical",
    "weaponization_score": 10.0,
    "is_critical": true,
    "is_weaponizable": true,
    "is_high_priority_project": true,
    "vulnerable_code": "CWE-119 static Sdb * store_versioninfo_gnu_verdef ( ELFOBJ * bin , Elf_ ( Shdr ) * shdr , int sz ) { const char * section_name = \"\" ; const char * link_section_name = \"\" ; char * end = NULL ; Elf_ ( Shdr ) * link_shdr = NULL ; ut8 dfs [ sizeof ( Elf_ ( Verdef ) ) ] = { 0 } ; Sdb * sdb ; int cnt , i ; if ( shdr -> sh_link > bin -> ehdr . e_shnum ) { return false ; } link_shdr = & bin -> shdr [ shdr -> sh_link ] ; if ( shdr -> sh_size < 1 ) { return false ; } Elf_ ( Verdef ) * defs = calloc ( shdr -> sh_size , sizeof ( char ) ) ; if ( ! defs ) { return false ; } if ( bin -> shstrtab && shdr -> sh_name < bin -> shstrtab_size ) { section_name = & bin -> shstrtab [ shdr -> sh_name ] ; } if ( link_shdr && bin -> shstrtab && link_shdr -> sh_name < bin -> shstrtab_size ) { link_section_name = & bin -> shstrtab [ link_shdr -> sh_name ] ; } if ( ! defs ) { bprintf ( \"Warning:<S2SV_blank>Cannot<S2SV_blank>allocate<S2SV_blank>memory<S2SV_blank>(Check<S2SV_blank>Elf_(Verdef))\\\\n\" ) ; return NULL ; } sdb = sdb_new0 ( ) ; end = ( char * ) defs + shdr -> sh_size ; sdb_set ( sdb , \"section_name\" , section_name , 0 ) ; sdb_num_set ( sdb , \"entries\" , shdr -> sh_info , 0 ) ; sdb_num_set ( sdb , \"addr\" , shdr -> sh_addr , 0 ) ; sdb_num_set ( sdb , \"offset\" , shdr -> sh_offset , 0 ) ; sdb_num_set ( sdb , \"link\" , shdr -> sh_link , 0 ) ; sdb_set ( sdb , \"link_section_name\" , link_section_name , 0 ) ; <S2SV_StartBug> for ( cnt = 0 , i = 0 ; cnt < shdr -> sh_info && ( ( char * ) defs + i < end ) ; ++ cnt ) { <S2SV_EndBug> Sdb * sdb_verdef = sdb_new0 ( ) ; char * vstart = ( ( char * ) defs ) + i ; char key [ 32 ] = { 0 } ; Elf_ ( Verdef ) * verdef = ( Elf_ ( Verdef ) * ) vstart ; Elf_ ( Verdaux ) aux = { 0 } ; int j = 0 ; int isum = 0 ; r_buf_read_at ( bin -> b , shdr -> sh_offset + i , dfs , sizeof ( Elf_ ( Verdef ) ) ) ; verdef -> vd_version = READ16 ( dfs , j ) verdef -> vd_flags = READ16 ( dfs , j ) verdef -> vd_ndx = READ16 ( dfs , j ) verdef -> vd_cnt = READ16 ( dfs , j ) verdef -> vd_hash = READ32 ( dfs , j ) verdef -> vd_aux = READ32 ( dfs , j ) verdef -> vd_next = READ32 ( dfs , j ) vstart += verdef -> vd_aux ; if ( vstart > end || vstart + sizeof ( Elf_ ( Verdaux ) ) > end ) { sdb_free ( sdb_verdef ) ; goto out_error ; } j = 0 ; aux . vda_name = READ32 ( vstart , j ) aux . vda_next = READ32 ( vstart , j ) isum = i + verdef -> vd_aux ; if ( aux . vda_name > bin -> dynstr_size ) { sdb_free ( sdb_verdef ) ; goto out_error ; } sdb_num_set ( sdb_verdef , \"idx\" , i , 0 ) ; sdb_num_set ( sdb_verdef , \"vd_version\" , verdef -> vd_version , 0 ) ; sdb_num_set ( sdb_verdef , \"vd_ndx\" , verdef -> vd_ndx , 0 ) ; sdb_num_set ( sdb_verdef , \"vd_cnt\" , verdef -> vd_cnt , 0 ) ; sdb_set ( sdb_verdef , \"vda_name\" , & bin -> dynstr [ aux . vda_name ] , 0 ) ; sdb_set ( sdb_verdef , \"flags\" , get_ver_flags ( verdef -> vd_flags ) , 0 ) ; for ( j = 1 ; j < verdef -> vd_cnt ; ++ j ) { int k ; Sdb * sdb_parent = sdb_new0 ( ) ; isum += aux . vda_next ; vstart += aux . vda_next ; if ( vstart > end || vstart + sizeof ( Elf_ ( Verdaux ) ) > end ) { sdb_free ( sdb_verdef ) ; sdb_free ( sdb_parent ) ; goto out_error ; } k = 0 ; aux . vda_name = READ32 ( vstart , k ) aux . vda_next = READ32 ( vstart , k ) if ( aux . vda_name > bin -> dynstr_size ) { sdb_free ( sdb_verdef ) ; sdb_free ( sdb_parent ) ; goto out_error ; } sdb_num_set ( sdb_parent , \"idx\" , isum , 0 ) ; sdb_num_set ( sdb_parent , \"parent\" , j , 0 ) ; sdb_set ( sdb_parent , \"vda_name\" , & bin -> dynstr [ aux . vda_name ] , 0 ) ; snprintf ( key , sizeof ( key ) , \"parent%d\" , j - 1 ) ; sdb_ns_set ( sdb_verdef , key , sdb_parent ) ; } snprintf ( key , sizeof ( key ) , \"verdef%d\" , cnt ) ; sdb_ns_set ( sdb , key , sdb_verdef ) ; if ( ! verdef -> vd_next ) { sdb_free ( sdb_verdef ) ; goto out_error ; } <S2SV_StartBug> i += verdef -> vd_next ; <S2SV_EndBug> } free ( defs ) ; return sdb ; out_error : free ( defs ) ; sdb_free ( sdb ) ; return NULL ; }\n",
    "fixed_code": "<S2SV_ModStart> = 0 ; i >= 0 && <S2SV_ModStart> out_error ; } if ( ( st32 ) verdef -> vd_next < 1 ) { eprintf ( \"Warning:<S2SV_blank>Invalid<S2SV_blank>vd_next<S2SV_blank>in<S2SV_blank>the<S2SV_blank>ELF<S2SV_blank>version\\\\n\" ) ; break ; }\n",
    "source_code_length": 3931,
    "target_code_length": 241,
    "vulnerability_patterns": {
      "use_after_free": 3,
      "integer_overflow": 6,
      "format_string": 2,
      "null_pointer": 48,
      "memory_leak": 1,
      "total": 60
    },
    "total_patterns": 60,
    "original_address": "https://github.com/radare/radare2/commit/21a6f570ba33fa9f52f1bba87f07acc4e8c178f4",
    "discovery_time": "2017-10-16T22:29Z",
    "project_commit_id": "radare@radare2/21a6f570ba33fa9f52f1bba87f07acc4e8c178f4",
    "extraction_time": "2025-08-31T15:41:49.174215",
    "label": 1,
    "vulnerability_type": "buffer_overflow",
    "difficulty_level": "expert",
    "risk_factors": [
      "memory_corruption",
      "critical_infrastructure",
      "arbitrary_code_execution",
      "system_crash",
      "use_after_free"
    ],
    "attack_vectors": [
      "memory_manipulation",
      "malicious_input",
      "code_analysis",
      "buffer_overflow",
      "reverse_engineering",
      "fuzzing"
    ],
    "mitigation_strategies": [
      "safe_string_functions",
      "dynamic_analysis",
      "code_review",
      "static_analysis",
      "memory_safety_checks",
      "input_validation",
      "fuzzing",
      "bounds_checking",
      "secure_coding_practices"
    ],
    "code_differences": {
      "has_differences": true,
      "source_lines": 2,
      "target_lines": 2,
      "character_differences": 3690,
      "similarity_percentage": 12.5
    },
    "vulnerability_location": {
      "vulnerability_present": true,
      "fix_applied": true,
      "code_changed": true,
      "estimated_lines_changed": 0
    },
    "variants": [
      {
        "variant_id": "CVE-2017-15385_variant_1",
        "source_cve_id": "CVE-2017-15385",
        "variant_number": 1,
        "vulnerable_code": "static Sdb *store_versioninfo_gnu_verdef(ELFOBJ *bin_obj, Elf_(Shdr) *section_header, int size_val) {\n    const char *sec_name = \"\";\n    const char *linked_sec_name = \"\";\n    char *termination_ptr = NULL;\n    Elf_(Shdr) *linked_header = NULL;\n    ut8 read_buffer[sizeof(Elf_(Verdef))] = {0};\n    Sdb *version_db;\n    int count, index_val;\n\n    if (section_header->sh_link >= bin_obj->ehdr.e_shnum) {\n        return false;\n    }\n\n    linked_header = bin_obj->shdr + section_header->sh_link;\n    if (section_header->sh_size <= 0) {\n        return false;\n    }\n\n    Elf_(Verdef) *version_defs = (Elf_(Verdef) *)calloc(section_header->sh_size, 1);\n    if (!version_defs) {\n        return false;\n    }\n\n    if (bin_obj->shstrtab && section_header->sh_name < bin_obj->shstrtab_size) {\n        sec_name = bin_obj->shstrtab + section_header->sh_name;\n    }\n\n    if (linked_header && bin_obj->shstrtab && linked_header->sh_name < bin_obj->shstrtab_size) {\n        linked_sec_name = bin_obj->shstrtab + linked_header->sh_name;\n    }\n\n    if (!version_defs) {\n        bprintf(\"Warning: Cannot allocate memory (Check Elf_(Verdef))\\n\");\n        return NULL;\n    }\n\n    version_db = sdb_new0();\n    termination_ptr = (char *)version_defs + section_header->sh_size;\n    \n    sdb_set(version_db, \"section_name\", sec_name, 0);\n    sdb_num_set(version_db, \"entries\", section_header->sh_info, 0);\n    sdb_num_set(version_db, \"addr\", section_header->sh_addr, 0);\n    sdb_num_set(version_db, \"offset\", section_header->sh_offset, 0);\n    sdb_num_set(version_db, \"link\", section_header->sh_link, 0);\n    sdb_set(version_db, \"link_section_name\", linked_sec_name, 0);\n\n    for (count = 0, index_val = 0; count < section_header->sh_info; ++count) {\n        char *current_position = (char *)version_defs + index_val;\n        if (current_position >= termination_ptr) break;\n        \n        Sdb *def_entry = sdb_new0();\n        char entry_key[32] = {0};\n        Elf_(Verdef) *ver_def = (Elf_(Verdef) *)current_position;\n        Elf_(Verdaux) aux_entry = {0};\n        int read_offset = 0;\n        int aux_sum = 0;\n\n        r_buf_read_at(bin_obj->b, section_header->sh_offset + index_val, read_buffer, sizeof(Elf_(Verdef)));\n        \n        ver_def->vd_version = READ16(read_buffer, read_offset);\n        ver_def->vd_flags = READ16(read_buffer, read_offset);\n        ver_def->vd_ndx = READ16(read_buffer, read_offset);\n        ver_def->vd_cnt = READ16(read_buffer, read_offset);\n        ver_def->vd_hash = READ32(read_buffer, read_offset);\n        ver_def->vd_aux = READ32(read_buffer, read_offset);\n        ver_def->vd_next = READ32(read_buffer, read_offset);\n\n        char *aux_ptr = current_position + ver_def->vd_aux;\n        if (aux_ptr > termination_ptr || aux_ptr + sizeof(Elf_(Verdaux)) > termination_ptr) {\n            sdb_free(def_entry);\n            goto cleanup_error;\n        }\n\n        read_offset = 0;\n        aux_entry.vda_name = READ32(aux_ptr, read_offset);\n        aux_entry.vda_next = READ32(aux_ptr, read_offset);\n        \n        aux_sum = index_val + ver_def->vd_aux;\n        if (aux_entry.vda_name >= bin_obj->dynstr_size) {\n            sdb_free(def_entry);\n            goto cleanup_error;\n        }\n\n        sdb_num_set(def_entry, \"idx\", index_val, 0);\n        sdb_num_set(def_entry, \"vd_version\", ver_def->vd_version, 0);\n        sdb_num_set(def_entry, \"vd_ndx\", ver_def->vd_ndx, 0);\n        sdb_num_set(def_entry, \"vd_cnt\", ver_def->vd_cnt, 0);\n        sdb_set(def_entry, \"vda_name\", bin_obj->dynstr + aux_entry.vda_name, 0);\n        sdb_set(def_entry, \"flags\", get_ver_flags(ver_def->vd_flags), 0);\n\n        for (int aux_index = 1; aux_index < ver_def->vd_cnt; ++aux_index) {\n            Sdb *parent_entry = sdb_new0();\n            aux_sum += aux_entry.vda_next;\n            aux_ptr += aux_entry.vda_next;\n            \n            if (aux_ptr > termination_ptr || aux_ptr + sizeof(Elf_(Verdaux)) > termination_ptr) {\n                sdb_free(def_entry);\n                sdb_free(parent_entry);\n                goto cleanup_error;\n            }\n\n            int inner_offset = 0;\n            aux_entry.vda_name = READ32(aux_ptr, inner_offset);\n            aux_entry.vda_next = READ32(aux_ptr, inner_offset);\n            \n            if (aux_entry.vda_name >= bin_obj->dynstr_size) {\n                sdb_free(def_entry);\n                sdb_free(parent_entry);\n                goto cleanup_error;\n            }\n\n            sdb_num_set(parent_entry, \"idx\", aux_sum, 0);\n            sdb_num_set(parent_entry, \"parent\", aux_index, 0);\n            sdb_set(parent_entry, \"vda_name\", bin_obj->dynstr + aux_entry.vda_name, 0);\n            \n            snprintf(entry_key, sizeof(entry_key), \"parent%d\", aux_index - 1);\n            sdb_ns_set(def_entry, entry_key, parent_entry);\n        }\n\n        snprintf(entry_key, sizeof(entry_key), \"verdef%d\", count);\n        sdb_ns_set(version_db, entry_key, def_entry);\n\n        if (!ver_def->vd_next) {\n            sdb_free(def_entry);\n            goto cleanup_error;\n        }\n\n        index_val += ver_def->vd_next;\n    }\n\n    free(version_defs);\n    return version_db;\n\ncleanup_error:\n    free(version_defs);\n    sdb_free(version_db);\n    return NULL;\n}",
        "fixed_code": "<S2SV_ModStart> = 0 ; i >= 0 && <S2SV_ModStart> out_error ; } if ( ( st32 ) verdef -> vd_next < 1 ) { eprintf ( \"Warning:<S2SV_blank>Invalid<S2SV_blank>vd_next<S2SV_blank>in<S2SV_blank>the<S2SV_blank>ELF<S2SV_blank>version\\\\n\" ) ; break ; }\n",
        "cwe_id": "CWE-119",
        "cvss_score": "critical",
        "weaponization_score": 10.0,
        "project": "radare",
        "vulnerability_type": "buffer_overflow",
        "difficulty_level": "expert",
        "risk_factors": [
          "memory_corruption",
          "critical_infrastructure",
          "arbitrary_code_execution",
          "system_crash",
          "use_after_free"
        ],
        "attack_vectors": [
          "memory_manipulation",
          "malicious_input",
          "code_analysis",
          "buffer_overflow",
          "reverse_engineering",
          "fuzzing"
        ],
        "mitigation_strategies": [
          "safe_string_functions",
          "dynamic_analysis",
          "code_review",
          "static_analysis",
          "memory_safety_checks",
          "input_validation",
          "fuzzing",
          "bounds_checking",
          "secure_coding_practices"
        ],
        "code_differences": {
          "original_length": 3931,
          "variant_length": 5189,
          "length_difference": 1258,
          "original_lines": 2,
          "variant_lines": 138,
          "line_difference": 136,
          "added_lines": 138,
          "removed_lines": 2,
          "similarity_ratio": 0.38092105263157894
        },
        "vulnerability_location": {
          "vulnerability_present": true,
          "fix_applied": true,
          "code_changed": true,
          "estimated_lines_changed": 0
        },
        "validation_score": 0.75,
        "validation_checks": {
          "code_differences": true,
          "pattern_preservation": true,
          "structure_quality": true,
          "cwe_consistency": false
        },
        "generation_timestamp": "2025-09-02T14:25:40.541463",
        "generation_method": "deepseek_coder_refactoring"
      },
      {
        "variant_id": "CVE-2017-15385_variant_2",
        "source_cve_id": "CVE-2017-15385",
        "variant_number": 2,
        "vulnerable_code": "static Sdb * store_versioninfo_gnu_verdef(ELFOBJ *bin_obj, Elf_(Shdr) *section_header, int size_param) {\n    const char *name_of_section = \"\";\n    const char *linked_section_name = \"\";\n    char *termination_ptr = NULL;\n    Elf_(Shdr) *linked_header = NULL;\n    ut8 read_buffer[sizeof(Elf_(Verdef))] = {0};\n    Sdb *version_db;\n    int counter, index_var;\n\n    if (section_header->sh_link > bin_obj->ehdr.e_shnum) {\n        return false;\n    }\n\n    linked_header = &bin_obj->shdr[section_header->sh_link];\n    \n    if (section_header->sh_size < 1) {\n        return false;\n    }\n\n    Elf_(Verdef) *version_definitions = (Elf_(Verdef) *)calloc(section_header->sh_size, sizeof(char));\n    if (!version_definitions) {\n        return false;\n    }\n\n    if (bin_obj->shstrtab && section_header->sh_name < bin_obj->shstrtab_size) {\n        name_of_section = &bin_obj->shstrtab[section_header->sh_name];\n    }\n\n    if (linked_header && bin_obj->shstrtab && linked_header->sh_name < bin_obj->shstrtab_size) {\n        linked_section_name = &bin_obj->shstrtab[linked_header->sh_name];\n    }\n\n    if (!version_definitions) {\n        bprintf(\"Warning: Cannot allocate memory (Check Elf_(Verdef))\\n\");\n        return NULL;\n    }\n\n    version_db = sdb_new0();\n    termination_ptr = (char *)version_definitions + section_header->sh_size;\n    \n    sdb_set(version_db, \"section_name\", name_of_section, 0);\n    sdb_num_set(version_db, \"entries\", section_header->sh_info, 0);\n    sdb_num_set(version_db, \"addr\", section_header->sh_addr, 0);\n    sdb_num_set(version_db, \"offset\", section_header->sh_offset, 0);\n    sdb_num_set(version_db, \"link\", section_header->sh_link, 0);\n    sdb_set(version_db, \"link_section_name\", linked_section_name, 0);\n\n    for (counter = 0, index_var = 0; counter < section_header->sh_info && ((char *)version_definitions + index_var < termination_ptr); ++counter) {\n        Sdb *verdef_entry = sdb_new0();\n        char *current_position = ((char *)version_definitions) + index_var;\n        char entry_key[32] = {0};\n        Elf_(Verdef) *verdef_data = (Elf_(Verdef) *)current_position;\n        Elf_(Verdaux) auxiliary_data = {0};\n        int read_index = 0;\n        int cumulative_offset = 0;\n\n        r_buf_read_at(bin_obj->b, section_header->sh_offset + index_var, read_buffer, sizeof(Elf_(Verdef)));\n        \n        verdef_data->vd_version = READ16(read_buffer, read_index);\n        verdef_data->vd_flags = READ16(read_buffer, read_index);\n        verdef_data->vd_ndx = READ16(read_buffer, read_index);\n        verdef_data->vd_cnt = READ16(read_buffer, read_index);\n        verdef_data->vd_hash = READ32(read_buffer, read_index);\n        verdef_data->vd_aux = READ32(read_buffer, read_index);\n        verdef_data->vd_next = READ32(read_buffer, read_index);\n\n        current_position += *(int *)&verdef_data->vd_aux;\n        \n        if (current_position > termination_ptr || current_position + sizeof(Elf_(Verdaux)) > termination_ptr) {\n            sdb_free(verdef_entry);\n            goto cleanup_error;\n        }\n\n        read_index = 0;\n        auxiliary_data.vda_name = READ32(current_position, read_index);\n        auxiliary_data.vda_next = READ32(current_position, read_index);\n        \n        cumulative_offset = index_var + *(int *)&verdef_data->vd_aux;\n        \n        if (auxiliary_data.vda_name > bin_obj->dynstr_size) {\n            sdb_free(verdef_entry);\n            goto cleanup_error;\n        }\n\n        sdb_num_set(verdef_entry, \"idx\", index_var, 0);\n        sdb_num_set(verdef_entry, \"vd_version\", verdef_data->vd_version, 0);\n        sdb_num_set(verdef_entry, \"vd_ndx\", verdef_data->vd_ndx, 0);\n        sdb_num_set(verdef_entry, \"vd_cnt\", verdef_data->vd_cnt, 0);\n        sdb_set(verdef_entry, \"vda_name\", &bin_obj->dynstr[auxiliary_data.vda_name], 0);\n        sdb_set(verdef_entry, \"flags\", get_ver_flags(verdef_data->vd_flags), 0);\n\n        for (int parent_index = 1; parent_index < *(int *)&verdef_data->vd_cnt; ++parent_index) {\n            int aux_read_index;\n            Sdb *parent_entry = sdb_new0();\n            \n            cumulative_offset += *(int *)&auxiliary_data.vda_next;\n            current_position += *(int *)&auxiliary_data.vda_next;\n            \n            if (current_position > termination_ptr || current_position + sizeof(Elf_(Verdaux)) > termination_ptr) {\n                sdb_free(verdef_entry);\n                sdb_free(parent_entry);\n                goto cleanup_error;\n            }\n\n            aux_read_index = 0;\n            auxiliary_data.vda_name = READ32(current_position, aux_read_index);\n            auxiliary_data.vda_next = READ32(current_position, aux_read_index);\n            \n            if (auxiliary_data.vda_name > bin_obj->dynstr_size) {\n                sdb_free(verdef_entry);\n                sdb_free(parent_entry);\n                goto cleanup_error;\n            }\n\n            sdb_num_set(parent_entry, \"idx\", cumulative_offset, 0);\n            sdb_num_set(parent_entry, \"parent\", parent_index, 0);\n            sdb_set(parent_entry, \"vda_name\", &bin_obj->dynstr[auxiliary_data.vda_name], 0);\n            \n            snprintf(entry_key, sizeof(entry_key), \"parent%d\", parent_index - 1);\n            sdb_ns_set(verdef_entry, entry_key, parent_entry);\n        }\n\n        snprintf(entry_key, sizeof(entry_key), \"verdef%d\", counter);\n        sdb_ns_set(version_db, entry_key, verdef_entry);\n\n        if (!*(int *)&verdef_data->vd_next) {\n            sdb_free(verdef_entry);\n            goto cleanup_error;\n        }\n\n        index_var += *(int *)&verdef_data->vd_next;\n    }\n\n    free(version_definitions);\n    return version_db;\n\ncleanup_error:\n    free(version_definitions);\n    sdb_free(version_db);\n    return NULL;\n}",
        "fixed_code": "<S2SV_ModStart> = 0 ; i >= 0 && <S2SV_ModStart> out_error ; } if ( ( st32 ) verdef -> vd_next < 1 ) { eprintf ( \"Warning:<S2SV_blank>Invalid<S2SV_blank>vd_next<S2SV_blank>in<S2SV_blank>the<S2SV_blank>ELF<S2SV_blank>version\\\\n\" ) ; break ; }\n",
        "cwe_id": "CWE-119",
        "cvss_score": "critical",
        "weaponization_score": 10.0,
        "project": "radare",
        "vulnerability_type": "buffer_overflow",
        "difficulty_level": "expert",
        "risk_factors": [
          "memory_corruption",
          "critical_infrastructure",
          "arbitrary_code_execution",
          "system_crash",
          "use_after_free"
        ],
        "attack_vectors": [
          "memory_manipulation",
          "malicious_input",
          "code_analysis",
          "buffer_overflow",
          "reverse_engineering",
          "fuzzing"
        ],
        "mitigation_strategies": [
          "safe_string_functions",
          "dynamic_analysis",
          "code_review",
          "static_analysis",
          "memory_safety_checks",
          "input_validation",
          "fuzzing",
          "bounds_checking",
          "secure_coding_practices"
        ],
        "code_differences": {
          "original_length": 3931,
          "variant_length": 5699,
          "length_difference": 1768,
          "original_lines": 2,
          "variant_lines": 141,
          "line_difference": 139,
          "added_lines": 141,
          "removed_lines": 2,
          "similarity_ratio": 0.3954309449636552
        },
        "vulnerability_location": {
          "vulnerability_present": true,
          "fix_applied": true,
          "code_changed": true,
          "estimated_lines_changed": 0
        },
        "validation_score": 0.75,
        "validation_checks": {
          "code_differences": true,
          "pattern_preservation": true,
          "structure_quality": true,
          "cwe_consistency": false
        },
        "generation_timestamp": "2025-09-02T14:26:58.556521",
        "generation_method": "deepseek_coder_refactoring"
      },
      {
        "variant_id": "CVE-2017-15385_variant_3",
        "source_cve_id": "CVE-2017-15385",
        "variant_number": 3,
        "vulnerable_code": "static Sdb *store_versioninfo_gnu_verdef(ELFOBJ *bin, Elf_(Shdr) *shdr, int sz) {\n    const char *section_name_ptr = \"\";\n    const char *link_section_name_ptr = \"\";\n    char *buffer_end_position = NULL;\n    Elf_(Shdr) *linked_section_header = NULL;\n    ut8 read_buffer[sizeof(Elf_(Verdef))] = {0};\n    Sdb *version_database;\n    int iteration_count, byte_offset;\n\n    if (shdr->sh_link >= bin->ehdr.e_shnum) {\n        return false;\n    }\n\n    linked_section_header = bin->shdr + shdr->sh_link;\n    if (shdr->sh_size <= 0) {\n        return false;\n    }\n\n    Elf_(Verdef) *version_definitions = (Elf_(Verdef) *)calloc(shdr->sh_size, sizeof(char));\n    if (!version_definitions) {\n        return false;\n    }\n\n    if (bin->shstrtab && shdr->sh_name < bin->shstrtab_size) {\n        section_name_ptr = bin->shstrtab + shdr->sh_name;\n    }\n\n    if (linked_section_header && bin->shstrtab && \n        linked_section_header->sh_name < bin->shstrtab_size) {\n        link_section_name_ptr = bin->shstrtab + linked_section_header->sh_name;\n    }\n\n    if (!version_definitions) {\n        bprintf(\"Warning: Cannot allocate memory (Check Elf_(Verdef))\\n\");\n        return NULL;\n    }\n\n    version_database = sdb_new0();\n    buffer_end_position = (char *)version_definitions + shdr->sh_size;\n    \n    sdb_set(version_database, \"section_name\", section_name_ptr, 0);\n    sdb_num_set(version_database, \"entries\", shdr->sh_info, 0);\n    sdb_num_set(version_database, \"addr\", shdr->sh_addr, 0);\n    sdb_num_set(version_database, \"offset\", shdr->sh_offset, 0);\n    sdb_num_set(version_database, \"link\", shdr->sh_link, 0);\n    sdb_set(version_database, \"link_section_name\", link_section_name_ptr, 0);\n\n    iteration_count = 0;\n    byte_offset = 0;\n    \n    while (iteration_count < shdr->sh_info) {\n        char *current_position = ((char *)version_definitions) + byte_offset;\n        if (current_position >= buffer_end_position) break;\n        \n        Sdb *version_entry = sdb_new0();\n        char entry_key[32] = {0};\n        Elf_(Verdef) *current_verdef = (Elf_(Verdef) *)current_position;\n        Elf_(Verdaux) auxiliary_entry = {0};\n        int read_index = 0;\n        int accumulated_offset = 0;\n\n        r_buf_read_at(bin->b, shdr->sh_offset + byte_offset, read_buffer, sizeof(Elf_(Verdef)));\n        \n        current_verdef->vd_version = READ16(read_buffer, read_index);\n        current_verdef->vd_flags = READ16(read_buffer, read_index);\n        current_verdef->vd_ndx = READ16(read_buffer, read_index);\n        current_verdef->vd_cnt = READ16(read_buffer, read_index);\n        current_verdef->vd_hash = READ32(read_buffer, read_index);\n        current_verdef->vd_aux = READ32(read_buffer, read_index);\n        current_verdef->vd_next = READ32(read_buffer, read_index);\n\n        char *auxiliary_start = current_position + current_verdef->vd_aux;\n        \n        if (auxiliary_start > buffer_end_position || \n            auxiliary_start + sizeof(Elf_(Verdaux)) > buffer_end_position) {\n            sdb_free(version_entry);\n            goto cleanup_error;\n        }\n\n        read_index = 0;\n        auxiliary_entry.vda_name = READ32(auxiliary_start, read_index);\n        auxiliary_entry.vda_next = READ32(auxiliary_start, read_index);\n        \n        accumulated_offset = byte_offset + current_verdef->vd_aux;\n\n        if (auxiliary_entry.vda_name >= bin->dynstr_size) {\n            sdb_free(version_entry);\n            goto cleanup_error;\n        }\n\n        sdb_num_set(version_entry, \"idx\", byte_offset, 0);\n        sdb_num_set(version_entry, \"vd_version\", current_verdef->vd_version, 0);\n        sdb_num_set(version_entry, \"vd_ndx\", current_verdef->vd_ndx, 0);\n        sdb_num_set(version_entry, \"vd_cnt\", current_verdef->vd_cnt, 0);\n        sdb_set(version_entry, \"vda_name\", bin->dynstr + auxiliary_entry.vda_name, 0);\n        sdb_set(version_entry, \"flags\", get_ver_flags(current_verdef->vd_flags), 0);\n\n        int parent_index;\n        for (parent_index = 1; parent_index < current_verdef->vd_cnt; parent_index++) {\n            Sdb *parent_entry = sdb_new0();\n            accumulated_offset += auxiliary_entry.vda_next;\n            auxiliary_start += auxiliary_entry.vda_next;\n\n            if (auxiliary_start > buffer_end_position || \n                auxiliary_start + sizeof(Elf_(Verdaux)) > buffer_end_position) {\n                sdb_free(version_entry);\n                sdb_free(parent_entry);\n                goto cleanup_error;\n            }\n\n            int aux_read_pos = 0;\n            auxiliary_entry.vda_name = READ32(auxiliary_start, aux_read_pos);\n            auxiliary_entry.vda_next = READ32(auxiliary_start, aux_read_pos);\n\n            if (auxiliary_entry.vda_name >= bin->dynstr_size) {\n                sdb_free(version_entry);\n                sdb_free(parent_entry);\n                goto cleanup_error;\n            }\n\n            sdb_num_set(parent_entry, \"idx\", accumulated_offset, 0);\n            sdb_num_set(parent_entry, \"parent\", parent_index, 0);\n            sdb_set(parent_entry, \"vda_name\", bin->dynstr + auxiliary_entry.vda_name, 0);\n            \n            snprintf(entry_key, sizeof(entry_key), \"parent%d\", parent_index - 1);\n            sdb_ns_set(version_entry, entry_key, parent_entry);\n        }\n\n        snprintf(entry_key, sizeof(entry_key), \"verdef%d\", iteration_count);\n        sdb_ns_set(version_database, entry_key, version_entry);\n\n        if (!current_verdef->vd_next) {\n            sdb_free(version_entry);\n            goto cleanup_error;\n        }\n\n        byte_offset += *(int *)&current_verdef->vd_next;\n        iteration_count++;\n    }\n\n    free(version_definitions);\n    return version_database;\n\ncleanup_error:\n    free(version_definitions);\n    sdb_free(version_database);\n    return NULL;\n}",
        "fixed_code": "<S2SV_ModStart> = 0 ; i >= 0 && <S2SV_ModStart> out_error ; } if ( ( st32 ) verdef -> vd_next < 1 ) { eprintf ( \"Warning:<S2SV_blank>Invalid<S2SV_blank>vd_next<S2SV_blank>in<S2SV_blank>the<S2SV_blank>ELF<S2SV_blank>version\\\\n\" ) ; break ; }\n",
        "cwe_id": "CWE-119",
        "cvss_score": "critical",
        "weaponization_score": 10.0,
        "project": "radare",
        "vulnerability_type": "buffer_overflow",
        "difficulty_level": "expert",
        "risk_factors": [
          "memory_corruption",
          "critical_infrastructure",
          "arbitrary_code_execution",
          "system_crash",
          "use_after_free"
        ],
        "attack_vectors": [
          "memory_manipulation",
          "malicious_input",
          "code_analysis",
          "buffer_overflow",
          "reverse_engineering",
          "fuzzing"
        ],
        "mitigation_strategies": [
          "safe_string_functions",
          "dynamic_analysis",
          "code_review",
          "static_analysis",
          "memory_safety_checks",
          "input_validation",
          "fuzzing",
          "bounds_checking",
          "secure_coding_practices"
        ],
        "code_differences": {
          "original_length": 3931,
          "variant_length": 5737,
          "length_difference": 1806,
          "original_lines": 2,
          "variant_lines": 148,
          "line_difference": 146,
          "added_lines": 148,
          "removed_lines": 2,
          "similarity_ratio": 0.395945386843194
        },
        "vulnerability_location": {
          "vulnerability_present": true,
          "fix_applied": true,
          "code_changed": true,
          "estimated_lines_changed": 0
        },
        "validation_score": 0.75,
        "validation_checks": {
          "code_differences": true,
          "pattern_preservation": true,
          "structure_quality": true,
          "cwe_consistency": false
        },
        "generation_timestamp": "2025-09-02T14:28:15.214238",
        "generation_method": "deepseek_coder_refactoring"
      }
    ],
    "variant_count": 3
  },
  {
    "cve_id": "CVE-2019-19275",
    "cwe_id": "CWE-125",
    "cwe_name": "Out-of-bounds Read",
    "project": "python",
    "severity": "critical",
    "weaponization_score": 10.0,
    "is_critical": true,
    "is_weaponizable": true,
    "is_high_priority_project": true,
    "vulnerable_code": "CWE-125 static arguments_ty ast_for_arguments ( struct compiling * c , const node * n ) { int i , j , k , nposargs = 0 , nkwonlyargs = 0 ; int nposdefaults = 0 , found_default = 0 ; asdl_seq * posargs , * posdefaults , * kwonlyargs , * kwdefaults ; arg_ty vararg = NULL , kwarg = NULL ; arg_ty arg ; node * ch ; if ( TYPE ( n ) == parameters ) { if ( NCH ( n ) == 2 ) return arguments ( NULL , NULL , NULL , NULL , NULL , NULL , c -> c_arena ) ; n = CHILD ( n , 1 ) ; } assert ( TYPE ( n ) == typedargslist || TYPE ( n ) == varargslist ) ; for ( i = 0 ; i < NCH ( n ) ; i ++ ) { ch = CHILD ( n , i ) ; if ( TYPE ( ch ) == STAR ) { i ++ ; if ( i < NCH ( n ) && ( TYPE ( CHILD ( n , i ) ) == tfpdef || TYPE ( CHILD ( n , i ) ) == vfpdef ) ) { i ++ ; } break ; } if ( TYPE ( ch ) == DOUBLESTAR ) break ; if ( TYPE ( ch ) == vfpdef || TYPE ( ch ) == tfpdef ) nposargs ++ ; if ( TYPE ( ch ) == EQUAL ) nposdefaults ++ ; } for ( ; i < NCH ( n ) ; ++ i ) { ch = CHILD ( n , i ) ; if ( TYPE ( ch ) == DOUBLESTAR ) break ; if ( TYPE ( ch ) == tfpdef || TYPE ( ch ) == vfpdef ) nkwonlyargs ++ ; } posargs = ( nposargs ? _Ta3_asdl_seq_new ( nposargs , c -> c_arena ) : NULL ) ; if ( ! posargs && nposargs ) return NULL ; kwonlyargs = ( nkwonlyargs ? _Ta3_asdl_seq_new ( nkwonlyargs , c -> c_arena ) : NULL ) ; if ( ! kwonlyargs && nkwonlyargs ) return NULL ; posdefaults = ( nposdefaults ? _Ta3_asdl_seq_new ( nposdefaults , c -> c_arena ) : NULL ) ; if ( ! posdefaults && nposdefaults ) return NULL ; kwdefaults = ( nkwonlyargs ? _Ta3_asdl_seq_new ( nkwonlyargs , c -> c_arena ) : NULL ) ; if ( ! kwdefaults && nkwonlyargs ) return NULL ; <S2SV_StartBug> if ( nposargs + nkwonlyargs > 255 ) { <S2SV_EndBug> ast_error ( c , n , \"more<S2SV_blank>than<S2SV_blank>255<S2SV_blank>arguments\" ) ; return NULL ; } i = 0 ; j = 0 ; k = 0 ; while ( i < NCH ( n ) ) { ch = CHILD ( n , i ) ; switch ( TYPE ( ch ) ) { case tfpdef : case vfpdef : if ( i + 1 < NCH ( n ) && TYPE ( CHILD ( n , i + 1 ) ) == EQUAL ) { expr_ty expression = ast_for_expr ( c , CHILD ( n , i + 2 ) ) ; if ( ! expression ) return NULL ; assert ( posdefaults != NULL ) ; asdl_seq_SET ( posdefaults , j ++ , expression ) ; i += 2 ; found_default = 1 ; } else if ( found_default ) { ast_error ( c , n , \"non-default<S2SV_blank>argument<S2SV_blank>follows<S2SV_blank>default<S2SV_blank>argument\" ) ; return NULL ; } arg = ast_for_arg ( c , ch ) ; if ( ! arg ) return NULL ; asdl_seq_SET ( posargs , k ++ , arg ) ; i += 1 ; <S2SV_StartBug> if ( i < NCH ( n ) && TYPE ( CHILD ( n , i ) ) == COMMA ) <S2SV_EndBug> i += 1 ; break ; case STAR : if ( i + 1 >= NCH ( n ) || ( i + 2 == NCH ( n ) && ( TYPE ( CHILD ( n , i + 1 ) ) == COMMA || TYPE ( CHILD ( n , i + 1 ) ) == TYPE_COMMENT ) ) ) { ast_error ( c , CHILD ( n , i ) , \"named<S2SV_blank>arguments<S2SV_blank>must<S2SV_blank>follow<S2SV_blank>bare<S2SV_blank>*\" ) ; return NULL ; } ch = CHILD ( n , i + 1 ) ; if ( TYPE ( ch ) == COMMA ) { int res = 0 ; i += 2 ; <S2SV_StartBug> if ( i < NCH ( n ) && TYPE ( CHILD ( n , i ) ) == TYPE_COMMENT ) { <S2SV_EndBug> ast_error ( c , CHILD ( n , i ) , \"bare<S2SV_blank>*<S2SV_blank>has<S2SV_blank>associated<S2SV_blank>type<S2SV_blank>comment\" ) ; return NULL ; } res = handle_keywordonly_args ( c , n , i , kwonlyargs , kwdefaults ) ; if ( res == - 1 ) return NULL ; i = res ; } else { vararg = ast_for_arg ( c , ch ) ; if ( ! vararg ) return NULL ; i += 2 ; <S2SV_StartBug> if ( i < NCH ( n ) && TYPE ( CHILD ( n , i ) ) == COMMA ) <S2SV_EndBug> i += 1 ; <S2SV_StartBug> if ( i < NCH ( n ) && TYPE ( CHILD ( n , i ) ) == TYPE_COMMENT ) { <S2SV_EndBug> vararg -> type_comment = NEW_TYPE_COMMENT ( CHILD ( n , i ) ) ; i += 1 ; } if ( i < NCH ( n ) && ( TYPE ( CHILD ( n , i ) ) == tfpdef || TYPE ( CHILD ( n , i ) ) == vfpdef ) ) { int res = 0 ; res = handle_keywordonly_args ( c , n , i , kwonlyargs , kwdefaults ) ; if ( res == - 1 ) return NULL ; i = res ; } } break ; case DOUBLESTAR : ch = CHILD ( n , i + 1 ) ; assert ( TYPE ( ch ) == tfpdef || TYPE ( ch ) == vfpdef ) ; kwarg = ast_for_arg ( c , ch ) ; if ( ! kwarg ) return NULL ; i += 2 ; <S2SV_StartBug> if ( i < NCH ( n ) && TYPE ( CHILD ( n , i ) ) == COMMA ) <S2SV_EndBug> i += 1 ; break ; case TYPE_COMMENT : assert ( i ) ; if ( kwarg ) arg = kwarg ; arg -> type_comment = NEW_TYPE_COMMENT ( ch ) ; i += 1 ; break ; default : PyErr_Format ( PyExc_SystemError , \"unexpected<S2SV_blank>node<S2SV_blank>in<S2SV_blank>varargslist:<S2SV_blank>%d<S2SV_blank>@<S2SV_blank>%d\" , TYPE ( ch ) , i ) ; return NULL ; } } return arguments ( posargs , vararg , kwonlyargs , kwdefaults , kwarg , posdefaults , c -> c_arena ) ; }\n",
    "fixed_code": "<S2SV_ModStart> return NULL ; <S2SV_ModEnd> i = 0 <S2SV_ModStart> ; if ( <S2SV_ModEnd> TYPE ( CHILD <S2SV_ModStart> ; if ( <S2SV_ModEnd> TYPE ( CHILD <S2SV_ModStart> ; if ( <S2SV_ModEnd> TYPE ( CHILD <S2SV_ModStart> ; if ( <S2SV_ModEnd> TYPE ( CHILD <S2SV_ModStart> ; if ( <S2SV_ModEnd> TYPE ( CHILD\n",
    "source_code_length": 4617,
    "target_code_length": 300,
    "vulnerability_patterns": {
      "use_after_free": 2,
      "integer_overflow": 19,
      "null_pointer": 16,
      "total": 37
    },
    "total_patterns": 37,
    "original_address": "https://github.com/python/typed_ast/commit/156afcb26c198e162504a57caddfe0acd9ed7dce",
    "discovery_time": "2019-11-26T15:15Z",
    "project_commit_id": "python@typed_ast/156afcb26c198e162504a57caddfe0acd9ed7dce",
    "extraction_time": "2025-08-31T15:41:49.174266",
    "label": 1,
    "vulnerability_type": "out-of-bounds_read",
    "difficulty_level": "expert",
    "risk_factors": [
      "memory_corruption",
      "critical_infrastructure",
      "information_disclosure",
      "use_after_free",
      "integer_overflow"
    ],
    "attack_vectors": [
      "memory_manipulation",
      "malicious_input",
      "code_analysis",
      "buffer_overflow",
      "reverse_engineering",
      "fuzzing"
    ],
    "mitigation_strategies": [
      "safe_string_functions",
      "dynamic_analysis",
      "code_review",
      "static_analysis",
      "memory_safety_checks",
      "input_validation",
      "fuzzing",
      "bounds_checking",
      "secure_coding_practices"
    ],
    "code_differences": {
      "has_differences": true,
      "source_lines": 2,
      "target_lines": 2,
      "character_differences": 4317,
      "similarity_percentage": 9.70873786407767
    },
    "vulnerability_location": {
      "vulnerability_present": true,
      "fix_applied": true,
      "code_changed": true,
      "estimated_lines_changed": 0
    },
    "variants": [
      {
        "variant_id": "CVE-2019-19275_variant_1",
        "source_cve_id": "CVE-2019-19275",
        "variant_number": 1,
        "vulnerable_code": "CWE-125 static arguments_ty ast_for_arguments(struct compiling *c, const node *n) {\n    int posarg_count = 0, kwonly_count = 0;\n    int posdefault_count = 0, has_default = 0;\n    asdl_seq *positional_args, *positional_defaults, *keyword_only_args, *keyword_defaults;\n    arg_ty var_arg = NULL, kw_arg = NULL;\n    node *current_child;\n    \n    if (TYPE(n) == parameters) {\n        if (NCH(n) == 2) \n            return arguments(NULL, NULL, NULL, NULL, NULL, NULL, c->c_arena);\n        n = CHILD(n, 1);\n    }\n    \n    assert(TYPE(n) == typedargslist || TYPE(n) == varargslist);\n    \n    int index = 0;\n    while (index < NCH(n)) {\n        current_child = CHILD(n, index);\n        if (TYPE(current_child) == STAR) {\n            index++;\n            if (index < NCH(n) && (TYPE(CHILD(n, index)) == tfpdef || TYPE(CHILD(n, index)) == vfpdef)) {\n                index++;\n            }\n            break;\n        }\n        if (TYPE(current_child) == DOUBLESTAR) break;\n        if (TYPE(current_child) == vfpdef || TYPE(current_child) == tfpdef) posarg_count++;\n        if (TYPE(current_child) == EQUAL) posdefault_count++;\n        index++;\n    }\n    \n    for (int temp_idx = index; temp_idx < NCH(n); temp_idx++) {\n        current_child = CHILD(n, temp_idx);\n        if (TYPE(current_child) == DOUBLESTAR) break;\n        if (TYPE(current_child) == tfpdef || TYPE(current_child) == vfpdef) kwonly_count++;\n    }\n    \n    positional_args = (posarg_count ? _Ta3_asdl_seq_new(posarg_count, c->c_arena) : NULL);\n    if (!positional_args && posarg_count) return NULL;\n    \n    keyword_only_args = (kwonly_count ? _Ta3_asdl_seq_new(kwonly_count, c->c_arena) : NULL);\n    if (!keyword_only_args && kwonly_count) return NULL;\n    \n    positional_defaults = (posdefault_count ? _Ta3_asdl_seq_new(posdefault_count, c->c_arena) : NULL);\n    if (!positional_defaults && posdefault_count) return NULL;\n    \n    keyword_defaults = (kwonly_count ? _Ta3_asdl_seq_new(kwonly_count, c->c_arena) : NULL);\n    if (!keyword_defaults && kwonly_count) return NULL;\n    \n    if (posarg_count + kwonly_count > 255) {\n        ast_error(c, n, \"more than 255 arguments\");\n        return NULL;\n    }\n    \n    int pos_idx = 0, default_idx = 0, arg_idx = 0;\n    index = 0;\n    \n    while (index < NCH(n)) {\n        current_child = CHILD(n, index);\n        \n        switch (TYPE(current_child)) {\n            case tfpdef:\n            case vfpdef:\n                if ((index + 1) < NCH(n) && TYPE(CHILD(n, index + 1)) == EQUAL) {\n                    expr_ty default_expr = ast_for_expr(c, CHILD(n, index + 2));\n                    if (!default_expr) return NULL;\n                    asdl_seq_SET(positional_defaults, default_idx++, default_expr);\n                    index += 2;\n                    has_default = 1;\n                } else if (has_default) {\n                    ast_error(c, n, \"non-default argument follows default argument\");\n                    return NULL;\n                }\n                \n                arg_ty current_arg = ast_for_arg(c, current_child);\n                if (!current_arg) return NULL;\n                asdl_seq_SET(positional_args, arg_idx++, current_arg);\n                index++;\n                \n                if (index < NCH(n) && TYPE(CHILD(n, index)) == COMMA)\n                    index++;\n                break;\n                \n            case STAR:\n                if ((index + 1) >= NCH(n) || ((index + 2) == NCH(n) && \n                    (TYPE(CHILD(n, index + 1)) == COMMA || TYPE(CHILD(n, index + 1)) == TYPE_COMMENT))) {\n                    ast_error(c, CHILD(n, index), \"named arguments must follow bare *\");\n                    return NULL;\n                }\n                \n                current_child = CHILD(n, index + 1);\n                if (TYPE(current_child) == COMMA) {\n                    int result = 0;\n                    index += 2;\n                    \n                    if (index < NCH(n) && TYPE(CHILD(n, index)) == TYPE_COMMENT) {\n                        ast_error(c, CHILD(n, index), \"bare * has associated type comment\");\n                        return NULL;\n                    }\n                    \n                    result = handle_keywordonly_args(c, n, index, keyword_only_args, keyword_defaults);\n                    if (result == -1) return NULL;\n                    index = result;\n                } else {\n                    var_arg = ast_for_arg(c, current_child);\n                    if (!var_arg) return NULL;\n                    index += 2;\n                    \n                    if (index < NCH(n) && TYPE(CHILD(n, index)) == COMMA)\n                        index++;\n                    \n                    if (index < NCH(n) && TYPE(CHILD(n, index)) == TYPE_COMMENT) {\n                        var_arg->type_comment = NEW_TYPE_COMMENT(CHILD(n, index));\n                        index++;\n                    }\n                    \n                    if (index < NCH(n) && (TYPE(CHILD(n, index)) == tfpdef || TYPE(CHILD(n, index)) == vfpdef)) {\n                        int result = handle_keywordonly_args(c, n, index, keyword_only_args, keyword_defaults);\n                        if (result == -1) return NULL;\n                        index = result;\n                    }\n                }\n                break;\n                \n            case DOUBLESTAR:\n                current_child = CHILD(n, index + 1);\n                assert(TYPE(current_child) == tfpdef || TYPE(current_child) == vfpdef);\n                kw_arg = ast_for_arg(c, current_child);\n                if (!kw_arg) return NULL;\n                index += 2;\n                \n                if (index < NCH(n) && TYPE(CHILD(n, index)) == COMMA)\n                    index++;\n                break;\n                \n            case TYPE_COMMENT:\n                assert(index > 0);\n                arg_ty target_arg = kw_arg ? kw_arg : *(arg_ty *)((char *)positional_args + (arg_idx - 1) * sizeof(arg_ty));\n                target_arg->type_comment = NEW_TYPE_COMMENT(current_child);\n                index++;\n                break;\n                \n            default:\n                PyErr_Format(PyExc_SystemError, \"unexpected node in varargslist: %d @ %d\", \n                           TYPE(current_child), index);\n                return NULL;\n        }\n    }\n    \n    return arguments(positional_args, var_arg, keyword_only_args, keyword_defaults, \n                   kw_arg, positional_defaults, c->c_arena);\n}",
        "fixed_code": "<S2SV_ModStart> return NULL ; <S2SV_ModEnd> i = 0 <S2SV_ModStart> ; if ( <S2SV_ModEnd> TYPE ( CHILD <S2SV_ModStart> ; if ( <S2SV_ModEnd> TYPE ( CHILD <S2SV_ModStart> ; if ( <S2SV_ModEnd> TYPE ( CHILD <S2SV_ModStart> ; if ( <S2SV_ModEnd> TYPE ( CHILD <S2SV_ModStart> ; if ( <S2SV_ModEnd> TYPE ( CHILD\n",
        "cwe_id": "CWE-125",
        "cvss_score": "critical",
        "weaponization_score": 10.0,
        "project": "python",
        "vulnerability_type": "out-of-bounds_read",
        "difficulty_level": "expert",
        "risk_factors": [
          "memory_corruption",
          "critical_infrastructure",
          "information_disclosure",
          "use_after_free",
          "integer_overflow"
        ],
        "attack_vectors": [
          "memory_manipulation",
          "malicious_input",
          "code_analysis",
          "buffer_overflow",
          "reverse_engineering",
          "fuzzing"
        ],
        "mitigation_strategies": [
          "safe_string_functions",
          "dynamic_analysis",
          "code_review",
          "static_analysis",
          "memory_safety_checks",
          "input_validation",
          "fuzzing",
          "bounds_checking",
          "secure_coding_practices"
        ],
        "code_differences": {
          "original_length": 4617,
          "variant_length": 6444,
          "length_difference": 1827,
          "original_lines": 2,
          "variant_lines": 152,
          "line_difference": 150,
          "added_lines": 153,
          "removed_lines": 3,
          "similarity_ratio": 0.390923063014194
        },
        "vulnerability_location": {
          "vulnerability_present": true,
          "fix_applied": true,
          "code_changed": true,
          "estimated_lines_changed": 0
        },
        "validation_score": 0.75,
        "validation_checks": {
          "code_differences": true,
          "pattern_preservation": true,
          "structure_quality": true,
          "cwe_consistency": false
        },
        "generation_timestamp": "2025-09-02T14:29:33.739435",
        "generation_method": "deepseek_coder_refactoring"
      },
      {
        "variant_id": "CVE-2019-19275_variant_2",
        "source_cve_id": "CVE-2019-19275",
        "variant_number": 2,
        "vulnerable_code": "CWE_125 static arguments_ty refactored_ast_for_arguments(struct compiling *compiler_ctx, const node *parse_node) {\n    int idx = 0, pos_arg_idx = 0, kw_arg_idx = 0, default_idx = 0;\n    int total_pos_args = 0, total_kw_only = 0;\n    int pos_defaults_count = 0, has_default = 0;\n    asdl_seq *positional_args_seq, *positional_defaults_seq, *keyword_only_args_seq, *keyword_defaults_seq;\n    arg_ty var_args_ptr = NULL, kw_args_ptr = NULL;\n    arg_ty current_arg;\n    node *current_child;\n\n    if (NODE_TYPE(parse_node) == parameters) {\n        if (CHILD_COUNT(parse_node) == 2) {\n            return create_arguments(NULL, NULL, NULL, NULL, NULL, NULL, compiler_ctx->memory_arena);\n        }\n        parse_node = GET_CHILD(parse_node, 1);\n    }\n\n    _Static_assert(NODE_TYPE(parse_node) == typedargslist || NODE_TYPE(parse_node) == varargslist, \"Invalid node type\");\n\n    for (int scan_idx = 0; scan_idx < CHILD_COUNT(parse_node); scan_idx++) {\n        current_child = GET_CHILD(parse_node, scan_idx);\n        if (NODE_TYPE(current_child) == STAR) {\n            scan_idx++;\n            if (scan_idx < CHILD_COUNT(parse_node) && \n                (NODE_TYPE(GET_CHILD(parse_node, scan_idx)) == tfpdef || \n                 NODE_TYPE(GET_CHILD(parse_node, scan_idx)) == vfpdef)) {\n                scan_idx++;\n            }\n            idx = scan_idx;\n            break;\n        }\n        if (NODE_TYPE(current_child) == DOUBLESTAR) break;\n        if (NODE_TYPE(current_child) == vfpdef || NODE_TYPE(current_child) == tfpdef) total_pos_args++;\n        if (NODE_TYPE(current_child) == EQUAL) pos_defaults_count++;\n        idx = scan_idx + 1;\n    }\n\n    int temp_i = idx;\n    while (temp_i < CHILD_COUNT(parse_node)) {\n        current_child = GET_CHILD(parse_node, temp_i);\n        if (NODE_TYPE(current_child) == DOUBLESTAR) break;\n        if (NODE_TYPE(current_child) == tfpdef || NODE_TYPE(current_child) == vfpdef) total_kw_only++;\n        temp_i++;\n    }\n\n    positional_args_seq = total_pos_args ? _Ta3_asdl_seq_new(total_pos_args, compiler_ctx->memory_arena) : NULL;\n    if (!positional_args_seq && total_pos_args) return NULL;\n\n    keyword_only_args_seq = total_kw_only ? _Ta3_asdl_seq_new(total_kw_only, compiler_ctx->memory_arena) : NULL;\n    if (!keyword_only_args_seq && total_kw_only) return NULL;\n\n    positional_defaults_seq = pos_defaults_count ? _Ta3_asdl_seq_new(pos_defaults_count, compiler_ctx->memory_arena) : NULL;\n    if (!positional_defaults_seq && pos_defaults_count) return NULL;\n\n    keyword_defaults_seq = total_kw_only ? _Ta3_asdl_seq_new(total_kw_only, compiler_ctx->memory_arena) : NULL;\n    if (!keyword_defaults_seq && total_kw_only) return NULL;\n\n    if (*(&total_pos_args + &total_kw_only - &total_pos_args) > 255) {\n        report_ast_error(compiler_ctx, parse_node, \"more than 255 arguments\");\n        return NULL;\n    }\n\n    int processing_index = 0;\n    while (processing_index < CHILD_COUNT(parse_node)) {\n        current_child = GET_CHILD(parse_node, processing_index);\n        \n        switch (NODE_TYPE(current_child)) {\n            case tfpdef:\n            case vfpdef:\n                if (processing_index + 1 < CHILD_COUNT(parse_node) && \n                    NODE_TYPE(GET_CHILD(parse_node, processing_index + 1)) == EQUAL) {\n                    expr_ty default_expr = ast_for_expr(compiler_ctx, GET_CHILD(parse_node, processing_index + 2));\n                    if (!default_expr) return NULL;\n                    asdl_seq_SET(positional_defaults_seq, default_idx++, default_expr);\n                    processing_index += 2;\n                    has_default = 1;\n                } else if (has_default) {\n                    report_ast_error(compiler_ctx, parse_node, \"non-default argument follows default argument\");\n                    return NULL;\n                }\n                \n                current_arg = ast_for_arg(compiler_ctx, current_child);\n                if (!current_arg) return NULL;\n                asdl_seq_SET(positional_args_seq, pos_arg_idx++, current_arg);\n                processing_index++;\n\n                if (processing_index < CHILD_COUNT(parse_node) && \n                    NODE_TYPE(GET_CHILD(parse_node, processing_index)) == COMMA)\n                    processing_index++;\n                break;\n\n            case STAR:\n                if (processing_index + 1 >= CHILD_COUNT(parse_node) || \n                    (processing_index + 2 == CHILD_COUNT(parse_node) && \n                     (NODE_TYPE(GET_CHILD(parse_node, processing_index + 1)) == COMMA || \n                      NODE_TYPE(GET_CHILD(parse_node, processing_index + 1)) == TYPE_COMMENT))) {\n                    report_ast_error(compiler_ctx, GET_CHILD(parse_node, processing_index), \n                                   \"named arguments must follow bare *\");\n                    return NULL;\n                }\n\n                current_child = GET_CHILD(parse_node, processing_index + 1);\n                if (NODE_TYPE(current_child) == COMMA) {\n                    processing_index += 2;\n                    \n                    if (processing_index < CHILD_COUNT(parse_node) && \n                        NODE_TYPE(GET_CHILD(parse_node, processing_index)) == TYPE_COMMENT) {\n                        report_ast_error(compiler_ctx, GET_CHILD(parse_node, processing_index), \n                                       \"bare * has associated type comment\");\n                        return NULL;\n                    }\n                    \n                    int result = process_keyword_only_args(compiler_ctx, parse_node, processing_index, \n                                                         keyword_only_args_seq, keyword_defaults_seq);\n                    if (result == -1) return NULL;\n                    processing_index = result;\n                } else {\n                    var_args_ptr = ast_for_arg(compiler_ctx, current_child);\n                    if (!var_args_ptr) return NULL;\n                    processing_index += 2;\n\n                    if (processing_index < CHILD_COUNT(parse_node) && \n                        NODE_TYPE(GET_CHILD(parse_node, processing_index)) == COMMA)\n                        processing_index++;\n\n                    if (processing_index < CHILD_COUNT(parse_node) && \n                        NODE_TYPE(GET_CHILD(parse_node, processing_index)) == TYPE_COMMENT) {\n                        var_args_ptr->type_comment = CREATE_TYPE_COMMENT(GET_CHILD(parse_node, processing_index));\n                        processing_index++;\n                    }\n\n                    if (processing_index < CHILD_COUNT(parse_node) && \n                        (NODE_TYPE(GET_CHILD(parse_node, processing_index)) == tfpdef || \n                         NODE_TYPE(GET_CHILD(parse_node, processing_index)) == vfpdef)) {\n                        int result = process_keyword_only_args(compiler_ctx, parse_node, processing_index, \n                                                             keyword_only_args_seq, keyword_defaults_seq);\n                        if (result == -1) return NULL;\n                        processing_index = result;\n                    }\n                }\n                break;\n\n            case DOUBLESTAR:\n                current_child = GET_CHILD(parse_node, processing_index + 1);\n                _Static_assert(NODE_TYPE(current_child) == tfpdef || NODE_TYPE(current_child) == vfpdef, \"Invalid node type\");\n                kw_args_ptr = ast_for_arg(compiler_ctx, current_child);\n                if (!kw_args_ptr) return NULL;\n                processing_index += 2;\n\n                if (processing_index < CHILD_COUNT(parse_node) && \n                    NODE_TYPE(GET_CHILD(parse_node, processing_index)) == COMMA)\n                    processing_index++;\n                break;\n\n            case TYPE_COMMENT:\n                _Static_assert(processing_index > 0, \"Invalid position\");\n                current_arg = kw_args_ptr ? kw_args_ptr : current_arg;\n                current_arg->type_comment = CREATE_TYPE_COMMENT(current_child);\n                processing_index++;\n                break;\n\n            default:\n                PyErr_Format(PyExc_SystemError, \"unexpected node in varargslist: %d @ %d\", \n                           NODE_TYPE(current_child), processing_index);\n                return NULL;\n        }\n    }\n\n    return create_arguments(positional_args_seq, var_args_ptr, keyword_only_args_seq, \n                          keyword_defaults_seq, kw_args_ptr, positional_defaults_seq, \n                          compiler_ctx->memory_arena);\n}",
        "fixed_code": "<S2SV_ModStart> return NULL ; <S2SV_ModEnd> i = 0 <S2SV_ModStart> ; if ( <S2SV_ModEnd> TYPE ( CHILD <S2SV_ModStart> ; if ( <S2SV_ModEnd> TYPE ( CHILD <S2SV_ModStart> ; if ( <S2SV_ModEnd> TYPE ( CHILD <S2SV_ModStart> ; if ( <S2SV_ModEnd> TYPE ( CHILD <S2SV_ModStart> ; if ( <S2SV_ModEnd> TYPE ( CHILD\n",
        "cwe_id": "CWE-125",
        "cvss_score": "critical",
        "weaponization_score": 10.0,
        "project": "python",
        "vulnerability_type": "out-of-bounds_read",
        "difficulty_level": "expert",
        "risk_factors": [
          "memory_corruption",
          "critical_infrastructure",
          "information_disclosure",
          "use_after_free",
          "integer_overflow"
        ],
        "attack_vectors": [
          "memory_manipulation",
          "malicious_input",
          "code_analysis",
          "buffer_overflow",
          "reverse_engineering",
          "fuzzing"
        ],
        "mitigation_strategies": [
          "safe_string_functions",
          "dynamic_analysis",
          "code_review",
          "static_analysis",
          "memory_safety_checks",
          "input_validation",
          "fuzzing",
          "bounds_checking",
          "secure_coding_practices"
        ],
        "code_differences": {
          "original_length": 4617,
          "variant_length": 8530,
          "length_difference": 3913,
          "original_lines": 2,
          "variant_lines": 171,
          "line_difference": 169,
          "added_lines": 171,
          "removed_lines": 2,
          "similarity_ratio": 0.2315357115691793
        },
        "vulnerability_location": {
          "vulnerability_present": true,
          "fix_applied": true,
          "code_changed": true,
          "estimated_lines_changed": 0
        },
        "validation_score": 0.75,
        "validation_checks": {
          "code_differences": true,
          "pattern_preservation": true,
          "structure_quality": true,
          "cwe_consistency": false
        },
        "generation_timestamp": "2025-09-02T14:31:11.237947",
        "generation_method": "deepseek_coder_refactoring"
      },
      {
        "variant_id": "CVE-2019-19275_variant_3",
        "source_cve_id": "CVE-2019-19275",
        "variant_number": 3,
        "vulnerable_code": "CWE_125 static arguments_ty refactored_ast_for_arguments(struct compiling *compiler_ctx, const node *parse_node) {\n    int idx = 0, pos_arg_counter = 0, kwonly_arg_count = 0;\n    int pos_default_count = 0, has_default = 0;\n    asdl_seq *positional_args, *pos_defaults, *kwonly_args, *kw_defaults;\n    arg_ty var_arg_ptr = NULL, kw_arg_ptr = NULL;\n    node *current_child;\n\n    if (TYPE(parse_node) == parameters) {\n        if (NCH(parse_node) == 2) {\n            return arguments(NULL, NULL, NULL, NULL, NULL, NULL, compiler_ctx->c_arena);\n        }\n        parse_node = CHILD(parse_node, 1);\n    }\n\n    assert(TYPE(parse_node) == typedargslist || TYPE(parse_node) == varargslist);\n\n    for (int scan_idx = 0; scan_idx < NCH(parse_node); scan_idx++) {\n        current_child = CHILD(parse_node, scan_idx);\n        if (TYPE(current_child) == STAR) {\n            scan_idx++;\n            if (scan_idx < NCH(parse_node) && \n                (TYPE(CHILD(parse_node, scan_idx)) == tfpdef || \n                 TYPE(CHILD(parse_node, scan_idx)) == vfpdef)) {\n                scan_idx++;\n            }\n            break;\n        }\n        if (TYPE(current_child) == DOUBLESTAR) break;\n        if (TYPE(current_child) == vfpdef || TYPE(current_child) == tfpdef) pos_arg_counter++;\n        if (TYPE(current_child) == EQUAL) pos_default_count++;\n    }\n\n    int continuation_index = idx;\n    for (; continuation_index < NCH(parse_node); ++continuation_index) {\n        current_child = CHILD(parse_node, continuation_index);\n        if (TYPE(current_child) == DOUBLESTAR) break;\n        if (TYPE(current_child) == tfpdef || TYPE(current_child) == vfpdef) kwonly_arg_count++;\n    }\n\n    positional_args = (pos_arg_counter ? _Ta3_asdl_seq_new(pos_arg_counter, compiler_ctx->c_arena) : NULL);\n    if (!positional_args && pos_arg_counter) return NULL;\n    \n    kwonly_args = (kwonly_arg_count ? _Ta3_asdl_seq_new(kwonly_arg_count, compiler_ctx->c_arena) : NULL);\n    if (!kwonly_args && kwonly_arg_count) return NULL;\n    \n    pos_defaults = (pos_default_count ? _Ta3_asdl_seq_new(pos_default_count, compiler_ctx->c_arena) : NULL);\n    if (!pos_defaults && pos_default_count) return NULL;\n    \n    kw_defaults = (kwonly_arg_count ? _Ta3_asdl_seq_new(kwonly_arg_count, compiler_ctx->c_arena) : NULL);\n    if (!kw_defaults && kwonly_arg_count) return NULL;\n\n    int total_args_combined = pos_arg_counter + kwonly_arg_count;\n    if (total_args_combined > 255) {\n        ast_error(compiler_ctx, parse_node, \"more than 255 arguments\");\n        return NULL;\n    }\n\n    int pos_idx = 0, default_idx = 0, arg_store_idx = 0;\n    idx = 0;\n\n    while (idx < NCH(parse_node)) {\n        current_child = CHILD(parse_node, idx);\n        \n        switch (TYPE(current_child)) {\n            case tfpdef:\n            case vfpdef: {\n                int lookahead_idx = idx + 1;\n                if (lookahead_idx < NCH(parse_node) && TYPE(CHILD(parse_node, lookahead_idx)) == EQUAL) {\n                    expr_ty default_expr = ast_for_expr(compiler_ctx, CHILD(parse_node, idx + 2));\n                    if (!default_expr) return NULL;\n                    asdl_seq_SET(pos_defaults, default_idx++, default_expr);\n                    idx += 2;\n                    has_default = 1;\n                } else if (has_default) {\n                    ast_error(compiler_ctx, parse_node, \"non-default argument follows default argument\");\n                    return NULL;\n                }\n                \n                arg_ty parsed_arg = ast_for_arg(compiler_ctx, current_child);\n                if (!parsed_arg) return NULL;\n                asdl_seq_SET(positional_args, arg_store_idx++, parsed_arg);\n                idx++;\n\n                node *next_sibling = (idx < NCH(parse_node)) ? CHILD(parse_node, idx) : NULL;\n                if (next_sibling && TYPE(next_sibling) == COMMA)\n                    idx++;\n                break;\n            }\n            \n            case STAR: {\n                int next_idx = idx + 1;\n                if (next_idx >= NCH(parse_node) || \n                    (next_idx + 1 == NCH(parse_node) && \n                     (TYPE(CHILD(parse_node, next_idx)) == COMMA || \n                      TYPE(CHILD(parse_node, next_idx)) == TYPE_COMMENT))) {\n                    ast_error(compiler_ctx, CHILD(parse_node, idx), \"named arguments must follow bare *\");\n                    return NULL;\n                }\n                \n                node *star_next = CHILD(parse_node, idx + 1);\n                if (TYPE(star_next) == COMMA) {\n                    idx += 2;\n                    node *potential_comment = (idx < NCH(parse_node)) ? CHILD(parse_node, idx) : NULL;\n                    if (potential_comment && TYPE(potential_comment) == TYPE_COMMENT) {\n                        ast_error(compiler_ctx, CHILD(parse_node, idx), \"bare * has associated type comment\");\n                        return NULL;\n                    }\n                    int result = handle_keywordonly_args(compiler_ctx, parse_node, idx, kwonly_args, kw_defaults);\n                    if (result == -1) return NULL;\n                    idx = result;\n                } else {\n                    var_arg_ptr = ast_for_arg(compiler_ctx, star_next);\n                    if (!var_arg_ptr) return NULL;\n                    idx += 2;\n                    \n                    node *comma_check = (idx < NCH(parse_node)) ? CHILD(parse_node, idx) : NULL;\n                    if (comma_check && TYPE(comma_check) == COMMA)\n                        idx++;\n                        \n                    node *type_comment_check = (idx < NCH(parse_node)) ? CHILD(parse_node, idx) : NULL;\n                    if (type_comment_check && TYPE(type_comment_check) == TYPE_COMMENT) {\n                        var_arg_ptr->type_comment = NEW_TYPE_COMMENT(CHILD(parse_node, idx));\n                        idx++;\n                    }\n                    \n                    if (idx < NCH(parse_node) && \n                        (TYPE(CHILD(parse_node, idx)) == tfpdef || \n                         TYPE(CHILD(parse_node, idx)) == vfpdef)) {\n                        int res = handle_keywordonly_args(compiler_ctx, parse_node, idx, kwonly_args, kw_defaults);\n                        if (res == -1) return NULL;\n                        idx = res;\n                    }\n                }\n                break;\n            }\n            \n            case DOUBLESTAR: {\n                node *double_star_target = CHILD(parse_node, idx + 1);\n                assert(TYPE(double_star_target) == tfpdef || TYPE(double_star_target) == vfpdef);\n                kw_arg_ptr = ast_for_arg(compiler_ctx, double_star_target);\n                if (!kw_arg_ptr) return NULL;\n                idx += 2;\n                \n                node *comma_after_double_star = (idx < NCH(parse_node)) ? CHILD(parse_node, idx) : NULL;\n                if (comma_after_double_star && TYPE(comma_after_double_star) == COMMA)\n                    idx++;\n                break;\n            }\n            \n            case TYPE_COMMENT: {\n                assert(idx > 0);\n                arg_ty target_arg = kw_arg_ptr ? kw_arg_ptr : positional_args ? \n                    *(arg_ty *)asdl_seq_GET(positional_args, arg_store_idx - 1) : NULL;\n                if (target_arg) target_arg->type_comment = NEW_TYPE_COMMENT(current_child);\n                idx++;\n                break;\n            }\n            \n            default:\n                PyErr_Format(PyExc_SystemError, \"unexpected node in varargslist: %d @ %d\", \n                            TYPE(current_child), idx);\n                return NULL;\n        }\n    }\n    \n    return arguments(positional_args, var_arg_ptr, kwonly_args, kw_defaults, \n                    kw_arg_ptr, pos_defaults, compiler_ctx->c_arena);\n}",
        "fixed_code": "<S2SV_ModStart> return NULL ; <S2SV_ModEnd> i = 0 <S2SV_ModStart> ; if ( <S2SV_ModEnd> TYPE ( CHILD <S2SV_ModStart> ; if ( <S2SV_ModEnd> TYPE ( CHILD <S2SV_ModStart> ; if ( <S2SV_ModEnd> TYPE ( CHILD <S2SV_ModStart> ; if ( <S2SV_ModEnd> TYPE ( CHILD <S2SV_ModStart> ; if ( <S2SV_ModEnd> TYPE ( CHILD\n",
        "cwe_id": "CWE-125",
        "cvss_score": "critical",
        "weaponization_score": 10.0,
        "project": "python",
        "vulnerability_type": "out-of-bounds_read",
        "difficulty_level": "expert",
        "risk_factors": [
          "memory_corruption",
          "critical_infrastructure",
          "information_disclosure",
          "use_after_free",
          "integer_overflow"
        ],
        "attack_vectors": [
          "memory_manipulation",
          "malicious_input",
          "code_analysis",
          "buffer_overflow",
          "reverse_engineering",
          "fuzzing"
        ],
        "mitigation_strategies": [
          "safe_string_functions",
          "dynamic_analysis",
          "code_review",
          "static_analysis",
          "memory_safety_checks",
          "input_validation",
          "fuzzing",
          "bounds_checking",
          "secure_coding_practices"
        ],
        "code_differences": {
          "original_length": 4617,
          "variant_length": 7773,
          "length_difference": 3156,
          "original_lines": 2,
          "variant_lines": 168,
          "line_difference": 166,
          "added_lines": 168,
          "removed_lines": 2,
          "similarity_ratio": 0.35803066989507665
        },
        "vulnerability_location": {
          "vulnerability_present": true,
          "fix_applied": true,
          "code_changed": true,
          "estimated_lines_changed": 0
        },
        "validation_score": 0.75,
        "validation_checks": {
          "code_differences": true,
          "pattern_preservation": true,
          "structure_quality": true,
          "cwe_consistency": false
        },
        "generation_timestamp": "2025-09-02T14:32:44.350540",
        "generation_method": "deepseek_coder_refactoring"
      }
    ],
    "variant_count": 3
  }
]