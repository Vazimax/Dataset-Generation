CWE-125 static int ape_decode_frame ( AVCodecContext * avctx , void * data , int * got_frame_ptr , AVPacket * avpkt ) { AVFrame * frame = data ; const uint8_t * buf = avpkt -> data ; APEContext * s = avctx -> priv_data ; uint8_t * sample8 ; int16_t * sample16 ; int32_t * sample24 ; int i , ch , ret ; <S2SV_StartBug> int blockstodecode ; <S2SV_EndBug> av_assert0 ( s -> samples >= 0 ) ; if ( ! s -> samples ) { uint32_t nblocks , offset ; int buf_size ; if ( ! avpkt -> size ) { * got_frame_ptr = 0 ; return 0 ; } if ( avpkt -> size < 8 ) { av_log ( avctx , AV_LOG_ERROR , "Packet<S2SV_blank>is<S2SV_blank>too<S2SV_blank>small\\n" ) ; return AVERROR_INVALIDDATA ; } buf_size = avpkt -> size & ~ 3 ; if ( buf_size != avpkt -> size ) { av_log ( avctx , AV_LOG_WARNING , "packet<S2SV_blank>size<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>multiple<S2SV_blank>of<S2SV_blank>4.<S2SV_blank>" "extra<S2SV_blank>bytes<S2SV_blank>at<S2SV_blank>the<S2SV_blank>end<S2SV_blank>will<S2SV_blank>be<S2SV_blank>skipped.\\n" ) ; } if ( s -> fileversion < 3950 ) buf_size += 2 ; av_fast_padded_malloc ( & s -> data , & s -> data_size , buf_size ) ; if ( ! s -> data ) return AVERROR ( ENOMEM ) ; s -> bdsp . bswap_buf ( ( uint32_t * ) s -> data , ( const uint32_t * ) buf , buf_size >> 2 ) ; memset ( s -> data + ( buf_size & ~ 3 ) , 0 , buf_size & 3 ) ; s -> ptr = s -> data ; s -> data_end = s -> data + buf_size ; nblocks = bytestream_get_be32 ( & s -> ptr ) ; offset = bytestream_get_be32 ( & s -> ptr ) ; if ( s -> fileversion >= 3900 ) { if ( offset > 3 ) { av_log ( avctx , AV_LOG_ERROR , "Incorrect<S2SV_blank>offset<S2SV_blank>passed\\n" ) ; s -> data = NULL ; return AVERROR_INVALIDDATA ; } if ( s -> data_end - s -> ptr < offset ) { av_log ( avctx , AV_LOG_ERROR , "Packet<S2SV_blank>is<S2SV_blank>too<S2SV_blank>small\\n" ) ; return AVERROR_INVALIDDATA ; } s -> ptr += offset ; } else { if ( ( ret = init_get_bits8 ( & s -> gb , s -> ptr , s -> data_end - s -> ptr ) ) < 0 ) return ret ; if ( s -> fileversion > 3800 ) skip_bits_long ( & s -> gb , offset * 8 ) ; else skip_bits_long ( & s -> gb , offset ) ; } <S2SV_StartBug> if ( ! nblocks || nblocks > INT_MAX ) { <S2SV_EndBug> av_log ( avctx , AV_LOG_ERROR , "Invalid<S2SV_blank>sample<S2SV_blank>count:<S2SV_blank>%" PRIu32 ".\\n" , nblocks ) ; return AVERROR_INVALIDDATA ; } if ( init_frame_decoder ( s ) < 0 ) { av_log ( avctx , AV_LOG_ERROR , "Error<S2SV_blank>reading<S2SV_blank>frame<S2SV_blank>header\\n" ) ; return AVERROR_INVALIDDATA ; } s -> samples = nblocks ; } if ( ! s -> data ) { * got_frame_ptr = 0 ; return avpkt -> size ; } blockstodecode = FFMIN ( s -> blocks_per_loop , s -> samples ) ; if ( s -> fileversion < 3930 ) blockstodecode = s -> samples ; <S2SV_StartBug> av_fast_malloc ( & s -> decoded_buffer , & s -> decoded_size , <S2SV_EndBug> <S2SV_StartBug> 2 * FFALIGN ( blockstodecode , 8 ) * sizeof ( * s -> decoded_buffer ) ) ; <S2SV_EndBug> if ( ! s -> decoded_buffer ) return AVERROR ( ENOMEM ) ; memset ( s -> decoded_buffer , 0 , s -> decoded_size ) ; s -> decoded [ 0 ] = s -> decoded_buffer ; s -> decoded [ 1 ] = s -> decoded_buffer + FFALIGN ( blockstodecode , 8 ) ; frame -> nb_samples = blockstodecode ; if ( ( ret = ff_get_buffer ( avctx , frame , 0 ) ) < 0 ) return ret ; s -> error = 0 ; if ( ( s -> channels == 1 ) || ( s -> frameflags & APE_FRAMECODE_PSEUDO_STEREO ) ) ape_unpack_mono ( s , blockstodecode ) ; else ape_unpack_stereo ( s , blockstodecode ) ; emms_c ( ) ; if ( s -> error ) { s -> samples = 0 ; av_log ( avctx , AV_LOG_ERROR , "Error<S2SV_blank>decoding<S2SV_blank>frame\\n" ) ; return AVERROR_INVALIDDATA ; } switch ( s -> bps ) { case 8 : for ( ch = 0 ; ch < s -> channels ; ch ++ ) { sample8 = ( uint8_t * ) frame -> data [ ch ] ; for ( i = 0 ; i < blockstodecode ; i ++ ) * sample8 ++ = ( s -> decoded [ ch ] [ i ] + 0x80 ) & 0xff ; } break ; case 16 : for ( ch = 0 ; ch < s -> channels ; ch ++ ) { sample16 = ( int16_t * ) frame -> data [ ch ] ; for ( i = 0 ; i < blockstodecode ; i ++ ) * sample16 ++ = s -> decoded [ ch ] [ i ] ; } break ; case 24 : for ( ch = 0 ; ch < s -> channels ; ch ++ ) { sample24 = ( int32_t * ) frame -> data [ ch ] ; for ( i = 0 ; i < blockstodecode ; i ++ ) * sample24 ++ = s -> decoded [ ch ] [ i ] << 8 ; } break ; } s -> samples -= blockstodecode ; * got_frame_ptr = 1 ; return ! s -> samples ? avpkt -> size : 0 ; }
