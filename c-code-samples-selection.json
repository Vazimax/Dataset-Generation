[
	{"Unnamed: 0":6299,"cwe_id":"CWE-476","source":"CWE-476 static int compile_length_bag_node ( BagNode * node , regex_t * reg ) { int len ; int tlen ; if ( node -> type == BAG_OPTION ) return compile_length_option_node ( node , reg ) ; if ( NODE_BAG_BODY ( node ) ) { tlen = compile_length_tree ( NODE_BAG_BODY ( node ) , reg ) ; if ( tlen < 0 ) return tlen ; } else tlen = 0 ; switch ( node -> type ) { case BAG_MEMORY : # ifdef USE_CALL if ( node -> m . regnum == 0 && NODE_IS_CALLED ( node ) ) { len = tlen + SIZE_OP_CALL + SIZE_OP_JUMP + SIZE_OP_RETURN ; return len ; } if ( NODE_IS_CALLED ( node ) ) { len = SIZE_OP_MEMORY_START_PUSH + tlen + SIZE_OP_CALL + SIZE_OP_JUMP + SIZE_OP_RETURN ; if ( MEM_STATUS_AT0 ( reg -> bt_mem_end , node -> m . regnum ) ) len += ( NODE_IS_RECURSION ( node ) ? SIZE_OP_MEMORY_END_PUSH_REC : SIZE_OP_MEMORY_END_PUSH ) ; else len += ( NODE_IS_RECURSION ( node ) ? SIZE_OP_MEMORY_END_REC : SIZE_OP_MEMORY_END ) ; } else if ( NODE_IS_RECURSION ( node ) ) { len = SIZE_OP_MEMORY_START_PUSH ; len += tlen + ( MEM_STATUS_AT0 ( reg -> bt_mem_end , node -> m . regnum ) ? SIZE_OP_MEMORY_END_PUSH_REC : SIZE_OP_MEMORY_END_REC ) ; } else # endif { if ( MEM_STATUS_AT0 ( reg -> bt_mem_start , node -> m . regnum ) ) len = SIZE_OP_MEMORY_START_PUSH ; else len = SIZE_OP_MEMORY_START ; len += tlen + ( MEM_STATUS_AT0 ( reg -> bt_mem_end , node -> m . regnum ) ? SIZE_OP_MEMORY_END_PUSH : SIZE_OP_MEMORY_END ) ; } break ; case BAG_STOP_BACKTRACK : if ( NODE_IS_STOP_BT_SIMPLE_REPEAT ( node ) ) { int v ; QuantNode * qn ; qn = QUANT_ ( NODE_BAG_BODY ( node ) ) ; tlen = compile_length_tree ( NODE_QUANT_BODY ( qn ) , reg ) ; if ( tlen < 0 ) return tlen ; v = onig_positive_int_multiply ( qn -> lower , tlen ) ; if ( v < 0 ) return ONIGERR_TOO_BIG_NUMBER_FOR_REPEAT_RANGE ; len = v + SIZE_OP_PUSH + tlen + SIZE_OP_POP_OUT + SIZE_OP_JUMP ; } else { len = SIZE_OP_ATOMIC_START + tlen + SIZE_OP_ATOMIC_END ; } break ; case BAG_IF_ELSE : { Node * cond = NODE_BAG_BODY ( node ) ; Node * Then = node -> te . Then ; Node * Else = node -> te . Else ; len = compile_length_tree ( cond , reg ) ; if ( len < 0 ) return len ; len += SIZE_OP_PUSH ; len += SIZE_OP_ATOMIC_START + SIZE_OP_ATOMIC_END ; if ( IS_NOT_NULL ( Then ) ) { tlen = compile_length_tree ( Then , reg ) ; if ( tlen < 0 ) return tlen ; len += tlen ; } <S2SV_StartBug> if ( IS_NOT_NULL ( Else ) ) { <S2SV_EndBug> <S2SV_StartBug> len += SIZE_OP_JUMP ; <S2SV_EndBug> tlen = compile_length_tree ( Else , reg ) ; if ( tlen < 0 ) return tlen ; len += tlen ; } } break ; case BAG_OPTION : len = 0 ; break ; } return len ; }\n","target":"<S2SV_ModStart> tlen ; } len += SIZE_OP_JUMP + SIZE_OP_ATOMIC_END ; <S2SV_ModStart> ) ) { <S2SV_ModEnd> tlen = compile_length_tree\n","project_and_commit_id":"kkos@oniguruma/c509265c5f6ae7264f7b8a8aae1cfa5fc59d108c","cve_id":"CVE-2019-13225","original_address":"https://github.com/kkos/oniguruma/commit/c509265c5f6ae7264f7b8a8aae1cfa5fc59d108c","time":"2019-07-10T14:15Z"},
	{"Unnamed: 0":6570,"cwe_id":"CWE-416","source":"CWE-416 static void smp_task_done ( struct sas_task * task ) { <S2SV_StartBug> if ( ! del_timer ( & task -> slow_task -> timer ) ) <S2SV_EndBug> return ; complete ( & task -> slow_task -> completion ) ; }\n","target":"<S2SV_ModStart> task ) { <S2SV_ModEnd> del_timer ( & <S2SV_ModStart> -> timer ) <S2SV_ModEnd> ; complete (\n","project_and_commit_id":"torvalds@linux/b90cd6f2b905905fb42671009dc0e27c310a16ae","cve_id":"CVE-2018-20836","original_address":"https://github.com/torvalds/linux/commit/b90cd6f2b905905fb42671009dc0e27c310a16ae","time":"2019-05-07T14:29Z"},
	{"Unnamed: 0":5563,"cwe_id":"CWE-416","source":"CWE-416 struct snd_seq_client_port * snd_seq_create_port ( struct snd_seq_client * client , int port ) { unsigned long flags ; struct snd_seq_client_port * new_port , * p ; int num = - 1 ; if ( snd_BUG_ON ( ! client ) ) return NULL ; if ( client -> num_ports >= SNDRV_SEQ_MAX_PORTS ) { pr_warn ( \"ALSA:<S2SV_blank>seq:<S2SV_blank>too<S2SV_blank>many<S2SV_blank>ports<S2SV_blank>for<S2SV_blank>client<S2SV_blank>%d\\\\n\" , client -> number ) ; return NULL ; } new_port = kzalloc ( sizeof ( * new_port ) , GFP_KERNEL ) ; if ( ! new_port ) return NULL ; new_port -> addr . client = client -> number ; new_port -> addr . port = - 1 ; new_port -> owner = THIS_MODULE ; sprintf ( new_port -> name , \"port-%d\" , num ) ; snd_use_lock_init ( & new_port -> use_lock ) ; port_subs_info_init ( & new_port -> c_src ) ; port_subs_info_init ( & new_port -> c_dest ) ; <S2SV_StartBug> num = port >= 0 ? port : 0 ; <S2SV_EndBug> mutex_lock ( & client -> ports_mutex ) ; write_lock_irqsave ( & client -> ports_lock , flags ) ; list_for_each_entry ( p , & client -> ports_list_head , list ) { if ( p -> addr . port > num ) break ; if ( port < 0 ) num = p -> addr . port + 1 ; } list_add_tail ( & new_port -> list , & p -> list ) ; client -> num_ports ++ ; new_port -> addr . port = num ; <S2SV_StartBug> write_unlock_irqrestore ( & client -> ports_lock , flags ) ; <S2SV_EndBug> <S2SV_StartBug> mutex_unlock ( & client -> ports_mutex ) ; <S2SV_EndBug> sprintf ( new_port -> name , \"port-%d\" , num ) ; return new_port ; }\n","target":"<S2SV_ModStart> c_dest ) ; snd_use_lock_use ( & new_port -> use_lock ) ; <S2SV_ModStart> = num ; sprintf ( new_port -> name , \"port-%d\" , num ) ; <S2SV_ModStart> client -> ports_mutex <S2SV_ModEnd> ) ; return\n","project_and_commit_id":"torvalds@linux/71105998845fb012937332fe2e806d443c09e026","cve_id":"CVE-2017-15265","original_address":"https://github.com/torvalds/linux/commit/71105998845fb012937332fe2e806d443c09e026","time":"2017-10-16T18:29Z"},
	{"Unnamed: 0":4305,"cwe_id":"CWE-119","source":"CWE-119 ssize_t cdf_read_short_sector ( const cdf_stream_t * sst , void * buf , size_t offs , size_t len , const cdf_header_t * h , cdf_secid_t id ) { <S2SV_StartBug> assert ( ( size_t ) CDF_SHORT_SEC_SIZE ( h ) == len ) ; <S2SV_EndBug> ( void ) memcpy ( ( ( char * ) buf ) + offs , <S2SV_StartBug> ( ( const char * ) sst -> sst_tab ) + CDF_SHORT_SEC_POS ( h , id ) , len ) ; <S2SV_EndBug> return len ; }\n","target":"<S2SV_ModStart> id ) { size_t ss = <S2SV_ModEnd> CDF_SHORT_SEC_SIZE ( h <S2SV_ModStart> ( h ) ; size_t pos = CDF_SHORT_SEC_POS ( h , id ) ; assert ( ss <S2SV_ModStart> len ) ; if ( sst -> sst_len < ( size_t ) id ) { DPRINTF ( ( \"bad<S2SV_blank>sector<S2SV_blank>id<S2SV_blank>%d<S2SV_blank>><S2SV_blank>%d\\\\n\" , id , sst -> sst_len ) ) ; return - 1 ; } <S2SV_ModStart> sst_tab ) + pos <S2SV_ModEnd> , len )\n","project_and_commit_id":"glensc@file/1859fdb4e67c49c463c4e0078054335cd46ba295","cve_id":"CVE-2012-1571","original_address":"https://github.com/glensc/file/commit/1859fdb4e67c49c463c4e0078054335cd46ba295","time":"2012-07-17T21:55Z"},
	{"Unnamed: 0":4250,"cwe_id":"CWE-400","source":"CWE-400 static void perf_swevent_event ( struct perf_event * event , u64 nr , <S2SV_StartBug> int nmi , struct perf_sample_data * data , <S2SV_EndBug> struct pt_regs * regs ) { struct hw_perf_event * hwc = & event -> hw ; local64_add ( nr , & event -> count ) ; if ( ! regs ) return ; if ( ! is_sampling_event ( event ) ) return ; if ( nr == 1 && hwc -> sample_period == 1 && ! event -> attr . freq ) <S2SV_StartBug> return perf_swevent_overflow ( event , 1 , nmi , data , regs ) ; <S2SV_EndBug> if ( local64_add_negative ( nr , & hwc -> period_left ) ) return ; <S2SV_StartBug> perf_swevent_overflow ( event , 0 , nmi , data , regs ) ; <S2SV_EndBug> }\n","target":"<S2SV_ModStart> u64 nr , <S2SV_ModEnd> struct perf_sample_data * <S2SV_ModStart> , 1 , <S2SV_ModEnd> data , regs <S2SV_ModStart> , 0 , <S2SV_ModEnd> data , regs\n","project_and_commit_id":"torvalds@linux/a8b0ca17b80e92faab46ee7179ba9e99ccb61233","cve_id":"CVE-2011-2918","original_address":"https://github.com/torvalds/linux/commit/a8b0ca17b80e92faab46ee7179ba9e99ccb61233","time":"2012-05-24T23:55Z"},
	{"Unnamed: 0":797,"cwe_id":"CWE-416","source":"CWE-416 int SMB2_write ( const unsigned int xid , struct cifs_io_parms * io_parms , unsigned int * nbytes , struct kvec * iov , int n_vec ) { struct smb_rqst rqst ; int rc = 0 ; struct smb2_write_req * req = NULL ; struct smb2_write_rsp * rsp = NULL ; int resp_buftype ; struct kvec rsp_iov ; int flags = 0 ; unsigned int total_len ; * nbytes = 0 ; if ( n_vec < 1 ) return rc ; rc = smb2_plain_req_init ( SMB2_WRITE , io_parms -> tcon , ( void * * ) & req , & total_len ) ; if ( rc ) return rc ; if ( io_parms -> tcon -> ses -> server == NULL ) return - ECONNABORTED ; if ( smb3_encryption_required ( io_parms -> tcon ) ) flags |= CIFS_TRANSFORM_REQ ; req -> sync_hdr . ProcessId = cpu_to_le32 ( io_parms -> pid ) ; req -> PersistentFileId = io_parms -> persistent_fid ; req -> VolatileFileId = io_parms -> volatile_fid ; req -> WriteChannelInfoOffset = 0 ; req -> WriteChannelInfoLength = 0 ; req -> Channel = 0 ; req -> Length = cpu_to_le32 ( io_parms -> length ) ; req -> Offset = cpu_to_le64 ( io_parms -> offset ) ; req -> DataOffset = cpu_to_le16 ( offsetof ( struct smb2_write_req , Buffer ) ) ; req -> RemainingBytes = 0 ; trace_smb3_write_enter ( xid , io_parms -> persistent_fid , io_parms -> tcon -> tid , io_parms -> tcon -> ses -> Suid , io_parms -> offset , io_parms -> length ) ; iov [ 0 ] . iov_base = ( char * ) req ; iov [ 0 ] . iov_len = total_len - 1 ; memset ( & rqst , 0 , sizeof ( struct smb_rqst ) ) ; rqst . rq_iov = iov ; rqst . rq_nvec = n_vec + 1 ; rc = cifs_send_recv ( xid , io_parms -> tcon -> ses , & rqst , & resp_buftype , flags , & rsp_iov ) ; <S2SV_StartBug> cifs_small_buf_release ( req ) ; <S2SV_EndBug> rsp = ( struct smb2_write_rsp * ) rsp_iov . iov_base ; if ( rc ) { trace_smb3_write_err ( xid , req -> PersistentFileId , io_parms -> tcon -> tid , io_parms -> tcon -> ses -> Suid , io_parms -> offset , io_parms -> length , rc ) ; cifs_stats_fail_inc ( io_parms -> tcon , SMB2_WRITE_HE ) ; cifs_dbg ( VFS , \"Send<S2SV_blank>error<S2SV_blank>in<S2SV_blank>write<S2SV_blank>=<S2SV_blank>%d\\\\n\" , rc ) ; } else { * nbytes = le32_to_cpu ( rsp -> DataLength ) ; trace_smb3_write_done ( xid , req -> PersistentFileId , io_parms -> tcon -> tid , io_parms -> tcon -> ses -> Suid , io_parms -> offset , * nbytes ) ; } <S2SV_StartBug> free_rsp_buf ( resp_buftype , rsp ) ; <S2SV_EndBug> return rc ; }\n","target":"<S2SV_ModStart> rsp_iov ) ; <S2SV_ModEnd> rsp = ( <S2SV_ModStart> ) ; } cifs_small_buf_release ( req ) ;\n","project_and_commit_id":"torvalds@linux/6a3eb3360667170988f8a6477f6686242061488a","cve_id":"CVE-2019-15919","original_address":"https://github.com/torvalds/linux/commit/6a3eb3360667170988f8a6477f6686242061488a","time":"2019-09-04T19:15Z"},
	{"Unnamed: 0":935,"cwe_id":"CWE-399","source":"CWE-399 protected struct magic_set * file_ms_alloc ( int flags ) { struct magic_set * ms ; size_t i , len ; if ( ( ms = CAST ( struct magic_set * , calloc ( ( size_t ) 1 , sizeof ( struct magic_set ) ) ) ) == NULL ) return NULL ; if ( magic_setflags ( ms , flags ) == - 1 ) { errno = EINVAL ; goto free ; } ms -> o . buf = ms -> o . pbuf = NULL ; len = ( ms -> c . len = 10 ) * sizeof ( * ms -> c . li ) ; if ( ( ms -> c . li = CAST ( struct level_info * , malloc ( len ) ) ) == NULL ) goto free ; ms -> event_flags = 0 ; ms -> error = - 1 ; for ( i = 0 ; i < MAGIC_SETS ; i ++ ) ms -> mlist [ i ] = NULL ; ms -> file = \"unknown\" ; ms -> line = 0 ; ms -> indir_max = FILE_INDIR_MAX ; ms -> name_max = FILE_NAME_MAX ; ms -> elf_shnum_max = FILE_ELF_SHNUM_MAX ; ms -> elf_phnum_max = FILE_ELF_PHNUM_MAX ; <S2SV_StartBug> return ms ; <S2SV_EndBug> free : free ( ms ) ; return NULL ; }\n","target":"<S2SV_ModStart> = FILE_ELF_PHNUM_MAX ; ms -> elf_notes_max = FILE_ELF_NOTES_MAX ;\n","project_and_commit_id":"file@file/ce90e05774dd77d86cfc8dfa6da57b32816841c4","cve_id":"CVE-2014-9620","original_address":"https://github.com/file/file/commit/ce90e05774dd77d86cfc8dfa6da57b32816841c4","time":"2015-01-21T18:59Z"},
	{"Unnamed: 0":6708,"cwe_id":"CWE-200","source":"CWE-200 void rds_inc_info_copy ( struct rds_incoming * inc , struct rds_info_iterator * iter , __be32 saddr , __be32 daddr , int flip ) { struct rds_info_message minfo ; minfo . seq = be64_to_cpu ( inc -> i_hdr . h_sequence ) ; minfo . len = be32_to_cpu ( inc -> i_hdr . h_len ) ; if ( flip ) { minfo . laddr = daddr ; minfo . faddr = saddr ; minfo . lport = inc -> i_hdr . h_dport ; minfo . fport = inc -> i_hdr . h_sport ; } else { minfo . laddr = saddr ; minfo . faddr = daddr ; minfo . lport = inc -> i_hdr . h_sport ; minfo . fport = inc -> i_hdr . h_dport ; } <S2SV_StartBug> rds_info_copy ( iter , & minfo , sizeof ( minfo ) ) ; <S2SV_EndBug> }\n","target":"<S2SV_ModStart> h_dport ; } minfo . flags = 0 ;\n","project_and_commit_id":"torvalds@linux/4116def2337991b39919f3b448326e21c40e0dbb","cve_id":"CVE-2016-5244","original_address":"https://github.com/torvalds/linux/commit/4116def2337991b39919f3b448326e21c40e0dbb","time":"2016-06-27T10:59Z"},
	{"Unnamed: 0":6592,"cwe_id":"CWE-190","source":"CWE-190 static inline void process_get_command ( conn * c , token_t * tokens , size_t ntokens , bool return_cas ) { char * key ; size_t nkey ; int i = 0 ; item * it ; token_t * key_token = & tokens [ KEY_TOKEN ] ; char * suffix ; assert ( c != NULL ) ; do { while ( key_token -> length != 0 ) { key = key_token -> value ; nkey = key_token -> length ; if ( nkey > KEY_MAX_LENGTH ) { out_string ( c , \"CLIENT_ERROR<S2SV_blank>bad<S2SV_blank>command<S2SV_blank>line<S2SV_blank>format\" ) ; while ( i -- > 0 ) { item_remove ( * ( c -> ilist + i ) ) ; } return ; } <S2SV_StartBug> it = item_get ( key , nkey , c , DO_UPDATE ) ; <S2SV_EndBug> if ( settings . detail_enabled ) { stats_prefix_record_get ( key , nkey , NULL != it ) ; } if ( it ) { if ( i >= c -> isize ) { item * * new_list = realloc ( c -> ilist , sizeof ( item * ) * c -> isize * 2 ) ; if ( new_list ) { c -> isize *= 2 ; c -> ilist = new_list ; } else { STATS_LOCK ( ) ; stats . malloc_fails ++ ; STATS_UNLOCK ( ) ; item_remove ( it ) ; break ; } } if ( return_cas || ! settings . inline_ascii_response ) { MEMCACHED_COMMAND_GET ( c -> sfd , ITEM_key ( it ) , it -> nkey , it -> nbytes , ITEM_get_cas ( it ) ) ; if ( i >= c -> suffixsize ) { char * * new_suffix_list = realloc ( c -> suffixlist , sizeof ( char * ) * c -> suffixsize * 2 ) ; if ( new_suffix_list ) { c -> suffixsize *= 2 ; c -> suffixlist = new_suffix_list ; } else { STATS_LOCK ( ) ; stats . malloc_fails ++ ; STATS_UNLOCK ( ) ; item_remove ( it ) ; break ; } } suffix = do_cache_alloc ( c -> thread -> suffix_cache ) ; if ( suffix == NULL ) { STATS_LOCK ( ) ; stats . malloc_fails ++ ; STATS_UNLOCK ( ) ; out_of_memory ( c , \"SERVER_ERROR<S2SV_blank>out<S2SV_blank>of<S2SV_blank>memory<S2SV_blank>making<S2SV_blank>CAS<S2SV_blank>suffix\" ) ; item_remove ( it ) ; while ( i -- > 0 ) { item_remove ( * ( c -> ilist + i ) ) ; } return ; } * ( c -> suffixlist + i ) = suffix ; int suffix_len = make_ascii_get_suffix ( suffix , it , return_cas ) ; if ( add_iov ( c , \"VALUE<S2SV_blank>\" , 6 ) != 0 || add_iov ( c , ITEM_key ( it ) , it -> nkey ) != 0 || ( settings . inline_ascii_response && add_iov ( c , ITEM_suffix ( it ) , it -> nsuffix - 2 ) != 0 ) || add_iov ( c , suffix , suffix_len ) != 0 ) { item_remove ( it ) ; break ; } if ( ( it -> it_flags & ITEM_CHUNKED ) == 0 ) { add_iov ( c , ITEM_data ( it ) , it -> nbytes ) ; } else if ( add_chunked_item_iovs ( c , it , it -> nbytes ) != 0 ) { item_remove ( it ) ; break ; } } else { MEMCACHED_COMMAND_GET ( c -> sfd , ITEM_key ( it ) , it -> nkey , it -> nbytes , ITEM_get_cas ( it ) ) ; if ( add_iov ( c , \"VALUE<S2SV_blank>\" , 6 ) != 0 || add_iov ( c , ITEM_key ( it ) , it -> nkey ) != 0 ) { item_remove ( it ) ; break ; } if ( ( it -> it_flags & ITEM_CHUNKED ) == 0 ) { if ( add_iov ( c , ITEM_suffix ( it ) , it -> nsuffix + it -> nbytes ) != 0 ) { item_remove ( it ) ; break ; } } else if ( add_iov ( c , ITEM_suffix ( it ) , it -> nsuffix ) != 0 || add_chunked_item_iovs ( c , it , it -> nbytes ) != 0 ) { item_remove ( it ) ; break ; } } if ( settings . verbose > 1 ) { int ii ; fprintf ( stderr , \">%d<S2SV_blank>sending<S2SV_blank>key<S2SV_blank>\" , c -> sfd ) ; for ( ii = 0 ; ii < it -> nkey ; ++ ii ) { fprintf ( stderr , \"%c\" , key [ ii ] ) ; } fprintf ( stderr , \"\\\\n\" ) ; } pthread_mutex_lock ( & c -> thread -> stats . mutex ) ; c -> thread -> stats . slab_stats [ ITEM_clsid ( it ) ] . get_hits ++ ; c -> thread -> stats . get_cmds ++ ; pthread_mutex_unlock ( & c -> thread -> stats . mutex ) ; * ( c -> ilist + i ) = it ; i ++ ; } else { pthread_mutex_lock ( & c -> thread -> stats . mutex ) ; c -> thread -> stats . get_misses ++ ; c -> thread -> stats . get_cmds ++ ; pthread_mutex_unlock ( & c -> thread -> stats . mutex ) ; MEMCACHED_COMMAND_GET ( c -> sfd , key , nkey , - 1 , 0 ) ; } key_token ++ ; } if ( key_token -> value != NULL ) { ntokens = tokenize_command ( key_token -> value , tokens , MAX_TOKENS ) ; key_token = tokens ; } } while ( key_token -> value != NULL ) ; c -> icurr = c -> ilist ; c -> ileft = i ; if ( return_cas || ! settings . inline_ascii_response ) { c -> suffixcurr = c -> suffixlist ; c -> suffixleft = i ; } if ( settings . verbose > 1 ) fprintf ( stderr , \">%d<S2SV_blank>END\\\\n\" , c -> sfd ) ; if ( key_token -> value != NULL || add_iov ( c , \"END\\\\r\\\\n\" , 5 ) != 0 || ( IS_UDP ( c -> transport ) && build_udp_headers ( c ) != 0 ) ) { out_of_memory ( c , \"SERVER_ERROR<S2SV_blank>out<S2SV_blank>of<S2SV_blank>memory<S2SV_blank>writing<S2SV_blank>get<S2SV_blank>response\" ) ; } else { conn_set_state ( c , conn_mwrite ) ; c -> msgcurr = 0 ; } }\n","target":"<S2SV_ModStart> } it = limited_get <S2SV_ModEnd> ( key , <S2SV_ModStart> nkey , c <S2SV_ModEnd> ) ; if\n","project_and_commit_id":"memcached@memcached/a8c4a82787b8b6c256d61bd5c42fb7f92d1bae00","cve_id":"CVE-2018-1000127","original_address":"https://github.com/memcached/memcached/commit/a8c4a82787b8b6c256d61bd5c42fb7f92d1bae00","time":"2018-03-13T21:29Z"},
	{"Unnamed: 0":4501,"cwe_id":"CWE-119","source":"CWE-119 int sock_setsockopt ( struct socket * sock , int level , int optname , char __user * optval , unsigned int optlen ) { struct sock * sk = sock -> sk ; int val ; int valbool ; struct linger ling ; int ret = 0 ; if ( optname == SO_BINDTODEVICE ) return sock_setbindtodevice ( sk , optval , optlen ) ; if ( optlen < sizeof ( int ) ) return - EINVAL ; if ( get_user ( val , ( int __user * ) optval ) ) return - EFAULT ; valbool = val ? 1 : 0 ; lock_sock ( sk ) ; switch ( optname ) { case SO_DEBUG : if ( val && ! capable ( CAP_NET_ADMIN ) ) ret = - EACCES ; else sock_valbool_flag ( sk , SOCK_DBG , valbool ) ; break ; case SO_REUSEADDR : sk -> sk_reuse = ( valbool ? SK_CAN_REUSE : SK_NO_REUSE ) ; break ; case SO_REUSEPORT : sk -> sk_reuseport = valbool ; break ; case SO_TYPE : case SO_PROTOCOL : case SO_DOMAIN : case SO_ERROR : ret = - ENOPROTOOPT ; break ; case SO_DONTROUTE : sock_valbool_flag ( sk , SOCK_LOCALROUTE , valbool ) ; break ; case SO_BROADCAST : sock_valbool_flag ( sk , SOCK_BROADCAST , valbool ) ; break ; case SO_SNDBUF : val = min_t ( u32 , val , sysctl_wmem_max ) ; set_sndbuf : sk -> sk_userlocks |= SOCK_SNDBUF_LOCK ; <S2SV_StartBug> sk -> sk_sndbuf = max_t ( u32 , val * 2 , SOCK_MIN_SNDBUF ) ; <S2SV_EndBug> sk -> sk_write_space ( sk ) ; break ; case SO_SNDBUFFORCE : if ( ! capable ( CAP_NET_ADMIN ) ) { ret = - EPERM ; break ; } goto set_sndbuf ; case SO_RCVBUF : val = min_t ( u32 , val , sysctl_rmem_max ) ; set_rcvbuf : sk -> sk_userlocks |= SOCK_RCVBUF_LOCK ; <S2SV_StartBug> sk -> sk_rcvbuf = max_t ( u32 , val * 2 , SOCK_MIN_RCVBUF ) ; <S2SV_EndBug> break ; case SO_RCVBUFFORCE : if ( ! capable ( CAP_NET_ADMIN ) ) { ret = - EPERM ; break ; } goto set_rcvbuf ; case SO_KEEPALIVE : # ifdef CONFIG_INET if ( sk -> sk_protocol == IPPROTO_TCP && sk -> sk_type == SOCK_STREAM ) tcp_set_keepalive ( sk , valbool ) ; # endif sock_valbool_flag ( sk , SOCK_KEEPOPEN , valbool ) ; break ; case SO_OOBINLINE : sock_valbool_flag ( sk , SOCK_URGINLINE , valbool ) ; break ; case SO_NO_CHECK : sk -> sk_no_check_tx = valbool ; break ; case SO_PRIORITY : if ( ( val >= 0 && val <= 6 ) || ns_capable ( sock_net ( sk ) -> user_ns , CAP_NET_ADMIN ) ) sk -> sk_priority = val ; else ret = - EPERM ; break ; case SO_LINGER : if ( optlen < sizeof ( ling ) ) { ret = - EINVAL ; break ; } if ( copy_from_user ( & ling , optval , sizeof ( ling ) ) ) { ret = - EFAULT ; break ; } if ( ! ling . l_onoff ) sock_reset_flag ( sk , SOCK_LINGER ) ; else { # if ( BITS_PER_LONG == 32 ) if ( ( unsigned int ) ling . l_linger >= MAX_SCHEDULE_TIMEOUT / HZ ) sk -> sk_lingertime = MAX_SCHEDULE_TIMEOUT ; else # endif sk -> sk_lingertime = ( unsigned int ) ling . l_linger * HZ ; sock_set_flag ( sk , SOCK_LINGER ) ; } break ; case SO_BSDCOMPAT : sock_warn_obsolete_bsdism ( \"setsockopt\" ) ; break ; case SO_PASSCRED : if ( valbool ) set_bit ( SOCK_PASSCRED , & sock -> flags ) ; else clear_bit ( SOCK_PASSCRED , & sock -> flags ) ; break ; case SO_TIMESTAMP : case SO_TIMESTAMPNS : if ( valbool ) { if ( optname == SO_TIMESTAMP ) sock_reset_flag ( sk , SOCK_RCVTSTAMPNS ) ; else sock_set_flag ( sk , SOCK_RCVTSTAMPNS ) ; sock_set_flag ( sk , SOCK_RCVTSTAMP ) ; sock_enable_timestamp ( sk , SOCK_TIMESTAMP ) ; } else { sock_reset_flag ( sk , SOCK_RCVTSTAMP ) ; sock_reset_flag ( sk , SOCK_RCVTSTAMPNS ) ; } break ; case SO_TIMESTAMPING : if ( val & ~ SOF_TIMESTAMPING_MASK ) { ret = - EINVAL ; break ; } if ( val & SOF_TIMESTAMPING_OPT_ID && ! ( sk -> sk_tsflags & SOF_TIMESTAMPING_OPT_ID ) ) { if ( sk -> sk_protocol == IPPROTO_TCP && sk -> sk_type == SOCK_STREAM ) { if ( ( 1 << sk -> sk_state ) & ( TCPF_CLOSE | TCPF_LISTEN ) ) { ret = - EINVAL ; break ; } sk -> sk_tskey = tcp_sk ( sk ) -> snd_una ; } else { sk -> sk_tskey = 0 ; } } sk -> sk_tsflags = val ; if ( val & SOF_TIMESTAMPING_RX_SOFTWARE ) sock_enable_timestamp ( sk , SOCK_TIMESTAMPING_RX_SOFTWARE ) ; else sock_disable_timestamp ( sk , ( 1UL << SOCK_TIMESTAMPING_RX_SOFTWARE ) ) ; break ; case SO_RCVLOWAT : if ( val < 0 ) val = INT_MAX ; sk -> sk_rcvlowat = val ? : 1 ; break ; case SO_RCVTIMEO : ret = sock_set_timeout ( & sk -> sk_rcvtimeo , optval , optlen ) ; break ; case SO_SNDTIMEO : ret = sock_set_timeout ( & sk -> sk_sndtimeo , optval , optlen ) ; break ; case SO_ATTACH_FILTER : ret = - EINVAL ; if ( optlen == sizeof ( struct sock_fprog ) ) { struct sock_fprog fprog ; ret = - EFAULT ; if ( copy_from_user ( & fprog , optval , sizeof ( fprog ) ) ) break ; ret = sk_attach_filter ( & fprog , sk ) ; } break ; case SO_ATTACH_BPF : ret = - EINVAL ; if ( optlen == sizeof ( u32 ) ) { u32 ufd ; ret = - EFAULT ; if ( copy_from_user ( & ufd , optval , sizeof ( ufd ) ) ) break ; ret = sk_attach_bpf ( ufd , sk ) ; } break ; case SO_ATTACH_REUSEPORT_CBPF : ret = - EINVAL ; if ( optlen == sizeof ( struct sock_fprog ) ) { struct sock_fprog fprog ; ret = - EFAULT ; if ( copy_from_user ( & fprog , optval , sizeof ( fprog ) ) ) break ; ret = sk_reuseport_attach_filter ( & fprog , sk ) ; } break ; case SO_ATTACH_REUSEPORT_EBPF : ret = - EINVAL ; if ( optlen == sizeof ( u32 ) ) { u32 ufd ; ret = - EFAULT ; if ( copy_from_user ( & ufd , optval , sizeof ( ufd ) ) ) break ; ret = sk_reuseport_attach_bpf ( ufd , sk ) ; } break ; case SO_DETACH_FILTER : ret = sk_detach_filter ( sk ) ; break ; case SO_LOCK_FILTER : if ( sock_flag ( sk , SOCK_FILTER_LOCKED ) && ! valbool ) ret = - EPERM ; else sock_valbool_flag ( sk , SOCK_FILTER_LOCKED , valbool ) ; break ; case SO_PASSSEC : if ( valbool ) set_bit ( SOCK_PASSSEC , & sock -> flags ) ; else clear_bit ( SOCK_PASSSEC , & sock -> flags ) ; break ; case SO_MARK : if ( ! ns_capable ( sock_net ( sk ) -> user_ns , CAP_NET_ADMIN ) ) ret = - EPERM ; else sk -> sk_mark = val ; break ; case SO_RXQ_OVFL : sock_valbool_flag ( sk , SOCK_RXQ_OVFL , valbool ) ; break ; case SO_WIFI_STATUS : sock_valbool_flag ( sk , SOCK_WIFI_STATUS , valbool ) ; break ; case SO_PEEK_OFF : if ( sock -> ops -> set_peek_off ) ret = sock -> ops -> set_peek_off ( sk , val ) ; else ret = - EOPNOTSUPP ; break ; case SO_NOFCS : sock_valbool_flag ( sk , SOCK_NOFCS , valbool ) ; break ; case SO_SELECT_ERR_QUEUE : sock_valbool_flag ( sk , SOCK_SELECT_ERR_QUEUE , valbool ) ; break ; # ifdef CONFIG_NET_RX_BUSY_POLL case SO_BUSY_POLL : if ( ( val > sk -> sk_ll_usec ) && ! capable ( CAP_NET_ADMIN ) ) ret = - EPERM ; else { if ( val < 0 ) ret = - EINVAL ; else sk -> sk_ll_usec = val ; } break ; # endif case SO_MAX_PACING_RATE : sk -> sk_max_pacing_rate = val ; sk -> sk_pacing_rate = min ( sk -> sk_pacing_rate , sk -> sk_max_pacing_rate ) ; break ; case SO_INCOMING_CPU : sk -> sk_incoming_cpu = val ; break ; case SO_CNX_ADVICE : if ( val == 1 ) dst_negative_advice ( sk ) ; break ; default : ret = - ENOPROTOOPT ; break ; } release_sock ( sk ) ; return ret ; }\n","target":"<S2SV_ModStart> = max_t ( int <S2SV_ModEnd> , val * <S2SV_ModStart> = max_t ( int <S2SV_ModEnd> , val *\n","project_and_commit_id":"torvalds@linux/b98b0bc8c431e3ceb4b26b0dfc8db509518fb290","cve_id":"CVE-2016-9793","original_address":"https://github.com/torvalds/linux/commit/b98b0bc8c431e3ceb4b26b0dfc8db509518fb290","time":"2016-12-28T07:59Z"},
	{"Unnamed: 0":4420,"cwe_id":"CWE-000","source":"CWE-000 int assoc_array_gc ( struct assoc_array * array , const struct assoc_array_ops * ops , bool ( * iterator ) ( void * object , void * iterator_data ) , void * iterator_data ) { struct assoc_array_shortcut * shortcut , * new_s ; struct assoc_array_node * node , * new_n ; struct assoc_array_edit * edit ; struct assoc_array_ptr * cursor , * ptr ; struct assoc_array_ptr * new_root , * new_parent , * * new_ptr_pp ; unsigned long nr_leaves_on_tree ; int keylen , slot , nr_free , next_slot , i ; pr_devel ( \"-->%s()\\\\n\" , __func__ ) ; if ( ! array -> root ) return 0 ; edit = kzalloc ( sizeof ( struct assoc_array_edit ) , GFP_KERNEL ) ; if ( ! edit ) return - ENOMEM ; edit -> array = array ; edit -> ops = ops ; edit -> ops_for_excised_subtree = ops ; edit -> set [ 0 ] . ptr = & array -> root ; edit -> excised_subtree = array -> root ; new_root = new_parent = NULL ; new_ptr_pp = & new_root ; cursor = array -> root ; descend : if ( assoc_array_ptr_is_shortcut ( cursor ) ) { shortcut = assoc_array_ptr_to_shortcut ( cursor ) ; keylen = round_up ( shortcut -> skip_to_level , ASSOC_ARRAY_KEY_CHUNK_SIZE ) ; keylen >>= ASSOC_ARRAY_KEY_CHUNK_SHIFT ; new_s = kmalloc ( sizeof ( struct assoc_array_shortcut ) + keylen * sizeof ( unsigned long ) , GFP_KERNEL ) ; if ( ! new_s ) goto enomem ; pr_devel ( \"dup<S2SV_blank>shortcut<S2SV_blank>%p<S2SV_blank>-><S2SV_blank>%p\\\\n\" , shortcut , new_s ) ; memcpy ( new_s , shortcut , ( sizeof ( struct assoc_array_shortcut ) + keylen * sizeof ( unsigned long ) ) ) ; new_s -> back_pointer = new_parent ; new_s -> parent_slot = shortcut -> parent_slot ; * new_ptr_pp = new_parent = assoc_array_shortcut_to_ptr ( new_s ) ; new_ptr_pp = & new_s -> next_node ; cursor = shortcut -> next_node ; } node = assoc_array_ptr_to_node ( cursor ) ; new_n = kzalloc ( sizeof ( struct assoc_array_node ) , GFP_KERNEL ) ; if ( ! new_n ) goto enomem ; pr_devel ( \"dup<S2SV_blank>node<S2SV_blank>%p<S2SV_blank>-><S2SV_blank>%p\\\\n\" , node , new_n ) ; new_n -> back_pointer = new_parent ; new_n -> parent_slot = node -> parent_slot ; * new_ptr_pp = new_parent = assoc_array_node_to_ptr ( new_n ) ; new_ptr_pp = NULL ; slot = 0 ; continue_node : for ( ; slot < ASSOC_ARRAY_FAN_OUT ; slot ++ ) { ptr = node -> slots [ slot ] ; if ( ! ptr ) continue ; if ( assoc_array_ptr_is_leaf ( ptr ) ) { if ( iterator ( assoc_array_ptr_to_leaf ( ptr ) , iterator_data ) ) new_n -> slots [ slot ] = ptr ; continue ; } new_ptr_pp = & new_n -> slots [ slot ] ; cursor = ptr ; goto descend ; } pr_devel ( \"--<S2SV_blank>compress<S2SV_blank>node<S2SV_blank>%p<S2SV_blank>--\\\\n\" , new_n ) ; new_n -> nr_leaves_on_branch = 0 ; nr_free = 0 ; for ( slot = 0 ; slot < ASSOC_ARRAY_FAN_OUT ; slot ++ ) { ptr = new_n -> slots [ slot ] ; if ( ! ptr ) nr_free ++ ; else if ( assoc_array_ptr_is_leaf ( ptr ) ) new_n -> nr_leaves_on_branch ++ ; } pr_devel ( \"free=%d,<S2SV_blank>leaves=%lu\\\\n\" , nr_free , new_n -> nr_leaves_on_branch ) ; next_slot = 0 ; for ( slot = 0 ; slot < ASSOC_ARRAY_FAN_OUT ; slot ++ ) { struct assoc_array_shortcut * s ; struct assoc_array_node * child ; ptr = new_n -> slots [ slot ] ; if ( ! ptr || assoc_array_ptr_is_leaf ( ptr ) ) continue ; s = NULL ; if ( assoc_array_ptr_is_shortcut ( ptr ) ) { s = assoc_array_ptr_to_shortcut ( ptr ) ; ptr = s -> next_node ; } child = assoc_array_ptr_to_node ( ptr ) ; new_n -> nr_leaves_on_branch += child -> nr_leaves_on_branch ; if ( child -> nr_leaves_on_branch <= nr_free + 1 ) { pr_devel ( \"[%d]<S2SV_blank>fold<S2SV_blank>node<S2SV_blank>%lu/%d<S2SV_blank>[nx<S2SV_blank>%d]\\\\n\" , slot , child -> nr_leaves_on_branch , nr_free + 1 , next_slot ) ; BUG_ON ( s ) ; new_n -> slots [ slot ] = NULL ; nr_free ++ ; if ( slot < next_slot ) next_slot = slot ; for ( i = 0 ; i < ASSOC_ARRAY_FAN_OUT ; i ++ ) { struct assoc_array_ptr * p = child -> slots [ i ] ; if ( ! p ) continue ; BUG_ON ( assoc_array_ptr_is_meta ( p ) ) ; while ( new_n -> slots [ next_slot ] ) next_slot ++ ; BUG_ON ( next_slot >= ASSOC_ARRAY_FAN_OUT ) ; new_n -> slots [ next_slot ++ ] = p ; nr_free -- ; } kfree ( child ) ; } else { pr_devel ( \"[%d]<S2SV_blank>retain<S2SV_blank>node<S2SV_blank>%lu/%d<S2SV_blank>[nx<S2SV_blank>%d]\\\\n\" , slot , child -> nr_leaves_on_branch , nr_free + 1 , next_slot ) ; } } pr_devel ( \"after:<S2SV_blank>%lu\\\\n\" , new_n -> nr_leaves_on_branch ) ; nr_leaves_on_tree = new_n -> nr_leaves_on_branch ; if ( nr_free == ASSOC_ARRAY_FAN_OUT - 1 ) { for ( slot = 0 ; slot < ASSOC_ARRAY_FAN_OUT ; slot ++ ) if ( ( ptr = new_n -> slots [ slot ] ) ) break ; if ( assoc_array_ptr_is_meta ( ptr ) && assoc_array_ptr_is_shortcut ( ptr ) ) { pr_devel ( \"excise<S2SV_blank>node<S2SV_blank>%p<S2SV_blank>with<S2SV_blank>1<S2SV_blank>shortcut\\\\n\" , new_n ) ; new_s = assoc_array_ptr_to_shortcut ( ptr ) ; new_parent = new_n -> back_pointer ; slot = new_n -> parent_slot ; kfree ( new_n ) ; if ( ! new_parent ) { new_s -> back_pointer = NULL ; new_s -> parent_slot = 0 ; new_root = ptr ; goto gc_complete ; } if ( assoc_array_ptr_is_shortcut ( new_parent ) ) { struct assoc_array_shortcut * s = assoc_array_ptr_to_shortcut ( new_parent ) ; pr_devel ( \"excise<S2SV_blank>preceding<S2SV_blank>shortcut\\\\n\" ) ; new_parent = new_s -> back_pointer = s -> back_pointer ; slot = new_s -> parent_slot = s -> parent_slot ; kfree ( s ) ; if ( ! new_parent ) { new_s -> back_pointer = NULL ; new_s -> parent_slot = 0 ; new_root = ptr ; goto gc_complete ; } } new_s -> back_pointer = new_parent ; new_s -> parent_slot = slot ; new_n = assoc_array_ptr_to_node ( new_parent ) ; new_n -> slots [ slot ] = ptr ; goto ascend_old_tree ; } } ptr = new_n -> back_pointer ; if ( ! ptr ) goto gc_complete ; if ( assoc_array_ptr_is_shortcut ( ptr ) ) { new_s = assoc_array_ptr_to_shortcut ( ptr ) ; new_parent = new_s -> back_pointer ; slot = new_s -> parent_slot ; if ( new_n -> nr_leaves_on_branch <= ASSOC_ARRAY_FAN_OUT ) { struct assoc_array_node * n ; pr_devel ( \"excise<S2SV_blank>shortcut\\\\n\" ) ; new_n -> back_pointer = new_parent ; new_n -> parent_slot = slot ; kfree ( new_s ) ; if ( ! new_parent ) { new_root = assoc_array_node_to_ptr ( new_n ) ; goto gc_complete ; } n = assoc_array_ptr_to_node ( new_parent ) ; n -> slots [ slot ] = assoc_array_node_to_ptr ( new_n ) ; } } else { new_parent = ptr ; } new_n = assoc_array_ptr_to_node ( new_parent ) ; ascend_old_tree : ptr = node -> back_pointer ; if ( assoc_array_ptr_is_shortcut ( ptr ) ) { shortcut = assoc_array_ptr_to_shortcut ( ptr ) ; slot = shortcut -> parent_slot ; cursor = shortcut -> back_pointer ; <S2SV_StartBug> } else { <S2SV_EndBug> slot = node -> parent_slot ; cursor = ptr ; } <S2SV_StartBug> BUG_ON ( ! ptr ) ; <S2SV_EndBug> node = assoc_array_ptr_to_node ( cursor ) ; slot ++ ; goto continue_node ; gc_complete : edit -> set [ 0 ] . to = new_root ; assoc_array_apply_edit ( edit ) ; array -> nr_leaves_on_tree = nr_leaves_on_tree ; return 0 ; enomem : pr_devel ( \"enomem\\\\n\" ) ; assoc_array_destroy_subtree ( new_root , edit -> ops ) ; kfree ( edit ) ; return - ENOMEM ; }\n","target":"<S2SV_ModStart> -> back_pointer ; if ( ! cursor ) goto gc_complete ; <S2SV_ModStart> BUG_ON ( ! cursor <S2SV_ModEnd> ) ; node\n","project_and_commit_id":"torvalds@linux/95389b08d93d5c06ec63ab49bd732b0069b7c35e","cve_id":"CVE-2014-3631","original_address":"https://github.com/torvalds/linux/commit/95389b08d93d5c06ec63ab49bd732b0069b7c35e","time":"2014-09-28T10:55Z"},
	{"Unnamed: 0":6664,"cwe_id":"CWE-264","source":"CWE-264 static int flakey_ioctl ( struct dm_target * ti , unsigned int cmd , unsigned long arg ) { struct flakey_c * fc = ti -> private ; <S2SV_StartBug> return __blkdev_driver_ioctl ( fc -> dev -> bdev , fc -> dev -> mode , cmd , arg ) ; <S2SV_EndBug> }\n","target":"<S2SV_ModStart> -> private ; struct dm_dev * dev = fc -> dev ; int r = 0 ; if <S2SV_ModEnd> ( fc -> <S2SV_ModStart> ( fc -> start || ti -> len != i_size_read ( dev -> bdev -> bd_inode ) >> SECTOR_SHIFT ) r = scsi_verify_blk_ioctl ( NULL , cmd ) ; return r ? : __blkdev_driver_ioctl ( <S2SV_ModStart> -> bdev , <S2SV_ModEnd> dev -> mode\n","project_and_commit_id":"torvalds@linux/ec8013beddd717d1740cfefb1a9b900deef85462","cve_id":"CVE-2011-4127","original_address":"https://github.com/torvalds/linux/commit/ec8013beddd717d1740cfefb1a9b900deef85462","time":"2012-07-03T16:40Z"},
	{"Unnamed: 0":6424,"cwe_id":"CWE-125","source":"CWE-125 static const struct usb_cdc_union_desc * ims_pcu_get_cdc_union_desc ( struct usb_interface * intf ) { const void * buf = intf -> altsetting -> extra ; size_t buflen = intf -> altsetting -> extralen ; struct usb_cdc_union_desc * union_desc ; if ( ! buf ) { dev_err ( & intf -> dev , \"Missing<S2SV_blank>descriptor<S2SV_blank>data\\\\n\" ) ; return NULL ; } if ( ! buflen ) { dev_err ( & intf -> dev , \"Zero<S2SV_blank>length<S2SV_blank>descriptor\\\\n\" ) ; return NULL ; } <S2SV_StartBug> while ( buflen > 0 ) { <S2SV_EndBug> union_desc = ( struct usb_cdc_union_desc * ) buf ; if ( union_desc -> bDescriptorType == USB_DT_CS_INTERFACE && union_desc -> bDescriptorSubType == USB_CDC_UNION_TYPE ) { dev_dbg ( & intf -> dev , \"Found<S2SV_blank>union<S2SV_blank>header\\\\n\" ) ; <S2SV_StartBug> return union_desc ; <S2SV_EndBug> } buflen -= union_desc -> bLength ; buf += union_desc -> bLength ; } dev_err ( & intf -> dev , \"Missing<S2SV_blank>CDC<S2SV_blank>union<S2SV_blank>descriptor\\\\n\" ) ; return NULL ; }\n","target":"<S2SV_ModStart> while ( buflen >= sizeof ( * union_desc ) ) { union_desc = ( struct usb_cdc_union_desc * ) buf ; if ( union_desc -> bLength > buflen ) { dev_err ( & intf -> dev , \"Too<S2SV_blank>large<S2SV_blank>descriptor\\\\n\" ) ; return NULL ; } <S2SV_ModEnd> if ( union_desc <S2SV_ModStart> \"Found<S2SV_blank>union<S2SV_blank>header\\\\n\" ) ; if ( union_desc -> bLength >= sizeof ( * union_desc ) ) return union_desc ; dev_err ( & intf -> dev , \"Union<S2SV_blank>descriptor<S2SV_blank>to<S2SV_blank>short<S2SV_blank>(%d<S2SV_blank>vs<S2SV_blank>%zd\\\\n)\" , union_desc -> bLength , sizeof ( * union_desc ) ) ; return NULL <S2SV_ModEnd> ; } buflen\n","project_and_commit_id":"torvalds@linux/ea04efee7635c9120d015dcdeeeb6988130cb67a","cve_id":"CVE-2017-16645","original_address":"https://github.com/torvalds/linux/commit/ea04efee7635c9120d015dcdeeeb6988130cb67a","time":"2017-11-07T23:29Z"},
	{"Unnamed: 0":2278,"cwe_id":"CWE-119","source":"CWE-119 int main ( int argc , char * * argv ) { int frame_cnt = 0 ; FILE * outfile = NULL ; vpx_codec_ctx_t codec ; const VpxInterface * decoder = NULL ; VpxVideoReader * reader = NULL ; const VpxVideoInfo * info = NULL ; int n = 0 ; int m = 0 ; int is_range = 0 ; char * nptr = NULL ; exec_name = argv [ 0 ] ; if ( argc != 4 ) die ( \"Invalid<S2SV_blank>number<S2SV_blank>of<S2SV_blank>arguments.\" ) ; reader = vpx_video_reader_open ( argv [ 1 ] ) ; if ( ! reader ) die ( \"Failed<S2SV_blank>to<S2SV_blank>open<S2SV_blank>%s<S2SV_blank>for<S2SV_blank>reading.\" , argv [ 1 ] ) ; if ( ! ( outfile = fopen ( argv [ 2 ] , \"wb\" ) ) ) die ( \"Failed<S2SV_blank>to<S2SV_blank>open<S2SV_blank>%s<S2SV_blank>for<S2SV_blank>writing.\" , argv [ 2 ] ) ; n = strtol ( argv [ 3 ] , & nptr , 0 ) ; m = strtol ( nptr + 1 , NULL , 0 ) ; is_range = ( * nptr == '-' ) ; if ( ! n || ! m || ( * nptr != '-' && * nptr != '/' ) ) die ( \"Couldn\\'t<S2SV_blank>parse<S2SV_blank>pattern<S2SV_blank>%s.\\\\n\" , argv [ 3 ] ) ; info = vpx_video_reader_get_info ( reader ) ; decoder = get_vpx_decoder_by_fourcc ( info -> codec_fourcc ) ; if ( ! decoder ) die ( \"Unknown<S2SV_blank>input<S2SV_blank>codec.\" ) ; <S2SV_StartBug> printf ( \"Using<S2SV_blank>%s\\\\n\" , vpx_codec_iface_name ( decoder -> interface ( ) ) ) ; <S2SV_EndBug> <S2SV_StartBug> if ( vpx_codec_dec_init ( & codec , decoder -> interface ( ) , NULL , 0 ) ) <S2SV_EndBug> die_codec ( & codec , \"Failed<S2SV_blank>to<S2SV_blank>initialize<S2SV_blank>decoder.\" ) ; while ( vpx_video_reader_read_frame ( reader ) ) { vpx_codec_iter_t iter = NULL ; vpx_image_t * img = NULL ; size_t frame_size = 0 ; int skip ; const unsigned char * frame = vpx_video_reader_get_frame ( reader , & frame_size ) ; if ( vpx_codec_decode ( & codec , frame , ( unsigned int ) frame_size , NULL , 0 ) ) die_codec ( & codec , \"Failed<S2SV_blank>to<S2SV_blank>decode<S2SV_blank>frame.\" ) ; ++ frame_cnt ; skip = ( is_range && frame_cnt >= n && frame_cnt <= m ) || ( ! is_range && m - ( frame_cnt - 1 ) % m <= n ) ; if ( ! skip ) { putc ( '.' , stdout ) ; while ( ( img = vpx_codec_get_frame ( & codec , & iter ) ) != NULL ) vpx_img_write ( img , outfile ) ; } else { putc ( 'X' , stdout ) ; } fflush ( stdout ) ; } printf ( \"Processed<S2SV_blank>%d<S2SV_blank>frames.\\\\n\" , frame_cnt ) ; if ( vpx_codec_destroy ( & codec ) ) die_codec ( & codec , \"Failed<S2SV_blank>to<S2SV_blank>destroy<S2SV_blank>codec.\" ) ; printf ( \"Play:<S2SV_blank>ffplay<S2SV_blank>-f<S2SV_blank>rawvideo<S2SV_blank>-pix_fmt<S2SV_blank>yuv420p<S2SV_blank>-s<S2SV_blank>%dx%d<S2SV_blank>%s\\\\n\" , info -> frame_width , info -> frame_height , argv [ 2 ] ) ; vpx_video_reader_close ( reader ) ; fclose ( outfile ) ; return EXIT_SUCCESS ; }\n","target":"<S2SV_ModStart> ( decoder -> codec_interface <S2SV_ModEnd> ( ) ) <S2SV_ModStart> , decoder -> codec_interface <S2SV_ModEnd> ( ) ,\n","project_and_commit_id":"external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426","cve_id":"CVE-2016-1621","original_address":"https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426","time":"2016-03-12T21:59Z"},
	{"Unnamed: 0":2740,"cwe_id":"CWE-119","source":"CWE-119 void vp8_set_speed_features ( VP8_COMP * cpi ) { SPEED_FEATURES * sf = & cpi -> sf ; int Mode = cpi -> compressor_speed ; int Speed = cpi -> Speed ; int i ; VP8_COMMON * cm = & cpi -> common ; int last_improved_quant = sf -> improved_quant ; int ref_frames ; for ( i = 0 ; i < MAX_MODES ; i ++ ) { cpi -> mode_check_freq [ i ] = 0 ; } cpi -> mb . mbs_tested_so_far = 0 ; <S2SV_StartBug> sf -> RD = 1 ; <S2SV_EndBug> sf -> search_method = NSTEP ; sf -> improved_quant = 1 ; sf -> improved_dct = 1 ; sf -> auto_filter = 1 ; sf -> recode_loop = 1 ; sf -> quarter_pixel_search = 1 ; sf -> half_pixel_search = 1 ; sf -> iterative_sub_pixel = 1 ; sf -> optimize_coefficients = 1 ; sf -> use_fastquant_for_pick = 0 ; sf -> no_skip_block4x4_search = 1 ; sf -> first_step = 0 ; sf -> max_step_search_steps = MAX_MVSEARCH_STEPS ; sf -> improved_mv_pred = 1 ; for ( i = 0 ; i < MAX_MODES ; i ++ ) sf -> thresh_mult [ i ] = 0 ; ref_frames = 1 ; if ( cpi -> ref_frame_flags & VP8_LAST_FRAME ) ref_frames ++ ; if ( cpi -> ref_frame_flags & VP8_GOLD_FRAME ) ref_frames ++ ; if ( cpi -> ref_frame_flags & VP8_ALTR_FRAME ) ref_frames ++ ; if ( Mode == 0 ) Speed = 0 ; else if ( Mode == 2 ) Speed = RT ( Speed ) ; else { if ( Speed > 5 ) Speed = 5 ; Speed = GOOD ( Speed ) ; } sf -> thresh_mult [ THR_ZERO1 ] = sf -> thresh_mult [ THR_NEAREST1 ] = sf -> thresh_mult [ THR_NEAR1 ] = sf -> thresh_mult [ THR_DC ] = 0 ; sf -> thresh_mult [ THR_ZERO2 ] = sf -> thresh_mult [ THR_ZERO3 ] = sf -> thresh_mult [ THR_NEAREST2 ] = sf -> thresh_mult [ THR_NEAREST3 ] = sf -> thresh_mult [ THR_NEAR2 ] = sf -> thresh_mult [ THR_NEAR3 ] = speed_map ( Speed , thresh_mult_map_znn ) ; sf -> thresh_mult [ THR_V_PRED ] = sf -> thresh_mult [ THR_H_PRED ] = speed_map ( Speed , thresh_mult_map_vhpred ) ; sf -> thresh_mult [ THR_B_PRED ] = speed_map ( Speed , thresh_mult_map_bpred ) ; sf -> thresh_mult [ THR_TM ] = speed_map ( Speed , thresh_mult_map_tm ) ; sf -> thresh_mult [ THR_NEW1 ] = speed_map ( Speed , thresh_mult_map_new1 ) ; sf -> thresh_mult [ THR_NEW2 ] = sf -> thresh_mult [ THR_NEW3 ] = speed_map ( Speed , thresh_mult_map_new2 ) ; sf -> thresh_mult [ THR_SPLIT1 ] = speed_map ( Speed , thresh_mult_map_split1 ) ; sf -> thresh_mult [ THR_SPLIT2 ] = <S2SV_StartBug> sf -> thresh_mult [ THR_SPLIT3 ] = speed_map ( Speed , thresh_mult_map_split2 ) ; <S2SV_EndBug> cpi -> mode_check_freq [ THR_ZERO1 ] = cpi -> mode_check_freq [ THR_NEAREST1 ] = cpi -> mode_check_freq [ THR_NEAR1 ] = cpi -> mode_check_freq [ THR_TM ] = cpi -> mode_check_freq [ THR_DC ] = 0 ; cpi -> mode_check_freq [ THR_ZERO2 ] = cpi -> mode_check_freq [ THR_ZERO3 ] = cpi -> mode_check_freq [ THR_NEAREST2 ] = cpi -> mode_check_freq [ THR_NEAREST3 ] = speed_map ( Speed , mode_check_freq_map_zn2 ) ; cpi -> mode_check_freq [ THR_NEAR2 ] = cpi -> mode_check_freq [ THR_NEAR3 ] = speed_map ( Speed , mode_check_freq_map_near2 ) ; cpi -> mode_check_freq [ THR_V_PRED ] = cpi -> mode_check_freq [ THR_H_PRED ] = cpi -> mode_check_freq [ THR_B_PRED ] = speed_map ( Speed , mode_check_freq_map_vhbpred ) ; cpi -> mode_check_freq [ THR_NEW1 ] = speed_map ( Speed , mode_check_freq_map_new1 ) ; cpi -> mode_check_freq [ THR_NEW2 ] = cpi -> mode_check_freq [ THR_NEW3 ] = speed_map ( Speed , mode_check_freq_map_new2 ) ; cpi -> mode_check_freq [ THR_SPLIT1 ] = speed_map ( Speed , mode_check_freq_map_split1 ) ; cpi -> mode_check_freq [ THR_SPLIT2 ] = cpi -> mode_check_freq [ THR_SPLIT3 ] = speed_map ( Speed , mode_check_freq_map_split2 ) ; Speed = cpi -> Speed ; switch ( Mode ) { # if ! ( CONFIG_REALTIME_ONLY ) case 0 : sf -> first_step = 0 ; sf -> max_step_search_steps = MAX_MVSEARCH_STEPS ; break ; case 1 : case 3 : if ( Speed > 0 ) { sf -> optimize_coefficients = 0 ; sf -> use_fastquant_for_pick = 1 ; sf -> no_skip_block4x4_search = 0 ; sf -> first_step = 1 ; } if ( Speed > 2 ) { sf -> improved_quant = 0 ; sf -> improved_dct = 0 ; sf -> recode_loop = 2 ; } if ( Speed > 3 ) { sf -> auto_filter = 1 ; sf -> recode_loop = 0 ; sf -> RD = 0 ; } if ( Speed > 4 ) { sf -> auto_filter = 0 ; } break ; # endif case 2 : sf -> optimize_coefficients = 0 ; sf -> recode_loop = 0 ; sf -> auto_filter = 1 ; sf -> iterative_sub_pixel = 1 ; sf -> search_method = NSTEP ; if ( Speed > 0 ) { sf -> improved_quant = 0 ; sf -> improved_dct = 0 ; sf -> use_fastquant_for_pick = 1 ; sf -> no_skip_block4x4_search = 0 ; sf -> first_step = 1 ; } if ( Speed > 2 ) sf -> auto_filter = 0 ; if ( Speed > 3 ) { sf -> RD = 0 ; sf -> auto_filter = 1 ; } if ( Speed > 4 ) { sf -> auto_filter = 0 ; sf -> search_method = HEX ; sf -> iterative_sub_pixel = 0 ; } if ( Speed > 6 ) { unsigned int sum = 0 ; unsigned int total_mbs = cm -> MBs ; int thresh ; unsigned int total_skip ; int min = 2000 ; if ( cpi -> oxcf . encode_breakout > 2000 ) min = cpi -> oxcf . encode_breakout ; min >>= 7 ; for ( i = 0 ; i < min ; i ++ ) { sum += cpi -> mb . error_bins [ i ] ; } total_skip = sum ; sum = 0 ; for ( ; i < 1024 ; i ++ ) { sum += cpi -> mb . error_bins [ i ] ; if ( 10 * sum >= ( unsigned int ) ( cpi -> Speed - 6 ) * ( total_mbs - total_skip ) ) break ; } i -- ; thresh = ( i << 7 ) ; if ( thresh < 2000 ) thresh = 2000 ; if ( ref_frames > 1 ) { sf -> thresh_mult [ THR_NEW1 ] = thresh ; sf -> thresh_mult [ THR_NEAREST1 ] = thresh >> 1 ; sf -> thresh_mult [ THR_NEAR1 ] = thresh >> 1 ; } if ( ref_frames > 2 ) { sf -> thresh_mult [ THR_NEW2 ] = thresh << 1 ; sf -> thresh_mult [ THR_NEAREST2 ] = thresh ; sf -> thresh_mult [ THR_NEAR2 ] = thresh ; } if ( ref_frames > 3 ) { sf -> thresh_mult [ THR_NEW3 ] = thresh << 1 ; sf -> thresh_mult [ THR_NEAREST3 ] = thresh ; sf -> thresh_mult [ THR_NEAR3 ] = thresh ; } sf -> improved_mv_pred = 0 ; } if ( Speed > 8 ) sf -> quarter_pixel_search = 0 ; if ( cm -> version == 0 ) { cm -> filter_type = NORMAL_LOOPFILTER ; if ( Speed >= 14 ) cm -> filter_type = SIMPLE_LOOPFILTER ; } else { cm -> filter_type = SIMPLE_LOOPFILTER ; } if ( Speed >= 15 ) sf -> half_pixel_search = 0 ; <S2SV_StartBug> vpx_memset ( cpi -> mb . error_bins , 0 , sizeof ( cpi -> mb . error_bins ) ) ; <S2SV_EndBug> } ; if ( cpi -> pass == 1 ) { sf -> improved_quant = 0 ; sf -> optimize_coefficients = 0 ; sf -> improved_dct = 0 ; } if ( cpi -> sf . search_method == NSTEP ) { vp8_init3smotion_compensation ( & cpi -> mb , cm -> yv12_fb [ cm -> lst_fb_idx ] . y_stride ) ; } else if ( cpi -> sf . search_method == DIAMOND ) { vp8_init_dsmotion_compensation ( & cpi -> mb , cm -> yv12_fb [ cm -> lst_fb_idx ] . y_stride ) ; } if ( cpi -> sf . improved_dct ) { cpi -> mb . short_fdct8x4 = vp8_short_fdct8x4 ; cpi -> mb . short_fdct4x4 = vp8_short_fdct4x4 ; } else { cpi -> mb . short_fdct8x4 = vp8_short_fdct8x4 ; cpi -> mb . short_fdct4x4 = vp8_short_fdct4x4 ; } cpi -> mb . short_walsh4x4 = vp8_short_walsh4x4 ; if ( cpi -> sf . improved_quant ) { cpi -> mb . quantize_b = vp8_regular_quantize_b ; <S2SV_StartBug> cpi -> mb . quantize_b_pair = vp8_regular_quantize_b_pair ; <S2SV_EndBug> } else { <S2SV_StartBug> cpi -> mb . quantize_b = vp8_fast_quantize_b ; <S2SV_EndBug> cpi -> mb . quantize_b_pair = vp8_fast_quantize_b_pair ; } if ( cpi -> sf . improved_quant != last_improved_quant ) vp8cx_init_quantizer ( cpi ) ; if ( cpi -> sf . iterative_sub_pixel == 1 ) { cpi -> find_fractional_mv_step = vp8_find_best_sub_pixel_step_iteratively ; } else if ( cpi -> sf . quarter_pixel_search ) { cpi -> find_fractional_mv_step = vp8_find_best_sub_pixel_step ; } else if ( cpi -> sf . half_pixel_search ) { cpi -> find_fractional_mv_step = vp8_find_best_half_pixel_step ; } else { cpi -> find_fractional_mv_step = vp8_skip_fractional_mv_step ; } if ( cpi -> sf . optimize_coefficients == 1 && cpi -> pass != 1 ) cpi -> mb . optimize = 1 ; else cpi -> mb . optimize = 0 ; if ( cpi -> common . full_pixel ) cpi -> find_fractional_mv_step = vp8_skip_fractional_mv_step ; # ifdef SPEEDSTATS frames_at_speed [ cpi -> Speed ] ++ ; # endif }\n","target":"<S2SV_ModStart> = 0 ; cpi -> mb . mbs_zero_last_dot_suppress = 0 ; <S2SV_ModStart> thresh_mult_map_split2 ) ; if ( ( cpi -> Speed <= 6 ) && ( cpi -> oxcf . number_of_layers > 1 ) && ( cpi -> ref_frame_flags & VP8_LAST_FRAME ) && ( cpi -> ref_frame_flags & VP8_GOLD_FRAME ) ) { if ( cpi -> closest_reference_frame == GOLDEN_FRAME ) { sf -> thresh_mult [ THR_ZERO2 ] = sf -> thresh_mult [ THR_ZERO2 ] >> 3 ; sf -> thresh_mult [ THR_NEAREST2 ] = sf -> thresh_mult [ THR_NEAREST2 ] >> 3 ; sf -> thresh_mult [ THR_NEAR2 ] = sf -> thresh_mult [ THR_NEAR2 ] >> 3 ; } else { sf -> thresh_mult [ THR_ZERO2 ] = sf -> thresh_mult [ THR_ZERO2 ] >> 1 ; sf -> thresh_mult [ THR_NEAREST2 ] = sf -> thresh_mult [ THR_NEAREST2 ] >> 1 ; sf -> thresh_mult [ THR_NEAR2 ] = sf -> thresh_mult [ THR_NEAR2 ] >> 1 ; } } <S2SV_ModStart> = 0 ; memset <S2SV_ModEnd> ( cpi -> <S2SV_ModStart> = vp8_regular_quantize_b ; } else { <S2SV_ModStart> -> mb . <S2SV_ModEnd> quantize_b = vp8_fast_quantize_b <S2SV_ModStart> quantize_b = vp8_fast_quantize_b <S2SV_ModEnd> ; } if\n","project_and_commit_id":"external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426","cve_id":"CVE-2016-1621","original_address":"https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426","time":"2016-03-12T21:59Z"},
	{"Unnamed: 0":690,"cwe_id":"CWE-254","source":"CWE-254 static int prepend_path ( const struct path * path , const struct path * root , char * * buffer , int * buflen ) { struct dentry * dentry ; struct vfsmount * vfsmnt ; struct mount * mnt ; int error = 0 ; unsigned seq , m_seq = 0 ; char * bptr ; int blen ; rcu_read_lock ( ) ; restart_mnt : read_seqbegin_or_lock ( & mount_lock , & m_seq ) ; seq = 0 ; rcu_read_lock ( ) ; restart : bptr = * buffer ; blen = * buflen ; error = 0 ; dentry = path -> dentry ; vfsmnt = path -> mnt ; mnt = real_mount ( vfsmnt ) ; read_seqbegin_or_lock ( & rename_lock , & seq ) ; while ( dentry != root -> dentry || vfsmnt != root -> mnt ) { struct dentry * parent ; if ( dentry == vfsmnt -> mnt_root || IS_ROOT ( dentry ) ) { <S2SV_StartBug> struct mount * parent = ACCESS_ONCE ( mnt -> mnt_parent ) ; <S2SV_EndBug> if ( mnt != parent ) { dentry = ACCESS_ONCE ( mnt -> mnt_mountpoint ) ; mnt = parent ; vfsmnt = & mnt -> mnt ; continue ; } if ( ! error ) error = is_mounted ( vfsmnt ) ? 1 : 2 ; break ; } parent = dentry -> d_parent ; prefetch ( parent ) ; error = prepend_name ( & bptr , & blen , & dentry -> d_name ) ; if ( error ) break ; dentry = parent ; } if ( ! ( seq & 1 ) ) rcu_read_unlock ( ) ; if ( need_seqretry ( & rename_lock , seq ) ) { seq = 1 ; goto restart ; } done_seqretry ( & rename_lock , seq ) ; if ( ! ( m_seq & 1 ) ) rcu_read_unlock ( ) ; if ( need_seqretry ( & mount_lock , m_seq ) ) { m_seq = 1 ; goto restart_mnt ; } done_seqretry ( & mount_lock , m_seq ) ; if ( error >= 0 && bptr == * buffer ) { if ( -- blen < 0 ) error = - ENAMETOOLONG ; else * -- bptr = '/' ; } * buffer = bptr ; * buflen = blen ; return error ; }\n","target":"<S2SV_ModStart> mnt_parent ) ; if ( dentry != vfsmnt -> mnt_root ) { bptr = * buffer ; blen = * buflen ; error = 3 ; break ; }\n","project_and_commit_id":"torvalds@linux/cde93be45a8a90d8c264c776fab63487b5038a65","cve_id":"CVE-2015-2925","original_address":"https://github.com/torvalds/linux/commit/cde93be45a8a90d8c264c776fab63487b5038a65","time":"2015-11-16T11:59Z"},
	{"Unnamed: 0":3436,"cwe_id":"CWE-476","source":"CWE-476 int rds_cmsg_atomic ( struct rds_sock * rs , struct rds_message * rm , struct cmsghdr * cmsg ) { struct page * page = NULL ; struct rds_atomic_args * args ; int ret = 0 ; if ( cmsg -> cmsg_len < CMSG_LEN ( sizeof ( struct rds_atomic_args ) ) || rm -> atomic . op_active ) return - EINVAL ; args = CMSG_DATA ( cmsg ) ; switch ( cmsg -> cmsg_type ) { case RDS_CMSG_ATOMIC_FADD : rm -> atomic . op_type = RDS_ATOMIC_TYPE_FADD ; rm -> atomic . op_m_fadd . add = args -> fadd . add ; rm -> atomic . op_m_fadd . nocarry_mask = 0 ; break ; case RDS_CMSG_MASKED_ATOMIC_FADD : rm -> atomic . op_type = RDS_ATOMIC_TYPE_FADD ; rm -> atomic . op_m_fadd . add = args -> m_fadd . add ; rm -> atomic . op_m_fadd . nocarry_mask = args -> m_fadd . nocarry_mask ; break ; case RDS_CMSG_ATOMIC_CSWP : rm -> atomic . op_type = RDS_ATOMIC_TYPE_CSWP ; rm -> atomic . op_m_cswp . compare = args -> cswp . compare ; rm -> atomic . op_m_cswp . swap = args -> cswp . swap ; rm -> atomic . op_m_cswp . compare_mask = ~ 0 ; rm -> atomic . op_m_cswp . swap_mask = ~ 0 ; break ; case RDS_CMSG_MASKED_ATOMIC_CSWP : rm -> atomic . op_type = RDS_ATOMIC_TYPE_CSWP ; rm -> atomic . op_m_cswp . compare = args -> m_cswp . compare ; rm -> atomic . op_m_cswp . swap = args -> m_cswp . swap ; rm -> atomic . op_m_cswp . compare_mask = args -> m_cswp . compare_mask ; rm -> atomic . op_m_cswp . swap_mask = args -> m_cswp . swap_mask ; break ; default : BUG ( ) ; } rm -> atomic . op_notify = ! ! ( args -> flags & RDS_RDMA_NOTIFY_ME ) ; rm -> atomic . op_silent = ! ! ( args -> flags & RDS_RDMA_SILENT ) ; rm -> atomic . op_active = 1 ; rm -> atomic . op_recverr = rs -> rs_recverr ; rm -> atomic . op_sg = rds_message_alloc_sgs ( rm , 1 ) ; if ( ! rm -> atomic . op_sg ) { ret = - ENOMEM ; goto err ; } if ( args -> local_addr & 0x7 ) { ret = - EFAULT ; goto err ; } ret = rds_pin_pages ( args -> local_addr , 1 , & page , 1 ) ; if ( ret != 1 ) goto err ; ret = 0 ; sg_set_page ( rm -> atomic . op_sg , page , 8 , offset_in_page ( args -> local_addr ) ) ; if ( rm -> atomic . op_notify || rm -> atomic . op_recverr ) { rm -> atomic . op_notifier = kmalloc ( sizeof ( * rm -> atomic . op_notifier ) , GFP_KERNEL ) ; if ( ! rm -> atomic . op_notifier ) { ret = - ENOMEM ; goto err ; } rm -> atomic . op_notifier -> n_user_token = args -> user_token ; rm -> atomic . op_notifier -> n_status = RDS_RDMA_SUCCESS ; } rm -> atomic . op_rkey = rds_rdma_cookie_key ( args -> cookie ) ; rm -> atomic . op_remote_addr = args -> remote_addr + rds_rdma_cookie_offset ( args -> cookie ) ; return ret ; err : if ( page ) put_page ( page ) ; <S2SV_StartBug> kfree ( rm -> atomic . op_notifier ) ; <S2SV_EndBug> return ret ; }\n","target":"<S2SV_ModStart> page ) ; rm -> atomic . op_active = 0 ;\n","project_and_commit_id":"torvalds@linux/7d11f77f84b27cef452cee332f4e469503084737","cve_id":"CVE-2018-5333","original_address":"https://github.com/torvalds/linux/commit/7d11f77f84b27cef452cee332f4e469503084737","time":"2018-01-11T07:29Z"},
	{"Unnamed: 0":4426,"cwe_id":"CWE-000","source":"CWE-000 static int ext4_show_options ( struct seq_file * seq , struct vfsmount * vfs ) { int def_errors ; unsigned long def_mount_opts ; struct super_block * sb = vfs -> mnt_sb ; struct ext4_sb_info * sbi = EXT4_SB ( sb ) ; struct ext4_super_block * es = sbi -> s_es ; def_mount_opts = le32_to_cpu ( es -> s_default_mount_opts ) ; def_errors = le16_to_cpu ( es -> s_errors ) ; if ( sbi -> s_sb_block != 1 ) seq_printf ( seq , \",sb=%llu\" , sbi -> s_sb_block ) ; if ( test_opt ( sb , MINIX_DF ) ) seq_puts ( seq , \",minixdf\" ) ; if ( test_opt ( sb , GRPID ) && ! ( def_mount_opts & EXT4_DEFM_BSDGROUPS ) ) seq_puts ( seq , \",grpid\" ) ; if ( ! test_opt ( sb , GRPID ) && ( def_mount_opts & EXT4_DEFM_BSDGROUPS ) ) seq_puts ( seq , \",nogrpid\" ) ; if ( sbi -> s_resuid != EXT4_DEF_RESUID || le16_to_cpu ( es -> s_def_resuid ) != EXT4_DEF_RESUID ) { seq_printf ( seq , \",resuid=%u\" , sbi -> s_resuid ) ; } if ( sbi -> s_resgid != EXT4_DEF_RESGID || le16_to_cpu ( es -> s_def_resgid ) != EXT4_DEF_RESGID ) { seq_printf ( seq , \",resgid=%u\" , sbi -> s_resgid ) ; } if ( test_opt ( sb , ERRORS_RO ) ) { if ( def_errors == EXT4_ERRORS_PANIC || def_errors == EXT4_ERRORS_CONTINUE ) { seq_puts ( seq , \",errors=remount-ro\" ) ; } } if ( test_opt ( sb , ERRORS_CONT ) && def_errors != EXT4_ERRORS_CONTINUE ) seq_puts ( seq , \",errors=continue\" ) ; if ( test_opt ( sb , ERRORS_PANIC ) && def_errors != EXT4_ERRORS_PANIC ) seq_puts ( seq , \",errors=panic\" ) ; if ( test_opt ( sb , NO_UID32 ) && ! ( def_mount_opts & EXT4_DEFM_UID16 ) ) seq_puts ( seq , \",nouid32\" ) ; if ( test_opt ( sb , DEBUG ) && ! ( def_mount_opts & EXT4_DEFM_DEBUG ) ) seq_puts ( seq , \",debug\" ) ; if ( test_opt ( sb , OLDALLOC ) ) seq_puts ( seq , \",oldalloc\" ) ; # ifdef CONFIG_EXT4_FS_XATTR if ( test_opt ( sb , XATTR_USER ) && ! ( def_mount_opts & EXT4_DEFM_XATTR_USER ) ) seq_puts ( seq , \",user_xattr\" ) ; if ( ! test_opt ( sb , XATTR_USER ) && ( def_mount_opts & EXT4_DEFM_XATTR_USER ) ) { seq_puts ( seq , \",nouser_xattr\" ) ; } # endif # ifdef CONFIG_EXT4_FS_POSIX_ACL if ( test_opt ( sb , POSIX_ACL ) && ! ( def_mount_opts & EXT4_DEFM_ACL ) ) seq_puts ( seq , \",acl\" ) ; if ( ! test_opt ( sb , POSIX_ACL ) && ( def_mount_opts & EXT4_DEFM_ACL ) ) seq_puts ( seq , \",noacl\" ) ; # endif if ( sbi -> s_commit_interval != JBD2_DEFAULT_MAX_COMMIT_AGE * HZ ) { seq_printf ( seq , \",commit=%u\" , ( unsigned ) ( sbi -> s_commit_interval / HZ ) ) ; } if ( sbi -> s_min_batch_time != EXT4_DEF_MIN_BATCH_TIME ) { seq_printf ( seq , \",min_batch_time=%u\" , ( unsigned ) sbi -> s_min_batch_time ) ; } if ( sbi -> s_max_batch_time != EXT4_DEF_MAX_BATCH_TIME ) { seq_printf ( seq , \",max_batch_time=%u\" , ( unsigned ) sbi -> s_min_batch_time ) ; } seq_puts ( seq , \",barrier=\" ) ; seq_puts ( seq , test_opt ( sb , BARRIER ) ? \"1\" : \"0\" ) ; if ( test_opt ( sb , JOURNAL_ASYNC_COMMIT ) ) seq_puts ( seq , \",journal_async_commit\" ) ; if ( test_opt ( sb , NOBH ) ) seq_puts ( seq , \",nobh\" ) ; if ( test_opt ( sb , I_VERSION ) ) seq_puts ( seq , \",i_version\" ) ; if ( ! test_opt ( sb , DELALLOC ) ) seq_puts ( seq , \",nodelalloc\" ) ; if ( sbi -> s_stripe ) seq_printf ( seq , \",stripe=%lu\" , sbi -> s_stripe ) ; if ( test_opt ( sb , DATA_FLAGS ) == EXT4_MOUNT_JOURNAL_DATA ) seq_puts ( seq , \",data=journal\" ) ; else if ( test_opt ( sb , DATA_FLAGS ) == EXT4_MOUNT_ORDERED_DATA ) seq_puts ( seq , \",data=ordered\" ) ; else if ( test_opt ( sb , DATA_FLAGS ) == EXT4_MOUNT_WRITEBACK_DATA ) seq_puts ( seq , \",data=writeback\" ) ; if ( sbi -> s_inode_readahead_blks != EXT4_DEF_INODE_READAHEAD_BLKS ) seq_printf ( seq , \",inode_readahead_blks=%u\" , sbi -> s_inode_readahead_blks ) ; if ( test_opt ( sb , DATA_ERR_ABORT ) ) seq_puts ( seq , \",data_err=abort\" ) ; if ( test_opt ( sb , NO_AUTO_DA_ALLOC ) ) seq_puts ( seq , \",noauto_da_alloc\" ) ; if ( test_opt ( sb , DISCARD ) ) seq_puts ( seq , \",discard\" ) ; if ( test_opt ( sb , NOLOAD ) ) seq_puts ( seq , \",norecovery\" ) ; <S2SV_StartBug> ext4_show_quota_options ( seq , sb ) ; <S2SV_EndBug> return 0 ; }\n","target":"<S2SV_ModStart> \",norecovery\" ) ; if ( test_opt ( sb , DIOREAD_NOLOCK ) ) seq_puts ( seq , \",dioread_nolock\" ) ;\n","project_and_commit_id":"torvalds@linux/744692dc059845b2a3022119871846e74d4f6e11","cve_id":"CVE-2015-8324","original_address":"https://github.com/torvalds/linux/commit/744692dc059845b2a3022119871846e74d4f6e11","time":"2016-05-02T10:59Z"},
	{"Unnamed: 0":5723,"cwe_id":"CWE-125","source":"CWE-125 static int rsvp_obj_print ( netdissect_options * ndo , const u_char * pptr , u_int plen , const u_char * tptr , const char * ident , u_int tlen , const struct rsvp_common_header * rsvp_com_header ) { const struct rsvp_object_header * rsvp_obj_header ; const u_char * obj_tptr ; union { const struct rsvp_obj_integrity_t * rsvp_obj_integrity ; const struct rsvp_obj_frr_t * rsvp_obj_frr ; } obj_ptr ; u_short rsvp_obj_len , rsvp_obj_ctype , obj_tlen , intserv_serv_tlen ; int hexdump , processed , padbytes , error_code , error_value , i , sigcheck ; union { float f ; uint32_t i ; } bw ; uint8_t namelen ; u_int action , subchannel ; while ( tlen >= sizeof ( struct rsvp_object_header ) ) { ND_TCHECK2 ( * tptr , sizeof ( struct rsvp_object_header ) ) ; rsvp_obj_header = ( const struct rsvp_object_header * ) tptr ; rsvp_obj_len = EXTRACT_16BITS ( rsvp_obj_header -> length ) ; rsvp_obj_ctype = rsvp_obj_header -> ctype ; if ( rsvp_obj_len % 4 ) { ND_PRINT ( ( ndo , \"%sERROR:<S2SV_blank>object<S2SV_blank>header<S2SV_blank>size<S2SV_blank>%u<S2SV_blank>not<S2SV_blank>a<S2SV_blank>multiple<S2SV_blank>of<S2SV_blank>4\" , ident , rsvp_obj_len ) ) ; return - 1 ; } if ( rsvp_obj_len < sizeof ( struct rsvp_object_header ) ) { ND_PRINT ( ( ndo , \"%sERROR:<S2SV_blank>object<S2SV_blank>header<S2SV_blank>too<S2SV_blank>short<S2SV_blank>%u<S2SV_blank><<S2SV_blank>%lu\" , ident , rsvp_obj_len , ( unsigned long ) sizeof ( const struct rsvp_object_header ) ) ) ; return - 1 ; } ND_PRINT ( ( ndo , \"%s%s<S2SV_blank>Object<S2SV_blank>(%u)<S2SV_blank>Flags:<S2SV_blank>[%s\" , ident , tok2str ( rsvp_obj_values , \"Unknown\" , rsvp_obj_header -> class_num ) , rsvp_obj_header -> class_num , ( ( rsvp_obj_header -> class_num ) & 0x80 ) ? \"ignore\" : \"reject\" ) ) ; if ( rsvp_obj_header -> class_num > 128 ) ND_PRINT ( ( ndo , \"<S2SV_blank>%s\" , ( ( rsvp_obj_header -> class_num ) & 0x40 ) ? \"and<S2SV_blank>forward\" : \"silently\" ) ) ; ND_PRINT ( ( ndo , \"<S2SV_blank>if<S2SV_blank>unknown],<S2SV_blank>Class-Type:<S2SV_blank>%s<S2SV_blank>(%u),<S2SV_blank>length:<S2SV_blank>%u\" , tok2str ( rsvp_ctype_values , \"Unknown\" , ( ( rsvp_obj_header -> class_num ) << 8 ) + rsvp_obj_ctype ) , rsvp_obj_ctype , rsvp_obj_len ) ) ; if ( tlen < rsvp_obj_len ) { ND_PRINT ( ( ndo , \"%sERROR:<S2SV_blank>object<S2SV_blank>goes<S2SV_blank>past<S2SV_blank>end<S2SV_blank>of<S2SV_blank>objects<S2SV_blank>TLV\" , ident ) ) ; return - 1 ; } obj_tptr = tptr + sizeof ( struct rsvp_object_header ) ; obj_tlen = rsvp_obj_len - sizeof ( struct rsvp_object_header ) ; if ( ! ND_TTEST2 ( * tptr , rsvp_obj_len ) ) return - 1 ; hexdump = FALSE ; switch ( rsvp_obj_header -> class_num ) { case RSVP_OBJ_SESSION : switch ( rsvp_obj_ctype ) { case RSVP_CTYPE_IPV4 : if ( obj_tlen < 8 ) return - 1 ; ND_PRINT ( ( ndo , \"%s<S2SV_blank><S2SV_blank>IPv4<S2SV_blank>DestAddress:<S2SV_blank>%s,<S2SV_blank>Protocol<S2SV_blank>ID:<S2SV_blank>0x%02x\" , ident , ipaddr_string ( ndo , obj_tptr ) , * ( obj_tptr + sizeof ( struct in_addr ) ) ) ) ; ND_PRINT ( ( ndo , \"%s<S2SV_blank><S2SV_blank>Flags:<S2SV_blank>[0x%02x],<S2SV_blank>DestPort<S2SV_blank>%u\" , ident , * ( obj_tptr + 5 ) , EXTRACT_16BITS ( obj_tptr + 6 ) ) ) ; obj_tlen -= 8 ; obj_tptr += 8 ; break ; case RSVP_CTYPE_IPV6 : if ( obj_tlen < 20 ) return - 1 ; ND_PRINT ( ( ndo , \"%s<S2SV_blank><S2SV_blank>IPv6<S2SV_blank>DestAddress:<S2SV_blank>%s,<S2SV_blank>Protocol<S2SV_blank>ID:<S2SV_blank>0x%02x\" , ident , ip6addr_string ( ndo , obj_tptr ) , * ( obj_tptr + sizeof ( struct in6_addr ) ) ) ) ; ND_PRINT ( ( ndo , \"%s<S2SV_blank><S2SV_blank>Flags:<S2SV_blank>[0x%02x],<S2SV_blank>DestPort<S2SV_blank>%u\" , ident , * ( obj_tptr + sizeof ( struct in6_addr ) + 1 ) , EXTRACT_16BITS ( obj_tptr + sizeof ( struct in6_addr ) + 2 ) ) ) ; obj_tlen -= 20 ; obj_tptr += 20 ; break ; case RSVP_CTYPE_TUNNEL_IPV6 : if ( obj_tlen < 36 ) return - 1 ; ND_PRINT ( ( ndo , \"%s<S2SV_blank><S2SV_blank>IPv6<S2SV_blank>Tunnel<S2SV_blank>EndPoint:<S2SV_blank>%s,<S2SV_blank>Tunnel<S2SV_blank>ID:<S2SV_blank>0x%04x,<S2SV_blank>Extended<S2SV_blank>Tunnel<S2SV_blank>ID:<S2SV_blank>%s\" , ident , ip6addr_string ( ndo , obj_tptr ) , EXTRACT_16BITS ( obj_tptr + 18 ) , ip6addr_string ( ndo , obj_tptr + 20 ) ) ) ; obj_tlen -= 36 ; obj_tptr += 36 ; break ; case RSVP_CTYPE_14 : if ( obj_tlen < 26 ) return - 1 ; ND_PRINT ( ( ndo , \"%s<S2SV_blank><S2SV_blank>IPv6<S2SV_blank>P2MP<S2SV_blank>LSP<S2SV_blank>ID:<S2SV_blank>0x%08x,<S2SV_blank>Tunnel<S2SV_blank>ID:<S2SV_blank>0x%04x,<S2SV_blank>Extended<S2SV_blank>Tunnel<S2SV_blank>ID:<S2SV_blank>%s\" , ident , EXTRACT_32BITS ( obj_tptr ) , EXTRACT_16BITS ( obj_tptr + 6 ) , ip6addr_string ( ndo , obj_tptr + 8 ) ) ) ; obj_tlen -= 26 ; obj_tptr += 26 ; break ; case RSVP_CTYPE_13 : if ( obj_tlen < 12 ) return - 1 ; ND_PRINT ( ( ndo , \"%s<S2SV_blank><S2SV_blank>IPv4<S2SV_blank>P2MP<S2SV_blank>LSP<S2SV_blank>ID:<S2SV_blank>%s,<S2SV_blank>Tunnel<S2SV_blank>ID:<S2SV_blank>0x%04x,<S2SV_blank>Extended<S2SV_blank>Tunnel<S2SV_blank>ID:<S2SV_blank>%s\" , ident , ipaddr_string ( ndo , obj_tptr ) , EXTRACT_16BITS ( obj_tptr + 6 ) , ipaddr_string ( ndo , obj_tptr + 8 ) ) ) ; obj_tlen -= 12 ; obj_tptr += 12 ; break ; case RSVP_CTYPE_TUNNEL_IPV4 : case RSVP_CTYPE_UNI_IPV4 : if ( obj_tlen < 12 ) return - 1 ; ND_PRINT ( ( ndo , \"%s<S2SV_blank><S2SV_blank>IPv4<S2SV_blank>Tunnel<S2SV_blank>EndPoint:<S2SV_blank>%s,<S2SV_blank>Tunnel<S2SV_blank>ID:<S2SV_blank>0x%04x,<S2SV_blank>Extended<S2SV_blank>Tunnel<S2SV_blank>ID:<S2SV_blank>%s\" , ident , ipaddr_string ( ndo , obj_tptr ) , EXTRACT_16BITS ( obj_tptr + 6 ) , ipaddr_string ( ndo , obj_tptr + 8 ) ) ) ; obj_tlen -= 12 ; obj_tptr += 12 ; break ; default : hexdump = TRUE ; } break ; case RSVP_OBJ_CONFIRM : switch ( rsvp_obj_ctype ) { case RSVP_CTYPE_IPV4 : if ( obj_tlen < sizeof ( struct in_addr ) ) return - 1 ; ND_PRINT ( ( ndo , \"%s<S2SV_blank><S2SV_blank>IPv4<S2SV_blank>Receiver<S2SV_blank>Address:<S2SV_blank>%s\" , ident , ipaddr_string ( ndo , obj_tptr ) ) ) ; obj_tlen -= sizeof ( struct in_addr ) ; obj_tptr += sizeof ( struct in_addr ) ; break ; case RSVP_CTYPE_IPV6 : if ( obj_tlen < sizeof ( struct in6_addr ) ) return - 1 ; ND_PRINT ( ( ndo , \"%s<S2SV_blank><S2SV_blank>IPv6<S2SV_blank>Receiver<S2SV_blank>Address:<S2SV_blank>%s\" , ident , ip6addr_string ( ndo , obj_tptr ) ) ) ; obj_tlen -= sizeof ( struct in6_addr ) ; obj_tptr += sizeof ( struct in6_addr ) ; break ; default : hexdump = TRUE ; } break ; case RSVP_OBJ_NOTIFY_REQ : switch ( rsvp_obj_ctype ) { case RSVP_CTYPE_IPV4 : if ( obj_tlen < sizeof ( struct in_addr ) ) return - 1 ; ND_PRINT ( ( ndo , \"%s<S2SV_blank><S2SV_blank>IPv4<S2SV_blank>Notify<S2SV_blank>Node<S2SV_blank>Address:<S2SV_blank>%s\" , ident , ipaddr_string ( ndo , obj_tptr ) ) ) ; obj_tlen -= sizeof ( struct in_addr ) ; obj_tptr += sizeof ( struct in_addr ) ; break ; case RSVP_CTYPE_IPV6 : if ( obj_tlen < sizeof ( struct in6_addr ) ) return - 1 ; ND_PRINT ( ( ndo , \"%s<S2SV_blank><S2SV_blank>IPv6<S2SV_blank>Notify<S2SV_blank>Node<S2SV_blank>Address:<S2SV_blank>%s\" , ident , ip6addr_string ( ndo , obj_tptr ) ) ) ; obj_tlen -= sizeof ( struct in6_addr ) ; obj_tptr += sizeof ( struct in6_addr ) ; break ; default : hexdump = TRUE ; } break ; case RSVP_OBJ_SUGGESTED_LABEL : case RSVP_OBJ_UPSTREAM_LABEL : case RSVP_OBJ_RECOVERY_LABEL : case RSVP_OBJ_LABEL : switch ( rsvp_obj_ctype ) { case RSVP_CTYPE_1 : while ( obj_tlen >= 4 ) { ND_PRINT ( ( ndo , \"%s<S2SV_blank><S2SV_blank>Label:<S2SV_blank>%u\" , ident , EXTRACT_32BITS ( obj_tptr ) ) ) ; obj_tlen -= 4 ; obj_tptr += 4 ; } break ; case RSVP_CTYPE_2 : if ( obj_tlen < 4 ) return - 1 ; ND_PRINT ( ( ndo , \"%s<S2SV_blank><S2SV_blank>Generalized<S2SV_blank>Label:<S2SV_blank>%u\" , ident , EXTRACT_32BITS ( obj_tptr ) ) ) ; obj_tlen -= 4 ; obj_tptr += 4 ; break ; case RSVP_CTYPE_3 : if ( obj_tlen < 12 ) return - 1 ; ND_PRINT ( ( ndo , \"%s<S2SV_blank><S2SV_blank>Waveband<S2SV_blank>ID:<S2SV_blank>%u%s<S2SV_blank><S2SV_blank>Start<S2SV_blank>Label:<S2SV_blank>%u,<S2SV_blank>Stop<S2SV_blank>Label:<S2SV_blank>%u\" , ident , EXTRACT_32BITS ( obj_tptr ) , ident , EXTRACT_32BITS ( obj_tptr + 4 ) , EXTRACT_32BITS ( obj_tptr + 8 ) ) ) ; obj_tlen -= 12 ; obj_tptr += 12 ; break ; default : hexdump = TRUE ; } break ; case RSVP_OBJ_STYLE : switch ( rsvp_obj_ctype ) { case RSVP_CTYPE_1 : if ( obj_tlen < 4 ) return - 1 ; ND_PRINT ( ( ndo , \"%s<S2SV_blank><S2SV_blank>Reservation<S2SV_blank>Style:<S2SV_blank>%s,<S2SV_blank>Flags:<S2SV_blank>[0x%02x]\" , ident , tok2str ( rsvp_resstyle_values , \"Unknown\" , EXTRACT_24BITS ( obj_tptr + 1 ) ) , * ( obj_tptr ) ) ) ; obj_tlen -= 4 ; obj_tptr += 4 ; break ; default : hexdump = TRUE ; } break ; case RSVP_OBJ_SENDER_TEMPLATE : switch ( rsvp_obj_ctype ) { case RSVP_CTYPE_IPV4 : if ( obj_tlen < 8 ) return - 1 ; ND_PRINT ( ( ndo , \"%s<S2SV_blank><S2SV_blank>Source<S2SV_blank>Address:<S2SV_blank>%s,<S2SV_blank>Source<S2SV_blank>Port:<S2SV_blank>%u\" , ident , ipaddr_string ( ndo , obj_tptr ) , EXTRACT_16BITS ( obj_tptr + 6 ) ) ) ; obj_tlen -= 8 ; obj_tptr += 8 ; break ; case RSVP_CTYPE_IPV6 : if ( obj_tlen < 20 ) return - 1 ; ND_PRINT ( ( ndo , \"%s<S2SV_blank><S2SV_blank>Source<S2SV_blank>Address:<S2SV_blank>%s,<S2SV_blank>Source<S2SV_blank>Port:<S2SV_blank>%u\" , ident , ip6addr_string ( ndo , obj_tptr ) , EXTRACT_16BITS ( obj_tptr + 18 ) ) ) ; obj_tlen -= 20 ; obj_tptr += 20 ; break ; case RSVP_CTYPE_13 : if ( obj_tlen < 40 ) return - 1 ; ND_PRINT ( ( ndo , \"%s<S2SV_blank><S2SV_blank>IPv6<S2SV_blank>Tunnel<S2SV_blank>Sender<S2SV_blank>Address:<S2SV_blank>%s,<S2SV_blank>LSP<S2SV_blank>ID:<S2SV_blank>0x%04x\" \"%s<S2SV_blank><S2SV_blank>Sub-Group<S2SV_blank>Originator<S2SV_blank>ID:<S2SV_blank>%s,<S2SV_blank>Sub-Group<S2SV_blank>ID:<S2SV_blank>0x%04x\" , ident , ip6addr_string ( ndo , obj_tptr ) , EXTRACT_16BITS ( obj_tptr + 18 ) , ident , ip6addr_string ( ndo , obj_tptr + 20 ) , EXTRACT_16BITS ( obj_tptr + 38 ) ) ) ; obj_tlen -= 40 ; obj_tptr += 40 ; break ; case RSVP_CTYPE_TUNNEL_IPV4 : if ( obj_tlen < 8 ) return - 1 ; ND_PRINT ( ( ndo , \"%s<S2SV_blank><S2SV_blank>IPv4<S2SV_blank>Tunnel<S2SV_blank>Sender<S2SV_blank>Address:<S2SV_blank>%s,<S2SV_blank>LSP-ID:<S2SV_blank>0x%04x\" , ident , ipaddr_string ( ndo , obj_tptr ) , EXTRACT_16BITS ( obj_tptr + 6 ) ) ) ; obj_tlen -= 8 ; obj_tptr += 8 ; break ; case RSVP_CTYPE_12 : if ( obj_tlen < 16 ) return - 1 ; ND_PRINT ( ( ndo , \"%s<S2SV_blank><S2SV_blank>IPv4<S2SV_blank>Tunnel<S2SV_blank>Sender<S2SV_blank>Address:<S2SV_blank>%s,<S2SV_blank>LSP<S2SV_blank>ID:<S2SV_blank>0x%04x\" \"%s<S2SV_blank><S2SV_blank>Sub-Group<S2SV_blank>Originator<S2SV_blank>ID:<S2SV_blank>%s,<S2SV_blank>Sub-Group<S2SV_blank>ID:<S2SV_blank>0x%04x\" , ident , ipaddr_string ( ndo , obj_tptr ) , EXTRACT_16BITS ( obj_tptr + 6 ) , ident , ipaddr_string ( ndo , obj_tptr + 8 ) , EXTRACT_16BITS ( obj_tptr + 12 ) ) ) ; obj_tlen -= 16 ; obj_tptr += 16 ; break ; default : hexdump = TRUE ; } break ; case RSVP_OBJ_LABEL_REQ : switch ( rsvp_obj_ctype ) { case RSVP_CTYPE_1 : while ( obj_tlen >= 4 ) { ND_PRINT ( ( ndo , \"%s<S2SV_blank><S2SV_blank>L3<S2SV_blank>Protocol<S2SV_blank>ID:<S2SV_blank>%s\" , ident , tok2str ( ethertype_values , \"Unknown<S2SV_blank>Protocol<S2SV_blank>(0x%04x)\" , EXTRACT_16BITS ( obj_tptr + 2 ) ) ) ) ; obj_tlen -= 4 ; obj_tptr += 4 ; } break ; case RSVP_CTYPE_2 : if ( obj_tlen < 12 ) return - 1 ; ND_PRINT ( ( ndo , \"%s<S2SV_blank><S2SV_blank>L3<S2SV_blank>Protocol<S2SV_blank>ID:<S2SV_blank>%s\" , ident , tok2str ( ethertype_values , \"Unknown<S2SV_blank>Protocol<S2SV_blank>(0x%04x)\" , EXTRACT_16BITS ( obj_tptr + 2 ) ) ) ) ; ND_PRINT ( ( ndo , \",%s<S2SV_blank>merge<S2SV_blank>capability\" , ( ( * ( obj_tptr + 4 ) ) & 0x80 ) ? \"no\" : \"\" ) ) ; ND_PRINT ( ( ndo , \"%s<S2SV_blank><S2SV_blank>Minimum<S2SV_blank>VPI/VCI:<S2SV_blank>%u/%u\" , ident , ( EXTRACT_16BITS ( obj_tptr + 4 ) ) & 0xfff , ( EXTRACT_16BITS ( obj_tptr + 6 ) ) & 0xfff ) ) ; ND_PRINT ( ( ndo , \"%s<S2SV_blank><S2SV_blank>Maximum<S2SV_blank>VPI/VCI:<S2SV_blank>%u/%u\" , ident , ( EXTRACT_16BITS ( obj_tptr + 8 ) ) & 0xfff , ( EXTRACT_16BITS ( obj_tptr + 10 ) ) & 0xfff ) ) ; obj_tlen -= 12 ; obj_tptr += 12 ; break ; case RSVP_CTYPE_3 : if ( obj_tlen < 12 ) return - 1 ; ND_PRINT ( ( ndo , \"%s<S2SV_blank><S2SV_blank>L3<S2SV_blank>Protocol<S2SV_blank>ID:<S2SV_blank>%s\" , ident , tok2str ( ethertype_values , \"Unknown<S2SV_blank>Protocol<S2SV_blank>(0x%04x)\" , EXTRACT_16BITS ( obj_tptr + 2 ) ) ) ) ; ND_PRINT ( ( ndo , \"%s<S2SV_blank><S2SV_blank>Minimum/Maximum<S2SV_blank>DLCI:<S2SV_blank>%u/%u,<S2SV_blank>%s%s<S2SV_blank>bit<S2SV_blank>DLCI\" , ident , ( EXTRACT_32BITS ( obj_tptr + 4 ) ) & 0x7fffff , ( EXTRACT_32BITS ( obj_tptr + 8 ) ) & 0x7fffff , ( ( ( EXTRACT_16BITS ( obj_tptr + 4 ) >> 7 ) & 3 ) == 0 ) ? \"10\" : \"\" , ( ( ( EXTRACT_16BITS ( obj_tptr + 4 ) >> 7 ) & 3 ) == 2 ) ? \"23\" : \"\" ) ) ; obj_tlen -= 12 ; obj_tptr += 12 ; break ; case RSVP_CTYPE_4 : if ( obj_tlen < 4 ) return - 1 ; ND_PRINT ( ( ndo , \"%s<S2SV_blank><S2SV_blank>LSP<S2SV_blank>Encoding<S2SV_blank>Type:<S2SV_blank>%s<S2SV_blank>(%u)\" , ident , tok2str ( gmpls_encoding_values , \"Unknown\" , * obj_tptr ) , * obj_tptr ) ) ; ND_PRINT ( ( ndo , \"%s<S2SV_blank><S2SV_blank>Switching<S2SV_blank>Type:<S2SV_blank>%s<S2SV_blank>(%u),<S2SV_blank>Payload<S2SV_blank>ID:<S2SV_blank>%s<S2SV_blank>(0x%04x)\" , ident , tok2str ( gmpls_switch_cap_values , \"Unknown\" , * ( obj_tptr + 1 ) ) , * ( obj_tptr + 1 ) , tok2str ( gmpls_payload_values , \"Unknown\" , EXTRACT_16BITS ( obj_tptr + 2 ) ) , EXTRACT_16BITS ( obj_tptr + 2 ) ) ) ; obj_tlen -= 4 ; obj_tptr += 4 ; break ; default : hexdump = TRUE ; } break ; case RSVP_OBJ_RRO : case RSVP_OBJ_ERO : switch ( rsvp_obj_ctype ) { case RSVP_CTYPE_IPV4 : while ( obj_tlen >= 4 ) { u_char length ; ND_TCHECK2 ( * obj_tptr , 4 ) ; length = * ( obj_tptr + 1 ) ; ND_PRINT ( ( ndo , \"%s<S2SV_blank><S2SV_blank>Subobject<S2SV_blank>Type:<S2SV_blank>%s,<S2SV_blank>length<S2SV_blank>%u\" , ident , tok2str ( rsvp_obj_xro_values , \"Unknown<S2SV_blank>%u\" , RSVP_OBJ_XRO_MASK_SUBOBJ ( * obj_tptr ) ) , length ) ) ; if ( length == 0 ) { ND_PRINT ( ( ndo , \"%s<S2SV_blank><S2SV_blank>ERROR:<S2SV_blank>zero<S2SV_blank>length<S2SV_blank>ERO<S2SV_blank>subtype\" , ident ) ) ; break ; } switch ( RSVP_OBJ_XRO_MASK_SUBOBJ ( * obj_tptr ) ) { u_char prefix_length ; case RSVP_OBJ_XRO_IPV4 : if ( length != 8 ) { ND_PRINT ( ( ndo , \"<S2SV_blank>ERROR:<S2SV_blank>length<S2SV_blank>!=<S2SV_blank>8\" ) ) ; goto invalid ; } ND_TCHECK2 ( * obj_tptr , 8 ) ; prefix_length = * ( obj_tptr + 6 ) ; if ( prefix_length != 32 ) { ND_PRINT ( ( ndo , \"<S2SV_blank>ERROR:<S2SV_blank>Prefix<S2SV_blank>length<S2SV_blank>%u<S2SV_blank>!=<S2SV_blank>32\" , prefix_length ) ) ; goto invalid ; } ND_PRINT ( ( ndo , \",<S2SV_blank>%s,<S2SV_blank>%s/%u,<S2SV_blank>Flags:<S2SV_blank>[%s]\" , RSVP_OBJ_XRO_MASK_LOOSE ( * obj_tptr ) ? \"Loose\" : \"Strict\" , ipaddr_string ( ndo , obj_tptr + 2 ) , * ( obj_tptr + 6 ) , bittok2str ( rsvp_obj_rro_flag_values , \"none\" , * ( obj_tptr + 7 ) ) ) ) ; break ; case RSVP_OBJ_XRO_LABEL : if ( length != 8 ) { ND_PRINT ( ( ndo , \"<S2SV_blank>ERROR:<S2SV_blank>length<S2SV_blank>!=<S2SV_blank>8\" ) ) ; goto invalid ; } ND_TCHECK2 ( * obj_tptr , 8 ) ; ND_PRINT ( ( ndo , \",<S2SV_blank>Flags:<S2SV_blank>[%s]<S2SV_blank>(%#x),<S2SV_blank>Class-Type:<S2SV_blank>%s<S2SV_blank>(%u),<S2SV_blank>%u\" , bittok2str ( rsvp_obj_rro_label_flag_values , \"none\" , * ( obj_tptr + 2 ) ) , * ( obj_tptr + 2 ) , tok2str ( rsvp_ctype_values , \"Unknown\" , * ( obj_tptr + 3 ) + 256 * RSVP_OBJ_RRO ) , * ( obj_tptr + 3 ) , EXTRACT_32BITS ( obj_tptr + 4 ) ) ) ; } obj_tlen -= * ( obj_tptr + 1 ) ; obj_tptr += * ( obj_tptr + 1 ) ; } break ; default : hexdump = TRUE ; } break ; case RSVP_OBJ_HELLO : switch ( rsvp_obj_ctype ) { case RSVP_CTYPE_1 : case RSVP_CTYPE_2 : if ( obj_tlen < 8 ) return - 1 ; ND_PRINT ( ( ndo , \"%s<S2SV_blank><S2SV_blank>Source<S2SV_blank>Instance:<S2SV_blank>0x%08x,<S2SV_blank>Destination<S2SV_blank>Instance:<S2SV_blank>0x%08x\" , ident , EXTRACT_32BITS ( obj_tptr ) , EXTRACT_32BITS ( obj_tptr + 4 ) ) ) ; obj_tlen -= 8 ; obj_tptr += 8 ; break ; default : hexdump = TRUE ; } break ; case RSVP_OBJ_RESTART_CAPABILITY : switch ( rsvp_obj_ctype ) { case RSVP_CTYPE_1 : if ( obj_tlen < 8 ) return - 1 ; ND_PRINT ( ( ndo , \"%s<S2SV_blank><S2SV_blank>Restart<S2SV_blank><S2SV_blank>Time:<S2SV_blank>%ums,<S2SV_blank>Recovery<S2SV_blank>Time:<S2SV_blank>%ums\" , ident , EXTRACT_32BITS ( obj_tptr ) , EXTRACT_32BITS ( obj_tptr + 4 ) ) ) ; obj_tlen -= 8 ; obj_tptr += 8 ; break ; default : hexdump = TRUE ; } break ; case RSVP_OBJ_SESSION_ATTRIBUTE : switch ( rsvp_obj_ctype ) { case RSVP_CTYPE_TUNNEL_IPV4 : if ( obj_tlen < 4 ) return - 1 ; namelen = * ( obj_tptr + 3 ) ; if ( obj_tlen < 4 + namelen ) return - 1 ; ND_PRINT ( ( ndo , \"%s<S2SV_blank><S2SV_blank>Session<S2SV_blank>Name:<S2SV_blank>\" , ident ) ) ; for ( i = 0 ; i < namelen ; i ++ ) safeputchar ( ndo , * ( obj_tptr + 4 + i ) ) ; ND_PRINT ( ( ndo , \"%s<S2SV_blank><S2SV_blank>Setup<S2SV_blank>Priority:<S2SV_blank>%u,<S2SV_blank>Holding<S2SV_blank>Priority:<S2SV_blank>%u,<S2SV_blank>Flags:<S2SV_blank>[%s]<S2SV_blank>(%#x)\" , ident , ( int ) * obj_tptr , ( int ) * ( obj_tptr + 1 ) , bittok2str ( rsvp_session_attribute_flag_values , \"none\" , * ( obj_tptr + 2 ) ) , * ( obj_tptr + 2 ) ) ) ; obj_tlen -= 4 + * ( obj_tptr + 3 ) ; obj_tptr += 4 + * ( obj_tptr + 3 ) ; break ; default : hexdump = TRUE ; } break ; case RSVP_OBJ_GENERALIZED_UNI : switch ( rsvp_obj_ctype ) { int subobj_type , af , subobj_len , total_subobj_len ; case RSVP_CTYPE_1 : if ( obj_tlen < 4 ) return - 1 ; total_subobj_len = obj_tlen ; while ( total_subobj_len > 0 ) { subobj_len = EXTRACT_16BITS ( obj_tptr ) ; subobj_type = ( EXTRACT_16BITS ( obj_tptr + 2 ) ) >> 8 ; af = ( EXTRACT_16BITS ( obj_tptr + 2 ) ) & 0x00FF ; ND_PRINT ( ( ndo , \"%s<S2SV_blank><S2SV_blank>Subobject<S2SV_blank>Type:<S2SV_blank>%s<S2SV_blank>(%u),<S2SV_blank>AF:<S2SV_blank>%s<S2SV_blank>(%u),<S2SV_blank>length:<S2SV_blank>%u\" , ident , tok2str ( rsvp_obj_generalized_uni_values , \"Unknown\" , subobj_type ) , subobj_type , tok2str ( af_values , \"Unknown\" , af ) , af , subobj_len ) ) ; if ( subobj_len == 0 ) goto invalid ; switch ( subobj_type ) { case RSVP_GEN_UNI_SUBOBJ_SOURCE_TNA_ADDRESS : case RSVP_GEN_UNI_SUBOBJ_DESTINATION_TNA_ADDRESS : switch ( af ) { case AFNUM_INET : if ( subobj_len < 8 ) return - 1 ; ND_PRINT ( ( ndo , \"%s<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>UNI<S2SV_blank>IPv4<S2SV_blank>TNA<S2SV_blank>address:<S2SV_blank>%s\" , ident , ipaddr_string ( ndo , obj_tptr + 4 ) ) ) ; break ; case AFNUM_INET6 : if ( subobj_len < 20 ) return - 1 ; ND_PRINT ( ( ndo , \"%s<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>UNI<S2SV_blank>IPv6<S2SV_blank>TNA<S2SV_blank>address:<S2SV_blank>%s\" , ident , ip6addr_string ( ndo , obj_tptr + 4 ) ) ) ; break ; case AFNUM_NSAP : if ( subobj_len ) { hexdump = TRUE ; } break ; } break ; case RSVP_GEN_UNI_SUBOBJ_DIVERSITY : if ( subobj_len ) { hexdump = TRUE ; } break ; case RSVP_GEN_UNI_SUBOBJ_EGRESS_LABEL : if ( subobj_len < 16 ) { return - 1 ; } ND_PRINT ( ( ndo , \"%s<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>U-bit:<S2SV_blank>%x,<S2SV_blank>Label<S2SV_blank>type:<S2SV_blank>%u,<S2SV_blank>Logical<S2SV_blank>port<S2SV_blank>id:<S2SV_blank>%u,<S2SV_blank>Label:<S2SV_blank>%u\" , ident , ( ( EXTRACT_32BITS ( obj_tptr + 4 ) ) >> 31 ) , ( ( EXTRACT_32BITS ( obj_tptr + 4 ) ) & 0xFF ) , EXTRACT_32BITS ( obj_tptr + 8 ) , EXTRACT_32BITS ( obj_tptr + 12 ) ) ) ; break ; case RSVP_GEN_UNI_SUBOBJ_SERVICE_LEVEL : if ( subobj_len < 8 ) { return - 1 ; } ND_PRINT ( ( ndo , \"%s<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Service<S2SV_blank>level:<S2SV_blank>%u\" , ident , ( EXTRACT_32BITS ( obj_tptr + 4 ) ) >> 24 ) ) ; break ; default : hexdump = TRUE ; break ; } total_subobj_len -= subobj_len ; obj_tptr += subobj_len ; obj_tlen += subobj_len ; } if ( total_subobj_len ) { hexdump = TRUE ; } break ; default : hexdump = TRUE ; } break ; case RSVP_OBJ_RSVP_HOP : switch ( rsvp_obj_ctype ) { case RSVP_CTYPE_3 : case RSVP_CTYPE_IPV4 : if ( obj_tlen < 8 ) return - 1 ; ND_PRINT ( ( ndo , \"%s<S2SV_blank><S2SV_blank>Previous/Next<S2SV_blank>Interface:<S2SV_blank>%s,<S2SV_blank>Logical<S2SV_blank>Interface<S2SV_blank>Handle:<S2SV_blank>0x%08x\" , ident , ipaddr_string ( ndo , obj_tptr ) , EXTRACT_32BITS ( obj_tptr + 4 ) ) ) ; obj_tlen -= 8 ; obj_tptr += 8 ; if ( obj_tlen ) hexdump = TRUE ; break ; case RSVP_CTYPE_4 : case RSVP_CTYPE_IPV6 : if ( obj_tlen < 20 ) return - 1 ; ND_PRINT ( ( ndo , \"%s<S2SV_blank><S2SV_blank>Previous/Next<S2SV_blank>Interface:<S2SV_blank>%s,<S2SV_blank>Logical<S2SV_blank>Interface<S2SV_blank>Handle:<S2SV_blank>0x%08x\" , ident , ip6addr_string ( ndo , obj_tptr ) , EXTRACT_32BITS ( obj_tptr + 16 ) ) ) ; obj_tlen -= 20 ; obj_tptr += 20 ; hexdump = TRUE ; break ; default : hexdump = TRUE ; } break ; case RSVP_OBJ_TIME_VALUES : switch ( rsvp_obj_ctype ) { case RSVP_CTYPE_1 : if ( obj_tlen < 4 ) return - 1 ; ND_PRINT ( ( ndo , \"%s<S2SV_blank><S2SV_blank>Refresh<S2SV_blank>Period:<S2SV_blank>%ums\" , ident , EXTRACT_32BITS ( obj_tptr ) ) ) ; obj_tlen -= 4 ; obj_tptr += 4 ; break ; default : hexdump = TRUE ; } break ; case RSVP_OBJ_SENDER_TSPEC : case RSVP_OBJ_ADSPEC : case RSVP_OBJ_FLOWSPEC : switch ( rsvp_obj_ctype ) { case RSVP_CTYPE_2 : if ( obj_tlen < 4 ) return - 1 ; ND_PRINT ( ( ndo , \"%s<S2SV_blank><S2SV_blank>Msg-Version:<S2SV_blank>%u,<S2SV_blank>length:<S2SV_blank>%u\" , ident , ( * obj_tptr & 0xf0 ) >> 4 , EXTRACT_16BITS ( obj_tptr + 2 ) << 2 ) ) ; obj_tptr += 4 ; obj_tlen -= 4 ; while ( obj_tlen >= 4 ) { intserv_serv_tlen = EXTRACT_16BITS ( obj_tptr + 2 ) << 2 ; ND_PRINT ( ( ndo , \"%s<S2SV_blank><S2SV_blank>Service<S2SV_blank>Type:<S2SV_blank>%s<S2SV_blank>(%u),<S2SV_blank>break<S2SV_blank>bit<S2SV_blank>%s<S2SV_blank>set,<S2SV_blank>Service<S2SV_blank>length:<S2SV_blank>%u\" , ident , tok2str ( rsvp_intserv_service_type_values , \"unknown\" , * ( obj_tptr ) ) , * ( obj_tptr ) , ( * ( obj_tptr + 1 ) & 0x80 ) ? \"\" : \"not\" , intserv_serv_tlen ) ) ; obj_tptr += 4 ; obj_tlen -= 4 ; while ( intserv_serv_tlen >= 4 ) { processed = rsvp_intserv_print ( ndo , obj_tptr , obj_tlen ) ; if ( processed == 0 ) break ; obj_tlen -= processed ; intserv_serv_tlen -= processed ; obj_tptr += processed ; } } break ; default : hexdump = TRUE ; } break ; case RSVP_OBJ_FILTERSPEC : switch ( rsvp_obj_ctype ) { case RSVP_CTYPE_IPV4 : if ( obj_tlen < 8 ) return - 1 ; ND_PRINT ( ( ndo , \"%s<S2SV_blank><S2SV_blank>Source<S2SV_blank>Address:<S2SV_blank>%s,<S2SV_blank>Source<S2SV_blank>Port:<S2SV_blank>%u\" , ident , ipaddr_string ( ndo , obj_tptr ) , EXTRACT_16BITS ( obj_tptr + 6 ) ) ) ; obj_tlen -= 8 ; obj_tptr += 8 ; break ; case RSVP_CTYPE_IPV6 : if ( obj_tlen < 20 ) return - 1 ; ND_PRINT ( ( ndo , \"%s<S2SV_blank><S2SV_blank>Source<S2SV_blank>Address:<S2SV_blank>%s,<S2SV_blank>Source<S2SV_blank>Port:<S2SV_blank>%u\" , ident , ip6addr_string ( ndo , obj_tptr ) , EXTRACT_16BITS ( obj_tptr + 18 ) ) ) ; obj_tlen -= 20 ; obj_tptr += 20 ; break ; case RSVP_CTYPE_3 : if ( obj_tlen < 20 ) return - 1 ; ND_PRINT ( ( ndo , \"%s<S2SV_blank><S2SV_blank>Source<S2SV_blank>Address:<S2SV_blank>%s,<S2SV_blank>Flow<S2SV_blank>Label:<S2SV_blank>%u\" , ident , ip6addr_string ( ndo , obj_tptr ) , EXTRACT_24BITS ( obj_tptr + 17 ) ) ) ; obj_tlen -= 20 ; obj_tptr += 20 ; break ; case RSVP_CTYPE_TUNNEL_IPV6 : if ( obj_tlen < 20 ) return - 1 ; ND_PRINT ( ( ndo , \"%s<S2SV_blank><S2SV_blank>Source<S2SV_blank>Address:<S2SV_blank>%s,<S2SV_blank>LSP-ID:<S2SV_blank>0x%04x\" , ident , ipaddr_string ( ndo , obj_tptr ) , EXTRACT_16BITS ( obj_tptr + 18 ) ) ) ; obj_tlen -= 20 ; obj_tptr += 20 ; break ; case RSVP_CTYPE_13 : if ( obj_tlen < 40 ) return - 1 ; ND_PRINT ( ( ndo , \"%s<S2SV_blank><S2SV_blank>IPv6<S2SV_blank>Tunnel<S2SV_blank>Sender<S2SV_blank>Address:<S2SV_blank>%s,<S2SV_blank>LSP<S2SV_blank>ID:<S2SV_blank>0x%04x\" \"%s<S2SV_blank><S2SV_blank>Sub-Group<S2SV_blank>Originator<S2SV_blank>ID:<S2SV_blank>%s,<S2SV_blank>Sub-Group<S2SV_blank>ID:<S2SV_blank>0x%04x\" , ident , ip6addr_string ( ndo , obj_tptr ) , EXTRACT_16BITS ( obj_tptr + 18 ) , ident , ip6addr_string ( ndo , obj_tptr + 20 ) , EXTRACT_16BITS ( obj_tptr + 38 ) ) ) ; obj_tlen -= 40 ; obj_tptr += 40 ; break ; case RSVP_CTYPE_TUNNEL_IPV4 : if ( obj_tlen < 8 ) return - 1 ; ND_PRINT ( ( ndo , \"%s<S2SV_blank><S2SV_blank>Source<S2SV_blank>Address:<S2SV_blank>%s,<S2SV_blank>LSP-ID:<S2SV_blank>0x%04x\" , ident , ipaddr_string ( ndo , obj_tptr ) , EXTRACT_16BITS ( obj_tptr + 6 ) ) ) ; obj_tlen -= 8 ; obj_tptr += 8 ; break ; case RSVP_CTYPE_12 : if ( obj_tlen < 16 ) return - 1 ; ND_PRINT ( ( ndo , \"%s<S2SV_blank><S2SV_blank>IPv4<S2SV_blank>Tunnel<S2SV_blank>Sender<S2SV_blank>Address:<S2SV_blank>%s,<S2SV_blank>LSP<S2SV_blank>ID:<S2SV_blank>0x%04x\" \"%s<S2SV_blank><S2SV_blank>Sub-Group<S2SV_blank>Originator<S2SV_blank>ID:<S2SV_blank>%s,<S2SV_blank>Sub-Group<S2SV_blank>ID:<S2SV_blank>0x%04x\" , ident , ipaddr_string ( ndo , obj_tptr ) , EXTRACT_16BITS ( obj_tptr + 6 ) , ident , ipaddr_string ( ndo , obj_tptr + 8 ) , EXTRACT_16BITS ( obj_tptr + 12 ) ) ) ; obj_tlen -= 16 ; obj_tptr += 16 ; break ; default : hexdump = TRUE ; } break ; case RSVP_OBJ_FASTREROUTE : obj_ptr . rsvp_obj_frr = ( const struct rsvp_obj_frr_t * ) obj_tptr ; <S2SV_StartBug> bw . i = EXTRACT_32BITS ( obj_ptr . rsvp_obj_frr -> bandwidth ) ; <S2SV_EndBug> <S2SV_StartBug> switch ( rsvp_obj_ctype ) { <S2SV_EndBug> case RSVP_CTYPE_1 : if ( obj_tlen < sizeof ( struct rsvp_obj_frr_t ) ) return - 1 ; ND_PRINT ( ( ndo , \"%s<S2SV_blank><S2SV_blank>Setup<S2SV_blank>Priority:<S2SV_blank>%u,<S2SV_blank>Holding<S2SV_blank>Priority:<S2SV_blank>%u,<S2SV_blank>Hop-limit:<S2SV_blank>%u,<S2SV_blank>Bandwidth:<S2SV_blank>%.10g<S2SV_blank>Mbps\" , ident , ( int ) obj_ptr . rsvp_obj_frr -> setup_prio , ( int ) obj_ptr . rsvp_obj_frr -> hold_prio , ( int ) obj_ptr . rsvp_obj_frr -> hop_limit , bw . f * 8 / 1000000 ) ) ; ND_PRINT ( ( ndo , \"%s<S2SV_blank><S2SV_blank>Include-any:<S2SV_blank>0x%08x,<S2SV_blank>Exclude-any:<S2SV_blank>0x%08x,<S2SV_blank>Include-all:<S2SV_blank>0x%08x\" , ident , EXTRACT_32BITS ( obj_ptr . rsvp_obj_frr -> include_any ) , EXTRACT_32BITS ( obj_ptr . rsvp_obj_frr -> exclude_any ) , EXTRACT_32BITS ( obj_ptr . rsvp_obj_frr -> include_all ) ) ) ; obj_tlen -= sizeof ( struct rsvp_obj_frr_t ) ; obj_tptr += sizeof ( struct rsvp_obj_frr_t ) ; break ; case RSVP_CTYPE_TUNNEL_IPV4 : if ( obj_tlen < 16 ) return - 1 ; <S2SV_StartBug> ND_PRINT ( ( ndo , \"%s<S2SV_blank><S2SV_blank>Setup<S2SV_blank>Priority:<S2SV_blank>%u,<S2SV_blank>Holding<S2SV_blank>Priority:<S2SV_blank>%u,<S2SV_blank>Hop-limit:<S2SV_blank>%u,<S2SV_blank>Bandwidth:<S2SV_blank>%.10g<S2SV_blank>Mbps\" , <S2SV_EndBug> ident , ( int ) obj_ptr . rsvp_obj_frr -> setup_prio , ( int ) obj_ptr . rsvp_obj_frr -> hold_prio , ( int ) obj_ptr . rsvp_obj_frr -> hop_limit , bw . f * 8 / 1000000 ) ) ; ND_PRINT ( ( ndo , \"%s<S2SV_blank><S2SV_blank>Include<S2SV_blank>Colors:<S2SV_blank>0x%08x,<S2SV_blank>Exclude<S2SV_blank>Colors:<S2SV_blank>0x%08x\" , ident , EXTRACT_32BITS ( obj_ptr . rsvp_obj_frr -> include_any ) , EXTRACT_32BITS ( obj_ptr . rsvp_obj_frr -> exclude_any ) ) ) ; obj_tlen -= 16 ; obj_tptr += 16 ; break ; default : hexdump = TRUE ; } break ; case RSVP_OBJ_DETOUR : switch ( rsvp_obj_ctype ) { case RSVP_CTYPE_TUNNEL_IPV4 : while ( obj_tlen >= 8 ) { ND_PRINT ( ( ndo , \"%s<S2SV_blank><S2SV_blank>PLR-ID:<S2SV_blank>%s,<S2SV_blank>Avoid-Node-ID:<S2SV_blank>%s\" , ident , ipaddr_string ( ndo , obj_tptr ) , ipaddr_string ( ndo , obj_tptr + 4 ) ) ) ; obj_tlen -= 8 ; obj_tptr += 8 ; } break ; default : hexdump = TRUE ; } break ; case RSVP_OBJ_CLASSTYPE : case RSVP_OBJ_CLASSTYPE_OLD : switch ( rsvp_obj_ctype ) { case RSVP_CTYPE_1 : ND_PRINT ( ( ndo , \"%s<S2SV_blank><S2SV_blank>CT:<S2SV_blank>%u\" , ident , EXTRACT_32BITS ( obj_tptr ) & 0x7 ) ) ; obj_tlen -= 4 ; obj_tptr += 4 ; break ; default : hexdump = TRUE ; } break ; case RSVP_OBJ_ERROR_SPEC : switch ( rsvp_obj_ctype ) { case RSVP_CTYPE_3 : case RSVP_CTYPE_IPV4 : if ( obj_tlen < 8 ) return - 1 ; error_code = * ( obj_tptr + 5 ) ; error_value = EXTRACT_16BITS ( obj_tptr + 6 ) ; ND_PRINT ( ( ndo , \"%s<S2SV_blank><S2SV_blank>Error<S2SV_blank>Node<S2SV_blank>Address:<S2SV_blank>%s,<S2SV_blank>Flags:<S2SV_blank>[0x%02x]%s<S2SV_blank><S2SV_blank>Error<S2SV_blank>Code:<S2SV_blank>%s<S2SV_blank>(%u)\" , ident , ipaddr_string ( ndo , obj_tptr ) , * ( obj_tptr + 4 ) , ident , tok2str ( rsvp_obj_error_code_values , \"unknown\" , error_code ) , error_code ) ) ; switch ( error_code ) { case RSVP_OBJ_ERROR_SPEC_CODE_ROUTING : ND_PRINT ( ( ndo , \",<S2SV_blank>Error<S2SV_blank>Value:<S2SV_blank>%s<S2SV_blank>(%u)\" , tok2str ( rsvp_obj_error_code_routing_values , \"unknown\" , error_value ) , error_value ) ) ; break ; case RSVP_OBJ_ERROR_SPEC_CODE_DIFFSERV_TE : case RSVP_OBJ_ERROR_SPEC_CODE_DIFFSERV_TE_OLD : ND_PRINT ( ( ndo , \",<S2SV_blank>Error<S2SV_blank>Value:<S2SV_blank>%s<S2SV_blank>(%u)\" , tok2str ( rsvp_obj_error_code_diffserv_te_values , \"unknown\" , error_value ) , error_value ) ) ; break ; default : ND_PRINT ( ( ndo , \",<S2SV_blank>Unknown<S2SV_blank>Error<S2SV_blank>Value<S2SV_blank>(%u)\" , error_value ) ) ; break ; } obj_tlen -= 8 ; obj_tptr += 8 ; break ; case RSVP_CTYPE_4 : case RSVP_CTYPE_IPV6 : if ( obj_tlen < 20 ) return - 1 ; error_code = * ( obj_tptr + 17 ) ; error_value = EXTRACT_16BITS ( obj_tptr + 18 ) ; ND_PRINT ( ( ndo , \"%s<S2SV_blank><S2SV_blank>Error<S2SV_blank>Node<S2SV_blank>Address:<S2SV_blank>%s,<S2SV_blank>Flags:<S2SV_blank>[0x%02x]%s<S2SV_blank><S2SV_blank>Error<S2SV_blank>Code:<S2SV_blank>%s<S2SV_blank>(%u)\" , ident , ip6addr_string ( ndo , obj_tptr ) , * ( obj_tptr + 16 ) , ident , tok2str ( rsvp_obj_error_code_values , \"unknown\" , error_code ) , error_code ) ) ; switch ( error_code ) { case RSVP_OBJ_ERROR_SPEC_CODE_ROUTING : ND_PRINT ( ( ndo , \",<S2SV_blank>Error<S2SV_blank>Value:<S2SV_blank>%s<S2SV_blank>(%u)\" , tok2str ( rsvp_obj_error_code_routing_values , \"unknown\" , error_value ) , error_value ) ) ; break ; default : break ; } obj_tlen -= 20 ; obj_tptr += 20 ; break ; default : hexdump = TRUE ; } break ; case RSVP_OBJ_PROPERTIES : switch ( rsvp_obj_ctype ) { case RSVP_CTYPE_1 : if ( obj_tlen < 4 ) return - 1 ; padbytes = EXTRACT_16BITS ( obj_tptr + 2 ) ; ND_PRINT ( ( ndo , \"%s<S2SV_blank><S2SV_blank>TLV<S2SV_blank>count:<S2SV_blank>%u,<S2SV_blank>padding<S2SV_blank>bytes:<S2SV_blank>%u\" , ident , EXTRACT_16BITS ( obj_tptr ) , padbytes ) ) ; obj_tlen -= 4 ; obj_tptr += 4 ; while ( obj_tlen >= 2 + padbytes ) { ND_PRINT ( ( ndo , \"%s<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s<S2SV_blank>TLV<S2SV_blank>(0x%02x),<S2SV_blank>length:<S2SV_blank>%u\" , ident , tok2str ( rsvp_obj_prop_tlv_values , \"unknown\" , * obj_tptr ) , * obj_tptr , * ( obj_tptr + 1 ) ) ) ; if ( obj_tlen < * ( obj_tptr + 1 ) ) return - 1 ; if ( * ( obj_tptr + 1 ) < 2 ) return - 1 ; print_unknown_data ( ndo , obj_tptr + 2 , \"\\\\n\\\\t\\\\t\" , * ( obj_tptr + 1 ) - 2 ) ; obj_tlen -= * ( obj_tptr + 1 ) ; obj_tptr += * ( obj_tptr + 1 ) ; } break ; default : hexdump = TRUE ; } break ; case RSVP_OBJ_MESSAGE_ID : case RSVP_OBJ_MESSAGE_ID_ACK : case RSVP_OBJ_MESSAGE_ID_LIST : switch ( rsvp_obj_ctype ) { case RSVP_CTYPE_1 : case RSVP_CTYPE_2 : if ( obj_tlen < 8 ) return - 1 ; ND_PRINT ( ( ndo , \"%s<S2SV_blank><S2SV_blank>Flags<S2SV_blank>[0x%02x],<S2SV_blank>epoch:<S2SV_blank>%u\" , ident , * obj_tptr , EXTRACT_24BITS ( obj_tptr + 1 ) ) ) ; obj_tlen -= 4 ; obj_tptr += 4 ; while ( obj_tlen >= 4 ) { ND_PRINT ( ( ndo , \"%s<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Message-ID<S2SV_blank>0x%08x<S2SV_blank>(%u)\" , ident , EXTRACT_32BITS ( obj_tptr ) , EXTRACT_32BITS ( obj_tptr ) ) ) ; obj_tlen -= 4 ; obj_tptr += 4 ; } break ; default : hexdump = TRUE ; } break ; case RSVP_OBJ_INTEGRITY : switch ( rsvp_obj_ctype ) { case RSVP_CTYPE_1 : if ( obj_tlen < sizeof ( struct rsvp_obj_integrity_t ) ) return - 1 ; obj_ptr . rsvp_obj_integrity = ( const struct rsvp_obj_integrity_t * ) obj_tptr ; ND_PRINT ( ( ndo , \"%s<S2SV_blank><S2SV_blank>Key-ID<S2SV_blank>0x%04x%08x,<S2SV_blank>Sequence<S2SV_blank>0x%08x%08x,<S2SV_blank>Flags<S2SV_blank>[%s]\" , ident , EXTRACT_16BITS ( obj_ptr . rsvp_obj_integrity -> key_id ) , EXTRACT_32BITS ( obj_ptr . rsvp_obj_integrity -> key_id + 2 ) , EXTRACT_32BITS ( obj_ptr . rsvp_obj_integrity -> sequence ) , EXTRACT_32BITS ( obj_ptr . rsvp_obj_integrity -> sequence + 4 ) , bittok2str ( rsvp_obj_integrity_flag_values , \"none\" , obj_ptr . rsvp_obj_integrity -> flags ) ) ) ; ND_PRINT ( ( ndo , \"%s<S2SV_blank><S2SV_blank>MD5-sum<S2SV_blank>0x%08x%08x%08x%08x<S2SV_blank>\" , ident , EXTRACT_32BITS ( obj_ptr . rsvp_obj_integrity -> digest ) , EXTRACT_32BITS ( obj_ptr . rsvp_obj_integrity -> digest + 4 ) , EXTRACT_32BITS ( obj_ptr . rsvp_obj_integrity -> digest + 8 ) , EXTRACT_32BITS ( obj_ptr . rsvp_obj_integrity -> digest + 12 ) ) ) ; sigcheck = signature_verify ( ndo , pptr , plen , obj_ptr . rsvp_obj_integrity -> digest , rsvp_clear_checksum , rsvp_com_header ) ; ND_PRINT ( ( ndo , \"<S2SV_blank>(%s)\" , tok2str ( signature_check_values , \"Unknown\" , sigcheck ) ) ) ; obj_tlen += sizeof ( struct rsvp_obj_integrity_t ) ; obj_tptr += sizeof ( struct rsvp_obj_integrity_t ) ; break ; default : hexdump = TRUE ; } break ; case RSVP_OBJ_ADMIN_STATUS : switch ( rsvp_obj_ctype ) { case RSVP_CTYPE_1 : if ( obj_tlen < 4 ) return - 1 ; ND_PRINT ( ( ndo , \"%s<S2SV_blank><S2SV_blank>Flags<S2SV_blank>[%s]\" , ident , bittok2str ( rsvp_obj_admin_status_flag_values , \"none\" , EXTRACT_32BITS ( obj_tptr ) ) ) ) ; obj_tlen -= 4 ; obj_tptr += 4 ; break ; default : hexdump = TRUE ; } break ; case RSVP_OBJ_LABEL_SET : switch ( rsvp_obj_ctype ) { case RSVP_CTYPE_1 : if ( obj_tlen < 4 ) return - 1 ; action = ( EXTRACT_16BITS ( obj_tptr ) >> 8 ) ; ND_PRINT ( ( ndo , \"%s<S2SV_blank><S2SV_blank>Action:<S2SV_blank>%s<S2SV_blank>(%u),<S2SV_blank>Label<S2SV_blank>type:<S2SV_blank>%u\" , ident , tok2str ( rsvp_obj_label_set_action_values , \"Unknown\" , action ) , action , ( ( EXTRACT_32BITS ( obj_tptr ) & 0x7F ) ) ) ) ; switch ( action ) { case LABEL_SET_INCLUSIVE_RANGE : case LABEL_SET_EXCLUSIVE_RANGE : if ( obj_tlen < 12 ) return - 1 ; ND_PRINT ( ( ndo , \"%s<S2SV_blank><S2SV_blank>Start<S2SV_blank>range:<S2SV_blank>%u,<S2SV_blank>End<S2SV_blank>range:<S2SV_blank>%u\" , ident , EXTRACT_32BITS ( obj_tptr + 4 ) , EXTRACT_32BITS ( obj_tptr + 8 ) ) ) ; obj_tlen -= 12 ; obj_tptr += 12 ; break ; default : obj_tlen -= 4 ; obj_tptr += 4 ; subchannel = 1 ; while ( obj_tlen >= 4 ) { ND_PRINT ( ( ndo , \"%s<S2SV_blank><S2SV_blank>Subchannel<S2SV_blank>#%u:<S2SV_blank>%u\" , ident , subchannel , EXTRACT_32BITS ( obj_tptr ) ) ) ; obj_tptr += 4 ; obj_tlen -= 4 ; subchannel ++ ; } break ; } break ; default : hexdump = TRUE ; } break ; case RSVP_OBJ_S2L : switch ( rsvp_obj_ctype ) { case RSVP_CTYPE_IPV4 : if ( obj_tlen < 4 ) return - 1 ; ND_PRINT ( ( ndo , \"%s<S2SV_blank><S2SV_blank>Sub-LSP<S2SV_blank>destination<S2SV_blank>address:<S2SV_blank>%s\" , ident , ipaddr_string ( ndo , obj_tptr ) ) ) ; obj_tlen -= 4 ; obj_tptr += 4 ; break ; case RSVP_CTYPE_IPV6 : if ( obj_tlen < 16 ) return - 1 ; ND_PRINT ( ( ndo , \"%s<S2SV_blank><S2SV_blank>Sub-LSP<S2SV_blank>destination<S2SV_blank>address:<S2SV_blank>%s\" , ident , ip6addr_string ( ndo , obj_tptr ) ) ) ; obj_tlen -= 16 ; obj_tptr += 16 ; break ; default : hexdump = TRUE ; } break ; case RSVP_OBJ_SCOPE : case RSVP_OBJ_POLICY_DATA : case RSVP_OBJ_ACCEPT_LABEL_SET : case RSVP_OBJ_PROTECTION : default : if ( ndo -> ndo_vflag <= 1 ) print_unknown_data ( ndo , obj_tptr , \"\\\\n\\\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>\" , obj_tlen ) ; break ; } if ( ndo -> ndo_vflag > 1 || hexdump == TRUE ) print_unknown_data ( ndo , tptr + sizeof ( struct rsvp_object_header ) , \"\\\\n\\\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>\" , rsvp_obj_len - sizeof ( struct rsvp_object_header ) ) ; tptr += rsvp_obj_len ; tlen -= rsvp_obj_len ; } return 0 ; invalid : ND_PRINT ( ( ndo , \"%s\" , istr ) ) ; return - 1 ; trunc : ND_PRINT ( ( ndo , \"\\\\n\\\\t\\\\t\" ) ) ; ND_PRINT ( ( ndo , \"%s\" , tstr ) ) ; return - 1 ; }\n","target":"<S2SV_ModStart> ) obj_tptr ; switch ( rsvp_obj_ctype ) { case RSVP_CTYPE_1 : if ( obj_tlen < sizeof ( struct rsvp_obj_frr_t ) ) return - 1 ; <S2SV_ModStart> bandwidth ) ; <S2SV_ModEnd> ND_PRINT ( ( <S2SV_ModStart> - 1 ; bw . i = EXTRACT_32BITS ( obj_ptr . rsvp_obj_frr -> bandwidth ) ;\n","project_and_commit_id":"the-tcpdump-group@tcpdump/3c8a2b0e91d8d8947e89384dacf6b54673083e71","cve_id":"CVE-2017-13048","original_address":"https://github.com/the-tcpdump-group/tcpdump/commit/3c8a2b0e91d8d8947e89384dacf6b54673083e71","time":"2017-09-14T06:29Z"},
	{"Unnamed: 0":4130,"cwe_id":"CWE-665","source":"CWE-665 int ParseWave64HeaderConfig ( FILE * infile , char * infilename , char * fourcc , WavpackContext * wpc , WavpackConfig * config ) { int64_t total_samples = 0 , infilesize ; Wave64ChunkHeader chunk_header ; Wave64FileHeader filehdr ; WaveHeader WaveHeader ; int format_chunk = 0 ; <S2SV_StartBug> uint32_t bcount ; <S2SV_EndBug> infilesize = DoGetFileSize ( infile ) ; memcpy ( & filehdr , fourcc , 4 ) ; if ( ! DoReadFile ( infile , ( ( char * ) & filehdr ) + 4 , sizeof ( Wave64FileHeader ) - 4 , & bcount ) || bcount != sizeof ( Wave64FileHeader ) - 4 || memcmp ( filehdr . ckID , riff_guid , sizeof ( riff_guid ) ) || memcmp ( filehdr . formType , wave_guid , sizeof ( wave_guid ) ) ) { error_line ( \"%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>.W64<S2SV_blank>file!\" , infilename ) ; return WAVPACK_SOFT_ERROR ; } else if ( ! ( config -> qmode & QMODE_NO_STORE_WRAPPER ) && ! WavpackAddWrapper ( wpc , & filehdr , sizeof ( filehdr ) ) ) { error_line ( \"%s\" , WavpackGetErrorMessage ( wpc ) ) ; return WAVPACK_SOFT_ERROR ; } # if 1 WavpackLittleEndianToNative ( & filehdr , Wave64ChunkHeaderFormat ) ; if ( infilesize && ! ( config -> qmode & QMODE_IGNORE_LENGTH ) && filehdr . ckSize && filehdr . ckSize + 1 && filehdr . ckSize != infilesize ) { error_line ( \"%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>.W64<S2SV_blank>file!\" , infilename ) ; return WAVPACK_SOFT_ERROR ; } # endif while ( 1 ) { if ( ! DoReadFile ( infile , & chunk_header , sizeof ( Wave64ChunkHeader ) , & bcount ) || bcount != sizeof ( Wave64ChunkHeader ) ) { error_line ( \"%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>.W64<S2SV_blank>file!\" , infilename ) ; return WAVPACK_SOFT_ERROR ; } else if ( ! ( config -> qmode & QMODE_NO_STORE_WRAPPER ) && ! WavpackAddWrapper ( wpc , & chunk_header , sizeof ( Wave64ChunkHeader ) ) ) { error_line ( \"%s\" , WavpackGetErrorMessage ( wpc ) ) ; return WAVPACK_SOFT_ERROR ; } WavpackLittleEndianToNative ( & chunk_header , Wave64ChunkHeaderFormat ) ; chunk_header . ckSize -= sizeof ( chunk_header ) ; if ( ! memcmp ( chunk_header . ckID , fmt_guid , sizeof ( fmt_guid ) ) ) { int supported = TRUE , format ; if ( format_chunk ++ ) { error_line ( \"%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>.W64<S2SV_blank>file!\" , infilename ) ; return WAVPACK_SOFT_ERROR ; } chunk_header . ckSize = ( chunk_header . ckSize + 7 ) & ~ 7L ; if ( chunk_header . ckSize < 16 || chunk_header . ckSize > sizeof ( WaveHeader ) || ! DoReadFile ( infile , & WaveHeader , ( uint32_t ) chunk_header . ckSize , & bcount ) || bcount != chunk_header . ckSize ) { error_line ( \"%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>.W64<S2SV_blank>file!\" , infilename ) ; return WAVPACK_SOFT_ERROR ; } else if ( ! ( config -> qmode & QMODE_NO_STORE_WRAPPER ) && ! WavpackAddWrapper ( wpc , & WaveHeader , ( uint32_t ) chunk_header . ckSize ) ) { error_line ( \"%s\" , WavpackGetErrorMessage ( wpc ) ) ; return WAVPACK_SOFT_ERROR ; } WavpackLittleEndianToNative ( & WaveHeader , WaveHeaderFormat ) ; if ( debug_logging_mode ) { error_line ( \"format<S2SV_blank>tag<S2SV_blank>size<S2SV_blank>=<S2SV_blank>%d\" , chunk_header . ckSize ) ; error_line ( \"FormatTag<S2SV_blank>=<S2SV_blank>%x,<S2SV_blank>NumChannels<S2SV_blank>=<S2SV_blank>%d,<S2SV_blank>BitsPerSample<S2SV_blank>=<S2SV_blank>%d\" , WaveHeader . FormatTag , WaveHeader . NumChannels , WaveHeader . BitsPerSample ) ; error_line ( \"BlockAlign<S2SV_blank>=<S2SV_blank>%d,<S2SV_blank>SampleRate<S2SV_blank>=<S2SV_blank>%d,<S2SV_blank>BytesPerSecond<S2SV_blank>=<S2SV_blank>%d\" , WaveHeader . BlockAlign , WaveHeader . SampleRate , WaveHeader . BytesPerSecond ) ; if ( chunk_header . ckSize > 16 ) error_line ( \"cbSize<S2SV_blank>=<S2SV_blank>%d,<S2SV_blank>ValidBitsPerSample<S2SV_blank>=<S2SV_blank>%d\" , WaveHeader . cbSize , WaveHeader . ValidBitsPerSample ) ; if ( chunk_header . ckSize > 20 ) error_line ( \"ChannelMask<S2SV_blank>=<S2SV_blank>%x,<S2SV_blank>SubFormat<S2SV_blank>=<S2SV_blank>%d\" , WaveHeader . ChannelMask , WaveHeader . SubFormat ) ; } if ( chunk_header . ckSize > 16 && WaveHeader . cbSize == 2 ) config -> qmode |= QMODE_ADOBE_MODE ; format = ( WaveHeader . FormatTag == 0xfffe && chunk_header . ckSize == 40 ) ? WaveHeader . SubFormat : WaveHeader . FormatTag ; config -> bits_per_sample = ( chunk_header . ckSize == 40 && WaveHeader . ValidBitsPerSample ) ? WaveHeader . ValidBitsPerSample : WaveHeader . BitsPerSample ; if ( format != 1 && format != 3 ) supported = FALSE ; if ( format == 3 && config -> bits_per_sample != 32 ) supported = FALSE ; if ( ! WaveHeader . NumChannels || WaveHeader . NumChannels > 256 || WaveHeader . BlockAlign / WaveHeader . NumChannels < ( config -> bits_per_sample + 7 ) / 8 || WaveHeader . BlockAlign / WaveHeader . NumChannels > 4 || WaveHeader . BlockAlign % WaveHeader . NumChannels ) supported = FALSE ; if ( config -> bits_per_sample < 1 || config -> bits_per_sample > 32 ) supported = FALSE ; if ( ! supported ) { error_line ( \"%s<S2SV_blank>is<S2SV_blank>an<S2SV_blank>unsupported<S2SV_blank>.W64<S2SV_blank>format!\" , infilename ) ; return WAVPACK_SOFT_ERROR ; } if ( chunk_header . ckSize < 40 ) { if ( ! config -> channel_mask && ! ( config -> qmode & QMODE_CHANS_UNASSIGNED ) ) { if ( WaveHeader . NumChannels <= 2 ) config -> channel_mask = 0x5 - WaveHeader . NumChannels ; else if ( WaveHeader . NumChannels <= 18 ) config -> channel_mask = ( 1 << WaveHeader . NumChannels ) - 1 ; else config -> channel_mask = 0x3ffff ; } } else if ( WaveHeader . ChannelMask && ( config -> channel_mask || ( config -> qmode & QMODE_CHANS_UNASSIGNED ) ) ) { error_line ( \"this<S2SV_blank>W64<S2SV_blank>file<S2SV_blank>already<S2SV_blank>has<S2SV_blank>channel<S2SV_blank>order<S2SV_blank>information!\" ) ; return WAVPACK_SOFT_ERROR ; } else if ( WaveHeader . ChannelMask ) config -> channel_mask = WaveHeader . ChannelMask ; if ( format == 3 ) config -> float_norm_exp = 127 ; else if ( ( config -> qmode & QMODE_ADOBE_MODE ) && WaveHeader . BlockAlign / WaveHeader . NumChannels == 4 ) { if ( WaveHeader . BitsPerSample == 24 ) config -> float_norm_exp = 127 + 23 ; else if ( WaveHeader . BitsPerSample == 32 ) config -> float_norm_exp = 127 + 15 ; } if ( debug_logging_mode ) { if ( config -> float_norm_exp == 127 ) error_line ( \"data<S2SV_blank>format:<S2SV_blank>normalized<S2SV_blank>32-bit<S2SV_blank>floating<S2SV_blank>point\" ) ; else error_line ( \"data<S2SV_blank>format:<S2SV_blank>%d-bit<S2SV_blank>integers<S2SV_blank>stored<S2SV_blank>in<S2SV_blank>%d<S2SV_blank>byte(s)\" , config -> bits_per_sample , WaveHeader . BlockAlign / WaveHeader . NumChannels ) ; } } else if ( ! memcmp ( chunk_header . ckID , data_guid , sizeof ( data_guid ) ) ) { if ( ! WaveHeader . NumChannels ) { error_line ( \"%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>.W64<S2SV_blank>file!\" , infilename ) ; return WAVPACK_SOFT_ERROR ; } if ( ( config -> qmode & QMODE_IGNORE_LENGTH ) || chunk_header . ckSize <= 0 ) { config -> qmode |= QMODE_IGNORE_LENGTH ; if ( infilesize && DoGetFilePosition ( infile ) != - 1 ) total_samples = ( infilesize - DoGetFilePosition ( infile ) ) / WaveHeader . BlockAlign ; else total_samples = - 1 ; } else { if ( infilesize && infilesize - chunk_header . ckSize > 16777216 ) { error_line ( \"this<S2SV_blank>.W64<S2SV_blank>file<S2SV_blank>has<S2SV_blank>over<S2SV_blank>16<S2SV_blank>MB<S2SV_blank>of<S2SV_blank>extra<S2SV_blank>RIFF<S2SV_blank>data,<S2SV_blank>probably<S2SV_blank>is<S2SV_blank>corrupt!\" ) ; return WAVPACK_SOFT_ERROR ; } total_samples = chunk_header . ckSize / WaveHeader . BlockAlign ; if ( ! total_samples ) { error_line ( \"this<S2SV_blank>.W64<S2SV_blank>file<S2SV_blank>has<S2SV_blank>no<S2SV_blank>audio<S2SV_blank>samples,<S2SV_blank>probably<S2SV_blank>is<S2SV_blank>corrupt!\" ) ; return WAVPACK_SOFT_ERROR ; } if ( total_samples > MAX_WAVPACK_SAMPLES ) { error_line ( \"%s<S2SV_blank>has<S2SV_blank>too<S2SV_blank>many<S2SV_blank>samples<S2SV_blank>for<S2SV_blank>WavPack!\" , infilename ) ; return WAVPACK_SOFT_ERROR ; } } config -> bytes_per_sample = WaveHeader . BlockAlign / WaveHeader . NumChannels ; config -> num_channels = WaveHeader . NumChannels ; config -> sample_rate = WaveHeader . SampleRate ; break ; } else { int bytes_to_copy = ( chunk_header . ckSize + 7 ) & ~ 7L ; char * buff ; if ( bytes_to_copy < 0 || bytes_to_copy > 4194304 ) { error_line ( \"%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>.W64<S2SV_blank>file!\" , infilename ) ; return WAVPACK_SOFT_ERROR ; } buff = malloc ( bytes_to_copy ) ; if ( debug_logging_mode ) error_line ( \"extra<S2SV_blank>unknown<S2SV_blank>chunk<S2SV_blank>\\\\\"%c%c%c%c\\\\\"<S2SV_blank>of<S2SV_blank>%d<S2SV_blank>bytes\" , chunk_header . ckID [ 0 ] , chunk_header . ckID [ 1 ] , chunk_header . ckID [ 2 ] , chunk_header . ckID [ 3 ] , chunk_header . ckSize ) ; if ( ! DoReadFile ( infile , buff , bytes_to_copy , & bcount ) || bcount != bytes_to_copy || ( ! ( config -> qmode & QMODE_NO_STORE_WRAPPER ) && ! WavpackAddWrapper ( wpc , buff , bytes_to_copy ) ) ) { error_line ( \"%s\" , WavpackGetErrorMessage ( wpc ) ) ; free ( buff ) ; return WAVPACK_SOFT_ERROR ; } free ( buff ) ; } } if ( ! WavpackSetConfiguration64 ( wpc , config , total_samples , NULL ) ) { error_line ( \"%s:<S2SV_blank>%s\" , infilename , WavpackGetErrorMessage ( wpc ) ) ; return WAVPACK_SOFT_ERROR ; } return WAVPACK_NO_ERROR ; }\n","target":"<S2SV_ModStart> ; uint32_t bcount ; CLEAR ( WaveHeader )\n","project_and_commit_id":"dbry@WavPack/33a0025d1d63ccd05d9dbaa6923d52b1446a62fe","cve_id":"CVE-2019-1010319","original_address":"https://github.com/dbry/WavPack/commit/33a0025d1d63ccd05d9dbaa6923d52b1446a62fe","time":"2019-07-11T20:15Z"},
	{"Unnamed: 0":1296,"cwe_id":"CWE-000","source":"CWE-000 <S2SV_StartBug> static void sas_destruct_devices ( struct work_struct * work ) <S2SV_EndBug> { <S2SV_StartBug> struct domain_device * dev , * n ; <S2SV_EndBug> struct sas_discovery_event * ev = to_sas_discovery_event ( work ) ; struct asd_sas_port * port = ev -> port ; clear_bit ( DISCE_DESTRUCT , & port -> disc . pending ) ; list_for_each_entry_safe ( dev , n , & port -> destroy_list , disco_list_node ) { list_del_init ( & dev -> disco_list_node ) ; sas_remove_children ( & dev -> rphy -> dev ) ; sas_rphy_delete ( dev -> rphy ) ; sas_unregister_common_dev ( port , dev ) ; } }\n","target":"<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_ModEnd> void sas_destruct_devices ( <S2SV_ModStart> sas_destruct_devices ( struct asd_sas_port * port <S2SV_ModEnd> ) { struct <S2SV_ModStart> , * n <S2SV_ModEnd> ; list_for_each_entry_safe (\n","project_and_commit_id":"torvalds@linux/0558f33c06bb910e2879e355192227a8e8f0219d","cve_id":"CVE-2017-18232","original_address":"https://github.com/torvalds/linux/commit/0558f33c06bb910e2879e355192227a8e8f0219d","time":"2018-03-15T04:29Z"},
	{"Unnamed: 0":2309,"cwe_id":"CWE-119","source":"CWE-119 TEE_Result syscall_cryp_derive_key ( unsigned long state , const struct utee_attribute * usr_params , unsigned long param_count , unsigned long derived_key ) { TEE_Result res = TEE_ERROR_NOT_SUPPORTED ; struct tee_ta_session * sess ; struct tee_obj * ko ; struct tee_obj * so ; struct tee_cryp_state * cs ; struct tee_cryp_obj_secret * sk ; const struct tee_cryp_obj_type_props * type_props ; TEE_Attribute * params = NULL ; struct user_ta_ctx * utc ; res = tee_ta_get_current_session ( & sess ) ; if ( res != TEE_SUCCESS ) return res ; utc = to_user_ta_ctx ( sess -> ctx ) ; res = tee_svc_cryp_get_state ( sess , tee_svc_uref_to_vaddr ( state ) , & cs ) ; if ( res != TEE_SUCCESS ) return res ; <S2SV_StartBug> params = malloc ( sizeof ( TEE_Attribute ) * param_count ) ; <S2SV_EndBug> if ( ! params ) return TEE_ERROR_OUT_OF_MEMORY ; res = copy_in_attrs ( utc , usr_params , param_count , params ) ; if ( res != TEE_SUCCESS ) goto out ; res = tee_obj_get ( utc , cs -> key1 , & ko ) ; if ( res != TEE_SUCCESS ) goto out ; res = tee_obj_get ( utc , tee_svc_uref_to_vaddr ( derived_key ) , & so ) ; if ( res != TEE_SUCCESS ) goto out ; sk = so -> attr ; type_props = tee_svc_find_type_props ( so -> info . objectType ) ; if ( ! type_props ) { res = TEE_ERROR_NOT_SUPPORTED ; goto out ; } if ( cs -> algo == TEE_ALG_DH_DERIVE_SHARED_SECRET ) { size_t alloc_size ; struct bignum * pub ; struct bignum * ss ; if ( param_count != 1 || params [ 0 ] . attributeID != TEE_ATTR_DH_PUBLIC_VALUE ) { res = TEE_ERROR_BAD_PARAMETERS ; goto out ; } alloc_size = params [ 0 ] . content . ref . length * 8 ; pub = crypto_bignum_allocate ( alloc_size ) ; ss = crypto_bignum_allocate ( alloc_size ) ; if ( pub && ss ) { crypto_bignum_bin2bn ( params [ 0 ] . content . ref . buffer , params [ 0 ] . content . ref . length , pub ) ; res = crypto_acipher_dh_shared_secret ( ko -> attr , pub , ss ) ; if ( res == TEE_SUCCESS ) { sk -> key_size = crypto_bignum_num_bytes ( ss ) ; crypto_bignum_bn2bin ( ss , ( uint8_t * ) ( sk + 1 ) ) ; so -> info . handleFlags |= TEE_HANDLE_FLAG_INITIALIZED ; set_attribute ( so , type_props , TEE_ATTR_SECRET_VALUE ) ; } } else { res = TEE_ERROR_OUT_OF_MEMORY ; } crypto_bignum_free ( pub ) ; crypto_bignum_free ( ss ) ; } else if ( TEE_ALG_GET_MAIN_ALG ( cs -> algo ) == TEE_MAIN_ALGO_ECDH ) { size_t alloc_size ; struct ecc_public_key key_public ; uint8_t * pt_secret ; unsigned long pt_secret_len ; if ( param_count != 2 || params [ 0 ] . attributeID != TEE_ATTR_ECC_PUBLIC_VALUE_X || params [ 1 ] . attributeID != TEE_ATTR_ECC_PUBLIC_VALUE_Y ) { res = TEE_ERROR_BAD_PARAMETERS ; goto out ; } switch ( cs -> algo ) { case TEE_ALG_ECDH_P192 : alloc_size = 192 ; break ; case TEE_ALG_ECDH_P224 : alloc_size = 224 ; break ; case TEE_ALG_ECDH_P256 : alloc_size = 256 ; break ; case TEE_ALG_ECDH_P384 : alloc_size = 384 ; break ; case TEE_ALG_ECDH_P521 : alloc_size = 521 ; break ; default : res = TEE_ERROR_NOT_IMPLEMENTED ; goto out ; } res = crypto_acipher_alloc_ecc_public_key ( & key_public , alloc_size ) ; if ( res != TEE_SUCCESS ) goto out ; key_public . curve = ( ( struct ecc_keypair * ) ko -> attr ) -> curve ; crypto_bignum_bin2bn ( params [ 0 ] . content . ref . buffer , params [ 0 ] . content . ref . length , key_public . x ) ; crypto_bignum_bin2bn ( params [ 1 ] . content . ref . buffer , params [ 1 ] . content . ref . length , key_public . y ) ; pt_secret = ( uint8_t * ) ( sk + 1 ) ; pt_secret_len = sk -> alloc_size ; res = crypto_acipher_ecc_shared_secret ( ko -> attr , & key_public , pt_secret , & pt_secret_len ) ; if ( res == TEE_SUCCESS ) { sk -> key_size = pt_secret_len ; so -> info . handleFlags |= TEE_HANDLE_FLAG_INITIALIZED ; set_attribute ( so , type_props , TEE_ATTR_SECRET_VALUE ) ; } crypto_acipher_free_ecc_public_key ( & key_public ) ; } # if defined ( CFG_CRYPTO_HKDF ) else if ( TEE_ALG_GET_MAIN_ALG ( cs -> algo ) == TEE_MAIN_ALGO_HKDF ) { void * salt , * info ; size_t salt_len , info_len , okm_len ; uint32_t hash_id = TEE_ALG_GET_DIGEST_HASH ( cs -> algo ) ; struct tee_cryp_obj_secret * ik = ko -> attr ; const uint8_t * ikm = ( const uint8_t * ) ( ik + 1 ) ; res = get_hkdf_params ( params , param_count , & salt , & salt_len , & info , & info_len , & okm_len ) ; if ( res != TEE_SUCCESS ) goto out ; if ( okm_len > ik -> alloc_size ) { res = TEE_ERROR_BAD_PARAMETERS ; goto out ; } res = tee_cryp_hkdf ( hash_id , ikm , ik -> key_size , salt , salt_len , info , info_len , ( uint8_t * ) ( sk + 1 ) , okm_len ) ; if ( res == TEE_SUCCESS ) { sk -> key_size = okm_len ; so -> info . handleFlags |= TEE_HANDLE_FLAG_INITIALIZED ; set_attribute ( so , type_props , TEE_ATTR_SECRET_VALUE ) ; } } # endif # if defined ( CFG_CRYPTO_CONCAT_KDF ) else if ( TEE_ALG_GET_MAIN_ALG ( cs -> algo ) == TEE_MAIN_ALGO_CONCAT_KDF ) { void * info ; size_t info_len , derived_key_len ; uint32_t hash_id = TEE_ALG_GET_DIGEST_HASH ( cs -> algo ) ; struct tee_cryp_obj_secret * ss = ko -> attr ; const uint8_t * shared_secret = ( const uint8_t * ) ( ss + 1 ) ; res = get_concat_kdf_params ( params , param_count , & info , & info_len , & derived_key_len ) ; if ( res != TEE_SUCCESS ) goto out ; if ( derived_key_len > ss -> alloc_size ) { res = TEE_ERROR_BAD_PARAMETERS ; goto out ; } res = tee_cryp_concat_kdf ( hash_id , shared_secret , ss -> key_size , info , info_len , ( uint8_t * ) ( sk + 1 ) , derived_key_len ) ; if ( res == TEE_SUCCESS ) { sk -> key_size = derived_key_len ; so -> info . handleFlags |= TEE_HANDLE_FLAG_INITIALIZED ; set_attribute ( so , type_props , TEE_ATTR_SECRET_VALUE ) ; } } # endif # if defined ( CFG_CRYPTO_PBKDF2 ) else if ( TEE_ALG_GET_MAIN_ALG ( cs -> algo ) == TEE_MAIN_ALGO_PBKDF2 ) { void * salt ; size_t salt_len , iteration_count , derived_key_len ; uint32_t hash_id = TEE_ALG_GET_DIGEST_HASH ( cs -> algo ) ; struct tee_cryp_obj_secret * ss = ko -> attr ; const uint8_t * password = ( const uint8_t * ) ( ss + 1 ) ; res = get_pbkdf2_params ( params , param_count , & salt , & salt_len , & derived_key_len , & iteration_count ) ; if ( res != TEE_SUCCESS ) goto out ; if ( derived_key_len > ss -> alloc_size ) { res = TEE_ERROR_BAD_PARAMETERS ; goto out ; } res = tee_cryp_pbkdf2 ( hash_id , password , ss -> key_size , salt , salt_len , iteration_count , ( uint8_t * ) ( sk + 1 ) , derived_key_len ) ; if ( res == TEE_SUCCESS ) { sk -> key_size = derived_key_len ; so -> info . handleFlags |= TEE_HANDLE_FLAG_INITIALIZED ; set_attribute ( so , type_props , TEE_ATTR_SECRET_VALUE ) ; } } # endif else res = TEE_ERROR_NOT_SUPPORTED ; out : free ( params ) ; return res ; }\n","target":"<S2SV_ModStart> return res ; size_t alloc_size = 0 ; if ( MUL_OVERFLOW ( sizeof ( TEE_Attribute ) , param_count , & alloc_size ) ) return TEE_ERROR_OVERFLOW ; <S2SV_ModStart> = malloc ( alloc_size <S2SV_ModEnd> ) ; if\n","project_and_commit_id":"OP-TEE@optee_os/a637243270fc1faae16de059091795c32d86e65e","cve_id":"CVE-2019-1010297","original_address":"https://github.com/OP-TEE/optee_os/commit/a637243270fc1faae16de059091795c32d86e65e","time":"2019-07-15T18:15Z"},
	{"Unnamed: 0":6266,"cwe_id":"CWE-352","source":"CWE-352 static HttpResponse create_HttpResponse ( Socket_T S ) { HttpResponse res = NULL ; NEW ( res ) ; res -> S = S ; res -> status = SC_OK ; res -> outputbuffer = StringBuffer_create ( 256 ) ; res -> is_committed = false ; res -> protocol = SERVER_PROTOCOL ; res -> status_msg = get_status_string ( SC_OK ) ; <S2SV_StartBug> return res ; <S2SV_EndBug> }\n","target":"<S2SV_ModStart> SC_OK ) ; Util_getToken ( res -> token ) ;\n","project_and_commit_id":"tildeslash@monit/c6ec3820e627f85417053e6336de2987f2d863e3","cve_id":"CVE-2016-7067","original_address":"https://bitbucket.org/tildeslash/monit/commit/c6ec3820e627f85417053e6336de2987f2d863e3","time":"2018-09-10T14:29Z"},
	{"Unnamed: 0":5740,"cwe_id":"CWE-20","source":"CWE-20 static int futex_wait_requeue_pi ( u32 __user * uaddr , unsigned int flags , u32 val , ktime_t * abs_time , u32 bitset , u32 __user * uaddr2 ) { struct hrtimer_sleeper timeout , * to = NULL ; struct rt_mutex_waiter rt_waiter ; struct rt_mutex * pi_mutex = NULL ; struct futex_hash_bucket * hb ; union futex_key key2 = FUTEX_KEY_INIT ; struct futex_q q = futex_q_init ; <S2SV_StartBug> int res , ret ; <S2SV_EndBug> if ( ! bitset ) return - EINVAL ; if ( abs_time ) { to = & timeout ; hrtimer_init_on_stack ( & to -> timer , ( flags & FLAGS_CLOCKRT ) ? CLOCK_REALTIME : CLOCK_MONOTONIC , HRTIMER_MODE_ABS ) ; hrtimer_init_sleeper ( to , current ) ; hrtimer_set_expires_range_ns ( & to -> timer , * abs_time , current -> timer_slack_ns ) ; } debug_rt_mutex_init_waiter ( & rt_waiter ) ; rt_waiter . task = NULL ; ret = get_futex_key ( uaddr2 , flags & FLAGS_SHARED , & key2 , VERIFY_WRITE ) ; if ( unlikely ( ret != 0 ) ) goto out ; q . bitset = bitset ; q . rt_waiter = & rt_waiter ; q . requeue_pi_key = & key2 ; ret = futex_wait_setup ( uaddr , val , flags , & q , & hb ) ; if ( ret ) goto out_key2 ; futex_wait_queue_me ( hb , & q , to ) ; spin_lock ( & hb -> lock ) ; ret = handle_early_requeue_pi_wakeup ( hb , & q , & key2 , to ) ; spin_unlock ( & hb -> lock ) ; if ( ret ) goto out_put_keys ; if ( ! q . rt_waiter ) { if ( q . pi_state && ( q . pi_state -> owner != current ) ) { spin_lock ( q . lock_ptr ) ; ret = fixup_pi_state_owner ( uaddr2 , & q , current ) ; spin_unlock ( q . lock_ptr ) ; } } else { WARN_ON ( ! q . pi_state ) ; pi_mutex = & q . pi_state -> pi_mutex ; ret = rt_mutex_finish_proxy_lock ( pi_mutex , to , & rt_waiter , 1 ) ; debug_rt_mutex_free_waiter ( & rt_waiter ) ; spin_lock ( q . lock_ptr ) ; res = fixup_owner ( uaddr2 , & q , ! ret ) ; if ( res ) ret = ( res < 0 ) ? res : 0 ; unqueue_me_pi ( & q ) ; } if ( ret == - EFAULT ) { if ( pi_mutex && rt_mutex_owner ( pi_mutex ) == current ) rt_mutex_unlock ( pi_mutex ) ; } else if ( ret == - EINTR ) { ret = - EWOULDBLOCK ; } out_put_keys : put_futex_key ( & q . key ) ; out_key2 : put_futex_key ( & key2 ) ; out : if ( to ) { hrtimer_cancel ( & to -> timer ) ; destroy_hrtimer_on_stack ( & to -> timer ) ; } return ret ; }\n","target":"<S2SV_ModStart> res , ret ; if ( uaddr == uaddr2 ) return - EINVAL\n","project_and_commit_id":"torvalds@linux/6f7b0a2a5c0fb03be7c25bd1745baa50582348ef","cve_id":"CVE-2012-6647","original_address":"https://github.com/torvalds/linux/commit/6f7b0a2a5c0fb03be7c25bd1745baa50582348ef","time":"2014-05-26T22:55Z"},
	{"Unnamed: 0":3241,"cwe_id":"CWE-399","source":"CWE-399 static Image * ReadSIXELImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { char * sixel_buffer ; Image * image ; MagickBooleanType status ; register char * p ; register ssize_t x ; register Quantum * q ; size_t length ; ssize_t i , j , y ; unsigned char * sixel_pixels , * sixel_palette ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickCoreSignature ) ; if ( image_info -> debug != MagickFalse ) ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , \"%s\" , image_info -> filename ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickCoreSignature ) ; image = AcquireImage ( image_info , exception ) ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } length = MagickPathExtent ; sixel_buffer = ( char * ) AcquireQuantumMemory ( ( size_t ) length + MagickPathExtent , sizeof ( * sixel_buffer ) ) ; p = sixel_buffer ; if ( sixel_buffer != ( char * ) NULL ) while ( ReadBlobString ( image , p ) != ( char * ) NULL ) { if ( ( * p == '#' ) && ( ( p == sixel_buffer ) || ( * ( p - 1 ) == '\\\\n' ) ) ) continue ; if ( ( * p == '}' ) && ( * ( p + 1 ) == ';' ) ) break ; p += strlen ( p ) ; if ( ( size_t ) ( p - sixel_buffer + MagickPathExtent + 1 ) < length ) continue ; length <<= 1 ; sixel_buffer = ( char * ) ResizeQuantumMemory ( sixel_buffer , length + MagickPathExtent + 1 , sizeof ( * sixel_buffer ) ) ; if ( sixel_buffer == ( char * ) NULL ) break ; p = sixel_buffer + strlen ( sixel_buffer ) ; } if ( sixel_buffer == ( char * ) NULL ) ThrowReaderException ( ResourceLimitError , \"MemoryAllocationFailed\" ) ; sixel_buffer [ length ] = '\\\\0' ; if ( sixel_decode ( image , ( unsigned char * ) sixel_buffer , & sixel_pixels , & image -> columns , & image -> rows , & sixel_palette , & image -> colors , exception ) == MagickFalse ) { <S2SV_StartBug> sixel_buffer = ( char * ) RelinquishMagickMemory ( sixel_buffer ) ; <S2SV_EndBug> ThrowReaderException ( CorruptImageError , \"CorruptImage\" ) ; } sixel_buffer = ( char * ) RelinquishMagickMemory ( sixel_buffer ) ; image -> depth = 24 ; image -> storage_class = PseudoClass ; status = SetImageExtent ( image , image -> columns , image -> rows , exception ) ; if ( status == MagickFalse ) { sixel_pixels = ( unsigned char * ) RelinquishMagickMemory ( sixel_pixels ) ; sixel_palette = ( unsigned char * ) RelinquishMagickMemory ( sixel_palette ) ; return ( DestroyImageList ( image ) ) ; } if ( AcquireImageColormap ( image , image -> colors , exception ) == MagickFalse ) { sixel_pixels = ( unsigned char * ) RelinquishMagickMemory ( sixel_pixels ) ; sixel_palette = ( unsigned char * ) RelinquishMagickMemory ( sixel_palette ) ; ThrowReaderException ( ResourceLimitError , \"MemoryAllocationFailed\" ) ; } for ( i = 0 ; i < ( ssize_t ) image -> colors ; ++ i ) { image -> colormap [ i ] . red = ScaleCharToQuantum ( sixel_palette [ i * 4 + 0 ] ) ; image -> colormap [ i ] . green = ScaleCharToQuantum ( sixel_palette [ i * 4 + 1 ] ) ; image -> colormap [ i ] . blue = ScaleCharToQuantum ( sixel_palette [ i * 4 + 2 ] ) ; } j = 0 ; if ( image_info -> ping == MagickFalse ) { for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { j = ( ssize_t ) sixel_pixels [ y * image -> columns + x ] ; SetPixelIndex ( image , j , q ) ; q += GetPixelChannels ( image ) ; } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; } if ( y < ( ssize_t ) image -> rows ) { sixel_pixels = ( unsigned char * ) RelinquishMagickMemory ( sixel_pixels ) ; sixel_palette = ( unsigned char * ) RelinquishMagickMemory ( sixel_palette ) ; ThrowReaderException ( CorruptImageError , \"NotEnoughPixelData\" ) ; } } sixel_pixels = ( unsigned char * ) RelinquishMagickMemory ( sixel_pixels ) ; sixel_palette = ( unsigned char * ) RelinquishMagickMemory ( sixel_palette ) ; ( void ) CloseBlob ( image ) ; return ( GetFirstImageInList ( image ) ) ; }\n","target":"<S2SV_ModStart> RelinquishMagickMemory ( sixel_buffer ) ; sixel_pixels = ( unsigned char * ) RelinquishMagickMemory ( sixel_pixels\n","project_and_commit_id":"ImageMagick@ImageMagick/748a03651e5b138bcaf160d15133de2f4b1b89ce","cve_id":"CVE-2019-7396","original_address":"https://github.com/ImageMagick/ImageMagick/commit/748a03651e5b138bcaf160d15133de2f4b1b89ce","time":"2019-02-05T00:29Z"},
	{"Unnamed: 0":2152,"cwe_id":"CWE-20","source":"CWE-20 static void rose_loopback_timer ( unsigned long param ) { struct sk_buff * skb ; struct net_device * dev ; rose_address * dest ; struct sock * sk ; unsigned short frametype ; unsigned int lci_i , lci_o ; <S2SV_StartBug> while ( ( skb = skb_dequeue ( & loopback_queue ) ) != NULL ) { <S2SV_EndBug> lci_i = ( ( skb -> data [ 0 ] << 8 ) & 0xF00 ) + ( ( skb -> data [ 1 ] << 0 ) & 0x0FF ) ; frametype = skb -> data [ 2 ] ; <S2SV_StartBug> dest = ( rose_address * ) ( skb -> data + 4 ) ; <S2SV_EndBug> lci_o = ROSE_DEFAULT_MAXVC + 1 - lci_i ; skb_reset_transport_header ( skb ) ; sk = rose_find_socket ( lci_o , rose_loopback_neigh ) ; if ( sk ) { if ( rose_process_rx_frame ( sk , skb ) == 0 ) kfree_skb ( skb ) ; continue ; } if ( frametype == ROSE_CALL_REQUEST ) { if ( ( dev = rose_dev_get ( dest ) ) != NULL ) { if ( rose_rx_call_request ( skb , dev , rose_loopback_neigh , lci_o ) == 0 ) kfree_skb ( skb ) ; } else { kfree_skb ( skb ) ; } } else { kfree_skb ( skb ) ; } } }\n","target":"<S2SV_ModStart> NULL ) { if ( skb -> len < ROSE_MIN_LEN ) { kfree_skb ( skb ) ; continue ; } <S2SV_ModStart> 2 ] ; if ( frametype == ROSE_CALL_REQUEST && ( skb -> len <= ROSE_CALL_REQ_FACILITIES_OFF || skb -> data [ ROSE_CALL_REQ_ADDR_LEN_OFF ] != ROSE_CALL_REQ_ADDR_LEN_VAL ) ) { kfree_skb ( skb ) ; continue ; } <S2SV_ModStart> -> data + ROSE_CALL_REQ_DEST_ADDR_OFF <S2SV_ModEnd> ) ; lci_o\n","project_and_commit_id":"torvalds@linux/e0bccd315db0c2f919e7fcf9cb60db21d9986f52","cve_id":"CVE-2011-4914","original_address":"https://github.com/torvalds/linux/commit/e0bccd315db0c2f919e7fcf9cb60db21d9986f52","time":"2012-06-21T23:55Z"},
	{"Unnamed: 0":3155,"cwe_id":"CWE-200","source":"CWE-200 static int rose_recvmsg ( struct kiocb * iocb , struct socket * sock , struct msghdr * msg , size_t size , int flags ) { struct sock * sk = sock -> sk ; struct rose_sock * rose = rose_sk ( sk ) ; struct sockaddr_rose * srose = ( struct sockaddr_rose * ) msg -> msg_name ; size_t copied ; unsigned char * asmptr ; struct sk_buff * skb ; int n , er , qbit ; if ( sk -> sk_state != TCP_ESTABLISHED ) return - ENOTCONN ; if ( ( skb = skb_recv_datagram ( sk , flags & ~ MSG_DONTWAIT , flags & MSG_DONTWAIT , & er ) ) == NULL ) return er ; qbit = ( skb -> data [ 0 ] & ROSE_Q_BIT ) == ROSE_Q_BIT ; skb_pull ( skb , ROSE_MIN_LEN ) ; if ( rose -> qbitincl ) { asmptr = skb_push ( skb , 1 ) ; * asmptr = qbit ; } skb_reset_transport_header ( skb ) ; copied = skb -> len ; if ( copied > size ) { copied = size ; msg -> msg_flags |= MSG_TRUNC ; } skb_copy_datagram_iovec ( skb , 0 , msg -> msg_iov , copied ) ; if ( srose != NULL ) { <S2SV_StartBug> srose -> srose_family = AF_ROSE ; <S2SV_EndBug> srose -> srose_addr = rose -> dest_addr ; srose -> srose_call = rose -> dest_call ; srose -> srose_ndigis = rose -> dest_ndigis ; if ( msg -> msg_namelen >= sizeof ( struct full_sockaddr_rose ) ) { struct full_sockaddr_rose * full_srose = ( struct full_sockaddr_rose * ) msg -> msg_name ; for ( n = 0 ; n < rose -> dest_ndigis ; n ++ ) full_srose -> srose_digis [ n ] = rose -> dest_digis [ n ] ; msg -> msg_namelen = sizeof ( struct full_sockaddr_rose ) ; } else { if ( rose -> dest_ndigis >= 1 ) { srose -> srose_ndigis = 1 ; srose -> srose_digi = rose -> dest_digis [ 0 ] ; } msg -> msg_namelen = sizeof ( struct sockaddr_rose ) ; } } skb_free_datagram ( sk , skb ) ; return copied ; }\n","target":"<S2SV_ModStart> NULL ) { memset ( srose , 0 , msg -> msg_namelen ) ;\n","project_and_commit_id":"torvalds@linux/4a184233f21645cf0b719366210ed445d1024d72","cve_id":"CVE-2013-3234","original_address":"https://github.com/torvalds/linux/commit/4a184233f21645cf0b719366210ed445d1024d72","time":"2013-04-22T11:41Z"},
	{"Unnamed: 0":2635,"cwe_id":"CWE-119","source":"CWE-119 static void define_gf_group ( VP8_COMP * cpi , FIRSTPASS_STATS * this_frame ) { FIRSTPASS_STATS next_frame ; FIRSTPASS_STATS * start_pos ; int i ; double r ; double boost_score = 0.0 ; double old_boost_score = 0.0 ; double gf_group_err = 0.0 ; double gf_first_frame_err = 0.0 ; double mod_frame_err = 0.0 ; double mv_ratio_accumulator = 0.0 ; double decay_accumulator = 1.0 ; double loop_decay_rate = 1.00 ; double this_frame_mv_in_out = 0.0 ; double mv_in_out_accumulator = 0.0 ; double abs_mv_in_out_accumulator = 0.0 ; double mod_err_per_mb_accumulator = 0.0 ; int max_bits = frame_max_bits ( cpi ) ; unsigned int allow_alt_ref = cpi -> oxcf . play_alternate && cpi -> oxcf . lag_in_frames ; int alt_boost = 0 ; int f_boost = 0 ; int b_boost = 0 ; int flash_detected ; cpi -> twopass . gf_group_bits = 0 ; cpi -> twopass . gf_decay_rate = 0 ; vp8_clear_system_state ( ) ; start_pos = cpi -> twopass . stats_in ; <S2SV_StartBug> vpx_memset ( & next_frame , 0 , sizeof ( next_frame ) ) ; <S2SV_EndBug> mod_frame_err = calculate_modified_err ( cpi , this_frame ) ; gf_first_frame_err = mod_frame_err ; if ( cpi -> common . frame_type == KEY_FRAME ) gf_group_err -= gf_first_frame_err ; i = 0 ; while ( ( ( i < cpi -> twopass . static_scene_max_gf_interval ) || ( ( cpi -> twopass . frames_to_key - i ) < MIN_GF_INTERVAL ) ) && ( i < cpi -> twopass . frames_to_key ) ) { i ++ ; mod_frame_err = calculate_modified_err ( cpi , this_frame ) ; gf_group_err += mod_frame_err ; mod_err_per_mb_accumulator += mod_frame_err / DOUBLE_DIVIDE_CHECK ( ( double ) cpi -> common . MBs ) ; if ( EOF == input_stats ( cpi , & next_frame ) ) break ; flash_detected = detect_flash ( cpi , 0 ) ; accumulate_frame_motion_stats ( cpi , & next_frame , & this_frame_mv_in_out , & mv_in_out_accumulator , & abs_mv_in_out_accumulator , & mv_ratio_accumulator ) ; r = calc_frame_boost ( cpi , & next_frame , this_frame_mv_in_out ) ; if ( ! flash_detected ) { loop_decay_rate = get_prediction_decay_rate ( cpi , & next_frame ) ; decay_accumulator = decay_accumulator * loop_decay_rate ; decay_accumulator = decay_accumulator < 0.1 ? 0.1 : decay_accumulator ; } boost_score += ( decay_accumulator * r ) ; if ( detect_transition_to_still ( cpi , i , 5 , loop_decay_rate , decay_accumulator ) ) { allow_alt_ref = 0 ; boost_score = old_boost_score ; break ; } if ( ( i >= cpi -> max_gf_interval && ( decay_accumulator < 0.995 ) ) || ( ( i > MIN_GF_INTERVAL ) && ( ( cpi -> twopass . frames_to_key - i ) >= MIN_GF_INTERVAL ) && ( ( boost_score > 20.0 ) || ( next_frame . pcnt_inter < 0.75 ) ) && ( ! flash_detected ) && ( ( mv_ratio_accumulator > 100.0 ) || ( abs_mv_in_out_accumulator > 3.0 ) || ( mv_in_out_accumulator < - 2.0 ) || ( ( boost_score - old_boost_score ) < 2.0 ) ) ) ) { boost_score = old_boost_score ; break ; } <S2SV_StartBug> vpx_memcpy ( this_frame , & next_frame , sizeof ( * this_frame ) ) ; <S2SV_EndBug> old_boost_score = boost_score ; } cpi -> twopass . gf_decay_rate = ( i > 0 ) ? ( int ) ( 100.0 * ( 1.0 - decay_accumulator ) ) / i : 0 ; if ( cpi -> oxcf . end_usage == USAGE_STREAM_FROM_SERVER ) { double max_boost ; if ( cpi -> drop_frames_allowed ) { int64_t df_buffer_level = cpi -> oxcf . drop_frames_water_mark * ( cpi -> oxcf . optimal_buffer_level / 100 ) ; if ( cpi -> buffer_level > df_buffer_level ) max_boost = ( ( double ) ( ( cpi -> buffer_level - df_buffer_level ) * 2 / 3 ) * 16.0 ) / DOUBLE_DIVIDE_CHECK ( ( double ) cpi -> av_per_frame_bandwidth ) ; else max_boost = 0.0 ; } else if ( cpi -> buffer_level > 0 ) { max_boost = ( ( double ) ( cpi -> buffer_level * 2 / 3 ) * 16.0 ) / DOUBLE_DIVIDE_CHECK ( ( double ) cpi -> av_per_frame_bandwidth ) ; } else { max_boost = 0.0 ; } if ( boost_score > max_boost ) boost_score = max_boost ; } if ( ( cpi -> twopass . frames_to_key - i ) < MIN_GF_INTERVAL ) { while ( i < cpi -> twopass . frames_to_key ) { i ++ ; if ( EOF == input_stats ( cpi , this_frame ) ) break ; if ( i < cpi -> twopass . frames_to_key ) { mod_frame_err = calculate_modified_err ( cpi , this_frame ) ; gf_group_err += mod_frame_err ; } } } cpi -> gfu_boost = ( int ) ( boost_score * 100.0 ) >> 4 ; # if NEW_BOOST alt_boost = calc_arf_boost ( cpi , 0 , ( i - 1 ) , ( i - 1 ) , & f_boost , & b_boost ) ; # endif if ( allow_alt_ref && ( i >= MIN_GF_INTERVAL ) && ( i <= ( cpi -> twopass . frames_to_key - MIN_GF_INTERVAL ) ) && # if NEW_BOOST ( ( next_frame . pcnt_inter > 0.75 ) || ( next_frame . pcnt_second_ref > 0.5 ) ) && ( ( mv_in_out_accumulator / ( double ) i > - 0.2 ) || ( mv_in_out_accumulator > - 2.0 ) ) && ( b_boost > 100 ) && ( f_boost > 100 ) ) # else ( next_frame . pcnt_inter > 0.75 ) && ( ( mv_in_out_accumulator / ( double ) i > - 0.2 ) || ( mv_in_out_accumulator > - 2.0 ) ) && ( cpi -> gfu_boost > 100 ) && ( cpi -> twopass . gf_decay_rate <= ( ARF_DECAY_THRESH + ( cpi -> gfu_boost / 200 ) ) ) ) # endif { int Boost ; int allocation_chunks ; int Q = ( cpi -> oxcf . fixed_q < 0 ) ? cpi -> last_q [ INTER_FRAME ] : cpi -> oxcf . fixed_q ; int tmp_q ; int arf_frame_bits = 0 ; int group_bits ; # if NEW_BOOST cpi -> gfu_boost = alt_boost ; # endif if ( ( cpi -> twopass . kf_group_bits > 0 ) && ( cpi -> twopass . kf_group_error_left > 0 ) ) { group_bits = ( int ) ( ( double ) cpi -> twopass . kf_group_bits * ( gf_group_err / ( double ) cpi -> twopass . kf_group_error_left ) ) ; } else group_bits = 0 ; # if NEW_BOOST Boost = ( alt_boost * GFQ_ADJUSTMENT ) / 100 ; # else Boost = ( cpi -> gfu_boost * 3 * GFQ_ADJUSTMENT ) / ( 2 * 100 ) ; # endif Boost += ( i * 50 ) ; if ( Boost > ( ( cpi -> baseline_gf_interval + 1 ) * 200 ) ) Boost = ( ( cpi -> baseline_gf_interval + 1 ) * 200 ) ; else if ( Boost < 125 ) Boost = 125 ; allocation_chunks = ( i * 100 ) + Boost ; while ( Boost > 1000 ) { Boost /= 2 ; allocation_chunks /= 2 ; } arf_frame_bits = ( int ) ( ( double ) Boost * ( group_bits / ( double ) allocation_chunks ) ) ; tmp_q = estimate_q ( cpi , mod_frame_err , ( int ) arf_frame_bits ) ; if ( tmp_q < cpi -> worst_quality ) { int half_gf_int ; int frames_after_arf ; int frames_bwd = cpi -> oxcf . arnr_max_frames - 1 ; int frames_fwd = cpi -> oxcf . arnr_max_frames - 1 ; cpi -> source_alt_ref_pending = 1 ; cpi -> baseline_gf_interval = i ; half_gf_int = cpi -> baseline_gf_interval >> 1 ; frames_after_arf = ( int ) ( cpi -> twopass . total_stats . count - this_frame -> frame - 1 ) ; switch ( cpi -> oxcf . arnr_type ) { case 1 : frames_fwd = 0 ; if ( frames_bwd > half_gf_int ) frames_bwd = half_gf_int ; break ; case 2 : if ( frames_fwd > half_gf_int ) frames_fwd = half_gf_int ; if ( frames_fwd > frames_after_arf ) frames_fwd = frames_after_arf ; frames_bwd = 0 ; break ; case 3 : default : frames_fwd >>= 1 ; if ( frames_fwd > frames_after_arf ) frames_fwd = frames_after_arf ; if ( frames_fwd > half_gf_int ) frames_fwd = half_gf_int ; frames_bwd = frames_fwd ; if ( frames_bwd < half_gf_int ) frames_bwd += ( cpi -> oxcf . arnr_max_frames + 1 ) & 0x1 ; break ; } cpi -> active_arnr_frames = frames_bwd + 1 + frames_fwd ; } else { cpi -> source_alt_ref_pending = 0 ; cpi -> baseline_gf_interval = i ; } } else { cpi -> source_alt_ref_pending = 0 ; cpi -> baseline_gf_interval = i ; } if ( cpi -> twopass . frames_to_key >= ( int ) ( cpi -> twopass . total_stats . count - cpi -> common . current_video_frame ) ) { cpi -> twopass . kf_group_bits = ( cpi -> twopass . bits_left > 0 ) ? cpi -> twopass . bits_left : 0 ; } if ( ( cpi -> twopass . kf_group_bits > 0 ) && ( cpi -> twopass . kf_group_error_left > 0 ) ) { cpi -> twopass . gf_group_bits = ( int64_t ) ( cpi -> twopass . kf_group_bits * ( gf_group_err / cpi -> twopass . kf_group_error_left ) ) ; } else cpi -> twopass . gf_group_bits = 0 ; cpi -> twopass . gf_group_bits = ( cpi -> twopass . gf_group_bits < 0 ) ? 0 : ( cpi -> twopass . gf_group_bits > cpi -> twopass . kf_group_bits ) ? cpi -> twopass . kf_group_bits : cpi -> twopass . gf_group_bits ; if ( cpi -> twopass . gf_group_bits > ( int64_t ) max_bits * cpi -> baseline_gf_interval ) cpi -> twopass . gf_group_bits = ( int64_t ) max_bits * cpi -> baseline_gf_interval ; reset_fpf_position ( cpi , start_pos ) ; cpi -> twopass . modified_error_used += gf_group_err ; for ( i = 0 ; i <= ( cpi -> source_alt_ref_pending && cpi -> common . frame_type != KEY_FRAME ) ; i ++ ) { int Boost ; int allocation_chunks ; int Q = ( cpi -> oxcf . fixed_q < 0 ) ? cpi -> last_q [ INTER_FRAME ] : cpi -> oxcf . fixed_q ; int gf_bits ; if ( cpi -> source_alt_ref_pending && i == 0 ) { # if NEW_BOOST Boost = ( alt_boost * GFQ_ADJUSTMENT ) / 100 ; # else Boost = ( cpi -> gfu_boost * 3 * GFQ_ADJUSTMENT ) / ( 2 * 100 ) ; # endif Boost += ( cpi -> baseline_gf_interval * 50 ) ; if ( Boost > ( ( cpi -> baseline_gf_interval + 1 ) * 200 ) ) Boost = ( ( cpi -> baseline_gf_interval + 1 ) * 200 ) ; else if ( Boost < 125 ) Boost = 125 ; allocation_chunks = ( ( cpi -> baseline_gf_interval + 1 ) * 100 ) + Boost ; } else { Boost = ( cpi -> gfu_boost * GFQ_ADJUSTMENT ) / 100 ; if ( Boost > ( cpi -> baseline_gf_interval * 150 ) ) Boost = ( cpi -> baseline_gf_interval * 150 ) ; else if ( Boost < 125 ) Boost = 125 ; allocation_chunks = ( cpi -> baseline_gf_interval * 100 ) + ( Boost - 100 ) ; } while ( Boost > 1000 ) { Boost /= 2 ; allocation_chunks /= 2 ; } gf_bits = ( int ) ( ( double ) Boost * ( cpi -> twopass . gf_group_bits / ( double ) allocation_chunks ) ) ; if ( mod_frame_err < gf_group_err / ( double ) cpi -> baseline_gf_interval ) { double alt_gf_grp_bits ; int alt_gf_bits ; alt_gf_grp_bits = ( double ) cpi -> twopass . kf_group_bits * ( mod_frame_err * ( double ) cpi -> baseline_gf_interval ) / DOUBLE_DIVIDE_CHECK ( ( double ) cpi -> twopass . kf_group_error_left ) ; alt_gf_bits = ( int ) ( ( double ) Boost * ( alt_gf_grp_bits / ( double ) allocation_chunks ) ) ; if ( gf_bits > alt_gf_bits ) { gf_bits = alt_gf_bits ; } } else { int alt_gf_bits = ( int ) ( ( double ) cpi -> twopass . kf_group_bits * mod_frame_err / DOUBLE_DIVIDE_CHECK ( ( double ) cpi -> twopass . kf_group_error_left ) ) ; if ( alt_gf_bits > gf_bits ) { gf_bits = alt_gf_bits ; } } if ( cpi -> oxcf . end_usage == USAGE_STREAM_FROM_SERVER ) { if ( cpi -> twopass . gf_bits > ( int ) ( cpi -> buffer_level >> 1 ) ) cpi -> twopass . gf_bits = ( int ) ( cpi -> buffer_level >> 1 ) ; } if ( gf_bits < 0 ) gf_bits = 0 ; gf_bits += cpi -> min_frame_bandwidth ; if ( i == 0 ) { cpi -> twopass . gf_bits = gf_bits ; } if ( i == 1 || ( ! cpi -> source_alt_ref_pending && ( cpi -> common . frame_type != KEY_FRAME ) ) ) { cpi -> per_frame_bandwidth = gf_bits ; } } { cpi -> twopass . kf_group_error_left -= ( int64_t ) gf_group_err ; cpi -> twopass . kf_group_bits -= cpi -> twopass . gf_group_bits ; if ( cpi -> twopass . kf_group_bits < 0 ) cpi -> twopass . kf_group_bits = 0 ; if ( ! cpi -> source_alt_ref_pending && cpi -> common . frame_type != KEY_FRAME ) cpi -> twopass . gf_group_error_left = ( int ) ( gf_group_err - gf_first_frame_err ) ; else cpi -> twopass . gf_group_error_left = ( int ) gf_group_err ; cpi -> twopass . gf_group_bits -= cpi -> twopass . gf_bits - cpi -> min_frame_bandwidth ; if ( cpi -> twopass . gf_group_bits < 0 ) cpi -> twopass . gf_group_bits = 0 ; if ( cpi -> baseline_gf_interval >= 3 ) { # if NEW_BOOST int boost = ( cpi -> source_alt_ref_pending ) ? b_boost : cpi -> gfu_boost ; # else int boost = cpi -> gfu_boost ; # endif if ( boost >= 150 ) { int pct_extra ; pct_extra = ( boost - 100 ) / 50 ; pct_extra = ( pct_extra > 20 ) ? 20 : pct_extra ; cpi -> twopass . alt_extra_bits = ( int ) ( cpi -> twopass . gf_group_bits * pct_extra ) / 100 ; cpi -> twopass . gf_group_bits -= cpi -> twopass . alt_extra_bits ; cpi -> twopass . alt_extra_bits /= ( ( cpi -> baseline_gf_interval - 1 ) >> 1 ) ; } else cpi -> twopass . alt_extra_bits = 0 ; } else cpi -> twopass . alt_extra_bits = 0 ; } if ( cpi -> common . frame_type != KEY_FRAME ) { FIRSTPASS_STATS sectionstats ; double Ratio ; zero_stats ( & sectionstats ) ; reset_fpf_position ( cpi , start_pos ) ; for ( i = 0 ; i < cpi -> baseline_gf_interval ; i ++ ) { input_stats ( cpi , & next_frame ) ; accumulate_stats ( & sectionstats , & next_frame ) ; } avg_stats ( & sectionstats ) ; cpi -> twopass . section_intra_rating = ( unsigned int ) ( sectionstats . intra_error / DOUBLE_DIVIDE_CHECK ( sectionstats . coded_error ) ) ; Ratio = sectionstats . intra_error / DOUBLE_DIVIDE_CHECK ( sectionstats . coded_error ) ; cpi -> twopass . section_max_qfactor = 1.0 - ( ( Ratio - 10.0 ) * 0.025 ) ; if ( cpi -> twopass . section_max_qfactor < 0.80 ) cpi -> twopass . section_max_qfactor = 0.80 ; reset_fpf_position ( cpi , start_pos ) ; } }\n","target":"<S2SV_ModStart> . stats_in ; memset <S2SV_ModEnd> ( & next_frame <S2SV_ModStart> break ; } memcpy <S2SV_ModEnd> ( this_frame ,\n","project_and_commit_id":"external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426","cve_id":"CVE-2016-1621","original_address":"https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426","time":"2016-03-12T21:59Z"},
	{"Unnamed: 0":4574,"cwe_id":"CWE-772","source":"CWE-772 gprincs_ret * get_princs_2_svc ( gprincs_arg * arg , struct svc_req * rqstp ) { static gprincs_ret ret ; char * prime_arg ; <S2SV_StartBug> gss_buffer_desc client_name , <S2SV_EndBug> service_name ; OM_uint32 minor_stat ; kadm5_server_handle_t handle ; const char * errmsg = NULL ; xdr_free ( xdr_gprincs_ret , & ret ) ; if ( ( ret . code = new_server_handle ( arg -> api_version , rqstp , & handle ) ) ) goto exit_func ; if ( ( ret . code = check_handle ( ( void * ) handle ) ) ) goto exit_func ; ret . api_version = handle -> api_version ; if ( setup_gss_names ( rqstp , & client_name , & service_name ) < 0 ) { ret . code = KADM5_FAILURE ; goto exit_func ; } prime_arg = arg -> exp ; if ( prime_arg == NULL ) prime_arg = \"*\" ; if ( CHANGEPW_SERVICE ( rqstp ) || ! kadm5int_acl_check ( handle -> context , rqst2name ( rqstp ) , ACL_LIST , NULL , NULL ) ) { ret . code = KADM5_AUTH_LIST ; log_unauth ( \"kadm5_get_principals\" , prime_arg , & client_name , & service_name , rqstp ) ; } else { ret . code = kadm5_get_principals ( ( void * ) handle , arg -> exp , & ret . princs , & ret . count ) ; if ( ret . code != 0 ) errmsg = krb5_get_error_message ( handle -> context , ret . code ) ; log_done ( \"kadm5_get_principals\" , prime_arg , errmsg , & client_name , & service_name , rqstp ) ; if ( errmsg != NULL ) krb5_free_error_message ( handle -> context , errmsg ) ; } <S2SV_StartBug> gss_release_buffer ( & minor_stat , & client_name ) ; <S2SV_EndBug> gss_release_buffer ( & minor_stat , & service_name ) ; exit_func : free_server_handle ( handle ) ; return & ret ; }\n","target":"<S2SV_ModStart> ; gss_buffer_desc client_name = GSS_C_EMPTY_BUFFER ; gss_buffer_desc service_name = GSS_C_EMPTY_BUFFER <S2SV_ModEnd> ; OM_uint32 minor_stat <S2SV_ModStart> ) ; } exit_func : gss_release_buffer ( & minor_stat , & client_name ) ; gss_release_buffer ( & minor_stat , & service_name ) ; <S2SV_ModEnd> free_server_handle ( handle\n","project_and_commit_id":"krb5@krb5/83ed75feba32e46f736fcce0d96a0445f29b96c2","cve_id":"CVE-2015-8631","original_address":"https://github.com/krb5/krb5/commit/83ed75feba32e46f736fcce0d96a0445f29b96c2","time":"2016-02-13T02:59Z"},
	{"Unnamed: 0":1194,"cwe_id":"CWE-74","source":"CWE-74 int nntp_open_connection ( struct NntpAccountData * adata ) { struct Connection * conn = adata -> conn ; char buf [ 256 ] ; int cap ; bool posting = false , auth = true ; if ( adata -> status == NNTP_OK ) return 0 ; if ( adata -> status == NNTP_BYE ) return - 1 ; adata -> status = NNTP_NONE ; if ( mutt_socket_open ( conn ) < 0 ) return - 1 ; if ( mutt_socket_readln ( buf , sizeof ( buf ) , conn ) < 0 ) return nntp_connect_error ( adata ) ; if ( mutt_str_startswith ( buf , \"200\" , CASE_MATCH ) ) posting = true ; else if ( ! mutt_str_startswith ( buf , \"201\" , CASE_MATCH ) ) { mutt_socket_close ( conn ) ; mutt_str_remove_trailing_ws ( buf ) ; mutt_error ( \"%s\" , buf ) ; return - 1 ; } cap = nntp_capabilities ( adata ) ; if ( cap < 0 ) return - 1 ; if ( cap > 0 ) { if ( ( mutt_socket_send ( conn , \"MODE<S2SV_blank>READER\\\\r\\\\n\" ) < 0 ) || ( mutt_socket_readln ( buf , sizeof ( buf ) , conn ) < 0 ) ) { return nntp_connect_error ( adata ) ; } if ( mutt_str_startswith ( buf , \"200\" , CASE_MATCH ) ) posting = true ; else if ( mutt_str_startswith ( buf , \"201\" , CASE_MATCH ) ) posting = false ; else if ( adata -> hasCAPABILITIES ) { mutt_socket_close ( conn ) ; mutt_error ( _ ( \"Could<S2SV_blank>not<S2SV_blank>switch<S2SV_blank>to<S2SV_blank>reader<S2SV_blank>mode\" ) ) ; return - 1 ; } if ( adata -> hasCAPABILITIES ) { cap = nntp_capabilities ( adata ) ; if ( cap < 0 ) return - 1 ; } } mutt_message ( _ ( \"Connected<S2SV_blank>to<S2SV_blank>%s.<S2SV_blank>%s\" ) , conn -> account . host , posting ? _ ( \"Posting<S2SV_blank>is<S2SV_blank>ok\" ) : _ ( \"Posting<S2SV_blank>is<S2SV_blank>NOT<S2SV_blank>ok\" ) ) ; mutt_sleep ( 1 ) ; # ifdef USE_SSL if ( ( adata -> use_tls != 1 ) && ( adata -> hasSTARTTLS || C_SslForceTls ) ) { if ( adata -> use_tls == 0 ) { adata -> use_tls = C_SslForceTls || query_quadoption ( C_SslStarttls , _ ( \"Secure<S2SV_blank>connection<S2SV_blank>with<S2SV_blank>TLS?\" ) ) == MUTT_YES ? 2 : 1 ; } if ( adata -> use_tls == 2 ) { if ( ( mutt_socket_send ( conn , \"STARTTLS\\\\r\\\\n\" ) < 0 ) || ( mutt_socket_readln ( buf , sizeof ( buf ) , conn ) < 0 ) ) { return nntp_connect_error ( adata ) ; <S2SV_StartBug> } <S2SV_EndBug> if ( ! mutt_str_startswith ( buf , \"382\" , CASE_MATCH ) ) { adata -> use_tls = 0 ; mutt_error ( \"STARTTLS:<S2SV_blank>%s\" , buf ) ; } else if ( mutt_ssl_starttls ( conn ) ) { adata -> use_tls = 0 ; adata -> status = NNTP_NONE ; mutt_socket_close ( adata -> conn ) ; mutt_error ( _ ( \"Could<S2SV_blank>not<S2SV_blank>negotiate<S2SV_blank>TLS<S2SV_blank>connection\" ) ) ; return - 1 ; } else { cap = nntp_capabilities ( adata ) ; if ( cap < 0 ) return - 1 ; } } } # endif if ( conn -> account . flags & MUTT_ACCT_USER ) { if ( ! conn -> account . user [ 0 ] ) auth = false ; } else { if ( ( mutt_socket_send ( conn , \"STAT\\\\r\\\\n\" ) < 0 ) || ( mutt_socket_readln ( buf , sizeof ( buf ) , conn ) < 0 ) ) { return nntp_connect_error ( adata ) ; } if ( ! mutt_str_startswith ( buf , \"480\" , CASE_MATCH ) ) auth = false ; } if ( auth && ( nntp_auth ( adata ) < 0 ) ) return - 1 ; if ( adata -> hasCAPABILITIES && ( auth || ( cap > 0 ) ) ) { cap = nntp_capabilities ( adata ) ; if ( cap < 0 ) return - 1 ; if ( cap > 0 ) { mutt_socket_close ( conn ) ; mutt_error ( _ ( \"Could<S2SV_blank>not<S2SV_blank>switch<S2SV_blank>to<S2SV_blank>reader<S2SV_blank>mode\" ) ) ; return - 1 ; } } if ( nntp_attempt_features ( adata ) < 0 ) return - 1 ; adata -> status = NNTP_OK ; return 0 ; }\n","target":"<S2SV_ModStart> ) ; } mutt_socket_empty ( conn ) ;\n","project_and_commit_id":"neomutt@neomutt/fb013ec666759cb8a9e294347c7b4c1f597639cc","cve_id":"CVE-2020-14954","original_address":"https://github.com/neomutt/neomutt/commit/fb013ec666759cb8a9e294347c7b4c1f597639cc","time":"2020-06-21T17:15Z"},
	{"Unnamed: 0":6499,"cwe_id":"CWE-617","source":"CWE-617 int connection_exit_begin_conn ( cell_t * cell , circuit_t * circ ) { edge_connection_t * n_stream ; relay_header_t rh ; char * address = NULL ; uint16_t port = 0 ; <S2SV_StartBug> or_circuit_t * or_circ = NULL ; <S2SV_EndBug> const or_options_t * options = get_options ( ) ; begin_cell_t bcell ; int rv ; uint8_t end_reason = 0 ; assert_circuit_ok ( circ ) ; <S2SV_StartBug> if ( ! CIRCUIT_IS_ORIGIN ( circ ) ) <S2SV_EndBug> <S2SV_StartBug> or_circ = TO_OR_CIRCUIT ( circ ) ; <S2SV_EndBug> relay_header_unpack ( & rh , cell -> payload ) ; if ( rh . length > RELAY_PAYLOAD_SIZE ) return - END_CIRC_REASON_TORPROTOCOL ; if ( ! server_mode ( options ) && circ -> purpose != CIRCUIT_PURPOSE_S_REND_JOINED ) { log_fn ( LOG_PROTOCOL_WARN , LD_PROTOCOL , \"Relay<S2SV_blank>begin<S2SV_blank>cell<S2SV_blank>at<S2SV_blank>non-server.<S2SV_blank>Closing.\" ) ; relay_send_end_cell_from_edge ( rh . stream_id , circ , END_STREAM_REASON_EXITPOLICY , NULL ) ; return 0 ; } rv = begin_cell_parse ( cell , & bcell , & end_reason ) ; if ( rv < - 1 ) { return - END_CIRC_REASON_TORPROTOCOL ; } else if ( rv == - 1 ) { tor_free ( bcell . address ) ; <S2SV_StartBug> relay_send_end_cell_from_edge ( rh . stream_id , circ , end_reason , NULL ) ; <S2SV_EndBug> return 0 ; } if ( ! bcell . is_begindir ) { address = bcell . address ; port = bcell . port ; if ( or_circ && or_circ -> p_chan ) { if ( ! options -> AllowSingleHopExits && ( or_circ -> is_first_hop || ( ! connection_or_digest_is_known_relay ( or_circ -> p_chan -> identity_digest ) && should_refuse_unknown_exits ( options ) ) ) ) { log_fn ( LOG_PROTOCOL_WARN , LD_PROTOCOL , \"Attempt<S2SV_blank>by<S2SV_blank>%s<S2SV_blank>to<S2SV_blank>open<S2SV_blank>a<S2SV_blank>stream<S2SV_blank>%s.<S2SV_blank>Closing.\" , safe_str ( channel_get_canonical_remote_descr ( or_circ -> p_chan ) ) , or_circ -> is_first_hop ? \"on<S2SV_blank>first<S2SV_blank>hop<S2SV_blank>of<S2SV_blank>circuit\" : \"from<S2SV_blank>unknown<S2SV_blank>relay\" ) ; relay_send_end_cell_from_edge ( rh . stream_id , circ , or_circ -> is_first_hop ? END_STREAM_REASON_TORPROTOCOL : END_STREAM_REASON_MISC , NULL ) ; tor_free ( address ) ; return 0 ; } } } else if ( rh . command == RELAY_COMMAND_BEGIN_DIR ) { if ( ! directory_permits_begindir_requests ( options ) || circ -> purpose != CIRCUIT_PURPOSE_OR ) { relay_send_end_cell_from_edge ( rh . stream_id , circ , <S2SV_StartBug> END_STREAM_REASON_NOTDIRECTORY , NULL ) ; <S2SV_EndBug> return 0 ; } if ( or_circ && or_circ -> p_chan ) address = tor_strdup ( channel_get_actual_remote_address ( or_circ -> p_chan ) ) ; else address = tor_strdup ( \"127.0.0.1\" ) ; port = 1 ; } else { log_warn ( LD_BUG , \"Got<S2SV_blank>an<S2SV_blank>unexpected<S2SV_blank>command<S2SV_blank>%d\" , ( int ) rh . command ) ; relay_send_end_cell_from_edge ( rh . stream_id , circ , <S2SV_StartBug> END_STREAM_REASON_INTERNAL , NULL ) ; <S2SV_EndBug> return 0 ; } if ( ! options -> IPv6Exit ) { bcell . flags &= ~ BEGIN_FLAG_IPV6_PREFERRED ; if ( bcell . flags & BEGIN_FLAG_IPV4_NOT_OK ) { tor_free ( address ) ; relay_send_end_cell_from_edge ( rh . stream_id , circ , <S2SV_StartBug> END_STREAM_REASON_EXITPOLICY , NULL ) ; <S2SV_EndBug> return 0 ; } } log_debug ( LD_EXIT , \"Creating<S2SV_blank>new<S2SV_blank>exit<S2SV_blank>connection.\" ) ; n_stream = edge_connection_new ( CONN_TYPE_EXIT , AF_INET ) ; n_stream -> dirreq_id = circ -> dirreq_id ; n_stream -> base_ . purpose = EXIT_PURPOSE_CONNECT ; n_stream -> begincell_flags = bcell . flags ; n_stream -> stream_id = rh . stream_id ; n_stream -> base_ . port = port ; n_stream -> package_window = STREAMWINDOW_START ; n_stream -> deliver_window = STREAMWINDOW_START ; if ( circ -> purpose == CIRCUIT_PURPOSE_S_REND_JOINED ) { <S2SV_StartBug> origin_circuit_t * origin_circ = TO_ORIGIN_CIRCUIT ( circ ) ; <S2SV_EndBug> log_info ( LD_REND , \"begin<S2SV_blank>is<S2SV_blank>for<S2SV_blank>rendezvous.<S2SV_blank>configuring<S2SV_blank>stream.\" ) ; n_stream -> base_ . address = tor_strdup ( \"(rendezvous)\" ) ; n_stream -> base_ . state = EXIT_CONN_STATE_CONNECTING ; n_stream -> rend_data = rend_data_dup ( origin_circ -> rend_data ) ; tor_assert ( connection_edge_is_rendezvous_stream ( n_stream ) ) ; assert_circuit_ok ( circ ) ; const int r = rend_service_set_connection_addr_port ( n_stream , origin_circ ) ; if ( r < 0 ) { log_info ( LD_REND , \"Didn\\'t<S2SV_blank>find<S2SV_blank>rendezvous<S2SV_blank>service<S2SV_blank>(port<S2SV_blank>%d)\" , n_stream -> base_ . port ) ; relay_send_end_cell_from_edge ( rh . stream_id , circ , END_STREAM_REASON_DONE , <S2SV_StartBug> origin_circ -> cpath -> prev ) ; <S2SV_EndBug> connection_free ( TO_CONN ( n_stream ) ) ; tor_free ( address ) ; if ( r < - 1 ) return END_CIRC_AT_ORIGIN ; else return 0 ; } assert_circuit_ok ( circ ) ; log_debug ( LD_REND , \"Finished<S2SV_blank>assigning<S2SV_blank>addr/port\" ) ; n_stream -> cpath_layer = origin_circ -> cpath -> prev ; n_stream -> next_stream = origin_circ -> p_streams ; n_stream -> on_circuit = circ ; origin_circ -> p_streams = n_stream ; assert_circuit_ok ( circ ) ; origin_circ -> rend_data -> nr_streams ++ ; connection_exit_connect ( n_stream ) ; pathbias_mark_use_success ( origin_circ ) ; tor_free ( address ) ; return 0 ; } tor_strlower ( address ) ; n_stream -> base_ . address = address ; n_stream -> base_ . state = EXIT_CONN_STATE_RESOLVEFAILED ; if ( we_are_hibernating ( ) ) { relay_send_end_cell_from_edge ( rh . stream_id , circ , END_STREAM_REASON_HIBERNATING , NULL ) ; connection_free ( TO_CONN ( n_stream ) ) ; return 0 ; } n_stream -> on_circuit = circ ; if ( rh . command == RELAY_COMMAND_BEGIN_DIR ) { tor_addr_t tmp_addr ; tor_assert ( or_circ ) ; if ( or_circ -> p_chan && channel_get_addr_if_possible ( or_circ -> p_chan , & tmp_addr ) ) { tor_addr_copy ( & n_stream -> base_ . addr , & tmp_addr ) ; } return connection_exit_connect_dir ( n_stream ) ; } log_debug ( LD_EXIT , \"about<S2SV_blank>to<S2SV_blank>start<S2SV_blank>the<S2SV_blank>dns_resolve().\" ) ; switch ( dns_resolve ( n_stream ) ) { case 1 : assert_circuit_ok ( circ ) ; log_debug ( LD_EXIT , \"about<S2SV_blank>to<S2SV_blank>call<S2SV_blank>connection_exit_connect().\" ) ; connection_exit_connect ( n_stream ) ; return 0 ; case - 1 : relay_send_end_cell_from_edge ( rh . stream_id , circ , END_STREAM_REASON_RESOLVEFAILED , NULL ) ; break ; case 0 : assert_circuit_ok ( circ ) ; break ; } return 0 ; }\n","target":"<S2SV_ModStart> or_circuit_t * or_circ = NULL ; origin_circuit_t * origin_circ = NULL ; crypt_path_t * layer_hint <S2SV_ModStart> circ ) ) { <S2SV_ModStart> circ ) ; } else { tor_assert ( circ -> purpose == CIRCUIT_PURPOSE_S_REND_JOINED ) ; origin_circ = TO_ORIGIN_CIRCUIT ( circ ) ; layer_hint = origin_circ -> cpath -> prev ; } <S2SV_ModStart> , end_reason , layer_hint <S2SV_ModEnd> ) ; return <S2SV_ModStart> , END_STREAM_REASON_NOTDIRECTORY , layer_hint <S2SV_ModEnd> ) ; return <S2SV_ModStart> , END_STREAM_REASON_INTERNAL , layer_hint <S2SV_ModEnd> ) ; return <S2SV_ModStart> , END_STREAM_REASON_EXITPOLICY , layer_hint <S2SV_ModEnd> ) ; return <S2SV_ModStart> CIRCUIT_PURPOSE_S_REND_JOINED ) { tor_assert ( origin_circ <S2SV_ModEnd> ) ; log_info <S2SV_ModStart> , END_STREAM_REASON_DONE , layer_hint <S2SV_ModEnd> ) ; connection_free\n","project_and_commit_id":"torproject@tor/79b59a2dfcb68897ee89d98587d09e55f07e68d7","cve_id":"CVE-2017-0375","original_address":"https://github.com/torproject/tor/commit/79b59a2dfcb68897ee89d98587d09e55f07e68d7","time":"2017-06-09T17:29Z"},
	{"Unnamed: 0":4144,"cwe_id":"CWE-674","source":"CWE-674 static void Sp_match ( js_State * J ) { js_Regexp * re ; const char * text ; int len ; const char * a , * b , * c , * e ; Resub m ; text = checkstring ( J , 0 ) ; if ( js_isregexp ( J , 1 ) ) js_copy ( J , 1 ) ; else if ( js_isundefined ( J , 1 ) ) js_newregexp ( J , \"\" , 0 ) ; else js_newregexp ( J , js_tostring ( J , 1 ) , 0 ) ; re = js_toregexp ( J , - 1 ) ; if ( ! ( re -> flags & JS_REGEXP_G ) ) { js_RegExp_prototype_exec ( J , re , text ) ; return ; } re -> last = 0 ; js_newarray ( J ) ; len = 0 ; a = text ; e = text + strlen ( text ) ; while ( a <= e ) { <S2SV_StartBug> if ( js_regexec ( re -> prog , a , & m , a > text ? REG_NOTBOL : 0 ) ) <S2SV_EndBug> break ; b = m . sub [ 0 ] . sp ; c = m . sub [ 0 ] . ep ; js_pushlstring ( J , b , c - b ) ; js_setindex ( J , - 2 , len ++ ) ; a = c ; if ( c - b == 0 ) ++ a ; } if ( len == 0 ) { js_pop ( J , 1 ) ; js_pushnull ( J ) ; } }\n","target":"<S2SV_ModStart> { if ( js_doregexec ( J , <S2SV_ModEnd> re -> prog\n","project_and_commit_id":"ccxvii@mujs/00d4606c3baf813b7b1c176823b2729bf51002a2","cve_id":"CVE-2019-11413","original_address":"https://github.com/ccxvii/mujs/commit/00d4606c3baf813b7b1c176823b2729bf51002a2","time":"2019-04-22T11:29Z"},
	{"Unnamed: 0":4223,"cwe_id":"CWE-787","source":"CWE-787 static void processCertificateElements ( struct ndpi_detection_module_struct * ndpi_struct , struct ndpi_flow_struct * flow , u_int16_t p_offset , u_int16_t certificate_len ) { struct ndpi_packet_struct * packet = & flow -> packet ; u_int num_found = 0 , i ; <S2SV_StartBug> char buffer [ 64 ] = { '\\\\0' } , rdnSeqBuf [ 1024 ] = { '\\\\0' } ; <S2SV_EndBug> u_int rdn_len = 0 ; # ifdef DEBUG_TLS printf ( \"[TLS]<S2SV_blank>%s()<S2SV_blank>[offset:<S2SV_blank>%u][certificate_len:<S2SV_blank>%u]\\\\n\" , __FUNCTION__ , p_offset , certificate_len ) ; # endif for ( i = p_offset ; i < certificate_len ; i ++ ) { if ( ( packet -> payload [ i ] == 0x55 ) && ( packet -> payload [ i + 1 ] == 0x04 ) && ( packet -> payload [ i + 2 ] == 0x03 ) ) { int rc = extractRDNSequence ( packet , i , buffer , sizeof ( buffer ) , rdnSeqBuf , & rdn_len , sizeof ( rdnSeqBuf ) , \"CN\" ) ; if ( rc == - 1 ) break ; # ifdef DEBUG_TLS printf ( \"[TLS]<S2SV_blank>%s()<S2SV_blank>[%s][%s:<S2SV_blank>%s]\\\\n\" , __FUNCTION__ , ( num_found == 0 ) ? \"Subject\" : \"Issuer\" , \"Common<S2SV_blank>Name\" , buffer ) ; # endif } else if ( ( packet -> payload [ i ] == 0x55 ) && ( packet -> payload [ i + 1 ] == 0x04 ) && ( packet -> payload [ i + 2 ] == 0x06 ) ) { int rc = extractRDNSequence ( packet , i , buffer , sizeof ( buffer ) , rdnSeqBuf , & rdn_len , sizeof ( rdnSeqBuf ) , \"C\" ) ; if ( rc == - 1 ) break ; # ifdef DEBUG_TLS printf ( \"[TLS]<S2SV_blank>%s()<S2SV_blank>[%s][%s:<S2SV_blank>%s]\\\\n\" , __FUNCTION__ , ( num_found == 0 ) ? \"Subject\" : \"Issuer\" , \"Country\" , buffer ) ; # endif } else if ( ( packet -> payload [ i ] == 0x55 ) && ( packet -> payload [ i + 1 ] == 0x04 ) && ( packet -> payload [ i + 2 ] == 0x07 ) ) { int rc = extractRDNSequence ( packet , i , buffer , sizeof ( buffer ) , rdnSeqBuf , & rdn_len , sizeof ( rdnSeqBuf ) , \"L\" ) ; if ( rc == - 1 ) break ; # ifdef DEBUG_TLS printf ( \"[TLS]<S2SV_blank>%s()<S2SV_blank>[%s][%s:<S2SV_blank>%s]\\\\n\" , __FUNCTION__ , ( num_found == 0 ) ? \"Subject\" : \"Issuer\" , \"Locality\" , buffer ) ; # endif } else if ( ( packet -> payload [ i ] == 0x55 ) && ( packet -> payload [ i + 1 ] == 0x04 ) && ( packet -> payload [ i + 2 ] == 0x08 ) ) { int rc = extractRDNSequence ( packet , i , buffer , sizeof ( buffer ) , rdnSeqBuf , & rdn_len , sizeof ( rdnSeqBuf ) , \"ST\" ) ; if ( rc == - 1 ) break ; # ifdef DEBUG_TLS printf ( \"[TLS]<S2SV_blank>%s()<S2SV_blank>[%s][%s:<S2SV_blank>%s]\\\\n\" , __FUNCTION__ , ( num_found == 0 ) ? \"Subject\" : \"Issuer\" , \"State<S2SV_blank>or<S2SV_blank>Province\" , buffer ) ; # endif } else if ( ( packet -> payload [ i ] == 0x55 ) && ( packet -> payload [ i + 1 ] == 0x04 ) && ( packet -> payload [ i + 2 ] == 0x0a ) ) { int rc = extractRDNSequence ( packet , i , buffer , sizeof ( buffer ) , rdnSeqBuf , & rdn_len , sizeof ( rdnSeqBuf ) , \"O\" ) ; if ( rc == - 1 ) break ; # ifdef DEBUG_TLS printf ( \"[TLS]<S2SV_blank>%s()<S2SV_blank>[%s][%s:<S2SV_blank>%s]\\\\n\" , __FUNCTION__ , ( num_found == 0 ) ? \"Subject\" : \"Issuer\" , \"Organization<S2SV_blank>Name\" , buffer ) ; # endif } else if ( ( packet -> payload [ i ] == 0x55 ) && ( packet -> payload [ i + 1 ] == 0x04 ) && ( packet -> payload [ i + 2 ] == 0x0b ) ) { int rc = extractRDNSequence ( packet , i , buffer , sizeof ( buffer ) , rdnSeqBuf , & rdn_len , sizeof ( rdnSeqBuf ) , \"OU\" ) ; if ( rc == - 1 ) break ; # ifdef DEBUG_TLS printf ( \"[TLS]<S2SV_blank>%s()<S2SV_blank>[%s][%s:<S2SV_blank>%s]\\\\n\" , __FUNCTION__ , ( num_found == 0 ) ? \"Subject\" : \"Issuer\" , \"Organization<S2SV_blank>Unit\" , buffer ) ; # endif } else if ( ( packet -> payload [ i ] == 0x30 ) && ( packet -> payload [ i + 1 ] == 0x1e ) && ( packet -> payload [ i + 2 ] == 0x17 ) ) { u_int8_t len = packet -> payload [ i + 3 ] ; u_int offset = i + 4 ; if ( num_found == 0 ) { num_found ++ ; # ifdef DEBUG_TLS printf ( \"[TLS]<S2SV_blank>%s()<S2SV_blank>IssuerDN<S2SV_blank>[%s]\\\\n\" , __FUNCTION__ , rdnSeqBuf ) ; # endif if ( rdn_len ) flow -> protos . stun_ssl . ssl . issuerDN = ndpi_strdup ( rdnSeqBuf ) ; rdn_len = 0 ; } if ( ( offset + len ) < packet -> payload_packet_len ) { char utcDate [ 32 ] ; # ifdef DEBUG_TLS u_int j ; printf ( \"[CERTIFICATE]<S2SV_blank>notBefore<S2SV_blank>[len:<S2SV_blank>%u][\" , len ) ; for ( j = 0 ; j < len ; j ++ ) printf ( \"%c\" , packet -> payload [ i + 4 + j ] ) ; printf ( \"]\\\\n\" ) ; # endif if ( len < ( sizeof ( utcDate ) - 1 ) ) { struct tm utc ; utc . tm_isdst = - 1 ; strncpy ( utcDate , ( const char * ) & packet -> payload [ i + 4 ] , len ) ; utcDate [ len ] = '\\\\0' ; if ( strptime ( utcDate , \"%y%m%d%H%M%SZ\" , & utc ) != NULL ) { flow -> protos . stun_ssl . ssl . notBefore = timegm ( & utc ) ; # ifdef DEBUG_TLS printf ( \"[CERTIFICATE]<S2SV_blank>notBefore<S2SV_blank>%u<S2SV_blank>[%s]\\\\n\" , flow -> protos . stun_ssl . ssl . notBefore , utcDate ) ; # endif } } offset += len ; if ( ( offset + 1 ) < packet -> payload_packet_len ) { len = packet -> payload [ offset + 1 ] ; offset += 2 ; if ( ( offset + len ) < packet -> payload_packet_len ) { u_int32_t time_sec = flow -> packet . current_time_ms / 1000 ; # ifdef DEBUG_TLS u_int j ; printf ( \"[CERTIFICATE]<S2SV_blank>notAfter<S2SV_blank>[len:<S2SV_blank>%u][\" , len ) ; for ( j = 0 ; j < len ; j ++ ) printf ( \"%c\" , packet -> payload [ offset + j ] ) ; printf ( \"]\\\\n\" ) ; # endif if ( len < ( sizeof ( utcDate ) - 1 ) ) { struct tm utc ; utc . tm_isdst = - 1 ; strncpy ( utcDate , ( const char * ) & packet -> payload [ offset ] , len ) ; utcDate [ len ] = '\\\\0' ; if ( strptime ( utcDate , \"%y%m%d%H%M%SZ\" , & utc ) != NULL ) { flow -> protos . stun_ssl . ssl . notAfter = timegm ( & utc ) ; # ifdef DEBUG_TLS printf ( \"[CERTIFICATE]<S2SV_blank>notAfter<S2SV_blank>%u<S2SV_blank>[%s]\\\\n\" , flow -> protos . stun_ssl . ssl . notAfter , utcDate ) ; # endif } } if ( ( time_sec < flow -> protos . stun_ssl . ssl . notBefore ) || ( time_sec > flow -> protos . stun_ssl . ssl . notAfter ) ) NDPI_SET_BIT ( flow -> risk , NDPI_TLS_CERTIFICATE_EXPIRED ) ; } } } } else if ( ( packet -> payload [ i ] == 0x55 ) && ( packet -> payload [ i + 1 ] == 0x1d ) && ( packet -> payload [ i + 2 ] == 0x11 ) ) { u_int8_t matched_name = 0 ; # ifdef DEBUG_TLS printf ( \"*******<S2SV_blank>[TLS]<S2SV_blank>Found<S2SV_blank>subjectAltName\\\\n\" ) ; # endif i += 3 ; i ++ ; if ( i < packet -> payload_packet_len ) { i += ( packet -> payload [ i ] & 0x80 ) ? ( packet -> payload [ i ] & 0x7F ) : 0 ; if ( i < packet -> payload_packet_len ) { i += 2 ; if ( i < packet -> payload_packet_len ) { i += ( packet -> payload [ i ] & 0x80 ) ? ( packet -> payload [ i ] & 0x7F ) : 0 ; i ++ ; while ( i < packet -> payload_packet_len ) { if ( packet -> payload [ i ] == 0x82 ) { if ( ( i < ( packet -> payload_packet_len - 1 ) ) && ( ( i + packet -> payload [ i + 1 ] + 2 ) < packet -> payload_packet_len ) ) { u_int8_t len = packet -> payload [ i + 1 ] ; char dNSName [ 256 ] ; i += 2 ; if ( len == 0 ) break ; strncpy ( dNSName , ( const char * ) & packet -> payload [ i ] , len ) ; dNSName [ len ] = '\\\\0' ; cleanupServerName ( dNSName , len ) ; # if DEBUG_TLS printf ( \"[TLS]<S2SV_blank>dNSName<S2SV_blank>%s<S2SV_blank>[%s]\\\\n\" , dNSName , flow -> protos . stun_ssl . ssl . client_requested_server_name ) ; # endif if ( matched_name == 0 ) { if ( ( dNSName [ 0 ] == '*' ) && strstr ( flow -> protos . stun_ssl . ssl . client_requested_server_name , & dNSName [ 1 ] ) ) matched_name = 1 ; else if ( strcmp ( flow -> protos . stun_ssl . ssl . client_requested_server_name , dNSName ) == 0 ) matched_name = 1 ; } if ( flow -> protos . stun_ssl . ssl . server_names == NULL ) flow -> protos . stun_ssl . ssl . server_names = ndpi_strdup ( dNSName ) , flow -> protos . stun_ssl . ssl . server_names_len = strlen ( dNSName ) ; else { u_int16_t dNSName_len = strlen ( dNSName ) ; u_int16_t newstr_len = flow -> protos . stun_ssl . ssl . server_names_len + dNSName_len + 1 ; char * newstr = ( char * ) ndpi_realloc ( flow -> protos . stun_ssl . ssl . server_names , flow -> protos . stun_ssl . ssl . server_names_len + 1 , newstr_len + 1 ) ; if ( newstr ) { flow -> protos . stun_ssl . ssl . server_names = newstr ; flow -> protos . stun_ssl . ssl . server_names [ flow -> protos . stun_ssl . ssl . server_names_len ] = ',' ; strncpy ( & flow -> protos . stun_ssl . ssl . server_names [ flow -> protos . stun_ssl . ssl . server_names_len + 1 ] , dNSName , dNSName_len + 1 ) ; flow -> protos . stun_ssl . ssl . server_names [ newstr_len ] = '\\\\0' ; flow -> protos . stun_ssl . ssl . server_names_len = newstr_len ; } } if ( ! flow -> l4 . tcp . tls . subprotocol_detected ) if ( ndpi_match_hostname_protocol ( ndpi_struct , flow , NDPI_PROTOCOL_TLS , dNSName , len ) ) flow -> l4 . tcp . tls . subprotocol_detected = 1 ; i += len ; } else { # if DEBUG_TLS printf ( \"[TLS]<S2SV_blank>Leftover<S2SV_blank>%u<S2SV_blank>bytes\" , packet -> payload_packet_len - i ) ; # endif break ; } } else { break ; } } if ( ! matched_name ) NDPI_SET_BIT ( flow -> risk , NDPI_TLS_CERTIFICATE_MISMATCH ) ; } } } } } if ( rdn_len ) flow -> protos . stun_ssl . ssl . subjectDN = ndpi_strdup ( rdnSeqBuf ) ; if ( flow -> protos . stun_ssl . ssl . subjectDN && flow -> protos . stun_ssl . ssl . issuerDN && ( ! strcmp ( flow -> protos . stun_ssl . ssl . subjectDN , flow -> protos . stun_ssl . ssl . issuerDN ) ) ) NDPI_SET_BIT ( flow -> risk , NDPI_TLS_SELFSIGNED_CERTIFICATE ) ; # if DEBUG_TLS printf ( \"[TLS]<S2SV_blank>%s()<S2SV_blank>SubjectDN<S2SV_blank>[%s]\\\\n\" , __FUNCTION__ , rdnSeqBuf ) ; # endif }\n","target":"<S2SV_ModStart> , rdnSeqBuf [ 2048 <S2SV_ModEnd> ] = {\n","project_and_commit_id":"ntop@nDPI/23594f036536468072198a57c59b6e9d63caf6ce","cve_id":"CVE-2020-15474","original_address":"https://github.com/ntop/nDPI/commit/23594f036536468072198a57c59b6e9d63caf6ce","time":"2020-07-01T11:15Z"},
	{"Unnamed: 0":1317,"cwe_id":"CWE-000","source":"CWE-000 static int ims_pcu_parse_cdc_data ( struct usb_interface * intf , struct ims_pcu * pcu ) { const struct usb_cdc_union_desc * union_desc ; struct usb_host_interface * alt ; union_desc = ims_pcu_get_cdc_union_desc ( intf ) ; if ( ! union_desc ) return - EINVAL ; pcu -> ctrl_intf = usb_ifnum_to_if ( pcu -> udev , union_desc -> bMasterInterface0 ) ; <S2SV_StartBug> alt = pcu -> ctrl_intf -> cur_altsetting ; <S2SV_EndBug> pcu -> ep_ctrl = & alt -> endpoint [ 0 ] . desc ; pcu -> max_ctrl_size = usb_endpoint_maxp ( pcu -> ep_ctrl ) ; pcu -> data_intf = usb_ifnum_to_if ( pcu -> udev , union_desc -> bSlaveInterface0 ) ; <S2SV_StartBug> alt = pcu -> data_intf -> cur_altsetting ; <S2SV_EndBug> if ( alt -> desc . bNumEndpoints != 2 ) { dev_err ( pcu -> dev , \"Incorrect<S2SV_blank>number<S2SV_blank>of<S2SV_blank>endpoints<S2SV_blank>on<S2SV_blank>data<S2SV_blank>interface<S2SV_blank>(%d)\\\\n\" , alt -> desc . bNumEndpoints ) ; return - EINVAL ; } pcu -> ep_out = & alt -> endpoint [ 0 ] . desc ; if ( ! usb_endpoint_is_bulk_out ( pcu -> ep_out ) ) { dev_err ( pcu -> dev , \"First<S2SV_blank>endpoint<S2SV_blank>on<S2SV_blank>data<S2SV_blank>interface<S2SV_blank>is<S2SV_blank>not<S2SV_blank>BULK<S2SV_blank>OUT\\\\n\" ) ; return - EINVAL ; } pcu -> max_out_size = usb_endpoint_maxp ( pcu -> ep_out ) ; if ( pcu -> max_out_size < 8 ) { dev_err ( pcu -> dev , \"Max<S2SV_blank>OUT<S2SV_blank>packet<S2SV_blank>size<S2SV_blank>is<S2SV_blank>too<S2SV_blank>small<S2SV_blank>(%zd)\\\\n\" , pcu -> max_out_size ) ; return - EINVAL ; } pcu -> ep_in = & alt -> endpoint [ 1 ] . desc ; if ( ! usb_endpoint_is_bulk_in ( pcu -> ep_in ) ) { dev_err ( pcu -> dev , \"Second<S2SV_blank>endpoint<S2SV_blank>on<S2SV_blank>data<S2SV_blank>interface<S2SV_blank>is<S2SV_blank>not<S2SV_blank>BULK<S2SV_blank>IN\\\\n\" ) ; return - EINVAL ; } pcu -> max_in_size = usb_endpoint_maxp ( pcu -> ep_in ) ; if ( pcu -> max_in_size < 8 ) { dev_err ( pcu -> dev , \"Max<S2SV_blank>IN<S2SV_blank>packet<S2SV_blank>size<S2SV_blank>is<S2SV_blank>too<S2SV_blank>small<S2SV_blank>(%zd)\\\\n\" , pcu -> max_in_size ) ; return - EINVAL ; } return 0 ; }\n","target":"<S2SV_ModStart> bMasterInterface0 ) ; if ( ! pcu -> ctrl_intf ) return - EINVAL ; <S2SV_ModStart> bSlaveInterface0 ) ; if ( ! pcu -> data_intf ) return - EINVAL ;\n","project_and_commit_id":"torvalds@linux/a0ad220c96692eda76b2e3fd7279f3dcd1d8a8ff","cve_id":"CVE-2016-3689","original_address":"https://github.com/torvalds/linux/commit/a0ad220c96692eda76b2e3fd7279f3dcd1d8a8ff","time":"2016-05-02T10:59Z"},
	{"Unnamed: 0":1854,"cwe_id":"CWE-20","source":"CWE-20 int bpf_check ( struct bpf_prog * * prog , union bpf_attr * attr ) { struct bpf_verifier_env * env ; struct bpf_verifer_log * log ; int ret = - EINVAL ; if ( ARRAY_SIZE ( bpf_verifier_ops ) == 0 ) return - EINVAL ; env = kzalloc ( sizeof ( struct bpf_verifier_env ) , GFP_KERNEL ) ; if ( ! env ) return - ENOMEM ; log = & env -> log ; env -> insn_aux_data = vzalloc ( sizeof ( struct bpf_insn_aux_data ) * ( * prog ) -> len ) ; ret = - ENOMEM ; if ( ! env -> insn_aux_data ) goto err_free_env ; env -> prog = * prog ; env -> ops = bpf_verifier_ops [ env -> prog -> type ] ; mutex_lock ( & bpf_verifier_lock ) ; if ( attr -> log_level || attr -> log_buf || attr -> log_size ) { log -> level = attr -> log_level ; log -> ubuf = ( char __user * ) ( unsigned long ) attr -> log_buf ; log -> len_total = attr -> log_size ; ret = - EINVAL ; if ( log -> len_total < 128 || log -> len_total > UINT_MAX >> 8 || ! log -> level || ! log -> ubuf ) goto err_unlock ; } env -> strict_alignment = ! ! ( attr -> prog_flags & BPF_F_STRICT_ALIGNMENT ) ; if ( ! IS_ENABLED ( CONFIG_HAVE_EFFICIENT_UNALIGNED_ACCESS ) ) env -> strict_alignment = true ; if ( env -> prog -> aux -> offload ) { ret = bpf_prog_offload_verifier_prep ( env ) ; if ( ret ) goto err_unlock ; } ret = replace_map_fd_with_map_ptr ( env ) ; if ( ret < 0 ) goto skip_full_check ; env -> explored_states = kcalloc ( env -> prog -> len , sizeof ( struct bpf_verifier_state_list * ) , GFP_USER ) ; ret = - ENOMEM ; if ( ! env -> explored_states ) goto skip_full_check ; ret = check_cfg ( env ) ; if ( ret < 0 ) goto skip_full_check ; env -> allow_ptr_leaks = capable ( CAP_SYS_ADMIN ) ; ret = do_check ( env ) ; if ( env -> cur_state ) { free_verifier_state ( env -> cur_state , true ) ; env -> cur_state = NULL ; } skip_full_check : while ( ! pop_stack ( env , NULL , NULL ) ) ; free_states ( env ) ; if ( ret == 0 ) <S2SV_StartBug> ret = convert_ctx_accesses ( env ) ; <S2SV_EndBug> if ( ret == 0 ) ret = fixup_bpf_calls ( env ) ; if ( log -> level && bpf_verifier_log_full ( log ) ) ret = - ENOSPC ; if ( log -> level && ! log -> ubuf ) { ret = - EFAULT ; goto err_release_maps ; } if ( ret == 0 && env -> used_map_cnt ) { env -> prog -> aux -> used_maps = kmalloc_array ( env -> used_map_cnt , sizeof ( env -> used_maps [ 0 ] ) , GFP_KERNEL ) ; if ( ! env -> prog -> aux -> used_maps ) { ret = - ENOMEM ; goto err_release_maps ; } memcpy ( env -> prog -> aux -> used_maps , env -> used_maps , sizeof ( env -> used_maps [ 0 ] ) * env -> used_map_cnt ) ; env -> prog -> aux -> used_map_cnt = env -> used_map_cnt ; convert_pseudo_ld_imm64 ( env ) ; } err_release_maps : if ( ! env -> prog -> aux -> used_maps ) release_maps ( env ) ; * prog = env -> prog ; err_unlock : mutex_unlock ( & bpf_verifier_lock ) ; vfree ( env -> insn_aux_data ) ; err_free_env : kfree ( env ) ; return ret ; }\n","target":"<S2SV_ModStart> == 0 ) sanitize_dead_code ( env ) ; if ( ret == 0 )\n","project_and_commit_id":"torvalds@linux/c131187db2d3fa2f8bf32fdf4e9a4ef805168467","cve_id":"CVE-2017-17862","original_address":"https://github.com/torvalds/linux/commit/c131187db2d3fa2f8bf32fdf4e9a4ef805168467","time":"2017-12-27T17:08Z"},
	{"Unnamed: 0":6751,"cwe_id":"CWE-119","source":"CWE-119 void vp9_setup_past_independence ( VP9_COMMON * cm ) { struct loopfilter * const lf = & cm -> lf ; int i ; vp9_clearall_segfeatures ( & cm -> seg ) ; cm -> seg . abs_delta = SEGMENT_DELTADATA ; <S2SV_StartBug> if ( cm -> last_frame_seg_map ) <S2SV_EndBug> <S2SV_StartBug> vpx_memset ( cm -> last_frame_seg_map , 0 , ( cm -> mi_rows * cm -> mi_cols ) ) ; <S2SV_EndBug> vp9_zero ( lf -> last_ref_deltas ) ; vp9_zero ( lf -> last_mode_deltas ) ; set_default_lf_deltas ( lf ) ; lf -> last_sharpness_level = - 1 ; vp9_default_coef_probs ( cm ) ; <S2SV_StartBug> vp9_init_mode_probs ( & cm -> fc ) ; <S2SV_EndBug> <S2SV_StartBug> vp9_init_mv_probs ( cm ) ; <S2SV_EndBug> if ( cm -> frame_type == KEY_FRAME || cm -> error_resilient_mode || cm -> reset_frame_context == 3 ) { for ( i = 0 ; i < FRAME_CONTEXTS ; ++ i ) <S2SV_StartBug> cm -> frame_contexts [ i ] = cm -> fc ; <S2SV_EndBug> } else if ( cm -> reset_frame_context == 2 ) { <S2SV_StartBug> cm -> frame_contexts [ cm -> frame_context_idx ] = cm -> fc ; <S2SV_EndBug> } <S2SV_StartBug> if ( frame_is_intra_only ( cm ) ) <S2SV_EndBug> <S2SV_StartBug> vpx_memset ( cm -> prev_mip , 0 , cm -> mi_stride * ( cm -> mi_rows + 1 ) * <S2SV_EndBug> <S2SV_StartBug> sizeof ( * cm -> prev_mip ) ) ; <S2SV_EndBug> vpx_memset ( cm -> mip , 0 , cm -> mi_stride * ( cm -> mi_rows + 1 ) * sizeof ( * cm -> mip ) ) ; vp9_zero ( cm -> ref_frame_sign_bias ) ; cm -> frame_context_idx = 0 ; }\n","target":"<S2SV_ModStart> cm -> last_frame_seg_map && ! cm -> frame_parallel_decode ) memset <S2SV_ModEnd> ( cm -> <S2SV_ModStart> cm -> last_frame_seg_map , 0 , ( cm -> mi_rows * cm -> mi_cols ) ) ; if ( cm -> current_frame_seg_map ) memset ( cm -> current_frame_seg_map <S2SV_ModStart> cm ) ; init_mode_probs ( <S2SV_ModEnd> cm -> fc <S2SV_ModStart> ( cm ) ; cm -> fc -> initialized = 1 <S2SV_ModStart> i ] = * <S2SV_ModStart> frame_context_idx ] = * <S2SV_ModStart> ( cm ) && <S2SV_ModEnd> cm -> prev_mip <S2SV_ModStart> cm -> prev_mip && ! cm -> frame_parallel_decode ) memset ( cm -> prev_mip , 0 , <S2SV_ModEnd> cm -> mi_stride <S2SV_ModStart> cm -> prev_mip <S2SV_ModEnd> ) ) ;\n","project_and_commit_id":"external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426","cve_id":"CVE-2016-1621","original_address":"https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426","time":"2016-03-12T21:59Z"},
	{"Unnamed: 0":1340,"cwe_id":"CWE-401","source":"CWE-401 struct clock_source * dcn10_clock_source_create ( struct dc_context * ctx , struct dc_bios * bios , enum clock_source_id id , const struct dce110_clk_src_regs * regs , bool dp_clk_src ) { struct dce110_clk_src * clk_src = kzalloc ( sizeof ( struct dce110_clk_src ) , GFP_KERNEL ) ; if ( ! clk_src ) return NULL ; if ( dce112_clk_src_construct ( clk_src , ctx , bios , id , regs , & cs_shift , & cs_mask ) ) { clk_src -> base . dp_clk_src = dp_clk_src ; return & clk_src -> base ; } <S2SV_StartBug> BREAK_TO_DEBUGGER ( ) ; <S2SV_EndBug> return NULL ; }\n","target":"<S2SV_ModStart> base ; } kfree ( clk_src ) ;\n","project_and_commit_id":"torvalds@linux/055e547478a11a6360c7ce05e2afc3e366968a12","cve_id":"CVE-2019-19083","original_address":"https://github.com/torvalds/linux/commit/055e547478a11a6360c7ce05e2afc3e366968a12","time":"2019-11-18T06:15Z"},
	{"Unnamed: 0":1078,"cwe_id":"CWE-400","source":"CWE-400 static void record_and_restart ( struct perf_event * event , unsigned long val , <S2SV_StartBug> struct pt_regs * regs , int nmi ) <S2SV_EndBug> { u64 period = event -> hw . sample_period ; s64 prev , delta , left ; int record = 0 ; if ( event -> hw . state & PERF_HES_STOPPED ) { write_pmc ( event -> hw . idx , 0 ) ; return ; } prev = local64_read ( & event -> hw . prev_count ) ; delta = ( val - prev ) & 0xfffffffful ; local64_add ( delta , & event -> count ) ; val = 0 ; left = local64_read ( & event -> hw . period_left ) - delta ; if ( period ) { if ( left <= 0 ) { left += period ; if ( left <= 0 ) left = period ; record = 1 ; event -> hw . last_period = event -> hw . sample_period ; } if ( left < 0x80000000LL ) val = 0x80000000LL - left ; } write_pmc ( event -> hw . idx , val ) ; local64_set ( & event -> hw . prev_count , val ) ; local64_set ( & event -> hw . period_left , left ) ; perf_event_update_userpage ( event ) ; if ( record ) { struct perf_sample_data data ; perf_sample_data_init ( & data , 0 ) ; data . period = event -> hw . last_period ; <S2SV_StartBug> if ( perf_event_overflow ( event , nmi , & data , regs ) ) <S2SV_EndBug> fsl_emb_pmu_stop ( event , 0 ) ; } }\n","target":"<S2SV_ModStart> pt_regs * regs <S2SV_ModEnd> ) { u64 <S2SV_ModStart> ( event , <S2SV_ModEnd> & data ,\n","project_and_commit_id":"torvalds@linux/a8b0ca17b80e92faab46ee7179ba9e99ccb61233","cve_id":"CVE-2011-2918","original_address":"https://github.com/torvalds/linux/commit/a8b0ca17b80e92faab46ee7179ba9e99ccb61233","time":"2012-05-24T23:55Z"},
	{"Unnamed: 0":3210,"cwe_id":"CWE-19","source":"CWE-19 static int ext4_fill_super ( struct super_block * sb , void * data , int silent ) { char * orig_data = kstrdup ( data , GFP_KERNEL ) ; struct buffer_head * bh ; struct ext4_super_block * es = NULL ; struct ext4_sb_info * sbi ; ext4_fsblk_t block ; ext4_fsblk_t sb_block = get_sb_block ( & data ) ; ext4_fsblk_t logical_sb_block ; unsigned long offset = 0 ; unsigned long journal_devnum = 0 ; unsigned long def_mount_opts ; struct inode * root ; const char * descr ; int ret = - ENOMEM ; int blocksize , clustersize ; unsigned int db_count ; unsigned int i ; int needs_recovery , has_huge_files , has_bigalloc ; __u64 blocks_count ; int err = 0 ; unsigned int journal_ioprio = DEFAULT_JOURNAL_IOPRIO ; ext4_group_t first_not_zeroed ; sbi = kzalloc ( sizeof ( * sbi ) , GFP_KERNEL ) ; if ( ! sbi ) goto out_free_orig ; sbi -> s_blockgroup_lock = kzalloc ( sizeof ( struct blockgroup_lock ) , GFP_KERNEL ) ; if ( ! sbi -> s_blockgroup_lock ) { kfree ( sbi ) ; goto out_free_orig ; } sb -> s_fs_info = sbi ; sbi -> s_sb = sb ; sbi -> s_inode_readahead_blks = EXT4_DEF_INODE_READAHEAD_BLKS ; sbi -> s_sb_block = sb_block ; if ( sb -> s_bdev -> bd_part ) sbi -> s_sectors_written_start = part_stat_read ( sb -> s_bdev -> bd_part , sectors [ 1 ] ) ; strreplace ( sb -> s_id , '/' , '!' ) ; ret = - EINVAL ; blocksize = sb_min_blocksize ( sb , EXT4_MIN_BLOCK_SIZE ) ; if ( ! blocksize ) { ext4_msg ( sb , KERN_ERR , \"unable<S2SV_blank>to<S2SV_blank>set<S2SV_blank>blocksize\" ) ; goto out_fail ; } if ( blocksize != EXT4_MIN_BLOCK_SIZE ) { logical_sb_block = sb_block * EXT4_MIN_BLOCK_SIZE ; offset = do_div ( logical_sb_block , blocksize ) ; } else { logical_sb_block = sb_block ; } if ( ! ( bh = sb_bread_unmovable ( sb , logical_sb_block ) ) ) { ext4_msg ( sb , KERN_ERR , \"unable<S2SV_blank>to<S2SV_blank>read<S2SV_blank>superblock\" ) ; goto out_fail ; } es = ( struct ext4_super_block * ) ( bh -> b_data + offset ) ; sbi -> s_es = es ; sb -> s_magic = le16_to_cpu ( es -> s_magic ) ; if ( sb -> s_magic != EXT4_SUPER_MAGIC ) goto cantfind_ext4 ; sbi -> s_kbytes_written = le64_to_cpu ( es -> s_kbytes_written ) ; if ( ext4_has_feature_metadata_csum ( sb ) && ext4_has_feature_gdt_csum ( sb ) ) ext4_warning ( sb , \"metadata_csum<S2SV_blank>and<S2SV_blank>uninit_bg<S2SV_blank>are<S2SV_blank>\" \"redundant<S2SV_blank>flags;<S2SV_blank>please<S2SV_blank>run<S2SV_blank>fsck.\" ) ; if ( ! ext4_verify_csum_type ( sb , es ) ) { ext4_msg ( sb , KERN_ERR , \"VFS:<S2SV_blank>Found<S2SV_blank>ext4<S2SV_blank>filesystem<S2SV_blank>with<S2SV_blank>\" \"unknown<S2SV_blank>checksum<S2SV_blank>algorithm.\" ) ; silent = 1 ; goto cantfind_ext4 ; } if ( ext4_has_feature_metadata_csum ( sb ) ) { sbi -> s_chksum_driver = crypto_alloc_shash ( \"crc32c\" , 0 , 0 ) ; if ( IS_ERR ( sbi -> s_chksum_driver ) ) { ext4_msg ( sb , KERN_ERR , \"Cannot<S2SV_blank>load<S2SV_blank>crc32c<S2SV_blank>driver.\" ) ; ret = PTR_ERR ( sbi -> s_chksum_driver ) ; sbi -> s_chksum_driver = NULL ; goto failed_mount ; } } if ( ! ext4_superblock_csum_verify ( sb , es ) ) { ext4_msg ( sb , KERN_ERR , \"VFS:<S2SV_blank>Found<S2SV_blank>ext4<S2SV_blank>filesystem<S2SV_blank>with<S2SV_blank>\" \"invalid<S2SV_blank>superblock<S2SV_blank>checksum.<S2SV_blank><S2SV_blank>Run<S2SV_blank>e2fsck?\" ) ; silent = 1 ; ret = - EFSBADCRC ; goto cantfind_ext4 ; } if ( ext4_has_feature_csum_seed ( sb ) ) sbi -> s_csum_seed = le32_to_cpu ( es -> s_checksum_seed ) ; else if ( ext4_has_metadata_csum ( sb ) ) sbi -> s_csum_seed = ext4_chksum ( sbi , ~ 0 , es -> s_uuid , sizeof ( es -> s_uuid ) ) ; def_mount_opts = le32_to_cpu ( es -> s_default_mount_opts ) ; set_opt ( sb , INIT_INODE_TABLE ) ; if ( def_mount_opts & EXT4_DEFM_DEBUG ) set_opt ( sb , DEBUG ) ; if ( def_mount_opts & EXT4_DEFM_BSDGROUPS ) set_opt ( sb , GRPID ) ; if ( def_mount_opts & EXT4_DEFM_UID16 ) set_opt ( sb , NO_UID32 ) ; set_opt ( sb , XATTR_USER ) ; # ifdef CONFIG_EXT4_FS_POSIX_ACL set_opt ( sb , POSIX_ACL ) ; # endif if ( ext4_has_metadata_csum ( sb ) ) set_opt ( sb , JOURNAL_CHECKSUM ) ; if ( ( def_mount_opts & EXT4_DEFM_JMODE ) == EXT4_DEFM_JMODE_DATA ) set_opt ( sb , JOURNAL_DATA ) ; else if ( ( def_mount_opts & EXT4_DEFM_JMODE ) == EXT4_DEFM_JMODE_ORDERED ) set_opt ( sb , ORDERED_DATA ) ; else if ( ( def_mount_opts & EXT4_DEFM_JMODE ) == EXT4_DEFM_JMODE_WBACK ) set_opt ( sb , WRITEBACK_DATA ) ; if ( le16_to_cpu ( sbi -> s_es -> s_errors ) == EXT4_ERRORS_PANIC ) set_opt ( sb , ERRORS_PANIC ) ; else if ( le16_to_cpu ( sbi -> s_es -> s_errors ) == EXT4_ERRORS_CONTINUE ) set_opt ( sb , ERRORS_CONT ) ; else set_opt ( sb , ERRORS_RO ) ; set_opt ( sb , BLOCK_VALIDITY ) ; if ( def_mount_opts & EXT4_DEFM_DISCARD ) set_opt ( sb , DISCARD ) ; sbi -> s_resuid = make_kuid ( & init_user_ns , le16_to_cpu ( es -> s_def_resuid ) ) ; sbi -> s_resgid = make_kgid ( & init_user_ns , le16_to_cpu ( es -> s_def_resgid ) ) ; sbi -> s_commit_interval = JBD2_DEFAULT_MAX_COMMIT_AGE * HZ ; sbi -> s_min_batch_time = EXT4_DEF_MIN_BATCH_TIME ; sbi -> s_max_batch_time = EXT4_DEF_MAX_BATCH_TIME ; if ( ( def_mount_opts & EXT4_DEFM_NOBARRIER ) == 0 ) set_opt ( sb , BARRIER ) ; if ( ! IS_EXT3_SB ( sb ) && ! IS_EXT2_SB ( sb ) && ( ( def_mount_opts & EXT4_DEFM_NODELALLOC ) == 0 ) ) set_opt ( sb , DELALLOC ) ; sbi -> s_li_wait_mult = EXT4_DEF_LI_WAIT_MULT ; if ( ! parse_options ( ( char * ) sbi -> s_es -> s_mount_opts , sb , & journal_devnum , & journal_ioprio , 0 ) ) { ext4_msg ( sb , KERN_WARNING , \"failed<S2SV_blank>to<S2SV_blank>parse<S2SV_blank>options<S2SV_blank>in<S2SV_blank>superblock:<S2SV_blank>%s\" , sbi -> s_es -> s_mount_opts ) ; } sbi -> s_def_mount_opt = sbi -> s_mount_opt ; if ( ! parse_options ( ( char * ) data , sb , & journal_devnum , & journal_ioprio , 0 ) ) goto failed_mount ; if ( test_opt ( sb , DATA_FLAGS ) == EXT4_MOUNT_JOURNAL_DATA ) { printk_once ( KERN_WARNING \"EXT4-fs:<S2SV_blank>Warning:<S2SV_blank>mounting<S2SV_blank>\" \"with<S2SV_blank>data=journal<S2SV_blank>disables<S2SV_blank>delayed<S2SV_blank>\" \"allocation<S2SV_blank>and<S2SV_blank>O_DIRECT<S2SV_blank>support!\\\\n\" ) ; if ( test_opt2 ( sb , EXPLICIT_DELALLOC ) ) { ext4_msg ( sb , KERN_ERR , \"can\\'t<S2SV_blank>mount<S2SV_blank>with<S2SV_blank>\" \"both<S2SV_blank>data=journal<S2SV_blank>and<S2SV_blank>delalloc\" ) ; goto failed_mount ; } if ( test_opt ( sb , DIOREAD_NOLOCK ) ) { ext4_msg ( sb , KERN_ERR , \"can\\'t<S2SV_blank>mount<S2SV_blank>with<S2SV_blank>\" \"both<S2SV_blank>data=journal<S2SV_blank>and<S2SV_blank>dioread_nolock\" ) ; goto failed_mount ; } if ( test_opt ( sb , DAX ) ) { ext4_msg ( sb , KERN_ERR , \"can\\'t<S2SV_blank>mount<S2SV_blank>with<S2SV_blank>\" \"both<S2SV_blank>data=journal<S2SV_blank>and<S2SV_blank>dax\" ) ; goto failed_mount ; } if ( test_opt ( sb , DELALLOC ) ) clear_opt ( sb , DELALLOC ) ; } else { sb -> s_iflags |= SB_I_CGROUPWB ; } sb -> s_flags = ( sb -> s_flags & ~ MS_POSIXACL ) | ( test_opt ( sb , POSIX_ACL ) ? MS_POSIXACL : 0 ) ; if ( le32_to_cpu ( es -> s_rev_level ) == EXT4_GOOD_OLD_REV && ( ext4_has_compat_features ( sb ) || ext4_has_ro_compat_features ( sb ) || ext4_has_incompat_features ( sb ) ) ) ext4_msg ( sb , KERN_WARNING , \"feature<S2SV_blank>flags<S2SV_blank>set<S2SV_blank>on<S2SV_blank>rev<S2SV_blank>0<S2SV_blank>fs,<S2SV_blank>\" \"running<S2SV_blank>e2fsck<S2SV_blank>is<S2SV_blank>recommended\" ) ; if ( es -> s_creator_os == cpu_to_le32 ( EXT4_OS_HURD ) ) { set_opt2 ( sb , HURD_COMPAT ) ; if ( ext4_has_feature_64bit ( sb ) ) { ext4_msg ( sb , KERN_ERR , \"The<S2SV_blank>Hurd<S2SV_blank>can\\'t<S2SV_blank>support<S2SV_blank>64-bit<S2SV_blank>file<S2SV_blank>systems\" ) ; goto failed_mount ; } } if ( IS_EXT2_SB ( sb ) ) { if ( ext2_feature_set_ok ( sb ) ) ext4_msg ( sb , KERN_INFO , \"mounting<S2SV_blank>ext2<S2SV_blank>file<S2SV_blank>system<S2SV_blank>\" \"using<S2SV_blank>the<S2SV_blank>ext4<S2SV_blank>subsystem\" ) ; else { ext4_msg ( sb , KERN_ERR , \"couldn\\'t<S2SV_blank>mount<S2SV_blank>as<S2SV_blank>ext2<S2SV_blank>due<S2SV_blank>\" \"to<S2SV_blank>feature<S2SV_blank>incompatibilities\" ) ; goto failed_mount ; } } if ( IS_EXT3_SB ( sb ) ) { if ( ext3_feature_set_ok ( sb ) ) ext4_msg ( sb , KERN_INFO , \"mounting<S2SV_blank>ext3<S2SV_blank>file<S2SV_blank>system<S2SV_blank>\" \"using<S2SV_blank>the<S2SV_blank>ext4<S2SV_blank>subsystem\" ) ; else { ext4_msg ( sb , KERN_ERR , \"couldn\\'t<S2SV_blank>mount<S2SV_blank>as<S2SV_blank>ext3<S2SV_blank>due<S2SV_blank>\" \"to<S2SV_blank>feature<S2SV_blank>incompatibilities\" ) ; goto failed_mount ; } } if ( ! ext4_feature_set_ok ( sb , ( sb -> s_flags & MS_RDONLY ) ) ) goto failed_mount ; blocksize = BLOCK_SIZE << le32_to_cpu ( es -> s_log_block_size ) ; if ( blocksize < EXT4_MIN_BLOCK_SIZE || blocksize > EXT4_MAX_BLOCK_SIZE ) { ext4_msg ( sb , KERN_ERR , \"Unsupported<S2SV_blank>filesystem<S2SV_blank>blocksize<S2SV_blank>%d\" , blocksize ) ; goto failed_mount ; } if ( sbi -> s_mount_opt & EXT4_MOUNT_DAX ) { if ( blocksize != PAGE_SIZE ) { ext4_msg ( sb , KERN_ERR , \"error:<S2SV_blank>unsupported<S2SV_blank>blocksize<S2SV_blank>for<S2SV_blank>dax\" ) ; goto failed_mount ; } if ( ! sb -> s_bdev -> bd_disk -> fops -> direct_access ) { ext4_msg ( sb , KERN_ERR , \"error:<S2SV_blank>device<S2SV_blank>does<S2SV_blank>not<S2SV_blank>support<S2SV_blank>dax\" ) ; goto failed_mount ; } } if ( ext4_has_feature_encrypt ( sb ) && es -> s_encryption_level ) { ext4_msg ( sb , KERN_ERR , \"Unsupported<S2SV_blank>encryption<S2SV_blank>level<S2SV_blank>%d\" , es -> s_encryption_level ) ; goto failed_mount ; } if ( sb -> s_blocksize != blocksize ) { if ( ! sb_set_blocksize ( sb , blocksize ) ) { ext4_msg ( sb , KERN_ERR , \"bad<S2SV_blank>block<S2SV_blank>size<S2SV_blank>%d\" , blocksize ) ; goto failed_mount ; } brelse ( bh ) ; logical_sb_block = sb_block * EXT4_MIN_BLOCK_SIZE ; offset = do_div ( logical_sb_block , blocksize ) ; bh = sb_bread_unmovable ( sb , logical_sb_block ) ; if ( ! bh ) { ext4_msg ( sb , KERN_ERR , \"Can\\'t<S2SV_blank>read<S2SV_blank>superblock<S2SV_blank>on<S2SV_blank>2nd<S2SV_blank>try\" ) ; goto failed_mount ; } es = ( struct ext4_super_block * ) ( bh -> b_data + offset ) ; sbi -> s_es = es ; if ( es -> s_magic != cpu_to_le16 ( EXT4_SUPER_MAGIC ) ) { ext4_msg ( sb , KERN_ERR , \"Magic<S2SV_blank>mismatch,<S2SV_blank>very<S2SV_blank>weird!\" ) ; goto failed_mount ; } } has_huge_files = ext4_has_feature_huge_file ( sb ) ; sbi -> s_bitmap_maxbytes = ext4_max_bitmap_size ( sb -> s_blocksize_bits , has_huge_files ) ; sb -> s_maxbytes = ext4_max_size ( sb -> s_blocksize_bits , has_huge_files ) ; if ( le32_to_cpu ( es -> s_rev_level ) == EXT4_GOOD_OLD_REV ) { sbi -> s_inode_size = EXT4_GOOD_OLD_INODE_SIZE ; sbi -> s_first_ino = EXT4_GOOD_OLD_FIRST_INO ; } else { sbi -> s_inode_size = le16_to_cpu ( es -> s_inode_size ) ; sbi -> s_first_ino = le32_to_cpu ( es -> s_first_ino ) ; if ( ( sbi -> s_inode_size < EXT4_GOOD_OLD_INODE_SIZE ) || ( ! is_power_of_2 ( sbi -> s_inode_size ) ) || ( sbi -> s_inode_size > blocksize ) ) { ext4_msg ( sb , KERN_ERR , \"unsupported<S2SV_blank>inode<S2SV_blank>size:<S2SV_blank>%d\" , sbi -> s_inode_size ) ; goto failed_mount ; } if ( sbi -> s_inode_size > EXT4_GOOD_OLD_INODE_SIZE ) sb -> s_time_gran = 1 << ( EXT4_EPOCH_BITS - 2 ) ; } sbi -> s_desc_size = le16_to_cpu ( es -> s_desc_size ) ; if ( ext4_has_feature_64bit ( sb ) ) { if ( sbi -> s_desc_size < EXT4_MIN_DESC_SIZE_64BIT || sbi -> s_desc_size > EXT4_MAX_DESC_SIZE || ! is_power_of_2 ( sbi -> s_desc_size ) ) { ext4_msg ( sb , KERN_ERR , \"unsupported<S2SV_blank>descriptor<S2SV_blank>size<S2SV_blank>%lu\" , sbi -> s_desc_size ) ; goto failed_mount ; } } else sbi -> s_desc_size = EXT4_MIN_DESC_SIZE ; sbi -> s_blocks_per_group = le32_to_cpu ( es -> s_blocks_per_group ) ; sbi -> s_inodes_per_group = le32_to_cpu ( es -> s_inodes_per_group ) ; if ( EXT4_INODE_SIZE ( sb ) == 0 || EXT4_INODES_PER_GROUP ( sb ) == 0 ) goto cantfind_ext4 ; sbi -> s_inodes_per_block = blocksize / EXT4_INODE_SIZE ( sb ) ; if ( sbi -> s_inodes_per_block == 0 ) goto cantfind_ext4 ; sbi -> s_itb_per_group = sbi -> s_inodes_per_group / sbi -> s_inodes_per_block ; sbi -> s_desc_per_block = blocksize / EXT4_DESC_SIZE ( sb ) ; sbi -> s_sbh = bh ; sbi -> s_mount_state = le16_to_cpu ( es -> s_state ) ; sbi -> s_addr_per_block_bits = ilog2 ( EXT4_ADDR_PER_BLOCK ( sb ) ) ; sbi -> s_desc_per_block_bits = ilog2 ( EXT4_DESC_PER_BLOCK ( sb ) ) ; for ( i = 0 ; i < 4 ; i ++ ) sbi -> s_hash_seed [ i ] = le32_to_cpu ( es -> s_hash_seed [ i ] ) ; sbi -> s_def_hash_version = es -> s_def_hash_version ; if ( ext4_has_feature_dir_index ( sb ) ) { i = le32_to_cpu ( es -> s_flags ) ; if ( i & EXT2_FLAGS_UNSIGNED_HASH ) sbi -> s_hash_unsigned = 3 ; else if ( ( i & EXT2_FLAGS_SIGNED_HASH ) == 0 ) { # ifdef __CHAR_UNSIGNED__ if ( ! ( sb -> s_flags & MS_RDONLY ) ) es -> s_flags |= cpu_to_le32 ( EXT2_FLAGS_UNSIGNED_HASH ) ; sbi -> s_hash_unsigned = 3 ; # else if ( ! ( sb -> s_flags & MS_RDONLY ) ) es -> s_flags |= cpu_to_le32 ( EXT2_FLAGS_SIGNED_HASH ) ; # endif } } clustersize = BLOCK_SIZE << le32_to_cpu ( es -> s_log_cluster_size ) ; has_bigalloc = ext4_has_feature_bigalloc ( sb ) ; if ( has_bigalloc ) { if ( clustersize < blocksize ) { ext4_msg ( sb , KERN_ERR , \"cluster<S2SV_blank>size<S2SV_blank>(%d)<S2SV_blank>smaller<S2SV_blank>than<S2SV_blank>\" \"block<S2SV_blank>size<S2SV_blank>(%d)\" , clustersize , blocksize ) ; goto failed_mount ; } sbi -> s_cluster_bits = le32_to_cpu ( es -> s_log_cluster_size ) - le32_to_cpu ( es -> s_log_block_size ) ; sbi -> s_clusters_per_group = le32_to_cpu ( es -> s_clusters_per_group ) ; if ( sbi -> s_clusters_per_group > blocksize * 8 ) { ext4_msg ( sb , KERN_ERR , \"#clusters<S2SV_blank>per<S2SV_blank>group<S2SV_blank>too<S2SV_blank>big:<S2SV_blank>%lu\" , sbi -> s_clusters_per_group ) ; goto failed_mount ; } if ( sbi -> s_blocks_per_group != ( sbi -> s_clusters_per_group * ( clustersize / blocksize ) ) ) { ext4_msg ( sb , KERN_ERR , \"blocks<S2SV_blank>per<S2SV_blank>group<S2SV_blank>(%lu)<S2SV_blank>and<S2SV_blank>\" \"clusters<S2SV_blank>per<S2SV_blank>group<S2SV_blank>(%lu)<S2SV_blank>inconsistent\" , sbi -> s_blocks_per_group , sbi -> s_clusters_per_group ) ; goto failed_mount ; } } else { if ( clustersize != blocksize ) { ext4_warning ( sb , \"fragment/cluster<S2SV_blank>size<S2SV_blank>(%d)<S2SV_blank>!=<S2SV_blank>\" \"block<S2SV_blank>size<S2SV_blank>(%d)\" , clustersize , blocksize ) ; clustersize = blocksize ; } if ( sbi -> s_blocks_per_group > blocksize * 8 ) { ext4_msg ( sb , KERN_ERR , \"#blocks<S2SV_blank>per<S2SV_blank>group<S2SV_blank>too<S2SV_blank>big:<S2SV_blank>%lu\" , sbi -> s_blocks_per_group ) ; goto failed_mount ; } sbi -> s_clusters_per_group = sbi -> s_blocks_per_group ; sbi -> s_cluster_bits = 0 ; } sbi -> s_cluster_ratio = clustersize / blocksize ; if ( sbi -> s_inodes_per_group > blocksize * 8 ) { ext4_msg ( sb , KERN_ERR , \"#inodes<S2SV_blank>per<S2SV_blank>group<S2SV_blank>too<S2SV_blank>big:<S2SV_blank>%lu\" , sbi -> s_inodes_per_group ) ; goto failed_mount ; } if ( sbi -> s_blocks_per_group == clustersize << 3 ) set_opt2 ( sb , STD_GROUP_SIZE ) ; err = generic_check_addressable ( sb -> s_blocksize_bits , ext4_blocks_count ( es ) ) ; if ( err ) { ext4_msg ( sb , KERN_ERR , \"filesystem\" \"<S2SV_blank>too<S2SV_blank>large<S2SV_blank>to<S2SV_blank>mount<S2SV_blank>safely<S2SV_blank>on<S2SV_blank>this<S2SV_blank>system\" ) ; if ( sizeof ( sector_t ) < 8 ) ext4_msg ( sb , KERN_WARNING , \"CONFIG_LBDAF<S2SV_blank>not<S2SV_blank>enabled\" ) ; goto failed_mount ; } if ( EXT4_BLOCKS_PER_GROUP ( sb ) == 0 ) goto cantfind_ext4 ; blocks_count = sb -> s_bdev -> bd_inode -> i_size >> sb -> s_blocksize_bits ; if ( blocks_count && ext4_blocks_count ( es ) > blocks_count ) { ext4_msg ( sb , KERN_WARNING , \"bad<S2SV_blank>geometry:<S2SV_blank>block<S2SV_blank>count<S2SV_blank>%llu<S2SV_blank>\" \"exceeds<S2SV_blank>size<S2SV_blank>of<S2SV_blank>device<S2SV_blank>(%llu<S2SV_blank>blocks)\" , ext4_blocks_count ( es ) , blocks_count ) ; goto failed_mount ; } if ( le32_to_cpu ( es -> s_first_data_block ) >= ext4_blocks_count ( es ) ) { ext4_msg ( sb , KERN_WARNING , \"bad<S2SV_blank>geometry:<S2SV_blank>first<S2SV_blank>data<S2SV_blank>\" \"block<S2SV_blank>%u<S2SV_blank>is<S2SV_blank>beyond<S2SV_blank>end<S2SV_blank>of<S2SV_blank>filesystem<S2SV_blank>(%llu)\" , le32_to_cpu ( es -> s_first_data_block ) , ext4_blocks_count ( es ) ) ; goto failed_mount ; } blocks_count = ( ext4_blocks_count ( es ) - le32_to_cpu ( es -> s_first_data_block ) + EXT4_BLOCKS_PER_GROUP ( sb ) - 1 ) ; do_div ( blocks_count , EXT4_BLOCKS_PER_GROUP ( sb ) ) ; if ( blocks_count > ( ( uint64_t ) 1 << 32 ) - EXT4_DESC_PER_BLOCK ( sb ) ) { ext4_msg ( sb , KERN_WARNING , \"groups<S2SV_blank>count<S2SV_blank>too<S2SV_blank>large:<S2SV_blank>%u<S2SV_blank>\" \"(block<S2SV_blank>count<S2SV_blank>%llu,<S2SV_blank>first<S2SV_blank>data<S2SV_blank>block<S2SV_blank>%u,<S2SV_blank>\" \"blocks<S2SV_blank>per<S2SV_blank>group<S2SV_blank>%lu)\" , sbi -> s_groups_count , ext4_blocks_count ( es ) , le32_to_cpu ( es -> s_first_data_block ) , EXT4_BLOCKS_PER_GROUP ( sb ) ) ; goto failed_mount ; } sbi -> s_groups_count = blocks_count ; sbi -> s_blockfile_groups = min_t ( ext4_group_t , sbi -> s_groups_count , ( EXT4_MAX_BLOCK_FILE_PHYS / EXT4_BLOCKS_PER_GROUP ( sb ) ) ) ; db_count = ( sbi -> s_groups_count + EXT4_DESC_PER_BLOCK ( sb ) - 1 ) / EXT4_DESC_PER_BLOCK ( sb ) ; sbi -> s_group_desc = ext4_kvmalloc ( db_count * sizeof ( struct buffer_head * ) , GFP_KERNEL ) ; if ( sbi -> s_group_desc == NULL ) { ext4_msg ( sb , KERN_ERR , \"not<S2SV_blank>enough<S2SV_blank>memory\" ) ; ret = - ENOMEM ; goto failed_mount ; } bgl_lock_init ( sbi -> s_blockgroup_lock ) ; for ( i = 0 ; i < db_count ; i ++ ) { block = descriptor_loc ( sb , logical_sb_block , i ) ; sbi -> s_group_desc [ i ] = sb_bread_unmovable ( sb , block ) ; if ( ! sbi -> s_group_desc [ i ] ) { ext4_msg ( sb , KERN_ERR , \"can\\'t<S2SV_blank>read<S2SV_blank>group<S2SV_blank>descriptor<S2SV_blank>%d\" , i ) ; db_count = i ; goto failed_mount2 ; } } if ( ! ext4_check_descriptors ( sb , & first_not_zeroed ) ) { ext4_msg ( sb , KERN_ERR , \"group<S2SV_blank>descriptors<S2SV_blank>corrupted!\" ) ; ret = - EFSCORRUPTED ; goto failed_mount2 ; } sbi -> s_gdb_count = db_count ; get_random_bytes ( & sbi -> s_next_generation , sizeof ( u32 ) ) ; spin_lock_init ( & sbi -> s_next_gen_lock ) ; setup_timer ( & sbi -> s_err_report , print_daily_error_info , ( unsigned long ) sb ) ; if ( ext4_es_register_shrinker ( sbi ) ) goto failed_mount3 ; sbi -> s_stripe = ext4_get_stripe_size ( sbi ) ; sbi -> s_extent_max_zeroout_kb = 32 ; sb -> s_op = & ext4_sops ; sb -> s_export_op = & ext4_export_ops ; sb -> s_xattr = ext4_xattr_handlers ; # ifdef CONFIG_QUOTA sb -> dq_op = & ext4_quota_operations ; if ( ext4_has_feature_quota ( sb ) ) sb -> s_qcop = & dquot_quotactl_sysfile_ops ; else sb -> s_qcop = & ext4_qctl_operations ; sb -> s_quota_types = QTYPE_MASK_USR | QTYPE_MASK_GRP | QTYPE_MASK_PRJ ; # endif memcpy ( sb -> s_uuid , es -> s_uuid , sizeof ( es -> s_uuid ) ) ; INIT_LIST_HEAD ( & sbi -> s_orphan ) ; mutex_init ( & sbi -> s_orphan_lock ) ; sb -> s_root = NULL ; needs_recovery = ( es -> s_last_orphan != 0 || ext4_has_feature_journal_needs_recovery ( sb ) ) ; if ( ext4_has_feature_mmp ( sb ) && ! ( sb -> s_flags & MS_RDONLY ) ) if ( ext4_multi_mount_protect ( sb , le64_to_cpu ( es -> s_mmp_block ) ) ) goto failed_mount3a ; if ( ! test_opt ( sb , NOLOAD ) && ext4_has_feature_journal ( sb ) ) { if ( ext4_load_journal ( sb , es , journal_devnum ) ) goto failed_mount3a ; } else if ( test_opt ( sb , NOLOAD ) && ! ( sb -> s_flags & MS_RDONLY ) && ext4_has_feature_journal_needs_recovery ( sb ) ) { ext4_msg ( sb , KERN_ERR , \"required<S2SV_blank>journal<S2SV_blank>recovery<S2SV_blank>\" \"suppressed<S2SV_blank>and<S2SV_blank>not<S2SV_blank>mounted<S2SV_blank>read-only\" ) ; goto failed_mount_wq ; } else { if ( test_opt2 ( sb , EXPLICIT_JOURNAL_CHECKSUM ) ) { ext4_msg ( sb , KERN_ERR , \"can\\'t<S2SV_blank>mount<S2SV_blank>with<S2SV_blank>\" \"journal_checksum,<S2SV_blank>fs<S2SV_blank>mounted<S2SV_blank>w/o<S2SV_blank>journal\" ) ; goto failed_mount_wq ; } if ( test_opt ( sb , JOURNAL_ASYNC_COMMIT ) ) { ext4_msg ( sb , KERN_ERR , \"can\\'t<S2SV_blank>mount<S2SV_blank>with<S2SV_blank>\" \"journal_async_commit,<S2SV_blank>fs<S2SV_blank>mounted<S2SV_blank>w/o<S2SV_blank>journal\" ) ; goto failed_mount_wq ; } if ( sbi -> s_commit_interval != JBD2_DEFAULT_MAX_COMMIT_AGE * HZ ) { ext4_msg ( sb , KERN_ERR , \"can\\'t<S2SV_blank>mount<S2SV_blank>with<S2SV_blank>\" \"commit=%lu,<S2SV_blank>fs<S2SV_blank>mounted<S2SV_blank>w/o<S2SV_blank>journal\" , sbi -> s_commit_interval / HZ ) ; goto failed_mount_wq ; } if ( EXT4_MOUNT_DATA_FLAGS & ( sbi -> s_mount_opt ^ sbi -> s_def_mount_opt ) ) { ext4_msg ( sb , KERN_ERR , \"can\\'t<S2SV_blank>mount<S2SV_blank>with<S2SV_blank>\" \"data=,<S2SV_blank>fs<S2SV_blank>mounted<S2SV_blank>w/o<S2SV_blank>journal\" ) ; goto failed_mount_wq ; } sbi -> s_def_mount_opt &= EXT4_MOUNT_JOURNAL_CHECKSUM ; clear_opt ( sb , JOURNAL_CHECKSUM ) ; clear_opt ( sb , DATA_FLAGS ) ; sbi -> s_journal = NULL ; needs_recovery = 0 ; goto no_journal ; } if ( ext4_has_feature_64bit ( sb ) && ! jbd2_journal_set_features ( EXT4_SB ( sb ) -> s_journal , 0 , 0 , JBD2_FEATURE_INCOMPAT_64BIT ) ) { ext4_msg ( sb , KERN_ERR , \"Failed<S2SV_blank>to<S2SV_blank>set<S2SV_blank>64-bit<S2SV_blank>journal<S2SV_blank>feature\" ) ; goto failed_mount_wq ; } if ( ! set_journal_csum_feature_set ( sb ) ) { ext4_msg ( sb , KERN_ERR , \"Failed<S2SV_blank>to<S2SV_blank>set<S2SV_blank>journal<S2SV_blank>checksum<S2SV_blank>\" \"feature<S2SV_blank>set\" ) ; goto failed_mount_wq ; } switch ( test_opt ( sb , DATA_FLAGS ) ) { case 0 : if ( jbd2_journal_check_available_features ( sbi -> s_journal , 0 , 0 , JBD2_FEATURE_INCOMPAT_REVOKE ) ) set_opt ( sb , ORDERED_DATA ) ; else set_opt ( sb , JOURNAL_DATA ) ; break ; case EXT4_MOUNT_ORDERED_DATA : case EXT4_MOUNT_WRITEBACK_DATA : if ( ! jbd2_journal_check_available_features ( sbi -> s_journal , 0 , 0 , JBD2_FEATURE_INCOMPAT_REVOKE ) ) { ext4_msg ( sb , KERN_ERR , \"Journal<S2SV_blank>does<S2SV_blank>not<S2SV_blank>support<S2SV_blank>\" \"requested<S2SV_blank>data<S2SV_blank>journaling<S2SV_blank>mode\" ) ; goto failed_mount_wq ; } default : break ; } set_task_ioprio ( sbi -> s_journal -> j_task , journal_ioprio ) ; sbi -> s_journal -> j_commit_callback = ext4_journal_commit_callback ; no_journal : if ( ext4_mballoc_ready ) { <S2SV_StartBug> sbi -> s_mb_cache = ext4_xattr_create_cache ( sb -> s_id ) ; <S2SV_EndBug> if ( ! sbi -> s_mb_cache ) { ext4_msg ( sb , KERN_ERR , \"Failed<S2SV_blank>to<S2SV_blank>create<S2SV_blank>an<S2SV_blank>mb_cache\" ) ; goto failed_mount_wq ; } } if ( ( DUMMY_ENCRYPTION_ENABLED ( sbi ) || ext4_has_feature_encrypt ( sb ) ) && ( blocksize != PAGE_CACHE_SIZE ) ) { ext4_msg ( sb , KERN_ERR , \"Unsupported<S2SV_blank>blocksize<S2SV_blank>for<S2SV_blank>fs<S2SV_blank>encryption\" ) ; goto failed_mount_wq ; } if ( DUMMY_ENCRYPTION_ENABLED ( sbi ) && ! ( sb -> s_flags & MS_RDONLY ) && ! ext4_has_feature_encrypt ( sb ) ) { ext4_set_feature_encrypt ( sb ) ; ext4_commit_super ( sb , 1 ) ; } if ( es -> s_overhead_clusters ) sbi -> s_overhead = le32_to_cpu ( es -> s_overhead_clusters ) ; else { err = ext4_calculate_overhead ( sb ) ; if ( err ) goto failed_mount_wq ; } EXT4_SB ( sb ) -> rsv_conversion_wq = alloc_workqueue ( \"ext4-rsv-conversion\" , WQ_MEM_RECLAIM | WQ_UNBOUND , 1 ) ; if ( ! EXT4_SB ( sb ) -> rsv_conversion_wq ) { printk ( KERN_ERR \"EXT4-fs:<S2SV_blank>failed<S2SV_blank>to<S2SV_blank>create<S2SV_blank>workqueue\\\\n\" ) ; ret = - ENOMEM ; goto failed_mount4 ; } root = ext4_iget ( sb , EXT4_ROOT_INO ) ; if ( IS_ERR ( root ) ) { ext4_msg ( sb , KERN_ERR , \"get<S2SV_blank>root<S2SV_blank>inode<S2SV_blank>failed\" ) ; ret = PTR_ERR ( root ) ; root = NULL ; goto failed_mount4 ; } if ( ! S_ISDIR ( root -> i_mode ) || ! root -> i_blocks || ! root -> i_size ) { ext4_msg ( sb , KERN_ERR , \"corrupt<S2SV_blank>root<S2SV_blank>inode,<S2SV_blank>run<S2SV_blank>e2fsck\" ) ; iput ( root ) ; goto failed_mount4 ; } sb -> s_root = d_make_root ( root ) ; if ( ! sb -> s_root ) { ext4_msg ( sb , KERN_ERR , \"get<S2SV_blank>root<S2SV_blank>dentry<S2SV_blank>failed\" ) ; ret = - ENOMEM ; goto failed_mount4 ; } if ( ext4_setup_super ( sb , es , sb -> s_flags & MS_RDONLY ) ) sb -> s_flags |= MS_RDONLY ; if ( sbi -> s_inode_size > EXT4_GOOD_OLD_INODE_SIZE ) { sbi -> s_want_extra_isize = sizeof ( struct ext4_inode ) - EXT4_GOOD_OLD_INODE_SIZE ; if ( ext4_has_feature_extra_isize ( sb ) ) { if ( sbi -> s_want_extra_isize < le16_to_cpu ( es -> s_want_extra_isize ) ) sbi -> s_want_extra_isize = le16_to_cpu ( es -> s_want_extra_isize ) ; if ( sbi -> s_want_extra_isize < le16_to_cpu ( es -> s_min_extra_isize ) ) sbi -> s_want_extra_isize = le16_to_cpu ( es -> s_min_extra_isize ) ; } } if ( EXT4_GOOD_OLD_INODE_SIZE + sbi -> s_want_extra_isize > sbi -> s_inode_size ) { sbi -> s_want_extra_isize = sizeof ( struct ext4_inode ) - EXT4_GOOD_OLD_INODE_SIZE ; ext4_msg ( sb , KERN_INFO , \"required<S2SV_blank>extra<S2SV_blank>inode<S2SV_blank>space<S2SV_blank>not\" \"available\" ) ; } ext4_set_resv_clusters ( sb ) ; err = ext4_setup_system_zone ( sb ) ; if ( err ) { ext4_msg ( sb , KERN_ERR , \"failed<S2SV_blank>to<S2SV_blank>initialize<S2SV_blank>system<S2SV_blank>\" \"zone<S2SV_blank>(%d)\" , err ) ; goto failed_mount4a ; } ext4_ext_init ( sb ) ; err = ext4_mb_init ( sb ) ; if ( err ) { ext4_msg ( sb , KERN_ERR , \"failed<S2SV_blank>to<S2SV_blank>initialize<S2SV_blank>mballoc<S2SV_blank>(%d)\" , err ) ; goto failed_mount5 ; } block = ext4_count_free_clusters ( sb ) ; ext4_free_blocks_count_set ( sbi -> s_es , EXT4_C2B ( sbi , block ) ) ; err = percpu_counter_init ( & sbi -> s_freeclusters_counter , block , GFP_KERNEL ) ; if ( ! err ) { unsigned long freei = ext4_count_free_inodes ( sb ) ; sbi -> s_es -> s_free_inodes_count = cpu_to_le32 ( freei ) ; err = percpu_counter_init ( & sbi -> s_freeinodes_counter , freei , GFP_KERNEL ) ; } if ( ! err ) err = percpu_counter_init ( & sbi -> s_dirs_counter , ext4_count_dirs ( sb ) , GFP_KERNEL ) ; if ( ! err ) err = percpu_counter_init ( & sbi -> s_dirtyclusters_counter , 0 , GFP_KERNEL ) ; if ( err ) { ext4_msg ( sb , KERN_ERR , \"insufficient<S2SV_blank>memory\" ) ; goto failed_mount6 ; } if ( ext4_has_feature_flex_bg ( sb ) ) if ( ! ext4_fill_flex_info ( sb ) ) { ext4_msg ( sb , KERN_ERR , \"unable<S2SV_blank>to<S2SV_blank>initialize<S2SV_blank>\" \"flex_bg<S2SV_blank>meta<S2SV_blank>info!\" ) ; goto failed_mount6 ; } err = ext4_register_li_request ( sb , first_not_zeroed ) ; if ( err ) goto failed_mount6 ; err = ext4_register_sysfs ( sb ) ; if ( err ) goto failed_mount7 ; # ifdef CONFIG_QUOTA if ( ext4_has_feature_quota ( sb ) && ! ( sb -> s_flags & MS_RDONLY ) ) { err = ext4_enable_quotas ( sb ) ; if ( err ) goto failed_mount8 ; } # endif EXT4_SB ( sb ) -> s_mount_state |= EXT4_ORPHAN_FS ; ext4_orphan_cleanup ( sb , es ) ; EXT4_SB ( sb ) -> s_mount_state &= ~ EXT4_ORPHAN_FS ; if ( needs_recovery ) { ext4_msg ( sb , KERN_INFO , \"recovery<S2SV_blank>complete\" ) ; ext4_mark_recovery_complete ( sb , es ) ; } if ( EXT4_SB ( sb ) -> s_journal ) { if ( test_opt ( sb , DATA_FLAGS ) == EXT4_MOUNT_JOURNAL_DATA ) descr = \"<S2SV_blank>journalled<S2SV_blank>data<S2SV_blank>mode\" ; else if ( test_opt ( sb , DATA_FLAGS ) == EXT4_MOUNT_ORDERED_DATA ) descr = \"<S2SV_blank>ordered<S2SV_blank>data<S2SV_blank>mode\" ; else descr = \"<S2SV_blank>writeback<S2SV_blank>data<S2SV_blank>mode\" ; } else descr = \"out<S2SV_blank>journal\" ; if ( test_opt ( sb , DISCARD ) ) { struct request_queue * q = bdev_get_queue ( sb -> s_bdev ) ; if ( ! blk_queue_discard ( q ) ) ext4_msg ( sb , KERN_WARNING , \"mounting<S2SV_blank>with<S2SV_blank>\\\\\"discard\\\\\"<S2SV_blank>option,<S2SV_blank>but<S2SV_blank>\" \"the<S2SV_blank>device<S2SV_blank>does<S2SV_blank>not<S2SV_blank>support<S2SV_blank>discard\" ) ; } if ( ___ratelimit ( & ext4_mount_msg_ratelimit , \"EXT4-fs<S2SV_blank>mount\" ) ) ext4_msg ( sb , KERN_INFO , \"mounted<S2SV_blank>filesystem<S2SV_blank>with%s.<S2SV_blank>\" \"Opts:<S2SV_blank>%s%s%s\" , descr , sbi -> s_es -> s_mount_opts , * sbi -> s_es -> s_mount_opts ? \";<S2SV_blank>\" : \"\" , orig_data ) ; if ( es -> s_error_count ) mod_timer ( & sbi -> s_err_report , jiffies + 300 * HZ ) ; ratelimit_state_init ( & sbi -> s_err_ratelimit_state , 5 * HZ , 10 ) ; ratelimit_state_init ( & sbi -> s_warning_ratelimit_state , 5 * HZ , 10 ) ; ratelimit_state_init ( & sbi -> s_msg_ratelimit_state , 5 * HZ , 10 ) ; kfree ( orig_data ) ; return 0 ; cantfind_ext4 : if ( ! silent ) ext4_msg ( sb , KERN_ERR , \"VFS:<S2SV_blank>Can\\'t<S2SV_blank>find<S2SV_blank>ext4<S2SV_blank>filesystem\" ) ; goto failed_mount ; # ifdef CONFIG_QUOTA failed_mount8 : ext4_unregister_sysfs ( sb ) ; # endif failed_mount7 : ext4_unregister_li_request ( sb ) ; failed_mount6 : ext4_mb_release ( sb ) ; if ( sbi -> s_flex_groups ) kvfree ( sbi -> s_flex_groups ) ; percpu_counter_destroy ( & sbi -> s_freeclusters_counter ) ; percpu_counter_destroy ( & sbi -> s_freeinodes_counter ) ; percpu_counter_destroy ( & sbi -> s_dirs_counter ) ; percpu_counter_destroy ( & sbi -> s_dirtyclusters_counter ) ; failed_mount5 : ext4_ext_release ( sb ) ; ext4_release_system_zone ( sb ) ; failed_mount4a : dput ( sb -> s_root ) ; sb -> s_root = NULL ; failed_mount4 : ext4_msg ( sb , KERN_ERR , \"mount<S2SV_blank>failed\" ) ; if ( EXT4_SB ( sb ) -> rsv_conversion_wq ) destroy_workqueue ( EXT4_SB ( sb ) -> rsv_conversion_wq ) ; <S2SV_StartBug> failed_mount_wq : <S2SV_EndBug> if ( sbi -> s_journal ) { jbd2_journal_destroy ( sbi -> s_journal ) ; sbi -> s_journal = NULL ; } failed_mount3a : ext4_es_unregister_shrinker ( sbi ) ; failed_mount3 : del_timer_sync ( & sbi -> s_err_report ) ; if ( sbi -> s_mmp_tsk ) kthread_stop ( sbi -> s_mmp_tsk ) ; failed_mount2 : for ( i = 0 ; i < db_count ; i ++ ) brelse ( sbi -> s_group_desc [ i ] ) ; kvfree ( sbi -> s_group_desc ) ; failed_mount : if ( sbi -> s_chksum_driver ) crypto_free_shash ( sbi -> s_chksum_driver ) ; # ifdef CONFIG_QUOTA for ( i = 0 ; i < EXT4_MAXQUOTAS ; i ++ ) kfree ( sbi -> s_qf_names [ i ] ) ; # endif ext4_blkdev_remove ( sbi ) ; brelse ( bh ) ; out_fail : sb -> s_fs_info = NULL ; kfree ( sbi -> s_blockgroup_lock ) ; kfree ( sbi ) ; out_free_orig : kfree ( orig_data ) ; return err ? err : ret ; }\n","target":"<S2SV_ModStart> = ext4_xattr_create_cache ( <S2SV_ModEnd> ) ; if <S2SV_ModStart> ; failed_mount_wq : if ( sbi -> s_mb_cache ) { ext4_xattr_destroy_cache ( sbi -> s_mb_cache ) ; sbi -> s_mb_cache = NULL ; }\n","project_and_commit_id":"torvalds@linux/82939d7999dfc1f1998c4b1c12e2f19edbdff272","cve_id":"CVE-2015-8952","original_address":"https://github.com/torvalds/linux/commit/82939d7999dfc1f1998c4b1c12e2f19edbdff272","time":"2016-10-16T21:59Z"},
	{"Unnamed: 0":86,"cwe_id":"CWE-000","source":"CWE-000 int propagate_mnt ( struct mount * dest_mnt , struct mountpoint * dest_mp , struct mount * source_mnt , struct hlist_head * tree_list ) { struct mount * m , * n ; int ret = 0 ; user_ns = current -> nsproxy -> mnt_ns -> user_ns ; last_dest = dest_mnt ; <S2SV_StartBug> last_source = source_mnt ; <S2SV_EndBug> mp = dest_mp ; list = tree_list ; dest_master = dest_mnt -> mnt_master ; for ( n = next_peer ( dest_mnt ) ; n != dest_mnt ; n = next_peer ( n ) ) { ret = propagate_one ( n ) ; if ( ret ) goto out ; } for ( m = next_group ( dest_mnt , dest_mnt ) ; m ; m = next_group ( m , dest_mnt ) ) { n = m ; do { ret = propagate_one ( n ) ; if ( ret ) goto out ; n = next_peer ( n ) ; } while ( n != m ) ; } out : read_seqlock_excl ( & mount_lock ) ; hlist_for_each_entry ( n , tree_list , mnt_hash ) { m = n -> mnt_parent ; if ( m -> mnt_master != dest_mnt -> mnt_master ) CLEAR_MNT_MARK ( m -> mnt_master ) ; } read_sequnlock_excl ( & mount_lock ) ; return ret ; }\n","target":"<S2SV_ModStart> = dest_mnt ; first_source = source_mnt ;\n","project_and_commit_id":"torvalds@linux/5ec0811d30378ae104f250bfc9b3640242d81e3f","cve_id":"CVE-2016-4581","original_address":"https://github.com/torvalds/linux/commit/5ec0811d30378ae104f250bfc9b3640242d81e3f","time":"2016-05-23T10:59Z"},
	{"Unnamed: 0":5134,"cwe_id":"CWE-119","source":"CWE-119 static Sdb * store_versioninfo_gnu_verdef ( ELFOBJ * bin , Elf_ ( Shdr ) * shdr , int sz ) { const char * section_name = \"\" ; const char * link_section_name = \"\" ; char * end = NULL ; Elf_ ( Shdr ) * link_shdr = NULL ; ut8 dfs [ sizeof ( Elf_ ( Verdef ) ) ] = { 0 } ; Sdb * sdb ; int cnt , i ; if ( shdr -> sh_link > bin -> ehdr . e_shnum ) { return false ; } link_shdr = & bin -> shdr [ shdr -> sh_link ] ; if ( shdr -> sh_size < 1 ) { return false ; } Elf_ ( Verdef ) * defs = calloc ( shdr -> sh_size , sizeof ( char ) ) ; if ( ! defs ) { return false ; } if ( bin -> shstrtab && shdr -> sh_name < bin -> shstrtab_size ) { section_name = & bin -> shstrtab [ shdr -> sh_name ] ; } if ( link_shdr && bin -> shstrtab && link_shdr -> sh_name < bin -> shstrtab_size ) { link_section_name = & bin -> shstrtab [ link_shdr -> sh_name ] ; } if ( ! defs ) { bprintf ( \"Warning:<S2SV_blank>Cannot<S2SV_blank>allocate<S2SV_blank>memory<S2SV_blank>(Check<S2SV_blank>Elf_(Verdef))\\\\n\" ) ; return NULL ; } sdb = sdb_new0 ( ) ; end = ( char * ) defs + shdr -> sh_size ; sdb_set ( sdb , \"section_name\" , section_name , 0 ) ; sdb_num_set ( sdb , \"entries\" , shdr -> sh_info , 0 ) ; sdb_num_set ( sdb , \"addr\" , shdr -> sh_addr , 0 ) ; sdb_num_set ( sdb , \"offset\" , shdr -> sh_offset , 0 ) ; sdb_num_set ( sdb , \"link\" , shdr -> sh_link , 0 ) ; sdb_set ( sdb , \"link_section_name\" , link_section_name , 0 ) ; <S2SV_StartBug> for ( cnt = 0 , i = 0 ; cnt < shdr -> sh_info && ( ( char * ) defs + i < end ) ; ++ cnt ) { <S2SV_EndBug> Sdb * sdb_verdef = sdb_new0 ( ) ; char * vstart = ( ( char * ) defs ) + i ; char key [ 32 ] = { 0 } ; Elf_ ( Verdef ) * verdef = ( Elf_ ( Verdef ) * ) vstart ; Elf_ ( Verdaux ) aux = { 0 } ; int j = 0 ; int isum = 0 ; r_buf_read_at ( bin -> b , shdr -> sh_offset + i , dfs , sizeof ( Elf_ ( Verdef ) ) ) ; verdef -> vd_version = READ16 ( dfs , j ) verdef -> vd_flags = READ16 ( dfs , j ) verdef -> vd_ndx = READ16 ( dfs , j ) verdef -> vd_cnt = READ16 ( dfs , j ) verdef -> vd_hash = READ32 ( dfs , j ) verdef -> vd_aux = READ32 ( dfs , j ) verdef -> vd_next = READ32 ( dfs , j ) vstart += verdef -> vd_aux ; if ( vstart > end || vstart + sizeof ( Elf_ ( Verdaux ) ) > end ) { sdb_free ( sdb_verdef ) ; goto out_error ; } j = 0 ; aux . vda_name = READ32 ( vstart , j ) aux . vda_next = READ32 ( vstart , j ) isum = i + verdef -> vd_aux ; if ( aux . vda_name > bin -> dynstr_size ) { sdb_free ( sdb_verdef ) ; goto out_error ; } sdb_num_set ( sdb_verdef , \"idx\" , i , 0 ) ; sdb_num_set ( sdb_verdef , \"vd_version\" , verdef -> vd_version , 0 ) ; sdb_num_set ( sdb_verdef , \"vd_ndx\" , verdef -> vd_ndx , 0 ) ; sdb_num_set ( sdb_verdef , \"vd_cnt\" , verdef -> vd_cnt , 0 ) ; sdb_set ( sdb_verdef , \"vda_name\" , & bin -> dynstr [ aux . vda_name ] , 0 ) ; sdb_set ( sdb_verdef , \"flags\" , get_ver_flags ( verdef -> vd_flags ) , 0 ) ; for ( j = 1 ; j < verdef -> vd_cnt ; ++ j ) { int k ; Sdb * sdb_parent = sdb_new0 ( ) ; isum += aux . vda_next ; vstart += aux . vda_next ; if ( vstart > end || vstart + sizeof ( Elf_ ( Verdaux ) ) > end ) { sdb_free ( sdb_verdef ) ; sdb_free ( sdb_parent ) ; goto out_error ; } k = 0 ; aux . vda_name = READ32 ( vstart , k ) aux . vda_next = READ32 ( vstart , k ) if ( aux . vda_name > bin -> dynstr_size ) { sdb_free ( sdb_verdef ) ; sdb_free ( sdb_parent ) ; goto out_error ; } sdb_num_set ( sdb_parent , \"idx\" , isum , 0 ) ; sdb_num_set ( sdb_parent , \"parent\" , j , 0 ) ; sdb_set ( sdb_parent , \"vda_name\" , & bin -> dynstr [ aux . vda_name ] , 0 ) ; snprintf ( key , sizeof ( key ) , \"parent%d\" , j - 1 ) ; sdb_ns_set ( sdb_verdef , key , sdb_parent ) ; } snprintf ( key , sizeof ( key ) , \"verdef%d\" , cnt ) ; sdb_ns_set ( sdb , key , sdb_verdef ) ; if ( ! verdef -> vd_next ) { sdb_free ( sdb_verdef ) ; goto out_error ; } <S2SV_StartBug> i += verdef -> vd_next ; <S2SV_EndBug> } free ( defs ) ; return sdb ; out_error : free ( defs ) ; sdb_free ( sdb ) ; return NULL ; }\n","target":"<S2SV_ModStart> = 0 ; i >= 0 && <S2SV_ModStart> out_error ; } if ( ( st32 ) verdef -> vd_next < 1 ) { eprintf ( \"Warning:<S2SV_blank>Invalid<S2SV_blank>vd_next<S2SV_blank>in<S2SV_blank>the<S2SV_blank>ELF<S2SV_blank>version\\\\n\" ) ; break ; }\n","project_and_commit_id":"radare@radare2/21a6f570ba33fa9f52f1bba87f07acc4e8c178f4","cve_id":"CVE-2017-15385","original_address":"https://github.com/radare/radare2/commit/21a6f570ba33fa9f52f1bba87f07acc4e8c178f4","time":"2017-10-16T22:29Z"},
	{"Unnamed: 0":5705,"cwe_id":"CWE-125","source":"CWE-125 static void interp_reply ( netdissect_options * ndo , const struct sunrpc_msg * rp , uint32_t proc , uint32_t vers , int length ) { register const uint32_t * dp ; register int v3 ; int er ; v3 = ( vers == NFS_VER3 ) ; if ( ! v3 && proc < NFS_NPROCS ) proc = nfsv3_procid [ proc ] ; ND_PRINT ( ( ndo , \"<S2SV_blank>%s\" , tok2str ( nfsproc_str , \"proc-%u\" , proc ) ) ) ; switch ( proc ) { case NFSPROC_GETATTR : dp = parserep ( ndo , rp , length ) ; if ( dp != NULL && parseattrstat ( ndo , dp , ! ndo -> ndo_qflag , v3 ) != 0 ) return ; break ; case NFSPROC_SETATTR : if ( ! ( dp = parserep ( ndo , rp , length ) ) ) return ; if ( v3 ) { if ( parsewccres ( ndo , dp , ndo -> ndo_vflag ) ) return ; } else { if ( parseattrstat ( ndo , dp , ! ndo -> ndo_qflag , 0 ) != 0 ) return ; } break ; case NFSPROC_LOOKUP : if ( ! ( dp = parserep ( ndo , rp , length ) ) ) break ; if ( v3 ) { if ( ! ( dp = parsestatus ( ndo , dp , & er ) ) ) break ; if ( er ) { if ( ndo -> ndo_vflag > 1 ) { ND_PRINT ( ( ndo , \"<S2SV_blank>post<S2SV_blank>dattr:\" ) ) ; dp = parse_post_op_attr ( ndo , dp , ndo -> ndo_vflag ) ; } } else { if ( ! ( dp = parsefh ( ndo , dp , v3 ) ) ) break ; if ( ( dp = parse_post_op_attr ( ndo , dp , ndo -> ndo_vflag ) ) && ndo -> ndo_vflag > 1 ) { ND_PRINT ( ( ndo , \"<S2SV_blank>post<S2SV_blank>dattr:\" ) ) ; dp = parse_post_op_attr ( ndo , dp , ndo -> ndo_vflag ) ; } } if ( dp ) return ; } else { if ( parsediropres ( ndo , dp ) != 0 ) return ; } break ; case NFSPROC_ACCESS : if ( ! ( dp = parserep ( ndo , rp , length ) ) ) break ; if ( ! ( dp = parsestatus ( ndo , dp , & er ) ) ) break ; if ( ndo -> ndo_vflag ) ND_PRINT ( ( ndo , \"<S2SV_blank>attr:\" ) ) ; if ( ! ( dp = parse_post_op_attr ( ndo , dp , ndo -> ndo_vflag ) ) ) break ; if ( ! er ) <S2SV_StartBug> ND_PRINT ( ( ndo , \"<S2SV_blank>c<S2SV_blank>%04x\" , EXTRACT_32BITS ( & dp [ 0 ] ) ) ) ; <S2SV_EndBug> return ; case NFSPROC_READLINK : dp = parserep ( ndo , rp , length ) ; if ( dp != NULL && parselinkres ( ndo , dp , v3 ) != 0 ) return ; break ; case NFSPROC_READ : if ( ! ( dp = parserep ( ndo , rp , length ) ) ) break ; if ( v3 ) { if ( ! ( dp = parsestatus ( ndo , dp , & er ) ) ) break ; if ( ! ( dp = parse_post_op_attr ( ndo , dp , ndo -> ndo_vflag ) ) ) break ; if ( er ) return ; if ( ndo -> ndo_vflag ) { ND_TCHECK ( dp [ 1 ] ) ; ND_PRINT ( ( ndo , \"<S2SV_blank>%u<S2SV_blank>bytes\" , EXTRACT_32BITS ( & dp [ 0 ] ) ) ) ; if ( EXTRACT_32BITS ( & dp [ 1 ] ) ) ND_PRINT ( ( ndo , \"<S2SV_blank>EOF\" ) ) ; } return ; } else { if ( parseattrstat ( ndo , dp , ndo -> ndo_vflag , 0 ) != 0 ) return ; } break ; case NFSPROC_WRITE : if ( ! ( dp = parserep ( ndo , rp , length ) ) ) break ; if ( v3 ) { if ( ! ( dp = parsestatus ( ndo , dp , & er ) ) ) break ; if ( ! ( dp = parse_wcc_data ( ndo , dp , ndo -> ndo_vflag ) ) ) break ; if ( er ) return ; if ( ndo -> ndo_vflag ) { ND_TCHECK ( dp [ 0 ] ) ; ND_PRINT ( ( ndo , \"<S2SV_blank>%u<S2SV_blank>bytes\" , EXTRACT_32BITS ( & dp [ 0 ] ) ) ) ; if ( ndo -> ndo_vflag > 1 ) { ND_TCHECK ( dp [ 1 ] ) ; ND_PRINT ( ( ndo , \"<S2SV_blank><%s>\" , tok2str ( nfsv3_writemodes , NULL , EXTRACT_32BITS ( & dp [ 1 ] ) ) ) ) ; } return ; } } else { if ( parseattrstat ( ndo , dp , ndo -> ndo_vflag , v3 ) != 0 ) return ; } break ; case NFSPROC_CREATE : case NFSPROC_MKDIR : if ( ! ( dp = parserep ( ndo , rp , length ) ) ) break ; if ( v3 ) { if ( parsecreateopres ( ndo , dp , ndo -> ndo_vflag ) != NULL ) return ; } else { if ( parsediropres ( ndo , dp ) != 0 ) return ; } break ; case NFSPROC_SYMLINK : if ( ! ( dp = parserep ( ndo , rp , length ) ) ) break ; if ( v3 ) { if ( parsecreateopres ( ndo , dp , ndo -> ndo_vflag ) != NULL ) return ; } else { if ( parsestatus ( ndo , dp , & er ) != NULL ) return ; } break ; case NFSPROC_MKNOD : if ( ! ( dp = parserep ( ndo , rp , length ) ) ) break ; if ( parsecreateopres ( ndo , dp , ndo -> ndo_vflag ) != NULL ) return ; break ; case NFSPROC_REMOVE : case NFSPROC_RMDIR : if ( ! ( dp = parserep ( ndo , rp , length ) ) ) break ; if ( v3 ) { if ( parsewccres ( ndo , dp , ndo -> ndo_vflag ) ) return ; } else { if ( parsestatus ( ndo , dp , & er ) != NULL ) return ; } break ; case NFSPROC_RENAME : if ( ! ( dp = parserep ( ndo , rp , length ) ) ) break ; if ( v3 ) { if ( ! ( dp = parsestatus ( ndo , dp , & er ) ) ) break ; if ( ndo -> ndo_vflag ) { ND_PRINT ( ( ndo , \"<S2SV_blank>from:\" ) ) ; if ( ! ( dp = parse_wcc_data ( ndo , dp , ndo -> ndo_vflag ) ) ) break ; ND_PRINT ( ( ndo , \"<S2SV_blank>to:\" ) ) ; if ( ! ( dp = parse_wcc_data ( ndo , dp , ndo -> ndo_vflag ) ) ) break ; } return ; } else { if ( parsestatus ( ndo , dp , & er ) != NULL ) return ; } break ; case NFSPROC_LINK : if ( ! ( dp = parserep ( ndo , rp , length ) ) ) break ; if ( v3 ) { if ( ! ( dp = parsestatus ( ndo , dp , & er ) ) ) break ; if ( ndo -> ndo_vflag ) { ND_PRINT ( ( ndo , \"<S2SV_blank>file<S2SV_blank>POST:\" ) ) ; if ( ! ( dp = parse_post_op_attr ( ndo , dp , ndo -> ndo_vflag ) ) ) break ; ND_PRINT ( ( ndo , \"<S2SV_blank>dir:\" ) ) ; if ( ! ( dp = parse_wcc_data ( ndo , dp , ndo -> ndo_vflag ) ) ) break ; return ; } } else { if ( parsestatus ( ndo , dp , & er ) != NULL ) return ; } break ; case NFSPROC_READDIR : if ( ! ( dp = parserep ( ndo , rp , length ) ) ) break ; if ( v3 ) { if ( parsev3rddirres ( ndo , dp , ndo -> ndo_vflag ) ) return ; } else { if ( parserddires ( ndo , dp ) != 0 ) return ; } break ; case NFSPROC_READDIRPLUS : if ( ! ( dp = parserep ( ndo , rp , length ) ) ) break ; if ( parsev3rddirres ( ndo , dp , ndo -> ndo_vflag ) ) return ; break ; case NFSPROC_FSSTAT : dp = parserep ( ndo , rp , length ) ; if ( dp != NULL && parsestatfs ( ndo , dp , v3 ) != 0 ) return ; break ; case NFSPROC_FSINFO : dp = parserep ( ndo , rp , length ) ; if ( dp != NULL && parsefsinfo ( ndo , dp ) != 0 ) return ; break ; case NFSPROC_PATHCONF : dp = parserep ( ndo , rp , length ) ; if ( dp != NULL && parsepathconf ( ndo , dp ) != 0 ) return ; break ; case NFSPROC_COMMIT : dp = parserep ( ndo , rp , length ) ; if ( dp != NULL && parsewccres ( ndo , dp , ndo -> ndo_vflag ) != 0 ) return ; break ; default : return ; } trunc : if ( ! nfserr ) ND_PRINT ( ( ndo , \"%s\" , tstr ) ) ; }\n","target":"<S2SV_ModStart> ! er ) { ND_TCHECK ( <S2SV_ModEnd> dp [ 0 <S2SV_ModStart> 0 ] ) ; ND_PRINT ( ( ndo , \"<S2SV_blank>c<S2SV_blank>%04x\" , EXTRACT_32BITS ( & dp [ 0 ] ) ) ) ; } <S2SV_ModEnd> return ; case\n","project_and_commit_id":"the-tcpdump-group@tcpdump/19d25dd8781620cd41bf178a5e2e27fc1cf242d0","cve_id":"CVE-2017-12898","original_address":"https://github.com/the-tcpdump-group/tcpdump/commit/19d25dd8781620cd41bf178a5e2e27fc1cf242d0","time":"2017-09-14T06:29Z"},
	{"Unnamed: 0":3530,"cwe_id":"CWE-264","source":"CWE-264 void setattr_copy ( struct inode * inode , const struct iattr * attr ) { unsigned int ia_valid = attr -> ia_valid ; if ( ia_valid & ATTR_UID ) inode -> i_uid = attr -> ia_uid ; if ( ia_valid & ATTR_GID ) inode -> i_gid = attr -> ia_gid ; if ( ia_valid & ATTR_ATIME ) inode -> i_atime = timespec_trunc ( attr -> ia_atime , inode -> i_sb -> s_time_gran ) ; if ( ia_valid & ATTR_MTIME ) inode -> i_mtime = timespec_trunc ( attr -> ia_mtime , inode -> i_sb -> s_time_gran ) ; if ( ia_valid & ATTR_CTIME ) inode -> i_ctime = timespec_trunc ( attr -> ia_ctime , inode -> i_sb -> s_time_gran ) ; if ( ia_valid & ATTR_MODE ) { umode_t mode = attr -> ia_mode ; if ( ! in_group_p ( inode -> i_gid ) && <S2SV_StartBug> ! inode_capable ( inode , CAP_FSETID ) ) <S2SV_EndBug> mode &= ~ S_ISGID ; inode -> i_mode = mode ; } }\n","target":"<S2SV_ModStart> ) && ! capable_wrt_inode_uidgid <S2SV_ModEnd> ( inode ,\n","project_and_commit_id":"torvalds@linux/23adbe12ef7d3d4195e80800ab36b37bee28cd03","cve_id":"CVE-2014-4014","original_address":"https://github.com/torvalds/linux/commit/23adbe12ef7d3d4195e80800ab36b37bee28cd03","time":"2014-06-23T11:21Z"},
	{"Unnamed: 0":1218,"cwe_id":"CWE-399","source":"CWE-399 static void inotify_free_group_priv ( struct fsnotify_group * group ) { idr_for_each ( & group -> inotify_data . idr , idr_callback , group ) ; idr_remove_all ( & group -> inotify_data . idr ) ; idr_destroy ( & group -> inotify_data . idr ) ; <S2SV_StartBug> free_uid ( group -> inotify_data . user ) ; <S2SV_EndBug> }\n","target":"<S2SV_ModStart> idr ) ; atomic_dec ( & group -> inotify_data . user -> inotify_devs ) ;\n","project_and_commit_id":"torvalds@linux/d0de4dc584ec6aa3b26fffea320a8457827768fc","cve_id":"CVE-2011-1479","original_address":"https://github.com/torvalds/linux/commit/d0de4dc584ec6aa3b26fffea320a8457827768fc","time":"2012-06-21T23:55Z"},
	{"Unnamed: 0":4998,"cwe_id":"CWE-22","source":"CWE-22 static int pop_sync_mailbox ( struct Context * ctx , int * index_hint ) { int i , j , ret = 0 ; char buf [ LONG_STRING ] ; struct PopData * pop_data = ( struct PopData * ) ctx -> data ; struct Progress progress ; # ifdef USE_HCACHE header_cache_t * hc = NULL ; # endif pop_data -> check_time = 0 ; while ( true ) { if ( pop_reconnect ( ctx ) < 0 ) return - 1 ; mutt_progress_init ( & progress , _ ( \"Marking<S2SV_blank>messages<S2SV_blank>deleted...\" ) , MUTT_PROGRESS_MSG , WriteInc , ctx -> deleted ) ; # ifdef USE_HCACHE hc = pop_hcache_open ( pop_data , ctx -> path ) ; # endif for ( i = 0 , j = 0 , ret = 0 ; ret == 0 && i < ctx -> msgcount ; i ++ ) { if ( ctx -> hdrs [ i ] -> deleted && ctx -> hdrs [ i ] -> refno != - 1 ) { j ++ ; if ( ! ctx -> quiet ) mutt_progress_update ( & progress , j , - 1 ) ; snprintf ( buf , sizeof ( buf ) , \"DELE<S2SV_blank>%d\\\\r\\\\n\" , ctx -> hdrs [ i ] -> refno ) ; ret = pop_query ( pop_data , buf , sizeof ( buf ) ) ; if ( ret == 0 ) { <S2SV_StartBug> mutt_bcache_del ( pop_data -> bcache , ctx -> hdrs [ i ] -> data ) ; <S2SV_EndBug> # ifdef USE_HCACHE mutt_hcache_delete ( hc , ctx -> hdrs [ i ] -> data , strlen ( ctx -> hdrs [ i ] -> data ) ) ; # endif } } # ifdef USE_HCACHE if ( ctx -> hdrs [ i ] -> changed ) { mutt_hcache_store ( hc , ctx -> hdrs [ i ] -> data , strlen ( ctx -> hdrs [ i ] -> data ) , ctx -> hdrs [ i ] , 0 ) ; } # endif } # ifdef USE_HCACHE mutt_hcache_close ( hc ) ; # endif if ( ret == 0 ) { mutt_str_strfcpy ( buf , \"QUIT\\\\r\\\\n\" , sizeof ( buf ) ) ; ret = pop_query ( pop_data , buf , sizeof ( buf ) ) ; } if ( ret == 0 ) { pop_data -> clear_cache = true ; pop_clear_cache ( pop_data ) ; pop_data -> status = POP_DISCONNECTED ; return 0 ; } if ( ret == - 2 ) { mutt_error ( \"%s\" , pop_data -> err_msg ) ; return - 1 ; } } }\n","target":"<S2SV_ModStart> -> bcache , cache_id ( <S2SV_ModStart> ] -> data )\n","project_and_commit_id":"neomutt@neomutt/9bfab35522301794483f8f9ed60820bdec9be59e","cve_id":"CVE-2018-14363","original_address":"https://github.com/neomutt/neomutt/commit/9bfab35522301794483f8f9ed60820bdec9be59e","time":"2018-07-17T17:29Z"},
	{"Unnamed: 0":4663,"cwe_id":"CWE-190","source":"CWE-190 <S2SV_StartBug> void jas_seq2d_bindsub ( jas_matrix_t * s , jas_matrix_t * s1 , int xstart , <S2SV_EndBug> int ystart , int xend , int yend ) { jas_matrix_bindsub ( s , s1 , ystart - s1 -> ystart_ , xstart - s1 -> xstart_ , yend - s1 -> ystart_ - 1 , xend - s1 -> xstart_ - 1 ) ; }\n","target":"<S2SV_ModStart> * s1 , jas_matind_t xstart , jas_matind_t ystart , jas_matind_t xend , jas_matind_t <S2SV_ModEnd> yend ) {\n","project_and_commit_id":"mdadams@jasper/d42b2388f7f8e0332c846675133acea151fc557a","cve_id":"CVE-2016-9557","original_address":"https://github.com/mdadams/jasper/commit/d42b2388f7f8e0332c846675133acea151fc557a","time":"2017-03-23T18:59Z"},
	{"Unnamed: 0":4517,"cwe_id":"CWE-200","source":"CWE-200 void free_bprm ( struct linux_binprm * bprm ) { free_arg_pages ( bprm ) ; if ( bprm -> cred ) { mutex_unlock ( & current -> signal -> cred_guard_mutex ) ; abort_creds ( bprm -> cred ) ; } <S2SV_StartBug> kfree ( bprm ) ; <S2SV_EndBug> }\n","target":"<S2SV_ModStart> ) ; } if ( bprm -> interp != bprm -> filename ) kfree ( bprm -> interp ) ;\n","project_and_commit_id":"torvalds@linux/b66c5984017533316fd1951770302649baf1aa33","cve_id":"CVE-2012-4530","original_address":"https://github.com/torvalds/linux/commit/b66c5984017533316fd1951770302649baf1aa33","time":"2013-02-18T04:41Z"},
	{"Unnamed: 0":3928,"cwe_id":"CWE-908","source":"CWE-908 void * vips_malloc ( VipsObject * object , size_t size ) { void * buf ; <S2SV_StartBug> buf = g_malloc ( size ) ; <S2SV_EndBug> if ( object ) { g_signal_connect ( object , \"postclose\" , G_CALLBACK ( vips_malloc_cb ) , buf ) ; object -> local_memory += size ; } return ( buf ) ; }\n","target":"<S2SV_ModStart> ; buf = g_malloc0 <S2SV_ModEnd> ( size )\n","project_and_commit_id":"libvips@libvips/00622428bda8d7521db8d74260b519fa41d69d0a","cve_id":"CVE-2019-6976","original_address":"https://github.com/libvips/libvips/commit/00622428bda8d7521db8d74260b519fa41d69d0a","time":"2019-01-26T23:29Z"},
	{"Unnamed: 0":3931,"cwe_id":"CWE-20","source":"CWE-20 static int chmd_read_headers ( struct mspack_system * sys , struct mspack_file * fh , struct mschmd_header * chm , int entire ) { unsigned int section , name_len , x , errors , num_chunks ; unsigned char buf [ 0x54 ] , * chunk = NULL , * name , * p , * end ; struct mschmd_file * fi , * link = NULL ; off_t offset , length ; int num_entries ; chm -> files = NULL ; chm -> sysfiles = NULL ; chm -> chunk_cache = NULL ; chm -> sec0 . base . chm = chm ; chm -> sec0 . base . id = 0 ; chm -> sec1 . base . chm = chm ; chm -> sec1 . base . id = 1 ; chm -> sec1 . content = NULL ; chm -> sec1 . control = NULL ; chm -> sec1 . spaninfo = NULL ; chm -> sec1 . rtable = NULL ; if ( sys -> read ( fh , & buf [ 0 ] , chmhead_SIZEOF ) != chmhead_SIZEOF ) { return MSPACK_ERR_READ ; } if ( EndGetI32 ( & buf [ chmhead_Signature ] ) != 0x46535449 ) { return MSPACK_ERR_SIGNATURE ; } if ( mspack_memcmp ( & buf [ chmhead_GUID1 ] , & guids [ 0 ] , 32L ) != 0 ) { D ( ( \"incorrect<S2SV_blank>GUIDs\" ) ) return MSPACK_ERR_SIGNATURE ; } chm -> version = EndGetI32 ( & buf [ chmhead_Version ] ) ; chm -> timestamp = EndGetM32 ( & buf [ chmhead_Timestamp ] ) ; chm -> language = EndGetI32 ( & buf [ chmhead_LanguageID ] ) ; if ( chm -> version > 3 ) { sys -> message ( fh , \"WARNING;<S2SV_blank>CHM<S2SV_blank>version<S2SV_blank>><S2SV_blank>3\" ) ; } if ( sys -> read ( fh , & buf [ 0 ] , chmhst3_SIZEOF ) != chmhst3_SIZEOF ) { return MSPACK_ERR_READ ; } if ( read_off64 ( & offset , & buf [ chmhst_OffsetHS0 ] , sys , fh ) || read_off64 ( & chm -> dir_offset , & buf [ chmhst_OffsetHS1 ] , sys , fh ) || read_off64 ( & chm -> sec0 . offset , & buf [ chmhst3_OffsetCS0 ] , sys , fh ) ) { return MSPACK_ERR_DATAFORMAT ; } if ( sys -> seek ( fh , offset , MSPACK_SYS_SEEK_START ) ) { return MSPACK_ERR_SEEK ; } if ( sys -> read ( fh , & buf [ 0 ] , chmhs0_SIZEOF ) != chmhs0_SIZEOF ) { return MSPACK_ERR_READ ; } if ( read_off64 ( & chm -> length , & buf [ chmhs0_FileLen ] , sys , fh ) ) { return MSPACK_ERR_DATAFORMAT ; } if ( sys -> seek ( fh , chm -> dir_offset , MSPACK_SYS_SEEK_START ) ) { return MSPACK_ERR_SEEK ; } if ( sys -> read ( fh , & buf [ 0 ] , chmhs1_SIZEOF ) != chmhs1_SIZEOF ) { return MSPACK_ERR_READ ; } chm -> dir_offset = sys -> tell ( fh ) ; chm -> chunk_size = EndGetI32 ( & buf [ chmhs1_ChunkSize ] ) ; chm -> density = EndGetI32 ( & buf [ chmhs1_Density ] ) ; chm -> depth = EndGetI32 ( & buf [ chmhs1_Depth ] ) ; chm -> index_root = EndGetI32 ( & buf [ chmhs1_IndexRoot ] ) ; chm -> num_chunks = EndGetI32 ( & buf [ chmhs1_NumChunks ] ) ; chm -> first_pmgl = EndGetI32 ( & buf [ chmhs1_FirstPMGL ] ) ; chm -> last_pmgl = EndGetI32 ( & buf [ chmhs1_LastPMGL ] ) ; if ( chm -> version < 3 ) { chm -> sec0 . offset = chm -> dir_offset + ( chm -> chunk_size * chm -> num_chunks ) ; } if ( chm -> sec0 . offset > chm -> length ) { D ( ( \"content<S2SV_blank>section<S2SV_blank>begins<S2SV_blank>after<S2SV_blank>file<S2SV_blank>has<S2SV_blank>ended\" ) ) return MSPACK_ERR_DATAFORMAT ; } if ( chm -> chunk_size < ( pmgl_Entries + 2 ) ) { D ( ( \"chunk<S2SV_blank>size<S2SV_blank>not<S2SV_blank>large<S2SV_blank>enough\" ) ) return MSPACK_ERR_DATAFORMAT ; } if ( chm -> num_chunks == 0 ) { D ( ( \"no<S2SV_blank>chunks\" ) ) return MSPACK_ERR_DATAFORMAT ; } if ( chm -> num_chunks > 100000 ) { D ( ( \"more<S2SV_blank>than<S2SV_blank>100,000<S2SV_blank>chunks\" ) ) return MSPACK_ERR_DATAFORMAT ; } if ( ( off_t ) chm -> chunk_size * ( off_t ) chm -> num_chunks > chm -> length ) { D ( ( \"chunks<S2SV_blank>larger<S2SV_blank>than<S2SV_blank>entire<S2SV_blank>file\" ) ) return MSPACK_ERR_DATAFORMAT ; } if ( ( chm -> chunk_size & ( chm -> chunk_size - 1 ) ) != 0 ) { sys -> message ( fh , \"WARNING;<S2SV_blank>chunk<S2SV_blank>size<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>power<S2SV_blank>of<S2SV_blank>two\" ) ; } if ( chm -> first_pmgl != 0 ) { sys -> message ( fh , \"WARNING;<S2SV_blank>first<S2SV_blank>PMGL<S2SV_blank>chunk<S2SV_blank>is<S2SV_blank>not<S2SV_blank>zero\" ) ; } if ( chm -> first_pmgl > chm -> last_pmgl ) { D ( ( \"first<S2SV_blank>pmgl<S2SV_blank>chunk<S2SV_blank>is<S2SV_blank>after<S2SV_blank>last<S2SV_blank>pmgl<S2SV_blank>chunk\" ) ) return MSPACK_ERR_DATAFORMAT ; } <S2SV_StartBug> if ( chm -> index_root != 0xFFFFFFFF && chm -> index_root > chm -> num_chunks ) { <S2SV_EndBug> D ( ( \"index_root<S2SV_blank>outside<S2SV_blank>valid<S2SV_blank>range\" ) ) return MSPACK_ERR_DATAFORMAT ; } if ( ! entire ) { return MSPACK_ERR_OK ; } if ( ( x = chm -> first_pmgl ) != 0 ) { if ( sys -> seek ( fh , ( off_t ) ( x * chm -> chunk_size ) , MSPACK_SYS_SEEK_CUR ) ) { return MSPACK_ERR_SEEK ; } } num_chunks = chm -> last_pmgl - x + 1 ; if ( ! ( chunk = ( unsigned char * ) sys -> alloc ( sys , ( size_t ) chm -> chunk_size ) ) ) { return MSPACK_ERR_NOMEMORY ; } errors = 0 ; while ( num_chunks -- ) { if ( sys -> read ( fh , chunk , ( int ) chm -> chunk_size ) != ( int ) chm -> chunk_size ) { sys -> free ( chunk ) ; return MSPACK_ERR_READ ; } if ( EndGetI32 ( & chunk [ pmgl_Signature ] ) != 0x4C474D50 ) continue ; if ( EndGetI32 ( & chunk [ pmgl_QuickRefSize ] ) < 2 ) { sys -> message ( fh , \"WARNING;<S2SV_blank>PMGL<S2SV_blank>quickref<S2SV_blank>area<S2SV_blank>is<S2SV_blank>too<S2SV_blank>small\" ) ; } if ( EndGetI32 ( & chunk [ pmgl_QuickRefSize ] ) > ( ( int ) chm -> chunk_size - pmgl_Entries ) ) { sys -> message ( fh , \"WARNING;<S2SV_blank>PMGL<S2SV_blank>quickref<S2SV_blank>area<S2SV_blank>is<S2SV_blank>too<S2SV_blank>large\" ) ; } p = & chunk [ pmgl_Entries ] ; end = & chunk [ chm -> chunk_size - 2 ] ; num_entries = EndGetI16 ( end ) ; while ( num_entries -- ) { READ_ENCINT ( name_len ) ; if ( name_len > ( unsigned int ) ( end - p ) ) goto chunk_end ; <S2SV_StartBug> name = p ; p += name_len ; <S2SV_EndBug> READ_ENCINT ( section ) ; READ_ENCINT ( offset ) ; READ_ENCINT ( length ) ; if ( ( offset == 0 ) && ( length == 0 ) ) { if ( ( name_len > 0 ) && ( name [ name_len - 1 ] == '/' ) ) continue ; } if ( section > 1 ) { sys -> message ( fh , \"invalid<S2SV_blank>section<S2SV_blank>number<S2SV_blank>\\'%u\\'.\" , section ) ; continue ; } if ( ! ( fi = ( struct mschmd_file * ) sys -> alloc ( sys , sizeof ( struct mschmd_file ) + name_len + 1 ) ) ) { sys -> free ( chunk ) ; return MSPACK_ERR_NOMEMORY ; } fi -> next = NULL ; fi -> filename = ( char * ) & fi [ 1 ] ; fi -> section = ( ( section == 0 ) ? ( struct mschmd_section * ) ( & chm -> sec0 ) : ( struct mschmd_section * ) ( & chm -> sec1 ) ) ; fi -> offset = offset ; fi -> length = length ; sys -> copy ( name , fi -> filename , ( size_t ) name_len ) ; fi -> filename [ name_len ] = '\\\\0' ; if ( name [ 0 ] == ':' && name [ 1 ] == ':' ) { if ( mspack_memcmp ( & name [ 2 ] , & content_name [ 2 ] , 31L ) == 0 ) { if ( mspack_memcmp ( & name [ 33 ] , & content_name [ 33 ] , 8L ) == 0 ) { chm -> sec1 . content = fi ; } else if ( mspack_memcmp ( & name [ 33 ] , & control_name [ 33 ] , 11L ) == 0 ) { chm -> sec1 . control = fi ; } else if ( mspack_memcmp ( & name [ 33 ] , & spaninfo_name [ 33 ] , 8L ) == 0 ) { chm -> sec1 . spaninfo = fi ; } else if ( mspack_memcmp ( & name [ 33 ] , & rtable_name [ 33 ] , 72L ) == 0 ) { chm -> sec1 . rtable = fi ; } } fi -> next = chm -> sysfiles ; chm -> sysfiles = fi ; } else { if ( link ) link -> next = fi ; else chm -> files = fi ; link = fi ; } } chunk_end : if ( num_entries >= 0 ) { D ( ( \"chunk<S2SV_blank>ended<S2SV_blank>before<S2SV_blank>all<S2SV_blank>entries<S2SV_blank>could<S2SV_blank>be<S2SV_blank>read\" ) ) errors ++ ; } } sys -> free ( chunk ) ; return ( errors > 0 ) ? MSPACK_ERR_DATAFORMAT : MSPACK_ERR_OK ; }\n","target":"<S2SV_ModStart> chm -> index_root >= <S2SV_ModEnd> chm -> num_chunks <S2SV_ModStart> goto chunk_end ; if ( name_len == 0 ) goto chunk_end ;\n","project_and_commit_id":"kyz@libmspack/72e70a921f0f07fee748aec2274b30784e1d312a","cve_id":"CVE-2018-14680","original_address":"https://github.com/kyz/libmspack/commit/72e70a921f0f07fee748aec2274b30784e1d312a","time":"2018-07-28T23:29Z"},
	{"Unnamed: 0":6495,"cwe_id":"CWE-476","source":"CWE-476 static int mpeg4video_probe ( AVProbeData * probe_packet ) { uint32_t temp_buffer = - 1 ; int VO = 0 , VOL = 0 , VOP = 0 , VISO = 0 , res = 0 ; int i ; for ( i = 0 ; i < probe_packet -> buf_size ; i ++ ) { temp_buffer = ( temp_buffer << 8 ) + probe_packet -> buf [ i ] ; <S2SV_StartBug> if ( ( temp_buffer & 0xffffff00 ) != 0x100 ) <S2SV_EndBug> continue ; if ( temp_buffer == VOP_START_CODE ) VOP ++ ; else if ( temp_buffer == VISUAL_OBJECT_START_CODE ) VISO ++ ; <S2SV_StartBug> else if ( temp_buffer < 0x120 ) <S2SV_EndBug> VO ++ ; <S2SV_StartBug> else if ( temp_buffer < 0x130 ) <S2SV_EndBug> VOL ++ ; else if ( ! ( 0x1AF < temp_buffer && temp_buffer < 0x1B7 ) && ! ( 0x1B9 < temp_buffer && temp_buffer < 0x1C4 ) ) res ++ ; } if ( VOP >= VISO && VOP >= VOL && VO >= VOL && VOL > 0 && res == 0 ) return AVPROBE_SCORE_EXTENSION ; return 0 ; }\n","target":"<S2SV_ModStart> ; if ( temp_buffer & 0xfffffe00 ) continue ; if ( temp_buffer < 2 <S2SV_ModEnd> ) continue ; <S2SV_ModStart> if ( temp_buffer >= 0x100 && temp_buffer <S2SV_ModStart> else if ( temp_buffer >= 0x120 &&\n","project_and_commit_id":"libav@libav/e5b019725f53b79159931d3a7317107cbbfd0860","cve_id":"CVE-2016-8675","original_address":"https://github.com/libav/libav/commit/e5b019725f53b79159931d3a7317107cbbfd0860","time":"2017-02-15T21:59Z"},
	{"Unnamed: 0":6695,"cwe_id":"CWE-000","source":"CWE-000 static int unix_dgram_sendmsg ( struct socket * sock , struct msghdr * msg , size_t len ) { struct sock * sk = sock -> sk ; struct net * net = sock_net ( sk ) ; struct unix_sock * u = unix_sk ( sk ) ; DECLARE_SOCKADDR ( struct sockaddr_un * , sunaddr , msg -> msg_name ) ; struct sock * other = NULL ; int namelen = 0 ; int err ; unsigned int hash ; struct sk_buff * skb ; long timeo ; struct scm_cookie scm ; int max_level ; int data_len = 0 ; <S2SV_StartBug> wait_for_unix_gc ( ) ; <S2SV_EndBug> err = scm_send ( sock , msg , & scm , false ) ; if ( err < 0 ) return err ; err = - EOPNOTSUPP ; if ( msg -> msg_flags & MSG_OOB ) goto out ; if ( msg -> msg_namelen ) { err = unix_mkname ( sunaddr , msg -> msg_namelen , & hash ) ; if ( err < 0 ) goto out ; namelen = err ; } else { sunaddr = NULL ; err = - ENOTCONN ; other = unix_peer_get ( sk ) ; if ( ! other ) goto out ; } if ( test_bit ( SOCK_PASSCRED , & sock -> flags ) && ! u -> addr && ( err = unix_autobind ( sock ) ) != 0 ) goto out ; err = - EMSGSIZE ; if ( len > sk -> sk_sndbuf - 32 ) goto out ; if ( len > SKB_MAX_ALLOC ) { data_len = min_t ( size_t , len - SKB_MAX_ALLOC , MAX_SKB_FRAGS * PAGE_SIZE ) ; data_len = PAGE_ALIGN ( data_len ) ; BUILD_BUG_ON ( SKB_MAX_ALLOC < PAGE_SIZE ) ; } skb = sock_alloc_send_pskb ( sk , len - data_len , data_len , msg -> msg_flags & MSG_DONTWAIT , & err , PAGE_ALLOC_COSTLY_ORDER ) ; if ( skb == NULL ) goto out ; err = unix_scm_to_skb ( & scm , skb , true ) ; if ( err < 0 ) goto out_free ; max_level = err + 1 ; skb_put ( skb , len - data_len ) ; skb -> data_len = data_len ; skb -> len = len ; err = skb_copy_datagram_from_iter ( skb , 0 , & msg -> msg_iter , len ) ; if ( err ) goto out_free ; timeo = sock_sndtimeo ( sk , msg -> msg_flags & MSG_DONTWAIT ) ; restart : if ( ! other ) { err = - ECONNRESET ; if ( sunaddr == NULL ) goto out_free ; other = unix_find_other ( net , sunaddr , namelen , sk -> sk_type , hash , & err ) ; if ( other == NULL ) goto out_free ; } if ( sk_filter ( other , skb ) < 0 ) { err = len ; goto out_free ; } <S2SV_StartBug> unix_state_lock ( other ) ; <S2SV_EndBug> err = - EPERM ; if ( ! unix_may_send ( sk , other ) ) goto out_unlock ; <S2SV_StartBug> if ( sock_flag ( other , SOCK_DEAD ) ) { <S2SV_EndBug> unix_state_unlock ( other ) ; sock_put ( other ) ; <S2SV_StartBug> err = 0 ; <S2SV_EndBug> <S2SV_StartBug> unix_state_lock ( sk ) ; <S2SV_EndBug> if ( unix_peer ( sk ) == other ) { <S2SV_StartBug> unix_peer ( sk ) = NULL ; <S2SV_EndBug> unix_state_unlock ( sk ) ; unix_dgram_disconnected ( sk , other ) ; sock_put ( other ) ; err = - ECONNREFUSED ; } else { unix_state_unlock ( sk ) ; } other = NULL ; if ( err ) goto out_free ; goto restart ; } err = - EPIPE ; if ( other -> sk_shutdown & RCV_SHUTDOWN ) goto out_unlock ; if ( sk -> sk_type != SOCK_SEQPACKET ) { err = security_unix_may_send ( sk -> sk_socket , other -> sk_socket ) ; if ( err ) goto out_unlock ; } <S2SV_StartBug> if ( unix_peer ( other ) != sk && unix_recvq_full ( other ) ) { <S2SV_EndBug> <S2SV_StartBug> if ( ! timeo ) { <S2SV_EndBug> err = - EAGAIN ; <S2SV_StartBug> goto out_unlock ; <S2SV_EndBug> } <S2SV_StartBug> timeo = unix_wait_for_peer ( other , timeo ) ; <S2SV_EndBug> err = sock_intr_errno ( timeo ) ; if ( signal_pending ( current ) ) goto out_free ; goto restart ; } if ( sock_flag ( other , SOCK_RCVTSTAMP ) ) __net_timestamp ( skb ) ; maybe_add_creds ( skb , sock , other ) ; skb_queue_tail ( & other -> sk_receive_queue , skb ) ; if ( max_level > unix_sk ( other ) -> recursion_level ) unix_sk ( other ) -> recursion_level = max_level ; unix_state_unlock ( other ) ; other -> sk_data_ready ( other ) ; sock_put ( other ) ; scm_destroy ( & scm ) ; return len ; out_unlock : <S2SV_StartBug> unix_state_unlock ( other ) ; <S2SV_EndBug> out_free : kfree_skb ( skb ) ; out : if ( other ) sock_put ( other ) ; scm_destroy ( & scm ) ; return err ; }\n","target":"<S2SV_ModStart> = 0 ; int sk_locked ; <S2SV_ModStart> out_free ; } sk_locked = 0 ; <S2SV_ModStart> other ) ; restart_locked : <S2SV_ModStart> ; if ( unlikely ( <S2SV_ModStart> SOCK_DEAD ) ) ) <S2SV_ModStart> other ) ; if ( ! sk_locked ) unix_state_lock ( sk ) ; <S2SV_ModStart> = 0 ; <S2SV_ModEnd> if ( unix_peer <S2SV_ModStart> ) = NULL ; unix_dgram_peer_wake_disconnect_wakeup ( sk , other ) <S2SV_ModStart> } if ( unlikely ( <S2SV_ModStart> other ) ) ) { if ( timeo ) { timeo = unix_wait_for_peer ( other , timeo ) ; err = sock_intr_errno ( timeo ) ; if ( signal_pending ( current ) ) goto out_free ; goto restart ; } <S2SV_ModEnd> if ( ! <S2SV_ModStart> if ( ! sk_locked ) { unix_state_unlock ( other ) ; unix_state_double_lock ( sk , other ) ; } if ( unix_peer ( sk ) != other || unix_dgram_peer_wake_me ( sk , other ) <S2SV_ModEnd> ) { err <S2SV_ModStart> - EAGAIN ; sk_locked = 1 ; <S2SV_ModStart> out_unlock ; } if ( ! sk_locked ) { sk_locked = 1 ; goto restart_locked ; } } if ( unlikely ( sk_locked ) ) unix_state_unlock ( sk ) ; <S2SV_ModEnd> if ( sock_flag <S2SV_ModStart> ; out_unlock : if ( sk_locked ) unix_state_unlock ( sk ) ;\n","project_and_commit_id":"torvalds@linux/7d267278a9ece963d77eefec61630223fce08c6c","cve_id":"CVE-2013-7446","original_address":"https://github.com/torvalds/linux/commit/7d267278a9ece963d77eefec61630223fce08c6c","time":"2015-12-28T11:59Z"},
	{"Unnamed: 0":5864,"cwe_id":"CWE-125","source":"CWE-125 static arguments_ty ast_for_arguments ( struct compiling * c , const node * n ) { int i , j , k , nposargs = 0 , nkwonlyargs = 0 ; int nposdefaults = 0 , found_default = 0 ; asdl_seq * posargs , * posdefaults , * kwonlyargs , * kwdefaults ; arg_ty vararg = NULL , kwarg = NULL ; arg_ty arg ; node * ch ; if ( TYPE ( n ) == parameters ) { if ( NCH ( n ) == 2 ) return arguments ( NULL , NULL , NULL , NULL , NULL , NULL , c -> c_arena ) ; n = CHILD ( n , 1 ) ; } assert ( TYPE ( n ) == typedargslist || TYPE ( n ) == varargslist ) ; for ( i = 0 ; i < NCH ( n ) ; i ++ ) { ch = CHILD ( n , i ) ; if ( TYPE ( ch ) == STAR ) { i ++ ; if ( i < NCH ( n ) && ( TYPE ( CHILD ( n , i ) ) == tfpdef || TYPE ( CHILD ( n , i ) ) == vfpdef ) ) { i ++ ; } break ; } if ( TYPE ( ch ) == DOUBLESTAR ) break ; if ( TYPE ( ch ) == vfpdef || TYPE ( ch ) == tfpdef ) nposargs ++ ; if ( TYPE ( ch ) == EQUAL ) nposdefaults ++ ; } for ( ; i < NCH ( n ) ; ++ i ) { ch = CHILD ( n , i ) ; if ( TYPE ( ch ) == DOUBLESTAR ) break ; if ( TYPE ( ch ) == tfpdef || TYPE ( ch ) == vfpdef ) nkwonlyargs ++ ; } posargs = ( nposargs ? _Ta3_asdl_seq_new ( nposargs , c -> c_arena ) : NULL ) ; if ( ! posargs && nposargs ) return NULL ; kwonlyargs = ( nkwonlyargs ? _Ta3_asdl_seq_new ( nkwonlyargs , c -> c_arena ) : NULL ) ; if ( ! kwonlyargs && nkwonlyargs ) return NULL ; posdefaults = ( nposdefaults ? _Ta3_asdl_seq_new ( nposdefaults , c -> c_arena ) : NULL ) ; if ( ! posdefaults && nposdefaults ) return NULL ; kwdefaults = ( nkwonlyargs ? _Ta3_asdl_seq_new ( nkwonlyargs , c -> c_arena ) : NULL ) ; if ( ! kwdefaults && nkwonlyargs ) return NULL ; <S2SV_StartBug> if ( nposargs + nkwonlyargs > 255 ) { <S2SV_EndBug> ast_error ( c , n , \"more<S2SV_blank>than<S2SV_blank>255<S2SV_blank>arguments\" ) ; return NULL ; } i = 0 ; j = 0 ; k = 0 ; while ( i < NCH ( n ) ) { ch = CHILD ( n , i ) ; switch ( TYPE ( ch ) ) { case tfpdef : case vfpdef : if ( i + 1 < NCH ( n ) && TYPE ( CHILD ( n , i + 1 ) ) == EQUAL ) { expr_ty expression = ast_for_expr ( c , CHILD ( n , i + 2 ) ) ; if ( ! expression ) return NULL ; assert ( posdefaults != NULL ) ; asdl_seq_SET ( posdefaults , j ++ , expression ) ; i += 2 ; found_default = 1 ; } else if ( found_default ) { ast_error ( c , n , \"non-default<S2SV_blank>argument<S2SV_blank>follows<S2SV_blank>default<S2SV_blank>argument\" ) ; return NULL ; } arg = ast_for_arg ( c , ch ) ; if ( ! arg ) return NULL ; asdl_seq_SET ( posargs , k ++ , arg ) ; i += 1 ; <S2SV_StartBug> if ( i < NCH ( n ) && TYPE ( CHILD ( n , i ) ) == COMMA ) <S2SV_EndBug> i += 1 ; break ; case STAR : if ( i + 1 >= NCH ( n ) || ( i + 2 == NCH ( n ) && ( TYPE ( CHILD ( n , i + 1 ) ) == COMMA || TYPE ( CHILD ( n , i + 1 ) ) == TYPE_COMMENT ) ) ) { ast_error ( c , CHILD ( n , i ) , \"named<S2SV_blank>arguments<S2SV_blank>must<S2SV_blank>follow<S2SV_blank>bare<S2SV_blank>*\" ) ; return NULL ; } ch = CHILD ( n , i + 1 ) ; if ( TYPE ( ch ) == COMMA ) { int res = 0 ; i += 2 ; <S2SV_StartBug> if ( i < NCH ( n ) && TYPE ( CHILD ( n , i ) ) == TYPE_COMMENT ) { <S2SV_EndBug> ast_error ( c , CHILD ( n , i ) , \"bare<S2SV_blank>*<S2SV_blank>has<S2SV_blank>associated<S2SV_blank>type<S2SV_blank>comment\" ) ; return NULL ; } res = handle_keywordonly_args ( c , n , i , kwonlyargs , kwdefaults ) ; if ( res == - 1 ) return NULL ; i = res ; } else { vararg = ast_for_arg ( c , ch ) ; if ( ! vararg ) return NULL ; i += 2 ; <S2SV_StartBug> if ( i < NCH ( n ) && TYPE ( CHILD ( n , i ) ) == COMMA ) <S2SV_EndBug> i += 1 ; <S2SV_StartBug> if ( i < NCH ( n ) && TYPE ( CHILD ( n , i ) ) == TYPE_COMMENT ) { <S2SV_EndBug> vararg -> type_comment = NEW_TYPE_COMMENT ( CHILD ( n , i ) ) ; i += 1 ; } if ( i < NCH ( n ) && ( TYPE ( CHILD ( n , i ) ) == tfpdef || TYPE ( CHILD ( n , i ) ) == vfpdef ) ) { int res = 0 ; res = handle_keywordonly_args ( c , n , i , kwonlyargs , kwdefaults ) ; if ( res == - 1 ) return NULL ; i = res ; } } break ; case DOUBLESTAR : ch = CHILD ( n , i + 1 ) ; assert ( TYPE ( ch ) == tfpdef || TYPE ( ch ) == vfpdef ) ; kwarg = ast_for_arg ( c , ch ) ; if ( ! kwarg ) return NULL ; i += 2 ; <S2SV_StartBug> if ( i < NCH ( n ) && TYPE ( CHILD ( n , i ) ) == COMMA ) <S2SV_EndBug> i += 1 ; break ; case TYPE_COMMENT : assert ( i ) ; if ( kwarg ) arg = kwarg ; arg -> type_comment = NEW_TYPE_COMMENT ( ch ) ; i += 1 ; break ; default : PyErr_Format ( PyExc_SystemError , \"unexpected<S2SV_blank>node<S2SV_blank>in<S2SV_blank>varargslist:<S2SV_blank>%d<S2SV_blank>@<S2SV_blank>%d\" , TYPE ( ch ) , i ) ; return NULL ; } } return arguments ( posargs , vararg , kwonlyargs , kwdefaults , kwarg , posdefaults , c -> c_arena ) ; }\n","target":"<S2SV_ModStart> return NULL ; <S2SV_ModEnd> i = 0 <S2SV_ModStart> ; if ( <S2SV_ModEnd> TYPE ( CHILD <S2SV_ModStart> ; if ( <S2SV_ModEnd> TYPE ( CHILD <S2SV_ModStart> ; if ( <S2SV_ModEnd> TYPE ( CHILD <S2SV_ModStart> ; if ( <S2SV_ModEnd> TYPE ( CHILD <S2SV_ModStart> ; if ( <S2SV_ModEnd> TYPE ( CHILD\n","project_and_commit_id":"python@typed_ast/156afcb26c198e162504a57caddfe0acd9ed7dce","cve_id":"CVE-2019-19275","original_address":"https://github.com/python/typed_ast/commit/156afcb26c198e162504a57caddfe0acd9ed7dce","time":"2019-11-26T15:15Z"},
	{"Unnamed: 0":3680,"cwe_id":"CWE-17","source":"CWE-17 static ssize_t <S2SV_StartBug> pipe_write ( struct kiocb * iocb , const struct iovec * _iov , <S2SV_EndBug> unsigned long nr_segs , loff_t ppos ) { struct file * filp = iocb -> ki_filp ; struct pipe_inode_info * pipe = filp -> private_data ; <S2SV_StartBug> ssize_t ret ; <S2SV_EndBug> <S2SV_StartBug> int do_wakeup ; <S2SV_EndBug> struct iovec * iov = ( struct iovec * ) _iov ; <S2SV_StartBug> size_t total_len ; <S2SV_EndBug> ssize_t chars ; <S2SV_StartBug> total_len = iov_length ( iov , nr_segs ) ; <S2SV_EndBug> if ( unlikely ( total_len == 0 ) ) <S2SV_StartBug> return 0 ; <S2SV_EndBug> do_wakeup = 0 ; ret = 0 ; __pipe_lock ( pipe ) ; if ( ! pipe -> readers ) { send_sig ( SIGPIPE , current , 0 ) ; ret = - EPIPE ; goto out ; } chars = total_len & ( PAGE_SIZE - 1 ) ; if ( pipe -> nrbufs && chars != 0 ) { int lastbuf = ( pipe -> curbuf + pipe -> nrbufs - 1 ) & ( pipe -> buffers - 1 ) ; struct pipe_buffer * buf = pipe -> bufs + lastbuf ; const struct pipe_buf_operations * ops = buf -> ops ; int offset = buf -> offset + buf -> len ; if ( ops -> can_merge && offset + chars <= PAGE_SIZE ) { <S2SV_StartBug> int error , atomic = 1 ; <S2SV_EndBug> void * addr ; error = ops -> confirm ( pipe , buf ) ; if ( error ) goto out ; <S2SV_StartBug> iov_fault_in_pages_read ( iov , chars ) ; <S2SV_EndBug> redo1 : if ( atomic ) addr = kmap_atomic ( buf -> page ) ; else addr = kmap ( buf -> page ) ; error = pipe_iov_copy_from_user ( offset + addr , iov , chars , atomic ) ; if ( atomic ) kunmap_atomic ( addr ) ; else kunmap ( buf -> page ) ; ret = error ; do_wakeup = 1 ; if ( error ) { if ( atomic ) { atomic = 0 ; goto redo1 ; } goto out ; <S2SV_StartBug> } <S2SV_EndBug> buf -> len += chars ; <S2SV_StartBug> total_len -= chars ; <S2SV_EndBug> ret = chars ; if ( ! total_len ) goto out ; } } for ( ; ; ) { int bufs ; if ( ! pipe -> readers ) { send_sig ( SIGPIPE , current , 0 ) ; if ( ! ret ) ret = - EPIPE ; break ; } bufs = pipe -> nrbufs ; if ( bufs < pipe -> buffers ) { int newbuf = ( pipe -> curbuf + bufs ) & ( pipe -> buffers - 1 ) ; struct pipe_buffer * buf = pipe -> bufs + newbuf ; struct page * page = pipe -> tmp_page ; <S2SV_StartBug> char * src ; <S2SV_EndBug> int error , atomic = 1 ; if ( ! page ) { page = alloc_page ( GFP_HIGHUSER ) ; if ( unlikely ( ! page ) ) { ret = ret ? : - ENOMEM ; break ; } pipe -> tmp_page = page ; } do_wakeup = 1 ; <S2SV_StartBug> chars = PAGE_SIZE ; <S2SV_EndBug> if ( chars > total_len ) chars = total_len ; iov_fault_in_pages_read ( iov , chars ) ; redo2 : if ( atomic ) src = kmap_atomic ( page ) ; else src = kmap ( page ) ; error = pipe_iov_copy_from_user ( src , iov , chars , atomic ) ; if ( atomic ) kunmap_atomic ( src ) ; else kunmap ( page ) ; <S2SV_StartBug> if ( unlikely ( error ) ) { <S2SV_EndBug> if ( atomic ) { atomic = 0 ; goto redo2 ; } if ( ! ret ) ret = error ; break ; } <S2SV_StartBug> ret += chars ; <S2SV_EndBug> buf -> page = page ; buf -> ops = & anon_pipe_buf_ops ; buf -> offset = 0 ; <S2SV_StartBug> buf -> len = chars ; <S2SV_EndBug> buf -> flags = 0 ; if ( is_packetized ( filp ) ) { buf -> ops = & packet_pipe_buf_ops ; buf -> flags = PIPE_BUF_FLAG_PACKET ; } pipe -> nrbufs = ++ bufs ; pipe -> tmp_page = NULL ; <S2SV_StartBug> total_len -= chars ; <S2SV_EndBug> if ( ! total_len ) break ; } if ( bufs < pipe -> buffers ) continue ; if ( filp -> f_flags & O_NONBLOCK ) { if ( ! ret ) ret = - EAGAIN ; break ; } if ( signal_pending ( current ) ) { if ( ! ret ) ret = - ERESTARTSYS ; break ; } if ( do_wakeup ) { wake_up_interruptible_sync_poll ( & pipe -> wait , POLLIN | POLLRDNORM ) ; kill_fasync ( & pipe -> fasync_readers , SIGIO , POLL_IN ) ; do_wakeup = 0 ; } pipe -> waiting_writers ++ ; pipe_wait ( pipe ) ; pipe -> waiting_writers -- ; } out : __pipe_unlock ( pipe ) ; if ( do_wakeup ) { wake_up_interruptible_sync_poll ( & pipe -> wait , POLLIN | POLLRDNORM ) ; kill_fasync ( & pipe -> fasync_readers , SIGIO , POLL_IN ) ; } if ( ret > 0 && sb_start_write_trylock ( file_inode ( filp ) -> i_sb ) ) { int err = file_update_time ( filp ) ; if ( err ) ret = err ; sb_end_write ( file_inode ( filp ) -> i_sb ) ; } return ret ; }\n","target":"<S2SV_ModStart> * iocb , struct iov_iter * from <S2SV_ModEnd> ) { struct <S2SV_ModStart> ; ssize_t ret = 0 <S2SV_ModStart> ; int do_wakeup = 0 <S2SV_ModEnd> ; size_t total_len <S2SV_ModStart> ; size_t total_len = iov_iter_count ( from ) <S2SV_ModStart> ssize_t chars ; <S2SV_ModEnd> if ( unlikely <S2SV_ModStart> ) ) return <S2SV_ModEnd> 0 ; __pipe_lock <S2SV_ModStart> { int error <S2SV_ModEnd> = ops -> <S2SV_ModStart> goto out ; ret = copy_page_from_iter ( buf -> page , offset , chars , from ) ; if ( unlikely ( ret < chars ) ) { error = - EFAULT ; <S2SV_ModEnd> goto out ; <S2SV_ModStart> out ; } do_wakeup = 1 ; <S2SV_ModStart> += chars ; ret = chars ; if ( ! iov_iter_count ( from ) <S2SV_ModEnd> ) goto out <S2SV_ModStart> -> tmp_page ; int copied <S2SV_ModEnd> ; if ( <S2SV_ModStart> = 1 ; copied = copy_page_from_iter ( page , 0 , PAGE_SIZE , from <S2SV_ModEnd> ) ; if <S2SV_ModStart> ( unlikely ( copied < PAGE_SIZE && iov_iter_count ( from ) ) ) { if ( ! ret ) ret = - EFAULT <S2SV_ModEnd> ; break ; <S2SV_ModStart> } ret += copied <S2SV_ModEnd> ; buf -> <S2SV_ModStart> -> len = copied <S2SV_ModEnd> ; buf -> <S2SV_ModStart> = NULL ; if ( ! iov_iter_count ( from ) <S2SV_ModEnd> ) break ;\n","project_and_commit_id":"torvalds@linux/f0d1bec9d58d4c038d0ac958c9af82be6eb18045","cve_id":"CVE-2015-1805","original_address":"https://github.com/torvalds/linux/commit/f0d1bec9d58d4c038d0ac958c9af82be6eb18045","time":"2015-08-08T10:59Z"},
	{"Unnamed: 0":1526,"cwe_id":"CWE-119","source":"CWE-119 unsigned int X509v3_addr_get_afi ( const IPAddressFamily * f ) { <S2SV_StartBug> return ( ( f != NULL && <S2SV_EndBug> <S2SV_StartBug> f -> addressFamily != NULL && f -> addressFamily -> data != NULL ) <S2SV_EndBug> <S2SV_StartBug> ? ( ( f -> addressFamily -> data [ 0 ] << 8 ) | ( f -> addressFamily -> data [ 1 ] ) ) <S2SV_EndBug> : 0 ) ; }\n","target":"<S2SV_ModStart> f ) { if ( f == NULL || <S2SV_ModEnd> f -> addressFamily <S2SV_ModStart> f -> addressFamily == NULL || <S2SV_ModEnd> f -> addressFamily <S2SV_ModStart> addressFamily -> data == NULL || f -> addressFamily -> length < 2 ) return 0 ; return <S2SV_ModEnd> ( f -> <S2SV_ModStart> 8 ) | <S2SV_ModEnd> f -> addressFamily <S2SV_ModStart> [ 1 ] <S2SV_ModEnd> ; } <S2SV_null>\n","project_and_commit_id":"openssl@openssl/068b963bb7afc57f5bdd723de0dd15e7795d5822","cve_id":"CVE-2017-3735","original_address":"https://github.com/openssl/openssl/commit/068b963bb7afc57f5bdd723de0dd15e7795d5822","time":"2017-08-28T19:29Z"},
	{"Unnamed: 0":6401,"cwe_id":"CWE-125","source":"CWE-125 void qedi_dbg_warn ( struct qedi_dbg_ctx * qedi , const char * func , u32 line , const char * fmt , ... ) { va_list va ; <S2SV_StartBug> struct va_format vaf ; <S2SV_EndBug> char nfunc [ 32 ] ; memset ( nfunc , 0 , sizeof ( nfunc ) ) ; memcpy ( nfunc , func , sizeof ( nfunc ) - 1 ) ; va_start ( va , fmt ) ; vaf . fmt = fmt ; vaf . va = & va ; if ( ! ( qedi_dbg_log & QEDI_LOG_WARN ) ) goto ret ; if ( likely ( qedi ) && likely ( qedi -> pdev ) ) pr_warn ( \"[%s]:[%s:%d]:%d:<S2SV_blank>%pV\" , dev_name ( & qedi -> pdev -> dev ) , <S2SV_StartBug> nfunc , line , qedi -> host_no , & vaf ) ; <S2SV_EndBug> else <S2SV_StartBug> pr_warn ( \"[0000:00:00.0]:[%s:%d]:<S2SV_blank>%pV\" , nfunc , line , & vaf ) ; <S2SV_EndBug> ret : va_end ( va ) ; }\n","target":"<S2SV_ModStart> struct va_format vaf <S2SV_ModEnd> ; va_start ( <S2SV_ModStart> dev ) , func <S2SV_ModEnd> , line , <S2SV_ModStart> ( \"[0000:00:00.0]:[%s:%d]:<S2SV_blank>%pV\" , func <S2SV_ModEnd> , line ,\n","project_and_commit_id":"torvalds@linux/c09581a52765a85f19fc35340127396d5e3379cc","cve_id":"CVE-2019-15090","original_address":"https://github.com/torvalds/linux/commit/c09581a52765a85f19fc35340127396d5e3379cc","time":"2019-08-16T00:15Z"},
	{"Unnamed: 0":4779,"cwe_id":"CWE-20","source":"CWE-20 static int wb_id ( netdissect_options * ndo , const struct pkt_id * id , u_int len ) { int i ; const char * cp ; const struct id_off * io ; char c ; int nid ; ND_PRINT ( ( ndo , \"<S2SV_blank>wb-id:\" ) ) ; if ( len < sizeof ( * id ) || ! ND_TTEST ( * id ) ) return ( - 1 ) ; len -= sizeof ( * id ) ; ND_PRINT ( ( ndo , \"<S2SV_blank>%u/%s:%u<S2SV_blank>(max<S2SV_blank>%u/%s:%u)<S2SV_blank>\" , EXTRACT_32BITS ( & id -> pi_ps . slot ) , ipaddr_string ( ndo , & id -> pi_ps . page . p_sid ) , EXTRACT_32BITS ( & id -> pi_ps . page . p_uid ) , EXTRACT_32BITS ( & id -> pi_mslot ) , ipaddr_string ( ndo , & id -> pi_mpage . p_sid ) , EXTRACT_32BITS ( & id -> pi_mpage . p_uid ) ) ) ; nid = EXTRACT_16BITS ( & id -> pi_ps . nid ) ; len -= sizeof ( * io ) * nid ; io = ( struct id_off * ) ( id + 1 ) ; cp = ( char * ) ( io + nid ) ; <S2SV_StartBug> if ( ! ND_TTEST2 ( cp , len ) ) { <S2SV_EndBug> ND_PRINT ( ( ndo , \"\\\\\"\" ) ) ; fn_print ( ndo , ( u_char * ) cp , ( u_char * ) cp + len ) ; ND_PRINT ( ( ndo , \"\\\\\"\" ) ) ; } c = '<' ; for ( i = 0 ; i < nid && ND_TTEST ( * io ) ; ++ io , ++ i ) { ND_PRINT ( ( ndo , \"%c%s:%u\" , c , ipaddr_string ( ndo , & io -> id ) , EXTRACT_32BITS ( & io -> off ) ) ) ; c = ',' ; } if ( i >= nid ) { ND_PRINT ( ( ndo , \">\" ) ) ; return ( 0 ) ; } return ( - 1 ) ; }\n","target":"<S2SV_ModStart> ; if ( <S2SV_ModEnd> ND_TTEST2 ( cp\n","project_and_commit_id":"the-tcpdump-group@tcpdump/3ed82f4ed0095768529afc22b923c8f7171fff70","cve_id":"CVE-2015-3138","original_address":"https://github.com/the-tcpdump-group/tcpdump/commit/3ed82f4ed0095768529afc22b923c8f7171fff70","time":"2017-09-28T01:29Z"},
	{"Unnamed: 0":5362,"cwe_id":"CWE-189","source":"CWE-189 static void nfs4_xdr_enc_getacl ( struct rpc_rqst * req , struct xdr_stream * xdr , struct nfs_getaclargs * args ) { struct compound_hdr hdr = { . minorversion = nfs4_xdr_minorversion ( & args -> seq_args ) , } ; uint32_t replen ; encode_compound_hdr ( xdr , req , & hdr ) ; encode_sequence ( xdr , & args -> seq_args , & hdr ) ; encode_putfh ( xdr , args -> fh , & hdr ) ; <S2SV_StartBug> replen = hdr . replen + op_decode_hdr_maxsz + nfs4_fattr_bitmap_maxsz + 1 ; <S2SV_EndBug> encode_getattr_two ( xdr , FATTR4_WORD0_ACL , 0 , & hdr ) ; xdr_inline_pages ( & req -> rq_rcv_buf , replen << 2 , args -> acl_pages , args -> acl_pgbase , args -> acl_len ) ; <S2SV_StartBug> encode_nops ( & hdr ) ; <S2SV_EndBug> }\n","target":"<S2SV_ModStart> + op_decode_hdr_maxsz + <S2SV_ModEnd> 1 ; encode_getattr_two <S2SV_ModStart> acl_len ) ; xdr_set_scratch_buffer ( xdr , page_address ( args -> acl_scratch ) , PAGE_SIZE ) ;\n","project_and_commit_id":"torvalds@linux/bf118a342f10dafe44b14451a1392c3254629a1f","cve_id":"CVE-2011-4131","original_address":"https://github.com/torvalds/linux/commit/bf118a342f10dafe44b14451a1392c3254629a1f","time":"2012-05-17T11:00Z"},
	{"Unnamed: 0":4115,"cwe_id":"CWE-000","source":"CWE-000 static int create_fixed_stream_quirk ( struct snd_usb_audio * chip , struct usb_interface * iface , struct usb_driver * driver , const struct snd_usb_audio_quirk * quirk ) { struct audioformat * fp ; struct usb_host_interface * alts ; struct usb_interface_descriptor * altsd ; int stream , err ; unsigned * rate_table = NULL ; fp = kmemdup ( quirk -> data , sizeof ( * fp ) , GFP_KERNEL ) ; if ( ! fp ) { usb_audio_err ( chip , \"cannot<S2SV_blank>memdup\\\\n\" ) ; return - ENOMEM ; } if ( fp -> nr_rates > MAX_NR_RATES ) { kfree ( fp ) ; return - EINVAL ; } if ( fp -> nr_rates > 0 ) { rate_table = kmemdup ( fp -> rate_table , sizeof ( int ) * fp -> nr_rates , GFP_KERNEL ) ; if ( ! rate_table ) { kfree ( fp ) ; return - ENOMEM ; } fp -> rate_table = rate_table ; } stream = ( fp -> endpoint & USB_DIR_IN ) ? SNDRV_PCM_STREAM_CAPTURE : SNDRV_PCM_STREAM_PLAYBACK ; err = snd_usb_add_audio_stream ( chip , stream , fp ) ; if ( err < 0 ) { kfree ( fp ) ; kfree ( rate_table ) ; return err ; } if ( fp -> iface != get_iface_desc ( & iface -> altsetting [ 0 ] ) -> bInterfaceNumber || fp -> altset_idx >= iface -> num_altsetting ) { kfree ( fp ) ; kfree ( rate_table ) ; return - EINVAL ; } alts = & iface -> altsetting [ fp -> altset_idx ] ; altsd = get_iface_desc ( alts ) ; <S2SV_StartBug> fp -> protocol = altsd -> bInterfaceProtocol ; <S2SV_EndBug> if ( fp -> datainterval == 0 ) fp -> datainterval = snd_usb_parse_datainterval ( chip , alts ) ; if ( fp -> maxpacksize == 0 ) fp -> maxpacksize = le16_to_cpu ( get_endpoint ( alts , 0 ) -> wMaxPacketSize ) ; usb_set_interface ( chip -> dev , fp -> iface , 0 ) ; snd_usb_init_pitch ( chip , fp -> iface , alts , fp ) ; snd_usb_init_sample_rate ( chip , fp -> iface , alts , fp , fp -> rate_max ) ; return 0 ; }\n","target":"<S2SV_ModStart> alts ) ; if ( altsd -> bNumEndpoints < 1 ) { kfree ( fp ) ; kfree ( rate_table ) ; return - EINVAL ; }\n","project_and_commit_id":"torvalds@linux/0f886ca12765d20124bd06291c82951fd49a33be","cve_id":"CVE-2016-2184","original_address":"https://github.com/torvalds/linux/commit/0f886ca12765d20124bd06291c82951fd49a33be","time":"2016-04-27T17:59Z"},
	{"Unnamed: 0":13,"cwe_id":"CWE-20","source":"CWE-20 int HTMLtagproc1 ( struct parsed_tag * tag , struct html_feed_environ * h_env ) { char * p , * q , * r ; int i , w , x , y , z , count , width ; struct readbuffer * obuf = h_env -> obuf ; struct environment * envs = h_env -> envs ; Str tmp ; int hseq ; int cmd ; # ifdef ID_EXT char * id = NULL ; # endif cmd = tag -> tagid ; if ( obuf -> flag & RB_PRE ) { switch ( cmd ) { case HTML_NOBR : case HTML_N_NOBR : case HTML_PRE_INT : case HTML_N_PRE_INT : return 1 ; } } switch ( cmd ) { case HTML_B : obuf -> in_bold ++ ; if ( obuf -> in_bold > 1 ) return 1 ; return 0 ; case HTML_N_B : if ( obuf -> in_bold == 1 && close_effect0 ( obuf , HTML_B ) ) obuf -> in_bold = 0 ; if ( obuf -> in_bold > 0 ) { obuf -> in_bold -- ; if ( obuf -> in_bold == 0 ) return 0 ; } return 1 ; case HTML_I : obuf -> in_italic ++ ; if ( obuf -> in_italic > 1 ) return 1 ; return 0 ; case HTML_N_I : if ( obuf -> in_italic == 1 && close_effect0 ( obuf , HTML_I ) ) obuf -> in_italic = 0 ; if ( obuf -> in_italic > 0 ) { obuf -> in_italic -- ; if ( obuf -> in_italic == 0 ) return 0 ; } return 1 ; case HTML_U : obuf -> in_under ++ ; if ( obuf -> in_under > 1 ) return 1 ; return 0 ; case HTML_N_U : if ( obuf -> in_under == 1 && close_effect0 ( obuf , HTML_U ) ) obuf -> in_under = 0 ; if ( obuf -> in_under > 0 ) { obuf -> in_under -- ; if ( obuf -> in_under == 0 ) return 0 ; } return 1 ; case HTML_EM : HTMLlineproc1 ( \"<i>\" , h_env ) ; return 1 ; case HTML_N_EM : HTMLlineproc1 ( \"</i>\" , h_env ) ; return 1 ; case HTML_STRONG : HTMLlineproc1 ( \"<b>\" , h_env ) ; return 1 ; case HTML_N_STRONG : HTMLlineproc1 ( \"</b>\" , h_env ) ; return 1 ; case HTML_Q : HTMLlineproc1 ( \"`\" , h_env ) ; return 1 ; case HTML_N_Q : HTMLlineproc1 ( \"\\'\" , h_env ) ; return 1 ; case HTML_P : case HTML_N_P : CLOSE_A ; if ( ! ( obuf -> flag & RB_IGNORE_P ) ) { flushline ( h_env , obuf , envs [ h_env -> envc ] . indent , 1 , h_env -> limit ) ; do_blankline ( h_env , obuf , envs [ h_env -> envc ] . indent , 0 , h_env -> limit ) ; } obuf -> flag |= RB_IGNORE_P ; if ( cmd == HTML_P ) { set_alignment ( obuf , tag ) ; obuf -> flag |= RB_P ; } return 1 ; case HTML_BR : flushline ( h_env , obuf , envs [ h_env -> envc ] . indent , 1 , h_env -> limit ) ; h_env -> blank_lines = 0 ; return 1 ; case HTML_H : if ( ! ( obuf -> flag & ( RB_PREMODE | RB_IGNORE_P ) ) ) { flushline ( h_env , obuf , envs [ h_env -> envc ] . indent , 0 , h_env -> limit ) ; do_blankline ( h_env , obuf , envs [ h_env -> envc ] . indent , 0 , h_env -> limit ) ; } HTMLlineproc1 ( \"<b>\" , h_env ) ; set_alignment ( obuf , tag ) ; return 1 ; case HTML_N_H : HTMLlineproc1 ( \"</b>\" , h_env ) ; if ( ! ( obuf -> flag & RB_PREMODE ) ) { flushline ( h_env , obuf , envs [ h_env -> envc ] . indent , 0 , h_env -> limit ) ; } do_blankline ( h_env , obuf , envs [ h_env -> envc ] . indent , 0 , h_env -> limit ) ; RB_RESTORE_FLAG ( obuf ) ; close_anchor ( h_env , obuf ) ; obuf -> flag |= RB_IGNORE_P ; return 1 ; case HTML_UL : case HTML_OL : case HTML_BLQ : CLOSE_A ; if ( ! ( obuf -> flag & RB_IGNORE_P ) ) { flushline ( h_env , obuf , envs [ h_env -> envc ] . indent , 0 , h_env -> limit ) ; if ( ! ( obuf -> flag & RB_PREMODE ) && ( h_env -> envc == 0 || cmd == HTML_BLQ ) ) do_blankline ( h_env , obuf , envs [ h_env -> envc ] . indent , 0 , h_env -> limit ) ; } PUSH_ENV ( cmd ) ; if ( cmd == HTML_UL || cmd == HTML_OL ) { if ( parsedtag_get_value ( tag , ATTR_START , & count ) ) { envs [ h_env -> envc ] . count = count - 1 ; } } if ( cmd == HTML_OL ) { envs [ h_env -> envc ] . type = '1' ; if ( parsedtag_get_value ( tag , ATTR_TYPE , & p ) ) { envs [ h_env -> envc ] . type = ( int ) * p ; } } if ( cmd == HTML_UL ) envs [ h_env -> envc ] . type = ul_type ( tag , 0 ) ; flushline ( h_env , obuf , envs [ h_env -> envc ] . indent , 0 , h_env -> limit ) ; return 1 ; case HTML_N_UL : case HTML_N_OL : case HTML_N_DL : case HTML_N_BLQ : CLOSE_DT ; CLOSE_A ; if ( h_env -> envc > 0 ) { flushline ( h_env , obuf , envs [ h_env -> envc - 1 ] . indent , 0 , h_env -> limit ) ; POP_ENV ; if ( ! ( obuf -> flag & RB_PREMODE ) && ( h_env -> envc == 0 || cmd == HTML_N_DL || cmd == HTML_N_BLQ ) ) { do_blankline ( h_env , obuf , envs [ h_env -> envc ] . indent , INDENT_INCR , h_env -> limit ) ; obuf -> flag |= RB_IGNORE_P ; } } close_anchor ( h_env , obuf ) ; return 1 ; case HTML_DL : CLOSE_A ; if ( ! ( obuf -> flag & RB_IGNORE_P ) ) { flushline ( h_env , obuf , envs [ h_env -> envc ] . indent , 0 , h_env -> limit ) ; if ( ! ( obuf -> flag & RB_PREMODE ) ) do_blankline ( h_env , obuf , envs [ h_env -> envc ] . indent , 0 , h_env -> limit ) ; } PUSH_ENV ( cmd ) ; if ( parsedtag_exists ( tag , ATTR_COMPACT ) ) envs [ h_env -> envc ] . env = HTML_DL_COMPACT ; obuf -> flag |= RB_IGNORE_P ; return 1 ; case HTML_LI : CLOSE_A ; CLOSE_DT ; if ( h_env -> envc > 0 ) { Str num ; flushline ( h_env , obuf , envs [ h_env -> envc - 1 ] . indent , 0 , h_env -> limit ) ; envs [ h_env -> envc ] . count ++ ; if ( parsedtag_get_value ( tag , ATTR_VALUE , & p ) ) { count = atoi ( p ) ; if ( count > 0 ) envs [ h_env -> envc ] . count = count ; else envs [ h_env -> envc ] . count = 0 ; } switch ( envs [ h_env -> envc ] . env ) { case HTML_UL : envs [ h_env -> envc ] . type = ul_type ( tag , envs [ h_env -> envc ] . type ) ; for ( i = 0 ; i < INDENT_INCR - 3 ; i ++ ) push_charp ( obuf , 1 , NBSP , PC_ASCII ) ; tmp = Strnew ( ) ; switch ( envs [ h_env -> envc ] . type ) { case 'd' : push_symbol ( tmp , UL_SYMBOL_DISC , symbol_width , 1 ) ; break ; case 'c' : push_symbol ( tmp , UL_SYMBOL_CIRCLE , symbol_width , 1 ) ; break ; case 's' : push_symbol ( tmp , UL_SYMBOL_SQUARE , symbol_width , 1 ) ; break ; default : push_symbol ( tmp , UL_SYMBOL ( ( h_env -> envc_real - 1 ) % MAX_UL_LEVEL ) , symbol_width , 1 ) ; break ; } if ( symbol_width == 1 ) push_charp ( obuf , 1 , NBSP , PC_ASCII ) ; push_str ( obuf , symbol_width , tmp , PC_ASCII ) ; push_charp ( obuf , 1 , NBSP , PC_ASCII ) ; set_space_to_prevchar ( obuf -> prevchar ) ; break ; case HTML_OL : if ( parsedtag_get_value ( tag , ATTR_TYPE , & p ) ) envs [ h_env -> envc ] . type = ( int ) * p ; switch ( ( envs [ h_env -> envc ] . count > 0 ) ? envs [ h_env -> envc ] . type : '1' ) { case 'i' : num = romanNumeral ( envs [ h_env -> envc ] . count ) ; break ; case 'I' : num = romanNumeral ( envs [ h_env -> envc ] . count ) ; Strupper ( num ) ; break ; case 'a' : num = romanAlphabet ( envs [ h_env -> envc ] . count ) ; break ; case 'A' : num = romanAlphabet ( envs [ h_env -> envc ] . count ) ; Strupper ( num ) ; break ; default : num = Sprintf ( \"%d\" , envs [ h_env -> envc ] . count ) ; break ; } if ( INDENT_INCR >= 4 ) Strcat_charp ( num , \".<S2SV_blank>\" ) ; else Strcat_char ( num , '.' ) ; push_spaces ( obuf , 1 , INDENT_INCR - num -> length ) ; push_str ( obuf , num -> length , num , PC_ASCII ) ; if ( INDENT_INCR >= 4 ) set_space_to_prevchar ( obuf -> prevchar ) ; break ; default : push_spaces ( obuf , 1 , INDENT_INCR ) ; break ; } } else { flushline ( h_env , obuf , 0 , 0 , h_env -> limit ) ; } obuf -> flag |= RB_IGNORE_P ; return 1 ; case HTML_DT : CLOSE_A ; if ( h_env -> envc == 0 || ( h_env -> envc_real < h_env -> nenv && envs [ h_env -> envc ] . env != HTML_DL && envs [ h_env -> envc ] . env != HTML_DL_COMPACT ) ) { PUSH_ENV ( HTML_DL ) ; } if ( h_env -> envc > 0 ) { flushline ( h_env , obuf , envs [ h_env -> envc - 1 ] . indent , 0 , h_env -> limit ) ; } if ( ! ( obuf -> flag & RB_IN_DT ) ) { HTMLlineproc1 ( \"<b>\" , h_env ) ; obuf -> flag |= RB_IN_DT ; } obuf -> flag |= RB_IGNORE_P ; return 1 ; case HTML_DD : CLOSE_A ; CLOSE_DT ; <S2SV_StartBug> if ( envs [ h_env -> envc ] . env == HTML_DL_COMPACT ) { <S2SV_EndBug> if ( obuf -> pos > envs [ h_env -> envc ] . indent ) flushline ( h_env , obuf , envs [ h_env -> envc ] . indent , 0 , h_env -> limit ) ; else push_spaces ( obuf , 1 , envs [ h_env -> envc ] . indent - obuf -> pos ) ; } else flushline ( h_env , obuf , envs [ h_env -> envc ] . indent , 0 , h_env -> limit ) ; return 1 ; case HTML_TITLE : close_anchor ( h_env , obuf ) ; process_title ( tag ) ; obuf -> flag |= RB_TITLE ; obuf -> end_tag = HTML_N_TITLE ; return 1 ; case HTML_N_TITLE : if ( ! ( obuf -> flag & RB_TITLE ) ) return 1 ; obuf -> flag &= ~ RB_TITLE ; obuf -> end_tag = 0 ; tmp = process_n_title ( tag ) ; if ( tmp ) HTMLlineproc1 ( tmp -> ptr , h_env ) ; return 1 ; case HTML_TITLE_ALT : if ( parsedtag_get_value ( tag , ATTR_TITLE , & p ) ) h_env -> title = html_unquote ( p ) ; return 0 ; case HTML_FRAMESET : PUSH_ENV ( cmd ) ; push_charp ( obuf , 9 , \"--FRAME--\" , PC_ASCII ) ; flushline ( h_env , obuf , envs [ h_env -> envc ] . indent , 0 , h_env -> limit ) ; return 0 ; case HTML_N_FRAMESET : if ( h_env -> envc > 0 ) { POP_ENV ; flushline ( h_env , obuf , envs [ h_env -> envc ] . indent , 0 , h_env -> limit ) ; } return 0 ; case HTML_NOFRAMES : CLOSE_A ; flushline ( h_env , obuf , envs [ h_env -> envc ] . indent , 0 , h_env -> limit ) ; obuf -> flag |= ( RB_NOFRAMES | RB_IGNORE_P ) ; return 1 ; case HTML_N_NOFRAMES : CLOSE_A ; flushline ( h_env , obuf , envs [ h_env -> envc ] . indent , 0 , h_env -> limit ) ; obuf -> flag &= ~ RB_NOFRAMES ; return 1 ; case HTML_FRAME : q = r = NULL ; parsedtag_get_value ( tag , ATTR_SRC , & q ) ; parsedtag_get_value ( tag , ATTR_NAME , & r ) ; if ( q ) { q = html_quote ( q ) ; push_tag ( obuf , Sprintf ( \"<a<S2SV_blank>hseq=\\\\\"%d\\\\\"<S2SV_blank>href=\\\\\"%s\\\\\">\" , cur_hseq ++ , q ) -> ptr , HTML_A ) ; if ( r ) q = html_quote ( r ) ; push_charp ( obuf , get_strwidth ( q ) , q , PC_ASCII ) ; push_tag ( obuf , \"</a>\" , HTML_N_A ) ; } flushline ( h_env , obuf , envs [ h_env -> envc ] . indent , 0 , h_env -> limit ) ; return 0 ; case HTML_HR : close_anchor ( h_env , obuf ) ; tmp = process_hr ( tag , h_env -> limit , envs [ h_env -> envc ] . indent ) ; HTMLlineproc1 ( tmp -> ptr , h_env ) ; set_space_to_prevchar ( obuf -> prevchar ) ; return 1 ; case HTML_PRE : x = parsedtag_exists ( tag , ATTR_FOR_TABLE ) ; CLOSE_A ; if ( ! ( obuf -> flag & RB_IGNORE_P ) ) { flushline ( h_env , obuf , envs [ h_env -> envc ] . indent , 0 , h_env -> limit ) ; if ( ! x ) do_blankline ( h_env , obuf , envs [ h_env -> envc ] . indent , 0 , h_env -> limit ) ; } else fillline ( obuf , envs [ h_env -> envc ] . indent ) ; obuf -> flag |= ( RB_PRE | RB_IGNORE_P ) ; return 1 ; case HTML_N_PRE : flushline ( h_env , obuf , envs [ h_env -> envc ] . indent , 0 , h_env -> limit ) ; if ( ! ( obuf -> flag & RB_IGNORE_P ) ) { do_blankline ( h_env , obuf , envs [ h_env -> envc ] . indent , 0 , h_env -> limit ) ; obuf -> flag |= RB_IGNORE_P ; h_env -> blank_lines ++ ; } obuf -> flag &= ~ RB_PRE ; close_anchor ( h_env , obuf ) ; return 1 ; case HTML_PRE_INT : i = obuf -> line -> length ; append_tags ( obuf ) ; if ( ! ( obuf -> flag & RB_SPECIAL ) ) { set_breakpoint ( obuf , obuf -> line -> length - i ) ; } obuf -> flag |= RB_PRE_INT ; return 0 ; case HTML_N_PRE_INT : push_tag ( obuf , \"</pre_int>\" , HTML_N_PRE_INT ) ; obuf -> flag &= ~ RB_PRE_INT ; if ( ! ( obuf -> flag & RB_SPECIAL ) && obuf -> pos > obuf -> bp . pos ) { set_prevchar ( obuf -> prevchar , \"\" , 0 ) ; obuf -> prev_ctype = PC_CTRL ; } return 1 ; case HTML_NOBR : obuf -> flag |= RB_NOBR ; obuf -> nobr_level ++ ; return 0 ; case HTML_N_NOBR : if ( obuf -> nobr_level > 0 ) obuf -> nobr_level -- ; if ( obuf -> nobr_level == 0 ) obuf -> flag &= ~ RB_NOBR ; return 0 ; case HTML_PRE_PLAIN : CLOSE_A ; if ( ! ( obuf -> flag & RB_IGNORE_P ) ) { flushline ( h_env , obuf , envs [ h_env -> envc ] . indent , 0 , h_env -> limit ) ; do_blankline ( h_env , obuf , envs [ h_env -> envc ] . indent , 0 , h_env -> limit ) ; } obuf -> flag |= ( RB_PRE | RB_IGNORE_P ) ; return 1 ; case HTML_N_PRE_PLAIN : CLOSE_A ; if ( ! ( obuf -> flag & RB_IGNORE_P ) ) { flushline ( h_env , obuf , envs [ h_env -> envc ] . indent , 0 , h_env -> limit ) ; do_blankline ( h_env , obuf , envs [ h_env -> envc ] . indent , 0 , h_env -> limit ) ; obuf -> flag |= RB_IGNORE_P ; } obuf -> flag &= ~ RB_PRE ; return 1 ; case HTML_LISTING : case HTML_XMP : case HTML_PLAINTEXT : CLOSE_A ; if ( ! ( obuf -> flag & RB_IGNORE_P ) ) { flushline ( h_env , obuf , envs [ h_env -> envc ] . indent , 0 , h_env -> limit ) ; do_blankline ( h_env , obuf , envs [ h_env -> envc ] . indent , 0 , h_env -> limit ) ; } obuf -> flag |= ( RB_PLAIN | RB_IGNORE_P ) ; switch ( cmd ) { case HTML_LISTING : obuf -> end_tag = HTML_N_LISTING ; break ; case HTML_XMP : obuf -> end_tag = HTML_N_XMP ; break ; case HTML_PLAINTEXT : obuf -> end_tag = MAX_HTMLTAG ; break ; } return 1 ; case HTML_N_LISTING : case HTML_N_XMP : CLOSE_A ; if ( ! ( obuf -> flag & RB_IGNORE_P ) ) { flushline ( h_env , obuf , envs [ h_env -> envc ] . indent , 0 , h_env -> limit ) ; do_blankline ( h_env , obuf , envs [ h_env -> envc ] . indent , 0 , h_env -> limit ) ; obuf -> flag |= RB_IGNORE_P ; } obuf -> flag &= ~ RB_PLAIN ; obuf -> end_tag = 0 ; return 1 ; case HTML_SCRIPT : obuf -> flag |= RB_SCRIPT ; obuf -> end_tag = HTML_N_SCRIPT ; return 1 ; case HTML_STYLE : obuf -> flag |= RB_STYLE ; obuf -> end_tag = HTML_N_STYLE ; return 1 ; case HTML_N_SCRIPT : obuf -> flag &= ~ RB_SCRIPT ; obuf -> end_tag = 0 ; return 1 ; case HTML_N_STYLE : obuf -> flag &= ~ RB_STYLE ; obuf -> end_tag = 0 ; return 1 ; case HTML_A : if ( obuf -> anchor . url ) close_anchor ( h_env , obuf ) ; hseq = 0 ; if ( parsedtag_get_value ( tag , ATTR_HREF , & p ) ) obuf -> anchor . url = Strnew_charp ( p ) -> ptr ; if ( parsedtag_get_value ( tag , ATTR_TARGET , & p ) ) obuf -> anchor . target = Strnew_charp ( p ) -> ptr ; if ( parsedtag_get_value ( tag , ATTR_REFERER , & p ) ) obuf -> anchor . referer = Strnew_charp ( p ) -> ptr ; if ( parsedtag_get_value ( tag , ATTR_TITLE , & p ) ) obuf -> anchor . title = Strnew_charp ( p ) -> ptr ; if ( parsedtag_get_value ( tag , ATTR_ACCESSKEY , & p ) ) obuf -> anchor . accesskey = ( unsigned char ) * p ; if ( parsedtag_get_value ( tag , ATTR_HSEQ , & hseq ) ) obuf -> anchor . hseq = hseq ; if ( hseq == 0 && obuf -> anchor . url ) { obuf -> anchor . hseq = cur_hseq ; tmp = process_anchor ( tag , h_env -> tagbuf -> ptr ) ; push_tag ( obuf , tmp -> ptr , HTML_A ) ; if ( displayLinkNumber ) HTMLlineproc1 ( getLinkNumberStr ( - 1 ) -> ptr , h_env ) ; return 1 ; } return 0 ; case HTML_N_A : close_anchor ( h_env , obuf ) ; return 1 ; case HTML_IMG : tmp = process_img ( tag , h_env -> limit ) ; HTMLlineproc1 ( tmp -> ptr , h_env ) ; return 1 ; case HTML_IMG_ALT : if ( parsedtag_get_value ( tag , ATTR_SRC , & p ) ) obuf -> img_alt = Strnew_charp ( p ) ; # ifdef USE_IMAGE i = 0 ; if ( parsedtag_get_value ( tag , ATTR_TOP_MARGIN , & i ) ) { if ( i > obuf -> top_margin ) obuf -> top_margin = i ; } i = 0 ; if ( parsedtag_get_value ( tag , ATTR_BOTTOM_MARGIN , & i ) ) { if ( i > obuf -> bottom_margin ) obuf -> bottom_margin = i ; } # endif return 0 ; case HTML_N_IMG_ALT : if ( obuf -> img_alt ) { if ( ! close_effect0 ( obuf , HTML_IMG_ALT ) ) push_tag ( obuf , \"</img_alt>\" , HTML_N_IMG_ALT ) ; obuf -> img_alt = NULL ; } return 1 ; case HTML_INPUT_ALT : i = 0 ; if ( parsedtag_get_value ( tag , ATTR_TOP_MARGIN , & i ) ) { if ( i > obuf -> top_margin ) obuf -> top_margin = i ; } i = 0 ; if ( parsedtag_get_value ( tag , ATTR_BOTTOM_MARGIN , & i ) ) { if ( i > obuf -> bottom_margin ) obuf -> bottom_margin = i ; } if ( parsedtag_get_value ( tag , ATTR_HSEQ , & hseq ) ) { obuf -> input_alt . hseq = hseq ; } if ( parsedtag_get_value ( tag , ATTR_FID , & i ) ) { obuf -> input_alt . fid = i ; } if ( parsedtag_get_value ( tag , ATTR_TYPE , & p ) ) { obuf -> input_alt . type = Strnew_charp ( p ) ; } if ( parsedtag_get_value ( tag , ATTR_VALUE , & p ) ) { obuf -> input_alt . value = Strnew_charp ( p ) ; } if ( parsedtag_get_value ( tag , ATTR_NAME , & p ) ) { obuf -> input_alt . name = Strnew_charp ( p ) ; } obuf -> input_alt . in = 1 ; return 0 ; case HTML_N_INPUT_ALT : if ( obuf -> input_alt . in ) { if ( ! close_effect0 ( obuf , HTML_INPUT_ALT ) ) push_tag ( obuf , \"</input_alt>\" , HTML_N_INPUT_ALT ) ; obuf -> input_alt . hseq = 0 ; obuf -> input_alt . fid = - 1 ; obuf -> input_alt . in = 0 ; obuf -> input_alt . type = NULL ; obuf -> input_alt . name = NULL ; obuf -> input_alt . value = NULL ; } return 1 ; case HTML_TABLE : close_anchor ( h_env , obuf ) ; obuf -> table_level ++ ; if ( obuf -> table_level >= MAX_TABLE ) break ; w = BORDER_NONE ; x = 2 ; y = 1 ; z = 0 ; width = 0 ; if ( parsedtag_exists ( tag , ATTR_BORDER ) ) { if ( parsedtag_get_value ( tag , ATTR_BORDER , & w ) ) { if ( w > 2 ) w = BORDER_THICK ; else if ( w < 0 ) { w = BORDER_THIN ; } } else w = BORDER_THIN ; } if ( DisplayBorders && w == BORDER_NONE ) w = BORDER_THIN ; if ( parsedtag_get_value ( tag , ATTR_WIDTH , & i ) ) { if ( obuf -> table_level == 0 ) width = REAL_WIDTH ( i , h_env -> limit - envs [ h_env -> envc ] . indent ) ; else width = RELATIVE_WIDTH ( i ) ; } if ( parsedtag_exists ( tag , ATTR_HBORDER ) ) w = BORDER_NOWIN ; # define MAX_CELLSPACING 1000 # define MAX_CELLPADDING 1000 # define MAX_VSPACE 1000 parsedtag_get_value ( tag , ATTR_CELLSPACING , & x ) ; parsedtag_get_value ( tag , ATTR_CELLPADDING , & y ) ; parsedtag_get_value ( tag , ATTR_VSPACE , & z ) ; if ( x > MAX_CELLSPACING ) x = MAX_CELLSPACING ; if ( y > MAX_CELLPADDING ) y = MAX_CELLPADDING ; if ( z > MAX_VSPACE ) z = MAX_VSPACE ; # ifdef ID_EXT parsedtag_get_value ( tag , ATTR_ID , & id ) ; # endif tables [ obuf -> table_level ] = begin_table ( w , x , y , z ) ; # ifdef ID_EXT if ( id != NULL ) tables [ obuf -> table_level ] -> id = Strnew_charp ( id ) ; # endif table_mode [ obuf -> table_level ] . pre_mode = 0 ; table_mode [ obuf -> table_level ] . indent_level = 0 ; table_mode [ obuf -> table_level ] . nobr_level = 0 ; table_mode [ obuf -> table_level ] . caption = 0 ; table_mode [ obuf -> table_level ] . end_tag = 0 ; # ifndef TABLE_EXPAND tables [ obuf -> table_level ] -> total_width = width ; # else tables [ obuf -> table_level ] -> real_width = width ; tables [ obuf -> table_level ] -> total_width = 0 ; # endif return 1 ; case HTML_N_TABLE : return 1 ; case HTML_CENTER : CLOSE_A ; if ( ! ( obuf -> flag & ( RB_PREMODE | RB_IGNORE_P ) ) ) flushline ( h_env , obuf , envs [ h_env -> envc ] . indent , 0 , h_env -> limit ) ; RB_SAVE_FLAG ( obuf ) ; RB_SET_ALIGN ( obuf , RB_CENTER ) ; return 1 ; case HTML_N_CENTER : CLOSE_A ; if ( ! ( obuf -> flag & RB_PREMODE ) ) flushline ( h_env , obuf , envs [ h_env -> envc ] . indent , 0 , h_env -> limit ) ; RB_RESTORE_FLAG ( obuf ) ; return 1 ; case HTML_DIV : CLOSE_A ; if ( ! ( obuf -> flag & RB_IGNORE_P ) ) flushline ( h_env , obuf , envs [ h_env -> envc ] . indent , 0 , h_env -> limit ) ; set_alignment ( obuf , tag ) ; return 1 ; case HTML_N_DIV : CLOSE_A ; flushline ( h_env , obuf , envs [ h_env -> envc ] . indent , 0 , h_env -> limit ) ; RB_RESTORE_FLAG ( obuf ) ; return 1 ; case HTML_DIV_INT : CLOSE_P ; if ( ! ( obuf -> flag & RB_IGNORE_P ) ) flushline ( h_env , obuf , envs [ h_env -> envc ] . indent , 0 , h_env -> limit ) ; set_alignment ( obuf , tag ) ; return 1 ; case HTML_N_DIV_INT : CLOSE_P ; flushline ( h_env , obuf , envs [ h_env -> envc ] . indent , 0 , h_env -> limit ) ; RB_RESTORE_FLAG ( obuf ) ; return 1 ; case HTML_FORM : CLOSE_A ; if ( ! ( obuf -> flag & RB_IGNORE_P ) ) flushline ( h_env , obuf , envs [ h_env -> envc ] . indent , 0 , h_env -> limit ) ; tmp = process_form ( tag ) ; if ( tmp ) HTMLlineproc1 ( tmp -> ptr , h_env ) ; return 1 ; case HTML_N_FORM : CLOSE_A ; flushline ( h_env , obuf , envs [ h_env -> envc ] . indent , 0 , h_env -> limit ) ; obuf -> flag |= RB_IGNORE_P ; process_n_form ( ) ; return 1 ; case HTML_INPUT : close_anchor ( h_env , obuf ) ; tmp = process_input ( tag ) ; if ( tmp ) HTMLlineproc1 ( tmp -> ptr , h_env ) ; return 1 ; case HTML_BUTTON : tmp = process_button ( tag ) ; if ( tmp ) HTMLlineproc1 ( tmp -> ptr , h_env ) ; return 1 ; case HTML_N_BUTTON : tmp = process_n_button ( ) ; if ( tmp ) HTMLlineproc1 ( tmp -> ptr , h_env ) ; return 1 ; case HTML_SELECT : close_anchor ( h_env , obuf ) ; tmp = process_select ( tag ) ; if ( tmp ) HTMLlineproc1 ( tmp -> ptr , h_env ) ; obuf -> flag |= RB_INSELECT ; obuf -> end_tag = HTML_N_SELECT ; return 1 ; case HTML_N_SELECT : obuf -> flag &= ~ RB_INSELECT ; obuf -> end_tag = 0 ; tmp = process_n_select ( ) ; if ( tmp ) HTMLlineproc1 ( tmp -> ptr , h_env ) ; return 1 ; case HTML_OPTION : return 1 ; case HTML_TEXTAREA : close_anchor ( h_env , obuf ) ; tmp = process_textarea ( tag , h_env -> limit ) ; if ( tmp ) HTMLlineproc1 ( tmp -> ptr , h_env ) ; obuf -> flag |= RB_INTXTA ; obuf -> end_tag = HTML_N_TEXTAREA ; return 1 ; case HTML_N_TEXTAREA : obuf -> flag &= ~ RB_INTXTA ; obuf -> end_tag = 0 ; tmp = process_n_textarea ( ) ; if ( tmp ) HTMLlineproc1 ( tmp -> ptr , h_env ) ; return 1 ; case HTML_ISINDEX : p = \"\" ; q = \"!CURRENT_URL!\" ; parsedtag_get_value ( tag , ATTR_PROMPT , & p ) ; parsedtag_get_value ( tag , ATTR_ACTION , & q ) ; tmp = Strnew_m_charp ( \"<form<S2SV_blank>method=get<S2SV_blank>action=\\\\\"\" , html_quote ( q ) , \"\\\\\">\" , html_quote ( p ) , \"<input<S2SV_blank>type=text<S2SV_blank>name=\\\\\"\\\\\"<S2SV_blank>accept></form>\" , NULL ) ; HTMLlineproc1 ( tmp -> ptr , h_env ) ; return 1 ; case HTML_META : p = q = r = NULL ; parsedtag_get_value ( tag , ATTR_HTTP_EQUIV , & p ) ; parsedtag_get_value ( tag , ATTR_CONTENT , & q ) ; # ifdef USE_M17N parsedtag_get_value ( tag , ATTR_CHARSET , & r ) ; if ( r ) { SKIP_BLANKS ( r ) ; meta_charset = wc_guess_charset ( r , 0 ) ; } else if ( p && q && ! strcasecmp ( p , \"Content-Type\" ) && ( q = strcasestr ( q , \"charset\" ) ) != NULL ) { q += 7 ; SKIP_BLANKS ( q ) ; if ( * q == '=' ) { q ++ ; SKIP_BLANKS ( q ) ; meta_charset = wc_guess_charset ( q , 0 ) ; } } else # endif if ( p && q && ! strcasecmp ( p , \"refresh\" ) ) { int refresh_interval ; tmp = NULL ; refresh_interval = getMetaRefreshParam ( q , & tmp ) ; if ( tmp ) { q = html_quote ( tmp -> ptr ) ; tmp = Sprintf ( \"Refresh<S2SV_blank>(%d<S2SV_blank>sec)<S2SV_blank><a<S2SV_blank>href=\\\\\"%s\\\\\">%s</a>\" , refresh_interval , q , q ) ; } else if ( refresh_interval > 0 ) tmp = Sprintf ( \"Refresh<S2SV_blank>(%d<S2SV_blank>sec)\" , refresh_interval ) ; if ( tmp ) { HTMLlineproc1 ( tmp -> ptr , h_env ) ; do_blankline ( h_env , obuf , envs [ h_env -> envc ] . indent , 0 , h_env -> limit ) ; if ( ! is_redisplay && ! ( ( obuf -> flag & RB_NOFRAMES ) && RenderFrame ) ) { tag -> need_reconstruct = TRUE ; return 0 ; } } } return 1 ; case HTML_BASE : # if defined ( USE_M17N ) || defined ( USE_IMAGE ) p = NULL ; if ( parsedtag_get_value ( tag , ATTR_HREF , & p ) ) { cur_baseURL = New ( ParsedURL ) ; parseURL ( p , cur_baseURL , NULL ) ; } # endif case HTML_MAP : case HTML_N_MAP : case HTML_AREA : return 0 ; case HTML_DEL : switch ( displayInsDel ) { case DISPLAY_INS_DEL_SIMPLE : obuf -> flag |= RB_DEL ; break ; case DISPLAY_INS_DEL_NORMAL : HTMLlineproc1 ( \"<U>[DEL:</U>\" , h_env ) ; break ; case DISPLAY_INS_DEL_FONTIFY : obuf -> in_strike ++ ; if ( obuf -> in_strike == 1 ) { push_tag ( obuf , \"<s>\" , HTML_S ) ; } break ; } return 1 ; case HTML_N_DEL : switch ( displayInsDel ) { case DISPLAY_INS_DEL_SIMPLE : obuf -> flag &= ~ RB_DEL ; break ; case DISPLAY_INS_DEL_NORMAL : HTMLlineproc1 ( \"<U>:DEL]</U>\" , h_env ) ; case DISPLAY_INS_DEL_FONTIFY : if ( obuf -> in_strike == 0 ) return 1 ; if ( obuf -> in_strike == 1 && close_effect0 ( obuf , HTML_S ) ) obuf -> in_strike = 0 ; if ( obuf -> in_strike > 0 ) { obuf -> in_strike -- ; if ( obuf -> in_strike == 0 ) { push_tag ( obuf , \"</s>\" , HTML_N_S ) ; } } break ; } return 1 ; case HTML_S : switch ( displayInsDel ) { case DISPLAY_INS_DEL_SIMPLE : obuf -> flag |= RB_S ; break ; case DISPLAY_INS_DEL_NORMAL : HTMLlineproc1 ( \"<U>[S:</U>\" , h_env ) ; break ; case DISPLAY_INS_DEL_FONTIFY : obuf -> in_strike ++ ; if ( obuf -> in_strike == 1 ) { push_tag ( obuf , \"<s>\" , HTML_S ) ; } break ; } return 1 ; case HTML_N_S : switch ( displayInsDel ) { case DISPLAY_INS_DEL_SIMPLE : obuf -> flag &= ~ RB_S ; break ; case DISPLAY_INS_DEL_NORMAL : HTMLlineproc1 ( \"<U>:S]</U>\" , h_env ) ; break ; case DISPLAY_INS_DEL_FONTIFY : if ( obuf -> in_strike == 0 ) return 1 ; if ( obuf -> in_strike == 1 && close_effect0 ( obuf , HTML_S ) ) obuf -> in_strike = 0 ; if ( obuf -> in_strike > 0 ) { obuf -> in_strike -- ; if ( obuf -> in_strike == 0 ) { push_tag ( obuf , \"</s>\" , HTML_N_S ) ; } } } return 1 ; case HTML_INS : switch ( displayInsDel ) { case DISPLAY_INS_DEL_SIMPLE : break ; case DISPLAY_INS_DEL_NORMAL : HTMLlineproc1 ( \"<U>[INS:</U>\" , h_env ) ; break ; case DISPLAY_INS_DEL_FONTIFY : obuf -> in_ins ++ ; if ( obuf -> in_ins == 1 ) { push_tag ( obuf , \"<ins>\" , HTML_INS ) ; } break ; } return 1 ; case HTML_N_INS : switch ( displayInsDel ) { case DISPLAY_INS_DEL_SIMPLE : break ; case DISPLAY_INS_DEL_NORMAL : HTMLlineproc1 ( \"<U>:INS]</U>\" , h_env ) ; break ; case DISPLAY_INS_DEL_FONTIFY : if ( obuf -> in_ins == 0 ) return 1 ; if ( obuf -> in_ins == 1 && close_effect0 ( obuf , HTML_INS ) ) obuf -> in_ins = 0 ; if ( obuf -> in_ins > 0 ) { obuf -> in_ins -- ; if ( obuf -> in_ins == 0 ) { push_tag ( obuf , \"</ins>\" , HTML_N_INS ) ; } } break ; } return 1 ; case HTML_SUP : if ( ! ( obuf -> flag & ( RB_DEL | RB_S ) ) ) HTMLlineproc1 ( \"^\" , h_env ) ; return 1 ; case HTML_N_SUP : return 1 ; case HTML_SUB : if ( ! ( obuf -> flag & ( RB_DEL | RB_S ) ) ) HTMLlineproc1 ( \"[\" , h_env ) ; return 1 ; case HTML_N_SUB : if ( ! ( obuf -> flag & ( RB_DEL | RB_S ) ) ) HTMLlineproc1 ( \"]\" , h_env ) ; return 1 ; case HTML_FONT : case HTML_N_FONT : case HTML_NOP : return 1 ; case HTML_BGSOUND : if ( view_unseenobject ) { if ( parsedtag_get_value ( tag , ATTR_SRC , & p ) ) { Str s ; q = html_quote ( p ) ; s = Sprintf ( \"<A<S2SV_blank>HREF=\\\\\"%s\\\\\">bgsound(%s)</A>\" , q , q ) ; HTMLlineproc1 ( s -> ptr , h_env ) ; } } return 1 ; case HTML_EMBED : if ( view_unseenobject ) { if ( parsedtag_get_value ( tag , ATTR_SRC , & p ) ) { Str s ; q = html_quote ( p ) ; s = Sprintf ( \"<A<S2SV_blank>HREF=\\\\\"%s\\\\\">embed(%s)</A>\" , q , q ) ; HTMLlineproc1 ( s -> ptr , h_env ) ; } } return 1 ; case HTML_APPLET : if ( view_unseenobject ) { if ( parsedtag_get_value ( tag , ATTR_ARCHIVE , & p ) ) { Str s ; q = html_quote ( p ) ; s = Sprintf ( \"<A<S2SV_blank>HREF=\\\\\"%s\\\\\">applet<S2SV_blank>archive(%s)</A>\" , q , q ) ; HTMLlineproc1 ( s -> ptr , h_env ) ; } } return 1 ; case HTML_BODY : if ( view_unseenobject ) { if ( parsedtag_get_value ( tag , ATTR_BACKGROUND , & p ) ) { Str s ; q = html_quote ( p ) ; s = Sprintf ( \"<IMG<S2SV_blank>SRC=\\\\\"%s\\\\\"<S2SV_blank>ALT=\\\\\"bg<S2SV_blank>image(%s)\\\\\"><BR>\" , q , q ) ; HTMLlineproc1 ( s -> ptr , h_env ) ; } } case HTML_N_HEAD : if ( obuf -> flag & RB_TITLE ) HTMLlineproc1 ( \"</title>\" , h_env ) ; case HTML_HEAD : case HTML_N_BODY : return 1 ; default : return 0 ; } return 0 ; }\n","target":"<S2SV_ModStart> ; if ( h_env -> envc == 0 || ( h_env -> envc_real < h_env -> nenv && envs [ h_env -> envc ] . env != HTML_DL && envs [ h_env -> envc ] . env != HTML_DL_COMPACT ) ) { PUSH_ENV ( HTML_DL ) ; } if (\n","project_and_commit_id":"tats@w3m/33509cc81ec5f2ba44eb6fd98bd5c1b5873e46bd","cve_id":"CVE-2016-9436","original_address":"https://github.com/tats/w3m/commit/33509cc81ec5f2ba44eb6fd98bd5c1b5873e46bd","time":"2017-01-20T15:59Z"},
	{"Unnamed: 0":5499,"cwe_id":"CWE-119","source":"CWE-119 static void finish_object ( struct object * obj , <S2SV_StartBug> struct strbuf * path , const char * name , <S2SV_EndBug> void * cb_data ) { struct rev_list_info * info = cb_data ; if ( obj -> type == OBJ_BLOB && ! has_object_file ( & obj -> oid ) ) die ( \"missing<S2SV_blank>blob<S2SV_blank>object<S2SV_blank>\\'%s\\'\" , oid_to_hex ( & obj -> oid ) ) ; if ( info -> revs -> verify_objects && ! obj -> parsed && obj -> type != OBJ_COMMIT ) parse_object ( obj -> oid . hash ) ; }\n","target":"<S2SV_ModStart> * obj , <S2SV_ModEnd> const char *\n","project_and_commit_id":"git@git/de1e67d0703894cb6ea782e36abb63976ab07e60","cve_id":"CVE-2016-2315","original_address":"https://github.com/git/git/commit/de1e67d0703894cb6ea782e36abb63976ab07e60","time":"2016-04-08T14:59Z"},
	{"Unnamed: 0":2850,"cwe_id":"CWE-119","source":"CWE-119 void vp8_change_config ( VP8_COMP * cpi , VP8_CONFIG * oxcf ) { VP8_COMMON * cm = & cpi -> common ; int last_w , last_h , prev_number_of_layers ; if ( ! cpi ) return ; if ( ! oxcf ) return ; # if CONFIG_MULTITHREAD if ( cpi -> b_lpf_running ) { sem_wait ( & cpi -> h_event_end_lpf ) ; cpi -> b_lpf_running = 0 ; } # endif if ( cm -> version != oxcf -> Version ) { cm -> version = oxcf -> Version ; vp8_setup_version ( cm ) ; } last_w = cpi -> oxcf . Width ; last_h = cpi -> oxcf . Height ; prev_number_of_layers = cpi -> oxcf . number_of_layers ; cpi -> oxcf = * oxcf ; switch ( cpi -> oxcf . Mode ) { case MODE_REALTIME : cpi -> pass = 0 ; cpi -> compressor_speed = 2 ; if ( cpi -> oxcf . cpu_used < - 16 ) { cpi -> oxcf . cpu_used = - 16 ; } if ( cpi -> oxcf . cpu_used > 16 ) cpi -> oxcf . cpu_used = 16 ; break ; case MODE_GOODQUALITY : cpi -> pass = 0 ; cpi -> compressor_speed = 1 ; if ( cpi -> oxcf . cpu_used < - 5 ) { cpi -> oxcf . cpu_used = - 5 ; } if ( cpi -> oxcf . cpu_used > 5 ) cpi -> oxcf . cpu_used = 5 ; break ; case MODE_BESTQUALITY : cpi -> pass = 0 ; cpi -> compressor_speed = 0 ; break ; case MODE_FIRSTPASS : cpi -> pass = 1 ; cpi -> compressor_speed = 1 ; break ; case MODE_SECONDPASS : cpi -> pass = 2 ; cpi -> compressor_speed = 1 ; if ( cpi -> oxcf . cpu_used < - 5 ) { cpi -> oxcf . cpu_used = - 5 ; } if ( cpi -> oxcf . cpu_used > 5 ) cpi -> oxcf . cpu_used = 5 ; break ; case MODE_SECONDPASS_BEST : cpi -> pass = 2 ; cpi -> compressor_speed = 0 ; break ; } if ( cpi -> pass == 0 ) cpi -> auto_worst_q = 1 ; cpi -> oxcf . worst_allowed_q = q_trans [ oxcf -> worst_allowed_q ] ; cpi -> oxcf . best_allowed_q = q_trans [ oxcf -> best_allowed_q ] ; cpi -> oxcf . cq_level = q_trans [ cpi -> oxcf . cq_level ] ; if ( oxcf -> fixed_q >= 0 ) { if ( oxcf -> worst_allowed_q < 0 ) cpi -> oxcf . fixed_q = q_trans [ 0 ] ; else cpi -> oxcf . fixed_q = q_trans [ oxcf -> worst_allowed_q ] ; if ( oxcf -> alt_q < 0 ) cpi -> oxcf . alt_q = q_trans [ 0 ] ; else cpi -> oxcf . alt_q = q_trans [ oxcf -> alt_q ] ; if ( oxcf -> key_q < 0 ) cpi -> oxcf . key_q = q_trans [ 0 ] ; else cpi -> oxcf . key_q = q_trans [ oxcf -> key_q ] ; if ( oxcf -> gold_q < 0 ) cpi -> oxcf . gold_q = q_trans [ 0 ] ; else cpi -> oxcf . gold_q = q_trans [ oxcf -> gold_q ] ; } cpi -> baseline_gf_interval = cpi -> oxcf . alt_freq ? cpi -> oxcf . alt_freq : DEFAULT_GF_INTERVAL ; <S2SV_StartBug> cpi -> ref_frame_flags = VP8_ALTR_FRAME | VP8_GOLD_FRAME | VP8_LAST_FRAME ; <S2SV_EndBug> cm -> refresh_golden_frame = 0 ; cm -> refresh_last_frame = 1 ; cm -> refresh_entropy_probs = 1 ; # if ( CONFIG_REALTIME_ONLY & CONFIG_ONTHEFLY_BITPACKING ) cpi -> oxcf . token_partitions = 3 ; # endif if ( cpi -> oxcf . token_partitions >= 0 && cpi -> oxcf . token_partitions <= 3 ) cm -> multi_token_partition = ( TOKEN_PARTITION ) cpi -> oxcf . token_partitions ; setup_features ( cpi ) ; { int i ; for ( i = 0 ; i < MAX_MB_SEGMENTS ; i ++ ) cpi -> segment_encode_breakout [ i ] = cpi -> oxcf . encode_breakout ; } if ( cpi -> oxcf . fixed_q > MAXQ ) cpi -> oxcf . fixed_q = MAXQ ; if ( cpi -> oxcf . end_usage == USAGE_LOCAL_FILE_PLAYBACK ) { cpi -> oxcf . starting_buffer_level = 60000 ; cpi -> oxcf . optimal_buffer_level = 60000 ; cpi -> oxcf . maximum_buffer_size = 240000 ; cpi -> oxcf . starting_buffer_level_in_ms = 60000 ; cpi -> oxcf . optimal_buffer_level_in_ms = 60000 ; cpi -> oxcf . maximum_buffer_size_in_ms = 240000 ; } cpi -> oxcf . target_bandwidth *= 1000 ; cpi -> oxcf . starting_buffer_level = rescale ( ( int ) cpi -> oxcf . starting_buffer_level , cpi -> oxcf . target_bandwidth , 1000 ) ; if ( cpi -> oxcf . optimal_buffer_level == 0 ) cpi -> oxcf . optimal_buffer_level = cpi -> oxcf . target_bandwidth / 8 ; else cpi -> oxcf . optimal_buffer_level = rescale ( ( int ) cpi -> oxcf . optimal_buffer_level , cpi -> oxcf . target_bandwidth , 1000 ) ; if ( cpi -> oxcf . maximum_buffer_size == 0 ) cpi -> oxcf . maximum_buffer_size = cpi -> oxcf . target_bandwidth / 8 ; else cpi -> oxcf . maximum_buffer_size = rescale ( ( int ) cpi -> oxcf . maximum_buffer_size , cpi -> oxcf . target_bandwidth , 1000 ) ; if ( cpi -> bits_off_target > cpi -> oxcf . maximum_buffer_size ) { cpi -> bits_off_target = cpi -> oxcf . maximum_buffer_size ; cpi -> buffer_level = cpi -> bits_off_target ; } vp8_new_framerate ( cpi , cpi -> framerate ) ; cpi -> worst_quality = cpi -> oxcf . worst_allowed_q ; cpi -> best_quality = cpi -> oxcf . best_allowed_q ; if ( cpi -> active_worst_quality > cpi -> oxcf . worst_allowed_q ) { cpi -> active_worst_quality = cpi -> oxcf . worst_allowed_q ; } else if ( cpi -> active_worst_quality < cpi -> oxcf . best_allowed_q ) { cpi -> active_worst_quality = cpi -> oxcf . best_allowed_q ; } if ( cpi -> active_best_quality < cpi -> oxcf . best_allowed_q ) { cpi -> active_best_quality = cpi -> oxcf . best_allowed_q ; } else if ( cpi -> active_best_quality > cpi -> oxcf . worst_allowed_q ) { cpi -> active_best_quality = cpi -> oxcf . worst_allowed_q ; } cpi -> buffered_mode = cpi -> oxcf . optimal_buffer_level > 0 ; cpi -> cq_target_quality = cpi -> oxcf . cq_level ; cpi -> drop_frames_allowed = cpi -> oxcf . allow_df && cpi -> buffered_mode ; cpi -> target_bandwidth = cpi -> oxcf . target_bandwidth ; if ( cpi -> oxcf . number_of_layers != prev_number_of_layers ) { <S2SV_StartBug> cpi -> temporal_pattern_counter = 0 ; <S2SV_EndBug> reset_temporal_layer_change ( cpi , oxcf , prev_number_of_layers ) ; } <S2SV_StartBug> cm -> Width = cpi -> oxcf . Width ; <S2SV_EndBug> <S2SV_StartBug> cm -> Height = cpi -> oxcf . Height ; <S2SV_EndBug> if ( cpi -> oxcf . Sharpness > 7 ) cpi -> oxcf . Sharpness = 7 ; cm -> sharpness_level = cpi -> oxcf . Sharpness ; if ( cm -> horiz_scale != NORMAL || cm -> vert_scale != NORMAL ) { int UNINITIALIZED_IS_SAFE ( hr ) , UNINITIALIZED_IS_SAFE ( hs ) ; int UNINITIALIZED_IS_SAFE ( vr ) , UNINITIALIZED_IS_SAFE ( vs ) ; Scale2Ratio ( cm -> horiz_scale , & hr , & hs ) ; Scale2Ratio ( cm -> vert_scale , & vr , & vs ) ; cm -> Width = ( hs - 1 + cpi -> oxcf . Width * hr ) / hs ; cm -> Height = ( vs - 1 + cpi -> oxcf . Height * vr ) / vs ; } if ( last_w != cpi -> oxcf . Width || last_h != cpi -> oxcf . Height ) cpi -> force_next_frame_intra = 1 ; if ( ( ( cm -> Width + 15 ) & 0xfffffff0 ) != cm -> yv12_fb [ cm -> lst_fb_idx ] . y_width || ( ( cm -> Height + 15 ) & 0xfffffff0 ) != cm -> yv12_fb [ cm -> lst_fb_idx ] . y_height || cm -> yv12_fb [ cm -> lst_fb_idx ] . y_width == 0 ) { dealloc_raw_frame_buffers ( cpi ) ; alloc_raw_frame_buffers ( cpi ) ; vp8_alloc_compressor_data ( cpi ) ; } if ( cpi -> oxcf . fixed_q >= 0 ) { cpi -> last_q [ 0 ] = cpi -> oxcf . fixed_q ; cpi -> last_q [ 1 ] = cpi -> oxcf . fixed_q ; } cpi -> Speed = cpi -> oxcf . cpu_used ; if ( cpi -> oxcf . lag_in_frames == 0 ) { cpi -> oxcf . allow_lag = 0 ; } else if ( cpi -> oxcf . lag_in_frames > MAX_LAG_BUFFERS ) cpi -> oxcf . lag_in_frames = MAX_LAG_BUFFERS ; cpi -> alt_ref_source = NULL ; cpi -> is_src_frame_alt_ref = 0 ; # if CONFIG_TEMPORAL_DENOISING if ( cpi -> oxcf . noise_sensitivity ) { if ( ! cpi -> denoiser . yv12_mc_running_avg . buffer_alloc ) { int width = ( cpi -> oxcf . Width + 15 ) & ~ 15 ; int height = ( cpi -> oxcf . Height + 15 ) & ~ 15 ; <S2SV_StartBug> vp8_denoiser_allocate ( & cpi -> denoiser , width , height ) ; <S2SV_EndBug> } } # endif # if 0 cpi -> frame_distortion = 0 ; cpi -> last_frame_distortion = 0 ; # endif }\n","target":"<S2SV_ModStart> : DEFAULT_GF_INTERVAL ; <S2SV_ModEnd> # if ( <S2SV_ModStart> prev_number_of_layers ) { if ( cpi -> temporal_layer_id > 0 ) { cpi -> temporal_layer_id = 0 ; } <S2SV_ModStart> ) ; } if ( ! cpi -> initial_width ) { cpi -> initial_width = cpi -> oxcf . Width ; cpi -> initial_height = cpi -> oxcf . Height ; } cm -> Width = cpi -> oxcf . Width <S2SV_ModEnd> ; cm -> <S2SV_ModStart> oxcf . Height ; assert ( cm -> Width <= cpi -> initial_width ) ; assert ( cm -> Height <= cpi -> initial_height ) <S2SV_ModStart> width , height , cm -> mb_rows , cm -> mb_cols , cpi -> oxcf . noise_sensitivity\n","project_and_commit_id":"external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426","cve_id":"CVE-2016-1621","original_address":"https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426","time":"2016-03-12T21:59Z"},
	{"Unnamed: 0":3536,"cwe_id":"CWE-763","source":"CWE-763 static OM_uint32 acc_ctx_hints ( OM_uint32 * minor_status , gss_ctx_id_t * ctx , spnego_gss_cred_id_t spcred , gss_buffer_t * mechListMIC , OM_uint32 * negState , send_token_flag * return_token ) { OM_uint32 tmpmin , ret ; gss_OID_set supported_mechSet ; spnego_gss_ctx_id_t sc = NULL ; * mechListMIC = GSS_C_NO_BUFFER ; supported_mechSet = GSS_C_NO_OID_SET ; * return_token = NO_TOKEN_SEND ; * negState = REJECT ; * minor_status = 0 ; if ( * ctx != GSS_C_NO_CONTEXT ) return GSS_S_DEFECTIVE_TOKEN ; ret = get_negotiable_mechs ( minor_status , spcred , GSS_C_ACCEPT , & supported_mechSet ) ; if ( ret != GSS_S_COMPLETE ) goto cleanup ; ret = make_NegHints ( minor_status , mechListMIC ) ; if ( ret != GSS_S_COMPLETE ) goto cleanup ; <S2SV_StartBug> sc = create_spnego_ctx ( ) ; <S2SV_EndBug> if ( sc == NULL ) { ret = GSS_S_FAILURE ; goto cleanup ; } if ( put_mech_set ( supported_mechSet , & sc -> DER_mechTypes ) < 0 ) { ret = GSS_S_FAILURE ; goto cleanup ; } sc -> internal_mech = GSS_C_NO_OID ; * negState = ACCEPT_INCOMPLETE ; * return_token = INIT_TOKEN_SEND ; sc -> firstpass = 1 ; * ctx = ( gss_ctx_id_t ) sc ; sc = NULL ; ret = GSS_S_COMPLETE ; cleanup : release_spnego_ctx ( & sc ) ; gss_release_oid_set ( & tmpmin , & supported_mechSet ) ; return ret ; }\n","target":"<S2SV_ModStart> = create_spnego_ctx ( 0\n","project_and_commit_id":"krb5@krb5/b51b33f2bc5d1497ddf5bd107f791c101695000d","cve_id":"CVE-2015-2695","original_address":"https://github.com/krb5/krb5/commit/b51b33f2bc5d1497ddf5bd107f791c101695000d","time":"2015-11-09T03:59Z"},
	{"Unnamed: 0":3080,"cwe_id":"CWE-400","source":"CWE-400 <S2SV_StartBug> static void __evtchn_fifo_handle_events ( unsigned cpu , bool drop ) <S2SV_EndBug> { struct evtchn_fifo_control_block * control_block ; unsigned long ready ; unsigned q ; control_block = per_cpu ( cpu_control_block , cpu ) ; ready = xchg ( & control_block -> ready , 0 ) ; while ( ready ) { q = find_first_bit ( & ready , EVTCHN_FIFO_MAX_QUEUES ) ; <S2SV_StartBug> consume_one_event ( cpu , control_block , q , & ready , drop ) ; <S2SV_EndBug> ready |= xchg ( & control_block -> ready , 0 ) ; } }\n","target":"<S2SV_ModStart> unsigned cpu , struct evtchn_loop_ctrl * ctrl <S2SV_ModEnd> ) { struct <S2SV_ModStart> ( cpu , ctrl , <S2SV_ModStart> , & ready <S2SV_ModEnd> ) ; ready\n","project_and_commit_id":"torvalds@linux/e99502f76271d6bc4e374fe368c50c67a1fd3070","cve_id":"CVE-2020-27673","original_address":"https://github.com/torvalds/linux/commit/e99502f76271d6bc4e374fe368c50c67a1fd3070","time":"2020-10-22T21:15Z"},
	{"Unnamed: 0":5929,"cwe_id":"CWE-362","source":"CWE-362 int ext4_insert_range ( struct inode * inode , loff_t offset , loff_t len ) { struct super_block * sb = inode -> i_sb ; handle_t * handle ; struct ext4_ext_path * path ; struct ext4_extent * extent ; ext4_lblk_t offset_lblk , len_lblk , ee_start_lblk = 0 ; unsigned int credits , ee_len ; int ret = 0 , depth , split_flag = 0 ; loff_t ioffset ; if ( ! ext4_test_inode_flag ( inode , EXT4_INODE_EXTENTS ) ) return - EOPNOTSUPP ; if ( offset & ( EXT4_CLUSTER_SIZE ( sb ) - 1 ) || len & ( EXT4_CLUSTER_SIZE ( sb ) - 1 ) ) return - EINVAL ; if ( ! S_ISREG ( inode -> i_mode ) ) return - EOPNOTSUPP ; trace_ext4_insert_range ( inode , offset , len ) ; offset_lblk = offset >> EXT4_BLOCK_SIZE_BITS ( sb ) ; len_lblk = len >> EXT4_BLOCK_SIZE_BITS ( sb ) ; if ( ext4_should_journal_data ( inode ) ) { ret = ext4_force_commit ( inode -> i_sb ) ; if ( ret ) return ret ; } ioffset = round_down ( offset , PAGE_SIZE ) ; ret = filemap_write_and_wait_range ( inode -> i_mapping , ioffset , LLONG_MAX ) ; if ( ret ) return ret ; mutex_lock ( & inode -> i_mutex ) ; if ( ! ext4_test_inode_flag ( inode , EXT4_INODE_EXTENTS ) ) { ret = - EOPNOTSUPP ; goto out_mutex ; } if ( inode -> i_size + len > inode -> i_sb -> s_maxbytes ) { ret = - EFBIG ; goto out_mutex ; } if ( offset >= i_size_read ( inode ) ) { ret = - EINVAL ; goto out_mutex ; } <S2SV_StartBug> truncate_pagecache ( inode , ioffset ) ; <S2SV_EndBug> <S2SV_StartBug> ext4_inode_block_unlocked_dio ( inode ) ; <S2SV_EndBug> inode_dio_wait ( inode ) ; credits = ext4_writepage_trans_blocks ( inode ) ; handle = ext4_journal_start ( inode , EXT4_HT_TRUNCATE , credits ) ; if ( IS_ERR ( handle ) ) { ret = PTR_ERR ( handle ) ; <S2SV_StartBug> goto out_dio ; <S2SV_EndBug> } inode -> i_size += len ; EXT4_I ( inode ) -> i_disksize += len ; inode -> i_mtime = inode -> i_ctime = ext4_current_time ( inode ) ; ret = ext4_mark_inode_dirty ( handle , inode ) ; if ( ret ) goto out_stop ; down_write ( & EXT4_I ( inode ) -> i_data_sem ) ; ext4_discard_preallocations ( inode ) ; path = ext4_find_extent ( inode , offset_lblk , NULL , 0 ) ; if ( IS_ERR ( path ) ) { up_write ( & EXT4_I ( inode ) -> i_data_sem ) ; goto out_stop ; } depth = ext_depth ( inode ) ; extent = path [ depth ] . p_ext ; if ( extent ) { ee_start_lblk = le32_to_cpu ( extent -> ee_block ) ; ee_len = ext4_ext_get_actual_len ( extent ) ; if ( ( offset_lblk > ee_start_lblk ) && ( offset_lblk < ( ee_start_lblk + ee_len ) ) ) { if ( ext4_ext_is_unwritten ( extent ) ) split_flag = EXT4_EXT_MARK_UNWRIT1 | EXT4_EXT_MARK_UNWRIT2 ; ret = ext4_split_extent_at ( handle , inode , & path , offset_lblk , split_flag , EXT4_EX_NOCACHE | EXT4_GET_BLOCKS_PRE_IO | EXT4_GET_BLOCKS_METADATA_NOFAIL ) ; } ext4_ext_drop_refs ( path ) ; kfree ( path ) ; if ( ret < 0 ) { up_write ( & EXT4_I ( inode ) -> i_data_sem ) ; goto out_stop ; } } ret = ext4_es_remove_extent ( inode , offset_lblk , EXT_MAX_BLOCKS - offset_lblk ) ; if ( ret ) { up_write ( & EXT4_I ( inode ) -> i_data_sem ) ; goto out_stop ; } ret = ext4_ext_shift_extents ( inode , handle , ee_start_lblk > offset_lblk ? ee_start_lblk : offset_lblk , len_lblk , SHIFT_RIGHT ) ; up_write ( & EXT4_I ( inode ) -> i_data_sem ) ; if ( IS_SYNC ( inode ) ) ext4_handle_sync ( handle ) ; out_stop : ext4_journal_stop ( handle ) ; <S2SV_StartBug> out_dio : <S2SV_EndBug> ext4_inode_resume_unlocked_dio ( inode ) ; out_mutex : mutex_unlock ( & inode -> i_mutex ) ; return ret ; }\n","target":"<S2SV_ModStart> out_mutex ; } ext4_inode_block_unlocked_dio ( inode ) ; inode_dio_wait ( inode ) ; down_write ( & EXT4_I ( inode ) -> i_mmap_sem ) ; <S2SV_ModStart> ioffset ) ; <S2SV_ModEnd> credits = ext4_writepage_trans_blocks <S2SV_ModStart> ) ; goto out_mmap <S2SV_ModEnd> ; } inode <S2SV_ModStart> handle ) ; out_mmap : up_write ( & EXT4_I ( inode ) -> i_mmap_sem ) ; <S2SV_ModEnd> ext4_inode_resume_unlocked_dio ( inode\n","project_and_commit_id":"torvalds@linux/ea3d7209ca01da209cda6f0dea8be9cc4b7a933b","cve_id":"CVE-2015-8839","original_address":"https://github.com/torvalds/linux/commit/ea3d7209ca01da209cda6f0dea8be9cc4b7a933b","time":"2016-05-02T10:59Z"},
	{"Unnamed: 0":6432,"cwe_id":"CWE-20","source":"CWE-20 static Image * ReadDCMImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { <S2SV_StartBug> # define ThrowDCMException ( exception , message ) { if ( info . scale != ( Quantum * ) NULL ) info . scale = ( Quantum * ) RelinquishMagickMemory ( info . scale ) ; if ( data != ( unsigned char * ) NULL ) data = ( unsigned char * ) RelinquishMagickMemory ( data ) ; if ( graymap != ( int * ) NULL ) graymap = ( int * ) RelinquishMagickMemory ( graymap ) ; if ( bluemap != ( int * ) NULL ) bluemap = ( int * ) RelinquishMagickMemory ( bluemap ) ; if ( greenmap != ( int * ) NULL ) greenmap = ( int * ) RelinquishMagickMemory ( greenmap ) ; if ( redmap != ( int * ) NULL ) redmap = ( int * ) RelinquishMagickMemory ( redmap ) ; if ( stream_info -> offsets != ( ssize_t * ) NULL ) stream_info -> offsets = ( ssize_t * ) RelinquishMagickMemory ( stream_info -> offsets ) ; if ( stream_info != ( DCMStreamInfo * ) NULL ) stream_info = ( DCMStreamInfo * ) RelinquishMagickMemory ( stream_info ) ; ThrowReaderException ( ( exception ) , ( message ) ) ; } <S2SV_EndBug> char explicit_vr [ MagickPathExtent ] , implicit_vr [ MagickPathExtent ] , magick [ MagickPathExtent ] , photometric [ MagickPathExtent ] ; DCMInfo info ; DCMStreamInfo * stream_info ; Image * image ; int * bluemap , datum , * greenmap , * graymap , * redmap ; MagickBooleanType explicit_file , explicit_retry , use_explicit ; MagickOffsetType offset ; register unsigned char * p ; register ssize_t i ; size_t colors , height , length , number_scenes , quantum , status , width ; ssize_t count , scene ; unsigned char * data ; unsigned short group , element ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickCoreSignature ) ; if ( image_info -> debug != MagickFalse ) ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , \"%s\" , image_info -> filename ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickCoreSignature ) ; image = AcquireImage ( image_info , exception ) ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } image -> depth = 8UL ; image -> endian = LSBEndian ; ( void ) memset ( & info , 0 , sizeof ( info ) ) ; data = ( unsigned char * ) NULL ; graymap = ( int * ) NULL ; redmap = ( int * ) NULL ; greenmap = ( int * ) NULL ; bluemap = ( int * ) NULL ; stream_info = ( DCMStreamInfo * ) AcquireMagickMemory ( sizeof ( * stream_info ) ) ; if ( stream_info == ( DCMStreamInfo * ) NULL ) ThrowDCMException ( ResourceLimitError , \"MemoryAllocationFailed\" ) ; ( void ) memset ( stream_info , 0 , sizeof ( * stream_info ) ) ; count = ReadBlob ( image , 128 , ( unsigned char * ) magick ) ; if ( count != 128 ) ThrowDCMException ( CorruptImageError , \"ImproperImageHeader\" ) ; count = ReadBlob ( image , 4 , ( unsigned char * ) magick ) ; if ( ( count != 4 ) || ( LocaleNCompare ( magick , \"DICM\" , 4 ) != 0 ) ) { offset = SeekBlob ( image , 0L , SEEK_SET ) ; if ( offset < 0 ) ThrowDCMException ( CorruptImageError , \"ImproperImageHeader\" ) ; } ( void ) CopyMagickString ( photometric , \"MONOCHROME1<S2SV_blank>\" , MagickPathExtent ) ; info . bits_allocated = 8 ; info . bytes_per_pixel = 1 ; info . depth = 8 ; info . mask = 0xffff ; info . max_value = 255UL ; info . samples_per_pixel = 1 ; info . signed_data = ( ~ 0UL ) ; info . rescale_slope = 1.0 ; data = ( unsigned char * ) NULL ; element = 0 ; explicit_vr [ 2 ] = '\\\\0' ; explicit_file = MagickFalse ; colors = 0 ; redmap = ( int * ) NULL ; greenmap = ( int * ) NULL ; bluemap = ( int * ) NULL ; graymap = ( int * ) NULL ; height = 0 ; number_scenes = 1 ; use_explicit = MagickFalse ; explicit_retry = MagickFalse ; width = 0 ; while ( TellBlob ( image ) < ( MagickOffsetType ) GetBlobSize ( image ) ) { for ( group = 0 ; ( group != 0x7FE0 ) || ( element != 0x0010 ) ; ) { image -> offset = ( ssize_t ) TellBlob ( image ) ; group = ReadBlobLSBShort ( image ) ; element = ReadBlobLSBShort ( image ) ; if ( ( group == 0xfffc ) && ( element == 0xfffc ) ) break ; if ( ( group != 0x0002 ) && ( image -> endian == MSBEndian ) ) { group = ( unsigned short ) ( ( group << 8 ) | ( ( group >> 8 ) & 0xFF ) ) ; element = ( unsigned short ) ( ( element << 8 ) | ( ( element >> 8 ) & 0xFF ) ) ; } quantum = 0 ; for ( i = 0 ; dicom_info [ i ] . group < 0xffff ; i ++ ) if ( ( group == dicom_info [ i ] . group ) && ( element == dicom_info [ i ] . element ) ) break ; ( void ) CopyMagickString ( implicit_vr , dicom_info [ i ] . vr , MagickPathExtent ) ; count = ReadBlob ( image , 2 , ( unsigned char * ) explicit_vr ) ; if ( count != 2 ) ThrowDCMException ( CorruptImageError , \"ImproperImageHeader\" ) ; if ( ( explicit_file == MagickFalse ) && ( group != 0x0002 ) ) explicit_file = ( isupper ( ( unsigned char ) * explicit_vr ) != MagickFalse ) && ( isupper ( ( unsigned char ) * ( explicit_vr + 1 ) ) != MagickFalse ) ? MagickTrue : MagickFalse ; use_explicit = ( ( group == 0x0002 ) && ( explicit_retry == MagickFalse ) ) || ( explicit_file != MagickFalse ) ? MagickTrue : MagickFalse ; if ( ( use_explicit != MagickFalse ) && ( strncmp ( implicit_vr , \"xs\" , 2 ) == 0 ) ) ( void ) CopyMagickString ( implicit_vr , explicit_vr , MagickPathExtent ) ; if ( ( use_explicit == MagickFalse ) || ( strncmp ( implicit_vr , \"!!\" , 2 ) == 0 ) ) { offset = SeekBlob ( image , ( MagickOffsetType ) - 2 , SEEK_CUR ) ; if ( offset < 0 ) ThrowDCMException ( CorruptImageError , \"ImproperImageHeader\" ) ; quantum = 4 ; } else { quantum = 2 ; if ( ( strncmp ( explicit_vr , \"OB\" , 2 ) == 0 ) || ( strncmp ( explicit_vr , \"UN\" , 2 ) == 0 ) || ( strncmp ( explicit_vr , \"OW\" , 2 ) == 0 ) || ( strncmp ( explicit_vr , \"SQ\" , 2 ) == 0 ) ) { ( void ) ReadBlobLSBShort ( image ) ; quantum = 4 ; } } datum = 0 ; if ( quantum == 4 ) { if ( group == 0x0002 ) datum = ReadBlobLSBSignedLong ( image ) ; else datum = ReadBlobSignedLong ( image ) ; } else if ( quantum == 2 ) { if ( group == 0x0002 ) datum = ReadBlobLSBSignedShort ( image ) ; else datum = ReadBlobSignedShort ( image ) ; } quantum = 0 ; length = 1 ; if ( datum != 0 ) { if ( ( strncmp ( implicit_vr , \"OW\" , 2 ) == 0 ) || ( strncmp ( implicit_vr , \"SS\" , 2 ) == 0 ) || ( strncmp ( implicit_vr , \"US\" , 2 ) == 0 ) ) quantum = 2 ; else if ( ( strncmp ( implicit_vr , \"FL\" , 2 ) == 0 ) || ( strncmp ( implicit_vr , \"OF\" , 2 ) == 0 ) || ( strncmp ( implicit_vr , \"SL\" , 2 ) == 0 ) || ( strncmp ( implicit_vr , \"UL\" , 2 ) == 0 ) ) quantum = 4 ; else if ( strncmp ( implicit_vr , \"FD\" , 2 ) == 0 ) quantum = 8 ; else quantum = 1 ; if ( datum != ~ 0 ) length = ( size_t ) datum / quantum ; else { quantum = 0 ; length = 0 ; } } if ( image_info -> verbose != MagickFalse ) { if ( use_explicit == MagickFalse ) explicit_vr [ 0 ] = '\\\\0' ; for ( i = 0 ; dicom_info [ i ] . description != ( char * ) NULL ; i ++ ) if ( ( group == dicom_info [ i ] . group ) && ( element == dicom_info [ i ] . element ) ) break ; ( void ) FormatLocaleFile ( stdout , \"0x%04lX<S2SV_blank>%4ld<S2SV_blank>%s-%s<S2SV_blank>(0x%04lx,0x%04lx)\" , ( unsigned long ) image -> offset , ( long ) length , implicit_vr , explicit_vr , ( unsigned long ) group , ( unsigned long ) element ) ; if ( dicom_info [ i ] . description != ( char * ) NULL ) ( void ) FormatLocaleFile ( stdout , \"<S2SV_blank>%s\" , dicom_info [ i ] . description ) ; ( void ) FormatLocaleFile ( stdout , \":<S2SV_blank>\" ) ; } if ( ( group == 0x7FE0 ) && ( element == 0x0010 ) ) { if ( image_info -> verbose != MagickFalse ) ( void ) FormatLocaleFile ( stdout , \"\\\\n\" ) ; break ; } data = ( unsigned char * ) NULL ; if ( ( length == 1 ) && ( quantum == 1 ) ) datum = ReadBlobByte ( image ) ; else if ( ( length == 1 ) && ( quantum == 2 ) ) { if ( group == 0x0002 ) datum = ReadBlobLSBSignedShort ( image ) ; else datum = ReadBlobSignedShort ( image ) ; } else if ( ( length == 1 ) && ( quantum == 4 ) ) { if ( group == 0x0002 ) datum = ReadBlobLSBSignedLong ( image ) ; else datum = ReadBlobSignedLong ( image ) ; } else if ( ( quantum != 0 ) && ( length != 0 ) ) { if ( length > ( size_t ) GetBlobSize ( image ) ) ThrowDCMException ( CorruptImageError , \"InsufficientImageDataInFile\" ) ; if ( ~ length >= 1 ) data = ( unsigned char * ) AcquireQuantumMemory ( length + 1 , quantum * sizeof ( * data ) ) ; if ( data == ( unsigned char * ) NULL ) ThrowDCMException ( ResourceLimitError , \"MemoryAllocationFailed\" ) ; count = ReadBlob ( image , ( size_t ) quantum * length , data ) ; if ( count != ( ssize_t ) ( quantum * length ) ) { if ( image_info -> verbose != MagickFalse ) ( void ) FormatLocaleFile ( stdout , \"count=%d<S2SV_blank>quantum=%d<S2SV_blank>\" \"length=%d<S2SV_blank>group=%d\\\\n\" , ( int ) count , ( int ) quantum , ( int ) length , ( int ) group ) ; ThrowDCMException ( CorruptImageError , \"InsufficientImageDataInFile\" ) ; } data [ length * quantum ] = '\\\\0' ; } if ( ( ( ( unsigned int ) group << 16 ) | element ) == 0xFFFEE0DD ) { if ( data != ( unsigned char * ) NULL ) data = ( unsigned char * ) RelinquishMagickMemory ( data ) ; continue ; } switch ( group ) { case 0x0002 : { switch ( element ) { case 0x0010 : { char transfer_syntax [ MagickPathExtent ] ; if ( ( datum == 0 ) && ( explicit_retry == MagickFalse ) ) { explicit_retry = MagickTrue ; ( void ) SeekBlob ( image , ( MagickOffsetType ) 0 , SEEK_SET ) ; group = 0 ; element = 0 ; if ( image_info -> verbose != MagickFalse ) ( void ) FormatLocaleFile ( stdout , \"Corrupted<S2SV_blank>image<S2SV_blank>-<S2SV_blank>trying<S2SV_blank>explicit<S2SV_blank>format\\\\n\" ) ; break ; } * transfer_syntax = '\\\\0' ; if ( data != ( unsigned char * ) NULL ) ( void ) CopyMagickString ( transfer_syntax , ( char * ) data , MagickPathExtent ) ; if ( image_info -> verbose != MagickFalse ) ( void ) FormatLocaleFile ( stdout , \"transfer_syntax=%s\\\\n\" , ( const char * ) transfer_syntax ) ; if ( strncmp ( transfer_syntax , \"1.2.840.10008.1.2\" , 17 ) == 0 ) { int subtype , type ; type = 1 ; subtype = 0 ; if ( strlen ( transfer_syntax ) > 17 ) { count = ( ssize_t ) sscanf ( transfer_syntax + 17 , \".%d.%d\" , & type , & subtype ) ; if ( count < 1 ) ThrowDCMException ( CorruptImageError , \"ImproperImageHeader\" ) ; } switch ( type ) { case 1 : { image -> endian = LSBEndian ; break ; } case 2 : { image -> endian = MSBEndian ; break ; } case 4 : { if ( ( subtype >= 80 ) && ( subtype <= 81 ) ) image -> compression = JPEGCompression ; else if ( ( subtype >= 90 ) && ( subtype <= 93 ) ) image -> compression = JPEG2000Compression ; else image -> compression = JPEGCompression ; break ; } case 5 : { image -> compression = RLECompression ; break ; } } } break ; } default : break ; } break ; } case 0x0028 : { switch ( element ) { case 0x0002 : { info . samples_per_pixel = ( size_t ) datum ; if ( ( info . samples_per_pixel == 0 ) || ( info . samples_per_pixel > 4 ) ) ThrowDCMException ( CorruptImageError , \"ImproperImageHeader\" ) ; break ; } case 0x0004 : { if ( data == ( unsigned char * ) NULL ) break ; for ( i = 0 ; i < ( ssize_t ) MagickMin ( length , MagickPathExtent - 1 ) ; i ++ ) photometric [ i ] = ( char ) data [ i ] ; photometric [ i ] = '\\\\0' ; info . polarity = LocaleCompare ( photometric , \"MONOCHROME1<S2SV_blank>\" ) == 0 ? MagickTrue : MagickFalse ; break ; } case 0x0006 : { if ( datum == 1 ) image -> interlace = PlaneInterlace ; break ; } case 0x0008 : { if ( data == ( unsigned char * ) NULL ) break ; number_scenes = StringToUnsignedLong ( ( char * ) data ) ; break ; } case 0x0010 : { height = ( size_t ) datum ; break ; } case 0x0011 : { width = ( size_t ) datum ; break ; } case 0x0100 : { info . bits_allocated = ( size_t ) datum ; info . bytes_per_pixel = 1 ; if ( datum > 8 ) info . bytes_per_pixel = 2 ; info . depth = info . bits_allocated ; if ( ( info . depth == 0 ) || ( info . depth > 32 ) ) ThrowDCMException ( CorruptImageError , \"ImproperImageHeader\" ) ; info . max_value = ( 1UL << info . bits_allocated ) - 1 ; image -> depth = info . depth ; break ; } case 0x0101 : { info . significant_bits = ( size_t ) datum ; info . bytes_per_pixel = 1 ; if ( info . significant_bits > 8 ) info . bytes_per_pixel = 2 ; info . depth = info . significant_bits ; if ( ( info . depth == 0 ) || ( info . depth > 16 ) ) ThrowDCMException ( CorruptImageError , \"ImproperImageHeader\" ) ; info . max_value = ( 1UL << info . significant_bits ) - 1 ; info . mask = ( size_t ) GetQuantumRange ( info . significant_bits ) ; image -> depth = info . depth ; break ; } case 0x0102 : { break ; } case 0x0103 : { info . signed_data = ( size_t ) datum ; break ; } case 0x1050 : { if ( data != ( unsigned char * ) NULL ) info . window_center = StringToDouble ( ( char * ) data , ( char * * ) NULL ) ; break ; } case 0x1051 : { if ( data != ( unsigned char * ) NULL ) info . window_width = StringToDouble ( ( char * ) data , ( char * * ) NULL ) ; break ; } case 0x1052 : { if ( data != ( unsigned char * ) NULL ) info . rescale_intercept = StringToDouble ( ( char * ) data , ( char * * ) NULL ) ; break ; } case 0x1053 : { if ( data != ( unsigned char * ) NULL ) info . rescale_slope = StringToDouble ( ( char * ) data , ( char * * ) NULL ) ; break ; } case 0x1200 : case 0x3006 : { if ( data == ( unsigned char * ) NULL ) break ; colors = ( size_t ) ( length / info . bytes_per_pixel ) ; datum = ( int ) colors ; if ( graymap != ( int * ) NULL ) graymap = ( int * ) RelinquishMagickMemory ( graymap ) ; graymap = ( int * ) AcquireQuantumMemory ( MagickMax ( colors , 65536 ) , sizeof ( * graymap ) ) ; if ( graymap == ( int * ) NULL ) ThrowDCMException ( ResourceLimitError , \"MemoryAllocationFailed\" ) ; ( void ) memset ( graymap , 0 , MagickMax ( colors , 65536 ) * sizeof ( * graymap ) ) ; for ( i = 0 ; i < ( ssize_t ) colors ; i ++ ) if ( info . bytes_per_pixel == 1 ) graymap [ i ] = ( int ) data [ i ] ; else graymap [ i ] = ( int ) ( ( short * ) data ) [ i ] ; break ; } case 0x1201 : { unsigned short index ; if ( data == ( unsigned char * ) NULL ) break ; colors = ( size_t ) ( length / 2 ) ; datum = ( int ) colors ; if ( redmap != ( int * ) NULL ) redmap = ( int * ) RelinquishMagickMemory ( redmap ) ; redmap = ( int * ) AcquireQuantumMemory ( MagickMax ( colors , 65536 ) , sizeof ( * redmap ) ) ; if ( redmap == ( int * ) NULL ) ThrowDCMException ( ResourceLimitError , \"MemoryAllocationFailed\" ) ; ( void ) memset ( redmap , 0 , MagickMax ( colors , 65536 ) * sizeof ( * redmap ) ) ; p = data ; for ( i = 0 ; i < ( ssize_t ) colors ; i ++ ) { if ( image -> endian == MSBEndian ) index = ( unsigned short ) ( ( * p << 8 ) | * ( p + 1 ) ) ; else index = ( unsigned short ) ( * p | ( * ( p + 1 ) << 8 ) ) ; redmap [ i ] = ( int ) index ; p += 2 ; } break ; } case 0x1202 : { unsigned short index ; if ( data == ( unsigned char * ) NULL ) break ; colors = ( size_t ) ( length / 2 ) ; datum = ( int ) colors ; if ( greenmap != ( int * ) NULL ) greenmap = ( int * ) RelinquishMagickMemory ( greenmap ) ; greenmap = ( int * ) AcquireQuantumMemory ( MagickMax ( colors , 65536 ) , sizeof ( * greenmap ) ) ; if ( greenmap == ( int * ) NULL ) ThrowDCMException ( ResourceLimitError , \"MemoryAllocationFailed\" ) ; ( void ) memset ( greenmap , 0 , MagickMax ( colors , 65536 ) * sizeof ( * greenmap ) ) ; p = data ; for ( i = 0 ; i < ( ssize_t ) colors ; i ++ ) { if ( image -> endian == MSBEndian ) index = ( unsigned short ) ( ( * p << 8 ) | * ( p + 1 ) ) ; else index = ( unsigned short ) ( * p | ( * ( p + 1 ) << 8 ) ) ; greenmap [ i ] = ( int ) index ; p += 2 ; } break ; } case 0x1203 : { unsigned short index ; if ( data == ( unsigned char * ) NULL ) break ; colors = ( size_t ) ( length / 2 ) ; datum = ( int ) colors ; if ( bluemap != ( int * ) NULL ) bluemap = ( int * ) RelinquishMagickMemory ( bluemap ) ; bluemap = ( int * ) AcquireQuantumMemory ( MagickMax ( colors , 65536 ) , sizeof ( * bluemap ) ) ; if ( bluemap == ( int * ) NULL ) ThrowDCMException ( ResourceLimitError , \"MemoryAllocationFailed\" ) ; ( void ) memset ( bluemap , 0 , MagickMax ( colors , 65536 ) * sizeof ( * bluemap ) ) ; p = data ; for ( i = 0 ; i < ( ssize_t ) colors ; i ++ ) { if ( image -> endian == MSBEndian ) index = ( unsigned short ) ( ( * p << 8 ) | * ( p + 1 ) ) ; else index = ( unsigned short ) ( * p | ( * ( p + 1 ) << 8 ) ) ; bluemap [ i ] = ( int ) index ; p += 2 ; } break ; } default : break ; } break ; } case 0x2050 : { switch ( element ) { case 0x0020 : { if ( ( data != ( unsigned char * ) NULL ) && ( strncmp ( ( char * ) data , \"INVERSE\" , 7 ) == 0 ) ) info . polarity = MagickTrue ; break ; } default : break ; } break ; } default : break ; } if ( data != ( unsigned char * ) NULL ) { char * attribute ; for ( i = 0 ; dicom_info [ i ] . description != ( char * ) NULL ; i ++ ) if ( ( group == dicom_info [ i ] . group ) && ( element == dicom_info [ i ] . element ) ) break ; if ( dicom_info [ i ] . description != ( char * ) NULL ) { attribute = AcquireString ( \"dcm:\" ) ; ( void ) ConcatenateString ( & attribute , dicom_info [ i ] . description ) ; for ( i = 0 ; i < ( ssize_t ) MagickMax ( length , 4 ) ; i ++ ) if ( isprint ( ( int ) data [ i ] ) == MagickFalse ) break ; if ( ( i == ( ssize_t ) length ) || ( length > 4 ) ) { ( void ) SubstituteString ( & attribute , \"<S2SV_blank>\" , \"\" ) ; ( void ) SetImageProperty ( image , attribute , ( char * ) data , exception ) ; } attribute = DestroyString ( attribute ) ; } } if ( image_info -> verbose != MagickFalse ) { if ( data == ( unsigned char * ) NULL ) ( void ) FormatLocaleFile ( stdout , \"%d\\\\n\" , datum ) ; else { for ( i = 0 ; i < ( ssize_t ) MagickMax ( length , 4 ) ; i ++ ) if ( isprint ( ( int ) data [ i ] ) == MagickFalse ) break ; if ( ( i != ( ssize_t ) length ) && ( length <= 4 ) ) { ssize_t j ; datum = 0 ; for ( j = ( ssize_t ) length - 1 ; j >= 0 ; j -- ) datum = ( 256 * datum + data [ j ] ) ; ( void ) FormatLocaleFile ( stdout , \"%d\" , datum ) ; } else for ( i = 0 ; i < ( ssize_t ) length ; i ++ ) if ( isprint ( ( int ) data [ i ] ) != MagickFalse ) ( void ) FormatLocaleFile ( stdout , \"%c\" , data [ i ] ) ; else ( void ) FormatLocaleFile ( stdout , \"%c\" , '.' ) ; ( void ) FormatLocaleFile ( stdout , \"\\\\n\" ) ; } } if ( data != ( unsigned char * ) NULL ) data = ( unsigned char * ) RelinquishMagickMemory ( data ) ; if ( EOFBlob ( image ) != MagickFalse ) { ThrowFileException ( exception , CorruptImageError , \"UnexpectedEndOfFile\" , image -> filename ) ; break ; } } if ( ( group == 0xfffc ) && ( element == 0xfffc ) ) { Image * last ; last = RemoveLastImageFromList ( & image ) ; if ( last != ( Image * ) NULL ) last = DestroyImage ( last ) ; break ; } if ( ( width == 0 ) || ( height == 0 ) ) ThrowDCMException ( CorruptImageError , \"ImproperImageHeader\" ) ; image -> columns = ( size_t ) width ; image -> rows = ( size_t ) height ; if ( info . signed_data == 0xffff ) info . signed_data = ( size_t ) ( info . significant_bits == 16 ? 1 : 0 ) ; if ( ( image -> compression == JPEGCompression ) || ( image -> compression == JPEG2000Compression ) ) { Image * images ; ImageInfo * read_info ; int c ; for ( i = 0 ; i < ( ssize_t ) stream_info -> remaining ; i ++ ) if ( ReadBlobByte ( image ) == EOF ) break ; ( void ) ( ( ( ssize_t ) ReadBlobLSBShort ( image ) << 16 ) | ReadBlobLSBShort ( image ) ) ; length = ( size_t ) ReadBlobLSBLong ( image ) ; if ( length > ( size_t ) GetBlobSize ( image ) ) ThrowDCMException ( CorruptImageError , \"InsufficientImageDataInFile\" ) ; stream_info -> offset_count = length >> 2 ; if ( stream_info -> offset_count != 0 ) { if ( stream_info -> offsets != ( ssize_t * ) NULL ) stream_info -> offsets = ( ssize_t * ) RelinquishMagickMemory ( stream_info -> offsets ) ; stream_info -> offsets = ( ssize_t * ) AcquireQuantumMemory ( stream_info -> offset_count , sizeof ( * stream_info -> offsets ) ) ; if ( stream_info -> offsets == ( ssize_t * ) NULL ) ThrowDCMException ( ResourceLimitError , \"MemoryAllocationFailed\" ) ; for ( i = 0 ; i < ( ssize_t ) stream_info -> offset_count ; i ++ ) stream_info -> offsets [ i ] = ( ssize_t ) ReadBlobLSBSignedLong ( image ) ; offset = TellBlob ( image ) ; for ( i = 0 ; i < ( ssize_t ) stream_info -> offset_count ; i ++ ) stream_info -> offsets [ i ] += offset ; } read_info = CloneImageInfo ( image_info ) ; SetImageInfoBlob ( read_info , ( void * ) NULL , 0 ) ; images = NewImageList ( ) ; for ( scene = 0 ; scene < ( ssize_t ) number_scenes ; scene ++ ) { char filename [ MagickPathExtent ] ; const char * property ; FILE * file ; Image * jpeg_image ; int unique_file ; unsigned int tag ; tag = ( ( unsigned int ) ReadBlobLSBShort ( image ) << 16 ) | ReadBlobLSBShort ( image ) ; length = ( size_t ) ReadBlobLSBLong ( image ) ; if ( tag == 0xFFFEE0DD ) break ; if ( tag != 0xFFFEE000 ) { read_info = DestroyImageInfo ( read_info ) ; ThrowDCMException ( CorruptImageError , \"ImproperImageHeader\" ) ; } file = ( FILE * ) NULL ; unique_file = AcquireUniqueFileResource ( filename ) ; if ( unique_file != - 1 ) file = fdopen ( unique_file , \"wb\" ) ; if ( file == ( FILE * ) NULL ) { ( void ) RelinquishUniqueFileResource ( filename ) ; ThrowFileException ( exception , FileOpenError , \"UnableToCreateTemporaryFile\" , filename ) ; break ; } for ( c = EOF ; length != 0 ; length -- ) { c = ReadBlobByte ( image ) ; if ( c == EOF ) { ThrowFileException ( exception , CorruptImageError , \"UnexpectedEndOfFile\" , image -> filename ) ; break ; } <S2SV_StartBug> ( void ) fputc ( c , file ) ; <S2SV_EndBug> } ( void ) fclose ( file ) ; if ( c == EOF ) break ; ( void ) FormatLocaleString ( read_info -> filename , MagickPathExtent , \"jpeg:%s\" , filename ) ; if ( image -> compression == JPEG2000Compression ) ( void ) FormatLocaleString ( read_info -> filename , MagickPathExtent , \"j2k:%s\" , filename ) ; jpeg_image = ReadImage ( read_info , exception ) ; if ( jpeg_image != ( Image * ) NULL ) { ResetImagePropertyIterator ( image ) ; property = GetNextImageProperty ( image ) ; while ( property != ( const char * ) NULL ) { ( void ) SetImageProperty ( jpeg_image , property , GetImageProperty ( image , property , exception ) , exception ) ; property = GetNextImageProperty ( image ) ; } AppendImageToList ( & images , jpeg_image ) ; } ( void ) RelinquishUniqueFileResource ( filename ) ; } read_info = DestroyImageInfo ( read_info ) ; if ( stream_info -> offsets != ( ssize_t * ) NULL ) stream_info -> offsets = ( ssize_t * ) RelinquishMagickMemory ( stream_info -> offsets ) ; stream_info = ( DCMStreamInfo * ) RelinquishMagickMemory ( stream_info ) ; if ( info . scale != ( Quantum * ) NULL ) info . scale = ( Quantum * ) RelinquishMagickMemory ( info . scale ) ; if ( graymap != ( int * ) NULL ) graymap = ( int * ) RelinquishMagickMemory ( graymap ) ; if ( bluemap != ( int * ) NULL ) bluemap = ( int * ) RelinquishMagickMemory ( bluemap ) ; if ( greenmap != ( int * ) NULL ) greenmap = ( int * ) RelinquishMagickMemory ( greenmap ) ; if ( redmap != ( int * ) NULL ) redmap = ( int * ) RelinquishMagickMemory ( redmap ) ; image = DestroyImageList ( image ) ; return ( GetFirstImageInList ( images ) ) ; } if ( info . depth != ( 1UL * MAGICKCORE_QUANTUM_DEPTH ) ) { QuantumAny range ; length = ( size_t ) ( GetQuantumRange ( info . depth ) + 1 ) ; if ( length > ( size_t ) GetBlobSize ( image ) ) ThrowDCMException ( CorruptImageError , \"InsufficientImageDataInFile\" ) ; if ( info . scale != ( Quantum * ) NULL ) info . scale = ( Quantum * ) RelinquishMagickMemory ( info . scale ) ; info . scale = ( Quantum * ) AcquireQuantumMemory ( MagickMax ( length , 256 ) , sizeof ( * info . scale ) ) ; if ( info . scale == ( Quantum * ) NULL ) ThrowDCMException ( ResourceLimitError , \"MemoryAllocationFailed\" ) ; ( void ) memset ( info . scale , 0 , MagickMax ( length , 256 ) * sizeof ( * info . scale ) ) ; range = GetQuantumRange ( info . depth ) ; for ( i = 0 ; i <= ( ssize_t ) GetQuantumRange ( info . depth ) ; i ++ ) info . scale [ i ] = ScaleAnyToQuantum ( ( size_t ) i , range ) ; } if ( image -> compression == RLECompression ) { unsigned int tag ; for ( i = 0 ; i < ( ssize_t ) stream_info -> remaining ; i ++ ) { int c ; c = ReadBlobByte ( image ) ; if ( c == EOF ) break ; } tag = ( ( unsigned int ) ReadBlobLSBShort ( image ) << 16 ) | ReadBlobLSBShort ( image ) ; ( void ) tag ; length = ( size_t ) ReadBlobLSBLong ( image ) ; if ( length > ( size_t ) GetBlobSize ( image ) ) ThrowDCMException ( CorruptImageError , \"InsufficientImageDataInFile\" ) ; stream_info -> offset_count = length >> 2 ; if ( stream_info -> offset_count != 0 ) { stream_info -> offsets = ( ssize_t * ) AcquireQuantumMemory ( stream_info -> offset_count , sizeof ( * stream_info -> offsets ) ) ; if ( stream_info -> offsets == ( ssize_t * ) NULL ) ThrowDCMException ( ResourceLimitError , \"MemoryAllocationFailed\" ) ; for ( i = 0 ; i < ( ssize_t ) stream_info -> offset_count ; i ++ ) { stream_info -> offsets [ i ] = ( ssize_t ) ReadBlobLSBSignedLong ( image ) ; if ( EOFBlob ( image ) != MagickFalse ) break ; } offset = TellBlob ( image ) + 8 ; for ( i = 0 ; i < ( ssize_t ) stream_info -> offset_count ; i ++ ) stream_info -> offsets [ i ] += offset ; } } for ( scene = 0 ; scene < ( ssize_t ) number_scenes ; scene ++ ) { if ( image_info -> ping != MagickFalse ) break ; image -> columns = ( size_t ) width ; image -> rows = ( size_t ) height ; image -> depth = info . depth ; status = SetImageExtent ( image , image -> columns , image -> rows , exception ) ; if ( status == MagickFalse ) break ; image -> colorspace = RGBColorspace ; ( void ) SetImageBackgroundColor ( image , exception ) ; if ( ( image -> colormap == ( PixelInfo * ) NULL ) && ( info . samples_per_pixel == 1 ) ) { int index ; size_t one ; one = 1 ; if ( colors == 0 ) colors = one << info . depth ; if ( AcquireImageColormap ( image , colors , exception ) == MagickFalse ) ThrowDCMException ( ResourceLimitError , \"MemoryAllocationFailed\" ) ; if ( redmap != ( int * ) NULL ) for ( i = 0 ; i < ( ssize_t ) colors ; i ++ ) { index = redmap [ i ] ; if ( ( info . scale != ( Quantum * ) NULL ) && ( index >= 0 ) && ( index <= ( int ) info . max_value ) ) index = ( int ) info . scale [ index ] ; image -> colormap [ i ] . red = ( MagickRealType ) index ; } if ( greenmap != ( int * ) NULL ) for ( i = 0 ; i < ( ssize_t ) colors ; i ++ ) { index = greenmap [ i ] ; if ( ( info . scale != ( Quantum * ) NULL ) && ( index >= 0 ) && ( index <= ( int ) info . max_value ) ) index = ( int ) info . scale [ index ] ; image -> colormap [ i ] . green = ( MagickRealType ) index ; } if ( bluemap != ( int * ) NULL ) for ( i = 0 ; i < ( ssize_t ) colors ; i ++ ) { index = bluemap [ i ] ; if ( ( info . scale != ( Quantum * ) NULL ) && ( index >= 0 ) && ( index <= ( int ) info . max_value ) ) index = ( int ) info . scale [ index ] ; image -> colormap [ i ] . blue = ( MagickRealType ) index ; } if ( graymap != ( int * ) NULL ) for ( i = 0 ; i < ( ssize_t ) colors ; i ++ ) { index = graymap [ i ] ; if ( ( info . scale != ( Quantum * ) NULL ) && ( index >= 0 ) && ( index <= ( int ) info . max_value ) ) index = ( int ) info . scale [ index ] ; image -> colormap [ i ] . red = ( MagickRealType ) index ; image -> colormap [ i ] . green = ( MagickRealType ) index ; image -> colormap [ i ] . blue = ( MagickRealType ) index ; } } if ( image -> compression == RLECompression ) { unsigned int tag ; for ( i = 0 ; i < ( ssize_t ) stream_info -> remaining ; i ++ ) { int c ; c = ReadBlobByte ( image ) ; if ( c == EOF ) break ; } tag = ( ( unsigned int ) ReadBlobLSBShort ( image ) << 16 ) | ReadBlobLSBShort ( image ) ; stream_info -> remaining = ( size_t ) ReadBlobLSBLong ( image ) ; if ( ( tag != 0xFFFEE000 ) || ( stream_info -> remaining <= 64 ) || ( EOFBlob ( image ) != MagickFalse ) ) { if ( stream_info -> offsets != ( ssize_t * ) NULL ) stream_info -> offsets = ( ssize_t * ) RelinquishMagickMemory ( stream_info -> offsets ) ; ThrowDCMException ( CorruptImageError , \"ImproperImageHeader\" ) ; } stream_info -> count = 0 ; stream_info -> segment_count = ReadBlobLSBLong ( image ) ; for ( i = 0 ; i < 15 ; i ++ ) stream_info -> segments [ i ] = ( ssize_t ) ReadBlobLSBSignedLong ( image ) ; stream_info -> remaining -= 64 ; if ( stream_info -> segment_count > 1 ) { info . bytes_per_pixel = 1 ; info . depth = 8 ; if ( stream_info -> offset_count > 0 ) ( void ) SeekBlob ( image , ( MagickOffsetType ) stream_info -> offsets [ 0 ] + stream_info -> segments [ 0 ] , SEEK_SET ) ; } } if ( ( info . samples_per_pixel > 1 ) && ( image -> interlace == PlaneInterlace ) ) { register ssize_t x ; register Quantum * q ; ssize_t y ; for ( i = 0 ; i < ( ssize_t ) info . samples_per_pixel ; i ++ ) { for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { q = GetAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { switch ( ( int ) i ) { case 0 : { SetPixelRed ( image , ScaleCharToQuantum ( ( unsigned char ) ReadDCMByte ( stream_info , image ) ) , q ) ; break ; } case 1 : { SetPixelGreen ( image , ScaleCharToQuantum ( ( unsigned char ) ReadDCMByte ( stream_info , image ) ) , q ) ; break ; } case 2 : { SetPixelBlue ( image , ScaleCharToQuantum ( ( unsigned char ) ReadDCMByte ( stream_info , image ) ) , q ) ; break ; } case 3 : { SetPixelAlpha ( image , ScaleCharToQuantum ( ( unsigned char ) ReadDCMByte ( stream_info , image ) ) , q ) ; break ; } default : break ; } q += GetPixelChannels ( image ) ; } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ; if ( status == MagickFalse ) break ; } } } } else { const char * option ; option = GetImageOption ( image_info , \"dcm:display-range\" ) ; if ( option != ( const char * ) NULL ) { if ( LocaleCompare ( option , \"reset\" ) == 0 ) info . window_width = 0 ; } option = GetImageOption ( image_info , \"dcm:window\" ) ; if ( option != ( char * ) NULL ) { GeometryInfo geometry_info ; MagickStatusType flags ; flags = ParseGeometry ( option , & geometry_info ) ; if ( flags & RhoValue ) info . window_center = geometry_info . rho ; if ( flags & SigmaValue ) info . window_width = geometry_info . sigma ; info . rescale = MagickTrue ; } option = GetImageOption ( image_info , \"dcm:rescale\" ) ; if ( option != ( char * ) NULL ) info . rescale = IsStringTrue ( option ) ; if ( ( info . window_center != 0 ) && ( info . window_width == 0 ) ) info . window_width = info . window_center ; status = ReadDCMPixels ( image , & info , stream_info , MagickTrue , exception ) ; if ( ( status != MagickFalse ) && ( stream_info -> segment_count > 1 ) ) { if ( stream_info -> offset_count > 0 ) ( void ) SeekBlob ( image , ( MagickOffsetType ) stream_info -> offsets [ 0 ] + stream_info -> segments [ 1 ] , SEEK_SET ) ; ( void ) ReadDCMPixels ( image , & info , stream_info , MagickFalse , exception ) ; } } if ( SetImageGray ( image , exception ) != MagickFalse ) ( void ) SetImageColorspace ( image , GRAYColorspace , exception ) ; if ( EOFBlob ( image ) != MagickFalse ) { ThrowFileException ( exception , CorruptImageError , \"UnexpectedEndOfFile\" , image -> filename ) ; break ; } if ( image_info -> number_scenes != 0 ) if ( image -> scene >= ( image_info -> scene + image_info -> number_scenes - 1 ) ) break ; if ( scene < ( ssize_t ) ( number_scenes - 1 ) ) { AcquireNextImage ( image_info , image , exception ) ; if ( GetNextImageInList ( image ) == ( Image * ) NULL ) { status = MagickFalse ; break ; } image = SyncNextImageInList ( image ) ; status = SetImageProgress ( image , LoadImagesTag , TellBlob ( image ) , GetBlobSize ( image ) ) ; if ( status == MagickFalse ) break ; } } if ( TellBlob ( image ) < ( MagickOffsetType ) GetBlobSize ( image ) ) { AcquireNextImage ( image_info , image , exception ) ; if ( GetNextImageInList ( image ) == ( Image * ) NULL ) { status = MagickFalse ; break ; } image = SyncNextImageInList ( image ) ; status = SetImageProgress ( image , LoadImagesTag , TellBlob ( image ) , GetBlobSize ( image ) ) ; if ( status == MagickFalse ) break ; } } if ( stream_info -> offsets != ( ssize_t * ) NULL ) stream_info -> offsets = ( ssize_t * ) RelinquishMagickMemory ( stream_info -> offsets ) ; stream_info = ( DCMStreamInfo * ) RelinquishMagickMemory ( stream_info ) ; if ( info . scale != ( Quantum * ) NULL ) info . scale = ( Quantum * ) RelinquishMagickMemory ( info . scale ) ; if ( graymap != ( int * ) NULL ) graymap = ( int * ) RelinquishMagickMemory ( graymap ) ; if ( bluemap != ( int * ) NULL ) bluemap = ( int * ) RelinquishMagickMemory ( bluemap ) ; if ( greenmap != ( int * ) NULL ) greenmap = ( int * ) RelinquishMagickMemory ( greenmap ) ; if ( redmap != ( int * ) NULL ) redmap = ( int * ) RelinquishMagickMemory ( redmap ) ; ( void ) CloseBlob ( image ) ; if ( status == MagickFalse ) return ( DestroyImageList ( image ) ) ; return ( GetFirstImageInList ( image ) ) ; }\n","target":"<S2SV_ModStart> , message ) \\\\\\n{ <S2SV_ModEnd> if ( info <S2SV_ModStart> ) ) ; \\\\\\n} <S2SV_ModEnd> char explicit_vr [ <S2SV_ModStart> break ; } if ( <S2SV_ModEnd> fputc ( c <S2SV_ModStart> , file ) != c ) break\n","project_and_commit_id":"ImageMagick@ImageMagick/6b6bff054d569a77973f2140c0e86366e6168a6c","cve_id":"CVE-2018-16643","original_address":"https://github.com/ImageMagick/ImageMagick/commit/6b6bff054d569a77973f2140c0e86366e6168a6c","time":"2018-09-06T22:29Z"},
	{"Unnamed: 0":5178,"cwe_id":"CWE-190","source":"CWE-190 jas_matrix_t * jas_matrix_create ( int numrows , int numcols ) { jas_matrix_t * matrix ; int i ; <S2SV_StartBug> if ( numrows < 0 || numcols < 0 ) { <S2SV_EndBug> <S2SV_StartBug> return 0 ; <S2SV_EndBug> } if ( ! ( matrix = jas_malloc ( sizeof ( jas_matrix_t ) ) ) ) { <S2SV_StartBug> return 0 ; <S2SV_EndBug> } matrix -> flags_ = 0 ; matrix -> numrows_ = numrows ; matrix -> numcols_ = numcols ; matrix -> rows_ = 0 ; matrix -> maxrows_ = numrows ; matrix -> data_ = 0 ; <S2SV_StartBug> matrix -> datasize_ = numrows * numcols ; <S2SV_EndBug> if ( matrix -> maxrows_ > 0 ) { if ( ! ( matrix -> rows_ = jas_alloc2 ( matrix -> maxrows_ , sizeof ( jas_seqent_t * ) ) ) ) { <S2SV_StartBug> jas_matrix_destroy ( matrix ) ; <S2SV_EndBug> return 0 ; } } if ( matrix -> datasize_ > 0 ) { if ( ! ( matrix -> data_ = jas_alloc2 ( matrix -> datasize_ , sizeof ( jas_seqent_t ) ) ) ) { <S2SV_StartBug> jas_matrix_destroy ( matrix ) ; <S2SV_EndBug> return 0 ; } } for ( i = 0 ; i < numrows ; ++ i ) { matrix -> rows_ [ i ] = & matrix -> data_ [ i * matrix -> numcols_ ] ; } for ( i = 0 ; i < matrix -> datasize_ ; ++ i ) { matrix -> data_ [ i ] = 0 ; } matrix -> xstart_ = 0 ; matrix -> ystart_ = 0 ; matrix -> xend_ = matrix -> numcols_ ; matrix -> yend_ = matrix -> numrows_ ; return matrix ; <S2SV_StartBug> } <S2SV_EndBug>\n","target":"<S2SV_ModStart> int i ; size_t size ; matrix = 0 ; <S2SV_ModStart> 0 ) { goto error <S2SV_ModEnd> ; } if <S2SV_ModStart> ) ) { goto error <S2SV_ModEnd> ; } matrix <S2SV_ModStart> -> datasize_ = 0 ; if ( ! jas_safe_size_mul ( numrows , numcols , & size ) ) { goto error ; } matrix -> datasize_ = size <S2SV_ModEnd> ; if ( <S2SV_ModStart> ) ) { goto error <S2SV_ModEnd> ; } } <S2SV_ModStart> ) ) { goto error <S2SV_ModEnd> ; } } <S2SV_ModStart> return matrix ; error : if ( matrix ) { jas_matrix_destroy ( matrix ) ; } return 0 ;\n","project_and_commit_id":"mdadams@jasper/988f8365f7d8ad8073b6786e433d34c553ecf568","cve_id":"CVE-2016-10249","original_address":"https://github.com/mdadams/jasper/commit/988f8365f7d8ad8073b6786e433d34c553ecf568","time":"2017-03-15T14:59Z"},
	{"Unnamed: 0":6387,"cwe_id":"CWE-264","source":"CWE-264 static int encrypted_update ( struct key * key , struct key_preparsed_payload * prep ) { struct encrypted_key_payload * epayload = key -> payload . data [ 0 ] ; struct encrypted_key_payload * new_epayload ; char * buf ; char * new_master_desc = NULL ; const char * format = NULL ; size_t datalen = prep -> datalen ; <S2SV_StartBug> int ret = 0 ; <S2SV_EndBug> if ( datalen <= 0 || datalen > 32767 || ! prep -> data ) return - EINVAL ; buf = kmalloc ( datalen + 1 , GFP_KERNEL ) ; if ( ! buf ) return - ENOMEM ; buf [ datalen ] = 0 ; memcpy ( buf , prep -> data , datalen ) ; ret = datablob_parse ( buf , & format , & new_master_desc , NULL , NULL ) ; if ( ret < 0 ) goto out ; ret = valid_master_desc ( new_master_desc , epayload -> master_desc ) ; if ( ret < 0 ) goto out ; new_epayload = encrypted_key_alloc ( key , epayload -> format , new_master_desc , epayload -> datalen ) ; if ( IS_ERR ( new_epayload ) ) { ret = PTR_ERR ( new_epayload ) ; goto out ; } __ekey_init ( new_epayload , epayload -> format , new_master_desc , epayload -> datalen ) ; memcpy ( new_epayload -> iv , epayload -> iv , ivsize ) ; memcpy ( new_epayload -> payload_data , epayload -> payload_data , epayload -> payload_datalen ) ; rcu_assign_keypointer ( key , new_epayload ) ; call_rcu ( & epayload -> rcu , encrypted_rcu_free ) ; out : kfree ( buf ) ; return ret ; }\n","target":"<S2SV_ModStart> ret = 0 ; if ( test_bit ( KEY_FLAG_NEGATIVE , & key -> flags ) ) return - ENOKEY\n","project_and_commit_id":"torvalds@linux/096fe9eaea40a17e125569f9e657e34cdb6d73bd","cve_id":"CVE-2015-8539","original_address":"https://github.com/torvalds/linux/commit/096fe9eaea40a17e125569f9e657e34cdb6d73bd","time":"2016-02-08T03:59Z"},
	{"Unnamed: 0":2074,"cwe_id":"CWE-119","source":"CWE-119 int main ( int argc , char * argv [ ] ) { int i , c ; FILE * ifp = 0 , * ofp = 0 ; const char * ifp_filename = \"<stdin>\" ; const char * ofp_filename = \"<stdout>\" ; const char * set_font_name = 0 ; struct font_reader fr ; uint32_t rfork_len ; int raw = 0 , macbinary = 1 , applesingle = 0 , appledouble = 0 , binhex = 0 ; Clp_Parser * clp = Clp_NewParser ( argc , ( const char * const * ) argv , sizeof ( options ) / sizeof ( options [ 0 ] ) , options ) ; program_name = Clp_ProgramName ( clp ) ; while ( 1 ) { int opt = Clp_Next ( clp ) ; switch ( opt ) { case RAW_OPT : raw = 1 ; macbinary = applesingle = appledouble = binhex = 0 ; break ; case MACBINARY_OPT : macbinary = 1 ; raw = applesingle = appledouble = binhex = 0 ; break ; case APPLESINGLE_OPT : applesingle = 1 ; raw = macbinary = appledouble = binhex = 0 ; break ; case APPLEDOUBLE_OPT : appledouble = 1 ; raw = macbinary = applesingle = binhex = 0 ; break ; case BINHEX_OPT : binhex = 1 ; raw = macbinary = applesingle = appledouble = 0 ; break ; output_file : case OUTPUT_OPT : if ( ofp ) fatal_error ( \"output<S2SV_blank>file<S2SV_blank>already<S2SV_blank>specified\" ) ; if ( strcmp ( clp -> vstr , \"-\" ) == 0 ) ofp = stdout ; else { ofp_filename = clp -> vstr ; ofp = fopen ( ofp_filename , \"wb\" ) ; if ( ! ofp ) fatal_error ( \"%s:<S2SV_blank>%s\" , ofp_filename , strerror ( errno ) ) ; } break ; case FILENAME_OPT : if ( set_font_name ) fatal_error ( \"Macintosh<S2SV_blank>font<S2SV_blank>filename<S2SV_blank>already<S2SV_blank>specified\" ) ; set_font_name = clp -> vstr ; break ; case HELP_OPT : usage ( ) ; exit ( 0 ) ; break ; case VERSION_OPT : printf ( \"t1mac<S2SV_blank>(LCDF<S2SV_blank>t1utils)<S2SV_blank>%s\\\\n\" , VERSION ) ; <S2SV_StartBug> printf ( \"Copyright<S2SV_blank>(C)<S2SV_blank>2000-2010<S2SV_blank>Eddie<S2SV_blank>Kohler<S2SV_blank>et<S2SV_blank>al.\\\\n\\\\\\n<S2SV_blank>This<S2SV_blank>is<S2SV_blank>free<S2SV_blank>software;<S2SV_blank>see<S2SV_blank>the<S2SV_blank>source<S2SV_blank>for<S2SV_blank>copying<S2SV_blank>conditions.\\\\n\\\\\\n<S2SV_blank>There<S2SV_blank>is<S2SV_blank>NO<S2SV_blank>warranty,<S2SV_blank>not<S2SV_blank>even<S2SV_blank>for<S2SV_blank>merchantability<S2SV_blank>or<S2SV_blank>fitness<S2SV_blank>for<S2SV_blank>a\\\\n\\\\\\n<S2SV_blank>particular<S2SV_blank>purpose.\\\\n\" ) ; <S2SV_EndBug> exit ( 0 ) ; break ; case Clp_NotOption : if ( ifp && ofp ) fatal_error ( \"too<S2SV_blank>many<S2SV_blank>arguments\" ) ; else if ( ifp ) goto output_file ; if ( strcmp ( clp -> vstr , \"-\" ) == 0 ) ifp = stdin ; else { ifp_filename = clp -> vstr ; ifp = fopen ( clp -> vstr , \"r\" ) ; if ( ! ifp ) fatal_error ( \"%s:<S2SV_blank>%s\" , clp -> vstr , strerror ( errno ) ) ; } break ; case Clp_Done : goto done ; case Clp_BadOption : short_usage ( ) ; exit ( 1 ) ; break ; } } done : if ( ! ifp ) ifp = stdin ; if ( ! ofp ) ofp = stdout ; # if defined ( _MSDOS ) || defined ( _WIN32 ) _setmode ( _fileno ( ofp ) , _O_BINARY ) ; # endif fr . output_ascii = t1mac_output_ascii ; fr . output_binary = t1mac_output_binary ; fr . output_end = t1mac_output_end ; rfork_f = tmpfile ( ) ; if ( ! rfork_f ) fatal_error ( \"cannot<S2SV_blank>open<S2SV_blank>temorary<S2SV_blank>file:<S2SV_blank>%s\" , strerror ( errno ) ) ; for ( i = 0 ; i < RFORK_HEADERLEN ; i ++ ) putc ( 0 , rfork_f ) ; init_current_post ( ) ; c = getc ( ifp ) ; ungetc ( c , ifp ) ; if ( c == PFB_MARKER ) process_pfb ( ifp , ifp_filename , & fr ) ; else if ( c == '%' ) process_pfa ( ifp , ifp_filename , & fr ) ; else fatal_error ( \"%s<S2SV_blank>does<S2SV_blank>not<S2SV_blank>start<S2SV_blank>with<S2SV_blank>font<S2SV_blank>marker<S2SV_blank>(`%%\\'<S2SV_blank>or<S2SV_blank>0x80)\" , ifp_filename ) ; if ( ifp != stdin ) fclose ( ifp ) ; if ( nrsrc == 0 ) error ( \"no<S2SV_blank>POST<S2SV_blank>resources<S2SV_blank>written<S2SV_blank>--<S2SV_blank>are<S2SV_blank>you<S2SV_blank>sure<S2SV_blank>this<S2SV_blank>was<S2SV_blank>a<S2SV_blank>font?\" ) ; output_new_rsrc ( \"ICN#\" , 256 , 32 , ( const char * ) icon_bw_data , 256 ) ; output_new_rsrc ( \"FREF\" , 256 , 32 , \"LWFN\\\\0\\\\0\\\\0\" , 7 ) ; output_new_rsrc ( \"BNDL\" , 256 , 32 , \"T1UT\\\\0\\\\0\\\\0\\\\1FREF\\\\0\\\\0\\\\0\\\\0\\\\1\\\\0ICN#\\\\0\\\\0\\\\0\\\\0\\\\1\\\\0\" , 28 ) ; output_new_rsrc ( \"icl8\" , 256 , 32 , ( const char * ) icon_8_data , 1024 ) ; output_new_rsrc ( \"icl4\" , 256 , 32 , ( const char * ) icon_4_data , 512 ) ; output_new_rsrc ( \"ics#\" , 256 , 32 , ( const char * ) small_icon_bw_data , 64 ) ; output_new_rsrc ( \"ics8\" , 256 , 32 , ( const char * ) small_icon_8_data , 256 ) ; output_new_rsrc ( \"ics4\" , 256 , 32 , ( const char * ) small_icon_4_data , 128 ) ; output_new_rsrc ( \"T1UT\" , 0 , 0 , \"DConverted<S2SV_blank>by<S2SV_blank>t1mac<S2SV_blank>(t1utils)<S2SV_blank>\\\\251Eddie<S2SV_blank>Kohler<S2SV_blank>http://www.lcdf.org/type/\" , 69 ) ; rfork_len = complete_rfork ( ) ; if ( ! set_font_name && font_name ) { int part = 0 , len = 0 ; char * x , * s ; for ( x = s = font_name ; * s ; s ++ ) <S2SV_StartBug> if ( isupper ( * s ) || isdigit ( * s ) ) { <S2SV_EndBug> * x ++ = * s ; part ++ ; len = 1 ; <S2SV_StartBug> } else if ( islower ( * s ) ) { <S2SV_EndBug> if ( len < ( part <= 1 ? 5 : 3 ) ) * x ++ = * s ; len ++ ; } * x ++ = 0 ; set_font_name = font_name ; } else if ( ! set_font_name ) set_font_name = \"Unknown<S2SV_blank>Font\" ; if ( macbinary ) output_macbinary ( rfork_f , rfork_len , set_font_name , ofp ) ; else if ( raw ) output_raw ( rfork_f , rfork_len , ofp ) ; else if ( applesingle || appledouble ) output_applesingle ( rfork_f , rfork_len , set_font_name , ofp , appledouble ) ; else if ( binhex ) output_binhex ( rfork_f , rfork_len , set_font_name , ofp ) ; else fatal_error ( \"strange<S2SV_blank>output<S2SV_blank>format\" ) ; fclose ( rfork_f ) ; if ( ofp != stdout ) fclose ( ofp ) ; return 0 ; }\n","target":"<S2SV_ModStart> ; printf ( \"Copyright<S2SV_blank>(C)<S2SV_blank>2000-2010<S2SV_blank>Eddie<S2SV_blank>Kohler<S2SV_blank>et<S2SV_blank>al.\\\\n\\\\\\nThis<S2SV_blank>is<S2SV_blank>free<S2SV_blank>software;<S2SV_blank>see<S2SV_blank>the<S2SV_blank>source<S2SV_blank>for<S2SV_blank>copying<S2SV_blank>conditions.\\\\n\\\\\\nThere<S2SV_blank>is<S2SV_blank>NO<S2SV_blank>warranty,<S2SV_blank>not<S2SV_blank>even<S2SV_blank>for<S2SV_blank>merchantability<S2SV_blank>or<S2SV_blank>fitness<S2SV_blank>for<S2SV_blank>a\\\\n\\\\\\nparticular<S2SV_blank>purpose.\\\\n\" <S2SV_ModEnd> ) ; exit <S2SV_ModStart> ( isupper ( ( unsigned char ) <S2SV_ModStart> || isdigit ( ( unsigned char ) <S2SV_ModStart> ( islower ( ( unsigned char )\n","project_and_commit_id":"kohler@t1utils/6b9d1aafcb61a3663c883663eb19ccdbfcde8d33","cve_id":"CVE-2015-3905","original_address":"https://github.com/kohler/t1utils/commit/6b9d1aafcb61a3663c883663eb19ccdbfcde8d33","time":"2015-06-08T14:59Z"},
	{"Unnamed: 0":6626,"cwe_id":"CWE-476","source":"CWE-476 rdpCredssp * credssp_new ( freerdp * instance , rdpTransport * transport , rdpSettings * settings ) { rdpCredssp * credssp ; credssp = ( rdpCredssp * ) malloc ( sizeof ( rdpCredssp ) ) ; ZeroMemory ( credssp , sizeof ( rdpCredssp ) ) ; if ( credssp != NULL ) { HKEY hKey ; LONG status ; DWORD dwType ; DWORD dwSize ; credssp -> instance = instance ; credssp -> settings = settings ; credssp -> server = settings -> ServerMode ; credssp -> transport = transport ; credssp -> send_seq_num = 0 ; credssp -> recv_seq_num = 0 ; ZeroMemory ( & credssp -> negoToken , sizeof ( SecBuffer ) ) ; ZeroMemory ( & credssp -> pubKeyAuth , sizeof ( SecBuffer ) ) ; <S2SV_StartBug> ZeroMemory ( & credssp -> authInfo , sizeof ( SecBuffer ) ) ; <S2SV_EndBug> if ( credssp -> server ) { status = RegOpenKeyEx ( HKEY_LOCAL_MACHINE , _T ( \"Software\\\\\\\\FreeRDP\\\\\\\\Server\" ) , 0 , KEY_READ | KEY_WOW64_64KEY , & hKey ) ; if ( status == ERROR_SUCCESS ) { status = RegQueryValueEx ( hKey , _T ( \"SspiModule\" ) , NULL , & dwType , NULL , & dwSize ) ; if ( status == ERROR_SUCCESS ) { credssp -> SspiModule = ( LPTSTR ) malloc ( dwSize + sizeof ( TCHAR ) ) ; status = RegQueryValueEx ( hKey , _T ( \"SspiModule\" ) , NULL , & dwType , ( BYTE * ) credssp -> SspiModule , & dwSize ) ; if ( status == ERROR_SUCCESS ) { _tprintf ( _T ( \"Using<S2SV_blank>SSPI<S2SV_blank>Module:<S2SV_blank>%s\\\\n\" ) , credssp -> SspiModule ) ; RegCloseKey ( hKey ) ; } } } } } return credssp ; }\n","target":"<S2SV_ModStart> ( SecBuffer ) ) ; SecInvalidateHandle ( & credssp -> context\n","project_and_commit_id":"FreeRDP@FreeRDP/0773bb9303d24473fe1185d85a424dfe159aff53","cve_id":"CVE-2013-4119","original_address":"https://github.com/FreeRDP/FreeRDP/commit/0773bb9303d24473fe1185d85a424dfe159aff53","time":"2016-10-03T21:59Z"},
	{"Unnamed: 0":35,"cwe_id":"CWE-119","source":"CWE-119 static vpx_codec_err_t ctrl_set_scale_mode ( vpx_codec_alg_priv_t * ctx , <S2SV_StartBug> int ctr_id , va_list args ) { <S2SV_EndBug> vpx_scaling_mode_t * const mode = va_arg ( args , vpx_scaling_mode_t * ) ; if ( mode ) { const int res = vp9_set_internal_size ( ctx -> cpi , ( VPX_SCALING ) mode -> h_scaling_mode , ( VPX_SCALING ) mode -> v_scaling_mode ) ; return ( res == 0 ) ? VPX_CODEC_OK : VPX_CODEC_INVALID_PARAM ; } else { return VPX_CODEC_INVALID_PARAM ; } }\n","target":"<S2SV_ModStart> * ctx , <S2SV_ModEnd> va_list args )\n","project_and_commit_id":"external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426","cve_id":"CVE-2016-1621","original_address":"https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426","time":"2016-03-12T21:59Z"},
	{"Unnamed: 0":132,"cwe_id":"CWE-000","source":"CWE-000 struct sk_buff * nf_ct_frag6_gather ( struct sk_buff * skb , u32 user ) { struct sk_buff * clone ; struct net_device * dev = skb -> dev ; struct frag_hdr * fhdr ; struct nf_ct_frag6_queue * fq ; struct ipv6hdr * hdr ; int fhoff , nhoff ; u8 prevhdr ; struct sk_buff * ret_skb = NULL ; if ( ipv6_hdr ( skb ) -> payload_len == 0 ) { pr_debug ( \"payload<S2SV_blank>len<S2SV_blank>=<S2SV_blank>0\\\\n\" ) ; return skb ; } if ( find_prev_fhdr ( skb , & prevhdr , & nhoff , & fhoff ) < 0 ) return skb ; clone = skb_clone ( skb , GFP_ATOMIC ) ; if ( clone == NULL ) { pr_debug ( \"Can\\'t<S2SV_blank>clone<S2SV_blank>skb\\\\n\" ) ; return skb ; } NFCT_FRAG6_CB ( clone ) -> orig = skb ; if ( ! pskb_may_pull ( clone , fhoff + sizeof ( * fhdr ) ) ) { pr_debug ( \"message<S2SV_blank>is<S2SV_blank>too<S2SV_blank>short.\\\\n\" ) ; goto ret_orig ; } skb_set_transport_header ( clone , fhoff ) ; hdr = ipv6_hdr ( clone ) ; fhdr = ( struct frag_hdr * ) skb_transport_header ( clone ) ; <S2SV_StartBug> if ( ! ( fhdr -> frag_off & htons ( 0xFFF9 ) ) ) { <S2SV_EndBug> pr_debug ( \"Invalid<S2SV_blank>fragment<S2SV_blank>offset\\\\n\" ) ; goto ret_orig ; } if ( atomic_read ( & nf_init_frags . mem ) > nf_init_frags . high_thresh ) nf_ct_frag6_evictor ( ) ; fq = fq_find ( fhdr -> identification , user , & hdr -> saddr , & hdr -> daddr ) ; if ( fq == NULL ) { pr_debug ( \"Can\\'t<S2SV_blank>find<S2SV_blank>and<S2SV_blank>can\\'t<S2SV_blank>create<S2SV_blank>new<S2SV_blank>queue\\\\n\" ) ; goto ret_orig ; } spin_lock_bh ( & fq -> q . lock ) ; if ( nf_ct_frag6_queue ( fq , clone , fhdr , nhoff ) < 0 ) { spin_unlock_bh ( & fq -> q . lock ) ; pr_debug ( \"Can\\'t<S2SV_blank>insert<S2SV_blank>skb<S2SV_blank>to<S2SV_blank>queue\\\\n\" ) ; fq_put ( fq ) ; goto ret_orig ; } if ( fq -> q . last_in == ( INET_FRAG_FIRST_IN | INET_FRAG_LAST_IN ) && fq -> q . meat == fq -> q . len ) { ret_skb = nf_ct_frag6_reasm ( fq , dev ) ; if ( ret_skb == NULL ) pr_debug ( \"Can\\'t<S2SV_blank>reassemble<S2SV_blank>fragmented<S2SV_blank>packets\\\\n\" ) ; } spin_unlock_bh ( & fq -> q . lock ) ; fq_put ( fq ) ; return ret_skb ; ret_orig : kfree_skb ( clone ) ; return skb ; }\n","target":"<S2SV_ModStart> ; if ( <S2SV_ModEnd> atomic_read ( &\n","project_and_commit_id":"torvalds@linux/9e2dcf72023d1447f09c47d77c99b0c49659e5ce","cve_id":"CVE-2012-2744","original_address":"https://github.com/torvalds/linux/commit/9e2dcf72023d1447f09c47d77c99b0c49659e5ce","time":"2012-08-09T10:29Z"},
	{"Unnamed: 0":3757,"cwe_id":"CWE-200","source":"CWE-200 int tpm_open ( struct inode * inode , struct file * file ) { int minor = iminor ( inode ) ; struct tpm_chip * chip = NULL , * pos ; rcu_read_lock ( ) ; list_for_each_entry_rcu ( pos , & tpm_chip_list , list ) { if ( pos -> vendor . miscdev . minor == minor ) { chip = pos ; get_device ( chip -> dev ) ; break ; } } rcu_read_unlock ( ) ; if ( ! chip ) return - ENODEV ; if ( test_and_set_bit ( 0 , & chip -> is_open ) ) { dev_dbg ( chip -> dev , \"Another<S2SV_blank>process<S2SV_blank>owns<S2SV_blank>this<S2SV_blank>TPM\\\\n\" ) ; put_device ( chip -> dev ) ; return - EBUSY ; } <S2SV_StartBug> chip -> data_buffer = kmalloc ( TPM_BUFSIZE * sizeof ( u8 ) , GFP_KERNEL ) ; <S2SV_EndBug> if ( chip -> data_buffer == NULL ) { clear_bit ( 0 , & chip -> is_open ) ; put_device ( chip -> dev ) ; return - ENOMEM ; } atomic_set ( & chip -> data_pending , 0 ) ; file -> private_data = chip ; return 0 ; }\n","target":"<S2SV_ModStart> -> data_buffer = kzalloc ( TPM_BUFSIZE <S2SV_ModEnd> , GFP_KERNEL )\n","project_and_commit_id":"torvalds@linux/1309d7afbed112f0e8e90be9af975550caa0076b","cve_id":"CVE-2011-1160","original_address":"https://github.com/torvalds/linux/commit/1309d7afbed112f0e8e90be9af975550caa0076b","time":"2012-06-21T23:55Z"},
	{"Unnamed: 0":4935,"cwe_id":"CWE-415","source":"CWE-415 void * gdImageGifPtr ( gdImagePtr im , int * size ) { void * rv ; gdIOCtx * out = gdNewDynamicCtx ( 2048 , NULL ) ; <S2SV_StartBug> gdImageGifCtx ( im , out ) ; <S2SV_EndBug> <S2SV_StartBug> rv = gdDPExtractData ( out , size ) ; <S2SV_EndBug> out -> gd_free ( out ) ; return rv ; }\n","target":"<S2SV_ModStart> NULL ) ; if ( ! _gdImageGifCtx <S2SV_ModEnd> ( im , <S2SV_ModStart> , out ) ) { <S2SV_ModEnd> rv = gdDPExtractData <S2SV_ModStart> size ) ; } else { rv = NULL ; }\n","project_and_commit_id":"php@php-src/089f7c0bc28d399b0420aa6ef058e4c1c120b2ae","cve_id":"CVE-2019-6978","original_address":"https://github.com/php/php-src/commit/089f7c0bc28d399b0420aa6ef058e4c1c120b2ae","time":"2019-01-28T08:29Z"},
	{"Unnamed: 0":3318,"cwe_id":"CWE-119","source":"CWE-119 static int fpAcc ( TIFF * tif , uint8 * cp0 , tmsize_t cc ) { tmsize_t stride = PredictorState ( tif ) -> stride ; uint32 bps = tif -> tif_dir . td_bitspersample / 8 ; tmsize_t wc = cc / bps ; tmsize_t count = cc ; uint8 * cp = ( uint8 * ) cp0 ; <S2SV_StartBug> uint8 * tmp = ( uint8 * ) _TIFFmalloc ( cc ) ; <S2SV_EndBug> if ( cc % ( bps * stride ) != 0 ) { TIFFErrorExt ( tif -> tif_clientdata , \"fpAcc\" , \"%s\" , \"cc%(bps*stride))!=0\" ) ; return 0 ; } <S2SV_StartBug> if ( ! tmp ) <S2SV_EndBug> return 0 ; while ( count > stride ) { REPEAT4 ( stride , cp [ stride ] = ( unsigned char ) ( ( cp [ stride ] + cp [ 0 ] ) & 0xff ) ; cp ++ ) count -= stride ; } _TIFFmemcpy ( tmp , cp0 , cc ) ; cp = ( uint8 * ) cp0 ; for ( count = 0 ; count < wc ; count ++ ) { uint32 byte ; for ( byte = 0 ; byte < bps ; byte ++ ) { # if WORDS_BIGENDIAN cp [ bps * count + byte ] = tmp [ byte * wc + count ] ; # else cp [ bps * count + byte ] = tmp [ ( bps - byte - 1 ) * wc + count ] ; # endif } } _TIFFfree ( tmp ) ; return 1 ; }\n","target":"<S2SV_ModStart> uint8 * tmp <S2SV_ModEnd> ; if ( <S2SV_ModStart> 0 ; } tmp = ( uint8 * ) _TIFFmalloc ( cc ) ;\n","project_and_commit_id":"vadz@libtiff/6a984bf7905c6621281588431f384e79d11a2e33","cve_id":"CVE-2016-9535","original_address":"https://github.com/vadz/libtiff/commit/6a984bf7905c6621281588431f384e79d11a2e33","time":"2016-11-22T19:59Z"},
	{"Unnamed: 0":4044,"cwe_id":"CWE-476","source":"CWE-476 static bool CopyKeyAliasesToKeymap ( struct xkb_keymap * keymap , KeyNamesInfo * info ) { AliasInfo * alias ; unsigned i , num_key_aliases ; struct xkb_key_alias * key_aliases ; num_key_aliases = 0 ; darray_foreach ( alias , info -> aliases ) { if ( ! XkbKeyByName ( keymap , alias -> real , false ) ) { log_vrb ( info -> ctx , 5 , \"Attempt<S2SV_blank>to<S2SV_blank>alias<S2SV_blank>%s<S2SV_blank>to<S2SV_blank>non-existent<S2SV_blank>key<S2SV_blank>%s;<S2SV_blank>Ignored\\\\n\" , KeyNameText ( info -> ctx , alias -> alias ) , KeyNameText ( info -> ctx , alias -> real ) ) ; alias -> real = XKB_ATOM_NONE ; continue ; } if ( XkbKeyByName ( keymap , alias -> alias , false ) ) { log_vrb ( info -> ctx , 5 , \"Attempt<S2SV_blank>to<S2SV_blank>create<S2SV_blank>alias<S2SV_blank>with<S2SV_blank>the<S2SV_blank>name<S2SV_blank>of<S2SV_blank>a<S2SV_blank>real<S2SV_blank>key;<S2SV_blank>\" \"Alias<S2SV_blank>\\\\\"%s<S2SV_blank>=<S2SV_blank>%s\\\\\"<S2SV_blank>ignored\\\\n\" , KeyNameText ( info -> ctx , alias -> alias ) , KeyNameText ( info -> ctx , alias -> real ) ) ; alias -> real = XKB_ATOM_NONE ; continue ; } num_key_aliases ++ ; } key_aliases = NULL ; if ( num_key_aliases > 0 ) { key_aliases = calloc ( num_key_aliases , sizeof ( * key_aliases ) ) ; if ( ! key_aliases ) return false ; <S2SV_StartBug> } <S2SV_EndBug> i = 0 ; darray_foreach ( alias , info -> aliases ) { if ( alias -> real != XKB_ATOM_NONE ) { key_aliases [ i ] . alias = alias -> alias ; key_aliases [ i ] . real = alias -> real ; i ++ ; } } <S2SV_StartBug> keymap -> num_key_aliases = num_key_aliases ; <S2SV_EndBug> keymap -> key_aliases = key_aliases ; return true ; }\n","target":"<S2SV_ModStart> return false ; <S2SV_ModEnd> i = 0 <S2SV_ModStart> ; } } }\n","project_and_commit_id":"xkbcommon@libxkbcommon/badb428e63387140720f22486b3acbd3d738859f","cve_id":"CVE-2018-15858","original_address":"https://github.com/xkbcommon/libxkbcommon/commit/badb428e63387140720f22486b3acbd3d738859f","time":"2018-08-25T21:29Z"},
	{"Unnamed: 0":5915,"cwe_id":"CWE-119","source":"CWE-119 static long gfs2_fallocate ( struct file * file , int mode , loff_t offset , loff_t len ) { struct inode * inode = file -> f_path . dentry -> d_inode ; struct gfs2_sbd * sdp = GFS2_SB ( inode ) ; struct gfs2_inode * ip = GFS2_I ( inode ) ; unsigned int data_blocks = 0 , ind_blocks = 0 , rblocks ; loff_t bytes , max_bytes ; struct gfs2_alloc * al ; int error ; loff_t bsize_mask = ~ ( ( loff_t ) sdp -> sd_sb . sb_bsize - 1 ) ; loff_t next = ( offset + len - 1 ) >> sdp -> sd_sb . sb_bsize_shift ; <S2SV_StartBug> next = ( next + 1 ) << sdp -> sd_sb . sb_bsize_shift ; <S2SV_EndBug> if ( mode & ~ FALLOC_FL_KEEP_SIZE ) return - EOPNOTSUPP ; offset &= bsize_mask ; len = next - offset ; bytes = sdp -> sd_max_rg_data * sdp -> sd_sb . sb_bsize / 2 ; if ( ! bytes ) bytes = UINT_MAX ; bytes &= bsize_mask ; if ( bytes == 0 ) bytes = sdp -> sd_sb . sb_bsize ; gfs2_holder_init ( ip -> i_gl , LM_ST_EXCLUSIVE , 0 , & ip -> i_gh ) ; error = gfs2_glock_nq ( & ip -> i_gh ) ; if ( unlikely ( error ) ) goto out_uninit ; if ( ! gfs2_write_alloc_required ( ip , offset , len ) ) goto out_unlock ; while ( len > 0 ) { if ( len < bytes ) bytes = len ; al = gfs2_alloc_get ( ip ) ; if ( ! al ) { error = - ENOMEM ; goto out_unlock ; } error = gfs2_quota_lock_check ( ip ) ; if ( error ) goto out_alloc_put ; retry : gfs2_write_calc_reserv ( ip , bytes , & data_blocks , & ind_blocks ) ; al -> al_requested = data_blocks + ind_blocks ; error = gfs2_inplace_reserve ( ip ) ; if ( error ) { if ( error == - ENOSPC && bytes > sdp -> sd_sb . sb_bsize ) { bytes >>= 1 ; bytes &= bsize_mask ; if ( bytes == 0 ) bytes = sdp -> sd_sb . sb_bsize ; goto retry ; } goto out_qunlock ; } max_bytes = bytes ; <S2SV_StartBug> calc_max_reserv ( ip , len , & max_bytes , & data_blocks , & ind_blocks ) ; <S2SV_EndBug> al -> al_requested = data_blocks + ind_blocks ; rblocks = RES_DINODE + ind_blocks + RES_STATFS + RES_QUOTA + RES_RG_HDR + gfs2_rg_blocks ( ip ) ; if ( gfs2_is_jdata ( ip ) ) rblocks += data_blocks ? data_blocks : 1 ; error = gfs2_trans_begin ( sdp , rblocks , PAGE_CACHE_SIZE / sdp -> sd_sb . sb_bsize ) ; if ( error ) goto out_trans_fail ; error = fallocate_chunk ( inode , offset , max_bytes , mode ) ; gfs2_trans_end ( sdp ) ; if ( error ) goto out_trans_fail ; len -= max_bytes ; offset += max_bytes ; gfs2_inplace_release ( ip ) ; gfs2_quota_unlock ( ip ) ; gfs2_alloc_put ( ip ) ; } goto out_unlock ; out_trans_fail : gfs2_inplace_release ( ip ) ; out_qunlock : gfs2_quota_unlock ( ip ) ; out_alloc_put : gfs2_alloc_put ( ip ) ; out_unlock : gfs2_glock_dq ( & ip -> i_gh ) ; out_uninit : gfs2_holder_uninit ( & ip -> i_gh ) ; return error ; }\n","target":"<S2SV_ModStart> . sb_bsize_shift ; loff_t max_chunk_size = UINT_MAX & bsize_mask ; <S2SV_ModStart> ( ip , ( len > max_chunk_size ) ? max_chunk_size : len , <S2SV_ModEnd> & max_bytes ,\n","project_and_commit_id":"torvalds@linux/64dd153c83743af81f20924c6343652d731eeecb","cve_id":"CVE-2011-4098","original_address":"https://github.com/torvalds/linux/commit/64dd153c83743af81f20924c6343652d731eeecb","time":"2013-06-08T13:05Z"},
	{"Unnamed: 0":6472,"cwe_id":"CWE-415","source":"CWE-415 static int amd_gpio_probe ( struct platform_device * pdev ) { int ret = 0 ; int irq_base ; struct resource * res ; struct amd_gpio * gpio_dev ; gpio_dev = devm_kzalloc ( & pdev -> dev , sizeof ( struct amd_gpio ) , GFP_KERNEL ) ; if ( ! gpio_dev ) return - ENOMEM ; spin_lock_init ( & gpio_dev -> lock ) ; res = platform_get_resource ( pdev , IORESOURCE_MEM , 0 ) ; if ( ! res ) { dev_err ( & pdev -> dev , \"Failed<S2SV_blank>to<S2SV_blank>get<S2SV_blank>gpio<S2SV_blank>io<S2SV_blank>resource.\\\\n\" ) ; return - EINVAL ; } gpio_dev -> base = devm_ioremap_nocache ( & pdev -> dev , res -> start , resource_size ( res ) ) ; if ( ! gpio_dev -> base ) return - ENOMEM ; irq_base = platform_get_irq ( pdev , 0 ) ; if ( irq_base < 0 ) { dev_err ( & pdev -> dev , \"Failed<S2SV_blank>to<S2SV_blank>get<S2SV_blank>gpio<S2SV_blank>IRQ.\\\\n\" ) ; return - EINVAL ; } gpio_dev -> pdev = pdev ; gpio_dev -> gc . direction_input = amd_gpio_direction_input ; gpio_dev -> gc . direction_output = amd_gpio_direction_output ; gpio_dev -> gc . get = amd_gpio_get_value ; gpio_dev -> gc . set = amd_gpio_set_value ; gpio_dev -> gc . set_debounce = amd_gpio_set_debounce ; gpio_dev -> gc . dbg_show = amd_gpio_dbg_show ; gpio_dev -> gc . base = 0 ; gpio_dev -> gc . label = pdev -> name ; gpio_dev -> gc . owner = THIS_MODULE ; gpio_dev -> gc . parent = & pdev -> dev ; gpio_dev -> gc . ngpio = TOTAL_NUMBER_OF_PINS ; # if defined ( CONFIG_OF_GPIO ) gpio_dev -> gc . of_node = pdev -> dev . of_node ; # endif gpio_dev -> groups = kerncz_groups ; gpio_dev -> ngroups = ARRAY_SIZE ( kerncz_groups ) ; amd_pinctrl_desc . name = dev_name ( & pdev -> dev ) ; <S2SV_StartBug> gpio_dev -> pctrl = pinctrl_register ( & amd_pinctrl_desc , <S2SV_EndBug> <S2SV_StartBug> & pdev -> dev , gpio_dev ) ; <S2SV_EndBug> if ( IS_ERR ( gpio_dev -> pctrl ) ) { dev_err ( & pdev -> dev , \"Couldn\\'t<S2SV_blank>register<S2SV_blank>pinctrl<S2SV_blank>driver\\\\n\" ) ; return PTR_ERR ( gpio_dev -> pctrl ) ; } ret = gpiochip_add_data ( & gpio_dev -> gc , gpio_dev ) ; if ( ret ) <S2SV_StartBug> goto out1 ; <S2SV_EndBug> ret = gpiochip_add_pin_range ( & gpio_dev -> gc , dev_name ( & pdev -> dev ) , 0 , 0 , TOTAL_NUMBER_OF_PINS ) ; if ( ret ) { dev_err ( & pdev -> dev , \"Failed<S2SV_blank>to<S2SV_blank>add<S2SV_blank>pin<S2SV_blank>range\\\\n\" ) ; goto out2 ; } ret = gpiochip_irqchip_add ( & gpio_dev -> gc , & amd_gpio_irqchip , 0 , handle_simple_irq , IRQ_TYPE_NONE ) ; if ( ret ) { dev_err ( & pdev -> dev , \"could<S2SV_blank>not<S2SV_blank>add<S2SV_blank>irqchip\\\\n\" ) ; ret = - ENODEV ; goto out2 ; } gpiochip_set_chained_irqchip ( & gpio_dev -> gc , & amd_gpio_irqchip , irq_base , amd_gpio_irq_handler ) ; platform_set_drvdata ( pdev , gpio_dev ) ; dev_dbg ( & pdev -> dev , \"amd<S2SV_blank>gpio<S2SV_blank>driver<S2SV_blank>loaded\\\\n\" ) ; return ret ; out2 : gpiochip_remove ( & gpio_dev -> gc ) ; <S2SV_StartBug> out1 : <S2SV_EndBug> pinctrl_unregister ( gpio_dev -> pctrl ) ; return ret ; }\n","target":"<S2SV_ModStart> -> pctrl = devm_pinctrl_register ( & pdev -> dev , <S2SV_ModEnd> & amd_pinctrl_desc , <S2SV_ModStart> & amd_pinctrl_desc , <S2SV_ModEnd> gpio_dev ) ; <S2SV_ModStart> ( ret ) return ret <S2SV_ModEnd> ; ret = <S2SV_ModStart> gc ) ; <S2SV_ModEnd> return ret ;\n","project_and_commit_id":"torvalds@linux/251e22abde21833b3d29577e4d8c7aaccd650eee","cve_id":"CVE-2017-18174","original_address":"https://github.com/torvalds/linux/commit/251e22abde21833b3d29577e4d8c7aaccd650eee","time":"2018-02-11T18:29Z"},
	{"Unnamed: 0":506,"cwe_id":"CWE-190","source":"CWE-190 static int futex_requeue ( u32 __user * uaddr1 , unsigned int flags , u32 __user * uaddr2 , int nr_wake , int nr_requeue , u32 * cmpval , int requeue_pi ) { union futex_key key1 = FUTEX_KEY_INIT , key2 = FUTEX_KEY_INIT ; int drop_count = 0 , task_count = 0 , ret ; struct futex_pi_state * pi_state = NULL ; struct futex_hash_bucket * hb1 , * hb2 ; struct futex_q * this , * next ; <S2SV_StartBug> DEFINE_WAKE_Q ( wake_q ) ; <S2SV_EndBug> if ( ! IS_ENABLED ( CONFIG_FUTEX_PI ) && requeue_pi ) return - ENOSYS ; if ( requeue_pi ) { if ( uaddr1 == uaddr2 ) return - EINVAL ; if ( refill_pi_state_cache ( ) ) return - ENOMEM ; if ( nr_wake != 1 ) return - EINVAL ; } retry : ret = get_futex_key ( uaddr1 , flags & FLAGS_SHARED , & key1 , VERIFY_READ ) ; if ( unlikely ( ret != 0 ) ) goto out ; ret = get_futex_key ( uaddr2 , flags & FLAGS_SHARED , & key2 , requeue_pi ? VERIFY_WRITE : VERIFY_READ ) ; if ( unlikely ( ret != 0 ) ) goto out_put_key1 ; if ( requeue_pi && match_futex ( & key1 , & key2 ) ) { ret = - EINVAL ; goto out_put_keys ; } hb1 = hash_futex ( & key1 ) ; hb2 = hash_futex ( & key2 ) ; retry_private : hb_waiters_inc ( hb2 ) ; double_lock_hb ( hb1 , hb2 ) ; if ( likely ( cmpval != NULL ) ) { u32 curval ; ret = get_futex_value_locked ( & curval , uaddr1 ) ; if ( unlikely ( ret ) ) { double_unlock_hb ( hb1 , hb2 ) ; hb_waiters_dec ( hb2 ) ; ret = get_user ( curval , uaddr1 ) ; if ( ret ) goto out_put_keys ; if ( ! ( flags & FLAGS_SHARED ) ) goto retry_private ; put_futex_key ( & key2 ) ; put_futex_key ( & key1 ) ; goto retry ; } if ( curval != * cmpval ) { ret = - EAGAIN ; goto out_unlock ; } } if ( requeue_pi && ( task_count - nr_wake < nr_requeue ) ) { ret = futex_proxy_trylock_atomic ( uaddr2 , hb1 , hb2 , & key1 , & key2 , & pi_state , nr_requeue ) ; if ( ret > 0 ) { WARN_ON ( pi_state ) ; drop_count ++ ; task_count ++ ; ret = lookup_pi_state ( uaddr2 , ret , hb2 , & key2 , & pi_state ) ; } switch ( ret ) { case 0 : break ; case - EFAULT : double_unlock_hb ( hb1 , hb2 ) ; hb_waiters_dec ( hb2 ) ; put_futex_key ( & key2 ) ; put_futex_key ( & key1 ) ; ret = fault_in_user_writeable ( uaddr2 ) ; if ( ! ret ) goto retry ; goto out ; case - EAGAIN : double_unlock_hb ( hb1 , hb2 ) ; hb_waiters_dec ( hb2 ) ; put_futex_key ( & key2 ) ; put_futex_key ( & key1 ) ; cond_resched ( ) ; goto retry ; default : goto out_unlock ; } } plist_for_each_entry_safe ( this , next , & hb1 -> chain , list ) { if ( task_count - nr_wake >= nr_requeue ) break ; if ( ! match_futex ( & this -> key , & key1 ) ) continue ; if ( ( requeue_pi && ! this -> rt_waiter ) || ( ! requeue_pi && this -> rt_waiter ) || this -> pi_state ) { ret = - EINVAL ; break ; } if ( ++ task_count <= nr_wake && ! requeue_pi ) { mark_wake_futex ( & wake_q , this ) ; continue ; } if ( requeue_pi && ! match_futex ( this -> requeue_pi_key , & key2 ) ) { ret = - EINVAL ; break ; } if ( requeue_pi ) { get_pi_state ( pi_state ) ; this -> pi_state = pi_state ; ret = rt_mutex_start_proxy_lock ( & pi_state -> pi_mutex , this -> rt_waiter , this -> task ) ; if ( ret == 1 ) { requeue_pi_wake_futex ( this , & key2 , hb2 ) ; drop_count ++ ; continue ; } else if ( ret ) { this -> pi_state = NULL ; put_pi_state ( pi_state ) ; break ; } } requeue_futex ( this , hb1 , hb2 , & key2 ) ; drop_count ++ ; } put_pi_state ( pi_state ) ; out_unlock : double_unlock_hb ( hb1 , hb2 ) ; wake_up_q ( & wake_q ) ; hb_waiters_dec ( hb2 ) ; while ( -- drop_count >= 0 ) drop_futex_key_refs ( & key1 ) ; out_put_keys : put_futex_key ( & key2 ) ; out_put_key1 : put_futex_key ( & key1 ) ; out : return ret ? ret : task_count ; }\n","target":"<S2SV_ModStart> ( wake_q ) ; if ( nr_wake < 0 || nr_requeue < 0 ) return - EINVAL\n","project_and_commit_id":"torvalds@linux/fbe0e839d1e22d88810f3ee3e2f1479be4c0aa4a","cve_id":"CVE-2018-6927","original_address":"https://github.com/torvalds/linux/commit/fbe0e839d1e22d88810f3ee3e2f1479be4c0aa4a","time":"2018-02-12T19:29Z"},
	{"Unnamed: 0":418,"cwe_id":"CWE-119","source":"CWE-119 static Image * ReadAAIImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { Image * image ; MagickBooleanType status ; register ssize_t x ; register PixelPacket * q ; register unsigned char * p ; size_t height , length , width ; ssize_t count , y ; unsigned char * pixels ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickSignature ) ; if ( image_info -> debug != MagickFalse ) ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , \"%s\" , image_info -> filename ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickSignature ) ; image = AcquireImage ( image_info ) ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } width = ReadBlobLSBLong ( image ) ; height = ReadBlobLSBLong ( image ) ; if ( EOFBlob ( image ) != MagickFalse ) ThrowReaderException ( CorruptImageError , \"ImproperImageHeader\" ) ; if ( ( width == 0UL ) || ( height == 0UL ) ) ThrowReaderException ( CorruptImageError , \"ImproperImageHeader\" ) ; do { image -> columns = width ; image -> rows = height ; image -> depth = 8 ; if ( ( image_info -> ping != MagickFalse ) && ( image_info -> number_scenes != 0 ) ) if ( image -> scene >= ( image_info -> scene + image_info -> number_scenes - 1 ) ) break ; <S2SV_StartBug> pixels = ( unsigned char * ) AcquireQuantumMemory ( image -> columns , <S2SV_EndBug> 4 * sizeof ( * pixels ) ) ; if ( pixels == ( unsigned char * ) NULL ) ThrowReaderException ( ResourceLimitError , \"MemoryAllocationFailed\" ) ; length = ( size_t ) 4 * image -> columns ; for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { count = ReadBlob ( image , length , pixels ) ; if ( ( size_t ) count != length ) ThrowReaderException ( CorruptImageError , \"UnableToReadImageData\" ) ; p = pixels ; q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( PixelPacket * ) NULL ) break ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { SetPixelBlue ( q , ScaleCharToQuantum ( * p ++ ) ) ; SetPixelGreen ( q , ScaleCharToQuantum ( * p ++ ) ) ; SetPixelRed ( q , ScaleCharToQuantum ( * p ++ ) ) ; if ( * p == 254 ) * p = 255 ; SetPixelAlpha ( q , ScaleCharToQuantum ( * p ++ ) ) ; if ( q -> opacity != OpaqueOpacity ) image -> matte = MagickTrue ; q ++ ; } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ; if ( status == MagickFalse ) break ; } } pixels = ( unsigned char * ) RelinquishMagickMemory ( pixels ) ; if ( EOFBlob ( image ) != MagickFalse ) { ThrowFileException ( exception , CorruptImageError , \"UnexpectedEndOfFile\" , image -> filename ) ; break ; } if ( image_info -> number_scenes != 0 ) if ( image -> scene >= ( image_info -> scene + image_info -> number_scenes - 1 ) ) break ; width = ReadBlobLSBLong ( image ) ; height = ReadBlobLSBLong ( image ) ; if ( ( width != 0UL ) && ( height != 0UL ) ) { AcquireNextImage ( image_info , image ) ; if ( GetNextImageInList ( image ) == ( Image * ) NULL ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } image = SyncNextImageInList ( image ) ; status = SetImageProgress ( image , LoadImagesTag , TellBlob ( image ) , GetBlobSize ( image ) ) ; if ( status == MagickFalse ) break ; } } while ( ( width != 0UL ) && ( height != 0UL ) ) ; ( void ) CloseBlob ( image ) ; return ( GetFirstImageInList ( image ) ) ; }\n","target":"<S2SV_ModStart> ) break ; status = SetImageExtent ( image , image -> columns , image -> rows ) ; if ( status == MagickFalse ) { InheritException ( exception , & image -> exception ) ; return ( DestroyImageList ( image ) ) ; }\n","project_and_commit_id":"ImageMagick@ImageMagick/f6e9d0d9955e85bdd7540b251cd50d598dacc5e6","cve_id":"CVE-2016-10066","original_address":"https://github.com/ImageMagick/ImageMagick/commit/f6e9d0d9955e85bdd7540b251cd50d598dacc5e6","time":"2017-03-03T17:59Z"},
	{"Unnamed: 0":4515,"cwe_id":"CWE-20","source":"CWE-20 static int create_filesystem_object ( struct archive_write_disk * a ) { const char * linkname ; mode_t final_mode , mode ; int r ; <S2SV_StartBug> linkname = archive_entry_hardlink ( a -> entry ) ; <S2SV_EndBug> if ( linkname != NULL ) { # if ! HAVE_LINK return ( EPERM ) ; <S2SV_StartBug> # else <S2SV_EndBug> r = link ( linkname , a -> name ) ? errno : 0 ; if ( r == 0 && a -> filesize <= 0 ) { a -> todo = 0 ; a -> deferred = 0 ; } else if ( r == 0 && a -> filesize > 0 ) { a -> fd = open ( a -> name , O_WRONLY | O_TRUNC | O_BINARY | O_CLOEXEC ) ; __archive_ensure_cloexec_flag ( a -> fd ) ; if ( a -> fd < 0 ) r = errno ; } return ( r ) ; # endif } linkname = archive_entry_symlink ( a -> entry ) ; if ( linkname != NULL ) { # if HAVE_SYMLINK return symlink ( linkname , a -> name ) ? errno : 0 ; # else return ( EPERM ) ; # endif } final_mode = a -> mode & 07777 ; mode = final_mode & 0777 & ~ a -> user_umask ; switch ( a -> mode & AE_IFMT ) { default : case AE_IFREG : a -> fd = open ( a -> name , O_WRONLY | O_CREAT | O_EXCL | O_BINARY | O_CLOEXEC , mode ) ; __archive_ensure_cloexec_flag ( a -> fd ) ; r = ( a -> fd < 0 ) ; break ; case AE_IFCHR : # ifdef HAVE_MKNOD r = mknod ( a -> name , mode | S_IFCHR , archive_entry_rdev ( a -> entry ) ) ; break ; # else return ( EINVAL ) ; # endif case AE_IFBLK : # ifdef HAVE_MKNOD r = mknod ( a -> name , mode | S_IFBLK , archive_entry_rdev ( a -> entry ) ) ; break ; # else return ( EINVAL ) ; # endif case AE_IFDIR : mode = ( mode | MINIMUM_DIR_MODE ) & MAXIMUM_DIR_MODE ; r = mkdir ( a -> name , mode ) ; if ( r == 0 ) { a -> deferred |= ( a -> todo & TODO_TIMES ) ; a -> todo &= ~ TODO_TIMES ; if ( ( mode != final_mode ) || ( a -> flags & ARCHIVE_EXTRACT_PERM ) ) a -> deferred |= ( a -> todo & TODO_MODE ) ; a -> todo &= ~ TODO_MODE ; } break ; case AE_IFIFO : # ifdef HAVE_MKFIFO r = mkfifo ( a -> name , mode ) ; break ; # else return ( EINVAL ) ; # endif } if ( r ) return ( errno ) ; if ( mode == final_mode ) a -> todo &= ~ TODO_MODE ; return ( 0 ) ; }\n","target":"<S2SV_ModStart> int r ; char * linkname_copy ; struct archive_string error_string ; int error_number ; <S2SV_ModStart> ; # else archive_string_init ( & error_string ) ; linkname_copy = strdup ( linkname ) ; if ( linkname_copy == NULL ) { return ( EPERM ) ; } r = cleanup_pathname_fsobj ( linkname_copy , & error_number , & error_string , a -> flags ) ; if ( r != ARCHIVE_OK ) { archive_set_error ( & a -> archive , error_number , \"%s\" , error_string . s ) ; free ( linkname_copy ) ; return ( EPERM ) ; } r = check_symlinks_fsobj ( linkname_copy , & error_number , & error_string , a -> flags ) ; if ( r != ARCHIVE_OK ) { archive_set_error ( & a -> archive , error_number , \"%s\" , error_string . s ) ; free ( linkname_copy ) ; return ( EPERM ) ; } free ( linkname_copy ) ;\n","project_and_commit_id":"libarchive@libarchive/dfd6b54ce33960e420fb206d8872fb759b577ad9","cve_id":"CVE-2016-5418","original_address":"https://github.com/libarchive/libarchive/commit/dfd6b54ce33960e420fb206d8872fb759b577ad9","time":"2016-09-21T14:25Z"},
	{"Unnamed: 0":4387,"cwe_id":"CWE-20","source":"CWE-20 int tls1_change_cipher_state ( SSL * s , int which ) { unsigned char * p , * mac_secret ; unsigned char tmp1 [ EVP_MAX_KEY_LENGTH ] ; unsigned char tmp2 [ EVP_MAX_KEY_LENGTH ] ; unsigned char iv1 [ EVP_MAX_IV_LENGTH * 2 ] ; unsigned char iv2 [ EVP_MAX_IV_LENGTH * 2 ] ; unsigned char * ms , * key , * iv ; EVP_CIPHER_CTX * dd ; const EVP_CIPHER * c ; # ifndef OPENSSL_NO_COMP const SSL_COMP * comp ; # endif const EVP_MD * m ; int mac_type ; int * mac_secret_size ; EVP_MD_CTX * mac_ctx ; EVP_PKEY * mac_key ; int n , i , j , k , cl ; int reuse_dd = 0 ; c = s -> s3 -> tmp . new_sym_enc ; m = s -> s3 -> tmp . new_hash ; mac_type = s -> s3 -> tmp . new_mac_pkey_type ; # ifndef OPENSSL_NO_COMP comp = s -> s3 -> tmp . new_compression ; # endif if ( which & SSL3_CC_READ ) { <S2SV_StartBug> if ( s -> s3 -> tmp . new_cipher -> algorithm2 & TLS1_STREAM_MAC ) <S2SV_EndBug> s -> mac_flags |= SSL_MAC_FLAG_READ_MAC_STREAM ; else s -> mac_flags &= ~ SSL_MAC_FLAG_READ_MAC_STREAM ; if ( s -> enc_read_ctx != NULL ) reuse_dd = 1 ; else if ( ( s -> enc_read_ctx = EVP_CIPHER_CTX_new ( ) ) == NULL ) goto err ; else EVP_CIPHER_CTX_reset ( s -> enc_read_ctx ) ; dd = s -> enc_read_ctx ; mac_ctx = ssl_replace_hash ( & s -> read_hash , NULL ) ; if ( mac_ctx == NULL ) goto err ; # ifndef OPENSSL_NO_COMP COMP_CTX_free ( s -> expand ) ; s -> expand = NULL ; if ( comp != NULL ) { s -> expand = COMP_CTX_new ( comp -> method ) ; if ( s -> expand == NULL ) { SSLerr ( SSL_F_TLS1_CHANGE_CIPHER_STATE , SSL_R_COMPRESSION_LIBRARY_ERROR ) ; goto err2 ; } } # endif if ( ! SSL_IS_DTLS ( s ) ) RECORD_LAYER_reset_read_sequence ( & s -> rlayer ) ; mac_secret = & ( s -> s3 -> read_mac_secret [ 0 ] ) ; mac_secret_size = & ( s -> s3 -> read_mac_secret_size ) ; <S2SV_StartBug> } else { <S2SV_EndBug> if ( s -> s3 -> tmp . new_cipher -> algorithm2 & TLS1_STREAM_MAC ) s -> mac_flags |= SSL_MAC_FLAG_WRITE_MAC_STREAM ; else s -> mac_flags &= ~ SSL_MAC_FLAG_WRITE_MAC_STREAM ; if ( s -> enc_write_ctx != NULL && ! SSL_IS_DTLS ( s ) ) reuse_dd = 1 ; else if ( ( s -> enc_write_ctx = EVP_CIPHER_CTX_new ( ) ) == NULL ) goto err ; dd = s -> enc_write_ctx ; if ( SSL_IS_DTLS ( s ) ) { mac_ctx = EVP_MD_CTX_new ( ) ; if ( mac_ctx == NULL ) goto err ; s -> write_hash = mac_ctx ; } else { mac_ctx = ssl_replace_hash ( & s -> write_hash , NULL ) ; if ( mac_ctx == NULL ) goto err ; } # ifndef OPENSSL_NO_COMP COMP_CTX_free ( s -> compress ) ; s -> compress = NULL ; if ( comp != NULL ) { s -> compress = COMP_CTX_new ( comp -> method ) ; if ( s -> compress == NULL ) { SSLerr ( SSL_F_TLS1_CHANGE_CIPHER_STATE , SSL_R_COMPRESSION_LIBRARY_ERROR ) ; goto err2 ; } } # endif if ( ! SSL_IS_DTLS ( s ) ) RECORD_LAYER_reset_write_sequence ( & s -> rlayer ) ; mac_secret = & ( s -> s3 -> write_mac_secret [ 0 ] ) ; mac_secret_size = & ( s -> s3 -> write_mac_secret_size ) ; } if ( reuse_dd ) EVP_CIPHER_CTX_reset ( dd ) ; p = s -> s3 -> tmp . key_block ; i = * mac_secret_size = s -> s3 -> tmp . new_mac_secret_size ; cl = EVP_CIPHER_key_length ( c ) ; j = cl ; if ( EVP_CIPHER_mode ( c ) == EVP_CIPH_GCM_MODE ) k = EVP_GCM_TLS_FIXED_IV_LEN ; else if ( EVP_CIPHER_mode ( c ) == EVP_CIPH_CCM_MODE ) k = EVP_CCM_TLS_FIXED_IV_LEN ; else k = EVP_CIPHER_iv_length ( c ) ; if ( ( which == SSL3_CHANGE_CIPHER_CLIENT_WRITE ) || ( which == SSL3_CHANGE_CIPHER_SERVER_READ ) ) { ms = & ( p [ 0 ] ) ; n = i + i ; key = & ( p [ n ] ) ; n += j + j ; iv = & ( p [ n ] ) ; n += k + k ; } else { n = i ; ms = & ( p [ n ] ) ; n += i + j ; key = & ( p [ n ] ) ; n += j + k ; iv = & ( p [ n ] ) ; n += k ; } if ( n > s -> s3 -> tmp . key_block_length ) { SSLerr ( SSL_F_TLS1_CHANGE_CIPHER_STATE , ERR_R_INTERNAL_ERROR ) ; goto err2 ; } memcpy ( mac_secret , ms , i ) ; if ( ! ( EVP_CIPHER_flags ( c ) & EVP_CIPH_FLAG_AEAD_CIPHER ) ) { mac_key = EVP_PKEY_new_mac_key ( mac_type , NULL , mac_secret , * mac_secret_size ) ; if ( mac_key == NULL || EVP_DigestSignInit ( mac_ctx , NULL , m , NULL , mac_key ) <= 0 ) { EVP_PKEY_free ( mac_key ) ; SSLerr ( SSL_F_TLS1_CHANGE_CIPHER_STATE , ERR_R_INTERNAL_ERROR ) ; goto err2 ; } EVP_PKEY_free ( mac_key ) ; } # ifdef SSL_DEBUG printf ( \"which<S2SV_blank>=<S2SV_blank>%04X\\\\nmac<S2SV_blank>key=\" , which ) ; { int z ; for ( z = 0 ; z < i ; z ++ ) printf ( \"%02X%c\" , ms [ z ] , ( ( z + 1 ) % 16 ) ? '<S2SV_blank>' : '\\\\n' ) ; } # endif if ( EVP_CIPHER_mode ( c ) == EVP_CIPH_GCM_MODE ) { if ( ! EVP_CipherInit_ex ( dd , c , NULL , key , NULL , ( which & SSL3_CC_WRITE ) ) || ! EVP_CIPHER_CTX_ctrl ( dd , EVP_CTRL_GCM_SET_IV_FIXED , k , iv ) ) { SSLerr ( SSL_F_TLS1_CHANGE_CIPHER_STATE , ERR_R_INTERNAL_ERROR ) ; goto err2 ; } } else if ( EVP_CIPHER_mode ( c ) == EVP_CIPH_CCM_MODE ) { int taglen ; if ( s -> s3 -> tmp . new_cipher -> algorithm_enc & ( SSL_AES128CCM8 | SSL_AES256CCM8 ) ) taglen = 8 ; else taglen = 16 ; if ( ! EVP_CipherInit_ex ( dd , c , NULL , NULL , NULL , ( which & SSL3_CC_WRITE ) ) || ! EVP_CIPHER_CTX_ctrl ( dd , EVP_CTRL_AEAD_SET_IVLEN , 12 , NULL ) || ! EVP_CIPHER_CTX_ctrl ( dd , EVP_CTRL_AEAD_SET_TAG , taglen , NULL ) || ! EVP_CIPHER_CTX_ctrl ( dd , EVP_CTRL_CCM_SET_IV_FIXED , k , iv ) || ! EVP_CipherInit_ex ( dd , NULL , NULL , key , NULL , - 1 ) ) { SSLerr ( SSL_F_TLS1_CHANGE_CIPHER_STATE , ERR_R_INTERNAL_ERROR ) ; goto err2 ; } } else { if ( ! EVP_CipherInit_ex ( dd , c , NULL , key , iv , ( which & SSL3_CC_WRITE ) ) ) { SSLerr ( SSL_F_TLS1_CHANGE_CIPHER_STATE , ERR_R_INTERNAL_ERROR ) ; goto err2 ; } } if ( ( EVP_CIPHER_flags ( c ) & EVP_CIPH_FLAG_AEAD_CIPHER ) && * mac_secret_size && ! EVP_CIPHER_CTX_ctrl ( dd , EVP_CTRL_AEAD_SET_MAC_KEY , * mac_secret_size , mac_secret ) ) { SSLerr ( SSL_F_TLS1_CHANGE_CIPHER_STATE , ERR_R_INTERNAL_ERROR ) ; goto err2 ; } # ifdef OPENSSL_SSL_TRACE_CRYPTO if ( s -> msg_callback ) { int wh = which & SSL3_CC_WRITE ? TLS1_RT_CRYPTO_WRITE : 0 ; if ( * mac_secret_size ) s -> msg_callback ( 2 , s -> version , wh | TLS1_RT_CRYPTO_MAC , mac_secret , * mac_secret_size , s , s -> msg_callback_arg ) ; if ( c -> key_len ) s -> msg_callback ( 2 , s -> version , wh | TLS1_RT_CRYPTO_KEY , key , c -> key_len , s , s -> msg_callback_arg ) ; if ( k ) { if ( EVP_CIPHER_mode ( c ) == EVP_CIPH_GCM_MODE ) wh |= TLS1_RT_CRYPTO_FIXED_IV ; else wh |= TLS1_RT_CRYPTO_IV ; s -> msg_callback ( 2 , s -> version , wh , iv , k , s , s -> msg_callback_arg ) ; } } # endif # ifdef SSL_DEBUG printf ( \"which<S2SV_blank>=<S2SV_blank>%04X\\\\nkey=\" , which ) ; { int z ; for ( z = 0 ; z < EVP_CIPHER_key_length ( c ) ; z ++ ) printf ( \"%02X%c\" , key [ z ] , ( ( z + 1 ) % 16 ) ? '<S2SV_blank>' : '\\\\n' ) ; } printf ( \"\\\\niv=\" ) ; { int z ; for ( z = 0 ; z < k ; z ++ ) printf ( \"%02X%c\" , iv [ z ] , ( ( z + 1 ) % 16 ) ? '<S2SV_blank>' : '\\\\n' ) ; } printf ( \"\\\\n\" ) ; # endif OPENSSL_cleanse ( tmp1 , sizeof ( tmp1 ) ) ; OPENSSL_cleanse ( tmp2 , sizeof ( tmp1 ) ) ; OPENSSL_cleanse ( iv1 , sizeof ( iv1 ) ) ; OPENSSL_cleanse ( iv2 , sizeof ( iv2 ) ) ; return ( 1 ) ; err : SSLerr ( SSL_F_TLS1_CHANGE_CIPHER_STATE , ERR_R_MALLOC_FAILURE ) ; err2 : OPENSSL_cleanse ( tmp1 , sizeof ( tmp1 ) ) ; OPENSSL_cleanse ( tmp2 , sizeof ( tmp1 ) ) ; OPENSSL_cleanse ( iv1 , sizeof ( iv1 ) ) ; OPENSSL_cleanse ( iv2 , sizeof ( iv2 ) ) ; return ( 0 ) ; }\n","target":"<S2SV_ModStart> ( s -> tlsext_use_etm ) s -> s3 -> flags |= TLS1_FLAGS_ENCRYPT_THEN_MAC_READ ; else s -> s3 -> flags &= ~ TLS1_FLAGS_ENCRYPT_THEN_MAC_READ ; if ( s -> <S2SV_ModStart> } else { if ( s -> tlsext_use_etm ) s -> s3 -> flags |= TLS1_FLAGS_ENCRYPT_THEN_MAC_WRITE ; else s -> s3 -> flags &= ~ TLS1_FLAGS_ENCRYPT_THEN_MAC_WRITE ;\n","project_and_commit_id":"openssl@openssl/4ad93618d26a3ea23d36ad5498ff4f59eff3a4d2","cve_id":"CVE-2017-3733","original_address":"https://github.com/openssl/openssl/commit/4ad93618d26a3ea23d36ad5498ff4f59eff3a4d2","time":"2017-05-04T19:29Z"},
	{"Unnamed: 0":664,"cwe_id":"CWE-295","source":"CWE-295 static int ssl_verify_cert ( struct tunnel * tunnel ) { int ret = - 1 ; int cert_valid = 0 ; unsigned char digest [ SHA256LEN ] ; unsigned int len ; struct x509_digest * elem ; char digest_str [ SHA256STRLEN ] , * subject , * issuer ; char * line ; int i ; X509_NAME * subj ; char common_name [ FIELD_SIZE + 1 ] ; SSL_set_verify ( tunnel -> ssl_handle , SSL_VERIFY_PEER , NULL ) ; X509 * cert = SSL_get_peer_certificate ( tunnel -> ssl_handle ) ; if ( cert == NULL ) { log_error ( \"Unable<S2SV_blank>to<S2SV_blank>get<S2SV_blank>gateway<S2SV_blank>certificate.\\\\n\" ) ; return 1 ; } subj = X509_get_subject_name ( cert ) ; # ifdef HAVE_X509_CHECK_HOST <S2SV_StartBug> if ( X509_check_host ( cert , common_name , FIELD_SIZE , 0 , NULL ) ) <S2SV_EndBug> cert_valid = 1 ; # else if ( subj && X509_NAME_get_text_by_NID ( subj , NID_commonName , common_name , FIELD_SIZE ) > 0 && strncasecmp ( common_name , tunnel -> config -> gateway_host , FIELD_SIZE ) == 0 ) cert_valid = 1 ; # endif if ( cert_valid && SSL_get_verify_result ( tunnel -> ssl_handle ) == X509_V_OK ) { log_debug ( \"Gateway<S2SV_blank>certificate<S2SV_blank>validation<S2SV_blank>succeeded.\\\\n\" ) ; ret = 0 ; goto free_cert ; } log_debug ( \"Gateway<S2SV_blank>certificate<S2SV_blank>validation<S2SV_blank>failed.\\\\n\" ) ; if ( X509_digest ( cert , EVP_sha256 ( ) , digest , & len ) <= 0 || len != SHA256LEN ) { log_error ( \"Could<S2SV_blank>not<S2SV_blank>compute<S2SV_blank>certificate<S2SV_blank>sha256<S2SV_blank>digest.\\\\n\" ) ; goto free_cert ; } for ( i = 0 ; i < SHA256LEN ; i ++ ) sprintf ( & digest_str [ 2 * i ] , \"%02x\" , digest [ i ] ) ; digest_str [ SHA256STRLEN - 1 ] = '\\\\0' ; for ( elem = tunnel -> config -> cert_whitelist ; elem != NULL ; elem = elem -> next ) if ( memcmp ( digest_str , elem -> data , SHA256STRLEN - 1 ) == 0 ) break ; if ( elem != NULL ) { log_debug ( \"Gateway<S2SV_blank>certificate<S2SV_blank>digest<S2SV_blank>found<S2SV_blank>in<S2SV_blank>white<S2SV_blank>list.\\\\n\" ) ; ret = 0 ; goto free_cert ; } subject = X509_NAME_oneline ( subj , NULL , 0 ) ; issuer = X509_NAME_oneline ( X509_get_issuer_name ( cert ) , NULL , 0 ) ; log_error ( \"Gateway<S2SV_blank>certificate<S2SV_blank>validation<S2SV_blank>failed,<S2SV_blank>and<S2SV_blank>the<S2SV_blank>certificate<S2SV_blank>digest<S2SV_blank>in<S2SV_blank>not<S2SV_blank>in<S2SV_blank>the<S2SV_blank>local<S2SV_blank>whitelist.<S2SV_blank>If<S2SV_blank>you<S2SV_blank>trust<S2SV_blank>it,<S2SV_blank>rerun<S2SV_blank>with:\\\\n\" ) ; log_error ( \"<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>--trusted-cert<S2SV_blank>%s\\\\n\" , digest_str ) ; log_error ( \"or<S2SV_blank>add<S2SV_blank>this<S2SV_blank>line<S2SV_blank>to<S2SV_blank>your<S2SV_blank>config<S2SV_blank>file:\\\\n\" ) ; log_error ( \"<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>trusted-cert<S2SV_blank>=<S2SV_blank>%s\\\\n\" , digest_str ) ; log_error ( \"Gateway<S2SV_blank>certificate:\\\\n\" ) ; log_error ( \"<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>subject:\\\\n\" ) ; for ( line = strtok ( subject , \"/\" ) ; line != NULL ; line = strtok ( NULL , \"/\" ) ) log_error ( \"<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s\\\\n\" , line ) ; log_error ( \"<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>issuer:\\\\n\" ) ; for ( line = strtok ( issuer , \"/\" ) ; line != NULL ; line = strtok ( NULL , \"/\" ) ) log_error ( \"<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s\\\\n\" , line ) ; log_error ( \"<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>sha256<S2SV_blank>digest:\\\\n\" ) ; log_error ( \"<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s\\\\n\" , digest_str ) ; free_cert : X509_free ( cert ) ; return ret ; }\n","target":"<S2SV_ModStart> , NULL ) == 1\n","project_and_commit_id":"adrienverge@openfortivpn/60660e00b80bad0fadcf39aee86f6f8756c94f91","cve_id":"CVE-2020-7041","original_address":"https://github.com/adrienverge/openfortivpn/commit/60660e00b80bad0fadcf39aee86f6f8756c94f91","time":"2020-02-27T18:15Z"},
	{"Unnamed: 0":1839,"cwe_id":"CWE-295","source":"CWE-295 NOEXPORT void transfer ( CLI * c ) { int timeout ; int pending ; # if OPENSSL_VERSION_NUMBER >= 0x10100000L int has_pending = 0 , prev_has_pending ; # endif <S2SV_StartBug> int watchdog = 0 ; <S2SV_EndBug> ssize_t num ; int err ; int sock_open_rd = 1 , sock_open_wr = 1 ; int shutdown_wants_read = 0 , shutdown_wants_write = 0 ; int read_wants_read = 0 , read_wants_write = 0 ; int write_wants_read = 0 , write_wants_write = 0 ; int sock_can_rd , sock_can_wr , ssl_can_rd , ssl_can_wr ; # ifdef USE_WIN32 unsigned long bytes ; # else int bytes ; # endif c -> sock_ptr = c -> ssl_ptr = 0 ; do { read_wants_read |= ! ( SSL_get_shutdown ( c -> ssl ) & SSL_RECEIVED_SHUTDOWN ) && c -> ssl_ptr < BUFFSIZE && ! read_wants_write ; write_wants_write |= ! ( SSL_get_shutdown ( c -> ssl ) & SSL_SENT_SHUTDOWN ) && c -> sock_ptr && ! write_wants_read ; s_poll_init ( c -> fds , 0 ) ; if ( sock_open_rd ) s_poll_add ( c -> fds , c -> sock_rfd -> fd , c -> sock_ptr < BUFFSIZE , 0 ) ; if ( sock_open_wr ) s_poll_add ( c -> fds , c -> sock_wfd -> fd , 0 , c -> ssl_ptr > 0 ) ; if ( SSL_get_shutdown ( c -> ssl ) != ( SSL_SENT_SHUTDOWN | SSL_RECEIVED_SHUTDOWN ) ) { s_poll_add ( c -> fds , c -> ssl_rfd -> fd , read_wants_read || write_wants_read || shutdown_wants_read , 0 ) ; s_poll_add ( c -> fds , c -> ssl_wfd -> fd , 0 , read_wants_write || write_wants_write || shutdown_wants_write ) ; } pending = SSL_pending ( c -> ssl ) ; # if OPENSSL_VERSION_NUMBER >= 0x10100000L prev_has_pending = has_pending ; has_pending = SSL_has_pending ( c -> ssl ) ; pending = pending || ( has_pending && ! prev_has_pending ) ; # endif if ( read_wants_read && pending ) { timeout = 0 ; } else if ( ( sock_open_rd && ! ( SSL_get_shutdown ( c -> ssl ) & SSL_RECEIVED_SHUTDOWN ) ) || c -> ssl_ptr || c -> sock_ptr ) { timeout = c -> opt -> timeout_idle ; } else { timeout = c -> opt -> timeout_close ; } err = s_poll_wait ( c -> fds , timeout , 0 ) ; switch ( err ) { case - 1 : sockerror ( \"transfer:<S2SV_blank>s_poll_wait\" ) ; throw_exception ( c , 1 ) ; case 0 : if ( read_wants_read && pending ) break ; if ( ( sock_open_rd && ! ( SSL_get_shutdown ( c -> ssl ) & SSL_RECEIVED_SHUTDOWN ) ) || c -> ssl_ptr || c -> sock_ptr ) { s_log ( LOG_INFO , \"transfer:<S2SV_blank>s_poll_wait:\" \"<S2SV_blank>TIMEOUTidle<S2SV_blank>exceeded:<S2SV_blank>sending<S2SV_blank>reset\" ) ; s_poll_dump ( c -> fds , LOG_DEBUG ) ; throw_exception ( c , 1 ) ; } s_log ( LOG_ERR , \"transfer:<S2SV_blank>s_poll_wait:\" \"<S2SV_blank>TIMEOUTclose<S2SV_blank>exceeded:<S2SV_blank>closing\" ) ; s_poll_dump ( c -> fds , LOG_DEBUG ) ; return ; } sock_can_rd = s_poll_canread ( c -> fds , c -> sock_rfd -> fd ) ; sock_can_wr = s_poll_canwrite ( c -> fds , c -> sock_wfd -> fd ) ; ssl_can_rd = s_poll_canread ( c -> fds , c -> ssl_rfd -> fd ) ; ssl_can_wr = s_poll_canwrite ( c -> fds , c -> ssl_wfd -> fd ) ; if ( c -> sock_rfd -> fd == c -> sock_wfd -> fd ) { if ( ( sock_can_rd || sock_can_wr ) && s_poll_err ( c -> fds , c -> sock_rfd -> fd ) ) { err = get_socket_error ( c -> sock_rfd -> fd ) ; if ( err ) log_error ( LOG_INFO , err , \"socket<S2SV_blank>fd\" ) ; } } else { if ( sock_can_rd && s_poll_err ( c -> fds , c -> sock_rfd -> fd ) ) { err = get_socket_error ( c -> sock_rfd -> fd ) ; if ( err ) log_error ( LOG_INFO , err , \"socket<S2SV_blank>rfd\" ) ; } if ( sock_can_wr && s_poll_err ( c -> fds , c -> sock_wfd -> fd ) ) { err = get_socket_error ( c -> sock_wfd -> fd ) ; if ( err ) log_error ( LOG_INFO , err , \"socket<S2SV_blank>wfd\" ) ; } } if ( c -> ssl_rfd -> fd == c -> ssl_wfd -> fd ) { if ( ( ssl_can_rd || ssl_can_wr ) && s_poll_err ( c -> fds , c -> ssl_rfd -> fd ) ) { err = get_socket_error ( c -> ssl_rfd -> fd ) ; if ( err ) log_error ( LOG_INFO , err , \"TLS<S2SV_blank>fd\" ) ; } } else { if ( ssl_can_rd && s_poll_err ( c -> fds , c -> ssl_rfd -> fd ) ) { err = get_socket_error ( c -> ssl_rfd -> fd ) ; if ( err ) log_error ( LOG_INFO , err , \"TLS<S2SV_blank>rfd\" ) ; } if ( c -> ssl_rfd -> fd != c -> ssl_wfd -> fd && ssl_can_wr && s_poll_err ( c -> fds , c -> ssl_wfd -> fd ) ) { err = get_socket_error ( c -> ssl_wfd -> fd ) ; if ( err ) log_error ( LOG_INFO , err , \"TLS<S2SV_blank>wfd\" ) ; } } if ( ! ( sock_can_rd || sock_can_wr || ssl_can_rd || ssl_can_wr ) ) { if ( s_poll_hup ( c -> fds , c -> sock_rfd -> fd ) || s_poll_hup ( c -> fds , c -> sock_wfd -> fd ) ) { if ( c -> ssl_ptr ) { s_log ( LOG_ERR , \"Socket<S2SV_blank>closed<S2SV_blank>(HUP)<S2SV_blank>with<S2SV_blank>%ld<S2SV_blank>unsent<S2SV_blank>byte(s)\" , ( long ) c -> ssl_ptr ) ; throw_exception ( c , 1 ) ; } s_log ( LOG_INFO , \"Socket<S2SV_blank>closed<S2SV_blank>(HUP)\" ) ; sock_open_rd = sock_open_wr = 0 ; } else if ( s_poll_hup ( c -> fds , c -> ssl_rfd -> fd ) || s_poll_hup ( c -> fds , c -> ssl_wfd -> fd ) ) { if ( c -> sock_ptr ) { s_log ( LOG_ERR , \"TLS<S2SV_blank>socket<S2SV_blank>closed<S2SV_blank>(HUP)<S2SV_blank>with<S2SV_blank>%ld<S2SV_blank>unsent<S2SV_blank>byte(s)\" , ( long ) c -> sock_ptr ) ; throw_exception ( c , 1 ) ; } s_log ( LOG_INFO , \"TLS<S2SV_blank>socket<S2SV_blank>closed<S2SV_blank>(HUP)\" ) ; SSL_set_shutdown ( c -> ssl , SSL_SENT_SHUTDOWN | SSL_RECEIVED_SHUTDOWN ) ; } } if ( c -> reneg_state == RENEG_DETECTED && ! c -> opt -> option . renegotiation ) { s_log ( LOG_ERR , \"Aborting<S2SV_blank>due<S2SV_blank>to<S2SV_blank>renegotiation<S2SV_blank>request\" ) ; throw_exception ( c , 1 ) ; } if ( shutdown_wants_read || shutdown_wants_write ) { <S2SV_StartBug> num = SSL_shutdown ( c -> ssl ) ; <S2SV_EndBug> if ( num < 0 ) <S2SV_StartBug> err = SSL_get_error ( c -> ssl , ( int ) num ) ; <S2SV_EndBug> else err = SSL_ERROR_NONE ; switch ( err ) { case SSL_ERROR_NONE : s_log ( LOG_INFO , \"SSL_shutdown<S2SV_blank>successfully<S2SV_blank>sent<S2SV_blank>close_notify<S2SV_blank>alert\" ) ; shutdown_wants_read = shutdown_wants_write = 0 ; break ; <S2SV_StartBug> case SSL_ERROR_SYSCALL : <S2SV_EndBug> if ( parse_socket_error ( c , \"SSL_shutdown\" ) ) break ; SSL_set_shutdown ( c -> ssl , SSL_SENT_SHUTDOWN | SSL_RECEIVED_SHUTDOWN ) ; shutdown_wants_read = shutdown_wants_write = 0 ; break ; <S2SV_StartBug> case SSL_ERROR_ZERO_RETURN : <S2SV_EndBug> SSL_set_shutdown ( c -> ssl , SSL_SENT_SHUTDOWN | SSL_RECEIVED_SHUTDOWN ) ; shutdown_wants_read = shutdown_wants_write = 0 ; break ; <S2SV_StartBug> case SSL_ERROR_WANT_WRITE : <S2SV_EndBug> s_log ( LOG_DEBUG , \"SSL_shutdown<S2SV_blank>returned<S2SV_blank>WANT_WRITE:<S2SV_blank>retrying\" ) ; shutdown_wants_read = 0 ; shutdown_wants_write = 1 ; break ; case SSL_ERROR_WANT_READ : s_log ( LOG_DEBUG , \"SSL_shutdown<S2SV_blank>returned<S2SV_blank>WANT_READ:<S2SV_blank>retrying\" ) ; shutdown_wants_read = 1 ; shutdown_wants_write = 0 ; break ; case SSL_ERROR_SSL : sslerror ( \"SSL_shutdown\" ) ; throw_exception ( c , 1 ) ; default : s_log ( LOG_ERR , \"SSL_shutdown/SSL_get_error<S2SV_blank>returned<S2SV_blank>%d\" , err ) ; throw_exception ( c , 1 ) ; } } if ( sock_open_wr && sock_can_wr ) { <S2SV_StartBug> num = writesocket ( c -> sock_wfd -> fd , c -> ssl_buff , c -> ssl_ptr ) ; <S2SV_EndBug> switch ( num ) { case - 1 : if ( parse_socket_error ( c , \"writesocket\" ) ) break ; sock_open_rd = sock_open_wr = 0 ; break ; case 0 : s_log ( LOG_DEBUG , \"writesocket<S2SV_blank>returned<S2SV_blank>0\" ) ; break ; default : memmove ( c -> ssl_buff , c -> ssl_buff + num , c -> ssl_ptr - ( size_t ) num ) ; c -> ssl_ptr -= ( size_t ) num ; memset ( c -> ssl_buff + c -> ssl_ptr , 0 , ( size_t ) num ) ; c -> sock_bytes += ( size_t ) num ; watchdog = 0 ; } } if ( sock_open_rd && sock_can_rd ) { <S2SV_StartBug> num = readsocket ( c -> sock_rfd -> fd , <S2SV_EndBug> c -> sock_buff + c -> sock_ptr , BUFFSIZE - c -> sock_ptr ) ; switch ( num ) { case - 1 : if ( parse_socket_error ( c , \"readsocket\" ) ) break ; sock_open_rd = sock_open_wr = 0 ; break ; case 0 : s_log ( LOG_INFO , \"Read<S2SV_blank>socket<S2SV_blank>closed<S2SV_blank>(readsocket)\" ) ; sock_open_rd = 0 ; break ; default : c -> sock_ptr += ( size_t ) num ; watchdog = 0 ; } } read_wants_read |= ! ( SSL_get_shutdown ( c -> ssl ) & SSL_RECEIVED_SHUTDOWN ) && c -> ssl_ptr < BUFFSIZE && ! read_wants_write ; write_wants_write |= ! ( SSL_get_shutdown ( c -> ssl ) & SSL_SENT_SHUTDOWN ) && c -> sock_ptr && ! write_wants_read ; if ( ( write_wants_read && ssl_can_rd ) || ( write_wants_write && ssl_can_wr ) ) { <S2SV_StartBug> write_wants_read = 0 ; <S2SV_EndBug> write_wants_write = 0 ; <S2SV_StartBug> num = SSL_write ( c -> ssl , c -> sock_buff , ( int ) ( c -> sock_ptr ) ) ; <S2SV_EndBug> <S2SV_StartBug> switch ( err = SSL_get_error ( c -> ssl , ( int ) num ) ) { <S2SV_EndBug> case SSL_ERROR_NONE : if ( num == 0 ) { s_log ( LOG_DEBUG , \"SSL_write<S2SV_blank>returned<S2SV_blank>0\" ) ; break ; } memmove ( c -> sock_buff , c -> sock_buff + num , c -> sock_ptr - ( size_t ) num ) ; c -> sock_ptr -= ( size_t ) num ; memset ( c -> sock_buff + c -> sock_ptr , 0 , ( size_t ) num ) ; c -> ssl_bytes += ( size_t ) num ; watchdog = 0 ; break ; case SSL_ERROR_WANT_WRITE : s_log ( LOG_DEBUG , \"SSL_write<S2SV_blank>returned<S2SV_blank>WANT_WRITE:<S2SV_blank>retrying\" ) ; write_wants_write = 1 ; break ; case SSL_ERROR_WANT_READ : s_log ( LOG_DEBUG , \"SSL_write<S2SV_blank>returned<S2SV_blank>WANT_READ:<S2SV_blank>retrying\" ) ; write_wants_read = 1 ; break ; case SSL_ERROR_WANT_X509_LOOKUP : s_log ( LOG_DEBUG , \"SSL_write<S2SV_blank>returned<S2SV_blank>WANT_X509_LOOKUP:<S2SV_blank>retrying\" ) ; break ; <S2SV_StartBug> case SSL_ERROR_SYSCALL : <S2SV_EndBug> <S2SV_StartBug> if ( num && parse_socket_error ( c , \"SSL_write\" ) ) <S2SV_EndBug> break ; if ( c -> sock_ptr ) { s_log ( LOG_ERR , \"TLS<S2SV_blank>socket<S2SV_blank>closed<S2SV_blank>(SSL_write)<S2SV_blank>with<S2SV_blank>%ld<S2SV_blank>unsent<S2SV_blank>byte(s)\" , ( long ) c -> sock_ptr ) ; throw_exception ( c , 1 ) ; } s_log ( LOG_INFO , \"TLS<S2SV_blank>socket<S2SV_blank>closed<S2SV_blank>(SSL_write)\" ) ; SSL_set_shutdown ( c -> ssl , SSL_SENT_SHUTDOWN | SSL_RECEIVED_SHUTDOWN ) ; break ; <S2SV_StartBug> case SSL_ERROR_ZERO_RETURN : <S2SV_EndBug> <S2SV_StartBug> s_log ( LOG_INFO , \"TLS<S2SV_blank>closed<S2SV_blank>(SSL_write)\" ) ; <S2SV_EndBug> if ( SSL_version ( c -> ssl ) == SSL2_VERSION ) SSL_set_shutdown ( c -> ssl , SSL_SENT_SHUTDOWN | SSL_RECEIVED_SHUTDOWN ) ; break ; <S2SV_StartBug> case SSL_ERROR_SSL : <S2SV_EndBug> sslerror ( \"SSL_write\" ) ; throw_exception ( c , 1 ) ; default : s_log ( LOG_ERR , \"SSL_write/SSL_get_error<S2SV_blank>returned<S2SV_blank>%d\" , err ) ; throw_exception ( c , 1 ) ; } } if ( ( read_wants_read && ( ssl_can_rd || pending ) ) || ( read_wants_write && ssl_can_wr ) ) { read_wants_read = 0 ; read_wants_write = 0 ; num = SSL_read ( c -> ssl , c -> ssl_buff + c -> ssl_ptr , ( int ) ( BUFFSIZE - c -> ssl_ptr ) ) ; switch ( err = SSL_get_error ( c -> ssl , ( int ) num ) ) { case SSL_ERROR_NONE : if ( num == 0 ) { s_log ( LOG_DEBUG , \"SSL_read<S2SV_blank>returned<S2SV_blank>0\" ) ; break ; } c -> ssl_ptr += ( size_t ) num ; watchdog = 0 ; break ; case SSL_ERROR_WANT_WRITE : s_log ( LOG_DEBUG , \"SSL_read<S2SV_blank>returned<S2SV_blank>WANT_WRITE:<S2SV_blank>retrying\" ) ; read_wants_write = 1 ; break ; case SSL_ERROR_WANT_READ : # if 0 s_log ( LOG_DEBUG , \"SSL_read<S2SV_blank>returned<S2SV_blank>WANT_READ:<S2SV_blank>retrying\" ) ; # endif read_wants_read = 1 ; break ; case SSL_ERROR_WANT_X509_LOOKUP : s_log ( LOG_DEBUG , \"SSL_read<S2SV_blank>returned<S2SV_blank>WANT_X509_LOOKUP:<S2SV_blank>retrying\" ) ; break ; case SSL_ERROR_SYSCALL : if ( num && parse_socket_error ( c , \"SSL_read\" ) ) break ; if ( c -> sock_ptr || write_wants_write ) { s_log ( LOG_ERR , \"TLS<S2SV_blank>socket<S2SV_blank>closed<S2SV_blank>(SSL_read)<S2SV_blank>with<S2SV_blank>%ld<S2SV_blank>unsent<S2SV_blank>byte(s)\" , ( long ) c -> sock_ptr ) ; throw_exception ( c , 1 ) ; } s_log ( LOG_INFO , \"TLS<S2SV_blank>socket<S2SV_blank>closed<S2SV_blank>(SSL_read)\" ) ; SSL_set_shutdown ( c -> ssl , SSL_SENT_SHUTDOWN | SSL_RECEIVED_SHUTDOWN ) ; <S2SV_StartBug> break ; <S2SV_EndBug> case SSL_ERROR_ZERO_RETURN : s_log ( LOG_INFO , \"TLS<S2SV_blank>closed<S2SV_blank>(SSL_read)\" ) ; if ( SSL_version ( c -> ssl ) == SSL2_VERSION ) SSL_set_shutdown ( c -> ssl , SSL_SENT_SHUTDOWN | SSL_RECEIVED_SHUTDOWN ) ; break ; case SSL_ERROR_SSL : sslerror ( \"SSL_read\" ) ; throw_exception ( c , 1 ) ; default : s_log ( LOG_ERR , \"SSL_read/SSL_get_error<S2SV_blank>returned<S2SV_blank>%d\" , err ) ; throw_exception ( c , 1 ) ; } } if ( sock_open_rd && s_poll_rdhup ( c -> fds , c -> sock_rfd -> fd ) && ( ioctlsocket ( c -> sock_rfd -> fd , FIONREAD , & bytes ) || ! bytes ) ) { s_log ( LOG_INFO , \"Read<S2SV_blank>socket<S2SV_blank>closed<S2SV_blank>(read<S2SV_blank>hangup)\" ) ; sock_open_rd = 0 ; } if ( sock_open_wr && s_poll_hup ( c -> fds , c -> sock_wfd -> fd ) ) { if ( c -> ssl_ptr ) { s_log ( LOG_ERR , \"Write<S2SV_blank>socket<S2SV_blank>closed<S2SV_blank>(write<S2SV_blank>hangup)<S2SV_blank>with<S2SV_blank>%ld<S2SV_blank>unsent<S2SV_blank>byte(s)\" , ( long ) c -> ssl_ptr ) ; throw_exception ( c , 1 ) ; } s_log ( LOG_INFO , \"Write<S2SV_blank>socket<S2SV_blank>closed<S2SV_blank>(write<S2SV_blank>hangup)\" ) ; sock_open_wr = 0 ; } if ( ! ( SSL_get_shutdown ( c -> ssl ) & SSL_RECEIVED_SHUTDOWN ) && s_poll_rdhup ( c -> fds , c -> ssl_rfd -> fd ) && ( ioctlsocket ( c -> ssl_rfd -> fd , FIONREAD , & bytes ) || ! bytes ) ) { s_log ( LOG_INFO , \"TLS<S2SV_blank>socket<S2SV_blank>closed<S2SV_blank>(read<S2SV_blank>hangup)\" ) ; SSL_set_shutdown ( c -> ssl , SSL_get_shutdown ( c -> ssl ) | SSL_RECEIVED_SHUTDOWN ) ; } if ( ! ( SSL_get_shutdown ( c -> ssl ) & SSL_SENT_SHUTDOWN ) && s_poll_hup ( c -> fds , c -> ssl_wfd -> fd ) ) { if ( c -> sock_ptr || write_wants_write ) { s_log ( LOG_ERR , \"TLS<S2SV_blank>socket<S2SV_blank>closed<S2SV_blank>(write<S2SV_blank>hangup)<S2SV_blank>with<S2SV_blank>%ld<S2SV_blank>unsent<S2SV_blank>byte(s)\" , ( long ) c -> sock_ptr ) ; throw_exception ( c , 1 ) ; } s_log ( LOG_INFO , \"TLS<S2SV_blank>socket<S2SV_blank>closed<S2SV_blank>(write<S2SV_blank>hangup)\" ) ; SSL_set_shutdown ( c -> ssl , SSL_get_shutdown ( c -> ssl ) | SSL_SENT_SHUTDOWN ) ; } if ( sock_open_wr && SSL_get_shutdown ( c -> ssl ) & SSL_RECEIVED_SHUTDOWN && ! c -> ssl_ptr ) { sock_open_wr = 0 ; if ( ! c -> sock_wfd -> is_socket ) { s_log ( LOG_DEBUG , \"Closing<S2SV_blank>the<S2SV_blank>file<S2SV_blank>descriptor\" ) ; sock_open_rd = 0 ; } else if ( ! shutdown ( c -> sock_wfd -> fd , SHUT_WR ) ) { s_log ( LOG_DEBUG , \"Sent<S2SV_blank>socket<S2SV_blank>write<S2SV_blank>shutdown\" ) ; } else { s_log ( LOG_DEBUG , \"Failed<S2SV_blank>to<S2SV_blank>send<S2SV_blank>socket<S2SV_blank>write<S2SV_blank>shutdown\" ) ; sock_open_rd = 0 ; } } if ( ! ( SSL_get_shutdown ( c -> ssl ) & SSL_SENT_SHUTDOWN ) && ! sock_open_rd && ! c -> sock_ptr && ! write_wants_write ) { if ( SSL_version ( c -> ssl ) != SSL2_VERSION ) { s_log ( LOG_DEBUG , \"Sending<S2SV_blank>close_notify<S2SV_blank>alert\" ) ; shutdown_wants_write = 1 ; } else { s_log ( LOG_DEBUG , \"Closing<S2SV_blank>SSLv2<S2SV_blank>socket\" ) ; if ( c -> ssl_rfd -> is_socket ) shutdown ( c -> ssl_rfd -> fd , SHUT_RD ) ; if ( c -> ssl_wfd -> is_socket ) shutdown ( c -> ssl_wfd -> fd , SHUT_WR ) ; SSL_set_shutdown ( c -> ssl , SSL_SENT_SHUTDOWN | SSL_RECEIVED_SHUTDOWN ) ; } } if ( ++ watchdog > 100 ) { s_log ( LOG_ERR , \"transfer()<S2SV_blank>loop<S2SV_blank>executes<S2SV_blank>not<S2SV_blank>transferring<S2SV_blank>any<S2SV_blank>data\" ) ; s_log ( LOG_ERR , \"please<S2SV_blank>report<S2SV_blank>the<S2SV_blank>problem<S2SV_blank>to<S2SV_blank>Michal.Trojnara@stunnel.org\" ) ; stunnel_info ( LOG_ERR ) ; # if OPENSSL_VERSION_NUMBER >= 0x10100000L s_log ( LOG_ERR , \"protocol=%s,<S2SV_blank>SSL_pending=%d,<S2SV_blank>SSL_has_pending=%d\" , SSL_get_version ( c -> ssl ) , SSL_pending ( c -> ssl ) , SSL_has_pending ( c -> ssl ) ) ; # else s_log ( LOG_ERR , \"protocol=%s,<S2SV_blank>SSL_pending=%d\" , SSL_get_version ( c -> ssl ) , SSL_pending ( c -> ssl ) ) ; # endif s_log ( LOG_ERR , \"sock_open_rd=%s,<S2SV_blank>sock_open_wr=%s\" , sock_open_rd ? \"Y\" : \"n\" , sock_open_wr ? \"Y\" : \"n\" ) ; s_log ( LOG_ERR , \"SSL_RECEIVED_SHUTDOWN=%s,<S2SV_blank>SSL_SENT_SHUTDOWN=%s\" , ( SSL_get_shutdown ( c -> ssl ) & SSL_RECEIVED_SHUTDOWN ) ? \"Y\" : \"n\" , ( SSL_get_shutdown ( c -> ssl ) & SSL_SENT_SHUTDOWN ) ? \"Y\" : \"n\" ) ; s_log ( LOG_ERR , \"sock_can_rd=%s,<S2SV_blank>sock_can_wr=%s\" , sock_can_rd ? \"Y\" : \"n\" , sock_can_wr ? \"Y\" : \"n\" ) ; s_log ( LOG_ERR , \"ssl_can_rd=%s,<S2SV_blank>ssl_can_wr=%s\" , ssl_can_rd ? \"Y\" : \"n\" , ssl_can_wr ? \"Y\" : \"n\" ) ; s_log ( LOG_ERR , \"read_wants_read=%s,<S2SV_blank>read_wants_write=%s\" , read_wants_read ? \"Y\" : \"n\" , read_wants_write ? \"Y\" : \"n\" ) ; s_log ( LOG_ERR , \"write_wants_read=%s,<S2SV_blank>write_wants_write=%s\" , write_wants_read ? \"Y\" : \"n\" , write_wants_write ? \"Y\" : \"n\" ) ; s_log ( LOG_ERR , \"shutdown_wants_read=%s,<S2SV_blank>shutdown_wants_write=%s\" , shutdown_wants_read ? \"Y\" : \"n\" , shutdown_wants_write ? \"Y\" : \"n\" ) ; s_log ( LOG_ERR , \"socket<S2SV_blank>input<S2SV_blank>buffer:<S2SV_blank>%ld<S2SV_blank>byte(s),<S2SV_blank>\" \"TLS<S2SV_blank>input<S2SV_blank>buffer:<S2SV_blank>%ld<S2SV_blank>byte(s)\" , ( long ) c -> sock_ptr , ( long ) c -> ssl_ptr ) ; throw_exception ( c , 1 ) ; } } while ( sock_open_wr || ! ( SSL_get_shutdown ( c -> ssl ) & SSL_SENT_SHUTDOWN ) || shutdown_wants_read || shutdown_wants_write ) ; }\n","target":"<S2SV_ModStart> watchdog = 0 <S2SV_ModEnd> ; int err <S2SV_ModStart> shutdown_wants_write ) { int <S2SV_ModStart> -> ssl , <S2SV_ModEnd> num ) ; <S2SV_ModStart> break ; case SSL_ERROR_WANT_WRITE : s_log ( LOG_DEBUG , \"SSL_shutdown<S2SV_blank>returned<S2SV_blank>WANT_WRITE:<S2SV_blank>retrying\" ) ; shutdown_wants_read = 0 ; shutdown_wants_write = 1 ; break ; case SSL_ERROR_WANT_READ : s_log ( LOG_DEBUG , \"SSL_shutdown<S2SV_blank>returned<S2SV_blank>WANT_READ:<S2SV_blank>retrying\" ) ; shutdown_wants_read = 1 ; shutdown_wants_write = 0 ; break ; case SSL_ERROR_SSL : sslerror ( \"SSL_shutdown\" ) ; throw_exception ( c , 1 ) ; case SSL_ERROR_ZERO_RETURN : <S2SV_ModEnd> SSL_set_shutdown ( c <S2SV_ModStart> break ; case SSL_ERROR_SYSCALL : if ( parse_socket_error ( c , \"SSL_shutdown\" ) ) break ; <S2SV_ModEnd> SSL_set_shutdown ( c <S2SV_ModStart> ; break ; default : s_log ( LOG_ERR , \"SSL_shutdown/SSL_get_error<S2SV_blank>returned<S2SV_blank>%d\" , err ) ; throw_exception ( c , 1 <S2SV_ModEnd> ) ; } <S2SV_ModStart> sock_can_wr ) { ssize_t <S2SV_ModStart> sock_can_rd ) { ssize_t <S2SV_ModStart> ) ) { int num = SSL_write ( c -> ssl , c -> sock_buff , ( int ) ( c -> sock_ptr ) ) ; <S2SV_ModStart> = 0 ; <S2SV_ModEnd> switch ( err <S2SV_ModStart> -> ssl , <S2SV_ModEnd> num ) ) <S2SV_ModStart> break ; case SSL_ERROR_SSL : sslerror ( \"SSL_write\" ) ; throw_exception ( c , 1 ) ; case SSL_ERROR_ZERO_RETURN : case <S2SV_ModStart> : if ( parse_socket_error ( c , \"SSL_write\" ) && num <S2SV_ModEnd> ) break ; <S2SV_ModStart> ; break ; default : s_log ( LOG_ERR , \"SSL_write/SSL_get_error<S2SV_blank>returned<S2SV_blank>%d\" , err ) ; throw_exception ( c , 1 ) ; } } if ( ( read_wants_read && ( ssl_can_rd || pending ) ) || ( read_wants_write && ssl_can_wr ) ) { int num = SSL_read ( c -> ssl , c -> ssl_buff + c -> ssl_ptr , ( int ) ( BUFFSIZE - c -> ssl_ptr ) ) ; read_wants_read = 0 ; read_wants_write = 0 ; switch ( err = SSL_get_error ( c -> ssl , num ) ) { case SSL_ERROR_NONE : if ( num == 0 ) { s_log ( LOG_DEBUG , \"SSL_read<S2SV_blank>returned<S2SV_blank>0\" ) ; break ; } c -> ssl_ptr += ( size_t ) num ; watchdog = 0 ; break ; case SSL_ERROR_WANT_WRITE : s_log ( LOG_DEBUG , \"SSL_read<S2SV_blank>returned<S2SV_blank>WANT_WRITE:<S2SV_blank>retrying\" ) ; read_wants_write = 1 ; break ; case SSL_ERROR_WANT_READ : # if 0 s_log ( LOG_DEBUG , \"SSL_read<S2SV_blank>returned<S2SV_blank>WANT_READ:<S2SV_blank>retrying\" ) ; # endif read_wants_read = 1 ; break ; case SSL_ERROR_WANT_X509_LOOKUP : s_log ( LOG_DEBUG , \"SSL_read<S2SV_blank>returned<S2SV_blank>WANT_X509_LOOKUP:<S2SV_blank>retrying\" ) ; break ; case SSL_ERROR_SSL : sslerror ( \"SSL_read\" ) ; throw_exception ( c , 1 ) ; <S2SV_ModStart> ( LOG_INFO , \"TLS<S2SV_blank>closed<S2SV_blank>(SSL_read)\" <S2SV_ModEnd> ) ; if <S2SV_ModStart> break ; case SSL_ERROR_SYSCALL : if ( parse_socket_error ( c , \"SSL_read\" ) && num <S2SV_ModEnd> ) break ; <S2SV_ModStart> ) ; break <S2SV_ModEnd> ; default :\n","project_and_commit_id":"mtrojnar@stunnel/ebad9ddc4efb2635f37174c9d800d06206f1edf9","cve_id":"CVE-2021-20230","original_address":"https://github.com/mtrojnar/stunnel/commit/ebad9ddc4efb2635f37174c9d800d06206f1edf9","time":"2021-02-23T17:15Z"},
	{"Unnamed: 0":4808,"cwe_id":"CWE-200","source":"CWE-200 static int raw_cmd_copyout ( int cmd , void __user * param , struct floppy_raw_cmd * ptr ) { int ret ; while ( ptr ) { <S2SV_StartBug> ret = copy_to_user ( param , ptr , sizeof ( * ptr ) ) ; <S2SV_EndBug> if ( ret ) return - EFAULT ; param += sizeof ( struct floppy_raw_cmd ) ; if ( ( ptr -> flags & FD_RAW_READ ) && ptr -> buffer_length ) { if ( ptr -> length >= 0 && ptr -> length <= ptr -> buffer_length ) { long length = ptr -> buffer_length - ptr -> length ; ret = fd_copyout ( ptr -> data , ptr -> kernel_data , length ) ; if ( ret ) return ret ; } } ptr = ptr -> next ; } return 0 ; }\n","target":"<S2SV_ModStart> ptr ) { struct floppy_raw_cmd cmd = * ptr ; cmd . next = NULL ; cmd . kernel_data = NULL ; <S2SV_ModStart> ( param , & cmd <S2SV_ModEnd> , sizeof ( <S2SV_ModStart> , sizeof ( cmd <S2SV_ModEnd> ) ) ;\n","project_and_commit_id":"torvalds@linux/2145e15e0557a01b9195d1c7199a1b92cb9be81f","cve_id":"CVE-2014-1738","original_address":"https://github.com/torvalds/linux/commit/2145e15e0557a01b9195d1c7199a1b92cb9be81f","time":"2014-05-11T21:55Z"},
	{"Unnamed: 0":2605,"cwe_id":"CWE-284","source":"CWE-284 __be32 nfsd4_set_nfs4_acl ( struct svc_rqst * rqstp , struct svc_fh * fhp , struct nfs4_acl * acl ) { __be32 error ; int host_error ; struct dentry * dentry ; struct inode * inode ; struct posix_acl * pacl = NULL , * dpacl = NULL ; unsigned int flags = 0 ; error = fh_verify ( rqstp , fhp , 0 , NFSD_MAY_SATTR ) ; if ( error ) return error ; dentry = fhp -> fh_dentry ; inode = d_inode ( dentry ) ; <S2SV_StartBug> if ( ! inode -> i_op -> set_acl || ! IS_POSIXACL ( inode ) ) <S2SV_EndBug> return nfserr_attrnotsupp ; if ( S_ISDIR ( inode -> i_mode ) ) flags = NFS4_ACL_DIR ; host_error = nfs4_acl_nfsv4_to_posix ( acl , & pacl , & dpacl , flags ) ; if ( host_error == - EINVAL ) return nfserr_attrnotsupp ; if ( host_error < 0 ) goto out_nfserr ; <S2SV_StartBug> host_error = inode -> i_op -> set_acl ( inode , pacl , ACL_TYPE_ACCESS ) ; <S2SV_EndBug> if ( host_error < 0 ) <S2SV_StartBug> goto out_release ; <S2SV_EndBug> if ( S_ISDIR ( inode -> i_mode ) ) { <S2SV_StartBug> host_error = inode -> i_op -> set_acl ( inode , dpacl , <S2SV_EndBug> ACL_TYPE_DEFAULT ) ; } <S2SV_StartBug> out_release : <S2SV_EndBug> posix_acl_release ( pacl ) ; posix_acl_release ( dpacl ) ; out_nfserr : if ( host_error == - EOPNOTSUPP ) return nfserr_attrnotsupp ; else return nfserrno ( host_error ) ; }\n","target":"<S2SV_ModStart> ; if ( <S2SV_ModEnd> S_ISDIR ( inode <S2SV_ModStart> goto out_nfserr ; fh_lock ( fhp ) ; host_error = set_posix_acl ( inode , ACL_TYPE_ACCESS , pacl <S2SV_ModEnd> ) ; if <S2SV_ModStart> 0 ) goto out_drop_lock <S2SV_ModEnd> ; if ( <S2SV_ModStart> { host_error = set_posix_acl ( inode , ACL_TYPE_DEFAULT , dpacl <S2SV_ModEnd> ) ; } <S2SV_ModStart> ) ; } out_drop_lock : fh_unlock ( fhp ) ; <S2SV_ModEnd> posix_acl_release ( pacl\n","project_and_commit_id":"torvalds@linux/999653786df6954a31044528ac3f7a5dadca08f4","cve_id":"CVE-2016-1237","original_address":"https://github.com/torvalds/linux/commit/999653786df6954a31044528ac3f7a5dadca08f4","time":"2016-06-29T14:10Z"},
	{"Unnamed: 0":1278,"cwe_id":"CWE-20","source":"CWE-20 static int net_ctl_permissions ( struct ctl_table_header * head , struct ctl_table * table ) { struct net * net = container_of ( head -> set , struct net , sysctls ) ; kuid_t root_uid = make_kuid ( net -> user_ns , 0 ) ; kgid_t root_gid = make_kgid ( net -> user_ns , 0 ) ; if ( ns_capable ( net -> user_ns , CAP_NET_ADMIN ) || <S2SV_StartBug> uid_eq ( root_uid , current_uid ( ) ) ) { <S2SV_EndBug> int mode = ( table -> mode >> 6 ) & 7 ; return ( mode << 6 ) | ( mode << 3 ) | mode ; } <S2SV_StartBug> if ( gid_eq ( root_gid , current_gid ( ) ) ) { <S2SV_EndBug> int mode = ( table -> mode >> 3 ) & 7 ; return ( mode << 3 ) | mode ; } return table -> mode ; }\n","target":"<S2SV_ModStart> ( root_uid , current_euid <S2SV_ModEnd> ( ) ) <S2SV_ModStart> } if ( in_egroup_p ( root_gid <S2SV_ModEnd> ) ) {\n","project_and_commit_id":"torvalds@linux/2433c8f094a008895e66f25bd1773cdb01c91d01","cve_id":"CVE-2013-4270","original_address":"https://github.com/torvalds/linux/commit/2433c8f094a008895e66f25bd1773cdb01c91d01","time":"2013-12-09T18:55Z"},
	{"Unnamed: 0":1923,"cwe_id":"CWE-119","source":"CWE-119 void unix_inflight ( struct file * fp ) { struct sock * s = unix_get_socket ( fp ) ; <S2SV_StartBug> if ( s ) { <S2SV_EndBug> <S2SV_StartBug> struct unix_sock * u = unix_sk ( s ) ; <S2SV_EndBug> spin_lock ( & unix_gc_lock ) ; if ( atomic_long_inc_return ( & u -> inflight ) == 1 ) { BUG_ON ( ! list_empty ( & u -> link ) ) ; list_add_tail ( & u -> link , & gc_inflight_list ) ; } else { BUG_ON ( list_empty ( & u -> link ) ) ; } unix_tot_inflight ++ ; <S2SV_StartBug> spin_unlock ( & unix_gc_lock ) ; <S2SV_EndBug> } <S2SV_StartBug> } <S2SV_EndBug>\n","target":"<S2SV_ModStart> fp ) ; spin_lock ( & unix_gc_lock ) ; <S2SV_ModStart> unix_sk ( s <S2SV_ModEnd> ) ; if <S2SV_ModStart> unix_tot_inflight ++ ; } fp -> f_cred -> user -> unix_inflight ++ ; <S2SV_ModStart> ) ; } <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null>\n","project_and_commit_id":"torvalds@linux/712f4aad406bb1ed67f3f98d04c044191f0ff593","cve_id":"CVE-2013-4312","original_address":"https://github.com/torvalds/linux/commit/712f4aad406bb1ed67f3f98d04c044191f0ff593","time":"2016-02-08T03:59Z"},
	{"Unnamed: 0":6076,"cwe_id":"CWE-400","source":"CWE-400 void handle_ld_nf ( u32 insn , struct pt_regs * regs ) { int rd = ( ( insn >> 25 ) & 0x1f ) ; int from_kernel = ( regs -> tstate & TSTATE_PRIV ) != 0 ; unsigned long * reg ; <S2SV_StartBug> perf_sw_event ( PERF_COUNT_SW_EMULATION_FAULTS , 1 , 0 , regs , 0 ) ; <S2SV_EndBug> maybe_flush_windows ( 0 , 0 , rd , from_kernel ) ; reg = fetch_reg_addr ( rd , regs ) ; if ( from_kernel || rd < 16 ) { reg [ 0 ] = 0 ; if ( ( insn & 0x780000 ) == 0x180000 ) reg [ 1 ] = 0 ; } else if ( test_thread_flag ( TIF_32BIT ) ) { put_user ( 0 , ( int __user * ) reg ) ; if ( ( insn & 0x780000 ) == 0x180000 ) put_user ( 0 , ( ( int __user * ) reg ) + 1 ) ; } else { put_user ( 0 , ( unsigned long __user * ) reg ) ; if ( ( insn & 0x780000 ) == 0x180000 ) put_user ( 0 , ( unsigned long __user * ) reg + 1 ) ; } advance ( regs ) ; }\n","target":"<S2SV_ModStart> , 1 , <S2SV_ModEnd> regs , 0\n","project_and_commit_id":"torvalds@linux/a8b0ca17b80e92faab46ee7179ba9e99ccb61233","cve_id":"CVE-2011-2918","original_address":"https://github.com/torvalds/linux/commit/a8b0ca17b80e92faab46ee7179ba9e99ccb61233","time":"2012-05-24T23:55Z"},
	{"Unnamed: 0":4539,"cwe_id":"CWE-20","source":"CWE-20 static Image * ReadDCMImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { char explicit_vr [ MagickPathExtent ] , implicit_vr [ MagickPathExtent ] , magick [ MagickPathExtent ] , photometric [ MagickPathExtent ] ; DCMStreamInfo * stream_info ; Image * image ; int * bluemap , datum , * greenmap , * graymap , index , * redmap ; MagickBooleanType explicit_file , explicit_retry , polarity , sequence , use_explicit ; MagickOffsetType offset ; Quantum * scale ; register ssize_t i , x ; register Quantum * q ; register unsigned char * p ; size_t bits_allocated , bytes_per_pixel , colors , depth , height , length , mask , max_value , number_scenes , quantum , samples_per_pixel , signed_data , significant_bits , status , width , window_width ; ssize_t count , rescale_intercept , rescale_slope , scene , window_center , y ; unsigned char * data ; unsigned short group , element ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickCoreSignature ) ; if ( image_info -> debug != MagickFalse ) ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , \"%s\" , image_info -> filename ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickCoreSignature ) ; image = AcquireImage ( image_info , exception ) ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } image -> depth = 8UL ; image -> endian = LSBEndian ; stream_info = ( DCMStreamInfo * ) AcquireMagickMemory ( sizeof ( * stream_info ) ) ; if ( stream_info == ( DCMStreamInfo * ) NULL ) ThrowReaderException ( ResourceLimitError , \"MemoryAllocationFailed\" ) ; ( void ) ResetMagickMemory ( stream_info , 0 , sizeof ( * stream_info ) ) ; count = ReadBlob ( image , 128 , ( unsigned char * ) magick ) ; if ( count != 128 ) ThrowReaderException ( CorruptImageError , \"ImproperImageHeader\" ) ; count = ReadBlob ( image , 4 , ( unsigned char * ) magick ) ; if ( ( count != 4 ) || ( LocaleNCompare ( magick , \"DICM\" , 4 ) != 0 ) ) { offset = SeekBlob ( image , 0L , SEEK_SET ) ; if ( offset < 0 ) ThrowReaderException ( CorruptImageError , \"ImproperImageHeader\" ) ; } ( void ) CopyMagickString ( photometric , \"MONOCHROME1<S2SV_blank>\" , MagickPathExtent ) ; bits_allocated = 8 ; bytes_per_pixel = 1 ; polarity = MagickFalse ; data = ( unsigned char * ) NULL ; depth = 8 ; element = 0 ; explicit_vr [ 2 ] = '\\\\0' ; explicit_file = MagickFalse ; colors = 0 ; redmap = ( int * ) NULL ; greenmap = ( int * ) NULL ; bluemap = ( int * ) NULL ; graymap = ( int * ) NULL ; height = 0 ; max_value = 255UL ; mask = 0xffff ; number_scenes = 1 ; rescale_intercept = 0 ; rescale_slope = 1 ; samples_per_pixel = 1 ; scale = ( Quantum * ) NULL ; sequence = MagickFalse ; signed_data = ( ~ 0UL ) ; significant_bits = 0 ; use_explicit = MagickFalse ; explicit_retry = MagickFalse ; width = 0 ; window_center = 0 ; window_width = 0 ; for ( group = 0 ; ( group != 0x7FE0 ) || ( element != 0x0010 ) || ( sequence != MagickFalse ) ; ) { image -> offset = ( ssize_t ) TellBlob ( image ) ; group = ReadBlobLSBShort ( image ) ; element = ReadBlobLSBShort ( image ) ; if ( ( group != 0x0002 ) && ( image -> endian == MSBEndian ) ) { group = ( unsigned short ) ( ( group << 8 ) | ( ( group >> 8 ) & 0xFF ) ) ; element = ( unsigned short ) ( ( element << 8 ) | ( ( element >> 8 ) & 0xFF ) ) ; } quantum = 0 ; for ( i = 0 ; dicom_info [ i ] . group < 0xffff ; i ++ ) if ( ( group == dicom_info [ i ] . group ) && ( element == dicom_info [ i ] . element ) ) break ; ( void ) CopyMagickString ( implicit_vr , dicom_info [ i ] . vr , MagickPathExtent ) ; count = ReadBlob ( image , 2 , ( unsigned char * ) explicit_vr ) ; if ( count != 2 ) ThrowReaderException ( CorruptImageError , \"ImproperImageHeader\" ) ; if ( ( explicit_file == MagickFalse ) && ( group != 0x0002 ) ) explicit_file = ( isupper ( ( unsigned char ) * explicit_vr ) != MagickFalse ) && ( isupper ( ( unsigned char ) * ( explicit_vr + 1 ) ) != MagickFalse ) ? MagickTrue : MagickFalse ; use_explicit = ( ( group == 0x0002 ) && ( explicit_retry == MagickFalse ) ) || ( explicit_file != MagickFalse ) ? MagickTrue : MagickFalse ; if ( ( use_explicit != MagickFalse ) && ( strncmp ( implicit_vr , \"xs\" , 2 ) == 0 ) ) ( void ) CopyMagickString ( implicit_vr , explicit_vr , MagickPathExtent ) ; if ( ( use_explicit == MagickFalse ) || ( strncmp ( implicit_vr , \"!!\" , 2 ) == 0 ) ) { offset = SeekBlob ( image , ( MagickOffsetType ) - 2 , SEEK_CUR ) ; if ( offset < 0 ) ThrowReaderException ( CorruptImageError , \"ImproperImageHeader\" ) ; quantum = 4 ; } else { quantum = 2 ; if ( ( strncmp ( explicit_vr , \"OB\" , 2 ) == 0 ) || ( strncmp ( explicit_vr , \"UN\" , 2 ) == 0 ) || ( strncmp ( explicit_vr , \"OW\" , 2 ) == 0 ) || ( strncmp ( explicit_vr , \"SQ\" , 2 ) == 0 ) ) { ( void ) ReadBlobLSBShort ( image ) ; quantum = 4 ; } } datum = 0 ; if ( quantum == 4 ) { if ( group == 0x0002 ) datum = ReadBlobLSBSignedLong ( image ) ; else datum = ReadBlobSignedLong ( image ) ; } else if ( quantum == 2 ) { if ( group == 0x0002 ) datum = ReadBlobLSBSignedShort ( image ) ; else datum = ReadBlobSignedShort ( image ) ; } quantum = 0 ; length = 1 ; if ( datum != 0 ) { if ( ( strncmp ( implicit_vr , \"SS\" , 2 ) == 0 ) || ( strncmp ( implicit_vr , \"US\" , 2 ) == 0 ) ) quantum = 2 ; else if ( ( strncmp ( implicit_vr , \"UL\" , 2 ) == 0 ) || ( strncmp ( implicit_vr , \"SL\" , 2 ) == 0 ) || ( strncmp ( implicit_vr , \"FL\" , 2 ) == 0 ) ) quantum = 4 ; else if ( strncmp ( implicit_vr , \"FD\" , 2 ) != 0 ) quantum = 1 ; else quantum = 8 ; if ( datum != ~ 0 ) length = ( size_t ) datum / quantum ; else { quantum = 0 ; length = 0 ; } } if ( image_info -> verbose != MagickFalse ) { if ( use_explicit == MagickFalse ) explicit_vr [ 0 ] = '\\\\0' ; for ( i = 0 ; dicom_info [ i ] . description != ( char * ) NULL ; i ++ ) if ( ( group == dicom_info [ i ] . group ) && ( element == dicom_info [ i ] . element ) ) break ; ( void ) FormatLocaleFile ( stdout , \"0x%04lX<S2SV_blank>%4ld<S2SV_blank>%s-%s<S2SV_blank>(0x%04lx,0x%04lx)\" , ( unsigned long ) image -> offset , ( long ) length , implicit_vr , explicit_vr , ( unsigned long ) group , ( unsigned long ) element ) ; if ( dicom_info [ i ] . description != ( char * ) NULL ) ( void ) FormatLocaleFile ( stdout , \"<S2SV_blank>%s\" , dicom_info [ i ] . description ) ; ( void ) FormatLocaleFile ( stdout , \":<S2SV_blank>\" ) ; } if ( ( sequence == MagickFalse ) && ( group == 0x7FE0 ) && ( element == 0x0010 ) ) { if ( image_info -> verbose != MagickFalse ) ( void ) FormatLocaleFile ( stdout , \"\\\\n\" ) ; break ; } data = ( unsigned char * ) NULL ; if ( ( length == 1 ) && ( quantum == 1 ) ) datum = ReadBlobByte ( image ) ; else if ( ( length == 1 ) && ( quantum == 2 ) ) { if ( group == 0x0002 ) datum = ReadBlobLSBSignedShort ( image ) ; else datum = ReadBlobSignedShort ( image ) ; } else if ( ( length == 1 ) && ( quantum == 4 ) ) { if ( group == 0x0002 ) datum = ReadBlobLSBSignedLong ( image ) ; else datum = ReadBlobSignedLong ( image ) ; } else if ( ( quantum != 0 ) && ( length != 0 ) ) { if ( ~ length >= 1 ) data = ( unsigned char * ) AcquireQuantumMemory ( length + 1 , quantum * sizeof ( * data ) ) ; if ( data == ( unsigned char * ) NULL ) ThrowReaderException ( ResourceLimitError , \"MemoryAllocationFailed\" ) ; count = ReadBlob ( image , ( size_t ) quantum * length , data ) ; if ( count != ( ssize_t ) ( quantum * length ) ) { if ( image_info -> verbose != MagickFalse ) ( void ) FormatLocaleFile ( stdout , \"count=%d<S2SV_blank>quantum=%d<S2SV_blank>\" \"length=%d<S2SV_blank>group=%d\\\\n\" , ( int ) count , ( int ) quantum , ( int ) length , ( int ) group ) ; ThrowReaderException ( CorruptImageError , \"InsufficientImageDataInFile\" ) ; } data [ length * quantum ] = '\\\\0' ; } else if ( ( unsigned int ) datum == 0xFFFFFFFFU ) { sequence = MagickTrue ; continue ; } if ( ( unsigned int ) ( ( group << 16 ) | element ) == 0xFFFEE0DD ) { if ( data != ( unsigned char * ) NULL ) data = ( unsigned char * ) RelinquishMagickMemory ( data ) ; sequence = MagickFalse ; continue ; } if ( sequence != MagickFalse ) { if ( data != ( unsigned char * ) NULL ) data = ( unsigned char * ) RelinquishMagickMemory ( data ) ; continue ; } switch ( group ) { case 0x0002 : { switch ( element ) { case 0x0010 : { char transfer_syntax [ MagickPathExtent ] ; if ( ( datum == 0 ) && ( explicit_retry == MagickFalse ) ) { explicit_retry = MagickTrue ; ( void ) SeekBlob ( image , ( MagickOffsetType ) 0 , SEEK_SET ) ; group = 0 ; element = 0 ; if ( image_info -> verbose != MagickFalse ) ( void ) FormatLocaleFile ( stdout , \"Corrupted<S2SV_blank>image<S2SV_blank>-<S2SV_blank>trying<S2SV_blank>explicit<S2SV_blank>format\\\\n\" ) ; break ; } * transfer_syntax = '\\\\0' ; if ( data != ( unsigned char * ) NULL ) ( void ) CopyMagickString ( transfer_syntax , ( char * ) data , MagickPathExtent ) ; if ( image_info -> verbose != MagickFalse ) ( void ) FormatLocaleFile ( stdout , \"transfer_syntax=%s\\\\n\" , ( const char * ) transfer_syntax ) ; if ( strncmp ( transfer_syntax , \"1.2.840.10008.1.2\" , 17 ) == 0 ) { int count , subtype , type ; type = 1 ; subtype = 0 ; if ( strlen ( transfer_syntax ) > 17 ) { count = sscanf ( transfer_syntax + 17 , \".%d.%d\" , & type , & subtype ) ; if ( count < 1 ) ThrowReaderException ( CorruptImageError , \"ImproperImageHeader\" ) ; } switch ( type ) { case 1 : { image -> endian = LSBEndian ; break ; } case 2 : { image -> endian = MSBEndian ; break ; } case 4 : { if ( ( subtype >= 80 ) && ( subtype <= 81 ) ) image -> compression = JPEGCompression ; else if ( ( subtype >= 90 ) && ( subtype <= 93 ) ) image -> compression = JPEG2000Compression ; else image -> compression = JPEGCompression ; break ; } case 5 : { image -> compression = RLECompression ; break ; } } } break ; } default : break ; } break ; } case 0x0028 : { switch ( element ) { case 0x0002 : { samples_per_pixel = ( size_t ) datum ; break ; } case 0x0004 : { <S2SV_StartBug> for ( i = 0 ; i < ( ssize_t ) MagickMin ( length , MagickPathExtent - 1 ) ; i ++ ) <S2SV_EndBug> photometric [ i ] = ( char ) data [ i ] ; photometric [ i ] = '\\\\0' ; polarity = LocaleCompare ( photometric , \"MONOCHROME1<S2SV_blank>\" ) == 0 ? MagickTrue : MagickFalse ; break ; } case 0x0006 : { if ( datum == 1 ) image -> interlace = PlaneInterlace ; break ; } case 0x0008 : <S2SV_StartBug> { <S2SV_EndBug> number_scenes = StringToUnsignedLong ( ( char * ) data ) ; break ; } case 0x0010 : { height = ( size_t ) datum ; break ; } case 0x0011 : { width = ( size_t ) datum ; break ; } case 0x0100 : { bits_allocated = ( size_t ) datum ; bytes_per_pixel = 1 ; if ( datum > 8 ) bytes_per_pixel = 2 ; depth = bits_allocated ; if ( depth > 32 ) ThrowReaderException ( CorruptImageError , \"ImproperImageHeader\" ) ; max_value = ( 1UL << bits_allocated ) - 1 ; break ; } case 0x0101 : { significant_bits = ( size_t ) datum ; bytes_per_pixel = 1 ; if ( significant_bits > 8 ) bytes_per_pixel = 2 ; depth = significant_bits ; if ( depth > 32 ) ThrowReaderException ( CorruptImageError , \"ImproperImageHeader\" ) ; max_value = ( 1UL << significant_bits ) - 1 ; mask = ( size_t ) GetQuantumRange ( significant_bits ) ; break ; } case 0x0102 : { break ; } case 0x0103 : { signed_data = ( size_t ) datum ; break ; } case 0x1050 : { if ( data != ( unsigned char * ) NULL ) window_center = ( ssize_t ) StringToLong ( ( char * ) data ) ; break ; } case 0x1051 : { if ( data != ( unsigned char * ) NULL ) window_width = StringToUnsignedLong ( ( char * ) data ) ; break ; } case 0x1052 : { if ( data != ( unsigned char * ) NULL ) rescale_intercept = ( ssize_t ) StringToLong ( ( char * ) data ) ; break ; } case 0x1053 : { if ( data != ( unsigned char * ) NULL ) rescale_slope = ( ssize_t ) StringToLong ( ( char * ) data ) ; break ; } case 0x1200 : case 0x3006 : { if ( data == ( unsigned char * ) NULL ) break ; colors = ( size_t ) ( length / bytes_per_pixel ) ; datum = ( int ) colors ; graymap = ( int * ) AcquireQuantumMemory ( ( size_t ) colors , sizeof ( * graymap ) ) ; if ( graymap == ( int * ) NULL ) ThrowReaderException ( ResourceLimitError , \"MemoryAllocationFailed\" ) ; for ( i = 0 ; i < ( ssize_t ) colors ; i ++ ) if ( bytes_per_pixel == 1 ) graymap [ i ] = ( int ) data [ i ] ; else graymap [ i ] = ( int ) ( ( short * ) data ) [ i ] ; break ; } case 0x1201 : { unsigned short index ; if ( data == ( unsigned char * ) NULL ) break ; colors = ( size_t ) ( length / 2 ) ; datum = ( int ) colors ; redmap = ( int * ) AcquireQuantumMemory ( ( size_t ) colors , sizeof ( * redmap ) ) ; if ( redmap == ( int * ) NULL ) ThrowReaderException ( ResourceLimitError , \"MemoryAllocationFailed\" ) ; p = data ; for ( i = 0 ; i < ( ssize_t ) colors ; i ++ ) { if ( image -> endian == MSBEndian ) index = ( unsigned short ) ( ( * p << 8 ) | * ( p + 1 ) ) ; else index = ( unsigned short ) ( * p | ( * ( p + 1 ) << 8 ) ) ; redmap [ i ] = ( int ) index ; p += 2 ; } break ; } case 0x1202 : { unsigned short index ; if ( data == ( unsigned char * ) NULL ) break ; colors = ( size_t ) ( length / 2 ) ; datum = ( int ) colors ; greenmap = ( int * ) AcquireQuantumMemory ( ( size_t ) colors , sizeof ( * greenmap ) ) ; if ( greenmap == ( int * ) NULL ) ThrowReaderException ( ResourceLimitError , \"MemoryAllocationFailed\" ) ; p = data ; for ( i = 0 ; i < ( ssize_t ) colors ; i ++ ) { if ( image -> endian == MSBEndian ) index = ( unsigned short ) ( ( * p << 8 ) | * ( p + 1 ) ) ; else index = ( unsigned short ) ( * p | ( * ( p + 1 ) << 8 ) ) ; greenmap [ i ] = ( int ) index ; p += 2 ; } break ; } case 0x1203 : { unsigned short index ; if ( data == ( unsigned char * ) NULL ) break ; colors = ( size_t ) ( length / 2 ) ; datum = ( int ) colors ; bluemap = ( int * ) AcquireQuantumMemory ( ( size_t ) colors , sizeof ( * bluemap ) ) ; if ( bluemap == ( int * ) NULL ) ThrowReaderException ( ResourceLimitError , \"MemoryAllocationFailed\" ) ; p = data ; for ( i = 0 ; i < ( ssize_t ) colors ; i ++ ) { if ( image -> endian == MSBEndian ) index = ( unsigned short ) ( ( * p << 8 ) | * ( p + 1 ) ) ; else index = ( unsigned short ) ( * p | ( * ( p + 1 ) << 8 ) ) ; bluemap [ i ] = ( int ) index ; p += 2 ; } break ; } default : break ; } break ; } case 0x2050 : { switch ( element ) { case 0x0020 : { if ( ( data != ( unsigned char * ) NULL ) && ( strncmp ( ( char * ) data , \"INVERSE\" , 7 ) == 0 ) ) polarity = MagickTrue ; break ; } default : break ; } break ; } default : break ; } if ( data != ( unsigned char * ) NULL ) { char * attribute ; for ( i = 0 ; dicom_info [ i ] . description != ( char * ) NULL ; i ++ ) if ( ( group == dicom_info [ i ] . group ) && ( element == dicom_info [ i ] . element ) ) break ; if ( dicom_info [ i ] . description != ( char * ) NULL ) { attribute = AcquireString ( \"dcm:\" ) ; ( void ) ConcatenateString ( & attribute , dicom_info [ i ] . description ) ; for ( i = 0 ; i < ( ssize_t ) MagickMax ( length , 4 ) ; i ++ ) if ( isprint ( ( int ) data [ i ] ) == MagickFalse ) break ; if ( ( i == ( ssize_t ) length ) || ( length > 4 ) ) { ( void ) SubstituteString ( & attribute , \"<S2SV_blank>\" , \"\" ) ; ( void ) SetImageProperty ( image , attribute , ( char * ) data , exception ) ; } attribute = DestroyString ( attribute ) ; } } if ( image_info -> verbose != MagickFalse ) { if ( data == ( unsigned char * ) NULL ) ( void ) FormatLocaleFile ( stdout , \"%d\\\\n\" , datum ) ; else { for ( i = 0 ; i < ( ssize_t ) MagickMax ( length , 4 ) ; i ++ ) if ( isprint ( ( int ) data [ i ] ) == MagickFalse ) break ; if ( ( i != ( ssize_t ) length ) && ( length <= 4 ) ) { ssize_t j ; datum = 0 ; for ( j = ( ssize_t ) length - 1 ; j >= 0 ; j -- ) datum = ( 256 * datum + data [ j ] ) ; ( void ) FormatLocaleFile ( stdout , \"%d\" , datum ) ; } else for ( i = 0 ; i < ( ssize_t ) length ; i ++ ) if ( isprint ( ( int ) data [ i ] ) != MagickFalse ) ( void ) FormatLocaleFile ( stdout , \"%c\" , data [ i ] ) ; else ( void ) FormatLocaleFile ( stdout , \"%c\" , '.' ) ; ( void ) FormatLocaleFile ( stdout , \"\\\\n\" ) ; } } if ( data != ( unsigned char * ) NULL ) data = ( unsigned char * ) RelinquishMagickMemory ( data ) ; if ( EOFBlob ( image ) != MagickFalse ) { ThrowFileException ( exception , CorruptImageError , \"UnexpectedEndOfFile\" , image -> filename ) ; break ; } } if ( ( width == 0 ) || ( height == 0 ) ) ThrowReaderException ( CorruptImageError , \"ImproperImageHeader\" ) ; image -> columns = ( size_t ) width ; image -> rows = ( size_t ) height ; if ( signed_data == 0xffff ) signed_data = ( size_t ) ( significant_bits == 16 ? 1 : 0 ) ; if ( ( image -> compression == JPEGCompression ) || ( image -> compression == JPEG2000Compression ) ) { Image * images ; ImageInfo * read_info ; int c ; size_t length ; unsigned int tag ; for ( i = 0 ; i < ( ssize_t ) stream_info -> remaining ; i ++ ) ( void ) ReadBlobByte ( image ) ; tag = ( ReadBlobLSBShort ( image ) << 16 ) | ReadBlobLSBShort ( image ) ; ( void ) tag ; length = ( size_t ) ReadBlobLSBLong ( image ) ; stream_info -> offset_count = length >> 2 ; if ( stream_info -> offset_count != 0 ) { MagickOffsetType offset ; stream_info -> offsets = ( ssize_t * ) AcquireQuantumMemory ( stream_info -> offset_count , sizeof ( * stream_info -> offsets ) ) ; if ( stream_info -> offsets == ( ssize_t * ) NULL ) ThrowReaderException ( ResourceLimitError , \"MemoryAllocationFailed\" ) ; for ( i = 0 ; i < ( ssize_t ) stream_info -> offset_count ; i ++ ) stream_info -> offsets [ i ] = ( ssize_t ) ReadBlobLSBSignedLong ( image ) ; offset = TellBlob ( image ) ; for ( i = 0 ; i < ( ssize_t ) stream_info -> offset_count ; i ++ ) stream_info -> offsets [ i ] += offset ; } read_info = CloneImageInfo ( image_info ) ; SetImageInfoBlob ( read_info , ( void * ) NULL , 0 ) ; images = NewImageList ( ) ; for ( scene = 0 ; scene < ( ssize_t ) number_scenes ; scene ++ ) { char filename [ MagickPathExtent ] ; const char * property ; FILE * file ; Image * jpeg_image ; int unique_file ; unsigned int tag ; tag = ( ReadBlobLSBShort ( image ) << 16 ) | ReadBlobLSBShort ( image ) ; length = ( size_t ) ReadBlobLSBLong ( image ) ; if ( tag == 0xFFFEE0DD ) break ; if ( tag != 0xFFFEE000 ) ThrowReaderException ( CorruptImageError , \"ImproperImageHeader\" ) ; file = ( FILE * ) NULL ; unique_file = AcquireUniqueFileResource ( filename ) ; if ( unique_file != - 1 ) file = fdopen ( unique_file , \"wb\" ) ; if ( file == ( FILE * ) NULL ) { ( void ) RelinquishUniqueFileResource ( filename ) ; ThrowFileException ( exception , FileOpenError , \"UnableToCreateTemporaryFile\" , filename ) ; break ; } for ( ; length != 0 ; length -- ) { c = ReadBlobByte ( image ) ; if ( c == EOF ) { ThrowFileException ( exception , CorruptImageError , \"UnexpectedEndOfFile\" , image -> filename ) ; break ; } ( void ) fputc ( c , file ) ; } ( void ) fclose ( file ) ; ( void ) FormatLocaleString ( read_info -> filename , MagickPathExtent , \"jpeg:%s\" , filename ) ; if ( image -> compression == JPEG2000Compression ) ( void ) FormatLocaleString ( read_info -> filename , MagickPathExtent , \"j2k:%s\" , filename ) ; jpeg_image = ReadImage ( read_info , exception ) ; if ( jpeg_image != ( Image * ) NULL ) { ResetImagePropertyIterator ( image ) ; property = GetNextImageProperty ( image ) ; while ( property != ( const char * ) NULL ) { ( void ) SetImageProperty ( jpeg_image , property , GetImageProperty ( image , property , exception ) , exception ) ; property = GetNextImageProperty ( image ) ; } AppendImageToList ( & images , jpeg_image ) ; } ( void ) RelinquishUniqueFileResource ( filename ) ; } read_info = DestroyImageInfo ( read_info ) ; image = DestroyImage ( image ) ; return ( GetFirstImageInList ( images ) ) ; } if ( depth != ( 1UL * MAGICKCORE_QUANTUM_DEPTH ) ) { QuantumAny range ; size_t length ; length = ( size_t ) ( GetQuantumRange ( depth ) + 1 ) ; scale = ( Quantum * ) AcquireQuantumMemory ( length , sizeof ( * scale ) ) ; if ( scale == ( Quantum * ) NULL ) ThrowReaderException ( ResourceLimitError , \"MemoryAllocationFailed\" ) ; range = GetQuantumRange ( depth ) ; <S2SV_StartBug> for ( i = 0 ; i < ( ssize_t ) ( GetQuantumRange ( depth ) + 1 ) ; i ++ ) <S2SV_EndBug> scale [ i ] = ScaleAnyToQuantum ( ( size_t ) i , range ) ; } if ( image -> compression == RLECompression ) { size_t length ; unsigned int tag ; for ( i = 0 ; i < ( ssize_t ) stream_info -> remaining ; i ++ ) ( void ) ReadBlobByte ( image ) ; tag = ( ReadBlobLSBShort ( image ) << 16 ) | ReadBlobLSBShort ( image ) ; ( void ) tag ; length = ( size_t ) ReadBlobLSBLong ( image ) ; stream_info -> offset_count = length >> 2 ; if ( stream_info -> offset_count != 0 ) { MagickOffsetType offset ; stream_info -> offsets = ( ssize_t * ) AcquireQuantumMemory ( stream_info -> offset_count , sizeof ( * stream_info -> offsets ) ) ; if ( stream_info -> offsets == ( ssize_t * ) NULL ) ThrowReaderException ( ResourceLimitError , \"MemoryAllocationFailed\" ) ; for ( i = 0 ; i < ( ssize_t ) stream_info -> offset_count ; i ++ ) stream_info -> offsets [ i ] = ( ssize_t ) ReadBlobLSBSignedLong ( image ) ; offset = TellBlob ( image ) ; for ( i = 0 ; i < ( ssize_t ) stream_info -> offset_count ; i ++ ) stream_info -> offsets [ i ] += offset ; } } for ( scene = 0 ; scene < ( ssize_t ) number_scenes ; scene ++ ) { if ( image_info -> ping != MagickFalse ) break ; image -> columns = ( size_t ) width ; image -> rows = ( size_t ) height ; image -> depth = depth ; status = SetImageExtent ( image , image -> columns , image -> rows , exception ) ; if ( status == MagickFalse ) break ; image -> colorspace = RGBColorspace ; if ( ( image -> colormap == ( PixelInfo * ) NULL ) && ( samples_per_pixel == 1 ) ) { size_t one ; one = 1 ; if ( colors == 0 ) colors = one << depth ; if ( AcquireImageColormap ( image , one << depth , exception ) == MagickFalse ) ThrowReaderException ( ResourceLimitError , \"MemoryAllocationFailed\" ) ; if ( redmap != ( int * ) NULL ) for ( i = 0 ; i < ( ssize_t ) colors ; i ++ ) { index = redmap [ i ] ; if ( ( scale != ( Quantum * ) NULL ) && ( index <= ( int ) max_value ) ) index = ( int ) scale [ index ] ; image -> colormap [ i ] . red = ( MagickRealType ) index ; } if ( greenmap != ( int * ) NULL ) for ( i = 0 ; i < ( ssize_t ) colors ; i ++ ) { index = greenmap [ i ] ; if ( ( scale != ( Quantum * ) NULL ) && ( index <= ( int ) max_value ) ) index = ( int ) scale [ index ] ; image -> colormap [ i ] . green = ( MagickRealType ) index ; } if ( bluemap != ( int * ) NULL ) for ( i = 0 ; i < ( ssize_t ) colors ; i ++ ) { index = bluemap [ i ] ; if ( ( scale != ( Quantum * ) NULL ) && ( index <= ( int ) max_value ) ) index = ( int ) scale [ index ] ; image -> colormap [ i ] . blue = ( MagickRealType ) index ; } if ( graymap != ( int * ) NULL ) for ( i = 0 ; i < ( ssize_t ) colors ; i ++ ) { index = graymap [ i ] ; if ( ( scale != ( Quantum * ) NULL ) && ( index <= ( int ) max_value ) ) index = ( int ) scale [ index ] ; image -> colormap [ i ] . red = ( MagickRealType ) index ; image -> colormap [ i ] . green = ( MagickRealType ) index ; image -> colormap [ i ] . blue = ( MagickRealType ) index ; } } if ( image -> compression == RLECompression ) { unsigned int tag ; for ( i = 0 ; i < ( ssize_t ) stream_info -> remaining ; i ++ ) ( void ) ReadBlobByte ( image ) ; tag = ( ReadBlobLSBShort ( image ) << 16 ) | ReadBlobLSBShort ( image ) ; stream_info -> remaining = ( size_t ) ReadBlobLSBLong ( image ) ; if ( ( tag != 0xFFFEE000 ) || ( stream_info -> remaining <= 64 ) || ( EOFBlob ( image ) != MagickFalse ) ) ThrowReaderException ( CorruptImageError , \"ImproperImageHeader\" ) ; stream_info -> count = 0 ; stream_info -> segment_count = ReadBlobLSBLong ( image ) ; if ( stream_info -> segment_count > 1 ) { bytes_per_pixel = 1 ; depth = 8 ; } for ( i = 0 ; i < 15 ; i ++ ) stream_info -> segments [ i ] = ( ssize_t ) ReadBlobLSBSignedLong ( image ) ; stream_info -> remaining -= 64 ; } if ( ( samples_per_pixel > 1 ) && ( image -> interlace == PlaneInterlace ) ) { for ( i = 0 ; i < ( ssize_t ) samples_per_pixel ; i ++ ) { for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { q = GetAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { switch ( ( int ) i ) { case 0 : { SetPixelRed ( image , ScaleCharToQuantum ( ( unsigned char ) ReadDCMByte ( stream_info , image ) ) , q ) ; break ; } case 1 : { SetPixelGreen ( image , ScaleCharToQuantum ( ( unsigned char ) ReadDCMByte ( stream_info , image ) ) , q ) ; break ; } case 2 : { SetPixelBlue ( image , ScaleCharToQuantum ( ( unsigned char ) ReadDCMByte ( stream_info , image ) ) , q ) ; break ; } case 3 : { SetPixelAlpha ( image , ScaleCharToQuantum ( ( unsigned char ) ReadDCMByte ( stream_info , image ) ) , q ) ; break ; } default : break ; } q += GetPixelChannels ( image ) ; } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ; if ( status == MagickFalse ) break ; } } } } else { const char * option ; int byte ; PixelPacket pixel ; byte = 0 ; i = 0 ; if ( ( window_center != 0 ) && ( window_width == 0 ) ) window_width = ( size_t ) window_center ; option = GetImageOption ( image_info , \"dcm:display-range\" ) ; if ( option != ( const char * ) NULL ) { if ( LocaleCompare ( option , \"reset\" ) == 0 ) window_width = 0 ; } ( void ) ResetMagickMemory ( & pixel , 0 , sizeof ( pixel ) ) ; for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { if ( samples_per_pixel == 1 ) { int pixel_value ; if ( bytes_per_pixel == 1 ) pixel_value = polarity != MagickFalse ? ( ( int ) max_value - ReadDCMByte ( stream_info , image ) ) : ReadDCMByte ( stream_info , image ) ; else if ( ( bits_allocated != 12 ) || ( significant_bits != 12 ) ) { if ( signed_data ) pixel_value = ReadDCMSignedShort ( stream_info , image ) ; else pixel_value = ReadDCMShort ( stream_info , image ) ; if ( polarity != MagickFalse ) pixel_value = ( int ) max_value - pixel_value ; } else { if ( ( i & 0x01 ) != 0 ) pixel_value = ( ReadDCMByte ( stream_info , image ) << 8 ) | byte ; else { pixel_value = ReadDCMSignedShort ( stream_info , image ) ; byte = ( int ) ( pixel_value & 0x0f ) ; pixel_value >>= 4 ; } i ++ ; } index = ( pixel_value * rescale_slope ) + rescale_intercept ; if ( window_width == 0 ) { if ( signed_data == 1 ) index -= 32767 ; } else { ssize_t window_max , window_min ; window_min = ( ssize_t ) ceil ( ( double ) window_center - ( window_width - 1.0 ) / 2.0 - 0.5 ) ; window_max = ( ssize_t ) floor ( ( double ) window_center + ( window_width - 1.0 ) / 2.0 + 0.5 ) ; if ( ( ssize_t ) index <= window_min ) index = 0 ; else if ( ( ssize_t ) index > window_max ) index = ( int ) max_value ; else index = ( int ) ( max_value * ( ( ( index - window_center - 0.5 ) / ( window_width - 1 ) ) + 0.5 ) ) ; } index &= mask ; index = ( int ) ConstrainColormapIndex ( image , ( size_t ) index , exception ) ; SetPixelIndex ( image , ( Quantum ) index , q ) ; pixel . red = ( unsigned int ) image -> colormap [ index ] . red ; pixel . green = ( unsigned int ) image -> colormap [ index ] . green ; pixel . blue = ( unsigned int ) image -> colormap [ index ] . blue ; } else { if ( bytes_per_pixel == 1 ) { pixel . red = ( unsigned int ) ReadDCMByte ( stream_info , image ) ; pixel . green = ( unsigned int ) ReadDCMByte ( stream_info , image ) ; pixel . blue = ( unsigned int ) ReadDCMByte ( stream_info , image ) ; } else { pixel . red = ReadDCMShort ( stream_info , image ) ; pixel . green = ReadDCMShort ( stream_info , image ) ; pixel . blue = ReadDCMShort ( stream_info , image ) ; } pixel . red &= mask ; pixel . green &= mask ; pixel . blue &= mask ; if ( scale != ( Quantum * ) NULL ) { <S2SV_StartBug> pixel . red = scale [ pixel . red ] ; <S2SV_EndBug> <S2SV_StartBug> pixel . green = scale [ pixel . green ] ; <S2SV_EndBug> <S2SV_StartBug> pixel . blue = scale [ pixel . blue ] ; <S2SV_EndBug> } } SetPixelRed ( image , ( Quantum ) pixel . red , q ) ; SetPixelGreen ( image , ( Quantum ) pixel . green , q ) ; SetPixelBlue ( image , ( Quantum ) pixel . blue , q ) ; q += GetPixelChannels ( image ) ; } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ; if ( status == MagickFalse ) break ; } } if ( stream_info -> segment_count > 1 ) for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { if ( samples_per_pixel == 1 ) { int pixel_value ; if ( bytes_per_pixel == 1 ) pixel_value = polarity != MagickFalse ? ( ( int ) max_value - ReadDCMByte ( stream_info , image ) ) : ReadDCMByte ( stream_info , image ) ; else if ( ( bits_allocated != 12 ) || ( significant_bits != 12 ) ) { pixel_value = ( int ) ( polarity != MagickFalse ? ( max_value - ReadDCMShort ( stream_info , image ) ) : ReadDCMShort ( stream_info , image ) ) ; if ( signed_data == 1 ) pixel_value = ( ( signed short ) pixel_value ) ; } else { if ( ( i & 0x01 ) != 0 ) pixel_value = ( ReadDCMByte ( stream_info , image ) << 8 ) | byte ; else { pixel_value = ReadDCMShort ( stream_info , image ) ; byte = ( int ) ( pixel_value & 0x0f ) ; pixel_value >>= 4 ; } i ++ ; } index = ( pixel_value * rescale_slope ) + rescale_intercept ; if ( window_width == 0 ) { if ( signed_data == 1 ) index -= 32767 ; } else { ssize_t window_max , window_min ; window_min = ( ssize_t ) ceil ( ( double ) window_center - ( window_width - 1.0 ) / 2.0 - 0.5 ) ; window_max = ( ssize_t ) floor ( ( double ) window_center + ( window_width - 1.0 ) / 2.0 + 0.5 ) ; if ( ( ssize_t ) index <= window_min ) index = 0 ; else if ( ( ssize_t ) index > window_max ) index = ( int ) max_value ; else index = ( int ) ( max_value * ( ( ( index - window_center - 0.5 ) / ( window_width - 1 ) ) + 0.5 ) ) ; } index &= mask ; index = ( int ) ConstrainColormapIndex ( image , ( size_t ) index , exception ) ; SetPixelIndex ( image , ( Quantum ) ( ( ( size_t ) GetPixelIndex ( image , q ) ) | ( ( ( size_t ) index ) << 8 ) ) , q ) ; pixel . red = ( unsigned int ) image -> colormap [ index ] . red ; pixel . green = ( unsigned int ) image -> colormap [ index ] . green ; pixel . blue = ( unsigned int ) image -> colormap [ index ] . blue ; } else { if ( bytes_per_pixel == 1 ) { pixel . red = ( unsigned int ) ReadDCMByte ( stream_info , image ) ; pixel . green = ( unsigned int ) ReadDCMByte ( stream_info , image ) ; pixel . blue = ( unsigned int ) ReadDCMByte ( stream_info , image ) ; } else { pixel . red = ReadDCMShort ( stream_info , image ) ; pixel . green = ReadDCMShort ( stream_info , image ) ; pixel . blue = ReadDCMShort ( stream_info , image ) ; } pixel . red &= mask ; pixel . green &= mask ; pixel . blue &= mask ; if ( scale != ( Quantum * ) NULL ) { pixel . red = scale [ pixel . red ] ; pixel . green = scale [ pixel . green ] ; pixel . blue = scale [ pixel . blue ] ; } } SetPixelRed ( image , ( Quantum ) ( ( ( size_t ) GetPixelRed ( image , q ) ) | ( ( ( size_t ) pixel . red ) << 8 ) ) , q ) ; SetPixelGreen ( image , ( Quantum ) ( ( ( size_t ) GetPixelGreen ( image , q ) ) | ( ( ( size_t ) pixel . green ) << 8 ) ) , q ) ; SetPixelBlue ( image , ( Quantum ) ( ( ( size_t ) GetPixelBlue ( image , q ) ) | ( ( ( size_t ) pixel . blue ) << 8 ) ) , q ) ; q += GetPixelChannels ( image ) ; } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ; if ( status == MagickFalse ) break ; } } } if ( SetImageGray ( image , exception ) != MagickFalse ) ( void ) SetImageColorspace ( image , GRAYColorspace , exception ) ; if ( EOFBlob ( image ) != MagickFalse ) { ThrowFileException ( exception , CorruptImageError , \"UnexpectedEndOfFile\" , image -> filename ) ; break ; } if ( image_info -> number_scenes != 0 ) if ( image -> scene >= ( image_info -> scene + image_info -> number_scenes - 1 ) ) break ; if ( scene < ( ssize_t ) ( number_scenes - 1 ) ) { AcquireNextImage ( image_info , image , exception ) ; if ( GetNextImageInList ( image ) == ( Image * ) NULL ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } image = SyncNextImageInList ( image ) ; status = SetImageProgress ( image , LoadImagesTag , TellBlob ( image ) , GetBlobSize ( image ) ) ; if ( status == MagickFalse ) break ; } } if ( stream_info -> offsets != ( ssize_t * ) NULL ) stream_info -> offsets = ( ssize_t * ) RelinquishMagickMemory ( stream_info -> offsets ) ; stream_info = ( DCMStreamInfo * ) RelinquishMagickMemory ( stream_info ) ; if ( scale != ( Quantum * ) NULL ) scale = ( Quantum * ) RelinquishMagickMemory ( scale ) ; if ( graymap != ( int * ) NULL ) graymap = ( int * ) RelinquishMagickMemory ( graymap ) ; if ( bluemap != ( int * ) NULL ) bluemap = ( int * ) RelinquishMagickMemory ( bluemap ) ; if ( greenmap != ( int * ) NULL ) greenmap = ( int * ) RelinquishMagickMemory ( greenmap ) ; if ( redmap != ( int * ) NULL ) redmap = ( int * ) RelinquishMagickMemory ( redmap ) ; ( void ) CloseBlob ( image ) ; return ( GetFirstImageInList ( image ) ) ; }\n","target":"<S2SV_ModStart> 0x0004 : { if ( data == ( unsigned char * ) NULL ) break ; <S2SV_ModStart> 0x0008 : { if ( data == ( unsigned char * ) NULL ) break ; <S2SV_ModStart> 0 ; i <= <S2SV_ModEnd> ( ssize_t ) <S2SV_ModStart> ( ssize_t ) <S2SV_ModEnd> GetQuantumRange ( depth <S2SV_ModStart> GetQuantumRange ( depth <S2SV_ModEnd> ) ; i <S2SV_ModStart> NULL ) { if ( pixel . red <= GetQuantumRange ( depth ) ) <S2SV_ModStart> red ] ; if ( pixel . green <= GetQuantumRange ( depth ) ) <S2SV_ModStart> green ] ; if ( pixel . blue <= GetQuantumRange ( depth ) )\n","project_and_commit_id":"ImageMagick@ImageMagick/5511ef530576ed18fd636baa3bb4eda3d667665d","cve_id":"CVE-2016-5691","original_address":"https://github.com/ImageMagick/ImageMagick/commit/5511ef530576ed18fd636baa3bb4eda3d667665d","time":"2016-12-13T15:59Z"},
	{"Unnamed: 0":883,"cwe_id":"CWE-119","source":"CWE-119 void * pvPortMalloc ( size_t xWantedSize ) { BlockLink_t * pxBlock , * pxPreviousBlock , * pxNewBlockLink ; void * pvReturn = NULL ; vTaskSuspendAll ( ) ; { if ( pxEnd == NULL ) { prvHeapInit ( ) ; } else { mtCOVERAGE_TEST_MARKER ( ) ; } if ( ( xWantedSize & xBlockAllocatedBit ) == 0 ) { <S2SV_StartBug> if ( xWantedSize > 0 ) <S2SV_EndBug> { xWantedSize += xHeapStructSize ; if ( ( xWantedSize & portBYTE_ALIGNMENT_MASK ) != 0x00 ) { <S2SV_StartBug> xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) ) ; <S2SV_EndBug> configASSERT ( ( xWantedSize & portBYTE_ALIGNMENT_MASK ) == 0 ) ; } else { <S2SV_StartBug> mtCOVERAGE_TEST_MARKER ( ) ; <S2SV_EndBug> } } else { mtCOVERAGE_TEST_MARKER ( ) ; } if ( ( xWantedSize > 0 ) && ( xWantedSize <= xFreeBytesRemaining ) ) { pxPreviousBlock = & xStart ; pxBlock = xStart . pxNextFreeBlock ; while ( ( pxBlock -> xBlockSize < xWantedSize ) && ( pxBlock -> pxNextFreeBlock != NULL ) ) { pxPreviousBlock = pxBlock ; pxBlock = pxBlock -> pxNextFreeBlock ; } if ( pxBlock != pxEnd ) { pvReturn = ( void * ) ( ( ( uint8_t * ) pxPreviousBlock -> pxNextFreeBlock ) + xHeapStructSize ) ; pxPreviousBlock -> pxNextFreeBlock = pxBlock -> pxNextFreeBlock ; if ( ( pxBlock -> xBlockSize - xWantedSize ) > heapMINIMUM_BLOCK_SIZE ) { pxNewBlockLink = ( void * ) ( ( ( uint8_t * ) pxBlock ) + xWantedSize ) ; configASSERT ( ( ( ( size_t ) pxNewBlockLink ) & portBYTE_ALIGNMENT_MASK ) == 0 ) ; pxNewBlockLink -> xBlockSize = pxBlock -> xBlockSize - xWantedSize ; pxBlock -> xBlockSize = xWantedSize ; prvInsertBlockIntoFreeList ( pxNewBlockLink ) ; } else { mtCOVERAGE_TEST_MARKER ( ) ; } xFreeBytesRemaining -= pxBlock -> xBlockSize ; if ( xFreeBytesRemaining < xMinimumEverFreeBytesRemaining ) { xMinimumEverFreeBytesRemaining = xFreeBytesRemaining ; } else { mtCOVERAGE_TEST_MARKER ( ) ; } pxBlock -> xBlockSize |= xBlockAllocatedBit ; pxBlock -> pxNextFreeBlock = NULL ; xNumberOfSuccessfulAllocations ++ ; } else { mtCOVERAGE_TEST_MARKER ( ) ; } } else { mtCOVERAGE_TEST_MARKER ( ) ; } } else { mtCOVERAGE_TEST_MARKER ( ) ; } traceMALLOC ( pvReturn , xWantedSize ) ; } ( void ) xTaskResumeAll ( ) ; # if ( configUSE_MALLOC_FAILED_HOOK == 1 ) { if ( pvReturn == NULL ) { extern void vApplicationMallocFailedHook ( void ) ; vApplicationMallocFailedHook ( ) ; } else { mtCOVERAGE_TEST_MARKER ( ) ; } } # endif configASSERT ( ( ( ( size_t ) pvReturn ) & ( size_t ) portBYTE_ALIGNMENT_MASK ) == 0 ) ; return pvReturn ; }\n","target":"<S2SV_ModStart> { if ( ( <S2SV_ModStart> xWantedSize > 0 ) && ( ( xWantedSize + xHeapStructSize ) > xWantedSize ) <S2SV_ModStart> 0x00 ) { if ( ( xWantedSize + <S2SV_ModEnd> ( portBYTE_ALIGNMENT - <S2SV_ModStart> portBYTE_ALIGNMENT_MASK ) ) ) > xWantedSize ) { xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) ) <S2SV_ModStart> } else { xWantedSize = 0 ; } } else { mtCOVERAGE_TEST_MARKER ( ) ; } } else { xWantedSize = 0 <S2SV_ModEnd> ; } if\n","project_and_commit_id":"FreeRTOS@FreeRTOS-Kernel/c7a9a01c94987082b223d3e59969ede64363da63","cve_id":"CVE-2021-32020","original_address":"https://github.com/FreeRTOS/FreeRTOS-Kernel/commit/c7a9a01c94987082b223d3e59969ede64363da63","time":"2021-05-03T22:15Z"},
	{"Unnamed: 0":5954,"cwe_id":"CWE-190","source":"CWE-190 static int uvesafb_setcmap ( struct fb_cmap * cmap , struct fb_info * info ) { struct uvesafb_pal_entry * entries ; int shift = 16 - dac_width ; int i , err = 0 ; if ( info -> var . bits_per_pixel == 8 ) { if ( cmap -> start + cmap -> len > info -> cmap . start + info -> cmap . len || cmap -> start < info -> cmap . start ) return - EINVAL ; <S2SV_StartBug> entries = kmalloc ( sizeof ( * entries ) * cmap -> len , GFP_KERNEL ) ; <S2SV_EndBug> if ( ! entries ) return - ENOMEM ; for ( i = 0 ; i < cmap -> len ; i ++ ) { entries [ i ] . red = cmap -> red [ i ] >> shift ; entries [ i ] . green = cmap -> green [ i ] >> shift ; entries [ i ] . blue = cmap -> blue [ i ] >> shift ; entries [ i ] . pad = 0 ; } err = uvesafb_setpalette ( entries , cmap -> len , cmap -> start , info ) ; kfree ( entries ) ; } else { for ( i = 0 ; i < cmap -> len ; i ++ ) { err |= uvesafb_setcolreg ( cmap -> start + i , cmap -> red [ i ] , cmap -> green [ i ] , cmap -> blue [ i ] , 0 , info ) ; } } return err ; }\n","target":"<S2SV_ModStart> ; entries = kmalloc_array ( cmap -> len , <S2SV_ModEnd> sizeof ( * <S2SV_ModStart> * entries ) , <S2SV_ModEnd> GFP_KERNEL ) ;\n","project_and_commit_id":"torvalds@linux/9f645bcc566a1e9f921bdae7528a01ced5bc3713","cve_id":"CVE-2018-13406","original_address":"https://github.com/torvalds/linux/commit/9f645bcc566a1e9f921bdae7528a01ced5bc3713","time":"2018-07-06T14:29Z"},
	{"Unnamed: 0":3063,"cwe_id":"CWE-125","source":"CWE-125 void arp_print ( netdissect_options * ndo , const u_char * bp , u_int length , u_int caplen ) { const struct arp_pkthdr * ap ; u_short pro , hrd , op , linkaddr ; ap = ( const struct arp_pkthdr * ) bp ; ND_TCHECK ( * ap ) ; hrd = HRD ( ap ) ; pro = PRO ( ap ) ; op = OP ( ap ) ; switch ( hrd ) { case ARPHRD_ATM2225 : atmarp_print ( ndo , bp , length , caplen ) ; return ; case ARPHRD_FRELAY : linkaddr = LINKADDR_FRELAY ; break ; default : linkaddr = LINKADDR_ETHER ; break ; } <S2SV_StartBug> if ( ! ND_TTEST2 ( * ar_tpa ( ap ) , PROTO_LEN ( ap ) ) ) { <S2SV_EndBug> ND_PRINT ( ( ndo , \"%s\" , tstr ) ) ; ND_DEFAULTPRINT ( ( const u_char * ) ap , length ) ; return ; } if ( ! ndo -> ndo_eflag ) { ND_PRINT ( ( ndo , \"ARP,<S2SV_blank>\" ) ) ; } if ( ( pro != ETHERTYPE_IP && pro != ETHERTYPE_TRAIL ) || PROTO_LEN ( ap ) != 4 || HRD_LEN ( ap ) == 0 || ndo -> ndo_vflag ) { ND_PRINT ( ( ndo , \"%s<S2SV_blank>(len<S2SV_blank>%u),<S2SV_blank>%s<S2SV_blank>(len<S2SV_blank>%u)\" , tok2str ( arphrd_values , \"Unknown<S2SV_blank>Hardware<S2SV_blank>(%u)\" , hrd ) , HRD_LEN ( ap ) , tok2str ( ethertype_values , \"Unknown<S2SV_blank>Protocol<S2SV_blank>(0x%04x)\" , pro ) , PROTO_LEN ( ap ) ) ) ; if ( ! ndo -> ndo_vflag ) { goto out ; } } ND_PRINT ( ( ndo , \"%s%s<S2SV_blank>\" , ndo -> ndo_vflag ? \",<S2SV_blank>\" : \"\" , tok2str ( arpop_values , \"Unknown<S2SV_blank>(%u)\" , op ) ) ) ; switch ( op ) { case ARPOP_REQUEST : <S2SV_StartBug> ND_PRINT ( ( ndo , \"who-has<S2SV_blank>%s\" , ipaddr_string ( ndo , TPA ( ap ) ) ) ) ; <S2SV_EndBug> if ( isnonzero ( ( const u_char * ) THA ( ap ) , HRD_LEN ( ap ) ) ) ND_PRINT ( ( ndo , \"<S2SV_blank>(%s)\" , linkaddr_string ( ndo , THA ( ap ) , linkaddr , HRD_LEN ( ap ) ) ) ) ; <S2SV_StartBug> ND_PRINT ( ( ndo , \"<S2SV_blank>tell<S2SV_blank>%s\" , ipaddr_string ( ndo , SPA ( ap ) ) ) ) ; <S2SV_EndBug> break ; case ARPOP_REPLY : <S2SV_StartBug> ND_PRINT ( ( ndo , \"%s<S2SV_blank>is-at<S2SV_blank>%s\" , <S2SV_EndBug> ipaddr_string ( ndo , SPA ( ap ) ) , linkaddr_string ( ndo , SHA ( ap ) , linkaddr , HRD_LEN ( ap ) ) ) ) ; break ; case ARPOP_REVREQUEST : ND_PRINT ( ( ndo , \"who-is<S2SV_blank>%s<S2SV_blank>tell<S2SV_blank>%s\" , linkaddr_string ( ndo , THA ( ap ) , linkaddr , HRD_LEN ( ap ) ) , linkaddr_string ( ndo , SHA ( ap ) , linkaddr , HRD_LEN ( ap ) ) ) ) ; break ; case ARPOP_REVREPLY : <S2SV_StartBug> ND_PRINT ( ( ndo , \"%s<S2SV_blank>at<S2SV_blank>%s\" , <S2SV_EndBug> <S2SV_StartBug> linkaddr_string ( ndo , THA ( ap ) , linkaddr , HRD_LEN ( ap ) ) , <S2SV_EndBug> ipaddr_string ( ndo , TPA ( ap ) ) ) ) ; break ; case ARPOP_INVREQUEST : ND_PRINT ( ( ndo , \"who-is<S2SV_blank>%s<S2SV_blank>tell<S2SV_blank>%s\" , linkaddr_string ( ndo , THA ( ap ) , linkaddr , HRD_LEN ( ap ) ) , linkaddr_string ( ndo , SHA ( ap ) , linkaddr , HRD_LEN ( ap ) ) ) ) ; break ; case ARPOP_INVREPLY : <S2SV_StartBug> ND_PRINT ( ( ndo , \"%s<S2SV_blank>at<S2SV_blank>%s\" , <S2SV_EndBug> <S2SV_StartBug> linkaddr_string ( ndo , SHA ( ap ) , linkaddr , HRD_LEN ( ap ) ) , <S2SV_EndBug> ipaddr_string ( ndo , SPA ( ap ) ) ) ) ; break ; default : ND_DEFAULTPRINT ( ( const u_char * ) ap , caplen ) ; return ; } out : ND_PRINT ( ( ndo , \",<S2SV_blank>length<S2SV_blank>%u\" , length ) ) ; return ; trunc : ND_PRINT ( ( ndo , \"%s\" , tstr ) ) ; }\n","target":"<S2SV_ModStart> ND_TTEST2 ( * TPA <S2SV_ModEnd> ( ap ) <S2SV_ModStart> ( ndo , \"who-has<S2SV_blank>\" ) ) ; tpaddr_print_ip ( ndo , ap , pro <S2SV_ModEnd> ) ; if <S2SV_ModStart> ( ndo , \"<S2SV_blank>tell<S2SV_blank>\" ) ) ; spaddr_print_ip ( ndo , ap , pro <S2SV_ModEnd> ) ; break <S2SV_ModStart> case ARPOP_REPLY : spaddr_print_ip ( ndo , ap , pro ) ; ND_PRINT ( ( ndo , \"<S2SV_blank>is-at<S2SV_blank>%s\" <S2SV_ModEnd> , linkaddr_string ( <S2SV_ModStart> ( ndo , \"%s<S2SV_blank>at<S2SV_blank>\" <S2SV_ModEnd> , linkaddr_string ( <S2SV_ModStart> ap ) ) ) ) ; tpaddr_print_ip ( ndo , ap , pro <S2SV_ModEnd> ) ; break <S2SV_ModStart> ( ndo , \"%s<S2SV_blank>at<S2SV_blank>\" <S2SV_ModEnd> , linkaddr_string ( <S2SV_ModStart> ap ) ) ) ) ; spaddr_print_ip ( ndo , ap , pro <S2SV_ModEnd> ) ; break\n","project_and_commit_id":"the-tcpdump-group@tcpdump/13ab8d18617d616c7d343530f8a842e7143fb5cc","cve_id":"CVE-2017-13013","original_address":"https://github.com/the-tcpdump-group/tcpdump/commit/13ab8d18617d616c7d343530f8a842e7143fb5cc","time":"2017-09-14T06:29Z"},
	{"Unnamed: 0":397,"cwe_id":"CWE-254","source":"CWE-254 int virDomainGetTime ( virDomainPtr dom , long long * seconds , unsigned int * nseconds , unsigned int flags ) { VIR_DOMAIN_DEBUG ( dom , \"seconds=%p,<S2SV_blank>nseconds=%p,<S2SV_blank>flags=%x\" , seconds , nseconds , flags ) ; virResetLastError ( ) ; <S2SV_StartBug> virCheckDomainReturn ( dom , - 1 ) ; <S2SV_EndBug> if ( dom -> conn -> driver -> domainGetTime ) { int ret = dom -> conn -> driver -> domainGetTime ( dom , seconds , nseconds , flags ) ; if ( ret < 0 ) goto error ; return ret ; } virReportUnsupportedError ( ) ; error : virDispatchError ( dom -> conn ) ; return - 1 ; }\n","target":"<S2SV_ModStart> , - 1 ) ; virCheckReadOnlyGoto ( dom -> conn -> flags , error\n","project_and_commit_id":"libvirt@libvirt/506e9d6c2d4baaf580d489fff0690c0ff2ff588f","cve_id":"CVE-2016-10746","original_address":"https://github.com/libvirt/libvirt/commit/506e9d6c2d4baaf580d489fff0690c0ff2ff588f","time":"2019-04-18T16:29Z"},
	{"Unnamed: 0":6505,"cwe_id":"CWE-125","source":"CWE-125 <S2SV_StartBug> INST_HANDLER ( lds ) { <S2SV_EndBug> int d = ( ( buf [ 0 ] >> 4 ) & 0xf ) | ( ( buf [ 1 ] & 0x1 ) << 4 ) ; int k = ( buf [ 3 ] << 8 ) | buf [ 2 ] ; op -> ptr = k ; __generic_ld_st ( op , \"ram\" , 0 , 1 , 0 , k , 0 ) ; ESIL_A ( \"r%d,=,\" , d ) ; }\n","target":"<S2SV_ModStart> lds ) { if ( len < 4 ) { return ; }\n","project_and_commit_id":"radare@radare2/041e53cab7ca33481ae45ecd65ad596976d78e68","cve_id":"CVE-2018-11375","original_address":"https://github.com/radare/radare2/commit/041e53cab7ca33481ae45ecd65ad596976d78e68","time":"2018-05-22T19:29Z"},
	{"Unnamed: 0":1954,"cwe_id":"CWE-415","source":"CWE-415 static Gif_Stream * read_gif ( Gif_Reader * grr , int read_flags , const char * landmark , Gif_ReadErrorHandler handler ) { Gif_Stream * gfs ; Gif_Image * gfi ; Gif_Context gfc ; int unknown_block_type = 0 ; if ( gifgetc ( grr ) != 'G' || gifgetc ( grr ) != 'I' || gifgetc ( grr ) != 'F' ) return 0 ; ( void ) gifgetc ( grr ) ; ( void ) gifgetc ( grr ) ; ( void ) gifgetc ( grr ) ; gfs = Gif_NewStream ( ) ; gfi = Gif_NewImage ( ) ; gfc . stream = gfs ; gfc . prefix = Gif_NewArray ( Gif_Code , GIF_MAX_CODE ) ; gfc . suffix = Gif_NewArray ( uint8_t , GIF_MAX_CODE ) ; gfc . length = Gif_NewArray ( uint16_t , GIF_MAX_CODE ) ; gfc . handler = handler ; gfc . gfi = gfi ; gfc . errors [ 0 ] = gfc . errors [ 1 ] = 0 ; if ( ! gfs || ! gfi || ! gfc . prefix || ! gfc . suffix || ! gfc . length ) goto done ; gfs -> landmark = landmark ; GIF_DEBUG ( ( \"\\\\nGIF<S2SV_blank>\" ) ) ; if ( ! read_logical_screen_descriptor ( gfs , grr ) ) goto done ; GIF_DEBUG ( ( \"logscrdesc<S2SV_blank>\" ) ) ; while ( ! gifeof ( grr ) ) { uint8_t block = gifgetbyte ( grr ) ; switch ( block ) { case ',' : GIF_DEBUG ( ( \"imageread<S2SV_blank>%d<S2SV_blank>\" , gfs -> nimages ) ) ; gfi -> identifier = last_name ; last_name = 0 ; if ( ! Gif_AddImage ( gfs , gfi ) ) goto done ; else if ( ! read_image ( grr , & gfc , gfi , read_flags ) ) { Gif_RemoveImage ( gfs , gfs -> nimages - 1 ) ; gfi = 0 ; goto done ; } gfc . gfi = gfi = Gif_NewImage ( ) ; if ( ! gfi ) goto done ; break ; case ';' : GIF_DEBUG ( ( \"term\\\\n\" ) ) ; goto done ; case '!' : block = gifgetbyte ( grr ) ; GIF_DEBUG ( ( \"ext(0x%02X)<S2SV_blank>\" , block ) ) ; switch ( block ) { case 0xF9 : read_graphic_control_extension ( & gfc , gfi , grr ) ; break ; case 0xCE : last_name = suck_data ( last_name , 0 , grr ) ; break ; case 0xFE : if ( ! read_comment_extension ( gfi , grr ) ) goto done ; break ; case 0xFF : read_application_extension ( & gfc , grr ) ; break ; default : read_unknown_extension ( & gfc , grr , block , 0 , 0 ) ; break ; } break ; default : if ( ! unknown_block_type ) { char buf [ 256 ] ; sprintf ( buf , \"unknown<S2SV_blank>block<S2SV_blank>type<S2SV_blank>%d<S2SV_blank>at<S2SV_blank>file<S2SV_blank>offset<S2SV_blank>%u\" , block , grr -> pos - 1 ) ; gif_read_error ( & gfc , 1 , buf ) ; unknown_block_type = 1 ; } break ; } } done : if ( gfs && gfi ) { Gif_Extension * gfex ; gfs -> end_comment = gfi -> comment ; gfi -> comment = 0 ; gfs -> end_extension_list = gfi -> extension_list ; gfi -> extension_list = 0 ; for ( gfex = gfs -> end_extension_list ; gfex ; gfex = gfex -> next ) gfex -> image = NULL ; } Gif_DeleteImage ( gfi ) ; Gif_DeleteArray ( last_name ) ; Gif_DeleteArray ( gfc . prefix ) ; Gif_DeleteArray ( gfc . suffix ) ; Gif_DeleteArray ( gfc . length ) ; gfc . gfi = 0 ; <S2SV_StartBug> if ( gfs ) <S2SV_EndBug> gfs -> errors = gfc . errors [ 1 ] ; if ( gfs && gfc . errors [ 1 ] == 0 && ! ( read_flags & GIF_READ_TRAILING_GARBAGE_OK ) && ! grr -> eofer ( grr ) ) gif_read_error ( & gfc , 0 , \"trailing<S2SV_blank>garbage<S2SV_blank>after<S2SV_blank>GIF<S2SV_blank>ignored\" ) ; gif_read_error ( & gfc , - 1 , 0 ) ; return gfs ; }\n","target":"<S2SV_ModStart> = 0 ; last_name = 0 ;\n","project_and_commit_id":"kohler@gifsicle/118a46090c50829dc543179019e6140e1235f909","cve_id":"CVE-2017-18120","original_address":"https://github.com/kohler/gifsicle/commit/118a46090c50829dc543179019e6140e1235f909","time":"2018-02-02T09:29Z"},
	{"Unnamed: 0":2297,"cwe_id":"CWE-835","source":"CWE-835 int lookup ( struct sip_msg * _m , char * _t , char * _f , char * _s ) { unsigned int flags ; urecord_t * r ; str aor , uri ; ucontact_t * ptr , * it ; int res ; int ret ; str path_dst ; str flags_s ; pv_value_t val ; int_str istr ; str sip_instance = { 0 , 0 } , call_id = { 0 , 0 } ; flags = 0 ; if ( _f && _f [ 0 ] != 0 ) { if ( fixup_get_svalue ( _m , ( gparam_p ) _f , & flags_s ) != 0 ) { LM_ERR ( \"invalid<S2SV_blank>owner<S2SV_blank>uri<S2SV_blank>parameter\" ) ; return - 1 ; } for ( res = 0 ; res < flags_s . len ; res ++ ) { switch ( flags_s . s [ res ] ) { case 'm' : flags |= REG_LOOKUP_METHODFILTER_FLAG ; break ; case 'b' : flags |= REG_LOOKUP_NOBRANCH_FLAG ; break ; default : LM_WARN ( \"unsuported<S2SV_blank>flag<S2SV_blank>%c<S2SV_blank>\\\\n\" , flags_s . s [ res ] ) ; } } } if ( _s ) { if ( pv_get_spec_value ( _m , ( pv_spec_p ) _s , & val ) != 0 ) { LM_ERR ( \"failed<S2SV_blank>to<S2SV_blank>get<S2SV_blank>PV<S2SV_blank>value\\\\n\" ) ; return - 1 ; } if ( ( val . flags & PV_VAL_STR ) == 0 ) { LM_ERR ( \"PV<S2SV_blank>vals<S2SV_blank>is<S2SV_blank>not<S2SV_blank>string\\\\n\" ) ; return - 1 ; } uri = val . rs ; } else { if ( _m -> new_uri . s ) uri = _m -> new_uri ; else uri = _m -> first_line . u . request . uri ; } if ( extract_aor ( & uri , & aor , & sip_instance , & call_id ) < 0 ) { LM_ERR ( \"failed<S2SV_blank>to<S2SV_blank>extract<S2SV_blank>address<S2SV_blank>of<S2SV_blank>record\\\\n\" ) ; return - 3 ; } get_act_time ( ) ; ul . lock_udomain ( ( udomain_t * ) _t , & aor ) ; res = ul . get_urecord ( ( udomain_t * ) _t , & aor , & r ) ; if ( res > 0 ) { LM_DBG ( \"\\'%.*s\\'<S2SV_blank>Not<S2SV_blank>found<S2SV_blank>in<S2SV_blank>usrloc\\\\n\" , aor . len , ZSW ( aor . s ) ) ; ul . unlock_udomain ( ( udomain_t * ) _t , & aor ) ; return - 1 ; } ptr = r -> contacts ; ret = - 1 ; search_valid_contact : while ( ( ptr ) && ! ( VALID_CONTACT ( ptr , act_time ) && ( ret = - 2 ) && allowed_method ( _m , ptr , flags ) ) ) ptr = ptr -> next ; if ( ptr == 0 ) { LM_DBG ( \"nothing<S2SV_blank>found<S2SV_blank>!\\\\n\" ) ; goto done ; } if ( sip_instance . len && sip_instance . s ) { LM_DBG ( \"ruri<S2SV_blank>has<S2SV_blank>gruu<S2SV_blank>in<S2SV_blank>lookup\\\\n\" ) ; if ( ptr -> instance . len - 2 != sip_instance . len || memcmp ( ptr -> instance . s + 1 , sip_instance . s , sip_instance . len ) ) { LM_DBG ( \"no<S2SV_blank>match<S2SV_blank>to<S2SV_blank>sip<S2SV_blank>instace<S2SV_blank>-<S2SV_blank>[%.*s]<S2SV_blank>-<S2SV_blank>[%.*s]\\\\n\" , ptr -> instance . len - 2 , ptr -> instance . s + 1 , sip_instance . len , sip_instance . s ) ; ptr = ptr -> next ; goto search_valid_contact ; } LM_DBG ( \"matched<S2SV_blank>sip<S2SV_blank>instace\\\\n\" ) ; } if ( call_id . len && call_id . s ) { if ( ptr -> callid . len != call_id . len || memcmp ( ptr -> callid . s , call_id . s , call_id . len ) ) { LM_DBG ( \"no<S2SV_blank>match<S2SV_blank>to<S2SV_blank>call<S2SV_blank>id<S2SV_blank>-<S2SV_blank>[%.*s]<S2SV_blank>-<S2SV_blank>[%.*s]\\\\n\" , ptr -> callid . len , ptr -> callid . s , call_id . len , call_id . s ) ; ptr = ptr -> next ; goto search_valid_contact ; } it = ptr -> next ; while ( it ) { if ( VALID_CONTACT ( it , act_time ) ) { if ( it -> instance . len - 2 == sip_instance . len && memcmp ( it -> instance . s + 1 , sip_instance . s , sip_instance . len ) == 0 ) if ( it -> last_modified > ptr -> last_modified ) { break ; } } <S2SV_StartBug> } <S2SV_EndBug> if ( it != NULL ) { ret = - 1 ; goto done ; } } LM_DBG ( \"found<S2SV_blank>a<S2SV_blank>complete<S2SV_blank>match\\\\n\" ) ; ret = 1 ; if ( ptr ) { LM_DBG ( \"setting<S2SV_blank>as<S2SV_blank>ruri<S2SV_blank><%.*s>\\\\n\" , ptr -> c . len , ptr -> c . s ) ; if ( set_ruri ( _m , & ptr -> c ) < 0 ) { LM_ERR ( \"unable<S2SV_blank>to<S2SV_blank>rewrite<S2SV_blank>Request-URI\\\\n\" ) ; ret = - 3 ; goto done ; } if ( ptr -> path . s && ptr -> path . len ) { if ( get_path_dst_uri ( & ptr -> path , & path_dst ) < 0 ) { LM_ERR ( \"failed<S2SV_blank>to<S2SV_blank>get<S2SV_blank>dst_uri<S2SV_blank>for<S2SV_blank>Path\\\\n\" ) ; ret = - 3 ; goto done ; } if ( set_path_vector ( _m , & ptr -> path ) < 0 ) { LM_ERR ( \"failed<S2SV_blank>to<S2SV_blank>set<S2SV_blank>path<S2SV_blank>vector\\\\n\" ) ; ret = - 3 ; goto done ; } if ( set_dst_uri ( _m , & path_dst ) < 0 ) { LM_ERR ( \"failed<S2SV_blank>to<S2SV_blank>set<S2SV_blank>dst_uri<S2SV_blank>of<S2SV_blank>Path\\\\n\" ) ; ret = - 3 ; goto done ; } } else if ( ptr -> received . s && ptr -> received . len ) { if ( set_dst_uri ( _m , & ptr -> received ) < 0 ) { ret = - 3 ; goto done ; } } set_ruri_q ( ptr -> q ) ; setbflag ( 0 , ptr -> cflags ) ; if ( ptr -> sock ) _m -> force_send_socket = ptr -> sock ; if ( attr_avp_name != - 1 ) { istr . s = ptr -> attr ; if ( add_avp_last ( AVP_VAL_STR , attr_avp_name , istr ) != 0 ) { LM_ERR ( \"Failed<S2SV_blank>to<S2SV_blank>populate<S2SV_blank>attr<S2SV_blank>avp!\\\\n\" ) ; } } ptr = ptr -> next ; } if ( flags & REG_LOOKUP_NOBRANCH_FLAG || ( sip_instance . len && sip_instance . s ) ) goto done ; LM_DBG ( \"looking<S2SV_blank>for<S2SV_blank>branches\\\\n\" ) ; for ( ; ptr ; ptr = ptr -> next ) { if ( VALID_CONTACT ( ptr , act_time ) && allowed_method ( _m , ptr , flags ) ) { path_dst . len = 0 ; if ( ptr -> path . s && ptr -> path . len && get_path_dst_uri ( & ptr -> path , & path_dst ) < 0 ) { LM_ERR ( \"failed<S2SV_blank>to<S2SV_blank>get<S2SV_blank>dst_uri<S2SV_blank>for<S2SV_blank>Path\\\\n\" ) ; continue ; } LM_DBG ( \"setting<S2SV_blank>branch<S2SV_blank><%.*s>\\\\n\" , ptr -> c . len , ptr -> c . s ) ; if ( append_branch ( _m , & ptr -> c , path_dst . len ? & path_dst : & ptr -> received , & ptr -> path , ptr -> q , ptr -> cflags , ptr -> sock ) == - 1 ) { LM_ERR ( \"failed<S2SV_blank>to<S2SV_blank>append<S2SV_blank>a<S2SV_blank>branch\\\\n\" ) ; continue ; } if ( attr_avp_name != - 1 ) { istr . s = ptr -> attr ; if ( add_avp_last ( AVP_VAL_STR , attr_avp_name , istr ) != 0 ) { LM_ERR ( \"Failed<S2SV_blank>to<S2SV_blank>populate<S2SV_blank>attr<S2SV_blank>avp!\\\\n\" ) ; } } } } done : ul . release_urecord ( r ) ; ul . unlock_udomain ( ( udomain_t * ) _t , & aor ) ; return ret ; }\n","target":"<S2SV_ModStart> ; } } it = it -> next ;\n","project_and_commit_id":"OpenSIPS@opensips/54e027adfa486cfcf993828512b2e273aeb163c2","cve_id":"CVE-2013-3722","original_address":"https://github.com/OpenSIPS/opensips/commit/54e027adfa486cfcf993828512b2e273aeb163c2","time":"2020-02-17T17:15Z"},
	{"Unnamed: 0":3593,"cwe_id":"CWE-000","source":"CWE-000 static void preinit_thread ( lua_State * L , global_State * g ) { G ( L ) = g ; L -> stack = NULL ; L -> ci = NULL ; L -> nci = 0 ; L -> stacksize = 0 ; L -> twups = L ; L -> errorJmp = NULL ; L -> hook = NULL ; L -> hookmask = 0 ; L -> basehookcount = 0 ; L -> allowhook = 1 ; resethookcount ( L ) ; L -> openupval = NULL ; L -> status = LUA_OK ; L -> errfunc = 0 ; <S2SV_StartBug> } <S2SV_EndBug>\n","target":"<S2SV_ModStart> = 0 ; L -> oldpc = 0 ;\n","project_and_commit_id":"lua@lua/a2195644d89812e5b157ce7bac35543e06db05e3","cve_id":"CVE-2020-15945","original_address":"https://github.com/lua/lua/commit/a2195644d89812e5b157ce7bac35543e06db05e3","time":"2020-07-24T21:15Z"},
	{"Unnamed: 0":2396,"cwe_id":"CWE-119","source":"CWE-119 int read_yuv_frame ( struct VpxInputContext * input_ctx , vpx_image_t * yuv_frame ) { FILE * f = input_ctx -> file ; struct FileTypeDetectionBuffer * detect = & input_ctx -> detect ; int plane = 0 ; int shortread = 0 ; <S2SV_StartBug> for ( plane = 0 ; plane < 3 ; ++ plane ) { <S2SV_EndBug> uint8_t * ptr ; <S2SV_StartBug> const int w = ( plane ? ( 1 + yuv_frame -> d_w ) / 2 : yuv_frame -> d_w ) ; <S2SV_EndBug> <S2SV_StartBug> const int h = ( plane ? ( 1 + yuv_frame -> d_h ) / 2 : yuv_frame -> d_h ) ; <S2SV_EndBug> int r ; switch ( plane ) { case 1 : ptr = yuv_frame -> planes [ yuv_frame -> fmt == VPX_IMG_FMT_YV12 ? VPX_PLANE_V : VPX_PLANE_U ] ; break ; case 2 : ptr = yuv_frame -> planes [ yuv_frame -> fmt == VPX_IMG_FMT_YV12 ? VPX_PLANE_U : VPX_PLANE_V ] ; break ; default : ptr = yuv_frame -> planes [ plane ] ; } for ( r = 0 ; r < h ; ++ r ) { <S2SV_StartBug> size_t needed = w ; <S2SV_EndBug> size_t buf_position = 0 ; const size_t left = detect -> buf_read - detect -> position ; if ( left > 0 ) { const size_t more = ( left < needed ) ? left : needed ; memcpy ( ptr , detect -> buf + detect -> position , more ) ; buf_position = more ; needed -= more ; detect -> position += more ; } if ( needed > 0 ) { shortread |= ( fread ( ptr + buf_position , 1 , needed , f ) < needed ) ; } ptr += yuv_frame -> stride [ plane ] ; } } return shortread ; }\n","target":"<S2SV_ModStart> = 0 ; const int bytespp = ( yuv_frame -> fmt & VPX_IMG_FMT_HIGHBITDEPTH ) ? 2 : 1 ; <S2SV_ModStart> int w = vpx_img_plane_width ( yuv_frame , plane <S2SV_ModEnd> ) ; const <S2SV_ModStart> int h = vpx_img_plane_height ( yuv_frame , plane <S2SV_ModEnd> ) ; int <S2SV_ModStart> needed = w * bytespp\n","project_and_commit_id":"external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426","cve_id":"CVE-2016-1621","original_address":"https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426","time":"2016-03-12T21:59Z"},
	{"Unnamed: 0":4928,"cwe_id":"CWE-20","source":"CWE-20 static int packet_recvmsg ( struct kiocb * iocb , struct socket * sock , struct msghdr * msg , size_t len , int flags ) { struct sock * sk = sock -> sk ; struct sk_buff * skb ; <S2SV_StartBug> int copied , err ; <S2SV_EndBug> struct sockaddr_ll * sll ; int vnet_hdr_len = 0 ; err = - EINVAL ; if ( flags & ~ ( MSG_PEEK | MSG_DONTWAIT | MSG_TRUNC | MSG_CMSG_COMPAT | MSG_ERRQUEUE ) ) goto out ; # if 0 if ( pkt_sk ( sk ) -> ifindex < 0 ) return - ENODEV ; # endif if ( flags & MSG_ERRQUEUE ) { err = sock_recv_errqueue ( sk , msg , len , SOL_PACKET , PACKET_TX_TIMESTAMP ) ; goto out ; } skb = skb_recv_datagram ( sk , flags , flags & MSG_DONTWAIT , & err ) ; if ( skb == NULL ) goto out ; if ( pkt_sk ( sk ) -> has_vnet_hdr ) { struct virtio_net_hdr vnet_hdr = { 0 } ; err = - EINVAL ; vnet_hdr_len = sizeof ( vnet_hdr ) ; if ( len < vnet_hdr_len ) goto out_free ; len -= vnet_hdr_len ; if ( skb_is_gso ( skb ) ) { struct skb_shared_info * sinfo = skb_shinfo ( skb ) ; vnet_hdr . hdr_len = skb_headlen ( skb ) ; vnet_hdr . gso_size = sinfo -> gso_size ; if ( sinfo -> gso_type & SKB_GSO_TCPV4 ) vnet_hdr . gso_type = VIRTIO_NET_HDR_GSO_TCPV4 ; else if ( sinfo -> gso_type & SKB_GSO_TCPV6 ) vnet_hdr . gso_type = VIRTIO_NET_HDR_GSO_TCPV6 ; else if ( sinfo -> gso_type & SKB_GSO_UDP ) vnet_hdr . gso_type = VIRTIO_NET_HDR_GSO_UDP ; else if ( sinfo -> gso_type & SKB_GSO_FCOE ) goto out_free ; else BUG ( ) ; if ( sinfo -> gso_type & SKB_GSO_TCP_ECN ) vnet_hdr . gso_type |= VIRTIO_NET_HDR_GSO_ECN ; } else vnet_hdr . gso_type = VIRTIO_NET_HDR_GSO_NONE ; if ( skb -> ip_summed == CHECKSUM_PARTIAL ) { vnet_hdr . flags = VIRTIO_NET_HDR_F_NEEDS_CSUM ; vnet_hdr . csum_start = skb_checksum_start_offset ( skb ) ; vnet_hdr . csum_offset = skb -> csum_offset ; } else if ( skb -> ip_summed == CHECKSUM_UNNECESSARY ) { vnet_hdr . flags = VIRTIO_NET_HDR_F_DATA_VALID ; } err = memcpy_toiovec ( msg -> msg_iov , ( void * ) & vnet_hdr , vnet_hdr_len ) ; if ( err < 0 ) goto out_free ; } <S2SV_StartBug> sll = & PACKET_SKB_CB ( skb ) -> sa . ll ; <S2SV_EndBug> <S2SV_StartBug> if ( sock -> type == SOCK_PACKET ) <S2SV_EndBug> msg -> msg_namelen = sizeof ( struct sockaddr_pkt ) ; <S2SV_StartBug> else <S2SV_EndBug> msg -> msg_namelen = sll -> sll_halen + offsetof ( struct sockaddr_ll , sll_addr ) ; <S2SV_StartBug> copied = skb -> len ; <S2SV_EndBug> if ( copied > len ) { copied = len ; msg -> msg_flags |= MSG_TRUNC ; } err = skb_copy_datagram_iovec ( skb , 0 , msg -> msg_iov , copied ) ; if ( err ) goto out_free ; sock_recv_ts_and_drops ( msg , sk , skb ) ; <S2SV_StartBug> if ( msg -> msg_name ) <S2SV_EndBug> memcpy ( msg -> msg_name , & PACKET_SKB_CB ( skb ) -> sa , <S2SV_StartBug> msg -> msg_namelen ) ; <S2SV_EndBug> if ( pkt_sk ( sk ) -> auxdata ) { struct tpacket_auxdata aux ; aux . tp_status = TP_STATUS_USER ; if ( skb -> ip_summed == CHECKSUM_PARTIAL ) aux . tp_status |= TP_STATUS_CSUMNOTREADY ; aux . tp_len = PACKET_SKB_CB ( skb ) -> origlen ; aux . tp_snaplen = skb -> len ; aux . tp_mac = 0 ; aux . tp_net = skb_network_offset ( skb ) ; if ( vlan_tx_tag_present ( skb ) ) { aux . tp_vlan_tci = vlan_tx_tag_get ( skb ) ; aux . tp_status |= TP_STATUS_VLAN_VALID ; } else { aux . tp_vlan_tci = 0 ; } aux . tp_padding = 0 ; put_cmsg ( msg , SOL_PACKET , PACKET_AUXDATA , sizeof ( aux ) , & aux ) ; } err = vnet_hdr_len + ( ( flags & MSG_TRUNC ) ? skb -> len : copied ) ; out_free : skb_free_datagram ( sk , skb ) ; out : return err ; }\n","target":"<S2SV_ModStart> copied , err <S2SV_ModEnd> ; int vnet_hdr_len <S2SV_ModStart> out_free ; } copied = skb -> len ; if ( copied > len ) { copied = len ; msg -> msg_flags |= MSG_TRUNC ; } err = skb_copy_datagram_iovec ( skb , 0 , msg -> msg_iov , copied ) ; if ( err ) goto out_free ; sock_recv_ts_and_drops ( msg , sk , skb ) ; if ( msg -> msg_name ) { <S2SV_ModEnd> if ( sock <S2SV_ModStart> == SOCK_PACKET ) { <S2SV_ModStart> sockaddr_pkt ) ; } else { struct sockaddr_ll * sll = & PACKET_SKB_CB ( skb ) -> sa . ll ; <S2SV_ModEnd> msg -> msg_namelen <S2SV_ModStart> sll_addr ) ; } memcpy <S2SV_ModEnd> ( msg -> <S2SV_ModStart> msg -> msg_name <S2SV_ModEnd> , & PACKET_SKB_CB <S2SV_ModStart> msg_namelen ) ; }\n","project_and_commit_id":"torvalds@linux/f3d3342602f8bcbf37d7c46641cb9bca7618eb1c","cve_id":"CVE-2013-7271","original_address":"https://github.com/torvalds/linux/commit/f3d3342602f8bcbf37d7c46641cb9bca7618eb1c","time":"2014-01-06T16:55Z"},
	{"Unnamed: 0":5183,"cwe_id":"CWE-125","source":"CWE-125 void bootp_print ( netdissect_options * ndo , register const u_char * cp , u_int length ) { register const struct bootp * bp ; static const u_char vm_cmu [ 4 ] = VM_CMU ; static const u_char vm_rfc1048 [ 4 ] = VM_RFC1048 ; bp = ( const struct bootp * ) cp ; ND_TCHECK ( bp -> bp_op ) ; ND_PRINT ( ( ndo , \"BOOTP/DHCP,<S2SV_blank>%s\" , tok2str ( bootp_op_values , \"unknown<S2SV_blank>(0x%02x)\" , bp -> bp_op ) ) ) ; ND_TCHECK ( bp -> bp_hlen ) ; if ( bp -> bp_htype == 1 && bp -> bp_hlen == 6 && bp -> bp_op == BOOTPREQUEST ) { ND_TCHECK2 ( bp -> bp_chaddr [ 0 ] , 6 ) ; ND_PRINT ( ( ndo , \"<S2SV_blank>from<S2SV_blank>%s\" , etheraddr_string ( ndo , bp -> bp_chaddr ) ) ) ; } ND_PRINT ( ( ndo , \",<S2SV_blank>length<S2SV_blank>%u\" , length ) ) ; if ( ! ndo -> ndo_vflag ) return ; ND_TCHECK ( bp -> bp_secs ) ; if ( bp -> bp_htype != 1 ) ND_PRINT ( ( ndo , \",<S2SV_blank>htype<S2SV_blank>%d\" , bp -> bp_htype ) ) ; if ( bp -> bp_htype != 1 || bp -> bp_hlen != 6 ) ND_PRINT ( ( ndo , \",<S2SV_blank>hlen<S2SV_blank>%d\" , bp -> bp_hlen ) ) ; if ( bp -> bp_hops ) ND_PRINT ( ( ndo , \",<S2SV_blank>hops<S2SV_blank>%d\" , bp -> bp_hops ) ) ; if ( EXTRACT_32BITS ( & bp -> bp_xid ) ) ND_PRINT ( ( ndo , \",<S2SV_blank>xid<S2SV_blank>0x%x\" , EXTRACT_32BITS ( & bp -> bp_xid ) ) ) ; if ( EXTRACT_16BITS ( & bp -> bp_secs ) ) ND_PRINT ( ( ndo , \",<S2SV_blank>secs<S2SV_blank>%d\" , EXTRACT_16BITS ( & bp -> bp_secs ) ) ) ; <S2SV_StartBug> ND_PRINT ( ( ndo , \",<S2SV_blank>Flags<S2SV_blank>[%s]\" , <S2SV_EndBug> bittok2str ( bootp_flag_values , \"none\" , EXTRACT_16BITS ( & bp -> bp_flags ) ) ) ) ; if ( ndo -> ndo_vflag > 1 ) ND_PRINT ( ( ndo , \"<S2SV_blank>(0x%04x)\" , EXTRACT_16BITS ( & bp -> bp_flags ) ) ) ; ND_TCHECK ( bp -> bp_ciaddr ) ; if ( EXTRACT_32BITS ( & bp -> bp_ciaddr . s_addr ) ) ND_PRINT ( ( ndo , \"\\\\n\\\\t<S2SV_blank><S2SV_blank>Client-IP<S2SV_blank>%s\" , ipaddr_string ( ndo , & bp -> bp_ciaddr ) ) ) ; ND_TCHECK ( bp -> bp_yiaddr ) ; if ( EXTRACT_32BITS ( & bp -> bp_yiaddr . s_addr ) ) ND_PRINT ( ( ndo , \"\\\\n\\\\t<S2SV_blank><S2SV_blank>Your-IP<S2SV_blank>%s\" , ipaddr_string ( ndo , & bp -> bp_yiaddr ) ) ) ; ND_TCHECK ( bp -> bp_siaddr ) ; if ( EXTRACT_32BITS ( & bp -> bp_siaddr . s_addr ) ) ND_PRINT ( ( ndo , \"\\\\n\\\\t<S2SV_blank><S2SV_blank>Server-IP<S2SV_blank>%s\" , ipaddr_string ( ndo , & bp -> bp_siaddr ) ) ) ; ND_TCHECK ( bp -> bp_giaddr ) ; if ( EXTRACT_32BITS ( & bp -> bp_giaddr . s_addr ) ) ND_PRINT ( ( ndo , \"\\\\n\\\\t<S2SV_blank><S2SV_blank>Gateway-IP<S2SV_blank>%s\" , ipaddr_string ( ndo , & bp -> bp_giaddr ) ) ) ; if ( bp -> bp_htype == 1 && bp -> bp_hlen == 6 ) { ND_TCHECK2 ( bp -> bp_chaddr [ 0 ] , 6 ) ; ND_PRINT ( ( ndo , \"\\\\n\\\\t<S2SV_blank><S2SV_blank>Client-Ethernet-Address<S2SV_blank>%s\" , etheraddr_string ( ndo , bp -> bp_chaddr ) ) ) ; } ND_TCHECK2 ( bp -> bp_sname [ 0 ] , 1 ) ; if ( * bp -> bp_sname ) { ND_PRINT ( ( ndo , \"\\\\n\\\\t<S2SV_blank><S2SV_blank>sname<S2SV_blank>\\\\\"\" ) ) ; if ( fn_printztn ( ndo , bp -> bp_sname , ( u_int ) sizeof bp -> bp_sname , ndo -> ndo_snapend ) ) { ND_PRINT ( ( ndo , \"\\\\\"\" ) ) ; ND_PRINT ( ( ndo , \"%s\" , tstr + 1 ) ) ; return ; } ND_PRINT ( ( ndo , \"\\\\\"\" ) ) ; } ND_TCHECK2 ( bp -> bp_file [ 0 ] , 1 ) ; if ( * bp -> bp_file ) { ND_PRINT ( ( ndo , \"\\\\n\\\\t<S2SV_blank><S2SV_blank>file<S2SV_blank>\\\\\"\" ) ) ; if ( fn_printztn ( ndo , bp -> bp_file , ( u_int ) sizeof bp -> bp_file , ndo -> ndo_snapend ) ) { ND_PRINT ( ( ndo , \"\\\\\"\" ) ) ; ND_PRINT ( ( ndo , \"%s\" , tstr + 1 ) ) ; return ; } ND_PRINT ( ( ndo , \"\\\\\"\" ) ) ; } ND_TCHECK ( bp -> bp_vend [ 0 ] ) ; if ( memcmp ( ( const char * ) bp -> bp_vend , vm_rfc1048 , sizeof ( uint32_t ) ) == 0 ) rfc1048_print ( ndo , bp -> bp_vend ) ; else if ( memcmp ( ( const char * ) bp -> bp_vend , vm_cmu , sizeof ( uint32_t ) ) == 0 ) cmu_print ( ndo , bp -> bp_vend ) ; else { uint32_t ul ; ul = EXTRACT_32BITS ( & bp -> bp_vend ) ; if ( ul != 0 ) ND_PRINT ( ( ndo , \"\\\\n\\\\t<S2SV_blank><S2SV_blank>Vendor-#0x%x\" , ul ) ) ; } return ; trunc : ND_PRINT ( ( ndo , \"%s\" , tstr ) ) ; }\n","target":"<S2SV_ModStart> ) ) ; ND_TCHECK ( bp -> bp_flags ) ;\n","project_and_commit_id":"the-tcpdump-group@tcpdump/29e5470e6ab84badbc31f4532bb7554a796d9d52","cve_id":"CVE-2017-13028","original_address":"https://github.com/the-tcpdump-group/tcpdump/commit/29e5470e6ab84badbc31f4532bb7554a796d9d52","time":"2017-09-14T06:29Z"},
	{"Unnamed: 0":3107,"cwe_id":"CWE-119","source":"CWE-119 static int cac_read_binary ( sc_card_t * card , unsigned int idx , unsigned char * buf , size_t count , unsigned long flags ) { cac_private_data_t * priv = CAC_DATA ( card ) ; int r = 0 ; u8 * val = NULL ; u8 * cert_ptr ; <S2SV_StartBug> size_t val_len ; <S2SV_EndBug> size_t len , cert_len ; u8 cert_type ; SC_FUNC_CALLED ( card -> ctx , SC_LOG_DEBUG_VERBOSE ) ; if ( priv -> cached ) { sc_log ( card -> ctx , \"returning<S2SV_blank>cached<S2SV_blank>value<S2SV_blank>idx=%d<S2SV_blank>count=%\" SC_FORMAT_LEN_SIZE_T \"u\" , idx , count ) ; if ( idx > priv -> cache_buf_len ) { LOG_FUNC_RETURN ( card -> ctx , SC_ERROR_FILE_END_REACHED ) ; } len = MIN ( count , priv -> cache_buf_len - idx ) ; memcpy ( buf , & priv -> cache_buf [ idx ] , len ) ; LOG_FUNC_RETURN ( card -> ctx , len ) ; } sc_log ( card -> ctx , \"clearing<S2SV_blank>cache<S2SV_blank>idx=%d<S2SV_blank>count=%\" SC_FORMAT_LEN_SIZE_T \"u\" , idx , count ) ; free ( priv -> cache_buf ) ; priv -> cache_buf = NULL ; priv -> cache_buf_len = 0 ; r = cac_cac1_get_certificate ( card , & val , & val_len ) ; if ( r < 0 ) goto done ; if ( val_len < 1 ) { r = SC_ERROR_INVALID_DATA ; goto done ; } cert_type = val [ 0 ] ; cert_ptr = val + 1 ; cert_len = val_len - 1 ; if ( ( cert_type & 0x3 ) == 1 ) { # ifdef ENABLE_ZLIB r = sc_decompress_alloc ( & priv -> cache_buf , & priv -> cache_buf_len , cert_ptr , cert_len , COMPRESSION_AUTO ) ; # else sc_log ( card -> ctx , \"CAC<S2SV_blank>compression<S2SV_blank>not<S2SV_blank>supported,<S2SV_blank>no<S2SV_blank>zlib\" ) ; r = SC_ERROR_NOT_SUPPORTED ; # endif if ( r ) goto done ; } else if ( cert_len > 0 ) { priv -> cache_buf = malloc ( cert_len ) ; if ( priv -> cache_buf == NULL ) { r = SC_ERROR_OUT_OF_MEMORY ; goto done ; } priv -> cache_buf_len = cert_len ; memcpy ( priv -> cache_buf , cert_ptr , cert_len ) ; } priv -> cached = 1 ; len = MIN ( count , priv -> cache_buf_len - idx ) ; if ( len && priv -> cache_buf ) memcpy ( buf , & priv -> cache_buf [ idx ] , len ) ; r = len ; done : if ( val ) free ( val ) ; LOG_FUNC_RETURN ( card -> ctx , r ) ; }\n","target":"<S2SV_ModStart> ; size_t val_len = 0\n","project_and_commit_id":"OpenSC@OpenSC/b75c002cfb1fd61cd20ec938ff4937d7b1a94278","cve_id":"CVE-2019-19481","original_address":"https://github.com/OpenSC/OpenSC/commit/b75c002cfb1fd61cd20ec938ff4937d7b1a94278","time":"2019-12-01T23:15Z"},
	{"Unnamed: 0":2517,"cwe_id":"CWE-000","source":"CWE-000 int key_reject_and_link ( struct key * key , unsigned timeout , unsigned error , struct key * keyring , struct key * authkey ) { struct assoc_array_edit * edit ; struct timespec now ; int ret , awaken , link_ret = 0 ; key_check ( key ) ; key_check ( keyring ) ; awaken = 0 ; ret = - EBUSY ; if ( keyring ) { if ( keyring -> restrict_link ) return - EPERM ; link_ret = __key_link_begin ( keyring , & key -> index_key , & edit ) ; } mutex_lock ( & key_construction_mutex ) ; if ( ! test_bit ( KEY_FLAG_INSTANTIATED , & key -> flags ) ) { atomic_inc ( & key -> user -> nikeys ) ; key -> reject_error = - error ; smp_wmb ( ) ; set_bit ( KEY_FLAG_NEGATIVE , & key -> flags ) ; set_bit ( KEY_FLAG_INSTANTIATED , & key -> flags ) ; now = current_kernel_time ( ) ; key -> expiry = now . tv_sec + timeout ; key_schedule_gc ( key -> expiry + key_gc_delay ) ; if ( test_and_clear_bit ( KEY_FLAG_USER_CONSTRUCT , & key -> flags ) ) awaken = 1 ; ret = 0 ; if ( keyring && link_ret == 0 ) __key_link ( key , & edit ) ; if ( authkey ) key_revoke ( authkey ) ; } mutex_unlock ( & key_construction_mutex ) ; <S2SV_StartBug> if ( keyring ) <S2SV_EndBug> __key_link_end ( keyring , & key -> index_key , edit ) ; if ( awaken ) wake_up_bit ( & key -> flags , KEY_FLAG_USER_CONSTRUCT ) ; return ret == 0 ? link_ret : ret ; }\n","target":"<S2SV_ModStart> if ( keyring && link_ret == 0\n","project_and_commit_id":"torvalds@linux/38327424b40bcebe2de92d07312c89360ac9229a","cve_id":"CVE-2016-4470","original_address":"https://github.com/torvalds/linux/commit/38327424b40bcebe2de92d07312c89360ac9229a","time":"2016-06-27T10:59Z"},
	{"Unnamed: 0":1617,"cwe_id":"CWE-190","source":"CWE-190 static int jpc_pi_nextcprl ( register jpc_pi_t * pi ) { int rlvlno ; jpc_pirlvl_t * pirlvl ; jpc_pchg_t * pchg ; int prchind ; int prcvind ; int * prclyrno ; uint_fast32_t trx0 ; uint_fast32_t try0 ; uint_fast32_t r ; uint_fast32_t rpx ; uint_fast32_t rpy ; pchg = pi -> pchg ; if ( ! pi -> prgvolfirst ) { goto skip ; } else { pi -> prgvolfirst = 0 ; } for ( pi -> compno = pchg -> compnostart , pi -> picomp = & pi -> picomps [ pi -> compno ] ; pi -> compno < JAS_CAST ( int , pchg -> compnoend ) && pi -> compno < pi -> numcomps ; ++ pi -> compno , ++ pi -> picomp ) { pirlvl = pi -> picomp -> pirlvls ; <S2SV_StartBug> pi -> xstep = pi -> picomp -> hsamp * ( 1 << ( pirlvl -> prcwidthexpn + <S2SV_EndBug> pi -> picomp -> numrlvls - 1 ) ) ; <S2SV_StartBug> pi -> ystep = pi -> picomp -> vsamp * ( 1 << ( pirlvl -> prcheightexpn + <S2SV_EndBug> pi -> picomp -> numrlvls - 1 ) ) ; for ( rlvlno = 1 , pirlvl = & pi -> picomp -> pirlvls [ 1 ] ; rlvlno < pi -> picomp -> numrlvls ; ++ rlvlno , ++ pirlvl ) { <S2SV_StartBug> pi -> xstep = JAS_MIN ( pi -> xstep , pi -> picomp -> hsamp * ( 1 << <S2SV_EndBug> ( pirlvl -> prcwidthexpn + pi -> picomp -> numrlvls - rlvlno - 1 ) ) ) ; <S2SV_StartBug> pi -> ystep = JAS_MIN ( pi -> ystep , pi -> picomp -> vsamp * ( 1 << <S2SV_EndBug> ( pirlvl -> prcheightexpn + pi -> picomp -> numrlvls - rlvlno - 1 ) ) ) ; } for ( pi -> y = pi -> ystart ; pi -> y < pi -> yend ; pi -> y += pi -> ystep - ( pi -> y % pi -> ystep ) ) { for ( pi -> x = pi -> xstart ; pi -> x < pi -> xend ; pi -> x += pi -> xstep - ( pi -> x % pi -> xstep ) ) { for ( pi -> rlvlno = pchg -> rlvlnostart , pi -> pirlvl = & pi -> picomp -> pirlvls [ pi -> rlvlno ] ; pi -> rlvlno < pi -> picomp -> numrlvls && pi -> rlvlno < pchg -> rlvlnoend ; ++ pi -> rlvlno , ++ pi -> pirlvl ) { if ( pi -> pirlvl -> numprcs == 0 ) { continue ; } r = pi -> picomp -> numrlvls - 1 - pi -> rlvlno ; trx0 = JPC_CEILDIV ( pi -> xstart , pi -> picomp -> hsamp << r ) ; try0 = JPC_CEILDIV ( pi -> ystart , pi -> picomp -> vsamp << r ) ; rpx = r + pi -> pirlvl -> prcwidthexpn ; rpy = r + pi -> pirlvl -> prcheightexpn ; if ( ( ( pi -> x == pi -> xstart && ( ( trx0 << r ) % ( 1 << rpx ) ) ) || ! ( pi -> x % ( pi -> picomp -> hsamp << rpx ) ) ) && ( ( pi -> y == pi -> ystart && ( ( try0 << r ) % ( 1 << rpy ) ) ) || ! ( pi -> y % ( pi -> picomp -> vsamp << rpy ) ) ) ) { prchind = JPC_FLOORDIVPOW2 ( JPC_CEILDIV ( pi -> x , pi -> picomp -> hsamp << r ) , pi -> pirlvl -> prcwidthexpn ) - JPC_FLOORDIVPOW2 ( trx0 , pi -> pirlvl -> prcwidthexpn ) ; prcvind = JPC_FLOORDIVPOW2 ( JPC_CEILDIV ( pi -> y , pi -> picomp -> vsamp << r ) , pi -> pirlvl -> prcheightexpn ) - JPC_FLOORDIVPOW2 ( try0 , pi -> pirlvl -> prcheightexpn ) ; pi -> prcno = prcvind * pi -> pirlvl -> numhprcs + prchind ; assert ( pi -> prcno < pi -> pirlvl -> numprcs ) ; for ( pi -> lyrno = 0 ; pi -> lyrno < pi -> numlyrs && pi -> lyrno < JAS_CAST ( int , pchg -> lyrnoend ) ; ++ pi -> lyrno ) { prclyrno = & pi -> pirlvl -> prclyrnos [ pi -> prcno ] ; if ( pi -> lyrno >= * prclyrno ) { ++ ( * prclyrno ) ; return 0 ; } skip : ; } } } } } } return 1 ; }\n","target":"<S2SV_ModStart> hsamp * ( JAS_CAST ( uint_fast32_t , 1 ) << <S2SV_ModEnd> ( pirlvl -> <S2SV_ModStart> vsamp * ( JAS_CAST ( uint_fast32_t , 1 ) << <S2SV_ModEnd> ( pirlvl -> <S2SV_ModStart> -> hsamp * ( JAS_CAST ( uint_fast32_t , 1 ) << <S2SV_ModEnd> ( pirlvl -> <S2SV_ModStart> -> vsamp * ( JAS_CAST ( uint_fast32_t , 1 ) << <S2SV_ModEnd> ( pirlvl ->\n","project_and_commit_id":"mdadams@jasper/1f0dfe5a42911b6880a1445f13f6d615ddb55387","cve_id":"CVE-2016-10251","original_address":"https://github.com/mdadams/jasper/commit/1f0dfe5a42911b6880a1445f13f6d615ddb55387","time":"2017-03-15T14:59Z"},
	{"Unnamed: 0":2747,"cwe_id":"CWE-200","source":"CWE-200 void __ip_select_ident ( struct net * net , struct iphdr * iph , int segs ) { <S2SV_StartBug> static u32 ip_idents_hashrnd __read_mostly ; <S2SV_EndBug> u32 hash , id ; <S2SV_StartBug> net_get_random_once ( & ip_idents_hashrnd , sizeof ( ip_idents_hashrnd ) ) ; <S2SV_EndBug> <S2SV_StartBug> hash = jhash_3words ( ( __force u32 ) iph -> daddr , <S2SV_EndBug> ( __force u32 ) iph -> saddr , <S2SV_StartBug> iph -> protocol ^ net_hash_mix ( net ) , <S2SV_EndBug> ip_idents_hashrnd ) ; id = ip_idents_reserve ( hash , segs ) ; iph -> id = htons ( id ) ; }\n","target":"<S2SV_ModStart> segs ) { <S2SV_ModEnd> u32 hash , <S2SV_ModStart> , id ; if ( unlikely ( siphash_key_is_zero ( & net -> ipv4 . ip_id_key ) ) ) get_random_bytes ( & net -> ipv4 . ip_id_key <S2SV_ModEnd> , sizeof ( <S2SV_ModStart> , sizeof ( net -> ipv4 . ip_id_key <S2SV_ModEnd> ) ) ; <S2SV_ModStart> ; hash = siphash_3u32 <S2SV_ModEnd> ( ( __force <S2SV_ModStart> iph -> protocol , & net -> ipv4 . ip_id_key <S2SV_ModEnd> ) ; id\n","project_and_commit_id":"torvalds@linux/df453700e8d81b1bdafdf684365ee2b9431fb702","cve_id":"CVE-2019-10638","original_address":"https://github.com/torvalds/linux/commit/df453700e8d81b1bdafdf684365ee2b9431fb702","time":"2019-07-05T23:15Z"},
	{"Unnamed: 0":3630,"cwe_id":"CWE-434","source":"CWE-434 static int zipfileUpdate ( sqlite3_vtab * pVtab , int nVal , sqlite3_value * * apVal , sqlite_int64 * pRowid ) { ZipfileTab * pTab = ( ZipfileTab * ) pVtab ; int rc = SQLITE_OK ; ZipfileEntry * pNew = 0 ; u32 mode = 0 ; u32 mTime = 0 ; i64 sz = 0 ; const char * zPath = 0 ; int nPath = 0 ; const u8 * pData = 0 ; int nData = 0 ; int iMethod = 0 ; u8 * pFree = 0 ; char * zFree = 0 ; ZipfileEntry * pOld = 0 ; ZipfileEntry * pOld2 = 0 ; int bUpdate = 0 ; int bIsDir = 0 ; u32 iCrc32 = 0 ; if ( pTab -> pWriteFd == 0 ) { rc = zipfileBegin ( pVtab ) ; if ( rc != SQLITE_OK ) return rc ; } if ( sqlite3_value_type ( apVal [ 0 ] ) != SQLITE_NULL ) { const char * zDelete = ( const char * ) sqlite3_value_text ( apVal [ 0 ] ) ; int nDelete = ( int ) strlen ( zDelete ) ; if ( nVal > 1 ) { const char * zUpdate = ( const char * ) sqlite3_value_text ( apVal [ 1 ] ) ; if ( zUpdate && zipfileComparePath ( zUpdate , zDelete , nDelete ) != 0 ) { bUpdate = 1 ; } } for ( pOld = pTab -> pFirstEntry ; 1 ; pOld = pOld -> pNext ) { if ( zipfileComparePath ( pOld -> cds . zFile , zDelete , nDelete ) == 0 ) { break ; } assert ( pOld -> pNext ) ; } } if ( nVal > 1 ) { if ( sqlite3_value_type ( apVal [ 5 ] ) != SQLITE_NULL ) { zipfileTableErr ( pTab , \"sz<S2SV_blank>must<S2SV_blank>be<S2SV_blank>NULL\" ) ; rc = SQLITE_CONSTRAINT ; } if ( sqlite3_value_type ( apVal [ 6 ] ) != SQLITE_NULL ) { zipfileTableErr ( pTab , \"rawdata<S2SV_blank>must<S2SV_blank>be<S2SV_blank>NULL\" ) ; rc = SQLITE_CONSTRAINT ; } if ( rc == SQLITE_OK ) { if ( sqlite3_value_type ( apVal [ 7 ] ) == SQLITE_NULL ) { bIsDir = 1 ; } else { const u8 * aIn = sqlite3_value_blob ( apVal [ 7 ] ) ; int nIn = sqlite3_value_bytes ( apVal [ 7 ] ) ; int bAuto = sqlite3_value_type ( apVal [ 8 ] ) == SQLITE_NULL ; iMethod = sqlite3_value_int ( apVal [ 8 ] ) ; sz = nIn ; pData = aIn ; nData = nIn ; if ( iMethod != 0 && iMethod != 8 ) { zipfileTableErr ( pTab , \"unknown<S2SV_blank>compression<S2SV_blank>method:<S2SV_blank>%d\" , iMethod ) ; rc = SQLITE_CONSTRAINT ; } else { if ( bAuto || iMethod ) { int nCmp ; rc = zipfileDeflate ( aIn , nIn , & pFree , & nCmp , & pTab -> base . zErrMsg ) ; if ( rc == SQLITE_OK ) { if ( iMethod || nCmp < nIn ) { iMethod = 8 ; pData = pFree ; nData = nCmp ; } } } iCrc32 = crc32 ( 0 , aIn , nIn ) ; } } } if ( rc == SQLITE_OK ) { rc = zipfileGetMode ( apVal [ 3 ] , bIsDir , & mode , & pTab -> base . zErrMsg ) ; } if ( rc == SQLITE_OK ) { zPath = ( const char * ) sqlite3_value_text ( apVal [ 2 ] ) ; <S2SV_StartBug> nPath = ( int ) strlen ( zPath ) ; <S2SV_EndBug> mTime = zipfileGetTime ( apVal [ 4 ] ) ; } if ( rc == SQLITE_OK && bIsDir ) { if ( zPath [ nPath - 1 ] != '/' ) { zFree = sqlite3_mprintf ( \"%s/\" , zPath ) ; if ( zFree == 0 ) { rc = SQLITE_NOMEM ; } zPath = ( const char * ) zFree ; nPath ++ ; } } if ( ( pOld == 0 || bUpdate ) && rc == SQLITE_OK ) { ZipfileEntry * p ; for ( p = pTab -> pFirstEntry ; p ; p = p -> pNext ) { if ( zipfileComparePath ( p -> cds . zFile , zPath , nPath ) == 0 ) { switch ( sqlite3_vtab_on_conflict ( pTab -> db ) ) { case SQLITE_IGNORE : { goto zipfile_update_done ; } case SQLITE_REPLACE : { pOld2 = p ; break ; } default : { zipfileTableErr ( pTab , \"duplicate<S2SV_blank>name:<S2SV_blank>\\\\\"%s\\\\\"\" , zPath ) ; rc = SQLITE_CONSTRAINT ; break ; } } break ; } } } if ( rc == SQLITE_OK ) { pNew = zipfileNewEntry ( zPath ) ; if ( pNew == 0 ) { rc = SQLITE_NOMEM ; } else { pNew -> cds . iVersionMadeBy = ZIPFILE_NEWENTRY_MADEBY ; pNew -> cds . iVersionExtract = ZIPFILE_NEWENTRY_REQUIRED ; pNew -> cds . flags = ZIPFILE_NEWENTRY_FLAGS ; pNew -> cds . iCompression = ( u16 ) iMethod ; zipfileMtimeToDos ( & pNew -> cds , mTime ) ; pNew -> cds . crc32 = iCrc32 ; pNew -> cds . szCompressed = nData ; pNew -> cds . szUncompressed = ( u32 ) sz ; pNew -> cds . iExternalAttr = ( mode << 16 ) ; pNew -> cds . iOffset = ( u32 ) pTab -> szCurrent ; pNew -> cds . nFile = ( u16 ) nPath ; pNew -> mUnixTime = ( u32 ) mTime ; rc = zipfileAppendEntry ( pTab , pNew , pData , nData ) ; zipfileAddEntry ( pTab , pOld , pNew ) ; } } } if ( rc == SQLITE_OK && ( pOld || pOld2 ) ) { ZipfileCsr * pCsr ; for ( pCsr = pTab -> pCsrList ; pCsr ; pCsr = pCsr -> pCsrNext ) { if ( pCsr -> pCurrent && ( pCsr -> pCurrent == pOld || pCsr -> pCurrent == pOld2 ) ) { pCsr -> pCurrent = pCsr -> pCurrent -> pNext ; pCsr -> bNoop = 1 ; } } zipfileRemoveEntryFromList ( pTab , pOld ) ; zipfileRemoveEntryFromList ( pTab , pOld2 ) ; } zipfile_update_done : sqlite3_free ( pFree ) ; sqlite3_free ( zFree ) ; return rc ; }\n","target":"<S2SV_ModStart> ] ) ; if ( zPath == 0 ) zPath = \"\" ;\n","project_and_commit_id":"sqlite@sqlite/54d501092d88c0cf89bec4279951f548fb0b8618","cve_id":"CVE-2019-19925","original_address":"https://github.com/sqlite/sqlite/commit/54d501092d88c0cf89bec4279951f548fb0b8618","time":"2019-12-24T17:15Z"},
	{"Unnamed: 0":3169,"cwe_id":"CWE-125","source":"CWE-125 static int validate_node ( node * tree ) { int type = TYPE ( tree ) ; int nch = NCH ( tree ) ; dfa * nt_dfa ; state * dfa_state ; int pos , arc ; assert ( ISNONTERMINAL ( type ) ) ; type -= NT_OFFSET ; if ( type >= _PyParser_Grammar . g_ndfas ) { PyErr_Format ( parser_error , \"Unrecognized<S2SV_blank>node<S2SV_blank>type<S2SV_blank>%d.\" , TYPE ( tree ) ) ; return 0 ; } nt_dfa = & _PyParser_Grammar . g_dfa [ type ] ; REQ ( tree , nt_dfa -> d_type ) ; dfa_state = & nt_dfa -> d_state [ nt_dfa -> d_initial ] ; for ( pos = 0 ; pos < nch ; ++ pos ) { node * ch = CHILD ( tree , pos ) ; int ch_type = TYPE ( ch ) ; <S2SV_StartBug> for ( arc = 0 ; arc < dfa_state -> s_narcs ; ++ arc ) { <S2SV_EndBug> short a_label = dfa_state -> s_arc [ arc ] . a_lbl ; assert ( a_label < _PyParser_Grammar . g_ll . ll_nlabels ) ; if ( _PyParser_Grammar . g_ll . ll_label [ a_label ] . lb_type == ch_type ) { if ( ISNONTERMINAL ( ch_type ) && ! validate_node ( ch ) ) return 0 ; dfa_state = & nt_dfa -> d_state [ dfa_state -> s_arc [ arc ] . a_arrow ] ; goto arc_found ; } } { short a_label = dfa_state -> s_arc -> a_lbl ; int next_type ; if ( ! a_label ) goto illegal_num_children ; next_type = _PyParser_Grammar . g_ll . ll_label [ a_label ] . lb_type ; if ( ISNONTERMINAL ( next_type ) ) PyErr_Format ( parser_error , \"Expected<S2SV_blank>node<S2SV_blank>type<S2SV_blank>%d,<S2SV_blank>got<S2SV_blank>%d.\" , next_type , ch_type ) ; else PyErr_Format ( parser_error , \"Illegal<S2SV_blank>terminal:<S2SV_blank>expected<S2SV_blank>%s.\" , _PyParser_TokenNames [ next_type ] ) ; return 0 ; } arc_found : continue ; } for ( arc = 0 ; arc < dfa_state -> s_narcs ; ++ arc ) { if ( ! dfa_state -> s_arc [ arc ] . a_lbl ) { return 1 ; } } illegal_num_children : PyErr_Format ( parser_error , \"Illegal<S2SV_blank>number<S2SV_blank>of<S2SV_blank>children<S2SV_blank>for<S2SV_blank>%s<S2SV_blank>node.\" , nt_dfa -> d_name ) ; return 0 ; }\n","target":"<S2SV_ModStart> ch ) ; if ( ch_type == suite && TYPE ( tree ) == funcdef ) { ch_type = func_body_suite ; }\n","project_and_commit_id":"python@typed_ast/dcfcd146f8e6fc5c2fc16a4c192a0c5f5ca8c53c","cve_id":"CVE-2019-19275","original_address":"https://github.com/python/typed_ast/commit/dcfcd146f8e6fc5c2fc16a4c192a0c5f5ca8c53c","time":"2019-11-26T15:15Z"},
	{"Unnamed: 0":2638,"cwe_id":"CWE-000","source":"CWE-000 static int tty_open ( struct inode * inode , struct file * filp ) { struct tty_struct * tty = NULL ; int noctty , retval ; struct tty_driver * driver ; int index ; dev_t device = inode -> i_rdev ; unsigned saved_flags = filp -> f_flags ; nonseekable_open ( inode , filp ) ; retry_open : noctty = filp -> f_flags & O_NOCTTY ; index = - 1 ; retval = 0 ; mutex_lock ( & tty_mutex ) ; tty_lock ( ) ; if ( device == MKDEV ( TTYAUX_MAJOR , 0 ) ) { tty = get_current_tty ( ) ; if ( ! tty ) { tty_unlock ( ) ; mutex_unlock ( & tty_mutex ) ; return - ENXIO ; } driver = tty_driver_kref_get ( tty -> driver ) ; index = tty -> index ; filp -> f_flags |= O_NONBLOCK ; tty_kref_put ( tty ) ; goto got_driver ; } # ifdef CONFIG_VT if ( device == MKDEV ( TTY_MAJOR , 0 ) ) { extern struct tty_driver * console_driver ; driver = tty_driver_kref_get ( console_driver ) ; index = fg_console ; noctty = 1 ; goto got_driver ; } # endif if ( device == MKDEV ( TTYAUX_MAJOR , 1 ) ) { struct tty_driver * console_driver = console_device ( & index ) ; if ( console_driver ) { driver = tty_driver_kref_get ( console_driver ) ; if ( driver ) { filp -> f_flags |= O_NONBLOCK ; noctty = 1 ; goto got_driver ; } } tty_unlock ( ) ; mutex_unlock ( & tty_mutex ) ; return - ENODEV ; } driver = get_tty_driver ( device , & index ) ; if ( ! driver ) { tty_unlock ( ) ; mutex_unlock ( & tty_mutex ) ; return - ENODEV ; } got_driver : if ( ! tty ) { tty = tty_driver_lookup_tty ( driver , inode , index ) ; if ( IS_ERR ( tty ) ) { tty_unlock ( ) ; mutex_unlock ( & tty_mutex ) ; <S2SV_StartBug> return PTR_ERR ( tty ) ; <S2SV_EndBug> } } if ( tty ) { retval = tty_reopen ( tty ) ; if ( retval ) tty = ERR_PTR ( retval ) ; } else tty = tty_init_dev ( driver , index , 0 ) ; mutex_unlock ( & tty_mutex ) ; tty_driver_kref_put ( driver ) ; if ( IS_ERR ( tty ) ) { tty_unlock ( ) ; return PTR_ERR ( tty ) ; } retval = tty_add_file ( tty , filp ) ; if ( retval ) { tty_unlock ( ) ; tty_release ( inode , filp ) ; return retval ; } check_tty_count ( tty , \"tty_open\" ) ; if ( tty -> driver -> type == TTY_DRIVER_TYPE_PTY && tty -> driver -> subtype == PTY_TYPE_MASTER ) noctty = 1 ; # ifdef TTY_DEBUG_HANGUP printk ( KERN_DEBUG \"opening<S2SV_blank>%s...\" , tty -> name ) ; # endif if ( tty -> ops -> open ) retval = tty -> ops -> open ( tty , filp ) ; else retval = - ENODEV ; filp -> f_flags = saved_flags ; if ( ! retval && test_bit ( TTY_EXCLUSIVE , & tty -> flags ) && ! capable ( CAP_SYS_ADMIN ) ) retval = - EBUSY ; if ( retval ) { # ifdef TTY_DEBUG_HANGUP printk ( KERN_DEBUG \"error<S2SV_blank>%d<S2SV_blank>in<S2SV_blank>opening<S2SV_blank>%s...\" , retval , tty -> name ) ; # endif tty_unlock ( ) ; tty_release ( inode , filp ) ; if ( retval != - ERESTARTSYS ) return retval ; if ( signal_pending ( current ) ) return retval ; schedule ( ) ; tty_lock ( ) ; if ( filp -> f_op == & hung_up_tty_fops ) filp -> f_op = & tty_fops ; tty_unlock ( ) ; goto retry_open ; } tty_unlock ( ) ; mutex_lock ( & tty_mutex ) ; tty_lock ( ) ; spin_lock_irq ( & current -> sighand -> siglock ) ; if ( ! noctty && current -> signal -> leader && ! current -> signal -> tty && tty -> session == NULL ) __proc_set_tty ( current , tty ) ; spin_unlock_irq ( & current -> sighand -> siglock ) ; tty_unlock ( ) ; mutex_unlock ( & tty_mutex ) ; return 0 ; }\n","target":"<S2SV_ModStart> tty_mutex ) ; tty_driver_kref_put ( driver ) ;\n","project_and_commit_id":"torvalds@linux/c290f8358acaeffd8e0c551ddcc24d1206143376","cve_id":"CVE-2011-5321","original_address":"https://github.com/torvalds/linux/commit/c290f8358acaeffd8e0c551ddcc24d1206143376","time":"2016-05-02T10:59Z"},
	{"Unnamed: 0":944,"cwe_id":"CWE-125","source":"CWE-125 int ares_parse_a_reply ( const unsigned char * abuf , int alen , struct hostent * * host ) { unsigned int qdcount , ancount ; int status , i , rr_type , rr_class , rr_len , naddrs ; long int len ; int naliases ; const unsigned char * aptr ; char * hostname , * rr_name , * rr_data , * * aliases ; struct in_addr * addrs ; struct hostent * hostent ; * host = NULL ; if ( alen < HFIXEDSZ ) return ARES_EBADRESP ; qdcount = DNS_HEADER_QDCOUNT ( abuf ) ; ancount = DNS_HEADER_ANCOUNT ( abuf ) ; if ( qdcount != 1 ) return ARES_EBADRESP ; aptr = abuf + HFIXEDSZ ; status = ares_expand_name ( aptr , abuf , alen , & hostname , & len ) ; if ( status != ARES_SUCCESS ) return status ; if ( aptr + len + QFIXEDSZ > abuf + alen ) { free ( hostname ) ; return ARES_EBADRESP ; } aptr += len + QFIXEDSZ ; addrs = malloc ( ancount * sizeof ( struct in_addr ) ) ; if ( ! addrs ) { free ( hostname ) ; return ARES_ENOMEM ; } aliases = malloc ( ( ancount + 1 ) * sizeof ( char * ) ) ; if ( ! aliases ) { free ( hostname ) ; free ( addrs ) ; return ARES_ENOMEM ; } naddrs = 0 ; naliases = 0 ; for ( i = 0 ; i < ( int ) ancount ; i ++ ) { status = ares_expand_name ( aptr , abuf , alen , & rr_name , & len ) ; if ( status != ARES_SUCCESS ) break ; aptr += len ; if ( aptr + RRFIXEDSZ > abuf + alen ) { free ( rr_name ) ; status = ARES_EBADRESP ; break ; } rr_type = DNS_RR_TYPE ( aptr ) ; rr_class = DNS_RR_CLASS ( aptr ) ; rr_len = DNS_RR_LEN ( aptr ) ; <S2SV_StartBug> aptr += RRFIXEDSZ ; <S2SV_EndBug> if ( rr_class == C_IN && rr_type == T_A && rr_len == sizeof ( struct in_addr ) && strcasecmp ( rr_name , hostname ) == 0 ) { memcpy ( & addrs [ naddrs ] , aptr , sizeof ( struct in_addr ) ) ; naddrs ++ ; status = ARES_SUCCESS ; } if ( rr_class == C_IN && rr_type == T_CNAME ) { aliases [ naliases ] = rr_name ; naliases ++ ; status = ares_expand_name ( aptr , abuf , alen , & rr_data , & len ) ; if ( status != ARES_SUCCESS ) break ; free ( hostname ) ; hostname = rr_data ; } else free ( rr_name ) ; aptr += rr_len ; if ( aptr > abuf + alen ) { status = ARES_EBADRESP ; break ; } } if ( status == ARES_SUCCESS && naddrs == 0 ) status = ARES_ENODATA ; if ( status == ARES_SUCCESS ) { aliases [ naliases ] = NULL ; hostent = malloc ( sizeof ( struct hostent ) ) ; if ( hostent ) { hostent -> h_addr_list = malloc ( ( naddrs + 1 ) * sizeof ( char * ) ) ; if ( hostent -> h_addr_list ) { hostent -> h_name = hostname ; hostent -> h_aliases = aliases ; hostent -> h_addrtype = AF_INET ; hostent -> h_length = sizeof ( struct in_addr ) ; for ( i = 0 ; i < naddrs ; i ++ ) hostent -> h_addr_list [ i ] = ( char * ) & addrs [ i ] ; hostent -> h_addr_list [ naddrs ] = NULL ; * host = hostent ; return ARES_SUCCESS ; } free ( hostent ) ; } status = ARES_ENOMEM ; } for ( i = 0 ; i < naliases ; i ++ ) free ( aliases [ i ] ) ; free ( aliases ) ; free ( addrs ) ; free ( hostname ) ; return status ; }\n","target":"<S2SV_ModStart> += RRFIXEDSZ ; if ( aptr + rr_len > abuf + alen ) { free ( rr_name ) ; status = ARES_EBADRESP ; break ; }\n","project_and_commit_id":"resiprocate@resiprocate/d67a9ca6fd06ca65d23e313bdbad1ef4dd3aa0df","cve_id":"CVE-2017-9454","original_address":"https://github.com/resiprocate/resiprocate/commit/d67a9ca6fd06ca65d23e313bdbad1ef4dd3aa0df","time":"2017-08-18T14:29Z"},
	{"Unnamed: 0":6723,"cwe_id":"CWE-200","source":"CWE-200 static int irda_recvmsg_dgram ( struct kiocb * iocb , struct socket * sock , struct msghdr * msg , size_t size , int flags ) { struct sock * sk = sock -> sk ; struct irda_sock * self = irda_sk ( sk ) ; struct sk_buff * skb ; size_t copied ; int err ; IRDA_DEBUG ( 4 , \"%s()\\\\n\" , __func__ ) ; <S2SV_StartBug> skb = skb_recv_datagram ( sk , flags & ~ MSG_DONTWAIT , <S2SV_EndBug> flags & MSG_DONTWAIT , & err ) ; if ( ! skb ) return err ; skb_reset_transport_header ( skb ) ; copied = skb -> len ; if ( copied > size ) { IRDA_DEBUG ( 2 , \"%s(),<S2SV_blank>Received<S2SV_blank>truncated<S2SV_blank>frame<S2SV_blank>(%zd<S2SV_blank><<S2SV_blank>%zd)!\\\\n\" , __func__ , copied , size ) ; copied = size ; msg -> msg_flags |= MSG_TRUNC ; } skb_copy_datagram_iovec ( skb , 0 , msg -> msg_iov , copied ) ; skb_free_datagram ( sk , skb ) ; if ( self -> rx_flow == FLOW_STOP ) { if ( ( atomic_read ( & sk -> sk_rmem_alloc ) << 2 ) <= sk -> sk_rcvbuf ) { IRDA_DEBUG ( 2 , \"%s(),<S2SV_blank>Starting<S2SV_blank>IrTTP\\\\n\" , __func__ ) ; self -> rx_flow = FLOW_START ; irttp_flow_request ( self -> tsap , FLOW_START ) ; } } return copied ; }\n","target":"<S2SV_ModStart> __func__ ) ; msg -> msg_namelen = 0 ;\n","project_and_commit_id":"torvalds@linux/5ae94c0d2f0bed41d6718be743985d61b7f5c47d","cve_id":"CVE-2013-3228","original_address":"https://github.com/torvalds/linux/commit/5ae94c0d2f0bed41d6718be743985d61b7f5c47d","time":"2013-04-22T11:41Z"},
	{"Unnamed: 0":4444,"cwe_id":"CWE-17","source":"CWE-17 static int __mkroute_input ( struct sk_buff * skb , const struct fib_result * res , struct in_device * in_dev , __be32 daddr , __be32 saddr , u32 tos ) { struct fib_nh_exception * fnhe ; struct rtable * rth ; int err ; struct in_device * out_dev ; unsigned int flags = 0 ; bool do_cache ; u32 itag = 0 ; out_dev = __in_dev_get_rcu ( FIB_RES_DEV ( * res ) ) ; if ( out_dev == NULL ) { net_crit_ratelimited ( \"Bug<S2SV_blank>in<S2SV_blank>ip_route_input_slow().<S2SV_blank>Please<S2SV_blank>report.\\\\n\" ) ; return - EINVAL ; } err = fib_validate_source ( skb , saddr , daddr , tos , FIB_RES_OIF ( * res ) , in_dev -> dev , in_dev , & itag ) ; if ( err < 0 ) { ip_handle_martian_source ( in_dev -> dev , in_dev , skb , daddr , saddr ) ; goto cleanup ; } do_cache = res -> fi && ! itag ; if ( out_dev == in_dev && err && IN_DEV_TX_REDIRECTS ( out_dev ) && <S2SV_StartBug> ( IN_DEV_SHARED_MEDIA ( out_dev ) || <S2SV_EndBug> <S2SV_StartBug> inet_addr_onlink ( out_dev , saddr , FIB_RES_GW ( * res ) ) ) ) { <S2SV_EndBug> flags |= RTCF_DOREDIRECT ; do_cache = false ; } if ( skb -> protocol != htons ( ETH_P_IP ) ) { if ( out_dev == in_dev && IN_DEV_PROXY_ARP_PVLAN ( in_dev ) == 0 ) { err = - EINVAL ; goto cleanup ; } } fnhe = find_exception ( & FIB_RES_NH ( * res ) , daddr ) ; if ( do_cache ) { if ( fnhe != NULL ) rth = rcu_dereference ( fnhe -> fnhe_rth_input ) ; else rth = rcu_dereference ( FIB_RES_NH ( * res ) . nh_rth_input ) ; if ( rt_cache_valid ( rth ) ) { skb_dst_set_noref ( skb , & rth -> dst ) ; goto out ; } } rth = rt_dst_alloc ( out_dev -> dev , IN_DEV_CONF_GET ( in_dev , NOPOLICY ) , IN_DEV_CONF_GET ( out_dev , NOXFRM ) , do_cache ) ; if ( ! rth ) { err = - ENOBUFS ; goto cleanup ; } rth -> rt_genid = rt_genid_ipv4 ( dev_net ( rth -> dst . dev ) ) ; rth -> rt_flags = flags ; rth -> rt_type = res -> type ; rth -> rt_is_input = 1 ; rth -> rt_iif = 0 ; rth -> rt_pmtu = 0 ; rth -> rt_gateway = 0 ; rth -> rt_uses_gateway = 0 ; INIT_LIST_HEAD ( & rth -> rt_uncached ) ; RT_CACHE_STAT_INC ( in_slow_tot ) ; rth -> dst . input = ip_forward ; rth -> dst . output = ip_output ; rt_set_nexthop ( rth , daddr , res , fnhe , res -> fi , res -> type , itag ) ; skb_dst_set ( skb , & rth -> dst ) ; out : err = 0 ; cleanup : return err ; }\n","target":"<S2SV_ModStart> out_dev ) && skb -> protocol == htons ( ETH_P_IP ) && <S2SV_ModStart> ) ) ) IPCB ( skb ) -> flags |= IPSKB_DOREDIRECT ; <S2SV_ModEnd> if ( skb\n","project_and_commit_id":"torvalds@linux/df4d92549f23e1c037e83323aff58a21b3de7fe0","cve_id":"CVE-2015-1465","original_address":"https://github.com/torvalds/linux/commit/df4d92549f23e1c037e83323aff58a21b3de7fe0","time":"2015-04-05T21:59Z"},
	{"Unnamed: 0":4812,"cwe_id":"CWE-20","source":"CWE-20 error_t ftpClientParseDirEntry ( char_t * line , FtpDirEntry * dirEntry ) { uint_t i ; size_t n ; char_t * p ; char_t * token ; static const char_t months [ 13 ] [ 4 ] = { \"<S2SV_blank><S2SV_blank><S2SV_blank>\" , \"Jan\" , \"Feb\" , \"Mar\" , \"Apr\" , \"May\" , \"Jun\" , \"Jul\" , \"Aug\" , \"Sep\" , \"Oct\" , \"Nov\" , \"Dec\" } ; token = osStrtok_r ( line , \"<S2SV_blank>\\\\t\" , & p ) ; if ( token == NULL ) return ERROR_INVALID_SYNTAX ; if ( osIsdigit ( token [ 0 ] ) ) { if ( osStrlen ( token ) == 8 && token [ 2 ] == '-' && token [ 5 ] == '-' ) { dirEntry -> modified . month = ( uint8_t ) osStrtoul ( token , NULL , 10 ) ; dirEntry -> modified . day = ( uint8_t ) osStrtoul ( token + 3 , NULL , 10 ) ; dirEntry -> modified . year = ( uint16_t ) osStrtoul ( token + 6 , NULL , 10 ) + 2000 ; } else if ( osStrlen ( token ) == 10 && token [ 2 ] == '/' && token [ 5 ] == '/' ) { dirEntry -> modified . month = ( uint8_t ) osStrtoul ( token , NULL , 10 ) ; dirEntry -> modified . day = ( uint8_t ) osStrtoul ( token + 3 , NULL , 10 ) ; dirEntry -> modified . year = ( uint16_t ) osStrtoul ( token + 6 , NULL , 10 ) ; } else { return ERROR_INVALID_SYNTAX ; } token = osStrtok_r ( NULL , \"<S2SV_blank>\" , & p ) ; if ( token == NULL ) return ERROR_INVALID_SYNTAX ; if ( osStrlen ( token ) >= 5 && token [ 2 ] == ':' ) { dirEntry -> modified . hours = ( uint8_t ) osStrtoul ( token , NULL , 10 ) ; dirEntry -> modified . minutes = ( uint8_t ) osStrtoul ( token + 3 , NULL , 10 ) ; <S2SV_StartBug> if ( strstr ( token , \"PM\" ) != NULL ) <S2SV_EndBug> dirEntry -> modified . hours += 12 ; } <S2SV_StartBug> else <S2SV_EndBug> { return ERROR_INVALID_SYNTAX ; } token = osStrtok_r ( NULL , \"<S2SV_blank>\" , & p ) ; if ( token == NULL ) return ERROR_INVALID_SYNTAX ; if ( ! osStrcmp ( token , \"<DIR>\" ) ) { dirEntry -> attributes |= FTP_FILE_ATTR_DIRECTORY ; } else { dirEntry -> size = osStrtoul ( token , NULL , 10 ) ; } token = osStrtok_r ( NULL , \"<S2SV_blank>\\\\r\\\\n\" , & p ) ; if ( token == NULL ) return ERROR_INVALID_SYNTAX ; n = osStrlen ( token ) ; n = MIN ( n , FTP_CLIENT_MAX_FILENAME_LEN ) ; osStrncpy ( dirEntry -> name , token , n ) ; dirEntry -> name [ n ] = '\\\\0' ; } else { <S2SV_StartBug> if ( strchr ( token , 'd' ) != NULL ) <S2SV_EndBug> dirEntry -> attributes |= FTP_FILE_ATTR_DIRECTORY ; <S2SV_StartBug> if ( strchr ( token , 'w' ) == NULL ) <S2SV_EndBug> dirEntry -> attributes |= FTP_FILE_ATTR_READ_ONLY ; <S2SV_StartBug> token = osStrtok_r ( NULL , \"<S2SV_blank>\" , & p ) ; <S2SV_EndBug> if ( token == NULL ) return ERROR_INVALID_SYNTAX ; token = osStrtok_r ( NULL , \"<S2SV_blank>\" , & p ) ; if ( token == NULL ) return ERROR_INVALID_SYNTAX ; token = osStrtok_r ( NULL , \"<S2SV_blank>\" , & p ) ; if ( token == NULL ) return ERROR_INVALID_SYNTAX ; token = osStrtok_r ( NULL , \"<S2SV_blank>\" , & p ) ; if ( token == NULL ) return ERROR_INVALID_SYNTAX ; dirEntry -> size = osStrtoul ( token , NULL , 10 ) ; token = osStrtok_r ( NULL , \"<S2SV_blank>\" , & p ) ; if ( token == NULL ) return ERROR_INVALID_SYNTAX ; for ( i = 1 ; i <= 12 ; i ++ ) { if ( ! osStrcmp ( token , months [ i ] ) ) { dirEntry -> modified . month = i ; break ; } } token = osStrtok_r ( NULL , \"<S2SV_blank>\" , & p ) ; if ( token == NULL ) return ERROR_INVALID_SYNTAX ; dirEntry -> modified . day = ( uint8_t ) osStrtoul ( token , NULL , 10 ) ; token = osStrtok_r ( NULL , \"<S2SV_blank>\" , & p ) ; if ( token == NULL ) return ERROR_INVALID_SYNTAX ; if ( osStrlen ( token ) == 4 ) { dirEntry -> modified . year = ( uint16_t ) osStrtoul ( token , NULL , 10 ) ; } else if ( osStrlen ( token ) == 5 ) { token [ 2 ] = '\\\\0' ; dirEntry -> modified . hours = ( uint8_t ) osStrtoul ( token , NULL , 10 ) ; dirEntry -> modified . minutes = ( uint8_t ) osStrtoul ( token + 3 , NULL , 10 ) ; } else { return ERROR_INVALID_SYNTAX ; } token = osStrtok_r ( NULL , \"<S2SV_blank>\\\\r\\\\n\" , & p ) ; if ( token == NULL ) return ERROR_INVALID_SYNTAX ; n = osStrlen ( token ) ; n = MIN ( n , FTP_CLIENT_MAX_FILENAME_LEN ) ; osStrncpy ( dirEntry -> name , token , n ) ; dirEntry -> name [ n ] = '\\\\0' ; } return NO_ERROR ; }\n","target":"<S2SV_ModStart> ; if ( osStrstr <S2SV_ModEnd> ( token , <S2SV_ModStart> != NULL ) { <S2SV_ModStart> 12 ; } } <S2SV_ModStart> { if ( osStrchr <S2SV_ModEnd> ( token , <S2SV_ModStart> != NULL ) { <S2SV_ModStart> |= FTP_FILE_ATTR_DIRECTORY ; } if ( osStrchr <S2SV_ModEnd> ( token , <S2SV_ModStart> == NULL ) { <S2SV_ModStart> |= FTP_FILE_ATTR_READ_ONLY ; }\n","project_and_commit_id":"Oryx-Embedded@CycloneTCP/de5336016edbe1e90327d0ed1cba5c4e49114366","cve_id":"CVE-2021-26788","original_address":"https://github.com/Oryx-Embedded/CycloneTCP/commit/de5336016edbe1e90327d0ed1cba5c4e49114366","time":"2021-03-08T13:15Z"},
	{"Unnamed: 0":2317,"cwe_id":"CWE-399","source":"CWE-399 SYSCALL_DEFINE1 ( inotify_init1 , int , flags ) { <S2SV_StartBug> struct fsnotify_group * group ; <S2SV_EndBug> struct user_struct * user ; int ret ; BUILD_BUG_ON ( IN_CLOEXEC != O_CLOEXEC ) ; BUILD_BUG_ON ( IN_NONBLOCK != O_NONBLOCK ) ; if ( flags & ~ ( IN_CLOEXEC | IN_NONBLOCK ) ) return - EINVAL ; <S2SV_StartBug> user = get_current_user ( ) ; <S2SV_EndBug> if ( unlikely ( atomic_read ( & user -> inotify_devs ) >= inotify_max_user_instances ) ) { ret = - EMFILE ; goto out_free_uid ; } <S2SV_StartBug> group = inotify_new_group ( user , inotify_max_queued_events ) ; <S2SV_EndBug> <S2SV_StartBug> if ( IS_ERR ( group ) ) { <S2SV_EndBug> <S2SV_StartBug> ret = PTR_ERR ( group ) ; <S2SV_EndBug> goto out_free_uid ; } atomic_inc ( & user -> inotify_devs ) ; ret = anon_inode_getfd ( \"inotify\" , & inotify_fops , group , O_RDONLY | flags ) ; <S2SV_StartBug> if ( ret >= 0 ) <S2SV_EndBug> return ret ; <S2SV_StartBug> fsnotify_put_group ( group ) ; <S2SV_EndBug> atomic_dec ( & user -> inotify_devs ) ; out_free_uid : free_uid ( user ) ; return ret ; }\n","target":"<S2SV_ModStart> fsnotify_group * group <S2SV_ModEnd> ; int ret <S2SV_ModStart> - EINVAL ; <S2SV_ModEnd> group = inotify_new_group <S2SV_ModStart> = inotify_new_group ( <S2SV_ModEnd> inotify_max_queued_events ) ; <S2SV_ModStart> group ) ) return <S2SV_ModEnd> PTR_ERR ( group <S2SV_ModStart> PTR_ERR ( group <S2SV_ModEnd> ) ; ret <S2SV_ModStart> if ( ret < 0 ) <S2SV_ModEnd> fsnotify_put_group ( group <S2SV_ModStart> fsnotify_put_group ( group <S2SV_ModEnd> ) ; return\n","project_and_commit_id":"torvalds@linux/d0de4dc584ec6aa3b26fffea320a8457827768fc","cve_id":"CVE-2011-1479","original_address":"https://github.com/torvalds/linux/commit/d0de4dc584ec6aa3b26fffea320a8457827768fc","time":"2012-06-21T23:55Z"},
	{"Unnamed: 0":3929,"cwe_id":"CWE-119","source":"CWE-119 static MagickBooleanType EncodeImage ( const ImageInfo * image_info , Image * image , const size_t data_size ) { # define MaxCode ( number_bits ) ( ( one << ( number_bits ) ) - 1 ) # define MaxHashTable 5003 # define MaxGIFBits 12UL # define MaxGIFTable ( 1UL << MaxGIFBits ) <S2SV_StartBug> # define GIFOutputCode ( code ) { if ( bits > 0 ) datum |= ( size_t ) ( code ) << bits ; else datum = ( size_t ) ( code ) ; bits += number_bits ; while ( bits >= 8 ) { packet [ length ++ ] = ( unsigned char ) ( datum & 0xff ) ; if ( length >= 254 ) { ( void ) WriteBlobByte ( image , ( unsigned char ) length ) ; ( void ) WriteBlob ( image , length , packet ) ; length = 0 ; } datum >>= 8 ; bits -= 8 ; } if ( free_code > max_code ) { number_bits ++ ; if ( number_bits == MaxGIFBits ) max_code = MaxGIFTable ; else max_code = MaxCode ( number_bits ) ; } } <S2SV_EndBug> IndexPacket index ; short * hash_code , * hash_prefix , waiting_code ; size_t bits , clear_code , datum , end_of_information_code , free_code , length , max_code , next_pixel , number_bits , one , pass ; ssize_t displacement , offset , k , y ; unsigned char * packet , * hash_suffix ; assert ( image != ( Image * ) NULL ) ; one = 1 ; packet = ( unsigned char * ) AcquireQuantumMemory ( 256 , sizeof ( * packet ) ) ; hash_code = ( short * ) AcquireQuantumMemory ( MaxHashTable , sizeof ( * hash_code ) ) ; hash_prefix = ( short * ) AcquireQuantumMemory ( MaxHashTable , sizeof ( * hash_prefix ) ) ; hash_suffix = ( unsigned char * ) AcquireQuantumMemory ( MaxHashTable , sizeof ( * hash_suffix ) ) ; if ( ( packet == ( unsigned char * ) NULL ) || ( hash_code == ( short * ) NULL ) || ( hash_prefix == ( short * ) NULL ) || ( hash_suffix == ( unsigned char * ) NULL ) ) { if ( packet != ( unsigned char * ) NULL ) packet = ( unsigned char * ) RelinquishMagickMemory ( packet ) ; if ( hash_code != ( short * ) NULL ) hash_code = ( short * ) RelinquishMagickMemory ( hash_code ) ; if ( hash_prefix != ( short * ) NULL ) hash_prefix = ( short * ) RelinquishMagickMemory ( hash_prefix ) ; if ( hash_suffix != ( unsigned char * ) NULL ) hash_suffix = ( unsigned char * ) RelinquishMagickMemory ( hash_suffix ) ; return ( MagickFalse ) ; } ( void ) memset ( packet , 0 , 256 * sizeof ( * packet ) ) ; ( void ) memset ( hash_code , 0 , MaxHashTable * sizeof ( * hash_code ) ) ; ( void ) memset ( hash_prefix , 0 , MaxHashTable * sizeof ( * hash_prefix ) ) ; ( void ) memset ( hash_suffix , 0 , MaxHashTable * sizeof ( * hash_suffix ) ) ; number_bits = data_size ; max_code = MaxCode ( number_bits ) ; clear_code = ( ( short ) one << ( data_size - 1 ) ) ; end_of_information_code = clear_code + 1 ; free_code = clear_code + 2 ; length = 0 ; datum = 0 ; bits = 0 ; GIFOutputCode ( clear_code ) ; offset = 0 ; pass = 0 ; waiting_code = 0 ; for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { register const IndexPacket * magick_restrict indexes ; register const PixelPacket * magick_restrict p ; register ssize_t x ; p = GetVirtualPixels ( image , 0 , offset , image -> columns , 1 , & image -> exception ) ; if ( p == ( const PixelPacket * ) NULL ) break ; indexes = GetVirtualIndexQueue ( image ) ; if ( y == 0 ) { waiting_code = ( short ) ( * indexes ) ; p ++ ; } for ( x = ( ssize_t ) ( y == 0 ? 1 : 0 ) ; x < ( ssize_t ) image -> columns ; x ++ ) { <S2SV_StartBug> index = ( IndexPacket ) ( ( size_t ) GetPixelIndex ( indexes + x ) & 0xff ) ; <S2SV_EndBug> p ++ ; k = ( ssize_t ) ( ( ( size_t ) index << ( MaxGIFBits - 8 ) ) + waiting_code ) ; if ( k >= MaxHashTable ) k -= MaxHashTable ; <S2SV_StartBug> next_pixel = MagickFalse ; <S2SV_EndBug> displacement = 1 ; if ( hash_code [ k ] > 0 ) { if ( ( hash_prefix [ k ] == waiting_code ) && ( hash_suffix [ k ] == ( unsigned char ) index ) ) { waiting_code = hash_code [ k ] ; continue ; } if ( k != 0 ) displacement = MaxHashTable - k ; for ( ; ; ) { k -= displacement ; if ( k < 0 ) k += MaxHashTable ; if ( hash_code [ k ] == 0 ) break ; if ( ( hash_prefix [ k ] == waiting_code ) && ( hash_suffix [ k ] == ( unsigned char ) index ) ) { waiting_code = hash_code [ k ] ; next_pixel = MagickTrue ; break ; } } if ( next_pixel != MagickFalse ) continue ; } GIFOutputCode ( waiting_code ) ; if ( free_code < MaxGIFTable ) { hash_code [ k ] = ( short ) free_code ++ ; hash_prefix [ k ] = waiting_code ; hash_suffix [ k ] = ( unsigned char ) index ; } else { for ( k = 0 ; k < MaxHashTable ; k ++ ) hash_code [ k ] = 0 ; free_code = clear_code + 2 ; GIFOutputCode ( clear_code ) ; number_bits = data_size ; max_code = MaxCode ( number_bits ) ; } waiting_code = ( short ) index ; } if ( image_info -> interlace == NoInterlace ) offset ++ ; else switch ( pass ) { case 0 : default : { offset += 8 ; if ( offset >= ( ssize_t ) image -> rows ) { pass ++ ; offset = 4 ; } break ; } case 1 : { offset += 8 ; if ( offset >= ( ssize_t ) image -> rows ) { pass ++ ; offset = 2 ; } break ; } case 2 : { offset += 4 ; if ( offset >= ( ssize_t ) image -> rows ) { pass ++ ; offset = 1 ; } break ; } case 3 : { offset += 2 ; break ; } } } GIFOutputCode ( waiting_code ) ; GIFOutputCode ( end_of_information_code ) ; if ( bits > 0 ) { packet [ length ++ ] = ( unsigned char ) ( datum & 0xff ) ; if ( length >= 254 ) { ( void ) WriteBlobByte ( image , ( unsigned char ) length ) ; ( void ) WriteBlob ( image , length , packet ) ; length = 0 ; } } if ( length > 0 ) { ( void ) WriteBlobByte ( image , ( unsigned char ) length ) ; ( void ) WriteBlob ( image , length , packet ) ; } hash_suffix = ( unsigned char * ) RelinquishMagickMemory ( hash_suffix ) ; hash_prefix = ( short * ) RelinquishMagickMemory ( hash_prefix ) ; hash_code = ( short * ) RelinquishMagickMemory ( hash_code ) ; packet = ( unsigned char * ) RelinquishMagickMemory ( packet ) ; return ( MagickTrue ) ; }\n","target":"<S2SV_ModStart> ( code ) \\\\\\n{ <S2SV_ModEnd> if ( bits <S2SV_ModStart> ) ; } \\\\\\n} <S2SV_ModEnd> IndexPacket index ; <S2SV_ModStart> ++ ) { next_pixel = MagickFalse ; displacement = 1 ; <S2SV_ModStart> -= MaxHashTable ; if ( k < 0 ) continue <S2SV_ModEnd> ; if (\n","project_and_commit_id":"ImageMagick@ImageMagick6/19651f3db63fa1511ed83a348c4c82fa553f8d01","cve_id":"CVE-2019-13308","original_address":"https://github.com/ImageMagick/ImageMagick6/commit/19651f3db63fa1511ed83a348c4c82fa553f8d01","time":"2019-07-05T01:15Z"},
	{"Unnamed: 0":2901,"cwe_id":"CWE-476","source":"CWE-476 SYSCALL_DEFINE5 ( add_key , const char __user * , _type , const char __user * , _description , const void __user * , _payload , size_t , plen , key_serial_t , ringid ) { key_ref_t keyring_ref , key_ref ; char type [ 32 ] , * description ; void * payload ; long ret ; ret = - EINVAL ; if ( plen > 1024 * 1024 - 1 ) goto error ; ret = key_get_type_from_user ( type , _type , sizeof ( type ) ) ; if ( ret < 0 ) goto error ; description = NULL ; if ( _description ) { description = strndup_user ( _description , KEY_MAX_DESC_SIZE ) ; if ( IS_ERR ( description ) ) { ret = PTR_ERR ( description ) ; goto error ; } if ( ! * description ) { kfree ( description ) ; description = NULL ; } else if ( ( description [ 0 ] == '.' ) && ( strncmp ( type , \"keyring\" , 7 ) == 0 ) ) { ret = - EPERM ; goto error2 ; } } payload = NULL ; <S2SV_StartBug> if ( _payload ) { <S2SV_EndBug> ret = - ENOMEM ; payload = kvmalloc ( plen , GFP_KERNEL ) ; if ( ! payload ) goto error2 ; ret = - EFAULT ; if ( copy_from_user ( payload , _payload , plen ) != 0 ) goto error3 ; } keyring_ref = lookup_user_key ( ringid , KEY_LOOKUP_CREATE , KEY_NEED_WRITE ) ; if ( IS_ERR ( keyring_ref ) ) { ret = PTR_ERR ( keyring_ref ) ; goto error3 ; } key_ref = key_create_or_update ( keyring_ref , type , description , payload , plen , KEY_PERM_UNDEF , KEY_ALLOC_IN_QUOTA ) ; if ( ! IS_ERR ( key_ref ) ) { ret = key_ref_to_ptr ( key_ref ) -> serial ; key_ref_put ( key_ref ) ; } else { ret = PTR_ERR ( key_ref ) ; } key_ref_put ( keyring_ref ) ; error3 : kvfree ( payload ) ; error2 : kfree ( description ) ; error : return ret ; }\n","target":"<S2SV_ModStart> ; if ( plen <S2SV_ModEnd> ) { ret\n","project_and_commit_id":"torvalds@linux/5649645d725c73df4302428ee4e02c869248b4c5","cve_id":"CVE-2017-15274","original_address":"https://github.com/torvalds/linux/commit/5649645d725c73df4302428ee4e02c869248b4c5","time":"2017-10-12T00:29Z"},
	{"Unnamed: 0":6087,"cwe_id":"CWE-79","source":"CWE-79 static int php_handler ( request_rec * r ) { php_struct * volatile ctx ; void * conf ; apr_bucket_brigade * volatile brigade ; apr_bucket * bucket ; apr_status_t rv ; request_rec * volatile parent_req = NULL ; TSRMLS_FETCH ( ) ; # define PHPAP_INI_OFF php_apache_ini_dtor ( r , parent_req TSRMLS_CC ) ; conf = ap_get_module_config ( r -> per_dir_config , & php5_module ) ; ctx = SG ( server_context ) ; if ( ctx == NULL || ( ctx && ctx -> request_processed && ! strcmp ( r -> protocol , \"INCLUDED\" ) ) ) { normal : ctx = SG ( server_context ) = apr_pcalloc ( r -> pool , sizeof ( * ctx ) ) ; apr_pool_cleanup_register ( r -> pool , ( void * ) & SG ( server_context ) , php_server_context_cleanup , apr_pool_cleanup_null ) ; ctx -> r = r ; ctx = NULL ; } else { parent_req = ctx -> r ; ctx -> r = r ; } apply_config ( conf ) ; if ( strcmp ( r -> handler , PHP_MAGIC_TYPE ) && strcmp ( r -> handler , PHP_SOURCE_MAGIC_TYPE ) && strcmp ( r -> handler , PHP_SCRIPT ) ) { if ( ! AP2 ( xbithack ) || strcmp ( r -> handler , \"text/html\" ) || ! ( r -> finfo . protection & APR_UEXECUTE ) ) { PHPAP_INI_OFF ; return DECLINED ; } } if ( r -> used_path_info == AP_REQ_REJECT_PATH_INFO && r -> path_info && r -> path_info [ 0 ] ) { PHPAP_INI_OFF ; return HTTP_NOT_FOUND ; } if ( ! AP2 ( engine ) ) { PHPAP_INI_OFF ; return DECLINED ; } if ( r -> finfo . filetype == 0 ) { php_apache_sapi_log_message_ex ( \"script<S2SV_blank>\\'%s\\'<S2SV_blank>not<S2SV_blank>found<S2SV_blank>or<S2SV_blank>unable<S2SV_blank>to<S2SV_blank>stat\" , r TSRMLS_CC ) ; PHPAP_INI_OFF ; return HTTP_NOT_FOUND ; } if ( r -> finfo . filetype == APR_DIR ) { php_apache_sapi_log_message_ex ( \"attempt<S2SV_blank>to<S2SV_blank>invoke<S2SV_blank>directory<S2SV_blank>\\'%s\\'<S2SV_blank>as<S2SV_blank>script\" , r TSRMLS_CC ) ; PHPAP_INI_OFF ; return HTTP_FORBIDDEN ; } if ( r -> main == NULL || r -> subprocess_env != r -> main -> subprocess_env ) { ap_add_common_vars ( r ) ; ap_add_cgi_vars ( r ) ; } zend_first_try { if ( ctx == NULL ) { brigade = apr_brigade_create ( r -> pool , r -> connection -> bucket_alloc ) ; ctx = SG ( server_context ) ; ctx -> brigade = brigade ; if ( php_apache_request_ctor ( r , ctx TSRMLS_CC ) != SUCCESS ) { zend_bailout ( ) ; } } else { if ( ! parent_req ) { parent_req = ctx -> r ; } if ( parent_req && parent_req -> handler && strcmp ( parent_req -> handler , PHP_MAGIC_TYPE ) && strcmp ( parent_req -> handler , PHP_SOURCE_MAGIC_TYPE ) && strcmp ( parent_req -> handler , PHP_SCRIPT ) ) { if ( php_apache_request_ctor ( r , ctx TSRMLS_CC ) != SUCCESS ) { zend_bailout ( ) ; } } if ( parent_req && parent_req -> status != HTTP_OK && parent_req -> status != 413 && strcmp ( r -> protocol , \"INCLUDED\" ) ) { parent_req = NULL ; goto normal ; } ctx -> r = r ; brigade = ctx -> brigade ; } if ( AP2 ( last_modified ) ) { ap_update_mtime ( r , r -> finfo . mtime ) ; ap_set_last_modified ( r ) ; } if ( strncmp ( r -> handler , PHP_SOURCE_MAGIC_TYPE , sizeof ( PHP_SOURCE_MAGIC_TYPE ) - 1 ) == 0 ) { zend_syntax_highlighter_ini syntax_highlighter_ini ; php_get_highlight_struct ( & syntax_highlighter_ini ) ; highlight_file ( ( char * ) r -> filename , & syntax_highlighter_ini TSRMLS_CC ) ; } else { zend_file_handle zfd ; zfd . type = ZEND_HANDLE_FILENAME ; zfd . filename = ( char * ) r -> filename ; zfd . free_filename = 0 ; zfd . opened_path = NULL ; if ( ! parent_req ) { php_execute_script ( & zfd TSRMLS_CC ) ; } else { zend_execute_scripts ( ZEND_INCLUDE TSRMLS_CC , NULL , 1 , & zfd ) ; } apr_table_set ( r -> notes , \"mod_php_memory_usage\" , apr_psprintf ( ctx -> r -> pool , \"%\" APR_SIZE_T_FMT , zend_memory_peak_usage ( 1 TSRMLS_CC ) ) ) ; } } zend_end_try ( ) ; if ( ! parent_req ) { php_apache_request_dtor ( r TSRMLS_CC ) ; ctx -> request_processed = 1 ; <S2SV_StartBug> bucket = apr_bucket_eos_create ( r -> connection -> bucket_alloc ) ; <S2SV_EndBug> APR_BRIGADE_INSERT_TAIL ( brigade , bucket ) ; rv = ap_pass_brigade ( r -> output_filters , brigade ) ; if ( rv != APR_SUCCESS || r -> connection -> aborted ) { zend_first_try { php_handle_aborted_connection ( ) ; } zend_end_try ( ) ; } apr_brigade_cleanup ( brigade ) ; apr_pool_cleanup_run ( r -> pool , ( void * ) & SG ( server_context ) , php_server_context_cleanup ) ; } else { ctx -> r = parent_req ; } return OK ; }\n","target":"<S2SV_ModStart> = 1 ; apr_brigade_cleanup ( brigade ) ;\n","project_and_commit_id":"php@php-src/23b057742e3cf199612fa8050ae86cae675e214e","cve_id":"CVE-2018-17082","original_address":"https://github.com/php/php-src/commit/23b057742e3cf199612fa8050ae86cae675e214e","time":"2018-09-16T15:29Z"},
	{"Unnamed: 0":6453,"cwe_id":"CWE-119","source":"CWE-119 static Image * ReadCUTImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { Image * image , * palette ; ImageInfo * clone_info ; MagickBooleanType status ; MagickOffsetType offset ; size_t EncodedByte ; unsigned char RunCount , RunValue , RunCountMasked ; CUTHeader Header ; CUTPalHeader PalHeader ; ssize_t depth ; ssize_t i , j ; ssize_t ldblk ; unsigned char * BImgBuff = NULL , * ptrB ; PixelPacket * q ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickSignature ) ; if ( image_info -> debug != MagickFalse ) ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , \"%s\" , image_info -> filename ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickSignature ) ; image = AcquireImage ( image_info ) ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } palette = NULL ; clone_info = NULL ; Header . Width = ReadBlobLSBShort ( image ) ; Header . Height = ReadBlobLSBShort ( image ) ; Header . Reserved = ReadBlobLSBShort ( image ) ; if ( Header . Width == 0 || Header . Height == 0 || Header . Reserved != 0 ) CUT_KO : ThrowReaderException ( CorruptImageError , \"ImproperImageHeader\" ) ; EncodedByte = ReadBlobLSBShort ( image ) ; RunCount = ( unsigned char ) ReadBlobByte ( image ) ; RunCountMasked = RunCount & 0x7F ; ldblk = 0 ; while ( ( int ) RunCountMasked != 0 ) { i = 1 ; if ( ( int ) RunCount < 0x80 ) i = ( ssize_t ) RunCountMasked ; offset = SeekBlob ( image , TellBlob ( image ) + i , SEEK_SET ) ; if ( offset < 0 ) ThrowReaderException ( CorruptImageError , \"ImproperImageHeader\" ) ; if ( EOFBlob ( image ) != MagickFalse ) goto CUT_KO ; EncodedByte -= i + 1 ; ldblk += ( ssize_t ) RunCountMasked ; RunCount = ( unsigned char ) ReadBlobByte ( image ) ; if ( EOFBlob ( image ) != MagickFalse ) goto CUT_KO ; RunCountMasked = RunCount & 0x7F ; } if ( EncodedByte != 1 ) goto CUT_KO ; i = 0 ; if ( ldblk == ( int ) Header . Width ) i = 8 ; if ( 2 * ldblk == ( int ) Header . Width ) i = 4 ; if ( 8 * ldblk == ( int ) Header . Width ) i = 1 ; if ( i == 0 ) goto CUT_KO ; depth = i ; image -> columns = Header . Width ; image -> rows = Header . Height ; image -> depth = 8 ; image -> colors = ( size_t ) ( GetQuantumRange ( 1UL * i ) + 1 ) ; <S2SV_StartBug> if ( image_info -> ping ) goto Finish ; <S2SV_EndBug> if ( ( clone_info = CloneImageInfo ( image_info ) ) == NULL ) goto NoPalette ; i = ( ssize_t ) strlen ( clone_info -> filename ) ; j = i ; while ( -- i > 0 ) { if ( clone_info -> filename [ i ] == '.' ) { break ; } if ( clone_info -> filename [ i ] == '/' || clone_info -> filename [ i ] == '\\\\\\\\' || clone_info -> filename [ i ] == ':' ) { i = j ; break ; } } ( void ) CopyMagickString ( clone_info -> filename + i , \".PAL\" , ( size_t ) ( MaxTextExtent - i ) ) ; if ( ( clone_info -> file = fopen_utf8 ( clone_info -> filename , \"rb\" ) ) == NULL ) { ( void ) CopyMagickString ( clone_info -> filename + i , \".pal\" , ( size_t ) ( MaxTextExtent - i ) ) ; if ( ( clone_info -> file = fopen_utf8 ( clone_info -> filename , \"rb\" ) ) == NULL ) { clone_info -> filename [ i ] = '\\\\0' ; if ( ( clone_info -> file = fopen_utf8 ( clone_info -> filename , \"rb\" ) ) == NULL ) { clone_info = DestroyImageInfo ( clone_info ) ; clone_info = NULL ; goto NoPalette ; } } } if ( ( palette = AcquireImage ( clone_info ) ) == NULL ) goto NoPalette ; status = OpenBlob ( clone_info , palette , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) { ErasePalette : palette = DestroyImage ( palette ) ; palette = NULL ; goto NoPalette ; } if ( palette != NULL ) { ( void ) ReadBlob ( palette , 2 , ( unsigned char * ) PalHeader . FileId ) ; if ( strncmp ( PalHeader . FileId , \"AH\" , 2 ) != 0 ) goto ErasePalette ; PalHeader . Version = ReadBlobLSBShort ( palette ) ; PalHeader . Size = ReadBlobLSBShort ( palette ) ; PalHeader . FileType = ( char ) ReadBlobByte ( palette ) ; PalHeader . SubType = ( char ) ReadBlobByte ( palette ) ; PalHeader . BoardID = ReadBlobLSBShort ( palette ) ; PalHeader . GraphicsMode = ReadBlobLSBShort ( palette ) ; PalHeader . MaxIndex = ReadBlobLSBShort ( palette ) ; PalHeader . MaxRed = ReadBlobLSBShort ( palette ) ; PalHeader . MaxGreen = ReadBlobLSBShort ( palette ) ; PalHeader . MaxBlue = ReadBlobLSBShort ( palette ) ; ( void ) ReadBlob ( palette , 20 , ( unsigned char * ) PalHeader . PaletteId ) ; if ( PalHeader . MaxIndex < 1 ) goto ErasePalette ; image -> colors = PalHeader . MaxIndex + 1 ; if ( AcquireImageColormap ( image , image -> colors ) == MagickFalse ) goto NoMemory ; if ( PalHeader . MaxRed == 0 ) PalHeader . MaxRed = ( unsigned int ) QuantumRange ; if ( PalHeader . MaxGreen == 0 ) PalHeader . MaxGreen = ( unsigned int ) QuantumRange ; if ( PalHeader . MaxBlue == 0 ) PalHeader . MaxBlue = ( unsigned int ) QuantumRange ; for ( i = 0 ; i <= ( int ) PalHeader . MaxIndex ; i ++ ) { j = ( ssize_t ) TellBlob ( palette ) ; if ( ( j % 512 ) > 512 - 6 ) { j = ( ( j / 512 ) + 1 ) * 512 ; offset = SeekBlob ( palette , j , SEEK_SET ) ; if ( offset < 0 ) ThrowReaderException ( CorruptImageError , \"ImproperImageHeader\" ) ; } image -> colormap [ i ] . red = ( Quantum ) ReadBlobLSBShort ( palette ) ; if ( QuantumRange != ( Quantum ) PalHeader . MaxRed ) { image -> colormap [ i ] . red = ClampToQuantum ( ( ( double ) image -> colormap [ i ] . red * QuantumRange + ( PalHeader . MaxRed >> 1 ) ) / PalHeader . MaxRed ) ; } image -> colormap [ i ] . green = ( Quantum ) ReadBlobLSBShort ( palette ) ; if ( QuantumRange != ( Quantum ) PalHeader . MaxGreen ) { image -> colormap [ i ] . green = ClampToQuantum ( ( ( double ) image -> colormap [ i ] . green * QuantumRange + ( PalHeader . MaxGreen >> 1 ) ) / PalHeader . MaxGreen ) ; } image -> colormap [ i ] . blue = ( Quantum ) ReadBlobLSBShort ( palette ) ; if ( QuantumRange != ( Quantum ) PalHeader . MaxBlue ) { image -> colormap [ i ] . blue = ClampToQuantum ( ( ( double ) image -> colormap [ i ] . blue * QuantumRange + ( PalHeader . MaxBlue >> 1 ) ) / PalHeader . MaxBlue ) ; } } } NoPalette : if ( palette == NULL ) { image -> colors = 256 ; if ( AcquireImageColormap ( image , image -> colors ) == MagickFalse ) { NoMemory : ThrowReaderException ( ResourceLimitError , \"MemoryAllocationFailed\" ) ; } for ( i = 0 ; i < ( ssize_t ) image -> colors ; i ++ ) { image -> colormap [ i ] . red = ScaleCharToQuantum ( ( unsigned char ) i ) ; image -> colormap [ i ] . green = ScaleCharToQuantum ( ( unsigned char ) i ) ; image -> colormap [ i ] . blue = ScaleCharToQuantum ( ( unsigned char ) i ) ; } } BImgBuff = ( unsigned char * ) AcquireQuantumMemory ( ( size_t ) ldblk , sizeof ( * BImgBuff ) ) ; if ( BImgBuff == NULL ) goto NoMemory ; offset = SeekBlob ( image , 6 , SEEK_SET ) ; if ( offset < 0 ) ThrowReaderException ( CorruptImageError , \"ImproperImageHeader\" ) ; for ( i = 0 ; i < ( int ) Header . Height ; i ++ ) { EncodedByte = ReadBlobLSBShort ( image ) ; ptrB = BImgBuff ; j = ldblk ; RunCount = ( unsigned char ) ReadBlobByte ( image ) ; RunCountMasked = RunCount & 0x7F ; while ( ( int ) RunCountMasked != 0 ) { if ( ( ssize_t ) RunCountMasked > j ) { RunCountMasked = ( unsigned char ) j ; if ( j == 0 ) { break ; } } if ( ( int ) RunCount > 0x80 ) { RunValue = ( unsigned char ) ReadBlobByte ( image ) ; ( void ) ResetMagickMemory ( ptrB , ( int ) RunValue , ( size_t ) RunCountMasked ) ; } else { ( void ) ReadBlob ( image , ( size_t ) RunCountMasked , ptrB ) ; } ptrB += ( int ) RunCountMasked ; j -= ( int ) RunCountMasked ; if ( EOFBlob ( image ) != MagickFalse ) goto Finish ; RunCount = ( unsigned char ) ReadBlobByte ( image ) ; RunCountMasked = RunCount & 0x7F ; } InsertRow ( depth , BImgBuff , i , image ) ; } ( void ) SyncImage ( image ) ; if ( palette == NULL ) { if ( ( image -> storage_class == PseudoClass ) && ( IsGrayImage ( image , & image -> exception ) != MagickFalse ) ) { if ( GetCutColors ( image ) == 2 ) { for ( i = 0 ; i < ( ssize_t ) image -> colors ; i ++ ) { register Quantum sample ; sample = ScaleCharToQuantum ( ( unsigned char ) i ) ; if ( image -> colormap [ i ] . red != sample ) goto Finish ; if ( image -> colormap [ i ] . green != sample ) goto Finish ; if ( image -> colormap [ i ] . blue != sample ) goto Finish ; } image -> colormap [ 1 ] . red = image -> colormap [ 1 ] . green = image -> colormap [ 1 ] . blue = QuantumRange ; for ( i = 0 ; i < ( ssize_t ) image -> rows ; i ++ ) { q = QueueAuthenticPixels ( image , 0 , i , image -> columns , 1 , exception ) ; for ( j = 0 ; j < ( ssize_t ) image -> columns ; j ++ ) { if ( GetPixelRed ( q ) == ScaleCharToQuantum ( 1 ) ) { SetPixelRed ( q , QuantumRange ) ; SetPixelGreen ( q , QuantumRange ) ; SetPixelBlue ( q , QuantumRange ) ; } q ++ ; } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) goto Finish ; } } } } Finish : if ( BImgBuff != NULL ) BImgBuff = ( unsigned char * ) RelinquishMagickMemory ( BImgBuff ) ; if ( palette != NULL ) palette = DestroyImage ( palette ) ; if ( clone_info != NULL ) clone_info = DestroyImageInfo ( clone_info ) ; if ( EOFBlob ( image ) != MagickFalse ) ThrowFileException ( exception , CorruptImageError , \"UnexpectedEndOfFile\" , image -> filename ) ; ( void ) CloseBlob ( image ) ; return ( GetFirstImageInList ( image ) ) ; }\n","target":"<S2SV_ModStart> image_info -> ping != MagickFalse <S2SV_ModStart> goto Finish ; status = SetImageExtent ( image , image -> columns , image -> rows ) ; if ( status == MagickFalse ) { InheritException ( exception , & image -> exception ) ; return ( DestroyImageList ( image ) ) ; }\n","project_and_commit_id":"ImageMagick@ImageMagick/f6e9d0d9955e85bdd7540b251cd50d598dacc5e6","cve_id":"CVE-2016-10066","original_address":"https://github.com/ImageMagick/ImageMagick/commit/f6e9d0d9955e85bdd7540b251cd50d598dacc5e6","time":"2017-03-03T17:59Z"},
	{"Unnamed: 0":3961,"cwe_id":"CWE-119","source":"CWE-119 static void swap_frame_buffers ( VP9Decoder * pbi ) { int ref_index = 0 , mask ; VP9_COMMON * const cm = & pbi -> common ; <S2SV_StartBug> for ( mask = pbi -> refresh_frame_flags ; mask ; mask >>= 1 ) { <S2SV_EndBug> <S2SV_StartBug> if ( mask & 1 ) { <S2SV_EndBug> const int old_idx = cm -> ref_frame_map [ ref_index ] ; <S2SV_StartBug> ref_cnt_fb ( cm -> frame_bufs , & cm -> ref_frame_map [ ref_index ] , <S2SV_EndBug> <S2SV_StartBug> cm -> new_fb_idx ) ; <S2SV_EndBug> <S2SV_StartBug> if ( old_idx >= 0 && cm -> frame_bufs [ old_idx ] . ref_count == 0 ) <S2SV_EndBug> cm -> release_fb_cb ( cm -> cb_priv , & cm -> frame_bufs [ old_idx ] . raw_frame_buffer ) ; } ++ ref_index ; } cm -> frame_to_show = get_frame_new_buffer ( cm ) ; cm -> frame_bufs [ cm -> new_fb_idx ] . ref_count -- ; for ( ref_index = 0 ; ref_index < 3 ; ref_index ++ ) <S2SV_StartBug> cm -> frame_refs [ ref_index ] . idx = INT_MAX ; <S2SV_EndBug> }\n","target":"<S2SV_ModStart> -> common ; BufferPool * const pool = cm -> buffer_pool ; RefCntBuffer * const frame_bufs = cm -> buffer_pool -> frame_bufs ; lock_buffer_pool ( pool ) ; <S2SV_ModStart> 1 ) { const int old_idx = cm -> ref_frame_map [ ref_index ] ; decrease_ref_count ( old_idx , frame_bufs , pool ) ; if ( <S2SV_ModEnd> ( mask & <S2SV_ModStart> & 1 ) && old_idx >= 0 ) { decrease_ref_count ( old_idx , frame_bufs , pool ) ; } cm -> ref_frame_map [ ref_index ] = cm -> next_ref_frame_map [ ref_index ] ; ++ ref_index ; } for ( ; ref_index < REF_FRAMES && ! cm -> show_existing_frame ; ++ ref_index ) <S2SV_ModStart> ref_index ] ; decrease_ref_count ( old_idx , frame_bufs , pool ) ; cm -> ref_frame_map [ ref_index ] = cm -> next_ref_frame_map [ ref_index ] ; } unlock_buffer_pool ( pool ) ; pbi -> hold_ref_buf = 0 ; cm -> frame_to_show = get_frame_new_buffer ( cm ) ; if ( ! pbi -> frame_parallel_decode || ! cm -> show_frame ) { lock_buffer_pool ( pool ) ; -- frame_bufs [ <S2SV_ModEnd> cm -> new_fb_idx <S2SV_ModStart> cm -> new_fb_idx <S2SV_ModEnd> ] . ref_count <S2SV_ModStart> ] . ref_count ; unlock_buffer_pool ( pool ) ; } <S2SV_ModEnd> for ( ref_index <S2SV_ModStart> . idx = - 1 <S2SV_ModEnd> ; } <S2SV_null>\n","project_and_commit_id":"external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426","cve_id":"CVE-2016-1621","original_address":"https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426","time":"2016-03-12T21:59Z"},
	{"Unnamed: 0":1667,"cwe_id":"CWE-787","source":"CWE-787 <S2SV_StartBug> uint32_t GetPayloadTime ( size_t handle , uint32_t index , float * in , float * out ) <S2SV_EndBug> { mp4object * mp4 = ( mp4object * ) handle ; <S2SV_StartBug> if ( mp4 == NULL ) return 0 ; <S2SV_EndBug> <S2SV_StartBug> if ( mp4 -> metaoffsets == 0 || mp4 -> basemetadataduration == 0 || mp4 -> meta_clockdemon == 0 || in == NULL || out == NULL ) return 1 ; <S2SV_EndBug> <S2SV_StartBug> * in = ( float ) ( ( double ) index * ( double ) mp4 -> basemetadataduration / ( double ) mp4 -> meta_clockdemon ) ; <S2SV_EndBug> <S2SV_StartBug> * out = ( float ) ( ( double ) ( index + 1 ) * ( double ) mp4 -> basemetadataduration / ( double ) mp4 -> meta_clockdemon ) ; <S2SV_EndBug> <S2SV_StartBug> return 0 ; <S2SV_EndBug> }\n","target":"<S2SV_ModStart> uint32_t index , double <S2SV_ModEnd> * in , <S2SV_ModStart> * in , double <S2SV_ModEnd> * out ) <S2SV_ModStart> NULL ) return GPMF_ERROR_MEMORY <S2SV_ModEnd> ; if ( <S2SV_ModStart> NULL ) return GPMF_ERROR_MEMORY <S2SV_ModEnd> ; * in <S2SV_ModStart> * in = <S2SV_ModEnd> ( ( double <S2SV_ModStart> * out = <S2SV_ModEnd> ( ( double <S2SV_ModStart> ) ; return GPMF_OK <S2SV_ModEnd> ; } <S2SV_null>\n","project_and_commit_id":"gopro@gpmf-parser/341f12cd5b97ab419e53853ca00176457c9f1681","cve_id":"CVE-2019-15148","original_address":"https://github.com/gopro/gpmf-parser/commit/341f12cd5b97ab419e53853ca00176457c9f1681","time":"2019-08-18T19:15Z"},
	{"Unnamed: 0":6686,"cwe_id":"CWE-119","source":"CWE-119 static void single_motion_search ( VP9_COMP * cpi , MACROBLOCK * x , <S2SV_StartBug> const TileInfo * const tile , <S2SV_EndBug> BLOCK_SIZE bsize , int mi_row , int mi_col , int_mv * tmp_mv , int * rate_mv ) { MACROBLOCKD * xd = & x -> e_mbd ; <S2SV_StartBug> VP9_COMMON * cm = & cpi -> common ; <S2SV_EndBug> MB_MODE_INFO * mbmi = & xd -> mi [ 0 ] -> mbmi ; <S2SV_StartBug> struct buf_2d backup_yv12 [ MAX_MB_PLANE ] = { { 0 } } ; <S2SV_EndBug> int bestsme = INT_MAX ; <S2SV_StartBug> int further_steps , step_param ; <S2SV_EndBug> int sadpb = x -> sadperbit16 ; MV mvp_full ; int ref = mbmi -> ref_frame [ 0 ] ; <S2SV_StartBug> MV ref_mv = mbmi -> ref_mvs [ ref ] [ 0 ] . as_mv ; <S2SV_EndBug> int tmp_col_min = x -> mv_col_min ; int tmp_col_max = x -> mv_col_max ; int tmp_row_min = x -> mv_row_min ; <S2SV_StartBug> int tmp_row_max = x -> mv_row_max ; <S2SV_EndBug> const YV12_BUFFER_CONFIG * scaled_ref_frame = vp9_get_scaled_ref_frame ( cpi , ref ) ; MV pred_mv [ 3 ] ; <S2SV_StartBug> pred_mv [ 0 ] = mbmi -> ref_mvs [ ref ] [ 0 ] . as_mv ; <S2SV_EndBug> <S2SV_StartBug> pred_mv [ 1 ] = mbmi -> ref_mvs [ ref ] [ 1 ] . as_mv ; <S2SV_EndBug> <S2SV_StartBug> pred_mv [ 2 ] = x -> pred_mv [ ref ] . as_mv ; <S2SV_EndBug> if ( scaled_ref_frame ) { int i ; for ( i = 0 ; i < MAX_MB_PLANE ; i ++ ) backup_yv12 [ i ] = xd -> plane [ i ] . pre [ 0 ] ; vp9_setup_pre_planes ( xd , 0 , scaled_ref_frame , mi_row , mi_col , NULL ) ; } vp9_set_mv_search_range ( x , & ref_mv ) ; <S2SV_StartBug> if ( cpi -> sf . auto_mv_step_size && cpi -> common . show_frame ) { <S2SV_EndBug> <S2SV_StartBug> step_param = ( vp9_init_search_range ( cpi , x -> max_mv_context [ ref ] ) + <S2SV_EndBug> <S2SV_StartBug> cpi -> mv_step_param ) >> 1 ; <S2SV_EndBug> } else { step_param = cpi -> mv_step_param ; } <S2SV_StartBug> if ( cpi -> sf . adaptive_motion_search && bsize < BLOCK_64X64 && <S2SV_EndBug> cpi -> common . show_frame ) { <S2SV_StartBug> int boffset = 2 * ( b_width_log2 ( BLOCK_64X64 ) - MIN ( b_height_log2 ( bsize ) , <S2SV_EndBug> b_width_log2 ( bsize ) ) ) ; step_param = MAX ( step_param , boffset ) ; } if ( cpi -> sf . adaptive_motion_search ) { int bwl = b_width_log2_lookup [ bsize ] ; <S2SV_StartBug> int bhl = b_height_log2_lookup [ bsize ] ; <S2SV_EndBug> int i ; int tlevel = x -> pred_mv_sad [ ref ] >> ( bwl + bhl + 4 ) ; if ( tlevel < 5 ) step_param += 2 ; <S2SV_StartBug> for ( i = LAST_FRAME ; i <= ALTREF_FRAME && cpi -> common . show_frame ; ++ i ) { <S2SV_EndBug> if ( ( x -> pred_mv_sad [ ref ] >> 3 ) > x -> pred_mv_sad [ i ] ) { <S2SV_StartBug> x -> pred_mv [ ref ] . as_int = 0 ; <S2SV_EndBug> tmp_mv -> as_int = INVALID_MV ; if ( scaled_ref_frame ) { int i ; <S2SV_StartBug> for ( i = 0 ; i < MAX_MB_PLANE ; i ++ ) <S2SV_EndBug> xd -> plane [ i ] . pre [ 0 ] = backup_yv12 [ i ] ; } <S2SV_StartBug> return ; <S2SV_EndBug> } } } mvp_full = pred_mv [ x -> mv_best_ref_index [ ref ] ] ; mvp_full . col >>= 3 ; mvp_full . row >>= 3 ; <S2SV_StartBug> further_steps = ( cpi -> sf . max_step_search_steps - 1 ) - step_param ; <S2SV_EndBug> if ( cpi -> sf . search_method == FAST_DIAMOND ) { bestsme = vp9_fast_dia_search ( x , & mvp_full , step_param , sadpb , 0 , & cpi -> fn_ptr [ bsize ] , 1 , & ref_mv , & tmp_mv -> as_mv ) ; if ( bestsme < INT_MAX ) <S2SV_StartBug> bestsme = vp9_get_mvpred_var ( x , & tmp_mv -> as_mv , & ref_mv , <S2SV_EndBug> <S2SV_StartBug> & cpi -> fn_ptr [ bsize ] , 1 ) ; <S2SV_EndBug> <S2SV_StartBug> } else if ( cpi -> sf . search_method == FAST_HEX ) { <S2SV_EndBug> bestsme = vp9_fast_hex_search ( x , & mvp_full , step_param , sadpb , 0 , & cpi -> fn_ptr [ bsize ] , 1 , & ref_mv , & tmp_mv -> as_mv ) ; if ( bestsme < INT_MAX ) bestsme = vp9_get_mvpred_var ( x , & tmp_mv -> as_mv , & ref_mv , & cpi -> fn_ptr [ bsize ] , 1 ) ; <S2SV_StartBug> } else if ( cpi -> sf . search_method == HEX ) { <S2SV_EndBug> bestsme = vp9_hex_search ( x , & mvp_full , step_param , sadpb , 1 , & cpi -> fn_ptr [ bsize ] , 1 , & ref_mv , & tmp_mv -> as_mv ) ; if ( bestsme < INT_MAX ) bestsme = vp9_get_mvpred_var ( x , & tmp_mv -> as_mv , & ref_mv , & cpi -> fn_ptr [ bsize ] , 1 ) ; } else if ( cpi -> sf . search_method == SQUARE ) { bestsme = vp9_square_search ( x , & mvp_full , step_param , sadpb , 1 , & cpi -> fn_ptr [ bsize ] , 1 , & ref_mv , & tmp_mv -> as_mv ) ; if ( bestsme < INT_MAX ) bestsme = vp9_get_mvpred_var ( x , & tmp_mv -> as_mv , & ref_mv , & cpi -> fn_ptr [ bsize ] , 1 ) ; } else if ( cpi -> sf . search_method == BIGDIA ) { bestsme = vp9_bigdia_search ( x , & mvp_full , step_param , sadpb , 1 , & cpi -> fn_ptr [ bsize ] , 1 , & ref_mv , & tmp_mv -> as_mv ) ; if ( bestsme < INT_MAX ) bestsme = vp9_get_mvpred_var ( x , & tmp_mv -> as_mv , & ref_mv , & cpi -> fn_ptr [ bsize ] , 1 ) ; } else { bestsme = vp9_full_pixel_diamond ( cpi , x , & mvp_full , step_param , sadpb , further_steps , 1 , & cpi -> fn_ptr [ bsize ] , & ref_mv , & tmp_mv -> as_mv ) ; } x -> mv_col_min = tmp_col_min ; x -> mv_col_max = tmp_col_max ; x -> mv_row_min = tmp_row_min ; x -> mv_row_max = tmp_row_max ; if ( bestsme < INT_MAX ) { int dis ; cpi -> find_fractional_mv_step ( x , & tmp_mv -> as_mv , & ref_mv , cm -> allow_high_precision_mv , x -> errorperbit , & cpi -> fn_ptr [ bsize ] , cpi -> sf . subpel_force_stop , cpi -> sf . subpel_iters_per_step , x -> nmvjointcost , x -> mvcost , <S2SV_StartBug> & dis , & x -> pred_sse [ ref ] ) ; <S2SV_EndBug> } * rate_mv = vp9_mv_bit_cost ( & tmp_mv -> as_mv , & ref_mv , x -> nmvjointcost , x -> mvcost , MV_COST_WEIGHT ) ; <S2SV_StartBug> if ( cpi -> sf . adaptive_motion_search && cpi -> common . show_frame ) <S2SV_EndBug> <S2SV_StartBug> x -> pred_mv [ ref ] . as_int = tmp_mv -> as_int ; <S2SV_EndBug> if ( scaled_ref_frame ) { int i ; for ( i = 0 ; i < MAX_MB_PLANE ; i ++ ) xd -> plane [ i ] . pre [ 0 ] = backup_yv12 [ i ] ; } }\n","target":"<S2SV_ModStart> * x , <S2SV_ModEnd> BLOCK_SIZE bsize , <S2SV_ModStart> -> e_mbd ; const <S2SV_ModStart> { { 0 , 0 <S2SV_ModStart> INT_MAX ; int <S2SV_ModEnd> step_param ; int <S2SV_ModStart> MV ref_mv = x -> mbmi_ext <S2SV_ModEnd> -> ref_mvs [ <S2SV_ModStart> x -> mv_row_max ; int cost_list [ 5 ] <S2SV_ModStart> 0 ] = x -> mbmi_ext <S2SV_ModEnd> -> ref_mvs [ <S2SV_ModStart> 1 ] = x -> mbmi_ext <S2SV_ModEnd> -> ref_mvs [ <S2SV_ModStart> [ ref ] <S2SV_ModEnd> ; if ( <S2SV_ModStart> -> sf . mv . auto_mv_step_size && cm -> <S2SV_ModEnd> show_frame ) { <S2SV_ModStart> ( vp9_init_search_range ( <S2SV_ModEnd> x -> max_mv_context <S2SV_ModStart> -> mv_step_param ) / 2 <S2SV_ModEnd> ; } else <S2SV_ModStart> bsize < BLOCK_64X64 <S2SV_ModEnd> ) { int <S2SV_ModStart> 2 * ( b_width_log2_lookup [ BLOCK_64X64 ] <S2SV_ModEnd> - MIN ( <S2SV_ModStart> - MIN ( b_height_log2_lookup [ bsize ] , b_width_log2_lookup [ bsize ] <S2SV_ModEnd> ) ) ; <S2SV_ModStart> [ bsize ] <S2SV_ModEnd> ; int tlevel <S2SV_ModStart> += 2 ; if ( cpi -> oxcf . resize_mode != RESIZE_DYNAMIC ) { int i ; <S2SV_ModStart> <= ALTREF_FRAME && cm -> <S2SV_ModEnd> show_frame ; ++ <S2SV_ModStart> ref ] . row = 0 ; x -> pred_mv [ ref ] . col <S2SV_ModEnd> = 0 ; <S2SV_ModStart> < MAX_MB_PLANE ; ++ i <S2SV_ModEnd> ) xd -> <S2SV_ModStart> } return ; } <S2SV_ModStart> >>= 3 ; bestsme = vp9_full_pixel_search ( cpi , x , bsize , & mvp_full , step_param , sadpb , cond_cost_list ( cpi , cost_list ) , & ref_mv , & tmp_mv -> as_mv , INT_MAX , 1 ) ; x -> mv_col_min = tmp_col_min ; x -> mv_col_max = tmp_col_max ; x -> mv_row_min = tmp_row_min ; x -> mv_row_max = tmp_row_max <S2SV_ModEnd> ; if ( <S2SV_ModStart> < INT_MAX ) { int dis ; cpi -> find_fractional_mv_step <S2SV_ModEnd> ( x , <S2SV_ModStart> & ref_mv , cm -> allow_high_precision_mv , x -> errorperbit , <S2SV_ModStart> bsize ] , <S2SV_ModEnd> cpi -> sf <S2SV_ModStart> -> sf . mv . subpel_force_stop , <S2SV_ModEnd> cpi -> sf <S2SV_ModStart> -> sf . mv . subpel_iters_per_step , cond_cost_list ( cpi , cost_list ) , x -> nmvjointcost , x -> mvcost , & dis <S2SV_ModEnd> , & x <S2SV_ModStart> [ ref ] , NULL , 0 , 0 <S2SV_ModStart> sf . adaptive_motion_search <S2SV_ModEnd> ) x -> <S2SV_ModStart> [ ref ] <S2SV_ModEnd> = tmp_mv -> <S2SV_ModStart> = tmp_mv -> as_mv <S2SV_ModEnd> ; if (\n","project_and_commit_id":"external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426","cve_id":"CVE-2016-1621","original_address":"https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426","time":"2016-03-12T21:59Z"},
	{"Unnamed: 0":5323,"cwe_id":"CWE-19","source":"CWE-19 int __sys_recvmmsg ( int fd , struct mmsghdr __user * mmsg , unsigned int vlen , unsigned int flags , struct timespec * timeout ) { int fput_needed , err , datagrams ; struct socket * sock ; struct mmsghdr __user * entry ; struct compat_mmsghdr __user * compat_entry ; struct msghdr msg_sys ; struct timespec end_time ; if ( timeout && poll_select_set_timeout ( & end_time , timeout -> tv_sec , timeout -> tv_nsec ) ) return - EINVAL ; datagrams = 0 ; sock = sockfd_lookup_light ( fd , & err , & fput_needed ) ; if ( ! sock ) return err ; err = sock_error ( sock -> sk ) ; if ( err ) goto out_put ; entry = mmsg ; compat_entry = ( struct compat_mmsghdr __user * ) mmsg ; while ( datagrams < vlen ) { if ( MSG_CMSG_COMPAT & flags ) { err = ___sys_recvmsg ( sock , ( struct user_msghdr __user * ) compat_entry , & msg_sys , flags & ~ MSG_WAITFORONE , datagrams ) ; if ( err < 0 ) break ; err = __put_user ( err , & compat_entry -> msg_len ) ; ++ compat_entry ; } else { err = ___sys_recvmsg ( sock , ( struct user_msghdr __user * ) entry , & msg_sys , flags & ~ MSG_WAITFORONE , datagrams ) ; if ( err < 0 ) break ; err = put_user ( err , & entry -> msg_len ) ; ++ entry ; } if ( err ) break ; ++ datagrams ; if ( flags & MSG_WAITFORONE ) flags |= MSG_DONTWAIT ; if ( timeout ) { ktime_get_ts ( timeout ) ; * timeout = timespec_sub ( end_time , * timeout ) ; if ( timeout -> tv_sec < 0 ) { timeout -> tv_sec = timeout -> tv_nsec = 0 ; break ; } if ( timeout -> tv_nsec == 0 && timeout -> tv_sec == 0 ) break ; } if ( msg_sys . msg_flags & MSG_OOB ) break ; cond_resched ( ) ; } <S2SV_StartBug> out_put : <S2SV_EndBug> fput_light ( sock -> file , fput_needed ) ; if ( err == 0 ) <S2SV_StartBug> return datagrams ; <S2SV_EndBug> if ( datagrams != 0 ) { if ( err != - EAGAIN ) { sock -> sk -> sk_err = - err ; } <S2SV_StartBug> return datagrams ; <S2SV_EndBug> } <S2SV_StartBug> return err ; <S2SV_EndBug> }\n","target":"<S2SV_ModStart> ) ; } if ( err == 0 ) goto out_put ; if ( datagrams <S2SV_ModEnd> == 0 ) <S2SV_ModStart> == 0 ) { datagrams = err ; goto out_put ; } <S2SV_ModEnd> if ( err <S2SV_ModStart> err ; } out_put : fput_light ( sock -> file , fput_needed ) ; <S2SV_ModStart> datagrams ; } <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null>\n","project_and_commit_id":"torvalds@linux/34b88a68f26a75e4fded796f1a49c40f82234b7d","cve_id":"CVE-2016-7117","original_address":"https://github.com/torvalds/linux/commit/34b88a68f26a75e4fded796f1a49c40f82234b7d","time":"2016-10-10T11:00Z"},
	{"Unnamed: 0":6688,"cwe_id":"CWE-310","source":"CWE-310 static int crypto_report_one ( struct crypto_alg * alg , struct crypto_user_alg * ualg , struct sk_buff * skb ) { <S2SV_StartBug> memcpy ( & ualg -> cru_name , & alg -> cra_name , sizeof ( ualg -> cru_name ) ) ; <S2SV_EndBug> <S2SV_StartBug> memcpy ( & ualg -> cru_driver_name , & alg -> cra_driver_name , <S2SV_EndBug> sizeof ( ualg -> cru_driver_name ) ) ; <S2SV_StartBug> memcpy ( & ualg -> cru_module_name , module_name ( alg -> cra_module ) , <S2SV_EndBug> <S2SV_StartBug> CRYPTO_MAX_ALG_NAME ) ; <S2SV_EndBug> ualg -> cru_flags = alg -> cra_flags ; ualg -> cru_refcnt = atomic_read ( & alg -> cra_refcnt ) ; if ( nla_put_u32 ( skb , CRYPTOCFGA_PRIORITY_VAL , alg -> cra_priority ) ) goto nla_put_failure ; if ( alg -> cra_flags & CRYPTO_ALG_LARVAL ) { struct crypto_report_larval rl ; <S2SV_StartBug> snprintf ( rl . type , CRYPTO_MAX_ALG_NAME , \"%s\" , \"larval\" ) ; <S2SV_EndBug> if ( nla_put ( skb , CRYPTOCFGA_REPORT_LARVAL , sizeof ( struct crypto_report_larval ) , & rl ) ) goto nla_put_failure ; goto out ; } if ( alg -> cra_type && alg -> cra_type -> report ) { if ( alg -> cra_type -> report ( skb , alg ) ) goto nla_put_failure ; goto out ; } switch ( alg -> cra_flags & ( CRYPTO_ALG_TYPE_MASK | CRYPTO_ALG_LARVAL ) ) { case CRYPTO_ALG_TYPE_CIPHER : if ( crypto_report_cipher ( skb , alg ) ) goto nla_put_failure ; break ; case CRYPTO_ALG_TYPE_COMPRESS : if ( crypto_report_comp ( skb , alg ) ) goto nla_put_failure ; break ; } out : return 0 ; nla_put_failure : return - EMSGSIZE ; }\n","target":"<S2SV_ModStart> skb ) { strncpy ( <S2SV_ModEnd> ualg -> cru_name <S2SV_ModStart> -> cru_name , <S2SV_ModEnd> alg -> cra_name <S2SV_ModStart> ) ) ; strncpy ( <S2SV_ModEnd> ualg -> cru_driver_name <S2SV_ModStart> -> cru_driver_name , <S2SV_ModEnd> alg -> cra_driver_name <S2SV_ModStart> ) ) ; strncpy ( <S2SV_ModEnd> ualg -> cru_module_name <S2SV_ModStart> cra_module ) , sizeof ( ualg -> cru_module_name ) ) ; ualg -> cru_type = 0 ; ualg -> cru_mask = 0 <S2SV_ModEnd> ; ualg -> <S2SV_ModStart> crypto_report_larval rl ; strncpy <S2SV_ModEnd> ( rl . <S2SV_ModStart> . type , \"larval\" , sizeof ( rl . type ) <S2SV_ModEnd> ) ; if\n","project_and_commit_id":"torvalds@linux/9a5467bf7b6e9e02ec9c3da4e23747c05faeaac6","cve_id":"CVE-2013-2548","original_address":"https://github.com/torvalds/linux/commit/9a5467bf7b6e9e02ec9c3da4e23747c05faeaac6","time":"2013-03-15T20:55Z"},
	{"Unnamed: 0":6118,"cwe_id":"CWE-189","source":"CWE-189 static void findoprnd ( ITEM * ptr , int32 * pos ) <S2SV_StartBug> { <S2SV_EndBug> if ( ptr [ * pos ] . type == VAL || ptr [ * pos ] . type == VALTRUE ) { ptr [ * pos ] . left = 0 ; ( * pos ) ++ ; } else if ( ptr [ * pos ] . val == ( int32 ) '!' ) { ptr [ * pos ] . left = 1 ; ( * pos ) ++ ; findoprnd ( ptr , pos ) ; } else { ITEM * curitem = & ptr [ * pos ] ; int32 tmp = * pos ; ( * pos ) ++ ; findoprnd ( ptr , pos ) ; curitem -> left = * pos - tmp ; findoprnd ( ptr , pos ) ; } }\n","target":"<S2SV_ModStart> pos ) { check_stack_depth ( ) ;\n","project_and_commit_id":"postgres@postgres/31400a673325147e1205326008e32135a78b4d8a","cve_id":"CVE-2014-2669","original_address":"https://github.com/postgres/postgres/commit/31400a673325147e1205326008e32135a78b4d8a","time":"2014-03-31T14:58Z"},
	{"Unnamed: 0":2993,"cwe_id":"CWE-125","source":"CWE-125 static int serdes_probe ( struct platform_device * pdev ) { struct phy_provider * provider ; struct serdes_ctrl * ctrl ; unsigned int i ; int ret ; ctrl = devm_kzalloc ( & pdev -> dev , sizeof ( * ctrl ) , GFP_KERNEL ) ; if ( ! ctrl ) return - ENOMEM ; ctrl -> dev = & pdev -> dev ; ctrl -> regs = syscon_node_to_regmap ( pdev -> dev . parent -> of_node ) ; if ( IS_ERR ( ctrl -> regs ) ) return PTR_ERR ( ctrl -> regs ) ; <S2SV_StartBug> for ( i = 0 ; i <= SERDES_MAX ; i ++ ) { <S2SV_EndBug> ret = serdes_phy_create ( ctrl , i , & ctrl -> phys [ i ] ) ; if ( ret ) return ret ; } dev_set_drvdata ( & pdev -> dev , ctrl ) ; provider = devm_of_phy_provider_register ( ctrl -> dev , serdes_simple_xlate ) ; return PTR_ERR_OR_ZERO ( provider ) ; }\n","target":"<S2SV_ModStart> 0 ; i < <S2SV_ModEnd> SERDES_MAX ; i\n","project_and_commit_id":"torvalds@linux/6acb47d1a318e5b3b7115354ebc4ea060c59d3a1","cve_id":"CVE-2018-20854","original_address":"https://github.com/torvalds/linux/commit/6acb47d1a318e5b3b7115354ebc4ea060c59d3a1","time":"2019-07-26T05:15Z"},
	{"Unnamed: 0":555,"cwe_id":"CWE-000","source":"CWE-000 static void sas_eh_finish_cmd ( struct scsi_cmnd * cmd ) { struct sas_ha_struct * sas_ha = SHOST_TO_SAS_HA ( cmd -> device -> host ) ; <S2SV_StartBug> struct sas_task * task = TO_SAS_TASK ( cmd ) ; <S2SV_EndBug> sas_end_task ( cmd , task ) ; <S2SV_StartBug> scsi_eh_finish_cmd ( cmd , & sas_ha -> eh_done_q ) ; <S2SV_EndBug> }\n","target":"<S2SV_ModStart> ) ; struct domain_device * dev = cmd_to_domain_dev ( cmd ) ; struct <S2SV_ModStart> task ) ; if ( dev_is_sata ( dev ) ) { list_move_tail ( & cmd -> eh_entry , & sas_ha -> eh_ata_q ) ; return ; }\n","project_and_commit_id":"torvalds@linux/318aaf34f1179b39fa9c30fa0f3288b645beee39","cve_id":"CVE-2018-10021","original_address":"https://github.com/torvalds/linux/commit/318aaf34f1179b39fa9c30fa0f3288b645beee39","time":"2018-04-11T17:29Z"},
	{"Unnamed: 0":5385,"cwe_id":"CWE-401","source":"CWE-401 static int mlx5_fpga_conn_create_cq ( struct mlx5_fpga_conn * conn , int cq_size ) { struct mlx5_fpga_device * fdev = conn -> fdev ; struct mlx5_core_dev * mdev = fdev -> mdev ; u32 temp_cqc [ MLX5_ST_SZ_DW ( cqc ) ] = { 0 } ; u32 out [ MLX5_ST_SZ_DW ( create_cq_out ) ] ; struct mlx5_wq_param wqp ; struct mlx5_cqe64 * cqe ; int inlen , err , eqn ; unsigned int irqn ; void * cqc , * in ; __be64 * pas ; u32 i ; cq_size = roundup_pow_of_two ( cq_size ) ; MLX5_SET ( cqc , temp_cqc , log_cq_size , ilog2 ( cq_size ) ) ; wqp . buf_numa_node = mdev -> priv . numa_node ; wqp . db_numa_node = mdev -> priv . numa_node ; err = mlx5_cqwq_create ( mdev , & wqp , temp_cqc , & conn -> cq . wq , & conn -> cq . wq_ctrl ) ; if ( err ) return err ; for ( i = 0 ; i < mlx5_cqwq_get_size ( & conn -> cq . wq ) ; i ++ ) { cqe = mlx5_cqwq_get_wqe ( & conn -> cq . wq , i ) ; cqe -> op_own = MLX5_CQE_INVALID << 4 | MLX5_CQE_OWNER_MASK ; } inlen = MLX5_ST_SZ_BYTES ( create_cq_in ) + sizeof ( u64 ) * conn -> cq . wq_ctrl . buf . npages ; in = kvzalloc ( inlen , GFP_KERNEL ) ; if ( ! in ) { err = - ENOMEM ; goto err_cqwq ; } err = mlx5_vector2eqn ( mdev , smp_processor_id ( ) , & eqn , & irqn ) ; <S2SV_StartBug> if ( err ) <S2SV_EndBug> <S2SV_StartBug> goto err_cqwq ; <S2SV_EndBug> cqc = MLX5_ADDR_OF ( create_cq_in , in , cq_context ) ; MLX5_SET ( cqc , cqc , log_cq_size , ilog2 ( cq_size ) ) ; MLX5_SET ( cqc , cqc , c_eqn , eqn ) ; MLX5_SET ( cqc , cqc , uar_page , fdev -> conn_res . uar -> index ) ; MLX5_SET ( cqc , cqc , log_page_size , conn -> cq . wq_ctrl . buf . page_shift - MLX5_ADAPTER_PAGE_SHIFT ) ; MLX5_SET64 ( cqc , cqc , dbr_addr , conn -> cq . wq_ctrl . db . dma ) ; pas = ( __be64 * ) MLX5_ADDR_OF ( create_cq_in , in , pas ) ; mlx5_fill_page_frag_array ( & conn -> cq . wq_ctrl . buf , pas ) ; err = mlx5_core_create_cq ( mdev , & conn -> cq . mcq , in , inlen , out , sizeof ( out ) ) ; kvfree ( in ) ; if ( err ) goto err_cqwq ; conn -> cq . mcq . cqe_sz = 64 ; conn -> cq . mcq . set_ci_db = conn -> cq . wq_ctrl . db . db ; conn -> cq . mcq . arm_db = conn -> cq . wq_ctrl . db . db + 1 ; * conn -> cq . mcq . set_ci_db = 0 ; * conn -> cq . mcq . arm_db = 0 ; conn -> cq . mcq . vector = 0 ; conn -> cq . mcq . comp = mlx5_fpga_conn_cq_complete ; conn -> cq . mcq . event = mlx5_fpga_conn_cq_event ; conn -> cq . mcq . irqn = irqn ; conn -> cq . mcq . uar = fdev -> conn_res . uar ; tasklet_init ( & conn -> cq . tasklet , mlx5_fpga_conn_cq_tasklet , ( unsigned long ) conn ) ; mlx5_fpga_dbg ( fdev , \"Created<S2SV_blank>CQ<S2SV_blank>#0x%x\\\\n\" , conn -> cq . mcq . cqn ) ; goto out ; err_cqwq : mlx5_wq_destroy ( & conn -> cq . wq_ctrl ) ; out : return err ; }\n","target":"<S2SV_ModStart> ( err ) { kvfree ( in ) ; <S2SV_ModStart> goto err_cqwq ; }\n","project_and_commit_id":"torvalds@linux/c8c2a057fdc7de1cd16f4baa51425b932a42eb39","cve_id":"CVE-2019-19045","original_address":"https://github.com/torvalds/linux/commit/c8c2a057fdc7de1cd16f4baa51425b932a42eb39","time":"2019-11-18T06:15Z"},
	{"Unnamed: 0":6353,"cwe_id":"CWE-119","source":"CWE-119 <S2SV_StartBug> static void encode_b ( VP9_COMP * cpi , const TileInfo * const tile , <S2SV_EndBug> TOKENEXTRA * * tp , int mi_row , int mi_col , <S2SV_StartBug> int output_enabled , BLOCK_SIZE bsize ) { <S2SV_EndBug> <S2SV_StartBug> MACROBLOCK * const x = & cpi -> mb ; <S2SV_EndBug> <S2SV_StartBug> if ( bsize < BLOCK_8X8 ) { <S2SV_EndBug> if ( x -> ab_index > 0 ) return ; } <S2SV_StartBug> set_offsets ( cpi , tile , mi_row , mi_col , bsize ) ; <S2SV_EndBug> <S2SV_StartBug> update_state ( cpi , get_block_context ( x , bsize ) , mi_row , mi_col , bsize , <S2SV_EndBug> output_enabled ) ; <S2SV_StartBug> encode_superblock ( cpi , tp , output_enabled , mi_row , mi_col , bsize ) ; <S2SV_EndBug> if ( output_enabled ) { <S2SV_StartBug> update_stats ( cpi ) ; <S2SV_EndBug> ( * tp ) -> token = EOSB_TOKEN ; ( * tp ) ++ ; } }\n","target":"<S2SV_ModStart> * const tile , ThreadData * td <S2SV_ModStart> , BLOCK_SIZE bsize , PICK_MODE_CONTEXT * ctx <S2SV_ModStart> x = & td <S2SV_ModEnd> -> mb ; <S2SV_ModStart> -> mb ; <S2SV_ModEnd> set_offsets ( cpi <S2SV_ModStart> cpi , tile , x <S2SV_ModStart> ( cpi , td , ctx <S2SV_ModEnd> , mi_row , <S2SV_ModStart> encode_superblock ( cpi , td <S2SV_ModStart> mi_col , bsize , ctx <S2SV_ModStart> { update_stats ( & cpi -> common , td <S2SV_ModEnd> ) ; (\n","project_and_commit_id":"external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426","cve_id":"CVE-2016-1621","original_address":"https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426","time":"2016-03-12T21:59Z"},
	{"Unnamed: 0":1336,"cwe_id":"CWE-310","source":"CWE-310 struct json_object * json_tokener_parse_ex ( struct json_tokener * tok , const char * str , int len ) { struct json_object * obj = NULL ; char c = '\\\\1' ; # ifdef HAVE_SETLOCALE char * oldlocale = NULL , * tmplocale ; tmplocale = setlocale ( LC_NUMERIC , NULL ) ; if ( tmplocale ) oldlocale = strdup ( tmplocale ) ; setlocale ( LC_NUMERIC , \"C\" ) ; # endif tok -> char_offset = 0 ; <S2SV_StartBug> tok -> err = json_tokener_success ; <S2SV_EndBug> while ( PEEK_CHAR ( c , tok ) ) { redo_char : switch ( state ) { case json_tokener_state_eatws : while ( isspace ( ( int ) c ) ) { if ( ( ! ADVANCE_CHAR ( str , tok ) ) || ( ! PEEK_CHAR ( c , tok ) ) ) goto out ; } if ( c == '/' && ! ( tok -> flags & JSON_TOKENER_STRICT ) ) { printbuf_reset ( tok -> pb ) ; printbuf_memappend_fast ( tok -> pb , & c , 1 ) ; state = json_tokener_state_comment_start ; } else { state = saved_state ; goto redo_char ; } break ; case json_tokener_state_start : switch ( c ) { case '{' : state = json_tokener_state_eatws ; saved_state = json_tokener_state_object_field_start ; current = json_object_new_object ( ) ; break ; case '[' : state = json_tokener_state_eatws ; saved_state = json_tokener_state_array ; current = json_object_new_array ( ) ; break ; case 'I' : case 'i' : state = json_tokener_state_inf ; printbuf_reset ( tok -> pb ) ; tok -> st_pos = 0 ; goto redo_char ; case 'N' : case 'n' : state = json_tokener_state_null ; printbuf_reset ( tok -> pb ) ; tok -> st_pos = 0 ; goto redo_char ; case '\\\\'' : if ( tok -> flags & JSON_TOKENER_STRICT ) { tok -> err = json_tokener_error_parse_unexpected ; goto out ; } case \\'\"\\' : state = json_tokener_state_string ; printbuf_reset ( tok -> pb ) ; tok -> quote_char = c ; break ; case 'T' : case 't' : case 'F' : case 'f' : state = json_tokener_state_boolean ; printbuf_reset ( tok -> pb ) ; tok -> st_pos = 0 ; goto redo_char ; # if defined ( __GNUC__ ) case '0' ... '9' : # else case '0' : case '1' : case '2' : case '3' : case '4' : case '5' : case '6' : case '7' : case '8' : case '9' : # endif case '-' : state = json_tokener_state_number ; printbuf_reset ( tok -> pb ) ; tok -> is_double = 0 ; goto redo_char ; default : tok -> err = json_tokener_error_parse_unexpected ; goto out ; } break ; case json_tokener_state_finish : if ( tok -> depth == 0 ) goto out ; obj = json_object_get ( current ) ; json_tokener_reset_level ( tok , tok -> depth ) ; tok -> depth -- ; goto redo_char ; case json_tokener_state_inf : { int size ; int size_inf ; int is_negative = 0 ; printbuf_memappend_fast ( tok -> pb , & c , 1 ) ; size = json_min ( tok -> st_pos + 1 , json_null_str_len ) ; size_inf = json_min ( tok -> st_pos + 1 , json_inf_str_len ) ; char * infbuf = tok -> pb -> buf ; if ( * infbuf == '-' ) { infbuf ++ ; is_negative = 1 ; } if ( ( ! ( tok -> flags & JSON_TOKENER_STRICT ) && strncasecmp ( json_inf_str , infbuf , size_inf ) == 0 ) || ( strncmp ( json_inf_str , infbuf , size_inf ) == 0 ) ) { if ( tok -> st_pos == json_inf_str_len ) { current = json_object_new_double ( is_negative ? - INFINITY : INFINITY ) ; saved_state = json_tokener_state_finish ; state = json_tokener_state_eatws ; goto redo_char ; } } else { tok -> err = json_tokener_error_parse_unexpected ; goto out ; } tok -> st_pos ++ ; } break ; case json_tokener_state_null : { int size ; int size_nan ; printbuf_memappend_fast ( tok -> pb , & c , 1 ) ; size = json_min ( tok -> st_pos + 1 , json_null_str_len ) ; size_nan = json_min ( tok -> st_pos + 1 , json_nan_str_len ) ; if ( ( ! ( tok -> flags & JSON_TOKENER_STRICT ) && strncasecmp ( json_null_str , tok -> pb -> buf , size ) == 0 ) || ( strncmp ( json_null_str , tok -> pb -> buf , size ) == 0 ) ) { if ( tok -> st_pos == json_null_str_len ) { current = NULL ; saved_state = json_tokener_state_finish ; state = json_tokener_state_eatws ; goto redo_char ; } } else if ( ( ! ( tok -> flags & JSON_TOKENER_STRICT ) && strncasecmp ( json_nan_str , tok -> pb -> buf , size_nan ) == 0 ) || ( strncmp ( json_nan_str , tok -> pb -> buf , size_nan ) == 0 ) ) { if ( tok -> st_pos == json_nan_str_len ) { current = json_object_new_double ( NAN ) ; saved_state = json_tokener_state_finish ; state = json_tokener_state_eatws ; goto redo_char ; } } else { tok -> err = json_tokener_error_parse_null ; goto out ; } tok -> st_pos ++ ; } break ; case json_tokener_state_comment_start : if ( c == '*' ) { state = json_tokener_state_comment ; } else if ( c == '/' ) { state = json_tokener_state_comment_eol ; } else { tok -> err = json_tokener_error_parse_comment ; goto out ; } printbuf_memappend_fast ( tok -> pb , & c , 1 ) ; break ; case json_tokener_state_comment : { const char * case_start = str ; while ( c != '*' ) { if ( ! ADVANCE_CHAR ( str , tok ) || ! PEEK_CHAR ( c , tok ) ) { printbuf_memappend_fast ( tok -> pb , case_start , str - case_start ) ; goto out ; } } printbuf_memappend_fast ( tok -> pb , case_start , 1 + str - case_start ) ; state = json_tokener_state_comment_end ; } break ; case json_tokener_state_comment_eol : { const char * case_start = str ; while ( c != '\\\\n' ) { if ( ! ADVANCE_CHAR ( str , tok ) || ! PEEK_CHAR ( c , tok ) ) { printbuf_memappend_fast ( tok -> pb , case_start , str - case_start ) ; goto out ; } } printbuf_memappend_fast ( tok -> pb , case_start , str - case_start ) ; MC_DEBUG ( \"json_tokener_comment:<S2SV_blank>%s\\\\n\" , tok -> pb -> buf ) ; state = json_tokener_state_eatws ; } break ; case json_tokener_state_comment_end : printbuf_memappend_fast ( tok -> pb , & c , 1 ) ; if ( c == '/' ) { MC_DEBUG ( \"json_tokener_comment:<S2SV_blank>%s\\\\n\" , tok -> pb -> buf ) ; state = json_tokener_state_eatws ; } else { state = json_tokener_state_comment ; } break ; case json_tokener_state_string : { const char * case_start = str ; while ( 1 ) { if ( c == tok -> quote_char ) { printbuf_memappend_fast ( tok -> pb , case_start , str - case_start ) ; current = json_object_new_string_len ( tok -> pb -> buf , tok -> pb -> bpos ) ; saved_state = json_tokener_state_finish ; state = json_tokener_state_eatws ; break ; } else if ( c == '\\\\\\\\' ) { printbuf_memappend_fast ( tok -> pb , case_start , str - case_start ) ; saved_state = json_tokener_state_string ; state = json_tokener_state_string_escape ; break ; } if ( ! ADVANCE_CHAR ( str , tok ) || ! PEEK_CHAR ( c , tok ) ) { printbuf_memappend_fast ( tok -> pb , case_start , str - case_start ) ; goto out ; } } } break ; case json_tokener_state_string_escape : switch ( c ) { case \\'\"\\' : case '\\\\\\\\' : case '/' : printbuf_memappend_fast ( tok -> pb , & c , 1 ) ; state = saved_state ; break ; case 'b' : case 'n' : case 'r' : case 't' : case 'f' : if ( c == 'b' ) printbuf_memappend_fast ( tok -> pb , \"\\\\b\" , 1 ) ; else if ( c == 'n' ) printbuf_memappend_fast ( tok -> pb , \"\\\\n\" , 1 ) ; else if ( c == 'r' ) printbuf_memappend_fast ( tok -> pb , \"\\\\r\" , 1 ) ; else if ( c == 't' ) printbuf_memappend_fast ( tok -> pb , \"\\\\t\" , 1 ) ; else if ( c == 'f' ) printbuf_memappend_fast ( tok -> pb , \"\\\\f\" , 1 ) ; state = saved_state ; break ; case 'u' : tok -> ucs_char = 0 ; tok -> st_pos = 0 ; state = json_tokener_state_escape_unicode ; break ; default : tok -> err = json_tokener_error_parse_string ; goto out ; } break ; case json_tokener_state_escape_unicode : { unsigned int got_hi_surrogate = 0 ; while ( 1 ) { if ( strchr ( json_hex_chars , c ) ) { tok -> ucs_char += ( ( unsigned int ) hexdigit ( c ) << ( ( 3 - tok -> st_pos ++ ) * 4 ) ) ; if ( tok -> st_pos == 4 ) { unsigned char unescaped_utf [ 4 ] ; if ( got_hi_surrogate ) { if ( IS_LOW_SURROGATE ( tok -> ucs_char ) ) { tok -> ucs_char = DECODE_SURROGATE_PAIR ( got_hi_surrogate , tok -> ucs_char ) ; } else { printbuf_memappend_fast ( tok -> pb , ( char * ) utf8_replacement_char , 3 ) ; } got_hi_surrogate = 0 ; } if ( tok -> ucs_char < 0x80 ) { unescaped_utf [ 0 ] = tok -> ucs_char ; printbuf_memappend_fast ( tok -> pb , ( char * ) unescaped_utf , 1 ) ; } else if ( tok -> ucs_char < 0x800 ) { unescaped_utf [ 0 ] = 0xc0 | ( tok -> ucs_char >> 6 ) ; unescaped_utf [ 1 ] = 0x80 | ( tok -> ucs_char & 0x3f ) ; printbuf_memappend_fast ( tok -> pb , ( char * ) unescaped_utf , 2 ) ; } else if ( IS_HIGH_SURROGATE ( tok -> ucs_char ) ) { got_hi_surrogate = tok -> ucs_char ; if ( ( tok -> char_offset + 1 != len ) && ( tok -> char_offset + 2 != len ) && ( str [ 1 ] == '\\\\\\\\' ) && ( str [ 2 ] == 'u' ) ) { if ( ! ADVANCE_CHAR ( str , tok ) || ! ADVANCE_CHAR ( str , tok ) ) { printbuf_memappend_fast ( tok -> pb , ( char * ) utf8_replacement_char , 3 ) ; } if ( ! ADVANCE_CHAR ( str , tok ) || ! PEEK_CHAR ( c , tok ) ) { printbuf_memappend_fast ( tok -> pb , ( char * ) utf8_replacement_char , 3 ) ; goto out ; } tok -> ucs_char = 0 ; tok -> st_pos = 0 ; continue ; } else { printbuf_memappend_fast ( tok -> pb , ( char * ) utf8_replacement_char , 3 ) ; } } else if ( IS_LOW_SURROGATE ( tok -> ucs_char ) ) { printbuf_memappend_fast ( tok -> pb , ( char * ) utf8_replacement_char , 3 ) ; } else if ( tok -> ucs_char < 0x10000 ) { unescaped_utf [ 0 ] = 0xe0 | ( tok -> ucs_char >> 12 ) ; unescaped_utf [ 1 ] = 0x80 | ( ( tok -> ucs_char >> 6 ) & 0x3f ) ; unescaped_utf [ 2 ] = 0x80 | ( tok -> ucs_char & 0x3f ) ; printbuf_memappend_fast ( tok -> pb , ( char * ) unescaped_utf , 3 ) ; } else if ( tok -> ucs_char < 0x110000 ) { unescaped_utf [ 0 ] = 0xf0 | ( ( tok -> ucs_char >> 18 ) & 0x07 ) ; unescaped_utf [ 1 ] = 0x80 | ( ( tok -> ucs_char >> 12 ) & 0x3f ) ; unescaped_utf [ 2 ] = 0x80 | ( ( tok -> ucs_char >> 6 ) & 0x3f ) ; unescaped_utf [ 3 ] = 0x80 | ( tok -> ucs_char & 0x3f ) ; printbuf_memappend_fast ( tok -> pb , ( char * ) unescaped_utf , 4 ) ; } else { printbuf_memappend_fast ( tok -> pb , ( char * ) utf8_replacement_char , 3 ) ; } state = saved_state ; break ; } } else { tok -> err = json_tokener_error_parse_string ; goto out ; } if ( ! ADVANCE_CHAR ( str , tok ) || ! PEEK_CHAR ( c , tok ) ) { if ( got_hi_surrogate ) printbuf_memappend_fast ( tok -> pb , ( char * ) utf8_replacement_char , 3 ) ; goto out ; } } } break ; case json_tokener_state_boolean : { int size1 , size2 ; printbuf_memappend_fast ( tok -> pb , & c , 1 ) ; size1 = json_min ( tok -> st_pos + 1 , json_true_str_len ) ; size2 = json_min ( tok -> st_pos + 1 , json_false_str_len ) ; if ( ( ! ( tok -> flags & JSON_TOKENER_STRICT ) && strncasecmp ( json_true_str , tok -> pb -> buf , size1 ) == 0 ) || ( strncmp ( json_true_str , tok -> pb -> buf , size1 ) == 0 ) ) { if ( tok -> st_pos == json_true_str_len ) { current = json_object_new_boolean ( 1 ) ; saved_state = json_tokener_state_finish ; state = json_tokener_state_eatws ; goto redo_char ; } } else if ( ( ! ( tok -> flags & JSON_TOKENER_STRICT ) && strncasecmp ( json_false_str , tok -> pb -> buf , size2 ) == 0 ) || ( strncmp ( json_false_str , tok -> pb -> buf , size2 ) == 0 ) ) { if ( tok -> st_pos == json_false_str_len ) { current = json_object_new_boolean ( 0 ) ; saved_state = json_tokener_state_finish ; state = json_tokener_state_eatws ; goto redo_char ; } } else { tok -> err = json_tokener_error_parse_boolean ; goto out ; } tok -> st_pos ++ ; } break ; case json_tokener_state_number : { const char * case_start = str ; int case_len = 0 ; while ( c && strchr ( json_number_chars , c ) ) { ++ case_len ; if ( c == '.' || c == 'e' || c == 'E' ) tok -> is_double = 1 ; if ( ! ADVANCE_CHAR ( str , tok ) || ! PEEK_CHAR ( c , tok ) ) { printbuf_memappend_fast ( tok -> pb , case_start , case_len ) ; goto out ; } } if ( case_len > 0 ) printbuf_memappend_fast ( tok -> pb , case_start , case_len ) ; if ( tok -> pb -> buf [ 0 ] == '-' && case_len == 1 && ( c == 'i' || c == 'I' ) ) { state = json_tokener_state_inf ; goto redo_char ; } } { int64_t num64 ; double numd ; if ( ! tok -> is_double && json_parse_int64 ( tok -> pb -> buf , & num64 ) == 0 ) { if ( num64 && tok -> pb -> buf [ 0 ] == '0' && ( tok -> flags & JSON_TOKENER_STRICT ) ) { tok -> err = json_tokener_error_parse_number ; goto out ; } current = json_object_new_int64 ( num64 ) ; } else if ( tok -> is_double && json_parse_double ( tok -> pb -> buf , & numd ) == 0 ) { current = json_object_new_double_s ( numd , tok -> pb -> buf ) ; } else { tok -> err = json_tokener_error_parse_number ; goto out ; } saved_state = json_tokener_state_finish ; state = json_tokener_state_eatws ; goto redo_char ; } break ; case json_tokener_state_array_after_sep : case json_tokener_state_array : if ( c == ']' ) { if ( state == json_tokener_state_array_after_sep && ( tok -> flags & JSON_TOKENER_STRICT ) ) { tok -> err = json_tokener_error_parse_unexpected ; goto out ; } saved_state = json_tokener_state_finish ; state = json_tokener_state_eatws ; } else { if ( tok -> depth >= tok -> max_depth - 1 ) { tok -> err = json_tokener_error_depth ; goto out ; } state = json_tokener_state_array_add ; tok -> depth ++ ; json_tokener_reset_level ( tok , tok -> depth ) ; goto redo_char ; } break ; case json_tokener_state_array_add : json_object_array_add ( current , obj ) ; saved_state = json_tokener_state_array_sep ; state = json_tokener_state_eatws ; goto redo_char ; case json_tokener_state_array_sep : if ( c == ']' ) { saved_state = json_tokener_state_finish ; state = json_tokener_state_eatws ; } else if ( c == ',' ) { saved_state = json_tokener_state_array_after_sep ; state = json_tokener_state_eatws ; } else { tok -> err = json_tokener_error_parse_array ; goto out ; } break ; case json_tokener_state_object_field_start : case json_tokener_state_object_field_start_after_sep : if ( c == '}' ) { if ( state == json_tokener_state_object_field_start_after_sep && ( tok -> flags & JSON_TOKENER_STRICT ) ) { tok -> err = json_tokener_error_parse_unexpected ; goto out ; } saved_state = json_tokener_state_finish ; state = json_tokener_state_eatws ; } else if ( c == \\'\"\\' || c == '\\\\'' ) { tok -> quote_char = c ; printbuf_reset ( tok -> pb ) ; state = json_tokener_state_object_field ; } else { tok -> err = json_tokener_error_parse_object_key_name ; goto out ; } break ; case json_tokener_state_object_field : { const char * case_start = str ; while ( 1 ) { if ( c == tok -> quote_char ) { printbuf_memappend_fast ( tok -> pb , case_start , str - case_start ) ; obj_field_name = strdup ( tok -> pb -> buf ) ; saved_state = json_tokener_state_object_field_end ; state = json_tokener_state_eatws ; break ; } else if ( c == '\\\\\\\\' ) { printbuf_memappend_fast ( tok -> pb , case_start , str - case_start ) ; saved_state = json_tokener_state_object_field ; state = json_tokener_state_string_escape ; break ; } if ( ! ADVANCE_CHAR ( str , tok ) || ! PEEK_CHAR ( c , tok ) ) { printbuf_memappend_fast ( tok -> pb , case_start , str - case_start ) ; goto out ; } } } break ; case json_tokener_state_object_field_end : if ( c == ':' ) { saved_state = json_tokener_state_object_value ; state = json_tokener_state_eatws ; } else { tok -> err = json_tokener_error_parse_object_key_sep ; goto out ; } break ; case json_tokener_state_object_value : if ( tok -> depth >= tok -> max_depth - 1 ) { tok -> err = json_tokener_error_depth ; goto out ; } state = json_tokener_state_object_value_add ; tok -> depth ++ ; json_tokener_reset_level ( tok , tok -> depth ) ; goto redo_char ; case json_tokener_state_object_value_add : json_object_object_add ( current , obj_field_name , obj ) ; free ( obj_field_name ) ; obj_field_name = NULL ; saved_state = json_tokener_state_object_sep ; state = json_tokener_state_eatws ; goto redo_char ; case json_tokener_state_object_sep : if ( c == '}' ) { saved_state = json_tokener_state_finish ; state = json_tokener_state_eatws ; } else if ( c == ',' ) { saved_state = json_tokener_state_object_field_start_after_sep ; state = json_tokener_state_eatws ; } else { tok -> err = json_tokener_error_parse_object_value_sep ; goto out ; } break ; } if ( ! ADVANCE_CHAR ( str , tok ) ) goto out ; } out : if ( c && ( state == json_tokener_state_finish ) && ( tok -> depth == 0 ) && ( tok -> flags & JSON_TOKENER_STRICT ) ) { tok -> err = json_tokener_error_parse_unexpected ; } if ( ! c ) { if ( state != json_tokener_state_finish && saved_state != json_tokener_state_finish ) tok -> err = json_tokener_error_parse_eof ; } # ifdef HAVE_SETLOCALE setlocale ( LC_NUMERIC , oldlocale ) ; if ( oldlocale ) free ( oldlocale ) ; # endif if ( tok -> err == json_tokener_success ) { json_object * ret = json_object_get ( current ) ; int ii ; for ( ii = tok -> depth ; ii >= 0 ; ii -- ) json_tokener_reset_level ( tok , ii ) ; return ret ; } MC_DEBUG ( \"json_tokener_parse_ex:<S2SV_blank>error<S2SV_blank>%s<S2SV_blank>at<S2SV_blank>offset<S2SV_blank>%d\\\\n\" , json_tokener_errors [ tok -> err ] , tok -> char_offset ) ; return NULL ; }\n","target":"<S2SV_ModStart> = json_tokener_success ; if ( ( len < - 1 ) || ( len == - 1 && strlen ( str ) > INT32_MAX ) ) { tok -> err = json_tokener_error_size ; return NULL ; }\n","project_and_commit_id":"json-c@json-c/64e36901a0614bf64a19bc3396469c66dcd0b015","cve_id":"CVE-2013-6371","original_address":"https://github.com/json-c/json-c/commit/64e36901a0614bf64a19bc3396469c66dcd0b015","time":"2014-04-22T13:06Z"},
	{"Unnamed: 0":4357,"cwe_id":"CWE-416","source":"CWE-416 int blk_rq_map_user_iov ( struct request_queue * q , struct request * rq , struct rq_map_data * map_data , const struct iov_iter * iter , gfp_t gfp_mask ) { bool copy = false ; unsigned long align = q -> dma_pad_mask | queue_dma_alignment ( q ) ; struct bio * bio = NULL ; struct iov_iter i ; int ret ; <S2SV_StartBug> if ( map_data ) <S2SV_EndBug> copy = true ; else if ( iov_iter_alignment ( iter ) & align ) copy = true ; else if ( queue_virt_boundary ( q ) ) copy = queue_virt_boundary ( q ) & iov_iter_gap_alignment ( iter ) ; i = * iter ; do { ret = __blk_rq_map_user_iov ( rq , map_data , & i , gfp_mask , copy ) ; if ( ret ) goto unmap_rq ; if ( ! bio ) bio = rq -> bio ; } while ( iov_iter_count ( & i ) ) ; if ( ! bio_flagged ( bio , BIO_USER_MAPPED ) ) rq -> cmd_flags |= REQ_COPY_USER ; return 0 ; unmap_rq : __blk_rq_unmap_user ( bio ) ; <S2SV_StartBug> rq -> bio = NULL ; <S2SV_EndBug> return - EINVAL ; }\n","target":"<S2SV_ModStart> ; if ( ! iter_is_iovec ( iter ) ) goto fail ; if ( <S2SV_ModStart> bio ) ; fail :\n","project_and_commit_id":"torvalds@linux/a0ac402cfcdc904f9772e1762b3fda112dcc56a0","cve_id":"CVE-2016-9576","original_address":"https://github.com/torvalds/linux/commit/a0ac402cfcdc904f9772e1762b3fda112dcc56a0","time":"2016-12-28T07:59Z"},
	{"Unnamed: 0":2630,"cwe_id":"CWE-369","source":"CWE-369 void fmtutil_macbitmap_read_pixmap_only_fields ( deark * c , dbuf * f , struct fmtutil_macbitmap_info * bi , i64 pos ) { i64 pixmap_version ; i64 pack_size ; i64 plane_bytes ; i64 n ; de_dbg ( c , \"additional<S2SV_blank>PixMap<S2SV_blank>header<S2SV_blank>fields,<S2SV_blank>at<S2SV_blank>%d\" , ( int ) pos ) ; de_dbg_indent ( c , 1 ) ; pixmap_version = dbuf_getu16be ( f , pos + 0 ) ; de_dbg ( c , \"pixmap<S2SV_blank>version:<S2SV_blank>%d\" , ( int ) pixmap_version ) ; bi -> packing_type = dbuf_getu16be ( f , pos + 2 ) ; de_dbg ( c , \"packing<S2SV_blank>type:<S2SV_blank>%d\" , ( int ) bi -> packing_type ) ; pack_size = dbuf_getu32be ( f , pos + 4 ) ; de_dbg ( c , \"pixel<S2SV_blank>data<S2SV_blank>length:<S2SV_blank>%d\" , ( int ) pack_size ) ; bi -> hdpi = pict_read_fixed ( f , pos + 8 ) ; bi -> vdpi = pict_read_fixed ( f , pos + 12 ) ; de_dbg ( c , \"dpi:<S2SV_blank>%.2f\" DE_CHAR_TIMES \"%.2f\" , bi -> hdpi , bi -> vdpi ) ; bi -> pixeltype = dbuf_getu16be ( f , pos + 16 ) ; bi -> pixelsize = dbuf_getu16be ( f , pos + 18 ) ; bi -> cmpcount = dbuf_getu16be ( f , pos + 20 ) ; bi -> cmpsize = dbuf_getu16be ( f , pos + 22 ) ; de_dbg ( c , \"pixel<S2SV_blank>type=%d,<S2SV_blank>bits/pixel=%d,<S2SV_blank>components/pixel=%d,<S2SV_blank>bits/comp=%d\" , ( int ) bi -> pixeltype , ( int ) bi -> pixelsize , ( int ) bi -> cmpcount , ( int ) bi -> cmpsize ) ; <S2SV_StartBug> bi -> pdwidth = ( bi -> rowbytes * 8 ) / bi -> pixelsize ; <S2SV_EndBug> <S2SV_StartBug> if ( bi -> pdwidth < bi -> npwidth ) { <S2SV_EndBug> bi -> pdwidth = bi -> npwidth ; } plane_bytes = dbuf_getu32be ( f , pos + 24 ) ; de_dbg ( c , \"plane<S2SV_blank>bytes:<S2SV_blank>%d\" , ( int ) plane_bytes ) ; bi -> pmTable = ( u32 ) dbuf_getu32be ( f , pos + 28 ) ; de_dbg ( c , \"pmTable:<S2SV_blank>0x%08x\" , ( unsigned int ) bi -> pmTable ) ; n = dbuf_getu32be ( f , pos + 32 ) ; de_dbg ( c , \"pmReserved:<S2SV_blank>0x%08x\" , ( unsigned int ) n ) ; de_dbg_indent ( c , - 1 ) ; }\n","target":"<S2SV_ModStart> cmpsize ) ; if ( bi -> pixelsize > 0 ) { <S2SV_ModStart> -> pixelsize ; }\n","project_and_commit_id":"jsummers@deark/62acb7753b0e3c0d3ab3c15057b0a65222313334","cve_id":"CVE-2021-28856","original_address":"https://github.com/jsummers/deark/commit/62acb7753b0e3c0d3ab3c15057b0a65222313334","time":"2021-04-14T17:15Z"},
	{"Unnamed: 0":5209,"cwe_id":"CWE-119","source":"CWE-119 static void set_default_lf_deltas ( VP8_COMP * cpi ) { cpi -> mb . e_mbd . mode_ref_lf_delta_enabled = 1 ; cpi -> mb . e_mbd . mode_ref_lf_delta_update = 1 ; <S2SV_StartBug> vpx_memset ( cpi -> mb . e_mbd . ref_lf_deltas , 0 , sizeof ( cpi -> mb . e_mbd . ref_lf_deltas ) ) ; <S2SV_EndBug> <S2SV_StartBug> vpx_memset ( cpi -> mb . e_mbd . mode_lf_deltas , 0 , sizeof ( cpi -> mb . e_mbd . mode_lf_deltas ) ) ; <S2SV_EndBug> cpi -> mb . e_mbd . ref_lf_deltas [ INTRA_FRAME ] = 2 ; cpi -> mb . e_mbd . ref_lf_deltas [ LAST_FRAME ] = 0 ; cpi -> mb . e_mbd . ref_lf_deltas [ GOLDEN_FRAME ] = - 2 ; cpi -> mb . e_mbd . ref_lf_deltas [ ALTREF_FRAME ] = - 2 ; cpi -> mb . e_mbd . mode_lf_deltas [ 0 ] = 4 ; if ( cpi -> oxcf . Mode == MODE_REALTIME ) cpi -> mb . e_mbd . mode_lf_deltas [ 1 ] = - 12 ; else cpi -> mb . e_mbd . mode_lf_deltas [ 1 ] = - 2 ; cpi -> mb . e_mbd . mode_lf_deltas [ 2 ] = 2 ; cpi -> mb . e_mbd . mode_lf_deltas [ 3 ] = 4 ; }\n","target":"<S2SV_ModStart> = 1 ; memset <S2SV_ModEnd> ( cpi -> <S2SV_ModStart> ) ) ; memset <S2SV_ModEnd> ( cpi ->\n","project_and_commit_id":"external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426","cve_id":"CVE-2016-1621","original_address":"https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426","time":"2016-03-12T21:59Z"},
	{"Unnamed: 0":641,"cwe_id":"CWE-119","source":"CWE-119 TEE_Result syscall_cryp_derive_key ( unsigned long state , const struct utee_attribute * usr_params , unsigned long param_count , unsigned long derived_key ) { TEE_Result res = TEE_ERROR_NOT_SUPPORTED ; struct tee_ta_session * sess ; struct tee_obj * ko ; struct tee_obj * so ; struct tee_cryp_state * cs ; struct tee_cryp_obj_secret * sk ; const struct tee_cryp_obj_type_props * type_props ; TEE_Attribute * params = NULL ; struct user_ta_ctx * utc ; res = tee_ta_get_current_session ( & sess ) ; if ( res != TEE_SUCCESS ) return res ; utc = to_user_ta_ctx ( sess -> ctx ) ; res = tee_svc_cryp_get_state ( sess , tee_svc_uref_to_vaddr ( state ) , & cs ) ; if ( res != TEE_SUCCESS ) return res ; <S2SV_StartBug> params = malloc ( sizeof ( TEE_Attribute ) * param_count ) ; <S2SV_EndBug> if ( ! params ) return TEE_ERROR_OUT_OF_MEMORY ; res = copy_in_attrs ( utc , usr_params , param_count , params ) ; if ( res != TEE_SUCCESS ) goto out ; res = tee_obj_get ( utc , cs -> key1 , & ko ) ; if ( res != TEE_SUCCESS ) goto out ; res = tee_obj_get ( utc , tee_svc_uref_to_vaddr ( derived_key ) , & so ) ; if ( res != TEE_SUCCESS ) goto out ; sk = so -> attr ; type_props = tee_svc_find_type_props ( so -> info . objectType ) ; if ( ! type_props ) { res = TEE_ERROR_NOT_SUPPORTED ; goto out ; } if ( cs -> algo == TEE_ALG_DH_DERIVE_SHARED_SECRET ) { size_t alloc_size ; struct bignum * pub ; struct bignum * ss ; if ( param_count != 1 || params [ 0 ] . attributeID != TEE_ATTR_DH_PUBLIC_VALUE ) { res = TEE_ERROR_BAD_PARAMETERS ; goto out ; } alloc_size = params [ 0 ] . content . ref . length * 8 ; pub = crypto_bignum_allocate ( alloc_size ) ; ss = crypto_bignum_allocate ( alloc_size ) ; if ( pub && ss ) { crypto_bignum_bin2bn ( params [ 0 ] . content . ref . buffer , params [ 0 ] . content . ref . length , pub ) ; res = crypto_acipher_dh_shared_secret ( ko -> attr , pub , ss ) ; if ( res == TEE_SUCCESS ) { sk -> key_size = crypto_bignum_num_bytes ( ss ) ; crypto_bignum_bn2bin ( ss , ( uint8_t * ) ( sk + 1 ) ) ; so -> info . handleFlags |= TEE_HANDLE_FLAG_INITIALIZED ; set_attribute ( so , type_props , TEE_ATTR_SECRET_VALUE ) ; } } else { res = TEE_ERROR_OUT_OF_MEMORY ; } crypto_bignum_free ( pub ) ; crypto_bignum_free ( ss ) ; } else if ( TEE_ALG_GET_MAIN_ALG ( cs -> algo ) == TEE_MAIN_ALGO_ECDH ) { size_t alloc_size ; struct ecc_public_key key_public ; uint8_t * pt_secret ; unsigned long pt_secret_len ; if ( param_count != 2 || params [ 0 ] . attributeID != TEE_ATTR_ECC_PUBLIC_VALUE_X || params [ 1 ] . attributeID != TEE_ATTR_ECC_PUBLIC_VALUE_Y ) { res = TEE_ERROR_BAD_PARAMETERS ; goto out ; } switch ( cs -> algo ) { case TEE_ALG_ECDH_P192 : alloc_size = 192 ; break ; case TEE_ALG_ECDH_P224 : alloc_size = 224 ; break ; case TEE_ALG_ECDH_P256 : alloc_size = 256 ; break ; case TEE_ALG_ECDH_P384 : alloc_size = 384 ; break ; case TEE_ALG_ECDH_P521 : alloc_size = 521 ; break ; default : res = TEE_ERROR_NOT_IMPLEMENTED ; goto out ; } res = crypto_acipher_alloc_ecc_public_key ( & key_public , alloc_size ) ; if ( res != TEE_SUCCESS ) goto out ; key_public . curve = ( ( struct ecc_keypair * ) ko -> attr ) -> curve ; crypto_bignum_bin2bn ( params [ 0 ] . content . ref . buffer , params [ 0 ] . content . ref . length , key_public . x ) ; crypto_bignum_bin2bn ( params [ 1 ] . content . ref . buffer , params [ 1 ] . content . ref . length , key_public . y ) ; pt_secret = ( uint8_t * ) ( sk + 1 ) ; pt_secret_len = sk -> alloc_size ; res = crypto_acipher_ecc_shared_secret ( ko -> attr , & key_public , pt_secret , & pt_secret_len ) ; if ( res == TEE_SUCCESS ) { sk -> key_size = pt_secret_len ; so -> info . handleFlags |= TEE_HANDLE_FLAG_INITIALIZED ; set_attribute ( so , type_props , TEE_ATTR_SECRET_VALUE ) ; } crypto_acipher_free_ecc_public_key ( & key_public ) ; } # if defined ( CFG_CRYPTO_HKDF ) else if ( TEE_ALG_GET_MAIN_ALG ( cs -> algo ) == TEE_MAIN_ALGO_HKDF ) { void * salt , * info ; size_t salt_len , info_len , okm_len ; uint32_t hash_id = TEE_ALG_GET_DIGEST_HASH ( cs -> algo ) ; struct tee_cryp_obj_secret * ik = ko -> attr ; const uint8_t * ikm = ( const uint8_t * ) ( ik + 1 ) ; res = get_hkdf_params ( params , param_count , & salt , & salt_len , & info , & info_len , & okm_len ) ; if ( res != TEE_SUCCESS ) goto out ; if ( okm_len > ik -> alloc_size ) { res = TEE_ERROR_BAD_PARAMETERS ; goto out ; } res = tee_cryp_hkdf ( hash_id , ikm , ik -> key_size , salt , salt_len , info , info_len , ( uint8_t * ) ( sk + 1 ) , okm_len ) ; if ( res == TEE_SUCCESS ) { sk -> key_size = okm_len ; so -> info . handleFlags |= TEE_HANDLE_FLAG_INITIALIZED ; set_attribute ( so , type_props , TEE_ATTR_SECRET_VALUE ) ; } } # endif # if defined ( CFG_CRYPTO_CONCAT_KDF ) else if ( TEE_ALG_GET_MAIN_ALG ( cs -> algo ) == TEE_MAIN_ALGO_CONCAT_KDF ) { void * info ; size_t info_len , derived_key_len ; uint32_t hash_id = TEE_ALG_GET_DIGEST_HASH ( cs -> algo ) ; struct tee_cryp_obj_secret * ss = ko -> attr ; const uint8_t * shared_secret = ( const uint8_t * ) ( ss + 1 ) ; res = get_concat_kdf_params ( params , param_count , & info , & info_len , & derived_key_len ) ; if ( res != TEE_SUCCESS ) goto out ; if ( derived_key_len > ss -> alloc_size ) { res = TEE_ERROR_BAD_PARAMETERS ; goto out ; } res = tee_cryp_concat_kdf ( hash_id , shared_secret , ss -> key_size , info , info_len , ( uint8_t * ) ( sk + 1 ) , derived_key_len ) ; if ( res == TEE_SUCCESS ) { sk -> key_size = derived_key_len ; so -> info . handleFlags |= TEE_HANDLE_FLAG_INITIALIZED ; set_attribute ( so , type_props , TEE_ATTR_SECRET_VALUE ) ; } } # endif # if defined ( CFG_CRYPTO_PBKDF2 ) else if ( TEE_ALG_GET_MAIN_ALG ( cs -> algo ) == TEE_MAIN_ALGO_PBKDF2 ) { void * salt ; size_t salt_len , iteration_count , derived_key_len ; uint32_t hash_id = TEE_ALG_GET_DIGEST_HASH ( cs -> algo ) ; struct tee_cryp_obj_secret * ss = ko -> attr ; const uint8_t * password = ( const uint8_t * ) ( ss + 1 ) ; res = get_pbkdf2_params ( params , param_count , & salt , & salt_len , & derived_key_len , & iteration_count ) ; if ( res != TEE_SUCCESS ) goto out ; if ( derived_key_len > ss -> alloc_size ) { res = TEE_ERROR_BAD_PARAMETERS ; goto out ; } res = tee_cryp_pbkdf2 ( hash_id , password , ss -> key_size , salt , salt_len , iteration_count , ( uint8_t * ) ( sk + 1 ) , derived_key_len ) ; if ( res == TEE_SUCCESS ) { sk -> key_size = derived_key_len ; so -> info . handleFlags |= TEE_HANDLE_FLAG_INITIALIZED ; set_attribute ( so , type_props , TEE_ATTR_SECRET_VALUE ) ; } } # endif else res = TEE_ERROR_NOT_SUPPORTED ; out : free ( params ) ; return res ; }\n","target":"<S2SV_ModStart> return res ; size_t alloc_size = 0 ; if ( MUL_OVERFLOW ( sizeof ( TEE_Attribute ) , param_count , & alloc_size ) ) return TEE_ERROR_OVERFLOW ; <S2SV_ModStart> = malloc ( alloc_size <S2SV_ModEnd> ) ; if\n","project_and_commit_id":"OP-TEE@optee_os/a637243270fc1faae16de059091795c32d86e65e","cve_id":"CVE-2019-1010297","original_address":"https://github.com/OP-TEE/optee_os/commit/a637243270fc1faae16de059091795c32d86e65e","time":"2019-07-15T18:15Z"},
	{"Unnamed: 0":271,"cwe_id":"CWE-190","source":"CWE-190 uint8_t hfs_cat_traverse ( HFS_INFO * hfs , TSK_HFS_BTREE_CB a_cb , void * ptr ) { TSK_FS_INFO * fs = & ( hfs -> fs_info ) ; uint32_t cur_node ; char * node ; uint16_t nodesize ; uint8_t is_done = 0 ; tsk_error_reset ( ) ; nodesize = tsk_getu16 ( fs -> endian , hfs -> catalog_header . nodesize ) ; if ( ( node = ( char * ) tsk_malloc ( nodesize ) ) == NULL ) return 1 ; cur_node = tsk_getu32 ( fs -> endian , hfs -> catalog_header . rootNode ) ; if ( cur_node == 0 ) { if ( tsk_verbose ) tsk_fprintf ( stderr , \"hfs_cat_traverse:<S2SV_blank>\" \"empty<S2SV_blank>extents<S2SV_blank>btree\\\\n\" ) ; free ( node ) ; return 1 ; } if ( tsk_verbose ) tsk_fprintf ( stderr , \"hfs_cat_traverse:<S2SV_blank>starting<S2SV_blank>at<S2SV_blank>\" \"root<S2SV_blank>node<S2SV_blank>%\" PRIu32 \";<S2SV_blank>nodesize<S2SV_blank>=<S2SV_blank>%\" PRIu16 \"\\\\n\" , cur_node , nodesize ) ; is_done = 0 ; while ( is_done == 0 ) { TSK_OFF_T cur_off ; uint16_t num_rec ; ssize_t cnt ; hfs_btree_node * node_desc ; if ( cur_node > tsk_getu32 ( fs -> endian , hfs -> catalog_header . totalNodes ) ) { tsk_error_set_errno ( TSK_ERR_FS_GENFS ) ; tsk_error_set_errstr ( \"hfs_cat_traverse:<S2SV_blank>Node<S2SV_blank>%d<S2SV_blank>too<S2SV_blank>large<S2SV_blank>for<S2SV_blank>file\" , cur_node ) ; free ( node ) ; return 1 ; } cur_off = cur_node * nodesize ; cnt = tsk_fs_attr_read ( hfs -> catalog_attr , cur_off , node , nodesize , 0 ) ; if ( cnt != nodesize ) { if ( cnt >= 0 ) { tsk_error_reset ( ) ; tsk_error_set_errno ( TSK_ERR_FS_READ ) ; } tsk_error_set_errstr2 ( \"hfs_cat_traverse:<S2SV_blank>Error<S2SV_blank>reading<S2SV_blank>node<S2SV_blank>%d<S2SV_blank>at<S2SV_blank>offset<S2SV_blank>%\" PRIuOFF , cur_node , cur_off ) ; free ( node ) ; return 1 ; } if ( nodesize < sizeof ( hfs_btree_node ) ) { tsk_error_set_errno ( TSK_ERR_FS_GENFS ) ; tsk_error_set_errstr ( \"hfs_cat_traverse:<S2SV_blank>Node<S2SV_blank>size<S2SV_blank>%d<S2SV_blank>is<S2SV_blank>too<S2SV_blank>small<S2SV_blank>to<S2SV_blank>be<S2SV_blank>valid\" , nodesize ) ; free ( node ) ; return 1 ; } node_desc = ( hfs_btree_node * ) node ; num_rec = tsk_getu16 ( fs -> endian , node_desc -> num_rec ) ; if ( tsk_verbose ) tsk_fprintf ( stderr , \"hfs_cat_traverse:<S2SV_blank>node<S2SV_blank>%\" PRIu32 \"<S2SV_blank>@<S2SV_blank>%\" PRIu64 \"<S2SV_blank>has<S2SV_blank>%\" PRIu16 \"<S2SV_blank>records\\\\n\" , cur_node , cur_off , num_rec ) ; if ( num_rec == 0 ) { tsk_error_set_errno ( TSK_ERR_FS_GENFS ) ; tsk_error_set_errstr ( \"hfs_cat_traverse:<S2SV_blank>zero<S2SV_blank>records<S2SV_blank>in<S2SV_blank>node<S2SV_blank>%\" PRIu32 , cur_node ) ; free ( node ) ; return 1 ; } if ( node_desc -> type == HFS_BT_NODE_TYPE_IDX ) { uint32_t next_node = 0 ; int rec ; for ( rec = 0 ; rec < num_rec ; ++ rec ) { size_t rec_off ; hfs_btree_key_cat * key ; uint8_t retval ; <S2SV_StartBug> uint16_t keylen ; <S2SV_EndBug> rec_off = tsk_getu16 ( fs -> endian , & node [ nodesize - ( rec + 1 ) * 2 ] ) ; if ( rec_off > nodesize ) { tsk_error_set_errno ( TSK_ERR_FS_GENFS ) ; tsk_error_set_errstr ( \"hfs_cat_traverse:<S2SV_blank>offset<S2SV_blank>of<S2SV_blank>record<S2SV_blank>%d<S2SV_blank>in<S2SV_blank>index<S2SV_blank>node<S2SV_blank>%d<S2SV_blank>too<S2SV_blank>large<S2SV_blank>(%d<S2SV_blank>vs<S2SV_blank>%\" PRIu16 \")\" , rec , cur_node , ( int ) rec_off , nodesize ) ; free ( node ) ; return 1 ; } key = ( hfs_btree_key_cat * ) & node [ rec_off ] ; keylen = 2 + tsk_getu16 ( hfs -> fs_info . endian , key -> key_len ) ; if ( ( keylen ) > nodesize ) { tsk_error_set_errno ( TSK_ERR_FS_GENFS ) ; tsk_error_set_errstr ( \"hfs_cat_traverse:<S2SV_blank>length<S2SV_blank>of<S2SV_blank>key<S2SV_blank>%d<S2SV_blank>in<S2SV_blank>index<S2SV_blank>node<S2SV_blank>%d<S2SV_blank>too<S2SV_blank>large<S2SV_blank>(%d<S2SV_blank>vs<S2SV_blank>%\" PRIu16 \")\" , rec , cur_node , keylen , nodesize ) ; free ( node ) ; return 1 ; } retval = a_cb ( hfs , HFS_BT_NODE_TYPE_IDX , key , cur_off + rec_off , ptr ) ; if ( retval == HFS_BTREE_CB_ERR ) { tsk_error_set_errno ( TSK_ERR_FS_GENFS ) ; tsk_error_set_errstr2 ( \"hfs_cat_traverse:<S2SV_blank>Callback<S2SV_blank>returned<S2SV_blank>error\" ) ; free ( node ) ; return 1 ; } else if ( ( retval == HFS_BTREE_CB_IDX_LT ) || ( next_node == 0 ) ) { hfs_btree_index_record * idx_rec ; int keylen = 2 + hfs_get_idxkeylen ( hfs , tsk_getu16 ( fs -> endian , key -> key_len ) , & ( hfs -> catalog_header ) ) ; if ( rec_off + keylen > nodesize ) { tsk_error_set_errno ( TSK_ERR_FS_GENFS ) ; tsk_error_set_errstr ( \"hfs_cat_traverse:<S2SV_blank>offset<S2SV_blank>of<S2SV_blank>record<S2SV_blank>and<S2SV_blank>keylength<S2SV_blank>%d<S2SV_blank>in<S2SV_blank>index<S2SV_blank>node<S2SV_blank>%d<S2SV_blank>too<S2SV_blank>large<S2SV_blank>(%d<S2SV_blank>vs<S2SV_blank>%\" PRIu16 \")\" , rec , cur_node , ( int ) rec_off + keylen , nodesize ) ; free ( node ) ; return 1 ; } idx_rec = ( hfs_btree_index_record * ) & node [ rec_off + keylen ] ; next_node = tsk_getu32 ( fs -> endian , idx_rec -> childNode ) ; } if ( retval == HFS_BTREE_CB_IDX_EQGT ) { break ; } } if ( next_node == 0 ) { tsk_error_set_errno ( TSK_ERR_FS_GENFS ) ; tsk_error_set_errstr ( \"hfs_cat_traverse:<S2SV_blank>did<S2SV_blank>not<S2SV_blank>find<S2SV_blank>any<S2SV_blank>keys<S2SV_blank>in<S2SV_blank>index<S2SV_blank>node<S2SV_blank>%d\" , cur_node ) ; is_done = 1 ; break ; } if ( next_node == cur_node ) { tsk_error_set_errno ( TSK_ERR_FS_GENFS ) ; tsk_error_set_errstr ( \"hfs_cat_traverse:<S2SV_blank>node<S2SV_blank>%d<S2SV_blank>references<S2SV_blank>itself<S2SV_blank>as<S2SV_blank>next<S2SV_blank>node\" , cur_node ) ; is_done = 1 ; break ; } cur_node = next_node ; } else if ( node_desc -> type == HFS_BT_NODE_TYPE_LEAF ) { int rec ; for ( rec = 0 ; rec < num_rec ; ++ rec ) { size_t rec_off ; hfs_btree_key_cat * key ; uint8_t retval ; <S2SV_StartBug> uint16_t keylen ; <S2SV_EndBug> rec_off = tsk_getu16 ( fs -> endian , & node [ nodesize - ( rec + 1 ) * 2 ] ) ; if ( rec_off > nodesize ) { tsk_error_set_errno ( TSK_ERR_FS_GENFS ) ; tsk_error_set_errstr ( \"hfs_cat_traverse:<S2SV_blank>offset<S2SV_blank>of<S2SV_blank>record<S2SV_blank>%d<S2SV_blank>in<S2SV_blank>leaf<S2SV_blank>node<S2SV_blank>%d<S2SV_blank>too<S2SV_blank>large<S2SV_blank>(%d<S2SV_blank>vs<S2SV_blank>%\" PRIu16 \")\" , rec , cur_node , ( int ) rec_off , nodesize ) ; free ( node ) ; return 1 ; } key = ( hfs_btree_key_cat * ) & node [ rec_off ] ; keylen = 2 + tsk_getu16 ( hfs -> fs_info . endian , key -> key_len ) ; if ( ( keylen ) > nodesize ) { tsk_error_set_errno ( TSK_ERR_FS_GENFS ) ; tsk_error_set_errstr ( \"hfs_cat_traverse:<S2SV_blank>length<S2SV_blank>of<S2SV_blank>key<S2SV_blank>%d<S2SV_blank>in<S2SV_blank>leaf<S2SV_blank>node<S2SV_blank>%d<S2SV_blank>too<S2SV_blank>large<S2SV_blank>(%d<S2SV_blank>vs<S2SV_blank>%\" PRIu16 \")\" , rec , cur_node , keylen , nodesize ) ; free ( node ) ; return 1 ; } retval = a_cb ( hfs , HFS_BT_NODE_TYPE_LEAF , key , cur_off + rec_off , ptr ) ; if ( retval == HFS_BTREE_CB_LEAF_STOP ) { is_done = 1 ; break ; } else if ( retval == HFS_BTREE_CB_ERR ) { tsk_error_set_errno ( TSK_ERR_FS_GENFS ) ; tsk_error_set_errstr2 ( \"hfs_cat_traverse:<S2SV_blank>Callback<S2SV_blank>returned<S2SV_blank>error\" ) ; free ( node ) ; return 1 ; } } if ( is_done == 0 ) { cur_node = tsk_getu32 ( fs -> endian , node_desc -> flink ) ; if ( cur_node == 0 ) { is_done = 1 ; } if ( tsk_verbose ) tsk_fprintf ( stderr , \"hfs_cat_traverse:<S2SV_blank>moving<S2SV_blank>forward<S2SV_blank>to<S2SV_blank>next<S2SV_blank>leaf\" ) ; } } else { tsk_error_set_errno ( TSK_ERR_FS_GENFS ) ; tsk_error_set_errstr ( \"hfs_cat_traverse:<S2SV_blank>btree<S2SV_blank>node<S2SV_blank>%\" PRIu32 \"<S2SV_blank>(%\" PRIu64 \")<S2SV_blank>is<S2SV_blank>neither<S2SV_blank>index<S2SV_blank>nor<S2SV_blank>leaf<S2SV_blank>(%\" PRIu8 \")\" , cur_node , cur_off , node_desc -> type ) ; free ( node ) ; return 1 ; } } free ( node ) ; return 0 ; }\n","target":"<S2SV_ModStart> uint8_t retval ; int <S2SV_ModEnd> keylen ; rec_off <S2SV_ModStart> uint8_t retval ; int <S2SV_ModEnd> keylen ; rec_off\n","project_and_commit_id":"sleuthkit@sleuthkit/114cd3d0aac8bd1aeaf4b33840feb0163d342d5b","cve_id":"CVE-2019-1010065","original_address":"https://github.com/sleuthkit/sleuthkit/commit/114cd3d0aac8bd1aeaf4b33840feb0163d342d5b","time":"2019-07-18T17:15Z"},
	{"Unnamed: 0":546,"cwe_id":"CWE-285","source":"CWE-285 int __gfs2_set_acl ( struct inode * inode , struct posix_acl * acl , int type ) { int error ; int len ; char * data ; const char * name = gfs2_acl_name ( type ) ; if ( acl && acl -> a_count > GFS2_ACL_MAX_ENTRIES ( GFS2_SB ( inode ) ) ) return - E2BIG ; if ( type == ACL_TYPE_ACCESS ) { umode_t mode = inode -> i_mode ; <S2SV_StartBug> error = posix_acl_equiv_mode ( acl , & mode ) ; <S2SV_EndBug> if ( error < 0 ) return error ; if ( error == 0 ) acl = NULL ; <S2SV_StartBug> if ( mode != inode -> i_mode ) { <S2SV_EndBug> inode -> i_mode = mode ; mark_inode_dirty ( inode ) ; <S2SV_StartBug> } <S2SV_EndBug> } if ( acl ) { len = posix_acl_to_xattr ( & init_user_ns , acl , NULL , 0 ) ; if ( len == 0 ) return 0 ; data = kmalloc ( len , GFP_NOFS ) ; if ( data == NULL ) return - ENOMEM ; error = posix_acl_to_xattr ( & init_user_ns , acl , data , len ) ; if ( error < 0 ) goto out ; } else { data = NULL ; len = 0 ; } error = __gfs2_xattr_set ( inode , name , data , len , 0 , GFS2_EATYPE_SYS ) ; if ( error ) goto out ; set_cached_acl ( inode , type , acl ) ; out : kfree ( data ) ; return error ; }\n","target":"<S2SV_ModStart> ; error = posix_acl_update_mode ( inode , & inode -> i_mode , & acl ) ; if ( error ) return error <S2SV_ModEnd> ; if ( <S2SV_ModStart> -> i_mode ) <S2SV_ModEnd> mark_inode_dirty ( inode <S2SV_ModStart> inode ) ; <S2SV_ModEnd> } if (\n","project_and_commit_id":"torvalds@linux/073931017b49d9458aa351605b43a7e34598caef","cve_id":"CVE-2016-7097","original_address":"https://github.com/torvalds/linux/commit/073931017b49d9458aa351605b43a7e34598caef","time":"2016-10-16T21:59Z"},
	{"Unnamed: 0":3776,"cwe_id":"CWE-200","source":"CWE-200 int btrfs_truncate_inode_items ( struct btrfs_trans_handle * trans , struct btrfs_root * root , struct inode * inode , u64 new_size , u32 min_type ) { struct btrfs_path * path ; struct extent_buffer * leaf ; struct btrfs_file_extent_item * fi ; struct btrfs_key key ; struct btrfs_key found_key ; u64 extent_start = 0 ; u64 extent_num_bytes = 0 ; u64 extent_offset = 0 ; u64 item_end = 0 ; u64 last_size = new_size ; u32 found_type = ( u8 ) - 1 ; int found_extent ; int del_item ; int pending_del_nr = 0 ; int pending_del_slot = 0 ; int extent_type = - 1 ; int ret ; int err = 0 ; u64 ino = btrfs_ino ( inode ) ; u64 bytes_deleted = 0 ; bool be_nice = 0 ; bool should_throttle = 0 ; bool should_end = 0 ; BUG_ON ( new_size > 0 && min_type != BTRFS_EXTENT_DATA_KEY ) ; if ( ! btrfs_is_free_space_inode ( inode ) && test_bit ( BTRFS_ROOT_REF_COWS , & root -> state ) ) be_nice = 1 ; path = btrfs_alloc_path ( ) ; if ( ! path ) return - ENOMEM ; path -> reada = - 1 ; if ( test_bit ( BTRFS_ROOT_REF_COWS , & root -> state ) || root == root -> fs_info -> tree_root ) btrfs_drop_extent_cache ( inode , ALIGN ( new_size , root -> sectorsize ) , ( u64 ) - 1 , 0 ) ; if ( min_type == 0 && root == BTRFS_I ( inode ) -> root ) btrfs_kill_delayed_inode_items ( inode ) ; key . objectid = ino ; key . offset = ( u64 ) - 1 ; key . type = ( u8 ) - 1 ; search_again : if ( be_nice && bytes_deleted > 32 * 1024 * 1024 ) { if ( btrfs_should_end_transaction ( trans , root ) ) { err = - EAGAIN ; goto error ; } } path -> leave_spinning = 1 ; ret = btrfs_search_slot ( trans , root , & key , path , - 1 , 1 ) ; if ( ret < 0 ) { err = ret ; goto out ; } if ( ret > 0 ) { if ( path -> slots [ 0 ] == 0 ) goto out ; path -> slots [ 0 ] -- ; } while ( 1 ) { fi = NULL ; leaf = path -> nodes [ 0 ] ; btrfs_item_key_to_cpu ( leaf , & found_key , path -> slots [ 0 ] ) ; found_type = found_key . type ; if ( found_key . objectid != ino ) break ; if ( found_type < min_type ) break ; item_end = found_key . offset ; if ( found_type == BTRFS_EXTENT_DATA_KEY ) { fi = btrfs_item_ptr ( leaf , path -> slots [ 0 ] , struct btrfs_file_extent_item ) ; extent_type = btrfs_file_extent_type ( leaf , fi ) ; if ( extent_type != BTRFS_FILE_EXTENT_INLINE ) { item_end += btrfs_file_extent_num_bytes ( leaf , fi ) ; } else if ( extent_type == BTRFS_FILE_EXTENT_INLINE ) { item_end += btrfs_file_extent_inline_len ( leaf , path -> slots [ 0 ] , fi ) ; } item_end -- ; } if ( found_type > min_type ) { del_item = 1 ; } else { if ( item_end < new_size ) break ; if ( found_key . offset >= new_size ) del_item = 1 ; else del_item = 0 ; } found_extent = 0 ; if ( found_type != BTRFS_EXTENT_DATA_KEY ) goto delete ; if ( del_item ) last_size = found_key . offset ; else last_size = new_size ; if ( extent_type != BTRFS_FILE_EXTENT_INLINE ) { u64 num_dec ; extent_start = btrfs_file_extent_disk_bytenr ( leaf , fi ) ; if ( ! del_item ) { u64 orig_num_bytes = btrfs_file_extent_num_bytes ( leaf , fi ) ; extent_num_bytes = ALIGN ( new_size - found_key . offset , root -> sectorsize ) ; btrfs_set_file_extent_num_bytes ( leaf , fi , extent_num_bytes ) ; num_dec = ( orig_num_bytes - extent_num_bytes ) ; if ( test_bit ( BTRFS_ROOT_REF_COWS , & root -> state ) && extent_start != 0 ) inode_sub_bytes ( inode , num_dec ) ; btrfs_mark_buffer_dirty ( leaf ) ; } else { extent_num_bytes = btrfs_file_extent_disk_num_bytes ( leaf , fi ) ; extent_offset = found_key . offset - btrfs_file_extent_offset ( leaf , fi ) ; num_dec = btrfs_file_extent_num_bytes ( leaf , fi ) ; if ( extent_start != 0 ) { found_extent = 1 ; if ( test_bit ( BTRFS_ROOT_REF_COWS , & root -> state ) ) inode_sub_bytes ( inode , num_dec ) ; } } } else if ( extent_type == BTRFS_FILE_EXTENT_INLINE ) { if ( ! del_item && <S2SV_StartBug> btrfs_file_extent_compression ( leaf , fi ) == 0 && <S2SV_EndBug> btrfs_file_extent_encryption ( leaf , fi ) == 0 && btrfs_file_extent_other_encoding ( leaf , fi ) == 0 ) { u32 size = new_size - found_key . offset ; <S2SV_StartBug> if ( test_bit ( BTRFS_ROOT_REF_COWS , & root -> state ) ) <S2SV_EndBug> inode_sub_bytes ( inode , item_end + 1 - <S2SV_StartBug> new_size ) ; <S2SV_EndBug> btrfs_set_file_extent_ram_bytes ( leaf , fi , size ) ; size = btrfs_file_extent_calc_inline_size ( size ) ; btrfs_truncate_item ( root , path , size , 1 ) ; } else if ( test_bit ( BTRFS_ROOT_REF_COWS , & root -> state ) ) { inode_sub_bytes ( inode , item_end + 1 - found_key . offset ) ; } } delete : if ( del_item ) { if ( ! pending_del_nr ) { pending_del_slot = path -> slots [ 0 ] ; pending_del_nr = 1 ; } else if ( pending_del_nr && path -> slots [ 0 ] + 1 == pending_del_slot ) { pending_del_nr ++ ; pending_del_slot = path -> slots [ 0 ] ; } else { BUG ( ) ; } } else { break ; } should_throttle = 0 ; if ( found_extent && ( test_bit ( BTRFS_ROOT_REF_COWS , & root -> state ) || root == root -> fs_info -> tree_root ) ) { btrfs_set_path_blocking ( path ) ; bytes_deleted += extent_num_bytes ; ret = btrfs_free_extent ( trans , root , extent_start , extent_num_bytes , 0 , btrfs_header_owner ( leaf ) , ino , extent_offset , 0 ) ; BUG_ON ( ret ) ; if ( btrfs_should_throttle_delayed_refs ( trans , root ) ) btrfs_async_run_delayed_refs ( root , trans -> delayed_ref_updates * 2 , 0 ) ; if ( be_nice ) { if ( truncate_space_check ( trans , root , extent_num_bytes ) ) { should_end = 1 ; } if ( btrfs_should_throttle_delayed_refs ( trans , root ) ) { should_throttle = 1 ; } } } if ( found_type == BTRFS_INODE_ITEM_KEY ) break ; if ( path -> slots [ 0 ] == 0 || path -> slots [ 0 ] != pending_del_slot || should_throttle || should_end ) { if ( pending_del_nr ) { ret = btrfs_del_items ( trans , root , path , pending_del_slot , pending_del_nr ) ; if ( ret ) { btrfs_abort_transaction ( trans , root , ret ) ; goto error ; } pending_del_nr = 0 ; } btrfs_release_path ( path ) ; if ( should_throttle ) { unsigned long updates = trans -> delayed_ref_updates ; if ( updates ) { trans -> delayed_ref_updates = 0 ; ret = btrfs_run_delayed_refs ( trans , root , updates * 2 ) ; if ( ret && ! err ) err = ret ; } } if ( should_end ) { err = - EAGAIN ; goto error ; } goto search_again ; } else { path -> slots [ 0 ] -- ; } } out : if ( pending_del_nr ) { ret = btrfs_del_items ( trans , root , path , pending_del_slot , pending_del_nr ) ; if ( ret ) btrfs_abort_transaction ( trans , root , ret ) ; } error : if ( root -> root_key . objectid != BTRFS_TREE_LOG_OBJECTID ) btrfs_ordered_update_i_size ( inode , last_size , NULL ) ; btrfs_free_path ( path ) ; if ( be_nice && bytes_deleted > 32 * 1024 * 1024 ) { unsigned long updates = trans -> delayed_ref_updates ; if ( updates ) { trans -> delayed_ref_updates = 0 ; ret = btrfs_run_delayed_refs ( trans , root , updates * 2 ) ; if ( ret && ! err ) err = ret ; } } return err ; }\n","target":"<S2SV_ModStart> ! del_item && btrfs_file_extent_encryption ( leaf , fi ) == 0 && btrfs_file_extent_other_encoding ( leaf , fi ) == 0 ) { if ( <S2SV_ModStart> , fi ) != BTRFS_COMPRESS_NONE && pending_del_nr ) { err = btrfs_del_items ( trans , root , path , pending_del_slot , pending_del_nr ) ; if ( err ) { btrfs_abort_transaction ( trans , root , err ) ; goto error ; } pending_del_nr = 0 ; } err = truncate_inline_extent ( inode , path , & found_key , item_end , new_size ) ; if ( err ) { btrfs_abort_transaction ( trans , root , err ) ; goto error ; } } else <S2SV_ModEnd> if ( test_bit <S2SV_ModStart> state ) ) { <S2SV_ModStart> 1 - new_size <S2SV_ModEnd> ) ; }\n","project_and_commit_id":"torvalds@linux/0305cd5f7fca85dae392b9ba85b116896eb7c1c7","cve_id":"CVE-2015-8374","original_address":"https://github.com/torvalds/linux/commit/0305cd5f7fca85dae392b9ba85b116896eb7c1c7","time":"2015-12-28T11:59Z"},
	{"Unnamed: 0":1121,"cwe_id":"CWE-125","source":"CWE-125 u_int atm_if_print ( netdissect_options * ndo , const struct pcap_pkthdr * h , const u_char * p ) { u_int caplen = h -> caplen ; u_int length = h -> len ; uint32_t llchdr ; u_int hdrlen = 0 ; if ( caplen < 1 || length < 1 ) { ND_PRINT ( ( ndo , \"%s\" , tstr ) ) ; return ( caplen ) ; } if ( * p == LLC_UI ) { if ( ndo -> ndo_eflag ) ND_PRINT ( ( ndo , \"CNLPID<S2SV_blank>\" ) ) ; <S2SV_StartBug> isoclns_print ( ndo , p + 1 , length - 1 , caplen - 1 ) ; <S2SV_EndBug> return hdrlen ; } if ( caplen < 3 || length < 3 ) { ND_PRINT ( ( ndo , \"%s\" , tstr ) ) ; return ( caplen ) ; } llchdr = EXTRACT_24BITS ( p ) ; if ( llchdr != LLC_UI_HDR ( LLCSAP_SNAP ) && llchdr != LLC_UI_HDR ( LLCSAP_ISONS ) && llchdr != LLC_UI_HDR ( LLCSAP_IP ) ) { if ( caplen < 20 || length < 20 ) { ND_PRINT ( ( ndo , \"%s\" , tstr ) ) ; return ( caplen ) ; } if ( ndo -> ndo_eflag ) ND_PRINT ( ( ndo , \"%08x%08x<S2SV_blank>%08x%08x<S2SV_blank>\" , EXTRACT_32BITS ( p ) , EXTRACT_32BITS ( p + 4 ) , EXTRACT_32BITS ( p + 8 ) , EXTRACT_32BITS ( p + 12 ) ) ) ; p += 20 ; length -= 20 ; caplen -= 20 ; hdrlen += 20 ; } hdrlen += atm_llc_print ( ndo , p , length , caplen ) ; return ( hdrlen ) ; }\n","target":"<S2SV_ModStart> length - 1 <S2SV_ModEnd> ) ; return\n","project_and_commit_id":"the-tcpdump-group@tcpdump/1dcd10aceabbc03bf571ea32b892c522cbe923de","cve_id":"CVE-2017-12897","original_address":"https://github.com/the-tcpdump-group/tcpdump/commit/1dcd10aceabbc03bf571ea32b892c522cbe923de","time":"2017-09-14T06:29Z"},
	{"Unnamed: 0":6463,"cwe_id":"CWE-119","source":"CWE-119 <S2SV_StartBug> static void <S2SV_EndBug> horAcc16 ( TIFF * tif , uint8 * cp0 , tmsize_t cc ) { tmsize_t stride = PredictorState ( tif ) -> stride ; uint16 * wp = ( uint16 * ) cp0 ; tmsize_t wc = cc / 2 ; <S2SV_StartBug> assert ( ( cc % ( 2 * stride ) ) == 0 ) ; <S2SV_EndBug> if ( wc > stride ) { wc -= stride ; do { REPEAT4 ( stride , wp [ stride ] = ( uint16 ) ( ( ( unsigned int ) wp [ stride ] + ( unsigned int ) wp [ 0 ] ) & 0xffff ) ; wp ++ ) wc -= stride ; } while ( wc > 0 ) ; } <S2SV_StartBug> } <S2SV_EndBug>\n","target":"<S2SV_ModStart> <S2SV_null> <S2SV_null> static int <S2SV_ModEnd> horAcc16 ( TIFF <S2SV_ModStart> / 2 ; if <S2SV_ModEnd> ( ( cc <S2SV_ModStart> stride ) ) != 0 ) { TIFFErrorExt ( tif -> tif_clientdata , \"horAcc16\" , \"%s\" , \"cc%(2*stride))!=0\" ) ; return 0 ; } <S2SV_ModEnd> if ( wc <S2SV_ModStart> ) ; } return 1 ;\n","project_and_commit_id":"vadz@libtiff/3ca657a8793dd011bf869695d72ad31c779c3cc1","cve_id":"CVE-2016-9535","original_address":"https://github.com/vadz/libtiff/commit/3ca657a8793dd011bf869695d72ad31c779c3cc1","time":"2016-11-22T19:59Z"},
	{"Unnamed: 0":6434,"cwe_id":"CWE-269","source":"CWE-269 void inode_init_owner ( struct inode * inode , const struct inode * dir , umode_t mode ) { inode -> i_uid = current_fsuid ( ) ; if ( dir && dir -> i_mode & S_ISGID ) { inode -> i_gid = dir -> i_gid ; if ( S_ISDIR ( mode ) ) mode |= S_ISGID ; <S2SV_StartBug> } else <S2SV_EndBug> inode -> i_gid = current_fsgid ( ) ; inode -> i_mode = mode ; }\n","target":"<S2SV_ModStart> |= S_ISGID ; else if ( ( mode & ( S_ISGID | S_IXGRP ) ) == ( S_ISGID | S_IXGRP ) && ! in_group_p ( inode -> i_gid ) && ! capable_wrt_inode_uidgid ( dir , CAP_FSETID ) ) mode &= ~ S_ISGID ;\n","project_and_commit_id":"torvalds@linux/0fa3ecd87848c9c93c2c828ef4c3a8ca36ce46c7","cve_id":"CVE-2018-13405","original_address":"https://github.com/torvalds/linux/commit/0fa3ecd87848c9c93c2c828ef4c3a8ca36ce46c7","time":"2018-07-06T14:29Z"},
	{"Unnamed: 0":4037,"cwe_id":"CWE-125","source":"CWE-125 int rt6_print ( netdissect_options * ndo , register const u_char * bp , const u_char * bp2 _U_ ) { register const struct ip6_rthdr * dp ; register const struct ip6_rthdr0 * dp0 ; register const u_char * ep ; int i , len ; register const struct in6_addr * addr ; dp = ( const struct ip6_rthdr * ) bp ; <S2SV_StartBug> len = dp -> ip6r_len ; <S2SV_EndBug> ep = ndo -> ndo_snapend ; ND_TCHECK ( dp -> ip6r_segleft ) ; ND_PRINT ( ( ndo , \"srcrt<S2SV_blank>(len=%d\" , dp -> ip6r_len ) ) ; ND_PRINT ( ( ndo , \",<S2SV_blank>type=%d\" , dp -> ip6r_type ) ) ; ND_PRINT ( ( ndo , \",<S2SV_blank>segleft=%d\" , dp -> ip6r_segleft ) ) ; switch ( dp -> ip6r_type ) { case IPV6_RTHDR_TYPE_0 : case IPV6_RTHDR_TYPE_2 : dp0 = ( const struct ip6_rthdr0 * ) dp ; ND_TCHECK ( dp0 -> ip6r0_reserved ) ; if ( dp0 -> ip6r0_reserved || ndo -> ndo_vflag ) { ND_PRINT ( ( ndo , \",<S2SV_blank>rsv=0x%0x\" , EXTRACT_32BITS ( & dp0 -> ip6r0_reserved ) ) ) ; } if ( len % 2 == 1 ) goto trunc ; len >>= 1 ; addr = & dp0 -> ip6r0_addr [ 0 ] ; for ( i = 0 ; i < len ; i ++ ) { if ( ( const u_char * ) ( addr + 1 ) > ep ) goto trunc ; ND_PRINT ( ( ndo , \",<S2SV_blank>[%d]%s\" , i , ip6addr_string ( ndo , addr ) ) ) ; addr ++ ; } ND_PRINT ( ( ndo , \")<S2SV_blank>\" ) ) ; return ( ( dp0 -> ip6r0_len + 1 ) << 3 ) ; break ; default : goto trunc ; break ; } trunc : ND_PRINT ( ( ndo , \"[|srcrt]\" ) ) ; return - 1 ; }\n","target":"<S2SV_ModStart> ) bp ; ep = ndo -> ndo_snapend ; ND_TCHECK ( dp -> ip6r_segleft ) ; <S2SV_ModStart> dp -> ip6r_len <S2SV_ModEnd> ; ND_PRINT (\n","project_and_commit_id":"the-tcpdump-group@tcpdump/3c4d7c0ee30a30e5abff3d6d9586a3753101faf5","cve_id":"CVE-2017-13725","original_address":"https://github.com/the-tcpdump-group/tcpdump/commit/3c4d7c0ee30a30e5abff3d6d9586a3753101faf5","time":"2017-09-14T06:29Z"},
	{"Unnamed: 0":6749,"cwe_id":"CWE-119","source":"CWE-119 <S2SV_StartBug> void vp9_encode_mv ( VP9_COMP * cpi , vp9_writer * w , <S2SV_EndBug> const MV * mv , const MV * ref , const nmv_context * mvctx , int usehp ) { const MV diff = { mv -> row - ref -> row , mv -> col - ref -> col } ; const MV_JOINT_TYPE j = vp9_get_mv_joint ( & diff ) ; usehp = usehp && vp9_use_mv_hp ( ref ) ; vp9_write_token ( w , vp9_mv_joint_tree , mvctx -> joints , & mv_joint_encodings [ j ] ) ; if ( mv_joint_vertical ( j ) ) encode_mv_component ( w , diff . row , & mvctx -> comps [ 0 ] , usehp ) ; if ( mv_joint_horizontal ( j ) ) encode_mv_component ( w , diff . col , & mvctx -> comps [ 1 ] , usehp ) ; <S2SV_StartBug> if ( ! cpi -> dummy_packing && cpi -> sf . auto_mv_step_size ) { <S2SV_EndBug> unsigned int maxv = MAX ( abs ( mv -> row ) , abs ( mv -> col ) ) >> 3 ; cpi -> max_mv_magnitude = MAX ( maxv , cpi -> max_mv_magnitude ) ; } }\n","target":"<S2SV_ModStart> * cpi , vpx_writer <S2SV_ModEnd> * w , <S2SV_ModStart> ; if ( <S2SV_ModEnd> cpi -> sf <S2SV_ModStart> cpi -> sf . mv\n","project_and_commit_id":"external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426","cve_id":"CVE-2016-1621","original_address":"https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426","time":"2016-03-12T21:59Z"},
	{"Unnamed: 0":5431,"cwe_id":"CWE-119","source":"CWE-119 static gboolean parse_cosine_packet ( FILE_T fh , struct wtap_pkthdr * phdr , Buffer * buf , char * line , int * err , gchar * * err_info ) { union wtap_pseudo_header * pseudo_header = & phdr -> pseudo_header ; int num_items_scanned ; <S2SV_StartBug> int yy , mm , dd , hr , min , sec , csec ; <S2SV_EndBug> guint pkt_len ; int pro , off , pri , rm , error ; guint code1 , code2 ; char if_name [ COSINE_MAX_IF_NAME_LEN ] = \"\" , direction [ 6 ] = \"\" ; struct tm tm ; guint8 * pd ; int i , hex_lines , n , caplen = 0 ; if ( sscanf ( line , \"%4d-%2d-%2d,%2d:%2d:%2d.%9d:\" , & yy , & mm , & dd , & hr , & min , & sec , & csec ) == 7 ) { num_items_scanned = sscanf ( line , <S2SV_StartBug> \"%4d-%2d-%2d,%2d:%2d:%2d.%9d:<S2SV_blank>%5s<S2SV_blank>(%127[A-Za-z0-9/:]),<S2SV_blank>Length:%9u,<S2SV_blank>Pro:%9d,<S2SV_blank>Off:%9d,<S2SV_blank>Pri:%9d,<S2SV_blank>RM:%9d,<S2SV_blank>Err:%9d<S2SV_blank>[%8x,<S2SV_blank>%8x]\" , <S2SV_EndBug> & yy , & mm , & dd , & hr , & min , & sec , & csec , direction , if_name , & pkt_len , & pro , & off , & pri , & rm , & error , & code1 , & code2 ) ; if ( num_items_scanned != 17 ) { * err = WTAP_ERR_BAD_FILE ; * err_info = g_strdup ( \"cosine:<S2SV_blank>purported<S2SV_blank>control<S2SV_blank>blade<S2SV_blank>line<S2SV_blank>doesn\\'t<S2SV_blank>have<S2SV_blank>code<S2SV_blank>values\" ) ; return FALSE ; } } else { num_items_scanned = sscanf ( line , <S2SV_StartBug> \"%5s<S2SV_blank>(%127[A-Za-z0-9/:]),<S2SV_blank>Length:%9u,<S2SV_blank>Pro:%9d,<S2SV_blank>Off:%9d,<S2SV_blank>Pri:%9d,<S2SV_blank>RM:%9d,<S2SV_blank>Err:%9d<S2SV_blank>[%8x,<S2SV_blank>%8x]\" , <S2SV_EndBug> direction , if_name , & pkt_len , & pro , & off , & pri , & rm , & error , & code1 , & code2 ) ; if ( num_items_scanned != 10 ) { * err = WTAP_ERR_BAD_FILE ; * err_info = g_strdup ( \"cosine:<S2SV_blank>header<S2SV_blank>line<S2SV_blank>is<S2SV_blank>neither<S2SV_blank>control<S2SV_blank>blade<S2SV_blank>nor<S2SV_blank>PE<S2SV_blank>output\" ) ; return FALSE ; } <S2SV_StartBug> yy = mm = dd = hr = min = sec = csec = 0 ; <S2SV_EndBug> } if ( pkt_len > WTAP_MAX_PACKET_SIZE ) { * err = WTAP_ERR_BAD_FILE ; * err_info = g_strdup_printf ( \"cosine:<S2SV_blank>File<S2SV_blank>has<S2SV_blank>%u-byte<S2SV_blank>packet,<S2SV_blank>bigger<S2SV_blank>than<S2SV_blank>maximum<S2SV_blank>of<S2SV_blank>%u\" , pkt_len , WTAP_MAX_PACKET_SIZE ) ; return FALSE ; } phdr -> rec_type = REC_TYPE_PACKET ; phdr -> presence_flags = WTAP_HAS_TS | WTAP_HAS_CAP_LEN ; tm . tm_year = yy - 1900 ; tm . tm_mon = mm - 1 ; tm . tm_mday = dd ; tm . tm_hour = hr ; tm . tm_min = min ; tm . tm_sec = sec ; tm . tm_isdst = - 1 ; phdr -> ts . secs = mktime ( & tm ) ; phdr -> ts . nsecs = csec * 10000000 ; phdr -> len = pkt_len ; if ( strncmp ( if_name , \"TEST:\" , 5 ) == 0 ) { pseudo_header -> cosine . encap = COSINE_ENCAP_TEST ; } else if ( strncmp ( if_name , \"PPoATM:\" , 7 ) == 0 ) { pseudo_header -> cosine . encap = COSINE_ENCAP_PPoATM ; } else if ( strncmp ( if_name , \"PPoFR:\" , 6 ) == 0 ) { pseudo_header -> cosine . encap = COSINE_ENCAP_PPoFR ; } else if ( strncmp ( if_name , \"ATM:\" , 4 ) == 0 ) { pseudo_header -> cosine . encap = COSINE_ENCAP_ATM ; } else if ( strncmp ( if_name , \"FR:\" , 3 ) == 0 ) { pseudo_header -> cosine . encap = COSINE_ENCAP_FR ; } else if ( strncmp ( if_name , \"HDLC:\" , 5 ) == 0 ) { pseudo_header -> cosine . encap = COSINE_ENCAP_HDLC ; } else if ( strncmp ( if_name , \"PPP:\" , 4 ) == 0 ) { pseudo_header -> cosine . encap = COSINE_ENCAP_PPP ; } else if ( strncmp ( if_name , \"ETH:\" , 4 ) == 0 ) { pseudo_header -> cosine . encap = COSINE_ENCAP_ETH ; } else { pseudo_header -> cosine . encap = COSINE_ENCAP_UNKNOWN ; } if ( strncmp ( direction , \"l2-tx\" , 5 ) == 0 ) { pseudo_header -> cosine . direction = COSINE_DIR_TX ; } else if ( strncmp ( direction , \"l2-rx\" , 5 ) == 0 ) { pseudo_header -> cosine . direction = COSINE_DIR_RX ; } g_strlcpy ( pseudo_header -> cosine . if_name , if_name , COSINE_MAX_IF_NAME_LEN ) ; pseudo_header -> cosine . pro = pro ; pseudo_header -> cosine . off = off ; pseudo_header -> cosine . pri = pri ; pseudo_header -> cosine . rm = rm ; pseudo_header -> cosine . err = error ; ws_buffer_assure_space ( buf , pkt_len ) ; pd = ws_buffer_start_ptr ( buf ) ; hex_lines = pkt_len / 16 + ( ( pkt_len % 16 ) ? 1 : 0 ) ; for ( i = 0 ; i < hex_lines ; i ++ ) { if ( file_gets ( line , COSINE_LINE_LENGTH , fh ) == NULL ) { * err = file_error ( fh , err_info ) ; if ( * err == 0 ) { * err = WTAP_ERR_SHORT_READ ; } return FALSE ; } if ( empty_line ( line ) ) { break ; } if ( ( n = parse_single_hex_dump_line ( line , pd , i * 16 ) ) == - 1 ) { * err = WTAP_ERR_BAD_FILE ; * err_info = g_strdup ( \"cosine:<S2SV_blank>hex<S2SV_blank>dump<S2SV_blank>line<S2SV_blank>doesn\\'t<S2SV_blank>have<S2SV_blank>16<S2SV_blank>numbers\" ) ; return FALSE ; } caplen += n ; } phdr -> caplen = caplen ; return TRUE ; }\n","target":"<S2SV_ModStart> sec , csec , <S2SV_ModEnd> pkt_len ; int <S2SV_ModStart> ( line , \"%4d-%2d-%2d,%2d:%2d:%2d.%9d:<S2SV_blank>%5s<S2SV_blank>(%127[A-Za-z0-9/:]),<S2SV_blank>Length:%9d,<S2SV_blank>Pro:%9d,<S2SV_blank>Off:%9d,<S2SV_blank>Pri:%9d,<S2SV_blank>RM:%9d,<S2SV_blank>Err:%9d<S2SV_blank>[%8x,<S2SV_blank>%8x]\" <S2SV_ModEnd> , & yy <S2SV_ModStart> ( line , \"%5s<S2SV_blank>(%127[A-Za-z0-9/:]),<S2SV_blank>Length:%9d,<S2SV_blank>Pro:%9d,<S2SV_blank>Off:%9d,<S2SV_blank>Pri:%9d,<S2SV_blank>RM:%9d,<S2SV_blank>Err:%9d<S2SV_blank>[%8x,<S2SV_blank>%8x]\" <S2SV_ModEnd> , direction , <S2SV_ModStart> csec = 0 ; } if ( pkt_len < 0 ) { * err = WTAP_ERR_BAD_FILE ; * err_info = g_strdup ( \"cosine:<S2SV_blank>packet<S2SV_blank>header<S2SV_blank>has<S2SV_blank>a<S2SV_blank>negative<S2SV_blank>packet<S2SV_blank>length\" ) ; return FALSE\n","project_and_commit_id":"wireshark@wireshark/a66628e425db725df1ac52a3c573a03357060ddd","cve_id":"CVE-2016-5356","original_address":"https://github.com/wireshark/wireshark/commit/a66628e425db725df1ac52a3c573a03357060ddd","time":"2016-08-07T16:59Z"},
	{"Unnamed: 0":1120,"cwe_id":"CWE-119","source":"CWE-119 l_int32 gplotAddPlot ( GPLOT * gplot , NUMA * nax , NUMA * nay , l_int32 plotstyle , const char * plottitle ) { <S2SV_StartBug> char buf [ L_BUF_SIZE ] ; <S2SV_EndBug> char emptystring [ ] = \"\" ; char * datastr , * title ; l_int32 n , i ; l_float32 valx , valy , startx , delx ; SARRAY * sa ; PROCNAME ( \"gplotAddPlot\" ) ; if ( ! gplot ) return ERROR_INT ( \"gplot<S2SV_blank>not<S2SV_blank>defined\" , procName , 1 ) ; if ( ! nay ) return ERROR_INT ( \"nay<S2SV_blank>not<S2SV_blank>defined\" , procName , 1 ) ; if ( plotstyle < 0 || plotstyle >= NUM_GPLOT_STYLES ) return ERROR_INT ( \"invalid<S2SV_blank>plotstyle\" , procName , 1 ) ; if ( ( n = numaGetCount ( nay ) ) == 0 ) return ERROR_INT ( \"no<S2SV_blank>points<S2SV_blank>to<S2SV_blank>plot\" , procName , 1 ) ; if ( nax && ( n != numaGetCount ( nax ) ) ) return ERROR_INT ( \"nax<S2SV_blank>and<S2SV_blank>nay<S2SV_blank>sizes<S2SV_blank>differ\" , procName , 1 ) ; if ( n == 1 && plotstyle == GPLOT_LINES ) { L_INFO ( \"only<S2SV_blank>1<S2SV_blank>pt;<S2SV_blank>changing<S2SV_blank>style<S2SV_blank>to<S2SV_blank>points\\\\n\" , procName ) ; plotstyle = GPLOT_POINTS ; } numaGetParameters ( nay , & startx , & delx ) ; numaAddNumber ( gplot -> plotstyles , plotstyle ) ; if ( plottitle ) { title = stringNew ( plottitle ) ; sarrayAddString ( gplot -> plottitles , title , L_INSERT ) ; } else { sarrayAddString ( gplot -> plottitles , emptystring , L_COPY ) ; } gplot -> nplots ++ ; <S2SV_StartBug> snprintf ( buf , L_BUF_SIZE , \"%s.data.%d\" , gplot -> rootname , gplot -> nplots ) ; <S2SV_EndBug> sarrayAddString ( gplot -> datanames , buf , L_COPY ) ; sa = sarrayCreate ( n ) ; for ( i = 0 ; i < n ; i ++ ) { if ( nax ) numaGetFValue ( nax , i , & valx ) ; else valx = startx + i * delx ; numaGetFValue ( nay , i , & valy ) ; <S2SV_StartBug> snprintf ( buf , L_BUF_SIZE , \"%f<S2SV_blank>%f\\\\n\" , valx , valy ) ; <S2SV_EndBug> sarrayAddString ( sa , buf , L_COPY ) ; } datastr = sarrayToString ( sa , 0 ) ; sarrayAddString ( gplot -> plotdata , datastr , L_INSERT ) ; sarrayDestroy ( & sa ) ; return 0 ; }\n","target":"<S2SV_ModStart> char buf [ L_BUFSIZE <S2SV_ModEnd> ] ; char <S2SV_ModStart> ( buf , L_BUFSIZE <S2SV_ModEnd> , \"%s.data.%d\" , <S2SV_ModStart> ( buf , L_BUFSIZE <S2SV_ModEnd> , \"%f<S2SV_blank>%f\\\\n\" ,\n","project_and_commit_id":"DanBloomberg@leptonica/ee301cb2029db8a6289c5295daa42bba7715e99a","cve_id":"CVE-2018-7186","original_address":"https://github.com/DanBloomberg/leptonica/commit/ee301cb2029db8a6289c5295daa42bba7715e99a","time":"2018-02-16T16:29Z"},
	{"Unnamed: 0":2473,"cwe_id":"CWE-119","source":"CWE-119 static int cqspi_setup_flash ( struct cqspi_st * cqspi , struct device_node * np ) { struct platform_device * pdev = cqspi -> pdev ; struct device * dev = & pdev -> dev ; struct cqspi_flash_pdata * f_pdata ; struct spi_nor * nor ; struct mtd_info * mtd ; unsigned int cs ; int i , ret ; for_each_available_child_of_node ( dev -> of_node , np ) { if ( of_property_read_u32 ( np , \"reg\" , & cs ) ) { dev_err ( dev , \"Couldn\\'t<S2SV_blank>determine<S2SV_blank>chip<S2SV_blank>select.\\\\n\" ) ; goto err ; } <S2SV_StartBug> if ( cs > CQSPI_MAX_CHIPSELECT ) { <S2SV_EndBug> dev_err ( dev , \"Chip<S2SV_blank>select<S2SV_blank>%d<S2SV_blank>out<S2SV_blank>of<S2SV_blank>range.\\\\n\" , cs ) ; goto err ; } f_pdata = & cqspi -> f_pdata [ cs ] ; f_pdata -> cqspi = cqspi ; f_pdata -> cs = cs ; ret = cqspi_of_get_flash_pdata ( pdev , f_pdata , np ) ; if ( ret ) goto err ; nor = & f_pdata -> nor ; mtd = & nor -> mtd ; mtd -> priv = nor ; nor -> dev = dev ; spi_nor_set_flash_node ( nor , np ) ; nor -> priv = f_pdata ; nor -> read_reg = cqspi_read_reg ; nor -> write_reg = cqspi_write_reg ; nor -> read = cqspi_read ; nor -> write = cqspi_write ; nor -> erase = cqspi_erase ; nor -> prepare = cqspi_prep ; nor -> unprepare = cqspi_unprep ; mtd -> name = devm_kasprintf ( dev , GFP_KERNEL , \"%s.%d\" , dev_name ( dev ) , cs ) ; if ( ! mtd -> name ) { ret = - ENOMEM ; goto err ; } ret = spi_nor_scan ( nor , NULL , SPI_NOR_QUAD ) ; if ( ret ) goto err ; ret = mtd_device_register ( mtd , NULL , 0 ) ; if ( ret ) goto err ; f_pdata -> registered = true ; } return 0 ; err : for ( i = 0 ; i < CQSPI_MAX_CHIPSELECT ; i ++ ) if ( cqspi -> f_pdata [ i ] . registered ) mtd_device_unregister ( & cqspi -> f_pdata [ i ] . nor . mtd ) ; return ret ; }\n","target":"<S2SV_ModStart> if ( cs >= <S2SV_ModEnd> CQSPI_MAX_CHIPSELECT ) {\n","project_and_commit_id":"torvalds@linux/193e87143c290ec16838f5368adc0e0bc94eb931","cve_id":"CVE-2016-10764","original_address":"https://github.com/torvalds/linux/commit/193e87143c290ec16838f5368adc0e0bc94eb931","time":"2019-07-27T22:15Z"},
	{"Unnamed: 0":2056,"cwe_id":"CWE-20","source":"CWE-20 int dns_packet_is_reply_for ( DnsPacket * p , const DnsResourceKey * key ) { int r ; assert ( p ) ; assert ( key ) ; if ( DNS_PACKET_QR ( p ) != 1 ) return 0 ; r = dns_packet_extract ( p ) ; if ( r < 0 ) return r ; <S2SV_StartBug> if ( p -> question -> n_keys != 1 ) <S2SV_EndBug> return 0 ; return dns_resource_key_equal ( p -> question -> keys [ 0 ] , key ) ; }\n","target":"<S2SV_ModStart> ; if ( ! p -> question ) return 0 ; if (\n","project_and_commit_id":"systemd@systemd/a924f43f30f9c4acaf70618dd2a055f8b0f166be","cve_id":"CVE-2017-9217","original_address":"https://github.com/systemd/systemd/commit/a924f43f30f9c4acaf70618dd2a055f8b0f166be","time":"2017-05-24T05:29Z"},
	{"Unnamed: 0":2267,"cwe_id":"CWE-119","source":"CWE-119 IV_API_CALL_STATUS_T impeg2d_api_entity ( iv_obj_t * ps_dechdl , void * pv_api_ip , void * pv_api_op ) { iv_obj_t * ps_dec_handle ; dec_state_t * ps_dec_state ; dec_state_multi_core_t * ps_dec_state_multi_core ; impeg2d_video_decode_ip_t * ps_dec_ip ; impeg2d_video_decode_op_t * ps_dec_op ; WORD32 bytes_remaining ; pic_buf_t * ps_disp_pic ; ps_dec_ip = ( impeg2d_video_decode_ip_t * ) pv_api_ip ; ps_dec_op = ( impeg2d_video_decode_op_t * ) pv_api_op ; memset ( ps_dec_op , 0 , sizeof ( impeg2d_video_decode_op_t ) ) ; ps_dec_op -> s_ivd_video_decode_op_t . u4_size = sizeof ( impeg2d_video_decode_op_t ) ; ps_dec_op -> s_ivd_video_decode_op_t . u4_output_present = 0 ; bytes_remaining = ps_dec_ip -> s_ivd_video_decode_ip_t . u4_num_Bytes ; ps_dec_handle = ( iv_obj_t * ) ps_dechdl ; if ( ps_dechdl == NULL ) { return ( IV_FAIL ) ; } ps_dec_state_multi_core = ps_dec_handle -> pv_codec_handle ; ps_dec_state = ps_dec_state_multi_core -> ps_dec_state [ 0 ] ; ps_dec_state -> ps_disp_frm_buf = & ( ps_dec_op -> s_ivd_video_decode_op_t . s_disp_frm_buf ) ; if ( 0 == ps_dec_state -> u4_share_disp_buf ) { ps_dec_state -> ps_disp_frm_buf -> pv_y_buf = ps_dec_ip -> s_ivd_video_decode_ip_t . s_out_buffer . pu1_bufs [ 0 ] ; ps_dec_state -> ps_disp_frm_buf -> pv_u_buf = ps_dec_ip -> s_ivd_video_decode_ip_t . s_out_buffer . pu1_bufs [ 1 ] ; ps_dec_state -> ps_disp_frm_buf -> pv_v_buf = ps_dec_ip -> s_ivd_video_decode_ip_t . s_out_buffer . pu1_bufs [ 2 ] ; } ps_dec_state -> ps_disp_pic = NULL ; ps_dec_state -> i4_frame_decoded = 0 ; ps_dec_op -> s_ivd_video_decode_op_t . u4_num_bytes_consumed = 0 ; ps_dec_op -> s_ivd_video_decode_op_t . u4_error_code = IV_SUCCESS ; if ( ( ps_dec_ip -> s_ivd_video_decode_ip_t . pv_stream_buffer == NULL ) && ( ps_dec_state -> u1_flushfrm == 0 ) ) { ps_dec_op -> s_ivd_video_decode_op_t . u4_error_code |= 1 << IVD_UNSUPPORTEDPARAM ; ps_dec_op -> s_ivd_video_decode_op_t . u4_error_code |= IVD_DEC_FRM_BS_BUF_NULL ; return IV_FAIL ; } if ( ps_dec_state -> u4_num_frames_decoded > NUM_FRAMES_LIMIT ) { ps_dec_op -> s_ivd_video_decode_op_t . u4_error_code = IMPEG2D_SAMPLE_VERSION_LIMIT_ERR ; return ( IV_FAIL ) ; } if ( ( ( 0 == ps_dec_state -> u2_header_done ) || ( ps_dec_state -> u2_decode_header == 1 ) ) && ( ps_dec_state -> u1_flushfrm == 0 ) ) { impeg2d_dec_hdr ( ps_dec_state , ps_dec_ip , ps_dec_op ) ; bytes_remaining -= ps_dec_op -> s_ivd_video_decode_op_t . u4_num_bytes_consumed ; } <S2SV_StartBug> if ( ( 1 != ps_dec_state -> u2_decode_header ) && ( ( bytes_remaining > 0 ) || ps_dec_state -> u1_flushfrm ) ) <S2SV_EndBug> { if ( ps_dec_state -> u1_flushfrm ) { if ( ps_dec_state -> aps_ref_pics [ 1 ] != NULL ) { impeg2_disp_mgr_add ( & ps_dec_state -> s_disp_mgr , ps_dec_state -> aps_ref_pics [ 1 ] , ps_dec_state -> aps_ref_pics [ 1 ] -> i4_buf_id ) ; impeg2_buf_mgr_release ( ps_dec_state -> pv_pic_buf_mg , ps_dec_state -> aps_ref_pics [ 1 ] -> i4_buf_id , BUF_MGR_REF ) ; impeg2_buf_mgr_release ( ps_dec_state -> pv_pic_buf_mg , ps_dec_state -> aps_ref_pics [ 0 ] -> i4_buf_id , BUF_MGR_REF ) ; ps_dec_state -> aps_ref_pics [ 1 ] = NULL ; ps_dec_state -> aps_ref_pics [ 0 ] = NULL ; } else if ( ps_dec_state -> aps_ref_pics [ 0 ] != NULL ) { impeg2_disp_mgr_add ( & ps_dec_state -> s_disp_mgr , ps_dec_state -> aps_ref_pics [ 0 ] , ps_dec_state -> aps_ref_pics [ 0 ] -> i4_buf_id ) ; impeg2_buf_mgr_release ( ps_dec_state -> pv_pic_buf_mg , ps_dec_state -> aps_ref_pics [ 0 ] -> i4_buf_id , BUF_MGR_REF ) ; ps_dec_state -> aps_ref_pics [ 0 ] = NULL ; } ps_dec_ip -> s_ivd_video_decode_ip_t . u4_size = sizeof ( impeg2d_video_decode_ip_t ) ; ps_dec_op -> s_ivd_video_decode_op_t . u4_size = sizeof ( impeg2d_video_decode_op_t ) ; ps_disp_pic = impeg2_disp_mgr_get ( & ps_dec_state -> s_disp_mgr , & ps_dec_state -> i4_disp_buf_id ) ; ps_dec_state -> ps_disp_pic = ps_disp_pic ; if ( ps_disp_pic == NULL ) { ps_dec_op -> s_ivd_video_decode_op_t . u4_output_present = 0 ; } else { WORD32 fmt_conv ; if ( 0 == ps_dec_state -> u4_share_disp_buf ) { ps_dec_op -> s_ivd_video_decode_op_t . s_disp_frm_buf . pv_y_buf = ps_dec_ip -> s_ivd_video_decode_ip_t . s_out_buffer . pu1_bufs [ 0 ] ; ps_dec_op -> s_ivd_video_decode_op_t . s_disp_frm_buf . pv_u_buf = ps_dec_ip -> s_ivd_video_decode_ip_t . s_out_buffer . pu1_bufs [ 1 ] ; ps_dec_op -> s_ivd_video_decode_op_t . s_disp_frm_buf . pv_v_buf = ps_dec_ip -> s_ivd_video_decode_ip_t . s_out_buffer . pu1_bufs [ 2 ] ; fmt_conv = 1 ; } else { ps_dec_op -> s_ivd_video_decode_op_t . s_disp_frm_buf . pv_y_buf = ps_disp_pic -> pu1_y ; if ( IV_YUV_420P == ps_dec_state -> i4_chromaFormat ) { ps_dec_op -> s_ivd_video_decode_op_t . s_disp_frm_buf . pv_u_buf = ps_disp_pic -> pu1_u ; ps_dec_op -> s_ivd_video_decode_op_t . s_disp_frm_buf . pv_v_buf = ps_disp_pic -> pu1_v ; fmt_conv = 0 ; } else { UWORD8 * pu1_buf ; pu1_buf = ps_dec_state -> as_disp_buffers [ ps_disp_pic -> i4_buf_id ] . pu1_bufs [ 1 ] ; ps_dec_op -> s_ivd_video_decode_op_t . s_disp_frm_buf . pv_u_buf = pu1_buf ; pu1_buf = ps_dec_state -> as_disp_buffers [ ps_disp_pic -> i4_buf_id ] . pu1_bufs [ 2 ] ; ps_dec_op -> s_ivd_video_decode_op_t . s_disp_frm_buf . pv_v_buf = pu1_buf ; fmt_conv = 1 ; } } if ( fmt_conv == 1 ) { iv_yuv_buf_t * ps_dst ; ps_dst = & ( ps_dec_op -> s_ivd_video_decode_op_t . s_disp_frm_buf ) ; if ( ps_dec_state -> u4_deinterlace && ( 0 == ps_dec_state -> u2_progressive_frame ) ) { impeg2d_deinterlace ( ps_dec_state , ps_disp_pic , ps_dst , 0 , ps_dec_state -> u2_vertical_size ) ; } else { impeg2d_format_convert ( ps_dec_state , ps_disp_pic , ps_dst , 0 , ps_dec_state -> u2_vertical_size ) ; } } if ( ps_dec_state -> u4_deinterlace ) { if ( ps_dec_state -> ps_deint_pic ) { impeg2_buf_mgr_release ( ps_dec_state -> pv_pic_buf_mg , ps_dec_state -> ps_deint_pic -> i4_buf_id , MPEG2_BUF_MGR_DEINT ) ; } ps_dec_state -> ps_deint_pic = ps_disp_pic ; } if ( 0 == ps_dec_state -> u4_share_disp_buf ) impeg2_buf_mgr_release ( ps_dec_state -> pv_pic_buf_mg , ps_disp_pic -> i4_buf_id , BUF_MGR_DISP ) ; ps_dec_op -> s_ivd_video_decode_op_t . u4_pic_ht = ps_dec_state -> u2_vertical_size ; ps_dec_op -> s_ivd_video_decode_op_t . u4_pic_wd = ps_dec_state -> u2_horizontal_size ; ps_dec_op -> s_ivd_video_decode_op_t . u4_output_present = 1 ; ps_dec_op -> s_ivd_video_decode_op_t . u4_disp_buf_id = ps_disp_pic -> i4_buf_id ; ps_dec_op -> s_ivd_video_decode_op_t . u4_ts = ps_disp_pic -> u4_ts ; ps_dec_op -> s_ivd_video_decode_op_t . e_output_format = ( IV_COLOR_FORMAT_T ) ps_dec_state -> i4_chromaFormat ; ps_dec_op -> s_ivd_video_decode_op_t . u4_is_ref_flag = ( B_PIC != ps_dec_state -> e_pic_type ) ; ps_dec_op -> s_ivd_video_decode_op_t . u4_progressive_frame_flag = IV_PROGRESSIVE ; ps_dec_op -> s_ivd_video_decode_op_t . s_disp_frm_buf . u4_y_wd = ps_dec_state -> u2_horizontal_size ; ps_dec_op -> s_ivd_video_decode_op_t . s_disp_frm_buf . u4_y_strd = ps_dec_state -> u4_frm_buf_stride ; ps_dec_op -> s_ivd_video_decode_op_t . s_disp_frm_buf . u4_y_ht = ps_dec_state -> u2_vertical_size ; ps_dec_op -> s_ivd_video_decode_op_t . s_disp_frm_buf . u4_u_wd = ps_dec_state -> u2_horizontal_size >> 1 ; ps_dec_op -> s_ivd_video_decode_op_t . s_disp_frm_buf . u4_u_strd = ps_dec_state -> u4_frm_buf_stride >> 1 ; ps_dec_op -> s_ivd_video_decode_op_t . s_disp_frm_buf . u4_u_ht = ps_dec_state -> u2_vertical_size >> 1 ; ps_dec_op -> s_ivd_video_decode_op_t . s_disp_frm_buf . u4_v_wd = ps_dec_state -> u2_horizontal_size >> 1 ; ps_dec_op -> s_ivd_video_decode_op_t . s_disp_frm_buf . u4_v_strd = ps_dec_state -> u4_frm_buf_stride >> 1 ; ps_dec_op -> s_ivd_video_decode_op_t . s_disp_frm_buf . u4_v_ht = ps_dec_state -> u2_vertical_size >> 1 ; ps_dec_op -> s_ivd_video_decode_op_t . s_disp_frm_buf . u4_size = sizeof ( ps_dec_op -> s_ivd_video_decode_op_t . s_disp_frm_buf ) ; switch ( ps_dec_state -> i4_chromaFormat ) { case IV_YUV_420SP_UV : case IV_YUV_420SP_VU : ps_dec_op -> s_ivd_video_decode_op_t . s_disp_frm_buf . u4_u_wd = ps_dec_state -> u2_horizontal_size ; ps_dec_op -> s_ivd_video_decode_op_t . s_disp_frm_buf . u4_u_strd = ps_dec_state -> u4_frm_buf_stride ; break ; case IV_YUV_422ILE : ps_dec_op -> s_ivd_video_decode_op_t . s_disp_frm_buf . u4_u_wd = 0 ; ps_dec_op -> s_ivd_video_decode_op_t . s_disp_frm_buf . u4_u_ht = 0 ; ps_dec_op -> s_ivd_video_decode_op_t . s_disp_frm_buf . u4_v_wd = 0 ; ps_dec_op -> s_ivd_video_decode_op_t . s_disp_frm_buf . u4_v_ht = 0 ; break ; default : break ; } } if ( ps_dec_op -> s_ivd_video_decode_op_t . u4_output_present ) { if ( 1 == ps_dec_op -> s_ivd_video_decode_op_t . u4_output_present ) { INSERT_LOGO ( ps_dec_ip -> s_ivd_video_decode_ip_t . s_out_buffer . pu1_bufs [ 0 ] , ps_dec_ip -> s_ivd_video_decode_ip_t . s_out_buffer . pu1_bufs [ 1 ] , ps_dec_ip -> s_ivd_video_decode_ip_t . s_out_buffer . pu1_bufs [ 2 ] , ps_dec_state -> u4_frm_buf_stride , ps_dec_state -> u2_horizontal_size , ps_dec_state -> u2_vertical_size , ps_dec_state -> i4_chromaFormat , ps_dec_state -> u2_horizontal_size , ps_dec_state -> u2_vertical_size ) ; } return ( IV_SUCCESS ) ; } else { ps_dec_state -> u1_flushfrm = 0 ; return ( IV_FAIL ) ; } } else if ( ps_dec_state -> u1_flushfrm == 0 ) { ps_dec_ip -> s_ivd_video_decode_ip_t . u4_size = sizeof ( impeg2d_video_decode_ip_t ) ; ps_dec_op -> s_ivd_video_decode_op_t . u4_size = sizeof ( impeg2d_video_decode_op_t ) ; if ( ps_dec_ip -> s_ivd_video_decode_ip_t . u4_num_Bytes < 4 ) { ps_dec_op -> s_ivd_video_decode_op_t . u4_num_bytes_consumed = ps_dec_ip -> s_ivd_video_decode_ip_t . u4_num_Bytes ; return ( IV_FAIL ) ; } if ( 1 == ps_dec_state -> u4_share_disp_buf ) { if ( 0 == impeg2_buf_mgr_check_free ( ps_dec_state -> pv_pic_buf_mg ) ) { ps_dec_op -> s_ivd_video_decode_op_t . u4_error_code = ( IMPEG2D_ERROR_CODES_T ) IVD_DEC_REF_BUF_NULL ; return IV_FAIL ; } } ps_dec_op -> s_ivd_video_decode_op_t . e_output_format = ( IV_COLOR_FORMAT_T ) ps_dec_state -> i4_chromaFormat ; ps_dec_op -> s_ivd_video_decode_op_t . u4_is_ref_flag = ( B_PIC != ps_dec_state -> e_pic_type ) ; ps_dec_op -> s_ivd_video_decode_op_t . u4_progressive_frame_flag = IV_PROGRESSIVE ; if ( 0 == ps_dec_state -> u4_frm_buf_stride ) { ps_dec_state -> u4_frm_buf_stride = ( ps_dec_state -> u2_horizontal_size ) ; } ps_dec_op -> s_ivd_video_decode_op_t . s_disp_frm_buf . u4_y_wd = ps_dec_state -> u2_horizontal_size ; ps_dec_op -> s_ivd_video_decode_op_t . s_disp_frm_buf . u4_y_strd = ps_dec_state -> u4_frm_buf_stride ; ps_dec_op -> s_ivd_video_decode_op_t . s_disp_frm_buf . u4_y_ht = ps_dec_state -> u2_vertical_size ; ps_dec_op -> s_ivd_video_decode_op_t . s_disp_frm_buf . u4_u_wd = ps_dec_state -> u2_horizontal_size >> 1 ; ps_dec_op -> s_ivd_video_decode_op_t . s_disp_frm_buf . u4_u_strd = ps_dec_state -> u4_frm_buf_stride >> 1 ; ps_dec_op -> s_ivd_video_decode_op_t . s_disp_frm_buf . u4_u_ht = ps_dec_state -> u2_vertical_size >> 1 ; ps_dec_op -> s_ivd_video_decode_op_t . s_disp_frm_buf . u4_v_wd = ps_dec_state -> u2_horizontal_size >> 1 ; ps_dec_op -> s_ivd_video_decode_op_t . s_disp_frm_buf . u4_v_strd = ps_dec_state -> u4_frm_buf_stride >> 1 ; ps_dec_op -> s_ivd_video_decode_op_t . s_disp_frm_buf . u4_v_ht = ps_dec_state -> u2_vertical_size >> 1 ; ps_dec_op -> s_ivd_video_decode_op_t . s_disp_frm_buf . u4_size = sizeof ( ps_dec_op -> s_ivd_video_decode_op_t . s_disp_frm_buf ) ; switch ( ps_dec_state -> i4_chromaFormat ) { case IV_YUV_420SP_UV : case IV_YUV_420SP_VU : ps_dec_op -> s_ivd_video_decode_op_t . s_disp_frm_buf . u4_u_wd = ps_dec_state -> u2_horizontal_size ; ps_dec_op -> s_ivd_video_decode_op_t . s_disp_frm_buf . u4_u_strd = ps_dec_state -> u4_frm_buf_stride ; break ; case IV_YUV_422ILE : ps_dec_op -> s_ivd_video_decode_op_t . s_disp_frm_buf . u4_u_wd = 0 ; ps_dec_op -> s_ivd_video_decode_op_t . s_disp_frm_buf . u4_u_ht = 0 ; ps_dec_op -> s_ivd_video_decode_op_t . s_disp_frm_buf . u4_v_wd = 0 ; ps_dec_op -> s_ivd_video_decode_op_t . s_disp_frm_buf . u4_v_ht = 0 ; break ; default : break ; } if ( ps_dec_state -> u1_flushfrm == 0 ) { ps_dec_state -> u1_flushcnt = 0 ; impeg2d_dec_frm ( ps_dec_state , ps_dec_ip , ps_dec_op ) ; if ( IVD_ERROR_NONE == ps_dec_op -> s_ivd_video_decode_op_t . u4_error_code ) { if ( ps_dec_state -> u1_first_frame_done == 0 ) { ps_dec_state -> u1_first_frame_done = 1 ; } if ( ps_dec_state -> ps_disp_pic ) { ps_dec_op -> s_ivd_video_decode_op_t . u4_output_present = 1 ; switch ( ps_dec_state -> ps_disp_pic -> e_pic_type ) { case I_PIC : ps_dec_op -> s_ivd_video_decode_op_t . e_pic_type = IV_I_FRAME ; break ; case P_PIC : ps_dec_op -> s_ivd_video_decode_op_t . e_pic_type = IV_P_FRAME ; break ; case B_PIC : ps_dec_op -> s_ivd_video_decode_op_t . e_pic_type = IV_B_FRAME ; break ; case D_PIC : ps_dec_op -> s_ivd_video_decode_op_t . e_pic_type = IV_I_FRAME ; break ; default : ps_dec_op -> s_ivd_video_decode_op_t . e_pic_type = IV_FRAMETYPE_DEFAULT ; break ; } } else { ps_dec_op -> s_ivd_video_decode_op_t . u4_output_present = 0 ; ps_dec_op -> s_ivd_video_decode_op_t . e_pic_type = IV_NA_FRAME ; } ps_dec_state -> u4_num_frames_decoded ++ ; } } else { ps_dec_state -> u1_flushcnt ++ ; } } if ( ps_dec_state -> ps_disp_pic ) { ps_dec_op -> s_ivd_video_decode_op_t . u4_disp_buf_id = ps_dec_state -> ps_disp_pic -> i4_buf_id ; ps_dec_op -> s_ivd_video_decode_op_t . u4_ts = ps_dec_state -> ps_disp_pic -> u4_ts ; if ( 0 == ps_dec_state -> u4_share_disp_buf ) { impeg2_buf_mgr_release ( ps_dec_state -> pv_pic_buf_mg , ps_dec_state -> ps_disp_pic -> i4_buf_id , BUF_MGR_DISP ) ; } } if ( ps_dec_state -> u4_deinterlace ) { if ( ps_dec_state -> ps_deint_pic ) { impeg2_buf_mgr_release ( ps_dec_state -> pv_pic_buf_mg , ps_dec_state -> ps_deint_pic -> i4_buf_id , MPEG2_BUF_MGR_DEINT ) ; } ps_dec_state -> ps_deint_pic = ps_dec_state -> ps_disp_pic ; } if ( 1 == ps_dec_op -> s_ivd_video_decode_op_t . u4_output_present ) { INSERT_LOGO ( ps_dec_ip -> s_ivd_video_decode_ip_t . s_out_buffer . pu1_bufs [ 0 ] , ps_dec_ip -> s_ivd_video_decode_ip_t . s_out_buffer . pu1_bufs [ 1 ] , ps_dec_ip -> s_ivd_video_decode_ip_t . s_out_buffer . pu1_bufs [ 2 ] , ps_dec_state -> u4_frm_buf_stride , ps_dec_state -> u2_horizontal_size , ps_dec_state -> u2_vertical_size , ps_dec_state -> i4_chromaFormat , ps_dec_state -> u2_horizontal_size , ps_dec_state -> u2_vertical_size ) ; } } ps_dec_op -> s_ivd_video_decode_op_t . u4_progressive_frame_flag = 1 ; ps_dec_op -> s_ivd_video_decode_op_t . e4_fld_type = ps_dec_state -> s_disp_op . e4_fld_type ; if ( ps_dec_op -> s_ivd_video_decode_op_t . u4_error_code ) return IV_FAIL ; else return IV_SUCCESS ; }\n","target":"<S2SV_ModStart> u2_decode_header ) && ( <S2SV_ModStart> bytes_remaining > 0 ) && ( 1 == ps_dec_state -> u2_header_done )\n","project_and_commit_id":"external@libmpeg2/a86eb798d077b9b25c8f8c77e3c02c2f287c1ce7","cve_id":"CVE-2017-0587","original_address":"https://android.googlesource.com/platform/external/libmpeg2/+/a86eb798d077b9b25c8f8c77e3c02c2f287c1ce7","time":"2017-05-12T15:29Z"},
	{"Unnamed: 0":5711,"cwe_id":"CWE-200","source":"CWE-200 int keepalived_main ( int argc , char * * argv ) { bool report_stopped = true ; struct utsname uname_buf ; char * end ; set_time_now ( ) ; save_cmd_line_options ( argc , argv ) ; debug = 0 ; # ifndef _DEBUG_ prog_type = PROG_TYPE_PARENT ; # endif # ifdef _WITH_VRRP_ __set_bit ( DAEMON_VRRP , & daemon_mode ) ; # endif # ifdef _WITH_LVS_ __set_bit ( DAEMON_CHECKERS , & daemon_mode ) ; # endif # ifdef _WITH_BFD_ __set_bit ( DAEMON_BFD , & daemon_mode ) ; <S2SV_StartBug> # endif <S2SV_EndBug> openlog ( PACKAGE_NAME , LOG_PID , log_facility ) ; # ifdef _MEM_CHECK_ mem_log_init ( PACKAGE_NAME , \"Parent<S2SV_blank>process\" ) ; # endif if ( uname ( & uname_buf ) ) log_message ( LOG_INFO , \"Unable<S2SV_blank>to<S2SV_blank>get<S2SV_blank>uname()<S2SV_blank>information<S2SV_blank>-<S2SV_blank>error<S2SV_blank>%d\" , errno ) ; else { os_major = ( unsigned ) strtoul ( uname_buf . release , & end , 10 ) ; if ( * end != '.' ) os_major = 0 ; else { os_minor = ( unsigned ) strtoul ( end + 1 , & end , 10 ) ; if ( * end != '.' ) os_major = 0 ; else { if ( ! isdigit ( end [ 1 ] ) ) os_major = 0 ; else os_release = ( unsigned ) strtoul ( end + 1 , & end , 10 ) ; } } if ( ! os_major ) log_message ( LOG_INFO , \"Unable<S2SV_blank>to<S2SV_blank>parse<S2SV_blank>kernel<S2SV_blank>version<S2SV_blank>%s\" , uname_buf . release ) ; if ( ! config_id ) { end = strchrnul ( uname_buf . nodename , '.' ) ; config_id = MALLOC ( ( size_t ) ( end - uname_buf . nodename ) + 1 ) ; strncpy ( config_id , uname_buf . nodename , ( size_t ) ( end - uname_buf . nodename ) ) ; config_id [ end - uname_buf . nodename ] = '\\\\0' ; } } if ( parse_cmdline ( argc , argv ) ) { closelog ( ) ; if ( ! __test_bit ( NO_SYSLOG_BIT , & debug ) ) openlog ( PACKAGE_NAME , LOG_PID | ( ( __test_bit ( LOG_CONSOLE_BIT , & debug ) ) ? LOG_CONS : 0 ) , log_facility ) ; } if ( __test_bit ( LOG_CONSOLE_BIT , & debug ) ) enable_console_log ( ) ; # ifdef GIT_COMMIT log_message ( LOG_INFO , \"Starting<S2SV_blank>%s,<S2SV_blank>git<S2SV_blank>commit<S2SV_blank>%s\" , version_string , GIT_COMMIT ) ; # else log_message ( LOG_INFO , \"Starting<S2SV_blank>%s\" , version_string ) ; # endif core_dump_init ( ) ; if ( os_major ) { if ( KERNEL_VERSION ( os_major , os_minor , os_release ) < LINUX_VERSION_CODE ) { log_message ( LOG_INFO , \"WARNING<S2SV_blank>-<S2SV_blank>keepalived<S2SV_blank>was<S2SV_blank>build<S2SV_blank>for<S2SV_blank>newer<S2SV_blank>Linux<S2SV_blank>%d.%d.%d,<S2SV_blank>running<S2SV_blank>on<S2SV_blank>%s<S2SV_blank>%s<S2SV_blank>%s\" , ( LINUX_VERSION_CODE >> 16 ) & 0xff , ( LINUX_VERSION_CODE >> 8 ) & 0xff , ( LINUX_VERSION_CODE ) & 0xff , uname_buf . sysname , uname_buf . release , uname_buf . version ) ; } else { log_message ( LOG_INFO , \"Running<S2SV_blank>on<S2SV_blank>%s<S2SV_blank>%s<S2SV_blank>%s<S2SV_blank>(built<S2SV_blank>for<S2SV_blank>Linux<S2SV_blank>%d.%d.%d)\" , uname_buf . sysname , uname_buf . release , uname_buf . version , ( LINUX_VERSION_CODE >> 16 ) & 0xff , ( LINUX_VERSION_CODE >> 8 ) & 0xff , ( LINUX_VERSION_CODE ) & 0xff ) ; } } # ifndef _DEBUG_ log_command_line ( 0 ) ; # endif if ( ! check_conf_file ( conf_file ) ) { if ( __test_bit ( CONFIG_TEST_BIT , & debug ) ) config_test_exit ( ) ; goto end ; } global_data = alloc_global_data ( ) ; <S2SV_StartBug> read_config_file ( ) ; <S2SV_EndBug> init_global_data ( global_data , NULL ) ; # if HAVE_DECL_CLONE_NEWNET if ( override_namespace ) { if ( global_data -> network_namespace ) { log_message ( LOG_INFO , \"Overriding<S2SV_blank>config<S2SV_blank>net_namespace<S2SV_blank>\\'%s\\'<S2SV_blank>with<S2SV_blank>command<S2SV_blank>line<S2SV_blank>namespace<S2SV_blank>\\'%s\\'\" , global_data -> network_namespace , override_namespace ) ; FREE ( global_data -> network_namespace ) ; } global_data -> network_namespace = override_namespace ; override_namespace = NULL ; } # endif if ( ! __test_bit ( CONFIG_TEST_BIT , & debug ) && ( global_data -> instance_name # if HAVE_DECL_CLONE_NEWNET || global_data -> network_namespace # endif ) ) { if ( ( syslog_ident = make_syslog_ident ( PACKAGE_NAME ) ) ) { log_message ( LOG_INFO , \"Changing<S2SV_blank>syslog<S2SV_blank>ident<S2SV_blank>to<S2SV_blank>%s\" , syslog_ident ) ; closelog ( ) ; openlog ( syslog_ident , LOG_PID | ( ( __test_bit ( LOG_CONSOLE_BIT , & debug ) ) ? LOG_CONS : 0 ) , log_facility ) ; } else log_message ( LOG_INFO , \"Unable<S2SV_blank>to<S2SV_blank>change<S2SV_blank>syslog<S2SV_blank>ident\" ) ; use_pid_dir = true ; open_log_file ( log_file_name , NULL , # if HAVE_DECL_CLONE_NEWNET global_data -> network_namespace , # else NULL , # endif global_data -> instance_name ) ; } set_child_finder_name ( find_keepalived_child_name ) ; if ( ! __test_bit ( CONFIG_TEST_BIT , & debug ) ) { if ( use_pid_dir ) { create_pid_dir ( ) ; } } # if HAVE_DECL_CLONE_NEWNET if ( global_data -> network_namespace ) { if ( global_data -> network_namespace && ! set_namespaces ( global_data -> network_namespace ) ) { log_message ( LOG_ERR , \"Unable<S2SV_blank>to<S2SV_blank>set<S2SV_blank>network<S2SV_blank>namespace<S2SV_blank>%s<S2SV_blank>-<S2SV_blank>exiting\" , global_data -> network_namespace ) ; goto end ; } } # endif if ( ! __test_bit ( CONFIG_TEST_BIT , & debug ) ) { if ( global_data -> instance_name ) { if ( ! main_pidfile && ( main_pidfile = make_pidfile_name ( KEEPALIVED_PID_DIR KEEPALIVED_PID_FILE , global_data -> instance_name , PID_EXTENSION ) ) ) free_main_pidfile = true ; # ifdef _WITH_LVS_ if ( ! checkers_pidfile && ( checkers_pidfile = make_pidfile_name ( KEEPALIVED_PID_DIR CHECKERS_PID_FILE , global_data -> instance_name , PID_EXTENSION ) ) ) free_checkers_pidfile = true ; # endif # ifdef _WITH_VRRP_ if ( ! vrrp_pidfile && ( vrrp_pidfile = make_pidfile_name ( KEEPALIVED_PID_DIR VRRP_PID_FILE , global_data -> instance_name , PID_EXTENSION ) ) ) free_vrrp_pidfile = true ; # endif # ifdef _WITH_BFD_ if ( ! bfd_pidfile && ( bfd_pidfile = make_pidfile_name ( KEEPALIVED_PID_DIR VRRP_PID_FILE , global_data -> instance_name , PID_EXTENSION ) ) ) free_bfd_pidfile = true ; # endif } if ( use_pid_dir ) { if ( ! main_pidfile ) main_pidfile = KEEPALIVED_PID_DIR KEEPALIVED_PID_FILE PID_EXTENSION ; # ifdef _WITH_LVS_ if ( ! checkers_pidfile ) checkers_pidfile = KEEPALIVED_PID_DIR CHECKERS_PID_FILE PID_EXTENSION ; # endif # ifdef _WITH_VRRP_ if ( ! vrrp_pidfile ) vrrp_pidfile = KEEPALIVED_PID_DIR VRRP_PID_FILE PID_EXTENSION ; # endif # ifdef _WITH_BFD_ if ( ! bfd_pidfile ) bfd_pidfile = KEEPALIVED_PID_DIR BFD_PID_FILE PID_EXTENSION ; # endif } else { if ( ! main_pidfile ) main_pidfile = PID_DIR KEEPALIVED_PID_FILE PID_EXTENSION ; # ifdef _WITH_LVS_ if ( ! checkers_pidfile ) checkers_pidfile = PID_DIR CHECKERS_PID_FILE PID_EXTENSION ; # endif # ifdef _WITH_VRRP_ if ( ! vrrp_pidfile ) vrrp_pidfile = PID_DIR VRRP_PID_FILE PID_EXTENSION ; # endif # ifdef _WITH_BFD_ if ( ! bfd_pidfile ) bfd_pidfile = PID_DIR BFD_PID_FILE PID_EXTENSION ; # endif } if ( keepalived_running ( daemon_mode ) ) { log_message ( LOG_INFO , \"daemon<S2SV_blank>is<S2SV_blank>already<S2SV_blank>running\" ) ; report_stopped = false ; goto end ; } } if ( ! __test_bit ( DONT_FORK_BIT , & debug ) && xdaemon ( false , false , true ) > 0 ) { closelog ( ) ; FREE_PTR ( config_id ) ; FREE_PTR ( orig_core_dump_pattern ) ; close_std_fd ( ) ; exit ( 0 ) ; } <S2SV_StartBug> umask ( 0 ) ; <S2SV_EndBug> # ifdef _MEM_CHECK_ enable_mem_log_termination ( ) ; # endif if ( __test_bit ( CONFIG_TEST_BIT , & debug ) ) { validate_config ( ) ; config_test_exit ( ) ; } if ( ! pidfile_write ( main_pidfile , getpid ( ) ) ) goto end ; master = thread_make_master ( ) ; signal_init ( ) ; if ( ! start_keepalived ( ) ) log_message ( LOG_INFO , \"Warning<S2SV_blank>-<S2SV_blank>keepalived<S2SV_blank>has<S2SV_blank>no<S2SV_blank>configuration<S2SV_blank>to<S2SV_blank>run\" ) ; initialise_debug_options ( ) ; # ifdef THREAD_DUMP register_parent_thread_addresses ( ) ; # endif launch_thread_scheduler ( master ) ; stop_keepalived ( ) ; # ifdef THREAD_DUMP deregister_thread_addresses ( ) ; # endif end : if ( report_stopped ) { # ifdef GIT_COMMIT log_message ( LOG_INFO , \"Stopped<S2SV_blank>%s,<S2SV_blank>git<S2SV_blank>commit<S2SV_blank>%s\" , version_string , GIT_COMMIT ) ; # else log_message ( LOG_INFO , \"Stopped<S2SV_blank>%s\" , version_string ) ; # endif } # if HAVE_DECL_CLONE_NEWNET if ( global_data && global_data -> network_namespace ) clear_namespaces ( ) ; # endif if ( use_pid_dir ) remove_pid_dir ( ) ; if ( orig_core_dump_pattern ) update_core_dump_pattern ( orig_core_dump_pattern ) ; free_parent_mallocs_startup ( false ) ; free_parent_mallocs_exit ( ) ; free_global_data ( global_data ) ; closelog ( ) ; # ifndef _MEM_CHECK_LOG_ FREE_PTR ( syslog_ident ) ; # else if ( syslog_ident ) free ( syslog_ident ) ; # endif close_std_fd ( ) ; exit ( KEEPALIVED_EXIT_OK ) ; }\n","target":"<S2SV_ModStart> ; # endif umask ( 022 ) ; <S2SV_ModStart> ( ) ; global_data -> umask = umask_val ; <S2SV_ModStart> ) ; } <S2SV_ModEnd> # ifdef _MEM_CHECK_\n","project_and_commit_id":"acassen@keepalived/c6247a9ef2c7b33244ab1d3aa5d629ec49f0a067","cve_id":"CVE-2018-19045","original_address":"https://github.com/acassen/keepalived/commit/c6247a9ef2c7b33244ab1d3aa5d629ec49f0a067","time":"2018-11-08T20:29Z"},
	{"Unnamed: 0":957,"cwe_id":"CWE-20","source":"CWE-20 int nfsd_dispatch ( struct svc_rqst * rqstp , __be32 * statp ) { struct svc_procedure * proc ; kxdrproc_t xdr ; __be32 nfserr ; __be32 * nfserrp ; dprintk ( \"nfsd_dispatch:<S2SV_blank>vers<S2SV_blank>%d<S2SV_blank>proc<S2SV_blank>%d\\\\n\" , rqstp -> rq_vers , rqstp -> rq_proc ) ; <S2SV_StartBug> proc = rqstp -> rq_procinfo ; <S2SV_EndBug> rqstp -> rq_cachetype = proc -> pc_cachetype ; xdr = proc -> pc_decode ; if ( xdr && ! xdr ( rqstp , ( __be32 * ) rqstp -> rq_arg . head [ 0 ] . iov_base , rqstp -> rq_argp ) ) { dprintk ( \"nfsd:<S2SV_blank>failed<S2SV_blank>to<S2SV_blank>decode<S2SV_blank>arguments!\\\\n\" ) ; * statp = rpc_garbage_args ; return 1 ; } switch ( nfsd_cache_lookup ( rqstp ) ) { case RC_DROPIT : return 0 ; case RC_REPLY : return 1 ; case RC_DOIT : ; } nfserrp = rqstp -> rq_res . head [ 0 ] . iov_base + rqstp -> rq_res . head [ 0 ] . iov_len ; rqstp -> rq_res . head [ 0 ] . iov_len += sizeof ( __be32 ) ; nfserr = proc -> pc_func ( rqstp , rqstp -> rq_argp , rqstp -> rq_resp ) ; nfserr = map_new_errors ( rqstp -> rq_vers , nfserr ) ; if ( nfserr == nfserr_dropit || test_bit ( RQ_DROPME , & rqstp -> rq_flags ) ) { dprintk ( \"nfsd:<S2SV_blank>Dropping<S2SV_blank>request;<S2SV_blank>may<S2SV_blank>be<S2SV_blank>revisited<S2SV_blank>later\\\\n\" ) ; nfsd_cache_update ( rqstp , RC_NOCACHE , NULL ) ; return 0 ; } if ( rqstp -> rq_proc != 0 ) * nfserrp ++ = nfserr ; if ( ! ( nfserr && rqstp -> rq_vers == 2 ) ) { xdr = proc -> pc_encode ; if ( xdr && ! xdr ( rqstp , nfserrp , rqstp -> rq_resp ) ) { dprintk ( \"nfsd:<S2SV_blank>failed<S2SV_blank>to<S2SV_blank>encode<S2SV_blank>result!\\\\n\" ) ; nfsd_cache_update ( rqstp , RC_NOCACHE , NULL ) ; * statp = rpc_system_err ; return 1 ; } } nfsd_cache_update ( rqstp , rqstp -> rq_cachetype , statp + 1 ) ; return 1 ; }\n","target":"<S2SV_ModStart> -> rq_procinfo ; if ( nfs_request_too_big ( rqstp , proc ) ) { dprintk ( \"nfsd:<S2SV_blank>NFSv%d<S2SV_blank>argument<S2SV_blank>too<S2SV_blank>large\\\\n\" , rqstp -> rq_vers ) ; * statp = rpc_garbage_args ; return 1 ; }\n","project_and_commit_id":"torvalds@linux/e6838a29ecb484c97e4efef9429643b9851fba6e","cve_id":"CVE-2017-7645","original_address":"https://github.com/torvalds/linux/commit/e6838a29ecb484c97e4efef9429643b9851fba6e","time":"2017-04-18T14:59Z"},
	{"Unnamed: 0":2987,"cwe_id":"CWE-125","source":"CWE-125 static void atmarp_print ( netdissect_options * ndo , const u_char * bp , u_int length , u_int caplen ) { const struct atmarp_pkthdr * ap ; u_short pro , hrd , op ; ap = ( const struct atmarp_pkthdr * ) bp ; ND_TCHECK ( * ap ) ; hrd = ATMHRD ( ap ) ; pro = ATMPRO ( ap ) ; op = ATMOP ( ap ) ; if ( ! ND_TTEST2 ( * aar_tpa ( ap ) , ATMTPROTO_LEN ( ap ) ) ) { ND_PRINT ( ( ndo , \"%s\" , tstr ) ) ; ND_DEFAULTPRINT ( ( const u_char * ) ap , length ) ; return ; } if ( ! ndo -> ndo_eflag ) { ND_PRINT ( ( ndo , \"ARP,<S2SV_blank>\" ) ) ; } if ( ( pro != ETHERTYPE_IP && pro != ETHERTYPE_TRAIL ) || ATMSPROTO_LEN ( ap ) != 4 || ATMTPROTO_LEN ( ap ) != 4 || ndo -> ndo_vflag ) { ND_PRINT ( ( ndo , \"%s,<S2SV_blank>%s<S2SV_blank>(len<S2SV_blank>%u/%u)\" , tok2str ( arphrd_values , \"Unknown<S2SV_blank>Hardware<S2SV_blank>(%u)\" , hrd ) , tok2str ( ethertype_values , \"Unknown<S2SV_blank>Protocol<S2SV_blank>(0x%04x)\" , pro ) , ATMSPROTO_LEN ( ap ) , ATMTPROTO_LEN ( ap ) ) ) ; if ( ! ndo -> ndo_vflag ) { goto out ; } } ND_PRINT ( ( ndo , \"%s%s<S2SV_blank>\" , ndo -> ndo_vflag ? \",<S2SV_blank>\" : \"\" , tok2str ( arpop_values , \"Unknown<S2SV_blank>(%u)\" , op ) ) ) ; switch ( op ) { case ARPOP_REQUEST : <S2SV_StartBug> ND_PRINT ( ( ndo , \"who-has<S2SV_blank>%s\" , ipaddr_string ( ndo , ATMTPA ( ap ) ) ) ) ; <S2SV_EndBug> if ( ATMTHRD_LEN ( ap ) != 0 ) { ND_PRINT ( ( ndo , \"<S2SV_blank>(\" ) ) ; atmarp_addr_print ( ndo , ATMTHA ( ap ) , ATMTHRD_LEN ( ap ) , ATMTSA ( ap ) , ATMTSLN ( ap ) ) ; ND_PRINT ( ( ndo , \")\" ) ) ; } <S2SV_StartBug> ND_PRINT ( ( ndo , \"tell<S2SV_blank>%s\" , ipaddr_string ( ndo , ATMSPA ( ap ) ) ) ) ; <S2SV_EndBug> break ; case ARPOP_REPLY : <S2SV_StartBug> ND_PRINT ( ( ndo , \"%s<S2SV_blank>is-at<S2SV_blank>\" , ipaddr_string ( ndo , ATMSPA ( ap ) ) ) ) ; <S2SV_EndBug> atmarp_addr_print ( ndo , ATMSHA ( ap ) , ATMSHRD_LEN ( ap ) , ATMSSA ( ap ) , ATMSSLN ( ap ) ) ; break ; case ARPOP_INVREQUEST : ND_PRINT ( ( ndo , \"who-is<S2SV_blank>\" ) ) ; atmarp_addr_print ( ndo , ATMTHA ( ap ) , ATMTHRD_LEN ( ap ) , ATMTSA ( ap ) , ATMTSLN ( ap ) ) ; ND_PRINT ( ( ndo , \"<S2SV_blank>tell<S2SV_blank>\" ) ) ; atmarp_addr_print ( ndo , ATMSHA ( ap ) , ATMSHRD_LEN ( ap ) , ATMSSA ( ap ) , ATMSSLN ( ap ) ) ; break ; case ARPOP_INVREPLY : atmarp_addr_print ( ndo , ATMSHA ( ap ) , ATMSHRD_LEN ( ap ) , ATMSSA ( ap ) , ATMSSLN ( ap ) ) ; <S2SV_StartBug> ND_PRINT ( ( ndo , \"at<S2SV_blank>%s\" , ipaddr_string ( ndo , ATMSPA ( ap ) ) ) ) ; <S2SV_EndBug> break ; case ARPOP_NAK : <S2SV_StartBug> ND_PRINT ( ( ndo , \"for<S2SV_blank>%s\" , ipaddr_string ( ndo , ATMSPA ( ap ) ) ) ) ; <S2SV_EndBug> break ; default : ND_DEFAULTPRINT ( ( const u_char * ) ap , caplen ) ; return ; } out : ND_PRINT ( ( ndo , \",<S2SV_blank>length<S2SV_blank>%u\" , length ) ) ; return ; trunc : ND_PRINT ( ( ndo , \"%s\" , tstr ) ) ; }\n","target":"<S2SV_ModStart> ( ndo , \"who-has<S2SV_blank>\" ) ) ; atmarp_tpaddr_print ( ndo , ap , pro <S2SV_ModEnd> ) ; if <S2SV_ModStart> ( ndo , \"<S2SV_blank>tell<S2SV_blank>\" ) ) ; atmarp_spaddr_print ( ndo , ap , pro <S2SV_ModEnd> ) ; break <S2SV_ModStart> case ARPOP_REPLY : atmarp_spaddr_print ( ndo , ap , pro ) ; ND_PRINT ( ( ndo , \"<S2SV_blank>is-at<S2SV_blank>\" <S2SV_ModEnd> ) ) ; <S2SV_ModStart> ( ndo , \"at<S2SV_blank>\" ) ) ; atmarp_spaddr_print ( ndo , ap , pro <S2SV_ModEnd> ) ; break <S2SV_ModStart> ( ndo , \"for<S2SV_blank>\" ) ) ; atmarp_spaddr_print ( ndo , ap , pro <S2SV_ModEnd> ) ; break\n","project_and_commit_id":"the-tcpdump-group@tcpdump/13ab8d18617d616c7d343530f8a842e7143fb5cc","cve_id":"CVE-2017-13013","original_address":"https://github.com/the-tcpdump-group/tcpdump/commit/13ab8d18617d616c7d343530f8a842e7143fb5cc","time":"2017-09-14T06:29Z"},
	{"Unnamed: 0":4393,"cwe_id":"CWE-362","source":"CWE-362 void sctp_generate_t3_rtx_event ( unsigned long peer ) { int error ; struct sctp_transport * transport = ( struct sctp_transport * ) peer ; struct sctp_association * asoc = transport -> asoc ; <S2SV_StartBug> struct net * net = sock_net ( asoc -> base . sk ) ; <S2SV_EndBug> <S2SV_StartBug> bh_lock_sock ( asoc -> base . sk ) ; <S2SV_EndBug> <S2SV_StartBug> if ( sock_owned_by_user ( asoc -> base . sk ) ) { <S2SV_EndBug> pr_debug ( \"%s:<S2SV_blank>sock<S2SV_blank>is<S2SV_blank>busy\\\\n\" , __func__ ) ; if ( ! mod_timer ( & transport -> T3_rtx_timer , jiffies + ( HZ / 20 ) ) ) sctp_transport_hold ( transport ) ; goto out_unlock ; } if ( transport -> dead ) goto out_unlock ; error = sctp_do_sm ( net , SCTP_EVENT_T_TIMEOUT , SCTP_ST_TIMEOUT ( SCTP_EVENT_TIMEOUT_T3_RTX ) , asoc -> state , asoc -> ep , asoc , transport , GFP_ATOMIC ) ; if ( error ) <S2SV_StartBug> asoc -> base . sk -> sk_err = - error ; <S2SV_EndBug> out_unlock : <S2SV_StartBug> bh_unlock_sock ( asoc -> base . sk ) ; <S2SV_EndBug> sctp_transport_put ( transport ) ; }\n","target":"<S2SV_ModStart> asoc ; struct sock * sk = asoc -> base . sk ; struct <S2SV_ModStart> = sock_net ( <S2SV_ModEnd> sk ) ; <S2SV_ModStart> ; bh_lock_sock ( <S2SV_ModEnd> sk ) ; <S2SV_ModStart> ( sock_owned_by_user ( <S2SV_ModEnd> sk ) ) <S2SV_ModStart> ( error ) <S2SV_ModEnd> sk -> sk_err <S2SV_ModStart> : bh_unlock_sock ( <S2SV_ModEnd> sk ) ;\n","project_and_commit_id":"torvalds@linux/635682a14427d241bab7bbdeebb48a7d7b91638e","cve_id":"CVE-2015-8767","original_address":"https://github.com/torvalds/linux/commit/635682a14427d241bab7bbdeebb48a7d7b91638e","time":"2016-02-08T03:59Z"},
	{"Unnamed: 0":5787,"cwe_id":"CWE-119","source":"CWE-119 static int parse_video_info ( AVIOContext * pb , AVStream * st ) { uint16_t size_asf ; uint32_t size_bmp ; unsigned int tag ; st -> codecpar -> width = avio_rl32 ( pb ) ; st -> codecpar -> height = avio_rl32 ( pb ) ; avio_skip ( pb , 1 ) ; size_asf = avio_rl16 ( pb ) ; tag = ff_get_bmp_header ( pb , st , & size_bmp ) ; st -> codecpar -> codec_tag = tag ; st -> codecpar -> codec_id = ff_codec_get_id ( ff_codec_bmp_tags , tag ) ; size_bmp = FFMAX ( size_asf , size_bmp ) ; <S2SV_StartBug> if ( size_bmp > BMP_HEADER_SIZE ) { <S2SV_EndBug> int ret ; st -> codecpar -> extradata_size = size_bmp - BMP_HEADER_SIZE ; if ( ! ( st -> codecpar -> extradata = av_malloc ( st -> codecpar -> extradata_size + AV_INPUT_BUFFER_PADDING_SIZE ) ) ) { st -> codecpar -> extradata_size = 0 ; return AVERROR ( ENOMEM ) ; } memset ( st -> codecpar -> extradata + st -> codecpar -> extradata_size , 0 , AV_INPUT_BUFFER_PADDING_SIZE ) ; if ( ( ret = avio_read ( pb , st -> codecpar -> extradata , st -> codecpar -> extradata_size ) ) < 0 ) return ret ; } return 0 ; }\n","target":"<S2SV_ModStart> size_bmp > BMP_HEADER_SIZE && size_bmp < INT_MAX - AV_INPUT_BUFFER_PADDING_SIZE\n","project_and_commit_id":"FFmpeg@FFmpeg/2b46ebdbff1d8dec7a3d8ea280a612b91a582869","cve_id":"CVE-2018-1999011","original_address":"https://github.com/FFmpeg/FFmpeg/commit/2b46ebdbff1d8dec7a3d8ea280a612b91a582869","time":"2018-07-23T15:29Z"},
	{"Unnamed: 0":6232,"cwe_id":"CWE-119","source":"CWE-119 <S2SV_StartBug> static void encode_txfm_probs ( VP9_COMMON * cm , vp9_writer * w ) { <S2SV_EndBug> vp9_write_literal ( w , MIN ( cm -> tx_mode , ALLOW_32X32 ) , 2 ) ; if ( cm -> tx_mode >= ALLOW_32X32 ) <S2SV_StartBug> vp9_write_bit ( w , cm -> tx_mode == TX_MODE_SELECT ) ; <S2SV_EndBug> if ( cm -> tx_mode == TX_MODE_SELECT ) { int i , j ; unsigned int ct_8x8p [ TX_SIZES - 3 ] [ 2 ] ; unsigned int ct_16x16p [ TX_SIZES - 2 ] [ 2 ] ; unsigned int ct_32x32p [ TX_SIZES - 1 ] [ 2 ] ; for ( i = 0 ; i < TX_SIZE_CONTEXTS ; i ++ ) { <S2SV_StartBug> tx_counts_to_branch_counts_8x8 ( cm -> counts . tx . p8x8 [ i ] , ct_8x8p ) ; <S2SV_EndBug> for ( j = 0 ; j < TX_SIZES - 3 ; j ++ ) <S2SV_StartBug> vp9_cond_prob_diff_update ( w , & cm -> fc . tx_probs . p8x8 [ i ] [ j ] , ct_8x8p [ j ] ) ; <S2SV_EndBug> } for ( i = 0 ; i < TX_SIZE_CONTEXTS ; i ++ ) { <S2SV_StartBug> tx_counts_to_branch_counts_16x16 ( cm -> counts . tx . p16x16 [ i ] , ct_16x16p ) ; <S2SV_EndBug> for ( j = 0 ; j < TX_SIZES - 2 ; j ++ ) <S2SV_StartBug> vp9_cond_prob_diff_update ( w , & cm -> fc . tx_probs . p16x16 [ i ] [ j ] , <S2SV_EndBug> ct_16x16p [ j ] ) ; } for ( i = 0 ; i < TX_SIZE_CONTEXTS ; i ++ ) { <S2SV_StartBug> tx_counts_to_branch_counts_32x32 ( cm -> counts . tx . p32x32 [ i ] , ct_32x32p ) ; <S2SV_EndBug> for ( j = 0 ; j < TX_SIZES - 1 ; j ++ ) <S2SV_StartBug> vp9_cond_prob_diff_update ( w , & cm -> fc . tx_probs . p32x32 [ i ] [ j ] , <S2SV_EndBug> ct_32x32p [ j ] ) ; } } }\n","target":"<S2SV_ModStart> * cm , vpx_writer * w , FRAME_COUNTS * counts ) { vpx_write_literal <S2SV_ModEnd> ( w , <S2SV_ModStart> >= ALLOW_32X32 ) vpx_write_bit <S2SV_ModEnd> ( w , <S2SV_ModStart> { tx_counts_to_branch_counts_8x8 ( counts -> <S2SV_ModEnd> tx . p8x8 <S2SV_ModStart> cm -> fc -> <S2SV_ModEnd> tx_probs . p8x8 <S2SV_ModStart> { tx_counts_to_branch_counts_16x16 ( counts -> <S2SV_ModEnd> tx . p16x16 <S2SV_ModStart> cm -> fc -> <S2SV_ModEnd> tx_probs . p16x16 <S2SV_ModStart> { tx_counts_to_branch_counts_32x32 ( counts -> <S2SV_ModEnd> tx . p32x32 <S2SV_ModStart> cm -> fc -> <S2SV_ModEnd> tx_probs . p32x32\n","project_and_commit_id":"external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426","cve_id":"CVE-2016-1621","original_address":"https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426","time":"2016-03-12T21:59Z"},
	{"Unnamed: 0":3866,"cwe_id":"CWE-787","source":"CWE-787 int jbig2_image_compose ( Jbig2Ctx * ctx , Jbig2Image * dst , Jbig2Image * src , int x , int y , Jbig2ComposeOp op ) { uint32_t w , h ; uint32_t shift ; uint32_t leftbyte ; uint8_t * ss ; uint8_t * dd ; uint8_t leftmask , rightmask ; int early = x >= 0 ; int late ; uint32_t bytewidth ; uint32_t syoffset = 0 ; if ( src == NULL ) <S2SV_StartBug> return 0 ; <S2SV_EndBug> w = src -> width ; h = src -> height ; shift = ( x & 7 ) ; ss = src -> data - early ; if ( x < 0 ) { if ( w < ( uint32_t ) - x ) w = 0 ; else w += x ; ss += ( - x - 1 ) >> 3 ; x = 0 ; } if ( y < 0 ) { if ( h < ( uint32_t ) - y ) h = 0 ; else h += y ; syoffset = - y * src -> stride ; y = 0 ; } if ( ( uint32_t ) x + w > dst -> width ) { if ( dst -> width < ( uint32_t ) x ) w = 0 ; else w = dst -> width - x ; } if ( ( uint32_t ) y + h > dst -> height ) { if ( dst -> height < ( uint32_t ) y ) h = 0 ; else h = dst -> height - y ; } # ifdef JBIG2_DEBUG jbig2_error ( ctx , JBIG2_SEVERITY_DEBUG , - 1 , \"compositing<S2SV_blank>%dx%d<S2SV_blank>at<S2SV_blank>(%d,<S2SV_blank>%d)<S2SV_blank>after<S2SV_blank>clipping\" , w , h , x , y ) ; # endif if ( ( w <= 0 ) || ( h <= 0 ) ) { # ifdef JBIG2_DEBUG jbig2_error ( ctx , JBIG2_SEVERITY_DEBUG , - 1 , \"zero<S2SV_blank>clipping<S2SV_blank>region\" ) ; # endif return 0 ; } leftbyte = ( uint32_t ) x >> 3 ; dd = dst -> data + y * dst -> stride + leftbyte ; bytewidth = ( ( ( uint32_t ) x + w - 1 ) >> 3 ) - leftbyte + 1 ; leftmask = 255 >> ( x & 7 ) ; rightmask = ( ( ( x + w ) & 7 ) == 0 ) ? 255 : ~ ( 255 >> ( ( x + w ) & 7 ) ) ; if ( bytewidth == 1 ) leftmask &= rightmask ; late = ( ss + bytewidth >= src -> data + ( ( src -> width + 7 ) >> 3 ) ) ; ss += syoffset ; switch ( op ) { case JBIG2_COMPOSE_OR : jbig2_image_compose_opt_OR ( ss , dd , early , late , leftmask , rightmask , bytewidth , h , shift , dst -> stride , src -> stride ) ; break ; case JBIG2_COMPOSE_AND : jbig2_image_compose_opt_AND ( ss , dd , early , late , leftmask , rightmask , bytewidth , h , shift , dst -> stride , src -> stride ) ; break ; case JBIG2_COMPOSE_XOR : jbig2_image_compose_opt_XOR ( ss , dd , early , late , leftmask , rightmask , bytewidth , h , shift , dst -> stride , src -> stride ) ; break ; case JBIG2_COMPOSE_XNOR : jbig2_image_compose_opt_XNOR ( ss , dd , early , late , leftmask , rightmask , bytewidth , h , shift , dst -> stride , src -> stride ) ; break ; case JBIG2_COMPOSE_REPLACE : jbig2_image_compose_opt_REPLACE ( ss , dd , early , late , leftmask , rightmask , bytewidth , h , shift , dst -> stride , src -> stride ) ; break ; } return 0 ; }\n","target":"<S2SV_ModStart> return 0 ; if ( ( UINT32_MAX - src -> width < ( x > 0 ? x : - x ) ) || ( UINT32_MAX - src -> height < ( y > 0 ? y : - y ) ) ) { # ifdef JBIG2_DEBUG jbig2_error ( ctx , JBIG2_SEVERITY_DEBUG , - 1 , \"overflow<S2SV_blank>in<S2SV_blank>compose_image\" ) ; # endif return 0 ; }\n","project_and_commit_id":"ArtifexSoftware@jbig2dec/0726320a4b55078e9d8deb590e477d598b3da66e","cve_id":"CVE-2020-12268","original_address":"https://github.com/ArtifexSoftware/jbig2dec/commit/0726320a4b55078e9d8deb590e477d598b3da66e","time":"2020-04-27T02:15Z"},
	{"Unnamed: 0":1258,"cwe_id":"CWE-200","source":"CWE-200 static Image * ReadMATImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { Image * image , * image2 = NULL , * rotated_image ; register Quantum * q ; unsigned int status ; MATHeader MATLAB_HDR ; size_t size ; size_t CellType ; QuantumInfo * quantum_info ; ImageInfo * clone_info ; int i ; ssize_t ldblk ; unsigned char * BImgBuff = NULL ; double MinVal , MaxVal ; unsigned z , z2 ; unsigned Frames ; int logging ; int sample_size ; MagickOffsetType filepos = 0x80 ; BlobInfo * blob ; size_t one ; unsigned int ( * ReadBlobXXXLong ) ( Image * image ) ; unsigned short ( * ReadBlobXXXShort ) ( Image * image ) ; void ( * ReadBlobDoublesXXX ) ( Image * image , size_t len , double * data ) ; void ( * ReadBlobFloatsXXX ) ( Image * image , size_t len , float * data ) ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickCoreSignature ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickCoreSignature ) ; logging = LogMagickEvent ( CoderEvent , GetMagickModule ( ) , \"enter\" ) ; image = AcquireImage ( image_info , exception ) ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } clone_info = CloneImageInfo ( image_info ) ; if ( ReadBlob ( image , 124 , ( unsigned char * ) & MATLAB_HDR . identific ) != 124 ) ThrowReaderException ( CorruptImageError , \"ImproperImageHeader\" ) ; if ( strncmp ( MATLAB_HDR . identific , \"MATLAB\" , 6 ) != 0 ) { image2 = ReadMATImageV4 ( image_info , image , exception ) ; if ( image2 == NULL ) goto MATLAB_KO ; image = image2 ; goto END_OF_READING ; } MATLAB_HDR . Version = ReadBlobLSBShort ( image ) ; if ( ReadBlob ( image , 2 , ( unsigned char * ) & MATLAB_HDR . EndianIndicator ) != 2 ) ThrowReaderException ( CorruptImageError , \"ImproperImageHeader\" ) ; if ( logging ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , \"<S2SV_blank><S2SV_blank>Endian<S2SV_blank>%c%c\" , MATLAB_HDR . EndianIndicator [ 0 ] , MATLAB_HDR . EndianIndicator [ 1 ] ) ; if ( ! strncmp ( MATLAB_HDR . EndianIndicator , \"IM\" , 2 ) ) { ReadBlobXXXLong = ReadBlobLSBLong ; ReadBlobXXXShort = ReadBlobLSBShort ; ReadBlobDoublesXXX = ReadBlobDoublesLSB ; ReadBlobFloatsXXX = ReadBlobFloatsLSB ; image -> endian = LSBEndian ; } else if ( ! strncmp ( MATLAB_HDR . EndianIndicator , \"MI\" , 2 ) ) { ReadBlobXXXLong = ReadBlobMSBLong ; ReadBlobXXXShort = ReadBlobMSBShort ; ReadBlobDoublesXXX = ReadBlobDoublesMSB ; ReadBlobFloatsXXX = ReadBlobFloatsMSB ; image -> endian = MSBEndian ; } else goto MATLAB_KO ; if ( strncmp ( MATLAB_HDR . identific , \"MATLAB\" , 6 ) ) MATLAB_KO : ThrowReaderException ( CorruptImageError , \"ImproperImageHeader\" ) ; filepos = TellBlob ( image ) ; while ( ! EOFBlob ( image ) ) { Frames = 1 ; ( void ) SeekBlob ( image , filepos , SEEK_SET ) ; MATLAB_HDR . DataType = ReadBlobXXXLong ( image ) ; if ( EOFBlob ( image ) ) break ; MATLAB_HDR . ObjectSize = ReadBlobXXXLong ( image ) ; if ( EOFBlob ( image ) ) break ; filepos += MATLAB_HDR . ObjectSize + 4 + 4 ; image2 = image ; # if defined ( MAGICKCORE_ZLIB_DELEGATE ) if ( MATLAB_HDR . DataType == miCOMPRESSED ) { image2 = DecompressBlock ( image , MATLAB_HDR . ObjectSize , clone_info , exception ) ; if ( image2 == NULL ) continue ; MATLAB_HDR . DataType = ReadBlobXXXLong ( image2 ) ; } # endif if ( MATLAB_HDR . DataType != miMATRIX ) continue ; MATLAB_HDR . unknown1 = ReadBlobXXXLong ( image2 ) ; MATLAB_HDR . unknown2 = ReadBlobXXXLong ( image2 ) ; MATLAB_HDR . unknown5 = ReadBlobXXXLong ( image2 ) ; MATLAB_HDR . StructureClass = MATLAB_HDR . unknown5 & 0xFF ; MATLAB_HDR . StructureFlag = ( MATLAB_HDR . unknown5 >> 8 ) & 0xFF ; MATLAB_HDR . unknown3 = ReadBlobXXXLong ( image2 ) ; if ( image != image2 ) MATLAB_HDR . unknown4 = ReadBlobXXXLong ( image2 ) ; MATLAB_HDR . unknown4 = ReadBlobXXXLong ( image2 ) ; MATLAB_HDR . DimFlag = ReadBlobXXXLong ( image2 ) ; MATLAB_HDR . SizeX = ReadBlobXXXLong ( image2 ) ; MATLAB_HDR . SizeY = ReadBlobXXXLong ( image2 ) ; switch ( MATLAB_HDR . DimFlag ) { case 8 : z2 = z = 1 ; break ; case 12 : z2 = z = ReadBlobXXXLong ( image2 ) ; ( void ) ReadBlobXXXLong ( image2 ) ; if ( z != 3 ) ThrowReaderException ( CoderError , \"MultidimensionalMatricesAreNotSupported\" ) ; break ; case 16 : z2 = z = ReadBlobXXXLong ( image2 ) ; if ( z != 3 && z != 1 ) ThrowReaderException ( CoderError , \"MultidimensionalMatricesAreNotSupported\" ) ; Frames = ReadBlobXXXLong ( image2 ) ; if ( Frames == 0 ) ThrowReaderException ( CorruptImageError , \"ImproperImageHeader\" ) ; break ; default : ThrowReaderException ( CoderError , \"MultidimensionalMatricesAreNotSupported\" ) ; } MATLAB_HDR . Flag1 = ReadBlobXXXShort ( image2 ) ; MATLAB_HDR . NameFlag = ReadBlobXXXShort ( image2 ) ; if ( logging ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , \"MATLAB_HDR.StructureClass<S2SV_blank>%d\" , MATLAB_HDR . StructureClass ) ; if ( MATLAB_HDR . StructureClass != mxCHAR_CLASS && MATLAB_HDR . StructureClass != mxSINGLE_CLASS && MATLAB_HDR . StructureClass != mxDOUBLE_CLASS && MATLAB_HDR . StructureClass != mxINT8_CLASS && MATLAB_HDR . StructureClass != mxUINT8_CLASS && MATLAB_HDR . StructureClass != mxINT16_CLASS && MATLAB_HDR . StructureClass != mxUINT16_CLASS && MATLAB_HDR . StructureClass != mxINT32_CLASS && MATLAB_HDR . StructureClass != mxUINT32_CLASS && MATLAB_HDR . StructureClass != mxINT64_CLASS && MATLAB_HDR . StructureClass != mxUINT64_CLASS ) ThrowReaderException ( CoderError , \"UnsupportedCellTypeInTheMatrix\" ) ; switch ( MATLAB_HDR . NameFlag ) { case 0 : size = ReadBlobXXXLong ( image2 ) ; size = 4 * ( ssize_t ) ( ( size + 3 + 1 ) / 4 ) ; ( void ) SeekBlob ( image2 , size , SEEK_CUR ) ; break ; case 1 : case 2 : case 3 : case 4 : ( void ) ReadBlob ( image2 , 4 , ( unsigned char * ) & size ) ; break ; default : goto MATLAB_KO ; } CellType = ReadBlobXXXLong ( image2 ) ; if ( logging ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , \"MATLAB_HDR.CellType:<S2SV_blank>%.20g\" , ( double ) CellType ) ; ( void ) ReadBlob ( image2 , 4 , ( unsigned char * ) & size ) ; NEXT_FRAME : switch ( CellType ) { case miINT8 : case miUINT8 : sample_size = 8 ; if ( MATLAB_HDR . StructureFlag & FLAG_LOGICAL ) image -> depth = 1 ; else image -> depth = 8 ; ldblk = ( ssize_t ) MATLAB_HDR . SizeX ; break ; case miINT16 : case miUINT16 : sample_size = 16 ; image -> depth = 16 ; ldblk = ( ssize_t ) ( 2 * MATLAB_HDR . SizeX ) ; break ; case miINT32 : case miUINT32 : sample_size = 32 ; image -> depth = 32 ; ldblk = ( ssize_t ) ( 4 * MATLAB_HDR . SizeX ) ; break ; case miINT64 : case miUINT64 : sample_size = 64 ; image -> depth = 64 ; ldblk = ( ssize_t ) ( 8 * MATLAB_HDR . SizeX ) ; break ; case miSINGLE : sample_size = 32 ; image -> depth = 32 ; ( void ) SetImageOption ( clone_info , \"quantum:format\" , \"floating-point\" ) ; if ( MATLAB_HDR . StructureFlag & FLAG_COMPLEX ) { } ldblk = ( ssize_t ) ( 4 * MATLAB_HDR . SizeX ) ; break ; case miDOUBLE : sample_size = 64 ; image -> depth = 64 ; ( void ) SetImageOption ( clone_info , \"quantum:format\" , \"floating-point\" ) ; DisableMSCWarning ( 4127 ) if ( sizeof ( double ) != 8 ) RestoreMSCWarning ThrowReaderException ( CoderError , \"IncompatibleSizeOfDouble\" ) ; if ( MATLAB_HDR . StructureFlag & FLAG_COMPLEX ) { } ldblk = ( ssize_t ) ( 8 * MATLAB_HDR . SizeX ) ; break ; default : ThrowReaderException ( CoderError , \"UnsupportedCellTypeInTheMatrix\" ) ; } ( void ) sample_size ; image -> columns = MATLAB_HDR . SizeX ; image -> rows = MATLAB_HDR . SizeY ; quantum_info = AcquireQuantumInfo ( clone_info , image ) ; if ( quantum_info == ( QuantumInfo * ) NULL ) ThrowReaderException ( ResourceLimitError , \"MemoryAllocationFailed\" ) ; one = 1 ; image -> colors = one << image -> depth ; if ( image -> columns == 0 || image -> rows == 0 ) goto MATLAB_KO ; if ( ( MATLAB_HDR . DimFlag == 8 ) && ( ( MATLAB_HDR . StructureFlag & FLAG_COMPLEX ) == 0 ) ) { image -> type = GrayscaleType ; SetImageColorspace ( image , GRAYColorspace , exception ) ; } if ( image_info -> ping ) { size_t temp = image -> columns ; image -> columns = image -> rows ; image -> rows = temp ; goto done_reading ; } status = SetImageExtent ( image , image -> columns , image -> rows , exception ) ; if ( status == MagickFalse ) return ( DestroyImageList ( image ) ) ; BImgBuff = ( unsigned char * ) AcquireQuantumMemory ( ( size_t ) ( ldblk ) , sizeof ( double ) ) ; if ( BImgBuff == NULL ) ThrowReaderException ( ResourceLimitError , \"MemoryAllocationFailed\" ) ; <S2SV_StartBug> MinVal = 0 ; <S2SV_EndBug> MaxVal = 0 ; if ( CellType == miDOUBLE || CellType == miSINGLE ) { CalcMinMax ( image2 , image_info -> endian , MATLAB_HDR . SizeX , MATLAB_HDR . SizeY , CellType , ldblk , BImgBuff , & quantum_info -> minimum , & quantum_info -> maximum ) ; } if ( z == 1 ) z = 0 ; do { for ( i = 0 ; i < ( ssize_t ) MATLAB_HDR . SizeY ; i ++ ) { q = GetAuthenticPixels ( image , 0 , MATLAB_HDR . SizeY - i - 1 , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) { if ( logging ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , \"<S2SV_blank><S2SV_blank>MAT<S2SV_blank>set<S2SV_blank>image<S2SV_blank>pixels<S2SV_blank>returns<S2SV_blank>unexpected<S2SV_blank>NULL<S2SV_blank>on<S2SV_blank>a<S2SV_blank>row<S2SV_blank>%u.\" , ( unsigned ) ( MATLAB_HDR . SizeY - i - 1 ) ) ; goto done_reading ; } if ( ReadBlob ( image2 , ldblk , ( unsigned char * ) BImgBuff ) != ( ssize_t ) ldblk ) { if ( logging ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , \"<S2SV_blank><S2SV_blank>MAT<S2SV_blank>cannot<S2SV_blank>read<S2SV_blank>scanrow<S2SV_blank>%u<S2SV_blank>from<S2SV_blank>a<S2SV_blank>file.\" , ( unsigned ) ( MATLAB_HDR . SizeY - i - 1 ) ) ; goto ExitLoop ; } if ( ( CellType == miINT8 || CellType == miUINT8 ) && ( MATLAB_HDR . StructureFlag & FLAG_LOGICAL ) ) { FixLogical ( ( unsigned char * ) BImgBuff , ldblk ) ; if ( ImportQuantumPixels ( image , ( CacheView * ) NULL , quantum_info , z2qtype [ z ] , BImgBuff , exception ) <= 0 ) { ImportQuantumPixelsFailed : if ( logging ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , \"<S2SV_blank><S2SV_blank>MAT<S2SV_blank>failed<S2SV_blank>to<S2SV_blank>ImportQuantumPixels<S2SV_blank>for<S2SV_blank>a<S2SV_blank>row<S2SV_blank>%u\" , ( unsigned ) ( MATLAB_HDR . SizeY - i - 1 ) ) ; break ; } } else { if ( ImportQuantumPixels ( image , ( CacheView * ) NULL , quantum_info , z2qtype [ z ] , BImgBuff , exception ) <= 0 ) goto ImportQuantumPixelsFailed ; if ( z <= 1 && ( CellType == miINT8 || CellType == miINT16 || CellType == miINT32 || CellType == miINT64 ) ) FixSignedValues ( image , q , MATLAB_HDR . SizeX ) ; } if ( ! SyncAuthenticPixels ( image , exception ) ) { if ( logging ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , \"<S2SV_blank><S2SV_blank>MAT<S2SV_blank>failed<S2SV_blank>to<S2SV_blank>sync<S2SV_blank>image<S2SV_blank>pixels<S2SV_blank>for<S2SV_blank>a<S2SV_blank>row<S2SV_blank>%u\" , ( unsigned ) ( MATLAB_HDR . SizeY - i - 1 ) ) ; goto ExitLoop ; } } } while ( z -- >= 2 ) ; quantum_info = DestroyQuantumInfo ( quantum_info ) ; ExitLoop : if ( MATLAB_HDR . StructureFlag & FLAG_COMPLEX ) { CellType = ReadBlobXXXLong ( image2 ) ; i = ReadBlobXXXLong ( image2 ) ; if ( CellType == miDOUBLE || CellType == miSINGLE ) { CalcMinMax ( image2 , image_info -> endian , MATLAB_HDR . SizeX , MATLAB_HDR . SizeY , CellType , ldblk , BImgBuff , & MinVal , & MaxVal ) ; } if ( CellType == miDOUBLE ) for ( i = 0 ; i < ( ssize_t ) MATLAB_HDR . SizeY ; i ++ ) { ReadBlobDoublesXXX ( image2 , ldblk , ( double * ) BImgBuff ) ; InsertComplexDoubleRow ( image , ( double * ) BImgBuff , i , MinVal , MaxVal , exception ) ; } if ( CellType == miSINGLE ) for ( i = 0 ; i < ( ssize_t ) MATLAB_HDR . SizeY ; i ++ ) { ReadBlobFloatsXXX ( image2 , ldblk , ( float * ) BImgBuff ) ; InsertComplexFloatRow ( image , ( float * ) BImgBuff , i , MinVal , MaxVal , exception ) ; } } if ( ( MATLAB_HDR . DimFlag == 8 ) && ( ( MATLAB_HDR . StructureFlag & FLAG_COMPLEX ) == 0 ) ) image -> type = GrayscaleType ; if ( image -> depth == 1 ) image -> type = BilevelType ; if ( image2 == image ) image2 = NULL ; rotated_image = RotateImage ( image , 90.0 , exception ) ; if ( rotated_image != ( Image * ) NULL ) { rotated_image -> page . x = 0 ; rotated_image -> page . y = 0 ; blob = rotated_image -> blob ; rotated_image -> blob = image -> blob ; rotated_image -> colors = image -> colors ; image -> blob = blob ; AppendImageToList ( & image , rotated_image ) ; DeleteImageFromList ( & image ) ; } done_reading : if ( image2 != NULL ) if ( image2 != image ) { DeleteImageFromList ( & image2 ) ; if ( clone_info ) { if ( clone_info -> file ) { fclose ( clone_info -> file ) ; clone_info -> file = NULL ; ( void ) remove_utf8 ( clone_info -> filename ) ; } } } AcquireNextImage ( image_info , image , exception ) ; if ( image -> next == ( Image * ) NULL ) break ; image = SyncNextImageInList ( image ) ; image -> columns = image -> rows = 0 ; image -> colors = 0 ; RelinquishMagickMemory ( BImgBuff ) ; BImgBuff = NULL ; if ( -- Frames > 0 ) { z = z2 ; if ( image2 == NULL ) image2 = image ; goto NEXT_FRAME ; } if ( ( image2 != NULL ) && ( image2 != image ) ) { DeleteImageFromList ( & image2 ) ; if ( clone_info ) { if ( clone_info -> file ) { fclose ( clone_info -> file ) ; clone_info -> file = NULL ; ( void ) remove_utf8 ( clone_info -> filename ) ; } } } } RelinquishMagickMemory ( BImgBuff ) ; END_OF_READING : clone_info = DestroyImageInfo ( clone_info ) ; CloseBlob ( image ) ; { Image * p ; ssize_t scene = 0 ; p = image ; image = NULL ; while ( p != ( Image * ) NULL ) { Image * tmp = p ; if ( ( p -> rows == 0 ) || ( p -> columns == 0 ) ) { p = p -> previous ; DeleteImageFromList ( & tmp ) ; } else { image = p ; p = p -> previous ; } } for ( p = image ; p != ( Image * ) NULL ; p = p -> next ) p -> scene = scene ++ ; } if ( clone_info != NULL ) { if ( clone_info -> file ) { fclose ( clone_info -> file ) ; clone_info -> file = NULL ; ( void ) remove_utf8 ( clone_info -> filename ) ; } DestroyImageInfo ( clone_info ) ; clone_info = NULL ; } if ( logging ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , \"return\" ) ; if ( image == NULL ) ThrowReaderException ( CorruptImageError , \"ImproperImageHeader\" ) ; return ( image ) ; }\n","target":"<S2SV_ModStart> \"MemoryAllocationFailed\" ) ; ( void ) ResetMagickMemory ( BImgBuff , 0 , ldblk * sizeof ( double ) ) ;\n","project_and_commit_id":"ImageMagick@ImageMagick/51b0ae01709adc1e4a9245e158ef17b85a110960","cve_id":"CVE-2017-13143","original_address":"https://github.com/ImageMagick/ImageMagick/commit/51b0ae01709adc1e4a9245e158ef17b85a110960","time":"2017-08-23T06:29Z"},
	{"Unnamed: 0":2892,"cwe_id":"CWE-59","source":"CWE-59 static int get_default_root ( pool * p , int allow_symlinks , char * * root ) { config_rec * c = NULL ; char * dir = NULL ; int res ; c = find_config ( main_server -> conf , CONF_PARAM , \"DefaultRoot\" , FALSE ) ; while ( c ) { pr_signals_handle ( ) ; if ( c -> argc < 2 ) { dir = c -> argv [ 0 ] ; break ; } res = pr_expr_eval_group_and ( ( ( char * * ) c -> argv ) + 1 ) ; if ( res ) { dir = c -> argv [ 0 ] ; break ; } c = find_config_next ( c , c -> next , CONF_PARAM , \"DefaultRoot\" , FALSE ) ; } if ( dir ) { char * new_dir ; new_dir = path_subst_uservar ( p , & dir ) ; if ( new_dir != NULL ) { dir = new_dir ; } if ( strncmp ( dir , \"/\" , 2 ) == 0 ) { dir = NULL ; } else { char * realdir ; int xerrno = 0 ; if ( allow_symlinks == FALSE ) { char * path , target_path [ PR_TUNABLE_PATH_MAX + 1 ] ; <S2SV_StartBug> struct stat st ; <S2SV_EndBug> size_t pathlen ; path = dir ; if ( * path != '/' ) { if ( * path == '~' ) { if ( pr_fs_interpolate ( dir , target_path , sizeof ( target_path ) - 1 ) < 0 ) { return - 1 ; } path = target_path ; } } pathlen = strlen ( path ) ; if ( pathlen > 1 && path [ pathlen - 1 ] == '/' ) { path [ pathlen - 1 ] = '\\\\0' ; } <S2SV_StartBug> pr_fs_clear_cache ( ) ; <S2SV_EndBug> res = pr_fsio_lstat ( path , & st ) ; if ( res < 0 ) { <S2SV_StartBug> xerrno = errno ; <S2SV_EndBug> <S2SV_StartBug> pr_log_pri ( PR_LOG_WARNING , \"error:<S2SV_blank>unable<S2SV_blank>to<S2SV_blank>check<S2SV_blank>%s:<S2SV_blank>%s\" , path , <S2SV_EndBug> strerror ( xerrno ) ) ; errno = xerrno ; return - 1 ; } if ( S_ISLNK ( st . st_mode ) ) { pr_log_pri ( PR_LOG_WARNING , \"error:<S2SV_blank>DefaultRoot<S2SV_blank>%s<S2SV_blank>is<S2SV_blank>a<S2SV_blank>symlink<S2SV_blank>(denied<S2SV_blank>by<S2SV_blank>AllowChrootSymlinks<S2SV_blank>\" \"config)\" , path ) ; errno = EPERM ; return - 1 ; } } PRIVS_USER realdir = dir_realpath ( p , dir ) ; xerrno = errno ; PRIVS_RELINQUISH if ( realdir ) { dir = realdir ; } else { char interp_dir [ PR_TUNABLE_PATH_MAX + 1 ] ; memset ( interp_dir , '\\\\0' , sizeof ( interp_dir ) ) ; ( void ) pr_fs_interpolate ( dir , interp_dir , sizeof ( interp_dir ) - 1 ) ; pr_log_pri ( PR_LOG_NOTICE , \"notice:<S2SV_blank>unable<S2SV_blank>to<S2SV_blank>use<S2SV_blank>DefaultRoot<S2SV_blank>\\'%s\\'<S2SV_blank>[resolved<S2SV_blank>to<S2SV_blank>\\'%s\\']:<S2SV_blank>%s\" , dir , interp_dir , strerror ( xerrno ) ) ; errno = xerrno ; } } } * root = dir ; return 0 ; }\n","target":"<S2SV_ModStart> 1 ] ; <S2SV_ModEnd> size_t pathlen ; <S2SV_ModStart> '\\\\0' ; } res = is_symlink_path ( p , path , pathlen <S2SV_ModEnd> ) ; if <S2SV_ModStart> 0 ) { if ( errno == EPERM ) { <S2SV_ModEnd> pr_log_pri ( PR_LOG_WARNING <S2SV_ModStart> ( PR_LOG_WARNING , \"error:<S2SV_blank>DefaultRoot<S2SV_blank>%s<S2SV_blank>is<S2SV_blank>a<S2SV_blank>symlink<S2SV_blank>\" \"(denied<S2SV_blank>by<S2SV_blank>AllowChrootSymlinks<S2SV_blank>config)\" , path ) ; } <S2SV_ModEnd> errno = EPERM\n","project_and_commit_id":"proftpd@proftpd/ecff21e0d0e84f35c299ef91d7fda088e516d4ed","cve_id":"CVE-2017-7418","original_address":"https://github.com/proftpd/proftpd/commit/ecff21e0d0e84f35c299ef91d7fda088e516d4ed","time":"2017-04-04T17:59Z"},
	{"Unnamed: 0":3779,"cwe_id":"CWE-200","source":"CWE-200 static int sco_sock_recvmsg ( struct kiocb * iocb , struct socket * sock , struct msghdr * msg , size_t len , int flags ) { struct sock * sk = sock -> sk ; struct sco_pinfo * pi = sco_pi ( sk ) ; lock_sock ( sk ) ; if ( sk -> sk_state == BT_CONNECT2 && test_bit ( BT_SK_DEFER_SETUP , & bt_sk ( sk ) -> flags ) ) { hci_conn_accept ( pi -> conn -> hcon , 0 ) ; sk -> sk_state = BT_CONFIG ; <S2SV_StartBug> release_sock ( sk ) ; <S2SV_EndBug> return 0 ; } release_sock ( sk ) ; return bt_sock_recvmsg ( iocb , sock , msg , len , flags ) ; }\n","target":"<S2SV_ModStart> = BT_CONFIG ; msg -> msg_namelen = 0 ;\n","project_and_commit_id":"torvalds@linux/c8c499175f7d295ef867335bceb9a76a2c3cdc38","cve_id":"CVE-2013-3226","original_address":"https://github.com/torvalds/linux/commit/c8c499175f7d295ef867335bceb9a76a2c3cdc38","time":"2013-04-22T11:41Z"},
	{"Unnamed: 0":3472,"cwe_id":"CWE-732","source":"CWE-732 int config__parse_args ( struct mosquitto_db * db , struct mosquitto__config * config , int argc , char * argv [ ] ) { int i ; int port_tmp ; for ( i = 1 ; i < argc ; i ++ ) { if ( ! strcmp ( argv [ i ] , \"-c\" ) || ! strcmp ( argv [ i ] , \"--config-file\" ) ) { if ( i < argc - 1 ) { db -> config_file = argv [ i + 1 ] ; if ( config__read ( db , config , false ) ) { log__printf ( NULL , MOSQ_LOG_ERR , \"Error:<S2SV_blank>Unable<S2SV_blank>to<S2SV_blank>open<S2SV_blank>configuration<S2SV_blank>file.\" ) ; return MOSQ_ERR_INVAL ; } } else { log__printf ( NULL , MOSQ_LOG_ERR , \"Error:<S2SV_blank>-c<S2SV_blank>argument<S2SV_blank>given,<S2SV_blank>but<S2SV_blank>no<S2SV_blank>config<S2SV_blank>file<S2SV_blank>specified.\" ) ; return MOSQ_ERR_INVAL ; } i ++ ; } else if ( ! strcmp ( argv [ i ] , \"-d\" ) || ! strcmp ( argv [ i ] , \"--daemon\" ) ) { config -> daemon = true ; } else if ( ! strcmp ( argv [ i ] , \"-h\" ) || ! strcmp ( argv [ i ] , \"--help\" ) ) { print_usage ( ) ; return MOSQ_ERR_INVAL ; } else if ( ! strcmp ( argv [ i ] , \"-p\" ) || ! strcmp ( argv [ i ] , \"--port\" ) ) { if ( i < argc - 1 ) { port_tmp = atoi ( argv [ i + 1 ] ) ; if ( port_tmp < 1 || port_tmp > 65535 ) { log__printf ( NULL , MOSQ_LOG_ERR , \"Error:<S2SV_blank>Invalid<S2SV_blank>port<S2SV_blank>specified<S2SV_blank>(%d).\" , port_tmp ) ; return MOSQ_ERR_INVAL ; } else { if ( config -> default_listener . port ) { log__printf ( NULL , MOSQ_LOG_WARNING , \"Warning:<S2SV_blank>Default<S2SV_blank>listener<S2SV_blank>port<S2SV_blank>specified<S2SV_blank>multiple<S2SV_blank>times.<S2SV_blank>Only<S2SV_blank>the<S2SV_blank>latest<S2SV_blank>will<S2SV_blank>be<S2SV_blank>used.\" ) ; } config -> default_listener . port = port_tmp ; } } else { log__printf ( NULL , MOSQ_LOG_ERR , \"Error:<S2SV_blank>-p<S2SV_blank>argument<S2SV_blank>given,<S2SV_blank>but<S2SV_blank>no<S2SV_blank>port<S2SV_blank>specified.\" ) ; return MOSQ_ERR_INVAL ; } i ++ ; } else if ( ! strcmp ( argv [ i ] , \"-v\" ) || ! strcmp ( argv [ i ] , \"--verbose\" ) ) { db -> verbose = true ; } else { fprintf ( stderr , \"Error:<S2SV_blank>Unknown<S2SV_blank>option<S2SV_blank>\\'%s\\'.\\\\n\" , argv [ i ] ) ; print_usage ( ) ; return MOSQ_ERR_INVAL ; } } if ( config -> listener_count == 0 # ifdef WITH_TLS || config -> default_listener . cafile || config -> default_listener . capath || config -> default_listener . certfile || config -> default_listener . keyfile || config -> default_listener . ciphers || config -> default_listener . psk_hint || config -> default_listener . require_certificate || config -> default_listener . crlfile || config -> default_listener . use_identity_as_username || config -> default_listener . use_subject_as_username # endif || config -> default_listener . use_username_as_clientid || config -> default_listener . host || config -> default_listener . port || config -> default_listener . max_connections != - 1 || config -> default_listener . mount_point || config -> default_listener . protocol != mp_mqtt || config -> default_listener . socket_domain || config -> default_listener . security_options . password_file || config -> default_listener . security_options . psk_file || config -> default_listener . security_options . auth_plugin_config_count || config -> default_listener . security_options . allow_anonymous != - 1 ) { config -> listener_count ++ ; config -> listeners = mosquitto__realloc ( config -> listeners , sizeof ( struct mosquitto__listener ) * config -> listener_count ) ; if ( ! config -> listeners ) { log__printf ( NULL , MOSQ_LOG_ERR , \"Error:<S2SV_blank>Out<S2SV_blank>of<S2SV_blank>memory.\" ) ; return MOSQ_ERR_NOMEM ; } memset ( & config -> listeners [ config -> listener_count - 1 ] , 0 , sizeof ( struct mosquitto__listener ) ) ; if ( config -> default_listener . port ) { config -> listeners [ config -> listener_count - 1 ] . port = config -> default_listener . port ; } else { config -> listeners [ config -> listener_count - 1 ] . port = 1883 ; } if ( config -> default_listener . host ) { config -> listeners [ config -> listener_count - 1 ] . host = config -> default_listener . host ; } else { config -> listeners [ config -> listener_count - 1 ] . host = NULL ; } if ( config -> default_listener . mount_point ) { config -> listeners [ config -> listener_count - 1 ] . mount_point = config -> default_listener . mount_point ; } else { config -> listeners [ config -> listener_count - 1 ] . mount_point = NULL ; } config -> listeners [ config -> listener_count - 1 ] . max_connections = config -> default_listener . max_connections ; config -> listeners [ config -> listener_count - 1 ] . protocol = config -> default_listener . protocol ; config -> listeners [ config -> listener_count - 1 ] . socket_domain = config -> default_listener . socket_domain ; config -> listeners [ config -> listener_count - 1 ] . client_count = 0 ; config -> listeners [ config -> listener_count - 1 ] . socks = NULL ; config -> listeners [ config -> listener_count - 1 ] . sock_count = 0 ; config -> listeners [ config -> listener_count - 1 ] . client_count = 0 ; config -> listeners [ config -> listener_count - 1 ] . use_username_as_clientid = config -> default_listener . use_username_as_clientid ; # ifdef WITH_TLS config -> listeners [ config -> listener_count - 1 ] . tls_version = config -> default_listener . tls_version ; config -> listeners [ config -> listener_count - 1 ] . cafile = config -> default_listener . cafile ; config -> listeners [ config -> listener_count - 1 ] . capath = config -> default_listener . capath ; config -> listeners [ config -> listener_count - 1 ] . certfile = config -> default_listener . certfile ; config -> listeners [ config -> listener_count - 1 ] . keyfile = config -> default_listener . keyfile ; config -> listeners [ config -> listener_count - 1 ] . ciphers = config -> default_listener . ciphers ; config -> listeners [ config -> listener_count - 1 ] . psk_hint = config -> default_listener . psk_hint ; config -> listeners [ config -> listener_count - 1 ] . require_certificate = config -> default_listener . require_certificate ; config -> listeners [ config -> listener_count - 1 ] . ssl_ctx = NULL ; config -> listeners [ config -> listener_count - 1 ] . crlfile = config -> default_listener . crlfile ; config -> listeners [ config -> listener_count - 1 ] . use_identity_as_username = config -> default_listener . use_identity_as_username ; config -> listeners [ config -> listener_count - 1 ] . use_subject_as_username = config -> default_listener . use_subject_as_username ; # endif <S2SV_StartBug> config -> listeners [ config -> listener_count - 1 ] . security_options . password_file = config -> default_listener . security_options . password_file ; <S2SV_EndBug> config -> listeners [ config -> listener_count - 1 ] . security_options . psk_file = config -> default_listener . security_options . psk_file ; config -> listeners [ config -> listener_count - 1 ] . security_options . auth_plugin_configs = config -> default_listener . security_options . auth_plugin_configs ; config -> listeners [ config -> listener_count - 1 ] . security_options . auth_plugin_config_count = config -> default_listener . security_options . auth_plugin_config_count ; config -> listeners [ config -> listener_count - 1 ] . security_options . allow_anonymous = config -> default_listener . security_options . allow_anonymous ; } if ( ! config -> user ) { config -> user = \"mosquitto\" ; } if ( db -> verbose ) { config -> log_type = INT_MAX ; } return config__check ( config ) ; }\n","target":"<S2SV_ModStart> . security_options . acl_file = config -> default_listener . security_options . acl_file ; config -> listeners [ config -> listener_count - 1 ] . security_options .\n","project_and_commit_id":"eclipse@mosquitto/9097577b49b7fdcf45d30975976dd93808ccc0c4","cve_id":"CVE-2018-20145","original_address":"https://github.com/eclipse/mosquitto/commit/9097577b49b7fdcf45d30975976dd93808ccc0c4","time":"2018-12-13T20:29Z"},
	{"Unnamed: 0":3918,"cwe_id":"CWE-125","source":"CWE-125 <S2SV_StartBug> void ntlm_free_message_fields_buffer ( NTLM_MESSAGE_FIELDS * fields ) <S2SV_EndBug> { if ( fields ) { if ( fields -> Buffer ) { free ( fields -> Buffer ) ; fields -> Len = 0 ; fields -> MaxLen = 0 ; fields -> Buffer = NULL ; fields -> BufferOffset = 0 ; } } }\n","target":"<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> static\n","project_and_commit_id":"FreeRDP@FreeRDP/2ee663f39dc8dac3d9988e847db19b2d7e3ac8c6","cve_id":"CVE-2018-8789","original_address":"https://github.com/FreeRDP/FreeRDP/commit/2ee663f39dc8dac3d9988e847db19b2d7e3ac8c6","time":"2018-11-29T18:29Z"},
	{"Unnamed: 0":5617,"cwe_id":"CWE-119","source":"CWE-119 static int rc_pick_q_and_bounds_one_pass_cbr ( const VP9_COMP * cpi , int * bottom_index , int * top_index ) { const VP9_COMMON * const cm = & cpi -> common ; const RATE_CONTROL * const rc = & cpi -> rc ; int active_best_quality ; int active_worst_quality = calc_active_worst_quality_one_pass_cbr ( cpi ) ; int q ; <S2SV_StartBug> if ( frame_is_intra_only ( cm ) ) { <S2SV_EndBug> active_best_quality = rc -> best_quality ; if ( rc -> this_key_frame_forced ) { int qindex = rc -> last_boosted_qindex ; <S2SV_StartBug> double last_boosted_q = vp9_convert_qindex_to_q ( qindex ) ; <S2SV_EndBug> int delta_qindex = vp9_compute_qdelta ( rc , last_boosted_q , <S2SV_StartBug> ( last_boosted_q * 0.75 ) ) ; <S2SV_EndBug> active_best_quality = MAX ( qindex + delta_qindex , rc -> best_quality ) ; } else if ( cm -> current_video_frame > 0 ) { double q_adj_factor = 1.0 ; double q_val ; <S2SV_StartBug> active_best_quality = get_active_quality ( rc -> avg_frame_qindex [ KEY_FRAME ] , <S2SV_EndBug> <S2SV_StartBug> rc -> kf_boost , <S2SV_EndBug> kf_low , kf_high , kf_low_motion_minq , kf_high_motion_minq ) ; if ( ( cm -> width * cm -> height ) <= ( 352 * 288 ) ) { q_adj_factor -= 0.25 ; } <S2SV_StartBug> q_val = vp9_convert_qindex_to_q ( active_best_quality ) ; <S2SV_EndBug> active_best_quality += vp9_compute_qdelta ( rc , q_val , <S2SV_StartBug> q_val * q_adj_factor ) ; <S2SV_EndBug> } } else if ( ! rc -> is_src_frame_alt_ref && ! cpi -> use_svc && ( cpi -> refresh_golden_frame || cpi -> refresh_alt_ref_frame ) ) { if ( rc -> frames_since_key > 1 && rc -> avg_frame_qindex [ INTER_FRAME ] < active_worst_quality ) { q = rc -> avg_frame_qindex [ INTER_FRAME ] ; } else { q = active_worst_quality ; } <S2SV_StartBug> active_best_quality = get_active_quality ( <S2SV_EndBug> q , rc -> gfu_boost , gf_low , gf_high , gf_low_motion_minq , gf_high_motion_minq ) ; } else { if ( cm -> current_video_frame > 1 ) { if ( rc -> avg_frame_qindex [ INTER_FRAME ] < active_worst_quality ) <S2SV_StartBug> active_best_quality = inter_minq [ rc -> avg_frame_qindex [ INTER_FRAME ] ] ; <S2SV_EndBug> else <S2SV_StartBug> active_best_quality = inter_minq [ active_worst_quality ] ; <S2SV_EndBug> } else { if ( rc -> avg_frame_qindex [ KEY_FRAME ] < active_worst_quality ) <S2SV_StartBug> active_best_quality = inter_minq [ rc -> avg_frame_qindex [ KEY_FRAME ] ] ; <S2SV_EndBug> else <S2SV_StartBug> active_best_quality = inter_minq [ active_worst_quality ] ; <S2SV_EndBug> } } active_best_quality = clamp ( active_best_quality , rc -> best_quality , rc -> worst_quality ) ; active_worst_quality = clamp ( active_worst_quality , active_best_quality , rc -> worst_quality ) ; * top_index = active_worst_quality ; * bottom_index = active_best_quality ; # if LIMIT_QRANGE_FOR_ALTREF_AND_KEY <S2SV_StartBug> if ( cm -> frame_type == KEY_FRAME && ! rc -> this_key_frame_forced ) { <S2SV_EndBug> if ( ! ( cm -> current_video_frame == 0 ) ) <S2SV_StartBug> * top_index = ( active_worst_quality + active_best_quality * 3 ) / 4 ; <S2SV_EndBug> } # endif if ( cm -> frame_type == KEY_FRAME && rc -> this_key_frame_forced ) { q = rc -> last_boosted_qindex ; } else { q = vp9_rc_regulate_q ( cpi , rc -> this_frame_target , active_best_quality , active_worst_quality ) ; if ( q > * top_index ) { if ( rc -> this_frame_target >= rc -> max_frame_bandwidth ) * top_index = q ; else q = * top_index ; } } assert ( * top_index <= rc -> worst_quality && * top_index >= rc -> best_quality ) ; assert ( * bottom_index <= rc -> worst_quality && * bottom_index >= rc -> best_quality ) ; assert ( q <= rc -> worst_quality && q >= rc -> best_quality ) ; return q ; }\n","target":"<S2SV_ModStart> int q ; int * rtc_minq ; ASSIGN_MINQ_TABLE ( cm -> bit_depth , rtc_minq ) ; <S2SV_ModStart> vp9_convert_qindex_to_q ( qindex , cm -> bit_depth <S2SV_ModStart> * 0.75 ) , cm -> bit_depth <S2SV_ModStart> ; active_best_quality = get_kf_active_quality ( rc , <S2SV_ModEnd> rc -> avg_frame_qindex <S2SV_ModStart> KEY_FRAME ] , cm -> bit_depth <S2SV_ModEnd> ) ; if <S2SV_ModStart> vp9_convert_qindex_to_q ( active_best_quality , cm -> bit_depth <S2SV_ModStart> q_val * q_adj_factor , cm -> bit_depth <S2SV_ModStart> } active_best_quality = get_gf_active_quality ( rc , q , cm -> bit_depth <S2SV_ModEnd> ) ; } <S2SV_ModStart> ) active_best_quality = rtc_minq <S2SV_ModEnd> [ rc -> <S2SV_ModStart> else active_best_quality = rtc_minq <S2SV_ModEnd> [ active_worst_quality ] <S2SV_ModStart> ) active_best_quality = rtc_minq <S2SV_ModEnd> [ rc -> <S2SV_ModStart> else active_best_quality = rtc_minq <S2SV_ModEnd> [ active_worst_quality ] <S2SV_ModStart> rc -> this_key_frame_forced && <S2SV_ModEnd> ! ( cm <S2SV_ModStart> 0 ) ) { int qdelta = 0 ; vpx_clear_system_state ( ) ; qdelta = vp9_compute_qdelta_by_rate ( & cpi -> rc , cm -> frame_type , active_worst_quality , 2.0 , cm -> bit_depth ) ; * top_index = active_worst_quality + qdelta ; * top_index = ( * top_index > * bottom_index ) ? * top_index : * bottom_index <S2SV_ModEnd> ; } #\n","project_and_commit_id":"external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426","cve_id":"CVE-2016-1621","original_address":"https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426","time":"2016-03-12T21:59Z"},
	{"Unnamed: 0":608,"cwe_id":"CWE-476","source":"CWE-476 static int i8042_start ( struct serio * serio ) { struct i8042_port * port = serio -> port_data ; <S2SV_StartBug> port -> exists = true ; <S2SV_EndBug> <S2SV_StartBug> mb ( ) ; <S2SV_EndBug> return 0 ; }\n","target":"<S2SV_ModStart> -> port_data ; spin_lock_irq ( & i8042_lock ) ; <S2SV_ModStart> = true ; spin_unlock_irq ( & i8042_lock <S2SV_ModEnd> ) ; return\n","project_and_commit_id":"torvalds@linux/340d394a789518018f834ff70f7534fc463d3226","cve_id":"CVE-2017-18079","original_address":"https://github.com/torvalds/linux/commit/340d394a789518018f834ff70f7534fc463d3226","time":"2018-01-29T05:29Z"},
	{"Unnamed: 0":1659,"cwe_id":"CWE-190","source":"CWE-190 static BOOL gdi_Bitmap_Decompress ( rdpContext * context , rdpBitmap * bitmap , const BYTE * pSrcData , UINT32 DstWidth , UINT32 DstHeight , UINT32 bpp , UINT32 length , BOOL compressed , UINT32 codecId ) { UINT32 SrcSize = length ; rdpGdi * gdi = context -> gdi ; <S2SV_StartBug> bitmap -> compressed = FALSE ; <S2SV_EndBug> bitmap -> format = gdi -> dstFormat ; <S2SV_StartBug> bitmap -> length = DstWidth * DstHeight * GetBytesPerPixel ( bitmap -> format ) ; <S2SV_EndBug> bitmap -> data = ( BYTE * ) _aligned_malloc ( bitmap -> length , 16 ) ; if ( ! bitmap -> data ) return FALSE ; if ( compressed ) { if ( bpp < 32 ) { if ( ! interleaved_decompress ( context -> codecs -> interleaved , pSrcData , SrcSize , DstWidth , DstHeight , bpp , bitmap -> data , bitmap -> format , 0 , 0 , 0 , DstWidth , DstHeight , & gdi -> palette ) ) return FALSE ; } else { if ( ! planar_decompress ( context -> codecs -> planar , pSrcData , SrcSize , DstWidth , DstHeight , bitmap -> data , bitmap -> format , 0 , 0 , 0 , DstWidth , DstHeight , TRUE ) ) return FALSE ; } } else { const UINT32 SrcFormat = gdi_get_pixel_format ( bpp ) ; const size_t sbpp = GetBytesPerPixel ( SrcFormat ) ; const size_t dbpp = GetBytesPerPixel ( bitmap -> format ) ; if ( ( sbpp == 0 ) || ( dbpp == 0 ) ) return FALSE ; else { const size_t dstSize = SrcSize * dbpp / sbpp ; if ( dstSize < bitmap -> length ) return FALSE ; } if ( ! freerdp_image_copy ( bitmap -> data , bitmap -> format , 0 , 0 , 0 , DstWidth , DstHeight , pSrcData , SrcFormat , 0 , 0 , 0 , & gdi -> palette , FREERDP_FLIP_VERTICAL ) ) return FALSE ; } return TRUE ; }\n","target":"<S2SV_ModStart> -> gdi ; UINT32 size = DstWidth * DstHeight ; <S2SV_ModStart> -> dstFormat ; if ( ( GetBytesPerPixel ( bitmap -> format ) == 0 ) || ( DstWidth == 0 ) || ( DstHeight == 0 ) || ( DstWidth > UINT32_MAX / DstHeight ) || ( size > ( UINT32_MAX / GetBytesPerPixel ( bitmap -> format ) ) ) ) return FALSE ; size *= GetBytesPerPixel ( bitmap -> format ) ; <S2SV_ModStart> -> length = size <S2SV_ModEnd> ; bitmap ->\n","project_and_commit_id":"FreeRDP@FreeRDP/09b9d4f1994a674c4ec85b4947aa656eda1aed8a","cve_id":"CVE-2018-8787","original_address":"https://github.com/FreeRDP/FreeRDP/commit/09b9d4f1994a674c4ec85b4947aa656eda1aed8a","time":"2018-11-29T18:29Z"},
	{"Unnamed: 0":5462,"cwe_id":"CWE-20","source":"CWE-20 static gboolean parse_toshiba_packet ( FILE_T fh , struct wtap_pkthdr * phdr , Buffer * buf , int * err , gchar * * err_info ) { union wtap_pseudo_header * pseudo_header = & phdr -> pseudo_header ; char line [ TOSHIBA_LINE_LENGTH ] ; int num_items_scanned ; <S2SV_StartBug> guint pkt_len ; <S2SV_EndBug> int pktnum , hr , min , sec , csec ; char channel [ 10 ] , direction [ 10 ] ; int i , hex_lines ; guint8 * pd ; if ( file_gets ( line , TOSHIBA_LINE_LENGTH , fh ) == NULL ) { * err = file_error ( fh , err_info ) ; if ( * err == 0 ) { * err = WTAP_ERR_SHORT_READ ; } return FALSE ; } num_items_scanned = sscanf ( line , \"%9d]<S2SV_blank>%2d:%2d:%2d.%9d<S2SV_blank>%9s<S2SV_blank>%9s\" , & pktnum , & hr , & min , & sec , & csec , channel , direction ) ; if ( num_items_scanned != 7 ) { * err = WTAP_ERR_BAD_FILE ; * err_info = g_strdup ( \"toshiba:<S2SV_blank>record<S2SV_blank>header<S2SV_blank>isn\\'t<S2SV_blank>valid\" ) ; return FALSE ; } do { if ( file_gets ( line , TOSHIBA_LINE_LENGTH , fh ) == NULL ) { * err = file_error ( fh , err_info ) ; if ( * err == 0 ) { * err = WTAP_ERR_SHORT_READ ; } return FALSE ; } line [ 16 ] = '\\\\0' ; } while ( strcmp ( line , \"OFFSET<S2SV_blank>0001-0203\" ) != 0 ) ; <S2SV_StartBug> num_items_scanned = sscanf ( line + 64 , \"LEN=%9u\" , & pkt_len ) ; <S2SV_EndBug> if ( num_items_scanned != 1 ) { * err = WTAP_ERR_BAD_FILE ; <S2SV_StartBug> * err_info = g_strdup ( \"toshiba:<S2SV_blank>OFFSET<S2SV_blank>line<S2SV_blank>doesn\\'t<S2SV_blank>have<S2SV_blank>valid<S2SV_blank>LEN<S2SV_blank>item\" ) ; <S2SV_EndBug> return FALSE ; } if ( pkt_len > WTAP_MAX_PACKET_SIZE ) { * err = WTAP_ERR_BAD_FILE ; * err_info = g_strdup_printf ( \"toshiba:<S2SV_blank>File<S2SV_blank>has<S2SV_blank>%u-byte<S2SV_blank>packet,<S2SV_blank>bigger<S2SV_blank>than<S2SV_blank>maximum<S2SV_blank>of<S2SV_blank>%u\" , pkt_len , WTAP_MAX_PACKET_SIZE ) ; return FALSE ; } phdr -> rec_type = REC_TYPE_PACKET ; phdr -> presence_flags = WTAP_HAS_TS | WTAP_HAS_CAP_LEN ; phdr -> ts . secs = hr * 3600 + min * 60 + sec ; phdr -> ts . nsecs = csec * 10000000 ; phdr -> caplen = pkt_len ; phdr -> len = pkt_len ; switch ( channel [ 0 ] ) { case 'B' : phdr -> pkt_encap = WTAP_ENCAP_ISDN ; pseudo_header -> isdn . uton = ( direction [ 0 ] == 'T' ) ; pseudo_header -> isdn . channel = ( guint8 ) strtol ( & channel [ 1 ] , NULL , 10 ) ; break ; case 'D' : phdr -> pkt_encap = WTAP_ENCAP_ISDN ; pseudo_header -> isdn . uton = ( direction [ 0 ] == 'T' ) ; pseudo_header -> isdn . channel = 0 ; break ; default : phdr -> pkt_encap = WTAP_ENCAP_ETHERNET ; pseudo_header -> eth . fcs_len = - 1 ; break ; } ws_buffer_assure_space ( buf , pkt_len ) ; pd = ws_buffer_start_ptr ( buf ) ; hex_lines = pkt_len / 16 + ( ( pkt_len % 16 ) ? 1 : 0 ) ; for ( i = 0 ; i < hex_lines ; i ++ ) { if ( file_gets ( line , TOSHIBA_LINE_LENGTH , fh ) == NULL ) { * err = file_error ( fh , err_info ) ; if ( * err == 0 ) { * err = WTAP_ERR_SHORT_READ ; } return FALSE ; } if ( ! parse_single_hex_dump_line ( line , pd , i * 16 ) ) { * err = WTAP_ERR_BAD_FILE ; * err_info = g_strdup ( \"toshiba:<S2SV_blank>hex<S2SV_blank>dump<S2SV_blank>not<S2SV_blank>valid\" ) ; return FALSE ; } } return TRUE ; }\n","target":"<S2SV_ModStart> int num_items_scanned ; int pkt_len , <S2SV_ModEnd> pktnum , hr <S2SV_ModStart> + 64 , \"LEN=%9d\" <S2SV_ModEnd> , & pkt_len <S2SV_ModStart> g_strdup ( \"toshiba:<S2SV_blank>OFFSET<S2SV_blank>line<S2SV_blank>doesn\\'t<S2SV_blank>have<S2SV_blank>valid<S2SV_blank>LEN<S2SV_blank>item\" ) ; return FALSE ; } if ( pkt_len < 0 ) { * err = WTAP_ERR_BAD_FILE ; * err_info = g_strdup ( \"toshiba:<S2SV_blank>packet<S2SV_blank>header<S2SV_blank>has<S2SV_blank>a<S2SV_blank>negative<S2SV_blank>packet<S2SV_blank>length\"\n","project_and_commit_id":"wireshark@wireshark/3270dfac43da861c714df76513456b46765ff47f","cve_id":"CVE-2016-5355","original_address":"https://github.com/wireshark/wireshark/commit/3270dfac43da861c714df76513456b46765ff47f","time":"2016-08-07T16:59Z"},
	{"Unnamed: 0":5788,"cwe_id":"CWE-119","source":"CWE-119 static int udf_pc_to_char ( struct super_block * sb , unsigned char * from , int fromlen , unsigned char * to , int tolen ) { struct pathComponent * pc ; int elen = 0 ; int comp_len ; unsigned char * p = to ; tolen -- ; while ( elen < fromlen ) { pc = ( struct pathComponent * ) ( from + elen ) ; <S2SV_StartBug> switch ( pc -> componentType ) { <S2SV_EndBug> case 1 : if ( pc -> lengthComponentIdent > 0 ) <S2SV_StartBug> break ; <S2SV_EndBug> case 2 : if ( tolen == 0 ) return - ENAMETOOLONG ; p = to ; * p ++ = '/' ; tolen -- ; break ; case 3 : if ( tolen < 3 ) return - ENAMETOOLONG ; memcpy ( p , \"../\" , 3 ) ; p += 3 ; tolen -= 3 ; break ; case 4 : if ( tolen < 2 ) return - ENAMETOOLONG ; memcpy ( p , \"./\" , 2 ) ; p += 2 ; tolen -= 2 ; break ; <S2SV_StartBug> case 5 : <S2SV_EndBug> comp_len = udf_get_filename ( sb , pc -> componentIdent , pc -> lengthComponentIdent , p , tolen ) ; p += comp_len ; tolen -= comp_len ; if ( tolen == 0 ) return - ENAMETOOLONG ; * p ++ = '/' ; tolen -- ; break ; } <S2SV_StartBug> elen += sizeof ( struct pathComponent ) + pc -> lengthComponentIdent ; <S2SV_EndBug> } if ( p > to + 1 ) p [ - 1 ] = '\\\\0' ; else p [ 0 ] = '\\\\0' ; return 0 ; }\n","target":"<S2SV_ModStart> elen ) ; elen += sizeof ( struct pathComponent ) ; <S2SV_ModStart> > 0 ) { elen += pc -> lengthComponentIdent ; break ; } <S2SV_ModEnd> case 2 : <S2SV_ModStart> case 5 : elen += pc -> lengthComponentIdent ; if ( elen > fromlen ) return - EIO ; <S2SV_ModStart> break ; } <S2SV_ModEnd> } if (\n","project_and_commit_id":"torvalds@linux/e237ec37ec154564f8690c5bd1795339955eeef9","cve_id":"CVE-2014-9728","original_address":"https://github.com/torvalds/linux/commit/e237ec37ec154564f8690c5bd1795339955eeef9","time":"2015-08-31T10:59Z"},
	{"Unnamed: 0":1577,"cwe_id":"CWE-125","source":"CWE-125 static void gre_print_0 ( netdissect_options * ndo , const u_char * bp , u_int length ) { u_int len = length ; uint16_t flags , prot ; flags = EXTRACT_16BITS ( bp ) ; if ( ndo -> ndo_vflag ) ND_PRINT ( ( ndo , \",<S2SV_blank>Flags<S2SV_blank>[%s]\" , bittok2str ( gre_flag_values , \"none\" , flags ) ) ) ; len -= 2 ; bp += 2 ; ND_TCHECK2 ( * bp , 2 ) ; if ( len < 2 ) goto trunc ; prot = EXTRACT_16BITS ( bp ) ; len -= 2 ; bp += 2 ; if ( ( flags & GRE_CP ) | ( flags & GRE_RP ) ) { ND_TCHECK2 ( * bp , 2 ) ; if ( len < 2 ) goto trunc ; if ( ndo -> ndo_vflag ) ND_PRINT ( ( ndo , \",<S2SV_blank>sum<S2SV_blank>0x%x\" , EXTRACT_16BITS ( bp ) ) ) ; bp += 2 ; len -= 2 ; ND_TCHECK2 ( * bp , 2 ) ; if ( len < 2 ) goto trunc ; ND_PRINT ( ( ndo , \",<S2SV_blank>off<S2SV_blank>0x%x\" , EXTRACT_16BITS ( bp ) ) ) ; bp += 2 ; len -= 2 ; } if ( flags & GRE_KP ) { ND_TCHECK2 ( * bp , 4 ) ; if ( len < 4 ) goto trunc ; ND_PRINT ( ( ndo , \",<S2SV_blank>key=0x%x\" , EXTRACT_32BITS ( bp ) ) ) ; bp += 4 ; len -= 4 ; } if ( flags & GRE_SP ) { ND_TCHECK2 ( * bp , 4 ) ; if ( len < 4 ) goto trunc ; ND_PRINT ( ( ndo , \",<S2SV_blank>seq<S2SV_blank>%u\" , EXTRACT_32BITS ( bp ) ) ) ; bp += 4 ; len -= 4 ; } if ( flags & GRE_RP ) { for ( ; ; ) { uint16_t af ; uint8_t sreoff ; uint8_t srelen ; ND_TCHECK2 ( * bp , 4 ) ; if ( len < 4 ) goto trunc ; af = EXTRACT_16BITS ( bp ) ; sreoff = * ( bp + 2 ) ; srelen = * ( bp + 3 ) ; bp += 4 ; len -= 4 ; if ( af == 0 && srelen == 0 ) break ; if ( ! gre_sre_print ( ndo , af , sreoff , srelen , bp , len ) ) goto trunc ; if ( len < srelen ) goto trunc ; bp += srelen ; len -= srelen ; } } if ( ndo -> ndo_eflag ) ND_PRINT ( ( ndo , \",<S2SV_blank>proto<S2SV_blank>%s<S2SV_blank>(0x%04x)\" , tok2str ( ethertype_values , \"unknown\" , prot ) , prot ) ) ; ND_PRINT ( ( ndo , \",<S2SV_blank>length<S2SV_blank>%u\" , length ) ) ; if ( ndo -> ndo_vflag < 1 ) ND_PRINT ( ( ndo , \":<S2SV_blank>\" ) ) ; else ND_PRINT ( ( ndo , \"\\\\n\\\\t\" ) ) ; switch ( prot ) { case ETHERTYPE_IP : ip_print ( ndo , bp , len ) ; break ; case ETHERTYPE_IPV6 : ip6_print ( ndo , bp , len ) ; break ; case ETHERTYPE_MPLS : mpls_print ( ndo , bp , len ) ; break ; case ETHERTYPE_IPX : ipx_print ( ndo , bp , len ) ; break ; case ETHERTYPE_ATALK : atalk_print ( ndo , bp , len ) ; break ; case ETHERTYPE_GRE_ISO : <S2SV_StartBug> isoclns_print ( ndo , bp , len , ndo -> ndo_snapend - bp ) ; <S2SV_EndBug> break ; case ETHERTYPE_TEB : ether_print ( ndo , bp , len , ndo -> ndo_snapend - bp , NULL , NULL ) ; break ; default : ND_PRINT ( ( ndo , \"gre-proto-0x%x\" , prot ) ) ; } return ; trunc : ND_PRINT ( ( ndo , \"%s\" , tstr ) ) ; }\n","target":"<S2SV_ModStart> bp , len ) ; break ; case ETHERTYPE_TEB : ether_print ( ndo , bp , len <S2SV_ModStart> ndo_snapend - bp <S2SV_ModEnd> , NULL ,\n","project_and_commit_id":"the-tcpdump-group@tcpdump/1dcd10aceabbc03bf571ea32b892c522cbe923de","cve_id":"CVE-2017-12897","original_address":"https://github.com/the-tcpdump-group/tcpdump/commit/1dcd10aceabbc03bf571ea32b892c522cbe923de","time":"2017-09-14T06:29Z"},
	{"Unnamed: 0":899,"cwe_id":"CWE-17","source":"CWE-17 <S2SV_StartBug> static void udf_pc_to_char ( struct super_block * sb , unsigned char * from , <S2SV_EndBug> <S2SV_StartBug> int fromlen , unsigned char * to ) <S2SV_EndBug> { struct pathComponent * pc ; int elen = 0 ; <S2SV_StartBug> unsigned char * p = to ; <S2SV_EndBug> while ( elen < fromlen ) { pc = ( struct pathComponent * ) ( from + elen ) ; switch ( pc -> componentType ) { case 1 : if ( pc -> lengthComponentIdent > 0 ) break ; case 2 : <S2SV_StartBug> p = to ; <S2SV_EndBug> * p ++ = '/' ; <S2SV_StartBug> break ; <S2SV_EndBug> case 3 : memcpy ( p , \"../\" , 3 ) ; p += 3 ; <S2SV_StartBug> break ; <S2SV_EndBug> case 4 : <S2SV_StartBug> memcpy ( p , \"./\" , 2 ) ; <S2SV_EndBug> p += 2 ; <S2SV_StartBug> break ; <S2SV_EndBug> case 5 : <S2SV_StartBug> p += udf_get_filename ( sb , pc -> componentIdent , p , <S2SV_EndBug> pc -> lengthComponentIdent ) ; <S2SV_StartBug> * p ++ = '/' ; <S2SV_EndBug> break ; } elen += sizeof ( struct pathComponent ) + pc -> lengthComponentIdent ; } if ( p > to + 1 ) p [ - 1 ] = '\\\\0' ; else p [ 0 ] = '\\\\0' ; <S2SV_StartBug> } <S2SV_EndBug>\n","target":"<S2SV_ModStart> <S2SV_null> <S2SV_null> static int <S2SV_ModEnd> udf_pc_to_char ( struct <S2SV_ModStart> char * to , int tolen <S2SV_ModStart> = 0 ; int comp_len ; <S2SV_ModStart> p = to ; tolen -- <S2SV_ModStart> case 2 : if ( tolen == 0 ) return - ENAMETOOLONG ; <S2SV_ModStart> = '/' ; tolen -- ; break ; case 3 : if ( tolen < 3 ) return - ENAMETOOLONG ; <S2SV_ModEnd> memcpy ( p <S2SV_ModStart> += 3 ; tolen -= 3 ; <S2SV_ModStart> case 4 : if ( tolen < 2 ) return - ENAMETOOLONG ; <S2SV_ModStart> += 2 ; tolen -= 2 ; <S2SV_ModStart> case 5 : comp_len = udf_get_filename ( sb , pc -> componentIdent , pc -> lengthComponentIdent , p , tolen ) ; p += comp_len ; tolen -= comp_len ; if ( tolen == 0 ) return - ENAMETOOLONG <S2SV_ModEnd> ; * p <S2SV_ModStart> ++ = '/' ; tolen -- <S2SV_ModStart> = '\\\\0' ; return 0 ;\n","project_and_commit_id":"torvalds@linux/0e5cc9a40ada6046e6bc3bdfcd0c0d7e4b706b14","cve_id":"CVE-2014-9731","original_address":"https://github.com/torvalds/linux/commit/0e5cc9a40ada6046e6bc3bdfcd0c0d7e4b706b14","time":"2015-08-31T10:59Z"},
	{"Unnamed: 0":4009,"cwe_id":"CWE-772","source":"CWE-772 static Image * ReadDCMImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { <S2SV_StartBug> # define ThrowDCMException ( exception , message ) { if ( data != ( unsigned char * ) NULL ) data = ( unsigned char * ) RelinquishMagickMemory ( data ) ; if ( stream_info != ( DCMStreamInfo * ) NULL ) stream_info = ( DCMStreamInfo * ) RelinquishMagickMemory ( stream_info ) ; ThrowReaderException ( ( exception ) , ( message ) ) ; } <S2SV_EndBug> char explicit_vr [ MaxTextExtent ] , implicit_vr [ MaxTextExtent ] , magick [ MaxTextExtent ] , photometric [ MaxTextExtent ] ; DCMInfo info ; DCMStreamInfo * stream_info ; Image * image ; int * bluemap , datum , * greenmap , * graymap , * redmap ; MagickBooleanType explicit_file , explicit_retry , sequence , use_explicit ; MagickOffsetType offset ; register unsigned char * p ; register ssize_t i ; size_t colors , height , length , number_scenes , quantum , status , width ; ssize_t count , scene ; unsigned char * data ; unsigned short group , element ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickSignature ) ; if ( image_info -> debug != MagickFalse ) ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , \"%s\" , image_info -> filename ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickSignature ) ; image = AcquireImage ( image_info ) ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } image -> depth = 8UL ; image -> endian = LSBEndian ; data = ( unsigned char * ) NULL ; stream_info = ( DCMStreamInfo * ) AcquireMagickMemory ( sizeof ( * stream_info ) ) ; if ( stream_info == ( DCMStreamInfo * ) NULL ) ThrowDCMException ( ResourceLimitError , \"MemoryAllocationFailed\" ) ; ( void ) ResetMagickMemory ( stream_info , 0 , sizeof ( * stream_info ) ) ; count = ReadBlob ( image , 128 , ( unsigned char * ) magick ) ; if ( count != 128 ) ThrowDCMException ( CorruptImageError , \"ImproperImageHeader\" ) ; count = ReadBlob ( image , 4 , ( unsigned char * ) magick ) ; if ( ( count != 4 ) || ( LocaleNCompare ( magick , \"DICM\" , 4 ) != 0 ) ) { offset = SeekBlob ( image , 0L , SEEK_SET ) ; if ( offset < 0 ) ThrowDCMException ( CorruptImageError , \"ImproperImageHeader\" ) ; } ( void ) CopyMagickString ( photometric , \"MONOCHROME1<S2SV_blank>\" , MaxTextExtent ) ; info . polarity = MagickFalse ; info . scale = ( Quantum * ) NULL ; info . bits_allocated = 8 ; info . bytes_per_pixel = 1 ; info . depth = 8 ; info . mask = 0xffff ; info . max_value = 255UL ; info . samples_per_pixel = 1 ; info . signed_data = ( ~ 0UL ) ; info . significant_bits = 0 ; info . rescale = MagickFalse ; info . rescale_intercept = 0.0 ; info . rescale_slope = 1.0 ; info . window_center = 0.0 ; info . window_width = 0.0 ; data = ( unsigned char * ) NULL ; element = 0 ; explicit_vr [ 2 ] = '\\\\0' ; explicit_file = MagickFalse ; colors = 0 ; redmap = ( int * ) NULL ; greenmap = ( int * ) NULL ; bluemap = ( int * ) NULL ; graymap = ( int * ) NULL ; height = 0 ; number_scenes = 1 ; sequence = MagickFalse ; use_explicit = MagickFalse ; explicit_retry = MagickFalse ; width = 0 ; for ( group = 0 ; ( group != 0x7FE0 ) || ( element != 0x0010 ) || ( sequence != MagickFalse ) ; ) { image -> offset = ( ssize_t ) TellBlob ( image ) ; group = ReadBlobLSBShort ( image ) ; element = ReadBlobLSBShort ( image ) ; if ( ( group != 0x0002 ) && ( image -> endian == MSBEndian ) ) { group = ( unsigned short ) ( ( group << 8 ) | ( ( group >> 8 ) & 0xFF ) ) ; element = ( unsigned short ) ( ( element << 8 ) | ( ( element >> 8 ) & 0xFF ) ) ; } quantum = 0 ; for ( i = 0 ; dicom_info [ i ] . group < 0xffff ; i ++ ) if ( ( group == dicom_info [ i ] . group ) && ( element == dicom_info [ i ] . element ) ) break ; ( void ) CopyMagickString ( implicit_vr , dicom_info [ i ] . vr , MaxTextExtent ) ; count = ReadBlob ( image , 2 , ( unsigned char * ) explicit_vr ) ; if ( count != 2 ) ThrowDCMException ( CorruptImageError , \"ImproperImageHeader\" ) ; if ( ( explicit_file == MagickFalse ) && ( group != 0x0002 ) ) explicit_file = ( isupper ( ( unsigned char ) * explicit_vr ) != MagickFalse ) && ( isupper ( ( unsigned char ) * ( explicit_vr + 1 ) ) != MagickFalse ) ? MagickTrue : MagickFalse ; use_explicit = ( ( group == 0x0002 ) && ( explicit_retry == MagickFalse ) ) || ( explicit_file != MagickFalse ) ? MagickTrue : MagickFalse ; if ( ( use_explicit != MagickFalse ) && ( strncmp ( implicit_vr , \"xs\" , 2 ) == 0 ) ) ( void ) CopyMagickString ( implicit_vr , explicit_vr , MaxTextExtent ) ; if ( ( use_explicit == MagickFalse ) || ( strncmp ( implicit_vr , \"!!\" , 2 ) == 0 ) ) { offset = SeekBlob ( image , ( MagickOffsetType ) - 2 , SEEK_CUR ) ; if ( offset < 0 ) ThrowDCMException ( CorruptImageError , \"ImproperImageHeader\" ) ; quantum = 4 ; } else { quantum = 2 ; if ( ( strncmp ( explicit_vr , \"OB\" , 2 ) == 0 ) || ( strncmp ( explicit_vr , \"UN\" , 2 ) == 0 ) || ( strncmp ( explicit_vr , \"OW\" , 2 ) == 0 ) || ( strncmp ( explicit_vr , \"SQ\" , 2 ) == 0 ) ) { ( void ) ReadBlobLSBShort ( image ) ; quantum = 4 ; } } datum = 0 ; if ( quantum == 4 ) { if ( group == 0x0002 ) datum = ReadBlobLSBSignedLong ( image ) ; else datum = ReadBlobSignedLong ( image ) ; } else if ( quantum == 2 ) { if ( group == 0x0002 ) datum = ReadBlobLSBSignedShort ( image ) ; else datum = ReadBlobSignedShort ( image ) ; } quantum = 0 ; length = 1 ; if ( datum != 0 ) { if ( ( strncmp ( implicit_vr , \"SS\" , 2 ) == 0 ) || ( strncmp ( implicit_vr , \"US\" , 2 ) == 0 ) ) quantum = 2 ; else if ( ( strncmp ( implicit_vr , \"UL\" , 2 ) == 0 ) || ( strncmp ( implicit_vr , \"SL\" , 2 ) == 0 ) || ( strncmp ( implicit_vr , \"FL\" , 2 ) == 0 ) ) quantum = 4 ; else if ( strncmp ( implicit_vr , \"FD\" , 2 ) != 0 ) quantum = 1 ; else quantum = 8 ; if ( datum != ~ 0 ) length = ( size_t ) datum / quantum ; else { quantum = 0 ; length = 0 ; } } if ( image_info -> verbose != MagickFalse ) { if ( use_explicit == MagickFalse ) explicit_vr [ 0 ] = '\\\\0' ; for ( i = 0 ; dicom_info [ i ] . description != ( char * ) NULL ; i ++ ) if ( ( group == dicom_info [ i ] . group ) && ( element == dicom_info [ i ] . element ) ) break ; ( void ) FormatLocaleFile ( stdout , \"0x%04lX<S2SV_blank>%4ld<S2SV_blank>%s-%s<S2SV_blank>(0x%04lx,0x%04lx)\" , ( unsigned long ) image -> offset , ( long ) length , implicit_vr , explicit_vr , ( unsigned long ) group , ( unsigned long ) element ) ; if ( dicom_info [ i ] . description != ( char * ) NULL ) ( void ) FormatLocaleFile ( stdout , \"<S2SV_blank>%s\" , dicom_info [ i ] . description ) ; ( void ) FormatLocaleFile ( stdout , \":<S2SV_blank>\" ) ; } if ( ( sequence == MagickFalse ) && ( group == 0x7FE0 ) && ( element == 0x0010 ) ) { if ( image_info -> verbose != MagickFalse ) ( void ) FormatLocaleFile ( stdout , \"\\\\n\" ) ; break ; } data = ( unsigned char * ) NULL ; if ( ( length == 1 ) && ( quantum == 1 ) ) datum = ReadBlobByte ( image ) ; else if ( ( length == 1 ) && ( quantum == 2 ) ) { if ( group == 0x0002 ) datum = ReadBlobLSBSignedShort ( image ) ; else datum = ReadBlobSignedShort ( image ) ; } else if ( ( length == 1 ) && ( quantum == 4 ) ) { if ( group == 0x0002 ) datum = ReadBlobLSBSignedLong ( image ) ; else datum = ReadBlobSignedLong ( image ) ; } else if ( ( quantum != 0 ) && ( length != 0 ) ) { if ( length > GetBlobSize ( image ) ) <S2SV_StartBug> ThrowReaderException ( CorruptImageError , <S2SV_EndBug> \"InsufficientImageDataInFile\" ) ; if ( ~ length >= 1 ) data = ( unsigned char * ) AcquireQuantumMemory ( length + 1 , quantum * sizeof ( * data ) ) ; if ( data == ( unsigned char * ) NULL ) ThrowDCMException ( ResourceLimitError , \"MemoryAllocationFailed\" ) ; count = ReadBlob ( image , ( size_t ) quantum * length , data ) ; if ( count != ( ssize_t ) ( quantum * length ) ) { if ( image_info -> verbose != MagickFalse ) ( void ) FormatLocaleFile ( stdout , \"count=%d<S2SV_blank>quantum=%d<S2SV_blank>\" \"length=%d<S2SV_blank>group=%d\\\\n\" , ( int ) count , ( int ) quantum , ( int ) length , ( int ) group ) ; ThrowDCMException ( CorruptImageError , \"InsufficientImageDataInFile\" ) ; } data [ length * quantum ] = '\\\\0' ; } else if ( ( unsigned int ) datum == 0xFFFFFFFFU ) { sequence = MagickTrue ; continue ; } if ( ( unsigned int ) ( ( group << 16 ) | element ) == 0xFFFEE0DD ) { if ( data != ( unsigned char * ) NULL ) data = ( unsigned char * ) RelinquishMagickMemory ( data ) ; sequence = MagickFalse ; continue ; } if ( sequence != MagickFalse ) { if ( data != ( unsigned char * ) NULL ) data = ( unsigned char * ) RelinquishMagickMemory ( data ) ; continue ; } switch ( group ) { case 0x0002 : { switch ( element ) { case 0x0010 : { char transfer_syntax [ MaxTextExtent ] ; if ( ( datum == 0 ) && ( explicit_retry == MagickFalse ) ) { explicit_retry = MagickTrue ; ( void ) SeekBlob ( image , ( MagickOffsetType ) 0 , SEEK_SET ) ; group = 0 ; element = 0 ; if ( image_info -> verbose != MagickFalse ) ( void ) FormatLocaleFile ( stdout , \"Corrupted<S2SV_blank>image<S2SV_blank>-<S2SV_blank>trying<S2SV_blank>explicit<S2SV_blank>format\\\\n\" ) ; break ; } * transfer_syntax = '\\\\0' ; if ( data != ( unsigned char * ) NULL ) ( void ) CopyMagickString ( transfer_syntax , ( char * ) data , MaxTextExtent ) ; if ( image_info -> verbose != MagickFalse ) ( void ) FormatLocaleFile ( stdout , \"transfer_syntax=%s\\\\n\" , ( const char * ) transfer_syntax ) ; if ( strncmp ( transfer_syntax , \"1.2.840.10008.1.2\" , 17 ) == 0 ) { int count , subtype , type ; type = 1 ; subtype = 0 ; if ( strlen ( transfer_syntax ) > 17 ) { count = sscanf ( transfer_syntax + 17 , \".%d.%d\" , & type , & subtype ) ; if ( count < 1 ) ThrowDCMException ( CorruptImageError , \"ImproperImageHeader\" ) ; } switch ( type ) { case 1 : { image -> endian = LSBEndian ; break ; } case 2 : { image -> endian = MSBEndian ; break ; } case 4 : { if ( ( subtype >= 80 ) && ( subtype <= 81 ) ) image -> compression = JPEGCompression ; else if ( ( subtype >= 90 ) && ( subtype <= 93 ) ) image -> compression = JPEG2000Compression ; else image -> compression = JPEGCompression ; break ; } case 5 : { image -> compression = RLECompression ; break ; } } } break ; } default : break ; } break ; } case 0x0028 : { switch ( element ) { case 0x0002 : { info . samples_per_pixel = ( size_t ) datum ; break ; } case 0x0004 : { if ( data == ( unsigned char * ) NULL ) break ; for ( i = 0 ; i < ( ssize_t ) MagickMin ( length , MaxTextExtent - 1 ) ; i ++ ) photometric [ i ] = ( char ) data [ i ] ; photometric [ i ] = '\\\\0' ; info . polarity = LocaleCompare ( photometric , \"MONOCHROME1<S2SV_blank>\" ) == 0 ? MagickTrue : MagickFalse ; break ; } case 0x0006 : { if ( datum == 1 ) image -> interlace = PlaneInterlace ; break ; } case 0x0008 : { if ( data == ( unsigned char * ) NULL ) break ; number_scenes = StringToUnsignedLong ( ( char * ) data ) ; break ; } case 0x0010 : { height = ( size_t ) datum ; break ; } case 0x0011 : { width = ( size_t ) datum ; break ; } case 0x0100 : { info . bits_allocated = ( size_t ) datum ; info . bytes_per_pixel = 1 ; if ( datum > 8 ) info . bytes_per_pixel = 2 ; info . depth = info . bits_allocated ; if ( info . depth > 32 ) ThrowDCMException ( CorruptImageError , \"ImproperImageHeader\" ) ; info . max_value = ( 1UL << info . bits_allocated ) - 1 ; image -> depth = info . depth ; break ; } case 0x0101 : { info . significant_bits = ( size_t ) datum ; info . bytes_per_pixel = 1 ; if ( info . significant_bits > 8 ) info . bytes_per_pixel = 2 ; info . depth = info . significant_bits ; if ( info . depth > 32 ) ThrowDCMException ( CorruptImageError , \"ImproperImageHeader\" ) ; info . max_value = ( 1UL << info . significant_bits ) - 1 ; info . mask = ( size_t ) GetQuantumRange ( info . significant_bits ) ; image -> depth = info . depth ; break ; } case 0x0102 : { break ; } case 0x0103 : { info . signed_data = ( size_t ) datum ; break ; } case 0x1050 : { if ( data != ( unsigned char * ) NULL ) info . window_center = StringToDouble ( ( char * ) data , ( char * * ) NULL ) ; break ; } case 0x1051 : { if ( data != ( unsigned char * ) NULL ) info . window_width = StringToDouble ( ( char * ) data , ( char * * ) NULL ) ; break ; } case 0x1052 : { if ( data != ( unsigned char * ) NULL ) info . rescale_intercept = StringToDouble ( ( char * ) data , ( char * * ) NULL ) ; break ; } case 0x1053 : { if ( data != ( unsigned char * ) NULL ) info . rescale_slope = StringToDouble ( ( char * ) data , ( char * * ) NULL ) ; break ; } case 0x1200 : case 0x3006 : { if ( data == ( unsigned char * ) NULL ) break ; colors = ( size_t ) ( length / info . bytes_per_pixel ) ; datum = ( int ) colors ; graymap = ( int * ) AcquireQuantumMemory ( ( size_t ) colors , sizeof ( * graymap ) ) ; if ( graymap == ( int * ) NULL ) ThrowDCMException ( ResourceLimitError , \"MemoryAllocationFailed\" ) ; for ( i = 0 ; i < ( ssize_t ) colors ; i ++ ) if ( info . bytes_per_pixel == 1 ) graymap [ i ] = ( int ) data [ i ] ; else graymap [ i ] = ( int ) ( ( short * ) data ) [ i ] ; break ; } case 0x1201 : { unsigned short index ; if ( data == ( unsigned char * ) NULL ) break ; colors = ( size_t ) ( length / 2 ) ; datum = ( int ) colors ; redmap = ( int * ) AcquireQuantumMemory ( ( size_t ) colors , sizeof ( * redmap ) ) ; if ( redmap == ( int * ) NULL ) ThrowDCMException ( ResourceLimitError , \"MemoryAllocationFailed\" ) ; p = data ; for ( i = 0 ; i < ( ssize_t ) colors ; i ++ ) { if ( image -> endian == MSBEndian ) index = ( unsigned short ) ( ( * p << 8 ) | * ( p + 1 ) ) ; else index = ( unsigned short ) ( * p | ( * ( p + 1 ) << 8 ) ) ; redmap [ i ] = ( int ) index ; p += 2 ; } break ; } case 0x1202 : { unsigned short index ; if ( data == ( unsigned char * ) NULL ) break ; colors = ( size_t ) ( length / 2 ) ; datum = ( int ) colors ; greenmap = ( int * ) AcquireQuantumMemory ( ( size_t ) colors , sizeof ( * greenmap ) ) ; if ( greenmap == ( int * ) NULL ) ThrowDCMException ( ResourceLimitError , \"MemoryAllocationFailed\" ) ; p = data ; for ( i = 0 ; i < ( ssize_t ) colors ; i ++ ) { if ( image -> endian == MSBEndian ) index = ( unsigned short ) ( ( * p << 8 ) | * ( p + 1 ) ) ; else index = ( unsigned short ) ( * p | ( * ( p + 1 ) << 8 ) ) ; greenmap [ i ] = ( int ) index ; p += 2 ; } break ; } case 0x1203 : { unsigned short index ; if ( data == ( unsigned char * ) NULL ) break ; colors = ( size_t ) ( length / 2 ) ; datum = ( int ) colors ; bluemap = ( int * ) AcquireQuantumMemory ( ( size_t ) colors , sizeof ( * bluemap ) ) ; if ( bluemap == ( int * ) NULL ) ThrowDCMException ( ResourceLimitError , \"MemoryAllocationFailed\" ) ; p = data ; for ( i = 0 ; i < ( ssize_t ) colors ; i ++ ) { if ( image -> endian == MSBEndian ) index = ( unsigned short ) ( ( * p << 8 ) | * ( p + 1 ) ) ; else index = ( unsigned short ) ( * p | ( * ( p + 1 ) << 8 ) ) ; bluemap [ i ] = ( int ) index ; p += 2 ; } break ; } default : break ; } break ; } case 0x2050 : { switch ( element ) { case 0x0020 : { if ( ( data != ( unsigned char * ) NULL ) && ( strncmp ( ( char * ) data , \"INVERSE\" , 7 ) == 0 ) ) info . polarity = MagickTrue ; break ; } default : break ; } break ; } default : break ; } if ( data != ( unsigned char * ) NULL ) { char * attribute ; for ( i = 0 ; dicom_info [ i ] . description != ( char * ) NULL ; i ++ ) if ( ( group == dicom_info [ i ] . group ) && ( element == dicom_info [ i ] . element ) ) break ; if ( dicom_info [ i ] . description != ( char * ) NULL ) { attribute = AcquireString ( \"dcm:\" ) ; ( void ) ConcatenateString ( & attribute , dicom_info [ i ] . description ) ; for ( i = 0 ; i < ( ssize_t ) MagickMax ( length , 4 ) ; i ++ ) if ( isprint ( ( int ) data [ i ] ) == MagickFalse ) break ; if ( ( i == ( ssize_t ) length ) || ( length > 4 ) ) { ( void ) SubstituteString ( & attribute , \"<S2SV_blank>\" , \"\" ) ; ( void ) SetImageProperty ( image , attribute , ( char * ) data ) ; } attribute = DestroyString ( attribute ) ; } } if ( image_info -> verbose != MagickFalse ) { if ( data == ( unsigned char * ) NULL ) ( void ) FormatLocaleFile ( stdout , \"%d\\\\n\" , datum ) ; else { for ( i = 0 ; i < ( ssize_t ) MagickMax ( length , 4 ) ; i ++ ) if ( isprint ( ( int ) data [ i ] ) == MagickFalse ) break ; if ( ( i != ( ssize_t ) length ) && ( length <= 4 ) ) { ssize_t j ; datum = 0 ; for ( j = ( ssize_t ) length - 1 ; j >= 0 ; j -- ) datum = ( 256 * datum + data [ j ] ) ; ( void ) FormatLocaleFile ( stdout , \"%d\" , datum ) ; } else for ( i = 0 ; i < ( ssize_t ) length ; i ++ ) if ( isprint ( ( int ) data [ i ] ) != MagickFalse ) ( void ) FormatLocaleFile ( stdout , \"%c\" , data [ i ] ) ; else ( void ) FormatLocaleFile ( stdout , \"%c\" , '.' ) ; ( void ) FormatLocaleFile ( stdout , \"\\\\n\" ) ; } } if ( data != ( unsigned char * ) NULL ) data = ( unsigned char * ) RelinquishMagickMemory ( data ) ; if ( EOFBlob ( image ) != MagickFalse ) { ThrowFileException ( exception , CorruptImageError , \"UnexpectedEndOfFile\" , image -> filename ) ; break ; } } if ( ( width == 0 ) || ( height == 0 ) ) ThrowDCMException ( CorruptImageError , \"ImproperImageHeader\" ) ; image -> columns = ( size_t ) width ; image -> rows = ( size_t ) height ; if ( info . signed_data == 0xffff ) info . signed_data = ( size_t ) ( info . significant_bits == 16 ? 1 : 0 ) ; if ( ( image -> compression == JPEGCompression ) || ( image -> compression == JPEG2000Compression ) ) { Image * images ; ImageInfo * read_info ; int c ; size_t length ; unsigned int tag ; for ( i = 0 ; i < ( ssize_t ) stream_info -> remaining ; i ++ ) ( void ) ReadBlobByte ( image ) ; tag = ( ReadBlobLSBShort ( image ) << 16 ) | ReadBlobLSBShort ( image ) ; ( void ) tag ; length = ( size_t ) ReadBlobLSBLong ( image ) ; stream_info -> offset_count = length >> 2 ; if ( stream_info -> offset_count != 0 ) { MagickOffsetType offset ; stream_info -> offsets = ( ssize_t * ) AcquireQuantumMemory ( stream_info -> offset_count , sizeof ( * stream_info -> offsets ) ) ; if ( stream_info -> offsets == ( ssize_t * ) NULL ) ThrowDCMException ( ResourceLimitError , \"MemoryAllocationFailed\" ) ; for ( i = 0 ; i < ( ssize_t ) stream_info -> offset_count ; i ++ ) stream_info -> offsets [ i ] = ( ssize_t ) ReadBlobLSBSignedLong ( image ) ; offset = TellBlob ( image ) ; for ( i = 0 ; i < ( ssize_t ) stream_info -> offset_count ; i ++ ) stream_info -> offsets [ i ] += offset ; } read_info = CloneImageInfo ( image_info ) ; SetImageInfoBlob ( read_info , ( void * ) NULL , 0 ) ; images = NewImageList ( ) ; for ( scene = 0 ; scene < ( ssize_t ) number_scenes ; scene ++ ) { char filename [ MaxTextExtent ] ; const char * property ; FILE * file ; Image * jpeg_image ; int unique_file ; unsigned int tag ; tag = ( ReadBlobLSBShort ( image ) << 16 ) | ReadBlobLSBShort ( image ) ; length = ( size_t ) ReadBlobLSBLong ( image ) ; if ( tag == 0xFFFEE0DD ) break ; if ( tag != 0xFFFEE000 ) ThrowDCMException ( CorruptImageError , \"ImproperImageHeader\" ) ; file = ( FILE * ) NULL ; unique_file = AcquireUniqueFileResource ( filename ) ; if ( unique_file != - 1 ) file = fdopen ( unique_file , \"wb\" ) ; if ( file == ( FILE * ) NULL ) { ( void ) RelinquishUniqueFileResource ( filename ) ; ThrowFileException ( exception , FileOpenError , \"UnableToCreateTemporaryFile\" , filename ) ; break ; } for ( ; length != 0 ; length -- ) { c = ReadBlobByte ( image ) ; if ( c == EOF ) { ThrowFileException ( exception , CorruptImageError , \"UnexpectedEndOfFile\" , image -> filename ) ; break ; } ( void ) fputc ( c , file ) ; } ( void ) fclose ( file ) ; ( void ) FormatLocaleString ( read_info -> filename , MaxTextExtent , \"jpeg:%s\" , filename ) ; if ( image -> compression == JPEG2000Compression ) ( void ) FormatLocaleString ( read_info -> filename , MaxTextExtent , \"j2k:%s\" , filename ) ; jpeg_image = ReadImage ( read_info , exception ) ; if ( jpeg_image != ( Image * ) NULL ) { ResetImagePropertyIterator ( image ) ; property = GetNextImageProperty ( image ) ; while ( property != ( const char * ) NULL ) { ( void ) SetImageProperty ( jpeg_image , property , GetImageProperty ( image , property ) ) ; property = GetNextImageProperty ( image ) ; } AppendImageToList ( & images , jpeg_image ) ; } ( void ) RelinquishUniqueFileResource ( filename ) ; } read_info = DestroyImageInfo ( read_info ) ; image = DestroyImage ( image ) ; return ( GetFirstImageInList ( images ) ) ; } if ( info . depth != ( 1UL * MAGICKCORE_QUANTUM_DEPTH ) ) { QuantumAny range ; size_t length ; length = ( size_t ) ( GetQuantumRange ( info . depth ) + 1 ) ; info . scale = ( Quantum * ) AcquireQuantumMemory ( length , sizeof ( * info . scale ) ) ; if ( info . scale == ( Quantum * ) NULL ) ThrowDCMException ( ResourceLimitError , \"MemoryAllocationFailed\" ) ; range = GetQuantumRange ( info . depth ) ; for ( i = 0 ; i <= ( ssize_t ) GetQuantumRange ( info . depth ) ; i ++ ) info . scale [ i ] = ScaleAnyToQuantum ( ( size_t ) i , range ) ; } if ( image -> compression == RLECompression ) { size_t length ; unsigned int tag ; for ( i = 0 ; i < ( ssize_t ) stream_info -> remaining ; i ++ ) ( void ) ReadBlobByte ( image ) ; tag = ( ReadBlobLSBShort ( image ) << 16 ) | ReadBlobLSBShort ( image ) ; ( void ) tag ; length = ( size_t ) ReadBlobLSBLong ( image ) ; stream_info -> offset_count = length >> 2 ; if ( stream_info -> offset_count != 0 ) { MagickOffsetType offset ; stream_info -> offsets = ( ssize_t * ) AcquireQuantumMemory ( stream_info -> offset_count , sizeof ( * stream_info -> offsets ) ) ; if ( stream_info -> offsets == ( ssize_t * ) NULL ) ThrowDCMException ( ResourceLimitError , \"MemoryAllocationFailed\" ) ; for ( i = 0 ; i < ( ssize_t ) stream_info -> offset_count ; i ++ ) stream_info -> offsets [ i ] = ( ssize_t ) ReadBlobLSBSignedLong ( image ) ; offset = TellBlob ( image ) + 8 ; for ( i = 0 ; i < ( ssize_t ) stream_info -> offset_count ; i ++ ) stream_info -> offsets [ i ] += offset ; } } for ( scene = 0 ; scene < ( ssize_t ) number_scenes ; scene ++ ) { if ( image_info -> ping != MagickFalse ) break ; image -> columns = ( size_t ) width ; image -> rows = ( size_t ) height ; image -> depth = info . depth ; status = SetImageExtent ( image , image -> columns , image -> rows ) ; if ( status == MagickFalse ) { InheritException ( exception , & image -> exception ) ; break ; } image -> colorspace = RGBColorspace ; if ( ( image -> colormap == ( PixelPacket * ) NULL ) && ( info . samples_per_pixel == 1 ) ) { int index ; size_t one ; one = 1 ; if ( colors == 0 ) colors = one << info . depth ; if ( AcquireImageColormap ( image , colors ) == MagickFalse ) ThrowDCMException ( ResourceLimitError , \"MemoryAllocationFailed\" ) ; if ( redmap != ( int * ) NULL ) for ( i = 0 ; i < ( ssize_t ) colors ; i ++ ) { index = redmap [ i ] ; if ( ( info . scale != ( Quantum * ) NULL ) && ( index <= ( int ) info . max_value ) ) index = ( int ) info . scale [ index ] ; image -> colormap [ i ] . red = ( Quantum ) index ; } if ( greenmap != ( int * ) NULL ) for ( i = 0 ; i < ( ssize_t ) colors ; i ++ ) { index = greenmap [ i ] ; if ( ( info . scale != ( Quantum * ) NULL ) && ( index <= ( int ) info . max_value ) ) index = ( int ) info . scale [ index ] ; image -> colormap [ i ] . green = ( Quantum ) index ; } if ( bluemap != ( int * ) NULL ) for ( i = 0 ; i < ( ssize_t ) colors ; i ++ ) { index = bluemap [ i ] ; if ( ( info . scale != ( Quantum * ) NULL ) && ( index <= ( int ) info . max_value ) ) index = ( int ) info . scale [ index ] ; image -> colormap [ i ] . blue = ( Quantum ) index ; } if ( graymap != ( int * ) NULL ) for ( i = 0 ; i < ( ssize_t ) colors ; i ++ ) { index = graymap [ i ] ; if ( ( info . scale != ( Quantum * ) NULL ) && ( index <= ( int ) info . max_value ) ) index = ( int ) info . scale [ index ] ; image -> colormap [ i ] . red = ( Quantum ) index ; image -> colormap [ i ] . green = ( Quantum ) index ; image -> colormap [ i ] . blue = ( Quantum ) index ; } } if ( image -> compression == RLECompression ) { unsigned int tag ; for ( i = 0 ; i < ( ssize_t ) stream_info -> remaining ; i ++ ) ( void ) ReadBlobByte ( image ) ; tag = ( ReadBlobLSBShort ( image ) << 16 ) | ReadBlobLSBShort ( image ) ; stream_info -> remaining = ( size_t ) ReadBlobLSBLong ( image ) ; if ( ( tag != 0xFFFEE000 ) || ( stream_info -> remaining <= 64 ) || ( EOFBlob ( image ) != MagickFalse ) ) ThrowDCMException ( CorruptImageError , \"ImproperImageHeader\" ) ; stream_info -> count = 0 ; stream_info -> segment_count = ReadBlobLSBLong ( image ) ; for ( i = 0 ; i < 15 ; i ++ ) stream_info -> segments [ i ] = ( ssize_t ) ReadBlobLSBSignedLong ( image ) ; stream_info -> remaining -= 64 ; if ( stream_info -> segment_count > 1 ) { info . bytes_per_pixel = 1 ; info . depth = 8 ; if ( stream_info -> offset_count > 0 ) ( void ) SeekBlob ( image , stream_info -> offsets [ 0 ] + stream_info -> segments [ 0 ] , SEEK_SET ) ; } } if ( ( info . samples_per_pixel > 1 ) && ( image -> interlace == PlaneInterlace ) ) { register ssize_t x ; register PixelPacket * q ; ssize_t y ; for ( i = 0 ; i < ( ssize_t ) info . samples_per_pixel ; i ++ ) { for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { q = GetAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( PixelPacket * ) NULL ) break ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { switch ( ( int ) i ) { case 0 : { SetPixelRed ( q , ScaleCharToQuantum ( ( unsigned char ) ReadDCMByte ( stream_info , image ) ) ) ; break ; } case 1 : { SetPixelGreen ( q , ScaleCharToQuantum ( ( unsigned char ) ReadDCMByte ( stream_info , image ) ) ) ; break ; } case 2 : { SetPixelBlue ( q , ScaleCharToQuantum ( ( unsigned char ) ReadDCMByte ( stream_info , image ) ) ) ; break ; } case 3 : { SetPixelAlpha ( q , ScaleCharToQuantum ( ( unsigned char ) ReadDCMByte ( stream_info , image ) ) ) ; break ; } default : break ; } q ++ ; } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ; if ( status == MagickFalse ) break ; } } } } else { const char * option ; option = GetImageOption ( image_info , \"dcm:display-range\" ) ; if ( option != ( const char * ) NULL ) { if ( LocaleCompare ( option , \"reset\" ) == 0 ) info . window_width = 0 ; } option = GetImageOption ( image_info , \"dcm:window\" ) ; if ( option != ( char * ) NULL ) { GeometryInfo geometry_info ; MagickStatusType flags ; flags = ParseGeometry ( option , & geometry_info ) ; if ( flags & RhoValue ) info . window_center = geometry_info . rho ; if ( flags & SigmaValue ) info . window_width = geometry_info . sigma ; info . rescale = MagickTrue ; } option = GetImageOption ( image_info , \"dcm:rescale\" ) ; if ( option != ( char * ) NULL ) info . rescale = IsStringTrue ( option ) ; if ( ( info . window_center != 0 ) && ( info . window_width == 0 ) ) info . window_width = info . window_center ; status = ReadDCMPixels ( image , & info , stream_info , MagickTrue , exception ) ; if ( ( status != MagickFalse ) && ( stream_info -> segment_count > 1 ) ) { if ( stream_info -> offset_count > 0 ) ( void ) SeekBlob ( image , stream_info -> offsets [ 0 ] + stream_info -> segments [ 1 ] , SEEK_SET ) ; ( void ) ReadDCMPixels ( image , & info , stream_info , MagickFalse , exception ) ; } } if ( SetImageGray ( image , exception ) != MagickFalse ) ( void ) SetImageColorspace ( image , GRAYColorspace ) ; if ( EOFBlob ( image ) != MagickFalse ) { ThrowFileException ( exception , CorruptImageError , \"UnexpectedEndOfFile\" , image -> filename ) ; break ; } if ( image_info -> number_scenes != 0 ) if ( image -> scene >= ( image_info -> scene + image_info -> number_scenes - 1 ) ) break ; if ( scene < ( ssize_t ) ( number_scenes - 1 ) ) { AcquireNextImage ( image_info , image ) ; if ( GetNextImageInList ( image ) == ( Image * ) NULL ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } image = SyncNextImageInList ( image ) ; status = SetImageProgress ( image , LoadImagesTag , TellBlob ( image ) , GetBlobSize ( image ) ) ; if ( status == MagickFalse ) break ; } } if ( stream_info -> offsets != ( ssize_t * ) NULL ) stream_info -> offsets = ( ssize_t * ) RelinquishMagickMemory ( stream_info -> offsets ) ; stream_info = ( DCMStreamInfo * ) RelinquishMagickMemory ( stream_info ) ; if ( info . scale != ( Quantum * ) NULL ) info . scale = ( Quantum * ) RelinquishMagickMemory ( info . scale ) ; if ( graymap != ( int * ) NULL ) graymap = ( int * ) RelinquishMagickMemory ( graymap ) ; if ( bluemap != ( int * ) NULL ) bluemap = ( int * ) RelinquishMagickMemory ( bluemap ) ; if ( greenmap != ( int * ) NULL ) greenmap = ( int * ) RelinquishMagickMemory ( greenmap ) ; if ( redmap != ( int * ) NULL ) redmap = ( int * ) RelinquishMagickMemory ( redmap ) ; ( void ) CloseBlob ( image ) ; return ( GetFirstImageInList ( image ) ) ; }\n","target":"<S2SV_ModStart> , message ) \\\\\\n{ <S2SV_ModEnd> if ( data <S2SV_ModStart> ) ) ; \\\\\\n} <S2SV_ModEnd> char explicit_vr [ <S2SV_ModStart> image ) ) ThrowDCMException <S2SV_ModEnd> ( CorruptImageError ,\n","project_and_commit_id":"ImageMagick@ImageMagick/9f375e7080a2c1044cd546854d0548b4bfb429d0","cve_id":"CVE-2017-12644","original_address":"https://github.com/ImageMagick/ImageMagick/commit/9f375e7080a2c1044cd546854d0548b4bfb429d0","time":"2017-08-07T15:29Z"},
	{"Unnamed: 0":4782,"cwe_id":"CWE-264","source":"CWE-264 static int msr_open ( struct inode * inode , struct file * file ) { unsigned int cpu ; <S2SV_StartBug> struct cpuinfo_x86 * c ; <S2SV_EndBug> cpu = iminor ( file -> f_path . dentry -> d_inode ) ; if ( cpu >= nr_cpu_ids || ! cpu_online ( cpu ) ) return - ENXIO ; c = & cpu_data ( cpu ) ; if ( ! cpu_has ( c , X86_FEATURE_MSR ) ) return - EIO ; return 0 ; }\n","target":"<S2SV_ModStart> cpuinfo_x86 * c ; if ( ! capable ( CAP_SYS_RAWIO ) ) return - EPERM\n","project_and_commit_id":"torvalds@linux/c903f0456bc69176912dee6dd25c6a66ee1aed00","cve_id":"CVE-2013-0268","original_address":"https://github.com/torvalds/linux/commit/c903f0456bc69176912dee6dd25c6a66ee1aed00","time":"2013-02-18T04:41Z"},
	{"Unnamed: 0":2331,"cwe_id":"CWE-94","source":"CWE-94 static target_ulong disas_insn ( CPUX86State * env , DisasContext * s , target_ulong pc_start ) { int b , prefixes ; int shift ; TCGMemOp ot , aflag , dflag ; int modrm , reg , rm , mod , op , opreg , val ; target_ulong next_eip , tval ; int rex_w , rex_r ; s -> pc_start = s -> pc = pc_start ; prefixes = 0 ; s -> override = - 1 ; rex_w = - 1 ; rex_r = 0 ; # ifdef TARGET_X86_64 s -> rex_x = 0 ; s -> rex_b = 0 ; x86_64_hregs = 0 ; # endif s -> rip_offset = 0 ; s -> vex_l = 0 ; s -> vex_v = 0 ; <S2SV_StartBug> next_byte : <S2SV_EndBug> b = cpu_ldub_code ( env , s -> pc ) ; s -> pc ++ ; switch ( b ) { case 0xf3 : prefixes |= PREFIX_REPZ ; goto next_byte ; case 0xf2 : prefixes |= PREFIX_REPNZ ; goto next_byte ; case 0xf0 : prefixes |= PREFIX_LOCK ; goto next_byte ; case 0x2e : s -> override = R_CS ; goto next_byte ; case 0x36 : s -> override = R_SS ; goto next_byte ; case 0x3e : s -> override = R_DS ; goto next_byte ; case 0x26 : s -> override = R_ES ; goto next_byte ; case 0x64 : s -> override = R_FS ; goto next_byte ; case 0x65 : s -> override = R_GS ; goto next_byte ; case 0x66 : prefixes |= PREFIX_DATA ; goto next_byte ; case 0x67 : prefixes |= PREFIX_ADR ; goto next_byte ; # ifdef TARGET_X86_64 case 0x40 ... 0x4f : if ( CODE64 ( s ) ) { rex_w = ( b >> 3 ) & 1 ; rex_r = ( b & 0x4 ) << 1 ; s -> rex_x = ( b & 0x2 ) << 2 ; REX_B ( s ) = ( b & 0x1 ) << 3 ; x86_64_hregs = 1 ; goto next_byte ; } break ; # endif case 0xc5 : case 0xc4 : if ( s -> code32 && ! s -> vm86 ) { static const int pp_prefix [ 4 ] = { 0 , PREFIX_DATA , PREFIX_REPZ , PREFIX_REPNZ } ; int vex3 , vex2 = cpu_ldub_code ( env , s -> pc ) ; if ( ! CODE64 ( s ) && ( vex2 & 0xc0 ) != 0xc0 ) { break ; } s -> pc ++ ; if ( prefixes & ( PREFIX_REPZ | PREFIX_REPNZ | PREFIX_LOCK | PREFIX_DATA ) ) { goto illegal_op ; } # ifdef TARGET_X86_64 if ( x86_64_hregs ) { goto illegal_op ; } # endif rex_r = ( ~ vex2 >> 4 ) & 8 ; if ( b == 0xc5 ) { vex3 = vex2 ; b = cpu_ldub_code ( env , s -> pc ++ ) ; } else { # ifdef TARGET_X86_64 s -> rex_x = ( ~ vex2 >> 3 ) & 8 ; s -> rex_b = ( ~ vex2 >> 2 ) & 8 ; # endif vex3 = cpu_ldub_code ( env , s -> pc ++ ) ; rex_w = ( vex3 >> 7 ) & 1 ; switch ( vex2 & 0x1f ) { case 0x01 : b = cpu_ldub_code ( env , s -> pc ++ ) | 0x100 ; break ; case 0x02 : b = 0x138 ; break ; case 0x03 : b = 0x13a ; break ; default : goto unknown_op ; } } s -> vex_v = ( ~ vex3 >> 3 ) & 0xf ; s -> vex_l = ( vex3 >> 2 ) & 1 ; prefixes |= pp_prefix [ vex3 & 3 ] | PREFIX_VEX ; } break ; } if ( CODE64 ( s ) ) { dflag = ( rex_w > 0 ? MO_64 : prefixes & PREFIX_DATA ? MO_16 : MO_32 ) ; aflag = ( prefixes & PREFIX_ADR ? MO_32 : MO_64 ) ; } else { if ( s -> code32 ^ ( ( prefixes & PREFIX_DATA ) != 0 ) ) { dflag = MO_32 ; } else { dflag = MO_16 ; } if ( s -> code32 ^ ( ( prefixes & PREFIX_ADR ) != 0 ) ) { aflag = MO_32 ; } else { aflag = MO_16 ; } } s -> prefix = prefixes ; s -> aflag = aflag ; s -> dflag = dflag ; reswitch : switch ( b ) { case 0x0f : b = cpu_ldub_code ( env , s -> pc ++ ) | 0x100 ; goto reswitch ; case 0x00 ... 0x05 : case 0x08 ... 0x0d : case 0x10 ... 0x15 : case 0x18 ... 0x1d : case 0x20 ... 0x25 : case 0x28 ... 0x2d : case 0x30 ... 0x35 : case 0x38 ... 0x3d : { int op , f , val ; op = ( b >> 3 ) & 7 ; f = ( b >> 1 ) & 3 ; ot = mo_b_d ( b , dflag ) ; switch ( f ) { case 0 : modrm = cpu_ldub_code ( env , s -> pc ++ ) ; reg = ( ( modrm >> 3 ) & 7 ) | rex_r ; mod = ( modrm >> 6 ) & 3 ; rm = ( modrm & 7 ) | REX_B ( s ) ; if ( mod != 3 ) { gen_lea_modrm ( env , s , modrm ) ; opreg = OR_TMP0 ; } else if ( op == OP_XORL && rm == reg ) { xor_zero : set_cc_op ( s , CC_OP_CLR ) ; tcg_gen_movi_tl ( cpu_T0 , 0 ) ; gen_op_mov_reg_v ( ot , reg , cpu_T0 ) ; break ; } else { opreg = rm ; } gen_op_mov_v_reg ( ot , cpu_T1 , reg ) ; gen_op ( s , op , ot , opreg ) ; break ; case 1 : modrm = cpu_ldub_code ( env , s -> pc ++ ) ; mod = ( modrm >> 6 ) & 3 ; reg = ( ( modrm >> 3 ) & 7 ) | rex_r ; rm = ( modrm & 7 ) | REX_B ( s ) ; if ( mod != 3 ) { gen_lea_modrm ( env , s , modrm ) ; gen_op_ld_v ( s , ot , cpu_T1 , cpu_A0 ) ; } else if ( op == OP_XORL && rm == reg ) { goto xor_zero ; } else { gen_op_mov_v_reg ( ot , cpu_T1 , rm ) ; } gen_op ( s , op , ot , reg ) ; break ; case 2 : val = insn_get ( env , s , ot ) ; tcg_gen_movi_tl ( cpu_T1 , val ) ; gen_op ( s , op , ot , OR_EAX ) ; break ; } } break ; case 0x82 : if ( CODE64 ( s ) ) goto illegal_op ; case 0x80 : case 0x81 : case 0x83 : { int val ; ot = mo_b_d ( b , dflag ) ; modrm = cpu_ldub_code ( env , s -> pc ++ ) ; mod = ( modrm >> 6 ) & 3 ; rm = ( modrm & 7 ) | REX_B ( s ) ; op = ( modrm >> 3 ) & 7 ; if ( mod != 3 ) { if ( b == 0x83 ) s -> rip_offset = 1 ; else s -> rip_offset = insn_const_size ( ot ) ; gen_lea_modrm ( env , s , modrm ) ; opreg = OR_TMP0 ; } else { opreg = rm ; } switch ( b ) { default : case 0x80 : case 0x81 : case 0x82 : val = insn_get ( env , s , ot ) ; break ; case 0x83 : val = ( int8_t ) insn_get ( env , s , MO_8 ) ; break ; } tcg_gen_movi_tl ( cpu_T1 , val ) ; gen_op ( s , op , ot , opreg ) ; } break ; case 0x40 ... 0x47 : ot = dflag ; gen_inc ( s , ot , OR_EAX + ( b & 7 ) , 1 ) ; break ; case 0x48 ... 0x4f : ot = dflag ; gen_inc ( s , ot , OR_EAX + ( b & 7 ) , - 1 ) ; break ; case 0xf6 : case 0xf7 : ot = mo_b_d ( b , dflag ) ; modrm = cpu_ldub_code ( env , s -> pc ++ ) ; mod = ( modrm >> 6 ) & 3 ; rm = ( modrm & 7 ) | REX_B ( s ) ; op = ( modrm >> 3 ) & 7 ; if ( mod != 3 ) { if ( op == 0 ) { s -> rip_offset = insn_const_size ( ot ) ; } gen_lea_modrm ( env , s , modrm ) ; if ( ! ( s -> prefix & PREFIX_LOCK ) || op != 2 ) { gen_op_ld_v ( s , ot , cpu_T0 , cpu_A0 ) ; } } else { gen_op_mov_v_reg ( ot , cpu_T0 , rm ) ; } switch ( op ) { case 0 : val = insn_get ( env , s , ot ) ; tcg_gen_movi_tl ( cpu_T1 , val ) ; gen_op_testl_T0_T1_cc ( ) ; set_cc_op ( s , CC_OP_LOGICB + ot ) ; break ; case 2 : if ( s -> prefix & PREFIX_LOCK ) { if ( mod == 3 ) { goto illegal_op ; } tcg_gen_movi_tl ( cpu_T0 , ~ 0 ) ; tcg_gen_atomic_xor_fetch_tl ( cpu_T0 , cpu_A0 , cpu_T0 , s -> mem_index , ot | MO_LE ) ; } else { tcg_gen_not_tl ( cpu_T0 , cpu_T0 ) ; if ( mod != 3 ) { gen_op_st_v ( s , ot , cpu_T0 , cpu_A0 ) ; } else { gen_op_mov_reg_v ( ot , rm , cpu_T0 ) ; } } break ; case 3 : if ( s -> prefix & PREFIX_LOCK ) { TCGLabel * label1 ; TCGv a0 , t0 , t1 , t2 ; if ( mod == 3 ) { goto illegal_op ; } a0 = tcg_temp_local_new ( ) ; t0 = tcg_temp_local_new ( ) ; label1 = gen_new_label ( ) ; tcg_gen_mov_tl ( a0 , cpu_A0 ) ; tcg_gen_mov_tl ( t0 , cpu_T0 ) ; gen_set_label ( label1 ) ; t1 = tcg_temp_new ( ) ; t2 = tcg_temp_new ( ) ; tcg_gen_mov_tl ( t2 , t0 ) ; tcg_gen_neg_tl ( t1 , t0 ) ; tcg_gen_atomic_cmpxchg_tl ( t0 , a0 , t0 , t1 , s -> mem_index , ot | MO_LE ) ; tcg_temp_free ( t1 ) ; tcg_gen_brcond_tl ( TCG_COND_NE , t0 , t2 , label1 ) ; tcg_temp_free ( t2 ) ; tcg_temp_free ( a0 ) ; tcg_gen_mov_tl ( cpu_T0 , t0 ) ; tcg_temp_free ( t0 ) ; } else { tcg_gen_neg_tl ( cpu_T0 , cpu_T0 ) ; if ( mod != 3 ) { gen_op_st_v ( s , ot , cpu_T0 , cpu_A0 ) ; } else { gen_op_mov_reg_v ( ot , rm , cpu_T0 ) ; } } gen_op_update_neg_cc ( ) ; set_cc_op ( s , CC_OP_SUBB + ot ) ; break ; case 4 : switch ( ot ) { case MO_8 : gen_op_mov_v_reg ( MO_8 , cpu_T1 , R_EAX ) ; tcg_gen_ext8u_tl ( cpu_T0 , cpu_T0 ) ; tcg_gen_ext8u_tl ( cpu_T1 , cpu_T1 ) ; tcg_gen_mul_tl ( cpu_T0 , cpu_T0 , cpu_T1 ) ; gen_op_mov_reg_v ( MO_16 , R_EAX , cpu_T0 ) ; tcg_gen_mov_tl ( cpu_cc_dst , cpu_T0 ) ; tcg_gen_andi_tl ( cpu_cc_src , cpu_T0 , 0xff00 ) ; set_cc_op ( s , CC_OP_MULB ) ; break ; case MO_16 : gen_op_mov_v_reg ( MO_16 , cpu_T1 , R_EAX ) ; tcg_gen_ext16u_tl ( cpu_T0 , cpu_T0 ) ; tcg_gen_ext16u_tl ( cpu_T1 , cpu_T1 ) ; tcg_gen_mul_tl ( cpu_T0 , cpu_T0 , cpu_T1 ) ; gen_op_mov_reg_v ( MO_16 , R_EAX , cpu_T0 ) ; tcg_gen_mov_tl ( cpu_cc_dst , cpu_T0 ) ; tcg_gen_shri_tl ( cpu_T0 , cpu_T0 , 16 ) ; gen_op_mov_reg_v ( MO_16 , R_EDX , cpu_T0 ) ; tcg_gen_mov_tl ( cpu_cc_src , cpu_T0 ) ; set_cc_op ( s , CC_OP_MULW ) ; break ; default : case MO_32 : tcg_gen_trunc_tl_i32 ( cpu_tmp2_i32 , cpu_T0 ) ; tcg_gen_trunc_tl_i32 ( cpu_tmp3_i32 , cpu_regs [ R_EAX ] ) ; tcg_gen_mulu2_i32 ( cpu_tmp2_i32 , cpu_tmp3_i32 , cpu_tmp2_i32 , cpu_tmp3_i32 ) ; tcg_gen_extu_i32_tl ( cpu_regs [ R_EAX ] , cpu_tmp2_i32 ) ; tcg_gen_extu_i32_tl ( cpu_regs [ R_EDX ] , cpu_tmp3_i32 ) ; tcg_gen_mov_tl ( cpu_cc_dst , cpu_regs [ R_EAX ] ) ; tcg_gen_mov_tl ( cpu_cc_src , cpu_regs [ R_EDX ] ) ; set_cc_op ( s , CC_OP_MULL ) ; break ; # ifdef TARGET_X86_64 case MO_64 : tcg_gen_mulu2_i64 ( cpu_regs [ R_EAX ] , cpu_regs [ R_EDX ] , cpu_T0 , cpu_regs [ R_EAX ] ) ; tcg_gen_mov_tl ( cpu_cc_dst , cpu_regs [ R_EAX ] ) ; tcg_gen_mov_tl ( cpu_cc_src , cpu_regs [ R_EDX ] ) ; set_cc_op ( s , CC_OP_MULQ ) ; break ; # endif } break ; case 5 : switch ( ot ) { case MO_8 : gen_op_mov_v_reg ( MO_8 , cpu_T1 , R_EAX ) ; tcg_gen_ext8s_tl ( cpu_T0 , cpu_T0 ) ; tcg_gen_ext8s_tl ( cpu_T1 , cpu_T1 ) ; tcg_gen_mul_tl ( cpu_T0 , cpu_T0 , cpu_T1 ) ; gen_op_mov_reg_v ( MO_16 , R_EAX , cpu_T0 ) ; tcg_gen_mov_tl ( cpu_cc_dst , cpu_T0 ) ; tcg_gen_ext8s_tl ( cpu_tmp0 , cpu_T0 ) ; tcg_gen_sub_tl ( cpu_cc_src , cpu_T0 , cpu_tmp0 ) ; set_cc_op ( s , CC_OP_MULB ) ; break ; case MO_16 : gen_op_mov_v_reg ( MO_16 , cpu_T1 , R_EAX ) ; tcg_gen_ext16s_tl ( cpu_T0 , cpu_T0 ) ; tcg_gen_ext16s_tl ( cpu_T1 , cpu_T1 ) ; tcg_gen_mul_tl ( cpu_T0 , cpu_T0 , cpu_T1 ) ; gen_op_mov_reg_v ( MO_16 , R_EAX , cpu_T0 ) ; tcg_gen_mov_tl ( cpu_cc_dst , cpu_T0 ) ; tcg_gen_ext16s_tl ( cpu_tmp0 , cpu_T0 ) ; tcg_gen_sub_tl ( cpu_cc_src , cpu_T0 , cpu_tmp0 ) ; tcg_gen_shri_tl ( cpu_T0 , cpu_T0 , 16 ) ; gen_op_mov_reg_v ( MO_16 , R_EDX , cpu_T0 ) ; set_cc_op ( s , CC_OP_MULW ) ; break ; default : case MO_32 : tcg_gen_trunc_tl_i32 ( cpu_tmp2_i32 , cpu_T0 ) ; tcg_gen_trunc_tl_i32 ( cpu_tmp3_i32 , cpu_regs [ R_EAX ] ) ; tcg_gen_muls2_i32 ( cpu_tmp2_i32 , cpu_tmp3_i32 , cpu_tmp2_i32 , cpu_tmp3_i32 ) ; tcg_gen_extu_i32_tl ( cpu_regs [ R_EAX ] , cpu_tmp2_i32 ) ; tcg_gen_extu_i32_tl ( cpu_regs [ R_EDX ] , cpu_tmp3_i32 ) ; tcg_gen_sari_i32 ( cpu_tmp2_i32 , cpu_tmp2_i32 , 31 ) ; tcg_gen_mov_tl ( cpu_cc_dst , cpu_regs [ R_EAX ] ) ; tcg_gen_sub_i32 ( cpu_tmp2_i32 , cpu_tmp2_i32 , cpu_tmp3_i32 ) ; tcg_gen_extu_i32_tl ( cpu_cc_src , cpu_tmp2_i32 ) ; set_cc_op ( s , CC_OP_MULL ) ; break ; # ifdef TARGET_X86_64 case MO_64 : tcg_gen_muls2_i64 ( cpu_regs [ R_EAX ] , cpu_regs [ R_EDX ] , cpu_T0 , cpu_regs [ R_EAX ] ) ; tcg_gen_mov_tl ( cpu_cc_dst , cpu_regs [ R_EAX ] ) ; tcg_gen_sari_tl ( cpu_cc_src , cpu_regs [ R_EAX ] , 63 ) ; tcg_gen_sub_tl ( cpu_cc_src , cpu_cc_src , cpu_regs [ R_EDX ] ) ; set_cc_op ( s , CC_OP_MULQ ) ; break ; # endif } break ; case 6 : switch ( ot ) { case MO_8 : gen_helper_divb_AL ( cpu_env , cpu_T0 ) ; break ; case MO_16 : gen_helper_divw_AX ( cpu_env , cpu_T0 ) ; break ; default : case MO_32 : gen_helper_divl_EAX ( cpu_env , cpu_T0 ) ; break ; # ifdef TARGET_X86_64 case MO_64 : gen_helper_divq_EAX ( cpu_env , cpu_T0 ) ; break ; # endif } break ; case 7 : switch ( ot ) { case MO_8 : gen_helper_idivb_AL ( cpu_env , cpu_T0 ) ; break ; case MO_16 : gen_helper_idivw_AX ( cpu_env , cpu_T0 ) ; break ; default : case MO_32 : gen_helper_idivl_EAX ( cpu_env , cpu_T0 ) ; break ; # ifdef TARGET_X86_64 case MO_64 : gen_helper_idivq_EAX ( cpu_env , cpu_T0 ) ; break ; # endif } break ; default : goto unknown_op ; } break ; case 0xfe : case 0xff : ot = mo_b_d ( b , dflag ) ; modrm = cpu_ldub_code ( env , s -> pc ++ ) ; mod = ( modrm >> 6 ) & 3 ; rm = ( modrm & 7 ) | REX_B ( s ) ; op = ( modrm >> 3 ) & 7 ; if ( op >= 2 && b == 0xfe ) { goto unknown_op ; } if ( CODE64 ( s ) ) { if ( op == 2 || op == 4 ) { ot = MO_64 ; } else if ( op == 3 || op == 5 ) { ot = dflag != MO_16 ? MO_32 + ( rex_w == 1 ) : MO_16 ; } else if ( op == 6 ) { ot = mo_pushpop ( s , dflag ) ; } } if ( mod != 3 ) { gen_lea_modrm ( env , s , modrm ) ; if ( op >= 2 && op != 3 && op != 5 ) gen_op_ld_v ( s , ot , cpu_T0 , cpu_A0 ) ; } else { gen_op_mov_v_reg ( ot , cpu_T0 , rm ) ; } switch ( op ) { case 0 : if ( mod != 3 ) opreg = OR_TMP0 ; else opreg = rm ; gen_inc ( s , ot , opreg , 1 ) ; break ; case 1 : if ( mod != 3 ) opreg = OR_TMP0 ; else opreg = rm ; gen_inc ( s , ot , opreg , - 1 ) ; break ; case 2 : if ( dflag == MO_16 ) { tcg_gen_ext16u_tl ( cpu_T0 , cpu_T0 ) ; } next_eip = s -> pc - s -> cs_base ; tcg_gen_movi_tl ( cpu_T1 , next_eip ) ; gen_push_v ( s , cpu_T1 ) ; gen_op_jmp_v ( cpu_T0 ) ; gen_bnd_jmp ( s ) ; gen_eob ( s ) ; break ; case 3 : gen_op_ld_v ( s , ot , cpu_T1 , cpu_A0 ) ; gen_add_A0_im ( s , 1 << ot ) ; gen_op_ld_v ( s , MO_16 , cpu_T0 , cpu_A0 ) ; do_lcall : if ( s -> pe && ! s -> vm86 ) { tcg_gen_trunc_tl_i32 ( cpu_tmp2_i32 , cpu_T0 ) ; gen_helper_lcall_protected ( cpu_env , cpu_tmp2_i32 , cpu_T1 , tcg_const_i32 ( dflag - 1 ) , tcg_const_tl ( s -> pc - s -> cs_base ) ) ; } else { tcg_gen_trunc_tl_i32 ( cpu_tmp2_i32 , cpu_T0 ) ; gen_helper_lcall_real ( cpu_env , cpu_tmp2_i32 , cpu_T1 , tcg_const_i32 ( dflag - 1 ) , tcg_const_i32 ( s -> pc - s -> cs_base ) ) ; } gen_eob ( s ) ; break ; case 4 : if ( dflag == MO_16 ) { tcg_gen_ext16u_tl ( cpu_T0 , cpu_T0 ) ; } gen_op_jmp_v ( cpu_T0 ) ; gen_bnd_jmp ( s ) ; gen_eob ( s ) ; break ; case 5 : gen_op_ld_v ( s , ot , cpu_T1 , cpu_A0 ) ; gen_add_A0_im ( s , 1 << ot ) ; gen_op_ld_v ( s , MO_16 , cpu_T0 , cpu_A0 ) ; do_ljmp : if ( s -> pe && ! s -> vm86 ) { tcg_gen_trunc_tl_i32 ( cpu_tmp2_i32 , cpu_T0 ) ; gen_helper_ljmp_protected ( cpu_env , cpu_tmp2_i32 , cpu_T1 , tcg_const_tl ( s -> pc - s -> cs_base ) ) ; } else { gen_op_movl_seg_T0_vm ( R_CS ) ; gen_op_jmp_v ( cpu_T1 ) ; } gen_eob ( s ) ; break ; case 6 : gen_push_v ( s , cpu_T0 ) ; break ; default : goto unknown_op ; } break ; case 0x84 : case 0x85 : ot = mo_b_d ( b , dflag ) ; modrm = cpu_ldub_code ( env , s -> pc ++ ) ; reg = ( ( modrm >> 3 ) & 7 ) | rex_r ; gen_ldst_modrm ( env , s , modrm , ot , OR_TMP0 , 0 ) ; gen_op_mov_v_reg ( ot , cpu_T1 , reg ) ; gen_op_testl_T0_T1_cc ( ) ; set_cc_op ( s , CC_OP_LOGICB + ot ) ; break ; case 0xa8 : case 0xa9 : ot = mo_b_d ( b , dflag ) ; val = insn_get ( env , s , ot ) ; gen_op_mov_v_reg ( ot , cpu_T0 , OR_EAX ) ; tcg_gen_movi_tl ( cpu_T1 , val ) ; gen_op_testl_T0_T1_cc ( ) ; set_cc_op ( s , CC_OP_LOGICB + ot ) ; break ; case 0x98 : switch ( dflag ) { # ifdef TARGET_X86_64 case MO_64 : gen_op_mov_v_reg ( MO_32 , cpu_T0 , R_EAX ) ; tcg_gen_ext32s_tl ( cpu_T0 , cpu_T0 ) ; gen_op_mov_reg_v ( MO_64 , R_EAX , cpu_T0 ) ; break ; # endif case MO_32 : gen_op_mov_v_reg ( MO_16 , cpu_T0 , R_EAX ) ; tcg_gen_ext16s_tl ( cpu_T0 , cpu_T0 ) ; gen_op_mov_reg_v ( MO_32 , R_EAX , cpu_T0 ) ; break ; case MO_16 : gen_op_mov_v_reg ( MO_8 , cpu_T0 , R_EAX ) ; tcg_gen_ext8s_tl ( cpu_T0 , cpu_T0 ) ; gen_op_mov_reg_v ( MO_16 , R_EAX , cpu_T0 ) ; break ; default : tcg_abort ( ) ; } break ; case 0x99 : switch ( dflag ) { # ifdef TARGET_X86_64 case MO_64 : gen_op_mov_v_reg ( MO_64 , cpu_T0 , R_EAX ) ; tcg_gen_sari_tl ( cpu_T0 , cpu_T0 , 63 ) ; gen_op_mov_reg_v ( MO_64 , R_EDX , cpu_T0 ) ; break ; # endif case MO_32 : gen_op_mov_v_reg ( MO_32 , cpu_T0 , R_EAX ) ; tcg_gen_ext32s_tl ( cpu_T0 , cpu_T0 ) ; tcg_gen_sari_tl ( cpu_T0 , cpu_T0 , 31 ) ; gen_op_mov_reg_v ( MO_32 , R_EDX , cpu_T0 ) ; break ; case MO_16 : gen_op_mov_v_reg ( MO_16 , cpu_T0 , R_EAX ) ; tcg_gen_ext16s_tl ( cpu_T0 , cpu_T0 ) ; tcg_gen_sari_tl ( cpu_T0 , cpu_T0 , 15 ) ; gen_op_mov_reg_v ( MO_16 , R_EDX , cpu_T0 ) ; break ; default : tcg_abort ( ) ; } break ; case 0x1af : case 0x69 : case 0x6b : ot = dflag ; modrm = cpu_ldub_code ( env , s -> pc ++ ) ; reg = ( ( modrm >> 3 ) & 7 ) | rex_r ; if ( b == 0x69 ) s -> rip_offset = insn_const_size ( ot ) ; else if ( b == 0x6b ) s -> rip_offset = 1 ; gen_ldst_modrm ( env , s , modrm , ot , OR_TMP0 , 0 ) ; if ( b == 0x69 ) { val = insn_get ( env , s , ot ) ; tcg_gen_movi_tl ( cpu_T1 , val ) ; } else if ( b == 0x6b ) { val = ( int8_t ) insn_get ( env , s , MO_8 ) ; tcg_gen_movi_tl ( cpu_T1 , val ) ; } else { gen_op_mov_v_reg ( ot , cpu_T1 , reg ) ; } switch ( ot ) { # ifdef TARGET_X86_64 case MO_64 : tcg_gen_muls2_i64 ( cpu_regs [ reg ] , cpu_T1 , cpu_T0 , cpu_T1 ) ; tcg_gen_mov_tl ( cpu_cc_dst , cpu_regs [ reg ] ) ; tcg_gen_sari_tl ( cpu_cc_src , cpu_cc_dst , 63 ) ; tcg_gen_sub_tl ( cpu_cc_src , cpu_cc_src , cpu_T1 ) ; break ; # endif case MO_32 : tcg_gen_trunc_tl_i32 ( cpu_tmp2_i32 , cpu_T0 ) ; tcg_gen_trunc_tl_i32 ( cpu_tmp3_i32 , cpu_T1 ) ; tcg_gen_muls2_i32 ( cpu_tmp2_i32 , cpu_tmp3_i32 , cpu_tmp2_i32 , cpu_tmp3_i32 ) ; tcg_gen_extu_i32_tl ( cpu_regs [ reg ] , cpu_tmp2_i32 ) ; tcg_gen_sari_i32 ( cpu_tmp2_i32 , cpu_tmp2_i32 , 31 ) ; tcg_gen_mov_tl ( cpu_cc_dst , cpu_regs [ reg ] ) ; tcg_gen_sub_i32 ( cpu_tmp2_i32 , cpu_tmp2_i32 , cpu_tmp3_i32 ) ; tcg_gen_extu_i32_tl ( cpu_cc_src , cpu_tmp2_i32 ) ; break ; default : tcg_gen_ext16s_tl ( cpu_T0 , cpu_T0 ) ; tcg_gen_ext16s_tl ( cpu_T1 , cpu_T1 ) ; tcg_gen_mul_tl ( cpu_T0 , cpu_T0 , cpu_T1 ) ; tcg_gen_mov_tl ( cpu_cc_dst , cpu_T0 ) ; tcg_gen_ext16s_tl ( cpu_tmp0 , cpu_T0 ) ; tcg_gen_sub_tl ( cpu_cc_src , cpu_T0 , cpu_tmp0 ) ; gen_op_mov_reg_v ( ot , reg , cpu_T0 ) ; break ; } set_cc_op ( s , CC_OP_MULB + ot ) ; break ; case 0x1c0 : case 0x1c1 : ot = mo_b_d ( b , dflag ) ; modrm = cpu_ldub_code ( env , s -> pc ++ ) ; reg = ( ( modrm >> 3 ) & 7 ) | rex_r ; mod = ( modrm >> 6 ) & 3 ; gen_op_mov_v_reg ( ot , cpu_T0 , reg ) ; if ( mod == 3 ) { rm = ( modrm & 7 ) | REX_B ( s ) ; gen_op_mov_v_reg ( ot , cpu_T1 , rm ) ; tcg_gen_add_tl ( cpu_T0 , cpu_T0 , cpu_T1 ) ; gen_op_mov_reg_v ( ot , reg , cpu_T1 ) ; gen_op_mov_reg_v ( ot , rm , cpu_T0 ) ; } else { gen_lea_modrm ( env , s , modrm ) ; if ( s -> prefix & PREFIX_LOCK ) { tcg_gen_atomic_fetch_add_tl ( cpu_T1 , cpu_A0 , cpu_T0 , s -> mem_index , ot | MO_LE ) ; tcg_gen_add_tl ( cpu_T0 , cpu_T0 , cpu_T1 ) ; } else { gen_op_ld_v ( s , ot , cpu_T1 , cpu_A0 ) ; tcg_gen_add_tl ( cpu_T0 , cpu_T0 , cpu_T1 ) ; gen_op_st_v ( s , ot , cpu_T0 , cpu_A0 ) ; } gen_op_mov_reg_v ( ot , reg , cpu_T1 ) ; } gen_op_update2_cc ( ) ; set_cc_op ( s , CC_OP_ADDB + ot ) ; break ; case 0x1b0 : case 0x1b1 : { TCGv oldv , newv , cmpv ; ot = mo_b_d ( b , dflag ) ; modrm = cpu_ldub_code ( env , s -> pc ++ ) ; reg = ( ( modrm >> 3 ) & 7 ) | rex_r ; mod = ( modrm >> 6 ) & 3 ; oldv = tcg_temp_new ( ) ; newv = tcg_temp_new ( ) ; cmpv = tcg_temp_new ( ) ; gen_op_mov_v_reg ( ot , newv , reg ) ; tcg_gen_mov_tl ( cmpv , cpu_regs [ R_EAX ] ) ; if ( s -> prefix & PREFIX_LOCK ) { if ( mod == 3 ) { goto illegal_op ; } gen_lea_modrm ( env , s , modrm ) ; tcg_gen_atomic_cmpxchg_tl ( oldv , cpu_A0 , cmpv , newv , s -> mem_index , ot | MO_LE ) ; gen_op_mov_reg_v ( ot , R_EAX , oldv ) ; } else { if ( mod == 3 ) { rm = ( modrm & 7 ) | REX_B ( s ) ; gen_op_mov_v_reg ( ot , oldv , rm ) ; } else { gen_lea_modrm ( env , s , modrm ) ; gen_op_ld_v ( s , ot , oldv , cpu_A0 ) ; rm = 0 ; } gen_extu ( ot , oldv ) ; gen_extu ( ot , cmpv ) ; tcg_gen_movcond_tl ( TCG_COND_EQ , newv , oldv , cmpv , newv , oldv ) ; if ( mod == 3 ) { gen_op_mov_reg_v ( ot , R_EAX , oldv ) ; gen_op_mov_reg_v ( ot , rm , newv ) ; } else { gen_op_st_v ( s , ot , newv , cpu_A0 ) ; gen_op_mov_reg_v ( ot , R_EAX , oldv ) ; } } tcg_gen_mov_tl ( cpu_cc_src , oldv ) ; tcg_gen_mov_tl ( cpu_cc_srcT , cmpv ) ; tcg_gen_sub_tl ( cpu_cc_dst , cmpv , oldv ) ; set_cc_op ( s , CC_OP_SUBB + ot ) ; tcg_temp_free ( oldv ) ; tcg_temp_free ( newv ) ; tcg_temp_free ( cmpv ) ; } break ; case 0x1c7 : modrm = cpu_ldub_code ( env , s -> pc ++ ) ; mod = ( modrm >> 6 ) & 3 ; if ( ( mod == 3 ) || ( ( modrm & 0x38 ) != 0x8 ) ) goto illegal_op ; # ifdef TARGET_X86_64 if ( dflag == MO_64 ) { if ( ! ( s -> cpuid_ext_features & CPUID_EXT_CX16 ) ) goto illegal_op ; gen_lea_modrm ( env , s , modrm ) ; if ( ( s -> prefix & PREFIX_LOCK ) && parallel_cpus ) { gen_helper_cmpxchg16b ( cpu_env , cpu_A0 ) ; } else { gen_helper_cmpxchg16b_unlocked ( cpu_env , cpu_A0 ) ; } } else # endif { if ( ! ( s -> cpuid_features & CPUID_CX8 ) ) goto illegal_op ; gen_lea_modrm ( env , s , modrm ) ; if ( ( s -> prefix & PREFIX_LOCK ) && parallel_cpus ) { gen_helper_cmpxchg8b ( cpu_env , cpu_A0 ) ; } else { gen_helper_cmpxchg8b_unlocked ( cpu_env , cpu_A0 ) ; } } set_cc_op ( s , CC_OP_EFLAGS ) ; break ; case 0x50 ... 0x57 : gen_op_mov_v_reg ( MO_32 , cpu_T0 , ( b & 7 ) | REX_B ( s ) ) ; gen_push_v ( s , cpu_T0 ) ; break ; case 0x58 ... 0x5f : ot = gen_pop_T0 ( s ) ; gen_pop_update ( s , ot ) ; gen_op_mov_reg_v ( ot , ( b & 7 ) | REX_B ( s ) , cpu_T0 ) ; break ; case 0x60 : if ( CODE64 ( s ) ) goto illegal_op ; gen_pusha ( s ) ; break ; case 0x61 : if ( CODE64 ( s ) ) goto illegal_op ; gen_popa ( s ) ; break ; case 0x68 : case 0x6a : ot = mo_pushpop ( s , dflag ) ; if ( b == 0x68 ) val = insn_get ( env , s , ot ) ; else val = ( int8_t ) insn_get ( env , s , MO_8 ) ; tcg_gen_movi_tl ( cpu_T0 , val ) ; gen_push_v ( s , cpu_T0 ) ; break ; case 0x8f : modrm = cpu_ldub_code ( env , s -> pc ++ ) ; mod = ( modrm >> 6 ) & 3 ; ot = gen_pop_T0 ( s ) ; if ( mod == 3 ) { gen_pop_update ( s , ot ) ; rm = ( modrm & 7 ) | REX_B ( s ) ; gen_op_mov_reg_v ( ot , rm , cpu_T0 ) ; } else { s -> popl_esp_hack = 1 << ot ; gen_ldst_modrm ( env , s , modrm , ot , OR_TMP0 , 1 ) ; s -> popl_esp_hack = 0 ; gen_pop_update ( s , ot ) ; } break ; case 0xc8 : { int level ; val = cpu_lduw_code ( env , s -> pc ) ; s -> pc += 2 ; level = cpu_ldub_code ( env , s -> pc ++ ) ; gen_enter ( s , val , level ) ; } break ; case 0xc9 : gen_leave ( s ) ; break ; case 0x06 : case 0x0e : case 0x16 : case 0x1e : if ( CODE64 ( s ) ) goto illegal_op ; gen_op_movl_T0_seg ( b >> 3 ) ; gen_push_v ( s , cpu_T0 ) ; break ; case 0x1a0 : case 0x1a8 : gen_op_movl_T0_seg ( ( b >> 3 ) & 7 ) ; gen_push_v ( s , cpu_T0 ) ; break ; case 0x07 : case 0x17 : case 0x1f : if ( CODE64 ( s ) ) goto illegal_op ; reg = b >> 3 ; ot = gen_pop_T0 ( s ) ; gen_movl_seg_T0 ( s , reg ) ; gen_pop_update ( s , ot ) ; if ( s -> is_jmp ) { gen_jmp_im ( s -> pc - s -> cs_base ) ; if ( reg == R_SS ) { s -> tf = 0 ; gen_eob_inhibit_irq ( s , true ) ; } else { gen_eob ( s ) ; } } break ; case 0x1a1 : case 0x1a9 : ot = gen_pop_T0 ( s ) ; gen_movl_seg_T0 ( s , ( b >> 3 ) & 7 ) ; gen_pop_update ( s , ot ) ; if ( s -> is_jmp ) { gen_jmp_im ( s -> pc - s -> cs_base ) ; gen_eob ( s ) ; } break ; case 0x88 : case 0x89 : ot = mo_b_d ( b , dflag ) ; modrm = cpu_ldub_code ( env , s -> pc ++ ) ; reg = ( ( modrm >> 3 ) & 7 ) | rex_r ; gen_ldst_modrm ( env , s , modrm , ot , reg , 1 ) ; break ; case 0xc6 : case 0xc7 : ot = mo_b_d ( b , dflag ) ; modrm = cpu_ldub_code ( env , s -> pc ++ ) ; mod = ( modrm >> 6 ) & 3 ; if ( mod != 3 ) { s -> rip_offset = insn_const_size ( ot ) ; gen_lea_modrm ( env , s , modrm ) ; } val = insn_get ( env , s , ot ) ; tcg_gen_movi_tl ( cpu_T0 , val ) ; if ( mod != 3 ) { gen_op_st_v ( s , ot , cpu_T0 , cpu_A0 ) ; } else { gen_op_mov_reg_v ( ot , ( modrm & 7 ) | REX_B ( s ) , cpu_T0 ) ; } break ; case 0x8a : case 0x8b : ot = mo_b_d ( b , dflag ) ; modrm = cpu_ldub_code ( env , s -> pc ++ ) ; reg = ( ( modrm >> 3 ) & 7 ) | rex_r ; gen_ldst_modrm ( env , s , modrm , ot , OR_TMP0 , 0 ) ; gen_op_mov_reg_v ( ot , reg , cpu_T0 ) ; break ; case 0x8e : modrm = cpu_ldub_code ( env , s -> pc ++ ) ; reg = ( modrm >> 3 ) & 7 ; if ( reg >= 6 || reg == R_CS ) goto illegal_op ; gen_ldst_modrm ( env , s , modrm , MO_16 , OR_TMP0 , 0 ) ; gen_movl_seg_T0 ( s , reg ) ; if ( s -> is_jmp ) { gen_jmp_im ( s -> pc - s -> cs_base ) ; if ( reg == R_SS ) { s -> tf = 0 ; gen_eob_inhibit_irq ( s , true ) ; } else { gen_eob ( s ) ; } } break ; case 0x8c : modrm = cpu_ldub_code ( env , s -> pc ++ ) ; reg = ( modrm >> 3 ) & 7 ; mod = ( modrm >> 6 ) & 3 ; if ( reg >= 6 ) goto illegal_op ; gen_op_movl_T0_seg ( reg ) ; ot = mod == 3 ? dflag : MO_16 ; gen_ldst_modrm ( env , s , modrm , ot , OR_TMP0 , 1 ) ; break ; case 0x1b6 : case 0x1b7 : case 0x1be : case 0x1bf : { TCGMemOp d_ot ; TCGMemOp s_ot ; d_ot = dflag ; ot = ( b & 1 ) + MO_8 ; s_ot = b & 8 ? MO_SIGN | ot : ot ; modrm = cpu_ldub_code ( env , s -> pc ++ ) ; reg = ( ( modrm >> 3 ) & 7 ) | rex_r ; mod = ( modrm >> 6 ) & 3 ; rm = ( modrm & 7 ) | REX_B ( s ) ; if ( mod == 3 ) { if ( s_ot == MO_SB && byte_reg_is_xH ( rm ) ) { tcg_gen_sextract_tl ( cpu_T0 , cpu_regs [ rm - 4 ] , 8 , 8 ) ; } else { gen_op_mov_v_reg ( ot , cpu_T0 , rm ) ; switch ( s_ot ) { case MO_UB : tcg_gen_ext8u_tl ( cpu_T0 , cpu_T0 ) ; break ; case MO_SB : tcg_gen_ext8s_tl ( cpu_T0 , cpu_T0 ) ; break ; case MO_UW : tcg_gen_ext16u_tl ( cpu_T0 , cpu_T0 ) ; break ; default : case MO_SW : tcg_gen_ext16s_tl ( cpu_T0 , cpu_T0 ) ; break ; } } gen_op_mov_reg_v ( d_ot , reg , cpu_T0 ) ; } else { gen_lea_modrm ( env , s , modrm ) ; gen_op_ld_v ( s , s_ot , cpu_T0 , cpu_A0 ) ; gen_op_mov_reg_v ( d_ot , reg , cpu_T0 ) ; } } break ; case 0x8d : modrm = cpu_ldub_code ( env , s -> pc ++ ) ; mod = ( modrm >> 6 ) & 3 ; if ( mod == 3 ) goto illegal_op ; reg = ( ( modrm >> 3 ) & 7 ) | rex_r ; { AddressParts a = gen_lea_modrm_0 ( env , s , modrm ) ; TCGv ea = gen_lea_modrm_1 ( a ) ; gen_lea_v_seg ( s , s -> aflag , ea , - 1 , - 1 ) ; gen_op_mov_reg_v ( dflag , reg , cpu_A0 ) ; } break ; case 0xa0 : case 0xa1 : case 0xa2 : case 0xa3 : { target_ulong offset_addr ; ot = mo_b_d ( b , dflag ) ; switch ( s -> aflag ) { # ifdef TARGET_X86_64 case MO_64 : offset_addr = cpu_ldq_code ( env , s -> pc ) ; s -> pc += 8 ; break ; # endif default : offset_addr = insn_get ( env , s , s -> aflag ) ; break ; } tcg_gen_movi_tl ( cpu_A0 , offset_addr ) ; gen_add_A0_ds_seg ( s ) ; if ( ( b & 2 ) == 0 ) { gen_op_ld_v ( s , ot , cpu_T0 , cpu_A0 ) ; gen_op_mov_reg_v ( ot , R_EAX , cpu_T0 ) ; } else { gen_op_mov_v_reg ( ot , cpu_T0 , R_EAX ) ; gen_op_st_v ( s , ot , cpu_T0 , cpu_A0 ) ; } } break ; case 0xd7 : tcg_gen_mov_tl ( cpu_A0 , cpu_regs [ R_EBX ] ) ; tcg_gen_ext8u_tl ( cpu_T0 , cpu_regs [ R_EAX ] ) ; tcg_gen_add_tl ( cpu_A0 , cpu_A0 , cpu_T0 ) ; gen_extu ( s -> aflag , cpu_A0 ) ; gen_add_A0_ds_seg ( s ) ; gen_op_ld_v ( s , MO_8 , cpu_T0 , cpu_A0 ) ; gen_op_mov_reg_v ( MO_8 , R_EAX , cpu_T0 ) ; break ; case 0xb0 ... 0xb7 : val = insn_get ( env , s , MO_8 ) ; tcg_gen_movi_tl ( cpu_T0 , val ) ; gen_op_mov_reg_v ( MO_8 , ( b & 7 ) | REX_B ( s ) , cpu_T0 ) ; break ; case 0xb8 ... 0xbf : # ifdef TARGET_X86_64 if ( dflag == MO_64 ) { uint64_t tmp ; tmp = cpu_ldq_code ( env , s -> pc ) ; s -> pc += 8 ; reg = ( b & 7 ) | REX_B ( s ) ; tcg_gen_movi_tl ( cpu_T0 , tmp ) ; gen_op_mov_reg_v ( MO_64 , reg , cpu_T0 ) ; } else # endif { ot = dflag ; val = insn_get ( env , s , ot ) ; reg = ( b & 7 ) | REX_B ( s ) ; tcg_gen_movi_tl ( cpu_T0 , val ) ; gen_op_mov_reg_v ( ot , reg , cpu_T0 ) ; } break ; case 0x91 ... 0x97 : do_xchg_reg_eax : ot = dflag ; reg = ( b & 7 ) | REX_B ( s ) ; rm = R_EAX ; goto do_xchg_reg ; case 0x86 : case 0x87 : ot = mo_b_d ( b , dflag ) ; modrm = cpu_ldub_code ( env , s -> pc ++ ) ; reg = ( ( modrm >> 3 ) & 7 ) | rex_r ; mod = ( modrm >> 6 ) & 3 ; if ( mod == 3 ) { rm = ( modrm & 7 ) | REX_B ( s ) ; do_xchg_reg : gen_op_mov_v_reg ( ot , cpu_T0 , reg ) ; gen_op_mov_v_reg ( ot , cpu_T1 , rm ) ; gen_op_mov_reg_v ( ot , rm , cpu_T0 ) ; gen_op_mov_reg_v ( ot , reg , cpu_T1 ) ; } else { gen_lea_modrm ( env , s , modrm ) ; gen_op_mov_v_reg ( ot , cpu_T0 , reg ) ; tcg_gen_atomic_xchg_tl ( cpu_T1 , cpu_A0 , cpu_T0 , s -> mem_index , ot | MO_LE ) ; gen_op_mov_reg_v ( ot , reg , cpu_T1 ) ; } break ; case 0xc4 : op = R_ES ; goto do_lxx ; case 0xc5 : op = R_DS ; goto do_lxx ; case 0x1b2 : op = R_SS ; goto do_lxx ; case 0x1b4 : op = R_FS ; goto do_lxx ; case 0x1b5 : op = R_GS ; do_lxx : ot = dflag != MO_16 ? MO_32 : MO_16 ; modrm = cpu_ldub_code ( env , s -> pc ++ ) ; reg = ( ( modrm >> 3 ) & 7 ) | rex_r ; mod = ( modrm >> 6 ) & 3 ; if ( mod == 3 ) goto illegal_op ; gen_lea_modrm ( env , s , modrm ) ; gen_op_ld_v ( s , ot , cpu_T1 , cpu_A0 ) ; gen_add_A0_im ( s , 1 << ot ) ; gen_op_ld_v ( s , MO_16 , cpu_T0 , cpu_A0 ) ; gen_movl_seg_T0 ( s , op ) ; gen_op_mov_reg_v ( ot , reg , cpu_T1 ) ; if ( s -> is_jmp ) { gen_jmp_im ( s -> pc - s -> cs_base ) ; gen_eob ( s ) ; } break ; case 0xc0 : case 0xc1 : shift = 2 ; grp2 : { ot = mo_b_d ( b , dflag ) ; modrm = cpu_ldub_code ( env , s -> pc ++ ) ; mod = ( modrm >> 6 ) & 3 ; op = ( modrm >> 3 ) & 7 ; if ( mod != 3 ) { if ( shift == 2 ) { s -> rip_offset = 1 ; } gen_lea_modrm ( env , s , modrm ) ; opreg = OR_TMP0 ; } else { opreg = ( modrm & 7 ) | REX_B ( s ) ; } if ( shift == 0 ) { gen_shift ( s , op , ot , opreg , OR_ECX ) ; } else { if ( shift == 2 ) { shift = cpu_ldub_code ( env , s -> pc ++ ) ; } gen_shifti ( s , op , ot , opreg , shift ) ; } } break ; case 0xd0 : case 0xd1 : shift = 1 ; goto grp2 ; case 0xd2 : case 0xd3 : shift = 0 ; goto grp2 ; case 0x1a4 : op = 0 ; shift = 1 ; goto do_shiftd ; case 0x1a5 : op = 0 ; shift = 0 ; goto do_shiftd ; case 0x1ac : op = 1 ; shift = 1 ; goto do_shiftd ; case 0x1ad : op = 1 ; shift = 0 ; do_shiftd : ot = dflag ; modrm = cpu_ldub_code ( env , s -> pc ++ ) ; mod = ( modrm >> 6 ) & 3 ; rm = ( modrm & 7 ) | REX_B ( s ) ; reg = ( ( modrm >> 3 ) & 7 ) | rex_r ; if ( mod != 3 ) { gen_lea_modrm ( env , s , modrm ) ; opreg = OR_TMP0 ; } else { opreg = rm ; } gen_op_mov_v_reg ( ot , cpu_T1 , reg ) ; if ( shift ) { TCGv imm = tcg_const_tl ( cpu_ldub_code ( env , s -> pc ++ ) ) ; gen_shiftd_rm_T1 ( s , ot , opreg , op , imm ) ; tcg_temp_free ( imm ) ; } else { gen_shiftd_rm_T1 ( s , ot , opreg , op , cpu_regs [ R_ECX ] ) ; } break ; case 0xd8 ... 0xdf : if ( s -> flags & ( HF_EM_MASK | HF_TS_MASK ) ) { gen_exception ( s , EXCP07_PREX , pc_start - s -> cs_base ) ; break ; } modrm = cpu_ldub_code ( env , s -> pc ++ ) ; mod = ( modrm >> 6 ) & 3 ; rm = modrm & 7 ; op = ( ( b & 7 ) << 3 ) | ( ( modrm >> 3 ) & 7 ) ; if ( mod != 3 ) { gen_lea_modrm ( env , s , modrm ) ; switch ( op ) { case 0x00 ... 0x07 : case 0x10 ... 0x17 : case 0x20 ... 0x27 : case 0x30 ... 0x37 : { int op1 ; op1 = op & 7 ; switch ( op >> 4 ) { case 0 : tcg_gen_qemu_ld_i32 ( cpu_tmp2_i32 , cpu_A0 , s -> mem_index , MO_LEUL ) ; gen_helper_flds_FT0 ( cpu_env , cpu_tmp2_i32 ) ; break ; case 1 : tcg_gen_qemu_ld_i32 ( cpu_tmp2_i32 , cpu_A0 , s -> mem_index , MO_LEUL ) ; gen_helper_fildl_FT0 ( cpu_env , cpu_tmp2_i32 ) ; break ; case 2 : tcg_gen_qemu_ld_i64 ( cpu_tmp1_i64 , cpu_A0 , s -> mem_index , MO_LEQ ) ; gen_helper_fldl_FT0 ( cpu_env , cpu_tmp1_i64 ) ; break ; case 3 : default : tcg_gen_qemu_ld_i32 ( cpu_tmp2_i32 , cpu_A0 , s -> mem_index , MO_LESW ) ; gen_helper_fildl_FT0 ( cpu_env , cpu_tmp2_i32 ) ; break ; } gen_helper_fp_arith_ST0_FT0 ( op1 ) ; if ( op1 == 3 ) { gen_helper_fpop ( cpu_env ) ; } } break ; case 0x08 : case 0x0a : case 0x0b : case 0x18 ... 0x1b : case 0x28 ... 0x2b : case 0x38 ... 0x3b : switch ( op & 7 ) { case 0 : switch ( op >> 4 ) { case 0 : tcg_gen_qemu_ld_i32 ( cpu_tmp2_i32 , cpu_A0 , s -> mem_index , MO_LEUL ) ; gen_helper_flds_ST0 ( cpu_env , cpu_tmp2_i32 ) ; break ; case 1 : tcg_gen_qemu_ld_i32 ( cpu_tmp2_i32 , cpu_A0 , s -> mem_index , MO_LEUL ) ; gen_helper_fildl_ST0 ( cpu_env , cpu_tmp2_i32 ) ; break ; case 2 : tcg_gen_qemu_ld_i64 ( cpu_tmp1_i64 , cpu_A0 , s -> mem_index , MO_LEQ ) ; gen_helper_fldl_ST0 ( cpu_env , cpu_tmp1_i64 ) ; break ; case 3 : default : tcg_gen_qemu_ld_i32 ( cpu_tmp2_i32 , cpu_A0 , s -> mem_index , MO_LESW ) ; gen_helper_fildl_ST0 ( cpu_env , cpu_tmp2_i32 ) ; break ; } break ; case 1 : switch ( op >> 4 ) { case 1 : gen_helper_fisttl_ST0 ( cpu_tmp2_i32 , cpu_env ) ; tcg_gen_qemu_st_i32 ( cpu_tmp2_i32 , cpu_A0 , s -> mem_index , MO_LEUL ) ; break ; case 2 : gen_helper_fisttll_ST0 ( cpu_tmp1_i64 , cpu_env ) ; tcg_gen_qemu_st_i64 ( cpu_tmp1_i64 , cpu_A0 , s -> mem_index , MO_LEQ ) ; break ; case 3 : default : gen_helper_fistt_ST0 ( cpu_tmp2_i32 , cpu_env ) ; tcg_gen_qemu_st_i32 ( cpu_tmp2_i32 , cpu_A0 , s -> mem_index , MO_LEUW ) ; break ; } gen_helper_fpop ( cpu_env ) ; break ; default : switch ( op >> 4 ) { case 0 : gen_helper_fsts_ST0 ( cpu_tmp2_i32 , cpu_env ) ; tcg_gen_qemu_st_i32 ( cpu_tmp2_i32 , cpu_A0 , s -> mem_index , MO_LEUL ) ; break ; case 1 : gen_helper_fistl_ST0 ( cpu_tmp2_i32 , cpu_env ) ; tcg_gen_qemu_st_i32 ( cpu_tmp2_i32 , cpu_A0 , s -> mem_index , MO_LEUL ) ; break ; case 2 : gen_helper_fstl_ST0 ( cpu_tmp1_i64 , cpu_env ) ; tcg_gen_qemu_st_i64 ( cpu_tmp1_i64 , cpu_A0 , s -> mem_index , MO_LEQ ) ; break ; case 3 : default : gen_helper_fist_ST0 ( cpu_tmp2_i32 , cpu_env ) ; tcg_gen_qemu_st_i32 ( cpu_tmp2_i32 , cpu_A0 , s -> mem_index , MO_LEUW ) ; break ; } if ( ( op & 7 ) == 3 ) gen_helper_fpop ( cpu_env ) ; break ; } break ; case 0x0c : gen_helper_fldenv ( cpu_env , cpu_A0 , tcg_const_i32 ( dflag - 1 ) ) ; break ; case 0x0d : tcg_gen_qemu_ld_i32 ( cpu_tmp2_i32 , cpu_A0 , s -> mem_index , MO_LEUW ) ; gen_helper_fldcw ( cpu_env , cpu_tmp2_i32 ) ; break ; case 0x0e : gen_helper_fstenv ( cpu_env , cpu_A0 , tcg_const_i32 ( dflag - 1 ) ) ; break ; case 0x0f : gen_helper_fnstcw ( cpu_tmp2_i32 , cpu_env ) ; tcg_gen_qemu_st_i32 ( cpu_tmp2_i32 , cpu_A0 , s -> mem_index , MO_LEUW ) ; break ; case 0x1d : gen_helper_fldt_ST0 ( cpu_env , cpu_A0 ) ; break ; case 0x1f : gen_helper_fstt_ST0 ( cpu_env , cpu_A0 ) ; gen_helper_fpop ( cpu_env ) ; break ; case 0x2c : gen_helper_frstor ( cpu_env , cpu_A0 , tcg_const_i32 ( dflag - 1 ) ) ; break ; case 0x2e : gen_helper_fsave ( cpu_env , cpu_A0 , tcg_const_i32 ( dflag - 1 ) ) ; break ; case 0x2f : gen_helper_fnstsw ( cpu_tmp2_i32 , cpu_env ) ; tcg_gen_qemu_st_i32 ( cpu_tmp2_i32 , cpu_A0 , s -> mem_index , MO_LEUW ) ; break ; case 0x3c : gen_helper_fbld_ST0 ( cpu_env , cpu_A0 ) ; break ; case 0x3e : gen_helper_fbst_ST0 ( cpu_env , cpu_A0 ) ; gen_helper_fpop ( cpu_env ) ; break ; case 0x3d : tcg_gen_qemu_ld_i64 ( cpu_tmp1_i64 , cpu_A0 , s -> mem_index , MO_LEQ ) ; gen_helper_fildll_ST0 ( cpu_env , cpu_tmp1_i64 ) ; break ; case 0x3f : gen_helper_fistll_ST0 ( cpu_tmp1_i64 , cpu_env ) ; tcg_gen_qemu_st_i64 ( cpu_tmp1_i64 , cpu_A0 , s -> mem_index , MO_LEQ ) ; gen_helper_fpop ( cpu_env ) ; break ; default : goto unknown_op ; } } else { opreg = rm ; switch ( op ) { case 0x08 : gen_helper_fpush ( cpu_env ) ; gen_helper_fmov_ST0_STN ( cpu_env , tcg_const_i32 ( ( opreg + 1 ) & 7 ) ) ; break ; case 0x09 : case 0x29 : case 0x39 : gen_helper_fxchg_ST0_STN ( cpu_env , tcg_const_i32 ( opreg ) ) ; break ; case 0x0a : switch ( rm ) { case 0 : gen_helper_fwait ( cpu_env ) ; break ; default : goto unknown_op ; } break ; case 0x0c : switch ( rm ) { case 0 : gen_helper_fchs_ST0 ( cpu_env ) ; break ; case 1 : gen_helper_fabs_ST0 ( cpu_env ) ; break ; case 4 : gen_helper_fldz_FT0 ( cpu_env ) ; gen_helper_fcom_ST0_FT0 ( cpu_env ) ; break ; case 5 : gen_helper_fxam_ST0 ( cpu_env ) ; break ; default : goto unknown_op ; } break ; case 0x0d : { switch ( rm ) { case 0 : gen_helper_fpush ( cpu_env ) ; gen_helper_fld1_ST0 ( cpu_env ) ; break ; case 1 : gen_helper_fpush ( cpu_env ) ; gen_helper_fldl2t_ST0 ( cpu_env ) ; break ; case 2 : gen_helper_fpush ( cpu_env ) ; gen_helper_fldl2e_ST0 ( cpu_env ) ; break ; case 3 : gen_helper_fpush ( cpu_env ) ; gen_helper_fldpi_ST0 ( cpu_env ) ; break ; case 4 : gen_helper_fpush ( cpu_env ) ; gen_helper_fldlg2_ST0 ( cpu_env ) ; break ; case 5 : gen_helper_fpush ( cpu_env ) ; gen_helper_fldln2_ST0 ( cpu_env ) ; break ; case 6 : gen_helper_fpush ( cpu_env ) ; gen_helper_fldz_ST0 ( cpu_env ) ; break ; default : goto unknown_op ; } } break ; case 0x0e : switch ( rm ) { case 0 : gen_helper_f2xm1 ( cpu_env ) ; break ; case 1 : gen_helper_fyl2x ( cpu_env ) ; break ; case 2 : gen_helper_fptan ( cpu_env ) ; break ; case 3 : gen_helper_fpatan ( cpu_env ) ; break ; case 4 : gen_helper_fxtract ( cpu_env ) ; break ; case 5 : gen_helper_fprem1 ( cpu_env ) ; break ; case 6 : gen_helper_fdecstp ( cpu_env ) ; break ; default : case 7 : gen_helper_fincstp ( cpu_env ) ; break ; } break ; case 0x0f : switch ( rm ) { case 0 : gen_helper_fprem ( cpu_env ) ; break ; case 1 : gen_helper_fyl2xp1 ( cpu_env ) ; break ; case 2 : gen_helper_fsqrt ( cpu_env ) ; break ; case 3 : gen_helper_fsincos ( cpu_env ) ; break ; case 5 : gen_helper_fscale ( cpu_env ) ; break ; case 4 : gen_helper_frndint ( cpu_env ) ; break ; case 6 : gen_helper_fsin ( cpu_env ) ; break ; default : case 7 : gen_helper_fcos ( cpu_env ) ; break ; } break ; case 0x00 : case 0x01 : case 0x04 ... 0x07 : case 0x20 : case 0x21 : case 0x24 ... 0x27 : case 0x30 : case 0x31 : case 0x34 ... 0x37 : { int op1 ; op1 = op & 7 ; if ( op >= 0x20 ) { gen_helper_fp_arith_STN_ST0 ( op1 , opreg ) ; if ( op >= 0x30 ) gen_helper_fpop ( cpu_env ) ; } else { gen_helper_fmov_FT0_STN ( cpu_env , tcg_const_i32 ( opreg ) ) ; gen_helper_fp_arith_ST0_FT0 ( op1 ) ; } } break ; case 0x02 : case 0x22 : gen_helper_fmov_FT0_STN ( cpu_env , tcg_const_i32 ( opreg ) ) ; gen_helper_fcom_ST0_FT0 ( cpu_env ) ; break ; case 0x03 : case 0x23 : case 0x32 : gen_helper_fmov_FT0_STN ( cpu_env , tcg_const_i32 ( opreg ) ) ; gen_helper_fcom_ST0_FT0 ( cpu_env ) ; gen_helper_fpop ( cpu_env ) ; break ; case 0x15 : switch ( rm ) { case 1 : gen_helper_fmov_FT0_STN ( cpu_env , tcg_const_i32 ( 1 ) ) ; gen_helper_fucom_ST0_FT0 ( cpu_env ) ; gen_helper_fpop ( cpu_env ) ; gen_helper_fpop ( cpu_env ) ; break ; default : goto unknown_op ; } break ; case 0x1c : switch ( rm ) { case 0 : break ; case 1 : break ; case 2 : gen_helper_fclex ( cpu_env ) ; break ; case 3 : gen_helper_fninit ( cpu_env ) ; break ; case 4 : break ; default : goto unknown_op ; } break ; case 0x1d : if ( ! ( s -> cpuid_features & CPUID_CMOV ) ) { goto illegal_op ; } gen_update_cc_op ( s ) ; gen_helper_fmov_FT0_STN ( cpu_env , tcg_const_i32 ( opreg ) ) ; gen_helper_fucomi_ST0_FT0 ( cpu_env ) ; set_cc_op ( s , CC_OP_EFLAGS ) ; break ; case 0x1e : if ( ! ( s -> cpuid_features & CPUID_CMOV ) ) { goto illegal_op ; } gen_update_cc_op ( s ) ; gen_helper_fmov_FT0_STN ( cpu_env , tcg_const_i32 ( opreg ) ) ; gen_helper_fcomi_ST0_FT0 ( cpu_env ) ; set_cc_op ( s , CC_OP_EFLAGS ) ; break ; case 0x28 : gen_helper_ffree_STN ( cpu_env , tcg_const_i32 ( opreg ) ) ; break ; case 0x2a : gen_helper_fmov_STN_ST0 ( cpu_env , tcg_const_i32 ( opreg ) ) ; break ; case 0x2b : case 0x0b : case 0x3a : case 0x3b : gen_helper_fmov_STN_ST0 ( cpu_env , tcg_const_i32 ( opreg ) ) ; gen_helper_fpop ( cpu_env ) ; break ; case 0x2c : gen_helper_fmov_FT0_STN ( cpu_env , tcg_const_i32 ( opreg ) ) ; gen_helper_fucom_ST0_FT0 ( cpu_env ) ; break ; case 0x2d : gen_helper_fmov_FT0_STN ( cpu_env , tcg_const_i32 ( opreg ) ) ; gen_helper_fucom_ST0_FT0 ( cpu_env ) ; gen_helper_fpop ( cpu_env ) ; break ; case 0x33 : switch ( rm ) { case 1 : gen_helper_fmov_FT0_STN ( cpu_env , tcg_const_i32 ( 1 ) ) ; gen_helper_fcom_ST0_FT0 ( cpu_env ) ; gen_helper_fpop ( cpu_env ) ; gen_helper_fpop ( cpu_env ) ; break ; default : goto unknown_op ; } break ; case 0x38 : gen_helper_ffree_STN ( cpu_env , tcg_const_i32 ( opreg ) ) ; gen_helper_fpop ( cpu_env ) ; break ; case 0x3c : switch ( rm ) { case 0 : gen_helper_fnstsw ( cpu_tmp2_i32 , cpu_env ) ; tcg_gen_extu_i32_tl ( cpu_T0 , cpu_tmp2_i32 ) ; gen_op_mov_reg_v ( MO_16 , R_EAX , cpu_T0 ) ; break ; default : goto unknown_op ; } break ; case 0x3d : if ( ! ( s -> cpuid_features & CPUID_CMOV ) ) { goto illegal_op ; } gen_update_cc_op ( s ) ; gen_helper_fmov_FT0_STN ( cpu_env , tcg_const_i32 ( opreg ) ) ; gen_helper_fucomi_ST0_FT0 ( cpu_env ) ; gen_helper_fpop ( cpu_env ) ; set_cc_op ( s , CC_OP_EFLAGS ) ; break ; case 0x3e : if ( ! ( s -> cpuid_features & CPUID_CMOV ) ) { goto illegal_op ; } gen_update_cc_op ( s ) ; gen_helper_fmov_FT0_STN ( cpu_env , tcg_const_i32 ( opreg ) ) ; gen_helper_fcomi_ST0_FT0 ( cpu_env ) ; gen_helper_fpop ( cpu_env ) ; set_cc_op ( s , CC_OP_EFLAGS ) ; break ; case 0x10 ... 0x13 : case 0x18 ... 0x1b : { int op1 ; TCGLabel * l1 ; static const uint8_t fcmov_cc [ 8 ] = { ( JCC_B << 1 ) , ( JCC_Z << 1 ) , ( JCC_BE << 1 ) , ( JCC_P << 1 ) , } ; if ( ! ( s -> cpuid_features & CPUID_CMOV ) ) { goto illegal_op ; } op1 = fcmov_cc [ op & 3 ] | ( ( ( op >> 3 ) & 1 ) ^ 1 ) ; l1 = gen_new_label ( ) ; gen_jcc1_noeob ( s , op1 , l1 ) ; gen_helper_fmov_ST0_STN ( cpu_env , tcg_const_i32 ( opreg ) ) ; gen_set_label ( l1 ) ; } break ; default : goto unknown_op ; } } break ; case 0xa4 : case 0xa5 : ot = mo_b_d ( b , dflag ) ; if ( prefixes & ( PREFIX_REPZ | PREFIX_REPNZ ) ) { gen_repz_movs ( s , ot , pc_start - s -> cs_base , s -> pc - s -> cs_base ) ; } else { gen_movs ( s , ot ) ; } break ; case 0xaa : case 0xab : ot = mo_b_d ( b , dflag ) ; if ( prefixes & ( PREFIX_REPZ | PREFIX_REPNZ ) ) { gen_repz_stos ( s , ot , pc_start - s -> cs_base , s -> pc - s -> cs_base ) ; } else { gen_stos ( s , ot ) ; } break ; case 0xac : case 0xad : ot = mo_b_d ( b , dflag ) ; if ( prefixes & ( PREFIX_REPZ | PREFIX_REPNZ ) ) { gen_repz_lods ( s , ot , pc_start - s -> cs_base , s -> pc - s -> cs_base ) ; } else { gen_lods ( s , ot ) ; } break ; case 0xae : case 0xaf : ot = mo_b_d ( b , dflag ) ; if ( prefixes & PREFIX_REPNZ ) { gen_repz_scas ( s , ot , pc_start - s -> cs_base , s -> pc - s -> cs_base , 1 ) ; } else if ( prefixes & PREFIX_REPZ ) { gen_repz_scas ( s , ot , pc_start - s -> cs_base , s -> pc - s -> cs_base , 0 ) ; } else { gen_scas ( s , ot ) ; } break ; case 0xa6 : case 0xa7 : ot = mo_b_d ( b , dflag ) ; if ( prefixes & PREFIX_REPNZ ) { gen_repz_cmps ( s , ot , pc_start - s -> cs_base , s -> pc - s -> cs_base , 1 ) ; } else if ( prefixes & PREFIX_REPZ ) { gen_repz_cmps ( s , ot , pc_start - s -> cs_base , s -> pc - s -> cs_base , 0 ) ; } else { gen_cmps ( s , ot ) ; } break ; case 0x6c : case 0x6d : ot = mo_b_d32 ( b , dflag ) ; tcg_gen_ext16u_tl ( cpu_T0 , cpu_regs [ R_EDX ] ) ; gen_check_io ( s , ot , pc_start - s -> cs_base , SVM_IOIO_TYPE_MASK | svm_is_rep ( prefixes ) | 4 ) ; if ( prefixes & ( PREFIX_REPZ | PREFIX_REPNZ ) ) { gen_repz_ins ( s , ot , pc_start - s -> cs_base , s -> pc - s -> cs_base ) ; } else { gen_ins ( s , ot ) ; if ( s -> tb -> cflags & CF_USE_ICOUNT ) { gen_jmp ( s , s -> pc - s -> cs_base ) ; } } break ; case 0x6e : case 0x6f : ot = mo_b_d32 ( b , dflag ) ; tcg_gen_ext16u_tl ( cpu_T0 , cpu_regs [ R_EDX ] ) ; gen_check_io ( s , ot , pc_start - s -> cs_base , svm_is_rep ( prefixes ) | 4 ) ; if ( prefixes & ( PREFIX_REPZ | PREFIX_REPNZ ) ) { gen_repz_outs ( s , ot , pc_start - s -> cs_base , s -> pc - s -> cs_base ) ; } else { gen_outs ( s , ot ) ; if ( s -> tb -> cflags & CF_USE_ICOUNT ) { gen_jmp ( s , s -> pc - s -> cs_base ) ; } } break ; case 0xe4 : case 0xe5 : ot = mo_b_d32 ( b , dflag ) ; val = cpu_ldub_code ( env , s -> pc ++ ) ; tcg_gen_movi_tl ( cpu_T0 , val ) ; gen_check_io ( s , ot , pc_start - s -> cs_base , SVM_IOIO_TYPE_MASK | svm_is_rep ( prefixes ) ) ; if ( s -> tb -> cflags & CF_USE_ICOUNT ) { gen_io_start ( ) ; } tcg_gen_movi_i32 ( cpu_tmp2_i32 , val ) ; gen_helper_in_func ( ot , cpu_T1 , cpu_tmp2_i32 ) ; gen_op_mov_reg_v ( ot , R_EAX , cpu_T1 ) ; gen_bpt_io ( s , cpu_tmp2_i32 , ot ) ; if ( s -> tb -> cflags & CF_USE_ICOUNT ) { gen_io_end ( ) ; gen_jmp ( s , s -> pc - s -> cs_base ) ; } break ; case 0xe6 : case 0xe7 : ot = mo_b_d32 ( b , dflag ) ; val = cpu_ldub_code ( env , s -> pc ++ ) ; tcg_gen_movi_tl ( cpu_T0 , val ) ; gen_check_io ( s , ot , pc_start - s -> cs_base , svm_is_rep ( prefixes ) ) ; gen_op_mov_v_reg ( ot , cpu_T1 , R_EAX ) ; if ( s -> tb -> cflags & CF_USE_ICOUNT ) { gen_io_start ( ) ; } tcg_gen_movi_i32 ( cpu_tmp2_i32 , val ) ; tcg_gen_trunc_tl_i32 ( cpu_tmp3_i32 , cpu_T1 ) ; gen_helper_out_func ( ot , cpu_tmp2_i32 , cpu_tmp3_i32 ) ; gen_bpt_io ( s , cpu_tmp2_i32 , ot ) ; if ( s -> tb -> cflags & CF_USE_ICOUNT ) { gen_io_end ( ) ; gen_jmp ( s , s -> pc - s -> cs_base ) ; } break ; case 0xec : case 0xed : ot = mo_b_d32 ( b , dflag ) ; tcg_gen_ext16u_tl ( cpu_T0 , cpu_regs [ R_EDX ] ) ; gen_check_io ( s , ot , pc_start - s -> cs_base , SVM_IOIO_TYPE_MASK | svm_is_rep ( prefixes ) ) ; if ( s -> tb -> cflags & CF_USE_ICOUNT ) { gen_io_start ( ) ; } tcg_gen_trunc_tl_i32 ( cpu_tmp2_i32 , cpu_T0 ) ; gen_helper_in_func ( ot , cpu_T1 , cpu_tmp2_i32 ) ; gen_op_mov_reg_v ( ot , R_EAX , cpu_T1 ) ; gen_bpt_io ( s , cpu_tmp2_i32 , ot ) ; if ( s -> tb -> cflags & CF_USE_ICOUNT ) { gen_io_end ( ) ; gen_jmp ( s , s -> pc - s -> cs_base ) ; } break ; case 0xee : case 0xef : ot = mo_b_d32 ( b , dflag ) ; tcg_gen_ext16u_tl ( cpu_T0 , cpu_regs [ R_EDX ] ) ; gen_check_io ( s , ot , pc_start - s -> cs_base , svm_is_rep ( prefixes ) ) ; gen_op_mov_v_reg ( ot , cpu_T1 , R_EAX ) ; if ( s -> tb -> cflags & CF_USE_ICOUNT ) { gen_io_start ( ) ; } tcg_gen_trunc_tl_i32 ( cpu_tmp2_i32 , cpu_T0 ) ; tcg_gen_trunc_tl_i32 ( cpu_tmp3_i32 , cpu_T1 ) ; gen_helper_out_func ( ot , cpu_tmp2_i32 , cpu_tmp3_i32 ) ; gen_bpt_io ( s , cpu_tmp2_i32 , ot ) ; if ( s -> tb -> cflags & CF_USE_ICOUNT ) { gen_io_end ( ) ; gen_jmp ( s , s -> pc - s -> cs_base ) ; } break ; case 0xc2 : val = cpu_ldsw_code ( env , s -> pc ) ; s -> pc += 2 ; ot = gen_pop_T0 ( s ) ; gen_stack_update ( s , val + ( 1 << ot ) ) ; gen_op_jmp_v ( cpu_T0 ) ; gen_bnd_jmp ( s ) ; gen_eob ( s ) ; break ; case 0xc3 : ot = gen_pop_T0 ( s ) ; gen_pop_update ( s , ot ) ; gen_op_jmp_v ( cpu_T0 ) ; gen_bnd_jmp ( s ) ; gen_eob ( s ) ; break ; case 0xca : val = cpu_ldsw_code ( env , s -> pc ) ; s -> pc += 2 ; do_lret : if ( s -> pe && ! s -> vm86 ) { gen_update_cc_op ( s ) ; gen_jmp_im ( pc_start - s -> cs_base ) ; gen_helper_lret_protected ( cpu_env , tcg_const_i32 ( dflag - 1 ) , tcg_const_i32 ( val ) ) ; } else { gen_stack_A0 ( s ) ; gen_op_ld_v ( s , dflag , cpu_T0 , cpu_A0 ) ; gen_op_jmp_v ( cpu_T0 ) ; gen_add_A0_im ( s , 1 << dflag ) ; gen_op_ld_v ( s , dflag , cpu_T0 , cpu_A0 ) ; gen_op_movl_seg_T0_vm ( R_CS ) ; gen_stack_update ( s , val + ( 2 << dflag ) ) ; } gen_eob ( s ) ; break ; case 0xcb : val = 0 ; goto do_lret ; case 0xcf : gen_svm_check_intercept ( s , pc_start , SVM_EXIT_IRET ) ; if ( ! s -> pe ) { gen_helper_iret_real ( cpu_env , tcg_const_i32 ( dflag - 1 ) ) ; set_cc_op ( s , CC_OP_EFLAGS ) ; } else if ( s -> vm86 ) { if ( s -> iopl != 3 ) { gen_exception ( s , EXCP0D_GPF , pc_start - s -> cs_base ) ; } else { gen_helper_iret_real ( cpu_env , tcg_const_i32 ( dflag - 1 ) ) ; set_cc_op ( s , CC_OP_EFLAGS ) ; } } else { gen_helper_iret_protected ( cpu_env , tcg_const_i32 ( dflag - 1 ) , tcg_const_i32 ( s -> pc - s -> cs_base ) ) ; set_cc_op ( s , CC_OP_EFLAGS ) ; } gen_eob ( s ) ; break ; case 0xe8 : { if ( dflag != MO_16 ) { tval = ( int32_t ) insn_get ( env , s , MO_32 ) ; } else { tval = ( int16_t ) insn_get ( env , s , MO_16 ) ; } next_eip = s -> pc - s -> cs_base ; tval += next_eip ; if ( dflag == MO_16 ) { tval &= 0xffff ; } else if ( ! CODE64 ( s ) ) { tval &= 0xffffffff ; } tcg_gen_movi_tl ( cpu_T0 , next_eip ) ; gen_push_v ( s , cpu_T0 ) ; gen_bnd_jmp ( s ) ; gen_jmp ( s , tval ) ; } break ; case 0x9a : { unsigned int selector , offset ; if ( CODE64 ( s ) ) goto illegal_op ; ot = dflag ; offset = insn_get ( env , s , ot ) ; selector = insn_get ( env , s , MO_16 ) ; tcg_gen_movi_tl ( cpu_T0 , selector ) ; tcg_gen_movi_tl ( cpu_T1 , offset ) ; } goto do_lcall ; case 0xe9 : if ( dflag != MO_16 ) { tval = ( int32_t ) insn_get ( env , s , MO_32 ) ; } else { tval = ( int16_t ) insn_get ( env , s , MO_16 ) ; } tval += s -> pc - s -> cs_base ; if ( dflag == MO_16 ) { tval &= 0xffff ; } else if ( ! CODE64 ( s ) ) { tval &= 0xffffffff ; } gen_bnd_jmp ( s ) ; gen_jmp ( s , tval ) ; break ; case 0xea : { unsigned int selector , offset ; if ( CODE64 ( s ) ) goto illegal_op ; ot = dflag ; offset = insn_get ( env , s , ot ) ; selector = insn_get ( env , s , MO_16 ) ; tcg_gen_movi_tl ( cpu_T0 , selector ) ; tcg_gen_movi_tl ( cpu_T1 , offset ) ; } goto do_ljmp ; case 0xeb : tval = ( int8_t ) insn_get ( env , s , MO_8 ) ; tval += s -> pc - s -> cs_base ; if ( dflag == MO_16 ) { tval &= 0xffff ; } gen_jmp ( s , tval ) ; break ; case 0x70 ... 0x7f : tval = ( int8_t ) insn_get ( env , s , MO_8 ) ; goto do_jcc ; case 0x180 ... 0x18f : if ( dflag != MO_16 ) { tval = ( int32_t ) insn_get ( env , s , MO_32 ) ; } else { tval = ( int16_t ) insn_get ( env , s , MO_16 ) ; } do_jcc : next_eip = s -> pc - s -> cs_base ; tval += next_eip ; if ( dflag == MO_16 ) { tval &= 0xffff ; } gen_bnd_jmp ( s ) ; gen_jcc ( s , b , tval , next_eip ) ; break ; case 0x190 ... 0x19f : modrm = cpu_ldub_code ( env , s -> pc ++ ) ; gen_setcc1 ( s , b , cpu_T0 ) ; gen_ldst_modrm ( env , s , modrm , MO_8 , OR_TMP0 , 1 ) ; break ; case 0x140 ... 0x14f : if ( ! ( s -> cpuid_features & CPUID_CMOV ) ) { goto illegal_op ; } ot = dflag ; modrm = cpu_ldub_code ( env , s -> pc ++ ) ; reg = ( ( modrm >> 3 ) & 7 ) | rex_r ; gen_cmovcc1 ( env , s , ot , b , modrm , reg ) ; break ; case 0x9c : gen_svm_check_intercept ( s , pc_start , SVM_EXIT_PUSHF ) ; if ( s -> vm86 && s -> iopl != 3 ) { gen_exception ( s , EXCP0D_GPF , pc_start - s -> cs_base ) ; } else { gen_update_cc_op ( s ) ; gen_helper_read_eflags ( cpu_T0 , cpu_env ) ; gen_push_v ( s , cpu_T0 ) ; } break ; case 0x9d : gen_svm_check_intercept ( s , pc_start , SVM_EXIT_POPF ) ; if ( s -> vm86 && s -> iopl != 3 ) { gen_exception ( s , EXCP0D_GPF , pc_start - s -> cs_base ) ; } else { ot = gen_pop_T0 ( s ) ; if ( s -> cpl == 0 ) { if ( dflag != MO_16 ) { gen_helper_write_eflags ( cpu_env , cpu_T0 , tcg_const_i32 ( ( TF_MASK | AC_MASK | ID_MASK | NT_MASK | IF_MASK | IOPL_MASK ) ) ) ; } else { gen_helper_write_eflags ( cpu_env , cpu_T0 , tcg_const_i32 ( ( TF_MASK | AC_MASK | ID_MASK | NT_MASK | IF_MASK | IOPL_MASK ) & 0xffff ) ) ; } } else { if ( s -> cpl <= s -> iopl ) { if ( dflag != MO_16 ) { gen_helper_write_eflags ( cpu_env , cpu_T0 , tcg_const_i32 ( ( TF_MASK | AC_MASK | ID_MASK | NT_MASK | IF_MASK ) ) ) ; } else { gen_helper_write_eflags ( cpu_env , cpu_T0 , tcg_const_i32 ( ( TF_MASK | AC_MASK | ID_MASK | NT_MASK | IF_MASK ) & 0xffff ) ) ; } } else { if ( dflag != MO_16 ) { gen_helper_write_eflags ( cpu_env , cpu_T0 , tcg_const_i32 ( ( TF_MASK | AC_MASK | ID_MASK | NT_MASK ) ) ) ; } else { gen_helper_write_eflags ( cpu_env , cpu_T0 , tcg_const_i32 ( ( TF_MASK | AC_MASK | ID_MASK | NT_MASK ) & 0xffff ) ) ; } } } gen_pop_update ( s , ot ) ; set_cc_op ( s , CC_OP_EFLAGS ) ; gen_jmp_im ( s -> pc - s -> cs_base ) ; gen_eob ( s ) ; } break ; case 0x9e : if ( CODE64 ( s ) && ! ( s -> cpuid_ext3_features & CPUID_EXT3_LAHF_LM ) ) goto illegal_op ; gen_op_mov_v_reg ( MO_8 , cpu_T0 , R_AH ) ; gen_compute_eflags ( s ) ; tcg_gen_andi_tl ( cpu_cc_src , cpu_cc_src , CC_O ) ; tcg_gen_andi_tl ( cpu_T0 , cpu_T0 , CC_S | CC_Z | CC_A | CC_P | CC_C ) ; tcg_gen_or_tl ( cpu_cc_src , cpu_cc_src , cpu_T0 ) ; break ; case 0x9f : if ( CODE64 ( s ) && ! ( s -> cpuid_ext3_features & CPUID_EXT3_LAHF_LM ) ) goto illegal_op ; gen_compute_eflags ( s ) ; tcg_gen_ori_tl ( cpu_T0 , cpu_cc_src , 0x02 ) ; gen_op_mov_reg_v ( MO_8 , R_AH , cpu_T0 ) ; break ; case 0xf5 : gen_compute_eflags ( s ) ; tcg_gen_xori_tl ( cpu_cc_src , cpu_cc_src , CC_C ) ; break ; case 0xf8 : gen_compute_eflags ( s ) ; tcg_gen_andi_tl ( cpu_cc_src , cpu_cc_src , ~ CC_C ) ; break ; case 0xf9 : gen_compute_eflags ( s ) ; tcg_gen_ori_tl ( cpu_cc_src , cpu_cc_src , CC_C ) ; break ; case 0xfc : tcg_gen_movi_i32 ( cpu_tmp2_i32 , 1 ) ; tcg_gen_st_i32 ( cpu_tmp2_i32 , cpu_env , offsetof ( CPUX86State , df ) ) ; break ; case 0xfd : tcg_gen_movi_i32 ( cpu_tmp2_i32 , - 1 ) ; tcg_gen_st_i32 ( cpu_tmp2_i32 , cpu_env , offsetof ( CPUX86State , df ) ) ; break ; case 0x1ba : ot = dflag ; modrm = cpu_ldub_code ( env , s -> pc ++ ) ; op = ( modrm >> 3 ) & 7 ; mod = ( modrm >> 6 ) & 3 ; rm = ( modrm & 7 ) | REX_B ( s ) ; if ( mod != 3 ) { s -> rip_offset = 1 ; gen_lea_modrm ( env , s , modrm ) ; if ( ! ( s -> prefix & PREFIX_LOCK ) ) { gen_op_ld_v ( s , ot , cpu_T0 , cpu_A0 ) ; } } else { gen_op_mov_v_reg ( ot , cpu_T0 , rm ) ; } val = cpu_ldub_code ( env , s -> pc ++ ) ; tcg_gen_movi_tl ( cpu_T1 , val ) ; if ( op < 4 ) goto unknown_op ; op -= 4 ; goto bt_op ; case 0x1a3 : op = 0 ; goto do_btx ; case 0x1ab : op = 1 ; goto do_btx ; case 0x1b3 : op = 2 ; goto do_btx ; case 0x1bb : op = 3 ; do_btx : ot = dflag ; modrm = cpu_ldub_code ( env , s -> pc ++ ) ; reg = ( ( modrm >> 3 ) & 7 ) | rex_r ; mod = ( modrm >> 6 ) & 3 ; rm = ( modrm & 7 ) | REX_B ( s ) ; gen_op_mov_v_reg ( MO_32 , cpu_T1 , reg ) ; if ( mod != 3 ) { AddressParts a = gen_lea_modrm_0 ( env , s , modrm ) ; gen_exts ( ot , cpu_T1 ) ; tcg_gen_sari_tl ( cpu_tmp0 , cpu_T1 , 3 + ot ) ; tcg_gen_shli_tl ( cpu_tmp0 , cpu_tmp0 , ot ) ; tcg_gen_add_tl ( cpu_A0 , gen_lea_modrm_1 ( a ) , cpu_tmp0 ) ; gen_lea_v_seg ( s , s -> aflag , cpu_A0 , a . def_seg , s -> override ) ; if ( ! ( s -> prefix & PREFIX_LOCK ) ) { gen_op_ld_v ( s , ot , cpu_T0 , cpu_A0 ) ; } } else { gen_op_mov_v_reg ( ot , cpu_T0 , rm ) ; } bt_op : tcg_gen_andi_tl ( cpu_T1 , cpu_T1 , ( 1 << ( 3 + ot ) ) - 1 ) ; tcg_gen_movi_tl ( cpu_tmp0 , 1 ) ; tcg_gen_shl_tl ( cpu_tmp0 , cpu_tmp0 , cpu_T1 ) ; if ( s -> prefix & PREFIX_LOCK ) { switch ( op ) { case 0 : gen_op_ld_v ( s , ot , cpu_T0 , cpu_A0 ) ; break ; case 1 : tcg_gen_atomic_fetch_or_tl ( cpu_T0 , cpu_A0 , cpu_tmp0 , s -> mem_index , ot | MO_LE ) ; break ; case 2 : tcg_gen_not_tl ( cpu_tmp0 , cpu_tmp0 ) ; tcg_gen_atomic_fetch_and_tl ( cpu_T0 , cpu_A0 , cpu_tmp0 , s -> mem_index , ot | MO_LE ) ; break ; default : case 3 : tcg_gen_atomic_fetch_xor_tl ( cpu_T0 , cpu_A0 , cpu_tmp0 , s -> mem_index , ot | MO_LE ) ; break ; } tcg_gen_shr_tl ( cpu_tmp4 , cpu_T0 , cpu_T1 ) ; } else { tcg_gen_shr_tl ( cpu_tmp4 , cpu_T0 , cpu_T1 ) ; switch ( op ) { case 0 : break ; case 1 : tcg_gen_or_tl ( cpu_T0 , cpu_T0 , cpu_tmp0 ) ; break ; case 2 : tcg_gen_andc_tl ( cpu_T0 , cpu_T0 , cpu_tmp0 ) ; break ; default : case 3 : tcg_gen_xor_tl ( cpu_T0 , cpu_T0 , cpu_tmp0 ) ; break ; } if ( op != 0 ) { if ( mod != 3 ) { gen_op_st_v ( s , ot , cpu_T0 , cpu_A0 ) ; } else { gen_op_mov_reg_v ( ot , rm , cpu_T0 ) ; } } } switch ( s -> cc_op ) { case CC_OP_MULB ... CC_OP_MULQ : case CC_OP_ADDB ... CC_OP_ADDQ : case CC_OP_ADCB ... CC_OP_ADCQ : case CC_OP_SUBB ... CC_OP_SUBQ : case CC_OP_SBBB ... CC_OP_SBBQ : case CC_OP_LOGICB ... CC_OP_LOGICQ : case CC_OP_INCB ... CC_OP_INCQ : case CC_OP_DECB ... CC_OP_DECQ : case CC_OP_SHLB ... CC_OP_SHLQ : case CC_OP_SARB ... CC_OP_SARQ : case CC_OP_BMILGB ... CC_OP_BMILGQ : tcg_gen_mov_tl ( cpu_cc_src , cpu_tmp4 ) ; set_cc_op ( s , ( ( s -> cc_op - CC_OP_MULB ) & 3 ) + CC_OP_SARB ) ; break ; default : gen_compute_eflags ( s ) ; tcg_gen_deposit_tl ( cpu_cc_src , cpu_cc_src , cpu_tmp4 , ctz32 ( CC_C ) , 1 ) ; break ; } break ; case 0x1bc : case 0x1bd : ot = dflag ; modrm = cpu_ldub_code ( env , s -> pc ++ ) ; reg = ( ( modrm >> 3 ) & 7 ) | rex_r ; gen_ldst_modrm ( env , s , modrm , ot , OR_TMP0 , 0 ) ; gen_extu ( ot , cpu_T0 ) ; if ( ( prefixes & PREFIX_REPZ ) && ( b & 1 ? s -> cpuid_ext3_features & CPUID_EXT3_ABM : s -> cpuid_7_0_ebx_features & CPUID_7_0_EBX_BMI1 ) ) { int size = 8 << ot ; tcg_gen_mov_tl ( cpu_cc_src , cpu_T0 ) ; if ( b & 1 ) { tcg_gen_clzi_tl ( cpu_T0 , cpu_T0 , TARGET_LONG_BITS ) ; tcg_gen_subi_tl ( cpu_T0 , cpu_T0 , TARGET_LONG_BITS - size ) ; } else { tcg_gen_ctzi_tl ( cpu_T0 , cpu_T0 , size ) ; } gen_op_update1_cc ( ) ; set_cc_op ( s , CC_OP_BMILGB + ot ) ; } else { tcg_gen_mov_tl ( cpu_cc_dst , cpu_T0 ) ; set_cc_op ( s , CC_OP_LOGICB + ot ) ; if ( b & 1 ) { tcg_gen_xori_tl ( cpu_T1 , cpu_regs [ reg ] , TARGET_LONG_BITS - 1 ) ; tcg_gen_clz_tl ( cpu_T0 , cpu_T0 , cpu_T1 ) ; tcg_gen_xori_tl ( cpu_T0 , cpu_T0 , TARGET_LONG_BITS - 1 ) ; } else { tcg_gen_ctz_tl ( cpu_T0 , cpu_T0 , cpu_regs [ reg ] ) ; } } gen_op_mov_reg_v ( ot , reg , cpu_T0 ) ; break ; case 0x27 : if ( CODE64 ( s ) ) goto illegal_op ; gen_update_cc_op ( s ) ; gen_helper_daa ( cpu_env ) ; set_cc_op ( s , CC_OP_EFLAGS ) ; break ; case 0x2f : if ( CODE64 ( s ) ) goto illegal_op ; gen_update_cc_op ( s ) ; gen_helper_das ( cpu_env ) ; set_cc_op ( s , CC_OP_EFLAGS ) ; break ; case 0x37 : if ( CODE64 ( s ) ) goto illegal_op ; gen_update_cc_op ( s ) ; gen_helper_aaa ( cpu_env ) ; set_cc_op ( s , CC_OP_EFLAGS ) ; break ; case 0x3f : if ( CODE64 ( s ) ) goto illegal_op ; gen_update_cc_op ( s ) ; gen_helper_aas ( cpu_env ) ; set_cc_op ( s , CC_OP_EFLAGS ) ; break ; case 0xd4 : if ( CODE64 ( s ) ) goto illegal_op ; val = cpu_ldub_code ( env , s -> pc ++ ) ; if ( val == 0 ) { gen_exception ( s , EXCP00_DIVZ , pc_start - s -> cs_base ) ; } else { gen_helper_aam ( cpu_env , tcg_const_i32 ( val ) ) ; set_cc_op ( s , CC_OP_LOGICB ) ; } break ; case 0xd5 : if ( CODE64 ( s ) ) goto illegal_op ; val = cpu_ldub_code ( env , s -> pc ++ ) ; gen_helper_aad ( cpu_env , tcg_const_i32 ( val ) ) ; set_cc_op ( s , CC_OP_LOGICB ) ; break ; case 0x90 : if ( prefixes & PREFIX_LOCK ) { goto illegal_op ; } if ( REX_B ( s ) ) { goto do_xchg_reg_eax ; } if ( prefixes & PREFIX_REPZ ) { gen_update_cc_op ( s ) ; gen_jmp_im ( pc_start - s -> cs_base ) ; gen_helper_pause ( cpu_env , tcg_const_i32 ( s -> pc - pc_start ) ) ; s -> is_jmp = DISAS_TB_JUMP ; } break ; case 0x9b : if ( ( s -> flags & ( HF_MP_MASK | HF_TS_MASK ) ) == ( HF_MP_MASK | HF_TS_MASK ) ) { gen_exception ( s , EXCP07_PREX , pc_start - s -> cs_base ) ; } else { gen_helper_fwait ( cpu_env ) ; } break ; case 0xcc : gen_interrupt ( s , EXCP03_INT3 , pc_start - s -> cs_base , s -> pc - s -> cs_base ) ; break ; case 0xcd : val = cpu_ldub_code ( env , s -> pc ++ ) ; if ( s -> vm86 && s -> iopl != 3 ) { gen_exception ( s , EXCP0D_GPF , pc_start - s -> cs_base ) ; } else { gen_interrupt ( s , val , pc_start - s -> cs_base , s -> pc - s -> cs_base ) ; } break ; case 0xce : if ( CODE64 ( s ) ) goto illegal_op ; gen_update_cc_op ( s ) ; gen_jmp_im ( pc_start - s -> cs_base ) ; gen_helper_into ( cpu_env , tcg_const_i32 ( s -> pc - pc_start ) ) ; break ; # ifdef WANT_ICEBP case 0xf1 : gen_svm_check_intercept ( s , pc_start , SVM_EXIT_ICEBP ) ; # if 1 gen_debug ( s , pc_start - s -> cs_base ) ; # else tb_flush ( CPU ( x86_env_get_cpu ( env ) ) ) ; qemu_set_log ( CPU_LOG_INT | CPU_LOG_TB_IN_ASM ) ; # endif break ; # endif case 0xfa : if ( ! s -> vm86 ) { if ( s -> cpl <= s -> iopl ) { gen_helper_cli ( cpu_env ) ; } else { gen_exception ( s , EXCP0D_GPF , pc_start - s -> cs_base ) ; } } else { if ( s -> iopl == 3 ) { gen_helper_cli ( cpu_env ) ; } else { gen_exception ( s , EXCP0D_GPF , pc_start - s -> cs_base ) ; } } break ; case 0xfb : if ( s -> vm86 ? s -> iopl == 3 : s -> cpl <= s -> iopl ) { gen_helper_sti ( cpu_env ) ; gen_jmp_im ( s -> pc - s -> cs_base ) ; gen_eob_inhibit_irq ( s , true ) ; } else { gen_exception ( s , EXCP0D_GPF , pc_start - s -> cs_base ) ; } break ; case 0x62 : if ( CODE64 ( s ) ) goto illegal_op ; ot = dflag ; modrm = cpu_ldub_code ( env , s -> pc ++ ) ; reg = ( modrm >> 3 ) & 7 ; mod = ( modrm >> 6 ) & 3 ; if ( mod == 3 ) goto illegal_op ; gen_op_mov_v_reg ( ot , cpu_T0 , reg ) ; gen_lea_modrm ( env , s , modrm ) ; tcg_gen_trunc_tl_i32 ( cpu_tmp2_i32 , cpu_T0 ) ; if ( ot == MO_16 ) { gen_helper_boundw ( cpu_env , cpu_A0 , cpu_tmp2_i32 ) ; } else { gen_helper_boundl ( cpu_env , cpu_A0 , cpu_tmp2_i32 ) ; } break ; case 0x1c8 ... 0x1cf : reg = ( b & 7 ) | REX_B ( s ) ; # ifdef TARGET_X86_64 if ( dflag == MO_64 ) { gen_op_mov_v_reg ( MO_64 , cpu_T0 , reg ) ; tcg_gen_bswap64_i64 ( cpu_T0 , cpu_T0 ) ; gen_op_mov_reg_v ( MO_64 , reg , cpu_T0 ) ; } else # endif { gen_op_mov_v_reg ( MO_32 , cpu_T0 , reg ) ; tcg_gen_ext32u_tl ( cpu_T0 , cpu_T0 ) ; tcg_gen_bswap32_tl ( cpu_T0 , cpu_T0 ) ; gen_op_mov_reg_v ( MO_32 , reg , cpu_T0 ) ; } break ; case 0xd6 : if ( CODE64 ( s ) ) goto illegal_op ; gen_compute_eflags_c ( s , cpu_T0 ) ; tcg_gen_neg_tl ( cpu_T0 , cpu_T0 ) ; gen_op_mov_reg_v ( MO_8 , R_EAX , cpu_T0 ) ; break ; case 0xe0 : case 0xe1 : case 0xe2 : case 0xe3 : { TCGLabel * l1 , * l2 , * l3 ; tval = ( int8_t ) insn_get ( env , s , MO_8 ) ; next_eip = s -> pc - s -> cs_base ; tval += next_eip ; if ( dflag == MO_16 ) { tval &= 0xffff ; } l1 = gen_new_label ( ) ; l2 = gen_new_label ( ) ; l3 = gen_new_label ( ) ; b &= 3 ; switch ( b ) { case 0 : case 1 : gen_op_add_reg_im ( s -> aflag , R_ECX , - 1 ) ; gen_op_jz_ecx ( s -> aflag , l3 ) ; gen_jcc1 ( s , ( JCC_Z << 1 ) | ( b ^ 1 ) , l1 ) ; break ; case 2 : gen_op_add_reg_im ( s -> aflag , R_ECX , - 1 ) ; gen_op_jnz_ecx ( s -> aflag , l1 ) ; break ; default : case 3 : gen_op_jz_ecx ( s -> aflag , l1 ) ; break ; } gen_set_label ( l3 ) ; gen_jmp_im ( next_eip ) ; tcg_gen_br ( l2 ) ; gen_set_label ( l1 ) ; gen_jmp_im ( tval ) ; gen_set_label ( l2 ) ; gen_eob ( s ) ; } break ; case 0x130 : case 0x132 : if ( s -> cpl != 0 ) { gen_exception ( s , EXCP0D_GPF , pc_start - s -> cs_base ) ; } else { gen_update_cc_op ( s ) ; gen_jmp_im ( pc_start - s -> cs_base ) ; if ( b & 2 ) { gen_helper_rdmsr ( cpu_env ) ; } else { gen_helper_wrmsr ( cpu_env ) ; } } break ; case 0x131 : gen_update_cc_op ( s ) ; gen_jmp_im ( pc_start - s -> cs_base ) ; if ( s -> tb -> cflags & CF_USE_ICOUNT ) { gen_io_start ( ) ; } gen_helper_rdtsc ( cpu_env ) ; if ( s -> tb -> cflags & CF_USE_ICOUNT ) { gen_io_end ( ) ; gen_jmp ( s , s -> pc - s -> cs_base ) ; } break ; case 0x133 : gen_update_cc_op ( s ) ; gen_jmp_im ( pc_start - s -> cs_base ) ; gen_helper_rdpmc ( cpu_env ) ; break ; case 0x134 : if ( CODE64 ( s ) && env -> cpuid_vendor1 != CPUID_VENDOR_INTEL_1 ) goto illegal_op ; if ( ! s -> pe ) { gen_exception ( s , EXCP0D_GPF , pc_start - s -> cs_base ) ; } else { gen_helper_sysenter ( cpu_env ) ; gen_eob ( s ) ; } break ; case 0x135 : if ( CODE64 ( s ) && env -> cpuid_vendor1 != CPUID_VENDOR_INTEL_1 ) goto illegal_op ; if ( ! s -> pe ) { gen_exception ( s , EXCP0D_GPF , pc_start - s -> cs_base ) ; } else { gen_helper_sysexit ( cpu_env , tcg_const_i32 ( dflag - 1 ) ) ; gen_eob ( s ) ; } break ; # ifdef TARGET_X86_64 case 0x105 : gen_update_cc_op ( s ) ; gen_jmp_im ( pc_start - s -> cs_base ) ; gen_helper_syscall ( cpu_env , tcg_const_i32 ( s -> pc - pc_start ) ) ; gen_eob_worker ( s , false , true ) ; break ; case 0x107 : if ( ! s -> pe ) { gen_exception ( s , EXCP0D_GPF , pc_start - s -> cs_base ) ; } else { gen_helper_sysret ( cpu_env , tcg_const_i32 ( dflag - 1 ) ) ; if ( s -> lma ) { set_cc_op ( s , CC_OP_EFLAGS ) ; } gen_eob_worker ( s , false , true ) ; } break ; # endif case 0x1a2 : gen_update_cc_op ( s ) ; gen_jmp_im ( pc_start - s -> cs_base ) ; gen_helper_cpuid ( cpu_env ) ; break ; case 0xf4 : if ( s -> cpl != 0 ) { gen_exception ( s , EXCP0D_GPF , pc_start - s -> cs_base ) ; } else { gen_update_cc_op ( s ) ; gen_jmp_im ( pc_start - s -> cs_base ) ; gen_helper_hlt ( cpu_env , tcg_const_i32 ( s -> pc - pc_start ) ) ; s -> is_jmp = DISAS_TB_JUMP ; } break ; case 0x100 : modrm = cpu_ldub_code ( env , s -> pc ++ ) ; mod = ( modrm >> 6 ) & 3 ; op = ( modrm >> 3 ) & 7 ; switch ( op ) { case 0 : if ( ! s -> pe || s -> vm86 ) goto illegal_op ; gen_svm_check_intercept ( s , pc_start , SVM_EXIT_LDTR_READ ) ; tcg_gen_ld32u_tl ( cpu_T0 , cpu_env , offsetof ( CPUX86State , ldt . selector ) ) ; ot = mod == 3 ? dflag : MO_16 ; gen_ldst_modrm ( env , s , modrm , ot , OR_TMP0 , 1 ) ; break ; case 2 : if ( ! s -> pe || s -> vm86 ) goto illegal_op ; if ( s -> cpl != 0 ) { gen_exception ( s , EXCP0D_GPF , pc_start - s -> cs_base ) ; } else { gen_svm_check_intercept ( s , pc_start , SVM_EXIT_LDTR_WRITE ) ; gen_ldst_modrm ( env , s , modrm , MO_16 , OR_TMP0 , 0 ) ; tcg_gen_trunc_tl_i32 ( cpu_tmp2_i32 , cpu_T0 ) ; gen_helper_lldt ( cpu_env , cpu_tmp2_i32 ) ; } break ; case 1 : if ( ! s -> pe || s -> vm86 ) goto illegal_op ; gen_svm_check_intercept ( s , pc_start , SVM_EXIT_TR_READ ) ; tcg_gen_ld32u_tl ( cpu_T0 , cpu_env , offsetof ( CPUX86State , tr . selector ) ) ; ot = mod == 3 ? dflag : MO_16 ; gen_ldst_modrm ( env , s , modrm , ot , OR_TMP0 , 1 ) ; break ; case 3 : if ( ! s -> pe || s -> vm86 ) goto illegal_op ; if ( s -> cpl != 0 ) { gen_exception ( s , EXCP0D_GPF , pc_start - s -> cs_base ) ; } else { gen_svm_check_intercept ( s , pc_start , SVM_EXIT_TR_WRITE ) ; gen_ldst_modrm ( env , s , modrm , MO_16 , OR_TMP0 , 0 ) ; tcg_gen_trunc_tl_i32 ( cpu_tmp2_i32 , cpu_T0 ) ; gen_helper_ltr ( cpu_env , cpu_tmp2_i32 ) ; } break ; case 4 : case 5 : if ( ! s -> pe || s -> vm86 ) goto illegal_op ; gen_ldst_modrm ( env , s , modrm , MO_16 , OR_TMP0 , 0 ) ; gen_update_cc_op ( s ) ; if ( op == 4 ) { gen_helper_verr ( cpu_env , cpu_T0 ) ; } else { gen_helper_verw ( cpu_env , cpu_T0 ) ; } set_cc_op ( s , CC_OP_EFLAGS ) ; break ; default : goto unknown_op ; } break ; case 0x101 : modrm = cpu_ldub_code ( env , s -> pc ++ ) ; switch ( modrm ) { CASE_MODRM_MEM_OP ( 0 ) : gen_svm_check_intercept ( s , pc_start , SVM_EXIT_GDTR_READ ) ; gen_lea_modrm ( env , s , modrm ) ; tcg_gen_ld32u_tl ( cpu_T0 , cpu_env , offsetof ( CPUX86State , gdt . limit ) ) ; gen_op_st_v ( s , MO_16 , cpu_T0 , cpu_A0 ) ; gen_add_A0_im ( s , 2 ) ; tcg_gen_ld_tl ( cpu_T0 , cpu_env , offsetof ( CPUX86State , gdt . base ) ) ; if ( dflag == MO_16 ) { tcg_gen_andi_tl ( cpu_T0 , cpu_T0 , 0xffffff ) ; } gen_op_st_v ( s , CODE64 ( s ) + MO_32 , cpu_T0 , cpu_A0 ) ; break ; case 0xc8 : if ( ! ( s -> cpuid_ext_features & CPUID_EXT_MONITOR ) || s -> cpl != 0 ) { goto illegal_op ; } gen_update_cc_op ( s ) ; gen_jmp_im ( pc_start - s -> cs_base ) ; tcg_gen_mov_tl ( cpu_A0 , cpu_regs [ R_EAX ] ) ; gen_extu ( s -> aflag , cpu_A0 ) ; gen_add_A0_ds_seg ( s ) ; gen_helper_monitor ( cpu_env , cpu_A0 ) ; break ; case 0xc9 : if ( ! ( s -> cpuid_ext_features & CPUID_EXT_MONITOR ) || s -> cpl != 0 ) { goto illegal_op ; } gen_update_cc_op ( s ) ; gen_jmp_im ( pc_start - s -> cs_base ) ; gen_helper_mwait ( cpu_env , tcg_const_i32 ( s -> pc - pc_start ) ) ; gen_eob ( s ) ; break ; case 0xca : if ( ! ( s -> cpuid_7_0_ebx_features & CPUID_7_0_EBX_SMAP ) || s -> cpl != 0 ) { goto illegal_op ; } gen_helper_clac ( cpu_env ) ; gen_jmp_im ( s -> pc - s -> cs_base ) ; gen_eob ( s ) ; break ; case 0xcb : if ( ! ( s -> cpuid_7_0_ebx_features & CPUID_7_0_EBX_SMAP ) || s -> cpl != 0 ) { goto illegal_op ; } gen_helper_stac ( cpu_env ) ; gen_jmp_im ( s -> pc - s -> cs_base ) ; gen_eob ( s ) ; break ; CASE_MODRM_MEM_OP ( 1 ) : gen_svm_check_intercept ( s , pc_start , SVM_EXIT_IDTR_READ ) ; gen_lea_modrm ( env , s , modrm ) ; tcg_gen_ld32u_tl ( cpu_T0 , cpu_env , offsetof ( CPUX86State , idt . limit ) ) ; gen_op_st_v ( s , MO_16 , cpu_T0 , cpu_A0 ) ; gen_add_A0_im ( s , 2 ) ; tcg_gen_ld_tl ( cpu_T0 , cpu_env , offsetof ( CPUX86State , idt . base ) ) ; if ( dflag == MO_16 ) { tcg_gen_andi_tl ( cpu_T0 , cpu_T0 , 0xffffff ) ; } gen_op_st_v ( s , CODE64 ( s ) + MO_32 , cpu_T0 , cpu_A0 ) ; break ; case 0xd0 : if ( ( s -> cpuid_ext_features & CPUID_EXT_XSAVE ) == 0 || ( s -> prefix & ( PREFIX_LOCK | PREFIX_DATA | PREFIX_REPZ | PREFIX_REPNZ ) ) ) { goto illegal_op ; } tcg_gen_trunc_tl_i32 ( cpu_tmp2_i32 , cpu_regs [ R_ECX ] ) ; gen_helper_xgetbv ( cpu_tmp1_i64 , cpu_env , cpu_tmp2_i32 ) ; tcg_gen_extr_i64_tl ( cpu_regs [ R_EAX ] , cpu_regs [ R_EDX ] , cpu_tmp1_i64 ) ; break ; case 0xd1 : if ( ( s -> cpuid_ext_features & CPUID_EXT_XSAVE ) == 0 || ( s -> prefix & ( PREFIX_LOCK | PREFIX_DATA | PREFIX_REPZ | PREFIX_REPNZ ) ) ) { goto illegal_op ; } if ( s -> cpl != 0 ) { gen_exception ( s , EXCP0D_GPF , pc_start - s -> cs_base ) ; break ; } tcg_gen_concat_tl_i64 ( cpu_tmp1_i64 , cpu_regs [ R_EAX ] , cpu_regs [ R_EDX ] ) ; tcg_gen_trunc_tl_i32 ( cpu_tmp2_i32 , cpu_regs [ R_ECX ] ) ; gen_helper_xsetbv ( cpu_env , cpu_tmp2_i32 , cpu_tmp1_i64 ) ; gen_jmp_im ( s -> pc - s -> cs_base ) ; gen_eob ( s ) ; break ; case 0xd8 : if ( ! ( s -> flags & HF_SVME_MASK ) || ! s -> pe ) { goto illegal_op ; } if ( s -> cpl != 0 ) { gen_exception ( s , EXCP0D_GPF , pc_start - s -> cs_base ) ; break ; } gen_update_cc_op ( s ) ; gen_jmp_im ( pc_start - s -> cs_base ) ; gen_helper_vmrun ( cpu_env , tcg_const_i32 ( s -> aflag - 1 ) , tcg_const_i32 ( s -> pc - pc_start ) ) ; tcg_gen_exit_tb ( 0 ) ; s -> is_jmp = DISAS_TB_JUMP ; break ; case 0xd9 : if ( ! ( s -> flags & HF_SVME_MASK ) ) { goto illegal_op ; } gen_update_cc_op ( s ) ; gen_jmp_im ( pc_start - s -> cs_base ) ; gen_helper_vmmcall ( cpu_env ) ; break ; case 0xda : if ( ! ( s -> flags & HF_SVME_MASK ) || ! s -> pe ) { goto illegal_op ; } if ( s -> cpl != 0 ) { gen_exception ( s , EXCP0D_GPF , pc_start - s -> cs_base ) ; break ; } gen_update_cc_op ( s ) ; gen_jmp_im ( pc_start - s -> cs_base ) ; gen_helper_vmload ( cpu_env , tcg_const_i32 ( s -> aflag - 1 ) ) ; break ; case 0xdb : if ( ! ( s -> flags & HF_SVME_MASK ) || ! s -> pe ) { goto illegal_op ; } if ( s -> cpl != 0 ) { gen_exception ( s , EXCP0D_GPF , pc_start - s -> cs_base ) ; break ; } gen_update_cc_op ( s ) ; gen_jmp_im ( pc_start - s -> cs_base ) ; gen_helper_vmsave ( cpu_env , tcg_const_i32 ( s -> aflag - 1 ) ) ; break ; case 0xdc : if ( ( ! ( s -> flags & HF_SVME_MASK ) && ! ( s -> cpuid_ext3_features & CPUID_EXT3_SKINIT ) ) || ! s -> pe ) { goto illegal_op ; } if ( s -> cpl != 0 ) { gen_exception ( s , EXCP0D_GPF , pc_start - s -> cs_base ) ; break ; } gen_update_cc_op ( s ) ; gen_jmp_im ( pc_start - s -> cs_base ) ; gen_helper_stgi ( cpu_env ) ; break ; case 0xdd : if ( ! ( s -> flags & HF_SVME_MASK ) || ! s -> pe ) { goto illegal_op ; } if ( s -> cpl != 0 ) { gen_exception ( s , EXCP0D_GPF , pc_start - s -> cs_base ) ; break ; } gen_update_cc_op ( s ) ; gen_jmp_im ( pc_start - s -> cs_base ) ; gen_helper_clgi ( cpu_env ) ; break ; case 0xde : if ( ( ! ( s -> flags & HF_SVME_MASK ) && ! ( s -> cpuid_ext3_features & CPUID_EXT3_SKINIT ) ) || ! s -> pe ) { goto illegal_op ; } gen_update_cc_op ( s ) ; gen_jmp_im ( pc_start - s -> cs_base ) ; gen_helper_skinit ( cpu_env ) ; break ; case 0xdf : if ( ! ( s -> flags & HF_SVME_MASK ) || ! s -> pe ) { goto illegal_op ; } if ( s -> cpl != 0 ) { gen_exception ( s , EXCP0D_GPF , pc_start - s -> cs_base ) ; break ; } gen_update_cc_op ( s ) ; gen_jmp_im ( pc_start - s -> cs_base ) ; gen_helper_invlpga ( cpu_env , tcg_const_i32 ( s -> aflag - 1 ) ) ; break ; CASE_MODRM_MEM_OP ( 2 ) : if ( s -> cpl != 0 ) { gen_exception ( s , EXCP0D_GPF , pc_start - s -> cs_base ) ; break ; } gen_svm_check_intercept ( s , pc_start , SVM_EXIT_GDTR_WRITE ) ; gen_lea_modrm ( env , s , modrm ) ; gen_op_ld_v ( s , MO_16 , cpu_T1 , cpu_A0 ) ; gen_add_A0_im ( s , 2 ) ; gen_op_ld_v ( s , CODE64 ( s ) + MO_32 , cpu_T0 , cpu_A0 ) ; if ( dflag == MO_16 ) { tcg_gen_andi_tl ( cpu_T0 , cpu_T0 , 0xffffff ) ; } tcg_gen_st_tl ( cpu_T0 , cpu_env , offsetof ( CPUX86State , gdt . base ) ) ; tcg_gen_st32_tl ( cpu_T1 , cpu_env , offsetof ( CPUX86State , gdt . limit ) ) ; break ; CASE_MODRM_MEM_OP ( 3 ) : if ( s -> cpl != 0 ) { gen_exception ( s , EXCP0D_GPF , pc_start - s -> cs_base ) ; break ; } gen_svm_check_intercept ( s , pc_start , SVM_EXIT_IDTR_WRITE ) ; gen_lea_modrm ( env , s , modrm ) ; gen_op_ld_v ( s , MO_16 , cpu_T1 , cpu_A0 ) ; gen_add_A0_im ( s , 2 ) ; gen_op_ld_v ( s , CODE64 ( s ) + MO_32 , cpu_T0 , cpu_A0 ) ; if ( dflag == MO_16 ) { tcg_gen_andi_tl ( cpu_T0 , cpu_T0 , 0xffffff ) ; } tcg_gen_st_tl ( cpu_T0 , cpu_env , offsetof ( CPUX86State , idt . base ) ) ; tcg_gen_st32_tl ( cpu_T1 , cpu_env , offsetof ( CPUX86State , idt . limit ) ) ; break ; CASE_MODRM_OP ( 4 ) : gen_svm_check_intercept ( s , pc_start , SVM_EXIT_READ_CR0 ) ; tcg_gen_ld_tl ( cpu_T0 , cpu_env , offsetof ( CPUX86State , cr [ 0 ] ) ) ; if ( CODE64 ( s ) ) { mod = ( modrm >> 6 ) & 3 ; ot = ( mod != 3 ? MO_16 : s -> dflag ) ; } else { ot = MO_16 ; } gen_ldst_modrm ( env , s , modrm , ot , OR_TMP0 , 1 ) ; break ; case 0xee : if ( prefixes & PREFIX_LOCK ) { goto illegal_op ; } tcg_gen_trunc_tl_i32 ( cpu_tmp2_i32 , cpu_regs [ R_ECX ] ) ; gen_helper_rdpkru ( cpu_tmp1_i64 , cpu_env , cpu_tmp2_i32 ) ; tcg_gen_extr_i64_tl ( cpu_regs [ R_EAX ] , cpu_regs [ R_EDX ] , cpu_tmp1_i64 ) ; break ; case 0xef : if ( prefixes & PREFIX_LOCK ) { goto illegal_op ; } tcg_gen_concat_tl_i64 ( cpu_tmp1_i64 , cpu_regs [ R_EAX ] , cpu_regs [ R_EDX ] ) ; tcg_gen_trunc_tl_i32 ( cpu_tmp2_i32 , cpu_regs [ R_ECX ] ) ; gen_helper_wrpkru ( cpu_env , cpu_tmp2_i32 , cpu_tmp1_i64 ) ; break ; CASE_MODRM_OP ( 6 ) : if ( s -> cpl != 0 ) { gen_exception ( s , EXCP0D_GPF , pc_start - s -> cs_base ) ; break ; } gen_svm_check_intercept ( s , pc_start , SVM_EXIT_WRITE_CR0 ) ; gen_ldst_modrm ( env , s , modrm , MO_16 , OR_TMP0 , 0 ) ; gen_helper_lmsw ( cpu_env , cpu_T0 ) ; gen_jmp_im ( s -> pc - s -> cs_base ) ; gen_eob ( s ) ; break ; CASE_MODRM_MEM_OP ( 7 ) : if ( s -> cpl != 0 ) { gen_exception ( s , EXCP0D_GPF , pc_start - s -> cs_base ) ; break ; } gen_update_cc_op ( s ) ; gen_jmp_im ( pc_start - s -> cs_base ) ; gen_lea_modrm ( env , s , modrm ) ; gen_helper_invlpg ( cpu_env , cpu_A0 ) ; gen_jmp_im ( s -> pc - s -> cs_base ) ; gen_eob ( s ) ; break ; case 0xf8 : # ifdef TARGET_X86_64 if ( CODE64 ( s ) ) { if ( s -> cpl != 0 ) { gen_exception ( s , EXCP0D_GPF , pc_start - s -> cs_base ) ; } else { tcg_gen_mov_tl ( cpu_T0 , cpu_seg_base [ R_GS ] ) ; tcg_gen_ld_tl ( cpu_seg_base [ R_GS ] , cpu_env , offsetof ( CPUX86State , kernelgsbase ) ) ; tcg_gen_st_tl ( cpu_T0 , cpu_env , offsetof ( CPUX86State , kernelgsbase ) ) ; } break ; } # endif goto illegal_op ; case 0xf9 : if ( ! ( s -> cpuid_ext2_features & CPUID_EXT2_RDTSCP ) ) { goto illegal_op ; } gen_update_cc_op ( s ) ; gen_jmp_im ( pc_start - s -> cs_base ) ; if ( s -> tb -> cflags & CF_USE_ICOUNT ) { gen_io_start ( ) ; } gen_helper_rdtscp ( cpu_env ) ; if ( s -> tb -> cflags & CF_USE_ICOUNT ) { gen_io_end ( ) ; gen_jmp ( s , s -> pc - s -> cs_base ) ; } break ; default : goto unknown_op ; } break ; case 0x108 : case 0x109 : if ( s -> cpl != 0 ) { gen_exception ( s , EXCP0D_GPF , pc_start - s -> cs_base ) ; } else { gen_svm_check_intercept ( s , pc_start , ( b & 2 ) ? SVM_EXIT_INVD : SVM_EXIT_WBINVD ) ; } break ; case 0x63 : # ifdef TARGET_X86_64 if ( CODE64 ( s ) ) { int d_ot ; d_ot = dflag ; modrm = cpu_ldub_code ( env , s -> pc ++ ) ; reg = ( ( modrm >> 3 ) & 7 ) | rex_r ; mod = ( modrm >> 6 ) & 3 ; rm = ( modrm & 7 ) | REX_B ( s ) ; if ( mod == 3 ) { gen_op_mov_v_reg ( MO_32 , cpu_T0 , rm ) ; if ( d_ot == MO_64 ) { tcg_gen_ext32s_tl ( cpu_T0 , cpu_T0 ) ; } gen_op_mov_reg_v ( d_ot , reg , cpu_T0 ) ; } else { gen_lea_modrm ( env , s , modrm ) ; gen_op_ld_v ( s , MO_32 | MO_SIGN , cpu_T0 , cpu_A0 ) ; gen_op_mov_reg_v ( d_ot , reg , cpu_T0 ) ; } } else # endif { TCGLabel * label1 ; TCGv t0 , t1 , t2 , a0 ; if ( ! s -> pe || s -> vm86 ) goto illegal_op ; t0 = tcg_temp_local_new ( ) ; t1 = tcg_temp_local_new ( ) ; t2 = tcg_temp_local_new ( ) ; ot = MO_16 ; modrm = cpu_ldub_code ( env , s -> pc ++ ) ; reg = ( modrm >> 3 ) & 7 ; mod = ( modrm >> 6 ) & 3 ; rm = modrm & 7 ; if ( mod != 3 ) { gen_lea_modrm ( env , s , modrm ) ; gen_op_ld_v ( s , ot , t0 , cpu_A0 ) ; a0 = tcg_temp_local_new ( ) ; tcg_gen_mov_tl ( a0 , cpu_A0 ) ; } else { gen_op_mov_v_reg ( ot , t0 , rm ) ; TCGV_UNUSED ( a0 ) ; } gen_op_mov_v_reg ( ot , t1 , reg ) ; tcg_gen_andi_tl ( cpu_tmp0 , t0 , 3 ) ; tcg_gen_andi_tl ( t1 , t1 , 3 ) ; tcg_gen_movi_tl ( t2 , 0 ) ; label1 = gen_new_label ( ) ; tcg_gen_brcond_tl ( TCG_COND_GE , cpu_tmp0 , t1 , label1 ) ; tcg_gen_andi_tl ( t0 , t0 , ~ 3 ) ; tcg_gen_or_tl ( t0 , t0 , t1 ) ; tcg_gen_movi_tl ( t2 , CC_Z ) ; gen_set_label ( label1 ) ; if ( mod != 3 ) { gen_op_st_v ( s , ot , t0 , a0 ) ; tcg_temp_free ( a0 ) ; } else { gen_op_mov_reg_v ( ot , rm , t0 ) ; } gen_compute_eflags ( s ) ; tcg_gen_andi_tl ( cpu_cc_src , cpu_cc_src , ~ CC_Z ) ; tcg_gen_or_tl ( cpu_cc_src , cpu_cc_src , t2 ) ; tcg_temp_free ( t0 ) ; tcg_temp_free ( t1 ) ; tcg_temp_free ( t2 ) ; } break ; case 0x102 : case 0x103 : { TCGLabel * label1 ; TCGv t0 ; if ( ! s -> pe || s -> vm86 ) goto illegal_op ; ot = dflag != MO_16 ? MO_32 : MO_16 ; modrm = cpu_ldub_code ( env , s -> pc ++ ) ; reg = ( ( modrm >> 3 ) & 7 ) | rex_r ; gen_ldst_modrm ( env , s , modrm , MO_16 , OR_TMP0 , 0 ) ; t0 = tcg_temp_local_new ( ) ; gen_update_cc_op ( s ) ; if ( b == 0x102 ) { gen_helper_lar ( t0 , cpu_env , cpu_T0 ) ; } else { gen_helper_lsl ( t0 , cpu_env , cpu_T0 ) ; } tcg_gen_andi_tl ( cpu_tmp0 , cpu_cc_src , CC_Z ) ; label1 = gen_new_label ( ) ; tcg_gen_brcondi_tl ( TCG_COND_EQ , cpu_tmp0 , 0 , label1 ) ; gen_op_mov_reg_v ( ot , reg , t0 ) ; gen_set_label ( label1 ) ; set_cc_op ( s , CC_OP_EFLAGS ) ; tcg_temp_free ( t0 ) ; } break ; case 0x118 : modrm = cpu_ldub_code ( env , s -> pc ++ ) ; mod = ( modrm >> 6 ) & 3 ; op = ( modrm >> 3 ) & 7 ; switch ( op ) { case 0 : case 1 : case 2 : case 3 : if ( mod == 3 ) goto illegal_op ; gen_nop_modrm ( env , s , modrm ) ; break ; default : gen_nop_modrm ( env , s , modrm ) ; break ; } break ; case 0x11a : modrm = cpu_ldub_code ( env , s -> pc ++ ) ; if ( s -> flags & HF_MPX_EN_MASK ) { mod = ( modrm >> 6 ) & 3 ; reg = ( ( modrm >> 3 ) & 7 ) | rex_r ; if ( prefixes & PREFIX_REPZ ) { if ( reg >= 4 || ( prefixes & PREFIX_LOCK ) || s -> aflag == MO_16 ) { goto illegal_op ; } gen_bndck ( env , s , modrm , TCG_COND_LTU , cpu_bndl [ reg ] ) ; } else if ( prefixes & PREFIX_REPNZ ) { if ( reg >= 4 || ( prefixes & PREFIX_LOCK ) || s -> aflag == MO_16 ) { goto illegal_op ; } TCGv_i64 notu = tcg_temp_new_i64 ( ) ; tcg_gen_not_i64 ( notu , cpu_bndu [ reg ] ) ; gen_bndck ( env , s , modrm , TCG_COND_GTU , notu ) ; tcg_temp_free_i64 ( notu ) ; } else if ( prefixes & PREFIX_DATA ) { if ( reg >= 4 || s -> aflag == MO_16 ) { goto illegal_op ; } if ( mod == 3 ) { int reg2 = ( modrm & 7 ) | REX_B ( s ) ; if ( reg2 >= 4 || ( prefixes & PREFIX_LOCK ) ) { goto illegal_op ; } if ( s -> flags & HF_MPX_IU_MASK ) { tcg_gen_mov_i64 ( cpu_bndl [ reg ] , cpu_bndl [ reg2 ] ) ; tcg_gen_mov_i64 ( cpu_bndu [ reg ] , cpu_bndu [ reg2 ] ) ; } } else { gen_lea_modrm ( env , s , modrm ) ; if ( CODE64 ( s ) ) { tcg_gen_qemu_ld_i64 ( cpu_bndl [ reg ] , cpu_A0 , s -> mem_index , MO_LEQ ) ; tcg_gen_addi_tl ( cpu_A0 , cpu_A0 , 8 ) ; tcg_gen_qemu_ld_i64 ( cpu_bndu [ reg ] , cpu_A0 , s -> mem_index , MO_LEQ ) ; } else { tcg_gen_qemu_ld_i64 ( cpu_bndl [ reg ] , cpu_A0 , s -> mem_index , MO_LEUL ) ; tcg_gen_addi_tl ( cpu_A0 , cpu_A0 , 4 ) ; tcg_gen_qemu_ld_i64 ( cpu_bndu [ reg ] , cpu_A0 , s -> mem_index , MO_LEUL ) ; } gen_set_hflag ( s , HF_MPX_IU_MASK ) ; } } else if ( mod != 3 ) { AddressParts a = gen_lea_modrm_0 ( env , s , modrm ) ; if ( reg >= 4 || ( prefixes & PREFIX_LOCK ) || s -> aflag == MO_16 || a . base < - 1 ) { goto illegal_op ; } if ( a . base >= 0 ) { tcg_gen_addi_tl ( cpu_A0 , cpu_regs [ a . base ] , a . disp ) ; } else { tcg_gen_movi_tl ( cpu_A0 , 0 ) ; } gen_lea_v_seg ( s , s -> aflag , cpu_A0 , a . def_seg , s -> override ) ; if ( a . index >= 0 ) { tcg_gen_mov_tl ( cpu_T0 , cpu_regs [ a . index ] ) ; } else { tcg_gen_movi_tl ( cpu_T0 , 0 ) ; } if ( CODE64 ( s ) ) { gen_helper_bndldx64 ( cpu_bndl [ reg ] , cpu_env , cpu_A0 , cpu_T0 ) ; tcg_gen_ld_i64 ( cpu_bndu [ reg ] , cpu_env , offsetof ( CPUX86State , mmx_t0 . MMX_Q ( 0 ) ) ) ; } else { gen_helper_bndldx32 ( cpu_bndu [ reg ] , cpu_env , cpu_A0 , cpu_T0 ) ; tcg_gen_ext32u_i64 ( cpu_bndl [ reg ] , cpu_bndu [ reg ] ) ; tcg_gen_shri_i64 ( cpu_bndu [ reg ] , cpu_bndu [ reg ] , 32 ) ; } gen_set_hflag ( s , HF_MPX_IU_MASK ) ; } } gen_nop_modrm ( env , s , modrm ) ; break ; case 0x11b : modrm = cpu_ldub_code ( env , s -> pc ++ ) ; if ( s -> flags & HF_MPX_EN_MASK ) { mod = ( modrm >> 6 ) & 3 ; reg = ( ( modrm >> 3 ) & 7 ) | rex_r ; if ( mod != 3 && ( prefixes & PREFIX_REPZ ) ) { if ( reg >= 4 || ( prefixes & PREFIX_LOCK ) || s -> aflag == MO_16 ) { goto illegal_op ; } AddressParts a = gen_lea_modrm_0 ( env , s , modrm ) ; if ( a . base >= 0 ) { tcg_gen_extu_tl_i64 ( cpu_bndl [ reg ] , cpu_regs [ a . base ] ) ; if ( ! CODE64 ( s ) ) { tcg_gen_ext32u_i64 ( cpu_bndl [ reg ] , cpu_bndl [ reg ] ) ; } } else if ( a . base == - 1 ) { tcg_gen_movi_i64 ( cpu_bndl [ reg ] , 0 ) ; } else { goto illegal_op ; } tcg_gen_not_tl ( cpu_A0 , gen_lea_modrm_1 ( a ) ) ; if ( ! CODE64 ( s ) ) { tcg_gen_ext32u_tl ( cpu_A0 , cpu_A0 ) ; } tcg_gen_extu_tl_i64 ( cpu_bndu [ reg ] , cpu_A0 ) ; gen_set_hflag ( s , HF_MPX_IU_MASK ) ; break ; } else if ( prefixes & PREFIX_REPNZ ) { if ( reg >= 4 || ( prefixes & PREFIX_LOCK ) || s -> aflag == MO_16 ) { goto illegal_op ; } gen_bndck ( env , s , modrm , TCG_COND_GTU , cpu_bndu [ reg ] ) ; } else if ( prefixes & PREFIX_DATA ) { if ( reg >= 4 || s -> aflag == MO_16 ) { goto illegal_op ; } if ( mod == 3 ) { int reg2 = ( modrm & 7 ) | REX_B ( s ) ; if ( reg2 >= 4 || ( prefixes & PREFIX_LOCK ) ) { goto illegal_op ; } if ( s -> flags & HF_MPX_IU_MASK ) { tcg_gen_mov_i64 ( cpu_bndl [ reg2 ] , cpu_bndl [ reg ] ) ; tcg_gen_mov_i64 ( cpu_bndu [ reg2 ] , cpu_bndu [ reg ] ) ; } } else { gen_lea_modrm ( env , s , modrm ) ; if ( CODE64 ( s ) ) { tcg_gen_qemu_st_i64 ( cpu_bndl [ reg ] , cpu_A0 , s -> mem_index , MO_LEQ ) ; tcg_gen_addi_tl ( cpu_A0 , cpu_A0 , 8 ) ; tcg_gen_qemu_st_i64 ( cpu_bndu [ reg ] , cpu_A0 , s -> mem_index , MO_LEQ ) ; } else { tcg_gen_qemu_st_i64 ( cpu_bndl [ reg ] , cpu_A0 , s -> mem_index , MO_LEUL ) ; tcg_gen_addi_tl ( cpu_A0 , cpu_A0 , 4 ) ; tcg_gen_qemu_st_i64 ( cpu_bndu [ reg ] , cpu_A0 , s -> mem_index , MO_LEUL ) ; } } } else if ( mod != 3 ) { AddressParts a = gen_lea_modrm_0 ( env , s , modrm ) ; if ( reg >= 4 || ( prefixes & PREFIX_LOCK ) || s -> aflag == MO_16 || a . base < - 1 ) { goto illegal_op ; } if ( a . base >= 0 ) { tcg_gen_addi_tl ( cpu_A0 , cpu_regs [ a . base ] , a . disp ) ; } else { tcg_gen_movi_tl ( cpu_A0 , 0 ) ; } gen_lea_v_seg ( s , s -> aflag , cpu_A0 , a . def_seg , s -> override ) ; if ( a . index >= 0 ) { tcg_gen_mov_tl ( cpu_T0 , cpu_regs [ a . index ] ) ; } else { tcg_gen_movi_tl ( cpu_T0 , 0 ) ; } if ( CODE64 ( s ) ) { gen_helper_bndstx64 ( cpu_env , cpu_A0 , cpu_T0 , cpu_bndl [ reg ] , cpu_bndu [ reg ] ) ; } else { gen_helper_bndstx32 ( cpu_env , cpu_A0 , cpu_T0 , cpu_bndl [ reg ] , cpu_bndu [ reg ] ) ; } } } gen_nop_modrm ( env , s , modrm ) ; break ; case 0x119 : case 0x11c ... 0x11f : modrm = cpu_ldub_code ( env , s -> pc ++ ) ; gen_nop_modrm ( env , s , modrm ) ; break ; case 0x120 : case 0x122 : if ( s -> cpl != 0 ) { gen_exception ( s , EXCP0D_GPF , pc_start - s -> cs_base ) ; } else { modrm = cpu_ldub_code ( env , s -> pc ++ ) ; rm = ( modrm & 7 ) | REX_B ( s ) ; reg = ( ( modrm >> 3 ) & 7 ) | rex_r ; if ( CODE64 ( s ) ) ot = MO_64 ; else ot = MO_32 ; if ( ( prefixes & PREFIX_LOCK ) && ( reg == 0 ) && ( s -> cpuid_ext3_features & CPUID_EXT3_CR8LEG ) ) { reg = 8 ; } switch ( reg ) { case 0 : case 2 : case 3 : case 4 : case 8 : gen_update_cc_op ( s ) ; gen_jmp_im ( pc_start - s -> cs_base ) ; if ( b & 2 ) { gen_op_mov_v_reg ( ot , cpu_T0 , rm ) ; gen_helper_write_crN ( cpu_env , tcg_const_i32 ( reg ) , cpu_T0 ) ; gen_jmp_im ( s -> pc - s -> cs_base ) ; gen_eob ( s ) ; } else { gen_helper_read_crN ( cpu_T0 , cpu_env , tcg_const_i32 ( reg ) ) ; gen_op_mov_reg_v ( ot , rm , cpu_T0 ) ; } break ; default : goto unknown_op ; } } break ; case 0x121 : case 0x123 : if ( s -> cpl != 0 ) { gen_exception ( s , EXCP0D_GPF , pc_start - s -> cs_base ) ; } else { modrm = cpu_ldub_code ( env , s -> pc ++ ) ; rm = ( modrm & 7 ) | REX_B ( s ) ; reg = ( ( modrm >> 3 ) & 7 ) | rex_r ; if ( CODE64 ( s ) ) ot = MO_64 ; else ot = MO_32 ; if ( reg >= 8 ) { goto illegal_op ; } if ( b & 2 ) { gen_svm_check_intercept ( s , pc_start , SVM_EXIT_WRITE_DR0 + reg ) ; gen_op_mov_v_reg ( ot , cpu_T0 , rm ) ; tcg_gen_movi_i32 ( cpu_tmp2_i32 , reg ) ; gen_helper_set_dr ( cpu_env , cpu_tmp2_i32 , cpu_T0 ) ; gen_jmp_im ( s -> pc - s -> cs_base ) ; gen_eob ( s ) ; } else { gen_svm_check_intercept ( s , pc_start , SVM_EXIT_READ_DR0 + reg ) ; tcg_gen_movi_i32 ( cpu_tmp2_i32 , reg ) ; gen_helper_get_dr ( cpu_T0 , cpu_env , cpu_tmp2_i32 ) ; gen_op_mov_reg_v ( ot , rm , cpu_T0 ) ; } } break ; case 0x106 : if ( s -> cpl != 0 ) { gen_exception ( s , EXCP0D_GPF , pc_start - s -> cs_base ) ; } else { gen_svm_check_intercept ( s , pc_start , SVM_EXIT_WRITE_CR0 ) ; gen_helper_clts ( cpu_env ) ; gen_jmp_im ( s -> pc - s -> cs_base ) ; gen_eob ( s ) ; } break ; case 0x1c3 : if ( ! ( s -> cpuid_features & CPUID_SSE2 ) ) goto illegal_op ; ot = mo_64_32 ( dflag ) ; modrm = cpu_ldub_code ( env , s -> pc ++ ) ; mod = ( modrm >> 6 ) & 3 ; if ( mod == 3 ) goto illegal_op ; reg = ( ( modrm >> 3 ) & 7 ) | rex_r ; gen_ldst_modrm ( env , s , modrm , ot , reg , 1 ) ; break ; case 0x1ae : modrm = cpu_ldub_code ( env , s -> pc ++ ) ; switch ( modrm ) { CASE_MODRM_MEM_OP ( 0 ) : if ( ! ( s -> cpuid_features & CPUID_FXSR ) || ( prefixes & PREFIX_LOCK ) ) { goto illegal_op ; } if ( ( s -> flags & HF_EM_MASK ) || ( s -> flags & HF_TS_MASK ) ) { gen_exception ( s , EXCP07_PREX , pc_start - s -> cs_base ) ; break ; } gen_lea_modrm ( env , s , modrm ) ; gen_helper_fxsave ( cpu_env , cpu_A0 ) ; break ; CASE_MODRM_MEM_OP ( 1 ) : if ( ! ( s -> cpuid_features & CPUID_FXSR ) || ( prefixes & PREFIX_LOCK ) ) { goto illegal_op ; } if ( ( s -> flags & HF_EM_MASK ) || ( s -> flags & HF_TS_MASK ) ) { gen_exception ( s , EXCP07_PREX , pc_start - s -> cs_base ) ; break ; } gen_lea_modrm ( env , s , modrm ) ; gen_helper_fxrstor ( cpu_env , cpu_A0 ) ; break ; CASE_MODRM_MEM_OP ( 2 ) : if ( ( s -> flags & HF_EM_MASK ) || ! ( s -> flags & HF_OSFXSR_MASK ) ) { goto illegal_op ; } if ( s -> flags & HF_TS_MASK ) { gen_exception ( s , EXCP07_PREX , pc_start - s -> cs_base ) ; break ; } gen_lea_modrm ( env , s , modrm ) ; tcg_gen_qemu_ld_i32 ( cpu_tmp2_i32 , cpu_A0 , s -> mem_index , MO_LEUL ) ; gen_helper_ldmxcsr ( cpu_env , cpu_tmp2_i32 ) ; break ; CASE_MODRM_MEM_OP ( 3 ) : if ( ( s -> flags & HF_EM_MASK ) || ! ( s -> flags & HF_OSFXSR_MASK ) ) { goto illegal_op ; } if ( s -> flags & HF_TS_MASK ) { gen_exception ( s , EXCP07_PREX , pc_start - s -> cs_base ) ; break ; } gen_lea_modrm ( env , s , modrm ) ; tcg_gen_ld32u_tl ( cpu_T0 , cpu_env , offsetof ( CPUX86State , mxcsr ) ) ; gen_op_st_v ( s , MO_32 , cpu_T0 , cpu_A0 ) ; break ; CASE_MODRM_MEM_OP ( 4 ) : if ( ( s -> cpuid_ext_features & CPUID_EXT_XSAVE ) == 0 || ( prefixes & ( PREFIX_LOCK | PREFIX_DATA | PREFIX_REPZ | PREFIX_REPNZ ) ) ) { goto illegal_op ; } gen_lea_modrm ( env , s , modrm ) ; tcg_gen_concat_tl_i64 ( cpu_tmp1_i64 , cpu_regs [ R_EAX ] , cpu_regs [ R_EDX ] ) ; gen_helper_xsave ( cpu_env , cpu_A0 , cpu_tmp1_i64 ) ; break ; CASE_MODRM_MEM_OP ( 5 ) : if ( ( s -> cpuid_ext_features & CPUID_EXT_XSAVE ) == 0 || ( prefixes & ( PREFIX_LOCK | PREFIX_DATA | PREFIX_REPZ | PREFIX_REPNZ ) ) ) { goto illegal_op ; } gen_lea_modrm ( env , s , modrm ) ; tcg_gen_concat_tl_i64 ( cpu_tmp1_i64 , cpu_regs [ R_EAX ] , cpu_regs [ R_EDX ] ) ; gen_helper_xrstor ( cpu_env , cpu_A0 , cpu_tmp1_i64 ) ; gen_update_cc_op ( s ) ; gen_jmp_im ( s -> pc - s -> cs_base ) ; gen_eob ( s ) ; break ; CASE_MODRM_MEM_OP ( 6 ) : if ( prefixes & PREFIX_LOCK ) { goto illegal_op ; } if ( prefixes & PREFIX_DATA ) { if ( ! ( s -> cpuid_7_0_ebx_features & CPUID_7_0_EBX_CLWB ) ) { goto illegal_op ; } gen_nop_modrm ( env , s , modrm ) ; } else { if ( ( s -> cpuid_ext_features & CPUID_EXT_XSAVE ) == 0 || ( s -> cpuid_xsave_features & CPUID_XSAVE_XSAVEOPT ) == 0 || ( prefixes & ( PREFIX_REPZ | PREFIX_REPNZ ) ) ) { goto illegal_op ; } gen_lea_modrm ( env , s , modrm ) ; tcg_gen_concat_tl_i64 ( cpu_tmp1_i64 , cpu_regs [ R_EAX ] , cpu_regs [ R_EDX ] ) ; gen_helper_xsaveopt ( cpu_env , cpu_A0 , cpu_tmp1_i64 ) ; } break ; CASE_MODRM_MEM_OP ( 7 ) : if ( prefixes & PREFIX_LOCK ) { goto illegal_op ; } if ( prefixes & PREFIX_DATA ) { if ( ! ( s -> cpuid_7_0_ebx_features & CPUID_7_0_EBX_CLFLUSHOPT ) ) { goto illegal_op ; } } else { if ( ( s -> prefix & ( PREFIX_REPZ | PREFIX_REPNZ ) ) || ! ( s -> cpuid_features & CPUID_CLFLUSH ) ) { goto illegal_op ; } } gen_nop_modrm ( env , s , modrm ) ; break ; case 0xc0 ... 0xc7 : case 0xc8 ... 0xc8 : case 0xd0 ... 0xd7 : case 0xd8 ... 0xd8 : if ( CODE64 ( s ) && ( prefixes & PREFIX_REPZ ) && ! ( prefixes & PREFIX_LOCK ) && ( s -> cpuid_7_0_ebx_features & CPUID_7_0_EBX_FSGSBASE ) ) { TCGv base , treg , src , dst ; tcg_gen_movi_i32 ( cpu_tmp2_i32 , CR4_FSGSBASE_MASK ) ; gen_helper_cr4_testbit ( cpu_env , cpu_tmp2_i32 ) ; base = cpu_seg_base [ modrm & 8 ? R_GS : R_FS ] ; treg = cpu_regs [ ( modrm & 7 ) | REX_B ( s ) ] ; if ( modrm & 0x10 ) { dst = base , src = treg ; } else { dst = treg , src = base ; } if ( s -> dflag == MO_32 ) { tcg_gen_ext32u_tl ( dst , src ) ; } else { tcg_gen_mov_tl ( dst , src ) ; } break ; } goto unknown_op ; case 0xf8 : if ( prefixes & PREFIX_DATA ) { if ( ! ( s -> cpuid_7_0_ebx_features & CPUID_7_0_EBX_PCOMMIT ) || ( prefixes & PREFIX_LOCK ) ) { goto illegal_op ; } break ; } case 0xf9 ... 0xff : if ( ! ( s -> cpuid_features & CPUID_SSE ) || ( prefixes & PREFIX_LOCK ) ) { goto illegal_op ; } tcg_gen_mb ( TCG_MO_ST_ST | TCG_BAR_SC ) ; break ; case 0xe8 ... 0xef : if ( ! ( s -> cpuid_features & CPUID_SSE ) || ( prefixes & PREFIX_LOCK ) ) { goto illegal_op ; } tcg_gen_mb ( TCG_MO_LD_LD | TCG_BAR_SC ) ; break ; case 0xf0 ... 0xf7 : if ( ! ( s -> cpuid_features & CPUID_SSE2 ) || ( prefixes & PREFIX_LOCK ) ) { goto illegal_op ; } tcg_gen_mb ( TCG_MO_ALL | TCG_BAR_SC ) ; break ; default : goto unknown_op ; } break ; case 0x10d : modrm = cpu_ldub_code ( env , s -> pc ++ ) ; mod = ( modrm >> 6 ) & 3 ; if ( mod == 3 ) goto illegal_op ; gen_nop_modrm ( env , s , modrm ) ; break ; case 0x1aa : gen_svm_check_intercept ( s , pc_start , SVM_EXIT_RSM ) ; if ( ! ( s -> flags & HF_SMM_MASK ) ) goto illegal_op ; gen_update_cc_op ( s ) ; gen_jmp_im ( s -> pc - s -> cs_base ) ; gen_helper_rsm ( cpu_env ) ; gen_eob ( s ) ; break ; case 0x1b8 : if ( ( prefixes & ( PREFIX_REPZ | PREFIX_LOCK | PREFIX_REPNZ ) ) != PREFIX_REPZ ) goto illegal_op ; if ( ! ( s -> cpuid_ext_features & CPUID_EXT_POPCNT ) ) goto illegal_op ; modrm = cpu_ldub_code ( env , s -> pc ++ ) ; reg = ( ( modrm >> 3 ) & 7 ) | rex_r ; if ( s -> prefix & PREFIX_DATA ) { ot = MO_16 ; } else { ot = mo_64_32 ( dflag ) ; } gen_ldst_modrm ( env , s , modrm , ot , OR_TMP0 , 0 ) ; gen_extu ( ot , cpu_T0 ) ; tcg_gen_mov_tl ( cpu_cc_src , cpu_T0 ) ; tcg_gen_ctpop_tl ( cpu_T0 , cpu_T0 ) ; gen_op_mov_reg_v ( ot , reg , cpu_T0 ) ; set_cc_op ( s , CC_OP_POPCNT ) ; break ; case 0x10e ... 0x10f : s -> prefix &= ~ ( PREFIX_REPZ | PREFIX_REPNZ | PREFIX_DATA ) ; case 0x110 ... 0x117 : case 0x128 ... 0x12f : case 0x138 ... 0x13a : case 0x150 ... 0x179 : case 0x17c ... 0x17f : case 0x1c2 : case 0x1c4 ... 0x1c6 : case 0x1d0 ... 0x1fe : gen_sse ( env , s , b , pc_start , rex_r ) ; break ; default : goto unknown_op ; } return s -> pc ; illegal_op : gen_illegal_opcode ( s ) ; return s -> pc ; unknown_op : gen_unknown_opcode ( env , s ) ; return s -> pc ; }\n","target":"<S2SV_ModStart> ; next_byte : if ( s -> pc - pc_start > 14 ) { goto illegal_op ; }\n","project_and_commit_id":"qemu@qemu/30663fd26c0307e414622c7a8607fbc04f92ec14","cve_id":"CVE-2017-8284","original_address":"https://github.com/qemu/qemu/commit/30663fd26c0307e414622c7a8607fbc04f92ec14","time":"2017-04-26T14:59Z"},
	{"Unnamed: 0":4323,"cwe_id":"CWE-200","source":"CWE-200 int rds_recvmsg ( struct kiocb * iocb , struct socket * sock , struct msghdr * msg , size_t size , int msg_flags ) { struct sock * sk = sock -> sk ; struct rds_sock * rs = rds_sk_to_rs ( sk ) ; long timeo ; int ret = 0 , nonblock = msg_flags & MSG_DONTWAIT ; struct sockaddr_in * sin ; struct rds_incoming * inc = NULL ; timeo = sock_rcvtimeo ( sk , nonblock ) ; <S2SV_StartBug> rdsdebug ( \"size<S2SV_blank>%zu<S2SV_blank>flags<S2SV_blank>0x%x<S2SV_blank>timeo<S2SV_blank>%ld\\\\n\" , size , msg_flags , timeo ) ; <S2SV_EndBug> if ( msg_flags & MSG_OOB ) goto out ; while ( 1 ) { if ( ! list_empty ( & rs -> rs_notify_queue ) ) { ret = rds_notify_queue_get ( rs , msg ) ; break ; } if ( rs -> rs_cong_notify ) { ret = rds_notify_cong ( rs , msg ) ; break ; } if ( ! rds_next_incoming ( rs , & inc ) ) { if ( nonblock ) { ret = - EAGAIN ; break ; } timeo = wait_event_interruptible_timeout ( * sk_sleep ( sk ) , ( ! list_empty ( & rs -> rs_notify_queue ) || rs -> rs_cong_notify || rds_next_incoming ( rs , & inc ) ) , timeo ) ; rdsdebug ( \"recvmsg<S2SV_blank>woke<S2SV_blank>inc<S2SV_blank>%p<S2SV_blank>timeo<S2SV_blank>%ld\\\\n\" , inc , timeo ) ; if ( timeo > 0 || timeo == MAX_SCHEDULE_TIMEOUT ) continue ; ret = timeo ; if ( ret == 0 ) ret = - ETIMEDOUT ; break ; } rdsdebug ( \"copying<S2SV_blank>inc<S2SV_blank>%p<S2SV_blank>from<S2SV_blank>%pI4:%u<S2SV_blank>to<S2SV_blank>user\\\\n\" , inc , & inc -> i_conn -> c_faddr , ntohs ( inc -> i_hdr . h_sport ) ) ; ret = inc -> i_conn -> c_trans -> inc_copy_to_user ( inc , msg -> msg_iov , size ) ; if ( ret < 0 ) break ; if ( ! rds_still_queued ( rs , inc , ! ( msg_flags & MSG_PEEK ) ) ) { rds_inc_put ( inc ) ; inc = NULL ; rds_stats_inc ( s_recv_deliver_raced ) ; continue ; } if ( ret < be32_to_cpu ( inc -> i_hdr . h_len ) ) { if ( msg_flags & MSG_TRUNC ) ret = be32_to_cpu ( inc -> i_hdr . h_len ) ; msg -> msg_flags |= MSG_TRUNC ; } if ( rds_cmsg_recv ( inc , msg ) ) { ret = - EFAULT ; goto out ; } rds_stats_inc ( s_recv_delivered ) ; sin = ( struct sockaddr_in * ) msg -> msg_name ; if ( sin ) { sin -> sin_family = AF_INET ; sin -> sin_port = inc -> i_hdr . h_sport ; sin -> sin_addr . s_addr = inc -> i_saddr ; memset ( sin -> sin_zero , 0 , sizeof ( sin -> sin_zero ) ) ; <S2SV_StartBug> } <S2SV_EndBug> break ; } if ( inc ) rds_inc_put ( inc ) ; out : return ret ; }\n","target":"<S2SV_ModStart> , timeo ) ; msg -> msg_namelen = 0 <S2SV_ModStart> ) ) ; msg -> msg_namelen = sizeof ( * sin ) ;\n","project_and_commit_id":"torvalds@linux/06b6a1cf6e776426766298d055bb3991957d90a7","cve_id":"CVE-2012-3430","original_address":"https://github.com/torvalds/linux/commit/06b6a1cf6e776426766298d055bb3991957d90a7","time":"2012-10-03T11:02Z"},
	{"Unnamed: 0":6539,"cwe_id":"CWE-119","source":"CWE-119 static int compare_img ( const vpx_image_t * const img1 , const vpx_image_t * const img2 ) { <S2SV_StartBug> const uint32_t c_w = <S2SV_EndBug> ( img1 -> d_w + img1 -> x_chroma_shift ) >> img1 -> x_chroma_shift ; const uint32_t c_h = ( img1 -> d_h + img1 -> y_chroma_shift ) >> img1 -> y_chroma_shift ; uint32_t i ; int match = 1 ; match &= ( img1 -> fmt == img2 -> fmt ) ; match &= ( img1 -> d_w == img2 -> d_w ) ; match &= ( img1 -> d_h == img2 -> d_h ) ; <S2SV_StartBug> for ( i = 0 ; i < img1 -> d_h ; ++ i ) <S2SV_EndBug> match &= ( memcmp ( img1 -> planes [ VPX_PLANE_Y ] + i * img1 -> stride [ VPX_PLANE_Y ] , img2 -> planes [ VPX_PLANE_Y ] + i * img2 -> stride [ VPX_PLANE_Y ] , <S2SV_StartBug> img1 -> d_w ) == 0 ) ; <S2SV_EndBug> for ( i = 0 ; i < c_h ; ++ i ) match &= ( memcmp ( img1 -> planes [ VPX_PLANE_U ] + i * img1 -> stride [ VPX_PLANE_U ] , img2 -> planes [ VPX_PLANE_U ] + i * img2 -> stride [ VPX_PLANE_U ] , c_w ) == 0 ) ; for ( i = 0 ; i < c_h ; ++ i ) match &= ( memcmp ( img1 -> planes [ VPX_PLANE_V ] + i * img1 -> stride [ VPX_PLANE_V ] , img2 -> planes [ VPX_PLANE_V ] + i * img2 -> stride [ VPX_PLANE_V ] , c_w ) == 0 ) ; return match ; }\n","target":"<S2SV_ModStart> img2 ) { uint32_t l_w = img1 -> d_w ; <S2SV_ModEnd> uint32_t c_w = <S2SV_ModStart> d_h ) ; # if CONFIG_VP9_HIGHBITDEPTH if ( img1 -> fmt & VPX_IMG_FMT_HIGHBITDEPTH ) { l_w *= 2 ; c_w *= 2 ; } # endif <S2SV_ModStart> VPX_PLANE_Y ] , l_w <S2SV_ModEnd> ) == 0\n","project_and_commit_id":"external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426","cve_id":"CVE-2016-1621","original_address":"https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426","time":"2016-03-12T21:59Z"},
	{"Unnamed: 0":3021,"cwe_id":"CWE-119","source":"CWE-119 <S2SV_StartBug> static void write_ref_frames ( const VP9_COMP * cpi , vp9_writer * w ) { <S2SV_EndBug> const VP9_COMMON * const cm = & cpi -> common ; const MACROBLOCKD * const xd = & cpi -> mb . e_mbd ; const MB_MODE_INFO * const mbmi = & xd -> mi [ 0 ] -> mbmi ; const int is_compound = has_second_ref ( mbmi ) ; const int segment_id = mbmi -> segment_id ; <S2SV_StartBug> if ( vp9_segfeature_active ( & cm -> seg , segment_id , SEG_LVL_REF_FRAME ) ) { <S2SV_EndBug> <S2SV_StartBug> assert ( ! is_compound ) ; <S2SV_EndBug> assert ( mbmi -> ref_frame [ 0 ] == vp9_get_segdata ( & cm -> seg , segment_id , SEG_LVL_REF_FRAME ) ) ; } else { <S2SV_StartBug> if ( cm -> reference_mode == REFERENCE_MODE_SELECT ) { <S2SV_EndBug> vp9_write ( w , is_compound , vp9_get_reference_mode_prob ( cm , xd ) ) ; } else { assert ( ! is_compound == ( cm -> reference_mode == SINGLE_REFERENCE ) ) ; } if ( is_compound ) { <S2SV_StartBug> vp9_write ( w , mbmi -> ref_frame [ 0 ] == GOLDEN_FRAME , <S2SV_EndBug> vp9_get_pred_prob_comp_ref_p ( cm , xd ) ) ; } else { const int bit0 = mbmi -> ref_frame [ 0 ] != LAST_FRAME ; <S2SV_StartBug> vp9_write ( w , bit0 , vp9_get_pred_prob_single_ref_p1 ( cm , xd ) ) ; <S2SV_EndBug> if ( bit0 ) { const int bit1 = mbmi -> ref_frame [ 0 ] != GOLDEN_FRAME ; <S2SV_StartBug> vp9_write ( w , bit1 , vp9_get_pred_prob_single_ref_p2 ( cm , xd ) ) ; <S2SV_EndBug> } } } }\n","target":"<S2SV_ModStart> write_ref_frames ( const VP9_COMMON * cm , const MACROBLOCKD * xd , vpx_writer * w ) { const MB_MODE_INFO * const mbmi = & xd -> mi [ 0 ] -> mbmi ; const int is_compound = has_second_ref ( mbmi ) ; const int segment_id = mbmi -> segment_id ; if ( segfeature_active ( & cm -> seg , segment_id , SEG_LVL_REF_FRAME ) ) { assert ( ! is_compound ) ; assert ( mbmi -> ref_frame [ 0 ] == get_segdata ( & <S2SV_ModEnd> cm -> seg <S2SV_ModStart> SEG_LVL_REF_FRAME ) ) ; } else { if ( cm -> reference_mode == REFERENCE_MODE_SELECT ) { vpx_write ( w , is_compound , vp9_get_reference_mode_prob ( cm , xd ) ) ; } else <S2SV_ModStart> ( ! is_compound == <S2SV_ModEnd> ( cm -> <S2SV_ModStart> -> reference_mode == <S2SV_ModEnd> SINGLE_REFERENCE ) ) <S2SV_ModStart> is_compound ) { vpx_write <S2SV_ModEnd> ( w , <S2SV_ModStart> != LAST_FRAME ; vpx_write <S2SV_ModEnd> ( w , <S2SV_ModStart> != GOLDEN_FRAME ; vpx_write <S2SV_ModEnd> ( w ,\n","project_and_commit_id":"external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426","cve_id":"CVE-2016-1621","original_address":"https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426","time":"2016-03-12T21:59Z"},
	{"Unnamed: 0":637,"cwe_id":"CWE-119","source":"CWE-119 int hugetlb_mcopy_atomic_pte ( struct mm_struct * dst_mm , pte_t * dst_pte , struct vm_area_struct * dst_vma , unsigned long dst_addr , unsigned long src_addr , struct page * * pagep ) { <S2SV_StartBug> int vm_shared = dst_vma -> vm_flags & VM_SHARED ; <S2SV_EndBug> struct hstate * h = hstate_vma ( dst_vma ) ; pte_t _dst_pte ; spinlock_t * ptl ; int ret ; struct page * page ; if ( ! * pagep ) { ret = - ENOMEM ; page = alloc_huge_page ( dst_vma , dst_addr , 0 ) ; if ( IS_ERR ( page ) ) goto out ; ret = copy_huge_page_from_user ( page , ( const void __user * ) src_addr , pages_per_huge_page ( h ) , false ) ; if ( unlikely ( ret ) ) { ret = - EFAULT ; * pagep = page ; goto out ; } } else { page = * pagep ; * pagep = NULL ; } __SetPageUptodate ( page ) ; set_page_huge_active ( page ) ; <S2SV_StartBug> if ( vm_shared ) { <S2SV_EndBug> <S2SV_StartBug> struct address_space * mapping = dst_vma -> vm_file -> f_mapping ; <S2SV_EndBug> pgoff_t idx = vma_hugecache_offset ( h , dst_vma , dst_addr ) ; ret = huge_add_to_page_cache ( page , mapping , idx ) ; if ( ret ) goto out_release_nounlock ; } ptl = huge_pte_lockptr ( h , dst_mm , dst_pte ) ; <S2SV_StartBug> spin_lock ( ptl ) ; <S2SV_EndBug> ret = - EEXIST ; if ( ! huge_pte_none ( huge_ptep_get ( dst_pte ) ) ) goto out_release_unlock ; if ( vm_shared ) { page_dup_rmap ( page , true ) ; } else { ClearPagePrivate ( page ) ; hugepage_add_new_anon_rmap ( page , dst_vma , dst_addr ) ; } _dst_pte = make_huge_pte ( dst_vma , page , dst_vma -> vm_flags & VM_WRITE ) ; if ( dst_vma -> vm_flags & VM_WRITE ) _dst_pte = huge_pte_mkdirty ( _dst_pte ) ; _dst_pte = pte_mkyoung ( _dst_pte ) ; set_huge_pte_at ( dst_mm , dst_addr , dst_pte , _dst_pte ) ; ( void ) huge_ptep_set_access_flags ( dst_vma , dst_addr , dst_pte , _dst_pte , dst_vma -> vm_flags & VM_WRITE ) ; hugetlb_count_add ( pages_per_huge_page ( h ) , dst_mm ) ; update_mmu_cache ( dst_vma , dst_addr , dst_pte ) ; spin_unlock ( ptl ) ; if ( vm_shared ) unlock_page ( page ) ; ret = 0 ; out : return ret ; out_release_unlock : spin_unlock ( ptl ) ; if ( vm_shared ) unlock_page ( page ) ; out_release_nounlock : put_page ( page ) ; goto out ; }\n","target":"<S2SV_ModStart> pagep ) { struct address_space * mapping ; pgoff_t idx ; unsigned long size ; <S2SV_ModStart> page ) ; mapping = dst_vma -> vm_file -> f_mapping ; idx = vma_hugecache_offset ( h , dst_vma , dst_addr ) ; <S2SV_ModStart> vm_shared ) { size = i_size_read ( mapping -> host ) >> huge_page_shift ( h ) ; ret = - EFAULT ; if ( idx >= size ) goto out_release_nounlock <S2SV_ModEnd> ; ret = <S2SV_ModStart> ( ptl ) ; size = i_size_read ( mapping -> host ) >> huge_page_shift ( h ) ; ret = - EFAULT ; if ( idx >= size ) goto out_release_unlock\n","project_and_commit_id":"torvalds@linux/1e3921471354244f70fe268586ff94a97a6dd4df","cve_id":"CVE-2017-15128","original_address":"https://github.com/torvalds/linux/commit/1e3921471354244f70fe268586ff94a97a6dd4df","time":"2018-01-14T06:29Z"},
	{"Unnamed: 0":490,"cwe_id":"CWE-399","source":"CWE-399 int udpv6_recvmsg ( struct sock * sk , struct msghdr * msg , size_t len , int noblock , int flags , int * addr_len ) { struct ipv6_pinfo * np = inet6_sk ( sk ) ; struct inet_sock * inet = inet_sk ( sk ) ; struct sk_buff * skb ; unsigned int ulen , copied ; int peeked , off = 0 ; int err ; int is_udplite = IS_UDPLITE ( sk ) ; int is_udp4 ; bool slow ; if ( flags & MSG_ERRQUEUE ) return ipv6_recv_error ( sk , msg , len , addr_len ) ; if ( np -> rxpmtu && np -> rxopt . bits . rxpmtu ) return ipv6_recv_rxpmtu ( sk , msg , len , addr_len ) ; try_again : skb = __skb_recv_datagram ( sk , flags | ( noblock ? MSG_DONTWAIT : 0 ) , & peeked , & off , & err ) ; if ( ! skb ) goto out ; ulen = skb -> len - sizeof ( struct udphdr ) ; copied = len ; if ( copied > ulen ) copied = ulen ; else if ( copied < ulen ) msg -> msg_flags |= MSG_TRUNC ; is_udp4 = ( skb -> protocol == htons ( ETH_P_IP ) ) ; if ( copied < ulen || UDP_SKB_CB ( skb ) -> partial_cov ) { if ( udp_lib_checksum_complete ( skb ) ) goto csum_copy_err ; } if ( skb_csum_unnecessary ( skb ) ) err = skb_copy_datagram_msg ( skb , sizeof ( struct udphdr ) , msg , copied ) ; else { err = skb_copy_and_csum_datagram_msg ( skb , sizeof ( struct udphdr ) , msg ) ; if ( err == - EINVAL ) goto csum_copy_err ; } if ( unlikely ( err ) ) { trace_kfree_skb ( skb , udpv6_recvmsg ) ; if ( ! peeked ) { atomic_inc ( & sk -> sk_drops ) ; if ( is_udp4 ) UDP_INC_STATS_USER ( sock_net ( sk ) , UDP_MIB_INERRORS , is_udplite ) ; else UDP6_INC_STATS_USER ( sock_net ( sk ) , UDP_MIB_INERRORS , is_udplite ) ; } goto out_free ; } if ( ! peeked ) { if ( is_udp4 ) UDP_INC_STATS_USER ( sock_net ( sk ) , UDP_MIB_INDATAGRAMS , is_udplite ) ; else UDP6_INC_STATS_USER ( sock_net ( sk ) , UDP_MIB_INDATAGRAMS , is_udplite ) ; } sock_recv_ts_and_drops ( msg , sk , skb ) ; if ( msg -> msg_name ) { DECLARE_SOCKADDR ( struct sockaddr_in6 * , sin6 , msg -> msg_name ) ; sin6 -> sin6_family = AF_INET6 ; sin6 -> sin6_port = udp_hdr ( skb ) -> source ; sin6 -> sin6_flowinfo = 0 ; if ( is_udp4 ) { ipv6_addr_set_v4mapped ( ip_hdr ( skb ) -> saddr , & sin6 -> sin6_addr ) ; sin6 -> sin6_scope_id = 0 ; } else { sin6 -> sin6_addr = ipv6_hdr ( skb ) -> saddr ; sin6 -> sin6_scope_id = ipv6_iface_scope_id ( & sin6 -> sin6_addr , inet6_iif ( skb ) ) ; } * addr_len = sizeof ( * sin6 ) ; } if ( np -> rxopt . all ) ip6_datagram_recv_common_ctl ( sk , msg , skb ) ; if ( is_udp4 ) { if ( inet -> cmsg_flags ) ip_cmsg_recv ( msg , skb ) ; } else { if ( np -> rxopt . all ) ip6_datagram_recv_specific_ctl ( sk , msg , skb ) ; } err = copied ; if ( flags & MSG_TRUNC ) err = ulen ; out_free : skb_free_datagram_locked ( sk , skb ) ; out : return err ; csum_copy_err : slow = lock_sock_fast ( sk ) ; if ( ! skb_kill_datagram ( sk , skb , flags ) ) { if ( is_udp4 ) { UDP_INC_STATS_USER ( sock_net ( sk ) , UDP_MIB_CSUMERRORS , is_udplite ) ; UDP_INC_STATS_USER ( sock_net ( sk ) , UDP_MIB_INERRORS , is_udplite ) ; } else { UDP6_INC_STATS_USER ( sock_net ( sk ) , UDP_MIB_CSUMERRORS , is_udplite ) ; UDP6_INC_STATS_USER ( sock_net ( sk ) , UDP_MIB_INERRORS , is_udplite ) ; } } unlock_sock_fast ( sk , slow ) ; <S2SV_StartBug> if ( noblock ) <S2SV_EndBug> return - EAGAIN ; msg -> msg_flags &= ~ MSG_TRUNC ; goto try_again ; }\n","target":"<S2SV_ModStart> slow ) ; cond_resched ( ) <S2SV_ModEnd> ; msg ->\n","project_and_commit_id":"torvalds@linux/beb39db59d14990e401e235faf66a6b9b31240b0","cve_id":"CVE-2015-5366","original_address":"https://github.com/torvalds/linux/commit/beb39db59d14990e401e235faf66a6b9b31240b0","time":"2015-08-31T10:59Z"},
	{"Unnamed: 0":772,"cwe_id":"CWE-200","source":"CWE-200 int readfile ( char_u * fname , char_u * sfname , linenr_T from , linenr_T lines_to_skip , linenr_T lines_to_read , exarg_T * eap , int flags ) { int fd = 0 ; int newfile = ( flags & READ_NEW ) ; int check_readonly ; int filtering = ( flags & READ_FILTER ) ; int read_stdin = ( flags & READ_STDIN ) ; int read_buffer = ( flags & READ_BUFFER ) ; int read_fifo = ( flags & READ_FIFO ) ; int set_options = newfile || read_buffer || ( eap != NULL && eap -> read_edit ) ; linenr_T read_buf_lnum = 1 ; colnr_T read_buf_col = 0 ; char_u c ; linenr_T lnum = from ; char_u * ptr = NULL ; char_u * buffer = NULL ; char_u * new_buffer = NULL ; char_u * line_start = NULL ; int wasempty ; colnr_T len ; long size = 0 ; char_u * p ; off_T filesize = 0 ; int skip_read = FALSE ; # ifdef FEAT_CRYPT char_u * cryptkey = NULL ; int did_ask_for_key = FALSE ; # endif # ifdef FEAT_PERSISTENT_UNDO context_sha256_T sha_ctx ; int read_undo_file = FALSE ; # endif int split = 0 ; # define UNKNOWN 0x0fffffff linenr_T linecnt ; int error = FALSE ; int ff_error = EOL_UNKNOWN ; long linerest = 0 ; # ifdef UNIX int perm = 0 ; int swap_mode = - 1 ; # else int perm ; # endif int fileformat = 0 ; int keep_fileformat = FALSE ; stat_T st ; int file_readonly ; linenr_T skip_count = 0 ; linenr_T read_count = 0 ; int msg_save = msg_scroll ; linenr_T read_no_eol_lnum = 0 ; int try_mac ; int try_dos ; int try_unix ; int file_rewind = FALSE ; # ifdef FEAT_MBYTE int can_retry ; linenr_T conv_error = 0 ; linenr_T illegal_byte = 0 ; int keep_dest_enc = FALSE ; int bad_char_behavior = BAD_REPLACE ; char_u * tmpname = NULL ; int fio_flags = 0 ; char_u * fenc ; int fenc_alloced ; char_u * fenc_next = NULL ; int advance_fenc = FALSE ; long real_size = 0 ; # ifdef USE_ICONV iconv_t iconv_fd = ( iconv_t ) - 1 ; # ifdef FEAT_EVAL int did_iconv = FALSE ; # endif # endif int converted = FALSE ; int notconverted = FALSE ; char_u conv_rest [ CONV_RESTLEN ] ; int conv_restlen = 0 ; # endif # ifdef FEAT_AUTOCMD buf_T * old_curbuf ; char_u * old_b_ffname ; char_u * old_b_fname ; int using_b_ffname ; int using_b_fname ; # endif # ifdef FEAT_AUTOCMD au_did_filetype = FALSE ; # endif curbuf -> b_no_eol_lnum = 0 ; if ( curbuf -> b_ffname == NULL && ! filtering && fname != NULL && vim_strchr ( p_cpo , CPO_FNAMER ) != NULL && ! ( flags & READ_DUMMY ) ) { if ( set_rw_fname ( fname , sfname ) == FAIL ) return FAIL ; } # ifdef FEAT_AUTOCMD old_curbuf = curbuf ; old_b_ffname = curbuf -> b_ffname ; old_b_fname = curbuf -> b_fname ; using_b_ffname = ( fname == curbuf -> b_ffname ) || ( sfname == curbuf -> b_ffname ) ; using_b_fname = ( fname == curbuf -> b_fname ) || ( sfname == curbuf -> b_fname ) ; # endif ex_no_reprint = TRUE ; need_fileinfo = FALSE ; if ( sfname == NULL ) sfname = fname ; # if defined ( UNIX ) fname = sfname ; # endif # ifdef FEAT_AUTOCMD if ( ! filtering && ! read_stdin && ! read_buffer ) { pos_T pos ; pos = curbuf -> b_op_start ; curbuf -> b_op_start . lnum = ( ( from == 0 ) ? 1 : from ) ; curbuf -> b_op_start . col = 0 ; if ( newfile ) { if ( apply_autocmds_exarg ( EVENT_BUFREADCMD , NULL , sfname , FALSE , curbuf , eap ) ) # ifdef FEAT_EVAL return aborting ( ) ? FAIL : OK ; # else return OK ; # endif } else if ( apply_autocmds_exarg ( EVENT_FILEREADCMD , sfname , sfname , FALSE , NULL , eap ) ) # ifdef FEAT_EVAL return aborting ( ) ? FAIL : OK ; # else return OK ; # endif curbuf -> b_op_start = pos ; } # endif if ( ( shortmess ( SHM_OVER ) || curbuf -> b_help ) && p_verbose == 0 ) msg_scroll = FALSE ; else msg_scroll = TRUE ; if ( fname != NULL && * fname != NUL ) { p = fname + STRLEN ( fname ) ; if ( after_pathsep ( fname , p ) || STRLEN ( fname ) >= MAXPATHL ) { filemess ( curbuf , fname , ( char_u * ) _ ( \"Illegal<S2SV_blank>file<S2SV_blank>name\" ) , 0 ) ; msg_end ( ) ; msg_scroll = msg_save ; return FAIL ; } } if ( ! read_stdin && ! read_buffer && ! read_fifo ) { # ifdef UNIX perm = mch_getperm ( fname ) ; if ( perm >= 0 && ! S_ISREG ( perm ) # ifdef S_ISFIFO && ! S_ISFIFO ( perm ) # endif # ifdef S_ISSOCK && ! S_ISSOCK ( perm ) # endif # ifdef OPEN_CHR_FILES && ! ( S_ISCHR ( perm ) && is_dev_fd_file ( fname ) ) # endif ) { int retval = FAIL ; if ( S_ISDIR ( perm ) ) { filemess ( curbuf , fname , ( char_u * ) _ ( \"is<S2SV_blank>a<S2SV_blank>directory\" ) , 0 ) ; retval = NOTDONE ; } else filemess ( curbuf , fname , ( char_u * ) _ ( \"is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>file\" ) , 0 ) ; msg_end ( ) ; msg_scroll = msg_save ; return retval ; } # endif # if defined ( MSWIN ) if ( ! p_odev && mch_nodetype ( fname ) == NODE_WRITABLE ) { filemess ( curbuf , fname , ( char_u * ) _ ( \"is<S2SV_blank>a<S2SV_blank>device<S2SV_blank>(disabled<S2SV_blank>with<S2SV_blank>\\'opendevice\\'<S2SV_blank>option)\" ) , 0 ) ; msg_end ( ) ; msg_scroll = msg_save ; return FAIL ; } # endif } set_file_options ( set_options , eap ) ; check_readonly = ( newfile && ( curbuf -> b_flags & BF_CHECK_RO ) ) ; if ( check_readonly && ! readonlymode ) curbuf -> b_p_ro = FALSE ; if ( newfile && ! read_stdin && ! read_buffer && ! read_fifo ) { if ( mch_stat ( ( char * ) fname , & st ) >= 0 ) { buf_store_time ( curbuf , & st , fname ) ; curbuf -> b_mtime_read = curbuf -> b_mtime ; # ifdef UNIX swap_mode = ( st . st_mode & 0644 ) | 0600 ; # endif # ifdef FEAT_CW_EDITOR ( void ) GetFSSpecFromPath ( curbuf -> b_ffname , & curbuf -> b_FSSpec ) ; # endif # ifdef VMS curbuf -> b_fab_rfm = st . st_fab_rfm ; curbuf -> b_fab_rat = st . st_fab_rat ; curbuf -> b_fab_mrs = st . st_fab_mrs ; # endif } else { curbuf -> b_mtime = 0 ; curbuf -> b_mtime_read = 0 ; curbuf -> b_orig_size = 0 ; curbuf -> b_orig_mode = 0 ; } curbuf -> b_flags &= ~ ( BF_NEW | BF_NEW_W ) ; } file_readonly = FALSE ; if ( read_stdin ) { # if defined ( MSWIN ) setmode ( 0 , O_BINARY ) ; # endif } else if ( ! read_buffer ) { # ifdef USE_MCH_ACCESS if ( # ifdef UNIX ! ( perm & 0222 ) || # endif mch_access ( ( char * ) fname , W_OK ) ) file_readonly = TRUE ; fd = mch_open ( ( char * ) fname , O_RDONLY | O_EXTRA , 0 ) ; # else if ( ! newfile || readonlymode || ( fd = mch_open ( ( char * ) fname , O_RDWR | O_EXTRA , 0 ) ) < 0 ) { file_readonly = TRUE ; fd = mch_open ( ( char * ) fname , O_RDONLY | O_EXTRA , 0 ) ; } # endif } if ( fd < 0 ) { # ifndef UNIX int isdir_f ; # endif msg_scroll = msg_save ; # ifndef UNIX isdir_f = ( mch_isdir ( fname ) ) ; perm = mch_getperm ( fname ) ; if ( isdir_f ) { filemess ( curbuf , sfname , ( char_u * ) _ ( \"is<S2SV_blank>a<S2SV_blank>directory\" ) , 0 ) ; curbuf -> b_p_ro = TRUE ; } else # endif if ( newfile ) { if ( perm < 0 # ifdef ENOENT && errno == ENOENT # endif ) { curbuf -> b_flags |= BF_NEW ; # ifdef FEAT_QUICKFIX if ( ! bt_dontwrite ( curbuf ) ) # endif { check_need_swap ( newfile ) ; # ifdef FEAT_AUTOCMD if ( curbuf != old_curbuf || ( using_b_ffname && ( old_b_ffname != curbuf -> b_ffname ) ) || ( using_b_fname && ( old_b_fname != curbuf -> b_fname ) ) ) { EMSG ( _ ( e_auchangedbuf ) ) ; return FAIL ; } # endif } if ( dir_of_file_exists ( fname ) ) filemess ( curbuf , sfname , ( char_u * ) _ ( \"[New<S2SV_blank>File]\" ) , 0 ) ; else filemess ( curbuf , sfname , ( char_u * ) _ ( \"[New<S2SV_blank>DIRECTORY]\" ) , 0 ) ; # ifdef FEAT_VIMINFO check_marks_read ( ) ; # endif # ifdef FEAT_MBYTE if ( eap != NULL ) set_forced_fenc ( eap ) ; # endif # ifdef FEAT_AUTOCMD apply_autocmds_exarg ( EVENT_BUFNEWFILE , sfname , sfname , FALSE , curbuf , eap ) ; # endif save_file_ff ( curbuf ) ; # if defined ( FEAT_AUTOCMD ) && defined ( FEAT_EVAL ) if ( aborting ( ) ) return FAIL ; # endif return OK ; } else { filemess ( curbuf , sfname , ( char_u * ) ( # ifdef EFBIG ( errno == EFBIG ) ? _ ( \"[File<S2SV_blank>too<S2SV_blank>big]\" ) : # endif # ifdef EOVERFLOW ( errno == EOVERFLOW ) ? _ ( \"[File<S2SV_blank>too<S2SV_blank>big]\" ) : # endif _ ( \"[Permission<S2SV_blank>Denied]\" ) ) , 0 ) ; curbuf -> b_p_ro = TRUE ; } } return FAIL ; } if ( ( check_readonly && file_readonly ) || curbuf -> b_help ) curbuf -> b_p_ro = TRUE ; if ( set_options ) { if ( ! read_buffer ) { curbuf -> b_p_eol = TRUE ; curbuf -> b_start_eol = TRUE ; } # ifdef FEAT_MBYTE curbuf -> b_p_bomb = FALSE ; curbuf -> b_start_bomb = FALSE ; # endif } # ifdef FEAT_QUICKFIX if ( ! bt_dontwrite ( curbuf ) ) # endif { check_need_swap ( newfile ) ; # ifdef FEAT_AUTOCMD if ( ! read_stdin && ( curbuf != old_curbuf || ( using_b_ffname && ( old_b_ffname != curbuf -> b_ffname ) ) || ( using_b_fname && ( old_b_fname != curbuf -> b_fname ) ) ) ) { EMSG ( _ ( e_auchangedbuf ) ) ; if ( ! read_buffer ) close ( fd ) ; return FAIL ; } # endif # ifdef UNIX if ( swap_mode > 0 && curbuf -> b_ml . ml_mfp != NULL && curbuf -> b_ml . ml_mfp -> mf_fname != NULL ) <S2SV_StartBug> ( void ) mch_setperm ( curbuf -> b_ml . ml_mfp -> mf_fname , ( long ) swap_mode ) ; <S2SV_EndBug> # endif } # if defined ( HAS_SWAP_EXISTS_ACTION ) if ( swap_exists_action == SEA_QUIT ) { if ( ! read_buffer && ! read_stdin ) close ( fd ) ; return FAIL ; } # endif ++ no_wait_return ; curbuf -> b_op_start . lnum = ( ( from == 0 ) ? 1 : from ) ; curbuf -> b_op_start . col = 0 ; try_mac = ( vim_strchr ( p_ffs , 'm' ) != NULL ) ; try_dos = ( vim_strchr ( p_ffs , 'd' ) != NULL ) ; try_unix = ( vim_strchr ( p_ffs , 'x' ) != NULL ) ; # ifdef FEAT_AUTOCMD if ( ! read_buffer ) { int m = msg_scroll ; int n = msg_scrolled ; if ( ! read_stdin ) close ( fd ) ; msg_scroll = TRUE ; if ( filtering ) apply_autocmds_exarg ( EVENT_FILTERREADPRE , NULL , sfname , FALSE , curbuf , eap ) ; else if ( read_stdin ) apply_autocmds_exarg ( EVENT_STDINREADPRE , NULL , sfname , FALSE , curbuf , eap ) ; else if ( newfile ) apply_autocmds_exarg ( EVENT_BUFREADPRE , NULL , sfname , FALSE , curbuf , eap ) ; else apply_autocmds_exarg ( EVENT_FILEREADPRE , sfname , sfname , FALSE , NULL , eap ) ; try_mac = ( vim_strchr ( p_ffs , 'm' ) != NULL ) ; try_dos = ( vim_strchr ( p_ffs , 'd' ) != NULL ) ; try_unix = ( vim_strchr ( p_ffs , 'x' ) != NULL ) ; if ( msg_scrolled == n ) msg_scroll = m ; # ifdef FEAT_EVAL if ( aborting ( ) ) { -- no_wait_return ; msg_scroll = msg_save ; curbuf -> b_p_ro = TRUE ; return FAIL ; } # endif if ( ! read_stdin && ( curbuf != old_curbuf || ( using_b_ffname && ( old_b_ffname != curbuf -> b_ffname ) ) || ( using_b_fname && ( old_b_fname != curbuf -> b_fname ) ) || ( fd = mch_open ( ( char * ) fname , O_RDONLY | O_EXTRA , 0 ) ) < 0 ) ) { -- no_wait_return ; msg_scroll = msg_save ; if ( fd < 0 ) EMSG ( _ ( \"E200:<S2SV_blank>*ReadPre<S2SV_blank>autocommands<S2SV_blank>made<S2SV_blank>the<S2SV_blank>file<S2SV_blank>unreadable\" ) ) ; else EMSG ( _ ( \"E201:<S2SV_blank>*ReadPre<S2SV_blank>autocommands<S2SV_blank>must<S2SV_blank>not<S2SV_blank>change<S2SV_blank>current<S2SV_blank>buffer\" ) ) ; curbuf -> b_p_ro = TRUE ; return FAIL ; } } # endif wasempty = ( curbuf -> b_ml . ml_flags & ML_EMPTY ) ; if ( ! recoverymode && ! filtering && ! ( flags & READ_DUMMY ) ) { if ( read_stdin ) { # ifndef ALWAYS_USE_GUI mch_msg ( _ ( \"Vim:<S2SV_blank>Reading<S2SV_blank>from<S2SV_blank>stdin...\\\\n\" ) ) ; # endif # ifdef FEAT_GUI if ( gui . in_use && ! gui . dying && ! gui . starting ) { p = ( char_u * ) _ ( \"Reading<S2SV_blank>from<S2SV_blank>stdin...\" ) ; gui_write ( p , ( int ) STRLEN ( p ) ) ; } # endif } else if ( ! read_buffer ) filemess ( curbuf , sfname , ( char_u * ) \"\" , 0 ) ; } msg_scroll = FALSE ; linecnt = curbuf -> b_ml . ml_line_count ; # ifdef FEAT_MBYTE if ( eap != NULL && eap -> bad_char != 0 ) { bad_char_behavior = eap -> bad_char ; if ( set_options ) curbuf -> b_bad_char = eap -> bad_char ; } else curbuf -> b_bad_char = 0 ; if ( eap != NULL && eap -> force_enc != 0 ) { fenc = enc_canonize ( eap -> cmd + eap -> force_enc ) ; fenc_alloced = TRUE ; keep_dest_enc = TRUE ; } else if ( curbuf -> b_p_bin ) { fenc = ( char_u * ) \"\" ; fenc_alloced = FALSE ; } else if ( curbuf -> b_help ) { char_u firstline [ 80 ] ; int fc ; fenc = ( char_u * ) \"latin1\" ; c = enc_utf8 ; if ( ! c && ! read_stdin ) { fc = fname [ STRLEN ( fname ) - 1 ] ; if ( TOLOWER_ASC ( fc ) == 'x' ) { len = read_eintr ( fd , firstline , 80 ) ; vim_lseek ( fd , ( off_T ) 0L , SEEK_SET ) ; for ( p = firstline ; p < firstline + len ; ++ p ) if ( * p >= 0x80 ) { c = TRUE ; break ; } } } if ( c ) { fenc_next = fenc ; fenc = ( char_u * ) \"utf-8\" ; if ( ! enc_utf8 ) keep_dest_enc = TRUE ; } fenc_alloced = FALSE ; } else if ( * p_fencs == NUL ) { fenc = curbuf -> b_p_fenc ; fenc_alloced = FALSE ; } else { fenc_next = p_fencs ; fenc = next_fenc ( & fenc_next ) ; fenc_alloced = TRUE ; } # endif retry : if ( file_rewind ) { if ( read_buffer ) { read_buf_lnum = 1 ; read_buf_col = 0 ; } else if ( read_stdin || vim_lseek ( fd , ( off_T ) 0L , SEEK_SET ) != 0 ) { error = TRUE ; goto failed ; } while ( lnum > from ) ml_delete ( lnum -- , FALSE ) ; file_rewind = FALSE ; # ifdef FEAT_MBYTE if ( set_options ) { curbuf -> b_p_bomb = FALSE ; curbuf -> b_start_bomb = FALSE ; } conv_error = 0 ; # endif } if ( keep_fileformat ) keep_fileformat = FALSE ; else { if ( eap != NULL && eap -> force_ff != 0 ) { fileformat = get_fileformat_force ( curbuf , eap ) ; try_unix = try_dos = try_mac = FALSE ; } else if ( curbuf -> b_p_bin ) fileformat = EOL_UNIX ; else if ( * p_ffs == NUL ) fileformat = get_fileformat ( curbuf ) ; else fileformat = EOL_UNKNOWN ; } # ifdef FEAT_MBYTE # ifdef USE_ICONV if ( iconv_fd != ( iconv_t ) - 1 ) { iconv_close ( iconv_fd ) ; iconv_fd = ( iconv_t ) - 1 ; } # endif if ( advance_fenc ) { advance_fenc = FALSE ; if ( eap != NULL && eap -> force_enc != 0 ) { notconverted = TRUE ; conv_error = 0 ; if ( fenc_alloced ) vim_free ( fenc ) ; fenc = ( char_u * ) \"\" ; fenc_alloced = FALSE ; } else { if ( fenc_alloced ) vim_free ( fenc ) ; if ( fenc_next != NULL ) { fenc = next_fenc ( & fenc_next ) ; fenc_alloced = ( fenc_next != NULL ) ; } else { fenc = ( char_u * ) \"\" ; fenc_alloced = FALSE ; } } if ( tmpname != NULL ) { mch_remove ( tmpname ) ; vim_free ( tmpname ) ; tmpname = NULL ; } } fio_flags = 0 ; converted = need_conversion ( fenc ) ; if ( converted ) { if ( STRCMP ( fenc , ENC_UCSBOM ) == 0 ) fio_flags = FIO_UCSBOM ; else if ( enc_utf8 || STRCMP ( p_enc , \"latin1\" ) == 0 ) fio_flags = get_fio_flags ( fenc ) ; # ifdef WIN3264 if ( fio_flags == 0 ) fio_flags = get_win_fio_flags ( fenc ) ; # endif # ifdef MACOS_CONVERT if ( fio_flags == 0 ) fio_flags = get_mac_fio_flags ( fenc ) ; # endif # ifdef USE_ICONV if ( fio_flags == 0 # ifdef FEAT_EVAL && ! did_iconv # endif ) iconv_fd = ( iconv_t ) my_iconv_open ( enc_utf8 ? ( char_u * ) \"utf-8\" : p_enc , fenc ) ; # endif # ifdef FEAT_EVAL if ( fio_flags == 0 && ! read_stdin && ! read_buffer && * p_ccv != NUL && ! read_fifo # ifdef USE_ICONV && iconv_fd == ( iconv_t ) - 1 # endif ) { # ifdef USE_ICONV did_iconv = FALSE ; # endif if ( tmpname == NULL ) { tmpname = readfile_charconvert ( fname , fenc , & fd ) ; if ( tmpname == NULL ) { advance_fenc = TRUE ; if ( fd < 0 ) { EMSG ( _ ( \"E202:<S2SV_blank>Conversion<S2SV_blank>made<S2SV_blank>file<S2SV_blank>unreadable!\" ) ) ; error = TRUE ; goto failed ; } goto retry ; } } } else # endif { if ( fio_flags == 0 # ifdef USE_ICONV && iconv_fd == ( iconv_t ) - 1 # endif ) { advance_fenc = TRUE ; goto retry ; } } } can_retry = ( * fenc != NUL && ! read_stdin && ! read_fifo && ! keep_dest_enc ) ; # endif if ( ! skip_read ) { linerest = 0 ; filesize = 0 ; skip_count = lines_to_skip ; read_count = lines_to_read ; # ifdef FEAT_MBYTE conv_restlen = 0 ; # endif # ifdef FEAT_PERSISTENT_UNDO read_undo_file = ( newfile && ( flags & READ_KEEP_UNDO ) == 0 && curbuf -> b_ffname != NULL && curbuf -> b_p_udf && ! filtering && ! read_fifo && ! read_stdin && ! read_buffer ) ; if ( read_undo_file ) sha256_start ( & sha_ctx ) ; # endif # ifdef FEAT_CRYPT if ( curbuf -> b_cryptstate != NULL ) { crypt_free_state ( curbuf -> b_cryptstate ) ; curbuf -> b_cryptstate = NULL ; } # endif } while ( ! error && ! got_int ) { # if VIM_SIZEOF_INT <= 2 if ( linerest >= 0x7ff0 ) { ++ split ; * ptr = NL ; size = 1 ; } else # endif { if ( ! skip_read ) { # if VIM_SIZEOF_INT > 2 # if defined ( SSIZE_MAX ) && ( SSIZE_MAX < 0x10000L ) size = SSIZE_MAX ; # else size = 0x10000L ; # endif # else size = 0x7ff0L - linerest ; # endif for ( ; size >= 10 ; size = ( long ) ( ( long_u ) size >> 1 ) ) { if ( ( new_buffer = lalloc ( ( long_u ) ( size + linerest + 1 ) , FALSE ) ) != NULL ) break ; } if ( new_buffer == NULL ) { do_outofmem_msg ( ( long_u ) ( size * 2 + linerest + 1 ) ) ; error = TRUE ; break ; } if ( linerest ) mch_memmove ( new_buffer , ptr - linerest , ( size_t ) linerest ) ; vim_free ( buffer ) ; buffer = new_buffer ; ptr = buffer + linerest ; line_start = buffer ; # ifdef FEAT_MBYTE real_size = ( int ) size ; # ifdef USE_ICONV if ( iconv_fd != ( iconv_t ) - 1 ) size = size / ICONV_MULT ; else # endif if ( fio_flags & FIO_LATIN1 ) size = size / 2 ; else if ( fio_flags & ( FIO_UCS2 | FIO_UTF16 ) ) size = ( size * 2 / 3 ) & ~ 1 ; else if ( fio_flags & FIO_UCS4 ) size = ( size * 2 / 3 ) & ~ 3 ; else if ( fio_flags == FIO_UCSBOM ) size = size / ICONV_MULT ; # ifdef WIN3264 else if ( fio_flags & FIO_CODEPAGE ) size = size / ICONV_MULT ; # endif # ifdef MACOS_CONVERT else if ( fio_flags & FIO_MACROMAN ) size = size / ICONV_MULT ; # endif # endif # ifdef FEAT_MBYTE if ( conv_restlen > 0 ) { mch_memmove ( ptr , conv_rest , conv_restlen ) ; ptr += conv_restlen ; size -= conv_restlen ; } # endif if ( read_buffer ) { if ( read_buf_lnum > from ) size = 0 ; else { int n , ni ; long tlen ; tlen = 0 ; for ( ; ; ) { p = ml_get ( read_buf_lnum ) + read_buf_col ; n = ( int ) STRLEN ( p ) ; if ( ( int ) tlen + n + 1 > size ) { n = ( int ) ( size - tlen ) ; for ( ni = 0 ; ni < n ; ++ ni ) { if ( p [ ni ] == NL ) ptr [ tlen ++ ] = NUL ; else ptr [ tlen ++ ] = p [ ni ] ; } read_buf_col += n ; break ; } else { for ( ni = 0 ; ni < n ; ++ ni ) { if ( p [ ni ] == NL ) ptr [ tlen ++ ] = NUL ; else ptr [ tlen ++ ] = p [ ni ] ; } ptr [ tlen ++ ] = NL ; read_buf_col = 0 ; if ( ++ read_buf_lnum > from ) { if ( ! curbuf -> b_p_eol ) -- tlen ; size = tlen ; break ; } } } } } else { size = read_eintr ( fd , ptr , size ) ; } # ifdef FEAT_CRYPT if ( filesize == 0 && size > 0 ) cryptkey = check_for_cryptkey ( cryptkey , ptr , & size , & filesize , newfile , sfname , & did_ask_for_key ) ; if ( cryptkey != NULL && curbuf -> b_cryptstate != NULL && size > 0 ) { if ( crypt_works_inplace ( curbuf -> b_cryptstate ) ) { crypt_decode_inplace ( curbuf -> b_cryptstate , ptr , size ) ; } else { char_u * newptr = NULL ; int decrypted_size ; decrypted_size = crypt_decode_alloc ( curbuf -> b_cryptstate , ptr , size , & newptr ) ; if ( size > 0 && decrypted_size == 0 ) continue ; if ( linerest == 0 ) { new_buffer = newptr ; } else { long_u new_size ; new_size = ( long_u ) ( decrypted_size + linerest + 1 ) ; new_buffer = lalloc ( new_size , FALSE ) ; if ( new_buffer == NULL ) { do_outofmem_msg ( new_size ) ; error = TRUE ; break ; } mch_memmove ( new_buffer , buffer , linerest ) ; if ( newptr != NULL ) mch_memmove ( new_buffer + linerest , newptr , decrypted_size ) ; } if ( new_buffer != NULL ) { vim_free ( buffer ) ; buffer = new_buffer ; new_buffer = NULL ; line_start = buffer ; ptr = buffer + linerest ; } size = decrypted_size ; } } # endif if ( size <= 0 ) { if ( size < 0 ) error = TRUE ; # ifdef FEAT_MBYTE else if ( conv_restlen > 0 ) { if ( fio_flags != 0 # ifdef USE_ICONV || iconv_fd != ( iconv_t ) - 1 # endif ) { if ( can_retry ) goto rewind_retry ; if ( conv_error == 0 ) conv_error = curbuf -> b_ml . ml_line_count - linecnt + 1 ; } else if ( illegal_byte == 0 ) illegal_byte = curbuf -> b_ml . ml_line_count - linecnt + 1 ; if ( bad_char_behavior == BAD_DROP ) { * ( ptr - conv_restlen ) = NUL ; conv_restlen = 0 ; } else { if ( bad_char_behavior != BAD_KEEP && ( fio_flags != 0 # ifdef USE_ICONV || iconv_fd != ( iconv_t ) - 1 # endif ) ) { while ( conv_restlen > 0 ) { * ( -- ptr ) = bad_char_behavior ; -- conv_restlen ; } } fio_flags = 0 ; # ifdef USE_ICONV if ( iconv_fd != ( iconv_t ) - 1 ) { iconv_close ( iconv_fd ) ; iconv_fd = ( iconv_t ) - 1 ; } # endif } } # endif } } skip_read = FALSE ; # ifdef FEAT_MBYTE if ( ( filesize == 0 # ifdef FEAT_CRYPT || ( cryptkey != NULL && filesize == crypt_get_header_len ( crypt_get_method_nr ( curbuf ) ) ) # endif ) && ( fio_flags == FIO_UCSBOM || ( ! curbuf -> b_p_bomb && tmpname == NULL && ( * fenc == 'u' || ( * fenc == NUL && enc_utf8 ) ) ) ) ) { char_u * ccname ; int blen ; if ( size < 2 || curbuf -> b_p_bin ) ccname = NULL ; else ccname = check_for_bom ( ptr , size , & blen , fio_flags == FIO_UCSBOM ? FIO_ALL : get_fio_flags ( fenc ) ) ; if ( ccname != NULL ) { filesize += blen ; size -= blen ; mch_memmove ( ptr , ptr + blen , ( size_t ) size ) ; if ( set_options ) { curbuf -> b_p_bomb = TRUE ; curbuf -> b_start_bomb = TRUE ; } } if ( fio_flags == FIO_UCSBOM ) { if ( ccname == NULL ) { advance_fenc = TRUE ; } else { if ( fenc_alloced ) vim_free ( fenc ) ; fenc = ccname ; fenc_alloced = FALSE ; } skip_read = TRUE ; goto retry ; } } ptr -= conv_restlen ; size += conv_restlen ; conv_restlen = 0 ; # endif if ( size <= 0 ) break ; # ifdef FEAT_MBYTE # ifdef USE_ICONV if ( iconv_fd != ( iconv_t ) - 1 ) { const char * fromp ; char * top ; size_t from_size ; size_t to_size ; fromp = ( char * ) ptr ; from_size = size ; ptr += size ; top = ( char * ) ptr ; to_size = real_size - size ; while ( ( iconv ( iconv_fd , ( void * ) & fromp , & from_size , & top , & to_size ) == ( size_t ) - 1 && ICONV_ERRNO != ICONV_EINVAL ) || from_size > CONV_RESTLEN ) { if ( can_retry ) goto rewind_retry ; if ( conv_error == 0 ) conv_error = readfile_linenr ( linecnt , ptr , ( char_u * ) top ) ; ++ fromp ; -- from_size ; if ( bad_char_behavior == BAD_KEEP ) { * top ++ = * ( fromp - 1 ) ; -- to_size ; } else if ( bad_char_behavior != BAD_DROP ) { * top ++ = bad_char_behavior ; -- to_size ; } } if ( from_size > 0 ) { mch_memmove ( conv_rest , ( char_u * ) fromp , from_size ) ; conv_restlen = ( int ) from_size ; } line_start = ptr - linerest ; mch_memmove ( line_start , buffer , ( size_t ) linerest ) ; size = ( long ) ( ( char_u * ) top - ptr ) ; } # endif # ifdef WIN3264 if ( fio_flags & FIO_CODEPAGE ) { char_u * src , * dst ; WCHAR ucs2buf [ 3 ] ; int ucs2len ; int codepage = FIO_GET_CP ( fio_flags ) ; int bytelen ; int found_bad ; char replstr [ 2 ] ; if ( bad_char_behavior > 0 ) replstr [ 0 ] = bad_char_behavior ; else replstr [ 0 ] = '?' ; replstr [ 1 ] = NUL ; src = ptr + real_size - size ; mch_memmove ( src , ptr , size ) ; dst = ptr ; size = size ; while ( size > 0 ) { found_bad = FALSE ; # ifdef CP_UTF8 if ( codepage == CP_UTF8 ) { bytelen = ( int ) utf_ptr2len_len ( src , size ) ; if ( bytelen > size ) { if ( bytelen <= CONV_RESTLEN ) break ; bytelen = size ; found_bad = TRUE ; } else { int u8c = utf_ptr2char ( src ) ; if ( u8c > 0xffff || ( * src >= 0x80 && bytelen == 1 ) ) found_bad = TRUE ; ucs2buf [ 0 ] = u8c ; ucs2len = 1 ; } } else # endif { for ( bytelen = 1 ; bytelen <= size && bytelen <= 3 ; ++ bytelen ) { ucs2len = MultiByteToWideChar ( codepage , MB_ERR_INVALID_CHARS , ( LPCSTR ) src , bytelen , ucs2buf , 3 ) ; if ( ucs2len > 0 ) break ; } if ( ucs2len == 0 ) { if ( size == 1 ) break ; found_bad = TRUE ; bytelen = 1 ; } } if ( ! found_bad ) { int i ; if ( enc_utf8 ) { for ( i = 0 ; i < ucs2len ; ++ i ) dst += utf_char2bytes ( ucs2buf [ i ] , dst ) ; } else { BOOL bad = FALSE ; int dstlen ; dstlen = WideCharToMultiByte ( enc_codepage , 0 , ( LPCWSTR ) ucs2buf , ucs2len , ( LPSTR ) dst , ( int ) ( src - dst ) , replstr , & bad ) ; if ( bad ) found_bad = TRUE ; else dst += dstlen ; } } if ( found_bad ) { if ( can_retry ) goto rewind_retry ; if ( conv_error == 0 ) conv_error = readfile_linenr ( linecnt , ptr , dst ) ; if ( bad_char_behavior != BAD_DROP ) { if ( bad_char_behavior == BAD_KEEP ) { mch_memmove ( dst , src , bytelen ) ; dst += bytelen ; } else * dst ++ = bad_char_behavior ; } } src += bytelen ; size -= bytelen ; } if ( size > 0 ) { mch_memmove ( conv_rest , src , size ) ; conv_restlen = size ; } size = ( long ) ( dst - ptr ) ; } else # endif # ifdef MACOS_CONVERT if ( fio_flags & FIO_MACROMAN ) { if ( macroman2enc ( ptr , & size , real_size ) == FAIL ) goto rewind_retry ; } else # endif if ( fio_flags != 0 ) { int u8c ; char_u * dest ; char_u * tail = NULL ; dest = ptr + real_size ; if ( fio_flags == FIO_LATIN1 || fio_flags == FIO_UTF8 ) { p = ptr + size ; if ( fio_flags == FIO_UTF8 ) { tail = ptr + size - 1 ; while ( tail > ptr && ( * tail & 0xc0 ) == 0x80 ) -- tail ; if ( tail + utf_byte2len ( * tail ) <= ptr + size ) tail = NULL ; else p = tail ; } } else if ( fio_flags & ( FIO_UCS2 | FIO_UTF16 ) ) { p = ptr + ( size & ~ 1 ) ; if ( size & 1 ) tail = p ; if ( ( fio_flags & FIO_UTF16 ) && p > ptr ) { if ( fio_flags & FIO_ENDIAN_L ) { u8c = ( * -- p << 8 ) ; u8c += * -- p ; } else { u8c = * -- p ; u8c += ( * -- p << 8 ) ; } if ( u8c >= 0xd800 && u8c <= 0xdbff ) tail = p ; else p += 2 ; } } else { p = ptr + ( size & ~ 3 ) ; if ( size & 3 ) tail = p ; } if ( tail != NULL ) { conv_restlen = ( int ) ( ( ptr + size ) - tail ) ; mch_memmove ( conv_rest , ( char_u * ) tail , conv_restlen ) ; size -= conv_restlen ; } while ( p > ptr ) { if ( fio_flags & FIO_LATIN1 ) u8c = * -- p ; else if ( fio_flags & ( FIO_UCS2 | FIO_UTF16 ) ) { if ( fio_flags & FIO_ENDIAN_L ) { u8c = ( * -- p << 8 ) ; u8c += * -- p ; } else { u8c = * -- p ; u8c += ( * -- p << 8 ) ; } if ( ( fio_flags & FIO_UTF16 ) && u8c >= 0xdc00 && u8c <= 0xdfff ) { int u16c ; if ( p == ptr ) { if ( can_retry ) goto rewind_retry ; if ( conv_error == 0 ) conv_error = readfile_linenr ( linecnt , ptr , p ) ; if ( bad_char_behavior == BAD_DROP ) continue ; if ( bad_char_behavior != BAD_KEEP ) u8c = bad_char_behavior ; } if ( fio_flags & FIO_ENDIAN_L ) { u16c = ( * -- p << 8 ) ; u16c += * -- p ; } else { u16c = * -- p ; u16c += ( * -- p << 8 ) ; } u8c = 0x10000 + ( ( u16c & 0x3ff ) << 10 ) + ( u8c & 0x3ff ) ; if ( u16c < 0xd800 || u16c > 0xdbff ) { if ( can_retry ) goto rewind_retry ; if ( conv_error == 0 ) conv_error = readfile_linenr ( linecnt , ptr , p ) ; if ( bad_char_behavior == BAD_DROP ) continue ; if ( bad_char_behavior != BAD_KEEP ) u8c = bad_char_behavior ; } } } else if ( fio_flags & FIO_UCS4 ) { if ( fio_flags & FIO_ENDIAN_L ) { u8c = ( unsigned ) * -- p << 24 ; u8c += ( unsigned ) * -- p << 16 ; u8c += ( unsigned ) * -- p << 8 ; u8c += * -- p ; } else { u8c = * -- p ; u8c += ( unsigned ) * -- p << 8 ; u8c += ( unsigned ) * -- p << 16 ; u8c += ( unsigned ) * -- p << 24 ; } } else { if ( * -- p < 0x80 ) u8c = * p ; else { len = utf_head_off ( ptr , p ) ; p -= len ; u8c = utf_ptr2char ( p ) ; if ( len == 0 ) { if ( can_retry ) goto rewind_retry ; if ( conv_error == 0 ) conv_error = readfile_linenr ( linecnt , ptr , p ) ; if ( bad_char_behavior == BAD_DROP ) continue ; if ( bad_char_behavior != BAD_KEEP ) u8c = bad_char_behavior ; } } } if ( enc_utf8 ) { dest -= utf_char2len ( u8c ) ; ( void ) utf_char2bytes ( u8c , dest ) ; } else { -- dest ; if ( u8c >= 0x100 ) { if ( can_retry ) goto rewind_retry ; if ( conv_error == 0 ) conv_error = readfile_linenr ( linecnt , ptr , p ) ; if ( bad_char_behavior == BAD_DROP ) ++ dest ; else if ( bad_char_behavior == BAD_KEEP ) * dest = u8c ; else if ( eap != NULL && eap -> bad_char != 0 ) * dest = bad_char_behavior ; else * dest = 0xBF ; } else * dest = u8c ; } } line_start = dest - linerest ; mch_memmove ( line_start , buffer , ( size_t ) linerest ) ; size = ( long ) ( ( ptr + real_size ) - dest ) ; ptr = dest ; } else if ( enc_utf8 && ! curbuf -> b_p_bin ) { int incomplete_tail = FALSE ; for ( p = ptr ; ; ++ p ) { int todo = ( int ) ( ( ptr + size ) - p ) ; int l ; if ( todo <= 0 ) break ; if ( * p >= 0x80 ) { l = utf_ptr2len_len ( p , todo ) ; if ( l > todo && ! incomplete_tail ) { if ( p > ptr || filesize > 0 ) incomplete_tail = TRUE ; if ( p > ptr ) { conv_restlen = todo ; mch_memmove ( conv_rest , p , conv_restlen ) ; size -= conv_restlen ; break ; } } if ( l == 1 || l > todo ) { if ( can_retry && ! incomplete_tail ) break ; # ifdef USE_ICONV if ( iconv_fd != ( iconv_t ) - 1 && conv_error == 0 ) conv_error = readfile_linenr ( linecnt , ptr , p ) ; # endif if ( conv_error == 0 && illegal_byte == 0 ) illegal_byte = readfile_linenr ( linecnt , ptr , p ) ; if ( bad_char_behavior == BAD_DROP ) { mch_memmove ( p , p + 1 , todo - 1 ) ; -- p ; -- size ; } else if ( bad_char_behavior != BAD_KEEP ) * p = bad_char_behavior ; } else p += l - 1 ; } } if ( p < ptr + size && ! incomplete_tail ) { rewind_retry : # if defined ( FEAT_EVAL ) && defined ( USE_ICONV ) if ( * p_ccv != NUL && iconv_fd != ( iconv_t ) - 1 ) did_iconv = TRUE ; else # endif advance_fenc = TRUE ; file_rewind = TRUE ; goto retry ; } } # endif filesize += size ; if ( fileformat == EOL_UNKNOWN ) { if ( try_dos || try_unix ) { if ( try_mac ) try_mac = 1 ; for ( p = ptr ; p < ptr + size ; ++ p ) { if ( * p == NL ) { if ( ! try_unix || ( try_dos && p > ptr && p [ - 1 ] == CAR ) ) fileformat = EOL_DOS ; else fileformat = EOL_UNIX ; break ; } else if ( * p == CAR && try_mac ) try_mac ++ ; } if ( fileformat == EOL_UNIX && try_mac ) { try_mac = 1 ; try_unix = 1 ; for ( ; p >= ptr && * p != CAR ; p -- ) ; if ( p >= ptr ) { for ( p = ptr ; p < ptr + size ; ++ p ) { if ( * p == NL ) try_unix ++ ; else if ( * p == CAR ) try_mac ++ ; } if ( try_mac > try_unix ) fileformat = EOL_MAC ; } } else if ( fileformat == EOL_UNKNOWN && try_mac == 1 ) fileformat = default_fileformat ( ) ; } if ( fileformat == EOL_UNKNOWN && try_mac ) fileformat = EOL_MAC ; if ( fileformat == EOL_UNKNOWN ) fileformat = default_fileformat ( ) ; if ( set_options ) set_fileformat ( fileformat , OPT_LOCAL ) ; } } if ( fileformat == EOL_MAC ) { -- ptr ; while ( ++ ptr , -- size >= 0 ) { if ( ( c = * ptr ) != NUL && c != CAR && c != NL ) continue ; if ( c == NUL ) * ptr = NL ; else if ( c == NL ) * ptr = CAR ; else { if ( skip_count == 0 ) { * ptr = NUL ; len = ( colnr_T ) ( ptr - line_start + 1 ) ; if ( ml_append ( lnum , line_start , len , newfile ) == FAIL ) { error = TRUE ; break ; } # ifdef FEAT_PERSISTENT_UNDO if ( read_undo_file ) sha256_update ( & sha_ctx , line_start , len ) ; # endif ++ lnum ; if ( -- read_count == 0 ) { error = TRUE ; line_start = ptr ; break ; } } else -- skip_count ; line_start = ptr + 1 ; } } } else { -- ptr ; while ( ++ ptr , -- size >= 0 ) { if ( ( c = * ptr ) != NUL && c != NL ) continue ; if ( c == NUL ) * ptr = NL ; else { if ( skip_count == 0 ) { * ptr = NUL ; len = ( colnr_T ) ( ptr - line_start + 1 ) ; if ( fileformat == EOL_DOS ) { if ( ptr > line_start && ptr [ - 1 ] == CAR ) { ptr [ - 1 ] = NUL ; -- len ; } else if ( ff_error != EOL_DOS ) { if ( try_unix && ! read_stdin && ( read_buffer || vim_lseek ( fd , ( off_T ) 0L , SEEK_SET ) == 0 ) ) { fileformat = EOL_UNIX ; if ( set_options ) set_fileformat ( EOL_UNIX , OPT_LOCAL ) ; file_rewind = TRUE ; keep_fileformat = TRUE ; goto retry ; } ff_error = EOL_DOS ; } } if ( ml_append ( lnum , line_start , len , newfile ) == FAIL ) { error = TRUE ; break ; } # ifdef FEAT_PERSISTENT_UNDO if ( read_undo_file ) sha256_update ( & sha_ctx , line_start , len ) ; # endif ++ lnum ; if ( -- read_count == 0 ) { error = TRUE ; line_start = ptr ; break ; } } else -- skip_count ; line_start = ptr + 1 ; } } } linerest = ( long ) ( ptr - line_start ) ; ui_breakcheck ( ) ; } failed : if ( error && read_count == 0 ) error = FALSE ; if ( ! error && ! got_int && linerest != 0 && ! ( ! curbuf -> b_p_bin && fileformat == EOL_DOS && * line_start == Ctrl_Z && ptr == line_start + 1 ) ) { if ( set_options ) curbuf -> b_p_eol = FALSE ; * ptr = NUL ; len = ( colnr_T ) ( ptr - line_start + 1 ) ; if ( ml_append ( lnum , line_start , len , newfile ) == FAIL ) error = TRUE ; else { # ifdef FEAT_PERSISTENT_UNDO if ( read_undo_file ) sha256_update ( & sha_ctx , line_start , len ) ; # endif read_no_eol_lnum = ++ lnum ; } } if ( set_options ) save_file_ff ( curbuf ) ; # ifdef FEAT_CRYPT if ( curbuf -> b_cryptstate != NULL ) { crypt_free_state ( curbuf -> b_cryptstate ) ; curbuf -> b_cryptstate = NULL ; } if ( cryptkey != NULL && cryptkey != curbuf -> b_p_key ) crypt_free_key ( cryptkey ) ; # endif # ifdef FEAT_MBYTE if ( set_options ) set_string_option_direct ( ( char_u * ) \"fenc\" , - 1 , fenc , OPT_FREE | OPT_LOCAL , 0 ) ; if ( fenc_alloced ) vim_free ( fenc ) ; # ifdef USE_ICONV if ( iconv_fd != ( iconv_t ) - 1 ) { iconv_close ( iconv_fd ) ; iconv_fd = ( iconv_t ) - 1 ; } # endif # endif if ( ! read_buffer && ! read_stdin ) close ( fd ) ; # ifdef HAVE_FD_CLOEXEC else { int fdflags = fcntl ( fd , F_GETFD ) ; if ( fdflags >= 0 && ( fdflags & FD_CLOEXEC ) == 0 ) ( void ) fcntl ( fd , F_SETFD , fdflags | FD_CLOEXEC ) ; } # endif vim_free ( buffer ) ; # ifdef HAVE_DUP if ( read_stdin ) { close ( 0 ) ; ignored = dup ( 2 ) ; } # endif # ifdef FEAT_MBYTE if ( tmpname != NULL ) { mch_remove ( tmpname ) ; vim_free ( tmpname ) ; } # endif -- no_wait_return ; if ( ! recoverymode ) { if ( newfile && wasempty && ! ( curbuf -> b_ml . ml_flags & ML_EMPTY ) ) { # ifdef FEAT_NETBEANS_INTG netbeansFireChanges = 0 ; # endif ml_delete ( curbuf -> b_ml . ml_line_count , FALSE ) ; # ifdef FEAT_NETBEANS_INTG netbeansFireChanges = 1 ; # endif -- linecnt ; } linecnt = curbuf -> b_ml . ml_line_count - linecnt ; if ( filesize == 0 ) linecnt = 0 ; if ( newfile || read_buffer ) { redraw_curbuf_later ( NOT_VALID ) ; # ifdef FEAT_DIFF diff_invalidate ( curbuf ) ; # endif # ifdef FEAT_FOLDING foldUpdateAll ( curwin ) ; # endif } else if ( linecnt ) appended_lines_mark ( from , linecnt ) ; # ifndef ALWAYS_USE_GUI if ( read_stdin ) { settmode ( TMODE_RAW ) ; starttermcap ( ) ; screenclear ( ) ; } # endif if ( got_int ) { if ( ! ( flags & READ_DUMMY ) ) { filemess ( curbuf , sfname , ( char_u * ) _ ( e_interr ) , 0 ) ; if ( newfile ) curbuf -> b_p_ro = TRUE ; } msg_scroll = msg_save ; # ifdef FEAT_VIMINFO check_marks_read ( ) ; # endif return OK ; } if ( ! filtering && ! ( flags & READ_DUMMY ) ) { msg_add_fname ( curbuf , sfname ) ; c = FALSE ; # ifdef UNIX # ifdef S_ISFIFO if ( S_ISFIFO ( perm ) ) { STRCAT ( IObuff , _ ( \"[fifo/socket]\" ) ) ; c = TRUE ; } # else # ifdef S_IFIFO if ( ( perm & S_IFMT ) == S_IFIFO ) { STRCAT ( IObuff , _ ( \"[fifo]\" ) ) ; c = TRUE ; } # endif # ifdef S_IFSOCK if ( ( perm & S_IFMT ) == S_IFSOCK ) { STRCAT ( IObuff , _ ( \"[socket]\" ) ) ; c = TRUE ; } # endif # endif # ifdef OPEN_CHR_FILES if ( S_ISCHR ( perm ) ) { STRCAT ( IObuff , _ ( \"[character<S2SV_blank>special]\" ) ) ; c = TRUE ; } # endif # endif if ( curbuf -> b_p_ro ) { STRCAT ( IObuff , shortmess ( SHM_RO ) ? _ ( \"[RO]\" ) : _ ( \"[readonly]\" ) ) ; c = TRUE ; } if ( read_no_eol_lnum ) { msg_add_eol ( ) ; c = TRUE ; } if ( ff_error == EOL_DOS ) { STRCAT ( IObuff , _ ( \"[CR<S2SV_blank>missing]\" ) ) ; c = TRUE ; } if ( split ) { STRCAT ( IObuff , _ ( \"[long<S2SV_blank>lines<S2SV_blank>split]\" ) ) ; c = TRUE ; } # ifdef FEAT_MBYTE if ( notconverted ) { STRCAT ( IObuff , _ ( \"[NOT<S2SV_blank>converted]\" ) ) ; c = TRUE ; } else if ( converted ) { STRCAT ( IObuff , _ ( \"[converted]\" ) ) ; c = TRUE ; } # endif # ifdef FEAT_CRYPT if ( cryptkey != NULL ) { crypt_append_msg ( curbuf ) ; c = TRUE ; } # endif # ifdef FEAT_MBYTE if ( conv_error != 0 ) { sprintf ( ( char * ) IObuff + STRLEN ( IObuff ) , _ ( \"[CONVERSION<S2SV_blank>ERROR<S2SV_blank>in<S2SV_blank>line<S2SV_blank>%ld]\" ) , ( long ) conv_error ) ; c = TRUE ; } else if ( illegal_byte > 0 ) { sprintf ( ( char * ) IObuff + STRLEN ( IObuff ) , _ ( \"[ILLEGAL<S2SV_blank>BYTE<S2SV_blank>in<S2SV_blank>line<S2SV_blank>%ld]\" ) , ( long ) illegal_byte ) ; c = TRUE ; } else # endif if ( error ) { STRCAT ( IObuff , _ ( \"[READ<S2SV_blank>ERRORS]\" ) ) ; c = TRUE ; } if ( msg_add_fileformat ( fileformat ) ) c = TRUE ; # ifdef FEAT_CRYPT if ( cryptkey != NULL ) msg_add_lines ( c , ( long ) linecnt , filesize - crypt_get_header_len ( crypt_get_method_nr ( curbuf ) ) ) ; else # endif msg_add_lines ( c , ( long ) linecnt , filesize ) ; vim_free ( keep_msg ) ; keep_msg = NULL ; msg_scrolled_ign = TRUE ; # ifdef ALWAYS_USE_GUI if ( read_stdin || read_buffer ) p = msg_may_trunc ( FALSE , IObuff ) ; else # endif p = msg_trunc_attr ( IObuff , FALSE , 0 ) ; if ( read_stdin || read_buffer || restart_edit != 0 || ( msg_scrolled != 0 && ! need_wait_return ) ) set_keep_msg ( p , 0 ) ; msg_scrolled_ign = FALSE ; } if ( newfile && ( error # ifdef FEAT_MBYTE || conv_error != 0 || ( illegal_byte > 0 && bad_char_behavior != BAD_KEEP ) # endif ) ) curbuf -> b_p_ro = TRUE ; u_clearline ( ) ; if ( exmode_active ) curwin -> w_cursor . lnum = from + linecnt ; else curwin -> w_cursor . lnum = from + 1 ; check_cursor_lnum ( ) ; beginline ( BL_WHITE | BL_FIX ) ; curbuf -> b_op_start . lnum = from + 1 ; curbuf -> b_op_start . col = 0 ; curbuf -> b_op_end . lnum = from + linecnt ; curbuf -> b_op_end . col = 0 ; # ifdef WIN32 if ( newfile && ! read_stdin && ! read_buffer && mch_stat ( ( char * ) fname , & st ) >= 0 ) { buf_store_time ( curbuf , & st , fname ) ; curbuf -> b_mtime_read = curbuf -> b_mtime ; } # endif } msg_scroll = msg_save ; # ifdef FEAT_VIMINFO check_marks_read ( ) ; # endif curbuf -> b_no_eol_lnum = read_no_eol_lnum ; if ( flags & READ_KEEP_UNDO ) u_find_first_changed ( ) ; # ifdef FEAT_PERSISTENT_UNDO if ( read_undo_file ) { char_u hash [ UNDO_HASH_SIZE ] ; sha256_finish ( & sha_ctx , hash ) ; u_read_undo ( NULL , hash , fname ) ; } # endif # ifdef FEAT_AUTOCMD if ( ! read_stdin && ! read_fifo && ( ! read_buffer || sfname != NULL ) ) { int m = msg_scroll ; int n = msg_scrolled ; if ( set_options ) save_file_ff ( curbuf ) ; msg_scroll = TRUE ; if ( filtering ) apply_autocmds_exarg ( EVENT_FILTERREADPOST , NULL , sfname , FALSE , curbuf , eap ) ; else if ( newfile || ( read_buffer && sfname != NULL ) ) { apply_autocmds_exarg ( EVENT_BUFREADPOST , NULL , sfname , FALSE , curbuf , eap ) ; if ( ! au_did_filetype && * curbuf -> b_p_ft != NUL ) apply_autocmds ( EVENT_FILETYPE , curbuf -> b_p_ft , curbuf -> b_fname , TRUE , curbuf ) ; } else apply_autocmds_exarg ( EVENT_FILEREADPOST , sfname , sfname , FALSE , NULL , eap ) ; if ( msg_scrolled == n ) msg_scroll = m ; # ifdef FEAT_EVAL if ( aborting ( ) ) return FAIL ; # endif } # endif if ( recoverymode && error ) return FAIL ; return OK ; }\n","target":"<S2SV_ModStart> != NULL ) { char_u * swap_fname = <S2SV_ModEnd> curbuf -> b_ml <S2SV_ModStart> ml_mfp -> mf_fname ; if ( ( swap_mode & 044 ) == 040 ) { stat_T swap_st ; if ( mch_stat ( ( char * ) swap_fname , & swap_st ) >= 0 && st . st_gid != swap_st . st_gid && fchown ( curbuf -> b_ml . ml_mfp -> mf_fd , - 1 , st . st_gid ) == - 1 ) swap_mode &= 0600 ; } ( void ) mch_setperm ( swap_fname <S2SV_ModStart> swap_mode ) ; }\n","project_and_commit_id":"vim@vim/5a73e0ca54c77e067c3b12ea6f35e3e8681e8cf8","cve_id":"CVE-2017-17087","original_address":"https://github.com/vim/vim/commit/5a73e0ca54c77e067c3b12ea6f35e3e8681e8cf8","time":"2017-12-01T08:29Z"},
	{"Unnamed: 0":5118,"cwe_id":"CWE-200","source":"CWE-200 static void tcp_send_challenge_ack ( struct sock * sk , const struct sk_buff * skb ) { static u32 challenge_timestamp ; static unsigned int challenge_count ; struct tcp_sock * tp = tcp_sk ( sk ) ; <S2SV_StartBug> u32 now ; <S2SV_EndBug> if ( tcp_oow_rate_limited ( sock_net ( sk ) , skb , LINUX_MIB_TCPACKSKIPPEDCHALLENGE , & tp -> last_oow_ack_time ) ) return ; now = jiffies / HZ ; if ( now != challenge_timestamp ) { <S2SV_StartBug> challenge_timestamp = now ; <S2SV_EndBug> <S2SV_StartBug> challenge_count = 0 ; <S2SV_EndBug> } if ( ++ challenge_count <= sysctl_tcp_challenge_ack_limit ) { NET_INC_STATS ( sock_net ( sk ) , LINUX_MIB_TCPCHALLENGEACK ) ; tcp_send_ack ( sk ) ; } }\n","target":"<S2SV_ModStart> ) ; u32 count , <S2SV_ModStart> challenge_timestamp ) { u32 half = ( sysctl_tcp_challenge_ack_limit + 1 ) >> 1 ; <S2SV_ModStart> = now ; WRITE_ONCE ( challenge_count , half + prandom_u32_max ( sysctl_tcp_challenge_ack_limit ) ) ; } count = READ_ONCE ( challenge_count ) ; if ( count > 0 ) { WRITE_ONCE ( challenge_count , count - 1 ) ; <S2SV_ModEnd> NET_INC_STATS ( sock_net\n","project_and_commit_id":"torvalds@linux/75ff39ccc1bd5d3c455b6822ab09e533c551f758","cve_id":"CVE-2016-5696","original_address":"https://github.com/torvalds/linux/commit/75ff39ccc1bd5d3c455b6822ab09e533c551f758","time":"2016-08-06T20:59Z"},
	{"Unnamed: 0":5958,"cwe_id":"CWE-476","source":"CWE-476 static int stv06xx_start ( struct gspca_dev * gspca_dev ) { struct sd * sd = ( struct sd * ) gspca_dev ; struct usb_host_interface * alt ; struct usb_interface * intf ; int err , packet_size ; intf = usb_ifnum_to_if ( sd -> gspca_dev . dev , sd -> gspca_dev . iface ) ; alt = usb_altnum_to_altsetting ( intf , sd -> gspca_dev . alt ) ; if ( ! alt ) { gspca_err ( gspca_dev , \"Couldn\\'t<S2SV_blank>get<S2SV_blank>altsetting\\\\n\" ) ; return - EIO ; } <S2SV_StartBug> packet_size = le16_to_cpu ( alt -> endpoint [ 0 ] . desc . wMaxPacketSize ) ; <S2SV_EndBug> err = stv06xx_write_bridge ( sd , STV_ISO_SIZE_L , packet_size ) ; if ( err < 0 ) return err ; err = sd -> sensor -> start ( sd ) ; if ( err < 0 ) goto out ; err = stv06xx_write_bridge ( sd , STV_ISO_ENABLE , 1 ) ; out : if ( err < 0 ) gspca_dbg ( gspca_dev , D_STREAM , \"Starting<S2SV_blank>stream<S2SV_blank>failed\\\\n\" ) ; else gspca_dbg ( gspca_dev , D_STREAM , \"Started<S2SV_blank>streaming\\\\n\" ) ; return ( err < 0 ) ? err : 0 ; }\n","target":"<S2SV_ModStart> EIO ; } if ( alt -> desc . bNumEndpoints < 1 ) return - ENODEV ;\n","project_and_commit_id":"torvalds@linux/485b06aadb933190f4bc44e006076bc27a23f205","cve_id":"CVE-2020-11609","original_address":"https://github.com/torvalds/linux/commit/485b06aadb933190f4bc44e006076bc27a23f205","time":"2020-04-07T17:15Z"},
	{"Unnamed: 0":6725,"cwe_id":"CWE-119","source":"CWE-119 <S2SV_StartBug> static int set_registers ( rtl8150_t * dev , u16 indx , u16 size , void * data ) <S2SV_EndBug> { <S2SV_StartBug> return usb_control_msg ( dev -> udev , usb_sndctrlpipe ( dev -> udev , 0 ) , <S2SV_EndBug> RTL8150_REQ_SET_REGS , RTL8150_REQT_WRITE , <S2SV_StartBug> indx , 0 , data , size , 500 ) ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug>\n","target":"<S2SV_ModStart> u16 size , const <S2SV_ModStart> data ) { void * buf ; int ret ; buf = kmemdup ( data , size , GFP_NOIO ) ; if ( ! buf ) return - ENOMEM ; ret = <S2SV_ModEnd> usb_control_msg ( dev <S2SV_ModStart> , 0 , buf <S2SV_ModEnd> , size , <S2SV_ModStart> 500 ) ; kfree ( buf ) ; return ret ;\n","project_and_commit_id":"torvalds@linux/7926aff5c57b577ab0f43364ff0c59d968f6a414","cve_id":"CVE-2017-8069","original_address":"https://github.com/torvalds/linux/commit/7926aff5c57b577ab0f43364ff0c59d968f6a414","time":"2017-04-23T05:59Z"},
	{"Unnamed: 0":6067,"cwe_id":"CWE-617","source":"CWE-617 int pci_emul_alloc_pbar ( struct pci_vdev * pdi , int idx , uint64_t hostbase , enum pcibar_type type , uint64_t size ) { int error ; uint64_t * baseptr , limit , addr , mask , lobits , bar ; <S2SV_StartBug> assert ( idx >= 0 && idx <= PCI_BARMAX ) ; <S2SV_EndBug> if ( ( size & ( size - 1 ) ) != 0 ) size = 1UL << flsl ( size ) ; if ( type == PCIBAR_IO ) { if ( size < 4 ) size = 4 ; } else { if ( size < 16 ) size = 16 ; } switch ( type ) { case PCIBAR_NONE : baseptr = NULL ; addr = mask = lobits = 0 ; break ; case PCIBAR_IO : baseptr = & pci_emul_iobase ; limit = PCI_EMUL_IOLIMIT ; mask = PCIM_BAR_IO_BASE ; lobits = PCIM_BAR_IO_SPACE ; break ; <S2SV_StartBug> case PCIBAR_MEM64 : <S2SV_EndBug> if ( ! skip_pci_mem64bar_workaround && ( size <= 32 * 1024 * 1024 ) ) { baseptr = & pci_emul_membase32 ; limit = PCI_EMUL_MEMLIMIT32 ; mask = PCIM_BAR_MEM_BASE ; lobits = PCIM_BAR_MEM_SPACE | PCIM_BAR_MEM_64 ; break ; } if ( size == 0x100000000UL ) baseptr = & hostbase ; else baseptr = & pci_emul_membase64 ; limit = PCI_EMUL_MEMLIMIT64 ; mask = PCIM_BAR_MEM_BASE ; lobits = PCIM_BAR_MEM_SPACE | PCIM_BAR_MEM_64 | PCIM_BAR_MEM_PREFETCH ; break ; case PCIBAR_MEM32 : baseptr = & pci_emul_membase32 ; limit = PCI_EMUL_MEMLIMIT32 ; mask = PCIM_BAR_MEM_BASE ; lobits = PCIM_BAR_MEM_SPACE | PCIM_BAR_MEM_32 ; break ; default : <S2SV_StartBug> printf ( \"%s:<S2SV_blank>invalid<S2SV_blank>bar<S2SV_blank>type<S2SV_blank>%d\\\\n\" , __func__ , type ) ; <S2SV_EndBug> <S2SV_StartBug> assert ( 0 ) ; <S2SV_EndBug> } if ( baseptr != NULL ) { error = pci_emul_alloc_resource ( baseptr , limit , size , & addr ) ; if ( error != 0 ) return error ; } pdi -> bar [ idx ] . type = type ; pdi -> bar [ idx ] . addr = addr ; pdi -> bar [ idx ] . size = size ; bar = ( addr & mask ) | lobits ; pci_set_cfgdata32 ( pdi , PCIR_BAR ( idx ) , bar ) ; if ( type == PCIBAR_MEM64 ) { <S2SV_StartBug> assert ( idx + 1 <= PCI_BARMAX ) ; <S2SV_EndBug> pdi -> bar [ idx + 1 ] . type = PCIBAR_MEMHI64 ; pci_set_cfgdata32 ( pdi , PCIR_BAR ( idx + 1 ) , bar >> 32 ) ; } register_bar ( pdi , idx ) ; return 0 ; }\n","target":"<S2SV_ModStart> , bar ; <S2SV_ModEnd> if ( ( <S2SV_ModStart> case PCIBAR_MEM64 : if ( idx + 1 > PCI_BARMAX ) { pr_err ( \"%s:<S2SV_blank>invalid<S2SV_blank>bar<S2SV_blank>number<S2SV_blank>%d<S2SV_blank>for<S2SV_blank>MEM64<S2SV_blank>type\\\\n\" , __func__ , idx ) ; return - 1 ; } <S2SV_ModStart> ; default : pr_err <S2SV_ModEnd> ( \"%s:<S2SV_blank>invalid<S2SV_blank>bar<S2SV_blank>type<S2SV_blank>%d\\\\n\" , <S2SV_ModStart> type ) ; return - 1 <S2SV_ModEnd> ; } if <S2SV_ModStart> PCIBAR_MEM64 ) { <S2SV_ModEnd> pdi -> bar\n","project_and_commit_id":"projectacrn@acrn-hypervisor/2b3dedfb9ba13f15887f22b935d373f36c9a59fa","cve_id":"CVE-2019-18844","original_address":"https://github.com/projectacrn/acrn-hypervisor/commit/2b3dedfb9ba13f15887f22b935d373f36c9a59fa","time":"2019-11-13T20:15Z"},
	{"Unnamed: 0":279,"cwe_id":"CWE-119","source":"CWE-119 static int adjust_scalar_min_max_vals ( struct bpf_verifier_env * env , struct bpf_insn * insn , struct bpf_reg_state * dst_reg , struct bpf_reg_state src_reg ) { struct bpf_reg_state * regs = cur_regs ( env ) ; u8 opcode = BPF_OP ( insn -> code ) ; bool src_known , dst_known ; s64 smin_val , smax_val ; u64 umin_val , umax_val ; if ( BPF_CLASS ( insn -> code ) != BPF_ALU64 ) { <S2SV_StartBug> coerce_reg_to_32 ( dst_reg ) ; <S2SV_EndBug> <S2SV_StartBug> coerce_reg_to_32 ( & src_reg ) ; <S2SV_EndBug> } smin_val = src_reg . smin_value ; smax_val = src_reg . smax_value ; umin_val = src_reg . umin_value ; umax_val = src_reg . umax_value ; src_known = tnum_is_const ( src_reg . var_off ) ; dst_known = tnum_is_const ( dst_reg -> var_off ) ; switch ( opcode ) { case BPF_ADD : if ( signed_add_overflows ( dst_reg -> smin_value , smin_val ) || signed_add_overflows ( dst_reg -> smax_value , smax_val ) ) { dst_reg -> smin_value = S64_MIN ; dst_reg -> smax_value = S64_MAX ; } else { dst_reg -> smin_value += smin_val ; dst_reg -> smax_value += smax_val ; } if ( dst_reg -> umin_value + umin_val < umin_val || dst_reg -> umax_value + umax_val < umax_val ) { dst_reg -> umin_value = 0 ; dst_reg -> umax_value = U64_MAX ; } else { dst_reg -> umin_value += umin_val ; dst_reg -> umax_value += umax_val ; } dst_reg -> var_off = tnum_add ( dst_reg -> var_off , src_reg . var_off ) ; break ; case BPF_SUB : if ( signed_sub_overflows ( dst_reg -> smin_value , smax_val ) || signed_sub_overflows ( dst_reg -> smax_value , smin_val ) ) { dst_reg -> smin_value = S64_MIN ; dst_reg -> smax_value = S64_MAX ; } else { dst_reg -> smin_value -= smax_val ; dst_reg -> smax_value -= smin_val ; } if ( dst_reg -> umin_value < umax_val ) { dst_reg -> umin_value = 0 ; dst_reg -> umax_value = U64_MAX ; } else { dst_reg -> umin_value -= umax_val ; dst_reg -> umax_value -= umin_val ; } dst_reg -> var_off = tnum_sub ( dst_reg -> var_off , src_reg . var_off ) ; break ; case BPF_MUL : dst_reg -> var_off = tnum_mul ( dst_reg -> var_off , src_reg . var_off ) ; if ( smin_val < 0 || dst_reg -> smin_value < 0 ) { __mark_reg_unbounded ( dst_reg ) ; __update_reg_bounds ( dst_reg ) ; break ; } if ( umax_val > U32_MAX || dst_reg -> umax_value > U32_MAX ) { __mark_reg_unbounded ( dst_reg ) ; __update_reg_bounds ( dst_reg ) ; break ; } dst_reg -> umin_value *= umin_val ; dst_reg -> umax_value *= umax_val ; if ( dst_reg -> umax_value > S64_MAX ) { dst_reg -> smin_value = S64_MIN ; dst_reg -> smax_value = S64_MAX ; } else { dst_reg -> smin_value = dst_reg -> umin_value ; dst_reg -> smax_value = dst_reg -> umax_value ; } break ; case BPF_AND : if ( src_known && dst_known ) { __mark_reg_known ( dst_reg , dst_reg -> var_off . value & src_reg . var_off . value ) ; break ; } dst_reg -> var_off = tnum_and ( dst_reg -> var_off , src_reg . var_off ) ; dst_reg -> umin_value = dst_reg -> var_off . value ; dst_reg -> umax_value = min ( dst_reg -> umax_value , umax_val ) ; if ( dst_reg -> smin_value < 0 || smin_val < 0 ) { dst_reg -> smin_value = S64_MIN ; dst_reg -> smax_value = S64_MAX ; } else { dst_reg -> smin_value = dst_reg -> umin_value ; dst_reg -> smax_value = dst_reg -> umax_value ; } __update_reg_bounds ( dst_reg ) ; break ; case BPF_OR : if ( src_known && dst_known ) { __mark_reg_known ( dst_reg , dst_reg -> var_off . value | src_reg . var_off . value ) ; break ; } dst_reg -> var_off = tnum_or ( dst_reg -> var_off , src_reg . var_off ) ; dst_reg -> umin_value = max ( dst_reg -> umin_value , umin_val ) ; dst_reg -> umax_value = dst_reg -> var_off . value | dst_reg -> var_off . mask ; if ( dst_reg -> smin_value < 0 || smin_val < 0 ) { dst_reg -> smin_value = S64_MIN ; dst_reg -> smax_value = S64_MAX ; } else { dst_reg -> smin_value = dst_reg -> umin_value ; dst_reg -> smax_value = dst_reg -> umax_value ; } __update_reg_bounds ( dst_reg ) ; break ; case BPF_LSH : if ( umax_val > 63 ) { mark_reg_unknown ( env , regs , insn -> dst_reg ) ; break ; } dst_reg -> smin_value = S64_MIN ; dst_reg -> smax_value = S64_MAX ; if ( dst_reg -> umax_value > 1ULL << ( 63 - umax_val ) ) { dst_reg -> umin_value = 0 ; dst_reg -> umax_value = U64_MAX ; } else { dst_reg -> umin_value <<= umin_val ; dst_reg -> umax_value <<= umax_val ; } if ( src_known ) dst_reg -> var_off = tnum_lshift ( dst_reg -> var_off , umin_val ) ; else dst_reg -> var_off = tnum_lshift ( tnum_unknown , umin_val ) ; __update_reg_bounds ( dst_reg ) ; break ; case BPF_RSH : if ( umax_val > 63 ) { mark_reg_unknown ( env , regs , insn -> dst_reg ) ; break ; } dst_reg -> smin_value = S64_MIN ; dst_reg -> smax_value = S64_MAX ; if ( src_known ) dst_reg -> var_off = tnum_rshift ( dst_reg -> var_off , umin_val ) ; else dst_reg -> var_off = tnum_rshift ( tnum_unknown , umin_val ) ; dst_reg -> umin_value >>= umax_val ; dst_reg -> umax_value >>= umin_val ; __update_reg_bounds ( dst_reg ) ; break ; default : mark_reg_unknown ( env , regs , insn -> dst_reg ) ; break ; } __reg_deduce_bounds ( dst_reg ) ; __reg_bound_offset ( dst_reg ) ; return 0 ; }\n","target":"<S2SV_ModStart> BPF_ALU64 ) { coerce_reg_to_size ( dst_reg , 4 ) ; coerce_reg_to_size <S2SV_ModEnd> ( & src_reg <S2SV_ModStart> ( & src_reg , 4\n","project_and_commit_id":"torvalds@linux/0c17d1d2c61936401f4702e1846e2c19b200f958","cve_id":"CVE-2017-16996","original_address":"https://github.com/torvalds/linux/commit/0c17d1d2c61936401f4702e1846e2c19b200f958","time":"2017-12-27T17:08Z"},
	{"Unnamed: 0":4409,"cwe_id":"CWE-119","source":"CWE-119 void vp9_update_layer_context_change_config ( VP9_COMP * const cpi , const int target_bandwidth ) { SVC * const svc = & cpi -> svc ; <S2SV_StartBug> const VP9_CONFIG * const oxcf = & cpi -> oxcf ; <S2SV_EndBug> const RATE_CONTROL * const rc = & cpi -> rc ; <S2SV_StartBug> int layer ; <S2SV_EndBug> int layer_end ; float bitrate_alloc = 1.0 ; <S2SV_StartBug> if ( svc -> number_temporal_layers > 1 ) { <S2SV_EndBug> layer_end = svc -> number_temporal_layers ; } else { layer_end = svc -> number_spatial_layers ; } for ( layer = 0 ; layer < layer_end ; ++ layer ) { LAYER_CONTEXT * const lc = & svc -> layer_context [ layer ] ; <S2SV_StartBug> RATE_CONTROL * const lrc = & lc -> rc ; <S2SV_EndBug> <S2SV_StartBug> if ( svc -> number_temporal_layers > 1 ) { <S2SV_EndBug> lc -> target_bandwidth = oxcf -> ts_target_bitrate [ layer ] * 1000 ; } else { lc -> target_bandwidth = oxcf -> ss_target_bitrate [ layer ] * 1000 ; } bitrate_alloc = ( float ) lc -> target_bandwidth / target_bandwidth ; lc -> starting_buffer_level = ( int64_t ) ( oxcf -> starting_buffer_level * bitrate_alloc ) ; lc -> optimal_buffer_level = ( int64_t ) ( oxcf -> optimal_buffer_level * bitrate_alloc ) ; lc -> maximum_buffer_size = ( int64_t ) ( oxcf -> maximum_buffer_size * bitrate_alloc ) ; lrc -> bits_off_target = MIN ( lrc -> bits_off_target , lc -> maximum_buffer_size ) ; lrc -> buffer_level = MIN ( lrc -> buffer_level , lc -> maximum_buffer_size ) ; if ( svc -> number_temporal_layers > 1 ) { <S2SV_StartBug> lc -> framerate = oxcf -> framerate / oxcf -> ts_rate_decimator [ layer ] ; <S2SV_EndBug> } else { <S2SV_StartBug> lc -> framerate = oxcf -> framerate ; <S2SV_EndBug> } <S2SV_StartBug> lrc -> av_per_frame_bandwidth = ( int ) ( lc -> target_bandwidth / lc -> framerate ) ; <S2SV_EndBug> lrc -> max_frame_bandwidth = rc -> max_frame_bandwidth ; lrc -> worst_quality = rc -> worst_quality ; lrc -> best_quality = rc -> best_quality ; } <S2SV_StartBug> } <S2SV_EndBug>\n","target":"<S2SV_ModStart> svc ; const VP9EncoderConfig <S2SV_ModEnd> * const oxcf <S2SV_ModStart> rc ; int sl , tl , layer = 0 , spatial_layer_target ; float bitrate_alloc = 1.0 ; if ( svc -> temporal_layering_mode != VP9E_TEMPORAL_LAYERING_MODE_NOLAYERING ) { for ( sl = 0 ; sl < oxcf -> ss_number_layers ; ++ sl ) { spatial_layer_target = 0 ; for ( tl = 0 ; tl < oxcf -> ts_number_layers ; ++ tl ) { layer = LAYER_IDS_TO_IDX ( sl , tl , oxcf -> ts_number_layers ) ; svc -> layer_context [ layer ] . target_bandwidth = oxcf -> layer_target_bitrate [ layer ] ; } layer = LAYER_IDS_TO_IDX ( sl , ( ( oxcf -> ts_number_layers - 1 ) < 0 ? 0 : ( oxcf -> ts_number_layers - 1 ) ) , oxcf -> ts_number_layers ) ; spatial_layer_target = svc -> layer_context [ layer ] . target_bandwidth = oxcf -> layer_target_bitrate [ layer ] ; for ( tl = 0 ; tl < oxcf -> ts_number_layers ; ++ tl ) { LAYER_CONTEXT * const lc = & svc -> layer_context [ sl * oxcf -> ts_number_layers + tl ] ; RATE_CONTROL * const lrc = & lc -> rc ; lc -> spatial_layer_target_bandwidth = spatial_layer_target ; bitrate_alloc = ( float ) lc -> target_bandwidth / spatial_layer_target ; lrc -> starting_buffer_level = ( int64_t ) ( rc -> starting_buffer_level * bitrate_alloc ) ; lrc -> optimal_buffer_level = ( int64_t ) ( rc -> optimal_buffer_level * bitrate_alloc ) ; lrc -> maximum_buffer_size = ( int64_t ) ( rc -> maximum_buffer_size * bitrate_alloc ) ; lrc -> bits_off_target = MIN ( lrc -> bits_off_target , lrc -> maximum_buffer_size ) ; lrc -> buffer_level = MIN ( lrc -> buffer_level , lrc -> maximum_buffer_size ) ; lc -> framerate = cpi -> framerate / oxcf -> ts_rate_decimator [ tl ] ; lrc -> avg_frame_bandwidth = ( int ) ( lc -> target_bandwidth / lc -> framerate ) ; lrc -> max_frame_bandwidth = rc -> max_frame_bandwidth ; lrc -> worst_quality = rc -> worst_quality ; lrc -> best_quality = rc -> best_quality ; } } } else { int layer_end <S2SV_ModEnd> ; if ( <S2SV_ModStart> number_temporal_layers > 1 && cpi -> oxcf . rc_mode == VPX_CBR <S2SV_ModStart> lc -> rc ; lc -> target_bandwidth = oxcf -> layer_target_bitrate [ layer ] ; bitrate_alloc = ( float ) lc -> target_bandwidth / target_bandwidth ; lrc -> starting_buffer_level = ( int64_t ) ( rc -> starting_buffer_level * bitrate_alloc ) ; lrc -> optimal_buffer_level = ( int64_t ) ( rc -> optimal_buffer_level * bitrate_alloc ) ; lrc -> maximum_buffer_size = ( int64_t ) ( rc -> maximum_buffer_size * bitrate_alloc ) ; lrc -> bits_off_target = MIN ( lrc -> bits_off_target , lrc -> maximum_buffer_size ) ; lrc -> buffer_level = MIN ( lrc -> buffer_level , lrc -> maximum_buffer_size ) <S2SV_ModStart> number_temporal_layers > 1 && cpi -> oxcf . rc_mode == VPX_CBR <S2SV_ModEnd> ) { lc <S2SV_ModStart> -> framerate = cpi <S2SV_ModEnd> -> framerate / <S2SV_ModStart> -> framerate = cpi <S2SV_ModEnd> -> framerate ; <S2SV_ModStart> } lrc -> avg_frame_bandwidth <S2SV_ModEnd> = ( int <S2SV_ModStart> ; } } }\n","project_and_commit_id":"external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426","cve_id":"CVE-2016-1621","original_address":"https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426","time":"2016-03-12T21:59Z"},
	{"Unnamed: 0":5211,"cwe_id":"CWE-399","source":"CWE-399 int tcp_rcv_state_process ( struct sock * sk , struct sk_buff * skb , const struct tcphdr * th , unsigned int len ) { struct tcp_sock * tp = tcp_sk ( sk ) ; struct inet_connection_sock * icsk = inet_csk ( sk ) ; int queued = 0 ; int res ; tp -> rx_opt . saw_tstamp = 0 ; switch ( sk -> sk_state ) { case TCP_CLOSE : goto discard ; case TCP_LISTEN : if ( th -> ack ) return 1 ; if ( th -> rst ) goto discard ; if ( th -> syn ) { <S2SV_StartBug> if ( icsk -> icsk_af_ops -> conn_request ( sk , skb ) < 0 ) <S2SV_EndBug> return 1 ; kfree_skb ( skb ) ; return 0 ; } goto discard ; case TCP_SYN_SENT : queued = tcp_rcv_synsent_state_process ( sk , skb , th , len ) ; if ( queued >= 0 ) return queued ; tcp_urg ( sk , skb , th ) ; __kfree_skb ( skb ) ; tcp_data_snd_check ( sk ) ; return 0 ; } res = tcp_validate_incoming ( sk , skb , th , 0 ) ; if ( res <= 0 ) return - res ; if ( th -> ack ) { int acceptable = tcp_ack ( sk , skb , FLAG_SLOWPATH ) > 0 ; switch ( sk -> sk_state ) { case TCP_SYN_RECV : if ( acceptable ) { tp -> copied_seq = tp -> rcv_nxt ; smp_mb ( ) ; tcp_set_state ( sk , TCP_ESTABLISHED ) ; sk -> sk_state_change ( sk ) ; if ( sk -> sk_socket ) sk_wake_async ( sk , SOCK_WAKE_IO , POLL_OUT ) ; tp -> snd_una = TCP_SKB_CB ( skb ) -> ack_seq ; tp -> snd_wnd = ntohs ( th -> window ) << tp -> rx_opt . snd_wscale ; tcp_init_wl ( tp , TCP_SKB_CB ( skb ) -> seq ) ; if ( tp -> rx_opt . tstamp_ok ) tp -> advmss -= TCPOLEN_TSTAMP_ALIGNED ; icsk -> icsk_af_ops -> rebuild_header ( sk ) ; tcp_init_metrics ( sk ) ; tcp_init_congestion_control ( sk ) ; tp -> lsndtime = tcp_time_stamp ; tcp_mtup_init ( sk ) ; tcp_initialize_rcv_mss ( sk ) ; tcp_init_buffer_space ( sk ) ; tcp_fast_path_on ( tp ) ; } else { return 1 ; } break ; case TCP_FIN_WAIT1 : if ( tp -> snd_una == tp -> write_seq ) { tcp_set_state ( sk , TCP_FIN_WAIT2 ) ; sk -> sk_shutdown |= SEND_SHUTDOWN ; dst_confirm ( __sk_dst_get ( sk ) ) ; if ( ! sock_flag ( sk , SOCK_DEAD ) ) sk -> sk_state_change ( sk ) ; else { int tmo ; if ( tp -> linger2 < 0 || ( TCP_SKB_CB ( skb ) -> end_seq != TCP_SKB_CB ( skb ) -> seq && after ( TCP_SKB_CB ( skb ) -> end_seq - th -> fin , tp -> rcv_nxt ) ) ) { tcp_done ( sk ) ; NET_INC_STATS_BH ( sock_net ( sk ) , LINUX_MIB_TCPABORTONDATA ) ; return 1 ; } tmo = tcp_fin_time ( sk ) ; if ( tmo > TCP_TIMEWAIT_LEN ) { inet_csk_reset_keepalive_timer ( sk , tmo - TCP_TIMEWAIT_LEN ) ; } else if ( th -> fin || sock_owned_by_user ( sk ) ) { inet_csk_reset_keepalive_timer ( sk , tmo ) ; } else { tcp_time_wait ( sk , TCP_FIN_WAIT2 , tmo ) ; goto discard ; } } } break ; case TCP_CLOSING : if ( tp -> snd_una == tp -> write_seq ) { tcp_time_wait ( sk , TCP_TIME_WAIT , 0 ) ; goto discard ; } break ; case TCP_LAST_ACK : if ( tp -> snd_una == tp -> write_seq ) { tcp_update_metrics ( sk ) ; tcp_done ( sk ) ; goto discard ; } break ; } } else goto discard ; tcp_urg ( sk , skb , th ) ; switch ( sk -> sk_state ) { case TCP_CLOSE_WAIT : case TCP_CLOSING : case TCP_LAST_ACK : if ( ! before ( TCP_SKB_CB ( skb ) -> seq , tp -> rcv_nxt ) ) break ; case TCP_FIN_WAIT1 : case TCP_FIN_WAIT2 : if ( sk -> sk_shutdown & RCV_SHUTDOWN ) { if ( TCP_SKB_CB ( skb ) -> end_seq != TCP_SKB_CB ( skb ) -> seq && after ( TCP_SKB_CB ( skb ) -> end_seq - th -> fin , tp -> rcv_nxt ) ) { NET_INC_STATS_BH ( sock_net ( sk ) , LINUX_MIB_TCPABORTONDATA ) ; tcp_reset ( sk ) ; return 1 ; } } case TCP_ESTABLISHED : tcp_data_queue ( sk , skb ) ; queued = 1 ; break ; } if ( sk -> sk_state != TCP_CLOSE ) { tcp_data_snd_check ( sk ) ; tcp_ack_snd_check ( sk ) ; } if ( ! queued ) { discard : __kfree_skb ( skb ) ; } return 0 ; }\n","target":"<S2SV_ModStart> { if ( th -> fin ) goto discard ; if (\n","project_and_commit_id":"torvalds@linux/fdf5af0daf8019cec2396cdef8fb042d80fe71fa","cve_id":"CVE-2012-6638","original_address":"https://github.com/torvalds/linux/commit/fdf5af0daf8019cec2396cdef8fb042d80fe71fa","time":"2014-02-15T14:57Z"},
	{"Unnamed: 0":2305,"cwe_id":"CWE-000","source":"CWE-000 static void nfs4_open_release ( void * calldata ) { struct nfs4_opendata * data = calldata ; struct nfs4_state * state = NULL ; if ( data -> cancelled == 0 ) goto out_free ; if ( data -> rpc_status != 0 || ! data -> rpc_done ) goto out_free ; if ( data -> o_res . rflags & NFS4_OPEN_RESULT_CONFIRM ) goto out_free ; state = nfs4_opendata_to_nfs4_state ( data ) ; if ( ! IS_ERR ( state ) ) <S2SV_StartBug> nfs4_close_state ( & data -> path , state , data -> o_arg . open_flags ) ; <S2SV_EndBug> out_free : nfs4_opendata_put ( data ) ; }\n","target":"<S2SV_ModStart> -> o_arg . fmode <S2SV_ModEnd> ) ; out_free\n","project_and_commit_id":"torvalds@linux/dc0b027dfadfcb8a5504f7d8052754bf8d501ab9","cve_id":"CVE-2011-4324","original_address":"https://github.com/torvalds/linux/commit/dc0b027dfadfcb8a5504f7d8052754bf8d501ab9","time":"2012-06-21T23:55Z"},
	{"Unnamed: 0":4519,"cwe_id":"CWE-787","source":"CWE-787 static int next_state_val ( CClassNode * cc , OnigCodePoint * vs , OnigCodePoint v , int * vs_israw , int v_israw , enum CCVALTYPE intype , enum CCVALTYPE * type , enum CCSTATE * state , ScanEnv * env ) { int r ; switch ( * state ) { case CCS_VALUE : if ( * type == CCV_SB ) { <S2SV_StartBug> BITSET_SET_BIT ( cc -> bs , ( int ) ( * vs ) ) ; <S2SV_EndBug> } else if ( * type == CCV_CODE_POINT ) { r = add_code_range ( & ( cc -> mbuf ) , env , * vs , * vs ) ; if ( r < 0 ) return r ; } break ; case CCS_RANGE : if ( intype == * type ) { if ( intype == CCV_SB ) { if ( * vs > 0xff || v > 0xff ) return ONIGERR_INVALID_CODE_POINT_VALUE ; if ( * vs > v ) { if ( IS_SYNTAX_BV ( env -> syntax , ONIG_SYN_ALLOW_EMPTY_RANGE_IN_CC ) ) goto ccs_range_end ; else return ONIGERR_EMPTY_RANGE_IN_CHAR_CLASS ; } bitset_set_range ( cc -> bs , ( int ) * vs , ( int ) v ) ; } else { r = add_code_range ( & ( cc -> mbuf ) , env , * vs , v ) ; if ( r < 0 ) return r ; } } else { # if 0 if ( intype == CCV_CODE_POINT && * type == CCV_SB ) { # endif if ( * vs > v ) { if ( IS_SYNTAX_BV ( env -> syntax , ONIG_SYN_ALLOW_EMPTY_RANGE_IN_CC ) ) goto ccs_range_end ; else return ONIGERR_EMPTY_RANGE_IN_CHAR_CLASS ; } bitset_set_range ( cc -> bs , ( int ) * vs , ( int ) ( v < 0xff ? v : 0xff ) ) ; r = add_code_range ( & ( cc -> mbuf ) , env , ( OnigCodePoint ) * vs , v ) ; if ( r < 0 ) return r ; # if 0 } else return ONIGERR_MISMATCH_CODE_LENGTH_IN_CLASS_RANGE ; # endif } ccs_range_end : * state = CCS_COMPLETE ; break ; case CCS_COMPLETE : case CCS_START : * state = CCS_VALUE ; break ; default : break ; } * vs_israw = v_israw ; * vs = v ; * type = intype ; return 0 ; }\n","target":"<S2SV_ModStart> CCV_SB ) { if ( * vs > 0xff ) return ONIGERR_INVALID_CODE_POINT_VALUE ;\n","project_and_commit_id":"kkos@oniguruma/b4bf968ad52afe14e60a2dc8a95d3555c543353a","cve_id":"CVE-2017-9226","original_address":"https://github.com/kkos/oniguruma/commit/b4bf968ad52afe14e60a2dc8a95d3555c543353a","time":"2017-05-24T15:29Z"},
	{"Unnamed: 0":5619,"cwe_id":"CWE-125","source":"CWE-125 PyObject * ast2obj_slice ( void * _o ) { slice_ty o = ( slice_ty ) _o ; PyObject * result = NULL , * value = NULL ; if ( ! o ) { <S2SV_StartBug> Py_INCREF ( Py_None ) ; <S2SV_EndBug> return Py_None ; } switch ( o -> kind ) { case Slice_kind : result = PyType_GenericNew ( Slice_type , NULL , NULL ) ; if ( ! result ) goto failed ; value = ast2obj_expr ( o -> v . Slice . lower ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_lower , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; value = ast2obj_expr ( o -> v . Slice . upper ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_upper , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; value = ast2obj_expr ( o -> v . Slice . step ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_step , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; break ; case ExtSlice_kind : result = PyType_GenericNew ( ExtSlice_type , NULL , NULL ) ; if ( ! result ) goto failed ; value = ast2obj_list ( o -> v . ExtSlice . dims , ast2obj_slice ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_dims , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; break ; case Index_kind : result = PyType_GenericNew ( Index_type , NULL , NULL ) ; if ( ! result ) goto failed ; value = ast2obj_expr ( o -> v . Index . value ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_value , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; break ; } return result ; failed : Py_XDECREF ( value ) ; Py_XDECREF ( result ) ; return NULL ; }\n","target":"<S2SV_ModStart> o ) { Py_RETURN_NONE <S2SV_ModEnd> ; } switch\n","project_and_commit_id":"python@typed_ast/156afcb26c198e162504a57caddfe0acd9ed7dce","cve_id":"CVE-2019-19275","original_address":"https://github.com/python/typed_ast/commit/156afcb26c198e162504a57caddfe0acd9ed7dce","time":"2019-11-26T15:15Z"},
	{"Unnamed: 0":5041,"cwe_id":"CWE-399","source":"CWE-399 static int handle_exception ( struct kvm_vcpu * vcpu ) { struct vcpu_vmx * vmx = to_vmx ( vcpu ) ; struct kvm_run * kvm_run = vcpu -> run ; u32 intr_info , ex_no , error_code ; unsigned long cr2 , rip , dr6 ; u32 vect_info ; enum emulation_result er ; vect_info = vmx -> idt_vectoring_info ; intr_info = vmx -> exit_intr_info ; if ( is_machine_check ( intr_info ) ) return handle_machine_check ( vcpu ) ; if ( ( intr_info & INTR_INFO_INTR_TYPE_MASK ) == INTR_TYPE_NMI_INTR ) return 1 ; if ( is_no_device ( intr_info ) ) { vmx_fpu_activate ( vcpu ) ; return 1 ; } if ( is_invalid_opcode ( intr_info ) ) { if ( is_guest_mode ( vcpu ) ) { kvm_queue_exception ( vcpu , UD_VECTOR ) ; return 1 ; } er = emulate_instruction ( vcpu , EMULTYPE_TRAP_UD ) ; if ( er != EMULATE_DONE ) kvm_queue_exception ( vcpu , UD_VECTOR ) ; return 1 ; } error_code = 0 ; if ( intr_info & INTR_INFO_DELIVER_CODE_MASK ) error_code = vmcs_read32 ( VM_EXIT_INTR_ERROR_CODE ) ; if ( ( vect_info & VECTORING_INFO_VALID_MASK ) && ! ( is_page_fault ( intr_info ) && ! ( error_code & PFERR_RSVD_MASK ) ) ) { vcpu -> run -> exit_reason = KVM_EXIT_INTERNAL_ERROR ; vcpu -> run -> internal . suberror = KVM_INTERNAL_ERROR_SIMUL_EX ; vcpu -> run -> internal . ndata = 3 ; vcpu -> run -> internal . data [ 0 ] = vect_info ; vcpu -> run -> internal . data [ 1 ] = intr_info ; vcpu -> run -> internal . data [ 2 ] = error_code ; return 0 ; } if ( is_page_fault ( intr_info ) ) { BUG_ON ( enable_ept ) ; cr2 = vmcs_readl ( EXIT_QUALIFICATION ) ; trace_kvm_page_fault ( cr2 , error_code ) ; if ( kvm_event_needs_reinjection ( vcpu ) ) kvm_mmu_unprotect_page_virt ( vcpu , cr2 ) ; return kvm_mmu_page_fault ( vcpu , cr2 , error_code , NULL , 0 ) ; } ex_no = intr_info & INTR_INFO_VECTOR_MASK ; if ( vmx -> rmode . vm86_active && rmode_exception ( vcpu , ex_no ) ) return handle_rmode_exception ( vcpu , ex_no , error_code ) ; switch ( ex_no ) { <S2SV_StartBug> case DB_VECTOR : <S2SV_EndBug> dr6 = vmcs_readl ( EXIT_QUALIFICATION ) ; if ( ! ( vcpu -> guest_debug & ( KVM_GUESTDBG_SINGLESTEP | KVM_GUESTDBG_USE_HW_BP ) ) ) { vcpu -> arch . dr6 &= ~ 15 ; vcpu -> arch . dr6 |= dr6 | DR6_RTM ; if ( ! ( dr6 & ~ DR6_RESERVED ) ) skip_emulated_instruction ( vcpu ) ; kvm_queue_exception ( vcpu , DB_VECTOR ) ; return 1 ; } kvm_run -> debug . arch . dr6 = dr6 | DR6_FIXED_1 ; kvm_run -> debug . arch . dr7 = vmcs_readl ( GUEST_DR7 ) ; case BP_VECTOR : vmx -> vcpu . arch . event_exit_inst_len = vmcs_read32 ( VM_EXIT_INSTRUCTION_LEN ) ; kvm_run -> exit_reason = KVM_EXIT_DEBUG ; rip = kvm_rip_read ( vcpu ) ; kvm_run -> debug . arch . pc = vmcs_readl ( GUEST_CS_BASE ) + rip ; kvm_run -> debug . arch . exception = ex_no ; break ; default : kvm_run -> exit_reason = KVM_EXIT_EXCEPTION ; kvm_run -> ex . exception = ex_no ; kvm_run -> ex . error_code = error_code ; break ; } return 0 ; }\n","target":"<S2SV_ModStart> ) { case AC_VECTOR : kvm_queue_exception_e ( vcpu , AC_VECTOR , error_code ) ; return 1 ; case\n","project_and_commit_id":"torvalds@linux/54a20552e1eae07aa240fa370a0293e006b5faed","cve_id":"CVE-2015-5307","original_address":"https://github.com/torvalds/linux/commit/54a20552e1eae07aa240fa370a0293e006b5faed","time":"2015-11-16T11:59Z"},
	{"Unnamed: 0":3125,"cwe_id":"CWE-399","source":"CWE-399 struct sctp_chunk * sctp_inq_pop ( struct sctp_inq * queue ) { struct sctp_chunk * chunk ; sctp_chunkhdr_t * ch = NULL ; if ( ( chunk = queue -> in_progress ) ) { if ( chunk -> singleton || chunk -> end_of_packet || chunk -> pdiscard ) { sctp_chunk_free ( chunk ) ; chunk = queue -> in_progress = NULL ; } else { ch = ( sctp_chunkhdr_t * ) chunk -> chunk_end ; skb_pull ( chunk -> skb , chunk -> chunk_end - chunk -> skb -> data ) ; <S2SV_StartBug> if ( skb_headlen ( chunk -> skb ) < sizeof ( sctp_chunkhdr_t ) ) { <S2SV_EndBug> sctp_chunk_free ( chunk ) ; chunk = queue -> in_progress = NULL ; } } } if ( ! chunk ) { struct list_head * entry ; if ( list_empty ( & queue -> in_chunk_list ) ) return NULL ; entry = queue -> in_chunk_list . next ; chunk = queue -> in_progress = list_entry ( entry , struct sctp_chunk , list ) ; list_del_init ( entry ) ; chunk -> singleton = 1 ; ch = ( sctp_chunkhdr_t * ) chunk -> skb -> data ; chunk -> data_accepted = 0 ; } chunk -> chunk_hdr = ch ; chunk -> chunk_end = ( ( __u8 * ) ch ) + WORD_ROUND ( ntohs ( ch -> length ) ) ; if ( unlikely ( skb_is_nonlinear ( chunk -> skb ) ) ) { if ( chunk -> chunk_end > skb_tail_pointer ( chunk -> skb ) ) chunk -> chunk_end = skb_tail_pointer ( chunk -> skb ) ; } skb_pull ( chunk -> skb , sizeof ( sctp_chunkhdr_t ) ) ; chunk -> subh . v = NULL ; <S2SV_StartBug> if ( chunk -> chunk_end < skb_tail_pointer ( chunk -> skb ) ) { <S2SV_EndBug> chunk -> singleton = 0 ; } else if ( chunk -> chunk_end > skb_tail_pointer ( chunk -> skb ) ) { <S2SV_StartBug> sctp_chunk_free ( chunk ) ; <S2SV_EndBug> chunk = queue -> in_progress = NULL ; return NULL ; } else { chunk -> end_of_packet = 1 ; } pr_debug ( \"+++sctp_inq_pop+++<S2SV_blank>chunk:%p[%s],<S2SV_blank>length:%d,<S2SV_blank>skb->len:%d\\\\n\" , chunk , sctp_cname ( SCTP_ST_CHUNK ( chunk -> chunk_hdr -> type ) ) , ntohs ( chunk -> chunk_hdr -> length ) , chunk -> skb -> len ) ; return chunk ; }\n","target":"<S2SV_ModStart> data ) ; <S2SV_ModEnd> } } if <S2SV_ModStart> chunk -> chunk_end + sizeof ( sctp_chunkhdr_t ) <S2SV_ModStart> ) ) { chunk -> pdiscard = 1 ; chunk -> chunk_end = skb_tail_pointer ( chunk -> skb ) ; } else { chunk -> end_of_packet = 1 ; } pr_debug ( \"+++sctp_inq_pop+++<S2SV_blank>chunk:%p[%s],<S2SV_blank>length:%d,<S2SV_blank>skb->len:%d\\\\n\" , chunk , sctp_cname ( SCTP_ST_CHUNK ( chunk -> chunk_hdr -> type ) ) , ntohs ( chunk -> chunk_hdr -> length ) , chunk -> skb -> len ) ; return <S2SV_ModEnd> chunk ; }\n","project_and_commit_id":"torvalds@linux/26b87c7881006311828bb0ab271a551a62dcceb4","cve_id":"CVE-2014-3688","original_address":"https://github.com/torvalds/linux/commit/26b87c7881006311828bb0ab271a551a62dcceb4","time":"2014-11-30T01:59Z"},
	{"Unnamed: 0":6724,"cwe_id":"CWE-310","source":"CWE-310 static int crypto_report_one ( struct crypto_alg * alg , struct crypto_user_alg * ualg , struct sk_buff * skb ) { <S2SV_StartBug> memcpy ( & ualg -> cru_name , & alg -> cra_name , sizeof ( ualg -> cru_name ) ) ; <S2SV_EndBug> <S2SV_StartBug> memcpy ( & ualg -> cru_driver_name , & alg -> cra_driver_name , <S2SV_EndBug> sizeof ( ualg -> cru_driver_name ) ) ; <S2SV_StartBug> memcpy ( & ualg -> cru_module_name , module_name ( alg -> cra_module ) , <S2SV_EndBug> <S2SV_StartBug> CRYPTO_MAX_ALG_NAME ) ; <S2SV_EndBug> ualg -> cru_flags = alg -> cra_flags ; ualg -> cru_refcnt = atomic_read ( & alg -> cra_refcnt ) ; if ( nla_put_u32 ( skb , CRYPTOCFGA_PRIORITY_VAL , alg -> cra_priority ) ) goto nla_put_failure ; if ( alg -> cra_flags & CRYPTO_ALG_LARVAL ) { struct crypto_report_larval rl ; <S2SV_StartBug> snprintf ( rl . type , CRYPTO_MAX_ALG_NAME , \"%s\" , \"larval\" ) ; <S2SV_EndBug> if ( nla_put ( skb , CRYPTOCFGA_REPORT_LARVAL , sizeof ( struct crypto_report_larval ) , & rl ) ) goto nla_put_failure ; goto out ; } if ( alg -> cra_type && alg -> cra_type -> report ) { if ( alg -> cra_type -> report ( skb , alg ) ) goto nla_put_failure ; goto out ; } switch ( alg -> cra_flags & ( CRYPTO_ALG_TYPE_MASK | CRYPTO_ALG_LARVAL ) ) { case CRYPTO_ALG_TYPE_CIPHER : if ( crypto_report_cipher ( skb , alg ) ) goto nla_put_failure ; break ; case CRYPTO_ALG_TYPE_COMPRESS : if ( crypto_report_comp ( skb , alg ) ) goto nla_put_failure ; break ; } out : return 0 ; nla_put_failure : return - EMSGSIZE ; }\n","target":"<S2SV_ModStart> skb ) { strncpy ( <S2SV_ModEnd> ualg -> cru_name <S2SV_ModStart> -> cru_name , <S2SV_ModEnd> alg -> cra_name <S2SV_ModStart> ) ) ; strncpy ( <S2SV_ModEnd> ualg -> cru_driver_name <S2SV_ModStart> -> cru_driver_name , <S2SV_ModEnd> alg -> cra_driver_name <S2SV_ModStart> ) ) ; strncpy ( <S2SV_ModEnd> ualg -> cru_module_name <S2SV_ModStart> cra_module ) , sizeof ( ualg -> cru_module_name ) ) ; ualg -> cru_type = 0 ; ualg -> cru_mask = 0 <S2SV_ModEnd> ; ualg -> <S2SV_ModStart> crypto_report_larval rl ; strncpy <S2SV_ModEnd> ( rl . <S2SV_ModStart> . type , \"larval\" , sizeof ( rl . type ) <S2SV_ModEnd> ) ; if\n","project_and_commit_id":"torvalds@linux/9a5467bf7b6e9e02ec9c3da4e23747c05faeaac6","cve_id":"CVE-2013-2548","original_address":"https://github.com/torvalds/linux/commit/9a5467bf7b6e9e02ec9c3da4e23747c05faeaac6","time":"2013-03-15T20:55Z"},
	{"Unnamed: 0":354,"cwe_id":"CWE-119","source":"CWE-119 int vp8_get_preview_raw_frame ( VP8_COMP * cpi , YV12_BUFFER_CONFIG * dest , vp8_ppflags_t * flags ) { if ( cpi -> common . refresh_alt_ref_frame ) return - 1 ; else { int ret ; # if CONFIG_MULTITHREAD if ( cpi -> b_lpf_running ) { sem_wait ( & cpi -> h_event_end_lpf ) ; cpi -> b_lpf_running = 0 ; } # endif # if CONFIG_POSTPROC cpi -> common . show_frame_mi = cpi -> common . mi ; ret = vp8_post_proc_frame ( & cpi -> common , dest , flags ) ; # else <S2SV_StartBug> if ( cpi -> common . frame_to_show ) <S2SV_EndBug> { * dest = * cpi -> common . frame_to_show ; dest -> y_width = cpi -> common . Width ; dest -> y_height = cpi -> common . Height ; dest -> uv_height = cpi -> common . Height / 2 ; ret = 0 ; } else { ret = - 1 ; } # endif vp8_clear_system_state ( ) ; return ret ; } }\n","target":"<S2SV_ModStart> ; # else ( void ) flags ;\n","project_and_commit_id":"external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426","cve_id":"CVE-2016-1621","original_address":"https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426","time":"2016-03-12T21:59Z"},
	{"Unnamed: 0":2226,"cwe_id":"CWE-787","source":"CWE-787 WORD32 ixheaacd_real_synth_filt ( ia_esbr_hbe_txposer_struct * ptr_hbe_txposer , WORD32 num_columns , FLOAT32 qmf_buf_real [ ] [ 64 ] , FLOAT32 qmf_buf_imag [ ] [ 64 ] ) { WORD32 i , j , k , l , idx ; FLOAT32 g [ 640 ] ; FLOAT32 w [ 640 ] ; FLOAT32 synth_out [ 128 ] ; FLOAT32 accu_r ; WORD32 synth_size = ptr_hbe_txposer -> synth_size ; FLOAT32 * ptr_cos_tab_trans_qmf = ( FLOAT32 * ) & ixheaacd_cos_table_trans_qmf [ 0 ] [ 0 ] + ptr_hbe_txposer -> k_start * 32 ; FLOAT32 * buffer = ptr_hbe_txposer -> synth_buf ; for ( idx = 0 ; idx < num_columns ; idx ++ ) { FLOAT32 loc_qmf_buf [ 64 ] ; FLOAT32 * synth_buf_r = loc_qmf_buf ; FLOAT32 * out_buf = ptr_hbe_txposer -> ptr_input_buf + ( idx + 1 ) * ptr_hbe_txposer -> synth_size ; FLOAT32 * synth_cos_tab = ptr_hbe_txposer -> synth_cos_tab ; const FLOAT32 * interp_window_coeff = ptr_hbe_txposer -> synth_wind_coeff ; if ( ptr_hbe_txposer -> k_start < 0 ) return - 1 ; for ( k = 0 ; k < synth_size ; k ++ ) { WORD32 ki = ptr_hbe_txposer -> k_start + k ; synth_buf_r [ k ] = ( FLOAT32 ) ( ptr_cos_tab_trans_qmf [ ( k << 1 ) + 0 ] * qmf_buf_real [ idx ] [ ki ] + ptr_cos_tab_trans_qmf [ ( k << 1 ) + 1 ] * qmf_buf_imag [ idx ] [ ki ] ) ; synth_buf_r [ k + ptr_hbe_txposer -> synth_size ] = 0 ; } for ( l = ( 20 * synth_size - 1 ) ; l >= 2 * synth_size ; l -- ) { buffer [ l ] = buffer [ l - 2 * synth_size ] ; } if ( synth_size == 20 ) { FLOAT32 * psynth_cos_tab = synth_cos_tab ; for ( l = 0 ; l < ( synth_size + 1 ) ; l ++ ) { accu_r = 0.0 ; for ( k = 0 ; k < synth_size ; k ++ ) { accu_r += synth_buf_r [ k ] * psynth_cos_tab [ k ] ; } buffer [ 0 + l ] = accu_r ; buffer [ synth_size - l ] = accu_r ; psynth_cos_tab = psynth_cos_tab + synth_size ; } for ( l = ( synth_size + 1 ) ; l < ( 2 * synth_size - synth_size / 2 ) ; l ++ ) { accu_r = 0.0 ; for ( k = 0 ; k < synth_size ; k ++ ) { accu_r += synth_buf_r [ k ] * psynth_cos_tab [ k ] ; } buffer [ 0 + l ] = accu_r ; buffer [ 3 * synth_size - l ] = - accu_r ; psynth_cos_tab = psynth_cos_tab + synth_size ; } accu_r = 0.0 ; for ( k = 0 ; k < synth_size ; k ++ ) { accu_r += synth_buf_r [ k ] * psynth_cos_tab [ k ] ; } buffer [ 3 * synth_size >> 1 ] = accu_r ; } else { FLOAT32 tmp ; FLOAT32 * ptr_u = synth_out ; WORD32 kmax = ( synth_size >> 1 ) ; FLOAT32 * syn_buf = & buffer [ kmax ] ; kmax += synth_size ; <S2SV_StartBug> if ( ixheaacd_real_synth_fft != NULL ) <S2SV_EndBug> <S2SV_StartBug> ( * ixheaacd_real_synth_fft ) ( synth_buf_r , synth_out , synth_size * 2 ) ; <S2SV_EndBug> else return - 1 ; for ( k = 0 ; k < kmax ; k ++ ) { tmp = ( ( * ptr_u ++ ) * ( * synth_cos_tab ++ ) ) ; tmp -= ( ( * ptr_u ++ ) * ( * synth_cos_tab ++ ) ) ; * syn_buf ++ = tmp ; } syn_buf = & buffer [ 0 ] ; kmax -= synth_size ; for ( k = 0 ; k < kmax ; k ++ ) { tmp = ( ( * ptr_u ++ ) * ( * synth_cos_tab ++ ) ) ; tmp -= ( ( * ptr_u ++ ) * ( * synth_cos_tab ++ ) ) ; * syn_buf ++ = tmp ; } } for ( i = 0 ; i < 5 ; i ++ ) { memcpy ( & g [ ( 2 * i + 0 ) * synth_size ] , & buffer [ ( 4 * i + 0 ) * synth_size ] , sizeof ( FLOAT32 ) * synth_size ) ; memcpy ( & g [ ( 2 * i + 1 ) * synth_size ] , & buffer [ ( 4 * i + 3 ) * synth_size ] , sizeof ( FLOAT32 ) * synth_size ) ; } for ( k = 0 ; k < 10 * synth_size ; k ++ ) { w [ k ] = g [ k ] * interp_window_coeff [ k ] ; } for ( i = 0 ; i < synth_size ; i ++ ) { accu_r = 0.0 ; for ( j = 0 ; j < 10 ; j ++ ) { accu_r = accu_r + w [ synth_size * j + i ] ; } out_buf [ i ] = ( FLOAT32 ) accu_r ; } } return 0 ; }\n","target":"<S2SV_ModStart> ; if ( ptr_hbe_txposer -> <S2SV_ModStart> ) ( * ( ptr_hbe_txposer -> ixheaacd_real_synth_fft ) ) <S2SV_ModEnd> ( synth_buf_r ,\n","project_and_commit_id":"external@libxaac/04e8cd58f075bec5892e369c8deebca9c67e855c","cve_id":"CVE-2018-9496","original_address":"https://android.googlesource.com/platform/external/libxaac/+/04e8cd58f075bec5892e369c8deebca9c67e855c","time":"2018-10-02T19:29Z"},
	{"Unnamed: 0":1275,"cwe_id":"CWE-285","source":"CWE-285 int orangefs_set_acl ( struct inode * inode , struct posix_acl * acl , int type ) { struct orangefs_inode_s * orangefs_inode = ORANGEFS_I ( inode ) ; int error = 0 ; void * value = NULL ; size_t size = 0 ; const char * name = NULL ; switch ( type ) { case ACL_TYPE_ACCESS : name = XATTR_NAME_POSIX_ACL_ACCESS ; if ( acl ) { <S2SV_StartBug> umode_t mode = inode -> i_mode ; <S2SV_EndBug> <S2SV_StartBug> error = posix_acl_equiv_mode ( acl , & mode ) ; <S2SV_EndBug> if ( error < 0 ) { <S2SV_StartBug> gossip_err ( \"%s:<S2SV_blank>posix_acl_equiv_mode<S2SV_blank>err:<S2SV_blank>%d\\\\n\" , <S2SV_EndBug> __func__ , error ) ; return error ; } if ( inode -> i_mode != mode ) SetModeFlag ( orangefs_inode ) ; inode -> i_mode = mode ; mark_inode_dirty_sync ( inode ) ; <S2SV_StartBug> if ( error == 0 ) <S2SV_EndBug> acl = NULL ; } break ; case ACL_TYPE_DEFAULT : name = XATTR_NAME_POSIX_ACL_DEFAULT ; break ; default : gossip_err ( \"%s:<S2SV_blank>invalid<S2SV_blank>type<S2SV_blank>%d!\\\\n\" , __func__ , type ) ; return - EINVAL ; } gossip_debug ( GOSSIP_ACL_DEBUG , \"%s:<S2SV_blank>inode<S2SV_blank>%pU,<S2SV_blank>key<S2SV_blank>%s<S2SV_blank>type<S2SV_blank>%d\\\\n\" , __func__ , get_khandle_from_ino ( inode ) , name , type ) ; if ( acl ) { size = posix_acl_xattr_size ( acl -> a_count ) ; value = kmalloc ( size , GFP_KERNEL ) ; if ( ! value ) return - ENOMEM ; error = posix_acl_to_xattr ( & init_user_ns , acl , value , size ) ; if ( error < 0 ) goto out ; } gossip_debug ( GOSSIP_ACL_DEBUG , \"%s:<S2SV_blank>name<S2SV_blank>%s,<S2SV_blank>value<S2SV_blank>%p,<S2SV_blank>size<S2SV_blank>%zd,<S2SV_blank>acl<S2SV_blank>%p\\\\n\" , __func__ , name , value , size , acl ) ; error = orangefs_inode_setxattr ( inode , name , value , size , 0 ) ; out : kfree ( value ) ; if ( ! error ) set_cached_acl ( inode , type , acl ) ; return error ; }\n","target":"<S2SV_ModStart> { umode_t mode ; error = posix_acl_update_mode ( inode <S2SV_ModEnd> , & mode <S2SV_ModStart> , & mode , & acl ) ; if ( error <S2SV_ModEnd> ) { gossip_err <S2SV_ModStart> { gossip_err ( \"%s:<S2SV_blank>posix_acl_update_mode<S2SV_blank>err:<S2SV_blank>%d\\\\n\" <S2SV_ModEnd> , __func__ , <S2SV_ModStart> inode ) ; <S2SV_ModEnd> } break ;\n","project_and_commit_id":"torvalds@linux/073931017b49d9458aa351605b43a7e34598caef","cve_id":"CVE-2016-7097","original_address":"https://github.com/torvalds/linux/commit/073931017b49d9458aa351605b43a7e34598caef","time":"2016-10-16T21:59Z"},
	{"Unnamed: 0":2474,"cwe_id":"CWE-189","source":"CWE-189 int kvm_iommu_map_pages ( struct kvm * kvm , struct kvm_memory_slot * slot ) { gfn_t gfn , end_gfn ; pfn_t pfn ; int r = 0 ; struct iommu_domain * domain = kvm -> arch . iommu_domain ; int flags ; if ( ! domain ) return 0 ; gfn = slot -> base_gfn ; end_gfn = gfn + slot -> npages ; flags = IOMMU_READ ; if ( ! ( slot -> flags & KVM_MEM_READONLY ) ) flags |= IOMMU_WRITE ; if ( ! kvm -> arch . iommu_noncoherent ) flags |= IOMMU_CACHE ; while ( gfn < end_gfn ) { unsigned long page_size ; if ( iommu_iova_to_phys ( domain , gfn_to_gpa ( gfn ) ) ) { gfn += 1 ; continue ; } page_size = kvm_host_page_size ( kvm , gfn ) ; while ( ( gfn + ( page_size >> PAGE_SHIFT ) ) > end_gfn ) page_size >>= 1 ; while ( ( gfn << PAGE_SHIFT ) & ( page_size - 1 ) ) page_size >>= 1 ; while ( __gfn_to_hva_memslot ( slot , gfn ) & ( page_size - 1 ) ) page_size >>= 1 ; pfn = kvm_pin_pages ( slot , gfn , page_size ) ; if ( is_error_noslot_pfn ( pfn ) ) { gfn += 1 ; continue ; } r = iommu_map ( domain , gfn_to_gpa ( gfn ) , pfn_to_hpa ( pfn ) , page_size , flags ) ; if ( r ) { printk ( KERN_ERR \"kvm_iommu_map_address:\" \"iommu<S2SV_blank>failed<S2SV_blank>to<S2SV_blank>map<S2SV_blank>pfn=%llx\\\\n\" , pfn ) ; <S2SV_StartBug> goto unmap_pages ; <S2SV_EndBug> } gfn += page_size >> PAGE_SHIFT ; } return 0 ; unmap_pages : <S2SV_StartBug> kvm_iommu_put_pages ( kvm , slot -> base_gfn , gfn ) ; <S2SV_EndBug> return r ; }\n","target":"<S2SV_ModStart> pfn ) ; kvm_unpin_pages ( kvm , pfn , page_size ) ; <S2SV_ModStart> base_gfn , gfn - slot -> base_gfn\n","project_and_commit_id":"torvalds@linux/350b8bdd689cd2ab2c67c8a86a0be86cfa0751a7","cve_id":"CVE-2014-3601","original_address":"https://github.com/torvalds/linux/commit/350b8bdd689cd2ab2c67c8a86a0be86cfa0751a7","time":"2014-09-01T01:55Z"},
	{"Unnamed: 0":2973,"cwe_id":"CWE-476","source":"CWE-476 int btrfs_init_dev_replace ( struct btrfs_fs_info * fs_info ) { struct btrfs_key key ; struct btrfs_root * dev_root = fs_info -> dev_root ; struct btrfs_dev_replace * dev_replace = & fs_info -> dev_replace ; struct extent_buffer * eb ; int slot ; int ret = 0 ; struct btrfs_path * path = NULL ; int item_size ; struct btrfs_dev_replace_item * ptr ; u64 src_devid ; path = btrfs_alloc_path ( ) ; if ( ! path ) { ret = - ENOMEM ; goto out ; } key . objectid = 0 ; key . type = BTRFS_DEV_REPLACE_KEY ; key . offset = 0 ; ret = btrfs_search_slot ( NULL , dev_root , & key , path , 0 , 0 ) ; if ( ret ) { no_valid_dev_replace_entry_found : ret = 0 ; dev_replace -> replace_state = BTRFS_DEV_REPLACE_ITEM_STATE_NEVER_STARTED ; dev_replace -> cont_reading_from_srcdev_mode = BTRFS_DEV_REPLACE_ITEM_CONT_READING_FROM_SRCDEV_MODE_ALWAYS ; dev_replace -> time_started = 0 ; dev_replace -> time_stopped = 0 ; atomic64_set ( & dev_replace -> num_write_errors , 0 ) ; atomic64_set ( & dev_replace -> num_uncorrectable_read_errors , 0 ) ; dev_replace -> cursor_left = 0 ; dev_replace -> committed_cursor_left = 0 ; dev_replace -> cursor_left_last_write_of_item = 0 ; dev_replace -> cursor_right = 0 ; dev_replace -> srcdev = NULL ; dev_replace -> tgtdev = NULL ; dev_replace -> is_valid = 0 ; dev_replace -> item_needs_writeback = 0 ; goto out ; } slot = path -> slots [ 0 ] ; eb = path -> nodes [ 0 ] ; item_size = btrfs_item_size_nr ( eb , slot ) ; ptr = btrfs_item_ptr ( eb , slot , struct btrfs_dev_replace_item ) ; if ( item_size != sizeof ( struct btrfs_dev_replace_item ) ) { btrfs_warn ( fs_info , \"dev_replace<S2SV_blank>entry<S2SV_blank>found<S2SV_blank>has<S2SV_blank>unexpected<S2SV_blank>size,<S2SV_blank>ignore<S2SV_blank>entry\" ) ; goto no_valid_dev_replace_entry_found ; } src_devid = btrfs_dev_replace_src_devid ( eb , ptr ) ; dev_replace -> cont_reading_from_srcdev_mode = btrfs_dev_replace_cont_reading_from_srcdev_mode ( eb , ptr ) ; dev_replace -> replace_state = btrfs_dev_replace_replace_state ( eb , ptr ) ; dev_replace -> time_started = btrfs_dev_replace_time_started ( eb , ptr ) ; dev_replace -> time_stopped = btrfs_dev_replace_time_stopped ( eb , ptr ) ; atomic64_set ( & dev_replace -> num_write_errors , btrfs_dev_replace_num_write_errors ( eb , ptr ) ) ; atomic64_set ( & dev_replace -> num_uncorrectable_read_errors , btrfs_dev_replace_num_uncorrectable_read_errors ( eb , ptr ) ) ; dev_replace -> cursor_left = btrfs_dev_replace_cursor_left ( eb , ptr ) ; dev_replace -> committed_cursor_left = dev_replace -> cursor_left ; dev_replace -> cursor_left_last_write_of_item = dev_replace -> cursor_left ; dev_replace -> cursor_right = btrfs_dev_replace_cursor_right ( eb , ptr ) ; dev_replace -> is_valid = 1 ; dev_replace -> item_needs_writeback = 0 ; switch ( dev_replace -> replace_state ) { case BTRFS_IOCTL_DEV_REPLACE_STATE_NEVER_STARTED : case BTRFS_IOCTL_DEV_REPLACE_STATE_FINISHED : case BTRFS_IOCTL_DEV_REPLACE_STATE_CANCELED : dev_replace -> srcdev = NULL ; dev_replace -> tgtdev = NULL ; break ; case BTRFS_IOCTL_DEV_REPLACE_STATE_STARTED : case BTRFS_IOCTL_DEV_REPLACE_STATE_SUSPENDED : dev_replace -> srcdev = btrfs_find_device ( fs_info -> fs_devices , <S2SV_StartBug> src_devid , NULL , NULL ) ; <S2SV_EndBug> dev_replace -> tgtdev = btrfs_find_device ( fs_info -> fs_devices , BTRFS_DEV_REPLACE_DEVID , <S2SV_StartBug> NULL , NULL ) ; <S2SV_EndBug> if ( ! dev_replace -> srcdev && ! btrfs_test_opt ( fs_info , DEGRADED ) ) { ret = - EIO ; btrfs_warn ( fs_info , \"cannot<S2SV_blank>mount<S2SV_blank>because<S2SV_blank>device<S2SV_blank>replace<S2SV_blank>operation<S2SV_blank>is<S2SV_blank>ongoing<S2SV_blank>and\" ) ; btrfs_warn ( fs_info , \"srcdev<S2SV_blank>(devid<S2SV_blank>%llu)<S2SV_blank>is<S2SV_blank>missing,<S2SV_blank>need<S2SV_blank>to<S2SV_blank>run<S2SV_blank>\\'btrfs<S2SV_blank>dev<S2SV_blank>scan\\'?\" , src_devid ) ; } if ( ! dev_replace -> tgtdev && ! btrfs_test_opt ( fs_info , DEGRADED ) ) { ret = - EIO ; btrfs_warn ( fs_info , \"cannot<S2SV_blank>mount<S2SV_blank>because<S2SV_blank>device<S2SV_blank>replace<S2SV_blank>operation<S2SV_blank>is<S2SV_blank>ongoing<S2SV_blank>and\" ) ; btrfs_warn ( fs_info , \"tgtdev<S2SV_blank>(devid<S2SV_blank>%llu)<S2SV_blank>is<S2SV_blank>missing,<S2SV_blank>need<S2SV_blank>to<S2SV_blank>run<S2SV_blank>\\'btrfs<S2SV_blank>dev<S2SV_blank>scan\\'?\" , BTRFS_DEV_REPLACE_DEVID ) ; } if ( dev_replace -> tgtdev ) { if ( dev_replace -> srcdev ) { dev_replace -> tgtdev -> total_bytes = dev_replace -> srcdev -> total_bytes ; dev_replace -> tgtdev -> disk_total_bytes = dev_replace -> srcdev -> disk_total_bytes ; dev_replace -> tgtdev -> commit_total_bytes = dev_replace -> srcdev -> commit_total_bytes ; dev_replace -> tgtdev -> bytes_used = dev_replace -> srcdev -> bytes_used ; dev_replace -> tgtdev -> commit_bytes_used = dev_replace -> srcdev -> commit_bytes_used ; } set_bit ( BTRFS_DEV_STATE_REPLACE_TGT , & dev_replace -> tgtdev -> dev_state ) ; WARN_ON ( fs_info -> fs_devices -> rw_devices == 0 ) ; dev_replace -> tgtdev -> io_width = fs_info -> sectorsize ; dev_replace -> tgtdev -> io_align = fs_info -> sectorsize ; dev_replace -> tgtdev -> sector_size = fs_info -> sectorsize ; dev_replace -> tgtdev -> fs_info = fs_info ; set_bit ( BTRFS_DEV_STATE_IN_FS_METADATA , & dev_replace -> tgtdev -> dev_state ) ; } break ; } out : btrfs_free_path ( path ) ; return ret ; }\n","target":"<S2SV_ModStart> NULL , NULL , true <S2SV_ModStart> NULL , NULL , true\n","project_and_commit_id":"torvalds@linux/09ba3bc9dd150457c506e4661380a6183af651c1","cve_id":"CVE-2019-18885","original_address":"https://github.com/torvalds/linux/commit/09ba3bc9dd150457c506e4661380a6183af651c1","time":"2019-11-14T14:15Z"},
	{"Unnamed: 0":33,"cwe_id":"CWE-200","source":"CWE-200 static int pn_recvmsg ( struct kiocb * iocb , struct sock * sk , struct msghdr * msg , size_t len , int noblock , int flags , int * addr_len ) { struct sk_buff * skb = NULL ; struct sockaddr_pn sa ; int rval = - EOPNOTSUPP ; int copylen ; if ( flags & ~ ( MSG_PEEK | MSG_TRUNC | MSG_DONTWAIT | MSG_NOSIGNAL | MSG_CMSG_COMPAT ) ) <S2SV_StartBug> goto out_nofree ; <S2SV_EndBug> if ( addr_len ) * addr_len = sizeof ( sa ) ; skb = skb_recv_datagram ( sk , flags , noblock , & rval ) ; if ( skb == NULL ) goto out_nofree ; pn_skb_get_src_sockaddr ( skb , & sa ) ; copylen = skb -> len ; if ( len < copylen ) { msg -> msg_flags |= MSG_TRUNC ; copylen = len ; } rval = skb_copy_datagram_iovec ( skb , 0 , msg -> msg_iov , copylen ) ; if ( rval ) { rval = - EFAULT ; goto out ; } rval = ( flags & MSG_TRUNC ) ? skb -> len : copylen ; <S2SV_StartBug> if ( msg -> msg_name != NULL ) <S2SV_EndBug> <S2SV_StartBug> memcpy ( msg -> msg_name , & sa , sizeof ( struct sockaddr_pn ) ) ; <S2SV_EndBug> out : skb_free_datagram ( sk , skb ) ; out_nofree : return rval ; }\n","target":"<S2SV_ModStart> ) goto out_nofree <S2SV_ModEnd> ; skb = <S2SV_ModStart> != NULL ) { <S2SV_ModStart> , sizeof ( sa ) ) ; * addr_len = sizeof ( sa ) ; } <S2SV_ModEnd> out : skb_free_datagram\n","project_and_commit_id":"torvalds@linux/bceaa90240b6019ed73b49965eac7d167610be69","cve_id":"CVE-2013-7281","original_address":"https://github.com/torvalds/linux/commit/bceaa90240b6019ed73b49965eac7d167610be69","time":"2014-01-08T16:55Z"},
	{"Unnamed: 0":6566,"cwe_id":"CWE-787","source":"CWE-787 static OPJ_BOOL opj_j2k_write_sod ( opj_j2k_t * p_j2k , opj_tcd_t * p_tile_coder , OPJ_BYTE * p_data , OPJ_UINT32 * p_data_written , OPJ_UINT32 p_total_data_size , const opj_stream_private_t * p_stream , opj_event_mgr_t * p_manager ) { opj_codestream_info_t * l_cstr_info = 00 ; OPJ_UINT32 l_remaining_data ; assert ( p_j2k != 00 ) ; assert ( p_manager != 00 ) ; assert ( p_stream != 00 ) ; OPJ_UNUSED ( p_stream ) ; <S2SV_StartBug> opj_write_bytes ( p_data , J2K_MS_SOD , <S2SV_EndBug> 2 ) ; p_data += 2 ; l_remaining_data = p_total_data_size - 4 ; p_tile_coder -> tp_num = p_j2k -> m_specific_param . m_encoder . m_current_poc_tile_part_number ; p_tile_coder -> cur_tp_num = p_j2k -> m_specific_param . m_encoder . m_current_tile_part_number ; # ifdef USE_JPWL assert ( 0 && \"TODO\" ) ; # endif if ( p_j2k -> m_specific_param . m_encoder . m_current_tile_part_number == 0 ) { p_tile_coder -> tcd_image -> tiles -> packno = 0 ; if ( l_cstr_info ) { l_cstr_info -> packno = 0 ; } } * p_data_written = 0 ; if ( ! opj_tcd_encode_tile ( p_tile_coder , p_j2k -> m_current_tile_number , p_data , p_data_written , l_remaining_data , l_cstr_info , p_manager ) ) { opj_event_msg ( p_manager , EVT_ERROR , \"Cannot<S2SV_blank>encode<S2SV_blank>tile\\\\n\" ) ; return OPJ_FALSE ; } * p_data_written += 2 ; return OPJ_TRUE ; }\n","target":"<S2SV_ModStart> p_stream ) ; if ( p_total_data_size < 4 ) { opj_event_msg ( p_manager , EVT_ERROR , \"Not<S2SV_blank>enough<S2SV_blank>bytes<S2SV_blank>in<S2SV_blank>output<S2SV_blank>buffer<S2SV_blank>to<S2SV_blank>write<S2SV_blank>SOD<S2SV_blank>marker\\\\n\" ) ; return OPJ_FALSE ; }\n","project_and_commit_id":"uclouvain@openjpeg/c535531f03369623b9b833ef41952c62257b507e","cve_id":"CVE-2017-14039","original_address":"https://github.com/uclouvain/openjpeg/commit/c535531f03369623b9b833ef41952c62257b507e","time":"2017-08-30T22:29Z"},
	{"Unnamed: 0":3286,"cwe_id":"CWE-119","source":"CWE-119 static void scsi_free_request ( SCSIRequest * req ) { SCSIDiskReq * r = DO_UPCAST ( SCSIDiskReq , req , req ) ; <S2SV_StartBug> qemu_vfree ( r -> iov . iov_base ) ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug>\n","target":"<S2SV_ModStart> req ) ; if ( r -> iov . iov_base ) { <S2SV_ModStart> ) ; } }\n","project_and_commit_id":"bonzini@qemu/7285477ab11831b1cf56e45878a89170dd06d9b9","cve_id":"CVE-2011-3346","original_address":"https://github.com/bonzini/qemu/commit/7285477ab11831b1cf56e45878a89170dd06d9b9","time":"2014-04-01T06:35Z"},
	{"Unnamed: 0":5886,"cwe_id":"CWE-120","source":"CWE-120 static int fuse_notify_inval_entry ( struct fuse_conn * fc , unsigned int size , struct fuse_copy_state * cs ) { struct fuse_notify_inval_entry_out outarg ; int err = - ENOMEM ; char * buf ; struct qstr name ; buf = kzalloc ( FUSE_NAME_MAX + 1 , GFP_KERNEL ) ; if ( ! buf ) goto err ; err = - EINVAL ; if ( size < sizeof ( outarg ) ) goto err ; err = fuse_copy_one ( cs , & outarg , sizeof ( outarg ) ) ; if ( err ) goto err ; err = - ENAMETOOLONG ; if ( outarg . namelen > FUSE_NAME_MAX ) goto err ; <S2SV_StartBug> name . name = buf ; <S2SV_EndBug> name . len = outarg . namelen ; <S2SV_StartBug> err = fuse_copy_one ( cs , buf , outarg . namelen + 1 ) ; <S2SV_EndBug> if ( err ) goto err ; fuse_copy_finish ( cs ) ; buf [ outarg . namelen ] = 0 ; name . hash = full_name_hash ( name . name , name . len ) ; down_read ( & fc -> killsb ) ; err = - ENOENT ; if ( fc -> sb ) err = fuse_reverse_inval_entry ( fc -> sb , outarg . parent , & name ) ; up_read ( & fc -> killsb ) ; kfree ( buf ) ; return err ; err : kfree ( buf ) ; fuse_copy_finish ( cs ) ; return err ; }\n","target":"<S2SV_ModStart> goto err ; err = - EINVAL ; if ( size != sizeof ( outarg ) + <S2SV_ModEnd> outarg . namelen <S2SV_ModStart> + 1 ) goto err ; name . name = buf ; name . len = outarg . namelen ; err = fuse_copy_one ( cs , buf , outarg . namelen + 1 )\n","project_and_commit_id":"torvalds@linux/c2183d1e9b3f313dd8ba2b1b0197c8d9fb86a7ae","cve_id":"CVE-2011-3353","original_address":"https://github.com/torvalds/linux/commit/c2183d1e9b3f313dd8ba2b1b0197c8d9fb86a7ae","time":"2012-05-24T23:55Z"},
	{"Unnamed: 0":1036,"cwe_id":"CWE-20","source":"CWE-20 int treeRead ( struct READER * reader , struct DATAOBJECT * data ) { int i , j , err , olen , elements , size , x , y , z , b , e , dy , dz , sx , sy , sz , dzy , szy ; char * input , * output ; uint8_t node_type , node_level ; uint16_t entries_used ; uint32_t size_of_chunk ; uint32_t filter_mask ; uint64_t address_of_left_sibling , address_of_right_sibling , start [ 4 ] , child_pointer , key , store ; char buf [ 4 ] ; UNUSED ( node_level ) ; UNUSED ( address_of_right_sibling ) ; UNUSED ( address_of_left_sibling ) ; UNUSED ( key ) ; if ( data -> ds . dimensionality > 3 ) { log ( \"TREE<S2SV_blank>dimensions<S2SV_blank>><S2SV_blank>3\" ) ; return MYSOFA_INVALID_FORMAT ; } if ( fread ( buf , 1 , 4 , reader -> fhd ) != 4 || strncmp ( buf , \"TREE\" , 4 ) ) { log ( \"cannot<S2SV_blank>read<S2SV_blank>signature<S2SV_blank>of<S2SV_blank>TREE\\\\n\" ) ; return MYSOFA_INVALID_FORMAT ; } log ( \"%08lX<S2SV_blank>%.4s\\\\n\" , ( uint64_t ) ftell ( reader -> fhd ) - 4 , buf ) ; node_type = ( uint8_t ) fgetc ( reader -> fhd ) ; node_level = ( uint8_t ) fgetc ( reader -> fhd ) ; entries_used = ( uint16_t ) readValue ( reader , 2 ) ; if ( entries_used > 0x1000 ) return MYSOFA_UNSUPPORTED_FORMAT ; address_of_left_sibling = readValue ( reader , reader -> superblock . size_of_offsets ) ; address_of_right_sibling = readValue ( reader , reader -> superblock . size_of_offsets ) ; elements = 1 ; for ( j = 0 ; j < data -> ds . dimensionality ; j ++ ) elements *= data -> datalayout_chunk [ j ] ; dy = data -> datalayout_chunk [ 1 ] ; dz = data -> datalayout_chunk [ 2 ] ; sx = data -> ds . dimension_size [ 0 ] ; sy = data -> ds . dimension_size [ 1 ] ; sz = data -> ds . dimension_size [ 2 ] ; dzy = dz * dy ; szy = sz * sy ; size = data -> datalayout_chunk [ data -> ds . dimensionality ] ; log ( \"elements<S2SV_blank>%d<S2SV_blank>size<S2SV_blank>%d\\\\n\" , elements , size ) ; if ( ! ( output = malloc ( elements * size ) ) ) { return MYSOFA_NO_MEMORY ; } for ( e = 0 ; e < entries_used * 2 ; e ++ ) { if ( node_type == 0 ) { key = readValue ( reader , reader -> superblock . size_of_lengths ) ; } else { size_of_chunk = ( uint32_t ) readValue ( reader , 4 ) ; filter_mask = ( uint32_t ) readValue ( reader , 4 ) ; if ( filter_mask ) { log ( \"TREE<S2SV_blank>all<S2SV_blank>filters<S2SV_blank>must<S2SV_blank>be<S2SV_blank>enabled\\\\n\" ) ; free ( output ) ; return MYSOFA_INVALID_FORMAT ; } for ( j = 0 ; j < data -> ds . dimensionality ; j ++ ) { start [ j ] = readValue ( reader , 8 ) ; log ( \"start<S2SV_blank>%d<S2SV_blank>%lu\\\\n\" , j , start [ j ] ) ; } if ( readValue ( reader , 8 ) ) { break ; } child_pointer = readValue ( reader , reader -> superblock . size_of_offsets ) ; log ( \"<S2SV_blank>data<S2SV_blank>at<S2SV_blank>%lX<S2SV_blank>len<S2SV_blank>%u\\\\n\" , child_pointer , size_of_chunk ) ; store = ftell ( reader -> fhd ) ; if ( fseek ( reader -> fhd , child_pointer , SEEK_SET ) < 0 ) { free ( output ) ; return errno ; } if ( ! ( input = malloc ( size_of_chunk ) ) ) { free ( output ) ; return MYSOFA_NO_MEMORY ; } if ( fread ( input , 1 , size_of_chunk , reader -> fhd ) != size_of_chunk ) { free ( output ) ; free ( input ) ; return MYSOFA_INVALID_FORMAT ; } olen = elements * size ; err = gunzip ( size_of_chunk , input , & olen , output ) ; free ( input ) ; log ( \"<S2SV_blank><S2SV_blank><S2SV_blank>gunzip<S2SV_blank>%d<S2SV_blank>%d<S2SV_blank>%d\\\\n\" , err , olen , elements * size ) ; if ( err || olen != elements * size ) { free ( output ) ; return MYSOFA_INVALID_FORMAT ; } switch ( data -> ds . dimensionality ) { case 1 : for ( i = 0 ; i < olen ; i ++ ) { b = i / elements ; x = i % elements + start [ 0 ] ; <S2SV_StartBug> if ( x < sx ) { <S2SV_EndBug> <S2SV_StartBug> j = x * size + b ; <S2SV_EndBug> ( ( char * ) data -> data ) [ j ] = output [ i ] ; } } break ; case 2 : for ( i = 0 ; i < olen ; i ++ ) { b = i / elements ; x = i % elements ; y = x % dy + start [ 1 ] ; x = x / dy + start [ 0 ] ; <S2SV_StartBug> if ( y < sy && x < sx ) { <S2SV_EndBug> <S2SV_StartBug> j = ( ( x * sy + y ) * size ) + b ; <S2SV_EndBug> ( ( char * ) data -> data ) [ j ] = output [ i ] ; } } break ; case 3 : for ( i = 0 ; i < olen ; i ++ ) { b = i / elements ; x = i % elements ; z = x % dz + start [ 2 ] ; y = ( x / dz ) % dy + start [ 1 ] ; x = ( x / dzy ) + start [ 0 ] ; <S2SV_StartBug> if ( z < sz && y < sy && x < sx ) { <S2SV_EndBug> j = ( x * szy + y * sz + z ) * size + b ; <S2SV_StartBug> ( ( char * ) data -> data ) [ j ] = output [ i ] ; <S2SV_EndBug> } } break ; default : log ( \"invalid<S2SV_blank>dim\\\\n\" ) ; return MYSOFA_INTERNAL_ERROR ; } if ( fseek ( reader -> fhd , store , SEEK_SET ) < 0 ) { free ( output ) ; return errno ; } } } free ( output ) ; if ( fseek ( reader -> fhd , 4 , SEEK_CUR ) < 0 ) return errno ; return MYSOFA_OK ; }\n","target":"<S2SV_ModStart> 0 ] ; <S2SV_ModEnd> j = x <S2SV_ModStart> + b ; if ( j >= 0 && j < elements * size ) { <S2SV_ModStart> 0 ] ; <S2SV_ModEnd> j = ( <S2SV_ModStart> + b ; if ( j >= 0 && j < elements * size ) { <S2SV_ModStart> 0 ] ; <S2SV_ModEnd> j = ( <S2SV_ModStart> + b ; if ( j >= 0 && j < elements * size ) {\n","project_and_commit_id":"hoene@libmysofa/d39a171e9c6a1c44dbdf43f9db6c3fbd887e38c1","cve_id":"CVE-2019-10672","original_address":"https://github.com/hoene/libmysofa/commit/d39a171e9c6a1c44dbdf43f9db6c3fbd887e38c1","time":"2019-03-31T17:29Z"},
	{"Unnamed: 0":4301,"cwe_id":"CWE-119","source":"CWE-119 <S2SV_StartBug> static void <S2SV_EndBug> horAcc16 ( TIFF * tif , uint8 * cp0 , tmsize_t cc ) { tmsize_t stride = PredictorState ( tif ) -> stride ; uint16 * wp = ( uint16 * ) cp0 ; tmsize_t wc = cc / 2 ; <S2SV_StartBug> assert ( ( cc % ( 2 * stride ) ) == 0 ) ; <S2SV_EndBug> if ( wc > stride ) { wc -= stride ; do { REPEAT4 ( stride , wp [ stride ] = ( uint16 ) ( ( ( unsigned int ) wp [ stride ] + ( unsigned int ) wp [ 0 ] ) & 0xffff ) ; wp ++ ) wc -= stride ; } while ( wc > 0 ) ; } <S2SV_StartBug> } <S2SV_EndBug>\n","target":"<S2SV_ModStart> <S2SV_null> <S2SV_null> static int <S2SV_ModEnd> horAcc16 ( TIFF <S2SV_ModStart> / 2 ; if <S2SV_ModEnd> ( ( cc <S2SV_ModStart> stride ) ) != 0 ) { TIFFErrorExt ( tif -> tif_clientdata , \"horAcc16\" , \"%s\" , \"cc%(2*stride))!=0\" ) ; return 0 ; } <S2SV_ModEnd> if ( wc <S2SV_ModStart> ) ; } return 1 ;\n","project_and_commit_id":"vadz@libtiff/3ca657a8793dd011bf869695d72ad31c779c3cc1","cve_id":"CVE-2016-9535","original_address":"https://github.com/vadz/libtiff/commit/3ca657a8793dd011bf869695d72ad31c779c3cc1","time":"2016-11-22T19:59Z"},
	{"Unnamed: 0":4330,"cwe_id":"CWE-444","source":"CWE-444 static ngx_int_t ngx_http_lua_adjust_subrequest ( ngx_http_request_t * sr , ngx_uint_t method , int always_forward_body , ngx_http_request_body_t * body , unsigned vars_action , ngx_array_t * extra_vars ) { ngx_http_request_t * r ; <S2SV_StartBug> ngx_int_t rc ; <S2SV_EndBug> ngx_http_core_main_conf_t * cmcf ; <S2SV_StartBug> size_t size ; <S2SV_EndBug> r = sr -> parent ; sr -> header_in = r -> header_in ; if ( body ) { sr -> request_body = body ; <S2SV_StartBug> rc = ngx_http_lua_set_content_length_header ( sr , <S2SV_EndBug> body -> buf ? ngx_buf_size ( body -> buf ) : 0 ) ; if ( rc != NGX_OK ) { return NGX_ERROR ; } } else if ( ! always_forward_body && method != NGX_HTTP_PUT && method != NGX_HTTP_POST && r -> headers_in . content_length_n > 0 ) { <S2SV_StartBug> rc = ngx_http_lua_set_content_length_header ( sr , 0 ) ; <S2SV_EndBug> if ( rc != NGX_OK ) { return NGX_ERROR ; } <S2SV_StartBug> # if 1 <S2SV_EndBug> sr -> request_body = NULL ; # endif } else { <S2SV_StartBug> if ( ngx_http_lua_copy_request_headers ( sr , r ) != NGX_OK ) { <S2SV_EndBug> return NGX_ERROR ; <S2SV_StartBug> } <S2SV_EndBug> if ( sr -> request_body ) { if ( sr -> request_body -> temp_file ) { if ( ngx_http_lua_copy_in_file_request_body ( sr ) != NGX_OK ) { return NGX_ERROR ; } } } } sr -> method = method ; switch ( method ) { case NGX_HTTP_GET : sr -> method_name = ngx_http_lua_get_method ; break ; case NGX_HTTP_POST : sr -> method_name = ngx_http_lua_post_method ; break ; case NGX_HTTP_PUT : sr -> method_name = ngx_http_lua_put_method ; break ; case NGX_HTTP_HEAD : sr -> method_name = ngx_http_lua_head_method ; break ; case NGX_HTTP_DELETE : sr -> method_name = ngx_http_lua_delete_method ; break ; case NGX_HTTP_OPTIONS : sr -> method_name = ngx_http_lua_options_method ; break ; case NGX_HTTP_MKCOL : sr -> method_name = ngx_http_lua_mkcol_method ; break ; case NGX_HTTP_COPY : sr -> method_name = ngx_http_lua_copy_method ; break ; case NGX_HTTP_MOVE : sr -> method_name = ngx_http_lua_move_method ; break ; case NGX_HTTP_PROPFIND : sr -> method_name = ngx_http_lua_propfind_method ; break ; case NGX_HTTP_PROPPATCH : sr -> method_name = ngx_http_lua_proppatch_method ; break ; case NGX_HTTP_LOCK : sr -> method_name = ngx_http_lua_lock_method ; break ; case NGX_HTTP_UNLOCK : sr -> method_name = ngx_http_lua_unlock_method ; break ; case NGX_HTTP_PATCH : sr -> method_name = ngx_http_lua_patch_method ; break ; case NGX_HTTP_TRACE : sr -> method_name = ngx_http_lua_trace_method ; break ; default : ngx_log_error ( NGX_LOG_ERR , r -> connection -> log , 0 , \"unsupported<S2SV_blank>HTTP<S2SV_blank>method:<S2SV_blank>%u\" , ( unsigned ) method ) ; return NGX_ERROR ; } if ( ! ( vars_action & NGX_HTTP_LUA_SHARE_ALL_VARS ) ) { cmcf = ngx_http_get_module_main_conf ( sr , ngx_http_core_module ) ; size = cmcf -> variables . nelts * sizeof ( ngx_http_variable_value_t ) ; if ( vars_action & NGX_HTTP_LUA_COPY_ALL_VARS ) { sr -> variables = ngx_palloc ( sr -> pool , size ) ; if ( sr -> variables == NULL ) { return NGX_ERROR ; } ngx_memcpy ( sr -> variables , r -> variables , size ) ; } else { sr -> variables = ngx_pcalloc ( sr -> pool , size ) ; if ( sr -> variables == NULL ) { return NGX_ERROR ; } } } return ngx_http_lua_subrequest_add_extra_vars ( sr , extra_vars ) ; }\n","target":"<S2SV_ModStart> * r ; <S2SV_ModEnd> ngx_http_core_main_conf_t * cmcf <S2SV_ModStart> * cmcf ; int pr_not_chunked = 0 ; <S2SV_ModStart> = body ; <S2SV_ModEnd> } else if <S2SV_ModStart> 0 ) { sr -> request_body = NULL ; } else { if ( ! r -> headers_in . chunked ) { pr_not_chunked = 1 ; } if ( sr -> request_body && sr -> request_body -> temp_file ) { if ( ngx_http_lua_copy_in_file_request_body ( sr ) <S2SV_ModEnd> != NGX_OK ) <S2SV_ModStart> NGX_ERROR ; } } } <S2SV_ModEnd> if ( ngx_http_lua_copy_request_headers <S2SV_ModStart> sr , r , pr_not_chunked <S2SV_ModStart> return NGX_ERROR ; <S2SV_ModEnd> } sr ->\n","project_and_commit_id":"openresty@lua-nginx-module/9ab38e8ee35fc08a57636b1b6190dca70b0076fa","cve_id":"CVE-2020-11724","original_address":"https://github.com/openresty/lua-nginx-module/commit/9ab38e8ee35fc08a57636b1b6190dca70b0076fa","time":"2020-04-12T21:15Z"},
	{"Unnamed: 0":3559,"cwe_id":"CWE-000","source":"CWE-000 static void setup_token_decoder ( VP8D_COMP * pbi , const unsigned char * token_part_sizes ) { vp8_reader * bool_decoder = & pbi -> mbc [ 0 ] ; unsigned int partition_idx ; unsigned int fragment_idx ; unsigned int num_token_partitions ; const unsigned char * first_fragment_end = pbi -> fragments . ptrs [ 0 ] + pbi -> fragments . sizes [ 0 ] ; TOKEN_PARTITION multi_token_partition = ( TOKEN_PARTITION ) vp8_read_literal ( & pbi -> mbc [ 8 ] , 2 ) ; if ( ! vp8dx_bool_error ( & pbi -> mbc [ 8 ] ) ) pbi -> common . multi_token_partition = multi_token_partition ; num_token_partitions = 1 << pbi -> common . multi_token_partition ; for ( fragment_idx = 0 ; fragment_idx < pbi -> fragments . count ; ++ fragment_idx ) { unsigned int fragment_size = pbi -> fragments . sizes [ fragment_idx ] ; const unsigned char * fragment_end = pbi -> fragments . ptrs [ fragment_idx ] + fragment_size ; if ( fragment_idx == 0 ) { ptrdiff_t ext_first_part_size = token_part_sizes - pbi -> fragments . ptrs [ 0 ] + 3 * ( num_token_partitions - 1 ) ; fragment_size -= ( unsigned int ) ext_first_part_size ; if ( fragment_size > 0 ) { pbi -> fragments . sizes [ 0 ] = ( unsigned int ) ext_first_part_size ; fragment_idx ++ ; pbi -> fragments . ptrs [ fragment_idx ] = pbi -> fragments . ptrs [ 0 ] + pbi -> fragments . sizes [ 0 ] ; } } while ( fragment_size > 0 ) { ptrdiff_t partition_size = read_available_partition_size ( pbi , token_part_sizes , pbi -> fragments . ptrs [ fragment_idx ] , first_fragment_end , fragment_end , fragment_idx - 1 , num_token_partitions ) ; pbi -> fragments . sizes [ fragment_idx ] = ( unsigned int ) partition_size ; fragment_size -= ( unsigned int ) partition_size ; assert ( fragment_idx <= num_token_partitions ) ; if ( fragment_size > 0 ) { fragment_idx ++ ; pbi -> fragments . ptrs [ fragment_idx ] = pbi -> fragments . ptrs [ fragment_idx - 1 ] + partition_size ; } } } pbi -> fragments . count = num_token_partitions + 1 ; for ( partition_idx = 1 ; partition_idx < pbi -> fragments . count ; ++ partition_idx ) { if ( vp8dx_start_decode ( bool_decoder , pbi -> fragments . ptrs [ partition_idx ] , pbi -> fragments . sizes [ partition_idx ] , pbi -> decrypt_cb , pbi -> decrypt_state ) ) vpx_internal_error ( & pbi -> common . error , VPX_CODEC_MEM_ERROR , \"Failed<S2SV_blank>to<S2SV_blank>allocate<S2SV_blank>bool<S2SV_blank>decoder<S2SV_blank>%d\" , partition_idx ) ; bool_decoder ++ ; } # if CONFIG_MULTITHREAD <S2SV_StartBug> if ( pbi -> decoding_thread_count > num_token_partitions - 1 ) <S2SV_EndBug> <S2SV_StartBug> pbi -> decoding_thread_count = num_token_partitions - 1 ; <S2SV_EndBug> # endif }\n","target":"<S2SV_ModStart> - 1 ) { <S2SV_ModStart> - 1 ; } if ( pbi -> decoding_thread_count > pbi -> common . mb_rows - 1 ) { pbi -> decoding_thread_count = pbi -> common . mb_rows - 1 ; }\n","project_and_commit_id":"external@libvpx/6886e8e0a9db2dbad723dc37a548233e004b33bc","cve_id":"CVE-2017-0393","original_address":"https://android.googlesource.com/platform/external/libvpx/+/6886e8e0a9db2dbad723dc37a548233e004b33bc","time":"2017-01-12T20:59Z"},
	{"Unnamed: 0":582,"cwe_id":"CWE-119","source":"CWE-119 static Sdb * store_versioninfo_gnu_verdef ( ELFOBJ * bin , Elf_ ( Shdr ) * shdr , int sz ) { const char * section_name = \"\" ; const char * link_section_name = \"\" ; char * end = NULL ; Elf_ ( Shdr ) * link_shdr = NULL ; ut8 dfs [ sizeof ( Elf_ ( Verdef ) ) ] = { 0 } ; Sdb * sdb ; int cnt , i ; if ( shdr -> sh_link > bin -> ehdr . e_shnum ) { return false ; } link_shdr = & bin -> shdr [ shdr -> sh_link ] ; if ( shdr -> sh_size < 1 ) { return false ; } Elf_ ( Verdef ) * defs = calloc ( shdr -> sh_size , sizeof ( char ) ) ; if ( ! defs ) { return false ; } if ( bin -> shstrtab && shdr -> sh_name < bin -> shstrtab_size ) { section_name = & bin -> shstrtab [ shdr -> sh_name ] ; } if ( link_shdr && bin -> shstrtab && link_shdr -> sh_name < bin -> shstrtab_size ) { link_section_name = & bin -> shstrtab [ link_shdr -> sh_name ] ; } if ( ! defs ) { bprintf ( \"Warning:<S2SV_blank>Cannot<S2SV_blank>allocate<S2SV_blank>memory<S2SV_blank>(Check<S2SV_blank>Elf_(Verdef))\\\\n\" ) ; return NULL ; } sdb = sdb_new0 ( ) ; end = ( char * ) defs + shdr -> sh_size ; sdb_set ( sdb , \"section_name\" , section_name , 0 ) ; sdb_num_set ( sdb , \"entries\" , shdr -> sh_info , 0 ) ; sdb_num_set ( sdb , \"addr\" , shdr -> sh_addr , 0 ) ; sdb_num_set ( sdb , \"offset\" , shdr -> sh_offset , 0 ) ; sdb_num_set ( sdb , \"link\" , shdr -> sh_link , 0 ) ; sdb_set ( sdb , \"link_section_name\" , link_section_name , 0 ) ; <S2SV_StartBug> for ( cnt = 0 , i = 0 ; cnt < shdr -> sh_info && ( ( char * ) defs + i < end ) ; ++ cnt ) { <S2SV_EndBug> Sdb * sdb_verdef = sdb_new0 ( ) ; char * vstart = ( ( char * ) defs ) + i ; char key [ 32 ] = { 0 } ; Elf_ ( Verdef ) * verdef = ( Elf_ ( Verdef ) * ) vstart ; Elf_ ( Verdaux ) aux = { 0 } ; int j = 0 ; int isum = 0 ; r_buf_read_at ( bin -> b , shdr -> sh_offset + i , dfs , sizeof ( Elf_ ( Verdef ) ) ) ; verdef -> vd_version = READ16 ( dfs , j ) verdef -> vd_flags = READ16 ( dfs , j ) verdef -> vd_ndx = READ16 ( dfs , j ) verdef -> vd_cnt = READ16 ( dfs , j ) verdef -> vd_hash = READ32 ( dfs , j ) verdef -> vd_aux = READ32 ( dfs , j ) verdef -> vd_next = READ32 ( dfs , j ) vstart += verdef -> vd_aux ; if ( vstart > end || vstart + sizeof ( Elf_ ( Verdaux ) ) > end ) { sdb_free ( sdb_verdef ) ; goto out_error ; } j = 0 ; aux . vda_name = READ32 ( vstart , j ) aux . vda_next = READ32 ( vstart , j ) isum = i + verdef -> vd_aux ; if ( aux . vda_name > bin -> dynstr_size ) { sdb_free ( sdb_verdef ) ; goto out_error ; } sdb_num_set ( sdb_verdef , \"idx\" , i , 0 ) ; sdb_num_set ( sdb_verdef , \"vd_version\" , verdef -> vd_version , 0 ) ; sdb_num_set ( sdb_verdef , \"vd_ndx\" , verdef -> vd_ndx , 0 ) ; sdb_num_set ( sdb_verdef , \"vd_cnt\" , verdef -> vd_cnt , 0 ) ; sdb_set ( sdb_verdef , \"vda_name\" , & bin -> dynstr [ aux . vda_name ] , 0 ) ; sdb_set ( sdb_verdef , \"flags\" , get_ver_flags ( verdef -> vd_flags ) , 0 ) ; for ( j = 1 ; j < verdef -> vd_cnt ; ++ j ) { int k ; Sdb * sdb_parent = sdb_new0 ( ) ; isum += aux . vda_next ; vstart += aux . vda_next ; if ( vstart > end || vstart + sizeof ( Elf_ ( Verdaux ) ) > end ) { sdb_free ( sdb_verdef ) ; sdb_free ( sdb_parent ) ; goto out_error ; } k = 0 ; aux . vda_name = READ32 ( vstart , k ) aux . vda_next = READ32 ( vstart , k ) if ( aux . vda_name > bin -> dynstr_size ) { sdb_free ( sdb_verdef ) ; sdb_free ( sdb_parent ) ; goto out_error ; } sdb_num_set ( sdb_parent , \"idx\" , isum , 0 ) ; sdb_num_set ( sdb_parent , \"parent\" , j , 0 ) ; sdb_set ( sdb_parent , \"vda_name\" , & bin -> dynstr [ aux . vda_name ] , 0 ) ; snprintf ( key , sizeof ( key ) , \"parent%d\" , j - 1 ) ; sdb_ns_set ( sdb_verdef , key , sdb_parent ) ; } snprintf ( key , sizeof ( key ) , \"verdef%d\" , cnt ) ; sdb_ns_set ( sdb , key , sdb_verdef ) ; if ( ! verdef -> vd_next ) { sdb_free ( sdb_verdef ) ; goto out_error ; } <S2SV_StartBug> i += verdef -> vd_next ; <S2SV_EndBug> } free ( defs ) ; return sdb ; out_error : free ( defs ) ; sdb_free ( sdb ) ; return NULL ; }\n","target":"<S2SV_ModStart> = 0 ; i >= 0 && <S2SV_ModStart> out_error ; } if ( ( st32 ) verdef -> vd_next < 1 ) { eprintf ( \"Warning:<S2SV_blank>Invalid<S2SV_blank>vd_next<S2SV_blank>in<S2SV_blank>the<S2SV_blank>ELF<S2SV_blank>version\\\\n\" ) ; break ; }\n","project_and_commit_id":"radare@radare2/21a6f570ba33fa9f52f1bba87f07acc4e8c178f4","cve_id":"CVE-2017-15385","original_address":"https://github.com/radare/radare2/commit/21a6f570ba33fa9f52f1bba87f07acc4e8c178f4","time":"2017-10-16T22:29Z"},
	{"Unnamed: 0":4018,"cwe_id":"CWE-254","source":"CWE-254 void impeg2d_peek_next_start_code ( dec_state_t * ps_dec ) { stream_t * ps_stream ; ps_stream = & ps_dec -> s_bit_stream ; impeg2d_bit_stream_flush_to_byte_boundary ( ps_stream ) ; while ( ( impeg2d_bit_stream_nxt ( ps_stream , START_CODE_PREFIX_LEN ) != START_CODE_PREFIX ) <S2SV_StartBug> && ( ps_dec -> s_bit_stream . u4_offset <= ps_dec -> s_bit_stream . u4_max_offset ) ) <S2SV_EndBug> { impeg2d_bit_stream_get ( ps_stream , 8 ) ; } return ; }\n","target":"<S2SV_ModStart> s_bit_stream . u4_offset < <S2SV_ModEnd> ps_dec -> s_bit_stream\n","project_and_commit_id":"external@libmpeg2/ffab15eb80630dc799eb410855c93525b75233c3","cve_id":"CVE-2016-0824","original_address":"https://android.googlesource.com/platform/external/libmpeg2/+/ffab15eb80630dc799eb410855c93525b75233c3","time":"2016-03-12T21:59Z"},
	{"Unnamed: 0":4535,"cwe_id":"CWE-416","source":"CWE-416 int __mdiobus_register ( struct mii_bus * bus , struct module * owner ) { struct mdio_device * mdiodev ; int i , err ; struct gpio_desc * gpiod ; if ( NULL == bus || NULL == bus -> name || NULL == bus -> read || NULL == bus -> write ) return - EINVAL ; BUG_ON ( bus -> state != MDIOBUS_ALLOCATED && bus -> state != MDIOBUS_UNREGISTERED ) ; bus -> owner = owner ; bus -> dev . parent = bus -> parent ; bus -> dev . class = & mdio_bus_class ; bus -> dev . groups = NULL ; dev_set_name ( & bus -> dev , \"%s\" , bus -> id ) ; err = device_register ( & bus -> dev ) ; if ( err ) { pr_err ( \"mii_bus<S2SV_blank>%s<S2SV_blank>failed<S2SV_blank>to<S2SV_blank>register\\\\n\" , bus -> id ) ; <S2SV_StartBug> put_device ( & bus -> dev ) ; <S2SV_EndBug> return - EINVAL ; } mutex_init ( & bus -> mdio_lock ) ; gpiod = devm_gpiod_get_optional ( & bus -> dev , \"reset\" , GPIOD_OUT_LOW ) ; if ( IS_ERR ( gpiod ) ) { dev_err ( & bus -> dev , \"mii_bus<S2SV_blank>%s<S2SV_blank>couldn\\'t<S2SV_blank>get<S2SV_blank>reset<S2SV_blank>GPIO\\\\n\" , bus -> id ) ; device_del ( & bus -> dev ) ; return PTR_ERR ( gpiod ) ; } else if ( gpiod ) { bus -> reset_gpiod = gpiod ; gpiod_set_value_cansleep ( gpiod , 1 ) ; udelay ( bus -> reset_delay_us ) ; gpiod_set_value_cansleep ( gpiod , 0 ) ; } if ( bus -> reset ) bus -> reset ( bus ) ; for ( i = 0 ; i < PHY_MAX_ADDR ; i ++ ) { if ( ( bus -> phy_mask & ( 1 << i ) ) == 0 ) { struct phy_device * phydev ; phydev = mdiobus_scan ( bus , i ) ; if ( IS_ERR ( phydev ) && ( PTR_ERR ( phydev ) != - ENODEV ) ) { err = PTR_ERR ( phydev ) ; goto error ; } } } mdiobus_setup_mdiodev_from_board_info ( bus , mdiobus_create_device ) ; bus -> state = MDIOBUS_REGISTERED ; pr_info ( \"%s:<S2SV_blank>probed\\\\n\" , bus -> name ) ; return 0 ; error : while ( -- i >= 0 ) { mdiodev = bus -> mdio_map [ i ] ; if ( ! mdiodev ) continue ; mdiodev -> device_remove ( mdiodev ) ; mdiodev -> device_free ( mdiodev ) ; } if ( bus -> reset_gpiod ) gpiod_set_value_cansleep ( bus -> reset_gpiod , 1 ) ; device_del ( & bus -> dev ) ; return err ; }\n","target":"<S2SV_ModStart> id ) ; <S2SV_ModEnd> return - EINVAL\n","project_and_commit_id":"torvalds@linux/6ff7b060535e87c2ae14dd8548512abfdda528fb","cve_id":"CVE-2019-12819","original_address":"https://github.com/torvalds/linux/commit/6ff7b060535e87c2ae14dd8548512abfdda528fb","time":"2019-06-14T02:29Z"},
	{"Unnamed: 0":6300,"cwe_id":"CWE-000","source":"CWE-000 static int handle_wrmsr ( struct kvm_vcpu * vcpu ) { struct msr_data msr ; u32 ecx = vcpu -> arch . regs [ VCPU_REGS_RCX ] ; u64 data = ( vcpu -> arch . regs [ VCPU_REGS_RAX ] & - 1u ) | ( ( u64 ) ( vcpu -> arch . regs [ VCPU_REGS_RDX ] & - 1u ) << 32 ) ; msr . data = data ; msr . index = ecx ; msr . host_initiated = false ; <S2SV_StartBug> if ( vmx_set_msr ( vcpu , & msr ) != 0 ) { <S2SV_EndBug> trace_kvm_msr_write_ex ( ecx , data ) ; kvm_inject_gp ( vcpu , 0 ) ; return 1 ; } trace_kvm_msr_write ( ecx , data ) ; skip_emulated_instruction ( vcpu ) ; return 1 ; }\n","target":"<S2SV_ModStart> ; if ( kvm_set_msr <S2SV_ModEnd> ( vcpu ,\n","project_and_commit_id":"torvalds@linux/854e8bb1aa06c578c2c9145fa6bfe3680ef63b23","cve_id":"CVE-2014-3610","original_address":"https://github.com/torvalds/linux/commit/854e8bb1aa06c578c2c9145fa6bfe3680ef63b23","time":"2014-11-10T11:55Z"},
	{"Unnamed: 0":5902,"cwe_id":"CWE-362","source":"CWE-362 static int newseg ( struct ipc_namespace * ns , struct ipc_params * params ) { key_t key = params -> key ; int shmflg = params -> flg ; size_t size = params -> u . size ; int error ; struct shmid_kernel * shp ; size_t numpages = ( size + PAGE_SIZE - 1 ) >> PAGE_SHIFT ; struct file * file ; char name [ 13 ] ; int id ; vm_flags_t acctflag = 0 ; if ( size < SHMMIN || size > ns -> shm_ctlmax ) return - EINVAL ; if ( numpages << PAGE_SHIFT < size ) return - ENOSPC ; if ( ns -> shm_tot + numpages < ns -> shm_tot || ns -> shm_tot + numpages > ns -> shm_ctlall ) return - ENOSPC ; shp = ipc_rcu_alloc ( sizeof ( * shp ) ) ; if ( ! shp ) return - ENOMEM ; shp -> shm_perm . key = key ; shp -> shm_perm . mode = ( shmflg & S_IRWXUGO ) ; shp -> mlock_user = NULL ; shp -> shm_perm . security = NULL ; error = security_shm_alloc ( shp ) ; if ( error ) { ipc_rcu_putref ( shp , ipc_rcu_free ) ; return error ; } sprintf ( name , \"SYSV%08x\" , key ) ; if ( shmflg & SHM_HUGETLB ) { struct hstate * hs ; size_t hugesize ; hs = hstate_sizelog ( ( shmflg >> SHM_HUGE_SHIFT ) & SHM_HUGE_MASK ) ; if ( ! hs ) { error = - EINVAL ; goto no_file ; } hugesize = ALIGN ( size , huge_page_size ( hs ) ) ; if ( shmflg & SHM_NORESERVE ) acctflag = VM_NORESERVE ; file = hugetlb_file_setup ( name , hugesize , acctflag , & shp -> mlock_user , HUGETLB_SHMFS_INODE , ( shmflg >> SHM_HUGE_SHIFT ) & SHM_HUGE_MASK ) ; } else { if ( ( shmflg & SHM_NORESERVE ) && sysctl_overcommit_memory != OVERCOMMIT_NEVER ) acctflag = VM_NORESERVE ; file = shmem_kernel_file_setup ( name , size , acctflag ) ; } error = PTR_ERR ( file ) ; if ( IS_ERR ( file ) ) goto no_file ; <S2SV_StartBug> id = ipc_addid ( & shm_ids ( ns ) , & shp -> shm_perm , ns -> shm_ctlmni ) ; <S2SV_EndBug> if ( id < 0 ) { error = id ; goto no_id ; } <S2SV_StartBug> shp -> shm_cprid = task_tgid_vnr ( current ) ; <S2SV_EndBug> shp -> shm_lprid = 0 ; shp -> shm_atim = shp -> shm_dtim = 0 ; shp -> shm_ctim = get_seconds ( ) ; shp -> shm_segsz = size ; shp -> shm_nattch = 0 ; shp -> shm_file = file ; shp -> shm_creator = current ; list_add ( & shp -> shm_clist , & current -> sysvshm . shm_clist ) ; file_inode ( file ) -> i_ino = shp -> shm_perm . id ; ns -> shm_tot += numpages ; error = shp -> shm_perm . id ; ipc_unlock_object ( & shp -> shm_perm ) ; rcu_read_unlock ( ) ; return error ; no_id : if ( is_file_hugepages ( file ) && shp -> mlock_user ) user_shm_unlock ( size , shp -> mlock_user ) ; fput ( file ) ; no_file : ipc_rcu_putref ( shp , shm_rcu_free ) ; return error ; }\n","target":"<S2SV_ModStart> goto no_file ; shp -> shm_cprid = task_tgid_vnr ( current ) ; shp -> shm_lprid = 0 ; shp -> shm_atim = shp -> shm_dtim = 0 ; shp -> shm_ctim = get_seconds ( ) ; shp -> shm_segsz = size ; shp -> shm_nattch = 0 ; shp -> shm_file = file ; shp -> shm_creator = current ; <S2SV_ModStart> no_id ; } <S2SV_ModEnd> list_add ( &\n","project_and_commit_id":"torvalds@linux/b9a532277938798b53178d5a66af6e2915cb27cf","cve_id":"CVE-2015-7613","original_address":"https://github.com/torvalds/linux/commit/b9a532277938798b53178d5a66af6e2915cb27cf","time":"2015-10-19T10:59Z"},
	{"Unnamed: 0":3708,"cwe_id":"CWE-362","source":"CWE-362 static int snd_timer_user_tselect ( struct file * file , struct snd_timer_select __user * _tselect ) { struct snd_timer_user * tu ; struct snd_timer_select tselect ; char str [ 32 ] ; int err = 0 ; tu = file -> private_data ; <S2SV_StartBug> mutex_lock ( & tu -> tread_sem ) ; <S2SV_EndBug> if ( tu -> timeri ) { snd_timer_close ( tu -> timeri ) ; tu -> timeri = NULL ; } if ( copy_from_user ( & tselect , _tselect , sizeof ( tselect ) ) ) { err = - EFAULT ; goto __err ; } sprintf ( str , \"application<S2SV_blank>%i\" , current -> pid ) ; if ( tselect . id . dev_class != SNDRV_TIMER_CLASS_SLAVE ) tselect . id . dev_sclass = SNDRV_TIMER_SCLASS_APPLICATION ; err = snd_timer_open ( & tu -> timeri , str , & tselect . id , current -> pid ) ; if ( err < 0 ) goto __err ; kfree ( tu -> queue ) ; tu -> queue = NULL ; kfree ( tu -> tqueue ) ; tu -> tqueue = NULL ; if ( tu -> tread ) { tu -> tqueue = kmalloc ( tu -> queue_size * sizeof ( struct snd_timer_tread ) , GFP_KERNEL ) ; if ( tu -> tqueue == NULL ) err = - ENOMEM ; } else { tu -> queue = kmalloc ( tu -> queue_size * sizeof ( struct snd_timer_read ) , GFP_KERNEL ) ; if ( tu -> queue == NULL ) err = - ENOMEM ; } if ( err < 0 ) { snd_timer_close ( tu -> timeri ) ; tu -> timeri = NULL ; } else { tu -> timeri -> flags |= SNDRV_TIMER_IFLG_FAST ; tu -> timeri -> callback = tu -> tread ? snd_timer_user_tinterrupt : snd_timer_user_interrupt ; tu -> timeri -> ccallback = snd_timer_user_ccallback ; tu -> timeri -> callback_data = ( void * ) tu ; } __err : <S2SV_StartBug> mutex_unlock ( & tu -> tread_sem ) ; <S2SV_EndBug> return err ; }\n","target":"<S2SV_ModStart> -> private_data ; <S2SV_ModEnd> if ( tu <S2SV_ModStart> } __err : <S2SV_ModEnd> return err ;\n","project_and_commit_id":"torvalds@linux/af368027a49a751d6ff4ee9e3f9961f35bb4fede","cve_id":"CVE-2016-2546","original_address":"https://github.com/torvalds/linux/commit/af368027a49a751d6ff4ee9e3f9961f35bb4fede","time":"2016-04-27T17:59Z"},
	{"Unnamed: 0":6413,"cwe_id":"CWE-000","source":"CWE-000 int sqlite3Select ( Parse * pParse , Select * p , SelectDest * pDest ) { int i , j ; WhereInfo * pWInfo ; Vdbe * v ; int isAgg ; ExprList * pEList = 0 ; SrcList * pTabList ; Expr * pWhere ; ExprList * pGroupBy ; Expr * pHaving ; int rc = 1 ; DistinctCtx sDistinct ; SortCtx sSort ; AggInfo sAggInfo ; int iEnd ; sqlite3 * db ; ExprList * pMinMaxOrderBy = 0 ; u8 minMaxFlag ; db = pParse -> db ; v = sqlite3GetVdbe ( pParse ) ; if ( p == 0 || db -> mallocFailed || pParse -> nErr ) { return 1 ; } if ( sqlite3AuthCheck ( pParse , SQLITE_SELECT , 0 , 0 , 0 ) ) return 1 ; memset ( & sAggInfo , 0 , sizeof ( sAggInfo ) ) ; # if SELECTTRACE_ENABLED SELECTTRACE ( 1 , pParse , p , ( \"begin<S2SV_blank>processing:\\\\n\" , pParse -> addrExplain ) ) ; if ( sqlite3SelectTrace & 0x100 ) { sqlite3TreeViewSelect ( 0 , p , 0 ) ; } # endif assert ( p -> pOrderBy == 0 || pDest -> eDest != SRT_DistFifo ) ; assert ( p -> pOrderBy == 0 || pDest -> eDest != SRT_Fifo ) ; assert ( p -> pOrderBy == 0 || pDest -> eDest != SRT_DistQueue ) ; assert ( p -> pOrderBy == 0 || pDest -> eDest != SRT_Queue ) ; if ( IgnorableOrderby ( pDest ) ) { assert ( pDest -> eDest == SRT_Exists || pDest -> eDest == SRT_Union || pDest -> eDest == SRT_Except || pDest -> eDest == SRT_Discard || pDest -> eDest == SRT_Queue || pDest -> eDest == SRT_DistFifo || pDest -> eDest == SRT_DistQueue || pDest -> eDest == SRT_Fifo ) ; sqlite3ExprListDelete ( db , p -> pOrderBy ) ; p -> pOrderBy = 0 ; p -> selFlags &= ~ SF_Distinct ; } sqlite3SelectPrep ( pParse , p , 0 ) ; if ( pParse -> nErr || db -> mallocFailed ) { goto select_end ; } assert ( p -> pEList != 0 ) ; # if SELECTTRACE_ENABLED if ( sqlite3SelectTrace & 0x104 ) { SELECTTRACE ( 0x104 , pParse , p , ( \"after<S2SV_blank>name<S2SV_blank>resolution:\\\\n\" ) ) ; sqlite3TreeViewSelect ( 0 , p , 0 ) ; } # endif if ( pDest -> eDest == SRT_Output ) { generateColumnNames ( pParse , p ) ; } # ifndef SQLITE_OMIT_WINDOWFUNC if ( sqlite3WindowRewrite ( pParse , p ) ) { goto select_end ; } # if SELECTTRACE_ENABLED if ( p -> pWin && ( sqlite3SelectTrace & 0x108 ) != 0 ) { SELECTTRACE ( 0x104 , pParse , p , ( \"after<S2SV_blank>window<S2SV_blank>rewrite:\\\\n\" ) ) ; sqlite3TreeViewSelect ( 0 , p , 0 ) ; } # endif # endif pTabList = p -> pSrc ; isAgg = ( p -> selFlags & SF_Aggregate ) != 0 ; memset ( & sSort , 0 , sizeof ( sSort ) ) ; sSort . pOrderBy = p -> pOrderBy ; # if ! defined ( SQLITE_OMIT_SUBQUERY ) || ! defined ( SQLITE_OMIT_VIEW ) for ( i = 0 ; ! p -> pPrior && i < pTabList -> nSrc ; i ++ ) { struct SrcList_item * pItem = & pTabList -> a [ i ] ; Select * pSub = pItem -> pSelect ; Table * pTab = pItem -> pTab ; if ( ( pItem -> fg . jointype & JT_LEFT ) != 0 && sqlite3ExprImpliesNonNullRow ( p -> pWhere , pItem -> iCursor ) && OptimizationEnabled ( db , SQLITE_SimplifyJoin ) ) { SELECTTRACE ( 0x100 , pParse , p , ( \"LEFT-JOIN<S2SV_blank>simplifies<S2SV_blank>to<S2SV_blank>JOIN<S2SV_blank>on<S2SV_blank>term<S2SV_blank>%d\\\\n\" , i ) ) ; pItem -> fg . jointype &= ~ ( JT_LEFT | JT_OUTER ) ; unsetJoinExpr ( p -> pWhere , pItem -> iCursor ) ; } if ( pSub == 0 ) continue ; if ( pTab -> nCol != pSub -> pEList -> nExpr ) { sqlite3ErrorMsg ( pParse , \"expected<S2SV_blank>%d<S2SV_blank>columns<S2SV_blank>for<S2SV_blank>\\'%s\\'<S2SV_blank>but<S2SV_blank>got<S2SV_blank>%d\" , pTab -> nCol , pTab -> zName , pSub -> pEList -> nExpr ) ; goto select_end ; } if ( ( pSub -> selFlags & SF_Aggregate ) != 0 ) continue ; assert ( pSub -> pGroupBy == 0 ) ; if ( pSub -> pOrderBy != 0 && i == 0 && ( p -> selFlags & SF_ComplexResult ) != 0 && ( pTabList -> nSrc == 1 || ( pTabList -> a [ 1 ] . fg . jointype & ( JT_LEFT | JT_CROSS ) ) != 0 ) ) { continue ; } if ( flattenSubquery ( pParse , p , i , isAgg ) ) { if ( pParse -> nErr ) goto select_end ; i = - 1 ; } pTabList = p -> pSrc ; if ( db -> mallocFailed ) goto select_end ; if ( ! IgnorableOrderby ( pDest ) ) { sSort . pOrderBy = p -> pOrderBy ; } } # endif # ifndef SQLITE_OMIT_COMPOUND_SELECT if ( p -> pPrior ) { rc = multiSelect ( pParse , p , pDest ) ; # if SELECTTRACE_ENABLED SELECTTRACE ( 0x1 , pParse , p , ( \"end<S2SV_blank>compound-select<S2SV_blank>processing\\\\n\" ) ) ; if ( ( sqlite3SelectTrace & 0x2000 ) != 0 && ExplainQueryPlanParent ( pParse ) == 0 ) { sqlite3TreeViewSelect ( 0 , p , 0 ) ; } # endif if ( p -> pNext == 0 ) ExplainQueryPlanPop ( pParse ) ; return rc ; } # endif if ( pTabList -> nSrc > 1 && OptimizationEnabled ( db , SQLITE_PropagateConst ) && propagateConstants ( pParse , p ) ) { # if SELECTTRACE_ENABLED if ( sqlite3SelectTrace & 0x100 ) { SELECTTRACE ( 0x100 , pParse , p , ( \"After<S2SV_blank>constant<S2SV_blank>propagation:\\\\n\" ) ) ; sqlite3TreeViewSelect ( 0 , p , 0 ) ; } # endif } else { SELECTTRACE ( 0x100 , pParse , p , ( \"Constant<S2SV_blank>propagation<S2SV_blank>not<S2SV_blank>helpful\\\\n\" ) ) ; } # ifdef SQLITE_COUNTOFVIEW_OPTIMIZATION if ( OptimizationEnabled ( db , SQLITE_QueryFlattener | SQLITE_CountOfView ) && countOfViewOptimization ( pParse , p ) ) { if ( db -> mallocFailed ) goto select_end ; pEList = p -> pEList ; pTabList = p -> pSrc ; } # endif for ( i = 0 ; i < pTabList -> nSrc ; i ++ ) { struct SrcList_item * pItem = & pTabList -> a [ i ] ; SelectDest dest ; Select * pSub ; # if ! defined ( SQLITE_OMIT_SUBQUERY ) || ! defined ( SQLITE_OMIT_VIEW ) const char * zSavedAuthContext ; # endif if ( pItem -> colUsed == 0 && pItem -> zName != 0 ) { sqlite3AuthCheck ( pParse , SQLITE_READ , pItem -> zName , \"\" , pItem -> zDatabase ) ; } # if ! defined ( SQLITE_OMIT_SUBQUERY ) || ! defined ( SQLITE_OMIT_VIEW ) pSub = pItem -> pSelect ; if ( pSub == 0 ) continue ; testcase ( pItem -> addrFillSub != 0 ) ; pParse -> nHeight += sqlite3SelectExprHeight ( p ) ; if ( OptimizationEnabled ( db , SQLITE_PushDown ) && pushDownWhereTerms ( pParse , pSub , p -> pWhere , pItem -> iCursor , ( pItem -> fg . jointype & JT_OUTER ) != 0 ) ) { # if SELECTTRACE_ENABLED if ( sqlite3SelectTrace & 0x100 ) { SELECTTRACE ( 0x100 , pParse , p , ( \"After<S2SV_blank>WHERE-clause<S2SV_blank>push-down<S2SV_blank>into<S2SV_blank>subquery<S2SV_blank>%d:\\\\n\" , pSub -> selId ) ) ; sqlite3TreeViewSelect ( 0 , p , 0 ) ; } # endif } else { SELECTTRACE ( 0x100 , pParse , p , ( \"Push-down<S2SV_blank>not<S2SV_blank>possible\\\\n\" ) ) ; } zSavedAuthContext = pParse -> zAuthContext ; pParse -> zAuthContext = pItem -> zName ; if ( i == 0 && ( pTabList -> nSrc == 1 || ( pTabList -> a [ 1 ] . fg . jointype & ( JT_LEFT | JT_CROSS ) ) != 0 ) ) { int addrTop = sqlite3VdbeCurrentAddr ( v ) + 1 ; pItem -> regReturn = ++ pParse -> nMem ; sqlite3VdbeAddOp3 ( v , OP_InitCoroutine , pItem -> regReturn , 0 , addrTop ) ; VdbeComment ( ( v , \"%s\" , pItem -> pTab -> zName ) ) ; pItem -> addrFillSub = addrTop ; sqlite3SelectDestInit ( & dest , SRT_Coroutine , pItem -> regReturn ) ; ExplainQueryPlan ( ( pParse , 1 , \"CO-ROUTINE<S2SV_blank>%u\" , pSub -> selId ) ) ; sqlite3Select ( pParse , pSub , & dest ) ; pItem -> pTab -> nRowLogEst = pSub -> nSelectRow ; pItem -> fg . viaCoroutine = 1 ; pItem -> regResult = dest . iSdst ; sqlite3VdbeEndCoroutine ( v , pItem -> regReturn ) ; sqlite3VdbeJumpHere ( v , addrTop - 1 ) ; sqlite3ClearTempRegCache ( pParse ) ; } else { int topAddr ; int onceAddr = 0 ; int retAddr ; struct SrcList_item * pPrior ; testcase ( pItem -> addrFillSub == 0 ) ; pItem -> regReturn = ++ pParse -> nMem ; topAddr = sqlite3VdbeAddOp2 ( v , OP_Integer , 0 , pItem -> regReturn ) ; pItem -> addrFillSub = topAddr + 1 ; if ( pItem -> fg . isCorrelated == 0 ) { onceAddr = sqlite3VdbeAddOp0 ( v , OP_Once ) ; VdbeCoverage ( v ) ; VdbeComment ( ( v , \"materialize<S2SV_blank>\\\\\"%s\\\\\"\" , pItem -> pTab -> zName ) ) ; } else { VdbeNoopComment ( ( v , \"materialize<S2SV_blank>\\\\\"%s\\\\\"\" , pItem -> pTab -> zName ) ) ; } pPrior = isSelfJoinView ( pTabList , pItem ) ; if ( pPrior ) { sqlite3VdbeAddOp2 ( v , OP_OpenDup , pItem -> iCursor , pPrior -> iCursor ) ; assert ( pPrior -> pSelect != 0 ) ; pSub -> nSelectRow = pPrior -> pSelect -> nSelectRow ; } else { sqlite3SelectDestInit ( & dest , SRT_EphemTab , pItem -> iCursor ) ; ExplainQueryPlan ( ( pParse , 1 , \"MATERIALIZE<S2SV_blank>%u\" , pSub -> selId ) ) ; sqlite3Select ( pParse , pSub , & dest ) ; } pItem -> pTab -> nRowLogEst = pSub -> nSelectRow ; if ( onceAddr ) sqlite3VdbeJumpHere ( v , onceAddr ) ; retAddr = sqlite3VdbeAddOp1 ( v , OP_Return , pItem -> regReturn ) ; VdbeComment ( ( v , \"end<S2SV_blank>%s\" , pItem -> pTab -> zName ) ) ; sqlite3VdbeChangeP1 ( v , topAddr , retAddr ) ; sqlite3ClearTempRegCache ( pParse ) ; } if ( db -> mallocFailed ) goto select_end ; pParse -> nHeight -= sqlite3SelectExprHeight ( p ) ; pParse -> zAuthContext = zSavedAuthContext ; # endif } pEList = p -> pEList ; pWhere = p -> pWhere ; pGroupBy = p -> pGroupBy ; pHaving = p -> pHaving ; sDistinct . isTnct = ( p -> selFlags & SF_Distinct ) != 0 ; # if SELECTTRACE_ENABLED if ( sqlite3SelectTrace & 0x400 ) { SELECTTRACE ( 0x400 , pParse , p , ( \"After<S2SV_blank>all<S2SV_blank>FROM-clause<S2SV_blank>analysis:\\\\n\" ) ) ; sqlite3TreeViewSelect ( 0 , p , 0 ) ; } # endif if ( ( p -> selFlags & ( SF_Distinct | SF_Aggregate ) ) == SF_Distinct && sqlite3ExprListCompare ( sSort . pOrderBy , pEList , - 1 ) == 0 <S2SV_StartBug> ) { <S2SV_EndBug> p -> selFlags &= ~ SF_Distinct ; pGroupBy = p -> pGroupBy = sqlite3ExprListDup ( db , pEList , 0 ) ; assert ( sDistinct . isTnct ) ; # if SELECTTRACE_ENABLED if ( sqlite3SelectTrace & 0x400 ) { SELECTTRACE ( 0x400 , pParse , p , ( \"Transform<S2SV_blank>DISTINCT<S2SV_blank>into<S2SV_blank>GROUP<S2SV_blank>BY:\\\\n\" ) ) ; sqlite3TreeViewSelect ( 0 , p , 0 ) ; } # endif } if ( sSort . pOrderBy ) { KeyInfo * pKeyInfo ; pKeyInfo = sqlite3KeyInfoFromExprList ( pParse , sSort . pOrderBy , 0 , pEList -> nExpr ) ; sSort . iECursor = pParse -> nTab ++ ; sSort . addrSortIndex = sqlite3VdbeAddOp4 ( v , OP_OpenEphemeral , sSort . iECursor , sSort . pOrderBy -> nExpr + 1 + pEList -> nExpr , 0 , ( char * ) pKeyInfo , P4_KEYINFO ) ; } else { sSort . addrSortIndex = - 1 ; } if ( pDest -> eDest == SRT_EphemTab ) { sqlite3VdbeAddOp2 ( v , OP_OpenEphemeral , pDest -> iSDParm , pEList -> nExpr ) ; } iEnd = sqlite3VdbeMakeLabel ( pParse ) ; if ( ( p -> selFlags & SF_FixedLimit ) == 0 ) { p -> nSelectRow = 320 ; } computeLimitRegisters ( pParse , p , iEnd ) ; if ( p -> iLimit == 0 && sSort . addrSortIndex >= 0 ) { sqlite3VdbeChangeOpcode ( v , sSort . addrSortIndex , OP_SorterOpen ) ; sSort . sortFlags |= SORTFLAG_UseSorter ; } if ( p -> selFlags & SF_Distinct ) { sDistinct . tabTnct = pParse -> nTab ++ ; sDistinct . addrTnct = sqlite3VdbeAddOp4 ( v , OP_OpenEphemeral , sDistinct . tabTnct , 0 , 0 , ( char * ) sqlite3KeyInfoFromExprList ( pParse , p -> pEList , 0 , 0 ) , P4_KEYINFO ) ; sqlite3VdbeChangeP5 ( v , BTREE_UNORDERED ) ; sDistinct . eTnctType = WHERE_DISTINCT_UNORDERED ; } else { sDistinct . eTnctType = WHERE_DISTINCT_NOOP ; } if ( ! isAgg && pGroupBy == 0 ) { u16 wctrlFlags = ( sDistinct . isTnct ? WHERE_WANT_DISTINCT : 0 ) | ( p -> selFlags & SF_FixedLimit ) ; # ifndef SQLITE_OMIT_WINDOWFUNC Window * pWin = p -> pWin ; if ( pWin ) { sqlite3WindowCodeInit ( pParse , pWin ) ; } # endif assert ( WHERE_USE_LIMIT == SF_FixedLimit ) ; SELECTTRACE ( 1 , pParse , p , ( \"WhereBegin\\\\n\" ) ) ; pWInfo = sqlite3WhereBegin ( pParse , pTabList , pWhere , sSort . pOrderBy , p -> pEList , wctrlFlags , p -> nSelectRow ) ; if ( pWInfo == 0 ) goto select_end ; if ( sqlite3WhereOutputRowCount ( pWInfo ) < p -> nSelectRow ) { p -> nSelectRow = sqlite3WhereOutputRowCount ( pWInfo ) ; } if ( sDistinct . isTnct && sqlite3WhereIsDistinct ( pWInfo ) ) { sDistinct . eTnctType = sqlite3WhereIsDistinct ( pWInfo ) ; } if ( sSort . pOrderBy ) { sSort . nOBSat = sqlite3WhereIsOrdered ( pWInfo ) ; sSort . labelOBLopt = sqlite3WhereOrderByLimitOptLabel ( pWInfo ) ; if ( sSort . nOBSat == sSort . pOrderBy -> nExpr ) { sSort . pOrderBy = 0 ; } } if ( sSort . addrSortIndex >= 0 && sSort . pOrderBy == 0 ) { sqlite3VdbeChangeToNoop ( v , sSort . addrSortIndex ) ; } assert ( p -> pEList == pEList ) ; # ifndef SQLITE_OMIT_WINDOWFUNC if ( pWin ) { int addrGosub = sqlite3VdbeMakeLabel ( pParse ) ; int iCont = sqlite3VdbeMakeLabel ( pParse ) ; int iBreak = sqlite3VdbeMakeLabel ( pParse ) ; int regGosub = ++ pParse -> nMem ; sqlite3WindowCodeStep ( pParse , p , pWInfo , regGosub , addrGosub ) ; sqlite3VdbeAddOp2 ( v , OP_Goto , 0 , iBreak ) ; sqlite3VdbeResolveLabel ( v , addrGosub ) ; VdbeNoopComment ( ( v , \"inner-loop<S2SV_blank>subroutine\" ) ) ; sSort . labelOBLopt = 0 ; selectInnerLoop ( pParse , p , - 1 , & sSort , & sDistinct , pDest , iCont , iBreak ) ; sqlite3VdbeResolveLabel ( v , iCont ) ; sqlite3VdbeAddOp1 ( v , OP_Return , regGosub ) ; VdbeComment ( ( v , \"end<S2SV_blank>inner-loop<S2SV_blank>subroutine\" ) ) ; sqlite3VdbeResolveLabel ( v , iBreak ) ; } else # endif { selectInnerLoop ( pParse , p , - 1 , & sSort , & sDistinct , pDest , sqlite3WhereContinueLabel ( pWInfo ) , sqlite3WhereBreakLabel ( pWInfo ) ) ; sqlite3WhereEnd ( pWInfo ) ; } } else { NameContext sNC ; int iAMem ; int iBMem ; int iUseFlag ; int iAbortFlag ; int groupBySort ; int addrEnd ; int sortPTab = 0 ; int sortOut = 0 ; int orderByGrp = 0 ; if ( pGroupBy ) { int k ; struct ExprList_item * pItem ; for ( k = p -> pEList -> nExpr , pItem = p -> pEList -> a ; k > 0 ; k -- , pItem ++ ) { pItem -> u . x . iAlias = 0 ; } for ( k = pGroupBy -> nExpr , pItem = pGroupBy -> a ; k > 0 ; k -- , pItem ++ ) { pItem -> u . x . iAlias = 0 ; } assert ( 66 == sqlite3LogEst ( 100 ) ) ; if ( p -> nSelectRow > 66 ) p -> nSelectRow = 66 ; if ( sSort . pOrderBy && pGroupBy -> nExpr == sSort . pOrderBy -> nExpr ) { int ii ; for ( ii = 0 ; ii < pGroupBy -> nExpr ; ii ++ ) { u8 sortFlags = sSort . pOrderBy -> a [ ii ] . sortFlags & KEYINFO_ORDER_DESC ; pGroupBy -> a [ ii ] . sortFlags = sortFlags ; } if ( sqlite3ExprListCompare ( pGroupBy , sSort . pOrderBy , - 1 ) == 0 ) { orderByGrp = 1 ; } } } else { assert ( 0 == sqlite3LogEst ( 1 ) ) ; p -> nSelectRow = 0 ; } addrEnd = sqlite3VdbeMakeLabel ( pParse ) ; memset ( & sNC , 0 , sizeof ( sNC ) ) ; sNC . pParse = pParse ; sNC . pSrcList = pTabList ; sNC . uNC . pAggInfo = & sAggInfo ; VVA_ONLY ( sNC . ncFlags = NC_UAggInfo ; ) sAggInfo . mnReg = pParse -> nMem + 1 ; sAggInfo . nSortingColumn = pGroupBy ? pGroupBy -> nExpr : 0 ; sAggInfo . pGroupBy = pGroupBy ; sqlite3ExprAnalyzeAggList ( & sNC , pEList ) ; sqlite3ExprAnalyzeAggList ( & sNC , sSort . pOrderBy ) ; if ( pHaving ) { if ( pGroupBy ) { assert ( pWhere == p -> pWhere ) ; assert ( pHaving == p -> pHaving ) ; assert ( pGroupBy == p -> pGroupBy ) ; havingToWhere ( pParse , p ) ; pWhere = p -> pWhere ; } sqlite3ExprAnalyzeAggregates ( & sNC , pHaving ) ; } sAggInfo . nAccumulator = sAggInfo . nColumn ; if ( p -> pGroupBy == 0 && p -> pHaving == 0 && sAggInfo . nFunc == 1 ) { minMaxFlag = minMaxQuery ( db , sAggInfo . aFunc [ 0 ] . pExpr , & pMinMaxOrderBy ) ; } else { minMaxFlag = WHERE_ORDERBY_NORMAL ; } for ( i = 0 ; i < sAggInfo . nFunc ; i ++ ) { Expr * pExpr = sAggInfo . aFunc [ i ] . pExpr ; assert ( ! ExprHasProperty ( pExpr , EP_xIsSelect ) ) ; sNC . ncFlags |= NC_InAggFunc ; sqlite3ExprAnalyzeAggList ( & sNC , pExpr -> x . pList ) ; # ifndef SQLITE_OMIT_WINDOWFUNC assert ( ! IsWindowFunc ( pExpr ) ) ; if ( ExprHasProperty ( pExpr , EP_WinFunc ) ) { sqlite3ExprAnalyzeAggregates ( & sNC , pExpr -> y . pWin -> pFilter ) ; } # endif sNC . ncFlags &= ~ NC_InAggFunc ; } sAggInfo . mxReg = pParse -> nMem ; if ( db -> mallocFailed ) goto select_end ; # if SELECTTRACE_ENABLED if ( sqlite3SelectTrace & 0x400 ) { int ii ; SELECTTRACE ( 0x400 , pParse , p , ( \"After<S2SV_blank>aggregate<S2SV_blank>analysis:\\\\n\" ) ) ; sqlite3TreeViewSelect ( 0 , p , 0 ) ; for ( ii = 0 ; ii < sAggInfo . nColumn ; ii ++ ) { sqlite3DebugPrintf ( \"agg-column[%d]<S2SV_blank>iMem=%d\\\\n\" , ii , sAggInfo . aCol [ ii ] . iMem ) ; sqlite3TreeViewExpr ( 0 , sAggInfo . aCol [ ii ] . pExpr , 0 ) ; } for ( ii = 0 ; ii < sAggInfo . nFunc ; ii ++ ) { sqlite3DebugPrintf ( \"agg-func[%d]:<S2SV_blank>iMem=%d\\\\n\" , ii , sAggInfo . aFunc [ ii ] . iMem ) ; sqlite3TreeViewExpr ( 0 , sAggInfo . aFunc [ ii ] . pExpr , 0 ) ; } } # endif if ( pGroupBy ) { KeyInfo * pKeyInfo ; int addr1 ; int addrOutputRow ; int regOutputRow ; int addrSetAbort ; int addrTopOfLoop ; int addrSortingIdx ; int addrReset ; int regReset ; sAggInfo . sortingIdx = pParse -> nTab ++ ; pKeyInfo = sqlite3KeyInfoFromExprList ( pParse , pGroupBy , 0 , sAggInfo . nColumn ) ; addrSortingIdx = sqlite3VdbeAddOp4 ( v , OP_SorterOpen , sAggInfo . sortingIdx , sAggInfo . nSortingColumn , 0 , ( char * ) pKeyInfo , P4_KEYINFO ) ; iUseFlag = ++ pParse -> nMem ; iAbortFlag = ++ pParse -> nMem ; regOutputRow = ++ pParse -> nMem ; addrOutputRow = sqlite3VdbeMakeLabel ( pParse ) ; regReset = ++ pParse -> nMem ; addrReset = sqlite3VdbeMakeLabel ( pParse ) ; iAMem = pParse -> nMem + 1 ; pParse -> nMem += pGroupBy -> nExpr ; iBMem = pParse -> nMem + 1 ; pParse -> nMem += pGroupBy -> nExpr ; sqlite3VdbeAddOp2 ( v , OP_Integer , 0 , iAbortFlag ) ; VdbeComment ( ( v , \"clear<S2SV_blank>abort<S2SV_blank>flag\" ) ) ; sqlite3VdbeAddOp3 ( v , OP_Null , 0 , iAMem , iAMem + pGroupBy -> nExpr - 1 ) ; sqlite3VdbeAddOp2 ( v , OP_Gosub , regReset , addrReset ) ; SELECTTRACE ( 1 , pParse , p , ( \"WhereBegin\\\\n\" ) ) ; pWInfo = sqlite3WhereBegin ( pParse , pTabList , pWhere , pGroupBy , 0 , WHERE_GROUPBY | ( orderByGrp ? WHERE_SORTBYGROUP : 0 ) , 0 ) ; if ( pWInfo == 0 ) goto select_end ; if ( sqlite3WhereIsOrdered ( pWInfo ) == pGroupBy -> nExpr ) { groupBySort = 0 ; } else { int regBase ; int regRecord ; int nCol ; int nGroupBy ; explainTempTable ( pParse , ( sDistinct . isTnct && ( p -> selFlags & SF_Distinct ) == 0 ) ? \"DISTINCT\" : \"GROUP<S2SV_blank>BY\" ) ; groupBySort = 1 ; nGroupBy = pGroupBy -> nExpr ; nCol = nGroupBy ; j = nGroupBy ; for ( i = 0 ; i < sAggInfo . nColumn ; i ++ ) { if ( sAggInfo . aCol [ i ] . iSorterColumn >= j ) { nCol ++ ; j ++ ; } } regBase = sqlite3GetTempRange ( pParse , nCol ) ; sqlite3ExprCodeExprList ( pParse , pGroupBy , regBase , 0 , 0 ) ; j = nGroupBy ; for ( i = 0 ; i < sAggInfo . nColumn ; i ++ ) { struct AggInfo_col * pCol = & sAggInfo . aCol [ i ] ; if ( pCol -> iSorterColumn >= j ) { int r1 = j + regBase ; sqlite3ExprCodeGetColumnOfTable ( v , pCol -> pTab , pCol -> iTable , pCol -> iColumn , r1 ) ; j ++ ; } } regRecord = sqlite3GetTempReg ( pParse ) ; sqlite3VdbeAddOp3 ( v , OP_MakeRecord , regBase , nCol , regRecord ) ; sqlite3VdbeAddOp2 ( v , OP_SorterInsert , sAggInfo . sortingIdx , regRecord ) ; sqlite3ReleaseTempReg ( pParse , regRecord ) ; sqlite3ReleaseTempRange ( pParse , regBase , nCol ) ; sqlite3WhereEnd ( pWInfo ) ; sAggInfo . sortingIdxPTab = sortPTab = pParse -> nTab ++ ; sortOut = sqlite3GetTempReg ( pParse ) ; sqlite3VdbeAddOp3 ( v , OP_OpenPseudo , sortPTab , sortOut , nCol ) ; sqlite3VdbeAddOp2 ( v , OP_SorterSort , sAggInfo . sortingIdx , addrEnd ) ; VdbeComment ( ( v , \"GROUP<S2SV_blank>BY<S2SV_blank>sort\" ) ) ; VdbeCoverage ( v ) ; sAggInfo . useSortingIdx = 1 ; } if ( orderByGrp && OptimizationEnabled ( db , SQLITE_GroupByOrder ) && ( groupBySort || sqlite3WhereIsSorted ( pWInfo ) ) ) { sSort . pOrderBy = 0 ; sqlite3VdbeChangeToNoop ( v , sSort . addrSortIndex ) ; } addrTopOfLoop = sqlite3VdbeCurrentAddr ( v ) ; if ( groupBySort ) { sqlite3VdbeAddOp3 ( v , OP_SorterData , sAggInfo . sortingIdx , sortOut , sortPTab ) ; } for ( j = 0 ; j < pGroupBy -> nExpr ; j ++ ) { if ( groupBySort ) { sqlite3VdbeAddOp3 ( v , OP_Column , sortPTab , j , iBMem + j ) ; } else { sAggInfo . directMode = 1 ; sqlite3ExprCode ( pParse , pGroupBy -> a [ j ] . pExpr , iBMem + j ) ; } } sqlite3VdbeAddOp4 ( v , OP_Compare , iAMem , iBMem , pGroupBy -> nExpr , ( char * ) sqlite3KeyInfoRef ( pKeyInfo ) , P4_KEYINFO ) ; addr1 = sqlite3VdbeCurrentAddr ( v ) ; sqlite3VdbeAddOp3 ( v , OP_Jump , addr1 + 1 , 0 , addr1 + 1 ) ; VdbeCoverage ( v ) ; sqlite3ExprCodeMove ( pParse , iBMem , iAMem , pGroupBy -> nExpr ) ; sqlite3VdbeAddOp2 ( v , OP_Gosub , regOutputRow , addrOutputRow ) ; VdbeComment ( ( v , \"output<S2SV_blank>one<S2SV_blank>row\" ) ) ; sqlite3VdbeAddOp2 ( v , OP_IfPos , iAbortFlag , addrEnd ) ; VdbeCoverage ( v ) ; VdbeComment ( ( v , \"check<S2SV_blank>abort<S2SV_blank>flag\" ) ) ; sqlite3VdbeAddOp2 ( v , OP_Gosub , regReset , addrReset ) ; VdbeComment ( ( v , \"reset<S2SV_blank>accumulator\" ) ) ; sqlite3VdbeJumpHere ( v , addr1 ) ; updateAccumulator ( pParse , iUseFlag , & sAggInfo ) ; sqlite3VdbeAddOp2 ( v , OP_Integer , 1 , iUseFlag ) ; VdbeComment ( ( v , \"indicate<S2SV_blank>data<S2SV_blank>in<S2SV_blank>accumulator\" ) ) ; if ( groupBySort ) { sqlite3VdbeAddOp2 ( v , OP_SorterNext , sAggInfo . sortingIdx , addrTopOfLoop ) ; VdbeCoverage ( v ) ; } else { sqlite3WhereEnd ( pWInfo ) ; sqlite3VdbeChangeToNoop ( v , addrSortingIdx ) ; } sqlite3VdbeAddOp2 ( v , OP_Gosub , regOutputRow , addrOutputRow ) ; VdbeComment ( ( v , \"output<S2SV_blank>final<S2SV_blank>row\" ) ) ; sqlite3VdbeGoto ( v , addrEnd ) ; addrSetAbort = sqlite3VdbeCurrentAddr ( v ) ; sqlite3VdbeAddOp2 ( v , OP_Integer , 1 , iAbortFlag ) ; VdbeComment ( ( v , \"set<S2SV_blank>abort<S2SV_blank>flag\" ) ) ; sqlite3VdbeAddOp1 ( v , OP_Return , regOutputRow ) ; sqlite3VdbeResolveLabel ( v , addrOutputRow ) ; addrOutputRow = sqlite3VdbeCurrentAddr ( v ) ; sqlite3VdbeAddOp2 ( v , OP_IfPos , iUseFlag , addrOutputRow + 2 ) ; VdbeCoverage ( v ) ; VdbeComment ( ( v , \"Groupby<S2SV_blank>result<S2SV_blank>generator<S2SV_blank>entry<S2SV_blank>point\" ) ) ; sqlite3VdbeAddOp1 ( v , OP_Return , regOutputRow ) ; finalizeAggFunctions ( pParse , & sAggInfo ) ; sqlite3ExprIfFalse ( pParse , pHaving , addrOutputRow + 1 , SQLITE_JUMPIFNULL ) ; selectInnerLoop ( pParse , p , - 1 , & sSort , & sDistinct , pDest , addrOutputRow + 1 , addrSetAbort ) ; sqlite3VdbeAddOp1 ( v , OP_Return , regOutputRow ) ; VdbeComment ( ( v , \"end<S2SV_blank>groupby<S2SV_blank>result<S2SV_blank>generator\" ) ) ; sqlite3VdbeResolveLabel ( v , addrReset ) ; resetAccumulator ( pParse , & sAggInfo ) ; sqlite3VdbeAddOp2 ( v , OP_Integer , 0 , iUseFlag ) ; VdbeComment ( ( v , \"indicate<S2SV_blank>accumulator<S2SV_blank>empty\" ) ) ; sqlite3VdbeAddOp1 ( v , OP_Return , regReset ) ; } else { # ifndef SQLITE_OMIT_BTREECOUNT Table * pTab ; if ( ( pTab = isSimpleCount ( p , & sAggInfo ) ) != 0 ) { const int iDb = sqlite3SchemaToIndex ( pParse -> db , pTab -> pSchema ) ; const int iCsr = pParse -> nTab ++ ; Index * pIdx ; KeyInfo * pKeyInfo = 0 ; Index * pBest = 0 ; int iRoot = pTab -> tnum ; sqlite3CodeVerifySchema ( pParse , iDb ) ; sqlite3TableLock ( pParse , iDb , pTab -> tnum , 0 , pTab -> zName ) ; if ( ! HasRowid ( pTab ) ) pBest = sqlite3PrimaryKeyIndex ( pTab ) ; for ( pIdx = pTab -> pIndex ; pIdx ; pIdx = pIdx -> pNext ) { if ( pIdx -> bUnordered == 0 && pIdx -> szIdxRow < pTab -> szTabRow && pIdx -> pPartIdxWhere == 0 && ( ! pBest || pIdx -> szIdxRow < pBest -> szIdxRow ) ) { pBest = pIdx ; } } if ( pBest ) { iRoot = pBest -> tnum ; pKeyInfo = sqlite3KeyInfoOfIndex ( pParse , pBest ) ; } sqlite3VdbeAddOp4Int ( v , OP_OpenRead , iCsr , iRoot , iDb , 1 ) ; if ( pKeyInfo ) { sqlite3VdbeChangeP4 ( v , - 1 , ( char * ) pKeyInfo , P4_KEYINFO ) ; } sqlite3VdbeAddOp2 ( v , OP_Count , iCsr , sAggInfo . aFunc [ 0 ] . iMem ) ; sqlite3VdbeAddOp1 ( v , OP_Close , iCsr ) ; explainSimpleCount ( pParse , pTab , pBest ) ; } else # endif { int regAcc = 0 ; if ( sAggInfo . nAccumulator ) { for ( i = 0 ; i < sAggInfo . nFunc ; i ++ ) { if ( ExprHasProperty ( sAggInfo . aFunc [ i ] . pExpr , EP_WinFunc ) ) continue ; if ( sAggInfo . aFunc [ i ] . pFunc -> funcFlags & SQLITE_FUNC_NEEDCOLL ) break ; } if ( i == sAggInfo . nFunc ) { regAcc = ++ pParse -> nMem ; sqlite3VdbeAddOp2 ( v , OP_Integer , 0 , regAcc ) ; } } assert ( p -> pGroupBy == 0 ) ; resetAccumulator ( pParse , & sAggInfo ) ; assert ( minMaxFlag == WHERE_ORDERBY_NORMAL || pMinMaxOrderBy != 0 ) ; assert ( pMinMaxOrderBy == 0 || pMinMaxOrderBy -> nExpr == 1 ) ; SELECTTRACE ( 1 , pParse , p , ( \"WhereBegin\\\\n\" ) ) ; pWInfo = sqlite3WhereBegin ( pParse , pTabList , pWhere , pMinMaxOrderBy , 0 , minMaxFlag , 0 ) ; if ( pWInfo == 0 ) { goto select_end ; } updateAccumulator ( pParse , regAcc , & sAggInfo ) ; if ( regAcc ) sqlite3VdbeAddOp2 ( v , OP_Integer , 1 , regAcc ) ; if ( sqlite3WhereIsOrdered ( pWInfo ) > 0 ) { sqlite3VdbeGoto ( v , sqlite3WhereBreakLabel ( pWInfo ) ) ; VdbeComment ( ( v , \"%s()<S2SV_blank>by<S2SV_blank>index\" , ( minMaxFlag == WHERE_ORDERBY_MIN ? \"min\" : \"max\" ) ) ) ; } sqlite3WhereEnd ( pWInfo ) ; finalizeAggFunctions ( pParse , & sAggInfo ) ; } sSort . pOrderBy = 0 ; sqlite3ExprIfFalse ( pParse , pHaving , addrEnd , SQLITE_JUMPIFNULL ) ; selectInnerLoop ( pParse , p , - 1 , 0 , 0 , pDest , addrEnd , addrEnd ) ; } sqlite3VdbeResolveLabel ( v , addrEnd ) ; } if ( sDistinct . eTnctType == WHERE_DISTINCT_UNORDERED ) { explainTempTable ( pParse , \"DISTINCT\" ) ; } if ( sSort . pOrderBy ) { explainTempTable ( pParse , sSort . nOBSat > 0 ? \"RIGHT<S2SV_blank>PART<S2SV_blank>OF<S2SV_blank>ORDER<S2SV_blank>BY\" : \"ORDER<S2SV_blank>BY\" ) ; assert ( p -> pEList == pEList ) ; generateSortTail ( pParse , p , & sSort , pEList -> nExpr , pDest ) ; } sqlite3VdbeResolveLabel ( v , iEnd ) ; rc = ( pParse -> nErr > 0 ) ; select_end : sqlite3ExprListDelete ( db , pMinMaxOrderBy ) ; sqlite3DbFree ( db , sAggInfo . aCol ) ; sqlite3DbFree ( db , sAggInfo . aFunc ) ; # if SELECTTRACE_ENABLED SELECTTRACE ( 0x1 , pParse , p , ( \"end<S2SV_blank>processing\\\\n\" ) ) ; if ( ( sqlite3SelectTrace & 0x2000 ) != 0 && ExplainQueryPlanParent ( pParse ) == 0 ) { sqlite3TreeViewSelect ( 0 , p , 0 ) ; } # endif ExplainQueryPlanPop ( pParse ) ; return rc ; }\n","target":"<S2SV_ModStart> ) == 0 && p -> pWin == 0\n","project_and_commit_id":"sqlite@sqlite/e59c562b3f6894f84c715772c4b116d7b5c01348","cve_id":"CVE-2019-19244","original_address":"https://github.com/sqlite/sqlite/commit/e59c562b3f6894f84c715772c4b116d7b5c01348","time":"2019-11-25T20:15Z"},
	{"Unnamed: 0":3474,"cwe_id":"CWE-119","source":"CWE-119 static int tcos_select_file ( sc_card_t * card , const sc_path_t * in_path , sc_file_t * * file_out ) { sc_context_t * ctx ; sc_apdu_t apdu ; sc_file_t * file = NULL ; u8 buf [ SC_MAX_APDU_BUFFER_SIZE ] , pathbuf [ SC_MAX_PATH_SIZE ] , * path = pathbuf ; unsigned int i ; int r , pathlen ; assert ( card != NULL && in_path != NULL ) ; ctx = card -> ctx ; memcpy ( path , in_path -> value , in_path -> len ) ; pathlen = in_path -> len ; sc_format_apdu ( card , & apdu , SC_APDU_CASE_4_SHORT , 0xA4 , 0 , 0x04 ) ; switch ( in_path -> type ) { case SC_PATH_TYPE_FILE_ID : if ( pathlen != 2 ) return SC_ERROR_INVALID_ARGUMENTS ; case SC_PATH_TYPE_FROM_CURRENT : apdu . p1 = 9 ; break ; case SC_PATH_TYPE_DF_NAME : apdu . p1 = 4 ; break ; case SC_PATH_TYPE_PATH : apdu . p1 = 8 ; if ( pathlen >= 2 && memcmp ( path , \"\\\\x3F\\\\x00\" , 2 ) == 0 ) path += 2 , pathlen -= 2 ; if ( pathlen == 0 ) apdu . p1 = 0 ; break ; case SC_PATH_TYPE_PARENT : apdu . p1 = 3 ; pathlen = 0 ; break ; default : SC_FUNC_RETURN ( ctx , SC_LOG_DEBUG_VERBOSE , SC_ERROR_INVALID_ARGUMENTS ) ; } if ( pathlen == 0 ) apdu . cse = SC_APDU_CASE_2_SHORT ; apdu . lc = pathlen ; apdu . data = path ; apdu . datalen = pathlen ; if ( file_out != NULL ) { apdu . resp = buf ; apdu . resplen = sizeof ( buf ) ; apdu . le = 256 ; } else { apdu . resplen = 0 ; apdu . le = 0 ; apdu . p2 = 0x0C ; apdu . cse = ( pathlen == 0 ) ? SC_APDU_CASE_1 : SC_APDU_CASE_3_SHORT ; } r = sc_transmit_apdu ( card , & apdu ) ; SC_TEST_RET ( ctx , SC_LOG_DEBUG_NORMAL , r , \"APDU<S2SV_blank>transmit<S2SV_blank>failed\" ) ; r = sc_check_sw ( card , apdu . sw1 , apdu . sw2 ) ; if ( r || file_out == NULL ) SC_FUNC_RETURN ( ctx , SC_LOG_DEBUG_VERBOSE , r ) ; if ( apdu . resplen < 1 || apdu . resp [ 0 ] != 0x62 ) { sc_debug ( ctx , SC_LOG_DEBUG_NORMAL , \"received<S2SV_blank>invalid<S2SV_blank>template<S2SV_blank>%02X\\\\n\" , apdu . resp [ 0 ] ) ; SC_FUNC_RETURN ( ctx , SC_LOG_DEBUG_VERBOSE , SC_ERROR_UNKNOWN_DATA_RECEIVED ) ; } file = sc_file_new ( ) ; if ( file == NULL ) SC_FUNC_RETURN ( ctx , SC_LOG_DEBUG_NORMAL , SC_ERROR_OUT_OF_MEMORY ) ; * file_out = file ; file -> path = * in_path ; for ( i = 2 ; i + 1 < apdu . resplen && i + 1 + apdu . resp [ i + 1 ] < apdu . resplen ; i += 2 + apdu . resp [ i + 1 ] ) { <S2SV_StartBug> int j , len = apdu . resp [ i + 1 ] ; <S2SV_EndBug> unsigned char type = apdu . resp [ i ] , * d = apdu . resp + i + 2 ; switch ( type ) { case 0x80 : case 0x81 : file -> size = 0 ; for ( j = 0 ; j < len ; ++ j ) file -> size = ( file -> size << 8 ) | d [ j ] ; break ; case 0x82 : file -> shareable = ( d [ 0 ] & 0x40 ) ? 1 : 0 ; file -> ef_structure = d [ 0 ] & 7 ; switch ( ( d [ 0 ] >> 3 ) & 7 ) { case 0 : file -> type = SC_FILE_TYPE_WORKING_EF ; break ; case 7 : file -> type = SC_FILE_TYPE_DF ; break ; default : sc_debug ( ctx , SC_LOG_DEBUG_NORMAL , \"invalid<S2SV_blank>file<S2SV_blank>type<S2SV_blank>%02X<S2SV_blank>in<S2SV_blank>file<S2SV_blank>descriptor\\\\n\" , d [ 0 ] ) ; SC_FUNC_RETURN ( ctx , SC_LOG_DEBUG_VERBOSE , SC_ERROR_UNKNOWN_DATA_RECEIVED ) ; } break ; case 0x83 : file -> id = ( d [ 0 ] << 8 ) | d [ 1 ] ; break ; case 0x84 : <S2SV_StartBug> memcpy ( file -> name , d , len ) ; <S2SV_EndBug> <S2SV_StartBug> file -> namelen = len ; <S2SV_EndBug> break ; case 0x86 : sc_file_set_sec_attr ( file , d , len ) ; break ; default : if ( len > 0 ) sc_file_set_prop_attr ( file , d , len ) ; } } file -> magic = SC_FILE_MAGIC ; parse_sec_attr ( card , file , file -> sec_attr , file -> sec_attr_len ) ; return 0 ; }\n","target":"<S2SV_ModStart> ] ) { size_t <S2SV_ModEnd> j , len <S2SV_ModStart> case 0x84 : file -> namelen = MIN ( sizeof file -> name , len ) ; <S2SV_ModStart> , d , <S2SV_ModEnd> file -> namelen <S2SV_ModStart> file -> namelen ) <S2SV_ModEnd> ; break ;\n","project_and_commit_id":"OpenSC@OpenSC/360e95d45ac4123255a4c796db96337f332160ad","cve_id":"CVE-2018-16391","original_address":"https://github.com/OpenSC/OpenSC/commit/360e95d45ac4123255a4c796db96337f332160ad#diff-477b7a40136bb418b10ce271c8664536","time":"2018-09-03T14:29Z"},
	{"Unnamed: 0":977,"cwe_id":"CWE-125","source":"CWE-125 mod_ty string_object_to_c_ast ( const char * s , PyObject * filename , int start , PyCompilerFlags * flags , int feature_version , PyArena * arena ) { mod_ty mod ; PyCompilerFlags localflags ; perrdetail err ; int iflags = PARSER_FLAGS ( flags ) ; <S2SV_StartBug> node * n = Ta3Parser_ParseStringObject ( s , filename , <S2SV_EndBug> & _Ta3Parser_Grammar , start , & err , & iflags ) ; if ( flags == NULL ) { localflags . cf_flags = 0 ; flags = & localflags ; } if ( n ) { flags -> cf_flags |= iflags & PyCF_MASK ; mod = Ta3AST_FromNodeObject ( n , flags , filename , feature_version , arena ) ; Ta3Node_Free ( n ) ; } else { err_input ( & err ) ; mod = NULL ; } err_free ( & err ) ; return mod ; }\n","target":"<S2SV_ModStart> ; node * n ; if ( feature_version >= 7 ) iflags |= PyPARSE_ASYNC_ALWAYS ;\n","project_and_commit_id":"python@typed_ast/156afcb26c198e162504a57caddfe0acd9ed7dce","cve_id":"CVE-2019-19275","original_address":"https://github.com/python/typed_ast/commit/156afcb26c198e162504a57caddfe0acd9ed7dce","time":"2019-11-26T15:15Z"},
	{"Unnamed: 0":4445,"cwe_id":"CWE-20","source":"CWE-20 static int keyring_search_iterator ( const void * object , void * iterator_data ) { struct keyring_search_context * ctx = iterator_data ; const struct key * key = keyring_ptr_to_key ( object ) ; <S2SV_StartBug> unsigned long kflags = key -> flags ; <S2SV_EndBug> kenter ( \"{%d}\" , key -> serial ) ; if ( key -> type != ctx -> index_key . type ) { kleave ( \"<S2SV_blank>=<S2SV_blank>0<S2SV_blank>[!type]\" ) ; return 0 ; } if ( ctx -> flags & KEYRING_SEARCH_DO_STATE_CHECK ) { if ( kflags & ( ( 1 << KEY_FLAG_INVALIDATED ) | ( 1 << KEY_FLAG_REVOKED ) ) ) { ctx -> result = ERR_PTR ( - EKEYREVOKED ) ; kleave ( \"<S2SV_blank>=<S2SV_blank>%d<S2SV_blank>[invrev]\" , ctx -> skipped_ret ) ; goto skipped ; } if ( key -> expiry && ctx -> now . tv_sec >= key -> expiry ) { if ( ! ( ctx -> flags & KEYRING_SEARCH_SKIP_EXPIRED ) ) ctx -> result = ERR_PTR ( - EKEYEXPIRED ) ; kleave ( \"<S2SV_blank>=<S2SV_blank>%d<S2SV_blank>[expire]\" , ctx -> skipped_ret ) ; goto skipped ; } } if ( ! ctx -> match_data . cmp ( key , & ctx -> match_data ) ) { kleave ( \"<S2SV_blank>=<S2SV_blank>0<S2SV_blank>[!match]\" ) ; return 0 ; } if ( ! ( ctx -> flags & KEYRING_SEARCH_NO_CHECK_PERM ) && key_task_permission ( make_key_ref ( key , ctx -> possessed ) , ctx -> cred , KEY_NEED_SEARCH ) < 0 ) { ctx -> result = ERR_PTR ( - EACCES ) ; kleave ( \"<S2SV_blank>=<S2SV_blank>%d<S2SV_blank>[!perm]\" , ctx -> skipped_ret ) ; goto skipped ; } if ( ctx -> flags & KEYRING_SEARCH_DO_STATE_CHECK ) { <S2SV_StartBug> if ( kflags & ( 1 << KEY_FLAG_NEGATIVE ) ) { <S2SV_EndBug> smp_rmb ( ) ; <S2SV_StartBug> ctx -> result = ERR_PTR ( key -> reject_error ) ; <S2SV_EndBug> kleave ( \"<S2SV_blank>=<S2SV_blank>%d<S2SV_blank>[neg]\" , ctx -> skipped_ret ) ; goto skipped ; } } ctx -> result = make_key_ref ( key , ctx -> possessed ) ; kleave ( \"<S2SV_blank>=<S2SV_blank>1<S2SV_blank>[found]\" ) ; return 1 ; skipped : return ctx -> skipped_ret ; }\n","target":"<S2SV_ModStart> long kflags = READ_ONCE ( key -> flags ) ; short state = READ_ONCE ( key -> state ) <S2SV_ModEnd> ; kenter ( <S2SV_ModStart> { if ( state < 0 ) { <S2SV_ModEnd> ctx -> result <S2SV_ModStart> = ERR_PTR ( state <S2SV_ModEnd> ) ; kleave\n","project_and_commit_id":"torvalds@linux/363b02dab09b3226f3bd1420dad9c72b79a42a76","cve_id":"CVE-2017-15951","original_address":"https://github.com/torvalds/linux/commit/363b02dab09b3226f3bd1420dad9c72b79a42a76","time":"2017-10-28T02:29Z"},
	{"Unnamed: 0":6682,"cwe_id":"CWE-264","source":"CWE-264 static bool blk_kick_flush ( struct request_queue * q , struct blk_flush_queue * fq ) { struct list_head * pending = & fq -> flush_queue [ fq -> flush_pending_idx ] ; struct request * first_rq = list_first_entry ( pending , struct request , flush . list ) ; struct request * flush_rq = fq -> flush_rq ; if ( fq -> flush_pending_idx != fq -> flush_running_idx || list_empty ( pending ) ) return false ; if ( ! list_empty ( & fq -> flush_data_in_flight ) && time_before ( jiffies , fq -> flush_pending_since + FLUSH_PENDING_TIMEOUT ) ) return false ; fq -> flush_pending_idx ^= 1 ; blk_rq_init ( q , flush_rq ) ; if ( q -> mq_ops ) { <S2SV_StartBug> flush_rq -> mq_ctx = first_rq -> mq_ctx ; <S2SV_EndBug> <S2SV_StartBug> flush_rq -> tag = first_rq -> tag ; <S2SV_EndBug> } flush_rq -> cmd_type = REQ_TYPE_FS ; flush_rq -> cmd_flags = WRITE_FLUSH | REQ_FLUSH_SEQ ; flush_rq -> rq_disk = first_rq -> rq_disk ; flush_rq -> end_io = flush_end_io ; return blk_flush_queue_rq ( flush_rq , false ) ; }\n","target":"<S2SV_ModStart> mq_ops ) { struct blk_mq_hw_ctx * hctx ; <S2SV_ModStart> first_rq -> tag ; fq -> orig_rq = first_rq ; hctx = q -> mq_ops -> map_queue ( q , first_rq -> mq_ctx -> cpu ) ; blk_mq_tag_set_rq ( hctx , first_rq -> tag , flush_rq )\n","project_and_commit_id":"torvalds@linux/0048b4837affd153897ed1222283492070027aa9","cve_id":"CVE-2015-9016","original_address":"https://github.com/torvalds/linux/commit/0048b4837affd153897ed1222283492070027aa9","time":"2018-04-05T18:29Z"},
	{"Unnamed: 0":3008,"cwe_id":"CWE-200","source":"CWE-200 SYSCALL_DEFINE5 ( waitid , int , which , pid_t , upid , struct siginfo __user * , infop , int , options , struct rusage __user * , ru ) { struct rusage r ; struct waitid_info info = { . status = 0 } ; long err = kernel_waitid ( which , upid , & info , options , ru ? & r : NULL ) ; int signo = 0 ; if ( err > 0 ) { signo = SIGCHLD ; err = 0 ; <S2SV_StartBug> } <S2SV_EndBug> if ( ! err ) { if ( ru && copy_to_user ( ru , & r , sizeof ( struct rusage ) ) ) return - EFAULT ; } if ( ! infop ) return err ; user_access_begin ( ) ; unsafe_put_user ( signo , & infop -> si_signo , Efault ) ; unsafe_put_user ( 0 , & infop -> si_errno , Efault ) ; unsafe_put_user ( info . cause , & infop -> si_code , Efault ) ; unsafe_put_user ( info . pid , & infop -> si_pid , Efault ) ; unsafe_put_user ( info . uid , & infop -> si_uid , Efault ) ; unsafe_put_user ( info . status , & infop -> si_status , Efault ) ; user_access_end ( ) ; return err ; Efault : user_access_end ( ) ; return - EFAULT ; }\n","target":"<S2SV_ModStart> = 0 ; <S2SV_ModEnd> if ( ru\n","project_and_commit_id":"torvalds@linux/6c85501f2fabcfc4fc6ed976543d252c4eaf4be9","cve_id":"CVE-2017-14954","original_address":"https://github.com/torvalds/linux/commit/6c85501f2fabcfc4fc6ed976543d252c4eaf4be9","time":"2017-10-02T01:29Z"},
	{"Unnamed: 0":2282,"cwe_id":"CWE-119","source":"CWE-119 cJSON * cJSON_CreateArray ( void ) { cJSON * item = cJSON_New_Item ( ) ; if ( item ) item -> type = cJSON_Array ; return item ; }\n","target":"\n","project_and_commit_id":"esnet@iperf/91f2fa59e8ed80dfbf400add0164ee0e508e412a","cve_id":"CVE-2016-4303","original_address":"https://github.com/esnet/iperf/commit/91f2fa59e8ed80dfbf400add0164ee0e508e412a","time":"2016-09-26T14:59Z"},
	{"Unnamed: 0":1994,"cwe_id":"CWE-20","source":"CWE-20 NORET_TYPE void do_exit ( long code ) { struct task_struct * tsk = current ; int group_dead ; profile_task_exit ( tsk ) ; WARN_ON ( atomic_read ( & tsk -> fs_excl ) ) ; if ( unlikely ( in_interrupt ( ) ) ) panic ( \"Aiee,<S2SV_blank>killing<S2SV_blank>interrupt<S2SV_blank>handler!\" ) ; if ( unlikely ( ! tsk -> pid ) ) panic ( \"Attempted<S2SV_blank>to<S2SV_blank>kill<S2SV_blank>the<S2SV_blank>idle<S2SV_blank>task!\" ) ; tracehook_report_exit ( & code ) ; validate_creds_for_do_exit ( tsk ) ; if ( unlikely ( tsk -> flags & PF_EXITING ) ) { printk ( KERN_ALERT \"Fixing<S2SV_blank>recursive<S2SV_blank>fault<S2SV_blank>but<S2SV_blank>reboot<S2SV_blank>is<S2SV_blank>needed!\\\\n\" ) ; tsk -> flags |= PF_EXITPIDONE ; set_current_state ( TASK_UNINTERRUPTIBLE ) ; schedule ( ) ; } exit_irq_thread ( ) ; exit_signals ( tsk ) ; smp_mb ( ) ; spin_unlock_wait ( & tsk -> pi_lock ) ; if ( unlikely ( in_atomic ( ) ) ) printk ( KERN_INFO \"note:<S2SV_blank>%s[%d]<S2SV_blank>exited<S2SV_blank>with<S2SV_blank>preempt_count<S2SV_blank>%d\\\\n\" , current -> comm , task_pid_nr ( current ) , preempt_count ( ) ) ; acct_update_integrals ( tsk ) ; group_dead = atomic_dec_and_test ( & tsk -> signal -> live ) ; if ( group_dead ) { hrtimer_cancel ( & tsk -> signal -> real_timer ) ; exit_itimers ( tsk -> signal ) ; if ( tsk -> mm ) setmax_mm_hiwater_rss ( & tsk -> signal -> maxrss , tsk -> mm ) ; } acct_collect ( code , group_dead ) ; if ( group_dead ) tty_audit_exit ( ) ; if ( unlikely ( tsk -> audit_context ) ) audit_free ( tsk ) ; tsk -> exit_code = code ; taskstats_exit ( tsk , group_dead ) ; exit_mm ( tsk ) ; if ( group_dead ) acct_process ( ) ; trace_sched_process_exit ( tsk ) ; exit_sem ( tsk ) ; exit_files ( tsk ) ; exit_fs ( tsk ) ; check_stack_usage ( ) ; exit_thread ( ) ; cgroup_exit ( tsk , 1 ) ; if ( group_dead && tsk -> signal -> leader ) disassociate_ctty ( 1 ) ; module_put ( task_thread_info ( tsk ) -> exec_domain -> module ) ; proc_exit_connector ( tsk ) ; perf_event_exit_task ( tsk ) ; exit_notify ( tsk , group_dead ) ; # ifdef CONFIG_NUMA mpol_put ( tsk -> mempolicy ) ; tsk -> mempolicy = NULL ; # endif # ifdef CONFIG_FUTEX if ( unlikely ( current -> pi_state_cache ) ) kfree ( current -> pi_state_cache ) ; # endif debug_check_no_locks_held ( tsk ) ; tsk -> flags |= PF_EXITPIDONE ; if ( tsk -> io_context ) <S2SV_StartBug> exit_io_context ( ) ; <S2SV_EndBug> if ( tsk -> splice_pipe ) __free_pipe_info ( tsk -> splice_pipe ) ; validate_creds_for_do_exit ( tsk ) ; preempt_disable ( ) ; exit_rcu ( ) ; tsk -> state = TASK_DEAD ; schedule ( ) ; BUG ( ) ; for ( ; ; ) cpu_relax ( ) ; }\n","target":"<S2SV_ModStart> ) exit_io_context ( tsk\n","project_and_commit_id":"torvalds@linux/b69f2292063d2caf37ca9aec7d63ded203701bf3","cve_id":"CVE-2012-0879","original_address":"https://github.com/torvalds/linux/commit/b69f2292063d2caf37ca9aec7d63ded203701bf3","time":"2012-05-17T11:00Z"},
	{"Unnamed: 0":140,"cwe_id":"CWE-119","source":"CWE-119 static int process_line ( URLContext * h , char * line , int line_count , int * new_location ) { HTTPContext * s = h -> priv_data ; const char * auto_method = h -> flags & AVIO_FLAG_READ ? \"POST\" : \"GET\" ; char * tag , * p , * end , * method , * resource , * version ; int ret ; if ( line [ 0 ] == '\\\\0' ) { s -> end_header = 1 ; return 0 ; } p = line ; if ( line_count == 0 ) { if ( s -> is_connected_server ) { method = p ; while ( * p && ! av_isspace ( * p ) ) p ++ ; * ( p ++ ) = '\\\\0' ; av_log ( h , AV_LOG_TRACE , \"Received<S2SV_blank>method:<S2SV_blank>%s\\\\n\" , method ) ; if ( s -> method ) { if ( av_strcasecmp ( s -> method , method ) ) { av_log ( h , AV_LOG_ERROR , \"Received<S2SV_blank>and<S2SV_blank>expected<S2SV_blank>HTTP<S2SV_blank>method<S2SV_blank>do<S2SV_blank>not<S2SV_blank>match.<S2SV_blank>(%s<S2SV_blank>expected,<S2SV_blank>%s<S2SV_blank>received)\\\\n\" , s -> method , method ) ; return ff_http_averror ( 400 , AVERROR ( EIO ) ) ; } } else { av_log ( h , AV_LOG_TRACE , \"Autodetected<S2SV_blank>%s<S2SV_blank>HTTP<S2SV_blank>method\\\\n\" , auto_method ) ; if ( av_strcasecmp ( auto_method , method ) ) { av_log ( h , AV_LOG_ERROR , \"Received<S2SV_blank>and<S2SV_blank>autodetected<S2SV_blank>HTTP<S2SV_blank>method<S2SV_blank>did<S2SV_blank>not<S2SV_blank>match<S2SV_blank>\" \"(%s<S2SV_blank>autodetected<S2SV_blank>%s<S2SV_blank>received)\\\\n\" , auto_method , method ) ; return ff_http_averror ( 400 , AVERROR ( EIO ) ) ; } if ( ! ( s -> method = av_strdup ( method ) ) ) return AVERROR ( ENOMEM ) ; } while ( av_isspace ( * p ) ) p ++ ; resource = p ; while ( ! av_isspace ( * p ) ) p ++ ; * ( p ++ ) = '\\\\0' ; av_log ( h , AV_LOG_TRACE , \"Requested<S2SV_blank>resource:<S2SV_blank>%s\\\\n\" , resource ) ; if ( ! ( s -> resource = av_strdup ( resource ) ) ) return AVERROR ( ENOMEM ) ; while ( av_isspace ( * p ) ) p ++ ; version = p ; while ( * p && ! av_isspace ( * p ) ) p ++ ; * p = '\\\\0' ; if ( av_strncasecmp ( version , \"HTTP/\" , 5 ) ) { av_log ( h , AV_LOG_ERROR , \"Malformed<S2SV_blank>HTTP<S2SV_blank>version<S2SV_blank>string.\\\\n\" ) ; return ff_http_averror ( 400 , AVERROR ( EIO ) ) ; } av_log ( h , AV_LOG_TRACE , \"HTTP<S2SV_blank>version<S2SV_blank>string:<S2SV_blank>%s\\\\n\" , version ) ; } else { while ( ! av_isspace ( * p ) && * p != '\\\\0' ) p ++ ; while ( av_isspace ( * p ) ) p ++ ; s -> http_code = strtol ( p , & end , 10 ) ; av_log ( h , AV_LOG_TRACE , \"http_code=%d\\\\n\" , s -> http_code ) ; if ( ( ret = check_http_code ( h , s -> http_code , end ) ) < 0 ) return ret ; } } else { while ( * p != '\\\\0' && * p != ':' ) p ++ ; if ( * p != ':' ) return 1 ; * p = '\\\\0' ; tag = line ; p ++ ; while ( av_isspace ( * p ) ) p ++ ; if ( ! av_strcasecmp ( tag , \"Location\" ) ) { if ( ( ret = parse_location ( s , p ) ) < 0 ) return ret ; * new_location = 1 ; <S2SV_StartBug> } else if ( ! av_strcasecmp ( tag , \"Content-Length\" ) && s -> filesize == - 1 ) { <S2SV_EndBug> <S2SV_StartBug> s -> filesize = strtoll ( p , NULL , 10 ) ; <S2SV_EndBug> } else if ( ! av_strcasecmp ( tag , \"Content-Range\" ) ) { parse_content_range ( h , p ) ; } else if ( ! av_strcasecmp ( tag , \"Accept-Ranges\" ) && ! strncmp ( p , \"bytes\" , 5 ) && s -> seekable == - 1 ) { h -> is_streamed = 0 ; } else if ( ! av_strcasecmp ( tag , \"Transfer-Encoding\" ) && ! av_strncasecmp ( p , \"chunked\" , 7 ) ) { <S2SV_StartBug> s -> filesize = - 1 ; <S2SV_EndBug> s -> chunksize = 0 ; } else if ( ! av_strcasecmp ( tag , \"WWW-Authenticate\" ) ) { <S2SV_StartBug> ff_http_auth_handle_header ( & s -> auth_state , tag , p ) ; <S2SV_EndBug> } else if ( ! av_strcasecmp ( tag , \"Authentication-Info\" ) ) { ff_http_auth_handle_header ( & s -> auth_state , tag , p ) ; } else if ( ! av_strcasecmp ( tag , \"Proxy-Authenticate\" ) ) { ff_http_auth_handle_header ( & s -> proxy_auth_state , tag , p ) ; } else if ( ! av_strcasecmp ( tag , \"Connection\" ) ) { if ( ! strcmp ( p , \"close\" ) ) s -> willclose = 1 ; } else if ( ! av_strcasecmp ( tag , \"Server\" ) ) { if ( ! av_strcasecmp ( p , \"AkamaiGHost\" ) ) { s -> is_akamai = 1 ; } else if ( ! av_strncasecmp ( p , \"MediaGateway\" , 12 ) ) { s -> is_mediagateway = 1 ; } } else if ( ! av_strcasecmp ( tag , \"Content-Type\" ) ) { av_free ( s -> mime_type ) ; s -> mime_type = av_strdup ( p ) ; } else if ( ! av_strcasecmp ( tag , \"Set-Cookie\" ) ) { if ( parse_cookie ( s , p , & s -> cookie_dict ) ) av_log ( h , AV_LOG_WARNING , \"Unable<S2SV_blank>to<S2SV_blank>parse<S2SV_blank>\\'%s\\'\\\\n\" , p ) ; } else if ( ! av_strcasecmp ( tag , \"Icy-MetaInt\" ) ) { <S2SV_StartBug> s -> icy_metaint = strtoll ( p , NULL , 10 ) ; <S2SV_EndBug> } else if ( ! av_strncasecmp ( tag , \"Icy-\" , 4 ) ) { if ( ( ret = parse_icy ( s , tag , p ) ) < 0 ) return ret ; } else if ( ! av_strcasecmp ( tag , \"Content-Encoding\" ) ) { if ( ( ret = parse_content_encoding ( h , p ) ) < 0 ) return ret ; } } return 1 ; }\n","target":"<S2SV_ModStart> -> filesize == UINT64_MAX <S2SV_ModEnd> ) { s <S2SV_ModStart> -> filesize = strtoull <S2SV_ModEnd> ( p , <S2SV_ModStart> -> filesize = UINT64_MAX ; s -> chunksize = 0 ; } else if ( ! av_strcasecmp ( tag , \"WWW-Authenticate\" ) ) { ff_http_auth_handle_header ( & s -> auth_state , tag , p ) ; } else if ( ! av_strcasecmp ( tag , \"Authentication-Info\" ) ) { ff_http_auth_handle_header ( & s -> auth_state , tag , p ) ; } else if ( ! av_strcasecmp ( tag , \"Proxy-Authenticate\" ) ) { ff_http_auth_handle_header ( & s -> proxy_auth_state , tag , p ) ; } else if ( ! av_strcasecmp ( tag , \"Connection\" ) ) { if ( ! strcmp ( p , \"close\" ) ) s -> willclose = 1 ; } else if ( ! av_strcasecmp ( tag , \"Server\" ) ) { if ( ! av_strcasecmp ( p , \"AkamaiGHost\" ) ) { s -> is_akamai = 1 ; } else if ( ! av_strncasecmp ( p , \"MediaGateway\" , 12 ) ) { s -> is_mediagateway = 1 ; } } else if ( ! av_strcasecmp ( tag , \"Content-Type\" ) ) { av_free ( s -> mime_type ) ; s -> mime_type = av_strdup ( p ) ; } else if ( ! av_strcasecmp ( tag , \"Set-Cookie\" ) ) { if ( parse_cookie ( s , p , <S2SV_ModEnd> & s -> <S2SV_ModStart> & s -> <S2SV_ModEnd> cookie_dict ) ) <S2SV_ModStart> -> icy_metaint = strtoull <S2SV_ModEnd> ( p ,\n","project_and_commit_id":"FFmpeg@FFmpeg/2a05c8f813de6f2278827734bf8102291e7484aa","cve_id":"CVE-2016-10190","original_address":"https://github.com/FFmpeg/FFmpeg/commit/2a05c8f813de6f2278827734bf8102291e7484aa","time":"2017-02-09T15:59Z"},
	{"Unnamed: 0":5592,"cwe_id":"CWE-20","source":"CWE-20 static int jpc_siz_getparms ( jpc_ms_t * ms , jpc_cstate_t * cstate , jas_stream_t * in ) { jpc_siz_t * siz = & ms -> parms . siz ; unsigned int i ; uint_fast8_t tmp ; <S2SV_StartBug> cstate = 0 ; <S2SV_EndBug> if ( jpc_getuint16 ( in , & siz -> caps ) || jpc_getuint32 ( in , & siz -> width ) || jpc_getuint32 ( in , & siz -> height ) || jpc_getuint32 ( in , & siz -> xoff ) || jpc_getuint32 ( in , & siz -> yoff ) || jpc_getuint32 ( in , & siz -> tilewidth ) || jpc_getuint32 ( in , & siz -> tileheight ) || jpc_getuint32 ( in , & siz -> tilexoff ) || jpc_getuint32 ( in , & siz -> tileyoff ) || jpc_getuint16 ( in , & siz -> numcomps ) ) { <S2SV_StartBug> return - 1 ; <S2SV_EndBug> } <S2SV_StartBug> if ( ! siz -> width || ! siz -> height || ! siz -> tilewidth || <S2SV_EndBug> ! siz -> tileheight || ! siz -> numcomps || siz -> numcomps > 16384 ) { return - 1 ; } if ( siz -> tilexoff >= siz -> width || siz -> tileyoff >= siz -> height ) { jas_eprintf ( \"all<S2SV_blank>tiles<S2SV_blank>are<S2SV_blank>outside<S2SV_blank>the<S2SV_blank>image<S2SV_blank>area\\\\n\" ) ; return - 1 ; } if ( ! ( siz -> comps = jas_alloc2 ( siz -> numcomps , sizeof ( jpc_sizcomp_t ) ) ) ) { return - 1 ; } for ( i = 0 ; i < siz -> numcomps ; ++ i ) { if ( jpc_getuint8 ( in , & tmp ) || jpc_getuint8 ( in , & siz -> comps [ i ] . hsamp ) || jpc_getuint8 ( in , & siz -> comps [ i ] . vsamp ) ) { jas_free ( siz -> comps ) ; return - 1 ; } if ( siz -> comps [ i ] . hsamp == 0 || siz -> comps [ i ] . hsamp > 255 ) { jas_eprintf ( \"invalid<S2SV_blank>XRsiz<S2SV_blank>value<S2SV_blank>%d\\\\n\" , siz -> comps [ i ] . hsamp ) ; jas_free ( siz -> comps ) ; return - 1 ; } if ( siz -> comps [ i ] . vsamp == 0 || siz -> comps [ i ] . vsamp > 255 ) { jas_eprintf ( \"invalid<S2SV_blank>YRsiz<S2SV_blank>value<S2SV_blank>%d\\\\n\" , siz -> comps [ i ] . vsamp ) ; jas_free ( siz -> comps ) ; return - 1 ; } siz -> comps [ i ] . sgnd = ( tmp >> 7 ) & 1 ; siz -> comps [ i ] . prec = ( tmp & 0x7f ) + 1 ; } if ( jas_stream_eof ( in ) ) { jas_free ( siz -> comps ) ; return - 1 ; } return 0 ; }\n","target":"<S2SV_ModStart> uint_fast8_t tmp ; siz -> comps = 0 ; <S2SV_ModStart> ) ) { goto error ; } if ( ! siz -> width || ! siz -> height ) { jas_eprintf ( \"reference<S2SV_blank>grid<S2SV_blank>cannot<S2SV_blank>have<S2SV_blank>zero<S2SV_blank>area\\\\n\" ) ; goto error ; } if ( ! siz -> tilewidth || ! siz -> tileheight ) { jas_eprintf ( \"tile<S2SV_blank>cannot<S2SV_blank>have<S2SV_blank>zero<S2SV_blank>area\\\\n\" ) ; goto error ; } if ( ! siz -> numcomps || siz -> numcomps > 16384 ) { jas_eprintf ( \"number<S2SV_blank>of<S2SV_blank>components<S2SV_blank>not<S2SV_blank>in<S2SV_blank>permissible<S2SV_blank>range\\\\n\" ) ; goto error ; } if ( siz -> xoff >= siz -> width ) { jas_eprintf ( \"XOsiz<S2SV_blank>not<S2SV_blank>in<S2SV_blank>permissible<S2SV_blank>range\\\\n\" ) ; goto error ; } if ( siz -> yoff >= siz -> height ) { jas_eprintf ( \"YOsiz<S2SV_blank>not<S2SV_blank>in<S2SV_blank>permissible<S2SV_blank>range\\\\n\" ) ; goto error ; } if ( siz -> tilexoff > siz -> xoff || siz -> tilexoff + siz -> tilewidth <= siz -> xoff ) { jas_eprintf ( \"XTOsiz<S2SV_blank>not<S2SV_blank>in<S2SV_blank>permissible<S2SV_blank>range\\\\n\" ) ; goto error ; } if ( siz -> tileyoff > siz -> yoff || siz -> tileyoff + siz -> tileheight <= siz -> yoff ) { jas_eprintf ( \"YTOsiz<S2SV_blank>not<S2SV_blank>in<S2SV_blank>permissible<S2SV_blank>range\\\\n\" ) ; goto error ; } if ( ! ( siz -> comps = jas_alloc2 ( siz -> numcomps , sizeof ( jpc_sizcomp_t ) ) ) ) { goto error ; } for ( i = 0 ; i < siz -> numcomps ; ++ i ) { if ( jpc_getuint8 ( in , & tmp ) || jpc_getuint8 ( in , & siz -> comps [ i ] . hsamp ) || jpc_getuint8 ( in , & siz -> comps [ i ] . vsamp ) ) { goto error ; } if ( siz -> comps [ i ] . hsamp == 0 || siz -> comps [ i ] . hsamp > 255 ) { jas_eprintf ( \"invalid<S2SV_blank>XRsiz<S2SV_blank>value<S2SV_blank>%d\\\\n\" , siz -> comps [ i ] . hsamp ) ; goto error ; } if ( siz -> comps [ i ] . vsamp == 0 || siz -> comps [ i ] . vsamp > 255 ) { jas_eprintf ( \"invalid<S2SV_blank>YRsiz<S2SV_blank>value<S2SV_blank>%d\\\\n\" , siz -> comps [ i ] . vsamp ) ; goto error ; } siz -> comps [ i ] . sgnd = ( tmp >> 7 ) & 1 ; siz -> comps [ i ] . prec = ( tmp & 0x7f ) + 1 ; } if ( jas_stream_eof ( in ) ) { goto error ; } return 0 ; error : if ( siz -> comps ) { jas_free ( siz -> comps ) ; } <S2SV_ModStart> 1 ; } <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null>\n","project_and_commit_id":"mdadams@jasper/f7038068550fba0e41e1d0c355787f1dcd5bf330","cve_id":"CVE-2016-9394","original_address":"https://github.com/mdadams/jasper/commit/f7038068550fba0e41e1d0c355787f1dcd5bf330","time":"2017-03-23T18:59Z"},
	{"Unnamed: 0":248,"cwe_id":"CWE-189","source":"CWE-189 static int sanitize_ptr_alu ( struct bpf_verifier_env * env , struct bpf_insn * insn , const struct bpf_reg_state * ptr_reg , struct bpf_reg_state * dst_reg , bool off_is_neg ) { struct bpf_verifier_state * vstate = env -> cur_state ; struct bpf_insn_aux_data * aux = cur_aux ( env ) ; bool ptr_is_dst_reg = ptr_reg == dst_reg ; u8 opcode = BPF_OP ( insn -> code ) ; u32 alu_state , alu_limit ; struct bpf_reg_state tmp ; bool ret ; <S2SV_StartBug> if ( env -> allow_ptr_leaks || BPF_SRC ( insn -> code ) == BPF_K ) <S2SV_EndBug> return 0 ; if ( vstate -> speculative ) goto do_sim ; alu_state = off_is_neg ? BPF_ALU_NEG_VALUE : 0 ; alu_state |= ptr_is_dst_reg ? BPF_ALU_SANITIZE_SRC : BPF_ALU_SANITIZE_DST ; if ( retrieve_ptr_limit ( ptr_reg , & alu_limit , opcode , off_is_neg ) ) return 0 ; <S2SV_StartBug> if ( aux -> alu_state && <S2SV_EndBug> ( aux -> alu_state != alu_state || aux -> alu_limit != alu_limit ) ) <S2SV_StartBug> return - EACCES ; <S2SV_EndBug> aux -> alu_state = alu_state ; aux -> alu_limit = alu_limit ; do_sim : if ( ! ptr_is_dst_reg ) { tmp = * dst_reg ; * dst_reg = * ptr_reg ; } ret = push_stack ( env , env -> insn_idx + 1 , env -> insn_idx , true ) ; if ( ! ptr_is_dst_reg ) * dst_reg = tmp ; return ! ret ? - EFAULT : 0 ; }\n","target":"<S2SV_ModStart> ; if ( can_skip_alu_sanitation ( env , insn ) <S2SV_ModEnd> ) return 0 <S2SV_ModStart> ; if ( update_alu_sanitation_state ( aux , alu_state , <S2SV_ModEnd> alu_limit ) ) <S2SV_ModStart> return - EACCES <S2SV_ModEnd> ; do_sim :\n","project_and_commit_id":"torvalds@linux/d3bd7413e0ca40b60cf60d4003246d067cafdeda","cve_id":"CVE-2019-7308","original_address":"https://github.com/torvalds/linux/commit/d3bd7413e0ca40b60cf60d4003246d067cafdeda","time":"2019-02-01T22:29Z"},
	{"Unnamed: 0":433,"cwe_id":"CWE-119","source":"CWE-119 int main ( int argc , char * * argv ) { int frame_cnt = 0 ; FILE * outfile = NULL ; vpx_codec_ctx_t codec ; VpxVideoReader * reader = NULL ; const VpxVideoInfo * info = NULL ; const VpxInterface * decoder = NULL ; exec_name = argv [ 0 ] ; if ( argc != 3 ) die ( \"Invalid<S2SV_blank>number<S2SV_blank>of<S2SV_blank>arguments.\" ) ; reader = vpx_video_reader_open ( argv [ 1 ] ) ; if ( ! reader ) die ( \"Failed<S2SV_blank>to<S2SV_blank>open<S2SV_blank>%s<S2SV_blank>for<S2SV_blank>reading.\" , argv [ 1 ] ) ; if ( ! ( outfile = fopen ( argv [ 2 ] , \"wb\" ) ) ) die ( \"Failed<S2SV_blank>to<S2SV_blank>open<S2SV_blank>%s<S2SV_blank>for<S2SV_blank>writing.\" , argv [ 2 ] ) ; info = vpx_video_reader_get_info ( reader ) ; decoder = get_vpx_decoder_by_fourcc ( info -> codec_fourcc ) ; if ( ! decoder ) die ( \"Unknown<S2SV_blank>input<S2SV_blank>codec.\" ) ; <S2SV_StartBug> printf ( \"Using<S2SV_blank>%s\\\\n\" , vpx_codec_iface_name ( decoder -> interface ( ) ) ) ; <S2SV_EndBug> <S2SV_StartBug> if ( vpx_codec_dec_init ( & codec , decoder -> interface ( ) , NULL , 0 ) ) <S2SV_EndBug> die_codec ( & codec , \"Failed<S2SV_blank>to<S2SV_blank>initialize<S2SV_blank>decoder\" ) ; while ( vpx_video_reader_read_frame ( reader ) ) { vpx_codec_iter_t iter = NULL ; vpx_image_t * img = NULL ; size_t frame_size = 0 ; const unsigned char * frame = vpx_video_reader_get_frame ( reader , & frame_size ) ; if ( vpx_codec_decode ( & codec , frame , ( unsigned int ) frame_size , NULL , 0 ) ) die_codec ( & codec , \"Failed<S2SV_blank>to<S2SV_blank>decode<S2SV_blank>frame\" ) ; while ( ( img = vpx_codec_get_frame ( & codec , & iter ) ) != NULL ) { unsigned char digest [ 16 ] ; get_image_md5 ( img , digest ) ; print_md5 ( outfile , digest ) ; fprintf ( outfile , \"<S2SV_blank><S2SV_blank>img-%dx%d-%04d.i420\\\\n\" , img -> d_w , img -> d_h , ++ frame_cnt ) ; } } printf ( \"Processed<S2SV_blank>%d<S2SV_blank>frames.\\\\n\" , frame_cnt ) ; if ( vpx_codec_destroy ( & codec ) ) die_codec ( & codec , \"Failed<S2SV_blank>to<S2SV_blank>destroy<S2SV_blank>codec.\" ) ; vpx_video_reader_close ( reader ) ; fclose ( outfile ) ; return EXIT_SUCCESS ; }\n","target":"<S2SV_ModStart> ( decoder -> codec_interface <S2SV_ModEnd> ( ) ) <S2SV_ModStart> , decoder -> codec_interface <S2SV_ModEnd> ( ) ,\n","project_and_commit_id":"external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426","cve_id":"CVE-2016-1621","original_address":"https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426","time":"2016-03-12T21:59Z"},
	{"Unnamed: 0":2343,"cwe_id":"CWE-388","source":"CWE-388 void processRequest ( struct reqelem * req ) { ssize_t n ; unsigned int l , m ; unsigned char buf [ 2048 ] ; const unsigned char * p ; int type ; struct device * d = devlist ; unsigned char rbuf [ 4096 ] ; unsigned char * rp = rbuf + 1 ; unsigned char nrep = 0 ; time_t t ; struct service * newserv = NULL ; struct service * serv ; n = read ( req -> socket , buf , sizeof ( buf ) ) ; if ( n < 0 ) { if ( errno == EINTR || errno == EAGAIN || errno == EWOULDBLOCK ) return ; syslog ( LOG_ERR , \"(s=%d)<S2SV_blank>processRequest():<S2SV_blank>read():<S2SV_blank>%m\" , req -> socket ) ; goto error ; } if ( n == 0 ) { syslog ( LOG_INFO , \"(s=%d)<S2SV_blank>request<S2SV_blank>connection<S2SV_blank>closed\" , req -> socket ) ; goto error ; } t = time ( NULL ) ; type = buf [ 0 ] ; p = buf + 1 ; DECODELENGTH_CHECKLIMIT ( l , p , buf + n ) ; if ( p + l > buf + n ) { syslog ( LOG_WARNING , \"bad<S2SV_blank>request<S2SV_blank>(length<S2SV_blank>encoding)\" ) ; goto error ; } if ( l == 0 && type != 3 ) { syslog ( LOG_WARNING , \"bad<S2SV_blank>request<S2SV_blank>(length=0)\" ) ; goto error ; } syslog ( LOG_INFO , \"(s=%d)<S2SV_blank>request<S2SV_blank>type=%d<S2SV_blank>str=\\'%.*s\\'\" , req -> socket , type , l , p ) ; switch ( type ) { case 1 : case 2 : case 3 : while ( d && ( nrep < 255 ) ) { if ( d -> t < t ) { syslog ( LOG_INFO , \"outdated<S2SV_blank>device\" ) ; } else { if ( d -> headers [ HEADER_LOCATION ] . l + d -> headers [ HEADER_NT ] . l + d -> headers [ HEADER_USN ] . l + 6 + ( rp - rbuf ) >= ( int ) sizeof ( rbuf ) ) break ; if ( ( type == 1 && 0 == memcmp ( d -> headers [ HEADER_NT ] . p , p , l ) ) || ( type == 2 && 0 == memcmp ( d -> headers [ HEADER_USN ] . p , p , l ) ) || ( type == 3 ) ) { m = d -> headers [ HEADER_LOCATION ] . l ; CODELENGTH ( m , rp ) ; memcpy ( rp , d -> headers [ HEADER_LOCATION ] . p , d -> headers [ HEADER_LOCATION ] . l ) ; rp += d -> headers [ HEADER_LOCATION ] . l ; m = d -> headers [ HEADER_NT ] . l ; CODELENGTH ( m , rp ) ; memcpy ( rp , d -> headers [ HEADER_NT ] . p , d -> headers [ HEADER_NT ] . l ) ; rp += d -> headers [ HEADER_NT ] . l ; m = d -> headers [ HEADER_USN ] . l ; CODELENGTH ( m , rp ) ; memcpy ( rp , d -> headers [ HEADER_USN ] . p , d -> headers [ HEADER_USN ] . l ) ; rp += d -> headers [ HEADER_USN ] . l ; nrep ++ ; } } d = d -> next ; } for ( serv = servicelisthead . lh_first ; serv && ( nrep < 255 ) ; serv = serv -> entries . le_next ) { if ( strlen ( serv -> location ) + strlen ( serv -> st ) + strlen ( serv -> usn ) + 6 + ( rp - rbuf ) >= sizeof ( rbuf ) ) break ; if ( ( type == 1 && 0 == strncmp ( serv -> st , ( const char * ) p , l ) ) || ( type == 2 && 0 == strncmp ( serv -> usn , ( const char * ) p , l ) ) || ( type == 3 ) ) { m = strlen ( serv -> location ) ; CODELENGTH ( m , rp ) ; memcpy ( rp , serv -> location , m ) ; rp += m ; m = strlen ( serv -> st ) ; CODELENGTH ( m , rp ) ; memcpy ( rp , serv -> st , m ) ; rp += m ; m = strlen ( serv -> usn ) ; CODELENGTH ( m , rp ) ; memcpy ( rp , serv -> usn , m ) ; rp += m ; nrep ++ ; } } rbuf [ 0 ] = nrep ; syslog ( LOG_DEBUG , \"(s=%d)<S2SV_blank>response<S2SV_blank>:<S2SV_blank>%d<S2SV_blank>device%s\" , req -> socket , nrep , ( nrep > 1 ) ? \"s\" : \"\" ) ; if ( write ( req -> socket , rbuf , rp - rbuf ) < 0 ) { syslog ( LOG_ERR , \"(s=%d)<S2SV_blank>write:<S2SV_blank>%m\" , req -> socket ) ; goto error ; } break ; case 4 : newserv = malloc ( sizeof ( struct service ) ) ; if ( ! newserv ) { syslog ( LOG_ERR , \"cannot<S2SV_blank>allocate<S2SV_blank>memory\" ) ; goto error ; } <S2SV_StartBug> if ( containsForbiddenChars ( p , l ) ) { <S2SV_EndBug> syslog ( LOG_ERR , \"bad<S2SV_blank>request<S2SV_blank>(st<S2SV_blank>contains<S2SV_blank>forbidden<S2SV_blank>chars)\" ) ; goto error ; } newserv -> st = malloc ( l + 1 ) ; if ( ! newserv -> st ) { syslog ( LOG_ERR , \"cannot<S2SV_blank>allocate<S2SV_blank>memory\" ) ; goto error ; } memcpy ( newserv -> st , p , l ) ; newserv -> st [ l ] = '\\\\0' ; p += l ; if ( p >= buf + n ) { syslog ( LOG_WARNING , \"bad<S2SV_blank>request<S2SV_blank>(missing<S2SV_blank>usn)\" ) ; goto error ; } DECODELENGTH_CHECKLIMIT ( l , p , buf + n ) ; if ( p + l > buf + n ) { syslog ( LOG_WARNING , \"bad<S2SV_blank>request<S2SV_blank>(length<S2SV_blank>encoding)\" ) ; goto error ; } if ( containsForbiddenChars ( p , l ) ) { syslog ( LOG_ERR , \"bad<S2SV_blank>request<S2SV_blank>(usn<S2SV_blank>contains<S2SV_blank>forbidden<S2SV_blank>chars)\" ) ; goto error ; } syslog ( LOG_INFO , \"usn=\\'%.*s\\'\" , l , p ) ; newserv -> usn = malloc ( l + 1 ) ; if ( ! newserv -> usn ) { syslog ( LOG_ERR , \"cannot<S2SV_blank>allocate<S2SV_blank>memory\" ) ; goto error ; } memcpy ( newserv -> usn , p , l ) ; newserv -> usn [ l ] = '\\\\0' ; p += l ; DECODELENGTH_CHECKLIMIT ( l , p , buf + n ) ; if ( p + l > buf + n ) { syslog ( LOG_WARNING , \"bad<S2SV_blank>request<S2SV_blank>(length<S2SV_blank>encoding)\" ) ; goto error ; } if ( containsForbiddenChars ( p , l ) ) { syslog ( LOG_ERR , \"bad<S2SV_blank>request<S2SV_blank>(server<S2SV_blank>contains<S2SV_blank>forbidden<S2SV_blank>chars)\" ) ; goto error ; } syslog ( LOG_INFO , \"server=\\'%.*s\\'\" , l , p ) ; newserv -> server = malloc ( l + 1 ) ; if ( ! newserv -> server ) { syslog ( LOG_ERR , \"cannot<S2SV_blank>allocate<S2SV_blank>memory\" ) ; goto error ; } memcpy ( newserv -> server , p , l ) ; newserv -> server [ l ] = '\\\\0' ; p += l ; DECODELENGTH_CHECKLIMIT ( l , p , buf + n ) ; if ( p + l > buf + n ) { syslog ( LOG_WARNING , \"bad<S2SV_blank>request<S2SV_blank>(length<S2SV_blank>encoding)\" ) ; goto error ; } if ( containsForbiddenChars ( p , l ) ) { syslog ( LOG_ERR , \"bad<S2SV_blank>request<S2SV_blank>(location<S2SV_blank>contains<S2SV_blank>forbidden<S2SV_blank>chars)\" ) ; goto error ; } syslog ( LOG_INFO , \"location=\\'%.*s\\'\" , l , p ) ; newserv -> location = malloc ( l + 1 ) ; if ( ! newserv -> location ) { syslog ( LOG_ERR , \"cannot<S2SV_blank>allocate<S2SV_blank>memory\" ) ; goto error ; } memcpy ( newserv -> location , p , l ) ; newserv -> location [ l ] = '\\\\0' ; for ( serv = servicelisthead . lh_first ; serv ; serv = serv -> entries . le_next ) { if ( 0 == strcmp ( newserv -> usn , serv -> usn ) && 0 == strcmp ( newserv -> st , serv -> st ) ) { syslog ( LOG_INFO , \"Service<S2SV_blank>allready<S2SV_blank>in<S2SV_blank>the<S2SV_blank>list.<S2SV_blank>Updating...\" ) ; free ( newserv -> st ) ; free ( newserv -> usn ) ; free ( serv -> server ) ; serv -> server = newserv -> server ; free ( serv -> location ) ; serv -> location = newserv -> location ; free ( newserv ) ; newserv = NULL ; return ; } } LIST_INSERT_HEAD ( & servicelisthead , newserv , entries ) ; newserv = NULL ; break ; default : syslog ( LOG_WARNING , \"Unknown<S2SV_blank>request<S2SV_blank>type<S2SV_blank>%d\" , type ) ; rbuf [ 0 ] = '\\\\0' ; if ( write ( req -> socket , rbuf , 1 ) < 0 ) { syslog ( LOG_ERR , \"(s=%d)<S2SV_blank>write:<S2SV_blank>%m\" , req -> socket ) ; goto error ; } } return ; error : if ( newserv ) { free ( newserv -> st ) ; free ( newserv -> usn ) ; free ( newserv -> server ) ; free ( newserv -> location ) ; free ( newserv ) ; newserv = NULL ; } close ( req -> socket ) ; req -> socket = - 1 ; return ; }\n","target":"<S2SV_ModStart> error ; } memset ( newserv , 0 , sizeof ( struct service ) ) ;\n","project_and_commit_id":"miniupnp@miniupnp/140ee8d2204b383279f854802b27bdb41c1d5d1a","cve_id":"CVE-2016-3179","original_address":"https://github.com/miniupnp/miniupnp/commit/140ee8d2204b383279f854802b27bdb41c1d5d1a","time":"2017-03-24T15:59Z"},
	{"Unnamed: 0":87,"cwe_id":"CWE-119","source":"CWE-119 static int tt_s2_4600_frontend_attach ( struct dvb_usb_adapter * adap ) { struct dvb_usb_device * d = adap -> dev ; <S2SV_StartBug> struct dw2102_state * state = d -> priv ; <S2SV_EndBug> u8 obuf [ 3 ] = { 0xe , 0x80 , 0 } ; u8 ibuf [ ] = { 0 } ; struct i2c_adapter * i2c_adapter ; struct i2c_client * client ; struct i2c_board_info board_info ; struct m88ds3103_platform_data m88ds3103_pdata = { } ; struct ts2020_config ts2020_config = { } ; <S2SV_StartBug> if ( dvb_usb_generic_rw ( d , obuf , 3 , ibuf , 1 , 0 ) < 0 ) <S2SV_EndBug> err ( \"command<S2SV_blank>0x0e<S2SV_blank>transfer<S2SV_blank>failed.\" ) ; <S2SV_StartBug> obuf [ 0 ] = 0xe ; <S2SV_EndBug> <S2SV_StartBug> obuf [ 1 ] = 0x02 ; <S2SV_EndBug> <S2SV_StartBug> obuf [ 2 ] = 1 ; <S2SV_EndBug> <S2SV_StartBug> if ( dvb_usb_generic_rw ( d , obuf , 3 , ibuf , 1 , 0 ) < 0 ) <S2SV_EndBug> err ( \"command<S2SV_blank>0x0e<S2SV_blank>transfer<S2SV_blank>failed.\" ) ; msleep ( 300 ) ; <S2SV_StartBug> obuf [ 0 ] = 0xe ; <S2SV_EndBug> <S2SV_StartBug> obuf [ 1 ] = 0x83 ; <S2SV_EndBug> <S2SV_StartBug> obuf [ 2 ] = 0 ; <S2SV_EndBug> <S2SV_StartBug> if ( dvb_usb_generic_rw ( d , obuf , 3 , ibuf , 1 , 0 ) < 0 ) <S2SV_EndBug> err ( \"command<S2SV_blank>0x0e<S2SV_blank>transfer<S2SV_blank>failed.\" ) ; <S2SV_StartBug> obuf [ 0 ] = 0xe ; <S2SV_EndBug> <S2SV_StartBug> obuf [ 1 ] = 0x83 ; <S2SV_EndBug> <S2SV_StartBug> obuf [ 2 ] = 1 ; <S2SV_EndBug> <S2SV_StartBug> if ( dvb_usb_generic_rw ( d , obuf , 3 , ibuf , 1 , 0 ) < 0 ) <S2SV_EndBug> err ( \"command<S2SV_blank>0x0e<S2SV_blank>transfer<S2SV_blank>failed.\" ) ; <S2SV_StartBug> obuf [ 0 ] = 0x51 ; <S2SV_EndBug> <S2SV_StartBug> if ( dvb_usb_generic_rw ( d , obuf , 1 , ibuf , 1 , 0 ) < 0 ) <S2SV_EndBug> <S2SV_StartBug> err ( \"command<S2SV_blank>0x51<S2SV_blank>transfer<S2SV_blank>failed.\" ) ; <S2SV_EndBug> m88ds3103_pdata . clk = 27000000 ; m88ds3103_pdata . i2c_wr_max = 33 ; m88ds3103_pdata . ts_mode = M88DS3103_TS_CI ; m88ds3103_pdata . ts_clk = 16000 ; m88ds3103_pdata . ts_clk_pol = 0 ; m88ds3103_pdata . spec_inv = 0 ; m88ds3103_pdata . agc = 0x99 ; m88ds3103_pdata . agc_inv = 0 ; m88ds3103_pdata . clk_out = M88DS3103_CLOCK_OUT_ENABLED ; m88ds3103_pdata . envelope_mode = 0 ; m88ds3103_pdata . lnb_hv_pol = 1 ; m88ds3103_pdata . lnb_en_pol = 0 ; memset ( & board_info , 0 , sizeof ( board_info ) ) ; strlcpy ( board_info . type , \"m88ds3103\" , I2C_NAME_SIZE ) ; board_info . addr = 0x68 ; board_info . platform_data = & m88ds3103_pdata ; request_module ( \"m88ds3103\" ) ; client = i2c_new_device ( & d -> i2c_adap , & board_info ) ; if ( client == NULL || client -> dev . driver == NULL ) return - ENODEV ; if ( ! try_module_get ( client -> dev . driver -> owner ) ) { i2c_unregister_device ( client ) ; return - ENODEV ; } adap -> fe_adap [ 0 ] . fe = m88ds3103_pdata . get_dvb_frontend ( client ) ; i2c_adapter = m88ds3103_pdata . get_i2c_adapter ( client ) ; state -> i2c_client_demod = client ; ts2020_config . fe = adap -> fe_adap [ 0 ] . fe ; memset ( & board_info , 0 , sizeof ( board_info ) ) ; strlcpy ( board_info . type , \"ts2022\" , I2C_NAME_SIZE ) ; board_info . addr = 0x60 ; board_info . platform_data = & ts2020_config ; request_module ( \"ts2020\" ) ; client = i2c_new_device ( i2c_adapter , & board_info ) ; if ( client == NULL || client -> dev . driver == NULL ) { dvb_frontend_detach ( adap -> fe_adap [ 0 ] . fe ) ; return - ENODEV ; } if ( ! try_module_get ( client -> dev . driver -> owner ) ) { i2c_unregister_device ( client ) ; dvb_frontend_detach ( adap -> fe_adap [ 0 ] . fe ) ; return - ENODEV ; } adap -> fe_adap [ 0 ] . fe -> ops . read_signal_strength = adap -> fe_adap [ 0 ] . fe -> ops . tuner_ops . get_rf_strength ; state -> i2c_client_tuner = client ; state -> fe_read_status = adap -> fe_adap [ 0 ] . fe -> ops . read_status ; adap -> fe_adap [ 0 ] . fe -> ops . read_status = tt_s2_4600_read_status ; state -> last_lock = 0 ; return 0 ; }\n","target":"<S2SV_ModStart> d -> priv <S2SV_ModEnd> ; struct i2c_adapter <S2SV_ModStart> { } ; mutex_lock ( & d -> data_mutex ) ; state -> data [ 0 ] = 0xe ; state -> data [ 1 ] = 0x80 ; state -> data [ 2 ] = 0x0 ; <S2SV_ModStart> ( d , state -> data <S2SV_ModEnd> , 3 , <S2SV_ModStart> , 3 , state -> data <S2SV_ModEnd> , 1 , <S2SV_ModStart> \"command<S2SV_blank>0x0e<S2SV_blank>transfer<S2SV_blank>failed.\" ) ; state -> data <S2SV_ModEnd> [ 0 ] <S2SV_ModStart> = 0xe ; state -> data <S2SV_ModEnd> [ 1 ] <S2SV_ModStart> = 0x02 ; state -> data <S2SV_ModEnd> [ 2 ] <S2SV_ModStart> ( d , state -> data <S2SV_ModEnd> , 3 , <S2SV_ModStart> , 3 , state -> data <S2SV_ModEnd> , 1 , <S2SV_ModStart> 300 ) ; state -> data <S2SV_ModEnd> [ 0 ] <S2SV_ModStart> = 0xe ; state -> data <S2SV_ModEnd> [ 1 ] <S2SV_ModStart> = 0x83 ; state -> data <S2SV_ModEnd> [ 2 ] <S2SV_ModStart> ( d , state -> data <S2SV_ModEnd> , 3 , <S2SV_ModStart> , 3 , state -> data <S2SV_ModEnd> , 1 , <S2SV_ModStart> \"command<S2SV_blank>0x0e<S2SV_blank>transfer<S2SV_blank>failed.\" ) ; state -> data <S2SV_ModEnd> [ 0 ] <S2SV_ModStart> = 0xe ; state -> data <S2SV_ModEnd> [ 1 ] <S2SV_ModStart> = 0x83 ; state -> data <S2SV_ModEnd> [ 2 ] <S2SV_ModStart> ( d , state -> data <S2SV_ModEnd> , 3 , <S2SV_ModStart> , 3 , state -> data <S2SV_ModEnd> , 1 , <S2SV_ModStart> \"command<S2SV_blank>0x0e<S2SV_blank>transfer<S2SV_blank>failed.\" ) ; state -> data <S2SV_ModEnd> [ 0 ] <S2SV_ModStart> ( d , state -> data , 1 , state -> data <S2SV_ModEnd> , 1 , <S2SV_ModStart> err ( \"command<S2SV_blank>0x51<S2SV_blank>transfer<S2SV_blank>failed.\" ) ; mutex_unlock ( & d -> data_mutex\n","project_and_commit_id":"torvalds@linux/606142af57dad981b78707234cfbd15f9f7b7125","cve_id":"CVE-2017-8062","original_address":"https://github.com/torvalds/linux/commit/606142af57dad981b78707234cfbd15f9f7b7125","time":"2017-04-23T05:59Z"},
	{"Unnamed: 0":1993,"cwe_id":"CWE-59","source":"CWE-59 void lxc_execute_bind_init ( struct lxc_conf * conf ) { int ret ; char path [ PATH_MAX ] , destpath [ PATH_MAX ] , * p ; p = choose_init ( conf -> rootfs . mount ) ; if ( p ) { free ( p ) ; return ; } ret = snprintf ( path , PATH_MAX , SBINDIR \"/init.lxc.static\" ) ; if ( ret < 0 || ret >= PATH_MAX ) { WARN ( \"Path<S2SV_blank>name<S2SV_blank>too<S2SV_blank>long<S2SV_blank>searching<S2SV_blank>for<S2SV_blank>lxc.init.static\" ) ; return ; } if ( ! file_exists ( path ) ) { INFO ( \"%s<S2SV_blank>does<S2SV_blank>not<S2SV_blank>exist<S2SV_blank>on<S2SV_blank>host\" , path ) ; return ; } ret = snprintf ( destpath , PATH_MAX , \"%s%s\" , conf -> rootfs . mount , \"/init.lxc.static\" ) ; if ( ret < 0 || ret >= PATH_MAX ) { WARN ( \"Path<S2SV_blank>name<S2SV_blank>too<S2SV_blank>long<S2SV_blank>for<S2SV_blank>container\\'s<S2SV_blank>lxc.init.static\" ) ; return ; } if ( ! file_exists ( destpath ) ) { FILE * pathfile = fopen ( destpath , \"wb\" ) ; if ( ! pathfile ) { SYSERROR ( \"Failed<S2SV_blank>to<S2SV_blank>create<S2SV_blank>mount<S2SV_blank>target<S2SV_blank>\\'%s\\'\" , destpath ) ; return ; } fclose ( pathfile ) ; } <S2SV_StartBug> ret = mount ( path , destpath , \"none\" , MS_BIND , NULL ) ; <S2SV_EndBug> if ( ret < 0 ) SYSERROR ( \"Failed<S2SV_blank>to<S2SV_blank>bind<S2SV_blank>lxc.init.static<S2SV_blank>into<S2SV_blank>container\" ) ; INFO ( \"lxc.init.static<S2SV_blank>bound<S2SV_blank>into<S2SV_blank>container<S2SV_blank>at<S2SV_blank>%s\" , path ) ; }\n","target":"<S2SV_ModStart> } ret = safe_mount ( path , destpath , \"none\" , MS_BIND , NULL , conf -> rootfs . mount <S2SV_ModEnd> ) ; if\n","project_and_commit_id":"lxc@lxc/592fd47a6245508b79fe6ac819fe6d3b2c1289be","cve_id":"CVE-2015-1335","original_address":"https://github.com/lxc/lxc/commit/592fd47a6245508b79fe6ac819fe6d3b2c1289be","time":"2015-10-01T20:59Z"},
	{"Unnamed: 0":1252,"cwe_id":"CWE-120","source":"CWE-120 int read_fru_area ( struct ipmi_intf * intf , struct fru_info * fru , uint8_t id , uint32_t offset , uint32_t length , uint8_t * frubuf ) { <S2SV_StartBug> uint32_t off = offset , tmp , finish ; <S2SV_EndBug> struct ipmi_rs * rsp ; struct ipmi_rq req ; uint8_t msg_data [ 4 ] ; if ( offset > fru -> size ) { lprintf ( LOG_ERR , \"Read<S2SV_blank>FRU<S2SV_blank>Area<S2SV_blank>offset<S2SV_blank>incorrect:<S2SV_blank>%d<S2SV_blank>><S2SV_blank>%d\" , offset , fru -> size ) ; return - 1 ; } finish = offset + length ; if ( finish > fru -> size ) { <S2SV_StartBug> finish = fru -> size ; <S2SV_EndBug> lprintf ( LOG_NOTICE , \"Read<S2SV_blank>FRU<S2SV_blank>Area<S2SV_blank>length<S2SV_blank>%d<S2SV_blank>too<S2SV_blank>large,<S2SV_blank>\" \"Adjusting<S2SV_blank>to<S2SV_blank>%d\" , offset + length , finish - offset ) ; <S2SV_StartBug> } <S2SV_EndBug> memset ( & req , 0 , sizeof ( req ) ) ; req . msg . netfn = IPMI_NETFN_STORAGE ; req . msg . cmd = GET_FRU_DATA ; req . msg . data = msg_data ; req . msg . data_len = 4 ; if ( fru -> max_read_size == 0 ) { uint16_t max_rs_size = ipmi_intf_get_max_response_data_size ( intf ) - 1 ; if ( max_rs_size <= 1 ) { lprintf ( LOG_ERROR , \"Maximum<S2SV_blank>response<S2SV_blank>size<S2SV_blank>is<S2SV_blank>too<S2SV_blank>small<S2SV_blank>to<S2SV_blank>send<S2SV_blank>\" \"a<S2SV_blank>read<S2SV_blank>request\" ) ; return - 1 ; } if ( max_rs_size - 1 > 255 ) { fru -> max_read_size = 255 ; } else { fru -> max_read_size = max_rs_size - 1 ; } if ( fru -> access ) { fru -> max_read_size &= ~ 1 ; } } <S2SV_StartBug> do { <S2SV_EndBug> tmp = fru -> access ? off >> 1 : off ; msg_data [ 0 ] = id ; msg_data [ 1 ] = ( uint8_t ) ( tmp & 0xff ) ; msg_data [ 2 ] = ( uint8_t ) ( tmp >> 8 ) ; tmp = finish - off ; if ( tmp > fru -> max_read_size ) msg_data [ 3 ] = ( uint8_t ) fru -> max_read_size ; else msg_data [ 3 ] = ( uint8_t ) tmp ; rsp = intf -> sendrecv ( intf , & req ) ; if ( ! rsp ) { lprintf ( LOG_NOTICE , \"FRU<S2SV_blank>Read<S2SV_blank>failed\" ) ; break ; } if ( rsp -> ccode ) { if ( fru_cc_rq2big ( rsp -> ccode ) && fru -> max_read_size > FRU_BLOCK_SZ ) { if ( fru -> max_read_size > FRU_AREA_MAXIMUM_BLOCK_SZ ) { fru -> max_read_size -= FRU_BLOCK_SZ ; } else { fru -> max_read_size -- ; } lprintf ( LOG_INFO , \"Retrying<S2SV_blank>FRU<S2SV_blank>read<S2SV_blank>with<S2SV_blank>request<S2SV_blank>size<S2SV_blank>%d\" , fru -> max_read_size ) ; continue ; } lprintf ( LOG_NOTICE , \"FRU<S2SV_blank>Read<S2SV_blank>failed:<S2SV_blank>%s\" , val2str ( rsp -> ccode , completion_code_vals ) ) ; break ; } tmp = fru -> access ? rsp -> data [ 0 ] << 1 : rsp -> data [ 0 ] ; <S2SV_StartBug> memcpy ( frubuf , rsp -> data + 1 , tmp ) ; <S2SV_EndBug> off += tmp ; frubuf += tmp ; <S2SV_StartBug> if ( tmp == 0 && off < finish ) { <S2SV_EndBug> return 0 ; } } while ( off < finish ) ; if ( off < finish ) { return - 1 ; } return 0 ; }\n","target":"<S2SV_ModStart> off = offset ; uint32_t tmp ; uint32_t finish ; uint32_t size_left_in_buffer <S2SV_ModEnd> ; struct ipmi_rs <S2SV_ModStart> size ) { memset ( frubuf + fru -> size , 0 , length - fru -> size ) ; <S2SV_ModStart> offset ) ; length = finish - offset ; <S2SV_ModStart> ; } } size_left_in_buffer = length ; <S2SV_ModStart> 0 ] ; if ( rsp -> data_len < 1 || tmp > rsp -> data_len - 1 || tmp > size_left_in_buffer ) { printf ( \"<S2SV_blank>Not<S2SV_blank>enough<S2SV_blank>buffer<S2SV_blank>size\" ) ; return - 1 ; } <S2SV_ModStart> += tmp ; size_left_in_buffer -= tmp ;\n","project_and_commit_id":"ipmitool@ipmitool/e824c23316ae50beb7f7488f2055ac65e8b341f2","cve_id":"CVE-2020-5208","original_address":"https://github.com/ipmitool/ipmitool/commit/e824c23316ae50beb7f7488f2055ac65e8b341f2","time":"2020-02-05T14:15Z"},
	{"Unnamed: 0":3668,"cwe_id":"CWE-125","source":"CWE-125 int sctp_load_addresses_from_init ( struct sctp_tcb * stcb , struct mbuf * m , int offset , int limit , struct sockaddr * src , struct sockaddr * dst , struct sockaddr * altsa , uint16_t port ) { struct sctp_inpcb * inp ; struct sctp_nets * net , * nnet , * net_tmp ; struct sctp_paramhdr * phdr , param_buf ; struct sctp_tcb * stcb_tmp ; uint16_t ptype , plen ; struct sockaddr * sa ; uint8_t random_store [ SCTP_PARAM_BUFFER_SIZE ] ; struct sctp_auth_random * p_random = NULL ; uint16_t random_len = 0 ; uint8_t hmacs_store [ SCTP_PARAM_BUFFER_SIZE ] ; struct sctp_auth_hmac_algo * hmacs = NULL ; uint16_t hmacs_len = 0 ; uint8_t saw_asconf = 0 ; uint8_t saw_asconf_ack = 0 ; uint8_t chunks_store [ SCTP_PARAM_BUFFER_SIZE ] ; struct sctp_auth_chunk_list * chunks = NULL ; uint16_t num_chunks = 0 ; sctp_key_t * new_key ; uint32_t keylen ; int got_random = 0 , got_hmacs = 0 , got_chklist = 0 ; uint8_t peer_supports_ecn ; uint8_t peer_supports_prsctp ; uint8_t peer_supports_auth ; uint8_t peer_supports_asconf ; uint8_t peer_supports_asconf_ack ; uint8_t peer_supports_reconfig ; uint8_t peer_supports_nrsack ; uint8_t peer_supports_pktdrop ; uint8_t peer_supports_idata ; # ifdef INET struct sockaddr_in sin ; # endif # ifdef INET6 struct sockaddr_in6 sin6 ; # endif # ifdef INET memset ( & sin , 0 , sizeof ( sin ) ) ; sin . sin_family = AF_INET ; # ifdef HAVE_SIN_LEN sin . sin_len = sizeof ( sin ) ; # endif sin . sin_port = stcb -> rport ; # endif # ifdef INET6 memset ( & sin6 , 0 , sizeof ( sin6 ) ) ; sin6 . sin6_family = AF_INET6 ; # ifdef HAVE_SIN6_LEN sin6 . sin6_len = sizeof ( struct sockaddr_in6 ) ; # endif sin6 . sin6_port = stcb -> rport ; # endif if ( altsa ) { sa = altsa ; } else { sa = src ; } peer_supports_idata = 0 ; peer_supports_ecn = 0 ; peer_supports_prsctp = 0 ; peer_supports_auth = 0 ; peer_supports_asconf = 0 ; peer_supports_reconfig = 0 ; peer_supports_nrsack = 0 ; peer_supports_pktdrop = 0 ; TAILQ_FOREACH ( net , & stcb -> asoc . nets , sctp_next ) { net -> dest_state |= SCTP_ADDR_NOT_IN_ASSOC ; } inp = stcb -> sctp_ep ; atomic_add_int ( & stcb -> asoc . refcnt , 1 ) ; stcb_tmp = sctp_findassociation_ep_addr ( & inp , sa , & net_tmp , dst , stcb ) ; atomic_add_int ( & stcb -> asoc . refcnt , - 1 ) ; if ( ( stcb_tmp == NULL && inp == stcb -> sctp_ep ) || inp == NULL ) { switch ( sa -> sa_family ) { # ifdef INET case AF_INET : if ( stcb -> asoc . scope . ipv4_addr_legal ) { if ( sctp_add_remote_addr ( stcb , sa , NULL , port , SCTP_DONOT_SETSCOPE , SCTP_LOAD_ADDR_2 ) ) { return ( - 1 ) ; } } break ; # endif # ifdef INET6 case AF_INET6 : if ( stcb -> asoc . scope . ipv6_addr_legal ) { if ( sctp_add_remote_addr ( stcb , sa , NULL , port , SCTP_DONOT_SETSCOPE , SCTP_LOAD_ADDR_3 ) ) { return ( - 2 ) ; } } break ; # endif # if defined ( __Userspace__ ) case AF_CONN : if ( stcb -> asoc . scope . conn_addr_legal ) { if ( sctp_add_remote_addr ( stcb , sa , NULL , port , SCTP_DONOT_SETSCOPE , SCTP_LOAD_ADDR_3 ) ) { return ( - 2 ) ; } } break ; # endif default : break ; } } else { if ( net_tmp != NULL && stcb_tmp == stcb ) { net_tmp -> dest_state &= ~ SCTP_ADDR_NOT_IN_ASSOC ; } else if ( stcb_tmp != stcb ) { if ( stcb_tmp ) SCTP_TCB_UNLOCK ( stcb_tmp ) ; return ( - 3 ) ; } } if ( stcb -> asoc . state == 0 ) { return ( - 4 ) ; } phdr = sctp_get_next_param ( m , offset , & param_buf , sizeof ( param_buf ) ) ; while ( phdr ) { ptype = ntohs ( phdr -> param_type ) ; plen = ntohs ( phdr -> param_length ) ; if ( offset + plen > limit ) { break ; } <S2SV_StartBug> if ( plen == 0 ) { <S2SV_EndBug> break ; } # ifdef INET if ( ptype == SCTP_IPV4_ADDRESS ) { if ( stcb -> asoc . scope . ipv4_addr_legal ) { struct sctp_ipv4addr_param * p4 , p4_buf ; phdr = sctp_get_next_param ( m , offset , ( struct sctp_paramhdr * ) & p4_buf , sizeof ( p4_buf ) ) ; if ( plen != sizeof ( struct sctp_ipv4addr_param ) || phdr == NULL ) { return ( - 5 ) ; } p4 = ( struct sctp_ipv4addr_param * ) phdr ; sin . sin_addr . s_addr = p4 -> addr ; if ( IN_MULTICAST ( ntohl ( sin . sin_addr . s_addr ) ) ) { goto next_param ; } if ( ( sin . sin_addr . s_addr == INADDR_BROADCAST ) || ( sin . sin_addr . s_addr == INADDR_ANY ) ) { goto next_param ; } sa = ( struct sockaddr * ) & sin ; inp = stcb -> sctp_ep ; atomic_add_int ( & stcb -> asoc . refcnt , 1 ) ; stcb_tmp = sctp_findassociation_ep_addr ( & inp , sa , & net , dst , stcb ) ; atomic_add_int ( & stcb -> asoc . refcnt , - 1 ) ; if ( ( stcb_tmp == NULL && inp == stcb -> sctp_ep ) || inp == NULL ) { add_it_now : if ( stcb -> asoc . state == 0 ) { return ( - 7 ) ; } if ( sctp_add_remote_addr ( stcb , sa , NULL , port , SCTP_DONOT_SETSCOPE , SCTP_LOAD_ADDR_4 ) ) { return ( - 8 ) ; } } else if ( stcb_tmp == stcb ) { if ( stcb -> asoc . state == 0 ) { return ( - 10 ) ; } if ( net != NULL ) { net -> dest_state &= ~ SCTP_ADDR_NOT_IN_ASSOC ; } } else { if ( stcb_tmp ) { if ( SCTP_GET_STATE ( stcb_tmp ) == SCTP_STATE_COOKIE_WAIT ) { struct mbuf * op_err ; char msg [ SCTP_DIAG_INFO_LEN ] ; snprintf ( msg , sizeof ( msg ) , \"%s:%d<S2SV_blank>at<S2SV_blank>%s\" , __FILE__ , __LINE__ , __func__ ) ; op_err = sctp_generate_cause ( SCTP_BASE_SYSCTL ( sctp_diag_info_code ) , msg ) ; sctp_abort_an_association ( stcb_tmp -> sctp_ep , stcb_tmp , op_err , SCTP_SO_NOT_LOCKED ) ; goto add_it_now ; } SCTP_TCB_UNLOCK ( stcb_tmp ) ; } if ( stcb -> asoc . state == 0 ) { return ( - 12 ) ; } return ( - 13 ) ; } } } else # endif # ifdef INET6 if ( ptype == SCTP_IPV6_ADDRESS ) { if ( stcb -> asoc . scope . ipv6_addr_legal ) { struct sctp_ipv6addr_param * p6 , p6_buf ; phdr = sctp_get_next_param ( m , offset , ( struct sctp_paramhdr * ) & p6_buf , sizeof ( p6_buf ) ) ; if ( plen != sizeof ( struct sctp_ipv6addr_param ) || phdr == NULL ) { return ( - 14 ) ; } p6 = ( struct sctp_ipv6addr_param * ) phdr ; memcpy ( ( caddr_t ) & sin6 . sin6_addr , p6 -> addr , sizeof ( p6 -> addr ) ) ; if ( IN6_IS_ADDR_MULTICAST ( & sin6 . sin6_addr ) ) { goto next_param ; } if ( IN6_IS_ADDR_LINKLOCAL ( & sin6 . sin6_addr ) ) { goto next_param ; } sa = ( struct sockaddr * ) & sin6 ; inp = stcb -> sctp_ep ; atomic_add_int ( & stcb -> asoc . refcnt , 1 ) ; stcb_tmp = sctp_findassociation_ep_addr ( & inp , sa , & net , dst , stcb ) ; atomic_add_int ( & stcb -> asoc . refcnt , - 1 ) ; if ( stcb_tmp == NULL && ( inp == stcb -> sctp_ep || inp == NULL ) ) { add_it_now6 : if ( stcb -> asoc . state == 0 ) { return ( - 16 ) ; } if ( sctp_add_remote_addr ( stcb , sa , NULL , port , SCTP_DONOT_SETSCOPE , SCTP_LOAD_ADDR_5 ) ) { return ( - 17 ) ; } } else if ( stcb_tmp == stcb ) { if ( stcb -> asoc . state == 0 ) { return ( - 19 ) ; } if ( net != NULL ) { net -> dest_state &= ~ SCTP_ADDR_NOT_IN_ASSOC ; } } else { if ( stcb_tmp ) { if ( SCTP_GET_STATE ( stcb_tmp ) == SCTP_STATE_COOKIE_WAIT ) { struct mbuf * op_err ; char msg [ SCTP_DIAG_INFO_LEN ] ; snprintf ( msg , sizeof ( msg ) , \"%s:%d<S2SV_blank>at<S2SV_blank>%s\" , __FILE__ , __LINE__ , __func__ ) ; op_err = sctp_generate_cause ( SCTP_BASE_SYSCTL ( sctp_diag_info_code ) , msg ) ; sctp_abort_an_association ( stcb_tmp -> sctp_ep , stcb_tmp , op_err , SCTP_SO_NOT_LOCKED ) ; goto add_it_now6 ; } SCTP_TCB_UNLOCK ( stcb_tmp ) ; } if ( stcb -> asoc . state == 0 ) { return ( - 21 ) ; } return ( - 22 ) ; } } } else # endif if ( ptype == SCTP_ECN_CAPABLE ) { peer_supports_ecn = 1 ; } else if ( ptype == SCTP_ULP_ADAPTATION ) { if ( stcb -> asoc . state != SCTP_STATE_OPEN ) { struct sctp_adaptation_layer_indication ai , * aip ; phdr = sctp_get_next_param ( m , offset , ( struct sctp_paramhdr * ) & ai , sizeof ( ai ) ) ; aip = ( struct sctp_adaptation_layer_indication * ) phdr ; if ( aip ) { stcb -> asoc . peers_adaptation = ntohl ( aip -> indication ) ; stcb -> asoc . adaptation_needed = 1 ; } } } else if ( ptype == SCTP_SET_PRIM_ADDR ) { struct sctp_asconf_addr_param lstore , * fee ; int lptype ; struct sockaddr * lsa = NULL ; # ifdef INET struct sctp_asconf_addrv4_param * fii ; # endif if ( stcb -> asoc . asconf_supported == 0 ) { return ( - 100 ) ; } if ( plen > sizeof ( lstore ) ) { return ( - 23 ) ; } <S2SV_StartBug> phdr = sctp_get_next_param ( m , offset , <S2SV_EndBug> ( struct sctp_paramhdr * ) & lstore , plen ) ; if ( phdr == NULL ) { return ( - 24 ) ; } fee = ( struct sctp_asconf_addr_param * ) phdr ; lptype = ntohs ( fee -> addrp . ph . param_type ) ; switch ( lptype ) { # ifdef INET case SCTP_IPV4_ADDRESS : if ( plen != sizeof ( struct sctp_asconf_addrv4_param ) ) { SCTP_PRINTF ( \"Sizeof<S2SV_blank>setprim<S2SV_blank>in<S2SV_blank>init/init<S2SV_blank>ack<S2SV_blank>not<S2SV_blank>%d<S2SV_blank>but<S2SV_blank>%d<S2SV_blank>-<S2SV_blank>ignored\\\\n\" , ( int ) sizeof ( struct sctp_asconf_addrv4_param ) , plen ) ; } else { fii = ( struct sctp_asconf_addrv4_param * ) fee ; sin . sin_addr . s_addr = fii -> addrp . addr ; lsa = ( struct sockaddr * ) & sin ; } break ; # endif # ifdef INET6 case SCTP_IPV6_ADDRESS : if ( plen != sizeof ( struct sctp_asconf_addr_param ) ) { SCTP_PRINTF ( \"Sizeof<S2SV_blank>setprim<S2SV_blank>(v6)<S2SV_blank>in<S2SV_blank>init/init<S2SV_blank>ack<S2SV_blank>not<S2SV_blank>%d<S2SV_blank>but<S2SV_blank>%d<S2SV_blank>-<S2SV_blank>ignored\\\\n\" , ( int ) sizeof ( struct sctp_asconf_addr_param ) , plen ) ; } else { memcpy ( sin6 . sin6_addr . s6_addr , fee -> addrp . addr , sizeof ( fee -> addrp . addr ) ) ; lsa = ( struct sockaddr * ) & sin6 ; } break ; # endif default : break ; } if ( lsa ) { ( void ) sctp_set_primary_addr ( stcb , sa , NULL ) ; } } else if ( ptype == SCTP_HAS_NAT_SUPPORT ) { stcb -> asoc . peer_supports_nat = 1 ; } else if ( ptype == SCTP_PRSCTP_SUPPORTED ) { peer_supports_prsctp = 1 ; } else if ( ptype == SCTP_SUPPORTED_CHUNK_EXT ) { struct sctp_supported_chunk_types_param * pr_supported ; uint8_t local_store [ SCTP_PARAM_BUFFER_SIZE ] ; int num_ent , i ; if ( plen > sizeof ( local_store ) ) { return ( - 35 ) ; } phdr = sctp_get_next_param ( m , offset , ( struct sctp_paramhdr * ) & local_store , plen ) ; if ( phdr == NULL ) { return ( - 25 ) ; } pr_supported = ( struct sctp_supported_chunk_types_param * ) phdr ; num_ent = plen - sizeof ( struct sctp_paramhdr ) ; for ( i = 0 ; i < num_ent ; i ++ ) { switch ( pr_supported -> chunk_types [ i ] ) { case SCTP_ASCONF : peer_supports_asconf = 1 ; break ; case SCTP_ASCONF_ACK : peer_supports_asconf_ack = 1 ; break ; case SCTP_FORWARD_CUM_TSN : peer_supports_prsctp = 1 ; break ; case SCTP_PACKET_DROPPED : peer_supports_pktdrop = 1 ; break ; case SCTP_NR_SELECTIVE_ACK : peer_supports_nrsack = 1 ; break ; case SCTP_STREAM_RESET : peer_supports_reconfig = 1 ; break ; case SCTP_AUTHENTICATION : peer_supports_auth = 1 ; break ; case SCTP_IDATA : peer_supports_idata = 1 ; break ; default : break ; } } } else if ( ptype == SCTP_RANDOM ) { if ( plen > sizeof ( random_store ) ) break ; if ( got_random ) { goto next_param ; } phdr = sctp_get_next_param ( m , offset , ( struct sctp_paramhdr * ) random_store , plen ) ; if ( phdr == NULL ) return ( - 26 ) ; p_random = ( struct sctp_auth_random * ) phdr ; random_len = plen - sizeof ( * p_random ) ; if ( random_len != SCTP_AUTH_RANDOM_SIZE_REQUIRED ) { SCTPDBG ( SCTP_DEBUG_AUTH1 , \"SCTP:<S2SV_blank>invalid<S2SV_blank>RANDOM<S2SV_blank>len\\\\n\" ) ; return ( - 27 ) ; } got_random = 1 ; } else if ( ptype == SCTP_HMAC_LIST ) { uint16_t num_hmacs ; uint16_t i ; if ( plen > sizeof ( hmacs_store ) ) break ; if ( got_hmacs ) { goto next_param ; } phdr = sctp_get_next_param ( m , offset , ( struct sctp_paramhdr * ) hmacs_store , plen ) ; if ( phdr == NULL ) return ( - 28 ) ; hmacs = ( struct sctp_auth_hmac_algo * ) phdr ; hmacs_len = plen - sizeof ( * hmacs ) ; num_hmacs = hmacs_len / sizeof ( hmacs -> hmac_ids [ 0 ] ) ; if ( sctp_verify_hmac_param ( hmacs , num_hmacs ) ) { return ( - 29 ) ; } if ( stcb -> asoc . peer_hmacs != NULL ) sctp_free_hmaclist ( stcb -> asoc . peer_hmacs ) ; stcb -> asoc . peer_hmacs = sctp_alloc_hmaclist ( num_hmacs ) ; if ( stcb -> asoc . peer_hmacs != NULL ) { for ( i = 0 ; i < num_hmacs ; i ++ ) { ( void ) sctp_auth_add_hmacid ( stcb -> asoc . peer_hmacs , ntohs ( hmacs -> hmac_ids [ i ] ) ) ; } } got_hmacs = 1 ; } else if ( ptype == SCTP_CHUNK_LIST ) { int i ; if ( plen > sizeof ( chunks_store ) ) break ; if ( got_chklist ) { goto next_param ; } phdr = sctp_get_next_param ( m , offset , ( struct sctp_paramhdr * ) chunks_store , plen ) ; if ( phdr == NULL ) return ( - 30 ) ; chunks = ( struct sctp_auth_chunk_list * ) phdr ; num_chunks = plen - sizeof ( * chunks ) ; if ( stcb -> asoc . peer_auth_chunks != NULL ) sctp_clear_chunklist ( stcb -> asoc . peer_auth_chunks ) ; else stcb -> asoc . peer_auth_chunks = sctp_alloc_chunklist ( ) ; for ( i = 0 ; i < num_chunks ; i ++ ) { ( void ) sctp_auth_add_chunk ( chunks -> chunk_types [ i ] , stcb -> asoc . peer_auth_chunks ) ; if ( chunks -> chunk_types [ i ] == SCTP_ASCONF ) saw_asconf = 1 ; if ( chunks -> chunk_types [ i ] == SCTP_ASCONF_ACK ) saw_asconf_ack = 1 ; } got_chklist = 1 ; } else if ( ( ptype == SCTP_HEARTBEAT_INFO ) || ( ptype == SCTP_STATE_COOKIE ) || ( ptype == SCTP_UNRECOG_PARAM ) || ( ptype == SCTP_COOKIE_PRESERVE ) || ( ptype == SCTP_SUPPORTED_ADDRTYPE ) || ( ptype == SCTP_ADD_IP_ADDRESS ) || ( ptype == SCTP_DEL_IP_ADDRESS ) || ( ptype == SCTP_ERROR_CAUSE_IND ) || ( ptype == SCTP_SUCCESS_REPORT ) ) { ; } else { if ( ( ptype & 0x8000 ) == 0x0000 ) { break ; } } next_param : offset += SCTP_SIZE32 ( plen ) ; if ( offset >= limit ) { break ; } phdr = sctp_get_next_param ( m , offset , & param_buf , sizeof ( param_buf ) ) ; } TAILQ_FOREACH_SAFE ( net , & stcb -> asoc . nets , sctp_next , nnet ) { if ( ( net -> dest_state & SCTP_ADDR_NOT_IN_ASSOC ) == SCTP_ADDR_NOT_IN_ASSOC ) { stcb -> asoc . numnets -- ; TAILQ_REMOVE ( & stcb -> asoc . nets , net , sctp_next ) ; sctp_free_remote_addr ( net ) ; if ( net == stcb -> asoc . primary_destination ) { stcb -> asoc . primary_destination = NULL ; sctp_select_primary_destination ( stcb ) ; } } } if ( ( stcb -> asoc . ecn_supported == 1 ) && ( peer_supports_ecn == 0 ) ) { stcb -> asoc . ecn_supported = 0 ; } if ( ( stcb -> asoc . prsctp_supported == 1 ) && ( peer_supports_prsctp == 0 ) ) { stcb -> asoc . prsctp_supported = 0 ; } if ( ( stcb -> asoc . auth_supported == 1 ) && ( ( peer_supports_auth == 0 ) || ( got_random == 0 ) || ( got_hmacs == 0 ) ) ) { stcb -> asoc . auth_supported = 0 ; } if ( ( stcb -> asoc . asconf_supported == 1 ) && ( ( peer_supports_asconf == 0 ) || ( peer_supports_asconf_ack == 0 ) || ( stcb -> asoc . auth_supported == 0 ) || ( saw_asconf == 0 ) || ( saw_asconf_ack == 0 ) ) ) { stcb -> asoc . asconf_supported = 0 ; } if ( ( stcb -> asoc . reconfig_supported == 1 ) && ( peer_supports_reconfig == 0 ) ) { stcb -> asoc . reconfig_supported = 0 ; } if ( ( stcb -> asoc . idata_supported == 1 ) && ( peer_supports_idata == 0 ) ) { stcb -> asoc . idata_supported = 0 ; } if ( ( stcb -> asoc . nrsack_supported == 1 ) && ( peer_supports_nrsack == 0 ) ) { stcb -> asoc . nrsack_supported = 0 ; } if ( ( stcb -> asoc . pktdrop_supported == 1 ) && ( peer_supports_pktdrop == 0 ) ) { stcb -> asoc . pktdrop_supported = 0 ; } if ( ( peer_supports_auth == 0 ) && ( got_chklist == 1 ) ) { return ( - 31 ) ; } if ( ( peer_supports_asconf == 1 ) && ( peer_supports_auth == 0 ) ) { return ( - 32 ) ; } else if ( ( peer_supports_asconf == 1 ) && ( peer_supports_auth == 1 ) && ( ( saw_asconf == 0 ) || ( saw_asconf_ack == 0 ) ) ) { return ( - 33 ) ; } keylen = sizeof ( * p_random ) + random_len + sizeof ( * hmacs ) + hmacs_len ; if ( chunks != NULL ) { keylen += sizeof ( * chunks ) + num_chunks ; } new_key = sctp_alloc_key ( keylen ) ; if ( new_key != NULL ) { if ( p_random != NULL ) { keylen = sizeof ( * p_random ) + random_len ; memcpy ( new_key -> key , p_random , keylen ) ; } else { keylen = 0 ; } if ( chunks != NULL ) { memcpy ( new_key -> key + keylen , chunks , sizeof ( * chunks ) + num_chunks ) ; keylen += sizeof ( * chunks ) + num_chunks ; } if ( hmacs != NULL ) { memcpy ( new_key -> key + keylen , hmacs , sizeof ( * hmacs ) + hmacs_len ) ; } } else { return ( - 34 ) ; } if ( stcb -> asoc . authinfo . peer_random != NULL ) sctp_free_key ( stcb -> asoc . authinfo . peer_random ) ; stcb -> asoc . authinfo . peer_random = new_key ; sctp_clear_cachedkeys ( stcb , stcb -> asoc . authinfo . assoc_keyid ) ; sctp_clear_cachedkeys ( stcb , stcb -> asoc . authinfo . recv_keyid ) ; return ( 0 ) ; }\n","target":"<S2SV_ModStart> if ( plen < sizeof ( struct sctp_paramhdr ) <S2SV_ModEnd> ) { break <S2SV_ModStart> ) ; } if ( plen < sizeof ( struct sctp_asconf_addrv4_param ) ) { return ( - 101 ) ; }\n","project_and_commit_id":"sctplab@usrsctp/790a7a2555aefb392a5a69923f1e9d17b4968467","cve_id":"CVE-2019-20503","original_address":"https://github.com/sctplab/usrsctp/commit/790a7a2555aefb392a5a69923f1e9d17b4968467","time":"2020-03-06T20:15Z"},
	{"Unnamed: 0":596,"cwe_id":"CWE-119","source":"CWE-119 static int read_private_key ( RSA * rsa ) { int r ; sc_path_t path ; sc_file_t * file ; const sc_acl_entry_t * e ; u8 buf [ 2048 ] , * p = buf ; size_t bufsize , keysize ; r = select_app_df ( ) ; if ( r ) return 1 ; sc_format_path ( \"I0012\" , & path ) ; r = sc_select_file ( card , & path , & file ) ; if ( r ) { fprintf ( stderr , \"Unable<S2SV_blank>to<S2SV_blank>select<S2SV_blank>private<S2SV_blank>key<S2SV_blank>file:<S2SV_blank>%s\\\\n\" , sc_strerror ( r ) ) ; return 2 ; } e = sc_file_get_acl_entry ( file , SC_AC_OP_READ ) ; if ( e == NULL || e -> method == SC_AC_NEVER ) return 10 ; <S2SV_StartBug> bufsize = file -> size ; <S2SV_EndBug> sc_file_free ( file ) ; r = sc_read_binary ( card , 0 , buf , bufsize , 0 ) ; if ( r < 0 ) { fprintf ( stderr , \"Unable<S2SV_blank>to<S2SV_blank>read<S2SV_blank>private<S2SV_blank>key<S2SV_blank>file:<S2SV_blank>%s\\\\n\" , sc_strerror ( r ) ) ; return 2 ; } bufsize = r ; do { if ( bufsize < 4 ) return 3 ; keysize = ( p [ 0 ] << 8 ) | p [ 1 ] ; if ( keysize == 0 ) break ; if ( keysize < 3 ) return 3 ; if ( p [ 2 ] == opt_key_num ) break ; p += keysize ; bufsize -= keysize ; } while ( 1 ) ; if ( keysize == 0 ) { printf ( \"Key<S2SV_blank>number<S2SV_blank>%d<S2SV_blank>not<S2SV_blank>found.\\\\n\" , opt_key_num ) ; return 2 ; } return parse_private_key ( p , keysize , rsa ) ; }\n","target":"<S2SV_ModStart> ; bufsize = MIN ( <S2SV_ModStart> file -> size , sizeof buf )\n","project_and_commit_id":"OpenSC@OpenSC/360e95d45ac4123255a4c796db96337f332160ad","cve_id":"CVE-2018-16391","original_address":"https://github.com/OpenSC/OpenSC/commit/360e95d45ac4123255a4c796db96337f332160ad#diff-477b7a40136bb418b10ce271c8664536","time":"2018-09-03T14:29Z"},
	{"Unnamed: 0":2669,"cwe_id":"CWE-59","source":"CWE-59 void vrrp_print_json ( void ) { FILE * file ; element e ; struct json_object * array ; if ( LIST_ISEMPTY ( vrrp_data -> vrrp ) ) return ; <S2SV_StartBug> file = fopen ( \"/tmp/keepalived.json\" , \"w\" ) ; <S2SV_EndBug> if ( ! file ) { log_message ( LOG_INFO , \"Can\\'t<S2SV_blank>open<S2SV_blank>/tmp/keepalived.json<S2SV_blank>(%d:<S2SV_blank>%s)\" , errno , strerror ( errno ) ) ; return ; } array = json_object_new_array ( ) ; for ( e = LIST_HEAD ( vrrp_data -> vrrp ) ; e ; ELEMENT_NEXT ( e ) ) { struct json_object * instance_json , * json_stats , * json_data , * vips , * evips , * track_ifp , * track_script ; # ifdef _HAVE_FIB_ROUTING_ struct json_object * vroutes , * vrules ; # endif element f ; vrrp_t * vrrp = ELEMENT_DATA ( e ) ; instance_json = json_object_new_object ( ) ; json_stats = json_object_new_object ( ) ; json_data = json_object_new_object ( ) ; vips = json_object_new_array ( ) ; evips = json_object_new_array ( ) ; track_ifp = json_object_new_array ( ) ; track_script = json_object_new_array ( ) ; # ifdef _HAVE_FIB_ROUTING_ vroutes = json_object_new_array ( ) ; vrules = json_object_new_array ( ) ; # endif json_object_object_add ( json_data , \"iname\" , json_object_new_string ( vrrp -> iname ) ) ; json_object_object_add ( json_data , \"dont_track_primary\" , json_object_new_int ( vrrp -> dont_track_primary ) ) ; json_object_object_add ( json_data , \"skip_check_adv_addr\" , json_object_new_int ( vrrp -> skip_check_adv_addr ) ) ; json_object_object_add ( json_data , \"strict_mode\" , json_object_new_int ( ( int ) vrrp -> strict_mode ) ) ; # ifdef _HAVE_VRRP_VMAC_ json_object_object_add ( json_data , \"vmac_ifname\" , json_object_new_string ( vrrp -> vmac_ifname ) ) ; # endif if ( ! LIST_ISEMPTY ( vrrp -> track_ifp ) ) { for ( f = LIST_HEAD ( vrrp -> track_ifp ) ; f ; ELEMENT_NEXT ( f ) ) { interface_t * ifp = ELEMENT_DATA ( f ) ; json_object_array_add ( track_ifp , json_object_new_string ( ifp -> ifname ) ) ; } } json_object_object_add ( json_data , \"track_ifp\" , track_ifp ) ; if ( ! LIST_ISEMPTY ( vrrp -> track_script ) ) { for ( f = LIST_HEAD ( vrrp -> track_script ) ; f ; ELEMENT_NEXT ( f ) ) { tracked_sc_t * tsc = ELEMENT_DATA ( f ) ; vrrp_script_t * vscript = tsc -> scr ; json_object_array_add ( track_script , json_object_new_string ( cmd_str ( & vscript -> script ) ) ) ; } } json_object_object_add ( json_data , \"track_script\" , track_script ) ; json_object_object_add ( json_data , \"ifp_ifname\" , json_object_new_string ( vrrp -> ifp -> ifname ) ) ; json_object_object_add ( json_data , \"master_priority\" , json_object_new_int ( vrrp -> master_priority ) ) ; json_object_object_add ( json_data , \"last_transition\" , json_object_new_double ( timeval_to_double ( & vrrp -> last_transition ) ) ) ; json_object_object_add ( json_data , \"garp_delay\" , json_object_new_double ( vrrp -> garp_delay / TIMER_HZ_FLOAT ) ) ; json_object_object_add ( json_data , \"garp_refresh\" , json_object_new_int ( ( int ) vrrp -> garp_refresh . tv_sec ) ) ; json_object_object_add ( json_data , \"garp_rep\" , json_object_new_int ( ( int ) vrrp -> garp_rep ) ) ; json_object_object_add ( json_data , \"garp_refresh_rep\" , json_object_new_int ( ( int ) vrrp -> garp_refresh_rep ) ) ; json_object_object_add ( json_data , \"garp_lower_prio_delay\" , json_object_new_int ( ( int ) ( vrrp -> garp_lower_prio_delay / TIMER_HZ ) ) ) ; json_object_object_add ( json_data , \"garp_lower_prio_rep\" , json_object_new_int ( ( int ) vrrp -> garp_lower_prio_rep ) ) ; json_object_object_add ( json_data , \"lower_prio_no_advert\" , json_object_new_int ( ( int ) vrrp -> lower_prio_no_advert ) ) ; json_object_object_add ( json_data , \"higher_prio_send_advert\" , json_object_new_int ( ( int ) vrrp -> higher_prio_send_advert ) ) ; json_object_object_add ( json_data , \"vrid\" , json_object_new_int ( vrrp -> vrid ) ) ; json_object_object_add ( json_data , \"base_priority\" , json_object_new_int ( vrrp -> base_priority ) ) ; json_object_object_add ( json_data , \"effective_priority\" , json_object_new_int ( vrrp -> effective_priority ) ) ; json_object_object_add ( json_data , \"vipset\" , json_object_new_boolean ( vrrp -> vipset ) ) ; if ( ! LIST_ISEMPTY ( vrrp -> vip ) ) { for ( f = LIST_HEAD ( vrrp -> vip ) ; f ; ELEMENT_NEXT ( f ) ) { ip_address_t * vip = ELEMENT_DATA ( f ) ; char ipaddr [ INET6_ADDRSTRLEN ] ; inet_ntop ( vrrp -> family , & ( vip -> u . sin . sin_addr . s_addr ) , ipaddr , INET6_ADDRSTRLEN ) ; json_object_array_add ( vips , json_object_new_string ( ipaddr ) ) ; } } json_object_object_add ( json_data , \"vips\" , vips ) ; if ( ! LIST_ISEMPTY ( vrrp -> evip ) ) { for ( f = LIST_HEAD ( vrrp -> evip ) ; f ; ELEMENT_NEXT ( f ) ) { ip_address_t * evip = ELEMENT_DATA ( f ) ; char ipaddr [ INET6_ADDRSTRLEN ] ; inet_ntop ( vrrp -> family , & ( evip -> u . sin . sin_addr . s_addr ) , ipaddr , INET6_ADDRSTRLEN ) ; json_object_array_add ( evips , json_object_new_string ( ipaddr ) ) ; } } json_object_object_add ( json_data , \"evips\" , evips ) ; json_object_object_add ( json_data , \"promote_secondaries\" , json_object_new_boolean ( vrrp -> promote_secondaries ) ) ; # ifdef _HAVE_FIB_ROUTING_ if ( ! LIST_ISEMPTY ( vrrp -> vroutes ) ) { for ( f = LIST_HEAD ( vrrp -> vroutes ) ; f ; ELEMENT_NEXT ( f ) ) { ip_route_t * route = ELEMENT_DATA ( f ) ; char * buf = MALLOC ( ROUTE_BUF_SIZE ) ; format_iproute ( route , buf , ROUTE_BUF_SIZE ) ; json_object_array_add ( vroutes , json_object_new_string ( buf ) ) ; } } json_object_object_add ( json_data , \"vroutes\" , vroutes ) ; if ( ! LIST_ISEMPTY ( vrrp -> vrules ) ) { for ( f = LIST_HEAD ( vrrp -> vrules ) ; f ; ELEMENT_NEXT ( f ) ) { ip_rule_t * rule = ELEMENT_DATA ( f ) ; char * buf = MALLOC ( RULE_BUF_SIZE ) ; format_iprule ( rule , buf , RULE_BUF_SIZE ) ; json_object_array_add ( vrules , json_object_new_string ( buf ) ) ; } } json_object_object_add ( json_data , \"vrules\" , vrules ) ; # endif json_object_object_add ( json_data , \"adver_int\" , json_object_new_double ( vrrp -> adver_int / TIMER_HZ_FLOAT ) ) ; json_object_object_add ( json_data , \"master_adver_int\" , json_object_new_double ( vrrp -> master_adver_int / TIMER_HZ_FLOAT ) ) ; json_object_object_add ( json_data , \"accept\" , json_object_new_int ( ( int ) vrrp -> accept ) ) ; json_object_object_add ( json_data , \"nopreempt\" , json_object_new_boolean ( vrrp -> nopreempt ) ) ; json_object_object_add ( json_data , \"preempt_delay\" , json_object_new_int ( ( int ) ( vrrp -> preempt_delay / TIMER_HZ ) ) ) ; json_object_object_add ( json_data , \"state\" , json_object_new_int ( vrrp -> state ) ) ; json_object_object_add ( json_data , \"wantstate\" , json_object_new_int ( vrrp -> wantstate ) ) ; json_object_object_add ( json_data , \"version\" , json_object_new_int ( vrrp -> version ) ) ; if ( vrrp -> script_backup ) json_object_object_add ( json_data , \"script_backup\" , json_object_new_string ( cmd_str ( vrrp -> script_backup ) ) ) ; if ( vrrp -> script_master ) json_object_object_add ( json_data , \"script_master\" , json_object_new_string ( cmd_str ( vrrp -> script_master ) ) ) ; if ( vrrp -> script_fault ) json_object_object_add ( json_data , \"script_fault\" , json_object_new_string ( cmd_str ( vrrp -> script_fault ) ) ) ; if ( vrrp -> script_stop ) json_object_object_add ( json_data , \"script_stop\" , json_object_new_string ( cmd_str ( vrrp -> script_stop ) ) ) ; if ( vrrp -> script ) json_object_object_add ( json_data , \"script\" , json_object_new_string ( cmd_str ( vrrp -> script ) ) ) ; if ( vrrp -> script_master_rx_lower_pri ) json_object_object_add ( json_data , \"script_master_rx_lower_pri\" , json_object_new_string ( cmd_str ( vrrp -> script_master_rx_lower_pri ) ) ) ; json_object_object_add ( json_data , \"smtp_alert\" , json_object_new_boolean ( vrrp -> smtp_alert ) ) ; # ifdef _WITH_VRRP_AUTH_ if ( vrrp -> auth_type ) { json_object_object_add ( json_data , \"auth_type\" , json_object_new_int ( vrrp -> auth_type ) ) ; if ( vrrp -> auth_type != VRRP_AUTH_AH ) { char auth_data [ sizeof ( vrrp -> auth_data ) + 1 ] ; memcpy ( auth_data , vrrp -> auth_data , sizeof ( vrrp -> auth_data ) ) ; auth_data [ sizeof ( vrrp -> auth_data ) ] = '\\\\0' ; json_object_object_add ( json_data , \"auth_data\" , json_object_new_string ( auth_data ) ) ; } } else json_object_object_add ( json_data , \"auth_type\" , json_object_new_int ( 0 ) ) ; # endif json_object_object_add ( json_stats , \"advert_rcvd\" , json_object_new_int64 ( ( int64_t ) vrrp -> stats -> advert_rcvd ) ) ; json_object_object_add ( json_stats , \"advert_sent\" , json_object_new_int64 ( vrrp -> stats -> advert_sent ) ) ; json_object_object_add ( json_stats , \"become_master\" , json_object_new_int64 ( vrrp -> stats -> become_master ) ) ; json_object_object_add ( json_stats , \"release_master\" , json_object_new_int64 ( vrrp -> stats -> release_master ) ) ; json_object_object_add ( json_stats , \"packet_len_err\" , json_object_new_int64 ( ( int64_t ) vrrp -> stats -> packet_len_err ) ) ; json_object_object_add ( json_stats , \"advert_interval_err\" , json_object_new_int64 ( ( int64_t ) vrrp -> stats -> advert_interval_err ) ) ; json_object_object_add ( json_stats , \"ip_ttl_err\" , json_object_new_int64 ( ( int64_t ) vrrp -> stats -> ip_ttl_err ) ) ; json_object_object_add ( json_stats , \"invalid_type_rcvd\" , json_object_new_int64 ( ( int64_t ) vrrp -> stats -> invalid_type_rcvd ) ) ; json_object_object_add ( json_stats , \"addr_list_err\" , json_object_new_int64 ( ( int64_t ) vrrp -> stats -> addr_list_err ) ) ; json_object_object_add ( json_stats , \"invalid_authtype\" , json_object_new_int64 ( vrrp -> stats -> invalid_authtype ) ) ; # ifdef _WITH_VRRP_AUTH_ json_object_object_add ( json_stats , \"authtype_mismatch\" , json_object_new_int64 ( vrrp -> stats -> authtype_mismatch ) ) ; json_object_object_add ( json_stats , \"auth_failure\" , json_object_new_int64 ( vrrp -> stats -> auth_failure ) ) ; # endif json_object_object_add ( json_stats , \"pri_zero_rcvd\" , json_object_new_int64 ( ( int64_t ) vrrp -> stats -> pri_zero_rcvd ) ) ; json_object_object_add ( json_stats , \"pri_zero_sent\" , json_object_new_int64 ( ( int64_t ) vrrp -> stats -> pri_zero_sent ) ) ; json_object_object_add ( instance_json , \"data\" , json_data ) ; json_object_object_add ( instance_json , \"stats\" , json_stats ) ; json_object_array_add ( array , instance_json ) ; } fprintf ( file , \"%s\" , json_object_to_json_string ( array ) ) ; fclose ( file ) ; }\n","target":"<S2SV_ModStart> ; file = fopen_safe <S2SV_ModEnd> ( \"/tmp/keepalived.json\" ,\n","project_and_commit_id":"acassen@keepalived/04f2d32871bb3b11d7dc024039952f2fe2750306","cve_id":"CVE-2018-19044","original_address":"https://github.com/acassen/keepalived/commit/04f2d32871bb3b11d7dc024039952f2fe2750306","time":"2018-11-08T20:29Z"},
	{"Unnamed: 0":6415,"cwe_id":"CWE-89","source":"CWE-89 static CURLcode imap_parse_url_path ( struct connectdata * conn ) { struct imap_conn * imapc = & conn -> proto . imapc ; struct SessionHandle * data = conn -> data ; const char * path = data -> state . path ; <S2SV_StartBug> int len ; <S2SV_EndBug> if ( ! * path ) path = \"INBOX\" ; <S2SV_StartBug> imapc -> mailbox = curl_easy_unescape ( data , path , 0 , & len ) ; <S2SV_EndBug> <S2SV_StartBug> if ( ! imapc -> mailbox ) <S2SV_EndBug> return CURLE_OUT_OF_MEMORY ; return CURLE_OK ; }\n","target":"<S2SV_ModStart> . path ; <S2SV_ModEnd> if ( ! <S2SV_ModStart> = \"INBOX\" ; return Curl_urldecode <S2SV_ModEnd> ( data , <S2SV_ModStart> 0 , & <S2SV_ModEnd> imapc -> mailbox <S2SV_ModStart> imapc -> mailbox , NULL , TRUE ) <S2SV_ModEnd> ; } <S2SV_null>\n","project_and_commit_id":"bagder@curl/75ca568fa1c19de4c5358fed246686de8467c238","cve_id":"CVE-2012-0036","original_address":"https://github.com/bagder/curl/commit/75ca568fa1c19de4c5358fed246686de8467c238","time":"2012-04-13T20:55Z"},
	{"Unnamed: 0":5813,"cwe_id":"CWE-20","source":"CWE-20 error_t tcpSendResetSegment ( NetInterface * interface , IpPseudoHeader * pseudoHeader , TcpHeader * segment , size_t length ) { error_t error ; size_t offset ; uint8_t flags ; uint32_t seqNum ; uint32_t ackNum ; NetBuffer * buffer ; TcpHeader * segment2 ; IpPseudoHeader pseudoHeader2 ; NetTxAncillary ancillary ; if ( segment -> flags & TCP_FLAG_ACK ) { flags = TCP_FLAG_RST ; seqNum = segment -> ackNum ; ackNum = 0 ; } else { flags = TCP_FLAG_RST | TCP_FLAG_ACK ; seqNum = 0 ; ackNum = segment -> seqNum + length ; if ( segment -> flags & TCP_FLAG_SYN ) <S2SV_StartBug> ackNum ++ ; <S2SV_EndBug> <S2SV_StartBug> if ( segment -> flags & TCP_FLAG_FIN ) <S2SV_EndBug> <S2SV_StartBug> ackNum ++ ; <S2SV_EndBug> } buffer = ipAllocBuffer ( sizeof ( TcpHeader ) , & offset ) ; if ( buffer == NULL ) return ERROR_OUT_OF_MEMORY ; segment2 = netBufferAt ( buffer , offset ) ; segment2 -> srcPort = htons ( segment -> destPort ) ; segment2 -> destPort = htons ( segment -> srcPort ) ; segment2 -> seqNum = htonl ( seqNum ) ; segment2 -> ackNum = htonl ( ackNum ) ; segment2 -> reserved1 = 0 ; segment2 -> dataOffset = 5 ; segment2 -> flags = flags ; segment2 -> reserved2 = 0 ; segment2 -> window = 0 ; segment2 -> checksum = 0 ; segment2 -> urgentPointer = 0 ; # if ( IPV4_SUPPORT == ENABLED ) if ( pseudoHeader -> length == sizeof ( Ipv4PseudoHeader ) ) { pseudoHeader2 . length = sizeof ( Ipv4PseudoHeader ) ; pseudoHeader2 . ipv4Data . srcAddr = pseudoHeader -> ipv4Data . destAddr ; pseudoHeader2 . ipv4Data . destAddr = pseudoHeader -> ipv4Data . srcAddr ; pseudoHeader2 . ipv4Data . reserved = 0 ; pseudoHeader2 . ipv4Data . protocol = IPV4_PROTOCOL_TCP ; pseudoHeader2 . ipv4Data . length = HTONS ( sizeof ( TcpHeader ) ) ; segment2 -> checksum = ipCalcUpperLayerChecksumEx ( & pseudoHeader2 . ipv4Data , sizeof ( Ipv4PseudoHeader ) , buffer , offset , sizeof ( TcpHeader ) ) ; } else # endif # if ( IPV6_SUPPORT == ENABLED ) if ( pseudoHeader -> length == sizeof ( Ipv6PseudoHeader ) ) { pseudoHeader2 . length = sizeof ( Ipv6PseudoHeader ) ; pseudoHeader2 . ipv6Data . srcAddr = pseudoHeader -> ipv6Data . destAddr ; pseudoHeader2 . ipv6Data . destAddr = pseudoHeader -> ipv6Data . srcAddr ; pseudoHeader2 . ipv6Data . length = HTONL ( sizeof ( TcpHeader ) ) ; pseudoHeader2 . ipv6Data . reserved [ 0 ] = 0 ; pseudoHeader2 . ipv6Data . reserved [ 1 ] = 0 ; pseudoHeader2 . ipv6Data . reserved [ 2 ] = 0 ; pseudoHeader2 . ipv6Data . nextHeader = IPV6_TCP_HEADER ; segment2 -> checksum = ipCalcUpperLayerChecksumEx ( & pseudoHeader2 . ipv6Data , sizeof ( Ipv6PseudoHeader ) , buffer , offset , sizeof ( TcpHeader ) ) ; } else # endif { netBufferFree ( buffer ) ; return ERROR_INVALID_ADDRESS ; } MIB2_INC_COUNTER32 ( tcpGroup . tcpOutSegs , 1 ) ; TCP_MIB_INC_COUNTER32 ( tcpOutSegs , 1 ) ; TCP_MIB_INC_COUNTER64 ( tcpHCOutSegs , 1 ) ; MIB2_INC_COUNTER32 ( tcpGroup . tcpOutRsts , 1 ) ; TCP_MIB_INC_COUNTER32 ( tcpOutRsts , 1 ) ; TRACE_DEBUG ( \"%s:<S2SV_blank>Sending<S2SV_blank>TCP<S2SV_blank>reset<S2SV_blank>segment...\\\\r\\\\n\" , formatSystemTime ( osGetSystemTime ( ) , NULL ) ) ; tcpDumpHeader ( segment2 , length , 0 , 0 ) ; ancillary = NET_DEFAULT_TX_ANCILLARY ; error = ipSendDatagram ( interface , & pseudoHeader2 , buffer , offset , & ancillary ) ; netBufferFree ( buffer ) ; return error ; }\n","target":"<S2SV_ModStart> & TCP_FLAG_SYN ) { <S2SV_ModStart> ackNum ++ ; } <S2SV_ModStart> & TCP_FLAG_FIN ) { <S2SV_ModStart> ackNum ++ ; }\n","project_and_commit_id":"Oryx-Embedded@CycloneTCP/de5336016edbe1e90327d0ed1cba5c4e49114366","cve_id":"CVE-2021-26788","original_address":"https://github.com/Oryx-Embedded/CycloneTCP/commit/de5336016edbe1e90327d0ed1cba5c4e49114366","time":"2021-03-08T13:15Z"},
	{"Unnamed: 0":4328,"cwe_id":"CWE-772","source":"CWE-772 chrand_ret * chrand_principal_2_svc ( chrand_arg * arg , struct svc_req * rqstp ) { static chrand_ret ret ; krb5_keyblock * k ; int nkeys ; char * prime_arg , * funcname ; <S2SV_StartBug> gss_buffer_desc client_name , <S2SV_EndBug> service_name ; OM_uint32 minor_stat ; kadm5_server_handle_t handle ; const char * errmsg = NULL ; xdr_free ( xdr_chrand_ret , & ret ) ; if ( ( ret . code = new_server_handle ( arg -> api_version , rqstp , & handle ) ) ) goto exit_func ; if ( ( ret . code = check_handle ( ( void * ) handle ) ) ) goto exit_func ; ret . api_version = handle -> api_version ; funcname = \"kadm5_randkey_principal\" ; if ( setup_gss_names ( rqstp , & client_name , & service_name ) < 0 ) { ret . code = KADM5_FAILURE ; goto exit_func ; } if ( krb5_unparse_name ( handle -> context , arg -> princ , & prime_arg ) ) { ret . code = KADM5_BAD_PRINCIPAL ; goto exit_func ; } if ( cmp_gss_krb5_name ( handle , rqst2name ( rqstp ) , arg -> princ ) ) { ret . code = randkey_principal_wrapper_3 ( ( void * ) handle , arg -> princ , FALSE , 0 , NULL , & k , & nkeys ) ; } else if ( ! ( CHANGEPW_SERVICE ( rqstp ) ) && kadm5int_acl_check ( handle -> context , rqst2name ( rqstp ) , ACL_CHANGEPW , arg -> princ , NULL ) ) { ret . code = kadm5_randkey_principal ( ( void * ) handle , arg -> princ , & k , & nkeys ) ; } else { log_unauth ( funcname , prime_arg , & client_name , & service_name , rqstp ) ; ret . code = KADM5_AUTH_CHANGEPW ; } if ( ret . code == KADM5_OK ) { ret . keys = k ; ret . n_keys = nkeys ; } if ( ret . code != KADM5_AUTH_CHANGEPW ) { if ( ret . code != 0 ) errmsg = krb5_get_error_message ( handle -> context , ret . code ) ; log_done ( funcname , prime_arg , errmsg , & client_name , & service_name , rqstp ) ; if ( errmsg != NULL ) krb5_free_error_message ( handle -> context , errmsg ) ; } free ( prime_arg ) ; <S2SV_StartBug> gss_release_buffer ( & minor_stat , & client_name ) ; <S2SV_EndBug> gss_release_buffer ( & minor_stat , & service_name ) ; exit_func : free_server_handle ( handle ) ; return & ret ; }\n","target":"<S2SV_ModStart> ; gss_buffer_desc client_name = GSS_C_EMPTY_BUFFER ; gss_buffer_desc service_name = GSS_C_EMPTY_BUFFER <S2SV_ModEnd> ; OM_uint32 minor_stat <S2SV_ModStart> prime_arg ) ; exit_func : gss_release_buffer ( & minor_stat , & client_name ) ; gss_release_buffer ( & minor_stat , & service_name ) ; <S2SV_ModEnd> free_server_handle ( handle\n","project_and_commit_id":"krb5@krb5/83ed75feba32e46f736fcce0d96a0445f29b96c2","cve_id":"CVE-2015-8631","original_address":"https://github.com/krb5/krb5/commit/83ed75feba32e46f736fcce0d96a0445f29b96c2","time":"2016-02-13T02:59Z"},
	{"Unnamed: 0":6230,"cwe_id":"CWE-119","source":"CWE-119 tsize_t t2p_readwrite_pdf_image ( T2P * t2p , TIFF * input , TIFF * output ) { tsize_t written = 0 ; unsigned char * buffer = NULL ; unsigned char * samplebuffer = NULL ; tsize_t bufferoffset = 0 ; tsize_t samplebufferoffset = 0 ; tsize_t read = 0 ; tstrip_t i = 0 ; tstrip_t j = 0 ; tstrip_t stripcount = 0 ; tsize_t stripsize = 0 ; tsize_t sepstripcount = 0 ; tsize_t sepstripsize = 0 ; # ifdef OJPEG_SUPPORT toff_t inputoffset = 0 ; uint16 h_samp = 1 ; uint16 v_samp = 1 ; uint16 ri = 1 ; uint32 rows = 0 ; # endif # ifdef JPEG_SUPPORT unsigned char * jpt ; float * xfloatp ; uint64 * sbc ; unsigned char * stripbuffer ; tsize_t striplength = 0 ; uint32 max_striplength = 0 ; # endif if ( t2p -> t2p_error != T2P_ERR_OK ) return ( 0 ) ; if ( t2p -> pdf_transcode == T2P_TRANSCODE_RAW ) { # ifdef CCITT_SUPPORT if ( t2p -> pdf_compression == T2P_COMPRESS_G4 ) { buffer = ( unsigned char * ) _TIFFmalloc ( t2p -> tiff_datasize ) ; if ( buffer == NULL ) { TIFFError ( TIFF2PDF_MODULE , \"Can\\'t<S2SV_blank>allocate<S2SV_blank>%lu<S2SV_blank>bytes<S2SV_blank>of<S2SV_blank>memory<S2SV_blank>for<S2SV_blank>\" \"t2p_readwrite_pdf_image,<S2SV_blank>%s\" , ( unsigned long ) t2p -> tiff_datasize , TIFFFileName ( input ) ) ; t2p -> t2p_error = T2P_ERR_ERROR ; return ( 0 ) ; } TIFFReadRawStrip ( input , 0 , ( tdata_t ) buffer , t2p -> tiff_datasize ) ; if ( t2p -> tiff_fillorder == FILLORDER_LSB2MSB ) { TIFFReverseBits ( buffer , t2p -> tiff_datasize ) ; } t2pWriteFile ( output , ( tdata_t ) buffer , t2p -> tiff_datasize ) ; _TIFFfree ( buffer ) ; return ( t2p -> tiff_datasize ) ; } # endif # ifdef ZIP_SUPPORT if ( t2p -> pdf_compression == T2P_COMPRESS_ZIP ) { buffer = ( unsigned char * ) _TIFFmalloc ( t2p -> tiff_datasize ) ; if ( buffer == NULL ) { TIFFError ( TIFF2PDF_MODULE , \"Can\\'t<S2SV_blank>allocate<S2SV_blank>%lu<S2SV_blank>bytes<S2SV_blank>of<S2SV_blank>memory<S2SV_blank>for<S2SV_blank>t2p_readwrite_pdf_image,<S2SV_blank>%s\" , ( unsigned long ) t2p -> tiff_datasize , TIFFFileName ( input ) ) ; t2p -> t2p_error = T2P_ERR_ERROR ; return ( 0 ) ; } memset ( buffer , 0 , t2p -> tiff_datasize ) ; TIFFReadRawStrip ( input , 0 , ( tdata_t ) buffer , t2p -> tiff_datasize ) ; if ( t2p -> tiff_fillorder == FILLORDER_LSB2MSB ) { TIFFReverseBits ( buffer , t2p -> tiff_datasize ) ; } t2pWriteFile ( output , ( tdata_t ) buffer , t2p -> tiff_datasize ) ; _TIFFfree ( buffer ) ; return ( t2p -> tiff_datasize ) ; } # endif # ifdef OJPEG_SUPPORT if ( t2p -> tiff_compression == COMPRESSION_OJPEG ) { if ( t2p -> tiff_dataoffset != 0 ) { buffer = ( unsigned char * ) _TIFFmalloc ( t2p -> tiff_datasize ) ; if ( buffer == NULL ) { TIFFError ( TIFF2PDF_MODULE , \"Can\\'t<S2SV_blank>allocate<S2SV_blank>%lu<S2SV_blank>bytes<S2SV_blank>of<S2SV_blank>memory<S2SV_blank>for<S2SV_blank>t2p_readwrite_pdf_image,<S2SV_blank>%s\" , ( unsigned long ) t2p -> tiff_datasize , TIFFFileName ( input ) ) ; t2p -> t2p_error = T2P_ERR_ERROR ; return ( 0 ) ; } memset ( buffer , 0 , t2p -> tiff_datasize ) ; if ( t2p -> pdf_ojpegiflength == 0 ) { inputoffset = t2pSeekFile ( input , 0 , SEEK_CUR ) ; t2pSeekFile ( input , t2p -> tiff_dataoffset , SEEK_SET ) ; t2pReadFile ( input , ( tdata_t ) buffer , t2p -> tiff_datasize ) ; t2pSeekFile ( input , inputoffset , SEEK_SET ) ; t2pWriteFile ( output , ( tdata_t ) buffer , t2p -> tiff_datasize ) ; _TIFFfree ( buffer ) ; return ( t2p -> tiff_datasize ) ; } else { inputoffset = t2pSeekFile ( input , 0 , SEEK_CUR ) ; t2pSeekFile ( input , t2p -> tiff_dataoffset , SEEK_SET ) ; bufferoffset = t2pReadFile ( input , ( tdata_t ) buffer , t2p -> pdf_ojpegiflength ) ; t2p -> pdf_ojpegiflength = 0 ; t2pSeekFile ( input , inputoffset , SEEK_SET ) ; TIFFGetField ( input , TIFFTAG_YCBCRSUBSAMPLING , & h_samp , & v_samp ) ; buffer [ bufferoffset ++ ] = 0xff ; buffer [ bufferoffset ++ ] = 0xdd ; buffer [ bufferoffset ++ ] = 0x00 ; buffer [ bufferoffset ++ ] = 0x04 ; h_samp *= 8 ; v_samp *= 8 ; ri = ( t2p -> tiff_width + h_samp - 1 ) / h_samp ; TIFFGetField ( input , TIFFTAG_ROWSPERSTRIP , & rows ) ; ri *= ( rows + v_samp - 1 ) / v_samp ; buffer [ bufferoffset ++ ] = ( ri >> 8 ) & 0xff ; buffer [ bufferoffset ++ ] = ri & 0xff ; stripcount = TIFFNumberOfStrips ( input ) ; for ( i = 0 ; i < stripcount ; i ++ ) { if ( i != 0 ) { buffer [ bufferoffset ++ ] = 0xff ; buffer [ bufferoffset ++ ] = ( 0xd0 | ( ( i - 1 ) % 8 ) ) ; } bufferoffset += TIFFReadRawStrip ( input , i , ( tdata_t ) & ( ( ( unsigned char * ) buffer ) [ bufferoffset ] ) , - 1 ) ; } t2pWriteFile ( output , ( tdata_t ) buffer , bufferoffset ) ; _TIFFfree ( buffer ) ; return ( bufferoffset ) ; } } else { if ( ! t2p -> pdf_ojpegdata ) { TIFFError ( TIFF2PDF_MODULE , \"No<S2SV_blank>support<S2SV_blank>for<S2SV_blank>OJPEG<S2SV_blank>image<S2SV_blank>%s<S2SV_blank>with<S2SV_blank>bad<S2SV_blank>tables\" , TIFFFileName ( input ) ) ; t2p -> t2p_error = T2P_ERR_ERROR ; return ( 0 ) ; } buffer = ( unsigned char * ) _TIFFmalloc ( t2p -> tiff_datasize ) ; if ( buffer == NULL ) { TIFFError ( TIFF2PDF_MODULE , \"Can\\'t<S2SV_blank>allocate<S2SV_blank>%lu<S2SV_blank>bytes<S2SV_blank>of<S2SV_blank>memory<S2SV_blank>for<S2SV_blank>t2p_readwrite_pdf_image,<S2SV_blank>%s\" , ( unsigned long ) t2p -> tiff_datasize , TIFFFileName ( input ) ) ; t2p -> t2p_error = T2P_ERR_ERROR ; return ( 0 ) ; } memset ( buffer , 0 , t2p -> tiff_datasize ) ; _TIFFmemcpy ( buffer , t2p -> pdf_ojpegdata , t2p -> pdf_ojpegdatalength ) ; bufferoffset = t2p -> pdf_ojpegdatalength ; stripcount = TIFFNumberOfStrips ( input ) ; for ( i = 0 ; i < stripcount ; i ++ ) { if ( i != 0 ) { buffer [ bufferoffset ++ ] = 0xff ; buffer [ bufferoffset ++ ] = ( 0xd0 | ( ( i - 1 ) % 8 ) ) ; } bufferoffset += TIFFReadRawStrip ( input , i , ( tdata_t ) & ( ( ( unsigned char * ) buffer ) [ bufferoffset ] ) , - 1 ) ; } if ( ! ( ( buffer [ bufferoffset - 1 ] == 0xd9 ) && ( buffer [ bufferoffset - 2 ] == 0xff ) ) ) { buffer [ bufferoffset ++ ] = 0xff ; buffer [ bufferoffset ++ ] = 0xd9 ; } t2pWriteFile ( output , ( tdata_t ) buffer , bufferoffset ) ; _TIFFfree ( buffer ) ; return ( bufferoffset ) ; # if 0 TIFFError ( TIFF2PDF_MODULE , \"No<S2SV_blank>support<S2SV_blank>for<S2SV_blank>OJPEG<S2SV_blank>image<S2SV_blank>%s<S2SV_blank>with<S2SV_blank>no<S2SV_blank>JPEG<S2SV_blank>File<S2SV_blank>Interchange<S2SV_blank>offset\" , TIFFFileName ( input ) ) ; t2p -> t2p_error = T2P_ERR_ERROR ; return ( 0 ) ; # endif } } # endif # ifdef JPEG_SUPPORT if ( t2p -> tiff_compression == COMPRESSION_JPEG ) { uint32 count = 0 ; buffer = ( unsigned char * ) _TIFFmalloc ( t2p -> tiff_datasize ) ; if ( buffer == NULL ) { TIFFError ( TIFF2PDF_MODULE , \"Can\\'t<S2SV_blank>allocate<S2SV_blank>%lu<S2SV_blank>bytes<S2SV_blank>of<S2SV_blank>memory<S2SV_blank>for<S2SV_blank>t2p_readwrite_pdf_image,<S2SV_blank>%s\" , ( unsigned long ) t2p -> tiff_datasize , TIFFFileName ( input ) ) ; t2p -> t2p_error = T2P_ERR_ERROR ; return ( 0 ) ; } memset ( buffer , 0 , t2p -> tiff_datasize ) ; if ( TIFFGetField ( input , TIFFTAG_JPEGTABLES , & count , & jpt ) != 0 ) { if ( count > 4 ) { _TIFFmemcpy ( buffer , jpt , count ) ; bufferoffset += count - 2 ; } } stripcount = TIFFNumberOfStrips ( input ) ; TIFFGetField ( input , TIFFTAG_STRIPBYTECOUNTS , & sbc ) ; for ( i = 0 ; i < stripcount ; i ++ ) { if ( sbc [ i ] > max_striplength ) max_striplength = sbc [ i ] ; } stripbuffer = ( unsigned char * ) _TIFFmalloc ( max_striplength ) ; if ( stripbuffer == NULL ) { TIFFError ( TIFF2PDF_MODULE , \"Can\\'t<S2SV_blank>allocate<S2SV_blank>%u<S2SV_blank>bytes<S2SV_blank>of<S2SV_blank>memory<S2SV_blank>for<S2SV_blank>t2p_readwrite_pdf_image,<S2SV_blank>%s\" , max_striplength , TIFFFileName ( input ) ) ; _TIFFfree ( buffer ) ; t2p -> t2p_error = T2P_ERR_ERROR ; return ( 0 ) ; } for ( i = 0 ; i < stripcount ; i ++ ) { striplength = TIFFReadRawStrip ( input , i , ( tdata_t ) stripbuffer , - 1 ) ; if ( ! t2p_process_jpeg_strip ( stripbuffer , & striplength , buffer , <S2SV_StartBug> & bufferoffset , <S2SV_EndBug> i , t2p -> tiff_length ) ) { TIFFError ( TIFF2PDF_MODULE , \"Can\\'t<S2SV_blank>process<S2SV_blank>JPEG<S2SV_blank>data<S2SV_blank>in<S2SV_blank>input<S2SV_blank>file<S2SV_blank>%s\" , TIFFFileName ( input ) ) ; _TIFFfree ( samplebuffer ) ; _TIFFfree ( buffer ) ; t2p -> t2p_error = T2P_ERR_ERROR ; return ( 0 ) ; } } buffer [ bufferoffset ++ ] = 0xff ; buffer [ bufferoffset ++ ] = 0xd9 ; t2pWriteFile ( output , ( tdata_t ) buffer , bufferoffset ) ; _TIFFfree ( stripbuffer ) ; _TIFFfree ( buffer ) ; return ( bufferoffset ) ; } # endif ( void ) 0 ; } if ( t2p -> pdf_sample == T2P_SAMPLE_NOTHING ) { buffer = ( unsigned char * ) _TIFFmalloc ( t2p -> tiff_datasize ) ; if ( buffer == NULL ) { TIFFError ( TIFF2PDF_MODULE , \"Can\\'t<S2SV_blank>allocate<S2SV_blank>%lu<S2SV_blank>bytes<S2SV_blank>of<S2SV_blank>memory<S2SV_blank>for<S2SV_blank>t2p_readwrite_pdf_image,<S2SV_blank>%s\" , ( unsigned long ) t2p -> tiff_datasize , TIFFFileName ( input ) ) ; t2p -> t2p_error = T2P_ERR_ERROR ; return ( 0 ) ; } memset ( buffer , 0 , t2p -> tiff_datasize ) ; stripsize = TIFFStripSize ( input ) ; stripcount = TIFFNumberOfStrips ( input ) ; for ( i = 0 ; i < stripcount ; i ++ ) { read = TIFFReadEncodedStrip ( input , i , ( tdata_t ) & buffer [ bufferoffset ] , TIFFmin ( stripsize , t2p -> tiff_datasize - bufferoffset ) ) ; if ( read == - 1 ) { TIFFError ( TIFF2PDF_MODULE , \"Error<S2SV_blank>on<S2SV_blank>decoding<S2SV_blank>strip<S2SV_blank>%u<S2SV_blank>of<S2SV_blank>%s\" , i , TIFFFileName ( input ) ) ; _TIFFfree ( buffer ) ; t2p -> t2p_error = T2P_ERR_ERROR ; return ( 0 ) ; } bufferoffset += read ; } } else { if ( t2p -> pdf_sample & T2P_SAMPLE_PLANAR_SEPARATE_TO_CONTIG ) { sepstripsize = TIFFStripSize ( input ) ; sepstripcount = TIFFNumberOfStrips ( input ) ; stripsize = sepstripsize * t2p -> tiff_samplesperpixel ; stripcount = sepstripcount / t2p -> tiff_samplesperpixel ; buffer = ( unsigned char * ) _TIFFmalloc ( t2p -> tiff_datasize ) ; if ( buffer == NULL ) { TIFFError ( TIFF2PDF_MODULE , \"Can\\'t<S2SV_blank>allocate<S2SV_blank>%lu<S2SV_blank>bytes<S2SV_blank>of<S2SV_blank>memory<S2SV_blank>for<S2SV_blank>t2p_readwrite_pdf_image,<S2SV_blank>%s\" , ( unsigned long ) t2p -> tiff_datasize , TIFFFileName ( input ) ) ; t2p -> t2p_error = T2P_ERR_ERROR ; return ( 0 ) ; } memset ( buffer , 0 , t2p -> tiff_datasize ) ; samplebuffer = ( unsigned char * ) _TIFFmalloc ( stripsize ) ; if ( samplebuffer == NULL ) { TIFFError ( TIFF2PDF_MODULE , \"Can\\'t<S2SV_blank>allocate<S2SV_blank>%lu<S2SV_blank>bytes<S2SV_blank>of<S2SV_blank>memory<S2SV_blank>for<S2SV_blank>t2p_readwrite_pdf_image,<S2SV_blank>%s\" , ( unsigned long ) t2p -> tiff_datasize , TIFFFileName ( input ) ) ; t2p -> t2p_error = T2P_ERR_ERROR ; _TIFFfree ( buffer ) ; return ( 0 ) ; } for ( i = 0 ; i < stripcount ; i ++ ) { samplebufferoffset = 0 ; for ( j = 0 ; j < t2p -> tiff_samplesperpixel ; j ++ ) { read = TIFFReadEncodedStrip ( input , i + j * stripcount , ( tdata_t ) & ( samplebuffer [ samplebufferoffset ] ) , TIFFmin ( sepstripsize , stripsize - samplebufferoffset ) ) ; if ( read == - 1 ) { TIFFError ( TIFF2PDF_MODULE , \"Error<S2SV_blank>on<S2SV_blank>decoding<S2SV_blank>strip<S2SV_blank>%u<S2SV_blank>of<S2SV_blank>%s\" , i + j * stripcount , TIFFFileName ( input ) ) ; _TIFFfree ( buffer ) ; t2p -> t2p_error = T2P_ERR_ERROR ; return ( 0 ) ; } samplebufferoffset += read ; } t2p_sample_planar_separate_to_contig ( t2p , & ( buffer [ bufferoffset ] ) , samplebuffer , samplebufferoffset ) ; bufferoffset += samplebufferoffset ; } _TIFFfree ( samplebuffer ) ; goto dataready ; } buffer = ( unsigned char * ) _TIFFmalloc ( t2p -> tiff_datasize ) ; if ( buffer == NULL ) { TIFFError ( TIFF2PDF_MODULE , \"Can\\'t<S2SV_blank>allocate<S2SV_blank>%lu<S2SV_blank>bytes<S2SV_blank>of<S2SV_blank>memory<S2SV_blank>for<S2SV_blank>t2p_readwrite_pdf_image,<S2SV_blank>%s\" , ( unsigned long ) t2p -> tiff_datasize , TIFFFileName ( input ) ) ; t2p -> t2p_error = T2P_ERR_ERROR ; return ( 0 ) ; } memset ( buffer , 0 , t2p -> tiff_datasize ) ; stripsize = TIFFStripSize ( input ) ; stripcount = TIFFNumberOfStrips ( input ) ; for ( i = 0 ; i < stripcount ; i ++ ) { read = TIFFReadEncodedStrip ( input , i , ( tdata_t ) & buffer [ bufferoffset ] , TIFFmin ( stripsize , t2p -> tiff_datasize - bufferoffset ) ) ; if ( read == - 1 ) { TIFFError ( TIFF2PDF_MODULE , \"Error<S2SV_blank>on<S2SV_blank>decoding<S2SV_blank>strip<S2SV_blank>%u<S2SV_blank>of<S2SV_blank>%s\" , i , TIFFFileName ( input ) ) ; _TIFFfree ( samplebuffer ) ; _TIFFfree ( buffer ) ; t2p -> t2p_error = T2P_ERR_ERROR ; return ( 0 ) ; } bufferoffset += read ; } if ( t2p -> pdf_sample & T2P_SAMPLE_REALIZE_PALETTE ) { samplebuffer = ( unsigned char * ) _TIFFrealloc ( ( tdata_t ) buffer , t2p -> tiff_datasize * t2p -> tiff_samplesperpixel ) ; if ( samplebuffer == NULL ) { TIFFError ( TIFF2PDF_MODULE , \"Can\\'t<S2SV_blank>allocate<S2SV_blank>%lu<S2SV_blank>bytes<S2SV_blank>of<S2SV_blank>memory<S2SV_blank>for<S2SV_blank>t2p_readwrite_pdf_image,<S2SV_blank>%s\" , ( unsigned long ) t2p -> tiff_datasize , TIFFFileName ( input ) ) ; t2p -> t2p_error = T2P_ERR_ERROR ; _TIFFfree ( buffer ) ; return ( 0 ) ; } else { buffer = samplebuffer ; t2p -> tiff_datasize *= t2p -> tiff_samplesperpixel ; } t2p_sample_realize_palette ( t2p , buffer ) ; } if ( t2p -> pdf_sample & T2P_SAMPLE_RGBA_TO_RGB ) { t2p -> tiff_datasize = t2p_sample_rgba_to_rgb ( ( tdata_t ) buffer , t2p -> tiff_width * t2p -> tiff_length ) ; } if ( t2p -> pdf_sample & T2P_SAMPLE_RGBAA_TO_RGB ) { t2p -> tiff_datasize = t2p_sample_rgbaa_to_rgb ( ( tdata_t ) buffer , t2p -> tiff_width * t2p -> tiff_length ) ; } if ( t2p -> pdf_sample & T2P_SAMPLE_YCBCR_TO_RGB ) { samplebuffer = ( unsigned char * ) _TIFFrealloc ( ( tdata_t ) buffer , t2p -> tiff_width * t2p -> tiff_length * 4 ) ; if ( samplebuffer == NULL ) { TIFFError ( TIFF2PDF_MODULE , \"Can\\'t<S2SV_blank>allocate<S2SV_blank>%lu<S2SV_blank>bytes<S2SV_blank>of<S2SV_blank>memory<S2SV_blank>for<S2SV_blank>t2p_readwrite_pdf_image,<S2SV_blank>%s\" , ( unsigned long ) t2p -> tiff_datasize , TIFFFileName ( input ) ) ; t2p -> t2p_error = T2P_ERR_ERROR ; _TIFFfree ( buffer ) ; return ( 0 ) ; } else { buffer = samplebuffer ; } if ( ! TIFFReadRGBAImageOriented ( input , t2p -> tiff_width , t2p -> tiff_length , ( uint32 * ) buffer , ORIENTATION_TOPLEFT , 0 ) ) { TIFFError ( TIFF2PDF_MODULE , \"Can\\'t<S2SV_blank>use<S2SV_blank>TIFFReadRGBAImageOriented<S2SV_blank>to<S2SV_blank>extract<S2SV_blank>RGB<S2SV_blank>image<S2SV_blank>from<S2SV_blank>%s\" , TIFFFileName ( input ) ) ; t2p -> t2p_error = T2P_ERR_ERROR ; return ( 0 ) ; } t2p -> tiff_datasize = t2p_sample_abgr_to_rgb ( ( tdata_t ) buffer , t2p -> tiff_width * t2p -> tiff_length ) ; } if ( t2p -> pdf_sample & T2P_SAMPLE_LAB_SIGNED_TO_UNSIGNED ) { t2p -> tiff_datasize = t2p_sample_lab_signed_to_unsigned ( ( tdata_t ) buffer , t2p -> tiff_width * t2p -> tiff_length ) ; } } dataready : t2p_disable ( output ) ; TIFFSetField ( output , TIFFTAG_PHOTOMETRIC , t2p -> tiff_photometric ) ; TIFFSetField ( output , TIFFTAG_BITSPERSAMPLE , t2p -> tiff_bitspersample ) ; TIFFSetField ( output , TIFFTAG_SAMPLESPERPIXEL , t2p -> tiff_samplesperpixel ) ; TIFFSetField ( output , TIFFTAG_IMAGEWIDTH , t2p -> tiff_width ) ; TIFFSetField ( output , TIFFTAG_IMAGELENGTH , t2p -> tiff_length ) ; TIFFSetField ( output , TIFFTAG_ROWSPERSTRIP , t2p -> tiff_length ) ; TIFFSetField ( output , TIFFTAG_PLANARCONFIG , PLANARCONFIG_CONTIG ) ; TIFFSetField ( output , TIFFTAG_FILLORDER , FILLORDER_MSB2LSB ) ; switch ( t2p -> pdf_compression ) { case T2P_COMPRESS_NONE : TIFFSetField ( output , TIFFTAG_COMPRESSION , COMPRESSION_NONE ) ; break ; # ifdef CCITT_SUPPORT case T2P_COMPRESS_G4 : TIFFSetField ( output , TIFFTAG_COMPRESSION , COMPRESSION_CCITTFAX4 ) ; break ; # endif # ifdef JPEG_SUPPORT case T2P_COMPRESS_JPEG : if ( t2p -> tiff_photometric == PHOTOMETRIC_YCBCR ) { uint16 hor = 0 , ver = 0 ; if ( TIFFGetField ( input , TIFFTAG_YCBCRSUBSAMPLING , & hor , & ver ) != 0 ) { if ( hor != 0 && ver != 0 ) { TIFFSetField ( output , TIFFTAG_YCBCRSUBSAMPLING , hor , ver ) ; } } if ( TIFFGetField ( input , TIFFTAG_REFERENCEBLACKWHITE , & xfloatp ) != 0 ) { TIFFSetField ( output , TIFFTAG_REFERENCEBLACKWHITE , xfloatp ) ; } } if ( TIFFSetField ( output , TIFFTAG_COMPRESSION , COMPRESSION_JPEG ) == 0 ) { TIFFError ( TIFF2PDF_MODULE , \"Unable<S2SV_blank>to<S2SV_blank>use<S2SV_blank>JPEG<S2SV_blank>compression<S2SV_blank>for<S2SV_blank>input<S2SV_blank>%s<S2SV_blank>and<S2SV_blank>output<S2SV_blank>%s\" , TIFFFileName ( input ) , TIFFFileName ( output ) ) ; _TIFFfree ( buffer ) ; t2p -> t2p_error = T2P_ERR_ERROR ; return ( 0 ) ; } TIFFSetField ( output , TIFFTAG_JPEGTABLESMODE , 0 ) ; if ( t2p -> pdf_colorspace & ( T2P_CS_RGB | T2P_CS_LAB ) ) { TIFFSetField ( output , TIFFTAG_PHOTOMETRIC , PHOTOMETRIC_YCBCR ) ; if ( t2p -> tiff_photometric != PHOTOMETRIC_YCBCR ) { TIFFSetField ( output , TIFFTAG_JPEGCOLORMODE , JPEGCOLORMODE_RGB ) ; } else { TIFFSetField ( output , TIFFTAG_JPEGCOLORMODE , JPEGCOLORMODE_RAW ) ; } } if ( t2p -> pdf_colorspace & T2P_CS_GRAY ) { ( void ) 0 ; } if ( t2p -> pdf_colorspace & T2P_CS_CMYK ) { ( void ) 0 ; } if ( t2p -> pdf_defaultcompressionquality != 0 ) { TIFFSetField ( output , TIFFTAG_JPEGQUALITY , t2p -> pdf_defaultcompressionquality ) ; } break ; # endif # ifdef ZIP_SUPPORT case T2P_COMPRESS_ZIP : TIFFSetField ( output , TIFFTAG_COMPRESSION , COMPRESSION_DEFLATE ) ; if ( t2p -> pdf_defaultcompressionquality % 100 != 0 ) { TIFFSetField ( output , TIFFTAG_PREDICTOR , t2p -> pdf_defaultcompressionquality % 100 ) ; } if ( t2p -> pdf_defaultcompressionquality / 100 != 0 ) { TIFFSetField ( output , TIFFTAG_ZIPQUALITY , ( t2p -> pdf_defaultcompressionquality / 100 ) ) ; } break ; # endif default : break ; } t2p_enable ( output ) ; t2p -> outputwritten = 0 ; # ifdef JPEG_SUPPORT if ( t2p -> pdf_compression == T2P_COMPRESS_JPEG && t2p -> tiff_photometric == PHOTOMETRIC_YCBCR ) { bufferoffset = TIFFWriteEncodedStrip ( output , ( tstrip_t ) 0 , buffer , stripsize * stripcount ) ; } else # endif { bufferoffset = TIFFWriteEncodedStrip ( output , ( tstrip_t ) 0 , buffer , t2p -> tiff_datasize ) ; } if ( buffer != NULL ) { _TIFFfree ( buffer ) ; buffer = NULL ; } if ( bufferoffset == ( tsize_t ) - 1 ) { TIFFError ( TIFF2PDF_MODULE , \"Error<S2SV_blank>writing<S2SV_blank>encoded<S2SV_blank>strip<S2SV_blank>to<S2SV_blank>output<S2SV_blank>PDF<S2SV_blank>%s\" , TIFFFileName ( output ) ) ; t2p -> t2p_error = T2P_ERR_ERROR ; return ( 0 ) ; } written = t2p -> outputwritten ; return ( written ) ; }\n","target":"<S2SV_ModStart> , buffer , t2p -> tiff_datasize ,\n","project_and_commit_id":"vadz@libtiff/83a4b92815ea04969d494416eaae3d4c6b338e4a","cve_id":"CVE-2016-9537","original_address":"https://github.com/vadz/libtiff/commit/83a4b92815ea04969d494416eaae3d4c6b338e4a","time":"2016-11-22T19:59Z"},
	{"Unnamed: 0":4481,"cwe_id":"CWE-190","source":"CWE-190 static int vfio_msi_enable ( struct vfio_pci_device * vdev , int nvec , bool msix ) { struct pci_dev * pdev = vdev -> pdev ; unsigned int flag = msix ? PCI_IRQ_MSIX : PCI_IRQ_MSI ; int ret ; if ( ! is_irq_none ( vdev ) ) return - EINVAL ; <S2SV_StartBug> vdev -> ctx = kzalloc ( nvec * sizeof ( struct vfio_pci_irq_ctx ) , GFP_KERNEL ) ; <S2SV_EndBug> if ( ! vdev -> ctx ) return - ENOMEM ; ret = pci_alloc_irq_vectors ( pdev , 1 , nvec , flag ) ; if ( ret < nvec ) { if ( ret > 0 ) pci_free_irq_vectors ( pdev ) ; kfree ( vdev -> ctx ) ; return ret ; } vdev -> num_ctx = nvec ; vdev -> irq_type = msix ? VFIO_PCI_MSIX_IRQ_INDEX : VFIO_PCI_MSI_IRQ_INDEX ; if ( ! msix ) { vdev -> msi_qmax = fls ( nvec * 2 - 1 ) - 1 ; } return 0 ; }\n","target":"<S2SV_ModStart> -> ctx = kcalloc ( nvec , <S2SV_ModEnd> sizeof ( struct\n","project_and_commit_id":"torvalds@linux/05692d7005a364add85c6e25a6c4447ce08f913a","cve_id":"CVE-2016-9084","original_address":"https://github.com/torvalds/linux/commit/05692d7005a364add85c6e25a6c4447ce08f913a","time":"2016-11-28T03:59Z"},
	{"Unnamed: 0":3473,"cwe_id":"CWE-125","source":"CWE-125 static int ext4_fill_super ( struct super_block * sb , void * data , int silent ) { char * orig_data = kstrdup ( data , GFP_KERNEL ) ; struct buffer_head * bh ; struct ext4_super_block * es = NULL ; struct ext4_sb_info * sbi = kzalloc ( sizeof ( * sbi ) , GFP_KERNEL ) ; ext4_fsblk_t block ; ext4_fsblk_t sb_block = get_sb_block ( & data ) ; ext4_fsblk_t logical_sb_block ; unsigned long offset = 0 ; unsigned long journal_devnum = 0 ; unsigned long def_mount_opts ; struct inode * root ; const char * descr ; int ret = - ENOMEM ; int blocksize , clustersize ; unsigned int db_count ; unsigned int i ; int needs_recovery , has_huge_files , has_bigalloc ; __u64 blocks_count ; int err = 0 ; unsigned int journal_ioprio = DEFAULT_JOURNAL_IOPRIO ; ext4_group_t first_not_zeroed ; if ( ( data && ! orig_data ) || ! sbi ) goto out_free_base ; sbi -> s_blockgroup_lock = kzalloc ( sizeof ( struct blockgroup_lock ) , GFP_KERNEL ) ; if ( ! sbi -> s_blockgroup_lock ) goto out_free_base ; sb -> s_fs_info = sbi ; sbi -> s_sb = sb ; sbi -> s_inode_readahead_blks = EXT4_DEF_INODE_READAHEAD_BLKS ; sbi -> s_sb_block = sb_block ; if ( sb -> s_bdev -> bd_part ) sbi -> s_sectors_written_start = part_stat_read ( sb -> s_bdev -> bd_part , sectors [ 1 ] ) ; strreplace ( sb -> s_id , '/' , '!' ) ; ret = - EINVAL ; blocksize = sb_min_blocksize ( sb , EXT4_MIN_BLOCK_SIZE ) ; if ( ! blocksize ) { ext4_msg ( sb , KERN_ERR , \"unable<S2SV_blank>to<S2SV_blank>set<S2SV_blank>blocksize\" ) ; goto out_fail ; } if ( blocksize != EXT4_MIN_BLOCK_SIZE ) { logical_sb_block = sb_block * EXT4_MIN_BLOCK_SIZE ; offset = do_div ( logical_sb_block , blocksize ) ; } else { logical_sb_block = sb_block ; } if ( ! ( bh = sb_bread_unmovable ( sb , logical_sb_block ) ) ) { ext4_msg ( sb , KERN_ERR , \"unable<S2SV_blank>to<S2SV_blank>read<S2SV_blank>superblock\" ) ; goto out_fail ; } es = ( struct ext4_super_block * ) ( bh -> b_data + offset ) ; sbi -> s_es = es ; sb -> s_magic = le16_to_cpu ( es -> s_magic ) ; if ( sb -> s_magic != EXT4_SUPER_MAGIC ) goto cantfind_ext4 ; sbi -> s_kbytes_written = le64_to_cpu ( es -> s_kbytes_written ) ; if ( ext4_has_feature_metadata_csum ( sb ) && ext4_has_feature_gdt_csum ( sb ) ) ext4_warning ( sb , \"metadata_csum<S2SV_blank>and<S2SV_blank>uninit_bg<S2SV_blank>are<S2SV_blank>\" \"redundant<S2SV_blank>flags;<S2SV_blank>please<S2SV_blank>run<S2SV_blank>fsck.\" ) ; if ( ! ext4_verify_csum_type ( sb , es ) ) { ext4_msg ( sb , KERN_ERR , \"VFS:<S2SV_blank>Found<S2SV_blank>ext4<S2SV_blank>filesystem<S2SV_blank>with<S2SV_blank>\" \"unknown<S2SV_blank>checksum<S2SV_blank>algorithm.\" ) ; silent = 1 ; goto cantfind_ext4 ; } if ( ext4_has_feature_metadata_csum ( sb ) ) { sbi -> s_chksum_driver = crypto_alloc_shash ( \"crc32c\" , 0 , 0 ) ; if ( IS_ERR ( sbi -> s_chksum_driver ) ) { ext4_msg ( sb , KERN_ERR , \"Cannot<S2SV_blank>load<S2SV_blank>crc32c<S2SV_blank>driver.\" ) ; ret = PTR_ERR ( sbi -> s_chksum_driver ) ; sbi -> s_chksum_driver = NULL ; goto failed_mount ; } } if ( ! ext4_superblock_csum_verify ( sb , es ) ) { ext4_msg ( sb , KERN_ERR , \"VFS:<S2SV_blank>Found<S2SV_blank>ext4<S2SV_blank>filesystem<S2SV_blank>with<S2SV_blank>\" \"invalid<S2SV_blank>superblock<S2SV_blank>checksum.<S2SV_blank><S2SV_blank>Run<S2SV_blank>e2fsck?\" ) ; silent = 1 ; ret = - EFSBADCRC ; goto cantfind_ext4 ; } if ( ext4_has_feature_csum_seed ( sb ) ) sbi -> s_csum_seed = le32_to_cpu ( es -> s_checksum_seed ) ; else if ( ext4_has_metadata_csum ( sb ) ) sbi -> s_csum_seed = ext4_chksum ( sbi , ~ 0 , es -> s_uuid , sizeof ( es -> s_uuid ) ) ; def_mount_opts = le32_to_cpu ( es -> s_default_mount_opts ) ; set_opt ( sb , INIT_INODE_TABLE ) ; if ( def_mount_opts & EXT4_DEFM_DEBUG ) set_opt ( sb , DEBUG ) ; if ( def_mount_opts & EXT4_DEFM_BSDGROUPS ) set_opt ( sb , GRPID ) ; if ( def_mount_opts & EXT4_DEFM_UID16 ) set_opt ( sb , NO_UID32 ) ; set_opt ( sb , XATTR_USER ) ; # ifdef CONFIG_EXT4_FS_POSIX_ACL set_opt ( sb , POSIX_ACL ) ; # endif if ( ext4_has_metadata_csum ( sb ) ) set_opt ( sb , JOURNAL_CHECKSUM ) ; if ( ( def_mount_opts & EXT4_DEFM_JMODE ) == EXT4_DEFM_JMODE_DATA ) set_opt ( sb , JOURNAL_DATA ) ; else if ( ( def_mount_opts & EXT4_DEFM_JMODE ) == EXT4_DEFM_JMODE_ORDERED ) set_opt ( sb , ORDERED_DATA ) ; else if ( ( def_mount_opts & EXT4_DEFM_JMODE ) == EXT4_DEFM_JMODE_WBACK ) set_opt ( sb , WRITEBACK_DATA ) ; if ( le16_to_cpu ( sbi -> s_es -> s_errors ) == EXT4_ERRORS_PANIC ) set_opt ( sb , ERRORS_PANIC ) ; else if ( le16_to_cpu ( sbi -> s_es -> s_errors ) == EXT4_ERRORS_CONTINUE ) set_opt ( sb , ERRORS_CONT ) ; else set_opt ( sb , ERRORS_RO ) ; set_opt ( sb , BLOCK_VALIDITY ) ; if ( def_mount_opts & EXT4_DEFM_DISCARD ) set_opt ( sb , DISCARD ) ; sbi -> s_resuid = make_kuid ( & init_user_ns , le16_to_cpu ( es -> s_def_resuid ) ) ; sbi -> s_resgid = make_kgid ( & init_user_ns , le16_to_cpu ( es -> s_def_resgid ) ) ; sbi -> s_commit_interval = JBD2_DEFAULT_MAX_COMMIT_AGE * HZ ; sbi -> s_min_batch_time = EXT4_DEF_MIN_BATCH_TIME ; sbi -> s_max_batch_time = EXT4_DEF_MAX_BATCH_TIME ; if ( ( def_mount_opts & EXT4_DEFM_NOBARRIER ) == 0 ) set_opt ( sb , BARRIER ) ; if ( ! IS_EXT3_SB ( sb ) && ! IS_EXT2_SB ( sb ) && ( ( def_mount_opts & EXT4_DEFM_NODELALLOC ) == 0 ) ) set_opt ( sb , DELALLOC ) ; sbi -> s_li_wait_mult = EXT4_DEF_LI_WAIT_MULT ; if ( sbi -> s_es -> s_mount_opts [ 0 ] ) { char * s_mount_opts = kstrndup ( sbi -> s_es -> s_mount_opts , sizeof ( sbi -> s_es -> s_mount_opts ) , GFP_KERNEL ) ; if ( ! s_mount_opts ) goto failed_mount ; if ( ! parse_options ( s_mount_opts , sb , & journal_devnum , & journal_ioprio , 0 ) ) { ext4_msg ( sb , KERN_WARNING , \"failed<S2SV_blank>to<S2SV_blank>parse<S2SV_blank>options<S2SV_blank>in<S2SV_blank>superblock:<S2SV_blank>%s\" , s_mount_opts ) ; } kfree ( s_mount_opts ) ; } sbi -> s_def_mount_opt = sbi -> s_mount_opt ; if ( ! parse_options ( ( char * ) data , sb , & journal_devnum , & journal_ioprio , 0 ) ) goto failed_mount ; if ( test_opt ( sb , DATA_FLAGS ) == EXT4_MOUNT_JOURNAL_DATA ) { printk_once ( KERN_WARNING \"EXT4-fs:<S2SV_blank>Warning:<S2SV_blank>mounting<S2SV_blank>\" \"with<S2SV_blank>data=journal<S2SV_blank>disables<S2SV_blank>delayed<S2SV_blank>\" \"allocation<S2SV_blank>and<S2SV_blank>O_DIRECT<S2SV_blank>support!\\\\n\" ) ; if ( test_opt2 ( sb , EXPLICIT_DELALLOC ) ) { ext4_msg ( sb , KERN_ERR , \"can\\'t<S2SV_blank>mount<S2SV_blank>with<S2SV_blank>\" \"both<S2SV_blank>data=journal<S2SV_blank>and<S2SV_blank>delalloc\" ) ; goto failed_mount ; } if ( test_opt ( sb , DIOREAD_NOLOCK ) ) { ext4_msg ( sb , KERN_ERR , \"can\\'t<S2SV_blank>mount<S2SV_blank>with<S2SV_blank>\" \"both<S2SV_blank>data=journal<S2SV_blank>and<S2SV_blank>dioread_nolock\" ) ; goto failed_mount ; } if ( test_opt ( sb , DAX ) ) { ext4_msg ( sb , KERN_ERR , \"can\\'t<S2SV_blank>mount<S2SV_blank>with<S2SV_blank>\" \"both<S2SV_blank>data=journal<S2SV_blank>and<S2SV_blank>dax\" ) ; goto failed_mount ; } if ( test_opt ( sb , DELALLOC ) ) clear_opt ( sb , DELALLOC ) ; } else { sb -> s_iflags |= SB_I_CGROUPWB ; } sb -> s_flags = ( sb -> s_flags & ~ MS_POSIXACL ) | ( test_opt ( sb , POSIX_ACL ) ? MS_POSIXACL : 0 ) ; if ( le32_to_cpu ( es -> s_rev_level ) == EXT4_GOOD_OLD_REV && ( ext4_has_compat_features ( sb ) || ext4_has_ro_compat_features ( sb ) || ext4_has_incompat_features ( sb ) ) ) ext4_msg ( sb , KERN_WARNING , \"feature<S2SV_blank>flags<S2SV_blank>set<S2SV_blank>on<S2SV_blank>rev<S2SV_blank>0<S2SV_blank>fs,<S2SV_blank>\" \"running<S2SV_blank>e2fsck<S2SV_blank>is<S2SV_blank>recommended\" ) ; if ( es -> s_creator_os == cpu_to_le32 ( EXT4_OS_HURD ) ) { set_opt2 ( sb , HURD_COMPAT ) ; if ( ext4_has_feature_64bit ( sb ) ) { ext4_msg ( sb , KERN_ERR , \"The<S2SV_blank>Hurd<S2SV_blank>can\\'t<S2SV_blank>support<S2SV_blank>64-bit<S2SV_blank>file<S2SV_blank>systems\" ) ; goto failed_mount ; } } if ( IS_EXT2_SB ( sb ) ) { if ( ext2_feature_set_ok ( sb ) ) ext4_msg ( sb , KERN_INFO , \"mounting<S2SV_blank>ext2<S2SV_blank>file<S2SV_blank>system<S2SV_blank>\" \"using<S2SV_blank>the<S2SV_blank>ext4<S2SV_blank>subsystem\" ) ; else { ext4_msg ( sb , KERN_ERR , \"couldn\\'t<S2SV_blank>mount<S2SV_blank>as<S2SV_blank>ext2<S2SV_blank>due<S2SV_blank>\" \"to<S2SV_blank>feature<S2SV_blank>incompatibilities\" ) ; goto failed_mount ; } } if ( IS_EXT3_SB ( sb ) ) { if ( ext3_feature_set_ok ( sb ) ) ext4_msg ( sb , KERN_INFO , \"mounting<S2SV_blank>ext3<S2SV_blank>file<S2SV_blank>system<S2SV_blank>\" \"using<S2SV_blank>the<S2SV_blank>ext4<S2SV_blank>subsystem\" ) ; else { ext4_msg ( sb , KERN_ERR , \"couldn\\'t<S2SV_blank>mount<S2SV_blank>as<S2SV_blank>ext3<S2SV_blank>due<S2SV_blank>\" \"to<S2SV_blank>feature<S2SV_blank>incompatibilities\" ) ; goto failed_mount ; } } if ( ! ext4_feature_set_ok ( sb , ( sb -> s_flags & MS_RDONLY ) ) ) goto failed_mount ; blocksize = BLOCK_SIZE << le32_to_cpu ( es -> s_log_block_size ) ; if ( blocksize < EXT4_MIN_BLOCK_SIZE || blocksize > EXT4_MAX_BLOCK_SIZE ) { ext4_msg ( sb , KERN_ERR , \"Unsupported<S2SV_blank>filesystem<S2SV_blank>blocksize<S2SV_blank>%d<S2SV_blank>(%d<S2SV_blank>log_block_size)\" , blocksize , le32_to_cpu ( es -> s_log_block_size ) ) ; goto failed_mount ; } if ( le32_to_cpu ( es -> s_log_block_size ) > ( EXT4_MAX_BLOCK_LOG_SIZE - EXT4_MIN_BLOCK_LOG_SIZE ) ) { ext4_msg ( sb , KERN_ERR , \"Invalid<S2SV_blank>log<S2SV_blank>block<S2SV_blank>size:<S2SV_blank>%u\" , le32_to_cpu ( es -> s_log_block_size ) ) ; goto failed_mount ; } if ( le16_to_cpu ( sbi -> s_es -> s_reserved_gdt_blocks ) > ( blocksize / 4 ) ) { ext4_msg ( sb , KERN_ERR , \"Number<S2SV_blank>of<S2SV_blank>reserved<S2SV_blank>GDT<S2SV_blank>blocks<S2SV_blank>insanely<S2SV_blank>large:<S2SV_blank>%d\" , le16_to_cpu ( sbi -> s_es -> s_reserved_gdt_blocks ) ) ; goto failed_mount ; } if ( sbi -> s_mount_opt & EXT4_MOUNT_DAX ) { err = bdev_dax_supported ( sb , blocksize ) ; if ( err ) goto failed_mount ; } if ( ext4_has_feature_encrypt ( sb ) && es -> s_encryption_level ) { ext4_msg ( sb , KERN_ERR , \"Unsupported<S2SV_blank>encryption<S2SV_blank>level<S2SV_blank>%d\" , es -> s_encryption_level ) ; goto failed_mount ; } if ( sb -> s_blocksize != blocksize ) { if ( ! sb_set_blocksize ( sb , blocksize ) ) { ext4_msg ( sb , KERN_ERR , \"bad<S2SV_blank>block<S2SV_blank>size<S2SV_blank>%d\" , blocksize ) ; goto failed_mount ; } brelse ( bh ) ; logical_sb_block = sb_block * EXT4_MIN_BLOCK_SIZE ; offset = do_div ( logical_sb_block , blocksize ) ; bh = sb_bread_unmovable ( sb , logical_sb_block ) ; if ( ! bh ) { ext4_msg ( sb , KERN_ERR , \"Can\\'t<S2SV_blank>read<S2SV_blank>superblock<S2SV_blank>on<S2SV_blank>2nd<S2SV_blank>try\" ) ; goto failed_mount ; } es = ( struct ext4_super_block * ) ( bh -> b_data + offset ) ; sbi -> s_es = es ; if ( es -> s_magic != cpu_to_le16 ( EXT4_SUPER_MAGIC ) ) { ext4_msg ( sb , KERN_ERR , \"Magic<S2SV_blank>mismatch,<S2SV_blank>very<S2SV_blank>weird!\" ) ; goto failed_mount ; } } has_huge_files = ext4_has_feature_huge_file ( sb ) ; sbi -> s_bitmap_maxbytes = ext4_max_bitmap_size ( sb -> s_blocksize_bits , has_huge_files ) ; sb -> s_maxbytes = ext4_max_size ( sb -> s_blocksize_bits , has_huge_files ) ; if ( le32_to_cpu ( es -> s_rev_level ) == EXT4_GOOD_OLD_REV ) { sbi -> s_inode_size = EXT4_GOOD_OLD_INODE_SIZE ; sbi -> s_first_ino = EXT4_GOOD_OLD_FIRST_INO ; } else { sbi -> s_inode_size = le16_to_cpu ( es -> s_inode_size ) ; sbi -> s_first_ino = le32_to_cpu ( es -> s_first_ino ) ; if ( ( sbi -> s_inode_size < EXT4_GOOD_OLD_INODE_SIZE ) || ( ! is_power_of_2 ( sbi -> s_inode_size ) ) || ( sbi -> s_inode_size > blocksize ) ) { ext4_msg ( sb , KERN_ERR , \"unsupported<S2SV_blank>inode<S2SV_blank>size:<S2SV_blank>%d\" , sbi -> s_inode_size ) ; goto failed_mount ; } if ( sbi -> s_inode_size > EXT4_GOOD_OLD_INODE_SIZE ) sb -> s_time_gran = 1 << ( EXT4_EPOCH_BITS - 2 ) ; } sbi -> s_desc_size = le16_to_cpu ( es -> s_desc_size ) ; if ( ext4_has_feature_64bit ( sb ) ) { if ( sbi -> s_desc_size < EXT4_MIN_DESC_SIZE_64BIT || sbi -> s_desc_size > EXT4_MAX_DESC_SIZE || ! is_power_of_2 ( sbi -> s_desc_size ) ) { ext4_msg ( sb , KERN_ERR , \"unsupported<S2SV_blank>descriptor<S2SV_blank>size<S2SV_blank>%lu\" , sbi -> s_desc_size ) ; goto failed_mount ; } } else sbi -> s_desc_size = EXT4_MIN_DESC_SIZE ; sbi -> s_blocks_per_group = le32_to_cpu ( es -> s_blocks_per_group ) ; sbi -> s_inodes_per_group = le32_to_cpu ( es -> s_inodes_per_group ) ; sbi -> s_inodes_per_block = blocksize / EXT4_INODE_SIZE ( sb ) ; if ( sbi -> s_inodes_per_block == 0 ) goto cantfind_ext4 ; if ( sbi -> s_inodes_per_group < sbi -> s_inodes_per_block || sbi -> s_inodes_per_group > blocksize * 8 ) { ext4_msg ( sb , KERN_ERR , \"invalid<S2SV_blank>inodes<S2SV_blank>per<S2SV_blank>group:<S2SV_blank>%lu\\\\n\" , sbi -> s_blocks_per_group ) ; goto failed_mount ; } sbi -> s_itb_per_group = sbi -> s_inodes_per_group / sbi -> s_inodes_per_block ; sbi -> s_desc_per_block = blocksize / EXT4_DESC_SIZE ( sb ) ; sbi -> s_sbh = bh ; sbi -> s_mount_state = le16_to_cpu ( es -> s_state ) ; sbi -> s_addr_per_block_bits = ilog2 ( EXT4_ADDR_PER_BLOCK ( sb ) ) ; sbi -> s_desc_per_block_bits = ilog2 ( EXT4_DESC_PER_BLOCK ( sb ) ) ; for ( i = 0 ; i < 4 ; i ++ ) sbi -> s_hash_seed [ i ] = le32_to_cpu ( es -> s_hash_seed [ i ] ) ; sbi -> s_def_hash_version = es -> s_def_hash_version ; if ( ext4_has_feature_dir_index ( sb ) ) { i = le32_to_cpu ( es -> s_flags ) ; if ( i & EXT2_FLAGS_UNSIGNED_HASH ) sbi -> s_hash_unsigned = 3 ; else if ( ( i & EXT2_FLAGS_SIGNED_HASH ) == 0 ) { # ifdef __CHAR_UNSIGNED__ if ( ! ( sb -> s_flags & MS_RDONLY ) ) es -> s_flags |= cpu_to_le32 ( EXT2_FLAGS_UNSIGNED_HASH ) ; sbi -> s_hash_unsigned = 3 ; # else if ( ! ( sb -> s_flags & MS_RDONLY ) ) es -> s_flags |= cpu_to_le32 ( EXT2_FLAGS_SIGNED_HASH ) ; # endif } } clustersize = BLOCK_SIZE << le32_to_cpu ( es -> s_log_cluster_size ) ; has_bigalloc = ext4_has_feature_bigalloc ( sb ) ; if ( has_bigalloc ) { if ( clustersize < blocksize ) { ext4_msg ( sb , KERN_ERR , \"cluster<S2SV_blank>size<S2SV_blank>(%d)<S2SV_blank>smaller<S2SV_blank>than<S2SV_blank>\" \"block<S2SV_blank>size<S2SV_blank>(%d)\" , clustersize , blocksize ) ; goto failed_mount ; } if ( le32_to_cpu ( es -> s_log_cluster_size ) > ( EXT4_MAX_CLUSTER_LOG_SIZE - EXT4_MIN_BLOCK_LOG_SIZE ) ) { ext4_msg ( sb , KERN_ERR , \"Invalid<S2SV_blank>log<S2SV_blank>cluster<S2SV_blank>size:<S2SV_blank>%u\" , le32_to_cpu ( es -> s_log_cluster_size ) ) ; goto failed_mount ; } sbi -> s_cluster_bits = le32_to_cpu ( es -> s_log_cluster_size ) - le32_to_cpu ( es -> s_log_block_size ) ; sbi -> s_clusters_per_group = le32_to_cpu ( es -> s_clusters_per_group ) ; if ( sbi -> s_clusters_per_group > blocksize * 8 ) { ext4_msg ( sb , KERN_ERR , \"#clusters<S2SV_blank>per<S2SV_blank>group<S2SV_blank>too<S2SV_blank>big:<S2SV_blank>%lu\" , sbi -> s_clusters_per_group ) ; goto failed_mount ; } if ( sbi -> s_blocks_per_group != ( sbi -> s_clusters_per_group * ( clustersize / blocksize ) ) ) { ext4_msg ( sb , KERN_ERR , \"blocks<S2SV_blank>per<S2SV_blank>group<S2SV_blank>(%lu)<S2SV_blank>and<S2SV_blank>\" \"clusters<S2SV_blank>per<S2SV_blank>group<S2SV_blank>(%lu)<S2SV_blank>inconsistent\" , sbi -> s_blocks_per_group , sbi -> s_clusters_per_group ) ; goto failed_mount ; } } else { if ( clustersize != blocksize ) { ext4_warning ( sb , \"fragment/cluster<S2SV_blank>size<S2SV_blank>(%d)<S2SV_blank>!=<S2SV_blank>\" \"block<S2SV_blank>size<S2SV_blank>(%d)\" , clustersize , blocksize ) ; clustersize = blocksize ; } if ( sbi -> s_blocks_per_group > blocksize * 8 ) { ext4_msg ( sb , KERN_ERR , \"#blocks<S2SV_blank>per<S2SV_blank>group<S2SV_blank>too<S2SV_blank>big:<S2SV_blank>%lu\" , sbi -> s_blocks_per_group ) ; goto failed_mount ; } sbi -> s_clusters_per_group = sbi -> s_blocks_per_group ; sbi -> s_cluster_bits = 0 ; } sbi -> s_cluster_ratio = clustersize / blocksize ; if ( sbi -> s_blocks_per_group == clustersize << 3 ) set_opt2 ( sb , STD_GROUP_SIZE ) ; err = generic_check_addressable ( sb -> s_blocksize_bits , ext4_blocks_count ( es ) ) ; if ( err ) { ext4_msg ( sb , KERN_ERR , \"filesystem\" \"<S2SV_blank>too<S2SV_blank>large<S2SV_blank>to<S2SV_blank>mount<S2SV_blank>safely<S2SV_blank>on<S2SV_blank>this<S2SV_blank>system\" ) ; if ( sizeof ( sector_t ) < 8 ) ext4_msg ( sb , KERN_WARNING , \"CONFIG_LBDAF<S2SV_blank>not<S2SV_blank>enabled\" ) ; goto failed_mount ; } if ( EXT4_BLOCKS_PER_GROUP ( sb ) == 0 ) goto cantfind_ext4 ; blocks_count = sb -> s_bdev -> bd_inode -> i_size >> sb -> s_blocksize_bits ; if ( blocks_count && ext4_blocks_count ( es ) > blocks_count ) { ext4_msg ( sb , KERN_WARNING , \"bad<S2SV_blank>geometry:<S2SV_blank>block<S2SV_blank>count<S2SV_blank>%llu<S2SV_blank>\" \"exceeds<S2SV_blank>size<S2SV_blank>of<S2SV_blank>device<S2SV_blank>(%llu<S2SV_blank>blocks)\" , ext4_blocks_count ( es ) , blocks_count ) ; goto failed_mount ; } if ( le32_to_cpu ( es -> s_first_data_block ) >= ext4_blocks_count ( es ) ) { ext4_msg ( sb , KERN_WARNING , \"bad<S2SV_blank>geometry:<S2SV_blank>first<S2SV_blank>data<S2SV_blank>\" \"block<S2SV_blank>%u<S2SV_blank>is<S2SV_blank>beyond<S2SV_blank>end<S2SV_blank>of<S2SV_blank>filesystem<S2SV_blank>(%llu)\" , le32_to_cpu ( es -> s_first_data_block ) , ext4_blocks_count ( es ) ) ; goto failed_mount ; } blocks_count = ( ext4_blocks_count ( es ) - le32_to_cpu ( es -> s_first_data_block ) + EXT4_BLOCKS_PER_GROUP ( sb ) - 1 ) ; do_div ( blocks_count , EXT4_BLOCKS_PER_GROUP ( sb ) ) ; if ( blocks_count > ( ( uint64_t ) 1 << 32 ) - EXT4_DESC_PER_BLOCK ( sb ) ) { ext4_msg ( sb , KERN_WARNING , \"groups<S2SV_blank>count<S2SV_blank>too<S2SV_blank>large:<S2SV_blank>%u<S2SV_blank>\" \"(block<S2SV_blank>count<S2SV_blank>%llu,<S2SV_blank>first<S2SV_blank>data<S2SV_blank>block<S2SV_blank>%u,<S2SV_blank>\" \"blocks<S2SV_blank>per<S2SV_blank>group<S2SV_blank>%lu)\" , sbi -> s_groups_count , ext4_blocks_count ( es ) , le32_to_cpu ( es -> s_first_data_block ) , EXT4_BLOCKS_PER_GROUP ( sb ) ) ; goto failed_mount ; } sbi -> s_groups_count = blocks_count ; sbi -> s_blockfile_groups = min_t ( ext4_group_t , sbi -> s_groups_count , ( EXT4_MAX_BLOCK_FILE_PHYS / EXT4_BLOCKS_PER_GROUP ( sb ) ) ) ; db_count = ( sbi -> s_groups_count + EXT4_DESC_PER_BLOCK ( sb ) - 1 ) / <S2SV_StartBug> EXT4_DESC_PER_BLOCK ( sb ) ; <S2SV_EndBug> sbi -> s_group_desc = ext4_kvmalloc ( db_count * sizeof ( struct buffer_head * ) , GFP_KERNEL ) ; if ( sbi -> s_group_desc == NULL ) { ext4_msg ( sb , KERN_ERR , \"not<S2SV_blank>enough<S2SV_blank>memory\" ) ; ret = - ENOMEM ; goto failed_mount ; } bgl_lock_init ( sbi -> s_blockgroup_lock ) ; for ( i = 0 ; i < db_count ; i ++ ) { block = descriptor_loc ( sb , logical_sb_block , i ) ; sbi -> s_group_desc [ i ] = sb_bread_unmovable ( sb , block ) ; if ( ! sbi -> s_group_desc [ i ] ) { ext4_msg ( sb , KERN_ERR , \"can\\'t<S2SV_blank>read<S2SV_blank>group<S2SV_blank>descriptor<S2SV_blank>%d\" , i ) ; db_count = i ; goto failed_mount2 ; } } if ( ! ext4_check_descriptors ( sb , logical_sb_block , & first_not_zeroed ) ) { ext4_msg ( sb , KERN_ERR , \"group<S2SV_blank>descriptors<S2SV_blank>corrupted!\" ) ; ret = - EFSCORRUPTED ; goto failed_mount2 ; } sbi -> s_gdb_count = db_count ; get_random_bytes ( & sbi -> s_next_generation , sizeof ( u32 ) ) ; spin_lock_init ( & sbi -> s_next_gen_lock ) ; setup_timer ( & sbi -> s_err_report , print_daily_error_info , ( unsigned long ) sb ) ; if ( ext4_es_register_shrinker ( sbi ) ) goto failed_mount3 ; sbi -> s_stripe = ext4_get_stripe_size ( sbi ) ; sbi -> s_extent_max_zeroout_kb = 32 ; sb -> s_op = & ext4_sops ; sb -> s_export_op = & ext4_export_ops ; sb -> s_xattr = ext4_xattr_handlers ; sb -> s_cop = & ext4_cryptops ; # ifdef CONFIG_QUOTA sb -> dq_op = & ext4_quota_operations ; if ( ext4_has_feature_quota ( sb ) ) sb -> s_qcop = & dquot_quotactl_sysfile_ops ; else sb -> s_qcop = & ext4_qctl_operations ; sb -> s_quota_types = QTYPE_MASK_USR | QTYPE_MASK_GRP | QTYPE_MASK_PRJ ; # endif memcpy ( sb -> s_uuid , es -> s_uuid , sizeof ( es -> s_uuid ) ) ; INIT_LIST_HEAD ( & sbi -> s_orphan ) ; mutex_init ( & sbi -> s_orphan_lock ) ; sb -> s_root = NULL ; needs_recovery = ( es -> s_last_orphan != 0 || ext4_has_feature_journal_needs_recovery ( sb ) ) ; if ( ext4_has_feature_mmp ( sb ) && ! ( sb -> s_flags & MS_RDONLY ) ) if ( ext4_multi_mount_protect ( sb , le64_to_cpu ( es -> s_mmp_block ) ) ) goto failed_mount3a ; if ( ! test_opt ( sb , NOLOAD ) && ext4_has_feature_journal ( sb ) ) { if ( ext4_load_journal ( sb , es , journal_devnum ) ) goto failed_mount3a ; } else if ( test_opt ( sb , NOLOAD ) && ! ( sb -> s_flags & MS_RDONLY ) && ext4_has_feature_journal_needs_recovery ( sb ) ) { ext4_msg ( sb , KERN_ERR , \"required<S2SV_blank>journal<S2SV_blank>recovery<S2SV_blank>\" \"suppressed<S2SV_blank>and<S2SV_blank>not<S2SV_blank>mounted<S2SV_blank>read-only\" ) ; goto failed_mount_wq ; } else { if ( test_opt2 ( sb , EXPLICIT_JOURNAL_CHECKSUM ) ) { ext4_msg ( sb , KERN_ERR , \"can\\'t<S2SV_blank>mount<S2SV_blank>with<S2SV_blank>\" \"journal_checksum,<S2SV_blank>fs<S2SV_blank>mounted<S2SV_blank>w/o<S2SV_blank>journal\" ) ; goto failed_mount_wq ; } if ( test_opt ( sb , JOURNAL_ASYNC_COMMIT ) ) { ext4_msg ( sb , KERN_ERR , \"can\\'t<S2SV_blank>mount<S2SV_blank>with<S2SV_blank>\" \"journal_async_commit,<S2SV_blank>fs<S2SV_blank>mounted<S2SV_blank>w/o<S2SV_blank>journal\" ) ; goto failed_mount_wq ; } if ( sbi -> s_commit_interval != JBD2_DEFAULT_MAX_COMMIT_AGE * HZ ) { ext4_msg ( sb , KERN_ERR , \"can\\'t<S2SV_blank>mount<S2SV_blank>with<S2SV_blank>\" \"commit=%lu,<S2SV_blank>fs<S2SV_blank>mounted<S2SV_blank>w/o<S2SV_blank>journal\" , sbi -> s_commit_interval / HZ ) ; goto failed_mount_wq ; } if ( EXT4_MOUNT_DATA_FLAGS & ( sbi -> s_mount_opt ^ sbi -> s_def_mount_opt ) ) { ext4_msg ( sb , KERN_ERR , \"can\\'t<S2SV_blank>mount<S2SV_blank>with<S2SV_blank>\" \"data=,<S2SV_blank>fs<S2SV_blank>mounted<S2SV_blank>w/o<S2SV_blank>journal\" ) ; goto failed_mount_wq ; } sbi -> s_def_mount_opt &= EXT4_MOUNT_JOURNAL_CHECKSUM ; clear_opt ( sb , JOURNAL_CHECKSUM ) ; clear_opt ( sb , DATA_FLAGS ) ; sbi -> s_journal = NULL ; needs_recovery = 0 ; goto no_journal ; } if ( ext4_has_feature_64bit ( sb ) && ! jbd2_journal_set_features ( EXT4_SB ( sb ) -> s_journal , 0 , 0 , JBD2_FEATURE_INCOMPAT_64BIT ) ) { ext4_msg ( sb , KERN_ERR , \"Failed<S2SV_blank>to<S2SV_blank>set<S2SV_blank>64-bit<S2SV_blank>journal<S2SV_blank>feature\" ) ; goto failed_mount_wq ; } if ( ! set_journal_csum_feature_set ( sb ) ) { ext4_msg ( sb , KERN_ERR , \"Failed<S2SV_blank>to<S2SV_blank>set<S2SV_blank>journal<S2SV_blank>checksum<S2SV_blank>\" \"feature<S2SV_blank>set\" ) ; goto failed_mount_wq ; } switch ( test_opt ( sb , DATA_FLAGS ) ) { case 0 : if ( jbd2_journal_check_available_features ( sbi -> s_journal , 0 , 0 , JBD2_FEATURE_INCOMPAT_REVOKE ) ) set_opt ( sb , ORDERED_DATA ) ; else set_opt ( sb , JOURNAL_DATA ) ; break ; case EXT4_MOUNT_ORDERED_DATA : case EXT4_MOUNT_WRITEBACK_DATA : if ( ! jbd2_journal_check_available_features ( sbi -> s_journal , 0 , 0 , JBD2_FEATURE_INCOMPAT_REVOKE ) ) { ext4_msg ( sb , KERN_ERR , \"Journal<S2SV_blank>does<S2SV_blank>not<S2SV_blank>support<S2SV_blank>\" \"requested<S2SV_blank>data<S2SV_blank>journaling<S2SV_blank>mode\" ) ; goto failed_mount_wq ; } default : break ; } set_task_ioprio ( sbi -> s_journal -> j_task , journal_ioprio ) ; sbi -> s_journal -> j_commit_callback = ext4_journal_commit_callback ; no_journal : sbi -> s_mb_cache = ext4_xattr_create_cache ( ) ; if ( ! sbi -> s_mb_cache ) { ext4_msg ( sb , KERN_ERR , \"Failed<S2SV_blank>to<S2SV_blank>create<S2SV_blank>an<S2SV_blank>mb_cache\" ) ; goto failed_mount_wq ; } if ( ( DUMMY_ENCRYPTION_ENABLED ( sbi ) || ext4_has_feature_encrypt ( sb ) ) && ( blocksize != PAGE_SIZE ) ) { ext4_msg ( sb , KERN_ERR , \"Unsupported<S2SV_blank>blocksize<S2SV_blank>for<S2SV_blank>fs<S2SV_blank>encryption\" ) ; goto failed_mount_wq ; } if ( DUMMY_ENCRYPTION_ENABLED ( sbi ) && ! ( sb -> s_flags & MS_RDONLY ) && ! ext4_has_feature_encrypt ( sb ) ) { ext4_set_feature_encrypt ( sb ) ; ext4_commit_super ( sb , 1 ) ; } if ( es -> s_overhead_clusters ) sbi -> s_overhead = le32_to_cpu ( es -> s_overhead_clusters ) ; else { err = ext4_calculate_overhead ( sb ) ; if ( err ) goto failed_mount_wq ; } EXT4_SB ( sb ) -> rsv_conversion_wq = alloc_workqueue ( \"ext4-rsv-conversion\" , WQ_MEM_RECLAIM | WQ_UNBOUND , 1 ) ; if ( ! EXT4_SB ( sb ) -> rsv_conversion_wq ) { printk ( KERN_ERR \"EXT4-fs:<S2SV_blank>failed<S2SV_blank>to<S2SV_blank>create<S2SV_blank>workqueue\\\\n\" ) ; ret = - ENOMEM ; goto failed_mount4 ; } root = ext4_iget ( sb , EXT4_ROOT_INO ) ; if ( IS_ERR ( root ) ) { ext4_msg ( sb , KERN_ERR , \"get<S2SV_blank>root<S2SV_blank>inode<S2SV_blank>failed\" ) ; ret = PTR_ERR ( root ) ; root = NULL ; goto failed_mount4 ; } if ( ! S_ISDIR ( root -> i_mode ) || ! root -> i_blocks || ! root -> i_size ) { ext4_msg ( sb , KERN_ERR , \"corrupt<S2SV_blank>root<S2SV_blank>inode,<S2SV_blank>run<S2SV_blank>e2fsck\" ) ; iput ( root ) ; goto failed_mount4 ; } sb -> s_root = d_make_root ( root ) ; if ( ! sb -> s_root ) { ext4_msg ( sb , KERN_ERR , \"get<S2SV_blank>root<S2SV_blank>dentry<S2SV_blank>failed\" ) ; ret = - ENOMEM ; goto failed_mount4 ; } if ( ext4_setup_super ( sb , es , sb -> s_flags & MS_RDONLY ) ) sb -> s_flags |= MS_RDONLY ; if ( sbi -> s_inode_size > EXT4_GOOD_OLD_INODE_SIZE ) { sbi -> s_want_extra_isize = sizeof ( struct ext4_inode ) - EXT4_GOOD_OLD_INODE_SIZE ; if ( ext4_has_feature_extra_isize ( sb ) ) { if ( sbi -> s_want_extra_isize < le16_to_cpu ( es -> s_want_extra_isize ) ) sbi -> s_want_extra_isize = le16_to_cpu ( es -> s_want_extra_isize ) ; if ( sbi -> s_want_extra_isize < le16_to_cpu ( es -> s_min_extra_isize ) ) sbi -> s_want_extra_isize = le16_to_cpu ( es -> s_min_extra_isize ) ; } } if ( EXT4_GOOD_OLD_INODE_SIZE + sbi -> s_want_extra_isize > sbi -> s_inode_size ) { sbi -> s_want_extra_isize = sizeof ( struct ext4_inode ) - EXT4_GOOD_OLD_INODE_SIZE ; ext4_msg ( sb , KERN_INFO , \"required<S2SV_blank>extra<S2SV_blank>inode<S2SV_blank>space<S2SV_blank>not\" \"available\" ) ; } ext4_set_resv_clusters ( sb ) ; err = ext4_setup_system_zone ( sb ) ; if ( err ) { ext4_msg ( sb , KERN_ERR , \"failed<S2SV_blank>to<S2SV_blank>initialize<S2SV_blank>system<S2SV_blank>\" \"zone<S2SV_blank>(%d)\" , err ) ; goto failed_mount4a ; } ext4_ext_init ( sb ) ; err = ext4_mb_init ( sb ) ; if ( err ) { ext4_msg ( sb , KERN_ERR , \"failed<S2SV_blank>to<S2SV_blank>initialize<S2SV_blank>mballoc<S2SV_blank>(%d)\" , err ) ; goto failed_mount5 ; } block = ext4_count_free_clusters ( sb ) ; ext4_free_blocks_count_set ( sbi -> s_es , EXT4_C2B ( sbi , block ) ) ; err = percpu_counter_init ( & sbi -> s_freeclusters_counter , block , GFP_KERNEL ) ; if ( ! err ) { unsigned long freei = ext4_count_free_inodes ( sb ) ; sbi -> s_es -> s_free_inodes_count = cpu_to_le32 ( freei ) ; err = percpu_counter_init ( & sbi -> s_freeinodes_counter , freei , GFP_KERNEL ) ; } if ( ! err ) err = percpu_counter_init ( & sbi -> s_dirs_counter , ext4_count_dirs ( sb ) , GFP_KERNEL ) ; if ( ! err ) err = percpu_counter_init ( & sbi -> s_dirtyclusters_counter , 0 , GFP_KERNEL ) ; if ( ! err ) err = percpu_init_rwsem ( & sbi -> s_journal_flag_rwsem ) ; if ( err ) { ext4_msg ( sb , KERN_ERR , \"insufficient<S2SV_blank>memory\" ) ; goto failed_mount6 ; } if ( ext4_has_feature_flex_bg ( sb ) ) if ( ! ext4_fill_flex_info ( sb ) ) { ext4_msg ( sb , KERN_ERR , \"unable<S2SV_blank>to<S2SV_blank>initialize<S2SV_blank>\" \"flex_bg<S2SV_blank>meta<S2SV_blank>info!\" ) ; goto failed_mount6 ; } err = ext4_register_li_request ( sb , first_not_zeroed ) ; if ( err ) goto failed_mount6 ; err = ext4_register_sysfs ( sb ) ; if ( err ) goto failed_mount7 ; # ifdef CONFIG_QUOTA if ( ext4_has_feature_quota ( sb ) && ! ( sb -> s_flags & MS_RDONLY ) ) { err = ext4_enable_quotas ( sb ) ; if ( err ) goto failed_mount8 ; } # endif EXT4_SB ( sb ) -> s_mount_state |= EXT4_ORPHAN_FS ; ext4_orphan_cleanup ( sb , es ) ; EXT4_SB ( sb ) -> s_mount_state &= ~ EXT4_ORPHAN_FS ; if ( needs_recovery ) { ext4_msg ( sb , KERN_INFO , \"recovery<S2SV_blank>complete\" ) ; ext4_mark_recovery_complete ( sb , es ) ; } if ( EXT4_SB ( sb ) -> s_journal ) { if ( test_opt ( sb , DATA_FLAGS ) == EXT4_MOUNT_JOURNAL_DATA ) descr = \"<S2SV_blank>journalled<S2SV_blank>data<S2SV_blank>mode\" ; else if ( test_opt ( sb , DATA_FLAGS ) == EXT4_MOUNT_ORDERED_DATA ) descr = \"<S2SV_blank>ordered<S2SV_blank>data<S2SV_blank>mode\" ; else descr = \"<S2SV_blank>writeback<S2SV_blank>data<S2SV_blank>mode\" ; } else descr = \"out<S2SV_blank>journal\" ; if ( test_opt ( sb , DISCARD ) ) { struct request_queue * q = bdev_get_queue ( sb -> s_bdev ) ; if ( ! blk_queue_discard ( q ) ) ext4_msg ( sb , KERN_WARNING , \"mounting<S2SV_blank>with<S2SV_blank>\\\\\"discard\\\\\"<S2SV_blank>option,<S2SV_blank>but<S2SV_blank>\" \"the<S2SV_blank>device<S2SV_blank>does<S2SV_blank>not<S2SV_blank>support<S2SV_blank>discard\" ) ; } if ( ___ratelimit ( & ext4_mount_msg_ratelimit , \"EXT4-fs<S2SV_blank>mount\" ) ) ext4_msg ( sb , KERN_INFO , \"mounted<S2SV_blank>filesystem<S2SV_blank>with%s.<S2SV_blank>\" \"Opts:<S2SV_blank>%.*s%s%s\" , descr , ( int ) sizeof ( sbi -> s_es -> s_mount_opts ) , sbi -> s_es -> s_mount_opts , * sbi -> s_es -> s_mount_opts ? \";<S2SV_blank>\" : \"\" , orig_data ) ; if ( es -> s_error_count ) mod_timer ( & sbi -> s_err_report , jiffies + 300 * HZ ) ; ratelimit_state_init ( & sbi -> s_err_ratelimit_state , 5 * HZ , 10 ) ; ratelimit_state_init ( & sbi -> s_warning_ratelimit_state , 5 * HZ , 10 ) ; ratelimit_state_init ( & sbi -> s_msg_ratelimit_state , 5 * HZ , 10 ) ; kfree ( orig_data ) ; # ifdef CONFIG_EXT4_FS_ENCRYPTION memcpy ( sbi -> key_prefix , EXT4_KEY_DESC_PREFIX , EXT4_KEY_DESC_PREFIX_SIZE ) ; sbi -> key_prefix_size = EXT4_KEY_DESC_PREFIX_SIZE ; # endif return 0 ; cantfind_ext4 : if ( ! silent ) ext4_msg ( sb , KERN_ERR , \"VFS:<S2SV_blank>Can\\'t<S2SV_blank>find<S2SV_blank>ext4<S2SV_blank>filesystem\" ) ; goto failed_mount ; # ifdef CONFIG_QUOTA failed_mount8 : ext4_unregister_sysfs ( sb ) ; # endif failed_mount7 : ext4_unregister_li_request ( sb ) ; failed_mount6 : ext4_mb_release ( sb ) ; if ( sbi -> s_flex_groups ) kvfree ( sbi -> s_flex_groups ) ; percpu_counter_destroy ( & sbi -> s_freeclusters_counter ) ; percpu_counter_destroy ( & sbi -> s_freeinodes_counter ) ; percpu_counter_destroy ( & sbi -> s_dirs_counter ) ; percpu_counter_destroy ( & sbi -> s_dirtyclusters_counter ) ; failed_mount5 : ext4_ext_release ( sb ) ; ext4_release_system_zone ( sb ) ; failed_mount4a : dput ( sb -> s_root ) ; sb -> s_root = NULL ; failed_mount4 : ext4_msg ( sb , KERN_ERR , \"mount<S2SV_blank>failed\" ) ; if ( EXT4_SB ( sb ) -> rsv_conversion_wq ) destroy_workqueue ( EXT4_SB ( sb ) -> rsv_conversion_wq ) ; failed_mount_wq : if ( sbi -> s_mb_cache ) { ext4_xattr_destroy_cache ( sbi -> s_mb_cache ) ; sbi -> s_mb_cache = NULL ; } if ( sbi -> s_journal ) { jbd2_journal_destroy ( sbi -> s_journal ) ; sbi -> s_journal = NULL ; } failed_mount3a : ext4_es_unregister_shrinker ( sbi ) ; failed_mount3 : del_timer_sync ( & sbi -> s_err_report ) ; if ( sbi -> s_mmp_tsk ) kthread_stop ( sbi -> s_mmp_tsk ) ; failed_mount2 : for ( i = 0 ; i < db_count ; i ++ ) brelse ( sbi -> s_group_desc [ i ] ) ; kvfree ( sbi -> s_group_desc ) ; failed_mount : if ( sbi -> s_chksum_driver ) crypto_free_shash ( sbi -> s_chksum_driver ) ; # ifdef CONFIG_QUOTA for ( i = 0 ; i < EXT4_MAXQUOTAS ; i ++ ) kfree ( sbi -> s_qf_names [ i ] ) ; # endif ext4_blkdev_remove ( sbi ) ; brelse ( bh ) ; out_fail : sb -> s_fs_info = NULL ; kfree ( sbi -> s_blockgroup_lock ) ; out_free_base : kfree ( sbi ) ; kfree ( orig_data ) ; return err ? err : ret ; }\n","target":"<S2SV_ModStart> sb ) ; if ( ext4_has_feature_meta_bg ( sb ) ) { if ( le32_to_cpu ( es -> s_first_meta_bg ) >= db_count ) { ext4_msg ( sb , KERN_WARNING , \"first<S2SV_blank>meta<S2SV_blank>block<S2SV_blank>group<S2SV_blank>too<S2SV_blank>large:<S2SV_blank>%u<S2SV_blank>\" \"(group<S2SV_blank>descriptor<S2SV_blank>block<S2SV_blank>count<S2SV_blank>%u)\" , le32_to_cpu ( es -> s_first_meta_bg ) , db_count ) ; goto failed_mount ; } }\n","project_and_commit_id":"torvalds@linux/3a4b77cd47bb837b8557595ec7425f281f2ca1fe","cve_id":"CVE-2016-10208","original_address":"https://github.com/torvalds/linux/commit/3a4b77cd47bb837b8557595ec7425f281f2ca1fe","time":"2017-02-06T06:59Z"},
	{"Unnamed: 0":1330,"cwe_id":"CWE-000","source":"CWE-000 static int traceLogDirective ( MaState * state , cchar * key , cchar * value ) { HttpRoute * route ; char * format , * option , * ovalue , * tok , * path , * formatter ; ssize size ; int flags , backup , level ; route = state -> route ; size = MAXINT ; backup = 0 ; flags = 0 ; path = 0 ; format = ME_HTTP_LOG_FORMAT ; formatter = \"detail\" ; level = 0 ; if ( route -> trace -> flags & MPR_LOG_CMDLINE ) { mprLog ( \"info<S2SV_blank>appweb<S2SV_blank>config\" , 4 , \"Already<S2SV_blank>tracing.<S2SV_blank>Ignoring<S2SV_blank>TraceLog<S2SV_blank>directive\" ) ; return 0 ; } for ( option = maGetNextArg ( sclone ( value ) , & tok ) ; option ; option = maGetNextArg ( tok , & tok ) ) { if ( ! path ) { path = sclone ( option ) ; } else { <S2SV_StartBug> option = stok ( option , \"<S2SV_blank>=\\\\t,\" , & ovalue ) ; <S2SV_EndBug> ovalue = strim ( ovalue , \"\\\\\"\\'\" , MPR_TRIM_BOTH ) ; if ( smatch ( option , \"anew\" ) ) { flags |= MPR_LOG_ANEW ; } else if ( smatch ( option , \"backup\" ) ) { backup = atoi ( ovalue ) ; } else if ( smatch ( option , \"format\" ) ) { format = ovalue ; } else if ( smatch ( option , \"level\" ) ) { level = ( int ) stoi ( ovalue ) ; } else if ( smatch ( option , \"size\" ) ) { size = ( ssize ) getnum ( ovalue ) ; } else if ( smatch ( option , \"formatter\" ) ) { formatter = ovalue ; } else { mprLog ( \"error<S2SV_blank>appweb<S2SV_blank>config\" , 0 , \"Unknown<S2SV_blank>TraceLog<S2SV_blank>option<S2SV_blank>%s\" , option ) ; } } } if ( size < HTTP_TRACE_MIN_LOG_SIZE ) { size = HTTP_TRACE_MIN_LOG_SIZE ; } if ( path == 0 ) { mprLog ( \"error<S2SV_blank>appweb<S2SV_blank>config\" , 0 , \"Missing<S2SV_blank>TraceLog<S2SV_blank>filename\" ) ; return MPR_ERR_BAD_SYNTAX ; } if ( formatter ) { httpSetTraceFormatterName ( route -> trace , formatter ) ; } if ( ! smatch ( path , \"stdout\" ) && ! smatch ( path , \"stderr\" ) ) { path = httpMakePath ( route , state -> configDir , path ) ; } route -> trace = httpCreateTrace ( route -> trace ) ; if ( httpSetTraceLogFile ( route -> trace , path , size , backup , format , flags ) < 0 ) { return MPR_ERR_CANT_OPEN ; } httpSetTraceLevel ( level ) ; return 0 ; }\n","target":"<S2SV_ModStart> { option = ssplit <S2SV_ModEnd> ( option ,\n","project_and_commit_id":"embedthis@appweb/7e6a925f5e86a19a7934a94bbd6959101d0b84eb","cve_id":"CVE-2014-9708","original_address":"https://github.com/embedthis/appweb/commit/7e6a925f5e86a19a7934a94bbd6959101d0b84eb","time":"2015-03-31T14:59Z"},
	{"Unnamed: 0":6066,"cwe_id":"CWE-20","source":"CWE-20 SPL_METHOD ( Array , unserialize ) { spl_array_object * intern = ( spl_array_object * ) zend_object_store_get_object ( getThis ( ) TSRMLS_CC ) ; char * buf ; int buf_len ; const unsigned char * p , * s ; php_unserialize_data_t var_hash ; zval * pmembers , * pflags = NULL ; HashTable * aht ; long flags ; if ( zend_parse_parameters ( ZEND_NUM_ARGS ( ) TSRMLS_CC , \"s\" , & buf , & buf_len ) == FAILURE ) { return ; } if ( buf_len == 0 ) { return ; } aht = spl_array_get_hash_table ( intern , 0 TSRMLS_CC ) ; if ( aht -> nApplyCount > 0 ) { zend_error ( E_WARNING , \"Modification<S2SV_blank>of<S2SV_blank>ArrayObject<S2SV_blank>during<S2SV_blank>sorting<S2SV_blank>is<S2SV_blank>prohibited\" ) ; return ; } s = p = ( const unsigned char * ) buf ; PHP_VAR_UNSERIALIZE_INIT ( var_hash ) ; if ( * p != 'x' || * ++ p != ':' ) { goto outexcept ; } ++ p ; ALLOC_INIT_ZVAL ( pflags ) ; if ( ! php_var_unserialize ( & pflags , & p , s + buf_len , & var_hash TSRMLS_CC ) || Z_TYPE_P ( pflags ) != IS_LONG ) { goto outexcept ; } var_push_dtor ( & var_hash , & pflags ) ; -- p ; flags = Z_LVAL_P ( pflags ) ; if ( * p != ';' ) { goto outexcept ; } ++ p ; if ( * p != 'm' ) { if ( * p != 'a' && * p != 'O' && * p != 'C' && * p != 'r' ) { goto outexcept ; } intern -> ar_flags &= ~ SPL_ARRAY_CLONE_MASK ; intern -> ar_flags |= flags & SPL_ARRAY_CLONE_MASK ; zval_ptr_dtor ( & intern -> array ) ; ALLOC_INIT_ZVAL ( intern -> array ) ; <S2SV_StartBug> if ( ! php_var_unserialize ( & intern -> array , & p , s + buf_len , & var_hash TSRMLS_CC ) ) { <S2SV_EndBug> goto outexcept ; } var_push_dtor ( & var_hash , & intern -> array ) ; } if ( * p != ';' ) { goto outexcept ; } ++ p ; if ( * p != 'm' || * ++ p != ':' ) { goto outexcept ; } ++ p ; ALLOC_INIT_ZVAL ( pmembers ) ; if ( ! php_var_unserialize ( & pmembers , & p , s + buf_len , & var_hash TSRMLS_CC ) || Z_TYPE_P ( pmembers ) != IS_ARRAY ) { zval_ptr_dtor ( & pmembers ) ; goto outexcept ; } var_push_dtor ( & var_hash , & pmembers ) ; if ( ! intern -> std . properties ) { rebuild_object_properties ( & intern -> std ) ; } zend_hash_copy ( intern -> std . properties , Z_ARRVAL_P ( pmembers ) , ( copy_ctor_func_t ) zval_add_ref , ( void * ) NULL , sizeof ( zval * ) ) ; zval_ptr_dtor ( & pmembers ) ; PHP_VAR_UNSERIALIZE_DESTROY ( var_hash ) ; if ( pflags ) { zval_ptr_dtor ( & pflags ) ; } return ; outexcept : PHP_VAR_UNSERIALIZE_DESTROY ( var_hash ) ; if ( pflags ) { zval_ptr_dtor ( & pflags ) ; } zend_throw_exception_ex ( spl_ce_UnexpectedValueException , 0 TSRMLS_CC , \"Error<S2SV_blank>at<S2SV_blank>offset<S2SV_blank>%ld<S2SV_blank>of<S2SV_blank>%d<S2SV_blank>bytes\" , ( long ) ( ( char * ) p - buf ) , buf_len ) ; return ; }\n","target":"<S2SV_ModStart> var_hash TSRMLS_CC ) || ( Z_TYPE_P ( intern -> array ) != IS_ARRAY && Z_TYPE_P ( intern -> array ) != IS_OBJECT ) ) { zval_ptr_dtor ( & intern -> array ) ; <S2SV_ModEnd> goto outexcept ;\n","project_and_commit_id":"php@php-src/ecb7f58a069be0dec4a6131b6351a761f808f22e","cve_id":"CVE-2016-7417","original_address":"https://github.com/php/php-src/commit/ecb7f58a069be0dec4a6131b6351a761f808f22e?w=1","time":"2016-09-17T21:59Z"},
	{"Unnamed: 0":4302,"cwe_id":"CWE-189","source":"CWE-189 void bpf_jit_compile ( struct sk_filter * fp ) { u8 temp [ 64 ] ; u8 * prog ; unsigned int proglen , oldproglen = 0 ; int ilen , i ; int t_offset , f_offset ; u8 t_op , f_op , seen = 0 , pass ; u8 * image = NULL ; u8 * func ; int pc_ret0 = - 1 ; unsigned int cleanup_addr ; unsigned int * addrs ; const struct sock_filter * filter = fp -> insns ; int flen = fp -> len ; if ( ! bpf_jit_enable ) return ; addrs = kmalloc ( flen * sizeof ( * addrs ) , GFP_KERNEL ) ; if ( addrs == NULL ) return ; for ( proglen = 0 , i = 0 ; i < flen ; i ++ ) { proglen += 64 ; addrs [ i ] = proglen ; } cleanup_addr = proglen ; for ( pass = 0 ; pass < 10 ; pass ++ ) { proglen = 0 ; prog = temp ; if ( seen ) { EMIT4 ( 0x55 , 0x48 , 0x89 , 0xe5 ) ; EMIT4 ( 0x48 , 0x83 , 0xec , 96 ) ; if ( seen & ( SEEN_XREG | SEEN_DATAREF ) ) EMIT4 ( 0x48 , 0x89 , 0x5d , 0xf8 ) ; if ( seen & SEEN_XREG ) CLEAR_X ( ) ; if ( seen & SEEN_DATAREF ) { if ( offsetof ( struct sk_buff , len ) <= 127 ) EMIT4 ( 0x44 , 0x8b , 0x4f , offsetof ( struct sk_buff , len ) ) ; else { EMIT3 ( 0x44 , 0x8b , 0x8f ) ; EMIT ( offsetof ( struct sk_buff , len ) , 4 ) ; } if ( is_imm8 ( offsetof ( struct sk_buff , data_len ) ) ) EMIT4 ( 0x44 , 0x2b , 0x4f , offsetof ( struct sk_buff , data_len ) ) ; else { EMIT3 ( 0x44 , 0x2b , 0x8f ) ; EMIT ( offsetof ( struct sk_buff , data_len ) , 4 ) ; } if ( is_imm8 ( offsetof ( struct sk_buff , data ) ) ) EMIT4 ( 0x4c , 0x8b , 0x47 , offsetof ( struct sk_buff , data ) ) ; else { EMIT3 ( 0x4c , 0x8b , 0x87 ) ; EMIT ( offsetof ( struct sk_buff , data ) , 4 ) ; } } } switch ( filter [ 0 ] . code ) { case BPF_S_RET_K : case BPF_S_LD_W_LEN : case BPF_S_ANC_PROTOCOL : case BPF_S_ANC_IFINDEX : case BPF_S_ANC_MARK : case BPF_S_ANC_RXHASH : case BPF_S_ANC_CPU : case BPF_S_ANC_QUEUE : case BPF_S_LD_W_ABS : case BPF_S_LD_H_ABS : case BPF_S_LD_B_ABS : break ; default : CLEAR_A ( ) ; } for ( i = 0 ; i < flen ; i ++ ) { unsigned int K = filter [ i ] . k ; switch ( filter [ i ] . code ) { case BPF_S_ALU_ADD_X : seen |= SEEN_XREG ; EMIT2 ( 0x01 , 0xd8 ) ; break ; case BPF_S_ALU_ADD_K : if ( ! K ) break ; if ( is_imm8 ( K ) ) EMIT3 ( 0x83 , 0xc0 , K ) ; else EMIT1_off32 ( 0x05 , K ) ; break ; case BPF_S_ALU_SUB_X : seen |= SEEN_XREG ; EMIT2 ( 0x29 , 0xd8 ) ; break ; case BPF_S_ALU_SUB_K : if ( ! K ) break ; if ( is_imm8 ( K ) ) EMIT3 ( 0x83 , 0xe8 , K ) ; else EMIT1_off32 ( 0x2d , K ) ; break ; case BPF_S_ALU_MUL_X : seen |= SEEN_XREG ; EMIT3 ( 0x0f , 0xaf , 0xc3 ) ; break ; case BPF_S_ALU_MUL_K : if ( is_imm8 ( K ) ) EMIT3 ( 0x6b , 0xc0 , K ) ; else { EMIT2 ( 0x69 , 0xc0 ) ; EMIT ( K , 4 ) ; } break ; case BPF_S_ALU_DIV_X : seen |= SEEN_XREG ; EMIT2 ( 0x85 , 0xdb ) ; if ( pc_ret0 != - 1 ) EMIT_COND_JMP ( X86_JE , addrs [ pc_ret0 ] - ( addrs [ i ] - 4 ) ) ; else { EMIT_COND_JMP ( X86_JNE , 2 + 5 ) ; CLEAR_A ( ) ; EMIT1_off32 ( 0xe9 , cleanup_addr - ( addrs [ i ] - 4 ) ) ; } EMIT4 ( 0x31 , 0xd2 , 0xf7 , 0xf3 ) ; break ; case BPF_S_ALU_DIV_K : EMIT3 ( 0x48 , 0x69 , 0xc0 ) ; EMIT ( K , 4 ) ; EMIT4 ( 0x48 , 0xc1 , 0xe8 , 0x20 ) ; break ; case BPF_S_ALU_AND_X : seen |= SEEN_XREG ; EMIT2 ( 0x21 , 0xd8 ) ; break ; case BPF_S_ALU_AND_K : if ( K >= 0xFFFFFF00 ) { EMIT2 ( 0x24 , K & 0xFF ) ; } else if ( K >= 0xFFFF0000 ) { EMIT2 ( 0x66 , 0x25 ) ; EMIT2 ( K , 2 ) ; } else { EMIT1_off32 ( 0x25 , K ) ; } break ; case BPF_S_ALU_OR_X : seen |= SEEN_XREG ; EMIT2 ( 0x09 , 0xd8 ) ; break ; case BPF_S_ALU_OR_K : if ( is_imm8 ( K ) ) EMIT3 ( 0x83 , 0xc8 , K ) ; else EMIT1_off32 ( 0x0d , K ) ; break ; case BPF_S_ALU_LSH_X : seen |= SEEN_XREG ; EMIT4 ( 0x89 , 0xd9 , 0xd3 , 0xe0 ) ; break ; case BPF_S_ALU_LSH_K : if ( K == 0 ) break ; else if ( K == 1 ) EMIT2 ( 0xd1 , 0xe0 ) ; else EMIT3 ( 0xc1 , 0xe0 , K ) ; break ; case BPF_S_ALU_RSH_X : seen |= SEEN_XREG ; EMIT4 ( 0x89 , 0xd9 , 0xd3 , 0xe8 ) ; break ; case BPF_S_ALU_RSH_K : if ( K == 0 ) break ; else if ( K == 1 ) EMIT2 ( 0xd1 , 0xe8 ) ; else EMIT3 ( 0xc1 , 0xe8 , K ) ; break ; case BPF_S_ALU_NEG : EMIT2 ( 0xf7 , 0xd8 ) ; break ; case BPF_S_RET_K : if ( ! K ) { if ( pc_ret0 == - 1 ) pc_ret0 = i ; CLEAR_A ( ) ; } else { EMIT1_off32 ( 0xb8 , K ) ; } case BPF_S_RET_A : if ( seen ) { if ( i != flen - 1 ) { EMIT_JMP ( cleanup_addr - addrs [ i ] ) ; break ; } if ( seen & SEEN_XREG ) EMIT4 ( 0x48 , 0x8b , 0x5d , 0xf8 ) ; EMIT1 ( 0xc9 ) ; } EMIT1 ( 0xc3 ) ; break ; case BPF_S_MISC_TAX : seen |= SEEN_XREG ; EMIT2 ( 0x89 , 0xc3 ) ; break ; case BPF_S_MISC_TXA : seen |= SEEN_XREG ; EMIT2 ( 0x89 , 0xd8 ) ; break ; case BPF_S_LD_IMM : if ( ! K ) CLEAR_A ( ) ; else EMIT1_off32 ( 0xb8 , K ) ; break ; case BPF_S_LDX_IMM : seen |= SEEN_XREG ; if ( ! K ) CLEAR_X ( ) ; else EMIT1_off32 ( 0xbb , K ) ; break ; case BPF_S_LD_MEM : seen |= SEEN_MEM ; EMIT3 ( 0x8b , 0x45 , 0xf0 - K * 4 ) ; break ; case BPF_S_LDX_MEM : seen |= SEEN_XREG | SEEN_MEM ; EMIT3 ( 0x8b , 0x5d , 0xf0 - K * 4 ) ; break ; case BPF_S_ST : seen |= SEEN_MEM ; EMIT3 ( 0x89 , 0x45 , 0xf0 - K * 4 ) ; break ; case BPF_S_STX : seen |= SEEN_XREG | SEEN_MEM ; EMIT3 ( 0x89 , 0x5d , 0xf0 - K * 4 ) ; break ; case BPF_S_LD_W_LEN : BUILD_BUG_ON ( FIELD_SIZEOF ( struct sk_buff , len ) != 4 ) ; if ( is_imm8 ( offsetof ( struct sk_buff , len ) ) ) EMIT3 ( 0x8b , 0x47 , offsetof ( struct sk_buff , len ) ) ; else { EMIT2 ( 0x8b , 0x87 ) ; EMIT ( offsetof ( struct sk_buff , len ) , 4 ) ; } break ; case BPF_S_LDX_W_LEN : seen |= SEEN_XREG ; if ( is_imm8 ( offsetof ( struct sk_buff , len ) ) ) EMIT3 ( 0x8b , 0x5f , offsetof ( struct sk_buff , len ) ) ; else { EMIT2 ( 0x8b , 0x9f ) ; EMIT ( offsetof ( struct sk_buff , len ) , 4 ) ; } break ; case BPF_S_ANC_PROTOCOL : BUILD_BUG_ON ( FIELD_SIZEOF ( struct sk_buff , protocol ) != 2 ) ; if ( is_imm8 ( offsetof ( struct sk_buff , protocol ) ) ) { EMIT4 ( 0x0f , 0xb7 , 0x47 , offsetof ( struct sk_buff , protocol ) ) ; } else { EMIT3 ( 0x0f , 0xb7 , 0x87 ) ; EMIT ( offsetof ( struct sk_buff , protocol ) , 4 ) ; } EMIT2 ( 0x86 , 0xc4 ) ; break ; case BPF_S_ANC_IFINDEX : if ( is_imm8 ( offsetof ( struct sk_buff , dev ) ) ) { EMIT4 ( 0x48 , 0x8b , 0x47 , offsetof ( struct sk_buff , dev ) ) ; } else { EMIT3 ( 0x48 , 0x8b , 0x87 ) ; EMIT ( offsetof ( struct sk_buff , dev ) , 4 ) ; } EMIT3 ( 0x48 , 0x85 , 0xc0 ) ; EMIT_COND_JMP ( X86_JE , cleanup_addr - ( addrs [ i ] - 6 ) ) ; BUILD_BUG_ON ( FIELD_SIZEOF ( struct net_device , ifindex ) != 4 ) ; EMIT2 ( 0x8b , 0x80 ) ; EMIT ( offsetof ( struct net_device , ifindex ) , 4 ) ; break ; case BPF_S_ANC_MARK : BUILD_BUG_ON ( FIELD_SIZEOF ( struct sk_buff , mark ) != 4 ) ; if ( is_imm8 ( offsetof ( struct sk_buff , mark ) ) ) { EMIT3 ( 0x8b , 0x47 , offsetof ( struct sk_buff , mark ) ) ; } else { EMIT2 ( 0x8b , 0x87 ) ; EMIT ( offsetof ( struct sk_buff , mark ) , 4 ) ; } break ; case BPF_S_ANC_RXHASH : BUILD_BUG_ON ( FIELD_SIZEOF ( struct sk_buff , rxhash ) != 4 ) ; if ( is_imm8 ( offsetof ( struct sk_buff , rxhash ) ) ) { EMIT3 ( 0x8b , 0x47 , offsetof ( struct sk_buff , rxhash ) ) ; } else { EMIT2 ( 0x8b , 0x87 ) ; EMIT ( offsetof ( struct sk_buff , rxhash ) , 4 ) ; } break ; case BPF_S_ANC_QUEUE : BUILD_BUG_ON ( FIELD_SIZEOF ( struct sk_buff , queue_mapping ) != 2 ) ; if ( is_imm8 ( offsetof ( struct sk_buff , queue_mapping ) ) ) { EMIT4 ( 0x0f , 0xb7 , 0x47 , offsetof ( struct sk_buff , queue_mapping ) ) ; } else { EMIT3 ( 0x0f , 0xb7 , 0x87 ) ; EMIT ( offsetof ( struct sk_buff , queue_mapping ) , 4 ) ; } break ; case BPF_S_ANC_CPU : # ifdef CONFIG_SMP EMIT4 ( 0x65 , 0x8b , 0x04 , 0x25 ) ; EMIT ( ( u32 ) ( unsigned long ) & cpu_number , 4 ) ; # else CLEAR_A ( ) ; # endif break ; case BPF_S_LD_W_ABS : func = sk_load_word ; common_load : seen |= SEEN_DATAREF ; if ( ( int ) K < 0 ) goto out ; t_offset = func - ( image + addrs [ i ] ) ; EMIT1_off32 ( 0xbe , K ) ; EMIT1_off32 ( 0xe8 , t_offset ) ; break ; case BPF_S_LD_H_ABS : func = sk_load_half ; goto common_load ; case BPF_S_LD_B_ABS : func = sk_load_byte ; goto common_load ; case BPF_S_LDX_B_MSH : if ( ( int ) K < 0 ) { if ( pc_ret0 != - 1 ) { EMIT_JMP ( addrs [ pc_ret0 ] - addrs [ i ] ) ; break ; } CLEAR_A ( ) ; EMIT_JMP ( cleanup_addr - addrs [ i ] ) ; break ; } seen |= SEEN_DATAREF | SEEN_XREG ; t_offset = sk_load_byte_msh - ( image + addrs [ i ] ) ; EMIT1_off32 ( 0xbe , K ) ; EMIT1_off32 ( 0xe8 , t_offset ) ; break ; case BPF_S_LD_W_IND : func = sk_load_word_ind ; common_load_ind : seen |= SEEN_DATAREF | SEEN_XREG ; t_offset = func - ( image + addrs [ i ] ) ; EMIT1_off32 ( 0xbe , K ) ; EMIT1_off32 ( 0xe8 , t_offset ) ; break ; case BPF_S_LD_H_IND : func = sk_load_half_ind ; goto common_load_ind ; case BPF_S_LD_B_IND : func = sk_load_byte_ind ; goto common_load_ind ; case BPF_S_JMP_JA : t_offset = addrs [ i + K ] - addrs [ i ] ; EMIT_JMP ( t_offset ) ; break ; COND_SEL ( BPF_S_JMP_JGT_K , X86_JA , X86_JBE ) ; COND_SEL ( BPF_S_JMP_JGE_K , X86_JAE , X86_JB ) ; COND_SEL ( BPF_S_JMP_JEQ_K , X86_JE , X86_JNE ) ; COND_SEL ( BPF_S_JMP_JSET_K , X86_JNE , X86_JE ) ; COND_SEL ( BPF_S_JMP_JGT_X , X86_JA , X86_JBE ) ; COND_SEL ( BPF_S_JMP_JGE_X , X86_JAE , X86_JB ) ; COND_SEL ( BPF_S_JMP_JEQ_X , X86_JE , X86_JNE ) ; COND_SEL ( BPF_S_JMP_JSET_X , X86_JNE , X86_JE ) ; cond_branch : f_offset = addrs [ i + filter [ i ] . jf ] - addrs [ i ] ; t_offset = addrs [ i + filter [ i ] . jt ] - addrs [ i ] ; if ( filter [ i ] . jt == filter [ i ] . jf ) { EMIT_JMP ( t_offset ) ; break ; } switch ( filter [ i ] . code ) { case BPF_S_JMP_JGT_X : case BPF_S_JMP_JGE_X : case BPF_S_JMP_JEQ_X : seen |= SEEN_XREG ; EMIT2 ( 0x39 , 0xd8 ) ; break ; case BPF_S_JMP_JSET_X : seen |= SEEN_XREG ; EMIT2 ( 0x85 , 0xd8 ) ; break ; case BPF_S_JMP_JEQ_K : if ( K == 0 ) { EMIT2 ( 0x85 , 0xc0 ) ; break ; } case BPF_S_JMP_JGT_K : case BPF_S_JMP_JGE_K : if ( K <= 127 ) EMIT3 ( 0x83 , 0xf8 , K ) ; else EMIT1_off32 ( 0x3d , K ) ; break ; case BPF_S_JMP_JSET_K : if ( K <= 0xFF ) EMIT2 ( 0xa8 , K ) ; else if ( ! ( K & 0xFFFF00FF ) ) EMIT3 ( 0xf6 , 0xc4 , K >> 8 ) ; else if ( K <= 0xFFFF ) { EMIT2 ( 0x66 , 0xa9 ) ; EMIT ( K , 2 ) ; } else { EMIT1_off32 ( 0xa9 , K ) ; } break ; } if ( filter [ i ] . jt != 0 ) { <S2SV_StartBug> if ( filter [ i ] . jf ) <S2SV_EndBug> <S2SV_StartBug> t_offset += is_near ( f_offset ) ? 2 : 6 ; <S2SV_EndBug> EMIT_COND_JMP ( t_op , t_offset ) ; if ( filter [ i ] . jf ) EMIT_JMP ( f_offset ) ; break ; } EMIT_COND_JMP ( f_op , f_offset ) ; break ; default : goto out ; } ilen = prog - temp ; if ( image ) { if ( unlikely ( proglen + ilen > oldproglen ) ) { pr_err ( \"bpb_jit_compile<S2SV_blank>fatal<S2SV_blank>error\\\\n\" ) ; kfree ( addrs ) ; module_free ( NULL , image ) ; return ; } memcpy ( image + proglen , temp , ilen ) ; } proglen += ilen ; addrs [ i ] = proglen ; prog = temp ; } cleanup_addr = proglen - 1 ; if ( seen ) cleanup_addr -= 1 ; if ( seen & SEEN_XREG ) cleanup_addr -= 4 ; if ( image ) { WARN_ON ( proglen != oldproglen ) ; break ; } if ( proglen == oldproglen ) { image = module_alloc ( max_t ( unsigned int , proglen , sizeof ( struct work_struct ) ) ) ; if ( ! image ) goto out ; } oldproglen = proglen ; } if ( bpf_jit_enable > 1 ) pr_err ( \"flen=%d<S2SV_blank>proglen=%u<S2SV_blank>pass=%d<S2SV_blank>image=%p\\\\n\" , flen , proglen , pass , image ) ; if ( image ) { if ( bpf_jit_enable > 1 ) print_hex_dump ( KERN_ERR , \"JIT<S2SV_blank>code:<S2SV_blank>\" , DUMP_PREFIX_ADDRESS , 16 , 1 , image , proglen , false ) ; bpf_flush_icache ( image , image + proglen ) ; fp -> bpf_func = ( void * ) image ; } out : kfree ( addrs ) ; return ; }\n","target":"<S2SV_ModStart> ] . jf && f_offset <S2SV_ModStart> ? 2 : 5 <S2SV_ModEnd> ; EMIT_COND_JMP (\n","project_and_commit_id":"torvalds@linux/a03ffcf873fe0f2565386ca8ef832144c42e67fa","cve_id":"CVE-2014-2889","original_address":"https://github.com/torvalds/linux/commit/a03ffcf873fe0f2565386ca8ef832144c42e67fa","time":"2014-04-27T00:55Z"},
	{"Unnamed: 0":6407,"cwe_id":"CWE-362","source":"CWE-362 void sock_release ( struct socket * sock ) { <S2SV_StartBug> if ( sock -> ops ) { <S2SV_EndBug> struct module * owner = sock -> ops -> owner ; sock -> ops -> release ( sock ) ; sock -> ops = NULL ; module_put ( owner ) ; } <S2SV_StartBug> if ( rcu_dereference_protected ( sock -> wq , 1 ) -> fasync_list ) <S2SV_EndBug> pr_err ( \"%s:<S2SV_blank>fasync<S2SV_blank>list<S2SV_blank>not<S2SV_blank>empty!\\\\n\" , __func__ ) ; if ( ! sock -> file ) { iput ( SOCK_INODE ( sock ) ) ; return ; } sock -> file = NULL ; }\n","target":"<S2SV_ModStart> sock ) { __sock_release ( sock , NULL <S2SV_ModEnd> ) ; } <S2SV_ModStart> ) ; } <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null>\n","project_and_commit_id":"torvalds@linux/6d8c50dcb029872b298eea68cc6209c866fd3e14","cve_id":"CVE-2018-12232","original_address":"https://github.com/torvalds/linux/commit/6d8c50dcb029872b298eea68cc6209c866fd3e14","time":"2018-06-12T12:29Z"},
	{"Unnamed: 0":2256,"cwe_id":"CWE-476","source":"CWE-476 static int parse_report ( transport_smart * transport , git_push * push ) { git_pkt * pkt = NULL ; const char * line_end = NULL ; gitno_buffer * buf = & transport -> buffer ; int error , recvd ; git_buf data_pkt_buf = GIT_BUF_INIT ; for ( ; ; ) { if ( buf -> offset > 0 ) error = git_pkt_parse_line ( & pkt , buf -> data , & line_end , buf -> offset ) ; else error = GIT_EBUFS ; if ( error < 0 && error != GIT_EBUFS ) { error = - 1 ; goto done ; } if ( error == GIT_EBUFS ) { if ( ( recvd = gitno_recv ( buf ) ) < 0 ) { error = recvd ; goto done ; } if ( recvd == 0 ) { giterr_set ( GITERR_NET , \"early<S2SV_blank>EOF\" ) ; error = GIT_EEOF ; goto done ; } continue ; } gitno_consume ( buf , line_end ) ; <S2SV_StartBug> error = 0 ; <S2SV_EndBug> if ( pkt == NULL ) continue ; switch ( pkt -> type ) { case GIT_PKT_DATA : error = add_push_report_sideband_pkt ( push , ( git_pkt_data * ) pkt , & data_pkt_buf ) ; break ; case GIT_PKT_ERR : giterr_set ( GITERR_NET , \"report-status:<S2SV_blank>Error<S2SV_blank>reported:<S2SV_blank>%s\" , ( ( git_pkt_err * ) pkt ) -> error ) ; error = - 1 ; break ; case GIT_PKT_PROGRESS : if ( transport -> progress_cb ) { git_pkt_progress * p = ( git_pkt_progress * ) pkt ; error = transport -> progress_cb ( p -> data , p -> len , transport -> message_cb_payload ) ; } break ; default : error = add_push_report_pkt ( push , pkt ) ; break ; } git_pkt_free ( pkt ) ; if ( error == GIT_ITEROVER ) { error = 0 ; if ( data_pkt_buf . size > 0 ) { giterr_set ( GITERR_NET , \"Incomplete<S2SV_blank>pack<S2SV_blank>data<S2SV_blank>pkt-line\" ) ; error = GIT_ERROR ; } goto done ; } if ( error < 0 ) { goto done ; } } done : git_buf_free ( & data_pkt_buf ) ; return error ; }\n","target":"<S2SV_ModStart> error = 0 <S2SV_ModEnd> ; switch (\n","project_and_commit_id":"libgit2@libgit2/84d30d569ada986f3eef527cbdb932643c2dd037","cve_id":"CVE-2016-10129","original_address":"https://github.com/libgit2/libgit2/commit/84d30d569ada986f3eef527cbdb932643c2dd037","time":"2017-03-24T15:59Z"},
	{"Unnamed: 0":6693,"cwe_id":"CWE-476","source":"CWE-476 jas_image_t * jp2_decode ( jas_stream_t * in , char * optstr ) { jp2_box_t * box ; int found ; jas_image_t * image ; jp2_dec_t * dec ; bool samedtype ; int dtype ; unsigned int i ; jp2_cmap_t * cmapd ; jp2_pclr_t * pclrd ; jp2_cdef_t * cdefd ; unsigned int channo ; int newcmptno ; int_fast32_t * lutents ; # if 0 jp2_cdefchan_t * cdefent ; int cmptno ; # endif jp2_cmapent_t * cmapent ; jas_icchdr_t icchdr ; jas_iccprof_t * iccprof ; dec = 0 ; box = 0 ; image = 0 ; if ( ! ( dec = jp2_dec_create ( ) ) ) { goto error ; } if ( ! ( box = jp2_box_get ( in ) ) ) { jas_eprintf ( \"error:<S2SV_blank>cannot<S2SV_blank>get<S2SV_blank>box\\\\n\" ) ; goto error ; } if ( box -> type != JP2_BOX_JP ) { jas_eprintf ( \"error:<S2SV_blank>expecting<S2SV_blank>signature<S2SV_blank>box\\\\n\" ) ; goto error ; } if ( box -> data . jp . magic != JP2_JP_MAGIC ) { jas_eprintf ( \"incorrect<S2SV_blank>magic<S2SV_blank>number\\\\n\" ) ; goto error ; } jp2_box_destroy ( box ) ; box = 0 ; if ( ! ( box = jp2_box_get ( in ) ) ) { goto error ; } if ( box -> type != JP2_BOX_FTYP ) { jas_eprintf ( \"expecting<S2SV_blank>file<S2SV_blank>type<S2SV_blank>box\\\\n\" ) ; goto error ; } jp2_box_destroy ( box ) ; box = 0 ; found = 0 ; while ( ( box = jp2_box_get ( in ) ) ) { if ( jas_getdbglevel ( ) >= 1 ) { <S2SV_StartBug> jas_eprintf ( \"box<S2SV_blank>type<S2SV_blank>%s\\\\n\" , box -> info -> name ) ; <S2SV_EndBug> } switch ( box -> type ) { case JP2_BOX_JP2C : found = 1 ; break ; case JP2_BOX_IHDR : if ( ! dec -> ihdr ) { dec -> ihdr = box ; box = 0 ; } break ; case JP2_BOX_BPCC : if ( ! dec -> bpcc ) { dec -> bpcc = box ; box = 0 ; } break ; case JP2_BOX_CDEF : if ( ! dec -> cdef ) { dec -> cdef = box ; box = 0 ; } break ; case JP2_BOX_PCLR : if ( ! dec -> pclr ) { dec -> pclr = box ; box = 0 ; } break ; case JP2_BOX_CMAP : if ( ! dec -> cmap ) { dec -> cmap = box ; box = 0 ; } break ; case JP2_BOX_COLR : if ( ! dec -> colr ) { dec -> colr = box ; box = 0 ; } break ; } if ( box ) { jp2_box_destroy ( box ) ; box = 0 ; } if ( found ) { break ; } } if ( ! found ) { jas_eprintf ( \"error:<S2SV_blank>no<S2SV_blank>code<S2SV_blank>stream<S2SV_blank>found\\\\n\" ) ; goto error ; } if ( ! ( dec -> image = jpc_decode ( in , optstr ) ) ) { jas_eprintf ( \"error:<S2SV_blank>cannot<S2SV_blank>decode<S2SV_blank>code<S2SV_blank>stream\\\\n\" ) ; goto error ; } if ( ! dec -> ihdr ) { jas_eprintf ( \"error:<S2SV_blank>missing<S2SV_blank>IHDR<S2SV_blank>box\\\\n\" ) ; goto error ; } if ( dec -> ihdr -> data . ihdr . numcmpts != JAS_CAST ( uint , jas_image_numcmpts ( dec -> image ) ) ) { jas_eprintf ( \"warning:<S2SV_blank>number<S2SV_blank>of<S2SV_blank>components<S2SV_blank>mismatch\\\\n\" ) ; } if ( ! jas_image_numcmpts ( dec -> image ) ) { jas_eprintf ( \"error:<S2SV_blank>no<S2SV_blank>components\\\\n\" ) ; goto error ; } samedtype = true ; dtype = jas_image_cmptdtype ( dec -> image , 0 ) ; for ( i = 1 ; i < JAS_CAST ( uint , jas_image_numcmpts ( dec -> image ) ) ; ++ i ) { if ( jas_image_cmptdtype ( dec -> image , i ) != dtype ) { samedtype = false ; break ; } } if ( ( samedtype && dec -> ihdr -> data . ihdr . bpc != JP2_DTYPETOBPC ( dtype ) ) || ( ! samedtype && dec -> ihdr -> data . ihdr . bpc != JP2_IHDR_BPCNULL ) ) { jas_eprintf ( \"warning:<S2SV_blank>component<S2SV_blank>data<S2SV_blank>type<S2SV_blank>mismatch\\\\n\" ) ; } if ( dec -> ihdr -> data . ihdr . comptype != JP2_IHDR_COMPTYPE ) { jas_eprintf ( \"error:<S2SV_blank>unsupported<S2SV_blank>compression<S2SV_blank>type\\\\n\" ) ; goto error ; } if ( dec -> bpcc ) { if ( dec -> bpcc -> data . bpcc . numcmpts != JAS_CAST ( uint , jas_image_numcmpts ( dec -> image ) ) ) { jas_eprintf ( \"warning:<S2SV_blank>number<S2SV_blank>of<S2SV_blank>components<S2SV_blank>mismatch\\\\n\" ) ; } if ( ! samedtype ) { for ( i = 0 ; i < JAS_CAST ( uint , jas_image_numcmpts ( dec -> image ) ) ; ++ i ) { if ( jas_image_cmptdtype ( dec -> image , i ) != JP2_BPCTODTYPE ( dec -> bpcc -> data . bpcc . bpcs [ i ] ) ) { jas_eprintf ( \"warning:<S2SV_blank>component<S2SV_blank>data<S2SV_blank>type<S2SV_blank>mismatch\\\\n\" ) ; } } } else { jas_eprintf ( \"warning:<S2SV_blank>superfluous<S2SV_blank>BPCC<S2SV_blank>box\\\\n\" ) ; } } if ( ! dec -> colr ) { jas_eprintf ( \"error:<S2SV_blank>no<S2SV_blank>COLR<S2SV_blank>box\\\\n\" ) ; goto error ; } switch ( dec -> colr -> data . colr . method ) { case JP2_COLR_ENUM : jas_image_setclrspc ( dec -> image , jp2_getcs ( & dec -> colr -> data . colr ) ) ; break ; case JP2_COLR_ICC : iccprof = jas_iccprof_createfrombuf ( dec -> colr -> data . colr . iccp , dec -> colr -> data . colr . iccplen ) ; if ( ! iccprof ) { jas_eprintf ( \"error:<S2SV_blank>failed<S2SV_blank>to<S2SV_blank>parse<S2SV_blank>ICC<S2SV_blank>profile\\\\n\" ) ; goto error ; } jas_iccprof_gethdr ( iccprof , & icchdr ) ; jas_eprintf ( \"ICC<S2SV_blank>Profile<S2SV_blank>CS<S2SV_blank>%08x\\\\n\" , icchdr . colorspc ) ; jas_image_setclrspc ( dec -> image , fromiccpcs ( icchdr . colorspc ) ) ; dec -> image -> cmprof_ = jas_cmprof_createfromiccprof ( iccprof ) ; assert ( dec -> image -> cmprof_ ) ; jas_iccprof_destroy ( iccprof ) ; break ; } if ( dec -> cmap && ! dec -> pclr ) { jas_eprintf ( \"warning:<S2SV_blank>missing<S2SV_blank>PCLR<S2SV_blank>box<S2SV_blank>or<S2SV_blank>superfluous<S2SV_blank>CMAP<S2SV_blank>box\\\\n\" ) ; jp2_box_destroy ( dec -> cmap ) ; dec -> cmap = 0 ; } if ( ! dec -> cmap && dec -> pclr ) { jas_eprintf ( \"warning:<S2SV_blank>missing<S2SV_blank>CMAP<S2SV_blank>box<S2SV_blank>or<S2SV_blank>superfluous<S2SV_blank>PCLR<S2SV_blank>box\\\\n\" ) ; jp2_box_destroy ( dec -> pclr ) ; dec -> pclr = 0 ; } dec -> numchans = dec -> cmap ? dec -> cmap -> data . cmap . numchans : JAS_CAST ( uint , jas_image_numcmpts ( dec -> image ) ) ; if ( dec -> cmap ) { for ( i = 0 ; i < dec -> numchans ; ++ i ) { if ( dec -> cmap -> data . cmap . ents [ i ] . cmptno >= JAS_CAST ( uint , jas_image_numcmpts ( dec -> image ) ) ) { jas_eprintf ( \"error:<S2SV_blank>invalid<S2SV_blank>component<S2SV_blank>number<S2SV_blank>in<S2SV_blank>CMAP<S2SV_blank>box\\\\n\" ) ; goto error ; } if ( dec -> cmap -> data . cmap . ents [ i ] . pcol >= dec -> pclr -> data . pclr . numchans ) { jas_eprintf ( \"error:<S2SV_blank>invalid<S2SV_blank>CMAP<S2SV_blank>LUT<S2SV_blank>index\\\\n\" ) ; goto error ; } } } if ( ! ( dec -> chantocmptlut = jas_alloc2 ( dec -> numchans , sizeof ( uint_fast16_t ) ) ) ) { jas_eprintf ( \"error:<S2SV_blank>no<S2SV_blank>memory\\\\n\" ) ; goto error ; } if ( ! dec -> cmap ) { for ( i = 0 ; i < dec -> numchans ; ++ i ) { dec -> chantocmptlut [ i ] = i ; } } else { cmapd = & dec -> cmap -> data . cmap ; pclrd = & dec -> pclr -> data . pclr ; cdefd = & dec -> cdef -> data . cdef ; for ( channo = 0 ; channo < cmapd -> numchans ; ++ channo ) { cmapent = & cmapd -> ents [ channo ] ; if ( cmapent -> map == JP2_CMAP_DIRECT ) { dec -> chantocmptlut [ channo ] = channo ; } else if ( cmapent -> map == JP2_CMAP_PALETTE ) { lutents = jas_alloc2 ( pclrd -> numlutents , sizeof ( int_fast32_t ) ) ; for ( i = 0 ; i < pclrd -> numlutents ; ++ i ) { lutents [ i ] = pclrd -> lutdata [ cmapent -> pcol + i * pclrd -> numchans ] ; } newcmptno = jas_image_numcmpts ( dec -> image ) ; jas_image_depalettize ( dec -> image , cmapent -> cmptno , pclrd -> numlutents , lutents , JP2_BPCTODTYPE ( pclrd -> bpc [ cmapent -> pcol ] ) , newcmptno ) ; dec -> chantocmptlut [ channo ] = newcmptno ; jas_free ( lutents ) ; # if 0 if ( dec -> cdef ) { cdefent = jp2_cdef_lookup ( cdefd , channo ) ; if ( ! cdefent ) { abort ( ) ; } jas_image_setcmpttype ( dec -> image , newcmptno , jp2_getct ( jas_image_clrspc ( dec -> image ) , cdefent -> type , cdefent -> assoc ) ) ; } else { jas_image_setcmpttype ( dec -> image , newcmptno , jp2_getct ( jas_image_clrspc ( dec -> image ) , 0 , channo + 1 ) ) ; } # endif } } } for ( i = 0 ; i < JAS_CAST ( uint , jas_image_numcmpts ( dec -> image ) ) ; ++ i ) { jas_image_setcmpttype ( dec -> image , i , JAS_IMAGE_CT_UNKNOWN ) ; } if ( dec -> cdef ) { for ( i = 0 ; i < dec -> numchans ; ++ i ) { if ( dec -> cdef -> data . cdef . ents [ i ] . channo >= dec -> numchans ) { jas_eprintf ( \"error:<S2SV_blank>invalid<S2SV_blank>channel<S2SV_blank>number<S2SV_blank>in<S2SV_blank>CDEF<S2SV_blank>box\\\\n\" ) ; goto error ; } jas_image_setcmpttype ( dec -> image , dec -> chantocmptlut [ dec -> cdef -> data . cdef . ents [ i ] . channo ] , jp2_getct ( jas_image_clrspc ( dec -> image ) , dec -> cdef -> data . cdef . ents [ i ] . type , dec -> cdef -> data . cdef . ents [ i ] . assoc ) ) ; } } else { for ( i = 0 ; i < dec -> numchans ; ++ i ) { jas_image_setcmpttype ( dec -> image , dec -> chantocmptlut [ i ] , jp2_getct ( jas_image_clrspc ( dec -> image ) , 0 , i + 1 ) ) ; } } for ( i = jas_image_numcmpts ( dec -> image ) ; i > 0 ; -- i ) { if ( jas_image_cmpttype ( dec -> image , i - 1 ) == JAS_IMAGE_CT_UNKNOWN ) { jas_image_delcmpt ( dec -> image , i - 1 ) ; } } if ( ! jas_image_numcmpts ( dec -> image ) ) { jas_eprintf ( \"error:<S2SV_blank>no<S2SV_blank>components\\\\n\" ) ; goto error ; } # if 0 jas_eprintf ( \"no<S2SV_blank>of<S2SV_blank>components<S2SV_blank>is<S2SV_blank>%d\\\\n\" , jas_image_numcmpts ( dec -> image ) ) ; # endif image = dec -> image ; dec -> image = 0 ; jp2_dec_destroy ( dec ) ; return image ; error : if ( box ) { jp2_box_destroy ( box ) ; } if ( dec ) { jp2_dec_destroy ( dec ) ; } return 0 ; }\n","target":"<S2SV_ModStart> { jas_eprintf ( \"got<S2SV_blank>box<S2SV_blank>type<S2SV_blank>%s\\\\n\" <S2SV_ModEnd> , box ->\n","project_and_commit_id":"mdadams@jasper/e24bdc716c3327b067c551bc6cfb97fd2370358d","cve_id":"CVE-2016-8887","original_address":"https://github.com/mdadams/jasper/commit/e24bdc716c3327b067c551bc6cfb97fd2370358d","time":"2017-03-23T18:59Z"},
	{"Unnamed: 0":954,"cwe_id":"CWE-000","source":"CWE-000 void vlan_setup ( struct net_device * dev ) { ether_setup ( dev ) ; dev -> priv_flags |= IFF_802_1Q_VLAN ; <S2SV_StartBug> dev -> priv_flags &= ~ IFF_XMIT_DST_RELEASE ; <S2SV_EndBug> dev -> tx_queue_len = 0 ; dev -> netdev_ops = & vlan_netdev_ops ; dev -> destructor = free_netdev ; dev -> ethtool_ops = & vlan_ethtool_ops ; memset ( dev -> broadcast , 0 , ETH_ALEN ) ; }\n","target":"<S2SV_ModStart> priv_flags &= ~ ( IFF_XMIT_DST_RELEASE | IFF_TX_SKB_SHARING ) <S2SV_ModEnd> ; dev ->\n","project_and_commit_id":"torvalds@linux/550fd08c2cebad61c548def135f67aba284c6162","cve_id":"CVE-2011-4112","original_address":"https://github.com/torvalds/linux/commit/550fd08c2cebad61c548def135f67aba284c6162","time":"2012-05-17T11:00Z"},
	{"Unnamed: 0":547,"cwe_id":"CWE-119","source":"CWE-119 static int http_buf_read ( URLContext * h , uint8_t * buf , int size ) { HTTPContext * s = h -> priv_data ; int len ; len = s -> buf_end - s -> buf_ptr ; if ( len > 0 ) { if ( len > size ) len = size ; memcpy ( buf , s -> buf_ptr , len ) ; s -> buf_ptr += len ; } else { <S2SV_StartBug> int64_t target_end = s -> end_off ? s -> end_off : s -> filesize ; <S2SV_EndBug> <S2SV_StartBug> if ( ( ! s -> willclose || s -> chunksize < 0 ) && <S2SV_EndBug> target_end >= 0 && s -> off >= target_end ) return AVERROR_EOF ; len = ffurl_read ( s -> hd , buf , size ) ; <S2SV_StartBug> if ( ! len && ( ! s -> willclose || s -> chunksize < 0 ) && <S2SV_EndBug> target_end >= 0 && s -> off < target_end ) { av_log ( h , AV_LOG_ERROR , <S2SV_StartBug> \"Stream<S2SV_blank>ends<S2SV_blank>prematurely<S2SV_blank>at<S2SV_blank>%\" PRId64 \",<S2SV_blank>should<S2SV_blank>be<S2SV_blank>%\" PRId64 \"\\\\n\" , <S2SV_EndBug> s -> off , target_end ) ; return AVERROR ( EIO ) ; } } if ( len > 0 ) { s -> off += len ; if ( s -> chunksize > 0 ) s -> chunksize -= len ; } return len ; }\n","target":"<S2SV_ModStart> } else { uint64_t <S2SV_ModEnd> target_end = s <S2SV_ModStart> s -> chunksize == UINT64_MAX ) <S2SV_ModEnd> && s -> <S2SV_ModStart> s -> chunksize == UINT64_MAX ) && s -> off < <S2SV_ModEnd> target_end ) { <S2SV_ModStart> AV_LOG_ERROR , \"Stream<S2SV_blank>ends<S2SV_blank>prematurely<S2SV_blank>at<S2SV_blank>%\" PRIu64 \",<S2SV_blank>should<S2SV_blank>be<S2SV_blank>%\" PRIu64 <S2SV_ModEnd> \"\\\\n\" , s\n","project_and_commit_id":"FFmpeg@FFmpeg/2a05c8f813de6f2278827734bf8102291e7484aa","cve_id":"CVE-2016-10190","original_address":"https://github.com/FFmpeg/FFmpeg/commit/2a05c8f813de6f2278827734bf8102291e7484aa","time":"2017-02-09T15:59Z"},
	{"Unnamed: 0":6341,"cwe_id":"CWE-120","source":"CWE-120 int parse_sym_line ( buf , which_set ) char * buf ; int which_set ; { int val , i ; struct symparse * symp ; <S2SV_StartBug> char * bufp , * commentp , * altp ; <S2SV_EndBug> mungspaces ( buf ) ; if ( ( commentp = rindex ( buf , '#' ) ) != 0 && commentp [ - 1 ] == '<S2SV_blank>' ) commentp [ - 1 ] = '\\\\0' ; bufp = index ( buf , '=' ) ; altp = index ( buf , ':' ) ; if ( ! bufp || ( altp && altp < bufp ) ) bufp = altp ; if ( ! bufp ) { if ( strncmpi ( buf , \"finish\" , 6 ) == 0 ) { if ( chosen_symset_start ) chosen_symset_end = TRUE ; chosen_symset_start = FALSE ; return 1 ; } config_error_add ( \"No<S2SV_blank>\\\\\"finish\\\\\"\" ) ; return 0 ; } ++ bufp ; if ( * bufp == '<S2SV_blank>' ) ++ bufp ; symp = match_sym ( buf ) ; if ( ! symp ) { config_error_add ( \"Unknown<S2SV_blank>sym<S2SV_blank>keyword\" ) ; return 0 ; } if ( ! symset [ which_set ] . name ) { if ( symp -> range == SYM_CONTROL ) { struct symsetentry * tmpsp , * lastsp ; for ( lastsp = symset_list ; lastsp ; lastsp = lastsp -> next ) if ( ! lastsp -> next ) break ; switch ( symp -> idx ) { case 0 : tmpsp = ( struct symsetentry * ) alloc ( sizeof * tmpsp ) ; tmpsp -> next = ( struct symsetentry * ) 0 ; if ( ! lastsp ) symset_list = tmpsp ; else lastsp -> next = tmpsp ; tmpsp -> idx = symset_count ++ ; tmpsp -> name = dupstr ( bufp ) ; tmpsp -> desc = ( char * ) 0 ; tmpsp -> handling = H_UNK ; tmpsp -> nocolor = 0 ; tmpsp -> primary = 0 ; tmpsp -> rogue = 0 ; break ; case 2 : tmpsp = lastsp ; for ( i = 0 ; known_handling [ i ] ; ++ i ) if ( ! strcmpi ( known_handling [ i ] , bufp ) ) { tmpsp -> handling = i ; break ; } break ; case 3 : tmpsp = lastsp ; if ( tmpsp && ! tmpsp -> desc ) tmpsp -> desc = dupstr ( bufp ) ; break ; case 5 : tmpsp = lastsp ; for ( i = 0 ; known_restrictions [ i ] ; ++ i ) { if ( ! strcmpi ( known_restrictions [ i ] , bufp ) ) { switch ( i ) { case 0 : tmpsp -> primary = 1 ; break ; case 1 : tmpsp -> rogue = 1 ; break ; } break ; } } break ; } } return 1 ; } if ( symp -> range ) { if ( symp -> range == SYM_CONTROL ) { switch ( symp -> idx ) { case 0 : if ( ! strcmpi ( bufp , symset [ which_set ] . name ) ) { chosen_symset_start = TRUE ; if ( which_set == ROGUESET ) init_rogue_symbols ( ) ; else if ( which_set == PRIMARY ) init_primary_symbols ( ) ; } break ; case 1 : if ( chosen_symset_start ) chosen_symset_end = TRUE ; chosen_symset_start = FALSE ; break ; case 2 : if ( chosen_symset_start ) set_symhandling ( bufp , which_set ) ; break ; case 4 : if ( chosen_symset_start ) { if ( bufp ) { if ( ! strcmpi ( bufp , \"true\" ) || ! strcmpi ( bufp , \"yes\" ) || ! strcmpi ( bufp , \"on\" ) ) symset [ which_set ] . nocolor = 0 ; else if ( ! strcmpi ( bufp , \"false\" ) || ! strcmpi ( bufp , \"no\" ) || ! strcmpi ( bufp , \"off\" ) ) symset [ which_set ] . nocolor = 1 ; } } break ; case 5 : if ( chosen_symset_start ) { int n = 0 ; while ( known_restrictions [ n ] ) { if ( ! strcmpi ( known_restrictions [ n ] , bufp ) ) { switch ( n ) { case 0 : symset [ which_set ] . primary = 1 ; break ; case 1 : symset [ which_set ] . rogue = 1 ; break ; } break ; } n ++ ; } } break ; } } else { val = sym_val ( bufp ) ; if ( chosen_symset_start ) { if ( which_set == PRIMARY ) { update_primary_symset ( symp , val ) ; } else if ( which_set == ROGUESET ) { update_rogue_symset ( symp , val ) ; } } } } return 1 ; }\n","target":"<S2SV_ModStart> , * altp ; if ( strlen ( buf ) >= BUFSZ ) buf [ BUFSZ - 1 ] = '\\\\0'\n","project_and_commit_id":"NetHack@NetHack/f4a840a48f4bcf11757b3d859e9d53cc9d5ef226","cve_id":"CVE-2019-19905","original_address":"https://github.com/NetHack/NetHack/commit/f4a840a48f4bcf11757b3d859e9d53cc9d5ef226","time":"2019-12-19T18:15Z"},
	{"Unnamed: 0":4049,"cwe_id":"CWE-264","source":"CWE-264 void inet6_destroy_sock ( struct sock * sk ) { struct ipv6_pinfo * np = inet6_sk ( sk ) ; struct sk_buff * skb ; struct ipv6_txoptions * opt ; skb = xchg ( & np -> pktoptions , NULL ) ; if ( skb ) kfree_skb ( skb ) ; skb = xchg ( & np -> rxpmtu , NULL ) ; if ( skb ) kfree_skb ( skb ) ; fl6_free_socklist ( sk ) ; <S2SV_StartBug> opt = xchg ( & np -> opt , NULL ) ; <S2SV_EndBug> <S2SV_StartBug> if ( opt ) <S2SV_EndBug> <S2SV_StartBug> sock_kfree_s ( sk , opt , opt -> tot_len ) ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug>\n","target":"<S2SV_ModStart> = xchg ( ( __force struct ipv6_txoptions * * ) <S2SV_ModStart> ( opt ) { atomic_sub ( <S2SV_ModEnd> opt -> tot_len <S2SV_ModStart> opt -> tot_len , & sk -> sk_omem_alloc ) ; txopt_put ( opt <S2SV_ModStart> ) ; } }\n","project_and_commit_id":"torvalds@linux/45f6fad84cc305103b28d73482b344d7f5b76f39","cve_id":"CVE-2016-3841","original_address":"https://github.com/torvalds/linux/commit/45f6fad84cc305103b28d73482b344d7f5b76f39","time":"2016-08-06T20:59Z"},
	{"Unnamed: 0":881,"cwe_id":"CWE-399","source":"CWE-399 int SMB2_tcon ( const unsigned int xid , struct cifs_ses * ses , const char * tree , struct cifs_tcon * tcon , const struct nls_table * cp ) { struct smb2_tree_connect_req * req ; struct smb2_tree_connect_rsp * rsp = NULL ; struct kvec iov [ 2 ] ; int rc = 0 ; int resp_buftype ; int unc_path_len ; struct TCP_Server_Info * server ; __le16 * unc_path = NULL ; cifs_dbg ( FYI , \"TCON\\\\n\" ) ; if ( ( ses -> server ) && tree ) server = ses -> server ; else return - EIO ; if ( tcon && tcon -> bad_network_name ) return - ENOENT ; unc_path = kmalloc ( MAX_SHARENAME_LENGTH * 2 , GFP_KERNEL ) ; if ( unc_path == NULL ) return - ENOMEM ; unc_path_len = cifs_strtoUTF16 ( unc_path , tree , strlen ( tree ) , cp ) + 1 ; unc_path_len *= 2 ; if ( unc_path_len < 2 ) { kfree ( unc_path ) ; return - EINVAL ; } rc = small_smb2_init ( SMB2_TREE_CONNECT , tcon , ( void * * ) & req ) ; if ( rc ) { kfree ( unc_path ) ; return rc ; } if ( tcon == NULL ) { req -> hdr . SessionId = ses -> Suid ; } iov [ 0 ] . iov_base = ( char * ) req ; iov [ 0 ] . iov_len = get_rfc1002_length ( req ) + 4 - 1 ; req -> PathOffset = cpu_to_le16 ( sizeof ( struct smb2_tree_connect_req ) - 1 - 4 ) ; req -> PathLength = cpu_to_le16 ( unc_path_len - 2 ) ; iov [ 1 ] . iov_base = unc_path ; iov [ 1 ] . iov_len = unc_path_len ; inc_rfc1001_len ( req , unc_path_len - 1 ) ; rc = SendReceive2 ( xid , ses , iov , 2 , & resp_buftype , 0 ) ; rsp = ( struct smb2_tree_connect_rsp * ) iov [ 0 ] . iov_base ; if ( rc != 0 ) { if ( tcon ) { cifs_stats_fail_inc ( tcon , SMB2_TREE_CONNECT_HE ) ; tcon -> need_reconnect = true ; } goto tcon_error_exit ; } if ( tcon == NULL ) { ses -> ipc_tid = rsp -> hdr . TreeId ; goto tcon_exit ; } if ( rsp -> ShareType & SMB2_SHARE_TYPE_DISK ) cifs_dbg ( FYI , \"connection<S2SV_blank>to<S2SV_blank>disk<S2SV_blank>share\\\\n\" ) ; else if ( rsp -> ShareType & SMB2_SHARE_TYPE_PIPE ) { tcon -> ipc = true ; cifs_dbg ( FYI , \"connection<S2SV_blank>to<S2SV_blank>pipe<S2SV_blank>share\\\\n\" ) ; } else if ( rsp -> ShareType & SMB2_SHARE_TYPE_PRINT ) { tcon -> print = true ; cifs_dbg ( FYI , \"connection<S2SV_blank>to<S2SV_blank>printer\\\\n\" ) ; } else { cifs_dbg ( VFS , \"unknown<S2SV_blank>share<S2SV_blank>type<S2SV_blank>%d\\\\n\" , rsp -> ShareType ) ; rc = - EOPNOTSUPP ; goto tcon_error_exit ; } tcon -> share_flags = le32_to_cpu ( rsp -> ShareFlags ) ; tcon -> capabilities = rsp -> Capabilities ; tcon -> maximal_access = le32_to_cpu ( rsp -> MaximalAccess ) ; tcon -> tidStatus = CifsGood ; tcon -> need_reconnect = false ; tcon -> tid = rsp -> hdr . TreeId ; strlcpy ( tcon -> treeName , tree , sizeof ( tcon -> treeName ) ) ; if ( ( rsp -> Capabilities & SMB2_SHARE_CAP_DFS ) && ( ( tcon -> share_flags & SHI1005_FLAGS_DFS ) == 0 ) ) cifs_dbg ( VFS , \"DFS<S2SV_blank>capability<S2SV_blank>contradicts<S2SV_blank>DFS<S2SV_blank>flag\\\\n\" ) ; init_copy_chunk_defaults ( tcon ) ; if ( tcon -> ses -> server -> ops -> validate_negotiate ) rc = tcon -> ses -> server -> ops -> validate_negotiate ( xid , tcon ) ; tcon_exit : free_rsp_buf ( resp_buftype , rsp ) ; kfree ( unc_path ) ; return rc ; tcon_error_exit : if ( rsp -> hdr . Status == STATUS_BAD_NETWORK_NAME ) { cifs_dbg ( VFS , \"BAD_NETWORK_NAME:<S2SV_blank>%s\\\\n\" , tree ) ; <S2SV_StartBug> tcon -> bad_network_name = true ; <S2SV_EndBug> } goto tcon_exit ; }\n","target":"<S2SV_ModStart> tree ) ; if ( tcon )\n","project_and_commit_id":"torvalds@linux/18f39e7be0121317550d03e267e3ebd4dbfbb3ce","cve_id":"CVE-2014-7145","original_address":"https://github.com/torvalds/linux/commit/18f39e7be0121317550d03e267e3ebd4dbfbb3ce","time":"2014-09-28T10:55Z"},
	{"Unnamed: 0":390,"cwe_id":"CWE-399","source":"CWE-399 void serveloop ( GArray * servers ) { struct sockaddr_storage addrin ; socklen_t addrinlen = sizeof ( addrin ) ; int i ; int max ; fd_set mset ; fd_set rset ; max = 0 ; FD_ZERO ( & mset ) ; for ( i = 0 ; i < servers -> len ; i ++ ) { int sock ; if ( ( sock = ( g_array_index ( servers , SERVER , i ) ) . socket ) >= 0 ) { FD_SET ( sock , & mset ) ; max = sock > max ? sock : max ; } } for ( i = 0 ; i < modernsocks -> len ; i ++ ) { int sock = g_array_index ( modernsocks , int , i ) ; FD_SET ( sock , & mset ) ; max = sock > max ? sock : max ; } for ( ; ; ) { if ( is_sighup_caught ) { int n ; GError * gerror = NULL ; msg ( LOG_INFO , \"reconfiguration<S2SV_blank>request<S2SV_blank>received\" ) ; is_sighup_caught = 0 ; n = append_new_servers ( servers , & gerror ) ; if ( n == - 1 ) msg ( LOG_ERR , \"failed<S2SV_blank>to<S2SV_blank>append<S2SV_blank>new<S2SV_blank>servers:<S2SV_blank>%s\" , gerror -> message ) ; for ( i = servers -> len - n ; i < servers -> len ; ++ i ) { const SERVER server = g_array_index ( servers , SERVER , i ) ; if ( server . socket >= 0 ) { FD_SET ( server . socket , & mset ) ; max = server . socket > max ? server . socket : max ; } msg ( LOG_INFO , \"reconfigured<S2SV_blank>new<S2SV_blank>server:<S2SV_blank>%s\" , server . servename ) ; } } memcpy ( & rset , & mset , sizeof ( fd_set ) ) ; if ( select ( max + 1 , & rset , NULL , NULL , NULL ) > 0 ) { <S2SV_StartBug> int net ; <S2SV_EndBug> DEBUG ( \"accept,<S2SV_blank>\" ) ; for ( i = 0 ; i < modernsocks -> len ; i ++ ) { int sock = g_array_index ( modernsocks , int , i ) ; if ( ! FD_ISSET ( sock , & rset ) ) { continue ; } <S2SV_StartBug> CLIENT * client ; <S2SV_EndBug> <S2SV_StartBug> if ( ( net = accept ( sock , ( struct sockaddr * ) & addrin , & addrinlen ) ) < 0 ) { <S2SV_EndBug> err_nonfatal ( \"accept:<S2SV_blank>%m\" ) ; continue ; } <S2SV_StartBug> client = negotiate ( net , NULL , servers , NEG_INIT | NEG_MODERN ) ; <S2SV_EndBug> if ( ! client ) { close ( net ) ; continue ; } handle_connection ( servers , net , client -> server , client ) ; } for ( i = 0 ; i < servers -> len ; i ++ ) { SERVER * serve ; serve = & ( g_array_index ( servers , SERVER , i ) ) ; if ( serve -> socket < 0 ) { continue ; } if ( FD_ISSET ( serve -> socket , & rset ) ) { if ( ( net = accept ( serve -> socket , ( struct sockaddr * ) & addrin , & addrinlen ) ) < 0 ) { err_nonfatal ( \"accept:<S2SV_blank>%m\" ) ; continue ; } handle_connection ( servers , net , serve , NULL ) ; } } } } }\n","target":"<S2SV_ModStart> 0 ) { <S2SV_ModEnd> DEBUG ( \"accept,<S2SV_blank>\" <S2SV_ModStart> continue ; } handle_modern_connection ( servers , sock ) ; } for ( i = 0 ; i < servers -> len ; i ++ ) { int net ; SERVER * serve ; serve = & ( g_array_index ( servers , SERVER , i ) ) ; if ( serve -> socket < 0 ) { continue ; } if ( FD_ISSET ( serve -> socket , & rset ) ) { <S2SV_ModEnd> if ( ( <S2SV_ModStart> = accept ( serve -> socket <S2SV_ModEnd> , ( struct <S2SV_ModStart> continue ; } handle_connection ( servers , net , serve , NULL <S2SV_ModEnd> ) ; }\n","project_and_commit_id":"yoe@nbd/741495cb08503fd32a9d22648e63b64390c601f4","cve_id":"CVE-2013-7441","original_address":"https://github.com/yoe/nbd/commit/741495cb08503fd32a9d22648e63b64390c601f4","time":"2015-05-29T15:59Z"},
	{"Unnamed: 0":2306,"cwe_id":"CWE-125","source":"CWE-125 static void exif_mnote_data_canon_load ( ExifMnoteData * ne , const unsigned char * buf , unsigned int buf_size ) { ExifMnoteDataCanon * n = ( ExifMnoteDataCanon * ) ne ; ExifShort c ; size_t i , tcount , o , datao ; if ( ! n || ! buf || ! buf_size ) { exif_log ( ne -> log , EXIF_LOG_CODE_CORRUPT_DATA , \"ExifMnoteCanon\" , \"Short<S2SV_blank>MakerNote\" ) ; return ; } datao = 6 + n -> offset ; <S2SV_StartBug> if ( ( datao + 2 < datao ) || ( datao + 2 < 2 ) || ( datao + 2 > buf_size ) ) { <S2SV_EndBug> exif_log ( ne -> log , EXIF_LOG_CODE_CORRUPT_DATA , \"ExifMnoteCanon\" , \"Short<S2SV_blank>MakerNote\" ) ; return ; } c = exif_get_short ( buf + datao , n -> order ) ; datao += 2 ; exif_mnote_data_canon_clear ( n ) ; n -> entries = exif_mem_alloc ( ne -> mem , sizeof ( MnoteCanonEntry ) * c ) ; if ( ! n -> entries ) { EXIF_LOG_NO_MEMORY ( ne -> log , \"ExifMnoteCanon\" , sizeof ( MnoteCanonEntry ) * c ) ; return ; } tcount = 0 ; for ( i = c , o = datao ; i ; -- i , o += 12 ) { size_t s ; <S2SV_StartBug> if ( ( o + 12 < o ) || ( o + 12 < 12 ) || ( o + 12 > buf_size ) ) { <S2SV_EndBug> exif_log ( ne -> log , EXIF_LOG_CODE_CORRUPT_DATA , <S2SV_StartBug> \"ExifMnoteCanon\" , \"Short<S2SV_blank>MakerNote\" ) ; <S2SV_EndBug> break ; } n -> entries [ tcount ] . tag = exif_get_short ( buf + o , n -> order ) ; <S2SV_StartBug> n -> entries [ tcount ] . format = exif_get_short ( buf + o + 2 , n -> order ) ; <S2SV_EndBug> <S2SV_StartBug> n -> entries [ tcount ] . components = exif_get_long ( buf + o + 4 , n -> order ) ; <S2SV_EndBug> n -> entries [ tcount ] . order = n -> order ; exif_log ( ne -> log , EXIF_LOG_CODE_DEBUG , \"ExifMnoteCanon\" , \"Loading<S2SV_blank>entry<S2SV_blank>0x%x<S2SV_blank>(\\'%s\\')...\" , n -> entries [ tcount ] . tag , mnote_canon_tag_get_name ( n -> entries [ tcount ] . tag ) ) ; s = exif_format_get_size ( n -> entries [ tcount ] . format ) * n -> entries [ tcount ] . components ; n -> entries [ tcount ] . size = s ; if ( ! s ) { exif_log ( ne -> log , EXIF_LOG_CODE_CORRUPT_DATA , \"ExifMnoteCanon\" , \"Invalid<S2SV_blank>zero-length<S2SV_blank>tag<S2SV_blank>size\" ) ; continue ; } else { size_t dataofs = o + 8 ; if ( s > 4 ) dataofs = exif_get_long ( buf + dataofs , n -> order ) + 6 ; <S2SV_StartBug> if ( ( dataofs + s < s ) || ( dataofs + s < dataofs ) || ( dataofs + s > buf_size ) ) { <S2SV_EndBug> exif_log ( ne -> log , EXIF_LOG_CODE_DEBUG , \"ExifMnoteCanon\" , \"Tag<S2SV_blank>data<S2SV_blank>past<S2SV_blank>end<S2SV_blank>of<S2SV_blank>buffer<S2SV_blank>(%u<S2SV_blank>><S2SV_blank>%u)\" , ( unsigned ) ( dataofs + s ) , buf_size ) ; continue ; } n -> entries [ tcount ] . data = exif_mem_alloc ( ne -> mem , s ) ; if ( ! n -> entries [ tcount ] . data ) { EXIF_LOG_NO_MEMORY ( ne -> log , \"ExifMnoteCanon\" , s ) ; continue ; } memcpy ( n -> entries [ tcount ] . data , buf + dataofs , s ) ; } ++ tcount ; } n -> count = tcount ; }\n","target":"<S2SV_ModStart> ; if ( CHECKOVERFLOW ( datao , buf_size , 2 <S2SV_ModEnd> ) ) { <S2SV_ModStart> ; if ( CHECKOVERFLOW ( o , buf_size , 12 ) ) { exif_log ( ne -> log , EXIF_LOG_CODE_CORRUPT_DATA , \"ExifMnoteCanon\" , \"Short<S2SV_blank>MakerNote\" ) ; break ; } n -> entries [ tcount ] . tag = exif_get_short ( buf + o , n -> order ) ; n -> entries [ tcount ] . format = exif_get_short ( buf + o + 2 , n -> order ) ; n -> entries [ tcount ] . components = exif_get_long ( buf + o + 4 , n -> order ) ; n -> entries [ tcount ] . order = n -> order ; exif_log ( ne -> log , EXIF_LOG_CODE_DEBUG , \"ExifMnoteCanon\" , \"Loading<S2SV_blank>entry<S2SV_blank>0x%x<S2SV_blank>(\\'%s\\')...\" , n -> entries [ tcount ] . tag , mnote_canon_tag_get_name ( n -> entries [ tcount ] . tag ) ) ; if ( exif_format_get_size ( n -> entries [ tcount ] . format ) && buf_size / exif_format_get_size ( n -> entries [ tcount ] . format ) < n -> entries [ tcount ] . components <S2SV_ModEnd> ) { exif_log <S2SV_ModStart> , \"ExifMnoteCanon\" , \"Tag<S2SV_blank>size<S2SV_blank>overflow<S2SV_blank>detected<S2SV_blank>(%u<S2SV_blank>*<S2SV_blank>%lu)\" , exif_format_get_size ( <S2SV_ModEnd> n -> entries <S2SV_ModStart> ] . format ) , <S2SV_ModEnd> n -> entries <S2SV_ModStart> ] . components ) ; continue ; } <S2SV_ModEnd> s = exif_format_get_size <S2SV_ModStart> ; if ( CHECKOVERFLOW ( dataofs , buf_size , s ) ) { exif_log ( ne -> log , EXIF_LOG_CODE_DEBUG , \"ExifMnoteCanon\" , \"Tag<S2SV_blank>data<S2SV_blank>past<S2SV_blank>end<S2SV_blank>of<S2SV_blank>buffer<S2SV_blank>(%u<S2SV_blank>><S2SV_blank>%u)\" , ( unsigned ) <S2SV_ModEnd> ( dataofs + <S2SV_ModStart> dataofs + s ) , buf_size ) ; continue ; } n -> entries [ tcount ] . data = exif_mem_alloc ( ne -> mem , s ) ; if ( ! n -> entries [ tcount ] . data ) { EXIF_LOG_NO_MEMORY ( ne -> log , \"ExifMnoteCanon\" , s ) ; continue ; } memcpy ( n -> entries [ tcount ] . data , buf + dataofs <S2SV_ModEnd> , s )\n","project_and_commit_id":"libexif@libexif/435e21f05001fb03f9f186fa7cbc69454afd00d1","cve_id":"CVE-2020-13112","original_address":"https://github.com/libexif/libexif/commit/435e21f05001fb03f9f186fa7cbc69454afd00d1","time":"2020-05-21T16:15Z"},
	{"Unnamed: 0":4600,"cwe_id":"CWE-119","source":"CWE-119 static vpx_codec_err_t vp8_set_decryptor ( vpx_codec_alg_priv_t * ctx , <S2SV_StartBug> int ctrl_id , <S2SV_EndBug> va_list args ) { <S2SV_StartBug> vp8_decrypt_init * init = va_arg ( args , vp8_decrypt_init * ) ; <S2SV_EndBug> if ( init ) { ctx -> decrypt_cb = init -> decrypt_cb ; ctx -> decrypt_state = init -> decrypt_state ; } else { ctx -> decrypt_cb = NULL ; ctx -> decrypt_state = NULL ; } return VPX_CODEC_OK ; }\n","target":"<S2SV_ModStart> * ctx , <S2SV_ModEnd> va_list args ) <S2SV_ModStart> args ) { vpx_decrypt_init <S2SV_ModEnd> * init = <S2SV_ModStart> ( args , vpx_decrypt_init <S2SV_ModEnd> * ) ;\n","project_and_commit_id":"external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426","cve_id":"CVE-2016-1621","original_address":"https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426","time":"2016-03-12T21:59Z"},
	{"Unnamed: 0":5587,"cwe_id":"CWE-119","source":"CWE-119 BOOL update_recv ( rdpUpdate * update , wStream * s ) { BOOL rc = FALSE ; UINT16 updateType ; rdpContext * context = update -> context ; if ( Stream_GetRemainingLength ( s ) < 2 ) { WLog_ERR ( TAG , \"Stream_GetRemainingLength(s)<S2SV_blank><<S2SV_blank>2\" ) ; return FALSE ; } Stream_Read_UINT16 ( s , updateType ) ; WLog_Print ( update -> log , WLOG_TRACE , \"%s<S2SV_blank>Update<S2SV_blank>Data<S2SV_blank>PDU\" , UPDATE_TYPE_STRINGS [ updateType ] ) ; if ( ! update_begin_paint ( update ) ) goto fail ; switch ( updateType ) { case UPDATE_TYPE_ORDERS : rc = update_recv_orders ( update , s ) ; break ; case UPDATE_TYPE_BITMAP : { BITMAP_UPDATE * bitmap_update = update_read_bitmap_update ( update , s ) ; if ( ! bitmap_update ) { WLog_ERR ( TAG , \"UPDATE_TYPE_BITMAP<S2SV_blank>-<S2SV_blank>update_read_bitmap_update()<S2SV_blank>failed\" ) ; goto fail ; } rc = IFCALLRESULT ( FALSE , update -> BitmapUpdate , context , bitmap_update ) ; free_bitmap_update ( update -> context , bitmap_update ) ; } break ; case UPDATE_TYPE_PALETTE : { PALETTE_UPDATE * palette_update = update_read_palette ( update , s ) ; if ( ! palette_update ) { WLog_ERR ( TAG , \"UPDATE_TYPE_PALETTE<S2SV_blank>-<S2SV_blank>update_read_palette()<S2SV_blank>failed\" ) ; goto fail ; } rc = IFCALLRESULT ( FALSE , update -> Palette , context , palette_update ) ; free_palette_update ( context , palette_update ) ; } break ; case UPDATE_TYPE_SYNCHRONIZE : <S2SV_StartBug> update_read_synchronize ( update , s ) ; <S2SV_EndBug> rc = IFCALLRESULT ( TRUE , update -> Synchronize , context ) ; break ; default : break ; } fail : if ( ! update_end_paint ( update ) ) rc = FALSE ; if ( ! rc ) { WLog_ERR ( TAG , \"UPDATE_TYPE<S2SV_blank>%s<S2SV_blank>[%\" PRIu16 \"]<S2SV_blank>failed\" , update_type_to_string ( updateType ) , updateType ) ; return FALSE ; } return TRUE ; }\n","target":"<S2SV_ModStart> case UPDATE_TYPE_SYNCHRONIZE : if ( ! <S2SV_ModStart> , s ) ) goto fail\n","project_and_commit_id":"FreeRDP@FreeRDP/ed53cd148f43cbab905eaa0f5308c2bf3c48cc37","cve_id":"CVE-2020-11046","original_address":"https://github.com/FreeRDP/FreeRDP/commit/ed53cd148f43cbab905eaa0f5308c2bf3c48cc37","time":"2020-05-07T19:15Z"},
	{"Unnamed: 0":3685,"cwe_id":"CWE-20","source":"CWE-20 static gboolean _handle_carbons ( xmpp_stanza_t * const stanza ) { xmpp_stanza_t * carbons = xmpp_stanza_get_child_by_ns ( stanza , STANZA_NS_CARBONS ) ; if ( ! carbons ) { return FALSE ; } const char * name = xmpp_stanza_get_name ( carbons ) ; if ( ! name ) { log_error ( \"Unable<S2SV_blank>to<S2SV_blank>retrieve<S2SV_blank>stanza<S2SV_blank>name<S2SV_blank>for<S2SV_blank>Carbon\" ) ; return TRUE ; } if ( g_strcmp0 ( name , \"private\" ) == 0 ) { log_info ( \"Carbon<S2SV_blank>received<S2SV_blank>with<S2SV_blank>private<S2SV_blank>element.\" ) ; return FALSE ; } if ( ( g_strcmp0 ( name , \"received\" ) != 0 ) && ( g_strcmp0 ( name , \"sent\" ) != 0 ) ) { log_warning ( \"Carbon<S2SV_blank>received<S2SV_blank>with<S2SV_blank>unrecognised<S2SV_blank>stanza<S2SV_blank>name:<S2SV_blank>%s\" , name ) ; return TRUE ; } xmpp_stanza_t * forwarded = xmpp_stanza_get_child_by_ns ( carbons , STANZA_NS_FORWARD ) ; if ( ! forwarded ) { log_warning ( \"Carbon<S2SV_blank>received<S2SV_blank>with<S2SV_blank>no<S2SV_blank>forwarded<S2SV_blank>element\" ) ; return TRUE ; } xmpp_stanza_t * message = xmpp_stanza_get_child_by_name ( forwarded , STANZA_NAME_MESSAGE ) ; if ( ! message ) { log_warning ( \"Carbon<S2SV_blank>received<S2SV_blank>with<S2SV_blank>no<S2SV_blank>message<S2SV_blank>element\" ) ; return TRUE ; } char * message_txt = xmpp_message_get_body ( message ) ; if ( ! message_txt ) { log_warning ( \"Carbon<S2SV_blank>received<S2SV_blank>with<S2SV_blank>no<S2SV_blank>message.\" ) ; return TRUE ; } <S2SV_StartBug> const gchar * to = xmpp_stanza_get_to ( message ) ; <S2SV_EndBug> const gchar * from = xmpp_stanza_get_from ( message ) ; if ( ! to ) to = from ; Jid * jid_from = jid_create ( from ) ; <S2SV_StartBug> Jid * jid_to = jid_create ( to ) ; <S2SV_EndBug> Jid * my_jid = jid_create ( connection_get_fulljid ( ) ) ; char * enc_message = NULL ; xmpp_stanza_t * x = xmpp_stanza_get_child_by_ns ( message , STANZA_NS_ENCRYPTED ) ; if ( x ) { enc_message = xmpp_stanza_get_text ( x ) ; } if ( g_strcmp0 ( my_jid -> barejid , jid_to -> barejid ) == 0 ) { sv_ev_incoming_carbon ( jid_from -> barejid , jid_from -> resourcepart , message_txt , enc_message ) ; } else { sv_ev_outgoing_carbon ( jid_to -> barejid , message_txt , enc_message ) ; } xmpp_ctx_t * ctx = connection_get_ctx ( ) ; xmpp_free ( ctx , message_txt ) ; xmpp_free ( ctx , enc_message ) ; jid_destroy ( jid_from ) ; jid_destroy ( jid_to ) ; jid_destroy ( my_jid ) ; return TRUE ; }\n","target":"<S2SV_ModStart> TRUE ; } Jid * my_jid = jid_create ( connection_get_fulljid ( ) ) ; const char * const stanza_from = xmpp_stanza_get_from ( stanza ) ; Jid * msg_jid = jid_create ( stanza_from ) ; if ( g_strcmp0 ( my_jid -> barejid , msg_jid -> barejid ) != 0 ) { log_warning ( \"Invalid<S2SV_blank>carbon<S2SV_blank>received,<S2SV_blank>from:<S2SV_blank>%s\" , stanza_from ) ; return TRUE ; } <S2SV_ModStart> jid_create ( to <S2SV_ModEnd> ) ; char\n","project_and_commit_id":"boothj5@profanity/8e75437a7e43d4c55e861691f74892e666e29b0b","cve_id":"CVE-2017-5592","original_address":"https://github.com/boothj5/profanity/commit/8e75437a7e43d4c55e861691f74892e666e29b0b","time":"2017-02-09T20:59Z"},
	{"Unnamed: 0":4649,"cwe_id":"CWE-119","source":"CWE-119 static vpx_codec_err_t encoder_destroy ( vpx_codec_alg_priv_t * ctx ) { free ( ctx -> cx_data ) ; vp9_remove_compressor ( ctx -> cpi ) ; <S2SV_StartBug> free ( ctx ) ; <S2SV_EndBug> return VPX_CODEC_OK ; }\n","target":"<S2SV_ModStart> cpi ) ; # if CONFIG_MULTITHREAD pthread_mutex_destroy ( & ctx -> buffer_pool -> pool_mutex ) ; # endif vpx_free ( ctx -> buffer_pool ) ; vpx_free <S2SV_ModEnd> ( ctx )\n","project_and_commit_id":"external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426","cve_id":"CVE-2016-1621","original_address":"https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426","time":"2016-03-12T21:59Z"},
	{"Unnamed: 0":553,"cwe_id":"CWE-416","source":"CWE-416 static int packet_set_ring ( struct sock * sk , union tpacket_req_u * req_u , int closing , int tx_ring ) { struct pgv * pg_vec = NULL ; struct packet_sock * po = pkt_sk ( sk ) ; int was_running , order = 0 ; struct packet_ring_buffer * rb ; struct sk_buff_head * rb_queue ; __be16 num ; int err = - EINVAL ; <S2SV_StartBug> struct tpacket_req * req = & req_u -> req ; <S2SV_EndBug> if ( ! closing && tx_ring && ( po -> tp_version > TPACKET_V2 ) ) { net_warn_ratelimited ( \"Tx-ring<S2SV_blank>is<S2SV_blank>not<S2SV_blank>supported.\\\\n\" ) ; goto out ; } rb = tx_ring ? & po -> tx_ring : & po -> rx_ring ; rb_queue = tx_ring ? & sk -> sk_write_queue : & sk -> sk_receive_queue ; err = - EBUSY ; if ( ! closing ) { if ( atomic_read ( & po -> mapped ) ) goto out ; if ( packet_read_pending ( rb ) ) goto out ; } if ( req -> tp_block_nr ) { err = - EBUSY ; if ( unlikely ( rb -> pg_vec ) ) goto out ; switch ( po -> tp_version ) { case TPACKET_V1 : po -> tp_hdrlen = TPACKET_HDRLEN ; break ; case TPACKET_V2 : po -> tp_hdrlen = TPACKET2_HDRLEN ; break ; case TPACKET_V3 : po -> tp_hdrlen = TPACKET3_HDRLEN ; break ; } err = - EINVAL ; if ( unlikely ( ( int ) req -> tp_block_size <= 0 ) ) goto out ; if ( unlikely ( ! PAGE_ALIGNED ( req -> tp_block_size ) ) ) goto out ; if ( po -> tp_version >= TPACKET_V3 && ( int ) ( req -> tp_block_size - BLK_PLUS_PRIV ( req_u -> req3 . tp_sizeof_priv ) ) <= 0 ) goto out ; if ( unlikely ( req -> tp_frame_size < po -> tp_hdrlen + po -> tp_reserve ) ) goto out ; if ( unlikely ( req -> tp_frame_size & ( TPACKET_ALIGNMENT - 1 ) ) ) goto out ; rb -> frames_per_block = req -> tp_block_size / req -> tp_frame_size ; if ( unlikely ( rb -> frames_per_block == 0 ) ) goto out ; if ( unlikely ( ( rb -> frames_per_block * req -> tp_block_nr ) != req -> tp_frame_nr ) ) goto out ; err = - ENOMEM ; order = get_order ( req -> tp_block_size ) ; pg_vec = alloc_pg_vec ( req , order ) ; if ( unlikely ( ! pg_vec ) ) goto out ; switch ( po -> tp_version ) { case TPACKET_V3 : if ( ! tx_ring ) init_prb_bdqc ( po , rb , pg_vec , req_u ) ; break ; default : break ; } } else { err = - EINVAL ; if ( unlikely ( req -> tp_frame_nr ) ) goto out ; } <S2SV_StartBug> lock_sock ( sk ) ; <S2SV_EndBug> spin_lock ( & po -> bind_lock ) ; was_running = po -> running ; num = po -> num ; if ( was_running ) { po -> num = 0 ; __unregister_prot_hook ( sk , false ) ; } spin_unlock ( & po -> bind_lock ) ; synchronize_net ( ) ; err = - EBUSY ; mutex_lock ( & po -> pg_vec_lock ) ; if ( closing || atomic_read ( & po -> mapped ) == 0 ) { err = 0 ; spin_lock_bh ( & rb_queue -> lock ) ; swap ( rb -> pg_vec , pg_vec ) ; rb -> frame_max = ( req -> tp_frame_nr - 1 ) ; rb -> head = 0 ; rb -> frame_size = req -> tp_frame_size ; spin_unlock_bh ( & rb_queue -> lock ) ; swap ( rb -> pg_vec_order , order ) ; swap ( rb -> pg_vec_len , req -> tp_block_nr ) ; rb -> pg_vec_pages = req -> tp_block_size / PAGE_SIZE ; po -> prot_hook . func = ( po -> rx_ring . pg_vec ) ? tpacket_rcv : packet_rcv ; skb_queue_purge ( rb_queue ) ; if ( atomic_read ( & po -> mapped ) ) pr_err ( \"packet_mmap:<S2SV_blank>vma<S2SV_blank>is<S2SV_blank>busy:<S2SV_blank>%d\\\\n\" , atomic_read ( & po -> mapped ) ) ; } mutex_unlock ( & po -> pg_vec_lock ) ; spin_lock ( & po -> bind_lock ) ; if ( was_running ) { po -> num = num ; register_prot_hook ( sk ) ; } spin_unlock ( & po -> bind_lock ) ; if ( closing && ( po -> tp_version > TPACKET_V2 ) ) { if ( ! tx_ring ) prb_shutdown_retire_blk_timer ( po , rb_queue ) ; } <S2SV_StartBug> release_sock ( sk ) ; <S2SV_EndBug> <S2SV_StartBug> if ( pg_vec ) <S2SV_EndBug> free_pg_vec ( pg_vec , order , req -> tp_block_nr ) ; out : return err ; }\n","target":"<S2SV_ModStart> req_u -> req ; lock_sock ( sk ) <S2SV_ModStart> out ; } <S2SV_ModEnd> spin_lock ( & <S2SV_ModStart> ) ; } if ( pg_vec ) free_pg_vec ( pg_vec , order , req -> tp_block_nr ) ; out : <S2SV_ModStart> sk ) ; <S2SV_ModEnd> return err ;\n","project_and_commit_id":"torvalds@linux/84ac7260236a49c79eede91617700174c2c19b0c","cve_id":"CVE-2016-8655","original_address":"https://github.com/torvalds/linux/commit/84ac7260236a49c79eede91617700174c2c19b0c","time":"2016-12-08T08:59Z"},
	{"Unnamed: 0":6459,"cwe_id":"CWE-20","source":"CWE-20 static int cma_req_handler ( struct ib_cm_id * cm_id , struct ib_cm_event * ib_event ) { struct rdma_id_private * listen_id , * conn_id ; struct rdma_cm_event event ; int offset , ret ; <S2SV_StartBug> u8 smac [ ETH_ALEN ] ; <S2SV_EndBug> u8 alt_smac [ ETH_ALEN ] ; u8 * psmac = smac ; u8 * palt_smac = alt_smac ; int is_iboe = ( ( rdma_node_get_transport ( cm_id -> device -> node_type ) == RDMA_TRANSPORT_IB ) && ( rdma_port_get_link_layer ( cm_id -> device , ib_event -> param . req_rcvd . port ) == IB_LINK_LAYER_ETHERNET ) ) ; listen_id = cm_id -> context ; if ( ! cma_check_req_qp_type ( & listen_id -> id , ib_event ) ) return - EINVAL ; if ( cma_disable_callback ( listen_id , RDMA_CM_LISTEN ) ) return - ECONNABORTED ; memset ( & event , 0 , sizeof event ) ; offset = cma_user_data_offset ( listen_id ) ; event . event = RDMA_CM_EVENT_CONNECT_REQUEST ; if ( ib_event -> event == IB_CM_SIDR_REQ_RECEIVED ) { conn_id = cma_new_udp_id ( & listen_id -> id , ib_event ) ; event . param . ud . private_data = ib_event -> private_data + offset ; event . param . ud . private_data_len = IB_CM_SIDR_REQ_PRIVATE_DATA_SIZE - offset ; } else { conn_id = cma_new_conn_id ( & listen_id -> id , ib_event ) ; cma_set_req_event_data ( & event , & ib_event -> param . req_rcvd , ib_event -> private_data , offset ) ; } if ( ! conn_id ) { ret = - ENOMEM ; goto err1 ; } mutex_lock_nested ( & conn_id -> handler_mutex , SINGLE_DEPTH_NESTING ) ; ret = cma_acquire_dev ( conn_id , listen_id ) ; if ( ret ) goto err2 ; conn_id -> cm_id . ib = cm_id ; cm_id -> context = conn_id ; cm_id -> cm_handler = cma_ib_handler ; atomic_inc ( & conn_id -> refcount ) ; ret = conn_id -> id . event_handler ( & conn_id -> id , & event ) ; if ( ret ) goto err3 ; <S2SV_StartBug> if ( is_iboe ) { <S2SV_EndBug> if ( ib_event -> param . req_rcvd . primary_path != NULL ) rdma_addr_find_smac_by_sgid ( & ib_event -> param . req_rcvd . primary_path -> sgid , psmac , NULL ) ; else psmac = NULL ; if ( ib_event -> param . req_rcvd . alternate_path != NULL ) rdma_addr_find_smac_by_sgid ( & ib_event -> param . req_rcvd . alternate_path -> sgid , palt_smac , NULL ) ; else palt_smac = NULL ; } <S2SV_StartBug> mutex_lock ( & lock ) ; <S2SV_EndBug> if ( is_iboe ) ib_update_cm_av ( cm_id , psmac , palt_smac ) ; if ( cma_comp ( conn_id , RDMA_CM_CONNECT ) && ( conn_id -> id . qp_type != IB_QPT_UD ) ) ib_send_cm_mra ( cm_id , CMA_CM_MRA_SETTING , NULL , 0 ) ; mutex_unlock ( & lock ) ; mutex_unlock ( & conn_id -> handler_mutex ) ; mutex_unlock ( & listen_id -> handler_mutex ) ; cma_deref_id ( conn_id ) ; return 0 ; err3 : cma_deref_id ( conn_id ) ; conn_id -> cm_id . ib = NULL ; err2 : cma_exch ( conn_id , RDMA_CM_DESTROYING ) ; mutex_unlock ( & conn_id -> handler_mutex ) ; err1 : mutex_unlock ( & listen_id -> handler_mutex ) ; if ( conn_id ) rdma_destroy_id ( & conn_id -> id ) ; return ret ; }\n","target":"<S2SV_ModStart> , ret ; <S2SV_ModEnd> listen_id = cm_id <S2SV_ModStart> goto err3 ; <S2SV_ModEnd> mutex_lock ( & <S2SV_ModStart> ( & lock <S2SV_ModEnd> ) ; if\n","project_and_commit_id":"torvalds@linux/b2853fd6c2d0f383dbdf7427e263eb576a633867","cve_id":"CVE-2014-2739","original_address":"https://github.com/torvalds/linux/commit/b2853fd6c2d0f383dbdf7427e263eb576a633867","time":"2014-04-14T23:55Z"},
	{"Unnamed: 0":5931,"cwe_id":"CWE-125","source":"CWE-125 PyObject * ast2obj_withitem ( void * _o ) { withitem_ty o = ( withitem_ty ) _o ; PyObject * result = NULL , * value = NULL ; if ( ! o ) { <S2SV_StartBug> Py_INCREF ( Py_None ) ; <S2SV_EndBug> return Py_None ; } result = PyType_GenericNew ( withitem_type , NULL , NULL ) ; if ( ! result ) return NULL ; value = ast2obj_expr ( o -> context_expr ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_context_expr , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; value = ast2obj_expr ( o -> optional_vars ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_optional_vars , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; return result ; failed : Py_XDECREF ( value ) ; Py_XDECREF ( result ) ; return NULL ; }\n","target":"<S2SV_ModStart> o ) { Py_RETURN_NONE <S2SV_ModEnd> ; } result\n","project_and_commit_id":"python@typed_ast/156afcb26c198e162504a57caddfe0acd9ed7dce","cve_id":"CVE-2019-19275","original_address":"https://github.com/python/typed_ast/commit/156afcb26c198e162504a57caddfe0acd9ed7dce","time":"2019-11-26T15:15Z"},
	{"Unnamed: 0":1609,"cwe_id":"CWE-119","source":"CWE-119 static vpx_codec_err_t decoder_destroy ( vpx_codec_alg_priv_t * ctx ) { <S2SV_StartBug> if ( ctx -> pbi ) { <S2SV_EndBug> vp9_decoder_remove ( ctx -> pbi ) ; <S2SV_StartBug> ctx -> pbi = NULL ; <S2SV_EndBug> } vpx_free ( ctx ) ; return VPX_CODEC_OK ; }\n","target":"<S2SV_ModStart> ( ctx -> frame_workers != NULL ) { int i ; for ( i = 0 ; i < ctx -> num_frame_workers ; ++ i ) { VPxWorker * const worker = & ctx -> frame_workers [ i ] ; FrameWorkerData * const frame_worker_data = ( FrameWorkerData * ) worker -> data1 ; vpx_get_worker_interface ( ) -> end ( worker ) ; vp9_remove_common ( & frame_worker_data -> pbi -> common ) ; # if CONFIG_VP9_POSTPROC vp9_free_postproc_buffers ( & frame_worker_data -> pbi -> common ) ; # endif vp9_decoder_remove ( frame_worker_data <S2SV_ModEnd> -> pbi ) <S2SV_ModStart> pbi ) ; vpx_free ( frame_worker_data -> scratch_buffer ) ; # if CONFIG_MULTITHREAD pthread_mutex_destroy ( & frame_worker_data -> stats_mutex ) ; pthread_cond_destroy ( & frame_worker_data -> stats_cond ) ; # endif vpx_free ( frame_worker_data ) ; } # if CONFIG_MULTITHREAD pthread_mutex_destroy ( & ctx -> buffer_pool -> pool_mutex ) ; # endif } if ( ctx -> buffer_pool ) { vp9_free_ref_frame_buffers ( ctx -> buffer_pool ) ; vp9_free_internal_frame_buffers ( & ctx -> buffer_pool -> int_frame_buffers ) ; } vpx_free ( ctx -> frame_workers ) ; vpx_free ( ctx -> buffer_pool ) ; <S2SV_ModEnd> vpx_free ( ctx\n","project_and_commit_id":"external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426","cve_id":"CVE-2016-1621","original_address":"https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426","time":"2016-03-12T21:59Z"},
	{"Unnamed: 0":3777,"cwe_id":"CWE-119","source":"CWE-119 void vp8_denoiser_free ( VP8_DENOISER * denoiser ) { int i ; assert ( denoiser ) ; for ( i = 0 ; i < MAX_REF_FRAMES ; i ++ ) { vp8_yv12_de_alloc_frame_buffer ( & denoiser -> yv12_running_avg [ i ] ) ; } vp8_yv12_de_alloc_frame_buffer ( & denoiser -> yv12_mc_running_avg ) ; <S2SV_StartBug> } <S2SV_EndBug>\n","target":"<S2SV_ModStart> yv12_mc_running_avg ) ; vp8_yv12_de_alloc_frame_buffer ( & denoiser -> yv12_last_source ) ; vpx_free ( denoiser -> denoise_state ) ;\n","project_and_commit_id":"external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426","cve_id":"CVE-2016-1621","original_address":"https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426","time":"2016-03-12T21:59Z"},
	{"Unnamed: 0":1829,"cwe_id":"CWE-416","source":"CWE-416 void ion_free ( struct ion_client * client , struct ion_handle * handle ) { <S2SV_StartBug> bool valid_handle ; <S2SV_EndBug> BUG_ON ( client != handle -> client ) ; mutex_lock ( & client -> lock ) ; <S2SV_StartBug> valid_handle = ion_handle_validate ( client , handle ) ; <S2SV_EndBug> if ( ! valid_handle ) { WARN ( 1 , \"%s:<S2SV_blank>invalid<S2SV_blank>handle<S2SV_blank>passed<S2SV_blank>to<S2SV_blank>free.\\\\n\" , __func__ ) ; mutex_unlock ( & client -> lock ) ; <S2SV_StartBug> return ; <S2SV_EndBug> } mutex_unlock ( & client -> lock ) ; ion_handle_put ( handle ) ; }\n","target":"<S2SV_ModStart> handle ) { <S2SV_ModEnd> BUG_ON ( client <S2SV_ModStart> lock ) ; ion_free_nolock <S2SV_ModEnd> ( client , <S2SV_ModStart> client , handle <S2SV_ModEnd> ) ; mutex_unlock <S2SV_ModStart> lock ) ; <S2SV_ModEnd> } <S2SV_null> <S2SV_null>\n","project_and_commit_id":"torvalds@linux/9590232bb4f4cc824f3425a6e1349afbe6d6d2b7","cve_id":"CVE-2016-9120","original_address":"https://github.com/torvalds/linux/commit/9590232bb4f4cc824f3425a6e1349afbe6d6d2b7","time":"2016-12-08T21:59Z"},
	{"Unnamed: 0":2259,"cwe_id":"CWE-125","source":"CWE-125 void vqp_print ( netdissect_options * ndo , register const u_char * pptr , register u_int len ) { const struct vqp_common_header_t * vqp_common_header ; const struct vqp_obj_tlv_t * vqp_obj_tlv ; const u_char * tptr ; uint16_t vqp_obj_len ; uint32_t vqp_obj_type ; <S2SV_StartBug> int tlen ; <S2SV_EndBug> uint8_t nitems ; tptr = pptr ; tlen = len ; vqp_common_header = ( const struct vqp_common_header_t * ) pptr ; <S2SV_StartBug> ND_TCHECK ( * vqp_common_header ) ; <S2SV_EndBug> if ( VQP_EXTRACT_VERSION ( vqp_common_header -> version ) != VQP_VERSION ) { ND_PRINT ( ( ndo , \"VQP<S2SV_blank>version<S2SV_blank>%u<S2SV_blank>packet<S2SV_blank>not<S2SV_blank>supported\" , VQP_EXTRACT_VERSION ( vqp_common_header -> version ) ) ) ; return ; } if ( ndo -> ndo_vflag < 1 ) { ND_PRINT ( ( ndo , \"VQPv%u<S2SV_blank>%s<S2SV_blank>Message,<S2SV_blank>error-code<S2SV_blank>%s<S2SV_blank>(%u),<S2SV_blank>length<S2SV_blank>%u\" , VQP_EXTRACT_VERSION ( vqp_common_header -> version ) , tok2str ( vqp_msg_type_values , \"unknown<S2SV_blank>(%u)\" , vqp_common_header -> msg_type ) , tok2str ( vqp_error_code_values , \"unknown<S2SV_blank>(%u)\" , vqp_common_header -> error_code ) , vqp_common_header -> error_code , len ) ) ; return ; } nitems = vqp_common_header -> nitems ; ND_PRINT ( ( ndo , \"\\\\n\\\\tVQPv%u,<S2SV_blank>%s<S2SV_blank>Message,<S2SV_blank>error-code<S2SV_blank>%s<S2SV_blank>(%u),<S2SV_blank>seq<S2SV_blank>0x%08x,<S2SV_blank>items<S2SV_blank>%u,<S2SV_blank>length<S2SV_blank>%u\" , VQP_EXTRACT_VERSION ( vqp_common_header -> version ) , tok2str ( vqp_msg_type_values , \"unknown<S2SV_blank>(%u)\" , vqp_common_header -> msg_type ) , tok2str ( vqp_error_code_values , \"unknown<S2SV_blank>(%u)\" , vqp_common_header -> error_code ) , vqp_common_header -> error_code , EXTRACT_32BITS ( & vqp_common_header -> sequence ) , nitems , len ) ) ; tptr += sizeof ( const struct vqp_common_header_t ) ; tlen -= sizeof ( const struct vqp_common_header_t ) ; while ( nitems > 0 && tlen > 0 ) { vqp_obj_tlv = ( const struct vqp_obj_tlv_t * ) tptr ; <S2SV_StartBug> vqp_obj_type = EXTRACT_32BITS ( vqp_obj_tlv -> obj_type ) ; <S2SV_EndBug> vqp_obj_len = EXTRACT_16BITS ( vqp_obj_tlv -> obj_length ) ; tptr += sizeof ( struct vqp_obj_tlv_t ) ; tlen -= sizeof ( struct vqp_obj_tlv_t ) ; ND_PRINT ( ( ndo , \"\\\\n\\\\t<S2SV_blank><S2SV_blank>%s<S2SV_blank>Object<S2SV_blank>(0x%08x),<S2SV_blank>length<S2SV_blank>%u,<S2SV_blank>value:<S2SV_blank>\" , tok2str ( vqp_obj_values , \"Unknown\" , vqp_obj_type ) , vqp_obj_type , vqp_obj_len ) ) ; if ( vqp_obj_type == 0 || vqp_obj_len == 0 ) { return ; } ND_TCHECK2 ( * tptr , vqp_obj_len ) ; <S2SV_StartBug> switch ( vqp_obj_type ) { <S2SV_EndBug> case VQP_OBJ_IP_ADDRESS : <S2SV_StartBug> ND_PRINT ( ( ndo , \"%s<S2SV_blank>(0x%08x)\" , ipaddr_string ( ndo , tptr ) , EXTRACT_32BITS ( tptr ) ) ) ; <S2SV_EndBug> break ; case VQP_OBJ_PORT_NAME : case VQP_OBJ_VLAN_NAME : case VQP_OBJ_VTP_DOMAIN : case VQP_OBJ_ETHERNET_PKT : safeputs ( ndo , tptr , vqp_obj_len ) ; break ; case VQP_OBJ_MAC_ADDRESS : <S2SV_StartBug> case VQP_OBJ_MAC_NULL : <S2SV_EndBug> ND_PRINT ( ( ndo , \"%s\" , etheraddr_string ( ndo , tptr ) ) ) ; break ; default : if ( ndo -> ndo_vflag <= 1 ) print_unknown_data ( ndo , tptr , \"\\\\n\\\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>\" , vqp_obj_len ) ; break ; } tptr += vqp_obj_len ; tlen -= vqp_obj_len ; nitems -- ; } return ; trunc : ND_PRINT ( ( ndo , \"\\\\n\\\\t[|VQP]\" ) ) ; }\n","target":"<S2SV_ModStart> uint32_t vqp_obj_type ; u_int <S2SV_ModEnd> tlen ; uint8_t <S2SV_ModStart> * vqp_common_header ) ; if ( sizeof ( struct vqp_common_header_t ) > tlen ) goto trunc <S2SV_ModStart> ) tptr ; ND_TCHECK ( * vqp_obj_tlv ) ; if ( sizeof ( struct vqp_obj_tlv_t ) > tlen ) goto trunc ; <S2SV_ModStart> vqp_obj_len ) ; if ( vqp_obj_len > tlen ) goto trunc ; <S2SV_ModStart> case VQP_OBJ_IP_ADDRESS : if ( vqp_obj_len != 4 ) goto trunc ; <S2SV_ModStart> case VQP_OBJ_MAC_NULL : if ( vqp_obj_len != ETHER_ADDR_LEN ) goto trunc ;\n","project_and_commit_id":"the-tcpdump-group@tcpdump/3b36ec4e713dea9266db11975066c425aa669b6c","cve_id":"CVE-2017-13045","original_address":"https://github.com/the-tcpdump-group/tcpdump/commit/3b36ec4e713dea9266db11975066c425aa669b6c","time":"2017-09-14T06:29Z"},
	{"Unnamed: 0":1338,"cwe_id":"CWE-189","source":"CWE-189 static inline void x86_assign_hw_event ( struct perf_event * event , struct cpu_hw_events * cpuc , int i ) { struct hw_perf_event * hwc = & event -> hw ; hwc -> idx = cpuc -> assign [ i ] ; hwc -> last_cpu = smp_processor_id ( ) ; hwc -> last_tag = ++ cpuc -> tags [ i ] ; if ( hwc -> idx == X86_PMC_IDX_FIXED_BTS ) { hwc -> config_base = 0 ; hwc -> event_base = 0 ; } else if ( hwc -> idx >= X86_PMC_IDX_FIXED ) { hwc -> config_base = MSR_ARCH_PERFMON_FIXED_CTR_CTRL ; <S2SV_StartBug> hwc -> event_base = MSR_ARCH_PERFMON_FIXED_CTR0 ; <S2SV_EndBug> } else { hwc -> config_base = x86_pmu_config_addr ( hwc -> idx ) ; hwc -> event_base = x86_pmu_event_addr ( hwc -> idx ) ; } }\n","target":"<S2SV_ModStart> event_base = MSR_ARCH_PERFMON_FIXED_CTR0 + ( hwc -> idx - X86_PMC_IDX_FIXED )\n","project_and_commit_id":"torvalds@linux/fc66c5210ec2539e800e87d7b3a985323c7be96e","cve_id":"CVE-2011-2521","original_address":"https://github.com/torvalds/linux/commit/fc66c5210ec2539e800e87d7b3a985323c7be96e","time":"2012-05-24T23:55Z"},
	{"Unnamed: 0":4229,"cwe_id":"CWE-20","source":"CWE-20 static int iucv_sock_recvmsg ( struct kiocb * iocb , struct socket * sock , struct msghdr * msg , size_t len , int flags ) { int noblock = flags & MSG_DONTWAIT ; struct sock * sk = sock -> sk ; struct iucv_sock * iucv = iucv_sk ( sk ) ; unsigned int copied , rlen ; struct sk_buff * skb , * rskb , * cskb ; int err = 0 ; <S2SV_StartBug> u32 offset ; <S2SV_EndBug> msg -> msg_namelen = 0 ; if ( ( sk -> sk_state == IUCV_DISCONN ) && skb_queue_empty ( & iucv -> backlog_skb_q ) && skb_queue_empty ( & sk -> sk_receive_queue ) && list_empty ( & iucv -> message_q . list ) ) return 0 ; if ( flags & ( MSG_OOB ) ) return - EOPNOTSUPP ; skb = skb_recv_datagram ( sk , flags , noblock , & err ) ; if ( ! skb ) { if ( sk -> sk_shutdown & RCV_SHUTDOWN ) return 0 ; return err ; } offset = IUCV_SKB_CB ( skb ) -> offset ; rlen = skb -> len - offset ; copied = min_t ( unsigned int , rlen , len ) ; if ( ! rlen ) sk -> sk_shutdown = sk -> sk_shutdown | RCV_SHUTDOWN ; cskb = skb ; if ( skb_copy_datagram_iovec ( cskb , offset , msg -> msg_iov , copied ) ) { if ( ! ( flags & MSG_PEEK ) ) skb_queue_head ( & sk -> sk_receive_queue , skb ) ; return - EFAULT ; } if ( sk -> sk_type == SOCK_SEQPACKET ) { if ( copied < rlen ) msg -> msg_flags |= MSG_TRUNC ; msg -> msg_flags |= MSG_EOR ; } err = put_cmsg ( msg , SOL_IUCV , SCM_IUCV_TRGCLS , sizeof ( IUCV_SKB_CB ( skb ) -> class ) , ( void * ) & IUCV_SKB_CB ( skb ) -> class ) ; if ( err ) { if ( ! ( flags & MSG_PEEK ) ) skb_queue_head ( & sk -> sk_receive_queue , skb ) ; return err ; } if ( ! ( flags & MSG_PEEK ) ) { if ( sk -> sk_type == SOCK_STREAM ) { if ( copied < rlen ) { IUCV_SKB_CB ( skb ) -> offset = offset + copied ; goto done ; } } kfree_skb ( skb ) ; if ( iucv -> transport == AF_IUCV_TRANS_HIPER ) { atomic_inc ( & iucv -> msg_recv ) ; if ( atomic_read ( & iucv -> msg_recv ) > iucv -> msglimit ) { WARN_ON ( 1 ) ; iucv_sock_close ( sk ) ; return - EFAULT ; } } spin_lock_bh ( & iucv -> message_q . lock ) ; rskb = skb_dequeue ( & iucv -> backlog_skb_q ) ; while ( rskb ) { IUCV_SKB_CB ( rskb ) -> offset = 0 ; if ( sock_queue_rcv_skb ( sk , rskb ) ) { skb_queue_head ( & iucv -> backlog_skb_q , rskb ) ; break ; } else { rskb = skb_dequeue ( & iucv -> backlog_skb_q ) ; } } if ( skb_queue_empty ( & iucv -> backlog_skb_q ) ) { if ( ! list_empty ( & iucv -> message_q . list ) ) iucv_process_message_q ( sk ) ; if ( atomic_read ( & iucv -> msg_recv ) >= iucv -> msglimit / 2 ) { err = iucv_send_ctrl ( sk , AF_IUCV_FLAG_WIN ) ; if ( err ) { sk -> sk_state = IUCV_DISCONN ; sk -> sk_state_change ( sk ) ; } } } spin_unlock_bh ( & iucv -> message_q . lock ) ; } done : if ( sk -> sk_type == SOCK_SEQPACKET && ( flags & MSG_TRUNC ) ) copied = rlen ; return copied ; }\n","target":"<S2SV_ModStart> ; u32 offset <S2SV_ModEnd> ; if (\n","project_and_commit_id":"torvalds@linux/f3d3342602f8bcbf37d7c46641cb9bca7618eb1c","cve_id":"CVE-2013-7271","original_address":"https://github.com/torvalds/linux/commit/f3d3342602f8bcbf37d7c46641cb9bca7618eb1c","time":"2014-01-06T16:55Z"},
	{"Unnamed: 0":754,"cwe_id":"CWE-125","source":"CWE-125 static int bgp_attr_print ( netdissect_options * ndo , u_int atype , const u_char * pptr , u_int len ) { int i ; uint16_t af ; uint8_t safi , snpa , nhlen ; union { float f ; uint32_t i ; } bw ; int advance ; u_int tlen ; const u_char * tptr ; char buf [ MAXHOSTNAMELEN + 100 ] ; int as_size ; tptr = pptr ; tlen = len ; switch ( atype ) { case BGPTYPE_ORIGIN : if ( len != 1 ) ND_PRINT ( ( ndo , \"invalid<S2SV_blank>len\" ) ) ; else { ND_TCHECK ( * tptr ) ; ND_PRINT ( ( ndo , \"%s\" , tok2str ( bgp_origin_values , \"Unknown<S2SV_blank>Origin<S2SV_blank>Typecode\" , tptr [ 0 ] ) ) ) ; } break ; case BGPTYPE_AS4_PATH : case BGPTYPE_AS_PATH : if ( len % 2 ) { ND_PRINT ( ( ndo , \"invalid<S2SV_blank>len\" ) ) ; break ; } if ( ! len ) { ND_PRINT ( ( ndo , \"empty\" ) ) ; break ; } as_size = bgp_attr_get_as_size ( ndo , atype , pptr , len ) ; while ( tptr < pptr + len ) { ND_TCHECK ( tptr [ 0 ] ) ; ND_PRINT ( ( ndo , \"%s\" , tok2str ( bgp_as_path_segment_open_values , \"?\" , tptr [ 0 ] ) ) ) ; ND_TCHECK ( tptr [ 1 ] ) ; for ( i = 0 ; i < tptr [ 1 ] * as_size ; i += as_size ) { ND_TCHECK2 ( tptr [ 2 + i ] , as_size ) ; ND_PRINT ( ( ndo , \"%s<S2SV_blank>\" , as_printf ( ndo , astostr , sizeof ( astostr ) , as_size == 2 ? EXTRACT_16BITS ( & tptr [ 2 + i ] ) : EXTRACT_32BITS ( & tptr [ 2 + i ] ) ) ) ) ; } ND_TCHECK ( tptr [ 0 ] ) ; ND_PRINT ( ( ndo , \"%s\" , tok2str ( bgp_as_path_segment_close_values , \"?\" , tptr [ 0 ] ) ) ) ; ND_TCHECK ( tptr [ 1 ] ) ; tptr += 2 + tptr [ 1 ] * as_size ; } break ; case BGPTYPE_NEXT_HOP : if ( len != 4 ) ND_PRINT ( ( ndo , \"invalid<S2SV_blank>len\" ) ) ; else { ND_TCHECK2 ( tptr [ 0 ] , 4 ) ; ND_PRINT ( ( ndo , \"%s\" , ipaddr_string ( ndo , tptr ) ) ) ; } break ; case BGPTYPE_MULTI_EXIT_DISC : case BGPTYPE_LOCAL_PREF : if ( len != 4 ) ND_PRINT ( ( ndo , \"invalid<S2SV_blank>len\" ) ) ; else { ND_TCHECK2 ( tptr [ 0 ] , 4 ) ; ND_PRINT ( ( ndo , \"%u\" , EXTRACT_32BITS ( tptr ) ) ) ; } break ; case BGPTYPE_ATOMIC_AGGREGATE : if ( len != 0 ) ND_PRINT ( ( ndo , \"invalid<S2SV_blank>len\" ) ) ; break ; case BGPTYPE_AGGREGATOR : if ( len != 6 && len != 8 ) { ND_PRINT ( ( ndo , \"invalid<S2SV_blank>len\" ) ) ; break ; } ND_TCHECK2 ( tptr [ 0 ] , len ) ; if ( len == 6 ) { ND_PRINT ( ( ndo , \"<S2SV_blank>AS<S2SV_blank>#%s,<S2SV_blank>origin<S2SV_blank>%s\" , as_printf ( ndo , astostr , sizeof ( astostr ) , EXTRACT_16BITS ( tptr ) ) , ipaddr_string ( ndo , tptr + 2 ) ) ) ; } else { ND_PRINT ( ( ndo , \"<S2SV_blank>AS<S2SV_blank>#%s,<S2SV_blank>origin<S2SV_blank>%s\" , as_printf ( ndo , astostr , sizeof ( astostr ) , EXTRACT_32BITS ( tptr ) ) , ipaddr_string ( ndo , tptr + 4 ) ) ) ; } break ; case BGPTYPE_AGGREGATOR4 : if ( len != 8 ) { ND_PRINT ( ( ndo , \"invalid<S2SV_blank>len\" ) ) ; break ; } ND_TCHECK2 ( tptr [ 0 ] , 8 ) ; ND_PRINT ( ( ndo , \"<S2SV_blank>AS<S2SV_blank>#%s,<S2SV_blank>origin<S2SV_blank>%s\" , as_printf ( ndo , astostr , sizeof ( astostr ) , EXTRACT_32BITS ( tptr ) ) , ipaddr_string ( ndo , tptr + 4 ) ) ) ; break ; case BGPTYPE_COMMUNITIES : if ( len % 4 ) { ND_PRINT ( ( ndo , \"invalid<S2SV_blank>len\" ) ) ; break ; } while ( tlen > 0 ) { uint32_t comm ; ND_TCHECK2 ( tptr [ 0 ] , 4 ) ; comm = EXTRACT_32BITS ( tptr ) ; switch ( comm ) { case BGP_COMMUNITY_NO_EXPORT : ND_PRINT ( ( ndo , \"<S2SV_blank>NO_EXPORT\" ) ) ; break ; case BGP_COMMUNITY_NO_ADVERT : ND_PRINT ( ( ndo , \"<S2SV_blank>NO_ADVERTISE\" ) ) ; break ; case BGP_COMMUNITY_NO_EXPORT_SUBCONFED : ND_PRINT ( ( ndo , \"<S2SV_blank>NO_EXPORT_SUBCONFED\" ) ) ; break ; default : ND_PRINT ( ( ndo , \"%u:%u%s\" , ( comm >> 16 ) & 0xffff , comm & 0xffff , ( tlen > 4 ) ? \",<S2SV_blank>\" : \"\" ) ) ; break ; } tlen -= 4 ; tptr += 4 ; } break ; case BGPTYPE_ORIGINATOR_ID : if ( len != 4 ) { ND_PRINT ( ( ndo , \"invalid<S2SV_blank>len\" ) ) ; break ; } ND_TCHECK2 ( tptr [ 0 ] , 4 ) ; ND_PRINT ( ( ndo , \"%s\" , ipaddr_string ( ndo , tptr ) ) ) ; break ; case BGPTYPE_CLUSTER_LIST : if ( len % 4 ) { ND_PRINT ( ( ndo , \"invalid<S2SV_blank>len\" ) ) ; break ; } while ( tlen > 0 ) { ND_TCHECK2 ( tptr [ 0 ] , 4 ) ; ND_PRINT ( ( ndo , \"%s%s\" , ipaddr_string ( ndo , tptr ) , ( tlen > 4 ) ? \",<S2SV_blank>\" : \"\" ) ) ; tlen -= 4 ; tptr += 4 ; } break ; case BGPTYPE_MP_REACH_NLRI : ND_TCHECK2 ( tptr [ 0 ] , 3 ) ; af = EXTRACT_16BITS ( tptr ) ; safi = tptr [ 2 ] ; ND_PRINT ( ( ndo , \"\\\\n\\\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>AFI:<S2SV_blank>%s<S2SV_blank>(%u),<S2SV_blank>%sSAFI:<S2SV_blank>%s<S2SV_blank>(%u)\" , tok2str ( af_values , \"Unknown<S2SV_blank>AFI\" , af ) , af , ( safi > 128 ) ? \"vendor<S2SV_blank>specific<S2SV_blank>\" : \"\" , tok2str ( bgp_safi_values , \"Unknown<S2SV_blank>SAFI\" , safi ) , safi ) ) ; switch ( af << 8 | safi ) { case ( AFNUM_INET << 8 | SAFNUM_UNICAST ) : case ( AFNUM_INET << 8 | SAFNUM_MULTICAST ) : case ( AFNUM_INET << 8 | SAFNUM_UNIMULTICAST ) : case ( AFNUM_INET << 8 | SAFNUM_LABUNICAST ) : case ( AFNUM_INET << 8 | SAFNUM_RT_ROUTING_INFO ) : case ( AFNUM_INET << 8 | SAFNUM_VPNUNICAST ) : case ( AFNUM_INET << 8 | SAFNUM_VPNMULTICAST ) : case ( AFNUM_INET << 8 | SAFNUM_VPNUNIMULTICAST ) : case ( AFNUM_INET << 8 | SAFNUM_MULTICAST_VPN ) : case ( AFNUM_INET << 8 | SAFNUM_MDT ) : case ( AFNUM_INET6 << 8 | SAFNUM_UNICAST ) : case ( AFNUM_INET6 << 8 | SAFNUM_MULTICAST ) : case ( AFNUM_INET6 << 8 | SAFNUM_UNIMULTICAST ) : case ( AFNUM_INET6 << 8 | SAFNUM_LABUNICAST ) : case ( AFNUM_INET6 << 8 | SAFNUM_VPNUNICAST ) : case ( AFNUM_INET6 << 8 | SAFNUM_VPNMULTICAST ) : case ( AFNUM_INET6 << 8 | SAFNUM_VPNUNIMULTICAST ) : case ( AFNUM_NSAP << 8 | SAFNUM_UNICAST ) : case ( AFNUM_NSAP << 8 | SAFNUM_MULTICAST ) : case ( AFNUM_NSAP << 8 | SAFNUM_UNIMULTICAST ) : case ( AFNUM_NSAP << 8 | SAFNUM_VPNUNICAST ) : case ( AFNUM_NSAP << 8 | SAFNUM_VPNMULTICAST ) : case ( AFNUM_NSAP << 8 | SAFNUM_VPNUNIMULTICAST ) : case ( AFNUM_L2VPN << 8 | SAFNUM_VPNUNICAST ) : case ( AFNUM_L2VPN << 8 | SAFNUM_VPNMULTICAST ) : case ( AFNUM_L2VPN << 8 | SAFNUM_VPNUNIMULTICAST ) : case ( AFNUM_VPLS << 8 | SAFNUM_VPLS ) : break ; default : ND_TCHECK2 ( tptr [ 0 ] , tlen ) ; ND_PRINT ( ( ndo , \"\\\\n\\\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>no<S2SV_blank>AFI<S2SV_blank>%u<S2SV_blank>/<S2SV_blank>SAFI<S2SV_blank>%u<S2SV_blank>decoder\" , af , safi ) ) ; if ( ndo -> ndo_vflag <= 1 ) print_unknown_data ( ndo , tptr , \"\\\\n\\\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>\" , tlen ) ; goto done ; break ; } tptr += 3 ; ND_TCHECK ( tptr [ 0 ] ) ; nhlen = tptr [ 0 ] ; tlen = nhlen ; tptr ++ ; if ( tlen ) { int nnh = 0 ; ND_PRINT ( ( ndo , \"\\\\n\\\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>nexthop:<S2SV_blank>\" ) ) ; while ( tlen > 0 ) { if ( nnh ++ > 0 ) { ND_PRINT ( ( ndo , \",<S2SV_blank>\" ) ) ; } switch ( af << 8 | safi ) { case ( AFNUM_INET << 8 | SAFNUM_UNICAST ) : case ( AFNUM_INET << 8 | SAFNUM_MULTICAST ) : case ( AFNUM_INET << 8 | SAFNUM_UNIMULTICAST ) : case ( AFNUM_INET << 8 | SAFNUM_LABUNICAST ) : case ( AFNUM_INET << 8 | SAFNUM_RT_ROUTING_INFO ) : case ( AFNUM_INET << 8 | SAFNUM_MULTICAST_VPN ) : case ( AFNUM_INET << 8 | SAFNUM_MDT ) : if ( tlen < ( int ) sizeof ( struct in_addr ) ) { ND_PRINT ( ( ndo , \"invalid<S2SV_blank>len\" ) ) ; tlen = 0 ; } else { ND_TCHECK2 ( tptr [ 0 ] , sizeof ( struct in_addr ) ) ; ND_PRINT ( ( ndo , \"%s\" , ipaddr_string ( ndo , tptr ) ) ) ; tlen -= sizeof ( struct in_addr ) ; tptr += sizeof ( struct in_addr ) ; } break ; case ( AFNUM_INET << 8 | SAFNUM_VPNUNICAST ) : case ( AFNUM_INET << 8 | SAFNUM_VPNMULTICAST ) : case ( AFNUM_INET << 8 | SAFNUM_VPNUNIMULTICAST ) : if ( tlen < ( int ) ( sizeof ( struct in_addr ) + BGP_VPN_RD_LEN ) ) { ND_PRINT ( ( ndo , \"invalid<S2SV_blank>len\" ) ) ; tlen = 0 ; } else { ND_TCHECK2 ( tptr [ 0 ] , sizeof ( struct in_addr ) + BGP_VPN_RD_LEN ) ; ND_PRINT ( ( ndo , \"RD:<S2SV_blank>%s,<S2SV_blank>%s\" , bgp_vpn_rd_print ( ndo , tptr ) , ipaddr_string ( ndo , tptr + BGP_VPN_RD_LEN ) ) ) ; tlen -= ( sizeof ( struct in_addr ) + BGP_VPN_RD_LEN ) ; tptr += ( sizeof ( struct in_addr ) + BGP_VPN_RD_LEN ) ; } break ; case ( AFNUM_INET6 << 8 | SAFNUM_UNICAST ) : case ( AFNUM_INET6 << 8 | SAFNUM_MULTICAST ) : case ( AFNUM_INET6 << 8 | SAFNUM_UNIMULTICAST ) : case ( AFNUM_INET6 << 8 | SAFNUM_LABUNICAST ) : if ( tlen < ( int ) sizeof ( struct in6_addr ) ) { ND_PRINT ( ( ndo , \"invalid<S2SV_blank>len\" ) ) ; tlen = 0 ; } else { ND_TCHECK2 ( tptr [ 0 ] , sizeof ( struct in6_addr ) ) ; ND_PRINT ( ( ndo , \"%s\" , ip6addr_string ( ndo , tptr ) ) ) ; tlen -= sizeof ( struct in6_addr ) ; tptr += sizeof ( struct in6_addr ) ; } break ; case ( AFNUM_INET6 << 8 | SAFNUM_VPNUNICAST ) : case ( AFNUM_INET6 << 8 | SAFNUM_VPNMULTICAST ) : case ( AFNUM_INET6 << 8 | SAFNUM_VPNUNIMULTICAST ) : if ( tlen < ( int ) ( sizeof ( struct in6_addr ) + BGP_VPN_RD_LEN ) ) { ND_PRINT ( ( ndo , \"invalid<S2SV_blank>len\" ) ) ; tlen = 0 ; } else { ND_TCHECK2 ( tptr [ 0 ] , sizeof ( struct in6_addr ) + BGP_VPN_RD_LEN ) ; ND_PRINT ( ( ndo , \"RD:<S2SV_blank>%s,<S2SV_blank>%s\" , bgp_vpn_rd_print ( ndo , tptr ) , ip6addr_string ( ndo , tptr + BGP_VPN_RD_LEN ) ) ) ; tlen -= ( sizeof ( struct in6_addr ) + BGP_VPN_RD_LEN ) ; tptr += ( sizeof ( struct in6_addr ) + BGP_VPN_RD_LEN ) ; } break ; case ( AFNUM_VPLS << 8 | SAFNUM_VPLS ) : case ( AFNUM_L2VPN << 8 | SAFNUM_VPNUNICAST ) : case ( AFNUM_L2VPN << 8 | SAFNUM_VPNMULTICAST ) : case ( AFNUM_L2VPN << 8 | SAFNUM_VPNUNIMULTICAST ) : if ( tlen < ( int ) sizeof ( struct in_addr ) ) { ND_PRINT ( ( ndo , \"invalid<S2SV_blank>len\" ) ) ; tlen = 0 ; } else { ND_TCHECK2 ( tptr [ 0 ] , sizeof ( struct in_addr ) ) ; ND_PRINT ( ( ndo , \"%s\" , ipaddr_string ( ndo , tptr ) ) ) ; tlen -= ( sizeof ( struct in_addr ) ) ; tptr += ( sizeof ( struct in_addr ) ) ; } break ; case ( AFNUM_NSAP << 8 | SAFNUM_UNICAST ) : case ( AFNUM_NSAP << 8 | SAFNUM_MULTICAST ) : case ( AFNUM_NSAP << 8 | SAFNUM_UNIMULTICAST ) : ND_TCHECK2 ( tptr [ 0 ] , tlen ) ; ND_PRINT ( ( ndo , \"%s\" , isonsap_string ( ndo , tptr , tlen ) ) ) ; tptr += tlen ; tlen = 0 ; break ; case ( AFNUM_NSAP << 8 | SAFNUM_VPNUNICAST ) : case ( AFNUM_NSAP << 8 | SAFNUM_VPNMULTICAST ) : case ( AFNUM_NSAP << 8 | SAFNUM_VPNUNIMULTICAST ) : if ( tlen < BGP_VPN_RD_LEN + 1 ) { ND_PRINT ( ( ndo , \"invalid<S2SV_blank>len\" ) ) ; tlen = 0 ; } else { ND_TCHECK2 ( tptr [ 0 ] , tlen ) ; ND_PRINT ( ( ndo , \"RD:<S2SV_blank>%s,<S2SV_blank>%s\" , bgp_vpn_rd_print ( ndo , tptr ) , isonsap_string ( ndo , tptr + BGP_VPN_RD_LEN , tlen - BGP_VPN_RD_LEN ) ) ) ; if ( EXTRACT_32BITS ( tptr + BGP_VPN_RD_LEN ) == 0x47000601 ) ND_PRINT ( ( ndo , \"<S2SV_blank>=<S2SV_blank>%s\" , ipaddr_string ( ndo , tptr + BGP_VPN_RD_LEN + 4 ) ) ) ; else if ( EXTRACT_24BITS ( tptr + BGP_VPN_RD_LEN ) == 0x350000 ) ND_PRINT ( ( ndo , \"<S2SV_blank>=<S2SV_blank>%s\" , ip6addr_string ( ndo , tptr + BGP_VPN_RD_LEN + 3 ) ) ) ; tptr += tlen ; tlen = 0 ; } break ; default : ND_TCHECK2 ( tptr [ 0 ] , tlen ) ; ND_PRINT ( ( ndo , \"no<S2SV_blank>AFI<S2SV_blank>%u/SAFI<S2SV_blank>%u<S2SV_blank>decoder\" , af , safi ) ) ; if ( ndo -> ndo_vflag <= 1 ) print_unknown_data ( ndo , tptr , \"\\\\n\\\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>\" , tlen ) ; tptr += tlen ; tlen = 0 ; goto done ; break ; } } } ND_PRINT ( ( ndo , \",<S2SV_blank>nh-length:<S2SV_blank>%u\" , nhlen ) ) ; tptr += tlen ; ND_TCHECK ( tptr [ 0 ] ) ; snpa = tptr [ 0 ] ; tptr ++ ; if ( snpa ) { ND_PRINT ( ( ndo , \"\\\\n\\\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%u<S2SV_blank>SNPA\" , snpa ) ) ; for ( ; snpa > 0 ; snpa -- ) { ND_TCHECK ( tptr [ 0 ] ) ; ND_PRINT ( ( ndo , \"\\\\n\\\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%d<S2SV_blank>bytes\" , tptr [ 0 ] ) ) ; tptr += tptr [ 0 ] + 1 ; } } else { ND_PRINT ( ( ndo , \",<S2SV_blank>no<S2SV_blank>SNPA\" ) ) ; } while ( tptr < pptr + len ) { switch ( af << 8 | safi ) { case ( AFNUM_INET << 8 | SAFNUM_UNICAST ) : case ( AFNUM_INET << 8 | SAFNUM_MULTICAST ) : case ( AFNUM_INET << 8 | SAFNUM_UNIMULTICAST ) : advance = decode_prefix4 ( ndo , tptr , len , buf , sizeof ( buf ) ) ; if ( advance == - 1 ) ND_PRINT ( ( ndo , \"\\\\n\\\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(illegal<S2SV_blank>prefix<S2SV_blank>length)\" ) ) ; else if ( advance == - 2 ) goto trunc ; else if ( advance == - 3 ) break ; else ND_PRINT ( ( ndo , \"\\\\n\\\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s\" , buf ) ) ; break ; case ( AFNUM_INET << 8 | SAFNUM_LABUNICAST ) : advance = decode_labeled_prefix4 ( ndo , tptr , len , buf , sizeof ( buf ) ) ; if ( advance == - 1 ) ND_PRINT ( ( ndo , \"\\\\n\\\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(illegal<S2SV_blank>prefix<S2SV_blank>length)\" ) ) ; else if ( advance == - 2 ) goto trunc ; else if ( advance == - 3 ) break ; else ND_PRINT ( ( ndo , \"\\\\n\\\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s\" , buf ) ) ; break ; case ( AFNUM_INET << 8 | SAFNUM_VPNUNICAST ) : case ( AFNUM_INET << 8 | SAFNUM_VPNMULTICAST ) : case ( AFNUM_INET << 8 | SAFNUM_VPNUNIMULTICAST ) : advance = decode_labeled_vpn_prefix4 ( ndo , tptr , buf , sizeof ( buf ) ) ; if ( advance == - 1 ) ND_PRINT ( ( ndo , \"\\\\n\\\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(illegal<S2SV_blank>prefix<S2SV_blank>length)\" ) ) ; else if ( advance == - 2 ) goto trunc ; else ND_PRINT ( ( ndo , \"\\\\n\\\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s\" , buf ) ) ; break ; case ( AFNUM_INET << 8 | SAFNUM_RT_ROUTING_INFO ) : advance = decode_rt_routing_info ( ndo , tptr , buf , sizeof ( buf ) ) ; if ( advance == - 1 ) ND_PRINT ( ( ndo , \"\\\\n\\\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(illegal<S2SV_blank>prefix<S2SV_blank>length)\" ) ) ; else if ( advance == - 2 ) goto trunc ; else ND_PRINT ( ( ndo , \"\\\\n\\\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s\" , buf ) ) ; break ; case ( AFNUM_INET << 8 | SAFNUM_MULTICAST_VPN ) : case ( AFNUM_INET6 << 8 | SAFNUM_MULTICAST_VPN ) : advance = decode_multicast_vpn ( ndo , tptr , buf , sizeof ( buf ) ) ; if ( advance == - 1 ) ND_PRINT ( ( ndo , \"\\\\n\\\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(illegal<S2SV_blank>prefix<S2SV_blank>length)\" ) ) ; else if ( advance == - 2 ) goto trunc ; else ND_PRINT ( ( ndo , \"\\\\n\\\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s\" , buf ) ) ; break ; case ( AFNUM_INET << 8 | SAFNUM_MDT ) : advance = decode_mdt_vpn_nlri ( ndo , tptr , buf , sizeof ( buf ) ) ; if ( advance == - 1 ) ND_PRINT ( ( ndo , \"\\\\n\\\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(illegal<S2SV_blank>prefix<S2SV_blank>length)\" ) ) ; else if ( advance == - 2 ) goto trunc ; else ND_PRINT ( ( ndo , \"\\\\n\\\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s\" , buf ) ) ; break ; case ( AFNUM_INET6 << 8 | SAFNUM_UNICAST ) : case ( AFNUM_INET6 << 8 | SAFNUM_MULTICAST ) : case ( AFNUM_INET6 << 8 | SAFNUM_UNIMULTICAST ) : advance = decode_prefix6 ( ndo , tptr , len , buf , sizeof ( buf ) ) ; if ( advance == - 1 ) ND_PRINT ( ( ndo , \"\\\\n\\\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(illegal<S2SV_blank>prefix<S2SV_blank>length)\" ) ) ; else if ( advance == - 2 ) goto trunc ; else if ( advance == - 3 ) break ; else ND_PRINT ( ( ndo , \"\\\\n\\\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s\" , buf ) ) ; break ; case ( AFNUM_INET6 << 8 | SAFNUM_LABUNICAST ) : advance = decode_labeled_prefix6 ( ndo , tptr , len , buf , sizeof ( buf ) ) ; if ( advance == - 1 ) ND_PRINT ( ( ndo , \"\\\\n\\\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(illegal<S2SV_blank>prefix<S2SV_blank>length)\" ) ) ; else if ( advance == - 2 ) goto trunc ; else if ( advance == - 3 ) break ; else ND_PRINT ( ( ndo , \"\\\\n\\\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s\" , buf ) ) ; break ; case ( AFNUM_INET6 << 8 | SAFNUM_VPNUNICAST ) : case ( AFNUM_INET6 << 8 | SAFNUM_VPNMULTICAST ) : case ( AFNUM_INET6 << 8 | SAFNUM_VPNUNIMULTICAST ) : advance = decode_labeled_vpn_prefix6 ( ndo , tptr , buf , sizeof ( buf ) ) ; if ( advance == - 1 ) ND_PRINT ( ( ndo , \"\\\\n\\\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(illegal<S2SV_blank>prefix<S2SV_blank>length)\" ) ) ; else if ( advance == - 2 ) goto trunc ; else ND_PRINT ( ( ndo , \"\\\\n\\\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s\" , buf ) ) ; break ; case ( AFNUM_VPLS << 8 | SAFNUM_VPLS ) : case ( AFNUM_L2VPN << 8 | SAFNUM_VPNUNICAST ) : case ( AFNUM_L2VPN << 8 | SAFNUM_VPNMULTICAST ) : case ( AFNUM_L2VPN << 8 | SAFNUM_VPNUNIMULTICAST ) : advance = decode_labeled_vpn_l2 ( ndo , tptr , buf , sizeof ( buf ) ) ; if ( advance == - 1 ) ND_PRINT ( ( ndo , \"\\\\n\\\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(illegal<S2SV_blank>length)\" ) ) ; else if ( advance == - 2 ) goto trunc ; else ND_PRINT ( ( ndo , \"\\\\n\\\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s\" , buf ) ) ; break ; case ( AFNUM_NSAP << 8 | SAFNUM_UNICAST ) : case ( AFNUM_NSAP << 8 | SAFNUM_MULTICAST ) : case ( AFNUM_NSAP << 8 | SAFNUM_UNIMULTICAST ) : advance = decode_clnp_prefix ( ndo , tptr , buf , sizeof ( buf ) ) ; if ( advance == - 1 ) ND_PRINT ( ( ndo , \"\\\\n\\\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(illegal<S2SV_blank>prefix<S2SV_blank>length)\" ) ) ; else if ( advance == - 2 ) goto trunc ; else ND_PRINT ( ( ndo , \"\\\\n\\\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s\" , buf ) ) ; break ; case ( AFNUM_NSAP << 8 | SAFNUM_VPNUNICAST ) : case ( AFNUM_NSAP << 8 | SAFNUM_VPNMULTICAST ) : case ( AFNUM_NSAP << 8 | SAFNUM_VPNUNIMULTICAST ) : advance = decode_labeled_vpn_clnp_prefix ( ndo , tptr , buf , sizeof ( buf ) ) ; if ( advance == - 1 ) ND_PRINT ( ( ndo , \"\\\\n\\\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(illegal<S2SV_blank>prefix<S2SV_blank>length)\" ) ) ; else if ( advance == - 2 ) goto trunc ; else ND_PRINT ( ( ndo , \"\\\\n\\\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s\" , buf ) ) ; break ; default : ND_TCHECK2 ( * tptr , tlen ) ; ND_PRINT ( ( ndo , \"\\\\n\\\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>no<S2SV_blank>AFI<S2SV_blank>%u<S2SV_blank>/<S2SV_blank>SAFI<S2SV_blank>%u<S2SV_blank>decoder\" , af , safi ) ) ; if ( ndo -> ndo_vflag <= 1 ) print_unknown_data ( ndo , tptr , \"\\\\n\\\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>\" , tlen ) ; advance = 0 ; tptr = pptr + len ; break ; } if ( advance < 0 ) break ; tptr += advance ; } done : break ; case BGPTYPE_MP_UNREACH_NLRI : ND_TCHECK2 ( tptr [ 0 ] , BGP_MP_NLRI_MINSIZE ) ; af = EXTRACT_16BITS ( tptr ) ; safi = tptr [ 2 ] ; ND_PRINT ( ( ndo , \"\\\\n\\\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>AFI:<S2SV_blank>%s<S2SV_blank>(%u),<S2SV_blank>%sSAFI:<S2SV_blank>%s<S2SV_blank>(%u)\" , tok2str ( af_values , \"Unknown<S2SV_blank>AFI\" , af ) , af , ( safi > 128 ) ? \"vendor<S2SV_blank>specific<S2SV_blank>\" : \"\" , tok2str ( bgp_safi_values , \"Unknown<S2SV_blank>SAFI\" , safi ) , safi ) ) ; if ( len == BGP_MP_NLRI_MINSIZE ) ND_PRINT ( ( ndo , \"\\\\n\\\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>End-of-Rib<S2SV_blank>Marker<S2SV_blank>(empty<S2SV_blank>NLRI)\" ) ) ; tptr += 3 ; while ( tptr < pptr + len ) { switch ( af << 8 | safi ) { case ( AFNUM_INET << 8 | SAFNUM_UNICAST ) : case ( AFNUM_INET << 8 | SAFNUM_MULTICAST ) : case ( AFNUM_INET << 8 | SAFNUM_UNIMULTICAST ) : advance = decode_prefix4 ( ndo , tptr , len , buf , sizeof ( buf ) ) ; if ( advance == - 1 ) ND_PRINT ( ( ndo , \"\\\\n\\\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(illegal<S2SV_blank>prefix<S2SV_blank>length)\" ) ) ; else if ( advance == - 2 ) goto trunc ; else if ( advance == - 3 ) break ; else ND_PRINT ( ( ndo , \"\\\\n\\\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s\" , buf ) ) ; break ; case ( AFNUM_INET << 8 | SAFNUM_LABUNICAST ) : advance = decode_labeled_prefix4 ( ndo , tptr , len , buf , sizeof ( buf ) ) ; if ( advance == - 1 ) ND_PRINT ( ( ndo , \"\\\\n\\\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(illegal<S2SV_blank>prefix<S2SV_blank>length)\" ) ) ; else if ( advance == - 2 ) goto trunc ; else if ( advance == - 3 ) break ; else ND_PRINT ( ( ndo , \"\\\\n\\\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s\" , buf ) ) ; break ; case ( AFNUM_INET << 8 | SAFNUM_VPNUNICAST ) : case ( AFNUM_INET << 8 | SAFNUM_VPNMULTICAST ) : case ( AFNUM_INET << 8 | SAFNUM_VPNUNIMULTICAST ) : advance = decode_labeled_vpn_prefix4 ( ndo , tptr , buf , sizeof ( buf ) ) ; if ( advance == - 1 ) ND_PRINT ( ( ndo , \"\\\\n\\\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(illegal<S2SV_blank>prefix<S2SV_blank>length)\" ) ) ; else if ( advance == - 2 ) goto trunc ; else ND_PRINT ( ( ndo , \"\\\\n\\\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s\" , buf ) ) ; break ; case ( AFNUM_INET6 << 8 | SAFNUM_UNICAST ) : case ( AFNUM_INET6 << 8 | SAFNUM_MULTICAST ) : case ( AFNUM_INET6 << 8 | SAFNUM_UNIMULTICAST ) : advance = decode_prefix6 ( ndo , tptr , len , buf , sizeof ( buf ) ) ; if ( advance == - 1 ) ND_PRINT ( ( ndo , \"\\\\n\\\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(illegal<S2SV_blank>prefix<S2SV_blank>length)\" ) ) ; else if ( advance == - 2 ) goto trunc ; else if ( advance == - 3 ) break ; else ND_PRINT ( ( ndo , \"\\\\n\\\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s\" , buf ) ) ; break ; case ( AFNUM_INET6 << 8 | SAFNUM_LABUNICAST ) : advance = decode_labeled_prefix6 ( ndo , tptr , len , buf , sizeof ( buf ) ) ; if ( advance == - 1 ) ND_PRINT ( ( ndo , \"\\\\n\\\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(illegal<S2SV_blank>prefix<S2SV_blank>length)\" ) ) ; else if ( advance == - 2 ) goto trunc ; else if ( advance == - 3 ) break ; else ND_PRINT ( ( ndo , \"\\\\n\\\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s\" , buf ) ) ; break ; case ( AFNUM_INET6 << 8 | SAFNUM_VPNUNICAST ) : case ( AFNUM_INET6 << 8 | SAFNUM_VPNMULTICAST ) : case ( AFNUM_INET6 << 8 | SAFNUM_VPNUNIMULTICAST ) : advance = decode_labeled_vpn_prefix6 ( ndo , tptr , buf , sizeof ( buf ) ) ; if ( advance == - 1 ) ND_PRINT ( ( ndo , \"\\\\n\\\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(illegal<S2SV_blank>prefix<S2SV_blank>length)\" ) ) ; else if ( advance == - 2 ) goto trunc ; else ND_PRINT ( ( ndo , \"\\\\n\\\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s\" , buf ) ) ; break ; case ( AFNUM_VPLS << 8 | SAFNUM_VPLS ) : case ( AFNUM_L2VPN << 8 | SAFNUM_VPNUNICAST ) : case ( AFNUM_L2VPN << 8 | SAFNUM_VPNMULTICAST ) : case ( AFNUM_L2VPN << 8 | SAFNUM_VPNUNIMULTICAST ) : advance = decode_labeled_vpn_l2 ( ndo , tptr , buf , sizeof ( buf ) ) ; if ( advance == - 1 ) ND_PRINT ( ( ndo , \"\\\\n\\\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(illegal<S2SV_blank>length)\" ) ) ; else if ( advance == - 2 ) goto trunc ; else ND_PRINT ( ( ndo , \"\\\\n\\\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s\" , buf ) ) ; break ; case ( AFNUM_NSAP << 8 | SAFNUM_UNICAST ) : case ( AFNUM_NSAP << 8 | SAFNUM_MULTICAST ) : case ( AFNUM_NSAP << 8 | SAFNUM_UNIMULTICAST ) : advance = decode_clnp_prefix ( ndo , tptr , buf , sizeof ( buf ) ) ; if ( advance == - 1 ) ND_PRINT ( ( ndo , \"\\\\n\\\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(illegal<S2SV_blank>prefix<S2SV_blank>length)\" ) ) ; else if ( advance == - 2 ) goto trunc ; else ND_PRINT ( ( ndo , \"\\\\n\\\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s\" , buf ) ) ; break ; case ( AFNUM_NSAP << 8 | SAFNUM_VPNUNICAST ) : case ( AFNUM_NSAP << 8 | SAFNUM_VPNMULTICAST ) : case ( AFNUM_NSAP << 8 | SAFNUM_VPNUNIMULTICAST ) : advance = decode_labeled_vpn_clnp_prefix ( ndo , tptr , buf , sizeof ( buf ) ) ; if ( advance == - 1 ) ND_PRINT ( ( ndo , \"\\\\n\\\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(illegal<S2SV_blank>prefix<S2SV_blank>length)\" ) ) ; else if ( advance == - 2 ) goto trunc ; else ND_PRINT ( ( ndo , \"\\\\n\\\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s\" , buf ) ) ; break ; case ( AFNUM_INET << 8 | SAFNUM_MDT ) : advance = decode_mdt_vpn_nlri ( ndo , tptr , buf , sizeof ( buf ) ) ; if ( advance == - 1 ) ND_PRINT ( ( ndo , \"\\\\n\\\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(illegal<S2SV_blank>prefix<S2SV_blank>length)\" ) ) ; else if ( advance == - 2 ) goto trunc ; else ND_PRINT ( ( ndo , \"\\\\n\\\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s\" , buf ) ) ; break ; case ( AFNUM_INET << 8 | SAFNUM_MULTICAST_VPN ) : case ( AFNUM_INET6 << 8 | SAFNUM_MULTICAST_VPN ) : advance = decode_multicast_vpn ( ndo , tptr , buf , sizeof ( buf ) ) ; if ( advance == - 1 ) ND_PRINT ( ( ndo , \"\\\\n\\\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(illegal<S2SV_blank>prefix<S2SV_blank>length)\" ) ) ; else if ( advance == - 2 ) goto trunc ; else ND_PRINT ( ( ndo , \"\\\\n\\\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s\" , buf ) ) ; break ; default : ND_TCHECK2 ( * ( tptr - 3 ) , tlen ) ; ND_PRINT ( ( ndo , \"no<S2SV_blank>AFI<S2SV_blank>%u<S2SV_blank>/<S2SV_blank>SAFI<S2SV_blank>%u<S2SV_blank>decoder\" , af , safi ) ) ; if ( ndo -> ndo_vflag <= 1 ) print_unknown_data ( ndo , tptr - 3 , \"\\\\n\\\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>\" , tlen ) ; advance = 0 ; tptr = pptr + len ; break ; } if ( advance < 0 ) break ; tptr += advance ; } break ; case BGPTYPE_EXTD_COMMUNITIES : if ( len % 8 ) { ND_PRINT ( ( ndo , \"invalid<S2SV_blank>len\" ) ) ; break ; } while ( tlen > 0 ) { uint16_t extd_comm ; ND_TCHECK2 ( tptr [ 0 ] , 2 ) ; extd_comm = EXTRACT_16BITS ( tptr ) ; ND_PRINT ( ( ndo , \"\\\\n\\\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s<S2SV_blank>(0x%04x),<S2SV_blank>Flags<S2SV_blank>[%s]\" , tok2str ( bgp_extd_comm_subtype_values , \"unknown<S2SV_blank>extd<S2SV_blank>community<S2SV_blank>typecode\" , extd_comm ) , extd_comm , bittok2str ( bgp_extd_comm_flag_values , \"none\" , extd_comm ) ) ) ; ND_TCHECK2 ( * ( tptr + 2 ) , 6 ) ; switch ( extd_comm ) { case BGP_EXT_COM_RT_0 : case BGP_EXT_COM_RO_0 : case BGP_EXT_COM_L2VPN_RT_0 : ND_PRINT ( ( ndo , \":<S2SV_blank>%u:%u<S2SV_blank>(=<S2SV_blank>%s)\" , EXTRACT_16BITS ( tptr + 2 ) , EXTRACT_32BITS ( tptr + 4 ) , ipaddr_string ( ndo , tptr + 4 ) ) ) ; break ; case BGP_EXT_COM_RT_1 : case BGP_EXT_COM_RO_1 : case BGP_EXT_COM_L2VPN_RT_1 : case BGP_EXT_COM_VRF_RT_IMP : ND_PRINT ( ( ndo , \":<S2SV_blank>%s:%u\" , ipaddr_string ( ndo , tptr + 2 ) , EXTRACT_16BITS ( tptr + 6 ) ) ) ; break ; case BGP_EXT_COM_RT_2 : case BGP_EXT_COM_RO_2 : ND_PRINT ( ( ndo , \":<S2SV_blank>%s:%u\" , as_printf ( ndo , astostr , sizeof ( astostr ) , EXTRACT_32BITS ( tptr + 2 ) ) , EXTRACT_16BITS ( tptr + 6 ) ) ) ; break ; case BGP_EXT_COM_LINKBAND : bw . i = EXTRACT_32BITS ( tptr + 2 ) ; ND_PRINT ( ( ndo , \":<S2SV_blank>bandwidth:<S2SV_blank>%.3f<S2SV_blank>Mbps\" , bw . f * 8 / 1000000 ) ) ; break ; case BGP_EXT_COM_VPN_ORIGIN : case BGP_EXT_COM_VPN_ORIGIN2 : case BGP_EXT_COM_VPN_ORIGIN3 : case BGP_EXT_COM_VPN_ORIGIN4 : case BGP_EXT_COM_OSPF_RID : case BGP_EXT_COM_OSPF_RID2 : ND_PRINT ( ( ndo , \"%s\" , ipaddr_string ( ndo , tptr + 2 ) ) ) ; break ; case BGP_EXT_COM_OSPF_RTYPE : case BGP_EXT_COM_OSPF_RTYPE2 : ND_PRINT ( ( ndo , \":<S2SV_blank>area:%s,<S2SV_blank>router-type:%s,<S2SV_blank>metric-type:%s%s\" , ipaddr_string ( ndo , tptr + 2 ) , tok2str ( bgp_extd_comm_ospf_rtype_values , \"unknown<S2SV_blank>(0x%02x)\" , * ( tptr + 6 ) ) , ( * ( tptr + 7 ) & BGP_OSPF_RTYPE_METRIC_TYPE ) ? \"E2\" : \"\" , ( ( * ( tptr + 6 ) == BGP_OSPF_RTYPE_EXT ) || ( * ( tptr + 6 ) == BGP_OSPF_RTYPE_NSSA ) ) ? \"E1\" : \"\" ) ) ; break ; case BGP_EXT_COM_L2INFO : ND_PRINT ( ( ndo , \":<S2SV_blank>%s<S2SV_blank>Control<S2SV_blank>Flags<S2SV_blank>[0x%02x]:MTU<S2SV_blank>%u\" , tok2str ( l2vpn_encaps_values , \"unknown<S2SV_blank>encaps\" , * ( tptr + 2 ) ) , * ( tptr + 3 ) , EXTRACT_16BITS ( tptr + 4 ) ) ) ; break ; case BGP_EXT_COM_SOURCE_AS : ND_PRINT ( ( ndo , \":<S2SV_blank>AS<S2SV_blank>%u\" , EXTRACT_16BITS ( tptr + 2 ) ) ) ; break ; default : ND_TCHECK2 ( * tptr , 8 ) ; print_unknown_data ( ndo , tptr , \"\\\\n\\\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>\" , 8 ) ; break ; } tlen -= 8 ; tptr += 8 ; } break ; case BGPTYPE_PMSI_TUNNEL : { uint8_t tunnel_type , flags ; <S2SV_StartBug> tunnel_type = * ( tptr + 1 ) ; <S2SV_EndBug> flags = * tptr ; <S2SV_StartBug> tlen = len ; <S2SV_EndBug> ND_TCHECK2 ( tptr [ 0 ] , 5 ) ; ND_PRINT ( ( ndo , \"\\\\n\\\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Tunnel-type<S2SV_blank>%s<S2SV_blank>(%u),<S2SV_blank>Flags<S2SV_blank>[%s],<S2SV_blank>MPLS<S2SV_blank>Label<S2SV_blank>%u\" , tok2str ( bgp_pmsi_tunnel_values , \"Unknown\" , tunnel_type ) , tunnel_type , bittok2str ( bgp_pmsi_flag_values , \"none\" , flags ) , EXTRACT_24BITS ( tptr + 2 ) >> 4 ) ) ; tptr += 5 ; tlen -= 5 ; switch ( tunnel_type ) { case BGP_PMSI_TUNNEL_PIM_SM : case BGP_PMSI_TUNNEL_PIM_BIDIR : ND_TCHECK2 ( tptr [ 0 ] , 8 ) ; ND_PRINT ( ( ndo , \"\\\\n\\\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Sender<S2SV_blank>%s,<S2SV_blank>P-Group<S2SV_blank>%s\" , ipaddr_string ( ndo , tptr ) , ipaddr_string ( ndo , tptr + 4 ) ) ) ; break ; case BGP_PMSI_TUNNEL_PIM_SSM : ND_TCHECK2 ( tptr [ 0 ] , 8 ) ; ND_PRINT ( ( ndo , \"\\\\n\\\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Root-Node<S2SV_blank>%s,<S2SV_blank>P-Group<S2SV_blank>%s\" , ipaddr_string ( ndo , tptr ) , ipaddr_string ( ndo , tptr + 4 ) ) ) ; break ; case BGP_PMSI_TUNNEL_INGRESS : ND_TCHECK2 ( tptr [ 0 ] , 4 ) ; ND_PRINT ( ( ndo , \"\\\\n\\\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Tunnel-Endpoint<S2SV_blank>%s\" , ipaddr_string ( ndo , tptr ) ) ) ; break ; case BGP_PMSI_TUNNEL_LDP_P2MP : case BGP_PMSI_TUNNEL_LDP_MP2MP : ND_TCHECK2 ( tptr [ 0 ] , 8 ) ; ND_PRINT ( ( ndo , \"\\\\n\\\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Root-Node<S2SV_blank>%s,<S2SV_blank>LSP-ID<S2SV_blank>0x%08x\" , ipaddr_string ( ndo , tptr ) , EXTRACT_32BITS ( tptr + 4 ) ) ) ; break ; case BGP_PMSI_TUNNEL_RSVP_P2MP : ND_TCHECK2 ( tptr [ 0 ] , 8 ) ; ND_PRINT ( ( ndo , \"\\\\n\\\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Extended-Tunnel-ID<S2SV_blank>%s,<S2SV_blank>P2MP-ID<S2SV_blank>0x%08x\" , ipaddr_string ( ndo , tptr ) , EXTRACT_32BITS ( tptr + 4 ) ) ) ; break ; default : if ( ndo -> ndo_vflag <= 1 ) { print_unknown_data ( ndo , tptr , \"\\\\n\\\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>\" , tlen ) ; } } break ; } case BGPTYPE_AIGP : { uint8_t type ; uint16_t length ; tlen = len ; while ( tlen >= 3 ) { ND_TCHECK2 ( tptr [ 0 ] , 3 ) ; type = * tptr ; length = EXTRACT_16BITS ( tptr + 1 ) ; tptr += 3 ; tlen -= 3 ; ND_PRINT ( ( ndo , \"\\\\n\\\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s<S2SV_blank>TLV<S2SV_blank>(%u),<S2SV_blank>length<S2SV_blank>%u\" , tok2str ( bgp_aigp_values , \"Unknown\" , type ) , type , length ) ) ; if ( length < 3 ) goto trunc ; length -= 3 ; ND_TCHECK2 ( tptr [ 3 ] , length ) ; switch ( type ) { case BGP_AIGP_TLV : if ( length < 8 ) goto trunc ; ND_PRINT ( ( ndo , \",<S2SV_blank>metric<S2SV_blank>%\" PRIu64 , EXTRACT_64BITS ( tptr ) ) ) ; break ; default : if ( ndo -> ndo_vflag <= 1 ) { print_unknown_data ( ndo , tptr , \"\\\\n\\\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>\" , length ) ; } } tptr += length ; tlen -= length ; } break ; } case BGPTYPE_ATTR_SET : ND_TCHECK2 ( tptr [ 0 ] , 4 ) ; if ( len < 4 ) goto trunc ; ND_PRINT ( ( ndo , \"\\\\n\\\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Origin<S2SV_blank>AS:<S2SV_blank>%s\" , as_printf ( ndo , astostr , sizeof ( astostr ) , EXTRACT_32BITS ( tptr ) ) ) ) ; tptr += 4 ; len -= 4 ; while ( len ) { u_int aflags , alenlen , alen ; ND_TCHECK2 ( tptr [ 0 ] , 2 ) ; if ( len < 2 ) goto trunc ; aflags = * tptr ; atype = * ( tptr + 1 ) ; tptr += 2 ; len -= 2 ; alenlen = bgp_attr_lenlen ( aflags , tptr ) ; ND_TCHECK2 ( tptr [ 0 ] , alenlen ) ; if ( len < alenlen ) goto trunc ; alen = bgp_attr_len ( aflags , tptr ) ; tptr += alenlen ; len -= alenlen ; ND_PRINT ( ( ndo , \"\\\\n\\\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s<S2SV_blank>(%u),<S2SV_blank>length:<S2SV_blank>%u\" , tok2str ( bgp_attr_values , \"Unknown<S2SV_blank>Attribute\" , atype ) , atype , alen ) ) ; if ( aflags ) { ND_PRINT ( ( ndo , \",<S2SV_blank>Flags<S2SV_blank>[%s%s%s%s\" , aflags & 0x80 ? \"O\" : \"\" , aflags & 0x40 ? \"T\" : \"\" , aflags & 0x20 ? \"P\" : \"\" , aflags & 0x10 ? \"E\" : \"\" ) ) ; if ( aflags & 0xf ) ND_PRINT ( ( ndo , \"+%x\" , aflags & 0xf ) ) ; ND_PRINT ( ( ndo , \"]:<S2SV_blank>\" ) ) ; } if ( ! bgp_attr_print ( ndo , atype , tptr , alen ) ) return 0 ; tptr += alen ; len -= alen ; } break ; case BGPTYPE_LARGE_COMMUNITY : if ( len == 0 || len % 12 ) { ND_PRINT ( ( ndo , \"invalid<S2SV_blank>len\" ) ) ; break ; } ND_PRINT ( ( ndo , \"\\\\n\\\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>\" ) ) ; while ( len > 0 ) { ND_TCHECK2 ( * tptr , 12 ) ; ND_PRINT ( ( ndo , \"%u:%u:%u%s\" , EXTRACT_32BITS ( tptr ) , EXTRACT_32BITS ( tptr + 4 ) , EXTRACT_32BITS ( tptr + 8 ) , ( len > 12 ) ? \",<S2SV_blank>\" : \"\" ) ) ; tptr += 12 ; len -= 12 ; } break ; default : ND_TCHECK2 ( * pptr , len ) ; ND_PRINT ( ( ndo , \"\\\\n\\\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>no<S2SV_blank>Attribute<S2SV_blank>%u<S2SV_blank>decoder\" , atype ) ) ; if ( ndo -> ndo_vflag <= 1 ) print_unknown_data ( ndo , pptr , \"\\\\n\\\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>\" , len ) ; break ; } if ( ndo -> ndo_vflag > 1 && len ) { ND_TCHECK2 ( * pptr , len ) ; print_unknown_data ( ndo , pptr , \"\\\\n\\\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>\" , len ) ; } return 1 ; trunc : return 0 ; }\n","target":"<S2SV_ModStart> , flags ; ND_TCHECK2 ( tptr [ 0 ] , 5 ) ; <S2SV_ModStart> tlen = len <S2SV_ModEnd> ; ND_PRINT (\n","project_and_commit_id":"the-tcpdump-group@tcpdump/d10a0f980fe8f9407ab1ffbd612641433ebe175e","cve_id":"CVE-2017-13046","original_address":"https://github.com/the-tcpdump-group/tcpdump/commit/d10a0f980fe8f9407ab1ffbd612641433ebe175e","time":"2017-09-14T06:29Z"},
	{"Unnamed: 0":4190,"cwe_id":"CWE-119","source":"CWE-119 static vpx_image_t * encoder_get_preview ( vpx_codec_alg_priv_t * ctx ) { YV12_BUFFER_CONFIG sd ; <S2SV_StartBug> vp9_ppflags_t flags = { 0 } ; <S2SV_EndBug> if ( ctx -> preview_ppcfg . post_proc_flag ) { flags . post_proc_flag = ctx -> preview_ppcfg . post_proc_flag ; flags . deblocking_level = ctx -> preview_ppcfg . deblocking_level ; flags . noise_level = ctx -> preview_ppcfg . noise_level ; } if ( vp9_get_preview_raw_frame ( ctx -> cpi , & sd , & flags ) == 0 ) { yuvconfig2image ( & ctx -> preview_img , & sd , NULL ) ; return & ctx -> preview_img ; } else { return NULL ; } }\n","target":"<S2SV_ModStart> ; vp9_ppflags_t flags ; vp9_zero ( flags ) <S2SV_ModEnd> ; if (\n","project_and_commit_id":"external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426","cve_id":"CVE-2016-1621","original_address":"https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426","time":"2016-03-12T21:59Z"},
	{"Unnamed: 0":6390,"cwe_id":"CWE-264","source":"CWE-264 static ssize_t perf_read ( struct file * file , char __user * buf , size_t count , loff_t * ppos ) { struct perf_event * event = file -> private_data ; <S2SV_StartBug> return perf_read_hw ( event , buf , count ) ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug>\n","target":"<S2SV_ModStart> -> private_data ; struct perf_event_context * ctx ; int ret ; ctx = perf_event_ctx_lock ( event ) ; ret = <S2SV_ModEnd> perf_read_hw ( event <S2SV_ModStart> count ) ; perf_event_ctx_unlock ( event , ctx ) ; return ret ;\n","project_and_commit_id":"torvalds@linux/f63a8daa5812afef4f06c962351687e1ff9ccb2b","cve_id":"CVE-2016-6787","original_address":"https://github.com/torvalds/linux/commit/f63a8daa5812afef4f06c962351687e1ff9ccb2b","time":"2016-12-28T07:59Z"},
	{"Unnamed: 0":3111,"cwe_id":"CWE-119","source":"CWE-119 static int host_start ( struct ci13xxx * ci ) { struct usb_hcd * hcd ; struct ehci_hcd * ehci ; int ret ; if ( usb_disabled ( ) ) return - ENODEV ; hcd = usb_create_hcd ( & ci_ehci_hc_driver , ci -> dev , dev_name ( ci -> dev ) ) ; if ( ! hcd ) return - ENOMEM ; dev_set_drvdata ( ci -> dev , ci ) ; hcd -> rsrc_start = ci -> hw_bank . phys ; hcd -> rsrc_len = ci -> hw_bank . size ; hcd -> regs = ci -> hw_bank . abs ; hcd -> has_tt = 1 ; hcd -> power_budget = ci -> platdata -> power_budget ; hcd -> phy = ci -> transceiver ; ehci = hcd_to_ehci ( hcd ) ; ehci -> caps = ci -> hw_bank . cap ; ehci -> has_hostpc = ci -> hw_bank . lpm ; ret = usb_add_hcd ( hcd , 0 , 0 ) ; if ( ret ) usb_put_hcd ( hcd ) ; else ci -> hcd = hcd ; <S2SV_StartBug> return ret ; <S2SV_EndBug> }\n","target":"<S2SV_ModStart> = hcd ; if ( ci -> platdata -> flags & CI13XXX_DISABLE_STREAMING ) hw_write ( ci , OP_USBMODE , USBMODE_CI_SDIS , USBMODE_CI_SDIS ) ;\n","project_and_commit_id":"torvalds@linux/929473ea05db455ad88cdc081f2adc556b8dc48f","cve_id":"CVE-2013-2058","original_address":"https://github.com/torvalds/linux/commit/929473ea05db455ad88cdc081f2adc556b8dc48f","time":"2013-11-04T15:55Z"},
	{"Unnamed: 0":2171,"cwe_id":"CWE-772","source":"CWE-772 int hsr_dev_finalize ( struct net_device * hsr_dev , struct net_device * slave [ 2 ] , unsigned char multicast_spec , u8 protocol_version ) { struct hsr_priv * hsr ; struct hsr_port * port ; int res ; hsr = netdev_priv ( hsr_dev ) ; INIT_LIST_HEAD ( & hsr -> ports ) ; INIT_LIST_HEAD ( & hsr -> node_db ) ; INIT_LIST_HEAD ( & hsr -> self_node_db ) ; ether_addr_copy ( hsr_dev -> dev_addr , slave [ 0 ] -> dev_addr ) ; res = hsr_create_self_node ( & hsr -> self_node_db , hsr_dev -> dev_addr , slave [ 1 ] -> dev_addr ) ; if ( res < 0 ) return res ; spin_lock_init ( & hsr -> seqnr_lock ) ; hsr -> sequence_nr = HSR_SEQNR_START ; hsr -> sup_sequence_nr = HSR_SUP_SEQNR_START ; timer_setup ( & hsr -> announce_timer , hsr_announce , 0 ) ; timer_setup ( & hsr -> prune_timer , hsr_prune_nodes , 0 ) ; ether_addr_copy ( hsr -> sup_multicast_addr , def_multicast_addr ) ; hsr -> sup_multicast_addr [ ETH_ALEN - 1 ] = multicast_spec ; hsr -> protVersion = protocol_version ; netif_carrier_off ( hsr_dev ) ; res = hsr_add_port ( hsr , hsr_dev , HSR_PT_MASTER ) ; if ( res ) <S2SV_StartBug> return res ; <S2SV_EndBug> res = register_netdevice ( hsr_dev ) ; if ( res ) goto fail ; res = hsr_add_port ( hsr , slave [ 0 ] , HSR_PT_SLAVE_A ) ; if ( res ) goto fail ; res = hsr_add_port ( hsr , slave [ 1 ] , HSR_PT_SLAVE_B ) ; if ( res ) goto fail ; mod_timer ( & hsr -> prune_timer , jiffies + msecs_to_jiffies ( PRUNE_PERIOD ) ) ; return 0 ; fail : hsr_for_each_port ( hsr , port ) hsr_del_port ( port ) ; <S2SV_StartBug> return res ; <S2SV_EndBug> }\n","target":"<S2SV_ModStart> ( res ) goto err_add_port <S2SV_ModEnd> ; res = <S2SV_ModStart> port ) ; err_add_port : hsr_del_node ( & hsr -> self_node_db ) ;\n","project_and_commit_id":"torvalds@linux/6caabe7f197d3466d238f70915d65301f1716626","cve_id":"CVE-2019-16995","original_address":"https://github.com/torvalds/linux/commit/6caabe7f197d3466d238f70915d65301f1716626","time":"2019-09-30T13:15Z"},
	{"Unnamed: 0":201,"cwe_id":"CWE-119","source":"CWE-119 <S2SV_StartBug> static void <S2SV_EndBug> horDiff32 ( TIFF * tif , uint8 * cp0 , tmsize_t cc ) { TIFFPredictorState * sp = PredictorState ( tif ) ; tmsize_t stride = sp -> stride ; uint32 * wp = ( uint32 * ) cp0 ; tmsize_t wc = cc / 4 ; <S2SV_StartBug> assert ( ( cc % ( 4 * stride ) ) == 0 ) ; <S2SV_EndBug> if ( wc > stride ) { wc -= stride ; wp += wc - 1 ; do { REPEAT4 ( stride , wp [ stride ] -= wp [ 0 ] ; wp -- ) wc -= stride ; } while ( wc > 0 ) ; } <S2SV_StartBug> } <S2SV_EndBug>\n","target":"<S2SV_ModStart> <S2SV_null> <S2SV_null> static int <S2SV_ModEnd> horDiff32 ( TIFF <S2SV_ModStart> / 4 ; if <S2SV_ModEnd> ( ( cc <S2SV_ModStart> stride ) ) != 0 ) { TIFFErrorExt ( tif -> tif_clientdata , \"horDiff32\" , \"%s\" , \"(cc%(4*stride))!=0\" ) ; return 0 ; } <S2SV_ModEnd> if ( wc <S2SV_ModStart> ) ; } return 1 ;\n","project_and_commit_id":"vadz@libtiff/3ca657a8793dd011bf869695d72ad31c779c3cc1","cve_id":"CVE-2016-9535","original_address":"https://github.com/vadz/libtiff/commit/3ca657a8793dd011bf869695d72ad31c779c3cc1","time":"2016-11-22T19:59Z"},
	{"Unnamed: 0":2765,"cwe_id":"CWE-20","source":"CWE-20 static struct dst_entry * ip6_sk_dst_check ( struct sock * sk , struct dst_entry * dst , const struct flowi6 * fl6 ) { struct ipv6_pinfo * np = inet6_sk ( sk ) ; <S2SV_StartBug> struct rt6_info * rt = ( struct rt6_info * ) dst ; <S2SV_EndBug> if ( ! dst ) <S2SV_StartBug> goto out ; <S2SV_EndBug> if ( ip6_rt_check ( & rt -> rt6i_dst , & fl6 -> daddr , np -> daddr_cache ) || # ifdef CONFIG_IPV6_SUBTREES ip6_rt_check ( & rt -> rt6i_src , & fl6 -> saddr , np -> saddr_cache ) || # endif ( fl6 -> flowi6_oif && fl6 -> flowi6_oif != dst -> dev -> ifindex ) ) { dst_release ( dst ) ; dst = NULL ; } out : return dst ; }\n","target":"<S2SV_ModStart> rt6_info * rt <S2SV_ModEnd> ; if ( <S2SV_ModStart> ) goto out ; if ( dst -> ops -> family != AF_INET6 ) { dst_release ( dst ) ; return NULL ; } rt = ( struct rt6_info * ) dst\n","project_and_commit_id":"torvalds@linux/a963a37d384d71ad43b3e9e79d68d42fbe0901f3","cve_id":"CVE-2013-2232","original_address":"https://github.com/torvalds/linux/commit/a963a37d384d71ad43b3e9e79d68d42fbe0901f3","time":"2013-07-04T21:55Z"},
	{"Unnamed: 0":3932,"cwe_id":"CWE-000","source":"CWE-000 static int iwch_l2t_send ( struct t3cdev * tdev , struct sk_buff * skb , struct l2t_entry * l2e ) { int error = 0 ; struct cxio_rdev * rdev ; rdev = ( struct cxio_rdev * ) tdev -> ulp ; if ( cxio_fatal_error ( rdev ) ) { kfree_skb ( skb ) ; return - EIO ; } error = l2t_send ( tdev , skb , l2e ) ; if ( error < 0 ) kfree_skb ( skb ) ; <S2SV_StartBug> return error ; <S2SV_EndBug> }\n","target":"<S2SV_ModStart> ; return error < 0 ? error : 0\n","project_and_commit_id":"torvalds@linux/67f1aee6f45059fd6b0f5b0ecb2c97ad0451f6b3","cve_id":"CVE-2015-8812","original_address":"https://github.com/torvalds/linux/commit/67f1aee6f45059fd6b0f5b0ecb2c97ad0451f6b3","time":"2016-04-27T17:59Z"},
	{"Unnamed: 0":6058,"cwe_id":"CWE-476","source":"CWE-476 static int f2fs_set_data_page_dirty ( struct page * page ) { <S2SV_StartBug> struct address_space * mapping = page -> mapping ; <S2SV_EndBug> <S2SV_StartBug> struct inode * inode = mapping -> host ; <S2SV_EndBug> trace_f2fs_set_page_dirty ( page , DATA ) ; if ( ! PageUptodate ( page ) ) <S2SV_StartBug> SetPageUptodate ( page ) ; <S2SV_EndBug> if ( f2fs_is_atomic_file ( inode ) && ! f2fs_is_commit_atomic_write ( inode ) ) { if ( ! IS_ATOMIC_WRITTEN_PAGE ( page ) ) { f2fs_register_inmem_page ( inode , page ) ; return 1 ; } return 0 ; } if ( ! PageDirty ( page ) ) { __set_page_dirty_nobuffers ( page ) ; f2fs_update_dirty_page ( inode , page ) ; return 1 ; } return 0 ; }\n","target":"<S2SV_ModStart> ) { struct <S2SV_ModEnd> inode * inode <S2SV_ModStart> * inode = page_file_mapping ( page ) <S2SV_ModEnd> -> host ; <S2SV_ModStart> ) ) SetPageUptodate ( page ) ; if ( PageSwapCache ( page ) ) return __set_page_dirty_nobuffers\n","project_and_commit_id":"torvalds@linux/4969c06a0d83c9c3dc50b8efcdc8eeedfce896f6","cve_id":"CVE-2019-19815","original_address":"https://github.com/torvalds/linux/commit/4969c06a0d83c9c3dc50b8efcdc8eeedfce896f6","time":"2019-12-17T07:15Z"},
	{"Unnamed: 0":2574,"cwe_id":"CWE-125","source":"CWE-125 static inline size_t GetPSDRowSize ( Image * image ) { if ( image -> depth == 1 ) <S2SV_StartBug> return ( ( image -> columns + 7 ) / 8 ) ; <S2SV_EndBug> else return ( image -> columns * GetPSDPacketSize ( image ) ) ; }\n","target":"<S2SV_ModStart> return ( ( ( <S2SV_ModStart> ) / 8 ) * GetPSDPacketSize ( image )\n","project_and_commit_id":"ImageMagick@ImageMagick/5f16640725b1225e6337c62526e6577f0f88edb8","cve_id":"CVE-2016-7525","original_address":"https://github.com/ImageMagick/ImageMagick/commit/5f16640725b1225e6337c62526e6577f0f88edb8","time":"2017-04-20T18:59Z"},
	{"Unnamed: 0":5202,"cwe_id":"CWE-119","source":"CWE-119 static int key_notify_sa_flush ( const struct km_event * c ) { struct sk_buff * skb ; struct sadb_msg * hdr ; skb = alloc_skb ( sizeof ( struct sadb_msg ) + 16 , GFP_ATOMIC ) ; if ( ! skb ) return - ENOBUFS ; hdr = ( struct sadb_msg * ) skb_put ( skb , sizeof ( struct sadb_msg ) ) ; hdr -> sadb_msg_satype = pfkey_proto2satype ( c -> data . proto ) ; hdr -> sadb_msg_type = SADB_FLUSH ; hdr -> sadb_msg_seq = c -> seq ; hdr -> sadb_msg_pid = c -> portid ; hdr -> sadb_msg_version = PF_KEY_V2 ; hdr -> sadb_msg_errno = ( uint8_t ) 0 ; hdr -> sadb_msg_len = ( sizeof ( struct sadb_msg ) / sizeof ( uint64_t ) ) ; <S2SV_StartBug> pfkey_broadcast ( skb , GFP_ATOMIC , BROADCAST_ALL , NULL , c -> net ) ; <S2SV_EndBug> return 0 ; }\n","target":"<S2SV_ModStart> ) ) ; hdr -> sadb_msg_reserved = 0 ;\n","project_and_commit_id":"torvalds@linux/a5cc68f3d63306d0d288f31edfc2ae6ef8ecd887","cve_id":"CVE-2013-2234","original_address":"https://github.com/torvalds/linux/commit/a5cc68f3d63306d0d288f31edfc2ae6ef8ecd887","time":"2013-07-04T21:55Z"},
	{"Unnamed: 0":1221,"cwe_id":"CWE-755","source":"CWE-755 struct dst_entry * fib6_rule_lookup ( struct net * net , struct flowi6 * fl6 , const struct sk_buff * skb , int flags , pol_lookup_t lookup ) { struct rt6_info * rt ; rt = lookup ( net , net -> ipv6 . fib6_main_tbl , fl6 , skb , flags ) ; if ( rt -> dst . error == - EAGAIN ) { ip6_rt_put_flags ( rt , flags ) ; rt = net -> ipv6 . ip6_null_entry ; <S2SV_StartBug> if ( ! ( flags | RT6_LOOKUP_F_DST_NOREF ) ) <S2SV_EndBug> dst_hold ( & rt -> dst ) ; } return & rt -> dst ; }\n","target":"<S2SV_ModStart> ! ( flags & <S2SV_ModEnd> RT6_LOOKUP_F_DST_NOREF ) )\n","project_and_commit_id":"torvalds@linux/7b09c2d052db4b4ad0b27b97918b46a7746966fa","cve_id":"CVE-2019-20422","original_address":"https://github.com/torvalds/linux/commit/7b09c2d052db4b4ad0b27b97918b46a7746966fa","time":"2020-01-27T05:15Z"},
	{"Unnamed: 0":3067,"cwe_id":"CWE-119","source":"CWE-119 static struct dentry * proc_mount ( struct file_system_type * fs_type , int flags , const char * dev_name , void * data ) { int err ; struct super_block * sb ; struct pid_namespace * ns ; char * options ; if ( flags & MS_KERNMOUNT ) { ns = ( struct pid_namespace * ) data ; options = NULL ; } else { ns = task_active_pid_ns ( current ) ; options = data ; if ( ! ns_capable ( ns -> user_ns , CAP_SYS_ADMIN ) ) return ERR_PTR ( - EPERM ) ; } sb = sget ( fs_type , proc_test_super , proc_set_super , flags , ns ) ; if ( IS_ERR ( sb ) ) return ERR_CAST ( sb ) ; <S2SV_StartBug> if ( ! proc_parse_options ( options , ns ) ) { <S2SV_EndBug> deactivate_locked_super ( sb ) ; return ERR_PTR ( - EINVAL ) ; } if ( ! sb -> s_root ) { err = proc_fill_super ( sb ) ; if ( err ) { deactivate_locked_super ( sb ) ; return ERR_PTR ( err ) ; } sb -> s_flags |= MS_ACTIVE ; sb -> s_iflags |= SB_I_NOEXEC ; } return dget ( sb -> s_root ) ; }\n","target":"<S2SV_ModStart> sb ) ; sb -> s_stack_depth = FILESYSTEM_MAX_STACK_DEPTH ;\n","project_and_commit_id":"torvalds@linux/f5364c150aa645b3d7daa21b5c0b9feaa1c9cd6d","cve_id":"CVE-2016-1583","original_address":"https://github.com/torvalds/linux/commit/f5364c150aa645b3d7daa21b5c0b9feaa1c9cd6d","time":"2016-06-27T10:59Z"},
	{"Unnamed: 0":4680,"cwe_id":"CWE-119","source":"CWE-119 <S2SV_StartBug> int vp9_compute_qdelta ( const RATE_CONTROL * rc , double qstart , double qtarget ) { <S2SV_EndBug> int start_index = rc -> worst_quality ; int target_index = rc -> worst_quality ; int i ; for ( i = rc -> best_quality ; i < rc -> worst_quality ; ++ i ) { start_index = i ; <S2SV_StartBug> if ( vp9_convert_qindex_to_q ( i ) >= qstart ) <S2SV_EndBug> break ; } for ( i = rc -> best_quality ; i < rc -> worst_quality ; ++ i ) { target_index = i ; <S2SV_StartBug> if ( vp9_convert_qindex_to_q ( i ) >= qtarget ) <S2SV_EndBug> break ; } return target_index - start_index ; }\n","target":"<S2SV_ModStart> , double qtarget , vpx_bit_depth_t bit_depth <S2SV_ModStart> vp9_convert_qindex_to_q ( i , bit_depth <S2SV_ModStart> vp9_convert_qindex_to_q ( i , bit_depth\n","project_and_commit_id":"external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426","cve_id":"CVE-2016-1621","original_address":"https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426","time":"2016-03-12T21:59Z"},
	{"Unnamed: 0":6236,"cwe_id":"CWE-772","source":"CWE-772 generic_ret * chpass_principal_2_svc ( chpass_arg * arg , struct svc_req * rqstp ) { static generic_ret ret ; char * prime_arg ; <S2SV_StartBug> gss_buffer_desc client_name , <S2SV_EndBug> service_name ; OM_uint32 minor_stat ; kadm5_server_handle_t handle ; const char * errmsg = NULL ; xdr_free ( xdr_generic_ret , & ret ) ; if ( ( ret . code = new_server_handle ( arg -> api_version , rqstp , & handle ) ) ) goto exit_func ; if ( ( ret . code = check_handle ( ( void * ) handle ) ) ) goto exit_func ; ret . api_version = handle -> api_version ; if ( setup_gss_names ( rqstp , & client_name , & service_name ) < 0 ) { ret . code = KADM5_FAILURE ; goto exit_func ; } if ( krb5_unparse_name ( handle -> context , arg -> princ , & prime_arg ) ) { ret . code = KADM5_BAD_PRINCIPAL ; goto exit_func ; } if ( cmp_gss_krb5_name ( handle , rqst2name ( rqstp ) , arg -> princ ) ) { ret . code = chpass_principal_wrapper_3 ( ( void * ) handle , arg -> princ , FALSE , 0 , NULL , arg -> pass ) ; } else if ( ! ( CHANGEPW_SERVICE ( rqstp ) ) && kadm5int_acl_check ( handle -> context , rqst2name ( rqstp ) , ACL_CHANGEPW , arg -> princ , NULL ) ) { ret . code = kadm5_chpass_principal ( ( void * ) handle , arg -> princ , arg -> pass ) ; } else { log_unauth ( \"kadm5_chpass_principal\" , prime_arg , & client_name , & service_name , rqstp ) ; ret . code = KADM5_AUTH_CHANGEPW ; } if ( ret . code != KADM5_AUTH_CHANGEPW ) { if ( ret . code != 0 ) errmsg = krb5_get_error_message ( handle -> context , ret . code ) ; log_done ( \"kadm5_chpass_principal\" , prime_arg , errmsg , & client_name , & service_name , rqstp ) ; if ( errmsg != NULL ) krb5_free_error_message ( handle -> context , errmsg ) ; } free ( prime_arg ) ; <S2SV_StartBug> gss_release_buffer ( & minor_stat , & client_name ) ; <S2SV_EndBug> gss_release_buffer ( & minor_stat , & service_name ) ; exit_func : free_server_handle ( handle ) ; return & ret ; }\n","target":"<S2SV_ModStart> ; gss_buffer_desc client_name = GSS_C_EMPTY_BUFFER ; gss_buffer_desc service_name = GSS_C_EMPTY_BUFFER <S2SV_ModEnd> ; OM_uint32 minor_stat <S2SV_ModStart> prime_arg ) ; exit_func : gss_release_buffer ( & minor_stat , & client_name ) ; gss_release_buffer ( & minor_stat , & service_name ) ; <S2SV_ModEnd> free_server_handle ( handle\n","project_and_commit_id":"krb5@krb5/83ed75feba32e46f736fcce0d96a0445f29b96c2","cve_id":"CVE-2015-8631","original_address":"https://github.com/krb5/krb5/commit/83ed75feba32e46f736fcce0d96a0445f29b96c2","time":"2016-02-13T02:59Z"},
	{"Unnamed: 0":1208,"cwe_id":"CWE-401","source":"CWE-401 static Image * ReadBMPImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { BMPInfo bmp_info ; Image * image ; MagickBooleanType status ; MagickOffsetType offset , profile_data , profile_size , start_position ; MemoryInfo * pixel_info ; Quantum index ; register Quantum * q ; register ssize_t i , x ; register unsigned char * p ; size_t bit , bytes_per_line , length ; ssize_t count , y ; unsigned char magick [ 12 ] , * pixels ; unsigned int blue , green , offset_bits , red ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickCoreSignature ) ; if ( image_info -> debug != MagickFalse ) ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , \"%s\" , image_info -> filename ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickCoreSignature ) ; image = AcquireImage ( image_info , exception ) ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } ( void ) memset ( & bmp_info , 0 , sizeof ( bmp_info ) ) ; bmp_info . ba_offset = 0 ; start_position = 0 ; offset_bits = 0 ; count = ReadBlob ( image , 2 , magick ) ; if ( count != 2 ) ThrowReaderException ( CorruptImageError , \"ImproperImageHeader\" ) ; do { PixelInfo quantum_bits ; PixelPacket shift ; start_position = TellBlob ( image ) - 2 ; bmp_info . ba_offset = 0 ; while ( LocaleNCompare ( ( char * ) magick , \"BA\" , 2 ) == 0 ) { bmp_info . file_size = ReadBlobLSBLong ( image ) ; bmp_info . ba_offset = ReadBlobLSBLong ( image ) ; bmp_info . offset_bits = ReadBlobLSBLong ( image ) ; count = ReadBlob ( image , 2 , magick ) ; if ( count != 2 ) break ; } if ( image -> debug != MagickFalse ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , \"<S2SV_blank><S2SV_blank>Magick:<S2SV_blank>%c%c\" , magick [ 0 ] , magick [ 1 ] ) ; if ( ( count != 2 ) || ( ( LocaleNCompare ( ( char * ) magick , \"BM\" , 2 ) != 0 ) && ( LocaleNCompare ( ( char * ) magick , \"CI\" , 2 ) != 0 ) ) ) ThrowReaderException ( CorruptImageError , \"ImproperImageHeader\" ) ; bmp_info . file_size = ReadBlobLSBLong ( image ) ; ( void ) ReadBlobLSBLong ( image ) ; bmp_info . offset_bits = ReadBlobLSBLong ( image ) ; bmp_info . size = ReadBlobLSBLong ( image ) ; if ( image -> debug != MagickFalse ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , \"<S2SV_blank><S2SV_blank>BMP<S2SV_blank>size:<S2SV_blank>%u\" , bmp_info . size ) ; profile_data = 0 ; profile_size = 0 ; if ( bmp_info . size == 12 ) { ( void ) CopyMagickString ( image -> magick , \"BMP2\" , MagickPathExtent ) ; bmp_info . width = ( ssize_t ) ( ( short ) ReadBlobLSBShort ( image ) ) ; bmp_info . height = ( ssize_t ) ( ( short ) ReadBlobLSBShort ( image ) ) ; bmp_info . planes = ReadBlobLSBShort ( image ) ; bmp_info . bits_per_pixel = ReadBlobLSBShort ( image ) ; bmp_info . x_pixels = 0 ; bmp_info . y_pixels = 0 ; bmp_info . number_colors = 0 ; bmp_info . compression = BI_RGB ; bmp_info . image_size = 0 ; bmp_info . alpha_mask = 0 ; if ( image -> debug != MagickFalse ) { ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , \"<S2SV_blank><S2SV_blank>Format:<S2SV_blank>OS/2<S2SV_blank>Bitmap\" ) ; ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , \"<S2SV_blank><S2SV_blank>Geometry:<S2SV_blank>%.20gx%.20g\" , ( double ) bmp_info . width , ( double ) bmp_info . height ) ; } } else { if ( bmp_info . size < 40 ) ThrowReaderException ( CorruptImageError , \"NonOS2HeaderSizeError\" ) ; bmp_info . width = ( ssize_t ) ReadBlobLSBSignedLong ( image ) ; bmp_info . height = ( ssize_t ) ReadBlobLSBSignedLong ( image ) ; bmp_info . planes = ReadBlobLSBShort ( image ) ; bmp_info . bits_per_pixel = ReadBlobLSBShort ( image ) ; bmp_info . compression = ReadBlobLSBLong ( image ) ; bmp_info . image_size = ReadBlobLSBLong ( image ) ; bmp_info . x_pixels = ReadBlobLSBLong ( image ) ; bmp_info . y_pixels = ReadBlobLSBLong ( image ) ; bmp_info . number_colors = ReadBlobLSBLong ( image ) ; if ( ( MagickSizeType ) bmp_info . number_colors > GetBlobSize ( image ) ) ThrowReaderException ( CorruptImageError , \"InsufficientImageDataInFile\" ) ; bmp_info . colors_important = ReadBlobLSBLong ( image ) ; if ( image -> debug != MagickFalse ) { ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , \"<S2SV_blank><S2SV_blank>Format:<S2SV_blank>MS<S2SV_blank>Windows<S2SV_blank>bitmap\" ) ; ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , \"<S2SV_blank><S2SV_blank>Geometry:<S2SV_blank>%.20gx%.20g\" , ( double ) bmp_info . width , ( double ) bmp_info . height ) ; ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , \"<S2SV_blank><S2SV_blank>Bits<S2SV_blank>per<S2SV_blank>pixel:<S2SV_blank>%.20g\" , ( double ) bmp_info . bits_per_pixel ) ; switch ( bmp_info . compression ) { case BI_RGB : { ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , \"<S2SV_blank><S2SV_blank>Compression:<S2SV_blank>BI_RGB\" ) ; break ; } case BI_RLE4 : { ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , \"<S2SV_blank><S2SV_blank>Compression:<S2SV_blank>BI_RLE4\" ) ; break ; } case BI_RLE8 : { ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , \"<S2SV_blank><S2SV_blank>Compression:<S2SV_blank>BI_RLE8\" ) ; break ; } case BI_BITFIELDS : { ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , \"<S2SV_blank><S2SV_blank>Compression:<S2SV_blank>BI_BITFIELDS\" ) ; break ; } case BI_PNG : { ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , \"<S2SV_blank><S2SV_blank>Compression:<S2SV_blank>BI_PNG\" ) ; break ; } case BI_JPEG : { ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , \"<S2SV_blank><S2SV_blank>Compression:<S2SV_blank>BI_JPEG\" ) ; break ; } default : { ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , \"<S2SV_blank><S2SV_blank>Compression:<S2SV_blank>UNKNOWN<S2SV_blank>(%u)\" , bmp_info . compression ) ; } } ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , \"<S2SV_blank><S2SV_blank>Number<S2SV_blank>of<S2SV_blank>colors:<S2SV_blank>%u\" , bmp_info . number_colors ) ; } bmp_info . red_mask = ReadBlobLSBLong ( image ) ; bmp_info . green_mask = ReadBlobLSBLong ( image ) ; bmp_info . blue_mask = ReadBlobLSBLong ( image ) ; if ( bmp_info . size > 40 ) { double gamma ; bmp_info . alpha_mask = ReadBlobLSBLong ( image ) ; bmp_info . colorspace = ReadBlobLSBSignedLong ( image ) ; # define BMP_DENOM ( ( double ) 0x40000000 ) bmp_info . red_primary . x = ( double ) ReadBlobLSBLong ( image ) / BMP_DENOM ; bmp_info . red_primary . y = ( double ) ReadBlobLSBLong ( image ) / BMP_DENOM ; bmp_info . red_primary . z = ( double ) ReadBlobLSBLong ( image ) / BMP_DENOM ; bmp_info . green_primary . x = ( double ) ReadBlobLSBLong ( image ) / BMP_DENOM ; bmp_info . green_primary . y = ( double ) ReadBlobLSBLong ( image ) / BMP_DENOM ; bmp_info . green_primary . z = ( double ) ReadBlobLSBLong ( image ) / BMP_DENOM ; bmp_info . blue_primary . x = ( double ) ReadBlobLSBLong ( image ) / BMP_DENOM ; bmp_info . blue_primary . y = ( double ) ReadBlobLSBLong ( image ) / BMP_DENOM ; bmp_info . blue_primary . z = ( double ) ReadBlobLSBLong ( image ) / BMP_DENOM ; gamma = bmp_info . red_primary . x + bmp_info . red_primary . y + bmp_info . red_primary . z ; gamma = PerceptibleReciprocal ( gamma ) ; bmp_info . red_primary . x *= gamma ; bmp_info . red_primary . y *= gamma ; image -> chromaticity . red_primary . x = bmp_info . red_primary . x ; image -> chromaticity . red_primary . y = bmp_info . red_primary . y ; gamma = bmp_info . green_primary . x + bmp_info . green_primary . y + bmp_info . green_primary . z ; gamma = PerceptibleReciprocal ( gamma ) ; bmp_info . green_primary . x *= gamma ; bmp_info . green_primary . y *= gamma ; image -> chromaticity . green_primary . x = bmp_info . green_primary . x ; image -> chromaticity . green_primary . y = bmp_info . green_primary . y ; gamma = bmp_info . blue_primary . x + bmp_info . blue_primary . y + bmp_info . blue_primary . z ; gamma = PerceptibleReciprocal ( gamma ) ; bmp_info . blue_primary . x *= gamma ; bmp_info . blue_primary . y *= gamma ; image -> chromaticity . blue_primary . x = bmp_info . blue_primary . x ; image -> chromaticity . blue_primary . y = bmp_info . blue_primary . y ; bmp_info . gamma_scale . x = ( double ) ReadBlobLSBLong ( image ) / 0x10000 ; bmp_info . gamma_scale . y = ( double ) ReadBlobLSBLong ( image ) / 0x10000 ; bmp_info . gamma_scale . z = ( double ) ReadBlobLSBLong ( image ) / 0x10000 ; image -> gamma = ( bmp_info . gamma_scale . x + bmp_info . gamma_scale . y + bmp_info . gamma_scale . z ) / 3.0 ; } else ( void ) CopyMagickString ( image -> magick , \"BMP3\" , MagickPathExtent ) ; if ( bmp_info . size > 108 ) { size_t intent ; intent = ReadBlobLSBLong ( image ) ; switch ( ( int ) intent ) { case LCS_GM_BUSINESS : { image -> rendering_intent = SaturationIntent ; break ; } case LCS_GM_GRAPHICS : { image -> rendering_intent = RelativeIntent ; break ; } case LCS_GM_IMAGES : { image -> rendering_intent = PerceptualIntent ; break ; } case LCS_GM_ABS_COLORIMETRIC : { image -> rendering_intent = AbsoluteIntent ; break ; } } profile_data = ( MagickOffsetType ) ReadBlobLSBLong ( image ) ; profile_size = ( MagickOffsetType ) ReadBlobLSBLong ( image ) ; ( void ) ReadBlobLSBLong ( image ) ; } } if ( ( MagickSizeType ) bmp_info . file_size > GetBlobSize ( image ) ) ( void ) ThrowMagickException ( exception , GetMagickModule ( ) , CorruptImageError , \"LengthAndFilesizeDoNotMatch\" , \"`%s\\'\" , image -> filename ) ; else if ( ( MagickSizeType ) bmp_info . file_size < GetBlobSize ( image ) ) ( void ) ThrowMagickException ( exception , GetMagickModule ( ) , CorruptImageWarning , \"LengthAndFilesizeDoNotMatch\" , \"`%s\\'\" , image -> filename ) ; if ( bmp_info . width <= 0 ) ThrowReaderException ( CorruptImageError , \"NegativeOrZeroImageSize\" ) ; if ( bmp_info . height == 0 ) ThrowReaderException ( CorruptImageError , \"NegativeOrZeroImageSize\" ) ; if ( bmp_info . planes != 1 ) ThrowReaderException ( CorruptImageError , \"StaticPlanesValueNotEqualToOne\" ) ; if ( ( bmp_info . bits_per_pixel != 1 ) && ( bmp_info . bits_per_pixel != 4 ) && ( bmp_info . bits_per_pixel != 8 ) && ( bmp_info . bits_per_pixel != 16 ) && ( bmp_info . bits_per_pixel != 24 ) && ( bmp_info . bits_per_pixel != 32 ) ) ThrowReaderException ( CorruptImageError , \"UnsupportedBitsPerPixel\" ) ; if ( bmp_info . bits_per_pixel < 16 && bmp_info . number_colors > ( 1U << bmp_info . bits_per_pixel ) ) ThrowReaderException ( CorruptImageError , \"UnrecognizedNumberOfColors\" ) ; if ( ( bmp_info . compression == 1 ) && ( bmp_info . bits_per_pixel != 8 ) ) ThrowReaderException ( CorruptImageError , \"UnsupportedBitsPerPixel\" ) ; if ( ( bmp_info . compression == 2 ) && ( bmp_info . bits_per_pixel != 4 ) ) ThrowReaderException ( CorruptImageError , \"UnsupportedBitsPerPixel\" ) ; if ( ( bmp_info . compression == 3 ) && ( bmp_info . bits_per_pixel < 16 ) ) ThrowReaderException ( CorruptImageError , \"UnsupportedBitsPerPixel\" ) ; switch ( bmp_info . compression ) { case BI_RGB : image -> compression = NoCompression ; break ; case BI_RLE8 : case BI_RLE4 : image -> compression = RLECompression ; break ; case BI_BITFIELDS : break ; case BI_JPEG : ThrowReaderException ( CoderError , \"JPEGCompressNotSupported\" ) ; case BI_PNG : ThrowReaderException ( CoderError , \"PNGCompressNotSupported\" ) ; default : ThrowReaderException ( CorruptImageError , \"UnrecognizedImageCompression\" ) ; } image -> columns = ( size_t ) MagickAbsoluteValue ( bmp_info . width ) ; image -> rows = ( size_t ) MagickAbsoluteValue ( bmp_info . height ) ; image -> depth = bmp_info . bits_per_pixel <= 8 ? bmp_info . bits_per_pixel : 8 ; image -> alpha_trait = ( ( bmp_info . alpha_mask != 0 ) && ( bmp_info . compression == BI_BITFIELDS ) ) ? BlendPixelTrait : UndefinedPixelTrait ; if ( bmp_info . bits_per_pixel < 16 ) { size_t one ; image -> storage_class = PseudoClass ; image -> colors = bmp_info . number_colors ; one = 1 ; if ( image -> colors == 0 ) image -> colors = one << bmp_info . bits_per_pixel ; } image -> resolution . x = ( double ) bmp_info . x_pixels / 100.0 ; image -> resolution . y = ( double ) bmp_info . y_pixels / 100.0 ; image -> units = PixelsPerCentimeterResolution ; if ( ( image_info -> ping != MagickFalse ) && ( image_info -> number_scenes != 0 ) ) if ( image -> scene >= ( image_info -> scene + image_info -> number_scenes - 1 ) ) break ; status = SetImageExtent ( image , image -> columns , image -> rows , exception ) ; if ( status == MagickFalse ) return ( DestroyImageList ( image ) ) ; if ( image -> storage_class == PseudoClass ) { unsigned char * bmp_colormap ; size_t packet_size ; if ( image -> debug != MagickFalse ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , \"<S2SV_blank><S2SV_blank>Reading<S2SV_blank>colormap<S2SV_blank>of<S2SV_blank>%.20g<S2SV_blank>colors\" , ( double ) image -> colors ) ; if ( AcquireImageColormap ( image , image -> colors , exception ) == MagickFalse ) ThrowReaderException ( ResourceLimitError , \"MemoryAllocationFailed\" ) ; bmp_colormap = ( unsigned char * ) AcquireQuantumMemory ( ( size_t ) image -> colors , 4 * sizeof ( * bmp_colormap ) ) ; if ( bmp_colormap == ( unsigned char * ) NULL ) ThrowReaderException ( ResourceLimitError , \"MemoryAllocationFailed\" ) ; if ( ( bmp_info . size == 12 ) || ( bmp_info . size == 64 ) ) packet_size = 3 ; else packet_size = 4 ; offset = SeekBlob ( image , start_position + 14 + bmp_info . size , SEEK_SET ) ; if ( offset < 0 ) { bmp_colormap = ( unsigned char * ) RelinquishMagickMemory ( bmp_colormap ) ; ThrowReaderException ( CorruptImageError , \"ImproperImageHeader\" ) ; } count = ReadBlob ( image , packet_size * image -> colors , bmp_colormap ) ; if ( count != ( ssize_t ) ( packet_size * image -> colors ) ) { bmp_colormap = ( unsigned char * ) RelinquishMagickMemory ( bmp_colormap ) ; ThrowReaderException ( CorruptImageError , \"InsufficientImageDataInFile\" ) ; } p = bmp_colormap ; for ( i = 0 ; i < ( ssize_t ) image -> colors ; i ++ ) { image -> colormap [ i ] . blue = ( MagickRealType ) ScaleCharToQuantum ( * p ++ ) ; image -> colormap [ i ] . green = ( MagickRealType ) ScaleCharToQuantum ( * p ++ ) ; image -> colormap [ i ] . red = ( MagickRealType ) ScaleCharToQuantum ( * p ++ ) ; if ( packet_size == 4 ) p ++ ; } bmp_colormap = ( unsigned char * ) RelinquishMagickMemory ( bmp_colormap ) ; } if ( bmp_info . offset_bits == offset_bits ) ThrowReaderException ( CorruptImageError , \"ImproperImageHeader\" ) ; offset_bits = bmp_info . offset_bits ; offset = SeekBlob ( image , start_position + bmp_info . offset_bits , SEEK_SET ) ; if ( offset < 0 ) ThrowReaderException ( CorruptImageError , \"ImproperImageHeader\" ) ; if ( bmp_info . compression == BI_RLE4 ) bmp_info . bits_per_pixel <<= 1 ; bytes_per_line = 4 * ( ( image -> columns * bmp_info . bits_per_pixel + 31 ) / 32 ) ; length = ( size_t ) bytes_per_line * image -> rows ; if ( ( MagickSizeType ) ( length / 256 ) > GetBlobSize ( image ) ) ThrowReaderException ( CorruptImageError , \"InsufficientImageDataInFile\" ) ; if ( ( bmp_info . compression == BI_RGB ) || ( bmp_info . compression == BI_BITFIELDS ) ) { pixel_info = AcquireVirtualMemory ( image -> rows , MagickMax ( bytes_per_line , image -> columns + 256UL ) * sizeof ( * pixels ) ) ; if ( pixel_info == ( MemoryInfo * ) NULL ) ThrowReaderException ( ResourceLimitError , \"MemoryAllocationFailed\" ) ; pixels = ( unsigned char * ) GetVirtualMemoryBlob ( pixel_info ) ; if ( image -> debug != MagickFalse ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , \"<S2SV_blank><S2SV_blank>Reading<S2SV_blank>pixels<S2SV_blank>(%.20g<S2SV_blank>bytes)\" , ( double ) length ) ; count = ReadBlob ( image , length , pixels ) ; if ( count != ( ssize_t ) length ) { pixel_info = RelinquishVirtualMemory ( pixel_info ) ; ThrowReaderException ( CorruptImageError , \"InsufficientImageDataInFile\" ) ; } } else { pixel_info = AcquireVirtualMemory ( image -> rows , MagickMax ( bytes_per_line , image -> columns + 256UL ) * sizeof ( * pixels ) ) ; if ( pixel_info == ( MemoryInfo * ) NULL ) ThrowReaderException ( ResourceLimitError , \"MemoryAllocationFailed\" ) ; pixels = ( unsigned char * ) GetVirtualMemoryBlob ( pixel_info ) ; status = DecodeImage ( image , bmp_info . compression , pixels , image -> columns * image -> rows ) ; if ( status == MagickFalse ) { pixel_info = RelinquishVirtualMemory ( pixel_info ) ; ThrowReaderException ( CorruptImageError , \"UnableToRunlengthDecodeImage\" ) ; } } if ( bmp_info . compression == BI_RGB ) { if ( ( image -> alpha_trait == UndefinedPixelTrait ) && ( bmp_info . size == 40 ) && ( bmp_info . bits_per_pixel == 32 ) ) { bytes_per_line = 4 * ( image -> columns ) ; for ( y = ( ssize_t ) image -> rows - 1 ; y >= 0 ; y -- ) { p = pixels + ( image -> rows - y - 1 ) * bytes_per_line ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { if ( * ( p + 3 ) != 0 ) { image -> alpha_trait = BlendPixelTrait ; y = - 1 ; break ; } p += 4 ; } } } bmp_info . alpha_mask = image -> alpha_trait != UndefinedPixelTrait ? 0xff000000U : 0U ; bmp_info . red_mask = 0x00ff0000U ; bmp_info . green_mask = 0x0000ff00U ; bmp_info . blue_mask = 0x000000ffU ; if ( bmp_info . bits_per_pixel == 16 ) { bmp_info . red_mask = 0x00007c00U ; bmp_info . green_mask = 0x000003e0U ; bmp_info . blue_mask = 0x0000001fU ; } } ( void ) memset ( & shift , 0 , sizeof ( shift ) ) ; ( void ) memset ( & quantum_bits , 0 , sizeof ( quantum_bits ) ) ; if ( ( bmp_info . bits_per_pixel == 16 ) || ( bmp_info . bits_per_pixel == 32 ) ) { register unsigned int sample ; if ( bmp_info . red_mask != 0 ) while ( ( ( bmp_info . red_mask << shift . red ) & 0x80000000UL ) == 0 ) { shift . red ++ ; if ( shift . red >= 32U ) break ; } if ( bmp_info . green_mask != 0 ) while ( ( ( bmp_info . green_mask << shift . green ) & 0x80000000UL ) == 0 ) { shift . green ++ ; if ( shift . green >= 32U ) break ; } if ( bmp_info . blue_mask != 0 ) while ( ( ( bmp_info . blue_mask << shift . blue ) & 0x80000000UL ) == 0 ) { shift . blue ++ ; if ( shift . blue >= 32U ) break ; } if ( bmp_info . alpha_mask != 0 ) while ( ( ( bmp_info . alpha_mask << shift . alpha ) & 0x80000000UL ) == 0 ) { shift . alpha ++ ; if ( shift . alpha >= 32U ) break ; } sample = shift . red ; while ( ( ( bmp_info . red_mask << sample ) & 0x80000000UL ) != 0 ) { sample ++ ; if ( sample >= 32U ) break ; } quantum_bits . red = ( MagickRealType ) ( sample - shift . red ) ; sample = shift . green ; while ( ( ( bmp_info . green_mask << sample ) & 0x80000000UL ) != 0 ) { sample ++ ; if ( sample >= 32U ) break ; } quantum_bits . green = ( MagickRealType ) ( sample - shift . green ) ; sample = shift . blue ; while ( ( ( bmp_info . blue_mask << sample ) & 0x80000000UL ) != 0 ) { sample ++ ; if ( sample >= 32U ) break ; } quantum_bits . blue = ( MagickRealType ) ( sample - shift . blue ) ; sample = shift . alpha ; while ( ( ( bmp_info . alpha_mask << sample ) & 0x80000000UL ) != 0 ) { sample ++ ; if ( sample >= 32U ) break ; } quantum_bits . alpha = ( MagickRealType ) ( sample - shift . alpha ) ; } switch ( bmp_info . bits_per_pixel ) { case 1 : { for ( y = ( ssize_t ) image -> rows - 1 ; y >= 0 ; y -- ) { p = pixels + ( image -> rows - y - 1 ) * bytes_per_line ; q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; for ( x = 0 ; x < ( ( ssize_t ) image -> columns - 7 ) ; x += 8 ) { for ( bit = 0 ; bit < 8 ; bit ++ ) { index = ( Quantum ) ( ( ( * p ) & ( 0x80 >> bit ) ) != 0 ? 0x01 : 0x00 ) ; SetPixelIndex ( image , index , q ) ; q += GetPixelChannels ( image ) ; } p ++ ; } if ( ( image -> columns % 8 ) != 0 ) { for ( bit = 0 ; bit < ( image -> columns % 8 ) ; bit ++ ) { index = ( Quantum ) ( ( ( * p ) & ( 0x80 >> bit ) ) != 0 ? 0x01 : 0x00 ) ; SetPixelIndex ( image , index , q ) ; q += GetPixelChannels ( image ) ; } p ++ ; } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) ( image -> rows - y ) , image -> rows ) ; if ( status == MagickFalse ) break ; } } ( void ) SyncImage ( image , exception ) ; break ; } case 4 : { for ( y = ( ssize_t ) image -> rows - 1 ; y >= 0 ; y -- ) { p = pixels + ( image -> rows - y - 1 ) * bytes_per_line ; q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; for ( x = 0 ; x < ( ( ssize_t ) image -> columns - 1 ) ; x += 2 ) { ValidateColormapValue ( image , ( ssize_t ) ( ( * p >> 4 ) & 0x0f ) , & index , exception ) ; SetPixelIndex ( image , index , q ) ; q += GetPixelChannels ( image ) ; ValidateColormapValue ( image , ( ssize_t ) ( * p & 0x0f ) , & index , exception ) ; SetPixelIndex ( image , index , q ) ; q += GetPixelChannels ( image ) ; p ++ ; } if ( ( image -> columns % 2 ) != 0 ) { ValidateColormapValue ( image , ( ssize_t ) ( ( * p >> 4 ) & 0xf ) , & index , exception ) ; SetPixelIndex ( image , index , q ) ; q += GetPixelChannels ( image ) ; p ++ ; x ++ ; } if ( x < ( ssize_t ) image -> columns ) break ; if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) ( image -> rows - y ) , image -> rows ) ; if ( status == MagickFalse ) break ; } } ( void ) SyncImage ( image , exception ) ; break ; } case 8 : { if ( ( bmp_info . compression == BI_RLE8 ) || ( bmp_info . compression == BI_RLE4 ) ) bytes_per_line = image -> columns ; for ( y = ( ssize_t ) image -> rows - 1 ; y >= 0 ; y -- ) { p = pixels + ( image -> rows - y - 1 ) * bytes_per_line ; q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; for ( x = ( ssize_t ) image -> columns ; x != 0 ; -- x ) { ValidateColormapValue ( image , ( ssize_t ) * p ++ , & index , exception ) ; SetPixelIndex ( image , index , q ) ; q += GetPixelChannels ( image ) ; } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; offset = ( MagickOffsetType ) ( image -> rows - y - 1 ) ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) ( image -> rows - y ) , image -> rows ) ; if ( status == MagickFalse ) break ; } } ( void ) SyncImage ( image , exception ) ; break ; } case 16 : { unsigned int alpha , pixel ; if ( ( bmp_info . compression != BI_RGB ) && ( bmp_info . compression != BI_BITFIELDS ) ) { pixel_info = RelinquishVirtualMemory ( pixel_info ) ; ThrowReaderException ( CorruptImageError , \"UnrecognizedImageCompression\" ) ; } bytes_per_line = 2 * ( image -> columns + image -> columns % 2 ) ; image -> storage_class = DirectClass ; for ( y = ( ssize_t ) image -> rows - 1 ; y >= 0 ; y -- ) { p = pixels + ( image -> rows - y - 1 ) * bytes_per_line ; q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { pixel = ( unsigned int ) ( * p ++ ) ; pixel |= ( * p ++ ) << 8 ; red = ( ( pixel & bmp_info . red_mask ) << shift . red ) >> 16 ; if ( quantum_bits . red == 5 ) red |= ( ( red & 0xe000 ) >> 5 ) ; if ( quantum_bits . red <= 8 ) red |= ( ( red & 0xff00 ) >> 8 ) ; green = ( ( pixel & bmp_info . green_mask ) << shift . green ) >> 16 ; if ( quantum_bits . green == 5 ) green |= ( ( green & 0xe000 ) >> 5 ) ; if ( quantum_bits . green == 6 ) green |= ( ( green & 0xc000 ) >> 6 ) ; if ( quantum_bits . green <= 8 ) green |= ( ( green & 0xff00 ) >> 8 ) ; blue = ( ( pixel & bmp_info . blue_mask ) << shift . blue ) >> 16 ; if ( quantum_bits . blue == 5 ) blue |= ( ( blue & 0xe000 ) >> 5 ) ; if ( quantum_bits . blue <= 8 ) blue |= ( ( blue & 0xff00 ) >> 8 ) ; SetPixelRed ( image , ScaleShortToQuantum ( ( unsigned short ) red ) , q ) ; SetPixelGreen ( image , ScaleShortToQuantum ( ( unsigned short ) green ) , q ) ; SetPixelBlue ( image , ScaleShortToQuantum ( ( unsigned short ) blue ) , q ) ; SetPixelAlpha ( image , OpaqueAlpha , q ) ; if ( image -> alpha_trait != UndefinedPixelTrait ) { alpha = ( ( pixel & bmp_info . alpha_mask ) << shift . alpha ) >> 16 ; if ( quantum_bits . alpha <= 8 ) alpha |= ( ( alpha & 0xff00 ) >> 8 ) ; SetPixelAlpha ( image , ScaleShortToQuantum ( ( unsigned short ) alpha ) , q ) ; } q += GetPixelChannels ( image ) ; } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; offset = ( MagickOffsetType ) ( image -> rows - y - 1 ) ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) ( image -> rows - y ) , image -> rows ) ; if ( status == MagickFalse ) break ; } } break ; } case 24 : { bytes_per_line = 4 * ( ( image -> columns * 24 + 31 ) / 32 ) ; for ( y = ( ssize_t ) image -> rows - 1 ; y >= 0 ; y -- ) { p = pixels + ( image -> rows - y - 1 ) * bytes_per_line ; q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { SetPixelBlue ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; SetPixelGreen ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; SetPixelRed ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; SetPixelAlpha ( image , OpaqueAlpha , q ) ; q += GetPixelChannels ( image ) ; } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; offset = ( MagickOffsetType ) ( image -> rows - y - 1 ) ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) ( image -> rows - y ) , image -> rows ) ; if ( status == MagickFalse ) break ; } } break ; } case 32 : { if ( ( bmp_info . compression != BI_RGB ) && ( bmp_info . compression != BI_BITFIELDS ) ) { pixel_info = RelinquishVirtualMemory ( pixel_info ) ; ThrowReaderException ( CorruptImageError , \"UnrecognizedImageCompression\" ) ; } bytes_per_line = 4 * ( image -> columns ) ; for ( y = ( ssize_t ) image -> rows - 1 ; y >= 0 ; y -- ) { unsigned int alpha , pixel ; p = pixels + ( image -> rows - y - 1 ) * bytes_per_line ; q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { pixel = ( unsigned int ) ( * p ++ ) ; pixel |= ( ( unsigned int ) * p ++ << 8 ) ; pixel |= ( ( unsigned int ) * p ++ << 16 ) ; pixel |= ( ( unsigned int ) * p ++ << 24 ) ; red = ( ( pixel & bmp_info . red_mask ) << shift . red ) >> 16 ; if ( quantum_bits . red == 8 ) red |= ( red >> 8 ) ; green = ( ( pixel & bmp_info . green_mask ) << shift . green ) >> 16 ; if ( quantum_bits . green == 8 ) green |= ( green >> 8 ) ; blue = ( ( pixel & bmp_info . blue_mask ) << shift . blue ) >> 16 ; if ( quantum_bits . blue == 8 ) blue |= ( blue >> 8 ) ; SetPixelRed ( image , ScaleShortToQuantum ( ( unsigned short ) red ) , q ) ; SetPixelGreen ( image , ScaleShortToQuantum ( ( unsigned short ) green ) , q ) ; SetPixelBlue ( image , ScaleShortToQuantum ( ( unsigned short ) blue ) , q ) ; SetPixelAlpha ( image , OpaqueAlpha , q ) ; if ( image -> alpha_trait != UndefinedPixelTrait ) { alpha = ( ( pixel & bmp_info . alpha_mask ) << shift . alpha ) >> 16 ; if ( quantum_bits . alpha == 8 ) alpha |= ( alpha >> 8 ) ; SetPixelAlpha ( image , ScaleShortToQuantum ( ( unsigned short ) alpha ) , q ) ; } q += GetPixelChannels ( image ) ; } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; offset = ( MagickOffsetType ) ( image -> rows - y - 1 ) ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) ( image -> rows - y ) , image -> rows ) ; if ( status == MagickFalse ) break ; } } break ; } default : { pixel_info = RelinquishVirtualMemory ( pixel_info ) ; ThrowReaderException ( CorruptImageError , \"ImproperImageHeader\" ) ; } } pixel_info = RelinquishVirtualMemory ( pixel_info ) ; if ( y > 0 ) break ; if ( EOFBlob ( image ) != MagickFalse ) { ThrowFileException ( exception , CorruptImageError , \"UnexpectedEndOfFile\" , image -> filename ) ; break ; } if ( bmp_info . height < 0 ) { Image * flipped_image ; flipped_image = FlipImage ( image , exception ) ; if ( flipped_image != ( Image * ) NULL ) { DuplicateBlob ( flipped_image , image ) ; ReplaceImageInList ( & image , flipped_image ) ; image = flipped_image ; } } if ( ( bmp_info . colorspace == 0x4D424544L ) && ( profile_data > 0 ) && ( profile_size > 0 ) ) { StringInfo * profile ; unsigned char * datum ; offset = start_position + 14 + profile_data ; if ( ( offset < TellBlob ( image ) ) || ( SeekBlob ( image , offset , SEEK_SET ) != offset ) || ( GetBlobSize ( image ) < ( MagickSizeType ) ( offset + profile_size ) ) ) ThrowReaderException ( CorruptImageError , \"ImproperImageHeader\" ) ; profile = AcquireStringInfo ( ( size_t ) profile_size ) ; if ( profile == ( StringInfo * ) NULL ) ThrowReaderException ( CorruptImageError , \"MemoryAllocationFailed\" ) ; datum = GetStringInfoDatum ( profile ) ; if ( ReadBlob ( image , ( size_t ) profile_size , datum ) == ( ssize_t ) profile_size ) { MagickOffsetType profile_size_orig ; profile_size_orig = ( MagickOffsetType ) datum [ 0 ] << 24 ; profile_size_orig |= ( MagickOffsetType ) datum [ 1 ] << 16 ; profile_size_orig |= ( MagickOffsetType ) datum [ 2 ] << 8 ; profile_size_orig |= ( MagickOffsetType ) datum [ 3 ] ; if ( profile_size_orig < profile_size ) SetStringInfoLength ( profile , ( size_t ) profile_size_orig ) ; if ( image -> debug != MagickFalse ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , \"Profile:<S2SV_blank>ICC,<S2SV_blank>%u<S2SV_blank>bytes\" , ( unsigned int ) profile_size_orig ) ; ( void ) SetImageProfile ( image , \"icc\" , profile , exception ) ; } profile = DestroyStringInfo ( profile ) ; } if ( image_info -> number_scenes != 0 ) if ( image -> scene >= ( image_info -> scene + image_info -> number_scenes - 1 ) ) break ; offset = ( MagickOffsetType ) bmp_info . ba_offset ; if ( offset != 0 ) if ( ( offset < TellBlob ( image ) ) || ( SeekBlob ( image , offset , SEEK_SET ) != offset ) ) ThrowReaderException ( CorruptImageError , \"ImproperImageHeader\" ) ; * magick = '\\\\0' ; count = ReadBlob ( image , 2 , magick ) ; if ( ( count == 2 ) && ( IsBMP ( magick , 2 ) != MagickFalse ) ) { AcquireNextImage ( image_info , image , exception ) ; if ( GetNextImageInList ( image ) == ( Image * ) NULL ) { status = MagickFalse ; <S2SV_StartBug> return ( ( Image * ) NULL ) ; <S2SV_EndBug> } image = SyncNextImageInList ( image ) ; status = SetImageProgress ( image , LoadImagesTag , TellBlob ( image ) , GetBlobSize ( image ) ) ; if ( status == MagickFalse ) break ; } } while ( IsBMP ( magick , 2 ) != MagickFalse ) ; ( void ) CloseBlob ( image ) ; if ( status == MagickFalse ) return ( DestroyImageList ( image ) ) ; return ( GetFirstImageInList ( image ) ) ; }\n","target":"<S2SV_ModStart> = MagickFalse ; break <S2SV_ModEnd> ; } image\n","project_and_commit_id":"ImageMagick@ImageMagick/fe3066122ef72c82415811d25e9e3fad622c0a99","cve_id":"CVE-2019-13134","original_address":"https://github.com/ImageMagick/ImageMagick/commit/fe3066122ef72c82415811d25e9e3fad622c0a99","time":"2019-07-01T20:15Z"},
	{"Unnamed: 0":1731,"cwe_id":"CWE-264","source":"CWE-264 static int pppol2tp_setsockopt ( struct socket * sock , int level , int optname , char __user * optval , unsigned int optlen ) { struct sock * sk = sock -> sk ; struct l2tp_session * session ; struct l2tp_tunnel * tunnel ; struct pppol2tp_session * ps ; int val ; int err ; if ( level != SOL_PPPOL2TP ) <S2SV_StartBug> return udp_prot . setsockopt ( sk , level , optname , optval , optlen ) ; <S2SV_EndBug> if ( optlen < sizeof ( int ) ) return - EINVAL ; if ( get_user ( val , ( int __user * ) optval ) ) return - EFAULT ; err = - ENOTCONN ; if ( sk -> sk_user_data == NULL ) goto end ; err = - EBADF ; session = pppol2tp_sock_to_session ( sk ) ; if ( session == NULL ) goto end ; ps = l2tp_session_priv ( session ) ; if ( ( session -> session_id == 0 ) && ( session -> peer_session_id == 0 ) ) { err = - EBADF ; tunnel = l2tp_sock_to_tunnel ( ps -> tunnel_sock ) ; if ( tunnel == NULL ) goto end_put_sess ; err = pppol2tp_tunnel_setsockopt ( sk , tunnel , optname , val ) ; sock_put ( ps -> tunnel_sock ) ; } else err = pppol2tp_session_setsockopt ( sk , session , optname , val ) ; err = 0 ; end_put_sess : sock_put ( sk ) ; end : return err ; }\n","target":"<S2SV_ModStart> SOL_PPPOL2TP ) return - EINVAL <S2SV_ModEnd> ; if (\n","project_and_commit_id":"torvalds@linux/3cf521f7dc87c031617fd47e4b7aa2593c2f3daf","cve_id":"CVE-2014-4943","original_address":"https://github.com/torvalds/linux/commit/3cf521f7dc87c031617fd47e4b7aa2593c2f3daf","time":"2014-07-19T19:55Z"},
	{"Unnamed: 0":4322,"cwe_id":"CWE-416","source":"CWE-416 struct sk_buff * skb_segment ( struct sk_buff * head_skb , netdev_features_t features ) { struct sk_buff * segs = NULL ; struct sk_buff * tail = NULL ; struct sk_buff * list_skb = skb_shinfo ( head_skb ) -> frag_list ; skb_frag_t * frag = skb_shinfo ( head_skb ) -> frags ; unsigned int mss = skb_shinfo ( head_skb ) -> gso_size ; <S2SV_StartBug> unsigned int doffset = head_skb -> data - skb_mac_header ( head_skb ) ; <S2SV_EndBug> unsigned int offset = doffset ; unsigned int tnl_hlen = skb_tnl_header_len ( head_skb ) ; unsigned int headroom ; unsigned int len ; __be16 proto ; bool csum ; int sg = ! ! ( features & NETIF_F_SG ) ; int nfrags = skb_shinfo ( head_skb ) -> nr_frags ; int err = - ENOMEM ; int i = 0 ; int pos ; proto = skb_network_protocol ( head_skb ) ; if ( unlikely ( ! proto ) ) return ERR_PTR ( - EINVAL ) ; csum = ! ! can_checksum_protocol ( features , proto ) ; __skb_push ( head_skb , doffset ) ; headroom = skb_headroom ( head_skb ) ; pos = skb_headlen ( head_skb ) ; do { struct sk_buff * nskb ; skb_frag_t * nskb_frag ; int hsize ; int size ; len = head_skb -> len - offset ; if ( len > mss ) len = mss ; hsize = skb_headlen ( head_skb ) - offset ; if ( hsize < 0 ) hsize = 0 ; if ( hsize > len || ! sg ) hsize = len ; if ( ! hsize && i >= nfrags && skb_headlen ( list_skb ) && ( skb_headlen ( list_skb ) == len || sg ) ) { BUG_ON ( skb_headlen ( list_skb ) > len ) ; i = 0 ; nfrags = skb_shinfo ( list_skb ) -> nr_frags ; frag = skb_shinfo ( list_skb ) -> frags ; <S2SV_StartBug> pos += skb_headlen ( list_skb ) ; <S2SV_EndBug> while ( pos < offset + len ) { BUG_ON ( i >= nfrags ) ; size = skb_frag_size ( frag ) ; if ( pos + size > offset + len ) break ; i ++ ; pos += size ; frag ++ ; } nskb = skb_clone ( list_skb , GFP_ATOMIC ) ; list_skb = list_skb -> next ; if ( unlikely ( ! nskb ) ) goto err ; if ( unlikely ( pskb_trim ( nskb , len ) ) ) { kfree_skb ( nskb ) ; goto err ; } hsize = skb_end_offset ( nskb ) ; if ( skb_cow_head ( nskb , doffset + headroom ) ) { kfree_skb ( nskb ) ; goto err ; } nskb -> truesize += skb_end_offset ( nskb ) - hsize ; skb_release_head_state ( nskb ) ; __skb_push ( nskb , doffset ) ; } else { nskb = __alloc_skb ( hsize + doffset + headroom , GFP_ATOMIC , skb_alloc_rx_flag ( head_skb ) , NUMA_NO_NODE ) ; if ( unlikely ( ! nskb ) ) goto err ; skb_reserve ( nskb , headroom ) ; __skb_put ( nskb , doffset ) ; } if ( segs ) tail -> next = nskb ; else segs = nskb ; tail = nskb ; __copy_skb_header ( nskb , head_skb ) ; nskb -> mac_len = head_skb -> mac_len ; skb_headers_offset_update ( nskb , skb_headroom ( nskb ) - headroom ) ; skb_copy_from_linear_data_offset ( head_skb , - tnl_hlen , nskb -> data - tnl_hlen , doffset + tnl_hlen ) ; if ( nskb -> len == len + doffset ) goto perform_csum_check ; if ( ! sg ) { nskb -> ip_summed = CHECKSUM_NONE ; nskb -> csum = skb_copy_and_csum_bits ( head_skb , offset , skb_put ( nskb , len ) , len , 0 ) ; continue ; } nskb_frag = skb_shinfo ( nskb ) -> frags ; skb_copy_from_linear_data_offset ( head_skb , offset , skb_put ( nskb , hsize ) , hsize ) ; skb_shinfo ( nskb ) -> tx_flags = skb_shinfo ( head_skb ) -> tx_flags & SKBTX_SHARED_FRAG ; while ( pos < offset + len ) { if ( i >= nfrags ) { BUG_ON ( skb_headlen ( list_skb ) ) ; i = 0 ; nfrags = skb_shinfo ( list_skb ) -> nr_frags ; frag = skb_shinfo ( list_skb ) -> frags ; <S2SV_StartBug> BUG_ON ( ! nfrags ) ; <S2SV_EndBug> list_skb = list_skb -> next ; } if ( unlikely ( skb_shinfo ( nskb ) -> nr_frags >= MAX_SKB_FRAGS ) ) { net_warn_ratelimited ( \"skb_segment:<S2SV_blank>too<S2SV_blank>many<S2SV_blank>frags:<S2SV_blank>%u<S2SV_blank>%u\\\\n\" , pos , mss ) ; goto err ; } <S2SV_StartBug> * nskb_frag = * frag ; <S2SV_EndBug> __skb_frag_ref ( nskb_frag ) ; size = skb_frag_size ( nskb_frag ) ; if ( pos < offset ) { nskb_frag -> page_offset += offset - pos ; skb_frag_size_sub ( nskb_frag , offset - pos ) ; } skb_shinfo ( nskb ) -> nr_frags ++ ; if ( pos + size <= offset + len ) { i ++ ; frag ++ ; pos += size ; } else { skb_frag_size_sub ( nskb_frag , pos + size - ( offset + len ) ) ; goto skip_fraglist ; } nskb_frag ++ ; } skip_fraglist : nskb -> data_len = len - hsize ; nskb -> len += nskb -> data_len ; nskb -> truesize += nskb -> data_len ; perform_csum_check : if ( ! csum ) { nskb -> csum = skb_checksum ( nskb , doffset , nskb -> len - doffset , 0 ) ; nskb -> ip_summed = CHECKSUM_NONE ; } } while ( ( offset += len ) < head_skb -> len ) ; return segs ; err : kfree_skb_list ( segs ) ; return ERR_PTR ( err ) ; }\n","target":"<S2SV_ModStart> ( head_skb ) ; struct sk_buff * frag_skb = head_skb <S2SV_ModStart> -> frags ; frag_skb = list_skb ; <S2SV_ModStart> -> frags ; frag_skb = list_skb ; <S2SV_ModStart> err ; } if ( unlikely ( skb_orphan_frags ( frag_skb , GFP_ATOMIC ) ) ) goto err ;\n","project_and_commit_id":"torvalds@linux/1fd819ecb90cc9b822cd84d3056ddba315d3340f","cve_id":"CVE-2014-0131","original_address":"https://github.com/torvalds/linux/commit/1fd819ecb90cc9b822cd84d3056ddba315d3340f","time":"2014-03-24T16:40Z"},
	{"Unnamed: 0":4450,"cwe_id":"CWE-264","source":"CWE-264 static int pppol2tp_getsockopt ( struct socket * sock , int level , int optname , char __user * optval , int __user * optlen ) { struct sock * sk = sock -> sk ; struct l2tp_session * session ; struct l2tp_tunnel * tunnel ; int val , len ; int err ; struct pppol2tp_session * ps ; if ( level != SOL_PPPOL2TP ) <S2SV_StartBug> return udp_prot . getsockopt ( sk , level , optname , optval , optlen ) ; <S2SV_EndBug> if ( get_user ( len , optlen ) ) return - EFAULT ; len = min_t ( unsigned int , len , sizeof ( int ) ) ; if ( len < 0 ) return - EINVAL ; err = - ENOTCONN ; if ( sk -> sk_user_data == NULL ) goto end ; err = - EBADF ; session = pppol2tp_sock_to_session ( sk ) ; if ( session == NULL ) goto end ; ps = l2tp_session_priv ( session ) ; if ( ( session -> session_id == 0 ) && ( session -> peer_session_id == 0 ) ) { err = - EBADF ; tunnel = l2tp_sock_to_tunnel ( ps -> tunnel_sock ) ; if ( tunnel == NULL ) goto end_put_sess ; err = pppol2tp_tunnel_getsockopt ( sk , tunnel , optname , & val ) ; sock_put ( ps -> tunnel_sock ) ; } else err = pppol2tp_session_getsockopt ( sk , session , optname , & val ) ; err = - EFAULT ; if ( put_user ( len , optlen ) ) goto end_put_sess ; if ( copy_to_user ( ( void __user * ) optval , & val , len ) ) goto end_put_sess ; err = 0 ; end_put_sess : sock_put ( sk ) ; end : return err ; }\n","target":"<S2SV_ModStart> SOL_PPPOL2TP ) return - EINVAL <S2SV_ModEnd> ; if (\n","project_and_commit_id":"torvalds@linux/3cf521f7dc87c031617fd47e4b7aa2593c2f3daf","cve_id":"CVE-2014-4943","original_address":"https://github.com/torvalds/linux/commit/3cf521f7dc87c031617fd47e4b7aa2593c2f3daf","time":"2014-07-19T19:55Z"},
	{"Unnamed: 0":568,"cwe_id":"CWE-000","source":"CWE-000 static int ras_putdatastd ( jas_stream_t * out , ras_hdr_t * hdr , jas_image_t * image , int numcmpts , int * cmpts ) { int rowsize ; int pad ; unsigned int z ; int nz ; int c ; int x ; int y ; int v ; jas_matrix_t * data [ 3 ] ; int i ; <S2SV_StartBug> for ( i = 0 ; i < numcmpts ; ++ i ) { <S2SV_EndBug> <S2SV_StartBug> data [ i ] = jas_matrix_create ( jas_image_height ( image ) , jas_image_width ( image ) ) ; <S2SV_EndBug> assert ( data [ i ] ) ; } rowsize = RAS_ROWSIZE ( hdr ) ; pad = rowsize - ( hdr -> width * hdr -> depth + 7 ) / 8 ; hdr -> length = hdr -> height * rowsize ; for ( y = 0 ; y < hdr -> height ; y ++ ) { for ( i = 0 ; i < numcmpts ; ++ i ) { if ( jas_image_readcmpt ( image , cmpts [ i ] , 0 , y , jas_image_width ( image ) , 1 , data [ i ] ) ) { <S2SV_StartBug> return - 1 ; <S2SV_EndBug> } } z = 0 ; nz = 0 ; for ( x = 0 ; x < hdr -> width ; x ++ ) { z <<= hdr -> depth ; if ( RAS_ISRGB ( hdr ) ) { v = RAS_RED ( ( jas_matrix_getv ( data [ 0 ] , x ) ) ) | RAS_GREEN ( ( jas_matrix_getv ( data [ 1 ] , x ) ) ) | RAS_BLUE ( ( jas_matrix_getv ( data [ 2 ] , x ) ) ) ; } else { v = ( jas_matrix_getv ( data [ 0 ] , x ) ) ; } z |= v & RAS_ONES ( hdr -> depth ) ; nz += hdr -> depth ; while ( nz >= 8 ) { c = ( z >> ( nz - 8 ) ) & 0xff ; if ( jas_stream_putc ( out , c ) == EOF ) { <S2SV_StartBug> return - 1 ; <S2SV_EndBug> } <S2SV_StartBug> nz -= 8 ; <S2SV_EndBug> z &= RAS_ONES ( nz ) ; } } if ( nz > 0 ) { c = ( z >> ( 8 - nz ) ) & RAS_ONES ( nz ) ; if ( jas_stream_putc ( out , c ) == EOF ) { return - 1 ; } } if ( pad % 2 ) { if ( jas_stream_putc ( out , 0 ) == EOF ) { return - 1 ; } } } for ( i = 0 ; i < numcmpts ; ++ i ) { jas_matrix_destroy ( data [ i ] ) ; } return 0 ; }\n","target":"<S2SV_ModStart> int i ; assert ( numcmpts <= 3 ) ; for ( i = 0 ; i < 3 ; ++ i ) { data [ i ] = 0 ; } <S2SV_ModStart> i ) { if ( ! ( <S2SV_ModStart> image ) ) ) ) { goto error ; } <S2SV_ModEnd> } rowsize = <S2SV_ModStart> ) ) { goto error <S2SV_ModEnd> ; } } <S2SV_ModStart> EOF ) { goto error ; } nz -= 8 ; z &= RAS_ONES ( nz ) ; } } if ( nz > 0 ) { c = ( z >> ( 8 - nz ) ) & RAS_ONES ( nz ) ; if ( jas_stream_putc ( out , c ) == EOF ) { goto error ; } } if ( pad % 2 ) { if ( jas_stream_putc ( out , 0 ) == EOF ) { goto error ; } } } for ( i = 0 ; i < numcmpts ; ++ i ) { jas_matrix_destroy ( data [ i ] ) ; data [ i ] = 0 ; } return 0 ; error : for ( i = 0 ; i < numcmpts ; ++ i ) { if ( data [ i ] ) { jas_matrix_destroy ( data [ i ] ) ; } } <S2SV_ModStart> 1 ; } <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null>\n","project_and_commit_id":"mdadams@jasper/411a4068f8c464e883358bf403a3e25158863823","cve_id":"CVE-2016-9388","original_address":"https://github.com/mdadams/jasper/commit/411a4068f8c464e883358bf403a3e25158863823","time":"2017-03-23T18:59Z"},
	{"Unnamed: 0":159,"cwe_id":"CWE-125","source":"CWE-125 void __sock_recv_timestamp ( struct msghdr * msg , struct sock * sk , struct sk_buff * skb ) { int need_software_tstamp = sock_flag ( sk , SOCK_RCVTSTAMP ) ; struct scm_timestamping tss ; int empty = 1 ; struct skb_shared_hwtstamps * shhwtstamps = skb_hwtstamps ( skb ) ; if ( need_software_tstamp && skb -> tstamp == 0 ) __net_timestamp ( skb ) ; if ( need_software_tstamp ) { if ( ! sock_flag ( sk , SOCK_RCVTSTAMPNS ) ) { struct timeval tv ; skb_get_timestamp ( skb , & tv ) ; put_cmsg ( msg , SOL_SOCKET , SCM_TIMESTAMP , sizeof ( tv ) , & tv ) ; } else { struct timespec ts ; skb_get_timestampns ( skb , & ts ) ; put_cmsg ( msg , SOL_SOCKET , SCM_TIMESTAMPNS , sizeof ( ts ) , & ts ) ; } } memset ( & tss , 0 , sizeof ( tss ) ) ; if ( ( sk -> sk_tsflags & SOF_TIMESTAMPING_SOFTWARE ) && ktime_to_timespec_cond ( skb -> tstamp , tss . ts + 0 ) ) empty = 0 ; if ( shhwtstamps && ( sk -> sk_tsflags & SOF_TIMESTAMPING_RAW_HARDWARE ) && ktime_to_timespec_cond ( shhwtstamps -> hwtstamp , tss . ts + 2 ) ) empty = 0 ; if ( ! empty ) { put_cmsg ( msg , SOL_SOCKET , SCM_TIMESTAMPING , sizeof ( tss ) , & tss ) ; <S2SV_StartBug> if ( skb -> len && ( sk -> sk_tsflags & SOF_TIMESTAMPING_OPT_STATS ) ) <S2SV_EndBug> put_cmsg ( msg , SOL_SOCKET , SCM_TIMESTAMPING_OPT_STATS , skb -> len , skb -> data ) ; } }\n","target":"<S2SV_ModStart> ; if ( skb_is_err_queue ( skb ) &&\n","project_and_commit_id":"torvalds@linux/8605330aac5a5785630aec8f64378a54891937cc","cve_id":"CVE-2017-7277","original_address":"https://github.com/torvalds/linux/commit/8605330aac5a5785630aec8f64378a54891937cc","time":"2017-03-28T06:59Z"},
	{"Unnamed: 0":6286,"cwe_id":"CWE-415","source":"CWE-415 int sc_file_set_sec_attr ( sc_file_t * file , const u8 * sec_attr , size_t sec_attr_len ) { u8 * tmp ; if ( ! sc_file_valid ( file ) ) { return SC_ERROR_INVALID_ARGUMENTS ; } <S2SV_StartBug> if ( sec_attr == NULL ) { <S2SV_EndBug> if ( file -> sec_attr != NULL ) free ( file -> sec_attr ) ; file -> sec_attr = NULL ; file -> sec_attr_len = 0 ; return 0 ; } tmp = ( u8 * ) realloc ( file -> sec_attr , sec_attr_len ) ; if ( ! tmp ) { if ( file -> sec_attr ) free ( file -> sec_attr ) ; file -> sec_attr = NULL ; file -> sec_attr_len = 0 ; return SC_ERROR_OUT_OF_MEMORY ; } file -> sec_attr = tmp ; memcpy ( file -> sec_attr , sec_attr , sec_attr_len ) ; file -> sec_attr_len = sec_attr_len ; return 0 ; }\n","target":"<S2SV_ModStart> sec_attr == NULL || sec_attr_len\n","project_and_commit_id":"OpenSC@OpenSC/360e95d45ac4123255a4c796db96337f332160ad","cve_id":"CVE-2018-16425","original_address":"https://github.com/OpenSC/OpenSC/commit/360e95d45ac4123255a4c796db96337f332160ad","time":"2018-09-04T00:29Z"},
	{"Unnamed: 0":5195,"cwe_id":"CWE-20","source":"CWE-20 error_t ipStringToAddr ( const char_t * str , IpAddr * ipAddr ) { error_t error ; # if ( IPV6_SUPPORT == ENABLED ) <S2SV_StartBug> if ( strchr ( str , ':' ) ) <S2SV_EndBug> { ipAddr -> length = sizeof ( Ipv6Addr ) ; error = ipv6StringToAddr ( str , & ipAddr -> ipv6Addr ) ; } else # endif # if ( IPV4_SUPPORT == ENABLED ) <S2SV_StartBug> if ( strchr ( str , '.' ) ) <S2SV_EndBug> { ipAddr -> length = sizeof ( Ipv4Addr ) ; error = ipv4StringToAddr ( str , & ipAddr -> ipv4Addr ) ; } else # endif { error = ERROR_FAILURE ; } return error ; }\n","target":"<S2SV_ModStart> ) if ( osStrchr <S2SV_ModEnd> ( str , <S2SV_ModStart> , ':' ) != NULL <S2SV_ModStart> ) if ( osStrchr <S2SV_ModEnd> ( str , <S2SV_ModStart> , '.' ) != NULL\n","project_and_commit_id":"Oryx-Embedded@CycloneTCP/de5336016edbe1e90327d0ed1cba5c4e49114366","cve_id":"CVE-2021-26788","original_address":"https://github.com/Oryx-Embedded/CycloneTCP/commit/de5336016edbe1e90327d0ed1cba5c4e49114366","time":"2021-03-08T13:15Z"},
	{"Unnamed: 0":2158,"cwe_id":"CWE-399","source":"CWE-399 <S2SV_StartBug> static void ip6_append_data_mtu ( int * mtu , <S2SV_EndBug> int * maxfraglen , unsigned int fragheaderlen , struct sk_buff * skb , <S2SV_StartBug> struct rt6_info * rt ) <S2SV_EndBug> { if ( ! ( rt -> dst . flags & DST_XFRM_TUNNEL ) ) { if ( skb == NULL ) { * mtu = * mtu - rt -> dst . header_len ; } else { <S2SV_StartBug> * mtu = dst_mtu ( rt -> dst . path ) ; <S2SV_EndBug> } * maxfraglen = ( ( * mtu - fragheaderlen ) & ~ 7 ) + fragheaderlen - sizeof ( struct frag_hdr ) ; } }\n","target":"<S2SV_ModStart> void ip6_append_data_mtu ( unsigned <S2SV_ModStart> rt6_info * rt , bool pmtuprobe <S2SV_ModStart> * mtu = min ( * mtu , pmtuprobe ? rt -> dst . dev -> mtu : <S2SV_ModStart> dst . path )\n","project_and_commit_id":"torvalds@linux/75a493e60ac4bbe2e977e7129d6d8cbb0dd236be","cve_id":"CVE-2013-4163","original_address":"https://github.com/torvalds/linux/commit/75a493e60ac4bbe2e977e7129d6d8cbb0dd236be","time":"2013-07-29T13:59Z"},
	{"Unnamed: 0":3891,"cwe_id":"CWE-000","source":"CWE-000 <S2SV_StartBug> static ssize_t aio_setup_single_vector ( struct kiocb * kiocb ) <S2SV_EndBug> <S2SV_StartBug> { <S2SV_EndBug> kiocb -> ki_iovec = & kiocb -> ki_inline_vec ; kiocb -> ki_iovec -> iov_base = kiocb -> ki_buf ; <S2SV_StartBug> kiocb -> ki_iovec -> iov_len = kiocb -> ki_left ; <S2SV_EndBug> kiocb -> ki_nr_segs = 1 ; kiocb -> ki_cur_seg = 0 ; return 0 ; }\n","target":"<S2SV_ModStart> ssize_t aio_setup_single_vector ( int type , struct file * file , <S2SV_ModStart> kiocb ) { int bytes ; bytes = rw_verify_area ( type , file , & kiocb -> ki_pos , kiocb -> ki_left ) ; if ( bytes < 0 ) return bytes ; <S2SV_ModStart> -> iov_len = bytes <S2SV_ModEnd> ; kiocb ->\n","project_and_commit_id":"torvalds@linux/a70b52ec1aaeaf60f4739edb1b422827cb6f3893","cve_id":"CVE-2012-6701","original_address":"https://github.com/torvalds/linux/commit/a70b52ec1aaeaf60f4739edb1b422827cb6f3893","time":"2016-05-02T10:59Z"},
	{"Unnamed: 0":3515,"cwe_id":"CWE-119","source":"CWE-119 <S2SV_StartBug> static bool <S2SV_EndBug> ChunkedDecode ( Request * reqPtr , bool update ) { const Tcl_DString * bufPtr ; const char * end , * chunkStart ; <S2SV_StartBug> bool success = NS_TRUE ; <S2SV_EndBug> NS_NONNULL_ASSERT ( reqPtr != NULL ) ; bufPtr = & reqPtr -> buffer ; end = bufPtr -> string + bufPtr -> length ; chunkStart = bufPtr -> string + reqPtr -> chunkStartOff ; while ( reqPtr -> chunkStartOff < ( size_t ) bufPtr -> length ) { char * p = strstr ( chunkStart , \"\\\\r\\\\n\" ) ; <S2SV_StartBug> size_t chunk_length ; <S2SV_EndBug> if ( p == NULL ) { Ns_Log ( DriverDebug , \"ChunkedDecode:<S2SV_blank>chunk<S2SV_blank>did<S2SV_blank>not<S2SV_blank>find<S2SV_blank>end-of-line\" ) ; <S2SV_StartBug> success = NS_FALSE ; <S2SV_EndBug> break ; } * p = '\\\\0' ; <S2SV_StartBug> chunk_length = ( size_t ) strtol ( chunkStart , NULL , 16 ) ; <S2SV_EndBug> * p = '\\\\r' ; <S2SV_StartBug> if ( p + 2 + chunk_length > end ) { <S2SV_EndBug> Ns_Log ( DriverDebug , \"ChunkedDecode:<S2SV_blank>chunk<S2SV_blank>length<S2SV_blank>past<S2SV_blank>end<S2SV_blank>of<S2SV_blank>buffer\" ) ; <S2SV_StartBug> success = NS_FALSE ; <S2SV_EndBug> break ; } if ( update ) { char * writeBuffer = bufPtr -> string + reqPtr -> chunkWriteOff ; <S2SV_StartBug> memmove ( writeBuffer , p + 2 , chunk_length ) ; <S2SV_EndBug> <S2SV_StartBug> reqPtr -> chunkWriteOff += chunk_length ; <S2SV_EndBug> <S2SV_StartBug> * ( writeBuffer + chunk_length ) = '\\\\0' ; <S2SV_EndBug> } <S2SV_StartBug> reqPtr -> chunkStartOff += ( size_t ) ( p - chunkStart ) + 4u + chunk_length ; <S2SV_EndBug> chunkStart = bufPtr -> string + reqPtr -> chunkStartOff ; } <S2SV_StartBug> return success ; <S2SV_EndBug> }\n","target":"<S2SV_ModStart> <S2SV_null> <S2SV_null> static SockState <S2SV_ModEnd> ChunkedDecode ( Request <S2SV_ModStart> * chunkStart ; SockState result = SOCK_READY <S2SV_ModEnd> ; NS_NONNULL_ASSERT ( <S2SV_ModStart> \"\\\\r\\\\n\" ) ; long chunkLength <S2SV_ModEnd> ; if ( <S2SV_ModStart> \"ChunkedDecode:<S2SV_blank>chunk<S2SV_blank>did<S2SV_blank>not<S2SV_blank>find<S2SV_blank>end-of-line\" ) ; result = SOCK_MORE <S2SV_ModEnd> ; break ; <S2SV_ModStart> = '\\\\0' ; chunkLength = <S2SV_ModEnd> strtol ( chunkStart <S2SV_ModStart> ; if ( chunkLength < 0 ) { Ns_Log ( Warning , \"ChunkedDecode:<S2SV_blank>negative<S2SV_blank>chunk<S2SV_blank>length\" ) ; result = SOCK_BADREQUEST ; break ; } * p = '\\\\r' ; if ( <S2SV_ModStart> + 2 + chunkLength <S2SV_ModEnd> > end ) <S2SV_ModStart> \"ChunkedDecode:<S2SV_blank>chunk<S2SV_blank>length<S2SV_blank>past<S2SV_blank>end<S2SV_blank>of<S2SV_blank>buffer\" ) ; result = SOCK_MORE <S2SV_ModEnd> ; break ; <S2SV_ModStart> + 2 , ( size_t ) chunkLength <S2SV_ModEnd> ) ; reqPtr <S2SV_ModStart> -> chunkWriteOff += ( size_t ) chunkLength <S2SV_ModEnd> ; * ( <S2SV_ModStart> ( writeBuffer + chunkLength <S2SV_ModEnd> ) = '\\\\0' <S2SV_ModStart> + 4u + ( size_t ) chunkLength <S2SV_ModEnd> ; chunkStart = <S2SV_ModStart> ; } return result <S2SV_ModEnd> ; } <S2SV_null>\n","project_and_commit_id":"naviserver@naviserver/a5c3079f1d8996d5f34c9384a440acf3519ca3bb","cve_id":"CVE-2020-13111","original_address":"https://bitbucket.org/naviserver/naviserver/commit/a5c3079f1d8996d5f34c9384a440acf3519ca3bb","time":"2020-05-16T15:15Z"},
	{"Unnamed: 0":1028,"cwe_id":"CWE-552","source":"CWE-552 static ssize_t _hostsock_writev ( oe_fd_t * desc , const struct oe_iovec * iov , int iovcnt ) { ssize_t ret = - 1 ; sock_t * sock = _cast_sock ( desc ) ; void * buf = NULL ; <S2SV_StartBug> size_t buf_size = 0 ; <S2SV_EndBug> if ( ! sock || ! iov || iovcnt < 0 || iovcnt > OE_IOV_MAX ) OE_RAISE_ERRNO ( OE_EINVAL ) ; <S2SV_StartBug> if ( oe_iov_pack ( iov , iovcnt , & buf , & buf_size ) != 0 ) <S2SV_EndBug> <S2SV_StartBug> OE_RAISE_ERRNO ( OE_ENOMEM ) ; <S2SV_EndBug> if ( oe_syscall_sendv_ocall ( & ret , sock -> host_fd , buf , iovcnt , buf_size ) != OE_OK ) { OE_RAISE_ERRNO ( OE_EINVAL ) ; } <S2SV_StartBug> done : <S2SV_EndBug> if ( buf ) oe_free ( buf ) ; return ret ; }\n","target":"<S2SV_ModStart> ; size_t buf_size = 0 ; size_t data_size <S2SV_ModStart> , & buf_size , & data_size <S2SV_ModStart> OE_RAISE_ERRNO ( OE_ENOMEM ) ; if ( data_size > OE_SSIZE_MAX ) OE_RAISE_ERRNO ( OE_EINVAL <S2SV_ModStart> ) ; } if ( ret > ( ssize_t ) data_size ) { ret = - 1 ; OE_RAISE_ERRNO ( OE_EINVAL ) ; }\n","project_and_commit_id":"openenclave@openenclave/bcac8e7acb514429fee9e0b5d0c7a0308fd4d76b","cve_id":"CVE-2020-15224","original_address":"https://github.com/openenclave/openenclave/commit/bcac8e7acb514429fee9e0b5d0c7a0308fd4d76b","time":"2020-10-14T19:15Z"},
	{"Unnamed: 0":264,"cwe_id":"CWE-787","source":"CWE-787 void * adminchild ( struct clientparam * param ) { int i , res ; char * buf ; char username [ 256 ] ; char * sb ; char * req = NULL ; struct printparam pp ; <S2SV_StartBug> int contentlen = 0 ; <S2SV_EndBug> int isform = 0 ; pp . inbuf = 0 ; pp . cp = param ; buf = myalloc ( LINESIZE ) ; if ( ! buf ) { RETURN ( 555 ) ; } i = sockgetlinebuf ( param , CLIENT , ( unsigned char * ) buf , LINESIZE - 1 , '\\\\n' , conf . timeouts [ STRING_S ] ) ; if ( i < 5 || ( ( buf [ 0 ] != 'G' || buf [ 1 ] != 'E' || buf [ 2 ] != 'T' || buf [ 3 ] != '<S2SV_blank>' || buf [ 4 ] != '/' ) && ( buf [ 0 ] != 'P' || buf [ 1 ] != 'O' || buf [ 2 ] != 'S' || buf [ 3 ] != 'T' || buf [ 4 ] != '<S2SV_blank>' || buf [ 5 ] != '/' ) ) ) { RETURN ( 701 ) ; } buf [ i ] = 0 ; sb = strchr ( buf + 5 , '<S2SV_blank>' ) ; if ( ! sb ) { RETURN ( 702 ) ; } * sb = 0 ; req = mystrdup ( buf + ( ( * buf == 'P' ) ? 6 : 5 ) ) ; while ( ( i = sockgetlinebuf ( param , CLIENT , ( unsigned char * ) buf , LINESIZE - 1 , '\\\\n' , conf . timeouts [ STRING_S ] ) ) > 2 ) { buf [ i ] = 0 ; if ( i > 19 && ( ! strncasecmp ( buf , \"authorization\" , 13 ) ) ) { sb = strchr ( buf , ':' ) ; if ( ! sb ) continue ; ++ sb ; while ( isspace ( * sb ) ) sb ++ ; if ( ! * sb || strncasecmp ( sb , \"basic\" , 5 ) ) { continue ; } sb += 5 ; while ( isspace ( * sb ) ) sb ++ ; i = de64 ( ( unsigned char * ) sb , ( unsigned char * ) username , 255 ) ; if ( i <= 0 ) continue ; username [ i ] = 0 ; sb = strchr ( ( char * ) username , ':' ) ; if ( sb ) { * sb = 0 ; if ( param -> password ) myfree ( param -> password ) ; param -> password = ( unsigned char * ) mystrdup ( sb + 1 ) ; } if ( param -> username ) myfree ( param -> username ) ; param -> username = ( unsigned char * ) mystrdup ( username ) ; continue ; } else if ( i > 15 && ( ! strncasecmp ( buf , \"content-length:\" , 15 ) ) ) { sb = buf + 15 ; while ( isspace ( * sb ) ) sb ++ ; <S2SV_StartBug> contentlen = atoi ( sb ) ; <S2SV_EndBug> } else if ( i > 13 && ( ! strncasecmp ( buf , \"content-type:\" , 13 ) ) ) { sb = buf + 13 ; while ( isspace ( * sb ) ) sb ++ ; if ( ! strncasecmp ( sb , \"x-www-form-urlencoded\" , 21 ) ) isform = 1 ; } } param -> operation = ADMIN ; if ( isform && contentlen ) { printstr ( & pp , \"HTTP/1.0<S2SV_blank>100<S2SV_blank>Continue\\\\r\\\\n\\\\r\\\\n\" ) ; stdpr ( & pp , NULL , 0 ) ; } res = ( * param -> srv -> authfunc ) ( param ) ; if ( res && res != 10 ) { printstr ( & pp , authreq ) ; RETURN ( res ) ; } if ( param -> srv -> singlepacket || param -> redirected ) { if ( * req == 'C' ) req [ 1 ] = 0 ; else * req = 0 ; } sprintf ( buf , ok , conf . stringtable ? ( char * ) conf . stringtable [ 2 ] : \"3proxy\" , conf . stringtable ? ( char * ) conf . stringtable [ 2 ] : \"3[APA3A]<S2SV_blank>tiny<S2SV_blank>proxy\" , conf . stringtable ? ( char * ) conf . stringtable [ 3 ] : \"\" ) ; if ( * req != 'S' ) printstr ( & pp , buf ) ; switch ( * req ) { case 'C' : printstr ( & pp , counters ) ; { struct trafcount * cp ; int num = 0 ; for ( cp = conf . trafcounter ; cp ; cp = cp -> next , num ++ ) { int inbuf = 0 ; if ( cp -> ace && ( param -> srv -> singlepacket || param -> redirected ) ) { if ( ! ACLmatches ( cp -> ace , param ) ) continue ; } if ( req [ 1 ] == 'S' && atoi ( req + 2 ) == num ) cp -> disabled = 0 ; if ( req [ 1 ] == 'D' && atoi ( req + 2 ) == num ) cp -> disabled = 1 ; inbuf += sprintf ( buf , \"<tr>\" \"<td>%s</td><td><A<S2SV_blank>HREF=\\\\\\'/C%c%d\\\\\\'>%s</A></td><td>\" , ( cp -> comment ) ? cp -> comment : \"&nbsp;\" , ( cp -> disabled ) ? 'S' : 'D' , num , ( cp -> disabled ) ? \"NO\" : \"YES\" ) ; if ( ! cp -> ace || ! cp -> ace -> users ) { inbuf += sprintf ( buf + inbuf , \"<center>ANY</center>\" ) ; } else { inbuf += printuserlist ( buf + inbuf , LINESIZE - 800 , cp -> ace -> users , \",<br<S2SV_blank>/>\\\\r\\\\n\" ) ; } inbuf += sprintf ( buf + inbuf , \"</td><td>\" ) ; if ( ! cp -> ace || ! cp -> ace -> src ) { inbuf += sprintf ( buf + inbuf , \"<center>ANY</center>\" ) ; } else { inbuf += printiplist ( buf + inbuf , LINESIZE - 512 , cp -> ace -> src , \",<br<S2SV_blank>/>\\\\r\\\\n\" ) ; } inbuf += sprintf ( buf + inbuf , \"</td><td>\" ) ; if ( ! cp -> ace || ! cp -> ace -> dst ) { inbuf += sprintf ( buf + inbuf , \"<center>ANY</center>\" ) ; } else { inbuf += printiplist ( buf + inbuf , LINESIZE - 512 , cp -> ace -> dst , \",<br<S2SV_blank>/>\\\\r\\\\n\" ) ; } inbuf += sprintf ( buf + inbuf , \"</td><td>\" ) ; if ( ! cp -> ace || ! cp -> ace -> ports ) { inbuf += sprintf ( buf + inbuf , \"<center>ANY</center>\" ) ; } else { inbuf += printportlist ( buf + inbuf , LINESIZE - 128 , cp -> ace -> ports , \",<br<S2SV_blank>/>\\\\r\\\\n\" ) ; } if ( cp -> type == NONE ) { inbuf += sprintf ( buf + inbuf , \"</td><td<S2SV_blank>colspan=\\\\\\'6\\\\\\'<S2SV_blank>align=\\\\\\'center\\\\\\'>exclude<S2SV_blank>from<S2SV_blank>limitation</td></tr>\\\\r\\\\n\" ) ; } else { inbuf += sprintf ( buf + inbuf , \"</td><td>%\" PRINTF_INT64_MODIFIER \"u</td>\" \"<td>MB%s</td>\" \"<td>%\" PRINTF_INT64_MODIFIER \"u</td>\" \"<td>%s</td>\" , cp -> traflim64 / ( 1024 * 1024 ) , rotations [ cp -> type ] , cp -> traf64 , cp -> cleared ? ctime ( & cp -> cleared ) : \"never\" ) ; inbuf += sprintf ( buf + inbuf , \"<td>%s</td>\" \"<td>%i</td>\" \"</tr>\\\\r\\\\n\" , cp -> updated ? ctime ( & cp -> updated ) : \"never\" , cp -> number ) ; } printstr ( & pp , buf ) ; } } printstr ( & pp , counterstail ) ; break ; case 'R' : conf . needreload = 1 ; printstr ( & pp , \"<h3>Reload<S2SV_blank>scheduled</h3>\" ) ; break ; case 'S' : { if ( req [ 1 ] == 'X' ) { printstr ( & pp , style ) ; break ; } printstr ( & pp , xml ) ; printval ( conf . services , TYPE_SERVER , 0 , & pp ) ; printstr ( & pp , postxml ) ; } break ; case 'F' : { FILE * fp ; char buf [ 256 ] ; fp = confopen ( ) ; if ( ! fp ) { printstr ( & pp , \"<h3><font<S2SV_blank>color=\\\\\"red\\\\\">Failed<S2SV_blank>to<S2SV_blank>open<S2SV_blank>config<S2SV_blank>file</font></h3>\" ) ; break ; } printstr ( & pp , \"<h3>Please<S2SV_blank>be<S2SV_blank>careful<S2SV_blank>editing<S2SV_blank>config<S2SV_blank>file<S2SV_blank>remotely</h3>\" ) ; <S2SV_StartBug> printstr ( & pp , \"<form<S2SV_blank>method=\\\\\"POST\\\\\"<S2SV_blank>action=\\\\\"/U\\\\\"><textarea<S2SV_blank>cols=\\\\\"80\\\\\"<S2SV_blank>rows=\\\\\"30\\\\\"<S2SV_blank>name=\\\\\"conffile\\\\\">\" ) ; <S2SV_EndBug> while ( fgets ( buf , 256 , fp ) ) { printstr ( & pp , buf ) ; } if ( ! writable ) fclose ( fp ) ; printstr ( & pp , \"</textarea><br><input<S2SV_blank>type=\\\\\"Submit\\\\\"></form>\" ) ; break ; } case 'U' : { <S2SV_StartBug> int l = 0 ; <S2SV_EndBug> int error = 0 ; <S2SV_StartBug> if ( ! writable || fseek ( writable , 0 , 0 ) ) { <S2SV_EndBug> error = 1 ; } <S2SV_StartBug> while ( ( i = sockgetlinebuf ( param , CLIENT , ( unsigned char * ) buf , LINESIZE - 1 , '+' , conf . timeouts [ STRING_S ] ) ) > 0 ) { <S2SV_EndBug> if ( i > ( contentlen - l ) ) i = ( contentlen - l ) ; <S2SV_StartBug> buf [ i ] = 0 ; <S2SV_EndBug> if ( ! l ) { if ( strncasecmp ( buf , \"conffile=\" , 9 ) ) error = 1 ; } <S2SV_StartBug> if ( ! error ) { <S2SV_EndBug> decodeurl ( ( unsigned char * ) buf , 1 ) ; fprintf ( writable , \"%s\" , l ? buf : buf + 9 ) ; } <S2SV_StartBug> l += i ; <S2SV_EndBug> if ( l >= contentlen ) break ; } if ( writable && ! error ) { fflush ( writable ) ; # ifndef _WINCE ftruncate ( fileno ( writable ) , ftell ( writable ) ) ; # endif } printstr ( & pp , error ? \"<h3><font<S2SV_blank>color=\\\\\"red\\\\\">Config<S2SV_blank>file<S2SV_blank>is<S2SV_blank>not<S2SV_blank>writable</font></h3>Make<S2SV_blank>sure<S2SV_blank>you<S2SV_blank>have<S2SV_blank>\\\\\"writable\\\\\"<S2SV_blank>command<S2SV_blank>in<S2SV_blank>configuration<S2SV_blank>file\" : \"<h3>Configuration<S2SV_blank>updated</h3>\" ) ; } break ; default : printstr ( & pp , ( char * ) conf . stringtable [ WEBBANNERS ] ) ; break ; } if ( * req != 'S' ) printstr ( & pp , tail ) ; CLEANRET : printstr ( & pp , NULL ) ; if ( buf ) myfree ( buf ) ; ( * param -> srv -> logfunc ) ( param , ( unsigned char * ) req ) ; if ( req ) myfree ( req ) ; freeparam ( param ) ; return ( NULL ) ; }\n","target":"<S2SV_ModStart> printparam pp ; unsigned <S2SV_ModEnd> contentlen = 0 <S2SV_ModStart> sb ++ ; sscanf ( sb , \"%u\" , & contentlen ) ; if ( contentlen > LINESIZE * 1024 ) contentlen = 0 <S2SV_ModEnd> ; } else <S2SV_ModStart> & pp , \"<form<S2SV_blank>method=\\\\\"POST\\\\\"<S2SV_blank>action=\\\\\"/U\\\\\"<S2SV_blank>enctype=\\\\\"application/x-www-form-urlencoded\\\\\"><textarea<S2SV_blank>cols=\\\\\"80\\\\\"<S2SV_blank>rows=\\\\\"30\\\\\"<S2SV_blank>name=\\\\\"conffile\\\\\">\" <S2SV_ModEnd> ) ; while <S2SV_ModStart> 'U' : { unsigned <S2SV_ModEnd> l = 0 <S2SV_ModStart> ! writable || ! contentlen || <S2SV_ModStart> } while ( l < contentlen && <S2SV_ModStart> ) buf , ( contentlen - l ) > <S2SV_ModStart> LINESIZE - 1 ? LINESIZE - 1 : contentlen - l <S2SV_ModStart> l ) ; if ( ! l ) { if ( i < 9 || <S2SV_ModEnd> strncasecmp ( buf <S2SV_ModStart> error ) { buf [ i ] = 0 ; <S2SV_ModStart> l += i <S2SV_ModEnd> ; } if\n","project_and_commit_id":"z3APA3A@3proxy/3b67dc844789dc0f00e934270c7b349bcb547865","cve_id":"CVE-2019-14495","original_address":"https://github.com/z3APA3A/3proxy/commit/3b67dc844789dc0f00e934270c7b349bcb547865","time":"2019-08-01T17:15Z"},
	{"Unnamed: 0":5043,"cwe_id":"CWE-119","source":"CWE-119 void vp9_rc_set_frame_target ( VP9_COMP * cpi , int target ) { const VP9_COMMON * const cm = & cpi -> common ; RATE_CONTROL * const rc = & cpi -> rc ; rc -> this_frame_target = target ; <S2SV_StartBug> rc -> sb64_target_rate = ( ( int64_t ) rc -> this_frame_target * 64 * 64 ) / <S2SV_EndBug> ( cm -> width * cm -> height ) ; }\n","target":"<S2SV_ModStart> = target ; if ( cpi -> oxcf . resize_mode == RESIZE_DYNAMIC && rc -> frame_size_selector != UNSCALED ) rc -> this_frame_target = ( int ) ( rc -> this_frame_target * rate_thresh_mult [ rc -> frame_size_selector ] ) ;\n","project_and_commit_id":"external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426","cve_id":"CVE-2016-1621","original_address":"https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426","time":"2016-03-12T21:59Z"},
	{"Unnamed: 0":2665,"cwe_id":"CWE-19","source":"CWE-19 static int ext2_xattr_list ( struct dentry * dentry , char * buffer , size_t buffer_size ) { struct inode * inode = d_inode ( dentry ) ; struct buffer_head * bh = NULL ; struct ext2_xattr_entry * entry ; char * end ; size_t rest = buffer_size ; <S2SV_StartBug> int error ; <S2SV_EndBug> ea_idebug ( inode , \"buffer=%p,<S2SV_blank>buffer_size=%ld\" , buffer , ( long ) buffer_size ) ; down_read ( & EXT2_I ( inode ) -> xattr_sem ) ; error = 0 ; if ( ! EXT2_I ( inode ) -> i_file_acl ) goto cleanup ; ea_idebug ( inode , \"reading<S2SV_blank>block<S2SV_blank>%d\" , EXT2_I ( inode ) -> i_file_acl ) ; bh = sb_bread ( inode -> i_sb , EXT2_I ( inode ) -> i_file_acl ) ; error = - EIO ; if ( ! bh ) goto cleanup ; ea_bdebug ( bh , \"b_count=%d,<S2SV_blank>refcount=%d\" , atomic_read ( & ( bh -> b_count ) ) , le32_to_cpu ( HDR ( bh ) -> h_refcount ) ) ; end = bh -> b_data + bh -> b_size ; if ( HDR ( bh ) -> h_magic != cpu_to_le32 ( EXT2_XATTR_MAGIC ) || HDR ( bh ) -> h_blocks != cpu_to_le32 ( 1 ) ) { bad_block : ext2_error ( inode -> i_sb , \"ext2_xattr_list\" , \"inode<S2SV_blank>%ld:<S2SV_blank>bad<S2SV_blank>block<S2SV_blank>%d\" , inode -> i_ino , EXT2_I ( inode ) -> i_file_acl ) ; error = - EIO ; goto cleanup ; } entry = FIRST_ENTRY ( bh ) ; while ( ! IS_LAST_ENTRY ( entry ) ) { struct ext2_xattr_entry * next = EXT2_XATTR_NEXT ( entry ) ; if ( ( char * ) next >= end ) goto bad_block ; entry = next ; } <S2SV_StartBug> if ( ext2_xattr_cache_insert ( bh ) ) <S2SV_EndBug> ea_idebug ( inode , \"cache<S2SV_blank>insert<S2SV_blank>failed\" ) ; for ( entry = FIRST_ENTRY ( bh ) ; ! IS_LAST_ENTRY ( entry ) ; entry = EXT2_XATTR_NEXT ( entry ) ) { const struct xattr_handler * handler = ext2_xattr_handler ( entry -> e_name_index ) ; if ( handler && ( ! handler -> list || handler -> list ( dentry ) ) ) { const char * prefix = handler -> prefix ? : handler -> name ; size_t prefix_len = strlen ( prefix ) ; size_t size = prefix_len + entry -> e_name_len + 1 ; if ( buffer ) { if ( size > rest ) { error = - ERANGE ; goto cleanup ; } memcpy ( buffer , prefix , prefix_len ) ; buffer += prefix_len ; memcpy ( buffer , entry -> e_name , entry -> e_name_len ) ; buffer += entry -> e_name_len ; * buffer ++ = 0 ; } rest -= size ; } } error = buffer_size - rest ; cleanup : brelse ( bh ) ; up_read ( & EXT2_I ( inode ) -> xattr_sem ) ; return error ; }\n","target":"<S2SV_ModStart> ; int error ; struct mb2_cache * ext2_mb_cache = EXT2_SB ( inode -> i_sb ) -> s_mb_cache <S2SV_ModStart> ( ext2_xattr_cache_insert ( ext2_mb_cache ,\n","project_and_commit_id":"torvalds@linux/be0726d33cb8f411945884664924bed3cb8c70ee","cve_id":"CVE-2015-8952","original_address":"https://github.com/torvalds/linux/commit/be0726d33cb8f411945884664924bed3cb8c70ee","time":"2016-10-16T21:59Z"},
	{"Unnamed: 0":1521,"cwe_id":"CWE-125","source":"CWE-125 static const ut8 * r_bin_dwarf_parse_attr_value ( const ut8 * obuf , int obuf_len , RBinDwarfAttrSpec * spec , RBinDwarfAttrValue * value , const RBinDwarfCompUnitHdr * hdr , const ut8 * debug_str , size_t debug_str_len ) { const ut8 * buf = obuf ; const ut8 * buf_end = obuf + obuf_len ; size_t j ; <S2SV_StartBug> if ( ! spec || ! value || ! hdr || ! obuf || obuf_len < 0 ) { <S2SV_EndBug> return NULL ; } value -> form = spec -> attr_form ; value -> name = spec -> attr_name ; value -> encoding . block . data = NULL ; value -> encoding . str_struct . string = NULL ; value -> encoding . str_struct . offset = 0 ; switch ( spec -> attr_form ) { case DW_FORM_addr : switch ( hdr -> pointer_size ) { case 1 : value -> encoding . address = READ ( buf , ut8 ) ; break ; case 2 : value -> encoding . address = READ ( buf , ut16 ) ; break ; case 4 : value -> encoding . address = READ ( buf , ut32 ) ; break ; case 8 : value -> encoding . address = READ ( buf , ut64 ) ; break ; default : eprintf ( \"DWARF:<S2SV_blank>Unexpected<S2SV_blank>pointer<S2SV_blank>size:<S2SV_blank>%u\\\\n\" , ( unsigned ) hdr -> pointer_size ) ; return NULL ; } break ; case DW_FORM_block2 : value -> encoding . block . length = READ ( buf , ut16 ) ; if ( value -> encoding . block . length > 0 ) { value -> encoding . block . data = calloc ( sizeof ( ut8 ) , value -> encoding . block . length ) ; for ( j = 0 ; j < value -> encoding . block . length ; j ++ ) { value -> encoding . block . data [ j ] = READ ( buf , ut8 ) ; } } break ; case DW_FORM_block4 : value -> encoding . block . length = READ ( buf , ut32 ) ; if ( value -> encoding . block . length > 0 ) { ut8 * data = calloc ( sizeof ( ut8 ) , value -> encoding . block . length ) ; if ( data ) { for ( j = 0 ; j < value -> encoding . block . length ; j ++ ) { data [ j ] = READ ( buf , ut8 ) ; } } value -> encoding . block . data = data ; } break ; <S2SV_StartBug> case DW_FORM_data2 : <S2SV_EndBug> value -> encoding . data = READ ( buf , ut16 ) ; break ; case DW_FORM_data4 : value -> encoding . data = READ ( buf , ut32 ) ; break ; case DW_FORM_data8 : value -> encoding . data = READ ( buf , ut64 ) ; <S2SV_StartBug> break ; <S2SV_EndBug> case DW_FORM_string : value -> encoding . str_struct . string = * buf ? strdup ( ( const char * ) buf ) : NULL ; buf += ( strlen ( ( const char * ) buf ) + 1 ) ; break ; case DW_FORM_block : buf = r_uleb128 ( buf , buf_end - buf , & value -> encoding . block . length ) ; if ( ! buf ) { return NULL ; } value -> encoding . block . data = calloc ( sizeof ( ut8 ) , value -> encoding . block . length ) ; <S2SV_StartBug> for ( j = 0 ; j < value -> encoding . block . length ; j ++ ) { <S2SV_EndBug> <S2SV_StartBug> value -> encoding . block . data [ j ] = READ ( buf , ut8 ) ; <S2SV_EndBug> } break ; case DW_FORM_block1 : value -> encoding . block . length = READ ( buf , ut8 ) ; value -> encoding . block . data = calloc ( sizeof ( ut8 ) , value -> encoding . block . length + 1 ) ; <S2SV_StartBug> for ( j = 0 ; j < value -> encoding . block . length ; j ++ ) { <S2SV_EndBug> <S2SV_StartBug> value -> encoding . block . data [ j ] = READ ( buf , ut8 ) ; <S2SV_EndBug> } break ; case DW_FORM_flag : value -> encoding . flag = READ ( buf , ut8 ) ; break ; case DW_FORM_sdata : buf = r_leb128 ( buf , & value -> encoding . sdata ) ; break ; case DW_FORM_strp : value -> encoding . str_struct . offset = READ ( buf , ut32 ) ; if ( debug_str && value -> encoding . str_struct . offset < debug_str_len ) { value -> encoding . str_struct . string = strdup ( ( const char * ) ( debug_str + value -> encoding . str_struct . offset ) ) ; } else { value -> encoding . str_struct . string = NULL ; } break ; case DW_FORM_udata : { ut64 ndata = 0 ; const ut8 * data = ( const ut8 * ) & ndata ; buf = r_uleb128 ( buf , R_MIN ( sizeof ( data ) , ( size_t ) ( buf_end - buf ) ) , & ndata ) ; memcpy ( & value -> encoding . data , data , sizeof ( value -> encoding . data ) ) ; value -> encoding . str_struct . string = NULL ; } break ; case DW_FORM_ref_addr : value -> encoding . reference = READ ( buf , ut64 ) ; break ; case DW_FORM_ref1 : value -> encoding . reference = READ ( buf , ut8 ) ; break ; case DW_FORM_ref2 : value -> encoding . reference = READ ( buf , ut16 ) ; break ; case DW_FORM_ref4 : value -> encoding . reference = READ ( buf , ut32 ) ; break ; case DW_FORM_ref8 : value -> encoding . reference = READ ( buf , ut64 ) ; break ; case DW_FORM_data1 : value -> encoding . data = READ ( buf , ut8 ) ; break ; default : eprintf ( \"Unknown<S2SV_blank>DW_FORM<S2SV_blank>0x%02\" PFMT64x \"\\\\n\" , spec -> attr_form ) ; value -> encoding . data = 0 ; return NULL ; } return buf ; }\n","target":"<S2SV_ModStart> || obuf_len < 1 <S2SV_ModEnd> ) { return <S2SV_ModStart> } break ; # if 0 <S2SV_ModStart> ; break ; # endif <S2SV_ModStart> length ) ; if ( value -> encoding . block . data ) { <S2SV_ModStart> ut8 ) ; } <S2SV_ModStart> 1 ) ; if ( value -> encoding . block . data ) { <S2SV_ModStart> ut8 ) ; }\n","project_and_commit_id":"radare@radare2/2ca9ab45891b6ae8e32b6c28c81eebca059cbe5d","cve_id":"CVE-2017-16805","original_address":"https://github.com/radare/radare2/commit/2ca9ab45891b6ae8e32b6c28c81eebca059cbe5d","time":"2017-11-13T21:29Z"},
	{"Unnamed: 0":6550,"cwe_id":"CWE-400","source":"CWE-400 static void record_and_restart ( struct perf_event * event , unsigned long val , <S2SV_StartBug> struct pt_regs * regs , int nmi ) <S2SV_EndBug> { u64 period = event -> hw . sample_period ; s64 prev , delta , left ; int record = 0 ; if ( event -> hw . state & PERF_HES_STOPPED ) { write_pmc ( event -> hw . idx , 0 ) ; return ; } prev = local64_read ( & event -> hw . prev_count ) ; delta = check_and_compute_delta ( prev , val ) ; local64_add ( delta , & event -> count ) ; val = 0 ; left = local64_read ( & event -> hw . period_left ) - delta ; if ( period ) { if ( left <= 0 ) { left += period ; if ( left <= 0 ) left = period ; record = 1 ; event -> hw . last_period = event -> hw . sample_period ; } if ( left < 0x80000000LL ) val = 0x80000000LL - left ; } write_pmc ( event -> hw . idx , val ) ; local64_set ( & event -> hw . prev_count , val ) ; local64_set ( & event -> hw . period_left , left ) ; perf_event_update_userpage ( event ) ; if ( record ) { struct perf_sample_data data ; perf_sample_data_init ( & data , ~ 0ULL ) ; data . period = event -> hw . last_period ; if ( event -> attr . sample_type & PERF_SAMPLE_ADDR ) perf_get_data_addr ( regs , & data . addr ) ; <S2SV_StartBug> if ( perf_event_overflow ( event , nmi , & data , regs ) ) <S2SV_EndBug> power_pmu_stop ( event , 0 ) ; } }\n","target":"<S2SV_ModStart> pt_regs * regs <S2SV_ModEnd> ) { u64 <S2SV_ModStart> ( event , <S2SV_ModEnd> & data ,\n","project_and_commit_id":"torvalds@linux/a8b0ca17b80e92faab46ee7179ba9e99ccb61233","cve_id":"CVE-2011-2918","original_address":"https://github.com/torvalds/linux/commit/a8b0ca17b80e92faab46ee7179ba9e99ccb61233","time":"2012-05-24T23:55Z"},
	{"Unnamed: 0":3589,"cwe_id":"CWE-000","source":"CWE-000 static int devzvol_readdir ( struct vnode * dvp , struct uio * uiop , struct cred * cred , int * eofp , caller_context_t * ct_unused , int flags_unused ) { struct sdev_node * sdvp = VTOSDEV ( dvp ) ; char * ptr ; sdcmn_err13 ( ( \"zv<S2SV_blank>readdir<S2SV_blank>of<S2SV_blank>\\'%s\\'<S2SV_blank>%s\\'\" , sdvp -> sdev_path , sdvp -> sdev_name ) ) ; if ( strcmp ( sdvp -> sdev_path , ZVOL_DIR ) == 0 ) { struct vnode * vp ; rw_exit ( & sdvp -> sdev_contents ) ; ( void ) devname_lookup_func ( sdvp , \"dsk\" , & vp , cred , devzvol_create_dir , SDEV_VATTR ) ; VN_RELE ( vp ) ; ( void ) devname_lookup_func ( sdvp , \"rdsk\" , & vp , cred , devzvol_create_dir , SDEV_VATTR ) ; VN_RELE ( vp ) ; rw_enter ( & sdvp -> sdev_contents , RW_READER ) ; return ( devname_readdir_func ( dvp , uiop , cred , eofp , 0 ) ) ; } if ( uiop -> uio_offset == 0 ) devzvol_prunedir ( sdvp ) ; ptr = sdvp -> sdev_path + strlen ( ZVOL_DIR ) ; if ( ( strcmp ( ptr , \"/dsk\" ) == 0 ) || ( strcmp ( ptr , \"/rdsk\" ) == 0 ) ) { rw_exit ( & sdvp -> sdev_contents ) ; devzvol_create_pool_dirs ( dvp ) ; rw_enter ( & sdvp -> sdev_contents , RW_READER ) ; return ( devname_readdir_func ( dvp , uiop , cred , eofp , 0 ) ) ; } <S2SV_StartBug> ptr = strchr ( ptr + 1 , '/' ) + 1 ; <S2SV_EndBug> rw_exit ( & sdvp -> sdev_contents ) ; sdev_iter_datasets ( dvp , ZFS_IOC_DATASET_LIST_NEXT , ptr ) ; rw_enter ( & sdvp -> sdev_contents , RW_READER ) ; return ( devname_readdir_func ( dvp , uiop , cred , eofp , 0 ) ) ; }\n","target":"<S2SV_ModStart> , '/' ) ; if ( ptr == NULL ) return ( ENOENT ) ; ptr ++ <S2SV_ModEnd> ; rw_exit (\n","project_and_commit_id":"illumos@illumos-gate/d65686849024838243515b5c40ae2c479460b4b5","cve_id":"CVE-2014-9491","original_address":"https://github.com/illumos/illumos-gate/commit/d65686849024838243515b5c40ae2c479460b4b5","time":"2015-01-20T15:59Z"},
	{"Unnamed: 0":5894,"cwe_id":"CWE-476","source":"CWE-476 static int hls_slice_header ( HEVCContext * s ) { GetBitContext * gb = & s -> HEVClc -> gb ; SliceHeader * sh = & s -> sh ; int i , ret ; <S2SV_StartBug> sh -> first_slice_in_pic_flag = get_bits1 ( gb ) ; <S2SV_EndBug> if ( ( IS_IDR ( s ) || IS_BLA ( s ) ) && sh -> first_slice_in_pic_flag ) { s -> seq_decode = ( s -> seq_decode + 1 ) & 0xff ; s -> max_ra = INT_MAX ; if ( IS_IDR ( s ) ) ff_hevc_clear_refs ( s ) ; } sh -> no_output_of_prior_pics_flag = 0 ; if ( IS_IRAP ( s ) ) sh -> no_output_of_prior_pics_flag = get_bits1 ( gb ) ; sh -> pps_id = get_ue_golomb_long ( gb ) ; if ( sh -> pps_id >= HEVC_MAX_PPS_COUNT || ! s -> ps . pps_list [ sh -> pps_id ] ) { av_log ( s -> avctx , AV_LOG_ERROR , \"PPS<S2SV_blank>id<S2SV_blank>out<S2SV_blank>of<S2SV_blank>range:<S2SV_blank>%d\\\\n\" , sh -> pps_id ) ; return AVERROR_INVALIDDATA ; } if ( ! sh -> first_slice_in_pic_flag && s -> ps . pps != ( HEVCPPS * ) s -> ps . pps_list [ sh -> pps_id ] -> data ) { av_log ( s -> avctx , AV_LOG_ERROR , \"PPS<S2SV_blank>changed<S2SV_blank>between<S2SV_blank>slices.\\\\n\" ) ; return AVERROR_INVALIDDATA ; } s -> ps . pps = ( HEVCPPS * ) s -> ps . pps_list [ sh -> pps_id ] -> data ; if ( s -> nal_unit_type == HEVC_NAL_CRA_NUT && s -> last_eos == 1 ) sh -> no_output_of_prior_pics_flag = 1 ; if ( s -> ps . sps != ( HEVCSPS * ) s -> ps . sps_list [ s -> ps . pps -> sps_id ] -> data ) { const HEVCSPS * sps = ( HEVCSPS * ) s -> ps . sps_list [ s -> ps . pps -> sps_id ] -> data ; const HEVCSPS * last_sps = s -> ps . sps ; enum AVPixelFormat pix_fmt ; if ( last_sps && IS_IRAP ( s ) && s -> nal_unit_type != HEVC_NAL_CRA_NUT ) { if ( sps -> width != last_sps -> width || sps -> height != last_sps -> height || sps -> temporal_layer [ sps -> max_sub_layers - 1 ] . max_dec_pic_buffering != last_sps -> temporal_layer [ last_sps -> max_sub_layers - 1 ] . max_dec_pic_buffering ) sh -> no_output_of_prior_pics_flag = 0 ; } ff_hevc_clear_refs ( s ) ; ret = set_sps ( s , sps , sps -> pix_fmt ) ; if ( ret < 0 ) return ret ; pix_fmt = get_format ( s , sps ) ; if ( pix_fmt < 0 ) return pix_fmt ; s -> avctx -> pix_fmt = pix_fmt ; s -> seq_decode = ( s -> seq_decode + 1 ) & 0xff ; s -> max_ra = INT_MAX ; } sh -> dependent_slice_segment_flag = 0 ; if ( ! sh -> first_slice_in_pic_flag ) { int slice_address_length ; if ( s -> ps . pps -> dependent_slice_segments_enabled_flag ) sh -> dependent_slice_segment_flag = get_bits1 ( gb ) ; slice_address_length = av_ceil_log2 ( s -> ps . sps -> ctb_width * s -> ps . sps -> ctb_height ) ; sh -> slice_segment_addr = get_bitsz ( gb , slice_address_length ) ; if ( sh -> slice_segment_addr >= s -> ps . sps -> ctb_width * s -> ps . sps -> ctb_height ) { av_log ( s -> avctx , AV_LOG_ERROR , \"Invalid<S2SV_blank>slice<S2SV_blank>segment<S2SV_blank>address:<S2SV_blank>%u.\\\\n\" , sh -> slice_segment_addr ) ; return AVERROR_INVALIDDATA ; } if ( ! sh -> dependent_slice_segment_flag ) { sh -> slice_addr = sh -> slice_segment_addr ; s -> slice_idx ++ ; } } else { sh -> slice_segment_addr = sh -> slice_addr = 0 ; s -> slice_idx = 0 ; s -> slice_initialized = 0 ; } if ( ! sh -> dependent_slice_segment_flag ) { s -> slice_initialized = 0 ; for ( i = 0 ; i < s -> ps . pps -> num_extra_slice_header_bits ; i ++ ) skip_bits ( gb , 1 ) ; sh -> slice_type = get_ue_golomb_long ( gb ) ; if ( ! ( sh -> slice_type == HEVC_SLICE_I || sh -> slice_type == HEVC_SLICE_P || sh -> slice_type == HEVC_SLICE_B ) ) { av_log ( s -> avctx , AV_LOG_ERROR , \"Unknown<S2SV_blank>slice<S2SV_blank>type:<S2SV_blank>%d.\\\\n\" , sh -> slice_type ) ; return AVERROR_INVALIDDATA ; } if ( IS_IRAP ( s ) && sh -> slice_type != HEVC_SLICE_I ) { av_log ( s -> avctx , AV_LOG_ERROR , \"Inter<S2SV_blank>slices<S2SV_blank>in<S2SV_blank>an<S2SV_blank>IRAP<S2SV_blank>frame.\\\\n\" ) ; return AVERROR_INVALIDDATA ; } sh -> pic_output_flag = 1 ; if ( s -> ps . pps -> output_flag_present_flag ) sh -> pic_output_flag = get_bits1 ( gb ) ; if ( s -> ps . sps -> separate_colour_plane_flag ) sh -> colour_plane_id = get_bits ( gb , 2 ) ; if ( ! IS_IDR ( s ) ) { int poc , pos ; sh -> pic_order_cnt_lsb = get_bits ( gb , s -> ps . sps -> log2_max_poc_lsb ) ; poc = ff_hevc_compute_poc ( s -> ps . sps , s -> pocTid0 , sh -> pic_order_cnt_lsb , s -> nal_unit_type ) ; if ( ! sh -> first_slice_in_pic_flag && poc != s -> poc ) { av_log ( s -> avctx , AV_LOG_WARNING , \"Ignoring<S2SV_blank>POC<S2SV_blank>change<S2SV_blank>between<S2SV_blank>slices:<S2SV_blank>%d<S2SV_blank>-><S2SV_blank>%d\\\\n\" , s -> poc , poc ) ; if ( s -> avctx -> err_recognition & AV_EF_EXPLODE ) return AVERROR_INVALIDDATA ; poc = s -> poc ; } s -> poc = poc ; sh -> short_term_ref_pic_set_sps_flag = get_bits1 ( gb ) ; pos = get_bits_left ( gb ) ; if ( ! sh -> short_term_ref_pic_set_sps_flag ) { ret = ff_hevc_decode_short_term_rps ( gb , s -> avctx , & sh -> slice_rps , s -> ps . sps , 1 ) ; if ( ret < 0 ) return ret ; sh -> short_term_rps = & sh -> slice_rps ; } else { int numbits , rps_idx ; if ( ! s -> ps . sps -> nb_st_rps ) { av_log ( s -> avctx , AV_LOG_ERROR , \"No<S2SV_blank>ref<S2SV_blank>lists<S2SV_blank>in<S2SV_blank>the<S2SV_blank>SPS.\\\\n\" ) ; return AVERROR_INVALIDDATA ; } numbits = av_ceil_log2 ( s -> ps . sps -> nb_st_rps ) ; rps_idx = numbits > 0 ? get_bits ( gb , numbits ) : 0 ; sh -> short_term_rps = & s -> ps . sps -> st_rps [ rps_idx ] ; } sh -> short_term_ref_pic_set_size = pos - get_bits_left ( gb ) ; pos = get_bits_left ( gb ) ; ret = decode_lt_rps ( s , & sh -> long_term_rps , gb ) ; if ( ret < 0 ) { av_log ( s -> avctx , AV_LOG_WARNING , \"Invalid<S2SV_blank>long<S2SV_blank>term<S2SV_blank>RPS.\\\\n\" ) ; if ( s -> avctx -> err_recognition & AV_EF_EXPLODE ) return AVERROR_INVALIDDATA ; } sh -> long_term_ref_pic_set_size = pos - get_bits_left ( gb ) ; if ( s -> ps . sps -> sps_temporal_mvp_enabled_flag ) sh -> slice_temporal_mvp_enabled_flag = get_bits1 ( gb ) ; else sh -> slice_temporal_mvp_enabled_flag = 0 ; } else { s -> sh . short_term_rps = NULL ; s -> poc = 0 ; } if ( sh -> first_slice_in_pic_flag && s -> temporal_id == 0 && s -> nal_unit_type != HEVC_NAL_TRAIL_N && s -> nal_unit_type != HEVC_NAL_TSA_N && s -> nal_unit_type != HEVC_NAL_STSA_N && s -> nal_unit_type != HEVC_NAL_RADL_N && s -> nal_unit_type != HEVC_NAL_RADL_R && s -> nal_unit_type != HEVC_NAL_RASL_N && s -> nal_unit_type != HEVC_NAL_RASL_R ) s -> pocTid0 = s -> poc ; if ( s -> ps . sps -> sao_enabled ) { sh -> slice_sample_adaptive_offset_flag [ 0 ] = get_bits1 ( gb ) ; if ( s -> ps . sps -> chroma_format_idc ) { sh -> slice_sample_adaptive_offset_flag [ 1 ] = sh -> slice_sample_adaptive_offset_flag [ 2 ] = get_bits1 ( gb ) ; } } else { sh -> slice_sample_adaptive_offset_flag [ 0 ] = 0 ; sh -> slice_sample_adaptive_offset_flag [ 1 ] = 0 ; sh -> slice_sample_adaptive_offset_flag [ 2 ] = 0 ; } sh -> nb_refs [ L0 ] = sh -> nb_refs [ L1 ] = 0 ; if ( sh -> slice_type == HEVC_SLICE_P || sh -> slice_type == HEVC_SLICE_B ) { int nb_refs ; sh -> nb_refs [ L0 ] = s -> ps . pps -> num_ref_idx_l0_default_active ; if ( sh -> slice_type == HEVC_SLICE_B ) sh -> nb_refs [ L1 ] = s -> ps . pps -> num_ref_idx_l1_default_active ; if ( get_bits1 ( gb ) ) { sh -> nb_refs [ L0 ] = get_ue_golomb_long ( gb ) + 1 ; if ( sh -> slice_type == HEVC_SLICE_B ) sh -> nb_refs [ L1 ] = get_ue_golomb_long ( gb ) + 1 ; } if ( sh -> nb_refs [ L0 ] > HEVC_MAX_REFS || sh -> nb_refs [ L1 ] > HEVC_MAX_REFS ) { av_log ( s -> avctx , AV_LOG_ERROR , \"Too<S2SV_blank>many<S2SV_blank>refs:<S2SV_blank>%d/%d.\\\\n\" , sh -> nb_refs [ L0 ] , sh -> nb_refs [ L1 ] ) ; return AVERROR_INVALIDDATA ; } sh -> rpl_modification_flag [ 0 ] = 0 ; sh -> rpl_modification_flag [ 1 ] = 0 ; nb_refs = ff_hevc_frame_nb_refs ( s ) ; if ( ! nb_refs ) { av_log ( s -> avctx , AV_LOG_ERROR , \"Zero<S2SV_blank>refs<S2SV_blank>for<S2SV_blank>a<S2SV_blank>frame<S2SV_blank>with<S2SV_blank>P<S2SV_blank>or<S2SV_blank>B<S2SV_blank>slices.\\\\n\" ) ; return AVERROR_INVALIDDATA ; } if ( s -> ps . pps -> lists_modification_present_flag && nb_refs > 1 ) { sh -> rpl_modification_flag [ 0 ] = get_bits1 ( gb ) ; if ( sh -> rpl_modification_flag [ 0 ] ) { for ( i = 0 ; i < sh -> nb_refs [ L0 ] ; i ++ ) sh -> list_entry_lx [ 0 ] [ i ] = get_bits ( gb , av_ceil_log2 ( nb_refs ) ) ; } if ( sh -> slice_type == HEVC_SLICE_B ) { sh -> rpl_modification_flag [ 1 ] = get_bits1 ( gb ) ; if ( sh -> rpl_modification_flag [ 1 ] == 1 ) for ( i = 0 ; i < sh -> nb_refs [ L1 ] ; i ++ ) sh -> list_entry_lx [ 1 ] [ i ] = get_bits ( gb , av_ceil_log2 ( nb_refs ) ) ; } } if ( sh -> slice_type == HEVC_SLICE_B ) sh -> mvd_l1_zero_flag = get_bits1 ( gb ) ; if ( s -> ps . pps -> cabac_init_present_flag ) sh -> cabac_init_flag = get_bits1 ( gb ) ; else sh -> cabac_init_flag = 0 ; sh -> collocated_ref_idx = 0 ; if ( sh -> slice_temporal_mvp_enabled_flag ) { sh -> collocated_list = L0 ; if ( sh -> slice_type == HEVC_SLICE_B ) sh -> collocated_list = ! get_bits1 ( gb ) ; if ( sh -> nb_refs [ sh -> collocated_list ] > 1 ) { sh -> collocated_ref_idx = get_ue_golomb_long ( gb ) ; if ( sh -> collocated_ref_idx >= sh -> nb_refs [ sh -> collocated_list ] ) { av_log ( s -> avctx , AV_LOG_ERROR , \"Invalid<S2SV_blank>collocated_ref_idx:<S2SV_blank>%d.\\\\n\" , sh -> collocated_ref_idx ) ; return AVERROR_INVALIDDATA ; } } } if ( ( s -> ps . pps -> weighted_pred_flag && sh -> slice_type == HEVC_SLICE_P ) || ( s -> ps . pps -> weighted_bipred_flag && sh -> slice_type == HEVC_SLICE_B ) ) { int ret = pred_weight_table ( s , gb ) ; if ( ret < 0 ) return ret ; } sh -> max_num_merge_cand = 5 - get_ue_golomb_long ( gb ) ; if ( sh -> max_num_merge_cand < 1 || sh -> max_num_merge_cand > 5 ) { av_log ( s -> avctx , AV_LOG_ERROR , \"Invalid<S2SV_blank>number<S2SV_blank>of<S2SV_blank>merging<S2SV_blank>MVP<S2SV_blank>candidates:<S2SV_blank>%d.\\\\n\" , sh -> max_num_merge_cand ) ; return AVERROR_INVALIDDATA ; } } sh -> slice_qp_delta = get_se_golomb ( gb ) ; if ( s -> ps . pps -> pic_slice_level_chroma_qp_offsets_present_flag ) { sh -> slice_cb_qp_offset = get_se_golomb ( gb ) ; sh -> slice_cr_qp_offset = get_se_golomb ( gb ) ; } else { sh -> slice_cb_qp_offset = 0 ; sh -> slice_cr_qp_offset = 0 ; } if ( s -> ps . pps -> chroma_qp_offset_list_enabled_flag ) sh -> cu_chroma_qp_offset_enabled_flag = get_bits1 ( gb ) ; else sh -> cu_chroma_qp_offset_enabled_flag = 0 ; if ( s -> ps . pps -> deblocking_filter_control_present_flag ) { int deblocking_filter_override_flag = 0 ; if ( s -> ps . pps -> deblocking_filter_override_enabled_flag ) deblocking_filter_override_flag = get_bits1 ( gb ) ; if ( deblocking_filter_override_flag ) { sh -> disable_deblocking_filter_flag = get_bits1 ( gb ) ; if ( ! sh -> disable_deblocking_filter_flag ) { int beta_offset_div2 = get_se_golomb ( gb ) ; int tc_offset_div2 = get_se_golomb ( gb ) ; if ( beta_offset_div2 < - 6 || beta_offset_div2 > 6 || tc_offset_div2 < - 6 || tc_offset_div2 > 6 ) { av_log ( s -> avctx , AV_LOG_ERROR , \"Invalid<S2SV_blank>deblock<S2SV_blank>filter<S2SV_blank>offsets:<S2SV_blank>%d,<S2SV_blank>%d\\\\n\" , beta_offset_div2 , tc_offset_div2 ) ; return AVERROR_INVALIDDATA ; } sh -> beta_offset = beta_offset_div2 * 2 ; sh -> tc_offset = tc_offset_div2 * 2 ; } } else { sh -> disable_deblocking_filter_flag = s -> ps . pps -> disable_dbf ; sh -> beta_offset = s -> ps . pps -> beta_offset ; sh -> tc_offset = s -> ps . pps -> tc_offset ; } } else { sh -> disable_deblocking_filter_flag = 0 ; sh -> beta_offset = 0 ; sh -> tc_offset = 0 ; } if ( s -> ps . pps -> seq_loop_filter_across_slices_enabled_flag && ( sh -> slice_sample_adaptive_offset_flag [ 0 ] || sh -> slice_sample_adaptive_offset_flag [ 1 ] || ! sh -> disable_deblocking_filter_flag ) ) { sh -> slice_loop_filter_across_slices_enabled_flag = get_bits1 ( gb ) ; } else { sh -> slice_loop_filter_across_slices_enabled_flag = s -> ps . pps -> seq_loop_filter_across_slices_enabled_flag ; } } else if ( ! s -> slice_initialized ) { av_log ( s -> avctx , AV_LOG_ERROR , \"Independent<S2SV_blank>slice<S2SV_blank>segment<S2SV_blank>missing.\\\\n\" ) ; return AVERROR_INVALIDDATA ; } sh -> num_entry_point_offsets = 0 ; if ( s -> ps . pps -> tiles_enabled_flag || s -> ps . pps -> entropy_coding_sync_enabled_flag ) { unsigned num_entry_point_offsets = get_ue_golomb_long ( gb ) ; if ( num_entry_point_offsets > get_bits_left ( gb ) ) { av_log ( s -> avctx , AV_LOG_ERROR , \"num_entry_point_offsets<S2SV_blank>%d<S2SV_blank>is<S2SV_blank>invalid\\\\n\" , num_entry_point_offsets ) ; return AVERROR_INVALIDDATA ; } sh -> num_entry_point_offsets = num_entry_point_offsets ; if ( sh -> num_entry_point_offsets > 0 ) { int offset_len = get_ue_golomb_long ( gb ) + 1 ; if ( offset_len < 1 || offset_len > 32 ) { sh -> num_entry_point_offsets = 0 ; av_log ( s -> avctx , AV_LOG_ERROR , \"offset_len<S2SV_blank>%d<S2SV_blank>is<S2SV_blank>invalid\\\\n\" , offset_len ) ; return AVERROR_INVALIDDATA ; } av_freep ( & sh -> entry_point_offset ) ; av_freep ( & sh -> offset ) ; av_freep ( & sh -> size ) ; sh -> entry_point_offset = av_malloc_array ( sh -> num_entry_point_offsets , sizeof ( unsigned ) ) ; sh -> offset = av_malloc_array ( sh -> num_entry_point_offsets , sizeof ( int ) ) ; sh -> size = av_malloc_array ( sh -> num_entry_point_offsets , sizeof ( int ) ) ; if ( ! sh -> entry_point_offset || ! sh -> offset || ! sh -> size ) { sh -> num_entry_point_offsets = 0 ; av_log ( s -> avctx , AV_LOG_ERROR , \"Failed<S2SV_blank>to<S2SV_blank>allocate<S2SV_blank>memory\\\\n\" ) ; return AVERROR ( ENOMEM ) ; } for ( i = 0 ; i < sh -> num_entry_point_offsets ; i ++ ) { unsigned val = get_bits_long ( gb , offset_len ) ; sh -> entry_point_offset [ i ] = val + 1 ; } if ( s -> threads_number > 1 && ( s -> ps . pps -> num_tile_rows > 1 || s -> ps . pps -> num_tile_columns > 1 ) ) { s -> enable_parallel_tiles = 0 ; s -> threads_number = 1 ; } else s -> enable_parallel_tiles = 0 ; } else s -> enable_parallel_tiles = 0 ; } if ( s -> ps . pps -> slice_header_extension_present_flag ) { unsigned int length = get_ue_golomb_long ( gb ) ; if ( length * 8LL > get_bits_left ( gb ) ) { av_log ( s -> avctx , AV_LOG_ERROR , \"too<S2SV_blank>many<S2SV_blank>slice_header_extension_data_bytes\\\\n\" ) ; return AVERROR_INVALIDDATA ; } for ( i = 0 ; i < length ; i ++ ) skip_bits ( gb , 8 ) ; } sh -> slice_qp = 26U + s -> ps . pps -> pic_init_qp_minus26 + sh -> slice_qp_delta ; if ( sh -> slice_qp > 51 || sh -> slice_qp < - s -> ps . sps -> qp_bd_offset ) { av_log ( s -> avctx , AV_LOG_ERROR , \"The<S2SV_blank>slice_qp<S2SV_blank>%d<S2SV_blank>is<S2SV_blank>outside<S2SV_blank>the<S2SV_blank>valid<S2SV_blank>range<S2SV_blank>\" \"[%d,<S2SV_blank>51].\\\\n\" , sh -> slice_qp , - s -> ps . sps -> qp_bd_offset ) ; return AVERROR_INVALIDDATA ; } sh -> slice_ctb_addr_rs = sh -> slice_segment_addr ; if ( ! s -> sh . slice_ctb_addr_rs && s -> sh . dependent_slice_segment_flag ) { av_log ( s -> avctx , AV_LOG_ERROR , \"Impossible<S2SV_blank>slice<S2SV_blank>segment.\\\\n\" ) ; return AVERROR_INVALIDDATA ; } if ( get_bits_left ( gb ) < 0 ) { av_log ( s -> avctx , AV_LOG_ERROR , \"Overread<S2SV_blank>slice<S2SV_blank>header<S2SV_blank>by<S2SV_blank>%d<S2SV_blank>bits\\\\n\" , - get_bits_left ( gb ) ) ; return AVERROR_INVALIDDATA ; } s -> HEVClc -> first_qp_group = ! s -> sh . dependent_slice_segment_flag ; if ( ! s -> ps . pps -> cu_qp_delta_enabled_flag ) s -> HEVClc -> qp_y = s -> sh . slice_qp ; s -> slice_initialized = 1 ; s -> HEVClc -> tu . cu_qp_offset_cb = 0 ; s -> HEVClc -> tu . cu_qp_offset_cr = 0 ; return 0 ; }\n","target":"<S2SV_ModStart> gb ) ; if ( s -> ref && sh -> first_slice_in_pic_flag ) { av_log ( s -> avctx , AV_LOG_ERROR , \"Two<S2SV_blank>slices<S2SV_blank>reporting<S2SV_blank>being<S2SV_blank>the<S2SV_blank>first<S2SV_blank>in<S2SV_blank>the<S2SV_blank>same<S2SV_blank>frame.\\\\n\" ) ; return 1 ; }\n","project_and_commit_id":"FFmpeg@FFmpeg/54655623a82632e7624714d7b2a3e039dc5faa7e","cve_id":"CVE-2019-11338","original_address":"https://github.com/FFmpeg/FFmpeg/commit/54655623a82632e7624714d7b2a3e039dc5faa7e","time":"2019-04-19T00:29Z"},
	{"Unnamed: 0":3328,"cwe_id":"CWE-119","source":"CWE-119 void vp9_encode_sb ( MACROBLOCK * x , BLOCK_SIZE bsize ) { MACROBLOCKD * const xd = & x -> e_mbd ; struct optimize_ctx ctx ; MB_MODE_INFO * mbmi = & xd -> mi [ 0 ] -> mbmi ; struct encode_b_args arg = { x , & ctx , & mbmi -> skip } ; int plane ; <S2SV_StartBug> for ( plane = 0 ; plane < MAX_MB_PLANE ; ++ plane ) { <S2SV_EndBug> if ( ! x -> skip_recode ) vp9_subtract_plane ( x , bsize , plane ) ; if ( x -> optimize && ( ! x -> skip_recode || ! x -> skip_optimize ) ) { const struct macroblockd_plane * const pd = & xd -> plane [ plane ] ; <S2SV_StartBug> const TX_SIZE tx_size = plane ? get_uv_tx_size ( mbmi ) : mbmi -> tx_size ; <S2SV_EndBug> vp9_get_entropy_contexts ( bsize , tx_size , pd , ctx . ta [ plane ] , ctx . tl [ plane ] ) ; } vp9_foreach_transformed_block_in_plane ( xd , bsize , plane , encode_block , & arg ) ; } }\n","target":"<S2SV_ModStart> int plane ; mbmi -> skip = 1 ; if ( x -> skip ) return ; <S2SV_ModStart> get_uv_tx_size ( mbmi , pd\n","project_and_commit_id":"external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426","cve_id":"CVE-2016-1621","original_address":"https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426","time":"2016-03-12T21:59Z"},
	{"Unnamed: 0":3758,"cwe_id":"CWE-476","source":"CWE-476 static int jp2_cdef_getdata ( jp2_box_t * box , jas_stream_t * in ) { jp2_cdef_t * cdef = & box -> data . cdef ; jp2_cdefchan_t * chan ; <S2SV_StartBug> unsigned int channo ; <S2SV_EndBug> if ( jp2_getuint16 ( in , & cdef -> numchans ) ) { return - 1 ; } if ( ! ( cdef -> ents = jas_alloc2 ( cdef -> numchans , sizeof ( jp2_cdefchan_t ) ) ) ) { return - 1 ; } for ( channo = 0 ; channo < cdef -> numchans ; ++ channo ) { chan = & cdef -> ents [ channo ] ; if ( jp2_getuint16 ( in , & chan -> channo ) || jp2_getuint16 ( in , & chan -> type ) || jp2_getuint16 ( in , & chan -> assoc ) ) { return - 1 ; } } return 0 ; }\n","target":"<S2SV_ModStart> unsigned int channo ; cdef -> ents = 0\n","project_and_commit_id":"mdadams@jasper/e96fc4fdd525fa0ede28074a7e2b1caf94b58b0d","cve_id":"CVE-2017-6850","original_address":"https://github.com/mdadams/jasper/commit/e96fc4fdd525fa0ede28074a7e2b1caf94b58b0d","time":"2017-03-15T14:59Z"},
	{"Unnamed: 0":6337,"cwe_id":"CWE-310","source":"CWE-310 int btrfs_add_link ( struct btrfs_trans_handle * trans , struct inode * parent_inode , struct inode * inode , const char * name , int name_len , int add_backref , u64 index ) { int ret = 0 ; struct btrfs_key key ; struct btrfs_root * root = BTRFS_I ( parent_inode ) -> root ; u64 ino = btrfs_ino ( inode ) ; u64 parent_ino = btrfs_ino ( parent_inode ) ; if ( unlikely ( ino == BTRFS_FIRST_FREE_OBJECTID ) ) { memcpy ( & key , & BTRFS_I ( inode ) -> root -> root_key , sizeof ( key ) ) ; } else { key . objectid = ino ; btrfs_set_key_type ( & key , BTRFS_INODE_ITEM_KEY ) ; key . offset = 0 ; } if ( unlikely ( ino == BTRFS_FIRST_FREE_OBJECTID ) ) { ret = btrfs_add_root_ref ( trans , root -> fs_info -> tree_root , key . objectid , root -> root_key . objectid , parent_ino , index , name , name_len ) ; } else if ( add_backref ) { ret = btrfs_insert_inode_ref ( trans , root , name , name_len , ino , parent_ino , index ) ; } if ( ret ) return ret ; ret = btrfs_insert_dir_item ( trans , root , name , name_len , parent_inode , & key , btrfs_inode_type ( inode ) , index ) ; <S2SV_StartBug> if ( ret == - EEXIST ) <S2SV_EndBug> goto fail_dir_item ; else if ( ret ) { btrfs_abort_transaction ( trans , root , ret ) ; return ret ; } btrfs_i_size_write ( parent_inode , parent_inode -> i_size + name_len * 2 ) ; inode_inc_iversion ( parent_inode ) ; parent_inode -> i_mtime = parent_inode -> i_ctime = CURRENT_TIME ; ret = btrfs_update_inode ( trans , root , parent_inode ) ; if ( ret ) btrfs_abort_transaction ( trans , root , ret ) ; return ret ; fail_dir_item : if ( unlikely ( ino == BTRFS_FIRST_FREE_OBJECTID ) ) { u64 local_index ; int err ; err = btrfs_del_root_ref ( trans , root -> fs_info -> tree_root , key . objectid , root -> root_key . objectid , parent_ino , & local_index , name , name_len ) ; } else if ( add_backref ) { u64 local_index ; int err ; err = btrfs_del_inode_ref ( trans , root , name , name_len , ino , parent_ino , & local_index ) ; } return ret ; }\n","target":"<S2SV_ModStart> == - EEXIST || ret == - EOVERFLOW\n","project_and_commit_id":"torvalds@linux/9c52057c698fb96f8f07e7a4bcf4801a092bda89","cve_id":"CVE-2012-5375","original_address":"https://github.com/torvalds/linux/commit/9c52057c698fb96f8f07e7a4bcf4801a092bda89","time":"2013-02-18T11:56Z"},
	{"Unnamed: 0":4893,"cwe_id":"CWE-362","source":"CWE-362 static int snd_ctl_elem_user_tlv ( struct snd_kcontrol * kcontrol , int op_flag , unsigned int size , unsigned int __user * tlv ) { struct user_element * ue = kcontrol -> private_data ; int change = 0 ; void * new_data ; if ( op_flag > 0 ) { if ( size > 1024 * 128 ) return - EINVAL ; new_data = memdup_user ( tlv , size ) ; if ( IS_ERR ( new_data ) ) return PTR_ERR ( new_data ) ; <S2SV_StartBug> change = ue -> tlv_data_size != size ; <S2SV_EndBug> if ( ! change ) change = memcmp ( ue -> tlv_data , new_data , size ) ; kfree ( ue -> tlv_data ) ; ue -> tlv_data = new_data ; ue -> tlv_data_size = size ; <S2SV_StartBug> } else { <S2SV_EndBug> if ( ! ue -> tlv_data_size || ! ue -> tlv_data ) <S2SV_StartBug> return - ENXIO ; <S2SV_EndBug> <S2SV_StartBug> if ( size < ue -> tlv_data_size ) <S2SV_EndBug> <S2SV_StartBug> return - ENOSPC ; <S2SV_EndBug> <S2SV_StartBug> if ( copy_to_user ( tlv , ue -> tlv_data , ue -> tlv_data_size ) ) <S2SV_EndBug> <S2SV_StartBug> return - EFAULT ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> return change ; }\n","target":"<S2SV_ModStart> new_data ) ; mutex_lock ( & ue -> card -> user_ctl_lock ) ; <S2SV_ModStart> = size ; mutex_unlock ( & ue -> card -> user_ctl_lock ) ; <S2SV_ModStart> } else { int ret = 0 ; mutex_lock ( & ue -> card -> user_ctl_lock ) ; <S2SV_ModStart> -> tlv_data ) { ret = <S2SV_ModEnd> - ENXIO ; <S2SV_ModStart> - ENXIO ; goto err_unlock ; } <S2SV_ModStart> -> tlv_data_size ) { ret = <S2SV_ModEnd> - ENOSPC ; <S2SV_ModStart> - ENOSPC ; goto err_unlock ; } <S2SV_ModStart> tlv_data_size ) ) ret = <S2SV_ModEnd> - EFAULT ; <S2SV_ModStart> - EFAULT ; err_unlock : mutex_unlock ( & ue -> card -> user_ctl_lock ) ; if ( ret ) return ret ;\n","project_and_commit_id":"torvalds@linux/07f4d9d74a04aa7c72c5dae0ef97565f28f17b92","cve_id":"CVE-2014-4652","original_address":"https://github.com/torvalds/linux/commit/07f4d9d74a04aa7c72c5dae0ef97565f28f17b92","time":"2014-07-03T04:22Z"},
	{"Unnamed: 0":5796,"cwe_id":"CWE-362","source":"CWE-362 static int ext4_convert_unwritten_extents_endio ( handle_t * handle , struct inode * inode , <S2SV_StartBug> struct ext4_ext_path * path ) <S2SV_EndBug> { <S2SV_StartBug> struct ext4_extent * ex ; <S2SV_EndBug> int depth ; int err = 0 ; depth = ext_depth ( inode ) ; ex = path [ depth ] . p_ext ; <S2SV_StartBug> ext_debug ( \"ext4_convert_unwritten_extents_endio:<S2SV_blank>inode<S2SV_blank>%lu,<S2SV_blank>logical\" <S2SV_EndBug> \"block<S2SV_blank>%llu,<S2SV_blank>max_blocks<S2SV_blank>%u\\\\n\" , inode -> i_ino , <S2SV_StartBug> ( unsigned long long ) le32_to_cpu ( ex -> ee_block ) , <S2SV_EndBug> ext4_ext_get_actual_len ( ex ) ) ; err = ext4_ext_get_access ( handle , inode , path + depth ) ; if ( err ) goto out ; ext4_ext_mark_initialized ( ex ) ; ext4_ext_try_to_merge ( handle , inode , path , ex ) ; err = ext4_ext_dirty ( handle , inode , path + path -> p_depth ) ; out : ext4_ext_show_leaf ( inode , path ) ; return err ; }\n","target":"<S2SV_ModStart> inode , struct ext4_map_blocks * map , struct <S2SV_ModStart> ext4_extent * ex ; ext4_lblk_t ee_block ; unsigned int ee_len <S2SV_ModStart> . p_ext ; ee_block = le32_to_cpu ( ex -> ee_block ) ; ee_len = ext4_ext_get_actual_len ( ex ) ; <S2SV_ModStart> long long ) ee_block , ee_len ) ; if ( ee_block != map -> m_lblk || ee_len > map -> m_len ) { err = ext4_split_unwritten_extents ( handle , inode , map , path , EXT4_GET_BLOCKS_CONVERT ) ; if ( err < 0 ) goto out ; ext4_ext_drop_refs ( path ) ; path = ext4_ext_find_extent ( inode , map -> m_lblk , path ) ; if ( IS_ERR ( path ) ) { err = PTR_ERR ( path ) ; goto out ; } depth = ext_depth ( inode ) ; ex = path [ depth ] . p_ext ; } <S2SV_ModEnd> err = ext4_ext_get_access\n","project_and_commit_id":"torvalds@linux/dee1f973ca341c266229faa5a1a5bb268bed3531","cve_id":"CVE-2012-4508","original_address":"https://github.com/torvalds/linux/commit/dee1f973ca341c266229faa5a1a5bb268bed3531","time":"2012-12-21T11:47Z"},
	{"Unnamed: 0":672,"cwe_id":"CWE-754","source":"CWE-754 Expr * sqlite3CreateColumnExpr ( sqlite3 * db , SrcList * pSrc , int iSrc , int iCol ) { Expr * p = sqlite3ExprAlloc ( db , TK_COLUMN , 0 , 0 ) ; if ( p ) { struct SrcList_item * pItem = & pSrc -> a [ iSrc ] ; <S2SV_StartBug> p -> y . pTab = pItem -> pTab ; <S2SV_EndBug> p -> iTable = pItem -> iCursor ; if ( p -> y . pTab -> iPKey == iCol ) { p -> iColumn = - 1 ; } else { p -> iColumn = ( ynVar ) iCol ; <S2SV_StartBug> testcase ( iCol == BMS ) ; <S2SV_EndBug> testcase ( iCol == BMS - 1 ) ; pItem -> colUsed |= ( ( Bitmask ) 1 ) << ( iCol >= BMS ? BMS - 1 : iCol ) ; } } <S2SV_StartBug> return p ; <S2SV_EndBug> }\n","target":"<S2SV_ModStart> iSrc ] ; Table * pTab = <S2SV_ModStart> ) iCol ; if ( pTab -> tabFlags & TF_HasGenerated ) { Column * pColumn = pTab -> aCol + iCol ; if ( pColumn -> colFlags & COLFLAG_GENERATED ) { testcase ( pTab -> nCol == 63 ) ; testcase ( pTab -> nCol == 64 ) ; if ( pTab -> nCol >= 64 ) { pItem -> colUsed = ALLBITS ; } else { pItem -> colUsed = MASKBIT ( pTab -> nCol ) - 1 ; } } } else { <S2SV_ModStart> ; } } }\n","project_and_commit_id":"sqlite@sqlite/926f796e8feec15f3836aa0a060ed906f8ae04d3","cve_id":"CVE-2019-19646","original_address":"https://github.com/sqlite/sqlite/commit/926f796e8feec15f3836aa0a060ed906f8ae04d3","time":"2019-12-09T19:15Z"},
	{"Unnamed: 0":1707,"cwe_id":"CWE-125","source":"CWE-125 static stmt_ty ast_for_with_stmt ( struct compiling * c , const node * n0 , bool is_async ) { const node * const n = is_async ? CHILD ( n0 , 1 ) : n0 ; <S2SV_StartBug> int i , n_items , end_lineno , end_col_offset ; <S2SV_EndBug> asdl_seq * items , * body ; <S2SV_StartBug> REQ ( n , with_stmt ) ; <S2SV_EndBug> <S2SV_StartBug> n_items = ( NCH ( n ) - 2 ) / 2 ; <S2SV_EndBug> items = _Py_asdl_seq_new ( n_items , c -> c_arena ) ; if ( ! items ) return NULL ; <S2SV_StartBug> for ( i = 1 ; i < NCH ( n ) - 2 ; i += 2 ) { <S2SV_EndBug> withitem_ty item = ast_for_with_item ( c , CHILD ( n , i ) ) ; if ( ! item ) return NULL ; asdl_seq_SET ( items , ( i - 1 ) / 2 , item ) ; } body = ast_for_suite ( c , CHILD ( n , NCH ( n ) - 1 ) ) ; if ( ! body ) return NULL ; get_last_end_pos ( body , & end_lineno , & end_col_offset ) ; <S2SV_StartBug> if ( is_async ) <S2SV_EndBug> <S2SV_StartBug> return AsyncWith ( items , body , LINENO ( n0 ) , n0 -> n_col_offset , <S2SV_EndBug> end_lineno , end_col_offset , c -> c_arena ) ; else <S2SV_StartBug> return With ( items , body , LINENO ( n ) , n -> n_col_offset , <S2SV_EndBug> end_lineno , end_col_offset , c -> c_arena ) ; }\n","target":"<S2SV_ModStart> , n_items , nch_minus_type , has_type_comment , <S2SV_ModStart> * body ; string type_comment ; <S2SV_ModStart> with_stmt ) ; has_type_comment = TYPE ( CHILD ( n , NCH ( n ) - 2 ) ) == TYPE_COMMENT ; nch_minus_type = NCH ( n ) - has_type_comment ; <S2SV_ModStart> n_items = ( nch_minus_type <S2SV_ModEnd> - 2 ) <S2SV_ModStart> ; i < nch_minus_type <S2SV_ModEnd> - 2 ; <S2SV_ModStart> ; if ( has_type_comment ) { type_comment = NEW_TYPE_COMMENT ( CHILD ( n , NCH ( n ) - 2 ) ) ; if ( ! type_comment ) return NULL ; } else type_comment = NULL ; if ( <S2SV_ModStart> , body , type_comment , <S2SV_ModStart> items , body , type_comment\n","project_and_commit_id":"python@typed_ast/dcfcd146f8e6fc5c2fc16a4c192a0c5f5ca8c53c","cve_id":"CVE-2019-19275","original_address":"https://github.com/python/typed_ast/commit/dcfcd146f8e6fc5c2fc16a4c192a0c5f5ca8c53c","time":"2019-11-26T15:15Z"},
	{"Unnamed: 0":5922,"cwe_id":"CWE-399","source":"CWE-399 static void xen_netbk_fill_frags ( struct xen_netbk * netbk , struct sk_buff * skb ) { struct skb_shared_info * shinfo = skb_shinfo ( skb ) ; int nr_frags = shinfo -> nr_frags ; int i ; for ( i = 0 ; i < nr_frags ; i ++ ) { skb_frag_t * frag = shinfo -> frags + i ; struct xen_netif_tx_request * txp ; struct page * page ; u16 pending_idx ; pending_idx = frag_get_pending_idx ( frag ) ; txp = & netbk -> pending_tx_info [ pending_idx ] . req ; page = virt_to_page ( idx_to_kaddr ( netbk , pending_idx ) ) ; __skb_fill_page_desc ( skb , i , page , txp -> offset , txp -> size ) ; skb -> len += txp -> size ; skb -> data_len += txp -> size ; skb -> truesize += txp -> size ; get_page ( netbk -> mmap_pages [ pending_idx ] ) ; <S2SV_StartBug> xen_netbk_idx_release ( netbk , pending_idx ) ; <S2SV_EndBug> } }\n","target":"<S2SV_ModStart> netbk , pending_idx , XEN_NETIF_RSP_OKAY\n","project_and_commit_id":"torvalds@linux/7d5145d8eb2b9791533ffe4dc003b129b9696c48","cve_id":"CVE-2013-0217","original_address":"https://github.com/torvalds/linux/commit/7d5145d8eb2b9791533ffe4dc003b129b9696c48","time":"2013-02-18T04:41Z"},
	{"Unnamed: 0":82,"cwe_id":"CWE-119","source":"CWE-119 static int netlbl_cipsov4_add_common ( struct genl_info * info , struct cipso_v4_doi * doi_def ) { struct nlattr * nla ; int nla_rem ; u32 iter = 0 ; doi_def -> doi = nla_get_u32 ( info -> attrs [ NLBL_CIPSOV4_A_DOI ] ) ; if ( nla_validate_nested ( info -> attrs [ NLBL_CIPSOV4_A_TAGLST ] , NLBL_CIPSOV4_A_MAX , netlbl_cipsov4_genl_policy ) != 0 ) return - EINVAL ; nla_for_each_nested ( nla , info -> attrs [ NLBL_CIPSOV4_A_TAGLST ] , nla_rem ) if ( nla -> nla_type == NLBL_CIPSOV4_A_TAG ) { <S2SV_StartBug> if ( iter > CIPSO_V4_TAG_MAXCNT ) <S2SV_EndBug> return - EINVAL ; doi_def -> tags [ iter ++ ] = nla_get_u8 ( nla ) ; } <S2SV_StartBug> if ( iter < CIPSO_V4_TAG_MAXCNT ) <S2SV_EndBug> <S2SV_StartBug> doi_def -> tags [ iter ] = CIPSO_V4_TAG_INVALID ; <S2SV_EndBug> return 0 ; }\n","target":"<S2SV_ModStart> if ( iter >= <S2SV_ModEnd> CIPSO_V4_TAG_MAXCNT ) return <S2SV_ModStart> ) ; } while <S2SV_ModEnd> ( iter < <S2SV_ModStart> tags [ iter ++\n","project_and_commit_id":"torvalds@linux/2a2f11c227bdf292b3a2900ad04139d301b56ac4","cve_id":"CVE-2007-6762","original_address":"https://github.com/torvalds/linux/commit/2a2f11c227bdf292b3a2900ad04139d301b56ac4","time":"2019-07-27T22:15Z"},
	{"Unnamed: 0":3432,"cwe_id":"CWE-415","source":"CWE-415 static int sc_pkcs15emu_sc_hsm_init ( sc_pkcs15_card_t * p15card ) { sc_card_t * card = p15card -> card ; sc_hsm_private_data_t * priv = ( sc_hsm_private_data_t * ) card -> drv_data ; sc_file_t * file = NULL ; sc_path_t path ; u8 filelist [ MAX_EXT_APDU_LENGTH ] ; int filelistlength ; int r , i ; sc_cvc_t devcert ; struct sc_app_info * appinfo ; struct sc_pkcs15_auth_info pin_info ; struct sc_pkcs15_object pin_obj ; struct sc_pin_cmd_data pindata ; u8 efbin [ 1024 ] ; u8 * ptr ; size_t len ; LOG_FUNC_CALLED ( card -> ctx ) ; appinfo = calloc ( 1 , sizeof ( struct sc_app_info ) ) ; if ( appinfo == NULL ) { LOG_FUNC_RETURN ( card -> ctx , SC_ERROR_OUT_OF_MEMORY ) ; } appinfo -> aid = sc_hsm_aid ; appinfo -> ddo . aid = sc_hsm_aid ; p15card -> app = appinfo ; sc_path_set ( & path , SC_PATH_TYPE_DF_NAME , sc_hsm_aid . value , sc_hsm_aid . len , 0 , 0 ) ; r = sc_select_file ( card , & path , & file ) ; LOG_TEST_RET ( card -> ctx , r , \"Could<S2SV_blank>not<S2SV_blank>select<S2SV_blank>SmartCard-HSM<S2SV_blank>application\" ) ; p15card -> card -> version . hw_major = 24 ; p15card -> card -> version . hw_minor = 13 ; if ( file && file -> prop_attr && file -> prop_attr_len >= 2 ) { p15card -> card -> version . fw_major = file -> prop_attr [ file -> prop_attr_len - 2 ] ; p15card -> card -> version . fw_minor = file -> prop_attr [ file -> prop_attr_len - 1 ] ; } sc_file_free ( file ) ; if ( priv -> EF_C_DevAut && priv -> EF_C_DevAut_len ) { ptr = priv -> EF_C_DevAut ; len = priv -> EF_C_DevAut_len ; } else { len = sizeof efbin ; r = read_file ( p15card , ( u8 * ) \"\\\\x2F\\\\x02\" , efbin , & len , 1 ) ; LOG_TEST_RET ( card -> ctx , r , \"Skipping<S2SV_blank>optional<S2SV_blank>EF.C_DevAut\" ) ; <S2SV_StartBug> ptr = realloc ( priv -> EF_C_DevAut , len ) ; <S2SV_EndBug> if ( ptr ) { memcpy ( ptr , efbin , len ) ; priv -> EF_C_DevAut = ptr ; <S2SV_StartBug> priv -> EF_C_DevAut_len = len ; <S2SV_EndBug> } ptr = efbin ; } memset ( & devcert , 0 , sizeof ( devcert ) ) ; r = sc_pkcs15emu_sc_hsm_decode_cvc ( p15card , ( const u8 * * ) & ptr , & len , & devcert ) ; LOG_TEST_RET ( card -> ctx , r , \"Could<S2SV_blank>not<S2SV_blank>decode<S2SV_blank>EF.C_DevAut\" ) ; sc_pkcs15emu_sc_hsm_read_tokeninfo ( p15card ) ; if ( p15card -> tokeninfo -> label == NULL ) { if ( p15card -> card -> type == SC_CARD_TYPE_SC_HSM_GOID || p15card -> card -> type == SC_CARD_TYPE_SC_HSM_SOC ) { p15card -> tokeninfo -> label = strdup ( \"GoID\" ) ; } else { p15card -> tokeninfo -> label = strdup ( \"SmartCard-HSM\" ) ; } if ( p15card -> tokeninfo -> label == NULL ) LOG_FUNC_RETURN ( card -> ctx , SC_ERROR_OUT_OF_MEMORY ) ; } if ( ( p15card -> tokeninfo -> manufacturer_id != NULL ) && ! strcmp ( \"(unknown)\" , p15card -> tokeninfo -> manufacturer_id ) ) { free ( p15card -> tokeninfo -> manufacturer_id ) ; p15card -> tokeninfo -> manufacturer_id = NULL ; } if ( p15card -> tokeninfo -> manufacturer_id == NULL ) { if ( p15card -> card -> type == SC_CARD_TYPE_SC_HSM_GOID || p15card -> card -> type == SC_CARD_TYPE_SC_HSM_SOC ) { p15card -> tokeninfo -> manufacturer_id = strdup ( \"Bundesdruckerei<S2SV_blank>GmbH\" ) ; } else { p15card -> tokeninfo -> manufacturer_id = strdup ( \"www.CardContact.de\" ) ; } if ( p15card -> tokeninfo -> manufacturer_id == NULL ) LOG_FUNC_RETURN ( card -> ctx , SC_ERROR_OUT_OF_MEMORY ) ; } appinfo -> label = strdup ( p15card -> tokeninfo -> label ) ; if ( appinfo -> label == NULL ) LOG_FUNC_RETURN ( card -> ctx , SC_ERROR_OUT_OF_MEMORY ) ; len = strnlen ( devcert . chr , sizeof devcert . chr ) ; assert ( len >= 8 ) ; len -= 5 ; p15card -> tokeninfo -> serial_number = calloc ( len + 1 , 1 ) ; if ( p15card -> tokeninfo -> serial_number == NULL ) LOG_FUNC_RETURN ( card -> ctx , SC_ERROR_OUT_OF_MEMORY ) ; memcpy ( p15card -> tokeninfo -> serial_number , devcert . chr , len ) ; * ( p15card -> tokeninfo -> serial_number + len ) = 0 ; sc_hsm_set_serialnr ( card , p15card -> tokeninfo -> serial_number ) ; sc_pkcs15emu_sc_hsm_free_cvc ( & devcert ) ; memset ( & pin_info , 0 , sizeof ( pin_info ) ) ; memset ( & pin_obj , 0 , sizeof ( pin_obj ) ) ; pin_info . auth_id . len = 1 ; pin_info . auth_id . value [ 0 ] = 1 ; pin_info . path . aid = sc_hsm_aid ; pin_info . auth_type = SC_PKCS15_PIN_AUTH_TYPE_PIN ; pin_info . attrs . pin . reference = 0x81 ; pin_info . attrs . pin . flags = SC_PKCS15_PIN_FLAG_LOCAL | SC_PKCS15_PIN_FLAG_INITIALIZED | SC_PKCS15_PIN_FLAG_EXCHANGE_REF_DATA ; pin_info . attrs . pin . type = SC_PKCS15_PIN_TYPE_ASCII_NUMERIC ; pin_info . attrs . pin . min_length = 6 ; pin_info . attrs . pin . stored_length = 0 ; pin_info . attrs . pin . max_length = 15 ; pin_info . attrs . pin . pad_char = '\\\\0' ; pin_info . tries_left = 3 ; pin_info . max_tries = 3 ; pin_obj . auth_id . len = 1 ; pin_obj . auth_id . value [ 0 ] = 2 ; strlcpy ( pin_obj . label , \"UserPIN\" , sizeof ( pin_obj . label ) ) ; pin_obj . flags = SC_PKCS15_CO_FLAG_PRIVATE | SC_PKCS15_CO_FLAG_MODIFIABLE ; r = sc_pkcs15emu_add_pin_obj ( p15card , & pin_obj , & pin_info ) ; if ( r < 0 ) LOG_FUNC_RETURN ( card -> ctx , r ) ; memset ( & pin_info , 0 , sizeof ( pin_info ) ) ; memset ( & pin_obj , 0 , sizeof ( pin_obj ) ) ; pin_info . auth_id . len = 1 ; pin_info . auth_id . value [ 0 ] = 2 ; pin_info . path . aid = sc_hsm_aid ; pin_info . auth_type = SC_PKCS15_PIN_AUTH_TYPE_PIN ; pin_info . attrs . pin . reference = 0x88 ; pin_info . attrs . pin . flags = SC_PKCS15_PIN_FLAG_LOCAL | SC_PKCS15_PIN_FLAG_INITIALIZED | SC_PKCS15_PIN_FLAG_UNBLOCK_DISABLED | SC_PKCS15_PIN_FLAG_SO_PIN ; pin_info . attrs . pin . type = SC_PKCS15_PIN_TYPE_BCD ; pin_info . attrs . pin . min_length = 16 ; pin_info . attrs . pin . stored_length = 0 ; pin_info . attrs . pin . max_length = 16 ; pin_info . attrs . pin . pad_char = '\\\\0' ; pin_info . tries_left = 15 ; pin_info . max_tries = 15 ; strlcpy ( pin_obj . label , \"SOPIN\" , sizeof ( pin_obj . label ) ) ; pin_obj . flags = SC_PKCS15_CO_FLAG_PRIVATE ; r = sc_pkcs15emu_add_pin_obj ( p15card , & pin_obj , & pin_info ) ; if ( r < 0 ) LOG_FUNC_RETURN ( card -> ctx , r ) ; if ( card -> type == SC_CARD_TYPE_SC_HSM_SOC || card -> type == SC_CARD_TYPE_SC_HSM_GOID ) { r = SC_SUCCESS ; } else { memset ( & pindata , 0 , sizeof ( pindata ) ) ; pindata . cmd = SC_PIN_CMD_GET_INFO ; pindata . pin_type = SC_AC_CHV ; pindata . pin_reference = 0x85 ; r = sc_pin_cmd ( card , & pindata , NULL ) ; } if ( r == SC_ERROR_DATA_OBJECT_NOT_FOUND ) { memset ( & pindata , 0 , sizeof ( pindata ) ) ; pindata . cmd = SC_PIN_CMD_GET_INFO ; pindata . pin_type = SC_AC_CHV ; pindata . pin_reference = 0x86 ; r = sc_pin_cmd ( card , & pindata , NULL ) ; } if ( ( r != SC_ERROR_DATA_OBJECT_NOT_FOUND ) && ( r != SC_ERROR_INCORRECT_PARAMETERS ) ) card -> caps |= SC_CARD_CAP_PROTECTED_AUTHENTICATION_PATH ; filelistlength = sc_list_files ( card , filelist , sizeof ( filelist ) ) ; LOG_TEST_RET ( card -> ctx , filelistlength , \"Could<S2SV_blank>not<S2SV_blank>enumerate<S2SV_blank>file<S2SV_blank>and<S2SV_blank>key<S2SV_blank>identifier\" ) ; for ( i = 0 ; i < filelistlength ; i += 2 ) { switch ( filelist [ i ] ) { case KEY_PREFIX : r = sc_pkcs15emu_sc_hsm_add_prkd ( p15card , filelist [ i + 1 ] ) ; break ; case DCOD_PREFIX : r = sc_pkcs15emu_sc_hsm_add_dcod ( p15card , filelist [ i + 1 ] ) ; break ; case CD_PREFIX : r = sc_pkcs15emu_sc_hsm_add_cd ( p15card , filelist [ i + 1 ] ) ; break ; } if ( r != SC_SUCCESS ) { sc_log ( card -> ctx , \"Error<S2SV_blank>%d<S2SV_blank>adding<S2SV_blank>elements<S2SV_blank>to<S2SV_blank>framework\" , r ) ; } } LOG_FUNC_RETURN ( card -> ctx , SC_SUCCESS ) ; }\n","target":"<S2SV_ModStart> \"Skipping<S2SV_blank>optional<S2SV_blank>EF.C_DevAut\" ) ; if ( len > 0 ) { <S2SV_ModStart> = len ; }\n","project_and_commit_id":"OpenSC@OpenSC/360e95d45ac4123255a4c796db96337f332160ad","cve_id":"CVE-2018-16425","original_address":"https://github.com/OpenSC/OpenSC/commit/360e95d45ac4123255a4c796db96337f332160ad","time":"2018-09-04T00:29Z"},
	{"Unnamed: 0":4592,"cwe_id":"CWE-119","source":"CWE-119 void vp8_loopfilter_frame ( VP8_COMP * cpi , VP8_COMMON * cm ) { <S2SV_StartBug> const FRAME_TYPE frame_type = cm -> frame_type ; <S2SV_EndBug> if ( cm -> no_lpf ) { cm -> filter_level = 0 ; } else { struct vpx_usec_timer timer ; vp8_clear_system_state ( ) ; vpx_usec_timer_start ( & timer ) ; <S2SV_StartBug> if ( cpi -> sf . auto_filter == 0 ) <S2SV_EndBug> vp8cx_pick_filter_level_fast ( cpi -> Source , cpi ) ; <S2SV_StartBug> else <S2SV_EndBug> <S2SV_StartBug> vp8cx_pick_filter_level ( cpi -> Source , cpi ) ; <S2SV_EndBug> if ( cm -> filter_level > 0 ) { vp8cx_set_alt_lf_level ( cpi , cm -> filter_level ) ; } vpx_usec_timer_mark ( & timer ) ; cpi -> time_pick_lpf += vpx_usec_timer_elapsed ( & timer ) ; } # if CONFIG_MULTITHREAD if ( cpi -> b_multi_threaded ) sem_post ( & cpi -> h_event_end_lpf ) ; # endif <S2SV_StartBug> if ( cm -> filter_level > 0 ) <S2SV_EndBug> { vp8_loop_filter_frame ( cm , & cpi -> mb . e_mbd , frame_type ) ; } vp8_yv12_extend_frame_borders ( cm -> frame_to_show ) ; }\n","target":"<S2SV_ModStart> -> frame_type ; int update_any_ref_buffers = 1 ; if ( cpi -> common . refresh_last_frame == 0 && cpi -> common . refresh_golden_frame == 0 && cpi -> common . refresh_alt_ref_frame == 0 ) { update_any_ref_buffers = 0 ; } <S2SV_ModStart> == 0 ) { # if CONFIG_TEMPORAL_DENOISING if ( cpi -> oxcf . noise_sensitivity && cm -> frame_type != KEY_FRAME ) { vp8cx_pick_filter_level_fast ( & cpi -> denoiser . yv12_running_avg [ INTRA_FRAME ] , cpi ) ; } else { vp8cx_pick_filter_level_fast ( <S2SV_ModEnd> cpi -> Source <S2SV_ModStart> cpi ) ; } # else vp8cx_pick_filter_level_fast ( cpi -> Source , cpi ) ; # endif } else { # if CONFIG_TEMPORAL_DENOISING if ( cpi -> oxcf . noise_sensitivity && cm -> frame_type != KEY_FRAME ) { vp8cx_pick_filter_level ( & cpi -> denoiser . yv12_running_avg [ INTRA_FRAME ] , cpi ) ; } else { vp8cx_pick_filter_level ( <S2SV_ModEnd> cpi -> Source <S2SV_ModStart> cpi ) ; } # else vp8cx_pick_filter_level ( cpi -> Source , cpi ) ; # endif } <S2SV_ModStart> filter_level > 0 && update_any_ref_buffers\n","project_and_commit_id":"external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426","cve_id":"CVE-2016-1621","original_address":"https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426","time":"2016-03-12T21:59Z"},
	{"Unnamed: 0":5094,"cwe_id":"CWE-404","source":"CWE-404 int nfs3svc_decode_readlinkargs ( struct svc_rqst * rqstp , __be32 * p , struct nfsd3_readlinkargs * args ) { p = decode_fh ( p , & args -> fh ) ; if ( ! p ) return 0 ; <S2SV_StartBug> args -> buffer = page_address ( * ( rqstp -> rq_next_page ++ ) ) ; <S2SV_EndBug> <S2SV_StartBug> return xdr_argsize_check ( rqstp , p ) ; <S2SV_EndBug> }\n","target":"<S2SV_ModStart> return 0 ; if ( ! xdr_argsize_check ( rqstp , p ) ) return 0 ; <S2SV_ModStart> ) ; return 1 <S2SV_ModEnd> ; } <S2SV_null>\n","project_and_commit_id":"torvalds@linux/c70422f760c120480fee4de6c38804c72aa26bc1","cve_id":"CVE-2017-9059","original_address":"https://github.com/torvalds/linux/commit/c70422f760c120480fee4de6c38804c72aa26bc1","time":"2017-05-18T06:29Z"},
	{"Unnamed: 0":1973,"cwe_id":"CWE-787","source":"CWE-787 <S2SV_StartBug> static PixelChannels * * AcquirePixelThreadSet ( const Image * image ) <S2SV_EndBug> { PixelChannels * * pixels ; register ssize_t i ; size_t <S2SV_StartBug> number_threads ; <S2SV_EndBug> number_threads = ( size_t ) GetMagickResourceLimit ( ThreadResource ) ; pixels = ( PixelChannels * * ) AcquireQuantumMemory ( number_threads , sizeof ( * pixels ) ) ; if ( pixels == ( PixelChannels * * ) NULL ) return ( ( PixelChannels * * ) NULL ) ; ( void ) memset ( pixels , 0 , number_threads * sizeof ( * pixels ) ) ; <S2SV_StartBug> for ( i = 0 ; i < ( ssize_t ) number_threads ; i ++ ) <S2SV_EndBug> { register ssize_t j ; <S2SV_StartBug> pixels [ i ] = ( PixelChannels * ) AcquireQuantumMemory ( image -> columns , <S2SV_EndBug> sizeof ( * * pixels ) ) ; if ( pixels [ i ] == ( PixelChannels * ) NULL ) return ( DestroyPixelThreadSet ( pixels ) ) ; <S2SV_StartBug> for ( j = 0 ; j < ( ssize_t ) image -> columns ; j ++ ) <S2SV_EndBug> { register ssize_t k ; for ( k = 0 ; k < MaxPixelChannels ; k ++ ) pixels [ i ] [ j ] . channel [ k ] = 0.0 ; } } return ( pixels ) ; }\n","target":"<S2SV_ModStart> const Image * images ) { const Image * next ; <S2SV_ModEnd> PixelChannels * * <S2SV_ModStart> i ; size_t columns , <S2SV_ModStart> ) ) ; columns = images -> columns ; for ( next = images ; next != ( Image * ) NULL ; next = next -> next ) columns = MagickMax ( next -> columns , columns ) ; <S2SV_ModStart> ) AcquireQuantumMemory ( columns , <S2SV_ModEnd> sizeof ( * <S2SV_ModStart> ( ssize_t ) <S2SV_ModEnd> columns ; j\n","project_and_commit_id":"ImageMagick@ImageMagick/a906fe9298bf89e01d5272023db687935068849a","cve_id":"CVE-2019-13300","original_address":"https://github.com/ImageMagick/ImageMagick/commit/a906fe9298bf89e01d5272023db687935068849a","time":"2019-07-05T01:15Z"},
	{"Unnamed: 0":5388,"cwe_id":"CWE-000","source":"CWE-000 <S2SV_StartBug> static ext4_io_end_t * ext4_init_io_end ( struct inode * inode ) <S2SV_EndBug> { ext4_io_end_t * io = NULL ; <S2SV_StartBug> io = kmalloc ( sizeof ( * io ) , GFP_NOFS ) ; <S2SV_EndBug> if ( io ) { igrab ( inode ) ; io -> inode = inode ; io -> flag = 0 ; io -> offset = 0 ; io -> size = 0 ; <S2SV_StartBug> io -> error = 0 ; <S2SV_EndBug> INIT_WORK ( & io -> work , ext4_end_io_work ) ; INIT_LIST_HEAD ( & io -> list ) ; } return io ; }\n","target":"<S2SV_ModStart> inode * inode , gfp_t flags <S2SV_ModStart> io ) , flags <S2SV_ModEnd> ) ; if <S2SV_ModStart> ; io -> page = NULL <S2SV_ModEnd> ; INIT_WORK (\n","project_and_commit_id":"torvalds@linux/744692dc059845b2a3022119871846e74d4f6e11","cve_id":"CVE-2015-8324","original_address":"https://github.com/torvalds/linux/commit/744692dc059845b2a3022119871846e74d4f6e11","time":"2016-05-02T10:59Z"},
	{"Unnamed: 0":5403,"cwe_id":"CWE-617","source":"CWE-617 int init_pci ( struct vmctx * ctx ) { struct mem_range mr ; struct pci_vdev_ops * ops ; struct businfo * bi ; struct slotinfo * si ; struct funcinfo * fi ; size_t lowmem ; int bus , slot , func ; int success_cnt = 0 ; int error ; pci_emul_iobase = PCI_EMUL_IOBASE ; pci_emul_membase32 = vm_get_lowmem_limit ( ctx ) ; pci_emul_membase64 = PCI_EMUL_MEMBASE64 ; create_gsi_sharing_groups ( ) ; for ( bus = 0 ; bus < MAXBUSES ; bus ++ ) { bi = pci_businfo [ bus ] ; if ( bi == NULL ) continue ; bi -> iobase = pci_emul_iobase ; bi -> membase32 = pci_emul_membase32 ; bi -> membase64 = pci_emul_membase64 ; for ( slot = 0 ; slot < MAXSLOTS ; slot ++ ) { si = & bi -> slotinfo [ slot ] ; for ( func = 0 ; func < MAXFUNCS ; func ++ ) { fi = & si -> si_funcs [ func ] ; if ( fi -> fi_name == NULL ) continue ; ops = pci_emul_finddev ( fi -> fi_name ) ; <S2SV_StartBug> assert ( ops != NULL ) ; <S2SV_EndBug> pr_notice ( \"pci<S2SV_blank>init<S2SV_blank>%s\\\\r\\\\n\" , fi -> fi_name ) ; error = pci_emul_init ( ctx , ops , bus , slot , func , fi ) ; if ( error ) { pr_err ( \"pci<S2SV_blank>%s<S2SV_blank>init<S2SV_blank>failed\\\\n\" , fi -> fi_name ) ; goto pci_emul_init_fail ; } success_cnt ++ ; } } pci_emul_iobase += BUSIO_ROUNDUP ; pci_emul_iobase = roundup2 ( pci_emul_iobase , BUSIO_ROUNDUP ) ; bi -> iolimit = pci_emul_iobase ; pci_emul_membase32 += BUSMEM_ROUNDUP ; pci_emul_membase32 = roundup2 ( pci_emul_membase32 , BUSMEM_ROUNDUP ) ; bi -> memlimit32 = pci_emul_membase32 ; pci_emul_membase64 += BUSMEM_ROUNDUP ; pci_emul_membase64 = roundup2 ( pci_emul_membase64 , BUSMEM_ROUNDUP ) ; bi -> memlimit64 = pci_emul_membase64 ; } error = check_gsi_sharing_violation ( ) ; if ( error < 0 ) goto pci_emul_init_fail ; for ( bus = 0 ; bus < MAXBUSES ; bus ++ ) { bi = pci_businfo [ bus ] ; if ( bi == NULL ) continue ; for ( slot = 0 ; slot < MAXSLOTS ; slot ++ ) { si = & bi -> slotinfo [ slot ] ; for ( func = 0 ; func < MAXFUNCS ; func ++ ) { fi = & si -> si_funcs [ func ] ; if ( fi -> fi_devi == NULL ) continue ; pci_lintr_route ( fi -> fi_devi ) ; ops = fi -> fi_devi -> dev_ops ; if ( ops && ops -> vdev_phys_access ) ops -> vdev_phys_access ( ctx , fi -> fi_devi ) ; } } } lpc_pirq_routed ( ) ; lowmem = vm_get_lowmem_size ( ctx ) ; bzero ( & mr , sizeof ( struct mem_range ) ) ; mr . name = \"PCI<S2SV_blank>hole<S2SV_blank>(32-bit)\" ; mr . flags = MEM_F_RW ; mr . base = lowmem ; mr . size = ( 4ULL * 1024 * 1024 * 1024 ) - lowmem ; mr . handler = pci_emul_fallback_handler ; error = register_mem_fallback ( & mr ) ; <S2SV_StartBug> assert ( error == 0 ) ; <S2SV_EndBug> bzero ( & mr , sizeof ( struct mem_range ) ) ; mr . name = \"PCI<S2SV_blank>hole<S2SV_blank>(64-bit)\" ; mr . flags = MEM_F_RW ; mr . base = PCI_EMUL_MEMBASE64 ; mr . size = PCI_EMUL_MEMLIMIT64 - PCI_EMUL_MEMBASE64 ; mr . handler = pci_emul_fallback_handler ; error = register_mem_fallback ( & mr ) ; <S2SV_StartBug> assert ( error == 0 ) ; <S2SV_EndBug> bzero ( & mr , sizeof ( struct mem_range ) ) ; mr . name = \"PCI<S2SV_blank>ECFG\" ; mr . flags = MEM_F_RW ; mr . base = PCI_EMUL_ECFG_BASE ; mr . size = PCI_EMUL_ECFG_SIZE ; mr . handler = pci_emul_ecfg_handler ; error = register_mem ( & mr ) ; <S2SV_StartBug> assert ( error == 0 ) ; <S2SV_EndBug> return 0 ; pci_emul_init_fail : for ( bus = 0 ; bus < MAXBUSES && success_cnt > 0 ; bus ++ ) { bi = pci_businfo [ bus ] ; if ( bi == NULL ) continue ; for ( slot = 0 ; slot < MAXSLOTS && success_cnt > 0 ; slot ++ ) { si = & bi -> slotinfo [ slot ] ; for ( func = 0 ; func < MAXFUNCS ; func ++ ) { fi = & si -> si_funcs [ func ] ; if ( fi -> fi_name == NULL ) continue ; if ( success_cnt -- <= 0 ) break ; ops = pci_emul_finddev ( fi -> fi_name ) ; <S2SV_StartBug> assert ( ops != NULL ) ; <S2SV_EndBug> pci_emul_deinit ( ctx , ops , bus , slot , func , fi ) ; } } } return error ; }\n","target":"<S2SV_ModStart> fi_name ) ; if ( ! ops ) { pr_warn ( \"No<S2SV_blank>driver<S2SV_blank>for<S2SV_blank>device<S2SV_blank>[%s]\\\\n\" , fi -> fi_name ) ; continue ; } <S2SV_ModEnd> pr_notice ( \"pci<S2SV_blank>init<S2SV_blank>%s\\\\r\\\\n\" <S2SV_ModStart> mr ) ; if ( error != 0 ) goto pci_emul_init_fail <S2SV_ModEnd> ; bzero ( <S2SV_ModStart> mr ) ; if ( error != 0 ) goto pci_emul_init_fail <S2SV_ModEnd> ; bzero ( <S2SV_ModStart> mr ) ; if ( error != 0 ) goto pci_emul_init_fail <S2SV_ModEnd> ; return 0 <S2SV_ModStart> fi_name ) ; if ( ! ops ) { pr_warn ( \"No<S2SV_blank>driver<S2SV_blank>for<S2SV_blank>device<S2SV_blank>[%s]\\\\n\" , fi -> fi_name ) ; continue ; } <S2SV_ModEnd> pci_emul_deinit ( ctx\n","project_and_commit_id":"projectacrn@acrn-hypervisor/2b3dedfb9ba13f15887f22b935d373f36c9a59fa","cve_id":"CVE-2019-18844","original_address":"https://github.com/projectacrn/acrn-hypervisor/commit/2b3dedfb9ba13f15887f22b935d373f36c9a59fa","time":"2019-11-13T20:15Z"},
	{"Unnamed: 0":3599,"cwe_id":"CWE-787","source":"CWE-787 void avcodec_align_dimensions2 ( AVCodecContext * s , int * width , int * height , int linesize_align [ AV_NUM_DATA_POINTERS ] ) { int i ; int w_align = 1 ; int h_align = 1 ; AVPixFmtDescriptor const * desc = av_pix_fmt_desc_get ( s -> pix_fmt ) ; if ( desc ) { w_align = 1 << desc -> log2_chroma_w ; h_align = 1 << desc -> log2_chroma_h ; } switch ( s -> pix_fmt ) { case AV_PIX_FMT_YUV420P : case AV_PIX_FMT_YUYV422 : case AV_PIX_FMT_YVYU422 : case AV_PIX_FMT_UYVY422 : case AV_PIX_FMT_YUV422P : case AV_PIX_FMT_YUV440P : case AV_PIX_FMT_YUV444P : case AV_PIX_FMT_GBRP : case AV_PIX_FMT_GBRAP : case AV_PIX_FMT_GRAY8 : case AV_PIX_FMT_GRAY16BE : case AV_PIX_FMT_GRAY16LE : case AV_PIX_FMT_YUVJ420P : case AV_PIX_FMT_YUVJ422P : case AV_PIX_FMT_YUVJ440P : case AV_PIX_FMT_YUVJ444P : case AV_PIX_FMT_YUVA420P : case AV_PIX_FMT_YUVA422P : case AV_PIX_FMT_YUVA444P : case AV_PIX_FMT_YUV420P9LE : case AV_PIX_FMT_YUV420P9BE : case AV_PIX_FMT_YUV420P10LE : case AV_PIX_FMT_YUV420P10BE : case AV_PIX_FMT_YUV420P12LE : case AV_PIX_FMT_YUV420P12BE : case AV_PIX_FMT_YUV420P14LE : case AV_PIX_FMT_YUV420P14BE : case AV_PIX_FMT_YUV420P16LE : case AV_PIX_FMT_YUV420P16BE : case AV_PIX_FMT_YUVA420P9LE : case AV_PIX_FMT_YUVA420P9BE : case AV_PIX_FMT_YUVA420P10LE : case AV_PIX_FMT_YUVA420P10BE : case AV_PIX_FMT_YUVA420P16LE : case AV_PIX_FMT_YUVA420P16BE : case AV_PIX_FMT_YUV422P9LE : case AV_PIX_FMT_YUV422P9BE : case AV_PIX_FMT_YUV422P10LE : case AV_PIX_FMT_YUV422P10BE : case AV_PIX_FMT_YUV422P12LE : case AV_PIX_FMT_YUV422P12BE : case AV_PIX_FMT_YUV422P14LE : case AV_PIX_FMT_YUV422P14BE : case AV_PIX_FMT_YUV422P16LE : case AV_PIX_FMT_YUV422P16BE : case AV_PIX_FMT_YUVA422P9LE : case AV_PIX_FMT_YUVA422P9BE : case AV_PIX_FMT_YUVA422P10LE : case AV_PIX_FMT_YUVA422P10BE : case AV_PIX_FMT_YUVA422P16LE : case AV_PIX_FMT_YUVA422P16BE : case AV_PIX_FMT_YUV440P10LE : case AV_PIX_FMT_YUV440P10BE : case AV_PIX_FMT_YUV440P12LE : case AV_PIX_FMT_YUV440P12BE : case AV_PIX_FMT_YUV444P9LE : case AV_PIX_FMT_YUV444P9BE : case AV_PIX_FMT_YUV444P10LE : case AV_PIX_FMT_YUV444P10BE : case AV_PIX_FMT_YUV444P12LE : case AV_PIX_FMT_YUV444P12BE : case AV_PIX_FMT_YUV444P14LE : case AV_PIX_FMT_YUV444P14BE : case AV_PIX_FMT_YUV444P16LE : case AV_PIX_FMT_YUV444P16BE : case AV_PIX_FMT_YUVA444P9LE : case AV_PIX_FMT_YUVA444P9BE : case AV_PIX_FMT_YUVA444P10LE : case AV_PIX_FMT_YUVA444P10BE : case AV_PIX_FMT_YUVA444P16LE : case AV_PIX_FMT_YUVA444P16BE : case AV_PIX_FMT_GBRP9LE : case AV_PIX_FMT_GBRP9BE : case AV_PIX_FMT_GBRP10LE : case AV_PIX_FMT_GBRP10BE : case AV_PIX_FMT_GBRP12LE : case AV_PIX_FMT_GBRP12BE : case AV_PIX_FMT_GBRP14LE : case AV_PIX_FMT_GBRP14BE : case AV_PIX_FMT_GBRP16LE : case AV_PIX_FMT_GBRP16BE : case AV_PIX_FMT_GBRAP12LE : case AV_PIX_FMT_GBRAP12BE : case AV_PIX_FMT_GBRAP16LE : case AV_PIX_FMT_GBRAP16BE : w_align = 16 ; h_align = 16 * 2 ; break ; case AV_PIX_FMT_YUV411P : case AV_PIX_FMT_YUVJ411P : case AV_PIX_FMT_UYYVYY411 : w_align = 32 ; h_align = 16 * 2 ; break ; case AV_PIX_FMT_YUV410P : if ( s -> codec_id == AV_CODEC_ID_SVQ1 ) { w_align = 64 ; h_align = 64 ; } break ; case AV_PIX_FMT_RGB555 : if ( s -> codec_id == AV_CODEC_ID_RPZA ) { w_align = 4 ; h_align = 4 ; } <S2SV_StartBug> break ; <S2SV_EndBug> case AV_PIX_FMT_PAL8 : case AV_PIX_FMT_BGR8 : case AV_PIX_FMT_RGB8 : if ( s -> codec_id == AV_CODEC_ID_SMC || s -> codec_id == AV_CODEC_ID_CINEPAK ) { w_align = 4 ; h_align = 4 ; } <S2SV_StartBug> if ( s -> codec_id == AV_CODEC_ID_JV ) { <S2SV_EndBug> w_align = 8 ; h_align = 8 ; } break ; case AV_PIX_FMT_BGR24 : if ( ( s -> codec_id == AV_CODEC_ID_MSZH ) || ( s -> codec_id == AV_CODEC_ID_ZLIB ) ) { w_align = 4 ; h_align = 4 ; } break ; case AV_PIX_FMT_RGB24 : if ( s -> codec_id == AV_CODEC_ID_CINEPAK ) { w_align = 4 ; h_align = 4 ; } break ; default : break ; } if ( s -> codec_id == AV_CODEC_ID_IFF_ILBM ) { w_align = FFMAX ( w_align , 8 ) ; } * width = FFALIGN ( * width , w_align ) ; * height = FFALIGN ( * height , h_align ) ; if ( s -> codec_id == AV_CODEC_ID_H264 || s -> lowres ) { * height += 2 ; * width = FFMAX ( * width , 32 ) ; } for ( i = 0 ; i < 4 ; i ++ ) linesize_align [ i ] = STRIDE_ALIGN ; }\n","target":"<S2SV_ModStart> 4 ; } if ( s -> codec_id == AV_CODEC_ID_INTERPLAY_VIDEO ) { w_align = 8 ; h_align = 8 ; } <S2SV_ModStart> codec_id == AV_CODEC_ID_JV || s -> codec_id == AV_CODEC_ID_INTERPLAY_VIDEO\n","project_and_commit_id":"FFmpeg@FFmpeg/2080bc33717955a0e4268e738acf8c1eeddbf8cb","cve_id":"CVE-2017-7865","original_address":"https://github.com/FFmpeg/FFmpeg/commit/2080bc33717955a0e4268e738acf8c1eeddbf8cb","time":"2017-04-14T04:59Z"},
	{"Unnamed: 0":6602,"cwe_id":"CWE-119","source":"CWE-119 static gboolean cosine_seek_read ( wtap * wth , gint64 seek_off , struct wtap_pkthdr * phdr , Buffer * buf , int * err , gchar * * err_info ) { <S2SV_StartBug> int pkt_len ; <S2SV_EndBug> char line [ COSINE_LINE_LENGTH ] ; if ( file_seek ( wth -> random_fh , seek_off , SEEK_SET , err ) == - 1 ) return FALSE ; if ( file_gets ( line , COSINE_LINE_LENGTH , wth -> random_fh ) == NULL ) { * err = file_error ( wth -> random_fh , err_info ) ; if ( * err == 0 ) { * err = WTAP_ERR_SHORT_READ ; } return FALSE ; } <S2SV_StartBug> pkt_len = parse_cosine_rec_hdr ( phdr , line , err , err_info ) ; <S2SV_EndBug> if ( pkt_len == - 1 ) return FALSE ; <S2SV_StartBug> return parse_cosine_hex_dump ( wth -> random_fh , phdr , pkt_len , buf , err , <S2SV_EndBug> err_info ) ; }\n","target":"<S2SV_ModStart> err_info ) { <S2SV_ModEnd> char line [ <S2SV_ModStart> FALSE ; } return parse_cosine_packet <S2SV_ModEnd> ( wth -> <S2SV_ModStart> , phdr , buf , line <S2SV_ModEnd> , err ,\n","project_and_commit_id":"wireshark@wireshark/f5ec0afb766f19519ea9623152cca3bbe2229500","cve_id":"CVE-2016-5356","original_address":"https://github.com/wireshark/wireshark/commit/f5ec0afb766f19519ea9623152cca3bbe2229500","time":"2016-08-07T16:59Z"},
	{"Unnamed: 0":3378,"cwe_id":"CWE-416","source":"CWE-416 static ssize_t sg_write ( struct file * filp , const char __user * buf , size_t count , loff_t * ppos ) { int mxsize , cmd_size , k ; int input_size , blocking ; unsigned char opcode ; Sg_device * sdp ; Sg_fd * sfp ; Sg_request * srp ; struct sg_header old_hdr ; sg_io_hdr_t * hp ; unsigned char cmnd [ SG_MAX_CDB_SIZE ] ; <S2SV_StartBug> if ( ( ! ( sfp = ( Sg_fd * ) filp -> private_data ) ) || ( ! ( sdp = sfp -> parentdp ) ) ) <S2SV_EndBug> return - ENXIO ; SCSI_LOG_TIMEOUT ( 3 , sg_printk ( KERN_INFO , sdp , \"sg_write:<S2SV_blank>count=%d\\\\n\" , ( int ) count ) ) ; if ( atomic_read ( & sdp -> detaching ) ) return - ENODEV ; if ( ! ( ( filp -> f_flags & O_NONBLOCK ) || scsi_block_when_processing_errors ( sdp -> device ) ) ) return - ENXIO ; if ( ! access_ok ( VERIFY_READ , buf , count ) ) return - EFAULT ; if ( count < SZ_SG_HEADER ) return - EIO ; if ( __copy_from_user ( & old_hdr , buf , SZ_SG_HEADER ) ) return - EFAULT ; blocking = ! ( filp -> f_flags & O_NONBLOCK ) ; if ( old_hdr . reply_len < 0 ) return sg_new_write ( sfp , filp , buf , count , blocking , 0 , 0 , NULL ) ; if ( count < ( SZ_SG_HEADER + 6 ) ) return - EIO ; if ( ! ( srp = sg_add_request ( sfp ) ) ) { SCSI_LOG_TIMEOUT ( 1 , sg_printk ( KERN_INFO , sdp , \"sg_write:<S2SV_blank>queue<S2SV_blank>full\\\\n\" ) ) ; return - EDOM ; } buf += SZ_SG_HEADER ; __get_user ( opcode , buf ) ; if ( sfp -> next_cmd_len > 0 ) { cmd_size = sfp -> next_cmd_len ; sfp -> next_cmd_len = 0 ; } else { cmd_size = COMMAND_SIZE ( opcode ) ; if ( ( opcode >= 0xc0 ) && old_hdr . twelve_byte ) cmd_size = 12 ; } SCSI_LOG_TIMEOUT ( 4 , sg_printk ( KERN_INFO , sdp , \"sg_write:<S2SV_blank><S2SV_blank><S2SV_blank>scsi<S2SV_blank>opcode=0x%02x,<S2SV_blank>cmd_size=%d\\\\n\" , ( int ) opcode , cmd_size ) ) ; input_size = count - cmd_size ; mxsize = ( input_size > old_hdr . reply_len ) ? input_size : old_hdr . reply_len ; mxsize -= SZ_SG_HEADER ; input_size -= SZ_SG_HEADER ; if ( input_size < 0 ) { sg_remove_request ( sfp , srp ) ; return - EIO ; } hp = & srp -> header ; hp -> interface_id = '\\\\0' ; hp -> cmd_len = ( unsigned char ) cmd_size ; hp -> iovec_count = 0 ; hp -> mx_sb_len = 0 ; if ( input_size > 0 ) hp -> dxfer_direction = ( old_hdr . reply_len > SZ_SG_HEADER ) ? SG_DXFER_TO_FROM_DEV : SG_DXFER_TO_DEV ; else hp -> dxfer_direction = ( mxsize > 0 ) ? SG_DXFER_FROM_DEV : SG_DXFER_NONE ; hp -> dxfer_len = mxsize ; if ( ( hp -> dxfer_direction == SG_DXFER_TO_DEV ) || ( hp -> dxfer_direction == SG_DXFER_TO_FROM_DEV ) ) hp -> dxferp = ( char __user * ) buf + cmd_size ; else hp -> dxferp = NULL ; hp -> sbp = NULL ; hp -> timeout = old_hdr . reply_len ; hp -> flags = input_size ; hp -> pack_id = old_hdr . pack_id ; hp -> usr_ptr = NULL ; if ( __copy_from_user ( cmnd , buf , cmd_size ) ) return - EFAULT ; if ( hp -> dxfer_direction == SG_DXFER_TO_FROM_DEV ) { static char cmd [ TASK_COMM_LEN ] ; if ( strcmp ( current -> comm , cmd ) ) { printk_ratelimited ( KERN_WARNING \"sg_write:<S2SV_blank>data<S2SV_blank>in/out<S2SV_blank>%d/%d<S2SV_blank>bytes<S2SV_blank>\" \"for<S2SV_blank>SCSI<S2SV_blank>command<S2SV_blank>0x%x--<S2SV_blank>guessing<S2SV_blank>\" \"data<S2SV_blank>in;\\\\n<S2SV_blank><S2SV_blank><S2SV_blank>program<S2SV_blank>%s<S2SV_blank>not<S2SV_blank>setting<S2SV_blank>\" \"count<S2SV_blank>and/or<S2SV_blank>reply_len<S2SV_blank>properly\\\\n\" , old_hdr . reply_len - ( int ) SZ_SG_HEADER , input_size , ( unsigned int ) cmnd [ 0 ] , current -> comm ) ; strcpy ( cmd , current -> comm ) ; } } k = sg_common_write ( sfp , srp , cmnd , sfp -> timeout , blocking ) ; return ( k < 0 ) ? k : count ; }\n","target":"<S2SV_ModStart> ; if ( unlikely ( segment_eq ( get_fs ( ) , KERNEL_DS ) ) ) return - EINVAL ; if (\n","project_and_commit_id":"torvalds@linux/128394eff343fc6d2f32172f03e24829539c5835","cve_id":"CVE-2016-10088","original_address":"https://github.com/torvalds/linux/commit/128394eff343fc6d2f32172f03e24829539c5835","time":"2016-12-30T18:59Z"},
	{"Unnamed: 0":207,"cwe_id":"CWE-119","source":"CWE-119 static Image * ReadDCMImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { <S2SV_StartBug> # define ThrowDCMException ( exception , message ) { if ( info . scale != ( Quantum * ) NULL ) info . scale = ( Quantum * ) RelinquishMagickMemory ( info . scale ) ; if ( data != ( unsigned char * ) NULL ) data = ( unsigned char * ) RelinquishMagickMemory ( data ) ; if ( graymap != ( int * ) NULL ) graymap = ( int * ) RelinquishMagickMemory ( graymap ) ; if ( bluemap != ( int * ) NULL ) bluemap = ( int * ) RelinquishMagickMemory ( bluemap ) ; if ( greenmap != ( int * ) NULL ) greenmap = ( int * ) RelinquishMagickMemory ( greenmap ) ; if ( redmap != ( int * ) NULL ) redmap = ( int * ) RelinquishMagickMemory ( redmap ) ; if ( stream_info -> offsets != ( ssize_t * ) NULL ) stream_info -> offsets = ( ssize_t * ) RelinquishMagickMemory ( stream_info -> offsets ) ; if ( stream_info != ( DCMStreamInfo * ) NULL ) stream_info = ( DCMStreamInfo * ) RelinquishMagickMemory ( stream_info ) ; ThrowReaderException ( ( exception ) , ( message ) ) ; } <S2SV_EndBug> char explicit_vr [ MagickPathExtent ] , implicit_vr [ MagickPathExtent ] , magick [ MagickPathExtent ] , photometric [ MagickPathExtent ] ; DCMInfo info ; DCMStreamInfo * stream_info ; Image * image ; int * bluemap , datum , * greenmap , * graymap , * redmap ; MagickBooleanType explicit_file , explicit_retry , use_explicit ; MagickOffsetType offset ; register unsigned char * p ; register ssize_t i ; size_t colors , height , length , number_scenes , quantum , status , width ; ssize_t count , scene ; unsigned char * data ; unsigned short group , element ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickCoreSignature ) ; if ( image_info -> debug != MagickFalse ) ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , \"%s\" , image_info -> filename ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickCoreSignature ) ; image = AcquireImage ( image_info , exception ) ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } image -> depth = 8UL ; image -> endian = LSBEndian ; ( void ) memset ( & info , 0 , sizeof ( info ) ) ; data = ( unsigned char * ) NULL ; graymap = ( int * ) NULL ; redmap = ( int * ) NULL ; greenmap = ( int * ) NULL ; bluemap = ( int * ) NULL ; stream_info = ( DCMStreamInfo * ) AcquireMagickMemory ( sizeof ( * stream_info ) ) ; if ( stream_info == ( DCMStreamInfo * ) NULL ) ThrowDCMException ( ResourceLimitError , \"MemoryAllocationFailed\" ) ; ( void ) memset ( stream_info , 0 , sizeof ( * stream_info ) ) ; count = ReadBlob ( image , 128 , ( unsigned char * ) magick ) ; if ( count != 128 ) ThrowDCMException ( CorruptImageError , \"ImproperImageHeader\" ) ; count = ReadBlob ( image , 4 , ( unsigned char * ) magick ) ; if ( ( count != 4 ) || ( LocaleNCompare ( magick , \"DICM\" , 4 ) != 0 ) ) { offset = SeekBlob ( image , 0L , SEEK_SET ) ; if ( offset < 0 ) ThrowDCMException ( CorruptImageError , \"ImproperImageHeader\" ) ; } ( void ) CopyMagickString ( photometric , \"MONOCHROME1<S2SV_blank>\" , MagickPathExtent ) ; info . bits_allocated = 8 ; info . bytes_per_pixel = 1 ; info . depth = 8 ; info . mask = 0xffff ; info . max_value = 255UL ; info . samples_per_pixel = 1 ; info . signed_data = ( ~ 0UL ) ; info . rescale_slope = 1.0 ; data = ( unsigned char * ) NULL ; element = 0 ; explicit_vr [ 2 ] = '\\\\0' ; explicit_file = MagickFalse ; colors = 0 ; redmap = ( int * ) NULL ; greenmap = ( int * ) NULL ; bluemap = ( int * ) NULL ; graymap = ( int * ) NULL ; height = 0 ; number_scenes = 1 ; use_explicit = MagickFalse ; explicit_retry = MagickFalse ; width = 0 ; while ( TellBlob ( image ) < ( MagickOffsetType ) GetBlobSize ( image ) ) { for ( group = 0 ; ( group != 0x7FE0 ) || ( element != 0x0010 ) ; ) { image -> offset = ( ssize_t ) TellBlob ( image ) ; group = ReadBlobLSBShort ( image ) ; element = ReadBlobLSBShort ( image ) ; if ( ( group == 0xfffc ) && ( element == 0xfffc ) ) break ; if ( ( group != 0x0002 ) && ( image -> endian == MSBEndian ) ) { group = ( unsigned short ) ( ( group << 8 ) | ( ( group >> 8 ) & 0xFF ) ) ; element = ( unsigned short ) ( ( element << 8 ) | ( ( element >> 8 ) & 0xFF ) ) ; } quantum = 0 ; for ( i = 0 ; dicom_info [ i ] . group < 0xffff ; i ++ ) if ( ( group == dicom_info [ i ] . group ) && ( element == dicom_info [ i ] . element ) ) break ; ( void ) CopyMagickString ( implicit_vr , dicom_info [ i ] . vr , MagickPathExtent ) ; count = ReadBlob ( image , 2 , ( unsigned char * ) explicit_vr ) ; if ( count != 2 ) ThrowDCMException ( CorruptImageError , \"ImproperImageHeader\" ) ; if ( ( explicit_file == MagickFalse ) && ( group != 0x0002 ) ) explicit_file = ( isupper ( ( unsigned char ) * explicit_vr ) != MagickFalse ) && ( isupper ( ( unsigned char ) * ( explicit_vr + 1 ) ) != MagickFalse ) ? MagickTrue : MagickFalse ; use_explicit = ( ( group == 0x0002 ) && ( explicit_retry == MagickFalse ) ) || ( explicit_file != MagickFalse ) ? MagickTrue : MagickFalse ; if ( ( use_explicit != MagickFalse ) && ( strncmp ( implicit_vr , \"xs\" , 2 ) == 0 ) ) ( void ) CopyMagickString ( implicit_vr , explicit_vr , MagickPathExtent ) ; if ( ( use_explicit == MagickFalse ) || ( strncmp ( implicit_vr , \"!!\" , 2 ) == 0 ) ) { offset = SeekBlob ( image , ( MagickOffsetType ) - 2 , SEEK_CUR ) ; if ( offset < 0 ) ThrowDCMException ( CorruptImageError , \"ImproperImageHeader\" ) ; quantum = 4 ; } else { quantum = 2 ; if ( ( strncmp ( explicit_vr , \"OB\" , 2 ) == 0 ) || ( strncmp ( explicit_vr , \"UN\" , 2 ) == 0 ) || ( strncmp ( explicit_vr , \"OW\" , 2 ) == 0 ) || ( strncmp ( explicit_vr , \"SQ\" , 2 ) == 0 ) ) { ( void ) ReadBlobLSBShort ( image ) ; quantum = 4 ; } } datum = 0 ; if ( quantum == 4 ) { if ( group == 0x0002 ) datum = ReadBlobLSBSignedLong ( image ) ; else datum = ReadBlobSignedLong ( image ) ; } else if ( quantum == 2 ) { if ( group == 0x0002 ) datum = ReadBlobLSBSignedShort ( image ) ; else datum = ReadBlobSignedShort ( image ) ; } quantum = 0 ; length = 1 ; if ( datum != 0 ) { if ( ( strncmp ( implicit_vr , \"OW\" , 2 ) == 0 ) || ( strncmp ( implicit_vr , \"SS\" , 2 ) == 0 ) || ( strncmp ( implicit_vr , \"US\" , 2 ) == 0 ) ) quantum = 2 ; else if ( ( strncmp ( implicit_vr , \"FL\" , 2 ) == 0 ) || ( strncmp ( implicit_vr , \"OF\" , 2 ) == 0 ) || ( strncmp ( implicit_vr , \"SL\" , 2 ) == 0 ) || ( strncmp ( implicit_vr , \"UL\" , 2 ) == 0 ) ) quantum = 4 ; else if ( strncmp ( implicit_vr , \"FD\" , 2 ) == 0 ) quantum = 8 ; else quantum = 1 ; if ( datum != ~ 0 ) length = ( size_t ) datum / quantum ; else { quantum = 0 ; length = 0 ; } } if ( image_info -> verbose != MagickFalse ) { if ( use_explicit == MagickFalse ) explicit_vr [ 0 ] = '\\\\0' ; for ( i = 0 ; dicom_info [ i ] . description != ( char * ) NULL ; i ++ ) if ( ( group == dicom_info [ i ] . group ) && ( element == dicom_info [ i ] . element ) ) break ; ( void ) FormatLocaleFile ( stdout , \"0x%04lX<S2SV_blank>%4ld<S2SV_blank>%s-%s<S2SV_blank>(0x%04lx,0x%04lx)\" , ( unsigned long ) image -> offset , ( long ) length , implicit_vr , explicit_vr , ( unsigned long ) group , ( unsigned long ) element ) ; if ( dicom_info [ i ] . description != ( char * ) NULL ) ( void ) FormatLocaleFile ( stdout , \"<S2SV_blank>%s\" , dicom_info [ i ] . description ) ; ( void ) FormatLocaleFile ( stdout , \":<S2SV_blank>\" ) ; } if ( ( group == 0x7FE0 ) && ( element == 0x0010 ) ) { if ( image_info -> verbose != MagickFalse ) ( void ) FormatLocaleFile ( stdout , \"\\\\n\" ) ; break ; } data = ( unsigned char * ) NULL ; if ( ( length == 1 ) && ( quantum == 1 ) ) datum = ReadBlobByte ( image ) ; else if ( ( length == 1 ) && ( quantum == 2 ) ) { if ( group == 0x0002 ) datum = ReadBlobLSBSignedShort ( image ) ; else datum = ReadBlobSignedShort ( image ) ; } else if ( ( length == 1 ) && ( quantum == 4 ) ) { if ( group == 0x0002 ) datum = ReadBlobLSBSignedLong ( image ) ; else datum = ReadBlobSignedLong ( image ) ; } else if ( ( quantum != 0 ) && ( length != 0 ) ) { if ( length > ( size_t ) GetBlobSize ( image ) ) ThrowDCMException ( CorruptImageError , \"InsufficientImageDataInFile\" ) ; if ( ~ length >= 1 ) data = ( unsigned char * ) AcquireQuantumMemory ( length + 1 , quantum * sizeof ( * data ) ) ; if ( data == ( unsigned char * ) NULL ) ThrowDCMException ( ResourceLimitError , \"MemoryAllocationFailed\" ) ; count = ReadBlob ( image , ( size_t ) quantum * length , data ) ; if ( count != ( ssize_t ) ( quantum * length ) ) { if ( image_info -> verbose != MagickFalse ) ( void ) FormatLocaleFile ( stdout , \"count=%d<S2SV_blank>quantum=%d<S2SV_blank>\" \"length=%d<S2SV_blank>group=%d\\\\n\" , ( int ) count , ( int ) quantum , ( int ) length , ( int ) group ) ; ThrowDCMException ( CorruptImageError , \"InsufficientImageDataInFile\" ) ; } data [ length * quantum ] = '\\\\0' ; } if ( ( ( ( unsigned int ) group << 16 ) | element ) == 0xFFFEE0DD ) { if ( data != ( unsigned char * ) NULL ) data = ( unsigned char * ) RelinquishMagickMemory ( data ) ; continue ; } switch ( group ) { case 0x0002 : { switch ( element ) { case 0x0010 : { char transfer_syntax [ MagickPathExtent ] ; if ( ( datum == 0 ) && ( explicit_retry == MagickFalse ) ) { explicit_retry = MagickTrue ; ( void ) SeekBlob ( image , ( MagickOffsetType ) 0 , SEEK_SET ) ; group = 0 ; element = 0 ; if ( image_info -> verbose != MagickFalse ) ( void ) FormatLocaleFile ( stdout , \"Corrupted<S2SV_blank>image<S2SV_blank>-<S2SV_blank>trying<S2SV_blank>explicit<S2SV_blank>format\\\\n\" ) ; break ; } * transfer_syntax = '\\\\0' ; if ( data != ( unsigned char * ) NULL ) ( void ) CopyMagickString ( transfer_syntax , ( char * ) data , MagickPathExtent ) ; if ( image_info -> verbose != MagickFalse ) ( void ) FormatLocaleFile ( stdout , \"transfer_syntax=%s\\\\n\" , ( const char * ) transfer_syntax ) ; if ( strncmp ( transfer_syntax , \"1.2.840.10008.1.2\" , 17 ) == 0 ) { int subtype , type ; type = 1 ; subtype = 0 ; if ( strlen ( transfer_syntax ) > 17 ) { count = ( ssize_t ) sscanf ( transfer_syntax + 17 , \".%d.%d\" , & type , & subtype ) ; if ( count < 1 ) ThrowDCMException ( CorruptImageError , \"ImproperImageHeader\" ) ; } switch ( type ) { case 1 : { image -> endian = LSBEndian ; break ; } case 2 : { image -> endian = MSBEndian ; break ; } case 4 : { if ( ( subtype >= 80 ) && ( subtype <= 81 ) ) image -> compression = JPEGCompression ; else if ( ( subtype >= 90 ) && ( subtype <= 93 ) ) image -> compression = JPEG2000Compression ; else image -> compression = JPEGCompression ; break ; } case 5 : { image -> compression = RLECompression ; break ; } } } break ; } default : break ; } break ; } case 0x0028 : { switch ( element ) { case 0x0002 : { info . samples_per_pixel = ( size_t ) datum ; if ( ( info . samples_per_pixel == 0 ) || ( info . samples_per_pixel > 4 ) ) ThrowDCMException ( CorruptImageError , \"ImproperImageHeader\" ) ; break ; } case 0x0004 : { if ( data == ( unsigned char * ) NULL ) break ; for ( i = 0 ; i < ( ssize_t ) MagickMin ( length , MagickPathExtent - 1 ) ; i ++ ) photometric [ i ] = ( char ) data [ i ] ; photometric [ i ] = '\\\\0' ; info . polarity = LocaleCompare ( photometric , \"MONOCHROME1<S2SV_blank>\" ) == 0 ? MagickTrue : MagickFalse ; break ; } case 0x0006 : { if ( datum == 1 ) image -> interlace = PlaneInterlace ; break ; } case 0x0008 : { if ( data == ( unsigned char * ) NULL ) break ; number_scenes = StringToUnsignedLong ( ( char * ) data ) ; break ; } case 0x0010 : { height = ( size_t ) datum ; break ; } case 0x0011 : { width = ( size_t ) datum ; break ; } case 0x0100 : { info . bits_allocated = ( size_t ) datum ; info . bytes_per_pixel = 1 ; if ( datum > 8 ) info . bytes_per_pixel = 2 ; info . depth = info . bits_allocated ; if ( ( info . depth == 0 ) || ( info . depth > 32 ) ) ThrowDCMException ( CorruptImageError , \"ImproperImageHeader\" ) ; info . max_value = ( 1UL << info . bits_allocated ) - 1 ; image -> depth = info . depth ; break ; } case 0x0101 : { info . significant_bits = ( size_t ) datum ; info . bytes_per_pixel = 1 ; if ( info . significant_bits > 8 ) info . bytes_per_pixel = 2 ; info . depth = info . significant_bits ; if ( ( info . depth == 0 ) || ( info . depth > 16 ) ) ThrowDCMException ( CorruptImageError , \"ImproperImageHeader\" ) ; info . max_value = ( 1UL << info . significant_bits ) - 1 ; info . mask = ( size_t ) GetQuantumRange ( info . significant_bits ) ; image -> depth = info . depth ; break ; } case 0x0102 : { break ; } case 0x0103 : { info . signed_data = ( size_t ) datum ; break ; } case 0x1050 : { if ( data != ( unsigned char * ) NULL ) info . window_center = StringToDouble ( ( char * ) data , ( char * * ) NULL ) ; break ; } case 0x1051 : { if ( data != ( unsigned char * ) NULL ) info . window_width = StringToDouble ( ( char * ) data , ( char * * ) NULL ) ; break ; } case 0x1052 : { if ( data != ( unsigned char * ) NULL ) info . rescale_intercept = StringToDouble ( ( char * ) data , ( char * * ) NULL ) ; break ; } case 0x1053 : { if ( data != ( unsigned char * ) NULL ) info . rescale_slope = StringToDouble ( ( char * ) data , ( char * * ) NULL ) ; break ; } case 0x1200 : case 0x3006 : { if ( data == ( unsigned char * ) NULL ) break ; colors = ( size_t ) ( length / info . bytes_per_pixel ) ; datum = ( int ) colors ; if ( graymap != ( int * ) NULL ) graymap = ( int * ) RelinquishMagickMemory ( graymap ) ; graymap = ( int * ) AcquireQuantumMemory ( MagickMax ( colors , 65536 ) , sizeof ( * graymap ) ) ; if ( graymap == ( int * ) NULL ) ThrowDCMException ( ResourceLimitError , \"MemoryAllocationFailed\" ) ; ( void ) memset ( graymap , 0 , MagickMax ( colors , 65536 ) * sizeof ( * graymap ) ) ; for ( i = 0 ; i < ( ssize_t ) colors ; i ++ ) if ( info . bytes_per_pixel == 1 ) graymap [ i ] = ( int ) data [ i ] ; else graymap [ i ] = ( int ) ( ( short * ) data ) [ i ] ; break ; } case 0x1201 : { unsigned short index ; if ( data == ( unsigned char * ) NULL ) break ; colors = ( size_t ) ( length / 2 ) ; datum = ( int ) colors ; if ( redmap != ( int * ) NULL ) redmap = ( int * ) RelinquishMagickMemory ( redmap ) ; redmap = ( int * ) AcquireQuantumMemory ( MagickMax ( colors , 65536 ) , sizeof ( * redmap ) ) ; if ( redmap == ( int * ) NULL ) ThrowDCMException ( ResourceLimitError , \"MemoryAllocationFailed\" ) ; ( void ) memset ( redmap , 0 , MagickMax ( colors , 65536 ) * sizeof ( * redmap ) ) ; p = data ; for ( i = 0 ; i < ( ssize_t ) colors ; i ++ ) { if ( image -> endian == MSBEndian ) index = ( unsigned short ) ( ( * p << 8 ) | * ( p + 1 ) ) ; else index = ( unsigned short ) ( * p | ( * ( p + 1 ) << 8 ) ) ; redmap [ i ] = ( int ) index ; p += 2 ; } break ; } case 0x1202 : { unsigned short index ; if ( data == ( unsigned char * ) NULL ) break ; colors = ( size_t ) ( length / 2 ) ; datum = ( int ) colors ; if ( greenmap != ( int * ) NULL ) greenmap = ( int * ) RelinquishMagickMemory ( greenmap ) ; greenmap = ( int * ) AcquireQuantumMemory ( MagickMax ( colors , 65536 ) , sizeof ( * greenmap ) ) ; if ( greenmap == ( int * ) NULL ) ThrowDCMException ( ResourceLimitError , \"MemoryAllocationFailed\" ) ; ( void ) memset ( greenmap , 0 , MagickMax ( colors , 65536 ) * sizeof ( * greenmap ) ) ; p = data ; for ( i = 0 ; i < ( ssize_t ) colors ; i ++ ) { if ( image -> endian == MSBEndian ) index = ( unsigned short ) ( ( * p << 8 ) | * ( p + 1 ) ) ; else index = ( unsigned short ) ( * p | ( * ( p + 1 ) << 8 ) ) ; greenmap [ i ] = ( int ) index ; p += 2 ; } break ; } case 0x1203 : { unsigned short index ; if ( data == ( unsigned char * ) NULL ) break ; colors = ( size_t ) ( length / 2 ) ; datum = ( int ) colors ; if ( bluemap != ( int * ) NULL ) bluemap = ( int * ) RelinquishMagickMemory ( bluemap ) ; bluemap = ( int * ) AcquireQuantumMemory ( MagickMax ( colors , 65536 ) , sizeof ( * bluemap ) ) ; if ( bluemap == ( int * ) NULL ) ThrowDCMException ( ResourceLimitError , \"MemoryAllocationFailed\" ) ; ( void ) memset ( bluemap , 0 , MagickMax ( colors , 65536 ) * sizeof ( * bluemap ) ) ; p = data ; for ( i = 0 ; i < ( ssize_t ) colors ; i ++ ) { if ( image -> endian == MSBEndian ) index = ( unsigned short ) ( ( * p << 8 ) | * ( p + 1 ) ) ; else index = ( unsigned short ) ( * p | ( * ( p + 1 ) << 8 ) ) ; bluemap [ i ] = ( int ) index ; p += 2 ; } break ; } default : break ; } break ; } case 0x2050 : { switch ( element ) { case 0x0020 : { if ( ( data != ( unsigned char * ) NULL ) && ( strncmp ( ( char * ) data , \"INVERSE\" , 7 ) == 0 ) ) info . polarity = MagickTrue ; break ; } default : break ; } break ; } default : break ; } if ( data != ( unsigned char * ) NULL ) { char * attribute ; for ( i = 0 ; dicom_info [ i ] . description != ( char * ) NULL ; i ++ ) if ( ( group == dicom_info [ i ] . group ) && ( element == dicom_info [ i ] . element ) ) break ; if ( dicom_info [ i ] . description != ( char * ) NULL ) { attribute = AcquireString ( \"dcm:\" ) ; ( void ) ConcatenateString ( & attribute , dicom_info [ i ] . description ) ; for ( i = 0 ; i < ( ssize_t ) MagickMax ( length , 4 ) ; i ++ ) if ( isprint ( ( int ) data [ i ] ) == MagickFalse ) break ; if ( ( i == ( ssize_t ) length ) || ( length > 4 ) ) { ( void ) SubstituteString ( & attribute , \"<S2SV_blank>\" , \"\" ) ; ( void ) SetImageProperty ( image , attribute , ( char * ) data , exception ) ; } attribute = DestroyString ( attribute ) ; } } if ( image_info -> verbose != MagickFalse ) { if ( data == ( unsigned char * ) NULL ) ( void ) FormatLocaleFile ( stdout , \"%d\\\\n\" , datum ) ; else { for ( i = 0 ; i < ( ssize_t ) MagickMax ( length , 4 ) ; i ++ ) if ( isprint ( ( int ) data [ i ] ) == MagickFalse ) break ; if ( ( i != ( ssize_t ) length ) && ( length <= 4 ) ) { ssize_t j ; datum = 0 ; for ( j = ( ssize_t ) length - 1 ; j >= 0 ; j -- ) datum = ( 256 * datum + data [ j ] ) ; ( void ) FormatLocaleFile ( stdout , \"%d\" , datum ) ; } else for ( i = 0 ; i < ( ssize_t ) length ; i ++ ) if ( isprint ( ( int ) data [ i ] ) != MagickFalse ) ( void ) FormatLocaleFile ( stdout , \"%c\" , data [ i ] ) ; else ( void ) FormatLocaleFile ( stdout , \"%c\" , '.' ) ; ( void ) FormatLocaleFile ( stdout , \"\\\\n\" ) ; } } if ( data != ( unsigned char * ) NULL ) data = ( unsigned char * ) RelinquishMagickMemory ( data ) ; if ( EOFBlob ( image ) != MagickFalse ) { ThrowFileException ( exception , CorruptImageError , \"UnexpectedEndOfFile\" , image -> filename ) ; break ; } } if ( ( group == 0xfffc ) && ( element == 0xfffc ) ) { Image * last ; last = RemoveLastImageFromList ( & image ) ; if ( last != ( Image * ) NULL ) last = DestroyImage ( last ) ; break ; } if ( ( width == 0 ) || ( height == 0 ) ) ThrowDCMException ( CorruptImageError , \"ImproperImageHeader\" ) ; image -> columns = ( size_t ) width ; image -> rows = ( size_t ) height ; if ( info . signed_data == 0xffff ) info . signed_data = ( size_t ) ( info . significant_bits == 16 ? 1 : 0 ) ; if ( ( image -> compression == JPEGCompression ) || ( image -> compression == JPEG2000Compression ) ) { Image * images ; ImageInfo * read_info ; int c ; for ( i = 0 ; i < ( ssize_t ) stream_info -> remaining ; i ++ ) if ( ReadBlobByte ( image ) == EOF ) break ; ( void ) ( ( ( ssize_t ) ReadBlobLSBShort ( image ) << 16 ) | ReadBlobLSBShort ( image ) ) ; length = ( size_t ) ReadBlobLSBLong ( image ) ; if ( length > ( size_t ) GetBlobSize ( image ) ) ThrowDCMException ( CorruptImageError , \"InsufficientImageDataInFile\" ) ; stream_info -> offset_count = length >> 2 ; if ( stream_info -> offset_count != 0 ) { if ( stream_info -> offsets != ( ssize_t * ) NULL ) stream_info -> offsets = ( ssize_t * ) RelinquishMagickMemory ( stream_info -> offsets ) ; stream_info -> offsets = ( ssize_t * ) AcquireQuantumMemory ( stream_info -> offset_count , sizeof ( * stream_info -> offsets ) ) ; if ( stream_info -> offsets == ( ssize_t * ) NULL ) ThrowDCMException ( ResourceLimitError , \"MemoryAllocationFailed\" ) ; for ( i = 0 ; i < ( ssize_t ) stream_info -> offset_count ; i ++ ) stream_info -> offsets [ i ] = ( ssize_t ) ReadBlobLSBSignedLong ( image ) ; offset = TellBlob ( image ) ; for ( i = 0 ; i < ( ssize_t ) stream_info -> offset_count ; i ++ ) stream_info -> offsets [ i ] += offset ; } read_info = CloneImageInfo ( image_info ) ; SetImageInfoBlob ( read_info , ( void * ) NULL , 0 ) ; images = NewImageList ( ) ; for ( scene = 0 ; scene < ( ssize_t ) number_scenes ; scene ++ ) { char filename [ MagickPathExtent ] ; const char * property ; FILE * file ; Image * jpeg_image ; int unique_file ; unsigned int tag ; tag = ( ( unsigned int ) ReadBlobLSBShort ( image ) << 16 ) | ReadBlobLSBShort ( image ) ; length = ( size_t ) ReadBlobLSBLong ( image ) ; <S2SV_StartBug> if ( tag == 0xFFFEE0DD ) <S2SV_EndBug> break ; if ( tag != 0xFFFEE000 ) { read_info = DestroyImageInfo ( read_info ) ; ThrowDCMException ( CorruptImageError , \"ImproperImageHeader\" ) ; } file = ( FILE * ) NULL ; unique_file = AcquireUniqueFileResource ( filename ) ; if ( unique_file != - 1 ) file = fdopen ( unique_file , \"wb\" ) ; if ( file == ( FILE * ) NULL ) { ( void ) RelinquishUniqueFileResource ( filename ) ; ThrowFileException ( exception , FileOpenError , \"UnableToCreateTemporaryFile\" , filename ) ; break ; } for ( c = EOF ; length != 0 ; length -- ) { c = ReadBlobByte ( image ) ; if ( c == EOF ) { ThrowFileException ( exception , CorruptImageError , \"UnexpectedEndOfFile\" , image -> filename ) ; break ; } if ( fputc ( c , file ) != c ) break ; } ( void ) fclose ( file ) ; if ( c == EOF ) break ; ( void ) FormatLocaleString ( read_info -> filename , MagickPathExtent , \"jpeg:%s\" , filename ) ; if ( image -> compression == JPEG2000Compression ) ( void ) FormatLocaleString ( read_info -> filename , MagickPathExtent , \"j2k:%s\" , filename ) ; jpeg_image = ReadImage ( read_info , exception ) ; if ( jpeg_image != ( Image * ) NULL ) { ResetImagePropertyIterator ( image ) ; property = GetNextImageProperty ( image ) ; while ( property != ( const char * ) NULL ) { ( void ) SetImageProperty ( jpeg_image , property , GetImageProperty ( image , property , exception ) , exception ) ; property = GetNextImageProperty ( image ) ; } AppendImageToList ( & images , jpeg_image ) ; } ( void ) RelinquishUniqueFileResource ( filename ) ; } read_info = DestroyImageInfo ( read_info ) ; if ( stream_info -> offsets != ( ssize_t * ) NULL ) stream_info -> offsets = ( ssize_t * ) RelinquishMagickMemory ( stream_info -> offsets ) ; stream_info = ( DCMStreamInfo * ) RelinquishMagickMemory ( stream_info ) ; if ( info . scale != ( Quantum * ) NULL ) info . scale = ( Quantum * ) RelinquishMagickMemory ( info . scale ) ; if ( graymap != ( int * ) NULL ) graymap = ( int * ) RelinquishMagickMemory ( graymap ) ; if ( bluemap != ( int * ) NULL ) bluemap = ( int * ) RelinquishMagickMemory ( bluemap ) ; if ( greenmap != ( int * ) NULL ) greenmap = ( int * ) RelinquishMagickMemory ( greenmap ) ; if ( redmap != ( int * ) NULL ) redmap = ( int * ) RelinquishMagickMemory ( redmap ) ; image = DestroyImageList ( image ) ; return ( GetFirstImageInList ( images ) ) ; } if ( info . depth != ( 1UL * MAGICKCORE_QUANTUM_DEPTH ) ) { QuantumAny range ; length = ( size_t ) ( GetQuantumRange ( info . depth ) + 1 ) ; if ( length > ( size_t ) GetBlobSize ( image ) ) ThrowDCMException ( CorruptImageError , \"InsufficientImageDataInFile\" ) ; if ( info . scale != ( Quantum * ) NULL ) info . scale = ( Quantum * ) RelinquishMagickMemory ( info . scale ) ; info . scale = ( Quantum * ) AcquireQuantumMemory ( MagickMax ( length , 256 ) , sizeof ( * info . scale ) ) ; if ( info . scale == ( Quantum * ) NULL ) ThrowDCMException ( ResourceLimitError , \"MemoryAllocationFailed\" ) ; ( void ) memset ( info . scale , 0 , MagickMax ( length , 256 ) * sizeof ( * info . scale ) ) ; range = GetQuantumRange ( info . depth ) ; for ( i = 0 ; i <= ( ssize_t ) GetQuantumRange ( info . depth ) ; i ++ ) info . scale [ i ] = ScaleAnyToQuantum ( ( size_t ) i , range ) ; } if ( image -> compression == RLECompression ) { unsigned int tag ; for ( i = 0 ; i < ( ssize_t ) stream_info -> remaining ; i ++ ) { int c ; c = ReadBlobByte ( image ) ; if ( c == EOF ) break ; } tag = ( ( unsigned int ) ReadBlobLSBShort ( image ) << 16 ) | ReadBlobLSBShort ( image ) ; ( void ) tag ; length = ( size_t ) ReadBlobLSBLong ( image ) ; if ( length > ( size_t ) GetBlobSize ( image ) ) ThrowDCMException ( CorruptImageError , \"InsufficientImageDataInFile\" ) ; stream_info -> offset_count = length >> 2 ; if ( stream_info -> offset_count != 0 ) { if ( stream_info -> offsets != ( ssize_t * ) NULL ) stream_info -> offsets = ( ssize_t * ) RelinquishMagickMemory ( stream_info -> offsets ) ; stream_info -> offsets = ( ssize_t * ) AcquireQuantumMemory ( stream_info -> offset_count , sizeof ( * stream_info -> offsets ) ) ; if ( stream_info -> offsets == ( ssize_t * ) NULL ) ThrowDCMException ( ResourceLimitError , \"MemoryAllocationFailed\" ) ; for ( i = 0 ; i < ( ssize_t ) stream_info -> offset_count ; i ++ ) { stream_info -> offsets [ i ] = ( ssize_t ) ReadBlobLSBSignedLong ( image ) ; if ( EOFBlob ( image ) != MagickFalse ) break ; } offset = TellBlob ( image ) + 8 ; for ( i = 0 ; i < ( ssize_t ) stream_info -> offset_count ; i ++ ) stream_info -> offsets [ i ] += offset ; } } for ( scene = 0 ; scene < ( ssize_t ) number_scenes ; scene ++ ) { image -> columns = ( size_t ) width ; image -> rows = ( size_t ) height ; image -> depth = info . depth ; status = SetImageExtent ( image , image -> columns , image -> rows , exception ) ; if ( status == MagickFalse ) break ; image -> colorspace = RGBColorspace ; ( void ) SetImageBackgroundColor ( image , exception ) ; if ( ( image -> colormap == ( PixelInfo * ) NULL ) && ( info . samples_per_pixel == 1 ) ) { int index ; size_t one ; one = 1 ; if ( colors == 0 ) colors = one << info . depth ; if ( AcquireImageColormap ( image , colors , exception ) == MagickFalse ) ThrowDCMException ( ResourceLimitError , \"MemoryAllocationFailed\" ) ; if ( redmap != ( int * ) NULL ) for ( i = 0 ; i < ( ssize_t ) colors ; i ++ ) { index = redmap [ i ] ; if ( ( info . scale != ( Quantum * ) NULL ) && ( index >= 0 ) && ( index <= ( int ) info . max_value ) ) index = ( int ) info . scale [ index ] ; image -> colormap [ i ] . red = ( MagickRealType ) index ; } if ( greenmap != ( int * ) NULL ) for ( i = 0 ; i < ( ssize_t ) colors ; i ++ ) { index = greenmap [ i ] ; if ( ( info . scale != ( Quantum * ) NULL ) && ( index >= 0 ) && ( index <= ( int ) info . max_value ) ) index = ( int ) info . scale [ index ] ; image -> colormap [ i ] . green = ( MagickRealType ) index ; } if ( bluemap != ( int * ) NULL ) for ( i = 0 ; i < ( ssize_t ) colors ; i ++ ) { index = bluemap [ i ] ; if ( ( info . scale != ( Quantum * ) NULL ) && ( index >= 0 ) && ( index <= ( int ) info . max_value ) ) index = ( int ) info . scale [ index ] ; image -> colormap [ i ] . blue = ( MagickRealType ) index ; } if ( graymap != ( int * ) NULL ) for ( i = 0 ; i < ( ssize_t ) colors ; i ++ ) { index = graymap [ i ] ; if ( ( info . scale != ( Quantum * ) NULL ) && ( index >= 0 ) && ( index <= ( int ) info . max_value ) ) index = ( int ) info . scale [ index ] ; image -> colormap [ i ] . red = ( MagickRealType ) index ; image -> colormap [ i ] . green = ( MagickRealType ) index ; image -> colormap [ i ] . blue = ( MagickRealType ) index ; } } if ( image -> compression == RLECompression ) { unsigned int tag ; for ( i = 0 ; i < ( ssize_t ) stream_info -> remaining ; i ++ ) { int c ; c = ReadBlobByte ( image ) ; if ( c == EOF ) break ; } tag = ( ( unsigned int ) ReadBlobLSBShort ( image ) << 16 ) | ReadBlobLSBShort ( image ) ; stream_info -> remaining = ( size_t ) ReadBlobLSBLong ( image ) ; if ( ( tag != 0xFFFEE000 ) || ( stream_info -> remaining <= 64 ) || ( EOFBlob ( image ) != MagickFalse ) ) { if ( stream_info -> offsets != ( ssize_t * ) NULL ) stream_info -> offsets = ( ssize_t * ) RelinquishMagickMemory ( stream_info -> offsets ) ; ThrowDCMException ( CorruptImageError , \"ImproperImageHeader\" ) ; } stream_info -> count = 0 ; stream_info -> segment_count = ReadBlobLSBLong ( image ) ; for ( i = 0 ; i < 15 ; i ++ ) stream_info -> segments [ i ] = ( ssize_t ) ReadBlobLSBSignedLong ( image ) ; stream_info -> remaining -= 64 ; if ( stream_info -> segment_count > 1 ) { info . bytes_per_pixel = 1 ; info . depth = 8 ; if ( stream_info -> offset_count > 0 ) ( void ) SeekBlob ( image , ( MagickOffsetType ) stream_info -> offsets [ 0 ] + stream_info -> segments [ 0 ] , SEEK_SET ) ; } } if ( ( info . samples_per_pixel > 1 ) && ( image -> interlace == PlaneInterlace ) ) { register ssize_t x ; register Quantum * q ; ssize_t y ; for ( i = 0 ; i < ( ssize_t ) info . samples_per_pixel ; i ++ ) { for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { q = GetAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { switch ( ( int ) i ) { case 0 : { SetPixelRed ( image , ScaleCharToQuantum ( ( unsigned char ) ReadDCMByte ( stream_info , image ) ) , q ) ; break ; } case 1 : { SetPixelGreen ( image , ScaleCharToQuantum ( ( unsigned char ) ReadDCMByte ( stream_info , image ) ) , q ) ; break ; } case 2 : { SetPixelBlue ( image , ScaleCharToQuantum ( ( unsigned char ) ReadDCMByte ( stream_info , image ) ) , q ) ; break ; } case 3 : { SetPixelAlpha ( image , ScaleCharToQuantum ( ( unsigned char ) ReadDCMByte ( stream_info , image ) ) , q ) ; break ; } default : break ; } q += GetPixelChannels ( image ) ; } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ; if ( status == MagickFalse ) break ; } } } } else { const char * option ; option = GetImageOption ( image_info , \"dcm:display-range\" ) ; if ( option != ( const char * ) NULL ) { if ( LocaleCompare ( option , \"reset\" ) == 0 ) info . window_width = 0 ; } option = GetImageOption ( image_info , \"dcm:window\" ) ; if ( option != ( char * ) NULL ) { GeometryInfo geometry_info ; MagickStatusType flags ; flags = ParseGeometry ( option , & geometry_info ) ; if ( flags & RhoValue ) info . window_center = geometry_info . rho ; if ( flags & SigmaValue ) info . window_width = geometry_info . sigma ; info . rescale = MagickTrue ; } option = GetImageOption ( image_info , \"dcm:rescale\" ) ; if ( option != ( char * ) NULL ) info . rescale = IsStringTrue ( option ) ; if ( ( info . window_center != 0 ) && ( info . window_width == 0 ) ) info . window_width = info . window_center ; status = ReadDCMPixels ( image , & info , stream_info , MagickTrue , exception ) ; if ( ( status != MagickFalse ) && ( stream_info -> segment_count > 1 ) ) { if ( stream_info -> offset_count > 0 ) ( void ) SeekBlob ( image , ( MagickOffsetType ) stream_info -> offsets [ 0 ] + stream_info -> segments [ 1 ] , SEEK_SET ) ; ( void ) ReadDCMPixels ( image , & info , stream_info , MagickFalse , exception ) ; } } if ( SetImageGray ( image , exception ) != MagickFalse ) ( void ) SetImageColorspace ( image , GRAYColorspace , exception ) ; if ( EOFBlob ( image ) != MagickFalse ) { ThrowFileException ( exception , CorruptImageError , \"UnexpectedEndOfFile\" , image -> filename ) ; break ; } if ( image_info -> number_scenes != 0 ) if ( image -> scene >= ( image_info -> scene + image_info -> number_scenes - 1 ) ) break ; if ( scene < ( ssize_t ) ( number_scenes - 1 ) ) { AcquireNextImage ( image_info , image , exception ) ; if ( GetNextImageInList ( image ) == ( Image * ) NULL ) { status = MagickFalse ; break ; } image = SyncNextImageInList ( image ) ; status = SetImageProgress ( image , LoadImagesTag , TellBlob ( image ) , GetBlobSize ( image ) ) ; if ( status == MagickFalse ) break ; } } if ( TellBlob ( image ) < ( MagickOffsetType ) GetBlobSize ( image ) ) { AcquireNextImage ( image_info , image , exception ) ; if ( GetNextImageInList ( image ) == ( Image * ) NULL ) { status = MagickFalse ; break ; } image = SyncNextImageInList ( image ) ; status = SetImageProgress ( image , LoadImagesTag , TellBlob ( image ) , GetBlobSize ( image ) ) ; if ( status == MagickFalse ) break ; } } if ( stream_info -> offsets != ( ssize_t * ) NULL ) stream_info -> offsets = ( ssize_t * ) RelinquishMagickMemory ( stream_info -> offsets ) ; stream_info = ( DCMStreamInfo * ) RelinquishMagickMemory ( stream_info ) ; if ( info . scale != ( Quantum * ) NULL ) info . scale = ( Quantum * ) RelinquishMagickMemory ( info . scale ) ; if ( graymap != ( int * ) NULL ) graymap = ( int * ) RelinquishMagickMemory ( graymap ) ; if ( bluemap != ( int * ) NULL ) bluemap = ( int * ) RelinquishMagickMemory ( bluemap ) ; if ( greenmap != ( int * ) NULL ) greenmap = ( int * ) RelinquishMagickMemory ( greenmap ) ; if ( redmap != ( int * ) NULL ) redmap = ( int * ) RelinquishMagickMemory ( redmap ) ; if ( image == ( Image * ) NULL ) return ( image ) ; ( void ) CloseBlob ( image ) ; if ( status == MagickFalse ) return ( DestroyImageList ( image ) ) ; return ( GetFirstImageInList ( image ) ) ; }\n","target":"<S2SV_ModStart> , message ) \\\\\\n{ <S2SV_ModEnd> if ( info <S2SV_ModStart> ) ) ; \\\\\\n} <S2SV_ModEnd> char explicit_vr [ <S2SV_ModStart> ; if ( length > ( size_t ) GetBlobSize ( image ) ) ThrowDCMException ( CorruptImageError , \"InsufficientImageDataInFile\" ) ; if (\n","project_and_commit_id":"ImageMagick@ImageMagick/16916c8979c32765c542e216b31cee2671b7afe7","cve_id":"CVE-2018-16644","original_address":"https://github.com/ImageMagick/ImageMagick/commit/16916c8979c32765c542e216b31cee2671b7afe7","time":"2018-09-06T22:29Z"},
	{"Unnamed: 0":1512,"cwe_id":"CWE-200","source":"CWE-200 static int recv_stream ( struct kiocb * iocb , struct socket * sock , struct msghdr * m , size_t buf_len , int flags ) { struct sock * sk = sock -> sk ; struct tipc_port * tport = tipc_sk_port ( sk ) ; struct sk_buff * buf ; struct tipc_msg * msg ; long timeout ; unsigned int sz ; int sz_to_copy , target , needed ; int sz_copied = 0 ; u32 err ; int res = 0 ; if ( unlikely ( ! buf_len ) ) return - EINVAL ; lock_sock ( sk ) ; if ( unlikely ( ( sock -> state == SS_UNCONNECTED ) || ( sock -> state == SS_CONNECTING ) ) ) { res = - ENOTCONN ; goto exit ; <S2SV_StartBug> } <S2SV_EndBug> target = sock_rcvlowat ( sk , flags & MSG_WAITALL , buf_len ) ; timeout = sock_rcvtimeo ( sk , flags & MSG_DONTWAIT ) ; restart : while ( skb_queue_empty ( & sk -> sk_receive_queue ) ) { if ( sock -> state == SS_DISCONNECTING ) { res = - ENOTCONN ; goto exit ; } if ( timeout <= 0L ) { res = timeout ? timeout : - EWOULDBLOCK ; goto exit ; } release_sock ( sk ) ; timeout = wait_event_interruptible_timeout ( * sk_sleep ( sk ) , tipc_rx_ready ( sock ) , timeout ) ; lock_sock ( sk ) ; } buf = skb_peek ( & sk -> sk_receive_queue ) ; msg = buf_msg ( buf ) ; sz = msg_data_sz ( msg ) ; err = msg_errcode ( msg ) ; if ( ( ! sz ) && ( ! err ) ) { advance_rx_queue ( sk ) ; goto restart ; } if ( sz_copied == 0 ) { set_orig_addr ( m , msg ) ; res = anc_data_recv ( m , msg , tport ) ; if ( res ) goto exit ; } if ( ! err ) { u32 offset = ( u32 ) ( unsigned long ) ( TIPC_SKB_CB ( buf ) -> handle ) ; sz -= offset ; needed = ( buf_len - sz_copied ) ; sz_to_copy = ( sz <= needed ) ? sz : needed ; res = skb_copy_datagram_iovec ( buf , msg_hdr_sz ( msg ) + offset , m -> msg_iov , sz_to_copy ) ; if ( res ) goto exit ; sz_copied += sz_to_copy ; if ( sz_to_copy < sz ) { if ( ! ( flags & MSG_PEEK ) ) TIPC_SKB_CB ( buf ) -> handle = ( void * ) ( unsigned long ) ( offset + sz_to_copy ) ; goto exit ; } } else { if ( sz_copied != 0 ) goto exit ; if ( ( err == TIPC_CONN_SHUTDOWN ) || m -> msg_control ) res = 0 ; else res = - ECONNRESET ; } if ( likely ( ! ( flags & MSG_PEEK ) ) ) { if ( unlikely ( ++ tport -> conn_unacked >= TIPC_FLOW_CONTROL_WIN ) ) tipc_acknowledge ( tport -> ref , tport -> conn_unacked ) ; advance_rx_queue ( sk ) ; } if ( ( sz_copied < buf_len ) && ( ! skb_queue_empty ( & sk -> sk_receive_queue ) || ( sz_copied < target ) ) && ( ! ( flags & MSG_PEEK ) ) && ( ! err ) ) goto restart ; exit : release_sock ( sk ) ; return sz_copied ? sz_copied : res ; }\n","target":"<S2SV_ModStart> exit ; } m -> msg_namelen = 0 ;\n","project_and_commit_id":"torvalds@linux/60085c3d009b0df252547adb336d1ccca5ce52ec","cve_id":"CVE-2013-3235","original_address":"https://github.com/torvalds/linux/commit/60085c3d009b0df252547adb336d1ccca5ce52ec","time":"2013-04-22T11:41Z"},
	{"Unnamed: 0":6079,"cwe_id":"CWE-119","source":"CWE-119 static void mark_commit ( struct commit * c , void * data ) { <S2SV_StartBug> mark_object ( & c -> object , NULL , NULL , data ) ; <S2SV_EndBug> }\n","target":"<S2SV_ModStart> , NULL , <S2SV_ModEnd> data ) ;\n","project_and_commit_id":"git@git/de1e67d0703894cb6ea782e36abb63976ab07e60","cve_id":"CVE-2016-2324","original_address":"https://github.com/git/git/commit/de1e67d0703894cb6ea782e36abb63976ab07e60","time":"2016-04-08T14:59Z"},
	{"Unnamed: 0":6579,"cwe_id":"CWE-20","source":"CWE-20 void big_key_describe ( const struct key * key , struct seq_file * m ) { size_t datalen = ( size_t ) key -> payload . data [ big_key_len ] ; seq_puts ( m , key -> description ) ; <S2SV_StartBug> if ( key_is_instantiated ( key ) ) <S2SV_EndBug> seq_printf ( m , \":<S2SV_blank>%zu<S2SV_blank>[%s]\" , datalen , datalen > BIG_KEY_FILE_THRESHOLD ? \"file\" : \"buff\" ) ; }\n","target":"<S2SV_ModStart> ; if ( key_is_positive <S2SV_ModEnd> ( key )\n","project_and_commit_id":"torvalds@linux/363b02dab09b3226f3bd1420dad9c72b79a42a76","cve_id":"CVE-2017-15951","original_address":"https://github.com/torvalds/linux/commit/363b02dab09b3226f3bd1420dad9c72b79a42a76","time":"2017-10-28T02:29Z"},
	{"Unnamed: 0":1714,"cwe_id":"CWE-125","source":"CWE-125 const char * le64addr_string ( netdissect_options * ndo , const u_char * ep ) { const unsigned int len = 8 ; register u_int i ; register char * cp ; <S2SV_StartBug> register struct enamemem * tp ; <S2SV_EndBug> char buf [ BUFSIZE ] ; tp = lookup_bytestring ( ndo , ep , len ) ; <S2SV_StartBug> if ( tp -> e_name ) <S2SV_EndBug> <S2SV_StartBug> return ( tp -> e_name ) ; <S2SV_EndBug> cp = buf ; for ( i = len ; i > 0 ; -- i ) { * cp ++ = hex [ * ( ep + i - 1 ) >> 4 ] ; * cp ++ = hex [ * ( ep + i - 1 ) & 0xf ] ; * cp ++ = ':' ; } cp -- ; * cp = '\\\\0' ; <S2SV_StartBug> tp -> e_name = strdup ( buf ) ; <S2SV_EndBug> <S2SV_StartBug> if ( tp -> e_name == NULL ) <S2SV_EndBug> ( * ndo -> ndo_error ) ( ndo , \"le64addr_string:<S2SV_blank>strdup(buf)\" ) ; <S2SV_StartBug> return ( tp -> e_name ) ; <S2SV_EndBug> }\n","target":"<S2SV_ModStart> ; register struct bsnamemem <S2SV_ModEnd> * tp ; <S2SV_ModStart> ( tp -> bs_name <S2SV_ModEnd> ) return ( <S2SV_ModStart> ( tp -> bs_name <S2SV_ModEnd> ) ; cp <S2SV_ModStart> ; tp -> bs_name <S2SV_ModEnd> = strdup ( <S2SV_ModStart> ( tp -> bs_name <S2SV_ModEnd> == NULL ) <S2SV_ModStart> ( tp -> bs_name <S2SV_ModEnd> ) ; }\n","project_and_commit_id":"the-tcpdump-group@tcpdump/730fc35968c5433b9e2a829779057f4f9495dc51","cve_id":"CVE-2017-12894","original_address":"https://github.com/the-tcpdump-group/tcpdump/commit/730fc35968c5433b9e2a829779057f4f9495dc51","time":"2017-09-14T06:29Z"},
	{"Unnamed: 0":1866,"cwe_id":"CWE-119","source":"CWE-119 static int rc_pick_q_and_bounds_one_pass_vbr ( const VP9_COMP * cpi , int * bottom_index , int * top_index ) { const VP9_COMMON * const cm = & cpi -> common ; const RATE_CONTROL * const rc = & cpi -> rc ; <S2SV_StartBug> const VP9_CONFIG * const oxcf = & cpi -> oxcf ; <S2SV_EndBug> <S2SV_StartBug> int active_best_quality ; <S2SV_EndBug> int active_worst_quality = calc_active_worst_quality_one_pass_vbr ( cpi ) ; int q ; <S2SV_StartBug> if ( frame_is_intra_only ( cm ) ) { <S2SV_EndBug> <S2SV_StartBug> active_best_quality = rc -> best_quality ; <S2SV_EndBug> # if ! CONFIG_MULTIPLE_ARF if ( rc -> this_key_frame_forced ) { int qindex = rc -> last_boosted_qindex ; <S2SV_StartBug> double last_boosted_q = vp9_convert_qindex_to_q ( qindex ) ; <S2SV_EndBug> int delta_qindex = vp9_compute_qdelta ( rc , last_boosted_q , <S2SV_StartBug> last_boosted_q * 0.75 ) ; <S2SV_EndBug> active_best_quality = MAX ( qindex + delta_qindex , rc -> best_quality ) ; <S2SV_StartBug> } else if ( cm -> current_video_frame > 0 ) { <S2SV_EndBug> double q_adj_factor = 1.0 ; double q_val ; <S2SV_StartBug> active_best_quality = get_active_quality ( rc -> avg_frame_qindex [ KEY_FRAME ] , <S2SV_EndBug> <S2SV_StartBug> rc -> kf_boost , <S2SV_EndBug> kf_low , kf_high , kf_low_motion_minq , kf_high_motion_minq ) ; if ( ( cm -> width * cm -> height ) <= ( 352 * 288 ) ) { q_adj_factor -= 0.25 ; } <S2SV_StartBug> q_val = vp9_convert_qindex_to_q ( active_best_quality ) ; <S2SV_EndBug> active_best_quality += vp9_compute_qdelta ( rc , q_val , <S2SV_StartBug> q_val * q_adj_factor ) ; <S2SV_EndBug> } # else double current_q ; current_q = vp9_convert_qindex_to_q ( active_worst_quality ) ; active_best_quality = active_worst_quality + vp9_compute_qdelta ( rc , current_q , current_q * 0.3 ) ; # endif } else if ( ! rc -> is_src_frame_alt_ref && ( cpi -> refresh_golden_frame || cpi -> refresh_alt_ref_frame ) ) { if ( rc -> frames_since_key > 1 && rc -> avg_frame_qindex [ INTER_FRAME ] < active_worst_quality ) { q = rc -> avg_frame_qindex [ INTER_FRAME ] ; } else { q = rc -> avg_frame_qindex [ KEY_FRAME ] ; } <S2SV_StartBug> if ( oxcf -> end_usage == USAGE_CONSTRAINED_QUALITY ) { <S2SV_EndBug> <S2SV_StartBug> if ( q < cpi -> cq_target_quality ) <S2SV_EndBug> q = cpi -> cq_target_quality ; if ( rc -> frames_since_key > 1 ) { active_best_quality = get_active_quality ( q , rc -> gfu_boost , gf_low , gf_high , afq_low_motion_minq , afq_high_motion_minq ) ; } else { active_best_quality = get_active_quality ( q , rc -> gfu_boost , gf_low , gf_high , gf_low_motion_minq , gf_high_motion_minq ) ; } active_best_quality = active_best_quality * 15 / 16 ; <S2SV_StartBug> } else if ( oxcf -> end_usage == USAGE_CONSTANT_QUALITY ) { <S2SV_EndBug> if ( ! cpi -> refresh_alt_ref_frame ) { <S2SV_StartBug> active_best_quality = cpi -> cq_target_quality ; <S2SV_EndBug> } else { if ( rc -> frames_since_key > 1 ) { active_best_quality = get_active_quality ( q , rc -> gfu_boost , gf_low , gf_high , afq_low_motion_minq , afq_high_motion_minq ) ; } else { active_best_quality = get_active_quality ( q , rc -> gfu_boost , gf_low , gf_high , gf_low_motion_minq , gf_high_motion_minq ) ; } } } else { active_best_quality = get_active_quality ( q , rc -> gfu_boost , gf_low , gf_high , gf_low_motion_minq , gf_high_motion_minq ) ; } } else { <S2SV_StartBug> if ( oxcf -> end_usage == USAGE_CONSTANT_QUALITY ) { <S2SV_EndBug> active_best_quality = cpi -> cq_target_quality ; } else { if ( cm -> current_video_frame > 1 ) active_best_quality = inter_minq [ rc -> avg_frame_qindex [ INTER_FRAME ] ] ; else active_best_quality = inter_minq [ rc -> avg_frame_qindex [ KEY_FRAME ] ] ; <S2SV_StartBug> if ( ( oxcf -> end_usage == USAGE_CONSTRAINED_QUALITY ) && <S2SV_EndBug> <S2SV_StartBug> ( active_best_quality < cpi -> cq_target_quality ) ) { <S2SV_EndBug> if ( rc -> rolling_actual_bits < rc -> min_frame_bandwidth ) active_best_quality = oxcf -> cq_level ; else active_best_quality = cpi -> cq_target_quality ; } } } active_best_quality = clamp ( active_best_quality , rc -> best_quality , rc -> worst_quality ) ; active_worst_quality = clamp ( active_worst_quality , active_best_quality , rc -> worst_quality ) ; * top_index = active_worst_quality ; * bottom_index = active_best_quality ; <S2SV_StartBug> # if LIMIT_QRANGE_FOR_ALTREF_AND_KEY <S2SV_EndBug> <S2SV_StartBug> if ( cm -> frame_type == KEY_FRAME && ! rc -> this_key_frame_forced ) { <S2SV_EndBug> if ( ! ( cm -> current_video_frame == 0 ) ) <S2SV_StartBug> * top_index = ( active_worst_quality + active_best_quality * 3 ) / 4 ; <S2SV_EndBug> } else if ( ! rc -> is_src_frame_alt_ref && ( cpi -> refresh_golden_frame || cpi -> refresh_alt_ref_frame ) ) { * top_index = ( active_worst_quality + active_best_quality ) / 2 ; } # endif <S2SV_StartBug> if ( oxcf -> end_usage == USAGE_CONSTANT_QUALITY ) { <S2SV_EndBug> q = active_best_quality ; } else if ( ( cm -> frame_type == KEY_FRAME ) && rc -> this_key_frame_forced ) { q = rc -> last_boosted_qindex ; } else { q = vp9_rc_regulate_q ( cpi , rc -> this_frame_target , active_best_quality , active_worst_quality ) ; if ( q > * top_index ) { if ( rc -> this_frame_target >= rc -> max_frame_bandwidth ) * top_index = q ; else q = * top_index ; } } <S2SV_StartBug> # if CONFIG_MULTIPLE_ARF <S2SV_EndBug> if ( cpi -> multi_arf_enabled && ( cm -> frame_type != KEY_FRAME ) && cpi -> oxcf . end_usage != USAGE_CONSTANT_QUALITY ) { double new_q ; double current_q = vp9_convert_qindex_to_q ( active_worst_quality ) ; int level = cpi -> this_frame_weight ; assert ( level >= 0 ) ; new_q = current_q * ( 1.0 - ( 0.2 * ( cpi -> max_arf_level - level ) ) ) ; q = active_worst_quality + vp9_compute_qdelta ( rc , current_q , new_q ) ; * bottom_index = q ; * top_index = q ; printf ( \"frame:%d<S2SV_blank>q:%d\\\\n\" , cm -> current_video_frame , q ) ; } # endif assert ( * top_index <= rc -> worst_quality && * top_index >= rc -> best_quality ) ; assert ( * bottom_index <= rc -> worst_quality && * bottom_index >= rc -> best_quality ) ; assert ( q <= rc -> worst_quality && q >= rc -> best_quality ) ; return q ; }\n","target":"<S2SV_ModStart> rc ; const VP9EncoderConfig <S2SV_ModEnd> * const oxcf <S2SV_ModStart> -> oxcf ; const int cq_level = get_active_cq_level ( rc , oxcf ) ; <S2SV_ModStart> int q ; int * inter_minq ; ASSIGN_MINQ_TABLE ( cm -> bit_depth , inter_minq ) ; <S2SV_ModStart> ) ) { <S2SV_ModEnd> if ( rc <S2SV_ModStart> vp9_convert_qindex_to_q ( qindex , cm -> bit_depth <S2SV_ModStart> last_boosted_q * 0.75 , cm -> bit_depth <S2SV_ModStart> ; } else <S2SV_ModEnd> { double q_adj_factor <S2SV_ModStart> ; active_best_quality = get_kf_active_quality ( rc , <S2SV_ModEnd> rc -> avg_frame_qindex <S2SV_ModStart> KEY_FRAME ] , cm -> bit_depth <S2SV_ModEnd> ) ; if <S2SV_ModStart> vp9_convert_qindex_to_q ( active_best_quality , cm -> bit_depth <S2SV_ModStart> q_val * q_adj_factor , cm -> bit_depth ) ; } <S2SV_ModEnd> } else if <S2SV_ModStart> ( oxcf -> rc_mode == VPX_CQ <S2SV_ModEnd> ) { if <S2SV_ModStart> ( q < cq_level ) q = cq_level ; active_best_quality = get_gf_active_quality ( rc , q , cm -> bit_depth ) ; <S2SV_ModEnd> active_best_quality = active_best_quality <S2SV_ModStart> ( oxcf -> rc_mode == VPX_Q <S2SV_ModEnd> ) { if <S2SV_ModStart> { active_best_quality = cq_level ; } else { active_best_quality = get_gf_active_quality ( rc , q , cm -> bit_depth ) ; } } else { active_best_quality = get_gf_active_quality ( rc , q , cm -> bit_depth <S2SV_ModEnd> ) ; } <S2SV_ModStart> ( oxcf -> rc_mode == VPX_Q ) { active_best_quality = cq_level <S2SV_ModEnd> ; } else <S2SV_ModStart> ( oxcf -> rc_mode == VPX_CQ <S2SV_ModEnd> ) && ( <S2SV_ModStart> ( active_best_quality < cq_level ) ) { active_best_quality = cq_level <S2SV_ModEnd> ; } } <S2SV_ModStart> # if LIMIT_QRANGE_FOR_ALTREF_AND_KEY { int qdelta = 0 ; vpx_clear_system_state ( ) ; <S2SV_ModStart> rc -> this_key_frame_forced && <S2SV_ModEnd> ! ( cm <S2SV_ModStart> 0 ) ) { qdelta = vp9_compute_qdelta_by_rate ( & cpi -> rc , cm -> frame_type , active_worst_quality , 2.0 , cm -> bit_depth ) ; } else if ( ! rc -> is_src_frame_alt_ref && ( cpi -> refresh_golden_frame || cpi -> refresh_alt_ref_frame ) ) { qdelta = vp9_compute_qdelta_by_rate ( & cpi -> rc , cm -> frame_type , active_worst_quality , 1.75 , cm -> bit_depth ) ; } * top_index = active_worst_quality + qdelta ; * top_index = ( * top_index > * bottom_index ) ? * top_index : * bottom_index <S2SV_ModEnd> ; } # <S2SV_ModStart> ( oxcf -> rc_mode == VPX_Q <S2SV_ModEnd> ) { q <S2SV_ModStart> ; } } <S2SV_ModEnd> assert ( *\n","project_and_commit_id":"external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426","cve_id":"CVE-2016-1621","original_address":"https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426","time":"2016-03-12T21:59Z"},
	{"Unnamed: 0":4089,"cwe_id":"CWE-835","source":"CWE-835 static Image * ReadTXTImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { char colorspace [ MaxTextExtent ] , text [ MaxTextExtent ] ; Image * image ; IndexPacket * indexes ; long x_offset , y_offset ; MagickBooleanType status ; MagickPixelPacket pixel ; QuantumAny range ; register ssize_t i , x ; register PixelPacket * q ; ssize_t count , type , y ; unsigned long depth , height , max_value , width ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickSignature ) ; if ( image_info -> debug != MagickFalse ) ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , \"%s\" , image_info -> filename ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickSignature ) ; image = AcquireImage ( image_info ) ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } ( void ) ResetMagickMemory ( text , 0 , sizeof ( text ) ) ; ( void ) ReadBlobString ( image , text ) ; if ( LocaleNCompare ( ( char * ) text , MagickID , strlen ( MagickID ) ) != 0 ) ThrowReaderException ( CorruptImageError , \"ImproperImageHeader\" ) ; do { width = 0 ; height = 0 ; max_value = 0 ; * colorspace = '\\\\0' ; count = ( ssize_t ) sscanf ( text + 32 , \"%lu,%lu,%lu,%s\" , & width , & height , & max_value , colorspace ) ; if ( ( count != 4 ) || ( width == 0 ) || ( height == 0 ) || ( max_value == 0 ) ) ThrowReaderException ( CorruptImageError , \"ImproperImageHeader\" ) ; image -> columns = width ; image -> rows = height ; for ( depth = 1 ; ( GetQuantumRange ( depth ) + 1 ) < max_value ; depth ++ ) ; image -> depth = depth ; status = SetImageExtent ( image , image -> columns , image -> rows ) ; if ( status == MagickFalse ) { InheritException ( exception , & image -> exception ) ; return ( DestroyImageList ( image ) ) ; } LocaleLower ( colorspace ) ; i = ( ssize_t ) strlen ( colorspace ) - 1 ; image -> matte = MagickFalse ; if ( ( i > 0 ) && ( colorspace [ i ] == 'a' ) ) { colorspace [ i ] = '\\\\0' ; image -> matte = MagickTrue ; } type = ParseCommandOption ( MagickColorspaceOptions , MagickFalse , colorspace ) ; if ( type < 0 ) ThrowReaderException ( CorruptImageError , \"ImproperImageHeader\" ) ; image -> colorspace = ( ColorspaceType ) type ; ( void ) ResetMagickMemory ( & pixel , 0 , sizeof ( pixel ) ) ; ( void ) SetImageBackgroundColor ( image ) ; range = GetQuantumRange ( image -> depth ) ; for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { double blue , green , index , opacity , red ; red = 0.0 ; green = 0.0 ; blue = 0.0 ; index = 0.0 ; opacity = 0.0 ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { if ( ReadBlobString ( image , text ) == ( char * ) NULL ) break ; switch ( image -> colorspace ) { case GRAYColorspace : { if ( image -> matte != MagickFalse ) { ( void ) sscanf ( text , \"%ld,%ld:<S2SV_blank>(%lf%*[%,]%lf%*[%,]\" , & x_offset , & y_offset , & red , & opacity ) ; green = red ; blue = red ; break ; } ( void ) sscanf ( text , \"%ld,%ld:<S2SV_blank>(%lf%*[%,]\" , & x_offset , & y_offset , & red ) ; green = red ; blue = red ; break ; } case CMYKColorspace : { if ( image -> matte != MagickFalse ) { ( void ) sscanf ( text , \"%ld,%ld:<S2SV_blank>(%lf%*[%,]%lf%*[%,]%lf%*[%,]%lf%*[%,]%lf%*[%,]\" , & x_offset , & y_offset , & red , & green , & blue , & index , & opacity ) ; break ; } ( void ) sscanf ( text , \"%ld,%ld:<S2SV_blank>(%lf%*[%,]%lf%*[%,]%lf%*[%,]%lf%*[%,]\" , & x_offset , & y_offset , & red , & green , & blue , & index ) ; break ; } default : { if ( image -> matte != MagickFalse ) { ( void ) sscanf ( text , \"%ld,%ld:<S2SV_blank>(%lf%*[%,]%lf%*[%,]%lf%*[%,]%lf%*[%,]\" , & x_offset , & y_offset , & red , & green , & blue , & opacity ) ; break ; } ( void ) sscanf ( text , \"%ld,%ld:<S2SV_blank>(%lf%*[%,]%lf%*[%,]%lf%*[%,]\" , & x_offset , & y_offset , & red , & green , & blue ) ; break ; } } if ( strchr ( text , '%' ) != ( char * ) NULL ) { red *= 0.01 * range ; green *= 0.01 * range ; blue *= 0.01 * range ; index *= 0.01 * range ; opacity *= 0.01 * range ; } if ( image -> colorspace == LabColorspace ) { green += ( range + 1 ) / 2.0 ; blue += ( range + 1 ) / 2.0 ; } pixel . red = ( MagickRealType ) ScaleAnyToQuantum ( ( QuantumAny ) ( red + 0.5 ) , range ) ; pixel . green = ( MagickRealType ) ScaleAnyToQuantum ( ( QuantumAny ) ( green + 0.5 ) , range ) ; pixel . blue = ( MagickRealType ) ScaleAnyToQuantum ( ( QuantumAny ) ( blue + 0.5 ) , range ) ; pixel . index = ( MagickRealType ) ScaleAnyToQuantum ( ( QuantumAny ) ( index + 0.5 ) , range ) ; pixel . opacity = ( MagickRealType ) ScaleAnyToQuantum ( ( QuantumAny ) ( opacity + 0.5 ) , range ) ; q = GetAuthenticPixels ( image , ( ssize_t ) x_offset , ( ssize_t ) y_offset , 1 , 1 , exception ) ; if ( q == ( PixelPacket * ) NULL ) continue ; SetPixelRed ( q , pixel . red ) ; SetPixelGreen ( q , pixel . green ) ; SetPixelBlue ( q , pixel . blue ) ; if ( image -> colorspace == CMYKColorspace ) { indexes = GetAuthenticIndexQueue ( image ) ; SetPixelIndex ( indexes , pixel . index ) ; } if ( image -> matte != MagickFalse ) SetPixelAlpha ( q , pixel . opacity ) ; if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; } } <S2SV_StartBug> ( void ) ReadBlobString ( image , text ) ; <S2SV_EndBug> if ( LocaleNCompare ( ( char * ) text , MagickID , strlen ( MagickID ) ) == 0 ) { AcquireNextImage ( image_info , image ) ; if ( GetNextImageInList ( image ) == ( Image * ) NULL ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } image = SyncNextImageInList ( image ) ; status = SetImageProgress ( image , LoadImagesTag , TellBlob ( image ) , GetBlobSize ( image ) ) ; if ( status == MagickFalse ) break ; } } while ( LocaleNCompare ( ( char * ) text , MagickID , strlen ( MagickID ) ) == 0 ) ; ( void ) CloseBlob ( image ) ; return ( GetFirstImageInList ( image ) ) ; }\n","target":"<S2SV_ModStart> ; } } if ( EOFBlob ( image ) != MagickFalse ) { ThrowFileException ( exception , CorruptImageError , \"UnexpectedEndOfFile\" , image -> filename ) ; break ; }\n","project_and_commit_id":"ImageMagick@ImageMagick/a8f9c2aabed37cd6a728532d1aed13ae0f3dfd78","cve_id":"CVE-2017-11523","original_address":"https://github.com/ImageMagick/ImageMagick/commit/a8f9c2aabed37cd6a728532d1aed13ae0f3dfd78","time":"2017-07-22T21:29Z"},
	{"Unnamed: 0":4850,"cwe_id":"CWE-416","source":"CWE-416 static int splice_pipe_to_pipe ( struct pipe_inode_info * ipipe , struct pipe_inode_info * opipe , size_t len , unsigned int flags ) { struct pipe_buffer * ibuf , * obuf ; int ret = 0 , nbuf ; bool input_wakeup = false ; retry : ret = ipipe_prep ( ipipe , flags ) ; if ( ret ) return ret ; ret = opipe_prep ( opipe , flags ) ; if ( ret ) return ret ; pipe_double_lock ( ipipe , opipe ) ; do { if ( ! opipe -> readers ) { send_sig ( SIGPIPE , current , 0 ) ; if ( ! ret ) ret = - EPIPE ; break ; } if ( ! ipipe -> nrbufs && ! ipipe -> writers ) break ; if ( ! ipipe -> nrbufs || opipe -> nrbufs >= opipe -> buffers ) { if ( ret ) break ; if ( flags & SPLICE_F_NONBLOCK ) { ret = - EAGAIN ; break ; } pipe_unlock ( ipipe ) ; pipe_unlock ( opipe ) ; goto retry ; } ibuf = ipipe -> bufs + ipipe -> curbuf ; nbuf = ( opipe -> curbuf + opipe -> nrbufs ) & ( opipe -> buffers - 1 ) ; obuf = opipe -> bufs + nbuf ; if ( len >= ibuf -> len ) { * obuf = * ibuf ; ibuf -> ops = NULL ; opipe -> nrbufs ++ ; ipipe -> curbuf = ( ipipe -> curbuf + 1 ) & ( ipipe -> buffers - 1 ) ; ipipe -> nrbufs -- ; input_wakeup = true ; } else { <S2SV_StartBug> pipe_buf_get ( ipipe , ibuf ) ; <S2SV_EndBug> * obuf = * ibuf ; obuf -> flags &= ~ PIPE_BUF_FLAG_GIFT ; obuf -> len = len ; opipe -> nrbufs ++ ; ibuf -> offset += obuf -> len ; ibuf -> len -= obuf -> len ; } ret += obuf -> len ; len -= obuf -> len ; } while ( len ) ; pipe_unlock ( ipipe ) ; pipe_unlock ( opipe ) ; if ( ret > 0 ) wakeup_pipe_readers ( opipe ) ; if ( input_wakeup ) wakeup_pipe_writers ( ipipe ) ; return ret ; }\n","target":"<S2SV_ModStart> } else { if ( ! <S2SV_ModStart> , ibuf ) ) { if ( ret == 0 ) ret = - EFAULT ; break ; } <S2SV_ModEnd> * obuf =\n","project_and_commit_id":"torvalds@linux/15fab63e1e57be9fdb5eec1bbc5916e9825e9acb","cve_id":"CVE-2019-11487","original_address":"https://github.com/torvalds/linux/commit/15fab63e1e57be9fdb5eec1bbc5916e9825e9acb","time":"2019-04-23T22:29Z"},
	{"Unnamed: 0":4402,"cwe_id":"CWE-269","source":"CWE-269 void virtio_config_writel ( VirtIODevice * vdev , uint32_t addr , uint32_t data ) { VirtioDeviceClass * k = VIRTIO_DEVICE_GET_CLASS ( vdev ) ; uint32_t val = data ; <S2SV_StartBug> if ( addr > ( vdev -> config_len - sizeof ( val ) ) ) <S2SV_EndBug> return ; stl_p ( vdev -> config + addr , val ) ; if ( k -> set_config ) { k -> set_config ( vdev , vdev -> config ) ; } }\n","target":"<S2SV_ModStart> if ( addr + <S2SV_ModEnd> sizeof ( val <S2SV_ModStart> ( val ) > vdev -> config_len ) { return ; } <S2SV_ModEnd> stl_p ( vdev\n","project_and_commit_id":"qemu@qemu/5f5a1318653c08e435cfa52f60b6a712815b659d","cve_id":"CVE-2013-2016","original_address":"https://github.com/qemu/qemu/commit/5f5a1318653c08e435cfa52f60b6a712815b659d","time":"2019-12-30T22:15Z"},
	{"Unnamed: 0":6389,"cwe_id":"CWE-119","source":"CWE-119 static void filter_selectively_horiz ( uint8_t * s , int pitch , unsigned int mask_16x16 , unsigned int mask_8x8 , unsigned int mask_4x4 , unsigned int mask_4x4_int , const loop_filter_info_n * lfi_n , const uint8_t * lfl ) { unsigned int mask ; int count ; for ( mask = mask_16x16 | mask_8x8 | mask_4x4 | mask_4x4_int ; mask ; mask >>= count ) { const loop_filter_thresh * lfi = lfi_n -> lfthr + * lfl ; count = 1 ; if ( mask & 1 ) { if ( mask_16x16 & 1 ) { if ( ( mask_16x16 & 3 ) == 3 ) { <S2SV_StartBug> vp9_lpf_horizontal_16 ( s , pitch , lfi -> mblim , lfi -> lim , <S2SV_EndBug> lfi -> hev_thr , 2 ) ; count = 2 ; } else { <S2SV_StartBug> vp9_lpf_horizontal_16 ( s , pitch , lfi -> mblim , lfi -> lim , <S2SV_EndBug> lfi -> hev_thr , 1 ) ; } } else if ( mask_8x8 & 1 ) { if ( ( mask_8x8 & 3 ) == 3 ) { const loop_filter_thresh * lfin = lfi_n -> lfthr + * ( lfl + 1 ) ; <S2SV_StartBug> vp9_lpf_horizontal_8_dual ( s , pitch , lfi -> mblim , lfi -> lim , <S2SV_EndBug> lfi -> hev_thr , lfin -> mblim , lfin -> lim , lfin -> hev_thr ) ; if ( ( mask_4x4_int & 3 ) == 3 ) { <S2SV_StartBug> vp9_lpf_horizontal_4_dual ( s + 4 * pitch , pitch , lfi -> mblim , <S2SV_EndBug> lfi -> lim , lfi -> hev_thr , lfin -> mblim , lfin -> lim , lfin -> hev_thr ) ; } else { if ( mask_4x4_int & 1 ) vp9_lpf_horizontal_4 ( s + 4 * pitch , pitch , lfi -> mblim , lfi -> lim , lfi -> hev_thr , 1 ) ; else if ( mask_4x4_int & 2 ) <S2SV_StartBug> vp9_lpf_horizontal_4 ( s + 8 + 4 * pitch , pitch , lfin -> mblim , <S2SV_EndBug> lfin -> lim , lfin -> hev_thr , 1 ) ; } count = 2 ; } else { <S2SV_StartBug> vp9_lpf_horizontal_8 ( s , pitch , lfi -> mblim , lfi -> lim , lfi -> hev_thr , 1 ) ; <S2SV_EndBug> if ( mask_4x4_int & 1 ) vp9_lpf_horizontal_4 ( s + 4 * pitch , pitch , lfi -> mblim , lfi -> lim , lfi -> hev_thr , 1 ) ; } } else if ( mask_4x4 & 1 ) { if ( ( mask_4x4 & 3 ) == 3 ) { const loop_filter_thresh * lfin = lfi_n -> lfthr + * ( lfl + 1 ) ; <S2SV_StartBug> vp9_lpf_horizontal_4_dual ( s , pitch , lfi -> mblim , lfi -> lim , <S2SV_EndBug> lfi -> hev_thr , lfin -> mblim , lfin -> lim , lfin -> hev_thr ) ; if ( ( mask_4x4_int & 3 ) == 3 ) { <S2SV_StartBug> vp9_lpf_horizontal_4_dual ( s + 4 * pitch , pitch , lfi -> mblim , <S2SV_EndBug> lfi -> lim , lfi -> hev_thr , lfin -> mblim , lfin -> lim , lfin -> hev_thr ) ; } else { if ( mask_4x4_int & 1 ) vp9_lpf_horizontal_4 ( s + 4 * pitch , pitch , lfi -> mblim , lfi -> lim , lfi -> hev_thr , 1 ) ; else if ( mask_4x4_int & 2 ) <S2SV_StartBug> vp9_lpf_horizontal_4 ( s + 8 + 4 * pitch , pitch , lfin -> mblim , <S2SV_EndBug> lfin -> lim , lfin -> hev_thr , 1 ) ; } count = 2 ; } else { <S2SV_StartBug> vp9_lpf_horizontal_4 ( s , pitch , lfi -> mblim , lfi -> lim , lfi -> hev_thr , 1 ) ; <S2SV_EndBug> if ( mask_4x4_int & 1 ) vp9_lpf_horizontal_4 ( s + 4 * pitch , pitch , lfi -> mblim , lfi -> lim , lfi -> hev_thr , 1 ) ; } } else if ( mask_4x4_int & 1 ) { vp9_lpf_horizontal_4 ( s + 4 * pitch , pitch , lfi -> mblim , lfi -> lim , lfi -> hev_thr , 1 ) ; } } s += 8 * count ; lfl += count ; mask_16x16 >>= count ; mask_8x8 >>= count ; mask_4x4 >>= count ; mask_4x4_int >>= count ; } }\n","target":"<S2SV_ModStart> 3 ) { vpx_lpf_horizontal_16 <S2SV_ModEnd> ( s , <S2SV_ModStart> } else { vpx_lpf_horizontal_16 <S2SV_ModEnd> ( s , <S2SV_ModStart> 1 ) ; vpx_lpf_horizontal_8_dual <S2SV_ModEnd> ( s , <S2SV_ModStart> 3 ) { vpx_lpf_horizontal_4_dual ( s + 4 * pitch , pitch , lfi -> mblim , lfi -> lim , lfi -> hev_thr , lfin -> mblim , lfin -> lim , lfin -> hev_thr ) ; } else { if ( mask_4x4_int & 1 ) vpx_lpf_horizontal_4 <S2SV_ModEnd> ( s + <S2SV_ModStart> & 2 ) vpx_lpf_horizontal_4 <S2SV_ModEnd> ( s + <S2SV_ModStart> } else { vpx_lpf_horizontal_8 ( s , pitch , lfi -> mblim , lfi -> lim , lfi -> hev_thr , 1 ) ; if ( mask_4x4_int & 1 ) vpx_lpf_horizontal_4 <S2SV_ModEnd> ( s + <S2SV_ModStart> 1 ) ; vpx_lpf_horizontal_4_dual <S2SV_ModEnd> ( s , <S2SV_ModStart> 3 ) { vpx_lpf_horizontal_4_dual ( s + 4 * pitch , pitch , lfi -> mblim , lfi -> lim , lfi -> hev_thr , lfin -> mblim , lfin -> lim , lfin -> hev_thr ) ; } else { if ( mask_4x4_int & 1 ) vpx_lpf_horizontal_4 <S2SV_ModEnd> ( s + <S2SV_ModStart> & 2 ) vpx_lpf_horizontal_4 <S2SV_ModEnd> ( s + <S2SV_ModStart> } else { vpx_lpf_horizontal_4 ( s , pitch , lfi -> mblim , lfi -> lim , lfi -> hev_thr , 1 ) ; if ( mask_4x4_int & 1 ) vpx_lpf_horizontal_4 ( s + 4 * pitch , pitch , lfi -> mblim , lfi -> lim , lfi -> hev_thr , 1 ) ; } } else if ( mask_4x4_int & 1 ) { vpx_lpf_horizontal_4 <S2SV_ModEnd> ( s +\n","project_and_commit_id":"external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426","cve_id":"CVE-2016-1621","original_address":"https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426","time":"2016-03-12T21:59Z"},
	{"Unnamed: 0":5997,"cwe_id":"CWE-119","source":"CWE-119 <S2SV_StartBug> static void encode_frame ( vpx_codec_ctx_t * codec , <S2SV_EndBug> vpx_image_t * img , int frame_index , <S2SV_StartBug> VpxVideoWriter * writer ) { <S2SV_EndBug> vpx_codec_iter_t iter = NULL ; const vpx_codec_cx_pkt_t * pkt = NULL ; const vpx_codec_err_t res = vpx_codec_encode ( codec , img , frame_index , 1 , 0 , VPX_DL_GOOD_QUALITY ) ; if ( res != VPX_CODEC_OK ) die_codec ( codec , \"Failed<S2SV_blank>to<S2SV_blank>encode<S2SV_blank>frame\" ) ; <S2SV_StartBug> while ( ( pkt = vpx_codec_get_cx_data ( codec , & iter ) ) != NULL ) { <S2SV_EndBug> if ( pkt -> kind == VPX_CODEC_CX_FRAME_PKT ) { const int keyframe = ( pkt -> data . frame . flags & VPX_FRAME_IS_KEY ) != 0 ; if ( ! vpx_video_writer_write_frame ( writer , pkt -> data . frame . buf , pkt -> data . frame . sz , pkt -> data . frame . pts ) ) { die_codec ( codec , \"Failed<S2SV_blank>to<S2SV_blank>write<S2SV_blank>compressed<S2SV_blank>frame\" ) ; } printf ( keyframe ? \"K\" : \".\" ) ; fflush ( stdout ) ; } } <S2SV_StartBug> } <S2SV_EndBug>\n","target":"<S2SV_ModStart> <S2SV_null> <S2SV_null> static int <S2SV_ModEnd> encode_frame ( vpx_codec_ctx_t <S2SV_ModStart> writer ) { int got_pkts = 0 ; <S2SV_ModStart> NULL ) { got_pkts = 1 ; <S2SV_ModStart> ; } } return got_pkts ;\n","project_and_commit_id":"external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426","cve_id":"CVE-2016-1621","original_address":"https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426","time":"2016-03-12T21:59Z"},
	{"Unnamed: 0":5547,"cwe_id":"CWE-000","source":"CWE-000 static int acm_probe ( struct usb_interface * intf , const struct usb_device_id * id ) { struct usb_cdc_union_desc * union_header = NULL ; struct usb_cdc_country_functional_desc * cfd = NULL ; unsigned char * buffer = intf -> altsetting -> extra ; int buflen = intf -> altsetting -> extralen ; struct usb_interface * control_interface ; struct usb_interface * data_interface ; struct usb_endpoint_descriptor * epctrl = NULL ; struct usb_endpoint_descriptor * epread = NULL ; struct usb_endpoint_descriptor * epwrite = NULL ; struct usb_device * usb_dev = interface_to_usbdev ( intf ) ; struct acm * acm ; int minor ; int ctrlsize , readsize ; u8 * buf ; u8 ac_management_function = 0 ; u8 call_management_function = 0 ; int call_interface_num = - 1 ; int data_interface_num = - 1 ; unsigned long quirks ; int num_rx_buf ; int i ; unsigned int elength = 0 ; int combined_interfaces = 0 ; struct device * tty_dev ; int rv = - ENOMEM ; quirks = ( unsigned long ) id -> driver_info ; if ( quirks == IGNORE_DEVICE ) return - ENODEV ; num_rx_buf = ( quirks == SINGLE_RX_URB ) ? 1 : ACM_NR ; if ( quirks == NO_UNION_NORMAL ) { data_interface = usb_ifnum_to_if ( usb_dev , 1 ) ; <S2SV_StartBug> control_interface = usb_ifnum_to_if ( usb_dev , 0 ) ; <S2SV_EndBug> goto skip_normal_probe ; } if ( ! buffer ) { dev_err ( & intf -> dev , \"Weird<S2SV_blank>descriptor<S2SV_blank>references\\\\n\" ) ; return - EINVAL ; } if ( ! buflen ) { if ( intf -> cur_altsetting -> endpoint && intf -> cur_altsetting -> endpoint -> extralen && intf -> cur_altsetting -> endpoint -> extra ) { dev_dbg ( & intf -> dev , \"Seeking<S2SV_blank>extra<S2SV_blank>descriptors<S2SV_blank>on<S2SV_blank>endpoint\\\\n\" ) ; buflen = intf -> cur_altsetting -> endpoint -> extralen ; buffer = intf -> cur_altsetting -> endpoint -> extra ; } else { dev_err ( & intf -> dev , \"Zero<S2SV_blank>length<S2SV_blank>descriptor<S2SV_blank>references\\\\n\" ) ; return - EINVAL ; } } while ( buflen > 0 ) { elength = buffer [ 0 ] ; if ( ! elength ) { dev_err ( & intf -> dev , \"skipping<S2SV_blank>garbage<S2SV_blank>byte\\\\n\" ) ; elength = 1 ; goto next_desc ; } if ( buffer [ 1 ] != USB_DT_CS_INTERFACE ) { dev_err ( & intf -> dev , \"skipping<S2SV_blank>garbage\\\\n\" ) ; goto next_desc ; } switch ( buffer [ 2 ] ) { case USB_CDC_UNION_TYPE : if ( elength < sizeof ( struct usb_cdc_union_desc ) ) goto next_desc ; if ( union_header ) { dev_err ( & intf -> dev , \"More<S2SV_blank>than<S2SV_blank>one<S2SV_blank>\" \"union<S2SV_blank>descriptor,<S2SV_blank>skipping<S2SV_blank>...\\\\n\" ) ; goto next_desc ; } union_header = ( struct usb_cdc_union_desc * ) buffer ; break ; case USB_CDC_COUNTRY_TYPE : if ( elength < sizeof ( struct usb_cdc_country_functional_desc ) ) goto next_desc ; cfd = ( struct usb_cdc_country_functional_desc * ) buffer ; break ; case USB_CDC_HEADER_TYPE : break ; case USB_CDC_ACM_TYPE : if ( elength < 4 ) goto next_desc ; ac_management_function = buffer [ 3 ] ; break ; case USB_CDC_CALL_MANAGEMENT_TYPE : if ( elength < 5 ) goto next_desc ; call_management_function = buffer [ 3 ] ; call_interface_num = buffer [ 4 ] ; break ; default : dev_dbg ( & intf -> dev , \"Ignoring<S2SV_blank>descriptor:<S2SV_blank>\" \"type<S2SV_blank>%02x,<S2SV_blank>length<S2SV_blank>%ud\\\\n\" , buffer [ 2 ] , elength ) ; break ; } next_desc : buflen -= elength ; buffer += elength ; } if ( ! union_header ) { if ( call_interface_num > 0 ) { dev_dbg ( & intf -> dev , \"No<S2SV_blank>union<S2SV_blank>descriptor,<S2SV_blank>using<S2SV_blank>call<S2SV_blank>management<S2SV_blank>descriptor\\\\n\" ) ; if ( quirks & NO_DATA_INTERFACE ) data_interface = usb_ifnum_to_if ( usb_dev , 0 ) ; else data_interface = usb_ifnum_to_if ( usb_dev , ( data_interface_num = call_interface_num ) ) ; control_interface = intf ; } else { if ( intf -> cur_altsetting -> desc . bNumEndpoints != 3 ) { dev_dbg ( & intf -> dev , \"No<S2SV_blank>union<S2SV_blank>descriptor,<S2SV_blank>giving<S2SV_blank>up\\\\n\" ) ; return - ENODEV ; } else { dev_warn ( & intf -> dev , \"No<S2SV_blank>union<S2SV_blank>descriptor,<S2SV_blank>testing<S2SV_blank>for<S2SV_blank>castrated<S2SV_blank>device\\\\n\" ) ; combined_interfaces = 1 ; control_interface = data_interface = intf ; goto look_for_collapsed_interface ; } } } else { control_interface = usb_ifnum_to_if ( usb_dev , union_header -> bMasterInterface0 ) ; data_interface = usb_ifnum_to_if ( usb_dev , ( data_interface_num = union_header -> bSlaveInterface0 ) ) ; } if ( ! control_interface || ! data_interface ) { dev_dbg ( & intf -> dev , \"no<S2SV_blank>interfaces\\\\n\" ) ; return - ENODEV ; } if ( data_interface_num != call_interface_num ) dev_dbg ( & intf -> dev , \"Separate<S2SV_blank>call<S2SV_blank>control<S2SV_blank>interface.<S2SV_blank>That<S2SV_blank>is<S2SV_blank>not<S2SV_blank>fully<S2SV_blank>supported.\\\\n\" ) ; if ( control_interface == data_interface ) { dev_warn ( & intf -> dev , \"Control<S2SV_blank>and<S2SV_blank>data<S2SV_blank>interfaces<S2SV_blank>are<S2SV_blank>not<S2SV_blank>separated!\\\\n\" ) ; combined_interfaces = 1 ; quirks |= NO_CAP_LINE ; if ( data_interface -> cur_altsetting -> desc . bNumEndpoints != 3 ) { dev_err ( & intf -> dev , \"This<S2SV_blank>needs<S2SV_blank>exactly<S2SV_blank>3<S2SV_blank>endpoints\\\\n\" ) ; return - EINVAL ; } look_for_collapsed_interface : for ( i = 0 ; i < 3 ; i ++ ) { struct usb_endpoint_descriptor * ep ; ep = & data_interface -> cur_altsetting -> endpoint [ i ] . desc ; if ( usb_endpoint_is_int_in ( ep ) ) epctrl = ep ; else if ( usb_endpoint_is_bulk_out ( ep ) ) epwrite = ep ; else if ( usb_endpoint_is_bulk_in ( ep ) ) epread = ep ; else return - EINVAL ; } if ( ! epctrl || ! epread || ! epwrite ) return - ENODEV ; else goto made_compressed_probe ; } skip_normal_probe : if ( data_interface -> cur_altsetting -> desc . bInterfaceClass != CDC_DATA_INTERFACE_TYPE ) { if ( control_interface -> cur_altsetting -> desc . bInterfaceClass == CDC_DATA_INTERFACE_TYPE ) { dev_dbg ( & intf -> dev , \"Your<S2SV_blank>device<S2SV_blank>has<S2SV_blank>switched<S2SV_blank>interfaces.\\\\n\" ) ; swap ( control_interface , data_interface ) ; } else { return - EINVAL ; } } if ( ! combined_interfaces && intf != control_interface ) return - ENODEV ; if ( ! combined_interfaces && usb_interface_claimed ( data_interface ) ) { dev_dbg ( & intf -> dev , \"The<S2SV_blank>data<S2SV_blank>interface<S2SV_blank>isn\\'t<S2SV_blank>available\\\\n\" ) ; return - EBUSY ; } if ( data_interface -> cur_altsetting -> desc . bNumEndpoints < 2 || control_interface -> cur_altsetting -> desc . bNumEndpoints == 0 ) return - EINVAL ; epctrl = & control_interface -> cur_altsetting -> endpoint [ 0 ] . desc ; epread = & data_interface -> cur_altsetting -> endpoint [ 0 ] . desc ; epwrite = & data_interface -> cur_altsetting -> endpoint [ 1 ] . desc ; if ( ! usb_endpoint_dir_in ( epread ) ) { dev_dbg ( & intf -> dev , \"The<S2SV_blank>data<S2SV_blank>interface<S2SV_blank>has<S2SV_blank>switched<S2SV_blank>endpoints\\\\n\" ) ; swap ( epread , epwrite ) ; } made_compressed_probe : dev_dbg ( & intf -> dev , \"interfaces<S2SV_blank>are<S2SV_blank>valid\\\\n\" ) ; acm = kzalloc ( sizeof ( struct acm ) , GFP_KERNEL ) ; if ( acm == NULL ) goto alloc_fail ; minor = acm_alloc_minor ( acm ) ; if ( minor < 0 ) { dev_err ( & intf -> dev , \"no<S2SV_blank>more<S2SV_blank>free<S2SV_blank>acm<S2SV_blank>devices\\\\n\" ) ; kfree ( acm ) ; return - ENODEV ; } ctrlsize = usb_endpoint_maxp ( epctrl ) ; readsize = usb_endpoint_maxp ( epread ) * ( quirks == SINGLE_RX_URB ? 1 : 2 ) ; acm -> combined_interfaces = combined_interfaces ; acm -> writesize = usb_endpoint_maxp ( epwrite ) * 20 ; acm -> control = control_interface ; acm -> data = data_interface ; acm -> minor = minor ; acm -> dev = usb_dev ; acm -> ctrl_caps = ac_management_function ; if ( quirks & NO_CAP_LINE ) acm -> ctrl_caps &= ~ USB_CDC_CAP_LINE ; acm -> ctrlsize = ctrlsize ; acm -> readsize = readsize ; acm -> rx_buflimit = num_rx_buf ; INIT_WORK ( & acm -> work , acm_softint ) ; init_waitqueue_head ( & acm -> wioctl ) ; spin_lock_init ( & acm -> write_lock ) ; spin_lock_init ( & acm -> read_lock ) ; mutex_init ( & acm -> mutex ) ; acm -> rx_endpoint = usb_rcvbulkpipe ( usb_dev , epread -> bEndpointAddress ) ; acm -> is_int_ep = usb_endpoint_xfer_int ( epread ) ; if ( acm -> is_int_ep ) acm -> bInterval = epread -> bInterval ; tty_port_init ( & acm -> port ) ; acm -> port . ops = & acm_port_ops ; init_usb_anchor ( & acm -> delayed ) ; acm -> quirks = quirks ; buf = usb_alloc_coherent ( usb_dev , ctrlsize , GFP_KERNEL , & acm -> ctrl_dma ) ; if ( ! buf ) goto alloc_fail2 ; acm -> ctrl_buffer = buf ; if ( acm_write_buffers_alloc ( acm ) < 0 ) goto alloc_fail4 ; acm -> ctrlurb = usb_alloc_urb ( 0 , GFP_KERNEL ) ; if ( ! acm -> ctrlurb ) goto alloc_fail5 ; for ( i = 0 ; i < num_rx_buf ; i ++ ) { struct acm_rb * rb = & ( acm -> read_buffers [ i ] ) ; struct urb * urb ; rb -> base = usb_alloc_coherent ( acm -> dev , readsize , GFP_KERNEL , & rb -> dma ) ; if ( ! rb -> base ) goto alloc_fail6 ; rb -> index = i ; rb -> instance = acm ; urb = usb_alloc_urb ( 0 , GFP_KERNEL ) ; if ( ! urb ) goto alloc_fail6 ; urb -> transfer_flags |= URB_NO_TRANSFER_DMA_MAP ; urb -> transfer_dma = rb -> dma ; if ( acm -> is_int_ep ) { usb_fill_int_urb ( urb , acm -> dev , acm -> rx_endpoint , rb -> base , acm -> readsize , acm_read_bulk_callback , rb , acm -> bInterval ) ; } else { usb_fill_bulk_urb ( urb , acm -> dev , acm -> rx_endpoint , rb -> base , acm -> readsize , acm_read_bulk_callback , rb ) ; } acm -> read_urbs [ i ] = urb ; __set_bit ( i , & acm -> read_urbs_free ) ; } for ( i = 0 ; i < ACM_NW ; i ++ ) { struct acm_wb * snd = & ( acm -> wb [ i ] ) ; snd -> urb = usb_alloc_urb ( 0 , GFP_KERNEL ) ; if ( snd -> urb == NULL ) goto alloc_fail7 ; if ( usb_endpoint_xfer_int ( epwrite ) ) usb_fill_int_urb ( snd -> urb , usb_dev , usb_sndintpipe ( usb_dev , epwrite -> bEndpointAddress ) , NULL , acm -> writesize , acm_write_bulk , snd , epwrite -> bInterval ) ; else usb_fill_bulk_urb ( snd -> urb , usb_dev , usb_sndbulkpipe ( usb_dev , epwrite -> bEndpointAddress ) , NULL , acm -> writesize , acm_write_bulk , snd ) ; snd -> urb -> transfer_flags |= URB_NO_TRANSFER_DMA_MAP ; if ( quirks & SEND_ZERO_PACKET ) snd -> urb -> transfer_flags |= URB_ZERO_PACKET ; snd -> instance = acm ; } usb_set_intfdata ( intf , acm ) ; i = device_create_file ( & intf -> dev , & dev_attr_bmCapabilities ) ; if ( i < 0 ) goto alloc_fail7 ; if ( cfd ) { acm -> country_codes = kmalloc ( cfd -> bLength - 4 , GFP_KERNEL ) ; if ( ! acm -> country_codes ) goto skip_countries ; acm -> country_code_size = cfd -> bLength - 4 ; memcpy ( acm -> country_codes , ( u8 * ) & cfd -> wCountyCode0 , cfd -> bLength - 4 ) ; acm -> country_rel_date = cfd -> iCountryCodeRelDate ; i = device_create_file ( & intf -> dev , & dev_attr_wCountryCodes ) ; if ( i < 0 ) { kfree ( acm -> country_codes ) ; acm -> country_codes = NULL ; acm -> country_code_size = 0 ; goto skip_countries ; } i = device_create_file ( & intf -> dev , & dev_attr_iCountryCodeRelDate ) ; if ( i < 0 ) { device_remove_file ( & intf -> dev , & dev_attr_wCountryCodes ) ; kfree ( acm -> country_codes ) ; acm -> country_codes = NULL ; acm -> country_code_size = 0 ; goto skip_countries ; } } skip_countries : usb_fill_int_urb ( acm -> ctrlurb , usb_dev , usb_rcvintpipe ( usb_dev , epctrl -> bEndpointAddress ) , acm -> ctrl_buffer , ctrlsize , acm_ctrl_irq , acm , epctrl -> bInterval ? epctrl -> bInterval : 16 ) ; acm -> ctrlurb -> transfer_flags |= URB_NO_TRANSFER_DMA_MAP ; acm -> ctrlurb -> transfer_dma = acm -> ctrl_dma ; dev_info ( & intf -> dev , \"ttyACM%d:<S2SV_blank>USB<S2SV_blank>ACM<S2SV_blank>device\\\\n\" , minor ) ; acm -> line . dwDTERate = cpu_to_le32 ( 9600 ) ; acm -> line . bDataBits = 8 ; acm_set_line ( acm , & acm -> line ) ; usb_driver_claim_interface ( & acm_driver , data_interface , acm ) ; usb_set_intfdata ( data_interface , acm ) ; usb_get_intf ( control_interface ) ; tty_dev = tty_port_register_device ( & acm -> port , acm_tty_driver , minor , & control_interface -> dev ) ; if ( IS_ERR ( tty_dev ) ) { rv = PTR_ERR ( tty_dev ) ; goto alloc_fail8 ; } if ( quirks & CLEAR_HALT_CONDITIONS ) { usb_clear_halt ( usb_dev , usb_rcvbulkpipe ( usb_dev , epread -> bEndpointAddress ) ) ; usb_clear_halt ( usb_dev , usb_sndbulkpipe ( usb_dev , epwrite -> bEndpointAddress ) ) ; } return 0 ; alloc_fail8 : if ( acm -> country_codes ) { device_remove_file ( & acm -> control -> dev , & dev_attr_wCountryCodes ) ; device_remove_file ( & acm -> control -> dev , & dev_attr_iCountryCodeRelDate ) ; kfree ( acm -> country_codes ) ; } device_remove_file ( & acm -> control -> dev , & dev_attr_bmCapabilities ) ; alloc_fail7 : usb_set_intfdata ( intf , NULL ) ; for ( i = 0 ; i < ACM_NW ; i ++ ) usb_free_urb ( acm -> wb [ i ] . urb ) ; alloc_fail6 : for ( i = 0 ; i < num_rx_buf ; i ++ ) usb_free_urb ( acm -> read_urbs [ i ] ) ; acm_read_buffers_free ( acm ) ; usb_free_urb ( acm -> ctrlurb ) ; alloc_fail5 : acm_write_buffers_free ( acm ) ; alloc_fail4 : usb_free_coherent ( usb_dev , ctrlsize , acm -> ctrl_buffer , acm -> ctrl_dma ) ; alloc_fail2 : acm_release_minor ( acm ) ; kfree ( acm ) ; alloc_fail : return rv ; }\n","target":"<S2SV_ModStart> , 0 ) ; if ( ! data_interface || ! control_interface ) return - ENODEV\n","project_and_commit_id":"torvalds@linux/8835ba4a39cf53f705417b3b3a94eb067673f2c9","cve_id":"CVE-2016-3138","original_address":"https://github.com/torvalds/linux/commit/8835ba4a39cf53f705417b3b3a94eb067673f2c9","time":"2016-05-02T10:59Z"},
	{"Unnamed: 0":1092,"cwe_id":"CWE-119","source":"CWE-119 void vp9_init_quantizer ( VP9_COMP * cpi ) { VP9_COMMON * const cm = & cpi -> common ; QUANTS * const quants = & cpi -> quants ; int i , q , quant ; for ( q = 0 ; q < QINDEX_RANGE ; q ++ ) { <S2SV_StartBug> const int qzbin_factor = q == 0 ? 64 : ( vp9_dc_quant ( q , 0 ) < 148 ? 84 : 80 ) ; <S2SV_EndBug> const int qrounding_factor = q == 0 ? 64 : 48 ; for ( i = 0 ; i < 2 ; ++ i ) { <S2SV_StartBug> quant = i == 0 ? vp9_dc_quant ( q , cm -> y_dc_delta_q ) <S2SV_EndBug> <S2SV_StartBug> : vp9_ac_quant ( q , 0 ) ; <S2SV_EndBug> invert_quant ( & quants -> y_quant [ q ] [ i ] , & quants -> y_quant_shift [ q ] [ i ] , quant ) ; <S2SV_StartBug> quants -> y_zbin [ q ] [ i ] = ROUND_POWER_OF_TWO ( qzbin_factor * quant , 7 ) ; <S2SV_EndBug> quants -> y_round [ q ] [ i ] = ( qrounding_factor * quant ) >> 7 ; <S2SV_StartBug> cm -> y_dequant [ q ] [ i ] = quant ; <S2SV_EndBug> <S2SV_StartBug> quant = i == 0 ? vp9_dc_quant ( q , cm -> uv_dc_delta_q ) <S2SV_EndBug> <S2SV_StartBug> : vp9_ac_quant ( q , cm -> uv_ac_delta_q ) ; <S2SV_EndBug> invert_quant ( & quants -> uv_quant [ q ] [ i ] , & quants -> uv_quant_shift [ q ] [ i ] , quant ) ; <S2SV_StartBug> quants -> uv_zbin [ q ] [ i ] = ROUND_POWER_OF_TWO ( qzbin_factor * quant , 7 ) ; <S2SV_EndBug> quants -> uv_round [ q ] [ i ] = ( qrounding_factor * quant ) >> 7 ; <S2SV_StartBug> cm -> uv_dequant [ q ] [ i ] = quant ; <S2SV_EndBug> # if CONFIG_ALPHA quant = i == 0 ? vp9_dc_quant ( q , cm -> a_dc_delta_q ) : vp9_ac_quant ( q , cm -> a_ac_delta_q ) ; invert_quant ( & quants -> a_quant [ q ] [ i ] , & quants -> a_quant_shift [ q ] [ i ] , quant ) ; quants -> a_zbin [ q ] [ i ] = ROUND_POWER_OF_TWO ( qzbin_factor * quant , 7 ) ; <S2SV_StartBug> quants -> a_round [ q ] [ i ] = ( qrounding_factor * quant ) >> 7 ; <S2SV_EndBug> <S2SV_StartBug> cm -> a_dequant [ q ] [ i ] = quant ; <S2SV_EndBug> # endif } for ( i = 2 ; i < 8 ; i ++ ) { quants -> y_quant [ q ] [ i ] = quants -> y_quant [ q ] [ 1 ] ; <S2SV_StartBug> quants -> y_quant_shift [ q ] [ i ] = quants -> y_quant_shift [ q ] [ 1 ] ; <S2SV_EndBug> quants -> y_zbin [ q ] [ i ] = quants -> y_zbin [ q ] [ 1 ] ; quants -> y_round [ q ] [ i ] = quants -> y_round [ q ] [ 1 ] ; <S2SV_StartBug> cm -> y_dequant [ q ] [ i ] = cm -> y_dequant [ q ] [ 1 ] ; <S2SV_EndBug> quants -> uv_quant [ q ] [ i ] = quants -> uv_quant [ q ] [ 1 ] ; <S2SV_StartBug> quants -> uv_quant_shift [ q ] [ i ] = quants -> uv_quant_shift [ q ] [ 1 ] ; <S2SV_EndBug> quants -> uv_zbin [ q ] [ i ] = quants -> uv_zbin [ q ] [ 1 ] ; quants -> uv_round [ q ] [ i ] = quants -> uv_round [ q ] [ 1 ] ; <S2SV_StartBug> cm -> uv_dequant [ q ] [ i ] = cm -> uv_dequant [ q ] [ 1 ] ; <S2SV_EndBug> <S2SV_StartBug> # if CONFIG_ALPHA <S2SV_EndBug> quants -> a_quant [ q ] [ i ] = quants -> a_quant [ q ] [ 1 ] ; quants -> a_quant_shift [ q ] [ i ] = quants -> a_quant_shift [ q ] [ 1 ] ; quants -> a_zbin [ q ] [ i ] = quants -> a_zbin [ q ] [ 1 ] ; quants -> a_round [ q ] [ i ] = quants -> a_round [ q ] [ 1 ] ; cm -> a_dequant [ q ] [ i ] = cm -> a_dequant [ q ] [ 1 ] ; # endif } } }\n","target":"<S2SV_ModStart> int qzbin_factor = get_qzbin_factor ( q , cm -> bit_depth <S2SV_ModEnd> ) ; const <S2SV_ModStart> i ) { int qrounding_factor_fp = i == 0 ? 48 : 42 ; if ( q == 0 ) qrounding_factor_fp = 64 ; <S2SV_ModStart> cm -> y_dc_delta_q , cm -> bit_depth <S2SV_ModStart> q , 0 , cm -> bit_depth <S2SV_ModStart> ; quants -> y_quant_fp [ q ] [ i ] = ( 1 << 16 ) / quant ; quants -> y_round_fp [ q ] [ i ] = ( qrounding_factor_fp <S2SV_ModEnd> * quant ) <S2SV_ModStart> >> 7 ; quants -> y_zbin [ q ] [ i ] = ROUND_POWER_OF_TWO ( qzbin_factor * quant , 7 ) ; quants -> y_round [ q ] [ i ] = ( qrounding_factor * quant ) >> 7 ; cpi <S2SV_ModEnd> -> y_dequant [ <S2SV_ModStart> cm -> uv_dc_delta_q , cm -> bit_depth <S2SV_ModStart> cm -> uv_ac_delta_q , cm -> bit_depth <S2SV_ModStart> ; quants -> uv_quant_fp [ q ] [ i ] = ( 1 << 16 ) / quant ; quants -> uv_round_fp [ q ] [ i ] = ( qrounding_factor_fp <S2SV_ModEnd> * quant ) <S2SV_ModStart> >> 7 ; quants -> uv_zbin <S2SV_ModEnd> [ q ] <S2SV_ModStart> ; quants -> uv_round <S2SV_ModEnd> [ q ] <S2SV_ModStart> >> 7 ; cpi -> uv_dequant [ q ] [ i ] = quant ; <S2SV_ModEnd> } for ( <S2SV_ModStart> ; quants -> y_quant_fp [ q ] [ i ] = quants -> y_quant_fp [ q ] [ 1 ] ; quants -> y_round_fp [ q ] [ i ] = quants -> y_round_fp [ q ] [ 1 ] ; quants -> <S2SV_ModStart> 1 ] ; cpi <S2SV_ModEnd> -> y_dequant [ <S2SV_ModStart> i ] = cpi <S2SV_ModEnd> -> y_dequant [ <S2SV_ModStart> ; quants -> uv_quant_fp [ q ] [ i ] = quants -> uv_quant_fp [ q ] [ 1 ] ; quants -> uv_round_fp [ q ] [ i ] = quants -> uv_round_fp [ q ] [ 1 ] ; quants -> <S2SV_ModStart> 1 ] ; cpi <S2SV_ModEnd> -> uv_dequant [ <S2SV_ModStart> i ] = cpi <S2SV_ModEnd> -> uv_dequant [ <S2SV_ModStart> 1 ] ; <S2SV_ModEnd> } } }\n","project_and_commit_id":"external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426","cve_id":"CVE-2016-1621","original_address":"https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426","time":"2016-03-12T21:59Z"},
	{"Unnamed: 0":3704,"cwe_id":"CWE-125","source":"CWE-125 static int set_geometry ( unsigned int cmd , struct floppy_struct * g , int drive , int type , struct block_device * bdev ) { int cnt ; <S2SV_StartBug> if ( g -> sect <= 0 || <S2SV_EndBug> <S2SV_StartBug> g -> head <= 0 || <S2SV_EndBug> ( unsigned char ) ( ( g -> sect << 2 ) >> FD_SIZECODE ( g ) ) == 0 || g -> track <= 0 || g -> track > UDP -> tracks >> STRETCH ( g ) || ( g -> stretch & ~ ( FD_STRETCH | FD_SWAPSIDES | FD_SECTBASEMASK ) ) != 0 ) return - EINVAL ; if ( type ) { if ( ! capable ( CAP_SYS_ADMIN ) ) return - EPERM ; mutex_lock ( & open_lock ) ; if ( lock_fdc ( drive ) ) { mutex_unlock ( & open_lock ) ; return - EINTR ; } floppy_type [ type ] = * g ; floppy_type [ type ] . name = \"user<S2SV_blank>format\" ; for ( cnt = type << 2 ; cnt < ( type << 2 ) + 4 ; cnt ++ ) floppy_sizes [ cnt ] = floppy_sizes [ cnt + 0x80 ] = floppy_type [ type ] . size + 1 ; process_fd_request ( ) ; for ( cnt = 0 ; cnt < N_DRIVE ; cnt ++ ) { struct block_device * bdev = opened_bdev [ cnt ] ; if ( ! bdev || ITYPE ( drive_state [ cnt ] . fd_device ) != type ) continue ; __invalidate_device ( bdev , true ) ; } mutex_unlock ( & open_lock ) ; } else { int oldStretch ; if ( lock_fdc ( drive ) ) return - EINTR ; if ( cmd != FDDEFPRM ) { if ( poll_drive ( true , FD_RAW_NEED_DISK ) == - EINTR ) return - EINTR ; } oldStretch = g -> stretch ; user_params [ drive ] = * g ; if ( buffer_drive == drive ) SUPBOUND ( buffer_max , user_params [ drive ] . sect ) ; current_type [ drive ] = & user_params [ drive ] ; floppy_sizes [ drive ] = user_params [ drive ] . size ; if ( cmd == FDDEFPRM ) DRS -> keep_data = - 1 ; else DRS -> keep_data = 1 ; if ( DRS -> maxblock > user_params [ drive ] . sect || DRS -> maxtrack || ( ( user_params [ drive ] . sect ^ oldStretch ) & ( FD_SWAPSIDES | FD_SECTBASEMASK ) ) ) invalidate_drive ( bdev ) ; else process_fd_request ( ) ; } return 0 ; }\n","target":"<S2SV_ModStart> ; if ( ( int ) <S2SV_ModStart> <= 0 || ( int ) <S2SV_ModStart> g -> head <= 0 || ( int ) ( g -> sect * g -> head )\n","project_and_commit_id":"torvalds@linux/da99466ac243f15fbba65bd261bfc75ffa1532b6","cve_id":"CVE-2019-14283","original_address":"https://github.com/torvalds/linux/commit/da99466ac243f15fbba65bd261bfc75ffa1532b6","time":"2019-07-26T13:15Z"},
	{"Unnamed: 0":1019,"cwe_id":"CWE-000","source":"CWE-000 PHYSICALPATH_FUNC ( mod_alias_physical_handler ) { plugin_data * p = p_d ; int uri_len , basedir_len ; char * uri_ptr ; size_t k ; if ( buffer_is_empty ( con -> physical . path ) ) return HANDLER_GO_ON ; mod_alias_patch_connection ( srv , con , p ) ; basedir_len = buffer_string_length ( con -> physical . basedir ) ; if ( '/' == con -> physical . basedir -> ptr [ basedir_len - 1 ] ) -- basedir_len ; uri_len = buffer_string_length ( con -> physical . path ) - basedir_len ; uri_ptr = con -> physical . path -> ptr + basedir_len ; for ( k = 0 ; k < p -> conf . alias -> used ; k ++ ) { data_string * ds = ( data_string * ) p -> conf . alias -> data [ k ] ; int alias_len = buffer_string_length ( ds -> key ) ; if ( alias_len > uri_len ) continue ; if ( buffer_is_empty ( ds -> key ) ) continue ; if ( 0 == ( con -> conf . force_lowercase_filenames ? strncasecmp ( uri_ptr , ds -> key -> ptr , alias_len ) : strncmp ( uri_ptr , ds -> key -> ptr , alias_len ) ) ) { <S2SV_StartBug> buffer_copy_buffer ( con -> physical . basedir , ds -> value ) ; <S2SV_EndBug> buffer_copy_buffer ( srv -> tmp_buf , ds -> value ) ; buffer_append_string ( srv -> tmp_buf , uri_ptr + alias_len ) ; buffer_copy_buffer ( con -> physical . path , srv -> tmp_buf ) ; return HANDLER_GO_ON ; } } return HANDLER_GO_ON ; }\n","target":"<S2SV_ModStart> ) ) { if ( uri_ptr [ alias_len ] == '.' ) { char * s = uri_ptr + alias_len + 1 ; if ( * s == '.' ) ++ s ; if ( * s == '/' || * s == '\\\\0' ) { size_t vlen = buffer_string_length ( ds -> value ) ; if ( 0 != alias_len && ds -> key -> ptr [ alias_len - 1 ] != '/' && 0 != vlen && ds -> value -> ptr [ vlen - 1 ] == '/' ) { con -> http_status = 403 ; return HANDLER_FINISHED ; } } }\n","project_and_commit_id":"lighttpd@lighttpd1.4/2105dae0f9d7a964375ce681e53cb165375f84c1","cve_id":"CVE-2018-19052","original_address":"https://github.com/lighttpd/lighttpd1.4/commit/2105dae0f9d7a964375ce681e53cb165375f84c1","time":"2018-11-07T05:29Z"},
	{"Unnamed: 0":3347,"cwe_id":"CWE-200","source":"CWE-200 static void * __dma_alloc_coherent ( struct device * dev , size_t size , dma_addr_t * dma_handle , gfp_t flags , struct dma_attrs * attrs ) { if ( dev == NULL ) { WARN_ONCE ( 1 , \"Use<S2SV_blank>an<S2SV_blank>actual<S2SV_blank>device<S2SV_blank>structure<S2SV_blank>for<S2SV_blank>DMA<S2SV_blank>allocation\\\\n\" ) ; return NULL ; } if ( IS_ENABLED ( CONFIG_ZONE_DMA ) && dev -> coherent_dma_mask <= DMA_BIT_MASK ( 32 ) ) flags |= GFP_DMA ; if ( IS_ENABLED ( CONFIG_DMA_CMA ) && ( flags & __GFP_WAIT ) ) { struct page * page ; void * addr ; size = PAGE_ALIGN ( size ) ; page = dma_alloc_from_contiguous ( dev , size >> PAGE_SHIFT , get_order ( size ) ) ; if ( ! page ) return NULL ; * dma_handle = phys_to_dma ( dev , page_to_phys ( page ) ) ; addr = page_address ( page ) ; <S2SV_StartBug> if ( flags & __GFP_ZERO ) <S2SV_EndBug> memset ( addr , 0 , size ) ; return addr ; } else { return swiotlb_alloc_coherent ( dev , size , dma_handle , flags ) ; } }\n","target":"<S2SV_ModStart> page ) ; <S2SV_ModEnd> memset ( addr\n","project_and_commit_id":"torvalds@linux/6829e274a623187c24f7cfc0e3d35f25d087fcc5","cve_id":"CVE-2015-8950","original_address":"https://github.com/torvalds/linux/commit/6829e274a623187c24f7cfc0e3d35f25d087fcc5","time":"2016-10-10T10:59Z"},
	{"Unnamed: 0":5332,"cwe_id":"CWE-415","source":"CWE-415 void gdImageWBMPCtx ( gdImagePtr image , int fg , gdIOCtx * out ) { <S2SV_StartBug> int x , y , pos ; <S2SV_EndBug> Wbmp * wbmp ; if ( ( wbmp = createwbmp ( gdImageSX ( image ) , gdImageSY ( image ) , WBMP_WHITE ) ) == NULL ) { gd_error ( \"Could<S2SV_blank>not<S2SV_blank>create<S2SV_blank>WBMP\" ) ; return ; } pos = 0 ; for ( y = 0 ; y < gdImageSY ( image ) ; y ++ ) { for ( x = 0 ; x < gdImageSX ( image ) ; x ++ ) { <S2SV_StartBug> if ( gdImageGetPixel ( image , x , y ) == fg ) { <S2SV_EndBug> wbmp -> bitmap [ pos ] = WBMP_BLACK ; } pos ++ ; } } if ( writewbmp ( wbmp , & gd_putout , out ) ) { gd_error ( \"Could<S2SV_blank>not<S2SV_blank>save<S2SV_blank>WBMP\" ) ; } freewbmp ( wbmp ) ; }\n","target":"<S2SV_ModStart> out ) { _gdImageWBMPCtx <S2SV_ModEnd> ( image , <S2SV_ModStart> ( image , fg , out <S2SV_ModEnd> ) ; }\n","project_and_commit_id":"php@php-src/089f7c0bc28d399b0420aa6ef058e4c1c120b2ae","cve_id":"CVE-2019-6978","original_address":"https://github.com/php/php-src/commit/089f7c0bc28d399b0420aa6ef058e4c1c120b2ae","time":"2019-01-28T08:29Z"},
	{"Unnamed: 0":3388,"cwe_id":"CWE-119","source":"CWE-119 static void process_tree ( struct rev_info * revs , struct tree * tree , show_object_fn show , struct strbuf * base , const char * name , void * cb_data ) { struct object * obj = & tree -> object ; struct tree_desc desc ; struct name_entry entry ; enum interesting match = revs -> diffopt . pathspec . nr == 0 ? all_entries_interesting : entry_not_interesting ; int baselen = base -> len ; if ( ! revs -> tree_objects ) return ; if ( ! obj ) die ( \"bad<S2SV_blank>tree<S2SV_blank>object\" ) ; if ( obj -> flags & ( UNINTERESTING | SEEN ) ) return ; if ( parse_tree_gently ( tree , revs -> ignore_missing_links ) < 0 ) { if ( revs -> ignore_missing_links ) return ; die ( \"bad<S2SV_blank>tree<S2SV_blank>object<S2SV_blank>%s\" , oid_to_hex ( & obj -> oid ) ) ; } obj -> flags |= SEEN ; <S2SV_StartBug> show ( obj , base , name , cb_data ) ; <S2SV_EndBug> strbuf_addstr ( base , name ) ; if ( base -> len ) strbuf_addch ( base , '/' ) ; init_tree_desc ( & desc , tree -> buffer , tree -> size ) ; while ( tree_entry ( & desc , & entry ) ) { if ( match != all_entries_interesting ) { match = tree_entry_interesting ( & entry , base , 0 , & revs -> diffopt . pathspec ) ; if ( match == all_entries_not_interesting ) break ; if ( match == entry_not_interesting ) continue ; } if ( S_ISDIR ( entry . mode ) ) process_tree ( revs , lookup_tree ( entry . sha1 ) , show , base , entry . path , cb_data ) ; else if ( S_ISGITLINK ( entry . mode ) ) process_gitlink ( revs , entry . sha1 , show , base , entry . path , cb_data ) ; else process_blob ( revs , lookup_blob ( entry . sha1 ) , show , base , entry . path , cb_data ) ; } strbuf_setlen ( base , baselen ) ; free_tree_buffer ( tree ) ; }\n","target":"<S2SV_ModStart> |= SEEN ; strbuf_addstr ( base , name ) ; <S2SV_ModStart> obj , base -> buf , cb_data <S2SV_ModEnd> ) ; if\n","project_and_commit_id":"git@git/de1e67d0703894cb6ea782e36abb63976ab07e60","cve_id":"CVE-2016-2315","original_address":"https://github.com/git/git/commit/de1e67d0703894cb6ea782e36abb63976ab07e60","time":"2016-04-08T14:59Z"},
	{"Unnamed: 0":6464,"cwe_id":"CWE-119","source":"CWE-119 static inline int check_entry_size_and_hooks ( struct arpt_entry * e , struct xt_table_info * newinfo , const unsigned char * base , const unsigned char * limit , const unsigned int * hook_entries , const unsigned int * underflows , unsigned int valid_hooks ) { unsigned int h ; int err ; if ( ( unsigned long ) e % __alignof__ ( struct arpt_entry ) != 0 || <S2SV_StartBug> ( unsigned char * ) e + sizeof ( struct arpt_entry ) >= limit ) { <S2SV_EndBug> duprintf ( \"Bad<S2SV_blank>offset<S2SV_blank>%p\\\\n\" , e ) ; return - EINVAL ; } if ( e -> next_offset < sizeof ( struct arpt_entry ) + sizeof ( struct xt_entry_target ) ) { duprintf ( \"checking:<S2SV_blank>element<S2SV_blank>%p<S2SV_blank>size<S2SV_blank>%u\\\\n\" , e , e -> next_offset ) ; return - EINVAL ; } err = check_entry ( e ) ; if ( err ) return err ; for ( h = 0 ; h < NF_ARP_NUMHOOKS ; h ++ ) { if ( ! ( valid_hooks & ( 1 << h ) ) ) continue ; if ( ( unsigned char * ) e - base == hook_entries [ h ] ) newinfo -> hook_entry [ h ] = hook_entries [ h ] ; if ( ( unsigned char * ) e - base == underflows [ h ] ) { if ( ! check_underflow ( e ) ) { pr_err ( \"Underflows<S2SV_blank>must<S2SV_blank>be<S2SV_blank>unconditional<S2SV_blank>and<S2SV_blank>\" \"use<S2SV_blank>the<S2SV_blank>STANDARD<S2SV_blank>target<S2SV_blank>with<S2SV_blank>\" \"ACCEPT/DROP\\\\n\" ) ; return - EINVAL ; } newinfo -> underflow [ h ] = underflows [ h ] ; } } e -> counters = ( ( struct xt_counters ) { 0 , 0 } ) ; e -> comefrom = 0 ; return 0 ; }\n","target":"<S2SV_ModStart> arpt_entry ) >= limit || ( unsigned char * ) e + e -> next_offset >\n","project_and_commit_id":"torvalds@linux/6e94e0cfb0887e4013b3b930fa6ab1fe6bb6ba91","cve_id":"CVE-2016-4998","original_address":"https://github.com/torvalds/linux/commit/6e94e0cfb0887e4013b3b930fa6ab1fe6bb6ba91","time":"2016-07-03T21:59Z"},
	{"Unnamed: 0":1638,"cwe_id":"CWE-119","source":"CWE-119 int read_file ( struct sc_card * card , char * str_path , unsigned char * * data , size_t * data_len ) { struct sc_path path ; struct sc_file * file ; unsigned char * p ; int ok = 0 ; int r ; size_t len ; sc_format_path ( str_path , & path ) ; if ( SC_SUCCESS != sc_select_file ( card , & path , & file ) ) { goto err ; } <S2SV_StartBug> len = file ? file -> size : 4096 ; <S2SV_EndBug> p = realloc ( * data , len ) ; if ( ! p ) { goto err ; } * data = p ; * data_len = len ; r = sc_read_binary ( card , 0 , p , len , 0 ) ; if ( r < 0 ) goto err ; * data_len = r ; ok = 1 ; err : sc_file_free ( file ) ; return ok ; }\n","target":"<S2SV_ModStart> len = file && file -> size > 0\n","project_and_commit_id":"OpenSC@OpenSC/360e95d45ac4123255a4c796db96337f332160ad","cve_id":"CVE-2018-16391","original_address":"https://github.com/OpenSC/OpenSC/commit/360e95d45ac4123255a4c796db96337f332160ad#diff-477b7a40136bb418b10ce271c8664536","time":"2018-09-03T14:29Z"},
	{"Unnamed: 0":3218,"cwe_id":"CWE-189","source":"CWE-189 static ssize_t __nfs4_get_acl_uncached ( struct inode * inode , void * buf , size_t buflen ) { struct page * pages [ NFS4ACL_MAXPAGES ] = { NULL , } ; struct nfs_getaclargs args = { . fh = NFS_FH ( inode ) , . acl_pages = pages , . acl_len = buflen , } ; struct nfs_getaclres res = { . acl_len = buflen , } ; void * resp_buf ; struct rpc_message msg = { . rpc_proc = & nfs4_procedures [ NFSPROC4_CLNT_GETACL ] , . rpc_argp = & args , . rpc_resp = & res , } ; int ret = - ENOMEM , npages , i , acl_len = 0 ; npages = ( buflen + PAGE_SIZE - 1 ) >> PAGE_SHIFT ; if ( npages == 0 ) npages = 1 ; for ( i = 0 ; i < npages ; i ++ ) { pages [ i ] = alloc_page ( GFP_KERNEL ) ; if ( ! pages [ i ] ) goto out_free ; } if ( npages > 1 ) { res . acl_scratch = alloc_page ( GFP_KERNEL ) ; if ( ! res . acl_scratch ) goto out_free ; } args . acl_len = npages * PAGE_SIZE ; args . acl_pgbase = 0 ; if ( buf == NULL ) res . acl_flags |= NFS4_ACL_LEN_REQUEST ; resp_buf = page_address ( pages [ 0 ] ) ; dprintk ( \"%s<S2SV_blank><S2SV_blank>buf<S2SV_blank>%p<S2SV_blank>buflen<S2SV_blank>%zu<S2SV_blank>npages<S2SV_blank>%d<S2SV_blank>args.acl_len<S2SV_blank>%zu\\\\n\" , __func__ , buf , buflen , npages , args . acl_len ) ; ret = nfs4_call_sync ( NFS_SERVER ( inode ) -> client , NFS_SERVER ( inode ) , & msg , & args . seq_args , & res . seq_res , 0 ) ; if ( ret ) goto out_free ; acl_len = res . acl_len - res . acl_data_offset ; if ( acl_len > args . acl_len ) nfs4_write_cached_acl ( inode , NULL , acl_len ) ; else nfs4_write_cached_acl ( inode , resp_buf + res . acl_data_offset , acl_len ) ; if ( buf ) { ret = - ERANGE ; if ( acl_len > buflen ) goto out_free ; _copy_from_pages ( buf , pages , res . acl_data_offset , <S2SV_StartBug> res . acl_len ) ; <S2SV_EndBug> } ret = acl_len ; out_free : for ( i = 0 ; i < npages ; i ++ ) if ( pages [ i ] ) __free_page ( pages [ i ] ) ; if ( res . acl_scratch ) __free_page ( res . acl_scratch ) ; return ret ; }\n","target":"<S2SV_ModStart> . acl_data_offset , <S2SV_ModEnd> acl_len ) ;\n","project_and_commit_id":"torvalds@linux/20e0fa98b751facf9a1101edaefbc19c82616a68","cve_id":"CVE-2012-2375","original_address":"https://github.com/torvalds/linux/commit/20e0fa98b751facf9a1101edaefbc19c82616a68","time":"2012-06-13T10:24Z"},
	{"Unnamed: 0":3307,"cwe_id":"CWE-787","source":"CWE-787 <S2SV_StartBug> static void nsc_rle_decompress_data ( NSC_CONTEXT * context ) <S2SV_EndBug> { UINT16 i ; BYTE * rle ; UINT32 planeSize ; UINT32 originalSize ; <S2SV_StartBug> rle = context -> Planes ; <S2SV_EndBug> for ( i = 0 ; i < 4 ; i ++ ) { originalSize = context -> OrgByteCount [ i ] ; planeSize = context -> PlaneByteCount [ i ] ; if ( planeSize == 0 ) <S2SV_StartBug> FillMemory ( context -> priv -> PlaneBuffers [ i ] , originalSize , 0xFF ) ; <S2SV_EndBug> <S2SV_StartBug> else if ( planeSize < originalSize ) <S2SV_EndBug> <S2SV_StartBug> nsc_rle_decode ( rle , context -> priv -> PlaneBuffers [ i ] , originalSize ) ; <S2SV_EndBug> else CopyMemory ( context -> priv -> PlaneBuffers [ i ] , rle , originalSize ) ; <S2SV_StartBug> rle += planeSize ; <S2SV_EndBug> } <S2SV_StartBug> } <S2SV_EndBug>\n","target":"<S2SV_ModStart> <S2SV_null> <S2SV_null> static BOOL <S2SV_ModEnd> nsc_rle_decompress_data ( NSC_CONTEXT <S2SV_ModStart> UINT32 originalSize ; if ( ! context ) return FALSE ; <S2SV_ModStart> == 0 ) { if ( context -> priv -> PlaneBuffersLength < originalSize ) return FALSE ; <S2SV_ModStart> 0xFF ) ; } <S2SV_ModStart> < originalSize ) { if ( ! <S2SV_ModStart> i ] , context -> priv -> PlaneBuffersLength , originalSize ) ) return FALSE ; } else { if ( context -> priv -> PlaneBuffersLength < originalSize ) return FALSE ; <S2SV_ModEnd> CopyMemory ( context <S2SV_ModStart> originalSize ) ; } <S2SV_ModStart> planeSize ; } return TRUE ;\n","project_and_commit_id":"FreeRDP@FreeRDP/d1112c279bd1a327e8e4d0b5f371458bf2579659","cve_id":"CVE-2018-8788","original_address":"https://github.com/FreeRDP/FreeRDP/commit/d1112c279bd1a327e8e4d0b5f371458bf2579659","time":"2018-11-29T18:29Z"},
	{"Unnamed: 0":1870,"cwe_id":"CWE-125","source":"CWE-125 static void bgp_capabilities_print ( netdissect_options * ndo , const u_char * opt , int caps_len ) { int cap_type , cap_len , tcap_len , cap_offset ; int i = 0 ; while ( i < caps_len ) { ND_TCHECK2 ( opt [ i ] , BGP_CAP_HEADER_SIZE ) ; cap_type = opt [ i ] ; cap_len = opt [ i + 1 ] ; tcap_len = cap_len ; ND_PRINT ( ( ndo , \"\\\\n\\\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s<S2SV_blank>(%u),<S2SV_blank>length:<S2SV_blank>%u\" , tok2str ( bgp_capcode_values , \"Unknown\" , cap_type ) , cap_type , cap_len ) ) ; ND_TCHECK2 ( opt [ i + 2 ] , cap_len ) ; switch ( cap_type ) { case BGP_CAPCODE_MP : ND_PRINT ( ( ndo , \"\\\\n\\\\t\\\\tAFI<S2SV_blank>%s<S2SV_blank>(%u),<S2SV_blank>SAFI<S2SV_blank>%s<S2SV_blank>(%u)\" , tok2str ( af_values , \"Unknown\" , EXTRACT_16BITS ( opt + i + 2 ) ) , EXTRACT_16BITS ( opt + i + 2 ) , tok2str ( bgp_safi_values , \"Unknown\" , opt [ i + 5 ] ) , opt [ i + 5 ] ) ) ; break ; <S2SV_StartBug> case BGP_CAPCODE_RESTART : <S2SV_EndBug> ND_PRINT ( ( ndo , \"\\\\n\\\\t\\\\tRestart<S2SV_blank>Flags:<S2SV_blank>[%s],<S2SV_blank>Restart<S2SV_blank>Time<S2SV_blank>%us\" , ( ( opt [ i + 2 ] ) & 0x80 ) ? \"R\" : \"none\" , EXTRACT_16BITS ( opt + i + 2 ) & 0xfff ) ) ; tcap_len -= 2 ; cap_offset = 4 ; while ( tcap_len >= 4 ) { ND_PRINT ( ( ndo , \"\\\\n\\\\t\\\\t<S2SV_blank><S2SV_blank>AFI<S2SV_blank>%s<S2SV_blank>(%u),<S2SV_blank>SAFI<S2SV_blank>%s<S2SV_blank>(%u),<S2SV_blank>Forwarding<S2SV_blank>state<S2SV_blank>preserved:<S2SV_blank>%s\" , tok2str ( af_values , \"Unknown\" , EXTRACT_16BITS ( opt + i + cap_offset ) ) , EXTRACT_16BITS ( opt + i + cap_offset ) , tok2str ( bgp_safi_values , \"Unknown\" , opt [ i + cap_offset + 2 ] ) , opt [ i + cap_offset + 2 ] , ( ( opt [ i + cap_offset + 3 ] ) & 0x80 ) ? \"yes\" : \"no\" ) ) ; tcap_len -= 4 ; cap_offset += 4 ; } break ; case BGP_CAPCODE_RR : case BGP_CAPCODE_RR_CISCO : break ; case BGP_CAPCODE_AS_NEW : if ( cap_len == 4 ) { ND_PRINT ( ( ndo , \"\\\\n\\\\t\\\\t<S2SV_blank>4<S2SV_blank>Byte<S2SV_blank>AS<S2SV_blank>%s\" , as_printf ( ndo , astostr , sizeof ( astostr ) , EXTRACT_32BITS ( opt + i + 2 ) ) ) ) ; } break ; case BGP_CAPCODE_ADD_PATH : cap_offset = 2 ; if ( tcap_len == 0 ) { ND_PRINT ( ( ndo , \"<S2SV_blank>(bogus)\" ) ) ; break ; } while ( tcap_len > 0 ) { if ( tcap_len < 4 ) { ND_PRINT ( ( ndo , \"\\\\n\\\\t\\\\t(invalid)\" ) ) ; break ; } ND_PRINT ( ( ndo , \"\\\\n\\\\t\\\\tAFI<S2SV_blank>%s<S2SV_blank>(%u),<S2SV_blank>SAFI<S2SV_blank>%s<S2SV_blank>(%u),<S2SV_blank>Send/Receive:<S2SV_blank>%s\" , tok2str ( af_values , \"Unknown\" , EXTRACT_16BITS ( opt + i + cap_offset ) ) , EXTRACT_16BITS ( opt + i + cap_offset ) , tok2str ( bgp_safi_values , \"Unknown\" , opt [ i + cap_offset + 2 ] ) , opt [ i + cap_offset + 2 ] , tok2str ( bgp_add_path_recvsend , \"Bogus<S2SV_blank>(0x%02x)\" , opt [ i + cap_offset + 3 ] ) ) ) ; tcap_len -= 4 ; cap_offset += 4 ; } break ; default : ND_PRINT ( ( ndo , \"\\\\n\\\\t\\\\tno<S2SV_blank>decoder<S2SV_blank>for<S2SV_blank>Capability<S2SV_blank>%u\" , cap_type ) ) ; if ( ndo -> ndo_vflag <= 1 ) print_unknown_data ( ndo , & opt [ i + 2 ] , \"\\\\n\\\\t\\\\t\" , cap_len ) ; break ; } if ( ndo -> ndo_vflag > 1 && cap_len > 0 ) { print_unknown_data ( ndo , & opt [ i + 2 ] , \"\\\\n\\\\t\\\\t\" , cap_len ) ; } i += BGP_CAP_HEADER_SIZE + cap_len ; } return ; trunc : ND_PRINT ( ( ndo , \"[|BGP]\" ) ) ; }\n","target":"<S2SV_ModStart> case BGP_CAPCODE_RESTART : ND_TCHECK_16BITS ( opt + i + 2 ) ;\n","project_and_commit_id":"the-tcpdump-group@tcpdump/86326e880d31b328a151d45348c35220baa9a1ff","cve_id":"CVE-2018-14881","original_address":"https://github.com/the-tcpdump-group/tcpdump/commit/86326e880d31b328a151d45348c35220baa9a1ff","time":"2019-10-03T16:15Z"},
	{"Unnamed: 0":3871,"cwe_id":"CWE-20","source":"CWE-20 void ftpServerProcessList ( FtpClientConnection * connection , char_t * param ) { error_t error ; uint_t perm ; if ( ! connection -> userLoggedIn ) { osStrcpy ( connection -> response , \"530<S2SV_blank>Not<S2SV_blank>logged<S2SV_blank>in\\\\r\\\\n\" ) ; return ; } while ( * param == '-' ) { while ( * param != '<S2SV_blank>' && * param != '\\\\0' ) <S2SV_StartBug> param ++ ; <S2SV_EndBug> <S2SV_StartBug> while ( * param == '<S2SV_blank>' ) <S2SV_EndBug> <S2SV_StartBug> param ++ ; <S2SV_EndBug> } if ( * param == '\\\\0' ) { osStrcpy ( connection -> path , connection -> currentDir ) ; } else { error = ftpServerGetPath ( connection , param , connection -> path , FTP_SERVER_MAX_PATH_LEN ) ; if ( error ) { osStrcpy ( connection -> response , \"501<S2SV_blank>Invalid<S2SV_blank>parameter\\\\r\\\\n\" ) ; return ; } } perm = ftpServerGetFilePermissions ( connection , connection -> path ) ; if ( ( perm & FTP_FILE_PERM_READ ) == 0 ) { osStrcpy ( connection -> response , \"550<S2SV_blank>Access<S2SV_blank>denied\\\\r\\\\n\" ) ; return ; } connection -> dir = fsOpenDir ( connection -> path ) ; if ( ! connection -> dir ) { osStrcpy ( connection -> response , \"550<S2SV_blank>Directory<S2SV_blank>not<S2SV_blank>found\\\\r\\\\n\" ) ; return ; } if ( connection -> passiveMode ) { if ( connection -> dataChannel . state == FTP_CHANNEL_STATE_IDLE ) connection -> dataChannel . state = FTP_CHANNEL_STATE_SEND ; } else { error = ftpServerOpenDataChannel ( connection ) ; if ( error ) { fsCloseDir ( connection -> dir ) ; osStrcpy ( connection -> response , \"450<S2SV_blank>Can\\'t<S2SV_blank>open<S2SV_blank>data<S2SV_blank>connection\\\\r\\\\n\" ) ; return ; } connection -> dataChannel . state = FTP_CHANNEL_STATE_SEND ; } connection -> bufferLength = 0 ; connection -> bufferPos = 0 ; connection -> controlChannel . state = FTP_CHANNEL_STATE_LIST ; osStrcpy ( connection -> response , \"150<S2SV_blank>Opening<S2SV_blank>data<S2SV_blank>connection\\\\r\\\\n\" ) ; }\n","target":"<S2SV_ModStart> != '\\\\0' ) { <S2SV_ModStart> param ++ ; } <S2SV_ModStart> == '<S2SV_blank>' ) { <S2SV_ModStart> param ++ ; }\n","project_and_commit_id":"Oryx-Embedded@CycloneTCP/de5336016edbe1e90327d0ed1cba5c4e49114366","cve_id":"CVE-2021-26788","original_address":"https://github.com/Oryx-Embedded/CycloneTCP/commit/de5336016edbe1e90327d0ed1cba5c4e49114366","time":"2021-03-08T13:15Z"},
	{"Unnamed: 0":2884,"cwe_id":"CWE-20","source":"CWE-20 static int flashsv_decode_frame ( AVCodecContext * avctx , void * data , int * got_frame , AVPacket * avpkt ) { int buf_size = avpkt -> size ; FlashSVContext * s = avctx -> priv_data ; int h_blocks , v_blocks , h_part , v_part , i , j , ret ; GetBitContext gb ; int last_blockwidth = s -> block_width ; int last_blockheight = s -> block_height ; if ( buf_size == 0 ) return 0 ; if ( buf_size < 4 ) return - 1 ; init_get_bits ( & gb , avpkt -> data , buf_size * 8 ) ; s -> block_width = 16 * ( get_bits ( & gb , 4 ) + 1 ) ; s -> image_width = get_bits ( & gb , 12 ) ; s -> block_height = 16 * ( get_bits ( & gb , 4 ) + 1 ) ; s -> image_height = get_bits ( & gb , 12 ) ; if ( last_blockwidth != s -> block_width || last_blockheight != s -> block_height ) av_freep ( & s -> blocks ) ; if ( s -> ver == 2 ) { skip_bits ( & gb , 6 ) ; if ( get_bits1 ( & gb ) ) { avpriv_request_sample ( avctx , \"iframe\" ) ; return AVERROR_PATCHWELCOME ; } if ( get_bits1 ( & gb ) ) { avpriv_request_sample ( avctx , \"Custom<S2SV_blank>palette\" ) ; return AVERROR_PATCHWELCOME ; } } h_blocks = s -> image_width / s -> block_width ; h_part = s -> image_width % s -> block_width ; v_blocks = s -> image_height / s -> block_height ; v_part = s -> image_height % s -> block_height ; if ( s -> block_size < s -> block_width * s -> block_height ) { int tmpblock_size = 3 * s -> block_width * s -> block_height ; s -> tmpblock = av_realloc ( s -> tmpblock , tmpblock_size ) ; if ( ! s -> tmpblock ) { av_log ( avctx , AV_LOG_ERROR , \"Can\\'t<S2SV_blank>allocate<S2SV_blank>decompression<S2SV_blank>buffer.\\\\n\" ) ; return AVERROR ( ENOMEM ) ; } if ( s -> ver == 2 ) { s -> deflate_block_size = calc_deflate_block_size ( tmpblock_size ) ; if ( s -> deflate_block_size <= 0 ) { av_log ( avctx , AV_LOG_ERROR , \"Can\\'t<S2SV_blank>determine<S2SV_blank>deflate<S2SV_blank>buffer<S2SV_blank>size.\\\\n\" ) ; return - 1 ; } s -> deflate_block = av_realloc ( s -> deflate_block , s -> deflate_block_size ) ; if ( ! s -> deflate_block ) { av_log ( avctx , AV_LOG_ERROR , \"Can\\'t<S2SV_blank>allocate<S2SV_blank>deflate<S2SV_blank>buffer.\\\\n\" ) ; return AVERROR ( ENOMEM ) ; } } } s -> block_size = s -> block_width * s -> block_height ; if ( avctx -> width == 0 && avctx -> height == 0 ) { avcodec_set_dimensions ( avctx , s -> image_width , s -> image_height ) ; } if ( avctx -> width != s -> image_width || avctx -> height != s -> image_height ) { av_log ( avctx , AV_LOG_ERROR , \"Frame<S2SV_blank>width<S2SV_blank>or<S2SV_blank>height<S2SV_blank>differs<S2SV_blank>from<S2SV_blank>first<S2SV_blank>frame!\\\\n\" ) ; av_log ( avctx , AV_LOG_ERROR , \"fh<S2SV_blank>=<S2SV_blank>%d,<S2SV_blank>fv<S2SV_blank>%d<S2SV_blank><S2SV_blank>vs<S2SV_blank><S2SV_blank>ch<S2SV_blank>=<S2SV_blank>%d,<S2SV_blank>cv<S2SV_blank>=<S2SV_blank>%d\\\\n\" , avctx -> height , avctx -> width , s -> image_height , s -> image_width ) ; return AVERROR_INVALIDDATA ; } s -> is_keyframe = ( avpkt -> flags & AV_PKT_FLAG_KEY ) && ( s -> ver == 2 ) ; if ( s -> is_keyframe ) { s -> keyframedata = av_realloc ( s -> keyframedata , avpkt -> size ) ; memcpy ( s -> keyframedata , avpkt -> data , avpkt -> size ) ; } if ( s -> ver == 2 && ! s -> blocks ) s -> blocks = av_mallocz ( ( v_blocks + ! ! v_part ) * ( h_blocks + ! ! h_part ) * sizeof ( s -> blocks [ 0 ] ) ) ; av_dlog ( avctx , \"image:<S2SV_blank>%dx%d<S2SV_blank>block:<S2SV_blank>%dx%d<S2SV_blank>num:<S2SV_blank>%dx%d<S2SV_blank>part:<S2SV_blank>%dx%d\\\\n\" , s -> image_width , s -> image_height , s -> block_width , s -> block_height , h_blocks , v_blocks , h_part , v_part ) ; if ( ( ret = ff_reget_buffer ( avctx , & s -> frame ) ) < 0 ) return ret ; for ( j = 0 ; j < v_blocks + ( v_part ? 1 : 0 ) ; j ++ ) { int y_pos = j * s -> block_height ; int cur_blk_height = ( j < v_blocks ) ? s -> block_height : v_part ; for ( i = 0 ; i < h_blocks + ( h_part ? 1 : 0 ) ; i ++ ) { int x_pos = i * s -> block_width ; int cur_blk_width = ( i < h_blocks ) ? s -> block_width : h_part ; int has_diff = 0 ; int size = get_bits ( & gb , 16 ) ; s -> color_depth = 0 ; s -> zlibprime_curr = 0 ; s -> zlibprime_prev = 0 ; s -> diff_start = 0 ; s -> diff_height = cur_blk_height ; if ( 8 * size > get_bits_left ( & gb ) ) { av_frame_unref ( & s -> frame ) ; return AVERROR_INVALIDDATA ; } if ( s -> ver == 2 && size ) { skip_bits ( & gb , 3 ) ; s -> color_depth = get_bits ( & gb , 2 ) ; has_diff = get_bits1 ( & gb ) ; s -> zlibprime_curr = get_bits1 ( & gb ) ; s -> zlibprime_prev = get_bits1 ( & gb ) ; if ( s -> color_depth != 0 && s -> color_depth != 2 ) { av_log ( avctx , AV_LOG_ERROR , \"%dx%d<S2SV_blank>invalid<S2SV_blank>color<S2SV_blank>depth<S2SV_blank>%d\\\\n\" , i , j , s -> color_depth ) ; return AVERROR_INVALIDDATA ; } if ( has_diff ) { if ( ! s -> keyframe ) { av_log ( avctx , AV_LOG_ERROR , \"inter<S2SV_blank>frame<S2SV_blank>without<S2SV_blank>keyframe\\\\n\" ) ; return AVERROR_INVALIDDATA ; } s -> diff_start = get_bits ( & gb , 8 ) ; s -> diff_height = get_bits ( & gb , 8 ) ; <S2SV_StartBug> av_log ( avctx , AV_LOG_DEBUG , <S2SV_EndBug> \"%dx%d<S2SV_blank>diff<S2SV_blank>start<S2SV_blank>%d<S2SV_blank>height<S2SV_blank>%d\\\\n\" , i , j , s -> diff_start , s -> diff_height ) ; size -= 2 ; } if ( s -> zlibprime_prev ) av_log ( avctx , AV_LOG_DEBUG , \"%dx%d<S2SV_blank>zlibprime_prev\\\\n\" , i , j ) ; if ( s -> zlibprime_curr ) { int col = get_bits ( & gb , 8 ) ; int row = get_bits ( & gb , 8 ) ; av_log ( avctx , AV_LOG_DEBUG , \"%dx%d<S2SV_blank>zlibprime_curr<S2SV_blank>%dx%d\\\\n\" , i , j , col , row ) ; size -= 2 ; avpriv_request_sample ( avctx , \"zlibprime_curr\" ) ; return AVERROR_PATCHWELCOME ; } if ( ! s -> blocks && ( s -> zlibprime_curr || s -> zlibprime_prev ) ) { av_log ( avctx , AV_LOG_ERROR , \"no<S2SV_blank>data<S2SV_blank>available<S2SV_blank>for<S2SV_blank>zlib<S2SV_blank>\" \"priming\\\\n\" ) ; return AVERROR_INVALIDDATA ; } size -- ; } if ( has_diff ) { int k ; int off = ( s -> image_height - y_pos - 1 ) * s -> frame . linesize [ 0 ] ; for ( k = 0 ; k < cur_blk_height ; k ++ ) memcpy ( s -> frame . data [ 0 ] + off - k * s -> frame . linesize [ 0 ] + x_pos * 3 , s -> keyframe + off - k * s -> frame . linesize [ 0 ] + x_pos * 3 , cur_blk_width * 3 ) ; } if ( size ) { if ( flashsv_decode_block ( avctx , avpkt , & gb , size , cur_blk_width , cur_blk_height , x_pos , y_pos , i + j * ( h_blocks + ! ! h_part ) ) ) av_log ( avctx , AV_LOG_ERROR , \"error<S2SV_blank>in<S2SV_blank>decompression<S2SV_blank>of<S2SV_blank>block<S2SV_blank>%dx%d\\\\n\" , i , j ) ; } } } if ( s -> is_keyframe && s -> ver == 2 ) { if ( ! s -> keyframe ) { s -> keyframe = av_malloc ( s -> frame . linesize [ 0 ] * avctx -> height ) ; if ( ! s -> keyframe ) { av_log ( avctx , AV_LOG_ERROR , \"Cannot<S2SV_blank>allocate<S2SV_blank>image<S2SV_blank>data\\\\n\" ) ; return AVERROR ( ENOMEM ) ; } } memcpy ( s -> keyframe , s -> frame . data [ 0 ] , s -> frame . linesize [ 0 ] * avctx -> height ) ; } if ( ( ret = av_frame_ref ( data , & s -> frame ) ) < 0 ) return ret ; * got_frame = 1 ; if ( ( get_bits_count ( & gb ) / 8 ) != buf_size ) av_log ( avctx , AV_LOG_ERROR , \"buffer<S2SV_blank>not<S2SV_blank>fully<S2SV_blank>consumed<S2SV_blank>(%d<S2SV_blank>!=<S2SV_blank>%d)\\\\n\" , buf_size , ( get_bits_count ( & gb ) / 8 ) ) ; return buf_size ; }\n","target":"<S2SV_ModStart> 8 ) ; if ( s -> diff_start + s -> diff_height > cur_blk_height ) { av_log ( avctx , AV_LOG_ERROR , \"Block<S2SV_blank>parameters<S2SV_blank>invalid\\\\n\" ) ; return AVERROR_INVALIDDATA ; }\n","project_and_commit_id":"FFmpeg@FFmpeg/880c73cd76109697447fbfbaa8e5ee5683309446","cve_id":"CVE-2013-7015","original_address":"https://github.com/FFmpeg/FFmpeg/commit/880c73cd76109697447fbfbaa8e5ee5683309446","time":"2013-12-09T16:36Z"},
	{"Unnamed: 0":3602,"cwe_id":"CWE-415","source":"CWE-415 static int amd_gpio_remove ( struct platform_device * pdev ) { struct amd_gpio * gpio_dev ; gpio_dev = platform_get_drvdata ( pdev ) ; gpiochip_remove ( & gpio_dev -> gc ) ; <S2SV_StartBug> pinctrl_unregister ( gpio_dev -> pctrl ) ; <S2SV_EndBug> return 0 ; }\n","target":"<S2SV_ModStart> gc ) ; <S2SV_ModEnd> return 0 ;\n","project_and_commit_id":"torvalds@linux/8dca4a41f1ad65043a78c2338d9725f859c8d2c3","cve_id":"CVE-2017-18174","original_address":"https://github.com/torvalds/linux/commit/8dca4a41f1ad65043a78c2338d9725f859c8d2c3","time":"2018-02-11T18:29Z"},
	{"Unnamed: 0":3825,"cwe_id":"CWE-20","source":"CWE-20 static int __ip6_append_data ( struct sock * sk , struct flowi6 * fl6 , struct sk_buff_head * queue , struct inet_cork * cork , struct inet6_cork * v6_cork , struct page_frag * pfrag , int getfrag ( void * from , char * to , int offset , int len , int odd , struct sk_buff * skb ) , void * from , int length , int transhdrlen , unsigned int flags , struct ipcm6_cookie * ipc6 , const struct sockcm_cookie * sockc ) { struct sk_buff * skb , * skb_prev = NULL ; unsigned int maxfraglen , fragheaderlen , mtu , orig_mtu ; int exthdrlen = 0 ; int dst_exthdrlen = 0 ; int hh_len ; int copy ; int err ; int offset = 0 ; __u8 tx_flags = 0 ; u32 tskey = 0 ; struct rt6_info * rt = ( struct rt6_info * ) cork -> dst ; struct ipv6_txoptions * opt = v6_cork -> opt ; int csummode = CHECKSUM_NONE ; unsigned int maxnonfragsize , headersize ; skb = skb_peek_tail ( queue ) ; if ( ! skb ) { exthdrlen = opt ? opt -> opt_flen : 0 ; dst_exthdrlen = rt -> dst . header_len - rt -> rt6i_nfheader_len ; } mtu = cork -> fragsize ; orig_mtu = mtu ; hh_len = LL_RESERVED_SPACE ( rt -> dst . dev ) ; fragheaderlen = sizeof ( struct ipv6hdr ) + rt -> rt6i_nfheader_len + ( opt ? opt -> opt_nflen : 0 ) ; maxfraglen = ( ( mtu - fragheaderlen ) & ~ 7 ) + fragheaderlen - sizeof ( struct frag_hdr ) ; headersize = sizeof ( struct ipv6hdr ) + ( opt ? opt -> opt_flen + opt -> opt_nflen : 0 ) + ( dst_allfrag ( & rt -> dst ) ? sizeof ( struct frag_hdr ) : 0 ) + rt -> rt6i_nfheader_len ; if ( cork -> length + length > mtu - headersize && ipc6 -> dontfrag && ( sk -> sk_protocol == IPPROTO_UDP || sk -> sk_protocol == IPPROTO_RAW ) ) { ipv6_local_rxpmtu ( sk , fl6 , mtu - headersize + sizeof ( struct ipv6hdr ) ) ; goto emsgsize ; } if ( ip6_sk_ignore_df ( sk ) ) maxnonfragsize = sizeof ( struct ipv6hdr ) + IPV6_MAXPLEN ; else maxnonfragsize = mtu ; if ( cork -> length + length > maxnonfragsize - headersize ) { emsgsize : ipv6_local_error ( sk , EMSGSIZE , fl6 , mtu - headersize + sizeof ( struct ipv6hdr ) ) ; return - EMSGSIZE ; } if ( transhdrlen && sk -> sk_protocol == IPPROTO_UDP && headersize == sizeof ( struct ipv6hdr ) && length <= mtu - headersize && ! ( flags & MSG_MORE ) && rt -> dst . dev -> features & ( NETIF_F_IPV6_CSUM | NETIF_F_HW_CSUM ) ) csummode = CHECKSUM_PARTIAL ; if ( sk -> sk_type == SOCK_DGRAM || sk -> sk_type == SOCK_RAW ) { sock_tx_timestamp ( sk , sockc -> tsflags , & tx_flags ) ; if ( tx_flags & SKBTX_ANY_SW_TSTAMP && sk -> sk_tsflags & SOF_TIMESTAMPING_OPT_ID ) tskey = sk -> sk_tskey ++ ; } cork -> length += length ; if ( ( ( ( length + fragheaderlen ) > mtu ) || ( skb && skb_is_gso ( skb ) ) ) && ( sk -> sk_protocol == IPPROTO_UDP ) && ( rt -> dst . dev -> features & NETIF_F_UFO ) && ! dst_xfrm ( & rt -> dst ) && ( sk -> sk_type == SOCK_DGRAM ) && ! udp_get_no_check6_tx ( sk ) ) { err = ip6_ufo_append_data ( sk , queue , getfrag , from , length , hh_len , fragheaderlen , exthdrlen , transhdrlen , mtu , flags , fl6 ) ; if ( err ) goto error ; return 0 ; } if ( ! skb ) goto alloc_new_skb ; while ( length > 0 ) { copy = ( cork -> length <= mtu && ! ( cork -> flags & IPCORK_ALLFRAG ) ? mtu : maxfraglen ) - skb -> len ; if ( copy < length ) copy = maxfraglen - skb -> len ; if ( copy <= 0 ) { char * data ; unsigned int datalen ; unsigned int fraglen ; unsigned int fraggap ; unsigned int alloclen ; alloc_new_skb : if ( skb ) fraggap = skb -> len - maxfraglen ; else fraggap = 0 ; if ( ! skb || ! skb_prev ) ip6_append_data_mtu ( & mtu , & maxfraglen , fragheaderlen , skb , rt , orig_mtu ) ; skb_prev = skb ; datalen = length + fraggap ; if ( datalen > ( cork -> length <= mtu && ! ( cork -> flags & IPCORK_ALLFRAG ) ? mtu : maxfraglen ) - fragheaderlen ) datalen = maxfraglen - fragheaderlen - rt -> dst . trailer_len ; if ( ( flags & MSG_MORE ) && ! ( rt -> dst . dev -> features & NETIF_F_SG ) ) alloclen = mtu ; else alloclen = datalen + fragheaderlen ; alloclen += dst_exthdrlen ; if ( datalen != length + fraggap ) { datalen += rt -> dst . trailer_len ; } alloclen += rt -> dst . trailer_len ; fraglen = datalen + fragheaderlen ; alloclen += sizeof ( struct frag_hdr ) ; <S2SV_StartBug> if ( transhdrlen ) { <S2SV_EndBug> skb = sock_alloc_send_skb ( sk , alloclen + hh_len , ( flags & MSG_DONTWAIT ) , & err ) ; } else { skb = NULL ; if ( atomic_read ( & sk -> sk_wmem_alloc ) <= 2 * sk -> sk_sndbuf ) skb = sock_wmalloc ( sk , alloclen + hh_len , 1 , sk -> sk_allocation ) ; if ( unlikely ( ! skb ) ) err = - ENOBUFS ; } if ( ! skb ) goto error ; skb -> protocol = htons ( ETH_P_IPV6 ) ; skb -> ip_summed = csummode ; skb -> csum = 0 ; skb_reserve ( skb , hh_len + sizeof ( struct frag_hdr ) + dst_exthdrlen ) ; skb_shinfo ( skb ) -> tx_flags = tx_flags ; tx_flags = 0 ; skb_shinfo ( skb ) -> tskey = tskey ; tskey = 0 ; data = skb_put ( skb , fraglen ) ; skb_set_network_header ( skb , exthdrlen ) ; data += fragheaderlen ; skb -> transport_header = ( skb -> network_header + fragheaderlen ) ; if ( fraggap ) { skb -> csum = skb_copy_and_csum_bits ( skb_prev , maxfraglen , data + transhdrlen , fraggap , 0 ) ; skb_prev -> csum = csum_sub ( skb_prev -> csum , skb -> csum ) ; data += fraggap ; pskb_trim_unique ( skb_prev , maxfraglen ) ; } <S2SV_StartBug> copy = datalen - transhdrlen - fraggap ; <S2SV_EndBug> if ( copy < 0 ) { err = - EINVAL ; kfree_skb ( skb ) ; goto error ; } else if ( copy > 0 && getfrag ( from , data + transhdrlen , offset , copy , fraggap , skb ) < 0 ) { err = - EFAULT ; kfree_skb ( skb ) ; goto error ; } offset += copy ; length -= datalen - fraggap ; transhdrlen = 0 ; exthdrlen = 0 ; dst_exthdrlen = 0 ; if ( ( flags & MSG_CONFIRM ) && ! skb_prev ) skb_set_dst_pending_confirm ( skb , 1 ) ; __skb_queue_tail ( queue , skb ) ; continue ; } if ( copy > length ) copy = length ; if ( ! ( rt -> dst . dev -> features & NETIF_F_SG ) ) { unsigned int off ; off = skb -> len ; if ( getfrag ( from , skb_put ( skb , copy ) , offset , copy , off , skb ) < 0 ) { __skb_trim ( skb , off ) ; err = - EFAULT ; goto error ; } } else { int i = skb_shinfo ( skb ) -> nr_frags ; err = - ENOMEM ; if ( ! sk_page_frag_refill ( sk , pfrag ) ) goto error ; if ( ! skb_can_coalesce ( skb , i , pfrag -> page , pfrag -> offset ) ) { err = - EMSGSIZE ; if ( i == MAX_SKB_FRAGS ) goto error ; __skb_fill_page_desc ( skb , i , pfrag -> page , pfrag -> offset , 0 ) ; skb_shinfo ( skb ) -> nr_frags = ++ i ; get_page ( pfrag -> page ) ; } copy = min_t ( int , copy , pfrag -> size - pfrag -> offset ) ; if ( getfrag ( from , page_address ( pfrag -> page ) + pfrag -> offset , offset , copy , skb -> len , skb ) < 0 ) goto error_efault ; pfrag -> offset += copy ; skb_frag_size_add ( & skb_shinfo ( skb ) -> frags [ i - 1 ] , copy ) ; skb -> len += copy ; skb -> data_len += copy ; skb -> truesize += copy ; atomic_add ( copy , & sk -> sk_wmem_alloc ) ; } offset += copy ; length -= copy ; } return 0 ; error_efault : err = - EFAULT ; error : cork -> length -= length ; IP6_INC_STATS ( sock_net ( sk ) , rt -> rt6i_idev , IPSTATS_MIB_OUTDISCARDS ) ; return err ; }\n","target":"<S2SV_ModStart> frag_hdr ) ; copy = datalen - transhdrlen - fraggap ; if ( copy < 0 ) { err = - EINVAL ; goto error ; } <S2SV_ModStart> ) ; } if ( copy > 0 && getfrag ( from , data + transhdrlen <S2SV_ModEnd> , offset ,\n","project_and_commit_id":"torvalds@linux/232cd35d0804cc241eb887bb8d4d9b3b9881c64a","cve_id":"CVE-2017-9242","original_address":"https://github.com/torvalds/linux/commit/232cd35d0804cc241eb887bb8d4d9b3b9881c64a","time":"2017-05-27T01:29Z"},
	{"Unnamed: 0":550,"cwe_id":"CWE-401","source":"CWE-401 int v3d_submit_cl_ioctl ( struct drm_device * dev , void * data , struct drm_file * file_priv ) { struct v3d_dev * v3d = to_v3d_dev ( dev ) ; struct v3d_file_priv * v3d_priv = file_priv -> driver_priv ; struct drm_v3d_submit_cl * args = data ; struct v3d_bin_job * bin = NULL ; struct v3d_render_job * render ; struct ww_acquire_ctx acquire_ctx ; int ret = 0 ; trace_v3d_submit_cl_ioctl ( & v3d -> drm , args -> rcl_start , args -> rcl_end ) ; if ( args -> pad != 0 ) { DRM_INFO ( \"pad<S2SV_blank>must<S2SV_blank>be<S2SV_blank>zero:<S2SV_blank>%d\\\\n\" , args -> pad ) ; return - EINVAL ; } render = kcalloc ( 1 , sizeof ( * render ) , GFP_KERNEL ) ; if ( ! render ) return - ENOMEM ; render -> start = args -> rcl_start ; render -> end = args -> rcl_end ; INIT_LIST_HEAD ( & render -> unref_list ) ; ret = v3d_job_init ( v3d , file_priv , & render -> base , v3d_render_job_free , args -> in_sync_rcl ) ; if ( ret ) { kfree ( render ) ; return ret ; } if ( args -> bcl_start != args -> bcl_end ) { bin = kcalloc ( 1 , sizeof ( * bin ) , GFP_KERNEL ) ; <S2SV_StartBug> if ( ! bin ) <S2SV_EndBug> return - ENOMEM ; <S2SV_StartBug> ret = v3d_job_init ( v3d , file_priv , & bin -> base , <S2SV_EndBug> v3d_job_free , args -> in_sync_bcl ) ; if ( ret ) { <S2SV_StartBug> v3d_job_put ( & render -> base ) ; <S2SV_EndBug> return ret ; } bin -> start = args -> bcl_start ; bin -> end = args -> bcl_end ; bin -> qma = args -> qma ; bin -> qms = args -> qms ; bin -> qts = args -> qts ; bin -> render = render ; } ret = v3d_lookup_bos ( dev , file_priv , & render -> base , args -> bo_handles , args -> bo_handle_count ) ; if ( ret ) goto fail ; ret = v3d_lock_bo_reservations ( & render -> base , & acquire_ctx ) ; if ( ret ) goto fail ; mutex_lock ( & v3d -> sched_lock ) ; if ( bin ) { ret = v3d_push_job ( v3d_priv , & bin -> base , V3D_BIN ) ; if ( ret ) goto fail_unreserve ; ret = drm_gem_fence_array_add ( & render -> base . deps , dma_fence_get ( bin -> base . done_fence ) ) ; if ( ret ) goto fail_unreserve ; } ret = v3d_push_job ( v3d_priv , & render -> base , V3D_RENDER ) ; if ( ret ) goto fail_unreserve ; mutex_unlock ( & v3d -> sched_lock ) ; v3d_attach_fences_and_unlock_reservation ( file_priv , & render -> base , & acquire_ctx , args -> out_sync , render -> base . done_fence ) ; if ( bin ) v3d_job_put ( & bin -> base ) ; v3d_job_put ( & render -> base ) ; return 0 ; fail_unreserve : mutex_unlock ( & v3d -> sched_lock ) ; drm_gem_unlock_reservations ( render -> base . bo , render -> base . bo_count , & acquire_ctx ) ; fail : if ( bin ) v3d_job_put ( & bin -> base ) ; v3d_job_put ( & render -> base ) ; return ret ; }\n","target":"<S2SV_ModStart> ! bin ) { v3d_job_put ( & render -> base ) ; <S2SV_ModStart> - ENOMEM ; } <S2SV_ModStart> render -> base ) ; kfree ( bin\n","project_and_commit_id":"torvalds@linux/29cd13cfd7624726d9e6becbae9aa419ef35af7f","cve_id":"CVE-2019-19044","original_address":"https://github.com/torvalds/linux/commit/29cd13cfd7624726d9e6becbae9aa419ef35af7f","time":"2019-11-18T06:15Z"},
	{"Unnamed: 0":4954,"cwe_id":"CWE-119","source":"CWE-119 bool f2fs_init_extent_tree ( struct inode * inode , struct f2fs_extent * i_ext ) { <S2SV_StartBug> struct f2fs_sb_info * sbi = F2FS_I_SB ( inode ) ; <S2SV_EndBug> struct extent_tree * et ; struct extent_node * en ; struct extent_info ei ; if ( ! f2fs_may_extent_tree ( inode ) ) { if ( i_ext && i_ext -> len ) { i_ext -> len = 0 ; return true ; } return false ; } et = __grab_extent_tree ( inode ) ; <S2SV_StartBug> if ( ! i_ext || ! i_ext -> len ) <S2SV_EndBug> return false ; get_extent_info ( & ei , i_ext ) ; write_lock ( & et -> lock ) ; if ( atomic_read ( & et -> node_cnt ) ) goto out ; en = __init_extent_tree ( sbi , et , & ei ) ; if ( en ) { spin_lock ( & sbi -> extent_lock ) ; list_add_tail ( & en -> list , & sbi -> extent_list ) ; spin_unlock ( & sbi -> extent_lock ) ; } out : write_unlock ( & et -> lock ) ; <S2SV_StartBug> return false ; <S2SV_EndBug> }\n","target":"<S2SV_ModStart> i_ext ) { bool ret = __f2fs_init_extent_tree ( inode , i_ext <S2SV_ModEnd> ) ; if <S2SV_ModStart> if ( ! F2FS_I ( inode ) -> extent_tree ) set_inode_flag ( inode , FI_NO_EXTENT <S2SV_ModEnd> ) ; return <S2SV_ModStart> ) ; return ret <S2SV_ModEnd> ; } <S2SV_null>\n","project_and_commit_id":"torvalds@linux/dad48e73127ba10279ea33e6dbc8d3905c4d31c0","cve_id":"CVE-2017-18193","original_address":"https://github.com/torvalds/linux/commit/dad48e73127ba10279ea33e6dbc8d3905c4d31c0","time":"2018-02-22T15:29Z"},
	{"Unnamed: 0":318,"cwe_id":"CWE-674","source":"CWE-674 void js_RegExp_prototype_exec ( js_State * J , js_Regexp * re , const char * text ) { <S2SV_StartBug> int i ; <S2SV_EndBug> int opts ; Resub m ; opts = 0 ; if ( re -> flags & JS_REGEXP_G ) { if ( re -> last > strlen ( text ) ) { re -> last = 0 ; js_pushnull ( J ) ; return ; } if ( re -> last > 0 ) { text += re -> last ; opts |= REG_NOTBOL ; } } <S2SV_StartBug> if ( ! js_regexec ( re -> prog , text , & m , opts ) ) { <S2SV_EndBug> js_newarray ( J ) ; js_pushstring ( J , text ) ; js_setproperty ( J , - 2 , \"input\" ) ; js_pushnumber ( J , js_utfptrtoidx ( text , m . sub [ 0 ] . sp ) ) ; js_setproperty ( J , - 2 , \"index\" ) ; for ( i = 0 ; i < m . nsub ; ++ i ) { js_pushlstring ( J , m . sub [ i ] . sp , m . sub [ i ] . ep - m . sub [ i ] . sp ) ; js_setindex ( J , - 2 , i ) ; } if ( re -> flags & JS_REGEXP_G ) re -> last = re -> last + ( m . sub [ 0 ] . ep - text ) ; return ; } if ( re -> flags & JS_REGEXP_G ) re -> last = 0 ; js_pushnull ( J ) ; }\n","target":"<S2SV_ModStart> ) { int result ; int <S2SV_ModStart> ; } } result = <S2SV_ModEnd> js_regexec ( re <S2SV_ModStart> , opts ) ; if ( result < 0 ) js_error ( J , \"regexec<S2SV_blank>failed\" ) ; if ( result == 0\n","project_and_commit_id":"ccxvii@mujs/00d4606c3baf813b7b1c176823b2729bf51002a2","cve_id":"CVE-2019-11413","original_address":"https://github.com/ccxvii/mujs/commit/00d4606c3baf813b7b1c176823b2729bf51002a2","time":"2019-04-22T11:29Z"},
	{"Unnamed: 0":4825,"cwe_id":"CWE-399","source":"CWE-399 protected struct magic_set * file_ms_alloc ( int flags ) { struct magic_set * ms ; size_t i , len ; if ( ( ms = CAST ( struct magic_set * , calloc ( ( size_t ) 1 , sizeof ( struct magic_set ) ) ) ) == NULL ) return NULL ; if ( magic_setflags ( ms , flags ) == - 1 ) { errno = EINVAL ; goto free ; } ms -> o . buf = ms -> o . pbuf = NULL ; len = ( ms -> c . len = 10 ) * sizeof ( * ms -> c . li ) ; if ( ( ms -> c . li = CAST ( struct level_info * , malloc ( len ) ) ) == NULL ) goto free ; ms -> event_flags = 0 ; ms -> error = - 1 ; for ( i = 0 ; i < MAGIC_SETS ; i ++ ) ms -> mlist [ i ] = NULL ; ms -> file = \"unknown\" ; ms -> line = 0 ; ms -> indir_max = FILE_INDIR_MAX ; ms -> name_max = FILE_NAME_MAX ; ms -> elf_shnum_max = FILE_ELF_SHNUM_MAX ; ms -> elf_phnum_max = FILE_ELF_PHNUM_MAX ; <S2SV_StartBug> return ms ; <S2SV_EndBug> free : free ( ms ) ; return NULL ; }\n","target":"<S2SV_ModStart> = FILE_ELF_PHNUM_MAX ; ms -> elf_notes_max = FILE_ELF_NOTES_MAX ;\n","project_and_commit_id":"file@file/ce90e05774dd77d86cfc8dfa6da57b32816841c4","cve_id":"CVE-2014-9620","original_address":"https://github.com/file/file/commit/ce90e05774dd77d86cfc8dfa6da57b32816841c4","time":"2015-01-21T18:59Z"},
	{"Unnamed: 0":2618,"cwe_id":"CWE-20","source":"CWE-20 static int rose_recvmsg ( struct kiocb * iocb , struct socket * sock , struct msghdr * msg , size_t size , int flags ) { struct sock * sk = sock -> sk ; <S2SV_StartBug> struct rose_sock * rose = rose_sk ( sk ) ; <S2SV_EndBug> struct sockaddr_rose * srose = ( struct sockaddr_rose * ) msg -> msg_name ; size_t copied ; unsigned char * asmptr ; struct sk_buff * skb ; int n , er , qbit ; if ( sk -> sk_state != TCP_ESTABLISHED ) return - ENOTCONN ; if ( ( skb = skb_recv_datagram ( sk , flags & ~ MSG_DONTWAIT , flags & MSG_DONTWAIT , & er ) ) == NULL ) return er ; qbit = ( skb -> data [ 0 ] & ROSE_Q_BIT ) == ROSE_Q_BIT ; skb_pull ( skb , ROSE_MIN_LEN ) ; if ( rose -> qbitincl ) { asmptr = skb_push ( skb , 1 ) ; * asmptr = qbit ; } skb_reset_transport_header ( skb ) ; copied = skb -> len ; if ( copied > size ) { copied = size ; msg -> msg_flags |= MSG_TRUNC ; } skb_copy_datagram_iovec ( skb , 0 , msg -> msg_iov , copied ) ; <S2SV_StartBug> if ( srose != NULL ) { <S2SV_EndBug> <S2SV_StartBug> memset ( srose , 0 , msg -> msg_namelen ) ; <S2SV_EndBug> srose -> srose_family = AF_ROSE ; srose -> srose_addr = rose -> dest_addr ; srose -> srose_call = rose -> dest_call ; srose -> srose_ndigis = rose -> dest_ndigis ; if ( msg -> msg_namelen >= sizeof ( struct full_sockaddr_rose ) ) { struct full_sockaddr_rose * full_srose = ( struct full_sockaddr_rose * ) msg -> msg_name ; for ( n = 0 ; n < rose -> dest_ndigis ; n ++ ) full_srose -> srose_digis [ n ] = rose -> dest_digis [ n ] ; msg -> msg_namelen = sizeof ( struct full_sockaddr_rose ) ; } else { if ( rose -> dest_ndigis >= 1 ) { srose -> srose_ndigis = 1 ; srose -> srose_digi = rose -> dest_digis [ 0 ] ; } msg -> msg_namelen = sizeof ( struct sockaddr_rose ) ; } } skb_free_datagram ( sk , skb ) ; return copied ; }\n","target":"<S2SV_ModStart> ( sk ) <S2SV_ModEnd> ; size_t copied <S2SV_ModStart> ; if ( msg -> msg_name ) { struct sockaddr_rose * srose ; memset ( msg -> msg_name <S2SV_ModEnd> , 0 , <S2SV_ModStart> , 0 , sizeof ( struct full_sockaddr_rose ) ) ; srose = msg -> msg_name <S2SV_ModEnd> ; srose ->\n","project_and_commit_id":"torvalds@linux/f3d3342602f8bcbf37d7c46641cb9bca7618eb1c","cve_id":"CVE-2013-7271","original_address":"https://github.com/torvalds/linux/commit/f3d3342602f8bcbf37d7c46641cb9bca7618eb1c","time":"2014-01-06T16:55Z"},
	{"Unnamed: 0":2159,"cwe_id":"CWE-400","source":"CWE-400 static void alpha_perf_event_irq_handler ( unsigned long la_ptr , struct pt_regs * regs ) { struct cpu_hw_events * cpuc ; struct perf_sample_data data ; struct perf_event * event ; struct hw_perf_event * hwc ; int idx , j ; __get_cpu_var ( irq_pmi_count ) ++ ; cpuc = & __get_cpu_var ( cpu_hw_events ) ; wrperfmon ( PERFMON_CMD_DISABLE , cpuc -> idx_mask ) ; if ( unlikely ( la_ptr >= alpha_pmu -> num_pmcs ) ) { irq_err_count ++ ; pr_warning ( \"PMI:<S2SV_blank>silly<S2SV_blank>index<S2SV_blank>%ld\\\\n\" , la_ptr ) ; wrperfmon ( PERFMON_CMD_ENABLE , cpuc -> idx_mask ) ; return ; } idx = la_ptr ; perf_sample_data_init ( & data , 0 ) ; for ( j = 0 ; j < cpuc -> n_events ; j ++ ) { if ( cpuc -> current_idx [ j ] == idx ) break ; } if ( unlikely ( j == cpuc -> n_events ) ) { wrperfmon ( PERFMON_CMD_ENABLE , cpuc -> idx_mask ) ; return ; } event = cpuc -> event [ j ] ; if ( unlikely ( ! event ) ) { irq_err_count ++ ; pr_warning ( \"PMI:<S2SV_blank>No<S2SV_blank>event<S2SV_blank>at<S2SV_blank>index<S2SV_blank>%d!\\\\n\" , idx ) ; wrperfmon ( PERFMON_CMD_ENABLE , cpuc -> idx_mask ) ; return ; } hwc = & event -> hw ; alpha_perf_event_update ( event , hwc , idx , alpha_pmu -> pmc_max_period [ idx ] + 1 ) ; data . period = event -> hw . last_period ; if ( alpha_perf_event_set_period ( event , hwc , idx ) ) { <S2SV_StartBug> if ( perf_event_overflow ( event , 1 , & data , regs ) ) { <S2SV_EndBug> alpha_pmu_stop ( event , 0 ) ; } } wrperfmon ( PERFMON_CMD_ENABLE , cpuc -> idx_mask ) ; return ; }\n","target":"<S2SV_ModStart> ( event , <S2SV_ModEnd> & data ,\n","project_and_commit_id":"torvalds@linux/a8b0ca17b80e92faab46ee7179ba9e99ccb61233","cve_id":"CVE-2011-2918","original_address":"https://github.com/torvalds/linux/commit/a8b0ca17b80e92faab46ee7179ba9e99ccb61233","time":"2012-05-24T23:55Z"},
	{"Unnamed: 0":4163,"cwe_id":"CWE-254","source":"CWE-254 IMPEG2D_ERROR_CODES_T impeg2d_dec_pic_ext_data ( dec_state_t * ps_dec ) { stream_t * ps_stream ; UWORD32 u4_start_code ; IMPEG2D_ERROR_CODES_T e_error ; e_error = ( IMPEG2D_ERROR_CODES_T ) IVD_ERROR_NONE ; ps_stream = & ps_dec -> s_bit_stream ; u4_start_code = impeg2d_bit_stream_nxt ( ps_stream , START_CODE_LEN ) ; while ( ( u4_start_code == EXTENSION_START_CODE || u4_start_code == USER_DATA_START_CODE ) && <S2SV_StartBug> ( IMPEG2D_ERROR_CODES_T ) IVD_ERROR_NONE == e_error ) <S2SV_EndBug> { if ( u4_start_code == USER_DATA_START_CODE ) { impeg2d_dec_user_data ( ps_dec ) ; } else { impeg2d_bit_stream_flush ( ps_stream , START_CODE_LEN ) ; u4_start_code = impeg2d_bit_stream_nxt ( ps_stream , EXT_ID_LEN ) ; switch ( u4_start_code ) { case QUANT_MATRIX_EXT_ID : impeg2d_dec_quant_matrix_ext ( ps_dec ) ; break ; case COPYRIGHT_EXT_ID : impeg2d_dec_copyright_ext ( ps_dec ) ; break ; case PIC_DISPLAY_EXT_ID : impeg2d_dec_pic_disp_ext ( ps_dec ) ; break ; case CAMERA_PARAM_EXT_ID : impeg2d_dec_cam_param_ext ( ps_dec ) ; break ; case ITU_T_EXT_ID : impeg2d_dec_itu_t_ext ( ps_dec ) ; break ; case PIC_SPATIAL_SCALABLE_EXT_ID : case PIC_TEMPORAL_SCALABLE_EXT_ID : e_error = IMPEG2D_SCALABLITY_NOT_SUP ; break ; default : impeg2d_bit_stream_flush ( ps_stream , EXT_ID_LEN ) ; impeg2d_next_start_code ( ps_dec ) ; break ; } } u4_start_code = impeg2d_bit_stream_nxt ( ps_stream , START_CODE_LEN ) ; } return e_error ; }\n","target":"<S2SV_ModStart> IVD_ERROR_NONE == e_error && ( ps_stream -> u4_offset < ps_stream -> u4_max_offset )\n","project_and_commit_id":"external@libmpeg2/ffab15eb80630dc799eb410855c93525b75233c3","cve_id":"CVE-2016-0824","original_address":"https://android.googlesource.com/platform/external/libmpeg2/+/ffab15eb80630dc799eb410855c93525b75233c3","time":"2016-03-12T21:59Z"},
	{"Unnamed: 0":4823,"cwe_id":"CWE-119","source":"CWE-119 static void initialize_encoder ( struct stream_state * stream , struct VpxEncoderConfig * global ) { int i ; int flags = 0 ; flags |= global -> show_psnr ? VPX_CODEC_USE_PSNR : 0 ; flags |= global -> out_part ? VPX_CODEC_USE_OUTPUT_PARTITION : 0 ; <S2SV_StartBug> vpx_codec_enc_init ( & stream -> encoder , global -> codec -> interface ( ) , <S2SV_EndBug> & stream -> config . cfg , flags ) ; ctx_exit_on_error ( & stream -> encoder , \"Failed<S2SV_blank>to<S2SV_blank>initialize<S2SV_blank>encoder\" ) ; for ( i = 0 ; i < stream -> config . arg_ctrl_cnt ; i ++ ) { int ctrl = stream -> config . arg_ctrls [ i ] [ 0 ] ; int value = stream -> config . arg_ctrls [ i ] [ 1 ] ; if ( vpx_codec_control_ ( & stream -> encoder , ctrl , value ) ) fprintf ( stderr , \"Error:<S2SV_blank>Tried<S2SV_blank>to<S2SV_blank>set<S2SV_blank>control<S2SV_blank>%d<S2SV_blank>=<S2SV_blank>%d\\\\n\" , ctrl , value ) ; ctx_exit_on_error ( & stream -> encoder , \"Failed<S2SV_blank>to<S2SV_blank>control<S2SV_blank>codec\" ) ; } # if CONFIG_DECODERS if ( global -> test_decode != TEST_DECODE_OFF ) { const VpxInterface * decoder = get_vpx_decoder_by_name ( global -> codec -> name ) ; <S2SV_StartBug> vpx_codec_dec_init ( & stream -> decoder , decoder -> interface ( ) , NULL , 0 ) ; <S2SV_EndBug> } # endif }\n","target":"<S2SV_ModStart> : 0 ; # if CONFIG_VP9_HIGHBITDEPTH flags |= stream -> config . use_16bit_internal ? VPX_CODEC_USE_HIGHBITDEPTH : 0 ; # endif <S2SV_ModStart> -> codec -> codec_interface <S2SV_ModEnd> ( ) , <S2SV_ModStart> , decoder -> codec_interface <S2SV_ModEnd> ( ) ,\n","project_and_commit_id":"external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426","cve_id":"CVE-2016-1621","original_address":"https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426","time":"2016-03-12T21:59Z"},
	{"Unnamed: 0":3956,"cwe_id":"CWE-476","source":"CWE-476 int ff_mpeg4_decode_picture_header ( Mpeg4DecContext * ctx , GetBitContext * gb ) { MpegEncContext * s = & ctx -> m ; unsigned startcode , v ; int ret ; int vol = 0 ; align_get_bits ( gb ) ; if ( ! s -> studio_profile && s -> avctx -> bits_per_raw_sample != 8 ) s -> avctx -> bits_per_raw_sample = 0 ; if ( s -> codec_tag == AV_RL32 ( \"WV1F\" ) && show_bits ( gb , 24 ) == 0x575630 ) { skip_bits ( gb , 24 ) ; if ( get_bits ( gb , 8 ) == 0xF0 ) goto end ; } startcode = 0xff ; for ( ; ; ) { if ( get_bits_count ( gb ) >= gb -> size_in_bits ) { if ( gb -> size_in_bits == 8 && ( ctx -> divx_version >= 0 || ctx -> xvid_build >= 0 ) || s -> codec_tag == AV_RL32 ( \"QMP4\" ) ) { av_log ( s -> avctx , AV_LOG_VERBOSE , \"frame<S2SV_blank>skip<S2SV_blank>%d\\\\n\" , gb -> size_in_bits ) ; return FRAME_SKIPPED ; } else return AVERROR_INVALIDDATA ; } v = get_bits ( gb , 8 ) ; startcode = ( ( startcode << 8 ) | v ) & 0xffffffff ; if ( ( startcode & 0xFFFFFF00 ) != 0x100 ) continue ; if ( s -> avctx -> debug & FF_DEBUG_STARTCODE ) { av_log ( s -> avctx , AV_LOG_DEBUG , \"startcode:<S2SV_blank>%3X<S2SV_blank>\" , startcode ) ; if ( startcode <= 0x11F ) av_log ( s -> avctx , AV_LOG_DEBUG , \"Video<S2SV_blank>Object<S2SV_blank>Start\" ) ; else if ( startcode <= 0x12F ) av_log ( s -> avctx , AV_LOG_DEBUG , \"Video<S2SV_blank>Object<S2SV_blank>Layer<S2SV_blank>Start\" ) ; else if ( startcode <= 0x13F ) av_log ( s -> avctx , AV_LOG_DEBUG , \"Reserved\" ) ; else if ( startcode <= 0x15F ) av_log ( s -> avctx , AV_LOG_DEBUG , \"FGS<S2SV_blank>bp<S2SV_blank>start\" ) ; else if ( startcode <= 0x1AF ) av_log ( s -> avctx , AV_LOG_DEBUG , \"Reserved\" ) ; else if ( startcode == 0x1B0 ) av_log ( s -> avctx , AV_LOG_DEBUG , \"Visual<S2SV_blank>Object<S2SV_blank>Seq<S2SV_blank>Start\" ) ; else if ( startcode == 0x1B1 ) av_log ( s -> avctx , AV_LOG_DEBUG , \"Visual<S2SV_blank>Object<S2SV_blank>Seq<S2SV_blank>End\" ) ; else if ( startcode == 0x1B2 ) av_log ( s -> avctx , AV_LOG_DEBUG , \"User<S2SV_blank>Data\" ) ; else if ( startcode == 0x1B3 ) av_log ( s -> avctx , AV_LOG_DEBUG , \"Group<S2SV_blank>of<S2SV_blank>VOP<S2SV_blank>start\" ) ; else if ( startcode == 0x1B4 ) av_log ( s -> avctx , AV_LOG_DEBUG , \"Video<S2SV_blank>Session<S2SV_blank>Error\" ) ; else if ( startcode == 0x1B5 ) av_log ( s -> avctx , AV_LOG_DEBUG , \"Visual<S2SV_blank>Object<S2SV_blank>Start\" ) ; else if ( startcode == 0x1B6 ) av_log ( s -> avctx , AV_LOG_DEBUG , \"Video<S2SV_blank>Object<S2SV_blank>Plane<S2SV_blank>start\" ) ; else if ( startcode == 0x1B7 ) av_log ( s -> avctx , AV_LOG_DEBUG , \"slice<S2SV_blank>start\" ) ; else if ( startcode == 0x1B8 ) av_log ( s -> avctx , AV_LOG_DEBUG , \"extension<S2SV_blank>start\" ) ; else if ( startcode == 0x1B9 ) av_log ( s -> avctx , AV_LOG_DEBUG , \"fgs<S2SV_blank>start\" ) ; else if ( startcode == 0x1BA ) av_log ( s -> avctx , AV_LOG_DEBUG , \"FBA<S2SV_blank>Object<S2SV_blank>start\" ) ; else if ( startcode == 0x1BB ) av_log ( s -> avctx , AV_LOG_DEBUG , \"FBA<S2SV_blank>Object<S2SV_blank>Plane<S2SV_blank>start\" ) ; else if ( startcode == 0x1BC ) av_log ( s -> avctx , AV_LOG_DEBUG , \"Mesh<S2SV_blank>Object<S2SV_blank>start\" ) ; else if ( startcode == 0x1BD ) av_log ( s -> avctx , AV_LOG_DEBUG , \"Mesh<S2SV_blank>Object<S2SV_blank>Plane<S2SV_blank>start\" ) ; else if ( startcode == 0x1BE ) av_log ( s -> avctx , AV_LOG_DEBUG , \"Still<S2SV_blank>Texture<S2SV_blank>Object<S2SV_blank>start\" ) ; else if ( startcode == 0x1BF ) av_log ( s -> avctx , AV_LOG_DEBUG , \"Texture<S2SV_blank>Spatial<S2SV_blank>Layer<S2SV_blank>start\" ) ; else if ( startcode == 0x1C0 ) av_log ( s -> avctx , AV_LOG_DEBUG , \"Texture<S2SV_blank>SNR<S2SV_blank>Layer<S2SV_blank>start\" ) ; else if ( startcode == 0x1C1 ) av_log ( s -> avctx , AV_LOG_DEBUG , \"Texture<S2SV_blank>Tile<S2SV_blank>start\" ) ; else if ( startcode == 0x1C2 ) av_log ( s -> avctx , AV_LOG_DEBUG , \"Texture<S2SV_blank>Shape<S2SV_blank>Layer<S2SV_blank>start\" ) ; else if ( startcode == 0x1C3 ) av_log ( s -> avctx , AV_LOG_DEBUG , \"stuffing<S2SV_blank>start\" ) ; else if ( startcode <= 0x1C5 ) av_log ( s -> avctx , AV_LOG_DEBUG , \"reserved\" ) ; else if ( startcode <= 0x1FF ) av_log ( s -> avctx , AV_LOG_DEBUG , \"System<S2SV_blank>start\" ) ; av_log ( s -> avctx , AV_LOG_DEBUG , \"<S2SV_blank>at<S2SV_blank>%d\\\\n\" , get_bits_count ( gb ) ) ; } if ( startcode >= 0x120 && startcode <= 0x12F ) { if ( vol ) { av_log ( s -> avctx , AV_LOG_WARNING , \"Ignoring<S2SV_blank>multiple<S2SV_blank>VOL<S2SV_blank>headers\\\\n\" ) ; continue ; } vol ++ ; if ( ( ret = decode_vol_header ( ctx , gb ) ) < 0 ) return ret ; } else if ( startcode == USER_DATA_STARTCODE ) { decode_user_data ( ctx , gb ) ; } else if ( startcode == GOP_STARTCODE ) { mpeg4_decode_gop_header ( s , gb ) ; } else if ( startcode == VOS_STARTCODE ) { <S2SV_StartBug> mpeg4_decode_profile_level ( s , gb ) ; <S2SV_EndBug> if ( s -> avctx -> profile == FF_PROFILE_MPEG4_SIMPLE_STUDIO && <S2SV_StartBug> ( s -> avctx -> level > 0 && s -> avctx -> level < 9 ) ) { <S2SV_EndBug> s -> studio_profile = 1 ; next_start_code_studio ( gb ) ; extension_and_user_data ( s , gb , 0 ) ; <S2SV_StartBug> } <S2SV_EndBug> } else if ( startcode == VISUAL_OBJ_STARTCODE ) { if ( s -> studio_profile ) { if ( ( ret = decode_studiovisualobject ( ctx , gb ) ) < 0 ) return ret ; } else mpeg4_decode_visual_object ( s , gb ) ; } else if ( startcode == VOP_STARTCODE ) { break ; } align_get_bits ( gb ) ; startcode = 0xff ; } end : if ( s -> avctx -> flags & AV_CODEC_FLAG_LOW_DELAY ) s -> low_delay = 1 ; s -> avctx -> has_b_frames = ! s -> low_delay ; if ( s -> studio_profile ) { <S2SV_StartBug> if ( ! s -> avctx -> bits_per_raw_sample ) { <S2SV_EndBug> av_log ( s -> avctx , AV_LOG_ERROR , \"Missing<S2SV_blank>VOL<S2SV_blank>header\\\\n\" ) ; return AVERROR_INVALIDDATA ; } return decode_studio_vop_header ( ctx , gb ) ; } else return decode_vop_header ( ctx , gb ) ; }\n","target":"<S2SV_ModStart> VOS_STARTCODE ) { int profile , level ; <S2SV_ModStart> s , gb , & profile , & level ) ; if ( <S2SV_ModEnd> profile == FF_PROFILE_MPEG4_SIMPLE_STUDIO <S2SV_ModStart> FF_PROFILE_MPEG4_SIMPLE_STUDIO && ( <S2SV_ModEnd> level > 0 <S2SV_ModStart> > 0 && <S2SV_ModEnd> level < 9 <S2SV_ModStart> ) ; } else if ( s -> studio_profile ) { avpriv_request_sample ( s -> avctx , \"Mixes<S2SV_blank>studio<S2SV_blank>and<S2SV_blank>non<S2SV_blank>studio<S2SV_blank>profile\\\\n\" ) ; return AVERROR_PATCHWELCOME ; } s -> avctx -> profile = profile ; s -> avctx -> level = level ; <S2SV_ModStart> studio_profile ) { av_assert0 ( s -> avctx -> profile == FF_PROFILE_MPEG4_SIMPLE_STUDIO ) ;\n","project_and_commit_id":"FFmpeg@FFmpeg/2aa9047486dbff12d9e040f917e5f799ed2fd78b","cve_id":"CVE-2018-13301","original_address":"https://github.com/FFmpeg/FFmpeg/commit/2aa9047486dbff12d9e040f917e5f799ed2fd78b","time":"2018-07-05T17:29Z"},
	{"Unnamed: 0":1759,"cwe_id":"CWE-119","source":"CWE-119 <S2SV_StartBug> static MB_PREDICTION_MODE read_inter_mode ( VP9_COMMON * cm , vp9_reader * r , <S2SV_EndBug> int ctx ) { <S2SV_StartBug> const int mode = vp9_read_tree ( r , vp9_inter_mode_tree , <S2SV_EndBug> <S2SV_StartBug> cm -> fc . inter_mode_probs [ ctx ] ) ; <S2SV_EndBug> <S2SV_StartBug> if ( ! cm -> frame_parallel_decoding_mode ) <S2SV_EndBug> ++ cm -> counts . inter_mode [ ctx ] [ mode ] ; return NEARESTMV + mode ; }\n","target":"<S2SV_ModStart> <S2SV_null> <S2SV_null> static PREDICTION_MODE <S2SV_ModEnd> read_inter_mode ( VP9_COMMON <S2SV_ModStart> * cm , MACROBLOCKD * xd , vpx_reader <S2SV_ModEnd> * r , <S2SV_ModStart> int mode = vpx_read_tree <S2SV_ModEnd> ( r , <S2SV_ModStart> cm -> fc -> <S2SV_ModEnd> inter_mode_probs [ ctx <S2SV_ModStart> ] ) ; FRAME_COUNTS * counts = xd -> counts ; if ( counts ) ++ counts -> <S2SV_ModEnd> inter_mode [ ctx\n","project_and_commit_id":"external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426","cve_id":"CVE-2016-1621","original_address":"https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426","time":"2016-03-12T21:59Z"},
	{"Unnamed: 0":1875,"cwe_id":"CWE-74","source":"CWE-74 int imap_exec ( struct ImapAccountData * adata , const char * cmdstr , ImapCmdFlags flags ) { int rc ; <S2SV_StartBug> rc = cmd_start ( adata , cmdstr , flags ) ; <S2SV_EndBug> if ( rc < 0 ) { cmd_handle_fatal ( adata ) ; return IMAP_EXEC_FATAL ; } if ( flags & IMAP_CMD_QUEUE ) return IMAP_EXEC_SUCCESS ; if ( ( flags & IMAP_CMD_POLL ) && ( C_ImapPollTimeout > 0 ) && ( ( mutt_socket_poll ( adata -> conn , C_ImapPollTimeout ) ) == 0 ) ) { mutt_error ( _ ( \"Connection<S2SV_blank>to<S2SV_blank>%s<S2SV_blank>timed<S2SV_blank>out\" ) , adata -> conn -> account . host ) ; cmd_handle_fatal ( adata ) ; return IMAP_EXEC_FATAL ; } mutt_sig_allow_interrupt ( true ) ; do { rc = imap_cmd_step ( adata ) ; <S2SV_StartBug> } while ( rc == IMAP_RES_CONTINUE ) ; <S2SV_EndBug> mutt_sig_allow_interrupt ( false ) ; if ( rc == IMAP_RES_NO ) return IMAP_EXEC_ERROR ; if ( rc != IMAP_RES_OK ) { if ( adata -> status != IMAP_FATAL ) return IMAP_EXEC_ERROR ; mutt_debug ( LL_DEBUG1 , \"command<S2SV_blank>failed:<S2SV_blank>%s\\\\n\" , adata -> buf ) ; return IMAP_EXEC_FATAL ; } return IMAP_EXEC_SUCCESS ; }\n","target":"<S2SV_ModStart> int rc ; if ( flags & IMAP_CMD_SINGLE ) { if ( adata -> nextcmd != adata -> lastcmd ) imap_exec ( adata , NULL , IMAP_CMD_POLL ) ; } <S2SV_ModStart> adata ) ; if ( ( flags & IMAP_CMD_SINGLE ) && ( adata -> nextcmd == adata -> lastcmd ) ) break ;\n","project_and_commit_id":"neomutt@neomutt/fb013ec666759cb8a9e294347c7b4c1f597639cc","cve_id":"CVE-2020-14954","original_address":"https://github.com/neomutt/neomutt/commit/fb013ec666759cb8a9e294347c7b4c1f597639cc","time":"2020-06-21T17:15Z"},
	{"Unnamed: 0":1098,"cwe_id":"CWE-787","source":"CWE-787 static int exif_data_load_data_entry ( ExifData * data , ExifEntry * entry , const unsigned char * d , unsigned int size , unsigned int offset ) { unsigned int s , doff ; entry -> tag = exif_get_short ( d + offset + 0 , data -> priv -> order ) ; entry -> format = exif_get_short ( d + offset + 2 , data -> priv -> order ) ; entry -> components = exif_get_long ( d + offset + 4 , data -> priv -> order ) ; exif_log ( data -> priv -> log , EXIF_LOG_CODE_DEBUG , \"ExifData\" , \"Loading<S2SV_blank>entry<S2SV_blank>0x%x<S2SV_blank>(\\'%s\\')...\" , entry -> tag , exif_tag_get_name ( entry -> tag ) ) ; s = exif_format_get_size ( entry -> format ) * entry -> components ; if ( ( s < entry -> components ) || ( s == 0 ) ) { return 0 ; } if ( s > 4 ) doff = exif_get_long ( d + offset + 8 , data -> priv -> order ) ; else doff = offset + 8 ; <S2SV_StartBug> if ( ( doff + s < doff ) || ( doff + s < s ) || ( doff + s > size ) ) { <S2SV_EndBug> exif_log ( data -> priv -> log , EXIF_LOG_CODE_DEBUG , \"ExifData\" , <S2SV_StartBug> \"Tag<S2SV_blank>data<S2SV_blank>past<S2SV_blank>end<S2SV_blank>of<S2SV_blank>buffer<S2SV_blank>(%u<S2SV_blank>><S2SV_blank>%u)\" , doff + s , size ) ; <S2SV_EndBug> return 0 ; } entry -> data = exif_data_alloc ( data , s ) ; if ( entry -> data ) { entry -> size = s ; memcpy ( entry -> data , d + doff , s ) ; } else { EXIF_LOG_NO_MEMORY ( data -> priv -> log , \"ExifData\" , s ) ; return 0 ; } if ( entry -> tag == EXIF_TAG_MAKER_NOTE ) { if ( ! entry -> data ) { exif_log ( data -> priv -> log , EXIF_LOG_CODE_DEBUG , \"ExifData\" , \"MakerNote<S2SV_blank>found<S2SV_blank>with<S2SV_blank>empty<S2SV_blank>data\" ) ; } else if ( entry -> size > 6 ) { exif_log ( data -> priv -> log , EXIF_LOG_CODE_DEBUG , \"ExifData\" , \"MakerNote<S2SV_blank>found<S2SV_blank>(%02x<S2SV_blank>%02x<S2SV_blank>%02x<S2SV_blank>%02x<S2SV_blank>\" \"%02x<S2SV_blank>%02x<S2SV_blank>%02x...).\" , entry -> data [ 0 ] , entry -> data [ 1 ] , entry -> data [ 2 ] , entry -> data [ 3 ] , entry -> data [ 4 ] , entry -> data [ 5 ] , entry -> data [ 6 ] ) ; } data -> priv -> offset_mnote = doff ; } return 1 ; }\n","target":"<S2SV_ModStart> ; if ( doff >= size ) { exif_log ( data -> priv -> log , EXIF_LOG_CODE_DEBUG , \"ExifData\" , \"Tag<S2SV_blank>starts<S2SV_blank>past<S2SV_blank>end<S2SV_blank>of<S2SV_blank>buffer<S2SV_blank>(%u<S2SV_blank>><S2SV_blank>%u)\" , doff , size ) ; return 0 ; } if ( <S2SV_ModEnd> s > size <S2SV_ModStart> s > size - doff <S2SV_ModEnd> ) { exif_log <S2SV_ModStart> , \"ExifData\" , \"Tag<S2SV_blank>data<S2SV_blank>goes<S2SV_blank>past<S2SV_blank>end<S2SV_blank>of<S2SV_blank>buffer<S2SV_blank>(%u<S2SV_blank>><S2SV_blank>%u)\" <S2SV_ModEnd> , doff +\n","project_and_commit_id":"libexif@libexif/75aa73267fdb1e0ebfbc00369e7312bac43d0566","cve_id":"CVE-2019-9278","original_address":"https://github.com/libexif/libexif/commit/75aa73267fdb1e0ebfbc00369e7312bac43d0566","time":"2019-09-27T19:15Z"},
	{"Unnamed: 0":1377,"cwe_id":"CWE-264","source":"CWE-264 static bool nested_vmx_exit_handled ( struct kvm_vcpu * vcpu ) { u32 intr_info = vmcs_read32 ( VM_EXIT_INTR_INFO ) ; struct vcpu_vmx * vmx = to_vmx ( vcpu ) ; struct vmcs12 * vmcs12 = get_vmcs12 ( vcpu ) ; u32 exit_reason = vmx -> exit_reason ; trace_kvm_nested_vmexit ( kvm_rip_read ( vcpu ) , exit_reason , vmcs_readl ( EXIT_QUALIFICATION ) , vmx -> idt_vectoring_info , intr_info , vmcs_read32 ( VM_EXIT_INTR_ERROR_CODE ) , KVM_ISA_VMX ) ; if ( vmx -> nested . nested_run_pending ) return 0 ; if ( unlikely ( vmx -> fail ) ) { pr_info_ratelimited ( \"%s<S2SV_blank>failed<S2SV_blank>vm<S2SV_blank>entry<S2SV_blank>%x\\\\n\" , __func__ , vmcs_read32 ( VM_INSTRUCTION_ERROR ) ) ; return 1 ; } switch ( exit_reason ) { case EXIT_REASON_EXCEPTION_NMI : if ( ! is_exception ( intr_info ) ) return 0 ; else if ( is_page_fault ( intr_info ) ) return enable_ept ; else if ( is_no_device ( intr_info ) && ! ( vmcs12 -> guest_cr0 & X86_CR0_TS ) ) return 0 ; return vmcs12 -> exception_bitmap & ( 1u << ( intr_info & INTR_INFO_VECTOR_MASK ) ) ; case EXIT_REASON_EXTERNAL_INTERRUPT : return 0 ; case EXIT_REASON_TRIPLE_FAULT : return 1 ; case EXIT_REASON_PENDING_INTERRUPT : return nested_cpu_has ( vmcs12 , CPU_BASED_VIRTUAL_INTR_PENDING ) ; case EXIT_REASON_NMI_WINDOW : return nested_cpu_has ( vmcs12 , CPU_BASED_VIRTUAL_NMI_PENDING ) ; case EXIT_REASON_TASK_SWITCH : return 1 ; case EXIT_REASON_CPUID : if ( kvm_register_read ( vcpu , VCPU_REGS_RAX ) == 0xa ) return 0 ; return 1 ; case EXIT_REASON_HLT : return nested_cpu_has ( vmcs12 , CPU_BASED_HLT_EXITING ) ; case EXIT_REASON_INVD : return 1 ; case EXIT_REASON_INVLPG : return nested_cpu_has ( vmcs12 , CPU_BASED_INVLPG_EXITING ) ; case EXIT_REASON_RDPMC : return nested_cpu_has ( vmcs12 , CPU_BASED_RDPMC_EXITING ) ; case EXIT_REASON_RDTSC : return nested_cpu_has ( vmcs12 , CPU_BASED_RDTSC_EXITING ) ; case EXIT_REASON_VMCALL : case EXIT_REASON_VMCLEAR : case EXIT_REASON_VMLAUNCH : case EXIT_REASON_VMPTRLD : case EXIT_REASON_VMPTRST : case EXIT_REASON_VMREAD : case EXIT_REASON_VMRESUME : case EXIT_REASON_VMWRITE : case EXIT_REASON_VMOFF : case EXIT_REASON_VMON : <S2SV_StartBug> case EXIT_REASON_INVEPT : <S2SV_EndBug> return 1 ; case EXIT_REASON_CR_ACCESS : return nested_vmx_exit_handled_cr ( vcpu , vmcs12 ) ; case EXIT_REASON_DR_ACCESS : return nested_cpu_has ( vmcs12 , CPU_BASED_MOV_DR_EXITING ) ; case EXIT_REASON_IO_INSTRUCTION : return nested_vmx_exit_handled_io ( vcpu , vmcs12 ) ; case EXIT_REASON_MSR_READ : case EXIT_REASON_MSR_WRITE : return nested_vmx_exit_handled_msr ( vcpu , vmcs12 , exit_reason ) ; case EXIT_REASON_INVALID_STATE : return 1 ; case EXIT_REASON_MWAIT_INSTRUCTION : return nested_cpu_has ( vmcs12 , CPU_BASED_MWAIT_EXITING ) ; case EXIT_REASON_MONITOR_INSTRUCTION : return nested_cpu_has ( vmcs12 , CPU_BASED_MONITOR_EXITING ) ; case EXIT_REASON_PAUSE_INSTRUCTION : return nested_cpu_has ( vmcs12 , CPU_BASED_PAUSE_EXITING ) || nested_cpu_has2 ( vmcs12 , SECONDARY_EXEC_PAUSE_LOOP_EXITING ) ; case EXIT_REASON_MCE_DURING_VMENTRY : return 0 ; case EXIT_REASON_TPR_BELOW_THRESHOLD : return nested_cpu_has ( vmcs12 , CPU_BASED_TPR_SHADOW ) ; case EXIT_REASON_APIC_ACCESS : return nested_cpu_has2 ( vmcs12 , SECONDARY_EXEC_VIRTUALIZE_APIC_ACCESSES ) ; case EXIT_REASON_EPT_VIOLATION : return 0 ; case EXIT_REASON_EPT_MISCONFIG : return 0 ; case EXIT_REASON_WBINVD : return nested_cpu_has2 ( vmcs12 , SECONDARY_EXEC_WBINVD_EXITING ) ; case EXIT_REASON_XSETBV : return 1 ; default : return 1 ; } }\n","target":"<S2SV_ModStart> case EXIT_REASON_INVEPT : case EXIT_REASON_INVVPID :\n","project_and_commit_id":"torvalds@linux/a642fc305053cc1c6e47e4f4df327895747ab485","cve_id":"CVE-2014-3646","original_address":"https://github.com/torvalds/linux/commit/a642fc305053cc1c6e47e4f4df327895747ab485","time":"2014-11-10T11:55Z"},
	{"Unnamed: 0":5992,"cwe_id":"CWE-19","source":"CWE-19 static int ext4_xattr_block_list ( struct dentry * dentry , char * buffer , size_t buffer_size ) { struct inode * inode = d_inode ( dentry ) ; struct buffer_head * bh = NULL ; int error ; <S2SV_StartBug> struct mb_cache * ext4_mb_cache = EXT4_GET_MB_CACHE ( inode ) ; <S2SV_EndBug> ea_idebug ( inode , \"buffer=%p,<S2SV_blank>buffer_size=%ld\" , buffer , ( long ) buffer_size ) ; error = 0 ; if ( ! EXT4_I ( inode ) -> i_file_acl ) goto cleanup ; ea_idebug ( inode , \"reading<S2SV_blank>block<S2SV_blank>%llu\" , ( unsigned long long ) EXT4_I ( inode ) -> i_file_acl ) ; bh = sb_bread ( inode -> i_sb , EXT4_I ( inode ) -> i_file_acl ) ; error = - EIO ; if ( ! bh ) goto cleanup ; ea_bdebug ( bh , \"b_count=%d,<S2SV_blank>refcount=%d\" , atomic_read ( & ( bh -> b_count ) ) , le32_to_cpu ( BHDR ( bh ) -> h_refcount ) ) ; if ( ext4_xattr_check_block ( inode , bh ) ) { EXT4_ERROR_INODE ( inode , \"bad<S2SV_blank>block<S2SV_blank>%llu\" , EXT4_I ( inode ) -> i_file_acl ) ; error = - EFSCORRUPTED ; goto cleanup ; } ext4_xattr_cache_insert ( ext4_mb_cache , bh ) ; error = ext4_xattr_list_entries ( dentry , BFIRST ( bh ) , buffer , buffer_size ) ; cleanup : brelse ( bh ) ; return error ; }\n","target":"<S2SV_ModStart> error ; struct mb2_cache <S2SV_ModEnd> * ext4_mb_cache =\n","project_and_commit_id":"torvalds@linux/82939d7999dfc1f1998c4b1c12e2f19edbdff272","cve_id":"CVE-2015-8952","original_address":"https://github.com/torvalds/linux/commit/82939d7999dfc1f1998c4b1c12e2f19edbdff272","time":"2016-10-16T21:59Z"},
	{"Unnamed: 0":4016,"cwe_id":"CWE-284","source":"CWE-284 static __be32 nfsacld_proc_setacl ( struct svc_rqst * rqstp , struct nfsd3_setaclargs * argp , struct nfsd_attrstat * resp ) { struct inode * inode ; svc_fh * fh ; __be32 nfserr = 0 ; int error ; dprintk ( \"nfsd:<S2SV_blank>SETACL(2acl)<S2SV_blank><S2SV_blank><S2SV_blank>%s\\\\n\" , SVCFH_fmt ( & argp -> fh ) ) ; fh = fh_copy ( & resp -> fh , & argp -> fh ) ; nfserr = fh_verify ( rqstp , & resp -> fh , 0 , NFSD_MAY_SATTR ) ; if ( nfserr ) goto out ; inode = d_inode ( fh -> fh_dentry ) ; <S2SV_StartBug> if ( ! IS_POSIXACL ( inode ) || ! inode -> i_op -> set_acl ) { <S2SV_EndBug> error = - EOPNOTSUPP ; goto out_errno ; <S2SV_StartBug> } <S2SV_EndBug> error = fh_want_write ( fh ) ; if ( error ) goto out_errno ; <S2SV_StartBug> error = inode -> i_op -> set_acl ( inode , argp -> acl_access , ACL_TYPE_ACCESS ) ; <S2SV_EndBug> if ( error ) goto out_drop_write ; <S2SV_StartBug> error = inode -> i_op -> set_acl ( inode , argp -> acl_default , <S2SV_EndBug> ACL_TYPE_DEFAULT ) ; if ( error ) goto out_drop_write ; fh_drop_write ( fh ) ; nfserr = fh_getattr ( fh , & resp -> stat ) ; out : posix_acl_release ( argp -> acl_access ) ; posix_acl_release ( argp -> acl_default ) ; return nfserr ; <S2SV_StartBug> out_drop_write : <S2SV_EndBug> fh_drop_write ( fh ) ; out_errno : nfserr = nfserrno ( error ) ; goto out ; }\n","target":"<S2SV_ModStart> fh_dentry ) ; error = fh_want_write ( fh ) ; if ( error ) <S2SV_ModEnd> goto out_errno ; <S2SV_ModStart> goto out_errno ; fh_lock ( fh ) ; error = set_posix_acl ( inode , ACL_TYPE_ACCESS <S2SV_ModEnd> , argp -> <S2SV_ModStart> argp -> acl_access ) ; if ( error ) goto out_drop_lock ; error = set_posix_acl ( inode , ACL_TYPE_DEFAULT <S2SV_ModEnd> , argp -> <S2SV_ModStart> argp -> acl_default ) ; if ( error ) goto out_drop_lock ; fh_unlock ( fh ) <S2SV_ModEnd> ; fh_drop_write ( <S2SV_ModStart> return nfserr ; out_drop_lock : fh_unlock ( fh ) ; <S2SV_ModEnd> fh_drop_write ( fh\n","project_and_commit_id":"torvalds@linux/999653786df6954a31044528ac3f7a5dadca08f4","cve_id":"CVE-2016-1237","original_address":"https://github.com/torvalds/linux/commit/999653786df6954a31044528ac3f7a5dadca08f4","time":"2016-06-29T14:10Z"},
	{"Unnamed: 0":2233,"cwe_id":"CWE-476","source":"CWE-476 static int pcd_detect ( void ) { char id [ 18 ] ; int k , unit ; struct pcd_unit * cd ; printk ( \"%s:<S2SV_blank>%s<S2SV_blank>version<S2SV_blank>%s,<S2SV_blank>major<S2SV_blank>%d,<S2SV_blank>nice<S2SV_blank>%d\\\\n\" , name , name , PCD_VERSION , major , nice ) ; par_drv = pi_register_driver ( name ) ; if ( ! par_drv ) { pr_err ( \"failed<S2SV_blank>to<S2SV_blank>register<S2SV_blank>%s<S2SV_blank>driver\\\\n\" , name ) ; return - 1 ; } k = 0 ; if ( pcd_drive_count == 0 ) { cd = pcd ; if ( pi_init ( cd -> pi , 1 , - 1 , - 1 , - 1 , - 1 , - 1 , pcd_buffer , PI_PCD , verbose , cd -> name ) ) { if ( ! pcd_probe ( cd , - 1 , id ) && cd -> disk ) { cd -> present = 1 ; k ++ ; } else pi_release ( cd -> pi ) ; } } else { for ( unit = 0 , cd = pcd ; unit < PCD_UNITS ; unit ++ , cd ++ ) { int * conf = * drives [ unit ] ; if ( ! conf [ D_PRT ] ) continue ; if ( ! pi_init ( cd -> pi , 0 , conf [ D_PRT ] , conf [ D_MOD ] , conf [ D_UNI ] , conf [ D_PRO ] , conf [ D_DLY ] , pcd_buffer , PI_PCD , verbose , cd -> name ) ) continue ; if ( ! pcd_probe ( cd , conf [ D_SLV ] , id ) && cd -> disk ) { cd -> present = 1 ; k ++ ; } else pi_release ( cd -> pi ) ; } } if ( k ) return 0 ; printk ( \"%s:<S2SV_blank>No<S2SV_blank>CD-ROM<S2SV_blank>drive<S2SV_blank>found\\\\n\" , name ) ; for ( unit = 0 , cd = pcd ; unit < PCD_UNITS ; unit ++ , cd ++ ) { <S2SV_StartBug> blk_cleanup_queue ( cd -> disk -> queue ) ; <S2SV_EndBug> cd -> disk -> queue = NULL ; blk_mq_free_tag_set ( & cd -> tag_set ) ; put_disk ( cd -> disk ) ; } pi_unregister_driver ( par_drv ) ; return - 1 ; }\n","target":"<S2SV_ModStart> ++ ) { if ( ! cd -> disk ) continue ;\n","project_and_commit_id":"torvalds@linux/f0d1762554014ce0ae347b9f0d088f2c157c8c72","cve_id":"CVE-2019-15923","original_address":"https://github.com/torvalds/linux/commit/f0d1762554014ce0ae347b9f0d088f2c157c8c72","time":"2019-09-04T19:15Z"},
	{"Unnamed: 0":2896,"cwe_id":"CWE-200","source":"CWE-200 int vcc_recvmsg ( struct kiocb * iocb , struct socket * sock , struct msghdr * msg , size_t size , int flags ) { struct sock * sk = sock -> sk ; struct atm_vcc * vcc ; struct sk_buff * skb ; <S2SV_StartBug> int copied , error = - EINVAL ; <S2SV_EndBug> if ( sock -> state != SS_CONNECTED ) return - ENOTCONN ; if ( flags & ~ ( MSG_DONTWAIT | MSG_PEEK ) ) return - EOPNOTSUPP ; vcc = ATM_SD ( sock ) ; if ( test_bit ( ATM_VF_RELEASED , & vcc -> flags ) || test_bit ( ATM_VF_CLOSE , & vcc -> flags ) || ! test_bit ( ATM_VF_READY , & vcc -> flags ) ) return 0 ; skb = skb_recv_datagram ( sk , flags , flags & MSG_DONTWAIT , & error ) ; if ( ! skb ) return error ; copied = skb -> len ; if ( copied > size ) { copied = size ; msg -> msg_flags |= MSG_TRUNC ; } error = skb_copy_datagram_iovec ( skb , 0 , msg -> msg_iov , copied ) ; if ( error ) return error ; sock_recv_ts_and_drops ( msg , sk , skb ) ; if ( ! ( flags & MSG_PEEK ) ) { pr_debug ( \"%d<S2SV_blank>-=<S2SV_blank>%d\\\\n\" , atomic_read ( & sk -> sk_rmem_alloc ) , skb -> truesize ) ; atm_return ( vcc , skb -> truesize ) ; } skb_free_datagram ( sk , skb ) ; return copied ; }\n","target":"<S2SV_ModStart> = - EINVAL ; msg -> msg_namelen = 0\n","project_and_commit_id":"torvalds@linux/9b3e617f3df53822345a8573b6d358f6b9e5ed87","cve_id":"CVE-2013-3222","original_address":"https://github.com/torvalds/linux/commit/9b3e617f3df53822345a8573b6d358f6b9e5ed87","time":"2013-04-22T11:41Z"},
	{"Unnamed: 0":2846,"cwe_id":"CWE-000","source":"CWE-000 int main ( void ) { int fd , len , sock_opt ; int error ; struct cn_msg * message ; struct pollfd pfd ; struct nlmsghdr * incoming_msg ; struct cn_msg * incoming_cn_msg ; struct hv_kvp_msg * hv_msg ; char * p ; char * key_value ; char * key_name ; int op ; int pool ; char * if_name ; struct hv_kvp_ipaddr_value * kvp_ip_val ; daemon ( 1 , 0 ) ; openlog ( \"KVP\" , 0 , LOG_USER ) ; syslog ( LOG_INFO , \"KVP<S2SV_blank>starting;<S2SV_blank>pid<S2SV_blank>is:%d\" , getpid ( ) ) ; kvp_get_os_info ( ) ; if ( kvp_file_init ( ) ) { syslog ( LOG_ERR , \"Failed<S2SV_blank>to<S2SV_blank>initialize<S2SV_blank>the<S2SV_blank>pools\" ) ; exit ( EXIT_FAILURE ) ; } fd = socket ( AF_NETLINK , SOCK_DGRAM , NETLINK_CONNECTOR ) ; if ( fd < 0 ) { syslog ( LOG_ERR , \"netlink<S2SV_blank>socket<S2SV_blank>creation<S2SV_blank>failed;<S2SV_blank>error:%d\" , fd ) ; exit ( EXIT_FAILURE ) ; } addr . nl_family = AF_NETLINK ; addr . nl_pad = 0 ; addr . nl_pid = 0 ; addr . nl_groups = CN_KVP_IDX ; error = bind ( fd , ( struct sockaddr * ) & addr , sizeof ( addr ) ) ; if ( error < 0 ) { syslog ( LOG_ERR , \"bind<S2SV_blank>failed;<S2SV_blank>error:%d\" , error ) ; close ( fd ) ; exit ( EXIT_FAILURE ) ; } sock_opt = addr . nl_groups ; setsockopt ( fd , 270 , 1 , & sock_opt , sizeof ( sock_opt ) ) ; message = ( struct cn_msg * ) kvp_send_buffer ; message -> id . idx = CN_KVP_IDX ; message -> id . val = CN_KVP_VAL ; hv_msg = ( struct hv_kvp_msg * ) message -> data ; hv_msg -> kvp_hdr . operation = KVP_OP_REGISTER1 ; message -> ack = 0 ; message -> len = sizeof ( struct hv_kvp_msg ) ; len = netlink_send ( fd , message ) ; if ( len < 0 ) { syslog ( LOG_ERR , \"netlink_send<S2SV_blank>failed;<S2SV_blank>error:%d\" , len ) ; close ( fd ) ; exit ( EXIT_FAILURE ) ; } pfd . fd = fd ; while ( 1 ) { struct sockaddr * addr_p = ( struct sockaddr * ) & addr ; socklen_t addr_l = sizeof ( addr ) ; pfd . events = POLLIN ; pfd . revents = 0 ; poll ( & pfd , 1 , - 1 ) ; len = recvfrom ( fd , kvp_recv_buffer , sizeof ( kvp_recv_buffer ) , 0 , addr_p , & addr_l ) ; <S2SV_StartBug> if ( len < 0 || addr . nl_pid ) { <S2SV_EndBug> syslog ( LOG_ERR , \"recvfrom<S2SV_blank>failed;<S2SV_blank>pid:%u<S2SV_blank>error:%d<S2SV_blank>%s\" , addr . nl_pid , errno , strerror ( errno ) ) ; close ( fd ) ; return - 1 ; } <S2SV_StartBug> incoming_msg = ( struct nlmsghdr * ) kvp_recv_buffer ; <S2SV_EndBug> incoming_cn_msg = ( struct cn_msg * ) NLMSG_DATA ( incoming_msg ) ; hv_msg = ( struct hv_kvp_msg * ) incoming_cn_msg -> data ; op = hv_msg -> kvp_hdr . operation ; pool = hv_msg -> kvp_hdr . pool ; hv_msg -> error = HV_S_OK ; if ( ( in_hand_shake ) && ( op == KVP_OP_REGISTER1 ) ) { in_hand_shake = 0 ; p = ( char * ) hv_msg -> body . kvp_register . version ; lic_version = malloc ( strlen ( p ) + 1 ) ; if ( lic_version ) { strcpy ( lic_version , p ) ; syslog ( LOG_INFO , \"KVP<S2SV_blank>LIC<S2SV_blank>Version:<S2SV_blank>%s\" , lic_version ) ; } else { syslog ( LOG_ERR , \"malloc<S2SV_blank>failed\" ) ; } continue ; } switch ( op ) { case KVP_OP_GET_IP_INFO : kvp_ip_val = & hv_msg -> body . kvp_ip_val ; if_name = kvp_mac_to_if_name ( ( char * ) kvp_ip_val -> adapter_id ) ; if ( if_name == NULL ) { hv_msg -> error = HV_E_FAIL ; break ; } error = kvp_get_ip_info ( 0 , if_name , KVP_OP_GET_IP_INFO , kvp_ip_val , ( MAX_IP_ADDR_SIZE * 2 ) ) ; if ( error ) hv_msg -> error = error ; free ( if_name ) ; break ; case KVP_OP_SET_IP_INFO : kvp_ip_val = & hv_msg -> body . kvp_ip_val ; if_name = kvp_get_if_name ( ( char * ) kvp_ip_val -> adapter_id ) ; if ( if_name == NULL ) { hv_msg -> error = HV_GUID_NOTFOUND ; break ; } error = kvp_set_ip_info ( if_name , kvp_ip_val ) ; if ( error ) hv_msg -> error = error ; free ( if_name ) ; break ; case KVP_OP_SET : if ( kvp_key_add_or_modify ( pool , hv_msg -> body . kvp_set . data . key , hv_msg -> body . kvp_set . data . key_size , hv_msg -> body . kvp_set . data . value , hv_msg -> body . kvp_set . data . value_size ) ) hv_msg -> error = HV_S_CONT ; break ; case KVP_OP_GET : if ( kvp_get_value ( pool , hv_msg -> body . kvp_set . data . key , hv_msg -> body . kvp_set . data . key_size , hv_msg -> body . kvp_set . data . value , hv_msg -> body . kvp_set . data . value_size ) ) hv_msg -> error = HV_S_CONT ; break ; case KVP_OP_DELETE : if ( kvp_key_delete ( pool , hv_msg -> body . kvp_delete . key , hv_msg -> body . kvp_delete . key_size ) ) hv_msg -> error = HV_S_CONT ; break ; default : break ; } if ( op != KVP_OP_ENUMERATE ) goto kvp_done ; if ( pool != KVP_POOL_AUTO ) { if ( kvp_pool_enumerate ( pool , hv_msg -> body . kvp_enum_data . index , hv_msg -> body . kvp_enum_data . data . key , HV_KVP_EXCHANGE_MAX_KEY_SIZE , hv_msg -> body . kvp_enum_data . data . value , HV_KVP_EXCHANGE_MAX_VALUE_SIZE ) ) hv_msg -> error = HV_S_CONT ; goto kvp_done ; } hv_msg = ( struct hv_kvp_msg * ) incoming_cn_msg -> data ; key_name = ( char * ) hv_msg -> body . kvp_enum_data . data . key ; key_value = ( char * ) hv_msg -> body . kvp_enum_data . data . value ; switch ( hv_msg -> body . kvp_enum_data . index ) { case FullyQualifiedDomainName : kvp_get_domain_name ( key_value , HV_KVP_EXCHANGE_MAX_VALUE_SIZE ) ; strcpy ( key_name , \"FullyQualifiedDomainName\" ) ; break ; case IntegrationServicesVersion : strcpy ( key_name , \"IntegrationServicesVersion\" ) ; strcpy ( key_value , lic_version ) ; break ; case NetworkAddressIPv4 : kvp_get_ip_info ( AF_INET , NULL , KVP_OP_ENUMERATE , key_value , HV_KVP_EXCHANGE_MAX_VALUE_SIZE ) ; strcpy ( key_name , \"NetworkAddressIPv4\" ) ; break ; case NetworkAddressIPv6 : kvp_get_ip_info ( AF_INET6 , NULL , KVP_OP_ENUMERATE , key_value , HV_KVP_EXCHANGE_MAX_VALUE_SIZE ) ; strcpy ( key_name , \"NetworkAddressIPv6\" ) ; break ; case OSBuildNumber : strcpy ( key_value , os_build ) ; strcpy ( key_name , \"OSBuildNumber\" ) ; break ; case OSName : strcpy ( key_value , os_name ) ; strcpy ( key_name , \"OSName\" ) ; break ; case OSMajorVersion : strcpy ( key_value , os_major ) ; strcpy ( key_name , \"OSMajorVersion\" ) ; break ; case OSMinorVersion : strcpy ( key_value , os_minor ) ; strcpy ( key_name , \"OSMinorVersion\" ) ; break ; case OSVersion : strcpy ( key_value , os_version ) ; strcpy ( key_name , \"OSVersion\" ) ; break ; case ProcessorArchitecture : strcpy ( key_value , processor_arch ) ; strcpy ( key_name , \"ProcessorArchitecture\" ) ; break ; default : hv_msg -> error = HV_S_CONT ; break ; } kvp_done : incoming_cn_msg -> id . idx = CN_KVP_IDX ; incoming_cn_msg -> id . val = CN_KVP_VAL ; incoming_cn_msg -> ack = 0 ; incoming_cn_msg -> len = sizeof ( struct hv_kvp_msg ) ; len = netlink_send ( fd , incoming_cn_msg ) ; if ( len < 0 ) { syslog ( LOG_ERR , \"net_link<S2SV_blank>send<S2SV_blank>failed;<S2SV_blank>error:%d\" , len ) ; exit ( EXIT_FAILURE ) ; } } }\n","target":"<S2SV_ModStart> len < 0 <S2SV_ModEnd> ) { syslog <S2SV_ModStart> 1 ; } if ( addr . nl_pid ) { syslog ( LOG_WARNING , \"Received<S2SV_blank>packet<S2SV_blank>from<S2SV_blank>untrusted<S2SV_blank>pid:%u\" , addr . nl_pid ) ; continue ; }\n","project_and_commit_id":"torvalds@linux/95a69adab9acfc3981c504737a2b6578e4d846ef","cve_id":"CVE-2012-5532","original_address":"https://github.com/torvalds/linux/commit/95a69adab9acfc3981c504737a2b6578e4d846ef","time":"2012-12-27T11:47Z"},
	{"Unnamed: 0":2271,"cwe_id":"CWE-20","source":"CWE-20 static int irda_recvmsg_stream ( struct kiocb * iocb , struct socket * sock , struct msghdr * msg , size_t size , int flags ) { struct sock * sk = sock -> sk ; struct irda_sock * self = irda_sk ( sk ) ; int noblock = flags & MSG_DONTWAIT ; size_t copied = 0 ; int target , err ; long timeo ; IRDA_DEBUG ( 3 , \"%s()\\\\n\" , __func__ ) ; if ( ( err = sock_error ( sk ) ) < 0 ) return err ; if ( sock -> flags & __SO_ACCEPTCON ) return - EINVAL ; err = - EOPNOTSUPP ; if ( flags & MSG_OOB ) return - EOPNOTSUPP ; err = 0 ; target = sock_rcvlowat ( sk , flags & MSG_WAITALL , size ) ; timeo = sock_rcvtimeo ( sk , noblock ) ; <S2SV_StartBug> msg -> msg_namelen = 0 ; <S2SV_EndBug> do { int chunk ; struct sk_buff * skb = skb_dequeue ( & sk -> sk_receive_queue ) ; if ( skb == NULL ) { DEFINE_WAIT ( wait ) ; err = 0 ; if ( copied >= target ) break ; prepare_to_wait_exclusive ( sk_sleep ( sk ) , & wait , TASK_INTERRUPTIBLE ) ; err = sock_error ( sk ) ; if ( err ) ; else if ( sk -> sk_shutdown & RCV_SHUTDOWN ) ; else if ( noblock ) err = - EAGAIN ; else if ( signal_pending ( current ) ) err = sock_intr_errno ( timeo ) ; else if ( sk -> sk_state != TCP_ESTABLISHED ) err = - ENOTCONN ; else if ( skb_peek ( & sk -> sk_receive_queue ) == NULL ) schedule ( ) ; finish_wait ( sk_sleep ( sk ) , & wait ) ; if ( err ) return err ; if ( sk -> sk_shutdown & RCV_SHUTDOWN ) break ; continue ; } chunk = min_t ( unsigned int , skb -> len , size ) ; if ( memcpy_toiovec ( msg -> msg_iov , skb -> data , chunk ) ) { skb_queue_head ( & sk -> sk_receive_queue , skb ) ; if ( copied == 0 ) copied = - EFAULT ; break ; } copied += chunk ; size -= chunk ; if ( ! ( flags & MSG_PEEK ) ) { skb_pull ( skb , chunk ) ; if ( skb -> len ) { IRDA_DEBUG ( 1 , \"%s(),<S2SV_blank>back<S2SV_blank>on<S2SV_blank>q!\\\\n\" , __func__ ) ; skb_queue_head ( & sk -> sk_receive_queue , skb ) ; break ; } kfree_skb ( skb ) ; } else { IRDA_DEBUG ( 0 , \"%s()<S2SV_blank>questionable!?\\\\n\" , __func__ ) ; skb_queue_head ( & sk -> sk_receive_queue , skb ) ; break ; } } while ( size ) ; if ( self -> rx_flow == FLOW_STOP ) { if ( ( atomic_read ( & sk -> sk_rmem_alloc ) << 2 ) <= sk -> sk_rcvbuf ) { IRDA_DEBUG ( 2 , \"%s(),<S2SV_blank>Starting<S2SV_blank>IrTTP\\\\n\" , __func__ ) ; self -> rx_flow = FLOW_START ; irttp_flow_request ( self -> tsap , FLOW_START ) ; } } return copied ; }\n","target":"<S2SV_ModStart> noblock ) ; <S2SV_ModEnd> do { int\n","project_and_commit_id":"torvalds@linux/f3d3342602f8bcbf37d7c46641cb9bca7618eb1c","cve_id":"CVE-2013-7271","original_address":"https://github.com/torvalds/linux/commit/f3d3342602f8bcbf37d7c46641cb9bca7618eb1c","time":"2014-01-06T16:55Z"},
	{"Unnamed: 0":6093,"cwe_id":"CWE-400","source":"CWE-400 <S2SV_StartBug> void exit_io_context ( void ) <S2SV_EndBug> { struct io_context * ioc ; <S2SV_StartBug> task_lock ( current ) ; <S2SV_EndBug> <S2SV_StartBug> ioc = current -> io_context ; <S2SV_EndBug> <S2SV_StartBug> current -> io_context = NULL ; <S2SV_EndBug> <S2SV_StartBug> task_unlock ( current ) ; <S2SV_EndBug> if ( atomic_dec_and_test ( & ioc -> nr_tasks ) ) { if ( ioc -> aic && ioc -> aic -> exit ) ioc -> aic -> exit ( ioc -> aic ) ; cfq_exit ( ioc ) ; } put_io_context ( ioc ) ; }\n","target":"<S2SV_ModStart> void exit_io_context ( struct task_struct * task <S2SV_ModEnd> ) { struct <S2SV_ModStart> ; task_lock ( task <S2SV_ModEnd> ) ; ioc <S2SV_ModStart> ; ioc = task <S2SV_ModEnd> -> io_context ; <S2SV_ModStart> -> io_context ; task <S2SV_ModEnd> -> io_context = <S2SV_ModStart> ; task_unlock ( task <S2SV_ModEnd> ) ; if\n","project_and_commit_id":"torvalds@linux/b69f2292063d2caf37ca9aec7d63ded203701bf3","cve_id":"CVE-2012-0879","original_address":"https://github.com/torvalds/linux/commit/b69f2292063d2caf37ca9aec7d63ded203701bf3","time":"2012-05-17T11:00Z"},
	{"Unnamed: 0":6371,"cwe_id":"CWE-835","source":"CWE-835 G_DEFINE_TYPE ( GsmXsmpServer , gsm_xsmp_server , G_TYPE_OBJECT ) typedef struct { GsmXsmpServer * server ; IceListenObj listener ; } GsmIceConnectionData ; <S2SV_StartBug> static gboolean <S2SV_EndBug> accept_ice_connection ( GIOChannel * source , GIOCondition condition , GsmIceConnectionData * data ) { IceListenObj listener ; IceConn ice_conn ; IceAcceptStatus status ; GsmClient * client ; GsmXsmpServer * server ; listener = data -> listener ; server = data -> server ; g_debug ( \"GsmXsmpServer:<S2SV_blank>accept_ice_connection()\" ) ; ice_conn = IceAcceptConnection ( listener , & status ) ; if ( status != IceAcceptSuccess ) { g_debug ( \"GsmXsmpServer:<S2SV_blank>IceAcceptConnection<S2SV_blank>returned<S2SV_blank>%d\" , status ) ; return TRUE ; } client = gsm_xsmp_client_new ( ice_conn ) ; <S2SV_StartBug> ice_conn -> context = client ; <S2SV_EndBug> gsm_store_add ( server -> priv -> client_store , gsm_client_peek_id ( client ) , G_OBJECT ( client ) ) ; g_object_unref ( client ) ; return TRUE ; }\n","target":"<S2SV_ModStart> } GsmIceConnectionData ; typedef struct { guint watch_id ; guint protocol_timeout ; } GsmIceConnectionWatch ; static void disconnect_ice_connection ( IceConn ice_conn ) { IceSetShutdownNegotiation ( ice_conn , FALSE ) ; IceCloseConnection <S2SV_ModEnd> ( ice_conn ) <S2SV_ModStart> ice_conn ) ; <S2SV_ModEnd> } <S2SV_null> <S2SV_null>\n","project_and_commit_id":"GNOME@gnome-session/b0dc999e0b45355314616321dbb6cb71e729fc9d","cve_id":"CVE-2017-11171","original_address":"https://github.com/GNOME/gnome-session/commit/b0dc999e0b45355314616321dbb6cb71e729fc9d","time":"2017-07-11T20:29Z"},
	{"Unnamed: 0":5382,"cwe_id":"CWE-416","source":"CWE-416 static OPJ_BOOL opj_j2k_write_mco ( opj_j2k_t * p_j2k , struct opj_stream_private * p_stream , struct opj_event_mgr * p_manager ) { OPJ_BYTE * l_current_data = 00 ; OPJ_UINT32 l_mco_size ; opj_tcp_t * l_tcp = 00 ; opj_simple_mcc_decorrelation_data_t * l_mcc_record ; OPJ_UINT32 i ; assert ( p_j2k != 00 ) ; assert ( p_manager != 00 ) ; assert ( p_stream != 00 ) ; l_tcp = & ( p_j2k -> m_cp . tcps [ p_j2k -> m_current_tile_number ] ) ; <S2SV_StartBug> l_current_data = p_j2k -> m_specific_param . m_encoder . m_header_tile_data ; <S2SV_EndBug> l_mco_size = 5 + l_tcp -> m_nb_mcc_records ; if ( l_mco_size > p_j2k -> m_specific_param . m_encoder . m_header_tile_data_size ) { OPJ_BYTE * new_header_tile_data = ( OPJ_BYTE * ) opj_realloc ( p_j2k -> m_specific_param . m_encoder . m_header_tile_data , l_mco_size ) ; if ( ! new_header_tile_data ) { opj_free ( p_j2k -> m_specific_param . m_encoder . m_header_tile_data ) ; p_j2k -> m_specific_param . m_encoder . m_header_tile_data = NULL ; p_j2k -> m_specific_param . m_encoder . m_header_tile_data_size = 0 ; opj_event_msg ( p_manager , EVT_ERROR , \"Not<S2SV_blank>enough<S2SV_blank>memory<S2SV_blank>to<S2SV_blank>write<S2SV_blank>MCO<S2SV_blank>marker\\\\n\" ) ; return OPJ_FALSE ; } p_j2k -> m_specific_param . m_encoder . m_header_tile_data = new_header_tile_data ; p_j2k -> m_specific_param . m_encoder . m_header_tile_data_size = l_mco_size ; } <S2SV_StartBug> opj_write_bytes ( l_current_data , J2K_MS_MCO , 2 ) ; <S2SV_EndBug> l_current_data += 2 ; opj_write_bytes ( l_current_data , l_mco_size - 2 , 2 ) ; l_current_data += 2 ; opj_write_bytes ( l_current_data , l_tcp -> m_nb_mcc_records , 1 ) ; ++ l_current_data ; l_mcc_record = l_tcp -> m_mcc_records ; for ( i = 0 ; i < l_tcp -> m_nb_mcc_records ; ++ i ) { opj_write_bytes ( l_current_data , l_mcc_record -> m_index , 1 ) ; ++ l_current_data ; ++ l_mcc_record ; } if ( opj_stream_write_data ( p_stream , p_j2k -> m_specific_param . m_encoder . m_header_tile_data , l_mco_size , p_manager ) != l_mco_size ) { return OPJ_FALSE ; } return OPJ_TRUE ; }\n","target":"<S2SV_ModStart> ] ) ; <S2SV_ModEnd> l_mco_size = 5 <S2SV_ModStart> l_mco_size ; } l_current_data = p_j2k -> m_specific_param . m_encoder . m_header_tile_data ;\n","project_and_commit_id":"uclouvain@openjpeg/940100c28ae28931722290794889cf84a92c5f6f","cve_id":"CVE-2015-8871","original_address":"https://github.com/uclouvain/openjpeg/commit/940100c28ae28931722290794889cf84a92c5f6f","time":"2016-09-21T14:25Z"},
	{"Unnamed: 0":1287,"cwe_id":"CWE-119","source":"CWE-119 static int http_connect ( URLContext * h , const char * path , const char * local_path , const char * hoststr , const char * auth , const char * proxyauth , int * new_location ) { HTTPContext * s = h -> priv_data ; int post , err ; char headers [ HTTP_HEADERS_SIZE ] = \"\" ; char * authstr = NULL , * proxyauthstr = NULL ; <S2SV_StartBug> int64_t off = s -> off ; <S2SV_EndBug> int len = 0 ; const char * method ; int send_expect_100 = 0 ; post = h -> flags & AVIO_FLAG_WRITE ; if ( s -> post_data ) { post = 1 ; s -> chunked_post = 0 ; } if ( s -> method ) method = s -> method ; else method = post ? \"POST\" : \"GET\" ; authstr = ff_http_auth_create_response ( & s -> auth_state , auth , local_path , method ) ; proxyauthstr = ff_http_auth_create_response ( & s -> proxy_auth_state , proxyauth , local_path , method ) ; if ( post && ! s -> post_data ) { send_expect_100 = s -> send_expect_100 ; if ( auth && * auth && s -> auth_state . auth_type == HTTP_AUTH_NONE && s -> http_code != 401 ) send_expect_100 = 1 ; } # if FF_API_HTTP_USER_AGENT if ( strcmp ( s -> user_agent_deprecated , DEFAULT_USER_AGENT ) ) { av_log ( s , AV_LOG_WARNING , \"the<S2SV_blank>user-agent<S2SV_blank>option<S2SV_blank>is<S2SV_blank>deprecated,<S2SV_blank>please<S2SV_blank>use<S2SV_blank>user_agent<S2SV_blank>option\\\\n\" ) ; s -> user_agent = av_strdup ( s -> user_agent_deprecated ) ; } # endif if ( ! has_header ( s -> headers , \"\\\\r\\\\nUser-Agent:<S2SV_blank>\" ) ) len += av_strlcatf ( headers + len , sizeof ( headers ) - len , \"User-Agent:<S2SV_blank>%s\\\\r\\\\n\" , s -> user_agent ) ; if ( ! has_header ( s -> headers , \"\\\\r\\\\nAccept:<S2SV_blank>\" ) ) len += av_strlcpy ( headers + len , \"Accept:<S2SV_blank>*/*\\\\r\\\\n\" , sizeof ( headers ) - len ) ; if ( ! has_header ( s -> headers , \"\\\\r\\\\nRange:<S2SV_blank>\" ) && ! post && ( s -> off > 0 || s -> end_off || s -> seekable == - 1 ) ) { len += av_strlcatf ( headers + len , sizeof ( headers ) - len , <S2SV_StartBug> \"Range:<S2SV_blank>bytes=%\" PRId64 \"-\" , s -> off ) ; <S2SV_EndBug> if ( s -> end_off ) len += av_strlcatf ( headers + len , sizeof ( headers ) - len , \"%\" PRId64 , s -> end_off - 1 ) ; len += av_strlcpy ( headers + len , \"\\\\r\\\\n\" , sizeof ( headers ) - len ) ; } if ( send_expect_100 && ! has_header ( s -> headers , \"\\\\r\\\\nExpect:<S2SV_blank>\" ) ) len += av_strlcatf ( headers + len , sizeof ( headers ) - len , \"Expect:<S2SV_blank>100-continue\\\\r\\\\n\" ) ; if ( ! has_header ( s -> headers , \"\\\\r\\\\nConnection:<S2SV_blank>\" ) ) { if ( s -> multiple_requests ) len += av_strlcpy ( headers + len , \"Connection:<S2SV_blank>keep-alive\\\\r\\\\n\" , sizeof ( headers ) - len ) ; else len += av_strlcpy ( headers + len , \"Connection:<S2SV_blank>close\\\\r\\\\n\" , sizeof ( headers ) - len ) ; } if ( ! has_header ( s -> headers , \"\\\\r\\\\nHost:<S2SV_blank>\" ) ) len += av_strlcatf ( headers + len , sizeof ( headers ) - len , \"Host:<S2SV_blank>%s\\\\r\\\\n\" , hoststr ) ; if ( ! has_header ( s -> headers , \"\\\\r\\\\nContent-Length:<S2SV_blank>\" ) && s -> post_data ) len += av_strlcatf ( headers + len , sizeof ( headers ) - len , \"Content-Length:<S2SV_blank>%d\\\\r\\\\n\" , s -> post_datalen ) ; if ( ! has_header ( s -> headers , \"\\\\r\\\\nContent-Type:<S2SV_blank>\" ) && s -> content_type ) len += av_strlcatf ( headers + len , sizeof ( headers ) - len , \"Content-Type:<S2SV_blank>%s\\\\r\\\\n\" , s -> content_type ) ; if ( ! has_header ( s -> headers , \"\\\\r\\\\nCookie:<S2SV_blank>\" ) && s -> cookies ) { char * cookies = NULL ; if ( ! get_cookies ( s , & cookies , path , hoststr ) && cookies ) { len += av_strlcatf ( headers + len , sizeof ( headers ) - len , \"Cookie:<S2SV_blank>%s\\\\r\\\\n\" , cookies ) ; av_free ( cookies ) ; } } if ( ! has_header ( s -> headers , \"\\\\r\\\\nIcy-MetaData:<S2SV_blank>\" ) && s -> icy ) len += av_strlcatf ( headers + len , sizeof ( headers ) - len , \"Icy-MetaData:<S2SV_blank>%d\\\\r\\\\n\" , 1 ) ; if ( s -> headers ) av_strlcpy ( headers + len , s -> headers , sizeof ( headers ) - len ) ; snprintf ( s -> buffer , sizeof ( s -> buffer ) , \"%s<S2SV_blank>%s<S2SV_blank>HTTP/1.1\\\\r\\\\n\" \"%s\" \"%s\" \"%s\" \"%s%s\" \"\\\\r\\\\n\" , method , path , post && s -> chunked_post ? \"Transfer-Encoding:<S2SV_blank>chunked\\\\r\\\\n\" : \"\" , headers , authstr ? authstr : \"\" , proxyauthstr ? \"Proxy-\" : \"\" , proxyauthstr ? proxyauthstr : \"\" ) ; av_log ( h , AV_LOG_DEBUG , \"request:<S2SV_blank>%s\\\\n\" , s -> buffer ) ; if ( ( err = ffurl_write ( s -> hd , s -> buffer , strlen ( s -> buffer ) ) ) < 0 ) goto done ; if ( s -> post_data ) if ( ( err = ffurl_write ( s -> hd , s -> post_data , s -> post_datalen ) ) < 0 ) goto done ; s -> buf_ptr = s -> buffer ; s -> buf_end = s -> buffer ; s -> line_count = 0 ; s -> off = 0 ; s -> icy_data_read = 0 ; <S2SV_StartBug> s -> filesize = - 1 ; <S2SV_EndBug> s -> willclose = 0 ; s -> end_chunked_post = 0 ; s -> end_header = 0 ; if ( post && ! s -> post_data && ! send_expect_100 ) { s -> http_code = 200 ; err = 0 ; goto done ; } err = http_read_header ( h , new_location ) ; if ( err < 0 ) goto done ; if ( * new_location ) s -> off = off ; err = ( off == s -> off ) ? 0 : - 1 ; done : av_freep ( & authstr ) ; av_freep ( & proxyauthstr ) ; return err ; }\n","target":"<S2SV_ModStart> = NULL ; uint64_t <S2SV_ModEnd> off = s <S2SV_ModStart> len , \"Range:<S2SV_blank>bytes=%\" PRIu64 <S2SV_ModEnd> \"-\" , s <S2SV_ModStart> -> filesize = UINT64_MAX <S2SV_ModEnd> ; s ->\n","project_and_commit_id":"FFmpeg@FFmpeg/2a05c8f813de6f2278827734bf8102291e7484aa","cve_id":"CVE-2016-10190","original_address":"https://github.com/FFmpeg/FFmpeg/commit/2a05c8f813de6f2278827734bf8102291e7484aa","time":"2017-02-09T15:59Z"},
	{"Unnamed: 0":6193,"cwe_id":"CWE-362","source":"CWE-362 static int <S2SV_StartBug> mptctl_hp_hostinfo ( unsigned long arg , unsigned int data_size ) <S2SV_EndBug> { hp_host_info_t __user * uarg = ( void __user * ) arg ; <S2SV_StartBug> MPT_ADAPTER * ioc ; <S2SV_EndBug> struct pci_dev * pdev ; char * pbuf = NULL ; dma_addr_t buf_dma ; hp_host_info_t karg ; CONFIGPARMS cfg ; <S2SV_StartBug> ConfigPageHeader_t hdr ; <S2SV_EndBug> int iocnum ; int rc , cim_rev ; ToolboxIstwiReadWriteRequest_t * IstwiRWRequest ; MPT_FRAME_HDR * mf = NULL ; unsigned long timeleft ; int retval ; u32 msgcontext ; if ( data_size == sizeof ( hp_host_info_t ) ) cim_rev = 1 ; else if ( data_size == sizeof ( hp_host_info_rev0_t ) ) cim_rev = 0 ; else return - EFAULT ; if ( copy_from_user ( & karg , uarg , sizeof ( hp_host_info_t ) ) ) { printk ( KERN_ERR MYNAM \"%s@%d::mptctl_hp_host_info<S2SV_blank>-<S2SV_blank>\" \"Unable<S2SV_blank>to<S2SV_blank>read<S2SV_blank>in<S2SV_blank>hp_host_info<S2SV_blank>struct<S2SV_blank>@<S2SV_blank>%p\\\\n\" , __FILE__ , __LINE__ , uarg ) ; return - EFAULT ; } <S2SV_StartBug> if ( ( ( iocnum = mpt_verify_adapter ( karg . hdr . iocnum , & ioc ) ) < 0 ) || <S2SV_EndBug> ( ioc == NULL ) ) { printk ( KERN_DEBUG MYNAM \"%s::mptctl_hp_hostinfo()<S2SV_blank>@%d<S2SV_blank>-<S2SV_blank>ioc%d<S2SV_blank>not<S2SV_blank>found!\\\\n\" , __FILE__ , __LINE__ , iocnum ) ; return - ENODEV ; } dctlprintk ( ioc , printk ( MYIOC_s_DEBUG_FMT \":<S2SV_blank>mptctl_hp_hostinfo<S2SV_blank>called.\\\\n\" , ioc -> name ) ) ; pdev = ( struct pci_dev * ) ioc -> pcidev ; karg . vendor = pdev -> vendor ; karg . device = pdev -> device ; karg . subsystem_id = pdev -> subsystem_device ; karg . subsystem_vendor = pdev -> subsystem_vendor ; karg . devfn = pdev -> devfn ; karg . bus = pdev -> bus -> number ; if ( ioc -> sh != NULL ) karg . host_no = ioc -> sh -> host_no ; else karg . host_no = - 1 ; snprintf ( karg . fw_version , sizeof ( karg . fw_version ) , \"%.2hhu.%.2hhu.%.2hhu.%.2hhu\" , ioc -> facts . FWVersion . Struct . Major , ioc -> facts . FWVersion . Struct . Minor , ioc -> facts . FWVersion . Struct . Unit , ioc -> facts . FWVersion . Struct . Dev ) ; hdr . PageVersion = 0 ; hdr . PageLength = 0 ; hdr . PageNumber = 0 ; hdr . PageType = MPI_CONFIG_PAGETYPE_MANUFACTURING ; cfg . cfghdr . hdr = & hdr ; cfg . physAddr = - 1 ; cfg . pageAddr = 0 ; cfg . action = MPI_CONFIG_ACTION_PAGE_HEADER ; cfg . dir = 0 ; cfg . timeout = 10 ; strncpy ( karg . serial_number , \"<S2SV_blank>\" , 24 ) ; if ( mpt_config ( ioc , & cfg ) == 0 ) { if ( cfg . cfghdr . hdr -> PageLength > 0 ) { cfg . action = MPI_CONFIG_ACTION_PAGE_READ_CURRENT ; pbuf = pci_alloc_consistent ( ioc -> pcidev , hdr . PageLength * 4 , & buf_dma ) ; if ( pbuf ) { cfg . physAddr = buf_dma ; if ( mpt_config ( ioc , & cfg ) == 0 ) { ManufacturingPage0_t * pdata = ( ManufacturingPage0_t * ) pbuf ; if ( strlen ( pdata -> BoardTracerNumber ) > 1 ) { strlcpy ( karg . serial_number , pdata -> BoardTracerNumber , 24 ) ; } } pci_free_consistent ( ioc -> pcidev , hdr . PageLength * 4 , pbuf , buf_dma ) ; pbuf = NULL ; } } } rc = mpt_GetIocState ( ioc , 1 ) ; switch ( rc ) { case MPI_IOC_STATE_OPERATIONAL : karg . ioc_status = HP_STATUS_OK ; break ; case MPI_IOC_STATE_FAULT : karg . ioc_status = HP_STATUS_FAILED ; break ; case MPI_IOC_STATE_RESET : case MPI_IOC_STATE_READY : default : karg . ioc_status = HP_STATUS_OTHER ; break ; } karg . base_io_addr = pci_resource_start ( pdev , 0 ) ; if ( ( ioc -> bus_type == SAS ) || ( ioc -> bus_type == FC ) ) karg . bus_phys_width = HP_BUS_WIDTH_UNK ; else karg . bus_phys_width = HP_BUS_WIDTH_16 ; karg . hard_resets = 0 ; karg . soft_resets = 0 ; karg . timeouts = 0 ; if ( ioc -> sh != NULL ) { MPT_SCSI_HOST * hd = shost_priv ( ioc -> sh ) ; if ( hd && ( cim_rev == 1 ) ) { karg . hard_resets = ioc -> hard_resets ; karg . soft_resets = ioc -> soft_resets ; karg . timeouts = ioc -> timeouts ; } } if ( ( mf = mpt_get_msg_frame ( mptctl_id , ioc ) ) == NULL ) { dfailprintk ( ioc , printk ( MYIOC_s_WARN_FMT \"%s,<S2SV_blank>no<S2SV_blank>msg<S2SV_blank>frames!!\\\\n\" , ioc -> name , __func__ ) ) ; goto out ; } IstwiRWRequest = ( ToolboxIstwiReadWriteRequest_t * ) mf ; msgcontext = IstwiRWRequest -> MsgContext ; memset ( IstwiRWRequest , 0 , sizeof ( ToolboxIstwiReadWriteRequest_t ) ) ; IstwiRWRequest -> MsgContext = msgcontext ; IstwiRWRequest -> Function = MPI_FUNCTION_TOOLBOX ; IstwiRWRequest -> Tool = MPI_TOOLBOX_ISTWI_READ_WRITE_TOOL ; IstwiRWRequest -> Flags = MPI_TB_ISTWI_FLAGS_READ ; IstwiRWRequest -> NumAddressBytes = 0x01 ; IstwiRWRequest -> DataLength = cpu_to_le16 ( 0x04 ) ; if ( pdev -> devfn & 1 ) IstwiRWRequest -> DeviceAddr = 0xB2 ; else IstwiRWRequest -> DeviceAddr = 0xB0 ; pbuf = pci_alloc_consistent ( ioc -> pcidev , 4 , & buf_dma ) ; if ( ! pbuf ) goto out ; ioc -> add_sge ( ( char * ) & IstwiRWRequest -> SGL , ( MPT_SGE_FLAGS_SSIMPLE_READ | 4 ) , buf_dma ) ; retval = 0 ; SET_MGMT_MSG_CONTEXT ( ioc -> ioctl_cmds . msg_context , IstwiRWRequest -> MsgContext ) ; INITIALIZE_MGMT_STATUS ( ioc -> ioctl_cmds . status ) mpt_put_msg_frame ( mptctl_id , ioc , mf ) ; retry_wait : timeleft = wait_for_completion_timeout ( & ioc -> ioctl_cmds . done , HZ * MPT_IOCTL_DEFAULT_TIMEOUT ) ; if ( ! ( ioc -> ioctl_cmds . status & MPT_MGMT_STATUS_COMMAND_GOOD ) ) { retval = - ETIME ; printk ( MYIOC_s_WARN_FMT \"%s:<S2SV_blank>failed\\\\n\" , ioc -> name , __func__ ) ; if ( ioc -> ioctl_cmds . status & MPT_MGMT_STATUS_DID_IOCRESET ) { mpt_free_msg_frame ( ioc , mf ) ; goto out ; } if ( ! timeleft ) { printk ( MYIOC_s_WARN_FMT \"HOST<S2SV_blank>INFO<S2SV_blank>command<S2SV_blank>timeout,<S2SV_blank>doorbell=0x%08x\\\\n\" , ioc -> name , mpt_GetIocState ( ioc , 0 ) ) ; mptctl_timeout_expired ( ioc , mf ) ; } else goto retry_wait ; goto out ; } if ( ioc -> ioctl_cmds . status & MPT_MGMT_STATUS_RF_VALID ) karg . rsvd = * ( u32 * ) pbuf ; out : CLEAR_MGMT_STATUS ( ioc -> ioctl_cmds . status ) SET_MGMT_MSG_CONTEXT ( ioc -> ioctl_cmds . msg_context , 0 ) ; if ( pbuf ) pci_free_consistent ( ioc -> pcidev , 4 , pbuf , buf_dma ) ; if ( copy_to_user ( ( char __user * ) arg , & karg , sizeof ( hp_host_info_t ) ) ) { printk ( MYIOC_s_ERR_FMT \"%s@%d::mptctl_hpgethostinfo<S2SV_blank>-<S2SV_blank>\" \"Unable<S2SV_blank>to<S2SV_blank>write<S2SV_blank>out<S2SV_blank>hp_host_info<S2SV_blank>@<S2SV_blank>%p\\\\n\" , ioc -> name , __FILE__ , __LINE__ , uarg ) ; return - EFAULT ; } return 0 ; }\n","target":"<S2SV_ModStart> int mptctl_hp_hostinfo ( MPT_ADAPTER * ioc , <S2SV_ModStart> ) arg ; <S2SV_ModEnd> struct pci_dev * <S2SV_ModStart> ; ConfigPageHeader_t hdr <S2SV_ModEnd> ; int rc <S2SV_ModStart> EFAULT ; } <S2SV_ModEnd> dctlprintk ( ioc\n","project_and_commit_id":"torvalds@linux/28d76df18f0ad5bcf5fa48510b225f0ed262a99b","cve_id":"CVE-2020-12652","original_address":"https://github.com/torvalds/linux/commit/28d76df18f0ad5bcf5fa48510b225f0ed262a99b","time":"2020-05-05T05:15Z"},
	{"Unnamed: 0":3587,"cwe_id":"CWE-119","source":"CWE-119 static int rd_inter16x16_uv ( VP8_COMP * cpi , MACROBLOCK * x , int * rate , int * distortion , int fullpixel ) <S2SV_StartBug> { <S2SV_EndBug> vp8_build_inter16x16_predictors_mbuv ( & x -> e_mbd ) ; vp8_subtract_mbuv ( x -> src_diff , x -> src . u_buffer , x -> src . v_buffer , x -> src . uv_stride , & x -> e_mbd . predictor [ 256 ] , & x -> e_mbd . predictor [ 320 ] , 8 ) ; vp8_transform_mbuv ( x ) ; vp8_quantize_mbuv ( x ) ; * rate = rd_cost_mbuv ( x ) ; * distortion = vp8_mbuverror ( x ) / 4 ; return RDCOST ( x -> rdmult , x -> rddiv , * rate , * distortion ) ; }\n","target":"<S2SV_ModStart> fullpixel ) { ( void ) cpi ; ( void ) fullpixel ;\n","project_and_commit_id":"external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426","cve_id":"CVE-2016-1621","original_address":"https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426","time":"2016-03-12T21:59Z"},
	{"Unnamed: 0":6204,"cwe_id":"CWE-000","source":"CWE-000 void sas_init_disc ( struct sas_discovery * disc , struct asd_sas_port * port ) { int i ; static const work_func_t sas_event_fns [ DISC_NUM_EVENTS ] = { [ DISCE_DISCOVER_DOMAIN ] = sas_discover_domain , [ DISCE_REVALIDATE_DOMAIN ] = sas_revalidate_domain , <S2SV_StartBug> [ DISCE_PROBE ] = sas_probe_devices , <S2SV_EndBug> [ DISCE_SUSPEND ] = sas_suspend_devices , <S2SV_StartBug> [ DISCE_RESUME ] = sas_resume_devices , <S2SV_EndBug> [ DISCE_DESTRUCT ] = sas_destruct_devices , } ; disc -> pending = 0 ; for ( i = 0 ; i < DISC_NUM_EVENTS ; i ++ ) { INIT_SAS_WORK ( & disc -> disc_work [ i ] . work , sas_event_fns [ i ] ) ; disc -> disc_work [ i ] . port = port ; } }\n","target":"<S2SV_ModStart> sas_revalidate_domain , [ <S2SV_ModEnd> DISCE_SUSPEND ] = <S2SV_ModStart> ] = sas_resume_devices <S2SV_ModEnd> , } ;\n","project_and_commit_id":"torvalds@linux/0558f33c06bb910e2879e355192227a8e8f0219d","cve_id":"CVE-2017-18232","original_address":"https://github.com/torvalds/linux/commit/0558f33c06bb910e2879e355192227a8e8f0219d","time":"2018-03-15T04:29Z"},
	{"Unnamed: 0":1968,"cwe_id":"CWE-125","source":"CWE-125 PyObject * ast2obj_stmt ( void * _o ) { stmt_ty o = ( stmt_ty ) _o ; PyObject * result = NULL , * value = NULL ; if ( ! o ) { <S2SV_StartBug> Py_INCREF ( Py_None ) ; <S2SV_EndBug> return Py_None ; } switch ( o -> kind ) { case FunctionDef_kind : result = PyType_GenericNew ( FunctionDef_type , NULL , NULL ) ; if ( ! result ) goto failed ; value = ast2obj_identifier ( o -> v . FunctionDef . name ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_name , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; value = ast2obj_arguments ( o -> v . FunctionDef . args ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_args , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; value = ast2obj_list ( o -> v . FunctionDef . body , ast2obj_stmt ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_body , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; value = ast2obj_list ( o -> v . FunctionDef . decorator_list , ast2obj_expr ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_decorator_list , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; value = ast2obj_expr ( o -> v . FunctionDef . returns ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_returns , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; value = ast2obj_string ( o -> v . FunctionDef . type_comment ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_type_comment , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; break ; case AsyncFunctionDef_kind : result = PyType_GenericNew ( AsyncFunctionDef_type , NULL , NULL ) ; if ( ! result ) goto failed ; value = ast2obj_identifier ( o -> v . AsyncFunctionDef . name ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_name , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; value = ast2obj_arguments ( o -> v . AsyncFunctionDef . args ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_args , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; value = ast2obj_list ( o -> v . AsyncFunctionDef . body , ast2obj_stmt ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_body , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; value = ast2obj_list ( o -> v . AsyncFunctionDef . decorator_list , ast2obj_expr ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_decorator_list , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; value = ast2obj_expr ( o -> v . AsyncFunctionDef . returns ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_returns , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; value = ast2obj_string ( o -> v . AsyncFunctionDef . type_comment ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_type_comment , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; break ; case ClassDef_kind : result = PyType_GenericNew ( ClassDef_type , NULL , NULL ) ; if ( ! result ) goto failed ; value = ast2obj_identifier ( o -> v . ClassDef . name ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_name , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; value = ast2obj_list ( o -> v . ClassDef . bases , ast2obj_expr ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_bases , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; value = ast2obj_list ( o -> v . ClassDef . keywords , ast2obj_keyword ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_keywords , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; value = ast2obj_list ( o -> v . ClassDef . body , ast2obj_stmt ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_body , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; value = ast2obj_list ( o -> v . ClassDef . decorator_list , ast2obj_expr ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_decorator_list , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; break ; case Return_kind : result = PyType_GenericNew ( Return_type , NULL , NULL ) ; if ( ! result ) goto failed ; value = ast2obj_expr ( o -> v . Return . value ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_value , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; break ; case Delete_kind : result = PyType_GenericNew ( Delete_type , NULL , NULL ) ; if ( ! result ) goto failed ; value = ast2obj_list ( o -> v . Delete . targets , ast2obj_expr ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_targets , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; break ; case Assign_kind : result = PyType_GenericNew ( Assign_type , NULL , NULL ) ; if ( ! result ) goto failed ; value = ast2obj_list ( o -> v . Assign . targets , ast2obj_expr ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_targets , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; value = ast2obj_expr ( o -> v . Assign . value ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_value , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; value = ast2obj_string ( o -> v . Assign . type_comment ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_type_comment , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; break ; case AugAssign_kind : result = PyType_GenericNew ( AugAssign_type , NULL , NULL ) ; if ( ! result ) goto failed ; value = ast2obj_expr ( o -> v . AugAssign . target ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_target , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; value = ast2obj_operator ( o -> v . AugAssign . op ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_op , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; value = ast2obj_expr ( o -> v . AugAssign . value ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_value , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; break ; case AnnAssign_kind : result = PyType_GenericNew ( AnnAssign_type , NULL , NULL ) ; if ( ! result ) goto failed ; value = ast2obj_expr ( o -> v . AnnAssign . target ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_target , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; value = ast2obj_expr ( o -> v . AnnAssign . annotation ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_annotation , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; value = ast2obj_expr ( o -> v . AnnAssign . value ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_value , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; value = ast2obj_int ( o -> v . AnnAssign . simple ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_simple , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; break ; case For_kind : result = PyType_GenericNew ( For_type , NULL , NULL ) ; if ( ! result ) goto failed ; value = ast2obj_expr ( o -> v . For . target ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_target , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; value = ast2obj_expr ( o -> v . For . iter ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_iter , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; value = ast2obj_list ( o -> v . For . body , ast2obj_stmt ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_body , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; value = ast2obj_list ( o -> v . For . orelse , ast2obj_stmt ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_orelse , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; value = ast2obj_string ( o -> v . For . type_comment ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_type_comment , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; break ; case AsyncFor_kind : result = PyType_GenericNew ( AsyncFor_type , NULL , NULL ) ; if ( ! result ) goto failed ; value = ast2obj_expr ( o -> v . AsyncFor . target ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_target , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; value = ast2obj_expr ( o -> v . AsyncFor . iter ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_iter , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; value = ast2obj_list ( o -> v . AsyncFor . body , ast2obj_stmt ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_body , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; value = ast2obj_list ( o -> v . AsyncFor . orelse , ast2obj_stmt ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_orelse , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; value = ast2obj_string ( o -> v . AsyncFor . type_comment ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_type_comment , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; break ; case While_kind : result = PyType_GenericNew ( While_type , NULL , NULL ) ; if ( ! result ) goto failed ; value = ast2obj_expr ( o -> v . While . test ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_test , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; value = ast2obj_list ( o -> v . While . body , ast2obj_stmt ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_body , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; value = ast2obj_list ( o -> v . While . orelse , ast2obj_stmt ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_orelse , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; break ; case If_kind : result = PyType_GenericNew ( If_type , NULL , NULL ) ; if ( ! result ) goto failed ; value = ast2obj_expr ( o -> v . If . test ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_test , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; value = ast2obj_list ( o -> v . If . body , ast2obj_stmt ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_body , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; value = ast2obj_list ( o -> v . If . orelse , ast2obj_stmt ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_orelse , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; break ; case With_kind : result = PyType_GenericNew ( With_type , NULL , NULL ) ; if ( ! result ) goto failed ; value = ast2obj_list ( o -> v . With . items , ast2obj_withitem ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_items , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; value = ast2obj_list ( o -> v . With . body , ast2obj_stmt ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_body , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; value = ast2obj_string ( o -> v . With . type_comment ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_type_comment , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; break ; case AsyncWith_kind : result = PyType_GenericNew ( AsyncWith_type , NULL , NULL ) ; if ( ! result ) goto failed ; value = ast2obj_list ( o -> v . AsyncWith . items , ast2obj_withitem ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_items , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; value = ast2obj_list ( o -> v . AsyncWith . body , ast2obj_stmt ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_body , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; value = ast2obj_string ( o -> v . AsyncWith . type_comment ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_type_comment , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; break ; case Raise_kind : result = PyType_GenericNew ( Raise_type , NULL , NULL ) ; if ( ! result ) goto failed ; value = ast2obj_expr ( o -> v . Raise . exc ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_exc , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; value = ast2obj_expr ( o -> v . Raise . cause ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_cause , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; break ; case Try_kind : result = PyType_GenericNew ( Try_type , NULL , NULL ) ; if ( ! result ) goto failed ; value = ast2obj_list ( o -> v . Try . body , ast2obj_stmt ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_body , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; value = ast2obj_list ( o -> v . Try . handlers , ast2obj_excepthandler ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_handlers , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; value = ast2obj_list ( o -> v . Try . orelse , ast2obj_stmt ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_orelse , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; value = ast2obj_list ( o -> v . Try . finalbody , ast2obj_stmt ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_finalbody , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; break ; case Assert_kind : result = PyType_GenericNew ( Assert_type , NULL , NULL ) ; if ( ! result ) goto failed ; value = ast2obj_expr ( o -> v . Assert . test ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_test , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; value = ast2obj_expr ( o -> v . Assert . msg ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_msg , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; break ; case Import_kind : result = PyType_GenericNew ( Import_type , NULL , NULL ) ; if ( ! result ) goto failed ; value = ast2obj_list ( o -> v . Import . names , ast2obj_alias ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_names , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; break ; case ImportFrom_kind : result = PyType_GenericNew ( ImportFrom_type , NULL , NULL ) ; if ( ! result ) goto failed ; value = ast2obj_identifier ( o -> v . ImportFrom . module ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_module , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; value = ast2obj_list ( o -> v . ImportFrom . names , ast2obj_alias ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_names , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; value = ast2obj_int ( o -> v . ImportFrom . level ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_level , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; break ; case Global_kind : result = PyType_GenericNew ( Global_type , NULL , NULL ) ; if ( ! result ) goto failed ; value = ast2obj_list ( o -> v . Global . names , ast2obj_identifier ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_names , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; break ; case Nonlocal_kind : result = PyType_GenericNew ( Nonlocal_type , NULL , NULL ) ; if ( ! result ) goto failed ; value = ast2obj_list ( o -> v . Nonlocal . names , ast2obj_identifier ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_names , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; break ; case Expr_kind : result = PyType_GenericNew ( Expr_type , NULL , NULL ) ; if ( ! result ) goto failed ; value = ast2obj_expr ( o -> v . Expr . value ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_value , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; break ; case Pass_kind : result = PyType_GenericNew ( Pass_type , NULL , NULL ) ; if ( ! result ) goto failed ; break ; case Break_kind : result = PyType_GenericNew ( Break_type , NULL , NULL ) ; if ( ! result ) goto failed ; break ; case Continue_kind : result = PyType_GenericNew ( Continue_type , NULL , NULL ) ; if ( ! result ) goto failed ; break ; } value = ast2obj_int ( o -> lineno ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_lineno , value ) < 0 ) goto failed ; Py_DECREF ( value ) ; value = ast2obj_int ( o -> col_offset ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_col_offset , value ) < 0 ) goto failed ; Py_DECREF ( value ) ; return result ; failed : Py_XDECREF ( value ) ; Py_XDECREF ( result ) ; return NULL ; }\n","target":"<S2SV_ModStart> o ) { Py_RETURN_NONE <S2SV_ModEnd> ; } switch\n","project_and_commit_id":"python@typed_ast/156afcb26c198e162504a57caddfe0acd9ed7dce","cve_id":"CVE-2019-19275","original_address":"https://github.com/python/typed_ast/commit/156afcb26c198e162504a57caddfe0acd9ed7dce","time":"2019-11-26T15:15Z"},
	{"Unnamed: 0":3736,"cwe_id":"CWE-119","source":"CWE-119 void vp8_setup_key_frame ( VP8_COMP * cpi ) { vp8_default_coef_probs ( & cpi -> common ) ; <S2SV_StartBug> vpx_memcpy ( cpi -> common . fc . mvc , vp8_default_mv_context , sizeof ( vp8_default_mv_context ) ) ; <S2SV_EndBug> { int flag [ 2 ] = { 1 , 1 } ; vp8_build_component_cost_table ( cpi -> mb . mvcost , ( const MV_CONTEXT * ) cpi -> common . fc . mvc , flag ) ; } <S2SV_StartBug> vpx_memcpy ( & cpi -> lfc_a , & cpi -> common . fc , sizeof ( cpi -> common . fc ) ) ; <S2SV_EndBug> <S2SV_StartBug> vpx_memcpy ( & cpi -> lfc_g , & cpi -> common . fc , sizeof ( cpi -> common . fc ) ) ; <S2SV_EndBug> <S2SV_StartBug> vpx_memcpy ( & cpi -> lfc_n , & cpi -> common . fc , sizeof ( cpi -> common . fc ) ) ; <S2SV_EndBug> cpi -> common . filter_level = cpi -> common . base_qindex * 3 / 8 ; if ( cpi -> auto_gold ) cpi -> frames_till_gf_update_due = cpi -> baseline_gf_interval ; else cpi -> frames_till_gf_update_due = DEFAULT_GF_INTERVAL ; cpi -> common . refresh_golden_frame = 1 ; cpi -> common . refresh_alt_ref_frame = 1 ; }\n","target":"<S2SV_ModStart> common ) ; memcpy <S2SV_ModEnd> ( cpi -> <S2SV_ModStart> ) ; } memcpy <S2SV_ModEnd> ( & cpi <S2SV_ModStart> ) ) ; memcpy <S2SV_ModEnd> ( & cpi <S2SV_ModStart> ) ) ; memcpy <S2SV_ModEnd> ( & cpi\n","project_and_commit_id":"external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426","cve_id":"CVE-2016-1621","original_address":"https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426","time":"2016-03-12T21:59Z"},
	{"Unnamed: 0":4227,"cwe_id":"CWE-119","source":"CWE-119 static void accumulate_frame_motion_stats ( <S2SV_StartBug> FIRSTPASS_STATS * this_frame , <S2SV_EndBug> <S2SV_StartBug> double * this_frame_mv_in_out , <S2SV_EndBug> double * mv_in_out_accumulator , double * abs_mv_in_out_accumulator , double * mv_ratio_accumulator ) { <S2SV_StartBug> double motion_pct ; <S2SV_EndBug> motion_pct = this_frame -> pcnt_motion ; <S2SV_StartBug> * this_frame_mv_in_out = this_frame -> mv_in_out_count * motion_pct ; <S2SV_EndBug> <S2SV_StartBug> * mv_in_out_accumulator += this_frame -> mv_in_out_count * motion_pct ; <S2SV_EndBug> <S2SV_StartBug> * abs_mv_in_out_accumulator += fabs ( this_frame -> mv_in_out_count * motion_pct ) ; <S2SV_EndBug> <S2SV_StartBug> if ( motion_pct > 0.05 ) { <S2SV_EndBug> <S2SV_StartBug> const double this_frame_mvr_ratio = fabs ( this_frame -> mvr_abs ) / <S2SV_EndBug> <S2SV_StartBug> DOUBLE_DIVIDE_CHECK ( fabs ( this_frame -> MVr ) ) ; <S2SV_EndBug> <S2SV_StartBug> const double this_frame_mvc_ratio = fabs ( this_frame -> mvc_abs ) / <S2SV_EndBug> <S2SV_StartBug> DOUBLE_DIVIDE_CHECK ( fabs ( this_frame -> MVc ) ) ; <S2SV_EndBug> <S2SV_StartBug> * mv_ratio_accumulator += ( this_frame_mvr_ratio < this_frame -> mvr_abs ) <S2SV_EndBug> <S2SV_StartBug> ? ( this_frame_mvr_ratio * motion_pct ) <S2SV_EndBug> : this_frame -> mvr_abs * motion_pct ; <S2SV_StartBug> * mv_ratio_accumulator += ( this_frame_mvc_ratio < this_frame -> mvc_abs ) <S2SV_EndBug> <S2SV_StartBug> ? ( this_frame_mvc_ratio * motion_pct ) <S2SV_EndBug> : this_frame -> mvc_abs * motion_pct ; } }\n","target":"<S2SV_ModStart> void accumulate_frame_motion_stats ( const FIRSTPASS_STATS * stats <S2SV_ModEnd> , double * <S2SV_ModStart> , double * mv_in_out <S2SV_ModEnd> , double * <S2SV_ModStart> mv_ratio_accumulator ) { const double pct = stats <S2SV_ModEnd> -> pcnt_motion ; <S2SV_ModStart> pcnt_motion ; * mv_in_out = stats <S2SV_ModEnd> -> mv_in_out_count * <S2SV_ModStart> -> mv_in_out_count * pct <S2SV_ModEnd> ; * mv_in_out_accumulator <S2SV_ModStart> * mv_in_out_accumulator += * mv_in_out <S2SV_ModEnd> ; * abs_mv_in_out_accumulator <S2SV_ModStart> += fabs ( * mv_in_out <S2SV_ModEnd> ) ; if <S2SV_ModStart> ; if ( pct <S2SV_ModEnd> > 0.05 ) <S2SV_ModStart> { const double mvr_ratio <S2SV_ModEnd> = fabs ( <S2SV_ModStart> = fabs ( stats <S2SV_ModEnd> -> mvr_abs ) <S2SV_ModStart> ( fabs ( stats <S2SV_ModEnd> -> MVr ) <S2SV_ModStart> ; const double mvc_ratio <S2SV_ModEnd> = fabs ( <S2SV_ModStart> = fabs ( stats <S2SV_ModEnd> -> mvc_abs ) <S2SV_ModStart> ( fabs ( stats <S2SV_ModEnd> -> MVc ) <S2SV_ModStart> * mv_ratio_accumulator += pct * ( mvr_ratio < stats -> mvr_abs ? mvr_ratio : stats <S2SV_ModEnd> -> mvr_abs ) <S2SV_ModStart> -> mvr_abs ) <S2SV_ModEnd> ; * mv_ratio_accumulator <S2SV_ModStart> * mv_ratio_accumulator += pct * ( mvc_ratio < stats -> mvc_abs ? mvc_ratio : stats <S2SV_ModEnd> -> mvc_abs ) <S2SV_ModStart> -> mvc_abs ) <S2SV_ModEnd> ; } }\n","project_and_commit_id":"external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426","cve_id":"CVE-2016-1621","original_address":"https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426","time":"2016-03-12T21:59Z"},
	{"Unnamed: 0":2865,"cwe_id":"CWE-190","source":"CWE-190 static int vdbePmaReadBlob ( PmaReader * p , int nByte , u8 * * ppOut ) { int iBuf ; int nAvail ; if ( p -> aMap ) { * ppOut = & p -> aMap [ p -> iReadOff ] ; p -> iReadOff += nByte ; return SQLITE_OK ; } assert ( p -> aBuffer ) ; iBuf = p -> iReadOff % p -> nBuffer ; if ( iBuf == 0 ) { int nRead ; int rc ; if ( ( p -> iEof - p -> iReadOff ) > ( i64 ) p -> nBuffer ) { nRead = p -> nBuffer ; } else { nRead = ( int ) ( p -> iEof - p -> iReadOff ) ; } assert ( nRead > 0 ) ; rc = sqlite3OsRead ( p -> pFd , p -> aBuffer , nRead , p -> iReadOff ) ; assert ( rc != SQLITE_IOERR_SHORT_READ ) ; if ( rc != SQLITE_OK ) return rc ; } nAvail = p -> nBuffer - iBuf ; if ( nByte <= nAvail ) { * ppOut = & p -> aBuffer [ iBuf ] ; p -> iReadOff += nByte ; } else { int nRem ; if ( p -> nAlloc < nByte ) { u8 * aNew ; <S2SV_StartBug> int nNew = MAX ( 128 , p -> nAlloc * 2 ) ; <S2SV_EndBug> while ( nByte > nNew ) nNew = nNew * 2 ; aNew = sqlite3Realloc ( p -> aAlloc , nNew ) ; if ( ! aNew ) return SQLITE_NOMEM_BKPT ; p -> nAlloc = nNew ; p -> aAlloc = aNew ; } memcpy ( p -> aAlloc , & p -> aBuffer [ iBuf ] , nAvail ) ; p -> iReadOff += nAvail ; nRem = nByte - nAvail ; while ( nRem > 0 ) { int rc ; int nCopy ; u8 * aNext ; nCopy = nRem ; if ( nRem > p -> nBuffer ) nCopy = p -> nBuffer ; rc = vdbePmaReadBlob ( p , nCopy , & aNext ) ; if ( rc != SQLITE_OK ) return rc ; assert ( aNext != p -> aAlloc ) ; memcpy ( & p -> aAlloc [ nByte - nRem ] , aNext , nCopy ) ; nRem -= nCopy ; } * ppOut = p -> aAlloc ; } return SQLITE_OK ; }\n","target":"<S2SV_ModStart> * aNew ; sqlite3_int64 <S2SV_ModEnd> nNew = MAX <S2SV_ModStart> ( 128 , 2 * ( sqlite3_int64 ) <S2SV_ModStart> p -> nAlloc <S2SV_ModEnd> ) ; while\n","project_and_commit_id":"chromium@chromium/517ac71c9ee27f856f9becde8abea7d1604af9d4","cve_id":"CVE-2019-5827","original_address":"https://github.com/chromium/chromium/commit/517ac71c9ee27f856f9becde8abea7d1604af9d4","time":"2019-06-27T17:15Z"},
	{"Unnamed: 0":3355,"cwe_id":"CWE-119","source":"CWE-119 static int futex_wait ( u32 __user * uaddr , int fshared , u32 val , ktime_t * abs_time , u32 bitset , int clockrt ) { struct hrtimer_sleeper timeout , * to = NULL ; struct restart_block * restart ; struct futex_hash_bucket * hb ; struct futex_q q ; int ret ; if ( ! bitset ) return - EINVAL ; q . pi_state = NULL ; q . bitset = bitset ; q . rt_waiter = NULL ; q . requeue_pi_key = NULL ; if ( abs_time ) { to = & timeout ; hrtimer_init_on_stack ( & to -> timer , clockrt ? CLOCK_REALTIME : CLOCK_MONOTONIC , HRTIMER_MODE_ABS ) ; hrtimer_init_sleeper ( to , current ) ; hrtimer_set_expires_range_ns ( & to -> timer , * abs_time , current -> timer_slack_ns ) ; } retry : ret = futex_wait_setup ( uaddr , val , fshared , & q , & hb ) ; if ( ret ) goto out ; futex_wait_queue_me ( hb , & q , to ) ; ret = 0 ; if ( ! unqueue_me ( & q ) ) <S2SV_StartBug> goto out_put_key ; <S2SV_EndBug> ret = - ETIMEDOUT ; if ( to && ! to -> task ) <S2SV_StartBug> goto out_put_key ; <S2SV_EndBug> <S2SV_StartBug> if ( ! signal_pending ( current ) ) { <S2SV_EndBug> put_futex_key ( fshared , & q . key ) ; goto retry ; <S2SV_StartBug> } <S2SV_EndBug> ret = - ERESTARTSYS ; if ( ! abs_time ) <S2SV_StartBug> goto out_put_key ; <S2SV_EndBug> restart = & current_thread_info ( ) -> restart_block ; restart -> fn = futex_wait_restart ; restart -> futex . uaddr = ( u32 * ) uaddr ; restart -> futex . val = val ; restart -> futex . time = abs_time -> tv64 ; restart -> futex . bitset = bitset ; restart -> futex . flags = FLAGS_HAS_TIMEOUT ; if ( fshared ) restart -> futex . flags |= FLAGS_SHARED ; if ( clockrt ) restart -> futex . flags |= FLAGS_CLOCKRT ; ret = - ERESTART_RESTARTBLOCK ; <S2SV_StartBug> out_put_key : <S2SV_EndBug> put_futex_key ( fshared , & q . key ) ; out : if ( to ) { hrtimer_cancel ( & to -> timer ) ; destroy_hrtimer_on_stack ( & to -> timer ) ; } return ret ; }\n","target":"<S2SV_ModStart> ) ) goto out <S2SV_ModEnd> ; ret = <S2SV_ModStart> task ) goto out <S2SV_ModEnd> ; if ( <S2SV_ModStart> current ) ) <S2SV_ModEnd> goto retry ; <S2SV_ModStart> goto retry ; <S2SV_ModEnd> ret = - <S2SV_ModStart> abs_time ) goto out <S2SV_ModEnd> ; restart = <S2SV_ModStart> - ERESTART_RESTARTBLOCK ; <S2SV_ModEnd> out : if\n","project_and_commit_id":"torvalds@linux/7ada876a8703f23befbb20a7465a702ee39b1704","cve_id":"CVE-2014-0205","original_address":"https://github.com/torvalds/linux/commit/7ada876a8703f23befbb20a7465a702ee39b1704","time":"2014-09-28T19:55Z"},
	{"Unnamed: 0":6123,"cwe_id":"CWE-264","source":"CWE-264 static void bt_tags_for_each ( struct blk_mq_tags * tags , struct blk_mq_bitmap_tags * bt , unsigned int off , busy_tag_iter_fn * fn , void * data , bool reserved ) { struct request * rq ; int bit , i ; if ( ! tags -> rqs ) return ; for ( i = 0 ; i < bt -> map_nr ; i ++ ) { struct blk_align_bitmap * bm = & bt -> map [ i ] ; for ( bit = find_first_bit ( & bm -> word , bm -> depth ) ; bit < bm -> depth ; bit = find_next_bit ( & bm -> word , bm -> depth , bit + 1 ) ) { <S2SV_StartBug> rq = blk_mq_tag_to_rq ( tags , off + bit ) ; <S2SV_EndBug> fn ( rq , data , reserved ) ; } off += ( 1 << bt -> bits_per_word ) ; } }\n","target":"<S2SV_ModStart> { rq = tags -> rqs [ <S2SV_ModEnd> off + bit <S2SV_ModStart> off + bit ] <S2SV_ModEnd> ; fn (\n","project_and_commit_id":"torvalds@linux/0048b4837affd153897ed1222283492070027aa9","cve_id":"CVE-2015-9016","original_address":"https://github.com/torvalds/linux/commit/0048b4837affd153897ed1222283492070027aa9","time":"2018-04-05T18:29Z"},
	{"Unnamed: 0":2176,"cwe_id":"CWE-000","source":"CWE-000 static void sas_discover_domain ( struct work_struct * work ) { struct domain_device * dev ; int error = 0 ; struct sas_discovery_event * ev = to_sas_discovery_event ( work ) ; struct asd_sas_port * port = ev -> port ; clear_bit ( DISCE_DISCOVER_DOMAIN , & port -> disc . pending ) ; if ( port -> port_dev ) return ; error = sas_get_port_device ( port ) ; if ( error ) return ; dev = port -> port_dev ; SAS_DPRINTK ( \"DOING<S2SV_blank>DISCOVERY<S2SV_blank>on<S2SV_blank>port<S2SV_blank>%d,<S2SV_blank>pid:%d\\\\n\" , port -> id , task_pid_nr ( current ) ) ; switch ( dev -> dev_type ) { case SAS_END_DEVICE : error = sas_discover_end_dev ( dev ) ; break ; case SAS_EDGE_EXPANDER_DEVICE : case SAS_FANOUT_EXPANDER_DEVICE : error = sas_discover_root_expander ( dev ) ; break ; case SAS_SATA_DEV : case SAS_SATA_PM : # ifdef CONFIG_SCSI_SAS_ATA error = sas_discover_sata ( dev ) ; break ; # else SAS_DPRINTK ( \"ATA<S2SV_blank>device<S2SV_blank>seen<S2SV_blank>but<S2SV_blank>CONFIG_SCSI_SAS_ATA=N<S2SV_blank>so<S2SV_blank>cannot<S2SV_blank>attach\\\\n\" ) ; # endif default : error = - ENXIO ; SAS_DPRINTK ( \"unhandled<S2SV_blank>device<S2SV_blank>%d\\\\n\" , dev -> dev_type ) ; break ; } if ( error ) { sas_rphy_free ( dev -> rphy ) ; list_del_init ( & dev -> disco_list_node ) ; spin_lock_irq ( & port -> dev_list_lock ) ; list_del_init ( & dev -> dev_list_node ) ; spin_unlock_irq ( & port -> dev_list_lock ) ; sas_put_device ( dev ) ; port -> port_dev = NULL ; } <S2SV_StartBug> SAS_DPRINTK ( \"DONE<S2SV_blank>DISCOVERY<S2SV_blank>on<S2SV_blank>port<S2SV_blank>%d,<S2SV_blank>pid:%d,<S2SV_blank>result:%d\\\\n\" , port -> id , <S2SV_EndBug> task_pid_nr ( current ) , error ) ; }\n","target":"<S2SV_ModStart> NULL ; } sas_probe_devices ( port ) ;\n","project_and_commit_id":"torvalds@linux/0558f33c06bb910e2879e355192227a8e8f0219d","cve_id":"CVE-2017-18232","original_address":"https://github.com/torvalds/linux/commit/0558f33c06bb910e2879e355192227a8e8f0219d","time":"2018-03-15T04:29Z"},
	{"Unnamed: 0":1814,"cwe_id":"CWE-399","source":"CWE-399 int genl_register_family ( struct genl_family * family ) { int err , i ; int start = GENL_START_ALLOC , end = GENL_MAX_ID ; err = genl_validate_ops ( family ) ; if ( err ) return err ; genl_lock_all ( ) ; if ( genl_family_find_byname ( family -> name ) ) { err = - EEXIST ; goto errout_locked ; } if ( family == & genl_ctrl ) { start = end = GENL_ID_CTRL ; } else if ( strcmp ( family -> name , \"pmcraid\" ) == 0 ) { start = end = GENL_ID_PMCRAID ; } else if ( strcmp ( family -> name , \"VFS_DQUOT\" ) == 0 ) { start = end = GENL_ID_VFS_DQUOT ; } if ( family -> maxattr && ! family -> parallel_ops ) { family -> attrbuf = kmalloc_array ( family -> maxattr + 1 , sizeof ( struct nlattr * ) , GFP_KERNEL ) ; if ( family -> attrbuf == NULL ) { err = - ENOMEM ; goto errout_locked ; } } else family -> attrbuf = NULL ; family -> id = idr_alloc ( & genl_fam_idr , family , start , end + 1 , GFP_KERNEL ) ; if ( family -> id < 0 ) { err = family -> id ; <S2SV_StartBug> goto errout_locked ; <S2SV_EndBug> } err = genl_validate_assign_mc_groups ( family ) ; if ( err ) goto errout_remove ; genl_unlock_all ( ) ; genl_ctrl_event ( CTRL_CMD_NEWFAMILY , family , NULL , 0 ) ; for ( i = 0 ; i < family -> n_mcgrps ; i ++ ) genl_ctrl_event ( CTRL_CMD_NEWMCAST_GRP , family , & family -> mcgrps [ i ] , family -> mcgrp_offset + i ) ; return 0 ; errout_remove : idr_remove ( & genl_fam_idr , family -> id ) ; <S2SV_StartBug> kfree ( family -> attrbuf ) ; <S2SV_EndBug> errout_locked : genl_unlock_all ( ) ; return err ; }\n","target":"<S2SV_ModStart> id ; goto errout_free <S2SV_ModEnd> ; } err <S2SV_ModStart> id ) ; errout_free :\n","project_and_commit_id":"torvalds@linux/ceabee6c59943bdd5e1da1a6a20dc7ee5f8113a2","cve_id":"CVE-2019-15921","original_address":"https://github.com/torvalds/linux/commit/ceabee6c59943bdd5e1da1a6a20dc7ee5f8113a2","time":"2019-09-04T19:15Z"},
	{"Unnamed: 0":1369,"cwe_id":"CWE-189","source":"CWE-189 static Image * ExtractPostscript ( Image * image , const ImageInfo * image_info , MagickOffsetType PS_Offset , ssize_t PS_Size , ExceptionInfo * exception ) { char postscript_file [ MaxTextExtent ] ; const MagicInfo * magic_info ; FILE * ps_file ; ImageInfo * clone_info ; Image * image2 ; unsigned char magick [ 2 * MaxTextExtent ] ; if ( ( clone_info = CloneImageInfo ( image_info ) ) == NULL ) return ( image ) ; clone_info -> blob = ( void * ) NULL ; clone_info -> length = 0 ; ( void ) AcquireUniqueFilename ( postscript_file ) ; ps_file = fopen_utf8 ( postscript_file , \"wb\" ) ; if ( ps_file == ( FILE * ) NULL ) goto FINISH ; ( void ) SeekBlob ( image , PS_Offset , SEEK_SET ) ; ( void ) ReadBlob ( image , 2 * MaxTextExtent , magick ) ; ( void ) SeekBlob ( image , PS_Offset , SEEK_SET ) ; while ( PS_Size -- > 0 ) { ( void ) fputc ( ReadBlobByte ( image ) , ps_file ) ; } ( void ) fclose ( ps_file ) ; magic_info = GetMagicInfo ( magick , 2 * MaxTextExtent , exception ) ; if ( magic_info == ( const MagicInfo * ) NULL ) goto FINISH_UNL ; if ( exception -> severity != UndefinedException ) goto FINISH_UNL ; if ( magic_info -> name == ( char * ) NULL ) goto FINISH_UNL ; <S2SV_StartBug> ( void ) strncpy ( clone_info -> magick , magic_info -> name , MaxTextExtent ) ; <S2SV_EndBug> FormatLocaleString ( clone_info -> filename , MaxTextExtent , \"%s\" , postscript_file ) ; image2 = ReadImage ( clone_info , exception ) ; if ( ! image2 ) goto FINISH_UNL ; ( void ) CopyMagickString ( image2 -> filename , image -> filename , MaxTextExtent ) ; ( void ) CopyMagickString ( image2 -> magick_filename , image -> magick_filename , MaxTextExtent ) ; ( void ) CopyMagickString ( image2 -> magick , image -> magick , MaxTextExtent ) ; image2 -> depth = image -> depth ; DestroyBlob ( image2 ) ; image2 -> blob = ReferenceBlob ( image -> blob ) ; if ( ( image -> rows == 0 ) || ( image -> columns == 0 ) ) DeleteImageFromList ( & image ) ; AppendImageToList ( & image , image2 ) ; FINISH_UNL : ( void ) RelinquishUniqueFileResource ( postscript_file ) ; FINISH : DestroyImageInfo ( clone_info ) ; return ( image ) ; }\n","target":"<S2SV_ModStart> name , MaxTextExtent - 1\n","project_and_commit_id":"ImageMagick@ImageMagick/d23beebe7b1179fb75db1e85fbca3100e49593d9","cve_id":"CVE-2016-10145","original_address":"https://github.com/ImageMagick/ImageMagick/commit/d23beebe7b1179fb75db1e85fbca3100e49593d9","time":"2017-03-24T15:59Z"},
	{"Unnamed: 0":2875,"cwe_id":"CWE-264","source":"CWE-264 int do_set_thread_area ( struct task_struct * p , int idx , struct user_desc __user * u_info , int can_allocate ) { struct user_desc info ; if ( copy_from_user ( & info , u_info , sizeof ( info ) ) ) <S2SV_StartBug> return - EFAULT ; <S2SV_EndBug> if ( idx == - 1 ) idx = info . entry_number ; if ( idx == - 1 && can_allocate ) { idx = get_free_idx ( ) ; if ( idx < 0 ) return idx ; if ( put_user ( idx , & u_info -> entry_number ) ) return - EFAULT ; } if ( idx < GDT_ENTRY_TLS_MIN || idx > GDT_ENTRY_TLS_MAX ) return - EINVAL ; set_tls_desc ( p , idx , & info , 1 ) ; return 0 ; }\n","target":"<S2SV_ModStart> return - EFAULT ; if ( ! tls_desc_okay ( & info ) ) return - EINVAL\n","project_and_commit_id":"torvalds@linux/41bdc78544b8a93a9c6814b8bbbfef966272abbe","cve_id":"CVE-2014-8133","original_address":"https://github.com/torvalds/linux/commit/41bdc78544b8a93a9c6814b8bbbfef966272abbe","time":"2014-12-17T11:59Z"},
	{"Unnamed: 0":1578,"cwe_id":"CWE-476","source":"CWE-476 static int crypto_skcipher_init_tfm ( struct crypto_tfm * tfm ) { struct crypto_skcipher * skcipher = __crypto_skcipher_cast ( tfm ) ; struct skcipher_alg * alg = crypto_skcipher_alg ( skcipher ) ; if ( tfm -> __crt_alg -> cra_type == & crypto_blkcipher_type ) return crypto_init_skcipher_ops_blkcipher ( tfm ) ; if ( tfm -> __crt_alg -> cra_type == & crypto_ablkcipher_type || tfm -> __crt_alg -> cra_type == & crypto_givcipher_type ) return crypto_init_skcipher_ops_ablkcipher ( tfm ) ; <S2SV_StartBug> skcipher -> setkey = alg -> setkey ; <S2SV_EndBug> skcipher -> encrypt = alg -> encrypt ; skcipher -> decrypt = alg -> decrypt ; skcipher -> ivsize = alg -> ivsize ; skcipher -> keysize = alg -> max_keysize ; if ( alg -> exit ) skcipher -> base . exit = crypto_skcipher_exit_tfm ; if ( alg -> init ) return alg -> init ( skcipher ) ; return 0 ; }\n","target":"<S2SV_ModStart> -> setkey = skcipher_setkey <S2SV_ModEnd> ; skcipher ->\n","project_and_commit_id":"torvalds@linux/9933e113c2e87a9f46a40fde8dafbf801dca1ab9","cve_id":"CVE-2017-9211","original_address":"https://github.com/torvalds/linux/commit/9933e113c2e87a9f46a40fde8dafbf801dca1ab9","time":"2017-05-23T05:29Z"},
	{"Unnamed: 0":4366,"cwe_id":"CWE-20","source":"CWE-20 static int unix_stream_recvmsg ( struct kiocb * iocb , struct socket * sock , struct msghdr * msg , size_t size , int flags ) { struct sock_iocb * siocb = kiocb_to_siocb ( iocb ) ; struct scm_cookie tmp_scm ; struct sock * sk = sock -> sk ; struct unix_sock * u = unix_sk ( sk ) ; struct sockaddr_un * sunaddr = msg -> msg_name ; int copied = 0 ; int check_creds = 0 ; int target ; int err = 0 ; long timeo ; int skip ; err = - EINVAL ; if ( sk -> sk_state != TCP_ESTABLISHED ) goto out ; err = - EOPNOTSUPP ; if ( flags & MSG_OOB ) goto out ; target = sock_rcvlowat ( sk , flags & MSG_WAITALL , size ) ; timeo = sock_rcvtimeo ( sk , flags & MSG_DONTWAIT ) ; <S2SV_StartBug> msg -> msg_namelen = 0 ; <S2SV_EndBug> if ( ! siocb -> scm ) { siocb -> scm = & tmp_scm ; memset ( & tmp_scm , 0 , sizeof ( tmp_scm ) ) ; } err = mutex_lock_interruptible ( & u -> readlock ) ; if ( err ) { err = sock_intr_errno ( timeo ) ; goto out ; } do { int chunk ; struct sk_buff * skb , * last ; unix_state_lock ( sk ) ; last = skb = skb_peek ( & sk -> sk_receive_queue ) ; again : if ( skb == NULL ) { unix_sk ( sk ) -> recursion_level = 0 ; if ( copied >= target ) goto unlock ; err = sock_error ( sk ) ; if ( err ) goto unlock ; if ( sk -> sk_shutdown & RCV_SHUTDOWN ) goto unlock ; unix_state_unlock ( sk ) ; err = - EAGAIN ; if ( ! timeo ) break ; mutex_unlock ( & u -> readlock ) ; timeo = unix_stream_data_wait ( sk , timeo , last ) ; if ( signal_pending ( current ) || mutex_lock_interruptible ( & u -> readlock ) ) { err = sock_intr_errno ( timeo ) ; goto out ; } continue ; unlock : unix_state_unlock ( sk ) ; break ; } skip = sk_peek_offset ( sk , flags ) ; while ( skip >= unix_skb_len ( skb ) ) { skip -= unix_skb_len ( skb ) ; last = skb ; skb = skb_peek_next ( skb , & sk -> sk_receive_queue ) ; if ( ! skb ) goto again ; } unix_state_unlock ( sk ) ; if ( check_creds ) { if ( ( UNIXCB ( skb ) . pid != siocb -> scm -> pid ) || ! uid_eq ( UNIXCB ( skb ) . uid , siocb -> scm -> creds . uid ) || ! gid_eq ( UNIXCB ( skb ) . gid , siocb -> scm -> creds . gid ) ) break ; } else if ( test_bit ( SOCK_PASSCRED , & sock -> flags ) ) { scm_set_cred ( siocb -> scm , UNIXCB ( skb ) . pid , UNIXCB ( skb ) . uid , UNIXCB ( skb ) . gid ) ; check_creds = 1 ; } if ( sunaddr ) { unix_copy_addr ( msg , skb -> sk ) ; sunaddr = NULL ; } chunk = min_t ( unsigned int , unix_skb_len ( skb ) - skip , size ) ; if ( skb_copy_datagram_iovec ( skb , UNIXCB ( skb ) . consumed + skip , msg -> msg_iov , chunk ) ) { if ( copied == 0 ) copied = - EFAULT ; break ; } copied += chunk ; size -= chunk ; if ( ! ( flags & MSG_PEEK ) ) { UNIXCB ( skb ) . consumed += chunk ; sk_peek_offset_bwd ( sk , chunk ) ; if ( UNIXCB ( skb ) . fp ) unix_detach_fds ( siocb -> scm , skb ) ; if ( unix_skb_len ( skb ) ) break ; skb_unlink ( skb , & sk -> sk_receive_queue ) ; consume_skb ( skb ) ; if ( siocb -> scm -> fp ) break ; } else { if ( UNIXCB ( skb ) . fp ) siocb -> scm -> fp = scm_fp_dup ( UNIXCB ( skb ) . fp ) ; sk_peek_offset_fwd ( sk , chunk ) ; break ; } } while ( size ) ; mutex_unlock ( & u -> readlock ) ; scm_recv ( sock , msg , siocb -> scm , flags ) ; out : return copied ? : err ; }\n","target":"<S2SV_ModStart> MSG_DONTWAIT ) ; <S2SV_ModEnd> if ( !\n","project_and_commit_id":"torvalds@linux/f3d3342602f8bcbf37d7c46641cb9bca7618eb1c","cve_id":"CVE-2013-7271","original_address":"https://github.com/torvalds/linux/commit/f3d3342602f8bcbf37d7c46641cb9bca7618eb1c","time":"2014-01-06T16:55Z"},
	{"Unnamed: 0":2685,"cwe_id":"CWE-119","source":"CWE-119 u32 h264bsdActivateParamSets ( storage_t * pStorage , u32 ppsId , u32 isIdr ) { u32 tmp ; u32 flag ; ASSERT ( pStorage ) ; ASSERT ( ppsId < MAX_NUM_PIC_PARAM_SETS ) ; if ( ( pStorage -> pps [ ppsId ] == NULL ) || ( pStorage -> sps [ pStorage -> pps [ ppsId ] -> seqParameterSetId ] == NULL ) ) { return ( HANTRO_NOK ) ; } tmp = CheckPps ( pStorage -> pps [ ppsId ] , pStorage -> sps [ pStorage -> pps [ ppsId ] -> seqParameterSetId ] ) ; if ( tmp != HANTRO_OK ) return ( tmp ) ; if ( pStorage -> activePpsId == MAX_NUM_PIC_PARAM_SETS ) { pStorage -> activePpsId = ppsId ; pStorage -> activePps = pStorage -> pps [ ppsId ] ; pStorage -> activeSpsId = pStorage -> activePps -> seqParameterSetId ; pStorage -> activeSps = pStorage -> sps [ pStorage -> activeSpsId ] ; <S2SV_StartBug> pStorage -> picSizeInMbs = <S2SV_EndBug> pStorage -> activeSps -> picWidthInMbs * <S2SV_StartBug> pStorage -> activeSps -> picHeightInMbs ; <S2SV_EndBug> pStorage -> currImage -> width = pStorage -> activeSps -> picWidthInMbs ; pStorage -> currImage -> height = pStorage -> activeSps -> picHeightInMbs ; pStorage -> pendingActivation = HANTRO_TRUE ; } else if ( pStorage -> pendingActivation ) { pStorage -> pendingActivation = HANTRO_FALSE ; FREE ( pStorage -> mb ) ; FREE ( pStorage -> sliceGroupMap ) ; ALLOCATE ( pStorage -> mb , pStorage -> picSizeInMbs , mbStorage_t ) ; ALLOCATE ( pStorage -> sliceGroupMap , pStorage -> picSizeInMbs , u32 ) ; if ( pStorage -> mb == NULL || pStorage -> sliceGroupMap == NULL ) return ( MEMORY_ALLOCATION_ERROR ) ; H264SwDecMemset ( pStorage -> mb , 0 , pStorage -> picSizeInMbs * sizeof ( mbStorage_t ) ) ; h264bsdInitMbNeighbours ( pStorage -> mb , pStorage -> activeSps -> picWidthInMbs , pStorage -> picSizeInMbs ) ; if ( pStorage -> noReordering || pStorage -> activeSps -> picOrderCntType == 2 || ( pStorage -> activeSps -> vuiParametersPresentFlag && pStorage -> activeSps -> vuiParameters -> bitstreamRestrictionFlag && ! pStorage -> activeSps -> vuiParameters -> numReorderFrames ) ) flag = HANTRO_TRUE ; else flag = HANTRO_FALSE ; tmp = h264bsdResetDpb ( pStorage -> dpb , pStorage -> activeSps -> picWidthInMbs * pStorage -> activeSps -> picHeightInMbs , pStorage -> activeSps -> maxDpbSize , pStorage -> activeSps -> numRefFrames , pStorage -> activeSps -> maxFrameNum , flag ) ; if ( tmp != HANTRO_OK ) return ( tmp ) ; } else if ( ppsId != pStorage -> activePpsId ) { if ( pStorage -> pps [ ppsId ] -> seqParameterSetId != pStorage -> activeSpsId ) { DEBUG ( ( \"SEQ<S2SV_blank>PARAM<S2SV_blank>SET<S2SV_blank>CHANGING...\\\\n\" ) ) ; if ( isIdr ) { pStorage -> activePpsId = ppsId ; pStorage -> activePps = pStorage -> pps [ ppsId ] ; pStorage -> activeSpsId = pStorage -> activePps -> seqParameterSetId ; pStorage -> activeSps = pStorage -> sps [ pStorage -> activeSpsId ] ; pStorage -> picSizeInMbs = pStorage -> activeSps -> picWidthInMbs * pStorage -> activeSps -> picHeightInMbs ; pStorage -> currImage -> width = pStorage -> activeSps -> picWidthInMbs ; pStorage -> currImage -> height = pStorage -> activeSps -> picHeightInMbs ; pStorage -> pendingActivation = HANTRO_TRUE ; } else { DEBUG ( ( \"TRYING<S2SV_blank>TO<S2SV_blank>CHANGE<S2SV_blank>SPS<S2SV_blank>IN<S2SV_blank>NON-IDR<S2SV_blank>SLICE\\\\n\" ) ) ; return ( HANTRO_NOK ) ; } } else { pStorage -> activePpsId = ppsId ; pStorage -> activePps = pStorage -> pps [ ppsId ] ; } } return ( HANTRO_OK ) ; }\n","target":"<S2SV_ModStart> activeSpsId ] ; if ( pStorage -> activeSps -> picWidthInMbs == 0 ) { pStorage -> picSizeInMbs = 0 ; } else if ( pStorage -> activeSps -> picHeightInMbs > UINT32_MAX / pStorage -> activeSps -> picWidthInMbs ) { return ( MEMORY_ALLOCATION_ERROR ) ; } else { <S2SV_ModStart> -> picHeightInMbs ; }\n","project_and_commit_id":"frameworks@av/60547808ca4e9cfac50028c00c58a6ceb2319301","cve_id":"CVE-2016-2507","original_address":"https://android.googlesource.com/platform/frameworks/av/+/60547808ca4e9cfac50028c00c58a6ceb2319301","time":"2016-07-11T01:59Z"},
	{"Unnamed: 0":3795,"cwe_id":"CWE-20","source":"CWE-20 static int wb_prep ( netdissect_options * ndo , const struct pkt_prep * prep , u_int len ) { int n ; const struct pgstate * ps ; const u_char * ep = ndo -> ndo_snapend ; ND_PRINT ( ( ndo , \"<S2SV_blank>wb-prep:\" ) ) ; if ( len < sizeof ( * prep ) ) { return ( - 1 ) ; } n = EXTRACT_32BITS ( & prep -> pp_n ) ; ps = ( const struct pgstate * ) ( prep + 1 ) ; <S2SV_StartBug> while ( -- n >= 0 && ! ND_TTEST ( * ps ) ) { <S2SV_EndBug> const struct id_off * io , * ie ; char c = '<' ; ND_PRINT ( ( ndo , \"<S2SV_blank>%u/%s:%u\" , EXTRACT_32BITS ( & ps -> slot ) , ipaddr_string ( ndo , & ps -> page . p_sid ) , EXTRACT_32BITS ( & ps -> page . p_uid ) ) ) ; io = ( struct id_off * ) ( ps + 1 ) ; <S2SV_StartBug> for ( ie = io + ps -> nid ; io < ie && ! ND_TTEST ( * io ) ; ++ io ) { <S2SV_EndBug> ND_PRINT ( ( ndo , \"%c%s:%u\" , c , ipaddr_string ( ndo , & io -> id ) , EXTRACT_32BITS ( & io -> off ) ) ) ; c = ',' ; } ND_PRINT ( ( ndo , \">\" ) ) ; ps = ( struct pgstate * ) io ; } return ( ( u_char * ) ps <= ep ? 0 : - 1 ) ; }\n","target":"<S2SV_ModStart> >= 0 && <S2SV_ModEnd> ND_TTEST ( * <S2SV_ModStart> < ie && <S2SV_ModEnd> ND_TTEST ( *\n","project_and_commit_id":"the-tcpdump-group@tcpdump/3ed82f4ed0095768529afc22b923c8f7171fff70","cve_id":"CVE-2015-3138","original_address":"https://github.com/the-tcpdump-group/tcpdump/commit/3ed82f4ed0095768529afc22b923c8f7171fff70","time":"2017-09-28T01:29Z"},
	{"Unnamed: 0":3327,"cwe_id":"CWE-284","source":"CWE-284 static int tcp_v6_do_rcv ( struct sock * sk , struct sk_buff * skb ) { struct ipv6_pinfo * np = inet6_sk ( sk ) ; struct tcp_sock * tp ; struct sk_buff * opt_skb = NULL ; if ( skb -> protocol == htons ( ETH_P_IP ) ) return tcp_v4_do_rcv ( sk , skb ) ; <S2SV_StartBug> if ( sk_filter ( sk , skb ) ) <S2SV_EndBug> goto discard ; if ( np -> rxopt . all ) opt_skb = skb_clone ( skb , sk_gfp_mask ( sk , GFP_ATOMIC ) ) ; if ( sk -> sk_state == TCP_ESTABLISHED ) { struct dst_entry * dst = sk -> sk_rx_dst ; sock_rps_save_rxhash ( sk , skb ) ; sk_mark_napi_id ( sk , skb ) ; if ( dst ) { if ( inet_sk ( sk ) -> rx_dst_ifindex != skb -> skb_iif || dst -> ops -> check ( dst , np -> rx_dst_cookie ) == NULL ) { dst_release ( dst ) ; sk -> sk_rx_dst = NULL ; } } tcp_rcv_established ( sk , skb , tcp_hdr ( skb ) , skb -> len ) ; if ( opt_skb ) goto ipv6_pktoptions ; return 0 ; } if ( tcp_checksum_complete ( skb ) ) goto csum_err ; if ( sk -> sk_state == TCP_LISTEN ) { struct sock * nsk = tcp_v6_cookie_check ( sk , skb ) ; if ( ! nsk ) goto discard ; if ( nsk != sk ) { sock_rps_save_rxhash ( nsk , skb ) ; sk_mark_napi_id ( nsk , skb ) ; if ( tcp_child_process ( sk , nsk , skb ) ) goto reset ; if ( opt_skb ) __kfree_skb ( opt_skb ) ; return 0 ; } } else sock_rps_save_rxhash ( sk , skb ) ; if ( tcp_rcv_state_process ( sk , skb ) ) goto reset ; if ( opt_skb ) goto ipv6_pktoptions ; return 0 ; reset : tcp_v6_send_reset ( sk , skb ) ; discard : if ( opt_skb ) __kfree_skb ( opt_skb ) ; kfree_skb ( skb ) ; return 0 ; csum_err : TCP_INC_STATS ( sock_net ( sk ) , TCP_MIB_CSUMERRORS ) ; TCP_INC_STATS ( sock_net ( sk ) , TCP_MIB_INERRS ) ; goto discard ; ipv6_pktoptions : tp = tcp_sk ( sk ) ; if ( TCP_SKB_CB ( opt_skb ) -> end_seq == tp -> rcv_nxt && ! ( ( 1 << sk -> sk_state ) & ( TCPF_CLOSE | TCPF_LISTEN ) ) ) { if ( np -> rxopt . bits . rxinfo || np -> rxopt . bits . rxoinfo ) np -> mcast_oif = tcp_v6_iif ( opt_skb ) ; if ( np -> rxopt . bits . rxhlim || np -> rxopt . bits . rxohlim ) np -> mcast_hops = ipv6_hdr ( opt_skb ) -> hop_limit ; if ( np -> rxopt . bits . rxflow || np -> rxopt . bits . rxtclass ) np -> rcv_flowinfo = ip6_flowinfo ( ipv6_hdr ( opt_skb ) ) ; if ( np -> repflow ) np -> flow_label = ip6_flowlabel ( ipv6_hdr ( opt_skb ) ) ; if ( ipv6_opt_accepted ( sk , opt_skb , & TCP_SKB_CB ( opt_skb ) -> header . h6 ) ) { skb_set_owner_r ( opt_skb , sk ) ; tcp_v6_restore_cb ( opt_skb ) ; opt_skb = xchg ( & np -> pktoptions , opt_skb ) ; } else { __kfree_skb ( opt_skb ) ; opt_skb = xchg ( & np -> pktoptions , NULL ) ; } } kfree_skb ( opt_skb ) ; return 0 ; }\n","target":"<S2SV_ModStart> ; if ( tcp_filter <S2SV_ModEnd> ( sk ,\n","project_and_commit_id":"torvalds@linux/ac6e780070e30e4c35bd395acfe9191e6268bdd3","cve_id":"CVE-2016-8645","original_address":"https://github.com/torvalds/linux/commit/ac6e780070e30e4c35bd395acfe9191e6268bdd3","time":"2016-11-28T03:59Z"},
	{"Unnamed: 0":4908,"cwe_id":"CWE-772","source":"CWE-772 static inline rsRetVal processBatchMultiRuleset ( batch_t * pBatch ) { ruleset_t * currRuleset ; batch_t snglRuleBatch ; int i ; int iStart ; int iNew ; <S2SV_StartBug> DEFiRet ; <S2SV_EndBug> CHKiRet ( batchInit ( & snglRuleBatch , pBatch -> nElem ) ) ; snglRuleBatch . pbShutdownImmediate = pBatch -> pbShutdownImmediate ; <S2SV_StartBug> while ( 1 ) { <S2SV_EndBug> for ( iStart = 0 ; iStart < pBatch -> nElem && pBatch -> pElem [ iStart ] . state == BATCH_STATE_DISC ; ++ iStart ) ; if ( iStart == pBatch -> nElem ) FINALIZE ; currRuleset = batchElemGetRuleset ( pBatch , iStart ) ; iNew = 0 ; for ( i = iStart ; i < pBatch -> nElem ; ++ i ) { if ( batchElemGetRuleset ( pBatch , i ) == currRuleset ) { batchCopyElem ( & ( snglRuleBatch . pElem [ iNew ++ ] ) , & ( pBatch -> pElem [ i ] ) ) ; pBatch -> pElem [ i ] . state = BATCH_STATE_DISC ; } } snglRuleBatch . nElem = iNew ; batchSetSingleRuleset ( & snglRuleBatch , 1 ) ; processBatch ( & snglRuleBatch ) ; } batchFree ( & snglRuleBatch ) ; finalize_it : RETiRet ; }\n","target":"<S2SV_ModStart> int iNew ; int bHaveUnprocessed ; DEFiRet ; do { bHaveUnprocessed = 0 ; for ( iStart = 0 ; iStart < pBatch -> nElem && pBatch -> pElem [ iStart ] . state == BATCH_STATE_DISC ; ++ iStart ) ; if ( iStart == pBatch -> nElem ) break ; <S2SV_ModEnd> CHKiRet ( batchInit <S2SV_ModStart> -> pbShutdownImmediate ; currRuleset = batchElemGetRuleset ( pBatch , iStart ) ; iNew = 0 ; for ( i = iStart ; i < pBatch -> nElem ; ++ i ) { if ( batchElemGetRuleset ( pBatch , i ) == currRuleset ) { snglRuleBatch . pElem [ iNew ] . pUsrp = pBatch -> pElem [ i ] . pUsrp ; snglRuleBatch . pElem [ iNew ] . state = pBatch -> pElem [ i ] . state ; ++ iNew ; pBatch -> pElem [ i ] . state = BATCH_STATE_DISC ; } else { bHaveUnprocessed = 1 ; } } snglRuleBatch . nElem = iNew ; batchSetSingleRuleset ( & snglRuleBatch , 1 ) ; processBatch ( & snglRuleBatch ) ; batchFree ( & snglRuleBatch ) ; } while ( bHaveUnprocessed == 1 <S2SV_ModEnd> ) ; finalize_it\n","project_and_commit_id":"rsyslog@rsyslog/1ef709cc97d54f74d3fdeb83788cc4b01f4c6a2a","cve_id":"CVE-2011-1490","original_address":"https://github.com/rsyslog/rsyslog/commit/1ef709cc97d54f74d3fdeb83788cc4b01f4c6a2a","time":"2019-11-14T02:15Z"},
	{"Unnamed: 0":4139,"cwe_id":"CWE-000","source":"CWE-000 static void hub_activate ( struct usb_hub * hub , enum hub_activation_type type ) { struct usb_device * hdev = hub -> hdev ; struct usb_hcd * hcd ; int ret ; int port1 ; int status ; bool need_debounce_delay = false ; unsigned delay ; <S2SV_StartBug> if ( type == HUB_INIT2 ) <S2SV_EndBug> goto init2 ; <S2SV_StartBug> if ( type == HUB_INIT3 ) <S2SV_EndBug> goto init3 ; if ( type != HUB_RESUME ) { if ( hdev -> parent && hub_is_superspeed ( hdev ) ) { ret = usb_control_msg ( hdev , usb_sndctrlpipe ( hdev , 0 ) , HUB_SET_DEPTH , USB_RT_HUB , hdev -> level - 1 , 0 , NULL , 0 , USB_CTRL_SET_TIMEOUT ) ; if ( ret < 0 ) dev_err ( hub -> intfdev , \"set<S2SV_blank>hub<S2SV_blank>depth<S2SV_blank>failed\\\\n\" ) ; } if ( type == HUB_INIT ) { delay = hub_power_on_good_delay ( hub ) ; hub_power_on ( hub , false ) ; INIT_DELAYED_WORK ( & hub -> init_work , hub_init_func2 ) ; queue_delayed_work ( system_power_efficient_wq , & hub -> init_work , msecs_to_jiffies ( delay ) ) ; usb_autopm_get_interface_no_resume ( to_usb_interface ( hub -> intfdev ) ) ; return ; } else if ( type == HUB_RESET_RESUME ) { hcd = bus_to_hcd ( hdev -> bus ) ; if ( hcd -> driver -> update_hub_device ) { ret = hcd -> driver -> update_hub_device ( hcd , hdev , & hub -> tt , GFP_NOIO ) ; if ( ret < 0 ) { dev_err ( hub -> intfdev , \"Host<S2SV_blank>not<S2SV_blank>\" \"accepting<S2SV_blank>hub<S2SV_blank>info<S2SV_blank>\" \"update.\\\\n\" ) ; dev_err ( hub -> intfdev , \"LS/FS<S2SV_blank>devices<S2SV_blank>\" \"and<S2SV_blank>hubs<S2SV_blank>may<S2SV_blank>not<S2SV_blank>work<S2SV_blank>\" \"under<S2SV_blank>this<S2SV_blank>hub\\\\n.\" ) ; } } hub_power_on ( hub , true ) ; } else { hub_power_on ( hub , true ) ; } } init2 : for ( port1 = 1 ; port1 <= hdev -> maxchild ; ++ port1 ) { struct usb_port * port_dev = hub -> ports [ port1 - 1 ] ; struct usb_device * udev = port_dev -> child ; u16 portstatus , portchange ; portstatus = portchange = 0 ; status = hub_port_status ( hub , port1 , & portstatus , & portchange ) ; if ( udev || ( portstatus & USB_PORT_STAT_CONNECTION ) ) dev_dbg ( & port_dev -> dev , \"status<S2SV_blank>%04x<S2SV_blank>change<S2SV_blank>%04x\\\\n\" , portstatus , portchange ) ; if ( ( portstatus & USB_PORT_STAT_ENABLE ) && ( type != HUB_RESUME || ! ( portstatus & USB_PORT_STAT_CONNECTION ) || ! udev || udev -> state == USB_STATE_NOTATTACHED ) ) { portstatus &= ~ USB_PORT_STAT_ENABLE ; if ( ! hub_is_superspeed ( hdev ) ) usb_clear_port_feature ( hdev , port1 , USB_PORT_FEAT_ENABLE ) ; } if ( portchange & USB_PORT_STAT_C_CONNECTION ) { need_debounce_delay = true ; usb_clear_port_feature ( hub -> hdev , port1 , USB_PORT_FEAT_C_CONNECTION ) ; } if ( portchange & USB_PORT_STAT_C_ENABLE ) { need_debounce_delay = true ; usb_clear_port_feature ( hub -> hdev , port1 , USB_PORT_FEAT_C_ENABLE ) ; } if ( portchange & USB_PORT_STAT_C_RESET ) { need_debounce_delay = true ; usb_clear_port_feature ( hub -> hdev , port1 , USB_PORT_FEAT_C_RESET ) ; } if ( ( portchange & USB_PORT_STAT_C_BH_RESET ) && hub_is_superspeed ( hub -> hdev ) ) { need_debounce_delay = true ; usb_clear_port_feature ( hub -> hdev , port1 , USB_PORT_FEAT_C_BH_PORT_RESET ) ; } if ( ! ( portstatus & USB_PORT_STAT_CONNECTION ) || ( portchange & USB_PORT_STAT_C_CONNECTION ) ) clear_bit ( port1 , hub -> removed_bits ) ; if ( ! udev || udev -> state == USB_STATE_NOTATTACHED ) { if ( udev || ( portstatus & USB_PORT_STAT_CONNECTION ) || ( portstatus & USB_PORT_STAT_OVERCURRENT ) ) set_bit ( port1 , hub -> change_bits ) ; } else if ( portstatus & USB_PORT_STAT_ENABLE ) { bool port_resumed = ( portstatus & USB_PORT_STAT_LINK_STATE ) == USB_SS_PORT_LS_U0 ; if ( portchange || ( hub_is_superspeed ( hub -> hdev ) && port_resumed ) ) set_bit ( port1 , hub -> change_bits ) ; } else if ( udev -> persist_enabled ) { # ifdef CONFIG_PM udev -> reset_resume = 1 ; # endif if ( test_bit ( port1 , hub -> power_bits ) ) set_bit ( port1 , hub -> change_bits ) ; } else { usb_set_device_state ( udev , USB_STATE_NOTATTACHED ) ; set_bit ( port1 , hub -> change_bits ) ; } } if ( need_debounce_delay ) { delay = HUB_DEBOUNCE_STABLE ; if ( type == HUB_INIT2 ) { INIT_DELAYED_WORK ( & hub -> init_work , hub_init_func3 ) ; queue_delayed_work ( system_power_efficient_wq , & hub -> init_work , msecs_to_jiffies ( delay ) ) ; <S2SV_StartBug> return ; <S2SV_EndBug> } else { msleep ( delay ) ; } } init3 : hub -> quiescing = 0 ; status = usb_submit_urb ( hub -> urb , GFP_NOIO ) ; if ( status < 0 ) dev_err ( hub -> intfdev , \"activate<S2SV_blank>--><S2SV_blank>%d\\\\n\" , status ) ; if ( hub -> has_indicators && blinkenlights ) queue_delayed_work ( system_power_efficient_wq , & hub -> leds , LED_CYCLE_PERIOD ) ; kick_hub_wq ( hub ) ; if ( type <= HUB_INIT3 ) usb_autopm_put_interface_async ( to_usb_interface ( hub -> intfdev ) ) ; <S2SV_StartBug> } <S2SV_EndBug>\n","target":"<S2SV_ModStart> type == HUB_INIT2 || type == HUB_INIT3 ) { device_lock ( hub -> intfdev ) ; if ( hub -> disconnected ) { device_unlock ( hub -> intfdev ) ; kref_put ( & hub -> kref , hub_release ) ; return ; } if ( type == HUB_INIT2 <S2SV_ModStart> goto init2 ; goto init3 ; } kref_get ( & hub -> kref ) <S2SV_ModEnd> ; if ( <S2SV_ModStart> ) ) ; device_unlock ( hub -> intfdev ) ; <S2SV_ModStart> ) ) ; if ( type == HUB_INIT2 || type == HUB_INIT3 ) device_unlock ( hub -> intfdev ) ; kref_put ( & hub -> kref , hub_release ) ;\n","project_and_commit_id":"torvalds@linux/e50293ef9775c5f1cf3fcc093037dd6a8c5684ea","cve_id":"CVE-2015-8816","original_address":"https://github.com/torvalds/linux/commit/e50293ef9775c5f1cf3fcc093037dd6a8c5684ea","time":"2016-04-27T17:59Z"},
	{"Unnamed: 0":5020,"cwe_id":"CWE-362","source":"CWE-362 int rds_sendmsg ( struct socket * sock , struct msghdr * msg , size_t payload_len ) { struct sock * sk = sock -> sk ; struct rds_sock * rs = rds_sk_to_rs ( sk ) ; DECLARE_SOCKADDR ( struct sockaddr_in * , usin , msg -> msg_name ) ; __be32 daddr ; __be16 dport ; struct rds_message * rm = NULL ; struct rds_connection * conn ; int ret = 0 ; int queued = 0 , allocated_mr = 0 ; int nonblock = msg -> msg_flags & MSG_DONTWAIT ; long timeo = sock_sndtimeo ( sk , nonblock ) ; if ( msg -> msg_flags & ~ ( MSG_DONTWAIT | MSG_CMSG_COMPAT ) ) { ret = - EOPNOTSUPP ; goto out ; } if ( msg -> msg_namelen ) { if ( msg -> msg_namelen < sizeof ( * usin ) || usin -> sin_family != AF_INET ) { ret = - EINVAL ; goto out ; } daddr = usin -> sin_addr . s_addr ; dport = usin -> sin_port ; } else { lock_sock ( sk ) ; daddr = rs -> rs_conn_addr ; dport = rs -> rs_conn_port ; release_sock ( sk ) ; } <S2SV_StartBug> if ( daddr == 0 || rs -> rs_bound_addr == 0 ) { <S2SV_EndBug> <S2SV_StartBug> ret = - ENOTCONN ; <S2SV_EndBug> goto out ; <S2SV_StartBug> } <S2SV_EndBug> if ( payload_len > rds_sk_sndbuf ( rs ) ) { ret = - EMSGSIZE ; goto out ; } ret = rds_rm_size ( msg , payload_len ) ; if ( ret < 0 ) goto out ; rm = rds_message_alloc ( ret , GFP_KERNEL ) ; if ( ! rm ) { ret = - ENOMEM ; goto out ; } if ( payload_len ) { rm -> data . op_sg = rds_message_alloc_sgs ( rm , ceil ( payload_len , PAGE_SIZE ) ) ; if ( ! rm -> data . op_sg ) { ret = - ENOMEM ; goto out ; } ret = rds_message_copy_from_user ( rm , & msg -> msg_iter ) ; if ( ret ) goto out ; } rm -> data . op_active = 1 ; rm -> m_daddr = daddr ; if ( rs -> rs_conn && rs -> rs_conn -> c_faddr == daddr ) conn = rs -> rs_conn ; else { conn = rds_conn_create_outgoing ( sock_net ( sock -> sk ) , rs -> rs_bound_addr , daddr , rs -> rs_transport , sock -> sk -> sk_allocation ) ; if ( IS_ERR ( conn ) ) { ret = PTR_ERR ( conn ) ; goto out ; } rs -> rs_conn = conn ; } ret = rds_cmsg_send ( rs , rm , msg , & allocated_mr ) ; if ( ret ) goto out ; if ( rm -> rdma . op_active && ! conn -> c_trans -> xmit_rdma ) { printk_ratelimited ( KERN_NOTICE \"rdma_op<S2SV_blank>%p<S2SV_blank>conn<S2SV_blank>xmit_rdma<S2SV_blank>%p\\\\n\" , & rm -> rdma , conn -> c_trans -> xmit_rdma ) ; ret = - EOPNOTSUPP ; goto out ; } if ( rm -> atomic . op_active && ! conn -> c_trans -> xmit_atomic ) { printk_ratelimited ( KERN_NOTICE \"atomic_op<S2SV_blank>%p<S2SV_blank>conn<S2SV_blank>xmit_atomic<S2SV_blank>%p\\\\n\" , & rm -> atomic , conn -> c_trans -> xmit_atomic ) ; ret = - EOPNOTSUPP ; goto out ; } rds_conn_connect_if_down ( conn ) ; ret = rds_cong_wait ( conn -> c_fcong , dport , nonblock , rs ) ; if ( ret ) { rs -> rs_seen_congestion = 1 ; goto out ; } while ( ! rds_send_queue_rm ( rs , conn , rm , rs -> rs_bound_port , dport , & queued ) ) { rds_stats_inc ( s_send_queue_full ) ; if ( nonblock ) { ret = - EAGAIN ; goto out ; } timeo = wait_event_interruptible_timeout ( * sk_sleep ( sk ) , rds_send_queue_rm ( rs , conn , rm , rs -> rs_bound_port , dport , & queued ) , timeo ) ; rdsdebug ( \"sendmsg<S2SV_blank>woke<S2SV_blank>queued<S2SV_blank>%d<S2SV_blank>timeo<S2SV_blank>%ld\\\\n\" , queued , timeo ) ; if ( timeo > 0 || timeo == MAX_SCHEDULE_TIMEOUT ) continue ; ret = timeo ; if ( ret == 0 ) ret = - ETIMEDOUT ; goto out ; } rds_stats_inc ( s_send_queued ) ; ret = rds_send_xmit ( conn ) ; if ( ret == - ENOMEM || ret == - EAGAIN ) queue_delayed_work ( rds_wq , & conn -> c_send_w , 1 ) ; rds_message_put ( rm ) ; return payload_len ; out : if ( allocated_mr ) rds_rdma_unuse ( rs , rds_rdma_cookie_key ( rm -> m_rdma_cookie ) , 1 ) ; if ( rm ) rds_message_put ( rm ) ; return ret ; }\n","target":"<S2SV_ModStart> ) ; } lock_sock ( sk ) ; <S2SV_ModStart> 0 ) { release_sock ( sk ) ; <S2SV_ModStart> out ; } release_sock ( sk ) ;\n","project_and_commit_id":"torvalds@linux/8c7188b23474cca017b3ef354c4a58456f68303a","cve_id":"CVE-2015-7990","original_address":"https://github.com/torvalds/linux/commit/8c7188b23474cca017b3ef354c4a58456f68303a","time":"2015-12-28T11:59Z"},
	{"Unnamed: 0":2682,"cwe_id":"CWE-674","source":"CWE-674 int yyparse ( void * yyscanner , HEX_LEX_ENVIRONMENT * lex_env ) { int yychar ; YY_INITIAL_VALUE ( static YYSTYPE yyval_default ; ) YYSTYPE yylval YY_INITIAL_VALUE ( = yyval_default ) ; int yynerrs ; int yystate ; int yyerrstatus ; yytype_int16 yyssa [ YYINITDEPTH ] ; yytype_int16 * yyss ; yytype_int16 * yyssp ; YYSTYPE yyvsa [ YYINITDEPTH ] ; YYSTYPE * yyvs ; YYSTYPE * yyvsp ; YYSIZE_T yystacksize ; int yyn ; int yyresult ; int yytoken = 0 ; YYSTYPE yyval ; # if YYERROR_VERBOSE char yymsgbuf [ 128 ] ; char * yymsg = yymsgbuf ; YYSIZE_T yymsg_alloc = sizeof yymsgbuf ; # endif # define YYPOPSTACK ( N ) ( yyvsp -= ( N ) , yyssp -= ( N ) ) int yylen = 0 ; yyssp = yyss = yyssa ; yyvsp = yyvs = yyvsa ; yystacksize = YYINITDEPTH ; YYDPRINTF ( ( stderr , \"Starting<S2SV_blank>parse\\\\n\" ) ) ; yystate = 0 ; yyerrstatus = 0 ; yynerrs = 0 ; yychar = YYEMPTY ; goto yysetstate ; yynewstate : yyssp ++ ; yysetstate : * yyssp = yystate ; if ( yyss + yystacksize - 1 <= yyssp ) { YYSIZE_T yysize = yyssp - yyss + 1 ; # ifdef yyoverflow { YYSTYPE * yyvs1 = yyvs ; yytype_int16 * yyss1 = yyss ; yyoverflow ( YY_ ( \"memory<S2SV_blank>exhausted\" ) , & yyss1 , yysize * sizeof ( * yyssp ) , & yyvs1 , yysize * sizeof ( * yyvsp ) , & yystacksize ) ; yyss = yyss1 ; yyvs = yyvs1 ; } # else # ifndef YYSTACK_RELOCATE goto yyexhaustedlab ; # else if ( YYMAXDEPTH <= yystacksize ) goto yyexhaustedlab ; yystacksize *= 2 ; if ( YYMAXDEPTH < yystacksize ) yystacksize = YYMAXDEPTH ; { yytype_int16 * yyss1 = yyss ; union yyalloc * yyptr = ( union yyalloc * ) YYSTACK_ALLOC ( YYSTACK_BYTES ( yystacksize ) ) ; if ( ! yyptr ) goto yyexhaustedlab ; YYSTACK_RELOCATE ( yyss_alloc , yyss ) ; YYSTACK_RELOCATE ( yyvs_alloc , yyvs ) ; # undef YYSTACK_RELOCATE if ( yyss1 != yyssa ) YYSTACK_FREE ( yyss1 ) ; } # endif # endif yyssp = yyss + yysize - 1 ; yyvsp = yyvs + yysize - 1 ; YYDPRINTF ( ( stderr , \"Stack<S2SV_blank>size<S2SV_blank>increased<S2SV_blank>to<S2SV_blank>%lu\\\\n\" , ( unsigned long int ) yystacksize ) ) ; if ( yyss + yystacksize - 1 <= yyssp ) YYABORT ; } YYDPRINTF ( ( stderr , \"Entering<S2SV_blank>state<S2SV_blank>%d\\\\n\" , yystate ) ) ; if ( yystate == YYFINAL ) YYACCEPT ; goto yybackup ; yybackup : yyn = yypact [ yystate ] ; if ( yypact_value_is_default ( yyn ) ) goto yydefault ; if ( yychar == YYEMPTY ) { YYDPRINTF ( ( stderr , \"Reading<S2SV_blank>a<S2SV_blank>token:<S2SV_blank>\" ) ) ; yychar = yylex ( & yylval , yyscanner , lex_env ) ; } if ( yychar <= YYEOF ) { yychar = yytoken = YYEOF ; YYDPRINTF ( ( stderr , \"Now<S2SV_blank>at<S2SV_blank>end<S2SV_blank>of<S2SV_blank>input.\\\\n\" ) ) ; } else { yytoken = YYTRANSLATE ( yychar ) ; YY_SYMBOL_PRINT ( \"Next<S2SV_blank>token<S2SV_blank>is\" , yytoken , & yylval , & yylloc ) ; } yyn += yytoken ; if ( yyn < 0 || YYLAST < yyn || yycheck [ yyn ] != yytoken ) goto yydefault ; yyn = yytable [ yyn ] ; if ( yyn <= 0 ) { if ( yytable_value_is_error ( yyn ) ) goto yyerrlab ; yyn = - yyn ; goto yyreduce ; } if ( yyerrstatus ) yyerrstatus -- ; YY_SYMBOL_PRINT ( \"Shifting\" , yytoken , & yylval , & yylloc ) ; yychar = YYEMPTY ; yystate = yyn ; YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN * ++ yyvsp = yylval ; YY_IGNORE_MAYBE_UNINITIALIZED_END goto yynewstate ; yydefault : yyn = yydefact [ yystate ] ; if ( yyn == 0 ) goto yyerrlab ; goto yyreduce ; yyreduce : yylen = yyr2 [ yyn ] ; yyval = yyvsp [ 1 - yylen ] ; YY_REDUCE_PRINT ( yyn ) ; switch ( yyn ) { case 2 : <S2SV_StartBug> # line 106 \"hex_grammar.y\" <S2SV_EndBug> { RE_AST * re_ast = yyget_extra ( yyscanner ) ; re_ast -> root_node = ( yyvsp [ - 1 ] . re_node ) ; } <S2SV_StartBug> # line 1330 \"hex_grammar.c\" <S2SV_EndBug> break ; case 3 : <S2SV_StartBug> # line 115 \"hex_grammar.y\" <S2SV_EndBug> { ( yyval . re_node ) = ( yyvsp [ 0 ] . re_node ) ; } <S2SV_StartBug> # line 1338 \"hex_grammar.c\" <S2SV_EndBug> break ; case 4 : <S2SV_StartBug> # line 119 \"hex_grammar.y\" <S2SV_EndBug> { ( yyval . re_node ) = yr_re_node_create ( RE_NODE_CONCAT , ( yyvsp [ - 1 ] . re_node ) , ( yyvsp [ 0 ] . re_node ) ) ; DESTROY_NODE_IF ( ( yyval . re_node ) == NULL , ( yyvsp [ - 1 ] . re_node ) ) ; DESTROY_NODE_IF ( ( yyval . re_node ) == NULL , ( yyvsp [ 0 ] . re_node ) ) ; ERROR_IF ( ( yyval . re_node ) == NULL , ERROR_INSUFFICIENT_MEMORY ) ; } <S2SV_StartBug> # line 1351 \"hex_grammar.c\" <S2SV_EndBug> break ; case 5 : <S2SV_StartBug> # line 128 \"hex_grammar.y\" <S2SV_EndBug> { RE_NODE * new_concat ; RE_NODE * leftmost_concat = NULL ; <S2SV_StartBug> RE_NODE * leftmost_node = ( yyvsp [ - 1 ] . re_node ) ; <S2SV_EndBug> ( yyval . re_node ) = NULL ; while ( leftmost_node -> type == RE_NODE_CONCAT ) { leftmost_concat = leftmost_node ; leftmost_node = leftmost_node -> left ; } new_concat = yr_re_node_create ( RE_NODE_CONCAT , ( yyvsp [ - 2 ] . re_node ) , leftmost_node ) ; if ( new_concat != NULL ) { if ( leftmost_concat != NULL ) { leftmost_concat -> left = new_concat ; ( yyval . re_node ) = yr_re_node_create ( RE_NODE_CONCAT , ( yyvsp [ - 1 ] . re_node ) , ( yyvsp [ 0 ] . re_node ) ) ; } else { ( yyval . re_node ) = yr_re_node_create ( RE_NODE_CONCAT , new_concat , ( yyvsp [ 0 ] . re_node ) ) ; } } DESTROY_NODE_IF ( ( yyval . re_node ) == NULL , ( yyvsp [ - 2 ] . re_node ) ) ; DESTROY_NODE_IF ( ( yyval . re_node ) == NULL , ( yyvsp [ - 1 ] . re_node ) ) ; DESTROY_NODE_IF ( ( yyval . re_node ) == NULL , ( yyvsp [ 0 ] . re_node ) ) ; ERROR_IF ( ( yyval . re_node ) == NULL , ERROR_INSUFFICIENT_MEMORY ) ; } <S2SV_StartBug> # line 1413 \"hex_grammar.c\" <S2SV_EndBug> break ; case 6 : <S2SV_StartBug> # line 190 \"hex_grammar.y\" <S2SV_EndBug> { ( yyval . re_node ) = ( yyvsp [ 0 ] . re_node ) ; } <S2SV_StartBug> # line 1421 \"hex_grammar.c\" <S2SV_EndBug> break ; case 7 : <S2SV_StartBug> # line 194 \"hex_grammar.y\" <S2SV_EndBug> { ( yyval . re_node ) = yr_re_node_create ( RE_NODE_CONCAT , ( yyvsp [ - 1 ] . re_node ) , ( yyvsp [ 0 ] . re_node ) ) ; DESTROY_NODE_IF ( ( yyval . re_node ) == NULL , ( yyvsp [ - 1 ] . re_node ) ) ; DESTROY_NODE_IF ( ( yyval . re_node ) == NULL , ( yyvsp [ 0 ] . re_node ) ) ; ERROR_IF ( ( yyval . re_node ) == NULL , ERROR_INSUFFICIENT_MEMORY ) ; } <S2SV_StartBug> # line 1434 \"hex_grammar.c\" <S2SV_EndBug> break ; case 8 : <S2SV_StartBug> # line 207 \"hex_grammar.y\" <S2SV_EndBug> { ( yyval . re_node ) = ( yyvsp [ 0 ] . re_node ) ; } <S2SV_StartBug> # line 1442 \"hex_grammar.c\" <S2SV_EndBug> break ; case 9 : <S2SV_StartBug> # line 211 \"hex_grammar.y\" <S2SV_EndBug> { ( yyval . re_node ) = ( yyvsp [ 0 ] . re_node ) ; ( yyval . re_node ) -> greedy = FALSE ; } <S2SV_StartBug> # line 1451 \"hex_grammar.c\" <S2SV_EndBug> break ; case 10 : <S2SV_StartBug> # line 220 \"hex_grammar.y\" <S2SV_EndBug> { lex_env -> token_count ++ ; if ( lex_env -> token_count > MAX_HEX_STRING_TOKENS ) { yr_re_node_destroy ( ( yyvsp [ 0 ] . re_node ) ) ; yyerror ( yyscanner , lex_env , \"string<S2SV_blank>too<S2SV_blank>long\" ) ; YYABORT ; } ( yyval . re_node ) = ( yyvsp [ 0 ] . re_node ) ; } <S2SV_StartBug> # line 1468 \"hex_grammar.c\" <S2SV_EndBug> break ; case 11 : <S2SV_StartBug> # line 233 \"hex_grammar.y\" <S2SV_EndBug> { lex_env -> inside_or ++ ; } <S2SV_StartBug> # line 1476 \"hex_grammar.c\" <S2SV_EndBug> break ; case 12 : <S2SV_StartBug> # line 237 \"hex_grammar.y\" <S2SV_EndBug> { ( yyval . re_node ) = ( yyvsp [ - 1 ] . re_node ) ; lex_env -> inside_or -- ; } <S2SV_StartBug> # line 1485 \"hex_grammar.c\" <S2SV_EndBug> break ; case 13 : <S2SV_StartBug> # line 246 \"hex_grammar.y\" <S2SV_EndBug> { if ( ( yyvsp [ - 1 ] . integer ) <= 0 ) { yyerror ( yyscanner , lex_env , \"invalid<S2SV_blank>jump<S2SV_blank>length\" ) ; YYABORT ; } if ( lex_env -> inside_or && ( yyvsp [ - 1 ] . integer ) > STRING_CHAINING_THRESHOLD ) { yyerror ( yyscanner , lex_env , \"jumps<S2SV_blank>over<S2SV_blank>\" STR ( STRING_CHAINING_THRESHOLD ) \"<S2SV_blank>now<S2SV_blank>allowed<S2SV_blank>inside<S2SV_blank>alternation<S2SV_blank>(|)\" ) ; YYABORT ; } ( yyval . re_node ) = yr_re_node_create ( RE_NODE_RANGE_ANY , NULL , NULL ) ; ERROR_IF ( ( yyval . re_node ) == NULL , ERROR_INSUFFICIENT_MEMORY ) ; ( yyval . re_node ) -> start = ( int ) ( yyvsp [ - 1 ] . integer ) ; ( yyval . re_node ) -> end = ( int ) ( yyvsp [ - 1 ] . integer ) ; } <S2SV_StartBug> # line 1512 \"hex_grammar.c\" <S2SV_EndBug> break ; case 14 : <S2SV_StartBug> # line 269 \"hex_grammar.y\" <S2SV_EndBug> { if ( lex_env -> inside_or && ( ( yyvsp [ - 3 ] . integer ) > STRING_CHAINING_THRESHOLD || ( yyvsp [ - 1 ] . integer ) > STRING_CHAINING_THRESHOLD ) ) { yyerror ( yyscanner , lex_env , \"jumps<S2SV_blank>over<S2SV_blank>\" STR ( STRING_CHAINING_THRESHOLD ) \"<S2SV_blank>now<S2SV_blank>allowed<S2SV_blank>inside<S2SV_blank>alternation<S2SV_blank>(|)\" ) ; YYABORT ; } if ( ( yyvsp [ - 3 ] . integer ) < 0 || ( yyvsp [ - 1 ] . integer ) < 0 ) { yyerror ( yyscanner , lex_env , \"invalid<S2SV_blank>negative<S2SV_blank>jump<S2SV_blank>length\" ) ; YYABORT ; } if ( ( yyvsp [ - 3 ] . integer ) > ( yyvsp [ - 1 ] . integer ) ) { yyerror ( yyscanner , lex_env , \"invalid<S2SV_blank>jump<S2SV_blank>range\" ) ; YYABORT ; } ( yyval . re_node ) = yr_re_node_create ( RE_NODE_RANGE_ANY , NULL , NULL ) ; ERROR_IF ( ( yyval . re_node ) == NULL , ERROR_INSUFFICIENT_MEMORY ) ; ( yyval . re_node ) -> start = ( int ) ( yyvsp [ - 3 ] . integer ) ; ( yyval . re_node ) -> end = ( int ) ( yyvsp [ - 1 ] . integer ) ; } <S2SV_StartBug> # line 1548 \"hex_grammar.c\" <S2SV_EndBug> break ; case 15 : <S2SV_StartBug> # line 301 \"hex_grammar.y\" <S2SV_EndBug> { if ( lex_env -> inside_or ) { yyerror ( yyscanner , lex_env , \"unbounded<S2SV_blank>jumps<S2SV_blank>not<S2SV_blank>allowed<S2SV_blank>inside<S2SV_blank>alternation<S2SV_blank>(|)\" ) ; YYABORT ; } if ( ( yyvsp [ - 2 ] . integer ) < 0 ) { yyerror ( yyscanner , lex_env , \"invalid<S2SV_blank>negative<S2SV_blank>jump<S2SV_blank>length\" ) ; YYABORT ; } ( yyval . re_node ) = yr_re_node_create ( RE_NODE_RANGE_ANY , NULL , NULL ) ; ERROR_IF ( ( yyval . re_node ) == NULL , ERROR_INSUFFICIENT_MEMORY ) ; ( yyval . re_node ) -> start = ( int ) ( yyvsp [ - 2 ] . integer ) ; ( yyval . re_node ) -> end = INT_MAX ; } <S2SV_StartBug> # line 1574 \"hex_grammar.c\" <S2SV_EndBug> break ; case 16 : <S2SV_StartBug> # line 323 \"hex_grammar.y\" <S2SV_EndBug> { if ( lex_env -> inside_or ) { yyerror ( yyscanner , lex_env , \"unbounded<S2SV_blank>jumps<S2SV_blank>not<S2SV_blank>allowed<S2SV_blank>inside<S2SV_blank>alternation<S2SV_blank>(|)\" ) ; YYABORT ; } ( yyval . re_node ) = yr_re_node_create ( RE_NODE_RANGE_ANY , NULL , NULL ) ; ERROR_IF ( ( yyval . re_node ) == NULL , ERROR_INSUFFICIENT_MEMORY ) ; ( yyval . re_node ) -> start = 0 ; ( yyval . re_node ) -> end = INT_MAX ; } <S2SV_StartBug> # line 1594 \"hex_grammar.c\" <S2SV_EndBug> break ; case 17 : <S2SV_StartBug> # line 343 \"hex_grammar.y\" <S2SV_EndBug> { ( yyval . re_node ) = ( yyvsp [ 0 ] . re_node ) ; } <S2SV_StartBug> # line 1602 \"hex_grammar.c\" <S2SV_EndBug> break ; case 18 : <S2SV_StartBug> # line 347 \"hex_grammar.y\" <S2SV_EndBug> { mark_as_not_fast_regexp ( ) ; <S2SV_StartBug> ( yyval . re_node ) = yr_re_node_create ( RE_NODE_ALT , ( yyvsp [ - 2 ] . re_node ) , ( yyvsp [ 0 ] . re_node ) ) ; <S2SV_EndBug> DESTROY_NODE_IF ( ( yyval . re_node ) == NULL , ( yyvsp [ - 2 ] . re_node ) ) ; DESTROY_NODE_IF ( ( yyval . re_node ) == NULL , ( yyvsp [ 0 ] . re_node ) ) ; ERROR_IF ( ( yyval . re_node ) == NULL , ERROR_INSUFFICIENT_MEMORY ) ; } <S2SV_StartBug> # line 1617 \"hex_grammar.c\" <S2SV_EndBug> break ; case 19 : <S2SV_StartBug> # line 361 \"hex_grammar.y\" <S2SV_EndBug> { ( yyval . re_node ) = yr_re_node_create ( RE_NODE_LITERAL , NULL , NULL ) ; ERROR_IF ( ( yyval . re_node ) == NULL , ERROR_INSUFFICIENT_MEMORY ) ; ( yyval . re_node ) -> value = ( int ) ( yyvsp [ 0 ] . integer ) ; } <S2SV_StartBug> # line 1629 \"hex_grammar.c\" <S2SV_EndBug> break ; case 20 : <S2SV_StartBug> # line 369 \"hex_grammar.y\" <S2SV_EndBug> { uint8_t mask = ( uint8_t ) ( ( yyvsp [ 0 ] . integer ) >> 8 ) ; if ( mask == 0x00 ) { ( yyval . re_node ) = yr_re_node_create ( RE_NODE_ANY , NULL , NULL ) ; ERROR_IF ( ( yyval . re_node ) == NULL , ERROR_INSUFFICIENT_MEMORY ) ; } else { ( yyval . re_node ) = yr_re_node_create ( RE_NODE_MASKED_LITERAL , NULL , NULL ) ; ERROR_IF ( ( yyval . re_node ) == NULL , ERROR_INSUFFICIENT_MEMORY ) ; ( yyval . re_node ) -> value = ( yyvsp [ 0 ] . integer ) & 0xFF ; ( yyval . re_node ) -> mask = mask ; } } <S2SV_StartBug> # line 1653 \"hex_grammar.c\" <S2SV_EndBug> break ; <S2SV_StartBug> # line 1657 \"hex_grammar.c\" <S2SV_EndBug> default : break ; } YY_SYMBOL_PRINT ( \"-><S2SV_blank>$$<S2SV_blank>=\" , yyr1 [ yyn ] , & yyval , & yyloc ) ; YYPOPSTACK ( yylen ) ; yylen = 0 ; YY_STACK_PRINT ( yyss , yyssp ) ; * ++ yyvsp = yyval ; yyn = yyr1 [ yyn ] ; yystate = yypgoto [ yyn - YYNTOKENS ] + * yyssp ; if ( 0 <= yystate && yystate <= YYLAST && yycheck [ yystate ] == * yyssp ) yystate = yytable [ yystate ] ; else yystate = yydefgoto [ yyn - YYNTOKENS ] ; goto yynewstate ; yyerrlab : yytoken = yychar == YYEMPTY ? YYEMPTY : YYTRANSLATE ( yychar ) ; if ( ! yyerrstatus ) { ++ yynerrs ; # if ! YYERROR_VERBOSE yyerror ( yyscanner , lex_env , YY_ ( \"syntax<S2SV_blank>error\" ) ) ; # else # define YYSYNTAX_ERROR yysyntax_error ( & yymsg_alloc , & yymsg , yyssp , yytoken ) { char const * yymsgp = YY_ ( \"syntax<S2SV_blank>error\" ) ; int yysyntax_error_status ; yysyntax_error_status = YYSYNTAX_ERROR ; if ( yysyntax_error_status == 0 ) yymsgp = yymsg ; else if ( yysyntax_error_status == 1 ) { if ( yymsg != yymsgbuf ) YYSTACK_FREE ( yymsg ) ; yymsg = ( char * ) YYSTACK_ALLOC ( yymsg_alloc ) ; if ( ! yymsg ) { yymsg = yymsgbuf ; yymsg_alloc = sizeof yymsgbuf ; yysyntax_error_status = 2 ; } else { yysyntax_error_status = YYSYNTAX_ERROR ; yymsgp = yymsg ; } } yyerror ( yyscanner , lex_env , yymsgp ) ; if ( yysyntax_error_status == 2 ) goto yyexhaustedlab ; } # undef YYSYNTAX_ERROR # endif } if ( yyerrstatus == 3 ) { if ( yychar <= YYEOF ) { if ( yychar == YYEOF ) YYABORT ; } else { yydestruct ( \"Error:<S2SV_blank>discarding\" , yytoken , & yylval , yyscanner , lex_env ) ; yychar = YYEMPTY ; } } goto yyerrlab1 ; yyerrorlab : if ( 0 ) goto yyerrorlab ; YYPOPSTACK ( yylen ) ; yylen = 0 ; YY_STACK_PRINT ( yyss , yyssp ) ; yystate = * yyssp ; goto yyerrlab1 ; yyerrlab1 : yyerrstatus = 3 ; for ( ; ; ) { yyn = yypact [ yystate ] ; if ( ! yypact_value_is_default ( yyn ) ) { yyn += YYTERROR ; if ( 0 <= yyn && yyn <= YYLAST && yycheck [ yyn ] == YYTERROR ) { yyn = yytable [ yyn ] ; if ( 0 < yyn ) break ; } } if ( yyssp == yyss ) YYABORT ; yydestruct ( \"Error:<S2SV_blank>popping\" , yystos [ yystate ] , yyvsp , yyscanner , lex_env ) ; YYPOPSTACK ( 1 ) ; yystate = * yyssp ; YY_STACK_PRINT ( yyss , yyssp ) ; } YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN * ++ yyvsp = yylval ; YY_IGNORE_MAYBE_UNINITIALIZED_END YY_SYMBOL_PRINT ( \"Shifting\" , yystos [ yyn ] , yyvsp , yylsp ) ; yystate = yyn ; goto yynewstate ; yyacceptlab : yyresult = 0 ; goto yyreturn ; yyabortlab : yyresult = 1 ; goto yyreturn ; # if ! defined yyoverflow || YYERROR_VERBOSE yyexhaustedlab : yyerror ( yyscanner , lex_env , YY_ ( \"memory<S2SV_blank>exhausted\" ) ) ; yyresult = 2 ; # endif yyreturn : if ( yychar != YYEMPTY ) { yytoken = YYTRANSLATE ( yychar ) ; yydestruct ( \"Cleanup:<S2SV_blank>discarding<S2SV_blank>lookahead\" , yytoken , & yylval , yyscanner , lex_env ) ; } YYPOPSTACK ( yylen ) ; YY_STACK_PRINT ( yyss , yyssp ) ; while ( yyssp != yyss ) { yydestruct ( \"Cleanup:<S2SV_blank>popping\" , yystos [ * yyssp ] , yyvsp , yyscanner , lex_env ) ; YYPOPSTACK ( 1 ) ; } # ifndef yyoverflow if ( yyss != yyssa ) YYSTACK_FREE ( yyss ) ; # endif # if YYERROR_VERBOSE if ( yymsg != yymsgbuf ) YYSTACK_FREE ( yymsg ) ; # endif return yyresult ; }\n","target":"<S2SV_ModStart> : # line 113 <S2SV_ModEnd> \"hex_grammar.y\" { RE_AST <S2SV_ModStart> } # line 1337 <S2SV_ModEnd> \"hex_grammar.c\" break ; <S2SV_ModStart> : # line 122 <S2SV_ModEnd> \"hex_grammar.y\" { ( <S2SV_ModStart> } # line 1345 <S2SV_ModEnd> \"hex_grammar.c\" break ; <S2SV_ModStart> : # line 126 \"hex_grammar.y\" { incr_ast_levels ( ) ; <S2SV_ModEnd> ( yyval . <S2SV_ModStart> } # line 1360 <S2SV_ModEnd> \"hex_grammar.c\" break ; <S2SV_ModStart> : # line 137 <S2SV_ModEnd> \"hex_grammar.y\" { RE_NODE <S2SV_ModStart> ] . re_node ) ; incr_ast_levels ( <S2SV_ModStart> } # line 1424 <S2SV_ModEnd> \"hex_grammar.c\" break ; <S2SV_ModStart> : # line 201 <S2SV_ModEnd> \"hex_grammar.y\" { ( <S2SV_ModStart> } # line 1432 <S2SV_ModEnd> \"hex_grammar.c\" break ; <S2SV_ModStart> : # line 205 \"hex_grammar.y\" { incr_ast_levels ( ) ; <S2SV_ModEnd> ( yyval . <S2SV_ModStart> } # line 1447 <S2SV_ModEnd> \"hex_grammar.c\" break ; <S2SV_ModStart> : # line 220 <S2SV_ModEnd> \"hex_grammar.y\" { ( <S2SV_ModStart> } # line 1455 <S2SV_ModEnd> \"hex_grammar.c\" break ; <S2SV_ModStart> : # line 224 <S2SV_ModEnd> \"hex_grammar.y\" { ( <S2SV_ModStart> } # line 1464 <S2SV_ModEnd> \"hex_grammar.c\" break ; <S2SV_ModStart> : # line 233 <S2SV_ModEnd> \"hex_grammar.y\" { lex_env <S2SV_ModStart> } # line 1481 <S2SV_ModEnd> \"hex_grammar.c\" break ; <S2SV_ModStart> : # line 246 <S2SV_ModEnd> \"hex_grammar.y\" { lex_env <S2SV_ModStart> } # line 1489 <S2SV_ModEnd> \"hex_grammar.c\" break ; <S2SV_ModStart> : # line 250 <S2SV_ModEnd> \"hex_grammar.y\" { ( <S2SV_ModStart> } # line 1498 <S2SV_ModEnd> \"hex_grammar.c\" break ; <S2SV_ModStart> : # line 259 <S2SV_ModEnd> \"hex_grammar.y\" { if <S2SV_ModStart> } # line 1525 <S2SV_ModEnd> \"hex_grammar.c\" break ; <S2SV_ModStart> : # line 282 <S2SV_ModEnd> \"hex_grammar.y\" { if <S2SV_ModStart> } # line 1561 <S2SV_ModEnd> \"hex_grammar.c\" break ; <S2SV_ModStart> : # line 314 <S2SV_ModEnd> \"hex_grammar.y\" { if <S2SV_ModStart> } # line 1587 <S2SV_ModEnd> \"hex_grammar.c\" break ; <S2SV_ModStart> : # line 336 <S2SV_ModEnd> \"hex_grammar.y\" { if <S2SV_ModStart> } # line 1607 <S2SV_ModEnd> \"hex_grammar.c\" break ; <S2SV_ModStart> : # line 356 <S2SV_ModEnd> \"hex_grammar.y\" { ( <S2SV_ModStart> } # line 1615 <S2SV_ModEnd> \"hex_grammar.c\" break ; <S2SV_ModStart> : # line 360 <S2SV_ModEnd> \"hex_grammar.y\" { mark_as_not_fast_regexp <S2SV_ModStart> ( ) ; incr_ast_levels ( ) ; <S2SV_ModStart> } # line 1631 <S2SV_ModEnd> \"hex_grammar.c\" break ; <S2SV_ModStart> : # line 375 <S2SV_ModEnd> \"hex_grammar.y\" { ( <S2SV_ModStart> } # line 1643 <S2SV_ModEnd> \"hex_grammar.c\" break ; <S2SV_ModStart> : # line 383 <S2SV_ModEnd> \"hex_grammar.y\" { uint8_t <S2SV_ModStart> } # line 1667 <S2SV_ModEnd> \"hex_grammar.c\" break ; <S2SV_ModStart> ; # line 1671 <S2SV_ModEnd> \"hex_grammar.c\" default :\n","project_and_commit_id":"VirusTotal@yara/10e8bd3071677dd1fa76beeef4bc2fc427cea5e7","cve_id":"CVE-2017-9438","original_address":"https://github.com/VirusTotal/yara/commit/10e8bd3071677dd1fa76beeef4bc2fc427cea5e7","time":"2017-06-05T17:29Z"},
	{"Unnamed: 0":5683,"cwe_id":"CWE-416","source":"CWE-416 void comps_mrtree_unite ( COMPS_MRTree * rt1 , COMPS_MRTree * rt2 ) { COMPS_HSList * tmplist , * tmp_subnodes ; COMPS_HSListItem * it , * it2 ; struct Pair { COMPS_HSList * subnodes ; char * key ; <S2SV_StartBug> char added ; <S2SV_EndBug> } * pair , * parent_pair ; pair = malloc ( sizeof ( struct Pair ) ) ; pair -> subnodes = rt2 -> subnodes ; pair -> key = NULL ; tmplist = comps_hslist_create ( ) ; comps_hslist_init ( tmplist , NULL , NULL , & free ) ; comps_hslist_append ( tmplist , pair , 0 ) ; while ( tmplist -> first != NULL ) { it = tmplist -> first ; comps_hslist_remove ( tmplist , tmplist -> first ) ; tmp_subnodes = ( ( struct Pair * ) it -> data ) -> subnodes ; parent_pair = ( struct Pair * ) it -> data ; free ( it ) ; <S2SV_StartBug> pair -> added = 0 ; <S2SV_EndBug> for ( it = tmp_subnodes -> first ; it != NULL ; it = it -> next ) { pair = malloc ( sizeof ( struct Pair ) ) ; pair -> subnodes = ( ( COMPS_MRTreeData * ) it -> data ) -> subnodes ; if ( parent_pair -> key != NULL ) { pair -> key = malloc ( sizeof ( char ) * ( strlen ( ( ( COMPS_MRTreeData * ) it -> data ) -> key ) + strlen ( parent_pair -> key ) + 1 ) ) ; memcpy ( pair -> key , parent_pair -> key , sizeof ( char ) * strlen ( parent_pair -> key ) ) ; memcpy ( pair -> key + strlen ( parent_pair -> key ) , ( ( COMPS_MRTreeData * ) it -> data ) -> key , sizeof ( char ) * ( strlen ( ( ( COMPS_MRTreeData * ) it -> data ) -> key ) + 1 ) ) ; } else { pair -> key = malloc ( sizeof ( char ) * ( strlen ( ( ( COMPS_MRTreeData * ) it -> data ) -> key ) + 1 ) ) ; memcpy ( pair -> key , ( ( COMPS_MRTreeData * ) it -> data ) -> key , sizeof ( char ) * ( strlen ( ( ( COMPS_MRTreeData * ) it -> data ) -> key ) + 1 ) ) ; } if ( ( ( COMPS_MRTreeData * ) it -> data ) -> data -> first != NULL ) { for ( it2 = ( ( COMPS_MRTreeData * ) it -> data ) -> data -> first ; it2 != NULL ; it2 = it2 -> next ) { comps_mrtree_set ( rt1 , pair -> key , it2 -> data ) ; } if ( ( ( COMPS_MRTreeData * ) it -> data ) -> subnodes -> first ) { comps_hslist_append ( tmplist , pair , 0 ) ; } else { free ( pair -> key ) ; free ( pair ) ; } } else { if ( ( ( COMPS_MRTreeData * ) it -> data ) -> subnodes -> first ) { comps_hslist_append ( tmplist , pair , 0 ) ; } else { free ( pair -> key ) ; free ( pair ) ; } } } free ( parent_pair -> key ) ; free ( parent_pair ) ; } comps_hslist_destroy ( & tmplist ) ; }\n","target":"<S2SV_ModStart> * key ; <S2SV_ModEnd> } * pair <S2SV_ModStart> it ) ; <S2SV_ModEnd> for ( it\n","project_and_commit_id":"rpm-software-management@libcomps/e3a5d056633677959ad924a51758876d415e7046","cve_id":"CVE-2019-3817","original_address":"https://github.com/rpm-software-management/libcomps/commit/e3a5d056633677959ad924a51758876d415e7046","time":"2019-03-27T13:29Z"},
	{"Unnamed: 0":4125,"cwe_id":"CWE-399","source":"CWE-399 static void free_huge_page ( struct page * page ) { struct hstate * h = page_hstate ( page ) ; int nid = page_to_nid ( page ) ; <S2SV_StartBug> struct address_space * mapping ; <S2SV_EndBug> mapping = ( struct address_space * ) page_private ( page ) ; set_page_private ( page , 0 ) ; page -> mapping = NULL ; BUG_ON ( page_count ( page ) ) ; BUG_ON ( page_mapcount ( page ) ) ; INIT_LIST_HEAD ( & page -> lru ) ; spin_lock ( & hugetlb_lock ) ; if ( h -> surplus_huge_pages_node [ nid ] && huge_page_order ( h ) < MAX_ORDER ) { update_and_free_page ( h , page ) ; h -> surplus_huge_pages -- ; h -> surplus_huge_pages_node [ nid ] -- ; } else { enqueue_huge_page ( h , page ) ; } spin_unlock ( & hugetlb_lock ) ; <S2SV_StartBug> if ( mapping ) <S2SV_EndBug> hugetlb_put_quota ( mapping , 1 ) ; }\n","target":"<S2SV_ModStart> ) ; struct hugepage_subpool * spool = ( struct hugepage_subpool <S2SV_ModEnd> * ) page_private <S2SV_ModStart> hugetlb_lock ) ; hugepage_subpool_put_pages ( spool <S2SV_ModEnd> , 1 )\n","project_and_commit_id":"torvalds@linux/90481622d75715bfcb68501280a917dbfe516029","cve_id":"CVE-2012-2133","original_address":"https://github.com/torvalds/linux/commit/90481622d75715bfcb68501280a917dbfe516029","time":"2012-07-03T16:40Z"},
	{"Unnamed: 0":3937,"cwe_id":"CWE-399","source":"CWE-399 static int db_interception ( struct vcpu_svm * svm ) { struct kvm_run * kvm_run = svm -> vcpu . run ; if ( ! ( svm -> vcpu . guest_debug & ( KVM_GUESTDBG_SINGLESTEP | KVM_GUESTDBG_USE_HW_BP ) ) && ! svm -> nmi_singlestep ) { kvm_queue_exception ( & svm -> vcpu , DB_VECTOR ) ; return 1 ; } if ( svm -> nmi_singlestep ) { svm -> nmi_singlestep = false ; if ( ! ( svm -> vcpu . guest_debug & KVM_GUESTDBG_SINGLESTEP ) ) svm -> vmcb -> save . rflags &= ~ ( X86_EFLAGS_TF | X86_EFLAGS_RF ) ; <S2SV_StartBug> update_db_bp_intercept ( & svm -> vcpu ) ; <S2SV_EndBug> } if ( svm -> vcpu . guest_debug & ( KVM_GUESTDBG_SINGLESTEP | KVM_GUESTDBG_USE_HW_BP ) ) { kvm_run -> exit_reason = KVM_EXIT_DEBUG ; kvm_run -> debug . arch . pc = svm -> vmcb -> save . cs . base + svm -> vmcb -> save . rip ; kvm_run -> debug . arch . exception = DB_VECTOR ; return 0 ; } return 1 ; }\n","target":"<S2SV_ModStart> X86_EFLAGS_RF ) ; <S2SV_ModEnd> } if (\n","project_and_commit_id":"torvalds@linux/cbdb967af3d54993f5814f1cee0ed311a055377d","cve_id":"CVE-2015-8104","original_address":"https://github.com/torvalds/linux/commit/cbdb967af3d54993f5814f1cee0ed311a055377d","time":"2015-11-16T11:59Z"},
	{"Unnamed: 0":2696,"cwe_id":"CWE-119","source":"CWE-119 static Image * ReadSUNImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { # define RMT_EQUAL_RGB 1 # define RMT_NONE 0 # define RMT_RAW 2 # define RT_STANDARD 1 # define RT_ENCODED 2 # define RT_FORMAT_RGB 3 typedef struct _SUNInfo { unsigned int magic , width , height , depth , length , type , maptype , maplength ; } SUNInfo ; Image * image ; int bit ; MagickBooleanType status ; MagickSizeType number_pixels ; register Quantum * q ; register ssize_t i , x ; register unsigned char * p ; size_t bytes_per_line , extent , length ; ssize_t count , y ; SUNInfo sun_info ; unsigned char * sun_data , * sun_pixels ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickSignature ) ; if ( image_info -> debug != MagickFalse ) ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , \"%s\" , image_info -> filename ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickSignature ) ; image = AcquireImage ( image_info , exception ) ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } ( void ) ResetMagickMemory ( & sun_info , 0 , sizeof ( sun_info ) ) ; sun_info . magic = ReadBlobMSBLong ( image ) ; do { if ( sun_info . magic != 0x59a66a95 ) ThrowReaderException ( CorruptImageError , \"ImproperImageHeader\" ) ; sun_info . width = ReadBlobMSBLong ( image ) ; sun_info . height = ReadBlobMSBLong ( image ) ; sun_info . depth = ReadBlobMSBLong ( image ) ; sun_info . length = ReadBlobMSBLong ( image ) ; sun_info . type = ReadBlobMSBLong ( image ) ; sun_info . maptype = ReadBlobMSBLong ( image ) ; sun_info . maplength = ReadBlobMSBLong ( image ) ; extent = sun_info . height * sun_info . width ; if ( ( sun_info . height != 0 ) && ( sun_info . width != extent / sun_info . height ) ) ThrowReaderException ( CorruptImageError , \"ImproperImageHeader\" ) ; if ( ( sun_info . type != RT_STANDARD ) && ( sun_info . type != RT_ENCODED ) && ( sun_info . type != RT_FORMAT_RGB ) ) ThrowReaderException ( CorruptImageError , \"ImproperImageHeader\" ) ; if ( ( sun_info . maptype == RMT_NONE ) && ( sun_info . maplength != 0 ) ) ThrowReaderException ( CorruptImageError , \"ImproperImageHeader\" ) ; if ( ( sun_info . depth == 0 ) || ( sun_info . depth > 32 ) ) ThrowReaderException ( CorruptImageError , \"ImproperImageHeader\" ) ; if ( ( sun_info . maptype != RMT_NONE ) && ( sun_info . maptype != RMT_EQUAL_RGB ) && ( sun_info . maptype != RMT_RAW ) ) ThrowReaderException ( CoderError , \"ColormapTypeNotSupported\" ) ; image -> columns = sun_info . width ; image -> rows = sun_info . height ; image -> depth = sun_info . depth <= 8 ? sun_info . depth : MAGICKCORE_QUANTUM_DEPTH ; if ( sun_info . depth < 24 ) { size_t one ; image -> colors = sun_info . maplength ; one = 1 ; if ( sun_info . maptype == RMT_NONE ) image -> colors = one << sun_info . depth ; if ( sun_info . maptype == RMT_EQUAL_RGB ) image -> colors = sun_info . maplength / 3 ; if ( AcquireImageColormap ( image , image -> colors , exception ) == MagickFalse ) ThrowReaderException ( ResourceLimitError , \"MemoryAllocationFailed\" ) ; } switch ( sun_info . maptype ) <S2SV_StartBug> { <S2SV_EndBug> case RMT_EQUAL_RGB : { unsigned char * sun_colormap ; sun_colormap = ( unsigned char * ) AcquireQuantumMemory ( image -> colors , sizeof ( * sun_colormap ) ) ; if ( sun_colormap == ( unsigned char * ) NULL ) ThrowReaderException ( ResourceLimitError , \"MemoryAllocationFailed\" ) ; count = ReadBlob ( image , image -> colors , sun_colormap ) ; if ( count != ( ssize_t ) image -> colors ) ThrowReaderException ( CorruptImageError , \"UnexpectedEndOfFile\" ) ; for ( i = 0 ; i < ( ssize_t ) image -> colors ; i ++ ) image -> colormap [ i ] . red = ( MagickRealType ) ScaleCharToQuantum ( sun_colormap [ i ] ) ; count = ReadBlob ( image , image -> colors , sun_colormap ) ; if ( count != ( ssize_t ) image -> colors ) ThrowReaderException ( CorruptImageError , \"UnexpectedEndOfFile\" ) ; for ( i = 0 ; i < ( ssize_t ) image -> colors ; i ++ ) image -> colormap [ i ] . green = ( MagickRealType ) ScaleCharToQuantum ( sun_colormap [ i ] ) ; count = ReadBlob ( image , image -> colors , sun_colormap ) ; if ( count != ( ssize_t ) image -> colors ) ThrowReaderException ( CorruptImageError , \"UnexpectedEndOfFile\" ) ; for ( i = 0 ; i < ( ssize_t ) image -> colors ; i ++ ) image -> colormap [ i ] . blue = ( MagickRealType ) ScaleCharToQuantum ( sun_colormap [ i ] ) ; sun_colormap = ( unsigned char * ) RelinquishMagickMemory ( sun_colormap ) ; break ; } case RMT_RAW : { unsigned char * sun_colormap ; sun_colormap = ( unsigned char * ) AcquireQuantumMemory ( sun_info . maplength , sizeof ( * sun_colormap ) ) ; if ( sun_colormap == ( unsigned char * ) NULL ) ThrowReaderException ( ResourceLimitError , \"MemoryAllocationFailed\" ) ; count = ReadBlob ( image , sun_info . maplength , sun_colormap ) ; if ( count != ( ssize_t ) sun_info . maplength ) ThrowReaderException ( CorruptImageError , \"UnexpectedEndOfFile\" ) ; sun_colormap = ( unsigned char * ) RelinquishMagickMemory ( sun_colormap ) ; break ; } default : ThrowReaderException ( CoderError , \"ColormapTypeNotSupported\" ) ; } image -> alpha_trait = sun_info . depth == 32 ? BlendPixelTrait : UndefinedPixelTrait ; image -> columns = sun_info . width ; image -> rows = sun_info . height ; if ( image_info -> ping != MagickFalse ) { ( void ) CloseBlob ( image ) ; return ( GetFirstImageInList ( image ) ) ; } status = SetImageExtent ( image , image -> columns , image -> rows , exception ) ; if ( status == MagickFalse ) return ( DestroyImageList ( image ) ) ; if ( ( sun_info . length * sizeof ( * sun_data ) ) / sizeof ( * sun_data ) != sun_info . length || ! sun_info . length ) ThrowReaderException ( ResourceLimitError , \"MemoryAllocationFailed\" ) ; number_pixels = ( MagickSizeType ) image -> columns * image -> rows ; if ( ( sun_info . type != RT_ENCODED ) && ( sun_info . depth >= 8 ) && ( ( number_pixels * ( ( sun_info . depth + 7 ) / 8 ) ) > sun_info . length ) ) ThrowReaderException ( CorruptImageError , \"ImproperImageHeader\" ) ; bytes_per_line = sun_info . width * sun_info . depth ; sun_data = ( unsigned char * ) AcquireQuantumMemory ( ( size_t ) MagickMax ( sun_info . length , bytes_per_line * sun_info . width ) , sizeof ( * sun_data ) ) ; if ( sun_data == ( unsigned char * ) NULL ) ThrowReaderException ( ResourceLimitError , \"MemoryAllocationFailed\" ) ; count = ( ssize_t ) ReadBlob ( image , sun_info . length , sun_data ) ; if ( count != ( ssize_t ) sun_info . length ) ThrowReaderException ( CorruptImageError , \"UnableToReadImageData\" ) ; sun_pixels = sun_data ; bytes_per_line = 0 ; if ( sun_info . type == RT_ENCODED ) { size_t height ; height = sun_info . height ; if ( ( height == 0 ) || ( sun_info . width == 0 ) || ( sun_info . depth == 0 ) || ( ( bytes_per_line / sun_info . depth ) != sun_info . width ) ) ThrowReaderException ( ResourceLimitError , \"MemoryAllocationFailed\" ) ; bytes_per_line += 15 ; bytes_per_line <<= 1 ; if ( ( bytes_per_line >> 1 ) != ( sun_info . width * sun_info . depth + 15 ) ) ThrowReaderException ( ResourceLimitError , \"MemoryAllocationFailed\" ) ; bytes_per_line >>= 4 ; sun_pixels = ( unsigned char * ) AcquireQuantumMemory ( height , bytes_per_line * sizeof ( * sun_pixels ) ) ; if ( sun_pixels == ( unsigned char * ) NULL ) ThrowReaderException ( ResourceLimitError , \"MemoryAllocationFailed\" ) ; ( void ) DecodeImage ( sun_data , sun_info . length , sun_pixels , bytes_per_line * height ) ; sun_data = ( unsigned char * ) RelinquishMagickMemory ( sun_data ) ; } p = sun_pixels ; if ( sun_info . depth == 1 ) for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; for ( x = 0 ; x < ( ( ssize_t ) image -> columns - 7 ) ; x += 8 ) { for ( bit = 7 ; bit >= 0 ; bit -- ) { SetPixelIndex ( image , ( Quantum ) ( ( * p ) & ( 0x01 << bit ) ? 0x00 : 0x01 ) , q ) ; q += GetPixelChannels ( image ) ; } p ++ ; } if ( ( image -> columns % 8 ) != 0 ) { for ( bit = 7 ; bit >= ( int ) ( 8 - ( image -> columns % 8 ) ) ; bit -- ) { SetPixelIndex ( image , ( Quantum ) ( ( * p ) & ( 0x01 << bit ) ? 0x00 : 0x01 ) , q ) ; q += GetPixelChannels ( image ) ; } p ++ ; } if ( ( ( ( image -> columns / 8 ) + ( image -> columns % 8 ? 1 : 0 ) ) % 2 ) != 0 ) p ++ ; if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ; if ( status == MagickFalse ) break ; } } else if ( image -> storage_class == PseudoClass ) { if ( bytes_per_line == 0 ) bytes_per_line = image -> columns ; length = image -> rows * ( image -> columns + image -> columns % 2 ) ; if ( ( ( sun_info . type == RT_ENCODED ) && ( length > ( bytes_per_line * image -> rows ) ) ) || ( ( sun_info . type != RT_ENCODED ) && ( length > sun_info . length ) ) ) ThrowReaderException ( CorruptImageError , \"UnableToReadImageData\" ) ; for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { SetPixelIndex ( image , * p ++ , q ) ; q += GetPixelChannels ( image ) ; } if ( ( image -> columns % 2 ) != 0 ) p ++ ; if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ; if ( status == MagickFalse ) break ; } } } else { size_t bytes_per_pixel ; bytes_per_pixel = 3 ; if ( image -> alpha_trait != UndefinedPixelTrait ) bytes_per_pixel ++ ; if ( bytes_per_line == 0 ) bytes_per_line = bytes_per_pixel * image -> columns ; length = image -> rows * ( bytes_per_line + image -> columns % 2 ) ; if ( ( ( sun_info . type == RT_ENCODED ) && ( length > ( bytes_per_line * image -> rows ) ) ) || ( ( sun_info . type != RT_ENCODED ) && ( length > sun_info . length ) ) ) ThrowReaderException ( CorruptImageError , \"UnableToReadImageData\" ) ; for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { if ( image -> alpha_trait != UndefinedPixelTrait ) SetPixelAlpha ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; if ( sun_info . type == RT_STANDARD ) { SetPixelBlue ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; SetPixelGreen ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; SetPixelRed ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; } else { SetPixelRed ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; SetPixelGreen ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; SetPixelBlue ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; } if ( image -> colors != 0 ) { SetPixelRed ( image , ClampToQuantum ( image -> colormap [ ( ssize_t ) GetPixelRed ( image , q ) ] . red ) , q ) ; SetPixelGreen ( image , ClampToQuantum ( image -> colormap [ ( ssize_t ) GetPixelGreen ( image , q ) ] . green ) , q ) ; SetPixelBlue ( image , ClampToQuantum ( image -> colormap [ ( ssize_t ) GetPixelBlue ( image , q ) ] . blue ) , q ) ; } q += GetPixelChannels ( image ) ; } if ( ( ( bytes_per_pixel * image -> columns ) % 2 ) != 0 ) p ++ ; if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ; if ( status == MagickFalse ) break ; } } } if ( image -> storage_class == PseudoClass ) ( void ) SyncImage ( image , exception ) ; sun_pixels = ( unsigned char * ) RelinquishMagickMemory ( sun_pixels ) ; if ( EOFBlob ( image ) != MagickFalse ) { ThrowFileException ( exception , CorruptImageError , \"UnexpectedEndOfFile\" , image -> filename ) ; break ; } if ( image_info -> number_scenes != 0 ) if ( image -> scene >= ( image_info -> scene + image_info -> number_scenes - 1 ) ) break ; sun_info . magic = ReadBlobMSBLong ( image ) ; if ( sun_info . magic == 0x59a66a95 ) { AcquireNextImage ( image_info , image , exception ) ; if ( GetNextImageInList ( image ) == ( Image * ) NULL ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } image = SyncNextImageInList ( image ) ; status = SetImageProgress ( image , LoadImagesTag , TellBlob ( image ) , GetBlobSize ( image ) ) ; if ( status == MagickFalse ) break ; } } while ( sun_info . magic == 0x59a66a95 ) ; ( void ) CloseBlob ( image ) ; return ( GetFirstImageInList ( image ) ) ; }\n","target":"<S2SV_ModStart> maptype ) { case RMT_NONE : break ;\n","project_and_commit_id":"ImageMagick@ImageMagick/450bd716ed3b9186dd10f9e60f630a3d9eeea2a4","cve_id":"CVE-2015-8957","original_address":"https://github.com/ImageMagick/ImageMagick/commit/450bd716ed3b9186dd10f9e60f630a3d9eeea2a4","time":"2017-04-20T18:59Z"},
	{"Unnamed: 0":1626,"cwe_id":"CWE-400","source":"CWE-400 static int parse_exp ( Node * * np , PToken * tok , int term , UChar * * src , UChar * end , ScanEnv * env , int group_head ) { <S2SV_StartBug> int r , len , group = 0 ; <S2SV_EndBug> Node * qn ; <S2SV_StartBug> Node * * tp ; <S2SV_EndBug> * np = NULL ; if ( tok -> type == ( enum TokenSyms ) term ) <S2SV_StartBug> goto end_of_token ; <S2SV_EndBug> switch ( tok -> type ) { case TK_ALT : case TK_EOT : end_of_token : * np = node_new_empty ( ) ; CHECK_NULL_RETURN_MEMERR ( * np ) ; return tok -> type ; break ; case TK_SUBEXP_OPEN : r = parse_bag ( np , tok , TK_SUBEXP_CLOSE , src , end , env ) ; if ( r < 0 ) return r ; if ( r == 1 ) { if ( group_head == 0 ) group = 1 ; else { Node * target = * np ; * np = node_new_group ( target ) ; if ( IS_NULL ( * np ) ) { onig_node_free ( target ) ; return ONIGERR_MEMORY ; } group = 2 ; } } else if ( r == 2 ) { Node * target ; OnigOptionType prev = env -> options ; env -> options = BAG_ ( * np ) -> o . options ; r = fetch_token ( tok , src , end , env ) ; if ( r < 0 ) return r ; r = parse_subexp ( & target , tok , term , src , end , env , 0 ) ; env -> options = prev ; if ( r < 0 ) { onig_node_free ( target ) ; return r ; } NODE_BODY ( * np ) = target ; return tok -> type ; } break ; case TK_SUBEXP_CLOSE : if ( ! IS_SYNTAX_BV ( env -> syntax , ONIG_SYN_ALLOW_UNMATCHED_CLOSE_SUBEXP ) ) return ONIGERR_UNMATCHED_CLOSE_PARENTHESIS ; if ( tok -> escaped ) goto tk_raw_byte ; else goto tk_byte ; break ; case TK_STRING : tk_byte : { * np = node_new_str ( tok -> backp , * src ) ; CHECK_NULL_RETURN_MEMERR ( * np ) ; while ( 1 ) { r = fetch_token ( tok , src , end , env ) ; if ( r < 0 ) return r ; if ( r != TK_STRING ) break ; r = onig_node_str_cat ( * np , tok -> backp , * src ) ; if ( r < 0 ) return r ; } string_end : tp = np ; goto repeat ; } break ; case TK_RAW_BYTE : tk_raw_byte : { * np = node_new_str_raw_char ( ( UChar ) tok -> u . c ) ; CHECK_NULL_RETURN_MEMERR ( * np ) ; len = 1 ; while ( 1 ) { if ( len >= ONIGENC_MBC_MINLEN ( env -> enc ) ) { if ( len == enclen ( env -> enc , STR_ ( * np ) -> s ) ) { r = fetch_token ( tok , src , end , env ) ; goto tk_raw_byte_end ; } } r = fetch_token ( tok , src , end , env ) ; if ( r < 0 ) return r ; if ( r != TK_RAW_BYTE ) return ONIGERR_TOO_SHORT_MULTI_BYTE_STRING ; r = node_str_cat_char ( * np , ( UChar ) tok -> u . c ) ; if ( r < 0 ) return r ; len ++ ; } tk_raw_byte_end : if ( ! ONIGENC_IS_VALID_MBC_STRING ( env -> enc , STR_ ( * np ) -> s , STR_ ( * np ) -> end ) ) return ONIGERR_INVALID_WIDE_CHAR_VALUE ; NODE_STRING_CLEAR_RAW ( * np ) ; goto string_end ; } break ; case TK_CODE_POINT : { UChar buf [ ONIGENC_CODE_TO_MBC_MAXLEN ] ; len = ONIGENC_CODE_TO_MBC ( env -> enc , tok -> u . code , buf ) ; if ( len < 0 ) return len ; # ifdef NUMBERED_CHAR_IS_NOT_CASE_AMBIG * np = node_new_str_raw ( buf , buf + len ) ; # else * np = node_new_str ( buf , buf + len ) ; # endif CHECK_NULL_RETURN_MEMERR ( * np ) ; } break ; case TK_QUOTE_OPEN : { OnigCodePoint end_op [ 2 ] ; UChar * qstart , * qend , * nextp ; end_op [ 0 ] = ( OnigCodePoint ) MC_ESC ( env -> syntax ) ; end_op [ 1 ] = ( OnigCodePoint ) 'E' ; qstart = * src ; qend = find_str_position ( end_op , 2 , qstart , end , & nextp , env -> enc ) ; if ( IS_NULL ( qend ) ) { nextp = qend = end ; } * np = node_new_str ( qstart , qend ) ; CHECK_NULL_RETURN_MEMERR ( * np ) ; * src = nextp ; } break ; case TK_CHAR_TYPE : { switch ( tok -> u . prop . ctype ) { case ONIGENC_CTYPE_WORD : * np = node_new_ctype ( tok -> u . prop . ctype , tok -> u . prop . not , env -> options ) ; CHECK_NULL_RETURN_MEMERR ( * np ) ; break ; case ONIGENC_CTYPE_SPACE : case ONIGENC_CTYPE_DIGIT : case ONIGENC_CTYPE_XDIGIT : { CClassNode * cc ; * np = node_new_cclass ( ) ; CHECK_NULL_RETURN_MEMERR ( * np ) ; cc = CCLASS_ ( * np ) ; add_ctype_to_cc ( cc , tok -> u . prop . ctype , 0 , env ) ; if ( tok -> u . prop . not != 0 ) NCCLASS_SET_NOT ( cc ) ; } break ; default : return ONIGERR_PARSER_BUG ; break ; } } break ; case TK_CHAR_PROPERTY : r = parse_char_property ( np , tok , src , end , env ) ; if ( r != 0 ) return r ; break ; case TK_CC_OPEN : { CClassNode * cc ; r = parse_char_class ( np , tok , src , end , env ) ; if ( r != 0 ) return r ; cc = CCLASS_ ( * np ) ; if ( IS_IGNORECASE ( env -> options ) ) { IApplyCaseFoldArg iarg ; iarg . env = env ; iarg . cc = cc ; iarg . alt_root = NULL_NODE ; iarg . ptail = & ( iarg . alt_root ) ; r = ONIGENC_APPLY_ALL_CASE_FOLD ( env -> enc , env -> case_fold_flag , i_apply_case_fold , & iarg ) ; if ( r != 0 ) { onig_node_free ( iarg . alt_root ) ; return r ; } if ( IS_NOT_NULL ( iarg . alt_root ) ) { Node * work = onig_node_new_alt ( * np , iarg . alt_root ) ; if ( IS_NULL ( work ) ) { onig_node_free ( iarg . alt_root ) ; return ONIGERR_MEMORY ; } * np = work ; } } } break ; case TK_ANYCHAR : * np = node_new_anychar ( ) ; CHECK_NULL_RETURN_MEMERR ( * np ) ; break ; case TK_ANYCHAR_ANYTIME : * np = node_new_anychar ( ) ; CHECK_NULL_RETURN_MEMERR ( * np ) ; qn = node_new_quantifier ( 0 , INFINITE_REPEAT , 0 ) ; CHECK_NULL_RETURN_MEMERR ( qn ) ; NODE_BODY ( qn ) = * np ; * np = qn ; break ; case TK_BACKREF : len = tok -> u . backref . num ; * np = node_new_backref ( len , ( len > 1 ? tok -> u . backref . refs : & ( tok -> u . backref . ref1 ) ) , tok -> u . backref . by_name , # ifdef USE_BACKREF_WITH_LEVEL tok -> u . backref . exist_level , tok -> u . backref . level , # endif env ) ; CHECK_NULL_RETURN_MEMERR ( * np ) ; break ; # ifdef USE_CALL case TK_CALL : { int gnum = tok -> u . call . gnum ; * np = node_new_call ( tok -> u . call . name , tok -> u . call . name_end , gnum , tok -> u . call . by_number ) ; CHECK_NULL_RETURN_MEMERR ( * np ) ; env -> num_call ++ ; if ( tok -> u . call . by_number != 0 && gnum == 0 ) { env -> has_call_zero = 1 ; } } break ; # endif case TK_ANCHOR : { int ascii_mode = IS_WORD_ASCII ( env -> options ) && IS_WORD_ANCHOR_TYPE ( tok -> u . anchor ) ? 1 : 0 ; * np = onig_node_new_anchor ( tok -> u . anchor , ascii_mode ) ; CHECK_NULL_RETURN_MEMERR ( * np ) ; } break ; case TK_REPEAT : case TK_INTERVAL : if ( IS_SYNTAX_BV ( env -> syntax , ONIG_SYN_CONTEXT_INDEP_REPEAT_OPS ) ) { if ( IS_SYNTAX_BV ( env -> syntax , ONIG_SYN_CONTEXT_INVALID_REPEAT_OPS ) ) return ONIGERR_TARGET_OF_REPEAT_OPERATOR_NOT_SPECIFIED ; else { * np = node_new_empty ( ) ; CHECK_NULL_RETURN_MEMERR ( * np ) ; } } else { goto tk_byte ; } break ; case TK_KEEP : r = node_new_keep ( np , env ) ; if ( r < 0 ) return r ; break ; case TK_GENERAL_NEWLINE : r = node_new_general_newline ( np , env ) ; if ( r < 0 ) return r ; break ; case TK_NO_NEWLINE : r = node_new_no_newline ( np , env ) ; if ( r < 0 ) return r ; break ; case TK_TRUE_ANYCHAR : r = node_new_true_anychar ( np , env ) ; if ( r < 0 ) return r ; break ; case TK_TEXT_SEGMENT : r = make_text_segment ( np , env ) ; if ( r < 0 ) return r ; break ; default : return ONIGERR_PARSER_BUG ; break ; } { tp = np ; re_entry : r = fetch_token ( tok , src , end , env ) ; if ( r < 0 ) return r ; repeat : if ( r == TK_REPEAT || r == TK_INTERVAL ) { Node * target ; if ( is_invalid_quantifier_target ( * tp ) ) return ONIGERR_TARGET_OF_REPEAT_OPERATOR_INVALID ; <S2SV_StartBug> qn = node_new_quantifier ( tok -> u . repeat . lower , tok -> u . repeat . upper , <S2SV_EndBug> r == TK_INTERVAL ) ; CHECK_NULL_RETURN_MEMERR ( qn ) ; QUANT_ ( qn ) -> greedy = tok -> u . repeat . greedy ; if ( group == 2 ) { target = node_drop_group ( * tp ) ; * tp = NULL_NODE ; } else { target = * tp ; } r = set_quantifier ( qn , target , group , env ) ; if ( r < 0 ) { onig_node_free ( qn ) ; return r ; } if ( tok -> u . repeat . possessive != 0 ) { Node * en ; en = node_new_bag ( BAG_STOP_BACKTRACK ) ; if ( IS_NULL ( en ) ) { onig_node_free ( qn ) ; return ONIGERR_MEMORY ; } NODE_BODY ( en ) = qn ; qn = en ; } if ( r == 0 ) { * tp = qn ; } else if ( r == 1 ) { onig_node_free ( qn ) ; * tp = target ; } else if ( r == 2 ) { Node * tmp ; * tp = node_new_list ( * tp , NULL ) ; if ( IS_NULL ( * tp ) ) { onig_node_free ( qn ) ; return ONIGERR_MEMORY ; } tmp = NODE_CDR ( * tp ) = node_new_list ( qn , NULL ) ; if ( IS_NULL ( tmp ) ) { onig_node_free ( qn ) ; return ONIGERR_MEMORY ; } tp = & ( NODE_CAR ( tmp ) ) ; } group = 0 ; goto re_entry ; } } return r ; }\n","target":"<S2SV_ModStart> len , group <S2SV_ModEnd> ; Node * <S2SV_ModStart> * * tp ; unsigned int parse_depth ; group = 0 <S2SV_ModStart> ) goto end_of_token ; parse_depth = env -> parse_depth <S2SV_ModStart> return ONIGERR_TARGET_OF_REPEAT_OPERATOR_INVALID ; parse_depth ++ ; if ( parse_depth > ParseDepthLimit ) return ONIGERR_PARSE_DEPTH_LIMIT_OVER ;\n","project_and_commit_id":"kkos@oniguruma/4097828d7cc87589864fecf452f2cd46c5f37180","cve_id":"CVE-2019-16163","original_address":"https://github.com/kkos/oniguruma/commit/4097828d7cc87589864fecf452f2cd46c5f37180","time":"2019-09-09T17:15Z"},
	{"Unnamed: 0":3108,"cwe_id":"CWE-416","source":"CWE-416 static int link_pipe ( struct pipe_inode_info * ipipe , struct pipe_inode_info * opipe , size_t len , unsigned int flags ) { struct pipe_buffer * ibuf , * obuf ; int ret = 0 , i = 0 , nbuf ; pipe_double_lock ( ipipe , opipe ) ; do { if ( ! opipe -> readers ) { send_sig ( SIGPIPE , current , 0 ) ; if ( ! ret ) ret = - EPIPE ; break ; } if ( i >= ipipe -> nrbufs || opipe -> nrbufs >= opipe -> buffers ) break ; ibuf = ipipe -> bufs + ( ( ipipe -> curbuf + i ) & ( ipipe -> buffers - 1 ) ) ; nbuf = ( opipe -> curbuf + opipe -> nrbufs ) & ( opipe -> buffers - 1 ) ; <S2SV_StartBug> pipe_buf_get ( ipipe , ibuf ) ; <S2SV_EndBug> obuf = opipe -> bufs + nbuf ; * obuf = * ibuf ; obuf -> flags &= ~ PIPE_BUF_FLAG_GIFT ; if ( obuf -> len > len ) obuf -> len = len ; opipe -> nrbufs ++ ; ret += obuf -> len ; len -= obuf -> len ; i ++ ; } while ( len ) ; if ( ! ret && ipipe -> waiting_writers && ( flags & SPLICE_F_NONBLOCK ) ) ret = - EAGAIN ; pipe_unlock ( ipipe ) ; pipe_unlock ( opipe ) ; if ( ret > 0 ) wakeup_pipe_readers ( opipe ) ; return ret ; }\n","target":"<S2SV_ModStart> 1 ) ; if ( ! <S2SV_ModStart> , ibuf ) ) { if ( ret == 0 ) ret = - EFAULT ; break ; } <S2SV_ModEnd> obuf = opipe\n","project_and_commit_id":"torvalds@linux/15fab63e1e57be9fdb5eec1bbc5916e9825e9acb","cve_id":"CVE-2019-11487","original_address":"https://github.com/torvalds/linux/commit/15fab63e1e57be9fdb5eec1bbc5916e9825e9acb","time":"2019-04-23T22:29Z"},
	{"Unnamed: 0":2737,"cwe_id":"CWE-19","source":"CWE-19 static void ext2_put_super ( struct super_block * sb ) { int db_count ; int i ; struct ext2_sb_info * sbi = EXT2_SB ( sb ) ; dquot_disable ( sb , - 1 , DQUOT_USAGE_ENABLED | DQUOT_LIMITS_ENABLED ) ; <S2SV_StartBug> ext2_xattr_put_super ( sb ) ; <S2SV_EndBug> if ( ! ( sb -> s_flags & MS_RDONLY ) ) { struct ext2_super_block * es = sbi -> s_es ; spin_lock ( & sbi -> s_lock ) ; es -> s_state = cpu_to_le16 ( sbi -> s_mount_state ) ; spin_unlock ( & sbi -> s_lock ) ; ext2_sync_super ( sb , es , 1 ) ; } db_count = sbi -> s_gdb_count ; for ( i = 0 ; i < db_count ; i ++ ) if ( sbi -> s_group_desc [ i ] ) brelse ( sbi -> s_group_desc [ i ] ) ; kfree ( sbi -> s_group_desc ) ; kfree ( sbi -> s_debts ) ; percpu_counter_destroy ( & sbi -> s_freeblocks_counter ) ; percpu_counter_destroy ( & sbi -> s_freeinodes_counter ) ; percpu_counter_destroy ( & sbi -> s_dirs_counter ) ; brelse ( sbi -> s_sbh ) ; sb -> s_fs_info = NULL ; kfree ( sbi -> s_blockgroup_lock ) ; kfree ( sbi ) ; }\n","target":"<S2SV_ModStart> DQUOT_LIMITS_ENABLED ) ; if ( sbi -> s_mb_cache ) { ext2_xattr_destroy_cache ( sbi -> s_mb_cache ) ; sbi -> s_mb_cache = NULL ; } <S2SV_ModEnd> if ( !\n","project_and_commit_id":"torvalds@linux/be0726d33cb8f411945884664924bed3cb8c70ee","cve_id":"CVE-2015-8952","original_address":"https://github.com/torvalds/linux/commit/be0726d33cb8f411945884664924bed3cb8c70ee","time":"2016-10-16T21:59Z"},
	{"Unnamed: 0":6474,"cwe_id":"CWE-787","source":"CWE-787 <S2SV_StartBug> static void nsc_decode ( NSC_CONTEXT * context ) <S2SV_EndBug> { UINT16 x ; UINT16 y ; <S2SV_StartBug> UINT16 rw = ROUND_UP_TO ( context -> width , 8 ) ; <S2SV_EndBug> <S2SV_StartBug> BYTE shift = context -> ColorLossLevel - 1 ; <S2SV_EndBug> <S2SV_StartBug> BYTE * bmpdata = context -> BitmapData ; <S2SV_EndBug> for ( y = 0 ; y < context -> height ; y ++ ) { const BYTE * yplane ; const BYTE * coplane ; const BYTE * cgplane ; const BYTE * aplane = context -> priv -> PlaneBuffers [ 3 ] + y * context -> width ; if ( context -> ChromaSubsamplingLevel ) { yplane = context -> priv -> PlaneBuffers [ 0 ] + y * rw ; coplane = context -> priv -> PlaneBuffers [ 1 ] + ( y >> 1 ) * ( rw >> 1 ) ; cgplane = context -> priv -> PlaneBuffers [ 2 ] + ( y >> 1 ) * ( rw >> 1 ) ; } else { yplane = context -> priv -> PlaneBuffers [ 0 ] + y * context -> width ; coplane = context -> priv -> PlaneBuffers [ 1 ] + y * context -> width ; cgplane = context -> priv -> PlaneBuffers [ 2 ] + y * context -> width ; } for ( x = 0 ; x < context -> width ; x ++ ) { INT16 y_val = ( INT16 ) * yplane ; INT16 co_val = ( INT16 ) ( INT8 ) ( * coplane << shift ) ; INT16 cg_val = ( INT16 ) ( INT8 ) ( * cgplane << shift ) ; INT16 r_val = y_val + co_val - cg_val ; INT16 g_val = y_val + cg_val ; INT16 b_val = y_val - co_val - cg_val ; <S2SV_StartBug> * bmpdata ++ = MINMAX ( b_val , 0 , 0xFF ) ; <S2SV_EndBug> * bmpdata ++ = MINMAX ( g_val , 0 , 0xFF ) ; * bmpdata ++ = MINMAX ( r_val , 0 , 0xFF ) ; * bmpdata ++ = * aplane ; yplane ++ ; coplane += ( context -> ChromaSubsamplingLevel ? x % 2 : 1 ) ; cgplane += ( context -> ChromaSubsamplingLevel ? x % 2 : 1 ) ; aplane ++ ; } } <S2SV_StartBug> } <S2SV_EndBug>\n","target":"<S2SV_ModStart> <S2SV_null> <S2SV_null> static BOOL <S2SV_ModEnd> nsc_decode ( NSC_CONTEXT <S2SV_ModStart> ; UINT16 rw ; BYTE shift ; BYTE * bmpdata ; size_t pos = 0 ; if ( ! context ) return FALSE ; rw <S2SV_ModStart> 8 ) ; <S2SV_ModEnd> shift = context <S2SV_ModStart> - 1 ; <S2SV_ModEnd> bmpdata = context <S2SV_ModStart> context -> BitmapData ; if ( ! bmpdata ) return FALSE <S2SV_ModStart> - cg_val ; if ( pos + 4 > context -> BitmapDataLength ) return FALSE ; pos += 4 ; <S2SV_ModStart> ; } } return TRUE ;\n","project_and_commit_id":"FreeRDP@FreeRDP/d1112c279bd1a327e8e4d0b5f371458bf2579659","cve_id":"CVE-2018-8788","original_address":"https://github.com/FreeRDP/FreeRDP/commit/d1112c279bd1a327e8e4d0b5f371458bf2579659","time":"2018-11-29T18:29Z"},
	{"Unnamed: 0":650,"cwe_id":"CWE-125","source":"CWE-125 static RList * r_bin_wasm_get_data_entries ( RBinWasmObj * bin , RBinWasmSection * sec ) { RList * ret = NULL ; RBinWasmDataEntry * ptr = NULL ; <S2SV_StartBug> if ( ! ( ret = r_list_newf ( ( RListFree ) free ) ) ) { <S2SV_EndBug> return NULL ; } ut8 * buf = bin -> buf -> buf + ( ut32 ) sec -> payload_data ; <S2SV_StartBug> ut32 len = sec -> payload_len ; <S2SV_EndBug> ut32 count = sec -> count ; ut32 i = 0 , r = 0 ; size_t n = 0 ; <S2SV_StartBug> while ( i < len && r < count ) { <S2SV_EndBug> if ( ! ( ptr = R_NEW0 ( RBinWasmDataEntry ) ) ) { return ret ; } if ( ! ( consume_u32 ( buf + i , buf + len , & ptr -> index , & i ) ) ) { <S2SV_StartBug> free ( ptr ) ; <S2SV_EndBug> return ret ; } if ( ! ( n = consume_init_expr ( buf + i , buf + len , R_BIN_WASM_END_OF_CODE , NULL , & i ) ) ) { <S2SV_StartBug> free ( ptr ) ; <S2SV_EndBug> return ret ; } ptr -> offset . len = n ; if ( ! ( consume_u32 ( buf + i , buf + len , & ptr -> size , & i ) ) ) { <S2SV_StartBug> free ( ptr ) ; <S2SV_EndBug> return ret ; } ptr -> data = sec -> payload_data + i ; r_list_append ( ret , ptr ) ; r += 1 ; } return ret ; <S2SV_StartBug> } <S2SV_EndBug>\n","target":"<S2SV_ModStart> = NULL ; ut32 len = sec -> payload_len ; <S2SV_ModStart> -> payload_data ; int buflen = bin -> buf -> length - ( ut32 ) sec -> payload_data <S2SV_ModEnd> ; ut32 count <S2SV_ModStart> i < len && len < buflen <S2SV_ModStart> ) ) { goto beach ; } if ( i + 4 >= buflen ) { goto beach <S2SV_ModEnd> ; } if <S2SV_ModStart> ) ) { goto beach <S2SV_ModEnd> ; } ptr <S2SV_ModStart> ) ) { goto beach ; } if ( i + 4 >= buflen ) { goto beach <S2SV_ModEnd> ; } ptr <S2SV_ModStart> return ret ; beach : free ( ptr ) ; return ret ;\n","project_and_commit_id":"radare@radare2/d2632f6483a3ceb5d8e0a5fb11142c51c43978b4","cve_id":"CVE-2017-7854","original_address":"https://github.com/radare/radare2/commit/d2632f6483a3ceb5d8e0a5fb11142c51c43978b4","time":"2017-04-13T16:59Z"},
	{"Unnamed: 0":100,"cwe_id":"CWE-362","source":"CWE-362 void __kvm_migrate_pit_timer ( struct kvm_vcpu * vcpu ) { struct kvm_pit * pit = vcpu -> kvm -> arch . vpit ; struct hrtimer * timer ; if ( ! kvm_vcpu_is_bsp ( vcpu ) || ! pit ) return ; timer = & pit -> pit_state . timer ; <S2SV_StartBug> if ( hrtimer_cancel ( timer ) ) <S2SV_EndBug> hrtimer_start_expires ( timer , HRTIMER_MODE_ABS ) ; <S2SV_StartBug> } <S2SV_EndBug>\n","target":"<S2SV_ModStart> . timer ; mutex_lock ( & pit -> pit_state . lock ) ; <S2SV_ModStart> HRTIMER_MODE_ABS ) ; mutex_unlock ( & pit -> pit_state . lock ) ;\n","project_and_commit_id":"torvalds@linux/2febc839133280d5a5e8e1179c94ea674489dae2","cve_id":"CVE-2014-3611","original_address":"https://github.com/torvalds/linux/commit/2febc839133280d5a5e8e1179c94ea674489dae2","time":"2014-11-10T11:55Z"},
	{"Unnamed: 0":5139,"cwe_id":"CWE-476","source":"CWE-476 static void <S2SV_StartBug> sraSpanInsertBefore ( sraSpan * newspan , sraSpan * before ) { <S2SV_EndBug> newspan -> _next = before ; newspan -> _prev = before -> _prev ; before -> _prev -> _next = newspan ; before -> _prev = newspan ; <S2SV_StartBug> } <S2SV_EndBug>\n","target":"<S2SV_ModStart> , sraSpan * before ) { if ( newspan && <S2SV_ModStart> newspan ; } }\n","project_and_commit_id":"LibVNC@libvncserver/38e98ee61d74f5f5ab4aa4c77146faad1962d6d0","cve_id":"CVE-2020-14397","original_address":"https://github.com/LibVNC/libvncserver/commit/38e98ee61d74f5f5ab4aa4c77146faad1962d6d0","time":"2020-06-17T16:15Z"},
	{"Unnamed: 0":4699,"cwe_id":"CWE-119","source":"CWE-119 PHP_FUNCTION ( msgfmt_format_message ) { zval * args ; UChar * spattern = NULL ; int spattern_len = 0 ; char * pattern = NULL ; int pattern_len = 0 ; const char * slocale = NULL ; int slocale_len = 0 ; MessageFormatter_object mf = { 0 } ; MessageFormatter_object * mfo = & mf ; if ( zend_parse_method_parameters ( ZEND_NUM_ARGS ( ) TSRMLS_CC , getThis ( ) , \"ssa\" , & slocale , & slocale_len , & pattern , & pattern_len , & args ) == FAILURE ) { intl_error_set ( NULL , U_ILLEGAL_ARGUMENT_ERROR , \"msgfmt_format_message:<S2SV_blank>unable<S2SV_blank>to<S2SV_blank>parse<S2SV_blank>input<S2SV_blank>params\" , 0 TSRMLS_CC ) ; RETURN_FALSE ; <S2SV_StartBug> } <S2SV_EndBug> msgformat_data_init ( & mfo -> mf_data TSRMLS_CC ) ; if ( pattern && pattern_len ) { intl_convert_utf8_to_utf16 ( & spattern , & spattern_len , pattern , pattern_len , & INTL_DATA_ERROR_CODE ( mfo ) ) ; if ( U_FAILURE ( INTL_DATA_ERROR_CODE ( ( mfo ) ) ) ) { intl_error_set ( NULL , U_ILLEGAL_ARGUMENT_ERROR , \"msgfmt_format_message:<S2SV_blank>error<S2SV_blank>converting<S2SV_blank>pattern<S2SV_blank>to<S2SV_blank>UTF-16\" , 0 TSRMLS_CC ) ; RETURN_FALSE ; } } else { spattern_len = 0 ; spattern = NULL ; } if ( slocale_len == 0 ) { slocale = intl_locale_get_default ( TSRMLS_C ) ; } # ifdef MSG_FORMAT_QUOTE_APOS if ( msgformat_fix_quotes ( & spattern , & spattern_len , & INTL_DATA_ERROR_CODE ( mfo ) ) != SUCCESS ) { intl_error_set ( NULL , U_INVALID_FORMAT_ERROR , \"msgfmt_format_message:<S2SV_blank>error<S2SV_blank>converting<S2SV_blank>pattern<S2SV_blank>to<S2SV_blank>quote-friendly<S2SV_blank>format\" , 0 TSRMLS_CC ) ; RETURN_FALSE ; } # endif MSG_FORMAT_OBJECT ( mfo ) = umsg_open ( spattern , spattern_len , slocale , NULL , & INTL_DATA_ERROR_CODE ( mfo ) ) ; if ( spattern && spattern_len ) { efree ( spattern ) ; } INTL_METHOD_CHECK_STATUS ( mfo , \"Creating<S2SV_blank>message<S2SV_blank>formatter<S2SV_blank>failed\" ) ; msgfmt_do_format ( mfo , args , return_value TSRMLS_CC ) ; msgformat_data_free ( & mfo -> mf_data TSRMLS_CC ) ; }\n","target":"<S2SV_ModStart> RETURN_FALSE ; } INTL_CHECK_LOCALE_LEN ( slocale_len ) ;\n","project_and_commit_id":"php@php-src/6d55ba265637d6adf0ba7e9c9ef11187d1ec2f5b","cve_id":"CVE-2016-7416","original_address":"https://github.com/php/php-src/commit/6d55ba265637d6adf0ba7e9c9ef11187d1ec2f5b","time":"2016-09-17T21:59Z"},
	{"Unnamed: 0":47,"cwe_id":"CWE-399","source":"CWE-399 static Image * ReadCAPTIONImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { char * caption , geometry [ MaxTextExtent ] , * property , * text ; const char * gravity , * option ; DrawInfo * draw_info ; Image * image ; MagickBooleanType split , status ; register ssize_t i ; size_t height , width ; TypeMetric metrics ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickSignature ) ; if ( image_info -> debug != MagickFalse ) ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , \"%s\" , image_info -> filename ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickSignature ) ; image = AcquireImage ( image_info ) ; ( void ) ResetImagePage ( image , \"0x0+0+0\" ) ; option = GetImageOption ( image_info , \"filename\" ) ; if ( option == ( const char * ) NULL ) property = InterpretImageProperties ( image_info , image , image_info -> filename ) ; else if ( LocaleNCompare ( option , \"caption:\" , 8 ) == 0 ) property = InterpretImageProperties ( image_info , image , option + 8 ) ; else property = InterpretImageProperties ( image_info , image , option ) ; ( void ) SetImageProperty ( image , \"caption\" , property ) ; property = DestroyString ( property ) ; caption = ConstantString ( GetImageProperty ( image , \"caption\" ) ) ; draw_info = CloneDrawInfo ( image_info , ( DrawInfo * ) NULL ) ; ( void ) CloneString ( & draw_info -> text , caption ) ; gravity = GetImageOption ( image_info , \"gravity\" ) ; if ( gravity != ( char * ) NULL ) draw_info -> gravity = ( GravityType ) ParseCommandOption ( MagickGravityOptions , MagickFalse , gravity ) ; split = MagickFalse ; status = MagickTrue ; if ( image -> columns == 0 ) { text = AcquireString ( caption ) ; i = FormatMagickCaption ( image , draw_info , split , & metrics , & text ) ; ( void ) CloneString ( & draw_info -> text , text ) ; text = DestroyString ( text ) ; ( void ) FormatLocaleString ( geometry , MaxTextExtent , \"%+g%+g\" , - metrics . bounds . x1 , metrics . ascent ) ; if ( draw_info -> gravity == UndefinedGravity ) ( void ) CloneString ( & draw_info -> geometry , geometry ) ; status = GetMultilineTypeMetrics ( image , draw_info , & metrics ) ; width = ( size_t ) floor ( metrics . width + draw_info -> stroke_width + 0.5 ) ; image -> columns = width ; } if ( image -> rows == 0 ) { split = MagickTrue ; text = AcquireString ( caption ) ; i = FormatMagickCaption ( image , draw_info , split , & metrics , & text ) ; ( void ) CloneString ( & draw_info -> text , text ) ; text = DestroyString ( text ) ; ( void ) FormatLocaleString ( geometry , MaxTextExtent , \"%+g%+g\" , - metrics . bounds . x1 , metrics . ascent ) ; if ( draw_info -> gravity == UndefinedGravity ) ( void ) CloneString ( & draw_info -> geometry , geometry ) ; status = GetMultilineTypeMetrics ( image , draw_info , & metrics ) ; image -> rows = ( size_t ) ( ( i + 1 ) * ( metrics . ascent - metrics . descent + draw_info -> interline_spacing + draw_info -> stroke_width ) + 0.5 ) ; } if ( status != MagickFalse ) status = SetImageExtent ( image , image -> columns , image -> rows ) ; if ( status == MagickFalse ) { draw_info = DestroyDrawInfo ( draw_info ) ; InheritException ( exception , & image -> exception ) ; return ( DestroyImageList ( image ) ) ; } if ( SetImageBackgroundColor ( image ) == MagickFalse ) { draw_info = DestroyDrawInfo ( draw_info ) ; InheritException ( exception , & image -> exception ) ; image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } if ( ( fabs ( image_info -> pointsize ) < MagickEpsilon ) && ( strlen ( caption ) > 0 ) ) { double high , low ; for ( ; ; draw_info -> pointsize *= 2.0 ) { text = AcquireString ( caption ) ; i = FormatMagickCaption ( image , draw_info , split , & metrics , & text ) ; ( void ) CloneString ( & draw_info -> text , text ) ; text = DestroyString ( text ) ; ( void ) FormatLocaleString ( geometry , MaxTextExtent , \"%+g%+g\" , - metrics . bounds . x1 , metrics . ascent ) ; if ( draw_info -> gravity == UndefinedGravity ) ( void ) CloneString ( & draw_info -> geometry , geometry ) ; status = GetMultilineTypeMetrics ( image , draw_info , & metrics ) ; ( void ) status ; width = ( size_t ) floor ( metrics . width + draw_info -> stroke_width + 0.5 ) ; height = ( size_t ) floor ( metrics . height + draw_info -> stroke_width + 0.5 ) ; if ( ( image -> columns != 0 ) && ( image -> rows != 0 ) ) { if ( ( width >= image -> columns ) && ( height >= image -> rows ) ) break ; } else if ( ( ( image -> columns != 0 ) && ( width >= image -> columns ) ) || ( ( image -> rows != 0 ) && ( height >= image -> rows ) ) ) break ; } high = draw_info -> pointsize ; for ( low = 1.0 ; ( high - low ) > 0.5 ; ) { draw_info -> pointsize = ( low + high ) / 2.0 ; text = AcquireString ( caption ) ; i = FormatMagickCaption ( image , draw_info , split , & metrics , & text ) ; ( void ) CloneString ( & draw_info -> text , text ) ; text = DestroyString ( text ) ; ( void ) FormatLocaleString ( geometry , MaxTextExtent , \"%+g%+g\" , - metrics . bounds . x1 , metrics . ascent ) ; if ( draw_info -> gravity == UndefinedGravity ) ( void ) CloneString ( & draw_info -> geometry , geometry ) ; ( void ) GetMultilineTypeMetrics ( image , draw_info , & metrics ) ; width = ( size_t ) floor ( metrics . width + draw_info -> stroke_width + 0.5 ) ; height = ( size_t ) floor ( metrics . height + draw_info -> stroke_width + 0.5 ) ; if ( ( image -> columns != 0 ) && ( image -> rows != 0 ) ) { if ( ( width < image -> columns ) && ( height < image -> rows ) ) low = draw_info -> pointsize + 0.5 ; else high = draw_info -> pointsize - 0.5 ; } else if ( ( ( image -> columns != 0 ) && ( width < image -> columns ) ) || ( ( image -> rows != 0 ) && ( height < image -> rows ) ) ) low = draw_info -> pointsize + 0.5 ; else high = draw_info -> pointsize - 0.5 ; } draw_info -> pointsize = floor ( ( low + high ) / 2.0 - 0.5 ) ; } i = FormatMagickCaption ( image , draw_info , split , & metrics , & caption ) ; ( void ) CloneString ( & draw_info -> text , caption ) ; ( void ) FormatLocaleString ( geometry , MaxTextExtent , \"%+g%+g\" , MagickMax ( draw_info -> direction == RightToLeftDirection ? image -> columns - metrics . bounds . x2 : - metrics . bounds . x1 , 0.0 ) , draw_info -> gravity == UndefinedGravity ? metrics . ascent : 0.0 ) ; <S2SV_StartBug> draw_info -> geometry = AcquireString ( geometry ) ; <S2SV_EndBug> status = AnnotateImage ( image , draw_info ) ; if ( image_info -> pointsize == 0.0 ) { char pointsize [ MaxTextExtent ] ; ( void ) FormatLocaleString ( pointsize , MaxTextExtent , \"%.20g\" , draw_info -> pointsize ) ; ( void ) SetImageProperty ( image , \"caption:pointsize\" , pointsize ) ; } draw_info = DestroyDrawInfo ( draw_info ) ; caption = DestroyString ( caption ) ; if ( status == MagickFalse ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } return ( GetFirstImageInList ( image ) ) ; }\n","target":"<S2SV_ModStart> 0.0 ) ; ( void ) CloneString ( & <S2SV_ModStart> draw_info -> geometry , <S2SV_ModEnd> geometry ) ;\n","project_and_commit_id":"ImageMagick@ImageMagick/aeff00de228bc5a158c2a975ab47845d8a1db456","cve_id":"CVE-2016-10146","original_address":"https://github.com/ImageMagick/ImageMagick/commit/aeff00de228bc5a158c2a975ab47845d8a1db456","time":"2017-03-24T15:59Z"},
	{"Unnamed: 0":2013,"cwe_id":"CWE-000","source":"CWE-000 int ip6_append_data ( struct sock * sk , int getfrag ( void * from , char * to , int offset , int len , int odd , struct sk_buff * skb ) , void * from , int length , int transhdrlen , int hlimit , int tclass , struct ipv6_txoptions * opt , struct flowi6 * fl6 , struct rt6_info * rt , unsigned int flags , int dontfrag ) { struct inet_sock * inet = inet_sk ( sk ) ; struct ipv6_pinfo * np = inet6_sk ( sk ) ; struct inet_cork * cork ; struct sk_buff * skb ; unsigned int maxfraglen , fragheaderlen ; int exthdrlen ; int hh_len ; int mtu ; int copy ; int err ; int offset = 0 ; int csummode = CHECKSUM_NONE ; __u8 tx_flags = 0 ; if ( flags & MSG_PROBE ) return 0 ; cork = & inet -> cork . base ; if ( skb_queue_empty ( & sk -> sk_write_queue ) ) { if ( opt ) { if ( WARN_ON ( np -> cork . opt ) ) return - EINVAL ; np -> cork . opt = kmalloc ( opt -> tot_len , sk -> sk_allocation ) ; if ( unlikely ( np -> cork . opt == NULL ) ) return - ENOBUFS ; np -> cork . opt -> tot_len = opt -> tot_len ; np -> cork . opt -> opt_flen = opt -> opt_flen ; np -> cork . opt -> opt_nflen = opt -> opt_nflen ; np -> cork . opt -> dst0opt = ip6_opt_dup ( opt -> dst0opt , sk -> sk_allocation ) ; if ( opt -> dst0opt && ! np -> cork . opt -> dst0opt ) return - ENOBUFS ; np -> cork . opt -> dst1opt = ip6_opt_dup ( opt -> dst1opt , sk -> sk_allocation ) ; if ( opt -> dst1opt && ! np -> cork . opt -> dst1opt ) return - ENOBUFS ; np -> cork . opt -> hopopt = ip6_opt_dup ( opt -> hopopt , sk -> sk_allocation ) ; if ( opt -> hopopt && ! np -> cork . opt -> hopopt ) return - ENOBUFS ; np -> cork . opt -> srcrt = ip6_rthdr_dup ( opt -> srcrt , sk -> sk_allocation ) ; if ( opt -> srcrt && ! np -> cork . opt -> srcrt ) return - ENOBUFS ; } dst_hold ( & rt -> dst ) ; cork -> dst = & rt -> dst ; inet -> cork . fl . u . ip6 = * fl6 ; np -> cork . hop_limit = hlimit ; np -> cork . tclass = tclass ; mtu = np -> pmtudisc == IPV6_PMTUDISC_PROBE ? rt -> dst . dev -> mtu : dst_mtu ( rt -> dst . path ) ; if ( np -> frag_size < mtu ) { if ( np -> frag_size ) mtu = np -> frag_size ; } cork -> fragsize = mtu ; if ( dst_allfrag ( rt -> dst . path ) ) cork -> flags |= IPCORK_ALLFRAG ; cork -> length = 0 ; sk -> sk_sndmsg_page = NULL ; sk -> sk_sndmsg_off = 0 ; exthdrlen = rt -> dst . header_len + ( opt ? opt -> opt_flen : 0 ) - rt -> rt6i_nfheader_len ; length += exthdrlen ; transhdrlen += exthdrlen ; } else { rt = ( struct rt6_info * ) cork -> dst ; fl6 = & inet -> cork . fl . u . ip6 ; opt = np -> cork . opt ; transhdrlen = 0 ; exthdrlen = 0 ; mtu = cork -> fragsize ; } hh_len = LL_RESERVED_SPACE ( rt -> dst . dev ) ; fragheaderlen = sizeof ( struct ipv6hdr ) + rt -> rt6i_nfheader_len + ( opt ? opt -> opt_nflen : 0 ) ; maxfraglen = ( ( mtu - fragheaderlen ) & ~ 7 ) + fragheaderlen - sizeof ( struct frag_hdr ) ; if ( mtu <= sizeof ( struct ipv6hdr ) + IPV6_MAXPLEN ) { if ( cork -> length + length > sizeof ( struct ipv6hdr ) + IPV6_MAXPLEN - fragheaderlen ) { ipv6_local_error ( sk , EMSGSIZE , fl6 , mtu - exthdrlen ) ; return - EMSGSIZE ; } } if ( sk -> sk_type == SOCK_DGRAM ) { err = sock_tx_timestamp ( sk , & tx_flags ) ; if ( err ) goto error ; } cork -> length += length ; if ( length > mtu ) { int proto = sk -> sk_protocol ; if ( dontfrag && ( proto == IPPROTO_UDP || proto == IPPROTO_RAW ) ) { ipv6_local_rxpmtu ( sk , fl6 , mtu - exthdrlen ) ; return - EMSGSIZE ; } if ( proto == IPPROTO_UDP && ( rt -> dst . dev -> features & NETIF_F_UFO ) ) { err = ip6_ufo_append_data ( sk , getfrag , from , length , hh_len , fragheaderlen , <S2SV_StartBug> transhdrlen , mtu , flags ) ; <S2SV_EndBug> if ( err ) goto error ; return 0 ; } } if ( ( skb = skb_peek_tail ( & sk -> sk_write_queue ) ) == NULL ) goto alloc_new_skb ; while ( length > 0 ) { copy = ( cork -> length <= mtu && ! ( cork -> flags & IPCORK_ALLFRAG ) ? mtu : maxfraglen ) - skb -> len ; if ( copy < length ) copy = maxfraglen - skb -> len ; if ( copy <= 0 ) { char * data ; unsigned int datalen ; unsigned int fraglen ; unsigned int fraggap ; unsigned int alloclen ; struct sk_buff * skb_prev ; alloc_new_skb : skb_prev = skb ; if ( skb_prev ) fraggap = skb_prev -> len - maxfraglen ; else fraggap = 0 ; datalen = length + fraggap ; if ( datalen > ( cork -> length <= mtu && ! ( cork -> flags & IPCORK_ALLFRAG ) ? mtu : maxfraglen ) - fragheaderlen ) datalen = maxfraglen - fragheaderlen ; fraglen = datalen + fragheaderlen ; if ( ( flags & MSG_MORE ) && ! ( rt -> dst . dev -> features & NETIF_F_SG ) ) alloclen = mtu ; else alloclen = datalen + fragheaderlen ; if ( datalen == length + fraggap ) alloclen += rt -> dst . trailer_len ; alloclen += sizeof ( struct frag_hdr ) ; if ( transhdrlen ) { skb = sock_alloc_send_skb ( sk , alloclen + hh_len , ( flags & MSG_DONTWAIT ) , & err ) ; } else { skb = NULL ; if ( atomic_read ( & sk -> sk_wmem_alloc ) <= 2 * sk -> sk_sndbuf ) skb = sock_wmalloc ( sk , alloclen + hh_len , 1 , sk -> sk_allocation ) ; if ( unlikely ( skb == NULL ) ) err = - ENOBUFS ; else { tx_flags = 0 ; } } if ( skb == NULL ) goto error ; skb -> ip_summed = csummode ; skb -> csum = 0 ; skb_reserve ( skb , hh_len + sizeof ( struct frag_hdr ) ) ; if ( sk -> sk_type == SOCK_DGRAM ) skb_shinfo ( skb ) -> tx_flags = tx_flags ; data = skb_put ( skb , fraglen ) ; skb_set_network_header ( skb , exthdrlen ) ; data += fragheaderlen ; skb -> transport_header = ( skb -> network_header + fragheaderlen ) ; if ( fraggap ) { skb -> csum = skb_copy_and_csum_bits ( skb_prev , maxfraglen , data + transhdrlen , fraggap , 0 ) ; skb_prev -> csum = csum_sub ( skb_prev -> csum , skb -> csum ) ; data += fraggap ; pskb_trim_unique ( skb_prev , maxfraglen ) ; } copy = datalen - transhdrlen - fraggap ; if ( copy < 0 ) { err = - EINVAL ; kfree_skb ( skb ) ; goto error ; } else if ( copy > 0 && getfrag ( from , data + transhdrlen , offset , copy , fraggap , skb ) < 0 ) { err = - EFAULT ; kfree_skb ( skb ) ; goto error ; } offset += copy ; length -= datalen - fraggap ; transhdrlen = 0 ; exthdrlen = 0 ; csummode = CHECKSUM_NONE ; __skb_queue_tail ( & sk -> sk_write_queue , skb ) ; continue ; } if ( copy > length ) copy = length ; if ( ! ( rt -> dst . dev -> features & NETIF_F_SG ) ) { unsigned int off ; off = skb -> len ; if ( getfrag ( from , skb_put ( skb , copy ) , offset , copy , off , skb ) < 0 ) { __skb_trim ( skb , off ) ; err = - EFAULT ; goto error ; } } else { int i = skb_shinfo ( skb ) -> nr_frags ; skb_frag_t * frag = & skb_shinfo ( skb ) -> frags [ i - 1 ] ; struct page * page = sk -> sk_sndmsg_page ; int off = sk -> sk_sndmsg_off ; unsigned int left ; if ( page && ( left = PAGE_SIZE - off ) > 0 ) { if ( copy >= left ) copy = left ; if ( page != frag -> page ) { if ( i == MAX_SKB_FRAGS ) { err = - EMSGSIZE ; goto error ; } get_page ( page ) ; skb_fill_page_desc ( skb , i , page , sk -> sk_sndmsg_off , 0 ) ; frag = & skb_shinfo ( skb ) -> frags [ i ] ; } } else if ( i < MAX_SKB_FRAGS ) { if ( copy > PAGE_SIZE ) copy = PAGE_SIZE ; page = alloc_pages ( sk -> sk_allocation , 0 ) ; if ( page == NULL ) { err = - ENOMEM ; goto error ; } sk -> sk_sndmsg_page = page ; sk -> sk_sndmsg_off = 0 ; skb_fill_page_desc ( skb , i , page , 0 , 0 ) ; frag = & skb_shinfo ( skb ) -> frags [ i ] ; } else { err = - EMSGSIZE ; goto error ; } if ( getfrag ( from , page_address ( frag -> page ) + frag -> page_offset + frag -> size , offset , copy , skb -> len , skb ) < 0 ) { err = - EFAULT ; goto error ; } sk -> sk_sndmsg_off += copy ; frag -> size += copy ; skb -> len += copy ; skb -> data_len += copy ; skb -> truesize += copy ; atomic_add ( copy , & sk -> sk_wmem_alloc ) ; } offset += copy ; length -= copy ; } return 0 ; error : cork -> length -= length ; IP6_INC_STATS ( sock_net ( sk ) , rt -> rt6i_idev , IPSTATS_MIB_OUTDISCARDS ) ; return err ; }\n","target":"<S2SV_ModStart> mtu , flags , rt\n","project_and_commit_id":"torvalds@linux/87c48fa3b4630905f98268dde838ee43626a060c","cve_id":"CVE-2011-2699","original_address":"https://github.com/torvalds/linux/commit/87c48fa3b4630905f98268dde838ee43626a060c","time":"2012-05-24T23:55Z"},
	{"Unnamed: 0":333,"cwe_id":"CWE-674","source":"CWE-674 static void Sp_split_regexp ( js_State * J ) { js_Regexp * re ; const char * text ; int limit , len , k ; const char * p , * a , * b , * c , * e ; Resub m ; text = checkstring ( J , 0 ) ; re = js_toregexp ( J , 1 ) ; limit = js_isdefined ( J , 2 ) ? js_tointeger ( J , 2 ) : 1 << 30 ; js_newarray ( J ) ; len = 0 ; e = text + strlen ( text ) ; if ( e == text ) { <S2SV_StartBug> if ( js_regexec ( re -> prog , text , & m , 0 ) ) { <S2SV_EndBug> if ( len == limit ) return ; js_pushliteral ( J , \"\" ) ; js_setindex ( J , - 2 , 0 ) ; } return ; } p = a = text ; while ( a < e ) { <S2SV_StartBug> if ( js_regexec ( re -> prog , a , & m , a > text ? REG_NOTBOL : 0 ) ) <S2SV_EndBug> break ; b = m . sub [ 0 ] . sp ; c = m . sub [ 0 ] . ep ; if ( b == p ) { ++ a ; continue ; } if ( len == limit ) return ; js_pushlstring ( J , p , b - p ) ; js_setindex ( J , - 2 , len ++ ) ; for ( k = 1 ; k < m . nsub ; ++ k ) { if ( len == limit ) return ; js_pushlstring ( J , m . sub [ k ] . sp , m . sub [ k ] . ep - m . sub [ k ] . sp ) ; js_setindex ( J , - 2 , len ++ ) ; } a = p = c ; } if ( len == limit ) return ; js_pushstring ( J , p ) ; js_setindex ( J , - 2 , len ) ; }\n","target":"<S2SV_ModStart> { if ( js_doregexec ( J , <S2SV_ModEnd> re -> prog <S2SV_ModStart> { if ( js_doregexec ( J , <S2SV_ModEnd> re -> prog\n","project_and_commit_id":"ccxvii@mujs/00d4606c3baf813b7b1c176823b2729bf51002a2","cve_id":"CVE-2019-11413","original_address":"https://github.com/ccxvii/mujs/commit/00d4606c3baf813b7b1c176823b2729bf51002a2","time":"2019-04-22T11:29Z"},
	{"Unnamed: 0":530,"cwe_id":"CWE-125","source":"CWE-125 static Image * ReadRLEImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { # define SkipLinesOp 0x01 # define SetColorOp 0x02 # define SkipPixelsOp 0x03 # define ByteDataOp 0x05 # define RunDataOp 0x06 # define EOFOp 0x07 char magick [ 12 ] ; Image * image ; int opcode , operand , status ; MagickStatusType flags ; MagickSizeType number_pixels ; MemoryInfo * pixel_info ; Quantum index ; register ssize_t x ; register Quantum * q ; register ssize_t i ; register unsigned char * p ; size_t bits_per_pixel , map_length , number_colormaps , <S2SV_StartBug> number_planes , <S2SV_EndBug> one , offset , pixel_info_length ; ssize_t count , y ; unsigned char background_color [ 256 ] , * colormap , pixel , plane , * pixels ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickCoreSignature ) ; if ( image_info -> debug != MagickFalse ) ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , \"%s\" , image_info -> filename ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickCoreSignature ) ; image = AcquireImage ( image_info , exception ) ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) return ( DestroyImageList ( image ) ) ; count = ReadBlob ( image , 2 , ( unsigned char * ) magick ) ; if ( ( count != 2 ) || ( memcmp ( magick , \"\\\\122\\\\314\" , 2 ) != 0 ) ) ThrowReaderException ( CorruptImageError , \"ImproperImageHeader\" ) ; do { image -> page . x = ReadBlobLSBShort ( image ) ; image -> page . y = ReadBlobLSBShort ( image ) ; image -> columns = ReadBlobLSBShort ( image ) ; image -> rows = ReadBlobLSBShort ( image ) ; flags = ( MagickStatusType ) ReadBlobByte ( image ) ; image -> alpha_trait = flags & 0x04 ? BlendPixelTrait : UndefinedPixelTrait ; number_planes = ( size_t ) ReadBlobByte ( image ) ; bits_per_pixel = ( size_t ) ReadBlobByte ( image ) ; number_colormaps = ( size_t ) ReadBlobByte ( image ) ; map_length = ( unsigned char ) ReadBlobByte ( image ) ; if ( map_length >= 64 ) ThrowReaderException ( CorruptImageError , \"ImproperImageHeader\" ) ; one = 1 ; map_length = one << map_length ; if ( ( number_planes == 0 ) || ( number_planes == 2 ) || ( bits_per_pixel != 8 ) || ( image -> columns == 0 ) ) ThrowReaderException ( CorruptImageError , \"ImproperImageHeader\" ) ; if ( flags & 0x02 ) { for ( i = 0 ; i < ( ssize_t ) number_planes ; i ++ ) background_color [ i ] = 0 ; ( void ) ReadBlobByte ( image ) ; } else { p = background_color ; for ( i = 0 ; i < ( ssize_t ) number_planes ; i ++ ) * p ++ = ( unsigned char ) ReadBlobByte ( image ) ; } if ( ( number_planes & 0x01 ) == 0 ) ( void ) ReadBlobByte ( image ) ; if ( EOFBlob ( image ) != MagickFalse ) { ThrowFileException ( exception , CorruptImageError , \"UnexpectedEndOfFile\" , image -> filename ) ; break ; } colormap = ( unsigned char * ) NULL ; if ( number_colormaps != 0 ) { colormap = ( unsigned char * ) AcquireQuantumMemory ( number_colormaps , 3 * map_length * sizeof ( * colormap ) ) ; if ( colormap == ( unsigned char * ) NULL ) ThrowReaderException ( ResourceLimitError , \"MemoryAllocationFailed\" ) ; p = colormap ; for ( i = 0 ; i < ( ssize_t ) number_colormaps ; i ++ ) for ( x = 0 ; x < ( ssize_t ) map_length ; x ++ ) * p ++ = ( unsigned char ) ScaleShortToQuantum ( ReadBlobLSBShort ( image ) ) ; } if ( ( flags & 0x08 ) != 0 ) { char * comment ; size_t length ; length = ReadBlobLSBShort ( image ) ; if ( length != 0 ) { comment = ( char * ) AcquireQuantumMemory ( length , sizeof ( * comment ) ) ; if ( comment == ( char * ) NULL ) ThrowReaderException ( ResourceLimitError , \"MemoryAllocationFailed\" ) ; count = ReadBlob ( image , length - 1 , ( unsigned char * ) comment ) ; comment [ length - 1 ] = '\\\\0' ; ( void ) SetImageProperty ( image , \"comment\" , comment , exception ) ; comment = DestroyString ( comment ) ; if ( ( length & 0x01 ) == 0 ) ( void ) ReadBlobByte ( image ) ; } } if ( ( image_info -> ping != MagickFalse ) && ( image_info -> number_scenes != 0 ) ) if ( image -> scene >= ( image_info -> scene + image_info -> number_scenes - 1 ) ) break ; status = SetImageExtent ( image , image -> columns , image -> rows , exception ) ; if ( status == MagickFalse ) return ( DestroyImageList ( image ) ) ; if ( image -> alpha_trait != UndefinedPixelTrait ) number_planes ++ ; number_pixels = ( MagickSizeType ) image -> columns * image -> rows ; <S2SV_StartBug> if ( ( number_pixels * number_planes ) != ( size_t ) ( number_pixels * number_planes ) ) <S2SV_EndBug> ThrowReaderException ( ResourceLimitError , \"MemoryAllocationFailed\" ) ; <S2SV_StartBug> pixel_info_length = image -> columns * image -> rows * MagickMax ( number_planes , 4 ) ; <S2SV_EndBug> pixel_info = AcquireVirtualMemory ( pixel_info_length , sizeof ( * pixels ) ) ; if ( pixel_info == ( MemoryInfo * ) NULL ) ThrowReaderException ( ResourceLimitError , \"MemoryAllocationFailed\" ) ; pixels = ( unsigned char * ) GetVirtualMemoryBlob ( pixel_info ) ; if ( ( flags & 0x01 ) && ! ( flags & 0x02 ) ) { ssize_t j ; p = pixels ; for ( i = 0 ; i < ( ssize_t ) number_pixels ; i ++ ) { if ( image -> alpha_trait == UndefinedPixelTrait ) for ( j = 0 ; j < ( ssize_t ) number_planes ; j ++ ) * p ++ = background_color [ j ] ; else { for ( j = 0 ; j < ( ssize_t ) ( number_planes - 1 ) ; j ++ ) * p ++ = background_color [ j ] ; * p ++ = 0 ; } } } plane = 0 ; x = 0 ; y = 0 ; opcode = ReadBlobByte ( image ) ; do { switch ( opcode & 0x3f ) { case SkipLinesOp : { operand = ReadBlobByte ( image ) ; if ( opcode & 0x40 ) operand = ( int ) ReadBlobLSBShort ( image ) ; x = 0 ; y += operand ; break ; } case SetColorOp : { operand = ReadBlobByte ( image ) ; plane = ( unsigned char ) operand ; if ( plane == 255 ) plane = ( unsigned char ) ( number_planes - 1 ) ; x = 0 ; break ; } case SkipPixelsOp : { operand = ReadBlobByte ( image ) ; if ( opcode & 0x40 ) operand = ( int ) ReadBlobLSBShort ( image ) ; x += operand ; break ; } case ByteDataOp : { operand = ReadBlobByte ( image ) ; if ( opcode & 0x40 ) operand = ( int ) ReadBlobLSBShort ( image ) ; offset = ( ( image -> rows - y - 1 ) * image -> columns * number_planes ) + x * number_planes + plane ; operand ++ ; if ( offset + ( ( size_t ) operand * number_planes ) > pixel_info_length ) { if ( number_colormaps != 0 ) colormap = ( unsigned char * ) RelinquishMagickMemory ( colormap ) ; pixel_info = RelinquishVirtualMemory ( pixel_info ) ; ThrowReaderException ( CorruptImageError , \"UnableToReadImageData\" ) ; } p = pixels + offset ; for ( i = 0 ; i < ( ssize_t ) operand ; i ++ ) { pixel = ( unsigned char ) ReadBlobByte ( image ) ; if ( ( y < ( ssize_t ) image -> rows ) && ( ( x + i ) < ( ssize_t ) image -> columns ) ) * p = pixel ; p += number_planes ; } if ( operand & 0x01 ) ( void ) ReadBlobByte ( image ) ; x += operand ; break ; } case RunDataOp : { operand = ReadBlobByte ( image ) ; if ( opcode & 0x40 ) operand = ( int ) ReadBlobLSBShort ( image ) ; pixel = ( unsigned char ) ReadBlobByte ( image ) ; ( void ) ReadBlobByte ( image ) ; offset = ( ( image -> rows - y - 1 ) * image -> columns * number_planes ) + x * number_planes + plane ; operand ++ ; if ( offset + ( ( size_t ) operand * number_planes ) > pixel_info_length ) { if ( number_colormaps != 0 ) colormap = ( unsigned char * ) RelinquishMagickMemory ( colormap ) ; pixel_info = RelinquishVirtualMemory ( pixel_info ) ; ThrowReaderException ( CorruptImageError , \"UnableToReadImageData\" ) ; } p = pixels + offset ; for ( i = 0 ; i < ( ssize_t ) operand ; i ++ ) { if ( ( y < ( ssize_t ) image -> rows ) && ( ( x + i ) < ( ssize_t ) image -> columns ) ) * p = pixel ; p += number_planes ; } x += operand ; break ; } default : break ; } opcode = ReadBlobByte ( image ) ; } while ( ( ( opcode & 0x3f ) != EOFOp ) && ( opcode != EOF ) ) ; if ( number_colormaps != 0 ) { MagickStatusType mask ; mask = ( MagickStatusType ) ( map_length - 1 ) ; p = pixels ; x = ( ssize_t ) number_planes ; if ( number_colormaps == 1 ) for ( i = 0 ; i < ( ssize_t ) number_pixels ; i ++ ) { if ( IsValidColormapIndex ( image , * p & mask , & index , exception ) == MagickFalse ) break ; * p = colormap [ ( ssize_t ) index ] ; p ++ ; } else if ( ( number_planes >= 3 ) && ( number_colormaps >= 3 ) ) for ( i = 0 ; i < ( ssize_t ) number_pixels ; i ++ ) for ( x = 0 ; x < ( ssize_t ) number_planes ; x ++ ) { if ( IsValidColormapIndex ( image , ( size_t ) ( x * map_length + ( * p & mask ) ) , & index , exception ) == MagickFalse ) break ; * p = colormap [ ( ssize_t ) index ] ; p ++ ; } if ( ( i < ( ssize_t ) number_pixels ) || ( x < ( ssize_t ) number_planes ) ) { colormap = ( unsigned char * ) RelinquishMagickMemory ( colormap ) ; pixel_info = RelinquishVirtualMemory ( pixel_info ) ; ThrowReaderException ( CorruptImageError , \"UnableToReadImageData\" ) ; } } if ( number_planes >= 3 ) { p = pixels ; for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { SetPixelRed ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; SetPixelGreen ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; SetPixelBlue ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; if ( image -> alpha_trait != UndefinedPixelTrait ) SetPixelAlpha ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; q += GetPixelChannels ( image ) ; } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ; if ( status == MagickFalse ) break ; } } } else { if ( number_colormaps == 0 ) map_length = 256 ; if ( AcquireImageColormap ( image , map_length , exception ) == MagickFalse ) ThrowReaderException ( ResourceLimitError , \"MemoryAllocationFailed\" ) ; p = colormap ; if ( number_colormaps == 1 ) for ( i = 0 ; i < ( ssize_t ) image -> colors ; i ++ ) { image -> colormap [ i ] . red = ( MagickRealType ) ScaleCharToQuantum ( ( unsigned char ) i ) ; image -> colormap [ i ] . green = ( MagickRealType ) ScaleCharToQuantum ( ( unsigned char ) i ) ; image -> colormap [ i ] . blue = ( MagickRealType ) ScaleCharToQuantum ( ( unsigned char ) i ) ; } else if ( number_colormaps > 1 ) for ( i = 0 ; i < ( ssize_t ) image -> colors ; i ++ ) { image -> colormap [ i ] . red = ( MagickRealType ) ScaleCharToQuantum ( * p ) ; image -> colormap [ i ] . green = ( MagickRealType ) ScaleCharToQuantum ( * ( p + map_length ) ) ; image -> colormap [ i ] . blue = ( MagickRealType ) ScaleCharToQuantum ( * ( p + map_length * 2 ) ) ; p ++ ; } p = pixels ; if ( image -> alpha_trait == UndefinedPixelTrait ) { for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { SetPixelIndex ( image , * p ++ , q ) ; q += GetPixelChannels ( image ) ; } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ; if ( status == MagickFalse ) break ; } } ( void ) SyncImage ( image , exception ) ; } else { for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { if ( IsValidColormapIndex ( image , ( ssize_t ) * p ++ , & index , exception ) == MagickFalse ) break ; SetPixelRed ( image , ClampToQuantum ( image -> colormap [ ( ssize_t ) index ] . red ) , q ) ; if ( IsValidColormapIndex ( image , ( ssize_t ) * p ++ , & index , exception ) == MagickFalse ) break ; SetPixelGreen ( image , ClampToQuantum ( image -> colormap [ ( ssize_t ) index ] . green ) , q ) ; if ( IsValidColormapIndex ( image , ( ssize_t ) * p ++ , & index , exception ) == MagickFalse ) break ; SetPixelBlue ( image , ClampToQuantum ( image -> colormap [ ( ssize_t ) index ] . blue ) , q ) ; SetPixelAlpha ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; q += GetPixelChannels ( image ) ; } if ( x < ( ssize_t ) image -> columns ) break ; if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ; if ( status == MagickFalse ) break ; } } image -> colormap = ( PixelInfo * ) RelinquishMagickMemory ( image -> colormap ) ; image -> storage_class = DirectClass ; image -> colors = 0 ; } } if ( number_colormaps != 0 ) colormap = ( unsigned char * ) RelinquishMagickMemory ( colormap ) ; pixel_info = RelinquishVirtualMemory ( pixel_info ) ; if ( EOFBlob ( image ) != MagickFalse ) { ThrowFileException ( exception , CorruptImageError , \"UnexpectedEndOfFile\" , image -> filename ) ; break ; } if ( image_info -> number_scenes != 0 ) if ( image -> scene >= ( image_info -> scene + image_info -> number_scenes - 1 ) ) break ; ( void ) ReadBlobByte ( image ) ; count = ReadBlob ( image , 2 , ( unsigned char * ) magick ) ; if ( ( count != 0 ) && ( memcmp ( magick , \"\\\\122\\\\314\" , 2 ) == 0 ) ) { AcquireNextImage ( image_info , image , exception ) ; if ( GetNextImageInList ( image ) == ( Image * ) NULL ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } image = SyncNextImageInList ( image ) ; status = SetImageProgress ( image , LoadImagesTag , TellBlob ( image ) , GetBlobSize ( image ) ) ; if ( status == MagickFalse ) break ; } } while ( ( count != 0 ) && ( memcmp ( magick , \"\\\\122\\\\314\" , 2 ) == 0 ) ) ; ( void ) CloseBlob ( image ) ; return ( GetFirstImageInList ( image ) ) ; }\n","target":"<S2SV_ModStart> number_colormaps , number_planes , number_planes_filled <S2SV_ModStart> -> rows ; number_planes_filled = ( number_planes % 2 == 0 ) ? number_planes : number_planes + 1 ; <S2SV_ModStart> ( number_pixels * number_planes_filled <S2SV_ModEnd> ) != ( <S2SV_ModStart> ( number_pixels * number_planes_filled <S2SV_ModEnd> ) ) ThrowReaderException <S2SV_ModStart> -> rows * number_planes_filled <S2SV_ModEnd> ; pixel_info =\n","project_and_commit_id":"ImageMagick@ImageMagick/2ad6d33493750a28a5a655d319a8e0b16c392de1","cve_id":"CVE-2016-7515","original_address":"https://github.com/ImageMagick/ImageMagick/commit/2ad6d33493750a28a5a655d319a8e0b16c392de1","time":"2017-04-19T14:59Z"},
	{"Unnamed: 0":481,"cwe_id":"CWE-264","source":"CWE-264 static void tun_net_init ( struct net_device * dev ) { struct tun_struct * tun = netdev_priv ( dev ) ; switch ( tun -> flags & TUN_TYPE_MASK ) { case TUN_TUN_DEV : dev -> netdev_ops = & tun_netdev_ops ; dev -> hard_header_len = 0 ; dev -> addr_len = 0 ; dev -> mtu = 1500 ; dev -> type = ARPHRD_NONE ; dev -> flags = IFF_POINTOPOINT | IFF_NOARP | IFF_MULTICAST ; dev -> tx_queue_len = TUN_READQ_SIZE ; break ; case TUN_TAP_DEV : dev -> netdev_ops = & tap_netdev_ops ; ether_setup ( dev ) ; <S2SV_StartBug> random_ether_addr ( dev -> dev_addr ) ; <S2SV_EndBug> dev -> tx_queue_len = TUN_READQ_SIZE ; break ; } }\n","target":"<S2SV_ModStart> dev ) ; dev -> priv_flags &= ~ IFF_TX_SKB_SHARING ;\n","project_and_commit_id":"torvalds@linux/550fd08c2cebad61c548def135f67aba284c6162","cve_id":"CVE-2011-4112","original_address":"https://github.com/torvalds/linux/commit/550fd08c2cebad61c548def135f67aba284c6162","time":"2012-05-17T11:00Z"},
	{"Unnamed: 0":2257,"cwe_id":"CWE-310","source":"CWE-310 int ssl3_accept ( SSL * s ) { BUF_MEM * buf ; unsigned long alg_k , Time = ( unsigned long ) time ( NULL ) ; void ( * cb ) ( const SSL * ssl , int type , int val ) = NULL ; int ret = - 1 ; int new_state , state , skip = 0 ; RAND_add ( & Time , sizeof ( Time ) , 0 ) ; ERR_clear_error ( ) ; clear_sys_error ( ) ; if ( s -> info_callback != NULL ) cb = s -> info_callback ; else if ( s -> ctx -> info_callback != NULL ) cb = s -> ctx -> info_callback ; s -> in_handshake ++ ; if ( ! SSL_in_init ( s ) || SSL_in_before ( s ) ) SSL_clear ( s ) ; if ( s -> cert == NULL ) { SSLerr ( SSL_F_SSL3_ACCEPT , SSL_R_NO_CERTIFICATE_SET ) ; return ( - 1 ) ; } # ifndef OPENSSL_NO_HEARTBEATS if ( s -> tlsext_hb_pending ) { s -> tlsext_hb_pending = 0 ; s -> tlsext_hb_seq ++ ; } # endif for ( ; ; ) { state = s -> state ; switch ( s -> state ) { case SSL_ST_RENEGOTIATE : s -> renegotiate = 1 ; case SSL_ST_BEFORE : case SSL_ST_ACCEPT : case SSL_ST_BEFORE | SSL_ST_ACCEPT : case SSL_ST_OK | SSL_ST_ACCEPT : s -> server = 1 ; if ( cb != NULL ) cb ( s , SSL_CB_HANDSHAKE_START , 1 ) ; if ( ( s -> version >> 8 ) != 3 ) { SSLerr ( SSL_F_SSL3_ACCEPT , ERR_R_INTERNAL_ERROR ) ; return - 1 ; } if ( ! ssl_security ( s , SSL_SECOP_VERSION , 0 , s -> version , NULL ) ) { SSLerr ( SSL_F_SSL3_ACCEPT , SSL_R_VERSION_TOO_LOW ) ; return - 1 ; } s -> type = SSL_ST_ACCEPT ; if ( s -> init_buf == NULL ) { if ( ( buf = BUF_MEM_new ( ) ) == NULL ) { ret = - 1 ; goto end ; } if ( ! BUF_MEM_grow ( buf , SSL3_RT_MAX_PLAIN_LENGTH ) ) { BUF_MEM_free ( buf ) ; ret = - 1 ; goto end ; } s -> init_buf = buf ; } if ( ! ssl3_setup_buffers ( s ) ) { ret = - 1 ; goto end ; } s -> init_num = 0 ; s -> s3 -> flags &= ~ TLS1_FLAGS_SKIP_CERT_VERIFY ; s -> s3 -> flags &= ~ SSL3_FLAGS_CCS_OK ; s -> s3 -> change_cipher_spec = 0 ; if ( s -> state != SSL_ST_RENEGOTIATE ) { if ( ! ssl_init_wbio_buffer ( s , 1 ) ) { ret = - 1 ; goto end ; } ssl3_init_finished_mac ( s ) ; s -> state = SSL3_ST_SR_CLNT_HELLO_A ; s -> ctx -> stats . sess_accept ++ ; } else if ( ! s -> s3 -> send_connection_binding && ! ( s -> options & SSL_OP_ALLOW_UNSAFE_LEGACY_RENEGOTIATION ) ) { SSLerr ( SSL_F_SSL3_ACCEPT , SSL_R_UNSAFE_LEGACY_RENEGOTIATION_DISABLED ) ; ssl3_send_alert ( s , SSL3_AL_FATAL , SSL_AD_HANDSHAKE_FAILURE ) ; ret = - 1 ; goto end ; } else { s -> ctx -> stats . sess_accept_renegotiate ++ ; s -> state = SSL3_ST_SW_HELLO_REQ_A ; } break ; case SSL3_ST_SW_HELLO_REQ_A : case SSL3_ST_SW_HELLO_REQ_B : s -> shutdown = 0 ; ret = ssl3_send_hello_request ( s ) ; if ( ret <= 0 ) goto end ; s -> s3 -> tmp . next_state = SSL3_ST_SW_HELLO_REQ_C ; s -> state = SSL3_ST_SW_FLUSH ; s -> init_num = 0 ; ssl3_init_finished_mac ( s ) ; break ; case SSL3_ST_SW_HELLO_REQ_C : s -> state = SSL_ST_OK ; break ; case SSL3_ST_SR_CLNT_HELLO_A : case SSL3_ST_SR_CLNT_HELLO_B : case SSL3_ST_SR_CLNT_HELLO_C : ret = ssl3_get_client_hello ( s ) ; if ( ret <= 0 ) goto end ; # ifndef OPENSSL_NO_SRP s -> state = SSL3_ST_SR_CLNT_HELLO_D ; case SSL3_ST_SR_CLNT_HELLO_D : { int al ; if ( ( ret = ssl_check_srp_ext_ClientHello ( s , & al ) ) < 0 ) { s -> rwstate = SSL_X509_LOOKUP ; goto end ; } if ( ret != SSL_ERROR_NONE ) { ssl3_send_alert ( s , SSL3_AL_FATAL , al ) ; if ( al != TLS1_AD_UNKNOWN_PSK_IDENTITY ) SSLerr ( SSL_F_SSL3_ACCEPT , SSL_R_CLIENTHELLO_TLSEXT ) ; ret = SSL_TLSEXT_ERR_ALERT_FATAL ; ret = - 1 ; goto end ; } } # endif s -> renegotiate = 2 ; s -> state = SSL3_ST_SW_SRVR_HELLO_A ; s -> init_num = 0 ; break ; case SSL3_ST_SW_SRVR_HELLO_A : case SSL3_ST_SW_SRVR_HELLO_B : ret = ssl3_send_server_hello ( s ) ; if ( ret <= 0 ) goto end ; # ifndef OPENSSL_NO_TLSEXT if ( s -> hit ) { if ( s -> tlsext_ticket_expected ) s -> state = SSL3_ST_SW_SESSION_TICKET_A ; else s -> state = SSL3_ST_SW_CHANGE_A ; } # else if ( s -> hit ) s -> state = SSL3_ST_SW_CHANGE_A ; # endif else s -> state = SSL3_ST_SW_CERT_A ; s -> init_num = 0 ; break ; case SSL3_ST_SW_CERT_A : case SSL3_ST_SW_CERT_B : if ( ! ( s -> s3 -> tmp . new_cipher -> algorithm_auth & ( SSL_aNULL | SSL_aKRB5 | SSL_aSRP ) ) && ! ( s -> s3 -> tmp . new_cipher -> algorithm_mkey & SSL_kPSK ) ) { ret = ssl3_send_server_certificate ( s ) ; if ( ret <= 0 ) goto end ; # ifndef OPENSSL_NO_TLSEXT if ( s -> tlsext_status_expected ) s -> state = SSL3_ST_SW_CERT_STATUS_A ; else s -> state = SSL3_ST_SW_KEY_EXCH_A ; } else { skip = 1 ; s -> state = SSL3_ST_SW_KEY_EXCH_A ; } # else } else skip = 1 ; s -> state = SSL3_ST_SW_KEY_EXCH_A ; # endif s -> init_num = 0 ; break ; case SSL3_ST_SW_KEY_EXCH_A : case SSL3_ST_SW_KEY_EXCH_B : alg_k = s -> s3 -> tmp . new_cipher -> algorithm_mkey ; <S2SV_StartBug> if ( ( s -> options & SSL_OP_EPHEMERAL_RSA ) <S2SV_EndBug> # ifndef OPENSSL_NO_KRB5 && ! ( alg_k & SSL_kKRB5 ) # endif ) <S2SV_StartBug> s -> s3 -> tmp . use_rsa_tmp = 1 ; <S2SV_EndBug> else s -> s3 -> tmp . use_rsa_tmp = 0 ; if ( s -> s3 -> tmp . use_rsa_tmp # ifndef OPENSSL_NO_PSK || ( ( alg_k & SSL_kPSK ) && s -> ctx -> psk_identity_hint ) # endif # ifndef OPENSSL_NO_SRP || ( alg_k & SSL_kSRP ) # endif || ( alg_k & SSL_kDHE ) || ( alg_k & SSL_kECDHE ) || ( ( alg_k & SSL_kRSA ) && ( s -> cert -> pkeys [ SSL_PKEY_RSA_ENC ] . privatekey == NULL || ( SSL_C_IS_EXPORT ( s -> s3 -> tmp . new_cipher ) && EVP_PKEY_size ( s -> cert -> pkeys [ SSL_PKEY_RSA_ENC ] . privatekey ) * 8 > SSL_C_EXPORT_PKEYLENGTH ( s -> s3 -> tmp . new_cipher ) ) ) ) ) { ret = ssl3_send_server_key_exchange ( s ) ; if ( ret <= 0 ) goto end ; } else skip = 1 ; s -> state = SSL3_ST_SW_CERT_REQ_A ; s -> init_num = 0 ; break ; case SSL3_ST_SW_CERT_REQ_A : case SSL3_ST_SW_CERT_REQ_B : if ( ! ( s -> verify_mode & SSL_VERIFY_PEER ) || ( ( s -> session -> peer != NULL ) && ( s -> verify_mode & SSL_VERIFY_CLIENT_ONCE ) ) || ( ( s -> s3 -> tmp . new_cipher -> algorithm_auth & SSL_aNULL ) && ! ( s -> verify_mode & SSL_VERIFY_FAIL_IF_NO_PEER_CERT ) ) || ( s -> s3 -> tmp . new_cipher -> algorithm_auth & SSL_aKRB5 ) || ( s -> s3 -> tmp . new_cipher -> algorithm_auth & SSL_aSRP ) || ( s -> s3 -> tmp . new_cipher -> algorithm_mkey & SSL_kPSK ) ) { skip = 1 ; s -> s3 -> tmp . cert_request = 0 ; s -> state = SSL3_ST_SW_SRVR_DONE_A ; if ( s -> s3 -> handshake_buffer ) if ( ! ssl3_digest_cached_records ( s ) ) return - 1 ; } else { s -> s3 -> tmp . cert_request = 1 ; ret = ssl3_send_certificate_request ( s ) ; if ( ret <= 0 ) goto end ; # ifndef NETSCAPE_HANG_BUG s -> state = SSL3_ST_SW_SRVR_DONE_A ; # else s -> state = SSL3_ST_SW_FLUSH ; s -> s3 -> tmp . next_state = SSL3_ST_SR_CERT_A ; # endif s -> init_num = 0 ; } break ; case SSL3_ST_SW_SRVR_DONE_A : case SSL3_ST_SW_SRVR_DONE_B : ret = ssl3_send_server_done ( s ) ; if ( ret <= 0 ) goto end ; s -> s3 -> tmp . next_state = SSL3_ST_SR_CERT_A ; s -> state = SSL3_ST_SW_FLUSH ; s -> init_num = 0 ; break ; case SSL3_ST_SW_FLUSH : s -> rwstate = SSL_WRITING ; if ( BIO_flush ( s -> wbio ) <= 0 ) { ret = - 1 ; goto end ; } s -> rwstate = SSL_NOTHING ; s -> state = s -> s3 -> tmp . next_state ; break ; case SSL3_ST_SR_CERT_A : case SSL3_ST_SR_CERT_B : if ( s -> s3 -> tmp . cert_request ) { ret = ssl3_get_client_certificate ( s ) ; if ( ret <= 0 ) goto end ; } s -> init_num = 0 ; s -> state = SSL3_ST_SR_KEY_EXCH_A ; break ; case SSL3_ST_SR_KEY_EXCH_A : case SSL3_ST_SR_KEY_EXCH_B : ret = ssl3_get_client_key_exchange ( s ) ; if ( ret <= 0 ) goto end ; if ( ret == 2 ) { # if defined ( OPENSSL_NO_TLSEXT ) || defined ( OPENSSL_NO_NEXTPROTONEG ) s -> state = SSL3_ST_SR_FINISHED_A ; # else if ( s -> s3 -> next_proto_neg_seen ) s -> state = SSL3_ST_SR_NEXT_PROTO_A ; else s -> state = SSL3_ST_SR_FINISHED_A ; # endif s -> init_num = 0 ; } else if ( SSL_USE_SIGALGS ( s ) ) { s -> state = SSL3_ST_SR_CERT_VRFY_A ; s -> init_num = 0 ; if ( ! s -> session -> peer ) break ; if ( ! s -> s3 -> handshake_buffer ) { SSLerr ( SSL_F_SSL3_ACCEPT , ERR_R_INTERNAL_ERROR ) ; return - 1 ; } s -> s3 -> flags |= TLS1_FLAGS_KEEP_HANDSHAKE ; if ( ! ssl3_digest_cached_records ( s ) ) return - 1 ; } else { int offset = 0 ; int dgst_num ; s -> state = SSL3_ST_SR_CERT_VRFY_A ; s -> init_num = 0 ; if ( s -> s3 -> handshake_buffer ) if ( ! ssl3_digest_cached_records ( s ) ) return - 1 ; for ( dgst_num = 0 ; dgst_num < SSL_MAX_DIGEST ; dgst_num ++ ) if ( s -> s3 -> handshake_dgst [ dgst_num ] ) { int dgst_size ; s -> method -> ssl3_enc -> cert_verify_mac ( s , EVP_MD_CTX_type ( s -> s3 -> handshake_dgst [ dgst_num ] ) , & ( s -> s3 -> tmp . cert_verify_md [ offset ] ) ) ; dgst_size = EVP_MD_CTX_size ( s -> s3 -> handshake_dgst [ dgst_num ] ) ; if ( dgst_size < 0 ) { ret = - 1 ; goto end ; } offset += dgst_size ; } } break ; case SSL3_ST_SR_CERT_VRFY_A : case SSL3_ST_SR_CERT_VRFY_B : if ( ! s -> s3 -> change_cipher_spec ) s -> s3 -> flags |= SSL3_FLAGS_CCS_OK ; ret = ssl3_get_cert_verify ( s ) ; if ( ret <= 0 ) goto end ; # if defined ( OPENSSL_NO_TLSEXT ) || defined ( OPENSSL_NO_NEXTPROTONEG ) s -> state = SSL3_ST_SR_FINISHED_A ; # else if ( s -> s3 -> next_proto_neg_seen ) s -> state = SSL3_ST_SR_NEXT_PROTO_A ; else s -> state = SSL3_ST_SR_FINISHED_A ; # endif s -> init_num = 0 ; break ; # if ! defined ( OPENSSL_NO_TLSEXT ) && ! defined ( OPENSSL_NO_NEXTPROTONEG ) case SSL3_ST_SR_NEXT_PROTO_A : case SSL3_ST_SR_NEXT_PROTO_B : if ( ! s -> s3 -> change_cipher_spec ) s -> s3 -> flags |= SSL3_FLAGS_CCS_OK ; ret = ssl3_get_next_proto ( s ) ; if ( ret <= 0 ) goto end ; s -> init_num = 0 ; s -> state = SSL3_ST_SR_FINISHED_A ; break ; # endif case SSL3_ST_SR_FINISHED_A : case SSL3_ST_SR_FINISHED_B : if ( ! s -> s3 -> change_cipher_spec ) s -> s3 -> flags |= SSL3_FLAGS_CCS_OK ; ret = ssl3_get_finished ( s , SSL3_ST_SR_FINISHED_A , SSL3_ST_SR_FINISHED_B ) ; if ( ret <= 0 ) goto end ; if ( s -> hit ) s -> state = SSL_ST_OK ; # ifndef OPENSSL_NO_TLSEXT else if ( s -> tlsext_ticket_expected ) s -> state = SSL3_ST_SW_SESSION_TICKET_A ; # endif else s -> state = SSL3_ST_SW_CHANGE_A ; s -> init_num = 0 ; break ; # ifndef OPENSSL_NO_TLSEXT case SSL3_ST_SW_SESSION_TICKET_A : case SSL3_ST_SW_SESSION_TICKET_B : ret = ssl3_send_newsession_ticket ( s ) ; if ( ret <= 0 ) goto end ; s -> state = SSL3_ST_SW_CHANGE_A ; s -> init_num = 0 ; break ; case SSL3_ST_SW_CERT_STATUS_A : case SSL3_ST_SW_CERT_STATUS_B : ret = ssl3_send_cert_status ( s ) ; if ( ret <= 0 ) goto end ; s -> state = SSL3_ST_SW_KEY_EXCH_A ; s -> init_num = 0 ; break ; # endif case SSL3_ST_SW_CHANGE_A : case SSL3_ST_SW_CHANGE_B : s -> session -> cipher = s -> s3 -> tmp . new_cipher ; if ( ! s -> method -> ssl3_enc -> setup_key_block ( s ) ) { ret = - 1 ; goto end ; } ret = ssl3_send_change_cipher_spec ( s , SSL3_ST_SW_CHANGE_A , SSL3_ST_SW_CHANGE_B ) ; if ( ret <= 0 ) goto end ; s -> state = SSL3_ST_SW_FINISHED_A ; s -> init_num = 0 ; if ( ! s -> method -> ssl3_enc -> change_cipher_state ( s , SSL3_CHANGE_CIPHER_SERVER_WRITE ) ) { ret = - 1 ; goto end ; } break ; case SSL3_ST_SW_FINISHED_A : case SSL3_ST_SW_FINISHED_B : ret = ssl3_send_finished ( s , SSL3_ST_SW_FINISHED_A , SSL3_ST_SW_FINISHED_B , s -> method -> ssl3_enc -> server_finished_label , s -> method -> ssl3_enc -> server_finished_label_len ) ; if ( ret <= 0 ) goto end ; s -> state = SSL3_ST_SW_FLUSH ; if ( s -> hit ) { # if defined ( OPENSSL_NO_TLSEXT ) || defined ( OPENSSL_NO_NEXTPROTONEG ) s -> s3 -> tmp . next_state = SSL3_ST_SR_FINISHED_A ; # else if ( s -> s3 -> next_proto_neg_seen ) { s -> s3 -> tmp . next_state = SSL3_ST_SR_NEXT_PROTO_A ; } else s -> s3 -> tmp . next_state = SSL3_ST_SR_FINISHED_A ; # endif } else s -> s3 -> tmp . next_state = SSL_ST_OK ; s -> init_num = 0 ; break ; case SSL_ST_OK : ssl3_cleanup_key_block ( s ) ; BUF_MEM_free ( s -> init_buf ) ; s -> init_buf = NULL ; ssl_free_wbio_buffer ( s ) ; s -> init_num = 0 ; if ( s -> renegotiate == 2 ) { s -> renegotiate = 0 ; s -> new_session = 0 ; ssl_update_cache ( s , SSL_SESS_CACHE_SERVER ) ; s -> ctx -> stats . sess_accept_good ++ ; s -> handshake_func = ssl3_accept ; if ( cb != NULL ) cb ( s , SSL_CB_HANDSHAKE_DONE , 1 ) ; } ret = 1 ; goto end ; default : SSLerr ( SSL_F_SSL3_ACCEPT , SSL_R_UNKNOWN_STATE ) ; ret = - 1 ; goto end ; } if ( ! s -> s3 -> tmp . reuse_message && ! skip ) { if ( s -> debug ) { if ( ( ret = BIO_flush ( s -> wbio ) ) <= 0 ) goto end ; } if ( ( cb != NULL ) && ( s -> state != state ) ) { new_state = s -> state ; s -> state = state ; cb ( s , SSL_CB_ACCEPT_LOOP , 1 ) ; s -> state = new_state ; } } skip = 0 ; } end : s -> in_handshake -- ; if ( cb != NULL ) cb ( s , SSL_CB_ACCEPT_EXIT , ret ) ; return ( ret ) ; }\n","target":"<S2SV_ModStart> -> algorithm_mkey ; <S2SV_ModEnd> s -> s3 <S2SV_ModStart> . use_rsa_tmp = 0 ; if ( <S2SV_ModEnd> # ifndef OPENSSL_NO_PSK\n","project_and_commit_id":"openssl@openssl/ce325c60c74b0fa784f5872404b722e120e5cab0","cve_id":"CVE-2015-0204","original_address":"https://github.com/openssl/openssl/commit/ce325c60c74b0fa784f5872404b722e120e5cab0","time":"2015-01-09T02:59Z"},
	{"Unnamed: 0":4628,"cwe_id":"CWE-200","source":"CWE-200 long tty_ioctl ( struct file * file , unsigned int cmd , unsigned long arg ) { struct tty_struct * tty = file_tty ( file ) ; struct tty_struct * real_tty ; void __user * p = ( void __user * ) arg ; int retval ; struct tty_ldisc * ld ; if ( tty_paranoia_check ( tty , file_inode ( file ) , \"tty_ioctl\" ) ) return - EINVAL ; real_tty = tty_pair_get_tty ( tty ) ; switch ( cmd ) { case TIOCSETD : case TIOCSBRK : case TIOCCBRK : case TCSBRK : case TCSBRKP : retval = tty_check_change ( tty ) ; if ( retval ) return retval ; if ( cmd != TIOCCBRK ) { tty_wait_until_sent ( tty , 0 ) ; if ( signal_pending ( current ) ) return - EINTR ; } break ; } switch ( cmd ) { case TIOCSTI : return tiocsti ( tty , p ) ; case TIOCGWINSZ : return tiocgwinsz ( real_tty , p ) ; case TIOCSWINSZ : return tiocswinsz ( real_tty , p ) ; case TIOCCONS : return real_tty != tty ? - EINVAL : tioccons ( file ) ; case FIONBIO : return fionbio ( file , p ) ; case TIOCEXCL : set_bit ( TTY_EXCLUSIVE , & tty -> flags ) ; return 0 ; case TIOCNXCL : clear_bit ( TTY_EXCLUSIVE , & tty -> flags ) ; return 0 ; case TIOCGEXCL : { int excl = test_bit ( TTY_EXCLUSIVE , & tty -> flags ) ; return put_user ( excl , ( int __user * ) p ) ; } case TIOCNOTTY : if ( current -> signal -> tty != tty ) return - ENOTTY ; no_tty ( ) ; return 0 ; case TIOCSCTTY : return tiocsctty ( real_tty , file , arg ) ; case TIOCGPGRP : return tiocgpgrp ( tty , real_tty , p ) ; case TIOCSPGRP : return tiocspgrp ( tty , real_tty , p ) ; case TIOCGSID : return tiocgsid ( tty , real_tty , p ) ; case TIOCGETD : <S2SV_StartBug> return put_user ( tty -> ldisc -> ops -> num , ( int __user * ) p ) ; <S2SV_EndBug> case TIOCSETD : return tiocsetd ( tty , p ) ; case TIOCVHANGUP : if ( ! capable ( CAP_SYS_ADMIN ) ) return - EPERM ; tty_vhangup ( tty ) ; return 0 ; case TIOCGDEV : { unsigned int ret = new_encode_dev ( tty_devnum ( real_tty ) ) ; return put_user ( ret , ( unsigned int __user * ) p ) ; } case TIOCSBRK : if ( tty -> ops -> break_ctl ) return tty -> ops -> break_ctl ( tty , - 1 ) ; return 0 ; case TIOCCBRK : if ( tty -> ops -> break_ctl ) return tty -> ops -> break_ctl ( tty , 0 ) ; return 0 ; case TCSBRK : if ( ! arg ) return send_break ( tty , 250 ) ; return 0 ; case TCSBRKP : return send_break ( tty , arg ? arg * 100 : 250 ) ; case TIOCMGET : return tty_tiocmget ( tty , p ) ; case TIOCMSET : case TIOCMBIC : case TIOCMBIS : return tty_tiocmset ( tty , cmd , p ) ; case TIOCGICOUNT : retval = tty_tiocgicount ( tty , p ) ; if ( retval != - EINVAL ) return retval ; break ; case TCFLSH : switch ( arg ) { case TCIFLUSH : case TCIOFLUSH : tty_buffer_flush ( tty , NULL ) ; break ; } break ; case TIOCSSERIAL : tty_warn_deprecated_flags ( p ) ; break ; } if ( tty -> ops -> ioctl ) { retval = tty -> ops -> ioctl ( tty , cmd , arg ) ; if ( retval != - ENOIOCTLCMD ) return retval ; } ld = tty_ldisc_ref_wait ( tty ) ; retval = - EINVAL ; if ( ld -> ops -> ioctl ) { retval = ld -> ops -> ioctl ( tty , file , cmd , arg ) ; if ( retval == - ENOIOCTLCMD ) retval = - ENOTTY ; } tty_ldisc_deref ( ld ) ; return retval ; }\n","target":"<S2SV_ModStart> TIOCGETD : return tiocgetd ( tty , <S2SV_ModEnd> p ) ;\n","project_and_commit_id":"torvalds@linux/5c17c861a357e9458001f021a7afa7aab9937439","cve_id":"CVE-2016-0723","original_address":"https://github.com/torvalds/linux/commit/5c17c861a357e9458001f021a7afa7aab9937439","time":"2016-02-08T03:59Z"},
	{"Unnamed: 0":5489,"cwe_id":"CWE-772","source":"CWE-772 generic_ret * delete_policy_2_svc ( dpol_arg * arg , struct svc_req * rqstp ) { static generic_ret ret ; char * prime_arg ; <S2SV_StartBug> gss_buffer_desc client_name , <S2SV_EndBug> service_name ; OM_uint32 minor_stat ; kadm5_server_handle_t handle ; const char * errmsg = NULL ; xdr_free ( xdr_generic_ret , & ret ) ; if ( ( ret . code = new_server_handle ( arg -> api_version , rqstp , & handle ) ) ) goto exit_func ; if ( ( ret . code = check_handle ( ( void * ) handle ) ) ) goto exit_func ; ret . api_version = handle -> api_version ; if ( setup_gss_names ( rqstp , & client_name , & service_name ) < 0 ) { ret . code = KADM5_FAILURE ; goto exit_func ; } prime_arg = arg -> name ; if ( CHANGEPW_SERVICE ( rqstp ) || ! kadm5int_acl_check ( handle -> context , rqst2name ( rqstp ) , ACL_DELETE , NULL , NULL ) ) { log_unauth ( \"kadm5_delete_policy\" , prime_arg , & client_name , & service_name , rqstp ) ; ret . code = KADM5_AUTH_DELETE ; } else { ret . code = kadm5_delete_policy ( ( void * ) handle , arg -> name ) ; if ( ret . code != 0 ) errmsg = krb5_get_error_message ( handle -> context , ret . code ) ; log_done ( \"kadm5_delete_policy\" , ( ( prime_arg == NULL ) ? \"(null)\" : prime_arg ) , errmsg , & client_name , & service_name , rqstp ) ; if ( errmsg != NULL ) krb5_free_error_message ( handle -> context , errmsg ) ; } <S2SV_StartBug> gss_release_buffer ( & minor_stat , & client_name ) ; <S2SV_EndBug> gss_release_buffer ( & minor_stat , & service_name ) ; exit_func : free_server_handle ( handle ) ; return & ret ; }\n","target":"<S2SV_ModStart> ; gss_buffer_desc client_name = GSS_C_EMPTY_BUFFER ; gss_buffer_desc service_name = GSS_C_EMPTY_BUFFER <S2SV_ModEnd> ; OM_uint32 minor_stat <S2SV_ModStart> ) ; } exit_func : gss_release_buffer ( & minor_stat , & client_name ) ; gss_release_buffer ( & minor_stat , & service_name ) ; <S2SV_ModEnd> free_server_handle ( handle\n","project_and_commit_id":"krb5@krb5/83ed75feba32e46f736fcce0d96a0445f29b96c2","cve_id":"CVE-2015-8631","original_address":"https://github.com/krb5/krb5/commit/83ed75feba32e46f736fcce0d96a0445f29b96c2","time":"2016-02-13T02:59Z"},
	{"Unnamed: 0":5615,"cwe_id":"CWE-415","source":"CWE-415 static int f_midi_set_alt ( struct usb_function * f , unsigned intf , unsigned alt ) { struct f_midi * midi = func_to_midi ( f ) ; unsigned i ; int err ; if ( intf != midi -> ms_id ) return 0 ; err = f_midi_start_ep ( midi , f , midi -> in_ep ) ; if ( err ) return err ; err = f_midi_start_ep ( midi , f , midi -> out_ep ) ; if ( err ) return err ; while ( kfifo_avail ( & midi -> in_req_fifo ) ) { struct usb_request * req = midi_alloc_ep_req ( midi -> in_ep , midi -> buflen ) ; if ( req == NULL ) return - ENOMEM ; req -> length = 0 ; req -> complete = f_midi_complete ; kfifo_put ( & midi -> in_req_fifo , req ) ; } for ( i = 0 ; i < midi -> qlen && err == 0 ; i ++ ) { struct usb_request * req = midi_alloc_ep_req ( midi -> out_ep , midi -> buflen ) ; if ( req == NULL ) return - ENOMEM ; req -> complete = f_midi_complete ; err = usb_ep_queue ( midi -> out_ep , req , GFP_ATOMIC ) ; if ( err ) { ERROR ( midi , \"%s:<S2SV_blank>couldn\\'t<S2SV_blank>enqueue<S2SV_blank>request:<S2SV_blank>%d\\\\n\" , midi -> out_ep -> name , err ) ; <S2SV_StartBug> free_ep_req ( midi -> out_ep , req ) ; <S2SV_EndBug> return err ; } } return 0 ; }\n","target":"<S2SV_ModStart> err ) ; if ( req -> buf != NULL )\n","project_and_commit_id":"torvalds@linux/7fafcfdf6377b18b2a726ea554d6e593ba44349f","cve_id":"CVE-2018-20961","original_address":"https://github.com/torvalds/linux/commit/7fafcfdf6377b18b2a726ea554d6e593ba44349f","time":"2019-08-07T15:15Z"},
	{"Unnamed: 0":4658,"cwe_id":"CWE-200","source":"CWE-200 int sbusfb_ioctl_helper ( unsigned long cmd , unsigned long arg , struct fb_info * info , int type , int fb_depth , unsigned long fb_size ) { switch ( cmd ) { case FBIOGTYPE : { struct fbtype __user * f = ( struct fbtype __user * ) arg ; if ( put_user ( type , & f -> fb_type ) || __put_user ( info -> var . yres , & f -> fb_height ) || __put_user ( info -> var . xres , & f -> fb_width ) || __put_user ( fb_depth , & f -> fb_depth ) || __put_user ( 0 , & f -> fb_cmsize ) || __put_user ( fb_size , & f -> fb_cmsize ) ) return - EFAULT ; return 0 ; } case FBIOPUTCMAP_SPARC : { struct fbcmap __user * c = ( struct fbcmap __user * ) arg ; struct fb_cmap cmap ; u16 red , green , blue ; u8 red8 , green8 , blue8 ; unsigned char __user * ured ; unsigned char __user * ugreen ; unsigned char __user * ublue ; <S2SV_StartBug> int index , count , i ; <S2SV_EndBug> if ( get_user ( index , & c -> index ) || __get_user ( count , & c -> count ) || __get_user ( ured , & c -> red ) || __get_user ( ugreen , & c -> green ) || __get_user ( ublue , & c -> blue ) ) return - EFAULT ; cmap . len = 1 ; cmap . red = & red ; cmap . green = & green ; cmap . blue = & blue ; cmap . transp = NULL ; for ( i = 0 ; i < count ; i ++ ) { int err ; if ( get_user ( red8 , & ured [ i ] ) || get_user ( green8 , & ugreen [ i ] ) || get_user ( blue8 , & ublue [ i ] ) ) return - EFAULT ; red = red8 << 8 ; green = green8 << 8 ; blue = blue8 << 8 ; cmap . start = index + i ; err = fb_set_cmap ( & cmap , info ) ; if ( err ) return err ; } return 0 ; } case FBIOGETCMAP_SPARC : { struct fbcmap __user * c = ( struct fbcmap __user * ) arg ; unsigned char __user * ured ; unsigned char __user * ugreen ; unsigned char __user * ublue ; struct fb_cmap * cmap = & info -> cmap ; <S2SV_StartBug> int index , count , i ; <S2SV_EndBug> u8 red , green , blue ; if ( get_user ( index , & c -> index ) || __get_user ( count , & c -> count ) || __get_user ( ured , & c -> red ) || __get_user ( ugreen , & c -> green ) || __get_user ( ublue , & c -> blue ) ) return - EFAULT ; if ( index + count > cmap -> len ) return - EINVAL ; for ( i = 0 ; i < count ; i ++ ) { red = cmap -> red [ index + i ] >> 8 ; green = cmap -> green [ index + i ] >> 8 ; blue = cmap -> blue [ index + i ] >> 8 ; if ( put_user ( red , & ured [ i ] ) || put_user ( green , & ugreen [ i ] ) || put_user ( blue , & ublue [ i ] ) ) return - EFAULT ; } return 0 ; } default : return - EINVAL ; } }\n","target":"<S2SV_ModStart> * ublue ; unsigned <S2SV_ModStart> -> cmap ; unsigned\n","project_and_commit_id":"torvalds@linux/250c6c49e3b68756b14983c076183568636e2bde","cve_id":"CVE-2018-6412","original_address":"https://github.com/torvalds/linux/commit/250c6c49e3b68756b14983c076183568636e2bde","time":"2018-01-31T07:29Z"},
	{"Unnamed: 0":2697,"cwe_id":"CWE-189","source":"CWE-189 static int check_cond_jmp_op ( struct bpf_verifier_env * env , struct bpf_insn * insn , int * insn_idx ) { struct bpf_verifier_state * this_branch = env -> cur_state ; struct bpf_verifier_state * other_branch ; struct bpf_reg_state * regs = this_branch -> frame [ this_branch -> curframe ] -> regs ; struct bpf_reg_state * dst_reg , * other_branch_regs ; u8 opcode = BPF_OP ( insn -> code ) ; int err ; if ( opcode > BPF_JSLE ) { verbose ( env , \"invalid<S2SV_blank>BPF_JMP<S2SV_blank>opcode<S2SV_blank>%x\\\\n\" , opcode ) ; return - EINVAL ; } if ( BPF_SRC ( insn -> code ) == BPF_X ) { if ( insn -> imm != 0 ) { verbose ( env , \"BPF_JMP<S2SV_blank>uses<S2SV_blank>reserved<S2SV_blank>fields\\\\n\" ) ; return - EINVAL ; } err = check_reg_arg ( env , insn -> src_reg , SRC_OP ) ; if ( err ) return err ; if ( is_pointer_value ( env , insn -> src_reg ) ) { verbose ( env , \"R%d<S2SV_blank>pointer<S2SV_blank>comparison<S2SV_blank>prohibited\\\\n\" , insn -> src_reg ) ; return - EACCES ; } } else { if ( insn -> src_reg != BPF_REG_0 ) { verbose ( env , \"BPF_JMP<S2SV_blank>uses<S2SV_blank>reserved<S2SV_blank>fields\\\\n\" ) ; return - EINVAL ; } } err = check_reg_arg ( env , insn -> dst_reg , SRC_OP ) ; if ( err ) return err ; dst_reg = & regs [ insn -> dst_reg ] ; if ( BPF_SRC ( insn -> code ) == BPF_K ) { int pred = is_branch_taken ( dst_reg , insn -> imm , opcode ) ; if ( pred == 1 ) { * insn_idx += insn -> off ; return 0 ; } else if ( pred == 0 ) { return 0 ; } } <S2SV_StartBug> other_branch = push_stack ( env , * insn_idx + insn -> off + 1 , * insn_idx ) ; <S2SV_EndBug> if ( ! other_branch ) return - EFAULT ; other_branch_regs = other_branch -> frame [ other_branch -> curframe ] -> regs ; if ( BPF_SRC ( insn -> code ) == BPF_X ) { if ( dst_reg -> type == SCALAR_VALUE && regs [ insn -> src_reg ] . type == SCALAR_VALUE ) { if ( tnum_is_const ( regs [ insn -> src_reg ] . var_off ) ) reg_set_min_max ( & other_branch_regs [ insn -> dst_reg ] , dst_reg , regs [ insn -> src_reg ] . var_off . value , opcode ) ; else if ( tnum_is_const ( dst_reg -> var_off ) ) reg_set_min_max_inv ( & other_branch_regs [ insn -> src_reg ] , & regs [ insn -> src_reg ] , dst_reg -> var_off . value , opcode ) ; else if ( opcode == BPF_JEQ || opcode == BPF_JNE ) reg_combine_min_max ( & other_branch_regs [ insn -> src_reg ] , & other_branch_regs [ insn -> dst_reg ] , & regs [ insn -> src_reg ] , & regs [ insn -> dst_reg ] , opcode ) ; } } else if ( dst_reg -> type == SCALAR_VALUE ) { reg_set_min_max ( & other_branch_regs [ insn -> dst_reg ] , dst_reg , insn -> imm , opcode ) ; } if ( BPF_SRC ( insn -> code ) == BPF_K && insn -> imm == 0 && ( opcode == BPF_JEQ || opcode == BPF_JNE ) && reg_type_may_be_null ( dst_reg -> type ) ) { mark_ptr_or_null_regs ( this_branch , insn -> dst_reg , opcode == BPF_JNE ) ; mark_ptr_or_null_regs ( other_branch , insn -> dst_reg , opcode == BPF_JEQ ) ; } else if ( ! try_match_pkt_pointers ( insn , dst_reg , & regs [ insn -> src_reg ] , this_branch , other_branch ) && is_pointer_value ( env , insn -> dst_reg ) ) { verbose ( env , \"R%d<S2SV_blank>pointer<S2SV_blank>comparison<S2SV_blank>prohibited\\\\n\" , insn -> dst_reg ) ; return - EACCES ; } if ( env -> log . level ) print_verifier_state ( env , this_branch -> frame [ this_branch -> curframe ] ) ; return 0 ; }\n","target":"<S2SV_ModStart> , * insn_idx , false\n","project_and_commit_id":"torvalds@linux/979d63d50c0c0f7bc537bf821e056cc9fe5abd38","cve_id":"CVE-2019-7308","original_address":"https://github.com/torvalds/linux/commit/979d63d50c0c0f7bc537bf821e056cc9fe5abd38","time":"2019-02-01T22:29Z"},
	{"Unnamed: 0":3440,"cwe_id":"CWE-264","source":"CWE-264 static int perf_event_read_group ( struct perf_event * event , u64 read_format , char __user * buf ) { struct perf_event * leader = event -> group_leader , * sub ; <S2SV_StartBug> int n = 0 , size = 0 , ret = - EFAULT ; <S2SV_EndBug> <S2SV_StartBug> struct perf_event_context * ctx = leader -> ctx ; <S2SV_EndBug> u64 values [ 5 ] ; u64 count , enabled , running ; mutex_lock ( & ctx -> mutex ) ; count = perf_event_read_value ( leader , & enabled , & running ) ; values [ n ++ ] = 1 + leader -> nr_siblings ; if ( read_format & PERF_FORMAT_TOTAL_TIME_ENABLED ) values [ n ++ ] = enabled ; if ( read_format & PERF_FORMAT_TOTAL_TIME_RUNNING ) values [ n ++ ] = running ; values [ n ++ ] = count ; if ( read_format & PERF_FORMAT_ID ) values [ n ++ ] = primary_event_id ( leader ) ; size = n * sizeof ( u64 ) ; if ( copy_to_user ( buf , values , size ) ) goto unlock ; ret = size ; list_for_each_entry ( sub , & leader -> sibling_list , group_entry ) { n = 0 ; values [ n ++ ] = perf_event_read_value ( sub , & enabled , & running ) ; if ( read_format & PERF_FORMAT_ID ) values [ n ++ ] = primary_event_id ( sub ) ; size = n * sizeof ( u64 ) ; if ( copy_to_user ( buf + ret , values , size ) ) { <S2SV_StartBug> ret = - EFAULT ; <S2SV_EndBug> <S2SV_StartBug> goto unlock ; <S2SV_EndBug> } ret += size ; } <S2SV_StartBug> unlock : <S2SV_EndBug> mutex_unlock ( & ctx -> mutex ) ; return ret ; }\n","target":"<S2SV_ModStart> * sub ; struct perf_event_context * ctx = leader -> ctx ; <S2SV_ModStart> 0 , ret ; u64 count , enabled , running ; u64 values [ 5 ] ; lockdep_assert_held ( & ctx -> mutex ) ; count = perf_event_read_value ( leader , & enabled , & running ) ; values [ n ++ ] = 1 + leader -> nr_siblings ; if ( read_format & PERF_FORMAT_TOTAL_TIME_ENABLED ) values [ n ++ ] = enabled ; if ( read_format & PERF_FORMAT_TOTAL_TIME_RUNNING ) values [ n ++ ] = running ; values [ n ++ ] = count ; if ( read_format & PERF_FORMAT_ID ) values [ n ++ ] = primary_event_id ( leader ) ; size = n * sizeof ( u64 ) ; if ( copy_to_user ( buf , values , size ) ) return <S2SV_ModEnd> - EFAULT ; <S2SV_ModStart> - EFAULT ; <S2SV_ModEnd> ret = size <S2SV_ModStart> ) ) { return <S2SV_ModEnd> - EFAULT ; <S2SV_ModStart> - EFAULT ; <S2SV_ModEnd> } ret += <S2SV_ModStart> size ; } <S2SV_ModEnd> return ret ;\n","project_and_commit_id":"torvalds@linux/f63a8daa5812afef4f06c962351687e1ff9ccb2b","cve_id":"CVE-2016-6787","original_address":"https://github.com/torvalds/linux/commit/f63a8daa5812afef4f06c962351687e1ff9ccb2b","time":"2016-12-28T07:59Z"},
	{"Unnamed: 0":2532,"cwe_id":"CWE-125","source":"CWE-125 stmt_ty AsyncFunctionDef ( identifier name , arguments_ty args , asdl_seq * body , asdl_seq <S2SV_StartBug> * decorator_list , expr_ty returns , int lineno , int col_offset , <S2SV_EndBug> int end_lineno , int end_col_offset , PyArena * arena ) { stmt_ty p ; if ( ! name ) { PyErr_SetString ( PyExc_ValueError , \"field<S2SV_blank>name<S2SV_blank>is<S2SV_blank>required<S2SV_blank>for<S2SV_blank>AsyncFunctionDef\" ) ; return NULL ; } if ( ! args ) { PyErr_SetString ( PyExc_ValueError , \"field<S2SV_blank>args<S2SV_blank>is<S2SV_blank>required<S2SV_blank>for<S2SV_blank>AsyncFunctionDef\" ) ; return NULL ; } p = ( stmt_ty ) PyArena_Malloc ( arena , sizeof ( * p ) ) ; if ( ! p ) return NULL ; p -> kind = AsyncFunctionDef_kind ; p -> v . AsyncFunctionDef . name = name ; p -> v . AsyncFunctionDef . args = args ; p -> v . AsyncFunctionDef . body = body ; p -> v . AsyncFunctionDef . decorator_list = decorator_list ; <S2SV_StartBug> p -> v . AsyncFunctionDef . returns = returns ; <S2SV_EndBug> p -> lineno = lineno ; p -> col_offset = col_offset ; p -> end_lineno = end_lineno ; p -> end_col_offset = end_col_offset ; return p ; }\n","target":"<S2SV_ModStart> expr_ty returns , string type_comment , int <S2SV_ModEnd> lineno , int <S2SV_ModStart> returns = returns ; p -> v . AsyncFunctionDef . type_comment = type_comment\n","project_and_commit_id":"python@typed_ast/dcfcd146f8e6fc5c2fc16a4c192a0c5f5ca8c53c","cve_id":"CVE-2019-19275","original_address":"https://github.com/python/typed_ast/commit/dcfcd146f8e6fc5c2fc16a4c192a0c5f5ca8c53c","time":"2019-11-26T15:15Z"},
	{"Unnamed: 0":5016,"cwe_id":"CWE-119","source":"CWE-119 <S2SV_StartBug> static vpx_codec_err_t vp8_set_reference ( vpx_codec_alg_priv_t * ctx , <S2SV_EndBug> int ctr_id , va_list args ) { vpx_ref_frame_t * data = va_arg ( args , vpx_ref_frame_t * ) ; if ( data && ! ctx -> yv12_frame_buffers . use_frame_threads ) { vpx_ref_frame_t * frame = ( vpx_ref_frame_t * ) data ; YV12_BUFFER_CONFIG sd ; image2yuvconfig ( & frame -> img , & sd ) ; return vp8dx_set_reference ( ctx -> yv12_frame_buffers . pbi [ 0 ] , frame -> frame_type , & sd ) ; } else return VPX_CODEC_INVALID_PARAM ; }\n","target":"<S2SV_ModStart> vpx_codec_alg_priv_t * ctx <S2SV_ModEnd> , va_list args\n","project_and_commit_id":"external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426","cve_id":"CVE-2016-1621","original_address":"https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426","time":"2016-03-12T21:59Z"},
	{"Unnamed: 0":5649,"cwe_id":"CWE-119","source":"CWE-119 static int filter_frame ( AVFilterLink * inlink , AVFrame * inpic ) { KerndeintContext * kerndeint = inlink -> dst -> priv ; AVFilterLink * outlink = inlink -> dst -> outputs [ 0 ] ; AVFrame * outpic ; const uint8_t * prvp ; const uint8_t * prvpp ; const uint8_t * prvpn ; const uint8_t * prvppp ; const uint8_t * prvpnn ; const uint8_t * prvp4p ; const uint8_t * prvp4n ; const uint8_t * srcp ; const uint8_t * srcpp ; const uint8_t * srcpn ; const uint8_t * srcppp ; const uint8_t * srcpnn ; const uint8_t * srcp3p ; const uint8_t * srcp3n ; const uint8_t * srcp4p ; const uint8_t * srcp4n ; uint8_t * dstp , * dstp_saved ; const uint8_t * srcp_saved ; int src_linesize , psrc_linesize , dst_linesize , bwidth ; int x , y , plane , val , hi , lo , g , h , n = kerndeint -> frame ++ ; double valf ; const int thresh = kerndeint -> thresh ; const int order = kerndeint -> order ; const int map = kerndeint -> map ; const int sharp = kerndeint -> sharp ; const int twoway = kerndeint -> twoway ; const int is_packed_rgb = kerndeint -> is_packed_rgb ; outpic = ff_get_video_buffer ( outlink , outlink -> w , outlink -> h ) ; if ( ! outpic ) { av_frame_free ( & inpic ) ; return AVERROR ( ENOMEM ) ; } av_frame_copy_props ( outpic , inpic ) ; outpic -> interlaced_frame = 0 ; <S2SV_StartBug> for ( plane = 0 ; inpic -> data [ plane ] && plane < 4 ; plane ++ ) { <S2SV_EndBug> h = plane == 0 ? inlink -> h : FF_CEIL_RSHIFT ( inlink -> h , kerndeint -> vsub ) ; bwidth = kerndeint -> tmp_bwidth [ plane ] ; srcp = srcp_saved = inpic -> data [ plane ] ; src_linesize = inpic -> linesize [ plane ] ; psrc_linesize = kerndeint -> tmp_linesize [ plane ] ; dstp = dstp_saved = outpic -> data [ plane ] ; dst_linesize = outpic -> linesize [ plane ] ; srcp = srcp_saved + ( 1 - order ) * src_linesize ; dstp = dstp_saved + ( 1 - order ) * dst_linesize ; for ( y = 0 ; y < h ; y += 2 ) { memcpy ( dstp , srcp , bwidth ) ; srcp += 2 * src_linesize ; dstp += 2 * dst_linesize ; } memcpy ( dstp_saved + order * dst_linesize , srcp_saved + ( 1 - order ) * src_linesize , bwidth ) ; memcpy ( dstp_saved + ( 2 + order ) * dst_linesize , srcp_saved + ( 3 - order ) * src_linesize , bwidth ) ; memcpy ( dstp_saved + ( h - 2 + order ) * dst_linesize , srcp_saved + ( h - 1 - order ) * src_linesize , bwidth ) ; memcpy ( dstp_saved + ( h - 4 + order ) * dst_linesize , srcp_saved + ( h - 3 - order ) * src_linesize , bwidth ) ; prvp = kerndeint -> tmp_data [ plane ] + 5 * psrc_linesize - ( 1 - order ) * psrc_linesize ; prvpp = prvp - psrc_linesize ; prvppp = prvp - 2 * psrc_linesize ; prvp4p = prvp - 4 * psrc_linesize ; prvpn = prvp + psrc_linesize ; prvpnn = prvp + 2 * psrc_linesize ; prvp4n = prvp + 4 * psrc_linesize ; srcp = srcp_saved + 5 * src_linesize - ( 1 - order ) * src_linesize ; srcpp = srcp - src_linesize ; srcppp = srcp - 2 * src_linesize ; srcp3p = srcp - 3 * src_linesize ; srcp4p = srcp - 4 * src_linesize ; srcpn = srcp + src_linesize ; srcpnn = srcp + 2 * src_linesize ; srcp3n = srcp + 3 * src_linesize ; srcp4n = srcp + 4 * src_linesize ; dstp = dstp_saved + 5 * dst_linesize - ( 1 - order ) * dst_linesize ; for ( y = 5 - ( 1 - order ) ; y <= h - 5 - ( 1 - order ) ; y += 2 ) { for ( x = 0 ; x < bwidth ; x ++ ) { if ( thresh == 0 || n == 0 || ( abs ( ( int ) prvp [ x ] - ( int ) srcp [ x ] ) > thresh ) || ( abs ( ( int ) prvpp [ x ] - ( int ) srcpp [ x ] ) > thresh ) || ( abs ( ( int ) prvpn [ x ] - ( int ) srcpn [ x ] ) > thresh ) ) { if ( map ) { g = x & ~ 3 ; if ( is_packed_rgb ) { AV_WB32 ( dstp + g , 0xffffffff ) ; x = g + 3 ; } else if ( inlink -> format == AV_PIX_FMT_YUYV422 ) { AV_WB32 ( dstp + g , 0xeb80eb80 ) ; x = g + 3 ; } else { dstp [ x ] = plane == 0 ? 235 : 128 ; } } else { if ( is_packed_rgb ) { hi = 255 ; lo = 0 ; } else if ( inlink -> format == AV_PIX_FMT_YUYV422 ) { hi = x & 1 ? 240 : 235 ; lo = 16 ; } else { hi = plane == 0 ? 235 : 240 ; lo = 16 ; } if ( sharp ) { if ( twoway ) { valf = + 0.526 * ( ( int ) srcpp [ x ] + ( int ) srcpn [ x ] ) + 0.170 * ( ( int ) srcp [ x ] + ( int ) prvp [ x ] ) - 0.116 * ( ( int ) srcppp [ x ] + ( int ) srcpnn [ x ] + ( int ) prvppp [ x ] + ( int ) prvpnn [ x ] ) - 0.026 * ( ( int ) srcp3p [ x ] + ( int ) srcp3n [ x ] ) + 0.031 * ( ( int ) srcp4p [ x ] + ( int ) srcp4n [ x ] + ( int ) prvp4p [ x ] + ( int ) prvp4n [ x ] ) ; } else { valf = + 0.526 * ( ( int ) srcpp [ x ] + ( int ) srcpn [ x ] ) + 0.170 * ( ( int ) prvp [ x ] ) - 0.116 * ( ( int ) prvppp [ x ] + ( int ) prvpnn [ x ] ) - 0.026 * ( ( int ) srcp3p [ x ] + ( int ) srcp3n [ x ] ) + 0.031 * ( ( int ) prvp4p [ x ] + ( int ) prvp4p [ x ] ) ; } dstp [ x ] = av_clip ( valf , lo , hi ) ; } else { if ( twoway ) { val = ( 8 * ( ( int ) srcpp [ x ] + ( int ) srcpn [ x ] ) + 2 * ( ( int ) srcp [ x ] + ( int ) prvp [ x ] ) - ( int ) ( srcppp [ x ] ) - ( int ) ( srcpnn [ x ] ) - ( int ) ( prvppp [ x ] ) - ( int ) ( prvpnn [ x ] ) ) >> 4 ; } else { val = ( 8 * ( ( int ) srcpp [ x ] + ( int ) srcpn [ x ] ) + 2 * ( ( int ) prvp [ x ] ) - ( int ) ( prvppp [ x ] ) - ( int ) ( prvpnn [ x ] ) ) >> 4 ; } dstp [ x ] = av_clip ( val , lo , hi ) ; } } } else { dstp [ x ] = srcp [ x ] ; } } prvp += 2 * psrc_linesize ; prvpp += 2 * psrc_linesize ; prvppp += 2 * psrc_linesize ; prvpn += 2 * psrc_linesize ; prvpnn += 2 * psrc_linesize ; prvp4p += 2 * psrc_linesize ; prvp4n += 2 * psrc_linesize ; srcp += 2 * src_linesize ; srcpp += 2 * src_linesize ; srcppp += 2 * src_linesize ; srcp3p += 2 * src_linesize ; srcp4p += 2 * src_linesize ; srcpn += 2 * src_linesize ; srcpnn += 2 * src_linesize ; srcp3n += 2 * src_linesize ; srcp4n += 2 * src_linesize ; dstp += 2 * dst_linesize ; } srcp = inpic -> data [ plane ] ; dstp = kerndeint -> tmp_data [ plane ] ; av_image_copy_plane ( dstp , psrc_linesize , srcp , src_linesize , bwidth , h ) ; } av_frame_free ( & inpic ) ; return ff_filter_frame ( outlink , outpic ) ; }\n","target":"<S2SV_ModStart> = 0 ; <S2SV_ModEnd> plane < 4 <S2SV_ModStart> plane < 4 && inpic -> data [ plane ] && inpic -> linesize [ plane ]\n","project_and_commit_id":"FFmpeg@FFmpeg/e43a0a232dbf6d3c161823c2e07c52e76227a1bc","cve_id":"CVE-2013-4263","original_address":"https://github.com/FFmpeg/FFmpeg/commit/e43a0a232dbf6d3c161823c2e07c52e76227a1bc","time":"2013-11-23T17:55Z"},
	{"Unnamed: 0":2810,"cwe_id":"CWE-119","source":"CWE-119 int vpx_img_set_rect ( vpx_image_t * img , unsigned int x , unsigned int y , unsigned int w , unsigned int h ) { unsigned char * data ; if ( x + w <= img -> w && y + h <= img -> h ) { img -> d_w = w ; img -> d_h = h ; if ( ! ( img -> fmt & VPX_IMG_FMT_PLANAR ) ) { img -> planes [ VPX_PLANE_PACKED ] = img -> img_data + x * img -> bps / 8 + y * img -> stride [ VPX_PLANE_PACKED ] ; } else { <S2SV_StartBug> data = img -> img_data ; <S2SV_EndBug> if ( img -> fmt & VPX_IMG_FMT_HAS_ALPHA ) { img -> planes [ VPX_PLANE_ALPHA ] = <S2SV_StartBug> data + x + y * img -> stride [ VPX_PLANE_ALPHA ] ; <S2SV_EndBug> data += img -> h * img -> stride [ VPX_PLANE_ALPHA ] ; } <S2SV_StartBug> img -> planes [ VPX_PLANE_Y ] = data + x + y * img -> stride [ VPX_PLANE_Y ] ; <S2SV_EndBug> data += img -> h * img -> stride [ VPX_PLANE_Y ] ; if ( ! ( img -> fmt & VPX_IMG_FMT_UV_FLIP ) ) { <S2SV_StartBug> img -> planes [ VPX_PLANE_U ] = data <S2SV_EndBug> + ( x >> img -> x_chroma_shift ) <S2SV_StartBug> + ( y >> img -> y_chroma_shift ) * img -> stride [ VPX_PLANE_U ] ; <S2SV_EndBug> data += ( img -> h >> img -> y_chroma_shift ) * img -> stride [ VPX_PLANE_U ] ; <S2SV_StartBug> img -> planes [ VPX_PLANE_V ] = data <S2SV_EndBug> + ( x >> img -> x_chroma_shift ) <S2SV_StartBug> + ( y >> img -> y_chroma_shift ) * img -> stride [ VPX_PLANE_V ] ; <S2SV_EndBug> } else { <S2SV_StartBug> img -> planes [ VPX_PLANE_V ] = data <S2SV_EndBug> + ( x >> img -> x_chroma_shift ) <S2SV_StartBug> + ( y >> img -> y_chroma_shift ) * img -> stride [ VPX_PLANE_V ] ; <S2SV_EndBug> data += ( img -> h >> img -> y_chroma_shift ) * img -> stride [ VPX_PLANE_V ] ; <S2SV_StartBug> img -> planes [ VPX_PLANE_U ] = data <S2SV_EndBug> + ( x >> img -> x_chroma_shift ) <S2SV_StartBug> + ( y >> img -> y_chroma_shift ) * img -> stride [ VPX_PLANE_U ] ; <S2SV_EndBug> } } return 0 ; } return - 1 ; }\n","target":"<S2SV_ModStart> } else { const int bytes_per_sample = ( img -> fmt & VPX_IMG_FMT_HIGHBITDEPTH ) ? 2 : 1 ; <S2SV_ModStart> data + x * bytes_per_sample <S2SV_ModStart> data + x * bytes_per_sample + <S2SV_ModEnd> y * img <S2SV_ModStart> VPX_PLANE_U ] = data <S2SV_ModEnd> + ( x <S2SV_ModStart> -> x_chroma_shift ) * bytes_per_sample + <S2SV_ModEnd> ( y >> <S2SV_ModStart> VPX_PLANE_V ] = data <S2SV_ModEnd> + ( x <S2SV_ModStart> -> x_chroma_shift ) * bytes_per_sample + <S2SV_ModEnd> ( y >> <S2SV_ModStart> VPX_PLANE_V ] = data <S2SV_ModEnd> + ( x <S2SV_ModStart> -> x_chroma_shift ) * bytes_per_sample + <S2SV_ModEnd> ( y >> <S2SV_ModStart> VPX_PLANE_U ] = data <S2SV_ModEnd> + ( x <S2SV_ModStart> -> x_chroma_shift ) * bytes_per_sample + <S2SV_ModEnd> ( y >>\n","project_and_commit_id":"external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426","cve_id":"CVE-2016-1621","original_address":"https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426","time":"2016-03-12T21:59Z"},
	{"Unnamed: 0":5249,"cwe_id":"CWE-119","source":"CWE-119 int copy_creds ( struct task_struct * p , unsigned long clone_flags ) { # ifdef CONFIG_KEYS struct thread_group_cred * tgcred ; # endif struct cred * new ; int ret ; <S2SV_StartBug> if ( <S2SV_EndBug> # ifdef CONFIG_KEYS ! p -> cred -> thread_keyring && # endif clone_flags & CLONE_THREAD ) { p -> real_cred = get_cred ( p -> cred ) ; get_cred ( p -> cred ) ; alter_cred_subscribers ( p -> cred , 2 ) ; kdebug ( \"share_creds(%p{%d,%d})\" , p -> cred , atomic_read ( & p -> cred -> usage ) , read_cred_subscribers ( p -> cred ) ) ; atomic_inc ( & p -> cred -> user -> processes ) ; return 0 ; } new = prepare_creds ( ) ; if ( ! new ) return - ENOMEM ; if ( clone_flags & CLONE_NEWUSER ) { ret = create_user_ns ( new ) ; if ( ret < 0 ) goto error_put ; } new -> user_ns = new -> user -> user_ns ; # ifdef CONFIG_KEYS if ( new -> thread_keyring ) { key_put ( new -> thread_keyring ) ; new -> thread_keyring = NULL ; if ( clone_flags & CLONE_THREAD ) install_thread_keyring_to_cred ( new ) ; } if ( ! ( clone_flags & CLONE_THREAD ) ) { tgcred = kmalloc ( sizeof ( * tgcred ) , GFP_KERNEL ) ; if ( ! tgcred ) { ret = - ENOMEM ; goto error_put ; } atomic_set ( & tgcred -> usage , 1 ) ; spin_lock_init ( & tgcred -> lock ) ; tgcred -> process_keyring = NULL ; tgcred -> session_keyring = key_get ( new -> tgcred -> session_keyring ) ; release_tgcred ( new ) ; new -> tgcred = tgcred ; } # endif atomic_inc ( & new -> user -> processes ) ; p -> cred = p -> real_cred = get_cred ( new ) ; alter_cred_subscribers ( new , 2 ) ; validate_creds ( new ) ; return 0 ; error_put : put_cred ( new ) ; return ret ; }\n","target":"<S2SV_ModStart> int ret ; p -> replacement_session_keyring = NULL ;\n","project_and_commit_id":"torvalds@linux/79549c6dfda0603dba9a70a53467ce62d9335c33","cve_id":"CVE-2012-2745","original_address":"https://github.com/torvalds/linux/commit/79549c6dfda0603dba9a70a53467ce62d9335c33","time":"2012-08-09T10:29Z"},
	{"Unnamed: 0":4598,"cwe_id":"CWE-119","source":"CWE-119 ssize_t cdf_read_short_sector ( const cdf_stream_t * sst , void * buf , size_t offs , size_t len , const cdf_header_t * h , cdf_secid_t id ) { size_t ss = CDF_SHORT_SEC_SIZE ( h ) ; size_t pos = CDF_SHORT_SEC_POS ( h , id ) ; assert ( ss == len ) ; <S2SV_StartBug> if ( pos > CDF_SEC_SIZE ( h ) * sst -> sst_len ) { <S2SV_EndBug> DPRINTF ( ( \"Out<S2SV_blank>of<S2SV_blank>bounds<S2SV_blank>read<S2SV_blank>%\" SIZE_T_FORMAT \"u<S2SV_blank>><S2SV_blank>%\" SIZE_T_FORMAT \"u\\\\n\" , <S2SV_StartBug> pos , CDF_SEC_SIZE ( h ) * sst -> sst_len ) ) ; <S2SV_EndBug> return - 1 ; } ( void ) memcpy ( ( ( char * ) buf ) + offs , ( ( const char * ) sst -> sst_tab ) + pos , len ) ; return len ; }\n","target":"<S2SV_ModStart> if ( pos + len <S2SV_ModStart> \"u\\\\n\" , pos + len\n","project_and_commit_id":"file@file/6d209c1c489457397a5763bca4b28e43aac90391","cve_id":"CVE-2014-0207","original_address":"https://github.com/file/file/commit/6d209c1c489457397a5763bca4b28e43aac90391","time":"2014-07-09T11:07Z"},
	{"Unnamed: 0":4434,"cwe_id":"CWE-189","source":"CWE-189 Image * AutoResizeImage ( const Image * image , const char * option , MagickOffsetType * count , ExceptionInfo * exception ) { # define MAX_SIZES 16 char * q ; const char * p ; Image * resized , * images ; register ssize_t i ; size_t sizes [ MAX_SIZES ] = { 256 , 192 , 128 , 96 , 64 , 48 , 40 , 32 , 24 , 16 } ; images = NULL ; * count = 0 ; i = 0 ; p = option ; while ( * p != '\\\\0' && i < MAX_SIZES ) { size_t size ; while ( ( isspace ( ( int ) ( ( unsigned char ) * p ) ) != 0 ) ) p ++ ; size = ( size_t ) strtol ( p , & q , 10 ) ; <S2SV_StartBug> if ( p == q || size < 16 || size > 256 ) <S2SV_EndBug> return ( ( Image * ) NULL ) ; p = q ; sizes [ i ++ ] = size ; while ( ( isspace ( ( int ) ( ( unsigned char ) * p ) ) != 0 ) || ( * p == ',' ) ) p ++ ; } if ( i == 0 ) i = 10 ; * count = i ; for ( i = 0 ; i < * count ; i ++ ) { resized = ResizeImage ( image , sizes [ i ] , sizes [ i ] , image -> filter , exception ) ; if ( resized == ( Image * ) NULL ) return ( DestroyImageList ( images ) ) ; if ( images == ( Image * ) NULL ) images = resized ; else AppendImageToList ( & images , resized ) ; } return ( images ) ; }\n","target":"<S2SV_ModStart> ; if ( ( <S2SV_ModStart> p == q ) || ( <S2SV_ModEnd> size < 16 <S2SV_ModStart> size < 16 ) || ( <S2SV_ModEnd> size > 256 <S2SV_ModStart> size > 256 )\n","project_and_commit_id":"ImageMagick@ImageMagick/0f6fc2d5bf8f500820c3dbcf0d23ee14f2d9f734","cve_id":"CVE-2015-8896","original_address":"https://github.com/ImageMagick/ImageMagick/commit/0f6fc2d5bf8f500820c3dbcf0d23ee14f2d9f734","time":"2017-03-15T19:59Z"},
	{"Unnamed: 0":2671,"cwe_id":"CWE-401","source":"CWE-401 static int crypto_report ( struct sk_buff * in_skb , struct nlmsghdr * in_nlh , struct nlattr * * attrs ) { struct net * net = sock_net ( in_skb -> sk ) ; struct crypto_user_alg * p = nlmsg_data ( in_nlh ) ; struct crypto_alg * alg ; struct sk_buff * skb ; struct crypto_dump_info info ; int err ; if ( ! null_terminated ( p -> cru_name ) || ! null_terminated ( p -> cru_driver_name ) ) return - EINVAL ; alg = crypto_alg_match ( p , 0 ) ; if ( ! alg ) return - ENOENT ; err = - ENOMEM ; skb = nlmsg_new ( NLMSG_DEFAULT_SIZE , GFP_KERNEL ) ; if ( ! skb ) goto drop_alg ; info . in_skb = in_skb ; info . out_skb = skb ; info . nlmsg_seq = in_nlh -> nlmsg_seq ; info . nlmsg_flags = 0 ; err = crypto_report_alg ( alg , & info ) ; drop_alg : crypto_mod_put ( alg ) ; if ( err ) <S2SV_StartBug> return err ; <S2SV_EndBug> return nlmsg_unicast ( net -> crypto_nlsk , skb , NETLINK_CB ( in_skb ) . portid ) ; }\n","target":"<S2SV_ModStart> ( err ) { kfree_skb ( skb ) ; return err ; } <S2SV_ModEnd> return nlmsg_unicast (\n","project_and_commit_id":"torvalds@linux/ffdde5932042600c6807d46c1550b28b0db6a3bc","cve_id":"CVE-2019-19062","original_address":"https://github.com/torvalds/linux/commit/ffdde5932042600c6807d46c1550b28b0db6a3bc","time":"2019-11-18T06:15Z"},
	{"Unnamed: 0":562,"cwe_id":"CWE-415","source":"CWE-415 static int sctp_wait_for_sndbuf ( struct sctp_association * asoc , long * timeo_p , size_t msg_len ) { struct sock * sk = asoc -> base . sk ; int err = 0 ; long current_timeo = * timeo_p ; DEFINE_WAIT ( wait ) ; pr_debug ( \"%s:<S2SV_blank>asoc:%p,<S2SV_blank>timeo:%ld,<S2SV_blank>msg_len:%zu\\\\n\" , __func__ , asoc , * timeo_p , msg_len ) ; sctp_association_hold ( asoc ) ; for ( ; ; ) { prepare_to_wait_exclusive ( & asoc -> wait , & wait , TASK_INTERRUPTIBLE ) ; if ( ! * timeo_p ) goto do_nonblock ; if ( sk -> sk_err || asoc -> state >= SCTP_STATE_SHUTDOWN_PENDING || asoc -> base . dead ) goto do_error ; if ( signal_pending ( current ) ) goto do_interrupted ; if ( msg_len <= sctp_wspace ( asoc ) ) break ; release_sock ( sk ) ; current_timeo = schedule_timeout ( current_timeo ) ; <S2SV_StartBug> if ( sk != asoc -> base . sk ) <S2SV_EndBug> goto do_error ; lock_sock ( sk ) ; * timeo_p = current_timeo ; } out : finish_wait ( & asoc -> wait , & wait ) ; sctp_association_put ( asoc ) ; return err ; do_error : err = - EPIPE ; goto out ; do_interrupted : err = sock_intr_errno ( * timeo_p ) ; goto out ; do_nonblock : err = - EAGAIN ; goto out ; }\n","target":"<S2SV_ModStart> current_timeo ) ; <S2SV_ModEnd> lock_sock ( sk\n","project_and_commit_id":"torvalds@linux/dfcb9f4f99f1e9a49e43398a7bfbf56927544af1","cve_id":"CVE-2017-6353","original_address":"https://github.com/torvalds/linux/commit/dfcb9f4f99f1e9a49e43398a7bfbf56927544af1","time":"2017-03-01T20:59Z"},
	{"Unnamed: 0":1403,"cwe_id":"CWE-119","source":"CWE-119 static __u8 * nci_extract_rf_params_nfcf_passive_poll ( struct nci_dev * ndev , struct rf_tech_specific_params_nfcf_poll * nfcf_poll , __u8 * data ) { nfcf_poll -> bit_rate = * data ++ ; <S2SV_StartBug> nfcf_poll -> sensf_res_len = * data ++ ; <S2SV_EndBug> pr_debug ( \"bit_rate<S2SV_blank>%d,<S2SV_blank>sensf_res_len<S2SV_blank>%d\\\\n\" , nfcf_poll -> bit_rate , nfcf_poll -> sensf_res_len ) ; memcpy ( nfcf_poll -> sensf_res , data , nfcf_poll -> sensf_res_len ) ; data += nfcf_poll -> sensf_res_len ; return data ; }\n","target":"<S2SV_ModStart> -> sensf_res_len = min_t ( __u8 , <S2SV_ModStart> * data ++ , NFC_SENSF_RES_MAXSIZE )\n","project_and_commit_id":"torvalds@linux/67de956ff5dc1d4f321e16cfbd63f5be3b691b43","cve_id":"CVE-2012-3364","original_address":"https://github.com/torvalds/linux/commit/67de956ff5dc1d4f321e16cfbd63f5be3b691b43","time":"2013-01-22T23:55Z"},
	{"Unnamed: 0":5686,"cwe_id":"CWE-125","source":"CWE-125 static void hid_input_field ( struct hid_device * hid , struct hid_field * field , __u8 * data , int interrupt ) { unsigned n ; unsigned count = field -> report_count ; unsigned offset = field -> report_offset ; unsigned size = field -> report_size ; __s32 min = field -> logical_minimum ; __s32 max = field -> logical_maximum ; __s32 * value ; value = kmalloc ( sizeof ( __s32 ) * count , GFP_ATOMIC ) ; if ( ! value ) return ; for ( n = 0 ; n < count ; n ++ ) { value [ n ] = min < 0 ? snto32 ( hid_field_extract ( hid , data , offset + n * size , size ) , size ) : hid_field_extract ( hid , data , offset + n * size , size ) ; if ( ! ( field -> flags & HID_MAIN_ITEM_VARIABLE ) && <S2SV_StartBug> value [ n ] >= min && value [ n ] <= max && <S2SV_EndBug> field -> usage [ value [ n ] - min ] . hid == HID_UP_KEYBOARD + 1 ) goto exit ; } for ( n = 0 ; n < count ; n ++ ) { if ( HID_MAIN_ITEM_VARIABLE & field -> flags ) { hid_process_event ( hid , field , & field -> usage [ n ] , value [ n ] , interrupt ) ; continue ; } if ( field -> value [ n ] >= min && field -> value [ n ] <= max <S2SV_StartBug> && field -> usage [ field -> value [ n ] - min ] . hid <S2SV_EndBug> && search ( value , field -> value [ n ] , count ) ) hid_process_event ( hid , field , & field -> usage [ field -> value [ n ] - min ] , 0 , interrupt ) ; if ( value [ n ] >= min && value [ n ] <= max <S2SV_StartBug> && field -> usage [ value [ n ] - min ] . hid <S2SV_EndBug> && search ( field -> value , value [ n ] , count ) ) hid_process_event ( hid , field , & field -> usage [ value [ n ] - min ] , 1 , interrupt ) ; } memcpy ( field -> value , value , count * sizeof ( __s32 ) ) ; exit : kfree ( value ) ; }\n","target":"<S2SV_ModStart> ] <= max && value [ n ] - min < field -> maxusage <S2SV_ModStart> && field -> value [ n ] - min < field -> maxusage && field -> <S2SV_ModStart> <= max && value [ n ] - min < field -> maxusage &&\n","project_and_commit_id":"torvalds@linux/50220dead1650609206efe91f0cc116132d59b3f","cve_id":"CVE-2016-7915","original_address":"https://github.com/torvalds/linux/commit/50220dead1650609206efe91f0cc116132d59b3f","time":"2016-11-16T05:59Z"},
	{"Unnamed: 0":3972,"cwe_id":"CWE-000","source":"CWE-000 static struct sock * unix_create1 ( struct net * net , struct socket * sock , int kern ) { struct sock * sk = NULL ; struct unix_sock * u ; atomic_long_inc ( & unix_nr_socks ) ; if ( atomic_long_read ( & unix_nr_socks ) > 2 * get_max_files ( ) ) goto out ; sk = sk_alloc ( net , PF_UNIX , GFP_KERNEL , & unix_proto , kern ) ; if ( ! sk ) goto out ; sock_init_data ( sock , sk ) ; lockdep_set_class ( & sk -> sk_receive_queue . lock , & af_unix_sk_receive_queue_lock_key ) ; sk -> sk_write_space = unix_write_space ; sk -> sk_max_ack_backlog = net -> unx . sysctl_max_dgram_qlen ; sk -> sk_destruct = unix_sock_destructor ; u = unix_sk ( sk ) ; u -> path . dentry = NULL ; u -> path . mnt = NULL ; spin_lock_init ( & u -> lock ) ; atomic_long_set ( & u -> inflight , 0 ) ; INIT_LIST_HEAD ( & u -> link ) ; mutex_init ( & u -> readlock ) ; init_waitqueue_head ( & u -> peer_wait ) ; <S2SV_StartBug> unix_insert_socket ( unix_sockets_unbound ( sk ) , sk ) ; <S2SV_EndBug> out : if ( sk == NULL ) atomic_long_dec ( & unix_nr_socks ) ; else { local_bh_disable ( ) ; sock_prot_inuse_add ( sock_net ( sk ) , sk -> sk_prot , 1 ) ; local_bh_enable ( ) ; } return sk ; }\n","target":"<S2SV_ModStart> peer_wait ) ; init_waitqueue_func_entry ( & u -> peer_wake , unix_dgram_peer_wake_relay ) ;\n","project_and_commit_id":"torvalds@linux/7d267278a9ece963d77eefec61630223fce08c6c","cve_id":"CVE-2013-7446","original_address":"https://github.com/torvalds/linux/commit/7d267278a9ece963d77eefec61630223fce08c6c","time":"2015-12-28T11:59Z"},
	{"Unnamed: 0":1744,"cwe_id":"CWE-400","source":"CWE-400 static void commit_tree ( struct mount * mnt , struct mount * shadows ) { struct mount * parent = mnt -> mnt_parent ; struct mount * m ; LIST_HEAD ( head ) ; struct mnt_namespace * n = parent -> mnt_ns ; BUG_ON ( parent == mnt ) ; list_add_tail ( & head , & mnt -> mnt_list ) ; list_for_each_entry ( m , & head , mnt_list ) m -> mnt_ns = n ; list_splice ( & head , n -> list . prev ) ; <S2SV_StartBug> attach_shadowed ( mnt , parent , shadows ) ; <S2SV_EndBug> touch_mnt_namespace ( n ) ; }\n","target":"<S2SV_ModStart> prev ) ; n -> mounts += n -> pending_mounts ; n -> pending_mounts = 0 ;\n","project_and_commit_id":"torvalds@linux/d29216842a85c7970c536108e093963f02714498","cve_id":"CVE-2016-6213","original_address":"https://github.com/torvalds/linux/commit/d29216842a85c7970c536108e093963f02714498","time":"2016-12-28T07:59Z"},
	{"Unnamed: 0":1929,"cwe_id":"CWE-20","source":"CWE-20 WORD32 ih264d_parse_decode_slice ( UWORD8 u1_is_idr_slice , UWORD8 u1_nal_ref_idc , dec_struct_t * ps_dec ) { dec_bit_stream_t * ps_bitstrm = ps_dec -> ps_bitstrm ; dec_pic_params_t * ps_pps ; dec_seq_params_t * ps_seq ; dec_slice_params_t * ps_cur_slice = ps_dec -> ps_cur_slice ; pocstruct_t s_tmp_poc ; WORD32 i_delta_poc [ 2 ] ; WORD32 i4_poc = 0 ; UWORD16 u2_first_mb_in_slice , u2_frame_num ; UWORD8 u1_field_pic_flag , u1_redundant_pic_cnt = 0 , u1_slice_type ; UWORD32 u4_idr_pic_id = 0 ; UWORD8 u1_bottom_field_flag , u1_pic_order_cnt_type ; UWORD8 u1_nal_unit_type ; UWORD32 * pu4_bitstrm_buf = ps_bitstrm -> pu4_buffer ; UWORD32 * pu4_bitstrm_ofst = & ps_bitstrm -> u4_ofst ; WORD8 i1_is_end_of_poc ; WORD32 ret , end_of_frame ; WORD32 prev_slice_err , num_mb_skipped ; UWORD8 u1_mbaff ; pocstruct_t * ps_cur_poc ; UWORD32 u4_temp ; WORD32 i_temp ; UWORD32 u4_call_end_of_pic = 0 ; ps_dec -> ps_dpb_cmds -> u1_dpb_commands_read_slc = 0 ; u2_first_mb_in_slice = ih264d_uev ( pu4_bitstrm_ofst , pu4_bitstrm_buf ) ; if ( u2_first_mb_in_slice > ( ps_dec -> u2_frm_ht_in_mbs * ps_dec -> u2_frm_wd_in_mbs ) ) { return ERROR_CORRUPTED_SLICE ; } if ( ( ( u2_first_mb_in_slice << ps_cur_slice -> u1_mbaff_frame_flag ) <= ps_dec -> u2_cur_mb_addr ) && ( ps_dec -> u4_first_slice_in_pic == 0 ) ) { return ERROR_CORRUPTED_SLICE ; } COPYTHECONTEXT ( \"SH:<S2SV_blank>first_mb_in_slice\" , u2_first_mb_in_slice ) ; u4_temp = ih264d_uev ( pu4_bitstrm_ofst , pu4_bitstrm_buf ) ; if ( u4_temp > 9 ) return ERROR_INV_SLC_TYPE_T ; u1_slice_type = u4_temp ; COPYTHECONTEXT ( \"SH:<S2SV_blank>slice_type\" , ( u1_slice_type ) ) ; if ( u1_slice_type > 4 ) { u1_slice_type -= 5 ; } { UWORD32 skip ; if ( ( ps_dec -> i4_app_skip_mode == IVD_SKIP_PB ) || ( ps_dec -> i4_dec_skip_mode == IVD_SKIP_PB ) ) { UWORD32 u4_bit_stream_offset = 0 ; if ( ps_dec -> u1_nal_unit_type == IDR_SLICE_NAL ) { skip = 0 ; ps_dec -> i4_dec_skip_mode = IVD_SKIP_NONE ; } else if ( ( I_SLICE == u1_slice_type ) && ( 1 >= ps_dec -> ps_cur_sps -> u1_num_ref_frames ) ) { skip = 0 ; ps_dec -> i4_dec_skip_mode = IVD_SKIP_NONE ; } else { skip = 1 ; } if ( ( 0 == u2_first_mb_in_slice ) && ( 1 == ps_dec -> u4_prev_nal_skipped ) ) { skip = 0 ; } if ( skip ) { ps_dec -> u4_prev_nal_skipped = 1 ; ps_dec -> i4_dec_skip_mode = IVD_SKIP_PB ; return 0 ; } else { if ( 1 == ps_dec -> u4_prev_nal_skipped ) { ps_dec -> u4_return_to_app = 1 ; return 0 ; } } } } u4_temp = ih264d_uev ( pu4_bitstrm_ofst , pu4_bitstrm_buf ) ; if ( u4_temp & MASK_ERR_PIC_SET_ID ) return ERROR_INV_SLICE_HDR_T ; COPYTHECONTEXT ( \"SH:<S2SV_blank>pic_parameter_set_id\" , u4_temp ) ; ps_pps = & ps_dec -> ps_pps [ u4_temp ] ; if ( FALSE == ps_pps -> u1_is_valid ) { return ERROR_INV_SLICE_HDR_T ; } ps_seq = ps_pps -> ps_sps ; if ( ! ps_seq ) return ERROR_INV_SLICE_HDR_T ; if ( FALSE == ps_seq -> u1_is_valid ) return ERROR_INV_SLICE_HDR_T ; u2_frame_num = ih264d_get_bits_h264 ( ps_bitstrm , ps_seq -> u1_bits_in_frm_num ) ; COPYTHECONTEXT ( \"SH:<S2SV_blank>frame_num\" , u2_frame_num ) ; if ( ! ps_dec -> u1_first_slice_in_stream && ps_dec -> u4_first_slice_in_pic ) { pocstruct_t * ps_prev_poc = & ps_dec -> s_prev_pic_poc ; pocstruct_t * ps_cur_poc = & ps_dec -> s_cur_pic_poc ; ps_dec -> u2_mbx = 0xffff ; ps_dec -> u2_mby = 0 ; if ( ( 0 == u1_is_idr_slice ) && ps_cur_slice -> u1_nal_ref_idc ) ps_dec -> u2_prev_ref_frame_num = ps_cur_slice -> u2_frame_num ; if ( u1_is_idr_slice || ps_cur_slice -> u1_mmco_equalto5 ) ps_dec -> u2_prev_ref_frame_num = 0 ; if ( ps_dec -> ps_cur_sps -> u1_gaps_in_frame_num_value_allowed_flag ) { ih264d_decode_gaps_in_frame_num ( ps_dec , u2_frame_num ) ; } ps_prev_poc -> i4_prev_frame_num_ofst = ps_cur_poc -> i4_prev_frame_num_ofst ; ps_prev_poc -> u2_frame_num = ps_cur_poc -> u2_frame_num ; ps_prev_poc -> u1_mmco_equalto5 = ps_cur_slice -> u1_mmco_equalto5 ; if ( ps_cur_slice -> u1_nal_ref_idc ) { ps_prev_poc -> i4_pic_order_cnt_lsb = ps_cur_poc -> i4_pic_order_cnt_lsb ; ps_prev_poc -> i4_pic_order_cnt_msb = ps_cur_poc -> i4_pic_order_cnt_msb ; ps_prev_poc -> i4_delta_pic_order_cnt_bottom = ps_cur_poc -> i4_delta_pic_order_cnt_bottom ; ps_prev_poc -> i4_delta_pic_order_cnt [ 0 ] = ps_cur_poc -> i4_delta_pic_order_cnt [ 0 ] ; ps_prev_poc -> i4_delta_pic_order_cnt [ 1 ] = ps_cur_poc -> i4_delta_pic_order_cnt [ 1 ] ; ps_prev_poc -> u1_bot_field = ps_cur_poc -> u1_bot_field ; } ps_dec -> u2_total_mbs_coded = 0 ; } if ( ! ps_seq -> u1_frame_mbs_only_flag ) { u1_field_pic_flag = ih264d_get_bit_h264 ( ps_bitstrm ) ; COPYTHECONTEXT ( \"SH:<S2SV_blank>field_pic_flag\" , u1_field_pic_flag ) ; u1_bottom_field_flag = 0 ; if ( u1_field_pic_flag ) { ps_dec -> pu1_inv_scan = ( UWORD8 * ) gau1_ih264d_inv_scan_fld ; u1_bottom_field_flag = ih264d_get_bit_h264 ( ps_bitstrm ) ; COPYTHECONTEXT ( \"SH:<S2SV_blank>bottom_field_flag\" , u1_bottom_field_flag ) ; } else { ps_dec -> pu1_inv_scan = ( UWORD8 * ) gau1_ih264d_inv_scan ; } } else { u1_field_pic_flag = 0 ; u1_bottom_field_flag = 0 ; ps_dec -> pu1_inv_scan = ( UWORD8 * ) gau1_ih264d_inv_scan ; } u1_nal_unit_type = SLICE_NAL ; if ( u1_is_idr_slice ) { u1_nal_unit_type = IDR_SLICE_NAL ; u4_idr_pic_id = ih264d_uev ( pu4_bitstrm_ofst , pu4_bitstrm_buf ) ; if ( u4_idr_pic_id > 65535 ) return ERROR_INV_SLICE_HDR_T ; COPYTHECONTEXT ( \"SH:<S2SV_blank><S2SV_blank>\" , u4_idr_pic_id ) ; } i_delta_poc [ 0 ] = i_delta_poc [ 1 ] = 0 ; s_tmp_poc . i4_pic_order_cnt_lsb = 0 ; s_tmp_poc . i4_delta_pic_order_cnt_bottom = 0 ; u1_pic_order_cnt_type = ps_seq -> u1_pic_order_cnt_type ; if ( u1_pic_order_cnt_type == 0 ) { i_temp = ih264d_get_bits_h264 ( ps_bitstrm , ps_seq -> u1_log2_max_pic_order_cnt_lsb_minus ) ; if ( i_temp < 0 || i_temp >= ps_seq -> i4_max_pic_order_cntLsb ) return ERROR_INV_SLICE_HDR_T ; s_tmp_poc . i4_pic_order_cnt_lsb = i_temp ; COPYTHECONTEXT ( \"SH:<S2SV_blank>pic_order_cnt_lsb\" , s_tmp_poc . i4_pic_order_cnt_lsb ) ; if ( ( ps_pps -> u1_pic_order_present_flag == 1 ) && ( ! u1_field_pic_flag ) ) { s_tmp_poc . i4_delta_pic_order_cnt_bottom = ih264d_sev ( pu4_bitstrm_ofst , pu4_bitstrm_buf ) ; COPYTHECONTEXT ( \"SH:<S2SV_blank>delta_pic_order_cnt_bottom\" , s_tmp_poc . i4_delta_pic_order_cnt_bottom ) ; } } s_tmp_poc . i4_delta_pic_order_cnt [ 0 ] = 0 ; s_tmp_poc . i4_delta_pic_order_cnt [ 1 ] = 0 ; if ( u1_pic_order_cnt_type == 1 && ( ! ps_seq -> u1_delta_pic_order_always_zero_flag ) ) { s_tmp_poc . i4_delta_pic_order_cnt [ 0 ] = ih264d_sev ( pu4_bitstrm_ofst , pu4_bitstrm_buf ) ; COPYTHECONTEXT ( \"SH:<S2SV_blank>delta_pic_order_cnt[0]\" , s_tmp_poc . i4_delta_pic_order_cnt [ 0 ] ) ; if ( ps_pps -> u1_pic_order_present_flag && ! u1_field_pic_flag ) { s_tmp_poc . i4_delta_pic_order_cnt [ 1 ] = ih264d_sev ( pu4_bitstrm_ofst , pu4_bitstrm_buf ) ; COPYTHECONTEXT ( \"SH:<S2SV_blank>delta_pic_order_cnt[1]\" , s_tmp_poc . i4_delta_pic_order_cnt [ 1 ] ) ; } } if ( ps_pps -> u1_redundant_pic_cnt_present_flag ) { u4_temp = ih264d_uev ( pu4_bitstrm_ofst , pu4_bitstrm_buf ) ; if ( u4_temp > MAX_REDUNDANT_PIC_CNT ) return ERROR_INV_SLICE_HDR_T ; u1_redundant_pic_cnt = u4_temp ; COPYTHECONTEXT ( \"SH:<S2SV_blank>redundant_pic_cnt\" , u1_redundant_pic_cnt ) ; } i1_is_end_of_poc = 1 ; ps_dec -> ps_dec_err_status -> u1_err_flag &= MASK_REJECT_CUR_PIC ; if ( ps_dec -> u4_first_slice_in_pic == 0 ) { i1_is_end_of_poc = ih264d_is_end_of_pic ( u2_frame_num , u1_nal_ref_idc , & s_tmp_poc , & ps_dec -> s_cur_pic_poc , ps_cur_slice , u1_pic_order_cnt_type , u1_nal_unit_type , u4_idr_pic_id , u1_field_pic_flag , u1_bottom_field_flag ) ; if ( i1_is_end_of_poc ) { ps_dec -> u1_first_slice_in_stream = 0 ; return ERROR_INCOMPLETE_FRAME ; } } u1_mbaff = ps_seq -> u1_mb_aff_flag && ( ! u1_field_pic_flag ) ; prev_slice_err = 0 ; if ( i1_is_end_of_poc || ps_dec -> u1_first_slice_in_stream ) { if ( u2_frame_num != ps_dec -> u2_prv_frame_num && ps_dec -> u1_top_bottom_decoded != 0 && ps_dec -> u1_top_bottom_decoded != ( TOP_FIELD_ONLY | BOT_FIELD_ONLY ) ) { ps_dec -> u1_dangling_field = 1 ; if ( ps_dec -> u4_first_slice_in_pic ) { prev_slice_err = 1 ; } else { prev_slice_err = 2 ; } if ( ps_dec -> u1_top_bottom_decoded == TOP_FIELD_ONLY ) ps_cur_slice -> u1_bottom_field_flag = 1 ; else ps_cur_slice -> u1_bottom_field_flag = 0 ; num_mb_skipped = ( ps_dec -> u2_frm_ht_in_mbs * ps_dec -> u2_frm_wd_in_mbs ) - ps_dec -> u2_total_mbs_coded ; ps_cur_poc = & ps_dec -> s_cur_pic_poc ; u1_is_idr_slice = ps_cur_slice -> u1_nal_unit_type == IDR_SLICE_NAL ; } else if ( ps_dec -> u4_first_slice_in_pic ) { if ( u2_first_mb_in_slice > 0 ) { prev_slice_err = 1 ; num_mb_skipped = u2_first_mb_in_slice << u1_mbaff ; ps_cur_poc = & s_tmp_poc ; ps_cur_slice -> u4_idr_pic_id = u4_idr_pic_id ; ps_cur_slice -> u1_field_pic_flag = u1_field_pic_flag ; ps_cur_slice -> u1_bottom_field_flag = u1_bottom_field_flag ; ps_cur_slice -> i4_pic_order_cnt_lsb = s_tmp_poc . i4_pic_order_cnt_lsb ; ps_cur_slice -> u1_nal_unit_type = u1_nal_unit_type ; ps_cur_slice -> u1_redundant_pic_cnt = u1_redundant_pic_cnt ; ps_cur_slice -> u1_nal_ref_idc = u1_nal_ref_idc ; ps_cur_slice -> u1_pic_order_cnt_type = u1_pic_order_cnt_type ; ps_cur_slice -> u1_mbaff_frame_flag = ps_seq -> u1_mb_aff_flag && ( ! u1_field_pic_flag ) ; } } else { prev_slice_err = 2 ; num_mb_skipped = ( ps_dec -> u2_frm_ht_in_mbs * ps_dec -> u2_frm_wd_in_mbs ) - ps_dec -> u2_total_mbs_coded ; ps_cur_poc = & s_tmp_poc ; } } else { if ( ( u2_first_mb_in_slice << u1_mbaff ) > ps_dec -> u2_total_mbs_coded ) { prev_slice_err = 2 ; num_mb_skipped = ( u2_first_mb_in_slice << u1_mbaff ) - ps_dec -> u2_total_mbs_coded ; ps_cur_poc = & s_tmp_poc ; } else if ( ( u2_first_mb_in_slice << u1_mbaff ) < ps_dec -> u2_total_mbs_coded ) { return ERROR_CORRUPTED_SLICE ; } } if ( prev_slice_err ) { ret = ih264d_mark_err_slice_skip ( ps_dec , num_mb_skipped , u1_is_idr_slice , u2_frame_num , ps_cur_poc , prev_slice_err ) ; if ( ps_dec -> u1_dangling_field == 1 ) { ps_dec -> u1_second_field = 1 - ps_dec -> u1_second_field ; ps_dec -> u1_first_slice_in_stream = 0 ; ps_dec -> u1_top_bottom_decoded = TOP_FIELD_ONLY | BOT_FIELD_ONLY ; return ERROR_DANGLING_FIELD_IN_PIC ; } if ( prev_slice_err == 2 ) { ps_dec -> u1_first_slice_in_stream = 0 ; return ERROR_INCOMPLETE_FRAME ; } if ( ps_dec -> u2_total_mbs_coded >= ps_dec -> u2_frm_ht_in_mbs * ps_dec -> u2_frm_wd_in_mbs ) { ps_dec -> u1_first_slice_in_stream = 0 ; return ERROR_IN_LAST_SLICE_OF_PIC ; } if ( ps_dec -> ps_dec_err_status -> u1_err_flag & REJECT_CUR_PIC ) { ih264d_err_pic_dispbuf_mgr ( ps_dec ) ; return ERROR_NEW_FRAME_EXPECTED ; } if ( ret != OK ) return ret ; i1_is_end_of_poc = 0 ; } if ( ps_dec -> u4_first_slice_in_pic == 0 ) { ps_dec -> ps_parse_cur_slice ++ ; ps_dec -> u2_cur_slice_num ++ ; } if ( ( ps_dec -> u1_separate_parse == 0 ) && ( ps_dec -> u4_first_slice_in_pic == 0 ) ) { ps_dec -> ps_decode_cur_slice ++ ; } ps_dec -> u1_slice_header_done = 0 ; if ( u1_field_pic_flag ) { ps_dec -> u2_prv_frame_num = u2_frame_num ; } if ( ps_cur_slice -> u1_mmco_equalto5 ) { WORD32 i4_temp_poc ; WORD32 i4_top_field_order_poc , i4_bot_field_order_poc ; if ( ! ps_cur_slice -> u1_field_pic_flag ) { i4_top_field_order_poc = ps_dec -> ps_cur_pic -> i4_top_field_order_cnt ; i4_bot_field_order_poc = ps_dec -> ps_cur_pic -> i4_bottom_field_order_cnt ; i4_temp_poc = MIN ( i4_top_field_order_poc , i4_bot_field_order_poc ) ; } else if ( ! ps_cur_slice -> u1_bottom_field_flag ) i4_temp_poc = ps_dec -> ps_cur_pic -> i4_top_field_order_cnt ; else i4_temp_poc = ps_dec -> ps_cur_pic -> i4_bottom_field_order_cnt ; ps_dec -> ps_cur_pic -> i4_top_field_order_cnt = i4_temp_poc - ps_dec -> ps_cur_pic -> i4_top_field_order_cnt ; ps_dec -> ps_cur_pic -> i4_bottom_field_order_cnt = i4_temp_poc - ps_dec -> ps_cur_pic -> i4_bottom_field_order_cnt ; ps_dec -> ps_cur_pic -> i4_poc = i4_temp_poc ; ps_dec -> ps_cur_pic -> i4_avg_poc = i4_temp_poc ; } if ( ps_dec -> u4_first_slice_in_pic ) { ret = ih264d_decode_pic_order_cnt ( u1_is_idr_slice , u2_frame_num , & ps_dec -> s_prev_pic_poc , & s_tmp_poc , ps_cur_slice , ps_pps , u1_nal_ref_idc , u1_bottom_field_flag , u1_field_pic_flag , & i4_poc ) ; if ( ret != OK ) return ret ; if ( i4_poc >= ps_dec -> i4_max_poc ) ps_dec -> i4_max_poc = i4_poc ; if ( i4_poc == 0 ) { ps_dec -> i4_prev_max_display_seq = ps_dec -> i4_prev_max_display_seq + ps_dec -> i4_max_poc + ps_dec -> u1_max_dec_frame_buffering + 1 ; ps_dec -> i4_max_poc = 0 ; } } ps_cur_slice -> i4_delta_pic_order_cnt [ 0 ] = i_delta_poc [ 0 ] ; ps_cur_slice -> i4_delta_pic_order_cnt [ 1 ] = i_delta_poc [ 1 ] ; ps_cur_slice -> u4_idr_pic_id = u4_idr_pic_id ; ps_cur_slice -> u2_first_mb_in_slice = u2_first_mb_in_slice ; ps_cur_slice -> u1_field_pic_flag = u1_field_pic_flag ; ps_cur_slice -> u1_bottom_field_flag = u1_bottom_field_flag ; ps_cur_slice -> u1_slice_type = u1_slice_type ; ps_cur_slice -> i4_pic_order_cnt_lsb = s_tmp_poc . i4_pic_order_cnt_lsb ; ps_cur_slice -> u1_nal_unit_type = u1_nal_unit_type ; ps_cur_slice -> u1_redundant_pic_cnt = u1_redundant_pic_cnt ; ps_cur_slice -> u1_nal_ref_idc = u1_nal_ref_idc ; ps_cur_slice -> u1_pic_order_cnt_type = u1_pic_order_cnt_type ; if ( ps_seq -> u1_frame_mbs_only_flag ) ps_cur_slice -> u1_direct_8x8_inference_flag = ps_seq -> u1_direct_8x8_inference_flag ; else ps_cur_slice -> u1_direct_8x8_inference_flag = 1 ; if ( u1_slice_type == B_SLICE ) { ps_cur_slice -> u1_direct_spatial_mv_pred_flag = ih264d_get_bit_h264 ( ps_bitstrm ) ; COPYTHECONTEXT ( \"SH:<S2SV_blank>direct_spatial_mv_pred_flag\" , ps_cur_slice -> u1_direct_spatial_mv_pred_flag ) ; if ( ps_cur_slice -> u1_direct_spatial_mv_pred_flag ) ps_cur_slice -> pf_decodeDirect = ih264d_decode_spatial_direct ; else ps_cur_slice -> pf_decodeDirect = ih264d_decode_temporal_direct ; if ( ! ( ( ps_pps -> ps_sps -> u1_mb_aff_flag ) && ( ! u1_field_pic_flag ) ) ) ps_dec -> pf_mvpred = ih264d_mvpred_nonmbaffB ; } else { if ( ! ( ( ps_pps -> ps_sps -> u1_mb_aff_flag ) && ( ! u1_field_pic_flag ) ) ) ps_dec -> pf_mvpred = ih264d_mvpred_nonmbaff ; } if ( ps_dec -> u4_first_slice_in_pic ) { if ( u2_first_mb_in_slice == 0 ) { ret = ih264d_start_of_pic ( ps_dec , i4_poc , & s_tmp_poc , u2_frame_num , ps_pps ) ; if ( ret != OK ) return ret ; } ps_dec -> u4_output_present = 0 ; { ih264d_get_next_display_field ( ps_dec , ps_dec -> ps_out_buffer , & ( ps_dec -> s_disp_op ) ) ; if ( 0 != ps_dec -> s_disp_op . u4_error_code ) { ps_dec -> u4_fmt_conv_cur_row = ps_dec -> s_disp_frame_info . u4_y_ht ; } else ps_dec -> u4_output_present = 1 ; } if ( ps_dec -> u1_separate_parse == 1 ) { if ( ps_dec -> u4_dec_thread_created == 0 ) { ithread_create ( ps_dec -> pv_dec_thread_handle , NULL , ( void * ) ih264d_decode_picture_thread , ( void * ) ps_dec ) ; ps_dec -> u4_dec_thread_created = 1 ; } if ( ( ps_dec -> u4_num_cores == 3 ) && ( ( ps_dec -> u4_app_disable_deblk_frm == 0 ) || ps_dec -> i1_recon_in_thread3_flag ) && ( ps_dec -> u4_bs_deblk_thread_created == 0 ) ) { ps_dec -> u4_start_recon_deblk = 0 ; ithread_create ( ps_dec -> pv_bs_deblk_thread_handle , NULL , ( void * ) ih264d_recon_deblk_thread , ( void * ) ps_dec ) ; ps_dec -> u4_bs_deblk_thread_created = 1 ; } } } { UWORD8 uc_nofield_nombaff ; uc_nofield_nombaff = ( ( ps_dec -> ps_cur_slice -> u1_field_pic_flag == 0 ) && ( ps_dec -> ps_cur_slice -> u1_mbaff_frame_flag == 0 ) && ( u1_slice_type != B_SLICE ) && ( ps_dec -> ps_cur_pps -> u1_wted_pred_flag == 0 ) ) ; if ( uc_nofield_nombaff ) { ps_dec -> p_form_mb_part_info = ih264d_form_mb_part_info_bp ; ps_dec -> p_motion_compensate = ih264d_motion_compensate_bp ; } else { ps_dec -> p_form_mb_part_info = ih264d_form_mb_part_info_mp ; ps_dec -> p_motion_compensate = ih264d_motion_compensate_mp ; } } { dec_err_status_t * ps_err = ps_dec -> ps_dec_err_status ; if ( ps_err -> u4_frm_sei_sync == u2_frame_num ) { ps_err -> u1_err_flag = ACCEPT_ALL_PICS ; ps_err -> u4_frm_sei_sync = SYNC_FRM_DEFAULT ; } ps_err -> u4_cur_frm = u2_frame_num ; } { WORD32 i4_skip_b_pic , i4_skip_p_pic ; i4_skip_b_pic = ( ps_dec -> u4_skip_frm_mask & B_SLC_BIT ) && ( B_SLICE == u1_slice_type ) && ( 0 == u1_nal_ref_idc ) ; i4_skip_p_pic = ( ps_dec -> u4_skip_frm_mask & P_SLC_BIT ) && ( P_SLICE == u1_slice_type ) && ( 0 == u1_nal_ref_idc ) ; if ( i4_skip_b_pic ) { ps_dec -> ps_cur_pic -> u4_pack_slc_typ |= B_SLC_BIT ; ps_dec -> u1_last_pic_not_decoded = 1 ; return OK ; } if ( i4_skip_p_pic ) { ps_dec -> ps_cur_pic -> u4_pack_slc_typ |= P_SLC_BIT ; ps_dec -> u1_last_pic_not_decoded = 1 ; return OK ; } } { UWORD16 u2_mb_x , u2_mb_y ; ps_dec -> i4_submb_ofst = ( ( u2_first_mb_in_slice << ps_cur_slice -> u1_mbaff_frame_flag ) * SUB_BLK_SIZE ) - SUB_BLK_SIZE ; if ( u2_first_mb_in_slice ) { UWORD8 u1_mb_aff ; UWORD8 u1_field_pic ; UWORD16 u2_frm_wd_in_mbs ; u2_frm_wd_in_mbs = ps_seq -> u2_frm_wd_in_mbs ; u1_mb_aff = ps_cur_slice -> u1_mbaff_frame_flag ; u1_field_pic = ps_cur_slice -> u1_field_pic_flag ; { UWORD32 x_offset ; UWORD32 y_offset ; UWORD32 u4_frame_stride ; tfr_ctxt_t * ps_trns_addr ; if ( ps_dec -> u1_separate_parse ) { ps_trns_addr = & ps_dec -> s_tran_addrecon_parse ; } else { ps_trns_addr = & ps_dec -> s_tran_addrecon ; } u2_mb_x = MOD ( u2_first_mb_in_slice , u2_frm_wd_in_mbs ) ; u2_mb_y = DIV ( u2_first_mb_in_slice , u2_frm_wd_in_mbs ) ; u2_mb_y <<= u1_mb_aff ; if ( ( u2_mb_x > u2_frm_wd_in_mbs - 1 ) || ( u2_mb_y > ps_dec -> u2_frm_ht_in_mbs - 1 ) ) { return ERROR_CORRUPTED_SLICE ; } u4_frame_stride = ps_dec -> u2_frm_wd_y << u1_field_pic ; x_offset = u2_mb_x << 4 ; y_offset = ( u2_mb_y * u4_frame_stride ) << 4 ; ps_trns_addr -> pu1_dest_y = ps_dec -> s_cur_pic . pu1_buf1 + x_offset + y_offset ; u4_frame_stride = ps_dec -> u2_frm_wd_uv << u1_field_pic ; x_offset >>= 1 ; y_offset = ( u2_mb_y * u4_frame_stride ) << 3 ; x_offset *= YUV420SP_FACTOR ; ps_trns_addr -> pu1_dest_u = ps_dec -> s_cur_pic . pu1_buf2 + x_offset + y_offset ; ps_trns_addr -> pu1_dest_v = ps_dec -> s_cur_pic . pu1_buf3 + x_offset + y_offset ; ps_trns_addr -> pu1_mb_y = ps_trns_addr -> pu1_dest_y ; ps_trns_addr -> pu1_mb_u = ps_trns_addr -> pu1_dest_u ; ps_trns_addr -> pu1_mb_v = ps_trns_addr -> pu1_dest_v ; if ( ps_dec -> u1_separate_parse == 1 ) { ps_dec -> ps_deblk_mbn = ps_dec -> ps_deblk_pic + ( u2_first_mb_in_slice << u1_mb_aff ) ; } else { ps_dec -> ps_deblk_mbn = ps_dec -> ps_deblk_pic + ( u2_first_mb_in_slice << u1_mb_aff ) ; } ps_dec -> u2_cur_mb_addr = ( u2_first_mb_in_slice << u1_mb_aff ) ; ps_dec -> ps_mv_cur = ps_dec -> s_cur_pic . ps_mv + ( ( u2_first_mb_in_slice << u1_mb_aff ) << 4 ) ; } } else { tfr_ctxt_t * ps_trns_addr ; if ( ps_dec -> u1_separate_parse ) { ps_trns_addr = & ps_dec -> s_tran_addrecon_parse ; } else { ps_trns_addr = & ps_dec -> s_tran_addrecon ; } u2_mb_x = 0xffff ; u2_mb_y = 0 ; ps_dec -> u2_cur_mb_addr = 0 ; ps_dec -> ps_deblk_mbn = ps_dec -> ps_deblk_pic ; ps_dec -> ps_mv_cur = ps_dec -> s_cur_pic . ps_mv ; ps_trns_addr -> pu1_dest_y = ps_dec -> s_cur_pic . pu1_buf1 ; ps_trns_addr -> pu1_dest_u = ps_dec -> s_cur_pic . pu1_buf2 ; ps_trns_addr -> pu1_dest_v = ps_dec -> s_cur_pic . pu1_buf3 ; ps_trns_addr -> pu1_mb_y = ps_trns_addr -> pu1_dest_y ; ps_trns_addr -> pu1_mb_u = ps_trns_addr -> pu1_dest_u ; ps_trns_addr -> pu1_mb_v = ps_trns_addr -> pu1_dest_v ; } ps_dec -> ps_part = ps_dec -> ps_parse_part_params ; ps_dec -> u2_mbx = ( MOD ( u2_first_mb_in_slice - 1 , ps_seq -> u2_frm_wd_in_mbs ) ) ; ps_dec -> u2_mby = ( DIV ( u2_first_mb_in_slice - 1 , ps_seq -> u2_frm_wd_in_mbs ) ) ; ps_dec -> u2_mby <<= ps_cur_slice -> u1_mbaff_frame_flag ; ps_dec -> i2_prev_slice_mbx = ps_dec -> u2_mbx ; ps_dec -> i2_prev_slice_mby = ps_dec -> u2_mby ; } ps_bitstrm -> u4_max_ofst += ps_dec -> ps_cur_pps -> u1_entropy_coding_mode ; ps_dec -> u1_B = ( u1_slice_type == B_SLICE ) ; ps_dec -> u4_next_mb_skip = 0 ; ps_dec -> ps_parse_cur_slice -> u4_first_mb_in_slice = ps_dec -> ps_cur_slice -> u2_first_mb_in_slice ; ps_dec -> ps_parse_cur_slice -> slice_type = ps_dec -> ps_cur_slice -> u1_slice_type ; ps_dec -> u4_start_recon_deblk = 1 ; { WORD32 num_entries ; WORD32 size ; UWORD8 * pu1_buf ; num_entries = MAX_FRAMES ; if ( ( 1 >= ps_dec -> ps_cur_sps -> u1_num_ref_frames ) && ( 0 == ps_dec -> i4_display_delay ) ) { num_entries = 1 ; } num_entries = ( ( 2 * num_entries ) + 1 ) ; num_entries *= 2 ; size = num_entries * sizeof ( void * ) ; size += PAD_MAP_IDX_POC * sizeof ( void * ) ; pu1_buf = ( UWORD8 * ) ps_dec -> pv_map_ref_idx_to_poc_buf ; pu1_buf += size * ps_dec -> u2_cur_slice_num ; ps_dec -> ps_parse_cur_slice -> ppv_map_ref_idx_to_poc = ( void * ) pu1_buf ; } if ( ps_dec -> u1_separate_parse ) { ps_dec -> ps_parse_cur_slice -> pv_tu_coeff_data_start = ps_dec -> pv_parse_tu_coeff_data ; } else { ps_dec -> pv_proc_tu_coeff_data = ps_dec -> pv_parse_tu_coeff_data ; } if ( u1_slice_type == I_SLICE ) { ps_dec -> ps_cur_pic -> u4_pack_slc_typ |= I_SLC_BIT ; ret = ih264d_parse_islice ( ps_dec , u2_first_mb_in_slice ) ; if ( ps_dec -> i4_pic_type != B_SLICE && ps_dec -> i4_pic_type != P_SLICE ) ps_dec -> i4_pic_type = I_SLICE ; } else if ( u1_slice_type == P_SLICE ) { ps_dec -> ps_cur_pic -> u4_pack_slc_typ |= P_SLC_BIT ; ret = ih264d_parse_pslice ( ps_dec , u2_first_mb_in_slice ) ; ps_dec -> u1_pr_sl_type = u1_slice_type ; if ( ps_dec -> i4_pic_type != B_SLICE ) ps_dec -> i4_pic_type = P_SLICE ; } else if ( u1_slice_type == B_SLICE ) { ps_dec -> ps_cur_pic -> u4_pack_slc_typ |= B_SLC_BIT ; ret = ih264d_parse_bslice ( ps_dec , u2_first_mb_in_slice ) ; ps_dec -> u1_pr_sl_type = u1_slice_type ; ps_dec -> i4_pic_type = B_SLICE ; } else return ERROR_INV_SLC_TYPE_T ; if ( ps_dec -> u1_slice_header_done ) { ps_dec -> u1_first_slice_in_stream = 0 ; } if ( ret != OK ) return ret ; <S2SV_StartBug> ps_dec -> i2_prev_slice_mbx = ps_dec -> u2_mbx ; <S2SV_EndBug> ps_dec -> i2_prev_slice_mby = ps_dec -> u2_mby ; if ( ps_dec -> u2_total_mbs_coded >= ( ps_seq -> u2_max_mb_addr + 1 ) ) { ps_dec -> u1_pic_decode_done = 1 ; } { dec_err_status_t * ps_err = ps_dec -> ps_dec_err_status ; if ( ( ps_err -> u1_err_flag & REJECT_PB_PICS ) && ( ps_err -> u1_cur_pic_type == PIC_TYPE_I ) ) { ps_err -> u1_err_flag = ACCEPT_ALL_PICS ; } } PRINT_BIN_BIT_RATIO ( ps_dec ) return ret ; }\n","target":"<S2SV_ModStart> return ret ; if ( u1_nal_ref_idc != 0 ) { if ( ! ps_dec -> ps_dpb_cmds -> u1_dpb_commands_read ) { memcpy ( ( void * ) ps_dec -> ps_dpb_cmds , ( void * ) ( & ( ps_dec -> s_dpb_cmds_scratch ) ) , sizeof ( dpb_commands_t ) ) ; } }\n","project_and_commit_id":"external@libavc/6c327afb263837bc90760c55c6605b26161a4eb9","cve_id":"CVE-2017-13186","original_address":"https://android.googlesource.com/platform/external/libavc/+/6c327afb263837bc90760c55c6605b26161a4eb9","time":"2018-01-12T23:29Z"},
	{"Unnamed: 0":588,"cwe_id":"CWE-404","source":"CWE-404 static int omninet_open ( struct tty_struct * tty , struct usb_serial_port * port ) { <S2SV_StartBug> struct usb_serial * serial = port -> serial ; <S2SV_EndBug> struct usb_serial_port * wport ; wport = serial -> port [ 1 ] ; tty_port_tty_set ( & wport -> port , tty ) ; return usb_serial_generic_open ( tty , port ) ; }\n","target":"<S2SV_ModStart> port ) { <S2SV_ModEnd> return usb_serial_generic_open (\n","project_and_commit_id":"torvalds@linux/30572418b445d85fcfe6c8fe84c947d2606767d8","cve_id":"CVE-2017-8925","original_address":"https://github.com/torvalds/linux/commit/30572418b445d85fcfe6c8fe84c947d2606767d8","time":"2017-05-12T21:29Z"},
	{"Unnamed: 0":1647,"cwe_id":"CWE-119","source":"CWE-119 static PyObject * _pyfribidi_log2vis ( PyObject * self , PyObject * args , PyObject * kw ) { <S2SV_StartBug> PyObject * logical = NULL ; <S2SV_EndBug> <S2SV_StartBug> FriBidiParType base = FRIBIDI_TYPE_RTL ; <S2SV_EndBug> const char * encoding = \"utf-8\" ; int clean = 0 ; int reordernsm = 1 ; static char * kwargs [ ] = <S2SV_StartBug> { \"logical\" , \"base_direction\" , \"encoding\" , \"clean\" , \"reordernsm\" , NULL } ; <S2SV_EndBug> <S2SV_StartBug> if ( ! PyArg_ParseTupleAndKeywords ( args , kw , \"O|isii\" , kwargs , <S2SV_EndBug> <S2SV_StartBug> & logical , & base , & encoding , & clean , & reordernsm ) ) <S2SV_EndBug> <S2SV_StartBug> return NULL ; <S2SV_EndBug> if ( ! ( base == FRIBIDI_TYPE_RTL || <S2SV_StartBug> base == FRIBIDI_TYPE_LTR || base == FRIBIDI_TYPE_ON ) ) <S2SV_EndBug> return PyErr_Format ( PyExc_ValueError , \"invalid<S2SV_blank>value<S2SV_blank>%d:<S2SV_blank>use<S2SV_blank>either<S2SV_blank>RTL,<S2SV_blank>LTR<S2SV_blank>or<S2SV_blank>ON\" , base ) ; <S2SV_StartBug> if ( PyUnicode_Check ( logical ) ) <S2SV_EndBug> return log2vis_unicode ( logical , base , clean , reordernsm ) ; <S2SV_StartBug> else if ( PyString_Check ( logical ) ) <S2SV_EndBug> return log2vis_encoded_string ( logical , encoding , base , clean , reordernsm ) ; else return PyErr_Format ( PyExc_TypeError , \"expected<S2SV_blank>unicode<S2SV_blank>or<S2SV_blank>str,<S2SV_blank>not<S2SV_blank>%s\" , logical -> ob_type -> tp_name ) ; }\n","target":"<S2SV_ModStart> kw ) { PyUnicodeObject <S2SV_ModEnd> * logical = <S2SV_ModStart> base = FRIBIDI_TYPE_RTL <S2SV_ModEnd> ; int clean <S2SV_ModStart> , \"base_direction\" , <S2SV_ModEnd> \"clean\" , \"reordernsm\" <S2SV_ModStart> , kw , \"U|iii\" <S2SV_ModEnd> , kwargs , <S2SV_ModStart> base , & <S2SV_ModEnd> clean , & <S2SV_ModStart> reordernsm ) ) { <S2SV_ModStart> return NULL ; } <S2SV_ModStart> FRIBIDI_TYPE_ON ) ) { <S2SV_ModStart> base ) ; } return unicode_log2vis <S2SV_ModEnd> ( logical , <S2SV_ModStart> reordernsm ) ; <S2SV_ModEnd> } <S2SV_null> <S2SV_null>\n","project_and_commit_id":"pediapress@pyfribidi/d2860c655357975e7b32d84e6b45e98f0dcecd7a","cve_id":"CVE-2012-1176","original_address":"https://github.com/pediapress/pyfribidi/commit/d2860c655357975e7b32d84e6b45e98f0dcecd7a","time":"2012-08-26T20:55Z"},
	{"Unnamed: 0":6523,"cwe_id":"CWE-200","source":"CWE-200 <S2SV_StartBug> static void print_bpf_insn ( struct bpf_insn * insn ) <S2SV_EndBug> { u8 class = BPF_CLASS ( insn -> code ) ; if ( class == BPF_ALU || class == BPF_ALU64 ) { if ( BPF_SRC ( insn -> code ) == BPF_X ) verbose ( \"(%02x)<S2SV_blank>%sr%d<S2SV_blank>%s<S2SV_blank>%sr%d\\\\n\" , insn -> code , class == BPF_ALU ? \"(u32)<S2SV_blank>\" : \"\" , insn -> dst_reg , bpf_alu_string [ BPF_OP ( insn -> code ) >> 4 ] , class == BPF_ALU ? \"(u32)<S2SV_blank>\" : \"\" , insn -> src_reg ) ; else verbose ( \"(%02x)<S2SV_blank>%sr%d<S2SV_blank>%s<S2SV_blank>%s%d\\\\n\" , insn -> code , class == BPF_ALU ? \"(u32)<S2SV_blank>\" : \"\" , insn -> dst_reg , bpf_alu_string [ BPF_OP ( insn -> code ) >> 4 ] , class == BPF_ALU ? \"(u32)<S2SV_blank>\" : \"\" , insn -> imm ) ; } else if ( class == BPF_STX ) { if ( BPF_MODE ( insn -> code ) == BPF_MEM ) verbose ( \"(%02x)<S2SV_blank>*(%s<S2SV_blank>*)(r%d<S2SV_blank>%+d)<S2SV_blank>=<S2SV_blank>r%d\\\\n\" , insn -> code , bpf_ldst_string [ BPF_SIZE ( insn -> code ) >> 3 ] , insn -> dst_reg , insn -> off , insn -> src_reg ) ; else if ( BPF_MODE ( insn -> code ) == BPF_XADD ) verbose ( \"(%02x)<S2SV_blank>lock<S2SV_blank>*(%s<S2SV_blank>*)(r%d<S2SV_blank>%+d)<S2SV_blank>+=<S2SV_blank>r%d\\\\n\" , insn -> code , bpf_ldst_string [ BPF_SIZE ( insn -> code ) >> 3 ] , insn -> dst_reg , insn -> off , insn -> src_reg ) ; else verbose ( \"BUG_%02x\\\\n\" , insn -> code ) ; } else if ( class == BPF_ST ) { if ( BPF_MODE ( insn -> code ) != BPF_MEM ) { verbose ( \"BUG_st_%02x\\\\n\" , insn -> code ) ; return ; } verbose ( \"(%02x)<S2SV_blank>*(%s<S2SV_blank>*)(r%d<S2SV_blank>%+d)<S2SV_blank>=<S2SV_blank>%d\\\\n\" , insn -> code , bpf_ldst_string [ BPF_SIZE ( insn -> code ) >> 3 ] , insn -> dst_reg , insn -> off , insn -> imm ) ; } else if ( class == BPF_LDX ) { if ( BPF_MODE ( insn -> code ) != BPF_MEM ) { verbose ( \"BUG_ldx_%02x\\\\n\" , insn -> code ) ; return ; } verbose ( \"(%02x)<S2SV_blank>r%d<S2SV_blank>=<S2SV_blank>*(%s<S2SV_blank>*)(r%d<S2SV_blank>%+d)\\\\n\" , insn -> code , insn -> dst_reg , bpf_ldst_string [ BPF_SIZE ( insn -> code ) >> 3 ] , insn -> src_reg , insn -> off ) ; } else if ( class == BPF_LD ) { if ( BPF_MODE ( insn -> code ) == BPF_ABS ) { verbose ( \"(%02x)<S2SV_blank>r0<S2SV_blank>=<S2SV_blank>*(%s<S2SV_blank>*)skb[%d]\\\\n\" , insn -> code , bpf_ldst_string [ BPF_SIZE ( insn -> code ) >> 3 ] , insn -> imm ) ; } else if ( BPF_MODE ( insn -> code ) == BPF_IND ) { verbose ( \"(%02x)<S2SV_blank>r0<S2SV_blank>=<S2SV_blank>*(%s<S2SV_blank>*)skb[r%d<S2SV_blank>+<S2SV_blank>%d]\\\\n\" , insn -> code , bpf_ldst_string [ BPF_SIZE ( insn -> code ) >> 3 ] , insn -> src_reg , insn -> imm ) ; <S2SV_StartBug> } else if ( BPF_MODE ( insn -> code ) == BPF_IMM ) { <S2SV_EndBug> verbose ( \"(%02x)<S2SV_blank>r%d<S2SV_blank>=<S2SV_blank>0x%x\\\\n\" , <S2SV_StartBug> insn -> code , insn -> dst_reg , insn -> imm ) ; <S2SV_EndBug> } else { verbose ( \"BUG_ld_%02x\\\\n\" , insn -> code ) ; return ; } } else if ( class == BPF_JMP ) { u8 opcode = BPF_OP ( insn -> code ) ; if ( opcode == BPF_CALL ) { verbose ( \"(%02x)<S2SV_blank>call<S2SV_blank>%s#%d\\\\n\" , insn -> code , func_id_name ( insn -> imm ) , insn -> imm ) ; } else if ( insn -> code == ( BPF_JMP | BPF_JA ) ) { verbose ( \"(%02x)<S2SV_blank>goto<S2SV_blank>pc%+d\\\\n\" , insn -> code , insn -> off ) ; } else if ( insn -> code == ( BPF_JMP | BPF_EXIT ) ) { verbose ( \"(%02x)<S2SV_blank>exit\\\\n\" , insn -> code ) ; } else if ( BPF_SRC ( insn -> code ) == BPF_X ) { verbose ( \"(%02x)<S2SV_blank>if<S2SV_blank>r%d<S2SV_blank>%s<S2SV_blank>r%d<S2SV_blank>goto<S2SV_blank>pc%+d\\\\n\" , insn -> code , insn -> dst_reg , bpf_jmp_string [ BPF_OP ( insn -> code ) >> 4 ] , insn -> src_reg , insn -> off ) ; } else { verbose ( \"(%02x)<S2SV_blank>if<S2SV_blank>r%d<S2SV_blank>%s<S2SV_blank>0x%x<S2SV_blank>goto<S2SV_blank>pc%+d\\\\n\" , insn -> code , insn -> dst_reg , bpf_jmp_string [ BPF_OP ( insn -> code ) >> 4 ] , insn -> imm , insn -> off ) ; } } else { verbose ( \"(%02x)<S2SV_blank>%s\\\\n\" , insn -> code , bpf_class_string [ class ] ) ; } }\n","target":"<S2SV_ModStart> void print_bpf_insn ( const struct bpf_verifier_env * env , const <S2SV_ModStart> ) == BPF_IMM && BPF_SIZE ( insn -> code ) == BPF_DW ) { u64 imm = ( ( u64 ) ( insn + 1 ) -> imm << 32 ) | ( u32 ) insn -> imm ; bool map_ptr = insn -> src_reg == BPF_PSEUDO_MAP_FD ; if ( map_ptr && ! env -> allow_ptr_leaks ) imm = 0 ; verbose ( \"(%02x)<S2SV_blank>r%d<S2SV_blank>=<S2SV_blank>0x%llx\\\\n\" , insn -> code , <S2SV_ModEnd> insn -> dst_reg <S2SV_ModStart> -> dst_reg , ( unsigned long long ) <S2SV_ModEnd> imm ) ;\n","project_and_commit_id":"torvalds@linux/0d0e57697f162da4aa218b5feafe614fb666db07","cve_id":"CVE-2017-9150","original_address":"https://github.com/torvalds/linux/commit/0d0e57697f162da4aa218b5feafe614fb666db07","time":"2017-05-22T22:29Z"},
	{"Unnamed: 0":4726,"cwe_id":"CWE-119","source":"CWE-119 <S2SV_StartBug> static void iwl_sta_ucode_activate ( struct iwl_priv * priv , u8 sta_id ) <S2SV_EndBug> <S2SV_StartBug> { <S2SV_EndBug> if ( ! ( priv -> stations [ sta_id ] . used & IWL_STA_DRIVER_ACTIVE ) ) IWL_ERR ( priv , \"ACTIVATE<S2SV_blank>a<S2SV_blank>non<S2SV_blank>DRIVER<S2SV_blank>active<S2SV_blank>station<S2SV_blank>id<S2SV_blank>%u<S2SV_blank>\" \"addr<S2SV_blank>%pM\\\\n\" , sta_id , priv -> stations [ sta_id ] . sta . sta . addr ) ; if ( priv -> stations [ sta_id ] . used & IWL_STA_UCODE_ACTIVE ) { IWL_DEBUG_ASSOC ( priv , \"STA<S2SV_blank>id<S2SV_blank>%u<S2SV_blank>addr<S2SV_blank>%pM<S2SV_blank>already<S2SV_blank>present<S2SV_blank>in<S2SV_blank>uCode<S2SV_blank>\" \"(according<S2SV_blank>to<S2SV_blank>driver)\\\\n\" , sta_id , priv -> stations [ sta_id ] . sta . sta . addr ) ; } else { priv -> stations [ sta_id ] . used |= IWL_STA_UCODE_ACTIVE ; IWL_DEBUG_ASSOC ( priv , \"Added<S2SV_blank>STA<S2SV_blank>id<S2SV_blank>%u<S2SV_blank>addr<S2SV_blank>%pM<S2SV_blank>to<S2SV_blank>uCode\\\\n\" , sta_id , priv -> stations [ sta_id ] . sta . sta . addr ) ; } <S2SV_StartBug> } <S2SV_EndBug>\n","target":"<S2SV_ModStart> <S2SV_null> <S2SV_null> static int <S2SV_ModEnd> iwl_sta_ucode_activate ( struct <S2SV_ModStart> sta_id ) { if ( sta_id >= IWLAGN_STATION_COUNT ) { IWL_ERR ( priv , \"invalid<S2SV_blank>sta_id<S2SV_blank>%u\" , sta_id ) ; return - EINVAL ; } <S2SV_ModStart> ) ; } return 0 ;\n","project_and_commit_id":"torvalds@linux/2da424b0773cea3db47e1e81db71eeebde8269d4","cve_id":"CVE-2012-6712","original_address":"https://github.com/torvalds/linux/commit/2da424b0773cea3db47e1e81db71eeebde8269d4","time":"2019-07-27T22:15Z"},
	{"Unnamed: 0":2826,"cwe_id":"CWE-399","source":"CWE-399 int kvm_arch_vcpu_init ( struct kvm_vcpu * vcpu ) { struct page * page ; struct kvm * kvm ; int r ; BUG_ON ( vcpu -> kvm == NULL ) ; kvm = vcpu -> kvm ; vcpu -> arch . emulate_ctxt . ops = & emulate_ops ; if ( ! irqchip_in_kernel ( kvm ) || kvm_vcpu_is_bsp ( vcpu ) ) vcpu -> arch . mp_state = KVM_MP_STATE_RUNNABLE ; else vcpu -> arch . mp_state = KVM_MP_STATE_UNINITIALIZED ; page = alloc_page ( GFP_KERNEL | __GFP_ZERO ) ; if ( ! page ) { r = - ENOMEM ; goto fail ; } vcpu -> arch . pio_data = page_address ( page ) ; kvm_set_tsc_khz ( vcpu , max_tsc_khz ) ; r = kvm_mmu_create ( vcpu ) ; if ( r < 0 ) goto fail_free_pio_data ; if ( irqchip_in_kernel ( kvm ) ) { r = kvm_create_lapic ( vcpu ) ; if ( r < 0 ) goto fail_mmu_destroy ; } else static_key_slow_inc ( & kvm_no_apic_vcpu ) ; vcpu -> arch . mce_banks = kzalloc ( KVM_MAX_MCE_BANKS * sizeof ( u64 ) * 4 , GFP_KERNEL ) ; if ( ! vcpu -> arch . mce_banks ) { r = - ENOMEM ; goto fail_free_lapic ; } vcpu -> arch . mcg_cap = KVM_MAX_MCE_BANKS ; if ( ! zalloc_cpumask_var ( & vcpu -> arch . wbinvd_dirty_mask , GFP_KERNEL ) ) goto fail_free_mce_banks ; r = fx_init ( vcpu ) ; if ( r ) goto fail_free_wbinvd_dirty_mask ; vcpu -> arch . ia32_tsc_adjust_msr = 0x0 ; <S2SV_StartBug> kvm_async_pf_hash_reset ( vcpu ) ; <S2SV_EndBug> kvm_pmu_init ( vcpu ) ; return 0 ; fail_free_wbinvd_dirty_mask : free_cpumask_var ( vcpu -> arch . wbinvd_dirty_mask ) ; fail_free_mce_banks : kfree ( vcpu -> arch . mce_banks ) ; fail_free_lapic : kvm_free_lapic ( vcpu ) ; fail_mmu_destroy : kvm_mmu_destroy ( vcpu ) ; fail_free_pio_data : free_page ( ( unsigned long ) vcpu -> arch . pio_data ) ; fail : return r ; }\n","target":"<S2SV_ModStart> = 0x0 ; vcpu -> arch . pv_time_enabled = false ;\n","project_and_commit_id":"torvalds@linux/0b79459b482e85cb7426aa7da683a9f2c97aeae1","cve_id":"CVE-2013-1797","original_address":"https://github.com/torvalds/linux/commit/0b79459b482e85cb7426aa7da683a9f2c97aeae1","time":"2013-03-22T11:59Z"},
	{"Unnamed: 0":1849,"cwe_id":"CWE-20","source":"CWE-20 int vp9_alloc_context_buffers ( VP9_COMMON * cm , int width , int height ) { int new_mi_size ; vp9_set_mb_mi ( cm , width , height ) ; new_mi_size = cm -> mi_stride * calc_mi_size ( cm -> mi_rows ) ; if ( cm -> mi_alloc_size < new_mi_size ) { cm -> free_mi ( cm ) ; if ( cm -> alloc_mi ( cm , new_mi_size ) ) goto fail ; } if ( cm -> seg_map_alloc_size < cm -> mi_rows * cm -> mi_cols ) { free_seg_map ( cm ) ; if ( alloc_seg_map ( cm , cm -> mi_rows * cm -> mi_cols ) ) goto fail ; } if ( cm -> above_context_alloc_cols < cm -> mi_cols ) { vpx_free ( cm -> above_context ) ; cm -> above_context = ( ENTROPY_CONTEXT * ) vpx_calloc ( 2 * mi_cols_aligned_to_sb ( cm -> mi_cols ) * MAX_MB_PLANE , sizeof ( * cm -> above_context ) ) ; if ( ! cm -> above_context ) goto fail ; vpx_free ( cm -> above_seg_context ) ; cm -> above_seg_context = ( PARTITION_CONTEXT * ) vpx_calloc ( mi_cols_aligned_to_sb ( cm -> mi_cols ) , sizeof ( * cm -> above_seg_context ) ) ; if ( ! cm -> above_seg_context ) goto fail ; cm -> above_context_alloc_cols = cm -> mi_cols ; } return 0 ; fail : <S2SV_StartBug> vp9_free_context_buffers ( cm ) ; <S2SV_EndBug> return 1 ; }\n","target":"<S2SV_ModStart> ; fail : vp9_set_mb_mi ( cm , 0 , 0 ) ;\n","project_and_commit_id":"external@libvpx/fdb1b40e7bb147c07bda988c9501ad223795d12d","cve_id":"CVE-2016-6712","original_address":"https://android.googlesource.com/platform/external/libvpx/+/fdb1b40e7bb147c07bda988c9501ad223795d12d","time":"2016-12-13T19:59Z"},
	{"Unnamed: 0":5578,"cwe_id":"CWE-119","source":"CWE-119 void ih264d_rest_of_residual_cav_chroma_dc_block ( UWORD32 u4_total_coeff_trail_one , dec_bit_stream_t * ps_bitstrm ) { UWORD32 u4_total_zeroes ; WORD16 i ; UWORD32 * pu4_bitstrm_buf = ps_bitstrm -> pu4_buffer ; UWORD32 u4_bitstream_offset = ps_bitstrm -> u4_ofst ; UWORD32 u4_trailing_ones = u4_total_coeff_trail_one & 0xFFFF ; UWORD32 u4_total_coeff = u4_total_coeff_trail_one >> 16 ; <S2SV_StartBug> WORD16 i2_level_arr [ 4 ] ; <S2SV_EndBug> tu_sblk4x4_coeff_data_t * ps_tu_4x4 ; WORD16 * pi2_coeff_data ; dec_struct_t * ps_dec = ( dec_struct_t * ) ps_bitstrm -> pv_codec_handle ; ps_tu_4x4 = ( tu_sblk4x4_coeff_data_t * ) ps_dec -> pv_parse_tu_coeff_data ; ps_tu_4x4 -> u2_sig_coeff_map = 0 ; pi2_coeff_data = & ps_tu_4x4 -> ai2_level [ 0 ] ; i = u4_total_coeff - 1 ; if ( u4_trailing_ones ) { UWORD32 u4_signs , u4_cnt = u4_trailing_ones ; WORD16 ( * ppi2_trlone_lkup ) [ 3 ] = ( WORD16 ( * ) [ 3 ] ) gai2_ih264d_trailing_one_level ; WORD16 * pi2_trlone_lkup ; GETBITS ( u4_signs , u4_bitstream_offset , pu4_bitstrm_buf , u4_cnt ) ; pi2_trlone_lkup = ppi2_trlone_lkup [ ( 1 << u4_cnt ) - 2 + u4_signs ] ; while ( u4_cnt -- ) i2_level_arr [ i -- ] = * pi2_trlone_lkup ++ ; } if ( i >= 0 ) { UWORD32 u4_lev_suffix , u4_suffix_len , u4_lev_suffix_size ; UWORD16 u2_lev_code , u2_abs_value ; UWORD32 u4_lev_prefix ; FIND_ONE_IN_STREAM_32 ( u4_lev_prefix , u4_bitstream_offset , pu4_bitstrm_buf ) ; u2_lev_code = MIN ( 15 , u4_lev_prefix ) ; u2_lev_code += ( 3 == u4_trailing_ones ) ? 0 : ( 2 ) ; if ( 14 == u4_lev_prefix ) u4_lev_suffix_size = 4 ; else if ( 15 <= u4_lev_prefix ) { u2_lev_code += 15 ; u4_lev_suffix_size = u4_lev_prefix - 3 ; } else u4_lev_suffix_size = 0 ; if ( 16 <= u4_lev_prefix ) { u2_lev_code += ( ( 1 << ( u4_lev_prefix - 3 ) ) - 4096 ) ; } if ( u4_lev_suffix_size ) { GETBITS ( u4_lev_suffix , u4_bitstream_offset , pu4_bitstrm_buf , u4_lev_suffix_size ) ; u2_lev_code += u4_lev_suffix ; } u2_abs_value = ( u2_lev_code + 2 ) >> 1 ; i2_level_arr [ i -- ] = ( u2_lev_code & 1 ) ? - u2_abs_value : u2_abs_value ; u4_suffix_len = ( u2_abs_value > 3 ) ? 2 : 1 ; while ( i >= 0 ) { FIND_ONE_IN_STREAM_32 ( u4_lev_prefix , u4_bitstream_offset , pu4_bitstrm_buf ) ; u4_lev_suffix_size = ( 15 <= u4_lev_prefix ) ? ( u4_lev_prefix - 3 ) : u4_suffix_len ; GETBITS ( u4_lev_suffix , u4_bitstream_offset , pu4_bitstrm_buf , u4_lev_suffix_size ) ; u2_lev_code = ( MIN ( u4_lev_prefix , 15 ) << u4_suffix_len ) + u4_lev_suffix ; if ( 16 <= u4_lev_prefix ) { u2_lev_code += ( ( 1 << ( u4_lev_prefix - 3 ) ) - 4096 ) ; } u2_abs_value = ( u2_lev_code + 2 ) >> 1 ; i2_level_arr [ i -- ] = ( u2_lev_code & 1 ) ? - u2_abs_value : u2_abs_value ; u4_suffix_len += ( u2_abs_value > ( 3 << ( u4_suffix_len - 1 ) ) ) ; } } if ( u4_total_coeff < 4 ) { UWORD32 u4_max_ldz = ( 4 - u4_total_coeff ) ; FIND_ONE_IN_STREAM_LEN ( u4_total_zeroes , u4_bitstream_offset , pu4_bitstrm_buf , u4_max_ldz ) ; } else u4_total_zeroes = 0 ; { const UWORD8 * pu1_table_runbefore ; UWORD32 u4_run ; UWORD32 u4_scan_pos = ( u4_total_coeff + u4_total_zeroes - 1 ) ; UWORD32 u4_zeroes_left = u4_total_zeroes ; i = u4_total_coeff - 1 ; pu1_table_runbefore = ( UWORD8 * ) gau1_ih264d_table_run_before ; while ( u4_zeroes_left && i ) { UWORD32 u4_code ; NEXTBITS ( u4_code , u4_bitstream_offset , pu4_bitstrm_buf , 3 ) ; u4_code = pu1_table_runbefore [ u4_code + ( u4_zeroes_left << 3 ) ] ; u4_run = u4_code >> 2 ; FLUSHBITS ( u4_bitstream_offset , ( u4_code & 0x03 ) ) ; SET_BIT ( ps_tu_4x4 -> u2_sig_coeff_map , u4_scan_pos ) ; * pi2_coeff_data ++ = i2_level_arr [ i -- ] ; u4_zeroes_left -= u4_run ; u4_scan_pos -= ( u4_run + 1 ) ; } while ( i >= 0 ) { SET_BIT ( ps_tu_4x4 -> u2_sig_coeff_map , u4_scan_pos ) ; * pi2_coeff_data ++ = i2_level_arr [ i -- ] ; u4_scan_pos -- ; } } { WORD32 offset ; offset = ( UWORD8 * ) pi2_coeff_data - ( UWORD8 * ) ps_tu_4x4 ; offset = ALIGN4 ( offset ) ; ps_dec -> pv_parse_tu_coeff_data = ( void * ) ( ( UWORD8 * ) ps_dec -> pv_parse_tu_coeff_data + offset ) ; } ps_bitstrm -> u4_ofst = u4_bitstream_offset ; }\n","target":"<S2SV_ModStart> 16 ; WORD16 ai2_level_arr [ 7 ] ; WORD16 * i2_level_arr = & ai2_level_arr [ 3 <S2SV_ModEnd> ] ; tu_sblk4x4_coeff_data_t\n","project_and_commit_id":"external@libavc/c57fc3703ae2e0d41b1f6580c50015937f2d23c1","cve_id":"CVE-2016-0840","original_address":"https://android.googlesource.com/platform/external/libavc/+/c57fc3703ae2e0d41b1f6580c50015937f2d23c1","time":"2016-04-18T00:59Z"},
	{"Unnamed: 0":4604,"cwe_id":"CWE-119","source":"CWE-119 cJSON * cJSON_CreateTrue ( void ) { cJSON * item = cJSON_New_Item ( ) ; if ( item ) item -> type = cJSON_True ; return item ; }\n","target":"\n","project_and_commit_id":"esnet@iperf/91f2fa59e8ed80dfbf400add0164ee0e508e412a","cve_id":"CVE-2016-4303","original_address":"https://github.com/esnet/iperf/commit/91f2fa59e8ed80dfbf400add0164ee0e508e412a","time":"2016-09-26T14:59Z"},
	{"Unnamed: 0":3401,"cwe_id":"CWE-200","source":"CWE-200 IMPEG2D_ERROR_CODES_T impeg2d_init_video_state ( dec_state_t * ps_dec , e_video_type_t e_video_type ) { if ( e_video_type == MPEG_1_VIDEO ) { ps_dec -> u2_is_mpeg2 = 0 ; ps_dec -> u2_progressive_sequence = 1 ; ps_dec -> u2_intra_dc_precision = 0 ; ps_dec -> u2_picture_structure = FRAME_PICTURE ; ps_dec -> u2_frame_pred_frame_dct = 1 ; ps_dec -> u2_concealment_motion_vectors = 0 ; ps_dec -> u2_q_scale_type = 0 ; ps_dec -> u2_intra_vlc_format = 0 ; ps_dec -> u2_alternate_scan = 0 ; ps_dec -> u2_repeat_first_field = 0 ; ps_dec -> u2_progressive_frame = 1 ; ps_dec -> u2_frame_rate_extension_n = 0 ; ps_dec -> u2_frame_rate_extension_d = 0 ; <S2SV_StartBug> ps_dec -> pf_vld_inv_quant = impeg2d_vld_inv_quant_mpeg1 ; <S2SV_EndBug> } else { ps_dec -> u2_is_mpeg2 = 1 ; ps_dec -> u2_full_pel_forw_vector = 0 ; ps_dec -> u2_forw_f_code = 7 ; ps_dec -> u2_full_pel_back_vector = 0 ; ps_dec -> u2_back_f_code = 7 ; ps_dec -> pf_vld_inv_quant = impeg2d_vld_inv_quant_mpeg2 ; } impeg2d_init_function_ptr ( ps_dec ) ; ps_dec -> u2_frame_height = ALIGN16 ( ps_dec -> u2_vertical_size ) ; ps_dec -> u2_frame_width = ALIGN16 ( ps_dec -> u2_horizontal_size ) ; ps_dec -> u2_num_horiz_mb = ( ps_dec -> u2_horizontal_size + 15 ) >> 4 ; if ( ps_dec -> u2_frame_height > ps_dec -> u2_create_max_height || ps_dec -> u2_frame_width > ps_dec -> u2_create_max_width ) { return IMPEG2D_PIC_SIZE_NOT_SUPPORTED ; } ps_dec -> u2_num_flds_decoded = 0 ; { UWORD32 numer ; UWORD32 denom ; numer = ( UWORD32 ) gau2_impeg2_frm_rate_code [ ps_dec -> u2_frame_rate_code ] [ 1 ] * ( UWORD32 ) ( ps_dec -> u2_frame_rate_extension_d + 1 ) ; denom = ( UWORD32 ) gau2_impeg2_frm_rate_code [ ps_dec -> u2_frame_rate_code ] [ 0 ] * ( UWORD32 ) ( ps_dec -> u2_frame_rate_extension_n + 1 ) ; ps_dec -> u2_framePeriod = ( numer * 1000 * 100 ) / denom ; } if ( VERTICAL_SCAN == ps_dec -> u2_alternate_scan ) { ps_dec -> pu1_inv_scan_matrix = ( UWORD8 * ) gau1_impeg2_inv_scan_vertical ; } else { ps_dec -> pu1_inv_scan_matrix = ( UWORD8 * ) gau1_impeg2_inv_scan_zig_zag ; } return ( IMPEG2D_ERROR_CODES_T ) IVD_ERROR_NONE ; }\n","target":"<S2SV_ModStart> ; ps_dec -> u2_forw_f_code = 7 ; ps_dec -> u2_back_f_code = 7 ; ps_dec ->\n","project_and_commit_id":"external@libmpeg2/29a78a11844fc027fa44be7f8bd8dc1cf8bf89f6","cve_id":"CVE-2017-13205","original_address":"https://android.googlesource.com/platform/external/libmpeg2/+/29a78a11844fc027fa44be7f8bd8dc1cf8bf89f6","time":"2018-01-12T23:29Z"},
	{"Unnamed: 0":3121,"cwe_id":"CWE-119","source":"CWE-119 static void output_stats ( FIRSTPASS_STATS * stats , struct vpx_codec_pkt_list * pktlist ) { struct vpx_codec_cx_pkt pkt ; pkt . kind = VPX_CODEC_STATS_PKT ; pkt . data . twopass_stats . buf = stats ; pkt . data . twopass_stats . sz = sizeof ( FIRSTPASS_STATS ) ; vpx_codec_pkt_list_add ( pktlist , & pkt ) ; # if OUTPUT_FPF { FILE * fpfile ; fpfile = fopen ( \"firstpass.stt\" , \"a\" ) ; <S2SV_StartBug> fprintf ( fpfile , \"%12.0f<S2SV_blank>%12.0f<S2SV_blank>%12.0f<S2SV_blank>%12.0f<S2SV_blank>%12.0f<S2SV_blank>%12.4f<S2SV_blank>%12.4f\" <S2SV_EndBug> \"%12.4f<S2SV_blank>%12.4f<S2SV_blank>%12.4f<S2SV_blank>%12.4f<S2SV_blank>%12.4f<S2SV_blank>%12.4f<S2SV_blank>%12.4f\" \"%12.0f<S2SV_blank>%12.0f<S2SV_blank>%12.4f<S2SV_blank>%12.0f<S2SV_blank>%12.0f<S2SV_blank>%12.4f\\\\n\" , stats -> frame , <S2SV_StartBug> stats -> intra_error , <S2SV_EndBug> stats -> coded_error , stats -> sr_coded_error , <S2SV_StartBug> stats -> ssim_weighted_pred_err , <S2SV_EndBug> stats -> pcnt_inter , stats -> pcnt_motion , stats -> pcnt_second_ref , <S2SV_StartBug> stats -> pcnt_neutral , <S2SV_EndBug> stats -> MVr , stats -> mvr_abs , stats -> MVc , stats -> mvc_abs , stats -> MVrv , stats -> MVcv , stats -> mv_in_out_count , stats -> new_mv_count , stats -> count , stats -> duration ) ; fclose ( fpfile ) ; } # endif }\n","target":"<S2SV_ModStart> ( fpfile , \"%12.0lf<S2SV_blank>%12.4lf<S2SV_blank>%12.0lf<S2SV_blank>%12.0lf<S2SV_blank>%12.0lf<S2SV_blank>%12.4lf<S2SV_blank>%12.4lf\" \"%12.4lf<S2SV_blank>%12.4lf<S2SV_blank>%12.4lf<S2SV_blank>%12.4lf<S2SV_blank>%12.4lf<S2SV_blank>%12.4lf<S2SV_blank>%12.4lf<S2SV_blank>%12.4lf\" \"%12.4lf<S2SV_blank>%12.4lf<S2SV_blank>%12.0lf<S2SV_blank>%12.0lf<S2SV_blank>%12.0lf<S2SV_blank>%12.4lf\\\\n\" <S2SV_ModEnd> , stats -> <S2SV_ModStart> , stats -> weight , stats -> <S2SV_ModStart> , stats -> <S2SV_ModEnd> pcnt_inter , stats <S2SV_ModStart> stats -> pcnt_neutral , stats -> intra_skip_pct , stats -> inactive_zone_rows , stats -> inactive_zone_cols\n","project_and_commit_id":"external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426","cve_id":"CVE-2016-1621","original_address":"https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426","time":"2016-03-12T21:59Z"},
	{"Unnamed: 0":2265,"cwe_id":"CWE-200","source":"CWE-200 static int l2cap_sock_getname ( struct socket * sock , struct sockaddr * addr , int * len , int peer ) { struct sockaddr_l2 * la = ( struct sockaddr_l2 * ) addr ; struct sock * sk = sock -> sk ; struct l2cap_chan * chan = l2cap_pi ( sk ) -> chan ; <S2SV_StartBug> BT_DBG ( \"sock<S2SV_blank>%p,<S2SV_blank>sk<S2SV_blank>%p\" , sock , sk ) ; <S2SV_EndBug> addr -> sa_family = AF_BLUETOOTH ; * len = sizeof ( struct sockaddr_l2 ) ; if ( peer ) { la -> l2_psm = chan -> psm ; bacpy ( & la -> l2_bdaddr , & bt_sk ( sk ) -> dst ) ; la -> l2_cid = cpu_to_le16 ( chan -> dcid ) ; } else { la -> l2_psm = chan -> sport ; bacpy ( & la -> l2_bdaddr , & bt_sk ( sk ) -> src ) ; la -> l2_cid = cpu_to_le16 ( chan -> scid ) ; } return 0 ; }\n","target":"<S2SV_ModStart> sock , sk ) ; memset ( la , 0 , sizeof ( struct sockaddr_l2 )\n","project_and_commit_id":"torvalds@linux/792039c73cf176c8e39a6e8beef2c94ff46522ed","cve_id":"CVE-2012-6544","original_address":"https://github.com/torvalds/linux/commit/792039c73cf176c8e39a6e8beef2c94ff46522ed","time":"2013-03-15T20:55Z"},
	{"Unnamed: 0":3186,"cwe_id":"CWE-476","source":"CWE-476 static unsigned int seedsize ( struct crypto_alg * alg ) { struct rng_alg * ralg = container_of ( alg , struct rng_alg , base ) ; <S2SV_StartBug> return alg -> cra_rng . rng_make_random ? <S2SV_EndBug> alg -> cra_rng . seedsize : ralg -> seedsize ; }\n","target":"<S2SV_ModStart> ) ; return <S2SV_ModEnd> ralg -> seedsize\n","project_and_commit_id":"torvalds@linux/94f1bb15bed84ad6c893916b7e7b9db6f1d7eec6","cve_id":"CVE-2017-15116","original_address":"https://github.com/torvalds/linux/commit/94f1bb15bed84ad6c893916b7e7b9db6f1d7eec6","time":"2017-11-30T18:29Z"},
	{"Unnamed: 0":5785,"cwe_id":"CWE-20","source":"CWE-20 static int nfs_can_extend_write ( struct file * file , struct page * page , struct inode * inode ) { if ( file -> f_flags & O_DSYNC ) return 0 ; <S2SV_StartBug> if ( NFS_PROTO ( inode ) -> have_delegation ( inode , FMODE_WRITE ) ) <S2SV_EndBug> return 1 ; <S2SV_StartBug> if ( nfs_write_pageuptodate ( page , inode ) && ( inode -> i_flock == NULL || <S2SV_EndBug> ( inode -> i_flock -> fl_start == 0 && inode -> i_flock -> fl_end == OFFSET_MAX && <S2SV_StartBug> inode -> i_flock -> fl_type != F_RDLCK ) ) ) <S2SV_EndBug> return 1 ; return 0 ; }\n","target":"<S2SV_ModStart> ; if ( ! nfs_write_pageuptodate ( page , inode ) ) return 0 ; if ( <S2SV_ModStart> ; if ( <S2SV_ModEnd> inode -> i_flock <S2SV_ModStart> F_RDLCK ) ) <S2SV_ModEnd> return 1 ;\n","project_and_commit_id":"torvalds@linux/263b4509ec4d47e0da3e753f85a39ea12d1eff24","cve_id":"CVE-2014-2038","original_address":"https://github.com/torvalds/linux/commit/263b4509ec4d47e0da3e753f85a39ea12d1eff24","time":"2014-02-28T06:18Z"},
	{"Unnamed: 0":6356,"cwe_id":"CWE-17","source":"CWE-17 void fput ( struct file * file ) { if ( atomic_long_dec_and_test ( & file -> f_count ) ) { <S2SV_StartBug> struct task_struct * task = current ; <S2SV_EndBug> file_sb_list_del ( file ) ; if ( likely ( ! in_interrupt ( ) && ! ( task -> flags & PF_KTHREAD ) ) ) { init_task_work ( & file -> f_u . fu_rcuhead , ____fput ) ; if ( ! task_work_add ( task , & file -> f_u . fu_rcuhead , true ) ) return ; } if ( llist_add ( & file -> f_u . fu_llist , & delayed_fput_list ) ) schedule_work ( & delayed_fput_work ) ; } }\n","target":"<S2SV_ModStart> task = current <S2SV_ModEnd> ; if (\n","project_and_commit_id":"torvalds@linux/eee5cc2702929fd41cce28058dc6d6717f723f87","cve_id":"CVE-2014-8172","original_address":"https://github.com/torvalds/linux/commit/eee5cc2702929fd41cce28058dc6d6717f723f87","time":"2015-03-16T10:59Z"},
	{"Unnamed: 0":5527,"cwe_id":"CWE-264","source":"CWE-264 static int em_ret_far ( struct x86_emulate_ctxt * ctxt ) { int rc ; <S2SV_StartBug> unsigned long cs ; <S2SV_EndBug> int cpl = ctxt -> ops -> cpl ( ctxt ) ; <S2SV_StartBug> rc = emulate_pop ( ctxt , & ctxt -> _eip , ctxt -> op_bytes ) ; <S2SV_EndBug> if ( rc != X86EMUL_CONTINUE ) <S2SV_StartBug> return rc ; <S2SV_EndBug> if ( ctxt -> op_bytes == 4 ) ctxt -> _eip = ( u32 ) ctxt -> _eip ; rc = emulate_pop ( ctxt , & cs , ctxt -> op_bytes ) ; if ( rc != X86EMUL_CONTINUE ) return rc ; if ( ctxt -> mode >= X86EMUL_MODE_PROT16 && ( cs & 3 ) > cpl ) return X86EMUL_UNHANDLEABLE ; <S2SV_StartBug> rc = load_segment_descriptor ( ctxt , ( u16 ) cs , VCPU_SREG_CS ) ; <S2SV_EndBug> return rc ; }\n","target":"<S2SV_ModStart> ; unsigned long eip , cs ; u16 old_cs <S2SV_ModEnd> ; int cpl <S2SV_ModStart> ctxt ) ; struct desc_struct old_desc , new_desc ; const struct x86_emulate_ops * ops = ctxt -> ops ; if ( ctxt -> mode == X86EMUL_MODE_PROT64 ) ops -> get_segment ( ctxt , & old_cs , & old_desc , NULL , VCPU_SREG_CS ) ; <S2SV_ModStart> ctxt , & eip <S2SV_ModEnd> , ctxt -> <S2SV_ModStart> ) return rc <S2SV_ModEnd> ; rc = <S2SV_ModStart> ; rc = __load_segment_descriptor <S2SV_ModEnd> ( ctxt , <S2SV_ModStart> cs , VCPU_SREG_CS , 0 , false , & new_desc ) ; if ( rc != X86EMUL_CONTINUE ) return rc ; rc = assign_eip_far ( ctxt , eip , new_desc . l ) ; if ( rc != X86EMUL_CONTINUE ) { WARN_ON ( ! ctxt -> mode != X86EMUL_MODE_PROT64 ) ; ops -> set_segment ( ctxt , old_cs , & old_desc , 0 , VCPU_SREG_CS ) ; } <S2SV_ModEnd> return rc ;\n","project_and_commit_id":"torvalds@linux/d1442d85cc30ea75f7d399474ca738e0bc96f715","cve_id":"CVE-2014-3647","original_address":"https://github.com/torvalds/linux/commit/d1442d85cc30ea75f7d399474ca738e0bc96f715","time":"2014-11-10T11:55Z"},
	{"Unnamed: 0":2716,"cwe_id":"CWE-125","source":"CWE-125 static struct phy * serdes_simple_xlate ( struct device * dev , struct of_phandle_args * args ) { struct serdes_ctrl * ctrl = dev_get_drvdata ( dev ) ; unsigned int port , idx , i ; if ( args -> args_count != 2 ) return ERR_PTR ( - EINVAL ) ; port = args -> args [ 0 ] ; idx = args -> args [ 1 ] ; <S2SV_StartBug> for ( i = 0 ; i <= SERDES_MAX ; i ++ ) { <S2SV_EndBug> struct serdes_macro * macro = phy_get_drvdata ( ctrl -> phys [ i ] ) ; if ( idx != macro -> idx ) continue ; if ( idx != SERDES6G ( 0 ) && macro -> port >= 0 ) return ERR_PTR ( - EBUSY ) ; macro -> port = port ; return ctrl -> phys [ i ] ; } return ERR_PTR ( - ENODEV ) ; }\n","target":"<S2SV_ModStart> 0 ; i < <S2SV_ModEnd> SERDES_MAX ; i\n","project_and_commit_id":"torvalds@linux/6acb47d1a318e5b3b7115354ebc4ea060c59d3a1","cve_id":"CVE-2018-20854","original_address":"https://github.com/torvalds/linux/commit/6acb47d1a318e5b3b7115354ebc4ea060c59d3a1","time":"2019-07-26T05:15Z"},
	{"Unnamed: 0":4545,"cwe_id":"CWE-119","source":"CWE-119 static int DecodeNumberField ( int len , char * str , int fmask , int * tmask , struct tm * tm , fsec_t * fsec , int * is2digits ) { char * cp ; if ( ( cp = strchr ( str , '.' ) ) != NULL ) { # ifdef HAVE_INT64_TIMESTAMP <S2SV_StartBug> char fstr [ MAXDATELEN + 1 ] ; <S2SV_EndBug> strcpy ( fstr , ( cp + 1 ) ) ; strcpy ( fstr + strlen ( fstr ) , \"000000\" ) ; * ( fstr + 6 ) = '\\\\0' ; * fsec = strtol ( fstr , NULL , 10 ) ; # else * fsec = strtod ( cp , NULL ) ; # endif * cp = '\\\\0' ; len = strlen ( str ) ; } else if ( ( fmask & DTK_DATE_M ) != DTK_DATE_M ) { if ( len == 8 ) { * tmask = DTK_DATE_M ; tm -> tm_mday = atoi ( str + 6 ) ; * ( str + 6 ) = '\\\\0' ; tm -> tm_mon = atoi ( str + 4 ) ; * ( str + 4 ) = '\\\\0' ; tm -> tm_year = atoi ( str + 0 ) ; return DTK_DATE ; } else if ( len == 6 ) { * tmask = DTK_DATE_M ; tm -> tm_mday = atoi ( str + 4 ) ; * ( str + 4 ) = '\\\\0' ; tm -> tm_mon = atoi ( str + 2 ) ; * ( str + 2 ) = '\\\\0' ; tm -> tm_year = atoi ( str + 0 ) ; * is2digits = TRUE ; return DTK_DATE ; } else if ( len == 5 ) { * tmask = DTK_DATE_M ; tm -> tm_mday = atoi ( str + 2 ) ; * ( str + 2 ) = '\\\\0' ; tm -> tm_mon = 1 ; tm -> tm_year = atoi ( str + 0 ) ; * is2digits = TRUE ; return DTK_DATE ; } } if ( ( fmask & DTK_TIME_M ) != DTK_TIME_M ) { if ( len == 6 ) { * tmask = DTK_TIME_M ; tm -> tm_sec = atoi ( str + 4 ) ; * ( str + 4 ) = '\\\\0' ; tm -> tm_min = atoi ( str + 2 ) ; * ( str + 2 ) = '\\\\0' ; tm -> tm_hour = atoi ( str + 0 ) ; return DTK_TIME ; } else if ( len == 4 ) { * tmask = DTK_TIME_M ; tm -> tm_sec = 0 ; tm -> tm_min = atoi ( str + 2 ) ; * ( str + 2 ) = '\\\\0' ; tm -> tm_hour = atoi ( str + 0 ) ; return DTK_TIME ; } } return - 1 ; }\n","target":"<S2SV_ModStart> char fstr [ 7 ] ; int i ; cp ++ ; for ( i = 0 ; i < 6 ; i ++ ) fstr [ i ] = * cp != '\\\\0' ? * cp ++ : '0' ; fstr [ i ] <S2SV_ModEnd> = '\\\\0' ;\n","project_and_commit_id":"postgres@postgres/4318daecc959886d001a6e79c6ea853e8b1dfb4b","cve_id":"CVE-2014-0063","original_address":"https://github.com/postgres/postgres/commit/4318daecc959886d001a6e79c6ea853e8b1dfb4b","time":"2014-03-31T14:58Z"},
	{"Unnamed: 0":1834,"cwe_id":"CWE-254","source":"CWE-254 static inline int handle_dots ( struct nameidata * nd , int type ) { if ( type == LAST_DOTDOT ) { if ( nd -> flags & LOOKUP_RCU ) { return follow_dotdot_rcu ( nd ) ; } else <S2SV_StartBug> follow_dotdot ( nd ) ; <S2SV_EndBug> } return 0 ; }\n","target":"<S2SV_ModStart> ; } else return\n","project_and_commit_id":"torvalds@linux/397d425dc26da728396e66d392d5dcb8dac30c37","cve_id":"CVE-2015-2925","original_address":"https://github.com/torvalds/linux/commit/397d425dc26da728396e66d392d5dcb8dac30c37","time":"2015-11-16T11:59Z"},
	{"Unnamed: 0":3243,"cwe_id":"CWE-119","source":"CWE-119 <S2SV_StartBug> static INLINE void read_mv ( vp9_reader * r , MV * mv , const MV * ref , <S2SV_EndBug> const nmv_context * ctx , nmv_context_counts * counts , int allow_hp ) { const MV_JOINT_TYPE joint_type = <S2SV_StartBug> ( MV_JOINT_TYPE ) vp9_read_tree ( r , vp9_mv_joint_tree , ctx -> joints ) ; <S2SV_EndBug> const int use_hp = allow_hp && vp9_use_mv_hp ( ref ) ; MV diff = { 0 , 0 } ; if ( mv_joint_vertical ( joint_type ) ) diff . row = read_mv_component ( r , & ctx -> comps [ 0 ] , use_hp ) ; if ( mv_joint_horizontal ( joint_type ) ) diff . col = read_mv_component ( r , & ctx -> comps [ 1 ] , use_hp ) ; vp9_inc_mv ( & diff , counts ) ; mv -> row = ref -> row + diff . row ; mv -> col = ref -> col + diff . col ; }\n","target":"<S2SV_ModStart> void read_mv ( vpx_reader <S2SV_ModEnd> * r , <S2SV_ModStart> ( MV_JOINT_TYPE ) vpx_read_tree <S2SV_ModEnd> ( r ,\n","project_and_commit_id":"external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426","cve_id":"CVE-2016-1621","original_address":"https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426","time":"2016-03-12T21:59Z"},
	{"Unnamed: 0":2353,"cwe_id":"CWE-362","source":"CWE-362 static int snd_ctl_elem_user_put ( struct snd_kcontrol * kcontrol , struct snd_ctl_elem_value * ucontrol ) { int change ; <S2SV_StartBug> struct user_element * ue = kcontrol -> private_data ; <S2SV_EndBug> change = memcmp ( & ucontrol -> value , ue -> elem_data , ue -> elem_data_size ) != 0 ; if ( change ) memcpy ( ue -> elem_data , & ucontrol -> value , ue -> elem_data_size ) ; <S2SV_StartBug> return change ; <S2SV_EndBug> }\n","target":"<S2SV_ModStart> kcontrol -> private_data ; mutex_lock ( & ue -> card -> user_ctl_lock ) <S2SV_ModStart> elem_data_size ) ; mutex_unlock ( & ue -> card -> user_ctl_lock ) ;\n","project_and_commit_id":"torvalds@linux/07f4d9d74a04aa7c72c5dae0ef97565f28f17b92","cve_id":"CVE-2014-4652","original_address":"https://github.com/torvalds/linux/commit/07f4d9d74a04aa7c72c5dae0ef97565f28f17b92","time":"2014-07-03T04:22Z"},
	{"Unnamed: 0":4811,"cwe_id":"CWE-264","source":"CWE-264 int generic_permission ( struct inode * inode , int mask ) { int ret ; ret = acl_permission_check ( inode , mask ) ; if ( ret != - EACCES ) return ret ; if ( S_ISDIR ( inode -> i_mode ) ) { <S2SV_StartBug> if ( inode_capable ( inode , CAP_DAC_OVERRIDE ) ) <S2SV_EndBug> return 0 ; if ( ! ( mask & MAY_WRITE ) ) <S2SV_StartBug> if ( inode_capable ( inode , CAP_DAC_READ_SEARCH ) ) <S2SV_EndBug> return 0 ; return - EACCES ; } if ( ! ( mask & MAY_EXEC ) || ( inode -> i_mode & S_IXUGO ) ) <S2SV_StartBug> if ( inode_capable ( inode , CAP_DAC_OVERRIDE ) ) <S2SV_EndBug> return 0 ; mask &= MAY_READ | MAY_WRITE | MAY_EXEC ; if ( mask == MAY_READ ) <S2SV_StartBug> if ( inode_capable ( inode , CAP_DAC_READ_SEARCH ) ) <S2SV_EndBug> return 0 ; return - EACCES ; }\n","target":"<S2SV_ModStart> { if ( capable_wrt_inode_uidgid <S2SV_ModEnd> ( inode , <S2SV_ModStart> ) if ( capable_wrt_inode_uidgid <S2SV_ModEnd> ( inode , <S2SV_ModStart> ) if ( capable_wrt_inode_uidgid <S2SV_ModEnd> ( inode , <S2SV_ModStart> ) if ( capable_wrt_inode_uidgid <S2SV_ModEnd> ( inode ,\n","project_and_commit_id":"torvalds@linux/23adbe12ef7d3d4195e80800ab36b37bee28cd03","cve_id":"CVE-2014-4014","original_address":"https://github.com/torvalds/linux/commit/23adbe12ef7d3d4195e80800ab36b37bee28cd03","time":"2014-06-23T11:21Z"},
	{"Unnamed: 0":1123,"cwe_id":"CWE-119","source":"CWE-119 static __u8 * lg_report_fixup ( struct hid_device * hdev , __u8 * rdesc , unsigned int * rsize ) { struct lg_drv_data * drv_data = hid_get_drvdata ( hdev ) ; struct usb_device_descriptor * udesc ; __u16 bcdDevice , rev_maj , rev_min ; <S2SV_StartBug> if ( ( drv_data -> quirks & LG_RDESC ) && * rsize >= 90 && rdesc [ 83 ] == 0x26 && <S2SV_EndBug> rdesc [ 84 ] == 0x8c && rdesc [ 85 ] == 0x02 ) { hid_info ( hdev , \"fixing<S2SV_blank>up<S2SV_blank>Logitech<S2SV_blank>keyboard<S2SV_blank>report<S2SV_blank>descriptor\\\\n\" ) ; rdesc [ 84 ] = rdesc [ 89 ] = 0x4d ; rdesc [ 85 ] = rdesc [ 90 ] = 0x10 ; } <S2SV_StartBug> if ( ( drv_data -> quirks & LG_RDESC_REL_ABS ) && * rsize >= 50 && <S2SV_EndBug> rdesc [ 32 ] == 0x81 && rdesc [ 33 ] == 0x06 && rdesc [ 49 ] == 0x81 && rdesc [ 50 ] == 0x06 ) { hid_info ( hdev , \"fixing<S2SV_blank>up<S2SV_blank>rel/abs<S2SV_blank>in<S2SV_blank>Logitech<S2SV_blank>report<S2SV_blank>descriptor\\\\n\" ) ; rdesc [ 33 ] = rdesc [ 50 ] = 0x02 ; } switch ( hdev -> product ) { case USB_DEVICE_ID_LOGITECH_WHEEL : udesc = & ( hid_to_usb_dev ( hdev ) -> descriptor ) ; if ( ! udesc ) { hid_err ( hdev , \"NULL<S2SV_blank>USB<S2SV_blank>device<S2SV_blank>descriptor\\\\n\" ) ; break ; } bcdDevice = le16_to_cpu ( udesc -> bcdDevice ) ; rev_maj = bcdDevice >> 8 ; rev_min = bcdDevice & 0xff ; if ( rev_maj == 1 && rev_min == 2 && * rsize == DF_RDESC_ORIG_SIZE ) { hid_info ( hdev , \"fixing<S2SV_blank>up<S2SV_blank>Logitech<S2SV_blank>Driving<S2SV_blank>Force<S2SV_blank>report<S2SV_blank>descriptor\\\\n\" ) ; rdesc = df_rdesc_fixed ; * rsize = sizeof ( df_rdesc_fixed ) ; } break ; case USB_DEVICE_ID_LOGITECH_MOMO_WHEEL : if ( * rsize == MOMO_RDESC_ORIG_SIZE ) { hid_info ( hdev , \"fixing<S2SV_blank>up<S2SV_blank>Logitech<S2SV_blank>Momo<S2SV_blank>Force<S2SV_blank>(Red)<S2SV_blank>report<S2SV_blank>descriptor\\\\n\" ) ; rdesc = momo_rdesc_fixed ; * rsize = sizeof ( momo_rdesc_fixed ) ; } break ; case USB_DEVICE_ID_LOGITECH_MOMO_WHEEL2 : if ( * rsize == MOMO2_RDESC_ORIG_SIZE ) { hid_info ( hdev , \"fixing<S2SV_blank>up<S2SV_blank>Logitech<S2SV_blank>Momo<S2SV_blank>Racing<S2SV_blank>Force<S2SV_blank>(Black)<S2SV_blank>report<S2SV_blank>descriptor\\\\n\" ) ; rdesc = momo2_rdesc_fixed ; * rsize = sizeof ( momo2_rdesc_fixed ) ; } break ; case USB_DEVICE_ID_LOGITECH_VIBRATION_WHEEL : if ( * rsize == FV_RDESC_ORIG_SIZE ) { hid_info ( hdev , \"fixing<S2SV_blank>up<S2SV_blank>Logitech<S2SV_blank>Formula<S2SV_blank>Vibration<S2SV_blank>report<S2SV_blank>descriptor\\\\n\" ) ; rdesc = fv_rdesc_fixed ; * rsize = sizeof ( fv_rdesc_fixed ) ; } break ; case USB_DEVICE_ID_LOGITECH_DFP_WHEEL : if ( * rsize == DFP_RDESC_ORIG_SIZE ) { hid_info ( hdev , \"fixing<S2SV_blank>up<S2SV_blank>Logitech<S2SV_blank>Driving<S2SV_blank>Force<S2SV_blank>Pro<S2SV_blank>report<S2SV_blank>descriptor\\\\n\" ) ; rdesc = dfp_rdesc_fixed ; * rsize = sizeof ( dfp_rdesc_fixed ) ; } break ; case USB_DEVICE_ID_LOGITECH_WII_WHEEL : if ( * rsize >= 101 && rdesc [ 41 ] == 0x95 && rdesc [ 42 ] == 0x0B && rdesc [ 47 ] == 0x05 && rdesc [ 48 ] == 0x09 ) { hid_info ( hdev , \"fixing<S2SV_blank>up<S2SV_blank>Logitech<S2SV_blank>Speed<S2SV_blank>Force<S2SV_blank>Wireless<S2SV_blank>report<S2SV_blank>descriptor\\\\n\" ) ; rdesc [ 41 ] = 0x05 ; rdesc [ 42 ] = 0x09 ; rdesc [ 47 ] = 0x95 ; rdesc [ 48 ] = 0x0B ; } break ; } return rdesc ; }\n","target":"<S2SV_ModStart> * rsize >= 91 <S2SV_ModEnd> && rdesc [ <S2SV_ModStart> * rsize >= 51 <S2SV_ModEnd> && rdesc [\n","project_and_commit_id":"torvalds@linux/4ab25786c87eb20857bbb715c3ae34ec8fd6a214","cve_id":"CVE-2014-3184","original_address":"https://github.com/torvalds/linux/commit/4ab25786c87eb20857bbb715c3ae34ec8fd6a214","time":"2014-09-28T10:55Z"},
	{"Unnamed: 0":4719,"cwe_id":"CWE-119","source":"CWE-119 static int check_entry_size_and_hooks ( struct ipt_entry * e , struct xt_table_info * newinfo , const unsigned char * base , const unsigned char * limit , const unsigned int * hook_entries , const unsigned int * underflows , unsigned int valid_hooks ) { unsigned int h ; int err ; if ( ( unsigned long ) e % __alignof__ ( struct ipt_entry ) != 0 || <S2SV_StartBug> ( unsigned char * ) e + sizeof ( struct ipt_entry ) >= limit ) { <S2SV_EndBug> duprintf ( \"Bad<S2SV_blank>offset<S2SV_blank>%p\\\\n\" , e ) ; return - EINVAL ; } if ( e -> next_offset < sizeof ( struct ipt_entry ) + sizeof ( struct xt_entry_target ) ) { duprintf ( \"checking:<S2SV_blank>element<S2SV_blank>%p<S2SV_blank>size<S2SV_blank>%u\\\\n\" , e , e -> next_offset ) ; return - EINVAL ; } err = check_entry ( e ) ; if ( err ) return err ; for ( h = 0 ; h < NF_INET_NUMHOOKS ; h ++ ) { if ( ! ( valid_hooks & ( 1 << h ) ) ) continue ; if ( ( unsigned char * ) e - base == hook_entries [ h ] ) newinfo -> hook_entry [ h ] = hook_entries [ h ] ; if ( ( unsigned char * ) e - base == underflows [ h ] ) { if ( ! check_underflow ( e ) ) { pr_err ( \"Underflows<S2SV_blank>must<S2SV_blank>be<S2SV_blank>unconditional<S2SV_blank>and<S2SV_blank>\" \"use<S2SV_blank>the<S2SV_blank>STANDARD<S2SV_blank>target<S2SV_blank>with<S2SV_blank>\" \"ACCEPT/DROP\\\\n\" ) ; return - EINVAL ; } newinfo -> underflow [ h ] = underflows [ h ] ; } } e -> counters = ( ( struct xt_counters ) { 0 , 0 } ) ; e -> comefrom = 0 ; return 0 ; }\n","target":"<S2SV_ModStart> ipt_entry ) >= limit || ( unsigned char * ) e + e -> next_offset >\n","project_and_commit_id":"torvalds@linux/6e94e0cfb0887e4013b3b930fa6ab1fe6bb6ba91","cve_id":"CVE-2016-4998","original_address":"https://github.com/torvalds/linux/commit/6e94e0cfb0887e4013b3b930fa6ab1fe6bb6ba91","time":"2016-07-03T21:59Z"},
	{"Unnamed: 0":1111,"cwe_id":"CWE-119","source":"CWE-119 void vp8_reset_mb_tokens_context ( MACROBLOCKD * x ) { ENTROPY_CONTEXT * a_ctx = ( ( ENTROPY_CONTEXT * ) x -> above_context ) ; ENTROPY_CONTEXT * l_ctx = ( ( ENTROPY_CONTEXT * ) x -> left_context ) ; <S2SV_StartBug> vpx_memset ( a_ctx , 0 , sizeof ( ENTROPY_CONTEXT_PLANES ) - 1 ) ; <S2SV_EndBug> <S2SV_StartBug> vpx_memset ( l_ctx , 0 , sizeof ( ENTROPY_CONTEXT_PLANES ) - 1 ) ; <S2SV_EndBug> if ( ! x -> mode_info_context -> mbmi . is_4x4 ) { a_ctx [ 8 ] = l_ctx [ 8 ] = 0 ; } }\n","target":"<S2SV_ModStart> left_context ) ; memset <S2SV_ModEnd> ( a_ctx , <S2SV_ModStart> 1 ) ; memset <S2SV_ModEnd> ( l_ctx ,\n","project_and_commit_id":"external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426","cve_id":"CVE-2016-1621","original_address":"https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426","time":"2016-03-12T21:59Z"},
	{"Unnamed: 0":4994,"cwe_id":"CWE-125","source":"CWE-125 void mpls_print ( netdissect_options * ndo , const u_char * bp , u_int length ) { const u_char * p ; uint32_t label_entry ; uint16_t label_stack_depth = 0 ; enum mpls_packet_type pt = PT_UNKNOWN ; p = bp ; ND_PRINT ( ( ndo , \"MPLS\" ) ) ; do { ND_TCHECK2 ( * p , sizeof ( label_entry ) ) ; if ( length < sizeof ( label_entry ) ) { ND_PRINT ( ( ndo , \"[|MPLS],<S2SV_blank>length<S2SV_blank>%u\" , length ) ) ; return ; } label_entry = EXTRACT_32BITS ( p ) ; ND_PRINT ( ( ndo , \"%s(label<S2SV_blank>%u\" , ( label_stack_depth && ndo -> ndo_vflag ) ? \"\\\\n\\\\t\" : \"<S2SV_blank>\" , MPLS_LABEL ( label_entry ) ) ) ; label_stack_depth ++ ; if ( ndo -> ndo_vflag && MPLS_LABEL ( label_entry ) < sizeof ( mpls_labelname ) / sizeof ( mpls_labelname [ 0 ] ) ) ND_PRINT ( ( ndo , \"<S2SV_blank>(%s)\" , mpls_labelname [ MPLS_LABEL ( label_entry ) ] ) ) ; ND_PRINT ( ( ndo , \",<S2SV_blank>exp<S2SV_blank>%u\" , MPLS_EXP ( label_entry ) ) ) ; if ( MPLS_STACK ( label_entry ) ) ND_PRINT ( ( ndo , \",<S2SV_blank>[S]\" ) ) ; ND_PRINT ( ( ndo , \",<S2SV_blank>ttl<S2SV_blank>%u)\" , MPLS_TTL ( label_entry ) ) ) ; p += sizeof ( label_entry ) ; length -= sizeof ( label_entry ) ; } while ( ! MPLS_STACK ( label_entry ) ) ; switch ( MPLS_LABEL ( label_entry ) ) { case 0 : case 3 : pt = PT_IPV4 ; break ; case 2 : pt = PT_IPV6 ; break ; default : ND_TCHECK ( * p ) ; if ( length < 1 ) { return ; } switch ( * p ) { case 0x45 : case 0x46 : case 0x47 : case 0x48 : case 0x49 : case 0x4a : case 0x4b : case 0x4c : case 0x4d : case 0x4e : case 0x4f : pt = PT_IPV4 ; break ; case 0x60 : case 0x61 : case 0x62 : case 0x63 : case 0x64 : case 0x65 : case 0x66 : case 0x67 : case 0x68 : case 0x69 : case 0x6a : case 0x6b : case 0x6c : case 0x6d : case 0x6e : case 0x6f : pt = PT_IPV6 ; break ; case 0x81 : case 0x82 : case 0x83 : pt = PT_OSI ; break ; default : break ; } } if ( pt == PT_UNKNOWN ) { if ( ! ndo -> ndo_suppress_default_print ) ND_DEFAULTPRINT ( p , length ) ; return ; } ND_PRINT ( ( ndo , ndo -> ndo_vflag ? \"\\\\n\\\\t\" : \"<S2SV_blank>\" ) ) ; switch ( pt ) { case PT_IPV4 : ip_print ( ndo , p , length ) ; break ; case PT_IPV6 : ip6_print ( ndo , p , length ) ; break ; case PT_OSI : <S2SV_StartBug> isoclns_print ( ndo , p , length , length ) ; <S2SV_EndBug> break ; default : break ; } return ; trunc : ND_PRINT ( ( ndo , \"[|MPLS]\" ) ) ; }\n","target":"<S2SV_ModStart> p , length <S2SV_ModEnd> ) ; break\n","project_and_commit_id":"the-tcpdump-group@tcpdump/1dcd10aceabbc03bf571ea32b892c522cbe923de","cve_id":"CVE-2017-12897","original_address":"https://github.com/the-tcpdump-group/tcpdump/commit/1dcd10aceabbc03bf571ea32b892c522cbe923de","time":"2017-09-14T06:29Z"},
	{"Unnamed: 0":1033,"cwe_id":"CWE-125","source":"CWE-125 static void sycc422_to_rgb ( opj_image_t * img ) { int * d0 , * d1 , * d2 , * r , * g , * b ; const int * y , * cb , * cr ; <S2SV_StartBug> unsigned int maxw , maxh , max ; <S2SV_EndBug> int offset , upb ; <S2SV_StartBug> unsigned int i , j ; <S2SV_EndBug> upb = ( int ) img -> comps [ 0 ] . prec ; offset = 1 << ( upb - 1 ) ; upb = ( 1 << upb ) - 1 ; <S2SV_StartBug> maxw = ( unsigned int ) img -> comps [ 0 ] . w ; maxh = ( unsigned int ) img -> comps [ 0 ] . h ; <S2SV_EndBug> max = maxw * maxh ; y = img -> comps [ 0 ] . data ; cb = img -> comps [ 1 ] . data ; cr = img -> comps [ 2 ] . data ; <S2SV_StartBug> d0 = r = ( int * ) malloc ( sizeof ( int ) * ( size_t ) max ) ; <S2SV_EndBug> <S2SV_StartBug> d1 = g = ( int * ) malloc ( sizeof ( int ) * ( size_t ) max ) ; <S2SV_EndBug> <S2SV_StartBug> d2 = b = ( int * ) malloc ( sizeof ( int ) * ( size_t ) max ) ; <S2SV_EndBug> if ( r == NULL || g == NULL || b == NULL ) goto fails ; <S2SV_StartBug> for ( i = 0U ; i < maxh ; ++ i ) <S2SV_EndBug> { <S2SV_StartBug> for ( j = 0U ; j < ( maxw & ~ ( unsigned int ) 1U ) ; j += 2U ) <S2SV_EndBug> { sycc_to_rgb ( offset , upb , * y , * cb , * cr , r , g , b ) ; ++ y ; ++ r ; ++ g ; ++ b ; sycc_to_rgb ( offset , upb , * y , * cb , * cr , r , g , b ) ; ++ y ; ++ r ; ++ g ; ++ b ; ++ cb ; ++ cr ; } <S2SV_StartBug> if ( j < maxw ) { <S2SV_EndBug> sycc_to_rgb ( offset , upb , * y , * cb , * cr , r , g , b ) ; ++ y ; ++ r ; ++ g ; ++ b ; ++ cb ; ++ cr ; } } free ( img -> comps [ 0 ] . data ) ; img -> comps [ 0 ] . data = d0 ; free ( img -> comps [ 1 ] . data ) ; img -> comps [ 1 ] . data = d1 ; free ( img -> comps [ 2 ] . data ) ; img -> comps [ 2 ] . data = d2 ; <S2SV_StartBug> # if defined ( USE_JPWL ) || defined ( USE_MJ2 ) <S2SV_EndBug> <S2SV_StartBug> img -> comps [ 1 ] . w = maxw ; img -> comps [ 1 ] . h = maxh ; <S2SV_EndBug> <S2SV_StartBug> img -> comps [ 2 ] . w = maxw ; img -> comps [ 2 ] . h = maxh ; <S2SV_EndBug> # else img -> comps [ 1 ] . w = ( OPJ_UINT32 ) maxw ; img -> comps [ 1 ] . h = ( OPJ_UINT32 ) maxh ; <S2SV_StartBug> img -> comps [ 2 ] . w = ( OPJ_UINT32 ) maxw ; img -> comps [ 2 ] . h = ( OPJ_UINT32 ) maxh ; <S2SV_EndBug> # endif img -> comps [ 1 ] . dx = img -> comps [ 0 ] . dx ; img -> comps [ 2 ] . dx = img -> comps [ 0 ] . dx ; img -> comps [ 1 ] . dy = img -> comps [ 0 ] . dy ; <S2SV_StartBug> img -> comps [ 2 ] . dy = img -> comps [ 0 ] . dy ; <S2SV_EndBug> return ; fails : <S2SV_StartBug> if ( r ) free ( r ) ; <S2SV_EndBug> <S2SV_StartBug> if ( g ) free ( g ) ; <S2SV_EndBug> <S2SV_StartBug> if ( b ) free ( b ) ; <S2SV_EndBug> }\n","target":"<S2SV_ModStart> * cr ; size_t <S2SV_ModEnd> maxw , maxh <S2SV_ModStart> maxh , max , offx , loopmaxw <S2SV_ModStart> , upb ; size_t i <S2SV_ModEnd> ; upb = <S2SV_ModStart> maxw = ( size_t <S2SV_ModEnd> ) img -> <S2SV_ModStart> maxh = ( size_t <S2SV_ModEnd> ) img -> <S2SV_ModStart> int ) * <S2SV_ModEnd> max ) ; <S2SV_ModStart> int ) * <S2SV_ModEnd> max ) ; <S2SV_ModStart> int ) * <S2SV_ModEnd> max ) ; <S2SV_ModStart> goto fails ; offx = img -> x0 & 1U ; loopmaxw = maxw - offx ; <S2SV_ModStart> i ) { size_t j ; if ( offx > 0U ) { sycc_to_rgb ( offset , upb , * y , 0 , 0 , r , g , b ) ; ++ y ; ++ r ; ++ g ; ++ b ; } <S2SV_ModStart> j < ( loopmaxw <S2SV_ModEnd> & ~ ( <S2SV_ModStart> & ~ ( size_t <S2SV_ModEnd> ) 1U ) <S2SV_ModStart> ( j < loopmaxw <S2SV_ModEnd> ) { sycc_to_rgb <S2SV_ModStart> = d2 ; <S2SV_ModEnd> img -> comps <S2SV_ModStart> . w = img -> comps [ 2 ] . w = img -> comps [ 0 ] . w ; <S2SV_ModEnd> img -> comps <S2SV_ModStart> . h = <S2SV_ModEnd> img -> comps <S2SV_ModStart> 2 ] . h = img -> comps [ 0 ] . h ; img -> comps [ 1 ] . dx = <S2SV_ModEnd> img -> comps <S2SV_ModStart> 2 ] . dx = img -> comps [ 0 ] . dx ; img -> comps [ 1 ] . dy = <S2SV_ModEnd> img -> comps <S2SV_ModStart> 2 ] . <S2SV_ModEnd> dy = img <S2SV_ModStart> ; img -> color_space = OPJ_CLRSPC_SRGB <S2SV_ModEnd> ; return ; <S2SV_ModStart> ; fails : <S2SV_ModEnd> free ( r <S2SV_ModStart> r ) ; <S2SV_ModEnd> free ( g <S2SV_ModStart> g ) ; <S2SV_ModEnd> free ( b\n","project_and_commit_id":"uclouvain@openjpeg/15f081c89650dccee4aa4ae66f614c3fdb268767","cve_id":"CVE-2016-3183","original_address":"https://github.com/uclouvain/openjpeg/commit/15f081c89650dccee4aa4ae66f614c3fdb268767","time":"2017-02-03T16:59Z"},
	{"Unnamed: 0":5261,"cwe_id":"CWE-000","source":"CWE-000 static void * bpf_any_get ( void * raw , enum bpf_type type ) { switch ( type ) { case BPF_TYPE_PROG : <S2SV_StartBug> atomic_inc ( & ( ( struct bpf_prog * ) raw ) -> aux -> refcnt ) ; <S2SV_EndBug> break ; case BPF_TYPE_MAP : <S2SV_StartBug> bpf_map_inc ( raw , true ) ; <S2SV_EndBug> break ; default : WARN_ON_ONCE ( 1 ) ; break ; } return raw ; }\n","target":"<S2SV_ModStart> case BPF_TYPE_PROG : raw = bpf_prog_inc ( raw <S2SV_ModEnd> ) ; break <S2SV_ModStart> case BPF_TYPE_MAP : raw =\n","project_and_commit_id":"torvalds@linux/92117d8443bc5afacc8d5ba82e541946310f106e","cve_id":"CVE-2016-4558","original_address":"https://github.com/torvalds/linux/commit/92117d8443bc5afacc8d5ba82e541946310f106e","time":"2016-05-23T10:59Z"},
	{"Unnamed: 0":3303,"cwe_id":"CWE-119","source":"CWE-119 IMPEG2D_ERROR_CODES_T impeg2d_dec_p_b_slice ( dec_state_t * ps_dec ) { WORD16 * pi2_vld_out ; UWORD32 i ; yuv_buf_t * ps_cur_frm_buf = & ps_dec -> s_cur_frm_buf ; UWORD32 u4_frm_offset = 0 ; const dec_mb_params_t * ps_dec_mb_params ; IMPEG2D_ERROR_CODES_T e_error = ( IMPEG2D_ERROR_CODES_T ) IVD_ERROR_NONE ; pi2_vld_out = ps_dec -> ai2_vld_buf ; memset ( ps_dec -> ai2_pred_mv , 0 , sizeof ( ps_dec -> ai2_pred_mv ) ) ; ps_dec -> u2_prev_intra_mb = 0 ; ps_dec -> u2_first_mb = 1 ; ps_dec -> u2_picture_width = ps_dec -> u2_frame_width ; if ( ps_dec -> u2_picture_structure != FRAME_PICTURE ) { ps_dec -> u2_picture_width <<= 1 ; if ( ps_dec -> u2_picture_structure == BOTTOM_FIELD ) { u4_frm_offset = ps_dec -> u2_frame_width ; } } do { UWORD32 u4_x_offset , u4_y_offset ; WORD32 ret ; UWORD32 u4_x_dst_offset = 0 ; UWORD32 u4_y_dst_offset = 0 ; UWORD8 * pu1_out_p ; UWORD8 * pu1_pred ; WORD32 u4_pred_strd ; IMPEG2D_TRACE_MB_START ( ps_dec -> u2_mb_x , ps_dec -> u2_mb_y ) ; if ( ps_dec -> e_pic_type == B_PIC ) ret = impeg2d_dec_pnb_mb_params ( ps_dec ) ; else ret = impeg2d_dec_p_mb_params ( ps_dec ) ; if ( ret ) <S2SV_StartBug> return IMPEG2D_MB_TEX_DECODE_ERR ; <S2SV_EndBug> IMPEG2D_TRACE_MB_START ( ps_dec -> u2_mb_x , ps_dec -> u2_mb_y ) ; u4_x_dst_offset = u4_frm_offset + ( ps_dec -> u2_mb_x << 4 ) ; u4_y_dst_offset = ( ps_dec -> u2_mb_y << 4 ) * ps_dec -> u2_picture_width ; pu1_out_p = ps_cur_frm_buf -> pu1_y + u4_x_dst_offset + u4_y_dst_offset ; if ( ps_dec -> u2_prev_intra_mb == 0 ) { UWORD32 offset_x , offset_y , stride ; UWORD16 index = ( ps_dec -> u2_motion_type ) ; if ( ps_dec -> e_mb_pred == BIDIRECT ) { ps_dec_mb_params = & ps_dec -> ps_func_bi_direct [ index ] ; } else { ps_dec_mb_params = & ps_dec -> ps_func_forw_or_back [ index ] ; } stride = ps_dec -> u2_picture_width ; offset_x = u4_frm_offset + ( ps_dec -> u2_mb_x << 4 ) ; offset_y = ( ps_dec -> u2_mb_y << 4 ) ; ps_dec -> s_dest_buf . pu1_y = ps_cur_frm_buf -> pu1_y + offset_y * stride + offset_x ; stride = stride >> 1 ; ps_dec -> s_dest_buf . pu1_u = ps_cur_frm_buf -> pu1_u + ( offset_y >> 1 ) * stride + ( offset_x >> 1 ) ; ps_dec -> s_dest_buf . pu1_v = ps_cur_frm_buf -> pu1_v + ( offset_y >> 1 ) * stride + ( offset_x >> 1 ) ; PROFILE_DISABLE_MC_IF0 ps_dec_mb_params -> pf_mc ( ps_dec ) ; } for ( i = 0 ; i < NUM_LUMA_BLKS ; ++ i ) { if ( ( ps_dec -> u2_cbp & ( 1 << ( BLOCKS_IN_MB - 1 - i ) ) ) != 0 ) { e_error = ps_dec -> pf_vld_inv_quant ( ps_dec , pi2_vld_out , ps_dec -> pu1_inv_scan_matrix , ps_dec -> u2_prev_intra_mb , Y_LUMA , 0 ) ; if ( ( IMPEG2D_ERROR_CODES_T ) IVD_ERROR_NONE != e_error ) { return e_error ; } u4_x_offset = gai2_impeg2_blk_x_off [ i ] ; if ( ps_dec -> u2_field_dct == 0 ) u4_y_offset = gai2_impeg2_blk_y_off_frm [ i ] ; else u4_y_offset = gai2_impeg2_blk_y_off_fld [ i ] ; IMPEG2D_IDCT_INP_STATISTICS ( pi2_vld_out , ps_dec -> u4_non_zero_cols , ps_dec -> u4_non_zero_rows ) ; PROFILE_DISABLE_IDCT_IF0 { WORD32 idx ; if ( 1 == ( ps_dec -> u4_non_zero_cols | ps_dec -> u4_non_zero_rows ) ) idx = 0 ; else idx = 1 ; if ( 0 == ps_dec -> u2_prev_intra_mb ) { pu1_pred = pu1_out_p + u4_y_offset * ps_dec -> u2_picture_width + u4_x_offset ; u4_pred_strd = ps_dec -> u2_picture_width << ps_dec -> u2_field_dct ; } else { pu1_pred = ( UWORD8 * ) gau1_impeg2_zerobuf ; u4_pred_strd = 8 ; } ps_dec -> pf_idct_recon [ idx * 2 + ps_dec -> i4_last_value_one ] ( pi2_vld_out , ps_dec -> ai2_idct_stg1 , pu1_pred , pu1_out_p + u4_y_offset * ps_dec -> u2_picture_width + u4_x_offset , 8 , u4_pred_strd , ps_dec -> u2_picture_width << ps_dec -> u2_field_dct , ~ ps_dec -> u4_non_zero_cols , ~ ps_dec -> u4_non_zero_rows ) ; } } } u4_x_dst_offset >>= 1 ; u4_y_dst_offset >>= 2 ; if ( ( ps_dec -> u2_cbp & 0x02 ) != 0 ) { pu1_out_p = ps_cur_frm_buf -> pu1_u + u4_x_dst_offset + u4_y_dst_offset ; e_error = ps_dec -> pf_vld_inv_quant ( ps_dec , pi2_vld_out , ps_dec -> pu1_inv_scan_matrix , ps_dec -> u2_prev_intra_mb , U_CHROMA , 0 ) ; if ( ( IMPEG2D_ERROR_CODES_T ) IVD_ERROR_NONE != e_error ) { return e_error ; } IMPEG2D_IDCT_INP_STATISTICS ( pi2_vld_out , ps_dec -> u4_non_zero_cols , ps_dec -> u4_non_zero_rows ) ; PROFILE_DISABLE_IDCT_IF0 { WORD32 idx ; if ( 1 == ( ps_dec -> u4_non_zero_cols | ps_dec -> u4_non_zero_rows ) ) idx = 0 ; else idx = 1 ; if ( 0 == ps_dec -> u2_prev_intra_mb ) { pu1_pred = pu1_out_p ; u4_pred_strd = ps_dec -> u2_picture_width >> 1 ; } else { pu1_pred = ( UWORD8 * ) gau1_impeg2_zerobuf ; u4_pred_strd = 8 ; } ps_dec -> pf_idct_recon [ idx * 2 + ps_dec -> i4_last_value_one ] ( pi2_vld_out , ps_dec -> ai2_idct_stg1 , pu1_pred , pu1_out_p , 8 , u4_pred_strd , ps_dec -> u2_picture_width >> 1 , ~ ps_dec -> u4_non_zero_cols , ~ ps_dec -> u4_non_zero_rows ) ; } } if ( ( ps_dec -> u2_cbp & 0x01 ) != 0 ) { pu1_out_p = ps_cur_frm_buf -> pu1_v + u4_x_dst_offset + u4_y_dst_offset ; e_error = ps_dec -> pf_vld_inv_quant ( ps_dec , pi2_vld_out , ps_dec -> pu1_inv_scan_matrix , ps_dec -> u2_prev_intra_mb , V_CHROMA , 0 ) ; if ( ( IMPEG2D_ERROR_CODES_T ) IVD_ERROR_NONE != e_error ) { return e_error ; } IMPEG2D_IDCT_INP_STATISTICS ( pi2_vld_out , ps_dec -> u4_non_zero_cols , ps_dec -> u4_non_zero_rows ) ; PROFILE_DISABLE_IDCT_IF0 { WORD32 idx ; if ( 1 == ( ps_dec -> u4_non_zero_cols | ps_dec -> u4_non_zero_rows ) ) idx = 0 ; else idx = 1 ; if ( 0 == ps_dec -> u2_prev_intra_mb ) { pu1_pred = pu1_out_p ; u4_pred_strd = ps_dec -> u2_picture_width >> 1 ; } else { pu1_pred = ( UWORD8 * ) gau1_impeg2_zerobuf ; u4_pred_strd = 8 ; } ps_dec -> pf_idct_recon [ idx * 2 + ps_dec -> i4_last_value_one ] ( pi2_vld_out , ps_dec -> ai2_idct_stg1 , pu1_pred , pu1_out_p , 8 , u4_pred_strd , ps_dec -> u2_picture_width >> 1 , ~ ps_dec -> u4_non_zero_cols , ~ ps_dec -> u4_non_zero_rows ) ; } } ps_dec -> u2_num_mbs_left -- ; ps_dec -> u2_first_mb = 0 ; ps_dec -> u2_mb_x ++ ; if ( ps_dec -> s_bit_stream . u4_offset > ps_dec -> s_bit_stream . u4_max_offset ) { return IMPEG2D_BITSTREAM_BUFF_EXCEEDED_ERR ; } else if ( ps_dec -> u2_mb_x == ps_dec -> u2_num_horiz_mb ) { ps_dec -> u2_mb_x = 0 ; ps_dec -> u2_mb_y ++ ; } } while ( ps_dec -> u2_num_mbs_left != 0 && impeg2d_bit_stream_nxt ( & ps_dec -> s_bit_stream , 23 ) != 0x0 ) ; return e_error ; }\n","target":"<S2SV_ModStart> return IMPEG2D_MB_TEX_DECODE_ERR ; if ( 0 >= ps_dec -> u2_num_mbs_left ) { break ; }\n","project_and_commit_id":"external@libmpeg2/7737780815fe523ad7b0e49456eb75d27a30818a","cve_id":"CVE-2017-0810","original_address":"https://android.googlesource.com/platform/external/libmpeg2/+/7737780815fe523ad7b0e49456eb75d27a30818a","time":"2017-10-04T01:29Z"},
	{"Unnamed: 0":896,"cwe_id":"CWE-119","source":"CWE-119 static int rc_pick_q_and_bounds_two_pass ( const VP9_COMP * cpi , int * bottom_index , int * top_index ) { const VP9_COMMON * const cm = & cpi -> common ; const RATE_CONTROL * const rc = & cpi -> rc ; <S2SV_StartBug> const VP9_CONFIG * const oxcf = & cpi -> oxcf ; <S2SV_EndBug> <S2SV_StartBug> int active_best_quality ; <S2SV_EndBug> int active_worst_quality = cpi -> twopass . active_worst_quality ; int q ; <S2SV_StartBug> if ( frame_is_intra_only ( cm ) ) { <S2SV_EndBug> # if ! CONFIG_MULTIPLE_ARF <S2SV_StartBug> if ( rc -> this_key_frame_forced ) { <S2SV_EndBug> <S2SV_StartBug> int qindex = rc -> last_boosted_qindex ; <S2SV_EndBug> <S2SV_StartBug> double last_boosted_q = vp9_convert_qindex_to_q ( qindex ) ; <S2SV_EndBug> int delta_qindex = vp9_compute_qdelta ( rc , last_boosted_q , <S2SV_StartBug> last_boosted_q * 0.75 ) ; <S2SV_EndBug> <S2SV_StartBug> active_best_quality = MAX ( qindex + delta_qindex , rc -> best_quality ) ; <S2SV_EndBug> } else { double q_adj_factor = 1.0 ; double q_val ; <S2SV_StartBug> active_best_quality = get_active_quality ( active_worst_quality , <S2SV_EndBug> rc -> kf_boost , kf_low , kf_high , kf_low_motion_minq , kf_high_motion_minq ) ; if ( ( cm -> width * cm -> height ) <= ( 352 * 288 ) ) { q_adj_factor -= 0.25 ; } q_adj_factor += 0.05 - ( 0.001 * ( double ) cpi -> twopass . kf_zeromotion_pct ) ; <S2SV_StartBug> q_val = vp9_convert_qindex_to_q ( active_best_quality ) ; <S2SV_EndBug> active_best_quality += vp9_compute_qdelta ( rc , q_val , <S2SV_StartBug> q_val * q_adj_factor ) ; <S2SV_EndBug> } # else double current_q ; current_q = vp9_convert_qindex_to_q ( active_worst_quality ) ; active_best_quality = active_worst_quality + vp9_compute_qdelta ( rc , current_q , current_q * 0.3 ) ; # endif } else if ( ! rc -> is_src_frame_alt_ref && ( cpi -> refresh_golden_frame || cpi -> refresh_alt_ref_frame ) ) { if ( rc -> frames_since_key > 1 && rc -> avg_frame_qindex [ INTER_FRAME ] < active_worst_quality ) { q = rc -> avg_frame_qindex [ INTER_FRAME ] ; } else { q = active_worst_quality ; } <S2SV_StartBug> if ( oxcf -> end_usage == USAGE_CONSTRAINED_QUALITY ) { <S2SV_EndBug> <S2SV_StartBug> if ( q < cpi -> cq_target_quality ) <S2SV_EndBug> q = cpi -> cq_target_quality ; if ( rc -> frames_since_key > 1 ) { active_best_quality = get_active_quality ( q , rc -> gfu_boost , gf_low , gf_high , afq_low_motion_minq , afq_high_motion_minq ) ; } else { active_best_quality = get_active_quality ( q , rc -> gfu_boost , gf_low , gf_high , gf_low_motion_minq , gf_high_motion_minq ) ; } active_best_quality = active_best_quality * 15 / 16 ; <S2SV_StartBug> } else if ( oxcf -> end_usage == USAGE_CONSTANT_QUALITY ) { <S2SV_EndBug> if ( ! cpi -> refresh_alt_ref_frame ) { <S2SV_StartBug> active_best_quality = cpi -> cq_target_quality ; <S2SV_EndBug> } else { if ( rc -> frames_since_key > 1 ) { active_best_quality = get_active_quality ( q , rc -> gfu_boost , gf_low , gf_high , afq_low_motion_minq , afq_high_motion_minq ) ; } else { active_best_quality = get_active_quality ( q , rc -> gfu_boost , gf_low , gf_high , gf_low_motion_minq , gf_high_motion_minq ) ; } } } else { active_best_quality = get_active_quality ( q , rc -> gfu_boost , gf_low , gf_high , gf_low_motion_minq , gf_high_motion_minq ) ; } } else { <S2SV_StartBug> if ( oxcf -> end_usage == USAGE_CONSTANT_QUALITY ) { <S2SV_EndBug> active_best_quality = cpi -> cq_target_quality ; } else { active_best_quality = inter_minq [ active_worst_quality ] ; <S2SV_StartBug> if ( ( oxcf -> end_usage == USAGE_CONSTRAINED_QUALITY ) && <S2SV_EndBug> <S2SV_StartBug> ( active_best_quality < cpi -> cq_target_quality ) ) { <S2SV_EndBug> if ( rc -> rolling_actual_bits < rc -> min_frame_bandwidth ) active_best_quality = oxcf -> cq_level ; else active_best_quality = cpi -> cq_target_quality ; } } } active_best_quality = clamp ( active_best_quality , rc -> best_quality , rc -> worst_quality ) ; active_worst_quality = clamp ( active_worst_quality , active_best_quality , rc -> worst_quality ) ; * top_index = active_worst_quality ; * bottom_index = active_best_quality ; # if LIMIT_QRANGE_FOR_ALTREF_AND_KEY <S2SV_StartBug> if ( cm -> frame_type == KEY_FRAME && ! rc -> this_key_frame_forced ) { <S2SV_EndBug> <S2SV_StartBug> * top_index = ( active_worst_quality + active_best_quality * 3 ) / 4 ; <S2SV_EndBug> } else if ( ! rc -> is_src_frame_alt_ref && ( oxcf -> end_usage != USAGE_STREAM_FROM_SERVER ) && ( cpi -> refresh_golden_frame || cpi -> refresh_alt_ref_frame ) ) { * top_index = ( active_worst_quality + active_best_quality ) / 2 ; } # endif if ( oxcf -> end_usage == USAGE_CONSTANT_QUALITY ) { q = active_best_quality ; } else if ( ( cm -> frame_type == KEY_FRAME ) && rc -> this_key_frame_forced ) { <S2SV_StartBug> q = rc -> last_boosted_qindex ; <S2SV_EndBug> } else { q = vp9_rc_regulate_q ( cpi , rc -> this_frame_target , active_best_quality , active_worst_quality ) ; <S2SV_StartBug> if ( q > * top_index ) { <S2SV_EndBug> if ( rc -> this_frame_target >= rc -> max_frame_bandwidth ) <S2SV_StartBug> * top_index = q ; <S2SV_EndBug> else q = * top_index ; } } # if CONFIG_MULTIPLE_ARF if ( cpi -> multi_arf_enabled && ( cm -> frame_type != KEY_FRAME ) && cpi -> oxcf . end_usage != USAGE_CONSTANT_QUALITY ) { double new_q ; double current_q = vp9_convert_qindex_to_q ( active_worst_quality ) ; int level = cpi -> this_frame_weight ; assert ( level >= 0 ) ; new_q = current_q * ( 1.0 - ( 0.2 * ( cpi -> max_arf_level - level ) ) ) ; q = active_worst_quality + vp9_compute_qdelta ( rc , current_q , new_q ) ; <S2SV_StartBug> * bottom_index = q ; <S2SV_EndBug> * top_index = q ; printf ( \"frame:%d<S2SV_blank>q:%d\\\\n\" , cm -> current_video_frame , q ) ; } # endif assert ( * top_index <= rc -> worst_quality && * top_index >= rc -> best_quality ) ; assert ( * bottom_index <= rc -> worst_quality && * bottom_index >= rc -> best_quality ) ; assert ( q <= rc -> worst_quality && q >= rc -> best_quality ) ; return q ; }\n","target":"<S2SV_ModStart> rc ; const VP9EncoderConfig <S2SV_ModEnd> * const oxcf <S2SV_ModStart> -> oxcf ; const GF_GROUP * gf_group = & cpi -> twopass . gf_group ; const int cq_level = get_active_cq_level ( rc , oxcf ) ; int active_best_quality ; int active_worst_quality = cpi -> twopass . active_worst_quality ; int q ; int * inter_minq ; ASSIGN_MINQ_TABLE ( cm -> bit_depth , inter_minq ) <S2SV_ModEnd> ; if ( <S2SV_ModStart> ( cm ) || vp9_is_upper_layer_key_frame ( cpi ) ) { <S2SV_ModEnd> if ( rc <S2SV_ModStart> this_key_frame_forced ) { double last_boosted_q ; int delta_qindex ; int qindex ; if ( cpi -> twopass . last_kfgroup_zeromotion_pct >= STATIC_MOTION_THRESH ) { qindex = MIN ( rc -> last_kf_qindex , <S2SV_ModEnd> rc -> last_boosted_qindex <S2SV_ModStart> rc -> last_boosted_qindex ) ; active_best_quality = qindex ; <S2SV_ModEnd> last_boosted_q = vp9_convert_qindex_to_q <S2SV_ModStart> vp9_convert_qindex_to_q ( qindex , cm -> bit_depth ) ; <S2SV_ModEnd> delta_qindex = vp9_compute_qdelta <S2SV_ModStart> , last_boosted_q * 1.25 , cm -> bit_depth ) ; active_worst_quality = MIN <S2SV_ModEnd> ( qindex + <S2SV_ModStart> + delta_qindex , active_worst_quality ) ; } else { qindex = rc -> last_boosted_qindex ; last_boosted_q = vp9_convert_qindex_to_q ( qindex , cm -> bit_depth ) ; delta_qindex = vp9_compute_qdelta ( rc , last_boosted_q , last_boosted_q * 0.75 , cm -> bit_depth ) ; active_best_quality = MAX ( qindex + delta_qindex , <S2SV_ModStart> best_quality ) ; } <S2SV_ModStart> ; active_best_quality = get_kf_active_quality ( rc , active_worst_quality , cm -> bit_depth <S2SV_ModEnd> ) ; if <S2SV_ModStart> vp9_convert_qindex_to_q ( active_best_quality , cm -> bit_depth <S2SV_ModStart> q_val * q_adj_factor , cm -> bit_depth ) ; } <S2SV_ModEnd> } else if <S2SV_ModStart> ( oxcf -> rc_mode == VPX_CQ <S2SV_ModEnd> ) { if <S2SV_ModStart> ( q < cq_level ) q = cq_level ; active_best_quality = get_gf_active_quality ( rc , q , cm -> bit_depth ) ; <S2SV_ModEnd> active_best_quality = active_best_quality <S2SV_ModStart> ( oxcf -> rc_mode == VPX_Q <S2SV_ModEnd> ) { if <S2SV_ModStart> { active_best_quality = cq_level ; } else { active_best_quality = get_gf_active_quality ( rc , q , cm -> bit_depth ) ; if ( gf_group -> rf_level [ gf_group -> index ] == GF_ARF_LOW ) active_best_quality = ( active_best_quality + cq_level + 1 ) / 2 ; } } else { active_best_quality = get_gf_active_quality ( rc , q , cm -> bit_depth <S2SV_ModEnd> ) ; } <S2SV_ModStart> ( oxcf -> rc_mode == VPX_Q ) { active_best_quality = cq_level <S2SV_ModEnd> ; } else <S2SV_ModStart> ( oxcf -> rc_mode == VPX_CQ <S2SV_ModEnd> ) && ( <S2SV_ModStart> ( active_best_quality < cq_level ) ) { active_best_quality = cq_level ; } } } if ( ( cpi -> oxcf . rc_mode != VPX_Q ) && ( cpi -> twopass . gf_zeromotion_pct < VLOW_MOTION_THRESHOLD ) ) { if ( frame_is_intra_only ( cm ) || ( ! rc -> is_src_frame_alt_ref && ( cpi -> refresh_golden_frame || cpi -> refresh_alt_ref_frame ) ) ) { active_best_quality -= ( cpi -> twopass . extend_minq + cpi -> twopass . extend_minq_fast ) ; active_worst_quality += ( cpi -> twopass . extend_maxq / 2 ) ; } else { active_best_quality -= ( cpi -> twopass . extend_minq + cpi -> twopass . extend_minq_fast ) / 2 ; active_worst_quality += cpi -> twopass . extend_maxq ; } } <S2SV_ModEnd> # if LIMIT_QRANGE_FOR_ALTREF_AND_KEY <S2SV_ModStart> # if LIMIT_QRANGE_FOR_ALTREF_AND_KEY vpx_clear_system_state ( ) ; if ( ! ( ( frame_is_intra_only ( cm ) || vp9_is_upper_layer_key_frame ( cpi ) ) ) || ! rc -> this_key_frame_forced || ( cpi -> twopass . last_kfgroup_zeromotion_pct < STATIC_MOTION_THRESH ) ) { int qdelta = vp9_frame_type_qdelta ( cpi , gf_group -> rf_level [ gf_group -> index ] , active_worst_quality ) ; active_worst_quality = MAX ( active_worst_quality + qdelta , active_best_quality ) ; } # endif if ( rc -> frame_size_selector != UNSCALED && ! frame_is_kf_gf_arf ( cpi ) ) { int qdelta = vp9_compute_qdelta_by_rate ( rc , cm -> frame_type , active_best_quality , 2.0 , cm -> bit_depth ) ; active_best_quality = MAX ( active_best_quality + qdelta , rc -> best_quality ) ; } active_best_quality = clamp ( active_best_quality , rc -> best_quality , rc -> worst_quality ) ; active_worst_quality = clamp ( active_worst_quality , active_best_quality , rc -> worst_quality ) ; if ( oxcf -> rc_mode == VPX_Q ) { q = active_best_quality ; } else if ( ( frame_is_intra_only ( cm ) || vp9_is_upper_layer_key_frame ( cpi ) ) && <S2SV_ModEnd> rc -> this_key_frame_forced <S2SV_ModStart> this_key_frame_forced ) { if ( cpi -> twopass . last_kfgroup_zeromotion_pct >= STATIC_MOTION_THRESH ) { q = MIN ( rc -> last_kf_qindex , <S2SV_ModEnd> rc -> last_boosted_qindex <S2SV_ModStart> rc -> last_boosted_qindex ) ; } else { q = rc -> last_boosted_qindex ; } <S2SV_ModEnd> } else { <S2SV_ModStart> ( q > active_worst_quality <S2SV_ModEnd> ) { if <S2SV_ModStart> -> max_frame_bandwidth ) active_worst_quality = q ; else q = active_worst_quality ; } } clamp ( q , active_best_quality , active_worst_quality ) ; <S2SV_ModStart> * top_index = active_worst_quality <S2SV_ModEnd> ; * bottom_index <S2SV_ModStart> * bottom_index = active_best_quality ; <S2SV_ModEnd> assert ( *\n","project_and_commit_id":"external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426","cve_id":"CVE-2016-1621","original_address":"https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426","time":"2016-03-12T21:59Z"},
	{"Unnamed: 0":3300,"cwe_id":"CWE-119","source":"CWE-119 static vpx_codec_err_t vp8_peek_si_internal ( const uint8_t * data , unsigned int data_sz , vpx_codec_stream_info_t * si , <S2SV_StartBug> vp8_decrypt_cb * decrypt_cb , <S2SV_EndBug> void * decrypt_state ) { vpx_codec_err_t res = VPX_CODEC_OK ; if ( data + data_sz <= data ) { res = VPX_CODEC_INVALID_PARAM ; } else { uint8_t clear_buffer [ 10 ] ; const uint8_t * clear = data ; if ( decrypt_cb ) { <S2SV_StartBug> int n = data_sz > 10 ? 10 : data_sz ; <S2SV_EndBug> decrypt_cb ( decrypt_state , data , clear_buffer , n ) ; clear = clear_buffer ; } si -> is_kf = 0 ; if ( data_sz >= 10 && ! ( clear [ 0 ] & 0x01 ) ) { si -> is_kf = 1 ; if ( clear [ 3 ] != 0x9d || clear [ 4 ] != 0x01 || clear [ 5 ] != 0x2a ) <S2SV_StartBug> res = VPX_CODEC_UNSUP_BITSTREAM ; <S2SV_EndBug> si -> w = ( clear [ 6 ] | ( clear [ 7 ] << 8 ) ) & 0x3fff ; si -> h = ( clear [ 8 ] | ( clear [ 9 ] << 8 ) ) & 0x3fff ; if ( ! ( si -> h | si -> w ) ) res = VPX_CODEC_UNSUP_BITSTREAM ; } else { res = VPX_CODEC_UNSUP_BITSTREAM ; } } return res ; }\n","target":"<S2SV_ModStart> * si , vpx_decrypt_cb <S2SV_ModEnd> decrypt_cb , void <S2SV_ModStart> int n = MIN ( sizeof ( clear_buffer ) , data_sz ) <S2SV_ModEnd> ; decrypt_cb ( <S2SV_ModStart> != 0x2a ) return <S2SV_ModEnd> VPX_CODEC_UNSUP_BITSTREAM ; si\n","project_and_commit_id":"external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426","cve_id":"CVE-2016-1621","original_address":"https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426","time":"2016-03-12T21:59Z"},
	{"Unnamed: 0":4376,"cwe_id":"CWE-787","source":"CWE-787 pdf_t * pdf_new ( const char * name ) { const char * n ; pdf_t * pdf ; <S2SV_StartBug> pdf = calloc ( 1 , sizeof ( pdf_t ) ) ; <S2SV_EndBug> if ( name ) { if ( ( n = strrchr ( name , '/' ) ) ) ++ n ; else n = name ; <S2SV_StartBug> pdf -> name = malloc ( strlen ( n ) + 1 ) ; <S2SV_EndBug> strcpy ( pdf -> name , n ) ; } else { <S2SV_StartBug> pdf -> name = malloc ( strlen ( \"Unknown\" ) + 1 ) ; <S2SV_EndBug> strcpy ( pdf -> name , \"Unknown\" ) ; } return pdf ; }\n","target":"<S2SV_ModStart> ; pdf = safe_calloc ( <S2SV_ModEnd> sizeof ( pdf_t <S2SV_ModStart> -> name = safe_calloc <S2SV_ModEnd> ( strlen ( <S2SV_ModStart> -> name = safe_calloc <S2SV_ModEnd> ( strlen (\n","project_and_commit_id":"enferex@pdfresurrect/0c4120fffa3dffe97b95c486a120eded82afe8a6","cve_id":"CVE-2019-14934","original_address":"https://github.com/enferex/pdfresurrect/commit/0c4120fffa3dffe97b95c486a120eded82afe8a6","time":"2019-08-11T22:15Z"},
	{"Unnamed: 0":4021,"cwe_id":"CWE-119","source":"CWE-119 int sr_do_ioctl ( Scsi_CD * cd , struct packet_command * cgc ) { struct scsi_device * SDev ; struct scsi_sense_hdr sshdr ; int result , err = 0 , retries = 0 ; <S2SV_StartBug> SDev = cd -> device ; <S2SV_EndBug> retry : if ( ! scsi_block_when_processing_errors ( SDev ) ) { err = - ENODEV ; goto out ; } result = scsi_execute ( SDev , cgc -> cmd , cgc -> data_direction , cgc -> buffer , cgc -> buflen , <S2SV_StartBug> ( unsigned char * ) cgc -> sense , & sshdr , <S2SV_EndBug> cgc -> timeout , IOCTL_RETRIES , 0 , 0 , NULL ) ; if ( driver_byte ( result ) != 0 ) { switch ( sshdr . sense_key ) { case UNIT_ATTENTION : SDev -> changed = 1 ; if ( ! cgc -> quiet ) sr_printk ( KERN_INFO , cd , \"disc<S2SV_blank>change<S2SV_blank>detected.\\\\n\" ) ; if ( retries ++ < 10 ) goto retry ; err = - ENOMEDIUM ; break ; case NOT_READY : if ( sshdr . asc == 0x04 && sshdr . ascq == 0x01 ) { if ( ! cgc -> quiet ) sr_printk ( KERN_INFO , cd , \"CDROM<S2SV_blank>not<S2SV_blank>ready<S2SV_blank>yet.\\\\n\" ) ; if ( retries ++ < 10 ) { ssleep ( 2 ) ; goto retry ; } else { err = - ENOMEDIUM ; break ; } } if ( ! cgc -> quiet ) sr_printk ( KERN_INFO , cd , \"CDROM<S2SV_blank>not<S2SV_blank>ready.<S2SV_blank><S2SV_blank>Make<S2SV_blank>sure<S2SV_blank>there<S2SV_blank>\" \"is<S2SV_blank>a<S2SV_blank>disc<S2SV_blank>in<S2SV_blank>the<S2SV_blank>drive.\\\\n\" ) ; err = - ENOMEDIUM ; break ; case ILLEGAL_REQUEST : err = - EIO ; if ( sshdr . asc == 0x20 && sshdr . ascq == 0x00 ) err = - EDRIVE_CANT_DO_THIS ; break ; default : err = - EIO ; } } out : cgc -> stat = err ; return err ; }\n","target":"<S2SV_ModStart> = 0 ; unsigned char sense_buffer [ SCSI_SENSE_BUFFERSIZE ] , * senseptr = NULL ; <S2SV_ModStart> cd -> device ; if ( cgc -> sense ) senseptr = sense_buffer <S2SV_ModStart> -> buflen , senseptr , & sshdr , cgc -> timeout , IOCTL_RETRIES , 0 , 0 , NULL ) ; if ( cgc -> sense ) memcpy ( cgc -> sense , sense_buffer , sizeof ( * <S2SV_ModEnd> cgc -> sense <S2SV_ModStart> cgc -> sense ) <S2SV_ModEnd> ) ; if\n","project_and_commit_id":"torvalds@linux/f7068114d45ec55996b9040e98111afa56e010fe","cve_id":"CVE-2018-11506","original_address":"https://github.com/torvalds/linux/commit/f7068114d45ec55996b9040e98111afa56e010fe","time":"2018-05-28T04:29Z"},
	{"Unnamed: 0":688,"cwe_id":"CWE-362","source":"CWE-362 static int raw_sendmsg ( struct sock * sk , struct msghdr * msg , size_t len ) { struct inet_sock * inet = inet_sk ( sk ) ; struct net * net = sock_net ( sk ) ; struct ipcm_cookie ipc ; struct rtable * rt = NULL ; struct flowi4 fl4 ; int free = 0 ; __be32 daddr ; __be32 saddr ; u8 tos ; int err ; struct ip_options_data opt_copy ; struct raw_frag_vec rfv ; <S2SV_StartBug> err = - EMSGSIZE ; <S2SV_EndBug> if ( len > 0xFFFF ) <S2SV_StartBug> goto out ; <S2SV_EndBug> err = - EOPNOTSUPP ; if ( msg -> msg_flags & MSG_OOB ) goto out ; if ( msg -> msg_namelen ) { DECLARE_SOCKADDR ( struct sockaddr_in * , usin , msg -> msg_name ) ; err = - EINVAL ; if ( msg -> msg_namelen < sizeof ( * usin ) ) goto out ; if ( usin -> sin_family != AF_INET ) { pr_info_once ( \"%s:<S2SV_blank>%s<S2SV_blank>forgot<S2SV_blank>to<S2SV_blank>set<S2SV_blank>AF_INET.<S2SV_blank>Fix<S2SV_blank>it!\\\\n\" , __func__ , current -> comm ) ; err = - EAFNOSUPPORT ; if ( usin -> sin_family ) goto out ; } daddr = usin -> sin_addr . s_addr ; } else { err = - EDESTADDRREQ ; if ( sk -> sk_state != TCP_ESTABLISHED ) goto out ; daddr = inet -> inet_daddr ; } ipc . sockc . tsflags = sk -> sk_tsflags ; ipc . addr = inet -> inet_saddr ; ipc . opt = NULL ; ipc . tx_flags = 0 ; ipc . ttl = 0 ; ipc . tos = - 1 ; ipc . oif = sk -> sk_bound_dev_if ; if ( msg -> msg_controllen ) { err = ip_cmsg_send ( sk , msg , & ipc , false ) ; if ( unlikely ( err ) ) { kfree ( ipc . opt ) ; goto out ; } if ( ipc . opt ) free = 1 ; } saddr = ipc . addr ; ipc . addr = daddr ; if ( ! ipc . opt ) { struct ip_options_rcu * inet_opt ; rcu_read_lock ( ) ; inet_opt = rcu_dereference ( inet -> inet_opt ) ; if ( inet_opt ) { memcpy ( & opt_copy , inet_opt , sizeof ( * inet_opt ) + inet_opt -> opt . optlen ) ; ipc . opt = & opt_copy . opt ; } rcu_read_unlock ( ) ; } if ( ipc . opt ) { err = - EINVAL ; <S2SV_StartBug> if ( inet -> hdrincl ) <S2SV_EndBug> goto done ; if ( ipc . opt -> opt . srr ) { if ( ! daddr ) goto done ; daddr = ipc . opt -> opt . faddr ; } } tos = get_rtconn_flags ( & ipc , sk ) ; if ( msg -> msg_flags & MSG_DONTROUTE ) tos |= RTO_ONLINK ; if ( ipv4_is_multicast ( daddr ) ) { if ( ! ipc . oif ) ipc . oif = inet -> mc_index ; if ( ! saddr ) saddr = inet -> mc_addr ; } else if ( ! ipc . oif ) ipc . oif = inet -> uc_index ; flowi4_init_output ( & fl4 , ipc . oif , sk -> sk_mark , tos , RT_SCOPE_UNIVERSE , <S2SV_StartBug> inet -> hdrincl ? IPPROTO_RAW : sk -> sk_protocol , <S2SV_EndBug> inet_sk_flowi_flags ( sk ) | <S2SV_StartBug> ( inet -> hdrincl ? FLOWI_FLAG_KNOWN_NH : 0 ) , <S2SV_EndBug> daddr , saddr , 0 , 0 , sk -> sk_uid ) ; <S2SV_StartBug> if ( ! inet -> hdrincl ) { <S2SV_EndBug> rfv . msg = msg ; rfv . hlen = 0 ; err = raw_probe_proto_opt ( & rfv , & fl4 ) ; if ( err ) goto done ; } security_sk_classify_flow ( sk , flowi4_to_flowi ( & fl4 ) ) ; rt = ip_route_output_flow ( net , & fl4 , sk ) ; if ( IS_ERR ( rt ) ) { err = PTR_ERR ( rt ) ; rt = NULL ; goto done ; } err = - EACCES ; if ( rt -> rt_flags & RTCF_BROADCAST && ! sock_flag ( sk , SOCK_BROADCAST ) ) goto done ; if ( msg -> msg_flags & MSG_CONFIRM ) goto do_confirm ; back_from_confirm : <S2SV_StartBug> if ( inet -> hdrincl ) <S2SV_EndBug> err = raw_send_hdrinc ( sk , & fl4 , msg , len , & rt , msg -> msg_flags , & ipc . sockc ) ; else { sock_tx_timestamp ( sk , ipc . sockc . tsflags , & ipc . tx_flags ) ; if ( ! ipc . addr ) ipc . addr = fl4 . daddr ; lock_sock ( sk ) ; err = ip_append_data ( sk , & fl4 , raw_getfrag , & rfv , len , 0 , & ipc , & rt , msg -> msg_flags ) ; if ( err ) ip_flush_pending_frames ( sk ) ; else if ( ! ( msg -> msg_flags & MSG_MORE ) ) { err = ip_push_pending_frames ( sk , & fl4 ) ; if ( err == - ENOBUFS && ! inet -> recverr ) err = 0 ; } release_sock ( sk ) ; } done : if ( free ) kfree ( ipc . opt ) ; ip_rt_put ( rt ) ; out : if ( err < 0 ) return err ; return len ; do_confirm : if ( msg -> msg_flags & MSG_PROBE ) dst_confirm_neigh ( & rt -> dst , & fl4 . daddr ) ; if ( ! ( msg -> msg_flags & MSG_PROBE ) || len ) goto back_from_confirm ; err = 0 ; goto done ; }\n","target":"<S2SV_ModStart> raw_frag_vec rfv ; int hdrincl ; <S2SV_ModStart> ) goto out ; hdrincl = inet -> hdrincl <S2SV_ModStart> ; if ( <S2SV_ModEnd> hdrincl ) goto <S2SV_ModStart> , RT_SCOPE_UNIVERSE , <S2SV_ModEnd> hdrincl ? IPPROTO_RAW <S2SV_ModStart> ) | ( <S2SV_ModEnd> hdrincl ? FLOWI_FLAG_KNOWN_NH <S2SV_ModStart> if ( ! <S2SV_ModEnd> hdrincl ) { <S2SV_ModStart> : if ( <S2SV_ModEnd> hdrincl ) err\n","project_and_commit_id":"torvalds@linux/8f659a03a0ba9289b9aeb9b4470e6fb263d6f483","cve_id":"CVE-2017-17712","original_address":"https://github.com/torvalds/linux/commit/8f659a03a0ba9289b9aeb9b4470e6fb263d6f483","time":"2017-12-16T01:29Z"},
	{"Unnamed: 0":3909,"cwe_id":"CWE-863","source":"CWE-863 static int sanitize_ptr_alu ( struct bpf_verifier_env * env , struct bpf_insn * insn , const struct bpf_reg_state * ptr_reg , const struct bpf_reg_state * off_reg , struct bpf_reg_state * dst_reg , struct bpf_insn_aux_data * tmp_aux , const bool commit_window ) { struct bpf_insn_aux_data * aux = commit_window ? cur_aux ( env ) : tmp_aux ; struct bpf_verifier_state * vstate = env -> cur_state ; <S2SV_StartBug> bool off_is_neg = off_reg -> smin_value < 0 ; <S2SV_EndBug> bool ptr_is_dst_reg = ptr_reg == dst_reg ; u8 opcode = BPF_OP ( insn -> code ) ; u32 alu_state , alu_limit ; struct bpf_reg_state tmp ; bool ret ; int err ; if ( can_skip_alu_sanitation ( env , insn ) ) return 0 ; if ( vstate -> speculative ) goto do_sim ; err = retrieve_ptr_limit ( ptr_reg , off_reg , & alu_limit , opcode ) ; if ( err < 0 ) return err ; if ( commit_window ) { alu_state = tmp_aux -> alu_state ; alu_limit = abs ( tmp_aux -> alu_limit - alu_limit ) ; } else { <S2SV_StartBug> alu_state = off_is_neg ? BPF_ALU_NEG_VALUE : 0 ; <S2SV_EndBug> alu_state |= ptr_is_dst_reg ? BPF_ALU_SANITIZE_SRC : BPF_ALU_SANITIZE_DST ; } err = update_alu_sanitation_state ( aux , alu_state , alu_limit ) ; if ( err < 0 ) return err ; do_sim : if ( commit_window ) return 0 ; if ( ! ptr_is_dst_reg ) { tmp = * dst_reg ; * dst_reg = * ptr_reg ; } ret = push_stack ( env , env -> insn_idx + 1 , env -> insn_idx , true ) ; if ( ! ptr_is_dst_reg && ret ) * dst_reg = tmp ; return ! ret ? REASON_STACK : 0 ; }\n","target":"<S2SV_ModStart> cur_state ; bool off_is_imm = tnum_is_const ( off_reg -> var_off ) ; bool <S2SV_ModStart> off_is_neg ? BPF_ALU_NEG_VALUE : 0 ; alu_state |= off_is_imm ? BPF_ALU_IMMEDIATE\n","project_and_commit_id":"torvalds@linux/801c6058d14a82179a7ee17a4b532cac6fad067f","cve_id":"CVE-2021-31829","original_address":"https://github.com/torvalds/linux/commit/801c6058d14a82179a7ee17a4b532cac6fad067f","time":"2021-05-06T16:15Z"},
	{"Unnamed: 0":3274,"cwe_id":"CWE-190","source":"CWE-190 static long mem_seek ( jas_stream_obj_t * obj , long offset , int origin ) { jas_stream_memobj_t * m = ( jas_stream_memobj_t * ) obj ; <S2SV_StartBug> long newpos ; <S2SV_EndBug> JAS_DBGLOG ( 100 , ( \"mem_seek(%p,<S2SV_blank>%ld,<S2SV_blank>%d)\\\\n\" , obj , offset , origin ) ) ; switch ( origin ) { case SEEK_SET : newpos = offset ; break ; case SEEK_END : newpos = m -> len_ - offset ; break ; case SEEK_CUR : newpos = m -> pos_ + offset ; break ; default : abort ( ) ; break ; } if ( newpos < 0 ) { return - 1 ; } m -> pos_ = newpos ; return m -> pos_ ; }\n","target":"<S2SV_ModStart> ) obj ; size_t <S2SV_ModEnd> newpos ; JAS_DBGLOG\n","project_and_commit_id":"mdadams@jasper/634ce8e8a5accc0fa05dd2c20d42b4749d4b2735","cve_id":"CVE-2016-9262","original_address":"https://github.com/mdadams/jasper/commit/634ce8e8a5accc0fa05dd2c20d42b4749d4b2735","time":"2017-03-23T18:59Z"},
	{"Unnamed: 0":6048,"cwe_id":"CWE-835","source":"CWE-835 static Image * ReadTXTImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { char colorspace [ MagickPathExtent ] , text [ MagickPathExtent ] ; Image * image ; long x_offset , y_offset ; PixelInfo pixel ; MagickBooleanType status ; QuantumAny range ; register ssize_t i , x ; register Quantum * q ; ssize_t count , type , y ; unsigned long depth , height , max_value , width ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickCoreSignature ) ; if ( image_info -> debug != MagickFalse ) ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , \"%s\" , image_info -> filename ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickCoreSignature ) ; image = AcquireImage ( image_info , exception ) ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } ( void ) ResetMagickMemory ( text , 0 , sizeof ( text ) ) ; ( void ) ReadBlobString ( image , text ) ; if ( LocaleNCompare ( ( char * ) text , MagickID , strlen ( MagickID ) ) != 0 ) ThrowReaderException ( CorruptImageError , \"ImproperImageHeader\" ) ; do { width = 0 ; height = 0 ; max_value = 0 ; * colorspace = '\\\\0' ; count = ( ssize_t ) sscanf ( text + 32 , \"%lu,%lu,%lu,%s\" , & width , & height , & max_value , colorspace ) ; if ( ( count != 4 ) || ( width == 0 ) || ( height == 0 ) || ( max_value == 0 ) ) ThrowReaderException ( CorruptImageError , \"ImproperImageHeader\" ) ; image -> columns = width ; image -> rows = height ; for ( depth = 1 ; ( GetQuantumRange ( depth ) + 1 ) < max_value ; depth ++ ) ; image -> depth = depth ; status = SetImageExtent ( image , image -> columns , image -> rows , exception ) ; if ( status == MagickFalse ) return ( DestroyImageList ( image ) ) ; LocaleLower ( colorspace ) ; i = ( ssize_t ) strlen ( colorspace ) - 1 ; image -> alpha_trait = UndefinedPixelTrait ; if ( ( i > 0 ) && ( colorspace [ i ] == 'a' ) ) { colorspace [ i ] = '\\\\0' ; image -> alpha_trait = BlendPixelTrait ; } type = ParseCommandOption ( MagickColorspaceOptions , MagickFalse , colorspace ) ; if ( type < 0 ) ThrowReaderException ( CorruptImageError , \"ImproperImageHeader\" ) ; ( void ) SetImageBackgroundColor ( image , exception ) ; ( void ) SetImageColorspace ( image , ( ColorspaceType ) type , exception ) ; GetPixelInfo ( image , & pixel ) ; range = GetQuantumRange ( image -> depth ) ; for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { double alpha , black , blue , green , red ; red = 0.0 ; green = 0.0 ; blue = 0.0 ; black = 0.0 ; alpha = 0.0 ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { if ( ReadBlobString ( image , text ) == ( char * ) NULL ) break ; switch ( image -> colorspace ) { case GRAYColorspace : { if ( image -> alpha_trait != UndefinedPixelTrait ) { count = ( ssize_t ) sscanf ( text , \"%ld,%ld:<S2SV_blank>(%lf%*[%,]%lf%*[%,]\" , & x_offset , & y_offset , & red , & alpha ) ; green = red ; blue = red ; break ; } count = ( ssize_t ) sscanf ( text , \"%ld,%ld:<S2SV_blank>(%lf%*[%,]\" , & x_offset , & y_offset , & red ) ; green = red ; blue = red ; break ; } case CMYKColorspace : { if ( image -> alpha_trait != UndefinedPixelTrait ) { count = ( ssize_t ) sscanf ( text , \"%ld,%ld:<S2SV_blank>(%lf%*[%,]%lf%*[%,]%lf%*[%,]%lf%*[%,]%lf%*[%,]\" , & x_offset , & y_offset , & red , & green , & blue , & black , & alpha ) ; break ; } count = ( ssize_t ) sscanf ( text , \"%ld,%ld:<S2SV_blank>(%lf%*[%,]%lf%*[%,]%lf%*[%,]%lf%*[%,]\" , & x_offset , & y_offset , & red , & green , & blue , & black ) ; break ; } default : { if ( image -> alpha_trait != UndefinedPixelTrait ) { count = ( ssize_t ) sscanf ( text , \"%ld,%ld:<S2SV_blank>(%lf%*[%,]%lf%*[%,]%lf%*[%,]%lf%*[%,]\" , & x_offset , & y_offset , & red , & green , & blue , & alpha ) ; break ; } count = ( ssize_t ) sscanf ( text , \"%ld,%ld:<S2SV_blank>(%lf%*[%,]%lf%*[%,]%lf%*[%,]\" , & x_offset , & y_offset , & red , & green , & blue ) ; break ; } } if ( strchr ( text , '%' ) != ( char * ) NULL ) { red *= 0.01 * range ; green *= 0.01 * range ; blue *= 0.01 * range ; black *= 0.01 * range ; alpha *= 0.01 * range ; } if ( image -> colorspace == LabColorspace ) { green += ( range + 1 ) / 2.0 ; blue += ( range + 1 ) / 2.0 ; } pixel . red = ( MagickRealType ) ScaleAnyToQuantum ( ( QuantumAny ) ( red + 0.5 ) , range ) ; pixel . green = ( MagickRealType ) ScaleAnyToQuantum ( ( QuantumAny ) ( green + 0.5 ) , range ) ; pixel . blue = ( MagickRealType ) ScaleAnyToQuantum ( ( QuantumAny ) ( blue + 0.5 ) , range ) ; pixel . black = ( MagickRealType ) ScaleAnyToQuantum ( ( QuantumAny ) ( black + 0.5 ) , range ) ; pixel . alpha = ( MagickRealType ) ScaleAnyToQuantum ( ( QuantumAny ) ( alpha + 0.5 ) , range ) ; q = GetAuthenticPixels ( image , ( ssize_t ) x_offset , ( ssize_t ) y_offset , 1 , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) continue ; SetPixelViaPixelInfo ( image , & pixel , q ) ; if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; } } <S2SV_StartBug> ( void ) ReadBlobString ( image , text ) ; <S2SV_EndBug> if ( LocaleNCompare ( ( char * ) text , MagickID , strlen ( MagickID ) ) == 0 ) { AcquireNextImage ( image_info , image , exception ) ; if ( GetNextImageInList ( image ) == ( Image * ) NULL ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } image = SyncNextImageInList ( image ) ; status = SetImageProgress ( image , LoadImagesTag , TellBlob ( image ) , GetBlobSize ( image ) ) ; if ( status == MagickFalse ) break ; } } while ( LocaleNCompare ( ( char * ) text , MagickID , strlen ( MagickID ) ) == 0 ) ; ( void ) CloseBlob ( image ) ; return ( GetFirstImageInList ( image ) ) ; }\n","target":"<S2SV_ModStart> ; } } if ( EOFBlob ( image ) != MagickFalse ) { ThrowFileException ( exception , CorruptImageError , \"UnexpectedEndOfFile\" , image -> filename ) ; break ; }\n","project_and_commit_id":"ImageMagick@ImageMagick/83e0f8ffd7eeb7661b0ff83257da23d24ca7f078","cve_id":"CVE-2017-11523","original_address":"https://github.com/ImageMagick/ImageMagick/commit/83e0f8ffd7eeb7661b0ff83257da23d24ca7f078","time":"2017-07-22T21:29Z"},
	{"Unnamed: 0":3343,"cwe_id":"CWE-119","source":"CWE-119 int y4m_write_file_header ( char * buf , size_t len , int width , int height , const struct VpxRational * framerate , <S2SV_StartBug> vpx_img_fmt_t fmt ) { <S2SV_EndBug> <S2SV_StartBug> const char * const color = fmt == VPX_IMG_FMT_444A ? \"C444alpha\\\\n\" : <S2SV_EndBug> fmt == VPX_IMG_FMT_I444 ? \"C444\\\\n\" : fmt == VPX_IMG_FMT_I422 ? \"C422\\\\n\" : <S2SV_StartBug> \"C420jpeg\\\\n\" ; <S2SV_EndBug> return snprintf ( buf , len , \"YUV4MPEG2<S2SV_blank>W%u<S2SV_blank>H%u<S2SV_blank>F%u:%u<S2SV_blank>I%c<S2SV_blank>%s\" , width , height , framerate -> numerator , framerate -> denominator , 'p' , color ) ; }\n","target":"<S2SV_ModStart> , vpx_img_fmt_t fmt , unsigned int bit_depth <S2SV_ModStart> const char * color ; switch ( bit_depth ) { case 8 : <S2SV_ModEnd> color = fmt <S2SV_ModStart> : \"C420jpeg\\\\n\" ; break ; case 9 : color = fmt == VPX_IMG_FMT_I44416 ? \"C444p9<S2SV_blank>XYSCSS=444P9\\\\n\" : fmt == VPX_IMG_FMT_I42216 ? \"C422p9<S2SV_blank>XYSCSS=422P9\\\\n\" : \"C420p9<S2SV_blank>XYSCSS=420P9\\\\n\" ; break ; case 10 : color = fmt == VPX_IMG_FMT_I44416 ? \"C444p10<S2SV_blank>XYSCSS=444P10\\\\n\" : fmt == VPX_IMG_FMT_I42216 ? \"C422p10<S2SV_blank>XYSCSS=422P10\\\\n\" : \"C420p10<S2SV_blank>XYSCSS=420P10\\\\n\" ; break ; case 12 : color = fmt == VPX_IMG_FMT_I44416 ? \"C444p12<S2SV_blank>XYSCSS=444P12\\\\n\" : fmt == VPX_IMG_FMT_I42216 ? \"C422p12<S2SV_blank>XYSCSS=422P12\\\\n\" : \"C420p12<S2SV_blank>XYSCSS=420P12\\\\n\" ; break ; case 14 : color = fmt == VPX_IMG_FMT_I44416 ? \"C444p14<S2SV_blank>XYSCSS=444P14\\\\n\" : fmt == VPX_IMG_FMT_I42216 ? \"C422p14<S2SV_blank>XYSCSS=422P14\\\\n\" : \"C420p14<S2SV_blank>XYSCSS=420P14\\\\n\" ; break ; case 16 : color = fmt == VPX_IMG_FMT_I44416 ? \"C444p16<S2SV_blank>XYSCSS=444P16\\\\n\" : fmt == VPX_IMG_FMT_I42216 ? \"C422p16<S2SV_blank>XYSCSS=422P16\\\\n\" : \"C420p16<S2SV_blank>XYSCSS=420P16\\\\n\" ; break ; default : color = NULL ; assert ( 0 ) ; }\n","project_and_commit_id":"external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426","cve_id":"CVE-2016-1621","original_address":"https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426","time":"2016-03-12T21:59Z"},
	{"Unnamed: 0":3632,"cwe_id":"CWE-125","source":"CWE-125 static Sdb * store_versioninfo_gnu_verneed ( ELFOBJ * bin , Elf_ ( Shdr ) * shdr , int sz ) { ut8 * end , * need = NULL ; const char * section_name = \"\" ; Elf_ ( Shdr ) * link_shdr = NULL ; const char * link_section_name = \"\" ; Sdb * sdb_vernaux = NULL ; Sdb * sdb_version = NULL ; Sdb * sdb = NULL ; int i , cnt ; if ( ! bin || ! bin -> dynstr ) { return NULL ; } if ( shdr -> sh_link > bin -> ehdr . e_shnum ) { return NULL ; } if ( shdr -> sh_size < 1 ) { return NULL ; } sdb = sdb_new0 ( ) ; if ( ! sdb ) { return NULL ; } link_shdr = & bin -> shdr [ shdr -> sh_link ] ; if ( bin -> shstrtab && shdr -> sh_name < bin -> shstrtab_size ) { section_name = & bin -> shstrtab [ shdr -> sh_name ] ; } if ( bin -> shstrtab && link_shdr -> sh_name < bin -> shstrtab_size ) { link_section_name = & bin -> shstrtab [ link_shdr -> sh_name ] ; } if ( ! ( need = ( ut8 * ) calloc ( R_MAX ( 1 , shdr -> sh_size ) , sizeof ( ut8 ) ) ) ) { bprintf ( \"Warning:<S2SV_blank>Cannot<S2SV_blank>allocate<S2SV_blank>memory<S2SV_blank>for<S2SV_blank>Elf_(Verneed)\\\\n\" ) ; goto beach ; } end = need + shdr -> sh_size ; sdb_set ( sdb , \"section_name\" , section_name , 0 ) ; sdb_num_set ( sdb , \"num_entries\" , shdr -> sh_info , 0 ) ; sdb_num_set ( sdb , \"addr\" , shdr -> sh_addr , 0 ) ; sdb_num_set ( sdb , \"offset\" , shdr -> sh_offset , 0 ) ; sdb_num_set ( sdb , \"link\" , shdr -> sh_link , 0 ) ; sdb_set ( sdb , \"link_section_name\" , link_section_name , 0 ) ; if ( shdr -> sh_offset > bin -> size || shdr -> sh_offset + shdr -> sh_size > bin -> size ) { goto beach ; } if ( shdr -> sh_offset + shdr -> sh_size < shdr -> sh_size ) { goto beach ; } i = r_buf_read_at ( bin -> b , shdr -> sh_offset , need , shdr -> sh_size ) ; if ( i < 0 ) goto beach ; for ( i = 0 , cnt = 0 ; cnt < shdr -> sh_info ; ++ cnt ) { int j , isum ; ut8 * vstart = need + i ; Elf_ ( Verneed ) vvn = { 0 } ; if ( vstart + sizeof ( Elf_ ( Verneed ) ) > end ) { goto beach ; } Elf_ ( Verneed ) * entry = & vvn ; char key [ 32 ] = { 0 } ; sdb_version = sdb_new0 ( ) ; if ( ! sdb_version ) { goto beach ; } j = 0 ; vvn . vn_version = READ16 ( vstart , j ) vvn . vn_cnt = READ16 ( vstart , j ) vvn . vn_file = READ32 ( vstart , j ) vvn . vn_aux = READ32 ( vstart , j ) vvn . vn_next = READ32 ( vstart , j ) sdb_num_set ( sdb_version , \"vn_version\" , entry -> vn_version , 0 ) ; sdb_num_set ( sdb_version , \"idx\" , i , 0 ) ; if ( entry -> vn_file > bin -> dynstr_size ) { goto beach ; } { char * s = r_str_ndup ( & bin -> dynstr [ entry -> vn_file ] , 16 ) ; sdb_set ( sdb_version , \"file_name\" , s , 0 ) ; free ( s ) ; } sdb_num_set ( sdb_version , \"cnt\" , entry -> vn_cnt , 0 ) ; <S2SV_StartBug> vstart += entry -> vn_aux ; <S2SV_EndBug> for ( j = 0 , isum = i + entry -> vn_aux ; j < entry -> vn_cnt && vstart + sizeof ( Elf_ ( Vernaux ) ) <= end ; ++ j ) { int k ; Elf_ ( Vernaux ) * aux = NULL ; Elf_ ( Vernaux ) vaux = { 0 } ; sdb_vernaux = sdb_new0 ( ) ; if ( ! sdb_vernaux ) { goto beach ; } aux = ( Elf_ ( Vernaux ) * ) & vaux ; k = 0 ; vaux . vna_hash = READ32 ( vstart , k ) vaux . vna_flags = READ16 ( vstart , k ) vaux . vna_other = READ16 ( vstart , k ) vaux . vna_name = READ32 ( vstart , k ) vaux . vna_next = READ32 ( vstart , k ) if ( aux -> vna_name > bin -> dynstr_size ) { goto beach ; } sdb_num_set ( sdb_vernaux , \"idx\" , isum , 0 ) ; if ( aux -> vna_name > 0 && aux -> vna_name + 8 < bin -> dynstr_size ) { char name [ 16 ] ; strncpy ( name , & bin -> dynstr [ aux -> vna_name ] , sizeof ( name ) - 1 ) ; name [ sizeof ( name ) - 1 ] = 0 ; sdb_set ( sdb_vernaux , \"name\" , name , 0 ) ; } sdb_set ( sdb_vernaux , \"flags\" , get_ver_flags ( aux -> vna_flags ) , 0 ) ; sdb_num_set ( sdb_vernaux , \"version\" , aux -> vna_other , 0 ) ; isum += aux -> vna_next ; vstart += aux -> vna_next ; snprintf ( key , sizeof ( key ) , \"vernaux%d\" , j ) ; sdb_ns_set ( sdb_version , key , sdb_vernaux ) ; } if ( ( int ) entry -> vn_next < 0 ) { bprintf ( \"Invalid<S2SV_blank>vn_next\\\\n\" ) ; break ; } i += entry -> vn_next ; snprintf ( key , sizeof ( key ) , \"version%d\" , cnt ) ; sdb_ns_set ( sdb , key , sdb_version ) ; if ( ! entry -> vn_next ) { break ; } } free ( need ) ; return sdb ; beach : free ( need ) ; sdb_free ( sdb_vernaux ) ; sdb_free ( sdb_version ) ; sdb_free ( sdb ) ; return NULL ; }\n","target":"<S2SV_ModStart> 0 ) ; st32 vnaux = entry -> vn_aux ; if ( vnaux < 1 ) { goto beach ; } vstart += vnaux <S2SV_ModEnd> ; for (\n","project_and_commit_id":"radare@radare2/c6d0076c924891ad9948a62d89d0bcdaf965f0cd","cve_id":"CVE-2017-15931","original_address":"https://github.com/radare/radare2/commit/c6d0076c924891ad9948a62d89d0bcdaf965f0cd","time":"2017-10-27T18:29Z"},
	{"Unnamed: 0":1368,"cwe_id":"CWE-172","source":"CWE-172 WORD32 ih264d_video_decode ( iv_obj_t * dec_hdl , void * pv_api_ip , void * pv_api_op ) { dec_struct_t * ps_dec = ( dec_struct_t * ) ( dec_hdl -> pv_codec_handle ) ; WORD32 i4_err_status = 0 ; UWORD8 * pu1_buf = NULL ; WORD32 buflen ; UWORD32 u4_max_ofst , u4_length_of_start_code = 0 ; UWORD32 bytes_consumed = 0 ; UWORD32 cur_slice_is_nonref = 0 ; UWORD32 u4_next_is_aud ; UWORD32 u4_first_start_code_found = 0 ; WORD32 ret = 0 , api_ret_value = IV_SUCCESS ; WORD32 header_data_left = 0 , frame_data_left = 0 ; UWORD8 * pu1_bitstrm_buf ; ivd_video_decode_ip_t * ps_dec_ip ; ivd_video_decode_op_t * ps_dec_op ; ithread_set_name ( ( void * ) \"Parse_thread\" ) ; ps_dec_ip = ( ivd_video_decode_ip_t * ) pv_api_ip ; ps_dec_op = ( ivd_video_decode_op_t * ) pv_api_op ; { UWORD32 u4_size ; u4_size = ps_dec_op -> u4_size ; memset ( ps_dec_op , 0 , sizeof ( ivd_video_decode_op_t ) ) ; ps_dec_op -> u4_size = u4_size ; } ps_dec -> pv_dec_out = ps_dec_op ; if ( ps_dec -> init_done != 1 ) { return IV_FAIL ; } DATA_SYNC ( ) ; if ( 0 == ps_dec -> u1_flushfrm ) { if ( ps_dec_ip -> pv_stream_buffer == NULL ) { ps_dec_op -> u4_error_code |= 1 << IVD_UNSUPPORTEDPARAM ; ps_dec_op -> u4_error_code |= IVD_DEC_FRM_BS_BUF_NULL ; return IV_FAIL ; } if ( ps_dec_ip -> u4_num_Bytes <= 0 ) { ps_dec_op -> u4_error_code |= 1 << IVD_UNSUPPORTEDPARAM ; ps_dec_op -> u4_error_code |= IVD_DEC_NUMBYTES_INV ; return IV_FAIL ; } } ps_dec -> u1_pic_decode_done = 0 ; ps_dec_op -> u4_num_bytes_consumed = 0 ; ps_dec -> ps_out_buffer = NULL ; if ( ps_dec_ip -> u4_size >= offsetof ( ivd_video_decode_ip_t , s_out_buffer ) ) ps_dec -> ps_out_buffer = & ps_dec_ip -> s_out_buffer ; ps_dec -> u4_fmt_conv_cur_row = 0 ; ps_dec -> u4_output_present = 0 ; ps_dec -> s_disp_op . u4_error_code = 1 ; ps_dec -> u4_fmt_conv_num_rows = FMT_CONV_NUM_ROWS ; if ( 0 == ps_dec -> u4_share_disp_buf && ps_dec -> i4_decode_header == 0 ) { UWORD32 i ; if ( ps_dec -> ps_out_buffer -> u4_num_bufs == 0 ) { ps_dec_op -> u4_error_code |= 1 << IVD_UNSUPPORTEDPARAM ; ps_dec_op -> u4_error_code |= IVD_DISP_FRM_ZERO_OP_BUFS ; return IV_FAIL ; } for ( i = 0 ; i < ps_dec -> ps_out_buffer -> u4_num_bufs ; i ++ ) { if ( ps_dec -> ps_out_buffer -> pu1_bufs [ i ] == NULL ) { ps_dec_op -> u4_error_code |= 1 << IVD_UNSUPPORTEDPARAM ; ps_dec_op -> u4_error_code |= IVD_DISP_FRM_OP_BUF_NULL ; return IV_FAIL ; } if ( ps_dec -> ps_out_buffer -> u4_min_out_buf_size [ i ] == 0 ) { ps_dec_op -> u4_error_code |= 1 << IVD_UNSUPPORTEDPARAM ; ps_dec_op -> u4_error_code |= IVD_DISP_FRM_ZERO_OP_BUF_SIZE ; return IV_FAIL ; } } } if ( ps_dec -> u4_total_frames_decoded >= NUM_FRAMES_LIMIT ) { ps_dec_op -> u4_error_code = ERROR_FRAME_LIMIT_OVER ; return IV_FAIL ; } ps_dec -> u4_ts = ps_dec_ip -> u4_ts ; ps_dec_op -> u4_error_code = 0 ; ps_dec_op -> e_pic_type = - 1 ; ps_dec_op -> u4_output_present = 0 ; ps_dec_op -> u4_frame_decoded_flag = 0 ; ps_dec -> i4_frametype = - 1 ; ps_dec -> i4_content_type = - 1 ; { if ( ( TOP_FIELD_ONLY | BOT_FIELD_ONLY ) == ps_dec -> u1_top_bottom_decoded ) { ps_dec -> u1_top_bottom_decoded = 0 ; } } ps_dec -> u4_slice_start_code_found = 0 ; if ( ps_dec -> u1_init_dec_flag == 1 && ps_dec -> u4_share_disp_buf == 1 && ps_dec -> u1_flushfrm == 0 ) { UWORD32 i ; WORD32 disp_avail = 0 , free_id ; for ( i = 0 ; i < ps_dec -> u1_pic_bufs ; i ++ ) { if ( 0 == ps_dec -> u4_disp_buf_mapping [ i ] || 1 == ps_dec -> u4_disp_buf_to_be_freed [ i ] ) { disp_avail = 1 ; break ; } } if ( 0 == disp_avail ) { ps_dec_op -> u4_error_code = IVD_DEC_REF_BUF_NULL ; ps_dec_op -> u4_error_code |= ( 1 << IVD_UNSUPPORTEDPARAM ) ; return ( IV_FAIL ) ; } while ( 1 ) { pic_buffer_t * ps_pic_buf ; ps_pic_buf = ( pic_buffer_t * ) ih264_buf_mgr_get_next_free ( ( buf_mgr_t * ) ps_dec -> pv_pic_buf_mgr , & free_id ) ; if ( ps_pic_buf == NULL ) { UWORD32 i , display_queued = 0 ; for ( i = 0 ; i < ( MAX_DISP_BUFS_NEW ) ; i ++ ) { if ( 0 != ps_dec -> u4_disp_buf_mapping [ i ] ) { display_queued = 1 ; break ; } } if ( 1 == display_queued ) { ps_dec_op -> u4_error_code = IVD_DEC_REF_BUF_NULL ; ps_dec_op -> u4_error_code |= ( 1 << IVD_UNSUPPORTEDPARAM ) ; return ( IV_FAIL ) ; } } else { if ( 1 == ps_dec -> u4_disp_buf_mapping [ free_id ] ) { ih264_buf_mgr_set_status ( ( buf_mgr_t * ) ps_dec -> pv_pic_buf_mgr , free_id , BUF_MGR_IO ) ; } else { ih264_buf_mgr_release ( ( buf_mgr_t * ) ps_dec -> pv_pic_buf_mgr , free_id , BUF_MGR_IO ) ; break ; } } } } if ( ps_dec -> u1_flushfrm && ps_dec -> u1_init_dec_flag ) { ih264d_get_next_display_field ( ps_dec , ps_dec -> ps_out_buffer , & ( ps_dec -> s_disp_op ) ) ; if ( 0 == ps_dec -> s_disp_op . u4_error_code ) { ps_dec -> u4_fmt_conv_cur_row = 0 ; ps_dec -> u4_fmt_conv_num_rows = ps_dec -> s_disp_frame_info . u4_y_ht ; ih264d_format_convert ( ps_dec , & ( ps_dec -> s_disp_op ) , ps_dec -> u4_fmt_conv_cur_row , ps_dec -> u4_fmt_conv_num_rows ) ; ps_dec -> u4_fmt_conv_cur_row += ps_dec -> u4_fmt_conv_num_rows ; ps_dec -> u4_output_present = 1 ; } ih264d_release_display_field ( ps_dec , & ( ps_dec -> s_disp_op ) ) ; ps_dec_op -> u4_pic_wd = ( UWORD32 ) ps_dec -> u2_disp_width ; ps_dec_op -> u4_pic_ht = ( UWORD32 ) ps_dec -> u2_disp_height ; ps_dec_op -> u4_new_seq = 0 ; ps_dec_op -> u4_output_present = ps_dec -> u4_output_present ; ps_dec_op -> u4_progressive_frame_flag = ps_dec -> s_disp_op . u4_progressive_frame_flag ; ps_dec_op -> e_output_format = ps_dec -> s_disp_op . e_output_format ; ps_dec_op -> s_disp_frm_buf = ps_dec -> s_disp_op . s_disp_frm_buf ; ps_dec_op -> e4_fld_type = ps_dec -> s_disp_op . e4_fld_type ; ps_dec_op -> u4_ts = ps_dec -> s_disp_op . u4_ts ; ps_dec_op -> u4_disp_buf_id = ps_dec -> s_disp_op . u4_disp_buf_id ; ps_dec_op -> u4_is_ref_flag = - 1 ; ps_dec_op -> e_pic_type = IV_NA_FRAME ; ps_dec_op -> u4_frame_decoded_flag = 0 ; if ( 0 == ps_dec -> s_disp_op . u4_error_code ) { return ( IV_SUCCESS ) ; } else return ( IV_FAIL ) ; } if ( ps_dec -> u1_res_changed == 1 ) { ih264d_init_decoder ( ps_dec ) ; } ps_dec -> u4_prev_nal_skipped = 0 ; ps_dec -> u2_cur_mb_addr = 0 ; ps_dec -> u2_total_mbs_coded = 0 ; ps_dec -> u2_cur_slice_num = 0 ; ps_dec -> cur_dec_mb_num = 0 ; ps_dec -> cur_recon_mb_num = 0 ; <S2SV_StartBug> ps_dec -> u4_first_slice_in_pic = 2 ; <S2SV_EndBug> ps_dec -> u1_slice_header_done = 0 ; ps_dec -> u1_dangling_field = 0 ; ps_dec -> u4_dec_thread_created = 0 ; ps_dec -> u4_bs_deblk_thread_created = 0 ; ps_dec -> u4_cur_bs_mb_num = 0 ; ps_dec -> u4_start_recon_deblk = 0 ; DEBUG_THREADS_PRINTF ( \"<S2SV_blank>Starting<S2SV_blank>process<S2SV_blank>call\\\\n\" ) ; ps_dec -> u4_pic_buf_got = 0 ; do { WORD32 buf_size ; pu1_buf = ( UWORD8 * ) ps_dec_ip -> pv_stream_buffer + ps_dec_op -> u4_num_bytes_consumed ; u4_max_ofst = ps_dec_ip -> u4_num_Bytes - ps_dec_op -> u4_num_bytes_consumed ; if ( ( NULL == ps_dec -> pu1_bits_buf_dynamic ) && ( ps_dec -> i4_header_decoded & 1 ) ) { WORD32 size ; void * pv_buf ; void * pv_mem_ctxt = ps_dec -> pv_mem_ctxt ; size = MAX ( 256000 , ps_dec -> u2_pic_wd * ps_dec -> u2_pic_ht * 3 / 2 ) ; pv_buf = ps_dec -> pf_aligned_alloc ( pv_mem_ctxt , 128 , size ) ; RETURN_IF ( ( NULL == pv_buf ) , IV_FAIL ) ; ps_dec -> pu1_bits_buf_dynamic = pv_buf ; ps_dec -> u4_dynamic_bits_buf_size = size ; } if ( ps_dec -> pu1_bits_buf_dynamic ) { pu1_bitstrm_buf = ps_dec -> pu1_bits_buf_dynamic ; buf_size = ps_dec -> u4_dynamic_bits_buf_size ; } else { pu1_bitstrm_buf = ps_dec -> pu1_bits_buf_static ; buf_size = ps_dec -> u4_static_bits_buf_size ; } u4_next_is_aud = 0 ; buflen = ih264d_find_start_code ( pu1_buf , 0 , u4_max_ofst , & u4_length_of_start_code , & u4_next_is_aud ) ; if ( buflen == - 1 ) buflen = 0 ; buflen = MIN ( buflen , buf_size ) ; bytes_consumed = buflen + u4_length_of_start_code ; ps_dec_op -> u4_num_bytes_consumed += bytes_consumed ; { UWORD8 u1_firstbyte , u1_nal_ref_idc ; if ( ps_dec -> i4_app_skip_mode == IVD_SKIP_B ) { u1_firstbyte = * ( pu1_buf + u4_length_of_start_code ) ; u1_nal_ref_idc = ( UWORD8 ) ( NAL_REF_IDC ( u1_firstbyte ) ) ; if ( u1_nal_ref_idc == 0 ) { cur_slice_is_nonref = 1 ; continue ; } else { if ( 1 == cur_slice_is_nonref ) { ps_dec_op -> u4_num_bytes_consumed -= bytes_consumed ; ps_dec_op -> e_pic_type = IV_B_FRAME ; ps_dec_op -> u4_error_code = IVD_DEC_FRM_SKIPPED ; ps_dec_op -> u4_error_code |= ( 1 << IVD_UNSUPPORTEDPARAM ) ; ps_dec_op -> u4_frame_decoded_flag = 0 ; ps_dec_op -> u4_size = sizeof ( ivd_video_decode_op_t ) ; ih264d_signal_decode_thread ( ps_dec ) ; if ( ps_dec -> u4_num_cores == 3 ) { ih264d_signal_bs_deblk_thread ( ps_dec ) ; } return ( IV_FAIL ) ; } } } } if ( buflen ) { memcpy ( pu1_bitstrm_buf , pu1_buf + u4_length_of_start_code , buflen ) ; if ( ( buflen + 8 ) < buf_size ) { memset ( pu1_bitstrm_buf + buflen , 0 , 8 ) ; } u4_first_start_code_found = 1 ; } else { if ( u4_first_start_code_found == 0 ) { ps_dec -> i4_error_code = ERROR_START_CODE_NOT_FOUND ; ps_dec_op -> u4_error_code |= 1 << IVD_INSUFFICIENTDATA ; if ( ps_dec -> u4_pic_buf_got == 0 ) { ih264d_fill_output_struct_from_context ( ps_dec , ps_dec_op ) ; ps_dec_op -> u4_error_code = ps_dec -> i4_error_code ; ps_dec_op -> u4_frame_decoded_flag = 0 ; return ( IV_FAIL ) ; } else { ps_dec -> u1_pic_decode_done = 1 ; continue ; } } else { frame_data_left = 0 ; continue ; } } ps_dec -> u4_return_to_app = 0 ; ret = ih264d_parse_nal_unit ( dec_hdl , ps_dec_op , pu1_bitstrm_buf , buflen ) ; if ( ret != OK ) { UWORD32 error = ih264d_map_error ( ret ) ; ps_dec_op -> u4_error_code = error | ret ; api_ret_value = IV_FAIL ; if ( ( ret == IVD_RES_CHANGED ) || ( ret == IVD_MEM_ALLOC_FAILED ) || ( ret == ERROR_UNAVAIL_PICBUF_T ) || ( ret == ERROR_UNAVAIL_MVBUF_T ) || ( ret == ERROR_INV_SPS_PPS_T ) ) { ps_dec -> u4_slice_start_code_found = 0 ; break ; } if ( ( ret == ERROR_INCOMPLETE_FRAME ) || ( ret == ERROR_DANGLING_FIELD_IN_PIC ) ) { ps_dec_op -> u4_num_bytes_consumed -= bytes_consumed ; api_ret_value = IV_FAIL ; break ; } if ( ret == ERROR_IN_LAST_SLICE_OF_PIC ) { api_ret_value = IV_FAIL ; break ; } } if ( ps_dec -> u4_return_to_app ) { ps_dec_op -> u4_num_bytes_consumed -= bytes_consumed ; ps_dec_op -> u4_error_code = IVD_DEC_FRM_SKIPPED ; ps_dec_op -> u4_error_code |= ( 1 << IVD_UNSUPPORTEDPARAM ) ; ps_dec_op -> u4_frame_decoded_flag = 0 ; ps_dec_op -> u4_size = sizeof ( ivd_video_decode_op_t ) ; ih264d_signal_decode_thread ( ps_dec ) ; if ( ps_dec -> u4_num_cores == 3 ) { ih264d_signal_bs_deblk_thread ( ps_dec ) ; } return ( IV_FAIL ) ; } header_data_left = ( ( ps_dec -> i4_decode_header == 1 ) && ( ps_dec -> i4_header_decoded != 3 ) && ( ps_dec_op -> u4_num_bytes_consumed < ps_dec_ip -> u4_num_Bytes ) ) ; frame_data_left = ( ( ( ps_dec -> i4_decode_header == 0 ) && ( ( ps_dec -> u1_pic_decode_done == 0 ) || ( u4_next_is_aud == 1 ) ) ) && ( ps_dec_op -> u4_num_bytes_consumed < ps_dec_ip -> u4_num_Bytes ) ) ; } while ( ( header_data_left == 1 ) || ( frame_data_left == 1 ) ) ; if ( ( ps_dec -> u4_slice_start_code_found == 1 ) && ( ret != IVD_MEM_ALLOC_FAILED ) && ps_dec -> u2_total_mbs_coded < ps_dec -> u2_frm_ht_in_mbs * ps_dec -> u2_frm_wd_in_mbs ) { WORD32 num_mb_skipped ; WORD32 prev_slice_err ; pocstruct_t temp_poc ; WORD32 ret1 ; num_mb_skipped = ( ps_dec -> u2_frm_ht_in_mbs * ps_dec -> u2_frm_wd_in_mbs ) - ps_dec -> u2_total_mbs_coded ; if ( ps_dec -> u4_first_slice_in_pic && ( ps_dec -> u4_pic_buf_got == 0 ) ) prev_slice_err = 1 ; else prev_slice_err = 2 ; ret1 = ih264d_mark_err_slice_skip ( ps_dec , num_mb_skipped , ps_dec -> u1_nal_unit_type == IDR_SLICE_NAL , ps_dec -> ps_cur_slice -> u2_frame_num , & temp_poc , prev_slice_err ) ; if ( ( ret1 == ERROR_UNAVAIL_PICBUF_T ) || ( ret1 == ERROR_UNAVAIL_MVBUF_T ) ) { return IV_FAIL ; } } if ( ( ret == IVD_RES_CHANGED ) || ( ret == IVD_MEM_ALLOC_FAILED ) || ( ret == ERROR_UNAVAIL_PICBUF_T ) || ( ret == ERROR_UNAVAIL_MVBUF_T ) || ( ret == ERROR_INV_SPS_PPS_T ) ) { ih264d_signal_decode_thread ( ps_dec ) ; if ( ps_dec -> u4_num_cores == 3 ) { ih264d_signal_bs_deblk_thread ( ps_dec ) ; } if ( ret == IVD_RES_CHANGED ) { ps_dec_op -> u4_num_bytes_consumed -= bytes_consumed ; } return IV_FAIL ; } if ( ps_dec -> u1_separate_parse ) { if ( ps_dec -> u4_num_cores == 2 ) { if ( ( ps_dec -> u4_nmb_deblk == 0 ) && ( ps_dec -> u4_start_recon_deblk == 1 ) && ( ps_dec -> ps_cur_sps -> u1_mb_aff_flag == 0 ) ) { UWORD32 u4_num_mbs , u4_max_addr ; tfr_ctxt_t s_tfr_ctxt ; tfr_ctxt_t * ps_tfr_cxt = & s_tfr_ctxt ; pad_mgr_t * ps_pad_mgr = & ps_dec -> s_pad_mgr ; u4_max_addr = ( ps_dec -> u2_frm_wd_in_mbs * ps_dec -> u2_frm_ht_in_mbs ) - 1 ; ps_dec -> u4_cur_bs_mb_num = u4_max_addr + 1 ; ih264d_init_deblk_tfr_ctxt ( ps_dec , ps_pad_mgr , ps_tfr_cxt , ps_dec -> u2_frm_wd_in_mbs , 0 ) ; u4_num_mbs = u4_max_addr - ps_dec -> u4_cur_deblk_mb_num + 1 ; DEBUG_PERF_PRINTF ( \"mbs<S2SV_blank>left<S2SV_blank>for<S2SV_blank>deblocking=<S2SV_blank>%d<S2SV_blank>\\\\n\" , u4_num_mbs ) ; if ( u4_num_mbs != 0 ) ih264d_check_mb_map_deblk ( ps_dec , u4_num_mbs , ps_tfr_cxt , 1 ) ; ps_dec -> u4_start_recon_deblk = 0 ; } } ih264d_signal_decode_thread ( ps_dec ) ; if ( ps_dec -> u4_num_cores == 3 ) { ih264d_signal_bs_deblk_thread ( ps_dec ) ; } } DATA_SYNC ( ) ; if ( ( ps_dec_op -> u4_error_code & 0xff ) != ERROR_DYNAMIC_RESOLUTION_NOT_SUPPORTED ) { ps_dec_op -> u4_pic_wd = ( UWORD32 ) ps_dec -> u2_disp_width ; ps_dec_op -> u4_pic_ht = ( UWORD32 ) ps_dec -> u2_disp_height ; } if ( ps_dec -> i4_header_decoded != 3 ) { ps_dec_op -> u4_error_code |= ( 1 << IVD_INSUFFICIENTDATA ) ; } if ( ps_dec -> i4_decode_header == 1 && ps_dec -> i4_header_decoded != 3 ) { ps_dec_op -> u4_error_code |= ( 1 << IVD_INSUFFICIENTDATA ) ; } if ( ps_dec -> u4_prev_nal_skipped ) { ps_dec_op -> u4_error_code = IVD_DEC_FRM_SKIPPED ; ps_dec_op -> u4_error_code |= ( 1 << IVD_UNSUPPORTEDPARAM ) ; ps_dec_op -> u4_frame_decoded_flag = 0 ; ps_dec_op -> u4_size = sizeof ( ivd_video_decode_op_t ) ; if ( ps_dec -> u4_num_cores == 3 ) { ih264d_signal_bs_deblk_thread ( ps_dec ) ; } return ( IV_FAIL ) ; } if ( ( ps_dec -> u4_slice_start_code_found == 1 ) && ( ERROR_DANGLING_FIELD_IN_PIC != i4_err_status ) ) { if ( ps_dec -> ps_cur_slice -> u1_field_pic_flag ) { if ( 1 == ps_dec -> ps_cur_slice -> u1_bottom_field_flag ) { ps_dec -> u1_top_bottom_decoded |= BOT_FIELD_ONLY ; } else { ps_dec -> u1_top_bottom_decoded |= TOP_FIELD_ONLY ; } } if ( ( ps_dec -> ps_dec_err_status -> u1_err_flag & REJECT_CUR_PIC ) == 0 ) { ret = ih264d_deblock_display ( ps_dec ) ; if ( ret != 0 ) { return IV_FAIL ; } } if ( ps_dec -> i4_header_decoded == 3 ) { ps_dec -> u2_total_mbs_coded = ps_dec -> ps_cur_sps -> u2_max_mb_addr + 1 ; } if ( ps_dec -> ps_cur_slice -> u1_nal_unit_type == IDR_SLICE_NAL ) { ps_dec -> i4_frametype = IV_IDR_FRAME ; } else if ( ps_dec -> i4_pic_type == B_SLICE ) { ps_dec -> i4_frametype = IV_B_FRAME ; } else if ( ps_dec -> i4_pic_type == P_SLICE ) { ps_dec -> i4_frametype = IV_P_FRAME ; } else if ( ps_dec -> i4_pic_type == I_SLICE ) { ps_dec -> i4_frametype = IV_I_FRAME ; } else { H264_DEC_DEBUG_PRINT ( \"Shouldn\\'t<S2SV_blank>come<S2SV_blank>here\\\\n\" ) ; } ps_dec -> i4_content_type = ps_dec -> ps_cur_slice -> u1_field_pic_flag ; ps_dec -> u4_total_frames_decoded = ps_dec -> u4_total_frames_decoded + 2 ; ps_dec -> u4_total_frames_decoded = ps_dec -> u4_total_frames_decoded - ps_dec -> ps_cur_slice -> u1_field_pic_flag ; } if ( ps_dec -> u4_num_cores == 3 ) { ih264d_signal_bs_deblk_thread ( ps_dec ) ; } { if ( ( IVD_DECODE_FRAME_OUT == ps_dec -> e_frm_out_mode ) && ps_dec -> u1_init_dec_flag ) { ih264d_get_next_display_field ( ps_dec , ps_dec -> ps_out_buffer , & ( ps_dec -> s_disp_op ) ) ; if ( 0 == ps_dec -> s_disp_op . u4_error_code ) { ps_dec -> u4_fmt_conv_cur_row = 0 ; ps_dec -> u4_output_present = 1 ; } } ih264d_fill_output_struct_from_context ( ps_dec , ps_dec_op ) ; if ( ps_dec -> u4_output_present && ( ps_dec -> u4_fmt_conv_cur_row < ps_dec -> s_disp_frame_info . u4_y_ht ) ) { ps_dec -> u4_fmt_conv_num_rows = ps_dec -> s_disp_frame_info . u4_y_ht - ps_dec -> u4_fmt_conv_cur_row ; ih264d_format_convert ( ps_dec , & ( ps_dec -> s_disp_op ) , ps_dec -> u4_fmt_conv_cur_row , ps_dec -> u4_fmt_conv_num_rows ) ; ps_dec -> u4_fmt_conv_cur_row += ps_dec -> u4_fmt_conv_num_rows ; } ih264d_release_display_field ( ps_dec , & ( ps_dec -> s_disp_op ) ) ; } if ( ps_dec -> i4_decode_header == 1 && ( ps_dec -> i4_header_decoded & 1 ) == 1 ) { ps_dec_op -> u4_progressive_frame_flag = 1 ; if ( ( NULL != ps_dec -> ps_cur_sps ) && ( 1 == ( ps_dec -> ps_cur_sps -> u1_is_valid ) ) ) { if ( ( 0 == ps_dec -> ps_sps -> u1_frame_mbs_only_flag ) && ( 0 == ps_dec -> ps_sps -> u1_mb_aff_flag ) ) ps_dec_op -> u4_progressive_frame_flag = 0 ; } } DATA_SYNC ( ) ; H264_DEC_DEBUG_PRINT ( \"The<S2SV_blank>num<S2SV_blank>bytes<S2SV_blank>consumed:<S2SV_blank>%d\\\\n\" , ps_dec_op -> u4_num_bytes_consumed ) ; return api_ret_value ; }\n","target":"<S2SV_ModStart> u4_first_slice_in_pic = 2 ; ps_dec -> u1_first_pb_nal_in_pic = 1\n","project_and_commit_id":"external@libavc/326fe991a4b7971e8aeaf4ac775491dd8abd85bb","cve_id":"CVE-2016-3829","original_address":"https://android.googlesource.com/platform/external/libavc/+/326fe991a4b7971e8aeaf4ac775491dd8abd85bb","time":"2016-08-05T20:59Z"},
	{"Unnamed: 0":6451,"cwe_id":"CWE-617","source":"CWE-617 static int pci_emul_mem_handler ( struct vmctx * ctx , int vcpu , int dir , uint64_t addr , int size , uint64_t * val , void * arg1 , long arg2 ) { struct pci_vdev * pdi = arg1 ; struct pci_vdev_ops * ops = pdi -> dev_ops ; uint64_t offset ; int bidx = ( int ) arg2 ; <S2SV_StartBug> assert ( bidx <= PCI_BARMAX ) ; <S2SV_EndBug> <S2SV_StartBug> assert ( pdi -> bar [ bidx ] . type == PCIBAR_MEM32 || <S2SV_EndBug> <S2SV_StartBug> pdi -> bar [ bidx ] . type == PCIBAR_MEM64 ) ; <S2SV_EndBug> assert ( addr >= pdi -> bar [ bidx ] . addr && addr + size <= pdi -> bar [ bidx ] . addr + pdi -> bar [ bidx ] . size ) ; offset = addr - pdi -> bar [ bidx ] . addr ; if ( dir == MEM_F_WRITE ) { if ( size == 8 ) { ( * ops -> vdev_barwrite ) ( ctx , vcpu , pdi , bidx , offset , 4 , * val & 0xffffffff ) ; ( * ops -> vdev_barwrite ) ( ctx , vcpu , pdi , bidx , offset + 4 , 4 , * val >> 32 ) ; } else { ( * ops -> vdev_barwrite ) ( ctx , vcpu , pdi , bidx , offset , size , bar_value ( size , * val ) ) ; } } else { if ( size == 8 ) { uint64_t val_lo , val_hi ; val_lo = ( * ops -> vdev_barread ) ( ctx , vcpu , pdi , bidx , offset , 4 ) ; val_lo = bar_value ( 4 , val_lo ) ; val_hi = ( * ops -> vdev_barread ) ( ctx , vcpu , pdi , bidx , offset + 4 , 4 ) ; * val = val_lo | ( val_hi << 32 ) ; } else { * val = ( * ops -> vdev_barread ) ( ctx , vcpu , pdi , bidx , offset , size ) ; * val = bar_value ( size , * val ) ; } } return 0 ; }\n","target":"<S2SV_ModStart> ) arg2 ; if ( addr + size > <S2SV_ModEnd> pdi -> bar <S2SV_ModStart> bidx ] . addr + <S2SV_ModEnd> pdi -> bar <S2SV_ModStart> bidx ] . size ) { printf ( \"%s,<S2SV_blank>Out<S2SV_blank>of<S2SV_blank>emulated<S2SV_blank>memory<S2SV_blank>range.\\\\n\" , __func__ ) ; return - ESRCH ; } <S2SV_ModEnd> offset = addr\n","project_and_commit_id":"projectacrn@acrn-hypervisor/6199e653418eda58cd698d8769820904453e2535","cve_id":"CVE-2019-18844","original_address":"https://github.com/projectacrn/acrn-hypervisor/commit/6199e653418eda58cd698d8769820904453e2535","time":"2019-11-13T20:15Z"},
	{"Unnamed: 0":6637,"cwe_id":"CWE-125","source":"CWE-125 static mrb_value fiber_switch ( mrb_state * mrb , mrb_value self , mrb_int len , const mrb_value * a , mrb_bool resume , mrb_bool vmexec ) { struct mrb_context * c = fiber_check ( mrb , self ) ; struct mrb_context * old_c = mrb -> c ; <S2SV_StartBug> mrb_value value ; <S2SV_EndBug> <S2SV_StartBug> fiber_check_cfunc ( mrb , c ) ; <S2SV_EndBug> <S2SV_StartBug> if ( resume && c -> status == MRB_FIBER_TRANSFERRED ) { <S2SV_EndBug> mrb_raise ( mrb , E_FIBER_ERROR , \"resuming<S2SV_blank>transferred<S2SV_blank>fiber\" ) ; } <S2SV_StartBug> if ( c -> status == MRB_FIBER_RUNNING || c -> status == MRB_FIBER_RESUMED ) { <S2SV_EndBug> mrb_raise ( mrb , E_FIBER_ERROR , \"double<S2SV_blank>resume<S2SV_blank>(fib)\" ) ; } <S2SV_StartBug> if ( c -> status == MRB_FIBER_TERMINATED ) { <S2SV_EndBug> mrb_raise ( mrb , E_FIBER_ERROR , \"resuming<S2SV_blank>dead<S2SV_blank>fiber\" ) ; } <S2SV_StartBug> mrb -> c -> status = resume ? MRB_FIBER_RESUMED : MRB_FIBER_TRANSFERRED ; <S2SV_EndBug> c -> prev = resume ? mrb -> c : ( c -> prev ? c -> prev : mrb -> root_c ) ; <S2SV_StartBug> if ( c -> status == MRB_FIBER_CREATED ) { <S2SV_EndBug> mrb_value * b , * e ; <S2SV_StartBug> if ( len >= c -> stend - c -> stack ) { <S2SV_EndBug> mrb_raise ( mrb , E_FIBER_ERROR , \"too<S2SV_blank>many<S2SV_blank>arguments<S2SV_blank>to<S2SV_blank>fiber\" ) ; } b = c -> stack + 1 ; e = b + len ; while ( b < e ) { * b ++ = * a ++ ; } c -> cibase -> argc = ( int ) len ; value = c -> stack [ 0 ] = MRB_PROC_ENV ( c -> ci -> proc ) -> stack [ 0 ] ; } else { value = fiber_result ( mrb , a , len ) ; } <S2SV_StartBug> fiber_switch_context ( mrb , c ) ; <S2SV_EndBug> if ( vmexec ) { c -> vmexec = TRUE ; value = mrb_vm_exec ( mrb , c -> ci [ - 1 ] . proc , c -> ci -> pc ) ; mrb -> c = old_c ; } else { MARK_CONTEXT_MODIFY ( c ) ; } return value ; }\n","target":"<S2SV_ModStart> -> c ; enum mrb_fiber_state status ; <S2SV_ModStart> , c ) ; status = c -> status <S2SV_ModStart> ( resume && <S2SV_ModEnd> status == MRB_FIBER_TRANSFERRED <S2SV_ModStart> } if ( <S2SV_ModEnd> status == MRB_FIBER_RUNNING <S2SV_ModStart> == MRB_FIBER_RUNNING || <S2SV_ModEnd> status == MRB_FIBER_RESUMED <S2SV_ModStart> } if ( <S2SV_ModEnd> status == MRB_FIBER_TERMINATED <S2SV_ModStart> ) ; } old_c <S2SV_ModEnd> -> status = <S2SV_ModStart> root_c ) ; fiber_switch_context ( mrb , c ) ; if ( <S2SV_ModEnd> status == MRB_FIBER_CREATED <S2SV_ModStart> * e ; mrb_stack_extend ( mrb , len + 2 ) ; <S2SV_ModEnd> b = c <S2SV_ModStart> ) ; } <S2SV_ModEnd> if ( vmexec\n","project_and_commit_id":"mruby@mruby/778500563a9f7ceba996937dc886bd8cde29b42b","cve_id":"CVE-2018-12248","original_address":"https://github.com/mruby/mruby/commit/778500563a9f7ceba996937dc886bd8cde29b42b","time":"2018-06-12T14:29Z"},
	{"Unnamed: 0":2743,"cwe_id":"CWE-125","source":"CWE-125 struct r_bin_dyldcache_obj_t * r_bin_dyldcache_from_bytes_new ( const ut8 * buf , ut64 size ) { <S2SV_StartBug> struct r_bin_dyldcache_obj_t * bin ; <S2SV_EndBug> <S2SV_StartBug> if ( ! ( bin = malloc ( sizeof ( struct r_bin_dyldcache_obj_t ) ) ) ) { <S2SV_EndBug> return NULL ; } <S2SV_StartBug> memset ( bin , 0 , sizeof ( struct r_bin_dyldcache_obj_t ) ) ; <S2SV_EndBug> if ( ! buf ) { return r_bin_dyldcache_free ( bin ) ; } bin -> b = r_buf_new ( ) ; <S2SV_StartBug> if ( ! r_buf_set_bytes ( bin -> b , buf , size ) ) { <S2SV_EndBug> return r_bin_dyldcache_free ( bin ) ; } if ( ! r_bin_dyldcache_init ( bin ) ) { return r_bin_dyldcache_free ( bin ) ; } bin -> size = size ; return bin ; }\n","target":"<S2SV_ModStart> r_bin_dyldcache_obj_t * bin = R_NEW0 ( struct r_bin_dyldcache_obj_t ) <S2SV_ModStart> if ( ! bin <S2SV_ModEnd> ) { return <S2SV_ModStart> NULL ; } <S2SV_ModEnd> if ( ! <S2SV_ModStart> ; if ( ! bin -> b ||\n","project_and_commit_id":"radare@radare2/4e98402f09a0ef0bb8559a33a4c1988c54938eaf","cve_id":"CVE-2018-20458","original_address":"https://github.com/radare/radare2/commit/4e98402f09a0ef0bb8559a33a4c1988c54938eaf","time":"2018-12-25T19:29Z"},
	{"Unnamed: 0":6184,"cwe_id":"CWE-476","source":"CWE-476 void * sspi_SecureHandleGetUpperPointer ( SecHandle * handle ) { void * pointer ; <S2SV_StartBug> if ( ! handle ) <S2SV_EndBug> return NULL ; pointer = ( void * ) ~ ( ( size_t ) handle -> dwUpper ) ; return pointer ; }\n","target":"<S2SV_ModStart> ( ! handle || ! SecIsValidHandle ( handle )\n","project_and_commit_id":"FreeRDP@FreeRDP/0773bb9303d24473fe1185d85a424dfe159aff53","cve_id":"CVE-2013-4119","original_address":"https://github.com/FreeRDP/FreeRDP/commit/0773bb9303d24473fe1185d85a424dfe159aff53","time":"2016-10-03T21:59Z"},
	{"Unnamed: 0":6563,"cwe_id":"CWE-119","source":"CWE-119 cJSON * cJSON_DetachItemFromArray ( cJSON * array , int which ) { cJSON * c = array -> child ; <S2SV_StartBug> while ( c && which > 0 ) { <S2SV_EndBug> <S2SV_StartBug> c = c -> next ; <S2SV_EndBug> -- which ; } if ( ! c ) return 0 ; if ( c -> prev ) c -> prev -> next = c -> next ; if ( c -> next ) c -> next -> prev = c -> prev ; if ( c == array -> child ) array -> child = c -> next ; c -> prev = c -> next = 0 ; return c ; }\n","target":"<S2SV_ModStart> > 0 ) <S2SV_ModEnd> c = c <S2SV_ModStart> c -> next , which -- ; <S2SV_ModEnd> if ( !\n","project_and_commit_id":"esnet@iperf/91f2fa59e8ed80dfbf400add0164ee0e508e412a","cve_id":"CVE-2016-4303","original_address":"https://github.com/esnet/iperf/commit/91f2fa59e8ed80dfbf400add0164ee0e508e412a","time":"2016-09-26T14:59Z"},
	{"Unnamed: 0":2247,"cwe_id":"CWE-200","source":"CWE-200 int raptor_turtle_writer_set_option ( raptor_turtle_writer * turtle_writer , raptor_option option , int value ) { if ( value < 0 || ! raptor_option_is_valid_for_area ( option , RAPTOR_OPTION_AREA_TURTLE_WRITER ) ) return 1 ; switch ( option ) { case RAPTOR_OPTION_WRITER_AUTO_INDENT : if ( value ) turtle_writer -> flags |= TURTLE_WRITER_AUTO_INDENT ; else turtle_writer -> flags &= ~ TURTLE_WRITER_AUTO_INDENT ; break ; case RAPTOR_OPTION_WRITER_INDENT_WIDTH : turtle_writer -> indent = value ; break ; case RAPTOR_OPTION_WRITER_AUTO_EMPTY : case RAPTOR_OPTION_WRITER_XML_VERSION : case RAPTOR_OPTION_WRITER_XML_DECLARATION : break ; case RAPTOR_OPTION_SCANNING : case RAPTOR_OPTION_ALLOW_NON_NS_ATTRIBUTES : case RAPTOR_OPTION_ALLOW_OTHER_PARSETYPES : case RAPTOR_OPTION_ALLOW_BAGID : case RAPTOR_OPTION_ALLOW_RDF_TYPE_RDF_LIST : case RAPTOR_OPTION_NORMALIZE_LANGUAGE : case RAPTOR_OPTION_NON_NFC_FATAL : case RAPTOR_OPTION_WARN_OTHER_PARSETYPES : case RAPTOR_OPTION_CHECK_RDF_ID : case RAPTOR_OPTION_HTML_TAG_SOUP : case RAPTOR_OPTION_MICROFORMATS : case RAPTOR_OPTION_HTML_LINK : case RAPTOR_OPTION_WWW_TIMEOUT : case RAPTOR_OPTION_STRICT : case RAPTOR_OPTION_NO_NET : case RAPTOR_OPTION_NO_FILE : <S2SV_StartBug> case RAPTOR_OPTION_RELATIVE_URIS : <S2SV_EndBug> case RAPTOR_OPTION_RESOURCE_BORDER : case RAPTOR_OPTION_LITERAL_BORDER : case RAPTOR_OPTION_BNODE_BORDER : case RAPTOR_OPTION_RESOURCE_FILL : case RAPTOR_OPTION_LITERAL_FILL : case RAPTOR_OPTION_BNODE_FILL : case RAPTOR_OPTION_JSON_CALLBACK : case RAPTOR_OPTION_JSON_EXTRA_DATA : case RAPTOR_OPTION_RSS_TRIPLES : case RAPTOR_OPTION_ATOM_ENTRY_URI : case RAPTOR_OPTION_PREFIX_ELEMENTS : case RAPTOR_OPTION_WRITE_BASE_URI : case RAPTOR_OPTION_WWW_HTTP_CACHE_CONTROL : case RAPTOR_OPTION_WWW_HTTP_USER_AGENT : case RAPTOR_OPTION_WWW_CERT_FILENAME : case RAPTOR_OPTION_WWW_CERT_TYPE : case RAPTOR_OPTION_WWW_CERT_PASSPHRASE : case RAPTOR_OPTION_WWW_SSL_VERIFY_PEER : case RAPTOR_OPTION_WWW_SSL_VERIFY_HOST : default : return - 1 ; break ; } return 0 ; }\n","target":"<S2SV_ModStart> RAPTOR_OPTION_NO_FILE : case RAPTOR_OPTION_LOAD_EXTERNAL_ENTITIES : case\n","project_and_commit_id":"dajobe@raptor/a676f235309a59d4aa78eeffd2574ae5d341fcb0","cve_id":"CVE-2012-0037","original_address":"https://github.com/dajobe/raptor/commit/a676f235309a59d4aa78eeffd2574ae5d341fcb0","time":"2012-06-17T03:41Z"},
	{"Unnamed: 0":2465,"cwe_id":"CWE-908","source":"CWE-908 int ParseCaffHeaderConfig ( FILE * infile , char * infilename , char * fourcc , WavpackContext * wpc , WavpackConfig * config ) { <S2SV_StartBug> uint32_t chan_chunk = 0 , channel_layout = 0 , bcount ; <S2SV_EndBug> unsigned char * channel_identities = NULL ; unsigned char * channel_reorder = NULL ; int64_t total_samples = 0 , infilesize ; CAFFileHeader caf_file_header ; CAFChunkHeader caf_chunk_header ; CAFAudioFormat caf_audio_format ; int i ; infilesize = DoGetFileSize ( infile ) ; memcpy ( & caf_file_header , fourcc , 4 ) ; if ( ( ! DoReadFile ( infile , ( ( char * ) & caf_file_header ) + 4 , sizeof ( CAFFileHeader ) - 4 , & bcount ) || bcount != sizeof ( CAFFileHeader ) - 4 ) ) { error_line ( \"%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>.CAF<S2SV_blank>file!\" , infilename ) ; return WAVPACK_SOFT_ERROR ; } else if ( ! ( config -> qmode & QMODE_NO_STORE_WRAPPER ) && ! WavpackAddWrapper ( wpc , & caf_file_header , sizeof ( CAFFileHeader ) ) ) { error_line ( \"%s\" , WavpackGetErrorMessage ( wpc ) ) ; return WAVPACK_SOFT_ERROR ; } WavpackBigEndianToNative ( & caf_file_header , CAFFileHeaderFormat ) ; if ( caf_file_header . mFileVersion != 1 ) { error_line ( \"%s:<S2SV_blank>can\\'t<S2SV_blank>handle<S2SV_blank>version<S2SV_blank>%d<S2SV_blank>.CAF<S2SV_blank>files!\" , infilename , caf_file_header . mFileVersion ) ; return WAVPACK_SOFT_ERROR ; } while ( 1 ) { if ( ! DoReadFile ( infile , & caf_chunk_header , sizeof ( CAFChunkHeader ) , & bcount ) || bcount != sizeof ( CAFChunkHeader ) ) { error_line ( \"%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>.CAF<S2SV_blank>file!\" , infilename ) ; return WAVPACK_SOFT_ERROR ; } else if ( ! ( config -> qmode & QMODE_NO_STORE_WRAPPER ) && ! WavpackAddWrapper ( wpc , & caf_chunk_header , sizeof ( CAFChunkHeader ) ) ) { error_line ( \"%s\" , WavpackGetErrorMessage ( wpc ) ) ; return WAVPACK_SOFT_ERROR ; } WavpackBigEndianToNative ( & caf_chunk_header , CAFChunkHeaderFormat ) ; if ( ! strncmp ( caf_chunk_header . mChunkType , \"desc\" , 4 ) ) { int supported = TRUE ; if ( caf_chunk_header . mChunkSize != sizeof ( CAFAudioFormat ) || ! DoReadFile ( infile , & caf_audio_format , ( uint32_t ) caf_chunk_header . mChunkSize , & bcount ) || bcount != caf_chunk_header . mChunkSize ) { error_line ( \"%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>.CAF<S2SV_blank>file!\" , infilename ) ; return WAVPACK_SOFT_ERROR ; } else if ( ! ( config -> qmode & QMODE_NO_STORE_WRAPPER ) && ! WavpackAddWrapper ( wpc , & caf_audio_format , ( uint32_t ) caf_chunk_header . mChunkSize ) ) { error_line ( \"%s\" , WavpackGetErrorMessage ( wpc ) ) ; return WAVPACK_SOFT_ERROR ; } <S2SV_StartBug> WavpackBigEndianToNative ( & caf_audio_format , CAFAudioFormatFormat ) ; <S2SV_EndBug> if ( debug_logging_mode ) { char formatstr [ 5 ] ; memcpy ( formatstr , caf_audio_format . mFormatID , 4 ) ; formatstr [ 4 ] = 0 ; error_line ( \"format<S2SV_blank>=<S2SV_blank>%s,<S2SV_blank>flags<S2SV_blank>=<S2SV_blank>%x,<S2SV_blank>sampling<S2SV_blank>rate<S2SV_blank>=<S2SV_blank>%g\" , formatstr , caf_audio_format . mFormatFlags , caf_audio_format . mSampleRate ) ; error_line ( \"packet<S2SV_blank>=<S2SV_blank>%d<S2SV_blank>bytes<S2SV_blank>and<S2SV_blank>%d<S2SV_blank>frames\" , caf_audio_format . mBytesPerPacket , caf_audio_format . mFramesPerPacket ) ; error_line ( \"channels<S2SV_blank>per<S2SV_blank>frame<S2SV_blank>=<S2SV_blank>%d,<S2SV_blank>bits<S2SV_blank>per<S2SV_blank>channel<S2SV_blank>=<S2SV_blank>%d\" , caf_audio_format . mChannelsPerFrame , caf_audio_format . mBitsPerChannel ) ; } if ( strncmp ( caf_audio_format . mFormatID , \"lpcm\" , 4 ) || ( caf_audio_format . mFormatFlags & ~ 3 ) ) supported = FALSE ; else if ( caf_audio_format . mSampleRate < 1.0 || caf_audio_format . mSampleRate > 16777215.0 || caf_audio_format . mSampleRate != floor ( caf_audio_format . mSampleRate ) ) supported = FALSE ; else if ( ! caf_audio_format . mChannelsPerFrame || caf_audio_format . mChannelsPerFrame > 256 ) supported = FALSE ; else if ( caf_audio_format . mBitsPerChannel < 1 || caf_audio_format . mBitsPerChannel > 32 || ( ( caf_audio_format . mFormatFlags & CAF_FORMAT_FLOAT ) && caf_audio_format . mBitsPerChannel != 32 ) ) supported = FALSE ; else if ( caf_audio_format . mFramesPerPacket != 1 || caf_audio_format . mBytesPerPacket / caf_audio_format . mChannelsPerFrame < ( caf_audio_format . mBitsPerChannel + 7 ) / 8 || caf_audio_format . mBytesPerPacket / caf_audio_format . mChannelsPerFrame > 4 || caf_audio_format . mBytesPerPacket % caf_audio_format . mChannelsPerFrame ) supported = FALSE ; if ( ! supported ) { error_line ( \"%s<S2SV_blank>is<S2SV_blank>an<S2SV_blank>unsupported<S2SV_blank>.CAF<S2SV_blank>format!\" , infilename ) ; return WAVPACK_SOFT_ERROR ; } config -> bytes_per_sample = caf_audio_format . mBytesPerPacket / caf_audio_format . mChannelsPerFrame ; config -> float_norm_exp = ( caf_audio_format . mFormatFlags & CAF_FORMAT_FLOAT ) ? 127 : 0 ; config -> bits_per_sample = caf_audio_format . mBitsPerChannel ; config -> num_channels = caf_audio_format . mChannelsPerFrame ; config -> sample_rate = ( int ) caf_audio_format . mSampleRate ; if ( ! ( caf_audio_format . mFormatFlags & CAF_FORMAT_LITTLE_ENDIAN ) && config -> bytes_per_sample > 1 ) config -> qmode |= QMODE_BIG_ENDIAN ; if ( config -> bytes_per_sample == 1 ) config -> qmode |= QMODE_SIGNED_BYTES ; if ( debug_logging_mode ) { if ( config -> float_norm_exp == 127 ) error_line ( \"data<S2SV_blank>format:<S2SV_blank>32-bit<S2SV_blank>%s-endian<S2SV_blank>floating<S2SV_blank>point\" , ( config -> qmode & QMODE_BIG_ENDIAN ) ? \"big\" : \"little\" ) ; else error_line ( \"data<S2SV_blank>format:<S2SV_blank>%d-bit<S2SV_blank>%s-endian<S2SV_blank>integers<S2SV_blank>stored<S2SV_blank>in<S2SV_blank>%d<S2SV_blank>byte(s)\" , config -> bits_per_sample , ( config -> qmode & QMODE_BIG_ENDIAN ) ? \"big\" : \"little\" , config -> bytes_per_sample ) ; } } else if ( ! strncmp ( caf_chunk_header . mChunkType , \"chan\" , 4 ) ) { CAFChannelLayout * caf_channel_layout ; if ( caf_chunk_header . mChunkSize < 0 || caf_chunk_header . mChunkSize > 1024 || caf_chunk_header . mChunkSize < sizeof ( CAFChannelLayout ) ) { error_line ( \"this<S2SV_blank>.CAF<S2SV_blank>file<S2SV_blank>has<S2SV_blank>an<S2SV_blank>invalid<S2SV_blank>\\'chan\\'<S2SV_blank>chunk!\" ) ; return WAVPACK_SOFT_ERROR ; } if ( debug_logging_mode ) error_line ( \"\\'chan\\'<S2SV_blank>chunk<S2SV_blank>is<S2SV_blank>%d<S2SV_blank>bytes\" , ( int ) caf_chunk_header . mChunkSize ) ; caf_channel_layout = malloc ( ( size_t ) caf_chunk_header . mChunkSize ) ; if ( ! DoReadFile ( infile , caf_channel_layout , ( uint32_t ) caf_chunk_header . mChunkSize , & bcount ) || bcount != caf_chunk_header . mChunkSize ) { error_line ( \"%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>.CAF<S2SV_blank>file!\" , infilename ) ; free ( caf_channel_layout ) ; return WAVPACK_SOFT_ERROR ; } else if ( ! ( config -> qmode & QMODE_NO_STORE_WRAPPER ) && ! WavpackAddWrapper ( wpc , caf_channel_layout , ( uint32_t ) caf_chunk_header . mChunkSize ) ) { error_line ( \"%s\" , WavpackGetErrorMessage ( wpc ) ) ; free ( caf_channel_layout ) ; return WAVPACK_SOFT_ERROR ; } WavpackBigEndianToNative ( caf_channel_layout , CAFChannelLayoutFormat ) ; chan_chunk = 1 ; if ( config -> channel_mask || ( config -> qmode & QMODE_CHANS_UNASSIGNED ) ) { error_line ( \"this<S2SV_blank>CAF<S2SV_blank>file<S2SV_blank>already<S2SV_blank>has<S2SV_blank>channel<S2SV_blank>order<S2SV_blank>information!\" ) ; free ( caf_channel_layout ) ; return WAVPACK_SOFT_ERROR ; } switch ( caf_channel_layout -> mChannelLayoutTag ) { case kCAFChannelLayoutTag_UseChannelDescriptions : { CAFChannelDescription * descriptions = ( CAFChannelDescription * ) ( caf_channel_layout + 1 ) ; int num_descriptions = caf_channel_layout -> mNumberChannelDescriptions ; int label , cindex = 0 , idents = 0 ; if ( caf_chunk_header . mChunkSize != sizeof ( CAFChannelLayout ) + sizeof ( CAFChannelDescription ) * num_descriptions || num_descriptions != config -> num_channels ) { error_line ( \"channel<S2SV_blank>descriptions<S2SV_blank>in<S2SV_blank>\\'chan\\'<S2SV_blank>chunk<S2SV_blank>are<S2SV_blank>the<S2SV_blank>wrong<S2SV_blank>size!\" ) ; free ( caf_channel_layout ) ; return WAVPACK_SOFT_ERROR ; } if ( num_descriptions >= 256 ) { error_line ( \"%d<S2SV_blank>channel<S2SV_blank>descriptions<S2SV_blank>is<S2SV_blank>more<S2SV_blank>than<S2SV_blank>we<S2SV_blank>can<S2SV_blank>handle...ignoring!\" ) ; break ; } channel_reorder = malloc ( num_descriptions ) ; memset ( channel_reorder , - 1 , num_descriptions ) ; channel_identities = malloc ( num_descriptions + 1 ) ; for ( i = 0 ; i < num_descriptions ; ++ i ) { WavpackBigEndianToNative ( descriptions + i , CAFChannelDescriptionFormat ) ; if ( debug_logging_mode ) error_line ( \"chan<S2SV_blank>%d<S2SV_blank>--><S2SV_blank>%d\" , i + 1 , descriptions [ i ] . mChannelLabel ) ; } for ( label = 1 ; label <= 18 ; ++ label ) for ( i = 0 ; i < num_descriptions ; ++ i ) if ( descriptions [ i ] . mChannelLabel == label ) { config -> channel_mask |= 1 << ( label - 1 ) ; channel_reorder [ i ] = cindex ++ ; break ; } for ( i = 0 ; i < num_descriptions ; ++ i ) if ( channel_reorder [ i ] == ( unsigned char ) - 1 ) { uint32_t clabel = descriptions [ i ] . mChannelLabel ; if ( clabel == 0 || clabel == 0xffffffff || clabel == 100 ) channel_identities [ idents ++ ] = 0xff ; else if ( ( clabel >= 33 && clabel <= 44 ) || ( clabel >= 200 && clabel <= 207 ) || ( clabel >= 301 && clabel <= 305 ) ) channel_identities [ idents ++ ] = clabel >= 301 ? clabel - 80 : clabel ; else { error_line ( \"warning:<S2SV_blank>unknown<S2SV_blank>channel<S2SV_blank>descriptions<S2SV_blank>label:<S2SV_blank>%d\" , clabel ) ; channel_identities [ idents ++ ] = 0xff ; } channel_reorder [ i ] = cindex ++ ; } for ( i = 0 ; i < num_descriptions ; ++ i ) if ( channel_reorder [ i ] != i ) break ; if ( i == num_descriptions ) { free ( channel_reorder ) ; channel_reorder = NULL ; } else { config -> qmode |= QMODE_REORDERED_CHANS ; channel_layout = num_descriptions ; } if ( ! idents ) { free ( channel_identities ) ; channel_identities = NULL ; } else channel_identities [ idents ] = 0 ; if ( debug_logging_mode ) { error_line ( \"layout_tag<S2SV_blank>=<S2SV_blank>0x%08x,<S2SV_blank>so<S2SV_blank>generated<S2SV_blank>bitmap<S2SV_blank>of<S2SV_blank>0x%08x<S2SV_blank>from<S2SV_blank>%d<S2SV_blank>descriptions,<S2SV_blank>%d<S2SV_blank>non-MS\" , caf_channel_layout -> mChannelLayoutTag , config -> channel_mask , caf_channel_layout -> mNumberChannelDescriptions , idents ) ; if ( channel_reorder && num_descriptions <= 8 ) { char reorder_string [ ] = \"12345678\" ; for ( i = 0 ; i < num_descriptions ; ++ i ) reorder_string [ i ] = channel_reorder [ i ] + '1' ; reorder_string [ i ] = 0 ; error_line ( \"reordering<S2SV_blank>string<S2SV_blank>=<S2SV_blank>\\\\\"%s\\\\\"\\\\n\" , reorder_string ) ; } } } break ; case kCAFChannelLayoutTag_UseChannelBitmap : config -> channel_mask = caf_channel_layout -> mChannelBitmap ; if ( debug_logging_mode ) error_line ( \"layout_tag<S2SV_blank>=<S2SV_blank>0x%08x,<S2SV_blank>so<S2SV_blank>using<S2SV_blank>supplied<S2SV_blank>bitmap<S2SV_blank>of<S2SV_blank>0x%08x\" , caf_channel_layout -> mChannelLayoutTag , caf_channel_layout -> mChannelBitmap ) ; break ; default : for ( i = 0 ; i < NUM_LAYOUTS ; ++ i ) if ( caf_channel_layout -> mChannelLayoutTag == layouts [ i ] . mChannelLayoutTag ) { config -> channel_mask = layouts [ i ] . mChannelBitmap ; channel_layout = layouts [ i ] . mChannelLayoutTag ; if ( layouts [ i ] . mChannelReorder ) { channel_reorder = ( unsigned char * ) strdup ( layouts [ i ] . mChannelReorder ) ; config -> qmode |= QMODE_REORDERED_CHANS ; } if ( layouts [ i ] . mChannelIdentities ) channel_identities = ( unsigned char * ) strdup ( layouts [ i ] . mChannelIdentities ) ; if ( debug_logging_mode ) error_line ( \"layout_tag<S2SV_blank>0x%08x<S2SV_blank>found<S2SV_blank>in<S2SV_blank>table,<S2SV_blank>bitmap<S2SV_blank>=<S2SV_blank>0x%08x,<S2SV_blank>reorder<S2SV_blank>=<S2SV_blank>%s,<S2SV_blank>identities<S2SV_blank>=<S2SV_blank>%s\" , channel_layout , config -> channel_mask , channel_reorder ? \"yes\" : \"no\" , channel_identities ? \"yes\" : \"no\" ) ; break ; } if ( i == NUM_LAYOUTS && debug_logging_mode ) error_line ( \"layout_tag<S2SV_blank>0x%08x<S2SV_blank>not<S2SV_blank>found<S2SV_blank>in<S2SV_blank>table...all<S2SV_blank>channels<S2SV_blank>unassigned\" , caf_channel_layout -> mChannelLayoutTag ) ; break ; } free ( caf_channel_layout ) ; } else if ( ! strncmp ( caf_chunk_header . mChunkType , \"data\" , 4 ) ) { uint32_t mEditCount ; <S2SV_StartBug> if ( ! DoReadFile ( infile , & mEditCount , sizeof ( mEditCount ) , & bcount ) || <S2SV_EndBug> bcount != sizeof ( mEditCount ) ) { error_line ( \"%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>.CAF<S2SV_blank>file!\" , infilename ) ; return WAVPACK_SOFT_ERROR ; } else if ( ! ( config -> qmode & QMODE_NO_STORE_WRAPPER ) && ! WavpackAddWrapper ( wpc , & mEditCount , sizeof ( mEditCount ) ) ) { error_line ( \"%s\" , WavpackGetErrorMessage ( wpc ) ) ; return WAVPACK_SOFT_ERROR ; } if ( ( config -> qmode & QMODE_IGNORE_LENGTH ) || caf_chunk_header . mChunkSize == - 1 ) { config -> qmode |= QMODE_IGNORE_LENGTH ; if ( infilesize && DoGetFilePosition ( infile ) != - 1 ) total_samples = ( infilesize - DoGetFilePosition ( infile ) ) / caf_audio_format . mBytesPerPacket ; else total_samples = - 1 ; } else { if ( infilesize && infilesize - caf_chunk_header . mChunkSize > 16777216 ) { error_line ( \".CAF<S2SV_blank>file<S2SV_blank>%s<S2SV_blank>has<S2SV_blank>over<S2SV_blank>16<S2SV_blank>MB<S2SV_blank>of<S2SV_blank>extra<S2SV_blank>CAFF<S2SV_blank>data,<S2SV_blank>probably<S2SV_blank>is<S2SV_blank>corrupt!\" , infilename ) ; return WAVPACK_SOFT_ERROR ; } if ( ( caf_chunk_header . mChunkSize - 4 ) % caf_audio_format . mBytesPerPacket ) { error_line ( \".CAF<S2SV_blank>file<S2SV_blank>%s<S2SV_blank>has<S2SV_blank>an<S2SV_blank>invalid<S2SV_blank>data<S2SV_blank>chunk<S2SV_blank>size,<S2SV_blank>probably<S2SV_blank>is<S2SV_blank>corrupt!\" , infilename ) ; return WAVPACK_SOFT_ERROR ; } total_samples = ( caf_chunk_header . mChunkSize - 4 ) / caf_audio_format . mBytesPerPacket ; if ( ! total_samples ) { error_line ( \"this<S2SV_blank>.CAF<S2SV_blank>file<S2SV_blank>has<S2SV_blank>no<S2SV_blank>audio<S2SV_blank>samples,<S2SV_blank>probably<S2SV_blank>is<S2SV_blank>corrupt!\" ) ; return WAVPACK_SOFT_ERROR ; } if ( total_samples > MAX_WAVPACK_SAMPLES ) { error_line ( \"%s<S2SV_blank>has<S2SV_blank>too<S2SV_blank>many<S2SV_blank>samples<S2SV_blank>for<S2SV_blank>WavPack!\" , infilename ) ; return WAVPACK_SOFT_ERROR ; } } break ; } else { uint32_t bytes_to_copy = ( uint32_t ) caf_chunk_header . mChunkSize ; char * buff ; if ( caf_chunk_header . mChunkSize < 0 || caf_chunk_header . mChunkSize > 1048576 ) { error_line ( \"%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>.CAF<S2SV_blank>file!\" , infilename ) ; return WAVPACK_SOFT_ERROR ; } buff = malloc ( bytes_to_copy ) ; if ( debug_logging_mode ) error_line ( \"extra<S2SV_blank>unknown<S2SV_blank>chunk<S2SV_blank>\\\\\"%c%c%c%c\\\\\"<S2SV_blank>of<S2SV_blank>%d<S2SV_blank>bytes\" , caf_chunk_header . mChunkType [ 0 ] , caf_chunk_header . mChunkType [ 1 ] , caf_chunk_header . mChunkType [ 2 ] , caf_chunk_header . mChunkType [ 3 ] , caf_chunk_header . mChunkSize ) ; if ( ! DoReadFile ( infile , buff , bytes_to_copy , & bcount ) || bcount != bytes_to_copy || ( ! ( config -> qmode & QMODE_NO_STORE_WRAPPER ) && ! WavpackAddWrapper ( wpc , buff , bytes_to_copy ) ) ) { error_line ( \"%s\" , WavpackGetErrorMessage ( wpc ) ) ; free ( buff ) ; return WAVPACK_SOFT_ERROR ; } free ( buff ) ; } } if ( ! chan_chunk && ! config -> channel_mask && config -> num_channels <= 2 && ! ( config -> qmode & QMODE_CHANS_UNASSIGNED ) ) config -> channel_mask = 0x5 - config -> num_channels ; if ( ! WavpackSetConfiguration64 ( wpc , config , total_samples , channel_identities ) ) { error_line ( \"%s\" , WavpackGetErrorMessage ( wpc ) ) ; return WAVPACK_SOFT_ERROR ; } if ( channel_identities ) free ( channel_identities ) ; if ( channel_layout || channel_reorder ) { if ( ! WavpackSetChannelLayout ( wpc , channel_layout , channel_reorder ) ) { error_line ( \"problem<S2SV_blank>with<S2SV_blank>setting<S2SV_blank>channel<S2SV_blank>layout<S2SV_blank>(should<S2SV_blank>not<S2SV_blank>happen)\" ) ; return WAVPACK_SOFT_ERROR ; } if ( channel_reorder ) free ( channel_reorder ) ; } return WAVPACK_NO_ERROR ; }\n","target":"<S2SV_ModStart> { uint32_t chan_chunk = 0 , desc_chunk <S2SV_ModStart> , CAFAudioFormatFormat ) ; desc_chunk = 1 <S2SV_ModStart> if ( ! desc_chunk || !\n","project_and_commit_id":"dbry@WavPack/f68a9555b548306c5b1ee45199ccdc4a16a6101b","cve_id":"CVE-2019-1010317","original_address":"https://github.com/dbry/WavPack/commit/f68a9555b548306c5b1ee45199ccdc4a16a6101b","time":"2019-07-11T20:15Z"},
	{"Unnamed: 0":5145,"cwe_id":"CWE-125","source":"CWE-125 int ff_mms_asf_header_parser ( MMSContext * mms ) { uint8_t * p = mms -> asf_header ; uint8_t * end ; int flags , stream_id ; mms -> stream_num = 0 ; if ( mms -> asf_header_size < sizeof ( ff_asf_guid ) * 2 + 22 || memcmp ( p , ff_asf_header , sizeof ( ff_asf_guid ) ) ) { av_log ( NULL , AV_LOG_ERROR , \"Corrupt<S2SV_blank>stream<S2SV_blank>(invalid<S2SV_blank>ASF<S2SV_blank>header,<S2SV_blank>size=%d)\\\\n\" , mms -> asf_header_size ) ; return AVERROR_INVALIDDATA ; } end = mms -> asf_header + mms -> asf_header_size ; p += sizeof ( ff_asf_guid ) + 14 ; while ( end - p >= sizeof ( ff_asf_guid ) + 8 ) { uint64_t chunksize ; if ( ! memcmp ( p , ff_asf_data_header , sizeof ( ff_asf_guid ) ) ) { chunksize = 50 ; } else { chunksize = AV_RL64 ( p + sizeof ( ff_asf_guid ) ) ; } if ( ! chunksize || chunksize > end - p ) { av_log ( NULL , AV_LOG_ERROR , \"Corrupt<S2SV_blank>stream<S2SV_blank>(header<S2SV_blank>chunksize<S2SV_blank>%\" PRId64 \"<S2SV_blank>is<S2SV_blank>invalid)\\\\n\" , chunksize ) ; return AVERROR_INVALIDDATA ; } if ( ! memcmp ( p , ff_asf_file_header , sizeof ( ff_asf_guid ) ) ) { if ( end - p > sizeof ( ff_asf_guid ) * 2 + 68 ) { mms -> asf_packet_len = AV_RL32 ( p + sizeof ( ff_asf_guid ) * 2 + 64 ) ; if ( mms -> asf_packet_len <= 0 || mms -> asf_packet_len > sizeof ( mms -> in_buffer ) ) { av_log ( NULL , AV_LOG_ERROR , \"Corrupt<S2SV_blank>stream<S2SV_blank>(too<S2SV_blank>large<S2SV_blank>pkt_len<S2SV_blank>%d)\\\\n\" , mms -> asf_packet_len ) ; return AVERROR_INVALIDDATA ; } } } else if ( ! memcmp ( p , ff_asf_stream_header , sizeof ( ff_asf_guid ) ) ) { <S2SV_StartBug> flags = AV_RL16 ( p + sizeof ( ff_asf_guid ) * 3 + 24 ) ; <S2SV_EndBug> stream_id = flags & 0x7F ; if ( mms -> stream_num < MMS_MAX_STREAMS && 46 + mms -> stream_num * 6 < sizeof ( mms -> out_buffer ) ) { mms -> streams = av_fast_realloc ( mms -> streams , & mms -> nb_streams_allocated , ( mms -> stream_num + 1 ) * sizeof ( MMSStream ) ) ; if ( ! mms -> streams ) return AVERROR ( ENOMEM ) ; mms -> streams [ mms -> stream_num ] . id = stream_id ; mms -> stream_num ++ ; } else { av_log ( NULL , AV_LOG_ERROR , \"Corrupt<S2SV_blank>stream<S2SV_blank>(too<S2SV_blank>many<S2SV_blank>A/V<S2SV_blank>streams)\\\\n\" ) ; return AVERROR_INVALIDDATA ; } <S2SV_StartBug> } else if ( ! memcmp ( p , ff_asf_ext_stream_header , sizeof ( ff_asf_guid ) ) ) { <S2SV_EndBug> if ( end - p >= 88 ) { int stream_count = AV_RL16 ( p + 84 ) , ext_len_count = AV_RL16 ( p + 86 ) ; uint64_t skip_bytes = 88 ; while ( stream_count -- ) { if ( end - p < skip_bytes + 4 ) { av_log ( NULL , AV_LOG_ERROR , \"Corrupt<S2SV_blank>stream<S2SV_blank>(next<S2SV_blank>stream<S2SV_blank>name<S2SV_blank>length<S2SV_blank>is<S2SV_blank>not<S2SV_blank>in<S2SV_blank>the<S2SV_blank>buffer)\\\\n\" ) ; return AVERROR_INVALIDDATA ; } skip_bytes += 4 + AV_RL16 ( p + skip_bytes + 2 ) ; } while ( ext_len_count -- ) { if ( end - p < skip_bytes + 22 ) { av_log ( NULL , AV_LOG_ERROR , \"Corrupt<S2SV_blank>stream<S2SV_blank>(next<S2SV_blank>extension<S2SV_blank>system<S2SV_blank>info<S2SV_blank>length<S2SV_blank>is<S2SV_blank>not<S2SV_blank>in<S2SV_blank>the<S2SV_blank>buffer)\\\\n\" ) ; return AVERROR_INVALIDDATA ; } skip_bytes += 22 + AV_RL32 ( p + skip_bytes + 18 ) ; } if ( end - p < skip_bytes ) { av_log ( NULL , AV_LOG_ERROR , \"Corrupt<S2SV_blank>stream<S2SV_blank>(the<S2SV_blank>last<S2SV_blank>extension<S2SV_blank>system<S2SV_blank>info<S2SV_blank>length<S2SV_blank>is<S2SV_blank>invalid)\\\\n\" ) ; return AVERROR_INVALIDDATA ; } if ( chunksize - skip_bytes > 24 ) chunksize = skip_bytes ; } } else if ( ! memcmp ( p , ff_asf_head1_guid , sizeof ( ff_asf_guid ) ) ) { chunksize = 46 ; <S2SV_StartBug> } <S2SV_EndBug> p += chunksize ; } return 0 ; }\n","target":"<S2SV_ModStart> ) ) { if ( end - p >= ( sizeof ( ff_asf_guid ) * 3 + 26 ) ) { <S2SV_ModStart> ; } } } <S2SV_ModStart> = 46 ; if ( chunksize > end - p ) { av_log ( NULL , AV_LOG_ERROR , \"Corrupt<S2SV_blank>stream<S2SV_blank>(header<S2SV_blank>chunksize<S2SV_blank>%\" PRId64 \"<S2SV_blank>is<S2SV_blank>invalid)\\\\n\" , chunksize ) ; return AVERROR_INVALIDDATA ; }\n","project_and_commit_id":"FFmpeg@FFmpeg/cced03dd667a5df6df8fd40d8de0bff477ee02e8","cve_id":"CVE-2018-1999010","original_address":"https://github.com/FFmpeg/FFmpeg/commit/cced03dd667a5df6df8fd40d8de0bff477ee02e8","time":"2018-07-23T15:29Z"},
	{"Unnamed: 0":2894,"cwe_id":"CWE-415","source":"CWE-415 void * gdImageWBMPPtr ( gdImagePtr im , int * size , int fg ) { void * rv ; gdIOCtx * out = gdNewDynamicCtx ( 2048 , NULL ) ; <S2SV_StartBug> gdImageWBMPCtx ( im , fg , out ) ; <S2SV_EndBug> <S2SV_StartBug> rv = gdDPExtractData ( out , size ) ; <S2SV_EndBug> out -> gd_free ( out ) ; return rv ; }\n","target":"<S2SV_ModStart> NULL ) ; if ( ! _gdImageWBMPCtx <S2SV_ModEnd> ( im , <S2SV_ModStart> , out ) ) { <S2SV_ModEnd> rv = gdDPExtractData <S2SV_ModStart> size ) ; } else { rv = NULL ; }\n","project_and_commit_id":"php@php-src/089f7c0bc28d399b0420aa6ef058e4c1c120b2ae","cve_id":"CVE-2019-6978","original_address":"https://github.com/php/php-src/commit/089f7c0bc28d399b0420aa6ef058e4c1c120b2ae","time":"2019-01-28T08:29Z"},
	{"Unnamed: 0":4824,"cwe_id":"CWE-416","source":"CWE-416 int SMB2_write ( const unsigned int xid , struct cifs_io_parms * io_parms , unsigned int * nbytes , struct kvec * iov , int n_vec ) { struct smb_rqst rqst ; int rc = 0 ; struct smb2_write_req * req = NULL ; struct smb2_write_rsp * rsp = NULL ; int resp_buftype ; struct kvec rsp_iov ; int flags = 0 ; unsigned int total_len ; * nbytes = 0 ; if ( n_vec < 1 ) return rc ; rc = smb2_plain_req_init ( SMB2_WRITE , io_parms -> tcon , ( void * * ) & req , & total_len ) ; if ( rc ) return rc ; if ( io_parms -> tcon -> ses -> server == NULL ) return - ECONNABORTED ; if ( smb3_encryption_required ( io_parms -> tcon ) ) flags |= CIFS_TRANSFORM_REQ ; req -> sync_hdr . ProcessId = cpu_to_le32 ( io_parms -> pid ) ; req -> PersistentFileId = io_parms -> persistent_fid ; req -> VolatileFileId = io_parms -> volatile_fid ; req -> WriteChannelInfoOffset = 0 ; req -> WriteChannelInfoLength = 0 ; req -> Channel = 0 ; req -> Length = cpu_to_le32 ( io_parms -> length ) ; req -> Offset = cpu_to_le64 ( io_parms -> offset ) ; req -> DataOffset = cpu_to_le16 ( offsetof ( struct smb2_write_req , Buffer ) ) ; req -> RemainingBytes = 0 ; trace_smb3_write_enter ( xid , io_parms -> persistent_fid , io_parms -> tcon -> tid , io_parms -> tcon -> ses -> Suid , io_parms -> offset , io_parms -> length ) ; iov [ 0 ] . iov_base = ( char * ) req ; iov [ 0 ] . iov_len = total_len - 1 ; memset ( & rqst , 0 , sizeof ( struct smb_rqst ) ) ; rqst . rq_iov = iov ; rqst . rq_nvec = n_vec + 1 ; rc = cifs_send_recv ( xid , io_parms -> tcon -> ses , & rqst , & resp_buftype , flags , & rsp_iov ) ; <S2SV_StartBug> cifs_small_buf_release ( req ) ; <S2SV_EndBug> rsp = ( struct smb2_write_rsp * ) rsp_iov . iov_base ; if ( rc ) { trace_smb3_write_err ( xid , req -> PersistentFileId , io_parms -> tcon -> tid , io_parms -> tcon -> ses -> Suid , io_parms -> offset , io_parms -> length , rc ) ; cifs_stats_fail_inc ( io_parms -> tcon , SMB2_WRITE_HE ) ; cifs_dbg ( VFS , \"Send<S2SV_blank>error<S2SV_blank>in<S2SV_blank>write<S2SV_blank>=<S2SV_blank>%d\\\\n\" , rc ) ; } else { * nbytes = le32_to_cpu ( rsp -> DataLength ) ; trace_smb3_write_done ( xid , req -> PersistentFileId , io_parms -> tcon -> tid , io_parms -> tcon -> ses -> Suid , io_parms -> offset , * nbytes ) ; } <S2SV_StartBug> free_rsp_buf ( resp_buftype , rsp ) ; <S2SV_EndBug> return rc ; }\n","target":"<S2SV_ModStart> rsp_iov ) ; <S2SV_ModEnd> rsp = ( <S2SV_ModStart> ) ; } cifs_small_buf_release ( req ) ;\n","project_and_commit_id":"torvalds@linux/6a3eb3360667170988f8a6477f6686242061488a","cve_id":"CVE-2019-15919","original_address":"https://github.com/torvalds/linux/commit/6a3eb3360667170988f8a6477f6686242061488a","time":"2019-09-04T19:15Z"},
	{"Unnamed: 0":4892,"cwe_id":"CWE-362","source":"CWE-362 <S2SV_StartBug> int ip_options_get ( struct net * net , struct ip_options * * optp , <S2SV_EndBug> unsigned char * data , int optlen ) { <S2SV_StartBug> struct ip_options * opt = ip_options_get_alloc ( optlen ) ; <S2SV_EndBug> if ( ! opt ) return - ENOMEM ; if ( optlen ) <S2SV_StartBug> memcpy ( opt -> __data , data , optlen ) ; <S2SV_EndBug> return ip_options_get_finish ( net , optp , opt , optlen ) ; }\n","target":"<S2SV_ModStart> net , struct ip_options_rcu <S2SV_ModEnd> * * optp <S2SV_ModStart> ) { struct ip_options_rcu <S2SV_ModEnd> * opt = <S2SV_ModStart> ( opt -> opt .\n","project_and_commit_id":"torvalds@linux/f6d8bd051c391c1c0458a30b2a7abcd939329259","cve_id":"CVE-2012-3552","original_address":"https://github.com/torvalds/linux/commit/f6d8bd051c391c1c0458a30b2a7abcd939329259","time":"2012-10-03T11:02Z"},
	{"Unnamed: 0":1301,"cwe_id":"CWE-119","source":"CWE-119 static int r_core_cmd_subst_i ( RCore * core , char * cmd , char * colon ) { const char * quotestr = \"`\" ; const char * tick = NULL ; char * ptr , * ptr2 , * str ; char * arroba = NULL ; int i , ret = 0 , pipefd ; bool usemyblock = false ; int scr_html = - 1 ; int scr_color = - 1 ; bool eos = false ; bool haveQuote = false ; if ( ! cmd ) { return 0 ; } cmd = r_str_trim_head_tail ( cmd ) ; switch ( * cmd ) { case '.' : if ( cmd [ 1 ] == \\'\"\\' ) { return r_cmd_call ( core -> rcmd , cmd ) ; } break ; case \\'\"\\' : for ( ; * cmd ; ) { int pipefd = - 1 ; ut64 oseek = UT64_MAX ; char * line , * p ; haveQuote = * cmd == \\'\"\\' ; if ( haveQuote ) { cmd ++ ; <S2SV_StartBug> p = find_eoq ( cmd + 1 ) ; <S2SV_EndBug> if ( ! p || ! * p ) { eprintf ( \"Missing<S2SV_blank>\\\\\"<S2SV_blank>in<S2SV_blank>(%s).\" , cmd ) ; return false ; } * p ++ = 0 ; if ( ! * p ) { eos = true ; } } else { char * sc = strchr ( cmd , ';' ) ; if ( sc ) { * sc = 0 ; } r_core_cmd0 ( core , cmd ) ; if ( ! sc ) { break ; } cmd = sc + 1 ; continue ; } if ( p [ 0 ] ) { if ( p [ 0 ] == '@' ) { p -- ; } while ( p [ 1 ] == ';' || IS_WHITESPACE ( p [ 1 ] ) ) { p ++ ; } if ( p [ 1 ] == '@' || ( p [ 1 ] && p [ 2 ] == '@' ) ) { char * q = strchr ( p + 1 , \\'\"\\' ) ; if ( q ) { * q = 0 ; } haveQuote = q != NULL ; oseek = core -> offset ; r_core_seek ( core , r_num_math ( core -> num , p + 2 ) , 1 ) ; if ( q ) { * p = \\'\"\\' ; p = q ; } else { p = strchr ( p + 1 , ';' ) ; } } if ( p && * p && p [ 1 ] == '>' ) { str = p + 2 ; while ( * str == '>' ) { str ++ ; } while ( IS_WHITESPACE ( * str ) ) { str ++ ; } r_cons_flush ( ) ; pipefd = r_cons_pipe_open ( str , 1 , p [ 2 ] == '>' ) ; } } line = strdup ( cmd ) ; line = r_str_replace ( line , \"\\\\\\\\\\\\\"\" , \"\\\\\"\" , true ) ; if ( p && * p && p [ 1 ] == '|' ) { str = p + 2 ; while ( IS_WHITESPACE ( * str ) ) { str ++ ; } r_core_cmd_pipe ( core , cmd , str ) ; } else { r_cmd_call ( core -> rcmd , line ) ; } free ( line ) ; if ( oseek != UT64_MAX ) { r_core_seek ( core , oseek , 1 ) ; oseek = UT64_MAX ; } if ( pipefd != - 1 ) { r_cons_flush ( ) ; r_cons_pipe_close ( pipefd ) ; } if ( ! p ) { break ; } if ( eos ) { break ; } if ( haveQuote ) { if ( * p == ';' ) { cmd = p + 1 ; } else { if ( * p == \\'\"\\' ) { cmd = p + 1 ; } else { * p = \\'\"\\' ; cmd = p ; } } } else { cmd = p + 1 ; } } return true ; case '(' : if ( cmd [ 1 ] != '*' ) { return r_cmd_call ( core -> rcmd , cmd ) ; } } if ( * cmd != '#' ) { ptr = ( char * ) r_str_lastbut ( cmd , '#' , quotestr ) ; if ( ptr && ( ptr [ 1 ] == '<S2SV_blank>' || ptr [ 1 ] == '\\\\t' ) ) { * ptr = '\\\\0' ; } } if ( * cmd != '#' ) { ptr = ( char * ) r_str_lastbut ( cmd , ';' , quotestr ) ; if ( colon && ptr ) { int ret ; * ptr = '\\\\0' ; if ( r_core_cmd_subst ( core , cmd ) == - 1 ) { return - 1 ; } cmd = ptr + 1 ; ret = r_core_cmd_subst ( core , cmd ) ; * ptr = ';' ; return ret ; } } ptr = ( char * ) r_str_lastbut ( cmd , '|' , quotestr ) ; if ( ptr ) { char * ptr2 = strchr ( cmd , '`' ) ; if ( ! ptr2 || ( ptr2 && ptr2 > ptr ) ) { if ( ! tick || ( tick && tick > ptr ) ) { * ptr = '\\\\0' ; cmd = r_str_clean ( cmd ) ; if ( ! strcmp ( ptr + 1 , \"?\" ) ) { eprintf ( \"Usage:<S2SV_blank><r2command><S2SV_blank>|<S2SV_blank><program|H|>\\\\n\" ) ; eprintf ( \"<S2SV_blank>pd|?<S2SV_blank><S2SV_blank><S2SV_blank>-<S2SV_blank>show<S2SV_blank>this<S2SV_blank>help\\\\n\" ) ; eprintf ( \"<S2SV_blank>pd|<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>-<S2SV_blank>disable<S2SV_blank>scr.html<S2SV_blank>and<S2SV_blank>scr.color\\\\n\" ) ; eprintf ( \"<S2SV_blank>pd|H<S2SV_blank><S2SV_blank><S2SV_blank>-<S2SV_blank>enable<S2SV_blank>scr.html,<S2SV_blank>respect<S2SV_blank>scr.color\\\\n\" ) ; return ret ; } else if ( ! strcmp ( ptr + 1 , \"H\" ) ) { scr_html = r_config_get_i ( core -> config , \"scr.html\" ) ; r_config_set_i ( core -> config , \"scr.html\" , true ) ; } else if ( ptr [ 1 ] ) { int value = core -> num -> value ; if ( * cmd ) { r_core_cmd_pipe ( core , cmd , ptr + 1 ) ; } else { r_io_system ( core -> io , ptr + 1 ) ; } core -> num -> value = value ; return 0 ; } else { scr_html = r_config_get_i ( core -> config , \"scr.html\" ) ; r_config_set_i ( core -> config , \"scr.html\" , 0 ) ; scr_color = r_config_get_i ( core -> config , \"scr.color\" ) ; r_config_set_i ( core -> config , \"scr.color\" , false ) ; } } } } ptr = ( char * ) r_str_lastbut ( cmd , '&' , quotestr ) ; while ( ptr && ptr [ 1 ] == '&' ) { * ptr = '\\\\0' ; ret = r_cmd_call ( core -> rcmd , cmd ) ; if ( ret == - 1 ) { eprintf ( \"command<S2SV_blank>error(%s)\\\\n\" , cmd ) ; if ( scr_html != - 1 ) { r_config_set_i ( core -> config , \"scr.html\" , scr_html ) ; } if ( scr_color != - 1 ) { r_config_set_i ( core -> config , \"scr.color\" , scr_color ) ; } return ret ; } for ( cmd = ptr + 2 ; cmd && * cmd == '<S2SV_blank>' ; cmd ++ ) ; ptr = strchr ( cmd , '&' ) ; } free ( core -> oobi ) ; core -> oobi = NULL ; ptr = strstr ( cmd , \"?*\" ) ; if ( ptr ) { char * prech = ptr - 1 ; if ( * prech != '~' ) { ptr [ 1 ] = 0 ; if ( * cmd != '#' && strlen ( cmd ) < 5 ) { r_cons_break_push ( NULL , NULL ) ; recursive_help ( core , cmd ) ; r_cons_break_pop ( ) ; r_cons_grep_parsecmd ( ptr + 2 , \"`\" ) ; if ( scr_html != - 1 ) { r_config_set_i ( core -> config , \"scr.html\" , scr_html ) ; } if ( scr_color != - 1 ) { r_config_set_i ( core -> config , \"scr.color\" , scr_color ) ; } return 0 ; } } } # if 0 ptr = strchr ( cmd , '<' ) ; if ( ptr ) { ptr [ 0 ] = '\\\\0' ; if ( r_cons_singleton ( ) -> is_interactive ) { if ( ptr [ 1 ] == '<' ) { for ( str = ptr + 2 ; str [ 0 ] == '<S2SV_blank>' ; str ++ ) { } eprintf ( \"==><S2SV_blank>Reading<S2SV_blank>from<S2SV_blank>stdin<S2SV_blank>until<S2SV_blank>\\'%s\\'\\\\n\" , str ) ; free ( core -> oobi ) ; core -> oobi = malloc ( 1 ) ; if ( core -> oobi ) { core -> oobi [ 0 ] = '\\\\0' ; } core -> oobi_len = 0 ; for ( ; ; ) { char buf [ 1024 ] ; int ret ; write ( 1 , \"><S2SV_blank>\" , 2 ) ; fgets ( buf , sizeof ( buf ) - 1 , stdin ) ; if ( feof ( stdin ) ) { break ; } if ( * buf ) buf [ strlen ( buf ) - 1 ] = '\\\\0' ; ret = strlen ( buf ) ; core -> oobi_len += ret ; core -> oobi = realloc ( core -> oobi , core -> oobi_len + 1 ) ; if ( core -> oobi ) { if ( ! strcmp ( buf , str ) ) { break ; } strcat ( ( char * ) core -> oobi , buf ) ; } } } else { for ( str = ptr + 1 ; * str == '<S2SV_blank>' ; str ++ ) { } if ( ! * str ) { goto next ; } eprintf ( \"Slurping<S2SV_blank>file<S2SV_blank>\\'%s\\'\\\\n\" , str ) ; free ( core -> oobi ) ; core -> oobi = ( ut8 * ) r_file_slurp ( str , & core -> oobi_len ) ; if ( ! core -> oobi ) { eprintf ( \"cannot<S2SV_blank>open<S2SV_blank>file\\\\n\" ) ; } else if ( ptr == cmd ) { return r_core_cmd_buffer ( core , ( const char * ) core -> oobi ) ; } } } else { eprintf ( \"Cannot<S2SV_blank>slurp<S2SV_blank>with<S2SV_blank><<<S2SV_blank>in<S2SV_blank>non-interactive<S2SV_blank>mode\\\\n\" ) ; return 0 ; } } next : # endif ptr = strchr ( cmd , '>' ) ; if ( ptr ) { int fdn = 1 ; int pipecolor = r_config_get_i ( core -> config , \"scr.pipecolor\" ) ; int use_editor = false ; int ocolor = r_config_get_i ( core -> config , \"scr.color\" ) ; * ptr = '\\\\0' ; str = r_str_trim_head_tail ( ptr + 1 + ( ptr [ 1 ] == '>' ) ) ; if ( ! * str ) { eprintf ( \"No<S2SV_blank>output?\\\\n\" ) ; goto next2 ; } if ( ptr > ( cmd + 1 ) && ISWHITECHAR ( ptr [ - 2 ] ) ) { char * fdnum = ptr - 1 ; if ( * fdnum == 'H' ) { scr_html = r_config_get_i ( core -> config , \"scr.html\" ) ; r_config_set_i ( core -> config , \"scr.html\" , true ) ; pipecolor = true ; * fdnum = 0 ; } else { if ( IS_DIGIT ( * fdnum ) ) { fdn = * fdnum - '0' ; } * fdnum = 0 ; } } r_cons_set_interactive ( false ) ; if ( ! strcmp ( str , \"-\" ) ) { use_editor = true ; str = r_file_temp ( \"dumpedit\" ) ; r_config_set ( core -> config , \"scr.color\" , \"false\" ) ; } if ( fdn > 0 ) { pipefd = r_cons_pipe_open ( str , fdn , ptr [ 1 ] == '>' ) ; if ( pipefd != - 1 ) { if ( ! pipecolor ) { r_config_set_i ( core -> config , \"scr.color\" , 0 ) ; } ret = r_core_cmd_subst ( core , cmd ) ; r_cons_flush ( ) ; r_cons_pipe_close ( pipefd ) ; } } r_cons_set_last_interactive ( ) ; if ( ! pipecolor ) { r_config_set_i ( core -> config , \"scr.color\" , ocolor ) ; } if ( use_editor ) { const char * editor = r_config_get ( core -> config , \"cfg.editor\" ) ; if ( editor && * editor ) { r_sys_cmdf ( \"%s<S2SV_blank>\\'%s\\'\" , editor , str ) ; r_file_rm ( str ) ; } else { eprintf ( \"No<S2SV_blank>cfg.editor<S2SV_blank>configured\\\\n\" ) ; } r_config_set_i ( core -> config , \"scr.color\" , ocolor ) ; free ( str ) ; } if ( scr_html != - 1 ) { r_config_set_i ( core -> config , \"scr.html\" , scr_html ) ; } if ( scr_color != - 1 ) { r_config_set_i ( core -> config , \"scr.color\" , scr_color ) ; } return ret ; } next2 : ptr = strchr ( cmd , '`' ) ; if ( ptr ) { int empty = 0 ; int oneline = 1 ; if ( ptr [ 1 ] == '`' ) { memmove ( ptr , ptr + 1 , strlen ( ptr ) ) ; oneline = 0 ; empty = 1 ; } ptr2 = strchr ( ptr + 1 , '`' ) ; if ( empty ) { } else if ( ! ptr2 ) { eprintf ( \"parse:<S2SV_blank>Missing<S2SV_blank>backtick<S2SV_blank>in<S2SV_blank>expression.\\\\n\" ) ; goto fail ; } else { int value = core -> num -> value ; * ptr = '\\\\0' ; * ptr2 = '\\\\0' ; if ( ptr [ 1 ] == '!' ) { str = r_core_cmd_str_pipe ( core , ptr + 1 ) ; } else { str = r_core_cmd_str ( core , ptr + 1 ) ; } if ( ! str ) { goto fail ; } if ( * str == '|' || * str == '*' ) { eprintf ( \"r_core_cmd_subst_i:<S2SV_blank>invalid<S2SV_blank>backticked<S2SV_blank>command\\\\n\" ) ; free ( str ) ; goto fail ; } if ( oneline && str ) { for ( i = 0 ; str [ i ] ; i ++ ) { if ( str [ i ] == '\\\\n' ) { str [ i ] = '<S2SV_blank>' ; } } } str = r_str_append ( str , ptr2 + 1 ) ; cmd = r_str_append ( strdup ( cmd ) , str ) ; core -> num -> value = value ; ret = r_core_cmd_subst ( core , cmd ) ; free ( cmd ) ; if ( scr_html != - 1 ) { r_config_set_i ( core -> config , \"scr.html\" , scr_html ) ; } free ( str ) ; return ret ; } } core -> fixedblock = false ; if ( r_str_endswith ( cmd , \"~?\" ) && cmd [ 2 ] == '\\\\0' ) { r_cons_grep_help ( ) ; return true ; } if ( * cmd != '.' ) { r_cons_grep_parsecmd ( cmd , quotestr ) ; } if ( * cmd != '(' && * cmd != \\'\"\\' ) { ptr = strchr ( cmd , '@' ) ; if ( ptr == cmd + 1 && * cmd == '?' ) { ptr = NULL ; } } else { ptr = NULL ; } core -> tmpseek = ptr ? true : false ; int rc = 0 ; if ( ptr ) { char * f , * ptr2 = strchr ( ptr + 1 , '!' ) ; ut64 addr = UT64_MAX ; const char * tmpbits = NULL ; const char * offstr = NULL ; ut64 tmpbsz = core -> blocksize ; char * tmpeval = NULL ; ut64 tmpoff = core -> offset ; char * tmpasm = NULL ; int tmpfd = - 1 ; int sz , len ; ut8 * buf ; * ptr = '\\\\0' ; for ( ptr ++ ; * ptr == '<S2SV_blank>' ; ptr ++ ) { } if ( * ptr && ptr [ 1 ] == ':' ) { } else { ptr -- ; } arroba = ( ptr [ 0 ] && ptr [ 1 ] && ptr [ 2 ] ) ? strchr ( ptr + 2 , '@' ) : NULL ; repeat_arroba : if ( arroba ) { * arroba = 0 ; } if ( ptr [ 1 ] == '?' ) { helpCmdAt ( core ) ; } else if ( ptr [ 0 ] && ptr [ 1 ] == ':' && ptr [ 2 ] ) { usemyblock = true ; switch ( ptr [ 0 ] ) { case 'f' : f = r_file_slurp ( ptr + 2 , & sz ) ; if ( f ) { buf = malloc ( sz ) ; if ( buf ) { free ( core -> block ) ; core -> block = buf ; core -> blocksize = sz ; memcpy ( core -> block , f , sz ) ; } else { eprintf ( \"cannot<S2SV_blank>alloc<S2SV_blank>%d\" , sz ) ; } free ( f ) ; } else { eprintf ( \"cannot<S2SV_blank>open<S2SV_blank>\\'%s\\'\\\\n\" , ptr + 3 ) ; } break ; case 'r' : if ( ptr [ 1 ] == ':' ) { ut64 regval ; char * mander = strdup ( ptr + 2 ) ; char * sep = findSeparator ( mander ) ; if ( sep ) { char ch = * sep ; * sep = 0 ; regval = r_debug_reg_get ( core -> dbg , mander ) ; * sep = ch ; char * numexpr = r_str_newf ( \"0x%\" PFMT64x \"%s\" , regval , sep ) ; regval = r_num_math ( core -> num , numexpr ) ; free ( numexpr ) ; } else { regval = r_debug_reg_get ( core -> dbg , ptr + 2 ) ; } r_core_seek ( core , regval , 1 ) ; free ( mander ) ; } break ; case 'b' : tmpbits = strdup ( r_config_get ( core -> config , \"asm.bits\" ) ) ; r_config_set_i ( core -> config , \"asm.bits\" , r_num_math ( core -> num , ptr + 2 ) ) ; break ; case 'i' : { ut64 addr = r_num_math ( core -> num , ptr + 2 ) ; if ( addr ) { r_core_cmdf ( core , \"so<S2SV_blank>%s\" , ptr + 2 ) ; } } break ; case 'e' : tmpeval = parse_tmp_evals ( core , ptr + 2 ) ; break ; case 'x' : if ( ptr [ 1 ] == ':' ) { buf = malloc ( strlen ( ptr + 2 ) + 1 ) ; if ( buf ) { len = r_hex_str2bin ( ptr + 2 , buf ) ; r_core_block_size ( core , R_ABS ( len ) ) ; memcpy ( core -> block , buf , core -> blocksize ) ; core -> fixedblock = true ; free ( buf ) ; } else { eprintf ( \"cannot<S2SV_blank>allocate\\\\n\" ) ; } } else { eprintf ( \"Invalid<S2SV_blank>@x:<S2SV_blank>syntax\\\\n\" ) ; } break ; case 'k' : { char * out = sdb_querys ( core -> sdb , NULL , 0 , ptr + ( ( ptr [ 1 ] ) ? 2 : 1 ) ) ; if ( out ) { r_core_seek ( core , r_num_math ( core -> num , out ) , 1 ) ; free ( out ) ; } } break ; case 'o' : if ( ptr [ 1 ] == ':' ) { tmpfd = core -> io -> raised ; r_io_raise ( core -> io , atoi ( ptr + 2 ) ) ; } break ; case 'a' : if ( ptr [ 1 ] == ':' ) { char * q = strchr ( ptr + 2 , ':' ) ; tmpasm = strdup ( r_config_get ( core -> config , \"asm.arch\" ) ) ; if ( q ) { * q ++ = 0 ; tmpbits = r_config_get ( core -> config , \"asm.bits\" ) ; r_config_set ( core -> config , \"asm.bits\" , q ) ; } r_config_set ( core -> config , \"asm.arch\" , ptr + 2 ) ; } else { eprintf ( \"Usage:<S2SV_blank>pd<S2SV_blank>10<S2SV_blank>@a:arm:32\\\\n\" ) ; } break ; case 's' : len = strlen ( ptr + 2 ) ; r_core_block_size ( core , len ) ; memcpy ( core -> block , ptr + 2 , len ) ; break ; default : goto ignore ; } * ptr = '@' ; goto next_arroba ; } ignore : ptr = r_str_trim_head ( ptr + 1 ) ; ptr -- ; cmd = r_str_clean ( cmd ) ; if ( ptr2 ) { if ( strlen ( ptr + 1 ) == 13 && strlen ( ptr2 + 1 ) == 6 && ! memcmp ( ptr + 1 , \"0x\" , 2 ) && ! memcmp ( ptr2 + 1 , \"0x\" , 2 ) ) { } else if ( strlen ( ptr + 1 ) == 9 && strlen ( ptr2 + 1 ) == 4 ) { } else { * ptr2 = '\\\\0' ; if ( ! ptr2 [ 1 ] ) { goto fail ; } r_core_block_size ( core , r_num_math ( core -> num , ptr2 + 1 ) ) ; } } offstr = r_str_trim_head ( ptr + 1 ) ; addr = r_num_math ( core -> num , offstr ) ; if ( isalpha ( ( unsigned char ) ptr [ 1 ] ) && ! addr ) { if ( ! r_flag_get ( core -> flags , ptr + 1 ) ) { eprintf ( \"Invalid<S2SV_blank>address<S2SV_blank>(%s)\\\\n\" , ptr + 1 ) ; goto fail ; } } else { char ch = * offstr ; if ( ch == '-' || ch == '+' ) { addr = core -> offset + addr ; } } next_arroba : if ( arroba ) { ptr = arroba ; arroba = NULL ; goto repeat_arroba ; } if ( ptr [ 1 ] == '@' ) { if ( ptr [ 2 ] == '@' ) { char * rule = ptr + 3 ; while ( * rule && * rule == '<S2SV_blank>' ) rule ++ ; ret = r_core_cmd_foreach3 ( core , cmd , rule ) ; } else { ret = r_core_cmd_foreach ( core , cmd , ptr + 2 ) ; } } else { bool tmpseek = false ; const char * fromvars [ ] = { \"anal.from\" , \"diff.from\" , \"graph.from\" , \"io.buffer.from\" , \"lines.from\" , \"search.from\" , \"zoom.from\" , NULL } ; const char * tovars [ ] = { \"anal.to\" , \"diff.to\" , \"graph.to\" , \"io.buffer.to\" , \"lines.to\" , \"search.to\" , \"zoom.to\" , NULL } ; ut64 curfrom [ R_ARRAY_SIZE ( fromvars ) - 1 ] , curto [ R_ARRAY_SIZE ( tovars ) - 1 ] ; if ( ptr [ 1 ] == '.' && ptr [ 2 ] == '.' ) { char * range = ptr + 3 ; char * p = strchr ( range , '<S2SV_blank>' ) ; if ( ! p ) { eprintf ( \"Usage:<S2SV_blank>/<S2SV_blank>ABCD<S2SV_blank>@..0x1000<S2SV_blank>0x3000\\\\n\" ) ; free ( tmpeval ) ; free ( tmpasm ) ; goto fail ; } * p = '\\\\x00' ; ut64 from = r_num_math ( core -> num , range ) ; ut64 to = r_num_math ( core -> num , p + 1 ) ; for ( i = 0 ; fromvars [ i ] ; i ++ ) { curfrom [ i ] = r_config_get_i ( core -> config , fromvars [ i ] ) ; } for ( i = 0 ; tovars [ i ] ; i ++ ) { curto [ i ] = r_config_get_i ( core -> config , tovars [ i ] ) ; } for ( i = 0 ; fromvars [ i ] ; i ++ ) { r_config_set_i ( core -> config , fromvars [ i ] , from ) ; } for ( i = 0 ; tovars [ i ] ; i ++ ) { r_config_set_i ( core -> config , tovars [ i ] , to ) ; } tmpseek = true ; } if ( usemyblock ) { if ( addr != UT64_MAX ) { core -> offset = addr ; } ret = r_cmd_call ( core -> rcmd , r_str_trim_head ( cmd ) ) ; } else { if ( addr != UT64_MAX ) { if ( ! ptr [ 1 ] || r_core_seek ( core , addr , 1 ) ) { r_core_block_read ( core ) ; ret = r_cmd_call ( core -> rcmd , r_str_trim_head ( cmd ) ) ; } else { ret = 0 ; } } } if ( tmpseek ) { for ( i = 0 ; fromvars [ i ] ; i ++ ) { r_config_set_i ( core -> config , fromvars [ i ] , curfrom [ i ] ) ; } for ( i = 0 ; tovars [ i ] ; i ++ ) { r_config_set_i ( core -> config , tovars [ i ] , curto [ i ] ) ; } } } if ( ptr2 ) { * ptr2 = '!' ; r_core_block_size ( core , tmpbsz ) ; } if ( tmpasm ) { r_config_set ( core -> config , \"asm.arch\" , tmpasm ) ; tmpasm = NULL ; } if ( tmpfd != - 1 ) { r_io_raise ( core -> io , tmpfd ) ; } if ( tmpbits ) { r_config_set ( core -> config , \"asm.bits\" , tmpbits ) ; tmpbits = NULL ; } if ( tmpeval ) { r_core_cmd0 ( core , tmpeval ) ; R_FREE ( tmpeval ) ; } r_core_seek ( core , tmpoff , 1 ) ; * ptr = '@' ; rc = ret ; goto beach ; } rc = cmd ? r_cmd_call ( core -> rcmd , r_str_trim_head ( cmd ) ) : false ; beach : if ( scr_html != - 1 ) { r_cons_flush ( ) ; r_config_set_i ( core -> config , \"scr.html\" , scr_html ) ; } if ( scr_color != - 1 ) { r_config_set_i ( core -> config , \"scr.color\" , scr_color ) ; } core -> fixedblock = false ; return rc ; fail : rc = - 1 ; goto beach ; }\n","target":"<S2SV_ModStart> ; p = cmd [ 0 ] ? <S2SV_ModStart> + 1 ) : NULL\n","project_and_commit_id":"radare@radare2/00e8f205475332d7842d0f0d1481eeab4e83017c","cve_id":"CVE-2017-9761","original_address":"https://github.com/radare/radare2/commit/00e8f205475332d7842d0f0d1481eeab4e83017c","time":"2017-06-19T16:29Z"},
	{"Unnamed: 0":2321,"cwe_id":"CWE-189","source":"CWE-189 static ssize_t __nfs4_get_acl_uncached ( struct inode * inode , void * buf , size_t buflen ) { <S2SV_StartBug> struct page * pages [ NFS4ACL_MAXPAGES ] ; <S2SV_EndBug> struct nfs_getaclargs args = { . fh = NFS_FH ( inode ) , . acl_pages = pages , . acl_len = buflen , } ; struct nfs_getaclres res = { . acl_len = buflen , } ; void * resp_buf ; struct rpc_message msg = { . rpc_proc = & nfs4_procedures [ NFSPROC4_CLNT_GETACL ] , . rpc_argp = & args , . rpc_resp = & res , } ; <S2SV_StartBug> struct page * localpage = NULL ; <S2SV_EndBug> int ret ; if ( buflen < PAGE_SIZE ) { localpage = alloc_page ( GFP_KERNEL ) ; resp_buf = page_address ( localpage ) ; if ( localpage == NULL ) <S2SV_StartBug> return - ENOMEM ; <S2SV_EndBug> args . acl_pages [ 0 ] = localpage ; args . acl_pgbase = 0 ; args . acl_len = PAGE_SIZE ; } else { resp_buf = buf ; buf_to_pages ( buf , buflen , args . acl_pages , & args . acl_pgbase ) ; } ret = nfs4_call_sync ( NFS_SERVER ( inode ) -> client , NFS_SERVER ( inode ) , & msg , & args . seq_args , & res . seq_res , 0 ) ; if ( ret ) goto out_free ; <S2SV_StartBug> if ( res . acl_len > args . acl_len ) <S2SV_EndBug> <S2SV_StartBug> nfs4_write_cached_acl ( inode , NULL , res . acl_len ) ; <S2SV_EndBug> else <S2SV_StartBug> nfs4_write_cached_acl ( inode , resp_buf , res . acl_len ) ; <S2SV_EndBug> if ( buf ) { ret = - ERANGE ; <S2SV_StartBug> if ( res . acl_len > buflen ) <S2SV_EndBug> goto out_free ; <S2SV_StartBug> if ( localpage ) <S2SV_EndBug> <S2SV_StartBug> memcpy ( buf , resp_buf , res . acl_len ) ; <S2SV_EndBug> } ret = res . acl_len ; out_free : <S2SV_StartBug> if ( localpage ) <S2SV_EndBug> <S2SV_StartBug> __free_page ( localpage ) ; <S2SV_EndBug> return ret ; }\n","target":"<S2SV_ModStart> [ NFS4ACL_MAXPAGES ] = { NULL , } <S2SV_ModStart> , } ; int ret = - ENOMEM , npages , i , acl_len = 0 ; npages = ( buflen + PAGE_SIZE - 1 ) >> PAGE_SHIFT ; if ( npages == 0 ) npages = 1 ; for ( i = 0 ; i < npages ; i ++ ) { pages [ i ] = alloc_page ( GFP_KERNEL ) ; if ( ! pages [ i ] ) goto out_free ; } if ( npages > 1 ) { args . acl_scratch = alloc_page ( GFP_KERNEL ) ; if ( ! args . acl_scratch ) goto out_free ; } args . acl_len = npages * PAGE_SIZE ; args . acl_pgbase = 0 ; if ( buf <S2SV_ModEnd> == NULL ) <S2SV_ModStart> == NULL ) res . acl_flags |= NFS4_ACL_LEN_REQUEST ; resp_buf = page_address ( pages [ 0 ] ) ; dprintk ( \"%s<S2SV_blank><S2SV_blank>buf<S2SV_blank>%p<S2SV_blank>buflen<S2SV_blank>%ld<S2SV_blank>npages<S2SV_blank>%d<S2SV_blank>args.acl_len<S2SV_blank>%ld\\\\n\" , __func__ , buf , buflen , npages , args . acl_len ) ; <S2SV_ModEnd> ret = nfs4_call_sync <S2SV_ModStart> goto out_free ; acl_len = res . acl_len - res . acl_data_offset ; if ( <S2SV_ModEnd> acl_len > args <S2SV_ModStart> , NULL , <S2SV_ModEnd> acl_len ) ; <S2SV_ModStart> inode , resp_buf + res . acl_data_offset , <S2SV_ModEnd> acl_len ) ; <S2SV_ModStart> ; if ( <S2SV_ModEnd> acl_len > buflen <S2SV_ModStart> goto out_free ; _copy_from_pages <S2SV_ModEnd> ( buf , <S2SV_ModStart> ( buf , pages , res . acl_data_offset , res . acl_len ) ; } ret = <S2SV_ModEnd> acl_len ; out_free <S2SV_ModStart> ; out_free : for ( i = 0 ; i < npages ; i ++ ) if ( pages [ i ] <S2SV_ModEnd> ) __free_page ( <S2SV_ModStart> ) __free_page ( pages [ i ] ) ; if ( args . acl_scratch ) __free_page ( args . acl_scratch <S2SV_ModEnd> ) ; return\n","project_and_commit_id":"torvalds@linux/bf118a342f10dafe44b14451a1392c3254629a1f","cve_id":"CVE-2011-4131","original_address":"https://github.com/torvalds/linux/commit/bf118a342f10dafe44b14451a1392c3254629a1f","time":"2012-05-17T11:00Z"},
	{"Unnamed: 0":686,"cwe_id":"CWE-200","source":"CWE-200 int get_rock_ridge_filename ( struct iso_directory_record * de , char * retname , struct inode * inode ) { struct rock_state rs ; struct rock_ridge * rr ; int sig ; int retnamlen = 0 ; int truncate = 0 ; int ret = 0 ; <S2SV_StartBug> if ( ! ISOFS_SB ( inode -> i_sb ) -> s_rock ) <S2SV_EndBug> return 0 ; * retname = 0 ; init_rock_state ( & rs , inode ) ; setup_rock_ridge ( de , inode , & rs ) ; repeat : while ( rs . len > 2 ) { rr = ( struct rock_ridge * ) rs . chr ; if ( rr -> len < 3 ) goto out ; sig = isonum_721 ( rs . chr ) ; if ( rock_check_overflow ( & rs , sig ) ) goto eio ; rs . chr += rr -> len ; rs . len -= rr -> len ; if ( rs . len < 0 ) goto out ; switch ( sig ) { case SIG ( 'R' , 'R' ) : if ( ( rr -> u . RR . flags [ 0 ] & RR_NM ) == 0 ) goto out ; break ; case SIG ( 'S' , 'P' ) : if ( check_sp ( rr , inode ) ) goto out ; break ; case SIG ( 'C' , 'E' ) : rs . cont_extent = isonum_733 ( rr -> u . CE . extent ) ; rs . cont_offset = isonum_733 ( rr -> u . CE . offset ) ; rs . cont_size = isonum_733 ( rr -> u . CE . size ) ; break ; case SIG ( 'N' , 'M' ) : if ( truncate ) break ; if ( rr -> len < 5 ) break ; if ( rr -> u . NM . flags & 6 ) break ; if ( rr -> u . NM . flags & ~ 1 ) { printk ( \"Unsupported<S2SV_blank>NM<S2SV_blank>flag<S2SV_blank>settings<S2SV_blank>(%d)\\\\n\" , rr -> u . NM . flags ) ; break ; } <S2SV_StartBug> if ( ( strlen ( retname ) + rr -> len - 5 ) >= 254 ) { <S2SV_EndBug> truncate = 1 ; break ; } <S2SV_StartBug> strncat ( retname , rr -> u . NM . name , rr -> len - 5 ) ; <S2SV_EndBug> <S2SV_StartBug> retnamlen += rr -> len - 5 ; <S2SV_EndBug> break ; case SIG ( 'R' , 'E' ) : kfree ( rs . buffer ) ; return - 1 ; default : break ; } } ret = rock_continue ( & rs ) ; if ( ret == 0 ) goto repeat ; if ( ret == 1 ) return retnamlen ; out : kfree ( rs . buffer ) ; return ret ; eio : ret = - EIO ; goto out ; }\n","target":"<S2SV_ModStart> = 0 ; char * p ; int len ; <S2SV_ModStart> break ; } len = <S2SV_ModEnd> rr -> len <S2SV_ModStart> len - 5 ; if ( retnamlen + len <S2SV_ModEnd> >= 254 ) <S2SV_ModStart> break ; } p = memchr ( rr -> u . NM . name , '\\\\0' , len ) ; if ( unlikely ( p ) ) len = p - rr -> u . NM . name ; memcpy ( retname + retnamlen <S2SV_ModEnd> , rr -> <S2SV_ModStart> . name , len <S2SV_ModEnd> ) ; retnamlen <S2SV_ModStart> ; retnamlen += len ; retname [ retnamlen ] = '\\\\0' <S2SV_ModEnd> ; break ;\n","project_and_commit_id":"torvalds@linux/99d825822eade8d827a1817357cbf3f889a552d6","cve_id":"CVE-2016-4913","original_address":"https://github.com/torvalds/linux/commit/99d825822eade8d827a1817357cbf3f889a552d6","time":"2016-05-23T10:59Z"},
	{"Unnamed: 0":2998,"cwe_id":"CWE-401","source":"CWE-401 static int fsl_lpspi_probe ( struct platform_device * pdev ) { struct device_node * np = pdev -> dev . of_node ; struct fsl_lpspi_data * fsl_lpspi ; struct spi_controller * controller ; struct spi_imx_master * lpspi_platform_info = dev_get_platdata ( & pdev -> dev ) ; struct resource * res ; int i , ret , irq ; u32 temp ; bool is_slave ; is_slave = of_property_read_bool ( ( & pdev -> dev ) -> of_node , \"spi-slave\" ) ; if ( is_slave ) controller = spi_alloc_slave ( & pdev -> dev , sizeof ( struct fsl_lpspi_data ) ) ; else controller = spi_alloc_master ( & pdev -> dev , sizeof ( struct fsl_lpspi_data ) ) ; if ( ! controller ) return - ENOMEM ; platform_set_drvdata ( pdev , controller ) ; fsl_lpspi = spi_controller_get_devdata ( controller ) ; fsl_lpspi -> dev = & pdev -> dev ; fsl_lpspi -> is_slave = is_slave ; if ( ! fsl_lpspi -> is_slave ) { for ( i = 0 ; i < controller -> num_chipselect ; i ++ ) { int cs_gpio = of_get_named_gpio ( np , \"cs-gpios\" , i ) ; if ( ! gpio_is_valid ( cs_gpio ) && lpspi_platform_info ) cs_gpio = lpspi_platform_info -> chipselect [ i ] ; fsl_lpspi -> chipselect [ i ] = cs_gpio ; if ( ! gpio_is_valid ( cs_gpio ) ) continue ; ret = devm_gpio_request ( & pdev -> dev , fsl_lpspi -> chipselect [ i ] , DRIVER_NAME ) ; if ( ret ) { dev_err ( & pdev -> dev , \"can\\'t<S2SV_blank>get<S2SV_blank>cs<S2SV_blank>gpios\\\\n\" ) ; goto out_controller_put ; } } controller -> cs_gpios = fsl_lpspi -> chipselect ; controller -> prepare_message = fsl_lpspi_prepare_message ; } controller -> bits_per_word_mask = SPI_BPW_RANGE_MASK ( 8 , 32 ) ; controller -> transfer_one = fsl_lpspi_transfer_one ; controller -> prepare_transfer_hardware = lpspi_prepare_xfer_hardware ; controller -> unprepare_transfer_hardware = lpspi_unprepare_xfer_hardware ; controller -> mode_bits = SPI_CPOL | SPI_CPHA | SPI_CS_HIGH ; controller -> flags = SPI_MASTER_MUST_RX | SPI_MASTER_MUST_TX ; controller -> dev . of_node = pdev -> dev . of_node ; controller -> bus_num = pdev -> id ; controller -> slave_abort = fsl_lpspi_slave_abort ; init_completion ( & fsl_lpspi -> xfer_done ) ; res = platform_get_resource ( pdev , IORESOURCE_MEM , 0 ) ; fsl_lpspi -> base = devm_ioremap_resource ( & pdev -> dev , res ) ; if ( IS_ERR ( fsl_lpspi -> base ) ) { ret = PTR_ERR ( fsl_lpspi -> base ) ; goto out_controller_put ; } fsl_lpspi -> base_phys = res -> start ; irq = platform_get_irq ( pdev , 0 ) ; if ( irq < 0 ) { ret = irq ; goto out_controller_put ; } ret = devm_request_irq ( & pdev -> dev , irq , fsl_lpspi_isr , 0 , dev_name ( & pdev -> dev ) , fsl_lpspi ) ; if ( ret ) { dev_err ( & pdev -> dev , \"can\\'t<S2SV_blank>get<S2SV_blank>irq%d:<S2SV_blank>%d\\\\n\" , irq , ret ) ; goto out_controller_put ; } fsl_lpspi -> clk_per = devm_clk_get ( & pdev -> dev , \"per\" ) ; if ( IS_ERR ( fsl_lpspi -> clk_per ) ) { ret = PTR_ERR ( fsl_lpspi -> clk_per ) ; goto out_controller_put ; } fsl_lpspi -> clk_ipg = devm_clk_get ( & pdev -> dev , \"ipg\" ) ; if ( IS_ERR ( fsl_lpspi -> clk_ipg ) ) { ret = PTR_ERR ( fsl_lpspi -> clk_ipg ) ; goto out_controller_put ; } ret = fsl_lpspi_init_rpm ( fsl_lpspi ) ; if ( ret ) goto out_controller_put ; ret = pm_runtime_get_sync ( fsl_lpspi -> dev ) ; if ( ret < 0 ) { dev_err ( fsl_lpspi -> dev , \"failed<S2SV_blank>to<S2SV_blank>enable<S2SV_blank>clock\\\\n\" ) ; <S2SV_StartBug> return ret ; <S2SV_EndBug> } temp = readl ( fsl_lpspi -> base + IMX7ULP_PARAM ) ; fsl_lpspi -> txfifosize = 1 << ( temp & 0x0f ) ; fsl_lpspi -> rxfifosize = 1 << ( ( temp >> 8 ) & 0x0f ) ; ret = fsl_lpspi_dma_init ( & pdev -> dev , fsl_lpspi , controller ) ; if ( ret == - EPROBE_DEFER ) goto out_controller_put ; if ( ret < 0 ) dev_err ( & pdev -> dev , \"dma<S2SV_blank>setup<S2SV_blank>error<S2SV_blank>%d,<S2SV_blank>use<S2SV_blank>pio\\\\n\" , ret ) ; ret = devm_spi_register_controller ( & pdev -> dev , controller ) ; if ( ret < 0 ) { dev_err ( & pdev -> dev , \"spi_register_controller<S2SV_blank>error.\\\\n\" ) ; goto out_controller_put ; } return 0 ; out_controller_put : spi_controller_put ( controller ) ; return ret ; }\n","target":"<S2SV_ModStart> \"failed<S2SV_blank>to<S2SV_blank>enable<S2SV_blank>clock\\\\n\" ) ; goto out_controller_put <S2SV_ModEnd> ; } temp\n","project_and_commit_id":"torvalds@linux/057b8945f78f76d0b04eeb5c27cd9225e5e7ad86","cve_id":"CVE-2019-19064","original_address":"https://github.com/torvalds/linux/commit/057b8945f78f76d0b04eeb5c27cd9225e5e7ad86","time":"2019-11-18T06:15Z"},
	{"Unnamed: 0":3860,"cwe_id":"CWE-119","source":"CWE-119 static long ioctl_file_dedupe_range ( struct file * file , void __user * arg ) { struct file_dedupe_range __user * argp = arg ; struct file_dedupe_range * same = NULL ; int ret ; unsigned long size ; u16 count ; if ( get_user ( count , & argp -> dest_count ) ) { ret = - EFAULT ; goto out ; } size = offsetof ( struct file_dedupe_range __user , info [ count ] ) ; same = memdup_user ( argp , size ) ; if ( IS_ERR ( same ) ) { ret = PTR_ERR ( same ) ; same = NULL ; goto out ; } <S2SV_StartBug> ret = vfs_dedupe_file_range ( file , same ) ; <S2SV_EndBug> if ( ret ) goto out ; ret = copy_to_user ( argp , same , size ) ; if ( ret ) ret = - EFAULT ; out : kfree ( same ) ; return ret ; }\n","target":"<S2SV_ModStart> out ; } same -> dest_count = count ;\n","project_and_commit_id":"torvalds@linux/10eec60ce79187686e052092e5383c99b4420a20","cve_id":"CVE-2016-6516","original_address":"https://github.com/torvalds/linux/commit/10eec60ce79187686e052092e5383c99b4420a20","time":"2016-08-06T20:59Z"},
	{"Unnamed: 0":5561,"cwe_id":"CWE-119","source":"CWE-119 static void do_ssh2_kex ( void ) { char * myproposal [ PROPOSAL_MAX ] = { KEX_SERVER } ; struct kex * kex ; int r ; myproposal [ PROPOSAL_KEX_ALGS ] = compat_kex_proposal ( options . kex_algorithms ) ; myproposal [ PROPOSAL_ENC_ALGS_CTOS ] = compat_cipher_proposal ( options . ciphers ) ; myproposal [ PROPOSAL_ENC_ALGS_STOC ] = compat_cipher_proposal ( options . ciphers ) ; myproposal [ PROPOSAL_MAC_ALGS_CTOS ] = myproposal [ PROPOSAL_MAC_ALGS_STOC ] = options . macs ; if ( options . compression == COMP_NONE ) { myproposal [ PROPOSAL_COMP_ALGS_CTOS ] = myproposal [ PROPOSAL_COMP_ALGS_STOC ] = \"none\" ; <S2SV_StartBug> } else if ( options . compression == COMP_DELAYED ) { <S2SV_EndBug> myproposal [ PROPOSAL_COMP_ALGS_CTOS ] = myproposal [ PROPOSAL_COMP_ALGS_STOC ] = \"none,zlib@openssh.com\" ; } if ( options . rekey_limit || options . rekey_interval ) packet_set_rekey_limits ( options . rekey_limit , ( time_t ) options . rekey_interval ) ; myproposal [ PROPOSAL_SERVER_HOST_KEY_ALGS ] = compat_pkalg_proposal ( list_hostkey_types ( ) ) ; if ( ( r = kex_setup ( active_state , myproposal ) ) != 0 ) fatal ( \"kex_setup:<S2SV_blank>%s\" , ssh_err ( r ) ) ; kex = active_state -> kex ; # ifdef WITH_OPENSSL kex -> kex [ KEX_DH_GRP1_SHA1 ] = kexdh_server ; kex -> kex [ KEX_DH_GRP14_SHA1 ] = kexdh_server ; kex -> kex [ KEX_DH_GRP14_SHA256 ] = kexdh_server ; kex -> kex [ KEX_DH_GRP16_SHA512 ] = kexdh_server ; kex -> kex [ KEX_DH_GRP18_SHA512 ] = kexdh_server ; kex -> kex [ KEX_DH_GEX_SHA1 ] = kexgex_server ; kex -> kex [ KEX_DH_GEX_SHA256 ] = kexgex_server ; kex -> kex [ KEX_ECDH_SHA2 ] = kexecdh_server ; # endif kex -> kex [ KEX_C25519_SHA256 ] = kexc25519_server ; kex -> server = 1 ; kex -> client_version_string = client_version_string ; kex -> server_version_string = server_version_string ; kex -> load_host_public_key = & get_hostkey_public_by_type ; kex -> load_host_private_key = & get_hostkey_private_by_type ; kex -> host_key_index = & get_hostkey_index ; kex -> sign = sshd_hostkey_sign ; dispatch_run ( DISPATCH_BLOCK , & kex -> done , active_state ) ; session_id2 = kex -> session_id ; session_id2_len = kex -> session_id_len ; # ifdef DEBUG_KEXDH packet_start ( SSH2_MSG_IGNORE ) ; packet_put_cstring ( \"markus\" ) ; packet_send ( ) ; packet_write_wait ( ) ; # endif debug ( \"KEX<S2SV_blank>done\" ) ; }\n","target":"<S2SV_ModStart> \"none\" ; } <S2SV_ModEnd> if ( options\n","project_and_commit_id":"openbsd@src/3095060f479b86288e31c79ecbc5131a66bcd2f9","cve_id":"CVE-2016-10012","original_address":"https://github.com/openbsd/src/commit/3095060f479b86288e31c79ecbc5131a66bcd2f9","time":"2017-01-05T02:59Z"},
	{"Unnamed: 0":5455,"cwe_id":"CWE-476","source":"CWE-476 int jpc_tsfb_synthesize ( jpc_tsfb_t * tsfb , jas_seq2d_t * a ) { <S2SV_StartBug> return ( tsfb -> numlvls > 0 ) ? jpc_tsfb_synthesize2 ( tsfb , <S2SV_EndBug> jas_seq2d_getref ( a , jas_seq2d_xstart ( a ) , jas_seq2d_ystart ( a ) ) , jas_seq2d_xstart ( a ) , jas_seq2d_ystart ( a ) , jas_seq2d_width ( a ) , jas_seq2d_height ( a ) , jas_seq2d_rowstep ( a ) , tsfb -> numlvls - 1 ) : 0 ; }\n","target":"<S2SV_ModStart> numlvls > 0 && jas_seq2d_size ( a )\n","project_and_commit_id":"mdadams@jasper/2e82fa00466ae525339754bb3ab0a0474a31d4bd","cve_id":"CVE-2016-10248","original_address":"https://github.com/mdadams/jasper/commit/2e82fa00466ae525339754bb3ab0a0474a31d4bd","time":"2017-03-15T14:59Z"},
	{"Unnamed: 0":2449,"cwe_id":"CWE-20","source":"CWE-20 static int vsock_stream_recvmsg ( struct kiocb * kiocb , struct socket * sock , struct msghdr * msg , size_t len , int flags ) { struct sock * sk ; struct vsock_sock * vsk ; int err ; size_t target ; ssize_t copied ; long timeout ; struct vsock_transport_recv_notify_data recv_data ; DEFINE_WAIT ( wait ) ; sk = sock -> sk ; vsk = vsock_sk ( sk ) ; err = 0 ; <S2SV_StartBug> msg -> msg_namelen = 0 ; <S2SV_EndBug> lock_sock ( sk ) ; if ( sk -> sk_state != SS_CONNECTED ) { if ( sock_flag ( sk , SOCK_DONE ) ) err = 0 ; else err = - ENOTCONN ; goto out ; } if ( flags & MSG_OOB ) { err = - EOPNOTSUPP ; goto out ; } if ( sk -> sk_shutdown & RCV_SHUTDOWN ) { err = 0 ; goto out ; } if ( ! len ) { err = 0 ; goto out ; } target = sock_rcvlowat ( sk , flags & MSG_WAITALL , len ) ; if ( target >= transport -> stream_rcvhiwat ( vsk ) ) { err = - ENOMEM ; goto out ; } timeout = sock_rcvtimeo ( sk , flags & MSG_DONTWAIT ) ; copied = 0 ; err = transport -> notify_recv_init ( vsk , target , & recv_data ) ; if ( err < 0 ) goto out ; prepare_to_wait ( sk_sleep ( sk ) , & wait , TASK_INTERRUPTIBLE ) ; while ( 1 ) { s64 ready = vsock_stream_has_data ( vsk ) ; if ( ready < 0 ) { err = - ENOMEM ; goto out_wait ; } else if ( ready > 0 ) { ssize_t read ; err = transport -> notify_recv_pre_dequeue ( vsk , target , & recv_data ) ; if ( err < 0 ) break ; read = transport -> stream_dequeue ( vsk , msg -> msg_iov , len - copied , flags ) ; if ( read < 0 ) { err = - ENOMEM ; break ; } copied += read ; err = transport -> notify_recv_post_dequeue ( vsk , target , read , ! ( flags & MSG_PEEK ) , & recv_data ) ; if ( err < 0 ) goto out_wait ; if ( read >= target || flags & MSG_PEEK ) break ; target -= read ; } else { if ( sk -> sk_err != 0 || ( sk -> sk_shutdown & RCV_SHUTDOWN ) || ( vsk -> peer_shutdown & SEND_SHUTDOWN ) ) { break ; } if ( timeout == 0 ) { err = - EAGAIN ; break ; } err = transport -> notify_recv_pre_block ( vsk , target , & recv_data ) ; if ( err < 0 ) break ; release_sock ( sk ) ; timeout = schedule_timeout ( timeout ) ; lock_sock ( sk ) ; if ( signal_pending ( current ) ) { err = sock_intr_errno ( timeout ) ; break ; } else if ( timeout == 0 ) { err = - EAGAIN ; break ; } prepare_to_wait ( sk_sleep ( sk ) , & wait , TASK_INTERRUPTIBLE ) ; } } if ( sk -> sk_err ) err = - sk -> sk_err ; else if ( sk -> sk_shutdown & RCV_SHUTDOWN ) err = 0 ; if ( copied > 0 ) { if ( ! ( flags & MSG_PEEK ) ) { if ( vsk -> peer_shutdown & SEND_SHUTDOWN ) { if ( vsock_stream_has_data ( vsk ) <= 0 ) { sk -> sk_state = SS_UNCONNECTED ; sock_set_flag ( sk , SOCK_DONE ) ; sk -> sk_state_change ( sk ) ; } } } err = copied ; } out_wait : finish_wait ( sk_sleep ( sk ) , & wait ) ; out : release_sock ( sk ) ; return err ; }\n","target":"<S2SV_ModStart> = 0 ; <S2SV_ModEnd> lock_sock ( sk\n","project_and_commit_id":"torvalds@linux/f3d3342602f8bcbf37d7c46641cb9bca7618eb1c","cve_id":"CVE-2013-7271","original_address":"https://github.com/torvalds/linux/commit/f3d3342602f8bcbf37d7c46641cb9bca7618eb1c","time":"2014-01-06T16:55Z"},
	{"Unnamed: 0":4549,"cwe_id":"CWE-125","source":"CWE-125 static MagickBooleanType load_tile ( Image * image , Image * tile_image , XCFDocInfo * inDocInfo , XCFLayerInfo * inLayerInfo , size_t data_length , ExceptionInfo * exception ) { ssize_t y ; register ssize_t x ; register Quantum * q ; ssize_t count ; unsigned char * graydata ; XCFPixelInfo * xcfdata , * xcfodata ; <S2SV_StartBug> xcfdata = ( XCFPixelInfo * ) AcquireQuantumMemory ( data_length , sizeof ( * xcfdata ) ) ; <S2SV_EndBug> if ( xcfdata == ( XCFPixelInfo * ) NULL ) ThrowBinaryException ( ResourceLimitError , \"MemoryAllocationFailed\" , image -> filename ) ; xcfodata = xcfdata ; graydata = ( unsigned char * ) xcfdata ; count = ReadBlob ( image , data_length , ( unsigned char * ) xcfdata ) ; if ( count != ( ssize_t ) data_length ) ThrowBinaryException ( CorruptImageError , \"NotEnoughPixelData\" , image -> filename ) ; for ( y = 0 ; y < ( ssize_t ) tile_image -> rows ; y ++ ) { q = GetAuthenticPixels ( tile_image , 0 , y , tile_image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; if ( inDocInfo -> image_type == GIMP_GRAY ) { for ( x = 0 ; x < ( ssize_t ) tile_image -> columns ; x ++ ) { SetPixelGray ( tile_image , ScaleCharToQuantum ( * graydata ) , q ) ; SetPixelAlpha ( tile_image , ScaleCharToQuantum ( ( unsigned char ) inLayerInfo -> alpha ) , q ) ; graydata ++ ; q += GetPixelChannels ( tile_image ) ; } } else if ( inDocInfo -> image_type == GIMP_RGB ) { for ( x = 0 ; x < ( ssize_t ) tile_image -> columns ; x ++ ) { SetPixelRed ( tile_image , ScaleCharToQuantum ( xcfdata -> red ) , q ) ; SetPixelGreen ( tile_image , ScaleCharToQuantum ( xcfdata -> green ) , q ) ; SetPixelBlue ( tile_image , ScaleCharToQuantum ( xcfdata -> blue ) , q ) ; SetPixelAlpha ( tile_image , xcfdata -> alpha == 255U ? TransparentAlpha : ScaleCharToQuantum ( ( unsigned char ) inLayerInfo -> alpha ) , q ) ; xcfdata ++ ; q += GetPixelChannels ( tile_image ) ; } } if ( SyncAuthenticPixels ( tile_image , exception ) == MagickFalse ) break ; } xcfodata = ( XCFPixelInfo * ) RelinquishMagickMemory ( xcfodata ) ; return MagickTrue ; }\n","target":"<S2SV_ModStart> ) AcquireQuantumMemory ( MagickMax ( data_length , tile_image -> columns * tile_image -> rows ) <S2SV_ModEnd> , sizeof (\n","project_and_commit_id":"ImageMagick@ImageMagick/a2e1064f288a353bc5fef7f79ccb7683759e775c","cve_id":"CVE-2016-7529","original_address":"https://github.com/ImageMagick/ImageMagick/commit/a2e1064f288a353bc5fef7f79ccb7683759e775c","time":"2017-04-19T14:59Z"},
	{"Unnamed: 0":4645,"cwe_id":"CWE-399","source":"CWE-399 static void vhost_net_ubuf_put_and_wait ( struct vhost_net_ubuf_ref * ubufs ) { kref_put ( & ubufs -> kref , vhost_net_zerocopy_done_signal ) ; wait_event ( ubufs -> wait , ! atomic_read ( & ubufs -> kref . refcount ) ) ; <S2SV_StartBug> kfree ( ubufs ) ; <S2SV_EndBug> }\n","target":"<S2SV_ModStart> ) ) ; <S2SV_ModEnd> } <S2SV_null> <S2SV_null>\n","project_and_commit_id":"torvalds@linux/dd7633ecd553a5e304d349aa6f8eb8a0417098c5","cve_id":"CVE-2013-4127","original_address":"https://github.com/torvalds/linux/commit/dd7633ecd553a5e304d349aa6f8eb8a0417098c5","time":"2013-07-29T13:59Z"},
	{"Unnamed: 0":3799,"cwe_id":"CWE-000","source":"CWE-000 void ping_unhash ( struct sock * sk ) { struct inet_sock * isk = inet_sk ( sk ) ; pr_debug ( \"ping_unhash(isk=%p,isk->num=%u)\\\\n\" , isk , isk -> inet_num ) ; <S2SV_StartBug> if ( sk_hashed ( sk ) ) { <S2SV_EndBug> <S2SV_StartBug> write_lock_bh ( & ping_table . lock ) ; <S2SV_EndBug> hlist_nulls_del ( & sk -> sk_nulls_node ) ; sk_nulls_node_init ( & sk -> sk_nulls_node ) ; sock_put ( sk ) ; isk -> inet_num = 0 ; isk -> inet_sport = 0 ; sock_prot_inuse_add ( sock_net ( sk ) , sk -> sk_prot , - 1 ) ; <S2SV_StartBug> write_unlock_bh ( & ping_table . lock ) ; <S2SV_EndBug> } <S2SV_StartBug> } <S2SV_EndBug>\n","target":"<S2SV_ModStart> inet_num ) ; write_lock_bh ( & ping_table . lock ) ; <S2SV_ModStart> ) ) { <S2SV_ModEnd> hlist_nulls_del ( & <S2SV_ModStart> 1 ) ; } <S2SV_ModStart> ) ; } <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null>\n","project_and_commit_id":"torvalds@linux/43a6684519ab0a6c52024b5e25322476cabad893","cve_id":"CVE-2017-2671","original_address":"https://github.com/torvalds/linux/commit/43a6684519ab0a6c52024b5e25322476cabad893","time":"2017-04-05T06:59Z"},
	{"Unnamed: 0":3346,"cwe_id":"CWE-20","source":"CWE-20 static void _out_result ( conn_t out , nad_t nad ) { int attr ; jid_t from , to ; char * rkey ; int rkeylen ; attr = nad_find_attr ( nad , 0 , - 1 , \"from\" , NULL ) ; if ( attr < 0 || ( from = jid_new ( NAD_AVAL ( nad , attr ) , NAD_AVAL_L ( nad , attr ) ) ) == NULL ) { log_debug ( ZONE , \"missing<S2SV_blank>or<S2SV_blank>invalid<S2SV_blank>from<S2SV_blank>on<S2SV_blank>db<S2SV_blank>result<S2SV_blank>packet\" ) ; nad_free ( nad ) ; return ; } attr = nad_find_attr ( nad , 0 , - 1 , \"to\" , NULL ) ; if ( attr < 0 || ( to = jid_new ( NAD_AVAL ( nad , attr ) , NAD_AVAL_L ( nad , attr ) ) ) == NULL ) { log_debug ( ZONE , \"missing<S2SV_blank>or<S2SV_blank>invalid<S2SV_blank>to<S2SV_blank>on<S2SV_blank>db<S2SV_blank>result<S2SV_blank>packet\" ) ; jid_free ( from ) ; nad_free ( nad ) ; return ; } rkey = s2s_route_key ( NULL , to -> domain , from -> domain ) ; rkeylen = strlen ( rkey ) ; <S2SV_StartBug> if ( nad_find_attr ( nad , 0 , - 1 , \"type\" , \"valid\" ) >= 0 ) { <S2SV_EndBug> log_write ( out -> s2s -> log , LOG_NOTICE , \"[%d]<S2SV_blank>[%s,<S2SV_blank>port=%d]<S2SV_blank>outgoing<S2SV_blank>route<S2SV_blank>\\'%s\\'<S2SV_blank>is<S2SV_blank>now<S2SV_blank>valid%s%s\" , out -> fd -> fd , out -> ip , out -> port , rkey , ( out -> s -> flags & SX_SSL_WRAPPER ) ? \",<S2SV_blank>TLS<S2SV_blank>negotiated\" : \"\" , out -> s -> compressed ? \",<S2SV_blank>ZLIB<S2SV_blank>compression<S2SV_blank>enabled\" : \"\" ) ; xhash_put ( out -> states , pstrdup ( xhash_pool ( out -> states ) , rkey ) , ( void * ) conn_VALID ) ; log_debug ( ZONE , \"%s<S2SV_blank>valid,<S2SV_blank>flushing<S2SV_blank>queue\" , rkey ) ; out_flush_route_queue ( out -> s2s , rkey , rkeylen ) ; free ( rkey ) ; jid_free ( from ) ; jid_free ( to ) ; nad_free ( nad ) ; return ; } log_write ( out -> s2s -> log , LOG_NOTICE , \"[%d]<S2SV_blank>[%s,<S2SV_blank>port=%d]<S2SV_blank>outgoing<S2SV_blank>route<S2SV_blank>\\'%s\\'<S2SV_blank>is<S2SV_blank>now<S2SV_blank>invalid\" , out -> fd -> fd , out -> ip , out -> port , rkey ) ; log_write ( out -> s2s -> log , LOG_NOTICE , \"[%d]<S2SV_blank>[%s,<S2SV_blank>port=%d]<S2SV_blank>closing<S2SV_blank>connection\" , out -> fd -> fd , out -> ip , out -> port ) ; sx_error ( out -> s , stream_err_INVALID_ID , \"dialback<S2SV_blank>negotiation<S2SV_blank>failed\" ) ; sx_close ( out -> s ) ; out_bounce_route_queue ( out -> s2s , rkey , rkeylen , stanza_err_SERVICE_UNAVAILABLE ) ; free ( rkey ) ; jid_free ( from ) ; jid_free ( to ) ; nad_free ( nad ) ; }\n","target":"<S2SV_ModStart> ) >= 0 && xhash_get ( out -> states , rkey ) == ( void * ) conn_INPROGRESS\n","project_and_commit_id":"Jabberd2@jabberd2/aabcffae560d5fd00cd1d2ffce5d760353cf0a4d","cve_id":"CVE-2012-3525","original_address":"https://github.com/Jabberd2/jabberd2/commit/aabcffae560d5fd00cd1d2ffce5d760353cf0a4d","time":"2012-08-25T16:55Z"},
	{"Unnamed: 0":5067,"cwe_id":"CWE-476","source":"CWE-476 static gint dissect_ac_if_hdr_body ( tvbuff_t * tvb , gint offset , packet_info * pinfo _U_ , proto_tree * tree , usb_conv_info_t * usb_conv_info ) { gint offset_start ; guint16 bcdADC ; guint8 ver_major ; double ver ; guint8 if_in_collection , i ; audio_conv_info_t * audio_conv_info ; offset_start = offset ; bcdADC = tvb_get_letohs ( tvb , offset ) ; ver_major = USB_AUDIO_BCD44_TO_DEC ( bcdADC >> 8 ) ; ver = ver_major + USB_AUDIO_BCD44_TO_DEC ( bcdADC & 0xFF ) / 100.0 ; proto_tree_add_double_format_value ( tree , hf_ac_if_hdr_ver , tvb , offset , 2 , ver , \"%2.2f\" , ver ) ; audio_conv_info = ( audio_conv_info_t * ) usb_conv_info -> class_data ; if ( ! audio_conv_info ) { audio_conv_info = wmem_new ( wmem_file_scope ( ) , audio_conv_info_t ) ; usb_conv_info -> class_data = audio_conv_info ; <S2SV_StartBug> } <S2SV_EndBug> audio_conv_info -> ver_major = ver_major ; offset += 2 ; if ( ver_major == 1 ) { proto_tree_add_item ( tree , hf_ac_if_hdr_total_len , tvb , offset , 2 , ENC_LITTLE_ENDIAN ) ; offset += 2 ; if_in_collection = tvb_get_guint8 ( tvb , offset ) ; proto_tree_add_item ( tree , hf_ac_if_hdr_bInCollection , tvb , offset , 1 , ENC_LITTLE_ENDIAN ) ; offset ++ ; for ( i = 0 ; i < if_in_collection ; i ++ ) { proto_tree_add_item ( tree , hf_ac_if_hdr_if_num , tvb , offset , 1 , ENC_LITTLE_ENDIAN ) ; offset ++ ; } } return offset - offset_start ; }\n","target":"<S2SV_ModStart> = audio_conv_info ; usb_conv_info -> class_data_type = USB_CONV_AUDIO ; } else if ( usb_conv_info -> class_data_type != USB_CONV_AUDIO ) { return 0 ;\n","project_and_commit_id":"wireshark@wireshark/2cb5985bf47bdc8bea78d28483ed224abdd33dc6","cve_id":"CVE-2016-5354","original_address":"https://github.com/wireshark/wireshark/commit/2cb5985bf47bdc8bea78d28483ed224abdd33dc6","time":"2016-08-07T16:59Z"},
	{"Unnamed: 0":5775,"cwe_id":"CWE-416","source":"CWE-416 void comps_mrtree_unite ( COMPS_MRTree * rt1 , COMPS_MRTree * rt2 ) { COMPS_HSList * tmplist , * tmp_subnodes ; COMPS_HSListItem * it , * it2 ; struct Pair { COMPS_HSList * subnodes ; char * key ; <S2SV_StartBug> char added ; <S2SV_EndBug> } * pair , * parent_pair ; pair = malloc ( sizeof ( struct Pair ) ) ; pair -> subnodes = rt2 -> subnodes ; pair -> key = NULL ; tmplist = comps_hslist_create ( ) ; comps_hslist_init ( tmplist , NULL , NULL , & free ) ; comps_hslist_append ( tmplist , pair , 0 ) ; while ( tmplist -> first != NULL ) { it = tmplist -> first ; comps_hslist_remove ( tmplist , tmplist -> first ) ; tmp_subnodes = ( ( struct Pair * ) it -> data ) -> subnodes ; parent_pair = ( struct Pair * ) it -> data ; free ( it ) ; <S2SV_StartBug> pair -> added = 0 ; <S2SV_EndBug> for ( it = tmp_subnodes -> first ; it != NULL ; it = it -> next ) { pair = malloc ( sizeof ( struct Pair ) ) ; pair -> subnodes = ( ( COMPS_MRTreeData * ) it -> data ) -> subnodes ; if ( parent_pair -> key != NULL ) { pair -> key = malloc ( sizeof ( char ) * ( strlen ( ( ( COMPS_MRTreeData * ) it -> data ) -> key ) + strlen ( parent_pair -> key ) + 1 ) ) ; memcpy ( pair -> key , parent_pair -> key , sizeof ( char ) * strlen ( parent_pair -> key ) ) ; memcpy ( pair -> key + strlen ( parent_pair -> key ) , ( ( COMPS_MRTreeData * ) it -> data ) -> key , sizeof ( char ) * ( strlen ( ( ( COMPS_MRTreeData * ) it -> data ) -> key ) + 1 ) ) ; } else { pair -> key = malloc ( sizeof ( char ) * ( strlen ( ( ( COMPS_MRTreeData * ) it -> data ) -> key ) + 1 ) ) ; memcpy ( pair -> key , ( ( COMPS_MRTreeData * ) it -> data ) -> key , sizeof ( char ) * ( strlen ( ( ( COMPS_MRTreeData * ) it -> data ) -> key ) + 1 ) ) ; } if ( ( ( COMPS_MRTreeData * ) it -> data ) -> data -> first != NULL ) { for ( it2 = ( ( COMPS_MRTreeData * ) it -> data ) -> data -> first ; it2 != NULL ; it2 = it2 -> next ) { comps_mrtree_set ( rt1 , pair -> key , it2 -> data ) ; } if ( ( ( COMPS_MRTreeData * ) it -> data ) -> subnodes -> first ) { comps_hslist_append ( tmplist , pair , 0 ) ; } else { free ( pair -> key ) ; free ( pair ) ; } } else { if ( ( ( COMPS_MRTreeData * ) it -> data ) -> subnodes -> first ) { comps_hslist_append ( tmplist , pair , 0 ) ; } else { free ( pair -> key ) ; free ( pair ) ; } } } free ( parent_pair -> key ) ; free ( parent_pair ) ; } comps_hslist_destroy ( & tmplist ) ; }\n","target":"<S2SV_ModStart> * key ; <S2SV_ModEnd> } * pair <S2SV_ModStart> it ) ; <S2SV_ModEnd> for ( it\n","project_and_commit_id":"rpm-software-management@libcomps/e3a5d056633677959ad924a51758876d415e7046","cve_id":"CVE-2019-3817","original_address":"https://github.com/rpm-software-management/libcomps/commit/e3a5d056633677959ad924a51758876d415e7046","time":"2019-03-27T13:29Z"},
	{"Unnamed: 0":5101,"cwe_id":"CWE-200","source":"CWE-200 static void ipv6_select_ident ( struct frag_hdr * fhdr , struct rt6_info * rt ) { static u32 ip6_idents_hashrnd __read_mostly ; <S2SV_StartBug> u32 hash , id ; <S2SV_EndBug> <S2SV_StartBug> net_get_random_once ( & ip6_idents_hashrnd , sizeof ( ip6_idents_hashrnd ) ) ; <S2SV_EndBug> hash = __ipv6_addr_jhash ( & rt -> rt6i_dst . addr , ip6_idents_hashrnd ) ; hash = __ipv6_addr_jhash ( & rt -> rt6i_src . addr , hash ) ; <S2SV_StartBug> id = ip_idents_reserve ( hash , 1 ) ; <S2SV_EndBug> fhdr -> identification = htonl ( id ) ; }\n","target":"<S2SV_ModStart> ip6_idents_hashrnd __read_mostly ; static u32 ip6_idents_hashrnd_extra __read_mostly ; <S2SV_ModStart> sizeof ( ip6_idents_hashrnd ) ) ; net_get_random_once ( & ip6_idents_hashrnd_extra , sizeof ( ip6_idents_hashrnd_extra <S2SV_ModStart> hash ) ; hash = jhash_1word ( hash , ip6_idents_hashrnd_extra ) ;\n","project_and_commit_id":"torvalds@linux/55f0fc7a02de8f12757f4937143d8d5091b2e40b","cve_id":"CVE-2019-10638","original_address":"https://github.com/torvalds/linux/commit/55f0fc7a02de8f12757f4937143d8d5091b2e40b","time":"2019-07-05T23:15Z"},
	{"Unnamed: 0":4585,"cwe_id":"CWE-415","source":"CWE-415 const char * util_acl_to_str ( const sc_acl_entry_t * e ) { static char line [ 80 ] , buf [ 20 ] ; unsigned int acl ; if ( e == NULL ) return \"N/A\" ; line [ 0 ] = 0 ; while ( e != NULL ) { acl = e -> method ; switch ( acl ) { case SC_AC_UNKNOWN : return \"N/A\" ; case SC_AC_NEVER : return \"NEVR\" ; case SC_AC_NONE : return \"NONE\" ; case SC_AC_CHV : strcpy ( buf , \"CHV\" ) ; if ( e -> key_ref != SC_AC_KEY_REF_NONE ) sprintf ( buf + 3 , \"%d\" , e -> key_ref ) ; break ; case SC_AC_TERM : strcpy ( buf , \"TERM\" ) ; break ; case SC_AC_PRO : strcpy ( buf , \"PROT\" ) ; break ; case SC_AC_AUT : strcpy ( buf , \"AUTH\" ) ; if ( e -> key_ref != SC_AC_KEY_REF_NONE ) sprintf ( buf + 4 , \"%d\" , e -> key_ref ) ; break ; case SC_AC_SEN : strcpy ( buf , \"Sec.Env.<S2SV_blank>\" ) ; if ( e -> key_ref != SC_AC_KEY_REF_NONE ) sprintf ( buf + 3 , \"#%d\" , e -> key_ref ) ; break ; case SC_AC_SCB : strcpy ( buf , \"Sec.ControlByte<S2SV_blank>\" ) ; if ( e -> key_ref != SC_AC_KEY_REF_NONE ) sprintf ( buf + 3 , \"Ox%X\" , e -> key_ref ) ; break ; case SC_AC_IDA : strcpy ( buf , \"PKCS#15<S2SV_blank>AuthID<S2SV_blank>\" ) ; if ( e -> key_ref != SC_AC_KEY_REF_NONE ) sprintf ( buf + 3 , \"#%d\" , e -> key_ref ) ; break ; default : strcpy ( buf , \"????\" ) ; break ; } <S2SV_StartBug> strcat ( line , buf ) ; <S2SV_EndBug> <S2SV_StartBug> strcat ( line , \"<S2SV_blank>\" ) ; <S2SV_EndBug> e = e -> next ; } <S2SV_StartBug> line [ strlen ( line ) - 1 ] = 0 ; <S2SV_EndBug> return line ; }\n","target":"<S2SV_ModStart> break ; } strncat ( line , buf , sizeof line ) ; strncat <S2SV_ModEnd> ( line , <S2SV_ModStart> line , \"<S2SV_blank>\" , sizeof line <S2SV_ModStart> } line [ ( sizeof <S2SV_ModEnd> line ) - <S2SV_ModStart> 1 ] = '\\\\0' ; line [ strlen ( line ) - 1 ] =\n","project_and_commit_id":"OpenSC@OpenSC/360e95d45ac4123255a4c796db96337f332160ad","cve_id":"CVE-2018-16425","original_address":"https://github.com/OpenSC/OpenSC/commit/360e95d45ac4123255a4c796db96337f332160ad","time":"2018-09-04T00:29Z"},
	{"Unnamed: 0":89,"cwe_id":"CWE-787","source":"CWE-787 static int next_state_class ( CClassNode * cc , OnigCodePoint * vs , enum CCVALTYPE * type , enum CCSTATE * state , ScanEnv * env ) { int r ; if ( * state == CCS_RANGE ) return ONIGERR_CHAR_CLASS_VALUE_AT_END_OF_RANGE ; if ( * state == CCS_VALUE && * type != CCV_CLASS ) { if ( * type == CCV_SB ) BITSET_SET_BIT ( cc -> bs , ( int ) ( * vs ) ) ; else if ( * type == CCV_CODE_POINT ) { r = add_code_range ( & ( cc -> mbuf ) , env , * vs , * vs ) ; if ( r < 0 ) return r ; } } <S2SV_StartBug> * state = CCS_VALUE ; <S2SV_EndBug> * type = CCV_CLASS ; return 0 ; }\n","target":"<S2SV_ModStart> ; } } if ( * state != CCS_START )\n","project_and_commit_id":"kkos@oniguruma/3b63d12038c8d8fc278e81c942fa9bec7c704c8b","cve_id":"CVE-2017-9228","original_address":"https://github.com/kkos/oniguruma/commit/3b63d12038c8d8fc278e81c942fa9bec7c704c8b","time":"2017-05-24T15:29Z"},
	{"Unnamed: 0":3377,"cwe_id":"CWE-269","source":"CWE-269 void inode_init_owner ( struct inode * inode , const struct inode * dir , umode_t mode ) { inode -> i_uid = current_fsuid ( ) ; if ( dir && dir -> i_mode & S_ISGID ) { inode -> i_gid = dir -> i_gid ; if ( S_ISDIR ( mode ) ) mode |= S_ISGID ; <S2SV_StartBug> } else <S2SV_EndBug> inode -> i_gid = current_fsgid ( ) ; inode -> i_mode = mode ; }\n","target":"<S2SV_ModStart> |= S_ISGID ; else if ( ( mode & ( S_ISGID | S_IXGRP ) ) == ( S_ISGID | S_IXGRP ) && ! in_group_p ( inode -> i_gid ) && ! capable_wrt_inode_uidgid ( dir , CAP_FSETID ) ) mode &= ~ S_ISGID ;\n","project_and_commit_id":"torvalds@linux/0fa3ecd87848c9c93c2c828ef4c3a8ca36ce46c7","cve_id":"CVE-2018-13405","original_address":"https://github.com/torvalds/linux/commit/0fa3ecd87848c9c93c2c828ef4c3a8ca36ce46c7","time":"2018-07-06T14:29Z"},
	{"Unnamed: 0":522,"cwe_id":"CWE-200","source":"CWE-200 IMPEG2D_ERROR_CODES_T impeg2d_dec_seq_hdr ( dec_state_t * ps_dec ) { stream_t * ps_stream ; ps_stream = & ps_dec -> s_bit_stream ; UWORD16 u2_height ; UWORD16 u2_width ; if ( impeg2d_bit_stream_nxt ( ps_stream , START_CODE_LEN ) != SEQUENCE_HEADER_CODE ) { impeg2d_bit_stream_flush ( ps_stream , START_CODE_LEN ) ; return IMPEG2D_FRM_HDR_START_CODE_NOT_FOUND ; } impeg2d_bit_stream_flush ( ps_stream , START_CODE_LEN ) ; u2_width = impeg2d_bit_stream_get ( ps_stream , 12 ) ; u2_height = impeg2d_bit_stream_get ( ps_stream , 12 ) ; if ( ( u2_width != ps_dec -> u2_horizontal_size ) || ( u2_height != ps_dec -> u2_vertical_size ) ) { if ( 0 == ps_dec -> u2_header_done ) { ps_dec -> u2_horizontal_size = u2_width ; ps_dec -> u2_vertical_size = u2_height ; if ( 0 == ps_dec -> u4_frm_buf_stride ) { ps_dec -> u4_frm_buf_stride = ( UWORD32 ) ALIGN16 ( u2_width ) ; } } else { if ( ( u2_width > ps_dec -> u2_create_max_width ) || ( u2_height > ps_dec -> u2_create_max_height ) ) { IMPEG2D_ERROR_CODES_T e_error = IMPEG2D_UNSUPPORTED_DIMENSIONS ; ps_dec -> u2_reinit_max_height = u2_height ; ps_dec -> u2_reinit_max_width = u2_width ; return e_error ; } else { return ( IMPEG2D_ERROR_CODES_T ) IVD_RES_CHANGED ; } } } if ( ( ps_dec -> u2_horizontal_size > ps_dec -> u2_create_max_width ) || ( ps_dec -> u2_vertical_size > ps_dec -> u2_create_max_height ) ) { IMPEG2D_ERROR_CODES_T e_error = IMPEG2D_UNSUPPORTED_DIMENSIONS ; return SET_IVD_FATAL_ERROR ( e_error ) ; } ps_dec -> u2_aspect_ratio_info = impeg2d_bit_stream_get ( ps_stream , 4 ) ; <S2SV_StartBug> ps_dec -> u2_frame_rate_code = impeg2d_bit_stream_get ( ps_stream , 4 ) ; <S2SV_EndBug> impeg2d_bit_stream_flush ( ps_stream , 18 ) ; GET_MARKER_BIT ( ps_dec , ps_stream ) ; impeg2d_bit_stream_flush ( ps_stream , 11 ) ; if ( impeg2d_bit_stream_get_bit ( ps_stream ) == 1 ) { UWORD16 i ; for ( i = 0 ; i < NUM_PELS_IN_BLOCK ; i ++ ) { ps_dec -> au1_intra_quant_matrix [ gau1_impeg2_inv_scan_zig_zag [ i ] ] = ( UWORD8 ) impeg2d_bit_stream_get ( ps_stream , 8 ) ; } } else { memcpy ( ps_dec -> au1_intra_quant_matrix , gau1_impeg2_intra_quant_matrix_default , NUM_PELS_IN_BLOCK ) ; } if ( impeg2d_bit_stream_get_bit ( ps_stream ) == 1 ) { UWORD16 i ; for ( i = 0 ; i < NUM_PELS_IN_BLOCK ; i ++ ) { ps_dec -> au1_inter_quant_matrix [ gau1_impeg2_inv_scan_zig_zag [ i ] ] = ( UWORD8 ) impeg2d_bit_stream_get ( ps_stream , 8 ) ; } } else { memcpy ( ps_dec -> au1_inter_quant_matrix , gau1_impeg2_inter_quant_matrix_default , NUM_PELS_IN_BLOCK ) ; } impeg2d_next_start_code ( ps_dec ) ; return ( IMPEG2D_ERROR_CODES_T ) IVD_ERROR_NONE ; }\n","target":"<S2SV_ModStart> 4 ) ; if ( ps_dec -> u2_frame_rate_code > MPEG2_MAX_FRAME_RATE_CODE ) { return IMPEG2D_FRM_HDR_DECODE_ERR ; }\n","project_and_commit_id":"external@libmpeg2/f301cff2c1ddd880d9a2c77b22602a137519867b","cve_id":"CVE-2017-0556","original_address":"https://android.googlesource.com/platform/external/libmpeg2/+/f301cff2c1ddd880d9a2c77b22602a137519867b","time":"2017-04-07T22:59Z"},
	{"Unnamed: 0":809,"cwe_id":"CWE-20","source":"CWE-20 apr_status_t ap_http_filter ( ap_filter_t * f , apr_bucket_brigade * b , ap_input_mode_t mode , apr_read_type_e block , apr_off_t readbytes ) { core_server_config * conf ; apr_bucket * e ; http_ctx_t * ctx = f -> ctx ; apr_status_t rv ; apr_off_t totalread ; int again ; conf = ( core_server_config * ) ap_get_module_config ( f -> r -> server -> module_config , & core_module ) ; if ( mode != AP_MODE_READBYTES && mode != AP_MODE_GETLINE ) { return ap_get_brigade ( f -> next , b , mode , block , readbytes ) ; } if ( ! ctx ) { const char * tenc , * lenp ; f -> ctx = ctx = apr_pcalloc ( f -> r -> pool , sizeof ( * ctx ) ) ; ctx -> state = BODY_NONE ; if ( ! f -> r -> proxyreq ) { ctx -> limit = ap_get_limit_req_body ( f -> r ) ; } else { ctx -> limit = 0 ; } tenc = apr_table_get ( f -> r -> headers_in , \"Transfer-Encoding\" ) ; lenp = apr_table_get ( f -> r -> headers_in , \"Content-Length\" ) ; if ( tenc ) { if ( strcasecmp ( tenc , \"chunked\" ) == 0 || ap_find_last_token ( f -> r -> pool , tenc , \"chunked\" ) ) { ctx -> state = BODY_CHUNK ; } else if ( f -> r -> proxyreq == PROXYREQ_RESPONSE ) { ap_log_rerror ( APLOG_MARK , APLOG_INFO , 0 , f -> r , APLOGNO ( 02555 ) <S2SV_StartBug> \"Unknown<S2SV_blank>Transfer-Encoding:<S2SV_blank>%s;\" <S2SV_EndBug> \"<S2SV_blank>using<S2SV_blank>read-until-close\" , tenc ) ; tenc = NULL ; } else { ap_log_rerror ( APLOG_MARK , APLOG_INFO , 0 , f -> r , APLOGNO ( 01585 ) \"Unknown<S2SV_blank>Transfer-Encoding:<S2SV_blank>%s\" , tenc ) ; return APR_EGENERAL ; } lenp = NULL ; } if ( lenp ) { char * endstr ; ctx -> state = BODY_LENGTH ; if ( apr_strtoff ( & ctx -> remaining , lenp , & endstr , 10 ) || endstr == lenp || * endstr || ctx -> remaining < 0 ) { ctx -> remaining = 0 ; ap_log_rerror ( APLOG_MARK , APLOG_INFO , 0 , f -> r , APLOGNO ( 01587 ) \"Invalid<S2SV_blank>Content-Length\" ) ; <S2SV_StartBug> return APR_ENOSPC ; <S2SV_EndBug> } if ( ctx -> limit && ctx -> limit < ctx -> remaining ) { ap_log_rerror ( APLOG_MARK , APLOG_INFO , 0 , f -> r , APLOGNO ( 01588 ) \"Requested<S2SV_blank>content-length<S2SV_blank>of<S2SV_blank>%\" APR_OFF_T_FMT \"<S2SV_blank>is<S2SV_blank>larger<S2SV_blank>than<S2SV_blank>the<S2SV_blank>configured<S2SV_blank>limit\" \"<S2SV_blank>of<S2SV_blank>%\" APR_OFF_T_FMT , ctx -> remaining , ctx -> limit ) ; return APR_ENOSPC ; } } if ( ctx -> state == BODY_NONE && f -> r -> proxyreq != PROXYREQ_RESPONSE ) { e = apr_bucket_eos_create ( f -> c -> bucket_alloc ) ; APR_BRIGADE_INSERT_TAIL ( b , e ) ; ctx -> eos_sent = 1 ; return APR_SUCCESS ; } if ( ( ctx -> state == BODY_CHUNK || ( ctx -> state == BODY_LENGTH && ctx -> remaining > 0 ) ) && f -> r -> expecting_100 && f -> r -> proto_num >= HTTP_VERSION ( 1 , 1 ) && ! ( f -> r -> eos_sent || f -> r -> bytes_sent ) ) { if ( ! ap_is_HTTP_SUCCESS ( f -> r -> status ) ) { ctx -> state = BODY_NONE ; ctx -> eos_sent = 1 ; } else { char * tmp ; int len ; apr_bucket_brigade * bb ; bb = apr_brigade_create ( f -> r -> pool , f -> c -> bucket_alloc ) ; f -> r -> expecting_100 = 0 ; tmp = apr_pstrcat ( f -> r -> pool , AP_SERVER_PROTOCOL \"<S2SV_blank>\" , ap_get_status_line ( HTTP_CONTINUE ) , CRLF CRLF , NULL ) ; len = strlen ( tmp ) ; ap_xlate_proto_to_ascii ( tmp , len ) ; e = apr_bucket_pool_create ( tmp , len , f -> r -> pool , f -> c -> bucket_alloc ) ; APR_BRIGADE_INSERT_HEAD ( bb , e ) ; e = apr_bucket_flush_create ( f -> c -> bucket_alloc ) ; APR_BRIGADE_INSERT_TAIL ( bb , e ) ; rv = ap_pass_brigade ( f -> c -> output_filters , bb ) ; <S2SV_StartBug> if ( rv != APR_SUCCESS ) { <S2SV_EndBug> return AP_FILTER_ERROR ; } } } } if ( ctx -> eos_sent ) { e = apr_bucket_eos_create ( f -> c -> bucket_alloc ) ; APR_BRIGADE_INSERT_TAIL ( b , e ) ; return APR_SUCCESS ; } do { apr_brigade_cleanup ( b ) ; again = 0 ; switch ( ctx -> state ) { case BODY_CHUNK : case BODY_CHUNK_PART : case BODY_CHUNK_EXT : <S2SV_StartBug> case BODY_CHUNK_END : { <S2SV_EndBug> rv = ap_get_brigade ( f -> next , b , AP_MODE_GETLINE , block , 0 ) ; if ( block == APR_NONBLOCK_READ && ( ( rv == APR_SUCCESS && APR_BRIGADE_EMPTY ( b ) ) || ( APR_STATUS_IS_EAGAIN ( rv ) ) ) ) { return APR_EAGAIN ; } if ( rv == APR_EOF ) { return APR_INCOMPLETE ; } if ( rv != APR_SUCCESS ) { return rv ; } e = APR_BRIGADE_FIRST ( b ) ; while ( e != APR_BRIGADE_SENTINEL ( b ) ) { const char * buffer ; apr_size_t len ; if ( ! APR_BUCKET_IS_METADATA ( e ) ) { rv = apr_bucket_read ( e , & buffer , & len , APR_BLOCK_READ ) ; if ( rv == APR_SUCCESS ) { rv = parse_chunk_size ( ctx , buffer , len , f -> r -> server -> limit_req_fieldsize ) ; } if ( rv != APR_SUCCESS ) { ap_log_rerror ( APLOG_MARK , APLOG_INFO , rv , f -> r , APLOGNO ( 01590 ) \"Error<S2SV_blank>reading<S2SV_blank>chunk<S2SV_blank>%s<S2SV_blank>\" , ( APR_ENOSPC == rv ) ? \"(overflow)\" : \"\" ) ; return rv ; } } apr_bucket_delete ( e ) ; e = APR_BRIGADE_FIRST ( b ) ; } again = 1 ; if ( ctx -> state == BODY_CHUNK_TRAILER ) { <S2SV_StartBug> int merge_trailers = <S2SV_EndBug> conf -> merge_trailers == AP_MERGE_TRAILERS_ENABLE ; return read_chunked_trailers ( ctx , f , b , merge_trailers ) ; } break ; } case BODY_NONE : case BODY_LENGTH : case BODY_CHUNK_DATA : { if ( ctx -> state != BODY_NONE && ctx -> remaining < readbytes ) { readbytes = ctx -> remaining ; } if ( readbytes > 0 ) { rv = ap_get_brigade ( f -> next , b , mode , block , readbytes ) ; if ( block == APR_NONBLOCK_READ && ( ( rv == APR_SUCCESS && APR_BRIGADE_EMPTY ( b ) ) || ( APR_STATUS_IS_EAGAIN ( rv ) ) ) ) { return APR_EAGAIN ; } if ( rv == APR_EOF && ctx -> state != BODY_NONE && ctx -> remaining > 0 ) { return APR_INCOMPLETE ; } if ( rv != APR_SUCCESS ) { return rv ; } apr_brigade_length ( b , 0 , & totalread ) ; AP_DEBUG_ASSERT ( totalread >= 0 ) ; if ( ctx -> state != BODY_NONE ) { ctx -> remaining -= totalread ; if ( ctx -> remaining > 0 ) { e = APR_BRIGADE_LAST ( b ) ; if ( APR_BUCKET_IS_EOS ( e ) ) { apr_bucket_delete ( e ) ; return APR_INCOMPLETE ; } } else if ( ctx -> state == BODY_CHUNK_DATA ) { ctx -> state = BODY_CHUNK_END ; ctx -> chunk_used = 0 ; } } } if ( ctx -> state == BODY_LENGTH && ctx -> remaining == 0 ) { e = apr_bucket_eos_create ( f -> c -> bucket_alloc ) ; APR_BRIGADE_INSERT_TAIL ( b , e ) ; ctx -> eos_sent = 1 ; } if ( ctx -> limit ) { ctx -> limit_used += totalread ; if ( ctx -> limit < ctx -> limit_used ) { ap_log_rerror ( APLOG_MARK , APLOG_INFO , 0 , f -> r , APLOGNO ( 01591 ) \"Read<S2SV_blank>content-length<S2SV_blank>of<S2SV_blank>%\" APR_OFF_T_FMT \"<S2SV_blank>is<S2SV_blank>larger<S2SV_blank>than<S2SV_blank>the<S2SV_blank>configured<S2SV_blank>limit\" \"<S2SV_blank>of<S2SV_blank>%\" APR_OFF_T_FMT , ctx -> limit_used , ctx -> limit ) ; return APR_ENOSPC ; } } break ; } case BODY_CHUNK_TRAILER : { rv = ap_get_brigade ( f -> next , b , mode , block , readbytes ) ; if ( block == APR_NONBLOCK_READ && ( ( rv == APR_SUCCESS && APR_BRIGADE_EMPTY ( b ) ) || ( APR_STATUS_IS_EAGAIN ( rv ) ) ) ) { return APR_EAGAIN ; } if ( rv != APR_SUCCESS ) { return rv ; } break ; } default : { <S2SV_StartBug> break ; <S2SV_EndBug> } } } while ( again ) ; return APR_SUCCESS ; }\n","target":"<S2SV_ModStart> ( 02555 ) \"Unknown<S2SV_blank>Transfer-Encoding:<S2SV_blank>%s;<S2SV_blank>\" \"using<S2SV_blank>read-until-close\" <S2SV_ModEnd> , tenc ) <S2SV_ModStart> ) ; return APR_EINVAL <S2SV_ModEnd> ; } if <S2SV_ModStart> bb ) ; apr_brigade_cleanup ( bb ) ; <S2SV_ModStart> BODY_CHUNK_EXT : case BODY_CHUNK_LF : case BODY_CHUNK_END : case BODY_CHUNK_END_LF <S2SV_ModEnd> : { rv <S2SV_ModStart> BODY_CHUNK_TRAILER ) { return read_chunked_trailers ( ctx , f , b , conf -> merge_trailers == AP_MERGE_TRAILERS_ENABLE <S2SV_ModEnd> ) ; } <S2SV_ModStart> default : { ap_log_rerror ( APLOG_MARK , APLOG_ERR , 0 , f -> r , APLOGNO ( 02901 ) \"Unexpected<S2SV_blank>body<S2SV_blank>state<S2SV_blank>(%i)\" , ( int ) ctx -> state ) ; return APR_EGENERAL <S2SV_ModEnd> ; } }\n","project_and_commit_id":"apache@httpd/e427c41257957b57036d5a549b260b6185d1dd73","cve_id":"CVE-2015-3183","original_address":"https://github.com/apache/httpd/commit/e427c41257957b57036d5a549b260b6185d1dd73","time":"2015-07-20T23:59Z"},
	{"Unnamed: 0":1749,"cwe_id":"CWE-20","source":"CWE-20 error_t mqttSnClientSendUnsubscribe ( MqttSnClientContext * context , const char_t * topicName ) { error_t error ; systime_t time ; uint16_t topicId ; MqttSnFlags flags ; error = NO_ERROR ; flags . all = 0 ; topicId = mqttSnClientFindPredefTopicName ( context , topicName ) ; if ( topicId != MQTT_SN_INVALID_TOPIC_ID ) { flags . topicIdType = MQTT_SN_PREDEFINED_TOPIC_ID ; } else { <S2SV_StartBug> if ( osStrlen ( topicName ) == 2 && strchr ( topicName , '#' ) == NULL && <S2SV_EndBug> <S2SV_StartBug> strchr ( topicName , '+' ) == NULL ) <S2SV_EndBug> { flags . topicIdType = MQTT_SN_SHORT_TOPIC_NAME ; } else { flags . topicIdType = MQTT_SN_NORMAL_TOPIC_NAME ; } error = mqttSnFormatUnsubscribe ( & context -> message , flags , context -> msgId , topicId , topicName ) ; } if ( ! error ) { TRACE_INFO ( \"Sending<S2SV_blank>UNSUBSCRIBE<S2SV_blank>message<S2SV_blank>(%\" PRIuSIZE \"<S2SV_blank>bytes)...\\\\r\\\\n\" , context -> message . length ) ; mqttSnDumpMessage ( context -> message . buffer , context -> message . length ) ; error = mqttSnClientSendDatagram ( context , context -> message . buffer , context -> message . length ) ; time = osGetSystemTime ( ) ; context -> retransmitStartTime = time ; context -> keepAliveTimestamp = time ; context -> state = MQTT_SN_CLIENT_STATE_SENDING_REQ ; context -> msgType = MQTT_SN_MSG_TYPE_UNSUBSCRIBE ; } return error ; }\n","target":"<S2SV_ModStart> == 2 && osStrchr <S2SV_ModEnd> ( topicName , <S2SV_ModStart> == NULL && osStrchr <S2SV_ModEnd> ( topicName ,\n","project_and_commit_id":"Oryx-Embedded@CycloneTCP/de5336016edbe1e90327d0ed1cba5c4e49114366","cve_id":"CVE-2021-26788","original_address":"https://github.com/Oryx-Embedded/CycloneTCP/commit/de5336016edbe1e90327d0ed1cba5c4e49114366","time":"2021-03-08T13:15Z"},
	{"Unnamed: 0":5458,"cwe_id":"CWE-20","source":"CWE-20 static int dccp_error ( struct net * net , struct nf_conn * tmpl , struct sk_buff * skb , unsigned int dataoff , enum ip_conntrack_info * ctinfo , u_int8_t pf , unsigned int hooknum ) { struct dccp_hdr _dh , * dh ; unsigned int dccp_len = skb -> len - dataoff ; unsigned int cscov ; const char * msg ; <S2SV_StartBug> dh = skb_header_pointer ( skb , dataoff , sizeof ( _dh ) , & dh ) ; <S2SV_EndBug> if ( dh == NULL ) { msg = \"nf_ct_dccp:<S2SV_blank>short<S2SV_blank>packet<S2SV_blank>\" ; goto out_invalid ; } if ( dh -> dccph_doff * 4 < sizeof ( struct dccp_hdr ) || dh -> dccph_doff * 4 > dccp_len ) { msg = \"nf_ct_dccp:<S2SV_blank>truncated/malformed<S2SV_blank>packet<S2SV_blank>\" ; goto out_invalid ; } cscov = dccp_len ; if ( dh -> dccph_cscov ) { cscov = ( dh -> dccph_cscov - 1 ) * 4 ; if ( cscov > dccp_len ) { msg = \"nf_ct_dccp:<S2SV_blank>bad<S2SV_blank>checksum<S2SV_blank>coverage<S2SV_blank>\" ; goto out_invalid ; } } if ( net -> ct . sysctl_checksum && hooknum == NF_INET_PRE_ROUTING && nf_checksum_partial ( skb , hooknum , dataoff , cscov , IPPROTO_DCCP , pf ) ) { msg = \"nf_ct_dccp:<S2SV_blank>bad<S2SV_blank>checksum<S2SV_blank>\" ; goto out_invalid ; } if ( dh -> dccph_type >= DCCP_PKT_INVALID ) { msg = \"nf_ct_dccp:<S2SV_blank>reserved<S2SV_blank>packet<S2SV_blank>type<S2SV_blank>\" ; goto out_invalid ; } return NF_ACCEPT ; out_invalid : if ( LOG_INVALID ( net , IPPROTO_DCCP ) ) nf_log_packet ( net , pf , 0 , skb , NULL , NULL , NULL , \"%s\" , msg ) ; return - NF_ACCEPT ; }\n","target":"<S2SV_ModStart> ) , & _dh <S2SV_ModEnd> ) ; if\n","project_and_commit_id":"torvalds@linux/b22f5126a24b3b2f15448c3f2a254fc10cbc2b92","cve_id":"CVE-2014-2523","original_address":"https://github.com/torvalds/linux/commit/b22f5126a24b3b2f15448c3f2a254fc10cbc2b92","time":"2014-03-24T16:40Z"},
	{"Unnamed: 0":3023,"cwe_id":"CWE-476","source":"CWE-476 static int get_endpoints ( struct usbtest_dev * dev , struct usb_interface * intf ) { int tmp ; struct usb_host_interface * alt ; struct usb_host_endpoint * in , * out ; struct usb_host_endpoint * iso_in , * iso_out ; struct usb_host_endpoint * int_in , * int_out ; struct usb_device * udev ; for ( tmp = 0 ; tmp < intf -> num_altsetting ; tmp ++ ) { unsigned ep ; in = out = NULL ; iso_in = iso_out = NULL ; int_in = int_out = NULL ; alt = intf -> altsetting + tmp ; if ( override_alt >= 0 && override_alt != alt -> desc . bAlternateSetting ) continue ; for ( ep = 0 ; ep < alt -> desc . bNumEndpoints ; ep ++ ) { struct usb_host_endpoint * e ; int edi ; e = alt -> endpoint + ep ; edi = usb_endpoint_dir_in ( & e -> desc ) ; switch ( usb_endpoint_type ( & e -> desc ) ) { case USB_ENDPOINT_XFER_BULK : endpoint_update ( edi , & in , & out , e ) ; continue ; case USB_ENDPOINT_XFER_INT : if ( dev -> info -> intr ) endpoint_update ( edi , & int_in , & int_out , e ) ; continue ; case USB_ENDPOINT_XFER_ISOC : if ( dev -> info -> iso ) endpoint_update ( edi , & iso_in , & iso_out , e ) ; default : continue ; } } if ( ( in && out ) || iso_in || iso_out || int_in || int_out ) goto found ; } return - EINVAL ; found : udev = testdev_to_usbdev ( dev ) ; dev -> info -> alt = alt -> desc . bAlternateSetting ; if ( alt -> desc . bAlternateSetting != 0 ) { tmp = usb_set_interface ( udev , alt -> desc . bInterfaceNumber , alt -> desc . bAlternateSetting ) ; if ( tmp < 0 ) return tmp ; } <S2SV_StartBug> if ( in ) { <S2SV_EndBug> dev -> in_pipe = usb_rcvbulkpipe ( udev , in -> desc . bEndpointAddress & USB_ENDPOINT_NUMBER_MASK ) ; <S2SV_StartBug> dev -> out_pipe = usb_sndbulkpipe ( udev , <S2SV_EndBug> out -> desc . bEndpointAddress & USB_ENDPOINT_NUMBER_MASK ) ; <S2SV_StartBug> } <S2SV_EndBug> if ( iso_in ) { dev -> iso_in = & iso_in -> desc ; dev -> in_iso_pipe = usb_rcvisocpipe ( udev , iso_in -> desc . bEndpointAddress & USB_ENDPOINT_NUMBER_MASK ) ; } if ( iso_out ) { dev -> iso_out = & iso_out -> desc ; dev -> out_iso_pipe = usb_sndisocpipe ( udev , iso_out -> desc . bEndpointAddress & USB_ENDPOINT_NUMBER_MASK ) ; } if ( int_in ) { dev -> int_in = & int_in -> desc ; dev -> in_int_pipe = usb_rcvintpipe ( udev , int_in -> desc . bEndpointAddress & USB_ENDPOINT_NUMBER_MASK ) ; } if ( int_out ) { dev -> int_out = & int_out -> desc ; dev -> out_int_pipe = usb_sndintpipe ( udev , int_out -> desc . bEndpointAddress & USB_ENDPOINT_NUMBER_MASK ) ; } return 0 ; }\n","target":"<S2SV_ModStart> ( in ) <S2SV_ModEnd> dev -> in_pipe <S2SV_ModStart> USB_ENDPOINT_NUMBER_MASK ) ; if ( out ) <S2SV_ModStart> USB_ENDPOINT_NUMBER_MASK ) ; <S2SV_ModEnd> if ( iso_in\n","project_and_commit_id":"torvalds@linux/7c80f9e4a588f1925b07134bb2e3689335f6c6d8","cve_id":"CVE-2017-16532","original_address":"https://github.com/torvalds/linux/commit/7c80f9e4a588f1925b07134bb2e3689335f6c6d8","time":"2017-11-04T01:29Z"},
	{"Unnamed: 0":3990,"cwe_id":"CWE-362","source":"CWE-362 int vfs_rename ( struct inode * old_dir , struct dentry * old_dentry , struct inode * new_dir , struct dentry * new_dentry , struct inode * * delegated_inode , unsigned int flags ) { int error ; bool is_dir = d_is_dir ( old_dentry ) ; <S2SV_StartBug> const unsigned char * old_name ; <S2SV_EndBug> struct inode * source = old_dentry -> d_inode ; struct inode * target = new_dentry -> d_inode ; bool new_is_dir = false ; unsigned max_links = new_dir -> i_sb -> s_max_links ; <S2SV_StartBug> if ( source == target ) <S2SV_EndBug> return 0 ; error = may_delete ( old_dir , old_dentry , is_dir ) ; if ( error ) return error ; if ( ! target ) { error = may_create ( new_dir , new_dentry ) ; } else { new_is_dir = d_is_dir ( new_dentry ) ; if ( ! ( flags & RENAME_EXCHANGE ) ) error = may_delete ( new_dir , new_dentry , is_dir ) ; else error = may_delete ( new_dir , new_dentry , new_is_dir ) ; } if ( error ) return error ; if ( ! old_dir -> i_op -> rename ) return - EPERM ; if ( new_dir != old_dir ) { if ( is_dir ) { error = inode_permission ( source , MAY_WRITE ) ; if ( error ) return error ; } if ( ( flags & RENAME_EXCHANGE ) && new_is_dir ) { error = inode_permission ( target , MAY_WRITE ) ; if ( error ) return error ; } } error = security_inode_rename ( old_dir , old_dentry , new_dir , new_dentry , flags ) ; if ( error ) return error ; <S2SV_StartBug> old_name = fsnotify_oldname_init ( old_dentry -> d_name . name ) ; <S2SV_EndBug> dget ( new_dentry ) ; if ( ! is_dir || ( flags & RENAME_EXCHANGE ) ) lock_two_nondirectories ( source , target ) ; else if ( target ) inode_lock ( target ) ; error = - EBUSY ; if ( is_local_mountpoint ( old_dentry ) || is_local_mountpoint ( new_dentry ) ) goto out ; if ( max_links && new_dir != old_dir ) { error = - EMLINK ; if ( is_dir && ! new_is_dir && new_dir -> i_nlink >= max_links ) goto out ; if ( ( flags & RENAME_EXCHANGE ) && ! is_dir && new_is_dir && old_dir -> i_nlink >= max_links ) goto out ; } if ( is_dir && ! ( flags & RENAME_EXCHANGE ) && target ) shrink_dcache_parent ( new_dentry ) ; if ( ! is_dir ) { error = try_break_deleg ( source , delegated_inode ) ; if ( error ) goto out ; } if ( target && ! new_is_dir ) { error = try_break_deleg ( target , delegated_inode ) ; if ( error ) goto out ; } error = old_dir -> i_op -> rename ( old_dir , old_dentry , new_dir , new_dentry , flags ) ; if ( error ) goto out ; if ( ! ( flags & RENAME_EXCHANGE ) && target ) { if ( is_dir ) target -> i_flags |= S_DEAD ; dont_mount ( new_dentry ) ; detach_mounts ( new_dentry ) ; } if ( ! ( old_dir -> i_sb -> s_type -> fs_flags & FS_RENAME_DOES_D_MOVE ) ) { if ( ! ( flags & RENAME_EXCHANGE ) ) d_move ( old_dentry , new_dentry ) ; else d_exchange ( old_dentry , new_dentry ) ; } out : if ( ! is_dir || ( flags & RENAME_EXCHANGE ) ) unlock_two_nondirectories ( source , target ) ; else if ( target ) inode_unlock ( target ) ; dput ( new_dentry ) ; if ( ! error ) { fsnotify_move ( old_dir , new_dir , old_name , is_dir , ! ( flags & RENAME_EXCHANGE ) ? target : NULL , old_dentry ) ; if ( flags & RENAME_EXCHANGE ) { fsnotify_move ( new_dir , old_dir , old_dentry -> d_name . name , new_is_dir , NULL , new_dentry ) ; } } fsnotify_oldname_free ( old_name ) ; return error ; }\n","target":"<S2SV_ModStart> old_dentry ) ; <S2SV_ModEnd> struct inode * <S2SV_ModStart> -> s_max_links ; struct name_snapshot old_name ; <S2SV_ModStart> return error ; take_dentry_name_snapshot ( & old_name , old_dentry ) ; dget ( new_dentry ) ; if ( ! is_dir || ( flags & RENAME_EXCHANGE ) ) lock_two_nondirectories ( source , target ) ; else if ( target ) inode_lock ( target ) ; error = - EBUSY ; if ( is_local_mountpoint ( old_dentry ) || is_local_mountpoint ( new_dentry ) ) goto out ; if ( max_links && new_dir != old_dir ) { error = - EMLINK ; if ( is_dir && ! new_is_dir && new_dir -> i_nlink >= max_links ) goto out ; if ( ( flags & RENAME_EXCHANGE ) && ! is_dir && new_is_dir && old_dir -> i_nlink >= max_links ) goto out ; } if ( is_dir && ! ( flags & RENAME_EXCHANGE ) && target ) shrink_dcache_parent ( new_dentry ) ; if ( ! is_dir ) { error = try_break_deleg ( source , delegated_inode ) ; if ( error ) goto out ; } if ( target && ! new_is_dir ) { error = try_break_deleg ( target , delegated_inode ) ; if ( error ) goto out ; } error = old_dir -> i_op -> rename ( old_dir , old_dentry , new_dir , new_dentry , flags ) ; if ( error ) goto out ; if ( ! ( flags & RENAME_EXCHANGE ) && target ) { if ( is_dir ) target -> i_flags |= S_DEAD ; dont_mount ( new_dentry ) ; detach_mounts ( new_dentry ) ; } if ( ! ( old_dir -> i_sb -> s_type -> fs_flags & FS_RENAME_DOES_D_MOVE ) ) { if ( ! ( flags & RENAME_EXCHANGE ) ) d_move ( old_dentry , new_dentry ) ; else d_exchange ( old_dentry , new_dentry ) ; } out : if ( ! is_dir || ( flags & RENAME_EXCHANGE ) ) unlock_two_nondirectories ( source , target ) ; else if ( target ) inode_unlock ( target ) ; dput ( new_dentry ) ; if ( ! error ) { fsnotify_move ( old_dir , new_dir , old_name . name , is_dir , ! ( flags & RENAME_EXCHANGE ) ? target : NULL , old_dentry ) ; if ( flags & RENAME_EXCHANGE ) { fsnotify_move ( new_dir , old_dir , <S2SV_ModEnd> old_dentry -> d_name <S2SV_ModStart> d_name . name , new_is_dir , NULL , new_dentry ) ; } } release_dentry_name_snapshot ( & old_name <S2SV_ModEnd> ) ; return\n","project_and_commit_id":"torvalds@linux/49d31c2f389acfe83417083e1208422b4091cd9e","cve_id":"CVE-2017-7533","original_address":"https://github.com/torvalds/linux/commit/49d31c2f389acfe83417083e1208422b4091cd9e","time":"2017-08-05T16:29Z"},
	{"Unnamed: 0":4476,"cwe_id":"CWE-416","source":"CWE-416 static int snd_seq_device_dev_free ( struct snd_device * device ) { struct snd_seq_device * dev = device -> device_data ; <S2SV_StartBug> put_device ( & dev -> dev ) ; <S2SV_EndBug> return 0 ; }\n","target":"<S2SV_ModStart> -> device_data ; cancel_autoload_drivers ( ) ;\n","project_and_commit_id":"torvalds@linux/fc27fe7e8deef2f37cba3f2be2d52b6ca5eb9d57","cve_id":"CVE-2017-16528","original_address":"https://github.com/torvalds/linux/commit/fc27fe7e8deef2f37cba3f2be2d52b6ca5eb9d57","time":"2017-11-04T01:29Z"},
	{"Unnamed: 0":626,"cwe_id":"CWE-17","source":"CWE-17 int lxc_attach ( const char * name , const char * lxcpath , lxc_attach_exec_t exec_function , void * exec_payload , lxc_attach_options_t * options , pid_t * attached_process ) { int ret , status ; pid_t init_pid , pid , attached_pid , expected ; struct lxc_proc_context_info * init_ctx ; char * cwd ; char * new_cwd ; int ipc_sockets [ 2 ] ; <S2SV_StartBug> signed long personality ; <S2SV_EndBug> if ( ! options ) options = & attach_static_default_options ; init_pid = lxc_cmd_get_init_pid ( name , lxcpath ) ; if ( init_pid < 0 ) { ERROR ( \"failed<S2SV_blank>to<S2SV_blank>get<S2SV_blank>the<S2SV_blank>init<S2SV_blank>pid\" ) ; return - 1 ; } init_ctx = lxc_proc_get_context_info ( init_pid ) ; if ( ! init_ctx ) { ERROR ( \"failed<S2SV_blank>to<S2SV_blank>get<S2SV_blank>context<S2SV_blank>of<S2SV_blank>the<S2SV_blank>init<S2SV_blank>process,<S2SV_blank>pid<S2SV_blank>=<S2SV_blank>%ld\" , ( long ) init_pid ) ; return - 1 ; } personality = get_personality ( name , lxcpath ) ; if ( init_ctx -> personality < 0 ) { ERROR ( \"Failed<S2SV_blank>to<S2SV_blank>get<S2SV_blank>personality<S2SV_blank>of<S2SV_blank>the<S2SV_blank>container\" ) ; lxc_proc_put_context_info ( init_ctx ) ; return - 1 ; } init_ctx -> personality = personality ; if ( ! fetch_seccomp ( name , lxcpath , init_ctx , options ) ) WARN ( \"Failed<S2SV_blank>to<S2SV_blank>get<S2SV_blank>seccomp<S2SV_blank>policy\" ) ; cwd = getcwd ( NULL , 0 ) ; if ( options -> namespaces == - 1 ) { options -> namespaces = lxc_cmd_get_clone_flags ( name , lxcpath ) ; if ( options -> namespaces == - 1 ) { ERROR ( \"failed<S2SV_blank>to<S2SV_blank>automatically<S2SV_blank>determine<S2SV_blank>the<S2SV_blank>\" \"namespaces<S2SV_blank>which<S2SV_blank>the<S2SV_blank>container<S2SV_blank>unshared\" ) ; free ( cwd ) ; lxc_proc_put_context_info ( init_ctx ) ; return - 1 ; } } ret = socketpair ( PF_LOCAL , SOCK_STREAM | SOCK_CLOEXEC , 0 , ipc_sockets ) ; if ( ret < 0 ) { SYSERROR ( \"could<S2SV_blank>not<S2SV_blank>set<S2SV_blank>up<S2SV_blank>required<S2SV_blank>IPC<S2SV_blank>mechanism<S2SV_blank>for<S2SV_blank>attaching\" ) ; free ( cwd ) ; lxc_proc_put_context_info ( init_ctx ) ; return - 1 ; } pid = fork ( ) ; if ( pid < 0 ) { SYSERROR ( \"failed<S2SV_blank>to<S2SV_blank>create<S2SV_blank>first<S2SV_blank>subprocess\" ) ; free ( cwd ) ; lxc_proc_put_context_info ( init_ctx ) ; return - 1 ; } if ( pid ) { pid_t to_cleanup_pid = pid ; close ( ipc_sockets [ 1 ] ) ; free ( cwd ) ; if ( options -> attach_flags & LXC_ATTACH_MOVE_TO_CGROUP ) { if ( ! cgroup_attach ( name , lxcpath , pid ) ) goto cleanup_error ; } status = 0 ; ret = lxc_write_nointr ( ipc_sockets [ 0 ] , & status , sizeof ( status ) ) ; if ( ret <= 0 ) { ERROR ( \"error<S2SV_blank>using<S2SV_blank>IPC<S2SV_blank>to<S2SV_blank>notify<S2SV_blank>attached<S2SV_blank>process<S2SV_blank>for<S2SV_blank>initialization<S2SV_blank>(0)\" ) ; goto cleanup_error ; } ret = lxc_read_nointr_expect ( ipc_sockets [ 0 ] , & attached_pid , sizeof ( attached_pid ) , NULL ) ; if ( ret <= 0 ) { if ( ret != 0 ) ERROR ( \"error<S2SV_blank>using<S2SV_blank>IPC<S2SV_blank>to<S2SV_blank>receive<S2SV_blank>pid<S2SV_blank>of<S2SV_blank>attached<S2SV_blank>process\" ) ; goto cleanup_error ; } if ( options -> stdin_fd == 0 ) { signal ( SIGINT , SIG_IGN ) ; signal ( SIGQUIT , SIG_IGN ) ; } ret = wait_for_pid ( pid ) ; if ( ret < 0 ) goto cleanup_error ; to_cleanup_pid = attached_pid ; status = 0 ; ret = lxc_write_nointr ( ipc_sockets [ 0 ] , & status , sizeof ( status ) ) ; if ( ret <= 0 ) { ERROR ( \"error<S2SV_blank>using<S2SV_blank>IPC<S2SV_blank>to<S2SV_blank>notify<S2SV_blank>attached<S2SV_blank>process<S2SV_blank>for<S2SV_blank>initialization<S2SV_blank>(0)\" ) ; goto cleanup_error ; } expected = 1 ; ret = lxc_read_nointr_expect ( ipc_sockets [ 0 ] , & status , sizeof ( status ) , & expected ) ; if ( ret <= 0 ) { if ( ret != 0 ) ERROR ( \"error<S2SV_blank>using<S2SV_blank>IPC<S2SV_blank>to<S2SV_blank>receive<S2SV_blank>notification<S2SV_blank>from<S2SV_blank>attached<S2SV_blank>process<S2SV_blank>(1)\" ) ; goto cleanup_error ; } status = 2 ; ret = lxc_write_nointr ( ipc_sockets [ 0 ] , & status , sizeof ( status ) ) ; if ( ret <= 0 ) { ERROR ( \"error<S2SV_blank>using<S2SV_blank>IPC<S2SV_blank>to<S2SV_blank>notify<S2SV_blank>attached<S2SV_blank>process<S2SV_blank>for<S2SV_blank>initialization<S2SV_blank>(2)\" ) ; goto cleanup_error ; } shutdown ( ipc_sockets [ 0 ] , SHUT_RDWR ) ; close ( ipc_sockets [ 0 ] ) ; lxc_proc_put_context_info ( init_ctx ) ; * attached_process = attached_pid ; return 0 ; cleanup_error : shutdown ( ipc_sockets [ 0 ] , SHUT_RDWR ) ; close ( ipc_sockets [ 0 ] ) ; if ( to_cleanup_pid ) ( void ) wait_for_pid ( to_cleanup_pid ) ; lxc_proc_put_context_info ( init_ctx ) ; return - 1 ; } close ( ipc_sockets [ 0 ] ) ; expected = 0 ; status = - 1 ; ret = lxc_read_nointr_expect ( ipc_sockets [ 1 ] , & status , sizeof ( status ) , & expected ) ; if ( ret <= 0 ) { ERROR ( \"error<S2SV_blank>communicating<S2SV_blank>with<S2SV_blank>child<S2SV_blank>process\" ) ; shutdown ( ipc_sockets [ 1 ] , SHUT_RDWR ) ; rexit ( - 1 ) ; } <S2SV_StartBug> ret = lxc_attach_to_ns ( init_pid , options -> namespaces ) ; <S2SV_EndBug> if ( ret < 0 ) { ERROR ( \"failed<S2SV_blank>to<S2SV_blank>enter<S2SV_blank>the<S2SV_blank>namespace\" ) ; shutdown ( ipc_sockets [ 1 ] , SHUT_RDWR ) ; rexit ( - 1 ) ; } if ( options -> initial_cwd ) new_cwd = options -> initial_cwd ; else new_cwd = cwd ; ret = chdir ( new_cwd ) ; if ( ret < 0 ) WARN ( \"could<S2SV_blank>not<S2SV_blank>change<S2SV_blank>directory<S2SV_blank>to<S2SV_blank>\\'%s\\'\" , new_cwd ) ; free ( cwd ) ; { struct attach_clone_payload payload = { . ipc_socket = ipc_sockets [ 1 ] , . options = options , . init_ctx = init_ctx , . exec_function = exec_function , <S2SV_StartBug> . exec_payload = exec_payload <S2SV_EndBug> } ; pid = lxc_clone ( attach_child_main , & payload , CLONE_PARENT ) ; } if ( pid <= 0 ) { SYSERROR ( \"failed<S2SV_blank>to<S2SV_blank>create<S2SV_blank>subprocess\" ) ; shutdown ( ipc_sockets [ 1 ] , SHUT_RDWR ) ; rexit ( - 1 ) ; } ret = lxc_write_nointr ( ipc_sockets [ 1 ] , & pid , sizeof ( pid ) ) ; if ( ret != sizeof ( pid ) ) { ERROR ( \"error<S2SV_blank>using<S2SV_blank>IPC<S2SV_blank>to<S2SV_blank>notify<S2SV_blank>main<S2SV_blank>process<S2SV_blank>of<S2SV_blank>pid<S2SV_blank>of<S2SV_blank>the<S2SV_blank>attached<S2SV_blank>process\" ) ; shutdown ( ipc_sockets [ 1 ] , SHUT_RDWR ) ; rexit ( - 1 ) ; } rexit ( 0 ) ; }\n","target":"<S2SV_ModStart> 2 ] ; int procfd ; <S2SV_ModStart> ) ; } procfd = open ( \"/proc\" , O_DIRECTORY | O_RDONLY ) ; if ( procfd < 0 ) { SYSERROR ( \"Unable<S2SV_blank>to<S2SV_blank>open<S2SV_blank>/proc\" ) ; shutdown ( ipc_sockets [ 1 ] , SHUT_RDWR ) ; rexit ( - 1 ) ; } <S2SV_ModStart> exec_payload = exec_payload , . procfd = procfd\n","project_and_commit_id":"lxc@lxc/5c3fcae78b63ac9dd56e36075903921bd9461f9e","cve_id":"CVE-2015-1334","original_address":"https://github.com/lxc/lxc/commit/5c3fcae78b63ac9dd56e36075903921bd9461f9e","time":"2015-08-12T14:59Z"},
	{"Unnamed: 0":6717,"cwe_id":"CWE-125","source":"CWE-125 static void voutf ( struct GlobalConfig * config , const char * prefix , const char * fmt , va_list ap ) { size_t width = ( 79 - strlen ( prefix ) ) ; if ( ! config -> mute ) { size_t len ; char * ptr ; char * print_buffer ; print_buffer = curlx_mvaprintf ( fmt , ap ) ; if ( ! print_buffer ) return ; len = strlen ( print_buffer ) ; ptr = print_buffer ; while ( len > 0 ) { fputs ( prefix , config -> errors ) ; if ( len > width ) { size_t cut = width - 1 ; while ( ! ISSPACE ( ptr [ cut ] ) && cut ) { cut -- ; } if ( 0 == cut ) cut = width - 1 ; ( void ) fwrite ( ptr , cut + 1 , 1 , config -> errors ) ; fputs ( \"\\\\n\" , config -> errors ) ; ptr += cut + 1 ; <S2SV_StartBug> len -= cut ; <S2SV_EndBug> } else { fputs ( ptr , config -> errors ) ; len = 0 ; } } curl_free ( print_buffer ) ; } }\n","target":"<S2SV_ModStart> len -= cut + 1\n","project_and_commit_id":"curl@curl/d530e92f59ae9bb2d47066c3c460b25d2ffeb211","cve_id":"CVE-2018-16842","original_address":"https://github.com/curl/curl/commit/d530e92f59ae9bb2d47066c3c460b25d2ffeb211","time":"2018-10-31T19:29Z"},
	{"Unnamed: 0":5345,"cwe_id":"CWE-190","source":"CWE-190 TfLiteIntArray * TfLiteIntArrayCreate ( int size ) { <S2SV_StartBug> TfLiteIntArray * ret = <S2SV_EndBug> <S2SV_StartBug> ( TfLiteIntArray * ) malloc ( TfLiteIntArrayGetSizeInBytes ( size ) ) ; <S2SV_EndBug> ret -> size = size ; return ret ; }\n","target":"<S2SV_ModStart> size ) { int alloc_size = TfLiteIntArrayGetSizeInBytes ( size ) ; if ( alloc_size <= 0 ) return NULL ; <S2SV_ModStart> ) malloc ( alloc_size ) ; if ( ! ret ) return ret <S2SV_ModEnd> ; ret ->\n","project_and_commit_id":"tensorflow@tensorflow/7c8cc4ec69cd348e44ad6a2699057ca88faad3e5","cve_id":"CVE-2021-29605","original_address":"https://github.com/tensorflow/tensorflow/commit/7c8cc4ec69cd348e44ad6a2699057ca88faad3e5","time":"2021-05-14T20:15Z"},
	{"Unnamed: 0":6134,"cwe_id":"CWE-264","source":"CWE-264 static ssize_t map_write ( struct file * file , const char __user * buf , size_t count , loff_t * ppos , int cap_setid , struct uid_gid_map * map , struct uid_gid_map * parent_map ) { struct seq_file * seq = file -> private_data ; struct user_namespace * ns = seq -> private ; struct uid_gid_map new_map ; unsigned idx ; struct uid_gid_extent * extent = NULL ; unsigned long page = 0 ; char * kbuf , * pos , * next_line ; ssize_t ret = - EINVAL ; mutex_lock ( & id_map_mutex ) ; ret = - EPERM ; if ( map -> nr_extents != 0 ) goto out ; if ( cap_valid ( cap_setid ) && ! ns_capable ( ns , cap_setid ) ) goto out ; ret = - ENOMEM ; page = __get_free_page ( GFP_TEMPORARY ) ; kbuf = ( char * ) page ; if ( ! page ) goto out ; ret = - EINVAL ; if ( ( * ppos != 0 ) || ( count >= PAGE_SIZE ) ) goto out ; ret = - EFAULT ; if ( copy_from_user ( kbuf , buf , count ) ) goto out ; kbuf [ count ] = '\\\\0' ; ret = - EINVAL ; pos = kbuf ; new_map . nr_extents = 0 ; for ( ; pos ; pos = next_line ) { extent = & new_map . extent [ new_map . nr_extents ] ; next_line = strchr ( pos , '\\\\n' ) ; if ( next_line ) { * next_line = '\\\\0' ; next_line ++ ; if ( * next_line == '\\\\0' ) next_line = NULL ; } pos = skip_spaces ( pos ) ; extent -> first = simple_strtoul ( pos , & pos , 10 ) ; if ( ! isspace ( * pos ) ) goto out ; pos = skip_spaces ( pos ) ; extent -> lower_first = simple_strtoul ( pos , & pos , 10 ) ; if ( ! isspace ( * pos ) ) goto out ; pos = skip_spaces ( pos ) ; extent -> count = simple_strtoul ( pos , & pos , 10 ) ; if ( * pos && ! isspace ( * pos ) ) goto out ; pos = skip_spaces ( pos ) ; if ( * pos != '\\\\0' ) goto out ; if ( ( extent -> first == ( u32 ) - 1 ) || ( extent -> lower_first == ( u32 ) - 1 ) ) goto out ; if ( ( extent -> first + extent -> count ) <= extent -> first ) goto out ; if ( ( extent -> lower_first + extent -> count ) <= extent -> lower_first ) goto out ; if ( mappings_overlap ( & new_map , extent ) ) goto out ; new_map . nr_extents ++ ; if ( ( new_map . nr_extents == UID_GID_MAP_MAX_EXTENTS ) && ( next_line != NULL ) ) goto out ; } if ( new_map . nr_extents == 0 ) goto out ; ret = - EPERM ; <S2SV_StartBug> if ( ! new_idmap_permitted ( ns , cap_setid , & new_map ) ) <S2SV_EndBug> goto out ; for ( idx = 0 ; idx < new_map . nr_extents ; idx ++ ) { u32 lower_first ; extent = & new_map . extent [ idx ] ; lower_first = map_id_range_down ( parent_map , extent -> lower_first , extent -> count ) ; if ( lower_first == ( u32 ) - 1 ) goto out ; extent -> lower_first = lower_first ; } memcpy ( map -> extent , new_map . extent , new_map . nr_extents * sizeof ( new_map . extent [ 0 ] ) ) ; smp_wmb ( ) ; map -> nr_extents = new_map . nr_extents ; * ppos = count ; ret = count ; out : mutex_unlock ( & id_map_mutex ) ; if ( page ) free_page ( page ) ; return ret ; }\n","target":"<S2SV_ModStart> ! new_idmap_permitted ( file ,\n","project_and_commit_id":"torvalds@linux/6708075f104c3c9b04b23336bb0366ca30c3931b","cve_id":"CVE-2013-1959","original_address":"https://github.com/torvalds/linux/commit/6708075f104c3c9b04b23336bb0366ca30c3931b","time":"2013-05-03T11:57Z"},
	{"Unnamed: 0":4867,"cwe_id":"CWE-125","source":"CWE-125 void pgm_print ( netdissect_options * ndo , register const u_char * bp , register u_int length , register const u_char * bp2 ) { register const struct pgm_header * pgm ; register const struct ip * ip ; register char ch ; uint16_t sport , dport ; u_int nla_afnum ; char nla_buf [ INET6_ADDRSTRLEN ] ; register const struct ip6_hdr * ip6 ; uint8_t opt_type , opt_len ; uint32_t seq , opts_len , len , offset ; pgm = ( const struct pgm_header * ) bp ; ip = ( const struct ip * ) bp2 ; if ( IP_V ( ip ) == 6 ) ip6 = ( const struct ip6_hdr * ) bp2 ; else ip6 = NULL ; ch = '\\\\0' ; if ( ! ND_TTEST ( pgm -> pgm_dport ) ) { if ( ip6 ) { ND_PRINT ( ( ndo , \"%s<S2SV_blank>><S2SV_blank>%s:<S2SV_blank>[|pgm]\" , ip6addr_string ( ndo , & ip6 -> ip6_src ) , ip6addr_string ( ndo , & ip6 -> ip6_dst ) ) ) ; return ; } else { ND_PRINT ( ( ndo , \"%s<S2SV_blank>><S2SV_blank>%s:<S2SV_blank>[|pgm]\" , ipaddr_string ( ndo , & ip -> ip_src ) , ipaddr_string ( ndo , & ip -> ip_dst ) ) ) ; return ; } } sport = EXTRACT_16BITS ( & pgm -> pgm_sport ) ; dport = EXTRACT_16BITS ( & pgm -> pgm_dport ) ; if ( ip6 ) { if ( ip6 -> ip6_nxt == IPPROTO_PGM ) { ND_PRINT ( ( ndo , \"%s.%s<S2SV_blank>><S2SV_blank>%s.%s:<S2SV_blank>\" , ip6addr_string ( ndo , & ip6 -> ip6_src ) , tcpport_string ( ndo , sport ) , ip6addr_string ( ndo , & ip6 -> ip6_dst ) , tcpport_string ( ndo , dport ) ) ) ; } else { ND_PRINT ( ( ndo , \"%s<S2SV_blank>><S2SV_blank>%s:<S2SV_blank>\" , tcpport_string ( ndo , sport ) , tcpport_string ( ndo , dport ) ) ) ; } } else { if ( ip -> ip_p == IPPROTO_PGM ) { ND_PRINT ( ( ndo , \"%s.%s<S2SV_blank>><S2SV_blank>%s.%s:<S2SV_blank>\" , ipaddr_string ( ndo , & ip -> ip_src ) , tcpport_string ( ndo , sport ) , ipaddr_string ( ndo , & ip -> ip_dst ) , tcpport_string ( ndo , dport ) ) ) ; } else { ND_PRINT ( ( ndo , \"%s<S2SV_blank>><S2SV_blank>%s:<S2SV_blank>\" , tcpport_string ( ndo , sport ) , tcpport_string ( ndo , dport ) ) ) ; } } ND_TCHECK ( * pgm ) ; ND_PRINT ( ( ndo , \"PGM,<S2SV_blank>length<S2SV_blank>%u\" , EXTRACT_16BITS ( & pgm -> pgm_length ) ) ) ; if ( ! ndo -> ndo_vflag ) return ; ND_PRINT ( ( ndo , \"<S2SV_blank>0x%02x%02x%02x%02x%02x%02x<S2SV_blank>\" , pgm -> pgm_gsid [ 0 ] , pgm -> pgm_gsid [ 1 ] , pgm -> pgm_gsid [ 2 ] , pgm -> pgm_gsid [ 3 ] , pgm -> pgm_gsid [ 4 ] , pgm -> pgm_gsid [ 5 ] ) ) ; switch ( pgm -> pgm_type ) { case PGM_SPM : { const struct pgm_spm * spm ; spm = ( const struct pgm_spm * ) ( pgm + 1 ) ; ND_TCHECK ( * spm ) ; bp = ( const u_char * ) ( spm + 1 ) ; switch ( EXTRACT_16BITS ( & spm -> pgms_nla_afi ) ) { case AFNUM_INET : ND_TCHECK2 ( * bp , sizeof ( struct in_addr ) ) ; addrtostr ( bp , nla_buf , sizeof ( nla_buf ) ) ; bp += sizeof ( struct in_addr ) ; break ; case AFNUM_INET6 : ND_TCHECK2 ( * bp , sizeof ( struct in6_addr ) ) ; addrtostr6 ( bp , nla_buf , sizeof ( nla_buf ) ) ; bp += sizeof ( struct in6_addr ) ; break ; default : goto trunc ; break ; } ND_PRINT ( ( ndo , \"SPM<S2SV_blank>seq<S2SV_blank>%u<S2SV_blank>trail<S2SV_blank>%u<S2SV_blank>lead<S2SV_blank>%u<S2SV_blank>nla<S2SV_blank>%s\" , EXTRACT_32BITS ( & spm -> pgms_seq ) , EXTRACT_32BITS ( & spm -> pgms_trailseq ) , EXTRACT_32BITS ( & spm -> pgms_leadseq ) , nla_buf ) ) ; break ; } case PGM_POLL : { const struct pgm_poll * poll_msg ; poll_msg = ( const struct pgm_poll * ) ( pgm + 1 ) ; ND_TCHECK ( * poll_msg ) ; ND_PRINT ( ( ndo , \"POLL<S2SV_blank>seq<S2SV_blank>%u<S2SV_blank>round<S2SV_blank>%u\" , EXTRACT_32BITS ( & poll_msg -> pgmp_seq ) , EXTRACT_16BITS ( & poll_msg -> pgmp_round ) ) ) ; bp = ( const u_char * ) ( poll_msg + 1 ) ; break ; } case PGM_POLR : { const struct pgm_polr * polr ; uint32_t ivl , rnd , mask ; polr = ( const struct pgm_polr * ) ( pgm + 1 ) ; ND_TCHECK ( * polr ) ; bp = ( const u_char * ) ( polr + 1 ) ; switch ( EXTRACT_16BITS ( & polr -> pgmp_nla_afi ) ) { case AFNUM_INET : ND_TCHECK2 ( * bp , sizeof ( struct in_addr ) ) ; addrtostr ( bp , nla_buf , sizeof ( nla_buf ) ) ; bp += sizeof ( struct in_addr ) ; break ; case AFNUM_INET6 : ND_TCHECK2 ( * bp , sizeof ( struct in6_addr ) ) ; addrtostr6 ( bp , nla_buf , sizeof ( nla_buf ) ) ; bp += sizeof ( struct in6_addr ) ; break ; default : goto trunc ; break ; } ND_TCHECK2 ( * bp , sizeof ( uint32_t ) ) ; ivl = EXTRACT_32BITS ( bp ) ; bp += sizeof ( uint32_t ) ; ND_TCHECK2 ( * bp , sizeof ( uint32_t ) ) ; rnd = EXTRACT_32BITS ( bp ) ; bp += sizeof ( uint32_t ) ; ND_TCHECK2 ( * bp , sizeof ( uint32_t ) ) ; mask = EXTRACT_32BITS ( bp ) ; bp += sizeof ( uint32_t ) ; ND_PRINT ( ( ndo , \"POLR<S2SV_blank>seq<S2SV_blank>%u<S2SV_blank>round<S2SV_blank>%u<S2SV_blank>nla<S2SV_blank>%s<S2SV_blank>ivl<S2SV_blank>%u<S2SV_blank>rnd<S2SV_blank>0x%08x<S2SV_blank>\" \"mask<S2SV_blank>0x%08x\" , EXTRACT_32BITS ( & polr -> pgmp_seq ) , EXTRACT_16BITS ( & polr -> pgmp_round ) , nla_buf , ivl , rnd , mask ) ) ; break ; } case PGM_ODATA : { const struct pgm_data * odata ; odata = ( const struct pgm_data * ) ( pgm + 1 ) ; ND_TCHECK ( * odata ) ; ND_PRINT ( ( ndo , \"ODATA<S2SV_blank>trail<S2SV_blank>%u<S2SV_blank>seq<S2SV_blank>%u\" , EXTRACT_32BITS ( & odata -> pgmd_trailseq ) , EXTRACT_32BITS ( & odata -> pgmd_seq ) ) ) ; bp = ( const u_char * ) ( odata + 1 ) ; break ; } case PGM_RDATA : { const struct pgm_data * rdata ; rdata = ( const struct pgm_data * ) ( pgm + 1 ) ; ND_TCHECK ( * rdata ) ; ND_PRINT ( ( ndo , \"RDATA<S2SV_blank>trail<S2SV_blank>%u<S2SV_blank>seq<S2SV_blank>%u\" , EXTRACT_32BITS ( & rdata -> pgmd_trailseq ) , EXTRACT_32BITS ( & rdata -> pgmd_seq ) ) ) ; bp = ( const u_char * ) ( rdata + 1 ) ; break ; } case PGM_NAK : case PGM_NULLNAK : case PGM_NCF : { const struct pgm_nak * nak ; char source_buf [ INET6_ADDRSTRLEN ] , group_buf [ INET6_ADDRSTRLEN ] ; nak = ( const struct pgm_nak * ) ( pgm + 1 ) ; ND_TCHECK ( * nak ) ; bp = ( const u_char * ) ( nak + 1 ) ; switch ( EXTRACT_16BITS ( & nak -> pgmn_source_afi ) ) { case AFNUM_INET : ND_TCHECK2 ( * bp , sizeof ( struct in_addr ) ) ; addrtostr ( bp , source_buf , sizeof ( source_buf ) ) ; bp += sizeof ( struct in_addr ) ; break ; case AFNUM_INET6 : ND_TCHECK2 ( * bp , sizeof ( struct in6_addr ) ) ; addrtostr6 ( bp , source_buf , sizeof ( source_buf ) ) ; bp += sizeof ( struct in6_addr ) ; break ; default : goto trunc ; break ; } bp += ( 2 * sizeof ( uint16_t ) ) ; switch ( EXTRACT_16BITS ( bp ) ) { case AFNUM_INET : ND_TCHECK2 ( * bp , sizeof ( struct in_addr ) ) ; addrtostr ( bp , group_buf , sizeof ( group_buf ) ) ; bp += sizeof ( struct in_addr ) ; break ; case AFNUM_INET6 : ND_TCHECK2 ( * bp , sizeof ( struct in6_addr ) ) ; addrtostr6 ( bp , group_buf , sizeof ( group_buf ) ) ; bp += sizeof ( struct in6_addr ) ; break ; default : goto trunc ; break ; } switch ( pgm -> pgm_type ) { case PGM_NAK : ND_PRINT ( ( ndo , \"NAK<S2SV_blank>\" ) ) ; break ; case PGM_NULLNAK : ND_PRINT ( ( ndo , \"NNAK<S2SV_blank>\" ) ) ; break ; case PGM_NCF : ND_PRINT ( ( ndo , \"NCF<S2SV_blank>\" ) ) ; break ; default : break ; } ND_PRINT ( ( ndo , \"(%s<S2SV_blank>-><S2SV_blank>%s),<S2SV_blank>seq<S2SV_blank>%u\" , source_buf , group_buf , EXTRACT_32BITS ( & nak -> pgmn_seq ) ) ) ; break ; } case PGM_ACK : { const struct pgm_ack * ack ; ack = ( const struct pgm_ack * ) ( pgm + 1 ) ; ND_TCHECK ( * ack ) ; ND_PRINT ( ( ndo , \"ACK<S2SV_blank>seq<S2SV_blank>%u\" , EXTRACT_32BITS ( & ack -> pgma_rx_max_seq ) ) ) ; bp = ( const u_char * ) ( ack + 1 ) ; break ; } case PGM_SPMR : ND_PRINT ( ( ndo , \"SPMR\" ) ) ; break ; default : ND_PRINT ( ( ndo , \"UNKNOWN<S2SV_blank>type<S2SV_blank>0x%02x\" , pgm -> pgm_type ) ) ; break ; } if ( pgm -> pgm_options & PGM_OPT_BIT_PRESENT ) { if ( ! ND_TTEST2 ( * bp , PGM_MIN_OPT_LEN ) ) { ND_PRINT ( ( ndo , \"[|OPT]\" ) ) ; return ; } opt_type = * bp ++ ; if ( ( opt_type & PGM_OPT_MASK ) != PGM_OPT_LENGTH ) { ND_PRINT ( ( ndo , \"[First<S2SV_blank>option<S2SV_blank>bad,<S2SV_blank>should<S2SV_blank>be<S2SV_blank>PGM_OPT_LENGTH,<S2SV_blank>is<S2SV_blank>%u]\" , opt_type & PGM_OPT_MASK ) ) ; return ; } opt_len = * bp ++ ; if ( opt_len != 4 ) { ND_PRINT ( ( ndo , \"[Bad<S2SV_blank>OPT_LENGTH<S2SV_blank>option,<S2SV_blank>length<S2SV_blank>%u<S2SV_blank>!=<S2SV_blank>4]\" , opt_len ) ) ; return ; } opts_len = EXTRACT_16BITS ( bp ) ; if ( opts_len < 4 ) { ND_PRINT ( ( ndo , \"[Bad<S2SV_blank>total<S2SV_blank>option<S2SV_blank>length<S2SV_blank>%u<S2SV_blank><<S2SV_blank>4]\" , opts_len ) ) ; return ; } bp += sizeof ( uint16_t ) ; ND_PRINT ( ( ndo , \"<S2SV_blank>OPTS<S2SV_blank>LEN<S2SV_blank>%d\" , opts_len ) ) ; opts_len -= 4 ; while ( opts_len ) { if ( opts_len < PGM_MIN_OPT_LEN ) { ND_PRINT ( ( ndo , \"[Total<S2SV_blank>option<S2SV_blank>length<S2SV_blank>leaves<S2SV_blank>no<S2SV_blank>room<S2SV_blank>for<S2SV_blank>final<S2SV_blank>option]\" ) ) ; return ; } <S2SV_StartBug> opt_type = * bp ++ ; <S2SV_EndBug> opt_len = * bp ++ ; if ( opt_len < PGM_MIN_OPT_LEN ) { ND_PRINT ( ( ndo , \"[Bad<S2SV_blank>option,<S2SV_blank>length<S2SV_blank>%u<S2SV_blank><<S2SV_blank>%u]\" , opt_len , PGM_MIN_OPT_LEN ) ) ; break ; } if ( opts_len < opt_len ) { ND_PRINT ( ( ndo , \"[Total<S2SV_blank>option<S2SV_blank>length<S2SV_blank>leaves<S2SV_blank>no<S2SV_blank>room<S2SV_blank>for<S2SV_blank>final<S2SV_blank>option]\" ) ) ; return ; } if ( ! ND_TTEST2 ( * bp , opt_len - 2 ) ) { ND_PRINT ( ( ndo , \"<S2SV_blank>[|OPT]\" ) ) ; return ; } switch ( opt_type & PGM_OPT_MASK ) { case PGM_OPT_LENGTH : if ( opt_len != 4 ) { ND_PRINT ( ( ndo , \"[Bad<S2SV_blank>OPT_LENGTH<S2SV_blank>option,<S2SV_blank>length<S2SV_blank>%u<S2SV_blank>!=<S2SV_blank>4]\" , opt_len ) ) ; return ; } ND_PRINT ( ( ndo , \"<S2SV_blank>OPTS<S2SV_blank>LEN<S2SV_blank>(extra?)<S2SV_blank>%d\" , EXTRACT_16BITS ( bp ) ) ) ; bp += sizeof ( uint16_t ) ; opts_len -= 4 ; break ; case PGM_OPT_FRAGMENT : if ( opt_len != 16 ) { ND_PRINT ( ( ndo , \"[Bad<S2SV_blank>OPT_FRAGMENT<S2SV_blank>option,<S2SV_blank>length<S2SV_blank>%u<S2SV_blank>!=<S2SV_blank>16]\" , opt_len ) ) ; return ; } bp += 2 ; seq = EXTRACT_32BITS ( bp ) ; bp += sizeof ( uint32_t ) ; offset = EXTRACT_32BITS ( bp ) ; bp += sizeof ( uint32_t ) ; len = EXTRACT_32BITS ( bp ) ; bp += sizeof ( uint32_t ) ; ND_PRINT ( ( ndo , \"<S2SV_blank>FRAG<S2SV_blank>seq<S2SV_blank>%u<S2SV_blank>off<S2SV_blank>%u<S2SV_blank>len<S2SV_blank>%u\" , seq , offset , len ) ) ; opts_len -= 16 ; break ; case PGM_OPT_NAK_LIST : bp += 2 ; opt_len -= sizeof ( uint32_t ) ; ND_PRINT ( ( ndo , \"<S2SV_blank>NAK<S2SV_blank>LIST\" ) ) ; while ( opt_len ) { if ( opt_len < sizeof ( uint32_t ) ) { ND_PRINT ( ( ndo , \"[Option<S2SV_blank>length<S2SV_blank>not<S2SV_blank>a<S2SV_blank>multiple<S2SV_blank>of<S2SV_blank>4]\" ) ) ; return ; } ND_TCHECK2 ( * bp , sizeof ( uint32_t ) ) ; ND_PRINT ( ( ndo , \"<S2SV_blank>%u\" , EXTRACT_32BITS ( bp ) ) ) ; bp += sizeof ( uint32_t ) ; opt_len -= sizeof ( uint32_t ) ; opts_len -= sizeof ( uint32_t ) ; } break ; case PGM_OPT_JOIN : if ( opt_len != 8 ) { ND_PRINT ( ( ndo , \"[Bad<S2SV_blank>OPT_JOIN<S2SV_blank>option,<S2SV_blank>length<S2SV_blank>%u<S2SV_blank>!=<S2SV_blank>8]\" , opt_len ) ) ; return ; } bp += 2 ; seq = EXTRACT_32BITS ( bp ) ; bp += sizeof ( uint32_t ) ; ND_PRINT ( ( ndo , \"<S2SV_blank>JOIN<S2SV_blank>%u\" , seq ) ) ; opts_len -= 8 ; break ; case PGM_OPT_NAK_BO_IVL : if ( opt_len != 12 ) { ND_PRINT ( ( ndo , \"[Bad<S2SV_blank>OPT_NAK_BO_IVL<S2SV_blank>option,<S2SV_blank>length<S2SV_blank>%u<S2SV_blank>!=<S2SV_blank>12]\" , opt_len ) ) ; return ; } bp += 2 ; offset = EXTRACT_32BITS ( bp ) ; bp += sizeof ( uint32_t ) ; seq = EXTRACT_32BITS ( bp ) ; bp += sizeof ( uint32_t ) ; ND_PRINT ( ( ndo , \"<S2SV_blank>BACKOFF<S2SV_blank>ivl<S2SV_blank>%u<S2SV_blank>ivlseq<S2SV_blank>%u\" , offset , seq ) ) ; opts_len -= 12 ; break ; case PGM_OPT_NAK_BO_RNG : if ( opt_len != 12 ) { ND_PRINT ( ( ndo , \"[Bad<S2SV_blank>OPT_NAK_BO_RNG<S2SV_blank>option,<S2SV_blank>length<S2SV_blank>%u<S2SV_blank>!=<S2SV_blank>12]\" , opt_len ) ) ; return ; } bp += 2 ; offset = EXTRACT_32BITS ( bp ) ; bp += sizeof ( uint32_t ) ; seq = EXTRACT_32BITS ( bp ) ; bp += sizeof ( uint32_t ) ; ND_PRINT ( ( ndo , \"<S2SV_blank>BACKOFF<S2SV_blank>max<S2SV_blank>%u<S2SV_blank>min<S2SV_blank>%u\" , offset , seq ) ) ; opts_len -= 12 ; break ; case PGM_OPT_REDIRECT : bp += 2 ; nla_afnum = EXTRACT_16BITS ( bp ) ; bp += ( 2 * sizeof ( uint16_t ) ) ; switch ( nla_afnum ) { case AFNUM_INET : if ( opt_len != 4 + sizeof ( struct in_addr ) ) { ND_PRINT ( ( ndo , \"[Bad<S2SV_blank>OPT_REDIRECT<S2SV_blank>option,<S2SV_blank>length<S2SV_blank>%u<S2SV_blank>!=<S2SV_blank>4<S2SV_blank>+<S2SV_blank>address<S2SV_blank>size]\" , opt_len ) ) ; return ; } ND_TCHECK2 ( * bp , sizeof ( struct in_addr ) ) ; addrtostr ( bp , nla_buf , sizeof ( nla_buf ) ) ; bp += sizeof ( struct in_addr ) ; opts_len -= 4 + sizeof ( struct in_addr ) ; break ; case AFNUM_INET6 : if ( opt_len != 4 + sizeof ( struct in6_addr ) ) { ND_PRINT ( ( ndo , \"[Bad<S2SV_blank>OPT_REDIRECT<S2SV_blank>option,<S2SV_blank>length<S2SV_blank>%u<S2SV_blank>!=<S2SV_blank>4<S2SV_blank>+<S2SV_blank>address<S2SV_blank>size]\" , opt_len ) ) ; return ; } ND_TCHECK2 ( * bp , sizeof ( struct in6_addr ) ) ; addrtostr6 ( bp , nla_buf , sizeof ( nla_buf ) ) ; bp += sizeof ( struct in6_addr ) ; opts_len -= 4 + sizeof ( struct in6_addr ) ; break ; default : goto trunc ; break ; } ND_PRINT ( ( ndo , \"<S2SV_blank>REDIRECT<S2SV_blank>%s\" , nla_buf ) ) ; break ; case PGM_OPT_PARITY_PRM : if ( opt_len != 8 ) { ND_PRINT ( ( ndo , \"[Bad<S2SV_blank>OPT_PARITY_PRM<S2SV_blank>option,<S2SV_blank>length<S2SV_blank>%u<S2SV_blank>!=<S2SV_blank>8]\" , opt_len ) ) ; return ; } bp += 2 ; len = EXTRACT_32BITS ( bp ) ; bp += sizeof ( uint32_t ) ; ND_PRINT ( ( ndo , \"<S2SV_blank>PARITY<S2SV_blank>MAXTGS<S2SV_blank>%u\" , len ) ) ; opts_len -= 8 ; break ; case PGM_OPT_PARITY_GRP : if ( opt_len != 8 ) { ND_PRINT ( ( ndo , \"[Bad<S2SV_blank>OPT_PARITY_GRP<S2SV_blank>option,<S2SV_blank>length<S2SV_blank>%u<S2SV_blank>!=<S2SV_blank>8]\" , opt_len ) ) ; return ; } bp += 2 ; seq = EXTRACT_32BITS ( bp ) ; bp += sizeof ( uint32_t ) ; ND_PRINT ( ( ndo , \"<S2SV_blank>PARITY<S2SV_blank>GROUP<S2SV_blank>%u\" , seq ) ) ; opts_len -= 8 ; break ; case PGM_OPT_CURR_TGSIZE : if ( opt_len != 8 ) { ND_PRINT ( ( ndo , \"[Bad<S2SV_blank>OPT_CURR_TGSIZE<S2SV_blank>option,<S2SV_blank>length<S2SV_blank>%u<S2SV_blank>!=<S2SV_blank>8]\" , opt_len ) ) ; return ; } bp += 2 ; len = EXTRACT_32BITS ( bp ) ; bp += sizeof ( uint32_t ) ; ND_PRINT ( ( ndo , \"<S2SV_blank>PARITY<S2SV_blank>ATGS<S2SV_blank>%u\" , len ) ) ; opts_len -= 8 ; break ; case PGM_OPT_NBR_UNREACH : if ( opt_len != 4 ) { ND_PRINT ( ( ndo , \"[Bad<S2SV_blank>OPT_NBR_UNREACH<S2SV_blank>option,<S2SV_blank>length<S2SV_blank>%u<S2SV_blank>!=<S2SV_blank>4]\" , opt_len ) ) ; return ; } bp += 2 ; ND_PRINT ( ( ndo , \"<S2SV_blank>NBR_UNREACH\" ) ) ; opts_len -= 4 ; break ; case PGM_OPT_PATH_NLA : ND_PRINT ( ( ndo , \"<S2SV_blank>PATH_NLA<S2SV_blank>[%d]\" , opt_len ) ) ; bp += opt_len ; opts_len -= opt_len ; break ; case PGM_OPT_SYN : if ( opt_len != 4 ) { ND_PRINT ( ( ndo , \"[Bad<S2SV_blank>OPT_SYN<S2SV_blank>option,<S2SV_blank>length<S2SV_blank>%u<S2SV_blank>!=<S2SV_blank>4]\" , opt_len ) ) ; return ; } bp += 2 ; ND_PRINT ( ( ndo , \"<S2SV_blank>SYN\" ) ) ; opts_len -= 4 ; break ; case PGM_OPT_FIN : if ( opt_len != 4 ) { ND_PRINT ( ( ndo , \"[Bad<S2SV_blank>OPT_FIN<S2SV_blank>option,<S2SV_blank>length<S2SV_blank>%u<S2SV_blank>!=<S2SV_blank>4]\" , opt_len ) ) ; return ; } bp += 2 ; ND_PRINT ( ( ndo , \"<S2SV_blank>FIN\" ) ) ; opts_len -= 4 ; break ; case PGM_OPT_RST : if ( opt_len != 4 ) { ND_PRINT ( ( ndo , \"[Bad<S2SV_blank>OPT_RST<S2SV_blank>option,<S2SV_blank>length<S2SV_blank>%u<S2SV_blank>!=<S2SV_blank>4]\" , opt_len ) ) ; return ; } bp += 2 ; ND_PRINT ( ( ndo , \"<S2SV_blank>RST\" ) ) ; opts_len -= 4 ; break ; case PGM_OPT_CR : ND_PRINT ( ( ndo , \"<S2SV_blank>CR\" ) ) ; bp += opt_len ; opts_len -= opt_len ; break ; case PGM_OPT_CRQST : if ( opt_len != 4 ) { ND_PRINT ( ( ndo , \"[Bad<S2SV_blank>OPT_CRQST<S2SV_blank>option,<S2SV_blank>length<S2SV_blank>%u<S2SV_blank>!=<S2SV_blank>4]\" , opt_len ) ) ; return ; } bp += 2 ; ND_PRINT ( ( ndo , \"<S2SV_blank>CRQST\" ) ) ; opts_len -= 4 ; break ; case PGM_OPT_PGMCC_DATA : bp += 2 ; offset = EXTRACT_32BITS ( bp ) ; bp += sizeof ( uint32_t ) ; nla_afnum = EXTRACT_16BITS ( bp ) ; bp += ( 2 * sizeof ( uint16_t ) ) ; switch ( nla_afnum ) { case AFNUM_INET : if ( opt_len != 12 + sizeof ( struct in_addr ) ) { ND_PRINT ( ( ndo , \"[Bad<S2SV_blank>OPT_PGMCC_DATA<S2SV_blank>option,<S2SV_blank>length<S2SV_blank>%u<S2SV_blank>!=<S2SV_blank>12<S2SV_blank>+<S2SV_blank>address<S2SV_blank>size]\" , opt_len ) ) ; return ; } ND_TCHECK2 ( * bp , sizeof ( struct in_addr ) ) ; addrtostr ( bp , nla_buf , sizeof ( nla_buf ) ) ; bp += sizeof ( struct in_addr ) ; opts_len -= 12 + sizeof ( struct in_addr ) ; break ; case AFNUM_INET6 : if ( opt_len != 12 + sizeof ( struct in6_addr ) ) { ND_PRINT ( ( ndo , \"[Bad<S2SV_blank>OPT_PGMCC_DATA<S2SV_blank>option,<S2SV_blank>length<S2SV_blank>%u<S2SV_blank>!=<S2SV_blank>12<S2SV_blank>+<S2SV_blank>address<S2SV_blank>size]\" , opt_len ) ) ; return ; } ND_TCHECK2 ( * bp , sizeof ( struct in6_addr ) ) ; addrtostr6 ( bp , nla_buf , sizeof ( nla_buf ) ) ; bp += sizeof ( struct in6_addr ) ; opts_len -= 12 + sizeof ( struct in6_addr ) ; break ; default : goto trunc ; break ; } ND_PRINT ( ( ndo , \"<S2SV_blank>PGMCC<S2SV_blank>DATA<S2SV_blank>%u<S2SV_blank>%s\" , offset , nla_buf ) ) ; break ; case PGM_OPT_PGMCC_FEEDBACK : bp += 2 ; offset = EXTRACT_32BITS ( bp ) ; bp += sizeof ( uint32_t ) ; nla_afnum = EXTRACT_16BITS ( bp ) ; bp += ( 2 * sizeof ( uint16_t ) ) ; switch ( nla_afnum ) { case AFNUM_INET : if ( opt_len != 12 + sizeof ( struct in_addr ) ) { ND_PRINT ( ( ndo , \"[Bad<S2SV_blank>OPT_PGMCC_DATA<S2SV_blank>option,<S2SV_blank>length<S2SV_blank>%u<S2SV_blank>!=<S2SV_blank>12<S2SV_blank>+<S2SV_blank>address<S2SV_blank>size]\" , opt_len ) ) ; return ; } ND_TCHECK2 ( * bp , sizeof ( struct in_addr ) ) ; addrtostr ( bp , nla_buf , sizeof ( nla_buf ) ) ; bp += sizeof ( struct in_addr ) ; opts_len -= 12 + sizeof ( struct in_addr ) ; break ; case AFNUM_INET6 : if ( opt_len != 12 + sizeof ( struct in6_addr ) ) { ND_PRINT ( ( ndo , \"[Bad<S2SV_blank>OPT_PGMCC_DATA<S2SV_blank>option,<S2SV_blank>length<S2SV_blank>%u<S2SV_blank>!=<S2SV_blank>12<S2SV_blank>+<S2SV_blank>address<S2SV_blank>size]\" , opt_len ) ) ; return ; } ND_TCHECK2 ( * bp , sizeof ( struct in6_addr ) ) ; addrtostr6 ( bp , nla_buf , sizeof ( nla_buf ) ) ; bp += sizeof ( struct in6_addr ) ; opts_len -= 12 + sizeof ( struct in6_addr ) ; break ; default : goto trunc ; break ; } ND_PRINT ( ( ndo , \"<S2SV_blank>PGMCC<S2SV_blank>FEEDBACK<S2SV_blank>%u<S2SV_blank>%s\" , offset , nla_buf ) ) ; break ; default : ND_PRINT ( ( ndo , \"<S2SV_blank>OPT_%02X<S2SV_blank>[%d]<S2SV_blank>\" , opt_type , opt_len ) ) ; bp += opt_len ; opts_len -= opt_len ; break ; } if ( opt_type & PGM_OPT_END ) break ; } } ND_PRINT ( ( ndo , \"<S2SV_blank>[%u]\" , length ) ) ; if ( ndo -> ndo_packettype == PT_PGM_ZMTP1 && ( pgm -> pgm_type == PGM_ODATA || pgm -> pgm_type == PGM_RDATA ) ) zmtp1_print_datagram ( ndo , bp , EXTRACT_16BITS ( & pgm -> pgm_length ) ) ; return ; trunc : ND_PRINT ( ( ndo , \"[|pgm]\" ) ) ; if ( ch != '\\\\0' ) ND_PRINT ( ( ndo , \">\" ) ) ; }\n","target":"<S2SV_ModStart> return ; } if ( ! ND_TTEST2 ( * bp , 2 ) ) { ND_PRINT ( ( ndo , \"<S2SV_blank>[|OPT]\" ) ) ; return ; }\n","project_and_commit_id":"the-tcpdump-group@tcpdump/26a6799b9ca80508c05cac7a9a3bef922991520b","cve_id":"CVE-2017-13018","original_address":"https://github.com/the-tcpdump-group/tcpdump/commit/26a6799b9ca80508c05cac7a9a3bef922991520b","time":"2017-09-14T06:29Z"},
	{"Unnamed: 0":5515,"cwe_id":"CWE-119","source":"CWE-119 static int read_inter_segment_id ( VP9_COMMON * const cm , MACROBLOCKD * const xd , <S2SV_StartBug> int mi_row , int mi_col , vp9_reader * r ) { <S2SV_EndBug> struct segmentation * const seg = & cm -> seg ; MB_MODE_INFO * const mbmi = & xd -> mi [ 0 ] -> mbmi ; <S2SV_StartBug> const BLOCK_SIZE bsize = mbmi -> sb_type ; <S2SV_EndBug> int predicted_segment_id , segment_id ; if ( ! seg -> enabled ) return 0 ; <S2SV_StartBug> predicted_segment_id = vp9_get_segment_id ( cm , cm -> last_frame_seg_map , <S2SV_EndBug> bsize , mi_row , mi_col ) ; <S2SV_StartBug> if ( ! seg -> update_map ) <S2SV_EndBug> return predicted_segment_id ; <S2SV_StartBug> if ( seg -> temporal_update ) { <S2SV_EndBug> <S2SV_StartBug> const vp9_prob pred_prob = vp9_get_pred_prob_seg_id ( seg , xd ) ; <S2SV_EndBug> <S2SV_StartBug> mbmi -> seg_id_predicted = vp9_read ( r , pred_prob ) ; <S2SV_EndBug> segment_id = mbmi -> seg_id_predicted ? predicted_segment_id : read_segment_id ( r , seg ) ; } else { segment_id = read_segment_id ( r , seg ) ; } <S2SV_StartBug> set_segment_id ( cm , bsize , mi_row , mi_col , segment_id ) ; <S2SV_EndBug> return segment_id ; }\n","target":"<S2SV_ModStart> int mi_col , vpx_reader <S2SV_ModEnd> * r ) <S2SV_ModStart> -> mbmi ; int predicted_segment_id , segment_id ; const int mi_offset = mi_row * cm -> mi_cols + mi_col ; const int bw = xd -> plane [ 0 ] . n4_w >> 1 ; const int bh = xd -> plane [ 0 ] . n4_h >> 1 ; const int x_mis = MIN ( cm -> mi_cols - mi_col , bw ) ; const int y_mis = MIN ( cm -> mi_rows - mi_row , bh ) <S2SV_ModEnd> ; if ( <S2SV_ModStart> ; predicted_segment_id = <S2SV_ModEnd> cm -> last_frame_seg_map <S2SV_ModStart> cm -> last_frame_seg_map ? dec_get_segment_id ( cm , cm -> last_frame_seg_map , mi_offset , x_mis , y_mis ) : 0 <S2SV_ModEnd> ; if ( <S2SV_ModStart> -> update_map ) { copy_segment_id ( cm , cm -> last_frame_seg_map , cm -> current_frame_seg_map , mi_offset , x_mis , y_mis ) ; <S2SV_ModStart> return predicted_segment_id ; } <S2SV_ModStart> ) { const vpx_prob <S2SV_ModEnd> pred_prob = vp9_get_pred_prob_seg_id <S2SV_ModStart> -> seg_id_predicted = vpx_read <S2SV_ModEnd> ( r , <S2SV_ModStart> ( cm , mi_offset , x_mis , y_mis <S2SV_ModEnd> , segment_id )\n","project_and_commit_id":"external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426","cve_id":"CVE-2016-1621","original_address":"https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426","time":"2016-03-12T21:59Z"},
	{"Unnamed: 0":3625,"cwe_id":"CWE-190","source":"CWE-190 static void common_hrtimer_rearm ( struct k_itimer * timr ) { struct hrtimer * timer = & timr -> it . real . timer ; if ( ! timr -> it_interval ) return ; <S2SV_StartBug> timr -> it_overrun += ( unsigned int ) hrtimer_forward ( timer , <S2SV_EndBug> timer -> base -> get_time ( ) , timr -> it_interval ) ; hrtimer_restart ( timer ) ; }\n","target":"<S2SV_ModStart> -> it_overrun += <S2SV_ModEnd> hrtimer_forward ( timer\n","project_and_commit_id":"torvalds@linux/78c9c4dfbf8c04883941445a195276bb4bb92c76","cve_id":"CVE-2018-12896","original_address":"https://github.com/torvalds/linux/commit/78c9c4dfbf8c04883941445a195276bb4bb92c76","time":"2018-07-02T17:29Z"},
	{"Unnamed: 0":5513,"cwe_id":"CWE-000","source":"CWE-000 static int decode_slice_header ( H264Context * h , H264Context * h0 ) { unsigned int first_mb_in_slice ; unsigned int pps_id ; int ret ; unsigned int slice_type , tmp , i , j ; int last_pic_structure , last_pic_droppable ; int must_reinit ; int needs_reinit = 0 ; int field_pic_flag , bottom_field_flag ; h -> me . qpel_put = h -> h264qpel . put_h264_qpel_pixels_tab ; h -> me . qpel_avg = h -> h264qpel . avg_h264_qpel_pixels_tab ; first_mb_in_slice = get_ue_golomb_long ( & h -> gb ) ; if ( first_mb_in_slice == 0 ) { if ( h0 -> current_slice && FIELD_PICTURE ( h ) ) { field_end ( h , 1 ) ; } h0 -> current_slice = 0 ; if ( ! h0 -> first_field ) { if ( h -> cur_pic_ptr && ! h -> droppable ) { ff_thread_report_progress ( & h -> cur_pic_ptr -> tf , INT_MAX , h -> picture_structure == PICT_BOTTOM_FIELD ) ; } h -> cur_pic_ptr = NULL ; } } slice_type = get_ue_golomb_31 ( & h -> gb ) ; if ( slice_type > 9 ) { av_log ( h -> avctx , AV_LOG_ERROR , \"slice<S2SV_blank>type<S2SV_blank>too<S2SV_blank>large<S2SV_blank>(%d)<S2SV_blank>at<S2SV_blank>%d<S2SV_blank>%d\\\\n\" , slice_type , h -> mb_x , h -> mb_y ) ; return AVERROR_INVALIDDATA ; } if ( slice_type > 4 ) { slice_type -= 5 ; h -> slice_type_fixed = 1 ; } else h -> slice_type_fixed = 0 ; slice_type = golomb_to_pict_type [ slice_type ] ; h -> slice_type = slice_type ; h -> slice_type_nos = slice_type & 3 ; h -> pict_type = h -> slice_type ; pps_id = get_ue_golomb ( & h -> gb ) ; if ( pps_id >= MAX_PPS_COUNT ) { av_log ( h -> avctx , AV_LOG_ERROR , \"pps_id<S2SV_blank>%d<S2SV_blank>out<S2SV_blank>of<S2SV_blank>range\\\\n\" , pps_id ) ; return AVERROR_INVALIDDATA ; } if ( ! h0 -> pps_buffers [ pps_id ] ) { av_log ( h -> avctx , AV_LOG_ERROR , \"non-existing<S2SV_blank>PPS<S2SV_blank>%u<S2SV_blank>referenced\\\\n\" , pps_id ) ; return AVERROR_INVALIDDATA ; } h -> pps = * h0 -> pps_buffers [ pps_id ] ; if ( ! h0 -> sps_buffers [ h -> pps . sps_id ] ) { av_log ( h -> avctx , AV_LOG_ERROR , \"non-existing<S2SV_blank>SPS<S2SV_blank>%u<S2SV_blank>referenced\\\\n\" , h -> pps . sps_id ) ; return AVERROR_INVALIDDATA ; } if ( h -> pps . sps_id != h -> current_sps_id || h0 -> sps_buffers [ h -> pps . sps_id ] -> new ) { h0 -> sps_buffers [ h -> pps . sps_id ] -> new = 0 ; h -> current_sps_id = h -> pps . sps_id ; h -> sps = * h0 -> sps_buffers [ h -> pps . sps_id ] ; if ( h -> mb_width != h -> sps . mb_width || h -> mb_height != h -> sps . mb_height * ( 2 - h -> sps . frame_mbs_only_flag ) || h -> avctx -> bits_per_raw_sample != h -> sps . bit_depth_luma || h -> cur_chroma_format_idc != h -> sps . chroma_format_idc ) needs_reinit = 1 ; if ( h -> bit_depth_luma != h -> sps . bit_depth_luma || h -> chroma_format_idc != h -> sps . chroma_format_idc ) { h -> bit_depth_luma = h -> sps . bit_depth_luma ; h -> chroma_format_idc = h -> sps . chroma_format_idc ; needs_reinit = 1 ; } if ( ( ret = h264_set_parameter_from_sps ( h ) ) < 0 ) return ret ; } h -> avctx -> profile = ff_h264_get_profile ( & h -> sps ) ; h -> avctx -> level = h -> sps . level_idc ; h -> avctx -> refs = h -> sps . ref_frame_count ; must_reinit = ( h -> context_initialized && ( 16 * h -> sps . mb_width != h -> avctx -> coded_width || 16 * h -> sps . mb_height * ( 2 - h -> sps . frame_mbs_only_flag ) != h -> avctx -> coded_height || h -> avctx -> bits_per_raw_sample != h -> sps . bit_depth_luma || h -> cur_chroma_format_idc != h -> sps . chroma_format_idc || av_cmp_q ( h -> sps . sar , h -> avctx -> sample_aspect_ratio ) || h -> mb_width != h -> sps . mb_width || h -> mb_height != h -> sps . mb_height * ( 2 - h -> sps . frame_mbs_only_flag ) ) ) ; if ( h0 -> avctx -> pix_fmt != get_pixel_format ( h0 , 0 ) ) must_reinit = 1 ; h -> mb_width = h -> sps . mb_width ; h -> mb_height = h -> sps . mb_height * ( 2 - h -> sps . frame_mbs_only_flag ) ; h -> mb_num = h -> mb_width * h -> mb_height ; h -> mb_stride = h -> mb_width + 1 ; h -> b_stride = h -> mb_width * 4 ; h -> chroma_y_shift = h -> sps . chroma_format_idc <= 1 ; h -> width = 16 * h -> mb_width ; h -> height = 16 * h -> mb_height ; ret = init_dimensions ( h ) ; if ( ret < 0 ) return ret ; if ( h -> sps . video_signal_type_present_flag ) { h -> avctx -> color_range = h -> sps . full_range > 0 ? AVCOL_RANGE_JPEG : AVCOL_RANGE_MPEG ; if ( h -> sps . colour_description_present_flag ) { if ( h -> avctx -> colorspace != h -> sps . colorspace ) needs_reinit = 1 ; h -> avctx -> color_primaries = h -> sps . color_primaries ; h -> avctx -> color_trc = h -> sps . color_trc ; h -> avctx -> colorspace = h -> sps . colorspace ; } } if ( h -> context_initialized && ( h -> width != h -> avctx -> coded_width || h -> height != h -> avctx -> coded_height || must_reinit || needs_reinit ) ) { if ( h != h0 ) { av_log ( h -> avctx , AV_LOG_ERROR , \"changing<S2SV_blank>width/height<S2SV_blank>on<S2SV_blank>\" \"slice<S2SV_blank>%d\\\\n\" , h0 -> current_slice + 1 ) ; return AVERROR_INVALIDDATA ; } flush_change ( h ) ; if ( ( ret = get_pixel_format ( h , 1 ) ) < 0 ) return ret ; h -> avctx -> pix_fmt = ret ; av_log ( h -> avctx , AV_LOG_INFO , \"Reinit<S2SV_blank>context<S2SV_blank>to<S2SV_blank>%dx%d,<S2SV_blank>\" \"pix_fmt:<S2SV_blank>%s\\\\n\" , h -> width , h -> height , av_get_pix_fmt_name ( h -> avctx -> pix_fmt ) ) ; if ( ( ret = h264_slice_header_init ( h , 1 ) ) < 0 ) { av_log ( h -> avctx , AV_LOG_ERROR , \"h264_slice_header_init()<S2SV_blank>failed\\\\n\" ) ; return ret ; } } if ( ! h -> context_initialized ) { if ( h != h0 ) { av_log ( h -> avctx , AV_LOG_ERROR , \"Cannot<S2SV_blank>(re-)initialize<S2SV_blank>context<S2SV_blank>during<S2SV_blank>parallel<S2SV_blank>decoding.\\\\n\" ) ; return AVERROR_PATCHWELCOME ; } if ( ( ret = get_pixel_format ( h , 1 ) ) < 0 ) return ret ; h -> avctx -> pix_fmt = ret ; if ( ( ret = h264_slice_header_init ( h , 0 ) ) < 0 ) { av_log ( h -> avctx , AV_LOG_ERROR , \"h264_slice_header_init()<S2SV_blank>failed\\\\n\" ) ; return ret ; } } if ( h == h0 && h -> dequant_coeff_pps != pps_id ) { h -> dequant_coeff_pps = pps_id ; init_dequant_tables ( h ) ; } h -> frame_num = get_bits ( & h -> gb , h -> sps . log2_max_frame_num ) ; h -> mb_mbaff = 0 ; h -> mb_aff_frame = 0 ; last_pic_structure = h0 -> picture_structure ; last_pic_droppable = h0 -> droppable ; h -> droppable = h -> nal_ref_idc == 0 ; if ( h -> sps . frame_mbs_only_flag ) { h -> picture_structure = PICT_FRAME ; } else { if ( ! h -> sps . direct_8x8_inference_flag && slice_type == AV_PICTURE_TYPE_B ) { av_log ( h -> avctx , AV_LOG_ERROR , \"This<S2SV_blank>stream<S2SV_blank>was<S2SV_blank>generated<S2SV_blank>by<S2SV_blank>a<S2SV_blank>broken<S2SV_blank>encoder,<S2SV_blank>invalid<S2SV_blank>8x8<S2SV_blank>inference\\\\n\" ) ; return - 1 ; } field_pic_flag = get_bits1 ( & h -> gb ) ; if ( field_pic_flag ) { bottom_field_flag = get_bits1 ( & h -> gb ) ; h -> picture_structure = PICT_TOP_FIELD + bottom_field_flag ; } else { h -> picture_structure = PICT_FRAME ; h -> mb_aff_frame = h -> sps . mb_aff ; } } h -> mb_field_decoding_flag = h -> picture_structure != PICT_FRAME ; if ( h0 -> current_slice != 0 ) { if ( last_pic_structure != h -> picture_structure || last_pic_droppable != h -> droppable ) { av_log ( h -> avctx , AV_LOG_ERROR , \"Changing<S2SV_blank>field<S2SV_blank>mode<S2SV_blank>(%d<S2SV_blank>-><S2SV_blank>%d)<S2SV_blank>between<S2SV_blank>slices<S2SV_blank>is<S2SV_blank>not<S2SV_blank>allowed\\\\n\" , last_pic_structure , h -> picture_structure ) ; h -> picture_structure = last_pic_structure ; h -> droppable = last_pic_droppable ; return AVERROR_INVALIDDATA ; } else if ( ! h0 -> cur_pic_ptr ) { av_log ( h -> avctx , AV_LOG_ERROR , \"unset<S2SV_blank>cur_pic_ptr<S2SV_blank>on<S2SV_blank>%d.<S2SV_blank>slice\\\\n\" , h0 -> current_slice + 1 ) ; return AVERROR_INVALIDDATA ; } } else { if ( h -> frame_num != h -> prev_frame_num && h -> prev_frame_num >= 0 ) { int unwrap_prev_frame_num = h -> prev_frame_num ; int max_frame_num = 1 << h -> sps . log2_max_frame_num ; if ( unwrap_prev_frame_num > h -> frame_num ) unwrap_prev_frame_num -= max_frame_num ; if ( ( h -> frame_num - unwrap_prev_frame_num ) > h -> sps . ref_frame_count ) { unwrap_prev_frame_num = ( h -> frame_num - h -> sps . ref_frame_count ) - 1 ; if ( unwrap_prev_frame_num < 0 ) unwrap_prev_frame_num += max_frame_num ; h -> prev_frame_num = unwrap_prev_frame_num ; } } if ( h0 -> first_field ) { assert ( h0 -> cur_pic_ptr ) ; assert ( h0 -> cur_pic_ptr -> f . data [ 0 ] ) ; assert ( h0 -> cur_pic_ptr -> reference != DELAYED_PIC_REF ) ; <S2SV_StartBug> if ( ! last_pic_droppable && h0 -> cur_pic_ptr -> tf . owner == h0 -> avctx ) { <S2SV_EndBug> ff_thread_report_progress ( & h0 -> cur_pic_ptr -> tf , INT_MAX , last_pic_structure == PICT_BOTTOM_FIELD ) ; } if ( ! FIELD_PICTURE ( h ) || h -> picture_structure == last_pic_structure ) { <S2SV_StartBug> if ( ! last_pic_droppable && last_pic_structure != PICT_FRAME ) { <S2SV_EndBug> ff_thread_report_progress ( & h0 -> cur_pic_ptr -> tf , INT_MAX , last_pic_structure == PICT_TOP_FIELD ) ; } } else { if ( h0 -> cur_pic_ptr -> frame_num != h -> frame_num ) { <S2SV_StartBug> if ( ! last_pic_droppable && last_pic_structure != PICT_FRAME ) { <S2SV_EndBug> ff_thread_report_progress ( & h0 -> cur_pic_ptr -> tf , INT_MAX , last_pic_structure == PICT_TOP_FIELD ) ; } } else { if ( ! ( ( last_pic_structure == PICT_TOP_FIELD && h -> picture_structure == PICT_BOTTOM_FIELD ) || ( last_pic_structure == PICT_BOTTOM_FIELD && h -> picture_structure == PICT_TOP_FIELD ) ) ) { av_log ( h -> avctx , AV_LOG_ERROR , \"Invalid<S2SV_blank>field<S2SV_blank>mode<S2SV_blank>combination<S2SV_blank>%d/%d\\\\n\" , last_pic_structure , h -> picture_structure ) ; h -> picture_structure = last_pic_structure ; h -> droppable = last_pic_droppable ; return AVERROR_INVALIDDATA ; } else if ( last_pic_droppable != h -> droppable ) { avpriv_request_sample ( h -> avctx , \"Found<S2SV_blank>reference<S2SV_blank>and<S2SV_blank>non-reference<S2SV_blank>fields<S2SV_blank>in<S2SV_blank>the<S2SV_blank>same<S2SV_blank>frame,<S2SV_blank>which\" ) ; h -> picture_structure = last_pic_structure ; h -> droppable = last_pic_droppable ; return AVERROR_PATCHWELCOME ; } } } } while ( h -> frame_num != h -> prev_frame_num && h -> prev_frame_num >= 0 && ! h0 -> first_field && h -> frame_num != ( h -> prev_frame_num + 1 ) % ( 1 << h -> sps . log2_max_frame_num ) ) { Picture * prev = h -> short_ref_count ? h -> short_ref [ 0 ] : NULL ; av_log ( h -> avctx , AV_LOG_DEBUG , \"Frame<S2SV_blank>num<S2SV_blank>gap<S2SV_blank>%d<S2SV_blank>%d\\\\n\" , h -> frame_num , h -> prev_frame_num ) ; if ( ! h -> sps . gaps_in_frame_num_allowed_flag ) for ( i = 0 ; i < FF_ARRAY_ELEMS ( h -> last_pocs ) ; i ++ ) h -> last_pocs [ i ] = INT_MIN ; ret = h264_frame_start ( h ) ; if ( ret < 0 ) return ret ; h -> prev_frame_num ++ ; h -> prev_frame_num %= 1 << h -> sps . log2_max_frame_num ; h -> cur_pic_ptr -> frame_num = h -> prev_frame_num ; ff_thread_report_progress ( & h -> cur_pic_ptr -> tf , INT_MAX , 0 ) ; ff_thread_report_progress ( & h -> cur_pic_ptr -> tf , INT_MAX , 1 ) ; ret = ff_generate_sliding_window_mmcos ( h , 1 ) ; if ( ret < 0 && ( h -> avctx -> err_recognition & AV_EF_EXPLODE ) ) return ret ; ret = ff_h264_execute_ref_pic_marking ( h , h -> mmco , h -> mmco_index ) ; if ( ret < 0 && ( h -> avctx -> err_recognition & AV_EF_EXPLODE ) ) return ret ; if ( h -> short_ref_count ) { if ( prev ) { av_image_copy ( h -> short_ref [ 0 ] -> f . data , h -> short_ref [ 0 ] -> f . linesize , ( const uint8_t * * ) prev -> f . data , prev -> f . linesize , h -> avctx -> pix_fmt , h -> mb_width * 16 , h -> mb_height * 16 ) ; h -> short_ref [ 0 ] -> poc = prev -> poc + 2 ; } h -> short_ref [ 0 ] -> frame_num = h -> prev_frame_num ; } } if ( h0 -> first_field ) { assert ( h0 -> cur_pic_ptr ) ; assert ( h0 -> cur_pic_ptr -> f . data [ 0 ] ) ; assert ( h0 -> cur_pic_ptr -> reference != DELAYED_PIC_REF ) ; if ( ! FIELD_PICTURE ( h ) || h -> picture_structure == last_pic_structure ) { h0 -> cur_pic_ptr = NULL ; h0 -> first_field = FIELD_PICTURE ( h ) ; } else { if ( h0 -> cur_pic_ptr -> frame_num != h -> frame_num ) { ff_thread_report_progress ( & h0 -> cur_pic_ptr -> tf , INT_MAX , h0 -> picture_structure == PICT_BOTTOM_FIELD ) ; h0 -> first_field = 1 ; h0 -> cur_pic_ptr = NULL ; } else { h0 -> first_field = 0 ; } } } else { h0 -> first_field = FIELD_PICTURE ( h ) ; } if ( ! FIELD_PICTURE ( h ) || h0 -> first_field ) { if ( h264_frame_start ( h ) < 0 ) { h0 -> first_field = 0 ; return AVERROR_INVALIDDATA ; } } else { release_unused_pictures ( h , 0 ) ; } if ( FIELD_PICTURE ( h ) ) { for ( i = ( h -> picture_structure == PICT_BOTTOM_FIELD ) ; i < h -> mb_height ; i ++ ) memset ( h -> slice_table + i * h -> mb_stride , - 1 , ( h -> mb_stride - ( i + 1 == h -> mb_height ) ) * sizeof ( * h -> slice_table ) ) ; } else { memset ( h -> slice_table , - 1 , ( h -> mb_height * h -> mb_stride - 1 ) * sizeof ( * h -> slice_table ) ) ; } h0 -> last_slice_type = - 1 ; } if ( h != h0 && ( ret = clone_slice ( h , h0 ) ) < 0 ) return ret ; for ( i = 0 ; i < h -> slice_context_count ; i ++ ) if ( h -> thread_context [ i ] ) { ret = alloc_scratch_buffers ( h -> thread_context [ i ] , h -> linesize ) ; if ( ret < 0 ) return ret ; } h -> cur_pic_ptr -> frame_num = h -> frame_num ; av_assert1 ( h -> mb_num == h -> mb_width * h -> mb_height ) ; if ( first_mb_in_slice << FIELD_OR_MBAFF_PICTURE ( h ) >= h -> mb_num || first_mb_in_slice >= h -> mb_num ) { av_log ( h -> avctx , AV_LOG_ERROR , \"first_mb_in_slice<S2SV_blank>overflow\\\\n\" ) ; return AVERROR_INVALIDDATA ; } h -> resync_mb_x = h -> mb_x = first_mb_in_slice % h -> mb_width ; h -> resync_mb_y = h -> mb_y = ( first_mb_in_slice / h -> mb_width ) << FIELD_OR_MBAFF_PICTURE ( h ) ; if ( h -> picture_structure == PICT_BOTTOM_FIELD ) h -> resync_mb_y = h -> mb_y = h -> mb_y + 1 ; av_assert1 ( h -> mb_y < h -> mb_height ) ; if ( h -> picture_structure == PICT_FRAME ) { h -> curr_pic_num = h -> frame_num ; h -> max_pic_num = 1 << h -> sps . log2_max_frame_num ; } else { h -> curr_pic_num = 2 * h -> frame_num + 1 ; h -> max_pic_num = 1 << ( h -> sps . log2_max_frame_num + 1 ) ; } if ( h -> nal_unit_type == NAL_IDR_SLICE ) get_ue_golomb ( & h -> gb ) ; if ( h -> sps . poc_type == 0 ) { h -> poc_lsb = get_bits ( & h -> gb , h -> sps . log2_max_poc_lsb ) ; if ( h -> pps . pic_order_present == 1 && h -> picture_structure == PICT_FRAME ) h -> delta_poc_bottom = get_se_golomb ( & h -> gb ) ; } if ( h -> sps . poc_type == 1 && ! h -> sps . delta_pic_order_always_zero_flag ) { h -> delta_poc [ 0 ] = get_se_golomb ( & h -> gb ) ; if ( h -> pps . pic_order_present == 1 && h -> picture_structure == PICT_FRAME ) h -> delta_poc [ 1 ] = get_se_golomb ( & h -> gb ) ; } ff_init_poc ( h , h -> cur_pic_ptr -> field_poc , & h -> cur_pic_ptr -> poc ) ; if ( h -> pps . redundant_pic_cnt_present ) h -> redundant_pic_count = get_ue_golomb ( & h -> gb ) ; ret = ff_set_ref_count ( h ) ; if ( ret < 0 ) return ret ; if ( slice_type != AV_PICTURE_TYPE_I && ( h0 -> current_slice == 0 || slice_type != h0 -> last_slice_type || memcmp ( h0 -> last_ref_count , h0 -> ref_count , sizeof ( h0 -> ref_count ) ) ) ) { ff_h264_fill_default_ref_list ( h ) ; } if ( h -> slice_type_nos != AV_PICTURE_TYPE_I ) { ret = ff_h264_decode_ref_pic_list_reordering ( h ) ; if ( ret < 0 ) { h -> ref_count [ 1 ] = h -> ref_count [ 0 ] = 0 ; return ret ; } } if ( ( h -> pps . weighted_pred && h -> slice_type_nos == AV_PICTURE_TYPE_P ) || ( h -> pps . weighted_bipred_idc == 1 && h -> slice_type_nos == AV_PICTURE_TYPE_B ) ) ff_pred_weight_table ( h ) ; else if ( h -> pps . weighted_bipred_idc == 2 && h -> slice_type_nos == AV_PICTURE_TYPE_B ) { implicit_weight_table ( h , - 1 ) ; } else { h -> use_weight = 0 ; for ( i = 0 ; i < 2 ; i ++ ) { h -> luma_weight_flag [ i ] = 0 ; h -> chroma_weight_flag [ i ] = 0 ; } } if ( h -> nal_ref_idc ) { ret = ff_h264_decode_ref_pic_marking ( h0 , & h -> gb , ! ( h -> avctx -> active_thread_type & FF_THREAD_FRAME ) || h0 -> current_slice == 0 ) ; if ( ret < 0 && ( h -> avctx -> err_recognition & AV_EF_EXPLODE ) ) return AVERROR_INVALIDDATA ; } if ( FRAME_MBAFF ( h ) ) { ff_h264_fill_mbaff_ref_list ( h ) ; if ( h -> pps . weighted_bipred_idc == 2 && h -> slice_type_nos == AV_PICTURE_TYPE_B ) { implicit_weight_table ( h , 0 ) ; implicit_weight_table ( h , 1 ) ; } } if ( h -> slice_type_nos == AV_PICTURE_TYPE_B && ! h -> direct_spatial_mv_pred ) ff_h264_direct_dist_scale_factor ( h ) ; ff_h264_direct_ref_list_init ( h ) ; if ( h -> slice_type_nos != AV_PICTURE_TYPE_I && h -> pps . cabac ) { tmp = get_ue_golomb_31 ( & h -> gb ) ; if ( tmp > 2 ) { av_log ( h -> avctx , AV_LOG_ERROR , \"cabac_init_idc<S2SV_blank>overflow\\\\n\" ) ; return AVERROR_INVALIDDATA ; } h -> cabac_init_idc = tmp ; } h -> last_qscale_diff = 0 ; tmp = h -> pps . init_qp + get_se_golomb ( & h -> gb ) ; if ( tmp > 51 + 6 * ( h -> sps . bit_depth_luma - 8 ) ) { av_log ( h -> avctx , AV_LOG_ERROR , \"QP<S2SV_blank>%u<S2SV_blank>out<S2SV_blank>of<S2SV_blank>range\\\\n\" , tmp ) ; return AVERROR_INVALIDDATA ; } h -> qscale = tmp ; h -> chroma_qp [ 0 ] = get_chroma_qp ( h , 0 , h -> qscale ) ; h -> chroma_qp [ 1 ] = get_chroma_qp ( h , 1 , h -> qscale ) ; if ( h -> slice_type == AV_PICTURE_TYPE_SP ) get_bits1 ( & h -> gb ) ; if ( h -> slice_type == AV_PICTURE_TYPE_SP || h -> slice_type == AV_PICTURE_TYPE_SI ) get_se_golomb ( & h -> gb ) ; h -> deblocking_filter = 1 ; h -> slice_alpha_c0_offset = 52 ; h -> slice_beta_offset = 52 ; if ( h -> pps . deblocking_filter_parameters_present ) { tmp = get_ue_golomb_31 ( & h -> gb ) ; if ( tmp > 2 ) { av_log ( h -> avctx , AV_LOG_ERROR , \"deblocking_filter_idc<S2SV_blank>%u<S2SV_blank>out<S2SV_blank>of<S2SV_blank>range\\\\n\" , tmp ) ; return AVERROR_INVALIDDATA ; } h -> deblocking_filter = tmp ; if ( h -> deblocking_filter < 2 ) h -> deblocking_filter ^= 1 ; if ( h -> deblocking_filter ) { h -> slice_alpha_c0_offset += get_se_golomb ( & h -> gb ) << 1 ; h -> slice_beta_offset += get_se_golomb ( & h -> gb ) << 1 ; if ( h -> slice_alpha_c0_offset > 104U || h -> slice_beta_offset > 104U ) { av_log ( h -> avctx , AV_LOG_ERROR , \"deblocking<S2SV_blank>filter<S2SV_blank>parameters<S2SV_blank>%d<S2SV_blank>%d<S2SV_blank>out<S2SV_blank>of<S2SV_blank>range\\\\n\" , h -> slice_alpha_c0_offset , h -> slice_beta_offset ) ; return AVERROR_INVALIDDATA ; } } } if ( h -> avctx -> skip_loop_filter >= AVDISCARD_ALL || ( h -> avctx -> skip_loop_filter >= AVDISCARD_NONKEY && h -> slice_type_nos != AV_PICTURE_TYPE_I ) || ( h -> avctx -> skip_loop_filter >= AVDISCARD_BIDIR && h -> slice_type_nos == AV_PICTURE_TYPE_B ) || ( h -> avctx -> skip_loop_filter >= AVDISCARD_NONREF && h -> nal_ref_idc == 0 ) ) h -> deblocking_filter = 0 ; if ( h -> deblocking_filter == 1 && h0 -> max_contexts > 1 ) { if ( h -> avctx -> flags2 & CODEC_FLAG2_FAST ) { h -> deblocking_filter = 2 ; } else { h0 -> max_contexts = 1 ; if ( ! h0 -> single_decode_warning ) { av_log ( h -> avctx , AV_LOG_INFO , \"Cannot<S2SV_blank>parallelize<S2SV_blank>deblocking<S2SV_blank>type<S2SV_blank>1,<S2SV_blank>decoding<S2SV_blank>such<S2SV_blank>frames<S2SV_blank>in<S2SV_blank>sequential<S2SV_blank>order\\\\n\" ) ; h0 -> single_decode_warning = 1 ; } if ( h != h0 ) { av_log ( h -> avctx , AV_LOG_ERROR , \"Deblocking<S2SV_blank>switched<S2SV_blank>inside<S2SV_blank>frame.\\\\n\" ) ; return 1 ; } } } h -> qp_thresh = 15 + 52 - FFMIN ( h -> slice_alpha_c0_offset , h -> slice_beta_offset ) - FFMAX3 ( 0 , h -> pps . chroma_qp_index_offset [ 0 ] , h -> pps . chroma_qp_index_offset [ 1 ] ) + 6 * ( h -> sps . bit_depth_luma - 8 ) ; h0 -> last_slice_type = slice_type ; memcpy ( h0 -> last_ref_count , h0 -> ref_count , sizeof ( h0 -> last_ref_count ) ) ; h -> slice_num = ++ h0 -> current_slice ; if ( h -> slice_num ) h0 -> slice_row [ ( h -> slice_num - 1 ) & ( MAX_SLICES - 1 ) ] = h -> resync_mb_y ; if ( h0 -> slice_row [ h -> slice_num & ( MAX_SLICES - 1 ) ] + 3 >= h -> resync_mb_y && h0 -> slice_row [ h -> slice_num & ( MAX_SLICES - 1 ) ] <= h -> resync_mb_y && h -> slice_num >= MAX_SLICES ) { av_log ( h -> avctx , AV_LOG_WARNING , \"Possibly<S2SV_blank>too<S2SV_blank>many<S2SV_blank>slices<S2SV_blank>(%d<S2SV_blank>>=<S2SV_blank>%d),<S2SV_blank>increase<S2SV_blank>MAX_SLICES<S2SV_blank>and<S2SV_blank>recompile<S2SV_blank>if<S2SV_blank>there<S2SV_blank>are<S2SV_blank>artifacts\\\\n\" , h -> slice_num , MAX_SLICES ) ; } for ( j = 0 ; j < 2 ; j ++ ) { int id_list [ 16 ] ; int * ref2frm = h -> ref2frm [ h -> slice_num & ( MAX_SLICES - 1 ) ] [ j ] ; for ( i = 0 ; i < 16 ; i ++ ) { id_list [ i ] = 60 ; if ( j < h -> list_count && i < h -> ref_count [ j ] && h -> ref_list [ j ] [ i ] . f . buf [ 0 ] ) { int k ; AVBuffer * buf = h -> ref_list [ j ] [ i ] . f . buf [ 0 ] -> buffer ; for ( k = 0 ; k < h -> short_ref_count ; k ++ ) if ( h -> short_ref [ k ] -> f . buf [ 0 ] -> buffer == buf ) { id_list [ i ] = k ; break ; } for ( k = 0 ; k < h -> long_ref_count ; k ++ ) if ( h -> long_ref [ k ] && h -> long_ref [ k ] -> f . buf [ 0 ] -> buffer == buf ) { id_list [ i ] = h -> short_ref_count + k ; break ; } } } ref2frm [ 0 ] = ref2frm [ 1 ] = - 1 ; for ( i = 0 ; i < 16 ; i ++ ) ref2frm [ i + 2 ] = 4 * id_list [ i ] + ( h -> ref_list [ j ] [ i ] . reference & 3 ) ; ref2frm [ 18 + 0 ] = ref2frm [ 18 + 1 ] = - 1 ; for ( i = 16 ; i < 48 ; i ++ ) ref2frm [ i + 4 ] = 4 * id_list [ ( i - 16 ) >> 1 ] + ( h -> ref_list [ j ] [ i ] . reference & 3 ) ; } if ( h -> ref_count [ 0 ] ) h -> er . last_pic = & h -> ref_list [ 0 ] [ 0 ] ; if ( h -> ref_count [ 1 ] ) h -> er . next_pic = & h -> ref_list [ 1 ] [ 0 ] ; h -> er . ref_count = h -> ref_count [ 0 ] ; if ( h -> avctx -> debug & FF_DEBUG_PICT_INFO ) { av_log ( h -> avctx , AV_LOG_DEBUG , \"slice:%d<S2SV_blank>%s<S2SV_blank>mb:%d<S2SV_blank>%c%s%s<S2SV_blank>pps:%u<S2SV_blank>frame:%d<S2SV_blank>poc:%d/%d<S2SV_blank>ref:%d/%d<S2SV_blank>qp:%d<S2SV_blank>loop:%d:%d:%d<S2SV_blank>weight:%d%s<S2SV_blank>%s\\\\n\" , h -> slice_num , ( h -> picture_structure == PICT_FRAME ? \"F\" : h -> picture_structure == PICT_TOP_FIELD ? \"T\" : \"B\" ) , first_mb_in_slice , av_get_picture_type_char ( h -> slice_type ) , h -> slice_type_fixed ? \"<S2SV_blank>fix\" : \"\" , h -> nal_unit_type == NAL_IDR_SLICE ? \"<S2SV_blank>IDR\" : \"\" , pps_id , h -> frame_num , h -> cur_pic_ptr -> field_poc [ 0 ] , h -> cur_pic_ptr -> field_poc [ 1 ] , h -> ref_count [ 0 ] , h -> ref_count [ 1 ] , h -> qscale , h -> deblocking_filter , h -> slice_alpha_c0_offset / 2 - 26 , h -> slice_beta_offset / 2 - 26 , h -> use_weight , h -> use_weight == 1 && h -> use_weight_chroma ? \"c\" : \"\" , h -> slice_type == AV_PICTURE_TYPE_B ? ( h -> direct_spatial_mv_pred ? \"SPAT\" : \"TEMP\" ) : \"\" ) ; } return 0 ; }\n","target":"<S2SV_ModStart> ; if ( <S2SV_ModEnd> h0 -> cur_pic_ptr <S2SV_ModStart> { if ( <S2SV_ModEnd> last_pic_structure != PICT_FRAME <S2SV_ModStart> { if ( <S2SV_ModEnd> last_pic_structure != PICT_FRAME\n","project_and_commit_id":"FFmpeg@FFmpeg/29ffeef5e73b8f41ff3a3f2242d356759c66f91f","cve_id":"CVE-2013-7008","original_address":"https://github.com/FFmpeg/FFmpeg/commit/29ffeef5e73b8f41ff3a3f2242d356759c66f91f","time":"2013-12-09T16:36Z"},
	{"Unnamed: 0":6423,"cwe_id":"CWE-20","source":"CWE-20 int HTMLtagproc1 ( struct parsed_tag * tag , struct html_feed_environ * h_env ) { char * p , * q , * r ; int i , w , x , y , z , count , width ; struct readbuffer * obuf = h_env -> obuf ; struct environment * envs = h_env -> envs ; Str tmp ; int hseq ; int cmd ; # ifdef ID_EXT char * id = NULL ; # endif cmd = tag -> tagid ; if ( obuf -> flag & RB_PRE ) { switch ( cmd ) { case HTML_NOBR : case HTML_N_NOBR : case HTML_PRE_INT : case HTML_N_PRE_INT : return 1 ; } } switch ( cmd ) { case HTML_B : obuf -> in_bold ++ ; if ( obuf -> in_bold > 1 ) return 1 ; return 0 ; case HTML_N_B : if ( obuf -> in_bold == 1 && close_effect0 ( obuf , HTML_B ) ) obuf -> in_bold = 0 ; if ( obuf -> in_bold > 0 ) { obuf -> in_bold -- ; if ( obuf -> in_bold == 0 ) return 0 ; } return 1 ; case HTML_I : obuf -> in_italic ++ ; if ( obuf -> in_italic > 1 ) return 1 ; return 0 ; case HTML_N_I : if ( obuf -> in_italic == 1 && close_effect0 ( obuf , HTML_I ) ) obuf -> in_italic = 0 ; if ( obuf -> in_italic > 0 ) { obuf -> in_italic -- ; if ( obuf -> in_italic == 0 ) return 0 ; } return 1 ; case HTML_U : obuf -> in_under ++ ; if ( obuf -> in_under > 1 ) return 1 ; return 0 ; case HTML_N_U : if ( obuf -> in_under == 1 && close_effect0 ( obuf , HTML_U ) ) obuf -> in_under = 0 ; if ( obuf -> in_under > 0 ) { obuf -> in_under -- ; if ( obuf -> in_under == 0 ) return 0 ; } return 1 ; case HTML_EM : HTMLlineproc1 ( \"<i>\" , h_env ) ; return 1 ; case HTML_N_EM : HTMLlineproc1 ( \"</i>\" , h_env ) ; return 1 ; case HTML_STRONG : HTMLlineproc1 ( \"<b>\" , h_env ) ; return 1 ; case HTML_N_STRONG : HTMLlineproc1 ( \"</b>\" , h_env ) ; return 1 ; case HTML_Q : HTMLlineproc1 ( \"`\" , h_env ) ; return 1 ; case HTML_N_Q : HTMLlineproc1 ( \"\\'\" , h_env ) ; return 1 ; case HTML_P : case HTML_N_P : CLOSE_A ; if ( ! ( obuf -> flag & RB_IGNORE_P ) ) { flushline ( h_env , obuf , envs [ h_env -> envc ] . indent , 1 , h_env -> limit ) ; do_blankline ( h_env , obuf , envs [ h_env -> envc ] . indent , 0 , h_env -> limit ) ; } obuf -> flag |= RB_IGNORE_P ; if ( cmd == HTML_P ) { set_alignment ( obuf , tag ) ; obuf -> flag |= RB_P ; } return 1 ; case HTML_BR : flushline ( h_env , obuf , envs [ h_env -> envc ] . indent , 1 , h_env -> limit ) ; h_env -> blank_lines = 0 ; return 1 ; case HTML_H : if ( ! ( obuf -> flag & ( RB_PREMODE | RB_IGNORE_P ) ) ) { flushline ( h_env , obuf , envs [ h_env -> envc ] . indent , 0 , h_env -> limit ) ; do_blankline ( h_env , obuf , envs [ h_env -> envc ] . indent , 0 , h_env -> limit ) ; } HTMLlineproc1 ( \"<b>\" , h_env ) ; set_alignment ( obuf , tag ) ; return 1 ; case HTML_N_H : HTMLlineproc1 ( \"</b>\" , h_env ) ; if ( ! ( obuf -> flag & RB_PREMODE ) ) { flushline ( h_env , obuf , envs [ h_env -> envc ] . indent , 0 , h_env -> limit ) ; } do_blankline ( h_env , obuf , envs [ h_env -> envc ] . indent , 0 , h_env -> limit ) ; RB_RESTORE_FLAG ( obuf ) ; close_anchor ( h_env , obuf ) ; obuf -> flag |= RB_IGNORE_P ; return 1 ; case HTML_UL : case HTML_OL : case HTML_BLQ : CLOSE_A ; if ( ! ( obuf -> flag & RB_IGNORE_P ) ) { flushline ( h_env , obuf , envs [ h_env -> envc ] . indent , 0 , h_env -> limit ) ; if ( ! ( obuf -> flag & RB_PREMODE ) && ( h_env -> envc == 0 || cmd == HTML_BLQ ) ) do_blankline ( h_env , obuf , envs [ h_env -> envc ] . indent , 0 , h_env -> limit ) ; } PUSH_ENV ( cmd ) ; if ( cmd == HTML_UL || cmd == HTML_OL ) { if ( parsedtag_get_value ( tag , ATTR_START , & count ) ) { envs [ h_env -> envc ] . count = count - 1 ; } } if ( cmd == HTML_OL ) { envs [ h_env -> envc ] . type = '1' ; if ( parsedtag_get_value ( tag , ATTR_TYPE , & p ) ) { envs [ h_env -> envc ] . type = ( int ) * p ; } } if ( cmd == HTML_UL ) envs [ h_env -> envc ] . type = ul_type ( tag , 0 ) ; flushline ( h_env , obuf , envs [ h_env -> envc ] . indent , 0 , h_env -> limit ) ; return 1 ; case HTML_N_UL : case HTML_N_OL : case HTML_N_DL : case HTML_N_BLQ : CLOSE_DT ; CLOSE_A ; if ( h_env -> envc > 0 ) { flushline ( h_env , obuf , envs [ h_env -> envc - 1 ] . indent , 0 , h_env -> limit ) ; POP_ENV ; if ( ! ( obuf -> flag & RB_PREMODE ) && ( h_env -> envc == 0 || cmd == HTML_N_DL || cmd == HTML_N_BLQ ) ) { do_blankline ( h_env , obuf , envs [ h_env -> envc ] . indent , INDENT_INCR , h_env -> limit ) ; obuf -> flag |= RB_IGNORE_P ; } } close_anchor ( h_env , obuf ) ; return 1 ; case HTML_DL : CLOSE_A ; if ( ! ( obuf -> flag & RB_IGNORE_P ) ) { flushline ( h_env , obuf , envs [ h_env -> envc ] . indent , 0 , h_env -> limit ) ; if ( ! ( obuf -> flag & RB_PREMODE ) ) do_blankline ( h_env , obuf , envs [ h_env -> envc ] . indent , 0 , h_env -> limit ) ; } PUSH_ENV ( cmd ) ; if ( parsedtag_exists ( tag , ATTR_COMPACT ) ) envs [ h_env -> envc ] . env = HTML_DL_COMPACT ; obuf -> flag |= RB_IGNORE_P ; return 1 ; case HTML_LI : CLOSE_A ; CLOSE_DT ; if ( h_env -> envc > 0 ) { Str num ; flushline ( h_env , obuf , envs [ h_env -> envc - 1 ] . indent , 0 , h_env -> limit ) ; envs [ h_env -> envc ] . count ++ ; if ( parsedtag_get_value ( tag , ATTR_VALUE , & p ) ) { count = atoi ( p ) ; if ( count > 0 ) envs [ h_env -> envc ] . count = count ; else envs [ h_env -> envc ] . count = 0 ; } switch ( envs [ h_env -> envc ] . env ) { case HTML_UL : envs [ h_env -> envc ] . type = ul_type ( tag , envs [ h_env -> envc ] . type ) ; for ( i = 0 ; i < INDENT_INCR - 3 ; i ++ ) push_charp ( obuf , 1 , NBSP , PC_ASCII ) ; tmp = Strnew ( ) ; switch ( envs [ h_env -> envc ] . type ) { case 'd' : push_symbol ( tmp , UL_SYMBOL_DISC , symbol_width , 1 ) ; break ; case 'c' : push_symbol ( tmp , UL_SYMBOL_CIRCLE , symbol_width , 1 ) ; break ; case 's' : push_symbol ( tmp , UL_SYMBOL_SQUARE , symbol_width , 1 ) ; break ; default : push_symbol ( tmp , UL_SYMBOL ( ( h_env -> envc_real - 1 ) % MAX_UL_LEVEL ) , symbol_width , 1 ) ; break ; } if ( symbol_width == 1 ) push_charp ( obuf , 1 , NBSP , PC_ASCII ) ; push_str ( obuf , symbol_width , tmp , PC_ASCII ) ; push_charp ( obuf , 1 , NBSP , PC_ASCII ) ; set_space_to_prevchar ( obuf -> prevchar ) ; break ; case HTML_OL : if ( parsedtag_get_value ( tag , ATTR_TYPE , & p ) ) envs [ h_env -> envc ] . type = ( int ) * p ; switch ( ( envs [ h_env -> envc ] . count > 0 ) ? envs [ h_env -> envc ] . type : '1' ) { case 'i' : num = romanNumeral ( envs [ h_env -> envc ] . count ) ; break ; case 'I' : num = romanNumeral ( envs [ h_env -> envc ] . count ) ; Strupper ( num ) ; break ; case 'a' : num = romanAlphabet ( envs [ h_env -> envc ] . count ) ; break ; case 'A' : num = romanAlphabet ( envs [ h_env -> envc ] . count ) ; Strupper ( num ) ; break ; default : num = Sprintf ( \"%d\" , envs [ h_env -> envc ] . count ) ; break ; } if ( INDENT_INCR >= 4 ) Strcat_charp ( num , \".<S2SV_blank>\" ) ; else Strcat_char ( num , '.' ) ; push_spaces ( obuf , 1 , INDENT_INCR - num -> length ) ; push_str ( obuf , num -> length , num , PC_ASCII ) ; if ( INDENT_INCR >= 4 ) set_space_to_prevchar ( obuf -> prevchar ) ; break ; default : push_spaces ( obuf , 1 , INDENT_INCR ) ; break ; } } else { flushline ( h_env , obuf , 0 , 0 , h_env -> limit ) ; } obuf -> flag |= RB_IGNORE_P ; return 1 ; case HTML_DT : CLOSE_A ; if ( h_env -> envc == 0 || ( h_env -> envc_real < h_env -> nenv && envs [ h_env -> envc ] . env != HTML_DL && envs [ h_env -> envc ] . env != HTML_DL_COMPACT ) ) { PUSH_ENV ( HTML_DL ) ; } if ( h_env -> envc > 0 ) { flushline ( h_env , obuf , envs [ h_env -> envc - 1 ] . indent , 0 , h_env -> limit ) ; } if ( ! ( obuf -> flag & RB_IN_DT ) ) { HTMLlineproc1 ( \"<b>\" , h_env ) ; obuf -> flag |= RB_IN_DT ; } obuf -> flag |= RB_IGNORE_P ; return 1 ; case HTML_DD : CLOSE_A ; CLOSE_DT ; <S2SV_StartBug> if ( envs [ h_env -> envc ] . env == HTML_DL_COMPACT ) { <S2SV_EndBug> if ( obuf -> pos > envs [ h_env -> envc ] . indent ) flushline ( h_env , obuf , envs [ h_env -> envc ] . indent , 0 , h_env -> limit ) ; else push_spaces ( obuf , 1 , envs [ h_env -> envc ] . indent - obuf -> pos ) ; } else flushline ( h_env , obuf , envs [ h_env -> envc ] . indent , 0 , h_env -> limit ) ; return 1 ; case HTML_TITLE : close_anchor ( h_env , obuf ) ; process_title ( tag ) ; obuf -> flag |= RB_TITLE ; obuf -> end_tag = HTML_N_TITLE ; return 1 ; case HTML_N_TITLE : if ( ! ( obuf -> flag & RB_TITLE ) ) return 1 ; obuf -> flag &= ~ RB_TITLE ; obuf -> end_tag = 0 ; tmp = process_n_title ( tag ) ; if ( tmp ) HTMLlineproc1 ( tmp -> ptr , h_env ) ; return 1 ; case HTML_TITLE_ALT : if ( parsedtag_get_value ( tag , ATTR_TITLE , & p ) ) h_env -> title = html_unquote ( p ) ; return 0 ; case HTML_FRAMESET : PUSH_ENV ( cmd ) ; push_charp ( obuf , 9 , \"--FRAME--\" , PC_ASCII ) ; flushline ( h_env , obuf , envs [ h_env -> envc ] . indent , 0 , h_env -> limit ) ; return 0 ; case HTML_N_FRAMESET : if ( h_env -> envc > 0 ) { POP_ENV ; flushline ( h_env , obuf , envs [ h_env -> envc ] . indent , 0 , h_env -> limit ) ; } return 0 ; case HTML_NOFRAMES : CLOSE_A ; flushline ( h_env , obuf , envs [ h_env -> envc ] . indent , 0 , h_env -> limit ) ; obuf -> flag |= ( RB_NOFRAMES | RB_IGNORE_P ) ; return 1 ; case HTML_N_NOFRAMES : CLOSE_A ; flushline ( h_env , obuf , envs [ h_env -> envc ] . indent , 0 , h_env -> limit ) ; obuf -> flag &= ~ RB_NOFRAMES ; return 1 ; case HTML_FRAME : q = r = NULL ; parsedtag_get_value ( tag , ATTR_SRC , & q ) ; parsedtag_get_value ( tag , ATTR_NAME , & r ) ; if ( q ) { q = html_quote ( q ) ; push_tag ( obuf , Sprintf ( \"<a<S2SV_blank>hseq=\\\\\"%d\\\\\"<S2SV_blank>href=\\\\\"%s\\\\\">\" , cur_hseq ++ , q ) -> ptr , HTML_A ) ; if ( r ) q = html_quote ( r ) ; push_charp ( obuf , get_strwidth ( q ) , q , PC_ASCII ) ; push_tag ( obuf , \"</a>\" , HTML_N_A ) ; } flushline ( h_env , obuf , envs [ h_env -> envc ] . indent , 0 , h_env -> limit ) ; return 0 ; case HTML_HR : close_anchor ( h_env , obuf ) ; tmp = process_hr ( tag , h_env -> limit , envs [ h_env -> envc ] . indent ) ; HTMLlineproc1 ( tmp -> ptr , h_env ) ; set_space_to_prevchar ( obuf -> prevchar ) ; return 1 ; case HTML_PRE : x = parsedtag_exists ( tag , ATTR_FOR_TABLE ) ; CLOSE_A ; if ( ! ( obuf -> flag & RB_IGNORE_P ) ) { flushline ( h_env , obuf , envs [ h_env -> envc ] . indent , 0 , h_env -> limit ) ; if ( ! x ) do_blankline ( h_env , obuf , envs [ h_env -> envc ] . indent , 0 , h_env -> limit ) ; } else fillline ( obuf , envs [ h_env -> envc ] . indent ) ; obuf -> flag |= ( RB_PRE | RB_IGNORE_P ) ; return 1 ; case HTML_N_PRE : flushline ( h_env , obuf , envs [ h_env -> envc ] . indent , 0 , h_env -> limit ) ; if ( ! ( obuf -> flag & RB_IGNORE_P ) ) { do_blankline ( h_env , obuf , envs [ h_env -> envc ] . indent , 0 , h_env -> limit ) ; obuf -> flag |= RB_IGNORE_P ; h_env -> blank_lines ++ ; } obuf -> flag &= ~ RB_PRE ; close_anchor ( h_env , obuf ) ; return 1 ; case HTML_PRE_INT : i = obuf -> line -> length ; append_tags ( obuf ) ; if ( ! ( obuf -> flag & RB_SPECIAL ) ) { set_breakpoint ( obuf , obuf -> line -> length - i ) ; } obuf -> flag |= RB_PRE_INT ; return 0 ; case HTML_N_PRE_INT : push_tag ( obuf , \"</pre_int>\" , HTML_N_PRE_INT ) ; obuf -> flag &= ~ RB_PRE_INT ; if ( ! ( obuf -> flag & RB_SPECIAL ) && obuf -> pos > obuf -> bp . pos ) { set_prevchar ( obuf -> prevchar , \"\" , 0 ) ; obuf -> prev_ctype = PC_CTRL ; } return 1 ; case HTML_NOBR : obuf -> flag |= RB_NOBR ; obuf -> nobr_level ++ ; return 0 ; case HTML_N_NOBR : if ( obuf -> nobr_level > 0 ) obuf -> nobr_level -- ; if ( obuf -> nobr_level == 0 ) obuf -> flag &= ~ RB_NOBR ; return 0 ; case HTML_PRE_PLAIN : CLOSE_A ; if ( ! ( obuf -> flag & RB_IGNORE_P ) ) { flushline ( h_env , obuf , envs [ h_env -> envc ] . indent , 0 , h_env -> limit ) ; do_blankline ( h_env , obuf , envs [ h_env -> envc ] . indent , 0 , h_env -> limit ) ; } obuf -> flag |= ( RB_PRE | RB_IGNORE_P ) ; return 1 ; case HTML_N_PRE_PLAIN : CLOSE_A ; if ( ! ( obuf -> flag & RB_IGNORE_P ) ) { flushline ( h_env , obuf , envs [ h_env -> envc ] . indent , 0 , h_env -> limit ) ; do_blankline ( h_env , obuf , envs [ h_env -> envc ] . indent , 0 , h_env -> limit ) ; obuf -> flag |= RB_IGNORE_P ; } obuf -> flag &= ~ RB_PRE ; return 1 ; case HTML_LISTING : case HTML_XMP : case HTML_PLAINTEXT : CLOSE_A ; if ( ! ( obuf -> flag & RB_IGNORE_P ) ) { flushline ( h_env , obuf , envs [ h_env -> envc ] . indent , 0 , h_env -> limit ) ; do_blankline ( h_env , obuf , envs [ h_env -> envc ] . indent , 0 , h_env -> limit ) ; } obuf -> flag |= ( RB_PLAIN | RB_IGNORE_P ) ; switch ( cmd ) { case HTML_LISTING : obuf -> end_tag = HTML_N_LISTING ; break ; case HTML_XMP : obuf -> end_tag = HTML_N_XMP ; break ; case HTML_PLAINTEXT : obuf -> end_tag = MAX_HTMLTAG ; break ; } return 1 ; case HTML_N_LISTING : case HTML_N_XMP : CLOSE_A ; if ( ! ( obuf -> flag & RB_IGNORE_P ) ) { flushline ( h_env , obuf , envs [ h_env -> envc ] . indent , 0 , h_env -> limit ) ; do_blankline ( h_env , obuf , envs [ h_env -> envc ] . indent , 0 , h_env -> limit ) ; obuf -> flag |= RB_IGNORE_P ; } obuf -> flag &= ~ RB_PLAIN ; obuf -> end_tag = 0 ; return 1 ; case HTML_SCRIPT : obuf -> flag |= RB_SCRIPT ; obuf -> end_tag = HTML_N_SCRIPT ; return 1 ; case HTML_STYLE : obuf -> flag |= RB_STYLE ; obuf -> end_tag = HTML_N_STYLE ; return 1 ; case HTML_N_SCRIPT : obuf -> flag &= ~ RB_SCRIPT ; obuf -> end_tag = 0 ; return 1 ; case HTML_N_STYLE : obuf -> flag &= ~ RB_STYLE ; obuf -> end_tag = 0 ; return 1 ; case HTML_A : if ( obuf -> anchor . url ) close_anchor ( h_env , obuf ) ; hseq = 0 ; if ( parsedtag_get_value ( tag , ATTR_HREF , & p ) ) obuf -> anchor . url = Strnew_charp ( p ) -> ptr ; if ( parsedtag_get_value ( tag , ATTR_TARGET , & p ) ) obuf -> anchor . target = Strnew_charp ( p ) -> ptr ; if ( parsedtag_get_value ( tag , ATTR_REFERER , & p ) ) obuf -> anchor . referer = Strnew_charp ( p ) -> ptr ; if ( parsedtag_get_value ( tag , ATTR_TITLE , & p ) ) obuf -> anchor . title = Strnew_charp ( p ) -> ptr ; if ( parsedtag_get_value ( tag , ATTR_ACCESSKEY , & p ) ) obuf -> anchor . accesskey = ( unsigned char ) * p ; if ( parsedtag_get_value ( tag , ATTR_HSEQ , & hseq ) ) obuf -> anchor . hseq = hseq ; if ( hseq == 0 && obuf -> anchor . url ) { obuf -> anchor . hseq = cur_hseq ; tmp = process_anchor ( tag , h_env -> tagbuf -> ptr ) ; push_tag ( obuf , tmp -> ptr , HTML_A ) ; if ( displayLinkNumber ) HTMLlineproc1 ( getLinkNumberStr ( - 1 ) -> ptr , h_env ) ; return 1 ; } return 0 ; case HTML_N_A : close_anchor ( h_env , obuf ) ; return 1 ; case HTML_IMG : tmp = process_img ( tag , h_env -> limit ) ; HTMLlineproc1 ( tmp -> ptr , h_env ) ; return 1 ; case HTML_IMG_ALT : if ( parsedtag_get_value ( tag , ATTR_SRC , & p ) ) obuf -> img_alt = Strnew_charp ( p ) ; # ifdef USE_IMAGE i = 0 ; if ( parsedtag_get_value ( tag , ATTR_TOP_MARGIN , & i ) ) { if ( i > obuf -> top_margin ) obuf -> top_margin = i ; } i = 0 ; if ( parsedtag_get_value ( tag , ATTR_BOTTOM_MARGIN , & i ) ) { if ( i > obuf -> bottom_margin ) obuf -> bottom_margin = i ; } # endif return 0 ; case HTML_N_IMG_ALT : if ( obuf -> img_alt ) { if ( ! close_effect0 ( obuf , HTML_IMG_ALT ) ) push_tag ( obuf , \"</img_alt>\" , HTML_N_IMG_ALT ) ; obuf -> img_alt = NULL ; } return 1 ; case HTML_INPUT_ALT : i = 0 ; if ( parsedtag_get_value ( tag , ATTR_TOP_MARGIN , & i ) ) { if ( i > obuf -> top_margin ) obuf -> top_margin = i ; } i = 0 ; if ( parsedtag_get_value ( tag , ATTR_BOTTOM_MARGIN , & i ) ) { if ( i > obuf -> bottom_margin ) obuf -> bottom_margin = i ; } if ( parsedtag_get_value ( tag , ATTR_HSEQ , & hseq ) ) { obuf -> input_alt . hseq = hseq ; } if ( parsedtag_get_value ( tag , ATTR_FID , & i ) ) { obuf -> input_alt . fid = i ; } if ( parsedtag_get_value ( tag , ATTR_TYPE , & p ) ) { obuf -> input_alt . type = Strnew_charp ( p ) ; } if ( parsedtag_get_value ( tag , ATTR_VALUE , & p ) ) { obuf -> input_alt . value = Strnew_charp ( p ) ; } if ( parsedtag_get_value ( tag , ATTR_NAME , & p ) ) { obuf -> input_alt . name = Strnew_charp ( p ) ; } obuf -> input_alt . in = 1 ; return 0 ; case HTML_N_INPUT_ALT : if ( obuf -> input_alt . in ) { if ( ! close_effect0 ( obuf , HTML_INPUT_ALT ) ) push_tag ( obuf , \"</input_alt>\" , HTML_N_INPUT_ALT ) ; obuf -> input_alt . hseq = 0 ; obuf -> input_alt . fid = - 1 ; obuf -> input_alt . in = 0 ; obuf -> input_alt . type = NULL ; obuf -> input_alt . name = NULL ; obuf -> input_alt . value = NULL ; } return 1 ; case HTML_TABLE : close_anchor ( h_env , obuf ) ; obuf -> table_level ++ ; if ( obuf -> table_level >= MAX_TABLE ) break ; w = BORDER_NONE ; x = 2 ; y = 1 ; z = 0 ; width = 0 ; if ( parsedtag_exists ( tag , ATTR_BORDER ) ) { if ( parsedtag_get_value ( tag , ATTR_BORDER , & w ) ) { if ( w > 2 ) w = BORDER_THICK ; else if ( w < 0 ) { w = BORDER_THIN ; } } else w = BORDER_THIN ; } if ( DisplayBorders && w == BORDER_NONE ) w = BORDER_THIN ; if ( parsedtag_get_value ( tag , ATTR_WIDTH , & i ) ) { if ( obuf -> table_level == 0 ) width = REAL_WIDTH ( i , h_env -> limit - envs [ h_env -> envc ] . indent ) ; else width = RELATIVE_WIDTH ( i ) ; } if ( parsedtag_exists ( tag , ATTR_HBORDER ) ) w = BORDER_NOWIN ; # define MAX_CELLSPACING 1000 # define MAX_CELLPADDING 1000 # define MAX_VSPACE 1000 parsedtag_get_value ( tag , ATTR_CELLSPACING , & x ) ; parsedtag_get_value ( tag , ATTR_CELLPADDING , & y ) ; parsedtag_get_value ( tag , ATTR_VSPACE , & z ) ; if ( x > MAX_CELLSPACING ) x = MAX_CELLSPACING ; if ( y > MAX_CELLPADDING ) y = MAX_CELLPADDING ; if ( z > MAX_VSPACE ) z = MAX_VSPACE ; # ifdef ID_EXT parsedtag_get_value ( tag , ATTR_ID , & id ) ; # endif tables [ obuf -> table_level ] = begin_table ( w , x , y , z ) ; # ifdef ID_EXT if ( id != NULL ) tables [ obuf -> table_level ] -> id = Strnew_charp ( id ) ; # endif table_mode [ obuf -> table_level ] . pre_mode = 0 ; table_mode [ obuf -> table_level ] . indent_level = 0 ; table_mode [ obuf -> table_level ] . nobr_level = 0 ; table_mode [ obuf -> table_level ] . caption = 0 ; table_mode [ obuf -> table_level ] . end_tag = 0 ; # ifndef TABLE_EXPAND tables [ obuf -> table_level ] -> total_width = width ; # else tables [ obuf -> table_level ] -> real_width = width ; tables [ obuf -> table_level ] -> total_width = 0 ; # endif return 1 ; case HTML_N_TABLE : return 1 ; case HTML_CENTER : CLOSE_A ; if ( ! ( obuf -> flag & ( RB_PREMODE | RB_IGNORE_P ) ) ) flushline ( h_env , obuf , envs [ h_env -> envc ] . indent , 0 , h_env -> limit ) ; RB_SAVE_FLAG ( obuf ) ; RB_SET_ALIGN ( obuf , RB_CENTER ) ; return 1 ; case HTML_N_CENTER : CLOSE_A ; if ( ! ( obuf -> flag & RB_PREMODE ) ) flushline ( h_env , obuf , envs [ h_env -> envc ] . indent , 0 , h_env -> limit ) ; RB_RESTORE_FLAG ( obuf ) ; return 1 ; case HTML_DIV : CLOSE_A ; if ( ! ( obuf -> flag & RB_IGNORE_P ) ) flushline ( h_env , obuf , envs [ h_env -> envc ] . indent , 0 , h_env -> limit ) ; set_alignment ( obuf , tag ) ; return 1 ; case HTML_N_DIV : CLOSE_A ; flushline ( h_env , obuf , envs [ h_env -> envc ] . indent , 0 , h_env -> limit ) ; RB_RESTORE_FLAG ( obuf ) ; return 1 ; case HTML_DIV_INT : CLOSE_P ; if ( ! ( obuf -> flag & RB_IGNORE_P ) ) flushline ( h_env , obuf , envs [ h_env -> envc ] . indent , 0 , h_env -> limit ) ; set_alignment ( obuf , tag ) ; return 1 ; case HTML_N_DIV_INT : CLOSE_P ; flushline ( h_env , obuf , envs [ h_env -> envc ] . indent , 0 , h_env -> limit ) ; RB_RESTORE_FLAG ( obuf ) ; return 1 ; case HTML_FORM : CLOSE_A ; if ( ! ( obuf -> flag & RB_IGNORE_P ) ) flushline ( h_env , obuf , envs [ h_env -> envc ] . indent , 0 , h_env -> limit ) ; tmp = process_form ( tag ) ; if ( tmp ) HTMLlineproc1 ( tmp -> ptr , h_env ) ; return 1 ; case HTML_N_FORM : CLOSE_A ; flushline ( h_env , obuf , envs [ h_env -> envc ] . indent , 0 , h_env -> limit ) ; obuf -> flag |= RB_IGNORE_P ; process_n_form ( ) ; return 1 ; case HTML_INPUT : close_anchor ( h_env , obuf ) ; tmp = process_input ( tag ) ; if ( tmp ) HTMLlineproc1 ( tmp -> ptr , h_env ) ; return 1 ; case HTML_BUTTON : tmp = process_button ( tag ) ; if ( tmp ) HTMLlineproc1 ( tmp -> ptr , h_env ) ; return 1 ; case HTML_N_BUTTON : tmp = process_n_button ( ) ; if ( tmp ) HTMLlineproc1 ( tmp -> ptr , h_env ) ; return 1 ; case HTML_SELECT : close_anchor ( h_env , obuf ) ; tmp = process_select ( tag ) ; if ( tmp ) HTMLlineproc1 ( tmp -> ptr , h_env ) ; obuf -> flag |= RB_INSELECT ; obuf -> end_tag = HTML_N_SELECT ; return 1 ; case HTML_N_SELECT : obuf -> flag &= ~ RB_INSELECT ; obuf -> end_tag = 0 ; tmp = process_n_select ( ) ; if ( tmp ) HTMLlineproc1 ( tmp -> ptr , h_env ) ; return 1 ; case HTML_OPTION : return 1 ; case HTML_TEXTAREA : close_anchor ( h_env , obuf ) ; tmp = process_textarea ( tag , h_env -> limit ) ; if ( tmp ) HTMLlineproc1 ( tmp -> ptr , h_env ) ; obuf -> flag |= RB_INTXTA ; obuf -> end_tag = HTML_N_TEXTAREA ; return 1 ; case HTML_N_TEXTAREA : obuf -> flag &= ~ RB_INTXTA ; obuf -> end_tag = 0 ; tmp = process_n_textarea ( ) ; if ( tmp ) HTMLlineproc1 ( tmp -> ptr , h_env ) ; return 1 ; case HTML_ISINDEX : p = \"\" ; q = \"!CURRENT_URL!\" ; parsedtag_get_value ( tag , ATTR_PROMPT , & p ) ; parsedtag_get_value ( tag , ATTR_ACTION , & q ) ; tmp = Strnew_m_charp ( \"<form<S2SV_blank>method=get<S2SV_blank>action=\\\\\"\" , html_quote ( q ) , \"\\\\\">\" , html_quote ( p ) , \"<input<S2SV_blank>type=text<S2SV_blank>name=\\\\\"\\\\\"<S2SV_blank>accept></form>\" , NULL ) ; HTMLlineproc1 ( tmp -> ptr , h_env ) ; return 1 ; case HTML_META : p = q = r = NULL ; parsedtag_get_value ( tag , ATTR_HTTP_EQUIV , & p ) ; parsedtag_get_value ( tag , ATTR_CONTENT , & q ) ; # ifdef USE_M17N parsedtag_get_value ( tag , ATTR_CHARSET , & r ) ; if ( r ) { SKIP_BLANKS ( r ) ; meta_charset = wc_guess_charset ( r , 0 ) ; } else if ( p && q && ! strcasecmp ( p , \"Content-Type\" ) && ( q = strcasestr ( q , \"charset\" ) ) != NULL ) { q += 7 ; SKIP_BLANKS ( q ) ; if ( * q == '=' ) { q ++ ; SKIP_BLANKS ( q ) ; meta_charset = wc_guess_charset ( q , 0 ) ; } } else # endif if ( p && q && ! strcasecmp ( p , \"refresh\" ) ) { int refresh_interval ; tmp = NULL ; refresh_interval = getMetaRefreshParam ( q , & tmp ) ; if ( tmp ) { q = html_quote ( tmp -> ptr ) ; tmp = Sprintf ( \"Refresh<S2SV_blank>(%d<S2SV_blank>sec)<S2SV_blank><a<S2SV_blank>href=\\\\\"%s\\\\\">%s</a>\" , refresh_interval , q , q ) ; } else if ( refresh_interval > 0 ) tmp = Sprintf ( \"Refresh<S2SV_blank>(%d<S2SV_blank>sec)\" , refresh_interval ) ; if ( tmp ) { HTMLlineproc1 ( tmp -> ptr , h_env ) ; do_blankline ( h_env , obuf , envs [ h_env -> envc ] . indent , 0 , h_env -> limit ) ; if ( ! is_redisplay && ! ( ( obuf -> flag & RB_NOFRAMES ) && RenderFrame ) ) { tag -> need_reconstruct = TRUE ; return 0 ; } } } return 1 ; case HTML_BASE : # if defined ( USE_M17N ) || defined ( USE_IMAGE ) p = NULL ; if ( parsedtag_get_value ( tag , ATTR_HREF , & p ) ) { cur_baseURL = New ( ParsedURL ) ; parseURL ( p , cur_baseURL , NULL ) ; } # endif case HTML_MAP : case HTML_N_MAP : case HTML_AREA : return 0 ; case HTML_DEL : switch ( displayInsDel ) { case DISPLAY_INS_DEL_SIMPLE : obuf -> flag |= RB_DEL ; break ; case DISPLAY_INS_DEL_NORMAL : HTMLlineproc1 ( \"<U>[DEL:</U>\" , h_env ) ; break ; case DISPLAY_INS_DEL_FONTIFY : obuf -> in_strike ++ ; if ( obuf -> in_strike == 1 ) { push_tag ( obuf , \"<s>\" , HTML_S ) ; } break ; } return 1 ; case HTML_N_DEL : switch ( displayInsDel ) { case DISPLAY_INS_DEL_SIMPLE : obuf -> flag &= ~ RB_DEL ; break ; case DISPLAY_INS_DEL_NORMAL : HTMLlineproc1 ( \"<U>:DEL]</U>\" , h_env ) ; case DISPLAY_INS_DEL_FONTIFY : if ( obuf -> in_strike == 0 ) return 1 ; if ( obuf -> in_strike == 1 && close_effect0 ( obuf , HTML_S ) ) obuf -> in_strike = 0 ; if ( obuf -> in_strike > 0 ) { obuf -> in_strike -- ; if ( obuf -> in_strike == 0 ) { push_tag ( obuf , \"</s>\" , HTML_N_S ) ; } } break ; } return 1 ; case HTML_S : switch ( displayInsDel ) { case DISPLAY_INS_DEL_SIMPLE : obuf -> flag |= RB_S ; break ; case DISPLAY_INS_DEL_NORMAL : HTMLlineproc1 ( \"<U>[S:</U>\" , h_env ) ; break ; case DISPLAY_INS_DEL_FONTIFY : obuf -> in_strike ++ ; if ( obuf -> in_strike == 1 ) { push_tag ( obuf , \"<s>\" , HTML_S ) ; } break ; } return 1 ; case HTML_N_S : switch ( displayInsDel ) { case DISPLAY_INS_DEL_SIMPLE : obuf -> flag &= ~ RB_S ; break ; case DISPLAY_INS_DEL_NORMAL : HTMLlineproc1 ( \"<U>:S]</U>\" , h_env ) ; break ; case DISPLAY_INS_DEL_FONTIFY : if ( obuf -> in_strike == 0 ) return 1 ; if ( obuf -> in_strike == 1 && close_effect0 ( obuf , HTML_S ) ) obuf -> in_strike = 0 ; if ( obuf -> in_strike > 0 ) { obuf -> in_strike -- ; if ( obuf -> in_strike == 0 ) { push_tag ( obuf , \"</s>\" , HTML_N_S ) ; } } } return 1 ; case HTML_INS : switch ( displayInsDel ) { case DISPLAY_INS_DEL_SIMPLE : break ; case DISPLAY_INS_DEL_NORMAL : HTMLlineproc1 ( \"<U>[INS:</U>\" , h_env ) ; break ; case DISPLAY_INS_DEL_FONTIFY : obuf -> in_ins ++ ; if ( obuf -> in_ins == 1 ) { push_tag ( obuf , \"<ins>\" , HTML_INS ) ; } break ; } return 1 ; case HTML_N_INS : switch ( displayInsDel ) { case DISPLAY_INS_DEL_SIMPLE : break ; case DISPLAY_INS_DEL_NORMAL : HTMLlineproc1 ( \"<U>:INS]</U>\" , h_env ) ; break ; case DISPLAY_INS_DEL_FONTIFY : if ( obuf -> in_ins == 0 ) return 1 ; if ( obuf -> in_ins == 1 && close_effect0 ( obuf , HTML_INS ) ) obuf -> in_ins = 0 ; if ( obuf -> in_ins > 0 ) { obuf -> in_ins -- ; if ( obuf -> in_ins == 0 ) { push_tag ( obuf , \"</ins>\" , HTML_N_INS ) ; } } break ; } return 1 ; case HTML_SUP : if ( ! ( obuf -> flag & ( RB_DEL | RB_S ) ) ) HTMLlineproc1 ( \"^\" , h_env ) ; return 1 ; case HTML_N_SUP : return 1 ; case HTML_SUB : if ( ! ( obuf -> flag & ( RB_DEL | RB_S ) ) ) HTMLlineproc1 ( \"[\" , h_env ) ; return 1 ; case HTML_N_SUB : if ( ! ( obuf -> flag & ( RB_DEL | RB_S ) ) ) HTMLlineproc1 ( \"]\" , h_env ) ; return 1 ; case HTML_FONT : case HTML_N_FONT : case HTML_NOP : return 1 ; case HTML_BGSOUND : if ( view_unseenobject ) { if ( parsedtag_get_value ( tag , ATTR_SRC , & p ) ) { Str s ; q = html_quote ( p ) ; s = Sprintf ( \"<A<S2SV_blank>HREF=\\\\\"%s\\\\\">bgsound(%s)</A>\" , q , q ) ; HTMLlineproc1 ( s -> ptr , h_env ) ; } } return 1 ; case HTML_EMBED : if ( view_unseenobject ) { if ( parsedtag_get_value ( tag , ATTR_SRC , & p ) ) { Str s ; q = html_quote ( p ) ; s = Sprintf ( \"<A<S2SV_blank>HREF=\\\\\"%s\\\\\">embed(%s)</A>\" , q , q ) ; HTMLlineproc1 ( s -> ptr , h_env ) ; } } return 1 ; case HTML_APPLET : if ( view_unseenobject ) { if ( parsedtag_get_value ( tag , ATTR_ARCHIVE , & p ) ) { Str s ; q = html_quote ( p ) ; s = Sprintf ( \"<A<S2SV_blank>HREF=\\\\\"%s\\\\\">applet<S2SV_blank>archive(%s)</A>\" , q , q ) ; HTMLlineproc1 ( s -> ptr , h_env ) ; } } return 1 ; case HTML_BODY : if ( view_unseenobject ) { if ( parsedtag_get_value ( tag , ATTR_BACKGROUND , & p ) ) { Str s ; q = html_quote ( p ) ; s = Sprintf ( \"<IMG<S2SV_blank>SRC=\\\\\"%s\\\\\"<S2SV_blank>ALT=\\\\\"bg<S2SV_blank>image(%s)\\\\\"><BR>\" , q , q ) ; HTMLlineproc1 ( s -> ptr , h_env ) ; } } case HTML_N_HEAD : if ( obuf -> flag & RB_TITLE ) HTMLlineproc1 ( \"</title>\" , h_env ) ; case HTML_HEAD : case HTML_N_BODY : return 1 ; default : return 0 ; } return 0 ; }\n","target":"<S2SV_ModStart> ; if ( h_env -> envc == 0 || ( h_env -> envc_real < h_env -> nenv && envs [ h_env -> envc ] . env != HTML_DL && envs [ h_env -> envc ] . env != HTML_DL_COMPACT ) ) { PUSH_ENV ( HTML_DL ) ; } if (\n","project_and_commit_id":"tats@w3m/33509cc81ec5f2ba44eb6fd98bd5c1b5873e46bd","cve_id":"CVE-2016-9436","original_address":"https://github.com/tats/w3m/commit/33509cc81ec5f2ba44eb6fd98bd5c1b5873e46bd","time":"2017-01-20T15:59Z"},
	{"Unnamed: 0":313,"cwe_id":"CWE-20","source":"CWE-20 static void copy_move_file ( CopyMoveJob * copy_job , GFile * src , GFile * dest_dir , gboolean same_fs , gboolean unique_names , char * * dest_fs_type , SourceInfo * source_info , TransferInfo * transfer_info , GHashTable * debuting_files , GdkPoint * position , gboolean overwrite , gboolean * skipped_file , gboolean readonly_source_fs ) { GFile * dest , * new_dest ; g_autofree gchar * dest_uri = NULL ; GError * error ; GFileCopyFlags flags ; char * primary , * secondary , * details ; int response ; ProgressData pdata ; gboolean would_recurse , is_merge ; CommonJob * job ; gboolean res ; int unique_name_nr ; gboolean handled_invalid_filename ; job = ( CommonJob * ) copy_job ; if ( should_skip_file ( job , src ) ) { * skipped_file = TRUE ; return ; } unique_name_nr = 1 ; handled_invalid_filename = * dest_fs_type != NULL ; if ( unique_names ) { dest = get_unique_target_file ( src , dest_dir , same_fs , * dest_fs_type , unique_name_nr ++ ) ; } else if ( copy_job -> target_name != NULL ) { dest = get_target_file_with_custom_name ( src , dest_dir , * dest_fs_type , same_fs , copy_job -> target_name ) ; } else { dest = get_target_file ( src , dest_dir , * dest_fs_type , same_fs ) ; } if ( test_dir_is_parent ( dest_dir , src ) ) { if ( job -> skip_all_error ) { goto out ; } primary = copy_job -> is_move ? g_strdup ( _ ( \"You<S2SV_blank>cannot<S2SV_blank>move<S2SV_blank>a<S2SV_blank>folder<S2SV_blank>into<S2SV_blank>itself.\" ) ) : g_strdup ( _ ( \"You<S2SV_blank>cannot<S2SV_blank>copy<S2SV_blank>a<S2SV_blank>folder<S2SV_blank>into<S2SV_blank>itself.\" ) ) ; secondary = g_strdup ( _ ( \"The<S2SV_blank>destination<S2SV_blank>folder<S2SV_blank>is<S2SV_blank>inside<S2SV_blank>the<S2SV_blank>source<S2SV_blank>folder.\" ) ) ; response = run_cancel_or_skip_warning ( job , primary , secondary , NULL , source_info -> num_files , source_info -> num_files - transfer_info -> num_files ) ; if ( response == 0 || response == GTK_RESPONSE_DELETE_EVENT ) { abort_job ( job ) ; } else if ( response == 1 ) { job -> skip_all_error = TRUE ; } else if ( response == 2 ) { } else { g_assert_not_reached ( ) ; } goto out ; } if ( test_dir_is_parent ( src , dest ) ) { if ( job -> skip_all_error ) { goto out ; } primary = copy_job -> is_move ? g_strdup ( _ ( \"You<S2SV_blank>cannot<S2SV_blank>move<S2SV_blank>a<S2SV_blank>file<S2SV_blank>over<S2SV_blank>itself.\" ) ) : g_strdup ( _ ( \"You<S2SV_blank>cannot<S2SV_blank>copy<S2SV_blank>a<S2SV_blank>file<S2SV_blank>over<S2SV_blank>itself.\" ) ) ; secondary = g_strdup ( _ ( \"The<S2SV_blank>source<S2SV_blank>file<S2SV_blank>would<S2SV_blank>be<S2SV_blank>overwritten<S2SV_blank>by<S2SV_blank>the<S2SV_blank>destination.\" ) ) ; response = run_cancel_or_skip_warning ( job , primary , secondary , NULL , source_info -> num_files , source_info -> num_files - transfer_info -> num_files ) ; if ( response == 0 || response == GTK_RESPONSE_DELETE_EVENT ) { abort_job ( job ) ; } else if ( response == 1 ) { job -> skip_all_error = TRUE ; } else if ( response == 2 ) { } else { g_assert_not_reached ( ) ; } goto out ; } retry : error = NULL ; flags = G_FILE_COPY_NOFOLLOW_SYMLINKS ; if ( overwrite ) { flags |= G_FILE_COPY_OVERWRITE ; } if ( readonly_source_fs ) { flags |= G_FILE_COPY_TARGET_DEFAULT_PERMS ; } pdata . job = copy_job ; pdata . last_size = 0 ; pdata . source_info = source_info ; pdata . transfer_info = transfer_info ; if ( copy_job -> is_move ) { res = g_file_move ( src , dest , flags , job -> cancellable , copy_file_progress_callback , & pdata , & error ) ; } else { res = g_file_copy ( src , dest , flags , job -> cancellable , copy_file_progress_callback , & pdata , & error ) ; } if ( res ) { GFile * real ; real = map_possibly_volatile_file_to_real ( dest , job -> cancellable , & error ) ; if ( real == NULL ) { res = FALSE ; } else { g_object_unref ( dest ) ; dest = real ; } } if ( res ) { transfer_info -> num_files ++ ; report_copy_progress ( copy_job , source_info , transfer_info ) ; if ( debuting_files ) { dest_uri = g_file_get_uri ( dest ) ; if ( position ) { nautilus_file_changes_queue_schedule_position_set ( dest , * position , job -> screen_num ) ; } else if ( eel_uri_is_desktop ( dest_uri ) ) { nautilus_file_changes_queue_schedule_position_remove ( dest ) ; } g_hash_table_replace ( debuting_files , g_object_ref ( dest ) , GINT_TO_POINTER ( TRUE ) ) ; } if ( copy_job -> is_move ) { nautilus_file_changes_queue_file_moved ( src , dest ) ; } else { nautilus_file_changes_queue_file_added ( dest ) ; } if ( copy_job -> desktop_location != NULL && g_file_equal ( copy_job -> desktop_location , dest_dir ) && is_trusted_desktop_file ( src , job -> cancellable ) ) { <S2SV_StartBug> mark_desktop_file_trusted ( job , <S2SV_EndBug> job -> cancellable , dest , FALSE ) ; } if ( job -> undo_info != NULL ) { nautilus_file_undo_info_ext_add_origin_target_pair ( NAUTILUS_FILE_UNDO_INFO_EXT ( job -> undo_info ) , src , dest ) ; } g_object_unref ( dest ) ; return ; } if ( ! handled_invalid_filename && IS_IO_ERROR ( error , INVALID_FILENAME ) ) { handled_invalid_filename = TRUE ; g_assert ( * dest_fs_type == NULL ) ; * dest_fs_type = query_fs_type ( dest_dir , job -> cancellable ) ; if ( unique_names ) { new_dest = get_unique_target_file ( src , dest_dir , same_fs , * dest_fs_type , unique_name_nr ) ; } else { new_dest = get_target_file ( src , dest_dir , * dest_fs_type , same_fs ) ; } if ( ! g_file_equal ( dest , new_dest ) ) { g_object_unref ( dest ) ; dest = new_dest ; g_error_free ( error ) ; goto retry ; } else { g_object_unref ( new_dest ) ; } } if ( ! overwrite && IS_IO_ERROR ( error , EXISTS ) ) { gboolean is_merge ; FileConflictResponse * response ; g_error_free ( error ) ; if ( unique_names ) { g_object_unref ( dest ) ; dest = get_unique_target_file ( src , dest_dir , same_fs , * dest_fs_type , unique_name_nr ++ ) ; goto retry ; } is_merge = FALSE ; if ( is_dir ( dest ) && is_dir ( src ) ) { is_merge = TRUE ; } if ( ( is_merge && job -> merge_all ) || ( ! is_merge && job -> replace_all ) ) { overwrite = TRUE ; goto retry ; } if ( job -> skip_all_conflict ) { goto out ; } response = handle_copy_move_conflict ( job , src , dest , dest_dir ) ; if ( response -> id == GTK_RESPONSE_CANCEL || response -> id == GTK_RESPONSE_DELETE_EVENT ) { file_conflict_response_free ( response ) ; abort_job ( job ) ; } else if ( response -> id == CONFLICT_RESPONSE_SKIP ) { if ( response -> apply_to_all ) { job -> skip_all_conflict = TRUE ; } file_conflict_response_free ( response ) ; } else if ( response -> id == CONFLICT_RESPONSE_REPLACE ) { if ( response -> apply_to_all ) { if ( is_merge ) { job -> merge_all = TRUE ; } else { job -> replace_all = TRUE ; } } overwrite = TRUE ; file_conflict_response_free ( response ) ; goto retry ; } else if ( response -> id == CONFLICT_RESPONSE_RENAME ) { g_object_unref ( dest ) ; dest = get_target_file_for_display_name ( dest_dir , response -> new_name ) ; file_conflict_response_free ( response ) ; goto retry ; } else { g_assert_not_reached ( ) ; } } else if ( overwrite && IS_IO_ERROR ( error , IS_DIRECTORY ) ) { gboolean existing_file_deleted ; DeleteExistingFileData data ; g_error_free ( error ) ; data . job = job ; data . source = src ; existing_file_deleted = delete_file_recursively ( dest , job -> cancellable , existing_file_removed_callback , & data ) ; if ( existing_file_deleted ) { goto retry ; } } else if ( IS_IO_ERROR ( error , WOULD_RECURSE ) || IS_IO_ERROR ( error , WOULD_MERGE ) ) { is_merge = error -> code == G_IO_ERROR_WOULD_MERGE ; would_recurse = error -> code == G_IO_ERROR_WOULD_RECURSE ; g_error_free ( error ) ; if ( overwrite && would_recurse ) { error = NULL ; if ( ! g_file_delete ( dest , job -> cancellable , & error ) && ! IS_IO_ERROR ( error , NOT_FOUND ) ) { if ( job -> skip_all_error ) { g_error_free ( error ) ; goto out ; } if ( copy_job -> is_move ) { primary = f ( _ ( \"Error<S2SV_blank>while<S2SV_blank>moving<S2SV_blank>%B.\" ) , src ) ; } else { primary = f ( _ ( \"Error<S2SV_blank>while<S2SV_blank>copying<S2SV_blank>%B.\" ) , src ) ; } secondary = f ( _ ( \"Could<S2SV_blank>not<S2SV_blank>remove<S2SV_blank>the<S2SV_blank>already<S2SV_blank>existing<S2SV_blank>file<S2SV_blank>with<S2SV_blank>the<S2SV_blank>same<S2SV_blank>name<S2SV_blank>in<S2SV_blank>%F.\" ) , dest_dir ) ; details = error -> message ; response = run_warning ( job , primary , secondary , details , TRUE , CANCEL , SKIP_ALL , SKIP , NULL ) ; g_error_free ( error ) ; if ( response == 0 || response == GTK_RESPONSE_DELETE_EVENT ) { abort_job ( job ) ; } else if ( response == 1 ) { job -> skip_all_error = TRUE ; } else if ( response == 2 ) { } else { g_assert_not_reached ( ) ; } goto out ; } if ( error ) { g_error_free ( error ) ; error = NULL ; } nautilus_file_changes_queue_file_removed ( dest ) ; } if ( is_merge ) { same_fs = FALSE ; } if ( ! copy_move_directory ( copy_job , src , & dest , same_fs , would_recurse , dest_fs_type , source_info , transfer_info , debuting_files , skipped_file , readonly_source_fs ) ) { g_assert ( * dest_fs_type != NULL ) ; handled_invalid_filename = TRUE ; goto retry ; } g_object_unref ( dest ) ; return ; } else if ( IS_IO_ERROR ( error , CANCELLED ) ) { g_error_free ( error ) ; } else { if ( job -> skip_all_error ) { g_error_free ( error ) ; goto out ; } primary = f ( _ ( \"Error<S2SV_blank>while<S2SV_blank>copying<S2SV_blank>%B.\" ) , src ) ; secondary = f ( _ ( \"There<S2SV_blank>was<S2SV_blank>an<S2SV_blank>error<S2SV_blank>copying<S2SV_blank>the<S2SV_blank>file<S2SV_blank>into<S2SV_blank>%F.\" ) , dest_dir ) ; details = error -> message ; response = run_cancel_or_skip_warning ( job , primary , secondary , details , source_info -> num_files , source_info -> num_files - transfer_info -> num_files ) ; g_error_free ( error ) ; if ( response == 0 || response == GTK_RESPONSE_DELETE_EVENT ) { abort_job ( job ) ; } else if ( response == 1 ) { job -> skip_all_error = TRUE ; } else if ( response == 2 ) { } else { g_assert_not_reached ( ) ; } } out : * skipped_file = TRUE ; g_object_unref ( dest ) ; }\n","target":"<S2SV_ModStart> ) ) { mark_desktop_file_executable <S2SV_ModEnd> ( job ,\n","project_and_commit_id":"GNOME@nautilus/1630f53481f445ada0a455e9979236d31a8d3bb0","cve_id":"CVE-2017-14604","original_address":"https://github.com/GNOME/nautilus/commit/1630f53481f445ada0a455e9979236d31a8d3bb0","time":"2017-09-20T08:29Z"},
	{"Unnamed: 0":1373,"cwe_id":"CWE-476","source":"CWE-476 static int i8042_start ( struct serio * serio ) { struct i8042_port * port = serio -> port_data ; <S2SV_StartBug> port -> exists = true ; <S2SV_EndBug> <S2SV_StartBug> mb ( ) ; <S2SV_EndBug> return 0 ; }\n","target":"<S2SV_ModStart> -> port_data ; spin_lock_irq ( & i8042_lock ) ; <S2SV_ModStart> = true ; spin_unlock_irq ( & i8042_lock <S2SV_ModEnd> ) ; return\n","project_and_commit_id":"torvalds@linux/340d394a789518018f834ff70f7534fc463d3226","cve_id":"CVE-2017-18079","original_address":"https://github.com/torvalds/linux/commit/340d394a789518018f834ff70f7534fc463d3226","time":"2018-01-29T05:29Z"},
	{"Unnamed: 0":114,"cwe_id":"CWE-416","source":"CWE-416 static void host_callback ( void * arg , int status , int timeouts , unsigned char * abuf , int alen ) { struct host_query * hquery = ( struct host_query * ) arg ; int addinfostatus = ARES_SUCCESS ; hquery -> timeouts += timeouts ; hquery -> remaining -- ; if ( status == ARES_SUCCESS ) { addinfostatus = ares__parse_into_addrinfo ( abuf , alen , hquery -> ai ) ; } else if ( status == ARES_EDESTRUCTION ) { end_hquery ( hquery , status ) ; <S2SV_StartBug> } <S2SV_EndBug> if ( ! hquery -> remaining ) { if ( addinfostatus != ARES_SUCCESS ) { end_hquery ( hquery , addinfostatus ) ; } else if ( hquery -> ai -> nodes ) { end_hquery ( hquery , ARES_SUCCESS ) ; } else if ( status == ARES_ENOTFOUND ) { next_lookup ( hquery , status ) ; } else { end_hquery ( hquery , status ) ; } } }\n","target":"<S2SV_ModStart> status ) ; return ;\n","project_and_commit_id":"c-ares@c-ares/1cc7e83c3bdfaafbc5919c95025592d8de3a170e","cve_id":"CVE-2020-14354","original_address":"https://github.com/c-ares/c-ares/commit/1cc7e83c3bdfaafbc5919c95025592d8de3a170e","time":"2021-05-13T14:15Z"},
	{"Unnamed: 0":6291,"cwe_id":"CWE-119","source":"CWE-119 static int privsep_preauth ( Authctxt * authctxt ) { int status , r ; pid_t pid ; struct ssh_sandbox * box = NULL ; pmonitor = monitor_init ( ) ; pmonitor -> m_pkex = & active_state -> kex ; if ( use_privsep == PRIVSEP_ON ) box = ssh_sandbox_init ( ) ; pid = fork ( ) ; if ( pid == - 1 ) { fatal ( \"fork<S2SV_blank>of<S2SV_blank>unprivileged<S2SV_blank>child<S2SV_blank>failed\" ) ; } else if ( pid != 0 ) { debug2 ( \"Network<S2SV_blank>child<S2SV_blank>is<S2SV_blank>on<S2SV_blank>pid<S2SV_blank>%ld\" , ( long ) pid ) ; pmonitor -> m_pid = pid ; if ( have_agent ) { r = ssh_get_authentication_socket ( & auth_sock ) ; if ( r != 0 ) { error ( \"Could<S2SV_blank>not<S2SV_blank>get<S2SV_blank>agent<S2SV_blank>socket:<S2SV_blank>%s\" , ssh_err ( r ) ) ; have_agent = 0 ; } } if ( box != NULL ) ssh_sandbox_parent_preauth ( box , pid ) ; monitor_child_preauth ( authctxt , pmonitor ) ; <S2SV_StartBug> monitor_sync ( pmonitor ) ; <S2SV_EndBug> while ( waitpid ( pid , & status , 0 ) < 0 ) { if ( errno == EINTR ) continue ; pmonitor -> m_pid = - 1 ; fatal ( \"%s:<S2SV_blank>waitpid:<S2SV_blank>%s\" , __func__ , strerror ( errno ) ) ; } privsep_is_preauth = 0 ; pmonitor -> m_pid = - 1 ; if ( WIFEXITED ( status ) ) { if ( WEXITSTATUS ( status ) != 0 ) fatal ( \"%s:<S2SV_blank>preauth<S2SV_blank>child<S2SV_blank>exited<S2SV_blank>with<S2SV_blank>status<S2SV_blank>%d\" , __func__ , WEXITSTATUS ( status ) ) ; } else if ( WIFSIGNALED ( status ) ) fatal ( \"%s:<S2SV_blank>preauth<S2SV_blank>child<S2SV_blank>terminated<S2SV_blank>by<S2SV_blank>signal<S2SV_blank>%d\" , __func__ , WTERMSIG ( status ) ) ; if ( box != NULL ) ssh_sandbox_parent_finish ( box ) ; return 1 ; } else { close ( pmonitor -> m_sendfd ) ; close ( pmonitor -> m_log_recvfd ) ; set_log_handler ( mm_log_handler , pmonitor ) ; privsep_preauth_child ( ) ; setproctitle ( \"%s\" , \"[net]\" ) ; if ( box != NULL ) ssh_sandbox_child ( box ) ; return 0 ; } }\n","target":"<S2SV_ModStart> pmonitor ) ; <S2SV_ModEnd> while ( waitpid\n","project_and_commit_id":"openbsd@src/3095060f479b86288e31c79ecbc5131a66bcd2f9","cve_id":"CVE-2016-10012","original_address":"https://github.com/openbsd/src/commit/3095060f479b86288e31c79ecbc5131a66bcd2f9","time":"2017-01-05T02:59Z"},
	{"Unnamed: 0":4970,"cwe_id":"CWE-20","source":"CWE-20 bool_t enc28j60IrqHandler ( NetInterface * interface ) { bool_t flag ; uint8_t status ; flag = FALSE ; <S2SV_StartBug> enc28j60ClearBit ( interface , ENC28J60_REG_EIE , EIE_INTIE ) ; <S2SV_EndBug> <S2SV_StartBug> status = enc28j60ReadReg ( interface , ENC28J60_REG_EIR ) ; <S2SV_EndBug> <S2SV_StartBug> if ( ( status & EIR_LINKIF ) != 0 ) <S2SV_EndBug> { <S2SV_StartBug> enc28j60ClearBit ( interface , ENC28J60_REG_EIE , EIE_LINKIE ) ; <S2SV_EndBug> interface -> nicEvent = TRUE ; flag |= osSetEventFromIsr ( & netEvent ) ; } <S2SV_StartBug> if ( ( status & EIR_PKTIF ) != 0 ) <S2SV_EndBug> { <S2SV_StartBug> enc28j60ClearBit ( interface , ENC28J60_REG_EIE , EIE_PKTIE ) ; <S2SV_EndBug> interface -> nicEvent = TRUE ; flag |= osSetEventFromIsr ( & netEvent ) ; } <S2SV_StartBug> if ( ( status & ( EIR_TXIF | EIE_TXERIE ) ) != 0 ) <S2SV_EndBug> { <S2SV_StartBug> enc28j60ClearBit ( interface , ENC28J60_REG_EIR , EIR_TXIF | EIE_TXERIE ) ; <S2SV_EndBug> flag |= osSetEventFromIsr ( & interface -> nicTxEvent ) ; } <S2SV_StartBug> enc28j60SetBit ( interface , ENC28J60_REG_EIE , EIE_INTIE ) ; <S2SV_EndBug> return flag ; }\n","target":"<S2SV_ModStart> ( interface , ENC28J60_EIE , ENC28J60_EIE_INTIE <S2SV_ModEnd> ) ; status <S2SV_ModStart> ( interface , ENC28J60_EIR <S2SV_ModEnd> ) ; if <S2SV_ModStart> ( status & ENC28J60_EIR_LINKIF <S2SV_ModEnd> ) != 0 <S2SV_ModStart> ( interface , ENC28J60_EIE , ENC28J60_EIE_LINKIE <S2SV_ModEnd> ) ; interface <S2SV_ModStart> } if ( enc28j60ReadReg ( interface , ENC28J60_EPKTCNT <S2SV_ModEnd> ) != 0 <S2SV_ModStart> ( interface , ENC28J60_EIE , ENC28J60_EIE_PKTIE <S2SV_ModEnd> ) ; interface <S2SV_ModStart> status & ( ENC28J60_EIR_TXIF | ENC28J60_EIE_TXERIE <S2SV_ModEnd> ) ) != <S2SV_ModStart> ( interface , ENC28J60_EIR , ENC28J60_EIR_TXIF | ENC28J60_EIE_TXERIE <S2SV_ModEnd> ) ; flag <S2SV_ModStart> ( interface , ENC28J60_EIE , ENC28J60_EIE_INTIE <S2SV_ModEnd> ) ; return\n","project_and_commit_id":"Oryx-Embedded@CycloneTCP/de5336016edbe1e90327d0ed1cba5c4e49114366","cve_id":"CVE-2021-26788","original_address":"https://github.com/Oryx-Embedded/CycloneTCP/commit/de5336016edbe1e90327d0ed1cba5c4e49114366","time":"2021-03-08T13:15Z"},
	{"Unnamed: 0":2794,"cwe_id":"CWE-119","source":"CWE-119 static int filter_frame ( AVFilterLink * inlink , AVFrame * inpic ) { KerndeintContext * kerndeint = inlink -> dst -> priv ; AVFilterLink * outlink = inlink -> dst -> outputs [ 0 ] ; AVFrame * outpic ; const uint8_t * prvp ; const uint8_t * prvpp ; const uint8_t * prvpn ; const uint8_t * prvppp ; const uint8_t * prvpnn ; const uint8_t * prvp4p ; const uint8_t * prvp4n ; const uint8_t * srcp ; const uint8_t * srcpp ; const uint8_t * srcpn ; const uint8_t * srcppp ; const uint8_t * srcpnn ; const uint8_t * srcp3p ; const uint8_t * srcp3n ; const uint8_t * srcp4p ; const uint8_t * srcp4n ; uint8_t * dstp , * dstp_saved ; const uint8_t * srcp_saved ; int src_linesize , psrc_linesize , dst_linesize , bwidth ; int x , y , plane , val , hi , lo , g , h , n = kerndeint -> frame ++ ; double valf ; const int thresh = kerndeint -> thresh ; const int order = kerndeint -> order ; const int map = kerndeint -> map ; const int sharp = kerndeint -> sharp ; const int twoway = kerndeint -> twoway ; const int is_packed_rgb = kerndeint -> is_packed_rgb ; outpic = ff_get_video_buffer ( outlink , outlink -> w , outlink -> h ) ; if ( ! outpic ) { av_frame_free ( & inpic ) ; return AVERROR ( ENOMEM ) ; } av_frame_copy_props ( outpic , inpic ) ; outpic -> interlaced_frame = 0 ; <S2SV_StartBug> for ( plane = 0 ; inpic -> data [ plane ] && plane < 4 ; plane ++ ) { <S2SV_EndBug> h = plane == 0 ? inlink -> h : FF_CEIL_RSHIFT ( inlink -> h , kerndeint -> vsub ) ; bwidth = kerndeint -> tmp_bwidth [ plane ] ; srcp = srcp_saved = inpic -> data [ plane ] ; src_linesize = inpic -> linesize [ plane ] ; psrc_linesize = kerndeint -> tmp_linesize [ plane ] ; dstp = dstp_saved = outpic -> data [ plane ] ; dst_linesize = outpic -> linesize [ plane ] ; srcp = srcp_saved + ( 1 - order ) * src_linesize ; dstp = dstp_saved + ( 1 - order ) * dst_linesize ; for ( y = 0 ; y < h ; y += 2 ) { memcpy ( dstp , srcp , bwidth ) ; srcp += 2 * src_linesize ; dstp += 2 * dst_linesize ; } memcpy ( dstp_saved + order * dst_linesize , srcp_saved + ( 1 - order ) * src_linesize , bwidth ) ; memcpy ( dstp_saved + ( 2 + order ) * dst_linesize , srcp_saved + ( 3 - order ) * src_linesize , bwidth ) ; memcpy ( dstp_saved + ( h - 2 + order ) * dst_linesize , srcp_saved + ( h - 1 - order ) * src_linesize , bwidth ) ; memcpy ( dstp_saved + ( h - 4 + order ) * dst_linesize , srcp_saved + ( h - 3 - order ) * src_linesize , bwidth ) ; prvp = kerndeint -> tmp_data [ plane ] + 5 * psrc_linesize - ( 1 - order ) * psrc_linesize ; prvpp = prvp - psrc_linesize ; prvppp = prvp - 2 * psrc_linesize ; prvp4p = prvp - 4 * psrc_linesize ; prvpn = prvp + psrc_linesize ; prvpnn = prvp + 2 * psrc_linesize ; prvp4n = prvp + 4 * psrc_linesize ; srcp = srcp_saved + 5 * src_linesize - ( 1 - order ) * src_linesize ; srcpp = srcp - src_linesize ; srcppp = srcp - 2 * src_linesize ; srcp3p = srcp - 3 * src_linesize ; srcp4p = srcp - 4 * src_linesize ; srcpn = srcp + src_linesize ; srcpnn = srcp + 2 * src_linesize ; srcp3n = srcp + 3 * src_linesize ; srcp4n = srcp + 4 * src_linesize ; dstp = dstp_saved + 5 * dst_linesize - ( 1 - order ) * dst_linesize ; for ( y = 5 - ( 1 - order ) ; y <= h - 5 - ( 1 - order ) ; y += 2 ) { for ( x = 0 ; x < bwidth ; x ++ ) { if ( thresh == 0 || n == 0 || ( abs ( ( int ) prvp [ x ] - ( int ) srcp [ x ] ) > thresh ) || ( abs ( ( int ) prvpp [ x ] - ( int ) srcpp [ x ] ) > thresh ) || ( abs ( ( int ) prvpn [ x ] - ( int ) srcpn [ x ] ) > thresh ) ) { if ( map ) { g = x & ~ 3 ; if ( is_packed_rgb ) { AV_WB32 ( dstp + g , 0xffffffff ) ; x = g + 3 ; } else if ( inlink -> format == AV_PIX_FMT_YUYV422 ) { AV_WB32 ( dstp + g , 0xeb80eb80 ) ; x = g + 3 ; } else { dstp [ x ] = plane == 0 ? 235 : 128 ; } } else { if ( is_packed_rgb ) { hi = 255 ; lo = 0 ; } else if ( inlink -> format == AV_PIX_FMT_YUYV422 ) { hi = x & 1 ? 240 : 235 ; lo = 16 ; } else { hi = plane == 0 ? 235 : 240 ; lo = 16 ; } if ( sharp ) { if ( twoway ) { valf = + 0.526 * ( ( int ) srcpp [ x ] + ( int ) srcpn [ x ] ) + 0.170 * ( ( int ) srcp [ x ] + ( int ) prvp [ x ] ) - 0.116 * ( ( int ) srcppp [ x ] + ( int ) srcpnn [ x ] + ( int ) prvppp [ x ] + ( int ) prvpnn [ x ] ) - 0.026 * ( ( int ) srcp3p [ x ] + ( int ) srcp3n [ x ] ) + 0.031 * ( ( int ) srcp4p [ x ] + ( int ) srcp4n [ x ] + ( int ) prvp4p [ x ] + ( int ) prvp4n [ x ] ) ; } else { valf = + 0.526 * ( ( int ) srcpp [ x ] + ( int ) srcpn [ x ] ) + 0.170 * ( ( int ) prvp [ x ] ) - 0.116 * ( ( int ) prvppp [ x ] + ( int ) prvpnn [ x ] ) - 0.026 * ( ( int ) srcp3p [ x ] + ( int ) srcp3n [ x ] ) + 0.031 * ( ( int ) prvp4p [ x ] + ( int ) prvp4p [ x ] ) ; } dstp [ x ] = av_clip ( valf , lo , hi ) ; } else { if ( twoway ) { val = ( 8 * ( ( int ) srcpp [ x ] + ( int ) srcpn [ x ] ) + 2 * ( ( int ) srcp [ x ] + ( int ) prvp [ x ] ) - ( int ) ( srcppp [ x ] ) - ( int ) ( srcpnn [ x ] ) - ( int ) ( prvppp [ x ] ) - ( int ) ( prvpnn [ x ] ) ) >> 4 ; } else { val = ( 8 * ( ( int ) srcpp [ x ] + ( int ) srcpn [ x ] ) + 2 * ( ( int ) prvp [ x ] ) - ( int ) ( prvppp [ x ] ) - ( int ) ( prvpnn [ x ] ) ) >> 4 ; } dstp [ x ] = av_clip ( val , lo , hi ) ; } } } else { dstp [ x ] = srcp [ x ] ; } } prvp += 2 * psrc_linesize ; prvpp += 2 * psrc_linesize ; prvppp += 2 * psrc_linesize ; prvpn += 2 * psrc_linesize ; prvpnn += 2 * psrc_linesize ; prvp4p += 2 * psrc_linesize ; prvp4n += 2 * psrc_linesize ; srcp += 2 * src_linesize ; srcpp += 2 * src_linesize ; srcppp += 2 * src_linesize ; srcp3p += 2 * src_linesize ; srcp4p += 2 * src_linesize ; srcpn += 2 * src_linesize ; srcpnn += 2 * src_linesize ; srcp3n += 2 * src_linesize ; srcp4n += 2 * src_linesize ; dstp += 2 * dst_linesize ; } srcp = inpic -> data [ plane ] ; dstp = kerndeint -> tmp_data [ plane ] ; av_image_copy_plane ( dstp , psrc_linesize , srcp , src_linesize , bwidth , h ) ; } av_frame_free ( & inpic ) ; return ff_filter_frame ( outlink , outpic ) ; }\n","target":"<S2SV_ModStart> = 0 ; <S2SV_ModEnd> plane < 4 <S2SV_ModStart> plane < 4 && inpic -> data [ plane ] && inpic -> linesize [ plane ]\n","project_and_commit_id":"FFmpeg@FFmpeg/e43a0a232dbf6d3c161823c2e07c52e76227a1bc","cve_id":"CVE-2013-4263","original_address":"https://github.com/FFmpeg/FFmpeg/commit/e43a0a232dbf6d3c161823c2e07c52e76227a1bc","time":"2013-11-23T17:55Z"},
	{"Unnamed: 0":6519,"cwe_id":"CWE-119","source":"CWE-119 static int ttusbdecfe_dvbs_diseqc_send_master_cmd ( struct dvb_frontend * fe , struct dvb_diseqc_master_cmd * cmd ) { struct ttusbdecfe_state * state = ( struct ttusbdecfe_state * ) fe -> demodulator_priv ; u8 b [ ] = { 0x00 , 0xff , 0x00 , 0x00 , 0x00 , 0x00 , 0x00 , 0x00 , 0x00 , 0x00 } ; <S2SV_StartBug> memcpy ( & b [ 4 ] , cmd -> msg , cmd -> msg_len ) ; <S2SV_EndBug> state -> config -> send_command ( fe , 0x72 , sizeof ( b ) - ( 6 - cmd -> msg_len ) , b , NULL , NULL ) ; return 0 ; }\n","target":"<S2SV_ModStart> 0x00 } ; if ( cmd -> msg_len > sizeof ( b ) - 4 ) return - EINVAL ;\n","project_and_commit_id":"torvalds@linux/f2e323ec96077642d397bb1c355def536d489d16","cve_id":"CVE-2014-8884","original_address":"https://github.com/torvalds/linux/commit/f2e323ec96077642d397bb1c355def536d489d16","time":"2014-11-30T01:59Z"},
	{"Unnamed: 0":3747,"cwe_id":"CWE-125","source":"CWE-125 static int string_scan_range ( RList * list , RBinFile * bf , int min , const ut64 from , const ut64 to , int type ) { ut8 tmp [ R_STRING_SCAN_BUFFER_SIZE ] ; ut64 str_start , needle = from ; int count = 0 , i , rc , runes ; int str_type = R_STRING_TYPE_DETECT ; if ( type == - 1 ) { type = R_STRING_TYPE_DETECT ; } if ( from >= to ) { eprintf ( \"Invalid<S2SV_blank>range<S2SV_blank>to<S2SV_blank>find<S2SV_blank>strings<S2SV_blank>0x%llx<S2SV_blank>..<S2SV_blank>0x%llx\\\\n\" , from , to ) ; return - 1 ; } <S2SV_StartBug> ut8 * buf = calloc ( to - from , 1 ) ; <S2SV_EndBug> if ( ! buf || ! min ) { return - 1 ; } <S2SV_StartBug> r_buf_read_at ( bf -> buf , from , buf , to - from ) ; <S2SV_EndBug> while ( needle < to ) { rc = r_utf8_decode ( buf + needle - from , to - needle , NULL ) ; if ( ! rc ) { needle ++ ; continue ; } if ( type == R_STRING_TYPE_DETECT ) { char * w = ( char * ) buf + needle + rc - from ; <S2SV_StartBug> if ( ( to - needle ) > 5 ) { <S2SV_EndBug> <S2SV_StartBug> bool is_wide32 = needle + rc + 2 < to && ! w [ 0 ] && ! w [ 1 ] && ! w [ 2 ] && w [ 3 ] && ! w [ 4 ] ; <S2SV_EndBug> if ( is_wide32 ) { str_type = R_STRING_TYPE_WIDE32 ; } else { bool is_wide = needle + rc + 2 < to && ! w [ 0 ] && w [ 1 ] && ! w [ 2 ] ; str_type = is_wide ? R_STRING_TYPE_WIDE : R_STRING_TYPE_ASCII ; } } else { str_type = R_STRING_TYPE_ASCII ; } } else { str_type = type ; } runes = 0 ; str_start = needle ; for ( rc = i = 0 ; i < sizeof ( tmp ) - 3 && needle < to ; i += rc ) { RRune r = { 0 } ; if ( str_type == R_STRING_TYPE_WIDE32 ) { rc = r_utf32le_decode ( buf + needle - from , to - needle , & r ) ; if ( rc ) { rc = 4 ; } } else if ( str_type == R_STRING_TYPE_WIDE ) { rc = r_utf16le_decode ( buf + needle - from , to - needle , & r ) ; if ( rc == 1 ) { rc = 2 ; } } else { rc = r_utf8_decode ( buf + needle - from , to - needle , & r ) ; if ( rc > 1 ) { str_type = R_STRING_TYPE_UTF8 ; } } if ( ! rc ) { needle ++ ; break ; } needle += rc ; if ( r_isprint ( r ) && r != '\\\\\\\\' ) { if ( str_type == R_STRING_TYPE_WIDE32 ) { if ( r == 0xff ) { r = 0 ; } } rc = r_utf8_encode ( & tmp [ i ] , r ) ; runes ++ ; } else if ( r && r < 0x100 && strchr ( \"\\\\b\\\\v\\\\f\\\\n\\\\r\\\\t\\\\a\\\\033\\\\\\\\\" , ( char ) r ) ) { if ( ( i + 32 ) < sizeof ( tmp ) && r < 93 ) { tmp [ i + 0 ] = '\\\\\\\\' ; tmp [ i + 1 ] = \"<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>abtnvfr<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>e<S2SV_blank><S2SV_blank>\" \"<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>\" \"<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>\" \"<S2SV_blank><S2SV_blank>\\\\\\\\\" [ r ] ; } else { break ; } rc = 2 ; runes ++ ; } else { break ; } } tmp [ i ++ ] = '\\\\0' ; if ( runes >= min ) { if ( str_type == R_STRING_TYPE_ASCII ) { int j ; for ( j = 0 ; j < i ; j ++ ) { char ch = tmp [ j ] ; if ( ch != '\\\\n' && ch != '\\\\r' && ch != '\\\\t' ) { if ( ! IS_PRINTABLE ( tmp [ j ] ) ) { continue ; } } } } RBinString * bs = R_NEW0 ( RBinString ) ; if ( ! bs ) { break ; } bs -> type = str_type ; bs -> length = runes ; bs -> size = needle - str_start ; bs -> ordinal = count ++ ; switch ( str_type ) { case R_STRING_TYPE_WIDE : if ( str_start - from > 1 ) { const ut8 * p = buf + str_start - 2 - from ; if ( p [ 0 ] == 0xff && p [ 1 ] == 0xfe ) { str_start -= 2 ; } } break ; case R_STRING_TYPE_WIDE32 : if ( str_start - from > 3 ) { const ut8 * p = buf + str_start - 4 - from ; if ( p [ 0 ] == 0xff && p [ 1 ] == 0xfe ) { str_start -= 4 ; } } break ; } bs -> paddr = bs -> vaddr = str_start ; bs -> string = r_str_ndup ( ( const char * ) tmp , i ) ; if ( list ) { r_list_append ( list , bs ) ; } else { print_string ( bs , bf ) ; r_bin_string_free ( bs ) ; } } } free ( buf ) ; return count ; }\n","target":"<S2SV_ModStart> 1 ; } int len = to - from ; <S2SV_ModStart> = calloc ( len <S2SV_ModEnd> , 1 ) <S2SV_ModStart> , buf , len <S2SV_ModEnd> ) ; while <S2SV_ModStart> ) > 5 + rc <S2SV_ModStart> bool is_wide32 = ( <S2SV_ModStart> 2 < to ) && ( <S2SV_ModEnd> ! w [ <S2SV_ModStart> [ 4 ] )\n","project_and_commit_id":"radare@radare2/3fcf41ed96ffa25b38029449520c8d0a198745f3","cve_id":"CVE-2018-11381","original_address":"https://github.com/radare/radare2/commit/3fcf41ed96ffa25b38029449520c8d0a198745f3","time":"2018-05-22T19:29Z"},
	{"Unnamed: 0":3044,"cwe_id":"CWE-125","source":"CWE-125 static void handle_mlppp ( netdissect_options * ndo , const u_char * p , int length ) { if ( ! ndo -> ndo_eflag ) ND_PRINT ( ( ndo , \"MLPPP,<S2SV_blank>\" ) ) ; <S2SV_StartBug> ND_PRINT ( ( ndo , \"seq<S2SV_blank>0x%03x,<S2SV_blank>Flags<S2SV_blank>[%s],<S2SV_blank>length<S2SV_blank>%u\" , <S2SV_EndBug> ( EXTRACT_16BITS ( p ) ) & 0x0fff , bittok2str ( ppp_ml_flag_values , \"none\" , * p & 0xc0 ) , length ) ) ; }\n","target":"<S2SV_ModStart> ) ) ; if ( length < 2 ) { ND_PRINT ( ( ndo , \"[|mlppp]\" ) ) ; return ; } if ( ! ND_TTEST_16BITS ( p ) ) { ND_PRINT ( ( ndo , \"[|mlppp]\" ) ) ; return ; }\n","project_and_commit_id":"the-tcpdump-group@tcpdump/7335163a6ef82d46ff18f3e6099a157747241629","cve_id":"CVE-2017-13038","original_address":"https://github.com/the-tcpdump-group/tcpdump/commit/7335163a6ef82d46ff18f3e6099a157747241629","time":"2017-09-14T06:29Z"},
	{"Unnamed: 0":4636,"cwe_id":"CWE-119","source":"CWE-119 static bool check_underflow ( const struct ip6t_entry * e ) { const struct xt_entry_target * t ; unsigned int verdict ; <S2SV_StartBug> if ( ! unconditional ( & e -> ipv6 ) ) <S2SV_EndBug> return false ; t = ip6t_get_target_c ( e ) ; if ( strcmp ( t -> u . user . name , XT_STANDARD_TARGET ) != 0 ) return false ; verdict = ( ( struct xt_standard_target * ) t ) -> verdict ; verdict = - verdict - 1 ; return verdict == NF_DROP || verdict == NF_ACCEPT ; }\n","target":"<S2SV_ModStart> ! unconditional ( e <S2SV_ModEnd> ) ) return\n","project_and_commit_id":"torvalds@linux/54d83fc74aa9ec72794373cb47432c5f7fb1a309","cve_id":"CVE-2016-3134","original_address":"https://github.com/torvalds/linux/commit/54d83fc74aa9ec72794373cb47432c5f7fb1a309","time":"2016-04-27T17:59Z"},
	{"Unnamed: 0":3329,"cwe_id":"CWE-190","source":"CWE-190 static int burl_normalize_2F_to_slash_fix ( buffer * b , int qs , int i ) { char * const s = b -> ptr ; const int blen = ( int ) buffer_string_length ( b ) ; const int used = qs < 0 ? blen : qs ; int j = i ; for ( ; i < used ; ++ i , ++ j ) { s [ j ] = s [ i ] ; if ( s [ i ] == '%' && s [ i + 1 ] == '2' && s [ i + 2 ] == 'F' ) { s [ j ] = '/' ; i += 2 ; } } if ( qs >= 0 ) { <S2SV_StartBug> memmove ( s + j , s + qs , blen - qs ) ; <S2SV_EndBug> <S2SV_StartBug> j += blen - qs ; <S2SV_EndBug> } buffer_string_set_length ( b , j ) ; return qs ; }\n","target":"<S2SV_ModStart> 0 ) { const int qslen = blen - qs ; <S2SV_ModStart> + qs , ( size_t ) qslen ) ; qs = j <S2SV_ModEnd> ; j += <S2SV_ModStart> ; j += qslen <S2SV_ModEnd> ; } buffer_string_set_length\n","project_and_commit_id":"lighttpd@lighttpd1.4/32120d5b8b3203fc21ccb9eafb0eaf824bb59354","cve_id":"CVE-2019-11072","original_address":"https://github.com/lighttpd/lighttpd1.4/commit/32120d5b8b3203fc21ccb9eafb0eaf824bb59354","time":"2019-04-10T22:29Z"},
	{"Unnamed: 0":5201,"cwe_id":"CWE-119","source":"CWE-119 int dtls1_read_bytes ( SSL * s , int type , unsigned char * buf , int len , int peek ) { int al , i , j , ret ; unsigned int n ; SSL3_RECORD * rr ; void ( * cb ) ( const SSL * ssl , int type2 , int val ) = NULL ; if ( s -> s3 -> rbuf . buf == NULL ) if ( ! ssl3_setup_buffers ( s ) ) return ( - 1 ) ; if ( ( type && ( type != SSL3_RT_APPLICATION_DATA ) && ( type != SSL3_RT_HANDSHAKE ) ) || ( peek && ( type != SSL3_RT_APPLICATION_DATA ) ) ) { SSLerr ( SSL_F_DTLS1_READ_BYTES , ERR_R_INTERNAL_ERROR ) ; return - 1 ; } if ( ( ret = have_handshake_fragment ( s , type , buf , len , peek ) ) ) return ret ; # ifndef OPENSSL_NO_SCTP if ( ( ! s -> in_handshake && SSL_in_init ( s ) ) || ( BIO_dgram_is_sctp ( SSL_get_rbio ( s ) ) && ( s -> state == DTLS1_SCTP_ST_SR_READ_SOCK || s -> state == DTLS1_SCTP_ST_CR_READ_SOCK ) && s -> s3 -> in_read_app_data != 2 ) ) # else if ( ! s -> in_handshake && SSL_in_init ( s ) ) # endif { i = s -> handshake_func ( s ) ; if ( i < 0 ) return ( i ) ; if ( i == 0 ) { SSLerr ( SSL_F_DTLS1_READ_BYTES , SSL_R_SSL_HANDSHAKE_FAILURE ) ; return ( - 1 ) ; } } start : s -> rwstate = SSL_NOTHING ; rr = & ( s -> s3 -> rrec ) ; if ( s -> state == SSL_ST_OK && rr -> length == 0 ) { pitem * item ; item = pqueue_pop ( s -> d1 -> buffered_app_data . q ) ; if ( item ) { # ifndef OPENSSL_NO_SCTP if ( BIO_dgram_is_sctp ( SSL_get_rbio ( s ) ) ) { DTLS1_RECORD_DATA * rdata = ( DTLS1_RECORD_DATA * ) item -> data ; BIO_ctrl ( SSL_get_rbio ( s ) , BIO_CTRL_DGRAM_SCTP_SET_RCVINFO , sizeof ( rdata -> recordinfo ) , & rdata -> recordinfo ) ; } # endif dtls1_copy_record ( s , item ) ; OPENSSL_free ( item -> data ) ; pitem_free ( item ) ; } } if ( dtls1_handle_timeout ( s ) > 0 ) goto start ; if ( ( rr -> length == 0 ) || ( s -> rstate == SSL_ST_READ_BODY ) ) { ret = dtls1_get_record ( s ) ; if ( ret <= 0 ) { ret = dtls1_read_failed ( s , ret ) ; if ( ret <= 0 ) return ( ret ) ; else goto start ; } } if ( s -> d1 -> listen && rr -> type != SSL3_RT_HANDSHAKE ) { rr -> length = 0 ; goto start ; } if ( s -> s3 -> change_cipher_spec && ( rr -> type != SSL3_RT_HANDSHAKE ) ) { <S2SV_StartBug> dtls1_buffer_record ( s , & ( s -> d1 -> buffered_app_data ) , rr -> seq_num ) ; <S2SV_EndBug> rr -> length = 0 ; goto start ; } if ( s -> shutdown & SSL_RECEIVED_SHUTDOWN ) { rr -> length = 0 ; s -> rwstate = SSL_NOTHING ; return ( 0 ) ; } if ( type == rr -> type ) { if ( SSL_in_init ( s ) && ( type == SSL3_RT_APPLICATION_DATA ) && ( s -> enc_read_ctx == NULL ) ) { al = SSL_AD_UNEXPECTED_MESSAGE ; SSLerr ( SSL_F_DTLS1_READ_BYTES , SSL_R_APP_DATA_IN_HANDSHAKE ) ; goto f_err ; } if ( len <= 0 ) return ( len ) ; if ( ( unsigned int ) len > rr -> length ) n = rr -> length ; else n = ( unsigned int ) len ; memcpy ( buf , & ( rr -> data [ rr -> off ] ) , n ) ; if ( ! peek ) { rr -> length -= n ; rr -> off += n ; if ( rr -> length == 0 ) { s -> rstate = SSL_ST_READ_HEADER ; rr -> off = 0 ; } } # ifndef OPENSSL_NO_SCTP if ( BIO_dgram_is_sctp ( SSL_get_rbio ( s ) ) && rr -> type == SSL3_RT_APPLICATION_DATA && ( s -> state == DTLS1_SCTP_ST_SR_READ_SOCK || s -> state == DTLS1_SCTP_ST_CR_READ_SOCK ) ) { s -> rwstate = SSL_READING ; BIO_clear_retry_flags ( SSL_get_rbio ( s ) ) ; BIO_set_retry_read ( SSL_get_rbio ( s ) ) ; } if ( BIO_dgram_is_sctp ( SSL_get_rbio ( s ) ) && s -> d1 -> shutdown_received && ! BIO_dgram_sctp_msg_waiting ( SSL_get_rbio ( s ) ) ) { s -> shutdown |= SSL_RECEIVED_SHUTDOWN ; return ( 0 ) ; } # endif return ( n ) ; } { unsigned int k , dest_maxlen = 0 ; unsigned char * dest = NULL ; unsigned int * dest_len = NULL ; if ( rr -> type == SSL3_RT_HANDSHAKE ) { dest_maxlen = sizeof s -> d1 -> handshake_fragment ; dest = s -> d1 -> handshake_fragment ; dest_len = & s -> d1 -> handshake_fragment_len ; } else if ( rr -> type == SSL3_RT_ALERT ) { dest_maxlen = sizeof ( s -> d1 -> alert_fragment ) ; dest = s -> d1 -> alert_fragment ; dest_len = & s -> d1 -> alert_fragment_len ; } # ifndef OPENSSL_NO_HEARTBEATS else if ( rr -> type == TLS1_RT_HEARTBEAT ) { dtls1_process_heartbeat ( s ) ; rr -> length = 0 ; s -> rwstate = SSL_READING ; BIO_clear_retry_flags ( SSL_get_rbio ( s ) ) ; BIO_set_retry_read ( SSL_get_rbio ( s ) ) ; return ( - 1 ) ; } # endif else if ( rr -> type != SSL3_RT_CHANGE_CIPHER_SPEC ) { if ( rr -> type == SSL3_RT_APPLICATION_DATA ) { BIO * bio ; s -> s3 -> in_read_app_data = 2 ; bio = SSL_get_rbio ( s ) ; s -> rwstate = SSL_READING ; BIO_clear_retry_flags ( bio ) ; BIO_set_retry_read ( bio ) ; return ( - 1 ) ; } al = SSL_AD_UNEXPECTED_MESSAGE ; SSLerr ( SSL_F_DTLS1_READ_BYTES , SSL_R_UNEXPECTED_RECORD ) ; goto f_err ; } if ( dest_maxlen > 0 ) { if ( rr -> length < dest_maxlen ) { # ifdef DTLS1_AD_MISSING_HANDSHAKE_MESSAGE FIX ME # endif s -> rstate = SSL_ST_READ_HEADER ; rr -> length = 0 ; goto start ; } for ( k = 0 ; k < dest_maxlen ; k ++ ) { dest [ k ] = rr -> data [ rr -> off ++ ] ; rr -> length -- ; } * dest_len = dest_maxlen ; } } if ( ( ! s -> server ) && ( s -> d1 -> handshake_fragment_len >= DTLS1_HM_HEADER_LENGTH ) && ( s -> d1 -> handshake_fragment [ 0 ] == SSL3_MT_HELLO_REQUEST ) && ( s -> session != NULL ) && ( s -> session -> cipher != NULL ) ) { s -> d1 -> handshake_fragment_len = 0 ; if ( ( s -> d1 -> handshake_fragment [ 1 ] != 0 ) || ( s -> d1 -> handshake_fragment [ 2 ] != 0 ) || ( s -> d1 -> handshake_fragment [ 3 ] != 0 ) ) { al = SSL_AD_DECODE_ERROR ; SSLerr ( SSL_F_DTLS1_READ_BYTES , SSL_R_BAD_HELLO_REQUEST ) ; goto err ; } if ( s -> msg_callback ) s -> msg_callback ( 0 , s -> version , SSL3_RT_HANDSHAKE , s -> d1 -> handshake_fragment , 4 , s , s -> msg_callback_arg ) ; if ( SSL_is_init_finished ( s ) && ! ( s -> s3 -> flags & SSL3_FLAGS_NO_RENEGOTIATE_CIPHERS ) && ! s -> s3 -> renegotiate ) { s -> d1 -> handshake_read_seq ++ ; s -> new_session = 1 ; ssl3_renegotiate ( s ) ; if ( ssl3_renegotiate_check ( s ) ) { i = s -> handshake_func ( s ) ; if ( i < 0 ) return ( i ) ; if ( i == 0 ) { SSLerr ( SSL_F_DTLS1_READ_BYTES , SSL_R_SSL_HANDSHAKE_FAILURE ) ; return ( - 1 ) ; } if ( ! ( s -> mode & SSL_MODE_AUTO_RETRY ) ) { if ( s -> s3 -> rbuf . left == 0 ) { BIO * bio ; s -> rwstate = SSL_READING ; bio = SSL_get_rbio ( s ) ; BIO_clear_retry_flags ( bio ) ; BIO_set_retry_read ( bio ) ; return ( - 1 ) ; } } } } goto start ; } if ( s -> d1 -> alert_fragment_len >= DTLS1_AL_HEADER_LENGTH ) { int alert_level = s -> d1 -> alert_fragment [ 0 ] ; int alert_descr = s -> d1 -> alert_fragment [ 1 ] ; s -> d1 -> alert_fragment_len = 0 ; if ( s -> msg_callback ) s -> msg_callback ( 0 , s -> version , SSL3_RT_ALERT , s -> d1 -> alert_fragment , 2 , s , s -> msg_callback_arg ) ; if ( s -> info_callback != NULL ) cb = s -> info_callback ; else if ( s -> ctx -> info_callback != NULL ) cb = s -> ctx -> info_callback ; if ( cb != NULL ) { j = ( alert_level << 8 ) | alert_descr ; cb ( s , SSL_CB_READ_ALERT , j ) ; } if ( alert_level == 1 ) { s -> s3 -> warn_alert = alert_descr ; if ( alert_descr == SSL_AD_CLOSE_NOTIFY ) { # ifndef OPENSSL_NO_SCTP if ( BIO_dgram_is_sctp ( SSL_get_rbio ( s ) ) && BIO_dgram_sctp_msg_waiting ( SSL_get_rbio ( s ) ) ) { s -> d1 -> shutdown_received = 1 ; s -> rwstate = SSL_READING ; BIO_clear_retry_flags ( SSL_get_rbio ( s ) ) ; BIO_set_retry_read ( SSL_get_rbio ( s ) ) ; return - 1 ; } # endif s -> shutdown |= SSL_RECEIVED_SHUTDOWN ; return ( 0 ) ; } # if 0 if ( alert_descr == DTLS1_AD_MISSING_HANDSHAKE_MESSAGE ) { unsigned short seq ; unsigned int frag_off ; unsigned char * p = & ( s -> d1 -> alert_fragment [ 2 ] ) ; n2s ( p , seq ) ; n2l3 ( p , frag_off ) ; dtls1_retransmit_message ( s , dtls1_get_queue_priority ( frag -> msg_header . seq , 0 ) , frag_off , & found ) ; if ( ! found && SSL_in_init ( s ) ) { ssl3_send_alert ( s , SSL3_AL_WARNING , DTLS1_AD_MISSING_HANDSHAKE_MESSAGE ) ; } } # endif } else if ( alert_level == 2 ) { char tmp [ 16 ] ; s -> rwstate = SSL_NOTHING ; s -> s3 -> fatal_alert = alert_descr ; SSLerr ( SSL_F_DTLS1_READ_BYTES , SSL_AD_REASON_OFFSET + alert_descr ) ; BIO_snprintf ( tmp , sizeof tmp , \"%d\" , alert_descr ) ; ERR_add_error_data ( 2 , \"SSL<S2SV_blank>alert<S2SV_blank>number<S2SV_blank>\" , tmp ) ; s -> shutdown |= SSL_RECEIVED_SHUTDOWN ; SSL_CTX_remove_session ( s -> ctx , s -> session ) ; return ( 0 ) ; } else { al = SSL_AD_ILLEGAL_PARAMETER ; SSLerr ( SSL_F_DTLS1_READ_BYTES , SSL_R_UNKNOWN_ALERT_TYPE ) ; goto f_err ; } goto start ; } if ( s -> shutdown & SSL_SENT_SHUTDOWN ) { s -> rwstate = SSL_NOTHING ; rr -> length = 0 ; return ( 0 ) ; } if ( rr -> type == SSL3_RT_CHANGE_CIPHER_SPEC ) { struct ccs_header_st ccs_hdr ; unsigned int ccs_hdr_len = DTLS1_CCS_HEADER_LENGTH ; dtls1_get_ccs_header ( rr -> data , & ccs_hdr ) ; if ( s -> version == DTLS1_BAD_VER ) ccs_hdr_len = 3 ; if ( ( rr -> length != ccs_hdr_len ) || ( rr -> off != 0 ) || ( rr -> data [ 0 ] != SSL3_MT_CCS ) ) { i = SSL_AD_ILLEGAL_PARAMETER ; SSLerr ( SSL_F_DTLS1_READ_BYTES , SSL_R_BAD_CHANGE_CIPHER_SPEC ) ; goto err ; } rr -> length = 0 ; if ( s -> msg_callback ) s -> msg_callback ( 0 , s -> version , SSL3_RT_CHANGE_CIPHER_SPEC , rr -> data , 1 , s , s -> msg_callback_arg ) ; if ( ! s -> d1 -> change_cipher_spec_ok ) { goto start ; } s -> d1 -> change_cipher_spec_ok = 0 ; s -> s3 -> change_cipher_spec = 1 ; if ( ! ssl3_do_change_cipher_spec ( s ) ) goto err ; dtls1_reset_seq_numbers ( s , SSL3_CC_READ ) ; if ( s -> version == DTLS1_BAD_VER ) s -> d1 -> handshake_read_seq ++ ; # ifndef OPENSSL_NO_SCTP BIO_ctrl ( SSL_get_wbio ( s ) , BIO_CTRL_DGRAM_SCTP_AUTH_CCS_RCVD , 1 , NULL ) ; # endif goto start ; } if ( ( s -> d1 -> handshake_fragment_len >= DTLS1_HM_HEADER_LENGTH ) && ! s -> in_handshake ) { struct hm_header_st msg_hdr ; dtls1_get_message_header ( rr -> data , & msg_hdr ) ; if ( rr -> epoch != s -> d1 -> r_epoch ) { rr -> length = 0 ; goto start ; } if ( msg_hdr . type == SSL3_MT_FINISHED ) { if ( dtls1_check_timeout_num ( s ) < 0 ) return - 1 ; dtls1_retransmit_buffered_messages ( s ) ; rr -> length = 0 ; goto start ; } if ( ( ( s -> state & SSL_ST_MASK ) == SSL_ST_OK ) && ! ( s -> s3 -> flags & SSL3_FLAGS_NO_RENEGOTIATE_CIPHERS ) ) { # if 0 s -> state = SSL_ST_BEFORE | ( s -> server ) ? SSL_ST_ACCEPT : SSL_ST_CONNECT ; # else s -> state = s -> server ? SSL_ST_ACCEPT : SSL_ST_CONNECT ; # endif s -> renegotiate = 1 ; s -> new_session = 1 ; } i = s -> handshake_func ( s ) ; if ( i < 0 ) return ( i ) ; if ( i == 0 ) { SSLerr ( SSL_F_DTLS1_READ_BYTES , SSL_R_SSL_HANDSHAKE_FAILURE ) ; return ( - 1 ) ; } if ( ! ( s -> mode & SSL_MODE_AUTO_RETRY ) ) { if ( s -> s3 -> rbuf . left == 0 ) { BIO * bio ; s -> rwstate = SSL_READING ; bio = SSL_get_rbio ( s ) ; BIO_clear_retry_flags ( bio ) ; BIO_set_retry_read ( bio ) ; return ( - 1 ) ; } } goto start ; } switch ( rr -> type ) { default : # ifndef OPENSSL_NO_TLS if ( s -> version == TLS1_VERSION ) { rr -> length = 0 ; goto start ; } # endif al = SSL_AD_UNEXPECTED_MESSAGE ; SSLerr ( SSL_F_DTLS1_READ_BYTES , SSL_R_UNEXPECTED_RECORD ) ; goto f_err ; case SSL3_RT_CHANGE_CIPHER_SPEC : case SSL3_RT_ALERT : case SSL3_RT_HANDSHAKE : al = SSL_AD_UNEXPECTED_MESSAGE ; SSLerr ( SSL_F_DTLS1_READ_BYTES , ERR_R_INTERNAL_ERROR ) ; goto f_err ; case SSL3_RT_APPLICATION_DATA : if ( s -> s3 -> in_read_app_data && ( s -> s3 -> total_renegotiations != 0 ) && ( ( ( s -> state & SSL_ST_CONNECT ) && ( s -> state >= SSL3_ST_CW_CLNT_HELLO_A ) && ( s -> state <= SSL3_ST_CR_SRVR_HELLO_A ) ) || ( ( s -> state & SSL_ST_ACCEPT ) && ( s -> state <= SSL3_ST_SW_HELLO_REQ_A ) && ( s -> state >= SSL3_ST_SR_CLNT_HELLO_A ) ) ) ) { s -> s3 -> in_read_app_data = 2 ; return ( - 1 ) ; } else { al = SSL_AD_UNEXPECTED_MESSAGE ; SSLerr ( SSL_F_DTLS1_READ_BYTES , SSL_R_UNEXPECTED_RECORD ) ; goto f_err ; } } f_err : ssl3_send_alert ( s , SSL3_AL_FATAL , al ) ; err : return ( - 1 ) ; }\n","target":"<S2SV_ModStart> ) ) { if ( <S2SV_ModStart> -> seq_num ) < 0 ) { SSLerr ( SSL_F_DTLS1_READ_BYTES , ERR_R_INTERNAL_ERROR ) ; return - 1 ; } <S2SV_ModEnd> rr -> length\n","project_and_commit_id":"openssl@openssl/103b171d8fc282ef435f8de9afbf7782e312961f","cve_id":"CVE-2015-0206","original_address":"https://github.com/openssl/openssl/commit/103b171d8fc282ef435f8de9afbf7782e312961f","time":"2015-01-09T02:59Z"},
	{"Unnamed: 0":6217,"cwe_id":"CWE-362","source":"CWE-362 hsm_com_errno_t unix_client_connect ( hsm_com_client_hdl_t * hdl ) { int fd , len ; struct sockaddr_un unix_addr ; <S2SV_StartBug> if ( ( fd = socket ( AF_UNIX , SOCK_STREAM , 0 ) ) < 0 ) <S2SV_EndBug> { return HSM_COM_ERROR ; } memset ( & unix_addr , 0 , sizeof ( unix_addr ) ) ; unix_addr . sun_family = AF_UNIX ; if ( strlen ( hdl -> c_path ) >= sizeof ( unix_addr . sun_path ) ) { <S2SV_StartBug> close ( fd ) ; <S2SV_EndBug> return HSM_COM_PATH_ERR ; } snprintf ( unix_addr . sun_path , sizeof ( unix_addr . sun_path ) , \"%s\" , hdl -> c_path ) ; len = SUN_LEN ( & unix_addr ) ; unlink ( unix_addr . sun_path ) ; if ( bind ( fd , ( struct sockaddr * ) & unix_addr , len ) < 0 ) { <S2SV_StartBug> unlink ( hdl -> c_path ) ; <S2SV_EndBug> close ( fd ) ; return HSM_COM_BIND_ERR ; } if ( chmod ( unix_addr . sun_path , S_IRWXU ) < 0 ) { <S2SV_StartBug> unlink ( hdl -> c_path ) ; <S2SV_EndBug> close ( fd ) ; return HSM_COM_CHMOD_ERR ; } memset ( & unix_addr , 0 , sizeof ( unix_addr ) ) ; unix_addr . sun_family = AF_UNIX ; strncpy ( unix_addr . sun_path , hdl -> s_path , sizeof ( unix_addr . sun_path ) ) ; unix_addr . sun_path [ sizeof ( unix_addr . sun_path ) - 1 ] = 0 ; len = SUN_LEN ( & unix_addr ) ; if ( connect ( fd , ( struct sockaddr * ) & unix_addr , len ) < 0 ) { <S2SV_StartBug> unlink ( hdl -> c_path ) ; <S2SV_EndBug> close ( fd ) ; return HSM_COM_CONX_ERR ; } hdl -> client_fd = fd ; hdl -> client_state = HSM_COM_C_STATE_CT ; if ( unix_sck_send_conn ( hdl , 2 ) != HSM_COM_OK ) { hdl -> client_state = HSM_COM_C_STATE_IN ; <S2SV_StartBug> return HSM_COM_SEND_ERR ; <S2SV_EndBug> } return HSM_COM_OK ; }\n","target":"<S2SV_ModStart> sockaddr_un unix_addr ; hsm_com_errno_t res = HSM_COM_OK ; <S2SV_ModStart> ) ) { res = HSM_COM_PATH_ERR ; goto cleanup <S2SV_ModEnd> ; } snprintf <S2SV_ModStart> 0 ) { res = HSM_COM_BIND_ERR ; goto cleanup ; <S2SV_ModEnd> } if ( <S2SV_ModStart> 0 ) { res = HSM_COM_CHMOD_ERR ; goto cleanup <S2SV_ModEnd> ; } memset <S2SV_ModStart> 0 ) { res = HSM_COM_CONX_ERR ; goto cleanup <S2SV_ModEnd> ; } hdl <S2SV_ModStart> = HSM_COM_C_STATE_IN ; res = HSM_COM_SEND_ERR ; } return res ; cleanup : close ( fd ) ; return res <S2SV_ModEnd> ; } <S2SV_null>\n","project_and_commit_id":"01org@opa-fm/c5759e7b76f5bf844be6c6641cc1b356bbc83869","cve_id":"CVE-2015-5232","original_address":"https://github.com/01org/opa-fm/commit/c5759e7b76f5bf844be6c6641cc1b356bbc83869","time":"2017-06-07T20:29Z"},
	{"Unnamed: 0":4624,"cwe_id":"CWE-284","source":"CWE-284 static void umount_tree ( struct mount * mnt , enum umount_tree_flags how ) { LIST_HEAD ( tmp_list ) ; struct mount * p ; if ( how & UMOUNT_PROPAGATE ) propagate_mount_unlock ( mnt ) ; for ( p = mnt ; p ; p = next_mnt ( p , mnt ) ) { p -> mnt . mnt_flags |= MNT_UMOUNT ; list_move ( & p -> mnt_list , & tmp_list ) ; } list_for_each_entry ( p , & tmp_list , mnt_list ) { list_del_init ( & p -> mnt_child ) ; } if ( how & UMOUNT_PROPAGATE ) propagate_umount ( & tmp_list ) ; while ( ! list_empty ( & tmp_list ) ) { <S2SV_StartBug> p = list_first_entry ( & tmp_list , struct mount , mnt_list ) ; <S2SV_EndBug> list_del_init ( & p -> mnt_expire ) ; list_del_init ( & p -> mnt_list ) ; __touch_mnt_namespace ( p -> mnt_ns ) ; p -> mnt_ns = NULL ; if ( how & UMOUNT_SYNC ) p -> mnt . mnt_flags |= MNT_SYNC_UMOUNT ; <S2SV_StartBug> pin_insert_group ( & p -> mnt_umount , & p -> mnt_parent -> mnt , & unmounted ) ; <S2SV_EndBug> if ( mnt_has_parent ( p ) ) { mnt_add_count ( p -> mnt_parent , - 1 ) ; <S2SV_StartBug> umount_mnt ( p ) ; <S2SV_EndBug> } <S2SV_StartBug> change_mnt_propagation ( p , MS_PRIVATE ) ; <S2SV_EndBug> } }\n","target":"<S2SV_ModStart> ) ) { bool disconnect ; <S2SV_ModStart> |= MNT_SYNC_UMOUNT ; disconnect = ! IS_MNT_LOCKED_AND_LAZY ( p ) ; <S2SV_ModStart> -> mnt , disconnect ? & unmounted : NULL <S2SV_ModEnd> ) ; if <S2SV_ModStart> 1 ) ; if ( ! disconnect ) { list_add_tail ( & p -> mnt_child , & p -> mnt_parent -> mnt_mounts ) ; } else { <S2SV_ModStart> ) ; } }\n","project_and_commit_id":"torvalds@linux/ce07d891a0891d3c0d0c2d73d577490486b809e1","cve_id":"CVE-2014-9717","original_address":"https://github.com/torvalds/linux/commit/ce07d891a0891d3c0d0c2d73d577490486b809e1","time":"2016-05-02T10:59Z"},
	{"Unnamed: 0":5947,"cwe_id":"CWE-125","source":"CWE-125 static Image * ReadWPGImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { typedef struct { size_t FileId ; MagickOffsetType DataOffset ; unsigned int ProductType ; unsigned int FileType ; unsigned char MajorVersion ; unsigned char MinorVersion ; unsigned int EncryptKey ; unsigned int Reserved ; } WPGHeader ; typedef struct { unsigned char RecType ; size_t RecordLength ; } WPGRecord ; typedef struct { unsigned char Class ; unsigned char RecType ; size_t Extension ; size_t RecordLength ; } WPG2Record ; typedef struct { unsigned HorizontalUnits ; unsigned VerticalUnits ; unsigned char PosSizePrecision ; } WPG2Start ; typedef struct { unsigned int Width ; unsigned int Height ; unsigned int Depth ; unsigned int HorzRes ; unsigned int VertRes ; } WPGBitmapType1 ; typedef struct { unsigned int Width ; unsigned int Height ; unsigned char Depth ; unsigned char Compression ; } WPG2BitmapType1 ; typedef struct { unsigned int RotAngle ; unsigned int LowLeftX ; unsigned int LowLeftY ; unsigned int UpRightX ; unsigned int UpRightY ; unsigned int Width ; unsigned int Height ; unsigned int Depth ; unsigned int HorzRes ; unsigned int VertRes ; } WPGBitmapType2 ; typedef struct { unsigned int StartIndex ; unsigned int NumOfEntries ; } WPGColorMapRec ; Image * image ; unsigned int status ; WPGHeader Header ; WPGRecord Rec ; WPG2Record Rec2 ; WPG2Start StartWPG ; WPGBitmapType1 BitmapHeader1 ; WPG2BitmapType1 Bitmap2Header1 ; WPGBitmapType2 BitmapHeader2 ; WPGColorMapRec WPG_Palette ; int i , bpp , WPG2Flags ; ssize_t ldblk ; size_t one ; unsigned char * BImgBuff ; tCTM CTM ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickCoreSignature ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickCoreSignature ) ; one = 1 ; image = AcquireImage ( image_info , exception ) ; image -> depth = 8 ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } Header . FileId = ReadBlobLSBLong ( image ) ; Header . DataOffset = ( MagickOffsetType ) ReadBlobLSBLong ( image ) ; Header . ProductType = ReadBlobLSBShort ( image ) ; Header . FileType = ReadBlobLSBShort ( image ) ; Header . MajorVersion = ReadBlobByte ( image ) ; Header . MinorVersion = ReadBlobByte ( image ) ; Header . EncryptKey = ReadBlobLSBShort ( image ) ; Header . Reserved = ReadBlobLSBShort ( image ) ; if ( Header . FileId != 0x435057FF || ( Header . ProductType >> 8 ) != 0x16 ) ThrowReaderException ( CorruptImageError , \"ImproperImageHeader\" ) ; if ( Header . EncryptKey != 0 ) ThrowReaderException ( CoderError , \"EncryptedWPGImageFileNotSupported\" ) ; image -> columns = 1 ; image -> rows = 1 ; image -> colors = 0 ; bpp = 0 ; BitmapHeader2 . RotAngle = 0 ; switch ( Header . FileType ) { case 1 : while ( ! EOFBlob ( image ) ) { ( void ) SeekBlob ( image , Header . DataOffset , SEEK_SET ) ; if ( EOFBlob ( image ) ) break ; Rec . RecType = ( i = ReadBlobByte ( image ) ) ; if ( i == EOF ) break ; Rd_WP_DWORD ( image , & Rec . RecordLength ) ; if ( EOFBlob ( image ) ) break ; Header . DataOffset = TellBlob ( image ) + Rec . RecordLength ; switch ( Rec . RecType ) { case 0x0B : BitmapHeader1 . Width = ReadBlobLSBShort ( image ) ; BitmapHeader1 . Height = ReadBlobLSBShort ( image ) ; if ( ( BitmapHeader1 . Width == 0 ) || ( BitmapHeader1 . Height == 0 ) ) ThrowReaderException ( CorruptImageError , \"ImproperImageHeader\" ) ; BitmapHeader1 . Depth = ReadBlobLSBShort ( image ) ; BitmapHeader1 . HorzRes = ReadBlobLSBShort ( image ) ; BitmapHeader1 . VertRes = ReadBlobLSBShort ( image ) ; if ( BitmapHeader1 . HorzRes && BitmapHeader1 . VertRes ) { image -> units = PixelsPerCentimeterResolution ; image -> resolution . x = BitmapHeader1 . HorzRes / 470.0 ; image -> resolution . y = BitmapHeader1 . VertRes / 470.0 ; } image -> columns = BitmapHeader1 . Width ; image -> rows = BitmapHeader1 . Height ; bpp = BitmapHeader1 . Depth ; goto UnpackRaster ; case 0x0E : WPG_Palette . StartIndex = ReadBlobLSBShort ( image ) ; WPG_Palette . NumOfEntries = ReadBlobLSBShort ( image ) ; image -> colors = WPG_Palette . NumOfEntries ; if ( ! AcquireImageColormap ( image , image -> colors , exception ) ) goto NoMemory ; for ( i = WPG_Palette . StartIndex ; i < ( int ) WPG_Palette . NumOfEntries ; i ++ ) { image -> colormap [ i ] . red = ScaleCharToQuantum ( ( unsigned char ) ReadBlobByte ( image ) ) ; image -> colormap [ i ] . green = ScaleCharToQuantum ( ( unsigned char ) ReadBlobByte ( image ) ) ; image -> colormap [ i ] . blue = ScaleCharToQuantum ( ( unsigned char ) ReadBlobByte ( image ) ) ; } break ; case 0x11 : if ( Rec . RecordLength > 8 ) image = ExtractPostscript ( image , image_info , TellBlob ( image ) + 8 , ( ssize_t ) Rec . RecordLength - 8 , exception ) ; break ; case 0x14 : BitmapHeader2 . RotAngle = ReadBlobLSBShort ( image ) ; BitmapHeader2 . LowLeftX = ReadBlobLSBShort ( image ) ; BitmapHeader2 . LowLeftY = ReadBlobLSBShort ( image ) ; BitmapHeader2 . UpRightX = ReadBlobLSBShort ( image ) ; BitmapHeader2 . UpRightY = ReadBlobLSBShort ( image ) ; BitmapHeader2 . Width = ReadBlobLSBShort ( image ) ; BitmapHeader2 . Height = ReadBlobLSBShort ( image ) ; if ( ( BitmapHeader2 . Width == 0 ) || ( BitmapHeader2 . Height == 0 ) ) ThrowReaderException ( CorruptImageError , \"ImproperImageHeader\" ) ; BitmapHeader2 . Depth = ReadBlobLSBShort ( image ) ; BitmapHeader2 . HorzRes = ReadBlobLSBShort ( image ) ; BitmapHeader2 . VertRes = ReadBlobLSBShort ( image ) ; image -> units = PixelsPerCentimeterResolution ; image -> page . width = ( unsigned int ) ( ( BitmapHeader2 . LowLeftX - BitmapHeader2 . UpRightX ) / 470.0 ) ; image -> page . height = ( unsigned int ) ( ( BitmapHeader2 . LowLeftX - BitmapHeader2 . UpRightY ) / 470.0 ) ; image -> page . x = ( int ) ( BitmapHeader2 . LowLeftX / 470.0 ) ; image -> page . y = ( int ) ( BitmapHeader2 . LowLeftX / 470.0 ) ; if ( BitmapHeader2 . HorzRes && BitmapHeader2 . VertRes ) { image -> resolution . x = BitmapHeader2 . HorzRes / 470.0 ; image -> resolution . y = BitmapHeader2 . VertRes / 470.0 ; } image -> columns = BitmapHeader2 . Width ; image -> rows = BitmapHeader2 . Height ; bpp = BitmapHeader2 . Depth ; UnpackRaster : if ( ( image -> colors == 0 ) && ( bpp != 24 ) ) { image -> colors = one << bpp ; if ( ! AcquireImageColormap ( image , image -> colors , exception ) ) { NoMemory : ThrowReaderException ( ResourceLimitError , \"MemoryAllocationFailed\" ) ; } for ( i = 0 ; ( i < ( int ) image -> colors ) && ( i < 256 ) ; i ++ ) { image -> colormap [ i ] . red = ScaleCharToQuantum ( WPG1_Palette [ i ] . Red ) ; image -> colormap [ i ] . green = ScaleCharToQuantum ( WPG1_Palette [ i ] . Green ) ; image -> colormap [ i ] . blue = ScaleCharToQuantum ( WPG1_Palette [ i ] . Blue ) ; } } else { if ( bpp < 24 ) if ( ( image -> colors < ( one << bpp ) ) && ( bpp != 24 ) ) image -> colormap = ( PixelInfo * ) ResizeQuantumMemory ( image -> colormap , ( size_t ) ( one << bpp ) , sizeof ( * image -> colormap ) ) ; } if ( bpp == 1 ) { if ( image -> colormap [ 0 ] . red == 0 && image -> colormap [ 0 ] . green == 0 && image -> colormap [ 0 ] . blue == 0 && image -> colormap [ 1 ] . red == 0 && image -> colormap [ 1 ] . green == 0 && image -> colormap [ 1 ] . blue == 0 ) { image -> colormap [ 1 ] . red = image -> colormap [ 1 ] . green = image -> colormap [ 1 ] . blue = QuantumRange ; } } if ( UnpackWPGRaster ( image , bpp , exception ) < 0 ) { DecompressionFailed : ThrowReaderException ( CoderError , \"UnableToDecompressImage\" ) ; } if ( Rec . RecType == 0x14 && BitmapHeader2 . RotAngle != 0 && ! image_info -> ping ) { if ( BitmapHeader2 . RotAngle & 0x8000 ) { Image * flop_image ; flop_image = FlopImage ( image , exception ) ; if ( flop_image != ( Image * ) NULL ) { DuplicateBlob ( flop_image , image ) ; ( void ) RemoveLastImageFromList ( & image ) ; AppendImageToList ( & image , flop_image ) ; } } if ( BitmapHeader2 . RotAngle & 0x2000 ) { Image * flip_image ; flip_image = FlipImage ( image , exception ) ; if ( flip_image != ( Image * ) NULL ) { DuplicateBlob ( flip_image , image ) ; ( void ) RemoveLastImageFromList ( & image ) ; AppendImageToList ( & image , flip_image ) ; } } if ( BitmapHeader2 . RotAngle & 0x0FFF ) { Image * rotate_image ; rotate_image = RotateImage ( image , ( BitmapHeader2 . RotAngle & 0x0FFF ) , exception ) ; if ( rotate_image != ( Image * ) NULL ) { DuplicateBlob ( rotate_image , image ) ; ( void ) RemoveLastImageFromList ( & image ) ; AppendImageToList ( & image , rotate_image ) ; } } } AcquireNextImage ( image_info , image , exception ) ; image -> depth = 8 ; if ( image -> next == ( Image * ) NULL ) goto Finish ; image = SyncNextImageInList ( image ) ; image -> columns = image -> rows = 0 ; image -> colors = 0 ; break ; case 0x1B : if ( Rec . RecordLength > 0x3C ) image = ExtractPostscript ( image , image_info , TellBlob ( image ) + 0x3C , ( ssize_t ) Rec . RecordLength - 0x3C , exception ) ; break ; } } break ; case 2 : ( void ) memset ( CTM , 0 , sizeof ( CTM ) ) ; StartWPG . PosSizePrecision = 0 ; while ( ! EOFBlob ( image ) ) { ( void ) SeekBlob ( image , Header . DataOffset , SEEK_SET ) ; if ( EOFBlob ( image ) ) break ; Rec2 . Class = ( i = ReadBlobByte ( image ) ) ; if ( i == EOF ) break ; Rec2 . RecType = ( i = ReadBlobByte ( image ) ) ; if ( i == EOF ) break ; Rd_WP_DWORD ( image , & Rec2 . Extension ) ; Rd_WP_DWORD ( image , & Rec2 . RecordLength ) ; if ( EOFBlob ( image ) ) break ; Header . DataOffset = TellBlob ( image ) + Rec2 . RecordLength ; switch ( Rec2 . RecType ) { case 1 : StartWPG . HorizontalUnits = ReadBlobLSBShort ( image ) ; StartWPG . VerticalUnits = ReadBlobLSBShort ( image ) ; StartWPG . PosSizePrecision = ReadBlobByte ( image ) ; break ; case 0x0C : WPG_Palette . StartIndex = ReadBlobLSBShort ( image ) ; WPG_Palette . NumOfEntries = ReadBlobLSBShort ( image ) ; image -> colors = WPG_Palette . NumOfEntries ; if ( AcquireImageColormap ( image , image -> colors , exception ) == MagickFalse ) ThrowReaderException ( ResourceLimitError , \"MemoryAllocationFailed\" ) ; for ( i = WPG_Palette . StartIndex ; i < ( int ) WPG_Palette . NumOfEntries ; i ++ ) { image -> colormap [ i ] . red = ScaleCharToQuantum ( ( char ) ReadBlobByte ( image ) ) ; image -> colormap [ i ] . green = ScaleCharToQuantum ( ( char ) ReadBlobByte ( image ) ) ; image -> colormap [ i ] . blue = ScaleCharToQuantum ( ( char ) ReadBlobByte ( image ) ) ; ( void ) ReadBlobByte ( image ) ; } break ; case 0x0E : Bitmap2Header1 . Width = ReadBlobLSBShort ( image ) ; Bitmap2Header1 . Height = ReadBlobLSBShort ( image ) ; if ( ( Bitmap2Header1 . Width == 0 ) || ( Bitmap2Header1 . Height == 0 ) ) ThrowReaderException ( CorruptImageError , \"ImproperImageHeader\" ) ; Bitmap2Header1 . Depth = ReadBlobByte ( image ) ; Bitmap2Header1 . Compression = ReadBlobByte ( image ) ; if ( Bitmap2Header1 . Compression > 1 ) continue ; switch ( Bitmap2Header1 . Depth ) { case 1 : bpp = 1 ; break ; case 2 : bpp = 2 ; break ; case 3 : bpp = 4 ; break ; case 4 : bpp = 8 ; break ; case 8 : bpp = 24 ; break ; default : continue ; } image -> columns = Bitmap2Header1 . Width ; image -> rows = Bitmap2Header1 . Height ; if ( ( image -> colors == 0 ) && ( bpp != 24 ) ) { size_t one ; one = 1 ; image -> colors = one << bpp ; if ( ! AcquireImageColormap ( image , image -> colors , exception ) ) goto NoMemory ; } else { if ( bpp < 24 ) if ( image -> colors < ( one << bpp ) && bpp != 24 ) image -> colormap = ( PixelInfo * ) ResizeQuantumMemory ( image -> colormap , ( size_t ) ( one << bpp ) , sizeof ( * image -> colormap ) ) ; } switch ( Bitmap2Header1 . Compression ) { case 0 : { ldblk = ( ssize_t ) ( ( bpp * image -> columns + 7 ) / 8 ) ; BImgBuff = ( unsigned char * ) AcquireQuantumMemory ( ( size_t ) <S2SV_StartBug> ldblk , sizeof ( * BImgBuff ) ) ; <S2SV_EndBug> if ( BImgBuff == ( unsigned char * ) NULL ) goto NoMemory ; for ( i = 0 ; i < ( ssize_t ) image -> rows ; i ++ ) { ( void ) ReadBlob ( image , ldblk , BImgBuff ) ; InsertRow ( image , BImgBuff , i , bpp , exception ) ; } if ( BImgBuff ) BImgBuff = ( unsigned char * ) RelinquishMagickMemory ( BImgBuff ) ; ; break ; } case 1 : { if ( UnpackWPG2Raster ( image , bpp , exception ) < 0 ) goto DecompressionFailed ; break ; } } if ( CTM [ 0 ] [ 0 ] < 0 && ! image_info -> ping ) { Image * flop_image ; flop_image = FlopImage ( image , exception ) ; if ( flop_image != ( Image * ) NULL ) { DuplicateBlob ( flop_image , image ) ; ( void ) RemoveLastImageFromList ( & image ) ; AppendImageToList ( & image , flop_image ) ; } } if ( CTM [ 1 ] [ 1 ] < 0 && ! image_info -> ping ) { Image * flip_image ; flip_image = FlipImage ( image , exception ) ; if ( flip_image != ( Image * ) NULL ) { DuplicateBlob ( flip_image , image ) ; ( void ) RemoveLastImageFromList ( & image ) ; AppendImageToList ( & image , flip_image ) ; } } AcquireNextImage ( image_info , image , exception ) ; image -> depth = 8 ; if ( image -> next == ( Image * ) NULL ) goto Finish ; image = SyncNextImageInList ( image ) ; image -> columns = image -> rows = 1 ; image -> colors = 0 ; break ; case 0x12 : i = ReadBlobLSBShort ( image ) ; if ( Rec2 . RecordLength > ( unsigned int ) i ) image = ExtractPostscript ( image , image_info , TellBlob ( image ) + i , ( ssize_t ) ( Rec2 . RecordLength - i - 2 ) , exception ) ; break ; case 0x1B : WPG2Flags = LoadWPG2Flags ( image , StartWPG . PosSizePrecision , NULL , & CTM ) ; ( void ) WPG2Flags ; break ; } } break ; default : { ThrowReaderException ( CoderError , \"DataEncodingSchemeIsNotSupported\" ) ; } } status = SetImageExtent ( image , image -> columns , image -> rows , exception ) ; if ( status == MagickFalse ) return ( DestroyImageList ( image ) ) ; Finish : ( void ) CloseBlob ( image ) ; { Image * p ; ssize_t scene = 0 ; p = image ; image = NULL ; while ( p != ( Image * ) NULL ) { Image * tmp = p ; if ( ( p -> rows == 0 ) || ( p -> columns == 0 ) ) { p = p -> previous ; DeleteImageFromList ( & tmp ) ; } else { image = p ; p = p -> previous ; } } for ( p = image ; p != ( Image * ) NULL ; p = p -> next ) p -> scene = ( size_t ) scene ++ ; } if ( image == ( Image * ) NULL ) ThrowReaderException ( CorruptImageError , \"ImageFileDoesNotContainAnyImageData\" ) ; return ( image ) ; }\n","target":"<S2SV_ModStart> size_t ) ldblk + 1\n","project_and_commit_id":"ImageMagick@ImageMagick/bef1e4f637d8f665bc133a9c6d30df08d983bc3a","cve_id":"CVE-2016-7533","original_address":"https://github.com/ImageMagick/ImageMagick/commit/bef1e4f637d8f665bc133a9c6d30df08d983bc3a","time":"2017-04-19T14:59Z"},
	{"Unnamed: 0":5111,"cwe_id":"CWE-119","source":"CWE-119 void vp9_remove_common ( VP9_COMMON * cm ) { <S2SV_StartBug> vp9_free_frame_buffers ( cm ) ; <S2SV_EndBug> <S2SV_StartBug> vp9_free_internal_frame_buffers ( & cm -> int_frame_buffers ) ; <S2SV_EndBug> }\n","target":"<S2SV_ModStart> cm ) { vp9_free_context_buffers <S2SV_ModEnd> ( cm ) <S2SV_ModStart> cm ) ; vpx_free ( cm -> fc ) ; cm -> fc = NULL ; vpx_free ( cm -> frame_contexts ) ; cm -> frame_contexts = NULL <S2SV_ModEnd> ; } <S2SV_null>\n","project_and_commit_id":"external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426","cve_id":"CVE-2016-1621","original_address":"https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426","time":"2016-03-12T21:59Z"},
	{"Unnamed: 0":5344,"cwe_id":"CWE-611","source":"CWE-611 <S2SV_StartBug> static VALUE from_document ( VALUE klass , VALUE document ) <S2SV_EndBug> { xmlDocPtr doc ; xmlSchemaParserCtxtPtr ctx ; xmlSchemaPtr schema ; VALUE errors ; VALUE rb_schema ; <S2SV_StartBug> Data_Get_Struct ( document , xmlDoc , doc ) ; <S2SV_EndBug> <S2SV_StartBug> doc = doc -> doc ; <S2SV_EndBug> if ( has_blank_nodes_p ( DOC_NODE_CACHE ( doc ) ) ) { rb_raise ( rb_eArgError , \"Creating<S2SV_blank>a<S2SV_blank>schema<S2SV_blank>from<S2SV_blank>a<S2SV_blank>document<S2SV_blank>that<S2SV_blank>has<S2SV_blank>blank<S2SV_blank>nodes<S2SV_blank>exposed<S2SV_blank>to<S2SV_blank>Ruby<S2SV_blank>is<S2SV_blank>dangerous\" ) ; } ctx = xmlSchemaNewDocParserCtxt ( doc ) ; errors = rb_ary_new ( ) ; xmlSetStructuredErrorFunc ( ( void * ) errors , Nokogiri_error_array_pusher ) ; # ifdef HAVE_XMLSCHEMASETPARSERSTRUCTUREDERRORS xmlSchemaSetParserStructuredErrors ( ctx , Nokogiri_error_array_pusher , ( void * ) errors ) ; # endif schema = xmlSchemaParse ( ctx ) ; xmlSetStructuredErrorFunc ( NULL , NULL ) ; xmlSchemaFreeParserCtxt ( ctx ) ; if ( NULL == schema ) { xmlErrorPtr error = xmlGetLastError ( ) ; if ( error ) Nokogiri_error_raise ( NULL , error ) ; else rb_raise ( rb_eRuntimeError , \"Could<S2SV_blank>not<S2SV_blank>parse<S2SV_blank>document\" ) ; return Qnil ; } rb_schema = Data_Wrap_Struct ( klass , 0 , dealloc , schema ) ; rb_iv_set ( rb_schema , \"@errors\" , errors ) ; <S2SV_StartBug> return rb_schema ; <S2SV_EndBug> return Qnil ; }\n","target":"<S2SV_ModStart> VALUE from_document ( int argc , VALUE * argv , VALUE klass ) { VALUE document ; VALUE parse_options ; int parse_options_int ; <S2SV_ModEnd> xmlDocPtr doc ; <S2SV_ModStart> VALUE rb_schema ; int scanned_args = 0 ; scanned_args = rb_scan_args ( argc , argv , \"11\" , & document , & parse_options ) ; <S2SV_ModStart> doc -> doc ; if ( scanned_args == 1 ) { parse_options = rb_const_get ( rb_const_get ( mNokogiriXml , rb_intern ( \"ParseOptions\" ) ) , rb_intern ( \"DEFAULT_SCHEMA\" ) ) ; } parse_options_int = ( int ) NUM2INT ( rb_funcall ( parse_options , rb_intern ( \"to_i\" ) , 0 ) ) <S2SV_ModStart> errors ) ; rb_iv_set ( rb_schema , \"@parse_options\" , parse_options ) ;\n","project_and_commit_id":"sparklemotion@nokogiri/9c87439d9afa14a365ff13e73adc809cb2c3d97b","cve_id":"CVE-2020-26247","original_address":"https://github.com/sparklemotion/nokogiri/commit/9c87439d9afa14a365ff13e73adc809cb2c3d97b","time":"2020-12-30T19:15Z"},
	{"Unnamed: 0":6618,"cwe_id":"CWE-362","source":"CWE-362 static int ptrace_check_attach ( struct task_struct * child , bool ignore_state ) { int ret = - ESRCH ; read_lock ( & tasklist_lock ) ; <S2SV_StartBug> if ( ( child -> ptrace & PT_PTRACED ) && child -> parent == current ) { <S2SV_EndBug> <S2SV_StartBug> spin_lock_irq ( & child -> sighand -> siglock ) ; <S2SV_EndBug> WARN_ON_ONCE ( task_is_stopped ( child ) ) ; <S2SV_StartBug> if ( ignore_state || ( task_is_traced ( child ) && <S2SV_EndBug> ! ( child -> jobctl & JOBCTL_LISTENING ) ) ) <S2SV_StartBug> ret = 0 ; <S2SV_EndBug> spin_unlock_irq ( & child -> sighand -> siglock ) ; } read_unlock ( & tasklist_lock ) ; <S2SV_StartBug> if ( ! ret && ! ignore_state ) <S2SV_EndBug> <S2SV_StartBug> ret = wait_task_inactive ( child , TASK_TRACED ) ? 0 : - ESRCH ; <S2SV_EndBug> return ret ; }\n","target":"<S2SV_ModStart> ; if ( <S2SV_ModEnd> child -> ptrace <S2SV_ModStart> child -> ptrace <S2SV_ModEnd> && child -> <S2SV_ModStart> current ) { WARN_ON ( child -> state == __TASK_TRACED <S2SV_ModEnd> ) ; if <S2SV_ModStart> ( ignore_state || ptrace_freeze_traced ( child <S2SV_ModEnd> ) ) ret <S2SV_ModStart> ret = 0 <S2SV_ModEnd> ; } read_unlock <S2SV_ModStart> ! ignore_state ) { if ( ! <S2SV_ModEnd> wait_task_inactive ( child <S2SV_ModStart> ( child , __TASK_TRACED ) ) { WARN_ON ( child -> state == __TASK_TRACED ) ; ret = <S2SV_ModEnd> - ESRCH ; <S2SV_ModStart> - ESRCH ; } }\n","project_and_commit_id":"torvalds@linux/9899d11f654474d2d54ea52ceaa2a1f4db3abd68","cve_id":"CVE-2013-0871","original_address":"https://github.com/torvalds/linux/commit/9899d11f654474d2d54ea52ceaa2a1f4db3abd68","time":"2013-02-18T04:41Z"},
	{"Unnamed: 0":4107,"cwe_id":"CWE-189","source":"CWE-189 static int check_cond_jmp_op ( struct bpf_verifier_env * env , struct bpf_insn * insn , int * insn_idx ) { struct bpf_verifier_state * this_branch = env -> cur_state ; struct bpf_verifier_state * other_branch ; struct bpf_reg_state * regs = this_branch -> frame [ this_branch -> curframe ] -> regs ; struct bpf_reg_state * dst_reg , * other_branch_regs ; u8 opcode = BPF_OP ( insn -> code ) ; int err ; if ( opcode > BPF_JSLE ) { verbose ( env , \"invalid<S2SV_blank>BPF_JMP<S2SV_blank>opcode<S2SV_blank>%x\\\\n\" , opcode ) ; return - EINVAL ; } if ( BPF_SRC ( insn -> code ) == BPF_X ) { if ( insn -> imm != 0 ) { verbose ( env , \"BPF_JMP<S2SV_blank>uses<S2SV_blank>reserved<S2SV_blank>fields\\\\n\" ) ; return - EINVAL ; } err = check_reg_arg ( env , insn -> src_reg , SRC_OP ) ; if ( err ) return err ; if ( is_pointer_value ( env , insn -> src_reg ) ) { verbose ( env , \"R%d<S2SV_blank>pointer<S2SV_blank>comparison<S2SV_blank>prohibited\\\\n\" , insn -> src_reg ) ; return - EACCES ; } } else { if ( insn -> src_reg != BPF_REG_0 ) { verbose ( env , \"BPF_JMP<S2SV_blank>uses<S2SV_blank>reserved<S2SV_blank>fields\\\\n\" ) ; return - EINVAL ; } } err = check_reg_arg ( env , insn -> dst_reg , SRC_OP ) ; if ( err ) return err ; dst_reg = & regs [ insn -> dst_reg ] ; if ( BPF_SRC ( insn -> code ) == BPF_K ) { int pred = is_branch_taken ( dst_reg , insn -> imm , opcode ) ; if ( pred == 1 ) { * insn_idx += insn -> off ; return 0 ; } else if ( pred == 0 ) { return 0 ; } } <S2SV_StartBug> other_branch = push_stack ( env , * insn_idx + insn -> off + 1 , * insn_idx ) ; <S2SV_EndBug> if ( ! other_branch ) return - EFAULT ; other_branch_regs = other_branch -> frame [ other_branch -> curframe ] -> regs ; if ( BPF_SRC ( insn -> code ) == BPF_X ) { if ( dst_reg -> type == SCALAR_VALUE && regs [ insn -> src_reg ] . type == SCALAR_VALUE ) { if ( tnum_is_const ( regs [ insn -> src_reg ] . var_off ) ) reg_set_min_max ( & other_branch_regs [ insn -> dst_reg ] , dst_reg , regs [ insn -> src_reg ] . var_off . value , opcode ) ; else if ( tnum_is_const ( dst_reg -> var_off ) ) reg_set_min_max_inv ( & other_branch_regs [ insn -> src_reg ] , & regs [ insn -> src_reg ] , dst_reg -> var_off . value , opcode ) ; else if ( opcode == BPF_JEQ || opcode == BPF_JNE ) reg_combine_min_max ( & other_branch_regs [ insn -> src_reg ] , & other_branch_regs [ insn -> dst_reg ] , & regs [ insn -> src_reg ] , & regs [ insn -> dst_reg ] , opcode ) ; } } else if ( dst_reg -> type == SCALAR_VALUE ) { reg_set_min_max ( & other_branch_regs [ insn -> dst_reg ] , dst_reg , insn -> imm , opcode ) ; } if ( BPF_SRC ( insn -> code ) == BPF_K && insn -> imm == 0 && ( opcode == BPF_JEQ || opcode == BPF_JNE ) && reg_type_may_be_null ( dst_reg -> type ) ) { mark_ptr_or_null_regs ( this_branch , insn -> dst_reg , opcode == BPF_JNE ) ; mark_ptr_or_null_regs ( other_branch , insn -> dst_reg , opcode == BPF_JEQ ) ; } else if ( ! try_match_pkt_pointers ( insn , dst_reg , & regs [ insn -> src_reg ] , this_branch , other_branch ) && is_pointer_value ( env , insn -> dst_reg ) ) { verbose ( env , \"R%d<S2SV_blank>pointer<S2SV_blank>comparison<S2SV_blank>prohibited\\\\n\" , insn -> dst_reg ) ; return - EACCES ; } if ( env -> log . level ) print_verifier_state ( env , this_branch -> frame [ this_branch -> curframe ] ) ; return 0 ; }\n","target":"<S2SV_ModStart> , * insn_idx , false\n","project_and_commit_id":"torvalds@linux/979d63d50c0c0f7bc537bf821e056cc9fe5abd38","cve_id":"CVE-2019-7308","original_address":"https://github.com/torvalds/linux/commit/979d63d50c0c0f7bc537bf821e056cc9fe5abd38","time":"2019-02-01T22:29Z"},
	{"Unnamed: 0":3665,"cwe_id":"CWE-415","source":"CWE-415 static Gif_Stream * read_gif ( Gif_Reader * grr , int read_flags , const char * landmark , Gif_ReadErrorHandler handler ) { Gif_Stream * gfs ; Gif_Image * gfi ; Gif_Context gfc ; int unknown_block_type = 0 ; if ( gifgetc ( grr ) != 'G' || gifgetc ( grr ) != 'I' || gifgetc ( grr ) != 'F' ) return 0 ; ( void ) gifgetc ( grr ) ; ( void ) gifgetc ( grr ) ; ( void ) gifgetc ( grr ) ; gfs = Gif_NewStream ( ) ; gfi = Gif_NewImage ( ) ; gfc . stream = gfs ; gfc . prefix = Gif_NewArray ( Gif_Code , GIF_MAX_CODE ) ; gfc . suffix = Gif_NewArray ( uint8_t , GIF_MAX_CODE ) ; gfc . length = Gif_NewArray ( uint16_t , GIF_MAX_CODE ) ; gfc . handler = handler ; gfc . gfi = gfi ; gfc . errors [ 0 ] = gfc . errors [ 1 ] = 0 ; if ( ! gfs || ! gfi || ! gfc . prefix || ! gfc . suffix || ! gfc . length ) goto done ; gfs -> landmark = landmark ; GIF_DEBUG ( ( \"\\\\nGIF<S2SV_blank>\" ) ) ; if ( ! read_logical_screen_descriptor ( gfs , grr ) ) goto done ; GIF_DEBUG ( ( \"logscrdesc<S2SV_blank>\" ) ) ; while ( ! gifeof ( grr ) ) { uint8_t block = gifgetbyte ( grr ) ; switch ( block ) { case ',' : GIF_DEBUG ( ( \"imageread<S2SV_blank>%d<S2SV_blank>\" , gfs -> nimages ) ) ; gfi -> identifier = last_name ; last_name = 0 ; if ( ! Gif_AddImage ( gfs , gfi ) ) goto done ; else if ( ! read_image ( grr , & gfc , gfi , read_flags ) ) { Gif_RemoveImage ( gfs , gfs -> nimages - 1 ) ; gfi = 0 ; goto done ; } gfc . gfi = gfi = Gif_NewImage ( ) ; if ( ! gfi ) goto done ; break ; case ';' : GIF_DEBUG ( ( \"term\\\\n\" ) ) ; goto done ; case '!' : block = gifgetbyte ( grr ) ; GIF_DEBUG ( ( \"ext(0x%02X)<S2SV_blank>\" , block ) ) ; switch ( block ) { case 0xF9 : read_graphic_control_extension ( & gfc , gfi , grr ) ; break ; case 0xCE : last_name = suck_data ( last_name , 0 , grr ) ; break ; case 0xFE : if ( ! read_comment_extension ( gfi , grr ) ) goto done ; break ; case 0xFF : read_application_extension ( & gfc , grr ) ; break ; default : read_unknown_extension ( & gfc , grr , block , 0 , 0 ) ; break ; } break ; default : if ( ! unknown_block_type ) { char buf [ 256 ] ; sprintf ( buf , \"unknown<S2SV_blank>block<S2SV_blank>type<S2SV_blank>%d<S2SV_blank>at<S2SV_blank>file<S2SV_blank>offset<S2SV_blank>%u\" , block , grr -> pos - 1 ) ; gif_read_error ( & gfc , 1 , buf ) ; unknown_block_type = 1 ; } break ; } } done : if ( gfs && gfi ) { Gif_Extension * gfex ; gfs -> end_comment = gfi -> comment ; gfi -> comment = 0 ; gfs -> end_extension_list = gfi -> extension_list ; gfi -> extension_list = 0 ; for ( gfex = gfs -> end_extension_list ; gfex ; gfex = gfex -> next ) gfex -> image = NULL ; } Gif_DeleteImage ( gfi ) ; Gif_DeleteArray ( last_name ) ; Gif_DeleteArray ( gfc . prefix ) ; Gif_DeleteArray ( gfc . suffix ) ; Gif_DeleteArray ( gfc . length ) ; gfc . gfi = 0 ; <S2SV_StartBug> if ( gfs ) <S2SV_EndBug> gfs -> errors = gfc . errors [ 1 ] ; if ( gfs && gfc . errors [ 1 ] == 0 && ! ( read_flags & GIF_READ_TRAILING_GARBAGE_OK ) && ! grr -> eofer ( grr ) ) gif_read_error ( & gfc , 0 , \"trailing<S2SV_blank>garbage<S2SV_blank>after<S2SV_blank>GIF<S2SV_blank>ignored\" ) ; gif_read_error ( & gfc , - 1 , 0 ) ; return gfs ; }\n","target":"<S2SV_ModStart> = 0 ; last_name = 0 ;\n","project_and_commit_id":"kohler@gifsicle/118a46090c50829dc543179019e6140e1235f909","cve_id":"CVE-2017-18120","original_address":"https://github.com/kohler/gifsicle/commit/118a46090c50829dc543179019e6140e1235f909","time":"2018-02-02T09:29Z"},
	{"Unnamed: 0":2679,"cwe_id":"CWE-119","source":"CWE-119 WORD32 ih264d_mark_err_slice_skip ( dec_struct_t * ps_dec , WORD32 num_mb_skip , UWORD8 u1_is_idr_slice , UWORD16 u2_frame_num , pocstruct_t * ps_cur_poc , WORD32 prev_slice_err ) { WORD32 i2_cur_mb_addr ; UWORD32 u1_num_mbs , u1_num_mbsNby2 ; UWORD32 u1_mb_idx = ps_dec -> u1_mb_idx ; UWORD32 i2_mb_skip_run ; UWORD32 u1_num_mbs_next , u1_end_of_row ; const UWORD32 i2_pic_wdin_mbs = ps_dec -> u2_frm_wd_in_mbs ; UWORD32 u1_slice_end ; UWORD32 u1_tfr_n_mb ; UWORD32 u1_decode_nmb ; dec_bit_stream_t * const ps_bitstrm = ps_dec -> ps_bitstrm ; dec_slice_params_t * ps_slice = ps_dec -> ps_cur_slice ; UWORD32 * pu4_bitstrm_buf = ps_bitstrm -> pu4_buffer ; UWORD32 * pu4_bitstrm_ofst = & ps_bitstrm -> u4_ofst ; deblk_mb_t * ps_cur_deblk_mb ; dec_mb_info_t * ps_cur_mb_info ; parse_pmbarams_t * ps_parse_mb_data ; UWORD32 u1_inter_mb_type ; UWORD32 u1_deblk_mb_type ; UWORD16 u2_total_mbs_coded ; UWORD32 u1_mbaff = ps_slice -> u1_mbaff_frame_flag ; parse_part_params_t * ps_part_info ; WORD32 ret ; if ( ps_dec -> ps_dec_err_status -> u1_err_flag & REJECT_CUR_PIC ) { ih264d_err_pic_dispbuf_mgr ( ps_dec ) ; return 0 ; } if ( prev_slice_err == 1 ) { ps_dec -> ps_cur_slice -> u2_frame_num = u2_frame_num ; if ( ! ps_dec -> u1_first_slice_in_stream ) { ih264d_end_of_pic ( ps_dec , u1_is_idr_slice , ps_dec -> ps_cur_slice -> u2_frame_num ) ; ps_dec -> s_cur_pic_poc . u2_frame_num = ps_dec -> ps_cur_slice -> u2_frame_num ; } { WORD32 i , j , poc = 0 ; ps_dec -> ps_cur_slice -> u2_first_mb_in_slice = 0 ; ps_dec -> pf_mvpred = ih264d_mvpred_nonmbaff ; ps_dec -> p_form_mb_part_info = ih264d_form_mb_part_info_bp ; ps_dec -> p_motion_compensate = ih264d_motion_compensate_bp ; if ( ps_dec -> ps_cur_pic != NULL ) poc = ps_dec -> ps_cur_pic -> i4_poc + 2 ; j = 0 ; for ( i = 0 ; i < MAX_NUM_PIC_PARAMS ; i ++ ) if ( ps_dec -> ps_pps [ i ] . u1_is_valid == TRUE ) j = i ; { ret = ih264d_start_of_pic ( ps_dec , poc , ps_cur_poc , ps_dec -> ps_cur_slice -> u2_frame_num , & ps_dec -> ps_pps [ j ] ) ; if ( ret != OK ) { return ret ; } } ps_dec -> ps_ref_pic_buf_lx [ 0 ] [ 0 ] -> u1_pic_buf_id = 0 ; ps_dec -> u4_output_present = 0 ; { ih264d_get_next_display_field ( ps_dec , ps_dec -> ps_out_buffer , & ( ps_dec -> s_disp_op ) ) ; if ( 0 != ps_dec -> s_disp_op . u4_error_code ) { ps_dec -> u4_fmt_conv_cur_row = ps_dec -> s_disp_frame_info . u4_y_ht ; } else ps_dec -> u4_output_present = 1 ; } if ( ps_dec -> u1_separate_parse == 1 ) { if ( ps_dec -> u4_dec_thread_created == 0 ) { ithread_create ( ps_dec -> pv_dec_thread_handle , NULL , ( void * ) ih264d_decode_picture_thread , ( void * ) ps_dec ) ; ps_dec -> u4_dec_thread_created = 1 ; } if ( ( ps_dec -> u4_num_cores == 3 ) && ( ( ps_dec -> u4_app_disable_deblk_frm == 0 ) || ps_dec -> i1_recon_in_thread3_flag ) && ( ps_dec -> u4_bs_deblk_thread_created == 0 ) ) { ps_dec -> u4_start_recon_deblk = 0 ; ithread_create ( ps_dec -> pv_bs_deblk_thread_handle , NULL , ( void * ) ih264d_recon_deblk_thread , ( void * ) ps_dec ) ; ps_dec -> u4_bs_deblk_thread_created = 1 ; } } } } else { dec_slice_struct_t * ps_parse_cur_slice ; ps_parse_cur_slice = ps_dec -> ps_dec_slice_buf + ps_dec -> u2_cur_slice_num ; if ( ps_dec -> u1_slice_header_done && ps_parse_cur_slice == ps_dec -> ps_parse_cur_slice ) { u1_num_mbs = ps_dec -> u4_num_mbs_cur_nmb ; if ( u1_num_mbs ) { ps_cur_mb_info = ps_dec -> ps_nmb_info + u1_num_mbs - 1 ; } else { if ( ps_dec -> u1_separate_parse ) { ps_cur_mb_info = ps_dec -> ps_nmb_info - 1 ; } else { ps_cur_mb_info = ps_dec -> ps_nmb_info + ps_dec -> u4_num_mbs_prev_nmb - 1 ; } } ps_dec -> u2_mby = ps_cur_mb_info -> u2_mby ; ps_dec -> u2_mbx = ps_cur_mb_info -> u2_mbx ; ps_dec -> u1_mb_ngbr_availablity = ps_cur_mb_info -> u1_mb_ngbr_availablity ; ps_dec -> pv_parse_tu_coeff_data = ps_dec -> pv_prev_mb_parse_tu_coeff_data ; ps_dec -> u2_cur_mb_addr -- ; ps_dec -> i4_submb_ofst -= SUB_BLK_SIZE ; if ( u1_num_mbs ) { if ( ps_dec -> u1_pr_sl_type == P_SLICE || ps_dec -> u1_pr_sl_type == B_SLICE ) { ps_dec -> pf_mvpred_ref_tfr_nby2mb ( ps_dec , u1_mb_idx , u1_num_mbs ) ; ps_dec -> ps_part = ps_dec -> ps_parse_part_params ; } u1_num_mbs_next = i2_pic_wdin_mbs - ps_dec -> u2_mbx - 1 ; u1_end_of_row = ( ! u1_num_mbs_next ) && ( ! ( u1_mbaff && ( u1_num_mbs & 0x01 ) ) ) ; u1_slice_end = 1 ; u1_tfr_n_mb = 1 ; ps_cur_mb_info -> u1_end_of_slice = u1_slice_end ; if ( ps_dec -> u1_separate_parse ) { ih264d_parse_tfr_nmb ( ps_dec , u1_mb_idx , u1_num_mbs , u1_num_mbs_next , u1_tfr_n_mb , u1_end_of_row ) ; ps_dec -> ps_nmb_info += u1_num_mbs ; } else { ih264d_decode_recon_tfr_nmb ( ps_dec , u1_mb_idx , u1_num_mbs , u1_num_mbs_next , u1_tfr_n_mb , u1_end_of_row ) ; } <S2SV_StartBug> ps_dec -> u1_mb_idx = 0 ; <S2SV_EndBug> ps_dec -> u4_num_mbs_cur_nmb = 0 ; } if ( ps_dec -> u2_total_mbs_coded >= ps_dec -> u2_frm_ht_in_mbs * ps_dec -> u2_frm_wd_in_mbs ) { ps_dec -> u1_pic_decode_done = 1 ; return 0 ; } ps_dec -> u2_cur_slice_num ++ ; ps_dec -> i2_prev_slice_mbx = ps_dec -> u2_mbx ; ps_dec -> i2_prev_slice_mby = ps_dec -> u2_mby ; ps_dec -> ps_parse_cur_slice ++ ; } else { ps_dec -> ps_parse_cur_slice = ps_dec -> ps_dec_slice_buf + ps_dec -> u2_cur_slice_num ; } } { WORD32 num_entries ; WORD32 size ; UWORD8 * pu1_buf ; num_entries = MIN ( MAX_FRAMES , ps_dec -> u4_num_ref_frames_at_init ) ; num_entries = 2 * ( ( 2 * num_entries ) + 1 ) ; size = num_entries * sizeof ( void * ) ; size += PAD_MAP_IDX_POC * sizeof ( void * ) ; pu1_buf = ( UWORD8 * ) ps_dec -> pv_map_ref_idx_to_poc_buf ; pu1_buf += size * ps_dec -> u2_cur_slice_num ; ps_dec -> ps_parse_cur_slice -> ppv_map_ref_idx_to_poc = ( volatile void * * ) pu1_buf ; } ps_dec -> ps_cur_slice -> u2_first_mb_in_slice = ps_dec -> u2_total_mbs_coded << u1_mbaff ; if ( ps_dec -> ps_cur_slice -> u1_field_pic_flag ) ps_dec -> u2_prv_frame_num = ps_dec -> ps_cur_slice -> u2_frame_num ; ps_dec -> ps_parse_cur_slice -> u4_first_mb_in_slice = ps_dec -> u2_total_mbs_coded << u1_mbaff ; ps_dec -> ps_parse_cur_slice -> u2_log2Y_crwd = ps_dec -> ps_cur_slice -> u2_log2Y_crwd ; if ( ps_dec -> u1_separate_parse ) { ps_dec -> ps_parse_cur_slice -> pv_tu_coeff_data_start = ps_dec -> pv_parse_tu_coeff_data ; } else { ps_dec -> pv_proc_tu_coeff_data = ps_dec -> pv_parse_tu_coeff_data ; } u1_inter_mb_type = P_MB ; u1_deblk_mb_type = D_INTER_MB ; ps_dec -> ps_cur_slice -> u1_slice_type = P_SLICE ; ps_dec -> ps_parse_cur_slice -> slice_type = P_SLICE ; ps_dec -> pf_mvpred_ref_tfr_nby2mb = ih264d_mv_pred_ref_tfr_nby2_pmb ; ps_dec -> ps_part = ps_dec -> ps_parse_part_params ; ps_dec -> u1_slice_header_done = 2 ; ps_dec -> u1_qp = ps_slice -> u1_slice_qp ; ih264d_update_qp ( ps_dec , 0 ) ; u1_mb_idx = ps_dec -> u1_mb_idx ; ps_parse_mb_data = ps_dec -> ps_parse_mb_data ; u1_num_mbs = u1_mb_idx ; u1_slice_end = 0 ; u1_tfr_n_mb = 0 ; u1_decode_nmb = 0 ; u1_num_mbsNby2 = 0 ; i2_cur_mb_addr = ps_dec -> u2_total_mbs_coded ; i2_mb_skip_run = num_mb_skip ; while ( ! u1_slice_end ) { UWORD8 u1_mb_type ; if ( i2_cur_mb_addr > ps_dec -> ps_cur_sps -> u2_max_mb_addr ) break ; ps_cur_mb_info = ps_dec -> ps_nmb_info + u1_num_mbs ; ps_dec -> u4_num_mbs_cur_nmb = u1_num_mbs ; ps_cur_mb_info -> u1_Mux = 0 ; ps_dec -> u4_num_pmbair = ( u1_num_mbs >> u1_mbaff ) ; ps_cur_deblk_mb = ps_dec -> ps_deblk_mbn + u1_num_mbs ; ps_cur_mb_info -> u1_end_of_slice = 0 ; ps_parse_mb_data -> u1_num_part = 1 ; ps_parse_mb_data -> u1_isI_mb = 0 ; if ( u1_mbaff ) ih264d_get_mb_info_cavlc_mbaff ( ps_dec , i2_cur_mb_addr , ps_cur_mb_info , i2_mb_skip_run ) ; else ih264d_get_mb_info_cavlc_nonmbaff ( ps_dec , i2_cur_mb_addr , ps_cur_mb_info , i2_mb_skip_run ) ; if ( ps_dec -> u4_app_disable_deblk_frm == 0 ) { ih264d_set_deblocking_parameters ( ps_cur_deblk_mb , ps_slice , ps_dec -> u1_mb_ngbr_availablity , ps_dec -> u1_cur_mb_fld_dec_flag ) ; } ps_dec -> i1_prev_mb_qp_delta = 0 ; ps_dec -> u1_sub_mb_num = 0 ; ps_cur_mb_info -> u1_mb_type = MB_SKIP ; ps_cur_mb_info -> u1_mb_mc_mode = PRED_16x16 ; ps_cur_mb_info -> u1_cbp = 0 ; ps_part_info = ps_dec -> ps_part ; ps_part_info -> u1_is_direct = PART_DIRECT_16x16 ; ps_part_info -> u1_sub_mb_num = 0 ; ps_dec -> ps_part ++ ; ih264d_update_nnz_for_skipmb ( ps_dec , ps_cur_mb_info , CAVLC ) ; ps_cur_mb_info -> ps_curmb -> u1_mb_type = u1_inter_mb_type ; ps_cur_deblk_mb -> u1_mb_type |= u1_deblk_mb_type ; i2_mb_skip_run -- ; ps_cur_deblk_mb -> u1_mb_qp = ps_dec -> u1_qp ; if ( u1_mbaff ) { ih264d_update_mbaff_left_nnz ( ps_dec , ps_cur_mb_info ) ; } i2_cur_mb_addr ++ ; u1_num_mbs ++ ; <S2SV_StartBug> ps_dec -> u2_total_mbs_coded ++ ; <S2SV_EndBug> u1_num_mbsNby2 ++ ; ps_parse_mb_data ++ ; u1_num_mbs_next = i2_pic_wdin_mbs - ps_dec -> u2_mbx - 1 ; u1_end_of_row = ( ! u1_num_mbs_next ) && ( ! ( u1_mbaff && ( u1_num_mbs & 0x01 ) ) ) ; u1_slice_end = ! i2_mb_skip_run ; u1_tfr_n_mb = ( u1_num_mbs == ps_dec -> u1_recon_mb_grp ) || u1_end_of_row || u1_slice_end ; u1_decode_nmb = u1_tfr_n_mb || u1_slice_end ; ps_cur_mb_info -> u1_end_of_slice = u1_slice_end ; if ( u1_decode_nmb ) { ps_dec -> pf_mvpred_ref_tfr_nby2mb ( ps_dec , u1_mb_idx , u1_num_mbs ) ; u1_num_mbsNby2 = 0 ; ps_parse_mb_data = ps_dec -> ps_parse_mb_data ; ps_dec -> ps_part = ps_dec -> ps_parse_part_params ; if ( ps_dec -> u1_separate_parse ) { ih264d_parse_tfr_nmb ( ps_dec , u1_mb_idx , u1_num_mbs , u1_num_mbs_next , u1_tfr_n_mb , u1_end_of_row ) ; ps_dec -> ps_nmb_info += u1_num_mbs ; } else { ih264d_decode_recon_tfr_nmb ( ps_dec , u1_mb_idx , u1_num_mbs , u1_num_mbs_next , u1_tfr_n_mb , u1_end_of_row ) ; } <S2SV_StartBug> if ( u1_tfr_n_mb ) <S2SV_EndBug> u1_num_mbs = 0 ; u1_mb_idx = u1_num_mbs ; ps_dec -> u1_mb_idx = u1_num_mbs ; } } ps_dec -> u4_num_mbs_cur_nmb = 0 ; ps_dec -> ps_cur_slice -> u4_mbs_in_slice = i2_cur_mb_addr - ps_dec -> ps_parse_cur_slice -> u4_first_mb_in_slice ; H264_DEC_DEBUG_PRINT ( \"Mbs<S2SV_blank>in<S2SV_blank>slice:<S2SV_blank>%d\\\\n\" , ps_dec -> ps_cur_slice -> u4_mbs_in_slice ) ; ps_dec -> u2_cur_slice_num ++ ; if ( ps_dec -> u4_first_slice_in_pic != 0 ) ps_dec -> ps_parse_cur_slice ++ ; ps_dec -> i2_prev_slice_mbx = ps_dec -> u2_mbx ; ps_dec -> i2_prev_slice_mby = ps_dec -> u2_mby ; if ( ps_dec -> u2_total_mbs_coded >= ps_dec -> u2_frm_ht_in_mbs * ps_dec -> u2_frm_wd_in_mbs ) { ps_dec -> u1_pic_decode_done = 1 ; } return 0 ; }\n","target":"<S2SV_ModStart> } ps_dec -> u2_total_mbs_coded += u1_num_mbs ; ps_dec -> <S2SV_ModStart> u1_num_mbs ++ ; <S2SV_ModEnd> u1_num_mbsNby2 ++ ; <S2SV_ModStart> ) ; } ps_dec -> u2_total_mbs_coded += u1_num_mbs ;\n","project_and_commit_id":"external@libavc/4a524d3a8ae9aa20c36430008e6bd429443f8f1d","cve_id":"CVE-2016-0816","original_address":"https://android.googlesource.com/platform/external/libavc/+/4a524d3a8ae9aa20c36430008e6bd429443f8f1d","time":"2016-03-12T21:59Z"},
	{"Unnamed: 0":1089,"cwe_id":"CWE-552","source":"CWE-552 static ssize_t _hostsock_sendto ( oe_fd_t * sock_ , const void * buf , size_t count , int flags , const struct oe_sockaddr * dest_addr , oe_socklen_t addrlen ) { ssize_t ret = - 1 ; sock_t * sock = _cast_sock ( sock_ ) ; oe_errno = 0 ; <S2SV_StartBug> if ( ! sock || ( count && ! buf ) ) <S2SV_EndBug> OE_RAISE_ERRNO ( OE_EINVAL ) ; if ( oe_syscall_sendto_ocall ( & ret , sock -> host_fd , buf , count , flags , ( struct oe_sockaddr * ) dest_addr , addrlen ) != OE_OK ) { OE_RAISE_ERRNO ( OE_EINVAL ) ; } <S2SV_StartBug> done : <S2SV_EndBug> return ret ; }\n","target":"<S2SV_ModStart> ! buf ) || count > OE_SSIZE_MAX <S2SV_ModStart> ) ; } if ( ret > ( ssize_t ) count ) { ret = - 1 ; OE_RAISE_ERRNO ( OE_EINVAL ) ; }\n","project_and_commit_id":"openenclave@openenclave/bcac8e7acb514429fee9e0b5d0c7a0308fd4d76b","cve_id":"CVE-2020-15224","original_address":"https://github.com/openenclave/openenclave/commit/bcac8e7acb514429fee9e0b5d0c7a0308fd4d76b","time":"2020-10-14T19:15Z"},
	{"Unnamed: 0":5983,"cwe_id":"CWE-119","source":"CWE-119 int vp8_refining_search_sad_c ( MACROBLOCK * x , BLOCK * b , BLOCKD * d , int_mv * ref_mv , int error_per_bit , int search_range , vp8_variance_fn_ptr_t * fn_ptr , int * mvcost [ 2 ] , int_mv * center_mv ) { MV neighbors [ 4 ] = { { - 1 , 0 } , { 0 , - 1 } , { 0 , 1 } , { 1 , 0 } } ; int i , j ; short this_row_offset , this_col_offset ; int what_stride = b -> src_stride ; int pre_stride = x -> e_mbd . pre . y_stride ; unsigned char * base_pre = x -> e_mbd . pre . y_buffer ; int in_what_stride = pre_stride ; unsigned char * what = ( * ( b -> base_src ) + b -> src ) ; unsigned char * best_address = ( unsigned char * ) ( base_pre + d -> offset + ( ref_mv -> as_mv . row * pre_stride ) + ref_mv -> as_mv . col ) ; unsigned char * check_here ; int_mv this_mv ; unsigned int bestsad ; unsigned int thissad ; int * mvsadcost [ 2 ] ; int_mv fcenter_mv ; mvsadcost [ 0 ] = x -> mvsadcost [ 0 ] ; mvsadcost [ 1 ] = x -> mvsadcost [ 1 ] ; fcenter_mv . as_mv . row = center_mv -> as_mv . row >> 3 ; fcenter_mv . as_mv . col = center_mv -> as_mv . col >> 3 ; bestsad = fn_ptr -> sdf ( what , what_stride , best_address , <S2SV_StartBug> in_what_stride , UINT_MAX ) <S2SV_EndBug> + mvsad_err_cost ( ref_mv , & fcenter_mv , mvsadcost , error_per_bit ) ; for ( i = 0 ; i < search_range ; i ++ ) { int best_site = - 1 ; for ( j = 0 ; j < 4 ; j ++ ) { this_row_offset = ref_mv -> as_mv . row + neighbors [ j ] . row ; this_col_offset = ref_mv -> as_mv . col + neighbors [ j ] . col ; if ( ( this_col_offset > x -> mv_col_min ) && ( this_col_offset < x -> mv_col_max ) && ( this_row_offset > x -> mv_row_min ) && ( this_row_offset < x -> mv_row_max ) ) { check_here = ( neighbors [ j ] . row ) * in_what_stride + neighbors [ j ] . col + best_address ; <S2SV_StartBug> thissad = fn_ptr -> sdf ( what , what_stride , check_here , in_what_stride , bestsad ) ; <S2SV_EndBug> if ( thissad < bestsad ) { this_mv . as_mv . row = this_row_offset ; this_mv . as_mv . col = this_col_offset ; thissad += mvsad_err_cost ( & this_mv , & fcenter_mv , mvsadcost , error_per_bit ) ; if ( thissad < bestsad ) { bestsad = thissad ; best_site = j ; } } } } if ( best_site == - 1 ) break ; else { ref_mv -> as_mv . row += neighbors [ best_site ] . row ; ref_mv -> as_mv . col += neighbors [ best_site ] . col ; best_address += ( neighbors [ best_site ] . row ) * in_what_stride + neighbors [ best_site ] . col ; } } this_mv . as_mv . row = ref_mv -> as_mv . row << 3 ; this_mv . as_mv . col = ref_mv -> as_mv . col << 3 ; return fn_ptr -> vf ( what , what_stride , best_address , in_what_stride , & thissad ) + mv_err_cost ( & this_mv , center_mv , mvcost , x -> errorperbit ) ; }\n","target":"<S2SV_ModStart> best_address , in_what_stride <S2SV_ModEnd> ) + mvsad_err_cost <S2SV_ModStart> check_here , in_what_stride <S2SV_ModEnd> ) ; if\n","project_and_commit_id":"external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426","cve_id":"CVE-2016-1621","original_address":"https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426","time":"2016-03-12T21:59Z"},
	{"Unnamed: 0":4385,"cwe_id":"CWE-264","source":"CWE-264 int lxc_attach ( const char * name , const char * lxcpath , lxc_attach_exec_t exec_function , void * exec_payload , lxc_attach_options_t * options , pid_t * attached_process ) { int ret , status ; pid_t init_pid , pid , attached_pid , expected ; struct lxc_proc_context_info * init_ctx ; char * cwd ; char * new_cwd ; int ipc_sockets [ 2 ] ; <S2SV_StartBug> int procfd ; <S2SV_EndBug> signed long personality ; if ( ! options ) options = & attach_static_default_options ; init_pid = lxc_cmd_get_init_pid ( name , lxcpath ) ; if ( init_pid < 0 ) { ERROR ( \"failed<S2SV_blank>to<S2SV_blank>get<S2SV_blank>the<S2SV_blank>init<S2SV_blank>pid\" ) ; return - 1 ; } init_ctx = lxc_proc_get_context_info ( init_pid ) ; if ( ! init_ctx ) { ERROR ( \"failed<S2SV_blank>to<S2SV_blank>get<S2SV_blank>context<S2SV_blank>of<S2SV_blank>the<S2SV_blank>init<S2SV_blank>process,<S2SV_blank>pid<S2SV_blank>=<S2SV_blank>%ld\" , ( long ) init_pid ) ; return - 1 ; } personality = get_personality ( name , lxcpath ) ; if ( init_ctx -> personality < 0 ) { ERROR ( \"Failed<S2SV_blank>to<S2SV_blank>get<S2SV_blank>personality<S2SV_blank>of<S2SV_blank>the<S2SV_blank>container\" ) ; lxc_proc_put_context_info ( init_ctx ) ; return - 1 ; } init_ctx -> personality = personality ; init_ctx -> container = lxc_container_new ( name , lxcpath ) ; if ( ! init_ctx -> container ) return - 1 ; if ( ! fetch_seccomp ( init_ctx -> container , options ) ) WARN ( \"Failed<S2SV_blank>to<S2SV_blank>get<S2SV_blank>seccomp<S2SV_blank>policy\" ) ; if ( ! no_new_privs ( init_ctx -> container , options ) ) WARN ( \"Could<S2SV_blank>not<S2SV_blank>determine<S2SV_blank>whether<S2SV_blank>PR_SET_NO_NEW_PRIVS<S2SV_blank>is<S2SV_blank>set.\" ) ; cwd = getcwd ( NULL , 0 ) ; if ( options -> namespaces == - 1 ) { options -> namespaces = lxc_cmd_get_clone_flags ( name , lxcpath ) ; if ( options -> namespaces == - 1 ) { ERROR ( \"failed<S2SV_blank>to<S2SV_blank>automatically<S2SV_blank>determine<S2SV_blank>the<S2SV_blank>\" \"namespaces<S2SV_blank>which<S2SV_blank>the<S2SV_blank>container<S2SV_blank>unshared\" ) ; free ( cwd ) ; lxc_proc_put_context_info ( init_ctx ) ; return - 1 ; } } ret = socketpair ( PF_LOCAL , SOCK_STREAM | SOCK_CLOEXEC , 0 , ipc_sockets ) ; if ( ret < 0 ) { SYSERROR ( \"could<S2SV_blank>not<S2SV_blank>set<S2SV_blank>up<S2SV_blank>required<S2SV_blank>IPC<S2SV_blank>mechanism<S2SV_blank>for<S2SV_blank>attaching\" ) ; free ( cwd ) ; lxc_proc_put_context_info ( init_ctx ) ; return - 1 ; } pid = fork ( ) ; if ( pid < 0 ) { SYSERROR ( \"failed<S2SV_blank>to<S2SV_blank>create<S2SV_blank>first<S2SV_blank>subprocess\" ) ; free ( cwd ) ; lxc_proc_put_context_info ( init_ctx ) ; return - 1 ; } if ( pid ) { <S2SV_StartBug> pid_t to_cleanup_pid = pid ; <S2SV_EndBug> close ( ipc_sockets [ 1 ] ) ; free ( cwd ) ; if ( options -> attach_flags & LXC_ATTACH_MOVE_TO_CGROUP ) { if ( ! cgroup_attach ( name , lxcpath , pid ) ) goto cleanup_error ; } <S2SV_StartBug> status = 0 ; <S2SV_EndBug> ret = lxc_write_nointr ( ipc_sockets [ 0 ] , & status , sizeof ( status ) ) ; if ( ret <= 0 ) { ERROR ( \"error<S2SV_blank>using<S2SV_blank>IPC<S2SV_blank>to<S2SV_blank>notify<S2SV_blank>attached<S2SV_blank>process<S2SV_blank>for<S2SV_blank>initialization<S2SV_blank>(0)\" ) ; goto cleanup_error ; } <S2SV_StartBug> ret = lxc_read_nointr_expect ( ipc_sockets [ 0 ] , & attached_pid , sizeof ( attached_pid ) , NULL ) ; <S2SV_EndBug> if ( ret <= 0 ) { <S2SV_StartBug> if ( ret != 0 ) <S2SV_EndBug> ERROR ( \"error<S2SV_blank>using<S2SV_blank>IPC<S2SV_blank>to<S2SV_blank>receive<S2SV_blank>pid<S2SV_blank>of<S2SV_blank>attached<S2SV_blank>process\" ) ; goto cleanup_error ; } <S2SV_StartBug> if ( options -> stdin_fd == 0 ) { <S2SV_EndBug> signal ( SIGINT , SIG_IGN ) ; signal ( SIGQUIT , SIG_IGN ) ; } ret = wait_for_pid ( pid ) ; if ( ret < 0 ) goto cleanup_error ; to_cleanup_pid = attached_pid ; status = 0 ; ret = lxc_write_nointr ( ipc_sockets [ 0 ] , & status , sizeof ( status ) ) ; if ( ret <= 0 ) { ERROR ( \"error<S2SV_blank>using<S2SV_blank>IPC<S2SV_blank>to<S2SV_blank>notify<S2SV_blank>attached<S2SV_blank>process<S2SV_blank>for<S2SV_blank>initialization<S2SV_blank>(0)\" ) ; goto cleanup_error ; } expected = 1 ; ret = lxc_read_nointr_expect ( ipc_sockets [ 0 ] , & status , sizeof ( status ) , & expected ) ; if ( ret <= 0 ) { if ( ret != 0 ) <S2SV_StartBug> ERROR ( \"error<S2SV_blank>using<S2SV_blank>IPC<S2SV_blank>to<S2SV_blank>receive<S2SV_blank>notification<S2SV_blank>from<S2SV_blank>attached<S2SV_blank>process<S2SV_blank>(1)\" ) ; <S2SV_EndBug> goto cleanup_error ; } status = 2 ; ret = lxc_write_nointr ( ipc_sockets [ 0 ] , & status , sizeof ( status ) ) ; if ( ret <= 0 ) { <S2SV_StartBug> ERROR ( \"error<S2SV_blank>using<S2SV_blank>IPC<S2SV_blank>to<S2SV_blank>notify<S2SV_blank>attached<S2SV_blank>process<S2SV_blank>for<S2SV_blank>initialization<S2SV_blank>(2)\" ) ; <S2SV_EndBug> goto cleanup_error ; } <S2SV_StartBug> shutdown ( ipc_sockets [ 0 ] , SHUT_RDWR ) ; <S2SV_EndBug> close ( ipc_sockets [ 0 ] ) ; lxc_proc_put_context_info ( init_ctx ) ; * attached_process = attached_pid ; return 0 ; <S2SV_StartBug> cleanup_error : <S2SV_EndBug> shutdown ( ipc_sockets [ 0 ] , SHUT_RDWR ) ; close ( ipc_sockets [ 0 ] ) ; if ( to_cleanup_pid ) ( void ) wait_for_pid ( to_cleanup_pid ) ; lxc_proc_put_context_info ( init_ctx ) ; return - 1 ; } close ( ipc_sockets [ 0 ] ) ; expected = 0 ; status = - 1 ; ret = lxc_read_nointr_expect ( ipc_sockets [ 1 ] , & status , sizeof ( status ) , & expected ) ; if ( ret <= 0 ) { ERROR ( \"error<S2SV_blank>communicating<S2SV_blank>with<S2SV_blank>child<S2SV_blank>process\" ) ; shutdown ( ipc_sockets [ 1 ] , SHUT_RDWR ) ; rexit ( - 1 ) ; } if ( ( options -> attach_flags & LXC_ATTACH_MOVE_TO_CGROUP ) && cgns_supported ( ) ) options -> namespaces |= CLONE_NEWCGROUP ; <S2SV_StartBug> procfd = open ( \"/proc\" , O_DIRECTORY | O_RDONLY ) ; <S2SV_EndBug> if ( procfd < 0 ) { SYSERROR ( \"Unable<S2SV_blank>to<S2SV_blank>open<S2SV_blank>/proc\" ) ; shutdown ( ipc_sockets [ 1 ] , SHUT_RDWR ) ; rexit ( - 1 ) ; } ret = lxc_attach_to_ns ( init_pid , options -> namespaces ) ; if ( ret < 0 ) { ERROR ( \"failed<S2SV_blank>to<S2SV_blank>enter<S2SV_blank>the<S2SV_blank>namespace\" ) ; shutdown ( ipc_sockets [ 1 ] , SHUT_RDWR ) ; rexit ( - 1 ) ; } if ( options -> initial_cwd ) new_cwd = options -> initial_cwd ; else new_cwd = cwd ; ret = chdir ( new_cwd ) ; if ( ret < 0 ) WARN ( \"could<S2SV_blank>not<S2SV_blank>change<S2SV_blank>directory<S2SV_blank>to<S2SV_blank>\\'%s\\'\" , new_cwd ) ; free ( cwd ) ; { struct attach_clone_payload payload = { . ipc_socket = ipc_sockets [ 1 ] , . options = options , . init_ctx = init_ctx , . exec_function = exec_function , . exec_payload = exec_payload , <S2SV_StartBug> . procfd = procfd <S2SV_EndBug> } ; pid = lxc_clone ( attach_child_main , & payload , CLONE_PARENT ) ; } if ( pid <= 0 ) { SYSERROR ( \"failed<S2SV_blank>to<S2SV_blank>create<S2SV_blank>subprocess\" ) ; shutdown ( ipc_sockets [ 1 ] , SHUT_RDWR ) ; rexit ( - 1 ) ; } ret = lxc_write_nointr ( ipc_sockets [ 1 ] , & pid , sizeof ( pid ) ) ; if ( ret != sizeof ( pid ) ) { ERROR ( \"error<S2SV_blank>using<S2SV_blank>IPC<S2SV_blank>to<S2SV_blank>notify<S2SV_blank>main<S2SV_blank>process<S2SV_blank>of<S2SV_blank>pid<S2SV_blank>of<S2SV_blank>the<S2SV_blank>attached<S2SV_blank>process\" ) ; shutdown ( ipc_sockets [ 1 ] , SHUT_RDWR ) ; rexit ( - 1 ) ; } rexit ( 0 ) ; }\n","target":"<S2SV_ModStart> 2 ] ; <S2SV_ModEnd> signed long personality <S2SV_ModStart> pid ) { int procfd = - 1 ; <S2SV_ModStart> cleanup_error ; } procfd = open ( \"/proc\" , O_DIRECTORY | O_RDONLY | O_CLOEXEC ) ; if ( procfd < 0 ) { SYSERROR ( \"Unable<S2SV_blank>to<S2SV_blank>open<S2SV_blank>/proc.\" <S2SV_ModEnd> ) ; goto <S2SV_ModStart> cleanup_error ; } status = 0 ; ret = lxc_write_nointr ( ipc_sockets [ 0 ] , & status <S2SV_ModEnd> , sizeof ( <S2SV_ModStart> , sizeof ( status ) <S2SV_ModEnd> ) ; if <S2SV_ModStart> 0 ) { ERROR ( \"error<S2SV_blank>using<S2SV_blank>IPC<S2SV_blank>to<S2SV_blank>notify<S2SV_blank>attached<S2SV_blank>process<S2SV_blank>for<S2SV_blank>initialization<S2SV_blank>(0)\" <S2SV_ModEnd> ) ; goto <S2SV_ModStart> cleanup_error ; } ret = lxc_read_nointr_expect ( ipc_sockets [ 0 ] , & attached_pid , sizeof ( attached_pid ) , NULL ) ; if ( ret <= 0 ) { if ( ret != 0 ) ERROR ( \"error<S2SV_blank>using<S2SV_blank>IPC<S2SV_blank>to<S2SV_blank>receive<S2SV_blank>pid<S2SV_blank>of<S2SV_blank>attached<S2SV_blank>process\" ) ; goto cleanup_error ; } <S2SV_ModStart> ) ERROR ( \"error<S2SV_blank>using<S2SV_blank>IPC<S2SV_blank>to<S2SV_blank>receive<S2SV_blank>notification<S2SV_blank>\" \"from<S2SV_blank>attached<S2SV_blank>process<S2SV_blank>(1)\" <S2SV_ModEnd> ) ; goto <S2SV_ModStart> { ERROR ( \"Error<S2SV_blank>using<S2SV_blank>IPC<S2SV_blank>to<S2SV_blank>notify<S2SV_blank>attached<S2SV_blank>process<S2SV_blank>for<S2SV_blank>\" \"initialization<S2SV_blank>(2):<S2SV_blank>%s.\" , strerror ( errno ) <S2SV_ModEnd> ) ; goto <S2SV_ModStart> cleanup_error ; } expected = 3 ; ret = lxc_read_nointr_expect ( ipc_sockets [ 0 ] , & status , sizeof ( status ) , & expected ) ; if ( ret <= 0 ) { ERROR ( \"Error<S2SV_blank>using<S2SV_blank>IPC<S2SV_blank>for<S2SV_blank>the<S2SV_blank>child<S2SV_blank>to<S2SV_blank>tell<S2SV_blank>us<S2SV_blank>to<S2SV_blank>open<S2SV_blank>LSM<S2SV_blank>fd<S2SV_blank>(3):<S2SV_blank>%s.\" , strerror ( errno ) ) ; goto cleanup_error ; } if ( ( options -> namespaces & CLONE_NEWNS ) && ( options -> attach_flags & LXC_ATTACH_LSM ) && init_ctx -> lsm_label ) { int on_exec , labelfd ; on_exec = options -> attach_flags & LXC_ATTACH_LSM_EXEC ? 1 : 0 ; labelfd = lsm_openat ( procfd , attached_pid , on_exec ) ; if ( labelfd < 0 ) goto cleanup_error ; ret = lxc_abstract_unix_send_fd ( ipc_sockets [ 0 ] , labelfd , NULL , 0 ) ; if ( ret <= 0 ) { ERROR ( \"Error<S2SV_blank>using<S2SV_blank>IPC<S2SV_blank>to<S2SV_blank>send<S2SV_blank>child<S2SV_blank>LSM<S2SV_blank>fd<S2SV_blank>(4):<S2SV_blank>%s.\" , strerror ( errno ) ) ; goto cleanup_error ; } } <S2SV_ModStart> ; cleanup_error : if ( procfd >= 0 ) close ( procfd ) ; <S2SV_ModStart> |= CLONE_NEWCGROUP ; <S2SV_ModEnd> ret = lxc_attach_to_ns <S2SV_ModStart> = exec_payload , <S2SV_ModEnd> } ; pid\n","project_and_commit_id":"lxc@lxc/81f466d05f2a89cb4f122ef7f593ff3f279b165c","cve_id":"CVE-2016-8649","original_address":"https://github.com/lxc/lxc/commit/81f466d05f2a89cb4f122ef7f593ff3f279b165c","time":"2017-05-01T06:59Z"},
	{"Unnamed: 0":2606,"cwe_id":"CWE-119","source":"CWE-119 SQLRETURN SQLSetDescFieldW ( SQLHDESC descriptor_handle , SQLSMALLINT rec_number , SQLSMALLINT field_identifier , SQLPOINTER value , SQLINTEGER buffer_length ) { DMHDESC descriptor = ( DMHDESC ) descriptor_handle ; SQLRETURN ret ; SQLCHAR s1 [ 100 + LOG_MESSAGE_LEN ] ; int isStrField = 0 ; if ( ! __validate_desc ( descriptor ) ) { dm_log_write ( __FILE__ , __LINE__ , LOG_INFO , LOG_INFO , \"Error:<S2SV_blank>SQL_INVALID_HANDLE\" ) ; # ifdef WITH_HANDLE_REDIRECT { DMHDESC parent_desc ; parent_desc = find_parent_handle ( descriptor , SQL_HANDLE_DESC ) ; if ( parent_desc ) { dm_log_write ( __FILE__ , __LINE__ , LOG_INFO , LOG_INFO , \"Info:<S2SV_blank>found<S2SV_blank>parent<S2SV_blank>handle\" ) ; if ( CHECK_SQLSETDESCFIELDW ( parent_desc -> connection ) ) { dm_log_write ( __FILE__ , __LINE__ , LOG_INFO , LOG_INFO , \"Info:<S2SV_blank>calling<S2SV_blank>redirected<S2SV_blank>driver<S2SV_blank>function\" ) ; return SQLSETDESCFIELDW ( parent_desc -> connection , descriptor , rec_number , field_identifier , value , buffer_length ) ; } } } # endif return SQL_INVALID_HANDLE ; } function_entry ( descriptor ) ; if ( log_info . log_flag ) { <S2SV_StartBug> sprintf ( descriptor -> msg , \"\\\\n\\\\t\\\\tEntry:\\\\\\n<S2SV_blank>\\\\n\\\\t\\\\t\\\\tDescriptor<S2SV_blank>=<S2SV_blank>%p\\\\\\n<S2SV_blank>\\\\n\\\\t\\\\t\\\\tRec<S2SV_blank>Number<S2SV_blank>=<S2SV_blank>%d\\\\\\n<S2SV_blank>\\\\n\\\\t\\\\t\\\\tField<S2SV_blank>Ident<S2SV_blank>=<S2SV_blank>%s\\\\\\n<S2SV_blank>\\\\n\\\\t\\\\t\\\\tValue<S2SV_blank>=<S2SV_blank>%p\\\\\\n<S2SV_blank>\\\\n\\\\t\\\\t\\\\tBuffer<S2SV_blank>Length<S2SV_blank>=<S2SV_blank>%d\" , <S2SV_EndBug> descriptor , rec_number , __desc_attr_as_string ( s1 , field_identifier ) , value , ( int ) buffer_length ) ; dm_log_write ( __FILE__ , __LINE__ , LOG_INFO , LOG_INFO , descriptor -> msg ) ; } thread_protect ( SQL_HANDLE_DESC , descriptor ) ; if ( descriptor -> connection -> state < STATE_C4 ) { dm_log_write ( __FILE__ , __LINE__ , LOG_INFO , LOG_INFO , \"Error:<S2SV_blank>HY010\" ) ; __post_internal_error ( & descriptor -> error , ERROR_HY010 , NULL , descriptor -> connection -> environment -> requested_version ) ; return function_return_nodrv ( SQL_HANDLE_DESC , descriptor , SQL_ERROR ) ; } if ( __check_stmt_from_desc ( descriptor , STATE_S8 ) || __check_stmt_from_desc ( descriptor , STATE_S9 ) || __check_stmt_from_desc ( descriptor , STATE_S10 ) || __check_stmt_from_desc ( descriptor , STATE_S11 ) || __check_stmt_from_desc ( descriptor , STATE_S12 ) || __check_stmt_from_desc ( descriptor , STATE_S13 ) || __check_stmt_from_desc ( descriptor , STATE_S14 ) || __check_stmt_from_desc ( descriptor , STATE_S15 ) ) { dm_log_write ( __FILE__ , __LINE__ , LOG_INFO , LOG_INFO , \"Error:<S2SV_blank>HY010\" ) ; __post_internal_error ( & descriptor -> error , ERROR_HY010 , NULL , descriptor -> connection -> environment -> requested_version ) ; return function_return_nodrv ( SQL_HANDLE_DESC , descriptor , SQL_ERROR ) ; } if ( rec_number < 0 ) { __post_internal_error ( & descriptor -> error , ERROR_07009 , NULL , descriptor -> connection -> environment -> requested_version ) ; return function_return_nodrv ( SQL_HANDLE_DESC , descriptor , SQL_ERROR ) ; } switch ( field_identifier ) { case SQL_DESC_ALLOC_TYPE : case SQL_DESC_ARRAY_SIZE : case SQL_DESC_ARRAY_STATUS_PTR : case SQL_DESC_BIND_OFFSET_PTR : case SQL_DESC_BIND_TYPE : case SQL_DESC_COUNT : case SQL_DESC_ROWS_PROCESSED_PTR : case SQL_DESC_AUTO_UNIQUE_VALUE : case SQL_DESC_CASE_SENSITIVE : case SQL_DESC_CONCISE_TYPE : case SQL_DESC_DATA_PTR : case SQL_DESC_DATETIME_INTERVAL_CODE : case SQL_DESC_DATETIME_INTERVAL_PRECISION : case SQL_DESC_DISPLAY_SIZE : case SQL_DESC_FIXED_PREC_SCALE : case SQL_DESC_INDICATOR_PTR : case SQL_DESC_LENGTH : case SQL_DESC_NULLABLE : case SQL_DESC_NUM_PREC_RADIX : case SQL_DESC_OCTET_LENGTH : case SQL_DESC_OCTET_LENGTH_PTR : case SQL_DESC_PARAMETER_TYPE : case SQL_DESC_PRECISION : case SQL_DESC_ROWVER : case SQL_DESC_SCALE : case SQL_DESC_SEARCHABLE : case SQL_DESC_TYPE : case SQL_DESC_UNNAMED : case SQL_DESC_UNSIGNED : case SQL_DESC_UPDATABLE : isStrField = 0 ; break ; case SQL_DESC_BASE_COLUMN_NAME : case SQL_DESC_BASE_TABLE_NAME : case SQL_DESC_CATALOG_NAME : case SQL_DESC_LABEL : case SQL_DESC_LITERAL_PREFIX : case SQL_DESC_LITERAL_SUFFIX : case SQL_DESC_LOCAL_TYPE_NAME : case SQL_DESC_NAME : case SQL_DESC_SCHEMA_NAME : case SQL_DESC_TABLE_NAME : case SQL_DESC_TYPE_NAME : isStrField = 1 ; break ; default : isStrField = buffer_length != SQL_IS_POINTER && buffer_length != SQL_IS_INTEGER && buffer_length != SQL_IS_UINTEGER && buffer_length != SQL_IS_SMALLINT && buffer_length != SQL_IS_USMALLINT ; } if ( isStrField && buffer_length < 0 && buffer_length != SQL_NTS ) { __post_internal_error ( & descriptor -> error , ERROR_HY090 , NULL , descriptor -> connection -> environment -> requested_version ) ; return function_return_nodrv ( SQL_HANDLE_DESC , descriptor , SQL_ERROR ) ; } <S2SV_StartBug> if ( field_identifier == SQL_DESC_COUNT && ( SQLINTEGER ) value < 0 ) <S2SV_EndBug> { __post_internal_error ( & descriptor -> error , ERROR_07009 , NULL , descriptor -> connection -> environment -> requested_version ) ; return function_return_nodrv ( SQL_HANDLE_DESC , descriptor , SQL_ERROR ) ; } <S2SV_StartBug> if ( field_identifier == SQL_DESC_PARAMETER_TYPE && value != SQL_PARAM_INPUT <S2SV_EndBug> <S2SV_StartBug> && value != SQL_PARAM_OUTPUT && value != SQL_PARAM_INPUT_OUTPUT && <S2SV_EndBug> <S2SV_StartBug> value != SQL_PARAM_INPUT_OUTPUT_STREAM && value != SQL_PARAM_OUTPUT_STREAM ) <S2SV_EndBug> { __post_internal_error ( & descriptor -> error , ERROR_HY105 , NULL , descriptor -> connection -> environment -> requested_version ) ; return function_return_nodrv ( SQL_HANDLE_DESC , descriptor , SQL_ERROR ) ; } if ( descriptor -> connection -> unicode_driver || CHECK_SQLSETDESCFIELDW ( descriptor -> connection ) ) { if ( ! CHECK_SQLSETDESCFIELDW ( descriptor -> connection ) ) { dm_log_write ( __FILE__ , __LINE__ , LOG_INFO , LOG_INFO , \"Error:<S2SV_blank>IM001\" ) ; __post_internal_error ( & descriptor -> error , ERROR_IM001 , NULL , descriptor -> connection -> environment -> requested_version ) ; return function_return_nodrv ( SQL_HANDLE_DESC , descriptor , SQL_ERROR ) ; } ret = SQLSETDESCFIELDW ( descriptor -> connection , descriptor -> driver_desc , rec_number , field_identifier , value , buffer_length ) ; if ( log_info . log_flag ) { sprintf ( descriptor -> msg , \"\\\\n\\\\t\\\\tExit:[%s]\" , __get_return_status ( ret , s1 ) ) ; dm_log_write ( __FILE__ , __LINE__ , LOG_INFO , LOG_INFO , descriptor -> msg ) ; } } else { SQLCHAR * ascii_str = NULL ; if ( ! CHECK_SQLSETDESCFIELD ( descriptor -> connection ) ) { dm_log_write ( __FILE__ , __LINE__ , LOG_INFO , LOG_INFO , \"Error:<S2SV_blank>IM001\" ) ; __post_internal_error ( & descriptor -> error , ERROR_IM001 , NULL , descriptor -> connection -> environment -> requested_version ) ; return function_return_nodrv ( SQL_HANDLE_DESC , descriptor , SQL_ERROR ) ; } switch ( field_identifier ) { case SQL_DESC_NAME : ascii_str = ( SQLCHAR * ) unicode_to_ansi_alloc ( value , buffer_length , descriptor -> connection , NULL ) ; value = ascii_str ; buffer_length = strlen ( ( char * ) ascii_str ) ; break ; default : break ; } ret = SQLSETDESCFIELD ( descriptor -> connection , descriptor -> driver_desc , rec_number , field_identifier , value , buffer_length ) ; if ( log_info . log_flag ) { sprintf ( descriptor -> msg , \"\\\\n\\\\t\\\\tExit:[%s]\" , __get_return_status ( ret , s1 ) ) ; dm_log_write ( __FILE__ , __LINE__ , LOG_INFO , LOG_INFO , descriptor -> msg ) ; } if ( ascii_str ) { free ( ascii_str ) ; } } return function_return ( SQL_HANDLE_DESC , descriptor , ret ) ; }\n","target":"<S2SV_ModStart> -> msg , \"\\\\n\\\\t\\\\tEntry:\\\\\\n\\\\n\\\\t\\\\t\\\\tDescriptor<S2SV_blank>=<S2SV_blank>%p\\\\\\n\\\\n\\\\t\\\\t\\\\tRec<S2SV_blank>Number<S2SV_blank>=<S2SV_blank>%d\\\\\\n\\\\n\\\\t\\\\t\\\\tField<S2SV_blank>Ident<S2SV_blank>=<S2SV_blank>%s\\\\\\n\\\\n\\\\t\\\\t\\\\tValue<S2SV_blank>=<S2SV_blank>%p\\\\\\n\\\\n\\\\t\\\\t\\\\tBuffer<S2SV_blank>Length<S2SV_blank>=<S2SV_blank>%d\" <S2SV_ModEnd> , descriptor , <S2SV_ModStart> SQL_DESC_COUNT && ( intptr_t <S2SV_ModEnd> ) value < <S2SV_ModStart> == SQL_DESC_PARAMETER_TYPE && ( intptr_t ) <S2SV_ModStart> != SQL_PARAM_INPUT && ( intptr_t ) <S2SV_ModStart> != SQL_PARAM_OUTPUT && ( intptr_t ) <S2SV_ModStart> != SQL_PARAM_INPUT_OUTPUT && ( intptr_t ) <S2SV_ModStart> != SQL_PARAM_INPUT_OUTPUT_STREAM && ( intptr_t )\n","project_and_commit_id":"lurcher@unixODBC/45ef78e037f578b15fc58938a3a3251655e71d6f","cve_id":"CVE-2018-7485","original_address":"https://github.com/lurcher/unixODBC/commit/45ef78e037f578b15fc58938a3a3251655e71d6f#diff-d52750c7ba4e594410438569d8e2963aL24","time":"2018-02-26T14:29Z"},
	{"Unnamed: 0":5394,"cwe_id":"CWE-20","source":"CWE-20 static INT AirPDcapScanForKeys ( PAIRPDCAP_CONTEXT ctx , const guint8 * data , const guint mac_header_len , const guint tot_len , AIRPDCAP_SEC_ASSOCIATION_ID id ) { const UCHAR * addr ; guint bodyLength ; PAIRPDCAP_SEC_ASSOCIATION sta_sa ; PAIRPDCAP_SEC_ASSOCIATION sa ; guint offset = 0 ; const guint8 dot1x_header [ ] = { 0xAA , 0xAA , 0x03 , 0x00 , 0x00 , 0x00 , 0x88 , 0x8E } ; const guint8 bt_dot1x_header [ ] = { 0xAA , 0xAA , 0x03 , 0x00 , 0x19 , 0x58 , 0x00 , 0x03 } ; const guint8 tdls_header [ ] = { 0xAA , 0xAA , 0x03 , 0x00 , 0x00 , 0x00 , 0x89 , 0x0D , 0x02 , 0X0C } ; const EAPOL_RSN_KEY * pEAPKey ; # ifdef _DEBUG # define MSGBUF_LEN 255 CHAR msgbuf [ MSGBUF_LEN ] ; # endif AIRPDCAP_DEBUG_TRACE_START ( \"AirPDcapScanForKeys\" ) ; offset = mac_header_len ; if ( memcmp ( data + offset , dot1x_header , 8 ) == 0 || memcmp ( data + offset , bt_dot1x_header , 8 ) == 0 ) { AIRPDCAP_DEBUG_PRINT_LINE ( \"AirPDcapScanForKeys\" , \"Authentication:<S2SV_blank>EAPOL<S2SV_blank>packet\" , AIRPDCAP_DEBUG_LEVEL_3 ) ; offset += 8 ; if ( data [ offset + 1 ] != 3 ) { AIRPDCAP_DEBUG_PRINT_LINE ( \"AirPDcapScanForKeys\" , \"Not<S2SV_blank>EAPOL-Key\" , AIRPDCAP_DEBUG_LEVEL_3 ) ; return AIRPDCAP_RET_NO_VALID_HANDSHAKE ; } bodyLength = pntoh16 ( data + offset + 2 ) ; <S2SV_StartBug> if ( ( tot_len - offset - 4 ) < bodyLength ) { <S2SV_EndBug> AIRPDCAP_DEBUG_PRINT_LINE ( \"AirPDcapScanForKeys\" , \"EAPOL<S2SV_blank>body<S2SV_blank>too<S2SV_blank>short\" , AIRPDCAP_DEBUG_LEVEL_3 ) ; return AIRPDCAP_RET_NO_VALID_HANDSHAKE ; } offset += 4 ; pEAPKey = ( const EAPOL_RSN_KEY * ) ( data + offset ) ; if ( pEAPKey -> type != AIRPDCAP_RSN_WPA2_KEY_DESCRIPTOR && pEAPKey -> type != AIRPDCAP_RSN_WPA_KEY_DESCRIPTOR ) { AIRPDCAP_DEBUG_PRINT_LINE ( \"AirPDcapScanForKeys\" , \"Not<S2SV_blank>valid<S2SV_blank>key<S2SV_blank>descriptor<S2SV_blank>type\" , AIRPDCAP_DEBUG_LEVEL_3 ) ; return AIRPDCAP_RET_NO_VALID_HANDSHAKE ; } offset += 1 ; sa = AirPDcapGetSaPtr ( ctx , & id ) ; if ( sa == NULL ) { AIRPDCAP_DEBUG_PRINT_LINE ( \"AirPDcapScanForKeys\" , \"No<S2SV_blank>SA<S2SV_blank>for<S2SV_blank>BSSID<S2SV_blank>found\" , AIRPDCAP_DEBUG_LEVEL_3 ) ; return AIRPDCAP_RET_REQ_DATA ; } if ( AirPDcapRsna4WHandshake ( ctx , data , sa , offset , tot_len ) == AIRPDCAP_RET_SUCCESS_HANDSHAKE ) return AIRPDCAP_RET_SUCCESS_HANDSHAKE ; if ( mac_header_len + GROUP_KEY_PAYLOAD_LEN_MIN > tot_len ) { AIRPDCAP_DEBUG_PRINT_LINE ( \"AirPDcapScanForKeys\" , \"Message<S2SV_blank>too<S2SV_blank>short<S2SV_blank>for<S2SV_blank>Group<S2SV_blank>Key\" , AIRPDCAP_DEBUG_LEVEL_3 ) ; return AIRPDCAP_RET_NO_VALID_HANDSHAKE ; } if ( AIRPDCAP_EAP_KEY ( data [ offset + 1 ] ) != 0 || AIRPDCAP_EAP_ACK ( data [ offset + 1 ] ) != 1 || AIRPDCAP_EAP_MIC ( data [ offset ] ) != 1 || AIRPDCAP_EAP_SEC ( data [ offset ] ) != 1 ) { AIRPDCAP_DEBUG_PRINT_LINE ( \"AirPDcapScanForKeys\" , \"Key<S2SV_blank>bitfields<S2SV_blank>not<S2SV_blank>correct<S2SV_blank>for<S2SV_blank>Group<S2SV_blank>Key\" , AIRPDCAP_DEBUG_LEVEL_3 ) ; return AIRPDCAP_RET_NO_VALID_HANDSHAKE ; } memcpy ( id . sta , broadcast_mac , AIRPDCAP_MAC_LEN ) ; sa = AirPDcapGetSaPtr ( ctx , & id ) ; if ( sa == NULL ) { return AIRPDCAP_RET_REQ_DATA ; } if ( ( addr = AirPDcapGetStaAddress ( ( const AIRPDCAP_MAC_FRAME_ADDR4 * ) ( data ) ) ) != NULL ) { memcpy ( id . sta , addr , AIRPDCAP_MAC_LEN ) ; # ifdef _DEBUG g_snprintf ( msgbuf , MSGBUF_LEN , \"ST_MAC:<S2SV_blank>%2X.%2X.%2X.%2X.%2X.%2X\\\\t\" , id . sta [ 0 ] , id . sta [ 1 ] , id . sta [ 2 ] , id . sta [ 3 ] , id . sta [ 4 ] , id . sta [ 5 ] ) ; # endif AIRPDCAP_DEBUG_PRINT_LINE ( \"AirPDcapScanForKeys\" , msgbuf , AIRPDCAP_DEBUG_LEVEL_3 ) ; } else { AIRPDCAP_DEBUG_PRINT_LINE ( \"AirPDcapScanForKeys\" , \"SA<S2SV_blank>not<S2SV_blank>found\" , AIRPDCAP_DEBUG_LEVEL_5 ) ; return AIRPDCAP_RET_REQ_DATA ; } sta_sa = AirPDcapGetSaPtr ( ctx , & id ) ; if ( sta_sa == NULL ) { return AIRPDCAP_RET_REQ_DATA ; } return ( AirPDcapDecryptWPABroadcastKey ( pEAPKey , sta_sa -> wpa . ptk + 16 , sa , tot_len - offset + 1 ) ) ; } else if ( memcmp ( data + offset , tdls_header , 10 ) == 0 ) { const guint8 * initiator , * responder ; guint8 action ; guint status , offset_rsne = 0 , offset_fte = 0 , offset_link = 0 , offset_timeout = 0 ; AIRPDCAP_DEBUG_PRINT_LINE ( \"AirPDcapScanForKeys\" , \"Authentication:<S2SV_blank>TDLS<S2SV_blank>Action<S2SV_blank>Frame\" , AIRPDCAP_DEBUG_LEVEL_3 ) ; offset += 10 ; action = data [ offset ] ; if ( action != 1 && action != 2 ) { AIRPDCAP_DEBUG_PRINT_LINE ( \"AirPDcapScanForKeys\" , \"Not<S2SV_blank>Response<S2SV_blank>nor<S2SV_blank>confirm\" , AIRPDCAP_DEBUG_LEVEL_3 ) ; return AIRPDCAP_RET_NO_VALID_HANDSHAKE ; } offset ++ ; status = pntoh16 ( data + offset ) ; if ( status != 0 ) { AIRPDCAP_DEBUG_PRINT_LINE ( \"AirPDcapScanForKeys\" , \"TDLS<S2SV_blank>setup<S2SV_blank>not<S2SV_blank>successfull\" , AIRPDCAP_DEBUG_LEVEL_3 ) ; return AIRPDCAP_RET_NO_VALID_HANDSHAKE ; } offset += 5 ; while ( offset < ( tot_len - 2 ) ) { if ( data [ offset ] == 48 ) { offset_rsne = offset ; } else if ( data [ offset ] == 55 ) { offset_fte = offset ; } else if ( data [ offset ] == 56 ) { offset_timeout = offset ; } else if ( data [ offset ] == 101 ) { offset_link = offset ; } if ( tot_len < offset + data [ offset + 1 ] + 2 ) { return AIRPDCAP_RET_NO_VALID_HANDSHAKE ; } offset += data [ offset + 1 ] + 2 ; } if ( offset_rsne == 0 || offset_fte == 0 || offset_timeout == 0 || offset_link == 0 ) { AIRPDCAP_DEBUG_PRINT_LINE ( \"AirPDcapScanForKeys\" , \"Cannot<S2SV_blank>Find<S2SV_blank>all<S2SV_blank>necessary<S2SV_blank>IEs\" , AIRPDCAP_DEBUG_LEVEL_3 ) ; return AIRPDCAP_RET_NO_VALID_HANDSHAKE ; } AIRPDCAP_DEBUG_PRINT_LINE ( \"AirPDcapScanForKeys\" , \"Found<S2SV_blank>RSNE/Fast<S2SV_blank>BSS/Timeout<S2SV_blank>Interval/Link<S2SV_blank>IEs\" , AIRPDCAP_DEBUG_LEVEL_3 ) ; initiator = & data [ offset_link + 8 ] ; responder = & data [ offset_link + 14 ] ; if ( memcmp ( initiator , responder , AIRPDCAP_MAC_LEN ) < 0 ) { memcpy ( id . sta , initiator , AIRPDCAP_MAC_LEN ) ; memcpy ( id . bssid , responder , AIRPDCAP_MAC_LEN ) ; } else { memcpy ( id . sta , responder , AIRPDCAP_MAC_LEN ) ; memcpy ( id . bssid , initiator , AIRPDCAP_MAC_LEN ) ; } sa = AirPDcapGetSaPtr ( ctx , & id ) ; if ( sa == NULL ) { return AIRPDCAP_RET_REQ_DATA ; } if ( sa -> validKey ) { if ( memcmp ( sa -> wpa . nonce , data + offset_fte + 52 , AIRPDCAP_WPA_NONCE_LEN ) == 0 ) { return AIRPDCAP_RET_SUCCESS_HANDSHAKE ; } else { AIRPDCAP_SEC_ASSOCIATION * tmp_sa = g_new ( AIRPDCAP_SEC_ASSOCIATION , 1 ) ; memcpy ( tmp_sa , sa , sizeof ( AIRPDCAP_SEC_ASSOCIATION ) ) ; sa -> next = tmp_sa ; sa -> validKey = FALSE ; } } if ( AirPDcapTDLSDeriveKey ( sa , data , offset_rsne , offset_fte , offset_timeout , offset_link , action ) == AIRPDCAP_RET_SUCCESS ) { AIRPDCAP_DEBUG_TRACE_END ( \"AirPDcapScanForKeys\" ) ; return AIRPDCAP_RET_SUCCESS_HANDSHAKE ; } } else { AIRPDCAP_DEBUG_PRINT_LINE ( \"AirPDcapScanForKeys\" , \"Skipping:<S2SV_blank>not<S2SV_blank>an<S2SV_blank>EAPOL<S2SV_blank>packet\" , AIRPDCAP_DEBUG_LEVEL_3 ) ; } AIRPDCAP_DEBUG_TRACE_END ( \"AirPDcapScanForKeys\" ) ; return AIRPDCAP_RET_NO_VALID_HANDSHAKE ; }\n","target":"<S2SV_ModStart> if ( ( ( <S2SV_ModStart> ) < bodyLength ) || ( bodyLength < sizeof ( EAPOL_RSN_KEY ) )\n","project_and_commit_id":"wireshark@wireshark/9b0b20b8d5f8c9f7839d58ff6c5900f7e19283b4","cve_id":"CVE-2016-5351","original_address":"https://github.com/wireshark/wireshark/commit/9b0b20b8d5f8c9f7839d58ff6c5900f7e19283b4","time":"2016-08-07T16:59Z"},
	{"Unnamed: 0":2782,"cwe_id":"CWE-362","source":"CWE-362 static void sctp_generate_timeout_event ( struct sctp_association * asoc , sctp_event_timeout_t timeout_type ) { <S2SV_StartBug> struct net * net = sock_net ( asoc -> base . sk ) ; <S2SV_EndBug> int error = 0 ; <S2SV_StartBug> bh_lock_sock ( asoc -> base . sk ) ; <S2SV_EndBug> <S2SV_StartBug> if ( sock_owned_by_user ( asoc -> base . sk ) ) { <S2SV_EndBug> pr_debug ( \"%s:<S2SV_blank>sock<S2SV_blank>is<S2SV_blank>busy:<S2SV_blank>timer<S2SV_blank>%d\\\\n\" , __func__ , timeout_type ) ; if ( ! mod_timer ( & asoc -> timers [ timeout_type ] , jiffies + ( HZ / 20 ) ) ) sctp_association_hold ( asoc ) ; goto out_unlock ; } if ( asoc -> base . dead ) goto out_unlock ; error = sctp_do_sm ( net , SCTP_EVENT_T_TIMEOUT , SCTP_ST_TIMEOUT ( timeout_type ) , asoc -> state , asoc -> ep , asoc , ( void * ) timeout_type , GFP_ATOMIC ) ; if ( error ) <S2SV_StartBug> asoc -> base . sk -> sk_err = - error ; <S2SV_EndBug> out_unlock : <S2SV_StartBug> bh_unlock_sock ( asoc -> base . sk ) ; <S2SV_EndBug> sctp_association_put ( asoc ) ; }\n","target":"<S2SV_ModStart> ) { struct sock * sk = asoc -> base . sk ; struct <S2SV_ModStart> = sock_net ( <S2SV_ModEnd> sk ) ; <S2SV_ModStart> ; bh_lock_sock ( <S2SV_ModEnd> sk ) ; <S2SV_ModStart> ( sock_owned_by_user ( <S2SV_ModEnd> sk ) ) <S2SV_ModStart> ( error ) <S2SV_ModEnd> sk -> sk_err <S2SV_ModStart> : bh_unlock_sock ( <S2SV_ModEnd> sk ) ;\n","project_and_commit_id":"torvalds@linux/635682a14427d241bab7bbdeebb48a7d7b91638e","cve_id":"CVE-2015-8767","original_address":"https://github.com/torvalds/linux/commit/635682a14427d241bab7bbdeebb48a7d7b91638e","time":"2016-02-08T03:59Z"},
	{"Unnamed: 0":4863,"cwe_id":"CWE-399","source":"CWE-399 static void hugetlb_vm_op_close ( struct vm_area_struct * vma ) { struct hstate * h = hstate_vma ( vma ) ; <S2SV_StartBug> struct resv_map * reservations = vma_resv_map ( vma ) ; <S2SV_EndBug> unsigned long reserve ; unsigned long start ; unsigned long end ; if ( reservations ) { start = vma_hugecache_offset ( h , vma , vma -> vm_start ) ; end = vma_hugecache_offset ( h , vma , vma -> vm_end ) ; reserve = ( end - start ) - region_count ( & reservations -> regions , start , end ) ; kref_put ( & reservations -> refs , resv_map_release ) ; if ( reserve ) { hugetlb_acct_memory ( h , - reserve ) ; <S2SV_StartBug> hugetlb_put_quota ( vma -> vm_file -> f_mapping , reserve ) ; <S2SV_EndBug> } } }\n","target":"<S2SV_ModStart> reservations = vma_resv_map ( vma ) ; struct hugepage_subpool * spool = subpool_vma <S2SV_ModStart> reserve ) ; hugepage_subpool_put_pages ( spool <S2SV_ModEnd> , reserve )\n","project_and_commit_id":"torvalds@linux/90481622d75715bfcb68501280a917dbfe516029","cve_id":"CVE-2012-2133","original_address":"https://github.com/torvalds/linux/commit/90481622d75715bfcb68501280a917dbfe516029","time":"2012-07-03T16:40Z"},
	{"Unnamed: 0":4561,"cwe_id":"CWE-772","source":"CWE-772 static Image * ReadPALMImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { Image * image ; MagickBooleanType status ; MagickOffsetType totalOffset , seekNextDepth ; PixelInfo transpix ; Quantum index ; register ssize_t i , x ; register Quantum * q ; size_t bytes_per_row , flags , bits_per_pixel , version , nextDepthOffset , transparentIndex , compressionType , byte , mask , redbits , greenbits , bluebits , one , pad , size , bit ; ssize_t count , y ; unsigned char <S2SV_StartBug> * lastrow , <S2SV_EndBug> * one_row , * ptr ; unsigned short color16 ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickCoreSignature ) ; if ( image_info -> debug != MagickFalse ) ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , \"%s\" , image_info -> filename ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickCoreSignature ) ; image = AcquireImage ( image_info , exception ) ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) { ( void ) DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } totalOffset = 0 ; do { image -> columns = ReadBlobMSBShort ( image ) ; image -> rows = ReadBlobMSBShort ( image ) ; if ( EOFBlob ( image ) != MagickFalse ) ThrowReaderException ( CorruptImageError , \"ImproperImageHeader\" ) ; if ( ( image -> columns == 0 ) || ( image -> rows == 0 ) ) ThrowReaderException ( CorruptImageError , \"NegativeOrZeroImageSize\" ) ; status = SetImageExtent ( image , image -> columns , image -> rows , exception ) ; if ( status == MagickFalse ) return ( DestroyImageList ( image ) ) ; bytes_per_row = ReadBlobMSBShort ( image ) ; flags = ReadBlobMSBShort ( image ) ; bits_per_pixel = ( size_t ) ReadBlobByte ( image ) ; if ( ( bits_per_pixel != 1 ) && ( bits_per_pixel != 2 ) && ( bits_per_pixel != 4 ) && ( bits_per_pixel != 8 ) && ( bits_per_pixel != 16 ) ) ThrowReaderException ( CorruptImageError , \"UnrecognizedBitsPerPixel\" ) ; version = ( size_t ) ReadBlobByte ( image ) ; if ( ( version != 0 ) && ( version != 1 ) && ( version != 2 ) ) ThrowReaderException ( CorruptImageError , \"FileFormatVersionMismatch\" ) ; nextDepthOffset = ( size_t ) ReadBlobMSBShort ( image ) ; transparentIndex = ( size_t ) ReadBlobByte ( image ) ; compressionType = ( size_t ) ReadBlobByte ( image ) ; if ( ( compressionType != PALM_COMPRESSION_NONE ) && ( compressionType != PALM_COMPRESSION_SCANLINE ) && ( compressionType != PALM_COMPRESSION_RLE ) ) ThrowReaderException ( CorruptImageError , \"UnrecognizedImageCompression\" ) ; pad = ReadBlobMSBShort ( image ) ; ( void ) pad ; one = 1 ; if ( ( bits_per_pixel < 16 ) && ( AcquireImageColormap ( image , one << bits_per_pixel , exception ) == MagickFalse ) ) ThrowReaderException ( ResourceLimitError , \"MemoryAllocationFailed\" ) ; GetPixelInfo ( image , & transpix ) ; if ( bits_per_pixel == 16 ) { redbits = ( size_t ) ReadBlobByte ( image ) ; ( void ) redbits ; greenbits = ( size_t ) ReadBlobByte ( image ) ; ( void ) greenbits ; bluebits = ( size_t ) ReadBlobByte ( image ) ; ( void ) bluebits ; ReadBlobByte ( image ) ; ReadBlobByte ( image ) ; transpix . red = ( double ) ( QuantumRange * ReadBlobByte ( image ) / 31 ) ; transpix . green = ( double ) ( QuantumRange * ReadBlobByte ( image ) / 63 ) ; transpix . blue = ( double ) ( QuantumRange * ReadBlobByte ( image ) / 31 ) ; } if ( bits_per_pixel == 8 ) { ssize_t index ; if ( flags & PALM_HAS_COLORMAP_FLAG ) { count = ( ssize_t ) ReadBlobMSBShort ( image ) ; for ( i = 0 ; i < ( ssize_t ) count ; i ++ ) { ReadBlobByte ( image ) ; index = ConstrainColormapIndex ( image , 255 - i , exception ) ; image -> colormap [ index ] . red = ( MagickRealType ) ScaleCharToQuantum ( ( unsigned char ) ReadBlobByte ( image ) ) ; image -> colormap [ index ] . green = ( MagickRealType ) ScaleCharToQuantum ( ( unsigned char ) ReadBlobByte ( image ) ) ; image -> colormap [ index ] . blue = ( MagickRealType ) ScaleCharToQuantum ( ( unsigned char ) ReadBlobByte ( image ) ) ; } } else for ( i = 0 ; i < ( ssize_t ) ( 1L << bits_per_pixel ) ; i ++ ) { index = ConstrainColormapIndex ( image , 255 - i , exception ) ; image -> colormap [ index ] . red = ( MagickRealType ) ScaleCharToQuantum ( PalmPalette [ i ] [ 0 ] ) ; image -> colormap [ index ] . green = ( MagickRealType ) ScaleCharToQuantum ( PalmPalette [ i ] [ 1 ] ) ; image -> colormap [ index ] . blue = ( MagickRealType ) ScaleCharToQuantum ( PalmPalette [ i ] [ 2 ] ) ; } } if ( flags & PALM_IS_COMPRESSED_FLAG ) size = ReadBlobMSBShort ( image ) ; ( void ) size ; image -> storage_class = DirectClass ; if ( bits_per_pixel < 16 ) { image -> storage_class = PseudoClass ; image -> depth = 8 ; } if ( image_info -> ping != MagickFalse ) { ( void ) CloseBlob ( image ) ; return ( image ) ; } status = SetImageExtent ( image , image -> columns , image -> rows , exception ) ; if ( status == MagickFalse ) return ( DestroyImageList ( image ) ) ; one_row = ( unsigned char * ) AcquireQuantumMemory ( MagickMax ( bytes_per_row , 2 * image -> columns ) , sizeof ( * one_row ) ) ; if ( one_row == ( unsigned char * ) NULL ) ThrowReaderException ( ResourceLimitError , \"MemoryAllocationFailed\" ) ; <S2SV_StartBug> lastrow = ( unsigned char * ) NULL ; <S2SV_EndBug> if ( compressionType == PALM_COMPRESSION_SCANLINE ) { <S2SV_StartBug> lastrow = ( unsigned char * ) AcquireQuantumMemory ( MagickMax ( bytes_per_row , <S2SV_EndBug> <S2SV_StartBug> 2 * image -> columns ) , sizeof ( * lastrow ) ) ; <S2SV_EndBug> if ( lastrow == ( unsigned char * ) NULL ) ThrowReaderException ( ResourceLimitError , \"MemoryAllocationFailed\" ) ; } mask = ( size_t ) ( 1U << bits_per_pixel ) - 1 ; for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { if ( ( flags & PALM_IS_COMPRESSED_FLAG ) == 0 ) { image -> compression = NoCompression ; count = ReadBlob ( image , bytes_per_row , one_row ) ; if ( count != ( ssize_t ) bytes_per_row ) break ; } else { if ( compressionType == PALM_COMPRESSION_RLE ) { image -> compression = RLECompression ; for ( i = 0 ; i < ( ssize_t ) bytes_per_row ; ) { count = ( ssize_t ) ReadBlobByte ( image ) ; if ( count < 0 ) break ; count = MagickMin ( count , ( ssize_t ) bytes_per_row - i ) ; byte = ( size_t ) ReadBlobByte ( image ) ; ( void ) ResetMagickMemory ( one_row + i , ( int ) byte , ( size_t ) count ) ; i += count ; } } else if ( compressionType == PALM_COMPRESSION_SCANLINE ) { size_t one ; one = 1 ; image -> compression = FaxCompression ; for ( i = 0 ; i < ( ssize_t ) bytes_per_row ; i += 8 ) { count = ( ssize_t ) ReadBlobByte ( image ) ; if ( count < 0 ) break ; byte = ( size_t ) MagickMin ( ( ssize_t ) bytes_per_row - i , 8 ) ; for ( bit = 0 ; bit < byte ; bit ++ ) { if ( ( y == 0 ) || ( count & ( one << ( 7 - bit ) ) ) ) one_row [ i + bit ] = ( unsigned char ) ReadBlobByte ( image ) ; else <S2SV_StartBug> one_row [ i + bit ] = lastrow [ i + bit ] ; <S2SV_EndBug> } } <S2SV_StartBug> ( void ) CopyMagickMemory ( lastrow , one_row , bytes_per_row ) ; <S2SV_EndBug> } } ptr = one_row ; q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; if ( bits_per_pixel == 16 ) { if ( image -> columns > ( 2 * bytes_per_row ) ) { one_row = ( unsigned char * ) RelinquishMagickMemory ( one_row ) ; if ( compressionType == PALM_COMPRESSION_SCANLINE ) <S2SV_StartBug> lastrow = ( unsigned char * ) RelinquishMagickMemory ( lastrow ) ; <S2SV_EndBug> ThrowReaderException ( CorruptImageError , \"CorruptImage\" ) ; } for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { color16 = ( * ptr ++ << 8 ) ; color16 |= ( * ptr ++ ) ; SetPixelRed ( image , ( Quantum ) ( ( QuantumRange * ( ( color16 >> 11 ) & 0x1f ) ) / 0x1f ) , q ) ; SetPixelGreen ( image , ( Quantum ) ( ( QuantumRange * ( ( color16 >> 5 ) & 0x3f ) ) / 0x3f ) , q ) ; SetPixelBlue ( image , ( Quantum ) ( ( QuantumRange * ( ( color16 >> 0 ) & 0x1f ) ) / 0x1f ) , q ) ; SetPixelAlpha ( image , OpaqueAlpha , q ) ; q += GetPixelChannels ( image ) ; } } else { bit = 8 - bits_per_pixel ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { if ( ( size_t ) ( ptr - one_row ) >= bytes_per_row ) { one_row = ( unsigned char * ) RelinquishMagickMemory ( one_row ) ; if ( compressionType == PALM_COMPRESSION_SCANLINE ) <S2SV_StartBug> lastrow = ( unsigned char * ) RelinquishMagickMemory ( lastrow ) ; <S2SV_EndBug> ThrowReaderException ( CorruptImageError , \"CorruptImage\" ) ; } index = ( Quantum ) ( mask - ( ( ( * ptr ) & ( mask << bit ) ) >> bit ) ) ; SetPixelIndex ( image , index , q ) ; SetPixelViaPixelInfo ( image , image -> colormap + ( ssize_t ) index , q ) ; if ( bit ) bit -= bits_per_pixel ; else { ptr ++ ; bit = 8 - bits_per_pixel ; } q += GetPixelChannels ( image ) ; } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; } if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ; if ( status == MagickFalse ) break ; } } if ( flags & PALM_HAS_TRANSPARENCY_FLAG ) { ssize_t index = ConstrainColormapIndex ( image , ( ssize_t ) ( mask - transparentIndex ) , exception ) ; if ( bits_per_pixel != 16 ) transpix = image -> colormap [ index ] ; ( void ) TransparentPaintImage ( image , & transpix , ( Quantum ) TransparentAlpha , MagickFalse , exception ) ; } one_row = ( unsigned char * ) RelinquishMagickMemory ( one_row ) ; if ( compressionType == PALM_COMPRESSION_SCANLINE ) <S2SV_StartBug> lastrow = ( unsigned char * ) RelinquishMagickMemory ( lastrow ) ; <S2SV_EndBug> if ( EOFBlob ( image ) != MagickFalse ) { ThrowFileException ( exception , CorruptImageError , \"UnexpectedEndOfFile\" , image -> filename ) ; break ; } if ( image_info -> number_scenes != 0 ) if ( image -> scene >= ( image_info -> scene + image_info -> number_scenes - 1 ) ) break ; if ( nextDepthOffset != 0 ) { totalOffset += ( MagickOffsetType ) ( nextDepthOffset * 4 ) ; if ( totalOffset >= ( MagickOffsetType ) GetBlobSize ( image ) ) ThrowReaderException ( CorruptImageError , \"ImproperImageHeader\" ) else seekNextDepth = SeekBlob ( image , totalOffset , SEEK_SET ) ; if ( seekNextDepth != totalOffset ) ThrowReaderException ( CorruptImageError , \"ImproperImageHeader\" ) ; AcquireNextImage ( image_info , image , exception ) ; if ( GetNextImageInList ( image ) == ( Image * ) NULL ) { ( void ) DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } image = SyncNextImageInList ( image ) ; status = SetImageProgress ( image , LoadImagesTag , TellBlob ( image ) , GetBlobSize ( image ) ) ; if ( status == MagickFalse ) break ; } } while ( nextDepthOffset != 0 ) ; ( void ) CloseBlob ( image ) ; return ( GetFirstImageInList ( image ) ) ; }\n","target":"<S2SV_ModStart> unsigned char * last_row <S2SV_ModEnd> , * one_row <S2SV_ModStart> \"MemoryAllocationFailed\" ) ; last_row <S2SV_ModEnd> = ( unsigned <S2SV_ModStart> PALM_COMPRESSION_SCANLINE ) { last_row <S2SV_ModEnd> = ( unsigned <S2SV_ModStart> sizeof ( * last_row ) ) ; if ( last_row <S2SV_ModEnd> == ( unsigned <S2SV_ModStart> bit ] = last_row <S2SV_ModEnd> [ i + <S2SV_ModStart> ) CopyMagickMemory ( last_row <S2SV_ModEnd> , one_row , <S2SV_ModStart> == PALM_COMPRESSION_SCANLINE ) last_row <S2SV_ModEnd> = ( unsigned <S2SV_ModStart> ) RelinquishMagickMemory ( last_row <S2SV_ModEnd> ) ; ThrowReaderException <S2SV_ModStart> == PALM_COMPRESSION_SCANLINE ) last_row <S2SV_ModEnd> = ( unsigned <S2SV_ModStart> ) RelinquishMagickMemory ( last_row <S2SV_ModEnd> ) ; ThrowReaderException <S2SV_ModStart> == PALM_COMPRESSION_SCANLINE ) last_row <S2SV_ModEnd> = ( unsigned <S2SV_ModStart> ) RelinquishMagickMemory ( last_row <S2SV_ModEnd> ) ; if\n","project_and_commit_id":"ImageMagick@ImageMagick/0417cea1b6d72f90bd4f1f573f91e42a8ba66a89","cve_id":"CVE-2017-12664","original_address":"https://github.com/ImageMagick/ImageMagick/commit/0417cea1b6d72f90bd4f1f573f91e42a8ba66a89","time":"2017-08-07T21:29Z"},
	{"Unnamed: 0":5095,"cwe_id":"CWE-476","source":"CWE-476 static int __rds_rdma_map ( struct rds_sock * rs , struct rds_get_mr_args * args , u64 * cookie_ret , struct rds_mr * * mr_ret ) { struct rds_mr * mr = NULL , * found ; unsigned int nr_pages ; struct page * * pages = NULL ; struct scatterlist * sg ; void * trans_private ; unsigned long flags ; rds_rdma_cookie_t cookie ; unsigned int nents ; long i ; int ret ; <S2SV_StartBug> if ( rs -> rs_bound_addr == 0 ) { <S2SV_EndBug> ret = - ENOTCONN ; goto out ; } if ( ! rs -> rs_transport -> get_mr ) { ret = - EOPNOTSUPP ; goto out ; } nr_pages = rds_pages_in_vec ( & args -> vec ) ; if ( nr_pages == 0 ) { ret = - EINVAL ; goto out ; } if ( ( nr_pages - 1 ) > ( RDS_MAX_MSG_SIZE >> PAGE_SHIFT ) ) { ret = - EMSGSIZE ; goto out ; } rdsdebug ( \"RDS:<S2SV_blank>get_mr<S2SV_blank>addr<S2SV_blank>%llx<S2SV_blank>len<S2SV_blank>%llu<S2SV_blank>nr_pages<S2SV_blank>%u\\\\n\" , args -> vec . addr , args -> vec . bytes , nr_pages ) ; pages = kcalloc ( nr_pages , sizeof ( struct page * ) , GFP_KERNEL ) ; if ( ! pages ) { ret = - ENOMEM ; goto out ; } mr = kzalloc ( sizeof ( struct rds_mr ) , GFP_KERNEL ) ; if ( ! mr ) { ret = - ENOMEM ; goto out ; } refcount_set ( & mr -> r_refcount , 1 ) ; RB_CLEAR_NODE ( & mr -> r_rb_node ) ; mr -> r_trans = rs -> rs_transport ; mr -> r_sock = rs ; if ( args -> flags & RDS_RDMA_USE_ONCE ) mr -> r_use_once = 1 ; if ( args -> flags & RDS_RDMA_INVALIDATE ) mr -> r_invalidate = 1 ; if ( args -> flags & RDS_RDMA_READWRITE ) mr -> r_write = 1 ; ret = rds_pin_pages ( args -> vec . addr , nr_pages , pages , 1 ) ; if ( ret < 0 ) goto out ; nents = ret ; sg = kcalloc ( nents , sizeof ( * sg ) , GFP_KERNEL ) ; if ( ! sg ) { ret = - ENOMEM ; goto out ; } WARN_ON ( ! nents ) ; sg_init_table ( sg , nents ) ; for ( i = 0 ; i < nents ; i ++ ) sg_set_page ( & sg [ i ] , pages [ i ] , PAGE_SIZE , 0 ) ; rdsdebug ( \"RDS:<S2SV_blank>trans_private<S2SV_blank>nents<S2SV_blank>is<S2SV_blank>%u\\\\n\" , nents ) ; trans_private = rs -> rs_transport -> get_mr ( sg , nents , rs , & mr -> r_key ) ; if ( IS_ERR ( trans_private ) ) { for ( i = 0 ; i < nents ; i ++ ) put_page ( sg_page ( & sg [ i ] ) ) ; kfree ( sg ) ; ret = PTR_ERR ( trans_private ) ; goto out ; } mr -> r_trans_private = trans_private ; rdsdebug ( \"RDS:<S2SV_blank>get_mr<S2SV_blank>put_user<S2SV_blank>key<S2SV_blank>is<S2SV_blank>%x<S2SV_blank>cookie_addr<S2SV_blank>%p\\\\n\" , mr -> r_key , ( void * ) ( unsigned long ) args -> cookie_addr ) ; cookie = rds_rdma_make_cookie ( mr -> r_key , args -> vec . addr & ~ PAGE_MASK ) ; if ( cookie_ret ) * cookie_ret = cookie ; if ( args -> cookie_addr && put_user ( cookie , ( u64 __user * ) ( unsigned long ) args -> cookie_addr ) ) { ret = - EFAULT ; goto out ; } spin_lock_irqsave ( & rs -> rs_rdma_lock , flags ) ; found = rds_mr_tree_walk ( & rs -> rs_rdma_keys , mr -> r_key , mr ) ; spin_unlock_irqrestore ( & rs -> rs_rdma_lock , flags ) ; BUG_ON ( found && found != mr ) ; rdsdebug ( \"RDS:<S2SV_blank>get_mr<S2SV_blank>key<S2SV_blank>is<S2SV_blank>%x\\\\n\" , mr -> r_key ) ; if ( mr_ret ) { refcount_inc ( & mr -> r_refcount ) ; * mr_ret = mr ; } ret = 0 ; out : kfree ( pages ) ; if ( mr ) rds_mr_put ( mr ) ; return ret ; }\n","target":"<S2SV_ModStart> rs_bound_addr == 0 || ! rs -> rs_transport\n","project_and_commit_id":"torvalds@linux/f3069c6d33f6ae63a1668737bc78aaaa51bff7ca","cve_id":"CVE-2018-7492","original_address":"https://github.com/torvalds/linux/commit/f3069c6d33f6ae63a1668737bc78aaaa51bff7ca","time":"2018-02-26T20:29Z"},
	{"Unnamed: 0":5594,"cwe_id":"CWE-20","source":"CWE-20 int handle ( int s , unsigned char * data , int len , struct sockaddr_in * s_in ) { char buf [ 2048 ] ; unsigned short * cmd = ( unsigned short * ) buf ; int plen ; struct in_addr * addr = & s_in -> sin_addr ; unsigned short * pid = ( unsigned short * ) data ; if ( len == S_HELLO_LEN && memcmp ( data , \"sorbo\" , 5 ) == 0 ) { unsigned short * id = ( unsigned short * ) ( data + 5 ) ; int x = 2 + 4 + 2 ; * cmd = htons ( S_CMD_INET_CHECK ) ; memcpy ( cmd + 1 , addr , 4 ) ; memcpy ( cmd + 1 + 2 , id , 2 ) ; printf ( \"Inet<S2SV_blank>check<S2SV_blank>by<S2SV_blank>%s<S2SV_blank>%d\\\\n\" , inet_ntoa ( * addr ) , ntohs ( * id ) ) ; if ( send ( s , buf , x , 0 ) != x ) return 1 ; return 0 ; } * cmd ++ = htons ( S_CMD_PACKET ) ; * cmd ++ = * pid ; plen = len - 2 ; <S2SV_StartBug> last_id = ntohs ( * pid ) ; <S2SV_EndBug> if ( last_id > 20000 ) wrap = 1 ; if ( wrap && last_id < 100 ) { wrap = 0 ; memset ( ids , 0 , sizeof ( ids ) ) ; } printf ( \"Got<S2SV_blank>packet<S2SV_blank>%d<S2SV_blank>%d\" , last_id , plen ) ; if ( is_dup ( last_id ) ) { printf ( \"<S2SV_blank>(DUP)\\\\n\" ) ; return 0 ; } printf ( \"\\\\n\" ) ; * cmd ++ = htons ( plen ) ; memcpy ( cmd , data + 2 , plen ) ; plen += 2 + 2 + 2 ; assert ( plen <= ( int ) sizeof ( buf ) ) ; if ( send ( s , buf , plen , 0 ) != plen ) return 1 ; return 0 ; }\n","target":"<S2SV_ModStart> - 2 ; if ( plen < 0 ) return 0 ;\n","project_and_commit_id":"aircrack-ng@aircrack-ng/da087238963c1239fdabd47dc1b65279605aca70","cve_id":"CVE-2014-8323","original_address":"https://github.com/aircrack-ng/aircrack-ng/commit/da087238963c1239fdabd47dc1b65279605aca70","time":"2017-10-17T14:29Z"},
	{"Unnamed: 0":5939,"cwe_id":"CWE-119","source":"CWE-119 int cdf_read_property_info ( const cdf_stream_t * sst , const cdf_header_t * h , uint32_t offs , cdf_property_info_t * * info , size_t * count , size_t * maxcount ) { const cdf_section_header_t * shp ; cdf_section_header_t sh ; const uint8_t * p , * q , * e ; int16_t s16 ; int32_t s32 ; uint32_t u32 ; int64_t s64 ; uint64_t u64 ; cdf_timestamp_t tp ; size_t i , o , o4 , nelements , j ; cdf_property_info_t * inp ; if ( offs > UINT32_MAX / 4 ) { errno = EFTYPE ; goto out ; } shp = CAST ( const cdf_section_header_t * , ( const void * ) ( ( const char * ) sst -> sst_tab + offs ) ) ; if ( cdf_check_stream_offset ( sst , h , shp , sizeof ( * shp ) , __LINE__ ) == - 1 ) goto out ; sh . sh_len = CDF_TOLE4 ( shp -> sh_len ) ; # define CDF_SHLEN_LIMIT ( UINT32_MAX / 8 ) if ( sh . sh_len > CDF_SHLEN_LIMIT ) { errno = EFTYPE ; goto out ; } sh . sh_properties = CDF_TOLE4 ( shp -> sh_properties ) ; # define CDF_PROP_LIMIT ( UINT32_MAX / ( 4 * sizeof ( * inp ) ) ) if ( sh . sh_properties > CDF_PROP_LIMIT ) goto out ; DPRINTF ( ( \"section<S2SV_blank>len:<S2SV_blank>%u<S2SV_blank>properties<S2SV_blank>%u\\\\n\" , sh . sh_len , sh . sh_properties ) ) ; if ( * maxcount ) { if ( * maxcount > CDF_PROP_LIMIT ) goto out ; * maxcount += sh . sh_properties ; inp = CAST ( cdf_property_info_t * , realloc ( * info , * maxcount * sizeof ( * inp ) ) ) ; } else { * maxcount = sh . sh_properties ; inp = CAST ( cdf_property_info_t * , malloc ( * maxcount * sizeof ( * inp ) ) ) ; } if ( inp == NULL ) goto out ; * info = inp ; inp += * count ; * count += sh . sh_properties ; p = CAST ( const uint8_t * , ( const void * ) ( ( const char * ) ( const void * ) sst -> sst_tab + offs + sizeof ( sh ) ) ) ; e = CAST ( const uint8_t * , ( const void * ) ( ( ( const char * ) ( const void * ) shp ) + sh . sh_len ) ) ; if ( cdf_check_stream_offset ( sst , h , e , 0 , __LINE__ ) == - 1 ) goto out ; for ( i = 0 ; i < sh . sh_properties ; i ++ ) { <S2SV_StartBug> q = ( const uint8_t * ) ( const void * ) <S2SV_EndBug> ( ( const char * ) ( const void * ) p + <S2SV_StartBug> CDF_GETUINT32 ( p , ( i << 1 ) + 1 ) ) - 2 * sizeof ( uint32_t ) ; <S2SV_EndBug> if ( q > e ) { DPRINTF ( ( \"Ran<S2SV_blank>of<S2SV_blank>the<S2SV_blank>end<S2SV_blank>%p<S2SV_blank>><S2SV_blank>%p\\\\n\" , q , e ) ) ; goto out ; } inp [ i ] . pi_id = CDF_GETUINT32 ( p , i << 1 ) ; inp [ i ] . pi_type = CDF_GETUINT32 ( q , 0 ) ; <S2SV_StartBug> DPRINTF ( ( \"%\" SIZE_T_FORMAT \"u)<S2SV_blank>id=%x<S2SV_blank>type=%x<S2SV_blank>offs=0x%tx,0x%x\\\\n\" , i , <S2SV_EndBug> inp [ i ] . pi_id , inp [ i ] . pi_type , q - p , <S2SV_StartBug> CDF_GETUINT32 ( p , ( i << 1 ) + 1 ) ) ) ; <S2SV_EndBug> if ( inp [ i ] . pi_type & CDF_VECTOR ) { nelements = CDF_GETUINT32 ( q , 1 ) ; o = 2 ; } else { nelements = 1 ; o = 1 ; } o4 = o * sizeof ( uint32_t ) ; if ( inp [ i ] . pi_type & ( CDF_ARRAY | CDF_BYREF | CDF_RESERVED ) ) goto unknown ; switch ( inp [ i ] . pi_type & CDF_TYPEMASK ) { case CDF_NULL : case CDF_EMPTY : break ; case CDF_SIGNED16 : if ( inp [ i ] . pi_type & CDF_VECTOR ) goto unknown ; ( void ) memcpy ( & s16 , & q [ o4 ] , sizeof ( s16 ) ) ; inp [ i ] . pi_s16 = CDF_TOLE2 ( s16 ) ; break ; case CDF_SIGNED32 : if ( inp [ i ] . pi_type & CDF_VECTOR ) goto unknown ; ( void ) memcpy ( & s32 , & q [ o4 ] , sizeof ( s32 ) ) ; inp [ i ] . pi_s32 = CDF_TOLE4 ( ( uint32_t ) s32 ) ; break ; case CDF_BOOL : case CDF_UNSIGNED32 : if ( inp [ i ] . pi_type & CDF_VECTOR ) goto unknown ; ( void ) memcpy ( & u32 , & q [ o4 ] , sizeof ( u32 ) ) ; inp [ i ] . pi_u32 = CDF_TOLE4 ( u32 ) ; break ; case CDF_SIGNED64 : if ( inp [ i ] . pi_type & CDF_VECTOR ) goto unknown ; ( void ) memcpy ( & s64 , & q [ o4 ] , sizeof ( s64 ) ) ; inp [ i ] . pi_s64 = CDF_TOLE8 ( ( uint64_t ) s64 ) ; break ; case CDF_UNSIGNED64 : if ( inp [ i ] . pi_type & CDF_VECTOR ) goto unknown ; ( void ) memcpy ( & u64 , & q [ o4 ] , sizeof ( u64 ) ) ; inp [ i ] . pi_u64 = CDF_TOLE8 ( ( uint64_t ) u64 ) ; break ; case CDF_FLOAT : if ( inp [ i ] . pi_type & CDF_VECTOR ) goto unknown ; ( void ) memcpy ( & u32 , & q [ o4 ] , sizeof ( u32 ) ) ; u32 = CDF_TOLE4 ( u32 ) ; memcpy ( & inp [ i ] . pi_f , & u32 , sizeof ( inp [ i ] . pi_f ) ) ; break ; case CDF_DOUBLE : if ( inp [ i ] . pi_type & CDF_VECTOR ) goto unknown ; ( void ) memcpy ( & u64 , & q [ o4 ] , sizeof ( u64 ) ) ; u64 = CDF_TOLE8 ( ( uint64_t ) u64 ) ; memcpy ( & inp [ i ] . pi_d , & u64 , sizeof ( inp [ i ] . pi_d ) ) ; break ; case CDF_LENGTH32_STRING : case CDF_LENGTH32_WSTRING : if ( nelements > 1 ) { size_t nelem = inp - * info ; if ( * maxcount > CDF_PROP_LIMIT || nelements > CDF_PROP_LIMIT ) goto out ; * maxcount += nelements ; inp = CAST ( cdf_property_info_t * , realloc ( * info , * maxcount * sizeof ( * inp ) ) ) ; if ( inp == NULL ) goto out ; * info = inp ; inp = * info + nelem ; } DPRINTF ( ( \"nelements<S2SV_blank>=<S2SV_blank>%\" SIZE_T_FORMAT \"u\\\\n\" , nelements ) ) ; for ( j = 0 ; j < nelements ; j ++ , i ++ ) { uint32_t l = CDF_GETUINT32 ( q , o ) ; inp [ i ] . pi_str . s_len = l ; inp [ i ] . pi_str . s_buf = ( const char * ) ( const void * ) ( & q [ o4 + sizeof ( l ) ] ) ; DPRINTF ( ( \"l<S2SV_blank>=<S2SV_blank>%d,<S2SV_blank>r<S2SV_blank>=<S2SV_blank>%\" SIZE_T_FORMAT \"u,<S2SV_blank>s<S2SV_blank>=<S2SV_blank>%s\\\\n\" , l , CDF_ROUND ( l , sizeof ( l ) ) , inp [ i ] . pi_str . s_buf ) ) ; if ( l & 1 ) l ++ ; o += l >> 1 ; if ( q + o >= e ) goto out ; o4 = o * sizeof ( uint32_t ) ; } i -- ; break ; case CDF_FILETIME : if ( inp [ i ] . pi_type & CDF_VECTOR ) goto unknown ; ( void ) memcpy ( & tp , & q [ o4 ] , sizeof ( tp ) ) ; inp [ i ] . pi_tp = CDF_TOLE8 ( ( uint64_t ) tp ) ; break ; case CDF_CLIPBOARD : if ( inp [ i ] . pi_type & CDF_VECTOR ) goto unknown ; break ; default : unknown : DPRINTF ( ( \"Don\\'t<S2SV_blank>know<S2SV_blank>how<S2SV_blank>to<S2SV_blank>deal<S2SV_blank>with<S2SV_blank>%x\\\\n\" , inp [ i ] . pi_type ) ) ; break ; } } return 0 ; out : free ( * info ) ; return - 1 ; }\n","target":"<S2SV_ModStart> ++ ) { size_t ofs = CDF_GETUINT32 ( p , ( i << 1 ) + 1 ) ; <S2SV_ModStart> ) p + ofs <S2SV_ModEnd> - 2 * <S2SV_ModStart> sizeof ( uint32_t ) <S2SV_ModStart> SIZE_T_FORMAT \"u)<S2SV_blank>id=%x<S2SV_blank>type=%x<S2SV_blank>offs=0x%tx,0x%x\\\\n\" , i , <S2SV_ModEnd> inp [ i <S2SV_ModStart> - p , offs <S2SV_ModEnd> ) ) ;\n","project_and_commit_id":"glensc@file/1aec04dbf8a24b8a6ba64c4f74efa0628e36db0b","cve_id":"CVE-2012-1571","original_address":"https://github.com/glensc/file/commit/1aec04dbf8a24b8a6ba64c4f74efa0628e36db0b","time":"2012-07-17T21:55Z"},
	{"Unnamed: 0":5750,"cwe_id":"CWE-119","source":"CWE-119 static void read_intra_frame_mode_info ( VP9_COMMON * const cm , MACROBLOCKD * const xd , <S2SV_StartBug> int mi_row , int mi_col , vp9_reader * r ) { <S2SV_EndBug> MODE_INFO * const mi = xd -> mi [ 0 ] ; MB_MODE_INFO * const mbmi = & mi -> mbmi ; <S2SV_StartBug> const MODE_INFO * above_mi = xd -> mi [ - cm -> mi_stride ] ; <S2SV_EndBug> <S2SV_StartBug> const MODE_INFO * left_mi = xd -> left_available ? xd -> mi [ - 1 ] : NULL ; <S2SV_EndBug> const BLOCK_SIZE bsize = mbmi -> sb_type ; int i ; <S2SV_StartBug> mbmi -> segment_id = read_intra_segment_id ( cm , xd , mi_row , mi_col , r ) ; <S2SV_EndBug> mbmi -> skip = read_skip ( cm , xd , mbmi -> segment_id , r ) ; <S2SV_StartBug> mbmi -> tx_size = read_tx_size ( cm , xd , cm -> tx_mode , bsize , 1 , r ) ; <S2SV_EndBug> mbmi -> ref_frame [ 0 ] = INTRA_FRAME ; mbmi -> ref_frame [ 1 ] = NONE ; switch ( bsize ) { case BLOCK_4X4 : for ( i = 0 ; i < 4 ; ++ i ) mi -> bmi [ i ] . as_mode = read_intra_mode ( r , get_y_mode_probs ( mi , above_mi , left_mi , i ) ) ; mbmi -> mode = mi -> bmi [ 3 ] . as_mode ; break ; case BLOCK_4X8 : mi -> bmi [ 0 ] . as_mode = mi -> bmi [ 2 ] . as_mode = read_intra_mode ( r , get_y_mode_probs ( mi , above_mi , left_mi , 0 ) ) ; mi -> bmi [ 1 ] . as_mode = mi -> bmi [ 3 ] . as_mode = mbmi -> mode = read_intra_mode ( r , get_y_mode_probs ( mi , above_mi , left_mi , 1 ) ) ; break ; case BLOCK_8X4 : mi -> bmi [ 0 ] . as_mode = mi -> bmi [ 1 ] . as_mode = read_intra_mode ( r , get_y_mode_probs ( mi , above_mi , left_mi , 0 ) ) ; mi -> bmi [ 2 ] . as_mode = mi -> bmi [ 3 ] . as_mode = mbmi -> mode = read_intra_mode ( r , get_y_mode_probs ( mi , above_mi , left_mi , 2 ) ) ; break ; default : mbmi -> mode = read_intra_mode ( r , get_y_mode_probs ( mi , above_mi , left_mi , 0 ) ) ; } mbmi -> uv_mode = read_intra_mode ( r , vp9_kf_uv_mode_prob [ mbmi -> mode ] ) ; }\n","target":"<S2SV_ModStart> int mi_col , vpx_reader <S2SV_ModEnd> * r ) <S2SV_ModStart> = xd -> above_mi <S2SV_ModEnd> ; const MODE_INFO <S2SV_ModStart> = xd -> left_mi <S2SV_ModEnd> ; const BLOCK_SIZE <S2SV_ModStart> int i ; const int mi_offset = mi_row * cm -> mi_cols + mi_col ; const int bw = xd -> plane [ 0 ] . n4_w >> 1 ; const int bh = xd -> plane [ 0 ] . n4_h >> 1 ; const int x_mis = MIN ( cm -> mi_cols - mi_col , bw ) ; const int y_mis = MIN ( cm -> mi_rows - mi_row , bh ) ; <S2SV_ModStart> ( cm , mi_offset , x_mis , y_mis <S2SV_ModEnd> , r ) <S2SV_ModStart> cm , xd <S2SV_ModEnd> , 1 ,\n","project_and_commit_id":"external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426","cve_id":"CVE-2016-1621","original_address":"https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426","time":"2016-03-12T21:59Z"},
	{"Unnamed: 0":579,"cwe_id":"CWE-200","source":"CWE-200 static ssize_t snd_timer_user_read ( struct file * file , char __user * buffer , size_t count , loff_t * offset ) { struct snd_timer_user * tu ; long result = 0 , unit ; int qhead ; int err = 0 ; tu = file -> private_data ; unit = tu -> tread ? sizeof ( struct snd_timer_tread ) : sizeof ( struct snd_timer_read ) ; <S2SV_StartBug> spin_lock_irq ( & tu -> qlock ) ; <S2SV_EndBug> while ( ( long ) count - result >= unit ) { while ( ! tu -> qused ) { wait_queue_t wait ; if ( ( file -> f_flags & O_NONBLOCK ) != 0 || result > 0 ) { err = - EAGAIN ; goto _error ; } set_current_state ( TASK_INTERRUPTIBLE ) ; init_waitqueue_entry ( & wait , current ) ; add_wait_queue ( & tu -> qchange_sleep , & wait ) ; spin_unlock_irq ( & tu -> qlock ) ; <S2SV_StartBug> schedule ( ) ; <S2SV_EndBug> spin_lock_irq ( & tu -> qlock ) ; remove_wait_queue ( & tu -> qchange_sleep , & wait ) ; if ( tu -> disconnected ) { err = - ENODEV ; goto _error ; } if ( signal_pending ( current ) ) { err = - ERESTARTSYS ; goto _error ; } } qhead = tu -> qhead ++ ; tu -> qhead %= tu -> queue_size ; tu -> qused -- ; spin_unlock_irq ( & tu -> qlock ) ; <S2SV_StartBug> mutex_lock ( & tu -> ioctl_lock ) ; <S2SV_EndBug> if ( tu -> tread ) { if ( copy_to_user ( buffer , & tu -> tqueue [ qhead ] , sizeof ( struct snd_timer_tread ) ) ) err = - EFAULT ; } else { if ( copy_to_user ( buffer , & tu -> queue [ qhead ] , sizeof ( struct snd_timer_read ) ) ) err = - EFAULT ; } <S2SV_StartBug> mutex_unlock ( & tu -> ioctl_lock ) ; <S2SV_EndBug> spin_lock_irq ( & tu -> qlock ) ; if ( err < 0 ) goto _error ; result += unit ; buffer += unit ; } _error : spin_unlock_irq ( & tu -> qlock ) ; <S2SV_StartBug> return result > 0 ? result : err ; <S2SV_EndBug> }\n","target":"<S2SV_ModStart> snd_timer_read ) ; mutex_lock ( & tu -> ioctl_lock ) ; <S2SV_ModStart> qlock ) ; mutex_unlock ( & tu -> ioctl_lock ) ; schedule ( ) ; mutex_lock ( & tu -> ioctl_lock <S2SV_ModEnd> ) ; spin_lock_irq <S2SV_ModStart> qlock ) ; <S2SV_ModEnd> if ( tu <S2SV_ModStart> EFAULT ; } <S2SV_ModEnd> spin_lock_irq ( & <S2SV_ModStart> qlock ) ; mutex_unlock ( & tu -> ioctl_lock ) ;\n","project_and_commit_id":"torvalds@linux/d11662f4f798b50d8c8743f433842c3e40fe3378","cve_id":"CVE-2017-1000380","original_address":"https://github.com/torvalds/linux/commit/d11662f4f798b50d8c8743f433842c3e40fe3378","time":"2017-06-17T18:29Z"},
	{"Unnamed: 0":213,"cwe_id":"CWE-189","source":"CWE-189 static void oz_usb_handle_ep_data ( struct oz_usb_ctx * usb_ctx , struct oz_usb_hdr * usb_hdr , int len ) { struct oz_data * data_hdr = ( struct oz_data * ) usb_hdr ; switch ( data_hdr -> format ) { case OZ_DATA_F_MULTIPLE_FIXED : { struct oz_multiple_fixed * body = ( struct oz_multiple_fixed * ) data_hdr ; u8 * data = body -> data ; <S2SV_StartBug> int n = ( len - sizeof ( struct oz_multiple_fixed ) + 1 ) <S2SV_EndBug> / body -> unit_size ; while ( n -- ) { oz_hcd_data_ind ( usb_ctx -> hport , body -> endpoint , data , body -> unit_size ) ; data += body -> unit_size ; } } break ; case OZ_DATA_F_ISOC_FIXED : { struct oz_isoc_fixed * body = ( struct oz_isoc_fixed * ) data_hdr ; int data_len = len - sizeof ( struct oz_isoc_fixed ) + 1 ; int unit_size = body -> unit_size ; u8 * data = body -> data ; int count ; int i ; if ( ! unit_size ) break ; count = data_len / unit_size ; for ( i = 0 ; i < count ; i ++ ) { oz_hcd_data_ind ( usb_ctx -> hport , body -> endpoint , data , unit_size ) ; data += unit_size ; } } break ; } }\n","target":"<S2SV_ModStart> ; int n ; if ( ! body -> unit_size ) break ; n\n","project_and_commit_id":"torvalds@linux/04bf464a5dfd9ade0dda918e44366c2c61fce80b","cve_id":"CVE-2015-4003","original_address":"https://github.com/torvalds/linux/commit/04bf464a5dfd9ade0dda918e44366c2c61fce80b","time":"2015-06-07T23:59Z"},
	{"Unnamed: 0":1059,"cwe_id":"CWE-264","source":"CWE-264 static struct cifsSesInfo * <S2SV_StartBug> cifs_find_smb_ses ( struct TCP_Server_Info * server , char * username ) <S2SV_EndBug> { struct list_head * tmp ; struct cifsSesInfo * ses ; write_lock ( & cifs_tcp_ses_lock ) ; <S2SV_StartBug> list_for_each ( tmp , & server -> smb_ses_list ) { <S2SV_EndBug> ses = list_entry ( tmp , struct cifsSesInfo , smb_ses_list ) ; <S2SV_StartBug> if ( strncmp ( ses -> userName , username , MAX_USERNAME_SIZE ) ) <S2SV_EndBug> <S2SV_StartBug> continue ; <S2SV_EndBug> ++ ses -> ses_count ; write_unlock ( & cifs_tcp_ses_lock ) ; return ses ; } write_unlock ( & cifs_tcp_ses_lock ) ; return NULL ; }\n","target":"<S2SV_ModStart> * server , struct smb_vol * vol ) { <S2SV_ModEnd> struct cifsSesInfo * <S2SV_ModStart> cifs_tcp_ses_lock ) ; list_for_each_entry ( ses <S2SV_ModEnd> , & server <S2SV_ModStart> server -> smb_ses_list , smb_ses_list ) { switch ( server -> secType ) { case Kerberos : if ( vol -> linux_uid != ses -> linux_uid ) continue ; break ; default : <S2SV_ModEnd> if ( strncmp <S2SV_ModStart> -> userName , vol -> <S2SV_ModStart> ) continue ; if ( strlen ( vol -> username ) != 0 && strncmp ( ses -> password , vol -> password , MAX_PASSWORD_SIZE ) ) continue ; }\n","project_and_commit_id":"torvalds@linux/4ff67b720c02c36e54d55b88c2931879b7db1cd2","cve_id":"CVE-2011-1585","original_address":"https://github.com/torvalds/linux/commit/4ff67b720c02c36e54d55b88c2931879b7db1cd2","time":"2013-06-08T13:05Z"},
	{"Unnamed: 0":5877,"cwe_id":"CWE-125","source":"CWE-125 static int decode_studio_vop_header ( Mpeg4DecContext * ctx , GetBitContext * gb ) { MpegEncContext * s = & ctx -> m ; if ( get_bits_left ( gb ) <= 32 ) return 0 ; s -> partitioned_frame = 0 ; <S2SV_StartBug> s -> decode_mb = mpeg4_decode_studio_mb ; <S2SV_EndBug> decode_smpte_tc ( ctx , gb ) ; skip_bits ( gb , 10 ) ; skip_bits ( gb , 2 ) ; s -> pict_type = get_bits ( gb , 2 ) + AV_PICTURE_TYPE_I ; if ( get_bits1 ( gb ) ) { skip_bits1 ( gb ) ; skip_bits1 ( gb ) ; s -> progressive_frame = get_bits1 ( gb ) ^ 1 ; } if ( s -> pict_type == AV_PICTURE_TYPE_I ) { if ( get_bits1 ( gb ) ) reset_studio_dc_predictors ( s ) ; } if ( ctx -> shape != BIN_ONLY_SHAPE ) { s -> alternate_scan = get_bits1 ( gb ) ; s -> frame_pred_frame_dct = get_bits1 ( gb ) ; s -> dct_precision = get_bits ( gb , 2 ) ; s -> intra_dc_precision = get_bits ( gb , 2 ) ; s -> q_scale_type = get_bits1 ( gb ) ; } if ( s -> alternate_scan ) { ff_init_scantable ( s -> idsp . idct_permutation , & s -> inter_scantable , ff_alternate_vertical_scan ) ; ff_init_scantable ( s -> idsp . idct_permutation , & s -> intra_scantable , ff_alternate_vertical_scan ) ; ff_init_scantable ( s -> idsp . idct_permutation , & s -> intra_h_scantable , ff_alternate_vertical_scan ) ; ff_init_scantable ( s -> idsp . idct_permutation , & s -> intra_v_scantable , ff_alternate_vertical_scan ) ; } else { ff_init_scantable ( s -> idsp . idct_permutation , & s -> inter_scantable , ff_zigzag_direct ) ; ff_init_scantable ( s -> idsp . idct_permutation , & s -> intra_scantable , ff_zigzag_direct ) ; ff_init_scantable ( s -> idsp . idct_permutation , & s -> intra_h_scantable , ff_alternate_horizontal_scan ) ; ff_init_scantable ( s -> idsp . idct_permutation , & s -> intra_v_scantable , ff_alternate_vertical_scan ) ; } mpeg4_load_default_matrices ( s ) ; next_start_code_studio ( gb ) ; extension_and_user_data ( s , gb , 4 ) ; return 0 ; }\n","target":"<S2SV_ModStart> ; s -> interlaced_dct = 0 ; s ->\n","project_and_commit_id":"FFmpeg@FFmpeg/1f686d023b95219db933394a7704ad9aa5f01cbb","cve_id":"CVE-2019-11339","original_address":"https://github.com/FFmpeg/FFmpeg/commit/1f686d023b95219db933394a7704ad9aa5f01cbb","time":"2019-04-19T00:29Z"},
	{"Unnamed: 0":2639,"cwe_id":"CWE-476","source":"CWE-476 void * sspi_SecureHandleGetLowerPointer ( SecHandle * handle ) { void * pointer ; <S2SV_StartBug> if ( ! handle ) <S2SV_EndBug> return NULL ; pointer = ( void * ) ~ ( ( size_t ) handle -> dwLower ) ; return pointer ; }\n","target":"<S2SV_ModStart> ( ! handle || ! SecIsValidHandle ( handle )\n","project_and_commit_id":"FreeRDP@FreeRDP/0773bb9303d24473fe1185d85a424dfe159aff53","cve_id":"CVE-2013-4119","original_address":"https://github.com/FreeRDP/FreeRDP/commit/0773bb9303d24473fe1185d85a424dfe159aff53","time":"2016-10-03T21:59Z"},
	{"Unnamed: 0":5867,"cwe_id":"CWE-125","source":"CWE-125 static void nfnetlink_rcv_batch ( struct sk_buff * skb , struct nlmsghdr * nlh , u_int16_t subsys_id ) { struct sk_buff * oskb = skb ; struct net * net = sock_net ( skb -> sk ) ; const struct nfnetlink_subsystem * ss ; const struct nfnl_callback * nc ; static LIST_HEAD ( err_list ) ; u32 status ; int err ; if ( subsys_id >= NFNL_SUBSYS_COUNT ) return netlink_ack ( skb , nlh , - EINVAL ) ; replay : status = 0 ; skb = netlink_skb_clone ( oskb , GFP_KERNEL ) ; if ( ! skb ) return netlink_ack ( oskb , nlh , - ENOMEM ) ; nfnl_lock ( subsys_id ) ; ss = nfnl_dereference_protected ( subsys_id ) ; if ( ! ss ) { # ifdef CONFIG_MODULES nfnl_unlock ( subsys_id ) ; request_module ( \"nfnetlink-subsys-%d\" , subsys_id ) ; nfnl_lock ( subsys_id ) ; ss = nfnl_dereference_protected ( subsys_id ) ; if ( ! ss ) # endif { nfnl_unlock ( subsys_id ) ; netlink_ack ( oskb , nlh , - EOPNOTSUPP ) ; return kfree_skb ( skb ) ; } } if ( ! ss -> commit || ! ss -> abort ) { nfnl_unlock ( subsys_id ) ; netlink_ack ( oskb , nlh , - EOPNOTSUPP ) ; return kfree_skb ( skb ) ; } while ( skb -> len >= nlmsg_total_size ( 0 ) ) { int msglen , type ; nlh = nlmsg_hdr ( skb ) ; err = 0 ; <S2SV_StartBug> if ( nlmsg_len ( nlh ) < sizeof ( struct nfgenmsg ) || <S2SV_EndBug> skb -> len < nlh -> nlmsg_len ) { err = - EINVAL ; goto ack ; } if ( ! ( nlh -> nlmsg_flags & NLM_F_REQUEST ) ) { err = - EINVAL ; goto ack ; } type = nlh -> nlmsg_type ; if ( type == NFNL_MSG_BATCH_BEGIN ) { nfnl_err_reset ( & err_list ) ; status |= NFNL_BATCH_FAILURE ; goto done ; } else if ( type == NFNL_MSG_BATCH_END ) { status |= NFNL_BATCH_DONE ; goto done ; } else if ( type < NLMSG_MIN_TYPE ) { err = - EINVAL ; goto ack ; } if ( NFNL_SUBSYS_ID ( type ) != subsys_id ) { err = - EINVAL ; goto ack ; } nc = nfnetlink_find_client ( type , ss ) ; if ( ! nc ) { err = - EINVAL ; goto ack ; } { int min_len = nlmsg_total_size ( sizeof ( struct nfgenmsg ) ) ; u_int8_t cb_id = NFNL_MSG_TYPE ( nlh -> nlmsg_type ) ; struct nlattr * cda [ ss -> cb [ cb_id ] . attr_count + 1 ] ; struct nlattr * attr = ( void * ) nlh + min_len ; int attrlen = nlh -> nlmsg_len - min_len ; err = nla_parse ( cda , ss -> cb [ cb_id ] . attr_count , attr , attrlen , ss -> cb [ cb_id ] . policy ) ; if ( err < 0 ) goto ack ; if ( nc -> call_batch ) { err = nc -> call_batch ( net , net -> nfnl , skb , nlh , ( const struct nlattr * * ) cda ) ; } if ( err == - EAGAIN ) { status |= NFNL_BATCH_REPLAY ; goto next ; } } ack : if ( nlh -> nlmsg_flags & NLM_F_ACK || err ) { if ( nfnl_err_add ( & err_list , nlh , err ) < 0 ) { nfnl_err_reset ( & err_list ) ; netlink_ack ( oskb , nlmsg_hdr ( oskb ) , - ENOMEM ) ; status |= NFNL_BATCH_FAILURE ; goto done ; } if ( err ) status |= NFNL_BATCH_FAILURE ; } next : msglen = NLMSG_ALIGN ( nlh -> nlmsg_len ) ; if ( msglen > skb -> len ) msglen = skb -> len ; skb_pull ( skb , msglen ) ; } done : if ( status & NFNL_BATCH_REPLAY ) { ss -> abort ( net , oskb ) ; nfnl_err_reset ( & err_list ) ; nfnl_unlock ( subsys_id ) ; kfree_skb ( skb ) ; goto replay ; } else if ( status == NFNL_BATCH_DONE ) { ss -> commit ( net , oskb ) ; } else { ss -> abort ( net , oskb ) ; } nfnl_err_deliver ( & err_list , oskb ) ; nfnl_unlock ( subsys_id ) ; kfree_skb ( skb ) ; }\n","target":"<S2SV_ModStart> ; if ( nlh -> nlmsg_len < NLMSG_HDRLEN || skb -> len < nlh -> nlmsg_len || <S2SV_ModStart> struct nfgenmsg ) ) { nfnl_err_reset ( & err_list ) ; status |= NFNL_BATCH_FAILURE ; goto done <S2SV_ModEnd> ; } if\n","project_and_commit_id":"torvalds@linux/c58d6c93680f28ac58984af61d0a7ebf4319c241","cve_id":"CVE-2016-7917","original_address":"https://github.com/torvalds/linux/commit/c58d6c93680f28ac58984af61d0a7ebf4319c241","time":"2016-11-16T05:59Z"},
	{"Unnamed: 0":2952,"cwe_id":"CWE-189","source":"CWE-189 static ssize_t _archive_write_data ( struct archive * _a , const void * buff , size_t s ) { struct archive_write * a = ( struct archive_write * ) _a ; <S2SV_StartBug> archive_check_magic ( & a -> archive , ARCHIVE_WRITE_MAGIC , <S2SV_EndBug> <S2SV_StartBug> ARCHIVE_STATE_DATA , \"archive_write_data\" ) ; <S2SV_EndBug> archive_clear_error ( & a -> archive ) ; return ( ( a -> format_write_data ) ( a , buff , s ) ) ; }\n","target":"<S2SV_ModStart> ) _a ; const size_t max_write = INT_MAX ; <S2SV_ModStart> , \"archive_write_data\" ) ; if ( s > max_write ) s = max_write\n","project_and_commit_id":"libarchive@libarchive/22531545514043e04633e1c015c7540b9de9dbe4","cve_id":"CVE-2013-0211","original_address":"https://github.com/libarchive/libarchive/commit/22531545514043e04633e1c015c7540b9de9dbe4","time":"2013-09-30T22:55Z"},
	{"Unnamed: 0":6625,"cwe_id":"CWE-190","source":"CWE-190 void jas_matrix_divpow2 ( jas_matrix_t * matrix , int n ) { <S2SV_StartBug> int i ; <S2SV_EndBug> int j ; jas_seqent_t * rowstart ; <S2SV_StartBug> int rowstep ; <S2SV_EndBug> jas_seqent_t * data ; if ( jas_matrix_numrows ( matrix ) > 0 && jas_matrix_numcols ( matrix ) > 0 ) { assert ( matrix -> rows_ ) ; rowstep = jas_matrix_rowstep ( matrix ) ; for ( i = matrix -> numrows_ , rowstart = matrix -> rows_ [ 0 ] ; i > 0 ; -- i , rowstart += rowstep ) { for ( j = matrix -> numcols_ , data = rowstart ; j > 0 ; -- j , ++ data ) { * data = ( * data >= 0 ) ? ( ( * data ) >> n ) : ( - ( ( - ( * data ) ) >> n ) ) ; } } } }\n","target":"<S2SV_ModStart> n ) { jas_matind_t i ; jas_matind_t <S2SV_ModEnd> j ; jas_seqent_t <S2SV_ModStart> * rowstart ; jas_matind_t <S2SV_ModEnd> rowstep ; jas_seqent_t\n","project_and_commit_id":"mdadams@jasper/d42b2388f7f8e0332c846675133acea151fc557a","cve_id":"CVE-2016-9557","original_address":"https://github.com/mdadams/jasper/commit/d42b2388f7f8e0332c846675133acea151fc557a","time":"2017-03-23T18:59Z"},
	{"Unnamed: 0":3139,"cwe_id":"CWE-264","source":"CWE-264 void setattr_copy ( struct inode * inode , const struct iattr * attr ) { unsigned int ia_valid = attr -> ia_valid ; if ( ia_valid & ATTR_UID ) inode -> i_uid = attr -> ia_uid ; if ( ia_valid & ATTR_GID ) inode -> i_gid = attr -> ia_gid ; if ( ia_valid & ATTR_ATIME ) inode -> i_atime = timespec_trunc ( attr -> ia_atime , inode -> i_sb -> s_time_gran ) ; if ( ia_valid & ATTR_MTIME ) inode -> i_mtime = timespec_trunc ( attr -> ia_mtime , inode -> i_sb -> s_time_gran ) ; if ( ia_valid & ATTR_CTIME ) inode -> i_ctime = timespec_trunc ( attr -> ia_ctime , inode -> i_sb -> s_time_gran ) ; if ( ia_valid & ATTR_MODE ) { umode_t mode = attr -> ia_mode ; if ( ! in_group_p ( inode -> i_gid ) && <S2SV_StartBug> ! inode_capable ( inode , CAP_FSETID ) ) <S2SV_EndBug> mode &= ~ S_ISGID ; inode -> i_mode = mode ; } }\n","target":"<S2SV_ModStart> ) && ! capable_wrt_inode_uidgid <S2SV_ModEnd> ( inode ,\n","project_and_commit_id":"torvalds@linux/23adbe12ef7d3d4195e80800ab36b37bee28cd03","cve_id":"CVE-2014-4014","original_address":"https://github.com/torvalds/linux/commit/23adbe12ef7d3d4195e80800ab36b37bee28cd03","time":"2014-06-23T11:21Z"},
	{"Unnamed: 0":1280,"cwe_id":"CWE-000","source":"CWE-000 struct key * key_alloc ( struct key_type * type , const char * desc , kuid_t uid , kgid_t gid , const struct cred * cred , key_perm_t perm , unsigned long flags , struct key_restriction * restrict_link ) { struct key_user * user = NULL ; struct key * key ; size_t desclen , quotalen ; int ret ; key = ERR_PTR ( - EINVAL ) ; if ( ! desc || ! * desc ) goto error ; if ( type -> vet_description ) { ret = type -> vet_description ( desc ) ; if ( ret < 0 ) { key = ERR_PTR ( ret ) ; goto error ; } } desclen = strlen ( desc ) ; quotalen = desclen + 1 + type -> def_datalen ; user = key_user_lookup ( uid ) ; if ( ! user ) goto no_memory_1 ; if ( ! ( flags & KEY_ALLOC_NOT_IN_QUOTA ) ) { unsigned maxkeys = uid_eq ( uid , GLOBAL_ROOT_UID ) ? key_quota_root_maxkeys : key_quota_maxkeys ; unsigned maxbytes = uid_eq ( uid , GLOBAL_ROOT_UID ) ? key_quota_root_maxbytes : key_quota_maxbytes ; spin_lock ( & user -> lock ) ; if ( ! ( flags & KEY_ALLOC_QUOTA_OVERRUN ) ) { if ( user -> qnkeys + 1 >= maxkeys || user -> qnbytes + quotalen >= maxbytes || user -> qnbytes + quotalen < user -> qnbytes ) goto no_quota ; } user -> qnkeys ++ ; user -> qnbytes += quotalen ; spin_unlock ( & user -> lock ) ; } key = kmem_cache_zalloc ( key_jar , GFP_KERNEL ) ; if ( ! key ) goto no_memory_2 ; key -> index_key . desc_len = desclen ; key -> index_key . description = kmemdup ( desc , desclen + 1 , GFP_KERNEL ) ; if ( ! key -> index_key . description ) goto no_memory_3 ; refcount_set ( & key -> usage , 1 ) ; init_rwsem ( & key -> sem ) ; lockdep_set_class ( & key -> sem , & type -> lock_class ) ; key -> index_key . type = type ; key -> user = user ; key -> quotalen = quotalen ; key -> datalen = type -> def_datalen ; key -> uid = uid ; key -> gid = gid ; key -> perm = perm ; key -> restrict_link = restrict_link ; if ( ! ( flags & KEY_ALLOC_NOT_IN_QUOTA ) ) key -> flags |= 1 << KEY_FLAG_IN_QUOTA ; if ( flags & KEY_ALLOC_BUILT_IN ) key -> flags |= 1 << KEY_FLAG_BUILTIN ; <S2SV_StartBug> # ifdef KEY_DEBUGGING <S2SV_EndBug> key -> magic = KEY_DEBUG_MAGIC ; # endif ret = security_key_alloc ( key , cred , flags ) ; if ( ret < 0 ) goto security_error ; atomic_inc ( & user -> nkeys ) ; key_alloc_serial ( key ) ; error : return key ; security_error : kfree ( key -> description ) ; kmem_cache_free ( key_jar , key ) ; if ( ! ( flags & KEY_ALLOC_NOT_IN_QUOTA ) ) { spin_lock ( & user -> lock ) ; user -> qnkeys -- ; user -> qnbytes -= quotalen ; spin_unlock ( & user -> lock ) ; } key_user_put ( user ) ; key = ERR_PTR ( ret ) ; goto error ; no_memory_3 : kmem_cache_free ( key_jar , key ) ; no_memory_2 : if ( ! ( flags & KEY_ALLOC_NOT_IN_QUOTA ) ) { spin_lock ( & user -> lock ) ; user -> qnkeys -- ; user -> qnbytes -= quotalen ; spin_unlock ( & user -> lock ) ; } key_user_put ( user ) ; no_memory_1 : key = ERR_PTR ( - ENOMEM ) ; goto error ; no_quota : spin_unlock ( & user -> lock ) ; key_user_put ( user ) ; key = ERR_PTR ( - EDQUOT ) ; goto error ; }\n","target":"<S2SV_ModStart> << KEY_FLAG_BUILTIN ; if ( flags & KEY_ALLOC_UID_KEYRING ) key -> flags |= 1 << KEY_FLAG_UID_KEYRING ;\n","project_and_commit_id":"torvalds@linux/237bbd29f7a049d310d907f4b2716a7feef9abf3","cve_id":"CVE-2017-18270","original_address":"https://github.com/torvalds/linux/commit/237bbd29f7a049d310d907f4b2716a7feef9abf3","time":"2018-05-18T16:29Z"},
	{"Unnamed: 0":4868,"cwe_id":"CWE-20","source":"CWE-20 static int _snd_timer_stop ( struct snd_timer_instance * timeri , int keep_flag , int event ) { struct snd_timer * timer ; unsigned long flags ; if ( snd_BUG_ON ( ! timeri ) ) return - ENXIO ; if ( timeri -> flags & SNDRV_TIMER_IFLG_SLAVE ) { if ( ! keep_flag ) { spin_lock_irqsave ( & slave_active_lock , flags ) ; timeri -> flags &= ~ SNDRV_TIMER_IFLG_RUNNING ; <S2SV_StartBug> spin_unlock_irqrestore ( & slave_active_lock , flags ) ; <S2SV_EndBug> } goto __end ; } timer = timeri -> timer ; if ( ! timer ) return - EINVAL ; spin_lock_irqsave ( & timer -> lock , flags ) ; list_del_init ( & timeri -> ack_list ) ; list_del_init ( & timeri -> active_list ) ; if ( ( timeri -> flags & SNDRV_TIMER_IFLG_RUNNING ) && ! ( -- timer -> running ) ) { timer -> hw . stop ( timer ) ; if ( timer -> flags & SNDRV_TIMER_FLG_RESCHED ) { timer -> flags &= ~ SNDRV_TIMER_FLG_RESCHED ; snd_timer_reschedule ( timer , 0 ) ; if ( timer -> flags & SNDRV_TIMER_FLG_CHANGE ) { timer -> flags &= ~ SNDRV_TIMER_FLG_CHANGE ; timer -> hw . start ( timer ) ; } } } if ( ! keep_flag ) timeri -> flags &= ~ ( SNDRV_TIMER_IFLG_RUNNING | SNDRV_TIMER_IFLG_START ) ; spin_unlock_irqrestore ( & timer -> lock , flags ) ; __end : if ( event != SNDRV_TIMER_EVENT_RESOLUTION ) snd_timer_notify1 ( timeri , event ) ; return 0 ; }\n","target":"<S2SV_ModStart> ~ SNDRV_TIMER_IFLG_RUNNING ; list_del_init ( & timeri -> ack_list ) ; list_del_init ( & timeri -> active_list ) ;\n","project_and_commit_id":"torvalds@linux/b5a663aa426f4884c71cd8580adae73f33570f0d","cve_id":"CVE-2016-2548","original_address":"https://github.com/torvalds/linux/commit/b5a663aa426f4884c71cd8580adae73f33570f0d","time":"2016-04-27T17:59Z"},
	{"Unnamed: 0":3199,"cwe_id":"CWE-119","source":"CWE-119 const vpx_image_t * vpx_codec_get_preview_frame ( vpx_codec_ctx_t * ctx ) { vpx_image_t * img = NULL ; if ( ctx ) { if ( ! ctx -> iface || ! ctx -> priv ) ctx -> err = VPX_CODEC_ERROR ; else if ( ! ( ctx -> iface -> caps & VPX_CODEC_CAP_ENCODER ) ) ctx -> err = VPX_CODEC_INCAPABLE ; else if ( ! ctx -> iface -> enc . get_preview ) ctx -> err = VPX_CODEC_INCAPABLE ; else <S2SV_StartBug> img = ctx -> iface -> enc . get_preview ( ctx -> priv -> alg_priv ) ; <S2SV_EndBug> } return img ; }\n","target":"<S2SV_ModStart> . get_preview ( get_alg_priv ( ctx ) <S2SV_ModEnd> ) ; }\n","project_and_commit_id":"external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426","cve_id":"CVE-2016-1621","original_address":"https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426","time":"2016-03-12T21:59Z"},
	{"Unnamed: 0":5231,"cwe_id":"CWE-119","source":"CWE-119 <S2SV_StartBug> static int m88rs2000_frontend_attach ( struct dvb_usb_adapter * d ) <S2SV_EndBug> { u8 obuf [ ] = { 0x51 } ; u8 ibuf [ ] = { 0 } ; <S2SV_StartBug> if ( dvb_usb_generic_rw ( d -> dev , obuf , 1 , ibuf , 1 , 0 ) < 0 ) <S2SV_EndBug> err ( \"command<S2SV_blank>0x51<S2SV_blank>transfer<S2SV_blank>failed.\" ) ; <S2SV_StartBug> d -> fe_adap [ 0 ] . fe = dvb_attach ( m88rs2000_attach , & s421_m88rs2000_config , <S2SV_EndBug> <S2SV_StartBug> & d -> dev -> i2c_adap ) ; <S2SV_EndBug> <S2SV_StartBug> if ( d -> fe_adap [ 0 ] . fe == NULL ) <S2SV_EndBug> return - EIO ; <S2SV_StartBug> if ( dvb_attach ( ts2020_attach , d -> fe_adap [ 0 ] . fe , <S2SV_EndBug> & dw2104_ts2020_config , <S2SV_StartBug> & d -> dev -> i2c_adap ) ) { <S2SV_EndBug> info ( \"Attached<S2SV_blank>RS2000/TS2020!\" ) ; return 0 ; } info ( \"Failed<S2SV_blank>to<S2SV_blank>attach<S2SV_blank>RS2000/TS2020!\" ) ; return - EIO ; }\n","target":"<S2SV_ModStart> struct dvb_usb_adapter * adap ) { struct dvb_usb_device * d = adap -> dev ; struct dw2102_state * state = d -> priv ; mutex_lock ( & d -> data_mutex ) ; state -> data [ 0 ] = 0x51 <S2SV_ModEnd> ; if ( <S2SV_ModStart> dvb_usb_generic_rw ( d , state -> data <S2SV_ModEnd> , 1 , <S2SV_ModStart> , 1 , state -> data <S2SV_ModEnd> , 1 , <S2SV_ModStart> \"command<S2SV_blank>0x51<S2SV_blank>transfer<S2SV_blank>failed.\" ) ; mutex_unlock ( & d -> data_mutex ) ; adap <S2SV_ModEnd> -> fe_adap [ <S2SV_ModStart> & d -> <S2SV_ModEnd> i2c_adap ) ; <S2SV_ModStart> ; if ( adap <S2SV_ModEnd> -> fe_adap [ <S2SV_ModStart> ( ts2020_attach , adap <S2SV_ModEnd> -> fe_adap [ <S2SV_ModStart> , & d <S2SV_ModEnd> -> i2c_adap )\n","project_and_commit_id":"torvalds@linux/606142af57dad981b78707234cfbd15f9f7b7125","cve_id":"CVE-2017-8062","original_address":"https://github.com/torvalds/linux/commit/606142af57dad981b78707234cfbd15f9f7b7125","time":"2017-04-23T05:59Z"},
	{"Unnamed: 0":5253,"cwe_id":"CWE-416","source":"CWE-416 static int usb_audio_probe ( struct usb_interface * intf , const struct usb_device_id * usb_id ) { struct usb_device * dev = interface_to_usbdev ( intf ) ; const struct snd_usb_audio_quirk * quirk = ( const struct snd_usb_audio_quirk * ) usb_id -> driver_info ; struct snd_usb_audio * chip ; int i , err ; struct usb_host_interface * alts ; int ifnum ; u32 id ; alts = & intf -> altsetting [ 0 ] ; ifnum = get_iface_desc ( alts ) -> bInterfaceNumber ; id = USB_ID ( le16_to_cpu ( dev -> descriptor . idVendor ) , le16_to_cpu ( dev -> descriptor . idProduct ) ) ; if ( get_alias_id ( dev , & id ) ) quirk = get_alias_quirk ( dev , id ) ; if ( quirk && quirk -> ifnum >= 0 && ifnum != quirk -> ifnum ) return - ENXIO ; err = snd_usb_apply_boot_quirk ( dev , intf , quirk , id ) ; if ( err < 0 ) return err ; chip = NULL ; mutex_lock ( & register_mutex ) ; for ( i = 0 ; i < SNDRV_CARDS ; i ++ ) { if ( usb_chip [ i ] && usb_chip [ i ] -> dev == dev ) { if ( atomic_read ( & usb_chip [ i ] -> shutdown ) ) { dev_err ( & dev -> dev , \"USB<S2SV_blank>device<S2SV_blank>is<S2SV_blank>in<S2SV_blank>the<S2SV_blank>shutdown<S2SV_blank>state,<S2SV_blank>cannot<S2SV_blank>create<S2SV_blank>a<S2SV_blank>card<S2SV_blank>instance\\\\n\" ) ; err = - EIO ; goto __error ; } chip = usb_chip [ i ] ; atomic_inc ( & chip -> active ) ; break ; } } if ( ! chip ) { for ( i = 0 ; i < SNDRV_CARDS ; i ++ ) if ( ! usb_chip [ i ] && ( vid [ i ] == - 1 || vid [ i ] == USB_ID_VENDOR ( id ) ) && ( pid [ i ] == - 1 || pid [ i ] == USB_ID_PRODUCT ( id ) ) ) { if ( enable [ i ] ) { err = snd_usb_audio_create ( intf , dev , i , quirk , id , & chip ) ; if ( err < 0 ) goto __error ; chip -> pm_intf = intf ; break ; } else if ( vid [ i ] != - 1 || pid [ i ] != - 1 ) { dev_info ( & dev -> dev , \"device<S2SV_blank>(%04x:%04x)<S2SV_blank>is<S2SV_blank>disabled\\\\n\" , USB_ID_VENDOR ( id ) , USB_ID_PRODUCT ( id ) ) ; err = - ENOENT ; goto __error ; } } if ( ! chip ) { dev_err ( & dev -> dev , \"no<S2SV_blank>available<S2SV_blank>usb<S2SV_blank>audio<S2SV_blank>device\\\\n\" ) ; err = - ENODEV ; goto __error ; } } dev_set_drvdata ( & dev -> dev , chip ) ; if ( ! chip -> ctrl_intf ) chip -> ctrl_intf = alts ; chip -> txfr_quirk = 0 ; err = 1 ; if ( quirk && quirk -> ifnum != QUIRK_NO_INTERFACE ) { err = snd_usb_create_quirk ( chip , intf , & usb_audio_driver , quirk ) ; if ( err < 0 ) goto __error ; } if ( err > 0 ) { err = snd_usb_create_streams ( chip , ifnum ) ; if ( err < 0 ) goto __error ; err = snd_usb_create_mixer ( chip , ifnum , ignore_ctl_error ) ; if ( err < 0 ) goto __error ; } err = snd_card_register ( chip -> card ) ; if ( err < 0 ) goto __error ; usb_chip [ chip -> index ] = chip ; chip -> num_interfaces ++ ; usb_set_intfdata ( intf , chip ) ; atomic_dec ( & chip -> active ) ; mutex_unlock ( & register_mutex ) ; return 0 ; __error : if ( chip ) { <S2SV_StartBug> if ( ! chip -> num_interfaces ) <S2SV_EndBug> snd_card_free ( chip -> card ) ; <S2SV_StartBug> atomic_dec ( & chip -> active ) ; <S2SV_EndBug> } mutex_unlock ( & register_mutex ) ; return err ; }\n","target":"<S2SV_ModStart> chip ) { atomic_dec ( & chip -> active ) ; <S2SV_ModStart> card ) ; <S2SV_ModEnd> } mutex_unlock (\n","project_and_commit_id":"torvalds@linux/5f8cf712582617d523120df67d392059eaf2fc4b","cve_id":"CVE-2018-19824","original_address":"https://github.com/torvalds/linux/commit/5f8cf712582617d523120df67d392059eaf2fc4b","time":"2018-12-03T17:29Z"},
	{"Unnamed: 0":1830,"cwe_id":"CWE-119","source":"CWE-119 WORD32 ih264d_cavlc_4x4res_block_totalcoeff_2to10 ( UWORD32 u4_isdc , UWORD32 u4_total_coeff_trail_one , dec_bit_stream_t * ps_bitstrm ) { UWORD32 u4_total_zeroes ; WORD32 i ; UWORD32 * pu4_bitstrm_buf = ps_bitstrm -> pu4_buffer ; UWORD32 u4_bitstream_offset = ps_bitstrm -> u4_ofst ; UWORD32 u4_trailing_ones = u4_total_coeff_trail_one & 0xFFFF ; UWORD32 u4_total_coeff = u4_total_coeff_trail_one >> 16 ; <S2SV_StartBug> WORD16 i2_level_arr [ 16 ] ; <S2SV_EndBug> tu_sblk4x4_coeff_data_t * ps_tu_4x4 ; WORD16 * pi2_coeff_data ; dec_struct_t * ps_dec = ( dec_struct_t * ) ps_bitstrm -> pv_codec_handle ; ps_tu_4x4 = ( tu_sblk4x4_coeff_data_t * ) ps_dec -> pv_parse_tu_coeff_data ; ps_tu_4x4 -> u2_sig_coeff_map = 0 ; pi2_coeff_data = & ps_tu_4x4 -> ai2_level [ 0 ] ; i = u4_total_coeff - 1 ; if ( u4_trailing_ones ) { UWORD32 u4_signs , u4_cnt = u4_trailing_ones ; WORD16 ( * ppi2_trlone_lkup ) [ 3 ] = ( WORD16 ( * ) [ 3 ] ) gai2_ih264d_trailing_one_level ; WORD16 * pi2_trlone_lkup ; GETBITS ( u4_signs , u4_bitstream_offset , pu4_bitstrm_buf , u4_cnt ) ; pi2_trlone_lkup = ppi2_trlone_lkup [ ( 1 << u4_cnt ) - 2 + u4_signs ] ; while ( u4_cnt -- ) i2_level_arr [ i -- ] = * pi2_trlone_lkup ++ ; } if ( i >= 0 ) { UWORD32 u4_lev_suffix , u4_suffix_len , u4_lev_suffix_size ; WORD32 u2_lev_code , u2_abs_value ; UWORD32 u4_lev_prefix ; FIND_ONE_IN_STREAM_32 ( u4_lev_prefix , u4_bitstream_offset , pu4_bitstrm_buf ) ; u2_lev_code = MIN ( 15 , u4_lev_prefix ) ; u2_lev_code += ( 3 == u4_trailing_ones ) ? 0 : 2 ; if ( 14 == u4_lev_prefix ) u4_lev_suffix_size = 4 ; else if ( 15 <= u4_lev_prefix ) { u2_lev_code += 15 ; u4_lev_suffix_size = u4_lev_prefix - 3 ; } else u4_lev_suffix_size = 0 ; if ( 16 <= u4_lev_prefix ) { u2_lev_code += ( ( 1 << ( u4_lev_prefix - 3 ) ) - 4096 ) ; } if ( u4_lev_suffix_size ) { GETBITS ( u4_lev_suffix , u4_bitstream_offset , pu4_bitstrm_buf , u4_lev_suffix_size ) ; u2_lev_code += u4_lev_suffix ; } u2_abs_value = ( u2_lev_code + 2 ) >> 1 ; i2_level_arr [ i -- ] = ( u2_lev_code & 1 ) ? - u2_abs_value : u2_abs_value ; u4_suffix_len = ( u2_abs_value > 3 ) ? 2 : 1 ; while ( i >= 0 ) { FIND_ONE_IN_STREAM_32 ( u4_lev_prefix , u4_bitstream_offset , pu4_bitstrm_buf ) ; u4_lev_suffix_size = ( 15 <= u4_lev_prefix ) ? ( u4_lev_prefix - 3 ) : u4_suffix_len ; GETBITS ( u4_lev_suffix , u4_bitstream_offset , pu4_bitstrm_buf , u4_lev_suffix_size ) ; u2_lev_code = ( MIN ( 15 , u4_lev_prefix ) << u4_suffix_len ) + u4_lev_suffix ; if ( 16 <= u4_lev_prefix ) { u2_lev_code += ( ( 1 << ( u4_lev_prefix - 3 ) ) - 4096 ) ; } u2_abs_value = ( u2_lev_code + 2 ) >> 1 ; i2_level_arr [ i -- ] = ( u2_lev_code & 1 ) ? - u2_abs_value : u2_abs_value ; u4_suffix_len += ( u4_suffix_len < 6 ) ? ( u2_abs_value > ( 3 << ( u4_suffix_len - 1 ) ) ) : 0 ; } } { UWORD32 u4_index ; const UWORD8 ( * ppu1_total_zero_lkup ) [ 64 ] = ( const UWORD8 ( * ) [ 64 ] ) gau1_ih264d_table_total_zero_2to10 ; NEXTBITS ( u4_index , u4_bitstream_offset , pu4_bitstrm_buf , 6 ) ; u4_total_zeroes = ppu1_total_zero_lkup [ u4_total_coeff - 2 ] [ u4_index ] ; FLUSHBITS ( u4_bitstream_offset , ( u4_total_zeroes >> 4 ) ) ; u4_total_zeroes &= 0xf ; } { const UWORD8 * pu1_table_runbefore ; UWORD32 u4_run ; WORD32 k ; UWORD32 u4_scan_pos = u4_total_coeff + u4_total_zeroes - 1 + u4_isdc ; WORD32 u4_zeroes_left = u4_total_zeroes ; k = u4_total_coeff - 1 ; while ( ( u4_zeroes_left > 6 ) && k ) { UWORD32 u4_code ; NEXTBITS ( u4_code , u4_bitstream_offset , pu4_bitstrm_buf , 3 ) ; if ( u4_code != 0 ) { FLUSHBITS ( u4_bitstream_offset , 3 ) ; u4_run = ( 7 - u4_code ) ; } else { FIND_ONE_IN_STREAM_LEN ( u4_code , u4_bitstream_offset , pu4_bitstrm_buf , 11 ) ; u4_run = ( 4 + u4_code ) ; } SET_BIT ( ps_tu_4x4 -> u2_sig_coeff_map , u4_scan_pos ) ; * pi2_coeff_data ++ = i2_level_arr [ k -- ] ; u4_zeroes_left -= u4_run ; u4_scan_pos -= ( u4_run + 1 ) ; } pu1_table_runbefore = ( UWORD8 * ) gau1_ih264d_table_run_before ; while ( ( u4_zeroes_left > 0 ) && k ) { UWORD32 u4_code ; NEXTBITS ( u4_code , u4_bitstream_offset , pu4_bitstrm_buf , 3 ) ; u4_code = pu1_table_runbefore [ u4_code + ( u4_zeroes_left << 3 ) ] ; u4_run = u4_code >> 2 ; FLUSHBITS ( u4_bitstream_offset , ( u4_code & 0x03 ) ) ; SET_BIT ( ps_tu_4x4 -> u2_sig_coeff_map , u4_scan_pos ) ; * pi2_coeff_data ++ = i2_level_arr [ k -- ] ; u4_zeroes_left -= u4_run ; u4_scan_pos -= ( u4_run + 1 ) ; } if ( u4_zeroes_left < 0 ) return - 1 ; while ( k >= 0 ) { SET_BIT ( ps_tu_4x4 -> u2_sig_coeff_map , u4_scan_pos ) ; * pi2_coeff_data ++ = i2_level_arr [ k -- ] ; u4_scan_pos -- ; } } { WORD32 offset ; offset = ( UWORD8 * ) pi2_coeff_data - ( UWORD8 * ) ps_tu_4x4 ; offset = ALIGN4 ( offset ) ; ps_dec -> pv_parse_tu_coeff_data = ( void * ) ( ( UWORD8 * ) ps_dec -> pv_parse_tu_coeff_data + offset ) ; } ps_bitstrm -> u4_ofst = u4_bitstream_offset ; return 0 ; }\n","target":"<S2SV_ModStart> 16 ; WORD16 ai2_level_arr [ 19 ] ; WORD16 * i2_level_arr = & ai2_level_arr [ 3 <S2SV_ModEnd> ] ; tu_sblk4x4_coeff_data_t\n","project_and_commit_id":"external@libavc/c57fc3703ae2e0d41b1f6580c50015937f2d23c1","cve_id":"CVE-2016-0840","original_address":"https://android.googlesource.com/platform/external/libavc/+/c57fc3703ae2e0d41b1f6580c50015937f2d23c1","time":"2016-04-18T00:59Z"},
	{"Unnamed: 0":1958,"cwe_id":"CWE-400","source":"CWE-400 int perf_output_begin ( struct perf_output_handle * handle , struct perf_event * event , unsigned int size , <S2SV_StartBug> int nmi , int sample ) <S2SV_EndBug> { struct ring_buffer * rb ; unsigned long tail , offset , head ; int have_lost ; struct perf_sample_data sample_data ; struct { struct perf_event_header header ; u64 id ; u64 lost ; } lost_event ; rcu_read_lock ( ) ; if ( event -> parent ) event = event -> parent ; rb = rcu_dereference ( event -> rb ) ; if ( ! rb ) goto out ; handle -> rb = rb ; handle -> event = event ; <S2SV_StartBug> handle -> nmi = nmi ; <S2SV_EndBug> handle -> sample = sample ; if ( ! rb -> nr_pages ) goto out ; have_lost = local_read ( & rb -> lost ) ; if ( have_lost ) { lost_event . header . size = sizeof ( lost_event ) ; perf_event_header__init_id ( & lost_event . header , & sample_data , event ) ; size += lost_event . header . size ; } perf_output_get_handle ( handle ) ; do { tail = ACCESS_ONCE ( rb -> user_page -> data_tail ) ; smp_rmb ( ) ; offset = head = local_read ( & rb -> head ) ; head += size ; if ( unlikely ( ! perf_output_space ( rb , tail , offset , head ) ) ) goto fail ; } while ( local_cmpxchg ( & rb -> head , offset , head ) != offset ) ; if ( head - local_read ( & rb -> wakeup ) > rb -> watermark ) local_add ( rb -> watermark , & rb -> wakeup ) ; handle -> page = offset >> ( PAGE_SHIFT + page_order ( rb ) ) ; handle -> page &= rb -> nr_pages - 1 ; handle -> size = offset & ( ( PAGE_SIZE << page_order ( rb ) ) - 1 ) ; handle -> addr = rb -> data_pages [ handle -> page ] ; handle -> addr += handle -> size ; handle -> size = ( PAGE_SIZE << page_order ( rb ) ) - handle -> size ; if ( have_lost ) { lost_event . header . type = PERF_RECORD_LOST ; lost_event . header . misc = 0 ; lost_event . id = event -> id ; lost_event . lost = local_xchg ( & rb -> lost , 0 ) ; perf_output_put ( handle , lost_event ) ; perf_event__output_id_sample ( event , handle , & sample_data ) ; } return 0 ; fail : local_inc ( & rb -> lost ) ; perf_output_put_handle ( handle ) ; out : rcu_read_unlock ( ) ; return - ENOSPC ; }\n","target":"<S2SV_ModStart> size , int <S2SV_ModEnd> sample ) { <S2SV_ModStart> ; handle -> <S2SV_ModEnd> sample = sample\n","project_and_commit_id":"torvalds@linux/a8b0ca17b80e92faab46ee7179ba9e99ccb61233","cve_id":"CVE-2011-2918","original_address":"https://github.com/torvalds/linux/commit/a8b0ca17b80e92faab46ee7179ba9e99ccb61233","time":"2012-05-24T23:55Z"},
	{"Unnamed: 0":2380,"cwe_id":"CWE-119","source":"CWE-119 static int cxusb_ctrl_msg ( struct dvb_usb_device * d , u8 cmd , u8 * wbuf , int wlen , u8 * rbuf , int rlen ) { struct cxusb_state * st = d -> priv ; <S2SV_StartBug> int ret , wo ; <S2SV_EndBug> if ( 1 + wlen > MAX_XFER_SIZE ) { warn ( \"i2c<S2SV_blank>wr:<S2SV_blank>len=%d<S2SV_blank>is<S2SV_blank>too<S2SV_blank>big!\\\\n\" , wlen ) ; return - EOPNOTSUPP ; } <S2SV_StartBug> wo = ( rbuf == NULL || rlen == 0 ) ; <S2SV_EndBug> mutex_lock ( & d -> data_mutex ) ; st -> data [ 0 ] = cmd ; memcpy ( & st -> data [ 1 ] , wbuf , wlen ) ; <S2SV_StartBug> if ( wo ) <S2SV_EndBug> ret = dvb_usb_generic_write ( d , st -> data , 1 + wlen ) ; else ret = dvb_usb_generic_rw ( d , st -> data , 1 + wlen , <S2SV_StartBug> rbuf , rlen , 0 ) ; <S2SV_EndBug> mutex_unlock ( & d -> data_mutex ) ; return ret ; }\n","target":"<S2SV_ModStart> ; int ret <S2SV_ModEnd> ; if ( <S2SV_ModStart> EOPNOTSUPP ; } if ( rlen > MAX_XFER_SIZE ) { warn ( \"i2c<S2SV_blank>rd:<S2SV_blank>len=%d<S2SV_blank>is<S2SV_blank>too<S2SV_blank>big!\\\\n\" , rlen ) ; return - EOPNOTSUPP ; } <S2SV_ModEnd> mutex_lock ( & <S2SV_ModStart> wlen ) ; <S2SV_ModEnd> ret = dvb_usb_generic_rw <S2SV_ModStart> + wlen , st -> data <S2SV_ModEnd> , rlen , <S2SV_ModStart> rlen , 0 ) ; if ( ! ret && rbuf && rlen ) memcpy ( rbuf , st -> data , rlen\n","project_and_commit_id":"torvalds@linux/3f190e3aec212fc8c61e202c51400afa7384d4bc","cve_id":"CVE-2017-8063","original_address":"https://github.com/torvalds/linux/commit/3f190e3aec212fc8c61e202c51400afa7384d4bc","time":"2017-04-23T05:59Z"},
	{"Unnamed: 0":3311,"cwe_id":"CWE-119","source":"CWE-119 <S2SV_StartBug> static int cost_mv_ref ( const VP9_COMP * cpi , MB_PREDICTION_MODE mode , <S2SV_EndBug> <S2SV_StartBug> int mode_context ) { <S2SV_EndBug> const MACROBLOCK * const x = & cpi -> mb ; const int segment_id = x -> e_mbd . mi [ 0 ] -> mbmi . segment_id ; if ( ! vp9_segfeature_active ( & cpi -> common . seg , segment_id , SEG_LVL_SKIP ) ) { assert ( is_inter_mode ( mode ) ) ; <S2SV_StartBug> return x -> inter_mode_cost [ mode_context ] [ INTER_OFFSET ( mode ) ] ; <S2SV_EndBug> <S2SV_StartBug> } else { <S2SV_EndBug> return 0 ; } }\n","target":"<S2SV_ModStart> * cpi , PREDICTION_MODE <S2SV_ModEnd> mode , int <S2SV_ModStart> , int mode_context <S2SV_ModEnd> ) { assert <S2SV_ModStart> ) ; return cpi <S2SV_ModEnd> -> inter_mode_cost [ <S2SV_ModStart> ] ; } <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null>\n","project_and_commit_id":"external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426","cve_id":"CVE-2016-1621","original_address":"https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426","time":"2016-03-12T21:59Z"},
	{"Unnamed: 0":3957,"cwe_id":"CWE-119","source":"CWE-119 int dbd_bind_ph ( SV * sth , imp_sth_t * imp_sth , SV * param , SV * value , IV sql_type , SV * attribs , int is_inout , IV maxlen ) { dTHX ; int rc ; int param_num = SvIV ( param ) ; int idx = param_num - 1 ; <S2SV_StartBug> char err_msg [ 64 ] ; <S2SV_EndBug> D_imp_xxh ( sth ) ; # if MYSQL_VERSION_ID >= SERVER_PREPARE_VERSION STRLEN slen ; char * buffer = NULL ; int buffer_is_null = 0 ; int buffer_length = slen ; unsigned int buffer_type = 0 ; IV tmp ; # endif D_imp_dbh_from_sth ; ASYNC_CHECK_RETURN ( sth , FALSE ) ; if ( DBIc_TRACE_LEVEL ( imp_xxh ) >= 2 ) PerlIO_printf ( DBIc_LOGPIO ( imp_xxh ) , \"<S2SV_blank><S2SV_blank><S2SV_blank>Called:<S2SV_blank>dbd_bind_ph\\\\n\" ) ; attribs = attribs ; maxlen = maxlen ; if ( param_num <= 0 || param_num > DBIc_NUM_PARAMS ( imp_sth ) ) { do_error ( sth , JW_ERR_ILLEGAL_PARAM_NUM , \"Illegal<S2SV_blank>parameter<S2SV_blank>number\" , NULL ) ; return FALSE ; } if ( SvOK ( value ) && ( sql_type == SQL_NUMERIC || sql_type == SQL_DECIMAL || sql_type == SQL_INTEGER || sql_type == SQL_SMALLINT || sql_type == SQL_FLOAT || sql_type == SQL_REAL || sql_type == SQL_DOUBLE ) ) { if ( ! looks_like_number ( value ) ) { <S2SV_StartBug> sprintf ( err_msg , <S2SV_EndBug> \"Binding<S2SV_blank>non-numeric<S2SV_blank>field<S2SV_blank>%d,<S2SV_blank>value<S2SV_blank>%s<S2SV_blank>as<S2SV_blank>a<S2SV_blank>numeric!\" , <S2SV_StartBug> param_num , neatsvpv ( value , 0 ) ) ; <S2SV_EndBug> do_error ( sth , JW_ERR_ILLEGAL_PARAM_NUM , err_msg , NULL ) ; } } if ( is_inout ) { do_error ( sth , JW_ERR_NOT_IMPLEMENTED , \"Output<S2SV_blank>parameters<S2SV_blank>not<S2SV_blank>implemented\" , NULL ) ; return FALSE ; } rc = bind_param ( & imp_sth -> params [ idx ] , value , sql_type ) ; # if MYSQL_VERSION_ID >= SERVER_PREPARE_VERSION if ( imp_sth -> use_server_side_prepare ) { switch ( sql_type ) { case SQL_NUMERIC : case SQL_INTEGER : case SQL_SMALLINT : case SQL_BIGINT : case SQL_TINYINT : buffer_type = MYSQL_TYPE_LONG ; break ; case SQL_DOUBLE : case SQL_DECIMAL : case SQL_FLOAT : case SQL_REAL : buffer_type = MYSQL_TYPE_DOUBLE ; break ; case SQL_CHAR : case SQL_VARCHAR : case SQL_DATE : case SQL_TIME : case SQL_TIMESTAMP : case SQL_LONGVARCHAR : case SQL_BINARY : case SQL_VARBINARY : case SQL_LONGVARBINARY : buffer_type = MYSQL_TYPE_BLOB ; break ; default : buffer_type = MYSQL_TYPE_STRING ; } buffer_is_null = ! ( SvOK ( imp_sth -> params [ idx ] . value ) && imp_sth -> params [ idx ] . value ) ; if ( ! buffer_is_null ) { switch ( buffer_type ) { case MYSQL_TYPE_LONG : if ( ! SvIOK ( imp_sth -> params [ idx ] . value ) && DBIc_TRACE_LEVEL ( imp_xxh ) >= 2 ) PerlIO_printf ( DBIc_LOGPIO ( imp_xxh ) , \"\\\\t\\\\tTRY<S2SV_blank>TO<S2SV_blank>BIND<S2SV_blank>AN<S2SV_blank>INT<S2SV_blank>NUMBER\\\\n\" ) ; buffer_length = sizeof imp_sth -> fbind [ idx ] . numeric_val . lval ; tmp = SvIV ( imp_sth -> params [ idx ] . value ) ; if ( tmp > INT32_MAX ) croak ( \"Could<S2SV_blank>not<S2SV_blank>bind<S2SV_blank>%ld:<S2SV_blank>Integer<S2SV_blank>too<S2SV_blank>large<S2SV_blank>for<S2SV_blank>MYSQL_TYPE_LONG\" , tmp ) ; imp_sth -> fbind [ idx ] . numeric_val . lval = tmp ; buffer = ( void * ) & ( imp_sth -> fbind [ idx ] . numeric_val . lval ) ; if ( DBIc_TRACE_LEVEL ( imp_xxh ) >= 2 ) PerlIO_printf ( DBIc_LOGPIO ( imp_xxh ) , \"<S2SV_blank><S2SV_blank><S2SV_blank>SCALAR<S2SV_blank>type<S2SV_blank>%d<S2SV_blank>->%\" PRId32 \"<-<S2SV_blank>IS<S2SV_blank>A<S2SV_blank>INT<S2SV_blank>NUMBER\\\\n\" , ( int ) sql_type , * ( int32_t * ) buffer ) ; break ; case MYSQL_TYPE_DOUBLE : if ( ! SvNOK ( imp_sth -> params [ idx ] . value ) && DBIc_TRACE_LEVEL ( imp_xxh ) >= 2 ) PerlIO_printf ( DBIc_LOGPIO ( imp_xxh ) , \"\\\\t\\\\tTRY<S2SV_blank>TO<S2SV_blank>BIND<S2SV_blank>A<S2SV_blank>FLOAT<S2SV_blank>NUMBER\\\\n\" ) ; buffer_length = sizeof imp_sth -> fbind [ idx ] . numeric_val . dval ; imp_sth -> fbind [ idx ] . numeric_val . dval = SvNV ( imp_sth -> params [ idx ] . value ) ; buffer = ( char * ) & ( imp_sth -> fbind [ idx ] . numeric_val . dval ) ; if ( DBIc_TRACE_LEVEL ( imp_xxh ) >= 2 ) PerlIO_printf ( DBIc_LOGPIO ( imp_xxh ) , \"<S2SV_blank><S2SV_blank><S2SV_blank>SCALAR<S2SV_blank>type<S2SV_blank>%d<S2SV_blank>->%f<-<S2SV_blank>IS<S2SV_blank>A<S2SV_blank>FLOAT<S2SV_blank>NUMBER\\\\n\" , ( int ) sql_type , ( double ) ( * buffer ) ) ; break ; case MYSQL_TYPE_BLOB : if ( DBIc_TRACE_LEVEL ( imp_xxh ) >= 2 ) PerlIO_printf ( DBIc_LOGPIO ( imp_xxh ) , \"<S2SV_blank><S2SV_blank><S2SV_blank>SCALAR<S2SV_blank>type<S2SV_blank>BLOB\\\\n\" ) ; break ; case MYSQL_TYPE_STRING : if ( DBIc_TRACE_LEVEL ( imp_xxh ) >= 2 ) PerlIO_printf ( DBIc_LOGPIO ( imp_xxh ) , \"<S2SV_blank><S2SV_blank><S2SV_blank>SCALAR<S2SV_blank>type<S2SV_blank>STRING<S2SV_blank>%d,<S2SV_blank>buffertype=%d\\\\n\" , ( int ) sql_type , buffer_type ) ; break ; default : croak ( \"Bug<S2SV_blank>in<S2SV_blank>DBD::Mysql<S2SV_blank>file<S2SV_blank>dbdimp.c#dbd_bind_ph:<S2SV_blank>do<S2SV_blank>not<S2SV_blank>know<S2SV_blank>how<S2SV_blank>to<S2SV_blank>handle<S2SV_blank>unknown<S2SV_blank>buffer<S2SV_blank>type.\" ) ; } if ( buffer_type == MYSQL_TYPE_STRING || buffer_type == MYSQL_TYPE_BLOB ) { buffer = SvPV ( imp_sth -> params [ idx ] . value , slen ) ; buffer_length = slen ; if ( DBIc_TRACE_LEVEL ( imp_xxh ) >= 2 ) PerlIO_printf ( DBIc_LOGPIO ( imp_xxh ) , \"<S2SV_blank>SCALAR<S2SV_blank>type<S2SV_blank>%d<S2SV_blank>->length<S2SV_blank>%d<-<S2SV_blank>IS<S2SV_blank>A<S2SV_blank>STRING<S2SV_blank>or<S2SV_blank>BLOB\\\\n\" , ( int ) sql_type , buffer_length ) ; } } else { buffer = NULL ; if ( DBIc_TRACE_LEVEL ( imp_xxh ) >= 2 ) PerlIO_printf ( DBIc_LOGPIO ( imp_xxh ) , \"<S2SV_blank><S2SV_blank><S2SV_blank>SCALAR<S2SV_blank>NULL<S2SV_blank>VALUE:<S2SV_blank>buffer<S2SV_blank>type<S2SV_blank>is:<S2SV_blank>%d\\\\n\" , buffer_type ) ; } if ( imp_sth -> bind [ idx ] . buffer_type != buffer_type ) { if ( DBIc_TRACE_LEVEL ( imp_xxh ) >= 2 ) PerlIO_printf ( DBIc_LOGPIO ( imp_xxh ) , \"<S2SV_blank><S2SV_blank><S2SV_blank>FORCE<S2SV_blank>REBIND:<S2SV_blank>buffer<S2SV_blank>type<S2SV_blank>changed<S2SV_blank>from<S2SV_blank>%d<S2SV_blank>to<S2SV_blank>%d,<S2SV_blank>sql-type=%d\\\\n\" , ( int ) imp_sth -> bind [ idx ] . buffer_type , buffer_type , ( int ) sql_type ) ; imp_sth -> has_been_bound = 0 ; } if ( imp_sth -> has_been_bound == 0 ) { imp_sth -> bind [ idx ] . buffer_type = buffer_type ; imp_sth -> bind [ idx ] . buffer = buffer ; imp_sth -> bind [ idx ] . buffer_length = buffer_length ; } else { imp_sth -> stmt -> params [ idx ] . buffer = buffer ; imp_sth -> stmt -> params [ idx ] . buffer_length = buffer_length ; } imp_sth -> fbind [ idx ] . length = buffer_length ; imp_sth -> fbind [ idx ] . is_null = buffer_is_null ; } # endif return rc ; }\n","target":"<S2SV_ModStart> 1 ; char * err_msg <S2SV_ModEnd> ; D_imp_xxh ( <S2SV_ModStart> ) ) { err_msg = SvPVX ( sv_2mortal ( newSVpvf ( <S2SV_ModEnd> \"Binding<S2SV_blank>non-numeric<S2SV_blank>field<S2SV_blank>%d,<S2SV_blank>value<S2SV_blank>%s<S2SV_blank>as<S2SV_blank>a<S2SV_blank>numeric!\" , param_num <S2SV_ModStart> value , 0 ) )\n","project_and_commit_id":"perl5-dbi@DBD-mysql/7c164a0c86cec6ee95df1d141e67b0e85dfdefd2","cve_id":"CVE-2016-1246","original_address":"https://github.com/perl5-dbi/DBD-mysql/commit/7c164a0c86cec6ee95df1d141e67b0e85dfdefd2","time":"2016-10-05T16:59Z"},
	{"Unnamed: 0":2779,"cwe_id":"CWE-190","source":"CWE-190 SQLITE_PRIVATE int sqlite3VdbeSorterWrite ( const VdbeCursor * pCsr , Mem * pVal ) { VdbeSorter * pSorter ; int rc = SQLITE_OK ; SorterRecord * pNew ; int bFlush ; int nReq ; int nPMA ; int t ; assert ( pCsr -> eCurType == CURTYPE_SORTER ) ; pSorter = pCsr -> uc . pSorter ; getVarint32 ( ( const u8 * ) & pVal -> z [ 1 ] , t ) ; if ( t > 0 && t < 10 && t != 7 ) { pSorter -> typeMask &= SORTER_TYPE_INTEGER ; } else if ( t > 10 && ( t & 0x01 ) ) { pSorter -> typeMask &= SORTER_TYPE_TEXT ; } else { pSorter -> typeMask = 0 ; } assert ( pSorter ) ; nReq = pVal -> n + sizeof ( SorterRecord ) ; nPMA = pVal -> n + sqlite3VarintLen ( pVal -> n ) ; if ( pSorter -> mxPmaSize ) { if ( pSorter -> list . aMemory ) { bFlush = pSorter -> iMemory && ( pSorter -> iMemory + nReq ) > pSorter -> mxPmaSize ; } else { bFlush = ( ( pSorter -> list . szPMA > pSorter -> mxPmaSize ) || ( pSorter -> list . szPMA > pSorter -> mnPmaSize && sqlite3HeapNearlyFull ( ) ) ) ; } if ( bFlush ) { rc = vdbeSorterFlushPMA ( pSorter ) ; pSorter -> list . szPMA = 0 ; pSorter -> iMemory = 0 ; assert ( rc != SQLITE_OK || pSorter -> list . pList == 0 ) ; } } pSorter -> list . szPMA += nPMA ; if ( nPMA > pSorter -> mxKeysize ) { pSorter -> mxKeysize = nPMA ; } if ( pSorter -> list . aMemory ) { int nMin = pSorter -> iMemory + nReq ; if ( nMin > pSorter -> nMemory ) { u8 * aNew ; int iListOff = ( u8 * ) pSorter -> list . pList - pSorter -> list . aMemory ; <S2SV_StartBug> int nNew = pSorter -> nMemory * 2 ; <S2SV_EndBug> while ( nNew < nMin ) nNew = nNew * 2 ; if ( nNew > pSorter -> mxPmaSize ) nNew = pSorter -> mxPmaSize ; if ( nNew < nMin ) nNew = nMin ; aNew = sqlite3Realloc ( pSorter -> list . aMemory , nNew ) ; if ( ! aNew ) return SQLITE_NOMEM_BKPT ; pSorter -> list . pList = ( SorterRecord * ) & aNew [ iListOff ] ; pSorter -> list . aMemory = aNew ; pSorter -> nMemory = nNew ; } pNew = ( SorterRecord * ) & pSorter -> list . aMemory [ pSorter -> iMemory ] ; pSorter -> iMemory += ROUND8 ( nReq ) ; if ( pSorter -> list . pList ) { pNew -> u . iNext = ( int ) ( ( u8 * ) ( pSorter -> list . pList ) - pSorter -> list . aMemory ) ; } } else { pNew = ( SorterRecord * ) sqlite3Malloc ( nReq ) ; if ( pNew == 0 ) { return SQLITE_NOMEM_BKPT ; } pNew -> u . pNext = pSorter -> list . pList ; } memcpy ( SRVAL ( pNew ) , pVal -> z , pVal -> n ) ; pNew -> nVal = pVal -> n ; pSorter -> list . pList = pNew ; return rc ; }\n","target":"<S2SV_ModStart> . aMemory ; sqlite3_int64 nNew = 2 * ( sqlite3_int64 ) <S2SV_ModEnd> pSorter -> nMemory <S2SV_ModStart> pSorter -> nMemory <S2SV_ModEnd> ; while (\n","project_and_commit_id":"chromium@chromium/517ac71c9ee27f856f9becde8abea7d1604af9d4","cve_id":"CVE-2019-5827","original_address":"https://github.com/chromium/chromium/commit/517ac71c9ee27f856f9becde8abea7d1604af9d4","time":"2019-06-27T17:15Z"},
	{"Unnamed: 0":6021,"cwe_id":"CWE-119","source":"CWE-119 static gboolean cosine_read ( wtap * wth , int * err , gchar * * err_info , gint64 * data_offset ) { <S2SV_StartBug> gint64 offset ; <S2SV_EndBug> int pkt_len ; char line [ COSINE_LINE_LENGTH ] ; offset = cosine_seek_next_packet ( wth , err , err_info , line ) ; if ( offset < 0 ) return FALSE ; * data_offset = offset ; <S2SV_StartBug> pkt_len = parse_cosine_rec_hdr ( & wth -> phdr , line , err , err_info ) ; <S2SV_EndBug> if ( pkt_len == - 1 ) return FALSE ; <S2SV_StartBug> return parse_cosine_hex_dump ( wth -> fh , & wth -> phdr , pkt_len , <S2SV_EndBug> <S2SV_StartBug> wth -> frame_buffer , err , err_info ) ; <S2SV_EndBug> }\n","target":"<S2SV_ModStart> { gint64 offset <S2SV_ModEnd> ; char line <S2SV_ModStart> = offset ; return parse_cosine_packet <S2SV_ModEnd> ( wth -> <S2SV_ModStart> -> phdr , <S2SV_ModEnd> wth -> frame_buffer <S2SV_ModStart> wth -> frame_buffer , line\n","project_and_commit_id":"wireshark@wireshark/f5ec0afb766f19519ea9623152cca3bbe2229500","cve_id":"CVE-2016-5356","original_address":"https://github.com/wireshark/wireshark/commit/f5ec0afb766f19519ea9623152cca3bbe2229500","time":"2016-08-07T16:59Z"},
	{"Unnamed: 0":2876,"cwe_id":"CWE-74","source":"CWE-74 int pop_open_connection ( struct PopAccountData * adata ) { char buf [ 1024 ] ; int rc = pop_connect ( adata ) ; if ( rc < 0 ) return rc ; rc = pop_capabilities ( adata , 0 ) ; if ( rc == - 1 ) goto err_conn ; if ( rc == - 2 ) return - 2 ; # ifdef USE_SSL if ( ! adata -> conn -> ssf && ( adata -> cmd_stls || C_SslForceTls ) ) { if ( C_SslForceTls ) adata -> use_stls = 2 ; if ( adata -> use_stls == 0 ) { enum QuadOption ans = query_quadoption ( C_SslStarttls , _ ( \"Secure<S2SV_blank>connection<S2SV_blank>with<S2SV_blank>TLS?\" ) ) ; if ( ans == MUTT_ABORT ) return - 2 ; adata -> use_stls = 1 ; if ( ans == MUTT_YES ) adata -> use_stls = 2 ; } if ( adata -> use_stls == 2 ) { mutt_str_strfcpy ( buf , \"STLS\\\\r\\\\n\" , sizeof ( buf ) ) ; rc = pop_query ( adata , buf , sizeof ( buf ) ) ; <S2SV_StartBug> if ( rc == - 1 ) <S2SV_EndBug> goto err_conn ; if ( rc != 0 ) { mutt_error ( \"%s\" , adata -> err_msg ) ; } else if ( mutt_ssl_starttls ( adata -> conn ) ) { mutt_error ( _ ( \"Could<S2SV_blank>not<S2SV_blank>negotiate<S2SV_blank>TLS<S2SV_blank>connection\" ) ) ; return - 2 ; } else { rc = pop_capabilities ( adata , 1 ) ; if ( rc == - 1 ) goto err_conn ; if ( rc == - 2 ) return - 2 ; } } } if ( C_SslForceTls && ! adata -> conn -> ssf ) { mutt_error ( _ ( \"Encrypted<S2SV_blank>connection<S2SV_blank>unavailable\" ) ) ; return - 2 ; } # endif rc = pop_authenticate ( adata ) ; if ( rc == - 1 ) goto err_conn ; if ( rc == - 3 ) mutt_clear_error ( ) ; if ( rc != 0 ) return rc ; rc = pop_capabilities ( adata , 2 ) ; if ( rc == - 1 ) goto err_conn ; if ( rc == - 2 ) return - 2 ; mutt_str_strfcpy ( buf , \"STAT\\\\r\\\\n\" , sizeof ( buf ) ) ; rc = pop_query ( adata , buf , sizeof ( buf ) ) ; if ( rc == - 1 ) goto err_conn ; if ( rc == - 2 ) { mutt_error ( \"%s\" , adata -> err_msg ) ; return rc ; } unsigned int n = 0 , size = 0 ; sscanf ( buf , \"+OK<S2SV_blank>%u<S2SV_blank>%u\" , & n , & size ) ; adata -> size = size ; return 0 ; err_conn : adata -> status = POP_DISCONNECTED ; mutt_error ( _ ( \"Server<S2SV_blank>closed<S2SV_blank>connection\" ) ) ; return - 1 ; }\n","target":"<S2SV_ModStart> ) ) ; mutt_socket_empty ( adata -> conn ) ;\n","project_and_commit_id":"neomutt@neomutt/fb013ec666759cb8a9e294347c7b4c1f597639cc","cve_id":"CVE-2020-14954","original_address":"https://github.com/neomutt/neomutt/commit/fb013ec666759cb8a9e294347c7b4c1f597639cc","time":"2020-06-21T17:15Z"},
	{"Unnamed: 0":1282,"cwe_id":"CWE-787","source":"CWE-787 int mp4client_main ( int argc , char * * argv ) { char c ; const char * str ; int ret_val = 0 ; u32 i , times [ 100 ] , nb_times , dump_mode ; u32 simulation_time_in_ms = 0 ; u32 initial_service_id = 0 ; Bool auto_exit = GF_FALSE ; Bool logs_set = GF_FALSE ; Bool start_fs = GF_FALSE ; Bool use_rtix = GF_FALSE ; Bool pause_at_first = GF_FALSE ; Bool no_cfg_save = GF_FALSE ; Bool is_cfg_only = GF_FALSE ; Double play_from = 0 ; # ifdef GPAC_MEMORY_TRACKING GF_MemTrackerType mem_track = GF_MemTrackerNone ; # endif Double fps = GF_IMPORT_DEFAULT_FPS ; Bool fill_ar , visible , do_uncache , has_command ; char * url_arg , * out_arg , * the_cfg , * rti_file , * views , * mosaic ; FILE * logfile = NULL ; Float scale = 1 ; # ifndef WIN32 dlopen ( NULL , RTLD_NOW | RTLD_GLOBAL ) ; # endif strcpy ( the_url , \".\" ) ; memset ( & user , 0 , sizeof ( GF_User ) ) ; dump_mode = DUMP_NONE ; fill_ar = visible = do_uncache = has_command = GF_FALSE ; url_arg = out_arg = the_cfg = rti_file = views = mosaic = NULL ; nb_times = 0 ; times [ 0 ] = 0 ; for ( i = 1 ; i < ( u32 ) argc ; i ++ ) { char * arg = argv [ i ] ; if ( ! strcmp ( arg , \"-c\" ) || ! strcmp ( arg , \"-cfg\" ) ) { the_cfg = argv [ i + 1 ] ; i ++ ; } else if ( ! strcmp ( arg , \"-mem-track\" ) || ! strcmp ( arg , \"-mem-track-stack\" ) ) { # ifdef GPAC_MEMORY_TRACKING mem_track = ! strcmp ( arg , \"-mem-track-stack\" ) ? GF_MemTrackerBackTrace : GF_MemTrackerSimple ; # else fprintf ( stderr , \"WARNING<S2SV_blank>-<S2SV_blank>GPAC<S2SV_blank>not<S2SV_blank>compiled<S2SV_blank>with<S2SV_blank>Memory<S2SV_blank>Tracker<S2SV_blank>-<S2SV_blank>ignoring<S2SV_blank>\\\\\"%s\\\\\"\\\\n\" , arg ) ; # endif } else if ( ! strcmp ( arg , \"-gui\" ) ) { gui_mode = 1 ; } else if ( ! strcmp ( arg , \"-guid\" ) ) { gui_mode = 2 ; } else if ( ! strcmp ( arg , \"-h\" ) || ! strcmp ( arg , \"-help\" ) ) { PrintUsage ( ) ; return 0 ; } } # ifdef GPAC_MEMORY_TRACKING gf_sys_init ( mem_track ) ; # else gf_sys_init ( GF_MemTrackerNone ) ; # endif gf_sys_set_args ( argc , ( const char * * ) argv ) ; cfg_file = gf_cfg_init ( the_cfg , NULL ) ; if ( ! cfg_file ) { fprintf ( stderr , \"Error:<S2SV_blank>Configuration<S2SV_blank>File<S2SV_blank>not<S2SV_blank>found\\\\n\" ) ; return 1 ; } if ( gf_log_set_tools_levels ( gf_cfg_get_key ( cfg_file , \"General\" , \"Logs\" ) ) != GF_OK ) { return 1 ; } if ( gf_cfg_get_key ( cfg_file , \"General\" , \"Logs\" ) != NULL ) { logs_set = GF_TRUE ; } if ( ! gui_mode ) { str = gf_cfg_get_key ( cfg_file , \"General\" , \"ForceGUI\" ) ; if ( str && ! strcmp ( str , \"yes\" ) ) gui_mode = 1 ; } for ( i = 1 ; i < ( u32 ) argc ; i ++ ) { char * arg = argv [ i ] ; if ( ! strcmp ( arg , \"-rti\" ) ) { rti_file = argv [ i + 1 ] ; i ++ ; } else if ( ! strcmp ( arg , \"-rtix\" ) ) { rti_file = argv [ i + 1 ] ; i ++ ; use_rtix = GF_TRUE ; } else if ( ! stricmp ( arg , \"-size\" ) ) { if ( sscanf ( argv [ i + 1 ] , \"%dx%d\" , & forced_width , & forced_height ) != 2 ) { forced_width = forced_height = 0 ; } i ++ ; } else if ( ! strcmp ( arg , \"-quiet\" ) ) { be_quiet = 1 ; } else if ( ! strcmp ( arg , \"-strict-error\" ) ) { gf_log_set_strict_error ( 1 ) ; } else if ( ! strcmp ( arg , \"-log-file\" ) || ! strcmp ( arg , \"-lf\" ) ) { logfile = gf_fopen ( argv [ i + 1 ] , \"wt\" ) ; gf_log_set_callback ( logfile , on_gpac_log ) ; i ++ ; } else if ( ! strcmp ( arg , \"-logs\" ) ) { if ( gf_log_set_tools_levels ( argv [ i + 1 ] ) != GF_OK ) { return 1 ; } logs_set = GF_TRUE ; i ++ ; } else if ( ! strcmp ( arg , \"-log-clock\" ) || ! strcmp ( arg , \"-lc\" ) ) { log_time_start = 1 ; } else if ( ! strcmp ( arg , \"-log-utc\" ) || ! strcmp ( arg , \"-lu\" ) ) { log_utc_time = 1 ; } # if defined ( __DARWIN__ ) || defined ( __APPLE__ ) else if ( ! strcmp ( arg , \"-thread\" ) ) threading_flags = 0 ; # else else if ( ! strcmp ( arg , \"-no-thread\" ) ) threading_flags = GF_TERM_NO_DECODER_THREAD | GF_TERM_NO_COMPOSITOR_THREAD | GF_TERM_WINDOW_NO_THREAD ; # endif else if ( ! strcmp ( arg , \"-no-cthread\" ) || ! strcmp ( arg , \"-no-compositor-thread\" ) ) threading_flags |= GF_TERM_NO_COMPOSITOR_THREAD ; else if ( ! strcmp ( arg , \"-no-audio\" ) ) no_audio = 1 ; else if ( ! strcmp ( arg , \"-no-regulation\" ) ) no_regulation = 1 ; else if ( ! strcmp ( arg , \"-fs\" ) ) start_fs = 1 ; else if ( ! strcmp ( arg , \"-opt\" ) ) { set_cfg_option ( argv [ i + 1 ] ) ; i ++ ; } else if ( ! strcmp ( arg , \"-conf\" ) ) { set_cfg_option ( argv [ i + 1 ] ) ; is_cfg_only = GF_TRUE ; i ++ ; } else if ( ! strcmp ( arg , \"-ifce\" ) ) { gf_cfg_set_key ( cfg_file , \"Network\" , \"DefaultMCastInterface\" , argv [ i + 1 ] ) ; i ++ ; } else if ( ! stricmp ( arg , \"-help\" ) ) { PrintUsage ( ) ; return 1 ; } else if ( ! stricmp ( arg , \"-noprog\" ) ) { no_prog = 1 ; gf_set_progress_callback ( NULL , progress_quiet ) ; } else if ( ! stricmp ( arg , \"-no-save\" ) || ! stricmp ( arg , \"--no-save\" ) ) { no_cfg_save = 1 ; } else if ( ! stricmp ( arg , \"-ntp-shift\" ) ) { s32 shift = atoi ( argv [ i + 1 ] ) ; i ++ ; gf_net_set_ntp_shift ( shift ) ; } else if ( ! stricmp ( arg , \"-run-for\" ) ) { simulation_time_in_ms = atoi ( argv [ i + 1 ] ) * 1000 ; if ( ! simulation_time_in_ms ) simulation_time_in_ms = 1 ; i ++ ; } else if ( ! strcmp ( arg , \"-out\" ) ) { out_arg = argv [ i + 1 ] ; i ++ ; } else if ( ! stricmp ( arg , \"-fps\" ) ) { fps = atof ( argv [ i + 1 ] ) ; i ++ ; } else if ( ! strcmp ( arg , \"-avi\" ) || ! strcmp ( arg , \"-sha\" ) ) { dump_mode &= 0xFFFF0000 ; if ( ! strcmp ( arg , \"-sha\" ) ) dump_mode |= DUMP_SHA1 ; else dump_mode |= DUMP_AVI ; if ( ( url_arg || ( i + 2 < ( u32 ) argc ) ) && get_time_list ( argv [ i + 1 ] , times , & nb_times ) ) { if ( ! strcmp ( arg , \"-avi\" ) && ( nb_times != 2 ) ) { fprintf ( stderr , \"Only<S2SV_blank>one<S2SV_blank>time<S2SV_blank>arg<S2SV_blank>found<S2SV_blank>for<S2SV_blank>-avi<S2SV_blank>-<S2SV_blank>check<S2SV_blank>usage\\\\n\" ) ; return 1 ; } i ++ ; } } else if ( ! strcmp ( arg , \"-rgbds\" ) ) { dump_mode |= DUMP_RGB_DEPTH_SHAPE ; } else if ( ! strcmp ( arg , \"-rgbd\" ) ) { dump_mode |= DUMP_RGB_DEPTH ; } else if ( ! strcmp ( arg , \"-depth\" ) ) { dump_mode |= DUMP_DEPTH_ONLY ; } else if ( ! strcmp ( arg , \"-bmp\" ) ) { dump_mode &= 0xFFFF0000 ; dump_mode |= DUMP_BMP ; if ( ( url_arg || ( i + 2 < ( u32 ) argc ) ) && get_time_list ( argv [ i + 1 ] , times , & nb_times ) ) i ++ ; } else if ( ! strcmp ( arg , \"-png\" ) ) { dump_mode &= 0xFFFF0000 ; dump_mode |= DUMP_PNG ; if ( ( url_arg || ( i + 2 < ( u32 ) argc ) ) && get_time_list ( argv [ i + 1 ] , times , & nb_times ) ) i ++ ; } else if ( ! strcmp ( arg , \"-raw\" ) ) { dump_mode &= 0xFFFF0000 ; dump_mode |= DUMP_RAW ; if ( ( url_arg || ( i + 2 < ( u32 ) argc ) ) && get_time_list ( argv [ i + 1 ] , times , & nb_times ) ) i ++ ; } else if ( ! stricmp ( arg , \"-scale\" ) ) { sscanf ( argv [ i + 1 ] , \"%f\" , & scale ) ; i ++ ; } else if ( ! strcmp ( arg , \"-c\" ) || ! strcmp ( arg , \"-cfg\" ) ) { i ++ ; } if ( ! gui_mode ) { if ( arg [ 0 ] != '-' ) { if ( url_arg ) { fprintf ( stderr , \"Several<S2SV_blank>input<S2SV_blank>URLs<S2SV_blank>provided<S2SV_blank>(\\\\\"%s\\\\\",<S2SV_blank>\\\\\"%s\\\\\").<S2SV_blank>Check<S2SV_blank>your<S2SV_blank>command-line.\\\\n\" , url_arg , arg ) ; return 1 ; } url_arg = arg ; } else if ( ! strcmp ( arg , \"-loop\" ) ) loop_at_end = 1 ; else if ( ! strcmp ( arg , \"-bench\" ) ) bench_mode = 1 ; else if ( ! strcmp ( arg , \"-vbench\" ) ) bench_mode = 2 ; else if ( ! strcmp ( arg , \"-sbench\" ) ) bench_mode = 3 ; else if ( ! strcmp ( arg , \"-no-addon\" ) ) enable_add_ons = GF_FALSE ; else if ( ! strcmp ( arg , \"-pause\" ) ) pause_at_first = 1 ; else if ( ! strcmp ( arg , \"-play-from\" ) ) { play_from = atof ( ( const char * ) argv [ i + 1 ] ) ; i ++ ; } else if ( ! strcmp ( arg , \"-speed\" ) ) { playback_speed = FLT2FIX ( atof ( ( const char * ) argv [ i + 1 ] ) ) ; if ( playback_speed <= 0 ) playback_speed = FIX_ONE ; i ++ ; } else if ( ! strcmp ( arg , \"-no-wnd\" ) ) user . init_flags |= GF_TERM_WINDOWLESS ; else if ( ! strcmp ( arg , \"-no-back\" ) ) user . init_flags |= GF_TERM_WINDOW_TRANSPARENT ; else if ( ! strcmp ( arg , \"-align\" ) ) { if ( argv [ i + 1 ] [ 0 ] == 'm' ) align_mode = 1 ; else if ( argv [ i + 1 ] [ 0 ] == 'b' ) align_mode = 2 ; align_mode <<= 8 ; if ( argv [ i + 1 ] [ 1 ] == 'm' ) align_mode |= 1 ; else if ( argv [ i + 1 ] [ 1 ] == 'r' ) align_mode |= 2 ; i ++ ; } else if ( ! strcmp ( arg , \"-fill\" ) ) { fill_ar = GF_TRUE ; } else if ( ! strcmp ( arg , \"-show\" ) ) { visible = 1 ; } else if ( ! strcmp ( arg , \"-uncache\" ) ) { do_uncache = GF_TRUE ; } else if ( ! strcmp ( arg , \"-exit\" ) ) auto_exit = GF_TRUE ; else if ( ! stricmp ( arg , \"-views\" ) ) { views = argv [ i + 1 ] ; i ++ ; } else if ( ! stricmp ( arg , \"-mosaic\" ) ) { mosaic = argv [ i + 1 ] ; i ++ ; } else if ( ! stricmp ( arg , \"-com\" ) ) { has_command = GF_TRUE ; i ++ ; } else if ( ! stricmp ( arg , \"-service\" ) ) { initial_service_id = atoi ( argv [ i + 1 ] ) ; i ++ ; } } } if ( is_cfg_only ) { gf_cfg_del ( cfg_file ) ; fprintf ( stderr , \"GPAC<S2SV_blank>Config<S2SV_blank>updated\\\\n\" ) ; return 0 ; } if ( do_uncache ) { const char * cache_dir = gf_cfg_get_key ( cfg_file , \"General\" , \"CacheDirectory\" ) ; do_flatten_cache ( cache_dir ) ; fprintf ( stderr , \"GPAC<S2SV_blank>Cache<S2SV_blank>dir<S2SV_blank>%s<S2SV_blank>flattened\\\\n\" , cache_dir ) ; gf_cfg_del ( cfg_file ) ; return 0 ; } if ( dump_mode && ! url_arg ) { FILE * test ; url_arg = ( char * ) gf_cfg_get_key ( cfg_file , \"General\" , \"StartupFile\" ) ; test = url_arg ? gf_fopen ( url_arg , \"rt\" ) : NULL ; if ( ! test ) url_arg = NULL ; else gf_fclose ( test ) ; if ( ! url_arg ) { fprintf ( stderr , \"Missing<S2SV_blank>argument<S2SV_blank>for<S2SV_blank>dump\\\\n\" ) ; PrintUsage ( ) ; if ( logfile ) gf_fclose ( logfile ) ; return 1 ; } } if ( ! gui_mode && ! url_arg && ( gf_cfg_get_key ( cfg_file , \"General\" , \"StartupFile\" ) != NULL ) ) { gui_mode = 1 ; } # ifdef WIN32 if ( gui_mode == 1 ) { const char * opt ; TCHAR buffer [ 1024 ] ; DWORD res = GetCurrentDirectory ( 1024 , buffer ) ; buffer [ res ] = 0 ; opt = gf_cfg_get_key ( cfg_file , \"General\" , \"ModulesDirectory\" ) ; if ( strstr ( opt , buffer ) ) { gui_mode = 1 ; } else { gui_mode = 2 ; } } # endif if ( gui_mode == 1 ) { hide_shell ( 1 ) ; } if ( gui_mode ) { no_prog = 1 ; gf_set_progress_callback ( NULL , progress_quiet ) ; } if ( ! url_arg && simulation_time_in_ms ) simulation_time_in_ms += gf_sys_clock ( ) ; # if defined ( __DARWIN__ ) || defined ( __APPLE__ ) carbon_init ( ) ; # endif if ( dump_mode ) rti_file = NULL ; if ( ! logs_set ) { gf_log_set_tool_level ( GF_LOG_ALL , GF_LOG_WARNING ) ; } if ( rti_file || logfile || log_utc_time || log_time_start ) gf_log_set_callback ( NULL , on_gpac_log ) ; if ( rti_file ) init_rti_logs ( rti_file , url_arg , use_rtix ) ; { GF_SystemRTInfo rti ; if ( gf_sys_get_rti ( 0 , & rti , 0 ) ) fprintf ( stderr , \"System<S2SV_blank>info:<S2SV_blank>%d<S2SV_blank>MB<S2SV_blank>RAM<S2SV_blank>-<S2SV_blank>%d<S2SV_blank>cores\\\\n\" , ( u32 ) ( rti . physical_memory / 1024 / 1024 ) , rti . nb_cores ) ; } if ( dump_mode ) { user . init_flags |= GF_TERM_NO_DECODER_THREAD | GF_TERM_NO_COMPOSITOR_THREAD | GF_TERM_NO_REGULATION ; if ( ! visible ) user . init_flags |= GF_TERM_INIT_HIDE ; gf_cfg_set_key ( cfg_file , \"Audio\" , \"DriverName\" , \"Raw<S2SV_blank>Audio<S2SV_blank>Output\" ) ; no_cfg_save = GF_TRUE ; } else { init_w = forced_width ; init_h = forced_height ; } user . modules = gf_modules_new ( NULL , cfg_file ) ; if ( user . modules ) i = gf_modules_get_count ( user . modules ) ; if ( ! i || ! user . modules ) { fprintf ( stderr , \"Error:<S2SV_blank>no<S2SV_blank>modules<S2SV_blank>found<S2SV_blank>-<S2SV_blank>exiting\\\\n\" ) ; if ( user . modules ) gf_modules_del ( user . modules ) ; gf_cfg_del ( cfg_file ) ; gf_sys_close ( ) ; if ( logfile ) gf_fclose ( logfile ) ; return 1 ; } fprintf ( stderr , \"Modules<S2SV_blank>Found<S2SV_blank>:<S2SV_blank>%d<S2SV_blank>\\\\n\" , i ) ; str = gf_cfg_get_key ( cfg_file , \"General\" , \"GPACVersion\" ) ; if ( ! str || strcmp ( str , GPAC_FULL_VERSION ) ) { gf_cfg_del_section ( cfg_file , \"PluginsCache\" ) ; gf_cfg_set_key ( cfg_file , \"General\" , \"GPACVersion\" , GPAC_FULL_VERSION ) ; } user . config = cfg_file ; user . EventProc = GPAC_EventProc ; user . opaque = user . modules ; if ( threading_flags ) user . init_flags |= threading_flags ; if ( no_audio ) user . init_flags |= GF_TERM_NO_AUDIO ; if ( no_regulation ) user . init_flags |= GF_TERM_NO_REGULATION ; if ( threading_flags & ( GF_TERM_NO_DECODER_THREAD | GF_TERM_NO_COMPOSITOR_THREAD ) ) term_step = GF_TRUE ; if ( dump_mode ) user . init_flags |= GF_TERM_USE_AUDIO_HW_CLOCK ; if ( bench_mode ) { gf_cfg_discard_changes ( user . config ) ; auto_exit = GF_TRUE ; gf_cfg_set_key ( user . config , \"Audio\" , \"DriverName\" , \"Raw<S2SV_blank>Audio<S2SV_blank>Output\" ) ; if ( bench_mode != 2 ) { gf_cfg_set_key ( user . config , \"Video\" , \"DriverName\" , \"Raw<S2SV_blank>Video<S2SV_blank>Output\" ) ; gf_cfg_set_key ( user . config , \"RAWVideo\" , \"RawOutput\" , \"null\" ) ; gf_cfg_set_key ( user . config , \"Compositor\" , \"OpenGLMode\" , \"disable\" ) ; } else { gf_cfg_set_key ( user . config , \"Video\" , \"DisableVSync\" , \"yes\" ) ; } } { char dim [ 50 ] ; sprintf ( dim , \"%d\" , forced_width ) ; gf_cfg_set_key ( user . config , \"Compositor\" , \"DefaultWidth\" , forced_width ? dim : NULL ) ; sprintf ( dim , \"%d\" , forced_height ) ; gf_cfg_set_key ( user . config , \"Compositor\" , \"DefaultHeight\" , forced_height ? dim : NULL ) ; } fprintf ( stderr , \"Loading<S2SV_blank>GPAC<S2SV_blank>Terminal\\\\n\" ) ; i = gf_sys_clock ( ) ; term = gf_term_new ( & user ) ; if ( ! term ) { fprintf ( stderr , \"\\\\nInit<S2SV_blank>error<S2SV_blank>-<S2SV_blank>check<S2SV_blank>you<S2SV_blank>have<S2SV_blank>at<S2SV_blank>least<S2SV_blank>one<S2SV_blank>video<S2SV_blank>out<S2SV_blank>and<S2SV_blank>one<S2SV_blank>rasterizer...\\\\nFound<S2SV_blank>modules:\\\\n\" ) ; list_modules ( user . modules ) ; gf_modules_del ( user . modules ) ; gf_cfg_discard_changes ( cfg_file ) ; gf_cfg_del ( cfg_file ) ; gf_sys_close ( ) ; if ( logfile ) gf_fclose ( logfile ) ; return 1 ; } fprintf ( stderr , \"Terminal<S2SV_blank>Loaded<S2SV_blank>in<S2SV_blank>%d<S2SV_blank>ms\\\\n\" , gf_sys_clock ( ) - i ) ; if ( bench_mode ) { display_rti = 2 ; gf_term_set_option ( term , GF_OPT_VIDEO_BENCH , ( bench_mode == 3 ) ? 2 : 1 ) ; if ( bench_mode == 1 ) bench_mode = 2 ; } if ( dump_mode ) { if ( fill_ar ) gf_term_set_option ( term , GF_OPT_ASPECT_RATIO , GF_ASPECT_RATIO_FILL_SCREEN ) ; } else { str = gf_cfg_get_key ( cfg_file , \"Video\" , \"DriverName\" ) ; if ( ! bench_mode && ! strcmp ( str , \"Raw<S2SV_blank>Video<S2SV_blank>Output\" ) ) fprintf ( stderr , \"WARNING:<S2SV_blank>using<S2SV_blank>raw<S2SV_blank>output<S2SV_blank>video<S2SV_blank>(memory<S2SV_blank>only)<S2SV_blank>-<S2SV_blank>no<S2SV_blank>display<S2SV_blank>used\\\\n\" ) ; str = gf_cfg_get_key ( cfg_file , \"Audio\" , \"DriverName\" ) ; if ( ! str || ! strcmp ( str , \"No<S2SV_blank>Audio<S2SV_blank>Output<S2SV_blank>Available\" ) ) fprintf ( stderr , \"WARNING:<S2SV_blank>no<S2SV_blank>audio<S2SV_blank>output<S2SV_blank>available<S2SV_blank>-<S2SV_blank>make<S2SV_blank>sure<S2SV_blank>no<S2SV_blank>other<S2SV_blank>program<S2SV_blank>is<S2SV_blank>locking<S2SV_blank>the<S2SV_blank>sound<S2SV_blank>card\\\\n\" ) ; str = gf_cfg_get_key ( cfg_file , \"General\" , \"NoMIMETypeFetch\" ) ; no_mime_check = ( str && ! stricmp ( str , \"yes\" ) ) ? 1 : 0 ; } str = gf_cfg_get_key ( cfg_file , \"HTTPProxy\" , \"Enabled\" ) ; if ( str && ! strcmp ( str , \"yes\" ) ) { str = gf_cfg_get_key ( cfg_file , \"HTTPProxy\" , \"Name\" ) ; if ( str ) fprintf ( stderr , \"HTTP<S2SV_blank>Proxy<S2SV_blank>%s<S2SV_blank>enabled\\\\n\" , str ) ; } if ( rti_file ) { str = gf_cfg_get_key ( cfg_file , \"General\" , \"RTIRefreshPeriod\" ) ; if ( str ) { rti_update_time_ms = atoi ( str ) ; } else { gf_cfg_set_key ( cfg_file , \"General\" , \"RTIRefreshPeriod\" , \"200\" ) ; } UpdateRTInfo ( \"At<S2SV_blank>GPAC<S2SV_blank>load<S2SV_blank>time\\\\n\" ) ; } Run = 1 ; if ( dump_mode ) { if ( ! nb_times ) { times [ 0 ] = 0 ; nb_times ++ ; } ret_val = dump_file ( url_arg , out_arg , dump_mode , fps , forced_width , forced_height , scale , times , nb_times ) ; Run = 0 ; } else if ( views ) { } else if ( ! gui_mode && url_arg ) { char * ext ; if ( strlen ( url_arg ) >= sizeof ( the_url ) ) { fprintf ( stderr , \"Input<S2SV_blank>url<S2SV_blank>%s<S2SV_blank>is<S2SV_blank>too<S2SV_blank>long,<S2SV_blank>truncating<S2SV_blank>to<S2SV_blank>%d<S2SV_blank>chars.\\\\n\" , url_arg , ( int ) ( sizeof ( the_url ) - 1 ) ) ; strncpy ( the_url , url_arg , sizeof ( the_url ) - 1 ) ; the_url [ sizeof ( the_url ) - 1 ] = 0 ; } else { strcpy ( the_url , url_arg ) ; } ext = strrchr ( the_url , '.' ) ; if ( ext && ( ! stricmp ( ext , \".m3u\" ) || ! stricmp ( ext , \".pls\" ) ) ) { GF_Err e = GF_OK ; fprintf ( stderr , \"Opening<S2SV_blank>Playlist<S2SV_blank>%s\\\\n\" , the_url ) ; strcpy ( pl_path , the_url ) ; if ( ! strncmp ( \"http:\" , the_url , 5 ) ) { GF_DownloadSession * sess = gf_dm_sess_new ( term -> downloader , the_url , GF_NETIO_SESSION_NOT_THREADED , NULL , NULL , & e ) ; if ( sess ) { e = gf_dm_sess_process ( sess ) ; if ( ! e ) { strncpy ( the_url , gf_dm_sess_get_cache_name ( sess ) , sizeof ( the_url ) - 1 ) ; <S2SV_StartBug> the_url [ sizeof ( the_cfg ) - 1 ] = 0 ; <S2SV_EndBug> } gf_dm_sess_del ( sess ) ; } } playlist = e ? NULL : gf_fopen ( the_url , \"rt\" ) ; readonly_playlist = 1 ; if ( playlist ) { request_next_playlist_item = GF_TRUE ; } else { if ( e ) fprintf ( stderr , \"Failed<S2SV_blank>to<S2SV_blank>open<S2SV_blank>playlist<S2SV_blank>%s:<S2SV_blank>%s\\\\n\" , the_url , gf_error_to_string ( e ) ) ; fprintf ( stderr , \"Hit<S2SV_blank>\\'h\\'<S2SV_blank>for<S2SV_blank>help\\\\n\\\\n\" ) ; } } else { fprintf ( stderr , \"Opening<S2SV_blank>URL<S2SV_blank>%s\\\\n\" , the_url ) ; if ( pause_at_first ) fprintf ( stderr , \"[Status:<S2SV_blank>Paused]\\\\n\" ) ; gf_term_connect_from_time ( term , the_url , ( u64 ) ( play_from * 1000 ) , pause_at_first ) ; } } else { fprintf ( stderr , \"Hit<S2SV_blank>\\'h\\'<S2SV_blank>for<S2SV_blank>help\\\\n\\\\n\" ) ; str = gf_cfg_get_key ( cfg_file , \"General\" , \"StartupFile\" ) ; if ( str ) { strncpy ( the_url , \"MP4Client<S2SV_blank>\" GPAC_FULL_VERSION , sizeof ( the_url ) - 1 ) ; the_url [ sizeof ( the_url ) - 1 ] = 0 ; gf_term_connect ( term , str ) ; startup_file = 1 ; is_connected = 1 ; } } if ( gui_mode == 2 ) gui_mode = 0 ; if ( start_fs ) gf_term_set_option ( term , GF_OPT_FULLSCREEN , 1 ) ; if ( views ) { char szTemp [ 4046 ] ; sprintf ( szTemp , \"views://%s\" , views ) ; gf_term_connect ( term , szTemp ) ; } if ( mosaic ) { char szTemp [ 4046 ] ; sprintf ( szTemp , \"mosaic://%s\" , mosaic ) ; gf_term_connect ( term , szTemp ) ; } if ( bench_mode ) { rti_update_time_ms = 500 ; bench_mode_start = gf_sys_clock ( ) ; } while ( Run ) { if ( ( gui_mode == 1 ) || ! gf_prompt_has_input ( ) ) { if ( reload ) { reload = 0 ; gf_term_disconnect ( term ) ; gf_term_connect ( term , startup_file ? gf_cfg_get_key ( cfg_file , \"General\" , \"StartupFile\" ) : the_url ) ; } if ( restart && gf_term_get_option ( term , GF_OPT_IS_OVER ) ) { restart = 0 ; gf_term_play_from_time ( term , 0 , 0 ) ; } if ( request_next_playlist_item ) { c = '\\\\n' ; request_next_playlist_item = 0 ; goto force_input ; } if ( has_command && is_connected ) { has_command = GF_FALSE ; for ( i = 0 ; i < ( u32 ) argc ; i ++ ) { if ( ! strcmp ( argv [ i ] , \"-com\" ) ) { gf_term_scene_update ( term , NULL , argv [ i + 1 ] ) ; i ++ ; } } } if ( initial_service_id && is_connected ) { GF_ObjectManager * root_od = gf_term_get_root_object ( term ) ; if ( root_od ) { gf_term_select_service ( term , root_od , initial_service_id ) ; initial_service_id = 0 ; } } if ( ! use_rtix || display_rti ) UpdateRTInfo ( NULL ) ; if ( term_step ) { gf_term_process_step ( term ) ; } else { gf_sleep ( rti_update_time_ms ) ; } if ( auto_exit && eos_seen && gf_term_get_option ( term , GF_OPT_IS_OVER ) ) { Run = GF_FALSE ; } if ( simulation_time_in_ms && ( ( gf_term_get_elapsed_time_in_ms ( term ) > simulation_time_in_ms ) || ( ! url_arg && gf_sys_clock ( ) > simulation_time_in_ms ) ) ) { Run = GF_FALSE ; } continue ; } c = gf_prompt_get_char ( ) ; force_input : switch ( c ) { case 'q' : { GF_Event evt ; memset ( & evt , 0 , sizeof ( GF_Event ) ) ; evt . type = GF_EVENT_QUIT ; gf_term_send_event ( term , & evt ) ; } break ; case 'X' : exit ( 0 ) ; break ; case 'Q' : break ; case 'o' : startup_file = 0 ; gf_term_disconnect ( term ) ; fprintf ( stderr , \"Enter<S2SV_blank>the<S2SV_blank>absolute<S2SV_blank>URL\\\\n\" ) ; if ( 1 > scanf ( \"%s\" , the_url ) ) { fprintf ( stderr , \"Cannot<S2SV_blank>read<S2SV_blank>absolute<S2SV_blank>URL,<S2SV_blank>aborting\\\\n\" ) ; break ; } if ( rti_file ) init_rti_logs ( rti_file , the_url , use_rtix ) ; gf_term_connect ( term , the_url ) ; break ; case 'O' : gf_term_disconnect ( term ) ; fprintf ( stderr , \"Enter<S2SV_blank>the<S2SV_blank>absolute<S2SV_blank>URL<S2SV_blank>to<S2SV_blank>the<S2SV_blank>playlist\\\\n\" ) ; if ( 1 > scanf ( \"%s\" , the_url ) ) { fprintf ( stderr , \"Cannot<S2SV_blank>read<S2SV_blank>the<S2SV_blank>absolute<S2SV_blank>URL,<S2SV_blank>aborting.\\\\n\" ) ; break ; } playlist = gf_fopen ( the_url , \"rt\" ) ; if ( playlist ) { if ( 1 > fscanf ( playlist , \"%s\" , the_url ) ) { fprintf ( stderr , \"Cannot<S2SV_blank>read<S2SV_blank>any<S2SV_blank>URL<S2SV_blank>from<S2SV_blank>playlist,<S2SV_blank>aborting.\\\\n\" ) ; gf_fclose ( playlist ) ; break ; } fprintf ( stderr , \"Opening<S2SV_blank>URL<S2SV_blank>%s\\\\n\" , the_url ) ; gf_term_connect ( term , the_url ) ; } break ; case '\\\\n' : case 'N' : if ( playlist ) { int res ; gf_term_disconnect ( term ) ; res = fscanf ( playlist , \"%s\" , the_url ) ; if ( ( res == EOF ) && loop_at_end ) { fseek ( playlist , 0 , SEEK_SET ) ; res = fscanf ( playlist , \"%s\" , the_url ) ; } if ( res == EOF ) { fprintf ( stderr , \"No<S2SV_blank>more<S2SV_blank>items<S2SV_blank>-<S2SV_blank>exiting\\\\n\" ) ; Run = 0 ; } else if ( the_url [ 0 ] == '#' ) { request_next_playlist_item = GF_TRUE ; } else { fprintf ( stderr , \"Opening<S2SV_blank>URL<S2SV_blank>%s\\\\n\" , the_url ) ; gf_term_connect_with_path ( term , the_url , pl_path ) ; } } break ; case 'P' : if ( playlist ) { u32 count ; gf_term_disconnect ( term ) ; if ( 1 > scanf ( \"%u\" , & count ) ) { fprintf ( stderr , \"Cannot<S2SV_blank>read<S2SV_blank>number,<S2SV_blank>aborting.\\\\n\" ) ; break ; } while ( count ) { if ( fscanf ( playlist , \"%s\" , the_url ) ) { fprintf ( stderr , \"Failed<S2SV_blank>to<S2SV_blank>read<S2SV_blank>line,<S2SV_blank>aborting\\\\n\" ) ; break ; } count -- ; } fprintf ( stderr , \"Opening<S2SV_blank>URL<S2SV_blank>%s\\\\n\" , the_url ) ; gf_term_connect ( term , the_url ) ; } break ; case 'r' : if ( is_connected ) reload = 1 ; break ; case 'D' : if ( is_connected ) gf_term_disconnect ( term ) ; break ; case 'p' : if ( is_connected ) { Bool is_pause = gf_term_get_option ( term , GF_OPT_PLAY_STATE ) ; fprintf ( stderr , \"[Status:<S2SV_blank>%s]\\\\n\" , is_pause ? \"Playing\" : \"Paused\" ) ; gf_term_set_option ( term , GF_OPT_PLAY_STATE , is_pause ? GF_STATE_PLAYING : GF_STATE_PAUSED ) ; } break ; case 's' : if ( is_connected ) { gf_term_set_option ( term , GF_OPT_PLAY_STATE , GF_STATE_STEP_PAUSE ) ; fprintf ( stderr , \"Step<S2SV_blank>time:<S2SV_blank>\" ) ; PrintTime ( gf_term_get_time_in_ms ( term ) ) ; fprintf ( stderr , \"\\\\n\" ) ; } break ; case 'z' : case 'T' : if ( ! CanSeek || ( Duration <= 2000 ) ) { fprintf ( stderr , \"scene<S2SV_blank>not<S2SV_blank>seekable\\\\n\" ) ; } else { Double res ; s32 seekTo ; fprintf ( stderr , \"Duration:<S2SV_blank>\" ) ; PrintTime ( Duration ) ; res = gf_term_get_time_in_ms ( term ) ; if ( c == 'z' ) { res *= 100 ; res /= ( s64 ) Duration ; fprintf ( stderr , \"<S2SV_blank>(current<S2SV_blank>%.2f<S2SV_blank>%%)\\\\nEnter<S2SV_blank>Seek<S2SV_blank>percentage:\\\\n\" , res ) ; if ( scanf ( \"%d\" , & seekTo ) == 1 ) { if ( seekTo > 100 ) seekTo = 100 ; res = ( Double ) ( s64 ) Duration ; res /= 100 ; res *= seekTo ; gf_term_play_from_time ( term , ( u64 ) ( s64 ) res , 0 ) ; } } else { u32 r , h , m , s ; fprintf ( stderr , \"<S2SV_blank>-<S2SV_blank>Current<S2SV_blank>Time:<S2SV_blank>\" ) ; PrintTime ( ( u64 ) res ) ; fprintf ( stderr , \"\\\\nEnter<S2SV_blank>seek<S2SV_blank>time<S2SV_blank>(Format:<S2SV_blank>s,<S2SV_blank>m:s<S2SV_blank>or<S2SV_blank>h:m:s):\\\\n\" ) ; h = m = s = 0 ; r = scanf ( \"%d:%d:%d\" , & h , & m , & s ) ; if ( r == 2 ) { s = m ; m = h ; h = 0 ; } else if ( r == 1 ) { s = h ; m = h = 0 ; } if ( r && ( r <= 3 ) ) { u64 time = h * 3600 + m * 60 + s ; gf_term_play_from_time ( term , time * 1000 , 0 ) ; } } } break ; case 't' : { if ( is_connected ) { fprintf ( stderr , \"Current<S2SV_blank>Time:<S2SV_blank>\" ) ; PrintTime ( gf_term_get_time_in_ms ( term ) ) ; fprintf ( stderr , \"<S2SV_blank>-<S2SV_blank>Duration:<S2SV_blank>\" ) ; PrintTime ( Duration ) ; fprintf ( stderr , \"\\\\n\" ) ; } } break ; case 'w' : if ( is_connected ) PrintWorldInfo ( term ) ; break ; case 'v' : if ( is_connected ) PrintODList ( term , NULL , 0 , 0 , \"Root\" ) ; break ; case 'i' : if ( is_connected ) { u32 ID ; fprintf ( stderr , \"Enter<S2SV_blank>OD<S2SV_blank>ID<S2SV_blank>(0<S2SV_blank>for<S2SV_blank>main<S2SV_blank>OD):<S2SV_blank>\" ) ; fflush ( stderr ) ; if ( scanf ( \"%ud\" , & ID ) == 1 ) { ViewOD ( term , ID , ( u32 ) - 1 , NULL ) ; } else { char str_url [ GF_MAX_PATH ] ; if ( scanf ( \"%s\" , str_url ) == 1 ) ViewOD ( term , 0 , ( u32 ) - 1 , str_url ) ; } } break ; case 'j' : if ( is_connected ) { u32 num ; do { fprintf ( stderr , \"Enter<S2SV_blank>OD<S2SV_blank>number<S2SV_blank>(0<S2SV_blank>for<S2SV_blank>main<S2SV_blank>OD):<S2SV_blank>\" ) ; fflush ( stderr ) ; } while ( 1 > scanf ( \"%ud\" , & num ) ) ; ViewOD ( term , ( u32 ) - 1 , num , NULL ) ; } break ; case 'b' : if ( is_connected ) ViewODs ( term , 1 ) ; break ; case 'm' : if ( is_connected ) ViewODs ( term , 0 ) ; break ; case 'l' : list_modules ( user . modules ) ; break ; case 'n' : if ( is_connected ) set_navigation ( ) ; break ; case 'x' : if ( is_connected ) gf_term_set_option ( term , GF_OPT_NAVIGATION_TYPE , 0 ) ; break ; case 'd' : if ( is_connected ) { GF_ObjectManager * odm = NULL ; char radname [ GF_MAX_PATH ] , * sExt ; GF_Err e ; u32 i , count , odid ; Bool xml_dump , std_out ; radname [ 0 ] = 0 ; do { fprintf ( stderr , \"Enter<S2SV_blank>Inline<S2SV_blank>OD<S2SV_blank>ID<S2SV_blank>if<S2SV_blank>any<S2SV_blank>or<S2SV_blank>0<S2SV_blank>:<S2SV_blank>\" ) ; fflush ( stderr ) ; } while ( 1 > scanf ( \"%ud\" , & odid ) ) ; if ( odid ) { GF_ObjectManager * root_odm = gf_term_get_root_object ( term ) ; if ( ! root_odm ) break ; count = gf_term_get_object_count ( term , root_odm ) ; for ( i = 0 ; i < count ; i ++ ) { GF_MediaInfo info ; odm = gf_term_get_object ( term , root_odm , i ) ; if ( gf_term_get_object_info ( term , odm , & info ) == GF_OK ) { if ( info . od -> objectDescriptorID == odid ) break ; } odm = NULL ; } } do { fprintf ( stderr , \"Enter<S2SV_blank>file<S2SV_blank>radical<S2SV_blank>name<S2SV_blank>(+\\\\\\'.x\\\\\\'<S2SV_blank>for<S2SV_blank>XML<S2SV_blank>dumping)<S2SV_blank>-<S2SV_blank>\\\\\"std\\\\\"<S2SV_blank>for<S2SV_blank>stderr:<S2SV_blank>\" ) ; fflush ( stderr ) ; } while ( 1 > scanf ( \"%s\" , radname ) ) ; sExt = strrchr ( radname , '.' ) ; xml_dump = 0 ; if ( sExt ) { if ( ! stricmp ( sExt , \".x\" ) ) xml_dump = 1 ; sExt [ 0 ] = 0 ; } std_out = strnicmp ( radname , \"std\" , 3 ) ? 0 : 1 ; e = gf_term_dump_scene ( term , std_out ? NULL : radname , NULL , xml_dump , 0 , odm ) ; fprintf ( stderr , \"Dump<S2SV_blank>done<S2SV_blank>(%s)\\\\n\" , gf_error_to_string ( e ) ) ; } break ; case 'c' : PrintGPACConfig ( ) ; break ; case '3' : { Bool use_3d = ! gf_term_get_option ( term , GF_OPT_USE_OPENGL ) ; if ( gf_term_set_option ( term , GF_OPT_USE_OPENGL , use_3d ) == GF_OK ) { fprintf ( stderr , \"Using<S2SV_blank>%s<S2SV_blank>for<S2SV_blank>2D<S2SV_blank>drawing\\\\n\" , use_3d ? \"OpenGL\" : \"2D<S2SV_blank>rasterizer\" ) ; } } break ; case 'k' : { Bool opt = gf_term_get_option ( term , GF_OPT_STRESS_MODE ) ; opt = ! opt ; fprintf ( stderr , \"Turning<S2SV_blank>stress<S2SV_blank>mode<S2SV_blank>%s\\\\n\" , opt ? \"on\" : \"off\" ) ; gf_term_set_option ( term , GF_OPT_STRESS_MODE , opt ) ; } break ; case '4' : gf_term_set_option ( term , GF_OPT_ASPECT_RATIO , GF_ASPECT_RATIO_4_3 ) ; break ; case '5' : gf_term_set_option ( term , GF_OPT_ASPECT_RATIO , GF_ASPECT_RATIO_16_9 ) ; break ; case '6' : gf_term_set_option ( term , GF_OPT_ASPECT_RATIO , GF_ASPECT_RATIO_FILL_SCREEN ) ; break ; case '7' : gf_term_set_option ( term , GF_OPT_ASPECT_RATIO , GF_ASPECT_RATIO_KEEP ) ; break ; case 'C' : switch ( gf_term_get_option ( term , GF_OPT_MEDIA_CACHE ) ) { case GF_MEDIA_CACHE_DISABLED : gf_term_set_option ( term , GF_OPT_MEDIA_CACHE , GF_MEDIA_CACHE_ENABLED ) ; break ; case GF_MEDIA_CACHE_ENABLED : gf_term_set_option ( term , GF_OPT_MEDIA_CACHE , GF_MEDIA_CACHE_DISABLED ) ; break ; case GF_MEDIA_CACHE_RUNNING : fprintf ( stderr , \"Streaming<S2SV_blank>Cache<S2SV_blank>is<S2SV_blank>running<S2SV_blank>-<S2SV_blank>please<S2SV_blank>stop<S2SV_blank>it<S2SV_blank>first\\\\n\" ) ; continue ; } switch ( gf_term_get_option ( term , GF_OPT_MEDIA_CACHE ) ) { case GF_MEDIA_CACHE_ENABLED : fprintf ( stderr , \"Streaming<S2SV_blank>Cache<S2SV_blank>Enabled\\\\n\" ) ; break ; case GF_MEDIA_CACHE_DISABLED : fprintf ( stderr , \"Streaming<S2SV_blank>Cache<S2SV_blank>Disabled\\\\n\" ) ; break ; case GF_MEDIA_CACHE_RUNNING : fprintf ( stderr , \"Streaming<S2SV_blank>Cache<S2SV_blank>Running\\\\n\" ) ; break ; } break ; case 'S' : case 'A' : if ( gf_term_get_option ( term , GF_OPT_MEDIA_CACHE ) == GF_MEDIA_CACHE_RUNNING ) { gf_term_set_option ( term , GF_OPT_MEDIA_CACHE , ( c == 'S' ) ? GF_MEDIA_CACHE_DISABLED : GF_MEDIA_CACHE_DISCARD ) ; fprintf ( stderr , \"Streaming<S2SV_blank>Cache<S2SV_blank>stopped\\\\n\" ) ; } else { fprintf ( stderr , \"Streaming<S2SV_blank>Cache<S2SV_blank>not<S2SV_blank>running\\\\n\" ) ; } break ; case 'R' : display_rti = ! display_rti ; ResetCaption ( ) ; break ; case 'F' : if ( display_rti ) display_rti = 0 ; else display_rti = 2 ; ResetCaption ( ) ; break ; case 'u' : { GF_Err e ; char szCom [ 8192 ] ; fprintf ( stderr , \"Enter<S2SV_blank>command<S2SV_blank>to<S2SV_blank>send:\\\\n\" ) ; fflush ( stdin ) ; szCom [ 0 ] = 0 ; if ( 1 > scanf ( \"%[^\\\\t\\\\n]\" , szCom ) ) { fprintf ( stderr , \"Cannot<S2SV_blank>read<S2SV_blank>command<S2SV_blank>to<S2SV_blank>send,<S2SV_blank>aborting.\\\\n\" ) ; break ; } e = gf_term_scene_update ( term , NULL , szCom ) ; if ( e ) fprintf ( stderr , \"Processing<S2SV_blank>command<S2SV_blank>failed:<S2SV_blank>%s\\\\n\" , gf_error_to_string ( e ) ) ; } break ; case 'e' : { GF_Err e ; char jsCode [ 8192 ] ; fprintf ( stderr , \"Enter<S2SV_blank>JavaScript<S2SV_blank>code<S2SV_blank>to<S2SV_blank>evaluate:\\\\n\" ) ; fflush ( stdin ) ; jsCode [ 0 ] = 0 ; if ( 1 > scanf ( \"%[^\\\\t\\\\n]\" , jsCode ) ) { fprintf ( stderr , \"Cannot<S2SV_blank>read<S2SV_blank>code<S2SV_blank>to<S2SV_blank>evaluate,<S2SV_blank>aborting.\\\\n\" ) ; break ; } e = gf_term_scene_update ( term , \"application/ecmascript\" , jsCode ) ; if ( e ) fprintf ( stderr , \"Processing<S2SV_blank>JS<S2SV_blank>code<S2SV_blank>failed:<S2SV_blank>%s\\\\n\" , gf_error_to_string ( e ) ) ; } break ; case 'L' : { char szLog [ 1024 ] , * cur_logs ; cur_logs = gf_log_get_tools_levels ( ) ; fprintf ( stderr , \"Enter<S2SV_blank>new<S2SV_blank>log<S2SV_blank>level<S2SV_blank>(current<S2SV_blank>tools<S2SV_blank>%s):\\\\n\" , cur_logs ) ; gf_free ( cur_logs ) ; if ( scanf ( \"%s\" , szLog ) < 1 ) { fprintf ( stderr , \"Cannot<S2SV_blank>read<S2SV_blank>new<S2SV_blank>log<S2SV_blank>level,<S2SV_blank>aborting.\\\\n\" ) ; break ; } gf_log_modify_tools_levels ( szLog ) ; } break ; case 'g' : { GF_SystemRTInfo rti ; gf_sys_get_rti ( rti_update_time_ms , & rti , 0 ) ; fprintf ( stderr , \"GPAC<S2SV_blank>allocated<S2SV_blank>memory<S2SV_blank>\" LLD \"\\\\n\" , rti . gpac_memory ) ; } break ; case 'M' : { u32 size ; do { fprintf ( stderr , \"Enter<S2SV_blank>new<S2SV_blank>video<S2SV_blank>cache<S2SV_blank>memory<S2SV_blank>in<S2SV_blank>kBytes<S2SV_blank>(current<S2SV_blank>%ud):\\\\n\" , gf_term_get_option ( term , GF_OPT_VIDEO_CACHE_SIZE ) ) ; } while ( 1 > scanf ( \"%ud\" , & size ) ) ; gf_term_set_option ( term , GF_OPT_VIDEO_CACHE_SIZE , size ) ; } break ; case 'H' : { u32 http_bitrate = gf_term_get_option ( term , GF_OPT_HTTP_MAX_RATE ) ; do { fprintf ( stderr , \"Enter<S2SV_blank>new<S2SV_blank>http<S2SV_blank>bitrate<S2SV_blank>in<S2SV_blank>bps<S2SV_blank>(0<S2SV_blank>for<S2SV_blank>none)<S2SV_blank>-<S2SV_blank>current<S2SV_blank>limit:<S2SV_blank>%d\\\\n\" , http_bitrate ) ; } while ( 1 > scanf ( \"%ud\" , & http_bitrate ) ) ; gf_term_set_option ( term , GF_OPT_HTTP_MAX_RATE , http_bitrate ) ; } break ; case 'E' : gf_term_set_option ( term , GF_OPT_RELOAD_CONFIG , 1 ) ; break ; case 'B' : switch_bench ( ! bench_mode ) ; break ; case 'Y' : { char szOpt [ 8192 ] ; fprintf ( stderr , \"Enter<S2SV_blank>option<S2SV_blank>to<S2SV_blank>set<S2SV_blank>(Section:Name=Value):\\\\n\" ) ; fflush ( stdin ) ; szOpt [ 0 ] = 0 ; if ( 1 > scanf ( \"%[^\\\\t\\\\n]\" , szOpt ) ) { fprintf ( stderr , \"Cannot<S2SV_blank>read<S2SV_blank>option\\\\n\" ) ; break ; } set_cfg_option ( szOpt ) ; } break ; case 'Z' : { char szFileName [ 100 ] ; u32 nb_pass , nb_views , offscreen_view = 0 ; GF_VideoSurface fb ; GF_Err e ; nb_pass = 1 ; nb_views = gf_term_get_option ( term , GF_OPT_NUM_STEREO_VIEWS ) ; if ( nb_views > 1 ) { fprintf ( stderr , \"Auto-stereo<S2SV_blank>mode<S2SV_blank>detected<S2SV_blank>-<S2SV_blank>type<S2SV_blank>number<S2SV_blank>of<S2SV_blank>view<S2SV_blank>to<S2SV_blank>dump<S2SV_blank>(0<S2SV_blank>is<S2SV_blank>main<S2SV_blank>output,<S2SV_blank>1<S2SV_blank>to<S2SV_blank>%d<S2SV_blank>offscreen<S2SV_blank>view,<S2SV_blank>%d<S2SV_blank>for<S2SV_blank>all<S2SV_blank>offscreen,<S2SV_blank>%d<S2SV_blank>for<S2SV_blank>all<S2SV_blank>offscreen<S2SV_blank>and<S2SV_blank>main)\\\\n\" , nb_views , nb_views + 1 , nb_views + 2 ) ; if ( scanf ( \"%d\" , & offscreen_view ) != 1 ) { offscreen_view = 0 ; } if ( offscreen_view == nb_views + 1 ) { offscreen_view = 1 ; nb_pass = nb_views ; } else if ( offscreen_view == nb_views + 2 ) { offscreen_view = 0 ; nb_pass = nb_views + 1 ; } } while ( nb_pass ) { nb_pass -- ; if ( offscreen_view ) { sprintf ( szFileName , \"view%d_dump.png\" , offscreen_view ) ; e = gf_term_get_offscreen_buffer ( term , & fb , offscreen_view - 1 , 0 ) ; } else { sprintf ( szFileName , \"gpac_video_dump_\" LLU \".png\" , gf_net_get_utc ( ) ) ; e = gf_term_get_screen_buffer ( term , & fb ) ; } offscreen_view ++ ; if ( e ) { fprintf ( stderr , \"Error<S2SV_blank>dumping<S2SV_blank>screen<S2SV_blank>buffer<S2SV_blank>%s\\\\n\" , gf_error_to_string ( e ) ) ; nb_pass = 0 ; } else { # ifndef GPAC_DISABLE_AV_PARSERS u32 dst_size = fb . width * fb . height * 4 ; char * dst = ( char * ) gf_malloc ( sizeof ( char ) * dst_size ) ; e = gf_img_png_enc ( fb . video_buffer , fb . width , fb . height , fb . pitch_y , fb . pixel_format , dst , & dst_size ) ; if ( e ) { fprintf ( stderr , \"Error<S2SV_blank>encoding<S2SV_blank>PNG<S2SV_blank>%s\\\\n\" , gf_error_to_string ( e ) ) ; nb_pass = 0 ; } else { FILE * png = gf_fopen ( szFileName , \"wb\" ) ; if ( ! png ) { fprintf ( stderr , \"Error<S2SV_blank>writing<S2SV_blank>file<S2SV_blank>%s\\\\n\" , szFileName ) ; nb_pass = 0 ; } else { gf_fwrite ( dst , dst_size , 1 , png ) ; gf_fclose ( png ) ; fprintf ( stderr , \"Dump<S2SV_blank>to<S2SV_blank>%s\\\\n\" , szFileName ) ; } } if ( dst ) gf_free ( dst ) ; gf_term_release_screen_buffer ( term , & fb ) ; # endif } } fprintf ( stderr , \"Done:<S2SV_blank>%s\\\\n\" , szFileName ) ; } break ; case 'G' : { GF_ObjectManager * root_od , * odm ; u32 index ; char szOpt [ 8192 ] ; fprintf ( stderr , \"Enter<S2SV_blank>0-based<S2SV_blank>index<S2SV_blank>of<S2SV_blank>object<S2SV_blank>to<S2SV_blank>select<S2SV_blank>or<S2SV_blank>service<S2SV_blank>ID:\\\\n\" ) ; fflush ( stdin ) ; szOpt [ 0 ] = 0 ; if ( 1 > scanf ( \"%[^\\\\t\\\\n]\" , szOpt ) ) { fprintf ( stderr , \"Cannot<S2SV_blank>read<S2SV_blank>OD<S2SV_blank>ID\\\\n\" ) ; break ; } index = atoi ( szOpt ) ; odm = NULL ; root_od = gf_term_get_root_object ( term ) ; if ( root_od ) { if ( gf_term_find_service ( term , root_od , index ) ) { gf_term_select_service ( term , root_od , index ) ; } else { fprintf ( stderr , \"Cannot<S2SV_blank>find<S2SV_blank>service<S2SV_blank>%d<S2SV_blank>-<S2SV_blank>trying<S2SV_blank>with<S2SV_blank>object<S2SV_blank>index\\\\n\" , index ) ; odm = gf_term_get_object ( term , root_od , index ) ; if ( odm ) { gf_term_select_object ( term , odm ) ; } else { fprintf ( stderr , \"Cannot<S2SV_blank>find<S2SV_blank>object<S2SV_blank>at<S2SV_blank>index<S2SV_blank>%d\\\\n\" , index ) ; } } } } break ; case 'h' : PrintHelp ( ) ; break ; default : break ; } } if ( bench_mode ) { PrintAVInfo ( GF_TRUE ) ; } if ( simulation_time_in_ms ) { gf_log_set_strict_error ( 0 ) ; } i = gf_sys_clock ( ) ; gf_term_disconnect ( term ) ; if ( rti_file ) UpdateRTInfo ( \"Disconnected\\\\n\" ) ; fprintf ( stderr , \"Deleting<S2SV_blank>terminal...<S2SV_blank>\" ) ; if ( playlist ) gf_fclose ( playlist ) ; # if defined ( __DARWIN__ ) || defined ( __APPLE__ ) carbon_uninit ( ) ; # endif gf_term_del ( term ) ; fprintf ( stderr , \"done<S2SV_blank>(in<S2SV_blank>%d<S2SV_blank>ms)<S2SV_blank>-<S2SV_blank>ran<S2SV_blank>for<S2SV_blank>%d<S2SV_blank>ms\\\\n\" , gf_sys_clock ( ) - i , gf_sys_clock ( ) ) ; fprintf ( stderr , \"GPAC<S2SV_blank>cleanup<S2SV_blank>...\\\\n\" ) ; gf_modules_del ( user . modules ) ; if ( no_cfg_save ) gf_cfg_discard_changes ( cfg_file ) ; gf_cfg_del ( cfg_file ) ; gf_sys_close ( ) ; if ( rti_logs ) gf_fclose ( rti_logs ) ; if ( logfile ) gf_fclose ( logfile ) ; if ( gui_mode ) { hide_shell ( 2 ) ; } # ifdef GPAC_MEMORY_TRACKING if ( mem_track && ( gf_memory_size ( ) || gf_file_handles_count ( ) ) ) { gf_log_set_tool_level ( GF_LOG_MEMORY , GF_LOG_INFO ) ; gf_memory_print ( ) ; return 2 ; } # endif return ret_val ; }\n","target":"<S2SV_ModStart> [ sizeof ( the_url <S2SV_ModEnd> ) - 1\n","project_and_commit_id":"gpac@gpac/1c449a34fe0b50aaffb881bfb9d7c5ab0bb18cdd","cve_id":"CVE-2018-20763","original_address":"https://github.com/gpac/gpac/commit/1c449a34fe0b50aaffb881bfb9d7c5ab0bb18cdd","time":"2019-02-06T23:29Z"},
	{"Unnamed: 0":5135,"cwe_id":"CWE-189","source":"CWE-189 Datum path_in ( PG_FUNCTION_ARGS ) { char * str = PG_GETARG_CSTRING ( 0 ) ; PATH * path ; int isopen ; char * s ; int npts ; <S2SV_StartBug> int size ; <S2SV_EndBug> int depth = 0 ; if ( ( npts = pair_count ( str , ',' ) ) <= 0 ) ereport ( ERROR , ( errcode ( ERRCODE_INVALID_TEXT_REPRESENTATION ) , errmsg ( \"invalid<S2SV_blank>input<S2SV_blank>syntax<S2SV_blank>for<S2SV_blank>type<S2SV_blank>path:<S2SV_blank>\\\\\"%s\\\\\"\" , str ) ) ) ; s = str ; while ( isspace ( ( unsigned char ) * s ) ) s ++ ; if ( ( * s == LDELIM ) && ( strrchr ( s , LDELIM ) == s ) ) { s ++ ; depth ++ ; } <S2SV_StartBug> size = offsetof ( PATH , p [ 0 ] ) + sizeof ( path -> p [ 0 ] ) * npts ; <S2SV_EndBug> path = ( PATH * ) palloc ( size ) ; SET_VARSIZE ( path , size ) ; path -> npts = npts ; if ( ( ! path_decode ( TRUE , npts , s , & isopen , & s , & ( path -> p [ 0 ] ) ) ) && ( ! ( ( depth == 0 ) && ( * s == '\\\\0' ) ) ) && ! ( ( depth >= 1 ) && ( * s == RDELIM ) ) ) ereport ( ERROR , ( errcode ( ERRCODE_INVALID_TEXT_REPRESENTATION ) , errmsg ( \"invalid<S2SV_blank>input<S2SV_blank>syntax<S2SV_blank>for<S2SV_blank>type<S2SV_blank>path:<S2SV_blank>\\\\\"%s\\\\\"\" , str ) ) ) ; path -> closed = ( ! isopen ) ; path -> dummy = 0 ; PG_RETURN_PATH_P ( path ) ; }\n","target":"<S2SV_ModStart> ; int size ; int base_size <S2SV_ModStart> ++ ; } base_size = sizeof ( path -> <S2SV_ModEnd> p [ 0 <S2SV_ModStart> 0 ] ) * npts ; size = offsetof ( PATH , <S2SV_ModEnd> p [ 0 <S2SV_ModStart> 0 ] ) + base_size ; if ( base_size / npts != sizeof ( path -> p [ 0 ] ) || size <= base_size ) ereport ( ERROR , ( errcode ( ERRCODE_PROGRAM_LIMIT_EXCEEDED ) , errmsg ( \"too<S2SV_blank>many<S2SV_blank>points<S2SV_blank>requested\" ) ) ) <S2SV_ModEnd> ; path =\n","project_and_commit_id":"postgres@postgres/31400a673325147e1205326008e32135a78b4d8a","cve_id":"CVE-2014-2669","original_address":"https://github.com/postgres/postgres/commit/31400a673325147e1205326008e32135a78b4d8a","time":"2014-03-31T14:58Z"},
	{"Unnamed: 0":2937,"cwe_id":"CWE-190","source":"CWE-190 static int decode_level3_header ( LHAFileHeader * * header , LHAInputStream * stream ) { unsigned int header_len ; if ( lha_decode_uint16 ( & RAW_DATA ( header , 0 ) ) != 4 ) { return 0 ; } if ( ! extend_raw_data ( header , stream , LEVEL_3_HEADER_LEN - RAW_DATA_LEN ( header ) ) ) { return 0 ; } header_len = lha_decode_uint32 ( & RAW_DATA ( header , 24 ) ) ; <S2SV_StartBug> if ( header_len > LEVEL_3_MAX_HEADER_LEN ) { <S2SV_EndBug> return 0 ; } if ( ! extend_raw_data ( header , stream , header_len - RAW_DATA_LEN ( header ) ) ) { return 0 ; } memcpy ( ( * header ) -> compress_method , & RAW_DATA ( header , 2 ) , 5 ) ; ( * header ) -> compress_method [ 5 ] = '\\\\0' ; ( * header ) -> compressed_length = lha_decode_uint32 ( & RAW_DATA ( header , 7 ) ) ; ( * header ) -> length = lha_decode_uint32 ( & RAW_DATA ( header , 11 ) ) ; ( * header ) -> timestamp = lha_decode_uint32 ( & RAW_DATA ( header , 15 ) ) ; ( * header ) -> crc = lha_decode_uint16 ( & RAW_DATA ( header , 21 ) ) ; ( * header ) -> os_type = RAW_DATA ( header , 23 ) ; if ( ! decode_extended_headers ( header , 28 ) ) { return 0 ; } return 1 ; }\n","target":"<S2SV_ModStart> header_len > LEVEL_3_MAX_HEADER_LEN || header_len < RAW_DATA_LEN ( header )\n","project_and_commit_id":"fragglet@lhasa/6fcdb8f1f538b9d63e63a5fa199c5514a15d4564","cve_id":"CVE-2016-2347","original_address":"https://github.com/fragglet/lhasa/commit/6fcdb8f1f538b9d63e63a5fa199c5514a15d4564","time":"2017-04-21T20:59Z"},
	{"Unnamed: 0":4768,"cwe_id":"CWE-264","source":"CWE-264 int copy_thread ( unsigned long clone_flags , unsigned long stack_start , unsigned long stk_sz , struct task_struct * p ) { struct thread_info * thread = task_thread_info ( p ) ; struct pt_regs * childregs = task_pt_regs ( p ) ; memset ( & thread -> cpu_context , 0 , sizeof ( struct cpu_context_save ) ) ; if ( likely ( ! ( p -> flags & PF_KTHREAD ) ) ) { * childregs = * current_pt_regs ( ) ; childregs -> ARM_r0 = 0 ; if ( stack_start ) childregs -> ARM_sp = stack_start ; } else { memset ( childregs , 0 , sizeof ( struct pt_regs ) ) ; thread -> cpu_context . r4 = stk_sz ; thread -> cpu_context . r5 = stack_start ; childregs -> ARM_cpsr = SVC_MODE ; } thread -> cpu_context . pc = ( unsigned long ) ret_from_fork ; thread -> cpu_context . sp = ( unsigned long ) childregs ; clear_ptrace_hw_breakpoint ( p ) ; if ( clone_flags & CLONE_SETTLS ) <S2SV_StartBug> thread -> tp_value = childregs -> ARM_r3 ; <S2SV_EndBug> thread_notify ( THREAD_NOTIFY_COPY , thread ) ; return 0 ; }\n","target":"<S2SV_ModStart> thread -> tp_value [ 0 ] <S2SV_ModStart> childregs -> ARM_r3 ; thread -> tp_value [ 1 ] = get_tpuser ( )\n","project_and_commit_id":"torvalds@linux/a4780adeefd042482f624f5e0d577bf9cdcbb760","cve_id":"CVE-2014-9870","original_address":"https://github.com/torvalds/linux/commit/a4780adeefd042482f624f5e0d577bf9cdcbb760","time":"2016-08-06T10:59Z"},
	{"Unnamed: 0":4075,"cwe_id":"CWE-119","source":"CWE-119 static vpx_codec_err_t vp8e_destroy ( vpx_codec_alg_priv_t * ctx ) { # if CONFIG_MULTI_RES_ENCODING if ( ctx -> oxcf . mr_total_resolutions > 0 && ( ctx -> oxcf . mr_encoder_id == ctx -> oxcf . mr_total_resolutions - 1 ) ) { LOWER_RES_FRAME_INFO * shared_mem_loc = ( LOWER_RES_FRAME_INFO * ) ctx -> oxcf . mr_low_res_mode_info ; free ( shared_mem_loc -> mb_info ) ; free ( ctx -> oxcf . mr_low_res_mode_info ) ; } # endif free ( ctx -> cx_data ) ; vp8_remove_compressor ( & ctx -> cpi ) ; <S2SV_StartBug> free ( ctx ) ; <S2SV_EndBug> return VPX_CODEC_OK ; }\n","target":"<S2SV_ModStart> cpi ) ; vpx_free <S2SV_ModEnd> ( ctx )\n","project_and_commit_id":"external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426","cve_id":"CVE-2016-1621","original_address":"https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426","time":"2016-03-12T21:59Z"},
	{"Unnamed: 0":5019,"cwe_id":"CWE-834","source":"CWE-834 static int ivr_read_header ( AVFormatContext * s ) { unsigned tag , type , len , tlen , value ; int i , j , n , count , nb_streams = 0 , ret ; uint8_t key [ 256 ] , val [ 256 ] ; AVIOContext * pb = s -> pb ; AVStream * st ; int64_t pos , offset , temp ; pos = avio_tell ( pb ) ; tag = avio_rl32 ( pb ) ; if ( tag == MKTAG ( '.' , 'R' , '1' , 'M' ) ) { if ( avio_rb16 ( pb ) != 1 ) return AVERROR_INVALIDDATA ; if ( avio_r8 ( pb ) != 1 ) return AVERROR_INVALIDDATA ; len = avio_rb32 ( pb ) ; avio_skip ( pb , len ) ; avio_skip ( pb , 5 ) ; temp = avio_rb64 ( pb ) ; while ( ! avio_feof ( pb ) && temp ) { offset = temp ; temp = avio_rb64 ( pb ) ; } avio_skip ( pb , offset - avio_tell ( pb ) ) ; if ( avio_r8 ( pb ) != 1 ) return AVERROR_INVALIDDATA ; len = avio_rb32 ( pb ) ; avio_skip ( pb , len ) ; if ( avio_r8 ( pb ) != 2 ) return AVERROR_INVALIDDATA ; avio_skip ( pb , 16 ) ; pos = avio_tell ( pb ) ; tag = avio_rl32 ( pb ) ; } if ( tag != MKTAG ( '.' , 'R' , 'E' , 'C' ) ) return AVERROR_INVALIDDATA ; if ( avio_r8 ( pb ) != 0 ) return AVERROR_INVALIDDATA ; count = avio_rb32 ( pb ) ; for ( i = 0 ; i < count ; i ++ ) { if ( avio_feof ( pb ) ) return AVERROR_INVALIDDATA ; type = avio_r8 ( pb ) ; tlen = avio_rb32 ( pb ) ; avio_get_str ( pb , tlen , key , sizeof ( key ) ) ; len = avio_rb32 ( pb ) ; if ( type == 5 ) { avio_get_str ( pb , len , val , sizeof ( val ) ) ; av_log ( s , AV_LOG_DEBUG , \"%s<S2SV_blank>=<S2SV_blank>\\'%s\\'\\\\n\" , key , val ) ; } else if ( type == 4 ) { av_log ( s , AV_LOG_DEBUG , \"%s<S2SV_blank>=<S2SV_blank>\\'0x\" , key ) ; <S2SV_StartBug> for ( j = 0 ; j < len ; j ++ ) <S2SV_EndBug> <S2SV_StartBug> av_log ( s , AV_LOG_DEBUG , \"%X\" , avio_r8 ( pb ) ) ; <S2SV_EndBug> av_log ( s , AV_LOG_DEBUG , \"\\'\\\\n\" ) ; } else if ( len == 4 && type == 3 && ! strncmp ( key , \"StreamCount\" , tlen ) ) { nb_streams = value = avio_rb32 ( pb ) ; } else if ( len == 4 && type == 3 ) { value = avio_rb32 ( pb ) ; av_log ( s , AV_LOG_DEBUG , \"%s<S2SV_blank>=<S2SV_blank>%d\\\\n\" , key , value ) ; } else { av_log ( s , AV_LOG_DEBUG , \"Skipping<S2SV_blank>unsupported<S2SV_blank>key:<S2SV_blank>%s\\\\n\" , key ) ; avio_skip ( pb , len ) ; } } for ( n = 0 ; n < nb_streams ; n ++ ) { st = avformat_new_stream ( s , NULL ) ; if ( ! st ) return AVERROR ( ENOMEM ) ; st -> priv_data = ff_rm_alloc_rmstream ( ) ; if ( ! st -> priv_data ) return AVERROR ( ENOMEM ) ; if ( avio_r8 ( pb ) != 1 ) return AVERROR_INVALIDDATA ; count = avio_rb32 ( pb ) ; for ( i = 0 ; i < count ; i ++ ) { if ( avio_feof ( pb ) ) return AVERROR_INVALIDDATA ; type = avio_r8 ( pb ) ; tlen = avio_rb32 ( pb ) ; avio_get_str ( pb , tlen , key , sizeof ( key ) ) ; len = avio_rb32 ( pb ) ; if ( type == 5 ) { avio_get_str ( pb , len , val , sizeof ( val ) ) ; av_log ( s , AV_LOG_DEBUG , \"%s<S2SV_blank>=<S2SV_blank>\\'%s\\'\\\\n\" , key , val ) ; } else if ( type == 4 && ! strncmp ( key , \"OpaqueData\" , tlen ) ) { ret = ffio_ensure_seekback ( pb , 4 ) ; if ( ret < 0 ) return ret ; if ( avio_rb32 ( pb ) == MKBETAG ( 'M' , 'L' , 'T' , 'I' ) ) { ret = rm_read_multi ( s , pb , st , NULL ) ; } else { avio_seek ( pb , - 4 , SEEK_CUR ) ; ret = ff_rm_read_mdpr_codecdata ( s , pb , st , st -> priv_data , len , NULL ) ; } if ( ret < 0 ) return ret ; } else if ( type == 4 ) { int j ; av_log ( s , AV_LOG_DEBUG , \"%s<S2SV_blank>=<S2SV_blank>\\'0x\" , key ) ; for ( j = 0 ; j < len ; j ++ ) av_log ( s , AV_LOG_DEBUG , \"%X\" , avio_r8 ( pb ) ) ; av_log ( s , AV_LOG_DEBUG , \"\\'\\\\n\" ) ; } else if ( len == 4 && type == 3 && ! strncmp ( key , \"Duration\" , tlen ) ) { st -> duration = avio_rb32 ( pb ) ; } else if ( len == 4 && type == 3 ) { value = avio_rb32 ( pb ) ; av_log ( s , AV_LOG_DEBUG , \"%s<S2SV_blank>=<S2SV_blank>%d\\\\n\" , key , value ) ; } else { av_log ( s , AV_LOG_DEBUG , \"Skipping<S2SV_blank>unsupported<S2SV_blank>key:<S2SV_blank>%s\\\\n\" , key ) ; avio_skip ( pb , len ) ; } } } if ( avio_r8 ( pb ) != 6 ) return AVERROR_INVALIDDATA ; avio_skip ( pb , 12 ) ; avio_skip ( pb , avio_rb64 ( pb ) + pos - avio_tell ( s -> pb ) ) ; if ( avio_r8 ( pb ) != 8 ) return AVERROR_INVALIDDATA ; avio_skip ( pb , 8 ) ; return 0 ; }\n","target":"<S2SV_ModStart> j ++ ) { if ( avio_feof ( pb ) ) return AVERROR_INVALIDDATA ; <S2SV_ModStart> ) ) ; }\n","project_and_commit_id":"FFmpeg@FFmpeg/124eb202e70678539544f6268efc98131f19fa49","cve_id":"CVE-2017-14054","original_address":"https://github.com/FFmpeg/FFmpeg/commit/124eb202e70678539544f6268efc98131f19fa49","time":"2017-08-31T15:29Z"},
	{"Unnamed: 0":252,"cwe_id":"CWE-264","source":"CWE-264 static int do_remount ( struct path * path , int flags , int mnt_flags , void * data ) { int err ; struct super_block * sb = path -> mnt -> mnt_sb ; struct mount * mnt = real_mount ( path -> mnt ) ; if ( ! check_mnt ( mnt ) ) return - EINVAL ; if ( path -> dentry != path -> mnt -> mnt_root ) return - EINVAL ; if ( ( mnt -> mnt . mnt_flags & MNT_LOCK_READONLY ) && ! ( mnt_flags & MNT_READONLY ) ) { return - EPERM ; } <S2SV_StartBug> err = security_sb_remount ( sb , data ) ; <S2SV_EndBug> if ( err ) return err ; down_write ( & sb -> s_umount ) ; if ( flags & MS_BIND ) err = change_mount_flags ( path -> mnt , flags ) ; else if ( ! capable ( CAP_SYS_ADMIN ) ) err = - EPERM ; else err = do_remount_sb ( sb , flags , data , 0 ) ; if ( ! err ) { lock_mount_hash ( ) ; mnt_flags |= mnt -> mnt . mnt_flags & ~ MNT_USER_SETTABLE_MASK ; mnt -> mnt . mnt_flags = mnt_flags ; touch_mnt_namespace ( mnt -> mnt_ns ) ; unlock_mount_hash ( ) ; } up_write ( & sb -> s_umount ) ; return err ; }\n","target":"<S2SV_ModStart> EPERM ; } if ( ( mnt -> mnt . mnt_flags & MNT_LOCK_NODEV ) && ! ( mnt_flags & MNT_NODEV ) ) { return - EPERM ; } if ( ( mnt -> mnt . mnt_flags & MNT_LOCK_NOSUID ) && ! ( mnt_flags & MNT_NOSUID ) ) { return - EPERM ; } if ( ( mnt -> mnt . mnt_flags & MNT_LOCK_NOEXEC ) && ! ( mnt_flags & MNT_NOEXEC ) ) { return - EPERM ; } if ( ( mnt -> mnt . mnt_flags & MNT_LOCK_ATIME ) && ( ( mnt -> mnt . mnt_flags & MNT_ATIME_MASK ) != ( mnt_flags & MNT_ATIME_MASK ) ) ) { return - EPERM ; }\n","project_and_commit_id":"torvalds@linux/9566d6742852c527bf5af38af5cbb878dad75705","cve_id":"CVE-2014-5207","original_address":"https://github.com/torvalds/linux/commit/9566d6742852c527bf5af38af5cbb878dad75705","time":"2014-08-18T11:15Z"},
	{"Unnamed: 0":1998,"cwe_id":"CWE-269","source":"CWE-269 void virtio_config_writeb ( VirtIODevice * vdev , uint32_t addr , uint32_t data ) { VirtioDeviceClass * k = VIRTIO_DEVICE_GET_CLASS ( vdev ) ; uint8_t val = data ; <S2SV_StartBug> if ( addr > ( vdev -> config_len - sizeof ( val ) ) ) <S2SV_EndBug> return ; stb_p ( vdev -> config + addr , val ) ; if ( k -> set_config ) { k -> set_config ( vdev , vdev -> config ) ; } }\n","target":"<S2SV_ModStart> if ( addr + <S2SV_ModEnd> sizeof ( val <S2SV_ModStart> ( val ) > vdev -> config_len ) { return ; } <S2SV_ModEnd> stb_p ( vdev\n","project_and_commit_id":"qemu@qemu/5f5a1318653c08e435cfa52f60b6a712815b659d","cve_id":"CVE-2013-2016","original_address":"https://github.com/qemu/qemu/commit/5f5a1318653c08e435cfa52f60b6a712815b659d","time":"2019-12-30T22:15Z"},
	{"Unnamed: 0":6168,"cwe_id":"CWE-20","source":"CWE-20 error_t coapClientWriteBody ( CoapClientRequest * request , const void * data , size_t length , size_t * written , bool_t last ) { error_t error ; size_t n ; uint32_t value ; uint32_t blockPos ; uint32_t blockSzx ; size_t payloadLen ; const uint8_t * payload ; CoapMessage * requestMsg ; CoapMessage * responseMsg ; CoapCode responseCode ; error = NO_ERROR ; if ( written != NULL ) * written = 0 ; while ( length > 0 || last ) { requestMsg = coapClientGetRequestMessage ( request ) ; error = coapGetUintOption ( requestMsg , COAP_OPT_BLOCK1 , 0 , & value ) ; if ( ! error ) { blockPos = COAP_GET_BLOCK_POS ( value ) ; blockSzx = COAP_GET_BLOCK_SZX ( value ) ; } else { blockPos = 0 ; blockSzx = request -> txBlockSzx ; } error = coapClientGetPayload ( requestMsg , & payload , & payloadLen ) ; if ( error ) break ; if ( length > 0 && payloadLen < COAP_GET_BLOCK_SIZE ( blockSzx ) ) { n = MIN ( length , COAP_GET_BLOCK_SIZE ( blockSzx ) - payloadLen ) ; error = coapClientWritePayload ( requestMsg , data , n ) ; if ( error ) break ; data = ( uint8_t * ) data + n ; length -= n ; if ( written != NULL ) * written += n ; } else { if ( blockPos > 0 || length > 0 || ! last ) { COAP_SET_BLOCK_NUM ( value , blockPos >> ( blockSzx + 4 ) ) ; if ( length == 0 && last ) <S2SV_StartBug> COAP_SET_BLOCK_M ( value , 0 ) ; <S2SV_EndBug> <S2SV_StartBug> else <S2SV_EndBug> <S2SV_StartBug> COAP_SET_BLOCK_M ( value , 1 ) ; <S2SV_EndBug> COAP_SET_BLOCK_SZX ( value , blockSzx ) ; error = coapClientSetUintOption ( requestMsg , COAP_OPT_BLOCK1 , 0 , value ) ; if ( error ) break ; } if ( length == 0 && last ) { if ( request -> rxBlockSzx < COAP_BLOCK_SIZE_RESERVED ) { COAP_SET_BLOCK_NUM ( value , 0 ) ; COAP_SET_BLOCK_M ( value , 0 ) ; COAP_SET_BLOCK_SZX ( value , request -> rxBlockSzx ) ; error = coapClientSetUintOption ( requestMsg , COAP_OPT_BLOCK2 , 0 , value ) ; if ( error ) break ; } } error = coapClientSendRequest ( request , NULL , NULL ) ; if ( error ) break ; responseMsg = coapClientGetResponseMessage ( request ) ; error = coapClientGetResponseCode ( responseMsg , & responseCode ) ; if ( error ) break ; if ( COAP_GET_CODE_CLASS ( responseCode ) != COAP_CODE_CLASS_SUCCESS ) { error = ERROR_INVALID_STATUS ; break ; } if ( blockPos > 0 || length > 0 || ! last ) { error = coapClientGetUintOption ( responseMsg , COAP_OPT_BLOCK1 , 0 , & value ) ; if ( error ) break ; if ( COAP_GET_BLOCK_SZX ( value ) >= COAP_BLOCK_SIZE_RESERVED ) { error = ERROR_FAILURE ; break ; } if ( COAP_GET_BLOCK_POS ( value ) != blockPos ) { error = ERROR_FAILURE ; break ; } if ( blockSzx > COAP_GET_BLOCK_SZX ( value ) ) blockSzx = COAP_GET_BLOCK_SZX ( value ) ; blockPos += COAP_GET_BLOCK_SIZE ( blockSzx ) ; COAP_SET_BLOCK_NUM ( value , blockPos >> ( blockSzx + 4 ) ) ; COAP_SET_BLOCK_SZX ( value , blockSzx ) ; error = coapClientSetUintOption ( requestMsg , COAP_OPT_BLOCK1 , 0 , value ) ; if ( error ) break ; } error = coapClientSetPayload ( requestMsg , NULL , 0 ) ; if ( error ) break ; if ( length == 0 && last ) { error = coapClientDeleteOption ( requestMsg , COAP_OPT_BLOCK1 , 0 ) ; break ; } } } return error ; }\n","target":"<S2SV_ModStart> && last ) { <S2SV_ModStart> 0 ) ; } else { <S2SV_ModEnd> COAP_SET_BLOCK_M ( value <S2SV_ModStart> 1 ) ; }\n","project_and_commit_id":"Oryx-Embedded@CycloneTCP/de5336016edbe1e90327d0ed1cba5c4e49114366","cve_id":"CVE-2021-26788","original_address":"https://github.com/Oryx-Embedded/CycloneTCP/commit/de5336016edbe1e90327d0ed1cba5c4e49114366","time":"2021-03-08T13:15Z"},
	{"Unnamed: 0":6741,"cwe_id":"CWE-119","source":"CWE-119 const vpx_codec_cx_pkt_t * vpx_codec_get_cx_data ( vpx_codec_ctx_t * ctx , vpx_codec_iter_t * iter ) { const vpx_codec_cx_pkt_t * pkt = NULL ; if ( ctx ) { if ( ! iter ) ctx -> err = VPX_CODEC_INVALID_PARAM ; else if ( ! ctx -> iface || ! ctx -> priv ) ctx -> err = VPX_CODEC_ERROR ; else if ( ! ( ctx -> iface -> caps & VPX_CODEC_CAP_ENCODER ) ) ctx -> err = VPX_CODEC_INCAPABLE ; else <S2SV_StartBug> pkt = ctx -> iface -> enc . get_cx_data ( ctx -> priv -> alg_priv , iter ) ; <S2SV_EndBug> } if ( pkt && pkt -> kind == VPX_CODEC_CX_FRAME_PKT ) { vpx_codec_priv_t * const priv = ctx -> priv ; char * const dst_buf = ( char * ) priv -> enc . cx_data_dst_buf . buf ; if ( dst_buf && pkt -> data . raw . buf != dst_buf && pkt -> data . raw . sz + priv -> enc . cx_data_pad_before + priv -> enc . cx_data_pad_after <= priv -> enc . cx_data_dst_buf . sz ) { vpx_codec_cx_pkt_t * modified_pkt = & priv -> enc . cx_data_pkt ; memcpy ( dst_buf + priv -> enc . cx_data_pad_before , pkt -> data . raw . buf , pkt -> data . raw . sz ) ; * modified_pkt = * pkt ; modified_pkt -> data . raw . buf = dst_buf ; modified_pkt -> data . raw . sz += priv -> enc . cx_data_pad_before + priv -> enc . cx_data_pad_after ; pkt = modified_pkt ; } if ( dst_buf == pkt -> data . raw . buf ) { priv -> enc . cx_data_dst_buf . buf = dst_buf + pkt -> data . raw . sz ; priv -> enc . cx_data_dst_buf . sz -= pkt -> data . raw . sz ; } } return pkt ; }\n","target":"<S2SV_ModStart> . get_cx_data ( get_alg_priv ( ctx ) <S2SV_ModEnd> , iter )\n","project_and_commit_id":"external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426","cve_id":"CVE-2016-1621","original_address":"https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426","time":"2016-03-12T21:59Z"},
	{"Unnamed: 0":2820,"cwe_id":"CWE-190","source":"CWE-190 static int do_timer_create ( clockid_t which_clock , struct sigevent * event , timer_t __user * created_timer_id ) { const struct k_clock * kc = clockid_to_kclock ( which_clock ) ; struct k_itimer * new_timer ; int error , new_timer_id ; int it_id_set = IT_ID_NOT_SET ; if ( ! kc ) return - EINVAL ; if ( ! kc -> timer_create ) return - EOPNOTSUPP ; new_timer = alloc_posix_timer ( ) ; if ( unlikely ( ! new_timer ) ) return - EAGAIN ; spin_lock_init ( & new_timer -> it_lock ) ; new_timer_id = posix_timer_add ( new_timer ) ; if ( new_timer_id < 0 ) { error = new_timer_id ; goto out ; } it_id_set = IT_ID_SET ; new_timer -> it_id = ( timer_t ) new_timer_id ; new_timer -> it_clock = which_clock ; new_timer -> kclock = kc ; <S2SV_StartBug> new_timer -> it_overrun = - 1 ; <S2SV_EndBug> if ( event ) { rcu_read_lock ( ) ; new_timer -> it_pid = get_pid ( good_sigevent ( event ) ) ; rcu_read_unlock ( ) ; if ( ! new_timer -> it_pid ) { error = - EINVAL ; goto out ; } new_timer -> it_sigev_notify = event -> sigev_notify ; new_timer -> sigq -> info . si_signo = event -> sigev_signo ; new_timer -> sigq -> info . si_value = event -> sigev_value ; } else { new_timer -> it_sigev_notify = SIGEV_SIGNAL ; new_timer -> sigq -> info . si_signo = SIGALRM ; memset ( & new_timer -> sigq -> info . si_value , 0 , sizeof ( sigval_t ) ) ; new_timer -> sigq -> info . si_value . sival_int = new_timer -> it_id ; new_timer -> it_pid = get_pid ( task_tgid ( current ) ) ; } new_timer -> sigq -> info . si_tid = new_timer -> it_id ; new_timer -> sigq -> info . si_code = SI_TIMER ; if ( copy_to_user ( created_timer_id , & new_timer_id , sizeof ( new_timer_id ) ) ) { error = - EFAULT ; goto out ; } error = kc -> timer_create ( new_timer ) ; if ( error ) goto out ; spin_lock_irq ( & current -> sighand -> siglock ) ; new_timer -> it_signal = current -> signal ; list_add ( & new_timer -> list , & current -> signal -> posix_timers ) ; spin_unlock_irq ( & current -> sighand -> siglock ) ; return 0 ; out : release_posix_timer ( new_timer , it_id_set ) ; return error ; }\n","target":"<S2SV_ModStart> it_overrun = - 1LL <S2SV_ModEnd> ; if (\n","project_and_commit_id":"torvalds@linux/78c9c4dfbf8c04883941445a195276bb4bb92c76","cve_id":"CVE-2018-12896","original_address":"https://github.com/torvalds/linux/commit/78c9c4dfbf8c04883941445a195276bb4bb92c76","time":"2018-07-02T17:29Z"},
	{"Unnamed: 0":593,"cwe_id":"CWE-400","source":"CWE-400 int do_fpu_inst ( unsigned short inst , struct pt_regs * regs ) { struct task_struct * tsk = current ; struct sh_fpu_soft_struct * fpu = & ( tsk -> thread . xstate -> softfpu ) ; <S2SV_StartBug> perf_sw_event ( PERF_COUNT_SW_EMULATION_FAULTS , 1 , 0 , regs , 0 ) ; <S2SV_EndBug> if ( ! ( task_thread_info ( tsk ) -> status & TS_USEDFPU ) ) { fpu_init ( fpu ) ; task_thread_info ( tsk ) -> status |= TS_USEDFPU ; } return fpu_emulate ( inst , fpu , regs ) ; }\n","target":"<S2SV_ModStart> PERF_COUNT_SW_EMULATION_FAULTS , 1 <S2SV_ModEnd> , regs ,\n","project_and_commit_id":"torvalds@linux/a8b0ca17b80e92faab46ee7179ba9e99ccb61233","cve_id":"CVE-2011-2918","original_address":"https://github.com/torvalds/linux/commit/a8b0ca17b80e92faab46ee7179ba9e99ccb61233","time":"2012-05-24T23:55Z"},
	{"Unnamed: 0":5896,"cwe_id":"CWE-000","source":"CWE-000 int evm_update_evmxattr ( struct dentry * dentry , const char * xattr_name , const char * xattr_value , size_t xattr_value_len ) { struct inode * inode = dentry -> d_inode ; struct evm_ima_xattr_data xattr_data ; int rc = 0 ; rc = evm_calc_hmac ( dentry , xattr_name , xattr_value , xattr_value_len , xattr_data . digest ) ; if ( rc == 0 ) { xattr_data . type = EVM_XATTR_HMAC ; rc = __vfs_setxattr_noperm ( dentry , XATTR_NAME_EVM , & xattr_data , sizeof ( xattr_data ) , 0 ) ; } <S2SV_StartBug> else if ( rc == - ENODATA ) <S2SV_EndBug> rc = inode -> i_op -> removexattr ( dentry , XATTR_NAME_EVM ) ; <S2SV_StartBug> return rc ; <S2SV_EndBug> }\n","target":"<S2SV_ModStart> == - ENODATA && inode -> i_op -> removexattr ) { <S2SV_ModEnd> rc = inode <S2SV_ModStart> XATTR_NAME_EVM ) ; }\n","project_and_commit_id":"torvalds@linux/a67adb997419fb53540d4a4f79c6471c60bc69b6","cve_id":"CVE-2013-0313","original_address":"https://github.com/torvalds/linux/commit/a67adb997419fb53540d4a4f79c6471c60bc69b6","time":"2013-02-22T00:55Z"},
	{"Unnamed: 0":42,"cwe_id":"CWE-20","source":"CWE-20 void httpClientParseQopParam ( const HttpParam * param , HttpWwwAuthenticateHeader * authHeader ) { # if ( HTTP_CLIENT_DIGEST_AUTH_SUPPORT == ENABLED ) size_t i ; size_t n ; authHeader -> qop = HTTP_AUTH_QOP_NONE ; for ( i = 0 ; i < param -> valueLen ; i += ( n + 1 ) ) { for ( n = 0 ; ( i + n ) < param -> valueLen ; n ++ ) { <S2SV_StartBug> if ( strchr ( \",<S2SV_blank>\\\\t\" , param -> value [ i + n ] ) ) <S2SV_EndBug> break ; } if ( n == 4 && ! osStrncasecmp ( param -> value + i , \"auth\" , 4 ) ) { authHeader -> qop = HTTP_AUTH_QOP_AUTH ; } } if ( authHeader -> qop == HTTP_AUTH_QOP_NONE ) { authHeader -> mode = HTTP_AUTH_MODE_NONE ; } # endif }\n","target":"<S2SV_ModStart> { if ( osStrchr <S2SV_ModEnd> ( \",<S2SV_blank>\\\\t\" , <S2SV_ModStart> n ] ) != NULL ) { break ; } <S2SV_ModEnd> } if (\n","project_and_commit_id":"Oryx-Embedded@CycloneTCP/de5336016edbe1e90327d0ed1cba5c4e49114366","cve_id":"CVE-2021-26788","original_address":"https://github.com/Oryx-Embedded/CycloneTCP/commit/de5336016edbe1e90327d0ed1cba5c4e49114366","time":"2021-03-08T13:15Z"},
	{"Unnamed: 0":1551,"cwe_id":"CWE-119","source":"CWE-119 static int32_t scsi_send_command ( SCSIRequest * req , uint8_t * buf ) { SCSIDiskReq * r = DO_UPCAST ( SCSIDiskReq , req , req ) ; SCSIDiskState * s = DO_UPCAST ( SCSIDiskState , qdev , req -> dev ) ; int32_t len ; uint8_t command ; <S2SV_StartBug> uint8_t * outbuf ; <S2SV_EndBug> int rc ; <S2SV_StartBug> command = buf [ 0 ] ; <S2SV_EndBug> outbuf = ( uint8_t * ) r -> iov . iov_base ; DPRINTF ( \"Command:<S2SV_blank>lun=%d<S2SV_blank>tag=0x%x<S2SV_blank>data=0x%02x\" , req -> lun , req -> tag , buf [ 0 ] ) ; # ifdef DEBUG_SCSI { int i ; for ( i = 1 ; i < r -> req . cmd . len ; i ++ ) { printf ( \"<S2SV_blank>0x%02x\" , buf [ i ] ) ; } printf ( \"\\\\n\" ) ; } # endif switch ( command ) { case TEST_UNIT_READY : case INQUIRY : case MODE_SENSE : case MODE_SENSE_10 : case RESERVE : case RESERVE_10 : case RELEASE : case RELEASE_10 : case START_STOP : case ALLOW_MEDIUM_REMOVAL : case READ_CAPACITY_10 : case READ_TOC : case GET_CONFIGURATION : case SERVICE_ACTION_IN_16 : case VERIFY_10 : <S2SV_StartBug> rc = scsi_disk_emulate_command ( r , outbuf ) ; <S2SV_EndBug> if ( rc < 0 ) { return 0 ; } r -> iov . iov_len = rc ; break ; case SYNCHRONIZE_CACHE : bdrv_acct_start ( s -> bs , & r -> acct , 0 , BDRV_ACCT_FLUSH ) ; r -> req . aiocb = bdrv_aio_flush ( s -> bs , scsi_flush_complete , r ) ; if ( r -> req . aiocb == NULL ) { scsi_flush_complete ( r , - EIO ) ; } return 0 ; case READ_6 : case READ_10 : case READ_12 : case READ_16 : len = r -> req . cmd . xfer / s -> qdev . blocksize ; DPRINTF ( \"Read<S2SV_blank>(sector<S2SV_blank>%\" PRId64 \",<S2SV_blank>count<S2SV_blank>%d)\\\\n\" , r -> req . cmd . lba , len ) ; if ( r -> req . cmd . lba > s -> max_lba ) goto illegal_lba ; r -> sector = r -> req . cmd . lba * s -> cluster_size ; r -> sector_count = len * s -> cluster_size ; break ; case WRITE_6 : case WRITE_10 : case WRITE_12 : case WRITE_16 : case WRITE_VERIFY_10 : case WRITE_VERIFY_12 : case WRITE_VERIFY_16 : len = r -> req . cmd . xfer / s -> qdev . blocksize ; DPRINTF ( \"Write<S2SV_blank>%s(sector<S2SV_blank>%\" PRId64 \",<S2SV_blank>count<S2SV_blank>%d)\\\\n\" , ( command & 0xe ) == 0xe ? \"And<S2SV_blank>Verify<S2SV_blank>\" : \"\" , r -> req . cmd . lba , len ) ; if ( r -> req . cmd . lba > s -> max_lba ) goto illegal_lba ; r -> sector = r -> req . cmd . lba * s -> cluster_size ; r -> sector_count = len * s -> cluster_size ; break ; case MODE_SELECT : DPRINTF ( \"Mode<S2SV_blank>Select(6)<S2SV_blank>(len<S2SV_blank>%lu)\\\\n\" , ( long ) r -> req . cmd . xfer ) ; if ( r -> req . cmd . xfer > 12 ) { goto fail ; } break ; case MODE_SELECT_10 : DPRINTF ( \"Mode<S2SV_blank>Select(10)<S2SV_blank>(len<S2SV_blank>%lu)\\\\n\" , ( long ) r -> req . cmd . xfer ) ; if ( r -> req . cmd . xfer > 16 ) { goto fail ; } break ; case SEEK_6 : case SEEK_10 : DPRINTF ( \"Seek(%d)<S2SV_blank>(sector<S2SV_blank>%\" PRId64 \")\\\\n\" , command == SEEK_6 ? 6 : 10 , r -> req . cmd . lba ) ; if ( r -> req . cmd . lba > s -> max_lba ) { goto illegal_lba ; } break ; case WRITE_SAME_16 : len = r -> req . cmd . xfer / s -> qdev . blocksize ; DPRINTF ( \"WRITE<S2SV_blank>SAME(16)<S2SV_blank>(sector<S2SV_blank>%\" PRId64 \",<S2SV_blank>count<S2SV_blank>%d)\\\\n\" , r -> req . cmd . lba , len ) ; if ( r -> req . cmd . lba > s -> max_lba ) { goto illegal_lba ; } if ( ! ( buf [ 1 ] & 0x8 ) ) { goto fail ; } rc = bdrv_discard ( s -> bs , r -> req . cmd . lba * s -> cluster_size , len * s -> cluster_size ) ; if ( rc < 0 ) { goto fail ; } break ; case REQUEST_SENSE : abort ( ) ; default : DPRINTF ( \"Unknown<S2SV_blank>SCSI<S2SV_blank>command<S2SV_blank>(%2.2x)\\\\n\" , buf [ 0 ] ) ; scsi_check_condition ( r , SENSE_CODE ( INVALID_OPCODE ) ) ; return 0 ; fail : scsi_check_condition ( r , SENSE_CODE ( INVALID_FIELD ) ) ; return 0 ; illegal_lba : scsi_check_condition ( r , SENSE_CODE ( LBA_OUT_OF_RANGE ) ) ; return 0 ; } if ( r -> sector_count == 0 && r -> iov . iov_len == 0 ) { scsi_req_complete ( & r -> req , GOOD ) ; } len = r -> sector_count * 512 + r -> iov . iov_len ; if ( r -> req . cmd . mode == SCSI_XFER_TO_DEV ) { return - len ; } else { if ( ! r -> sector_count ) r -> sector_count = - 1 ; return len ; } }\n","target":"<S2SV_ModStart> uint8_t command ; <S2SV_ModEnd> int rc ; <S2SV_ModStart> [ 0 ] <S2SV_ModEnd> ; DPRINTF ( <S2SV_ModStart> scsi_disk_emulate_command ( r <S2SV_ModEnd> ) ; if\n","project_and_commit_id":"bonzini@qemu/7285477ab11831b1cf56e45878a89170dd06d9b9","cve_id":"CVE-2011-3346","original_address":"https://github.com/bonzini/qemu/commit/7285477ab11831b1cf56e45878a89170dd06d9b9","time":"2014-04-01T06:35Z"},
	{"Unnamed: 0":705,"cwe_id":"CWE-416","source":"CWE-416 static int hci_uart_set_proto ( struct hci_uart * hu , int id ) { const struct hci_uart_proto * p ; int err ; p = hci_uart_get_proto ( id ) ; if ( ! p ) return - EPROTONOSUPPORT ; hu -> proto = p ; <S2SV_StartBug> set_bit ( HCI_UART_PROTO_READY , & hu -> flags ) ; <S2SV_EndBug> err = hci_uart_register_dev ( hu ) ; if ( err ) { <S2SV_StartBug> clear_bit ( HCI_UART_PROTO_READY , & hu -> flags ) ; <S2SV_EndBug> <S2SV_StartBug> return err ; <S2SV_EndBug> } return 0 ; }\n","target":"<S2SV_ModStart> = p ; <S2SV_ModEnd> err = hci_uart_register_dev <S2SV_ModStart> err ) { return err ; } set_bit <S2SV_ModEnd> ( HCI_UART_PROTO_READY , <S2SV_ModStart> ) ; return <S2SV_ModEnd> 0 ; }\n","project_and_commit_id":"torvalds@linux/56897b217a1d0a91c9920cb418d6b3fe922f590a","cve_id":"CVE-2019-15917","original_address":"https://github.com/torvalds/linux/commit/56897b217a1d0a91c9920cb418d6b3fe922f590a","time":"2019-09-04T19:15Z"},
	{"Unnamed: 0":261,"cwe_id":"CWE-119","source":"CWE-119 void oz_usb_rx ( struct oz_pd * pd , struct oz_elt * elt ) { struct oz_usb_hdr * usb_hdr = ( struct oz_usb_hdr * ) ( elt + 1 ) ; struct oz_usb_ctx * usb_ctx ; spin_lock_bh ( & pd -> app_lock [ OZ_APPID_USB ] ) ; usb_ctx = ( struct oz_usb_ctx * ) pd -> app_ctx [ OZ_APPID_USB ] ; if ( usb_ctx ) oz_usb_get ( usb_ctx ) ; spin_unlock_bh ( & pd -> app_lock [ OZ_APPID_USB ] ) ; if ( usb_ctx == NULL ) return ; if ( usb_ctx -> stopped ) goto done ; if ( usb_hdr -> elt_seq_num != 0 ) { if ( ( ( usb_ctx -> rx_seq_num - usb_hdr -> elt_seq_num ) & 0x80 ) == 0 ) goto done ; } usb_ctx -> rx_seq_num = usb_hdr -> elt_seq_num ; switch ( usb_hdr -> type ) { case OZ_GET_DESC_RSP : { struct oz_get_desc_rsp * body = ( struct oz_get_desc_rsp * ) usb_hdr ; <S2SV_StartBug> int data_len = elt -> length - <S2SV_EndBug> <S2SV_StartBug> sizeof ( struct oz_get_desc_rsp ) + 1 ; <S2SV_EndBug> u16 offs = le16_to_cpu ( get_unaligned ( & body -> offset ) ) ; u16 total_size = le16_to_cpu ( get_unaligned ( & body -> total_size ) ) ; oz_dbg ( ON , \"USB_REQ_GET_DESCRIPTOR<S2SV_blank>-<S2SV_blank>cnf\\\\n\" ) ; oz_hcd_get_desc_cnf ( usb_ctx -> hport , body -> req_id , body -> rcode , body -> data , data_len , offs , total_size ) ; } break ; case OZ_SET_CONFIG_RSP : { struct oz_set_config_rsp * body = ( struct oz_set_config_rsp * ) usb_hdr ; oz_hcd_control_cnf ( usb_ctx -> hport , body -> req_id , body -> rcode , NULL , 0 ) ; } break ; case OZ_SET_INTERFACE_RSP : { struct oz_set_interface_rsp * body = ( struct oz_set_interface_rsp * ) usb_hdr ; oz_hcd_control_cnf ( usb_ctx -> hport , body -> req_id , body -> rcode , NULL , 0 ) ; } break ; case OZ_VENDOR_CLASS_RSP : { struct oz_vendor_class_rsp * body = ( struct oz_vendor_class_rsp * ) usb_hdr ; oz_hcd_control_cnf ( usb_ctx -> hport , body -> req_id , body -> rcode , body -> data , elt -> length - sizeof ( struct oz_vendor_class_rsp ) + 1 ) ; } break ; case OZ_USB_ENDPOINT_DATA : oz_usb_handle_ep_data ( usb_ctx , usb_hdr , elt -> length ) ; break ; } done : oz_usb_put ( usb_ctx ) ; }\n","target":"<S2SV_ModStart> ) usb_hdr ; u16 offs , total_size ; u8 data_len ; if ( elt -> length < sizeof ( struct oz_get_desc_rsp ) - 1 ) break ; <S2SV_ModEnd> data_len = elt <S2SV_ModStart> -> length - ( <S2SV_ModStart> ( struct oz_get_desc_rsp ) - 1 ) ; offs = le16_to_cpu ( get_unaligned ( & body -> offset ) ) ; total_size = le16_to_cpu ( get_unaligned ( & body -> total_size ) ) ; oz_dbg ( ON , \"USB_REQ_GET_DESCRIPTOR<S2SV_blank>-<S2SV_blank>cnf\\\\n\" ) ; oz_hcd_get_desc_cnf ( usb_ctx -> hport , body -> req_id , body -> rcode , body -> data , data_len , offs , total_size ) ; } break ; case OZ_SET_CONFIG_RSP : { struct oz_set_config_rsp * body = ( struct oz_set_config_rsp * ) usb_hdr ; oz_hcd_control_cnf ( usb_ctx -> hport , body -> req_id , body -> rcode , NULL , 0 ) ; } break ; case OZ_SET_INTERFACE_RSP : { struct oz_set_interface_rsp * body = ( struct oz_set_interface_rsp * ) usb_hdr ; oz_hcd_control_cnf ( usb_ctx -> hport , body -> req_id , body -> rcode , NULL , 0 ) ; } break ; case OZ_VENDOR_CLASS_RSP : { struct oz_vendor_class_rsp * body = ( struct oz_vendor_class_rsp * ) usb_hdr ; oz_hcd_control_cnf ( usb_ctx -> hport , body -> req_id , body -> rcode , body -> data , elt -> length - sizeof ( struct oz_vendor_class_rsp <S2SV_ModStart> ) + 1 <S2SV_ModEnd> ) ; }\n","project_and_commit_id":"torvalds@linux/d114b9fe78c8d6fc6e70808c2092aa307c36dc8e","cve_id":"CVE-2015-4002","original_address":"https://github.com/torvalds/linux/commit/d114b9fe78c8d6fc6e70808c2092aa307c36dc8e","time":"2015-06-07T23:59Z"},
	{"Unnamed: 0":2467,"cwe_id":"CWE-287","source":"CWE-287 static ngx_int_t ngx_http_auth_spnego_handler ( ngx_http_request_t * r ) { ngx_int_t ret = NGX_DECLINED ; ngx_http_auth_spnego_ctx_t * ctx ; ngx_http_auth_spnego_loc_conf_t * alcf ; alcf = ngx_http_get_module_loc_conf ( r , ngx_http_auth_spnego_module ) ; if ( alcf -> protect == 0 ) { return NGX_DECLINED ; } ctx = ngx_http_get_module_ctx ( r , ngx_http_auth_spnego_module ) ; if ( NULL == ctx ) { ctx = ngx_palloc ( r -> pool , sizeof ( ngx_http_auth_spnego_ctx_t ) ) ; if ( NULL == ctx ) { return NGX_HTTP_INTERNAL_SERVER_ERROR ; } ctx -> token . len = 0 ; ctx -> token . data = NULL ; ctx -> head = 0 ; ctx -> ret = NGX_HTTP_UNAUTHORIZED ; ngx_http_set_ctx ( r , ctx , ngx_http_auth_spnego_module ) ; } spnego_debug3 ( \"SSO<S2SV_blank>auth<S2SV_blank>handling<S2SV_blank>IN:<S2SV_blank>token.len=%d,<S2SV_blank>head=%d,<S2SV_blank>ret=%d\" , ctx -> token . len , ctx -> head , ctx -> ret ) ; if ( ctx -> token . len && ctx -> head ) { spnego_debug1 ( \"Found<S2SV_blank>token<S2SV_blank>and<S2SV_blank>head,<S2SV_blank>returning<S2SV_blank>%d\" , ctx -> ret ) ; return ctx -> ret ; } if ( NULL != r -> headers_in . user . data ) { spnego_debug0 ( \"User<S2SV_blank>header<S2SV_blank>set\" ) ; return NGX_OK ; } spnego_debug0 ( \"Begin<S2SV_blank>auth\" ) ; if ( alcf -> allow_basic ) { spnego_debug0 ( \"Detect<S2SV_blank>basic<S2SV_blank>auth\" ) ; ret = ngx_http_auth_basic_user ( r ) ; if ( NGX_OK == ret ) { spnego_debug0 ( \"Basic<S2SV_blank>auth<S2SV_blank>credentials<S2SV_blank>supplied<S2SV_blank>by<S2SV_blank>client\" ) ; <S2SV_StartBug> if ( NGX_DECLINED == ngx_http_auth_spnego_basic ( r , ctx , alcf ) ) { <S2SV_EndBug> spnego_debug0 ( \"Basic<S2SV_blank>auth<S2SV_blank>failed\" ) ; if ( NGX_ERROR == ngx_http_auth_spnego_headers_basic_only ( r , ctx , alcf ) ) { spnego_debug0 ( \"Error<S2SV_blank>setting<S2SV_blank>headers\" ) ; return ( ctx -> ret = NGX_HTTP_INTERNAL_SERVER_ERROR ) ; } return ( ctx -> ret = NGX_HTTP_UNAUTHORIZED ) ; } if ( ! ngx_spnego_authorized_principal ( r , & r -> headers_in . user , alcf ) ) { spnego_debug0 ( \"User<S2SV_blank>not<S2SV_blank>authorized\" ) ; return ( ctx -> ret = NGX_HTTP_FORBIDDEN ) ; } spnego_debug0 ( \"Basic<S2SV_blank>auth<S2SV_blank>succeeded\" ) ; return ( ctx -> ret = NGX_OK ) ; } } spnego_debug0 ( \"Detect<S2SV_blank>SPNEGO<S2SV_blank>token\" ) ; ret = ngx_http_auth_spnego_token ( r , ctx ) ; if ( NGX_OK == ret ) { spnego_debug0 ( \"Client<S2SV_blank>sent<S2SV_blank>a<S2SV_blank>reasonable<S2SV_blank>Negotiate<S2SV_blank>header\" ) ; ret = ngx_http_auth_spnego_auth_user_gss ( r , ctx , alcf ) ; if ( NGX_ERROR == ret ) { spnego_debug0 ( \"GSSAPI<S2SV_blank>failed\" ) ; return ( ctx -> ret = NGX_HTTP_INTERNAL_SERVER_ERROR ) ; } if ( NGX_DECLINED == ret ) { spnego_debug0 ( \"GSSAPI<S2SV_blank>failed\" ) ; if ( ! alcf -> allow_basic ) { return ( ctx -> ret = NGX_HTTP_FORBIDDEN ) ; } if ( NGX_ERROR == ngx_http_auth_spnego_headers_basic_only ( r , ctx , alcf ) ) { spnego_debug0 ( \"Error<S2SV_blank>setting<S2SV_blank>headers\" ) ; return ( ctx -> ret = NGX_HTTP_INTERNAL_SERVER_ERROR ) ; } return ( ctx -> ret = NGX_HTTP_UNAUTHORIZED ) ; } if ( ! ngx_spnego_authorized_principal ( r , & r -> headers_in . user , alcf ) ) { spnego_debug0 ( \"User<S2SV_blank>not<S2SV_blank>authorized\" ) ; return ( ctx -> ret = NGX_HTTP_FORBIDDEN ) ; } spnego_debug0 ( \"GSSAPI<S2SV_blank>auth<S2SV_blank>succeeded\" ) ; } ngx_str_t * token_out_b64 = NULL ; switch ( ret ) { case NGX_DECLINED : ctx -> ret = NGX_HTTP_UNAUTHORIZED ; break ; case NGX_OK : ctx -> ret = NGX_OK ; token_out_b64 = & ctx -> token_out_b64 ; break ; case NGX_ERROR : default : ctx -> ret = NGX_HTTP_INTERNAL_SERVER_ERROR ; break ; } if ( NGX_ERROR == ngx_http_auth_spnego_headers ( r , ctx , token_out_b64 , alcf ) ) { spnego_debug0 ( \"Error<S2SV_blank>setting<S2SV_blank>headers\" ) ; ctx -> ret = NGX_HTTP_INTERNAL_SERVER_ERROR ; } spnego_debug3 ( \"SSO<S2SV_blank>auth<S2SV_blank>handling<S2SV_blank>OUT:<S2SV_blank>token.len=%d,<S2SV_blank>head=%d,<S2SV_blank>ret=%d\" , ctx -> token . len , ctx -> head , ctx -> ret ) ; return ctx -> ret ; }\n","target":"<S2SV_ModStart> ; if ( NGX_OK != <S2SV_ModEnd> ngx_http_auth_spnego_basic ( r\n","project_and_commit_id":"stnoonan@spnego-http-auth-nginx-module/a06f9efca373e25328b1c53639a48decd0854570","cve_id":"CVE-2021-21335","original_address":"https://github.com/stnoonan/spnego-http-auth-nginx-module/commit/a06f9efca373e25328b1c53639a48decd0854570","time":"2021-03-08T21:15Z"},
	{"Unnamed: 0":1498,"cwe_id":"CWE-119","source":"CWE-119 static void scsi_read_data ( SCSIRequest * req ) { SCSIDiskReq * r = DO_UPCAST ( SCSIDiskReq , req , req ) ; SCSIDiskState * s = DO_UPCAST ( SCSIDiskState , qdev , r -> req . dev ) ; uint32_t n ; if ( r -> sector_count == ( uint32_t ) - 1 ) { DPRINTF ( \"Read<S2SV_blank>buf_len=%zd\\\\n\" , r -> iov . iov_len ) ; r -> sector_count = 0 ; scsi_req_data ( & r -> req , r -> iov . iov_len ) ; return ; } DPRINTF ( \"Read<S2SV_blank>sector_count=%d\\\\n\" , r -> sector_count ) ; if ( r -> sector_count == 0 ) { scsi_req_complete ( & r -> req , GOOD ) ; return ; } assert ( r -> req . aiocb == NULL ) ; if ( r -> req . cmd . mode == SCSI_XFER_TO_DEV ) { DPRINTF ( \"Data<S2SV_blank>transfer<S2SV_blank>direction<S2SV_blank>invalid\\\\n\" ) ; scsi_read_complete ( r , - EINVAL ) ; return ; } <S2SV_StartBug> n = r -> sector_count ; <S2SV_EndBug> if ( n > SCSI_DMA_BUF_SIZE / 512 ) n = SCSI_DMA_BUF_SIZE / 512 ; if ( s -> tray_open ) { scsi_read_complete ( r , - ENOMEDIUM ) ; } <S2SV_StartBug> r -> iov . iov_len = n * 512 ; <S2SV_EndBug> <S2SV_StartBug> qemu_iovec_init_external ( & r -> qiov , & r -> iov , 1 ) ; <S2SV_EndBug> bdrv_acct_start ( s -> bs , & r -> acct , n * BDRV_SECTOR_SIZE , BDRV_ACCT_READ ) ; <S2SV_StartBug> r -> req . aiocb = bdrv_aio_readv ( s -> bs , r -> sector , & r -> qiov , n , <S2SV_EndBug> scsi_read_complete , r ) ; if ( r -> req . aiocb == NULL ) { scsi_read_complete ( r , - EIO ) ; } }\n","target":"<S2SV_ModStart> return ; } <S2SV_ModEnd> if ( s <S2SV_ModStart> ) ; } n = scsi_init_iovec ( r ) ; bdrv_acct_start ( s -> bs , & r -> acct , n * BDRV_SECTOR_SIZE , BDRV_ACCT_READ ) ; r -> req . aiocb = bdrv_aio_readv ( s -> bs , r -> sector , <S2SV_ModEnd> & r -> <S2SV_ModStart> -> qiov , n , scsi_read_complete , r ) ; if ( <S2SV_ModEnd> r -> req <S2SV_ModStart> req . aiocb <S2SV_ModEnd> == NULL )\n","project_and_commit_id":"bonzini@qemu/103b40f51e4012b3b0ad20f615562a1806d7f49a","cve_id":"CVE-2011-3346","original_address":"https://github.com/bonzini/qemu/commit/103b40f51e4012b3b0ad20f615562a1806d7f49a","time":"2014-04-01T06:35Z"},
	{"Unnamed: 0":2186,"cwe_id":"CWE-200","source":"CWE-200 static int caif_seqpkt_recvmsg ( struct kiocb * iocb , struct socket * sock , struct msghdr * m , size_t len , int flags ) { struct sock * sk = sock -> sk ; struct sk_buff * skb ; int ret ; int copylen ; ret = - EOPNOTSUPP ; if ( m -> msg_flags & MSG_OOB ) goto read_error ; <S2SV_StartBug> skb = skb_recv_datagram ( sk , flags , 0 , & ret ) ; <S2SV_EndBug> if ( ! skb ) goto read_error ; copylen = skb -> len ; if ( len < copylen ) { m -> msg_flags |= MSG_TRUNC ; copylen = len ; } ret = skb_copy_datagram_iovec ( skb , 0 , m -> msg_iov , copylen ) ; if ( ret ) goto out_free ; ret = ( flags & MSG_TRUNC ) ? skb -> len : copylen ; out_free : skb_free_datagram ( sk , skb ) ; caif_check_flow_release ( sk ) ; return ret ; read_error : return ret ; }\n","target":"<S2SV_ModStart> goto read_error ; m -> msg_namelen = 0 ;\n","project_and_commit_id":"torvalds@linux/2d6fbfe733f35c6b355c216644e08e149c61b271","cve_id":"CVE-2013-3227","original_address":"https://github.com/torvalds/linux/commit/2d6fbfe733f35c6b355c216644e08e149c61b271","time":"2013-04-22T11:41Z"},
	{"Unnamed: 0":1661,"cwe_id":"CWE-20","source":"CWE-20 void beforeSleep ( struct aeEventLoop * eventLoop ) { REDIS_NOTUSED ( eventLoop ) ; listNode * ln ; redisClient * c ; <S2SV_StartBug> if ( server . vm_enabled && listLength ( server . io_ready_clients ) ) { <S2SV_EndBug> listIter li ; listRewind ( server . io_ready_clients , & li ) ; while ( ( ln = listNext ( & li ) ) ) { c = ln -> value ; struct redisCommand * cmd ; listDelNode ( server . io_ready_clients , ln ) ; c -> flags &= ( ~ REDIS_IO_WAIT ) ; <S2SV_StartBug> server . vm_blocked_clients -- ; <S2SV_EndBug> aeCreateFileEvent ( server . el , c -> fd , AE_READABLE , readQueryFromClient , c ) ; cmd = lookupCommand ( c -> argv [ 0 ] -> ptr ) ; redisAssert ( cmd != NULL ) ; call ( c , cmd ) ; resetClient ( c ) ; if ( c -> querybuf && sdslen ( c -> querybuf ) > 0 ) processInputBuffer ( c ) ; } } while ( listLength ( server . unblocked_clients ) ) { ln = listFirst ( server . unblocked_clients ) ; redisAssert ( ln != NULL ) ; c = ln -> value ; listDelNode ( server . unblocked_clients , ln ) ; if ( c -> querybuf && sdslen ( c -> querybuf ) > 0 ) processInputBuffer ( c ) ; } flushAppendOnlyFile ( ) ; }\n","target":"<S2SV_ModStart> ( server . ds_enabled <S2SV_ModEnd> && listLength ( <S2SV_ModStart> ; server . cache_blocked_clients <S2SV_ModEnd> -- ; aeCreateFileEvent\n","project_and_commit_id":"antirez@redis/697af434fbeb2e3ba2ba9687cd283ed1a2734fa5","cve_id":"CVE-2013-0178","original_address":"https://github.com/antirez/redis/commit/697af434fbeb2e3ba2ba9687cd283ed1a2734fa5","time":"2019-11-01T19:15Z"},
	{"Unnamed: 0":4203,"cwe_id":"CWE-190","source":"CWE-190 static int read_SubStreamsInfo ( struct archive_read * a , struct _7z_substream_info * ss , struct _7z_folder * f , size_t numFolders ) { const unsigned char * p ; uint64_t * usizes ; size_t unpack_streams ; int type ; unsigned i ; uint32_t numDigests ; memset ( ss , 0 , sizeof ( * ss ) ) ; for ( i = 0 ; i < numFolders ; i ++ ) f [ i ] . numUnpackStreams = 1 ; if ( ( p = header_bytes ( a , 1 ) ) == NULL ) return ( - 1 ) ; type = * p ; if ( type == kNumUnPackStream ) { unpack_streams = 0 ; for ( i = 0 ; i < numFolders ; i ++ ) { if ( parse_7zip_uint64 ( a , & ( f [ i ] . numUnpackStreams ) ) < 0 ) return ( - 1 ) ; if ( UMAX_ENTRY < f [ i ] . numUnpackStreams ) return ( - 1 ) ; <S2SV_StartBug> unpack_streams += ( size_t ) f [ i ] . numUnpackStreams ; <S2SV_EndBug> } if ( ( p = header_bytes ( a , 1 ) ) == NULL ) return ( - 1 ) ; type = * p ; } else unpack_streams = numFolders ; ss -> unpack_streams = unpack_streams ; if ( unpack_streams ) { ss -> unpackSizes = calloc ( unpack_streams , sizeof ( * ss -> unpackSizes ) ) ; ss -> digestsDefined = calloc ( unpack_streams , sizeof ( * ss -> digestsDefined ) ) ; ss -> digests = calloc ( unpack_streams , sizeof ( * ss -> digests ) ) ; if ( ss -> unpackSizes == NULL || ss -> digestsDefined == NULL || ss -> digests == NULL ) return ( - 1 ) ; } usizes = ss -> unpackSizes ; for ( i = 0 ; i < numFolders ; i ++ ) { unsigned pack ; uint64_t sum ; if ( f [ i ] . numUnpackStreams == 0 ) continue ; sum = 0 ; if ( type == kSize ) { for ( pack = 1 ; pack < f [ i ] . numUnpackStreams ; pack ++ ) { if ( parse_7zip_uint64 ( a , usizes ) < 0 ) return ( - 1 ) ; sum += * usizes ++ ; } } * usizes ++ = folder_uncompressed_size ( & f [ i ] ) - sum ; } if ( type == kSize ) { if ( ( p = header_bytes ( a , 1 ) ) == NULL ) return ( - 1 ) ; type = * p ; } for ( i = 0 ; i < unpack_streams ; i ++ ) { ss -> digestsDefined [ i ] = 0 ; ss -> digests [ i ] = 0 ; } numDigests = 0 ; for ( i = 0 ; i < numFolders ; i ++ ) { if ( f [ i ] . numUnpackStreams != 1 || ! f [ i ] . digest_defined ) numDigests += ( uint32_t ) f [ i ] . numUnpackStreams ; } if ( type == kCRC ) { struct _7z_digests tmpDigests ; unsigned char * digestsDefined = ss -> digestsDefined ; uint32_t * digests = ss -> digests ; int di = 0 ; memset ( & tmpDigests , 0 , sizeof ( tmpDigests ) ) ; if ( read_Digests ( a , & ( tmpDigests ) , numDigests ) < 0 ) { free_Digest ( & tmpDigests ) ; return ( - 1 ) ; } for ( i = 0 ; i < numFolders ; i ++ ) { if ( f [ i ] . numUnpackStreams == 1 && f [ i ] . digest_defined ) { * digestsDefined ++ = 1 ; * digests ++ = f [ i ] . digest ; } else { unsigned j ; for ( j = 0 ; j < f [ i ] . numUnpackStreams ; j ++ , di ++ ) { * digestsDefined ++ = tmpDigests . defineds [ di ] ; * digests ++ = tmpDigests . digests [ di ] ; } } } free_Digest ( & tmpDigests ) ; if ( ( p = header_bytes ( a , 1 ) ) == NULL ) return ( - 1 ) ; type = * p ; } if ( type != kEnd ) return ( - 1 ) ; return ( 0 ) ; }\n","target":"<S2SV_ModStart> 1 ) ; if ( unpack_streams > SIZE_MAX - UMAX_ENTRY ) { return ( - 1 ) ; }\n","project_and_commit_id":"libarchive@libarchive/e79ef306afe332faf22e9b442a2c6b59cb175573","cve_id":"CVE-2016-4300","original_address":"https://github.com/libarchive/libarchive/commit/e79ef306afe332faf22e9b442a2c6b59cb175573","time":"2016-09-21T14:25Z"},
	{"Unnamed: 0":2146,"cwe_id":"CWE-000","source":"CWE-000 void hostap_setup_dev ( struct net_device * dev , local_info_t * local , int type ) { struct hostap_interface * iface ; iface = netdev_priv ( dev ) ; <S2SV_StartBug> ether_setup ( dev ) ; <S2SV_EndBug> if ( iface ) { iface -> wireless_data . spy_data = & iface -> spy_data ; dev -> wireless_data = & iface -> wireless_data ; } dev -> wireless_handlers = & hostap_iw_handler_def ; dev -> watchdog_timeo = TX_TIMEOUT ; switch ( type ) { case HOSTAP_INTERFACE_AP : dev -> tx_queue_len = 0 ; dev -> netdev_ops = & hostap_mgmt_netdev_ops ; dev -> type = ARPHRD_IEEE80211 ; dev -> header_ops = & hostap_80211_ops ; break ; case HOSTAP_INTERFACE_MASTER : dev -> netdev_ops = & hostap_master_ops ; break ; default : dev -> tx_queue_len = 0 ; dev -> netdev_ops = & hostap_netdev_ops ; } dev -> mtu = local -> mtu ; SET_ETHTOOL_OPS ( dev , & prism2_ethtool_ops ) ; }\n","target":"<S2SV_ModStart> ( dev ) ; dev -> priv_flags &= ~ IFF_TX_SKB_SHARING\n","project_and_commit_id":"torvalds@linux/550fd08c2cebad61c548def135f67aba284c6162","cve_id":"CVE-2011-4112","original_address":"https://github.com/torvalds/linux/commit/550fd08c2cebad61c548def135f67aba284c6162","time":"2012-05-17T11:00Z"},
	{"Unnamed: 0":3692,"cwe_id":"CWE-119","source":"CWE-119 static void optimize_mb ( MACROBLOCK * x ) { int b ; int type ; int has_2nd_order ; ENTROPY_CONTEXT_PLANES t_above , t_left ; ENTROPY_CONTEXT * ta ; ENTROPY_CONTEXT * tl ; <S2SV_StartBug> vpx_memcpy ( & t_above , x -> e_mbd . above_context , sizeof ( ENTROPY_CONTEXT_PLANES ) ) ; <S2SV_EndBug> <S2SV_StartBug> vpx_memcpy ( & t_left , x -> e_mbd . left_context , sizeof ( ENTROPY_CONTEXT_PLANES ) ) ; <S2SV_EndBug> ta = ( ENTROPY_CONTEXT * ) & t_above ; tl = ( ENTROPY_CONTEXT * ) & t_left ; has_2nd_order = ( x -> e_mbd . mode_info_context -> mbmi . mode != B_PRED && x -> e_mbd . mode_info_context -> mbmi . mode != SPLITMV ) ; type = has_2nd_order ? PLANE_TYPE_Y_NO_DC : PLANE_TYPE_Y_WITH_DC ; for ( b = 0 ; b < 16 ; b ++ ) { optimize_b ( x , b , type , ta + vp8_block2above [ b ] , tl + vp8_block2left [ b ] ) ; } for ( b = 16 ; b < 24 ; b ++ ) { optimize_b ( x , b , PLANE_TYPE_UV , ta + vp8_block2above [ b ] , tl + vp8_block2left [ b ] ) ; } if ( has_2nd_order ) { b = 24 ; optimize_b ( x , b , PLANE_TYPE_Y2 , ta + vp8_block2above [ b ] , tl + vp8_block2left [ b ] ) ; check_reset_2nd_coeffs ( & x -> e_mbd , PLANE_TYPE_Y2 , ta + vp8_block2above [ b ] , tl + vp8_block2left [ b ] ) ; } }\n","target":"<S2SV_ModStart> * tl ; memcpy <S2SV_ModEnd> ( & t_above <S2SV_ModStart> ) ) ; memcpy <S2SV_ModEnd> ( & t_left\n","project_and_commit_id":"external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426","cve_id":"CVE-2016-1621","original_address":"https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426","time":"2016-03-12T21:59Z"},
	{"Unnamed: 0":6165,"cwe_id":"CWE-416","source":"CWE-416 SYSCALL_DEFINE2 ( timerfd_create , int , clockid , int , flags ) { int ufd ; struct timerfd_ctx * ctx ; BUILD_BUG_ON ( TFD_CLOEXEC != O_CLOEXEC ) ; BUILD_BUG_ON ( TFD_NONBLOCK != O_NONBLOCK ) ; if ( ( flags & ~ TFD_CREATE_FLAGS ) || ( clockid != CLOCK_MONOTONIC && clockid != CLOCK_REALTIME && clockid != CLOCK_REALTIME_ALARM && clockid != CLOCK_BOOTTIME && clockid != CLOCK_BOOTTIME_ALARM ) ) return - EINVAL ; if ( ! capable ( CAP_WAKE_ALARM ) && ( clockid == CLOCK_REALTIME_ALARM || clockid == CLOCK_BOOTTIME_ALARM ) ) return - EPERM ; ctx = kzalloc ( sizeof ( * ctx ) , GFP_KERNEL ) ; if ( ! ctx ) return - ENOMEM ; init_waitqueue_head ( & ctx -> wqh ) ; <S2SV_StartBug> ctx -> clockid = clockid ; <S2SV_EndBug> if ( isalarm ( ctx ) ) alarm_init ( & ctx -> t . alarm , ctx -> clockid == CLOCK_REALTIME_ALARM ? ALARM_REALTIME : ALARM_BOOTTIME , timerfd_alarmproc ) ; else hrtimer_init ( & ctx -> t . tmr , clockid , HRTIMER_MODE_ABS ) ; ctx -> moffs = ktime_mono_to_real ( 0 ) ; ufd = anon_inode_getfd ( \"[timerfd]\" , & timerfd_fops , ctx , O_RDWR | ( flags & TFD_SHARED_FCNTL_FLAGS ) ) ; if ( ufd < 0 ) kfree ( ctx ) ; return ufd ; }\n","target":"<S2SV_ModStart> wqh ) ; spin_lock_init ( & ctx -> cancel_lock ) ;\n","project_and_commit_id":"torvalds@linux/1e38da300e1e395a15048b0af1e5305bd91402f6","cve_id":"CVE-2017-10661","original_address":"https://github.com/torvalds/linux/commit/1e38da300e1e395a15048b0af1e5305bd91402f6","time":"2017-08-19T18:29Z"},
	{"Unnamed: 0":5708,"cwe_id":"CWE-119","source":"CWE-119 static void write_image_file ( const vpx_image_t * img , const int planes [ 3 ] , FILE * file ) { <S2SV_StartBug> int i , y ; <S2SV_EndBug> for ( i = 0 ; i < 3 ; ++ i ) { const int plane = planes [ i ] ; const unsigned char * buf = img -> planes [ plane ] ; const int stride = img -> stride [ plane ] ; const int w = vpx_img_plane_width ( img , plane ) ; const int h = vpx_img_plane_height ( img , plane ) ; for ( y = 0 ; y < h ; ++ y ) { <S2SV_StartBug> fwrite ( buf , 1 , w , file ) ; <S2SV_EndBug> buf += stride ; } } }\n","target":"<S2SV_ModStart> , y ; # if CONFIG_VP9_HIGHBITDEPTH const int bytes_per_sample = ( ( img -> fmt & VPX_IMG_FMT_HIGHBITDEPTH ) ? 2 : 1 ) ; # else const int bytes_per_sample = 1 ; # endif <S2SV_ModStart> ( buf , bytes_per_sample <S2SV_ModEnd> , w ,\n","project_and_commit_id":"external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426","cve_id":"CVE-2016-1621","original_address":"https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426","time":"2016-03-12T21:59Z"},
	{"Unnamed: 0":3773,"cwe_id":"CWE-264","source":"CWE-264 STATIC int xfs_ioctl_setattr ( xfs_inode_t * ip , struct fsxattr * fa , int mask ) { struct xfs_mount * mp = ip -> i_mount ; struct xfs_trans * tp ; unsigned int lock_flags = 0 ; struct xfs_dquot * udqp = NULL ; struct xfs_dquot * pdqp = NULL ; struct xfs_dquot * olddquot = NULL ; int code ; trace_xfs_ioctl_setattr ( ip ) ; if ( mp -> m_flags & XFS_MOUNT_RDONLY ) return XFS_ERROR ( EROFS ) ; if ( XFS_FORCED_SHUTDOWN ( mp ) ) return XFS_ERROR ( EIO ) ; if ( ( mask & FSX_PROJID ) && ( fa -> fsx_projid > ( __uint16_t ) - 1 ) && ! xfs_sb_version_hasprojid32bit ( & ip -> i_mount -> m_sb ) ) return XFS_ERROR ( EINVAL ) ; if ( XFS_IS_QUOTA_ON ( mp ) && ( mask & FSX_PROJID ) ) { code = xfs_qm_vop_dqalloc ( ip , ip -> i_d . di_uid , ip -> i_d . di_gid , fa -> fsx_projid , XFS_QMOPT_PQUOTA , & udqp , NULL , & pdqp ) ; if ( code ) return code ; } tp = xfs_trans_alloc ( mp , XFS_TRANS_SETATTR_NOT_SIZE ) ; code = xfs_trans_reserve ( tp , & M_RES ( mp ) -> tr_ichange , 0 , 0 ) ; if ( code ) goto error_return ; lock_flags = XFS_ILOCK_EXCL ; xfs_ilock ( ip , lock_flags ) ; if ( ! inode_owner_or_capable ( VFS_I ( ip ) ) ) { code = XFS_ERROR ( EPERM ) ; goto error_return ; } if ( mask & FSX_PROJID ) { if ( current_user_ns ( ) != & init_user_ns ) { code = XFS_ERROR ( EINVAL ) ; goto error_return ; } if ( XFS_IS_QUOTA_RUNNING ( mp ) && XFS_IS_PQUOTA_ON ( mp ) && xfs_get_projid ( ip ) != fa -> fsx_projid ) { ASSERT ( tp ) ; code = xfs_qm_vop_chown_reserve ( tp , ip , udqp , NULL , pdqp , capable ( CAP_FOWNER ) ? XFS_QMOPT_FORCE_RES : 0 ) ; if ( code ) goto error_return ; } } if ( mask & FSX_EXTSIZE ) { if ( ip -> i_d . di_nextents && ( ( ip -> i_d . di_extsize << mp -> m_sb . sb_blocklog ) != fa -> fsx_extsize ) ) { code = XFS_ERROR ( EINVAL ) ; goto error_return ; } if ( fa -> fsx_extsize != 0 ) { xfs_extlen_t size ; xfs_fsblock_t extsize_fsb ; extsize_fsb = XFS_B_TO_FSB ( mp , fa -> fsx_extsize ) ; if ( extsize_fsb > MAXEXTLEN ) { code = XFS_ERROR ( EINVAL ) ; goto error_return ; } if ( XFS_IS_REALTIME_INODE ( ip ) || ( ( mask & FSX_XFLAGS ) && ( fa -> fsx_xflags & XFS_XFLAG_REALTIME ) ) ) { size = mp -> m_sb . sb_rextsize << mp -> m_sb . sb_blocklog ; } else { size = mp -> m_sb . sb_blocksize ; if ( extsize_fsb > mp -> m_sb . sb_agblocks / 2 ) { code = XFS_ERROR ( EINVAL ) ; goto error_return ; } } if ( fa -> fsx_extsize % size ) { code = XFS_ERROR ( EINVAL ) ; goto error_return ; } } } if ( mask & FSX_XFLAGS ) { if ( ( ip -> i_d . di_nextents || ip -> i_delayed_blks ) && ( XFS_IS_REALTIME_INODE ( ip ) ) != ( fa -> fsx_xflags & XFS_XFLAG_REALTIME ) ) { code = XFS_ERROR ( EINVAL ) ; goto error_return ; } if ( ( fa -> fsx_xflags & XFS_XFLAG_REALTIME ) ) { if ( ( mp -> m_sb . sb_rblocks == 0 ) || ( mp -> m_sb . sb_rextsize == 0 ) || ( ip -> i_d . di_extsize % mp -> m_sb . sb_rextsize ) ) { code = XFS_ERROR ( EINVAL ) ; goto error_return ; } } if ( ( ip -> i_d . di_flags & ( XFS_DIFLAG_IMMUTABLE | XFS_DIFLAG_APPEND ) || ( fa -> fsx_xflags & ( XFS_XFLAG_IMMUTABLE | XFS_XFLAG_APPEND ) ) ) && ! capable ( CAP_LINUX_IMMUTABLE ) ) { code = XFS_ERROR ( EPERM ) ; goto error_return ; } } xfs_trans_ijoin ( tp , ip , 0 ) ; if ( mask & FSX_PROJID ) { if ( ( ip -> i_d . di_mode & ( S_ISUID | S_ISGID ) ) && <S2SV_StartBug> ! inode_capable ( VFS_I ( ip ) , CAP_FSETID ) ) <S2SV_EndBug> ip -> i_d . di_mode &= ~ ( S_ISUID | S_ISGID ) ; if ( xfs_get_projid ( ip ) != fa -> fsx_projid ) { if ( XFS_IS_QUOTA_RUNNING ( mp ) && XFS_IS_PQUOTA_ON ( mp ) ) { olddquot = xfs_qm_vop_chown ( tp , ip , & ip -> i_pdquot , pdqp ) ; } xfs_set_projid ( ip , fa -> fsx_projid ) ; if ( ip -> i_d . di_version == 1 ) xfs_bump_ino_vers2 ( tp , ip ) ; } } if ( mask & FSX_EXTSIZE ) ip -> i_d . di_extsize = fa -> fsx_extsize >> mp -> m_sb . sb_blocklog ; if ( mask & FSX_XFLAGS ) { xfs_set_diflags ( ip , fa -> fsx_xflags ) ; xfs_diflags_to_linux ( ip ) ; } xfs_trans_ichgtime ( tp , ip , XFS_ICHGTIME_CHG ) ; xfs_trans_log_inode ( tp , ip , XFS_ILOG_CORE ) ; XFS_STATS_INC ( xs_ig_attrchg ) ; if ( mp -> m_flags & XFS_MOUNT_WSYNC ) xfs_trans_set_sync ( tp ) ; code = xfs_trans_commit ( tp , 0 ) ; xfs_iunlock ( ip , lock_flags ) ; xfs_qm_dqrele ( olddquot ) ; xfs_qm_dqrele ( udqp ) ; xfs_qm_dqrele ( pdqp ) ; return code ; error_return : xfs_qm_dqrele ( udqp ) ; xfs_qm_dqrele ( pdqp ) ; xfs_trans_cancel ( tp , 0 ) ; if ( lock_flags ) xfs_iunlock ( ip , lock_flags ) ; return code ; }\n","target":"<S2SV_ModStart> ) && ! capable_wrt_inode_uidgid <S2SV_ModEnd> ( VFS_I (\n","project_and_commit_id":"torvalds@linux/23adbe12ef7d3d4195e80800ab36b37bee28cd03","cve_id":"CVE-2014-4014","original_address":"https://github.com/torvalds/linux/commit/23adbe12ef7d3d4195e80800ab36b37bee28cd03","time":"2014-06-23T11:21Z"},
	{"Unnamed: 0":5384,"cwe_id":"CWE-119","source":"CWE-119 struct lookahead_ctx * vp9_lookahead_init ( unsigned int width , unsigned int height , unsigned int subsampling_x , unsigned int subsampling_y , <S2SV_StartBug> unsigned int depth ) { <S2SV_EndBug> struct lookahead_ctx * ctx = NULL ; depth = clamp ( depth , 1 , MAX_LAG_BUFFERS ) ; depth += MAX_PRE_FRAMES ; ctx = calloc ( 1 , sizeof ( * ctx ) ) ; if ( ctx ) { <S2SV_StartBug> unsigned int i ; <S2SV_EndBug> ctx -> max_sz = depth ; ctx -> buf = calloc ( depth , sizeof ( * ctx -> buf ) ) ; if ( ! ctx -> buf ) goto bail ; for ( i = 0 ; i < depth ; i ++ ) <S2SV_StartBug> if ( vp9_alloc_frame_buffer ( & ctx -> buf [ i ] . img , <S2SV_EndBug> width , height , subsampling_x , subsampling_y , <S2SV_StartBug> VP9_ENC_BORDER_IN_PIXELS ) ) <S2SV_EndBug> goto bail ; } return ctx ; bail : vp9_lookahead_destroy ( ctx ) ; return NULL ; }\n","target":"<S2SV_ModStart> int subsampling_y , # if CONFIG_VP9_HIGHBITDEPTH int use_highbitdepth , # endif <S2SV_ModStart> ctx ) { const int legacy_byte_alignment = 0 ; <S2SV_ModStart> ) if ( vpx_alloc_frame_buffer <S2SV_ModEnd> ( & ctx <S2SV_ModStart> , subsampling_y , # if CONFIG_VP9_HIGHBITDEPTH use_highbitdepth , # endif VP9_ENC_BORDER_IN_PIXELS , legacy_byte_alignment <S2SV_ModEnd> ) ) goto\n","project_and_commit_id":"external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426","cve_id":"CVE-2016-1621","original_address":"https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426","time":"2016-03-12T21:59Z"},
	{"Unnamed: 0":4725,"cwe_id":"CWE-20","source":"CWE-20 WORD32 ih264d_read_mmco_commands ( struct _DecStruct * ps_dec ) { dec_bit_stream_t * ps_bitstrm = ps_dec -> ps_bitstrm ; <S2SV_StartBug> dpb_commands_t * ps_dpb_cmds = ps_dec -> ps_dpb_cmds ; <S2SV_EndBug> dec_slice_params_t * ps_slice = ps_dec -> ps_cur_slice ; WORD32 j ; UWORD8 u1_buf_mode ; struct MMCParams * ps_mmc_params ; UWORD32 * pu4_bitstrm_buf = ps_dec -> ps_bitstrm -> pu4_buffer ; UWORD32 * pu4_bitstrm_ofst = & ps_bitstrm -> u4_ofst ; UWORD32 u4_bit_ofst = ps_dec -> ps_bitstrm -> u4_ofst ; ps_slice -> u1_mmco_equalto5 = 0 ; { if ( ps_dec -> u1_nal_unit_type == IDR_SLICE_NAL ) { ps_slice -> u1_no_output_of_prior_pics_flag = ih264d_get_bit_h264 ( ps_bitstrm ) ; COPYTHECONTEXT ( \"SH:<S2SV_blank>no_output_of_prior_pics_flag\" , ps_slice -> u1_no_output_of_prior_pics_flag ) ; ps_slice -> u1_long_term_reference_flag = ih264d_get_bit_h264 ( ps_bitstrm ) ; COPYTHECONTEXT ( \"SH:<S2SV_blank>long_term_reference_flag\" , ps_slice -> u1_long_term_reference_flag ) ; ps_dpb_cmds -> u1_idr_pic = 1 ; ps_dpb_cmds -> u1_no_output_of_prior_pics_flag = ps_slice -> u1_no_output_of_prior_pics_flag ; ps_dpb_cmds -> u1_long_term_reference_flag = ps_slice -> u1_long_term_reference_flag ; } else { u1_buf_mode = ih264d_get_bit_h264 ( ps_bitstrm ) ; COPYTHECONTEXT ( \"SH:<S2SV_blank>adaptive_ref_pic_buffering_flag\" , u1_buf_mode ) ; ps_dpb_cmds -> u1_buf_mode = u1_buf_mode ; j = 0 ; if ( u1_buf_mode == 1 ) { UWORD32 u4_mmco ; UWORD32 u4_diff_pic_num ; UWORD32 u4_lt_idx , u4_max_lt_idx ; u4_mmco = ih264d_uev ( pu4_bitstrm_ofst , pu4_bitstrm_buf ) ; while ( u4_mmco != END_OF_MMCO ) { if ( j >= MAX_REF_BUFS ) { # ifdef __ANDROID__ ALOGE ( \"b/25818142\" ) ; android_errorWriteLog ( 0x534e4554 , \"25818142\" ) ; # endif ps_dpb_cmds -> u1_num_of_commands = 0 ; return - 1 ; } ps_mmc_params = & ps_dpb_cmds -> as_mmc_params [ j ] ; ps_mmc_params -> u4_mmco = u4_mmco ; switch ( u4_mmco ) { case MARK_ST_PICNUM_AS_NONREF : u4_diff_pic_num = ih264d_uev ( pu4_bitstrm_ofst , pu4_bitstrm_buf ) ; ps_mmc_params -> u4_diff_pic_num = u4_diff_pic_num ; break ; case MARK_LT_INDEX_AS_NONREF : u4_lt_idx = ih264d_uev ( pu4_bitstrm_ofst , pu4_bitstrm_buf ) ; ps_mmc_params -> u4_lt_idx = u4_lt_idx ; break ; case MARK_ST_PICNUM_AS_LT_INDEX : u4_diff_pic_num = ih264d_uev ( pu4_bitstrm_ofst , pu4_bitstrm_buf ) ; ps_mmc_params -> u4_diff_pic_num = u4_diff_pic_num ; u4_lt_idx = ih264d_uev ( pu4_bitstrm_ofst , pu4_bitstrm_buf ) ; ps_mmc_params -> u4_lt_idx = u4_lt_idx ; break ; case SET_MAX_LT_INDEX : { u4_max_lt_idx = ih264d_uev ( pu4_bitstrm_ofst , pu4_bitstrm_buf ) ; ps_mmc_params -> u4_max_lt_idx_plus1 = u4_max_lt_idx ; break ; } case RESET_REF_PICTURES : { ps_slice -> u1_mmco_equalto5 = 1 ; break ; } case SET_LT_INDEX : u4_lt_idx = ih264d_uev ( pu4_bitstrm_ofst , pu4_bitstrm_buf ) ; ps_mmc_params -> u4_lt_idx = u4_lt_idx ; break ; default : break ; } u4_mmco = ih264d_uev ( pu4_bitstrm_ofst , pu4_bitstrm_buf ) ; j ++ ; } ps_dpb_cmds -> u1_num_of_commands = j ; } } ps_dpb_cmds -> u1_dpb_commands_read = 1 ; ps_dpb_cmds -> u1_dpb_commands_read_slc = 1 ; } u4_bit_ofst = ps_dec -> ps_bitstrm -> u4_ofst - u4_bit_ofst ; return u4_bit_ofst ; }\n","target":"<S2SV_ModStart> * ps_dpb_cmds = & ( ps_dec -> s_dpb_cmds_scratch ) <S2SV_ModEnd> ; dec_slice_params_t *\n","project_and_commit_id":"external@libavc/6c327afb263837bc90760c55c6605b26161a4eb9","cve_id":"CVE-2017-13186","original_address":"https://android.googlesource.com/platform/external/libavc/+/6c327afb263837bc90760c55c6605b26161a4eb9","time":"2018-01-12T23:29Z"},
	{"Unnamed: 0":1163,"cwe_id":"CWE-120","source":"CWE-120 static void handle_PORT ( ctrl_t * ctrl , char * str ) { int a , b , c , d , e , f ; char addr [ INET_ADDRSTRLEN ] ; struct sockaddr_in sin ; if ( ctrl -> data_sd > 0 ) { uev_io_stop ( & ctrl -> data_watcher ) ; close ( ctrl -> data_sd ) ; ctrl -> data_sd = - 1 ; } sscanf ( str , \"%d,%d,%d,%d,%d,%d\" , & a , & b , & c , & d , & e , & f ) ; <S2SV_StartBug> sprintf ( addr , \"%d.%d.%d.%d\" , a , b , c , d ) ; <S2SV_EndBug> if ( ! inet_aton ( addr , & ( sin . sin_addr ) ) ) { ERR ( 0 , \"Invalid<S2SV_blank>address<S2SV_blank>\\'%s\\'<S2SV_blank>given<S2SV_blank>to<S2SV_blank>PORT<S2SV_blank>command\" , addr ) ; send_msg ( ctrl -> sd , \"500<S2SV_blank>Illegal<S2SV_blank>PORT<S2SV_blank>command.\\\\r\\\\n\" ) ; return ; } strlcpy ( ctrl -> data_address , addr , sizeof ( ctrl -> data_address ) ) ; ctrl -> data_port = e * 256 + f ; DBG ( \"Client<S2SV_blank>PORT<S2SV_blank>command<S2SV_blank>accepted<S2SV_blank>for<S2SV_blank>%s:%d\" , ctrl -> data_address , ctrl -> data_port ) ; send_msg ( ctrl -> sd , \"200<S2SV_blank>PORT<S2SV_blank>command<S2SV_blank>successful.\\\\r\\\\n\" ) ; }\n","target":"<S2SV_ModStart> f ) ; snprintf ( addr , sizeof ( addr ) <S2SV_ModEnd> , \"%d.%d.%d.%d\" ,\n","project_and_commit_id":"troglobit@uftpd/0fb2c031ce0ace07cc19cd2cb2143c4b5a63c9dd","cve_id":"CVE-2020-5204","original_address":"https://github.com/troglobit/uftpd/commit/0fb2c031ce0ace07cc19cd2cb2143c4b5a63c9dd","time":"2020-01-06T20:15Z"},
	{"Unnamed: 0":5218,"cwe_id":"CWE-189","source":"CWE-189 static int adjust_scalar_min_max_vals ( struct bpf_verifier_env * env , struct bpf_insn * insn , struct bpf_reg_state * dst_reg , struct bpf_reg_state src_reg ) { struct bpf_reg_state * regs = cur_regs ( env ) ; u8 opcode = BPF_OP ( insn -> code ) ; bool src_known , dst_known ; s64 smin_val , smax_val ; u64 umin_val , umax_val ; <S2SV_StartBug> u64 insn_bitness = ( BPF_CLASS ( insn -> code ) == BPF_ALU64 ) ? 64 : 32 ; <S2SV_EndBug> if ( insn_bitness == 32 ) { coerce_reg_to_size ( dst_reg , 4 ) ; coerce_reg_to_size ( & src_reg , 4 ) ; } smin_val = src_reg . smin_value ; smax_val = src_reg . smax_value ; umin_val = src_reg . umin_value ; umax_val = src_reg . umax_value ; src_known = tnum_is_const ( src_reg . var_off ) ; dst_known = tnum_is_const ( dst_reg -> var_off ) ; if ( ( src_known && ( smin_val != smax_val || umin_val != umax_val ) ) || smin_val > smax_val || umin_val > umax_val ) { __mark_reg_unknown ( dst_reg ) ; return 0 ; } if ( ! src_known && opcode != BPF_ADD && opcode != BPF_SUB && opcode != BPF_AND ) { __mark_reg_unknown ( dst_reg ) ; return 0 ; } switch ( opcode ) { case BPF_ADD : <S2SV_StartBug> if ( signed_add_overflows ( dst_reg -> smin_value , smin_val ) || <S2SV_EndBug> signed_add_overflows ( dst_reg -> smax_value , smax_val ) ) { dst_reg -> smin_value = S64_MIN ; dst_reg -> smax_value = S64_MAX ; } else { dst_reg -> smin_value += smin_val ; dst_reg -> smax_value += smax_val ; } if ( dst_reg -> umin_value + umin_val < umin_val || dst_reg -> umax_value + umax_val < umax_val ) { dst_reg -> umin_value = 0 ; dst_reg -> umax_value = U64_MAX ; } else { dst_reg -> umin_value += umin_val ; dst_reg -> umax_value += umax_val ; } dst_reg -> var_off = tnum_add ( dst_reg -> var_off , src_reg . var_off ) ; break ; case BPF_SUB : <S2SV_StartBug> if ( signed_sub_overflows ( dst_reg -> smin_value , smax_val ) || <S2SV_EndBug> signed_sub_overflows ( dst_reg -> smax_value , smin_val ) ) { dst_reg -> smin_value = S64_MIN ; dst_reg -> smax_value = S64_MAX ; } else { dst_reg -> smin_value -= smax_val ; dst_reg -> smax_value -= smin_val ; } if ( dst_reg -> umin_value < umax_val ) { dst_reg -> umin_value = 0 ; dst_reg -> umax_value = U64_MAX ; } else { dst_reg -> umin_value -= umax_val ; dst_reg -> umax_value -= umin_val ; } dst_reg -> var_off = tnum_sub ( dst_reg -> var_off , src_reg . var_off ) ; break ; case BPF_MUL : dst_reg -> var_off = tnum_mul ( dst_reg -> var_off , src_reg . var_off ) ; if ( smin_val < 0 || dst_reg -> smin_value < 0 ) { __mark_reg_unbounded ( dst_reg ) ; __update_reg_bounds ( dst_reg ) ; break ; } if ( umax_val > U32_MAX || dst_reg -> umax_value > U32_MAX ) { __mark_reg_unbounded ( dst_reg ) ; __update_reg_bounds ( dst_reg ) ; break ; } dst_reg -> umin_value *= umin_val ; dst_reg -> umax_value *= umax_val ; if ( dst_reg -> umax_value > S64_MAX ) { dst_reg -> smin_value = S64_MIN ; dst_reg -> smax_value = S64_MAX ; } else { dst_reg -> smin_value = dst_reg -> umin_value ; dst_reg -> smax_value = dst_reg -> umax_value ; } break ; case BPF_AND : if ( src_known && dst_known ) { __mark_reg_known ( dst_reg , dst_reg -> var_off . value & src_reg . var_off . value ) ; break ; } dst_reg -> var_off = tnum_and ( dst_reg -> var_off , src_reg . var_off ) ; dst_reg -> umin_value = dst_reg -> var_off . value ; dst_reg -> umax_value = min ( dst_reg -> umax_value , umax_val ) ; if ( dst_reg -> smin_value < 0 || smin_val < 0 ) { dst_reg -> smin_value = S64_MIN ; dst_reg -> smax_value = S64_MAX ; } else { dst_reg -> smin_value = dst_reg -> umin_value ; dst_reg -> smax_value = dst_reg -> umax_value ; } __update_reg_bounds ( dst_reg ) ; break ; case BPF_OR : if ( src_known && dst_known ) { __mark_reg_known ( dst_reg , dst_reg -> var_off . value | src_reg . var_off . value ) ; break ; } dst_reg -> var_off = tnum_or ( dst_reg -> var_off , src_reg . var_off ) ; dst_reg -> umin_value = max ( dst_reg -> umin_value , umin_val ) ; dst_reg -> umax_value = dst_reg -> var_off . value | dst_reg -> var_off . mask ; if ( dst_reg -> smin_value < 0 || smin_val < 0 ) { dst_reg -> smin_value = S64_MIN ; dst_reg -> smax_value = S64_MAX ; } else { dst_reg -> smin_value = dst_reg -> umin_value ; dst_reg -> smax_value = dst_reg -> umax_value ; } __update_reg_bounds ( dst_reg ) ; break ; case BPF_LSH : if ( umax_val >= insn_bitness ) { mark_reg_unknown ( env , regs , insn -> dst_reg ) ; break ; } dst_reg -> smin_value = S64_MIN ; dst_reg -> smax_value = S64_MAX ; if ( dst_reg -> umax_value > 1ULL << ( 63 - umax_val ) ) { dst_reg -> umin_value = 0 ; dst_reg -> umax_value = U64_MAX ; } else { dst_reg -> umin_value <<= umin_val ; dst_reg -> umax_value <<= umax_val ; } dst_reg -> var_off = tnum_lshift ( dst_reg -> var_off , umin_val ) ; __update_reg_bounds ( dst_reg ) ; break ; case BPF_RSH : if ( umax_val >= insn_bitness ) { mark_reg_unknown ( env , regs , insn -> dst_reg ) ; break ; } dst_reg -> smin_value = S64_MIN ; dst_reg -> smax_value = S64_MAX ; dst_reg -> var_off = tnum_rshift ( dst_reg -> var_off , umin_val ) ; dst_reg -> umin_value >>= umax_val ; dst_reg -> umax_value >>= umin_val ; __update_reg_bounds ( dst_reg ) ; break ; case BPF_ARSH : if ( umax_val >= insn_bitness ) { mark_reg_unknown ( env , regs , insn -> dst_reg ) ; break ; } dst_reg -> smin_value >>= umin_val ; dst_reg -> smax_value >>= umin_val ; dst_reg -> var_off = tnum_arshift ( dst_reg -> var_off , umin_val ) ; dst_reg -> umin_value = 0 ; dst_reg -> umax_value = U64_MAX ; __update_reg_bounds ( dst_reg ) ; break ; default : mark_reg_unknown ( env , regs , insn -> dst_reg ) ; break ; } if ( BPF_CLASS ( insn -> code ) != BPF_ALU64 ) { coerce_reg_to_size ( dst_reg , 4 ) ; } __reg_deduce_bounds ( dst_reg ) ; __reg_bound_offset ( dst_reg ) ; return 0 ; }\n","target":"<S2SV_ModStart> 64 : 32 ; u32 dst = insn -> dst_reg ; int ret <S2SV_ModStart> case BPF_ADD : ret = sanitize_val_alu ( env , insn ) ; if ( ret < 0 ) { verbose ( env , \"R%d<S2SV_blank>tried<S2SV_blank>to<S2SV_blank>add<S2SV_blank>from<S2SV_blank>different<S2SV_blank>pointers<S2SV_blank>or<S2SV_blank>scalars\\\\n\" , dst ) ; return ret ; } <S2SV_ModStart> case BPF_SUB : ret = sanitize_val_alu ( env , insn ) ; if ( ret < 0 ) { verbose ( env , \"R%d<S2SV_blank>tried<S2SV_blank>to<S2SV_blank>sub<S2SV_blank>from<S2SV_blank>different<S2SV_blank>pointers<S2SV_blank>or<S2SV_blank>scalars\\\\n\" , dst ) ; return ret ; }\n","project_and_commit_id":"torvalds@linux/d3bd7413e0ca40b60cf60d4003246d067cafdeda","cve_id":"CVE-2019-7308","original_address":"https://github.com/torvalds/linux/commit/d3bd7413e0ca40b60cf60d4003246d067cafdeda","time":"2019-02-01T22:29Z"},
	{"Unnamed: 0":6634,"cwe_id":"CWE-119","source":"CWE-119 static int tt_s2_4600_frontend_attach ( struct dvb_usb_adapter * adap ) { struct dvb_usb_device * d = adap -> dev ; <S2SV_StartBug> struct dw2102_state * state = d -> priv ; <S2SV_EndBug> u8 obuf [ 3 ] = { 0xe , 0x80 , 0 } ; u8 ibuf [ ] = { 0 } ; struct i2c_adapter * i2c_adapter ; struct i2c_client * client ; struct i2c_board_info board_info ; struct m88ds3103_platform_data m88ds3103_pdata = { } ; struct ts2020_config ts2020_config = { } ; <S2SV_StartBug> if ( dvb_usb_generic_rw ( d , obuf , 3 , ibuf , 1 , 0 ) < 0 ) <S2SV_EndBug> err ( \"command<S2SV_blank>0x0e<S2SV_blank>transfer<S2SV_blank>failed.\" ) ; <S2SV_StartBug> obuf [ 0 ] = 0xe ; <S2SV_EndBug> <S2SV_StartBug> obuf [ 1 ] = 0x02 ; <S2SV_EndBug> <S2SV_StartBug> obuf [ 2 ] = 1 ; <S2SV_EndBug> <S2SV_StartBug> if ( dvb_usb_generic_rw ( d , obuf , 3 , ibuf , 1 , 0 ) < 0 ) <S2SV_EndBug> err ( \"command<S2SV_blank>0x0e<S2SV_blank>transfer<S2SV_blank>failed.\" ) ; msleep ( 300 ) ; <S2SV_StartBug> obuf [ 0 ] = 0xe ; <S2SV_EndBug> <S2SV_StartBug> obuf [ 1 ] = 0x83 ; <S2SV_EndBug> <S2SV_StartBug> obuf [ 2 ] = 0 ; <S2SV_EndBug> <S2SV_StartBug> if ( dvb_usb_generic_rw ( d , obuf , 3 , ibuf , 1 , 0 ) < 0 ) <S2SV_EndBug> err ( \"command<S2SV_blank>0x0e<S2SV_blank>transfer<S2SV_blank>failed.\" ) ; <S2SV_StartBug> obuf [ 0 ] = 0xe ; <S2SV_EndBug> <S2SV_StartBug> obuf [ 1 ] = 0x83 ; <S2SV_EndBug> <S2SV_StartBug> obuf [ 2 ] = 1 ; <S2SV_EndBug> <S2SV_StartBug> if ( dvb_usb_generic_rw ( d , obuf , 3 , ibuf , 1 , 0 ) < 0 ) <S2SV_EndBug> err ( \"command<S2SV_blank>0x0e<S2SV_blank>transfer<S2SV_blank>failed.\" ) ; <S2SV_StartBug> obuf [ 0 ] = 0x51 ; <S2SV_EndBug> <S2SV_StartBug> if ( dvb_usb_generic_rw ( d , obuf , 1 , ibuf , 1 , 0 ) < 0 ) <S2SV_EndBug> <S2SV_StartBug> err ( \"command<S2SV_blank>0x51<S2SV_blank>transfer<S2SV_blank>failed.\" ) ; <S2SV_EndBug> m88ds3103_pdata . clk = 27000000 ; m88ds3103_pdata . i2c_wr_max = 33 ; m88ds3103_pdata . ts_mode = M88DS3103_TS_CI ; m88ds3103_pdata . ts_clk = 16000 ; m88ds3103_pdata . ts_clk_pol = 0 ; m88ds3103_pdata . spec_inv = 0 ; m88ds3103_pdata . agc = 0x99 ; m88ds3103_pdata . agc_inv = 0 ; m88ds3103_pdata . clk_out = M88DS3103_CLOCK_OUT_ENABLED ; m88ds3103_pdata . envelope_mode = 0 ; m88ds3103_pdata . lnb_hv_pol = 1 ; m88ds3103_pdata . lnb_en_pol = 0 ; memset ( & board_info , 0 , sizeof ( board_info ) ) ; strlcpy ( board_info . type , \"m88ds3103\" , I2C_NAME_SIZE ) ; board_info . addr = 0x68 ; board_info . platform_data = & m88ds3103_pdata ; request_module ( \"m88ds3103\" ) ; client = i2c_new_device ( & d -> i2c_adap , & board_info ) ; if ( client == NULL || client -> dev . driver == NULL ) return - ENODEV ; if ( ! try_module_get ( client -> dev . driver -> owner ) ) { i2c_unregister_device ( client ) ; return - ENODEV ; } adap -> fe_adap [ 0 ] . fe = m88ds3103_pdata . get_dvb_frontend ( client ) ; i2c_adapter = m88ds3103_pdata . get_i2c_adapter ( client ) ; state -> i2c_client_demod = client ; ts2020_config . fe = adap -> fe_adap [ 0 ] . fe ; memset ( & board_info , 0 , sizeof ( board_info ) ) ; strlcpy ( board_info . type , \"ts2022\" , I2C_NAME_SIZE ) ; board_info . addr = 0x60 ; board_info . platform_data = & ts2020_config ; request_module ( \"ts2020\" ) ; client = i2c_new_device ( i2c_adapter , & board_info ) ; if ( client == NULL || client -> dev . driver == NULL ) { dvb_frontend_detach ( adap -> fe_adap [ 0 ] . fe ) ; return - ENODEV ; } if ( ! try_module_get ( client -> dev . driver -> owner ) ) { i2c_unregister_device ( client ) ; dvb_frontend_detach ( adap -> fe_adap [ 0 ] . fe ) ; return - ENODEV ; } adap -> fe_adap [ 0 ] . fe -> ops . read_signal_strength = adap -> fe_adap [ 0 ] . fe -> ops . tuner_ops . get_rf_strength ; state -> i2c_client_tuner = client ; state -> fe_read_status = adap -> fe_adap [ 0 ] . fe -> ops . read_status ; adap -> fe_adap [ 0 ] . fe -> ops . read_status = tt_s2_4600_read_status ; state -> last_lock = 0 ; return 0 ; }\n","target":"<S2SV_ModStart> d -> priv <S2SV_ModEnd> ; struct i2c_adapter <S2SV_ModStart> { } ; mutex_lock ( & d -> data_mutex ) ; state -> data [ 0 ] = 0xe ; state -> data [ 1 ] = 0x80 ; state -> data [ 2 ] = 0x0 ; <S2SV_ModStart> ( d , state -> data <S2SV_ModEnd> , 3 , <S2SV_ModStart> , 3 , state -> data <S2SV_ModEnd> , 1 , <S2SV_ModStart> \"command<S2SV_blank>0x0e<S2SV_blank>transfer<S2SV_blank>failed.\" ) ; state -> data <S2SV_ModEnd> [ 0 ] <S2SV_ModStart> = 0xe ; state -> data <S2SV_ModEnd> [ 1 ] <S2SV_ModStart> = 0x02 ; state -> data <S2SV_ModEnd> [ 2 ] <S2SV_ModStart> ( d , state -> data <S2SV_ModEnd> , 3 , <S2SV_ModStart> , 3 , state -> data <S2SV_ModEnd> , 1 , <S2SV_ModStart> 300 ) ; state -> data <S2SV_ModEnd> [ 0 ] <S2SV_ModStart> = 0xe ; state -> data <S2SV_ModEnd> [ 1 ] <S2SV_ModStart> = 0x83 ; state -> data <S2SV_ModEnd> [ 2 ] <S2SV_ModStart> ( d , state -> data <S2SV_ModEnd> , 3 , <S2SV_ModStart> , 3 , state -> data <S2SV_ModEnd> , 1 , <S2SV_ModStart> \"command<S2SV_blank>0x0e<S2SV_blank>transfer<S2SV_blank>failed.\" ) ; state -> data <S2SV_ModEnd> [ 0 ] <S2SV_ModStart> = 0xe ; state -> data <S2SV_ModEnd> [ 1 ] <S2SV_ModStart> = 0x83 ; state -> data <S2SV_ModEnd> [ 2 ] <S2SV_ModStart> ( d , state -> data <S2SV_ModEnd> , 3 , <S2SV_ModStart> , 3 , state -> data <S2SV_ModEnd> , 1 , <S2SV_ModStart> \"command<S2SV_blank>0x0e<S2SV_blank>transfer<S2SV_blank>failed.\" ) ; state -> data <S2SV_ModEnd> [ 0 ] <S2SV_ModStart> ( d , state -> data , 1 , state -> data <S2SV_ModEnd> , 1 , <S2SV_ModStart> err ( \"command<S2SV_blank>0x51<S2SV_blank>transfer<S2SV_blank>failed.\" ) ; mutex_unlock ( & d -> data_mutex\n","project_and_commit_id":"torvalds@linux/606142af57dad981b78707234cfbd15f9f7b7125","cve_id":"CVE-2017-8062","original_address":"https://github.com/torvalds/linux/commit/606142af57dad981b78707234cfbd15f9f7b7125","time":"2017-04-23T05:59Z"},
	{"Unnamed: 0":1545,"cwe_id":"CWE-264","source":"CWE-264 void test_js ( void ) { GString * result = g_string_new ( \"\" ) ; parse_cmd_line ( \"js<S2SV_blank>(\\'x\\'<S2SV_blank>+<S2SV_blank>345).toUpperCase()\" , result ) ; g_assert_cmpstr ( \"X345\" , == , result -> str ) ; <S2SV_StartBug> uzbl . net . useragent = \"Test<S2SV_blank>useragent\" ; <S2SV_EndBug> parse_cmd_line ( \"js<S2SV_blank>Uzbl.run(\\'print<S2SV_blank>@useragent\\').toUpperCase();\" , result ) ; g_assert_cmpstr ( \"TEST<S2SV_blank>USERAGENT\" , == , result -> str ) ; g_string_free ( result , TRUE ) ; }\n","target":"<S2SV_ModStart> str ) ; <S2SV_ModEnd> g_string_free ( result\n","project_and_commit_id":"Dieterbe@uzbl/1958b52d41cba96956dc1995660de49525ed1047","cve_id":"CVE-2010-0011","original_address":"https://github.com/Dieterbe/uzbl/commit/1958b52d41cba96956dc1995660de49525ed1047","time":"2010-02-25T19:30Z"},
	{"Unnamed: 0":3201,"cwe_id":"CWE-000","source":"CWE-000 int evm_update_evmxattr ( struct dentry * dentry , const char * xattr_name , const char * xattr_value , size_t xattr_value_len ) { struct inode * inode = dentry -> d_inode ; struct evm_ima_xattr_data xattr_data ; int rc = 0 ; rc = evm_calc_hmac ( dentry , xattr_name , xattr_value , xattr_value_len , xattr_data . digest ) ; if ( rc == 0 ) { xattr_data . type = EVM_XATTR_HMAC ; rc = __vfs_setxattr_noperm ( dentry , XATTR_NAME_EVM , & xattr_data , sizeof ( xattr_data ) , 0 ) ; } <S2SV_StartBug> else if ( rc == - ENODATA ) <S2SV_EndBug> rc = inode -> i_op -> removexattr ( dentry , XATTR_NAME_EVM ) ; <S2SV_StartBug> return rc ; <S2SV_EndBug> }\n","target":"<S2SV_ModStart> == - ENODATA && inode -> i_op -> removexattr ) { <S2SV_ModEnd> rc = inode <S2SV_ModStart> XATTR_NAME_EVM ) ; }\n","project_and_commit_id":"torvalds@linux/a67adb997419fb53540d4a4f79c6471c60bc69b6","cve_id":"CVE-2013-0313","original_address":"https://github.com/torvalds/linux/commit/a67adb997419fb53540d4a4f79c6471c60bc69b6","time":"2013-02-22T00:55Z"},
	{"Unnamed: 0":378,"cwe_id":"CWE-20","source":"CWE-20 static int ipx_recvmsg ( struct kiocb * iocb , struct socket * sock , struct msghdr * msg , size_t size , int flags ) { struct sock * sk = sock -> sk ; struct ipx_sock * ipxs = ipx_sk ( sk ) ; struct sockaddr_ipx * sipx = ( struct sockaddr_ipx * ) msg -> msg_name ; struct ipxhdr * ipx = NULL ; struct sk_buff * skb ; int copied , rc ; lock_sock ( sk ) ; if ( ! ipxs -> port ) { struct sockaddr_ipx uaddr ; uaddr . sipx_port = 0 ; uaddr . sipx_network = 0 ; # ifdef CONFIG_IPX_INTERN rc = - ENETDOWN ; if ( ! ipxs -> intrfc ) goto out ; memcpy ( uaddr . sipx_node , ipxs -> intrfc -> if_node , IPX_NODE_LEN ) ; # endif rc = __ipx_bind ( sock , ( struct sockaddr * ) & uaddr , sizeof ( struct sockaddr_ipx ) ) ; if ( rc ) goto out ; } rc = - ENOTCONN ; if ( sock_flag ( sk , SOCK_ZAPPED ) ) goto out ; skb = skb_recv_datagram ( sk , flags & ~ MSG_DONTWAIT , flags & MSG_DONTWAIT , & rc ) ; if ( ! skb ) goto out ; ipx = ipx_hdr ( skb ) ; copied = ntohs ( ipx -> ipx_pktsize ) - sizeof ( struct ipxhdr ) ; if ( copied > size ) { copied = size ; msg -> msg_flags |= MSG_TRUNC ; } rc = skb_copy_datagram_iovec ( skb , sizeof ( struct ipxhdr ) , msg -> msg_iov , copied ) ; if ( rc ) goto out_free ; if ( skb -> tstamp . tv64 ) sk -> sk_stamp = skb -> tstamp ; <S2SV_StartBug> msg -> msg_namelen = sizeof ( * sipx ) ; <S2SV_EndBug> if ( sipx ) { sipx -> sipx_family = AF_IPX ; sipx -> sipx_port = ipx -> ipx_source . sock ; memcpy ( sipx -> sipx_node , ipx -> ipx_source . node , IPX_NODE_LEN ) ; sipx -> sipx_network = IPX_SKB_CB ( skb ) -> ipx_source_net ; sipx -> sipx_type = ipx -> ipx_type ; sipx -> sipx_zero = 0 ; } rc = copied ; out_free : skb_free_datagram ( sk , skb ) ; out : release_sock ( sk ) ; return rc ; }\n","target":"<S2SV_ModStart> -> tstamp ; if ( sipx ) { sipx -> sipx_family = AF_IPX ; sipx -> sipx_port = ipx -> ipx_source . sock ; memcpy ( sipx -> sipx_node , ipx -> ipx_source . node , IPX_NODE_LEN ) ; sipx -> sipx_network = IPX_SKB_CB ( skb ) -> ipx_source_net ; sipx -> sipx_type = ipx -> ipx_type ; sipx -> sipx_zero = 0 ; <S2SV_ModStart> * sipx ) <S2SV_ModEnd> ; } rc\n","project_and_commit_id":"torvalds@linux/f3d3342602f8bcbf37d7c46641cb9bca7618eb1c","cve_id":"CVE-2013-7271","original_address":"https://github.com/torvalds/linux/commit/f3d3342602f8bcbf37d7c46641cb9bca7618eb1c","time":"2014-01-06T16:55Z"},
	{"Unnamed: 0":721,"cwe_id":"CWE-119","source":"CWE-119 int main ( int argc , char * * argv ) { FILE * infile = NULL ; vpx_codec_ctx_t codec ; vpx_codec_enc_cfg_t cfg ; int frame_count = 0 ; vpx_image_t raw ; vpx_codec_err_t res ; VpxVideoInfo info = { 0 } ; VpxVideoWriter * writer = NULL ; const VpxInterface * encoder = NULL ; const int fps = 30 ; const int bitrate = 200 ; int keyframe_interval = 0 ; const char * codec_arg = NULL ; const char * width_arg = NULL ; const char * height_arg = NULL ; const char * infile_arg = NULL ; const char * outfile_arg = NULL ; const char * keyframe_interval_arg = NULL ; exec_name = argv [ 0 ] ; if ( argc < 7 ) die ( \"Invalid<S2SV_blank>number<S2SV_blank>of<S2SV_blank>arguments\" ) ; codec_arg = argv [ 1 ] ; width_arg = argv [ 2 ] ; height_arg = argv [ 3 ] ; infile_arg = argv [ 4 ] ; outfile_arg = argv [ 5 ] ; keyframe_interval_arg = argv [ 6 ] ; encoder = get_vpx_encoder_by_name ( codec_arg ) ; if ( ! encoder ) die ( \"Unsupported<S2SV_blank>codec.\" ) ; info . codec_fourcc = encoder -> fourcc ; info . frame_width = strtol ( width_arg , NULL , 0 ) ; info . frame_height = strtol ( height_arg , NULL , 0 ) ; info . time_base . numerator = 1 ; info . time_base . denominator = fps ; if ( info . frame_width <= 0 || info . frame_height <= 0 || ( info . frame_width % 2 ) != 0 || ( info . frame_height % 2 ) != 0 ) { die ( \"Invalid<S2SV_blank>frame<S2SV_blank>size:<S2SV_blank>%dx%d\" , info . frame_width , info . frame_height ) ; } if ( ! vpx_img_alloc ( & raw , VPX_IMG_FMT_I420 , info . frame_width , info . frame_height , 1 ) ) { die ( \"Failed<S2SV_blank>to<S2SV_blank>allocate<S2SV_blank>image.\" ) ; } keyframe_interval = strtol ( keyframe_interval_arg , NULL , 0 ) ; if ( keyframe_interval < 0 ) die ( \"Invalid<S2SV_blank>keyframe<S2SV_blank>interval<S2SV_blank>value.\" ) ; <S2SV_StartBug> printf ( \"Using<S2SV_blank>%s\\\\n\" , vpx_codec_iface_name ( encoder -> interface ( ) ) ) ; <S2SV_EndBug> <S2SV_StartBug> res = vpx_codec_enc_config_default ( encoder -> interface ( ) , & cfg , 0 ) ; <S2SV_EndBug> if ( res ) die_codec ( & codec , \"Failed<S2SV_blank>to<S2SV_blank>get<S2SV_blank>default<S2SV_blank>codec<S2SV_blank>config.\" ) ; cfg . g_w = info . frame_width ; cfg . g_h = info . frame_height ; cfg . g_timebase . num = info . time_base . numerator ; cfg . g_timebase . den = info . time_base . denominator ; cfg . rc_target_bitrate = bitrate ; cfg . g_error_resilient = argc > 7 ? strtol ( argv [ 7 ] , NULL , 0 ) : 0 ; writer = vpx_video_writer_open ( outfile_arg , kContainerIVF , & info ) ; if ( ! writer ) die ( \"Failed<S2SV_blank>to<S2SV_blank>open<S2SV_blank>%s<S2SV_blank>for<S2SV_blank>writing.\" , outfile_arg ) ; if ( ! ( infile = fopen ( infile_arg , \"rb\" ) ) ) die ( \"Failed<S2SV_blank>to<S2SV_blank>open<S2SV_blank>%s<S2SV_blank>for<S2SV_blank>reading.\" , infile_arg ) ; <S2SV_StartBug> if ( vpx_codec_enc_init ( & codec , encoder -> interface ( ) , & cfg , 0 ) ) <S2SV_EndBug> die_codec ( & codec , \"Failed<S2SV_blank>to<S2SV_blank>initialize<S2SV_blank>encoder\" ) ; while ( vpx_img_read ( & raw , infile ) ) { int flags = 0 ; if ( keyframe_interval > 0 && frame_count % keyframe_interval == 0 ) flags |= VPX_EFLAG_FORCE_KF ; encode_frame ( & codec , & raw , frame_count ++ , flags , writer ) ; } <S2SV_StartBug> encode_frame ( & codec , NULL , - 1 , 0 , writer ) ; <S2SV_EndBug> printf ( \"\\\\n\" ) ; fclose ( infile ) ; printf ( \"Processed<S2SV_blank>%d<S2SV_blank>frames.\\\\n\" , frame_count ) ; vpx_img_free ( & raw ) ; if ( vpx_codec_destroy ( & codec ) ) die_codec ( & codec , \"Failed<S2SV_blank>to<S2SV_blank>destroy<S2SV_blank>codec.\" ) ; vpx_video_writer_close ( writer ) ; return EXIT_SUCCESS ; }\n","target":"<S2SV_ModStart> ( encoder -> codec_interface <S2SV_ModEnd> ( ) ) <S2SV_ModStart> ( encoder -> codec_interface <S2SV_ModEnd> ( ) , <S2SV_ModStart> , encoder -> codec_interface <S2SV_ModEnd> ( ) , <S2SV_ModStart> ) ; } while ( <S2SV_ModStart> , writer ) ) { }\n","project_and_commit_id":"external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426","cve_id":"CVE-2016-1621","original_address":"https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426","time":"2016-03-12T21:59Z"},
	{"Unnamed: 0":4373,"cwe_id":"CWE-000","source":"CWE-000 void sctp_assoc_update ( struct sctp_association * asoc , struct sctp_association * new ) { struct sctp_transport * trans ; struct list_head * pos , * temp ; asoc -> c = new -> c ; asoc -> peer . rwnd = new -> peer . rwnd ; asoc -> peer . sack_needed = new -> peer . sack_needed ; asoc -> peer . auth_capable = new -> peer . auth_capable ; asoc -> peer . i = new -> peer . i ; sctp_tsnmap_init ( & asoc -> peer . tsn_map , SCTP_TSN_MAP_INITIAL , asoc -> peer . i . initial_tsn , GFP_ATOMIC ) ; list_for_each_safe ( pos , temp , & asoc -> peer . transport_addr_list ) { trans = list_entry ( pos , struct sctp_transport , transports ) ; if ( ! sctp_assoc_lookup_paddr ( new , & trans -> ipaddr ) ) { sctp_assoc_rm_peer ( asoc , trans ) ; continue ; } if ( asoc -> state >= SCTP_STATE_ESTABLISHED ) sctp_transport_reset ( trans ) ; } if ( asoc -> state >= SCTP_STATE_ESTABLISHED ) { asoc -> next_tsn = new -> next_tsn ; asoc -> ctsn_ack_point = new -> ctsn_ack_point ; asoc -> adv_peer_ack_point = new -> adv_peer_ack_point ; sctp_ssnmap_clear ( asoc -> ssnmap ) ; sctp_ulpq_flush ( & asoc -> ulpq ) ; asoc -> overall_error_count = 0 ; } else { list_for_each_entry ( trans , & new -> peer . transport_addr_list , transports ) { if ( ! sctp_assoc_lookup_paddr ( asoc , & trans -> ipaddr ) ) sctp_assoc_add_peer ( asoc , & trans -> ipaddr , GFP_ATOMIC , trans -> state ) ; } asoc -> ctsn_ack_point = asoc -> next_tsn - 1 ; asoc -> adv_peer_ack_point = asoc -> ctsn_ack_point ; if ( ! asoc -> ssnmap ) { asoc -> ssnmap = new -> ssnmap ; new -> ssnmap = NULL ; } if ( ! asoc -> assoc_id ) { sctp_assoc_set_id ( asoc , GFP_ATOMIC ) ; } } kfree ( asoc -> peer . peer_random ) ; asoc -> peer . peer_random = new -> peer . peer_random ; new -> peer . peer_random = NULL ; kfree ( asoc -> peer . peer_chunks ) ; asoc -> peer . peer_chunks = new -> peer . peer_chunks ; new -> peer . peer_chunks = NULL ; kfree ( asoc -> peer . peer_hmacs ) ; asoc -> peer . peer_hmacs = new -> peer . peer_hmacs ; new -> peer . peer_hmacs = NULL ; <S2SV_StartBug> sctp_auth_key_put ( asoc -> asoc_shared_key ) ; <S2SV_EndBug> sctp_auth_asoc_init_active_key ( asoc , GFP_ATOMIC ) ; }\n","target":"<S2SV_ModStart> = NULL ; <S2SV_ModEnd> sctp_auth_asoc_init_active_key ( asoc\n","project_and_commit_id":"torvalds@linux/600ddd6825543962fb807884169e57b580dba208","cve_id":"CVE-2015-1421","original_address":"https://github.com/torvalds/linux/commit/600ddd6825543962fb807884169e57b580dba208","time":"2015-03-16T10:59Z"},
	{"Unnamed: 0":1133,"cwe_id":"CWE-125","source":"CWE-125 char * Ta3Tokenizer_FindEncodingFilename ( int fd , PyObject * filename ) { struct tok_state * tok ; FILE * fp ; char * p_start = NULL , * p_end = NULL , * encoding = NULL ; # ifndef PGEN <S2SV_StartBug> # if PY_MINOR_VERSION >= 4 <S2SV_EndBug> fd = _Py_dup ( fd ) ; <S2SV_StartBug> # endif <S2SV_EndBug> # else fd = dup ( fd ) ; # endif if ( fd < 0 ) { return NULL ; } fp = fdopen ( fd , \"r\" ) ; if ( fp == NULL ) { return NULL ; } tok = Ta3Tokenizer_FromFile ( fp , NULL , NULL , NULL ) ; if ( tok == NULL ) { fclose ( fp ) ; return NULL ; } # ifndef PGEN if ( filename != NULL ) { Py_INCREF ( filename ) ; tok -> filename = filename ; } else { tok -> filename = PyUnicode_FromString ( \"<string>\" ) ; if ( tok -> filename == NULL ) { fclose ( fp ) ; Ta3Tokenizer_Free ( tok ) ; return encoding ; } } # endif while ( tok -> lineno < 2 && tok -> done == E_OK ) { Ta3Tokenizer_Get ( tok , & p_start , & p_end ) ; } fclose ( fp ) ; if ( tok -> encoding ) { encoding = ( char * ) PyMem_MALLOC ( strlen ( tok -> encoding ) + 1 ) ; if ( encoding ) strcpy ( encoding , tok -> encoding ) ; } Ta3Tokenizer_Free ( tok ) ; return encoding ; }\n","target":"<S2SV_ModStart> # ifndef PGEN <S2SV_ModEnd> fd = _Py_dup <S2SV_ModStart> fd ) ; <S2SV_ModEnd> # else fd\n","project_and_commit_id":"python@typed_ast/156afcb26c198e162504a57caddfe0acd9ed7dce","cve_id":"CVE-2019-19275","original_address":"https://github.com/python/typed_ast/commit/156afcb26c198e162504a57caddfe0acd9ed7dce","time":"2019-11-26T15:15Z"},
	{"Unnamed: 0":4182,"cwe_id":"CWE-787","source":"CWE-787 static OPJ_BOOL opj_j2k_write_sot ( opj_j2k_t * p_j2k , OPJ_BYTE * p_data , OPJ_UINT32 p_total_data_size , OPJ_UINT32 * p_data_written , const opj_stream_private_t * p_stream , opj_event_mgr_t * p_manager ) { assert ( p_j2k != 00 ) ; assert ( p_manager != 00 ) ; assert ( p_stream != 00 ) ; OPJ_UNUSED ( p_stream ) ; <S2SV_StartBug> OPJ_UNUSED ( p_manager ) ; <S2SV_EndBug> if ( p_total_data_size < 12 ) { opj_event_msg ( p_manager , EVT_ERROR , \"Not<S2SV_blank>enough<S2SV_blank>bytes<S2SV_blank>in<S2SV_blank>output<S2SV_blank>buffer<S2SV_blank>to<S2SV_blank>write<S2SV_blank>SOT<S2SV_blank>marker\\\\n\" ) ; return OPJ_FALSE ; } opj_write_bytes ( p_data , J2K_MS_SOT , 2 ) ; p_data += 2 ; opj_write_bytes ( p_data , 10 , 2 ) ; p_data += 2 ; opj_write_bytes ( p_data , p_j2k -> m_current_tile_number , 2 ) ; p_data += 2 ; p_data += 4 ; opj_write_bytes ( p_data , p_j2k -> m_specific_param . m_encoder . m_current_tile_part_number , 1 ) ; ++ p_data ; opj_write_bytes ( p_data , p_j2k -> m_cp . tcps [ p_j2k -> m_current_tile_number ] . m_nb_tile_parts , 1 ) ; ++ p_data ; # ifdef USE_JPWL assert ( 0 && \"TODO\" ) ; # endif * p_data_written = 12 ; return OPJ_TRUE ; }\n","target":"<S2SV_ModStart> p_stream ) ; <S2SV_ModEnd> if ( p_total_data_size\n","project_and_commit_id":"uclouvain@openjpeg/c535531f03369623b9b833ef41952c62257b507e","cve_id":"CVE-2017-14039","original_address":"https://github.com/uclouvain/openjpeg/commit/c535531f03369623b9b833ef41952c62257b507e","time":"2017-08-30T22:29Z"},
	{"Unnamed: 0":4413,"cwe_id":"CWE-000","source":"CWE-000 SYSCALL_DEFINE4 ( epoll_ctl , int , epfd , int , op , int , fd , struct epoll_event __user * , event ) { int error ; int did_lock_epmutex = 0 ; struct file * file , * tfile ; struct eventpoll * ep ; struct epitem * epi ; struct epoll_event epds ; error = - EFAULT ; if ( ep_op_has_event ( op ) && copy_from_user ( & epds , event , sizeof ( struct epoll_event ) ) ) goto error_return ; error = - EBADF ; file = fget ( epfd ) ; if ( ! file ) goto error_return ; tfile = fget ( fd ) ; if ( ! tfile ) goto error_fput ; error = - EPERM ; if ( ! tfile -> f_op || ! tfile -> f_op -> poll ) goto error_tgt_fput ; error = - EINVAL ; if ( file == tfile || ! is_file_epoll ( file ) ) goto error_tgt_fput ; ep = file -> private_data ; if ( op == EPOLL_CTL_ADD || op == EPOLL_CTL_DEL ) { mutex_lock ( & epmutex ) ; did_lock_epmutex = 1 ; } if ( op == EPOLL_CTL_ADD ) { if ( is_file_epoll ( tfile ) ) { error = - ELOOP ; <S2SV_StartBug> if ( ep_loop_check ( ep , tfile ) != 0 ) <S2SV_EndBug> <S2SV_StartBug> goto error_tgt_fput ; <S2SV_EndBug> } else list_add ( & tfile -> f_tfile_llink , & tfile_check_list ) ; } mutex_lock_nested ( & ep -> mtx , 0 ) ; epi = ep_find ( ep , tfile , fd ) ; error = - EINVAL ; switch ( op ) { case EPOLL_CTL_ADD : if ( ! epi ) { epds . events |= POLLERR | POLLHUP ; error = ep_insert ( ep , & epds , tfile , fd ) ; } else error = - EEXIST ; clear_tfile_check_list ( ) ; break ; case EPOLL_CTL_DEL : if ( epi ) error = ep_remove ( ep , epi ) ; else error = - ENOENT ; break ; case EPOLL_CTL_MOD : if ( epi ) { epds . events |= POLLERR | POLLHUP ; error = ep_modify ( ep , epi , & epds ) ; } else error = - ENOENT ; break ; } mutex_unlock ( & ep -> mtx ) ; error_tgt_fput : if ( did_lock_epmutex ) mutex_unlock ( & epmutex ) ; fput ( tfile ) ; error_fput : fput ( file ) ; error_return : return error ; }\n","target":"<S2SV_ModStart> != 0 ) { clear_tfile_check_list ( ) ; <S2SV_ModStart> goto error_tgt_fput ; }\n","project_and_commit_id":"torvalds@linux/13d518074a952d33d47c428419693f63389547e9","cve_id":"CVE-2012-3375","original_address":"https://github.com/torvalds/linux/commit/13d518074a952d33d47c428419693f63389547e9","time":"2012-10-03T11:02Z"},
	{"Unnamed: 0":758,"cwe_id":"CWE-399","source":"CWE-399 static struct sk_buff * udp6_ufo_fragment ( struct sk_buff * skb , u32 features ) { struct sk_buff * segs = ERR_PTR ( - EINVAL ) ; unsigned int mss ; unsigned int unfrag_ip6hlen , unfrag_len ; struct frag_hdr * fptr ; u8 * mac_start , * prevhdr ; u8 nexthdr ; u8 frag_hdr_sz = sizeof ( struct frag_hdr ) ; int offset ; __wsum csum ; mss = skb_shinfo ( skb ) -> gso_size ; if ( unlikely ( skb -> len <= mss ) ) goto out ; if ( skb_gso_ok ( skb , features | NETIF_F_GSO_ROBUST ) ) { int type = skb_shinfo ( skb ) -> gso_type ; if ( unlikely ( type & ~ ( SKB_GSO_UDP | SKB_GSO_DODGY ) || ! ( type & ( SKB_GSO_UDP ) ) ) ) goto out ; skb_shinfo ( skb ) -> gso_segs = DIV_ROUND_UP ( skb -> len , mss ) ; segs = NULL ; goto out ; } offset = skb -> csum_start - skb_headroom ( skb ) ; csum = skb_checksum ( skb , offset , skb -> len - offset , 0 ) ; offset += skb -> csum_offset ; * ( __sum16 * ) ( skb -> data + offset ) = csum_fold ( csum ) ; skb -> ip_summed = CHECKSUM_NONE ; <S2SV_StartBug> if ( ( skb_headroom ( skb ) < frag_hdr_sz ) && <S2SV_EndBug> pskb_expand_head ( skb , frag_hdr_sz , 0 , GFP_ATOMIC ) ) goto out ; unfrag_ip6hlen = ip6_find_1stfragopt ( skb , & prevhdr ) ; nexthdr = * prevhdr ; * prevhdr = NEXTHDR_FRAGMENT ; unfrag_len = skb_network_header ( skb ) - skb_mac_header ( skb ) + unfrag_ip6hlen ; mac_start = skb_mac_header ( skb ) ; memmove ( mac_start - frag_hdr_sz , mac_start , unfrag_len ) ; skb -> mac_header -= frag_hdr_sz ; skb -> network_header -= frag_hdr_sz ; fptr = ( struct frag_hdr * ) ( skb_network_header ( skb ) + unfrag_ip6hlen ) ; fptr -> nexthdr = nexthdr ; fptr -> reserved = 0 ; ipv6_select_ident ( fptr ) ; segs = skb_segment ( skb , features ) ; out : return segs ; }\n","target":"<S2SV_ModStart> if ( ( skb_mac_header <S2SV_ModEnd> ( skb ) <S2SV_ModStart> skb ) < skb -> head +\n","project_and_commit_id":"torvalds@linux/a9cf73ea7ff78f52662c8658d93c226effbbedde","cve_id":"CVE-2011-4326","original_address":"https://github.com/torvalds/linux/commit/a9cf73ea7ff78f52662c8658d93c226effbbedde","time":"2012-05-17T11:00Z"},
	{"Unnamed: 0":507,"cwe_id":"CWE-125","source":"CWE-125 static expr_ty ast_for_decorator ( struct compiling * c , const node * n ) { expr_ty d = NULL ; expr_ty name_expr ; REQ ( n , decorator ) ; REQ ( CHILD ( n , 0 ) , AT ) ; REQ ( RCHILD ( n , - 1 ) , NEWLINE ) ; name_expr = ast_for_dotted_name ( c , CHILD ( n , 1 ) ) ; if ( ! name_expr ) return NULL ; if ( NCH ( n ) == 3 ) { d = name_expr ; name_expr = NULL ; } else if ( NCH ( n ) == 5 ) { d = Call ( name_expr , NULL , NULL , LINENO ( n ) , n -> n_col_offset , c -> c_arena ) ; if ( ! d ) return NULL ; name_expr = NULL ; } else { <S2SV_StartBug> d = ast_for_call ( c , CHILD ( n , 3 ) , name_expr ) ; <S2SV_EndBug> if ( ! d ) return NULL ; name_expr = NULL ; } return d ; }\n","target":"<S2SV_ModStart> ) , name_expr , true\n","project_and_commit_id":"python@typed_ast/156afcb26c198e162504a57caddfe0acd9ed7dce","cve_id":"CVE-2019-19275","original_address":"https://github.com/python/typed_ast/commit/156afcb26c198e162504a57caddfe0acd9ed7dce","time":"2019-11-26T15:15Z"},
	{"Unnamed: 0":5524,"cwe_id":"CWE-119","source":"CWE-119 static int check_entry_size_and_hooks ( struct ip6t_entry * e , struct xt_table_info * newinfo , const unsigned char * base , const unsigned char * limit , const unsigned int * hook_entries , const unsigned int * underflows , unsigned int valid_hooks ) { unsigned int h ; int err ; if ( ( unsigned long ) e % __alignof__ ( struct ip6t_entry ) != 0 || <S2SV_StartBug> ( unsigned char * ) e + sizeof ( struct ip6t_entry ) >= limit ) { <S2SV_EndBug> duprintf ( \"Bad<S2SV_blank>offset<S2SV_blank>%p\\\\n\" , e ) ; return - EINVAL ; } if ( e -> next_offset < sizeof ( struct ip6t_entry ) + sizeof ( struct xt_entry_target ) ) { duprintf ( \"checking:<S2SV_blank>element<S2SV_blank>%p<S2SV_blank>size<S2SV_blank>%u\\\\n\" , e , e -> next_offset ) ; return - EINVAL ; } err = check_entry ( e ) ; if ( err ) return err ; for ( h = 0 ; h < NF_INET_NUMHOOKS ; h ++ ) { if ( ! ( valid_hooks & ( 1 << h ) ) ) continue ; if ( ( unsigned char * ) e - base == hook_entries [ h ] ) newinfo -> hook_entry [ h ] = hook_entries [ h ] ; if ( ( unsigned char * ) e - base == underflows [ h ] ) { if ( ! check_underflow ( e ) ) { pr_err ( \"Underflows<S2SV_blank>must<S2SV_blank>be<S2SV_blank>unconditional<S2SV_blank>and<S2SV_blank>\" \"use<S2SV_blank>the<S2SV_blank>STANDARD<S2SV_blank>target<S2SV_blank>with<S2SV_blank>\" \"ACCEPT/DROP\\\\n\" ) ; return - EINVAL ; } newinfo -> underflow [ h ] = underflows [ h ] ; } } e -> counters = ( ( struct xt_counters ) { 0 , 0 } ) ; e -> comefrom = 0 ; return 0 ; }\n","target":"<S2SV_ModStart> ip6t_entry ) >= limit || ( unsigned char * ) e + e -> next_offset >\n","project_and_commit_id":"torvalds@linux/6e94e0cfb0887e4013b3b930fa6ab1fe6bb6ba91","cve_id":"CVE-2016-4998","original_address":"https://github.com/torvalds/linux/commit/6e94e0cfb0887e4013b3b930fa6ab1fe6bb6ba91","time":"2016-07-03T21:59Z"},
	{"Unnamed: 0":5054,"cwe_id":"CWE-264","source":"CWE-264 int create_user_ns ( struct cred * new ) { struct user_namespace * ns , * parent_ns = new -> user_ns ; kuid_t owner = new -> euid ; kgid_t group = new -> egid ; <S2SV_StartBug> int ret ; <S2SV_EndBug> if ( ! kuid_has_mapping ( parent_ns , owner ) || ! kgid_has_mapping ( parent_ns , group ) ) return - EPERM ; ns = kmem_cache_zalloc ( user_ns_cachep , GFP_KERNEL ) ; if ( ! ns ) return - ENOMEM ; ret = proc_alloc_inum ( & ns -> proc_inum ) ; if ( ret ) { kmem_cache_free ( user_ns_cachep , ns ) ; return ret ; } atomic_set ( & ns -> count , 1 ) ; ns -> parent = parent_ns ; ns -> owner = owner ; ns -> group = group ; set_cred_user_ns ( new , ns ) ; return 0 ; }\n","target":"<S2SV_ModStart> ; int ret ; if ( current_chrooted ( ) ) return - EPERM\n","project_and_commit_id":"torvalds@linux/3151527ee007b73a0ebd296010f1c0454a919c7d","cve_id":"CVE-2013-1956","original_address":"https://github.com/torvalds/linux/commit/3151527ee007b73a0ebd296010f1c0454a919c7d","time":"2013-04-24T19:55Z"},
	{"Unnamed: 0":3112,"cwe_id":"CWE-125","source":"CWE-125 static inline long object_common1 ( UNSERIALIZE_PARAMETER , zend_class_entry * ce ) { <S2SV_StartBug> long elements ; <S2SV_EndBug> elements = parse_iv2 ( ( * p ) + 2 , p ) ; ( * p ) += 2 ; if ( ce -> serialize == NULL ) { object_init_ex ( * rval , ce ) ; } else { zend_error ( E_WARNING , \"Erroneous<S2SV_blank>data<S2SV_blank>format<S2SV_blank>for<S2SV_blank>unserializing<S2SV_blank>\\'%s\\'\" , ce -> name ) ; <S2SV_StartBug> return 0 ; <S2SV_EndBug> } return elements ; }\n","target":"<S2SV_ModStart> long elements ; if ( * p >= max - 2 ) { zend_error ( E_WARNING , \"Bad<S2SV_blank>unserialize<S2SV_blank>data\" ) ; return - 1 ; } <S2SV_ModStart> ) ; return - 1 <S2SV_ModEnd> ; } return\n","project_and_commit_id":"php@php-src/16b3003ffc6393e250f069aa28a78dc5a2c064b2","cve_id":"CVE-2016-10161","original_address":"https://github.com/php/php-src/commit/16b3003ffc6393e250f069aa28a78dc5a2c064b2","time":"2017-01-24T21:59Z"},
	{"Unnamed: 0":1715,"cwe_id":"CWE-000","source":"CWE-000 <S2SV_StartBug> static int can_open_cached ( struct nfs4_state * state , int mode ) <S2SV_EndBug> { int ret = 0 ; <S2SV_StartBug> switch ( mode & ( FMODE_READ | FMODE_WRITE | O_EXCL ) ) { <S2SV_EndBug> case FMODE_READ : ret |= test_bit ( NFS_O_RDONLY_STATE , & state -> flags ) != 0 ; break ; case FMODE_WRITE : ret |= test_bit ( NFS_O_WRONLY_STATE , & state -> flags ) != 0 ; break ; case FMODE_READ | FMODE_WRITE : ret |= test_bit ( NFS_O_RDWR_STATE , & state -> flags ) != 0 ; } <S2SV_StartBug> return ret ; <S2SV_EndBug> }\n","target":"<S2SV_ModStart> * state , fmode_t mode , int open_mode <S2SV_ModEnd> ) { int <S2SV_ModStart> = 0 ; if ( open_mode & O_EXCL ) goto out ; <S2SV_ModStart> FMODE_READ | FMODE_WRITE <S2SV_ModEnd> ) ) { <S2SV_ModStart> 0 ; } out :\n","project_and_commit_id":"torvalds@linux/dc0b027dfadfcb8a5504f7d8052754bf8d501ab9","cve_id":"CVE-2011-4324","original_address":"https://github.com/torvalds/linux/commit/dc0b027dfadfcb8a5504f7d8052754bf8d501ab9","time":"2012-06-21T23:55Z"},
	{"Unnamed: 0":398,"cwe_id":"CWE-000","source":"CWE-000 static int propagate_one ( struct mount * m ) { struct mount * child ; int type ; if ( IS_MNT_NEW ( m ) ) return 0 ; if ( ! is_subdir ( mp -> m_dentry , m -> mnt . mnt_root ) ) return 0 ; if ( peers ( m , last_dest ) ) { type = CL_MAKE_SHARED ; } else { <S2SV_StartBug> struct mount * n , * p ; <S2SV_EndBug> for ( n = m ; ; n = p ) { p = n -> mnt_master ; <S2SV_StartBug> if ( p == dest_master || IS_MNT_MARKED ( p ) ) { <S2SV_EndBug> while ( last_dest -> mnt_master != p ) { last_source = last_source -> mnt_master ; last_dest = last_source -> mnt_parent ; } if ( ! peers ( n , last_dest ) ) { last_source = last_source -> mnt_master ; last_dest = last_source -> mnt_parent ; } break ; } } type = CL_SLAVE ; if ( IS_MNT_SHARED ( m ) ) type |= CL_MAKE_SHARED ; } if ( m -> mnt_ns -> user_ns != user_ns ) type |= CL_UNPRIVILEGED ; child = copy_tree ( last_source , last_source -> mnt . mnt_root , type ) ; if ( IS_ERR ( child ) ) return PTR_ERR ( child ) ; child -> mnt . mnt_flags &= ~ MNT_LOCKED ; mnt_set_mountpoint ( m , mp , child ) ; last_dest = m ; last_source = child ; if ( m -> mnt_master != dest_master ) { read_seqlock_excl ( & mount_lock ) ; SET_MNT_MARK ( m -> mnt_master ) ; read_sequnlock_excl ( & mount_lock ) ; } hlist_add_head ( & child -> mnt_hash , list ) ; return 0 ; }\n","target":"<S2SV_ModStart> , * p ; bool done <S2SV_ModStart> p ) ) break ; } do { struct mount * parent = last_source -> mnt_parent ; if ( last_source == first_source ) break ; done = parent -> mnt_master == p ; if ( done && peers ( n , parent ) ) break ; last_source = last_source -> mnt_master ; } while ( ! done ) ; <S2SV_ModEnd> type = CL_SLAVE\n","project_and_commit_id":"torvalds@linux/5ec0811d30378ae104f250bfc9b3640242d81e3f","cve_id":"CVE-2016-4581","original_address":"https://github.com/torvalds/linux/commit/5ec0811d30378ae104f250bfc9b3640242d81e3f","time":"2016-05-23T10:59Z"},
	{"Unnamed: 0":950,"cwe_id":"CWE-119","source":"CWE-119 static void write_modes ( VP9_COMP * cpi , const TileInfo * const tile , <S2SV_StartBug> vp9_writer * w , TOKENEXTRA * * tok , TOKENEXTRA * tok_end ) { <S2SV_EndBug> <S2SV_StartBug> int mi_row , mi_col ; <S2SV_EndBug> for ( mi_row = tile -> mi_row_start ; mi_row < tile -> mi_row_end ; mi_row += MI_BLOCK_SIZE ) { <S2SV_StartBug> vp9_zero ( cpi -> mb . e_mbd . left_seg_context ) ; <S2SV_EndBug> for ( mi_col = tile -> mi_col_start ; mi_col < tile -> mi_col_end ; mi_col += MI_BLOCK_SIZE ) write_modes_sb ( cpi , tile , w , tok , tok_end , mi_row , mi_col , BLOCK_64X64 ) ; } }\n","target":"<S2SV_ModStart> const tile , vpx_writer <S2SV_ModEnd> * w , <S2SV_ModStart> * tok , const TOKENEXTRA * const <S2SV_ModEnd> tok_end ) { <S2SV_ModStart> tok_end ) { const VP9_COMMON * const cm = & cpi -> common ; MACROBLOCKD * const xd = & cpi -> td . mb . e_mbd ; <S2SV_ModStart> mi_row , mi_col ; set_partition_probs ( cm , xd ) <S2SV_ModStart> { vp9_zero ( xd -> <S2SV_ModEnd> left_seg_context ) ;\n","project_and_commit_id":"external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426","cve_id":"CVE-2016-1621","original_address":"https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426","time":"2016-03-12T21:59Z"},
	{"Unnamed: 0":431,"cwe_id":"CWE-787","source":"CWE-787 rfbBool HandleRFBServerMessage ( rfbClient * client ) { rfbServerToClientMsg msg ; if ( client -> serverPort == - 1 ) client -> vncRec -> readTimestamp = TRUE ; if ( ! ReadFromRFBServer ( client , ( char * ) & msg , 1 ) ) return FALSE ; switch ( msg . type ) { case rfbSetColourMapEntries : { break ; } case rfbFramebufferUpdate : { rfbFramebufferUpdateRectHeader rect ; int linesToRead ; int bytesPerLine ; int i ; if ( ! ReadFromRFBServer ( client , ( ( char * ) & msg . fu ) + 1 , sz_rfbFramebufferUpdateMsg - 1 ) ) return FALSE ; msg . fu . nRects = rfbClientSwap16IfLE ( msg . fu . nRects ) ; for ( i = 0 ; i < msg . fu . nRects ; i ++ ) { if ( ! ReadFromRFBServer ( client , ( char * ) & rect , sz_rfbFramebufferUpdateRectHeader ) ) return FALSE ; rect . encoding = rfbClientSwap32IfLE ( rect . encoding ) ; if ( rect . encoding == rfbEncodingLastRect ) break ; rect . r . x = rfbClientSwap16IfLE ( rect . r . x ) ; rect . r . y = rfbClientSwap16IfLE ( rect . r . y ) ; rect . r . w = rfbClientSwap16IfLE ( rect . r . w ) ; rect . r . h = rfbClientSwap16IfLE ( rect . r . h ) ; if ( rect . encoding == rfbEncodingXCursor || rect . encoding == rfbEncodingRichCursor ) { if ( ! HandleCursorShape ( client , rect . r . x , rect . r . y , rect . r . w , rect . r . h , rect . encoding ) ) { return FALSE ; } continue ; } if ( rect . encoding == rfbEncodingPointerPos ) { if ( ! client -> HandleCursorPos ( client , rect . r . x , rect . r . y ) ) { return FALSE ; } continue ; } if ( rect . encoding == rfbEncodingKeyboardLedState ) { client -> KeyboardLedStateEnabled = 1 ; if ( client -> HandleKeyboardLedState != NULL ) client -> HandleKeyboardLedState ( client , rect . r . x , 0 ) ; client -> CurrentKeyboardLedState = rect . r . x ; continue ; } if ( rect . encoding == rfbEncodingNewFBSize ) { client -> width = rect . r . w ; client -> height = rect . r . h ; client -> updateRect . x = client -> updateRect . y = 0 ; client -> updateRect . w = client -> width ; client -> updateRect . h = client -> height ; if ( ! client -> MallocFrameBuffer ( client ) ) return FALSE ; SendFramebufferUpdateRequest ( client , 0 , 0 , rect . r . w , rect . r . h , FALSE ) ; rfbClientLog ( \"Got<S2SV_blank>new<S2SV_blank>framebuffer<S2SV_blank>size:<S2SV_blank>%dx%d\\\\n\" , rect . r . w , rect . r . h ) ; continue ; } if ( rect . encoding == rfbEncodingSupportedMessages ) { int loop ; if ( ! ReadFromRFBServer ( client , ( char * ) & client -> supportedMessages , sz_rfbSupportedMessages ) ) return FALSE ; rfbClientLog ( \"client2server<S2SV_blank>supported<S2SV_blank>messages<S2SV_blank>(bit<S2SV_blank>flags)\\\\n\" ) ; for ( loop = 0 ; loop < 32 ; loop += 8 ) rfbClientLog ( \"%02X:<S2SV_blank>%04x<S2SV_blank>%04x<S2SV_blank>%04x<S2SV_blank>%04x<S2SV_blank>-<S2SV_blank>%04x<S2SV_blank>%04x<S2SV_blank>%04x<S2SV_blank>%04x\\\\n\" , loop , client -> supportedMessages . client2server [ loop ] , client -> supportedMessages . client2server [ loop + 1 ] , client -> supportedMessages . client2server [ loop + 2 ] , client -> supportedMessages . client2server [ loop + 3 ] , client -> supportedMessages . client2server [ loop + 4 ] , client -> supportedMessages . client2server [ loop + 5 ] , client -> supportedMessages . client2server [ loop + 6 ] , client -> supportedMessages . client2server [ loop + 7 ] ) ; rfbClientLog ( \"server2client<S2SV_blank>supported<S2SV_blank>messages<S2SV_blank>(bit<S2SV_blank>flags)\\\\n\" ) ; for ( loop = 0 ; loop < 32 ; loop += 8 ) rfbClientLog ( \"%02X:<S2SV_blank>%04x<S2SV_blank>%04x<S2SV_blank>%04x<S2SV_blank>%04x<S2SV_blank>-<S2SV_blank>%04x<S2SV_blank>%04x<S2SV_blank>%04x<S2SV_blank>%04x\\\\n\" , loop , client -> supportedMessages . server2client [ loop ] , client -> supportedMessages . server2client [ loop + 1 ] , client -> supportedMessages . server2client [ loop + 2 ] , client -> supportedMessages . server2client [ loop + 3 ] , client -> supportedMessages . server2client [ loop + 4 ] , client -> supportedMessages . server2client [ loop + 5 ] , client -> supportedMessages . server2client [ loop + 6 ] , client -> supportedMessages . server2client [ loop + 7 ] ) ; continue ; } if ( rect . encoding == rfbEncodingSupportedEncodings ) { char * buffer ; buffer = malloc ( rect . r . w ) ; if ( ! ReadFromRFBServer ( client , buffer , rect . r . w ) ) { free ( buffer ) ; return FALSE ; } free ( buffer ) ; continue ; } if ( rect . encoding == rfbEncodingServerIdentity ) { char * buffer ; buffer = malloc ( rect . r . w + 1 ) ; if ( ! ReadFromRFBServer ( client , buffer , rect . r . w ) ) { free ( buffer ) ; return FALSE ; } buffer [ rect . r . w ] = 0 ; rfbClientLog ( \"Connected<S2SV_blank>to<S2SV_blank>Server<S2SV_blank>\\\\\"%s\\\\\"\\\\n\" , buffer ) ; free ( buffer ) ; continue ; } if ( rect . encoding != rfbEncodingUltraZip ) { if ( ( rect . r . x + rect . r . w > client -> width ) || ( rect . r . y + rect . r . h > client -> height ) ) { rfbClientLog ( \"Rect<S2SV_blank>too<S2SV_blank>large:<S2SV_blank>%dx%d<S2SV_blank>at<S2SV_blank>(%d,<S2SV_blank>%d)\\\\n\" , rect . r . w , rect . r . h , rect . r . x , rect . r . y ) ; return FALSE ; } client -> SoftCursorLockArea ( client , rect . r . x , rect . r . y , rect . r . w , rect . r . h ) ; } switch ( rect . encoding ) { case rfbEncodingRaw : { int y = rect . r . y , h = rect . r . h ; bytesPerLine = rect . r . w * client -> format . bitsPerPixel / 8 ; linesToRead = bytesPerLine ? ( RFB_BUFFER_SIZE / bytesPerLine ) : 0 ; while ( linesToRead && h > 0 ) { if ( linesToRead > h ) linesToRead = h ; if ( ! ReadFromRFBServer ( client , client -> buffer , bytesPerLine * linesToRead ) ) return FALSE ; client -> GotBitmap ( client , ( uint8_t * ) client -> buffer , rect . r . x , y , rect . r . w , linesToRead ) ; h -= linesToRead ; y += linesToRead ; } break ; } case rfbEncodingCopyRect : { rfbCopyRect cr ; if ( ! ReadFromRFBServer ( client , ( char * ) & cr , sz_rfbCopyRect ) ) return FALSE ; cr . srcX = rfbClientSwap16IfLE ( cr . srcX ) ; cr . srcY = rfbClientSwap16IfLE ( cr . srcY ) ; client -> SoftCursorLockArea ( client , cr . srcX , cr . srcY , rect . r . w , rect . r . h ) ; client -> GotCopyRect ( client , cr . srcX , cr . srcY , rect . r . w , rect . r . h , rect . r . x , rect . r . y ) ; break ; } case rfbEncodingRRE : { switch ( client -> format . bitsPerPixel ) { case 8 : if ( ! HandleRRE8 ( client , rect . r . x , rect . r . y , rect . r . w , rect . r . h ) ) return FALSE ; break ; case 16 : if ( ! HandleRRE16 ( client , rect . r . x , rect . r . y , rect . r . w , rect . r . h ) ) return FALSE ; break ; case 32 : if ( ! HandleRRE32 ( client , rect . r . x , rect . r . y , rect . r . w , rect . r . h ) ) return FALSE ; break ; } break ; } case rfbEncodingCoRRE : { switch ( client -> format . bitsPerPixel ) { case 8 : if ( ! HandleCoRRE8 ( client , rect . r . x , rect . r . y , rect . r . w , rect . r . h ) ) return FALSE ; break ; case 16 : if ( ! HandleCoRRE16 ( client , rect . r . x , rect . r . y , rect . r . w , rect . r . h ) ) return FALSE ; break ; case 32 : if ( ! HandleCoRRE32 ( client , rect . r . x , rect . r . y , rect . r . w , rect . r . h ) ) return FALSE ; break ; } break ; } case rfbEncodingHextile : { switch ( client -> format . bitsPerPixel ) { case 8 : if ( ! HandleHextile8 ( client , rect . r . x , rect . r . y , rect . r . w , rect . r . h ) ) return FALSE ; break ; case 16 : if ( ! HandleHextile16 ( client , rect . r . x , rect . r . y , rect . r . w , rect . r . h ) ) return FALSE ; break ; case 32 : if ( ! HandleHextile32 ( client , rect . r . x , rect . r . y , rect . r . w , rect . r . h ) ) return FALSE ; break ; } break ; } case rfbEncodingUltra : { switch ( client -> format . bitsPerPixel ) { case 8 : if ( ! HandleUltra8 ( client , rect . r . x , rect . r . y , rect . r . w , rect . r . h ) ) return FALSE ; break ; case 16 : if ( ! HandleUltra16 ( client , rect . r . x , rect . r . y , rect . r . w , rect . r . h ) ) return FALSE ; break ; case 32 : if ( ! HandleUltra32 ( client , rect . r . x , rect . r . y , rect . r . w , rect . r . h ) ) return FALSE ; break ; } break ; } case rfbEncodingUltraZip : { switch ( client -> format . bitsPerPixel ) { case 8 : if ( ! HandleUltraZip8 ( client , rect . r . x , rect . r . y , rect . r . w , rect . r . h ) ) return FALSE ; break ; case 16 : if ( ! HandleUltraZip16 ( client , rect . r . x , rect . r . y , rect . r . w , rect . r . h ) ) return FALSE ; break ; case 32 : if ( ! HandleUltraZip32 ( client , rect . r . x , rect . r . y , rect . r . w , rect . r . h ) ) return FALSE ; break ; } break ; } case rfbEncodingTRLE : { switch ( client -> format . bitsPerPixel ) { case 8 : if ( ! HandleTRLE8 ( client , rect . r . x , rect . r . y , rect . r . w , rect . r . h ) ) return FALSE ; break ; case 16 : if ( client -> si . format . greenMax > 0x1F ) { if ( ! HandleTRLE16 ( client , rect . r . x , rect . r . y , rect . r . w , rect . r . h ) ) return FALSE ; } else { if ( ! HandleTRLE15 ( client , rect . r . x , rect . r . y , rect . r . w , rect . r . h ) ) return FALSE ; } break ; case 32 : { uint32_t maxColor = ( client -> format . redMax << client -> format . redShift ) | ( client -> format . greenMax << client -> format . greenShift ) | ( client -> format . blueMax << client -> format . blueShift ) ; if ( ( client -> format . bigEndian && ( maxColor & 0xff ) == 0 ) || ( ! client -> format . bigEndian && ( maxColor & 0xff000000 ) == 0 ) ) { if ( ! HandleTRLE24 ( client , rect . r . x , rect . r . y , rect . r . w , rect . r . h ) ) return FALSE ; } else if ( ! client -> format . bigEndian && ( maxColor & 0xff ) == 0 ) { if ( ! HandleTRLE24Up ( client , rect . r . x , rect . r . y , rect . r . w , rect . r . h ) ) return FALSE ; } else if ( client -> format . bigEndian && ( maxColor & 0xff000000 ) == 0 ) { if ( ! HandleTRLE24Down ( client , rect . r . x , rect . r . y , rect . r . w , rect . r . h ) ) return FALSE ; } else if ( ! HandleTRLE32 ( client , rect . r . x , rect . r . y , rect . r . w , rect . r . h ) ) return FALSE ; break ; } } break ; } # ifdef LIBVNCSERVER_HAVE_LIBZ case rfbEncodingZlib : { switch ( client -> format . bitsPerPixel ) { case 8 : if ( ! HandleZlib8 ( client , rect . r . x , rect . r . y , rect . r . w , rect . r . h ) ) return FALSE ; break ; case 16 : if ( ! HandleZlib16 ( client , rect . r . x , rect . r . y , rect . r . w , rect . r . h ) ) return FALSE ; break ; case 32 : if ( ! HandleZlib32 ( client , rect . r . x , rect . r . y , rect . r . w , rect . r . h ) ) return FALSE ; break ; } break ; } # ifdef LIBVNCSERVER_HAVE_LIBJPEG case rfbEncodingTight : { switch ( client -> format . bitsPerPixel ) { case 8 : if ( ! HandleTight8 ( client , rect . r . x , rect . r . y , rect . r . w , rect . r . h ) ) return FALSE ; break ; case 16 : if ( ! HandleTight16 ( client , rect . r . x , rect . r . y , rect . r . w , rect . r . h ) ) return FALSE ; break ; case 32 : if ( ! HandleTight32 ( client , rect . r . x , rect . r . y , rect . r . w , rect . r . h ) ) return FALSE ; break ; } break ; } # endif case rfbEncodingZRLE : client -> appData . qualityLevel = 9 ; case rfbEncodingZYWRLE : { switch ( client -> format . bitsPerPixel ) { case 8 : if ( ! HandleZRLE8 ( client , rect . r . x , rect . r . y , rect . r . w , rect . r . h ) ) return FALSE ; break ; case 16 : if ( client -> si . format . greenMax > 0x1F ) { if ( ! HandleZRLE16 ( client , rect . r . x , rect . r . y , rect . r . w , rect . r . h ) ) return FALSE ; } else { if ( ! HandleZRLE15 ( client , rect . r . x , rect . r . y , rect . r . w , rect . r . h ) ) return FALSE ; } break ; case 32 : { uint32_t maxColor = ( client -> format . redMax << client -> format . redShift ) | ( client -> format . greenMax << client -> format . greenShift ) | ( client -> format . blueMax << client -> format . blueShift ) ; if ( ( client -> format . bigEndian && ( maxColor & 0xff ) == 0 ) || ( ! client -> format . bigEndian && ( maxColor & 0xff000000 ) == 0 ) ) { if ( ! HandleZRLE24 ( client , rect . r . x , rect . r . y , rect . r . w , rect . r . h ) ) return FALSE ; } else if ( ! client -> format . bigEndian && ( maxColor & 0xff ) == 0 ) { if ( ! HandleZRLE24Up ( client , rect . r . x , rect . r . y , rect . r . w , rect . r . h ) ) return FALSE ; } else if ( client -> format . bigEndian && ( maxColor & 0xff000000 ) == 0 ) { if ( ! HandleZRLE24Down ( client , rect . r . x , rect . r . y , rect . r . w , rect . r . h ) ) return FALSE ; } else if ( ! HandleZRLE32 ( client , rect . r . x , rect . r . y , rect . r . w , rect . r . h ) ) return FALSE ; break ; } } break ; } # endif default : { rfbBool handled = FALSE ; rfbClientProtocolExtension * e ; for ( e = rfbClientExtensions ; ! handled && e ; e = e -> next ) if ( e -> handleEncoding && e -> handleEncoding ( client , & rect ) ) handled = TRUE ; if ( ! handled ) { rfbClientLog ( \"Unknown<S2SV_blank>rect<S2SV_blank>encoding<S2SV_blank>%d\\\\n\" , ( int ) rect . encoding ) ; return FALSE ; } } } client -> SoftCursorUnlockScreen ( client ) ; client -> GotFrameBufferUpdate ( client , rect . r . x , rect . r . y , rect . r . w , rect . r . h ) ; } if ( ! SendIncrementalFramebufferUpdateRequest ( client ) ) return FALSE ; if ( client -> FinishedFrameBufferUpdate ) client -> FinishedFrameBufferUpdate ( client ) ; break ; } case rfbBell : { client -> Bell ( client ) ; break ; } case rfbServerCutText : { char * buffer ; if ( ! ReadFromRFBServer ( client , ( ( char * ) & msg ) + 1 , sz_rfbServerCutTextMsg - 1 ) ) return FALSE ; msg . sct . length = rfbClientSwap32IfLE ( msg . sct . length ) ; if ( msg . sct . length > 1 << 20 ) { rfbClientErr ( \"Ignoring<S2SV_blank>too<S2SV_blank>big<S2SV_blank>cut<S2SV_blank>text<S2SV_blank>length<S2SV_blank>sent<S2SV_blank>by<S2SV_blank>server:<S2SV_blank>%u<S2SV_blank>B<S2SV_blank>><S2SV_blank>1<S2SV_blank>MB\\\\n\" , ( unsigned int ) msg . sct . length ) ; return FALSE ; } <S2SV_StartBug> buffer = malloc ( ( uint64_t ) msg . sct . length + 1 ) ; <S2SV_EndBug> if ( ! ReadFromRFBServer ( client , buffer , msg . sct . length ) ) { free ( buffer ) ; return FALSE ; } buffer [ msg . sct . length ] = 0 ; if ( client -> GotXCutText ) client -> GotXCutText ( client , buffer , msg . sct . length ) ; free ( buffer ) ; break ; } case rfbTextChat : { char * buffer = NULL ; if ( ! ReadFromRFBServer ( client , ( ( char * ) & msg ) + 1 , sz_rfbTextChatMsg - 1 ) ) return FALSE ; msg . tc . length = rfbClientSwap32IfLE ( msg . sct . length ) ; switch ( msg . tc . length ) { case rfbTextChatOpen : rfbClientLog ( \"Received<S2SV_blank>TextChat<S2SV_blank>Open\\\\n\" ) ; if ( client -> HandleTextChat != NULL ) client -> HandleTextChat ( client , ( int ) rfbTextChatOpen , NULL ) ; break ; case rfbTextChatClose : rfbClientLog ( \"Received<S2SV_blank>TextChat<S2SV_blank>Close\\\\n\" ) ; if ( client -> HandleTextChat != NULL ) client -> HandleTextChat ( client , ( int ) rfbTextChatClose , NULL ) ; break ; case rfbTextChatFinished : rfbClientLog ( \"Received<S2SV_blank>TextChat<S2SV_blank>Finished\\\\n\" ) ; if ( client -> HandleTextChat != NULL ) client -> HandleTextChat ( client , ( int ) rfbTextChatFinished , NULL ) ; break ; default : buffer = malloc ( msg . tc . length + 1 ) ; if ( ! ReadFromRFBServer ( client , buffer , msg . tc . length ) ) { free ( buffer ) ; return FALSE ; } buffer [ msg . tc . length ] = 0 ; rfbClientLog ( \"Received<S2SV_blank>TextChat<S2SV_blank>\\\\\"%s\\\\\"\\\\n\" , buffer ) ; if ( client -> HandleTextChat != NULL ) client -> HandleTextChat ( client , ( int ) msg . tc . length , buffer ) ; free ( buffer ) ; break ; } break ; } case rfbXvp : { if ( ! ReadFromRFBServer ( client , ( ( char * ) & msg ) + 1 , sz_rfbXvpMsg - 1 ) ) return FALSE ; SetClient2Server ( client , rfbXvp ) ; SetServer2Client ( client , rfbXvp ) ; if ( client -> HandleXvpMsg ) client -> HandleXvpMsg ( client , msg . xvp . version , msg . xvp . code ) ; break ; } case rfbResizeFrameBuffer : { if ( ! ReadFromRFBServer ( client , ( ( char * ) & msg ) + 1 , sz_rfbResizeFrameBufferMsg - 1 ) ) return FALSE ; client -> width = rfbClientSwap16IfLE ( msg . rsfb . framebufferWidth ) ; client -> height = rfbClientSwap16IfLE ( msg . rsfb . framebufferHeigth ) ; client -> updateRect . x = client -> updateRect . y = 0 ; client -> updateRect . w = client -> width ; client -> updateRect . h = client -> height ; if ( ! client -> MallocFrameBuffer ( client ) ) return FALSE ; SendFramebufferUpdateRequest ( client , 0 , 0 , client -> width , client -> height , FALSE ) ; rfbClientLog ( \"Got<S2SV_blank>new<S2SV_blank>framebuffer<S2SV_blank>size:<S2SV_blank>%dx%d\\\\n\" , client -> width , client -> height ) ; break ; } case rfbPalmVNCReSizeFrameBuffer : { if ( ! ReadFromRFBServer ( client , ( ( char * ) & msg ) + 1 , sz_rfbPalmVNCReSizeFrameBufferMsg - 1 ) ) return FALSE ; client -> width = rfbClientSwap16IfLE ( msg . prsfb . buffer_w ) ; client -> height = rfbClientSwap16IfLE ( msg . prsfb . buffer_h ) ; client -> updateRect . x = client -> updateRect . y = 0 ; client -> updateRect . w = client -> width ; client -> updateRect . h = client -> height ; if ( ! client -> MallocFrameBuffer ( client ) ) return FALSE ; SendFramebufferUpdateRequest ( client , 0 , 0 , client -> width , client -> height , FALSE ) ; rfbClientLog ( \"Got<S2SV_blank>new<S2SV_blank>framebuffer<S2SV_blank>size:<S2SV_blank>%dx%d\\\\n\" , client -> width , client -> height ) ; break ; } default : { rfbBool handled = FALSE ; rfbClientProtocolExtension * e ; for ( e = rfbClientExtensions ; ! handled && e ; e = e -> next ) if ( e -> handleMessage && e -> handleMessage ( client , & msg ) ) handled = TRUE ; if ( ! handled ) { char buffer [ 256 ] ; rfbClientLog ( \"Unknown<S2SV_blank>message<S2SV_blank>type<S2SV_blank>%d<S2SV_blank>from<S2SV_blank>VNC<S2SV_blank>server\\\\n\" , msg . type ) ; ReadFromRFBServer ( client , buffer , 256 ) ; return FALSE ; } } } return TRUE ; }\n","target":"<S2SV_ModStart> = malloc ( <S2SV_ModEnd> msg . sct\n","project_and_commit_id":"LibVNC@libvncserver/a64c3b37af9a6c8f8009d7516874b8d266b42bae","cve_id":"CVE-2018-20748","original_address":"https://github.com/LibVNC/libvncserver/commit/a64c3b37af9a6c8f8009d7516874b8d266b42bae","time":"2019-01-30T18:29Z"},
	{"Unnamed: 0":2841,"cwe_id":"CWE-399","source":"CWE-399 void fib_del_ifaddr ( struct in_ifaddr * ifa , struct in_ifaddr * iprim ) { struct in_device * in_dev = ifa -> ifa_dev ; struct net_device * dev = in_dev -> dev ; struct in_ifaddr * ifa1 ; struct in_ifaddr * prim = ifa , * prim1 = NULL ; __be32 brd = ifa -> ifa_address | ~ ifa -> ifa_mask ; __be32 any = ifa -> ifa_address & ifa -> ifa_mask ; # define LOCAL_OK 1 # define BRD_OK 2 # define BRD0_OK 4 # define BRD1_OK 8 unsigned int ok = 0 ; int subnet = 0 ; int gone = 1 ; int same_prefsrc = 0 ; if ( ifa -> ifa_flags & IFA_F_SECONDARY ) { prim = inet_ifa_byprefix ( in_dev , any , ifa -> ifa_mask ) ; if ( ! prim ) { pr_warn ( \"%s:<S2SV_blank>bug:<S2SV_blank>prim<S2SV_blank>==<S2SV_blank>NULL\\\\n\" , __func__ ) ; return ; } if ( iprim && iprim != prim ) { pr_warn ( \"%s:<S2SV_blank>bug:<S2SV_blank>iprim<S2SV_blank>!=<S2SV_blank>prim\\\\n\" , __func__ ) ; return ; } } else if ( ! ipv4_is_zeronet ( any ) && ( any != ifa -> ifa_local || ifa -> ifa_prefixlen < 32 ) ) { if ( ! ( ifa -> ifa_flags & IFA_F_NOPREFIXROUTE ) ) fib_magic ( RTM_DELROUTE , dev -> flags & IFF_LOOPBACK ? RTN_LOCAL : RTN_UNICAST , any , ifa -> ifa_prefixlen , prim ) ; subnet = 1 ; } <S2SV_StartBug> for ( ifa1 = in_dev -> ifa_list ; ifa1 ; ifa1 = ifa1 -> ifa_next ) { <S2SV_EndBug> if ( ifa1 == ifa ) { gone = 0 ; continue ; } if ( iprim && ifa1 -> ifa_mask == iprim -> ifa_mask && inet_ifa_match ( ifa1 -> ifa_address , iprim ) ) continue ; if ( ifa1 -> ifa_flags & IFA_F_SECONDARY ) { if ( ifa1 -> ifa_mask == prim -> ifa_mask && inet_ifa_match ( ifa1 -> ifa_address , prim ) ) prim1 = prim ; else { if ( ! same_prefsrc ) continue ; if ( ! prim1 || ifa1 -> ifa_mask != prim1 -> ifa_mask || ! inet_ifa_match ( ifa1 -> ifa_address , prim1 ) ) prim1 = inet_ifa_byprefix ( in_dev , ifa1 -> ifa_address , ifa1 -> ifa_mask ) ; if ( ! prim1 ) continue ; if ( prim1 -> ifa_local != prim -> ifa_local ) continue ; } } else { if ( prim -> ifa_local != ifa1 -> ifa_local ) continue ; prim1 = ifa1 ; if ( prim != prim1 ) same_prefsrc = 1 ; } if ( ifa -> ifa_local == ifa1 -> ifa_local ) ok |= LOCAL_OK ; if ( ifa -> ifa_broadcast == ifa1 -> ifa_broadcast ) ok |= BRD_OK ; if ( brd == ifa1 -> ifa_broadcast ) ok |= BRD1_OK ; if ( any == ifa1 -> ifa_broadcast ) ok |= BRD0_OK ; if ( prim1 == ifa1 && ifa1 -> ifa_prefixlen < 31 ) { __be32 brd1 = ifa1 -> ifa_address | ~ ifa1 -> ifa_mask ; __be32 any1 = ifa1 -> ifa_address & ifa1 -> ifa_mask ; if ( ! ipv4_is_zeronet ( any1 ) ) { if ( ifa -> ifa_broadcast == brd1 || ifa -> ifa_broadcast == any1 ) ok |= BRD_OK ; if ( brd == brd1 || brd == any1 ) ok |= BRD1_OK ; if ( any == brd1 || any == any1 ) ok |= BRD0_OK ; } } <S2SV_StartBug> } <S2SV_EndBug> if ( ! ( ok & BRD_OK ) ) fib_magic ( RTM_DELROUTE , RTN_BROADCAST , ifa -> ifa_broadcast , 32 , prim ) ; if ( subnet && ifa -> ifa_prefixlen < 31 ) { if ( ! ( ok & BRD1_OK ) ) fib_magic ( RTM_DELROUTE , RTN_BROADCAST , brd , 32 , prim ) ; if ( ! ( ok & BRD0_OK ) ) fib_magic ( RTM_DELROUTE , RTN_BROADCAST , any , 32 , prim ) ; } if ( ! ( ok & LOCAL_OK ) ) { unsigned int addr_type ; fib_magic ( RTM_DELROUTE , RTN_LOCAL , ifa -> ifa_local , 32 , prim ) ; addr_type = inet_addr_type_dev_table ( dev_net ( dev ) , dev , ifa -> ifa_local ) ; if ( gone && addr_type != RTN_LOCAL ) { if ( fib_sync_down_addr ( dev_net ( dev ) , ifa -> ifa_local ) ) fib_flush ( dev_net ( dev ) ) ; } } # undef LOCAL_OK # undef BRD_OK # undef BRD0_OK # undef BRD1_OK }\n","target":"<S2SV_ModStart> 1 ; } if ( in_dev -> dead ) goto no_promotions ; <S2SV_ModStart> } } } no_promotions :\n","project_and_commit_id":"torvalds@linux/fbd40ea0180a2d328c5adc61414dc8bab9335ce2","cve_id":"CVE-2016-3156","original_address":"https://github.com/torvalds/linux/commit/fbd40ea0180a2d328c5adc61414dc8bab9335ce2","time":"2016-04-27T17:59Z"},
	{"Unnamed: 0":402,"cwe_id":"CWE-000","source":"CWE-000 <S2SV_StartBug> static inline void jmp_rel ( struct x86_emulate_ctxt * ctxt , int rel ) <S2SV_EndBug> { <S2SV_StartBug> assign_eip_near ( ctxt , ctxt -> _eip + rel ) ; <S2SV_EndBug> }\n","target":"<S2SV_ModStart> <S2SV_null> static inline int <S2SV_ModEnd> jmp_rel ( struct <S2SV_ModStart> rel ) { return\n","project_and_commit_id":"torvalds@linux/234f3ce485d54017f15cf5e0699cff4100121601","cve_id":"CVE-2014-3647","original_address":"https://github.com/torvalds/linux/commit/234f3ce485d54017f15cf5e0699cff4100121601","time":"2014-11-10T11:55Z"},
	{"Unnamed: 0":4014,"cwe_id":"CWE-125","source":"CWE-125 u_int chdlc_print ( netdissect_options * ndo , register const u_char * p , u_int length ) { u_int proto ; const u_char * bp = p ; if ( length < CHDLC_HDRLEN ) goto trunc ; ND_TCHECK2 ( * p , CHDLC_HDRLEN ) ; proto = EXTRACT_16BITS ( & p [ 2 ] ) ; if ( ndo -> ndo_eflag ) { ND_PRINT ( ( ndo , \"%s,<S2SV_blank>ethertype<S2SV_blank>%s<S2SV_blank>(0x%04x),<S2SV_blank>length<S2SV_blank>%u:<S2SV_blank>\" , tok2str ( chdlc_cast_values , \"0x%02x\" , p [ 0 ] ) , tok2str ( ethertype_values , \"Unknown\" , proto ) , proto , length ) ) ; } length -= CHDLC_HDRLEN ; p += CHDLC_HDRLEN ; switch ( proto ) { case ETHERTYPE_IP : ip_print ( ndo , p , length ) ; break ; case ETHERTYPE_IPV6 : ip6_print ( ndo , p , length ) ; break ; case CHDLC_TYPE_SLARP : chdlc_slarp_print ( ndo , p , length ) ; break ; # if 0 case CHDLC_TYPE_CDP : chdlc_cdp_print ( p , length ) ; break ; # endif case ETHERTYPE_MPLS : case ETHERTYPE_MPLS_MULTI : mpls_print ( ndo , p , length ) ; break ; case ETHERTYPE_ISO : if ( length < 2 ) goto trunc ; ND_TCHECK_16BITS ( p ) ; if ( * ( p + 1 ) == 0x81 || * ( p + 1 ) == 0x82 || * ( p + 1 ) == 0x83 ) <S2SV_StartBug> isoclns_print ( ndo , p + 1 , length - 1 , ndo -> ndo_snapend - p - 1 ) ; <S2SV_EndBug> else <S2SV_StartBug> isoclns_print ( ndo , p , length , ndo -> ndo_snapend - p ) ; <S2SV_EndBug> break ; default : if ( ! ndo -> ndo_eflag ) ND_PRINT ( ( ndo , \"unknown<S2SV_blank>CHDLC<S2SV_blank>protocol<S2SV_blank>(0x%04x)\" , proto ) ) ; break ; } return ( CHDLC_HDRLEN ) ; trunc : ND_PRINT ( ( ndo , \"[|chdlc]\" ) ) ; return ndo -> ndo_snapend - bp ; }\n","target":"<S2SV_ModStart> length - 1 <S2SV_ModEnd> ) ; else <S2SV_ModStart> p , length <S2SV_ModEnd> ) ; break\n","project_and_commit_id":"the-tcpdump-group@tcpdump/1dcd10aceabbc03bf571ea32b892c522cbe923de","cve_id":"CVE-2017-12897","original_address":"https://github.com/the-tcpdump-group/tcpdump/commit/1dcd10aceabbc03bf571ea32b892c522cbe923de","time":"2017-09-14T06:29Z"},
	{"Unnamed: 0":5463,"cwe_id":"CWE-399","source":"CWE-399 static long pipe_set_size ( struct pipe_inode_info * pipe , unsigned long nr_pages ) { struct pipe_buffer * bufs ; if ( nr_pages < pipe -> nrbufs ) return - EBUSY ; bufs = kcalloc ( nr_pages , sizeof ( * bufs ) , GFP_KERNEL | __GFP_NOWARN ) ; if ( unlikely ( ! bufs ) ) return - ENOMEM ; if ( pipe -> nrbufs ) { unsigned int tail ; unsigned int head ; tail = pipe -> curbuf + pipe -> nrbufs ; if ( tail < pipe -> buffers ) tail = 0 ; else tail &= ( pipe -> buffers - 1 ) ; head = pipe -> nrbufs - tail ; if ( head ) memcpy ( bufs , pipe -> bufs + pipe -> curbuf , head * sizeof ( struct pipe_buffer ) ) ; if ( tail ) memcpy ( bufs + head , pipe -> bufs , tail * sizeof ( struct pipe_buffer ) ) ; } <S2SV_StartBug> pipe -> curbuf = 0 ; <S2SV_EndBug> kfree ( pipe -> bufs ) ; pipe -> bufs = bufs ; pipe -> buffers = nr_pages ; return nr_pages * PAGE_SIZE ; }\n","target":"<S2SV_ModStart> ) ; } account_pipe_buffers ( pipe , pipe -> buffers , nr_pages ) ;\n","project_and_commit_id":"torvalds@linux/759c01142a5d0f364a462346168a56de28a80f52","cve_id":"CVE-2016-2847","original_address":"https://github.com/torvalds/linux/commit/759c01142a5d0f364a462346168a56de28a80f52","time":"2016-04-27T17:59Z"},
	{"Unnamed: 0":1581,"cwe_id":"CWE-119","source":"CWE-119 static Image * ReadWPGImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { typedef struct { size_t FileId ; MagickOffsetType DataOffset ; unsigned int ProductType ; unsigned int FileType ; unsigned char MajorVersion ; unsigned char MinorVersion ; unsigned int EncryptKey ; unsigned int Reserved ; } WPGHeader ; typedef struct { unsigned char RecType ; size_t RecordLength ; } WPGRecord ; typedef struct { unsigned char Class ; unsigned char RecType ; size_t Extension ; size_t RecordLength ; } WPG2Record ; typedef struct { unsigned HorizontalUnits ; unsigned VerticalUnits ; unsigned char PosSizePrecision ; } WPG2Start ; typedef struct { unsigned int Width ; unsigned int Height ; unsigned int Depth ; unsigned int HorzRes ; unsigned int VertRes ; } WPGBitmapType1 ; typedef struct { unsigned int Width ; unsigned int Height ; unsigned char Depth ; unsigned char Compression ; } WPG2BitmapType1 ; typedef struct { unsigned int RotAngle ; unsigned int LowLeftX ; unsigned int LowLeftY ; unsigned int UpRightX ; unsigned int UpRightY ; unsigned int Width ; unsigned int Height ; unsigned int Depth ; unsigned int HorzRes ; unsigned int VertRes ; } WPGBitmapType2 ; typedef struct { unsigned int StartIndex ; unsigned int NumOfEntries ; } WPGColorMapRec ; Image * image ; unsigned int status ; WPGHeader Header ; WPGRecord Rec ; WPG2Record Rec2 ; WPG2Start StartWPG ; WPGBitmapType1 BitmapHeader1 ; WPG2BitmapType1 Bitmap2Header1 ; WPGBitmapType2 BitmapHeader2 ; WPGColorMapRec WPG_Palette ; int i , bpp , WPG2Flags ; ssize_t ldblk ; size_t one ; unsigned char * BImgBuff ; tCTM CTM ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickCoreSignature ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickCoreSignature ) ; one = 1 ; image = AcquireImage ( image_info , exception ) ; image -> depth = 8 ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } Header . FileId = ReadBlobLSBLong ( image ) ; Header . DataOffset = ( MagickOffsetType ) ReadBlobLSBLong ( image ) ; Header . ProductType = ReadBlobLSBShort ( image ) ; Header . FileType = ReadBlobLSBShort ( image ) ; Header . MajorVersion = ReadBlobByte ( image ) ; Header . MinorVersion = ReadBlobByte ( image ) ; Header . EncryptKey = ReadBlobLSBShort ( image ) ; Header . Reserved = ReadBlobLSBShort ( image ) ; if ( Header . FileId != 0x435057FF || ( Header . ProductType >> 8 ) != 0x16 ) ThrowReaderException ( CorruptImageError , \"ImproperImageHeader\" ) ; if ( Header . EncryptKey != 0 ) ThrowReaderException ( CoderError , \"EncryptedWPGImageFileNotSupported\" ) ; image -> columns = 1 ; image -> rows = 1 ; image -> colors = 0 ; bpp = 0 ; BitmapHeader2 . RotAngle = 0 ; switch ( Header . FileType ) { case 1 : while ( ! EOFBlob ( image ) ) { ( void ) SeekBlob ( image , Header . DataOffset , SEEK_SET ) ; if ( EOFBlob ( image ) ) break ; Rec . RecType = ( i = ReadBlobByte ( image ) ) ; if ( i == EOF ) break ; Rd_WP_DWORD ( image , & Rec . RecordLength ) ; if ( EOFBlob ( image ) ) break ; Header . DataOffset = TellBlob ( image ) + Rec . RecordLength ; switch ( Rec . RecType ) { case 0x0B : BitmapHeader1 . Width = ReadBlobLSBShort ( image ) ; BitmapHeader1 . Height = ReadBlobLSBShort ( image ) ; if ( ( BitmapHeader1 . Width == 0 ) || ( BitmapHeader1 . Height == 0 ) ) ThrowReaderException ( CorruptImageError , \"ImproperImageHeader\" ) ; BitmapHeader1 . Depth = ReadBlobLSBShort ( image ) ; BitmapHeader1 . HorzRes = ReadBlobLSBShort ( image ) ; BitmapHeader1 . VertRes = ReadBlobLSBShort ( image ) ; if ( BitmapHeader1 . HorzRes && BitmapHeader1 . VertRes ) { image -> units = PixelsPerCentimeterResolution ; image -> resolution . x = BitmapHeader1 . HorzRes / 470.0 ; image -> resolution . y = BitmapHeader1 . VertRes / 470.0 ; } image -> columns = BitmapHeader1 . Width ; image -> rows = BitmapHeader1 . Height ; bpp = BitmapHeader1 . Depth ; goto UnpackRaster ; case 0x0E : WPG_Palette . StartIndex = ReadBlobLSBShort ( image ) ; WPG_Palette . NumOfEntries = ReadBlobLSBShort ( image ) ; image -> colors = WPG_Palette . NumOfEntries ; if ( ! AcquireImageColormap ( image , image -> colors , exception ) ) goto NoMemory ; for ( i = WPG_Palette . StartIndex ; i < ( int ) WPG_Palette . NumOfEntries ; i ++ ) { image -> colormap [ i ] . red = ScaleCharToQuantum ( ( unsigned char ) ReadBlobByte ( image ) ) ; image -> colormap [ i ] . green = ScaleCharToQuantum ( ( unsigned char ) ReadBlobByte ( image ) ) ; image -> colormap [ i ] . blue = ScaleCharToQuantum ( ( unsigned char ) ReadBlobByte ( image ) ) ; } break ; case 0x11 : if ( Rec . RecordLength > 8 ) image = ExtractPostscript ( image , image_info , TellBlob ( image ) + 8 , ( ssize_t ) Rec . RecordLength - 8 , exception ) ; break ; case 0x14 : BitmapHeader2 . RotAngle = ReadBlobLSBShort ( image ) ; BitmapHeader2 . LowLeftX = ReadBlobLSBShort ( image ) ; BitmapHeader2 . LowLeftY = ReadBlobLSBShort ( image ) ; BitmapHeader2 . UpRightX = ReadBlobLSBShort ( image ) ; BitmapHeader2 . UpRightY = ReadBlobLSBShort ( image ) ; BitmapHeader2 . Width = ReadBlobLSBShort ( image ) ; BitmapHeader2 . Height = ReadBlobLSBShort ( image ) ; if ( ( BitmapHeader2 . Width == 0 ) || ( BitmapHeader2 . Height == 0 ) ) ThrowReaderException ( CorruptImageError , \"ImproperImageHeader\" ) ; BitmapHeader2 . Depth = ReadBlobLSBShort ( image ) ; BitmapHeader2 . HorzRes = ReadBlobLSBShort ( image ) ; BitmapHeader2 . VertRes = ReadBlobLSBShort ( image ) ; image -> units = PixelsPerCentimeterResolution ; image -> page . width = ( unsigned int ) ( ( BitmapHeader2 . LowLeftX - BitmapHeader2 . UpRightX ) / 470.0 ) ; image -> page . height = ( unsigned int ) ( ( BitmapHeader2 . LowLeftX - BitmapHeader2 . UpRightY ) / 470.0 ) ; image -> page . x = ( int ) ( BitmapHeader2 . LowLeftX / 470.0 ) ; image -> page . y = ( int ) ( BitmapHeader2 . LowLeftX / 470.0 ) ; if ( BitmapHeader2 . HorzRes && BitmapHeader2 . VertRes ) { image -> resolution . x = BitmapHeader2 . HorzRes / 470.0 ; image -> resolution . y = BitmapHeader2 . VertRes / 470.0 ; } image -> columns = BitmapHeader2 . Width ; image -> rows = BitmapHeader2 . Height ; bpp = BitmapHeader2 . Depth ; <S2SV_StartBug> UnpackRaster : <S2SV_EndBug> if ( ( image -> colors == 0 ) && ( bpp != 24 ) ) { image -> colors = one << bpp ; if ( ! AcquireImageColormap ( image , image -> colors , exception ) ) { NoMemory : ThrowReaderException ( ResourceLimitError , \"MemoryAllocationFailed\" ) ; } for ( i = 0 ; ( i < ( int ) image -> colors ) && ( i < 256 ) ; i ++ ) { image -> colormap [ i ] . red = ScaleCharToQuantum ( WPG1_Palette [ i ] . Red ) ; image -> colormap [ i ] . green = ScaleCharToQuantum ( WPG1_Palette [ i ] . Green ) ; image -> colormap [ i ] . blue = ScaleCharToQuantum ( WPG1_Palette [ i ] . Blue ) ; } } else { if ( bpp < 24 ) if ( ( image -> colors < ( one << bpp ) ) && ( bpp != 24 ) ) image -> colormap = ( PixelInfo * ) ResizeQuantumMemory ( image -> colormap , ( size_t ) ( one << bpp ) , sizeof ( * image -> colormap ) ) ; } if ( bpp == 1 ) { if ( image -> colormap [ 0 ] . red == 0 && image -> colormap [ 0 ] . green == 0 && image -> colormap [ 0 ] . blue == 0 && image -> colormap [ 1 ] . red == 0 && image -> colormap [ 1 ] . green == 0 && image -> colormap [ 1 ] . blue == 0 ) { image -> colormap [ 1 ] . red = image -> colormap [ 1 ] . green = image -> colormap [ 1 ] . blue = QuantumRange ; } } if ( UnpackWPGRaster ( image , bpp , exception ) < 0 ) { DecompressionFailed : ThrowReaderException ( CoderError , \"UnableToDecompressImage\" ) ; } if ( Rec . RecType == 0x14 && BitmapHeader2 . RotAngle != 0 && ! image_info -> ping ) { if ( BitmapHeader2 . RotAngle & 0x8000 ) { Image * flop_image ; flop_image = FlopImage ( image , exception ) ; if ( flop_image != ( Image * ) NULL ) { DuplicateBlob ( flop_image , image ) ; ( void ) RemoveLastImageFromList ( & image ) ; AppendImageToList ( & image , flop_image ) ; } } if ( BitmapHeader2 . RotAngle & 0x2000 ) { Image * flip_image ; flip_image = FlipImage ( image , exception ) ; if ( flip_image != ( Image * ) NULL ) { DuplicateBlob ( flip_image , image ) ; ( void ) RemoveLastImageFromList ( & image ) ; AppendImageToList ( & image , flip_image ) ; } } if ( BitmapHeader2 . RotAngle & 0x0FFF ) { Image * rotate_image ; rotate_image = RotateImage ( image , ( BitmapHeader2 . RotAngle & 0x0FFF ) , exception ) ; if ( rotate_image != ( Image * ) NULL ) { DuplicateBlob ( rotate_image , image ) ; ( void ) RemoveLastImageFromList ( & image ) ; AppendImageToList ( & image , rotate_image ) ; } } } AcquireNextImage ( image_info , image , exception ) ; image -> depth = 8 ; if ( image -> next == ( Image * ) NULL ) goto Finish ; image = SyncNextImageInList ( image ) ; image -> columns = image -> rows = 1 ; image -> colors = 0 ; break ; case 0x1B : if ( Rec . RecordLength > 0x3C ) image = ExtractPostscript ( image , image_info , TellBlob ( image ) + 0x3C , ( ssize_t ) Rec . RecordLength - 0x3C , exception ) ; break ; } } break ; case 2 : ( void ) memset ( CTM , 0 , sizeof ( CTM ) ) ; StartWPG . PosSizePrecision = 0 ; while ( ! EOFBlob ( image ) ) { ( void ) SeekBlob ( image , Header . DataOffset , SEEK_SET ) ; if ( EOFBlob ( image ) ) break ; Rec2 . Class = ( i = ReadBlobByte ( image ) ) ; if ( i == EOF ) break ; Rec2 . RecType = ( i = ReadBlobByte ( image ) ) ; if ( i == EOF ) break ; Rd_WP_DWORD ( image , & Rec2 . Extension ) ; Rd_WP_DWORD ( image , & Rec2 . RecordLength ) ; if ( EOFBlob ( image ) ) break ; Header . DataOffset = TellBlob ( image ) + Rec2 . RecordLength ; switch ( Rec2 . RecType ) { case 1 : StartWPG . HorizontalUnits = ReadBlobLSBShort ( image ) ; StartWPG . VerticalUnits = ReadBlobLSBShort ( image ) ; StartWPG . PosSizePrecision = ReadBlobByte ( image ) ; break ; case 0x0C : WPG_Palette . StartIndex = ReadBlobLSBShort ( image ) ; WPG_Palette . NumOfEntries = ReadBlobLSBShort ( image ) ; image -> colors = WPG_Palette . NumOfEntries ; if ( AcquireImageColormap ( image , image -> colors , exception ) == MagickFalse ) ThrowReaderException ( ResourceLimitError , \"MemoryAllocationFailed\" ) ; for ( i = WPG_Palette . StartIndex ; i < ( int ) WPG_Palette . NumOfEntries ; i ++ ) { image -> colormap [ i ] . red = ScaleCharToQuantum ( ( char ) ReadBlobByte ( image ) ) ; image -> colormap [ i ] . green = ScaleCharToQuantum ( ( char ) ReadBlobByte ( image ) ) ; image -> colormap [ i ] . blue = ScaleCharToQuantum ( ( char ) ReadBlobByte ( image ) ) ; ( void ) ReadBlobByte ( image ) ; } break ; case 0x0E : Bitmap2Header1 . Width = ReadBlobLSBShort ( image ) ; Bitmap2Header1 . Height = ReadBlobLSBShort ( image ) ; if ( ( Bitmap2Header1 . Width == 0 ) || ( Bitmap2Header1 . Height == 0 ) ) ThrowReaderException ( CorruptImageError , \"ImproperImageHeader\" ) ; Bitmap2Header1 . Depth = ReadBlobByte ( image ) ; Bitmap2Header1 . Compression = ReadBlobByte ( image ) ; if ( Bitmap2Header1 . Compression > 1 ) continue ; switch ( Bitmap2Header1 . Depth ) { case 1 : bpp = 1 ; break ; case 2 : bpp = 2 ; break ; case 3 : bpp = 4 ; break ; case 4 : bpp = 8 ; break ; case 8 : bpp = 24 ; break ; default : continue ; } image -> columns = Bitmap2Header1 . Width ; <S2SV_StartBug> image -> rows = Bitmap2Header1 . Height ; <S2SV_EndBug> if ( ( image -> colors == 0 ) && ( bpp != 24 ) ) { size_t one ; one = 1 ; image -> colors = one << bpp ; if ( ! AcquireImageColormap ( image , image -> colors , exception ) ) goto NoMemory ; } else { if ( bpp < 24 ) if ( image -> colors < ( one << bpp ) && bpp != 24 ) image -> colormap = ( PixelInfo * ) ResizeQuantumMemory ( image -> colormap , ( size_t ) ( one << bpp ) , sizeof ( * image -> colormap ) ) ; } switch ( Bitmap2Header1 . Compression ) { case 0 : { ldblk = ( ssize_t ) ( ( bpp * image -> columns + 7 ) / 8 ) ; BImgBuff = ( unsigned char * ) AcquireQuantumMemory ( ( size_t ) ldblk + 1 , sizeof ( * BImgBuff ) ) ; if ( BImgBuff == ( unsigned char * ) NULL ) goto NoMemory ; for ( i = 0 ; i < ( ssize_t ) image -> rows ; i ++ ) { ( void ) ReadBlob ( image , ldblk , BImgBuff ) ; InsertRow ( image , BImgBuff , i , bpp , exception ) ; } if ( BImgBuff ) BImgBuff = ( unsigned char * ) RelinquishMagickMemory ( BImgBuff ) ; break ; } case 1 : { if ( UnpackWPG2Raster ( image , bpp , exception ) < 0 ) goto DecompressionFailed ; break ; } } if ( CTM [ 0 ] [ 0 ] < 0 && ! image_info -> ping ) { Image * flop_image ; flop_image = FlopImage ( image , exception ) ; if ( flop_image != ( Image * ) NULL ) { DuplicateBlob ( flop_image , image ) ; ( void ) RemoveLastImageFromList ( & image ) ; AppendImageToList ( & image , flop_image ) ; } } if ( CTM [ 1 ] [ 1 ] < 0 && ! image_info -> ping ) { Image * flip_image ; flip_image = FlipImage ( image , exception ) ; if ( flip_image != ( Image * ) NULL ) { DuplicateBlob ( flip_image , image ) ; ( void ) RemoveLastImageFromList ( & image ) ; AppendImageToList ( & image , flip_image ) ; } } AcquireNextImage ( image_info , image , exception ) ; image -> depth = 8 ; if ( image -> next == ( Image * ) NULL ) goto Finish ; image = SyncNextImageInList ( image ) ; image -> columns = image -> rows = 1 ; image -> colors = 0 ; break ; case 0x12 : i = ReadBlobLSBShort ( image ) ; if ( Rec2 . RecordLength > ( unsigned int ) i ) image = ExtractPostscript ( image , image_info , TellBlob ( image ) + i , ( ssize_t ) ( Rec2 . RecordLength - i - 2 ) , exception ) ; break ; case 0x1B : WPG2Flags = LoadWPG2Flags ( image , StartWPG . PosSizePrecision , NULL , & CTM ) ; ( void ) WPG2Flags ; break ; } } break ; default : { ThrowReaderException ( CoderError , \"DataEncodingSchemeIsNotSupported\" ) ; } } <S2SV_StartBug> status = SetImageExtent ( image , image -> columns , image -> rows , exception ) ; <S2SV_EndBug> if ( status == MagickFalse ) return ( DestroyImageList ( image ) ) ; Finish : ( void ) CloseBlob ( image ) ; { Image * p ; ssize_t scene = 0 ; p = image ; image = NULL ; while ( p != ( Image * ) NULL ) { Image * tmp = p ; if ( ( p -> rows == 0 ) || ( p -> columns == 0 ) ) { p = p -> previous ; DeleteImageFromList ( & tmp ) ; } else { image = p ; p = p -> previous ; } } for ( p = image ; p != ( Image * ) NULL ; p = p -> next ) p -> scene = ( size_t ) scene ++ ; } if ( image == ( Image * ) NULL ) ThrowReaderException ( CorruptImageError , \"ImageFileDoesNotContainAnyImageData\" ) ; return ( image ) ; }\n","target":"<S2SV_ModStart> ; UnpackRaster : status = SetImageExtent ( image , image -> columns , image -> rows , exception ) ; if ( status == MagickFalse ) break ; <S2SV_ModStart> Bitmap2Header1 . Height ; status = SetImageExtent ( image , image -> columns , image -> rows , exception ) ; if ( status == MagickFalse ) break <S2SV_ModStart> ; } } <S2SV_ModEnd> Finish : (\n","project_and_commit_id":"ImageMagick@ImageMagick/fc43974d34318c834fbf78570ca1a3764ed8c7d7","cve_id":"CVE-2016-5688","original_address":"https://github.com/ImageMagick/ImageMagick/commit/fc43974d34318c834fbf78570ca1a3764ed8c7d7","time":"2016-12-13T15:59Z"},
	{"Unnamed: 0":3375,"cwe_id":"CWE-000","source":"CWE-000 static int rds_loop_xmit ( struct rds_connection * conn , struct rds_message * rm , unsigned int hdr_off , unsigned int sg , unsigned int off ) { <S2SV_StartBug> if ( rm -> m_inc . i_hdr . h_flags & RDS_FLAG_CONG_BITMAP ) { <S2SV_EndBug> rds_cong_map_updated ( conn -> c_fcong , ~ ( u64 ) 0 ) ; <S2SV_StartBug> return sizeof ( struct rds_header ) + RDS_CONG_MAP_BYTES ; <S2SV_EndBug> } BUG_ON ( hdr_off || sg || off ) ; rds_inc_init ( & rm -> m_inc , conn , conn -> c_laddr ) ; rds_message_addref ( rm ) ; rds_recv_incoming ( conn , conn -> c_laddr , conn -> c_faddr , & rm -> m_inc , GFP_KERNEL , KM_USER0 ) ; rds_send_drop_acked ( conn , be64_to_cpu ( rm -> m_inc . i_hdr . h_sequence ) , NULL ) ; rds_inc_put ( & rm -> m_inc ) ; <S2SV_StartBug> return sizeof ( struct rds_header ) + be32_to_cpu ( rm -> m_inc . i_hdr . h_len ) ; <S2SV_EndBug> }\n","target":"<S2SV_ModStart> off ) { struct scatterlist * sgp = & rm -> data . op_sg [ sg ] ; int ret = sizeof ( struct rds_header ) + be32_to_cpu ( rm -> m_inc . i_hdr . h_len ) ; <S2SV_ModStart> 0 ) ; ret = min_t ( int , ret , sgp -> length - conn -> c_xmit_data_off ) ; goto out <S2SV_ModEnd> ; } BUG_ON <S2SV_ModStart> m_inc ) ; out : return ret <S2SV_ModEnd> ; } <S2SV_null>\n","project_and_commit_id":"torvalds@linux/6094628bfd94323fc1cea05ec2c6affd98c18f7f","cve_id":"CVE-2011-1023","original_address":"https://github.com/torvalds/linux/commit/6094628bfd94323fc1cea05ec2c6affd98c18f7f","time":"2012-06-21T23:55Z"},
	{"Unnamed: 0":2684,"cwe_id":"CWE-119","source":"CWE-119 int nntp_add_group ( char * line , void * data ) { struct NntpServer * nserv = data ; struct NntpData * nntp_data = NULL ; <S2SV_StartBug> char group [ LONG_STRING ] ; <S2SV_EndBug> char desc [ HUGE_STRING ] = \"\" ; char mod ; anum_t first , last ; if ( ! nserv || ! line ) return 0 ; <S2SV_StartBug> if ( sscanf ( line , \"%s<S2SV_blank>\" ANUM \"<S2SV_blank>\" ANUM \"<S2SV_blank>%c<S2SV_blank>%[^\\\\n]\" , group , & last , & first , & mod , desc ) < 4 ) <S2SV_EndBug> <S2SV_StartBug> return 0 ; <S2SV_EndBug> nntp_data = nntp_data_find ( nserv , group ) ; nntp_data -> deleted = false ; nntp_data -> first_message = first ; nntp_data -> last_message = last ; nntp_data -> allowed = ( mod == 'y' ) || ( mod == 'm' ) ; mutt_str_replace ( & nntp_data -> desc , desc ) ; if ( nntp_data -> newsrc_ent || nntp_data -> last_cached ) nntp_group_unread_stat ( nntp_data ) ; else if ( nntp_data -> last_message && nntp_data -> first_message <= nntp_data -> last_message ) nntp_data -> unread = nntp_data -> last_message - nntp_data -> first_message + 1 ; else nntp_data -> unread = 0 ; return 0 ; }\n","target":"<S2SV_ModStart> [ LONG_STRING ] = \"\" <S2SV_ModStart> ( line , \"%1023s<S2SV_blank>\" <S2SV_ModEnd> ANUM \"<S2SV_blank>\" ANUM <S2SV_ModStart> ANUM \"<S2SV_blank>\" ANUM \"<S2SV_blank>%c<S2SV_blank>%8191[^\\\\n]\" <S2SV_ModEnd> , group , <S2SV_ModStart> < 4 ) { mutt_debug ( 4 , \"Cannot<S2SV_blank>parse<S2SV_blank>server<S2SV_blank>line:<S2SV_blank>%s\\\\n\" , line ) ; <S2SV_ModStart> return 0 ; }\n","project_and_commit_id":"neomutt@neomutt/6296f7153f0c9d5e5cd3aaf08f9731e56621bdd3","cve_id":"CVE-2018-14360","original_address":"https://github.com/neomutt/neomutt/commit/6296f7153f0c9d5e5cd3aaf08f9731e56621bdd3","time":"2018-07-17T17:29Z"},
	{"Unnamed: 0":5168,"cwe_id":"CWE-20","source":"CWE-20 int main ( int argc , char * * argv ) { int c ; bool lock_memory = false ; bool do_daemonize = false ; bool preallocate = false ; int maxcore = 0 ; char * username = NULL ; char * pid_file = NULL ; struct passwd * pw ; struct rlimit rlim ; char * buf ; char unit = '\\\\0' ; int size_max = 0 ; int retval = EXIT_SUCCESS ; static int * l_socket = NULL ; static int * u_socket = NULL ; bool protocol_specified = false ; bool tcp_specified = false ; bool udp_specified = false ; bool start_lru_maintainer = true ; bool start_lru_crawler = true ; bool start_assoc_maint = true ; enum hashfunc_type hash_type = MURMUR3_HASH ; uint32_t tocrawl ; uint32_t slab_sizes [ MAX_NUMBER_OF_SLAB_CLASSES ] ; bool use_slab_sizes = false ; char * slab_sizes_unparsed = NULL ; bool slab_chunk_size_changed = false ; # ifdef EXTSTORE void * storage = NULL ; char * storage_file = NULL ; struct extstore_conf ext_cf ; # endif char * subopts , * subopts_orig ; char * subopts_value ; enum { MAXCONNS_FAST = 0 , HASHPOWER_INIT , NO_HASHEXPAND , SLAB_REASSIGN , SLAB_AUTOMOVE , SLAB_AUTOMOVE_RATIO , SLAB_AUTOMOVE_WINDOW , TAIL_REPAIR_TIME , HASH_ALGORITHM , LRU_CRAWLER , LRU_CRAWLER_SLEEP , LRU_CRAWLER_TOCRAWL , LRU_MAINTAINER , HOT_LRU_PCT , WARM_LRU_PCT , HOT_MAX_FACTOR , WARM_MAX_FACTOR , TEMPORARY_TTL , IDLE_TIMEOUT , WATCHER_LOGBUF_SIZE , WORKER_LOGBUF_SIZE , SLAB_SIZES , SLAB_CHUNK_MAX , TRACK_SIZES , NO_INLINE_ASCII_RESP , MODERN , NO_MODERN , NO_CHUNKED_ITEMS , NO_SLAB_REASSIGN , NO_SLAB_AUTOMOVE , NO_MAXCONNS_FAST , INLINE_ASCII_RESP , NO_LRU_CRAWLER , NO_LRU_MAINTAINER , NO_DROP_PRIVILEGES , # ifdef MEMCACHED_DEBUG RELAXED_PRIVILEGES , # endif # ifdef EXTSTORE EXT_PAGE_SIZE , EXT_PAGE_COUNT , EXT_WBUF_SIZE , EXT_THREADS , EXT_IO_DEPTH , EXT_PATH , EXT_ITEM_SIZE , EXT_ITEM_AGE , EXT_LOW_TTL , EXT_RECACHE_RATE , EXT_COMPACT_UNDER , EXT_DROP_UNDER , EXT_MAX_FRAG , EXT_DROP_UNREAD , SLAB_AUTOMOVE_FREERATIO , # endif } ; char * const subopts_tokens [ ] = { [ MAXCONNS_FAST ] = \"maxconns_fast\" , [ HASHPOWER_INIT ] = \"hashpower\" , [ NO_HASHEXPAND ] = \"no_hashexpand\" , [ SLAB_REASSIGN ] = \"slab_reassign\" , [ SLAB_AUTOMOVE ] = \"slab_automove\" , [ SLAB_AUTOMOVE_RATIO ] = \"slab_automove_ratio\" , [ SLAB_AUTOMOVE_WINDOW ] = \"slab_automove_window\" , [ TAIL_REPAIR_TIME ] = \"tail_repair_time\" , [ HASH_ALGORITHM ] = \"hash_algorithm\" , [ LRU_CRAWLER ] = \"lru_crawler\" , [ LRU_CRAWLER_SLEEP ] = \"lru_crawler_sleep\" , [ LRU_CRAWLER_TOCRAWL ] = \"lru_crawler_tocrawl\" , [ LRU_MAINTAINER ] = \"lru_maintainer\" , [ HOT_LRU_PCT ] = \"hot_lru_pct\" , [ WARM_LRU_PCT ] = \"warm_lru_pct\" , [ HOT_MAX_FACTOR ] = \"hot_max_factor\" , [ WARM_MAX_FACTOR ] = \"warm_max_factor\" , [ TEMPORARY_TTL ] = \"temporary_ttl\" , [ IDLE_TIMEOUT ] = \"idle_timeout\" , [ WATCHER_LOGBUF_SIZE ] = \"watcher_logbuf_size\" , [ WORKER_LOGBUF_SIZE ] = \"worker_logbuf_size\" , [ SLAB_SIZES ] = \"slab_sizes\" , [ SLAB_CHUNK_MAX ] = \"slab_chunk_max\" , [ TRACK_SIZES ] = \"track_sizes\" , [ NO_INLINE_ASCII_RESP ] = \"no_inline_ascii_resp\" , [ MODERN ] = \"modern\" , [ NO_MODERN ] = \"no_modern\" , [ NO_CHUNKED_ITEMS ] = \"no_chunked_items\" , [ NO_SLAB_REASSIGN ] = \"no_slab_reassign\" , [ NO_SLAB_AUTOMOVE ] = \"no_slab_automove\" , [ NO_MAXCONNS_FAST ] = \"no_maxconns_fast\" , [ INLINE_ASCII_RESP ] = \"inline_ascii_resp\" , [ NO_LRU_CRAWLER ] = \"no_lru_crawler\" , [ NO_LRU_MAINTAINER ] = \"no_lru_maintainer\" , [ NO_DROP_PRIVILEGES ] = \"no_drop_privileges\" , # ifdef MEMCACHED_DEBUG [ RELAXED_PRIVILEGES ] = \"relaxed_privileges\" , # endif # ifdef EXTSTORE [ EXT_PAGE_SIZE ] = \"ext_page_size\" , [ EXT_PAGE_COUNT ] = \"ext_page_count\" , [ EXT_WBUF_SIZE ] = \"ext_wbuf_size\" , [ EXT_THREADS ] = \"ext_threads\" , [ EXT_IO_DEPTH ] = \"ext_io_depth\" , [ EXT_PATH ] = \"ext_path\" , [ EXT_ITEM_SIZE ] = \"ext_item_size\" , [ EXT_ITEM_AGE ] = \"ext_item_age\" , [ EXT_LOW_TTL ] = \"ext_low_ttl\" , [ EXT_RECACHE_RATE ] = \"ext_recache_rate\" , [ EXT_COMPACT_UNDER ] = \"ext_compact_under\" , [ EXT_DROP_UNDER ] = \"ext_drop_under\" , [ EXT_MAX_FRAG ] = \"ext_max_frag\" , [ EXT_DROP_UNREAD ] = \"ext_drop_unread\" , [ SLAB_AUTOMOVE_FREERATIO ] = \"slab_automove_freeratio\" , # endif NULL } ; if ( ! sanitycheck ( ) ) { return EX_OSERR ; } signal ( SIGINT , sig_handler ) ; signal ( SIGTERM , sig_handler ) ; settings_init ( ) ; # ifdef EXTSTORE settings . ext_item_size = 512 ; settings . ext_item_age = UINT_MAX ; settings . ext_low_ttl = 0 ; settings . ext_recache_rate = 2000 ; settings . ext_max_frag = 0.8 ; settings . ext_drop_unread = false ; settings . ext_wbuf_size = 1024 * 1024 * 4 ; settings . ext_compact_under = 0 ; settings . ext_drop_under = 0 ; settings . slab_automove_freeratio = 0.01 ; ext_cf . page_size = 1024 * 1024 * 64 ; ext_cf . page_count = 64 ; ext_cf . wbuf_size = settings . ext_wbuf_size ; ext_cf . io_threadcount = 1 ; ext_cf . io_depth = 1 ; ext_cf . page_buckets = 4 ; ext_cf . wbuf_count = ext_cf . page_buckets ; # endif init_lru_maintainer ( ) ; setbuf ( stderr , NULL ) ; char * shortopts = \"a:\" \"A\" \"p:\" \"s:\" \"U:\" \"m:\" \"M\" \"c:\" \"k\" \"hiV\" \"r\" \"v\" \"d\" \"l:\" \"u:\" \"P:\" \"f:\" \"n:\" \"t:\" \"D:\" \"L\" \"R:\" \"C\" \"b:\" \"B:\" \"I:\" \"S\" \"F\" \"X\" \"o:\" ; # ifdef HAVE_GETOPT_LONG const struct option longopts [ ] = { { \"unix-mask\" , required_argument , 0 , 'a' } , { \"enable-shutdown\" , no_argument , 0 , 'A' } , { \"port\" , required_argument , 0 , 'p' } , { \"unix-socket\" , required_argument , 0 , 's' } , { \"udp-port\" , required_argument , 0 , 'U' } , { \"memory-limit\" , required_argument , 0 , 'm' } , { \"disable-evictions\" , no_argument , 0 , 'M' } , { \"conn-limit\" , required_argument , 0 , 'c' } , { \"lock-memory\" , no_argument , 0 , 'k' } , { \"help\" , no_argument , 0 , 'h' } , { \"license\" , no_argument , 0 , 'i' } , { \"version\" , no_argument , 0 , 'V' } , { \"enable-coredumps\" , no_argument , 0 , 'r' } , { \"verbose\" , optional_argument , 0 , 'v' } , { \"daemon\" , no_argument , 0 , 'd' } , { \"listen\" , required_argument , 0 , 'l' } , { \"user\" , required_argument , 0 , 'u' } , { \"pidfile\" , required_argument , 0 , 'P' } , { \"slab-growth-factor\" , required_argument , 0 , 'f' } , { \"slab-min-size\" , required_argument , 0 , 'n' } , { \"threads\" , required_argument , 0 , 't' } , { \"enable-largepages\" , no_argument , 0 , 'L' } , { \"max-reqs-per-event\" , required_argument , 0 , 'R' } , { \"disable-cas\" , no_argument , 0 , 'C' } , { \"listen-backlog\" , required_argument , 0 , 'b' } , { \"protocol\" , required_argument , 0 , 'B' } , { \"max-item-size\" , required_argument , 0 , 'I' } , { \"enable-sasl\" , no_argument , 0 , 'S' } , { \"disable-flush-all\" , no_argument , 0 , 'F' } , { \"disable-dumping\" , no_argument , 0 , 'X' } , { \"extended\" , required_argument , 0 , 'o' } , { 0 , 0 , 0 , 0 } } ; int optindex ; while ( - 1 != ( c = getopt_long ( argc , argv , shortopts , longopts , & optindex ) ) ) { # else while ( - 1 != ( c = getopt ( argc , argv , shortopts ) ) ) { # endif switch ( c ) { case 'A' : settings . shutdown_command = true ; break ; case 'a' : settings . access = strtol ( optarg , NULL , 8 ) ; break ; case 'U' : settings . udpport = atoi ( optarg ) ; udp_specified = true ; break ; case 'p' : settings . port = atoi ( optarg ) ; tcp_specified = true ; break ; case 's' : settings . socketpath = optarg ; break ; case 'm' : settings . maxbytes = ( ( size_t ) atoi ( optarg ) ) * 1024 * 1024 ; break ; case 'M' : settings . evict_to_free = 0 ; break ; case 'c' : settings . maxconns = atoi ( optarg ) ; if ( settings . maxconns <= 0 ) { fprintf ( stderr , \"Maximum<S2SV_blank>connections<S2SV_blank>must<S2SV_blank>be<S2SV_blank>greater<S2SV_blank>than<S2SV_blank>0\\\\n\" ) ; return 1 ; } break ; case 'h' : usage ( ) ; exit ( EXIT_SUCCESS ) ; case 'i' : usage_license ( ) ; exit ( EXIT_SUCCESS ) ; case 'V' : printf ( PACKAGE \"<S2SV_blank>\" VERSION \"\\\\n\" ) ; exit ( EXIT_SUCCESS ) ; case 'k' : lock_memory = true ; break ; case 'v' : settings . verbose ++ ; break ; case 'l' : if ( settings . inter != NULL ) { if ( strstr ( settings . inter , optarg ) != NULL ) { break ; } size_t len = strlen ( settings . inter ) + strlen ( optarg ) + 2 ; char * p = malloc ( len ) ; if ( p == NULL ) { fprintf ( stderr , \"Failed<S2SV_blank>to<S2SV_blank>allocate<S2SV_blank>memory\\\\n\" ) ; return 1 ; } snprintf ( p , len , \"%s,%s\" , settings . inter , optarg ) ; free ( settings . inter ) ; settings . inter = p ; } else { settings . inter = strdup ( optarg ) ; } break ; case 'd' : do_daemonize = true ; break ; case 'r' : maxcore = 1 ; break ; case 'R' : settings . reqs_per_event = atoi ( optarg ) ; if ( settings . reqs_per_event == 0 ) { fprintf ( stderr , \"Number<S2SV_blank>of<S2SV_blank>requests<S2SV_blank>per<S2SV_blank>event<S2SV_blank>must<S2SV_blank>be<S2SV_blank>greater<S2SV_blank>than<S2SV_blank>0\\\\n\" ) ; return 1 ; } break ; case 'u' : username = optarg ; break ; case 'P' : pid_file = optarg ; break ; case 'f' : settings . factor = atof ( optarg ) ; if ( settings . factor <= 1.0 ) { fprintf ( stderr , \"Factor<S2SV_blank>must<S2SV_blank>be<S2SV_blank>greater<S2SV_blank>than<S2SV_blank>1\\\\n\" ) ; return 1 ; } break ; case 'n' : settings . chunk_size = atoi ( optarg ) ; if ( settings . chunk_size == 0 ) { fprintf ( stderr , \"Chunk<S2SV_blank>size<S2SV_blank>must<S2SV_blank>be<S2SV_blank>greater<S2SV_blank>than<S2SV_blank>0\\\\n\" ) ; return 1 ; } break ; case 't' : settings . num_threads = atoi ( optarg ) ; if ( settings . num_threads <= 0 ) { fprintf ( stderr , \"Number<S2SV_blank>of<S2SV_blank>threads<S2SV_blank>must<S2SV_blank>be<S2SV_blank>greater<S2SV_blank>than<S2SV_blank>0\\\\n\" ) ; return 1 ; } if ( settings . num_threads > 64 ) { fprintf ( stderr , \"WARNING:<S2SV_blank>Setting<S2SV_blank>a<S2SV_blank>high<S2SV_blank>number<S2SV_blank>of<S2SV_blank>worker\" \"threads<S2SV_blank>is<S2SV_blank>not<S2SV_blank>recommended.\\\\n\" \"<S2SV_blank>Set<S2SV_blank>this<S2SV_blank>value<S2SV_blank>to<S2SV_blank>the<S2SV_blank>number<S2SV_blank>of<S2SV_blank>cores<S2SV_blank>in\" \"<S2SV_blank>your<S2SV_blank>machine<S2SV_blank>or<S2SV_blank>less.\\\\n\" ) ; } break ; case 'D' : if ( ! optarg || ! optarg [ 0 ] ) { fprintf ( stderr , \"No<S2SV_blank>delimiter<S2SV_blank>specified\\\\n\" ) ; return 1 ; } settings . prefix_delimiter = optarg [ 0 ] ; settings . detail_enabled = 1 ; break ; case 'L' : if ( enable_large_pages ( ) == 0 ) { preallocate = true ; } else { fprintf ( stderr , \"Cannot<S2SV_blank>enable<S2SV_blank>large<S2SV_blank>pages<S2SV_blank>on<S2SV_blank>this<S2SV_blank>system\\\\n\" \"(There<S2SV_blank>is<S2SV_blank>no<S2SV_blank>Linux<S2SV_blank>support<S2SV_blank>as<S2SV_blank>of<S2SV_blank>this<S2SV_blank>version)\\\\n\" ) ; return 1 ; } break ; case 'C' : settings . use_cas = false ; break ; case 'b' : settings . backlog = atoi ( optarg ) ; break ; case 'B' : protocol_specified = true ; if ( strcmp ( optarg , \"auto\" ) == 0 ) { settings . binding_protocol = negotiating_prot ; } else if ( strcmp ( optarg , \"binary\" ) == 0 ) { settings . binding_protocol = binary_prot ; } else if ( strcmp ( optarg , \"ascii\" ) == 0 ) { settings . binding_protocol = ascii_prot ; } else { fprintf ( stderr , \"Invalid<S2SV_blank>value<S2SV_blank>for<S2SV_blank>binding<S2SV_blank>protocol:<S2SV_blank>%s\\\\n\" \"<S2SV_blank>--<S2SV_blank>should<S2SV_blank>be<S2SV_blank>one<S2SV_blank>of<S2SV_blank>auto,<S2SV_blank>binary,<S2SV_blank>or<S2SV_blank>ascii\\\\n\" , optarg ) ; exit ( EX_USAGE ) ; } break ; case 'I' : buf = strdup ( optarg ) ; unit = buf [ strlen ( buf ) - 1 ] ; if ( unit == 'k' || unit == 'm' || unit == 'K' || unit == 'M' ) { buf [ strlen ( buf ) - 1 ] = '\\\\0' ; size_max = atoi ( buf ) ; if ( unit == 'k' || unit == 'K' ) size_max *= 1024 ; if ( unit == 'm' || unit == 'M' ) size_max *= 1024 * 1024 ; settings . item_size_max = size_max ; } else { settings . item_size_max = atoi ( buf ) ; } free ( buf ) ; break ; case 'S' : # ifndef ENABLE_SASL fprintf ( stderr , \"This<S2SV_blank>server<S2SV_blank>is<S2SV_blank>not<S2SV_blank>built<S2SV_blank>with<S2SV_blank>SASL<S2SV_blank>support.\\\\n\" ) ; exit ( EX_USAGE ) ; # endif settings . sasl = true ; break ; case 'F' : settings . flush_enabled = false ; break ; case 'X' : settings . dump_enabled = false ; break ; case 'o' : subopts_orig = subopts = strdup ( optarg ) ; while ( * subopts != '\\\\0' ) { switch ( getsubopt ( & subopts , subopts_tokens , & subopts_value ) ) { case MAXCONNS_FAST : settings . maxconns_fast = true ; break ; case HASHPOWER_INIT : if ( subopts_value == NULL ) { fprintf ( stderr , \"Missing<S2SV_blank>numeric<S2SV_blank>argument<S2SV_blank>for<S2SV_blank>hashpower\\\\n\" ) ; return 1 ; } settings . hashpower_init = atoi ( subopts_value ) ; if ( settings . hashpower_init < 12 ) { fprintf ( stderr , \"Initial<S2SV_blank>hashtable<S2SV_blank>multiplier<S2SV_blank>of<S2SV_blank>%d<S2SV_blank>is<S2SV_blank>too<S2SV_blank>low\\\\n\" , settings . hashpower_init ) ; return 1 ; } else if ( settings . hashpower_init > 32 ) { fprintf ( stderr , \"Initial<S2SV_blank>hashtable<S2SV_blank>multiplier<S2SV_blank>of<S2SV_blank>%d<S2SV_blank>is<S2SV_blank>too<S2SV_blank>high\\\\n\" \"Choose<S2SV_blank>a<S2SV_blank>value<S2SV_blank>based<S2SV_blank>on<S2SV_blank>\\\\\"STAT<S2SV_blank>hash_power_level\\\\\"<S2SV_blank>from<S2SV_blank>a<S2SV_blank>running<S2SV_blank>instance\\\\n\" , settings . hashpower_init ) ; return 1 ; } break ; case NO_HASHEXPAND : start_assoc_maint = false ; break ; case SLAB_REASSIGN : settings . slab_reassign = true ; break ; case SLAB_AUTOMOVE : if ( subopts_value == NULL ) { settings . slab_automove = 1 ; break ; } settings . slab_automove = atoi ( subopts_value ) ; if ( settings . slab_automove < 0 || settings . slab_automove > 2 ) { fprintf ( stderr , \"slab_automove<S2SV_blank>must<S2SV_blank>be<S2SV_blank>between<S2SV_blank>0<S2SV_blank>and<S2SV_blank>2\\\\n\" ) ; return 1 ; } break ; case SLAB_AUTOMOVE_RATIO : if ( subopts_value == NULL ) { fprintf ( stderr , \"Missing<S2SV_blank>slab_automove_ratio<S2SV_blank>argument\\\\n\" ) ; return 1 ; } settings . slab_automove_ratio = atof ( subopts_value ) ; if ( settings . slab_automove_ratio <= 0 || settings . slab_automove_ratio > 1 ) { fprintf ( stderr , \"slab_automove_ratio<S2SV_blank>must<S2SV_blank>be<S2SV_blank>><S2SV_blank>0<S2SV_blank>and<S2SV_blank><<S2SV_blank>1\\\\n\" ) ; return 1 ; } break ; case SLAB_AUTOMOVE_WINDOW : if ( subopts_value == NULL ) { fprintf ( stderr , \"Missing<S2SV_blank>slab_automove_window<S2SV_blank>argument\\\\n\" ) ; return 1 ; } settings . slab_automove_window = atoi ( subopts_value ) ; if ( settings . slab_automove_window < 3 ) { fprintf ( stderr , \"slab_automove_window<S2SV_blank>must<S2SV_blank>be<S2SV_blank>><S2SV_blank>2\\\\n\" ) ; return 1 ; } break ; case TAIL_REPAIR_TIME : if ( subopts_value == NULL ) { fprintf ( stderr , \"Missing<S2SV_blank>numeric<S2SV_blank>argument<S2SV_blank>for<S2SV_blank>tail_repair_time\\\\n\" ) ; return 1 ; } settings . tail_repair_time = atoi ( subopts_value ) ; if ( settings . tail_repair_time < 10 ) { fprintf ( stderr , \"Cannot<S2SV_blank>set<S2SV_blank>tail_repair_time<S2SV_blank>to<S2SV_blank>less<S2SV_blank>than<S2SV_blank>10<S2SV_blank>seconds\\\\n\" ) ; return 1 ; } break ; case HASH_ALGORITHM : if ( subopts_value == NULL ) { fprintf ( stderr , \"Missing<S2SV_blank>hash_algorithm<S2SV_blank>argument\\\\n\" ) ; return 1 ; } ; if ( strcmp ( subopts_value , \"jenkins\" ) == 0 ) { hash_type = JENKINS_HASH ; } else if ( strcmp ( subopts_value , \"murmur3\" ) == 0 ) { hash_type = MURMUR3_HASH ; } else { fprintf ( stderr , \"Unknown<S2SV_blank>hash_algorithm<S2SV_blank>option<S2SV_blank>(jenkins,<S2SV_blank>murmur3)\\\\n\" ) ; return 1 ; } break ; case LRU_CRAWLER : start_lru_crawler = true ; break ; case LRU_CRAWLER_SLEEP : if ( subopts_value == NULL ) { fprintf ( stderr , \"Missing<S2SV_blank>lru_crawler_sleep<S2SV_blank>value\\\\n\" ) ; return 1 ; } settings . lru_crawler_sleep = atoi ( subopts_value ) ; if ( settings . lru_crawler_sleep > 1000000 || settings . lru_crawler_sleep < 0 ) { fprintf ( stderr , \"LRU<S2SV_blank>crawler<S2SV_blank>sleep<S2SV_blank>must<S2SV_blank>be<S2SV_blank>between<S2SV_blank>0<S2SV_blank>and<S2SV_blank>1<S2SV_blank>second\\\\n\" ) ; return 1 ; } break ; case LRU_CRAWLER_TOCRAWL : if ( subopts_value == NULL ) { fprintf ( stderr , \"Missing<S2SV_blank>lru_crawler_tocrawl<S2SV_blank>value\\\\n\" ) ; return 1 ; } if ( ! safe_strtoul ( subopts_value , & tocrawl ) ) { fprintf ( stderr , \"lru_crawler_tocrawl<S2SV_blank>takes<S2SV_blank>a<S2SV_blank>numeric<S2SV_blank>32bit<S2SV_blank>value\\\\n\" ) ; return 1 ; } settings . lru_crawler_tocrawl = tocrawl ; break ; case LRU_MAINTAINER : start_lru_maintainer = true ; settings . lru_segmented = true ; break ; case HOT_LRU_PCT : if ( subopts_value == NULL ) { fprintf ( stderr , \"Missing<S2SV_blank>hot_lru_pct<S2SV_blank>argument\\\\n\" ) ; return 1 ; } settings . hot_lru_pct = atoi ( subopts_value ) ; if ( settings . hot_lru_pct < 1 || settings . hot_lru_pct >= 80 ) { fprintf ( stderr , \"hot_lru_pct<S2SV_blank>must<S2SV_blank>be<S2SV_blank>><S2SV_blank>1<S2SV_blank>and<S2SV_blank><<S2SV_blank>80\\\\n\" ) ; return 1 ; } break ; case WARM_LRU_PCT : if ( subopts_value == NULL ) { fprintf ( stderr , \"Missing<S2SV_blank>warm_lru_pct<S2SV_blank>argument\\\\n\" ) ; return 1 ; } settings . warm_lru_pct = atoi ( subopts_value ) ; if ( settings . warm_lru_pct < 1 || settings . warm_lru_pct >= 80 ) { fprintf ( stderr , \"warm_lru_pct<S2SV_blank>must<S2SV_blank>be<S2SV_blank>><S2SV_blank>1<S2SV_blank>and<S2SV_blank><<S2SV_blank>80\\\\n\" ) ; return 1 ; } break ; case HOT_MAX_FACTOR : if ( subopts_value == NULL ) { fprintf ( stderr , \"Missing<S2SV_blank>hot_max_factor<S2SV_blank>argument\\\\n\" ) ; return 1 ; } settings . hot_max_factor = atof ( subopts_value ) ; if ( settings . hot_max_factor <= 0 ) { fprintf ( stderr , \"hot_max_factor<S2SV_blank>must<S2SV_blank>be<S2SV_blank>><S2SV_blank>0\\\\n\" ) ; return 1 ; } break ; case WARM_MAX_FACTOR : if ( subopts_value == NULL ) { fprintf ( stderr , \"Missing<S2SV_blank>warm_max_factor<S2SV_blank>argument\\\\n\" ) ; return 1 ; } settings . warm_max_factor = atof ( subopts_value ) ; if ( settings . warm_max_factor <= 0 ) { fprintf ( stderr , \"warm_max_factor<S2SV_blank>must<S2SV_blank>be<S2SV_blank>><S2SV_blank>0\\\\n\" ) ; return 1 ; } break ; case TEMPORARY_TTL : if ( subopts_value == NULL ) { fprintf ( stderr , \"Missing<S2SV_blank>temporary_ttl<S2SV_blank>argument\\\\n\" ) ; return 1 ; } settings . temp_lru = true ; settings . temporary_ttl = atoi ( subopts_value ) ; break ; case IDLE_TIMEOUT : if ( subopts_value == NULL ) { fprintf ( stderr , \"Missing<S2SV_blank>numeric<S2SV_blank>argument<S2SV_blank>for<S2SV_blank>idle_timeout\\\\n\" ) ; return 1 ; } settings . idle_timeout = atoi ( subopts_value ) ; break ; case WATCHER_LOGBUF_SIZE : if ( subopts_value == NULL ) { fprintf ( stderr , \"Missing<S2SV_blank>watcher_logbuf_size<S2SV_blank>argument\\\\n\" ) ; return 1 ; } if ( ! safe_strtoul ( subopts_value , & settings . logger_watcher_buf_size ) ) { fprintf ( stderr , \"could<S2SV_blank>not<S2SV_blank>parse<S2SV_blank>argument<S2SV_blank>to<S2SV_blank>watcher_logbuf_size\\\\n\" ) ; return 1 ; } settings . logger_watcher_buf_size *= 1024 ; break ; case WORKER_LOGBUF_SIZE : if ( subopts_value == NULL ) { fprintf ( stderr , \"Missing<S2SV_blank>worker_logbuf_size<S2SV_blank>argument\\\\n\" ) ; return 1 ; } if ( ! safe_strtoul ( subopts_value , & settings . logger_buf_size ) ) { fprintf ( stderr , \"could<S2SV_blank>not<S2SV_blank>parse<S2SV_blank>argument<S2SV_blank>to<S2SV_blank>worker_logbuf_size\\\\n\" ) ; return 1 ; } settings . logger_buf_size *= 1024 ; case SLAB_SIZES : slab_sizes_unparsed = subopts_value ; break ; case SLAB_CHUNK_MAX : if ( subopts_value == NULL ) { fprintf ( stderr , \"Missing<S2SV_blank>slab_chunk_max<S2SV_blank>argument\\\\n\" ) ; } if ( ! safe_strtol ( subopts_value , & settings . slab_chunk_size_max ) ) { fprintf ( stderr , \"could<S2SV_blank>not<S2SV_blank>parse<S2SV_blank>argument<S2SV_blank>to<S2SV_blank>slab_chunk_max\\\\n\" ) ; } slab_chunk_size_changed = true ; break ; case TRACK_SIZES : item_stats_sizes_init ( ) ; break ; case NO_INLINE_ASCII_RESP : settings . inline_ascii_response = false ; break ; case INLINE_ASCII_RESP : settings . inline_ascii_response = true ; break ; case NO_CHUNKED_ITEMS : settings . slab_chunk_size_max = settings . slab_page_size ; break ; case NO_SLAB_REASSIGN : settings . slab_reassign = false ; break ; case NO_SLAB_AUTOMOVE : settings . slab_automove = 0 ; break ; case NO_MAXCONNS_FAST : settings . maxconns_fast = false ; break ; case NO_LRU_CRAWLER : settings . lru_crawler = false ; start_lru_crawler = false ; break ; case NO_LRU_MAINTAINER : start_lru_maintainer = false ; settings . lru_segmented = false ; break ; # ifdef EXTSTORE case EXT_PAGE_SIZE : if ( subopts_value == NULL ) { fprintf ( stderr , \"Missing<S2SV_blank>ext_page_size<S2SV_blank>argument\\\\n\" ) ; return 1 ; } if ( ! safe_strtoul ( subopts_value , & ext_cf . page_size ) ) { fprintf ( stderr , \"could<S2SV_blank>not<S2SV_blank>parse<S2SV_blank>argument<S2SV_blank>to<S2SV_blank>ext_page_size\\\\n\" ) ; return 1 ; } ext_cf . page_size *= 1024 * 1024 ; break ; case EXT_PAGE_COUNT : if ( subopts_value == NULL ) { fprintf ( stderr , \"Missing<S2SV_blank>ext_page_count<S2SV_blank>argument\\\\n\" ) ; return 1 ; } if ( ! safe_strtoul ( subopts_value , & ext_cf . page_count ) ) { fprintf ( stderr , \"could<S2SV_blank>not<S2SV_blank>parse<S2SV_blank>argument<S2SV_blank>to<S2SV_blank>ext_page_count\\\\n\" ) ; return 1 ; } break ; case EXT_WBUF_SIZE : if ( subopts_value == NULL ) { fprintf ( stderr , \"Missing<S2SV_blank>ext_wbuf_size<S2SV_blank>argument\\\\n\" ) ; return 1 ; } if ( ! safe_strtoul ( subopts_value , & ext_cf . wbuf_size ) ) { fprintf ( stderr , \"could<S2SV_blank>not<S2SV_blank>parse<S2SV_blank>argument<S2SV_blank>to<S2SV_blank>ext_wbuf_size\\\\n\" ) ; return 1 ; } ext_cf . wbuf_size *= 1024 * 1024 ; settings . ext_wbuf_size = ext_cf . wbuf_size ; break ; case EXT_THREADS : if ( subopts_value == NULL ) { fprintf ( stderr , \"Missing<S2SV_blank>ext_threads<S2SV_blank>argument\\\\n\" ) ; return 1 ; } if ( ! safe_strtoul ( subopts_value , & ext_cf . io_threadcount ) ) { fprintf ( stderr , \"could<S2SV_blank>not<S2SV_blank>parse<S2SV_blank>argument<S2SV_blank>to<S2SV_blank>ext_threads\\\\n\" ) ; return 1 ; } break ; case EXT_IO_DEPTH : if ( subopts_value == NULL ) { fprintf ( stderr , \"Missing<S2SV_blank>ext_io_depth<S2SV_blank>argument\\\\n\" ) ; return 1 ; } if ( ! safe_strtoul ( subopts_value , & ext_cf . io_depth ) ) { fprintf ( stderr , \"could<S2SV_blank>not<S2SV_blank>parse<S2SV_blank>argument<S2SV_blank>to<S2SV_blank>ext_io_depth\\\\n\" ) ; return 1 ; } break ; case EXT_ITEM_SIZE : if ( subopts_value == NULL ) { fprintf ( stderr , \"Missing<S2SV_blank>ext_item_size<S2SV_blank>argument\\\\n\" ) ; return 1 ; } if ( ! safe_strtoul ( subopts_value , & settings . ext_item_size ) ) { fprintf ( stderr , \"could<S2SV_blank>not<S2SV_blank>parse<S2SV_blank>argument<S2SV_blank>to<S2SV_blank>ext_item_size\\\\n\" ) ; return 1 ; } break ; case EXT_ITEM_AGE : if ( subopts_value == NULL ) { fprintf ( stderr , \"Missing<S2SV_blank>ext_item_age<S2SV_blank>argument\\\\n\" ) ; return 1 ; } if ( ! safe_strtoul ( subopts_value , & settings . ext_item_age ) ) { fprintf ( stderr , \"could<S2SV_blank>not<S2SV_blank>parse<S2SV_blank>argument<S2SV_blank>to<S2SV_blank>ext_item_age\\\\n\" ) ; return 1 ; } break ; case EXT_LOW_TTL : if ( subopts_value == NULL ) { fprintf ( stderr , \"Missing<S2SV_blank>ext_low_ttl<S2SV_blank>argument\\\\n\" ) ; return 1 ; } if ( ! safe_strtoul ( subopts_value , & settings . ext_low_ttl ) ) { fprintf ( stderr , \"could<S2SV_blank>not<S2SV_blank>parse<S2SV_blank>argument<S2SV_blank>to<S2SV_blank>ext_low_ttl\\\\n\" ) ; return 1 ; } break ; case EXT_RECACHE_RATE : if ( subopts_value == NULL ) { fprintf ( stderr , \"Missing<S2SV_blank>ext_recache_rate<S2SV_blank>argument\\\\n\" ) ; return 1 ; } if ( ! safe_strtoul ( subopts_value , & settings . ext_recache_rate ) ) { fprintf ( stderr , \"could<S2SV_blank>not<S2SV_blank>parse<S2SV_blank>argument<S2SV_blank>to<S2SV_blank>ext_recache_rate\\\\n\" ) ; return 1 ; } break ; case EXT_COMPACT_UNDER : if ( subopts_value == NULL ) { fprintf ( stderr , \"Missing<S2SV_blank>ext_compact_under<S2SV_blank>argument\\\\n\" ) ; return 1 ; } if ( ! safe_strtoul ( subopts_value , & settings . ext_compact_under ) ) { fprintf ( stderr , \"could<S2SV_blank>not<S2SV_blank>parse<S2SV_blank>argument<S2SV_blank>to<S2SV_blank>ext_compact_under\\\\n\" ) ; return 1 ; } break ; case EXT_DROP_UNDER : if ( subopts_value == NULL ) { fprintf ( stderr , \"Missing<S2SV_blank>ext_drop_under<S2SV_blank>argument\\\\n\" ) ; return 1 ; } if ( ! safe_strtoul ( subopts_value , & settings . ext_drop_under ) ) { fprintf ( stderr , \"could<S2SV_blank>not<S2SV_blank>parse<S2SV_blank>argument<S2SV_blank>to<S2SV_blank>ext_drop_under\\\\n\" ) ; return 1 ; } break ; case EXT_MAX_FRAG : if ( subopts_value == NULL ) { fprintf ( stderr , \"Missing<S2SV_blank>ext_max_frag<S2SV_blank>argument\\\\n\" ) ; return 1 ; } if ( ! safe_strtod ( subopts_value , & settings . ext_max_frag ) ) { fprintf ( stderr , \"could<S2SV_blank>not<S2SV_blank>parse<S2SV_blank>argument<S2SV_blank>to<S2SV_blank>ext_max_frag\\\\n\" ) ; return 1 ; } break ; case SLAB_AUTOMOVE_FREERATIO : if ( subopts_value == NULL ) { fprintf ( stderr , \"Missing<S2SV_blank>slab_automove_freeratio<S2SV_blank>argument\\\\n\" ) ; return 1 ; } if ( ! safe_strtod ( subopts_value , & settings . slab_automove_freeratio ) ) { fprintf ( stderr , \"could<S2SV_blank>not<S2SV_blank>parse<S2SV_blank>argument<S2SV_blank>to<S2SV_blank>slab_automove_freeratio\\\\n\" ) ; return 1 ; } break ; case EXT_DROP_UNREAD : settings . ext_drop_unread = true ; break ; case EXT_PATH : storage_file = strdup ( subopts_value ) ; break ; # endif case MODERN : break ; case NO_MODERN : if ( ! slab_chunk_size_changed ) { settings . slab_chunk_size_max = settings . slab_page_size ; } settings . slab_reassign = false ; settings . slab_automove = 0 ; settings . maxconns_fast = false ; settings . inline_ascii_response = true ; settings . lru_segmented = false ; hash_type = JENKINS_HASH ; start_lru_crawler = false ; start_lru_maintainer = false ; break ; case NO_DROP_PRIVILEGES : settings . drop_privileges = false ; break ; # ifdef MEMCACHED_DEBUG case RELAXED_PRIVILEGES : settings . relaxed_privileges = true ; break ; # endif default : printf ( \"Illegal<S2SV_blank>suboption<S2SV_blank>\\\\\"%s\\\\\"\\\\n\" , subopts_value ) ; return 1 ; } } free ( subopts_orig ) ; break ; default : fprintf ( stderr , \"Illegal<S2SV_blank>argument<S2SV_blank>\\\\\"%c\\\\\"\\\\n\" , c ) ; return 1 ; } } if ( settings . item_size_max < 1024 ) { fprintf ( stderr , \"Item<S2SV_blank>max<S2SV_blank>size<S2SV_blank>cannot<S2SV_blank>be<S2SV_blank>less<S2SV_blank>than<S2SV_blank>1024<S2SV_blank>bytes.\\\\n\" ) ; exit ( EX_USAGE ) ; } if ( settings . item_size_max > ( settings . maxbytes / 2 ) ) { fprintf ( stderr , \"Cannot<S2SV_blank>set<S2SV_blank>item<S2SV_blank>size<S2SV_blank>limit<S2SV_blank>higher<S2SV_blank>than<S2SV_blank>1/2<S2SV_blank>of<S2SV_blank>memory<S2SV_blank>max.\\\\n\" ) ; exit ( EX_USAGE ) ; } if ( settings . item_size_max > ( 1024 * 1024 * 1024 ) ) { fprintf ( stderr , \"Cannot<S2SV_blank>set<S2SV_blank>item<S2SV_blank>size<S2SV_blank>limit<S2SV_blank>higher<S2SV_blank>than<S2SV_blank>a<S2SV_blank>gigabyte.\\\\n\" ) ; exit ( EX_USAGE ) ; } if ( settings . item_size_max > 1024 * 1024 ) { if ( ! slab_chunk_size_changed ) { settings . slab_chunk_size_max = settings . slab_page_size / 2 ; } } if ( settings . slab_chunk_size_max > settings . item_size_max ) { fprintf ( stderr , \"slab_chunk_max<S2SV_blank>(bytes:<S2SV_blank>%d)<S2SV_blank>cannot<S2SV_blank>be<S2SV_blank>larger<S2SV_blank>than<S2SV_blank>-I<S2SV_blank>(item_size_max<S2SV_blank>%d)\\\\n\" , settings . slab_chunk_size_max , settings . item_size_max ) ; exit ( EX_USAGE ) ; } if ( settings . item_size_max % settings . slab_chunk_size_max != 0 ) { fprintf ( stderr , \"-I<S2SV_blank>(item_size_max:<S2SV_blank>%d)<S2SV_blank>must<S2SV_blank>be<S2SV_blank>evenly<S2SV_blank>divisible<S2SV_blank>by<S2SV_blank>slab_chunk_max<S2SV_blank>(bytes:<S2SV_blank>%d)\\\\n\" , settings . item_size_max , settings . slab_chunk_size_max ) ; exit ( EX_USAGE ) ; } if ( settings . slab_page_size % settings . slab_chunk_size_max != 0 ) { fprintf ( stderr , \"slab_chunk_max<S2SV_blank>(bytes:<S2SV_blank>%d)<S2SV_blank>must<S2SV_blank>divide<S2SV_blank>evenly<S2SV_blank>into<S2SV_blank>%d<S2SV_blank>(slab_page_size)\\\\n\" , settings . slab_chunk_size_max , settings . slab_page_size ) ; exit ( EX_USAGE ) ; } # ifdef EXTSTORE if ( storage_file ) { if ( settings . item_size_max > ext_cf . wbuf_size ) { fprintf ( stderr , \"-I<S2SV_blank>(item_size_max:<S2SV_blank>%d)<S2SV_blank>cannot<S2SV_blank>be<S2SV_blank>larger<S2SV_blank>than<S2SV_blank>ext_wbuf_size:<S2SV_blank>%d\\\\n\" , settings . item_size_max , ext_cf . wbuf_size ) ; exit ( EX_USAGE ) ; } if ( settings . inline_ascii_response ) { fprintf ( stderr , \"Cannot<S2SV_blank>use<S2SV_blank>inline_ascii_response<S2SV_blank>with<S2SV_blank>extstore<S2SV_blank>enabled\\\\n\" ) ; exit ( EX_USAGE ) ; } if ( settings . udpport ) { fprintf ( stderr , \"Cannot<S2SV_blank>use<S2SV_blank>UDP<S2SV_blank>with<S2SV_blank>extstore<S2SV_blank>enabled<S2SV_blank>(-U<S2SV_blank>0<S2SV_blank>to<S2SV_blank>disable)\\\\n\" ) ; exit ( EX_USAGE ) ; } } # endif if ( slab_sizes_unparsed != NULL ) { if ( _parse_slab_sizes ( slab_sizes_unparsed , slab_sizes ) ) { use_slab_sizes = true ; } else { exit ( EX_USAGE ) ; } } if ( settings . hot_lru_pct + settings . warm_lru_pct > 80 ) { fprintf ( stderr , \"hot_lru_pct<S2SV_blank>+<S2SV_blank>warm_lru_pct<S2SV_blank>cannot<S2SV_blank>be<S2SV_blank>more<S2SV_blank>than<S2SV_blank>80%%<S2SV_blank>combined\\\\n\" ) ; exit ( EX_USAGE ) ; } if ( settings . temp_lru && ! start_lru_maintainer ) { fprintf ( stderr , \"temporary_ttl<S2SV_blank>requires<S2SV_blank>lru_maintainer<S2SV_blank>to<S2SV_blank>be<S2SV_blank>enabled\\\\n\" ) ; exit ( EX_USAGE ) ; } if ( hash_init ( hash_type ) != 0 ) { fprintf ( stderr , \"Failed<S2SV_blank>to<S2SV_blank>initialize<S2SV_blank>hash_algorithm!\\\\n\" ) ; exit ( EX_USAGE ) ; } if ( settings . inter != NULL && strchr ( settings . inter , ',' ) ) { settings . num_threads_per_udp = 1 ; } else { settings . num_threads_per_udp = settings . num_threads ; } if ( settings . sasl ) { if ( ! protocol_specified ) { settings . binding_protocol = binary_prot ; } else { if ( settings . binding_protocol != binary_prot ) { fprintf ( stderr , \"ERROR:<S2SV_blank>You<S2SV_blank>cannot<S2SV_blank>allow<S2SV_blank>the<S2SV_blank>ASCII<S2SV_blank>protocol<S2SV_blank>while<S2SV_blank>using<S2SV_blank>SASL.\\\\n\" ) ; exit ( EX_USAGE ) ; } } } <S2SV_StartBug> if ( tcp_specified && settings . port != 0 && ! udp_specified ) { <S2SV_EndBug> settings . udpport = settings . port ; } else if ( udp_specified && settings . udpport != 0 && ! tcp_specified ) { settings . port = settings . udpport ; } if ( maxcore != 0 ) { struct rlimit rlim_new ; if ( getrlimit ( RLIMIT_CORE , & rlim ) == 0 ) { rlim_new . rlim_cur = rlim_new . rlim_max = RLIM_INFINITY ; if ( setrlimit ( RLIMIT_CORE , & rlim_new ) != 0 ) { rlim_new . rlim_cur = rlim_new . rlim_max = rlim . rlim_max ; ( void ) setrlimit ( RLIMIT_CORE , & rlim_new ) ; } } if ( ( getrlimit ( RLIMIT_CORE , & rlim ) != 0 ) || rlim . rlim_cur == 0 ) { fprintf ( stderr , \"failed<S2SV_blank>to<S2SV_blank>ensure<S2SV_blank>corefile<S2SV_blank>creation\\\\n\" ) ; exit ( EX_OSERR ) ; } } if ( getrlimit ( RLIMIT_NOFILE , & rlim ) != 0 ) { fprintf ( stderr , \"failed<S2SV_blank>to<S2SV_blank>getrlimit<S2SV_blank>number<S2SV_blank>of<S2SV_blank>files\\\\n\" ) ; exit ( EX_OSERR ) ; } else { rlim . rlim_cur = settings . maxconns ; rlim . rlim_max = settings . maxconns ; if ( setrlimit ( RLIMIT_NOFILE , & rlim ) != 0 ) { fprintf ( stderr , \"failed<S2SV_blank>to<S2SV_blank>set<S2SV_blank>rlimit<S2SV_blank>for<S2SV_blank>open<S2SV_blank>files.<S2SV_blank>Try<S2SV_blank>starting<S2SV_blank>as<S2SV_blank>root<S2SV_blank>or<S2SV_blank>requesting<S2SV_blank>smaller<S2SV_blank>maxconns<S2SV_blank>value.\\\\n\" ) ; exit ( EX_OSERR ) ; } } if ( getuid ( ) == 0 || geteuid ( ) == 0 ) { if ( username == 0 || * username == '\\\\0' ) { fprintf ( stderr , \"can\\'t<S2SV_blank>run<S2SV_blank>as<S2SV_blank>root<S2SV_blank>without<S2SV_blank>the<S2SV_blank>-u<S2SV_blank>switch\\\\n\" ) ; exit ( EX_USAGE ) ; } if ( ( pw = getpwnam ( username ) ) == 0 ) { fprintf ( stderr , \"can\\'t<S2SV_blank>find<S2SV_blank>the<S2SV_blank>user<S2SV_blank>%s<S2SV_blank>to<S2SV_blank>switch<S2SV_blank>to\\\\n\" , username ) ; exit ( EX_NOUSER ) ; } if ( setgid ( pw -> pw_gid ) < 0 || setuid ( pw -> pw_uid ) < 0 ) { fprintf ( stderr , \"failed<S2SV_blank>to<S2SV_blank>assume<S2SV_blank>identity<S2SV_blank>of<S2SV_blank>user<S2SV_blank>%s\\\\n\" , username ) ; exit ( EX_OSERR ) ; } } if ( settings . sasl ) { init_sasl ( ) ; } if ( do_daemonize ) { if ( sigignore ( SIGHUP ) == - 1 ) { perror ( \"Failed<S2SV_blank>to<S2SV_blank>ignore<S2SV_blank>SIGHUP\" ) ; } if ( daemonize ( maxcore , settings . verbose ) == - 1 ) { fprintf ( stderr , \"failed<S2SV_blank>to<S2SV_blank>daemon()<S2SV_blank>in<S2SV_blank>order<S2SV_blank>to<S2SV_blank>daemonize\\\\n\" ) ; exit ( EXIT_FAILURE ) ; } } if ( lock_memory ) { # ifdef HAVE_MLOCKALL int res = mlockall ( MCL_CURRENT | MCL_FUTURE ) ; if ( res != 0 ) { fprintf ( stderr , \"warning:<S2SV_blank>-k<S2SV_blank>invalid,<S2SV_blank>mlockall()<S2SV_blank>failed:<S2SV_blank>%s\\\\n\" , strerror ( errno ) ) ; } # else fprintf ( stderr , \"warning:<S2SV_blank>-k<S2SV_blank>invalid,<S2SV_blank>mlockall()<S2SV_blank>not<S2SV_blank>supported<S2SV_blank>on<S2SV_blank>this<S2SV_blank>platform.<S2SV_blank><S2SV_blank>proceeding<S2SV_blank>without.\\\\n\" ) ; # endif } # if defined ( LIBEVENT_VERSION_NUMBER ) && LIBEVENT_VERSION_NUMBER >= 0x02000101 struct event_config * ev_config ; ev_config = event_config_new ( ) ; event_config_set_flag ( ev_config , EVENT_BASE_FLAG_NOLOCK ) ; main_base = event_base_new_with_config ( ev_config ) ; event_config_free ( ev_config ) ; # else main_base = event_init ( ) ; # endif logger_init ( ) ; stats_init ( ) ; assoc_init ( settings . hashpower_init ) ; conn_init ( ) ; slabs_init ( settings . maxbytes , settings . factor , preallocate , use_slab_sizes ? slab_sizes : NULL ) ; # ifdef EXTSTORE if ( storage_file ) { enum extstore_res eres ; if ( settings . ext_compact_under == 0 ) { settings . ext_compact_under = ext_cf . page_count / 4 ; settings . ext_drop_under = ext_cf . page_count / 4 ; } crc32c_init ( ) ; for ( int x = 0 ; x < MAX_NUMBER_OF_SLAB_CLASSES ; x ++ ) { settings . ext_free_memchunks [ x ] = 0 ; } storage = extstore_init ( storage_file , & ext_cf , & eres ) ; if ( storage == NULL ) { fprintf ( stderr , \"Failed<S2SV_blank>to<S2SV_blank>initialize<S2SV_blank>external<S2SV_blank>storage:<S2SV_blank>%s\\\\n\" , extstore_err ( eres ) ) ; if ( eres == EXTSTORE_INIT_OPEN_FAIL ) { perror ( \"extstore<S2SV_blank>open\" ) ; } exit ( EXIT_FAILURE ) ; } ext_storage = storage ; slabs_prefill_global ( ) ; } # endif if ( sigignore ( SIGPIPE ) == - 1 ) { perror ( \"failed<S2SV_blank>to<S2SV_blank>ignore<S2SV_blank>SIGPIPE;<S2SV_blank>sigaction\" ) ; exit ( EX_OSERR ) ; } # ifdef EXTSTORE slabs_set_storage ( storage ) ; memcached_thread_init ( settings . num_threads , storage ) ; init_lru_crawler ( storage ) ; # else memcached_thread_init ( settings . num_threads , NULL ) ; init_lru_crawler ( NULL ) ; # endif if ( start_assoc_maint && start_assoc_maintenance_thread ( ) == - 1 ) { exit ( EXIT_FAILURE ) ; } if ( start_lru_crawler && start_item_crawler_thread ( ) != 0 ) { fprintf ( stderr , \"Failed<S2SV_blank>to<S2SV_blank>enable<S2SV_blank>LRU<S2SV_blank>crawler<S2SV_blank>thread\\\\n\" ) ; exit ( EXIT_FAILURE ) ; } # ifdef EXTSTORE if ( storage && start_storage_compact_thread ( storage ) != 0 ) { fprintf ( stderr , \"Failed<S2SV_blank>to<S2SV_blank>start<S2SV_blank>storage<S2SV_blank>compaction<S2SV_blank>thread\\\\n\" ) ; exit ( EXIT_FAILURE ) ; } if ( start_lru_maintainer && start_lru_maintainer_thread ( storage ) != 0 ) { # else if ( start_lru_maintainer && start_lru_maintainer_thread ( NULL ) != 0 ) { # endif fprintf ( stderr , \"Failed<S2SV_blank>to<S2SV_blank>enable<S2SV_blank>LRU<S2SV_blank>maintainer<S2SV_blank>thread\\\\n\" ) ; return 1 ; } if ( settings . slab_reassign && start_slab_maintenance_thread ( ) == - 1 ) { exit ( EXIT_FAILURE ) ; } if ( settings . idle_timeout && start_conn_timeout_thread ( ) == - 1 ) { exit ( EXIT_FAILURE ) ; } clock_handler ( 0 , 0 , 0 ) ; if ( settings . socketpath != NULL ) { errno = 0 ; if ( server_socket_unix ( settings . socketpath , settings . access ) ) { vperror ( \"failed<S2SV_blank>to<S2SV_blank>listen<S2SV_blank>on<S2SV_blank>UNIX<S2SV_blank>socket:<S2SV_blank>%s\" , settings . socketpath ) ; exit ( EX_OSERR ) ; } } if ( settings . socketpath == NULL ) { const char * portnumber_filename = getenv ( \"MEMCACHED_PORT_FILENAME\" ) ; char * temp_portnumber_filename = NULL ; size_t len ; FILE * portnumber_file = NULL ; if ( portnumber_filename != NULL ) { len = strlen ( portnumber_filename ) + 4 + 1 ; temp_portnumber_filename = malloc ( len ) ; snprintf ( temp_portnumber_filename , len , \"%s.lck\" , portnumber_filename ) ; portnumber_file = fopen ( temp_portnumber_filename , \"a\" ) ; if ( portnumber_file == NULL ) { fprintf ( stderr , \"Failed<S2SV_blank>to<S2SV_blank>open<S2SV_blank>\\\\\"%s\\\\\":<S2SV_blank>%s\\\\n\" , temp_portnumber_filename , strerror ( errno ) ) ; } } errno = 0 ; if ( settings . port && server_sockets ( settings . port , tcp_transport , portnumber_file ) ) { vperror ( \"failed<S2SV_blank>to<S2SV_blank>listen<S2SV_blank>on<S2SV_blank>TCP<S2SV_blank>port<S2SV_blank>%d\" , settings . port ) ; exit ( EX_OSERR ) ; } errno = 0 ; if ( settings . udpport && server_sockets ( settings . udpport , udp_transport , portnumber_file ) ) { vperror ( \"failed<S2SV_blank>to<S2SV_blank>listen<S2SV_blank>on<S2SV_blank>UDP<S2SV_blank>port<S2SV_blank>%d\" , settings . udpport ) ; exit ( EX_OSERR ) ; } if ( portnumber_file ) { fclose ( portnumber_file ) ; rename ( temp_portnumber_filename , portnumber_filename ) ; } if ( temp_portnumber_filename ) free ( temp_portnumber_filename ) ; } usleep ( 1000 ) ; if ( stats_state . curr_conns + stats_state . reserved_fds >= settings . maxconns - 1 ) { fprintf ( stderr , \"Maxconns<S2SV_blank>setting<S2SV_blank>is<S2SV_blank>too<S2SV_blank>low,<S2SV_blank>use<S2SV_blank>-c<S2SV_blank>to<S2SV_blank>increase.\\\\n\" ) ; exit ( EXIT_FAILURE ) ; } if ( pid_file != NULL ) { save_pid ( pid_file ) ; } if ( settings . drop_privileges ) { drop_privileges ( ) ; } uriencode_init ( ) ; if ( event_base_loop ( main_base , 0 ) != 0 ) { retval = EXIT_FAILURE ; } stop_assoc_maintenance_thread ( ) ; if ( do_daemonize ) remove_pidfile ( pid_file ) ; if ( settings . inter ) free ( settings . inter ) ; if ( l_socket ) free ( l_socket ) ; if ( u_socket ) free ( u_socket ) ; event_base_free ( main_base ) ; return retval ; }\n","target":"<S2SV_ModStart> } if ( <S2SV_ModEnd> udp_specified && settings\n","project_and_commit_id":"memcached@memcached/dbb7a8af90054bf4ef51f5814ef7ceb17d83d974","cve_id":"CVE-2018-1000115","original_address":"https://github.com/memcached/memcached/commit/dbb7a8af90054bf4ef51f5814ef7ceb17d83d974","time":"2018-03-05T14:29Z"},
	{"Unnamed: 0":4266,"cwe_id":"CWE-119","source":"CWE-119 static cJSON * create_reference ( cJSON * item ) { <S2SV_StartBug> cJSON * ref ; <S2SV_EndBug> <S2SV_StartBug> if ( ! ( ref = cJSON_New_Item ( ) ) ) <S2SV_EndBug> return 0 ; memcpy ( ref , item , sizeof ( cJSON ) ) ; ref -> string = 0 ; ref -> type |= cJSON_IsReference ; ref -> next = ref -> prev = 0 ; return ref ; }\n","target":"<S2SV_ModStart> { cJSON * <S2SV_ModEnd> ref = cJSON_New_Item <S2SV_ModStart> cJSON_New_Item ( ) ; if ( ! ref ) <S2SV_ModEnd> return 0 ;\n","project_and_commit_id":"esnet@iperf/91f2fa59e8ed80dfbf400add0164ee0e508e412a","cve_id":"CVE-2016-4303","original_address":"https://github.com/esnet/iperf/commit/91f2fa59e8ed80dfbf400add0164ee0e508e412a","time":"2016-09-26T14:59Z"},
	{"Unnamed: 0":2594,"cwe_id":"CWE-119","source":"CWE-119 static krb5_error_code build_principal_va ( krb5_context context , krb5_principal princ , unsigned int rlen , const char * realm , va_list ap ) { krb5_error_code retval = 0 ; char * r = NULL ; krb5_data * data = NULL ; krb5_int32 count = 0 ; krb5_int32 size = 2 ; char * component = NULL ; data = malloc ( size * sizeof ( krb5_data ) ) ; if ( ! data ) { retval = ENOMEM ; } <S2SV_StartBug> if ( ! retval ) { <S2SV_EndBug> r = strdup ( realm ) ; if ( ! r ) { retval = ENOMEM ; } } while ( ! retval && ( component = va_arg ( ap , char * ) ) ) { if ( count == size ) { krb5_data * new_data = NULL ; size *= 2 ; new_data = realloc ( data , size * sizeof ( krb5_data ) ) ; if ( new_data ) { data = new_data ; } else { retval = ENOMEM ; } } if ( ! retval ) { data [ count ] . length = strlen ( component ) ; data [ count ] . data = strdup ( component ) ; if ( ! data [ count ] . data ) { retval = ENOMEM ; } count ++ ; } } if ( ! retval ) { princ -> type = KRB5_NT_UNKNOWN ; princ -> magic = KV5M_PRINCIPAL ; princ -> realm = make_data ( r , rlen ) ; princ -> data = data ; princ -> length = count ; r = NULL ; data = NULL ; } if ( data ) { while ( -- count >= 0 ) { free ( data [ count ] . data ) ; } free ( data ) ; } free ( r ) ; return retval ; }\n","target":"<S2SV_ModStart> ! retval ) r = k5memdup0 ( realm , rlen , & retval ) ; <S2SV_ModEnd> while ( !\n","project_and_commit_id":"krb5@krb5/f0c094a1b745d91ef2f9a4eae2149aac026a5789","cve_id":"CVE-2015-2697","original_address":"https://github.com/krb5/krb5/commit/f0c094a1b745d91ef2f9a4eae2149aac026a5789","time":"2015-11-09T03:59Z"},
	{"Unnamed: 0":4290,"cwe_id":"CWE-416","source":"CWE-416 int SMB2_read ( const unsigned int xid , struct cifs_io_parms * io_parms , unsigned int * nbytes , char * * buf , int * buf_type ) { struct smb_rqst rqst ; int resp_buftype , rc = - EACCES ; struct smb2_read_plain_req * req = NULL ; struct smb2_read_rsp * rsp = NULL ; struct kvec iov [ 1 ] ; struct kvec rsp_iov ; unsigned int total_len ; int flags = CIFS_LOG_ERROR ; struct cifs_ses * ses = io_parms -> tcon -> ses ; * nbytes = 0 ; rc = smb2_new_read_req ( ( void * * ) & req , & total_len , io_parms , NULL , 0 , 0 ) ; if ( rc ) return rc ; if ( smb3_encryption_required ( io_parms -> tcon ) ) flags |= CIFS_TRANSFORM_REQ ; iov [ 0 ] . iov_base = ( char * ) req ; iov [ 0 ] . iov_len = total_len ; memset ( & rqst , 0 , sizeof ( struct smb_rqst ) ) ; rqst . rq_iov = iov ; rqst . rq_nvec = 1 ; rc = cifs_send_recv ( xid , ses , & rqst , & resp_buftype , flags , & rsp_iov ) ; <S2SV_StartBug> cifs_small_buf_release ( req ) ; <S2SV_EndBug> rsp = ( struct smb2_read_rsp * ) rsp_iov . iov_base ; if ( rc ) { if ( rc != - ENODATA ) { cifs_stats_fail_inc ( io_parms -> tcon , SMB2_READ_HE ) ; cifs_dbg ( VFS , \"Send<S2SV_blank>error<S2SV_blank>in<S2SV_blank>read<S2SV_blank>=<S2SV_blank>%d\\\\n\" , rc ) ; trace_smb3_read_err ( xid , req -> PersistentFileId , io_parms -> tcon -> tid , ses -> Suid , io_parms -> offset , io_parms -> length , rc ) ; } else trace_smb3_read_done ( xid , req -> PersistentFileId , io_parms -> tcon -> tid , ses -> Suid , io_parms -> offset , 0 ) ; free_rsp_buf ( resp_buftype , rsp_iov . iov_base ) ; return rc == - ENODATA ? 0 : rc ; } else trace_smb3_read_done ( xid , req -> PersistentFileId , io_parms -> tcon -> tid , ses -> Suid , io_parms -> offset , io_parms -> length ) ; <S2SV_StartBug> * nbytes = le32_to_cpu ( rsp -> DataLength ) ; <S2SV_EndBug> if ( ( * nbytes > CIFS_MAX_MSGSIZE ) || ( * nbytes > io_parms -> length ) ) { cifs_dbg ( FYI , \"bad<S2SV_blank>length<S2SV_blank>%d<S2SV_blank>for<S2SV_blank>count<S2SV_blank>%d\\\\n\" , * nbytes , io_parms -> length ) ; rc = - EIO ; * nbytes = 0 ; } if ( * buf ) { memcpy ( * buf , ( char * ) rsp + rsp -> DataOffset , * nbytes ) ; free_rsp_buf ( resp_buftype , rsp_iov . iov_base ) ; } else if ( resp_buftype != CIFS_NO_BUFFER ) { * buf = rsp_iov . iov_base ; if ( resp_buftype == CIFS_SMALL_BUFFER ) * buf_type = CIFS_SMALL_BUFFER ; else if ( resp_buftype == CIFS_LARGE_BUFFER ) * buf_type = CIFS_LARGE_BUFFER ; } return rc ; }\n","target":"<S2SV_ModStart> rsp_iov ) ; <S2SV_ModEnd> rsp = ( <S2SV_ModStart> length ) ; cifs_small_buf_release ( req ) ;\n","project_and_commit_id":"torvalds@linux/088aaf17aa79300cab14dbee2569c58cfafd7d6e","cve_id":"CVE-2019-15920","original_address":"https://github.com/torvalds/linux/commit/088aaf17aa79300cab14dbee2569c58cfafd7d6e","time":"2019-09-04T19:15Z"},
	{"Unnamed: 0":1127,"cwe_id":"CWE-119","source":"CWE-119 static int check_alu_op ( struct bpf_verifier_env * env , struct bpf_insn * insn ) { struct bpf_reg_state * regs = cur_regs ( env ) ; u8 opcode = BPF_OP ( insn -> code ) ; int err ; if ( opcode == BPF_END || opcode == BPF_NEG ) { if ( opcode == BPF_NEG ) { if ( BPF_SRC ( insn -> code ) != 0 || insn -> src_reg != BPF_REG_0 || insn -> off != 0 || insn -> imm != 0 ) { verbose ( env , \"BPF_NEG<S2SV_blank>uses<S2SV_blank>reserved<S2SV_blank>fields\\\\n\" ) ; return - EINVAL ; } } else { if ( insn -> src_reg != BPF_REG_0 || insn -> off != 0 || ( insn -> imm != 16 && insn -> imm != 32 && insn -> imm != 64 ) || BPF_CLASS ( insn -> code ) == BPF_ALU64 ) { verbose ( env , \"BPF_END<S2SV_blank>uses<S2SV_blank>reserved<S2SV_blank>fields\\\\n\" ) ; return - EINVAL ; } } err = check_reg_arg ( env , insn -> dst_reg , SRC_OP ) ; if ( err ) return err ; if ( is_pointer_value ( env , insn -> dst_reg ) ) { verbose ( env , \"R%d<S2SV_blank>pointer<S2SV_blank>arithmetic<S2SV_blank>prohibited\\\\n\" , insn -> dst_reg ) ; return - EACCES ; } err = check_reg_arg ( env , insn -> dst_reg , DST_OP ) ; if ( err ) return err ; } else if ( opcode == BPF_MOV ) { if ( BPF_SRC ( insn -> code ) == BPF_X ) { if ( insn -> imm != 0 || insn -> off != 0 ) { verbose ( env , \"BPF_MOV<S2SV_blank>uses<S2SV_blank>reserved<S2SV_blank>fields\\\\n\" ) ; return - EINVAL ; } err = check_reg_arg ( env , insn -> src_reg , SRC_OP ) ; if ( err ) return err ; } else { if ( insn -> src_reg != BPF_REG_0 || insn -> off != 0 ) { verbose ( env , \"BPF_MOV<S2SV_blank>uses<S2SV_blank>reserved<S2SV_blank>fields\\\\n\" ) ; return - EINVAL ; } } err = check_reg_arg ( env , insn -> dst_reg , DST_OP ) ; if ( err ) return err ; if ( BPF_SRC ( insn -> code ) == BPF_X ) { if ( BPF_CLASS ( insn -> code ) == BPF_ALU64 ) { regs [ insn -> dst_reg ] = regs [ insn -> src_reg ] ; regs [ insn -> dst_reg ] . live |= REG_LIVE_WRITTEN ; } else { if ( is_pointer_value ( env , insn -> src_reg ) ) { verbose ( env , \"R%d<S2SV_blank>partial<S2SV_blank>copy<S2SV_blank>of<S2SV_blank>pointer\\\\n\" , insn -> src_reg ) ; return - EACCES ; } mark_reg_unknown ( env , regs , insn -> dst_reg ) ; regs [ insn -> dst_reg ] . var_off = tnum_cast ( regs [ insn -> dst_reg ] . var_off , 4 ) ; __update_reg_bounds ( & regs [ insn -> dst_reg ] ) ; } } else { regs [ insn -> dst_reg ] . type = SCALAR_VALUE ; <S2SV_StartBug> __mark_reg_known ( regs + insn -> dst_reg , insn -> imm ) ; <S2SV_EndBug> } } else if ( opcode > BPF_END ) { verbose ( env , \"invalid<S2SV_blank>BPF_ALU<S2SV_blank>opcode<S2SV_blank>%x\\\\n\" , opcode ) ; return - EINVAL ; } else { if ( BPF_SRC ( insn -> code ) == BPF_X ) { if ( insn -> imm != 0 || insn -> off != 0 ) { verbose ( env , \"BPF_ALU<S2SV_blank>uses<S2SV_blank>reserved<S2SV_blank>fields\\\\n\" ) ; return - EINVAL ; } err = check_reg_arg ( env , insn -> src_reg , SRC_OP ) ; if ( err ) return err ; } else { if ( insn -> src_reg != BPF_REG_0 || insn -> off != 0 ) { verbose ( env , \"BPF_ALU<S2SV_blank>uses<S2SV_blank>reserved<S2SV_blank>fields\\\\n\" ) ; return - EINVAL ; } } err = check_reg_arg ( env , insn -> dst_reg , SRC_OP ) ; if ( err ) return err ; if ( ( opcode == BPF_MOD || opcode == BPF_DIV ) && BPF_SRC ( insn -> code ) == BPF_K && insn -> imm == 0 ) { verbose ( env , \"div<S2SV_blank>by<S2SV_blank>zero\\\\n\" ) ; return - EINVAL ; } if ( ( opcode == BPF_LSH || opcode == BPF_RSH || opcode == BPF_ARSH ) && BPF_SRC ( insn -> code ) == BPF_K ) { int size = BPF_CLASS ( insn -> code ) == BPF_ALU64 ? 64 : 32 ; if ( insn -> imm < 0 || insn -> imm >= size ) { verbose ( env , \"invalid<S2SV_blank>shift<S2SV_blank>%d\\\\n\" , insn -> imm ) ; return - EINVAL ; } } err = check_reg_arg ( env , insn -> dst_reg , DST_OP_NO_MARK ) ; if ( err ) return err ; return adjust_reg_min_max_vals ( env , insn ) ; } return 0 ; }\n","target":"<S2SV_ModStart> = SCALAR_VALUE ; if ( BPF_CLASS ( insn -> code ) == BPF_ALU64 ) { <S2SV_ModStart> -> dst_reg , insn -> imm ) ; } else { __mark_reg_known ( regs + insn -> dst_reg , ( u32 ) insn -> imm ) ; } <S2SV_ModEnd> } } else\n","project_and_commit_id":"torvalds@linux/95a762e2c8c942780948091f8f2a4f32fce1ac6f","cve_id":"CVE-2017-16995","original_address":"https://github.com/torvalds/linux/commit/95a762e2c8c942780948091f8f2a4f32fce1ac6f","time":"2017-12-27T17:08Z"},
	{"Unnamed: 0":574,"cwe_id":"CWE-787","source":"CWE-787 static void rfbProcessClientNormalMessage ( rfbClientPtr cl ) { int n ; rfbClientToServerMsg msg ; char * str ; READ ( ( char * ) & msg , 1 ) switch ( msg . type ) { case rfbSetPixelFormat : READ ( ( ( char * ) & msg ) + 1 , sz_rfbSetPixelFormatMsg - 1 ) cl -> format . bitsPerPixel = msg . spf . format . bitsPerPixel ; cl -> format . depth = msg . spf . format . depth ; cl -> format . bigEndian = ( msg . spf . format . bigEndian ? 1 : 0 ) ; cl -> format . trueColour = ( msg . spf . format . trueColour ? 1 : 0 ) ; cl -> format . redMax = Swap16IfLE ( msg . spf . format . redMax ) ; cl -> format . greenMax = Swap16IfLE ( msg . spf . format . greenMax ) ; cl -> format . blueMax = Swap16IfLE ( msg . spf . format . blueMax ) ; cl -> format . redShift = msg . spf . format . redShift ; cl -> format . greenShift = msg . spf . format . greenShift ; cl -> format . blueShift = msg . spf . format . blueShift ; cl -> readyForSetColourMapEntries = TRUE ; rfbSetTranslateFunction ( cl ) ; return ; case rfbFixColourMapEntries : READ ( ( ( char * ) & msg ) + 1 , sz_rfbFixColourMapEntriesMsg - 1 ) rfbLog ( \"rfbProcessClientNormalMessage:<S2SV_blank>FixColourMapEntries<S2SV_blank>unsupported\\\\n\" ) ; rfbCloseClient ( cl ) ; return ; case rfbSetEncodings : { int i ; CARD32 enc ; Bool firstFence = ! cl -> enableFence ; Bool firstCU = ! cl -> enableCU ; Bool firstGII = ! cl -> enableGII ; Bool logTightCompressLevel = FALSE ; READ ( ( ( char * ) & msg ) + 1 , sz_rfbSetEncodingsMsg - 1 ) msg . se . nEncodings = Swap16IfLE ( msg . se . nEncodings ) ; cl -> preferredEncoding = - 1 ; cl -> useCopyRect = FALSE ; cl -> enableCursorShapeUpdates = FALSE ; cl -> enableCursorPosUpdates = FALSE ; cl -> enableLastRectEncoding = FALSE ; cl -> tightCompressLevel = TIGHT_DEFAULT_COMPRESSION ; cl -> tightSubsampLevel = TIGHT_DEFAULT_SUBSAMP ; cl -> tightQualityLevel = - 1 ; cl -> imageQualityLevel = - 1 ; for ( i = 0 ; i < msg . se . nEncodings ; i ++ ) { READ ( ( char * ) & enc , 4 ) enc = Swap32IfLE ( enc ) ; switch ( enc ) { case rfbEncodingCopyRect : cl -> useCopyRect = TRUE ; break ; case rfbEncodingRaw : if ( cl -> preferredEncoding == - 1 ) { cl -> preferredEncoding = enc ; rfbLog ( \"Using<S2SV_blank>raw<S2SV_blank>encoding<S2SV_blank>for<S2SV_blank>client<S2SV_blank>%s\\\\n\" , cl -> host ) ; } break ; case rfbEncodingRRE : if ( cl -> preferredEncoding == - 1 ) { cl -> preferredEncoding = enc ; rfbLog ( \"Using<S2SV_blank>rre<S2SV_blank>encoding<S2SV_blank>for<S2SV_blank>client<S2SV_blank>%s\\\\n\" , cl -> host ) ; } break ; case rfbEncodingCoRRE : if ( cl -> preferredEncoding == - 1 ) { cl -> preferredEncoding = enc ; rfbLog ( \"Using<S2SV_blank>CoRRE<S2SV_blank>encoding<S2SV_blank>for<S2SV_blank>client<S2SV_blank>%s\\\\n\" , cl -> host ) ; } break ; case rfbEncodingHextile : if ( cl -> preferredEncoding == - 1 ) { cl -> preferredEncoding = enc ; rfbLog ( \"Using<S2SV_blank>hextile<S2SV_blank>encoding<S2SV_blank>for<S2SV_blank>client<S2SV_blank>%s\\\\n\" , cl -> host ) ; } break ; case rfbEncodingZlib : if ( cl -> preferredEncoding == - 1 ) { cl -> preferredEncoding = enc ; rfbLog ( \"Using<S2SV_blank>zlib<S2SV_blank>encoding<S2SV_blank>for<S2SV_blank>client<S2SV_blank>%s\\\\n\" , cl -> host ) ; } break ; case rfbEncodingZRLE : if ( cl -> preferredEncoding == - 1 ) { cl -> preferredEncoding = enc ; rfbLog ( \"Using<S2SV_blank>ZRLE<S2SV_blank>encoding<S2SV_blank>for<S2SV_blank>client<S2SV_blank>%s\\\\n\" , cl -> host ) ; } break ; case rfbEncodingZYWRLE : if ( cl -> preferredEncoding == - 1 ) { cl -> preferredEncoding = enc ; rfbLog ( \"Using<S2SV_blank>ZYWRLE<S2SV_blank>encoding<S2SV_blank>for<S2SV_blank>client<S2SV_blank>%s\\\\n\" , cl -> host ) ; } break ; case rfbEncodingTight : if ( cl -> preferredEncoding == - 1 ) { cl -> preferredEncoding = enc ; rfbLog ( \"Using<S2SV_blank>tight<S2SV_blank>encoding<S2SV_blank>for<S2SV_blank>client<S2SV_blank>%s\\\\n\" , cl -> host ) ; } break ; case rfbEncodingXCursor : if ( ! cl -> enableCursorShapeUpdates ) { rfbLog ( \"Enabling<S2SV_blank>X-style<S2SV_blank>cursor<S2SV_blank>updates<S2SV_blank>for<S2SV_blank>client<S2SV_blank>%s\\\\n\" , cl -> host ) ; cl -> enableCursorShapeUpdates = TRUE ; cl -> useRichCursorEncoding = FALSE ; cl -> cursorWasChanged = TRUE ; } break ; case rfbEncodingRichCursor : if ( ! cl -> enableCursorShapeUpdates ) { rfbLog ( \"Enabling<S2SV_blank>full-color<S2SV_blank>cursor<S2SV_blank>updates<S2SV_blank>for<S2SV_blank>client<S2SV_blank>%s\\\\n\" , cl -> host ) ; cl -> enableCursorShapeUpdates = TRUE ; cl -> useRichCursorEncoding = TRUE ; cl -> cursorWasChanged = TRUE ; } break ; case rfbEncodingPointerPos : if ( ! cl -> enableCursorPosUpdates ) { rfbLog ( \"Enabling<S2SV_blank>cursor<S2SV_blank>position<S2SV_blank>updates<S2SV_blank>for<S2SV_blank>client<S2SV_blank>%s\\\\n\" , cl -> host ) ; cl -> enableCursorPosUpdates = TRUE ; cl -> cursorWasMoved = TRUE ; cl -> cursorX = - 1 ; cl -> cursorY = - 1 ; } break ; case rfbEncodingLastRect : if ( ! cl -> enableLastRectEncoding ) { rfbLog ( \"Enabling<S2SV_blank>LastRect<S2SV_blank>protocol<S2SV_blank>extension<S2SV_blank>for<S2SV_blank>client<S2SV_blank>%s\\\\n\" , cl -> host ) ; cl -> enableLastRectEncoding = TRUE ; } break ; case rfbEncodingFence : if ( ! cl -> enableFence ) { rfbLog ( \"Enabling<S2SV_blank>Fence<S2SV_blank>protocol<S2SV_blank>extension<S2SV_blank>for<S2SV_blank>client<S2SV_blank>%s\\\\n\" , cl -> host ) ; cl -> enableFence = TRUE ; } break ; case rfbEncodingContinuousUpdates : if ( ! cl -> enableCU ) { rfbLog ( \"Enabling<S2SV_blank>Continuous<S2SV_blank>Updates<S2SV_blank>protocol<S2SV_blank>extension<S2SV_blank>for<S2SV_blank>client<S2SV_blank>%s\\\\n\" , cl -> host ) ; cl -> enableCU = TRUE ; } break ; case rfbEncodingNewFBSize : if ( ! cl -> enableDesktopSize ) { if ( ! rfbAuthDisableRemoteResize ) { rfbLog ( \"Enabling<S2SV_blank>Desktop<S2SV_blank>Size<S2SV_blank>protocol<S2SV_blank>extension<S2SV_blank>for<S2SV_blank>client<S2SV_blank>%s\\\\n\" , cl -> host ) ; cl -> enableDesktopSize = TRUE ; } else rfbLog ( \"WARNING:<S2SV_blank>Remote<S2SV_blank>desktop<S2SV_blank>resizing<S2SV_blank>disabled<S2SV_blank>per<S2SV_blank>system<S2SV_blank>policy.\\\\n\" ) ; } break ; case rfbEncodingExtendedDesktopSize : if ( ! cl -> enableExtDesktopSize ) { if ( ! rfbAuthDisableRemoteResize ) { rfbLog ( \"Enabling<S2SV_blank>Extended<S2SV_blank>Desktop<S2SV_blank>Size<S2SV_blank>protocol<S2SV_blank>extension<S2SV_blank>for<S2SV_blank>client<S2SV_blank>%s\\\\n\" , cl -> host ) ; cl -> enableExtDesktopSize = TRUE ; } else rfbLog ( \"WARNING:<S2SV_blank>Remote<S2SV_blank>desktop<S2SV_blank>resizing<S2SV_blank>disabled<S2SV_blank>per<S2SV_blank>system<S2SV_blank>policy.\\\\n\" ) ; } break ; case rfbEncodingGII : if ( ! cl -> enableGII ) { rfbLog ( \"Enabling<S2SV_blank>GII<S2SV_blank>extension<S2SV_blank>for<S2SV_blank>client<S2SV_blank>%s\\\\n\" , cl -> host ) ; cl -> enableGII = TRUE ; } break ; default : if ( enc >= ( CARD32 ) rfbEncodingCompressLevel0 && enc <= ( CARD32 ) rfbEncodingCompressLevel9 ) { cl -> zlibCompressLevel = enc & 0x0F ; cl -> tightCompressLevel = enc & 0x0F ; if ( cl -> preferredEncoding == rfbEncodingTight ) logTightCompressLevel = TRUE ; else rfbLog ( \"Using<S2SV_blank>compression<S2SV_blank>level<S2SV_blank>%d<S2SV_blank>for<S2SV_blank>client<S2SV_blank>%s\\\\n\" , cl -> tightCompressLevel , cl -> host ) ; if ( rfbInterframe == - 1 ) { if ( cl -> tightCompressLevel >= 5 ) { if ( ! InterframeOn ( cl ) ) { rfbCloseClient ( cl ) ; return ; } } else InterframeOff ( cl ) ; } } else if ( enc >= ( CARD32 ) rfbEncodingSubsamp1X && enc <= ( CARD32 ) rfbEncodingSubsampGray ) { cl -> tightSubsampLevel = enc & 0xFF ; rfbLog ( \"Using<S2SV_blank>JPEG<S2SV_blank>subsampling<S2SV_blank>%d<S2SV_blank>for<S2SV_blank>client<S2SV_blank>%s\\\\n\" , cl -> tightSubsampLevel , cl -> host ) ; } else if ( enc >= ( CARD32 ) rfbEncodingQualityLevel0 && enc <= ( CARD32 ) rfbEncodingQualityLevel9 ) { cl -> tightQualityLevel = JPEG_QUAL [ enc & 0x0F ] ; cl -> tightSubsampLevel = JPEG_SUBSAMP [ enc & 0x0F ] ; cl -> imageQualityLevel = enc & 0x0F ; if ( cl -> preferredEncoding == rfbEncodingTight ) rfbLog ( \"Using<S2SV_blank>JPEG<S2SV_blank>subsampling<S2SV_blank>%d,<S2SV_blank>Q%d<S2SV_blank>for<S2SV_blank>client<S2SV_blank>%s\\\\n\" , cl -> tightSubsampLevel , cl -> tightQualityLevel , cl -> host ) ; else rfbLog ( \"Using<S2SV_blank>image<S2SV_blank>quality<S2SV_blank>level<S2SV_blank>%d<S2SV_blank>for<S2SV_blank>client<S2SV_blank>%s\\\\n\" , cl -> imageQualityLevel , cl -> host ) ; } else if ( enc >= ( CARD32 ) rfbEncodingFineQualityLevel0 + 1 && enc <= ( CARD32 ) rfbEncodingFineQualityLevel100 ) { cl -> tightQualityLevel = enc & 0xFF ; rfbLog ( \"Using<S2SV_blank>JPEG<S2SV_blank>quality<S2SV_blank>%d<S2SV_blank>for<S2SV_blank>client<S2SV_blank>%s\\\\n\" , cl -> tightQualityLevel , cl -> host ) ; } else { rfbLog ( \"rfbProcessClientNormalMessage:<S2SV_blank>ignoring<S2SV_blank>unknown<S2SV_blank>encoding<S2SV_blank>%d<S2SV_blank>(%x)\\\\n\" , ( int ) enc , ( int ) enc ) ; } } } if ( cl -> preferredEncoding == - 1 ) cl -> preferredEncoding = rfbEncodingTight ; if ( cl -> preferredEncoding == rfbEncodingTight && logTightCompressLevel ) rfbLog ( \"Using<S2SV_blank>Tight<S2SV_blank>compression<S2SV_blank>level<S2SV_blank>%d<S2SV_blank>for<S2SV_blank>client<S2SV_blank>%s\\\\n\" , rfbTightCompressLevel ( cl ) , cl -> host ) ; if ( cl -> enableCursorPosUpdates && ! cl -> enableCursorShapeUpdates ) { rfbLog ( \"Disabling<S2SV_blank>cursor<S2SV_blank>position<S2SV_blank>updates<S2SV_blank>for<S2SV_blank>client<S2SV_blank>%s\\\\n\" , cl -> host ) ; cl -> enableCursorPosUpdates = FALSE ; } if ( cl -> enableFence && firstFence ) { if ( ! rfbSendFence ( cl , rfbFenceFlagRequest , 0 , NULL ) ) return ; } if ( cl -> enableCU && cl -> enableFence && firstCU ) { if ( ! rfbSendEndOfCU ( cl ) ) return ; } if ( cl -> enableGII && firstGII ) { rfbGIIServerVersionMsg msg ; msg . type = rfbGIIServer ; msg . endianAndSubType = rfbGIIVersion | rfbGIIBE ; msg . length = Swap16IfLE ( sz_rfbGIIServerVersionMsg - 4 ) ; msg . maximumVersion = msg . minimumVersion = Swap16IfLE ( 1 ) ; if ( WriteExact ( cl , ( char * ) & msg , sz_rfbGIIServerVersionMsg ) < 0 ) { rfbLogPerror ( \"rfbProcessClientNormalMessage:<S2SV_blank>write\" ) ; rfbCloseClient ( cl ) ; return ; } } return ; } case rfbFramebufferUpdateRequest : { RegionRec tmpRegion ; BoxRec box ; READ ( ( ( char * ) & msg ) + 1 , sz_rfbFramebufferUpdateRequestMsg - 1 ) box . x1 = Swap16IfLE ( msg . fur . x ) ; box . y1 = Swap16IfLE ( msg . fur . y ) ; box . x2 = box . x1 + Swap16IfLE ( msg . fur . w ) ; box . y2 = box . y1 + Swap16IfLE ( msg . fur . h ) ; SAFE_REGION_INIT ( pScreen , & tmpRegion , & box , 0 ) ; if ( ! msg . fur . incremental || ! cl -> continuousUpdates ) REGION_UNION ( pScreen , & cl -> requestedRegion , & cl -> requestedRegion , & tmpRegion ) ; if ( ! cl -> readyForSetColourMapEntries ) { cl -> readyForSetColourMapEntries = TRUE ; if ( ! cl -> format . trueColour ) { if ( ! rfbSetClientColourMap ( cl , 0 , 0 ) ) { REGION_UNINIT ( pScreen , & tmpRegion ) ; return ; } } } if ( ! msg . fur . incremental ) { REGION_UNION ( pScreen , & cl -> modifiedRegion , & cl -> modifiedRegion , & tmpRegion ) ; REGION_SUBTRACT ( pScreen , & cl -> copyRegion , & cl -> copyRegion , & tmpRegion ) ; REGION_UNION ( pScreen , & cl -> ifRegion , & cl -> ifRegion , & tmpRegion ) ; cl -> pendingExtDesktopResize = TRUE ; } if ( FB_UPDATE_PENDING ( cl ) && ( ! cl -> deferredUpdateScheduled || rfbDeferUpdateTime == 0 || gettime ( ) - cl -> deferredUpdateStart >= ( double ) rfbDeferUpdateTime ) ) { if ( rfbSendFramebufferUpdate ( cl ) ) cl -> deferredUpdateScheduled = FALSE ; } REGION_UNINIT ( pScreen , & tmpRegion ) ; return ; } case rfbKeyEvent : cl -> rfbKeyEventsRcvd ++ ; READ ( ( ( char * ) & msg ) + 1 , sz_rfbKeyEventMsg - 1 ) if ( ! rfbViewOnly && ! cl -> viewOnly ) KeyEvent ( ( KeySym ) Swap32IfLE ( msg . ke . key ) , msg . ke . down ) ; return ; case rfbPointerEvent : cl -> rfbPointerEventsRcvd ++ ; READ ( ( ( char * ) & msg ) + 1 , sz_rfbPointerEventMsg - 1 ) if ( pointerClient && ( pointerClient != cl ) ) return ; if ( msg . pe . buttonMask == 0 ) pointerClient = NULL ; else pointerClient = cl ; if ( ! rfbViewOnly && ! cl -> viewOnly ) { cl -> cursorX = ( int ) Swap16IfLE ( msg . pe . x ) ; cl -> cursorY = ( int ) Swap16IfLE ( msg . pe . y ) ; PtrAddEvent ( msg . pe . buttonMask , cl -> cursorX , cl -> cursorY , cl ) ; } return ; case rfbClientCutText : { int ignoredBytes = 0 ; READ ( ( ( char * ) & msg ) + 1 , sz_rfbClientCutTextMsg - 1 ) msg . cct . length = Swap32IfLE ( msg . cct . length ) ; if ( msg . cct . length > rfbMaxClipboard ) { rfbLog ( \"Truncating<S2SV_blank>%d-byte<S2SV_blank>clipboard<S2SV_blank>update<S2SV_blank>to<S2SV_blank>%d<S2SV_blank>bytes.\\\\n\" , msg . cct . length , rfbMaxClipboard ) ; ignoredBytes = msg . cct . length - rfbMaxClipboard ; msg . cct . length = rfbMaxClipboard ; } if ( msg . cct . length <= 0 ) return ; str = ( char * ) malloc ( msg . cct . length ) ; if ( str == NULL ) { rfbLogPerror ( \"rfbProcessClientNormalMessage:<S2SV_blank>rfbClientCutText<S2SV_blank>out<S2SV_blank>of<S2SV_blank>memory\" ) ; rfbCloseClient ( cl ) ; return ; } if ( ( n = ReadExact ( cl , str , msg . cct . length ) ) <= 0 ) { if ( n != 0 ) rfbLogPerror ( \"rfbProcessClientNormalMessage:<S2SV_blank>read\" ) ; free ( str ) ; rfbCloseClient ( cl ) ; return ; } if ( ignoredBytes > 0 ) { if ( ( n = SkipExact ( cl , ignoredBytes ) ) <= 0 ) { if ( n != 0 ) rfbLogPerror ( \"rfbProcessClientNormalMessage:<S2SV_blank>read\" ) ; free ( str ) ; rfbCloseClient ( cl ) ; return ; } } if ( ! rfbViewOnly && ! cl -> viewOnly && ! rfbAuthDisableCBRecv ) { vncClientCutText ( str , msg . cct . length ) ; if ( rfbSyncCutBuffer ) rfbSetXCutText ( str , msg . cct . length ) ; } free ( str ) ; return ; } case rfbEnableContinuousUpdates : { BoxRec box ; READ ( ( ( char * ) & msg ) + 1 , sz_rfbEnableContinuousUpdatesMsg - 1 ) if ( ! cl -> enableFence || ! cl -> enableCU ) { rfbLog ( \"Ignoring<S2SV_blank>request<S2SV_blank>to<S2SV_blank>enable<S2SV_blank>continuous<S2SV_blank>updates<S2SV_blank>because<S2SV_blank>the<S2SV_blank>client<S2SV_blank>does<S2SV_blank>not\\\\n\" ) ; rfbLog ( \"support<S2SV_blank>the<S2SV_blank>flow<S2SV_blank>control<S2SV_blank>extensions.\\\\n\" ) ; return ; } box . x1 = Swap16IfLE ( msg . ecu . x ) ; box . y1 = Swap16IfLE ( msg . ecu . y ) ; box . x2 = box . x1 + Swap16IfLE ( msg . ecu . w ) ; box . y2 = box . y1 + Swap16IfLE ( msg . ecu . h ) ; SAFE_REGION_INIT ( pScreen , & cl -> cuRegion , & box , 0 ) ; cl -> continuousUpdates = msg . ecu . enable ; if ( cl -> continuousUpdates ) { REGION_EMPTY ( pScreen , & cl -> requestedRegion ) ; if ( ! rfbSendFramebufferUpdate ( cl ) ) return ; } else { if ( ! rfbSendEndOfCU ( cl ) ) return ; } rfbLog ( \"Continuous<S2SV_blank>updates<S2SV_blank>%s\\\\n\" , cl -> continuousUpdates ? \"enabled\" : \"disabled\" ) ; return ; } case rfbFence : { CARD32 flags ; char data [ 64 ] ; READ ( ( ( char * ) & msg ) + 1 , sz_rfbFenceMsg - 1 ) flags = Swap32IfLE ( msg . f . flags ) ; <S2SV_StartBug> READ ( data , msg . f . length ) <S2SV_EndBug> <S2SV_StartBug> if ( msg . f . length > sizeof ( data ) ) <S2SV_EndBug> rfbLog ( \"Ignoring<S2SV_blank>fence.<S2SV_blank><S2SV_blank>Payload<S2SV_blank>of<S2SV_blank>%d<S2SV_blank>bytes<S2SV_blank>is<S2SV_blank>too<S2SV_blank>large.\\\\n\" , msg . f . length ) ; <S2SV_StartBug> else <S2SV_EndBug> <S2SV_StartBug> HandleFence ( cl , flags , msg . f . length , data ) ; <S2SV_EndBug> return ; } # define EDSERROR ( format , args ... ) { if ( ! strlen ( errMsg ) ) snprintf ( errMsg , 256 , \"Desktop<S2SV_blank>resize<S2SV_blank>ERROR:<S2SV_blank>\" format \"\\\\n\" , args ) ; result = rfbEDSResultInvalid ; } case rfbSetDesktopSize : { int i ; struct xorg_list newScreens ; rfbClientPtr cl2 ; int result = rfbEDSResultSuccess ; char errMsg [ 256 ] = \"\\\\0\" ; ScreenPtr pScreen = screenInfo . screens [ 0 ] ; READ ( ( ( char * ) & msg ) + 1 , sz_rfbSetDesktopSizeMsg - 1 ) if ( msg . sds . numScreens < 1 ) EDSERROR ( \"Requested<S2SV_blank>number<S2SV_blank>of<S2SV_blank>screens<S2SV_blank>%d<S2SV_blank>is<S2SV_blank>invalid\" , msg . sds . numScreens ) ; msg . sds . w = Swap16IfLE ( msg . sds . w ) ; msg . sds . h = Swap16IfLE ( msg . sds . h ) ; if ( msg . sds . w < 1 || msg . sds . h < 1 ) EDSERROR ( \"Requested<S2SV_blank>framebuffer<S2SV_blank>dimensions<S2SV_blank>%dx%d<S2SV_blank>are<S2SV_blank>invalid\" , msg . sds . w , msg . sds . h ) ; xorg_list_init ( & newScreens ) ; for ( i = 0 ; i < msg . sds . numScreens ; i ++ ) { rfbScreenInfo * screen = rfbNewScreen ( 0 , 0 , 0 , 0 , 0 , 0 ) ; READ ( ( char * ) & screen -> s , sizeof ( rfbScreenDesc ) ) screen -> s . id = Swap32IfLE ( screen -> s . id ) ; screen -> s . x = Swap16IfLE ( screen -> s . x ) ; screen -> s . y = Swap16IfLE ( screen -> s . y ) ; screen -> s . w = Swap16IfLE ( screen -> s . w ) ; screen -> s . h = Swap16IfLE ( screen -> s . h ) ; screen -> s . flags = Swap32IfLE ( screen -> s . flags ) ; if ( screen -> s . w < 1 || screen -> s . h < 1 ) EDSERROR ( \"Screen<S2SV_blank>0x%.8x<S2SV_blank>requested<S2SV_blank>dimensions<S2SV_blank>%dx%d<S2SV_blank>are<S2SV_blank>invalid\" , ( unsigned int ) screen -> s . id , screen -> s . w , screen -> s . h ) ; if ( screen -> s . x >= msg . sds . w || screen -> s . y >= msg . sds . h || screen -> s . x + screen -> s . w > msg . sds . w || screen -> s . y + screen -> s . h > msg . sds . h ) EDSERROR ( \"Screen<S2SV_blank>0x%.8x<S2SV_blank>requested<S2SV_blank>geometry<S2SV_blank>%dx%d+%d+%d<S2SV_blank>exceeds<S2SV_blank>requested<S2SV_blank>framebuffer<S2SV_blank>dimensions\" , ( unsigned int ) screen -> s . id , screen -> s . w , screen -> s . h , screen -> s . x , screen -> s . y ) ; if ( rfbFindScreenID ( & newScreens , screen -> s . id ) ) { EDSERROR ( \"Screen<S2SV_blank>0x%.8x<S2SV_blank>duplicate<S2SV_blank>ID\" , ( unsigned int ) screen -> s . id ) ; free ( screen ) ; } else rfbAddScreen ( & newScreens , screen ) ; } if ( cl -> viewOnly ) { rfbLog ( \"NOTICE:<S2SV_blank>Ignoring<S2SV_blank>remote<S2SV_blank>desktop<S2SV_blank>resize<S2SV_blank>request<S2SV_blank>from<S2SV_blank>a<S2SV_blank>view-only<S2SV_blank>client.\\\\n\" ) ; result = rfbEDSResultProhibited ; } else if ( result == rfbEDSResultSuccess ) { result = ResizeDesktop ( pScreen , cl , msg . sds . w , msg . sds . h , & newScreens ) ; if ( result == rfbEDSResultSuccess ) return ; } else rfbLog ( errMsg ) ; rfbRemoveScreens ( & newScreens ) ; for ( cl2 = rfbClientHead ; cl2 ; cl2 = cl2 -> next ) { if ( cl2 == cl ) { cl2 -> pendingExtDesktopResize = TRUE ; cl2 -> reason = rfbEDSReasonClient ; cl2 -> result = result ; rfbSendFramebufferUpdate ( cl2 ) ; break ; } } return ; } case rfbGIIClient : { CARD8 endianAndSubType , littleEndian , subType ; READ ( ( char * ) & endianAndSubType , 1 ) ; littleEndian = ( endianAndSubType & rfbGIIBE ) ? 0 : 1 ; subType = endianAndSubType & ~ rfbGIIBE ; switch ( subType ) { case rfbGIIVersion : READ ( ( char * ) & msg . giicv . length , sz_rfbGIIClientVersionMsg - 2 ) ; if ( littleEndian != * ( const char * ) & rfbEndianTest ) { msg . giicv . length = Swap16 ( msg . giicv . length ) ; msg . giicv . version = Swap16 ( msg . giicv . version ) ; } if ( msg . giicv . length != sz_rfbGIIClientVersionMsg - 4 || msg . giicv . version < 1 ) { rfbLog ( \"ERROR:<S2SV_blank>Malformed<S2SV_blank>GII<S2SV_blank>client<S2SV_blank>version<S2SV_blank>message\\\\n\" ) ; rfbCloseClient ( cl ) ; return ; } rfbLog ( \"Client<S2SV_blank>supports<S2SV_blank>GII<S2SV_blank>version<S2SV_blank>%d\\\\n\" , msg . giicv . version ) ; break ; case rfbGIIDeviceCreate : { int i ; rfbDevInfo dev ; rfbGIIDeviceCreatedMsg dcmsg ; memset ( & dev , 0 , sizeof ( dev ) ) ; dcmsg . deviceOrigin = 0 ; READ ( ( char * ) & msg . giidc . length , sz_rfbGIIDeviceCreateMsg - 2 ) ; if ( littleEndian != * ( const char * ) & rfbEndianTest ) { msg . giidc . length = Swap16 ( msg . giidc . length ) ; msg . giidc . vendorID = Swap32 ( msg . giidc . vendorID ) ; msg . giidc . productID = Swap32 ( msg . giidc . productID ) ; msg . giidc . canGenerate = Swap32 ( msg . giidc . canGenerate ) ; msg . giidc . numRegisters = Swap32 ( msg . giidc . numRegisters ) ; msg . giidc . numValuators = Swap32 ( msg . giidc . numValuators ) ; msg . giidc . numButtons = Swap32 ( msg . giidc . numButtons ) ; } rfbLog ( \"GII<S2SV_blank>Device<S2SV_blank>Create:<S2SV_blank>%s\\\\n\" , msg . giidc . deviceName ) ; # ifdef GII_DEBUG rfbLog ( \"<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Vendor<S2SV_blank>ID:<S2SV_blank>%d\\\\n\" , msg . giidc . vendorID ) ; rfbLog ( \"<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Product<S2SV_blank>ID:<S2SV_blank>%d\\\\n\" , msg . giidc . productID ) ; rfbLog ( \"<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Event<S2SV_blank>mask:<S2SV_blank>%.8x\\\\n\" , msg . giidc . canGenerate ) ; rfbLog ( \"<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Registers:<S2SV_blank>%d\\\\n\" , msg . giidc . numRegisters ) ; rfbLog ( \"<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Valuators:<S2SV_blank>%d\\\\n\" , msg . giidc . numValuators ) ; rfbLog ( \"<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Buttons:<S2SV_blank>%d\\\\n\" , msg . giidc . numButtons ) ; # endif if ( msg . giidc . length != sz_rfbGIIDeviceCreateMsg - 4 + msg . giidc . numValuators * sz_rfbGIIValuator ) { rfbLog ( \"ERROR:<S2SV_blank>Malformed<S2SV_blank>GII<S2SV_blank>device<S2SV_blank>create<S2SV_blank>message\\\\n\" ) ; rfbCloseClient ( cl ) ; return ; } if ( msg . giidc . numButtons > MAX_BUTTONS ) { rfbLog ( \"GII<S2SV_blank>device<S2SV_blank>create<S2SV_blank>ERROR:<S2SV_blank>%d<S2SV_blank>buttons<S2SV_blank>exceeds<S2SV_blank>max<S2SV_blank>of<S2SV_blank>%d\\\\n\" , msg . giidc . numButtons , MAX_BUTTONS ) ; SKIP ( msg . giidc . numValuators * sz_rfbGIIValuator ) ; goto sendMessage ; } if ( msg . giidc . numValuators > MAX_VALUATORS ) { rfbLog ( \"GII<S2SV_blank>device<S2SV_blank>create<S2SV_blank>ERROR:<S2SV_blank>%d<S2SV_blank>valuators<S2SV_blank>exceeds<S2SV_blank>max<S2SV_blank>of<S2SV_blank>%d\\\\n\" , msg . giidc . numValuators , MAX_VALUATORS ) ; SKIP ( msg . giidc . numValuators * sz_rfbGIIValuator ) ; goto sendMessage ; } memcpy ( & dev . name , msg . giidc . deviceName , 32 ) ; dev . numButtons = msg . giidc . numButtons ; dev . numValuators = msg . giidc . numValuators ; dev . eventMask = msg . giidc . canGenerate ; dev . mode = ( dev . eventMask & rfbGIIValuatorAbsoluteMask ) ? Absolute : Relative ; dev . productID = msg . giidc . productID ; if ( dev . mode == Relative ) { rfbLog ( \"GII<S2SV_blank>device<S2SV_blank>create<S2SV_blank>ERROR:<S2SV_blank>relative<S2SV_blank>valuators<S2SV_blank>not<S2SV_blank>supported<S2SV_blank>(yet)\\\\n\" ) ; SKIP ( msg . giidc . numValuators * sz_rfbGIIValuator ) ; goto sendMessage ; } for ( i = 0 ; i < dev . numValuators ; i ++ ) { rfbGIIValuator * v = & dev . valuators [ i ] ; READ ( ( char * ) v , sz_rfbGIIValuator ) ; if ( littleEndian != * ( const char * ) & rfbEndianTest ) { v -> index = Swap32 ( v -> index ) ; v -> rangeMin = Swap32 ( ( CARD32 ) v -> rangeMin ) ; v -> rangeCenter = Swap32 ( ( CARD32 ) v -> rangeCenter ) ; v -> rangeMax = Swap32 ( ( CARD32 ) v -> rangeMax ) ; v -> siUnit = Swap32 ( v -> siUnit ) ; v -> siAdd = Swap32 ( ( CARD32 ) v -> siAdd ) ; v -> siMul = Swap32 ( ( CARD32 ) v -> siMul ) ; v -> siDiv = Swap32 ( ( CARD32 ) v -> siDiv ) ; v -> siShift = Swap32 ( ( CARD32 ) v -> siShift ) ; } # ifdef GII_DEBUG rfbLog ( \"<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Valuator:<S2SV_blank>%s<S2SV_blank>(%s)\\\\n\" , v -> longName , v -> shortName ) ; rfbLog ( \"<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Index:<S2SV_blank>%d\\\\n\" , v -> index ) ; rfbLog ( \"<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Range:<S2SV_blank>min<S2SV_blank>=<S2SV_blank>%d,<S2SV_blank>center<S2SV_blank>=<S2SV_blank>%d,<S2SV_blank>max<S2SV_blank>=<S2SV_blank>%d\\\\n\" , v -> rangeMin , v -> rangeCenter , v -> rangeMax ) ; rfbLog ( \"<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>SI<S2SV_blank>unit:<S2SV_blank>%d\\\\n\" , v -> siUnit ) ; rfbLog ( \"<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>SI<S2SV_blank>add:<S2SV_blank>%d\\\\n\" , v -> siAdd ) ; rfbLog ( \"<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>SI<S2SV_blank>multiply:<S2SV_blank>%d\\\\n\" , v -> siMul ) ; rfbLog ( \"<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>SI<S2SV_blank>divide:<S2SV_blank>%d\\\\n\" , v -> siDiv ) ; rfbLog ( \"<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>SI<S2SV_blank>shift:<S2SV_blank>%d\\\\n\" , v -> siShift ) ; # endif } for ( i = 0 ; i < cl -> numDevices ; i ++ ) { if ( ! strcmp ( dev . name , cl -> devices [ i ] . name ) ) { rfbLog ( \"Device<S2SV_blank>\\\\\\'%s\\\\\\'<S2SV_blank>already<S2SV_blank>exists<S2SV_blank>with<S2SV_blank>GII<S2SV_blank>device<S2SV_blank>ID<S2SV_blank>%d\\\\n\" , dev . name , i + 1 ) ; dcmsg . deviceOrigin = Swap32IfLE ( i + 1 ) ; goto sendMessage ; } } if ( rfbVirtualTablet || AddExtInputDevice ( & dev ) ) { memcpy ( & cl -> devices [ cl -> numDevices ] , & dev , sizeof ( dev ) ) ; cl -> numDevices ++ ; dcmsg . deviceOrigin = Swap32IfLE ( cl -> numDevices ) ; } rfbLog ( \"GII<S2SV_blank>device<S2SV_blank>ID<S2SV_blank>=<S2SV_blank>%d\\\\n\" , cl -> numDevices ) ; sendMessage : dcmsg . type = rfbGIIServer ; dcmsg . endianAndSubType = rfbGIIDeviceCreate | rfbGIIBE ; dcmsg . length = Swap16IfLE ( sz_rfbGIIDeviceCreatedMsg - 4 ) ; if ( WriteExact ( cl , ( char * ) & dcmsg , sz_rfbGIIDeviceCreatedMsg ) < 0 ) { rfbLogPerror ( \"rfbProcessClientNormalMessage:<S2SV_blank>write\" ) ; rfbCloseClient ( cl ) ; return ; } break ; } case rfbGIIDeviceDestroy : READ ( ( char * ) & msg . giidd . length , sz_rfbGIIDeviceDestroyMsg - 2 ) ; if ( littleEndian != * ( const char * ) & rfbEndianTest ) { msg . giidd . length = Swap16 ( msg . giidd . length ) ; msg . giidd . deviceOrigin = Swap32 ( msg . giidd . deviceOrigin ) ; } if ( msg . giidd . length != sz_rfbGIIDeviceDestroyMsg - 4 ) { rfbLog ( \"ERROR:<S2SV_blank>Malformed<S2SV_blank>GII<S2SV_blank>device<S2SV_blank>create<S2SV_blank>message\\\\n\" ) ; rfbCloseClient ( cl ) ; return ; } RemoveExtInputDevice ( cl , msg . giidd . deviceOrigin - 1 ) ; break ; case rfbGIIEvent : { CARD16 length ; READ ( ( char * ) & length , sizeof ( CARD16 ) ) ; if ( littleEndian != * ( const char * ) & rfbEndianTest ) length = Swap16 ( length ) ; while ( length > 0 ) { CARD8 eventSize , eventType ; READ ( ( char * ) & eventSize , 1 ) ; READ ( ( char * ) & eventType , 1 ) ; switch ( eventType ) { case rfbGIIButtonPress : case rfbGIIButtonRelease : { rfbGIIButtonEvent b ; rfbDevInfo * dev ; READ ( ( char * ) & b . pad , sz_rfbGIIButtonEvent - 2 ) ; if ( littleEndian != * ( const char * ) & rfbEndianTest ) { b . deviceOrigin = Swap32 ( b . deviceOrigin ) ; b . buttonNumber = Swap32 ( b . buttonNumber ) ; } if ( eventSize != sz_rfbGIIButtonEvent || b . deviceOrigin <= 0 || b . buttonNumber < 1 ) { rfbLog ( \"ERROR:<S2SV_blank>Malformed<S2SV_blank>GII<S2SV_blank>button<S2SV_blank>event\\\\n\" ) ; rfbCloseClient ( cl ) ; return ; } if ( eventSize > length ) { rfbLog ( \"ERROR:<S2SV_blank>Malformed<S2SV_blank>GII<S2SV_blank>event<S2SV_blank>message\\\\n\" ) ; rfbCloseClient ( cl ) ; return ; } length -= eventSize ; if ( b . deviceOrigin < 1 || b . deviceOrigin > cl -> numDevices ) { rfbLog ( \"ERROR:<S2SV_blank>GII<S2SV_blank>button<S2SV_blank>event<S2SV_blank>from<S2SV_blank>non-existent<S2SV_blank>device<S2SV_blank>%d\\\\n\" , b . deviceOrigin ) ; rfbCloseClient ( cl ) ; return ; } dev = & cl -> devices [ b . deviceOrigin - 1 ] ; if ( ( eventType == rfbGIIButtonPress && ( dev -> eventMask & rfbGIIButtonPressMask ) == 0 ) || ( eventType == rfbGIIButtonRelease && ( dev -> eventMask & rfbGIIButtonReleaseMask ) == 0 ) ) { rfbLog ( \"ERROR:<S2SV_blank>Device<S2SV_blank>%d<S2SV_blank>can\\'t<S2SV_blank>generate<S2SV_blank>GII<S2SV_blank>button<S2SV_blank>events\\\\n\" , b . deviceOrigin ) ; rfbCloseClient ( cl ) ; return ; } if ( b . buttonNumber > dev -> numButtons ) { rfbLog ( \"ERROR:<S2SV_blank>GII<S2SV_blank>button<S2SV_blank>%d<S2SV_blank>event<S2SV_blank>for<S2SV_blank>device<S2SV_blank>%d<S2SV_blank>exceeds<S2SV_blank>button<S2SV_blank>count<S2SV_blank>(%d)\\\\n\" , b . buttonNumber , b . deviceOrigin , dev -> numButtons ) ; rfbCloseClient ( cl ) ; return ; } # ifdef GII_DEBUG rfbLog ( \"Device<S2SV_blank>%d<S2SV_blank>button<S2SV_blank>%d<S2SV_blank>%s\\\\n\" , b . deviceOrigin , b . buttonNumber , eventType == rfbGIIButtonPress ? \"PRESS\" : \"release\" ) ; fflush ( stderr ) ; # endif ExtInputAddEvent ( dev , eventType == rfbGIIButtonPress ? ButtonPress : ButtonRelease , b . buttonNumber ) ; break ; } case rfbGIIValuatorRelative : case rfbGIIValuatorAbsolute : { rfbGIIValuatorEvent v ; int i ; rfbDevInfo * dev ; READ ( ( char * ) & v . pad , sz_rfbGIIValuatorEvent - 2 ) ; if ( littleEndian != * ( const char * ) & rfbEndianTest ) { v . deviceOrigin = Swap32 ( v . deviceOrigin ) ; v . first = Swap32 ( v . first ) ; v . count = Swap32 ( v . count ) ; } if ( eventSize != sz_rfbGIIValuatorEvent + sizeof ( int ) * v . count ) { rfbLog ( \"ERROR:<S2SV_blank>Malformed<S2SV_blank>GII<S2SV_blank>valuator<S2SV_blank>event\\\\n\" ) ; rfbCloseClient ( cl ) ; return ; } if ( eventSize > length ) { rfbLog ( \"ERROR:<S2SV_blank>Malformed<S2SV_blank>GII<S2SV_blank>event<S2SV_blank>message\\\\n\" ) ; rfbCloseClient ( cl ) ; return ; } length -= eventSize ; if ( v . deviceOrigin < 1 || v . deviceOrigin > cl -> numDevices ) { rfbLog ( \"ERROR:<S2SV_blank>GII<S2SV_blank>valuator<S2SV_blank>event<S2SV_blank>from<S2SV_blank>non-existent<S2SV_blank>device<S2SV_blank>%d\\\\n\" , v . deviceOrigin ) ; rfbCloseClient ( cl ) ; return ; } dev = & cl -> devices [ v . deviceOrigin - 1 ] ; if ( ( eventType == rfbGIIValuatorRelative && ( dev -> eventMask & rfbGIIValuatorRelativeMask ) == 0 ) || ( eventType == rfbGIIValuatorAbsolute && ( dev -> eventMask & rfbGIIValuatorAbsoluteMask ) == 0 ) ) { rfbLog ( \"ERROR:<S2SV_blank>Device<S2SV_blank>%d<S2SV_blank>cannot<S2SV_blank>generate<S2SV_blank>GII<S2SV_blank>valuator<S2SV_blank>events\\\\n\" , v . deviceOrigin ) ; rfbCloseClient ( cl ) ; return ; } if ( v . first + v . count > dev -> numValuators ) { rfbLog ( \"ERROR:<S2SV_blank>GII<S2SV_blank>valuator<S2SV_blank>event<S2SV_blank>for<S2SV_blank>device<S2SV_blank>%d<S2SV_blank>exceeds<S2SV_blank>valuator<S2SV_blank>count<S2SV_blank>(%d)\\\\n\" , v . deviceOrigin , dev -> numValuators ) ; rfbCloseClient ( cl ) ; return ; } # ifdef GII_DEBUG rfbLog ( \"Device<S2SV_blank>%d<S2SV_blank>Valuator<S2SV_blank>%s<S2SV_blank>first=%d<S2SV_blank>count=%d:\\\\n\" , v . deviceOrigin , eventType == rfbGIIValuatorRelative ? \"rel\" : \"ABS\" , v . first , v . count ) ; # endif for ( i = v . first ; i < v . first + v . count ; i ++ ) { READ ( ( char * ) & dev -> values [ i ] , sizeof ( int ) ) ; if ( littleEndian != * ( const char * ) & rfbEndianTest ) dev -> values [ i ] = Swap32 ( ( CARD32 ) dev -> values [ i ] ) ; # ifdef GII_DEBUG fprintf ( stderr , \"v[%d]=%d<S2SV_blank>\" , i , dev -> values [ i ] ) ; # endif } # ifdef GII_DEBUG fprintf ( stderr , \"\\\\n\" ) ; # endif if ( v . count > 0 ) { dev -> valFirst = v . first ; dev -> valCount = v . count ; dev -> mode = eventType == rfbGIIValuatorAbsolute ? Absolute : Relative ; ExtInputAddEvent ( dev , MotionNotify , 0 ) ; } break ; } default : rfbLog ( \"ERROR:<S2SV_blank>This<S2SV_blank>server<S2SV_blank>cannot<S2SV_blank>handle<S2SV_blank>GII<S2SV_blank>event<S2SV_blank>type<S2SV_blank>%d\\\\n\" , eventType ) ; rfbCloseClient ( cl ) ; return ; } } if ( length != 0 ) { rfbLog ( \"ERROR:<S2SV_blank>Malformed<S2SV_blank>GII<S2SV_blank>event<S2SV_blank>message\\\\n\" ) ; rfbCloseClient ( cl ) ; return ; } break ; } } return ; } default : rfbLog ( \"rfbProcessClientNormalMessage:<S2SV_blank>unknown<S2SV_blank>message<S2SV_blank>type<S2SV_blank>%d\\\\n\" , msg . type ) ; rfbLog ( \"<S2SV_blank>...<S2SV_blank>closing<S2SV_blank>connection\\\\n\" ) ; rfbCloseClient ( cl ) ; return ; } }\n","target":"<S2SV_ModStart> flags ) ; <S2SV_ModEnd> if ( msg <S2SV_ModStart> data ) ) { <S2SV_ModStart> length ) ; SKIP ( msg . f . length ) } else { READ ( data , msg . f . length ) <S2SV_ModEnd> HandleFence ( cl <S2SV_ModStart> data ) ; }\n","project_and_commit_id":"TurboVNC@turbovnc/cea98166008301e614e0d36776bf9435a536136e","cve_id":"CVE-2019-15683","original_address":"https://github.com/TurboVNC/turbovnc/commit/cea98166008301e614e0d36776bf9435a536136e","time":"2019-10-29T19:15Z"},
	{"Unnamed: 0":4495,"cwe_id":"CWE-200","source":"CWE-200 int get_devices_from_authfile ( const char * authfile , const char * username , unsigned max_devs , int verbose , FILE * debug_file , device_t * devices , unsigned * n_devs ) { char * buf = NULL ; char * s_user , * s_token ; int retval = 0 ; int fd = - 1 ; struct stat st ; struct passwd * pw = NULL , pw_s ; char buffer [ BUFSIZE ] ; int gpu_ret ; FILE * opwfile = NULL ; unsigned i , j ; * n_devs = 0 ; <S2SV_StartBug> fd = open ( authfile , O_RDONLY , 0 ) ; <S2SV_EndBug> if ( fd < 0 ) { if ( verbose ) D ( debug_file , \"Cannot<S2SV_blank>open<S2SV_blank>file:<S2SV_blank>%s<S2SV_blank>(%s)\" , authfile , strerror ( errno ) ) ; goto err ; } if ( fstat ( fd , & st ) < 0 ) { if ( verbose ) D ( debug_file , \"Cannot<S2SV_blank>stat<S2SV_blank>file:<S2SV_blank>%s<S2SV_blank>(%s)\" , authfile , strerror ( errno ) ) ; goto err ; } if ( ! S_ISREG ( st . st_mode ) ) { if ( verbose ) D ( debug_file , \"%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>regular<S2SV_blank>file\" , authfile ) ; goto err ; } if ( st . st_size == 0 ) { if ( verbose ) D ( debug_file , \"File<S2SV_blank>%s<S2SV_blank>is<S2SV_blank>empty\" , authfile ) ; goto err ; } gpu_ret = getpwuid_r ( st . st_uid , & pw_s , buffer , sizeof ( buffer ) , & pw ) ; if ( gpu_ret != 0 || pw == NULL ) { D ( debug_file , \"Unable<S2SV_blank>to<S2SV_blank>retrieve<S2SV_blank>credentials<S2SV_blank>for<S2SV_blank>uid<S2SV_blank>%u,<S2SV_blank>(%s)\" , st . st_uid , strerror ( errno ) ) ; goto err ; } if ( strcmp ( pw -> pw_name , username ) != 0 && strcmp ( pw -> pw_name , \"root\" ) != 0 ) { if ( strcmp ( username , \"root\" ) != 0 ) { D ( debug_file , \"The<S2SV_blank>owner<S2SV_blank>of<S2SV_blank>the<S2SV_blank>authentication<S2SV_blank>file<S2SV_blank>is<S2SV_blank>neither<S2SV_blank>%s<S2SV_blank>nor<S2SV_blank>root\" , username ) ; } else { D ( debug_file , \"The<S2SV_blank>owner<S2SV_blank>of<S2SV_blank>the<S2SV_blank>authentication<S2SV_blank>file<S2SV_blank>is<S2SV_blank>not<S2SV_blank>root\" ) ; } goto err ; } opwfile = fdopen ( fd , \"r\" ) ; if ( opwfile == NULL ) { if ( verbose ) D ( debug_file , \"fdopen:<S2SV_blank>%s\" , strerror ( errno ) ) ; <S2SV_StartBug> goto err ; <S2SV_EndBug> } buf = malloc ( sizeof ( char ) * ( DEVSIZE * max_devs ) ) ; if ( ! buf ) { if ( verbose ) D ( debug_file , \"Unable<S2SV_blank>to<S2SV_blank>allocate<S2SV_blank>memory\" ) ; goto err ; } retval = - 2 ; while ( fgets ( buf , ( int ) ( DEVSIZE * ( max_devs - 1 ) ) , opwfile ) ) { char * saveptr = NULL ; if ( buf [ strlen ( buf ) - 1 ] == '\\\\n' ) buf [ strlen ( buf ) - 1 ] = '\\\\0' ; if ( verbose ) D ( debug_file , \"Authorization<S2SV_blank>line:<S2SV_blank>%s\" , buf ) ; s_user = strtok_r ( buf , \":\" , & saveptr ) ; if ( s_user && strcmp ( username , s_user ) == 0 ) { if ( verbose ) D ( debug_file , \"Matched<S2SV_blank>user:<S2SV_blank>%s\" , s_user ) ; retval = - 1 ; for ( i = 0 ; i < * n_devs ; i ++ ) { free ( devices [ i ] . keyHandle ) ; free ( devices [ i ] . publicKey ) ; devices [ i ] . keyHandle = NULL ; devices [ i ] . publicKey = NULL ; } * n_devs = 0 ; i = 0 ; while ( ( s_token = strtok_r ( NULL , \",\" , & saveptr ) ) ) { devices [ i ] . keyHandle = NULL ; devices [ i ] . publicKey = NULL ; if ( ( * n_devs ) ++ > MAX_DEVS - 1 ) { * n_devs = MAX_DEVS ; if ( verbose ) D ( debug_file , \"Found<S2SV_blank>more<S2SV_blank>than<S2SV_blank>%d<S2SV_blank>devices,<S2SV_blank>ignoring<S2SV_blank>the<S2SV_blank>remaining<S2SV_blank>ones\" , MAX_DEVS ) ; break ; } if ( verbose ) D ( debug_file , \"KeyHandle<S2SV_blank>for<S2SV_blank>device<S2SV_blank>number<S2SV_blank>%d:<S2SV_blank>%s\" , i + 1 , s_token ) ; devices [ i ] . keyHandle = strdup ( s_token ) ; if ( ! devices [ i ] . keyHandle ) { if ( verbose ) D ( debug_file , \"Unable<S2SV_blank>to<S2SV_blank>allocate<S2SV_blank>memory<S2SV_blank>for<S2SV_blank>keyHandle<S2SV_blank>number<S2SV_blank>%d\" , i ) ; goto err ; } s_token = strtok_r ( NULL , \":\" , & saveptr ) ; if ( ! s_token ) { if ( verbose ) D ( debug_file , \"Unable<S2SV_blank>to<S2SV_blank>retrieve<S2SV_blank>publicKey<S2SV_blank>number<S2SV_blank>%d\" , i + 1 ) ; goto err ; } if ( verbose ) D ( debug_file , \"publicKey<S2SV_blank>for<S2SV_blank>device<S2SV_blank>number<S2SV_blank>%d:<S2SV_blank>%s\" , i + 1 , s_token ) ; if ( strlen ( s_token ) % 2 != 0 ) { if ( verbose ) D ( debug_file , \"Length<S2SV_blank>of<S2SV_blank>key<S2SV_blank>number<S2SV_blank>%d<S2SV_blank>not<S2SV_blank>even\" , i + 1 ) ; goto err ; } devices [ i ] . key_len = strlen ( s_token ) / 2 ; if ( verbose ) D ( debug_file , \"Length<S2SV_blank>of<S2SV_blank>key<S2SV_blank>number<S2SV_blank>%d<S2SV_blank>is<S2SV_blank>%zu\" , i + 1 , devices [ i ] . key_len ) ; devices [ i ] . publicKey = malloc ( ( sizeof ( unsigned char ) * devices [ i ] . key_len ) ) ; if ( ! devices [ i ] . publicKey ) { if ( verbose ) D ( debug_file , \"Unable<S2SV_blank>to<S2SV_blank>allocate<S2SV_blank>memory<S2SV_blank>for<S2SV_blank>publicKey<S2SV_blank>number<S2SV_blank>%d\" , i ) ; goto err ; } for ( j = 0 ; j < devices [ i ] . key_len ; j ++ ) { unsigned int x ; if ( sscanf ( & s_token [ 2 * j ] , \"%2x\" , & x ) != 1 ) { if ( verbose ) D ( debug_file , \"Invalid<S2SV_blank>hex<S2SV_blank>number<S2SV_blank>in<S2SV_blank>key\" ) ; goto err ; } devices [ i ] . publicKey [ j ] = ( unsigned char ) x ; } i ++ ; } } } if ( verbose ) D ( debug_file , \"Found<S2SV_blank>%d<S2SV_blank>device(s)<S2SV_blank>for<S2SV_blank>user<S2SV_blank>%s\" , * n_devs , username ) ; retval = 1 ; goto out ; err : for ( i = 0 ; i < * n_devs ; i ++ ) { free ( devices [ i ] . keyHandle ) ; free ( devices [ i ] . publicKey ) ; devices [ i ] . keyHandle = NULL ; devices [ i ] . publicKey = NULL ; } * n_devs = 0 ; out : if ( buf ) { free ( buf ) ; buf = NULL ; } if ( opwfile ) fclose ( opwfile ) ; <S2SV_StartBug> else if ( fd >= 0 ) <S2SV_EndBug> close ( fd ) ; return retval ; }\n","target":"<S2SV_ModStart> authfile , O_RDONLY | O_CLOEXEC | O_NOCTTY <S2SV_ModEnd> ) ; if <S2SV_ModStart> ; goto err ; } else { fd = - 1 <S2SV_ModStart> opwfile ) ; <S2SV_ModEnd> if ( fd <S2SV_ModStart> if ( fd != - 1 <S2SV_ModEnd> ) close (\n","project_and_commit_id":"Yubico@pam-u2f/18b1914e32b74ff52000f10e97067e841e5fff62","cve_id":"CVE-2019-12210","original_address":"https://github.com/Yubico/pam-u2f/commit/18b1914e32b74ff52000f10e97067e841e5fff62","time":"2019-06-04T21:29Z"},
	{"Unnamed: 0":5995,"cwe_id":"CWE-119","source":"CWE-119 <S2SV_StartBug> static void <S2SV_EndBug> fpAcc ( TIFF * tif , uint8 * cp0 , tmsize_t cc ) { tmsize_t stride = PredictorState ( tif ) -> stride ; uint32 bps = tif -> tif_dir . td_bitspersample / 8 ; tmsize_t wc = cc / bps ; tmsize_t count = cc ; uint8 * cp = ( uint8 * ) cp0 ; uint8 * tmp = ( uint8 * ) _TIFFmalloc ( cc ) ; <S2SV_StartBug> assert ( ( cc % ( bps * stride ) ) == 0 ) ; <S2SV_EndBug> if ( ! tmp ) <S2SV_StartBug> return ; <S2SV_EndBug> while ( count > stride ) { REPEAT4 ( stride , cp [ stride ] = ( unsigned char ) ( ( cp [ stride ] + cp [ 0 ] ) & 0xff ) ; cp ++ ) count -= stride ; } _TIFFmemcpy ( tmp , cp0 , cc ) ; cp = ( uint8 * ) cp0 ; for ( count = 0 ; count < wc ; count ++ ) { uint32 byte ; for ( byte = 0 ; byte < bps ; byte ++ ) { # if WORDS_BIGENDIAN cp [ bps * count + byte ] = tmp [ byte * wc + count ] ; # else cp [ bps * count + byte ] = tmp [ ( bps - byte - 1 ) * wc + count ] ; # endif } } _TIFFfree ( tmp ) ; <S2SV_StartBug> } <S2SV_EndBug>\n","target":"<S2SV_ModStart> <S2SV_null> <S2SV_null> static int <S2SV_ModEnd> fpAcc ( TIFF <S2SV_ModStart> cc ) ; if <S2SV_ModEnd> ( cc % <S2SV_ModStart> * stride ) != 0 ) { TIFFErrorExt ( tif -> tif_clientdata , \"fpAcc\" , \"%s\" , \"cc%(bps*stride))!=0\" ) ; return 0 ; } <S2SV_ModEnd> if ( ! <S2SV_ModStart> tmp ) return 0 <S2SV_ModStart> tmp ) ; return 1 ;\n","project_and_commit_id":"vadz@libtiff/3ca657a8793dd011bf869695d72ad31c779c3cc1","cve_id":"CVE-2016-9535","original_address":"https://github.com/vadz/libtiff/commit/3ca657a8793dd011bf869695d72ad31c779c3cc1","time":"2016-11-22T19:59Z"},
	{"Unnamed: 0":6288,"cwe_id":"CWE-000","source":"CWE-000 void ping_unhash ( struct sock * sk ) { struct inet_sock * isk = inet_sk ( sk ) ; pr_debug ( \"ping_unhash(isk=%p,isk->num=%u)\\\\n\" , isk , isk -> inet_num ) ; if ( sk_hashed ( sk ) ) { write_lock_bh ( & ping_table . lock ) ; hlist_nulls_del ( & sk -> sk_nulls_node ) ; <S2SV_StartBug> sock_put ( sk ) ; <S2SV_EndBug> isk -> inet_num = 0 ; isk -> inet_sport = 0 ; sock_prot_inuse_add ( sock_net ( sk ) , sk -> sk_prot , - 1 ) ; write_unlock_bh ( & ping_table . lock ) ; } }\n","target":"<S2SV_ModStart> sk_nulls_node ) ; sk_nulls_node_init ( & sk -> sk_nulls_node ) ;\n","project_and_commit_id":"torvalds@linux/a134f083e79fb4c3d0a925691e732c56911b4326","cve_id":"CVE-2015-3636","original_address":"https://github.com/torvalds/linux/commit/a134f083e79fb4c3d0a925691e732c56911b4326","time":"2015-08-06T01:59Z"},
	{"Unnamed: 0":4978,"cwe_id":"CWE-264","source":"CWE-264 void hostap_setup_dev ( struct net_device * dev , local_info_t * local , int type ) { struct hostap_interface * iface ; iface = netdev_priv ( dev ) ; <S2SV_StartBug> ether_setup ( dev ) ; <S2SV_EndBug> if ( iface ) { iface -> wireless_data . spy_data = & iface -> spy_data ; dev -> wireless_data = & iface -> wireless_data ; } dev -> wireless_handlers = & hostap_iw_handler_def ; dev -> watchdog_timeo = TX_TIMEOUT ; switch ( type ) { case HOSTAP_INTERFACE_AP : dev -> tx_queue_len = 0 ; dev -> netdev_ops = & hostap_mgmt_netdev_ops ; dev -> type = ARPHRD_IEEE80211 ; dev -> header_ops = & hostap_80211_ops ; break ; case HOSTAP_INTERFACE_MASTER : dev -> netdev_ops = & hostap_master_ops ; break ; default : dev -> tx_queue_len = 0 ; dev -> netdev_ops = & hostap_netdev_ops ; } dev -> mtu = local -> mtu ; SET_ETHTOOL_OPS ( dev , & prism2_ethtool_ops ) ; }\n","target":"<S2SV_ModStart> ( dev ) ; dev -> priv_flags &= ~ IFF_TX_SKB_SHARING\n","project_and_commit_id":"torvalds@linux/550fd08c2cebad61c548def135f67aba284c6162","cve_id":"CVE-2011-4112","original_address":"https://github.com/torvalds/linux/commit/550fd08c2cebad61c548def135f67aba284c6162","time":"2012-05-17T11:00Z"},
	{"Unnamed: 0":5690,"cwe_id":"CWE-264","source":"CWE-264 SYSCALL_DEFINE5 ( osf_getsysinfo , unsigned long , op , void __user * , buffer , unsigned long , nbytes , int __user * , start , void __user * , arg ) { unsigned long w ; struct percpu_struct * cpu ; switch ( op ) { case GSI_IEEE_FP_CONTROL : w = current_thread_info ( ) -> ieee_state & IEEE_SW_MASK ; w = swcr_update_status ( w , rdfpcr ( ) ) ; if ( put_user ( w , ( unsigned long __user * ) buffer ) ) return - EFAULT ; return 0 ; case GSI_IEEE_STATE_AT_SIGNAL : break ; case GSI_UACPROC : if ( nbytes < sizeof ( unsigned int ) ) return - EINVAL ; w = ( current_thread_info ( ) -> flags >> UAC_SHIFT ) & UAC_BITMASK ; if ( put_user ( w , ( unsigned int __user * ) buffer ) ) return - EFAULT ; return 1 ; case GSI_PROC_TYPE : if ( nbytes < sizeof ( unsigned long ) ) return - EINVAL ; cpu = ( struct percpu_struct * ) ( ( char * ) hwrpb + hwrpb -> processor_offset ) ; w = cpu -> type ; if ( put_user ( w , ( unsigned long __user * ) buffer ) ) return - EFAULT ; return 1 ; case GSI_GET_HWRPB : <S2SV_StartBug> if ( nbytes < sizeof ( * hwrpb ) ) <S2SV_EndBug> return - EINVAL ; if ( copy_to_user ( buffer , hwrpb , nbytes ) != 0 ) return - EFAULT ; return 1 ; default : break ; } return - EOPNOTSUPP ; }\n","target":"<S2SV_ModStart> if ( nbytes > <S2SV_ModEnd> sizeof ( *\n","project_and_commit_id":"torvalds@linux/21c5977a836e399fc710ff2c5367845ed5c2527f","cve_id":"CVE-2011-2211","original_address":"https://github.com/torvalds/linux/commit/21c5977a836e399fc710ff2c5367845ed5c2527f","time":"2012-06-13T10:24Z"},
	{"Unnamed: 0":620,"cwe_id":"CWE-362","source":"CWE-362 static int snd_timer_user_release ( struct inode * inode , struct file * file ) { struct snd_timer_user * tu ; if ( file -> private_data ) { tu = file -> private_data ; file -> private_data = NULL ; <S2SV_StartBug> if ( tu -> timeri ) <S2SV_EndBug> <S2SV_StartBug> snd_timer_close ( tu -> timeri ) ; <S2SV_EndBug> kfree ( tu -> queue ) ; kfree ( tu -> tqueue ) ; kfree ( tu ) ; } return 0 ; }\n","target":"<S2SV_ModStart> = NULL ; mutex_lock ( & tu -> ioctl_lock ) ; <S2SV_ModStart> tu -> timeri ) ; mutex_unlock ( & tu -> ioctl_lock\n","project_and_commit_id":"torvalds@linux/af368027a49a751d6ff4ee9e3f9961f35bb4fede","cve_id":"CVE-2016-2546","original_address":"https://github.com/torvalds/linux/commit/af368027a49a751d6ff4ee9e3f9961f35bb4fede","time":"2016-04-27T17:59Z"},
	{"Unnamed: 0":2940,"cwe_id":"CWE-416","source":"CWE-416 static ssize_t bsg_write ( struct file * file , const char __user * buf , size_t count , loff_t * ppos ) { struct bsg_device * bd = file -> private_data ; ssize_t bytes_written ; int ret ; <S2SV_StartBug> dprintk ( \"%s:<S2SV_blank>write<S2SV_blank>%Zd<S2SV_blank>bytes\\\\n\" , bd -> name , count ) ; <S2SV_EndBug> bsg_set_block ( bd , file ) ; bytes_written = 0 ; ret = __bsg_write ( bd , buf , count , & bytes_written , file -> f_mode & FMODE_WRITE ) ; * ppos = bytes_written ; if ( ! bytes_written || err_block_err ( ret ) ) bytes_written = ret ; dprintk ( \"%s:<S2SV_blank>returning<S2SV_blank>%Zd\\\\n\" , bd -> name , bytes_written ) ; return bytes_written ; }\n","target":"<S2SV_ModStart> , count ) ; if ( unlikely ( segment_eq ( get_fs ( ) , KERNEL_DS ) ) ) return - EINVAL\n","project_and_commit_id":"torvalds@linux/128394eff343fc6d2f32172f03e24829539c5835","cve_id":"CVE-2016-10088","original_address":"https://github.com/torvalds/linux/commit/128394eff343fc6d2f32172f03e24829539c5835","time":"2016-12-30T18:59Z"},
	{"Unnamed: 0":6408,"cwe_id":"CWE-264","source":"CWE-264 static NPError g_NPN_GetValue ( NPP instance , NPNVariable variable , void * value ) { D ( bug ( \"NPN_GetValue<S2SV_blank>instance=%p,<S2SV_blank>variable=%d<S2SV_blank>[%s]\\\\n\" , instance , variable , string_of_NPNVariable ( variable ) ) ) ; if ( ! thread_check ( ) ) { npw_printf ( \"WARNING:<S2SV_blank>NPN_GetValue<S2SV_blank>not<S2SV_blank>called<S2SV_blank>from<S2SV_blank>the<S2SV_blank>main<S2SV_blank>thread\\\\n\" ) ; return NPERR_INVALID_INSTANCE_ERROR ; } PluginInstance * plugin = NULL ; if ( instance ) plugin = PLUGIN_INSTANCE ( instance ) ; switch ( variable ) { case NPNVxDisplay : * ( void * * ) value = x_display ; break ; case NPNVxtAppContext : * ( void * * ) value = XtDisplayToApplicationContext ( x_display ) ; break ; case NPNVToolkit : * ( NPNToolkitType * ) value = NPW_TOOLKIT ; break ; # if USE_XPCOM case NPNVserviceManager : { nsIServiceManager * sm ; int ret = NS_GetServiceManager ( & sm ) ; if ( NS_FAILED ( ret ) ) { npw_printf ( \"WARNING:<S2SV_blank>NS_GetServiceManager<S2SV_blank>failed\\\\n\" ) ; return NPERR_GENERIC_ERROR ; } * ( nsIServiceManager * * ) value = sm ; break ; } case NPNVDOMWindow : case NPNVDOMElement : npw_printf ( \"WARNING:<S2SV_blank>%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>supported<S2SV_blank>by<S2SV_blank>NPN_GetValue()\\\\n\" , string_of_NPNVariable ( variable ) ) ; return NPERR_INVALID_PARAM ; # endif case NPNVnetscapeWindow : if ( plugin == NULL ) { npw_printf ( \"ERROR:<S2SV_blank>NPNVnetscapeWindow<S2SV_blank>requires<S2SV_blank>a<S2SV_blank>non<S2SV_blank>NULL<S2SV_blank>instance\\\\n\" ) ; return NPERR_INVALID_INSTANCE_ERROR ; } if ( plugin -> browser_toplevel == NULL ) { GdkNativeWindow netscape_xid = None ; NPError error = g_NPN_GetValue_real ( instance , variable , & netscape_xid ) ; if ( error != NPERR_NO_ERROR ) return error ; if ( netscape_xid == None ) return NPERR_GENERIC_ERROR ; plugin -> browser_toplevel = gdk_window_foreign_new ( netscape_xid ) ; if ( plugin -> browser_toplevel == NULL ) return NPERR_GENERIC_ERROR ; } * ( ( GdkNativeWindow * ) value ) = GDK_WINDOW_XWINDOW ( plugin -> browser_toplevel ) ; break ; # if ALLOW_WINDOWLESS_PLUGINS case NPNVSupportsWindowless : # endif case NPNVSupportsXEmbedBool : case NPNVWindowNPObject : case NPNVPluginElementNPObject : <S2SV_StartBug> return g_NPN_GetValue_real ( instance , variable , value ) ; <S2SV_EndBug> default : switch ( variable & 0xff ) { case 13 : if ( NPW_TOOLKIT == NPNVGtk2 ) { * ( NPNToolkitType * ) value = NPW_TOOLKIT ; return NPERR_NO_ERROR ; } break ; } D ( bug ( \"WARNING:<S2SV_blank>unhandled<S2SV_blank>variable<S2SV_blank>%d<S2SV_blank>(%s)<S2SV_blank>in<S2SV_blank>NPN_GetValue()\\\\n\" , variable , string_of_NPNVariable ( variable ) ) ) ; return NPERR_INVALID_PARAM ; } return NPERR_NO_ERROR ; }\n","target":"<S2SV_ModStart> case NPNVPluginElementNPObject : case NPNVprivateModeBool : case NPNVsupportsAdvancedKeyHandling :\n","project_and_commit_id":"davidben@nspluginwrapper/7e4ab8e1189846041f955e6c83f72bc1624e7a98","cve_id":"CVE-2011-2486","original_address":"https://github.com/davidben/nspluginwrapper/commit/7e4ab8e1189846041f955e6c83f72bc1624e7a98","time":"2012-11-19T12:10Z"},
	{"Unnamed: 0":3805,"cwe_id":"CWE-125","source":"CWE-125 opj_pi_iterator_t * opj_pi_create_decode ( opj_image_t * p_image , opj_cp_t * p_cp , OPJ_UINT32 p_tile_no ) { OPJ_UINT32 pino ; OPJ_UINT32 compno , resno ; OPJ_UINT32 * l_tmp_data ; OPJ_UINT32 * * l_tmp_ptr ; OPJ_UINT32 l_max_res ; OPJ_UINT32 l_max_prec ; OPJ_INT32 l_tx0 , l_tx1 , l_ty0 , l_ty1 ; OPJ_UINT32 l_dx_min , l_dy_min ; OPJ_UINT32 l_bound ; OPJ_UINT32 l_step_p , l_step_c , l_step_r , l_step_l ; OPJ_UINT32 l_data_stride ; opj_pi_iterator_t * l_pi = 00 ; opj_tcp_t * l_tcp = 00 ; const opj_tccp_t * l_tccp = 00 ; opj_pi_comp_t * l_current_comp = 00 ; opj_image_comp_t * l_img_comp = 00 ; opj_pi_iterator_t * l_current_pi = 00 ; OPJ_UINT32 * l_encoding_value_ptr = 00 ; assert ( p_cp != 00 ) ; assert ( p_image != 00 ) ; assert ( p_tile_no < p_cp -> tw * p_cp -> th ) ; l_tcp = & p_cp -> tcps [ p_tile_no ] ; l_bound = l_tcp -> numpocs + 1 ; l_data_stride = 4 * OPJ_J2K_MAXRLVLS ; l_tmp_data = ( OPJ_UINT32 * ) opj_malloc ( l_data_stride * p_image -> numcomps * sizeof ( OPJ_UINT32 ) ) ; if ( ! l_tmp_data ) { return 00 ; } l_tmp_ptr = ( OPJ_UINT32 * * ) opj_malloc ( p_image -> numcomps * sizeof ( OPJ_UINT32 * ) ) ; if ( ! l_tmp_ptr ) { opj_free ( l_tmp_data ) ; return 00 ; } l_pi = opj_pi_create ( p_image , p_cp , p_tile_no ) ; if ( ! l_pi ) { opj_free ( l_tmp_data ) ; opj_free ( l_tmp_ptr ) ; return 00 ; } l_encoding_value_ptr = l_tmp_data ; for ( compno = 0 ; compno < p_image -> numcomps ; ++ compno ) { l_tmp_ptr [ compno ] = l_encoding_value_ptr ; l_encoding_value_ptr += l_data_stride ; } opj_get_all_encoding_parameters ( p_image , p_cp , p_tile_no , & l_tx0 , & l_tx1 , & l_ty0 , & l_ty1 , & l_dx_min , & l_dy_min , & l_max_prec , & l_max_res , l_tmp_ptr ) ; l_step_p = 1 ; l_step_c = l_max_prec * l_step_p ; l_step_r = p_image -> numcomps * l_step_c ; l_step_l = l_max_res * l_step_r ; l_current_pi = l_pi ; l_current_pi -> include = 00 ; if ( l_step_l <= ( SIZE_MAX / ( l_tcp -> numlayers + 1U ) ) ) { <S2SV_StartBug> l_current_pi -> include = ( OPJ_INT16 * ) opj_calloc ( ( l_tcp -> numlayers + 1 ) * l_step_l , sizeof ( OPJ_INT16 ) ) ; <S2SV_EndBug> } if ( ! l_current_pi -> include ) { opj_free ( l_tmp_data ) ; opj_free ( l_tmp_ptr ) ; opj_pi_destroy ( l_pi , l_bound ) ; return 00 ; } l_current_comp = l_current_pi -> comps ; l_img_comp = p_image -> comps ; l_tccp = l_tcp -> tccps ; l_current_pi -> tx0 = l_tx0 ; l_current_pi -> ty0 = l_ty0 ; l_current_pi -> tx1 = l_tx1 ; l_current_pi -> ty1 = l_ty1 ; l_current_pi -> step_p = l_step_p ; l_current_pi -> step_c = l_step_c ; l_current_pi -> step_r = l_step_r ; l_current_pi -> step_l = l_step_l ; for ( compno = 0 ; compno < l_current_pi -> numcomps ; ++ compno ) { opj_pi_resolution_t * l_res = l_current_comp -> resolutions ; l_encoding_value_ptr = l_tmp_ptr [ compno ] ; l_current_comp -> dx = l_img_comp -> dx ; l_current_comp -> dy = l_img_comp -> dy ; for ( resno = 0 ; resno < l_current_comp -> numresolutions ; resno ++ ) { l_res -> pdx = * ( l_encoding_value_ptr ++ ) ; l_res -> pdy = * ( l_encoding_value_ptr ++ ) ; l_res -> pw = * ( l_encoding_value_ptr ++ ) ; l_res -> ph = * ( l_encoding_value_ptr ++ ) ; ++ l_res ; } ++ l_current_comp ; ++ l_img_comp ; ++ l_tccp ; } ++ l_current_pi ; for ( pino = 1 ; pino < l_bound ; ++ pino ) { l_current_comp = l_current_pi -> comps ; l_img_comp = p_image -> comps ; l_tccp = l_tcp -> tccps ; l_current_pi -> tx0 = l_tx0 ; l_current_pi -> ty0 = l_ty0 ; l_current_pi -> tx1 = l_tx1 ; l_current_pi -> ty1 = l_ty1 ; l_current_pi -> step_p = l_step_p ; l_current_pi -> step_c = l_step_c ; l_current_pi -> step_r = l_step_r ; l_current_pi -> step_l = l_step_l ; for ( compno = 0 ; compno < l_current_pi -> numcomps ; ++ compno ) { opj_pi_resolution_t * l_res = l_current_comp -> resolutions ; l_encoding_value_ptr = l_tmp_ptr [ compno ] ; l_current_comp -> dx = l_img_comp -> dx ; l_current_comp -> dy = l_img_comp -> dy ; for ( resno = 0 ; resno < l_current_comp -> numresolutions ; resno ++ ) { l_res -> pdx = * ( l_encoding_value_ptr ++ ) ; l_res -> pdy = * ( l_encoding_value_ptr ++ ) ; l_res -> pw = * ( l_encoding_value_ptr ++ ) ; l_res -> ph = * ( l_encoding_value_ptr ++ ) ; ++ l_res ; } ++ l_current_comp ; ++ l_img_comp ; ++ l_tccp ; } l_current_pi -> include = ( l_current_pi - 1 ) -> include ; ++ l_current_pi ; } opj_free ( l_tmp_data ) ; l_tmp_data = 00 ; opj_free ( l_tmp_ptr ) ; l_tmp_ptr = 00 ; if ( l_tcp -> POC ) { opj_pi_update_decode_poc ( l_pi , l_tcp , l_max_prec , l_max_res ) ; } else { opj_pi_update_decode_not_poc ( l_pi , l_tcp , l_max_prec , l_max_res ) ; } return l_pi ; }\n","target":"<S2SV_ModStart> opj_calloc ( ( size_t ) ( <S2SV_ModStart> -> numlayers + 1U <S2SV_ModEnd> ) * l_step_l\n","project_and_commit_id":"uclouvain@openjpeg/ef01f18dfc6780b776d0674ed3e7415c6ef54d24","cve_id":"CVE-2016-7163","original_address":"https://github.com/uclouvain/openjpeg/commit/ef01f18dfc6780b776d0674ed3e7415c6ef54d24","time":"2016-09-21T14:25Z"},
	{"Unnamed: 0":5275,"cwe_id":"CWE-119","source":"CWE-119 static int nl80211_trigger_scan ( struct sk_buff * skb , struct genl_info * info ) { struct cfg80211_registered_device * rdev = info -> user_ptr [ 0 ] ; struct net_device * dev = info -> user_ptr [ 1 ] ; struct cfg80211_scan_request * request ; struct nlattr * attr ; struct wiphy * wiphy ; int err , tmp , n_ssids = 0 , n_channels , i ; enum ieee80211_band band ; size_t ie_len ; if ( ! is_valid_ie_attr ( info -> attrs [ NL80211_ATTR_IE ] ) ) return - EINVAL ; wiphy = & rdev -> wiphy ; if ( ! rdev -> ops -> scan ) return - EOPNOTSUPP ; if ( rdev -> scan_req ) return - EBUSY ; if ( info -> attrs [ NL80211_ATTR_SCAN_FREQUENCIES ] ) { n_channels = validate_scan_freqs ( info -> attrs [ NL80211_ATTR_SCAN_FREQUENCIES ] ) ; if ( ! n_channels ) return - EINVAL ; } else { n_channels = 0 ; for ( band = 0 ; band < IEEE80211_NUM_BANDS ; band ++ ) if ( wiphy -> bands [ band ] ) n_channels += wiphy -> bands [ band ] -> n_channels ; } if ( info -> attrs [ NL80211_ATTR_SCAN_SSIDS ] ) nla_for_each_nested ( attr , info -> attrs [ NL80211_ATTR_SCAN_SSIDS ] , tmp ) n_ssids ++ ; if ( n_ssids > wiphy -> max_scan_ssids ) return - EINVAL ; if ( info -> attrs [ NL80211_ATTR_IE ] ) ie_len = nla_len ( info -> attrs [ NL80211_ATTR_IE ] ) ; else ie_len = 0 ; if ( ie_len > wiphy -> max_scan_ie_len ) return - EINVAL ; request = kzalloc ( sizeof ( * request ) + sizeof ( * request -> ssids ) * n_ssids + sizeof ( * request -> channels ) * n_channels + ie_len , GFP_KERNEL ) ; if ( ! request ) return - ENOMEM ; if ( n_ssids ) request -> ssids = ( void * ) & request -> channels [ n_channels ] ; request -> n_ssids = n_ssids ; if ( ie_len ) { if ( request -> ssids ) request -> ie = ( void * ) ( request -> ssids + n_ssids ) ; else request -> ie = ( void * ) ( request -> channels + n_channels ) ; } i = 0 ; if ( info -> attrs [ NL80211_ATTR_SCAN_FREQUENCIES ] ) { nla_for_each_nested ( attr , info -> attrs [ NL80211_ATTR_SCAN_FREQUENCIES ] , tmp ) { struct ieee80211_channel * chan ; chan = ieee80211_get_channel ( wiphy , nla_get_u32 ( attr ) ) ; if ( ! chan ) { err = - EINVAL ; goto out_free ; } if ( chan -> flags & IEEE80211_CHAN_DISABLED ) continue ; request -> channels [ i ] = chan ; i ++ ; } } else { for ( band = 0 ; band < IEEE80211_NUM_BANDS ; band ++ ) { int j ; if ( ! wiphy -> bands [ band ] ) continue ; for ( j = 0 ; j < wiphy -> bands [ band ] -> n_channels ; j ++ ) { struct ieee80211_channel * chan ; chan = & wiphy -> bands [ band ] -> channels [ j ] ; if ( chan -> flags & IEEE80211_CHAN_DISABLED ) continue ; request -> channels [ i ] = chan ; i ++ ; } } } if ( ! i ) { err = - EINVAL ; goto out_free ; } request -> n_channels = i ; i = 0 ; if ( info -> attrs [ NL80211_ATTR_SCAN_SSIDS ] ) { <S2SV_StartBug> nla_for_each_nested ( attr , info -> attrs [ NL80211_ATTR_SCAN_SSIDS ] , tmp ) { <S2SV_EndBug> if ( request -> ssids [ i ] . ssid_len > IEEE80211_MAX_SSID_LEN ) { err = - EINVAL ; goto out_free ; } memcpy ( request -> ssids [ i ] . ssid , nla_data ( attr ) , nla_len ( attr ) ) ; <S2SV_StartBug> request -> ssids [ i ] . ssid_len = nla_len ( attr ) ; <S2SV_EndBug> i ++ ; } } if ( info -> attrs [ NL80211_ATTR_IE ] ) { request -> ie_len = nla_len ( info -> attrs [ NL80211_ATTR_IE ] ) ; memcpy ( ( void * ) request -> ie , nla_data ( info -> attrs [ NL80211_ATTR_IE ] ) , request -> ie_len ) ; } request -> dev = dev ; request -> wiphy = & rdev -> wiphy ; rdev -> scan_req = request ; err = rdev -> ops -> scan ( & rdev -> wiphy , dev , request ) ; if ( ! err ) { nl80211_send_scan_start ( rdev , dev ) ; dev_hold ( dev ) ; } else { out_free : rdev -> scan_req = NULL ; kfree ( request ) ; } return err ; }\n","target":"<S2SV_ModStart> tmp ) { request -> ssids [ i ] . ssid_len = nla_len ( attr ) ; <S2SV_ModStart> ) ) ; <S2SV_ModEnd> i ++ ;\n","project_and_commit_id":"torvalds@linux/208c72f4fe44fe09577e7975ba0e7fa0278f3d03","cve_id":"CVE-2011-2517","original_address":"https://github.com/torvalds/linux/commit/208c72f4fe44fe09577e7975ba0e7fa0278f3d03","time":"2012-05-24T23:55Z"},
	{"Unnamed: 0":3002,"cwe_id":"CWE-125","source":"CWE-125 int yr_re_fast_exec ( uint8_t * code , uint8_t * input_data , <S2SV_StartBug> size_t input_size , <S2SV_EndBug> int flags , RE_MATCH_CALLBACK_FUNC callback , void * callback_args ) { RE_REPEAT_ANY_ARGS * repeat_any_args ; uint8_t * code_stack [ MAX_FAST_RE_STACK ] ; uint8_t * input_stack [ MAX_FAST_RE_STACK ] ; int matches_stack [ MAX_FAST_RE_STACK ] ; uint8_t * ip = code ; uint8_t * input = input_data ; uint8_t * next_input ; uint8_t * next_opcode ; uint8_t mask ; uint8_t value ; int i ; int stop ; int input_incr ; int sp = 0 ; int bytes_matched ; <S2SV_StartBug> int max_bytes_matched = input_size ; <S2SV_EndBug> input_incr = flags & RE_FLAGS_BACKWARDS ? - 1 : 1 ; if ( flags & RE_FLAGS_BACKWARDS ) input -- ; code_stack [ sp ] = code ; input_stack [ sp ] = input ; matches_stack [ sp ] = 0 ; sp ++ ; while ( sp > 0 ) { sp -- ; ip = code_stack [ sp ] ; input = input_stack [ sp ] ; bytes_matched = matches_stack [ sp ] ; stop = FALSE ; while ( ! stop ) { if ( * ip == RE_OPCODE_MATCH ) { if ( flags & RE_FLAGS_EXHAUSTIVE ) { int cb_result = callback ( flags & RE_FLAGS_BACKWARDS ? input + 1 : input_data , bytes_matched , flags , callback_args ) ; switch ( cb_result ) { case ERROR_INSUFFICIENT_MEMORY : return - 2 ; case ERROR_TOO_MANY_MATCHES : return - 3 ; default : if ( cb_result != ERROR_SUCCESS ) return - 4 ; } break ; } else { return bytes_matched ; } } if ( bytes_matched >= max_bytes_matched ) break ; switch ( * ip ) { case RE_OPCODE_LITERAL : if ( * input == * ( ip + 1 ) ) { bytes_matched ++ ; input += input_incr ; ip += 2 ; } else { stop = TRUE ; } break ; case RE_OPCODE_MASKED_LITERAL : value = * ( int16_t * ) ( ip + 1 ) & 0xFF ; mask = * ( int16_t * ) ( ip + 1 ) >> 8 ; if ( ( * input & mask ) == value ) { bytes_matched ++ ; input += input_incr ; ip += 3 ; } else { stop = TRUE ; } break ; case RE_OPCODE_ANY : bytes_matched ++ ; input += input_incr ; ip += 1 ; break ; case RE_OPCODE_REPEAT_ANY_UNGREEDY : repeat_any_args = ( RE_REPEAT_ANY_ARGS * ) ( ip + 1 ) ; next_opcode = ip + 1 + sizeof ( RE_REPEAT_ANY_ARGS ) ; for ( i = repeat_any_args -> min + 1 ; i <= repeat_any_args -> max ; i ++ ) { next_input = input + i * input_incr ; if ( bytes_matched + i >= max_bytes_matched ) break ; if ( * ( next_opcode ) != RE_OPCODE_LITERAL || ( * ( next_opcode ) == RE_OPCODE_LITERAL && * ( next_opcode + 1 ) == * next_input ) ) { if ( sp >= MAX_FAST_RE_STACK ) return - 4 ; code_stack [ sp ] = next_opcode ; input_stack [ sp ] = next_input ; matches_stack [ sp ] = bytes_matched + i ; sp ++ ; } } input += input_incr * repeat_any_args -> min ; bytes_matched += repeat_any_args -> min ; ip = next_opcode ; break ; default : assert ( FALSE ) ; } } } return - 1 ; }\n","target":"<S2SV_ModStart> input_data , size_t input_forwards_size , size_t input_backwards_size <S2SV_ModEnd> , int flags <S2SV_ModStart> ; int max_bytes_matched ; max_bytes_matched = flags & RE_FLAGS_BACKWARDS ? input_backwards_size : input_forwards_size <S2SV_ModEnd> ; input_incr =\n","project_and_commit_id":"VirusTotal@yara/83d799804648c2a0895d40a19835d9b757c6fa4e","cve_id":"CVE-2017-8294","original_address":"https://github.com/VirusTotal/yara/commit/83d799804648c2a0895d40a19835d9b757c6fa4e","time":"2017-04-27T14:59Z"},
	{"Unnamed: 0":1467,"cwe_id":"CWE-617","source":"CWE-617 static void pci_cfgrw ( struct vmctx * ctx , int vcpu , int in , int bus , int slot , int func , int coff , int bytes , uint32_t * eax ) { struct businfo * bi ; struct slotinfo * si ; struct pci_vdev * dev ; struct pci_vdev_ops * ops ; int idx , needcfg ; uint64_t addr , bar , mask ; bool decode , ignore_reg_unreg = false ; bi = pci_businfo [ bus ] ; if ( bi != NULL ) { si = & bi -> slotinfo [ slot ] ; dev = si -> si_funcs [ func ] . fi_devi ; } else dev = NULL ; if ( dev == NULL || ( bytes != 1 && bytes != 2 && bytes != 4 ) || ( coff & ( bytes - 1 ) ) != 0 ) { if ( in ) * eax = 0xffffffff ; return ; } ops = dev -> dev_ops ; if ( strcmp ( \"passthru\" , ops -> class_name ) ) { if ( coff >= PCI_REGMAX + 1 ) { if ( in ) { * eax = 0xffffffff ; if ( coff <= PCI_REGMAX + 4 ) * eax = 0x00000000 ; } return ; } } if ( in ) { if ( ops -> vdev_cfgread != NULL ) { needcfg = ops -> vdev_cfgread ( ctx , vcpu , dev , coff , bytes , eax ) ; } else { needcfg = 1 ; } if ( needcfg ) * eax = CFGREAD ( dev , coff , bytes ) ; pci_emul_hdrtype_fixup ( bus , slot , coff , bytes , eax ) ; } else { if ( ops -> vdev_cfgwrite != NULL && ( * ops -> vdev_cfgwrite ) ( ctx , vcpu , dev , coff , bytes , * eax ) == 0 ) return ; if ( coff >= PCIR_BAR ( 0 ) && coff < PCIR_BAR ( PCI_BARMAX + 1 ) ) { if ( bytes != 4 || ( coff & 0x3 ) != 0 ) return ; idx = ( coff - PCIR_BAR ( 0 ) ) / 4 ; mask = ~ ( dev -> bar [ idx ] . size - 1 ) ; if ( dev -> bar [ idx ] . type == PCIBAR_IO ) decode = porten ( dev ) ; else decode = memen ( dev ) ; if ( decode ) { if ( ! dev -> bar [ idx ] . sizing && ( * eax == ~ 0U ) ) { dev -> bar [ idx ] . sizing = true ; ignore_reg_unreg = true ; } else if ( dev -> bar [ idx ] . sizing && ( * eax != ~ 0U ) ) { dev -> bar [ idx ] . sizing = false ; ignore_reg_unreg = true ; } } switch ( dev -> bar [ idx ] . type ) { case PCIBAR_NONE : dev -> bar [ idx ] . addr = bar = 0 ; break ; case PCIBAR_IO : addr = * eax & mask ; addr &= 0xffff ; bar = addr | PCIM_BAR_IO_SPACE ; if ( addr != dev -> bar [ idx ] . addr ) { update_bar_address ( ctx , dev , addr , idx , PCIBAR_IO , ignore_reg_unreg ) ; } break ; case PCIBAR_MEM32 : addr = bar = * eax & mask ; bar |= PCIM_BAR_MEM_SPACE | PCIM_BAR_MEM_32 ; if ( addr != dev -> bar [ idx ] . addr ) { update_bar_address ( ctx , dev , addr , idx , PCIBAR_MEM32 , ignore_reg_unreg ) ; } break ; case PCIBAR_MEM64 : addr = bar = * eax & mask ; bar |= PCIM_BAR_MEM_SPACE | PCIM_BAR_MEM_64 | PCIM_BAR_MEM_PREFETCH ; if ( addr != ( uint32_t ) dev -> bar [ idx ] . addr ) { update_bar_address ( ctx , dev , addr , idx , PCIBAR_MEM64 , ignore_reg_unreg ) ; } break ; case PCIBAR_MEMHI64 : <S2SV_StartBug> assert ( idx >= 1 ) ; <S2SV_EndBug> mask = ~ ( dev -> bar [ idx - 1 ] . size - 1 ) ; addr = ( ( uint64_t ) * eax << 32 ) & mask ; bar = addr >> 32 ; if ( bar != dev -> bar [ idx - 1 ] . addr >> 32 ) { update_bar_address ( ctx , dev , addr , idx - 1 , PCIBAR_MEMHI64 , ignore_reg_unreg ) ; } break ; default : <S2SV_StartBug> assert ( 0 ) ; <S2SV_EndBug> } pci_set_cfgdata32 ( dev , coff , bar ) ; } else if ( coff == PCIR_BIOS ) { } else if ( pci_emul_iscap ( dev , coff ) ) { pci_emul_capwrite ( dev , coff , bytes , * eax ) ; } else if ( coff >= PCIR_COMMAND && coff < PCIR_REVID ) { pci_emul_cmdsts_write ( dev , coff , * eax , bytes ) ; } else { CFGWRITE ( dev , coff , * eax , bytes ) ; } } }\n","target":"<S2SV_ModStart> case PCIBAR_MEMHI64 : <S2SV_ModEnd> mask = ~ <S2SV_ModStart> ; default : pr_err ( \"%s:<S2SV_blank>invalid<S2SV_blank>bar<S2SV_blank>type<S2SV_blank>%d\\\\n\" , __func__ , dev -> bar [ idx ] . type ) ; return <S2SV_ModEnd> ; } pci_set_cfgdata32\n","project_and_commit_id":"projectacrn@acrn-hypervisor/2b3dedfb9ba13f15887f22b935d373f36c9a59fa","cve_id":"CVE-2019-18844","original_address":"https://github.com/projectacrn/acrn-hypervisor/commit/2b3dedfb9ba13f15887f22b935d373f36c9a59fa","time":"2019-11-13T20:15Z"},
	{"Unnamed: 0":2322,"cwe_id":"CWE-476","source":"CWE-476 int nfc_llcp_send_cc ( struct nfc_llcp_sock * sock ) { struct nfc_llcp_local * local ; struct sk_buff * skb ; u8 * miux_tlv = NULL , miux_tlv_length ; u8 * rw_tlv = NULL , rw_tlv_length , rw ; int err ; u16 size = 0 ; __be16 miux ; pr_debug ( \"Sending<S2SV_blank>CC\\\\n\" ) ; local = sock -> local ; if ( local == NULL ) return - ENODEV ; miux = be16_to_cpu ( sock -> miux ) > LLCP_MAX_MIUX ? local -> miux : sock -> miux ; rw = sock -> rw > LLCP_MAX_RW ? local -> rw : sock -> rw ; miux_tlv = nfc_llcp_build_tlv ( LLCP_TLV_MIUX , ( u8 * ) & miux , 0 , & miux_tlv_length ) ; <S2SV_StartBug> size += miux_tlv_length ; <S2SV_EndBug> rw_tlv = nfc_llcp_build_tlv ( LLCP_TLV_RW , & rw , 0 , & rw_tlv_length ) ; <S2SV_StartBug> size += rw_tlv_length ; <S2SV_EndBug> skb = llcp_allocate_pdu ( sock , LLCP_PDU_CC , size ) ; if ( skb == NULL ) { err = - ENOMEM ; goto error_tlv ; } llcp_add_tlv ( skb , miux_tlv , miux_tlv_length ) ; llcp_add_tlv ( skb , rw_tlv , rw_tlv_length ) ; skb_queue_tail ( & local -> tx_queue , skb ) ; err = 0 ; error_tlv : if ( err ) pr_err ( \"error<S2SV_blank>%d\\\\n\" , err ) ; kfree ( miux_tlv ) ; kfree ( rw_tlv ) ; return err ; }\n","target":"<S2SV_ModStart> miux_tlv_length ) ; if ( ! miux_tlv ) { err = - ENOMEM ; goto error_tlv ; } <S2SV_ModStart> rw_tlv_length ) ; if ( ! rw_tlv ) { err = - ENOMEM ; goto error_tlv ; }\n","project_and_commit_id":"torvalds@linux/58bdd544e2933a21a51eecf17c3f5f94038261b5","cve_id":"CVE-2019-12818","original_address":"https://github.com/torvalds/linux/commit/58bdd544e2933a21a51eecf17c3f5f94038261b5","time":"2019-06-14T02:29Z"},
	{"Unnamed: 0":2805,"cwe_id":"CWE-79","source":"CWE-79 static int oidc_handle_session_management_iframe_rp ( request_rec * r , oidc_cfg * c , oidc_session_t * session , const char * client_id , const char * check_session_iframe ) { oidc_debug ( r , \"enter\" ) ; const char * java_script = \"<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><script<S2SV_blank>type=\\\\\"text/javascript\\\\\">\\\\n\" \"<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>var<S2SV_blank>targetOrigin<S2SV_blank><S2SV_blank>=<S2SV_blank>\\'%s\\';\\\\n\" \"<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>var<S2SV_blank>message<S2SV_blank>=<S2SV_blank>\\'%s\\'<S2SV_blank>+<S2SV_blank>\\'<S2SV_blank>\\'<S2SV_blank>+<S2SV_blank>\\'%s\\';\\\\n\" \"\\t<S2SV_blank><S2SV_blank><S2SV_blank>var<S2SV_blank>timerID;\\\\n\" \"\\\\n\" \"<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>function<S2SV_blank>checkSession()<S2SV_blank>{\\\\n\" \"<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>console.debug(\\'checkSession:<S2SV_blank>posting<S2SV_blank>\\'<S2SV_blank>+<S2SV_blank>message<S2SV_blank>+<S2SV_blank>\\'<S2SV_blank>to<S2SV_blank>\\'<S2SV_blank>+<S2SV_blank>targetOrigin);\\\\n\" \"<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>var<S2SV_blank>win<S2SV_blank>=<S2SV_blank>window.parent.document.getElementById(\\'%s\\').contentWindow;\\\\n\" \"<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>win.postMessage(<S2SV_blank>message,<S2SV_blank>targetOrigin);\\\\n\" \"<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}\\\\n\" \"\\\\n\" \"<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>function<S2SV_blank>setTimer()<S2SV_blank>{\\\\n\" \"<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>checkSession();\\\\n\" <S2SV_StartBug> \"<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>timerID<S2SV_blank>=<S2SV_blank>setInterval(\\'checkSession()\\',<S2SV_blank>%s);\\\\n\" <S2SV_EndBug> \"<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}\\\\n\" \"\\\\n\" \"<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>function<S2SV_blank>receiveMessage(e)<S2SV_blank>{\\\\n\" \"<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>console.debug(\\'receiveMessage:<S2SV_blank>\\'<S2SV_blank>+<S2SV_blank>e.data<S2SV_blank>+<S2SV_blank>\\'<S2SV_blank>from<S2SV_blank>\\'<S2SV_blank>+<S2SV_blank>e.origin);\\\\n\" \"<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>if<S2SV_blank>(e.origin<S2SV_blank>!==<S2SV_blank>targetOrigin<S2SV_blank>)<S2SV_blank>{\\\\n\" \"<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>console.debug(\\'receiveMessage:<S2SV_blank>cross-site<S2SV_blank>scripting<S2SV_blank>attack?\\');\\\\n\" \"<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>return;\\\\n\" \"<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}\\\\n\" \"<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>if<S2SV_blank>(e.data<S2SV_blank>!=<S2SV_blank>\\'unchanged\\')<S2SV_blank>{\\\\n\" \"<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>clearInterval(timerID);\\\\n\" \"<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>if<S2SV_blank>(e.data<S2SV_blank>==<S2SV_blank>\\'changed\\')<S2SV_blank>{\\\\n\" \"\\t\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>window.location.href<S2SV_blank>=<S2SV_blank>\\'%s?session=check\\';\\\\n\" \"<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}<S2SV_blank>else<S2SV_blank>{\\\\n\" \"\\t\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>window.location.href<S2SV_blank>=<S2SV_blank>\\'%s?session=logout\\';\\\\n\" \"<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}\\\\n\" \"<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}\\\\n\" \"<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}\\\\n\" \"\\\\n\" \"<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>window.addEventListener(\\'message\\',<S2SV_blank>receiveMessage,<S2SV_blank>false);\\\\n\" \"\\\\n\" \"<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank></script>\\\\n\" ; char * origin = apr_pstrdup ( r -> pool , check_session_iframe ) ; apr_uri_t uri ; apr_uri_parse ( r -> pool , check_session_iframe , & uri ) ; char * p = strstr ( origin , uri . path ) ; * p = '\\\\0' ; const char * op_iframe_id = \"openidc-op\" ; const char * session_state = oidc_session_get_session_state ( r , session ) ; if ( session_state == NULL ) { oidc_warn ( r , \"no<S2SV_blank>session_state<S2SV_blank>found<S2SV_blank>in<S2SV_blank>the<S2SV_blank>session;<S2SV_blank>the<S2SV_blank>OP<S2SV_blank>does<S2SV_blank>probably<S2SV_blank>not<S2SV_blank>support<S2SV_blank>session<S2SV_blank>management!?\" ) ; return DONE ; } char * s_poll_interval = NULL ; oidc_util_get_request_parameter ( r , \"poll\" , & s_poll_interval ) ; <S2SV_StartBug> if ( s_poll_interval == NULL ) <S2SV_EndBug> s_poll_interval = \"3000\" ; const char * redirect_uri = oidc_get_redirect_uri ( r , c ) ; java_script = apr_psprintf ( r -> pool , java_script , origin , client_id , <S2SV_StartBug> session_state , op_iframe_id , s_poll_interval , redirect_uri , <S2SV_EndBug> redirect_uri ) ; return oidc_util_html_send ( r , NULL , java_script , \"setTimer\" , NULL , DONE ) ; }\n","target":"<S2SV_ModStart> \"\\\\n\" \"<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>function<S2SV_blank>setTimer()<S2SV_blank>{\\\\n\" \"<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>checkSession();\\\\n\" \"<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>timerID<S2SV_blank>=<S2SV_blank>setInterval(\\'checkSession()\\',<S2SV_blank>%d);\\\\n\" <S2SV_ModEnd> \"<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}\\\\n\" \"\\\\n\" \"<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>function<S2SV_blank>receiveMessage(e)<S2SV_blank>{\\\\n\" <S2SV_ModStart> s_poll_interval ) ; int poll_interval = s_poll_interval ? strtol ( s_poll_interval , NULL , 10 ) : 0 ; if ( ( poll_interval <= 0 ) || ( poll_interval > 3600 * 24 ) ) poll_interval = 3000 <S2SV_ModEnd> ; const char <S2SV_ModStart> , op_iframe_id , poll_interval <S2SV_ModEnd> , redirect_uri ,\n","project_and_commit_id":"zmartzone@mod_auth_openidc/132a4111bf3791e76437619a66336dce2ce4c79b","cve_id":"CVE-2019-1010247","original_address":"https://github.com/zmartzone/mod_auth_openidc/commit/132a4111bf3791e76437619a66336dce2ce4c79b","time":"2019-07-19T15:15Z"},
	{"Unnamed: 0":492,"cwe_id":"CWE-119","source":"CWE-119 static void vhost_scsi_send_evt ( struct vhost_scsi * vs , struct vhost_scsi_tpg * tpg , struct se_lun * lun , u32 event , u32 reason ) { struct vhost_scsi_evt * evt ; evt = vhost_scsi_allocate_evt ( vs , event , reason ) ; if ( ! evt ) return ; if ( tpg && lun ) { evt -> event . lun [ 0 ] = 0x01 ; <S2SV_StartBug> evt -> event . lun [ 1 ] = tpg -> tport_tpgt & 0xFF ; <S2SV_EndBug> if ( lun -> unpacked_lun >= 256 ) evt -> event . lun [ 2 ] = lun -> unpacked_lun >> 8 | 0x40 ; evt -> event . lun [ 3 ] = lun -> unpacked_lun & 0xFF ; } llist_add ( & evt -> list , & vs -> vs_event_list ) ; vhost_work_queue ( & vs -> dev , & vs -> vs_event_work ) ; }\n","target":"<S2SV_ModStart> tpg -> tport_tpgt <S2SV_ModEnd> ; if (\n","project_and_commit_id":"torvalds@linux/59c816c1f24df0204e01851431d3bab3eb76719c","cve_id":"CVE-2015-4036","original_address":"https://github.com/torvalds/linux/commit/59c816c1f24df0204e01851431d3bab3eb76719c","time":"2015-08-31T20:59Z"},
	{"Unnamed: 0":3386,"cwe_id":"CWE-125","source":"CWE-125 PyObject * ast2obj_comprehension ( void * _o ) { comprehension_ty o = ( comprehension_ty ) _o ; PyObject * result = NULL , * value = NULL ; if ( ! o ) { <S2SV_StartBug> Py_INCREF ( Py_None ) ; <S2SV_EndBug> return Py_None ; } result = PyType_GenericNew ( comprehension_type , NULL , NULL ) ; if ( ! result ) return NULL ; value = ast2obj_expr ( o -> target ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_target , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; value = ast2obj_expr ( o -> iter ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_iter , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; value = ast2obj_list ( o -> ifs , ast2obj_expr ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_ifs , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; value = ast2obj_int ( o -> is_async ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_is_async , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; return result ; failed : Py_XDECREF ( value ) ; Py_XDECREF ( result ) ; return NULL ; }\n","target":"<S2SV_ModStart> o ) { Py_RETURN_NONE <S2SV_ModEnd> ; } result\n","project_and_commit_id":"python@typed_ast/156afcb26c198e162504a57caddfe0acd9ed7dce","cve_id":"CVE-2019-19275","original_address":"https://github.com/python/typed_ast/commit/156afcb26c198e162504a57caddfe0acd9ed7dce","time":"2019-11-26T15:15Z"},
	{"Unnamed: 0":5471,"cwe_id":"CWE-362","source":"CWE-362 SYSCALL_DEFINE3 ( shmctl , int , shmid , int , cmd , struct shmid_ds __user * , buf ) { struct shmid_kernel * shp ; int err , version ; struct ipc_namespace * ns ; if ( cmd < 0 || shmid < 0 ) return - EINVAL ; version = ipc_parse_version ( & cmd ) ; ns = current -> nsproxy -> ipc_ns ; switch ( cmd ) { case IPC_INFO : case SHM_INFO : case SHM_STAT : case IPC_STAT : return shmctl_nolock ( ns , shmid , cmd , version , buf ) ; case IPC_RMID : case IPC_SET : return shmctl_down ( ns , shmid , cmd , buf , version ) ; case SHM_LOCK : case SHM_UNLOCK : { struct file * shm_file ; rcu_read_lock ( ) ; shp = shm_obtain_object_check ( ns , shmid ) ; if ( IS_ERR ( shp ) ) { err = PTR_ERR ( shp ) ; goto out_unlock1 ; } audit_ipc_obj ( & ( shp -> shm_perm ) ) ; err = security_shm_shmctl ( shp , cmd ) ; if ( err ) goto out_unlock1 ; ipc_lock_object ( & shp -> shm_perm ) ; if ( ! ns_capable ( ns -> user_ns , CAP_IPC_LOCK ) ) { kuid_t euid = current_euid ( ) ; err = - EPERM ; if ( ! uid_eq ( euid , shp -> shm_perm . uid ) && ! uid_eq ( euid , shp -> shm_perm . cuid ) ) goto out_unlock0 ; if ( cmd == SHM_LOCK && ! rlimit ( RLIMIT_MEMLOCK ) ) goto out_unlock0 ; } shm_file = shp -> shm_file ; <S2SV_StartBug> if ( is_file_hugepages ( shm_file ) ) <S2SV_EndBug> goto out_unlock0 ; if ( cmd == SHM_LOCK ) { struct user_struct * user = current_user ( ) ; err = shmem_lock ( shm_file , 1 , user ) ; if ( ! err && ! ( shp -> shm_perm . mode & SHM_LOCKED ) ) { shp -> shm_perm . mode |= SHM_LOCKED ; shp -> mlock_user = user ; } goto out_unlock0 ; } if ( ! ( shp -> shm_perm . mode & SHM_LOCKED ) ) goto out_unlock0 ; shmem_lock ( shm_file , 0 , shp -> mlock_user ) ; shp -> shm_perm . mode &= ~ SHM_LOCKED ; shp -> mlock_user = NULL ; get_file ( shm_file ) ; ipc_unlock_object ( & shp -> shm_perm ) ; rcu_read_unlock ( ) ; shmem_unlock_mapping ( shm_file -> f_mapping ) ; fput ( shm_file ) ; return err ; } default : return - EINVAL ; } out_unlock0 : ipc_unlock_object ( & shp -> shm_perm ) ; out_unlock1 : rcu_read_unlock ( ) ; return err ; }\n","target":"<S2SV_ModStart> ; if ( shm_file == NULL ) { err = - EIDRM ; goto out_unlock0 ; } if (\n","project_and_commit_id":"torvalds@linux/a399b29dfbaaaf91162b2dc5a5875dd51bbfa2a1","cve_id":"CVE-2013-7026","original_address":"https://github.com/torvalds/linux/commit/a399b29dfbaaaf91162b2dc5a5875dd51bbfa2a1","time":"2013-12-09T18:55Z"},
	{"Unnamed: 0":2849,"cwe_id":"CWE-264","source":"CWE-264 static int dccp_v6_connect ( struct sock * sk , struct sockaddr * uaddr , int addr_len ) { struct sockaddr_in6 * usin = ( struct sockaddr_in6 * ) uaddr ; struct inet_connection_sock * icsk = inet_csk ( sk ) ; struct inet_sock * inet = inet_sk ( sk ) ; struct ipv6_pinfo * np = inet6_sk ( sk ) ; struct dccp_sock * dp = dccp_sk ( sk ) ; <S2SV_StartBug> struct in6_addr * saddr = NULL , * final_p , final ; <S2SV_EndBug> struct flowi6 fl6 ; struct dst_entry * dst ; int addr_type ; int err ; dp -> dccps_role = DCCP_ROLE_CLIENT ; if ( addr_len < SIN6_LEN_RFC2133 ) return - EINVAL ; if ( usin -> sin6_family != AF_INET6 ) return - EAFNOSUPPORT ; memset ( & fl6 , 0 , sizeof ( fl6 ) ) ; if ( np -> sndflow ) { fl6 . flowlabel = usin -> sin6_flowinfo & IPV6_FLOWINFO_MASK ; IP6_ECN_flow_init ( fl6 . flowlabel ) ; if ( fl6 . flowlabel & IPV6_FLOWLABEL_MASK ) { struct ip6_flowlabel * flowlabel ; flowlabel = fl6_sock_lookup ( sk , fl6 . flowlabel ) ; if ( flowlabel == NULL ) return - EINVAL ; fl6_sock_release ( flowlabel ) ; } } if ( ipv6_addr_any ( & usin -> sin6_addr ) ) usin -> sin6_addr . s6_addr [ 15 ] = 1 ; addr_type = ipv6_addr_type ( & usin -> sin6_addr ) ; if ( addr_type & IPV6_ADDR_MULTICAST ) return - ENETUNREACH ; if ( addr_type & IPV6_ADDR_LINKLOCAL ) { if ( addr_len >= sizeof ( struct sockaddr_in6 ) && usin -> sin6_scope_id ) { if ( sk -> sk_bound_dev_if && sk -> sk_bound_dev_if != usin -> sin6_scope_id ) return - EINVAL ; sk -> sk_bound_dev_if = usin -> sin6_scope_id ; } if ( ! sk -> sk_bound_dev_if ) return - EINVAL ; } sk -> sk_v6_daddr = usin -> sin6_addr ; np -> flow_label = fl6 . flowlabel ; if ( addr_type == IPV6_ADDR_MAPPED ) { u32 exthdrlen = icsk -> icsk_ext_hdr_len ; struct sockaddr_in sin ; SOCK_DEBUG ( sk , \"connect:<S2SV_blank>ipv4<S2SV_blank>mapped\\\\n\" ) ; if ( __ipv6_only_sock ( sk ) ) return - ENETUNREACH ; sin . sin_family = AF_INET ; sin . sin_port = usin -> sin6_port ; sin . sin_addr . s_addr = usin -> sin6_addr . s6_addr32 [ 3 ] ; icsk -> icsk_af_ops = & dccp_ipv6_mapped ; sk -> sk_backlog_rcv = dccp_v4_do_rcv ; err = dccp_v4_connect ( sk , ( struct sockaddr * ) & sin , sizeof ( sin ) ) ; if ( err ) { icsk -> icsk_ext_hdr_len = exthdrlen ; icsk -> icsk_af_ops = & dccp_ipv6_af_ops ; sk -> sk_backlog_rcv = dccp_v6_do_rcv ; goto failure ; } np -> saddr = sk -> sk_v6_rcv_saddr ; return err ; } if ( ! ipv6_addr_any ( & sk -> sk_v6_rcv_saddr ) ) saddr = & sk -> sk_v6_rcv_saddr ; fl6 . flowi6_proto = IPPROTO_DCCP ; fl6 . daddr = sk -> sk_v6_daddr ; fl6 . saddr = saddr ? * saddr : np -> saddr ; fl6 . flowi6_oif = sk -> sk_bound_dev_if ; fl6 . fl6_dport = usin -> sin6_port ; fl6 . fl6_sport = inet -> inet_sport ; security_sk_classify_flow ( sk , flowi6_to_flowi ( & fl6 ) ) ; <S2SV_StartBug> final_p = fl6_update_dst ( & fl6 , np -> opt , & final ) ; <S2SV_EndBug> dst = ip6_dst_lookup_flow ( sk , & fl6 , final_p ) ; if ( IS_ERR ( dst ) ) { err = PTR_ERR ( dst ) ; goto failure ; } if ( saddr == NULL ) { saddr = & fl6 . saddr ; sk -> sk_v6_rcv_saddr = * saddr ; } np -> saddr = * saddr ; inet -> inet_rcv_saddr = LOOPBACK4_IPV6 ; __ip6_dst_store ( sk , dst , NULL , NULL ) ; icsk -> icsk_ext_hdr_len = 0 ; <S2SV_StartBug> if ( np -> opt != NULL ) <S2SV_EndBug> <S2SV_StartBug> icsk -> icsk_ext_hdr_len = ( np -> opt -> opt_flen + <S2SV_EndBug> <S2SV_StartBug> np -> opt -> opt_nflen ) ; <S2SV_EndBug> inet -> inet_dport = usin -> sin6_port ; dccp_set_state ( sk , DCCP_REQUESTING ) ; err = inet6_hash_connect ( & dccp_death_row , sk ) ; if ( err ) goto late_failure ; dp -> dccps_iss = secure_dccpv6_sequence_number ( np -> saddr . s6_addr32 , sk -> sk_v6_daddr . s6_addr32 , inet -> inet_sport , inet -> inet_dport ) ; err = dccp_connect ( sk ) ; if ( err ) goto late_failure ; return 0 ; late_failure : dccp_set_state ( sk , DCCP_CLOSED ) ; __sk_dst_reset ( sk ) ; failure : inet -> inet_dport = 0 ; sk -> sk_route_caps = 0 ; return err ; }\n","target":"<S2SV_ModStart> final_p , final ; struct ipv6_txoptions * opt <S2SV_ModStart> ) ) ; opt = rcu_dereference_protected ( np -> opt , sock_owned_by_user ( sk ) ) ; <S2SV_ModStart> & fl6 , <S2SV_ModEnd> opt , & <S2SV_ModStart> ; if ( opt <S2SV_ModEnd> ) icsk -> <S2SV_ModStart> -> icsk_ext_hdr_len = <S2SV_ModEnd> opt -> opt_flen <S2SV_ModStart> -> opt_flen + <S2SV_ModEnd> opt -> opt_nflen <S2SV_ModStart> opt -> opt_nflen <S2SV_ModEnd> ; inet ->\n","project_and_commit_id":"torvalds@linux/45f6fad84cc305103b28d73482b344d7f5b76f39","cve_id":"CVE-2016-3841","original_address":"https://github.com/torvalds/linux/commit/45f6fad84cc305103b28d73482b344d7f5b76f39","time":"2016-08-06T20:59Z"},
	{"Unnamed: 0":6412,"cwe_id":"CWE-189","source":"CWE-189 static int g2m_init_buffers ( G2MContext * c ) { int aligned_height ; if ( ! c -> framebuf || c -> old_width < c -> width || c -> old_height < c -> height ) { c -> framebuf_stride = FFALIGN ( c -> width * 3 , 16 ) ; aligned_height = FFALIGN ( c -> height , 16 ) ; av_free ( c -> framebuf ) ; c -> framebuf = av_mallocz ( c -> framebuf_stride * aligned_height ) ; if ( ! c -> framebuf ) return AVERROR ( ENOMEM ) ; } if ( ! c -> synth_tile || ! c -> jpeg_tile || c -> old_tile_w < c -> tile_width || c -> old_tile_h < c -> tile_height ) { <S2SV_StartBug> c -> tile_stride = FFALIGN ( c -> tile_width * 3 , 16 ) ; <S2SV_EndBug> aligned_height = FFALIGN ( c -> tile_height , 16 ) ; av_free ( c -> synth_tile ) ; av_free ( c -> jpeg_tile ) ; av_free ( c -> kempf_buf ) ; av_free ( c -> kempf_flags ) ; c -> synth_tile = av_mallocz ( c -> tile_stride * aligned_height ) ; c -> jpeg_tile = av_mallocz ( c -> tile_stride * aligned_height ) ; c -> kempf_buf = av_mallocz ( ( c -> tile_width + 1 ) * aligned_height + FF_INPUT_BUFFER_PADDING_SIZE ) ; c -> kempf_flags = av_mallocz ( c -> tile_width * aligned_height ) ; if ( ! c -> synth_tile || ! c -> jpeg_tile || ! c -> kempf_buf || ! c -> kempf_flags ) return AVERROR ( ENOMEM ) ; } return 0 ; }\n","target":"<S2SV_ModStart> c -> tile_width <S2SV_ModEnd> , 16 ) <S2SV_ModStart> , 16 ) * 3\n","project_and_commit_id":"FFmpeg@FFmpeg/821a5938d100458f4d09d634041b05c860554ce0","cve_id":"CVE-2013-7013","original_address":"https://github.com/FFmpeg/FFmpeg/commit/821a5938d100458f4d09d634041b05c860554ce0","time":"2013-12-09T16:36Z"},
	{"Unnamed: 0":2362,"cwe_id":"CWE-000","source":"CWE-000 static int zipfileUpdate ( sqlite3_vtab * pVtab , int nVal , sqlite3_value * * apVal , sqlite_int64 * pRowid ) { ZipfileTab * pTab = ( ZipfileTab * ) pVtab ; int rc = SQLITE_OK ; ZipfileEntry * pNew = 0 ; u32 mode = 0 ; u32 mTime = 0 ; i64 sz = 0 ; const char * zPath = 0 ; int nPath = 0 ; const u8 * pData = 0 ; int nData = 0 ; int iMethod = 0 ; u8 * pFree = 0 ; char * zFree = 0 ; ZipfileEntry * pOld = 0 ; ZipfileEntry * pOld2 = 0 ; int bUpdate = 0 ; int bIsDir = 0 ; u32 iCrc32 = 0 ; if ( pTab -> pWriteFd == 0 ) { rc = zipfileBegin ( pVtab ) ; if ( rc != SQLITE_OK ) return rc ; } if ( sqlite3_value_type ( apVal [ 0 ] ) != SQLITE_NULL ) { const char * zDelete = ( const char * ) sqlite3_value_text ( apVal [ 0 ] ) ; int nDelete = ( int ) strlen ( zDelete ) ; if ( nVal > 1 ) { const char * zUpdate = ( const char * ) sqlite3_value_text ( apVal [ 1 ] ) ; if ( zUpdate && zipfileComparePath ( zUpdate , zDelete , nDelete ) != 0 ) { bUpdate = 1 ; } } for ( pOld = pTab -> pFirstEntry ; 1 ; pOld = pOld -> pNext ) { if ( zipfileComparePath ( pOld -> cds . zFile , zDelete , nDelete ) == 0 ) { break ; } assert ( pOld -> pNext ) ; } } if ( nVal > 1 ) { if ( sqlite3_value_type ( apVal [ 5 ] ) != SQLITE_NULL ) { zipfileTableErr ( pTab , \"sz<S2SV_blank>must<S2SV_blank>be<S2SV_blank>NULL\" ) ; rc = SQLITE_CONSTRAINT ; } if ( sqlite3_value_type ( apVal [ 6 ] ) != SQLITE_NULL ) { zipfileTableErr ( pTab , \"rawdata<S2SV_blank>must<S2SV_blank>be<S2SV_blank>NULL\" ) ; rc = SQLITE_CONSTRAINT ; } if ( rc == SQLITE_OK ) { if ( sqlite3_value_type ( apVal [ 7 ] ) == SQLITE_NULL ) { bIsDir = 1 ; } else { const u8 * aIn = sqlite3_value_blob ( apVal [ 7 ] ) ; int nIn = sqlite3_value_bytes ( apVal [ 7 ] ) ; int bAuto = sqlite3_value_type ( apVal [ 8 ] ) == SQLITE_NULL ; iMethod = sqlite3_value_int ( apVal [ 8 ] ) ; sz = nIn ; pData = aIn ; nData = nIn ; if ( iMethod != 0 && iMethod != 8 ) { zipfileTableErr ( pTab , \"unknown<S2SV_blank>compression<S2SV_blank>method:<S2SV_blank>%d\" , iMethod ) ; rc = SQLITE_CONSTRAINT ; } else { if ( bAuto || iMethod ) { int nCmp ; rc = zipfileDeflate ( aIn , nIn , & pFree , & nCmp , & pTab -> base . zErrMsg ) ; if ( rc == SQLITE_OK ) { if ( iMethod || nCmp < nIn ) { iMethod = 8 ; pData = pFree ; nData = nCmp ; } } } iCrc32 = crc32 ( 0 , aIn , nIn ) ; } } } if ( rc == SQLITE_OK ) { rc = zipfileGetMode ( apVal [ 3 ] , bIsDir , & mode , & pTab -> base . zErrMsg ) ; } if ( rc == SQLITE_OK ) { zPath = ( const char * ) sqlite3_value_text ( apVal [ 2 ] ) ; if ( zPath == 0 ) zPath = \"\" ; nPath = ( int ) strlen ( zPath ) ; mTime = zipfileGetTime ( apVal [ 4 ] ) ; } if ( rc == SQLITE_OK && bIsDir ) { if ( zPath [ nPath - 1 ] != '/' ) { zFree = sqlite3_mprintf ( \"%s/\" , zPath ) ; if ( zFree == 0 ) { rc = SQLITE_NOMEM ; } zPath = ( const char * ) zFree ; <S2SV_StartBug> nPath ++ ; <S2SV_EndBug> } } if ( ( pOld == 0 || bUpdate ) && rc == SQLITE_OK ) { ZipfileEntry * p ; for ( p = pTab -> pFirstEntry ; p ; p = p -> pNext ) { if ( zipfileComparePath ( p -> cds . zFile , zPath , nPath ) == 0 ) { switch ( sqlite3_vtab_on_conflict ( pTab -> db ) ) { case SQLITE_IGNORE : { goto zipfile_update_done ; } case SQLITE_REPLACE : { pOld2 = p ; break ; } default : { zipfileTableErr ( pTab , \"duplicate<S2SV_blank>name:<S2SV_blank>\\\\\"%s\\\\\"\" , zPath ) ; rc = SQLITE_CONSTRAINT ; break ; } } break ; } } } if ( rc == SQLITE_OK ) { pNew = zipfileNewEntry ( zPath ) ; if ( pNew == 0 ) { rc = SQLITE_NOMEM ; } else { pNew -> cds . iVersionMadeBy = ZIPFILE_NEWENTRY_MADEBY ; pNew -> cds . iVersionExtract = ZIPFILE_NEWENTRY_REQUIRED ; pNew -> cds . flags = ZIPFILE_NEWENTRY_FLAGS ; pNew -> cds . iCompression = ( u16 ) iMethod ; zipfileMtimeToDos ( & pNew -> cds , mTime ) ; pNew -> cds . crc32 = iCrc32 ; pNew -> cds . szCompressed = nData ; pNew -> cds . szUncompressed = ( u32 ) sz ; pNew -> cds . iExternalAttr = ( mode << 16 ) ; pNew -> cds . iOffset = ( u32 ) pTab -> szCurrent ; pNew -> cds . nFile = ( u16 ) nPath ; pNew -> mUnixTime = ( u32 ) mTime ; rc = zipfileAppendEntry ( pTab , pNew , pData , nData ) ; zipfileAddEntry ( pTab , pOld , pNew ) ; } } } if ( rc == SQLITE_OK && ( pOld || pOld2 ) ) { ZipfileCsr * pCsr ; for ( pCsr = pTab -> pCsrList ; pCsr ; pCsr = pCsr -> pCsrNext ) { if ( pCsr -> pCurrent && ( pCsr -> pCurrent == pOld || pCsr -> pCurrent == pOld2 ) ) { pCsr -> pCurrent = pCsr -> pCurrent -> pNext ; pCsr -> bNoop = 1 ; } } zipfileRemoveEntryFromList ( pTab , pOld ) ; zipfileRemoveEntryFromList ( pTab , pOld2 ) ; } zipfile_update_done : sqlite3_free ( pFree ) ; sqlite3_free ( zFree ) ; return rc ; }\n","target":"<S2SV_ModStart> zFree ; nPath = ( int ) strlen ( zPath ) <S2SV_ModEnd> ; } }\n","project_and_commit_id":"sqlite@sqlite/d8f2d46cbc9925e034a68aaaf60aad788d9373c1","cve_id":"CVE-2019-19959","original_address":"https://github.com/sqlite/sqlite/commit/d8f2d46cbc9925e034a68aaaf60aad788d9373c1","time":"2020-01-03T22:15Z"},
	{"Unnamed: 0":81,"cwe_id":"CWE-119","source":"CWE-119 static int nl80211_start_sched_scan ( struct sk_buff * skb , struct genl_info * info ) { struct cfg80211_sched_scan_request * request ; struct cfg80211_registered_device * rdev = info -> user_ptr [ 0 ] ; struct net_device * dev = info -> user_ptr [ 1 ] ; struct nlattr * attr ; struct wiphy * wiphy ; int err , tmp , n_ssids = 0 , n_channels , i ; u32 interval ; enum ieee80211_band band ; size_t ie_len ; if ( ! ( rdev -> wiphy . flags & WIPHY_FLAG_SUPPORTS_SCHED_SCAN ) || ! rdev -> ops -> sched_scan_start ) return - EOPNOTSUPP ; if ( ! is_valid_ie_attr ( info -> attrs [ NL80211_ATTR_IE ] ) ) return - EINVAL ; if ( rdev -> sched_scan_req ) return - EINPROGRESS ; if ( ! info -> attrs [ NL80211_ATTR_SCHED_SCAN_INTERVAL ] ) return - EINVAL ; interval = nla_get_u32 ( info -> attrs [ NL80211_ATTR_SCHED_SCAN_INTERVAL ] ) ; if ( interval == 0 ) return - EINVAL ; wiphy = & rdev -> wiphy ; if ( info -> attrs [ NL80211_ATTR_SCAN_FREQUENCIES ] ) { n_channels = validate_scan_freqs ( info -> attrs [ NL80211_ATTR_SCAN_FREQUENCIES ] ) ; if ( ! n_channels ) return - EINVAL ; } else { n_channels = 0 ; for ( band = 0 ; band < IEEE80211_NUM_BANDS ; band ++ ) if ( wiphy -> bands [ band ] ) n_channels += wiphy -> bands [ band ] -> n_channels ; } if ( info -> attrs [ NL80211_ATTR_SCAN_SSIDS ] ) nla_for_each_nested ( attr , info -> attrs [ NL80211_ATTR_SCAN_SSIDS ] , tmp ) n_ssids ++ ; if ( n_ssids > wiphy -> max_scan_ssids ) return - EINVAL ; if ( info -> attrs [ NL80211_ATTR_IE ] ) ie_len = nla_len ( info -> attrs [ NL80211_ATTR_IE ] ) ; else ie_len = 0 ; if ( ie_len > wiphy -> max_scan_ie_len ) return - EINVAL ; request = kzalloc ( sizeof ( * request ) + sizeof ( * request -> ssids ) * n_ssids + sizeof ( * request -> channels ) * n_channels + ie_len , GFP_KERNEL ) ; if ( ! request ) return - ENOMEM ; if ( n_ssids ) request -> ssids = ( void * ) & request -> channels [ n_channels ] ; request -> n_ssids = n_ssids ; if ( ie_len ) { if ( request -> ssids ) request -> ie = ( void * ) ( request -> ssids + n_ssids ) ; else request -> ie = ( void * ) ( request -> channels + n_channels ) ; } i = 0 ; if ( info -> attrs [ NL80211_ATTR_SCAN_FREQUENCIES ] ) { nla_for_each_nested ( attr , info -> attrs [ NL80211_ATTR_SCAN_FREQUENCIES ] , tmp ) { struct ieee80211_channel * chan ; chan = ieee80211_get_channel ( wiphy , nla_get_u32 ( attr ) ) ; if ( ! chan ) { err = - EINVAL ; goto out_free ; } if ( chan -> flags & IEEE80211_CHAN_DISABLED ) continue ; request -> channels [ i ] = chan ; i ++ ; } } else { for ( band = 0 ; band < IEEE80211_NUM_BANDS ; band ++ ) { int j ; if ( ! wiphy -> bands [ band ] ) continue ; for ( j = 0 ; j < wiphy -> bands [ band ] -> n_channels ; j ++ ) { struct ieee80211_channel * chan ; chan = & wiphy -> bands [ band ] -> channels [ j ] ; if ( chan -> flags & IEEE80211_CHAN_DISABLED ) continue ; request -> channels [ i ] = chan ; i ++ ; } } } if ( ! i ) { err = - EINVAL ; goto out_free ; } request -> n_channels = i ; i = 0 ; if ( info -> attrs [ NL80211_ATTR_SCAN_SSIDS ] ) { nla_for_each_nested ( attr , info -> attrs [ NL80211_ATTR_SCAN_SSIDS ] , tmp ) { <S2SV_StartBug> if ( request -> ssids [ i ] . ssid_len > <S2SV_EndBug> IEEE80211_MAX_SSID_LEN ) { err = - EINVAL ; goto out_free ; } memcpy ( request -> ssids [ i ] . ssid , nla_data ( attr ) , nla_len ( attr ) ) ; <S2SV_StartBug> request -> ssids [ i ] . ssid_len = nla_len ( attr ) ; <S2SV_EndBug> i ++ ; } } if ( info -> attrs [ NL80211_ATTR_IE ] ) { request -> ie_len = nla_len ( info -> attrs [ NL80211_ATTR_IE ] ) ; memcpy ( ( void * ) request -> ie , nla_data ( info -> attrs [ NL80211_ATTR_IE ] ) , request -> ie_len ) ; } request -> dev = dev ; request -> wiphy = & rdev -> wiphy ; request -> interval = interval ; err = rdev -> ops -> sched_scan_start ( & rdev -> wiphy , dev , request ) ; if ( ! err ) { rdev -> sched_scan_req = request ; nl80211_send_sched_scan ( rdev , dev , NL80211_CMD_START_SCHED_SCAN ) ; goto out ; } out_free : kfree ( request ) ; out : return err ; }\n","target":"<S2SV_ModStart> tmp ) { request -> ssids [ i ] . ssid_len = nla_len ( attr ) ; <S2SV_ModStart> ) ) ; <S2SV_ModEnd> i ++ ;\n","project_and_commit_id":"torvalds@linux/208c72f4fe44fe09577e7975ba0e7fa0278f3d03","cve_id":"CVE-2011-2517","original_address":"https://github.com/torvalds/linux/commit/208c72f4fe44fe09577e7975ba0e7fa0278f3d03","time":"2012-05-24T23:55Z"},
	{"Unnamed: 0":6133,"cwe_id":"CWE-476","source":"CWE-476 static int forward_search_range ( regex_t * reg , const UChar * str , const UChar * end , UChar * s , UChar * range , UChar * * low , UChar * * high , UChar * * low_prev ) { UChar * p , * pprev = ( UChar * ) NULL ; # ifdef ONIG_DEBUG_SEARCH fprintf ( stderr , \"forward_search_range:<S2SV_blank>str:<S2SV_blank>%d,<S2SV_blank>end:<S2SV_blank>%d,<S2SV_blank>s:<S2SV_blank>%d,<S2SV_blank>range:<S2SV_blank>%d\\\\n\" , ( int ) str , ( int ) end , ( int ) s , ( int ) range ) ; # endif p = s ; if ( reg -> dmin > 0 ) { if ( ONIGENC_IS_SINGLEBYTE ( reg -> enc ) ) { p += reg -> dmin ; } else { UChar * q = p + reg -> dmin ; if ( q >= end ) return 0 ; while ( p < q ) p += enclen ( reg -> enc , p ) ; } } retry : switch ( reg -> optimize ) { case ONIG_OPTIMIZE_EXACT : p = slow_search ( reg -> enc , reg -> exact , reg -> exact_end , p , end , range ) ; break ; case ONIG_OPTIMIZE_EXACT_IC : p = slow_search_ic ( reg -> enc , reg -> case_fold_flag , reg -> exact , reg -> exact_end , p , end , range ) ; break ; case ONIG_OPTIMIZE_EXACT_BM : p = bm_search ( reg , reg -> exact , reg -> exact_end , p , end , range ) ; break ; case ONIG_OPTIMIZE_EXACT_BM_NOT_REV : p = bm_search_notrev ( reg , reg -> exact , reg -> exact_end , p , end , range ) ; break ; case ONIG_OPTIMIZE_MAP : p = map_search ( reg -> enc , reg -> map , p , range ) ; break ; } if ( p && p < range ) { if ( p - reg -> dmin < s ) { retry_gate : pprev = p ; p += enclen ( reg -> enc , p ) ; goto retry ; } if ( reg -> sub_anchor ) { UChar * prev ; switch ( reg -> sub_anchor ) { case ANCHOR_BEGIN_LINE : if ( ! ON_STR_BEGIN ( p ) ) { prev = onigenc_get_prev_char_head ( reg -> enc , ( pprev ? pprev : str ) , p ) ; if ( ! ONIGENC_IS_MBC_NEWLINE ( reg -> enc , prev , end ) ) goto retry_gate ; } break ; case ANCHOR_END_LINE : if ( ON_STR_END ( p ) ) { # ifndef USE_NEWLINE_AT_END_OF_STRING_HAS_EMPTY_LINE prev = ( UChar * ) onigenc_get_prev_char_head ( reg -> enc , ( pprev ? pprev : str ) , p ) ; if ( prev && ONIGENC_IS_MBC_NEWLINE ( reg -> enc , prev , end ) ) goto retry_gate ; # endif } else if ( ! ONIGENC_IS_MBC_NEWLINE ( reg -> enc , p , end ) # ifdef USE_CRNL_AS_LINE_TERMINATOR && ! ONIGENC_IS_MBC_CRNL ( reg -> enc , p , end ) # endif ) goto retry_gate ; break ; } } if ( reg -> dmax == 0 ) { * low = p ; if ( low_prev ) { if ( * low > s ) * low_prev = onigenc_get_prev_char_head ( reg -> enc , s , p ) ; else * low_prev = onigenc_get_prev_char_head ( reg -> enc , ( pprev ? pprev : str ) , p ) ; } } else { if ( reg -> dmax != ONIG_INFINITE_DISTANCE ) { <S2SV_StartBug> * low = p - reg -> dmax ; <S2SV_EndBug> if ( * low > s ) { * low = onigenc_get_right_adjust_char_head_with_prev ( reg -> enc , s , * low , ( const UChar * * ) low_prev ) ; if ( low_prev && IS_NULL ( * low_prev ) ) * low_prev = onigenc_get_prev_char_head ( reg -> enc , ( pprev ? pprev : s ) , * low ) ; } else { if ( low_prev ) * low_prev = onigenc_get_prev_char_head ( reg -> enc , <S2SV_StartBug> ( pprev ? pprev : str ) , * low ) ; <S2SV_EndBug> } } } * high = p - reg -> dmin ; # ifdef ONIG_DEBUG_SEARCH fprintf ( stderr , \"forward_search_range<S2SV_blank>success:<S2SV_blank>low:<S2SV_blank>%d,<S2SV_blank>high:<S2SV_blank>%d,<S2SV_blank>dmin:<S2SV_blank>%d,<S2SV_blank>dmax:<S2SV_blank>%d\\\\n\" , ( int ) ( * low - str ) , ( int ) ( * high - str ) , reg -> dmin , reg -> dmax ) ; # endif return 1 ; } return 0 ; }\n","target":"<S2SV_ModStart> ONIG_INFINITE_DISTANCE ) { if ( p - str < reg -> dmax ) { * low = ( UChar * ) str ; if ( low_prev ) * low_prev = onigenc_get_prev_char_head ( reg -> enc , str , * low ) ; } else { <S2SV_ModStart> low ) ; }\n","project_and_commit_id":"kkos@oniguruma/b690371bbf97794b4a1d3f295d4fb9a8b05d402d","cve_id":"CVE-2017-9229","original_address":"https://github.com/kkos/oniguruma/commit/b690371bbf97794b4a1d3f295d4fb9a8b05d402d","time":"2017-05-24T15:29Z"},
	{"Unnamed: 0":4528,"cwe_id":"CWE-399","source":"CWE-399 <S2SV_StartBug> void unix_notinflight ( struct file * fp ) <S2SV_EndBug> { struct sock * s = unix_get_socket ( fp ) ; spin_lock ( & unix_gc_lock ) ; if ( s ) { struct unix_sock * u = unix_sk ( s ) ; BUG_ON ( list_empty ( & u -> link ) ) ; if ( atomic_long_dec_and_test ( & u -> inflight ) ) list_del_init ( & u -> link ) ; unix_tot_inflight -- ; } <S2SV_StartBug> fp -> f_cred -> user -> unix_inflight -- ; <S2SV_EndBug> spin_unlock ( & unix_gc_lock ) ; }\n","target":"<S2SV_ModStart> void unix_notinflight ( struct user_struct * user , <S2SV_ModStart> -- ; } <S2SV_ModEnd> user -> unix_inflight\n","project_and_commit_id":"torvalds@linux/415e3d3e90ce9e18727e8843ae343eda5a58fad6","cve_id":"CVE-2016-2550","original_address":"https://github.com/torvalds/linux/commit/415e3d3e90ce9e18727e8843ae343eda5a58fad6","time":"2016-04-27T17:59Z"},
	{"Unnamed: 0":676,"cwe_id":"CWE-119","source":"CWE-119 static void zz_motion_search ( VP8_COMP * cpi , MACROBLOCK * x , YV12_BUFFER_CONFIG * raw_buffer , int * raw_motion_err , YV12_BUFFER_CONFIG * recon_buffer , int * best_motion_err , int recon_yoffset ) { MACROBLOCKD * const xd = & x -> e_mbd ; BLOCK * b = & x -> block [ 0 ] ; BLOCKD * d = & x -> e_mbd . block [ 0 ] ; unsigned char * src_ptr = ( * ( b -> base_src ) + b -> src ) ; int src_stride = b -> src_stride ; unsigned char * raw_ptr ; int raw_stride = raw_buffer -> y_stride ; unsigned char * ref_ptr ; int ref_stride = x -> e_mbd . pre . y_stride ; <S2SV_StartBug> raw_ptr = ( unsigned char * ) ( raw_buffer -> y_buffer + recon_yoffset <S2SV_EndBug> + d -> offset ) ; <S2SV_StartBug> vp8_mse16x16 ( src_ptr , src_stride , raw_ptr , raw_stride , <S2SV_EndBug> ( unsigned int * ) ( raw_motion_err ) ) ; xd -> pre . y_buffer = recon_buffer -> y_buffer + recon_yoffset ; ref_ptr = ( unsigned char * ) ( xd -> pre . y_buffer + d -> offset ) ; <S2SV_StartBug> vp8_mse16x16 ( src_ptr , src_stride , ref_ptr , ref_stride , <S2SV_EndBug> ( unsigned int * ) ( best_motion_err ) ) ; }\n","target":"<S2SV_ModStart> . y_stride ; ( void ) cpi ; <S2SV_ModStart> offset ) ; vpx_mse16x16 <S2SV_ModEnd> ( src_ptr , <S2SV_ModStart> offset ) ; vpx_mse16x16 <S2SV_ModEnd> ( src_ptr ,\n","project_and_commit_id":"external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426","cve_id":"CVE-2016-1621","original_address":"https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426","time":"2016-03-12T21:59Z"},
	{"Unnamed: 0":1846,"cwe_id":"CWE-119","source":"CWE-119 void vp9_restore_layer_context ( VP9_COMP * const cpi ) { <S2SV_StartBug> LAYER_CONTEXT * const lc = get_layer_context ( & cpi -> svc ) ; <S2SV_EndBug> const int old_frame_since_key = cpi -> rc . frames_since_key ; const int old_frame_to_key = cpi -> rc . frames_to_key ; cpi -> rc = lc -> rc ; cpi -> twopass = lc -> twopass ; cpi -> oxcf . target_bandwidth = lc -> target_bandwidth ; <S2SV_StartBug> cpi -> oxcf . starting_buffer_level = lc -> starting_buffer_level ; <S2SV_EndBug> cpi -> oxcf . optimal_buffer_level = lc -> optimal_buffer_level ; cpi -> oxcf . maximum_buffer_size = lc -> maximum_buffer_size ; cpi -> output_framerate = lc -> framerate ; if ( cpi -> svc . number_temporal_layers > 1 ) { cpi -> rc . frames_since_key = old_frame_since_key ; cpi -> rc . frames_to_key = old_frame_to_key ; } }\n","target":"<S2SV_ModStart> = get_layer_context ( cpi <S2SV_ModEnd> ) ; const <S2SV_ModStart> ; cpi -> alt_ref_source <S2SV_ModEnd> = lc -> <S2SV_ModStart> = lc -> alt_ref_source <S2SV_ModEnd> ; if (\n","project_and_commit_id":"external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426","cve_id":"CVE-2016-1621","original_address":"https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426","time":"2016-03-12T21:59Z"},
	{"Unnamed: 0":3013,"cwe_id":"CWE-284","source":"CWE-284 static int a2dp_command ( struct a2dp_stream_common * common , char cmd ) { char ack ; DEBUG ( \"A2DP<S2SV_blank>COMMAND<S2SV_blank>%s\" , dump_a2dp_ctrl_event ( cmd ) ) ; <S2SV_StartBug> if ( send ( common -> ctrl_fd , & cmd , 1 , MSG_NOSIGNAL ) == - 1 ) <S2SV_EndBug> { ERROR ( \"cmd<S2SV_blank>failed<S2SV_blank>(%s)\" , strerror ( errno ) ) ; skt_disconnect ( common -> ctrl_fd ) ; common -> ctrl_fd = AUDIO_SKT_DISCONNECTED ; return - 1 ; } if ( a2dp_ctrl_receive ( common , & ack , 1 ) < 0 ) return - 1 ; DEBUG ( \"A2DP<S2SV_blank>COMMAND<S2SV_blank>%s<S2SV_blank>DONE<S2SV_blank>STATUS<S2SV_blank>%d\" , dump_a2dp_ctrl_event ( cmd ) , ack ) ; if ( ack == A2DP_CTRL_ACK_INCALL_FAILURE ) return ack ; if ( ack != A2DP_CTRL_ACK_SUCCESS ) return - 1 ; return 0 ; }\n","target":"<S2SV_ModStart> ; if ( TEMP_FAILURE_RETRY ( <S2SV_ModStart> 1 , MSG_NOSIGNAL )\n","project_and_commit_id":"system@bt/472271b153c5dc53c28beac55480a8d8434b2d5c","cve_id":"CVE-2016-3839","original_address":"https://android.googlesource.com/platform/system/bt/+/472271b153c5dc53c28beac55480a8d8434b2d5c","time":"2016-08-05T20:59Z"},
	{"Unnamed: 0":3495,"cwe_id":"CWE-000","source":"CWE-000 static int orinoco_ioctl_set_auth ( struct net_device * dev , struct iw_request_info * info , union iwreq_data * wrqu , char * extra ) { struct orinoco_private * priv = ndev_priv ( dev ) ; hermes_t * hw = & priv -> hw ; struct iw_param * param = & wrqu -> param ; unsigned long flags ; int ret = - EINPROGRESS ; if ( orinoco_lock ( priv , & flags ) != 0 ) return - EBUSY ; switch ( param -> flags & IW_AUTH_INDEX ) { case IW_AUTH_WPA_VERSION : case IW_AUTH_CIPHER_PAIRWISE : case IW_AUTH_CIPHER_GROUP : case IW_AUTH_RX_UNENCRYPTED_EAPOL : case IW_AUTH_PRIVACY_INVOKED : case IW_AUTH_DROP_UNENCRYPTED : break ; case IW_AUTH_KEY_MGMT : priv -> key_mgmt = param -> value ; break ; case IW_AUTH_TKIP_COUNTERMEASURES : if ( param -> value ) { priv -> tkip_cm_active = 1 ; <S2SV_StartBug> ret = hermes_enable_port ( hw , 0 ) ; <S2SV_EndBug> } else { priv -> tkip_cm_active = 0 ; ret = hermes_disable_port ( hw , 0 ) ; } break ; case IW_AUTH_80211_AUTH_ALG : if ( param -> value & IW_AUTH_ALG_SHARED_KEY ) priv -> wep_restrict = 1 ; else if ( param -> value & IW_AUTH_ALG_OPEN_SYSTEM ) priv -> wep_restrict = 0 ; else ret = - EINVAL ; break ; case IW_AUTH_WPA_ENABLED : if ( priv -> has_wpa ) { priv -> wpa_enabled = param -> value ? 1 : 0 ; } else { if ( param -> value ) ret = - EOPNOTSUPP ; priv -> wpa_enabled = 0 ; } break ; default : ret = - EOPNOTSUPP ; } orinoco_unlock ( priv , & flags ) ; return ret ; }\n","target":"<S2SV_ModStart> ; ret = hermes_disable_port ( hw , 0 ) ; } else { priv -> tkip_cm_active = 0 ; ret = hermes_enable_port <S2SV_ModEnd> ( hw ,\n","project_and_commit_id":"torvalds@linux/0a54917c3fc295cb61f3fb52373c173fd3b69f48","cve_id":"CVE-2010-4648","original_address":"https://github.com/torvalds/linux/commit/0a54917c3fc295cb61f3fb52373c173fd3b69f48","time":"2012-06-21T23:55Z"},
	{"Unnamed: 0":197,"cwe_id":"CWE-125","source":"CWE-125 static int snd_usb_create_streams ( struct snd_usb_audio * chip , int ctrlif ) { struct usb_device * dev = chip -> dev ; struct usb_host_interface * host_iface ; struct usb_interface_descriptor * altsd ; void * control_header ; <S2SV_StartBug> int i , protocol ; <S2SV_EndBug> host_iface = & usb_ifnum_to_if ( dev , ctrlif ) -> altsetting [ 0 ] ; control_header = snd_usb_find_csint_desc ( host_iface -> extra , host_iface -> extralen , NULL , UAC_HEADER ) ; altsd = get_iface_desc ( host_iface ) ; protocol = altsd -> bInterfaceProtocol ; if ( ! control_header ) { dev_err ( & dev -> dev , \"cannot<S2SV_blank>find<S2SV_blank>UAC_HEADER\\\\n\" ) ; return - EINVAL ; } <S2SV_StartBug> switch ( protocol ) { <S2SV_EndBug> default : dev_warn ( & dev -> dev , \"unknown<S2SV_blank>interface<S2SV_blank>protocol<S2SV_blank>%#02x,<S2SV_blank>assuming<S2SV_blank>v1\\\\n\" , protocol ) ; case UAC_VERSION_1 : { struct uac1_ac_header_descriptor * h1 = control_header ; <S2SV_StartBug> if ( ! h1 -> bInCollection ) { <S2SV_EndBug> <S2SV_StartBug> dev_info ( & dev -> dev , \"skipping<S2SV_blank>empty<S2SV_blank>audio<S2SV_blank>interface<S2SV_blank>(v1)\\\\n\" ) ; <S2SV_EndBug> return - EINVAL ; } if ( h1 -> bLength < sizeof ( * h1 ) + h1 -> bInCollection ) { dev_err ( & dev -> dev , \"invalid<S2SV_blank>UAC_HEADER<S2SV_blank>(v1)\\\\n\" ) ; return - EINVAL ; } for ( i = 0 ; i < h1 -> bInCollection ; i ++ ) snd_usb_create_stream ( chip , ctrlif , h1 -> baInterfaceNr [ i ] ) ; break ; } case UAC_VERSION_2 : { struct usb_interface_assoc_descriptor * assoc = usb_ifnum_to_if ( dev , ctrlif ) -> intf_assoc ; if ( ! assoc ) { struct usb_interface * iface = usb_ifnum_to_if ( dev , ctrlif + 1 ) ; if ( iface && iface -> intf_assoc && iface -> intf_assoc -> bFunctionClass == USB_CLASS_AUDIO && iface -> intf_assoc -> bFunctionProtocol == UAC_VERSION_2 ) assoc = iface -> intf_assoc ; } if ( ! assoc ) { dev_err ( & dev -> dev , \"Audio<S2SV_blank>class<S2SV_blank>v2<S2SV_blank>interfaces<S2SV_blank>need<S2SV_blank>an<S2SV_blank>interface<S2SV_blank>association\\\\n\" ) ; return - EINVAL ; } for ( i = 0 ; i < assoc -> bInterfaceCount ; i ++ ) { int intf = assoc -> bFirstInterface + i ; if ( intf != ctrlif ) snd_usb_create_stream ( chip , ctrlif , intf ) ; } break ; } } return 0 ; }\n","target":"<S2SV_ModStart> i , protocol ; int rest_bytes <S2SV_ModStart> EINVAL ; } rest_bytes = ( void * ) ( host_iface -> extra + host_iface -> extralen ) - control_header ; if ( rest_bytes <= 0 ) { dev_err ( & dev -> dev , \"invalid<S2SV_blank>control<S2SV_blank>header\\\\n\" ) ; return - EINVAL ; } <S2SV_ModStart> ; if ( rest_bytes < sizeof ( * h1 ) ) { dev_err ( & dev -> dev , \"too<S2SV_blank>short<S2SV_blank>v1<S2SV_blank>buffer<S2SV_blank>descriptor\\\\n\" ) ; return - EINVAL ; } if ( <S2SV_ModStart> dev , \"skipping<S2SV_blank>empty<S2SV_blank>audio<S2SV_blank>interface<S2SV_blank>(v1)\\\\n\" ) ; return - EINVAL ; } if ( rest_bytes < h1 -> bLength ) { dev_err ( & dev -> dev , \"invalid<S2SV_blank>buffer<S2SV_blank>length<S2SV_blank>(v1)\\\\n\"\n","project_and_commit_id":"torvalds@linux/bfc81a8bc18e3c4ba0cbaa7666ff76be2f998991","cve_id":"CVE-2017-16529","original_address":"https://github.com/torvalds/linux/commit/bfc81a8bc18e3c4ba0cbaa7666ff76be2f998991","time":"2017-11-04T01:29Z"},
	{"Unnamed: 0":2033,"cwe_id":"CWE-20","source":"CWE-20 static void __iov_iter_advance_iov ( struct iov_iter * i , size_t bytes ) { if ( likely ( i -> nr_segs == 1 ) ) { i -> iov_offset += bytes ; } else { const struct iovec * iov = i -> iov ; size_t base = i -> iov_offset ; <S2SV_StartBug> while ( bytes ) { <S2SV_EndBug> int copy = min ( bytes , iov -> iov_len - base ) ; bytes -= copy ; base += copy ; if ( iov -> iov_len == base ) { iov ++ ; base = 0 ; } } i -> iov = iov ; i -> iov_offset = base ; } }\n","target":"<S2SV_ModStart> while ( bytes || ! iov -> iov_len\n","project_and_commit_id":"torvalds@linux/124d3b7041f9a0ca7c43a6293e1cae4576c32fd5","cve_id":"CVE-2008-7316","original_address":"https://github.com/torvalds/linux/commit/124d3b7041f9a0ca7c43a6293e1cae4576c32fd5","time":"2016-05-02T10:59Z"},
	{"Unnamed: 0":4269,"cwe_id":"CWE-476","source":"CWE-476 static int f2fs_read_single_page ( struct inode * inode , struct page * page , unsigned nr_pages , struct f2fs_map_blocks * map , struct bio * * bio_ret , sector_t * last_block_in_bio , bool is_readahead ) { struct bio * bio = * bio_ret ; const unsigned blkbits = inode -> i_blkbits ; const unsigned blocksize = 1 << blkbits ; sector_t block_in_file ; sector_t last_block ; sector_t last_block_in_file ; sector_t block_nr ; int ret = 0 ; <S2SV_StartBug> block_in_file = ( sector_t ) page -> index ; <S2SV_EndBug> last_block = block_in_file + nr_pages ; last_block_in_file = ( i_size_read ( inode ) + blocksize - 1 ) >> blkbits ; if ( last_block > last_block_in_file ) last_block = last_block_in_file ; if ( block_in_file >= last_block ) goto zero_out ; if ( ( map -> m_flags & F2FS_MAP_MAPPED ) && block_in_file > map -> m_lblk && block_in_file < ( map -> m_lblk + map -> m_len ) ) goto got_it ; map -> m_lblk = block_in_file ; map -> m_len = last_block - block_in_file ; ret = f2fs_map_blocks ( inode , map , 0 , F2FS_GET_BLOCK_DEFAULT ) ; if ( ret ) goto out ; got_it : if ( ( map -> m_flags & F2FS_MAP_MAPPED ) ) { block_nr = map -> m_pblk + block_in_file - map -> m_lblk ; SetPageMappedToDisk ( page ) ; <S2SV_StartBug> if ( ! PageUptodate ( page ) && ! cleancache_get_page ( page ) ) { <S2SV_EndBug> SetPageUptodate ( page ) ; goto confused ; } if ( ! f2fs_is_valid_blkaddr ( F2FS_I_SB ( inode ) , block_nr , DATA_GENERIC_ENHANCE_READ ) ) { ret = - EFSCORRUPTED ; goto out ; } } else { zero_out : zero_user_segment ( page , 0 , PAGE_SIZE ) ; if ( ! PageUptodate ( page ) ) SetPageUptodate ( page ) ; unlock_page ( page ) ; goto out ; } if ( bio && ( * last_block_in_bio != block_nr - 1 || ! __same_bdev ( F2FS_I_SB ( inode ) , block_nr , bio ) ) ) { submit_and_realloc : __submit_bio ( F2FS_I_SB ( inode ) , bio , DATA ) ; bio = NULL ; } if ( bio == NULL ) { bio = f2fs_grab_read_bio ( inode , block_nr , nr_pages , is_readahead ? REQ_RAHEAD : 0 ) ; if ( IS_ERR ( bio ) ) { ret = PTR_ERR ( bio ) ; bio = NULL ; goto out ; } } f2fs_wait_on_block_writeback ( inode , block_nr ) ; if ( bio_add_page ( bio , page , blocksize , 0 ) < blocksize ) goto submit_and_realloc ; inc_page_count ( F2FS_I_SB ( inode ) , F2FS_RD_DATA ) ; ClearPageError ( page ) ; * last_block_in_bio = block_nr ; goto out ; confused : if ( bio ) { __submit_bio ( F2FS_I_SB ( inode ) , bio , DATA ) ; bio = NULL ; } unlock_page ( page ) ; out : * bio_ret = bio ; return ret ; }\n","target":"<S2SV_ModStart> ( sector_t ) page_index ( page ) <S2SV_ModEnd> ; last_block = <S2SV_ModStart> page ) && ( ! PageSwapCache ( page ) && <S2SV_ModStart> cleancache_get_page ( page )\n","project_and_commit_id":"torvalds@linux/4969c06a0d83c9c3dc50b8efcdc8eeedfce896f6","cve_id":"CVE-2019-19815","original_address":"https://github.com/torvalds/linux/commit/4969c06a0d83c9c3dc50b8efcdc8eeedfce896f6","time":"2019-12-17T07:15Z"},
	{"Unnamed: 0":2229,"cwe_id":"CWE-362","source":"CWE-362 static void lo_release ( struct gendisk * disk , fmode_t mode ) { <S2SV_StartBug> struct loop_device * lo = disk -> private_data ; <S2SV_EndBug> int err ; if ( atomic_dec_return ( & lo -> lo_refcnt ) ) return ; mutex_lock ( & lo -> lo_ctl_mutex ) ; if ( lo -> lo_flags & LO_FLAGS_AUTOCLEAR ) { err = loop_clr_fd ( lo ) ; if ( ! err ) return ; } else if ( lo -> lo_state == Lo_bound ) { blk_mq_freeze_queue ( lo -> lo_queue ) ; blk_mq_unfreeze_queue ( lo -> lo_queue ) ; } <S2SV_StartBug> mutex_unlock ( & lo -> lo_ctl_mutex ) ; <S2SV_EndBug> }\n","target":"<S2SV_ModStart> mode ) { mutex_lock ( & loop_index_mutex ) ; __lo_release ( <S2SV_ModEnd> disk -> private_data <S2SV_ModStart> disk -> private_data ) ; <S2SV_ModEnd> mutex_unlock ( & <S2SV_ModStart> mutex_unlock ( & loop_index_mutex <S2SV_ModEnd> ) ; }\n","project_and_commit_id":"torvalds@linux/ae6650163c66a7eff1acd6eb8b0f752dcfa8eba5","cve_id":"CVE-2018-5344","original_address":"https://github.com/torvalds/linux/commit/ae6650163c66a7eff1acd6eb8b0f752dcfa8eba5","time":"2018-01-12T09:29Z"},
	{"Unnamed: 0":1908,"cwe_id":"CWE-20","source":"CWE-20 static int rose_parse_national ( unsigned char * p , struct rose_facilities_struct * facilities , int len ) { unsigned char * pt ; unsigned char l , lg , n = 0 ; int fac_national_digis_received = 0 ; do { switch ( * p & 0xC0 ) { case 0x00 : <S2SV_StartBug> p += 2 ; <S2SV_EndBug> n += 2 ; len -= 2 ; break ; case 0x40 : <S2SV_StartBug> if ( * p == FAC_NATIONAL_RAND ) <S2SV_EndBug> facilities -> rand = ( ( p [ 1 ] << 8 ) & 0xFF00 ) + ( ( p [ 2 ] << 0 ) & 0x00FF ) ; p += 3 ; n += 3 ; len -= 3 ; break ; case 0x80 : <S2SV_StartBug> p += 4 ; <S2SV_EndBug> n += 4 ; len -= 4 ; break ; case 0xC0 : <S2SV_StartBug> l = p [ 1 ] ; <S2SV_EndBug> if ( * p == FAC_NATIONAL_DEST_DIGI ) { if ( ! fac_national_digis_received ) { <S2SV_StartBug> memcpy ( & facilities -> source_digis [ 0 ] , p + 2 , AX25_ADDR_LEN ) ; <S2SV_EndBug> facilities -> source_ndigis = 1 ; } } else if ( * p == FAC_NATIONAL_SRC_DIGI ) { if ( ! fac_national_digis_received ) { <S2SV_StartBug> memcpy ( & facilities -> dest_digis [ 0 ] , p + 2 , AX25_ADDR_LEN ) ; <S2SV_EndBug> facilities -> dest_ndigis = 1 ; } } else if ( * p == FAC_NATIONAL_FAIL_CALL ) { <S2SV_StartBug> memcpy ( & facilities -> fail_call , p + 2 , AX25_ADDR_LEN ) ; <S2SV_EndBug> } else if ( * p == FAC_NATIONAL_FAIL_ADD ) { <S2SV_StartBug> memcpy ( & facilities -> fail_addr , p + 3 , ROSE_ADDR_LEN ) ; <S2SV_EndBug> } <S2SV_StartBug> else if ( * p == FAC_NATIONAL_DIGIS ) { <S2SV_EndBug> fac_national_digis_received = 1 ; facilities -> source_ndigis = 0 ; facilities -> dest_ndigis = 0 ; for ( pt = p + 2 , lg = 0 ; lg < l ; pt += AX25_ADDR_LEN , lg += AX25_ADDR_LEN ) { if ( pt [ 6 ] & AX25_HBIT ) { if ( facilities -> dest_ndigis >= ROSE_MAX_DIGIS ) return - 1 ; memcpy ( & facilities -> dest_digis [ facilities -> dest_ndigis ++ ] , pt , AX25_ADDR_LEN ) ; } else { if ( facilities -> source_ndigis >= ROSE_MAX_DIGIS ) return - 1 ; memcpy ( & facilities -> source_digis [ facilities -> source_ndigis ++ ] , pt , AX25_ADDR_LEN ) ; } } } p += l + 2 ; n += l + 2 ; len -= l + 2 ; break ; } } while ( * p != 0x00 && len > 0 ) ; return n ; }\n","target":"<S2SV_ModStart> case 0x00 : if ( len < 2 ) return - 1 ; <S2SV_ModStart> : if ( len < 3 ) return - 1 ; if ( <S2SV_ModStart> case 0x80 : if ( len < 4 ) return - 1 ; <S2SV_ModStart> case 0xC0 : if ( len < 2 ) return - 1 ; l = p [ 1 ] ; if ( len < 2 + l ) return - 1 <S2SV_ModEnd> ; if ( <S2SV_ModStart> fac_national_digis_received ) { if ( l < AX25_ADDR_LEN ) return - 1 ; <S2SV_ModStart> fac_national_digis_received ) { if ( l < AX25_ADDR_LEN ) return - 1 ; <S2SV_ModStart> FAC_NATIONAL_FAIL_CALL ) { if ( l < AX25_ADDR_LEN ) return - 1 ; <S2SV_ModStart> FAC_NATIONAL_FAIL_ADD ) { if ( l < 1 + ROSE_ADDR_LEN ) return - 1 ; <S2SV_ModStart> FAC_NATIONAL_DIGIS ) { if ( l % AX25_ADDR_LEN ) return - 1 ;\n","project_and_commit_id":"torvalds@linux/e0bccd315db0c2f919e7fcf9cb60db21d9986f52","cve_id":"CVE-2011-4914","original_address":"https://github.com/torvalds/linux/commit/e0bccd315db0c2f919e7fcf9cb60db21d9986f52","time":"2012-06-21T23:55Z"},
	{"Unnamed: 0":5843,"cwe_id":"CWE-399","source":"CWE-399 public int magic_setparam ( struct magic_set * ms , int param , const void * val ) { switch ( param ) { case MAGIC_PARAM_INDIR_MAX : ms -> indir_max = * ( const size_t * ) val ; return 0 ; case MAGIC_PARAM_NAME_MAX : ms -> name_max = * ( const size_t * ) val ; return 0 ; case MAGIC_PARAM_ELF_PHNUM_MAX : ms -> elf_phnum_max = * ( const size_t * ) val ; return 0 ; case MAGIC_PARAM_ELF_SHNUM_MAX : ms -> elf_shnum_max = * ( const size_t * ) val ; return 0 ; <S2SV_StartBug> default : <S2SV_EndBug> errno = EINVAL ; return - 1 ; } }\n","target":"<S2SV_ModStart> return 0 ; case MAGIC_PARAM_ELF_NOTES_MAX : ms -> elf_notes_max = * ( const size_t * ) val ; return 0 ;\n","project_and_commit_id":"file@file/ce90e05774dd77d86cfc8dfa6da57b32816841c4","cve_id":"CVE-2014-9620","original_address":"https://github.com/file/file/commit/ce90e05774dd77d86cfc8dfa6da57b32816841c4","time":"2015-01-21T18:59Z"},
	{"Unnamed: 0":4997,"cwe_id":"CWE-362","source":"CWE-362 static void __xen_evtchn_do_upcall ( void ) { struct vcpu_info * vcpu_info = __this_cpu_read ( xen_vcpu ) ; <S2SV_StartBug> int cpu = smp_processor_id ( ) ; <S2SV_EndBug> do { vcpu_info -> evtchn_upcall_pending = 0 ; xen_evtchn_handle_events ( cpu ) ; BUG_ON ( ! irqs_disabled ( ) ) ; virt_rmb ( ) ; } while ( vcpu_info -> evtchn_upcall_pending ) ; <S2SV_StartBug> } <S2SV_EndBug>\n","target":"<S2SV_ModStart> = smp_processor_id ( ) ; read_lock ( & evtchn_rwlock <S2SV_ModStart> evtchn_upcall_pending ) ; read_unlock ( & evtchn_rwlock ) ;\n","project_and_commit_id":"torvalds@linux/073d0552ead5bfc7a3a9c01de590e924f11b5dd2","cve_id":"CVE-2020-27675","original_address":"https://github.com/torvalds/linux/commit/073d0552ead5bfc7a3a9c01de590e924f11b5dd2","time":"2020-10-22T21:15Z"},
	{"Unnamed: 0":2107,"cwe_id":"CWE-310","source":"CWE-310 static int btrfs_rename ( struct inode * old_dir , struct dentry * old_dentry , struct inode * new_dir , struct dentry * new_dentry ) { struct btrfs_trans_handle * trans ; struct btrfs_root * root = BTRFS_I ( old_dir ) -> root ; struct btrfs_root * dest = BTRFS_I ( new_dir ) -> root ; struct inode * new_inode = new_dentry -> d_inode ; struct inode * old_inode = old_dentry -> d_inode ; struct timespec ctime = CURRENT_TIME ; u64 index = 0 ; u64 root_objectid ; int ret ; u64 old_ino = btrfs_ino ( old_inode ) ; if ( btrfs_ino ( new_dir ) == BTRFS_EMPTY_SUBVOL_DIR_OBJECTID ) return - EPERM ; if ( old_ino != BTRFS_FIRST_FREE_OBJECTID && root != dest ) return - EXDEV ; if ( old_ino == BTRFS_EMPTY_SUBVOL_DIR_OBJECTID || ( new_inode && btrfs_ino ( new_inode ) == BTRFS_FIRST_FREE_OBJECTID ) ) return - ENOTEMPTY ; if ( S_ISDIR ( old_inode -> i_mode ) && new_inode && new_inode -> i_size > BTRFS_EMPTY_DIR_SIZE ) return - ENOTEMPTY ; <S2SV_StartBug> if ( new_inode && S_ISREG ( old_inode -> i_mode ) && new_inode -> i_size && <S2SV_EndBug> old_inode -> i_size > BTRFS_ORDERED_OPERATIONS_FLUSH_LIMIT ) filemap_flush ( old_inode -> i_mapping ) ; if ( old_ino == BTRFS_FIRST_FREE_OBJECTID ) down_read ( & root -> fs_info -> subvol_sem ) ; trans = btrfs_start_transaction ( root , 20 ) ; if ( IS_ERR ( trans ) ) { ret = PTR_ERR ( trans ) ; goto out_notrans ; } if ( dest != root ) btrfs_record_root_in_trans ( trans , dest ) ; ret = btrfs_set_inode_index ( new_dir , & index ) ; if ( ret ) goto out_fail ; if ( unlikely ( old_ino == BTRFS_FIRST_FREE_OBJECTID ) ) { root -> fs_info -> last_trans_log_full_commit = trans -> transid ; } else { ret = btrfs_insert_inode_ref ( trans , dest , new_dentry -> d_name . name , new_dentry -> d_name . len , old_ino , btrfs_ino ( new_dir ) , index ) ; if ( ret ) goto out_fail ; btrfs_pin_log_trans ( root ) ; } if ( new_inode && new_inode -> i_size && S_ISREG ( old_inode -> i_mode ) ) btrfs_add_ordered_operation ( trans , root , old_inode ) ; inode_inc_iversion ( old_dir ) ; inode_inc_iversion ( new_dir ) ; inode_inc_iversion ( old_inode ) ; old_dir -> i_ctime = old_dir -> i_mtime = ctime ; new_dir -> i_ctime = new_dir -> i_mtime = ctime ; old_inode -> i_ctime = ctime ; if ( old_dentry -> d_parent != new_dentry -> d_parent ) btrfs_record_unlink_dir ( trans , old_dir , old_inode , 1 ) ; if ( unlikely ( old_ino == BTRFS_FIRST_FREE_OBJECTID ) ) { root_objectid = BTRFS_I ( old_inode ) -> root -> root_key . objectid ; ret = btrfs_unlink_subvol ( trans , root , old_dir , root_objectid , old_dentry -> d_name . name , old_dentry -> d_name . len ) ; } else { ret = __btrfs_unlink_inode ( trans , root , old_dir , old_dentry -> d_inode , old_dentry -> d_name . name , old_dentry -> d_name . len ) ; if ( ! ret ) ret = btrfs_update_inode ( trans , root , old_inode ) ; } if ( ret ) { btrfs_abort_transaction ( trans , root , ret ) ; goto out_fail ; } if ( new_inode ) { inode_inc_iversion ( new_inode ) ; new_inode -> i_ctime = CURRENT_TIME ; if ( unlikely ( btrfs_ino ( new_inode ) == BTRFS_EMPTY_SUBVOL_DIR_OBJECTID ) ) { root_objectid = BTRFS_I ( new_inode ) -> location . objectid ; ret = btrfs_unlink_subvol ( trans , dest , new_dir , root_objectid , new_dentry -> d_name . name , new_dentry -> d_name . len ) ; BUG_ON ( new_inode -> i_nlink == 0 ) ; } else { ret = btrfs_unlink_inode ( trans , dest , new_dir , new_dentry -> d_inode , new_dentry -> d_name . name , new_dentry -> d_name . len ) ; } if ( ! ret && new_inode -> i_nlink == 0 ) { ret = btrfs_orphan_add ( trans , new_dentry -> d_inode ) ; BUG_ON ( ret ) ; } if ( ret ) { btrfs_abort_transaction ( trans , root , ret ) ; goto out_fail ; } } fixup_inode_flags ( new_dir , old_inode ) ; ret = btrfs_add_link ( trans , new_dir , old_inode , new_dentry -> d_name . name , new_dentry -> d_name . len , 0 , index ) ; if ( ret ) { btrfs_abort_transaction ( trans , root , ret ) ; goto out_fail ; } if ( old_ino != BTRFS_FIRST_FREE_OBJECTID ) { struct dentry * parent = new_dentry -> d_parent ; btrfs_log_new_name ( trans , old_inode , old_dir , parent ) ; btrfs_end_log_trans ( root ) ; } out_fail : btrfs_end_transaction ( trans , root ) ; out_notrans : if ( old_ino == BTRFS_FIRST_FREE_OBJECTID ) up_read ( & root -> fs_info -> subvol_sem ) ; return ret ; }\n","target":"<S2SV_ModStart> - ENOTEMPTY ; ret = btrfs_check_dir_item_collision ( root , new_dir -> i_ino , new_dentry -> d_name . name , new_dentry -> d_name . len ) ; if ( ret ) { if ( ret == - EEXIST ) { if ( ! new_inode ) { WARN_ON ( 1 ) ; return ret ; } } else { return ret ; } } ret = 0 ;\n","project_and_commit_id":"torvalds@linux/9c52057c698fb96f8f07e7a4bcf4801a092bda89","cve_id":"CVE-2012-5375","original_address":"https://github.com/torvalds/linux/commit/9c52057c698fb96f8f07e7a4bcf4801a092bda89","time":"2013-02-18T11:56Z"},
	{"Unnamed: 0":6097,"cwe_id":"CWE-189","source":"CWE-189 static int perf_swevent_init ( struct perf_event * event ) { <S2SV_StartBug> int event_id = event -> attr . config ; <S2SV_EndBug> if ( event -> attr . type != PERF_TYPE_SOFTWARE ) return - ENOENT ; if ( has_branch_stack ( event ) ) return - EOPNOTSUPP ; switch ( event_id ) { case PERF_COUNT_SW_CPU_CLOCK : case PERF_COUNT_SW_TASK_CLOCK : return - ENOENT ; default : break ; } if ( event_id >= PERF_COUNT_SW_MAX ) return - ENOENT ; if ( ! event -> parent ) { int err ; err = swevent_hlist_get ( event ) ; if ( err ) return err ; static_key_slow_inc ( & perf_swevent_enabled [ event_id ] ) ; event -> destroy = sw_perf_event_destroy ; } return 0 ; }\n","target":"<S2SV_ModStart> event ) { u64 <S2SV_ModEnd> event_id = event\n","project_and_commit_id":"torvalds@linux/8176cced706b5e5d15887584150764894e94e02f","cve_id":"CVE-2013-2094","original_address":"https://github.com/torvalds/linux/commit/8176cced706b5e5d15887584150764894e94e02f","time":"2013-05-14T20:55Z"},
	{"Unnamed: 0":2695,"cwe_id":"CWE-787","source":"CWE-787 <S2SV_StartBug> static void nsc_encode_sse2 ( NSC_CONTEXT * context , const BYTE * data , <S2SV_EndBug> UINT32 scanline ) { nsc_encode_argb_to_aycocg_sse2 ( context , data , scanline ) ; if ( context -> ChromaSubsamplingLevel > 0 ) { nsc_encode_subsampling_sse2 ( context ) ; } <S2SV_StartBug> } <S2SV_EndBug>\n","target":"<S2SV_ModStart> <S2SV_null> <S2SV_null> static BOOL <S2SV_ModEnd> nsc_encode_sse2 ( NSC_CONTEXT <S2SV_ModStart> ) ; } return TRUE ;\n","project_and_commit_id":"FreeRDP@FreeRDP/d1112c279bd1a327e8e4d0b5f371458bf2579659","cve_id":"CVE-2018-8788","original_address":"https://github.com/FreeRDP/FreeRDP/commit/d1112c279bd1a327e8e4d0b5f371458bf2579659","time":"2018-11-29T18:29Z"},
	{"Unnamed: 0":2508,"cwe_id":"CWE-264","source":"CWE-264 void perf_event_enable ( struct perf_event * event ) { <S2SV_StartBug> struct perf_event_context * ctx = event -> ctx ; <S2SV_EndBug> struct task_struct * task = ctx -> task ; if ( ! task ) { cpu_function_call ( event -> cpu , __perf_event_enable , event ) ; return ; } raw_spin_lock_irq ( & ctx -> lock ) ; if ( event -> state >= PERF_EVENT_STATE_INACTIVE ) goto out ; if ( event -> state == PERF_EVENT_STATE_ERROR ) event -> state = PERF_EVENT_STATE_OFF ; retry : if ( ! ctx -> is_active ) { __perf_event_mark_enabled ( event ) ; <S2SV_StartBug> goto out ; <S2SV_EndBug> } raw_spin_unlock_irq ( & ctx -> lock ) ; if ( ! task_function_call ( task , __perf_event_enable , event ) ) return ; raw_spin_lock_irq ( & ctx -> lock ) ; if ( ctx -> is_active && event -> state == PERF_EVENT_STATE_OFF ) { task = ctx -> task ; goto retry ; } out : raw_spin_unlock_irq ( & ctx -> lock ) ; }\n","target":"<S2SV_ModStart> perf_event_context * ctx ; ctx = perf_event_ctx_lock <S2SV_ModEnd> ( event ) <S2SV_ModStart> event ) ; _perf_event_enable ( event ) ; perf_event_ctx_unlock ( event , ctx <S2SV_ModEnd> ) ; }\n","project_and_commit_id":"torvalds@linux/f63a8daa5812afef4f06c962351687e1ff9ccb2b","cve_id":"CVE-2016-6787","original_address":"https://github.com/torvalds/linux/commit/f63a8daa5812afef4f06c962351687e1ff9ccb2b","time":"2016-12-28T07:59Z"},
	{"Unnamed: 0":4132,"cwe_id":"CWE-125","source":"CWE-125 static int read_header ( struct archive_read * a , struct archive_entry * entry , char head_type ) { const void * h ; const char * p , * endp ; struct rar * rar ; struct rar_header rar_header ; struct rar_file_header file_header ; int64_t header_size ; unsigned filename_size , end ; char * filename ; char * strp ; char packed_size [ 8 ] ; char unp_size [ 8 ] ; int ttime ; struct archive_string_conv * sconv , * fn_sconv ; unsigned long crc32_val ; int ret = ( ARCHIVE_OK ) , ret2 ; rar = ( struct rar * ) ( a -> format -> data ) ; sconv = rar -> opt_sconv ; if ( sconv == NULL ) { if ( ! rar -> init_default_conversion ) { rar -> sconv_default = archive_string_default_conversion_for_read ( & ( a -> archive ) ) ; rar -> init_default_conversion = 1 ; } sconv = rar -> sconv_default ; } if ( ( h = __archive_read_ahead ( a , 7 , NULL ) ) == NULL ) return ( ARCHIVE_FATAL ) ; p = h ; memcpy ( & rar_header , p , sizeof ( rar_header ) ) ; rar -> file_flags = archive_le16dec ( rar_header . flags ) ; header_size = archive_le16dec ( rar_header . size ) ; if ( header_size < ( int64_t ) sizeof ( file_header ) + 7 ) { archive_set_error ( & a -> archive , ARCHIVE_ERRNO_FILE_FORMAT , \"Invalid<S2SV_blank>header<S2SV_blank>size\" ) ; return ( ARCHIVE_FATAL ) ; } crc32_val = crc32 ( 0 , ( const unsigned char * ) p + 2 , 7 - 2 ) ; __archive_read_consume ( a , 7 ) ; if ( ! ( rar -> file_flags & FHD_SOLID ) ) { rar -> compression_method = 0 ; rar -> packed_size = 0 ; rar -> unp_size = 0 ; rar -> mtime = 0 ; rar -> ctime = 0 ; rar -> atime = 0 ; rar -> arctime = 0 ; rar -> mode = 0 ; memset ( & rar -> salt , 0 , sizeof ( rar -> salt ) ) ; rar -> atime = 0 ; rar -> ansec = 0 ; rar -> ctime = 0 ; rar -> cnsec = 0 ; rar -> mtime = 0 ; rar -> mnsec = 0 ; rar -> arctime = 0 ; rar -> arcnsec = 0 ; } else { archive_set_error ( & a -> archive , ARCHIVE_ERRNO_FILE_FORMAT , \"RAR<S2SV_blank>solid<S2SV_blank>archive<S2SV_blank>support<S2SV_blank>unavailable.\" ) ; return ( ARCHIVE_FATAL ) ; } if ( ( h = __archive_read_ahead ( a , ( size_t ) header_size - 7 , NULL ) ) == NULL ) return ( ARCHIVE_FATAL ) ; crc32_val = crc32 ( crc32_val , h , ( unsigned ) ( header_size - 7 ) ) ; if ( ( crc32_val & 0xffff ) != archive_le16dec ( rar_header . crc ) ) { archive_set_error ( & a -> archive , ARCHIVE_ERRNO_FILE_FORMAT , \"Header<S2SV_blank>CRC<S2SV_blank>error\" ) ; return ( ARCHIVE_FATAL ) ; } p = h ; endp = p + header_size - 7 ; memcpy ( & file_header , p , sizeof ( file_header ) ) ; p += sizeof ( file_header ) ; rar -> compression_method = file_header . method ; ttime = archive_le32dec ( file_header . file_time ) ; rar -> mtime = get_time ( ttime ) ; rar -> file_crc = archive_le32dec ( file_header . file_crc ) ; if ( rar -> file_flags & FHD_PASSWORD ) { archive_entry_set_is_data_encrypted ( entry , 1 ) ; rar -> has_encrypted_entries = 1 ; archive_set_error ( & a -> archive , ARCHIVE_ERRNO_FILE_FORMAT , \"RAR<S2SV_blank>encryption<S2SV_blank>support<S2SV_blank>unavailable.\" ) ; } if ( rar -> file_flags & FHD_LARGE ) { memcpy ( packed_size , file_header . pack_size , 4 ) ; memcpy ( packed_size + 4 , p , 4 ) ; p += 4 ; memcpy ( unp_size , file_header . unp_size , 4 ) ; memcpy ( unp_size + 4 , p , 4 ) ; p += 4 ; rar -> packed_size = archive_le64dec ( & packed_size ) ; rar -> unp_size = archive_le64dec ( & unp_size ) ; } else { rar -> packed_size = archive_le32dec ( file_header . pack_size ) ; rar -> unp_size = archive_le32dec ( file_header . unp_size ) ; } if ( rar -> packed_size < 0 || rar -> unp_size < 0 ) { archive_set_error ( & a -> archive , ARCHIVE_ERRNO_FILE_FORMAT , \"Invalid<S2SV_blank>sizes<S2SV_blank>specified.\" ) ; return ( ARCHIVE_FATAL ) ; } rar -> bytes_remaining = rar -> packed_size ; if ( head_type == NEWSUB_HEAD ) { size_t distance = p - ( const char * ) h ; header_size += rar -> packed_size ; if ( ( h = __archive_read_ahead ( a , ( size_t ) header_size - 7 , NULL ) ) == NULL ) return ( ARCHIVE_FATAL ) ; p = h ; endp = p + header_size - 7 ; p += distance ; } filename_size = archive_le16dec ( file_header . name_size ) ; if ( p + filename_size > endp ) { archive_set_error ( & a -> archive , ARCHIVE_ERRNO_FILE_FORMAT , \"Invalid<S2SV_blank>filename<S2SV_blank>size\" ) ; return ( ARCHIVE_FATAL ) ; } if ( rar -> filename_allocated < filename_size * 2 + 2 ) { char * newptr ; size_t newsize = filename_size * 2 + 2 ; newptr = realloc ( rar -> filename , newsize ) ; if ( newptr == NULL ) { archive_set_error ( & a -> archive , ENOMEM , \"Couldn\\'t<S2SV_blank>allocate<S2SV_blank>memory.\" ) ; return ( ARCHIVE_FATAL ) ; } rar -> filename = newptr ; rar -> filename_allocated = newsize ; } filename = rar -> filename ; memcpy ( filename , p , filename_size ) ; filename [ filename_size ] = '\\\\0' ; if ( rar -> file_flags & FHD_UNICODE ) { if ( filename_size != strlen ( filename ) ) { unsigned char highbyte , flagbits , flagbyte ; unsigned fn_end , offset ; end = filename_size ; fn_end = filename_size * 2 ; filename_size = 0 ; offset = ( unsigned ) strlen ( filename ) + 1 ; highbyte = * ( p + offset ++ ) ; flagbits = 0 ; flagbyte = 0 ; while ( offset < end && filename_size < fn_end ) { if ( ! flagbits ) { flagbyte = * ( p + offset ++ ) ; flagbits = 8 ; } flagbits -= 2 ; switch ( ( flagbyte >> flagbits ) & 3 ) { case 0 : filename [ filename_size ++ ] = '\\\\0' ; filename [ filename_size ++ ] = * ( p + offset ++ ) ; break ; case 1 : filename [ filename_size ++ ] = highbyte ; filename [ filename_size ++ ] = * ( p + offset ++ ) ; break ; case 2 : filename [ filename_size ++ ] = * ( p + offset + 1 ) ; filename [ filename_size ++ ] = * ( p + offset ) ; offset += 2 ; break ; case 3 : { char extra , high ; uint8_t length = * ( p + offset ++ ) ; if ( length & 0x80 ) { extra = * ( p + offset ++ ) ; high = ( char ) highbyte ; } else extra = high = 0 ; length = ( length & 0x7f ) + 2 ; while ( length && filename_size < fn_end ) { unsigned cp = filename_size >> 1 ; filename [ filename_size ++ ] = high ; filename [ filename_size ++ ] = p [ cp ] + extra ; length -- ; } } break ; } } if ( filename_size > fn_end ) { archive_set_error ( & a -> archive , ARCHIVE_ERRNO_FILE_FORMAT , \"Invalid<S2SV_blank>filename\" ) ; return ( ARCHIVE_FATAL ) ; } filename [ filename_size ++ ] = '\\\\0' ; <S2SV_StartBug> filename [ filename_size ++ ] = '\\\\0' ; <S2SV_EndBug> if ( rar -> sconv_utf16be == NULL ) { rar -> sconv_utf16be = archive_string_conversion_from_charset ( & a -> archive , \"UTF-16BE\" , 1 ) ; if ( rar -> sconv_utf16be == NULL ) return ( ARCHIVE_FATAL ) ; } fn_sconv = rar -> sconv_utf16be ; strp = filename ; while ( memcmp ( strp , \"\\\\x00\\\\x00\" , 2 ) ) { if ( ! memcmp ( strp , \"\\\\x00\\\\\\\\\" , 2 ) ) * ( strp + 1 ) = '/' ; strp += 2 ; } p += offset ; } else { if ( rar -> sconv_utf8 == NULL ) { rar -> sconv_utf8 = archive_string_conversion_from_charset ( & a -> archive , \"UTF-8\" , 1 ) ; if ( rar -> sconv_utf8 == NULL ) return ( ARCHIVE_FATAL ) ; } fn_sconv = rar -> sconv_utf8 ; while ( ( strp = strchr ( filename , '\\\\\\\\' ) ) != NULL ) * strp = '/' ; p += filename_size ; } } else { fn_sconv = sconv ; while ( ( strp = strchr ( filename , '\\\\\\\\' ) ) != NULL ) * strp = '/' ; p += filename_size ; } if ( rar -> filename_save && filename_size == rar -> filename_save_size && ! memcmp ( rar -> filename , rar -> filename_save , filename_size + 1 ) ) { __archive_read_consume ( a , header_size - 7 ) ; rar -> cursor ++ ; if ( rar -> cursor >= rar -> nodes ) { rar -> nodes ++ ; if ( ( rar -> dbo = realloc ( rar -> dbo , sizeof ( * rar -> dbo ) * rar -> nodes ) ) == NULL ) { archive_set_error ( & a -> archive , ENOMEM , \"Couldn\\'t<S2SV_blank>allocate<S2SV_blank>memory.\" ) ; return ( ARCHIVE_FATAL ) ; } rar -> dbo [ rar -> cursor ] . header_size = header_size ; rar -> dbo [ rar -> cursor ] . start_offset = - 1 ; rar -> dbo [ rar -> cursor ] . end_offset = - 1 ; } if ( rar -> dbo [ rar -> cursor ] . start_offset < 0 ) { rar -> dbo [ rar -> cursor ] . start_offset = a -> filter -> position ; rar -> dbo [ rar -> cursor ] . end_offset = rar -> dbo [ rar -> cursor ] . start_offset + rar -> packed_size ; } return ret ; } rar -> filename_save = ( char * ) realloc ( rar -> filename_save , filename_size + 1 ) ; memcpy ( rar -> filename_save , rar -> filename , filename_size + 1 ) ; rar -> filename_save_size = filename_size ; free ( rar -> dbo ) ; if ( ( rar -> dbo = calloc ( 1 , sizeof ( * rar -> dbo ) ) ) == NULL ) { archive_set_error ( & a -> archive , ENOMEM , \"Couldn\\'t<S2SV_blank>allocate<S2SV_blank>memory.\" ) ; return ( ARCHIVE_FATAL ) ; } rar -> dbo [ 0 ] . header_size = header_size ; rar -> dbo [ 0 ] . start_offset = - 1 ; rar -> dbo [ 0 ] . end_offset = - 1 ; rar -> cursor = 0 ; rar -> nodes = 1 ; if ( rar -> file_flags & FHD_SALT ) { if ( p + 8 > endp ) { archive_set_error ( & a -> archive , ARCHIVE_ERRNO_FILE_FORMAT , \"Invalid<S2SV_blank>header<S2SV_blank>size\" ) ; return ( ARCHIVE_FATAL ) ; } memcpy ( rar -> salt , p , 8 ) ; p += 8 ; } if ( rar -> file_flags & FHD_EXTTIME ) { if ( read_exttime ( p , rar , endp ) < 0 ) { archive_set_error ( & a -> archive , ARCHIVE_ERRNO_FILE_FORMAT , \"Invalid<S2SV_blank>header<S2SV_blank>size\" ) ; return ( ARCHIVE_FATAL ) ; } } __archive_read_consume ( a , header_size - 7 ) ; rar -> dbo [ 0 ] . start_offset = a -> filter -> position ; rar -> dbo [ 0 ] . end_offset = rar -> dbo [ 0 ] . start_offset + rar -> packed_size ; switch ( file_header . host_os ) { case OS_MSDOS : case OS_OS2 : case OS_WIN32 : rar -> mode = archive_le32dec ( file_header . file_attr ) ; if ( rar -> mode & FILE_ATTRIBUTE_DIRECTORY ) rar -> mode = AE_IFDIR | S_IXUSR | S_IXGRP | S_IXOTH ; else rar -> mode = AE_IFREG ; rar -> mode |= S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH ; break ; case OS_UNIX : case OS_MAC_OS : case OS_BEOS : rar -> mode = archive_le32dec ( file_header . file_attr ) ; break ; default : archive_set_error ( & a -> archive , ARCHIVE_ERRNO_FILE_FORMAT , \"Unknown<S2SV_blank>file<S2SV_blank>attributes<S2SV_blank>from<S2SV_blank>RAR<S2SV_blank>file\\'s<S2SV_blank>host<S2SV_blank>OS\" ) ; return ( ARCHIVE_FATAL ) ; } rar -> bytes_uncopied = rar -> bytes_unconsumed = 0 ; rar -> lzss . position = rar -> offset = 0 ; rar -> offset_seek = 0 ; rar -> dictionary_size = 0 ; rar -> offset_outgoing = 0 ; rar -> br . cache_avail = 0 ; rar -> br . avail_in = 0 ; rar -> crc_calculated = 0 ; rar -> entry_eof = 0 ; rar -> valid = 1 ; rar -> is_ppmd_block = 0 ; rar -> start_new_table = 1 ; free ( rar -> unp_buffer ) ; rar -> unp_buffer = NULL ; rar -> unp_offset = 0 ; rar -> unp_buffer_size = UNP_BUFFER_SIZE ; memset ( rar -> lengthtable , 0 , sizeof ( rar -> lengthtable ) ) ; __archive_ppmd7_functions . Ppmd7_Free ( & rar -> ppmd7_context , & g_szalloc ) ; rar -> ppmd_valid = rar -> ppmd_eod = 0 ; if ( head_type == NEWSUB_HEAD ) return ret ; archive_entry_set_mtime ( entry , rar -> mtime , rar -> mnsec ) ; archive_entry_set_ctime ( entry , rar -> ctime , rar -> cnsec ) ; archive_entry_set_atime ( entry , rar -> atime , rar -> ansec ) ; archive_entry_set_size ( entry , rar -> unp_size ) ; archive_entry_set_mode ( entry , rar -> mode ) ; if ( archive_entry_copy_pathname_l ( entry , filename , filename_size , fn_sconv ) ) { if ( errno == ENOMEM ) { archive_set_error ( & a -> archive , ENOMEM , \"Can\\'t<S2SV_blank>allocate<S2SV_blank>memory<S2SV_blank>for<S2SV_blank>Pathname\" ) ; return ( ARCHIVE_FATAL ) ; } archive_set_error ( & a -> archive , ARCHIVE_ERRNO_FILE_FORMAT , \"Pathname<S2SV_blank>cannot<S2SV_blank>be<S2SV_blank>converted<S2SV_blank>from<S2SV_blank>%s<S2SV_blank>to<S2SV_blank>current<S2SV_blank>locale.\" , archive_string_conversion_charset_name ( fn_sconv ) ) ; ret = ( ARCHIVE_WARN ) ; } if ( ( ( rar -> mode ) & AE_IFMT ) == AE_IFLNK ) { rar -> bytes_remaining = 0 ; archive_entry_set_size ( entry , 0 ) ; if ( ( ret2 = read_symlink_stored ( a , entry , sconv ) ) < ( ARCHIVE_WARN ) ) return ret2 ; if ( ret > ret2 ) ret = ret2 ; } if ( rar -> bytes_remaining == 0 ) rar -> entry_eof = 1 ; return ret ; }\n","target":"<S2SV_ModStart> filename [ filename_size <S2SV_ModEnd> ] = '\\\\0'\n","project_and_commit_id":"libarchive@libarchive/5562545b5562f6d12a4ef991fae158bf4ccf92b6","cve_id":"CVE-2017-14502","original_address":"https://github.com/libarchive/libarchive/commit/5562545b5562f6d12a4ef991fae158bf4ccf92b6","time":"2017-09-17T18:29Z"},
	{"Unnamed: 0":6497,"cwe_id":"CWE-264","source":"CWE-264 static int em_jmp_far ( struct x86_emulate_ctxt * ctxt ) { int rc ; <S2SV_StartBug> unsigned short sel ; <S2SV_EndBug> memcpy ( & sel , ctxt -> src . valptr + ctxt -> op_bytes , 2 ) ; <S2SV_StartBug> rc = load_segment_descriptor ( ctxt , sel , VCPU_SREG_CS ) ; <S2SV_EndBug> if ( rc != X86EMUL_CONTINUE ) return rc ; <S2SV_StartBug> ctxt -> _eip = 0 ; <S2SV_EndBug> <S2SV_StartBug> memcpy ( & ctxt -> _eip , ctxt -> src . valptr , ctxt -> op_bytes ) ; <S2SV_EndBug> <S2SV_StartBug> return X86EMUL_CONTINUE ; <S2SV_EndBug> }\n","target":"<S2SV_ModStart> unsigned short sel , old_sel ; struct desc_struct old_desc , new_desc ; const struct x86_emulate_ops * ops = ctxt -> ops ; u8 cpl = ctxt -> ops -> cpl ( ctxt ) ; if ( ctxt -> mode == X86EMUL_MODE_PROT64 ) ops -> get_segment ( ctxt , & old_sel , & old_desc , NULL , VCPU_SREG_CS ) <S2SV_ModStart> ; rc = __load_segment_descriptor <S2SV_ModEnd> ( ctxt , <S2SV_ModStart> sel , VCPU_SREG_CS , cpl , false , & new_desc <S2SV_ModStart> return rc ; rc = assign_eip_far ( ctxt <S2SV_ModEnd> , ctxt -> <S2SV_ModStart> -> src . val , new_desc . l ) ; if ( rc != X86EMUL_CONTINUE ) { WARN_ON ( ! ctxt -> mode != X86EMUL_MODE_PROT64 ) ; ops -> set_segment ( ctxt , old_sel , & old_desc , 0 , VCPU_SREG_CS <S2SV_ModEnd> ) ; return <S2SV_ModStart> ) ; return rc ; } return rc <S2SV_ModEnd> ; } <S2SV_null>\n","project_and_commit_id":"torvalds@linux/d1442d85cc30ea75f7d399474ca738e0bc96f715","cve_id":"CVE-2014-3647","original_address":"https://github.com/torvalds/linux/commit/d1442d85cc30ea75f7d399474ca738e0bc96f715","time":"2014-11-10T11:55Z"},
	{"Unnamed: 0":377,"cwe_id":"CWE-119","source":"CWE-119 int encode_msg ( struct sip_msg * msg , char * payload , int len ) { int i , j , k , u , request ; unsigned short int h ; struct hdr_field * hf ; struct msg_start * ms ; struct sip_uri miuri ; char * myerror = NULL ; ptrdiff_t diff ; if ( len < MAX_ENCODED_MSG + MAX_MESSAGE_LEN ) return - 1 ; if ( parse_headers ( msg , HDR_EOH_F , 0 ) < 0 ) { myerror = \"in<S2SV_blank>parse_headers\" ; goto error ; } memset ( payload , 0 , len ) ; ms = & msg -> first_line ; if ( ms -> type == SIP_REQUEST ) request = 1 ; else if ( ms -> type == SIP_REPLY ) request = 0 ; else { myerror = \"message<S2SV_blank>is<S2SV_blank>neither<S2SV_blank>request<S2SV_blank>nor<S2SV_blank>response\" ; goto error ; } if ( request ) { for ( h = 0 ; h < 32 ; j = ( 0x01 << h ) , h ++ ) if ( j & ms -> u . request . method_value ) break ; } else { h = ( unsigned short ) ( ms -> u . reply . statuscode ) ; } if ( h == 32 ) { myerror = \"unknown<S2SV_blank>message<S2SV_blank>type\\\\n\" ; goto error ; } h = htons ( h ) ; memcpy ( payload , & h , 2 ) ; h = htons ( ( unsigned short int ) msg -> len ) ; memcpy ( & payload [ MSG_LEN_IDX ] , & h , 2 ) ; if ( 0 > ( diff = ( get_body ( msg ) - ( msg -> buf ) ) ) ) { myerror = \"body<S2SV_blank>starts<S2SV_blank>before<S2SV_blank>the<S2SV_blank>message<S2SV_blank>(uh<S2SV_blank>?)\" ; goto error ; } else h = htons ( ( unsigned short int ) diff ) ; memcpy ( payload + CONTENT_IDX , & h , 2 ) ; payload [ METHOD_CODE_IDX ] = ( unsigned char ) ( request ? ( ms -> u . request . method . s - msg -> buf ) : ( ms -> u . reply . status . s - msg -> buf ) ) ; payload [ METHOD_CODE_IDX + 1 ] = ( unsigned char ) ( request ? ( ms -> u . request . method . len ) : ( ms -> u . reply . status . len ) ) ; payload [ URI_REASON_IDX ] = ( unsigned char ) ( request ? ( ms -> u . request . uri . s - msg -> buf ) : ( ms -> u . reply . reason . s - msg -> buf ) ) ; payload [ URI_REASON_IDX + 1 ] = ( unsigned char ) ( request ? ( ms -> u . request . uri . len ) : ( ms -> u . reply . reason . len ) ) ; payload [ VERSION_IDX ] = ( unsigned char ) ( request ? ( ms -> u . request . version . s - msg -> buf ) : ( ms -> u . reply . version . s - msg -> buf ) ) ; if ( request ) { if ( parse_uri ( ms -> u . request . uri . s , ms -> u . request . uri . len , & miuri ) < 0 ) { LM_ERR ( \"<%.*s>\\\\n\" , ms -> u . request . uri . len , ms -> u . request . uri . s ) ; myerror = \"while<S2SV_blank>parsing<S2SV_blank>the<S2SV_blank>R-URI\" ; goto error ; } if ( 0 > ( j = encode_uri2 ( msg -> buf , ms -> u . request . method . s - msg -> buf + ms -> len , ms -> u . request . uri , & miuri , ( unsigned char * ) & payload [ REQUEST_URI_IDX + 1 ] ) ) ) { myerror = \"ENCODE_MSG:<S2SV_blank>ERROR<S2SV_blank>while<S2SV_blank>encoding<S2SV_blank>the<S2SV_blank>R-URI\" ; goto error ; } payload [ REQUEST_URI_IDX ] = ( unsigned char ) j ; k = REQUEST_URI_IDX + 1 + j ; } else k = REQUEST_URI_IDX ; u = k ; k ++ ; for ( i = 0 , hf = msg -> headers ; hf ; hf = hf -> next , i ++ ) ; i ++ ; j = k + 3 * i ; for ( i = 0 , hf = msg -> headers ; hf ; hf = hf -> next , k += 3 ) { payload [ k ] = ( unsigned char ) ( hf -> type & 0xFF ) ; h = htons ( j ) ; memcpy ( & payload [ k + 1 ] , & h , 2 ) ; if ( 0 > ( i = encode_header ( msg , hf , ( unsigned char * ) ( payload + j ) , MAX_ENCODED_MSG + MAX_MESSAGE_LEN - j ) ) ) { LM_ERR ( \"encoding<S2SV_blank>header<S2SV_blank>%.*s\\\\n\" , hf -> name . len , hf -> name . s ) ; goto error ; k -= 3 ; continue ; } j += ( unsigned short int ) i ; } payload [ u ] = ( unsigned char ) ( ( k - u - 1 ) / 3 ) ; j = htons ( j ) ; memcpy ( & payload [ k + 1 ] , & j , 2 ) ; k += 3 ; j = ntohs ( j ) ; <S2SV_StartBug> memcpy ( & payload [ j ] , msg -> buf , msg -> len ) ; <S2SV_EndBug> LM_DBG ( \"msglen<S2SV_blank>=<S2SV_blank>%d,msg<S2SV_blank>starts<S2SV_blank>at<S2SV_blank>%d\\\\n\" , msg -> len , j ) ; j = htons ( j ) ; memcpy ( & payload [ MSG_START_IDX ] , & j , 2 ) ; return GET_PAY_SIZE ( payload ) ; error : LM_ERR ( \"%s\\\\n\" , myerror ) ; return - 1 ; }\n","target":"<S2SV_ModStart> j ) ; if ( len < j + msg -> len + 1 ) { LM_ERR ( \"not<S2SV_blank>enough<S2SV_blank>space<S2SV_blank>to<S2SV_blank>encode<S2SV_blank>sip<S2SV_blank>message\\\\n\" ) ; return - 1 ; }\n","project_and_commit_id":"kamailio@kamailio/f50c9c853e7809810099c970780c30b0765b0643","cve_id":"CVE-2016-2385","original_address":"https://github.com/kamailio/kamailio/commit/f50c9c853e7809810099c970780c30b0765b0643","time":"2016-04-11T15:59Z"},
	{"Unnamed: 0":5481,"cwe_id":"CWE-119","source":"CWE-119 <S2SV_StartBug> static void rd_pick_partition ( VP9_COMP * cpi , const TileInfo * const tile , <S2SV_EndBug> TOKENEXTRA * * tp , int mi_row , <S2SV_StartBug> int mi_col , BLOCK_SIZE bsize , int * rate , <S2SV_EndBug> int64_t * dist , int do_recon , int64_t best_rd ) { VP9_COMMON * const cm = & cpi -> common ; <S2SV_StartBug> MACROBLOCK * const x = & cpi -> mb ; <S2SV_EndBug> MACROBLOCKD * const xd = & x -> e_mbd ; const int mi_step = num_8x8_blocks_wide_lookup [ bsize ] / 2 ; ENTROPY_CONTEXT l [ 16 * MAX_MB_PLANE ] , a [ 16 * MAX_MB_PLANE ] ; PARTITION_CONTEXT sl [ 8 ] , sa [ 8 ] ; TOKENEXTRA * tp_orig = * tp ; <S2SV_StartBug> PICK_MODE_CONTEXT * ctx = get_block_context ( x , bsize ) ; <S2SV_EndBug> int i , pl ; BLOCK_SIZE subsize ; <S2SV_StartBug> int this_rate , sum_rate = 0 , best_rate = INT_MAX ; <S2SV_EndBug> int64_t this_dist , sum_dist = 0 , best_dist = INT64_MAX ; int64_t sum_rd = 0 ; int do_split = bsize >= BLOCK_8X8 ; int do_rect = 1 ; const int force_horz_split = ( mi_row + mi_step >= cm -> mi_rows ) ; const int force_vert_split = ( mi_col + mi_step >= cm -> mi_cols ) ; const int xss = x -> e_mbd . plane [ 1 ] . subsampling_x ; const int yss = x -> e_mbd . plane [ 1 ] . subsampling_y ; <S2SV_StartBug> int partition_none_allowed = ! force_horz_split && ! force_vert_split ; <S2SV_EndBug> int partition_horz_allowed = ! force_vert_split && yss <= xss && bsize >= BLOCK_8X8 ; int partition_vert_allowed = ! force_horz_split && xss <= yss && bsize >= BLOCK_8X8 ; ( void ) * tp_orig ; <S2SV_StartBug> if ( bsize < BLOCK_8X8 ) { <S2SV_EndBug> if ( x -> ab_index != 0 ) { * rate = 0 ; * dist = 0 ; return ; } } assert ( num_8x8_blocks_wide_lookup [ bsize ] == <S2SV_StartBug> num_8x8_blocks_high_lookup [ bsize ] ) ; <S2SV_EndBug> <S2SV_StartBug> if ( bsize == BLOCK_16X16 ) { <S2SV_EndBug> set_offsets ( cpi , tile , mi_row , mi_col , bsize ) ; x -> mb_energy = vp9_block_energy ( cpi , x , bsize ) ; <S2SV_StartBug> } else { <S2SV_EndBug> x -> in_active_map = check_active_map ( cpi , x , mi_row , mi_col , bsize ) ; } if ( cpi -> sf . auto_min_max_partition_size ) { <S2SV_StartBug> partition_none_allowed &= ( bsize <= cpi -> sf . max_partition_size && <S2SV_EndBug> bsize >= cpi -> sf . min_partition_size ) ; <S2SV_StartBug> partition_horz_allowed &= ( ( bsize <= cpi -> sf . max_partition_size && <S2SV_EndBug> bsize > cpi -> sf . min_partition_size ) || force_horz_split ) ; <S2SV_StartBug> partition_vert_allowed &= ( ( bsize <= cpi -> sf . max_partition_size && <S2SV_EndBug> bsize > cpi -> sf . min_partition_size ) || force_vert_split ) ; <S2SV_StartBug> do_split &= bsize > cpi -> sf . min_partition_size ; <S2SV_EndBug> } if ( cpi -> sf . use_square_partition_only ) { partition_horz_allowed &= force_horz_split ; partition_vert_allowed &= force_vert_split ; } <S2SV_StartBug> save_context ( cpi , mi_row , mi_col , a , l , sa , sl , bsize ) ; <S2SV_EndBug> <S2SV_StartBug> if ( cpi -> sf . disable_split_var_thresh && partition_none_allowed ) { <S2SV_EndBug> unsigned int source_variancey ; vp9_setup_src_planes ( x , cpi -> Source , mi_row , mi_col ) ; source_variancey = get_sby_perpixel_variance ( cpi , x , bsize ) ; if ( source_variancey < cpi -> sf . disable_split_var_thresh ) { do_split = 0 ; <S2SV_StartBug> if ( source_variancey < cpi -> sf . disable_split_var_thresh / 2 ) <S2SV_EndBug> do_rect = 0 ; } } if ( ! x -> in_active_map && ( partition_horz_allowed || partition_vert_allowed ) ) do_split = 0 ; if ( partition_none_allowed ) { <S2SV_StartBug> rd_pick_sb_modes ( cpi , tile , mi_row , mi_col , & this_rate , & this_dist , bsize , <S2SV_EndBug> ctx , best_rd ) ; if ( this_rate != INT_MAX ) { if ( bsize >= BLOCK_8X8 ) { pl = partition_plane_context ( xd , mi_row , mi_col , bsize ) ; <S2SV_StartBug> this_rate += x -> partition_cost [ pl ] [ PARTITION_NONE ] ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> <S2SV_StartBug> sum_rd = RDCOST ( x -> rdmult , x -> rddiv , this_rate , this_dist ) ; <S2SV_EndBug> if ( sum_rd < best_rd ) { <S2SV_StartBug> int64_t stop_thresh = 4096 ; <S2SV_EndBug> int64_t stop_thresh_rd ; best_rate = this_rate ; best_dist = this_dist ; best_rd = sum_rd ; if ( bsize >= BLOCK_8X8 ) <S2SV_StartBug> * ( get_sb_partitioning ( x , bsize ) ) = bsize ; <S2SV_EndBug> stop_thresh >>= 8 - ( b_width_log2_lookup [ bsize ] + b_height_log2_lookup [ bsize ] ) ; <S2SV_StartBug> stop_thresh_rd = RDCOST ( x -> rdmult , x -> rddiv , 0 , stop_thresh ) ; <S2SV_EndBug> <S2SV_StartBug> if ( ! x -> e_mbd . lossless && best_rd < stop_thresh_rd ) { <S2SV_EndBug> do_split = 0 ; do_rect = 0 ; } } } <S2SV_StartBug> if ( ! x -> in_active_map ) { <S2SV_EndBug> do_split = 0 ; do_rect = 0 ; } restore_context ( cpi , mi_row , mi_col , a , l , sa , sl , bsize ) ; } if ( cpi -> sf . adaptive_motion_search ) store_pred_mv ( x , ctx ) ; sum_rd = 0 ; if ( do_split ) { subsize = get_subsize ( bsize , PARTITION_SPLIT ) ; <S2SV_StartBug> for ( i = 0 ; i < 4 && sum_rd < best_rd ; ++ i ) { <S2SV_EndBug> const int x_idx = ( i & 1 ) * mi_step ; const int y_idx = ( i >> 1 ) * mi_step ; if ( mi_row + y_idx >= cm -> mi_rows || mi_col + x_idx >= cm -> mi_cols ) continue ; <S2SV_StartBug> * get_sb_index ( x , subsize ) = i ; <S2SV_EndBug> if ( cpi -> sf . adaptive_motion_search ) load_pred_mv ( x , ctx ) ; if ( cpi -> sf . adaptive_pred_interp_filter && bsize == BLOCK_8X8 && partition_none_allowed ) get_block_context ( x , subsize ) -> pred_interp_filter = ctx -> mic . mbmi . interp_filter ; <S2SV_StartBug> rd_pick_partition ( cpi , tile , tp , mi_row + y_idx , mi_col + x_idx , subsize , <S2SV_EndBug> <S2SV_StartBug> & this_rate , & this_dist , i != 3 , best_rd - sum_rd ) ; <S2SV_EndBug> if ( this_rate == INT_MAX ) { <S2SV_StartBug> sum_rd = INT64_MAX ; <S2SV_EndBug> <S2SV_StartBug> } else { <S2SV_EndBug> <S2SV_StartBug> sum_rate += this_rate ; <S2SV_EndBug> sum_dist += this_dist ; sum_rd = RDCOST ( x -> rdmult , x -> rddiv , sum_rate , sum_dist ) ; } } if ( sum_rd < best_rd && i == 4 ) { pl = partition_plane_context ( xd , mi_row , mi_col , bsize ) ; <S2SV_StartBug> sum_rate += x -> partition_cost [ pl ] [ PARTITION_SPLIT ] ; <S2SV_EndBug> <S2SV_StartBug> sum_rd = RDCOST ( x -> rdmult , x -> rddiv , sum_rate , sum_dist ) ; <S2SV_EndBug> if ( sum_rd < best_rd ) { best_rate = sum_rate ; best_dist = sum_dist ; best_rd = sum_rd ; * ( get_sb_partitioning ( x , bsize ) ) = subsize ; } } else { if ( cpi -> sf . less_rectangular_check ) do_rect &= ! partition_none_allowed ; } <S2SV_StartBug> restore_context ( cpi , mi_row , mi_col , a , l , sa , sl , bsize ) ; <S2SV_EndBug> } <S2SV_StartBug> if ( partition_horz_allowed && do_rect ) { <S2SV_EndBug> <S2SV_StartBug> subsize = get_subsize ( bsize , PARTITION_HORZ ) ; <S2SV_EndBug> * get_sb_index ( x , subsize ) = 0 ; if ( cpi -> sf . adaptive_motion_search ) load_pred_mv ( x , ctx ) ; if ( cpi -> sf . adaptive_pred_interp_filter && bsize == BLOCK_8X8 && partition_none_allowed ) <S2SV_StartBug> get_block_context ( x , subsize ) -> pred_interp_filter = <S2SV_EndBug> ctx -> mic . mbmi . interp_filter ; rd_pick_sb_modes ( cpi , tile , mi_row , mi_col , & sum_rate , & sum_dist , subsize , get_block_context ( x , subsize ) , best_rd ) ; sum_rd = RDCOST ( x -> rdmult , x -> rddiv , sum_rate , sum_dist ) ; <S2SV_StartBug> if ( sum_rd < best_rd && mi_row + mi_step < cm -> mi_rows ) { <S2SV_EndBug> <S2SV_StartBug> update_state ( cpi , get_block_context ( x , subsize ) , mi_row , mi_col , <S2SV_EndBug> subsize , 0 ) ; encode_superblock ( cpi , tp , 0 , mi_row , mi_col , subsize ) ; * get_sb_index ( x , subsize ) = 1 ; if ( cpi -> sf . adaptive_motion_search ) load_pred_mv ( x , ctx ) ; if ( cpi -> sf . adaptive_pred_interp_filter && bsize == BLOCK_8X8 && partition_none_allowed ) <S2SV_StartBug> get_block_context ( x , subsize ) -> pred_interp_filter = <S2SV_EndBug> ctx -> mic . mbmi . interp_filter ; <S2SV_StartBug> rd_pick_sb_modes ( cpi , tile , mi_row + mi_step , mi_col , & this_rate , <S2SV_EndBug> & this_dist , subsize , get_block_context ( x , subsize ) , best_rd - sum_rd ) ; if ( this_rate == INT_MAX ) { <S2SV_StartBug> sum_rd = INT64_MAX ; <S2SV_EndBug> } else { <S2SV_StartBug> sum_rate += this_rate ; <S2SV_EndBug> sum_dist += this_dist ; <S2SV_StartBug> sum_rd = RDCOST ( x -> rdmult , x -> rddiv , sum_rate , sum_dist ) ; <S2SV_EndBug> } } if ( sum_rd < best_rd ) { pl = partition_plane_context ( xd , mi_row , mi_col , bsize ) ; sum_rate += x -> partition_cost [ pl ] [ PARTITION_HORZ ] ; sum_rd = RDCOST ( x -> rdmult , x -> rddiv , sum_rate , sum_dist ) ; if ( sum_rd < best_rd ) { best_rd = sum_rd ; best_rate = sum_rate ; best_dist = sum_dist ; * ( get_sb_partitioning ( x , bsize ) ) = subsize ; } } restore_context ( cpi , mi_row , mi_col , a , l , sa , sl , bsize ) ; } if ( partition_vert_allowed && do_rect ) { <S2SV_StartBug> subsize = get_subsize ( bsize , PARTITION_VERT ) ; <S2SV_EndBug> * get_sb_index ( x , subsize ) = 0 ; if ( cpi -> sf . adaptive_motion_search ) load_pred_mv ( x , ctx ) ; if ( cpi -> sf . adaptive_pred_interp_filter && bsize == BLOCK_8X8 && partition_none_allowed ) <S2SV_StartBug> get_block_context ( x , subsize ) -> pred_interp_filter = <S2SV_EndBug> ctx -> mic . mbmi . interp_filter ; rd_pick_sb_modes ( cpi , tile , mi_row , mi_col , & sum_rate , & sum_dist , subsize , get_block_context ( x , subsize ) , best_rd ) ; sum_rd = RDCOST ( x -> rdmult , x -> rddiv , sum_rate , sum_dist ) ; <S2SV_StartBug> if ( sum_rd < best_rd && mi_col + mi_step < cm -> mi_cols ) { <S2SV_EndBug> <S2SV_StartBug> update_state ( cpi , get_block_context ( x , subsize ) , mi_row , mi_col , <S2SV_EndBug> subsize , 0 ) ; encode_superblock ( cpi , tp , 0 , mi_row , mi_col , subsize ) ; * get_sb_index ( x , subsize ) = 1 ; if ( cpi -> sf . adaptive_motion_search ) load_pred_mv ( x , ctx ) ; if ( cpi -> sf . adaptive_pred_interp_filter && bsize == BLOCK_8X8 && partition_none_allowed ) <S2SV_StartBug> get_block_context ( x , subsize ) -> pred_interp_filter = <S2SV_EndBug> ctx -> mic . mbmi . interp_filter ; <S2SV_StartBug> rd_pick_sb_modes ( cpi , tile , mi_row , mi_col + mi_step , & this_rate , <S2SV_EndBug> & this_dist , subsize , get_block_context ( x , subsize ) , best_rd - sum_rd ) ; if ( this_rate == INT_MAX ) { <S2SV_StartBug> sum_rd = INT64_MAX ; <S2SV_EndBug> } else { <S2SV_StartBug> sum_rate += this_rate ; <S2SV_EndBug> sum_dist += this_dist ; <S2SV_StartBug> sum_rd = RDCOST ( x -> rdmult , x -> rddiv , sum_rate , sum_dist ) ; <S2SV_EndBug> } } if ( sum_rd < best_rd ) { pl = partition_plane_context ( xd , mi_row , mi_col , bsize ) ; sum_rate += x -> partition_cost [ pl ] [ PARTITION_VERT ] ; sum_rd = RDCOST ( x -> rdmult , x -> rddiv , sum_rate , sum_dist ) ; if ( sum_rd < best_rd ) { best_rate = sum_rate ; best_dist = sum_dist ; best_rd = sum_rd ; * ( get_sb_partitioning ( x , bsize ) ) = subsize ; } } restore_context ( cpi , mi_row , mi_col , a , l , sa , sl , bsize ) ; } ( void ) best_rd ; * rate = best_rate ; * dist = best_dist ; <S2SV_StartBug> if ( best_rate < INT_MAX && best_dist < INT64_MAX && do_recon ) { <S2SV_EndBug> int output_enabled = ( bsize == BLOCK_64X64 ) ; <S2SV_StartBug> if ( ( cpi -> oxcf . aq_mode == COMPLEXITY_AQ ) && cm -> seg . update_map ) { <S2SV_EndBug> vp9_select_in_frame_q_segment ( cpi , mi_row , mi_col , output_enabled , <S2SV_StartBug> best_rate ) ; <S2SV_EndBug> } if ( cpi -> oxcf . aq_mode == CYCLIC_REFRESH_AQ ) vp9_cyclic_refresh_set_rate_and_dist_sb ( cpi -> cyclic_refresh , best_rate , best_dist ) ; encode_sb ( cpi , tile , tp , mi_row , mi_col , output_enabled , bsize ) ; } if ( bsize == BLOCK_64X64 ) { assert ( tp_orig < * tp ) ; <S2SV_StartBug> assert ( best_rate < INT_MAX ) ; <S2SV_EndBug> <S2SV_StartBug> assert ( best_dist < INT64_MAX ) ; <S2SV_EndBug> } else { assert ( tp_orig == * tp ) ; } }\n","target":"<S2SV_ModStart> * cpi , ThreadData * td , TileDataEnc * tile_data <S2SV_ModEnd> , TOKENEXTRA * <S2SV_ModStart> int mi_row , int mi_col , <S2SV_ModEnd> BLOCK_SIZE bsize , <S2SV_ModStart> BLOCK_SIZE bsize , RD_COST * rd_cost , int64_t best_rd , PC_TREE * pc_tree <S2SV_ModEnd> ) { VP9_COMMON <S2SV_ModStart> -> common ; TileInfo * const tile_info = & tile_data -> tile_info ; <S2SV_ModStart> x = & td <S2SV_ModEnd> -> mb ; <S2SV_ModStart> * ctx = & pc_tree -> none <S2SV_ModEnd> ; int i <S2SV_ModStart> BLOCK_SIZE subsize ; RD_COST this_rdc , sum_rdc , best_rdc <S2SV_ModEnd> ; int do_split <S2SV_ModStart> . subsampling_y ; BLOCK_SIZE min_size = x -> min_partition_size ; BLOCK_SIZE max_size = x -> max_partition_size ; # if CONFIG_FP_MB_STATS unsigned int src_diff_var = UINT_MAX ; int none_complexity = 0 ; # endif <S2SV_ModStart> * tp_orig ; <S2SV_ModEnd> assert ( num_8x8_blocks_wide_lookup <S2SV_ModStart> [ bsize ] ) ; vp9_rd_cost_init ( & this_rdc ) ; vp9_rd_cost_init ( & sum_rdc ) ; vp9_rd_cost_reset ( & best_rdc ) ; best_rdc . rdcost = best_rd ; set_offsets ( cpi , tile_info , x , mi_row , mi_col , bsize <S2SV_ModStart> bsize == BLOCK_16X16 && cpi -> oxcf . aq_mode ) <S2SV_ModEnd> x -> mb_energy <S2SV_ModStart> bsize ) ; if ( cpi -> sf . cb_partition_search && bsize == BLOCK_16X16 ) { int cb_partition_search_ctrl = ( ( pc_tree -> index == 0 || pc_tree -> index == 3 ) + get_chessboard_index ( cm -> current_video_frame ) ) & 0x1 ; if ( cb_partition_search_ctrl && bsize > min_size && bsize < max_size ) set_partition_range ( cm , xd , mi_row , mi_col , bsize , & min_size , & max_size <S2SV_ModEnd> ) ; } <S2SV_ModStart> ( bsize <= max_size && bsize >= min_size <S2SV_ModEnd> ) ; partition_horz_allowed <S2SV_ModStart> ( bsize <= max_size && bsize > min_size <S2SV_ModEnd> ) || force_horz_split <S2SV_ModStart> ( bsize <= max_size && bsize > min_size <S2SV_ModEnd> ) || force_vert_split <S2SV_ModStart> &= bsize > min_size <S2SV_ModEnd> ; } if <S2SV_ModStart> } save_context ( x <S2SV_ModEnd> , mi_row , <S2SV_ModStart> bsize ) ; # if CONFIG_FP_MB_STATS if ( cpi -> use_fp_mb_stats ) { set_offsets ( cpi , tile_info , x , mi_row , mi_col , bsize ) ; src_diff_var = get_sby_perpixel_diff_variance ( cpi , & x -> plane [ 0 ] . src , mi_row , mi_col , bsize ) ; } # endif # if CONFIG_FP_MB_STATS if ( cpi -> use_fp_mb_stats && bsize >= BLOCK_32X32 && do_split && partition_none_allowed && src_diff_var > 4 && cm -> base_qindex < qindex_split_threshold_lookup [ bsize ] ) { int mb_row = mi_row >> 1 ; int mb_col = mi_col >> 1 ; int mb_row_end = MIN ( mb_row + num_16x16_blocks_high_lookup [ bsize ] , cm -> mb_rows ) ; int mb_col_end = MIN ( mb_col + num_16x16_blocks_wide_lookup [ bsize ] , cm -> mb_cols ) ; int r , c ; for ( r = mb_row ; r < mb_row_end ; r ++ ) { for ( c = mb_col ; c < mb_col_end ; c ++ ) { const int mb_index = r * cm -> mb_cols + c ; MOTION_DIRECTION this_mv ; MOTION_DIRECTION right_mv ; MOTION_DIRECTION bottom_mv ; this_mv = get_motion_direction_fp ( cpi -> twopass . this_frame_mb_stats [ mb_index ] ) ; if ( c != mb_col_end - 1 ) { right_mv = get_motion_direction_fp ( cpi -> twopass . this_frame_mb_stats [ mb_index + 1 ] ) ; none_complexity += get_motion_inconsistency ( this_mv , right_mv ) ; } if ( r != mb_row_end - 1 ) { bottom_mv = get_motion_direction_fp ( cpi -> twopass . this_frame_mb_stats [ mb_index + cm -> mb_cols ] ) ; none_complexity += get_motion_inconsistency ( this_mv , bottom_mv ) ; } } } if ( none_complexity > complexity_16x16_blocks_threshold [ bsize ] ) { partition_none_allowed <S2SV_ModEnd> = 0 ; <S2SV_ModStart> = 0 ; } } # endif <S2SV_ModEnd> if ( partition_none_allowed <S2SV_ModStart> ( cpi , tile_data , x , mi_row , mi_col , & this_rdc , bsize , ctx , best_rdc . rdcost ) ; if ( this_rdc . rate <S2SV_ModEnd> != INT_MAX ) <S2SV_ModStart> bsize ) ; this_rdc . rate += cpi <S2SV_ModEnd> -> partition_cost [ <S2SV_ModStart> PARTITION_NONE ] ; this_rdc . rdcost <S2SV_ModEnd> = RDCOST ( <S2SV_ModStart> -> rddiv , this_rdc . rate , this_rdc . dist ) ; } if ( this_rdc . rdcost < best_rdc . rdcost <S2SV_ModEnd> ) { int64_t <S2SV_ModStart> ) { int64_t dist_breakout_thr = cpi -> sf . partition_search_breakout_dist_thr ; int rate_breakout_thr = cpi -> sf . partition_search_breakout_rate_thr ; best_rdc = this_rdc <S2SV_ModEnd> ; if ( <S2SV_ModStart> >= BLOCK_8X8 ) pc_tree -> partitioning = PARTITION_NONE ; dist_breakout_thr <S2SV_ModEnd> >>= 8 - <S2SV_ModStart> ] ) ; rate_breakout_thr *= num_pels_log2_lookup [ bsize ] ; if ( ! x -> e_mbd . lossless && ( ctx -> skippable && best_rdc . dist < dist_breakout_thr && best_rdc . rate < rate_breakout_thr ) ) { do_split = 0 ; do_rect = 0 ; } # if CONFIG_FP_MB_STATS if ( cpi -> use_fp_mb_stats && do_split != 0 && cm -> base_qindex > qindex_skip_threshold_lookup [ bsize ] ) { int mb_row = mi_row >> 1 ; int mb_col = mi_col >> 1 ; int mb_row_end = MIN ( mb_row + num_16x16_blocks_high_lookup [ bsize ] , cm -> mb_rows ) ; int mb_col_end = MIN ( mb_col + num_16x16_blocks_wide_lookup [ bsize ] , cm -> mb_cols ) ; int r , c ; int skip = 1 ; for ( r = mb_row ; r < mb_row_end ; r ++ ) { for ( c = mb_col ; c < mb_col_end ; c ++ ) { const int mb_index = r * cm -> mb_cols + c <S2SV_ModEnd> ; if ( <S2SV_ModStart> if ( ! ( cpi -> twopass . this_frame_mb_stats [ mb_index ] & FPMB_MOTION_ZERO_MASK ) || ! ( cpi -> twopass . this_frame_mb_stats [ mb_index ] & FPMB_ERROR_SMALL_MASK ) ) { skip = 0 ; break ; } } if ( skip == 0 ) { break ; } } if ( skip ) { if ( src_diff_var == UINT_MAX ) { set_offsets ( cpi , tile_info , x , mi_row , mi_col , bsize ) ; src_diff_var = get_sby_perpixel_diff_variance ( cpi , & x -> plane [ 0 ] . src , mi_row , mi_col , bsize ) ; } if ( src_diff_var < 8 <S2SV_ModEnd> ) { do_split <S2SV_ModStart> } } } # endif } } restore_context ( x , mi_row , mi_col , a , l , sa , sl , bsize ) ; } if ( cpi -> sf . adaptive_motion_search ) store_pred_mv ( x , ctx ) ; if ( do_split ) { subsize = get_subsize ( bsize , PARTITION_SPLIT ) ; if ( bsize == BLOCK_8X8 ) { i = 4 ; if ( cpi -> sf . adaptive_pred_interp_filter && partition_none_allowed ) pc_tree -> leaf_split [ 0 ] -> pred_interp_filter = ctx -> mic . mbmi . interp_filter ; rd_pick_sb_modes ( cpi , tile_data , x , mi_row , mi_col , & sum_rdc , subsize , pc_tree -> leaf_split [ 0 ] , best_rdc . rdcost ) ; if ( sum_rdc . rate == INT_MAX ) sum_rdc . rdcost = INT64_MAX ; } else { <S2SV_ModEnd> for ( i <S2SV_ModStart> < 4 && sum_rdc . rdcost < best_rdc . rdcost <S2SV_ModEnd> ; ++ i <S2SV_ModStart> ) continue ; if ( cpi -> sf . adaptive_motion_search ) load_pred_mv ( x , ctx ) ; pc_tree -> split [ i ] -> index = i <S2SV_ModEnd> ; rd_pick_partition ( <S2SV_ModStart> ( cpi , td , tile_data <S2SV_ModEnd> , tp , <S2SV_ModStart> subsize , & this_rdc , best_rdc . rdcost - sum_rdc . rdcost , pc_tree -> split [ i ] ) ; if ( this_rdc . rate <S2SV_ModEnd> == INT_MAX ) <S2SV_ModStart> INT_MAX ) { sum_rdc . rdcost <S2SV_ModEnd> = INT64_MAX ; <S2SV_ModStart> = INT64_MAX ; break ; <S2SV_ModStart> } else { sum_rdc . rate += this_rdc . rate ; sum_rdc . dist += this_rdc . dist ; sum_rdc . rdcost += this_rdc . rdcost ; } } } if ( sum_rdc . rdcost < best_rdc . rdcost <S2SV_ModEnd> && i == <S2SV_ModStart> bsize ) ; sum_rdc . rate += cpi <S2SV_ModEnd> -> partition_cost [ <S2SV_ModStart> PARTITION_SPLIT ] ; sum_rdc . rdcost <S2SV_ModEnd> = RDCOST ( <S2SV_ModStart> -> rddiv , sum_rdc . rate , sum_rdc . dist ) ; if ( sum_rdc . rdcost < best_rdc . rdcost ) { best_rdc = sum_rdc ; pc_tree -> partitioning = PARTITION_SPLIT <S2SV_ModEnd> ; } } <S2SV_ModStart> } restore_context ( x <S2SV_ModEnd> , mi_row , <S2SV_ModStart> ( partition_horz_allowed && ( do_rect || vp9_active_h_edge ( cpi , mi_row , mi_step ) ) <S2SV_ModEnd> ) { subsize <S2SV_ModStart> , PARTITION_HORZ ) <S2SV_ModEnd> ; if ( <S2SV_ModStart> && partition_none_allowed ) pc_tree -> horizontal [ 0 ] . pred_interp_filter = ctx -> mic . mbmi . interp_filter ; rd_pick_sb_modes ( cpi , tile_data , x , mi_row , mi_col , & sum_rdc , subsize , & pc_tree -> horizontal [ 0 ] , best_rdc . rdcost ) ; if ( sum_rdc . rdcost < best_rdc . rdcost <S2SV_ModEnd> && mi_row + <S2SV_ModStart> cm -> mi_rows && bsize > BLOCK_8X8 ) { PICK_MODE_CONTEXT * ctx = & pc_tree -> horizontal [ 0 ] ; <S2SV_ModEnd> update_state ( cpi <S2SV_ModStart> ( cpi , td , ctx , mi_row , mi_col , subsize , 0 ) ; encode_superblock ( cpi , td , tp , 0 , mi_row , mi_col , subsize , ctx ) <S2SV_ModEnd> ; if ( <S2SV_ModStart> && partition_none_allowed ) pc_tree -> horizontal [ 1 ] . <S2SV_ModEnd> pred_interp_filter = ctx <S2SV_ModStart> ( cpi , tile_data , x <S2SV_ModEnd> , mi_row + <S2SV_ModStart> mi_col , & this_rdc , subsize , & pc_tree -> horizontal [ 1 ] , best_rdc . rdcost - sum_rdc . rdcost ) ; if ( this_rdc . rate <S2SV_ModEnd> == INT_MAX ) <S2SV_ModStart> INT_MAX ) { sum_rdc . rdcost <S2SV_ModEnd> = INT64_MAX ; <S2SV_ModStart> } else { sum_rdc . rate += this_rdc . rate ; sum_rdc . dist += this_rdc . dist ; sum_rdc . rdcost += this_rdc . rdcost ; } } if ( sum_rdc . rdcost < best_rdc . rdcost ) { pl = partition_plane_context ( xd , mi_row , mi_col , bsize ) ; sum_rdc . rate += cpi -> partition_cost [ pl ] [ PARTITION_HORZ ] ; sum_rdc . rdcost <S2SV_ModEnd> = RDCOST ( <S2SV_ModStart> -> rddiv , sum_rdc . rate , sum_rdc . dist ) ; if ( sum_rdc . rdcost < best_rdc . rdcost ) { best_rdc = sum_rdc ; pc_tree -> partitioning = PARTITION_HORZ ; } } restore_context ( x , mi_row , mi_col , a , l , sa , sl , bsize ) ; } if ( partition_vert_allowed && ( do_rect || vp9_active_v_edge ( cpi , mi_col , mi_step ) ) ) { subsize <S2SV_ModEnd> = get_subsize ( <S2SV_ModStart> , PARTITION_VERT ) <S2SV_ModEnd> ; if ( <S2SV_ModStart> && partition_none_allowed ) pc_tree -> vertical [ 0 ] . pred_interp_filter = ctx -> mic . mbmi . interp_filter ; rd_pick_sb_modes ( cpi , tile_data , x , mi_row , mi_col , & sum_rdc , subsize , & pc_tree -> vertical [ 0 ] , best_rdc . rdcost ) ; if ( sum_rdc . rdcost < best_rdc . rdcost <S2SV_ModEnd> && mi_col + <S2SV_ModStart> cm -> mi_cols && bsize > BLOCK_8X8 <S2SV_ModStart> ( cpi , td , & pc_tree -> vertical [ 0 ] , mi_row , mi_col , subsize , 0 ) ; encode_superblock ( cpi , td , tp , 0 , mi_row , mi_col , subsize , & pc_tree -> vertical [ 0 ] ) <S2SV_ModEnd> ; if ( <S2SV_ModStart> && partition_none_allowed ) pc_tree -> vertical [ 1 ] . <S2SV_ModEnd> pred_interp_filter = ctx <S2SV_ModStart> ( cpi , tile_data , x <S2SV_ModEnd> , mi_row , <S2SV_ModStart> mi_step , & this_rdc , subsize , & pc_tree -> vertical [ 1 ] , best_rdc . rdcost - sum_rdc . rdcost ) ; if ( this_rdc . rate <S2SV_ModEnd> == INT_MAX ) <S2SV_ModStart> INT_MAX ) { sum_rdc . rdcost <S2SV_ModEnd> = INT64_MAX ; <S2SV_ModStart> } else { sum_rdc . rate += this_rdc . rate ; sum_rdc . dist += this_rdc . dist ; sum_rdc . rdcost += this_rdc . rdcost ; } } if ( sum_rdc . rdcost < best_rdc . rdcost ) { pl = partition_plane_context ( xd , mi_row , mi_col , bsize ) ; sum_rdc . rate += cpi -> partition_cost [ pl ] [ PARTITION_VERT ] ; sum_rdc . rdcost <S2SV_ModEnd> = RDCOST ( <S2SV_ModStart> -> rddiv , sum_rdc . rate , sum_rdc . dist ) ; if ( sum_rdc . rdcost < best_rdc . rdcost ) { best_rdc = sum_rdc ; pc_tree -> partitioning = PARTITION_VERT ; } } restore_context ( x , mi_row , mi_col , a , l , sa , sl , bsize ) ; } ( void ) best_rd ; * rd_cost = best_rdc ; if ( best_rdc . rate <S2SV_ModEnd> < INT_MAX && <S2SV_ModStart> < INT_MAX && best_rdc . dist <S2SV_ModEnd> < INT64_MAX && <S2SV_ModStart> < INT64_MAX && pc_tree -> index != 3 <S2SV_ModEnd> ) { int <S2SV_ModStart> BLOCK_64X64 ) ; encode_sb ( cpi , td , tile_info , tp <S2SV_ModEnd> , mi_row , <S2SV_ModStart> , output_enabled , bsize , pc_tree <S2SV_ModEnd> ) ; } <S2SV_ModStart> ; assert ( best_rdc . rate <S2SV_ModEnd> < INT_MAX ) <S2SV_ModStart> ; assert ( best_rdc . dist <S2SV_ModEnd> < INT64_MAX )\n","project_and_commit_id":"external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426","cve_id":"CVE-2016-1621","original_address":"https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426","time":"2016-03-12T21:59Z"},
	{"Unnamed: 0":1732,"cwe_id":"CWE-119","source":"CWE-119 static void write_frame_size_with_refs ( VP9_COMP * cpi , <S2SV_StartBug> struct vp9_write_bit_buffer * wb ) { <S2SV_EndBug> VP9_COMMON * const cm = & cpi -> common ; int found = 0 ; MV_REFERENCE_FRAME ref_frame ; for ( ref_frame = LAST_FRAME ; ref_frame <= ALTREF_FRAME ; ++ ref_frame ) { YV12_BUFFER_CONFIG * cfg = get_ref_frame_buffer ( cpi , ref_frame ) ; <S2SV_StartBug> found = cm -> width == cfg -> y_crop_width && <S2SV_EndBug> cm -> height == cfg -> y_crop_height ; <S2SV_StartBug> if ( cpi -> use_svc ) { <S2SV_EndBug> found = 0 ; } vp9_wb_write_bit ( wb , found ) ; if ( found ) { break ; } } if ( ! found ) { <S2SV_StartBug> vp9_wb_write_literal ( wb , cm -> width - 1 , 16 ) ; <S2SV_EndBug> <S2SV_StartBug> vp9_wb_write_literal ( wb , cm -> height - 1 , 16 ) ; <S2SV_EndBug> } write_display_size ( cm , wb ) ; }\n","target":"<S2SV_ModStart> cpi , struct vpx_write_bit_buffer <S2SV_ModEnd> * wb ) <S2SV_ModStart> ref_frame ) ; if ( cpi -> use_svc && ( ( cpi -> svc . number_temporal_layers > 1 && cpi -> oxcf . rc_mode == VPX_CBR ) || ( cpi -> svc . number_spatial_layers > 1 && cpi -> svc . layer_context [ cpi -> svc . spatial_layer_id ] . is_key_frame ) || ( is_two_pass_svc ( cpi ) && cpi -> svc . encode_empty_frame_state == ENCODING && cpi -> svc . layer_context [ 0 ] . frames_from_key_frame < cpi -> svc . number_temporal_layers + 1 ) ) ) { found = 0 ; } else if ( cfg != NULL ) { <S2SV_ModStart> -> y_crop_height ; } vpx_wb_write_bit <S2SV_ModEnd> ( wb , <S2SV_ModStart> found ) { vpx_wb_write_literal <S2SV_ModEnd> ( wb , <S2SV_ModStart> 16 ) ; vpx_wb_write_literal <S2SV_ModEnd> ( wb ,\n","project_and_commit_id":"external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426","cve_id":"CVE-2016-1621","original_address":"https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426","time":"2016-03-12T21:59Z"},
	{"Unnamed: 0":707,"cwe_id":"CWE-125","source":"CWE-125 static RList * r_bin_wasm_get_element_entries ( RBinWasmObj * bin , RBinWasmSection * sec ) { RList * ret = NULL ; RBinWasmElementEntry * ptr = NULL ; if ( ! ( ret = r_list_newf ( ( RListFree ) free ) ) ) { return NULL ; } ut8 * buf = bin -> buf -> buf + ( ut32 ) sec -> payload_data ; <S2SV_StartBug> ut32 len = sec -> payload_len ; <S2SV_EndBug> ut32 count = sec -> count ; ut32 i = 0 , r = 0 ; <S2SV_StartBug> while ( i < len && r < count ) { <S2SV_EndBug> if ( ! ( ptr = R_NEW0 ( RBinWasmElementEntry ) ) ) { return ret ; } if ( ! ( consume_u32 ( buf + i , buf + len , & ptr -> index , & i ) ) ) { <S2SV_StartBug> free ( ptr ) ; <S2SV_EndBug> return ret ; } if ( ! ( consume_init_expr ( buf + i , buf + len , R_BIN_WASM_END_OF_CODE , NULL , & i ) ) ) { <S2SV_StartBug> free ( ptr ) ; <S2SV_EndBug> return ret ; } if ( ! ( consume_u32 ( buf + i , buf + len , & ptr -> num_elem , & i ) ) ) { <S2SV_StartBug> free ( ptr ) ; <S2SV_EndBug> return ret ; } ut32 j = 0 ; while ( i < len && j < ptr -> num_elem ) { ut32 e ; if ( ! ( consume_u32 ( buf + i , buf + len , & e , & i ) ) ) { free ( ptr ) ; return ret ; } } r_list_append ( ret , ptr ) ; r += 1 ; } return ret ; <S2SV_StartBug> } <S2SV_EndBug>\n","target":"<S2SV_ModStart> -> payload_data ; int buflen = bin -> buf -> length - ( ut32 ) sec -> payload_data ; <S2SV_ModStart> i < len && len < buflen <S2SV_ModStart> ) ) { goto beach <S2SV_ModEnd> ; } if <S2SV_ModStart> ) ) { goto beach <S2SV_ModEnd> ; } if <S2SV_ModStart> ) ) { goto beach <S2SV_ModEnd> ; } ut32 <S2SV_ModStart> return ret ; beach : free ( ptr ) ; return ret ;\n","project_and_commit_id":"radare@radare2/d2632f6483a3ceb5d8e0a5fb11142c51c43978b4","cve_id":"CVE-2017-7854","original_address":"https://github.com/radare/radare2/commit/d2632f6483a3ceb5d8e0a5fb11142c51c43978b4","time":"2017-04-13T16:59Z"},
	{"Unnamed: 0":4748,"cwe_id":"CWE-000","source":"CWE-000 static struct sock * tcp_v6_syn_recv_sock ( const struct sock * sk , struct sk_buff * skb , struct request_sock * req , struct dst_entry * dst , struct request_sock * req_unhash , bool * own_req ) { struct inet_request_sock * ireq ; struct ipv6_pinfo * newnp ; const struct ipv6_pinfo * np = inet6_sk ( sk ) ; struct ipv6_txoptions * opt ; struct tcp6_sock * newtcp6sk ; struct inet_sock * newinet ; struct tcp_sock * newtp ; struct sock * newsk ; # ifdef CONFIG_TCP_MD5SIG struct tcp_md5sig_key * key ; # endif struct flowi6 fl6 ; if ( skb -> protocol == htons ( ETH_P_IP ) ) { newsk = tcp_v4_syn_recv_sock ( sk , skb , req , dst , req_unhash , own_req ) ; if ( ! newsk ) return NULL ; newtcp6sk = ( struct tcp6_sock * ) newsk ; inet_sk ( newsk ) -> pinet6 = & newtcp6sk -> inet6 ; newinet = inet_sk ( newsk ) ; newnp = inet6_sk ( newsk ) ; newtp = tcp_sk ( newsk ) ; memcpy ( newnp , np , sizeof ( struct ipv6_pinfo ) ) ; newnp -> saddr = newsk -> sk_v6_rcv_saddr ; inet_csk ( newsk ) -> icsk_af_ops = & ipv6_mapped ; newsk -> sk_backlog_rcv = tcp_v4_do_rcv ; # ifdef CONFIG_TCP_MD5SIG newtp -> af_specific = & tcp_sock_ipv6_mapped_specific ; # endif <S2SV_StartBug> newnp -> ipv6_ac_list = NULL ; <S2SV_EndBug> newnp -> ipv6_fl_list = NULL ; newnp -> pktoptions = NULL ; newnp -> opt = NULL ; newnp -> mcast_oif = tcp_v6_iif ( skb ) ; newnp -> mcast_hops = ipv6_hdr ( skb ) -> hop_limit ; newnp -> rcv_flowinfo = ip6_flowinfo ( ipv6_hdr ( skb ) ) ; if ( np -> repflow ) newnp -> flow_label = ip6_flowlabel ( ipv6_hdr ( skb ) ) ; tcp_sync_mss ( newsk , inet_csk ( newsk ) -> icsk_pmtu_cookie ) ; return newsk ; } ireq = inet_rsk ( req ) ; if ( sk_acceptq_is_full ( sk ) ) goto out_overflow ; if ( ! dst ) { dst = inet6_csk_route_req ( sk , & fl6 , req , IPPROTO_TCP ) ; if ( ! dst ) goto out ; } newsk = tcp_create_openreq_child ( sk , req , skb ) ; if ( ! newsk ) goto out_nonewsk ; newsk -> sk_gso_type = SKB_GSO_TCPV6 ; ip6_dst_store ( newsk , dst , NULL , NULL ) ; inet6_sk_rx_dst_set ( newsk , skb ) ; newtcp6sk = ( struct tcp6_sock * ) newsk ; inet_sk ( newsk ) -> pinet6 = & newtcp6sk -> inet6 ; newtp = tcp_sk ( newsk ) ; newinet = inet_sk ( newsk ) ; newnp = inet6_sk ( newsk ) ; memcpy ( newnp , np , sizeof ( struct ipv6_pinfo ) ) ; newsk -> sk_v6_daddr = ireq -> ir_v6_rmt_addr ; newnp -> saddr = ireq -> ir_v6_loc_addr ; newsk -> sk_v6_rcv_saddr = ireq -> ir_v6_loc_addr ; newsk -> sk_bound_dev_if = ireq -> ir_iif ; <S2SV_StartBug> newinet -> inet_opt = NULL ; <S2SV_EndBug> newnp -> ipv6_ac_list = NULL ; newnp -> ipv6_fl_list = NULL ; newnp -> rxopt . all = np -> rxopt . all ; newnp -> pktoptions = NULL ; newnp -> opt = NULL ; newnp -> mcast_oif = tcp_v6_iif ( skb ) ; newnp -> mcast_hops = ipv6_hdr ( skb ) -> hop_limit ; newnp -> rcv_flowinfo = ip6_flowinfo ( ipv6_hdr ( skb ) ) ; if ( np -> repflow ) newnp -> flow_label = ip6_flowlabel ( ipv6_hdr ( skb ) ) ; opt = ireq -> ipv6_opt ; if ( ! opt ) opt = rcu_dereference ( np -> opt ) ; if ( opt ) { opt = ipv6_dup_options ( newsk , opt ) ; RCU_INIT_POINTER ( newnp -> opt , opt ) ; } inet_csk ( newsk ) -> icsk_ext_hdr_len = 0 ; if ( opt ) inet_csk ( newsk ) -> icsk_ext_hdr_len = opt -> opt_nflen + opt -> opt_flen ; tcp_ca_openreq_child ( newsk , dst ) ; tcp_sync_mss ( newsk , dst_mtu ( dst ) ) ; newtp -> advmss = tcp_mss_clamp ( tcp_sk ( sk ) , dst_metric_advmss ( dst ) ) ; tcp_initialize_rcv_mss ( newsk ) ; newinet -> inet_daddr = newinet -> inet_saddr = LOOPBACK4_IPV6 ; newinet -> inet_rcv_saddr = LOOPBACK4_IPV6 ; # ifdef CONFIG_TCP_MD5SIG key = tcp_v6_md5_do_lookup ( sk , & newsk -> sk_v6_daddr ) ; if ( key ) { tcp_md5_do_add ( newsk , ( union tcp_md5_addr * ) & newsk -> sk_v6_daddr , AF_INET6 , key -> key , key -> keylen , sk_gfp_mask ( sk , GFP_ATOMIC ) ) ; } # endif if ( __inet_inherit_port ( sk , newsk ) < 0 ) { inet_csk_prepare_forced_close ( newsk ) ; tcp_done ( newsk ) ; goto out ; } * own_req = inet_ehash_nolisten ( newsk , req_to_sk ( req_unhash ) ) ; if ( * own_req ) { tcp_move_syn ( newtp , req ) ; if ( ireq -> pktopts ) { newnp -> pktoptions = skb_clone ( ireq -> pktopts , sk_gfp_mask ( sk , GFP_ATOMIC ) ) ; consume_skb ( ireq -> pktopts ) ; ireq -> pktopts = NULL ; if ( newnp -> pktoptions ) { tcp_v6_restore_cb ( newnp -> pktoptions ) ; skb_set_owner_r ( newnp -> pktoptions , newsk ) ; } } } return newsk ; out_overflow : __NET_INC_STATS ( sock_net ( sk ) , LINUX_MIB_LISTENOVERFLOWS ) ; out_nonewsk : dst_release ( dst ) ; out : tcp_listendrop ( sk ) ; return NULL ; }\n","target":"<S2SV_ModStart> endif newnp -> ipv6_mc_list = NULL ; newnp -> <S2SV_ModStart> newinet -> inet_opt = NULL ; newnp -> ipv6_mc_list\n","project_and_commit_id":"torvalds@linux/83eaddab4378db256d00d295bda6ca997cd13a52","cve_id":"CVE-2017-9077","original_address":"https://github.com/torvalds/linux/commit/83eaddab4378db256d00d295bda6ca997cd13a52","time":"2017-05-19T14:29Z"},
	{"Unnamed: 0":6506,"cwe_id":"CWE-310","source":"CWE-310 int ASN1_item_verify ( const ASN1_ITEM * it , X509_ALGOR * a , ASN1_BIT_STRING * signature , void * asn , EVP_PKEY * pkey ) { EVP_MD_CTX ctx ; unsigned char * buf_in = NULL ; int ret = - 1 , inl ; int mdnid , pknid ; if ( ! pkey ) { ASN1err ( ASN1_F_ASN1_ITEM_VERIFY , ERR_R_PASSED_NULL_PARAMETER ) ; return - 1 ; } <S2SV_StartBug> EVP_MD_CTX_init ( & ctx ) ; <S2SV_EndBug> if ( ! OBJ_find_sigid_algs ( OBJ_obj2nid ( a -> algorithm ) , & mdnid , & pknid ) ) { ASN1err ( ASN1_F_ASN1_ITEM_VERIFY , ASN1_R_UNKNOWN_SIGNATURE_ALGORITHM ) ; goto err ; } if ( mdnid == NID_undef ) { if ( ! pkey -> ameth || ! pkey -> ameth -> item_verify ) { ASN1err ( ASN1_F_ASN1_ITEM_VERIFY , ASN1_R_UNKNOWN_SIGNATURE_ALGORITHM ) ; goto err ; } ret = pkey -> ameth -> item_verify ( & ctx , it , asn , a , signature , pkey ) ; if ( ret != 2 ) goto err ; ret = - 1 ; } else { const EVP_MD * type ; type = EVP_get_digestbynid ( mdnid ) ; if ( type == NULL ) { ASN1err ( ASN1_F_ASN1_ITEM_VERIFY , ASN1_R_UNKNOWN_MESSAGE_DIGEST_ALGORITHM ) ; goto err ; } if ( EVP_PKEY_type ( pknid ) != pkey -> ameth -> pkey_id ) { ASN1err ( ASN1_F_ASN1_ITEM_VERIFY , ASN1_R_WRONG_PUBLIC_KEY_TYPE ) ; goto err ; } if ( ! EVP_DigestVerifyInit ( & ctx , NULL , type , NULL , pkey ) ) { ASN1err ( ASN1_F_ASN1_ITEM_VERIFY , ERR_R_EVP_LIB ) ; ret = 0 ; goto err ; } } inl = ASN1_item_i2d ( asn , & buf_in , it ) ; if ( buf_in == NULL ) { ASN1err ( ASN1_F_ASN1_ITEM_VERIFY , ERR_R_MALLOC_FAILURE ) ; goto err ; } ret = EVP_DigestVerifyUpdate ( & ctx , buf_in , inl ) ; OPENSSL_cleanse ( buf_in , ( unsigned int ) inl ) ; OPENSSL_free ( buf_in ) ; if ( ! ret ) { ASN1err ( ASN1_F_ASN1_ITEM_VERIFY , ERR_R_EVP_LIB ) ; goto err ; } ret = - 1 ; if ( EVP_DigestVerifyFinal ( & ctx , signature -> data , ( size_t ) signature -> length ) <= 0 ) { ASN1err ( ASN1_F_ASN1_ITEM_VERIFY , ERR_R_EVP_LIB ) ; ret = 0 ; goto err ; } ret = 1 ; err : EVP_MD_CTX_cleanup ( & ctx ) ; return ( ret ) ; }\n","target":"<S2SV_ModStart> 1 ; } if ( signature -> type == V_ASN1_BIT_STRING && signature -> flags & 0x7 ) { ASN1err ( ASN1_F_ASN1_VERIFY , ASN1_R_INVALID_BIT_STRING_BITS_LEFT ) ; return - 1 ; }\n","project_and_commit_id":"openssl@openssl/684400ce192dac51df3d3e92b61830a6ef90be3e","cve_id":"CVE-2014-8275","original_address":"https://github.com/openssl/openssl/commit/684400ce192dac51df3d3e92b61830a6ef90be3e","time":"2015-01-09T02:59Z"},
	{"Unnamed: 0":6627,"cwe_id":"CWE-119","source":"CWE-119 static void copy_fields ( const FieldMatchContext * fm , AVFrame * dst , const AVFrame * src , int field ) { int plane ; <S2SV_StartBug> for ( plane = 0 ; plane < 4 && src -> data [ plane ] ; plane ++ ) <S2SV_EndBug> av_image_copy_plane ( dst -> data [ plane ] + field * dst -> linesize [ plane ] , dst -> linesize [ plane ] << 1 , src -> data [ plane ] + field * src -> linesize [ plane ] , src -> linesize [ plane ] << 1 , get_width ( fm , src , plane ) , get_height ( fm , src , plane ) / 2 ) ; }\n","target":"<S2SV_ModStart> src -> data [ plane ] && src -> linesize\n","project_and_commit_id":"FFmpeg@FFmpeg/e43a0a232dbf6d3c161823c2e07c52e76227a1bc","cve_id":"CVE-2013-4263","original_address":"https://github.com/FFmpeg/FFmpeg/commit/e43a0a232dbf6d3c161823c2e07c52e76227a1bc","time":"2013-11-23T17:55Z"},
	{"Unnamed: 0":5419,"cwe_id":"CWE-200","source":"CWE-200 static int ccid3_hc_tx_getsockopt ( struct sock * sk , const int optname , int len , u32 __user * optval , int __user * optlen ) { const struct ccid3_hc_tx_sock * hc = ccid3_hc_tx_sk ( sk ) ; struct tfrc_tx_info tfrc ; const void * val ; switch ( optname ) { case DCCP_SOCKOPT_CCID_TX_INFO : if ( len < sizeof ( tfrc ) ) return - EINVAL ; <S2SV_StartBug> tfrc . tfrctx_x = hc -> tx_x ; <S2SV_EndBug> tfrc . tfrctx_x_recv = hc -> tx_x_recv ; tfrc . tfrctx_x_calc = hc -> tx_x_calc ; tfrc . tfrctx_rtt = hc -> tx_rtt ; tfrc . tfrctx_p = hc -> tx_p ; tfrc . tfrctx_rto = hc -> tx_t_rto ; tfrc . tfrctx_ipi = hc -> tx_t_ipi ; len = sizeof ( tfrc ) ; val = & tfrc ; break ; default : return - ENOPROTOOPT ; } if ( put_user ( len , optlen ) || copy_to_user ( optval , val , len ) ) return - EFAULT ; return 0 ; }\n","target":"<S2SV_ModStart> - EINVAL ; memset ( & tfrc , 0 , sizeof ( tfrc ) ) ;\n","project_and_commit_id":"torvalds@linux/7b07f8eb75aa3097cdfd4f6eac3da49db787381d","cve_id":"CVE-2012-6541","original_address":"https://github.com/torvalds/linux/commit/7b07f8eb75aa3097cdfd4f6eac3da49db787381d","time":"2013-03-15T20:55Z"},
	{"Unnamed: 0":6047,"cwe_id":"CWE-125","source":"CWE-125 int yyparse ( void * yyscanner , YR_COMPILER * compiler ) { int yychar ; YY_INITIAL_VALUE ( static YYSTYPE yyval_default ; ) YYSTYPE yylval YY_INITIAL_VALUE ( = yyval_default ) ; int yynerrs ; int yystate ; int yyerrstatus ; yytype_int16 yyssa [ YYINITDEPTH ] ; yytype_int16 * yyss ; yytype_int16 * yyssp ; YYSTYPE yyvsa [ YYINITDEPTH ] ; YYSTYPE * yyvs ; YYSTYPE * yyvsp ; YYSIZE_T yystacksize ; int yyn ; int yyresult ; int yytoken = 0 ; YYSTYPE yyval ; # if YYERROR_VERBOSE char yymsgbuf [ 128 ] ; char * yymsg = yymsgbuf ; YYSIZE_T yymsg_alloc = sizeof yymsgbuf ; # endif # define YYPOPSTACK ( N ) ( yyvsp -= ( N ) , yyssp -= ( N ) ) int yylen = 0 ; yyssp = yyss = yyssa ; yyvsp = yyvs = yyvsa ; yystacksize = YYINITDEPTH ; YYDPRINTF ( ( stderr , \"Starting<S2SV_blank>parse\\\\n\" ) ) ; yystate = 0 ; yyerrstatus = 0 ; yynerrs = 0 ; yychar = YYEMPTY ; goto yysetstate ; yynewstate : yyssp ++ ; yysetstate : * yyssp = yystate ; if ( yyss + yystacksize - 1 <= yyssp ) { YYSIZE_T yysize = yyssp - yyss + 1 ; # ifdef yyoverflow { YYSTYPE * yyvs1 = yyvs ; yytype_int16 * yyss1 = yyss ; yyoverflow ( YY_ ( \"memory<S2SV_blank>exhausted\" ) , & yyss1 , yysize * sizeof ( * yyssp ) , & yyvs1 , yysize * sizeof ( * yyvsp ) , & yystacksize ) ; yyss = yyss1 ; yyvs = yyvs1 ; } # else # ifndef YYSTACK_RELOCATE goto yyexhaustedlab ; # else if ( YYMAXDEPTH <= yystacksize ) goto yyexhaustedlab ; yystacksize *= 2 ; if ( YYMAXDEPTH < yystacksize ) yystacksize = YYMAXDEPTH ; { yytype_int16 * yyss1 = yyss ; union yyalloc * yyptr = ( union yyalloc * ) YYSTACK_ALLOC ( YYSTACK_BYTES ( yystacksize ) ) ; if ( ! yyptr ) goto yyexhaustedlab ; YYSTACK_RELOCATE ( yyss_alloc , yyss ) ; YYSTACK_RELOCATE ( yyvs_alloc , yyvs ) ; # undef YYSTACK_RELOCATE if ( yyss1 != yyssa ) YYSTACK_FREE ( yyss1 ) ; } # endif # endif yyssp = yyss + yysize - 1 ; yyvsp = yyvs + yysize - 1 ; YYDPRINTF ( ( stderr , \"Stack<S2SV_blank>size<S2SV_blank>increased<S2SV_blank>to<S2SV_blank>%lu\\\\n\" , ( unsigned long int ) yystacksize ) ) ; if ( yyss + yystacksize - 1 <= yyssp ) YYABORT ; } YYDPRINTF ( ( stderr , \"Entering<S2SV_blank>state<S2SV_blank>%d\\\\n\" , yystate ) ) ; if ( yystate == YYFINAL ) YYACCEPT ; goto yybackup ; yybackup : yyn = yypact [ yystate ] ; if ( yypact_value_is_default ( yyn ) ) goto yydefault ; if ( yychar == YYEMPTY ) { YYDPRINTF ( ( stderr , \"Reading<S2SV_blank>a<S2SV_blank>token:<S2SV_blank>\" ) ) ; yychar = yylex ( & yylval , yyscanner , compiler ) ; } if ( yychar <= YYEOF ) { yychar = yytoken = YYEOF ; YYDPRINTF ( ( stderr , \"Now<S2SV_blank>at<S2SV_blank>end<S2SV_blank>of<S2SV_blank>input.\\\\n\" ) ) ; } else { yytoken = YYTRANSLATE ( yychar ) ; YY_SYMBOL_PRINT ( \"Next<S2SV_blank>token<S2SV_blank>is\" , yytoken , & yylval , & yylloc ) ; } yyn += yytoken ; if ( yyn < 0 || YYLAST < yyn || yycheck [ yyn ] != yytoken ) goto yydefault ; yyn = yytable [ yyn ] ; if ( yyn <= 0 ) { if ( yytable_value_is_error ( yyn ) ) goto yyerrlab ; yyn = - yyn ; goto yyreduce ; } if ( yyerrstatus ) yyerrstatus -- ; YY_SYMBOL_PRINT ( \"Shifting\" , yytoken , & yylval , & yylloc ) ; yychar = YYEMPTY ; yystate = yyn ; YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN * ++ yyvsp = yylval ; YY_IGNORE_MAYBE_UNINITIALIZED_END goto yynewstate ; yydefault : yyn = yydefact [ yystate ] ; if ( yyn == 0 ) goto yyerrlab ; goto yyreduce ; yyreduce : yylen = yyr2 [ yyn ] ; yyval = yyvsp [ 1 - yylen ] ; YY_REDUCE_PRINT ( yyn ) ; switch ( yyn ) { case 8 : # line 230 \"grammar.y\" { int result = yr_parser_reduce_import ( yyscanner , ( yyvsp [ 0 ] . sized_string ) ) ; yr_free ( ( yyvsp [ 0 ] . sized_string ) ) ; ERROR_IF ( result != ERROR_SUCCESS ) ; } # line 1661 \"grammar.c\" break ; case 9 : # line 242 \"grammar.y\" { YR_RULE * rule = yr_parser_reduce_rule_declaration_phase_1 ( yyscanner , ( int32_t ) ( yyvsp [ - 2 ] . integer ) , ( yyvsp [ 0 ] . c_string ) ) ; ERROR_IF ( rule == NULL ) ; ( yyval . rule ) = rule ; } # line 1674 \"grammar.c\" break ; case 10 : # line 251 \"grammar.y\" { YR_RULE * rule = ( yyvsp [ - 4 ] . rule ) ; rule -> tags = ( yyvsp [ - 3 ] . c_string ) ; rule -> metas = ( yyvsp [ - 1 ] . meta ) ; rule -> strings = ( yyvsp [ 0 ] . string ) ; } # line 1686 \"grammar.c\" break ; case 11 : # line 259 \"grammar.y\" { YR_RULE * rule = ( yyvsp [ - 7 ] . rule ) ; compiler -> last_result = yr_parser_reduce_rule_declaration_phase_2 ( yyscanner , rule ) ; yr_free ( ( yyvsp [ - 8 ] . c_string ) ) ; ERROR_IF ( compiler -> last_result != ERROR_SUCCESS ) ; } # line 1701 \"grammar.c\" break ; case 12 : # line 274 \"grammar.y\" { ( yyval . meta ) = NULL ; } # line 1709 \"grammar.c\" break ; case 13 : # line 278 \"grammar.y\" { YR_META null_meta ; memset ( & null_meta , 0xFF , sizeof ( YR_META ) ) ; null_meta . type = META_TYPE_NULL ; compiler -> last_result = yr_arena_write_data ( compiler -> metas_arena , & null_meta , sizeof ( YR_META ) , NULL ) ; ( yyval . meta ) = ( yyvsp [ 0 ] . meta ) ; ERROR_IF ( compiler -> last_result != ERROR_SUCCESS ) ; } # line 1736 \"grammar.c\" break ; case 14 : # line 305 \"grammar.y\" { ( yyval . string ) = NULL ; } # line 1744 \"grammar.c\" break ; case 15 : # line 309 \"grammar.y\" { YR_STRING null_string ; memset ( & null_string , 0xFF , sizeof ( YR_STRING ) ) ; null_string . g_flags = STRING_GFLAGS_NULL ; compiler -> last_result = yr_arena_write_data ( compiler -> strings_arena , & null_string , sizeof ( YR_STRING ) , NULL ) ; ERROR_IF ( compiler -> last_result != ERROR_SUCCESS ) ; ( yyval . string ) = ( yyvsp [ 0 ] . string ) ; } # line 1771 \"grammar.c\" break ; case 17 : # line 340 \"grammar.y\" { ( yyval . integer ) = 0 ; } # line 1777 \"grammar.c\" break ; case 18 : # line 341 \"grammar.y\" { ( yyval . integer ) = ( yyvsp [ - 1 ] . integer ) | ( yyvsp [ 0 ] . integer ) ; } # line 1783 \"grammar.c\" break ; case 19 : # line 346 \"grammar.y\" { ( yyval . integer ) = RULE_GFLAGS_PRIVATE ; } # line 1789 \"grammar.c\" break ; case 20 : # line 347 \"grammar.y\" { ( yyval . integer ) = RULE_GFLAGS_GLOBAL ; } # line 1795 \"grammar.c\" break ; case 21 : # line 353 \"grammar.y\" { ( yyval . c_string ) = NULL ; } # line 1803 \"grammar.c\" break ; case 22 : # line 357 \"grammar.y\" { compiler -> last_result = yr_arena_write_string ( yyget_extra ( yyscanner ) -> sz_arena , \"\" , NULL ) ; ERROR_IF ( compiler -> last_result != ERROR_SUCCESS ) ; ( yyval . c_string ) = ( yyvsp [ 0 ] . c_string ) ; } # line 1821 \"grammar.c\" break ; case 23 : # line 375 \"grammar.y\" { char * identifier ; compiler -> last_result = yr_arena_write_string ( yyget_extra ( yyscanner ) -> sz_arena , ( yyvsp [ 0 ] . c_string ) , & identifier ) ; yr_free ( ( yyvsp [ 0 ] . c_string ) ) ; ERROR_IF ( compiler -> last_result != ERROR_SUCCESS ) ; ( yyval . c_string ) = identifier ; } # line 1838 \"grammar.c\" break ; case 24 : # line 388 \"grammar.y\" { char * tag_name = ( yyvsp [ - 1 ] . c_string ) ; size_t tag_length = tag_name != NULL ? strlen ( tag_name ) : 0 ; while ( tag_length > 0 ) { if ( strcmp ( tag_name , ( yyvsp [ 0 ] . c_string ) ) == 0 ) { yr_compiler_set_error_extra_info ( compiler , tag_name ) ; compiler -> last_result = ERROR_DUPLICATED_TAG_IDENTIFIER ; break ; } tag_name = ( char * ) yr_arena_next_address ( yyget_extra ( yyscanner ) -> sz_arena , tag_name , tag_length + 1 ) ; tag_length = tag_name != NULL ? strlen ( tag_name ) : 0 ; } if ( compiler -> last_result == ERROR_SUCCESS ) compiler -> last_result = yr_arena_write_string ( yyget_extra ( yyscanner ) -> sz_arena , ( yyvsp [ 0 ] . c_string ) , NULL ) ; yr_free ( ( yyvsp [ 0 ] . c_string ) ) ; ERROR_IF ( compiler -> last_result != ERROR_SUCCESS ) ; ( yyval . c_string ) = ( yyvsp [ - 1 ] . c_string ) ; } # line 1874 \"grammar.c\" break ; case 25 : # line 424 \"grammar.y\" { ( yyval . meta ) = ( yyvsp [ 0 ] . meta ) ; } # line 1880 \"grammar.c\" break ; case 26 : # line 425 \"grammar.y\" { ( yyval . meta ) = ( yyvsp [ - 1 ] . meta ) ; } # line 1886 \"grammar.c\" break ; case 27 : # line 431 \"grammar.y\" { SIZED_STRING * sized_string = ( yyvsp [ 0 ] . sized_string ) ; ( yyval . meta ) = yr_parser_reduce_meta_declaration ( yyscanner , META_TYPE_STRING , ( yyvsp [ - 2 ] . c_string ) , sized_string -> c_string , 0 ) ; yr_free ( ( yyvsp [ - 2 ] . c_string ) ) ; yr_free ( ( yyvsp [ 0 ] . sized_string ) ) ; ERROR_IF ( ( yyval . meta ) == NULL ) ; } # line 1906 \"grammar.c\" break ; case 28 : # line 447 \"grammar.y\" { ( yyval . meta ) = yr_parser_reduce_meta_declaration ( yyscanner , META_TYPE_INTEGER , ( yyvsp [ - 2 ] . c_string ) , NULL , ( yyvsp [ 0 ] . integer ) ) ; yr_free ( ( yyvsp [ - 2 ] . c_string ) ) ; ERROR_IF ( ( yyval . meta ) == NULL ) ; } # line 1923 \"grammar.c\" break ; case 29 : # line 460 \"grammar.y\" { ( yyval . meta ) = yr_parser_reduce_meta_declaration ( yyscanner , META_TYPE_INTEGER , ( yyvsp [ - 3 ] . c_string ) , NULL , - ( yyvsp [ 0 ] . integer ) ) ; yr_free ( ( yyvsp [ - 3 ] . c_string ) ) ; ERROR_IF ( ( yyval . meta ) == NULL ) ; } # line 1940 \"grammar.c\" break ; case 30 : # line 473 \"grammar.y\" { ( yyval . meta ) = yr_parser_reduce_meta_declaration ( yyscanner , META_TYPE_BOOLEAN , ( yyvsp [ - 2 ] . c_string ) , NULL , TRUE ) ; yr_free ( ( yyvsp [ - 2 ] . c_string ) ) ; ERROR_IF ( ( yyval . meta ) == NULL ) ; } # line 1957 \"grammar.c\" break ; case 31 : # line 486 \"grammar.y\" { ( yyval . meta ) = yr_parser_reduce_meta_declaration ( yyscanner , META_TYPE_BOOLEAN , ( yyvsp [ - 2 ] . c_string ) , NULL , FALSE ) ; yr_free ( ( yyvsp [ - 2 ] . c_string ) ) ; ERROR_IF ( ( yyval . meta ) == NULL ) ; } # line 1974 \"grammar.c\" break ; case 32 : # line 502 \"grammar.y\" { ( yyval . string ) = ( yyvsp [ 0 ] . string ) ; } # line 1980 \"grammar.c\" break ; case 33 : # line 503 \"grammar.y\" { ( yyval . string ) = ( yyvsp [ - 1 ] . string ) ; } # line 1986 \"grammar.c\" break ; case 34 : # line 509 \"grammar.y\" { compiler -> error_line = yyget_lineno ( yyscanner ) ; } # line 1994 \"grammar.c\" break ; case 35 : # line 513 \"grammar.y\" { ( yyval . string ) = yr_parser_reduce_string_declaration ( yyscanner , ( int32_t ) ( yyvsp [ 0 ] . integer ) , ( yyvsp [ - 4 ] . c_string ) , ( yyvsp [ - 1 ] . sized_string ) ) ; yr_free ( ( yyvsp [ - 4 ] . c_string ) ) ; yr_free ( ( yyvsp [ - 1 ] . sized_string ) ) ; ERROR_IF ( ( yyval . string ) == NULL ) ; compiler -> error_line = 0 ; } # line 2009 \"grammar.c\" break ; case 36 : # line 524 \"grammar.y\" { compiler -> error_line = yyget_lineno ( yyscanner ) ; } # line 2017 \"grammar.c\" break ; case 37 : # line 528 \"grammar.y\" { ( yyval . string ) = yr_parser_reduce_string_declaration ( yyscanner , ( int32_t ) ( yyvsp [ 0 ] . integer ) | STRING_GFLAGS_REGEXP , ( yyvsp [ - 4 ] . c_string ) , ( yyvsp [ - 1 ] . sized_string ) ) ; yr_free ( ( yyvsp [ - 4 ] . c_string ) ) ; yr_free ( ( yyvsp [ - 1 ] . sized_string ) ) ; ERROR_IF ( ( yyval . string ) == NULL ) ; compiler -> error_line = 0 ; } # line 2033 \"grammar.c\" break ; case 38 : # line 540 \"grammar.y\" { ( yyval . string ) = yr_parser_reduce_string_declaration ( yyscanner , STRING_GFLAGS_HEXADECIMAL , ( yyvsp [ - 2 ] . c_string ) , ( yyvsp [ 0 ] . sized_string ) ) ; yr_free ( ( yyvsp [ - 2 ] . c_string ) ) ; yr_free ( ( yyvsp [ 0 ] . sized_string ) ) ; ERROR_IF ( ( yyval . string ) == NULL ) ; } # line 2047 \"grammar.c\" break ; case 39 : # line 553 \"grammar.y\" { ( yyval . integer ) = 0 ; } # line 2053 \"grammar.c\" break ; case 40 : # line 554 \"grammar.y\" { ( yyval . integer ) = ( yyvsp [ - 1 ] . integer ) | ( yyvsp [ 0 ] . integer ) ; } # line 2059 \"grammar.c\" break ; case 41 : # line 559 \"grammar.y\" { ( yyval . integer ) = STRING_GFLAGS_WIDE ; } # line 2065 \"grammar.c\" break ; case 42 : # line 560 \"grammar.y\" { ( yyval . integer ) = STRING_GFLAGS_ASCII ; } # line 2071 \"grammar.c\" break ; case 43 : # line 561 \"grammar.y\" { ( yyval . integer ) = STRING_GFLAGS_NO_CASE ; } # line 2077 \"grammar.c\" break ; case 44 : # line 562 \"grammar.y\" { ( yyval . integer ) = STRING_GFLAGS_FULL_WORD ; } # line 2083 \"grammar.c\" break ; case 45 : # line 568 \"grammar.y\" { int var_index = yr_parser_lookup_loop_variable ( yyscanner , ( yyvsp [ 0 ] . c_string ) ) ; if ( var_index >= 0 ) { compiler -> last_result = yr_parser_emit_with_arg ( yyscanner , OP_PUSH_M , LOOP_LOCAL_VARS * var_index , NULL , NULL ) ; ( yyval . expression ) . type = EXPRESSION_TYPE_INTEGER ; ( yyval . expression ) . value . integer = UNDEFINED ; ( yyval . expression ) . identifier = compiler -> loop_identifier [ var_index ] ; } else { YR_OBJECT * object = ( YR_OBJECT * ) yr_hash_table_lookup ( compiler -> objects_table , ( yyvsp [ 0 ] . c_string ) , NULL ) ; if ( object == NULL ) { char * ns = compiler -> current_namespace -> name ; object = ( YR_OBJECT * ) yr_hash_table_lookup ( compiler -> objects_table , ( yyvsp [ 0 ] . c_string ) , ns ) ; } if ( object != NULL ) { char * id ; compiler -> last_result = yr_arena_write_string ( compiler -> sz_arena , ( yyvsp [ 0 ] . c_string ) , & id ) ; if ( compiler -> last_result == ERROR_SUCCESS ) compiler -> last_result = yr_parser_emit_with_arg_reloc ( yyscanner , OP_OBJ_LOAD , id , NULL , NULL ) ; ( yyval . expression ) . type = EXPRESSION_TYPE_OBJECT ; ( yyval . expression ) . value . object = object ; ( yyval . expression ) . identifier = object -> identifier ; } else { YR_RULE * rule = ( YR_RULE * ) yr_hash_table_lookup ( compiler -> rules_table , ( yyvsp [ 0 ] . c_string ) , compiler -> current_namespace -> name ) ; if ( rule != NULL ) { compiler -> last_result = yr_parser_emit_with_arg_reloc ( yyscanner , OP_PUSH_RULE , rule , NULL , NULL ) ; ( yyval . expression ) . type = EXPRESSION_TYPE_BOOLEAN ; ( yyval . expression ) . value . integer = UNDEFINED ; ( yyval . expression ) . identifier = rule -> identifier ; } else { yr_compiler_set_error_extra_info ( compiler , ( yyvsp [ 0 ] . c_string ) ) ; compiler -> last_result = ERROR_UNDEFINED_IDENTIFIER ; } } } yr_free ( ( yyvsp [ 0 ] . c_string ) ) ; ERROR_IF ( compiler -> last_result != ERROR_SUCCESS ) ; } # line 2172 \"grammar.c\" break ; case 46 : # line 653 \"grammar.y\" { YR_OBJECT * field = NULL ; if ( ( yyvsp [ - 2 ] . expression ) . type == EXPRESSION_TYPE_OBJECT && ( yyvsp [ - 2 ] . expression ) . value . object -> type == OBJECT_TYPE_STRUCTURE ) { field = yr_object_lookup_field ( ( yyvsp [ - 2 ] . expression ) . value . object , ( yyvsp [ 0 ] . c_string ) ) ; if ( field != NULL ) { char * ident ; compiler -> last_result = yr_arena_write_string ( compiler -> sz_arena , ( yyvsp [ 0 ] . c_string ) , & ident ) ; if ( compiler -> last_result == ERROR_SUCCESS ) compiler -> last_result = yr_parser_emit_with_arg_reloc ( yyscanner , OP_OBJ_FIELD , ident , NULL , NULL ) ; ( yyval . expression ) . type = EXPRESSION_TYPE_OBJECT ; ( yyval . expression ) . value . object = field ; ( yyval . expression ) . identifier = field -> identifier ; } else { yr_compiler_set_error_extra_info ( compiler , ( yyvsp [ 0 ] . c_string ) ) ; compiler -> last_result = ERROR_INVALID_FIELD_NAME ; } } else { yr_compiler_set_error_extra_info ( compiler , ( yyvsp [ - 2 ] . expression ) . identifier ) ; compiler -> last_result = ERROR_NOT_A_STRUCTURE ; } yr_free ( ( yyvsp [ 0 ] . c_string ) ) ; ERROR_IF ( compiler -> last_result != ERROR_SUCCESS ) ; } # line 2222 \"grammar.c\" break ; case 47 : # line 699 \"grammar.y\" { YR_OBJECT_ARRAY * array ; YR_OBJECT_DICTIONARY * dict ; if ( ( yyvsp [ - 3 ] . expression ) . type == EXPRESSION_TYPE_OBJECT && ( yyvsp [ - 3 ] . expression ) . value . object -> type == OBJECT_TYPE_ARRAY ) { if ( ( yyvsp [ - 1 ] . expression ) . type != EXPRESSION_TYPE_INTEGER ) { yr_compiler_set_error_extra_info ( compiler , \"array<S2SV_blank>indexes<S2SV_blank>must<S2SV_blank>be<S2SV_blank>of<S2SV_blank>integer<S2SV_blank>type\" ) ; compiler -> last_result = ERROR_WRONG_TYPE ; } ERROR_IF ( compiler -> last_result != ERROR_SUCCESS ) ; compiler -> last_result = yr_parser_emit ( yyscanner , OP_INDEX_ARRAY , NULL ) ; array = ( YR_OBJECT_ARRAY * ) ( yyvsp [ - 3 ] . expression ) . value . object ; ( yyval . expression ) . type = EXPRESSION_TYPE_OBJECT ; ( yyval . expression ) . value . object = array -> prototype_item ; ( yyval . expression ) . identifier = array -> identifier ; } else if ( ( yyvsp [ - 3 ] . expression ) . type == EXPRESSION_TYPE_OBJECT && ( yyvsp [ - 3 ] . expression ) . value . object -> type == OBJECT_TYPE_DICTIONARY ) { if ( ( yyvsp [ - 1 ] . expression ) . type != EXPRESSION_TYPE_STRING ) { yr_compiler_set_error_extra_info ( compiler , \"dictionary<S2SV_blank>keys<S2SV_blank>must<S2SV_blank>be<S2SV_blank>of<S2SV_blank>string<S2SV_blank>type\" ) ; compiler -> last_result = ERROR_WRONG_TYPE ; } ERROR_IF ( compiler -> last_result != ERROR_SUCCESS ) ; compiler -> last_result = yr_parser_emit ( yyscanner , OP_LOOKUP_DICT , NULL ) ; dict = ( YR_OBJECT_DICTIONARY * ) ( yyvsp [ - 3 ] . expression ) . value . object ; ( yyval . expression ) . type = EXPRESSION_TYPE_OBJECT ; ( yyval . expression ) . value . object = dict -> prototype_item ; ( yyval . expression ) . identifier = dict -> identifier ; } else { yr_compiler_set_error_extra_info ( compiler , ( yyvsp [ - 3 ] . expression ) . identifier ) ; compiler -> last_result = ERROR_NOT_INDEXABLE ; } ERROR_IF ( compiler -> last_result != ERROR_SUCCESS ) ; } # line 2283 \"grammar.c\" break ; case 48 : # line 757 \"grammar.y\" { YR_OBJECT_FUNCTION * function ; char * args_fmt ; if ( ( yyvsp [ - 3 ] . expression ) . type == EXPRESSION_TYPE_OBJECT && ( yyvsp [ - 3 ] . expression ) . value . object -> type == OBJECT_TYPE_FUNCTION ) { compiler -> last_result = yr_parser_check_types ( compiler , ( YR_OBJECT_FUNCTION * ) ( yyvsp [ - 3 ] . expression ) . value . object , ( yyvsp [ - 1 ] . c_string ) ) ; if ( compiler -> last_result == ERROR_SUCCESS ) compiler -> last_result = yr_arena_write_string ( compiler -> sz_arena , ( yyvsp [ - 1 ] . c_string ) , & args_fmt ) ; if ( compiler -> last_result == ERROR_SUCCESS ) compiler -> last_result = yr_parser_emit_with_arg_reloc ( yyscanner , OP_CALL , args_fmt , NULL , NULL ) ; function = ( YR_OBJECT_FUNCTION * ) ( yyvsp [ - 3 ] . expression ) . value . object ; ( yyval . expression ) . type = EXPRESSION_TYPE_OBJECT ; ( yyval . expression ) . value . object = function -> return_obj ; ( yyval . expression ) . identifier = function -> identifier ; } else { yr_compiler_set_error_extra_info ( compiler , ( yyvsp [ - 3 ] . expression ) . identifier ) ; compiler -> last_result = ERROR_NOT_A_FUNCTION ; } yr_free ( ( yyvsp [ - 1 ] . c_string ) ) ; ERROR_IF ( compiler -> last_result != ERROR_SUCCESS ) ; } # line 2328 \"grammar.c\" break ; case 49 : # line 801 \"grammar.y\" { ( yyval . c_string ) = yr_strdup ( \"\" ) ; } # line 2334 \"grammar.c\" break ; case 50 : # line 802 \"grammar.y\" { ( yyval . c_string ) = ( yyvsp [ 0 ] . c_string ) ; } # line 2340 \"grammar.c\" break ; case 51 : # line 807 \"grammar.y\" { ( yyval . c_string ) = ( char * ) yr_malloc ( MAX_FUNCTION_ARGS + 1 ) ; switch ( ( yyvsp [ 0 ] . expression ) . type ) { case EXPRESSION_TYPE_INTEGER : strlcpy ( ( yyval . c_string ) , \"i\" , MAX_FUNCTION_ARGS ) ; break ; case EXPRESSION_TYPE_FLOAT : strlcpy ( ( yyval . c_string ) , \"f\" , MAX_FUNCTION_ARGS ) ; break ; case EXPRESSION_TYPE_BOOLEAN : strlcpy ( ( yyval . c_string ) , \"b\" , MAX_FUNCTION_ARGS ) ; break ; case EXPRESSION_TYPE_STRING : strlcpy ( ( yyval . c_string ) , \"s\" , MAX_FUNCTION_ARGS ) ; break ; case EXPRESSION_TYPE_REGEXP : strlcpy ( ( yyval . c_string ) , \"r\" , MAX_FUNCTION_ARGS ) ; break ; <S2SV_StartBug> } <S2SV_EndBug> ERROR_IF ( ( yyval . c_string ) == NULL ) ; } <S2SV_StartBug> # line 2369 \"grammar.c\" <S2SV_EndBug> break ; case 52 : <S2SV_StartBug> # line 832 \"grammar.y\" <S2SV_EndBug> { if ( strlen ( ( yyvsp [ - 2 ] . c_string ) ) == MAX_FUNCTION_ARGS ) { compiler -> last_result = ERROR_TOO_MANY_ARGUMENTS ; } else { switch ( ( yyvsp [ 0 ] . expression ) . type ) { case EXPRESSION_TYPE_INTEGER : strlcat ( ( yyvsp [ - 2 ] . c_string ) , \"i\" , MAX_FUNCTION_ARGS ) ; break ; case EXPRESSION_TYPE_FLOAT : strlcat ( ( yyvsp [ - 2 ] . c_string ) , \"f\" , MAX_FUNCTION_ARGS ) ; break ; case EXPRESSION_TYPE_BOOLEAN : strlcat ( ( yyvsp [ - 2 ] . c_string ) , \"b\" , MAX_FUNCTION_ARGS ) ; break ; case EXPRESSION_TYPE_STRING : strlcat ( ( yyvsp [ - 2 ] . c_string ) , \"s\" , MAX_FUNCTION_ARGS ) ; break ; case EXPRESSION_TYPE_REGEXP : strlcat ( ( yyvsp [ - 2 ] . c_string ) , \"r\" , MAX_FUNCTION_ARGS ) ; break ; <S2SV_StartBug> } <S2SV_EndBug> } ERROR_IF ( compiler -> last_result != ERROR_SUCCESS ) ; ( yyval . c_string ) = ( yyvsp [ - 2 ] . c_string ) ; } <S2SV_StartBug> # line 2405 \"grammar.c\" <S2SV_EndBug> break ; case 53 : <S2SV_StartBug> # line 868 \"grammar.y\" <S2SV_EndBug> { SIZED_STRING * sized_string = ( yyvsp [ 0 ] . sized_string ) ; RE * re ; RE_ERROR error ; int re_flags = 0 ; if ( sized_string -> flags & SIZED_STRING_FLAGS_NO_CASE ) re_flags |= RE_FLAGS_NO_CASE ; if ( sized_string -> flags & SIZED_STRING_FLAGS_DOT_ALL ) re_flags |= RE_FLAGS_DOT_ALL ; compiler -> last_result = yr_re_compile ( sized_string -> c_string , re_flags , compiler -> re_code_arena , & re , & error ) ; yr_free ( ( yyvsp [ 0 ] . sized_string ) ) ; if ( compiler -> last_result == ERROR_INVALID_REGULAR_EXPRESSION ) yr_compiler_set_error_extra_info ( compiler , error . message ) ; ERROR_IF ( compiler -> last_result != ERROR_SUCCESS ) ; if ( compiler -> last_result == ERROR_SUCCESS ) compiler -> last_result = yr_parser_emit_with_arg_reloc ( yyscanner , OP_PUSH , re -> root_node -> forward_code , NULL , NULL ) ; yr_re_destroy ( re ) ; ERROR_IF ( compiler -> last_result != ERROR_SUCCESS ) ; ( yyval . expression ) . type = EXPRESSION_TYPE_REGEXP ; } <S2SV_StartBug> # line 2451 \"grammar.c\" <S2SV_EndBug> break ; case 54 : <S2SV_StartBug> # line 914 \"grammar.y\" <S2SV_EndBug> { if ( ( yyvsp [ 0 ] . expression ) . type == EXPRESSION_TYPE_STRING ) { if ( ( yyvsp [ 0 ] . expression ) . value . sized_string != NULL ) { yywarning ( yyscanner , \"Using<S2SV_blank>literal<S2SV_blank>string<S2SV_blank>\\\\\"%s\\\\\"<S2SV_blank>in<S2SV_blank>a<S2SV_blank>boolean<S2SV_blank>operation.\" , ( yyvsp [ 0 ] . expression ) . value . sized_string -> c_string ) ; } compiler -> last_result = yr_parser_emit ( yyscanner , OP_STR_TO_BOOL , NULL ) ; ERROR_IF ( compiler -> last_result != ERROR_SUCCESS ) ; } ( yyval . expression ) . type = EXPRESSION_TYPE_BOOLEAN ; } <S2SV_StartBug> # line 2474 \"grammar.c\" <S2SV_EndBug> break ; case 55 : <S2SV_StartBug> # line 936 \"grammar.y\" <S2SV_EndBug> { compiler -> last_result = yr_parser_emit_with_arg ( yyscanner , OP_PUSH , 1 , NULL , NULL ) ; ERROR_IF ( compiler -> last_result != ERROR_SUCCESS ) ; ( yyval . expression ) . type = EXPRESSION_TYPE_BOOLEAN ; } <S2SV_StartBug> # line 2487 \"grammar.c\" <S2SV_EndBug> break ; case 56 : <S2SV_StartBug> # line 945 \"grammar.y\" <S2SV_EndBug> { compiler -> last_result = yr_parser_emit_with_arg ( yyscanner , OP_PUSH , 0 , NULL , NULL ) ; ERROR_IF ( compiler -> last_result != ERROR_SUCCESS ) ; ( yyval . expression ) . type = EXPRESSION_TYPE_BOOLEAN ; } <S2SV_StartBug> # line 2500 \"grammar.c\" <S2SV_EndBug> break ; case 57 : <S2SV_StartBug> # line 954 \"grammar.y\" <S2SV_EndBug> { CHECK_TYPE ( ( yyvsp [ - 2 ] . expression ) , EXPRESSION_TYPE_STRING , \"matches\" ) ; CHECK_TYPE ( ( yyvsp [ 0 ] . expression ) , EXPRESSION_TYPE_REGEXP , \"matches\" ) ; if ( compiler -> last_result == ERROR_SUCCESS ) compiler -> last_result = yr_parser_emit ( yyscanner , OP_MATCHES , NULL ) ; ERROR_IF ( compiler -> last_result != ERROR_SUCCESS ) ; ( yyval . expression ) . type = EXPRESSION_TYPE_BOOLEAN ; } <S2SV_StartBug> # line 2519 \"grammar.c\" <S2SV_EndBug> break ; case 58 : <S2SV_StartBug> # line 969 \"grammar.y\" <S2SV_EndBug> { CHECK_TYPE ( ( yyvsp [ - 2 ] . expression ) , EXPRESSION_TYPE_STRING , \"contains\" ) ; CHECK_TYPE ( ( yyvsp [ 0 ] . expression ) , EXPRESSION_TYPE_STRING , \"contains\" ) ; compiler -> last_result = yr_parser_emit ( yyscanner , OP_CONTAINS , NULL ) ; ERROR_IF ( compiler -> last_result != ERROR_SUCCESS ) ; ( yyval . expression ) . type = EXPRESSION_TYPE_BOOLEAN ; } <S2SV_StartBug> # line 2535 \"grammar.c\" <S2SV_EndBug> break ; case 59 : <S2SV_StartBug> # line 981 \"grammar.y\" <S2SV_EndBug> { int result = yr_parser_reduce_string_identifier ( yyscanner , ( yyvsp [ 0 ] . c_string ) , OP_FOUND , UNDEFINED ) ; yr_free ( ( yyvsp [ 0 ] . c_string ) ) ; ERROR_IF ( result != ERROR_SUCCESS ) ; ( yyval . expression ) . type = EXPRESSION_TYPE_BOOLEAN ; } <S2SV_StartBug> # line 2553 \"grammar.c\" <S2SV_EndBug> break ; case 60 : <S2SV_StartBug> # line 995 \"grammar.y\" <S2SV_EndBug> { CHECK_TYPE ( ( yyvsp [ 0 ] . expression ) , EXPRESSION_TYPE_INTEGER , \"at\" ) ; compiler -> last_result = yr_parser_reduce_string_identifier ( yyscanner , ( yyvsp [ - 2 ] . c_string ) , OP_FOUND_AT , ( yyvsp [ 0 ] . expression ) . value . integer ) ; yr_free ( ( yyvsp [ - 2 ] . c_string ) ) ; ERROR_IF ( compiler -> last_result != ERROR_SUCCESS ) ; ( yyval . expression ) . type = EXPRESSION_TYPE_BOOLEAN ; } <S2SV_StartBug> # line 2570 \"grammar.c\" <S2SV_EndBug> break ; case 61 : <S2SV_StartBug> # line 1008 \"grammar.y\" <S2SV_EndBug> { compiler -> last_result = yr_parser_reduce_string_identifier ( yyscanner , ( yyvsp [ - 2 ] . c_string ) , OP_FOUND_IN , UNDEFINED ) ; yr_free ( ( yyvsp [ - 2 ] . c_string ) ) ; ERROR_IF ( compiler -> last_result != ERROR_SUCCESS ) ; ( yyval . expression ) . type = EXPRESSION_TYPE_BOOLEAN ; } <S2SV_StartBug> # line 2585 \"grammar.c\" <S2SV_EndBug> break ; case 62 : <S2SV_StartBug> # line 1019 \"grammar.y\" <S2SV_EndBug> { if ( compiler -> loop_depth > 0 ) { compiler -> loop_depth -- ; compiler -> loop_identifier [ compiler -> loop_depth ] = NULL ; } <S2SV_StartBug> } <S2SV_EndBug> # line 2597 \"grammar.c\" break ; case 63 : <S2SV_StartBug> # line 1027 \"grammar.y\" <S2SV_EndBug> { int var_index ; if ( compiler -> loop_depth == MAX_LOOP_NESTING ) compiler -> last_result = ERROR_LOOP_NESTING_LIMIT_EXCEEDED ; ERROR_IF ( compiler -> last_result != ERROR_SUCCESS ) ; var_index = yr_parser_lookup_loop_variable ( yyscanner , ( yyvsp [ - 1 ] . c_string ) ) ; if ( var_index >= 0 ) { yr_compiler_set_error_extra_info ( compiler , ( yyvsp [ - 1 ] . c_string ) ) ; compiler -> last_result = ERROR_DUPLICATED_LOOP_IDENTIFIER ; } ERROR_IF ( compiler -> last_result != ERROR_SUCCESS ) ; compiler -> last_result = yr_parser_emit_with_arg ( yyscanner , OP_PUSH , UNDEFINED , NULL , NULL ) ; ERROR_IF ( compiler -> last_result != ERROR_SUCCESS ) ; } <S2SV_StartBug> # line 2631 \"grammar.c\" <S2SV_EndBug> break ; case 64 : <S2SV_StartBug> # line 1057 \"grammar.y\" <S2SV_EndBug> { int mem_offset = LOOP_LOCAL_VARS * compiler -> loop_depth ; uint8_t * addr ; yr_parser_emit_with_arg ( yyscanner , OP_CLEAR_M , mem_offset + 1 , NULL , NULL ) ; yr_parser_emit_with_arg ( yyscanner , OP_CLEAR_M , mem_offset + 2 , NULL , NULL ) ; if ( ( yyvsp [ - 1 ] . integer ) == INTEGER_SET_ENUMERATION ) { yr_parser_emit_with_arg ( yyscanner , OP_POP_M , mem_offset , & addr , NULL ) ; } else { yr_parser_emit_with_arg ( yyscanner , OP_POP_M , mem_offset + 3 , & addr , NULL ) ; yr_parser_emit_with_arg ( yyscanner , OP_POP_M , mem_offset , NULL , NULL ) ; } compiler -> loop_address [ compiler -> loop_depth ] = addr ; compiler -> loop_identifier [ compiler -> loop_depth ] = ( yyvsp [ - 4 ] . c_string ) ; compiler -> loop_depth ++ ; } <S2SV_StartBug> # line 2670 \"grammar.c\" <S2SV_EndBug> break ; case 65 : <S2SV_StartBug> # line 1092 \"grammar.y\" <S2SV_EndBug> { int mem_offset ; compiler -> loop_depth -- ; mem_offset = LOOP_LOCAL_VARS * compiler -> loop_depth ; yr_parser_emit_with_arg ( yyscanner , OP_ADD_M , mem_offset + 1 , NULL , NULL ) ; yr_parser_emit_with_arg ( yyscanner , OP_INCR_M , mem_offset + 2 , NULL , NULL ) ; if ( ( yyvsp [ - 5 ] . integer ) == INTEGER_SET_ENUMERATION ) { yr_parser_emit_with_arg_reloc ( yyscanner , OP_JNUNDEF , compiler -> loop_address [ compiler -> loop_depth ] , NULL , NULL ) ; } else { yr_parser_emit_with_arg ( yyscanner , OP_INCR_M , mem_offset , NULL , NULL ) ; yr_parser_emit_with_arg ( yyscanner , OP_PUSH_M , mem_offset , NULL , NULL ) ; yr_parser_emit_with_arg ( yyscanner , OP_PUSH_M , mem_offset + 3 , NULL , NULL ) ; yr_parser_emit_with_arg_reloc ( yyscanner , OP_JLE , compiler -> loop_address [ compiler -> loop_depth ] , NULL , NULL ) ; yr_parser_emit ( yyscanner , OP_POP , NULL ) ; yr_parser_emit ( yyscanner , OP_POP , NULL ) ; } yr_parser_emit ( yyscanner , OP_POP , NULL ) ; yr_parser_emit_with_arg ( yyscanner , OP_SWAPUNDEF , mem_offset + 2 , NULL , NULL ) ; yr_parser_emit_with_arg ( yyscanner , OP_PUSH_M , mem_offset + 1 , NULL , NULL ) ; yr_parser_emit ( yyscanner , OP_INT_LE , NULL ) ; compiler -> loop_identifier [ compiler -> loop_depth ] = NULL ; yr_free ( ( yyvsp [ - 8 ] . c_string ) ) ; ( yyval . expression ) . type = EXPRESSION_TYPE_BOOLEAN ; } <S2SV_StartBug> # line 2753 \"grammar.c\" <S2SV_EndBug> break ; case 66 : <S2SV_StartBug> # line 1171 \"grammar.y\" <S2SV_EndBug> { int mem_offset = LOOP_LOCAL_VARS * compiler -> loop_depth ; uint8_t * addr ; if ( compiler -> loop_depth == MAX_LOOP_NESTING ) compiler -> last_result = ERROR_LOOP_NESTING_LIMIT_EXCEEDED ; if ( compiler -> loop_for_of_mem_offset != - 1 ) compiler -> last_result = ERROR_NESTED_FOR_OF_LOOP ; ERROR_IF ( compiler -> last_result != ERROR_SUCCESS ) ; yr_parser_emit_with_arg ( yyscanner , OP_CLEAR_M , mem_offset + 1 , NULL , NULL ) ; yr_parser_emit_with_arg ( yyscanner , OP_CLEAR_M , mem_offset + 2 , NULL , NULL ) ; yr_parser_emit_with_arg ( yyscanner , OP_POP_M , mem_offset , & addr , NULL ) ; compiler -> loop_for_of_mem_offset = mem_offset ; compiler -> loop_address [ compiler -> loop_depth ] = addr ; compiler -> loop_identifier [ compiler -> loop_depth ] = NULL ; compiler -> loop_depth ++ ; } <S2SV_StartBug> # line 2787 \"grammar.c\" <S2SV_EndBug> break ; case 67 : <S2SV_StartBug> # line 1201 \"grammar.y\" <S2SV_EndBug> { int mem_offset ; compiler -> loop_depth -- ; compiler -> loop_for_of_mem_offset = - 1 ; mem_offset = LOOP_LOCAL_VARS * compiler -> loop_depth ; yr_parser_emit_with_arg ( yyscanner , OP_ADD_M , mem_offset + 1 , NULL , NULL ) ; yr_parser_emit_with_arg ( yyscanner , OP_INCR_M , mem_offset + 2 , NULL , NULL ) ; yr_parser_emit_with_arg_reloc ( yyscanner , OP_JNUNDEF , compiler -> loop_address [ compiler -> loop_depth ] , NULL , NULL ) ; yr_parser_emit ( yyscanner , OP_POP , NULL ) ; yr_parser_emit_with_arg ( yyscanner , OP_SWAPUNDEF , mem_offset + 2 , NULL , NULL ) ; yr_parser_emit_with_arg ( yyscanner , OP_PUSH_M , mem_offset + 1 , NULL , NULL ) ; yr_parser_emit ( yyscanner , OP_INT_LE , NULL ) ; ( yyval . expression ) . type = EXPRESSION_TYPE_BOOLEAN ; } <S2SV_StartBug> # line 2840 \"grammar.c\" <S2SV_EndBug> break ; case 68 : <S2SV_StartBug> # line 1250 \"grammar.y\" <S2SV_EndBug> { yr_parser_emit ( yyscanner , OP_OF , NULL ) ; ( yyval . expression ) . type = EXPRESSION_TYPE_BOOLEAN ; } <S2SV_StartBug> # line 2850 \"grammar.c\" <S2SV_EndBug> break ; case 69 : <S2SV_StartBug> # line 1256 \"grammar.y\" <S2SV_EndBug> { yr_parser_emit ( yyscanner , OP_NOT , NULL ) ; ( yyval . expression ) . type = EXPRESSION_TYPE_BOOLEAN ; } <S2SV_StartBug> # line 2860 \"grammar.c\" <S2SV_EndBug> break ; case 70 : <S2SV_StartBug> # line 1262 \"grammar.y\" <S2SV_EndBug> { YR_FIXUP * fixup ; void * jmp_destination_addr ; compiler -> last_result = yr_parser_emit_with_arg_reloc ( yyscanner , OP_JFALSE , 0 , NULL , & jmp_destination_addr ) ; ERROR_IF ( compiler -> last_result != ERROR_SUCCESS ) ; fixup = ( YR_FIXUP * ) yr_malloc ( sizeof ( YR_FIXUP ) ) ; if ( fixup == NULL ) compiler -> last_error = ERROR_INSUFFICIENT_MEMORY ; ERROR_IF ( compiler -> last_result != ERROR_SUCCESS ) ; fixup -> address = jmp_destination_addr ; fixup -> next = compiler -> fixup_stack_head ; compiler -> fixup_stack_head = fixup ; } <S2SV_StartBug> # line 2890 \"grammar.c\" <S2SV_EndBug> break ; case 71 : <S2SV_StartBug> # line 1288 \"grammar.y\" <S2SV_EndBug> { YR_FIXUP * fixup ; uint8_t * and_addr ; compiler -> last_result = yr_arena_reserve_memory ( compiler -> code_arena , 2 ) ; ERROR_IF ( compiler -> last_result != ERROR_SUCCESS ) ; compiler -> last_result = yr_parser_emit ( yyscanner , OP_AND , & and_addr ) ; ERROR_IF ( compiler -> last_result != ERROR_SUCCESS ) ; fixup = compiler -> fixup_stack_head ; * ( void * * ) ( fixup -> address ) = ( void * ) ( and_addr + 1 ) ; compiler -> fixup_stack_head = fixup -> next ; yr_free ( fixup ) ; ( yyval . expression ) . type = EXPRESSION_TYPE_BOOLEAN ; } <S2SV_StartBug> # line 2930 \"grammar.c\" <S2SV_EndBug> break ; case 72 : <S2SV_StartBug> # line 1324 \"grammar.y\" <S2SV_EndBug> { YR_FIXUP * fixup ; void * jmp_destination_addr ; compiler -> last_result = yr_parser_emit_with_arg_reloc ( yyscanner , OP_JTRUE , 0 , NULL , & jmp_destination_addr ) ; ERROR_IF ( compiler -> last_result != ERROR_SUCCESS ) ; fixup = ( YR_FIXUP * ) yr_malloc ( sizeof ( YR_FIXUP ) ) ; if ( fixup == NULL ) compiler -> last_error = ERROR_INSUFFICIENT_MEMORY ; ERROR_IF ( compiler -> last_result != ERROR_SUCCESS ) ; fixup -> address = jmp_destination_addr ; fixup -> next = compiler -> fixup_stack_head ; compiler -> fixup_stack_head = fixup ; } <S2SV_StartBug> # line 2959 \"grammar.c\" <S2SV_EndBug> break ; case 73 : <S2SV_StartBug> # line 1349 \"grammar.y\" <S2SV_EndBug> { YR_FIXUP * fixup ; uint8_t * or_addr ; compiler -> last_result = yr_arena_reserve_memory ( compiler -> code_arena , 2 ) ; ERROR_IF ( compiler -> last_result != ERROR_SUCCESS ) ; compiler -> last_result = yr_parser_emit ( yyscanner , OP_OR , & or_addr ) ; ERROR_IF ( compiler -> last_result != ERROR_SUCCESS ) ; fixup = compiler -> fixup_stack_head ; * ( void * * ) ( fixup -> address ) = ( void * ) ( or_addr + 1 ) ; compiler -> fixup_stack_head = fixup -> next ; yr_free ( fixup ) ; ( yyval . expression ) . type = EXPRESSION_TYPE_BOOLEAN ; } <S2SV_StartBug> # line 2999 \"grammar.c\" <S2SV_EndBug> break ; case 74 : <S2SV_StartBug> # line 1385 \"grammar.y\" <S2SV_EndBug> { compiler -> last_result = yr_parser_reduce_operation ( yyscanner , \"<\" , ( yyvsp [ - 2 ] . expression ) , ( yyvsp [ 0 ] . expression ) ) ; ERROR_IF ( compiler -> last_result != ERROR_SUCCESS ) ; ( yyval . expression ) . type = EXPRESSION_TYPE_BOOLEAN ; } <S2SV_StartBug> # line 3012 \"grammar.c\" <S2SV_EndBug> break ; case 75 : <S2SV_StartBug> # line 1394 \"grammar.y\" <S2SV_EndBug> { compiler -> last_result = yr_parser_reduce_operation ( yyscanner , \">\" , ( yyvsp [ - 2 ] . expression ) , ( yyvsp [ 0 ] . expression ) ) ; ERROR_IF ( compiler -> last_result != ERROR_SUCCESS ) ; ( yyval . expression ) . type = EXPRESSION_TYPE_BOOLEAN ; } <S2SV_StartBug> # line 3025 \"grammar.c\" <S2SV_EndBug> break ; case 76 : <S2SV_StartBug> # line 1403 \"grammar.y\" <S2SV_EndBug> { compiler -> last_result = yr_parser_reduce_operation ( yyscanner , \"<=\" , ( yyvsp [ - 2 ] . expression ) , ( yyvsp [ 0 ] . expression ) ) ; ERROR_IF ( compiler -> last_result != ERROR_SUCCESS ) ; ( yyval . expression ) . type = EXPRESSION_TYPE_BOOLEAN ; } <S2SV_StartBug> # line 3038 \"grammar.c\" <S2SV_EndBug> break ; case 77 : <S2SV_StartBug> # line 1412 \"grammar.y\" <S2SV_EndBug> { compiler -> last_result = yr_parser_reduce_operation ( yyscanner , \">=\" , ( yyvsp [ - 2 ] . expression ) , ( yyvsp [ 0 ] . expression ) ) ; ERROR_IF ( compiler -> last_result != ERROR_SUCCESS ) ; ( yyval . expression ) . type = EXPRESSION_TYPE_BOOLEAN ; } <S2SV_StartBug> # line 3051 \"grammar.c\" <S2SV_EndBug> break ; case 78 : <S2SV_StartBug> # line 1421 \"grammar.y\" <S2SV_EndBug> { compiler -> last_result = yr_parser_reduce_operation ( yyscanner , \"==\" , ( yyvsp [ - 2 ] . expression ) , ( yyvsp [ 0 ] . expression ) ) ; ERROR_IF ( compiler -> last_result != ERROR_SUCCESS ) ; ( yyval . expression ) . type = EXPRESSION_TYPE_BOOLEAN ; } <S2SV_StartBug> # line 3064 \"grammar.c\" <S2SV_EndBug> break ; case 79 : <S2SV_StartBug> # line 1430 \"grammar.y\" <S2SV_EndBug> { compiler -> last_result = yr_parser_reduce_operation ( yyscanner , \"!=\" , ( yyvsp [ - 2 ] . expression ) , ( yyvsp [ 0 ] . expression ) ) ; ERROR_IF ( compiler -> last_result != ERROR_SUCCESS ) ; ( yyval . expression ) . type = EXPRESSION_TYPE_BOOLEAN ; } <S2SV_StartBug> # line 3077 \"grammar.c\" <S2SV_EndBug> break ; case 80 : <S2SV_StartBug> # line 1439 \"grammar.y\" <S2SV_EndBug> { ( yyval . expression ) = ( yyvsp [ 0 ] . expression ) ; } <S2SV_StartBug> # line 3085 \"grammar.c\" <S2SV_EndBug> break ; case 81 : <S2SV_StartBug> # line 1443 \"grammar.y\" <S2SV_EndBug> { ( yyval . expression ) = ( yyvsp [ - 1 ] . expression ) ; } <S2SV_StartBug> # line 3093 \"grammar.c\" <S2SV_EndBug> break ; case 82 : <S2SV_StartBug> # line 1450 \"grammar.y\" <S2SV_EndBug> { ( yyval . integer ) = INTEGER_SET_ENUMERATION ; } <S2SV_StartBug> # line 3099 \"grammar.c\" <S2SV_EndBug> break ; case 83 : <S2SV_StartBug> # line 1451 \"grammar.y\" <S2SV_EndBug> { ( yyval . integer ) = INTEGER_SET_RANGE ; } <S2SV_StartBug> # line 3105 \"grammar.c\" <S2SV_EndBug> break ; case 84 : <S2SV_StartBug> # line 1457 \"grammar.y\" <S2SV_EndBug> { if ( ( yyvsp [ - 3 ] . expression ) . type != EXPRESSION_TYPE_INTEGER ) { yr_compiler_set_error_extra_info ( compiler , \"wrong<S2SV_blank>type<S2SV_blank>for<S2SV_blank>range\\'s<S2SV_blank>lower<S2SV_blank>bound\" ) ; compiler -> last_result = ERROR_WRONG_TYPE ; } if ( ( yyvsp [ - 1 ] . expression ) . type != EXPRESSION_TYPE_INTEGER ) { yr_compiler_set_error_extra_info ( compiler , \"wrong<S2SV_blank>type<S2SV_blank>for<S2SV_blank>range\\'s<S2SV_blank>upper<S2SV_blank>bound\" ) ; compiler -> last_result = ERROR_WRONG_TYPE ; } ERROR_IF ( compiler -> last_result != ERROR_SUCCESS ) ; } <S2SV_StartBug> # line 3127 \"grammar.c\" <S2SV_EndBug> break ; case 85 : <S2SV_StartBug> # line 1479 \"grammar.y\" <S2SV_EndBug> { if ( ( yyvsp [ 0 ] . expression ) . type != EXPRESSION_TYPE_INTEGER ) { yr_compiler_set_error_extra_info ( compiler , \"wrong<S2SV_blank>type<S2SV_blank>for<S2SV_blank>enumeration<S2SV_blank>item\" ) ; compiler -> last_result = ERROR_WRONG_TYPE ; } ERROR_IF ( compiler -> last_result != ERROR_SUCCESS ) ; } <S2SV_StartBug> # line 3143 \"grammar.c\" <S2SV_EndBug> break ; case 86 : <S2SV_StartBug> # line 1491 \"grammar.y\" <S2SV_EndBug> { if ( ( yyvsp [ 0 ] . expression ) . type != EXPRESSION_TYPE_INTEGER ) { yr_compiler_set_error_extra_info ( compiler , \"wrong<S2SV_blank>type<S2SV_blank>for<S2SV_blank>enumeration<S2SV_blank>item\" ) ; compiler -> last_result = ERROR_WRONG_TYPE ; } ERROR_IF ( compiler -> last_result != ERROR_SUCCESS ) ; } <S2SV_StartBug> # line 3158 \"grammar.c\" <S2SV_EndBug> break ; case 87 : <S2SV_StartBug> # line 1506 \"grammar.y\" <S2SV_EndBug> { yr_parser_emit_with_arg ( yyscanner , OP_PUSH , UNDEFINED , NULL , NULL ) ; } <S2SV_StartBug> # line 3167 \"grammar.c\" <S2SV_EndBug> break ; case 89 : <S2SV_StartBug> # line 1512 \"grammar.y\" <S2SV_EndBug> { yr_parser_emit_with_arg ( yyscanner , OP_PUSH , UNDEFINED , NULL , NULL ) ; yr_parser_emit_pushes_for_strings ( yyscanner , \"$*\" ) ; ERROR_IF ( compiler -> last_result != ERROR_SUCCESS ) ; } <S2SV_StartBug> # line 3178 \"grammar.c\" <S2SV_EndBug> break ; case 92 : <S2SV_StartBug> # line 1529 \"grammar.y\" <S2SV_EndBug> { yr_parser_emit_pushes_for_strings ( yyscanner , ( yyvsp [ 0 ] . c_string ) ) ; yr_free ( ( yyvsp [ 0 ] . c_string ) ) ; ERROR_IF ( compiler -> last_result != ERROR_SUCCESS ) ; } <S2SV_StartBug> # line 3189 \"grammar.c\" <S2SV_EndBug> break ; case 93 : <S2SV_StartBug> # line 1536 \"grammar.y\" <S2SV_EndBug> { yr_parser_emit_pushes_for_strings ( yyscanner , ( yyvsp [ 0 ] . c_string ) ) ; yr_free ( ( yyvsp [ 0 ] . c_string ) ) ; ERROR_IF ( compiler -> last_result != ERROR_SUCCESS ) ; } <S2SV_StartBug> # line 3200 \"grammar.c\" <S2SV_EndBug> break ; case 95 : <S2SV_StartBug> # line 1548 \"grammar.y\" <S2SV_EndBug> { yr_parser_emit_with_arg ( yyscanner , OP_PUSH , UNDEFINED , NULL , NULL ) ; } <S2SV_StartBug> # line 3208 \"grammar.c\" <S2SV_EndBug> break ; case 96 : <S2SV_StartBug> # line 1552 \"grammar.y\" <S2SV_EndBug> { yr_parser_emit_with_arg ( yyscanner , OP_PUSH , 1 , NULL , NULL ) ; } <S2SV_StartBug> # line 3216 \"grammar.c\" <S2SV_EndBug> break ; case 97 : <S2SV_StartBug> # line 1560 \"grammar.y\" <S2SV_EndBug> { ( yyval . expression ) = ( yyvsp [ - 1 ] . expression ) ; } <S2SV_StartBug> # line 3224 \"grammar.c\" <S2SV_EndBug> break ; case 98 : <S2SV_StartBug> # line 1564 \"grammar.y\" <S2SV_EndBug> { compiler -> last_result = yr_parser_emit ( yyscanner , OP_FILESIZE , NULL ) ; ERROR_IF ( compiler -> last_result != ERROR_SUCCESS ) ; ( yyval . expression ) . type = EXPRESSION_TYPE_INTEGER ; ( yyval . expression ) . value . integer = UNDEFINED ; } <S2SV_StartBug> # line 3238 \"grammar.c\" <S2SV_EndBug> break ; case 99 : <S2SV_StartBug> # line 1574 \"grammar.y\" <S2SV_EndBug> { yywarning ( yyscanner , \"Using<S2SV_blank>deprecated<S2SV_blank>\\\\\"entrypoint\\\\\"<S2SV_blank>keyword.<S2SV_blank>Use<S2SV_blank>the<S2SV_blank>\\\\\"entry_point\\\\\"<S2SV_blank>\" \"function<S2SV_blank>from<S2SV_blank>PE<S2SV_blank>module<S2SV_blank>instead.\" ) ; compiler -> last_result = yr_parser_emit ( yyscanner , OP_ENTRYPOINT , NULL ) ; ERROR_IF ( compiler -> last_result != ERROR_SUCCESS ) ; ( yyval . expression ) . type = EXPRESSION_TYPE_INTEGER ; ( yyval . expression ) . value . integer = UNDEFINED ; } <S2SV_StartBug> # line 3256 \"grammar.c\" <S2SV_EndBug> break ; case 100 : <S2SV_StartBug> # line 1588 \"grammar.y\" <S2SV_EndBug> { CHECK_TYPE ( ( yyvsp [ - 1 ] . expression ) , EXPRESSION_TYPE_INTEGER , \"intXXXX<S2SV_blank>or<S2SV_blank>uintXXXX\" ) ; compiler -> last_result = yr_parser_emit ( yyscanner , ( uint8_t ) ( OP_READ_INT + ( yyvsp [ - 3 ] . integer ) ) , NULL ) ; ERROR_IF ( compiler -> last_result != ERROR_SUCCESS ) ; ( yyval . expression ) . type = EXPRESSION_TYPE_INTEGER ; ( yyval . expression ) . value . integer = UNDEFINED ; } <S2SV_StartBug> # line 3276 \"grammar.c\" <S2SV_EndBug> break ; case 101 : <S2SV_StartBug> # line 1604 \"grammar.y\" <S2SV_EndBug> { compiler -> last_result = yr_parser_emit_with_arg ( yyscanner , OP_PUSH , ( yyvsp [ 0 ] . integer ) , NULL , NULL ) ; ERROR_IF ( compiler -> last_result != ERROR_SUCCESS ) ; ( yyval . expression ) . type = EXPRESSION_TYPE_INTEGER ; ( yyval . expression ) . value . integer = ( yyvsp [ 0 ] . integer ) ; } <S2SV_StartBug> # line 3290 \"grammar.c\" <S2SV_EndBug> break ; case 102 : <S2SV_StartBug> # line 1614 \"grammar.y\" <S2SV_EndBug> { compiler -> last_result = yr_parser_emit_with_arg_double ( yyscanner , OP_PUSH , ( yyvsp [ 0 ] . double_ ) , NULL , NULL ) ; ERROR_IF ( compiler -> last_result != ERROR_SUCCESS ) ; ( yyval . expression ) . type = EXPRESSION_TYPE_FLOAT ; } <S2SV_StartBug> # line 3303 \"grammar.c\" <S2SV_EndBug> break ; case 103 : <S2SV_StartBug> # line 1623 \"grammar.y\" <S2SV_EndBug> { SIZED_STRING * sized_string ; compiler -> last_result = yr_arena_write_data ( compiler -> sz_arena , ( yyvsp [ 0 ] . sized_string ) , ( yyvsp [ 0 ] . sized_string ) -> length + sizeof ( SIZED_STRING ) , ( void * * ) & sized_string ) ; yr_free ( ( yyvsp [ 0 ] . sized_string ) ) ; if ( compiler -> last_result == ERROR_SUCCESS ) compiler -> last_result = yr_parser_emit_with_arg_reloc ( yyscanner , OP_PUSH , sized_string , NULL , NULL ) ; ERROR_IF ( compiler -> last_result != ERROR_SUCCESS ) ; ( yyval . expression ) . type = EXPRESSION_TYPE_STRING ; ( yyval . expression ) . value . sized_string = sized_string ; } <S2SV_StartBug> # line 3332 \"grammar.c\" <S2SV_EndBug> break ; case 104 : <S2SV_StartBug> # line 1648 \"grammar.y\" <S2SV_EndBug> { compiler -> last_result = yr_parser_reduce_string_identifier ( yyscanner , ( yyvsp [ 0 ] . c_string ) , OP_COUNT , UNDEFINED ) ; yr_free ( ( yyvsp [ 0 ] . c_string ) ) ; ERROR_IF ( compiler -> last_result != ERROR_SUCCESS ) ; ( yyval . expression ) . type = EXPRESSION_TYPE_INTEGER ; ( yyval . expression ) . value . integer = UNDEFINED ; } <S2SV_StartBug> # line 3348 \"grammar.c\" <S2SV_EndBug> break ; case 105 : <S2SV_StartBug> # line 1660 \"grammar.y\" <S2SV_EndBug> { compiler -> last_result = yr_parser_reduce_string_identifier ( yyscanner , ( yyvsp [ - 3 ] . c_string ) , OP_OFFSET , UNDEFINED ) ; yr_free ( ( yyvsp [ - 3 ] . c_string ) ) ; ERROR_IF ( compiler -> last_result != ERROR_SUCCESS ) ; ( yyval . expression ) . type = EXPRESSION_TYPE_INTEGER ; ( yyval . expression ) . value . integer = UNDEFINED ; } <S2SV_StartBug> # line 3364 \"grammar.c\" <S2SV_EndBug> break ; case 106 : <S2SV_StartBug> # line 1672 \"grammar.y\" <S2SV_EndBug> { compiler -> last_result = yr_parser_emit_with_arg ( yyscanner , OP_PUSH , 1 , NULL , NULL ) ; if ( compiler -> last_result == ERROR_SUCCESS ) compiler -> last_result = yr_parser_reduce_string_identifier ( yyscanner , ( yyvsp [ 0 ] . c_string ) , OP_OFFSET , UNDEFINED ) ; yr_free ( ( yyvsp [ 0 ] . c_string ) ) ; ERROR_IF ( compiler -> last_result != ERROR_SUCCESS ) ; ( yyval . expression ) . type = EXPRESSION_TYPE_INTEGER ; ( yyval . expression ) . value . integer = UNDEFINED ; } <S2SV_StartBug> # line 3384 \"grammar.c\" <S2SV_EndBug> break ; case 107 : <S2SV_StartBug> # line 1688 \"grammar.y\" <S2SV_EndBug> { compiler -> last_result = yr_parser_reduce_string_identifier ( yyscanner , ( yyvsp [ - 3 ] . c_string ) , OP_LENGTH , UNDEFINED ) ; yr_free ( ( yyvsp [ - 3 ] . c_string ) ) ; ERROR_IF ( compiler -> last_result != ERROR_SUCCESS ) ; ( yyval . expression ) . type = EXPRESSION_TYPE_INTEGER ; ( yyval . expression ) . value . integer = UNDEFINED ; } <S2SV_StartBug> # line 3400 \"grammar.c\" <S2SV_EndBug> break ; case 108 : <S2SV_StartBug> # line 1700 \"grammar.y\" <S2SV_EndBug> { compiler -> last_result = yr_parser_emit_with_arg ( yyscanner , OP_PUSH , 1 , NULL , NULL ) ; if ( compiler -> last_result == ERROR_SUCCESS ) compiler -> last_result = yr_parser_reduce_string_identifier ( yyscanner , ( yyvsp [ 0 ] . c_string ) , OP_LENGTH , UNDEFINED ) ; yr_free ( ( yyvsp [ 0 ] . c_string ) ) ; ERROR_IF ( compiler -> last_result != ERROR_SUCCESS ) ; ( yyval . expression ) . type = EXPRESSION_TYPE_INTEGER ; ( yyval . expression ) . value . integer = UNDEFINED ; } <S2SV_StartBug> # line 3420 \"grammar.c\" <S2SV_EndBug> break ; case 109 : <S2SV_StartBug> # line 1716 \"grammar.y\" <S2SV_EndBug> { if ( ( yyvsp [ 0 ] . expression ) . type == EXPRESSION_TYPE_INTEGER ) { ( yyval . expression ) . type = EXPRESSION_TYPE_INTEGER ; ( yyval . expression ) . value . integer = UNDEFINED ; } else if ( ( yyvsp [ 0 ] . expression ) . type == EXPRESSION_TYPE_BOOLEAN ) { ( yyval . expression ) . type = EXPRESSION_TYPE_BOOLEAN ; ( yyval . expression ) . value . integer = UNDEFINED ; } else if ( ( yyvsp [ 0 ] . expression ) . type == EXPRESSION_TYPE_OBJECT ) { compiler -> last_result = yr_parser_emit ( yyscanner , OP_OBJ_VALUE , NULL ) ; switch ( ( yyvsp [ 0 ] . expression ) . value . object -> type ) { case OBJECT_TYPE_INTEGER : ( yyval . expression ) . type = EXPRESSION_TYPE_INTEGER ; ( yyval . expression ) . value . integer = UNDEFINED ; break ; case OBJECT_TYPE_FLOAT : ( yyval . expression ) . type = EXPRESSION_TYPE_FLOAT ; break ; case OBJECT_TYPE_STRING : ( yyval . expression ) . type = EXPRESSION_TYPE_STRING ; ( yyval . expression ) . value . sized_string = NULL ; break ; default : yr_compiler_set_error_extra_info_fmt ( compiler , \"wrong<S2SV_blank>usage<S2SV_blank>of<S2SV_blank>identifier<S2SV_blank>\\\\\"%s\\\\\"\" , ( yyvsp [ 0 ] . expression ) . identifier ) ; compiler -> last_result = ERROR_WRONG_TYPE ; } } else { assert ( FALSE ) ; } ERROR_IF ( compiler -> last_result != ERROR_SUCCESS ) ; } <S2SV_StartBug> # line 3469 \"grammar.c\" <S2SV_EndBug> break ; case 110 : <S2SV_StartBug> # line 1761 \"grammar.y\" <S2SV_EndBug> { CHECK_TYPE ( ( yyvsp [ 0 ] . expression ) , EXPRESSION_TYPE_INTEGER | EXPRESSION_TYPE_FLOAT , \"-\" ) ; if ( ( yyvsp [ 0 ] . expression ) . type == EXPRESSION_TYPE_INTEGER ) { ( yyval . expression ) . type = EXPRESSION_TYPE_INTEGER ; ( yyval . expression ) . value . integer = ( ( yyvsp [ 0 ] . expression ) . value . integer == UNDEFINED ) ? UNDEFINED : - ( ( yyvsp [ 0 ] . expression ) . value . integer ) ; compiler -> last_result = yr_parser_emit ( yyscanner , OP_INT_MINUS , NULL ) ; } else if ( ( yyvsp [ 0 ] . expression ) . type == EXPRESSION_TYPE_FLOAT ) { ( yyval . expression ) . type = EXPRESSION_TYPE_FLOAT ; compiler -> last_result = yr_parser_emit ( yyscanner , OP_DBL_MINUS , NULL ) ; } ERROR_IF ( compiler -> last_result != ERROR_SUCCESS ) ; } <S2SV_StartBug> # line 3492 \"grammar.c\" <S2SV_EndBug> break ; case 111 : <S2SV_StartBug> # line 1780 \"grammar.y\" <S2SV_EndBug> { compiler -> last_result = yr_parser_reduce_operation ( yyscanner , \"+\" , ( yyvsp [ - 2 ] . expression ) , ( yyvsp [ 0 ] . expression ) ) ; ERROR_IF ( compiler -> last_result != ERROR_SUCCESS ) ; if ( ( yyvsp [ - 2 ] . expression ) . type == EXPRESSION_TYPE_INTEGER && ( yyvsp [ 0 ] . expression ) . type == EXPRESSION_TYPE_INTEGER ) { ( yyval . expression ) . value . integer = OPERATION ( + , ( yyvsp [ - 2 ] . expression ) . value . integer , ( yyvsp [ 0 ] . expression ) . value . integer ) ; ( yyval . expression ) . type = EXPRESSION_TYPE_INTEGER ; } else { ( yyval . expression ) . type = EXPRESSION_TYPE_FLOAT ; } } <S2SV_StartBug> # line 3514 \"grammar.c\" <S2SV_EndBug> break ; case 112 : <S2SV_StartBug> # line 1798 \"grammar.y\" <S2SV_EndBug> { compiler -> last_result = yr_parser_reduce_operation ( yyscanner , \"-\" , ( yyvsp [ - 2 ] . expression ) , ( yyvsp [ 0 ] . expression ) ) ; ERROR_IF ( compiler -> last_result != ERROR_SUCCESS ) ; if ( ( yyvsp [ - 2 ] . expression ) . type == EXPRESSION_TYPE_INTEGER && ( yyvsp [ 0 ] . expression ) . type == EXPRESSION_TYPE_INTEGER ) { ( yyval . expression ) . value . integer = OPERATION ( - , ( yyvsp [ - 2 ] . expression ) . value . integer , ( yyvsp [ 0 ] . expression ) . value . integer ) ; ( yyval . expression ) . type = EXPRESSION_TYPE_INTEGER ; } else { ( yyval . expression ) . type = EXPRESSION_TYPE_FLOAT ; } } <S2SV_StartBug> # line 3536 \"grammar.c\" <S2SV_EndBug> break ; case 113 : <S2SV_StartBug> # line 1816 \"grammar.y\" <S2SV_EndBug> { compiler -> last_result = yr_parser_reduce_operation ( yyscanner , \"*\" , ( yyvsp [ - 2 ] . expression ) , ( yyvsp [ 0 ] . expression ) ) ; ERROR_IF ( compiler -> last_result != ERROR_SUCCESS ) ; if ( ( yyvsp [ - 2 ] . expression ) . type == EXPRESSION_TYPE_INTEGER && ( yyvsp [ 0 ] . expression ) . type == EXPRESSION_TYPE_INTEGER ) { ( yyval . expression ) . value . integer = OPERATION ( * , ( yyvsp [ - 2 ] . expression ) . value . integer , ( yyvsp [ 0 ] . expression ) . value . integer ) ; ( yyval . expression ) . type = EXPRESSION_TYPE_INTEGER ; } else { ( yyval . expression ) . type = EXPRESSION_TYPE_FLOAT ; } } <S2SV_StartBug> # line 3558 \"grammar.c\" <S2SV_EndBug> break ; case 114 : <S2SV_StartBug> # line 1834 \"grammar.y\" <S2SV_EndBug> { compiler -> last_result = yr_parser_reduce_operation ( yyscanner , \"\\\\\\\\\" , ( yyvsp [ - 2 ] . expression ) , ( yyvsp [ 0 ] . expression ) ) ; ERROR_IF ( compiler -> last_result != ERROR_SUCCESS ) ; if ( ( yyvsp [ - 2 ] . expression ) . type == EXPRESSION_TYPE_INTEGER && ( yyvsp [ 0 ] . expression ) . type == EXPRESSION_TYPE_INTEGER ) { if ( ( yyvsp [ 0 ] . expression ) . value . integer != 0 ) { ( yyval . expression ) . value . integer = OPERATION ( / , ( yyvsp [ - 2 ] . expression ) . value . integer , ( yyvsp [ 0 ] . expression ) . value . integer ) ; ( yyval . expression ) . type = EXPRESSION_TYPE_INTEGER ; } else { compiler -> last_result = ERROR_DIVISION_BY_ZERO ; ERROR_IF ( compiler -> last_result != ERROR_SUCCESS ) ; } } else { ( yyval . expression ) . type = EXPRESSION_TYPE_FLOAT ; } } <S2SV_StartBug> # line 3588 \"grammar.c\" <S2SV_EndBug> break ; case 115 : <S2SV_StartBug> # line 1860 \"grammar.y\" <S2SV_EndBug> { CHECK_TYPE ( ( yyvsp [ - 2 ] . expression ) , EXPRESSION_TYPE_INTEGER , \"%\" ) ; CHECK_TYPE ( ( yyvsp [ 0 ] . expression ) , EXPRESSION_TYPE_INTEGER , \"%\" ) ; yr_parser_emit ( yyscanner , OP_MOD , NULL ) ; if ( ( yyvsp [ 0 ] . expression ) . value . integer != 0 ) { ( yyval . expression ) . value . integer = OPERATION ( % , ( yyvsp [ - 2 ] . expression ) . value . integer , ( yyvsp [ 0 ] . expression ) . value . integer ) ; ( yyval . expression ) . type = EXPRESSION_TYPE_INTEGER ; } else { compiler -> last_result = ERROR_DIVISION_BY_ZERO ; ERROR_IF ( compiler -> last_result != ERROR_SUCCESS ) ; } } <S2SV_StartBug> # line 3610 \"grammar.c\" <S2SV_EndBug> break ; case 116 : <S2SV_StartBug> # line 1878 \"grammar.y\" <S2SV_EndBug> { CHECK_TYPE ( ( yyvsp [ - 2 ] . expression ) , EXPRESSION_TYPE_INTEGER , \"^\" ) ; CHECK_TYPE ( ( yyvsp [ 0 ] . expression ) , EXPRESSION_TYPE_INTEGER , \"^\" ) ; yr_parser_emit ( yyscanner , OP_BITWISE_XOR , NULL ) ; ( yyval . expression ) . type = EXPRESSION_TYPE_INTEGER ; ( yyval . expression ) . value . integer = OPERATION ( ^ , ( yyvsp [ - 2 ] . expression ) . value . integer , ( yyvsp [ 0 ] . expression ) . value . integer ) ; } <S2SV_StartBug> # line 3624 \"grammar.c\" <S2SV_EndBug> break ; case 117 : <S2SV_StartBug> # line 1888 \"grammar.y\" <S2SV_EndBug> { CHECK_TYPE ( ( yyvsp [ - 2 ] . expression ) , EXPRESSION_TYPE_INTEGER , \"^\" ) ; CHECK_TYPE ( ( yyvsp [ 0 ] . expression ) , EXPRESSION_TYPE_INTEGER , \"^\" ) ; yr_parser_emit ( yyscanner , OP_BITWISE_AND , NULL ) ; ( yyval . expression ) . type = EXPRESSION_TYPE_INTEGER ; ( yyval . expression ) . value . integer = OPERATION ( & , ( yyvsp [ - 2 ] . expression ) . value . integer , ( yyvsp [ 0 ] . expression ) . value . integer ) ; } <S2SV_StartBug> # line 3638 \"grammar.c\" <S2SV_EndBug> break ; case 118 : <S2SV_StartBug> # line 1898 \"grammar.y\" <S2SV_EndBug> { CHECK_TYPE ( ( yyvsp [ - 2 ] . expression ) , EXPRESSION_TYPE_INTEGER , \"|\" ) ; CHECK_TYPE ( ( yyvsp [ 0 ] . expression ) , EXPRESSION_TYPE_INTEGER , \"|\" ) ; yr_parser_emit ( yyscanner , OP_BITWISE_OR , NULL ) ; ( yyval . expression ) . type = EXPRESSION_TYPE_INTEGER ; ( yyval . expression ) . value . integer = OPERATION ( | , ( yyvsp [ - 2 ] . expression ) . value . integer , ( yyvsp [ 0 ] . expression ) . value . integer ) ; } <S2SV_StartBug> # line 3652 \"grammar.c\" <S2SV_EndBug> break ; case 119 : <S2SV_StartBug> # line 1908 \"grammar.y\" <S2SV_EndBug> { CHECK_TYPE ( ( yyvsp [ 0 ] . expression ) , EXPRESSION_TYPE_INTEGER , \"~\" ) ; yr_parser_emit ( yyscanner , OP_BITWISE_NOT , NULL ) ; ( yyval . expression ) . type = EXPRESSION_TYPE_INTEGER ; ( yyval . expression ) . value . integer = ( ( yyvsp [ 0 ] . expression ) . value . integer == UNDEFINED ) ? UNDEFINED : ~ ( ( yyvsp [ 0 ] . expression ) . value . integer ) ; } <S2SV_StartBug> # line 3666 \"grammar.c\" <S2SV_EndBug> break ; case 120 : <S2SV_StartBug> # line 1918 \"grammar.y\" <S2SV_EndBug> { CHECK_TYPE ( ( yyvsp [ - 2 ] . expression ) , EXPRESSION_TYPE_INTEGER , \"<<\" ) ; CHECK_TYPE ( ( yyvsp [ 0 ] . expression ) , EXPRESSION_TYPE_INTEGER , \"<<\" ) ; yr_parser_emit ( yyscanner , OP_SHL , NULL ) ; ( yyval . expression ) . type = EXPRESSION_TYPE_INTEGER ; ( yyval . expression ) . value . integer = OPERATION ( << , ( yyvsp [ - 2 ] . expression ) . value . integer , ( yyvsp [ 0 ] . expression ) . value . integer ) ; } <S2SV_StartBug> # line 3680 \"grammar.c\" <S2SV_EndBug> break ; case 121 : <S2SV_StartBug> # line 1928 \"grammar.y\" <S2SV_EndBug> { CHECK_TYPE ( ( yyvsp [ - 2 ] . expression ) , EXPRESSION_TYPE_INTEGER , \">>\" ) ; CHECK_TYPE ( ( yyvsp [ 0 ] . expression ) , EXPRESSION_TYPE_INTEGER , \">>\" ) ; yr_parser_emit ( yyscanner , OP_SHR , NULL ) ; ( yyval . expression ) . type = EXPRESSION_TYPE_INTEGER ; ( yyval . expression ) . value . integer = OPERATION ( >> , ( yyvsp [ - 2 ] . expression ) . value . integer , ( yyvsp [ 0 ] . expression ) . value . integer ) ; } <S2SV_StartBug> # line 3694 \"grammar.c\" <S2SV_EndBug> break ; case 122 : <S2SV_StartBug> # line 1938 \"grammar.y\" <S2SV_EndBug> { ( yyval . expression ) = ( yyvsp [ 0 ] . expression ) ; } <S2SV_StartBug> # line 3702 \"grammar.c\" <S2SV_EndBug> break ; <S2SV_StartBug> # line 3706 \"grammar.c\" <S2SV_EndBug> default : break ; } YY_SYMBOL_PRINT ( \"-><S2SV_blank>$$<S2SV_blank>=\" , yyr1 [ yyn ] , & yyval , & yyloc ) ; YYPOPSTACK ( yylen ) ; yylen = 0 ; YY_STACK_PRINT ( yyss , yyssp ) ; * ++ yyvsp = yyval ; yyn = yyr1 [ yyn ] ; yystate = yypgoto [ yyn - YYNTOKENS ] + * yyssp ; if ( 0 <= yystate && yystate <= YYLAST && yycheck [ yystate ] == * yyssp ) yystate = yytable [ yystate ] ; else yystate = yydefgoto [ yyn - YYNTOKENS ] ; goto yynewstate ; yyerrlab : yytoken = yychar == YYEMPTY ? YYEMPTY : YYTRANSLATE ( yychar ) ; if ( ! yyerrstatus ) { ++ yynerrs ; # if ! YYERROR_VERBOSE yyerror ( yyscanner , compiler , YY_ ( \"syntax<S2SV_blank>error\" ) ) ; # else # define YYSYNTAX_ERROR yysyntax_error ( & yymsg_alloc , & yymsg , yyssp , yytoken ) { char const * yymsgp = YY_ ( \"syntax<S2SV_blank>error\" ) ; int yysyntax_error_status ; yysyntax_error_status = YYSYNTAX_ERROR ; if ( yysyntax_error_status == 0 ) yymsgp = yymsg ; else if ( yysyntax_error_status == 1 ) { if ( yymsg != yymsgbuf ) YYSTACK_FREE ( yymsg ) ; yymsg = ( char * ) YYSTACK_ALLOC ( yymsg_alloc ) ; if ( ! yymsg ) { yymsg = yymsgbuf ; yymsg_alloc = sizeof yymsgbuf ; yysyntax_error_status = 2 ; } else { yysyntax_error_status = YYSYNTAX_ERROR ; yymsgp = yymsg ; } } yyerror ( yyscanner , compiler , yymsgp ) ; if ( yysyntax_error_status == 2 ) goto yyexhaustedlab ; } # undef YYSYNTAX_ERROR # endif } if ( yyerrstatus == 3 ) { if ( yychar <= YYEOF ) { if ( yychar == YYEOF ) YYABORT ; } else { yydestruct ( \"Error:<S2SV_blank>discarding\" , yytoken , & yylval , yyscanner , compiler ) ; yychar = YYEMPTY ; } } goto yyerrlab1 ; yyerrorlab : if ( 0 ) goto yyerrorlab ; YYPOPSTACK ( yylen ) ; yylen = 0 ; YY_STACK_PRINT ( yyss , yyssp ) ; yystate = * yyssp ; goto yyerrlab1 ; yyerrlab1 : yyerrstatus = 3 ; for ( ; ; ) { yyn = yypact [ yystate ] ; if ( ! yypact_value_is_default ( yyn ) ) { yyn += YYTERROR ; if ( 0 <= yyn && yyn <= YYLAST && yycheck [ yyn ] == YYTERROR ) { yyn = yytable [ yyn ] ; if ( 0 < yyn ) break ; } } if ( yyssp == yyss ) YYABORT ; yydestruct ( \"Error:<S2SV_blank>popping\" , yystos [ yystate ] , yyvsp , yyscanner , compiler ) ; YYPOPSTACK ( 1 ) ; yystate = * yyssp ; YY_STACK_PRINT ( yyss , yyssp ) ; } YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN * ++ yyvsp = yylval ; YY_IGNORE_MAYBE_UNINITIALIZED_END YY_SYMBOL_PRINT ( \"Shifting\" , yystos [ yyn ] , yyvsp , yylsp ) ; yystate = yyn ; goto yynewstate ; yyacceptlab : yyresult = 0 ; goto yyreturn ; yyabortlab : yyresult = 1 ; goto yyreturn ; # if ! defined yyoverflow || YYERROR_VERBOSE yyexhaustedlab : yyerror ( yyscanner , compiler , YY_ ( \"memory<S2SV_blank>exhausted\" ) ) ; yyresult = 2 ; # endif yyreturn : if ( yychar != YYEMPTY ) { yytoken = YYTRANSLATE ( yychar ) ; yydestruct ( \"Cleanup:<S2SV_blank>discarding<S2SV_blank>lookahead\" , yytoken , & yylval , yyscanner , compiler ) ; } YYPOPSTACK ( yylen ) ; YY_STACK_PRINT ( yyss , yyssp ) ; while ( yyssp != yyss ) { yydestruct ( \"Cleanup:<S2SV_blank>popping\" , yystos [ * yyssp ] , yyvsp , yyscanner , compiler ) ; YYPOPSTACK ( 1 ) ; } # ifndef yyoverflow if ( yyss != yyssa ) YYSTACK_FREE ( yyss ) ; # endif # if YYERROR_VERBOSE if ( yymsg != yymsgbuf ) YYSTACK_FREE ( yymsg ) ; # endif return yyresult ; }\n","target":"<S2SV_ModStart> ; break ; default : assert ( FALSE ) ; <S2SV_ModStart> } # line 2371 <S2SV_ModEnd> \"grammar.c\" break ; <S2SV_ModStart> : # line 834 <S2SV_ModEnd> \"grammar.y\" { if <S2SV_ModStart> ; break ; default : assert ( FALSE ) ; <S2SV_ModStart> } # line 2409 <S2SV_ModEnd> \"grammar.c\" break ; <S2SV_ModStart> : # line 872 <S2SV_ModEnd> \"grammar.y\" { SIZED_STRING <S2SV_ModStart> } # line 2455 <S2SV_ModEnd> \"grammar.c\" break ; <S2SV_ModStart> : # line 918 <S2SV_ModEnd> \"grammar.y\" { if <S2SV_ModStart> } # line 2478 <S2SV_ModEnd> \"grammar.c\" break ; <S2SV_ModStart> : # line 940 <S2SV_ModEnd> \"grammar.y\" { compiler <S2SV_ModStart> } # line 2491 <S2SV_ModEnd> \"grammar.c\" break ; <S2SV_ModStart> : # line 949 <S2SV_ModEnd> \"grammar.y\" { compiler <S2SV_ModStart> } # line 2504 <S2SV_ModEnd> \"grammar.c\" break ; <S2SV_ModStart> : # line 958 <S2SV_ModEnd> \"grammar.y\" { CHECK_TYPE <S2SV_ModStart> } # line 2523 <S2SV_ModEnd> \"grammar.c\" break ; <S2SV_ModStart> : # line 973 <S2SV_ModEnd> \"grammar.y\" { CHECK_TYPE <S2SV_ModStart> } # line 2539 <S2SV_ModEnd> \"grammar.c\" break ; <S2SV_ModStart> : # line 985 <S2SV_ModEnd> \"grammar.y\" { int <S2SV_ModStart> } # line 2557 <S2SV_ModEnd> \"grammar.c\" break ; <S2SV_ModStart> : # line 999 <S2SV_ModEnd> \"grammar.y\" { CHECK_TYPE <S2SV_ModStart> } # line 2574 <S2SV_ModEnd> \"grammar.c\" break ; <S2SV_ModStart> : # line 1012 <S2SV_ModEnd> \"grammar.y\" { compiler <S2SV_ModStart> } # line 2589 <S2SV_ModEnd> \"grammar.c\" break ; <S2SV_ModStart> : # line 1023 <S2SV_ModEnd> \"grammar.y\" { if <S2SV_ModStart> NULL ; } YYERROR ; } # line 2603 <S2SV_ModEnd> \"grammar.c\" break ; <S2SV_ModStart> : # line 1033 <S2SV_ModEnd> \"grammar.y\" { int <S2SV_ModStart> } # line 2637 <S2SV_ModEnd> \"grammar.c\" break ; <S2SV_ModStart> : # line 1063 <S2SV_ModEnd> \"grammar.y\" { int <S2SV_ModStart> } # line 2676 <S2SV_ModEnd> \"grammar.c\" break ; <S2SV_ModStart> : # line 1098 <S2SV_ModEnd> \"grammar.y\" { int <S2SV_ModStart> } # line 2759 <S2SV_ModEnd> \"grammar.c\" break ; <S2SV_ModStart> : # line 1177 <S2SV_ModEnd> \"grammar.y\" { int <S2SV_ModStart> } # line 2793 <S2SV_ModEnd> \"grammar.c\" break ; <S2SV_ModStart> : # line 1207 <S2SV_ModEnd> \"grammar.y\" { int <S2SV_ModStart> } # line 2846 <S2SV_ModEnd> \"grammar.c\" break ; <S2SV_ModStart> : # line 1256 <S2SV_ModEnd> \"grammar.y\" { yr_parser_emit <S2SV_ModStart> } # line 2856 <S2SV_ModEnd> \"grammar.c\" break ; <S2SV_ModStart> : # line 1262 <S2SV_ModEnd> \"grammar.y\" { yr_parser_emit <S2SV_ModStart> } # line 2866 <S2SV_ModEnd> \"grammar.c\" break ; <S2SV_ModStart> : # line 1268 <S2SV_ModEnd> \"grammar.y\" { YR_FIXUP <S2SV_ModStart> } # line 2896 <S2SV_ModEnd> \"grammar.c\" break ; <S2SV_ModStart> : # line 1294 <S2SV_ModEnd> \"grammar.y\" { YR_FIXUP <S2SV_ModStart> } # line 2936 <S2SV_ModEnd> \"grammar.c\" break ; <S2SV_ModStart> : # line 1330 <S2SV_ModEnd> \"grammar.y\" { YR_FIXUP <S2SV_ModStart> } # line 2965 <S2SV_ModEnd> \"grammar.c\" break ; <S2SV_ModStart> : # line 1355 <S2SV_ModEnd> \"grammar.y\" { YR_FIXUP <S2SV_ModStart> } # line 3005 <S2SV_ModEnd> \"grammar.c\" break ; <S2SV_ModStart> : # line 1391 <S2SV_ModEnd> \"grammar.y\" { compiler <S2SV_ModStart> } # line 3018 <S2SV_ModEnd> \"grammar.c\" break ; <S2SV_ModStart> : # line 1400 <S2SV_ModEnd> \"grammar.y\" { compiler <S2SV_ModStart> } # line 3031 <S2SV_ModEnd> \"grammar.c\" break ; <S2SV_ModStart> : # line 1409 <S2SV_ModEnd> \"grammar.y\" { compiler <S2SV_ModStart> } # line 3044 <S2SV_ModEnd> \"grammar.c\" break ; <S2SV_ModStart> : # line 1418 <S2SV_ModEnd> \"grammar.y\" { compiler <S2SV_ModStart> } # line 3057 <S2SV_ModEnd> \"grammar.c\" break ; <S2SV_ModStart> : # line 1427 <S2SV_ModEnd> \"grammar.y\" { compiler <S2SV_ModStart> } # line 3070 <S2SV_ModEnd> \"grammar.c\" break ; <S2SV_ModStart> : # line 1436 <S2SV_ModEnd> \"grammar.y\" { compiler <S2SV_ModStart> } # line 3083 <S2SV_ModEnd> \"grammar.c\" break ; <S2SV_ModStart> : # line 1445 <S2SV_ModEnd> \"grammar.y\" { ( <S2SV_ModStart> } # line 3091 <S2SV_ModEnd> \"grammar.c\" break ; <S2SV_ModStart> : # line 1449 <S2SV_ModEnd> \"grammar.y\" { ( <S2SV_ModStart> } # line 3099 <S2SV_ModEnd> \"grammar.c\" break ; <S2SV_ModStart> : # line 1456 <S2SV_ModEnd> \"grammar.y\" { ( <S2SV_ModStart> } # line 3105 <S2SV_ModEnd> \"grammar.c\" break ; <S2SV_ModStart> : # line 1457 <S2SV_ModEnd> \"grammar.y\" { ( <S2SV_ModStart> } # line 3111 <S2SV_ModEnd> \"grammar.c\" break ; <S2SV_ModStart> : # line 1463 <S2SV_ModEnd> \"grammar.y\" { if <S2SV_ModStart> } # line 3133 <S2SV_ModEnd> \"grammar.c\" break ; <S2SV_ModStart> : # line 1485 <S2SV_ModEnd> \"grammar.y\" { if <S2SV_ModStart> } # line 3149 <S2SV_ModEnd> \"grammar.c\" break ; <S2SV_ModStart> : # line 1497 <S2SV_ModEnd> \"grammar.y\" { if <S2SV_ModStart> } # line 3164 <S2SV_ModEnd> \"grammar.c\" break ; <S2SV_ModStart> : # line 1512 <S2SV_ModEnd> \"grammar.y\" { yr_parser_emit_with_arg <S2SV_ModStart> } # line 3173 <S2SV_ModEnd> \"grammar.c\" break ; <S2SV_ModStart> : # line 1518 <S2SV_ModEnd> \"grammar.y\" { yr_parser_emit_with_arg <S2SV_ModStart> } # line 3184 <S2SV_ModEnd> \"grammar.c\" break ; <S2SV_ModStart> : # line 1535 <S2SV_ModEnd> \"grammar.y\" { yr_parser_emit_pushes_for_strings <S2SV_ModStart> } # line 3195 <S2SV_ModEnd> \"grammar.c\" break ; <S2SV_ModStart> : # line 1542 <S2SV_ModEnd> \"grammar.y\" { yr_parser_emit_pushes_for_strings <S2SV_ModStart> } # line 3206 <S2SV_ModEnd> \"grammar.c\" break ; <S2SV_ModStart> : # line 1554 <S2SV_ModEnd> \"grammar.y\" { yr_parser_emit_with_arg <S2SV_ModStart> } # line 3214 <S2SV_ModEnd> \"grammar.c\" break ; <S2SV_ModStart> : # line 1558 <S2SV_ModEnd> \"grammar.y\" { yr_parser_emit_with_arg <S2SV_ModStart> } # line 3222 <S2SV_ModEnd> \"grammar.c\" break ; <S2SV_ModStart> : # line 1566 <S2SV_ModEnd> \"grammar.y\" { ( <S2SV_ModStart> } # line 3230 <S2SV_ModEnd> \"grammar.c\" break ; <S2SV_ModStart> : # line 1570 <S2SV_ModEnd> \"grammar.y\" { compiler <S2SV_ModStart> } # line 3244 <S2SV_ModEnd> \"grammar.c\" break ; <S2SV_ModStart> : # line 1580 <S2SV_ModEnd> \"grammar.y\" { yywarning <S2SV_ModStart> } # line 3262 <S2SV_ModEnd> \"grammar.c\" break ; <S2SV_ModStart> : # line 1594 <S2SV_ModEnd> \"grammar.y\" { CHECK_TYPE <S2SV_ModStart> } # line 3282 <S2SV_ModEnd> \"grammar.c\" break ; <S2SV_ModStart> : # line 1610 <S2SV_ModEnd> \"grammar.y\" { compiler <S2SV_ModStart> } # line 3296 <S2SV_ModEnd> \"grammar.c\" break ; <S2SV_ModStart> : # line 1620 <S2SV_ModEnd> \"grammar.y\" { compiler <S2SV_ModStart> } # line 3309 <S2SV_ModEnd> \"grammar.c\" break ; <S2SV_ModStart> : # line 1629 <S2SV_ModEnd> \"grammar.y\" { SIZED_STRING <S2SV_ModStart> } # line 3338 <S2SV_ModEnd> \"grammar.c\" break ; <S2SV_ModStart> : # line 1654 <S2SV_ModEnd> \"grammar.y\" { compiler <S2SV_ModStart> } # line 3354 <S2SV_ModEnd> \"grammar.c\" break ; <S2SV_ModStart> : # line 1666 <S2SV_ModEnd> \"grammar.y\" { compiler <S2SV_ModStart> } # line 3370 <S2SV_ModEnd> \"grammar.c\" break ; <S2SV_ModStart> : # line 1678 <S2SV_ModEnd> \"grammar.y\" { compiler <S2SV_ModStart> } # line 3390 <S2SV_ModEnd> \"grammar.c\" break ; <S2SV_ModStart> : # line 1694 <S2SV_ModEnd> \"grammar.y\" { compiler <S2SV_ModStart> } # line 3406 <S2SV_ModEnd> \"grammar.c\" break ; <S2SV_ModStart> : # line 1706 <S2SV_ModEnd> \"grammar.y\" { compiler <S2SV_ModStart> } # line 3426 <S2SV_ModEnd> \"grammar.c\" break ; <S2SV_ModStart> : # line 1722 <S2SV_ModEnd> \"grammar.y\" { if <S2SV_ModStart> } # line 3475 <S2SV_ModEnd> \"grammar.c\" break ; <S2SV_ModStart> : # line 1767 <S2SV_ModEnd> \"grammar.y\" { CHECK_TYPE <S2SV_ModStart> } # line 3498 <S2SV_ModEnd> \"grammar.c\" break ; <S2SV_ModStart> : # line 1786 <S2SV_ModEnd> \"grammar.y\" { compiler <S2SV_ModStart> } # line 3520 <S2SV_ModEnd> \"grammar.c\" break ; <S2SV_ModStart> : # line 1804 <S2SV_ModEnd> \"grammar.y\" { compiler <S2SV_ModStart> } # line 3542 <S2SV_ModEnd> \"grammar.c\" break ; <S2SV_ModStart> : # line 1822 <S2SV_ModEnd> \"grammar.y\" { compiler <S2SV_ModStart> } # line 3564 <S2SV_ModEnd> \"grammar.c\" break ; <S2SV_ModStart> : # line 1840 <S2SV_ModEnd> \"grammar.y\" { compiler <S2SV_ModStart> } # line 3594 <S2SV_ModEnd> \"grammar.c\" break ; <S2SV_ModStart> : # line 1866 <S2SV_ModEnd> \"grammar.y\" { CHECK_TYPE <S2SV_ModStart> } # line 3616 <S2SV_ModEnd> \"grammar.c\" break ; <S2SV_ModStart> : # line 1884 <S2SV_ModEnd> \"grammar.y\" { CHECK_TYPE <S2SV_ModStart> } # line 3630 <S2SV_ModEnd> \"grammar.c\" break ; <S2SV_ModStart> : # line 1894 <S2SV_ModEnd> \"grammar.y\" { CHECK_TYPE <S2SV_ModStart> } # line 3644 <S2SV_ModEnd> \"grammar.c\" break ; <S2SV_ModStart> : # line 1904 <S2SV_ModEnd> \"grammar.y\" { CHECK_TYPE <S2SV_ModStart> } # line 3658 <S2SV_ModEnd> \"grammar.c\" break ; <S2SV_ModStart> : # line 1914 <S2SV_ModEnd> \"grammar.y\" { CHECK_TYPE <S2SV_ModStart> } # line 3672 <S2SV_ModEnd> \"grammar.c\" break ; <S2SV_ModStart> : # line 1924 <S2SV_ModEnd> \"grammar.y\" { CHECK_TYPE <S2SV_ModStart> } # line 3686 <S2SV_ModEnd> \"grammar.c\" break ; <S2SV_ModStart> : # line 1934 <S2SV_ModEnd> \"grammar.y\" { CHECK_TYPE <S2SV_ModStart> } # line 3700 <S2SV_ModEnd> \"grammar.c\" break ; <S2SV_ModStart> : # line 1944 <S2SV_ModEnd> \"grammar.y\" { ( <S2SV_ModStart> } # line 3708 <S2SV_ModEnd> \"grammar.c\" break ; <S2SV_ModStart> ; # line 3712 <S2SV_ModEnd> \"grammar.c\" default :\n","project_and_commit_id":"VirusTotal@yara/ab906da53ff2a68c6fd6d1fa73f2b7c7bf0bc636","cve_id":"CVE-2017-5923","original_address":"https://github.com/VirusTotal/yara/commit/ab906da53ff2a68c6fd6d1fa73f2b7c7bf0bc636","time":"2017-04-03T05:59Z"},
	{"Unnamed: 0":1039,"cwe_id":"CWE-119","source":"CWE-119 int nfs3svc_decode_writeargs ( struct svc_rqst * rqstp , __be32 * p , struct nfsd3_writeargs * args ) { unsigned int len , v , hdr , dlen ; u32 max_blocksize = svc_max_payload ( rqstp ) ; struct kvec * head = rqstp -> rq_arg . head ; struct kvec * tail = rqstp -> rq_arg . tail ; p = decode_fh ( p , & args -> fh ) ; if ( ! p ) return 0 ; p = xdr_decode_hyper ( p , & args -> offset ) ; args -> count = ntohl ( * p ++ ) ; args -> stable = ntohl ( * p ++ ) ; <S2SV_StartBug> len = args -> len = ntohl ( * p ++ ) ; <S2SV_EndBug> if ( args -> count != args -> len ) return 0 ; hdr = ( void * ) p - head -> iov_base ; dlen = head -> iov_len + rqstp -> rq_arg . page_len + tail -> iov_len - hdr ; if ( dlen < XDR_QUADLEN ( len ) * 4 ) return 0 ; if ( args -> count > max_blocksize ) { args -> count = max_blocksize ; len = args -> len = max_blocksize ; } rqstp -> rq_vec [ 0 ] . iov_base = ( void * ) p ; rqstp -> rq_vec [ 0 ] . iov_len = head -> iov_len - hdr ; v = 0 ; while ( len > rqstp -> rq_vec [ v ] . iov_len ) { len -= rqstp -> rq_vec [ v ] . iov_len ; v ++ ; rqstp -> rq_vec [ v ] . iov_base = page_address ( rqstp -> rq_pages [ v ] ) ; rqstp -> rq_vec [ v ] . iov_len = PAGE_SIZE ; } rqstp -> rq_vec [ v ] . iov_len = len ; args -> vlen = v + 1 ; return 1 ; }\n","target":"<S2SV_ModStart> p ++ ) ; if ( ( void * ) p > head -> iov_base + head -> iov_len ) return 0\n","project_and_commit_id":"torvalds@linux/13bf9fbff0e5e099e2b6f003a0ab8ae145436309","cve_id":"CVE-2017-7895","original_address":"https://github.com/torvalds/linux/commit/13bf9fbff0e5e099e2b6f003a0ab8ae145436309","time":"2017-04-28T10:59Z"},
	{"Unnamed: 0":5184,"cwe_id":"CWE-20","source":"CWE-20 void big_key_describe ( const struct key * key , struct seq_file * m ) { size_t datalen = ( size_t ) key -> payload . data [ big_key_len ] ; seq_puts ( m , key -> description ) ; <S2SV_StartBug> if ( key_is_instantiated ( key ) ) <S2SV_EndBug> seq_printf ( m , \":<S2SV_blank>%zu<S2SV_blank>[%s]\" , datalen , datalen > BIG_KEY_FILE_THRESHOLD ? \"file\" : \"buff\" ) ; }\n","target":"<S2SV_ModStart> ; if ( key_is_positive <S2SV_ModEnd> ( key )\n","project_and_commit_id":"torvalds@linux/363b02dab09b3226f3bd1420dad9c72b79a42a76","cve_id":"CVE-2017-15951","original_address":"https://github.com/torvalds/linux/commit/363b02dab09b3226f3bd1420dad9c72b79a42a76","time":"2017-10-28T02:29Z"},
	{"Unnamed: 0":2385,"cwe_id":"CWE-200","source":"CWE-200 static int Downmix_Command ( effect_handle_t self , uint32_t cmdCode , uint32_t cmdSize , void * pCmdData , uint32_t * replySize , void * pReplyData ) { downmix_module_t * pDwmModule = ( downmix_module_t * ) self ; downmix_object_t * pDownmixer ; if ( pDwmModule == NULL || pDwmModule -> context . state == DOWNMIX_STATE_UNINITIALIZED ) { return - EINVAL ; } pDownmixer = ( downmix_object_t * ) & pDwmModule -> context ; ALOGV ( \"Downmix_Command<S2SV_blank>command<S2SV_blank>%\" PRIu32 \"<S2SV_blank>cmdSize<S2SV_blank>%\" PRIu32 , cmdCode , cmdSize ) ; switch ( cmdCode ) { case EFFECT_CMD_INIT : if ( pReplyData == NULL || replySize == NULL || * replySize != sizeof ( int ) ) { return - EINVAL ; } * ( int * ) pReplyData = Downmix_Init ( pDwmModule ) ; break ; case EFFECT_CMD_SET_CONFIG : if ( pCmdData == NULL || cmdSize != sizeof ( effect_config_t ) || pReplyData == NULL || replySize == NULL || * replySize != sizeof ( int ) ) { return - EINVAL ; } * ( int * ) pReplyData = Downmix_Configure ( pDwmModule , ( effect_config_t * ) pCmdData , false ) ; break ; case EFFECT_CMD_RESET : Downmix_Reset ( pDownmixer , false ) ; break ; case EFFECT_CMD_GET_PARAM : ALOGV ( \"Downmix_Command<S2SV_blank>EFFECT_CMD_GET_PARAM<S2SV_blank>pCmdData<S2SV_blank>%p,<S2SV_blank>*replySize<S2SV_blank>%\" PRIu32 \",<S2SV_blank>pReplyData:<S2SV_blank>%p\" , pCmdData , * replySize , pReplyData ) ; if ( pCmdData == NULL || cmdSize < ( int ) ( sizeof ( effect_param_t ) + sizeof ( int32_t ) ) || pReplyData == NULL || replySize == NULL || * replySize < ( int ) sizeof ( effect_param_t ) + 2 * sizeof ( int32_t ) ) { return - EINVAL ; } effect_param_t * rep = ( effect_param_t * ) pReplyData ; memcpy ( pReplyData , pCmdData , sizeof ( effect_param_t ) + sizeof ( int32_t ) ) ; ALOGV ( \"Downmix_Command<S2SV_blank>EFFECT_CMD_GET_PARAM<S2SV_blank>param<S2SV_blank>%\" PRId32 \",<S2SV_blank>replySize<S2SV_blank>%\" PRIu32 , * ( int32_t * ) rep -> data , rep -> vsize ) ; rep -> status = Downmix_getParameter ( pDownmixer , * ( int32_t * ) rep -> data , & rep -> vsize , rep -> data + sizeof ( int32_t ) ) ; * replySize = sizeof ( effect_param_t ) + sizeof ( int32_t ) + rep -> vsize ; break ; case EFFECT_CMD_SET_PARAM : ALOGV ( \"Downmix_Command<S2SV_blank>EFFECT_CMD_SET_PARAM<S2SV_blank>cmdSize<S2SV_blank>%d<S2SV_blank>pCmdData<S2SV_blank>%p,<S2SV_blank>*replySize<S2SV_blank>%\" PRIu32 \",<S2SV_blank>pReplyData<S2SV_blank>%p\" , cmdSize , pCmdData , * replySize , pReplyData ) ; if ( pCmdData == NULL || ( cmdSize < ( int ) ( sizeof ( effect_param_t ) + sizeof ( int32_t ) ) ) || pReplyData == NULL || replySize == NULL || * replySize != ( int ) sizeof ( int32_t ) ) { return - EINVAL ; } effect_param_t * cmd = ( effect_param_t * ) pCmdData ; <S2SV_StartBug> * ( int * ) pReplyData = Downmix_setParameter ( pDownmixer , * ( int32_t * ) cmd -> data , <S2SV_EndBug> cmd -> vsize , cmd -> data + sizeof ( int32_t ) ) ; break ; case EFFECT_CMD_SET_PARAM_DEFERRED : ALOGW ( \"Downmix_Command<S2SV_blank>command<S2SV_blank>EFFECT_CMD_SET_PARAM_DEFERRED<S2SV_blank>not<S2SV_blank>supported,<S2SV_blank>FIXME\" ) ; break ; case EFFECT_CMD_SET_PARAM_COMMIT : ALOGW ( \"Downmix_Command<S2SV_blank>command<S2SV_blank>EFFECT_CMD_SET_PARAM_COMMIT<S2SV_blank>not<S2SV_blank>supported,<S2SV_blank>FIXME\" ) ; break ; case EFFECT_CMD_ENABLE : if ( pReplyData == NULL || replySize == NULL || * replySize != sizeof ( int ) ) { return - EINVAL ; } if ( pDownmixer -> state != DOWNMIX_STATE_INITIALIZED ) { return - ENOSYS ; } pDownmixer -> state = DOWNMIX_STATE_ACTIVE ; ALOGV ( \"EFFECT_CMD_ENABLE()<S2SV_blank>OK\" ) ; * ( int * ) pReplyData = 0 ; break ; case EFFECT_CMD_DISABLE : if ( pReplyData == NULL || replySize == NULL || * replySize != sizeof ( int ) ) { return - EINVAL ; } if ( pDownmixer -> state != DOWNMIX_STATE_ACTIVE ) { return - ENOSYS ; } pDownmixer -> state = DOWNMIX_STATE_INITIALIZED ; ALOGV ( \"EFFECT_CMD_DISABLE()<S2SV_blank>OK\" ) ; * ( int * ) pReplyData = 0 ; break ; case EFFECT_CMD_SET_DEVICE : if ( pCmdData == NULL || cmdSize != ( int ) sizeof ( uint32_t ) ) { return - EINVAL ; } ALOGV ( \"Downmix_Command<S2SV_blank>EFFECT_CMD_SET_DEVICE:<S2SV_blank>0x%08\" PRIx32 , * ( uint32_t * ) pCmdData ) ; break ; case EFFECT_CMD_SET_VOLUME : { if ( pCmdData == NULL || cmdSize != ( int ) sizeof ( uint32_t ) * 2 ) { return - EINVAL ; } ALOGW ( \"Downmix_Command<S2SV_blank>command<S2SV_blank>EFFECT_CMD_SET_VOLUME<S2SV_blank>not<S2SV_blank>supported,<S2SV_blank>FIXME\" ) ; float left = ( float ) ( * ( uint32_t * ) pCmdData ) / ( 1 << 24 ) ; float right = ( float ) ( * ( ( uint32_t * ) pCmdData + 1 ) ) / ( 1 << 24 ) ; ALOGV ( \"Downmix_Command<S2SV_blank>EFFECT_CMD_SET_VOLUME:<S2SV_blank>left<S2SV_blank>%f,<S2SV_blank>right<S2SV_blank>%f<S2SV_blank>\" , left , right ) ; break ; } case EFFECT_CMD_SET_AUDIO_MODE : if ( pCmdData == NULL || cmdSize != ( int ) sizeof ( uint32_t ) ) { return - EINVAL ; } ALOGV ( \"Downmix_Command<S2SV_blank>EFFECT_CMD_SET_AUDIO_MODE:<S2SV_blank>%\" PRIu32 , * ( uint32_t * ) pCmdData ) ; break ; case EFFECT_CMD_SET_CONFIG_REVERSE : case EFFECT_CMD_SET_INPUT_DEVICE : break ; default : ALOGW ( \"Downmix_Command<S2SV_blank>invalid<S2SV_blank>command<S2SV_blank>%\" PRIu32 , cmdCode ) ; return - EINVAL ; } return 0 ; }\n","target":"<S2SV_ModStart> ) pCmdData ; if ( cmd -> psize != sizeof ( int32_t ) ) { android_errorWriteLog ( 0x534e4554 , \"63662938\" ) ; return - EINVAL ; }\n","project_and_commit_id":"frameworks@av/f490fc335772a9b14e78997486f4a572b0594c04","cve_id":"CVE-2017-0816","original_address":"https://android.googlesource.com/platform/frameworks/av/+/f490fc335772a9b14e78997486f4a572b0594c04","time":"2017-10-04T01:29Z"},
	{"Unnamed: 0":6425,"cwe_id":"CWE-476","source":"CWE-476 static int sd_isoc_init ( struct gspca_dev * gspca_dev ) <S2SV_StartBug> { <S2SV_EndBug> struct usb_host_interface * alt ; int max_packet_size ; switch ( gspca_dev -> pixfmt . width ) { case 160 : max_packet_size = 450 ; break ; case 176 : max_packet_size = 600 ; break ; default : max_packet_size = 1022 ; break ; } <S2SV_StartBug> alt = & gspca_dev -> dev -> actconfig -> intf_cache [ 0 ] -> altsetting [ 1 ] ; <S2SV_EndBug> alt -> endpoint [ 0 ] . desc . wMaxPacketSize = cpu_to_le16 ( max_packet_size ) ; return 0 ; }\n","target":"<S2SV_ModStart> gspca_dev ) { struct usb_interface_cache * intfc ; <S2SV_ModStart> break ; } intfc = <S2SV_ModEnd> gspca_dev -> dev <S2SV_ModStart> [ 0 ] ; if ( intfc -> num_altsetting < 2 ) return - ENODEV ; alt = & intfc <S2SV_ModStart> [ 1 ] ; if ( alt -> desc . bNumEndpoints < 1 ) return - ENODEV\n","project_and_commit_id":"torvalds@linux/a246b4d547708f33ff4d4b9a7a5dbac741dc89d8","cve_id":"CVE-2020-11668","original_address":"https://github.com/torvalds/linux/commit/a246b4d547708f33ff4d4b9a7a5dbac741dc89d8","time":"2020-04-09T21:15Z"},
	{"Unnamed: 0":5454,"cwe_id":"CWE-190","source":"CWE-190 jas_image_t * jp2_decode ( jas_stream_t * in , char * optstr ) { jp2_box_t * box ; int found ; jas_image_t * image ; jp2_dec_t * dec ; bool samedtype ; int dtype ; unsigned int i ; jp2_cmap_t * cmapd ; jp2_pclr_t * pclrd ; jp2_cdef_t * cdefd ; unsigned int channo ; int newcmptno ; int_fast32_t * lutents ; # if 0 jp2_cdefchan_t * cdefent ; int cmptno ; # endif jp2_cmapent_t * cmapent ; jas_icchdr_t icchdr ; jas_iccprof_t * iccprof ; dec = 0 ; box = 0 ; image = 0 ; if ( ! ( dec = jp2_dec_create ( ) ) ) { goto error ; } if ( ! ( box = jp2_box_get ( in ) ) ) { jas_eprintf ( \"error:<S2SV_blank>cannot<S2SV_blank>get<S2SV_blank>box\\\\n\" ) ; goto error ; } if ( box -> type != JP2_BOX_JP ) { jas_eprintf ( \"error:<S2SV_blank>expecting<S2SV_blank>signature<S2SV_blank>box\\\\n\" ) ; goto error ; } if ( box -> data . jp . magic != JP2_JP_MAGIC ) { jas_eprintf ( \"incorrect<S2SV_blank>magic<S2SV_blank>number\\\\n\" ) ; goto error ; } jp2_box_destroy ( box ) ; box = 0 ; if ( ! ( box = jp2_box_get ( in ) ) ) { goto error ; } if ( box -> type != JP2_BOX_FTYP ) { jas_eprintf ( \"expecting<S2SV_blank>file<S2SV_blank>type<S2SV_blank>box\\\\n\" ) ; goto error ; } jp2_box_destroy ( box ) ; box = 0 ; found = 0 ; while ( ( box = jp2_box_get ( in ) ) ) { if ( jas_getdbglevel ( ) >= 1 ) { jas_eprintf ( \"got<S2SV_blank>box<S2SV_blank>type<S2SV_blank>%s\\\\n\" , box -> info -> name ) ; } switch ( box -> type ) { case JP2_BOX_JP2C : found = 1 ; break ; case JP2_BOX_IHDR : if ( ! dec -> ihdr ) { dec -> ihdr = box ; box = 0 ; } break ; case JP2_BOX_BPCC : if ( ! dec -> bpcc ) { dec -> bpcc = box ; box = 0 ; } break ; case JP2_BOX_CDEF : if ( ! dec -> cdef ) { dec -> cdef = box ; box = 0 ; } break ; case JP2_BOX_PCLR : if ( ! dec -> pclr ) { dec -> pclr = box ; box = 0 ; } break ; case JP2_BOX_CMAP : if ( ! dec -> cmap ) { dec -> cmap = box ; box = 0 ; } break ; case JP2_BOX_COLR : if ( ! dec -> colr ) { dec -> colr = box ; box = 0 ; } break ; } if ( box ) { jp2_box_destroy ( box ) ; box = 0 ; } if ( found ) { break ; } } if ( ! found ) { jas_eprintf ( \"error:<S2SV_blank>no<S2SV_blank>code<S2SV_blank>stream<S2SV_blank>found\\\\n\" ) ; goto error ; } if ( ! ( dec -> image = jpc_decode ( in , optstr ) ) ) { jas_eprintf ( \"error:<S2SV_blank>cannot<S2SV_blank>decode<S2SV_blank>code<S2SV_blank>stream\\\\n\" ) ; goto error ; } if ( ! dec -> ihdr ) { jas_eprintf ( \"error:<S2SV_blank>missing<S2SV_blank>IHDR<S2SV_blank>box\\\\n\" ) ; goto error ; } <S2SV_StartBug> if ( dec -> ihdr -> data . ihdr . numcmpts != JAS_CAST ( uint , <S2SV_EndBug> jas_image_numcmpts ( dec -> image ) ) ) { jas_eprintf ( \"warning:<S2SV_blank>number<S2SV_blank>of<S2SV_blank>components<S2SV_blank>mismatch\\\\n\" ) ; } if ( ! jas_image_numcmpts ( dec -> image ) ) { jas_eprintf ( \"error:<S2SV_blank>no<S2SV_blank>components\\\\n\" ) ; goto error ; } samedtype = true ; dtype = jas_image_cmptdtype ( dec -> image , 0 ) ; <S2SV_StartBug> for ( i = 1 ; i < JAS_CAST ( uint , jas_image_numcmpts ( dec -> image ) ) ; ++ i ) { <S2SV_EndBug> if ( jas_image_cmptdtype ( dec -> image , i ) != dtype ) { samedtype = false ; break ; } } if ( ( samedtype && dec -> ihdr -> data . ihdr . bpc != JP2_DTYPETOBPC ( dtype ) ) || ( ! samedtype && dec -> ihdr -> data . ihdr . bpc != JP2_IHDR_BPCNULL ) ) { jas_eprintf ( \"warning:<S2SV_blank>component<S2SV_blank>data<S2SV_blank>type<S2SV_blank>mismatch\\\\n\" ) ; } if ( dec -> ihdr -> data . ihdr . comptype != JP2_IHDR_COMPTYPE ) { jas_eprintf ( \"error:<S2SV_blank>unsupported<S2SV_blank>compression<S2SV_blank>type\\\\n\" ) ; goto error ; } if ( dec -> bpcc ) { <S2SV_StartBug> if ( dec -> bpcc -> data . bpcc . numcmpts != JAS_CAST ( uint , jas_image_numcmpts ( <S2SV_EndBug> dec -> image ) ) ) { jas_eprintf ( \"warning:<S2SV_blank>number<S2SV_blank>of<S2SV_blank>components<S2SV_blank>mismatch\\\\n\" ) ; } if ( ! samedtype ) { <S2SV_StartBug> for ( i = 0 ; i < JAS_CAST ( uint , jas_image_numcmpts ( dec -> image ) ) ; <S2SV_EndBug> ++ i ) { if ( jas_image_cmptdtype ( dec -> image , i ) != JP2_BPCTODTYPE ( dec -> bpcc -> data . bpcc . bpcs [ i ] ) ) { jas_eprintf ( \"warning:<S2SV_blank>component<S2SV_blank>data<S2SV_blank>type<S2SV_blank>mismatch\\\\n\" ) ; } } } else { jas_eprintf ( \"warning:<S2SV_blank>superfluous<S2SV_blank>BPCC<S2SV_blank>box\\\\n\" ) ; } } if ( ! dec -> colr ) { jas_eprintf ( \"error:<S2SV_blank>no<S2SV_blank>COLR<S2SV_blank>box\\\\n\" ) ; goto error ; } switch ( dec -> colr -> data . colr . method ) { case JP2_COLR_ENUM : jas_image_setclrspc ( dec -> image , jp2_getcs ( & dec -> colr -> data . colr ) ) ; break ; case JP2_COLR_ICC : iccprof = jas_iccprof_createfrombuf ( dec -> colr -> data . colr . iccp , dec -> colr -> data . colr . iccplen ) ; if ( ! iccprof ) { jas_eprintf ( \"error:<S2SV_blank>failed<S2SV_blank>to<S2SV_blank>parse<S2SV_blank>ICC<S2SV_blank>profile\\\\n\" ) ; goto error ; } jas_iccprof_gethdr ( iccprof , & icchdr ) ; jas_eprintf ( \"ICC<S2SV_blank>Profile<S2SV_blank>CS<S2SV_blank>%08x\\\\n\" , icchdr . colorspc ) ; jas_image_setclrspc ( dec -> image , fromiccpcs ( icchdr . colorspc ) ) ; dec -> image -> cmprof_ = jas_cmprof_createfromiccprof ( iccprof ) ; assert ( dec -> image -> cmprof_ ) ; jas_iccprof_destroy ( iccprof ) ; break ; } if ( dec -> cmap && ! dec -> pclr ) { jas_eprintf ( \"warning:<S2SV_blank>missing<S2SV_blank>PCLR<S2SV_blank>box<S2SV_blank>or<S2SV_blank>superfluous<S2SV_blank>CMAP<S2SV_blank>box\\\\n\" ) ; jp2_box_destroy ( dec -> cmap ) ; dec -> cmap = 0 ; } if ( ! dec -> cmap && dec -> pclr ) { jas_eprintf ( \"warning:<S2SV_blank>missing<S2SV_blank>CMAP<S2SV_blank>box<S2SV_blank>or<S2SV_blank>superfluous<S2SV_blank>PCLR<S2SV_blank>box\\\\n\" ) ; jp2_box_destroy ( dec -> pclr ) ; dec -> pclr = 0 ; } dec -> numchans = dec -> cmap ? dec -> cmap -> data . cmap . numchans : <S2SV_StartBug> JAS_CAST ( uint , jas_image_numcmpts ( dec -> image ) ) ; <S2SV_EndBug> if ( dec -> cmap ) { for ( i = 0 ; i < dec -> numchans ; ++ i ) { <S2SV_StartBug> if ( dec -> cmap -> data . cmap . ents [ i ] . cmptno >= JAS_CAST ( uint , <S2SV_EndBug> jas_image_numcmpts ( dec -> image ) ) ) { jas_eprintf ( \"error:<S2SV_blank>invalid<S2SV_blank>component<S2SV_blank>number<S2SV_blank>in<S2SV_blank>CMAP<S2SV_blank>box\\\\n\" ) ; goto error ; } if ( dec -> cmap -> data . cmap . ents [ i ] . pcol >= dec -> pclr -> data . pclr . numchans ) { jas_eprintf ( \"error:<S2SV_blank>invalid<S2SV_blank>CMAP<S2SV_blank>LUT<S2SV_blank>index\\\\n\" ) ; goto error ; } } } if ( ! ( dec -> chantocmptlut = jas_alloc2 ( dec -> numchans , sizeof ( uint_fast16_t ) ) ) ) { jas_eprintf ( \"error:<S2SV_blank>no<S2SV_blank>memory\\\\n\" ) ; goto error ; } if ( ! dec -> cmap ) { for ( i = 0 ; i < dec -> numchans ; ++ i ) { dec -> chantocmptlut [ i ] = i ; } } else { cmapd = & dec -> cmap -> data . cmap ; pclrd = & dec -> pclr -> data . pclr ; cdefd = & dec -> cdef -> data . cdef ; for ( channo = 0 ; channo < cmapd -> numchans ; ++ channo ) { cmapent = & cmapd -> ents [ channo ] ; if ( cmapent -> map == JP2_CMAP_DIRECT ) { dec -> chantocmptlut [ channo ] = channo ; } else if ( cmapent -> map == JP2_CMAP_PALETTE ) { lutents = jas_alloc2 ( pclrd -> numlutents , sizeof ( int_fast32_t ) ) ; for ( i = 0 ; i < pclrd -> numlutents ; ++ i ) { lutents [ i ] = pclrd -> lutdata [ cmapent -> pcol + i * pclrd -> numchans ] ; } newcmptno = jas_image_numcmpts ( dec -> image ) ; jas_image_depalettize ( dec -> image , cmapent -> cmptno , pclrd -> numlutents , lutents , JP2_BPCTODTYPE ( pclrd -> bpc [ cmapent -> pcol ] ) , newcmptno ) ; dec -> chantocmptlut [ channo ] = newcmptno ; jas_free ( lutents ) ; # if 0 if ( dec -> cdef ) { cdefent = jp2_cdef_lookup ( cdefd , channo ) ; if ( ! cdefent ) { abort ( ) ; } jas_image_setcmpttype ( dec -> image , newcmptno , jp2_getct ( jas_image_clrspc ( dec -> image ) , cdefent -> type , cdefent -> assoc ) ) ; } else { jas_image_setcmpttype ( dec -> image , newcmptno , jp2_getct ( jas_image_clrspc ( dec -> image ) , 0 , channo + 1 ) ) ; } # endif } } } <S2SV_StartBug> for ( i = 0 ; i < JAS_CAST ( uint , jas_image_numcmpts ( dec -> image ) ) ; ++ i ) { <S2SV_EndBug> jas_image_setcmpttype ( dec -> image , i , JAS_IMAGE_CT_UNKNOWN ) ; } if ( dec -> cdef ) { for ( i = 0 ; i < dec -> numchans ; ++ i ) { if ( dec -> cdef -> data . cdef . ents [ i ] . channo >= dec -> numchans ) { jas_eprintf ( \"error:<S2SV_blank>invalid<S2SV_blank>channel<S2SV_blank>number<S2SV_blank>in<S2SV_blank>CDEF<S2SV_blank>box\\\\n\" ) ; goto error ; } jas_image_setcmpttype ( dec -> image , dec -> chantocmptlut [ dec -> cdef -> data . cdef . ents [ i ] . channo ] , jp2_getct ( jas_image_clrspc ( dec -> image ) , dec -> cdef -> data . cdef . ents [ i ] . type , dec -> cdef -> data . cdef . ents [ i ] . assoc ) ) ; } } else { for ( i = 0 ; i < dec -> numchans ; ++ i ) { jas_image_setcmpttype ( dec -> image , dec -> chantocmptlut [ i ] , jp2_getct ( jas_image_clrspc ( dec -> image ) , 0 , i + 1 ) ) ; } } for ( i = jas_image_numcmpts ( dec -> image ) ; i > 0 ; -- i ) { if ( jas_image_cmpttype ( dec -> image , i - 1 ) == JAS_IMAGE_CT_UNKNOWN ) { jas_image_delcmpt ( dec -> image , i - 1 ) ; } } if ( ! jas_image_numcmpts ( dec -> image ) ) { jas_eprintf ( \"error:<S2SV_blank>no<S2SV_blank>components\\\\n\" ) ; goto error ; } # if 0 jas_eprintf ( \"no<S2SV_blank>of<S2SV_blank>components<S2SV_blank>is<S2SV_blank>%d\\\\n\" , jas_image_numcmpts ( dec -> image ) ) ; # endif image = dec -> image ; dec -> image = 0 ; jp2_dec_destroy ( dec ) ; return image ; error : if ( box ) { jp2_box_destroy ( box ) ; } if ( dec ) { jp2_dec_destroy ( dec ) ; } return 0 ; }\n","target":"<S2SV_ModStart> != JAS_CAST ( jas_uint <S2SV_ModEnd> , jas_image_numcmpts ( <S2SV_ModStart> < JAS_CAST ( jas_uint <S2SV_ModEnd> , jas_image_numcmpts ( <S2SV_ModStart> != JAS_CAST ( jas_uint <S2SV_ModEnd> , jas_image_numcmpts ( <S2SV_ModStart> < JAS_CAST ( jas_uint <S2SV_ModEnd> , jas_image_numcmpts ( <S2SV_ModStart> : JAS_CAST ( jas_uint <S2SV_ModEnd> , jas_image_numcmpts ( <S2SV_ModStart> >= JAS_CAST ( jas_uint <S2SV_ModEnd> , jas_image_numcmpts ( <S2SV_ModStart> < JAS_CAST ( jas_uint <S2SV_ModEnd> , jas_image_numcmpts (\n","project_and_commit_id":"mdadams@jasper/d42b2388f7f8e0332c846675133acea151fc557a","cve_id":"CVE-2016-9557","original_address":"https://github.com/mdadams/jasper/commit/d42b2388f7f8e0332c846675133acea151fc557a","time":"2017-03-23T18:59Z"},
	{"Unnamed: 0":1604,"cwe_id":"CWE-125","source":"CWE-125 static int parseOperand ( RAsm * a , const char * str , Operand * op , bool isrepop ) { size_t pos , nextpos = 0 ; x86newTokenType last_type ; int size_token = 1 ; bool explicit_size = false ; int reg_index = 0 ; op -> type = 0 ; while ( size_token ) { pos = nextpos ; last_type = getToken ( str , & pos , & nextpos ) ; if ( ! r_str_ncasecmp ( str + pos , \"ptr\" , 3 ) ) { continue ; } else if ( ! r_str_ncasecmp ( str + pos , \"byte\" , 4 ) ) { op -> type |= OT_MEMORY | OT_BYTE ; op -> dest_size = OT_BYTE ; explicit_size = true ; } else if ( ! r_str_ncasecmp ( str + pos , \"word\" , 4 ) ) { op -> type |= OT_MEMORY | OT_WORD ; op -> dest_size = OT_WORD ; explicit_size = true ; } else if ( ! r_str_ncasecmp ( str + pos , \"dword\" , 5 ) ) { op -> type |= OT_MEMORY | OT_DWORD ; op -> dest_size = OT_DWORD ; explicit_size = true ; } else if ( ! r_str_ncasecmp ( str + pos , \"qword\" , 5 ) ) { op -> type |= OT_MEMORY | OT_QWORD ; op -> dest_size = OT_QWORD ; explicit_size = true ; } else if ( ! r_str_ncasecmp ( str + pos , \"oword\" , 5 ) ) { op -> type |= OT_MEMORY | OT_OWORD ; op -> dest_size = OT_OWORD ; explicit_size = true ; } else if ( ! r_str_ncasecmp ( str + pos , \"tbyte\" , 5 ) ) { op -> type |= OT_MEMORY | OT_TBYTE ; op -> dest_size = OT_TBYTE ; explicit_size = true ; } else { size_token = 0 ; } } if ( str [ pos ] == '[' ) { if ( ! op -> type ) { op -> type = OT_MEMORY ; } op -> offset = op -> scale [ 0 ] = op -> scale [ 1 ] = 0 ; ut64 temp = 1 ; Register reg = X86R_UNDEFINED ; bool first_reg = true ; while ( str [ pos ] != ']' ) { if ( pos > nextpos ) { break ; } pos = nextpos ; if ( ! str [ pos ] ) { break ; } last_type = getToken ( str , & pos , & nextpos ) ; if ( last_type == TT_SPECIAL ) { if ( str [ pos ] == '+' || str [ pos ] == '-' || str [ pos ] == ']' ) { if ( reg != X86R_UNDEFINED ) { <S2SV_StartBug> op -> regs [ reg_index ] = reg ; <S2SV_EndBug> op -> scale [ reg_index ] = temp ; <S2SV_StartBug> ++ reg_index ; <S2SV_EndBug> } else { <S2SV_StartBug> op -> offset += temp ; <S2SV_EndBug> <S2SV_StartBug> op -> regs [ reg_index ] = X86R_UNDEFINED ; <S2SV_EndBug> } temp = 1 ; reg = X86R_UNDEFINED ; } else if ( str [ pos ] == '*' ) { } } else if ( last_type == TT_WORD ) { ut32 reg_type = 0 ; if ( reg != X86R_UNDEFINED ) { op -> type = 0 ; } nextpos = pos ; reg = parseReg ( a , str , & nextpos , & reg_type ) ; if ( first_reg ) { op -> extended = false ; if ( reg > 8 ) { op -> extended = true ; op -> reg = reg - 9 ; } first_reg = false ; } else if ( reg > 8 ) { op -> reg = reg - 9 ; } if ( reg_type & OT_REGTYPE & OT_SEGMENTREG ) { op -> reg = reg ; op -> type = reg_type ; parse_segment_offset ( a , str , & nextpos , op , reg_index ) ; return nextpos ; } if ( ! explicit_size ) { op -> type |= reg_type ; } op -> reg_size = reg_type ; op -> explicit_size = explicit_size ; if ( ! ( reg_type & OT_GPREG ) ) { op -> type = 0 ; } } else { char * p = strchr ( str , '+' ) ; op -> offset_sign = 1 ; if ( ! p ) { p = strchr ( str , '-' ) ; if ( p ) { op -> offset_sign = - 1 ; } } char * plus = strchr ( str , '+' ) ; char * minus = strchr ( str , '-' ) ; char * closeB = strchr ( str , ']' ) ; if ( plus && minus && plus < closeB && minus < closeB ) { op -> offset_sign = - 1 ; } char * tmp ; tmp = malloc ( strlen ( str + pos ) + 1 ) ; strcpy ( tmp , str + pos ) ; strtok ( tmp , \"+-\" ) ; st64 read = getnum ( a , tmp ) ; free ( tmp ) ; temp *= read ; } } } else if ( last_type == TT_WORD ) { nextpos = pos ; RFlagItem * flag ; if ( isrepop ) { op -> is_good_flag = false ; strncpy ( op -> rep_op , str , MAX_REPOP_LENGTH - 1 ) ; op -> rep_op [ MAX_REPOP_LENGTH - 1 ] = '\\\\0' ; return nextpos ; } op -> reg = parseReg ( a , str , & nextpos , & op -> type ) ; op -> extended = false ; if ( op -> reg > 8 ) { op -> extended = true ; op -> reg -= 9 ; } if ( op -> type & OT_REGTYPE & OT_SEGMENTREG ) { parse_segment_offset ( a , str , & nextpos , op , reg_index ) ; return nextpos ; } if ( op -> reg == X86R_UNDEFINED ) { op -> is_good_flag = false ; if ( a -> num && a -> num -> value == 0 ) { return nextpos ; } op -> type = OT_CONSTANT ; RCore * core = a -> num ? ( RCore * ) ( a -> num -> userptr ) : NULL ; if ( core && ( flag = r_flag_get ( core -> flags , str ) ) ) { op -> is_good_flag = true ; } char * p = strchr ( str , '-' ) ; if ( p ) { op -> sign = - 1 ; str = ++ p ; } op -> immediate = getnum ( a , str ) ; } else if ( op -> reg < X86R_UNDEFINED ) { strncpy ( op -> rep_op , str , MAX_REPOP_LENGTH - 1 ) ; op -> rep_op [ MAX_REPOP_LENGTH - 1 ] = '\\\\0' ; } } else { op -> type = OT_CONSTANT ; op -> sign = 1 ; char * p = strchr ( str , '-' ) ; if ( p ) { op -> sign = - 1 ; str = ++ p ; } op -> immediate = getnum ( a , str ) ; } return nextpos ; }\n","target":"<S2SV_ModStart> X86R_UNDEFINED ) { if ( reg_index < 2 ) { <S2SV_ModStart> = temp ; } <S2SV_ModStart> += temp ; if ( reg_index < 2 ) { <S2SV_ModStart> = X86R_UNDEFINED ; }\n","project_and_commit_id":"radare@radare2/9b46d38dd3c4de6048a488b655c7319f845af185","cve_id":"CVE-2018-20456","original_address":"https://github.com/radare/radare2/commit/9b46d38dd3c4de6048a488b655c7319f845af185","time":"2018-12-25T19:29Z"},
	{"Unnamed: 0":6652,"cwe_id":"CWE-20","source":"CWE-20 static int encrypt ( struct blkcipher_desc * desc , struct scatterlist * dst , struct scatterlist * src , unsigned int nbytes ) { struct blkcipher_walk walk ; struct crypto_blkcipher * tfm = desc -> tfm ; struct salsa20_ctx * ctx = crypto_blkcipher_ctx ( tfm ) ; int err ; blkcipher_walk_init ( & walk , dst , src , nbytes ) ; err = blkcipher_walk_virt_block ( desc , & walk , 64 ) ; salsa20_ivsetup ( ctx , walk . iv ) ; <S2SV_StartBug> if ( likely ( walk . nbytes == nbytes ) ) <S2SV_EndBug> { salsa20_encrypt_bytes ( ctx , walk . src . virt . addr , walk . dst . virt . addr , nbytes ) ; return blkcipher_walk_done ( desc , & walk , 0 ) ; } while ( walk . nbytes >= 64 ) { salsa20_encrypt_bytes ( ctx , walk . src . virt . addr , walk . dst . virt . addr , walk . nbytes - ( walk . nbytes % 64 ) ) ; err = blkcipher_walk_done ( desc , & walk , walk . nbytes % 64 ) ; } if ( walk . nbytes ) { salsa20_encrypt_bytes ( ctx , walk . src . virt . addr , walk . dst . virt . addr , walk . nbytes ) ; err = blkcipher_walk_done ( desc , & walk , 0 ) ; } return err ; }\n","target":"<S2SV_ModStart> iv ) ; <S2SV_ModEnd> while ( walk\n","project_and_commit_id":"torvalds@linux/ecaaab5649781c5a0effdaf298a925063020500e","cve_id":"CVE-2017-17805","original_address":"https://github.com/torvalds/linux/commit/ecaaab5649781c5a0effdaf298a925063020500e","time":"2017-12-20T23:29Z"},
	{"Unnamed: 0":4740,"cwe_id":"CWE-20","source":"CWE-20 static void dissect_rpcap_packet ( tvbuff_t * tvb , packet_info * pinfo , proto_tree * top_tree , proto_tree * parent_tree , gint offset , proto_item * top_item ) { proto_tree * tree ; proto_item * ti ; nstime_t ts ; tvbuff_t * new_tvb ; guint caplen , len , frame_no ; <S2SV_StartBug> gint reported_length_remaining ; <S2SV_EndBug> ti = proto_tree_add_item ( parent_tree , hf_packet , tvb , offset , 20 , ENC_NA ) ; tree = proto_item_add_subtree ( ti , ett_packet ) ; ts . secs = tvb_get_ntohl ( tvb , offset ) ; ts . nsecs = tvb_get_ntohl ( tvb , offset + 4 ) * 1000 ; proto_tree_add_time ( tree , hf_timestamp , tvb , offset , 8 , & ts ) ; offset += 8 ; caplen = tvb_get_ntohl ( tvb , offset ) ; ti = proto_tree_add_item ( tree , hf_caplen , tvb , offset , 4 , ENC_BIG_ENDIAN ) ; offset += 4 ; len = tvb_get_ntohl ( tvb , offset ) ; proto_tree_add_item ( tree , hf_len , tvb , offset , 4 , ENC_BIG_ENDIAN ) ; offset += 4 ; frame_no = tvb_get_ntohl ( tvb , offset ) ; proto_tree_add_item ( tree , hf_npkt , tvb , offset , 4 , ENC_BIG_ENDIAN ) ; offset += 4 ; proto_item_append_text ( ti , \",<S2SV_blank>Frame<S2SV_blank>%u\" , frame_no ) ; proto_item_append_text ( top_item , \"<S2SV_blank>Frame<S2SV_blank>%u\" , frame_no ) ; reported_length_remaining = tvb_reported_length_remaining ( tvb , offset ) ; if ( caplen > ( guint ) reported_length_remaining ) { expert_add_info ( pinfo , ti , & ei_caplen_too_big ) ; return ; } new_tvb = tvb_new_subset ( tvb , offset , caplen , len ) ; if ( decode_content && linktype != WTAP_ENCAP_UNKNOWN ) { <S2SV_StartBug> dissector_try_uint ( wtap_encap_dissector_table , linktype , new_tvb , pinfo , top_tree ) ; <S2SV_EndBug> if ( ! info_added ) { col_prepend_fence_fstr ( pinfo -> cinfo , COL_PROTOCOL , \"R|\" ) ; col_prepend_fence_fstr ( pinfo -> cinfo , COL_INFO , \"Remote<S2SV_blank>|<S2SV_blank>\" ) ; info_added = TRUE ; register_frame_end_routine ( pinfo , rpcap_frame_end ) ; } } else { if ( linktype == WTAP_ENCAP_UNKNOWN ) { proto_item_append_text ( ti , \",<S2SV_blank>Unknown<S2SV_blank>link-layer<S2SV_blank>type\" ) ; } call_dissector ( data_handle , new_tvb , pinfo , top_tree ) ; } }\n","target":"<S2SV_ModStart> ; gint reported_length_remaining ; struct eth_phdr eth ; void * phdr <S2SV_ModStart> WTAP_ENCAP_UNKNOWN ) { switch ( linktype ) { case WTAP_ENCAP_ETHERNET : eth . fcs_len = - 1 ; phdr = & eth ; break ; default : phdr = NULL ; break ; } dissector_try_uint_new <S2SV_ModEnd> ( wtap_encap_dissector_table , <S2SV_ModStart> pinfo , top_tree , TRUE , phdr\n","project_and_commit_id":"wireshark@wireshark/2c13e97d656c1c0ac4d76eb9d307664aae0e0cf7","cve_id":"CVE-2016-5358","original_address":"https://github.com/wireshark/wireshark/commit/2c13e97d656c1c0ac4d76eb9d307664aae0e0cf7","time":"2016-08-07T16:59Z"},
	{"Unnamed: 0":3464,"cwe_id":"CWE-476","source":"CWE-476 static bool LookupModMask ( struct xkb_context * ctx , const void * priv , xkb_atom_t field , enum expr_value_type type , xkb_mod_mask_t * val_rtrn ) { const char * str ; xkb_mod_index_t ndx ; const LookupModMaskPriv * arg = priv ; const struct xkb_mod_set * mods = arg -> mods ; enum mod_type mod_type = arg -> mod_type ; if ( type != EXPR_TYPE_INT ) return false ; str = xkb_atom_text ( ctx , field ) ; <S2SV_StartBug> if ( istreq ( str , \"all\" ) ) { <S2SV_EndBug> * val_rtrn = MOD_REAL_MASK_ALL ; return true ; } if ( istreq ( str , \"none\" ) ) { * val_rtrn = 0 ; return true ; } ndx = XkbModNameToIndex ( mods , field , mod_type ) ; if ( ndx == XKB_MOD_INVALID ) return false ; * val_rtrn = ( 1u << ndx ) ; return true ; }\n","target":"<S2SV_ModStart> ; if ( ! str ) return false ; if (\n","project_and_commit_id":"xkbcommon@libxkbcommon/4e2ee9c3f6050d773f8bbe05bc0edb17f1ff8371","cve_id":"CVE-2018-15862","original_address":"https://github.com/xkbcommon/libxkbcommon/commit/4e2ee9c3f6050d773f8bbe05bc0edb17f1ff8371","time":"2018-08-25T21:29Z"},
	{"Unnamed: 0":2927,"cwe_id":"CWE-362","source":"CWE-362 static int <S2SV_StartBug> mptctl_do_fw_download ( int ioc , char __user * ufwbuf , size_t fwlen ) <S2SV_EndBug> { FWDownload_t * dlmsg ; <S2SV_StartBug> MPT_FRAME_HDR * mf ; <S2SV_EndBug> MPT_ADAPTER * iocp ; FWDownloadTCSGE_t * ptsge ; MptSge_t * sgl , * sgIn ; char * sgOut ; struct buflist * buflist ; struct buflist * bl ; dma_addr_t sgl_dma ; int ret ; int numfrags = 0 ; int maxfrags ; int n = 0 ; u32 sgdir ; u32 nib ; int fw_bytes_copied = 0 ; int i ; int sge_offset = 0 ; u16 iocstat ; pFWDownloadReply_t ReplyMsg = NULL ; unsigned long timeleft ; <S2SV_StartBug> if ( mpt_verify_adapter ( ioc , & iocp ) < 0 ) { <S2SV_EndBug> printk ( KERN_DEBUG MYNAM \"ioctl_fwdl<S2SV_blank>-<S2SV_blank>ioc%d<S2SV_blank>not<S2SV_blank>found!\\\\n\" , ioc ) ; return - ENODEV ; } else { if ( ( mf = mpt_get_msg_frame ( mptctl_id , iocp ) ) == NULL ) return - EAGAIN ; <S2SV_StartBug> } <S2SV_EndBug> dctlprintk ( iocp , printk ( MYIOC_s_DEBUG_FMT \"mptctl_do_fwdl<S2SV_blank>called.<S2SV_blank>mptctl_id<S2SV_blank>=<S2SV_blank>%xh.\\\\n\" , iocp -> name , mptctl_id ) ) ; dctlprintk ( iocp , printk ( MYIOC_s_DEBUG_FMT \"DbG:<S2SV_blank>kfwdl.bufp<S2SV_blank><S2SV_blank>=<S2SV_blank>%p\\\\n\" , iocp -> name , ufwbuf ) ) ; dctlprintk ( iocp , printk ( MYIOC_s_DEBUG_FMT \"DbG:<S2SV_blank>kfwdl.fwlen<S2SV_blank>=<S2SV_blank>%d\\\\n\" , <S2SV_StartBug> iocp -> name , ( int ) fwlen ) ) ; <S2SV_EndBug> dctlprintk ( iocp , printk ( MYIOC_s_DEBUG_FMT \"DbG:<S2SV_blank>kfwdl.ioc<S2SV_blank><S2SV_blank><S2SV_blank>=<S2SV_blank>%04xh\\\\n\" , iocp -> name , ioc ) ) ; dlmsg = ( FWDownload_t * ) mf ; ptsge = ( FWDownloadTCSGE_t * ) & dlmsg -> SGL ; sgOut = ( char * ) ( ptsge + 1 ) ; dlmsg -> ImageType = MPI_FW_DOWNLOAD_ITYPE_FW ; dlmsg -> Reserved = 0 ; dlmsg -> ChainOffset = 0 ; dlmsg -> Function = MPI_FUNCTION_FW_DOWNLOAD ; dlmsg -> Reserved1 [ 0 ] = dlmsg -> Reserved1 [ 1 ] = dlmsg -> Reserved1 [ 2 ] = 0 ; if ( iocp -> facts . MsgVersion >= MPI_VERSION_01_05 ) dlmsg -> MsgFlags = MPI_FW_DOWNLOAD_MSGFLGS_LAST_SEGMENT ; else dlmsg -> MsgFlags = 0 ; ptsge -> Reserved = 0 ; ptsge -> ContextSize = 0 ; ptsge -> DetailsLength = 12 ; ptsge -> Flags = MPI_SGE_FLAGS_TRANSACTION_ELEMENT ; ptsge -> Reserved_0100_Checksum = 0 ; ptsge -> ImageOffset = 0 ; ptsge -> ImageSize = cpu_to_le32 ( fwlen ) ; sgdir = 0x04000000 ; sge_offset = sizeof ( MPIHeader_t ) + sizeof ( FWDownloadTCSGE_t ) ; if ( ( sgl = kbuf_alloc_2_sgl ( fwlen , sgdir , sge_offset , & numfrags , & buflist , & sgl_dma , iocp ) ) == NULL ) return - ENOMEM ; maxfrags = ( iocp -> req_sz - sizeof ( MPIHeader_t ) - sizeof ( FWDownloadTCSGE_t ) ) / iocp -> SGE_size ; if ( numfrags > maxfrags ) { ret = - EMLINK ; goto fwdl_out ; } dctlprintk ( iocp , printk ( MYIOC_s_DEBUG_FMT \"DbG:<S2SV_blank>sgl<S2SV_blank>buffer<S2SV_blank>=<S2SV_blank>%p,<S2SV_blank>sgfrags<S2SV_blank>=<S2SV_blank>%d\\\\n\" , iocp -> name , sgl , numfrags ) ) ; ret = - EFAULT ; sgIn = sgl ; bl = buflist ; for ( i = 0 ; i < numfrags ; i ++ ) { nib = ( sgIn -> FlagsLength & 0x30000000 ) >> 28 ; if ( nib == 0 || nib == 3 ) { ; } else if ( sgIn -> Address ) { iocp -> add_sge ( sgOut , sgIn -> FlagsLength , sgIn -> Address ) ; n ++ ; if ( copy_from_user ( bl -> kptr , ufwbuf + fw_bytes_copied , bl -> len ) ) { printk ( MYIOC_s_ERR_FMT \"%s@%d::_ioctl_fwdl<S2SV_blank>-<S2SV_blank>\" \"Unable<S2SV_blank>to<S2SV_blank>copy<S2SV_blank>f/w<S2SV_blank>buffer<S2SV_blank>hunk#%d<S2SV_blank>@<S2SV_blank>%p\\\\n\" , iocp -> name , __FILE__ , __LINE__ , n , ufwbuf ) ; goto fwdl_out ; } fw_bytes_copied += bl -> len ; } sgIn ++ ; bl ++ ; sgOut += iocp -> SGE_size ; } DBG_DUMP_FW_DOWNLOAD ( iocp , ( u32 * ) mf , numfrags ) ; ReplyMsg = NULL ; SET_MGMT_MSG_CONTEXT ( iocp -> ioctl_cmds . msg_context , dlmsg -> MsgContext ) ; INITIALIZE_MGMT_STATUS ( iocp -> ioctl_cmds . status ) mpt_put_msg_frame ( mptctl_id , iocp , mf ) ; retry_wait : timeleft = wait_for_completion_timeout ( & iocp -> ioctl_cmds . done , HZ * 60 ) ; if ( ! ( iocp -> ioctl_cmds . status & MPT_MGMT_STATUS_COMMAND_GOOD ) ) { ret = - ETIME ; printk ( MYIOC_s_WARN_FMT \"%s:<S2SV_blank>failed\\\\n\" , iocp -> name , __func__ ) ; if ( iocp -> ioctl_cmds . status & MPT_MGMT_STATUS_DID_IOCRESET ) { mpt_free_msg_frame ( iocp , mf ) ; goto fwdl_out ; } if ( ! timeleft ) { printk ( MYIOC_s_WARN_FMT \"FW<S2SV_blank>download<S2SV_blank>timeout,<S2SV_blank>doorbell=0x%08x\\\\n\" , iocp -> name , mpt_GetIocState ( iocp , 0 ) ) ; mptctl_timeout_expired ( iocp , mf ) ; } else goto retry_wait ; goto fwdl_out ; } if ( ! ( iocp -> ioctl_cmds . status & MPT_MGMT_STATUS_RF_VALID ) ) { printk ( MYIOC_s_WARN_FMT \"%s:<S2SV_blank>failed\\\\n\" , iocp -> name , __func__ ) ; mpt_free_msg_frame ( iocp , mf ) ; ret = - ENODATA ; goto fwdl_out ; } if ( sgl ) kfree_sgl ( sgl , sgl_dma , buflist , iocp ) ; ReplyMsg = ( pFWDownloadReply_t ) iocp -> ioctl_cmds . reply ; iocstat = le16_to_cpu ( ReplyMsg -> IOCStatus ) & MPI_IOCSTATUS_MASK ; if ( iocstat == MPI_IOCSTATUS_SUCCESS ) { printk ( MYIOC_s_INFO_FMT \"F/W<S2SV_blank>update<S2SV_blank>successful!\\\\n\" , iocp -> name ) ; return 0 ; } else if ( iocstat == MPI_IOCSTATUS_INVALID_FUNCTION ) { printk ( MYIOC_s_WARN_FMT \"Hmmm...<S2SV_blank><S2SV_blank>F/W<S2SV_blank>download<S2SV_blank>not<S2SV_blank>supported!?!\\\\n\" , iocp -> name ) ; printk ( MYIOC_s_WARN_FMT \"(time<S2SV_blank>to<S2SV_blank>go<S2SV_blank>bang<S2SV_blank>on<S2SV_blank>somebodies<S2SV_blank>door)\\\\n\" , iocp -> name ) ; return - EBADRQC ; } else if ( iocstat == MPI_IOCSTATUS_BUSY ) { printk ( MYIOC_s_WARN_FMT \"IOC_BUSY!\\\\n\" , iocp -> name ) ; printk ( MYIOC_s_WARN_FMT \"(try<S2SV_blank>again<S2SV_blank>later?)\\\\n\" , iocp -> name ) ; return - EBUSY ; } else { printk ( MYIOC_s_WARN_FMT \"ioctl_fwdl()<S2SV_blank>returned<S2SV_blank>[bad]<S2SV_blank>status<S2SV_blank>=<S2SV_blank>%04xh\\\\n\" , iocp -> name , iocstat ) ; printk ( MYIOC_s_WARN_FMT \"(bad<S2SV_blank>VooDoo)\\\\n\" , iocp -> name ) ; return - ENOMSG ; } return 0 ; fwdl_out : CLEAR_MGMT_STATUS ( iocp -> ioctl_cmds . status ) ; SET_MGMT_MSG_CONTEXT ( iocp -> ioctl_cmds . msg_context , 0 ) ; kfree_sgl ( sgl , sgl_dma , buflist , iocp ) ; return ret ; }\n","target":"<S2SV_ModStart> int mptctl_do_fw_download ( MPT_ADAPTER * iocp <S2SV_ModEnd> , char __user <S2SV_ModStart> MPT_FRAME_HDR * mf <S2SV_ModEnd> ; FWDownloadTCSGE_t * <S2SV_ModStart> ; if ( <S2SV_ModEnd> ( mf = <S2SV_ModStart> - EAGAIN ; <S2SV_ModEnd> dctlprintk ( iocp <S2SV_ModStart> int ) fwlen <S2SV_ModEnd> ) ) ;\n","project_and_commit_id":"torvalds@linux/28d76df18f0ad5bcf5fa48510b225f0ed262a99b","cve_id":"CVE-2020-12652","original_address":"https://github.com/torvalds/linux/commit/28d76df18f0ad5bcf5fa48510b225f0ed262a99b","time":"2020-05-05T05:15Z"},
	{"Unnamed: 0":1108,"cwe_id":"CWE-119","source":"CWE-119 static int iscsi_add_notunderstood_response ( char * key , char * value , struct iscsi_param_list * param_list ) { struct iscsi_extra_response * extra_response ; if ( strlen ( value ) > VALUE_MAXLEN ) { pr_err ( \"Value<S2SV_blank>for<S2SV_blank>notunderstood<S2SV_blank>key<S2SV_blank>\\\\\"%s\\\\\"<S2SV_blank>exceeds<S2SV_blank>%d,\" \"<S2SV_blank>protocol<S2SV_blank>error.\\\\n\" , key , VALUE_MAXLEN ) ; return - 1 ; } extra_response = kzalloc ( sizeof ( struct iscsi_extra_response ) , GFP_KERNEL ) ; if ( ! extra_response ) { pr_err ( \"Unable<S2SV_blank>to<S2SV_blank>allocate<S2SV_blank>memory<S2SV_blank>for\" \"<S2SV_blank>struct<S2SV_blank>iscsi_extra_response.\\\\n\" ) ; return - 1 ; } INIT_LIST_HEAD ( & extra_response -> er_list ) ; <S2SV_StartBug> strncpy ( extra_response -> key , key , strlen ( key ) + 1 ) ; <S2SV_EndBug> strncpy ( extra_response -> value , NOTUNDERSTOOD , <S2SV_StartBug> strlen ( NOTUNDERSTOOD ) + 1 ) ; <S2SV_EndBug> list_add_tail ( & extra_response -> er_list , & param_list -> extra_response_list ) ; return 0 ; }\n","target":"<S2SV_ModStart> er_list ) ; strlcpy <S2SV_ModEnd> ( extra_response -> <S2SV_ModStart> , key , sizeof ( extra_response -> key ) ) ; strlcpy <S2SV_ModEnd> ( extra_response -> <S2SV_ModStart> , NOTUNDERSTOOD , sizeof ( extra_response -> value ) <S2SV_ModEnd> ) ; list_add_tail\n","project_and_commit_id":"torvalds@linux/cea4dcfdad926a27a18e188720efe0f2c9403456","cve_id":"CVE-2013-2850","original_address":"https://github.com/torvalds/linux/commit/cea4dcfdad926a27a18e188720efe0f2c9403456","time":"2013-06-07T14:03Z"},
	{"Unnamed: 0":2715,"cwe_id":"CWE-908","source":"CWE-908 static int kvaser_usb_leaf_simple_cmd_async ( struct kvaser_usb_net_priv * priv , u8 cmd_id ) { struct kvaser_cmd * cmd ; int err ; <S2SV_StartBug> cmd = kmalloc ( sizeof ( * cmd ) , GFP_ATOMIC ) ; <S2SV_EndBug> if ( ! cmd ) return - ENOMEM ; cmd -> len = CMD_HEADER_LEN + sizeof ( struct kvaser_cmd_simple ) ; cmd -> id = cmd_id ; cmd -> u . simple . channel = priv -> channel ; err = kvaser_usb_send_cmd_async ( priv , cmd , cmd -> len ) ; if ( err ) kfree ( cmd ) ; return err ; }\n","target":"<S2SV_ModStart> ; cmd = kzalloc <S2SV_ModEnd> ( sizeof (\n","project_and_commit_id":"torvalds@linux/da2311a6385c3b499da2ed5d9be59ce331fa93e9","cve_id":"CVE-2019-19947","original_address":"https://github.com/torvalds/linux/commit/da2311a6385c3b499da2ed5d9be59ce331fa93e9","time":"2019-12-24T00:15Z"},
	{"Unnamed: 0":4870,"cwe_id":"CWE-190","source":"CWE-190 static Image * ReadTXTImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { char colorspace [ MaxTextExtent ] , text [ MaxTextExtent ] ; Image * image ; IndexPacket * indexes ; long x_offset , y_offset ; MagickBooleanType status ; MagickPixelPacket pixel ; QuantumAny range ; register ssize_t i , x ; register PixelPacket * q ; ssize_t count , type , y ; unsigned long depth , height , max_value , width ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickSignature ) ; if ( image_info -> debug != MagickFalse ) ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , \"%s\" , image_info -> filename ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickSignature ) ; image = AcquireImage ( image_info ) ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } ( void ) ResetMagickMemory ( text , 0 , sizeof ( text ) ) ; ( void ) ReadBlobString ( image , text ) ; if ( LocaleNCompare ( ( char * ) text , MagickID , strlen ( MagickID ) ) != 0 ) ThrowReaderException ( CorruptImageError , \"ImproperImageHeader\" ) ; do { width = 0 ; height = 0 ; max_value = 0 ; * colorspace = '\\\\0' ; count = ( ssize_t ) sscanf ( text + 32 , \"%lu,%lu,%lu,%s\" , & width , & height , & max_value , colorspace ) ; if ( ( count != 4 ) || ( width == 0 ) || ( height == 0 ) || ( max_value == 0 ) ) ThrowReaderException ( CorruptImageError , \"ImproperImageHeader\" ) ; image -> columns = width ; image -> rows = height ; <S2SV_StartBug> for ( depth = 1 ; ( GetQuantumRange ( depth ) + 1 ) < max_value ; depth ++ ) <S2SV_EndBug> <S2SV_StartBug> if ( depth >= 64 ) <S2SV_EndBug> break ; image -> depth = depth ; status = SetImageExtent ( image , image -> columns , image -> rows ) ; if ( status == MagickFalse ) { InheritException ( exception , & image -> exception ) ; return ( DestroyImageList ( image ) ) ; } LocaleLower ( colorspace ) ; i = ( ssize_t ) strlen ( colorspace ) - 1 ; image -> matte = MagickFalse ; if ( ( i > 0 ) && ( colorspace [ i ] == 'a' ) ) { colorspace [ i ] = '\\\\0' ; image -> matte = MagickTrue ; } type = ParseCommandOption ( MagickColorspaceOptions , MagickFalse , colorspace ) ; if ( type < 0 ) ThrowReaderException ( CorruptImageError , \"ImproperImageHeader\" ) ; image -> colorspace = ( ColorspaceType ) type ; ( void ) ResetMagickMemory ( & pixel , 0 , sizeof ( pixel ) ) ; ( void ) SetImageBackgroundColor ( image ) ; range = GetQuantumRange ( image -> depth ) ; for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { double blue , green , index , opacity , red ; red = 0.0 ; green = 0.0 ; blue = 0.0 ; index = 0.0 ; opacity = 0.0 ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { if ( ReadBlobString ( image , text ) == ( char * ) NULL ) break ; switch ( image -> colorspace ) { case GRAYColorspace : { if ( image -> matte != MagickFalse ) { ( void ) sscanf ( text , \"%ld,%ld:<S2SV_blank>(%lf%*[%,]%lf%*[%,]\" , & x_offset , & y_offset , & red , & opacity ) ; green = red ; blue = red ; break ; } ( void ) sscanf ( text , \"%ld,%ld:<S2SV_blank>(%lf%*[%,]\" , & x_offset , & y_offset , & red ) ; green = red ; blue = red ; break ; } case CMYKColorspace : { if ( image -> matte != MagickFalse ) { ( void ) sscanf ( text , \"%ld,%ld:<S2SV_blank>(%lf%*[%,]%lf%*[%,]%lf%*[%,]%lf%*[%,]%lf%*[%,]\" , & x_offset , & y_offset , & red , & green , & blue , & index , & opacity ) ; break ; } ( void ) sscanf ( text , \"%ld,%ld:<S2SV_blank>(%lf%*[%,]%lf%*[%,]%lf%*[%,]%lf%*[%,]\" , & x_offset , & y_offset , & red , & green , & blue , & index ) ; break ; } default : { if ( image -> matte != MagickFalse ) { ( void ) sscanf ( text , \"%ld,%ld:<S2SV_blank>(%lf%*[%,]%lf%*[%,]%lf%*[%,]%lf%*[%,]\" , & x_offset , & y_offset , & red , & green , & blue , & opacity ) ; break ; } ( void ) sscanf ( text , \"%ld,%ld:<S2SV_blank>(%lf%*[%,]%lf%*[%,]%lf%*[%,]\" , & x_offset , & y_offset , & red , & green , & blue ) ; break ; } } if ( strchr ( text , '%' ) != ( char * ) NULL ) { red *= 0.01 * range ; green *= 0.01 * range ; blue *= 0.01 * range ; index *= 0.01 * range ; opacity *= 0.01 * range ; } if ( image -> colorspace == LabColorspace ) { green += ( range + 1 ) / 2.0 ; blue += ( range + 1 ) / 2.0 ; } pixel . red = ( MagickRealType ) ScaleAnyToQuantum ( ( QuantumAny ) ( red + 0.5 ) , range ) ; pixel . green = ( MagickRealType ) ScaleAnyToQuantum ( ( QuantumAny ) ( green + 0.5 ) , range ) ; pixel . blue = ( MagickRealType ) ScaleAnyToQuantum ( ( QuantumAny ) ( blue + 0.5 ) , range ) ; pixel . index = ( MagickRealType ) ScaleAnyToQuantum ( ( QuantumAny ) ( index + 0.5 ) , range ) ; pixel . opacity = ( MagickRealType ) ScaleAnyToQuantum ( ( QuantumAny ) ( opacity + 0.5 ) , range ) ; q = GetAuthenticPixels ( image , ( ssize_t ) x_offset , ( ssize_t ) y_offset , 1 , 1 , exception ) ; if ( q == ( PixelPacket * ) NULL ) continue ; SetPixelRed ( q , pixel . red ) ; SetPixelGreen ( q , pixel . green ) ; SetPixelBlue ( q , pixel . blue ) ; if ( image -> colorspace == CMYKColorspace ) { indexes = GetAuthenticIndexQueue ( image ) ; SetPixelIndex ( indexes , pixel . index ) ; } if ( image -> matte != MagickFalse ) SetPixelAlpha ( q , pixel . opacity ) ; if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; } } if ( EOFBlob ( image ) != MagickFalse ) { ThrowFileException ( exception , CorruptImageError , \"UnexpectedEndOfFile\" , image -> filename ) ; break ; } ( void ) ReadBlobString ( image , text ) ; if ( LocaleNCompare ( ( char * ) text , MagickID , strlen ( MagickID ) ) == 0 ) { AcquireNextImage ( image_info , image ) ; if ( GetNextImageInList ( image ) == ( Image * ) NULL ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } image = SyncNextImageInList ( image ) ; status = SetImageProgress ( image , LoadImagesTag , TellBlob ( image ) , GetBlobSize ( image ) ) ; if ( status == MagickFalse ) break ; } } while ( LocaleNCompare ( ( char * ) text , MagickID , strlen ( MagickID ) ) == 0 ) ; ( void ) CloseBlob ( image ) ; return ( GetFirstImageInList ( image ) ) ; }\n","target":"<S2SV_ModStart> = height ; if ( ( max_value == 0 ) || ( max_value > 4294967295 ) ) ThrowReaderException ( CorruptImageError , \"ImproperImageHeader\" ) ; <S2SV_ModStart> depth ++ ) <S2SV_ModEnd> ; image ->\n","project_and_commit_id":"ImageMagick@ImageMagick/48bcf7c39302cdf9b0d9202ad03bf1b95152c44d","cve_id":"CVE-2017-14173","original_address":"https://github.com/ImageMagick/ImageMagick/commit/48bcf7c39302cdf9b0d9202ad03bf1b95152c44d","time":"2017-09-07T06:29Z"},
	{"Unnamed: 0":862,"cwe_id":"CWE-119","source":"CWE-119 static int dtls1_process_record ( SSL * s ) { int i , al ; int enc_err ; SSL_SESSION * sess ; SSL3_RECORD * rr ; unsigned int mac_size ; unsigned char md [ EVP_MAX_MD_SIZE ] ; rr = & ( s -> s3 -> rrec ) ; sess = s -> session ; rr -> input = & ( s -> packet [ DTLS1_RT_HEADER_LENGTH ] ) ; if ( rr -> length > SSL3_RT_MAX_ENCRYPTED_LENGTH ) { al = SSL_AD_RECORD_OVERFLOW ; SSLerr ( SSL_F_DTLS1_PROCESS_RECORD , SSL_R_ENCRYPTED_LENGTH_TOO_LONG ) ; goto f_err ; } rr -> data = rr -> input ; rr -> orig_len = rr -> length ; enc_err = s -> method -> ssl3_enc -> enc ( s , 0 ) ; if ( enc_err == 0 ) { rr -> length = 0 ; s -> packet_length = 0 ; goto err ; } # ifdef TLS_DEBUG printf ( \"dec<S2SV_blank>%d\\\\n\" , rr -> length ) ; { unsigned int z ; for ( z = 0 ; z < rr -> length ; z ++ ) printf ( \"%02X%c\" , rr -> data [ z ] , ( ( z + 1 ) % 16 ) ? '<S2SV_blank>' : '\\\\n' ) ; } printf ( \"\\\\n\" ) ; # endif if ( ( sess != NULL ) && ( s -> enc_read_ctx != NULL ) && ( EVP_MD_CTX_md ( s -> read_hash ) != NULL ) ) { unsigned char * mac = NULL ; unsigned char mac_tmp [ EVP_MAX_MD_SIZE ] ; mac_size = EVP_MD_CTX_size ( s -> read_hash ) ; OPENSSL_assert ( mac_size <= EVP_MAX_MD_SIZE ) ; if ( rr -> orig_len < mac_size || ( EVP_CIPHER_CTX_mode ( s -> enc_read_ctx ) == EVP_CIPH_CBC_MODE && rr -> orig_len < mac_size + 1 ) ) { al = SSL_AD_DECODE_ERROR ; SSLerr ( SSL_F_DTLS1_PROCESS_RECORD , SSL_R_LENGTH_TOO_SHORT ) ; goto f_err ; } if ( EVP_CIPHER_CTX_mode ( s -> enc_read_ctx ) == EVP_CIPH_CBC_MODE ) { mac = mac_tmp ; ssl3_cbc_copy_mac ( mac_tmp , rr , mac_size ) ; rr -> length -= mac_size ; } else { rr -> length -= mac_size ; mac = & rr -> data [ rr -> length ] ; } i = s -> method -> ssl3_enc -> mac ( s , md , 0 ) ; if ( i < 0 || mac == NULL || CRYPTO_memcmp ( md , mac , ( size_t ) mac_size ) != 0 ) enc_err = - 1 ; if ( rr -> length > SSL3_RT_MAX_COMPRESSED_LENGTH + mac_size ) enc_err = - 1 ; } if ( enc_err < 0 ) { rr -> length = 0 ; s -> packet_length = 0 ; goto err ; } if ( s -> expand != NULL ) { if ( rr -> length > SSL3_RT_MAX_COMPRESSED_LENGTH ) { al = SSL_AD_RECORD_OVERFLOW ; SSLerr ( SSL_F_DTLS1_PROCESS_RECORD , SSL_R_COMPRESSED_LENGTH_TOO_LONG ) ; goto f_err ; } if ( ! ssl3_do_uncompress ( s ) ) { al = SSL_AD_DECOMPRESSION_FAILURE ; SSLerr ( SSL_F_DTLS1_PROCESS_RECORD , SSL_R_BAD_DECOMPRESSION ) ; goto f_err ; } } if ( rr -> length > SSL3_RT_MAX_PLAIN_LENGTH ) { al = SSL_AD_RECORD_OVERFLOW ; SSLerr ( SSL_F_DTLS1_PROCESS_RECORD , SSL_R_DATA_LENGTH_TOO_LONG ) ; goto f_err ; } rr -> off = 0 ; s -> packet_length = 0 ; <S2SV_StartBug> dtls1_record_bitmap_update ( s , & ( s -> d1 -> bitmap ) ) ; <S2SV_EndBug> return ( 1 ) ; f_err : ssl3_send_alert ( s , SSL3_AL_FATAL , al ) ; err : return ( 0 ) ; }\n","target":"<S2SV_ModStart> = 0 ; <S2SV_ModEnd> return ( 1\n","project_and_commit_id":"openssl@openssl/103b171d8fc282ef435f8de9afbf7782e312961f","cve_id":"CVE-2015-0206","original_address":"https://github.com/openssl/openssl/commit/103b171d8fc282ef435f8de9afbf7782e312961f","time":"2015-01-09T02:59Z"},
	{"Unnamed: 0":1156,"cwe_id":"CWE-284","source":"CWE-284 int btpan_tap_open ( ) { struct ifreq ifr ; int fd , err ; const char * clonedev = \"/dev/tun\" ; <S2SV_StartBug> if ( ( fd = open ( clonedev , O_RDWR ) ) < 0 ) <S2SV_EndBug> { BTIF_TRACE_DEBUG ( \"could<S2SV_blank>not<S2SV_blank>open<S2SV_blank>%s,<S2SV_blank>err:%d\" , clonedev , errno ) ; return fd ; } memset ( & ifr , 0 , sizeof ( ifr ) ) ; ifr . ifr_flags = IFF_TAP | IFF_NO_PI ; strncpy ( ifr . ifr_name , TAP_IF_NAME , IFNAMSIZ ) ; <S2SV_StartBug> if ( ( err = ioctl ( fd , TUNSETIFF , ( void * ) & ifr ) ) < 0 ) <S2SV_EndBug> { BTIF_TRACE_DEBUG ( \"ioctl<S2SV_blank>error:%d,<S2SV_blank>errno:%s\" , err , strerror ( errno ) ) ; close ( fd ) ; return err ; } if ( tap_if_up ( TAP_IF_NAME , controller_get_interface ( ) -> get_address ( ) ) == 0 ) { <S2SV_StartBug> int flags = fcntl ( fd , F_GETFL , 0 ) ; <S2SV_EndBug> <S2SV_StartBug> fcntl ( fd , F_SETFL , flags | O_NONBLOCK ) ; <S2SV_EndBug> return fd ; } BTIF_TRACE_ERROR ( \"can<S2SV_blank>not<S2SV_blank>bring<S2SV_blank>up<S2SV_blank>tap<S2SV_blank>interface:%s\" , TAP_IF_NAME ) ; close ( fd ) ; return INVALID_FD ; }\n","target":"<S2SV_ModStart> ( fd = TEMP_FAILURE_RETRY ( <S2SV_ModStart> clonedev , O_RDWR ) <S2SV_ModStart> ( err = TEMP_FAILURE_RETRY ( <S2SV_ModStart> ifr ) ) ) <S2SV_ModStart> int flags = TEMP_FAILURE_RETRY ( <S2SV_ModStart> , 0 ) ) ; TEMP_FAILURE_RETRY ( <S2SV_ModEnd> fcntl ( fd <S2SV_ModStart> | O_NONBLOCK ) )\n","project_and_commit_id":"system@bt/472271b153c5dc53c28beac55480a8d8434b2d5c","cve_id":"CVE-2016-3839","original_address":"https://android.googlesource.com/platform/system/bt/+/472271b153c5dc53c28beac55480a8d8434b2d5c","time":"2016-08-05T20:59Z"},
	{"Unnamed: 0":5999,"cwe_id":"CWE-000","source":"CWE-000 int usbnet_probe ( struct usb_interface * udev , const struct usb_device_id * prod ) { struct usbnet * dev ; struct net_device * net ; struct usb_host_interface * interface ; struct driver_info * info ; struct usb_device * xdev ; int status ; const char * name ; struct usb_driver * driver = to_usb_driver ( udev -> dev . driver ) ; if ( ! driver -> supports_autosuspend ) { driver -> supports_autosuspend = 1 ; pm_runtime_enable ( & udev -> dev ) ; } name = udev -> dev . driver -> name ; info = ( struct driver_info * ) prod -> driver_info ; if ( ! info ) { dev_dbg ( & udev -> dev , \"blacklisted<S2SV_blank>by<S2SV_blank>%s\\\\n\" , name ) ; return - ENODEV ; } xdev = interface_to_usbdev ( udev ) ; interface = udev -> cur_altsetting ; status = - ENOMEM ; net = alloc_etherdev ( sizeof ( * dev ) ) ; if ( ! net ) goto out ; SET_NETDEV_DEV ( net , & udev -> dev ) ; dev = netdev_priv ( net ) ; dev -> udev = xdev ; dev -> intf = udev ; dev -> driver_info = info ; dev -> driver_name = name ; dev -> msg_enable = netif_msg_init ( msg_level , NETIF_MSG_DRV | NETIF_MSG_PROBE | NETIF_MSG_LINK ) ; init_waitqueue_head ( & dev -> wait ) ; skb_queue_head_init ( & dev -> rxq ) ; skb_queue_head_init ( & dev -> txq ) ; skb_queue_head_init ( & dev -> done ) ; skb_queue_head_init ( & dev -> rxq_pause ) ; dev -> bh . func = usbnet_bh ; dev -> bh . data = ( unsigned long ) dev ; INIT_WORK ( & dev -> kevent , usbnet_deferred_kevent ) ; init_usb_anchor ( & dev -> deferred ) ; dev -> delay . function = usbnet_bh ; dev -> delay . data = ( unsigned long ) dev ; init_timer ( & dev -> delay ) ; mutex_init ( & dev -> phy_mutex ) ; mutex_init ( & dev -> interrupt_mutex ) ; dev -> interrupt_count = 0 ; dev -> net = net ; strcpy ( net -> name , \"usb%d\" ) ; memcpy ( net -> dev_addr , node_id , sizeof node_id ) ; dev -> hard_mtu = net -> mtu + net -> hard_header_len ; net -> netdev_ops = & usbnet_netdev_ops ; net -> watchdog_timeo = TX_TIMEOUT_JIFFIES ; net -> ethtool_ops = & usbnet_ethtool_ops ; if ( info -> bind ) { status = info -> bind ( dev , udev ) ; if ( status < 0 ) goto out1 ; if ( ( dev -> driver_info -> flags & FLAG_ETHER ) != 0 && ( ( dev -> driver_info -> flags & FLAG_POINTTOPOINT ) == 0 || ( net -> dev_addr [ 0 ] & 0x02 ) == 0 ) ) strcpy ( net -> name , \"eth%d\" ) ; if ( ( dev -> driver_info -> flags & FLAG_WLAN ) != 0 ) strcpy ( net -> name , \"wlan%d\" ) ; if ( ( dev -> driver_info -> flags & FLAG_WWAN ) != 0 ) strcpy ( net -> name , \"wwan%d\" ) ; if ( ( dev -> driver_info -> flags & FLAG_NOARP ) != 0 ) net -> flags |= IFF_NOARP ; if ( net -> mtu > ( dev -> hard_mtu - net -> hard_header_len ) ) net -> mtu = dev -> hard_mtu - net -> hard_header_len ; } else if ( ! info -> in || ! info -> out ) status = usbnet_get_endpoints ( dev , udev ) ; else { dev -> in = usb_rcvbulkpipe ( xdev , info -> in ) ; dev -> out = usb_sndbulkpipe ( xdev , info -> out ) ; if ( ! ( info -> flags & FLAG_NO_SETINT ) ) status = usb_set_interface ( xdev , interface -> desc . bInterfaceNumber , interface -> desc . bAlternateSetting ) ; else status = 0 ; } if ( status >= 0 && dev -> status ) status = init_status ( dev , udev ) ; if ( status < 0 ) goto out3 ; if ( ! dev -> rx_urb_size ) dev -> rx_urb_size = dev -> hard_mtu ; dev -> maxpacket = usb_maxpacket ( dev -> udev , dev -> out , 1 ) ; if ( ether_addr_equal ( net -> dev_addr , node_id ) ) net -> addr_assign_type = NET_ADDR_RANDOM ; if ( ( dev -> driver_info -> flags & FLAG_WLAN ) != 0 ) SET_NETDEV_DEVTYPE ( net , & wlan_type ) ; if ( ( dev -> driver_info -> flags & FLAG_WWAN ) != 0 ) SET_NETDEV_DEVTYPE ( net , & wwan_type ) ; usbnet_update_max_qlen ( dev ) ; if ( dev -> can_dma_sg && ! ( info -> flags & FLAG_SEND_ZLP ) && ! ( info -> flags & FLAG_MULTI_PACKET ) ) { dev -> padding_pkt = kzalloc ( 1 , GFP_KERNEL ) ; if ( ! dev -> padding_pkt ) { status = - ENOMEM ; goto out4 ; } } status = register_netdev ( net ) ; if ( status ) goto out5 ; netif_info ( dev , probe , dev -> net , \"register<S2SV_blank>\\'%s\\'<S2SV_blank>at<S2SV_blank>usb-%s-%s,<S2SV_blank>%s,<S2SV_blank>%pM\\\\n\" , udev -> dev . driver -> name , xdev -> bus -> bus_name , xdev -> devpath , dev -> driver_info -> description , net -> dev_addr ) ; usb_set_intfdata ( udev , dev ) ; netif_device_attach ( net ) ; if ( dev -> driver_info -> flags & FLAG_LINK_INTR ) usbnet_link_change ( dev , 0 , 0 ) ; return 0 ; out5 : kfree ( dev -> padding_pkt ) ; out4 : usb_free_urb ( dev -> interrupt ) ; out3 : if ( info -> unbind ) info -> unbind ( dev , udev ) ; out1 : <S2SV_StartBug> free_netdev ( net ) ; <S2SV_EndBug> out : return status ; }\n","target":"<S2SV_ModStart> ; out1 : cancel_work_sync ( & dev -> kevent ) ; del_timer_sync ( & dev -> delay ) ;\n","project_and_commit_id":"torvalds@linux/1666984c8625b3db19a9abc298931d35ab7bc64b","cve_id":"CVE-2016-3951","original_address":"https://github.com/torvalds/linux/commit/1666984c8625b3db19a9abc298931d35ab7bc64b","time":"2016-05-02T10:59Z"},
	{"Unnamed: 0":5037,"cwe_id":"CWE-754","source":"CWE-754 STATIC int xfs_attr_shortform_addname ( xfs_da_args_t * args ) { int newsize , forkoff , retval ; trace_xfs_attr_sf_addname ( args ) ; retval = xfs_attr_shortform_lookup ( args ) ; if ( ( args -> flags & ATTR_REPLACE ) && ( retval == - ENOATTR ) ) { return retval ; } else if ( retval == - EEXIST ) { if ( args -> flags & ATTR_CREATE ) return retval ; retval = xfs_attr_shortform_remove ( args ) ; <S2SV_StartBug> ASSERT ( retval == 0 ) ; <S2SV_EndBug> } if ( args -> namelen >= XFS_ATTR_SF_ENTSIZE_MAX || args -> valuelen >= XFS_ATTR_SF_ENTSIZE_MAX ) return - ENOSPC ; newsize = XFS_ATTR_SF_TOTSIZE ( args -> dp ) ; newsize += XFS_ATTR_SF_ENTSIZE_BYNAME ( args -> namelen , args -> valuelen ) ; forkoff = xfs_attr_shortform_bytesfit ( args -> dp , newsize ) ; if ( ! forkoff ) return - ENOSPC ; xfs_attr_shortform_add ( args , forkoff ) ; return 0 ; }\n","target":"<S2SV_ModStart> args ) ; if ( retval ) return retval ; args -> flags &= ~ ATTR_REPLACE <S2SV_ModEnd> ; } if\n","project_and_commit_id":"torvalds@linux/7b38460dc8e4eafba06c78f8e37099d3b34d473c","cve_id":"CVE-2018-18690","original_address":"https://github.com/torvalds/linux/commit/7b38460dc8e4eafba06c78f8e37099d3b34d473c","time":"2018-10-26T18:29Z"},
	{"Unnamed: 0":4542,"cwe_id":"CWE-190","source":"CWE-190 int drm_mode_dirtyfb_ioctl ( struct drm_device * dev , void * data , struct drm_file * file_priv ) { struct drm_clip_rect __user * clips_ptr ; struct drm_clip_rect * clips = NULL ; struct drm_mode_fb_dirty_cmd * r = data ; struct drm_mode_object * obj ; struct drm_framebuffer * fb ; unsigned flags ; int num_clips ; int ret = 0 ; if ( ! drm_core_check_feature ( dev , DRIVER_MODESET ) ) return - EINVAL ; mutex_lock ( & dev -> mode_config . mutex ) ; obj = drm_mode_object_find ( dev , r -> fb_id , DRM_MODE_OBJECT_FB ) ; if ( ! obj ) { DRM_ERROR ( \"invalid<S2SV_blank>framebuffer<S2SV_blank>id\\\\n\" ) ; ret = - EINVAL ; goto out_err1 ; } fb = obj_to_fb ( obj ) ; num_clips = r -> num_clips ; clips_ptr = ( struct drm_clip_rect * ) ( unsigned long ) r -> clips_ptr ; if ( ! num_clips != ! clips_ptr ) { ret = - EINVAL ; goto out_err1 ; } flags = DRM_MODE_FB_DIRTY_FLAGS & r -> flags ; if ( flags & DRM_MODE_FB_DIRTY_ANNOTATE_COPY && ( num_clips % 2 ) ) { ret = - EINVAL ; goto out_err1 ; } if ( num_clips && clips_ptr ) { <S2SV_StartBug> clips = kzalloc ( num_clips * sizeof ( * clips ) , GFP_KERNEL ) ; <S2SV_EndBug> if ( ! clips ) { ret = - ENOMEM ; goto out_err1 ; } ret = copy_from_user ( clips , clips_ptr , num_clips * sizeof ( * clips ) ) ; if ( ret ) { ret = - EFAULT ; goto out_err2 ; } } if ( fb -> funcs -> dirty ) { ret = fb -> funcs -> dirty ( fb , file_priv , flags , r -> color , clips , num_clips ) ; } else { ret = - ENOSYS ; goto out_err2 ; } out_err2 : kfree ( clips ) ; out_err1 : mutex_unlock ( & dev -> mode_config . mutex ) ; return ret ; }\n","target":"<S2SV_ModStart> clips_ptr ) { if ( num_clips < 0 || num_clips > DRM_MODE_FB_DIRTY_MAX_CLIPS ) { ret = - EINVAL ; goto out_err1 ; }\n","project_and_commit_id":"torvalds@linux/a5cd335165e31db9dbab636fd29895d41da55dd2","cve_id":"CVE-2012-0044","original_address":"https://github.com/torvalds/linux/commit/a5cd335165e31db9dbab636fd29895d41da55dd2","time":"2012-05-17T11:00Z"},
	{"Unnamed: 0":996,"cwe_id":"CWE-284","source":"CWE-284 void btif_hl_select_monitor_callback ( fd_set * p_cur_set , fd_set * p_org_set ) { UNUSED ( p_org_set ) ; BTIF_TRACE_DEBUG ( \"entering<S2SV_blank>%s\" , __FUNCTION__ ) ; for ( const list_node_t * node = list_begin ( soc_queue ) ; node != list_end ( soc_queue ) ; node = list_next ( node ) ) { btif_hl_soc_cb_t * p_scb = list_node ( node ) ; if ( btif_hl_get_socket_state ( p_scb ) == BTIF_HL_SOC_STATE_W4_READ ) { if ( FD_ISSET ( p_scb -> socket_id [ 1 ] , p_cur_set ) ) { BTIF_TRACE_DEBUG ( \"read<S2SV_blank>data<S2SV_blank>state=<S2SV_blank>BTIF_HL_SOC_STATE_W4_READ\" ) ; btif_hl_mdl_cb_t * p_dcb = BTIF_HL_GET_MDL_CB_PTR ( p_scb -> app_idx , p_scb -> mcl_idx , p_scb -> mdl_idx ) ; assert ( p_dcb != NULL ) ; if ( p_dcb -> p_tx_pkt ) { BTIF_TRACE_ERROR ( \"Rcv<S2SV_blank>new<S2SV_blank>pkt<S2SV_blank>but<S2SV_blank>the<S2SV_blank>last<S2SV_blank>pkt<S2SV_blank>is<S2SV_blank>still<S2SV_blank>not<S2SV_blank>been\" \"<S2SV_blank><S2SV_blank>sent<S2SV_blank>tx_size=%d\" , p_dcb -> tx_size ) ; btif_hl_free_buf ( ( void * * ) & p_dcb -> p_tx_pkt ) ; } p_dcb -> p_tx_pkt = btif_hl_get_buf ( p_dcb -> mtu ) ; if ( p_dcb ) { <S2SV_StartBug> int r = ( int ) recv ( p_scb -> socket_id [ 1 ] , p_dcb -> p_tx_pkt , <S2SV_EndBug> <S2SV_StartBug> p_dcb -> mtu , MSG_DONTWAIT ) ; <S2SV_EndBug> if ( r > 0 ) { BTIF_TRACE_DEBUG ( \"btif_hl_select_monitor_callback<S2SV_blank>send<S2SV_blank>data<S2SV_blank>r<S2SV_blank>=%d\" , r ) ; p_dcb -> tx_size = r ; BTIF_TRACE_DEBUG ( \"btif_hl_select_monitor_callback<S2SV_blank>send<S2SV_blank>data<S2SV_blank>tx_size=%d\" , p_dcb -> tx_size ) ; BTA_HlSendData ( p_dcb -> mdl_handle , p_dcb -> tx_size ) ; } else { BTIF_TRACE_DEBUG ( \"btif_hl_select_monitor_callback<S2SV_blank>receive<S2SV_blank>failed<S2SV_blank>r=%d\" , r ) ; BTA_HlDchClose ( p_dcb -> mdl_handle ) ; } } } } } if ( list_is_empty ( soc_queue ) ) BTIF_TRACE_DEBUG ( \"btif_hl_select_monitor_queue<S2SV_blank>is<S2SV_blank>empty\" ) ; BTIF_TRACE_DEBUG ( \"leaving<S2SV_blank>%s\" , __FUNCTION__ ) ; }\n","target":"<S2SV_ModStart> ( int ) TEMP_FAILURE_RETRY ( <S2SV_ModStart> , MSG_DONTWAIT ) )\n","project_and_commit_id":"system@bt/472271b153c5dc53c28beac55480a8d8434b2d5c","cve_id":"CVE-2016-3839","original_address":"https://android.googlesource.com/platform/system/bt/+/472271b153c5dc53c28beac55480a8d8434b2d5c","time":"2016-08-05T20:59Z"},
	{"Unnamed: 0":6150,"cwe_id":"CWE-200","source":"CWE-200 static int iucv_sock_recvmsg ( struct kiocb * iocb , struct socket * sock , struct msghdr * msg , size_t len , int flags ) { int noblock = flags & MSG_DONTWAIT ; struct sock * sk = sock -> sk ; struct iucv_sock * iucv = iucv_sk ( sk ) ; unsigned int copied , rlen ; struct sk_buff * skb , * rskb , * cskb ; <S2SV_StartBug> int err = 0 ; <S2SV_EndBug> if ( ( sk -> sk_state == IUCV_DISCONN ) && skb_queue_empty ( & iucv -> backlog_skb_q ) && skb_queue_empty ( & sk -> sk_receive_queue ) && list_empty ( & iucv -> message_q . list ) ) return 0 ; if ( flags & ( MSG_OOB ) ) return - EOPNOTSUPP ; skb = skb_recv_datagram ( sk , flags , noblock , & err ) ; if ( ! skb ) { if ( sk -> sk_shutdown & RCV_SHUTDOWN ) return 0 ; return err ; } rlen = skb -> len ; copied = min_t ( unsigned int , rlen , len ) ; if ( ! rlen ) sk -> sk_shutdown = sk -> sk_shutdown | RCV_SHUTDOWN ; cskb = skb ; if ( skb_copy_datagram_iovec ( cskb , 0 , msg -> msg_iov , copied ) ) { if ( ! ( flags & MSG_PEEK ) ) skb_queue_head ( & sk -> sk_receive_queue , skb ) ; return - EFAULT ; } if ( sk -> sk_type == SOCK_SEQPACKET ) { if ( copied < rlen ) msg -> msg_flags |= MSG_TRUNC ; msg -> msg_flags |= MSG_EOR ; } err = put_cmsg ( msg , SOL_IUCV , SCM_IUCV_TRGCLS , CB_TRGCLS_LEN , CB_TRGCLS ( skb ) ) ; if ( err ) { if ( ! ( flags & MSG_PEEK ) ) skb_queue_head ( & sk -> sk_receive_queue , skb ) ; return err ; } if ( ! ( flags & MSG_PEEK ) ) { if ( sk -> sk_type == SOCK_STREAM ) { skb_pull ( skb , copied ) ; if ( skb -> len ) { skb_queue_head ( & sk -> sk_receive_queue , skb ) ; goto done ; } } kfree_skb ( skb ) ; if ( iucv -> transport == AF_IUCV_TRANS_HIPER ) { atomic_inc ( & iucv -> msg_recv ) ; if ( atomic_read ( & iucv -> msg_recv ) > iucv -> msglimit ) { WARN_ON ( 1 ) ; iucv_sock_close ( sk ) ; return - EFAULT ; } } spin_lock_bh ( & iucv -> message_q . lock ) ; rskb = skb_dequeue ( & iucv -> backlog_skb_q ) ; while ( rskb ) { if ( sock_queue_rcv_skb ( sk , rskb ) ) { skb_queue_head ( & iucv -> backlog_skb_q , rskb ) ; break ; } else { rskb = skb_dequeue ( & iucv -> backlog_skb_q ) ; } } if ( skb_queue_empty ( & iucv -> backlog_skb_q ) ) { if ( ! list_empty ( & iucv -> message_q . list ) ) iucv_process_message_q ( sk ) ; if ( atomic_read ( & iucv -> msg_recv ) >= iucv -> msglimit / 2 ) { err = iucv_send_ctrl ( sk , AF_IUCV_FLAG_WIN ) ; if ( err ) { sk -> sk_state = IUCV_DISCONN ; sk -> sk_state_change ( sk ) ; } } } spin_unlock_bh ( & iucv -> message_q . lock ) ; } done : if ( sk -> sk_type == SOCK_SEQPACKET && ( flags & MSG_TRUNC ) ) copied = rlen ; return copied ; }\n","target":"<S2SV_ModStart> ; int err = 0 ; msg -> msg_namelen\n","project_and_commit_id":"torvalds@linux/a5598bd9c087dc0efc250a5221e5d0e6f584ee88","cve_id":"CVE-2013-3229","original_address":"https://github.com/torvalds/linux/commit/a5598bd9c087dc0efc250a5221e5d0e6f584ee88","time":"2013-04-22T11:41Z"},
	{"Unnamed: 0":4199,"cwe_id":"CWE-20","source":"CWE-20 int ssl3_write_bytes ( SSL * s , int type , const void * buf_ , int len ) { const unsigned char * buf = buf_ ; int tot ; unsigned int n , split_send_fragment , maxpipes ; # if ! defined ( OPENSSL_NO_MULTIBLOCK ) && EVP_CIPH_FLAG_TLS1_1_MULTIBLOCK unsigned int max_send_fragment , nw ; unsigned int u_len = ( unsigned int ) len ; # endif SSL3_BUFFER * wb = & s -> rlayer . wbuf [ 0 ] ; int i ; if ( len < 0 ) { SSLerr ( SSL_F_SSL3_WRITE_BYTES , SSL_R_SSL_NEGATIVE_LENGTH ) ; return - 1 ; } s -> rwstate = SSL_NOTHING ; tot = s -> rlayer . wnum ; if ( ( unsigned int ) len < s -> rlayer . wnum ) { SSLerr ( SSL_F_SSL3_WRITE_BYTES , SSL_R_BAD_LENGTH ) ; return - 1 ; } s -> rlayer . wnum = 0 ; if ( SSL_in_init ( s ) && ! ossl_statem_get_in_handshake ( s ) ) { i = s -> handshake_func ( s ) ; if ( i < 0 ) return ( i ) ; if ( i == 0 ) { SSLerr ( SSL_F_SSL3_WRITE_BYTES , SSL_R_SSL_HANDSHAKE_FAILURE ) ; return - 1 ; } } if ( wb -> left != 0 ) { i = ssl3_write_pending ( s , type , & buf [ tot ] , s -> rlayer . wpend_tot ) ; if ( i <= 0 ) { s -> rlayer . wnum = tot ; return i ; } tot += i ; } # if ! defined ( OPENSSL_NO_MULTIBLOCK ) && EVP_CIPH_FLAG_TLS1_1_MULTIBLOCK if ( type == SSL3_RT_APPLICATION_DATA && u_len >= 4 * ( max_send_fragment = s -> max_send_fragment ) && s -> compress == NULL && s -> msg_callback == NULL && <S2SV_StartBug> ! SSL_USE_ETM ( s ) && SSL_USE_EXPLICIT_IV ( s ) && <S2SV_EndBug> EVP_CIPHER_flags ( EVP_CIPHER_CTX_cipher ( s -> enc_write_ctx ) ) & EVP_CIPH_FLAG_TLS1_1_MULTIBLOCK ) { unsigned char aad [ 13 ] ; EVP_CTRL_TLS1_1_MULTIBLOCK_PARAM mb_param ; int packlen ; if ( ( max_send_fragment & 0xfff ) == 0 ) max_send_fragment -= 512 ; if ( tot == 0 || wb -> buf == NULL ) { ssl3_release_write_buffer ( s ) ; packlen = EVP_CIPHER_CTX_ctrl ( s -> enc_write_ctx , EVP_CTRL_TLS1_1_MULTIBLOCK_MAX_BUFSIZE , max_send_fragment , NULL ) ; if ( u_len >= 8 * max_send_fragment ) packlen *= 8 ; else packlen *= 4 ; if ( ! ssl3_setup_write_buffer ( s , 1 , packlen ) ) { SSLerr ( SSL_F_SSL3_WRITE_BYTES , ERR_R_MALLOC_FAILURE ) ; return - 1 ; } } else if ( tot == len ) { ssl3_release_write_buffer ( s ) ; return tot ; } n = ( len - tot ) ; for ( ; ; ) { if ( n < 4 * max_send_fragment ) { ssl3_release_write_buffer ( s ) ; break ; } if ( s -> s3 -> alert_dispatch ) { i = s -> method -> ssl_dispatch_alert ( s ) ; if ( i <= 0 ) { s -> rlayer . wnum = tot ; return i ; } } if ( n >= 8 * max_send_fragment ) nw = max_send_fragment * ( mb_param . interleave = 8 ) ; else nw = max_send_fragment * ( mb_param . interleave = 4 ) ; memcpy ( aad , s -> rlayer . write_sequence , 8 ) ; aad [ 8 ] = type ; aad [ 9 ] = ( unsigned char ) ( s -> version >> 8 ) ; aad [ 10 ] = ( unsigned char ) ( s -> version ) ; aad [ 11 ] = 0 ; aad [ 12 ] = 0 ; mb_param . out = NULL ; mb_param . inp = aad ; mb_param . len = nw ; packlen = EVP_CIPHER_CTX_ctrl ( s -> enc_write_ctx , EVP_CTRL_TLS1_1_MULTIBLOCK_AAD , sizeof ( mb_param ) , & mb_param ) ; if ( packlen <= 0 || packlen > ( int ) wb -> len ) { ssl3_release_write_buffer ( s ) ; break ; } mb_param . out = wb -> buf ; mb_param . inp = & buf [ tot ] ; mb_param . len = nw ; if ( EVP_CIPHER_CTX_ctrl ( s -> enc_write_ctx , EVP_CTRL_TLS1_1_MULTIBLOCK_ENCRYPT , sizeof ( mb_param ) , & mb_param ) <= 0 ) return - 1 ; s -> rlayer . write_sequence [ 7 ] += mb_param . interleave ; if ( s -> rlayer . write_sequence [ 7 ] < mb_param . interleave ) { int j = 6 ; while ( j >= 0 && ( ++ s -> rlayer . write_sequence [ j -- ] ) == 0 ) ; } wb -> offset = 0 ; wb -> left = packlen ; s -> rlayer . wpend_tot = nw ; s -> rlayer . wpend_buf = & buf [ tot ] ; s -> rlayer . wpend_type = type ; s -> rlayer . wpend_ret = nw ; i = ssl3_write_pending ( s , type , & buf [ tot ] , nw ) ; if ( i <= 0 ) { if ( i < 0 && ( ! s -> wbio || ! BIO_should_retry ( s -> wbio ) ) ) { ssl3_release_write_buffer ( s ) ; } s -> rlayer . wnum = tot ; return i ; } if ( i == ( int ) n ) { ssl3_release_write_buffer ( s ) ; return tot + i ; } n -= i ; tot += i ; } } else # endif if ( tot == len ) { if ( s -> mode & SSL_MODE_RELEASE_BUFFERS && ! SSL_IS_DTLS ( s ) ) ssl3_release_write_buffer ( s ) ; return tot ; } n = ( len - tot ) ; split_send_fragment = s -> split_send_fragment ; maxpipes = s -> max_pipelines ; if ( maxpipes > SSL_MAX_PIPELINES ) { SSLerr ( SSL_F_SSL3_WRITE_BYTES , ERR_R_INTERNAL_ERROR ) ; return - 1 ; } if ( maxpipes == 0 || s -> enc_write_ctx == NULL || ! ( EVP_CIPHER_flags ( EVP_CIPHER_CTX_cipher ( s -> enc_write_ctx ) ) & EVP_CIPH_FLAG_PIPELINE ) || ! SSL_USE_EXPLICIT_IV ( s ) ) maxpipes = 1 ; if ( s -> max_send_fragment == 0 || split_send_fragment > s -> max_send_fragment || split_send_fragment == 0 ) { SSLerr ( SSL_F_SSL3_WRITE_BYTES , ERR_R_INTERNAL_ERROR ) ; return - 1 ; } for ( ; ; ) { unsigned int pipelens [ SSL_MAX_PIPELINES ] , tmppipelen , remain ; unsigned int numpipes , j ; if ( n == 0 ) numpipes = 1 ; else numpipes = ( ( n - 1 ) / split_send_fragment ) + 1 ; if ( numpipes > maxpipes ) numpipes = maxpipes ; if ( n / numpipes >= s -> max_send_fragment ) { for ( j = 0 ; j < numpipes ; j ++ ) { pipelens [ j ] = s -> max_send_fragment ; } } else { tmppipelen = n / numpipes ; remain = n % numpipes ; for ( j = 0 ; j < numpipes ; j ++ ) { pipelens [ j ] = tmppipelen ; if ( j < remain ) pipelens [ j ] ++ ; } } i = do_ssl3_write ( s , type , & ( buf [ tot ] ) , pipelens , numpipes , 0 ) ; if ( i <= 0 ) { s -> rlayer . wnum = tot ; return i ; } if ( ( i == ( int ) n ) || ( type == SSL3_RT_APPLICATION_DATA && ( s -> mode & SSL_MODE_ENABLE_PARTIAL_WRITE ) ) ) { s -> s3 -> empty_fragment_done = 0 ; if ( ( i == ( int ) n ) && s -> mode & SSL_MODE_RELEASE_BUFFERS && ! SSL_IS_DTLS ( s ) ) ssl3_release_write_buffer ( s ) ; return tot + i ; } n -= i ; tot += i ; } }\n","target":"<S2SV_ModStart> NULL && ! SSL_WRITE_ETM <S2SV_ModEnd> ( s )\n","project_and_commit_id":"openssl@openssl/4ad93618d26a3ea23d36ad5498ff4f59eff3a4d2","cve_id":"CVE-2017-3733","original_address":"https://github.com/openssl/openssl/commit/4ad93618d26a3ea23d36ad5498ff4f59eff3a4d2","time":"2017-05-04T19:29Z"},
	{"Unnamed: 0":4575,"cwe_id":"CWE-125","source":"CWE-125 static void esis_print ( netdissect_options * ndo , const uint8_t * pptr , u_int length ) { const uint8_t * optr ; u_int li , esis_pdu_type , source_address_length , source_address_number ; const struct esis_header_t * esis_header ; if ( ! ndo -> ndo_eflag ) ND_PRINT ( ( ndo , \"ES-IS\" ) ) ; if ( length <= 2 ) { ND_PRINT ( ( ndo , ndo -> ndo_qflag ? \"bad<S2SV_blank>pkt!\" : \"no<S2SV_blank>header<S2SV_blank>at<S2SV_blank>all!\" ) ) ; return ; } esis_header = ( const struct esis_header_t * ) pptr ; ND_TCHECK ( * esis_header ) ; li = esis_header -> length_indicator ; optr = pptr ; if ( esis_header -> nlpid != NLPID_ESIS ) { ND_PRINT ( ( ndo , \"<S2SV_blank>nlpid<S2SV_blank>0x%02x<S2SV_blank>packet<S2SV_blank>not<S2SV_blank>supported\" , esis_header -> nlpid ) ) ; return ; } if ( esis_header -> version != ESIS_VERSION ) { ND_PRINT ( ( ndo , \"<S2SV_blank>version<S2SV_blank>%d<S2SV_blank>packet<S2SV_blank>not<S2SV_blank>supported\" , esis_header -> version ) ) ; return ; } if ( li > length ) { ND_PRINT ( ( ndo , \"<S2SV_blank>length<S2SV_blank>indicator(%u)<S2SV_blank>><S2SV_blank>PDU<S2SV_blank>size<S2SV_blank>(%u)!\" , li , length ) ) ; return ; } if ( li < sizeof ( struct esis_header_t ) + 2 ) { ND_PRINT ( ( ndo , \"<S2SV_blank>length<S2SV_blank>indicator<S2SV_blank>%u<S2SV_blank><<S2SV_blank>min<S2SV_blank>PDU<S2SV_blank>size:\" , li ) ) ; while ( pptr < ndo -> ndo_snapend ) ND_PRINT ( ( ndo , \"%02X\" , * pptr ++ ) ) ; return ; } esis_pdu_type = esis_header -> type & ESIS_PDU_TYPE_MASK ; if ( ndo -> ndo_vflag < 1 ) { ND_PRINT ( ( ndo , \"%s%s,<S2SV_blank>length<S2SV_blank>%u\" , ndo -> ndo_eflag ? \"\" : \",<S2SV_blank>\" , tok2str ( esis_pdu_values , \"unknown<S2SV_blank>type<S2SV_blank>(%u)\" , esis_pdu_type ) , length ) ) ; return ; } else ND_PRINT ( ( ndo , \"%slength<S2SV_blank>%u\\\\n\\\\t%s<S2SV_blank>(%u)\" , ndo -> ndo_eflag ? \"\" : \",<S2SV_blank>\" , length , tok2str ( esis_pdu_values , \"unknown<S2SV_blank>type:<S2SV_blank>%u\" , esis_pdu_type ) , esis_pdu_type ) ) ; ND_PRINT ( ( ndo , \",<S2SV_blank>v:<S2SV_blank>%u%s\" , esis_header -> version , esis_header -> version == ESIS_VERSION ? \"\" : \"unsupported\" ) ) ; ND_PRINT ( ( ndo , \",<S2SV_blank>checksum:<S2SV_blank>0x%04x\" , EXTRACT_16BITS ( esis_header -> cksum ) ) ) ; osi_print_cksum ( ndo , pptr , EXTRACT_16BITS ( esis_header -> cksum ) , 7 , li ) ; ND_PRINT ( ( ndo , \",<S2SV_blank>holding<S2SV_blank>time:<S2SV_blank>%us,<S2SV_blank>length<S2SV_blank>indicator:<S2SV_blank>%u\" , EXTRACT_16BITS ( esis_header -> holdtime ) , li ) ) ; if ( ndo -> ndo_vflag > 1 ) print_unknown_data ( ndo , optr , \"\\\\n\\\\t\" , sizeof ( struct esis_header_t ) ) ; pptr += sizeof ( struct esis_header_t ) ; li -= sizeof ( struct esis_header_t ) ; switch ( esis_pdu_type ) { case ESIS_PDU_REDIRECT : { const uint8_t * dst , * snpa , * neta ; u_int dstl , snpal , netal ; ND_TCHECK ( * pptr ) ; if ( li < 1 ) { ND_PRINT ( ( ndo , \",<S2SV_blank>bad<S2SV_blank>redirect/li\" ) ) ; return ; } dstl = * pptr ; pptr ++ ; li -- ; ND_TCHECK2 ( * pptr , dstl ) ; if ( li < dstl ) { ND_PRINT ( ( ndo , \",<S2SV_blank>bad<S2SV_blank>redirect/li\" ) ) ; return ; } dst = pptr ; pptr += dstl ; li -= dstl ; ND_PRINT ( ( ndo , \"\\\\n\\\\t<S2SV_blank><S2SV_blank>%s\" , isonsap_string ( ndo , dst , dstl ) ) ) ; ND_TCHECK ( * pptr ) ; if ( li < 1 ) { ND_PRINT ( ( ndo , \",<S2SV_blank>bad<S2SV_blank>redirect/li\" ) ) ; return ; } snpal = * pptr ; pptr ++ ; li -- ; ND_TCHECK2 ( * pptr , snpal ) ; if ( li < snpal ) { ND_PRINT ( ( ndo , \",<S2SV_blank>bad<S2SV_blank>redirect/li\" ) ) ; return ; } snpa = pptr ; pptr += snpal ; li -= snpal ; ND_TCHECK ( * pptr ) ; if ( li < 1 ) { ND_PRINT ( ( ndo , \",<S2SV_blank>bad<S2SV_blank>redirect/li\" ) ) ; return ; } netal = * pptr ; pptr ++ ; ND_TCHECK2 ( * pptr , netal ) ; if ( li < netal ) { ND_PRINT ( ( ndo , \",<S2SV_blank>bad<S2SV_blank>redirect/li\" ) ) ; return ; } neta = pptr ; pptr += netal ; li -= netal ; if ( snpal == 6 ) ND_PRINT ( ( ndo , \"\\\\n\\\\t<S2SV_blank><S2SV_blank>SNPA<S2SV_blank>(length:<S2SV_blank>%u):<S2SV_blank>%s\" , snpal , etheraddr_string ( ndo , snpa ) ) ) ; else ND_PRINT ( ( ndo , \"\\\\n\\\\t<S2SV_blank><S2SV_blank>SNPA<S2SV_blank>(length:<S2SV_blank>%u):<S2SV_blank>%s\" , snpal , linkaddr_string ( ndo , snpa , LINKADDR_OTHER , snpal ) ) ) ; if ( netal != 0 ) ND_PRINT ( ( ndo , \"\\\\n\\\\t<S2SV_blank><S2SV_blank>NET<S2SV_blank>(length:<S2SV_blank>%u)<S2SV_blank>%s\" , netal , isonsap_string ( ndo , neta , netal ) ) ) ; break ; } case ESIS_PDU_ESH : ND_TCHECK ( * pptr ) ; if ( li < 1 ) { ND_PRINT ( ( ndo , \",<S2SV_blank>bad<S2SV_blank>esh/li\" ) ) ; return ; } source_address_number = * pptr ; pptr ++ ; li -- ; ND_PRINT ( ( ndo , \"\\\\n\\\\t<S2SV_blank><S2SV_blank>Number<S2SV_blank>of<S2SV_blank>Source<S2SV_blank>Addresses:<S2SV_blank>%u\" , source_address_number ) ) ; while ( source_address_number > 0 ) { ND_TCHECK ( * pptr ) ; if ( li < 1 ) { ND_PRINT ( ( ndo , \",<S2SV_blank>bad<S2SV_blank>esh/li\" ) ) ; return ; } source_address_length = * pptr ; pptr ++ ; li -- ; ND_TCHECK2 ( * pptr , source_address_length ) ; if ( li < source_address_length ) { ND_PRINT ( ( ndo , \",<S2SV_blank>bad<S2SV_blank>esh/li\" ) ) ; return ; } ND_PRINT ( ( ndo , \"\\\\n\\\\t<S2SV_blank><S2SV_blank>NET<S2SV_blank>(length:<S2SV_blank>%u):<S2SV_blank>%s\" , source_address_length , isonsap_string ( ndo , pptr , source_address_length ) ) ) ; pptr += source_address_length ; li -= source_address_length ; source_address_number -- ; } break ; case ESIS_PDU_ISH : { ND_TCHECK ( * pptr ) ; if ( li < 1 ) { ND_PRINT ( ( ndo , \",<S2SV_blank>bad<S2SV_blank>ish/li\" ) ) ; return ; } source_address_length = * pptr ; pptr ++ ; li -- ; ND_TCHECK2 ( * pptr , source_address_length ) ; if ( li < source_address_length ) { ND_PRINT ( ( ndo , \",<S2SV_blank>bad<S2SV_blank>ish/li\" ) ) ; return ; } ND_PRINT ( ( ndo , \"\\\\n\\\\t<S2SV_blank><S2SV_blank>NET<S2SV_blank>(length:<S2SV_blank>%u):<S2SV_blank>%s\" , source_address_length , isonsap_string ( ndo , pptr , source_address_length ) ) ) ; pptr += source_address_length ; li -= source_address_length ; break ; } default : if ( ndo -> ndo_vflag <= 1 ) { if ( pptr < ndo -> ndo_snapend ) print_unknown_data ( ndo , pptr , \"\\\\n\\\\t<S2SV_blank><S2SV_blank>\" , ndo -> ndo_snapend - pptr ) ; } return ; } while ( li != 0 ) { u_int op , opli ; const uint8_t * tptr ; if ( li < 2 ) { ND_PRINT ( ( ndo , \",<S2SV_blank>bad<S2SV_blank>opts/li\" ) ) ; return ; } ND_TCHECK2 ( * pptr , 2 ) ; op = * pptr ++ ; opli = * pptr ++ ; li -= 2 ; if ( opli > li ) { ND_PRINT ( ( ndo , \",<S2SV_blank>opt<S2SV_blank>(%d)<S2SV_blank>too<S2SV_blank>long\" , op ) ) ; return ; } li -= opli ; tptr = pptr ; ND_PRINT ( ( ndo , \"\\\\n\\\\t<S2SV_blank><S2SV_blank>%s<S2SV_blank>Option<S2SV_blank>#%u,<S2SV_blank>length<S2SV_blank>%u,<S2SV_blank>value:<S2SV_blank>\" , tok2str ( esis_option_values , \"Unknown\" , op ) , op , opli ) ) ; switch ( op ) { case ESIS_OPTION_ES_CONF_TIME : if ( opli == 2 ) { ND_TCHECK2 ( * pptr , 2 ) ; ND_PRINT ( ( ndo , \"%us\" , EXTRACT_16BITS ( tptr ) ) ) ; } else ND_PRINT ( ( ndo , \"(bad<S2SV_blank>length)\" ) ) ; break ; case ESIS_OPTION_PROTOCOLS : while ( opli > 0 ) { <S2SV_StartBug> ND_TCHECK ( * pptr ) ; <S2SV_EndBug> ND_PRINT ( ( ndo , \"%s<S2SV_blank>(0x%02x)\" , tok2str ( nlpid_values , \"unknown\" , * tptr ) , * tptr ) ) ; if ( opli > 1 ) ND_PRINT ( ( ndo , \",<S2SV_blank>\" ) ) ; tptr ++ ; opli -- ; } break ; case ESIS_OPTION_QOS_MAINTENANCE : case ESIS_OPTION_SECURITY : case ESIS_OPTION_PRIORITY : case ESIS_OPTION_ADDRESS_MASK : case ESIS_OPTION_SNPA_MASK : default : print_unknown_data ( ndo , tptr , \"\\\\n\\\\t<S2SV_blank><S2SV_blank>\" , opli ) ; break ; } if ( ndo -> ndo_vflag > 1 ) print_unknown_data ( ndo , pptr , \"\\\\n\\\\t<S2SV_blank><S2SV_blank>\" , opli ) ; pptr += opli ; } trunc : <S2SV_StartBug> return ; <S2SV_EndBug> }\n","target":"<S2SV_ModStart> ND_TCHECK ( * tptr <S2SV_ModEnd> ) ; ND_PRINT <S2SV_ModStart> } trunc : ND_PRINT ( ( ndo , \"[|esis]\" ) ) <S2SV_ModEnd> ; } <S2SV_null>\n","project_and_commit_id":"the-tcpdump-group@tcpdump/331530a4076c69bbd2e3214db6ccbe834fb75640","cve_id":"CVE-2017-13047","original_address":"https://github.com/the-tcpdump-group/tcpdump/commit/331530a4076c69bbd2e3214db6ccbe834fb75640","time":"2017-09-14T06:29Z"},
	{"Unnamed: 0":1882,"cwe_id":"CWE-119","source":"CWE-119 static void command_port_read_callback ( struct urb * urb ) { struct usb_serial_port * command_port = urb -> context ; struct whiteheat_command_private * command_info ; int status = urb -> status ; unsigned char * data = urb -> transfer_buffer ; int result ; command_info = usb_get_serial_port_data ( command_port ) ; if ( ! command_info ) { dev_dbg ( & urb -> dev -> dev , \"%s<S2SV_blank>-<S2SV_blank>command_info<S2SV_blank>is<S2SV_blank>NULL,<S2SV_blank>exiting.\\\\n\" , __func__ ) ; return ; } <S2SV_StartBug> if ( status ) { <S2SV_EndBug> dev_dbg ( & urb -> dev -> dev , \"%s<S2SV_blank>-<S2SV_blank>nonzero<S2SV_blank>urb<S2SV_blank>status:<S2SV_blank>%d\\\\n\" , __func__ , status ) ; if ( status != - ENOENT ) command_info -> command_finished = WHITEHEAT_CMD_FAILURE ; wake_up ( & command_info -> wait_command ) ; return ; } usb_serial_debug_data ( & command_port -> dev , __func__ , urb -> actual_length , data ) ; if ( data [ 0 ] == WHITEHEAT_CMD_COMPLETE ) { command_info -> command_finished = WHITEHEAT_CMD_COMPLETE ; wake_up ( & command_info -> wait_command ) ; } else if ( data [ 0 ] == WHITEHEAT_CMD_FAILURE ) { command_info -> command_finished = WHITEHEAT_CMD_FAILURE ; wake_up ( & command_info -> wait_command ) ; } else if ( data [ 0 ] == WHITEHEAT_EVENT ) { dev_dbg ( & urb -> dev -> dev , \"%s<S2SV_blank>-<S2SV_blank>event<S2SV_blank>received\\\\n\" , __func__ ) ; <S2SV_StartBug> } else if ( data [ 0 ] == WHITEHEAT_GET_DTR_RTS ) { <S2SV_EndBug> memcpy ( command_info -> result_buffer , & data [ 1 ] , <S2SV_StartBug> urb -> actual_length - 1 ) ; <S2SV_EndBug> command_info -> command_finished = WHITEHEAT_CMD_COMPLETE ; wake_up ( & command_info -> wait_command ) ; } else dev_dbg ( & urb -> dev -> dev , \"%s<S2SV_blank>-<S2SV_blank>bad<S2SV_blank>reply<S2SV_blank>from<S2SV_blank>firmware\\\\n\" , __func__ ) ; result = usb_submit_urb ( command_port -> read_urb , GFP_ATOMIC ) ; if ( result ) dev_dbg ( & urb -> dev -> dev , \"%s<S2SV_blank>-<S2SV_blank>failed<S2SV_blank>resubmitting<S2SV_blank>read<S2SV_blank>urb,<S2SV_blank>error<S2SV_blank>%d\\\\n\" , __func__ , result ) ; }\n","target":"<S2SV_ModStart> } if ( ! urb -> actual_length ) { dev_dbg ( & urb -> dev -> dev , \"%s<S2SV_blank>-<S2SV_blank>empty<S2SV_blank>response,<S2SV_blank>exiting.\\\\n\" , __func__ ) ; return ; } if ( <S2SV_ModStart> else if ( ( <S2SV_ModStart> == WHITEHEAT_GET_DTR_RTS ) && ( <S2SV_ModEnd> urb -> actual_length <S2SV_ModStart> actual_length - 1 <= sizeof ( command_info -> result_buffer ) ) ) { memcpy ( command_info -> result_buffer , & data [ 1 ] , urb -> actual_length - 1\n","project_and_commit_id":"torvalds@linux/6817ae225cd650fb1c3295d769298c38b1eba818","cve_id":"CVE-2014-3185","original_address":"https://github.com/torvalds/linux/commit/6817ae225cd650fb1c3295d769298c38b1eba818","time":"2014-09-28T10:55Z"},
	{"Unnamed: 0":816,"cwe_id":"CWE-119","source":"CWE-119 <S2SV_StartBug> static void get_sb_partition_size_range ( VP9_COMP * cpi , MODE_INFO * * mi_8x8 , <S2SV_EndBug> BLOCK_SIZE * min_block_size , <S2SV_StartBug> BLOCK_SIZE * max_block_size ) { <S2SV_EndBug> MACROBLOCKD * const xd = & cpi -> mb . e_mbd ; int sb_width_in_blocks = MI_BLOCK_SIZE ; int sb_height_in_blocks = MI_BLOCK_SIZE ; int i , j ; int index = 0 ; for ( i = 0 ; i < sb_height_in_blocks ; ++ i ) { for ( j = 0 ; j < sb_width_in_blocks ; ++ j ) { MODE_INFO * mi = mi_8x8 [ index + j ] ; BLOCK_SIZE sb_type = mi ? mi -> mbmi . sb_type : 0 ; <S2SV_StartBug> * min_block_size = MIN ( * min_block_size , sb_type ) ; <S2SV_EndBug> * max_block_size = MAX ( * max_block_size , sb_type ) ; } index += xd -> mi_stride ; } }\n","target":"<S2SV_ModStart> void get_sb_partition_size_range ( MACROBLOCKD * xd <S2SV_ModEnd> , MODE_INFO * <S2SV_ModStart> BLOCK_SIZE * max_block_size , int bs_hist [ BLOCK_SIZES ] ) { <S2SV_ModEnd> int sb_width_in_blocks = <S2SV_ModStart> : 0 ; bs_hist [ sb_type ] ++ ;\n","project_and_commit_id":"external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426","cve_id":"CVE-2016-1621","original_address":"https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426","time":"2016-03-12T21:59Z"},
	{"Unnamed: 0":499,"cwe_id":"CWE-000","source":"CWE-000 static int userfaultfd_unregister ( struct userfaultfd_ctx * ctx , unsigned long arg ) { struct mm_struct * mm = ctx -> mm ; struct vm_area_struct * vma , * prev , * cur ; int ret ; struct uffdio_range uffdio_unregister ; unsigned long new_flags ; bool found ; unsigned long start , end , vma_end ; const void __user * buf = ( void __user * ) arg ; ret = - EFAULT ; if ( copy_from_user ( & uffdio_unregister , buf , sizeof ( uffdio_unregister ) ) ) goto out ; ret = validate_range ( mm , uffdio_unregister . start , uffdio_unregister . len ) ; if ( ret ) goto out ; start = uffdio_unregister . start ; end = start + uffdio_unregister . len ; ret = - ENOMEM ; if ( ! mmget_not_zero ( mm ) ) goto out ; down_write ( & mm -> mmap_sem ) ; vma = find_vma_prev ( mm , start , & prev ) ; if ( ! vma ) goto out_unlock ; ret = - EINVAL ; if ( vma -> vm_start >= end ) goto out_unlock ; if ( is_vm_hugetlb_page ( vma ) ) { unsigned long vma_hpagesize = vma_kernel_pagesize ( vma ) ; if ( start & ( vma_hpagesize - 1 ) ) goto out_unlock ; } found = false ; ret = - EINVAL ; for ( cur = vma ; cur && cur -> vm_start < end ; cur = cur -> vm_next ) { cond_resched ( ) ; BUG_ON ( ! ! cur -> vm_userfaultfd_ctx . ctx ^ ! ! ( cur -> vm_flags & ( VM_UFFD_MISSING | VM_UFFD_WP ) ) ) ; if ( ! vma_can_userfault ( cur ) ) goto out_unlock ; found = true ; } BUG_ON ( ! found ) ; if ( vma -> vm_start < start ) prev = vma ; ret = 0 ; do { cond_resched ( ) ; BUG_ON ( ! vma_can_userfault ( vma ) ) ; <S2SV_StartBug> if ( ! vma -> vm_userfaultfd_ctx . ctx ) <S2SV_EndBug> goto skip ; if ( vma -> vm_start > start ) start = vma -> vm_start ; vma_end = min ( end , vma -> vm_end ) ; if ( userfaultfd_missing ( vma ) ) { struct userfaultfd_wake_range range ; range . start = start ; range . len = vma_end - start ; wake_userfault ( vma -> vm_userfaultfd_ctx . ctx , & range ) ; } new_flags = vma -> vm_flags & ~ ( VM_UFFD_MISSING | VM_UFFD_WP ) ; prev = vma_merge ( mm , prev , start , vma_end , new_flags , vma -> anon_vma , vma -> vm_file , vma -> vm_pgoff , vma_policy ( vma ) , NULL_VM_UFFD_CTX ) ; if ( prev ) { vma = prev ; goto next ; } if ( vma -> vm_start < start ) { ret = split_vma ( mm , vma , start , 1 ) ; if ( ret ) break ; } if ( vma -> vm_end > end ) { ret = split_vma ( mm , vma , end , 0 ) ; if ( ret ) break ; } next : vma -> vm_flags = new_flags ; vma -> vm_userfaultfd_ctx = NULL_VM_UFFD_CTX ; skip : prev = vma ; start = vma -> vm_end ; vma = vma -> vm_next ; } while ( vma && vma -> vm_start < end ) ; out_unlock : up_write ( & mm -> mmap_sem ) ; mmput ( mm ) ; out : return ret ; }\n","target":"<S2SV_ModStart> ) ) ; WARN_ON ( ! ( vma -> vm_flags & VM_MAYWRITE ) ) ;\n","project_and_commit_id":"torvalds@linux/29ec90660d68bbdd69507c1c8b4e33aa299278b1","cve_id":"CVE-2018-18397","original_address":"https://github.com/torvalds/linux/commit/29ec90660d68bbdd69507c1c8b4e33aa299278b1","time":"2018-12-12T10:29Z"},
	{"Unnamed: 0":789,"cwe_id":"CWE-119","source":"CWE-119 static int do_16x16_zerozero_search ( VP9_COMP * cpi , int_mv * dst_mv ) { <S2SV_StartBug> MACROBLOCK * const x = & cpi -> mb ; <S2SV_EndBug> MACROBLOCKD * const xd = & x -> e_mbd ; unsigned int err ; <S2SV_StartBug> err = vp9_sad16x16 ( x -> plane [ 0 ] . src . buf , x -> plane [ 0 ] . src . stride , <S2SV_EndBug> <S2SV_StartBug> xd -> plane [ 0 ] . pre [ 0 ] . buf , xd -> plane [ 0 ] . pre [ 0 ] . stride , <S2SV_EndBug> INT_MAX ) ; dst_mv -> as_int = 0 ; return err ; }\n","target":"<S2SV_ModStart> & cpi -> td . <S2SV_ModStart> ; err = vpx_sad16x16 <S2SV_ModEnd> ( x -> <S2SV_ModStart> ] . stride <S2SV_ModEnd> ) ; dst_mv\n","project_and_commit_id":"external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426","cve_id":"CVE-2016-1621","original_address":"https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426","time":"2016-03-12T21:59Z"},
	{"Unnamed: 0":5984,"cwe_id":"CWE-20","source":"CWE-20 error_t enc28j60Init ( NetInterface * interface ) { uint8_t revisionId ; Enc28j60Context * context ; TRACE_INFO ( \"Initializing<S2SV_blank>ENC28J60<S2SV_blank>Ethernet<S2SV_blank>controller...\\\\r\\\\n\" ) ; interface -> spiDriver -> init ( ) ; interface -> extIntDriver -> init ( ) ; enc28j60SoftReset ( interface ) ; sleep ( 10 ) ; context = ( Enc28j60Context * ) interface -> nicContext ; context -> currentBank = UINT16_MAX ; context -> nextPacket = ENC28J60_RX_BUFFER_START ; context -> rxBuffer = memPoolAlloc ( ETH_MAX_FRAME_SIZE ) ; if ( context -> rxBuffer == NULL ) { return ERROR_OUT_OF_MEMORY ; } <S2SV_StartBug> revisionId = enc28j60ReadReg ( interface , ENC28J60_REG_EREVID ) ; <S2SV_EndBug> TRACE_INFO ( \"ENC28J60<S2SV_blank>revision<S2SV_blank>ID:<S2SV_blank>0x%02X\\\\r\\\\n\" , revisionId ) ; <S2SV_StartBug> enc28j60WriteReg ( interface , ENC28J60_REG_ECOCON , 0x00 ) ; <S2SV_EndBug> enc28j60WriteReg ( interface , ENC28J60_REG_MAADR1 , interface -> macAddr . b [ 0 ] ) ; <S2SV_StartBug> enc28j60WriteReg ( interface , ENC28J60_REG_MAADR2 , interface -> macAddr . b [ 1 ] ) ; <S2SV_EndBug> <S2SV_StartBug> enc28j60WriteReg ( interface , ENC28J60_REG_MAADR3 , interface -> macAddr . b [ 2 ] ) ; <S2SV_EndBug> <S2SV_StartBug> enc28j60WriteReg ( interface , ENC28J60_REG_MAADR4 , interface -> macAddr . b [ 3 ] ) ; <S2SV_EndBug> <S2SV_StartBug> enc28j60WriteReg ( interface , ENC28J60_REG_MAADR5 , interface -> macAddr . b [ 4 ] ) ; <S2SV_EndBug> <S2SV_StartBug> enc28j60WriteReg ( interface , ENC28J60_REG_MAADR6 , interface -> macAddr . b [ 5 ] ) ; <S2SV_EndBug> <S2SV_StartBug> enc28j60WriteReg ( interface , ENC28J60_REG_ERXSTL , LSB ( ENC28J60_RX_BUFFER_START ) ) ; <S2SV_EndBug> <S2SV_StartBug> enc28j60WriteReg ( interface , ENC28J60_REG_ERXSTH , MSB ( ENC28J60_RX_BUFFER_START ) ) ; <S2SV_EndBug> <S2SV_StartBug> enc28j60WriteReg ( interface , ENC28J60_REG_ERXNDL , LSB ( ENC28J60_RX_BUFFER_STOP ) ) ; <S2SV_EndBug> <S2SV_StartBug> enc28j60WriteReg ( interface , ENC28J60_REG_ERXNDH , MSB ( ENC28J60_RX_BUFFER_STOP ) ) ; <S2SV_EndBug> <S2SV_StartBug> enc28j60WriteReg ( interface , ENC28J60_REG_ERXRDPTL , LSB ( ENC28J60_RX_BUFFER_STOP ) ) ; <S2SV_EndBug> <S2SV_StartBug> enc28j60WriteReg ( interface , ENC28J60_REG_ERXRDPTH , MSB ( ENC28J60_RX_BUFFER_STOP ) ) ; <S2SV_EndBug> <S2SV_StartBug> enc28j60WriteReg ( interface , ENC28J60_REG_ERXFCON , ERXFCON_UCEN | <S2SV_EndBug> ERXFCON_CRCEN | ERXFCON_HTEN | ERXFCON_BCEN ) ; enc28j60WriteReg ( interface , ENC28J60_REG_EHT0 , 0x00 ) ; enc28j60WriteReg ( interface , ENC28J60_REG_EHT1 , 0x00 ) ; enc28j60WriteReg ( interface , ENC28J60_REG_EHT2 , 0x00 ) ; enc28j60WriteReg ( interface , ENC28J60_REG_EHT3 , 0x00 ) ; enc28j60WriteReg ( interface , ENC28J60_REG_EHT4 , 0x00 ) ; enc28j60WriteReg ( interface , ENC28J60_REG_EHT5 , 0x00 ) ; enc28j60WriteReg ( interface , ENC28J60_REG_EHT6 , 0x00 ) ; enc28j60WriteReg ( interface , ENC28J60_REG_EHT7 , 0x00 ) ; enc28j60WriteReg ( interface , ENC28J60_REG_MACON2 , 0x00 ) ; enc28j60WriteReg ( interface , ENC28J60_REG_MACON1 , MACON1_TXPAUS | MACON1_RXPAUS | MACON1_MARXEN ) ; # if ( ENC28J60_FULL_DUPLEX_SUPPORT == ENABLED ) <S2SV_StartBug> enc28j60WriteReg ( interface , ENC28J60_REG_MACON3 , MACON3_PADCFG ( 1 ) | <S2SV_EndBug> MACON3_TXCRCEN | MACON3_FRMLNEN | MACON3_FULDPX ) ; # else <S2SV_StartBug> enc28j60WriteReg ( interface , ENC28J60_REG_MACON3 , MACON3_PADCFG ( 1 ) | <S2SV_EndBug> MACON3_TXCRCEN | MACON3_FRMLNEN ) ; # endif <S2SV_StartBug> enc28j60WriteReg ( interface , ENC28J60_REG_MACON4 , MACON4_DEFER ) ; <S2SV_EndBug> enc28j60WriteReg ( interface , ENC28J60_REG_MAMXFLL , LSB ( ETH_MAX_FRAME_SIZE ) ) ; <S2SV_StartBug> enc28j60WriteReg ( interface , ENC28J60_REG_MAMXFLH , MSB ( ETH_MAX_FRAME_SIZE ) ) ; <S2SV_EndBug> # if ( ENC28J60_FULL_DUPLEX_SUPPORT == ENABLED ) <S2SV_StartBug> enc28j60WriteReg ( interface , ENC28J60_REG_MABBIPG , 0x15 ) ; <S2SV_EndBug> # else <S2SV_StartBug> enc28j60WriteReg ( interface , ENC28J60_REG_MABBIPG , 0x12 ) ; <S2SV_EndBug> # endif <S2SV_StartBug> enc28j60WriteReg ( interface , ENC28J60_REG_MAIPGL , 0x12 ) ; <S2SV_EndBug> enc28j60WriteReg ( interface , ENC28J60_REG_MAIPGH , 0x0C ) ; enc28j60WriteReg ( interface , ENC28J60_REG_MACLCON2 , 63 ) ; # if ( ENC28J60_FULL_DUPLEX_SUPPORT == ENABLED ) <S2SV_StartBug> enc28j60WritePhyReg ( interface , ENC28J60_PHY_REG_PHCON1 , PHCON1_PDPXMD ) ; <S2SV_EndBug> # else <S2SV_StartBug> enc28j60WritePhyReg ( interface , ENC28J60_PHY_REG_PHCON1 , 0x0000 ) ; <S2SV_EndBug> # endif <S2SV_StartBug> enc28j60WritePhyReg ( interface , ENC28J60_PHY_REG_PHCON2 , PHCON2_HDLDIS ) ; <S2SV_EndBug> <S2SV_StartBug> enc28j60WritePhyReg ( interface , ENC28J60_PHY_REG_PHLCON , <S2SV_EndBug> PHLCON_LACFG ( 4 ) | PHLCON_LBCFG ( 7 ) | PHLCON_LFRQ ( 0 ) | PHLCON_STRCH ) ; enc28j60WriteReg ( interface , ENC28J60_REG_EIR , 0x00 ) ; enc28j60WriteReg ( interface , ENC28J60_REG_EIE , EIE_INTIE | EIE_PKTIE | EIE_LINKIE | EIE_TXIE | EIE_TXERIE ) ; <S2SV_StartBug> enc28j60WritePhyReg ( interface , ENC28J60_PHY_REG_PHIE , <S2SV_EndBug> PHIE_PLNKIE | PHIE_PGEIE ) ; <S2SV_StartBug> enc28j60SetBit ( interface , ENC28J60_REG_ECON1 , ECON1_RXEN ) ; <S2SV_EndBug> enc28j60DumpReg ( interface ) ; enc28j60DumpPhyReg ( interface ) ; osSetEvent ( & interface -> nicTxEvent ) ; interface -> nicEvent = TRUE ; osSetEvent ( & netEvent ) ; return NO_ERROR ; }\n","target":"<S2SV_ModStart> ( interface , ENC28J60_EREVID <S2SV_ModEnd> ) ; TRACE_INFO <S2SV_ModStart> ( interface , ENC28J60_ECOCON , ENC28J60_ECOCON_COCON_DISABLED ) ; enc28j60WriteReg ( interface , ENC28J60_MAADR5 <S2SV_ModEnd> , interface -> <S2SV_ModStart> ( interface , ENC28J60_MAADR4 <S2SV_ModEnd> , interface -> <S2SV_ModStart> ( interface , ENC28J60_MAADR3 <S2SV_ModEnd> , interface -> <S2SV_ModStart> ( interface , ENC28J60_MAADR2 <S2SV_ModEnd> , interface -> <S2SV_ModStart> ( interface , ENC28J60_MAADR1 <S2SV_ModEnd> , interface -> <S2SV_ModStart> ( interface , ENC28J60_MAADR0 <S2SV_ModEnd> , interface -> <S2SV_ModStart> ( interface , ENC28J60_ERXSTL <S2SV_ModEnd> , LSB ( <S2SV_ModStart> ( interface , ENC28J60_ERXSTH <S2SV_ModEnd> , MSB ( <S2SV_ModStart> ( interface , ENC28J60_ERXNDL <S2SV_ModEnd> , LSB ( <S2SV_ModStart> ( interface , ENC28J60_ERXNDH <S2SV_ModEnd> , MSB ( <S2SV_ModStart> ( interface , ENC28J60_ERXRDPTL <S2SV_ModEnd> , LSB ( <S2SV_ModStart> ( interface , ENC28J60_ERXRDPTH <S2SV_ModEnd> , MSB ( <S2SV_ModStart> ( interface , ENC28J60_ERXFCON , ENC28J60_ERXFCON_UCEN | ENC28J60_ERXFCON_CRCEN | ENC28J60_ERXFCON_HTEN | ENC28J60_ERXFCON_BCEN ) ; enc28j60WriteReg ( interface , ENC28J60_EHT0 , 0x00 ) ; enc28j60WriteReg ( interface , ENC28J60_EHT1 , 0x00 ) ; enc28j60WriteReg ( interface , ENC28J60_EHT2 , 0x00 ) ; enc28j60WriteReg ( interface , ENC28J60_EHT3 , 0x00 ) ; enc28j60WriteReg ( interface , ENC28J60_EHT4 , 0x00 ) ; enc28j60WriteReg ( interface , ENC28J60_EHT5 , 0x00 ) ; enc28j60WriteReg ( interface , ENC28J60_EHT6 , 0x00 ) ; enc28j60WriteReg ( interface , ENC28J60_EHT7 , 0x00 ) ; enc28j60WriteReg ( interface , ENC28J60_MACON2 , 0x00 ) ; enc28j60WriteReg ( interface , ENC28J60_MACON1 , ENC28J60_MACON1_TXPAUS | ENC28J60_MACON1_RXPAUS | ENC28J60_MACON1_MARXEN <S2SV_ModEnd> ) ; # <S2SV_ModStart> ( interface , ENC28J60_MACON3 , ENC28J60_MACON3_PADCFG_AUTO | ENC28J60_MACON3_TXCRCEN | ENC28J60_MACON3_FRMLNEN | ENC28J60_MACON3_FULDPX <S2SV_ModEnd> ) ; # <S2SV_ModStart> ( interface , ENC28J60_MACON3 , ENC28J60_MACON3_PADCFG_AUTO | ENC28J60_MACON3_TXCRCEN | ENC28J60_MACON3_FRMLNEN <S2SV_ModEnd> ) ; # <S2SV_ModStart> ( interface , ENC28J60_MACON4 , ENC28J60_MACON4_DEFER ) ; enc28j60WriteReg ( interface , ENC28J60_MAMXFLL <S2SV_ModEnd> , LSB ( <S2SV_ModStart> ( interface , ENC28J60_MAMXFLH <S2SV_ModEnd> , MSB ( <S2SV_ModStart> ( interface , ENC28J60_MABBIPG , ENC28J60_MABBIPG_DEFAULT_FD <S2SV_ModEnd> ) ; # <S2SV_ModStart> ( interface , ENC28J60_MABBIPG , ENC28J60_MABBIPG_DEFAULT_HD <S2SV_ModEnd> ) ; # <S2SV_ModStart> ( interface , ENC28J60_MAIPGL , ENC28J60_MAIPGL_DEFAULT ) ; enc28j60WriteReg ( interface , ENC28J60_MAIPGH , ENC28J60_MAIPGH_DEFAULT ) ; enc28j60WriteReg ( interface , ENC28J60_MACLCON2 , ENC28J60_MACLCON2_COLWIN_DEFAULT <S2SV_ModEnd> ) ; # <S2SV_ModStart> ( interface , ENC28J60_PHCON1 , ENC28J60_PHCON1_PDPXMD <S2SV_ModEnd> ) ; # <S2SV_ModStart> ( interface , ENC28J60_PHCON1 <S2SV_ModEnd> , 0x0000 ) <S2SV_ModStart> ( interface , ENC28J60_PHCON2 , ENC28J60_PHCON2_HDLDIS <S2SV_ModEnd> ) ; enc28j60WritePhyReg <S2SV_ModStart> ( interface , ENC28J60_PHLCON , ENC28J60_PHLCON_LACFG_LINK | ENC28J60_PHLCON_LBCFG_TX_RX | ENC28J60_PHLCON_LFRQ_40_MS | ENC28J60_PHLCON_STRCH ) ; enc28j60WriteReg ( interface , ENC28J60_EIR , 0x00 ) ; enc28j60WriteReg ( interface , ENC28J60_EIE , ENC28J60_EIE_INTIE | ENC28J60_EIE_PKTIE | ENC28J60_EIE_LINKIE | ENC28J60_EIE_TXIE | ENC28J60_EIE_TXERIE <S2SV_ModEnd> ) ; enc28j60WritePhyReg <S2SV_ModStart> ( interface , ENC28J60_PHIE , ENC28J60_PHIE_PLNKIE | ENC28J60_PHIE_PGEIE <S2SV_ModEnd> ) ; enc28j60SetBit <S2SV_ModStart> ( interface , ENC28J60_ECON1 , ENC28J60_ECON1_RXEN <S2SV_ModEnd> ) ; enc28j60DumpReg\n","project_and_commit_id":"Oryx-Embedded@CycloneTCP/de5336016edbe1e90327d0ed1cba5c4e49114366","cve_id":"CVE-2021-26788","original_address":"https://github.com/Oryx-Embedded/CycloneTCP/commit/de5336016edbe1e90327d0ed1cba5c4e49114366","time":"2021-03-08T13:15Z"},
	{"Unnamed: 0":2951,"cwe_id":"CWE-19","source":"CWE-19 STATIC int xfs_attr_calc_size ( struct xfs_inode * ip , int namelen , int valuelen , int * local ) { struct xfs_mount * mp = ip -> i_mount ; int size ; int nblks ; size = xfs_attr_leaf_newentsize ( namelen , valuelen , mp -> m_sb . sb_blocksize , local ) ; nblks = XFS_DAENTER_SPACE_RES ( mp , XFS_ATTR_FORK ) ; if ( * local ) { if ( size > ( mp -> m_sb . sb_blocksize >> 1 ) ) { nblks *= 2 ; } } else { <S2SV_StartBug> uint dblocks = XFS_B_TO_FSB ( mp , valuelen ) ; <S2SV_EndBug> nblks += dblocks ; nblks += XFS_NEXTENTADD_SPACE_RES ( mp , dblocks , XFS_ATTR_FORK ) ; } return nblks ; }\n","target":"<S2SV_ModStart> uint dblocks = xfs_attr3_rmt_blocks <S2SV_ModEnd> ( mp ,\n","project_and_commit_id":"torvalds@linux/8275cdd0e7ac550dcce2b3ef6d2fb3b808c1ae59","cve_id":"CVE-2015-0274","original_address":"https://github.com/torvalds/linux/commit/8275cdd0e7ac550dcce2b3ef6d2fb3b808c1ae59","time":"2015-03-16T10:59Z"},
	{"Unnamed: 0":5540,"cwe_id":"CWE-416","source":"CWE-416 CURLcode Curl_close ( struct Curl_easy * data ) { struct Curl_multi * m ; if ( ! data ) return CURLE_OK ; Curl_expire_clear ( data ) ; m = data -> multi ; if ( m ) curl_multi_remove_handle ( data -> multi , data ) ; <S2SV_StartBug> if ( data -> multi_easy ) <S2SV_EndBug> <S2SV_StartBug> curl_multi_cleanup ( data -> multi_easy ) ; <S2SV_EndBug> Curl_llist_destroy ( & data -> state . timeoutlist , NULL ) ; data -> magic = 0 ; if ( data -> state . rangestringalloc ) free ( data -> state . range ) ; Curl_free_request_state ( data ) ; Curl_ssl_close_all ( data ) ; Curl_safefree ( data -> state . first_host ) ; Curl_safefree ( data -> state . scratch ) ; Curl_ssl_free_certinfo ( data ) ; free ( data -> req . newurl ) ; data -> req . newurl = NULL ; if ( data -> change . referer_alloc ) { Curl_safefree ( data -> change . referer ) ; data -> change . referer_alloc = FALSE ; } data -> change . referer = NULL ; Curl_up_free ( data ) ; Curl_safefree ( data -> state . buffer ) ; Curl_safefree ( data -> state . headerbuff ) ; Curl_safefree ( data -> state . ulbuf ) ; Curl_flush_cookies ( data , 1 ) ; Curl_digest_cleanup ( data ) ; Curl_safefree ( data -> info . contenttype ) ; Curl_safefree ( data -> info . wouldredirect ) ; Curl_resolver_cleanup ( data -> state . resolver ) ; Curl_http2_cleanup_dependencies ( data ) ; Curl_convert_close ( data ) ; if ( data -> share ) { Curl_share_lock ( data , CURL_LOCK_DATA_SHARE , CURL_LOCK_ACCESS_SINGLE ) ; data -> share -> dirty -- ; Curl_share_unlock ( data , CURL_LOCK_DATA_SHARE ) ; } Curl_wildcard_dtor ( & data -> wildcard ) ; Curl_freeset ( data ) ; free ( data ) ; return CURLE_OK ; }\n","target":"<S2SV_ModStart> -> multi_easy ) { <S2SV_ModStart> multi_easy ) ; data -> multi_easy = NULL ; }\n","project_and_commit_id":"curl@curl/81d135d67155c5295b1033679c606165d4e28f3f","cve_id":"CVE-2018-16840","original_address":"https://github.com/curl/curl/commit/81d135d67155c5295b1033679c606165d4e28f3f","time":"2018-10-31T18:29Z"},
	{"Unnamed: 0":1195,"cwe_id":"CWE-119","source":"CWE-119 static unsigned int get_sby_perpixel_diff_variance ( VP9_COMP * cpi , <S2SV_StartBug> MACROBLOCK * x , <S2SV_EndBug> int mi_row , int mi_col , BLOCK_SIZE bs ) { <S2SV_StartBug> const YV12_BUFFER_CONFIG * yv12 = get_ref_frame_buffer ( cpi , LAST_FRAME ) ; <S2SV_EndBug> <S2SV_StartBug> int offset = ( mi_row * MI_SIZE ) * yv12 -> y_stride + ( mi_col * MI_SIZE ) ; <S2SV_EndBug> unsigned int var , sse ; <S2SV_StartBug> var = cpi -> fn_ptr [ bs ] . vf ( x -> plane [ 0 ] . src . buf , <S2SV_EndBug> x -> plane [ 0 ] . src . stride , yv12 -> y_buffer + offset , yv12 -> y_stride , & sse ) ; return ROUND_POWER_OF_TWO ( var , num_pels_log2_lookup [ bs ] ) ; }\n","target":"<S2SV_ModStart> * cpi , const struct buf_2d * ref <S2SV_ModEnd> , int mi_row <S2SV_ModStart> bs ) { unsigned int sse , var ; uint8_t * last_y ; <S2SV_ModStart> const YV12_BUFFER_CONFIG * last <S2SV_ModEnd> = get_ref_frame_buffer ( <S2SV_ModStart> LAST_FRAME ) ; assert ( last != NULL ) ; last_y = & last -> y_buffer [ <S2SV_ModEnd> mi_row * MI_SIZE <S2SV_ModStart> mi_row * MI_SIZE * last <S2SV_ModEnd> -> y_stride + <S2SV_ModStart> -> y_stride + <S2SV_ModEnd> mi_col * MI_SIZE <S2SV_ModStart> mi_col * MI_SIZE ] <S2SV_ModEnd> ; var = <S2SV_ModStart> . vf ( ref -> buf , ref -> stride , last_y , last <S2SV_ModEnd> -> y_stride ,\n","project_and_commit_id":"external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426","cve_id":"CVE-2016-1621","original_address":"https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426","time":"2016-03-12T21:59Z"},
	{"Unnamed: 0":6242,"cwe_id":"CWE-125","source":"CWE-125 void skb_complete_tx_timestamp ( struct sk_buff * skb , struct skb_shared_hwtstamps * hwtstamps ) { struct sock * sk = skb -> sk ; if ( ! skb_may_tx_timestamp ( sk , false ) ) return ; if ( likely ( atomic_inc_not_zero ( & sk -> sk_refcnt ) ) ) { * skb_hwtstamps ( skb ) = * hwtstamps ; <S2SV_StartBug> __skb_complete_tx_timestamp ( skb , sk , SCM_TSTAMP_SND ) ; <S2SV_EndBug> sock_put ( sk ) ; } }\n","target":"<S2SV_ModStart> sk , SCM_TSTAMP_SND , false\n","project_and_commit_id":"torvalds@linux/4ef1b2869447411ad3ef91ad7d4891a83c1a509a","cve_id":"CVE-2017-7277","original_address":"https://github.com/torvalds/linux/commit/4ef1b2869447411ad3ef91ad7d4891a83c1a509a","time":"2017-03-28T06:59Z"},
	{"Unnamed: 0":2416,"cwe_id":"CWE-264","source":"CWE-264 static int userns_install ( struct nsproxy * nsproxy , void * ns ) { struct user_namespace * user_ns = ns ; struct cred * cred ; if ( user_ns == current_user_ns ( ) ) return - EINVAL ; <S2SV_StartBug> if ( atomic_read ( & current -> mm -> mm_users ) > 1 ) <S2SV_EndBug> return - EINVAL ; if ( ! ns_capable ( user_ns , CAP_SYS_ADMIN ) ) return - EPERM ; cred = prepare_creds ( ) ; if ( ! cred ) return - ENOMEM ; put_user_ns ( cred -> user_ns ) ; set_cred_user_ns ( cred , get_user_ns ( user_ns ) ) ; return commit_creds ( cred ) ; }\n","target":"<S2SV_ModStart> mm_users ) > 1 ) return - EINVAL ; if ( current -> fs -> users !=\n","project_and_commit_id":"torvalds@linux/e66eded8309ebf679d3d3c1f5820d1f2ca332c71","cve_id":"CVE-2013-1858","original_address":"https://github.com/torvalds/linux/commit/e66eded8309ebf679d3d3c1f5820d1f2ca332c71","time":"2013-04-05T21:55Z"},
	{"Unnamed: 0":4857,"cwe_id":"CWE-200","source":"CWE-200 static int sco_sock_getsockopt_old ( struct socket * sock , int optname , char __user * optval , int __user * optlen ) { struct sock * sk = sock -> sk ; struct sco_options opts ; struct sco_conninfo cinfo ; int len , err = 0 ; BT_DBG ( \"sk<S2SV_blank>%p\" , sk ) ; if ( get_user ( len , optlen ) ) return - EFAULT ; lock_sock ( sk ) ; switch ( optname ) { case SCO_OPTIONS : if ( sk -> sk_state != BT_CONNECTED ) { err = - ENOTCONN ; break ; } opts . mtu = sco_pi ( sk ) -> conn -> mtu ; BT_DBG ( \"mtu<S2SV_blank>%d\" , opts . mtu ) ; len = min_t ( unsigned int , len , sizeof ( opts ) ) ; if ( copy_to_user ( optval , ( char * ) & opts , len ) ) err = - EFAULT ; break ; case SCO_CONNINFO : if ( sk -> sk_state != BT_CONNECTED ) { err = - ENOTCONN ; break ; } <S2SV_StartBug> cinfo . hci_handle = sco_pi ( sk ) -> conn -> hcon -> handle ; <S2SV_EndBug> memcpy ( cinfo . dev_class , sco_pi ( sk ) -> conn -> hcon -> dev_class , 3 ) ; len = min_t ( unsigned int , len , sizeof ( cinfo ) ) ; if ( copy_to_user ( optval , ( char * ) & cinfo , len ) ) err = - EFAULT ; break ; default : err = - ENOPROTOOPT ; break ; } release_sock ( sk ) ; return err ; }\n","target":"<S2SV_ModStart> break ; } memset ( & cinfo , 0 , sizeof ( cinfo ) ) ;\n","project_and_commit_id":"torvalds@linux/c4c896e1471aec3b004a693c689f60be3b17ac86","cve_id":"CVE-2011-1078","original_address":"https://github.com/torvalds/linux/commit/c4c896e1471aec3b004a693c689f60be3b17ac86","time":"2012-06-21T23:55Z"},
	{"Unnamed: 0":1382,"cwe_id":"CWE-189","source":"CWE-189 static int perf_swevent_init ( struct perf_event * event ) { <S2SV_StartBug> int event_id = event -> attr . config ; <S2SV_EndBug> if ( event -> attr . type != PERF_TYPE_SOFTWARE ) return - ENOENT ; if ( has_branch_stack ( event ) ) return - EOPNOTSUPP ; switch ( event_id ) { case PERF_COUNT_SW_CPU_CLOCK : case PERF_COUNT_SW_TASK_CLOCK : return - ENOENT ; default : break ; } if ( event_id >= PERF_COUNT_SW_MAX ) return - ENOENT ; if ( ! event -> parent ) { int err ; err = swevent_hlist_get ( event ) ; if ( err ) return err ; static_key_slow_inc ( & perf_swevent_enabled [ event_id ] ) ; event -> destroy = sw_perf_event_destroy ; } return 0 ; }\n","target":"<S2SV_ModStart> event ) { u64 <S2SV_ModEnd> event_id = event\n","project_and_commit_id":"torvalds@linux/8176cced706b5e5d15887584150764894e94e02f","cve_id":"CVE-2013-2094","original_address":"https://github.com/torvalds/linux/commit/8176cced706b5e5d15887584150764894e94e02f","time":"2013-05-14T20:55Z"},
	{"Unnamed: 0":3611,"cwe_id":"CWE-119","source":"CWE-119 static void videobuf_vm_open ( struct vm_area_struct * vma ) { struct videobuf_mapping * map = vma -> vm_private_data ; <S2SV_StartBug> dprintk ( 2 , \"vm_open<S2SV_blank>%p<S2SV_blank>[count=%d,vma=%08lx-%08lx]\\\\n\" , map , <S2SV_EndBug> map -> count , vma -> vm_start , vma -> vm_end ) ; map -> count ++ ; }\n","target":"<S2SV_ModStart> ( 2 , \"vm_open<S2SV_blank>%p<S2SV_blank>[count=%u,vma=%08lx-%08lx]\\\\n\" <S2SV_ModEnd> , map ,\n","project_and_commit_id":"torvalds@linux/0b29669c065f60501e7289e1950fa2a618962358","cve_id":"CVE-2007-6761","original_address":"https://github.com/torvalds/linux/commit/0b29669c065f60501e7289e1950fa2a618962358","time":"2017-04-24T06:59Z"},
	{"Unnamed: 0":3225,"cwe_id":"CWE-416","source":"CWE-416 <S2SV_StartBug> static void buffer_pipe_buf_get ( struct pipe_inode_info * pipe , <S2SV_EndBug> struct pipe_buffer * buf ) { struct buffer_ref * ref = ( struct buffer_ref * ) buf -> private ; <S2SV_StartBug> ref -> ref ++ ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug>\n","target":"<S2SV_ModStart> <S2SV_null> <S2SV_null> static bool <S2SV_ModEnd> buffer_pipe_buf_get ( struct <S2SV_ModStart> -> private ; if ( ref -> ref > INT_MAX / 2 ) return false ; <S2SV_ModStart> ref ++ ; return true ;\n","project_and_commit_id":"torvalds@linux/15fab63e1e57be9fdb5eec1bbc5916e9825e9acb","cve_id":"CVE-2019-11487","original_address":"https://github.com/torvalds/linux/commit/15fab63e1e57be9fdb5eec1bbc5916e9825e9acb","time":"2019-04-23T22:29Z"},
	{"Unnamed: 0":6551,"cwe_id":"CWE-20","source":"CWE-20 static int flashsv_decode_frame ( AVCodecContext * avctx , void * data , int * got_frame , AVPacket * avpkt ) { int buf_size = avpkt -> size ; FlashSVContext * s = avctx -> priv_data ; int h_blocks , v_blocks , h_part , v_part , i , j , ret ; GetBitContext gb ; int last_blockwidth = s -> block_width ; int last_blockheight = s -> block_height ; if ( buf_size == 0 ) return 0 ; if ( buf_size < 4 ) return - 1 ; init_get_bits ( & gb , avpkt -> data , buf_size * 8 ) ; s -> block_width = 16 * ( get_bits ( & gb , 4 ) + 1 ) ; s -> image_width = get_bits ( & gb , 12 ) ; s -> block_height = 16 * ( get_bits ( & gb , 4 ) + 1 ) ; s -> image_height = get_bits ( & gb , 12 ) ; if ( last_blockwidth != s -> block_width || last_blockheight != s -> block_height ) av_freep ( & s -> blocks ) ; if ( s -> ver == 2 ) { skip_bits ( & gb , 6 ) ; if ( get_bits1 ( & gb ) ) { avpriv_request_sample ( avctx , \"iframe\" ) ; return AVERROR_PATCHWELCOME ; } if ( get_bits1 ( & gb ) ) { avpriv_request_sample ( avctx , \"Custom<S2SV_blank>palette\" ) ; return AVERROR_PATCHWELCOME ; } } h_blocks = s -> image_width / s -> block_width ; h_part = s -> image_width % s -> block_width ; v_blocks = s -> image_height / s -> block_height ; v_part = s -> image_height % s -> block_height ; if ( s -> block_size < s -> block_width * s -> block_height ) { int tmpblock_size = 3 * s -> block_width * s -> block_height ; s -> tmpblock = av_realloc ( s -> tmpblock , tmpblock_size ) ; if ( ! s -> tmpblock ) { av_log ( avctx , AV_LOG_ERROR , \"Can\\'t<S2SV_blank>allocate<S2SV_blank>decompression<S2SV_blank>buffer.\\\\n\" ) ; return AVERROR ( ENOMEM ) ; } if ( s -> ver == 2 ) { s -> deflate_block_size = calc_deflate_block_size ( tmpblock_size ) ; if ( s -> deflate_block_size <= 0 ) { av_log ( avctx , AV_LOG_ERROR , \"Can\\'t<S2SV_blank>determine<S2SV_blank>deflate<S2SV_blank>buffer<S2SV_blank>size.\\\\n\" ) ; return - 1 ; } s -> deflate_block = av_realloc ( s -> deflate_block , s -> deflate_block_size ) ; if ( ! s -> deflate_block ) { av_log ( avctx , AV_LOG_ERROR , \"Can\\'t<S2SV_blank>allocate<S2SV_blank>deflate<S2SV_blank>buffer.\\\\n\" ) ; return AVERROR ( ENOMEM ) ; } } } s -> block_size = s -> block_width * s -> block_height ; if ( avctx -> width == 0 && avctx -> height == 0 ) { avcodec_set_dimensions ( avctx , s -> image_width , s -> image_height ) ; } if ( avctx -> width != s -> image_width || avctx -> height != s -> image_height ) { av_log ( avctx , AV_LOG_ERROR , \"Frame<S2SV_blank>width<S2SV_blank>or<S2SV_blank>height<S2SV_blank>differs<S2SV_blank>from<S2SV_blank>first<S2SV_blank>frame!\\\\n\" ) ; av_log ( avctx , AV_LOG_ERROR , \"fh<S2SV_blank>=<S2SV_blank>%d,<S2SV_blank>fv<S2SV_blank>%d<S2SV_blank><S2SV_blank>vs<S2SV_blank><S2SV_blank>ch<S2SV_blank>=<S2SV_blank>%d,<S2SV_blank>cv<S2SV_blank>=<S2SV_blank>%d\\\\n\" , avctx -> height , avctx -> width , s -> image_height , s -> image_width ) ; return AVERROR_INVALIDDATA ; } s -> is_keyframe = ( avpkt -> flags & AV_PKT_FLAG_KEY ) && ( s -> ver == 2 ) ; if ( s -> is_keyframe ) { s -> keyframedata = av_realloc ( s -> keyframedata , avpkt -> size ) ; memcpy ( s -> keyframedata , avpkt -> data , avpkt -> size ) ; } if ( s -> ver == 2 && ! s -> blocks ) s -> blocks = av_mallocz ( ( v_blocks + ! ! v_part ) * ( h_blocks + ! ! h_part ) * sizeof ( s -> blocks [ 0 ] ) ) ; av_dlog ( avctx , \"image:<S2SV_blank>%dx%d<S2SV_blank>block:<S2SV_blank>%dx%d<S2SV_blank>num:<S2SV_blank>%dx%d<S2SV_blank>part:<S2SV_blank>%dx%d\\\\n\" , s -> image_width , s -> image_height , s -> block_width , s -> block_height , h_blocks , v_blocks , h_part , v_part ) ; if ( ( ret = ff_reget_buffer ( avctx , & s -> frame ) ) < 0 ) return ret ; for ( j = 0 ; j < v_blocks + ( v_part ? 1 : 0 ) ; j ++ ) { int y_pos = j * s -> block_height ; int cur_blk_height = ( j < v_blocks ) ? s -> block_height : v_part ; for ( i = 0 ; i < h_blocks + ( h_part ? 1 : 0 ) ; i ++ ) { int x_pos = i * s -> block_width ; int cur_blk_width = ( i < h_blocks ) ? s -> block_width : h_part ; int has_diff = 0 ; int size = get_bits ( & gb , 16 ) ; s -> color_depth = 0 ; s -> zlibprime_curr = 0 ; s -> zlibprime_prev = 0 ; s -> diff_start = 0 ; s -> diff_height = cur_blk_height ; if ( 8 * size > get_bits_left ( & gb ) ) { av_frame_unref ( & s -> frame ) ; return AVERROR_INVALIDDATA ; } if ( s -> ver == 2 && size ) { skip_bits ( & gb , 3 ) ; s -> color_depth = get_bits ( & gb , 2 ) ; has_diff = get_bits1 ( & gb ) ; s -> zlibprime_curr = get_bits1 ( & gb ) ; s -> zlibprime_prev = get_bits1 ( & gb ) ; if ( s -> color_depth != 0 && s -> color_depth != 2 ) { av_log ( avctx , AV_LOG_ERROR , \"%dx%d<S2SV_blank>invalid<S2SV_blank>color<S2SV_blank>depth<S2SV_blank>%d\\\\n\" , i , j , s -> color_depth ) ; return AVERROR_INVALIDDATA ; } if ( has_diff ) { if ( ! s -> keyframe ) { av_log ( avctx , AV_LOG_ERROR , \"inter<S2SV_blank>frame<S2SV_blank>without<S2SV_blank>keyframe\\\\n\" ) ; return AVERROR_INVALIDDATA ; } s -> diff_start = get_bits ( & gb , 8 ) ; s -> diff_height = get_bits ( & gb , 8 ) ; <S2SV_StartBug> av_log ( avctx , AV_LOG_DEBUG , <S2SV_EndBug> \"%dx%d<S2SV_blank>diff<S2SV_blank>start<S2SV_blank>%d<S2SV_blank>height<S2SV_blank>%d\\\\n\" , i , j , s -> diff_start , s -> diff_height ) ; size -= 2 ; } if ( s -> zlibprime_prev ) av_log ( avctx , AV_LOG_DEBUG , \"%dx%d<S2SV_blank>zlibprime_prev\\\\n\" , i , j ) ; if ( s -> zlibprime_curr ) { int col = get_bits ( & gb , 8 ) ; int row = get_bits ( & gb , 8 ) ; av_log ( avctx , AV_LOG_DEBUG , \"%dx%d<S2SV_blank>zlibprime_curr<S2SV_blank>%dx%d\\\\n\" , i , j , col , row ) ; size -= 2 ; avpriv_request_sample ( avctx , \"zlibprime_curr\" ) ; return AVERROR_PATCHWELCOME ; } if ( ! s -> blocks && ( s -> zlibprime_curr || s -> zlibprime_prev ) ) { av_log ( avctx , AV_LOG_ERROR , \"no<S2SV_blank>data<S2SV_blank>available<S2SV_blank>for<S2SV_blank>zlib<S2SV_blank>\" \"priming\\\\n\" ) ; return AVERROR_INVALIDDATA ; } size -- ; } if ( has_diff ) { int k ; int off = ( s -> image_height - y_pos - 1 ) * s -> frame . linesize [ 0 ] ; for ( k = 0 ; k < cur_blk_height ; k ++ ) memcpy ( s -> frame . data [ 0 ] + off - k * s -> frame . linesize [ 0 ] + x_pos * 3 , s -> keyframe + off - k * s -> frame . linesize [ 0 ] + x_pos * 3 , cur_blk_width * 3 ) ; } if ( size ) { if ( flashsv_decode_block ( avctx , avpkt , & gb , size , cur_blk_width , cur_blk_height , x_pos , y_pos , i + j * ( h_blocks + ! ! h_part ) ) ) av_log ( avctx , AV_LOG_ERROR , \"error<S2SV_blank>in<S2SV_blank>decompression<S2SV_blank>of<S2SV_blank>block<S2SV_blank>%dx%d\\\\n\" , i , j ) ; } } } if ( s -> is_keyframe && s -> ver == 2 ) { if ( ! s -> keyframe ) { s -> keyframe = av_malloc ( s -> frame . linesize [ 0 ] * avctx -> height ) ; if ( ! s -> keyframe ) { av_log ( avctx , AV_LOG_ERROR , \"Cannot<S2SV_blank>allocate<S2SV_blank>image<S2SV_blank>data\\\\n\" ) ; return AVERROR ( ENOMEM ) ; } } memcpy ( s -> keyframe , s -> frame . data [ 0 ] , s -> frame . linesize [ 0 ] * avctx -> height ) ; } if ( ( ret = av_frame_ref ( data , & s -> frame ) ) < 0 ) return ret ; * got_frame = 1 ; if ( ( get_bits_count ( & gb ) / 8 ) != buf_size ) av_log ( avctx , AV_LOG_ERROR , \"buffer<S2SV_blank>not<S2SV_blank>fully<S2SV_blank>consumed<S2SV_blank>(%d<S2SV_blank>!=<S2SV_blank>%d)\\\\n\" , buf_size , ( get_bits_count ( & gb ) / 8 ) ) ; return buf_size ; }\n","target":"<S2SV_ModStart> 8 ) ; if ( s -> diff_start + s -> diff_height > cur_blk_height ) { av_log ( avctx , AV_LOG_ERROR , \"Block<S2SV_blank>parameters<S2SV_blank>invalid\\\\n\" ) ; return AVERROR_INVALIDDATA ; }\n","project_and_commit_id":"FFmpeg@FFmpeg/880c73cd76109697447fbfbaa8e5ee5683309446","cve_id":"CVE-2013-7015","original_address":"https://github.com/FFmpeg/FFmpeg/commit/880c73cd76109697447fbfbaa8e5ee5683309446","time":"2013-12-09T16:36Z"},
	{"Unnamed: 0":973,"cwe_id":"CWE-119","source":"CWE-119 static void is_skippable ( int plane , int block , BLOCK_SIZE plane_bsize , TX_SIZE tx_size , void * argv ) { struct is_skippable_args * args = argv ; <S2SV_StartBug> args -> skippable [ 0 ] &= ( ! args -> x -> plane [ plane ] . eobs [ block ] ) ; <S2SV_EndBug> }\n","target":"<S2SV_ModStart> = argv ; ( void ) plane ; ( void ) plane_bsize ; ( void ) tx_size ; <S2SV_ModStart> ! args -> <S2SV_ModEnd> eobs [ block\n","project_and_commit_id":"external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426","cve_id":"CVE-2016-1621","original_address":"https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426","time":"2016-03-12T21:59Z"},
	{"Unnamed: 0":1311,"cwe_id":"CWE-125","source":"CWE-125 static Image * ReadSGIImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { Image * image ; MagickBooleanType status ; MagickSizeType number_pixels ; MemoryInfo * pixel_info ; register Quantum * q ; register ssize_t i , x ; register unsigned char * p ; SGIInfo iris_info ; size_t bytes_per_pixel , quantum ; ssize_t count , y , z ; unsigned char * pixels ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickCoreSignature ) ; if ( image_info -> debug != MagickFalse ) ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , \"%s\" , image_info -> filename ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickCoreSignature ) ; image = AcquireImage ( image_info , exception ) ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } iris_info . magic = ReadBlobMSBShort ( image ) ; do { if ( iris_info . magic != 0x01DA ) ThrowReaderException ( CorruptImageError , \"ImproperImageHeader\" ) ; iris_info . storage = ( unsigned char ) ReadBlobByte ( image ) ; switch ( iris_info . storage ) { case 0x00 : image -> compression = NoCompression ; break ; case 0x01 : image -> compression = RLECompression ; break ; default : ThrowReaderException ( CorruptImageError , \"ImproperImageHeader\" ) ; } iris_info . bytes_per_pixel = ( unsigned char ) ReadBlobByte ( image ) ; if ( ( iris_info . bytes_per_pixel == 0 ) || ( iris_info . bytes_per_pixel > 2 ) ) ThrowReaderException ( CorruptImageError , \"ImproperImageHeader\" ) ; iris_info . dimension = ReadBlobMSBShort ( image ) ; iris_info . columns = ReadBlobMSBShort ( image ) ; iris_info . rows = ReadBlobMSBShort ( image ) ; iris_info . depth = ReadBlobMSBShort ( image ) ; if ( ( iris_info . depth == 0 ) || ( iris_info . depth > 4 ) ) ThrowReaderException ( CorruptImageError , \"ImproperImageHeader\" ) ; iris_info . minimum_value = ReadBlobMSBLong ( image ) ; iris_info . maximum_value = ReadBlobMSBLong ( image ) ; iris_info . sans = ReadBlobMSBLong ( image ) ; <S2SV_StartBug> ( void ) ReadBlob ( image , sizeof ( iris_info . name ) , ( unsigned char * ) <S2SV_EndBug> <S2SV_StartBug> iris_info . name ) ; <S2SV_EndBug> iris_info . name [ sizeof ( iris_info . name ) - 1 ] = '\\\\0' ; if ( * iris_info . name != '\\\\0' ) ( void ) SetImageProperty ( image , \"label\" , iris_info . name , exception ) ; iris_info . pixel_format = ReadBlobMSBLong ( image ) ; if ( iris_info . pixel_format != 0 ) ThrowReaderException ( CorruptImageError , \"ImproperImageHeader\" ) ; count = ReadBlob ( image , sizeof ( iris_info . filler ) , iris_info . filler ) ; <S2SV_StartBug> ( void ) count ; <S2SV_EndBug> image -> columns = iris_info . columns ; image -> rows = iris_info . rows ; image -> depth = ( size_t ) MagickMin ( iris_info . depth , MAGICKCORE_QUANTUM_DEPTH ) ; if ( iris_info . pixel_format == 0 ) image -> depth = ( size_t ) MagickMin ( ( size_t ) 8 * iris_info . bytes_per_pixel , MAGICKCORE_QUANTUM_DEPTH ) ; if ( iris_info . depth < 3 ) { image -> storage_class = PseudoClass ; image -> colors = iris_info . bytes_per_pixel > 1 ? 65535 : 256 ; } <S2SV_StartBug> if ( EOFBlob ( image ) != MagickFalse ) <S2SV_EndBug> ThrowReaderException ( CorruptImageError , \"ImproperImageHeader\" ) ; if ( ( image_info -> ping != MagickFalse ) && ( image_info -> number_scenes != 0 ) ) if ( image -> scene >= ( image_info -> scene + image_info -> number_scenes - 1 ) ) break ; status = SetImageExtent ( image , image -> columns , image -> rows , exception ) ; if ( status == MagickFalse ) return ( DestroyImageList ( image ) ) ; bytes_per_pixel = ( size_t ) iris_info . bytes_per_pixel ; number_pixels = ( MagickSizeType ) iris_info . columns * iris_info . rows ; if ( ( 4 * bytes_per_pixel * number_pixels ) != ( ( MagickSizeType ) ( size_t ) ( 4 * bytes_per_pixel * number_pixels ) ) ) ThrowReaderException ( ResourceLimitError , \"MemoryAllocationFailed\" ) ; pixel_info = AcquireVirtualMemory ( iris_info . columns , iris_info . rows * 4 * bytes_per_pixel * sizeof ( * pixels ) ) ; if ( pixel_info == ( MemoryInfo * ) NULL ) ThrowReaderException ( ResourceLimitError , \"MemoryAllocationFailed\" ) ; pixels = ( unsigned char * ) GetVirtualMemoryBlob ( pixel_info ) ; if ( ( int ) iris_info . storage != 0x01 ) { unsigned char * scanline ; scanline = ( unsigned char * ) AcquireQuantumMemory ( iris_info . columns , bytes_per_pixel * sizeof ( * scanline ) ) ; if ( scanline == ( unsigned char * ) NULL ) ThrowReaderException ( ResourceLimitError , \"MemoryAllocationFailed\" ) ; for ( z = 0 ; z < ( ssize_t ) iris_info . depth ; z ++ ) { p = pixels + bytes_per_pixel * z ; for ( y = 0 ; y < ( ssize_t ) iris_info . rows ; y ++ ) { count = ReadBlob ( image , bytes_per_pixel * iris_info . columns , scanline ) ; if ( EOFBlob ( image ) != MagickFalse ) break ; if ( bytes_per_pixel == 2 ) for ( x = 0 ; x < ( ssize_t ) iris_info . columns ; x ++ ) { * p = scanline [ 2 * x ] ; * ( p + 1 ) = scanline [ 2 * x + 1 ] ; p += 8 ; } else for ( x = 0 ; x < ( ssize_t ) iris_info . columns ; x ++ ) { * p = scanline [ x ] ; p += 4 ; } } } scanline = ( unsigned char * ) RelinquishMagickMemory ( scanline ) ; } else { MemoryInfo * packet_info ; size_t * runlength ; ssize_t offset , * offsets ; unsigned char * packets ; unsigned int data_order ; offsets = ( ssize_t * ) AcquireQuantumMemory ( ( size_t ) iris_info . rows , iris_info . depth * sizeof ( * offsets ) ) ; runlength = ( size_t * ) AcquireQuantumMemory ( iris_info . rows , iris_info . depth * sizeof ( * runlength ) ) ; packet_info = AcquireVirtualMemory ( ( size_t ) iris_info . columns + 10UL , 4UL * sizeof ( * packets ) ) ; if ( ( offsets == ( ssize_t * ) NULL ) || ( runlength == ( size_t * ) NULL ) || ( packet_info == ( MemoryInfo * ) NULL ) ) { if ( offsets == ( ssize_t * ) NULL ) offsets = ( ssize_t * ) RelinquishMagickMemory ( offsets ) ; if ( runlength == ( size_t * ) NULL ) runlength = ( size_t * ) RelinquishMagickMemory ( runlength ) ; if ( packet_info == ( MemoryInfo * ) NULL ) packet_info = RelinquishVirtualMemory ( packet_info ) ; ThrowReaderException ( ResourceLimitError , \"MemoryAllocationFailed\" ) ; } packets = ( unsigned char * ) GetVirtualMemoryBlob ( packet_info ) ; for ( i = 0 ; i < ( ssize_t ) ( iris_info . rows * iris_info . depth ) ; i ++ ) offsets [ i ] = ReadBlobMSBSignedLong ( image ) ; for ( i = 0 ; i < ( ssize_t ) ( iris_info . rows * iris_info . depth ) ; i ++ ) { runlength [ i ] = ReadBlobMSBLong ( image ) ; if ( runlength [ i ] > ( 4 * ( size_t ) iris_info . columns + 10 ) ) ThrowReaderException ( CorruptImageError , \"ImproperImageHeader\" ) ; } offset = 0 ; data_order = 0 ; for ( y = 0 ; ( ( y < ( ssize_t ) iris_info . rows ) && ( data_order == 0 ) ) ; y ++ ) for ( z = 0 ; ( ( z < ( ssize_t ) iris_info . depth ) && ( data_order == 0 ) ) ; z ++ ) { if ( offsets [ y + z * iris_info . rows ] < offset ) data_order = 1 ; offset = offsets [ y + z * iris_info . rows ] ; } offset = ( ssize_t ) TellBlob ( image ) ; if ( data_order == 1 ) { for ( z = 0 ; z < ( ssize_t ) iris_info . depth ; z ++ ) { p = pixels ; for ( y = 0 ; y < ( ssize_t ) iris_info . rows ; y ++ ) { if ( offset != offsets [ y + z * iris_info . rows ] ) { offset = offsets [ y + z * iris_info . rows ] ; offset = ( ssize_t ) SeekBlob ( image , ( ssize_t ) offset , SEEK_SET ) ; } count = ReadBlob ( image , ( size_t ) runlength [ y + z * iris_info . rows ] , packets ) ; if ( EOFBlob ( image ) != MagickFalse ) break ; offset += ( ssize_t ) runlength [ y + z * iris_info . rows ] ; status = SGIDecode ( bytes_per_pixel , ( ssize_t ) ( runlength [ y + z * iris_info . rows ] / bytes_per_pixel ) , packets , 1L * iris_info . columns , p + bytes_per_pixel * z ) ; if ( status == MagickFalse ) ThrowReaderException ( CorruptImageError , \"ImproperImageHeader\" ) ; p += ( iris_info . columns * 4 * bytes_per_pixel ) ; } } } else { MagickOffsetType position ; position = TellBlob ( image ) ; p = pixels ; for ( y = 0 ; y < ( ssize_t ) iris_info . rows ; y ++ ) { for ( z = 0 ; z < ( ssize_t ) iris_info . depth ; z ++ ) { if ( offset != offsets [ y + z * iris_info . rows ] ) { offset = offsets [ y + z * iris_info . rows ] ; offset = ( ssize_t ) SeekBlob ( image , ( ssize_t ) offset , SEEK_SET ) ; } count = ReadBlob ( image , ( size_t ) runlength [ y + z * iris_info . rows ] , packets ) ; if ( EOFBlob ( image ) != MagickFalse ) break ; offset += ( ssize_t ) runlength [ y + z * iris_info . rows ] ; status = SGIDecode ( bytes_per_pixel , ( ssize_t ) ( runlength [ y + z * iris_info . rows ] / bytes_per_pixel ) , packets , 1L * iris_info . columns , p + bytes_per_pixel * z ) ; if ( status == MagickFalse ) ThrowReaderException ( CorruptImageError , \"ImproperImageHeader\" ) ; } p += ( iris_info . columns * 4 * bytes_per_pixel ) ; } offset = ( ssize_t ) SeekBlob ( image , position , SEEK_SET ) ; } packet_info = RelinquishVirtualMemory ( packet_info ) ; runlength = ( size_t * ) RelinquishMagickMemory ( runlength ) ; offsets = ( ssize_t * ) RelinquishMagickMemory ( offsets ) ; } image -> alpha_trait = iris_info . depth == 4 ? BlendPixelTrait : UndefinedPixelTrait ; image -> columns = iris_info . columns ; image -> rows = iris_info . rows ; if ( image -> storage_class == DirectClass ) { if ( bytes_per_pixel == 2 ) { for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { p = pixels + ( image -> rows - y - 1 ) * 8 * image -> columns ; q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { SetPixelRed ( image , ScaleShortToQuantum ( ( unsigned short ) ( ( * ( p + 0 ) << 8 ) | ( * ( p + 1 ) ) ) ) , q ) ; SetPixelGreen ( image , ScaleShortToQuantum ( ( unsigned short ) ( ( * ( p + 2 ) << 8 ) | ( * ( p + 3 ) ) ) ) , q ) ; SetPixelBlue ( image , ScaleShortToQuantum ( ( unsigned short ) ( ( * ( p + 4 ) << 8 ) | ( * ( p + 5 ) ) ) ) , q ) ; SetPixelAlpha ( image , OpaqueAlpha , q ) ; if ( image -> alpha_trait != UndefinedPixelTrait ) SetPixelAlpha ( image , ScaleShortToQuantum ( ( unsigned short ) ( ( * ( p + 6 ) << 8 ) | ( * ( p + 7 ) ) ) ) , q ) ; p += 8 ; q += GetPixelChannels ( image ) ; } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ; if ( status == MagickFalse ) break ; } } } else for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { p = pixels + ( image -> rows - y - 1 ) * 4 * image -> columns ; q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { SetPixelRed ( image , ScaleCharToQuantum ( * p ) , q ) ; SetPixelGreen ( image , ScaleCharToQuantum ( * ( p + 1 ) ) , q ) ; SetPixelBlue ( image , ScaleCharToQuantum ( * ( p + 2 ) ) , q ) ; SetPixelAlpha ( image , OpaqueAlpha , q ) ; if ( image -> alpha_trait != UndefinedPixelTrait ) SetPixelAlpha ( image , ScaleCharToQuantum ( * ( p + 3 ) ) , q ) ; p += 4 ; q += GetPixelChannels ( image ) ; } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ; if ( status == MagickFalse ) break ; } } } else { if ( AcquireImageColormap ( image , image -> colors , exception ) == MagickFalse ) ThrowReaderException ( ResourceLimitError , \"MemoryAllocationFailed\" ) ; if ( bytes_per_pixel == 2 ) { for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { p = pixels + ( image -> rows - y - 1 ) * 8 * image -> columns ; q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { quantum = ( * p << 8 ) ; quantum |= ( * ( p + 1 ) ) ; SetPixelIndex ( image , ( Quantum ) quantum , q ) ; p += 8 ; q += GetPixelChannels ( image ) ; } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ; if ( status == MagickFalse ) break ; } } } else for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { p = pixels + ( image -> rows - y - 1 ) * 4 * image -> columns ; q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { SetPixelIndex ( image , * p , q ) ; p += 4 ; q += GetPixelChannels ( image ) ; } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ; if ( status == MagickFalse ) break ; } } ( void ) SyncImage ( image , exception ) ; } pixel_info = RelinquishVirtualMemory ( pixel_info ) ; if ( EOFBlob ( image ) != MagickFalse ) { ThrowFileException ( exception , CorruptImageError , \"UnexpectedEndOfFile\" , image -> filename ) ; break ; } if ( image_info -> number_scenes != 0 ) if ( image -> scene >= ( image_info -> scene + image_info -> number_scenes - 1 ) ) break ; iris_info . magic = ReadBlobMSBShort ( image ) ; if ( iris_info . magic == 0x01DA ) { AcquireNextImage ( image_info , image , exception ) ; if ( GetNextImageInList ( image ) == ( Image * ) NULL ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } image = SyncNextImageInList ( image ) ; status = SetImageProgress ( image , LoadImagesTag , TellBlob ( image ) , GetBlobSize ( image ) ) ; if ( status == MagickFalse ) break ; } } while ( iris_info . magic == 0x01DA ) ; ( void ) CloseBlob ( image ) ; return ( GetFirstImageInList ( image ) ) ; }\n","target":"<S2SV_ModStart> image ) ; count = <S2SV_ModEnd> ReadBlob ( image <S2SV_ModStart> iris_info . name ) ; if ( count != sizeof ( iris_info . name ) ) ThrowReaderException ( CorruptImageError , \"ImproperImageHeader\" <S2SV_ModStart> filler ) ; if ( count != sizeof ( iris_info . filler ) ) ThrowReaderException ( CorruptImageError , \"ImproperImageHeader\" ) <S2SV_ModEnd> ; image -> <S2SV_ModStart> } if ( <S2SV_ModEnd> ( image_info ->\n","project_and_commit_id":"ImageMagick@ImageMagick/8f8959033e4e59418d6506b345829af1f7a71127","cve_id":"CVE-2016-7101","original_address":"https://github.com/ImageMagick/ImageMagick/commit/8f8959033e4e59418d6506b345829af1f7a71127","time":"2017-01-18T17:59Z"},
	{"Unnamed: 0":2170,"cwe_id":"CWE-20","source":"CWE-20 static void llc_sap_rcv ( struct llc_sap * sap , struct sk_buff * skb , struct sock * sk ) { struct llc_sap_state_ev * ev = llc_sap_ev ( skb ) ; ev -> type = LLC_SAP_EV_TYPE_PDU ; ev -> reason = 0 ; <S2SV_StartBug> skb -> sk = sk ; <S2SV_EndBug> llc_sap_state_process ( sap , skb ) ; }\n","target":"<S2SV_ModStart> = 0 ; skb_orphan ( skb ) ; sock_hold ( sk ) ; <S2SV_ModStart> sk = sk ; skb -> destructor = sock_efree\n","project_and_commit_id":"torvalds@linux/8b74d439e1697110c5e5c600643e823eb1dd0762","cve_id":"CVE-2017-6345","original_address":"https://github.com/torvalds/linux/commit/8b74d439e1697110c5e5c600643e823eb1dd0762","time":"2017-03-01T20:59Z"},
	{"Unnamed: 0":2796,"cwe_id":"CWE-362","source":"CWE-362 static int sockfs_setattr ( struct dentry * dentry , struct iattr * iattr ) { int err = simple_setattr ( dentry , iattr ) ; if ( ! err && ( iattr -> ia_valid & ATTR_UID ) ) { struct socket * sock = SOCKET_I ( d_inode ( dentry ) ) ; <S2SV_StartBug> sock -> sk -> sk_uid = iattr -> ia_uid ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> return err ; }\n","target":"<S2SV_ModStart> ) ) ; if ( sock -> sk ) <S2SV_ModStart> -> ia_uid ; else err = - ENOENT ;\n","project_and_commit_id":"torvalds@linux/6d8c50dcb029872b298eea68cc6209c866fd3e14","cve_id":"CVE-2018-12232","original_address":"https://github.com/torvalds/linux/commit/6d8c50dcb029872b298eea68cc6209c866fd3e14","time":"2018-06-12T12:29Z"},
	{"Unnamed: 0":4849,"cwe_id":"CWE-388","source":"CWE-388 static int vc4_get_bcl ( struct drm_device * dev , struct vc4_exec_info * exec ) { struct drm_vc4_submit_cl * args = exec -> args ; void * temp = NULL ; void * bin ; int ret = 0 ; uint32_t bin_offset = 0 ; uint32_t shader_rec_offset = roundup ( bin_offset + args -> bin_cl_size , 16 ) ; uint32_t uniforms_offset = shader_rec_offset + args -> shader_rec_size ; uint32_t exec_size = uniforms_offset + args -> uniforms_size ; uint32_t temp_size = exec_size + ( sizeof ( struct vc4_shader_state ) * args -> shader_rec_count ) ; struct vc4_bo * bo ; if ( shader_rec_offset < args -> bin_cl_size || uniforms_offset < shader_rec_offset || exec_size < uniforms_offset || args -> shader_rec_count >= ( UINT_MAX / sizeof ( struct vc4_shader_state ) ) || temp_size < exec_size ) { DRM_ERROR ( \"overflow<S2SV_blank>in<S2SV_blank>exec<S2SV_blank>arguments\\\\n\" ) ; <S2SV_StartBug> goto fail ; <S2SV_EndBug> } temp = drm_malloc_ab ( temp_size , 1 ) ; if ( ! temp ) { DRM_ERROR ( \"Failed<S2SV_blank>to<S2SV_blank>allocate<S2SV_blank>storage<S2SV_blank>for<S2SV_blank>copying<S2SV_blank>\" \"in<S2SV_blank>bin/render<S2SV_blank>CLs.\\\\n\" ) ; ret = - ENOMEM ; goto fail ; } bin = temp + bin_offset ; exec -> shader_rec_u = temp + shader_rec_offset ; exec -> uniforms_u = temp + uniforms_offset ; exec -> shader_state = temp + exec_size ; exec -> shader_state_size = args -> shader_rec_count ; if ( copy_from_user ( bin , ( void __user * ) ( uintptr_t ) args -> bin_cl , args -> bin_cl_size ) ) { ret = - EFAULT ; goto fail ; } if ( copy_from_user ( exec -> shader_rec_u , ( void __user * ) ( uintptr_t ) args -> shader_rec , args -> shader_rec_size ) ) { ret = - EFAULT ; goto fail ; } if ( copy_from_user ( exec -> uniforms_u , ( void __user * ) ( uintptr_t ) args -> uniforms , args -> uniforms_size ) ) { ret = - EFAULT ; goto fail ; } bo = vc4_bo_create ( dev , exec_size , true ) ; if ( IS_ERR ( bo ) ) { DRM_ERROR ( \"Couldn\\'t<S2SV_blank>allocate<S2SV_blank>BO<S2SV_blank>for<S2SV_blank>binning\\\\n\" ) ; ret = PTR_ERR ( bo ) ; goto fail ; } exec -> exec_bo = & bo -> base ; list_add_tail ( & to_vc4_bo ( & exec -> exec_bo -> base ) -> unref_head , & exec -> unref_list ) ; exec -> ct0ca = exec -> exec_bo -> paddr + bin_offset ; exec -> bin_u = bin ; exec -> shader_rec_v = exec -> exec_bo -> vaddr + shader_rec_offset ; exec -> shader_rec_p = exec -> exec_bo -> paddr + shader_rec_offset ; exec -> shader_rec_size = args -> shader_rec_size ; exec -> uniforms_v = exec -> exec_bo -> vaddr + uniforms_offset ; exec -> uniforms_p = exec -> exec_bo -> paddr + uniforms_offset ; exec -> uniforms_size = args -> uniforms_size ; ret = vc4_validate_bin_cl ( dev , exec -> exec_bo -> vaddr + bin_offset , bin , exec ) ; if ( ret ) goto fail ; ret = vc4_validate_shader_recs ( dev , exec ) ; if ( ret ) goto fail ; ret = vc4_wait_for_seqno ( dev , exec -> bin_dep_seqno , ~ 0ull , true ) ; fail : drm_free_large ( temp ) ; return ret ; }\n","target":"<S2SV_ModStart> \"overflow<S2SV_blank>in<S2SV_blank>exec<S2SV_blank>arguments\\\\n\" ) ; ret = - EINVAL ;\n","project_and_commit_id":"torvalds@linux/6b8ac63847bc2f958dd93c09edc941a0118992d9","cve_id":"CVE-2017-5577","original_address":"https://github.com/torvalds/linux/commit/6b8ac63847bc2f958dd93c09edc941a0118992d9","time":"2017-02-06T06:59Z"},
	{"Unnamed: 0":2344,"cwe_id":"CWE-119","source":"CWE-119 static void scsi_write_data ( SCSIRequest * req ) { SCSIDiskReq * r = DO_UPCAST ( SCSIDiskReq , req , req ) ; SCSIDiskState * s = DO_UPCAST ( SCSIDiskState , qdev , r -> req . dev ) ; uint32_t n ; assert ( r -> req . aiocb == NULL ) ; if ( r -> req . cmd . mode != SCSI_XFER_TO_DEV ) { DPRINTF ( \"Data<S2SV_blank>transfer<S2SV_blank>direction<S2SV_blank>invalid\\\\n\" ) ; scsi_write_complete ( r , - EINVAL ) ; return ; } <S2SV_StartBug> n = r -> iov . iov_len / 512 ; <S2SV_EndBug> if ( n ) { if ( s -> tray_open ) { scsi_write_complete ( r , - ENOMEDIUM ) ; } <S2SV_StartBug> qemu_iovec_init_external ( & r -> qiov , & r -> iov , 1 ) ; <S2SV_EndBug> bdrv_acct_start ( s -> bs , & r -> acct , n * BDRV_SECTOR_SIZE , BDRV_ACCT_WRITE ) ; r -> req . aiocb = bdrv_aio_writev ( s -> bs , r -> sector , & r -> qiov , n , scsi_write_complete , r ) ; if ( r -> req . aiocb == NULL ) { scsi_write_complete ( r , - ENOMEM ) ; } } else { scsi_write_complete ( r , 0 ) ; } }\n","target":"<S2SV_ModStart> = r -> qiov . size <S2SV_ModEnd> / 512 ; <S2SV_ModStart> ) ; } <S2SV_ModEnd> bdrv_acct_start ( s\n","project_and_commit_id":"bonzini@qemu/103b40f51e4012b3b0ad20f615562a1806d7f49a","cve_id":"CVE-2011-3346","original_address":"https://github.com/bonzini/qemu/commit/103b40f51e4012b3b0ad20f615562a1806d7f49a","time":"2014-04-01T06:35Z"},
	{"Unnamed: 0":1440,"cwe_id":"CWE-000","source":"CWE-000 static struct nfs4_opendata * nfs4_open_recoverdata_alloc ( struct nfs_open_context * ctx , struct nfs4_state * state ) { struct nfs4_opendata * opendata ; <S2SV_StartBug> opendata = nfs4_opendata_alloc ( & ctx -> path , state -> owner , 0 , NULL ) ; <S2SV_EndBug> if ( opendata == NULL ) return ERR_PTR ( - ENOMEM ) ; opendata -> state = state ; atomic_inc ( & state -> count ) ; return opendata ; }\n","target":"<S2SV_ModStart> state -> owner , 0\n","project_and_commit_id":"torvalds@linux/dc0b027dfadfcb8a5504f7d8052754bf8d501ab9","cve_id":"CVE-2011-4324","original_address":"https://github.com/torvalds/linux/commit/dc0b027dfadfcb8a5504f7d8052754bf8d501ab9","time":"2012-06-21T23:55Z"},
	{"Unnamed: 0":3864,"cwe_id":"CWE-119","source":"CWE-119 static int uio_mmap_physical ( struct vm_area_struct * vma ) { struct uio_device * idev = vma -> vm_private_data ; int mi = uio_find_mem_index ( vma ) ; <S2SV_StartBug> if ( mi < 0 ) <S2SV_EndBug> return - EINVAL ; vma -> vm_ops = & uio_physical_vm_ops ; vma -> vm_page_prot = pgprot_noncached ( vma -> vm_page_prot ) ; return remap_pfn_range ( vma , vma -> vm_start , <S2SV_StartBug> idev -> info -> mem [ mi ] . addr >> PAGE_SHIFT , <S2SV_EndBug> vma -> vm_end - vma -> vm_start , vma -> vm_page_prot ) ; }\n","target":"<S2SV_ModStart> vma ) ; struct uio_mem * mem ; <S2SV_ModStart> mi < 0 ) return - EINVAL ; mem = idev -> info -> mem + mi ; if ( vma -> vm_end - vma -> vm_start > mem -> size <S2SV_ModStart> -> vm_start , mem -> <S2SV_ModEnd> addr >> PAGE_SHIFT\n","project_and_commit_id":"torvalds@linux/7314e613d5ff9f0934f7a0f74ed7973b903315d1","cve_id":"CVE-2013-6763","original_address":"https://github.com/torvalds/linux/commit/7314e613d5ff9f0934f7a0f74ed7973b903315d1","time":"2013-11-12T14:35Z"},
	{"Unnamed: 0":3617,"cwe_id":"CWE-416","source":"CWE-416 static int usb_audio_probe ( struct usb_interface * intf , const struct usb_device_id * usb_id ) { struct usb_device * dev = interface_to_usbdev ( intf ) ; const struct snd_usb_audio_quirk * quirk = ( const struct snd_usb_audio_quirk * ) usb_id -> driver_info ; struct snd_usb_audio * chip ; int i , err ; struct usb_host_interface * alts ; int ifnum ; u32 id ; alts = & intf -> altsetting [ 0 ] ; ifnum = get_iface_desc ( alts ) -> bInterfaceNumber ; id = USB_ID ( le16_to_cpu ( dev -> descriptor . idVendor ) , le16_to_cpu ( dev -> descriptor . idProduct ) ) ; if ( get_alias_id ( dev , & id ) ) quirk = get_alias_quirk ( dev , id ) ; if ( quirk && quirk -> ifnum >= 0 && ifnum != quirk -> ifnum ) return - ENXIO ; err = snd_usb_apply_boot_quirk ( dev , intf , quirk , id ) ; if ( err < 0 ) return err ; chip = NULL ; mutex_lock ( & register_mutex ) ; for ( i = 0 ; i < SNDRV_CARDS ; i ++ ) { if ( usb_chip [ i ] && usb_chip [ i ] -> dev == dev ) { if ( atomic_read ( & usb_chip [ i ] -> shutdown ) ) { dev_err ( & dev -> dev , \"USB<S2SV_blank>device<S2SV_blank>is<S2SV_blank>in<S2SV_blank>the<S2SV_blank>shutdown<S2SV_blank>state,<S2SV_blank>cannot<S2SV_blank>create<S2SV_blank>a<S2SV_blank>card<S2SV_blank>instance\\\\n\" ) ; err = - EIO ; goto __error ; } chip = usb_chip [ i ] ; atomic_inc ( & chip -> active ) ; break ; } } if ( ! chip ) { for ( i = 0 ; i < SNDRV_CARDS ; i ++ ) if ( ! usb_chip [ i ] && ( vid [ i ] == - 1 || vid [ i ] == USB_ID_VENDOR ( id ) ) && ( pid [ i ] == - 1 || pid [ i ] == USB_ID_PRODUCT ( id ) ) ) { if ( enable [ i ] ) { err = snd_usb_audio_create ( intf , dev , i , quirk , id , & chip ) ; if ( err < 0 ) goto __error ; chip -> pm_intf = intf ; break ; } else if ( vid [ i ] != - 1 || pid [ i ] != - 1 ) { dev_info ( & dev -> dev , \"device<S2SV_blank>(%04x:%04x)<S2SV_blank>is<S2SV_blank>disabled\\\\n\" , USB_ID_VENDOR ( id ) , USB_ID_PRODUCT ( id ) ) ; err = - ENOENT ; goto __error ; } } if ( ! chip ) { dev_err ( & dev -> dev , \"no<S2SV_blank>available<S2SV_blank>usb<S2SV_blank>audio<S2SV_blank>device\\\\n\" ) ; err = - ENODEV ; goto __error ; } } dev_set_drvdata ( & dev -> dev , chip ) ; if ( ! chip -> ctrl_intf ) chip -> ctrl_intf = alts ; chip -> txfr_quirk = 0 ; err = 1 ; if ( quirk && quirk -> ifnum != QUIRK_NO_INTERFACE ) { err = snd_usb_create_quirk ( chip , intf , & usb_audio_driver , quirk ) ; if ( err < 0 ) goto __error ; } if ( err > 0 ) { err = snd_usb_create_streams ( chip , ifnum ) ; if ( err < 0 ) goto __error ; err = snd_usb_create_mixer ( chip , ifnum , ignore_ctl_error ) ; if ( err < 0 ) goto __error ; } err = snd_card_register ( chip -> card ) ; if ( err < 0 ) goto __error ; usb_chip [ chip -> index ] = chip ; chip -> num_interfaces ++ ; usb_set_intfdata ( intf , chip ) ; atomic_dec ( & chip -> active ) ; mutex_unlock ( & register_mutex ) ; return 0 ; __error : if ( chip ) { <S2SV_StartBug> if ( ! chip -> num_interfaces ) <S2SV_EndBug> snd_card_free ( chip -> card ) ; <S2SV_StartBug> atomic_dec ( & chip -> active ) ; <S2SV_EndBug> } mutex_unlock ( & register_mutex ) ; return err ; }\n","target":"<S2SV_ModStart> chip ) { atomic_dec ( & chip -> active ) ; <S2SV_ModStart> card ) ; <S2SV_ModEnd> } mutex_unlock (\n","project_and_commit_id":"torvalds@linux/5f8cf712582617d523120df67d392059eaf2fc4b","cve_id":"CVE-2018-19824","original_address":"https://github.com/torvalds/linux/commit/5f8cf712582617d523120df67d392059eaf2fc4b","time":"2018-12-03T17:29Z"},
	{"Unnamed: 0":1110,"cwe_id":"CWE-787","source":"CWE-787 static int sc_oberthur_read_file ( struct sc_pkcs15_card * p15card , const char * in_path , unsigned char * * out , size_t * out_len , int verify_pin ) { struct sc_context * ctx = p15card -> card -> ctx ; struct sc_card * card = p15card -> card ; struct sc_file * file = NULL ; struct sc_path path ; size_t sz ; int rv ; LOG_FUNC_CALLED ( ctx ) ; if ( ! in_path || ! out || ! out_len ) LOG_TEST_RET ( ctx , SC_ERROR_INVALID_ARGUMENTS , \"Cannot<S2SV_blank>read<S2SV_blank>oberthur<S2SV_blank>file\" ) ; sc_log ( ctx , \"read<S2SV_blank>file<S2SV_blank>\\'%s\\';<S2SV_blank>verify_pin:%i\" , in_path , verify_pin ) ; * out = NULL ; * out_len = 0 ; sc_format_path ( in_path , & path ) ; rv = sc_select_file ( card , & path , & file ) ; if ( rv != SC_SUCCESS ) { sc_file_free ( file ) ; LOG_TEST_RET ( ctx , rv , \"Cannot<S2SV_blank>select<S2SV_blank>oberthur<S2SV_blank>file<S2SV_blank>to<S2SV_blank>read\" ) ; } if ( file -> ef_structure == SC_FILE_EF_TRANSPARENT ) sz = file -> size ; else sz = ( file -> record_length + 2 ) * file -> record_count ; * out = calloc ( sz , 1 ) ; if ( * out == NULL ) { sc_file_free ( file ) ; LOG_TEST_RET ( ctx , SC_ERROR_OUT_OF_MEMORY , \"Cannot<S2SV_blank>read<S2SV_blank>oberthur<S2SV_blank>file\" ) ; } if ( file -> ef_structure == SC_FILE_EF_TRANSPARENT ) { rv = sc_read_binary ( card , 0 , * out , sz , 0 ) ; } else { <S2SV_StartBug> int rec ; <S2SV_EndBug> int offs = 0 ; <S2SV_StartBug> int rec_len = file -> record_length ; <S2SV_EndBug> <S2SV_StartBug> for ( rec = 1 ; ; rec ++ ) { <S2SV_EndBug> rv = sc_read_record ( card , rec , * out + offs + 2 , rec_len , SC_RECORD_BY_REC_NR ) ; if ( rv == SC_ERROR_RECORD_NOT_FOUND ) { rv = 0 ; break ; } else if ( rv < 0 ) { break ; } rec_len = rv ; * ( * out + offs ) = 'R' ; * ( * out + offs + 1 ) = rv ; offs += rv + 2 ; } sz = offs ; } sc_log ( ctx , \"read<S2SV_blank>oberthur<S2SV_blank>file<S2SV_blank>result<S2SV_blank>%i\" , rv ) ; if ( verify_pin && rv == SC_ERROR_SECURITY_STATUS_NOT_SATISFIED ) { struct sc_pkcs15_object * objs [ 0x10 ] , * pin_obj = NULL ; const struct sc_acl_entry * acl = sc_file_get_acl_entry ( file , SC_AC_OP_READ ) ; int ii ; rv = sc_pkcs15_get_objects ( p15card , SC_PKCS15_TYPE_AUTH_PIN , objs , 0x10 ) ; if ( rv != SC_SUCCESS ) { sc_file_free ( file ) ; LOG_TEST_RET ( ctx , rv , \"Cannot<S2SV_blank>read<S2SV_blank>oberthur<S2SV_blank>file:<S2SV_blank>get<S2SV_blank>AUTH<S2SV_blank>objects<S2SV_blank>error\" ) ; } for ( ii = 0 ; ii < rv ; ii ++ ) { struct sc_pkcs15_auth_info * auth_info = ( struct sc_pkcs15_auth_info * ) objs [ ii ] -> data ; sc_log ( ctx , \"compare<S2SV_blank>PIN/ACL<S2SV_blank>refs:%i/%i,<S2SV_blank>method:%i/%i\" , auth_info -> attrs . pin . reference , acl -> key_ref , auth_info -> auth_method , acl -> method ) ; if ( auth_info -> attrs . pin . reference == ( int ) acl -> key_ref && auth_info -> auth_method == ( unsigned ) acl -> method ) { pin_obj = objs [ ii ] ; break ; } } if ( ! pin_obj || ! pin_obj -> content . value ) { rv = SC_ERROR_SECURITY_STATUS_NOT_SATISFIED ; } else { rv = sc_pkcs15_verify_pin ( p15card , pin_obj , pin_obj -> content . value , pin_obj -> content . len ) ; if ( ! rv ) rv = sc_oberthur_read_file ( p15card , in_path , out , out_len , 0 ) ; } } ; sc_file_free ( file ) ; if ( rv < 0 ) { free ( * out ) ; * out = NULL ; * out_len = 0 ; } * out_len = sz ; LOG_FUNC_RETURN ( ctx , rv ) ; }\n","target":"<S2SV_ModStart> } else { size_t rec ; size_t <S2SV_ModEnd> offs = 0 <S2SV_ModStart> = 0 ; size_t <S2SV_ModEnd> rec_len = file <S2SV_ModStart> ++ ) { if ( rec > file -> record_count ) { rv = 0 ; break ; }\n","project_and_commit_id":"OpenSC@OpenSC/6903aebfddc466d966c7b865fae34572bf3ed23e","cve_id":"CVE-2020-26570","original_address":"https://github.com/OpenSC/OpenSC/commit/6903aebfddc466d966c7b865fae34572bf3ed23e","time":"2020-10-06T02:15Z"},
	{"Unnamed: 0":3555,"cwe_id":"CWE-119","source":"CWE-119 static void process_tree ( struct rev_info * revs , struct tree * tree , show_object_fn show , struct strbuf * base , const char * name , void * cb_data ) { struct object * obj = & tree -> object ; struct tree_desc desc ; struct name_entry entry ; enum interesting match = revs -> diffopt . pathspec . nr == 0 ? all_entries_interesting : entry_not_interesting ; int baselen = base -> len ; if ( ! revs -> tree_objects ) return ; if ( ! obj ) die ( \"bad<S2SV_blank>tree<S2SV_blank>object\" ) ; if ( obj -> flags & ( UNINTERESTING | SEEN ) ) return ; if ( parse_tree_gently ( tree , revs -> ignore_missing_links ) < 0 ) { if ( revs -> ignore_missing_links ) return ; die ( \"bad<S2SV_blank>tree<S2SV_blank>object<S2SV_blank>%s\" , oid_to_hex ( & obj -> oid ) ) ; } obj -> flags |= SEEN ; <S2SV_StartBug> show ( obj , base , name , cb_data ) ; <S2SV_EndBug> strbuf_addstr ( base , name ) ; if ( base -> len ) strbuf_addch ( base , '/' ) ; init_tree_desc ( & desc , tree -> buffer , tree -> size ) ; while ( tree_entry ( & desc , & entry ) ) { if ( match != all_entries_interesting ) { match = tree_entry_interesting ( & entry , base , 0 , & revs -> diffopt . pathspec ) ; if ( match == all_entries_not_interesting ) break ; if ( match == entry_not_interesting ) continue ; } if ( S_ISDIR ( entry . mode ) ) process_tree ( revs , lookup_tree ( entry . sha1 ) , show , base , entry . path , cb_data ) ; else if ( S_ISGITLINK ( entry . mode ) ) process_gitlink ( revs , entry . sha1 , show , base , entry . path , cb_data ) ; else process_blob ( revs , lookup_blob ( entry . sha1 ) , show , base , entry . path , cb_data ) ; } strbuf_setlen ( base , baselen ) ; free_tree_buffer ( tree ) ; }\n","target":"<S2SV_ModStart> |= SEEN ; strbuf_addstr ( base , name ) ; <S2SV_ModStart> obj , base -> buf , cb_data <S2SV_ModEnd> ) ; if\n","project_and_commit_id":"git@git/de1e67d0703894cb6ea782e36abb63976ab07e60","cve_id":"CVE-2016-2324","original_address":"https://github.com/git/git/commit/de1e67d0703894cb6ea782e36abb63976ab07e60","time":"2016-04-08T14:59Z"},
	{"Unnamed: 0":1613,"cwe_id":"CWE-000","source":"CWE-000 OM_uint32 kg_seal_iov ( OM_uint32 * minor_status , gss_ctx_id_t context_handle , int conf_req_flag , gss_qop_t qop_req , int * conf_state , gss_iov_buffer_desc * iov , int iov_count , int toktype ) { krb5_gss_ctx_id_rec * ctx ; krb5_error_code code ; krb5_context context ; if ( qop_req != 0 ) { * minor_status = ( OM_uint32 ) G_UNKNOWN_QOP ; return GSS_S_FAILURE ; } ctx = ( krb5_gss_ctx_id_rec * ) context_handle ; <S2SV_StartBug> if ( ! ctx -> established ) { <S2SV_EndBug> * minor_status = KG_CTX_INCOMPLETE ; return GSS_S_NO_CONTEXT ; } if ( conf_req_flag && kg_integ_only_iov ( iov , iov_count ) ) { conf_req_flag = FALSE ; } context = ctx -> k5_context ; switch ( ctx -> proto ) { case 0 : code = make_seal_token_v1_iov ( context , ctx , conf_req_flag , conf_state , iov , iov_count , toktype ) ; break ; case 1 : code = gss_krb5int_make_seal_token_v3_iov ( context , ctx , conf_req_flag , conf_state , iov , iov_count , toktype ) ; break ; default : code = G_UNKNOWN_QOP ; break ; } if ( code != 0 ) { * minor_status = code ; save_error_info ( * minor_status , context ) ; return GSS_S_FAILURE ; } * minor_status = 0 ; return GSS_S_COMPLETE ; }\n","target":"<S2SV_ModStart> ; if ( ctx -> terminated ||\n","project_and_commit_id":"krb5@krb5/82dc33da50338ac84c7b4102dc6513d897d0506a","cve_id":"CVE-2014-5352","original_address":"https://github.com/krb5/krb5/commit/82dc33da50338ac84c7b4102dc6513d897d0506a","time":"2015-02-19T11:59Z"},
	{"Unnamed: 0":4983,"cwe_id":"CWE-119","source":"CWE-119 int wasm_dis ( WasmOp * op , const unsigned char * buf , int buf_len ) { op -> len = 1 ; op -> op = buf [ 0 ] ; if ( op -> op > 0xbf ) { return 1 ; } WasmOpDef * opdef = & opcodes [ op -> op ] ; switch ( op -> op ) { case WASM_OP_TRAP : case WASM_OP_NOP : case WASM_OP_ELSE : case WASM_OP_RETURN : case WASM_OP_DROP : case WASM_OP_SELECT : case WASM_OP_I32EQZ : case WASM_OP_I32EQ : case WASM_OP_I32NE : case WASM_OP_I32LTS : case WASM_OP_I32LTU : case WASM_OP_I32GTS : case WASM_OP_I32GTU : case WASM_OP_I32LES : case WASM_OP_I32LEU : case WASM_OP_I32GES : case WASM_OP_I32GEU : case WASM_OP_I64EQZ : case WASM_OP_I64EQ : case WASM_OP_I64NE : case WASM_OP_I64LTS : case WASM_OP_I64LTU : case WASM_OP_I64GTS : case WASM_OP_I64GTU : case WASM_OP_I64LES : case WASM_OP_I64LEU : case WASM_OP_I64GES : case WASM_OP_I64GEU : case WASM_OP_F32EQ : case WASM_OP_F32NE : case WASM_OP_F32LT : case WASM_OP_F32GT : case WASM_OP_F32LE : case WASM_OP_F32GE : case WASM_OP_F64EQ : case WASM_OP_F64NE : case WASM_OP_F64LT : case WASM_OP_F64GT : case WASM_OP_F64LE : case WASM_OP_F64GE : case WASM_OP_I32CLZ : case WASM_OP_I32CTZ : case WASM_OP_I32POPCNT : case WASM_OP_I32ADD : case WASM_OP_I32SUB : case WASM_OP_I32MUL : case WASM_OP_I32DIVS : case WASM_OP_I32DIVU : case WASM_OP_I32REMS : case WASM_OP_I32REMU : case WASM_OP_I32AND : case WASM_OP_I32OR : case WASM_OP_I32XOR : case WASM_OP_I32SHL : case WASM_OP_I32SHRS : case WASM_OP_I32SHRU : case WASM_OP_I32ROTL : case WASM_OP_I32ROTR : case WASM_OP_I64CLZ : case WASM_OP_I64CTZ : case WASM_OP_I64POPCNT : case WASM_OP_I64ADD : case WASM_OP_I64SUB : case WASM_OP_I64MUL : case WASM_OP_I64DIVS : case WASM_OP_I64DIVU : case WASM_OP_I64REMS : case WASM_OP_I64REMU : case WASM_OP_I64AND : case WASM_OP_I64OR : case WASM_OP_I64XOR : case WASM_OP_I64SHL : case WASM_OP_I64SHRS : case WASM_OP_I64SHRU : case WASM_OP_I64ROTL : case WASM_OP_I64ROTR : case WASM_OP_F32ABS : case WASM_OP_F32NEG : case WASM_OP_F32CEIL : case WASM_OP_F32FLOOR : case WASM_OP_F32TRUNC : case WASM_OP_F32NEAREST : case WASM_OP_F32SQRT : case WASM_OP_F32ADD : case WASM_OP_F32SUB : case WASM_OP_F32MUL : case WASM_OP_F32DIV : case WASM_OP_F32MIN : case WASM_OP_F32MAX : case WASM_OP_F32COPYSIGN : case WASM_OP_F64ABS : case WASM_OP_F64NEG : case WASM_OP_F64CEIL : case WASM_OP_F64FLOOR : case WASM_OP_F64TRUNC : case WASM_OP_F64NEAREST : case WASM_OP_F64SQRT : case WASM_OP_F64ADD : case WASM_OP_F64SUB : case WASM_OP_F64MUL : case WASM_OP_F64DIV : case WASM_OP_F64MIN : case WASM_OP_F64MAX : case WASM_OP_F64COPYSIGN : case WASM_OP_I32WRAPI64 : case WASM_OP_I32TRUNCSF32 : case WASM_OP_I32TRUNCUF32 : case WASM_OP_I32TRUNCSF64 : case WASM_OP_I32TRUNCUF64 : case WASM_OP_I64EXTENDSI32 : case WASM_OP_I64EXTENDUI32 : case WASM_OP_I64TRUNCSF32 : case WASM_OP_I64TRUNCUF32 : case WASM_OP_I64TRUNCSF64 : case WASM_OP_I64TRUNCUF64 : case WASM_OP_F32CONVERTSI32 : case WASM_OP_F32CONVERTUI32 : case WASM_OP_F32CONVERTSI64 : case WASM_OP_F32CONVERTUI64 : case WASM_OP_F32DEMOTEF64 : case WASM_OP_F64CONVERTSI32 : case WASM_OP_F64CONVERTUI32 : case WASM_OP_F64CONVERTSI64 : case WASM_OP_F64CONVERTUI64 : case WASM_OP_F64PROMOTEF32 : case WASM_OP_I32REINTERPRETF32 : case WASM_OP_I64REINTERPRETF64 : case WASM_OP_F32REINTERPRETI32 : case WASM_OP_F64REINTERPRETI64 : case WASM_OP_END : { snprintf ( op -> txt , R_ASM_BUFSIZE , \"%s\" , opdef -> txt ) ; } break ; case WASM_OP_BLOCK : case WASM_OP_LOOP : case WASM_OP_IF : { st32 val = 0 ; size_t n = read_i32_leb128 ( buf + 1 , buf + buf_len , & val ) ; if ( ! ( n > 0 && n < buf_len ) ) goto err ; switch ( 0x80 - val ) { case R_BIN_WASM_VALUETYPE_EMPTY : snprintf ( op -> txt , R_ASM_BUFSIZE , \"%s\" , opdef -> txt ) ; break ; case R_BIN_WASM_VALUETYPE_i32 : snprintf ( op -> txt , R_ASM_BUFSIZE , \"%s<S2SV_blank>(result<S2SV_blank>i32)\" , opdef -> txt ) ; break ; case R_BIN_WASM_VALUETYPE_i64 : snprintf ( op -> txt , R_ASM_BUFSIZE , \"%s<S2SV_blank>(result<S2SV_blank>i64)\" , opdef -> txt ) ; break ; case R_BIN_WASM_VALUETYPE_f32 : snprintf ( op -> txt , R_ASM_BUFSIZE , \"%s<S2SV_blank>(result<S2SV_blank>f32)\" , opdef -> txt ) ; break ; case R_BIN_WASM_VALUETYPE_f64 : snprintf ( op -> txt , R_ASM_BUFSIZE , \"%s<S2SV_blank>(result<S2SV_blank>f64)\" , opdef -> txt ) ; break ; default : snprintf ( op -> txt , R_ASM_BUFSIZE , \"%s<S2SV_blank>(result<S2SV_blank>?)\" , opdef -> txt ) ; break ; } op -> len += n ; } break ; case WASM_OP_BR : case WASM_OP_BRIF : case WASM_OP_CALL : { ut32 val = 0 ; size_t n = read_u32_leb128 ( buf + 1 , buf + buf_len , & val ) ; if ( ! ( n > 0 && n < buf_len ) ) goto err ; snprintf ( op -> txt , R_ASM_BUFSIZE , \"%s<S2SV_blank>%d\" , opdef -> txt , val ) ; op -> len += n ; } break ; case WASM_OP_BRTABLE : { ut32 count = 0 , * table = NULL , def = 0 ; size_t n = read_u32_leb128 ( buf + 1 , buf + buf_len , & count ) ; if ( ! ( n > 0 && n < buf_len ) ) { goto err ; } if ( ! ( table = calloc ( count , sizeof ( ut32 ) ) ) ) { goto err ; } int i = 0 ; op -> len += n ; for ( i = 0 ; i < count ; i ++ ) { n = read_u32_leb128 ( buf + op -> len , buf + buf_len , & table [ i ] ) ; if ( ! ( op -> len + n <= buf_len ) ) { goto beach ; } op -> len += n ; } n = read_u32_leb128 ( buf + op -> len , buf + buf_len , & def ) ; if ( ! ( n > 0 && n + op -> len < buf_len ) ) { goto beach ; } op -> len += n ; snprintf ( op -> txt , R_ASM_BUFSIZE , \"%s<S2SV_blank>%d<S2SV_blank>\" , opdef -> txt , count ) ; <S2SV_StartBug> for ( i = 0 ; i < count && strlen ( op -> txt ) + 10 < R_ASM_BUFSIZE ; i ++ ) { <S2SV_EndBug> <S2SV_StartBug> int optxtlen = strlen ( op -> txt ) ; <S2SV_EndBug> snprintf ( op -> txt + optxtlen , R_ASM_BUFSIZE - optxtlen , \"%d<S2SV_blank>\" , table [ i ] ) ; <S2SV_StartBug> } <S2SV_EndBug> <S2SV_StartBug> snprintf ( op -> txt + strlen ( op -> txt ) , R_ASM_BUFSIZE , \"%d\" , def ) ; <S2SV_EndBug> free ( table ) ; break ; beach : free ( table ) ; goto err ; } break ; case WASM_OP_CALLINDIRECT : { ut32 val = 0 , reserved = 0 ; size_t n = read_u32_leb128 ( buf + 1 , buf + buf_len , & val ) ; if ( ! ( n > 0 && n < buf_len ) ) goto err ; op -> len += n ; n = read_u32_leb128 ( buf + op -> len , buf + buf_len , & reserved ) ; if ( ! ( n == 1 && op -> len + n <= buf_len ) ) goto err ; reserved &= 0x1 ; snprintf ( op -> txt , R_ASM_BUFSIZE , \"%s<S2SV_blank>%d<S2SV_blank>%d\" , opdef -> txt , val , reserved ) ; op -> len += n ; } break ; case WASM_OP_GETLOCAL : case WASM_OP_SETLOCAL : case WASM_OP_TEELOCAL : case WASM_OP_GETGLOBAL : case WASM_OP_SETGLOBAL : { ut32 val = 0 ; size_t n = read_u32_leb128 ( buf + 1 , buf + buf_len , & val ) ; if ( ! ( n > 0 && n < buf_len ) ) goto err ; snprintf ( op -> txt , R_ASM_BUFSIZE , \"%s<S2SV_blank>%d\" , opdef -> txt , val ) ; op -> len += n ; } break ; case WASM_OP_I32LOAD : case WASM_OP_I64LOAD : case WASM_OP_F32LOAD : case WASM_OP_F64LOAD : case WASM_OP_I32LOAD8S : case WASM_OP_I32LOAD8U : case WASM_OP_I32LOAD16S : case WASM_OP_I32LOAD16U : case WASM_OP_I64LOAD8S : case WASM_OP_I64LOAD8U : case WASM_OP_I64LOAD16S : case WASM_OP_I64LOAD16U : case WASM_OP_I64LOAD32S : case WASM_OP_I64LOAD32U : case WASM_OP_I32STORE : case WASM_OP_I64STORE : case WASM_OP_F32STORE : case WASM_OP_F64STORE : case WASM_OP_I32STORE8 : case WASM_OP_I32STORE16 : case WASM_OP_I64STORE8 : case WASM_OP_I64STORE16 : case WASM_OP_I64STORE32 : { ut32 flag = 0 , offset = 0 ; size_t n = read_u32_leb128 ( buf + 1 , buf + buf_len , & flag ) ; if ( ! ( n > 0 && n < buf_len ) ) goto err ; op -> len += n ; n = read_u32_leb128 ( buf + op -> len , buf + buf_len , & offset ) ; if ( ! ( n > 0 && op -> len + n <= buf_len ) ) goto err ; snprintf ( op -> txt , R_ASM_BUFSIZE , \"%s<S2SV_blank>%d<S2SV_blank>%d\" , opdef -> txt , flag , offset ) ; op -> len += n ; } break ; case WASM_OP_CURRENTMEMORY : case WASM_OP_GROWMEMORY : { ut32 reserved = 0 ; size_t n = read_u32_leb128 ( buf + 1 , buf + buf_len , & reserved ) ; if ( ! ( n == 1 && n < buf_len ) ) goto err ; reserved &= 0x1 ; snprintf ( op -> txt , R_ASM_BUFSIZE , \"%s<S2SV_blank>%d\" , opdef -> txt , reserved ) ; op -> len += n ; } break ; case WASM_OP_I32CONST : { st32 val = 0 ; size_t n = read_i32_leb128 ( buf + 1 , buf + buf_len , & val ) ; if ( ! ( n > 0 && n < buf_len ) ) goto err ; snprintf ( op -> txt , R_ASM_BUFSIZE , \"%s<S2SV_blank>%\" PFMT32d , opdef -> txt , val ) ; op -> len += n ; } break ; case WASM_OP_I64CONST : { st64 val = 0 ; size_t n = read_i64_leb128 ( buf + 1 , buf + buf_len , & val ) ; if ( ! ( n > 0 && n < buf_len ) ) goto err ; snprintf ( op -> txt , R_ASM_BUFSIZE , \"%s<S2SV_blank>%\" PFMT64d , opdef -> txt , val ) ; op -> len += n ; } break ; case WASM_OP_F32CONST : { ut32 val = 0 ; size_t n = read_u32_leb128 ( buf + 1 , buf + buf_len , & val ) ; if ( ! ( n > 0 && n < buf_len ) ) goto err ; long double d = ( long double ) val ; snprintf ( op -> txt , R_ASM_BUFSIZE , \"%s<S2SV_blank>%\" LDBLFMT , opdef -> txt , d ) ; op -> len += n ; } break ; case WASM_OP_F64CONST : { ut64 val = 0 ; size_t n = read_u64_leb128 ( buf + 1 , buf + buf_len , & val ) ; if ( ! ( n > 0 && n < buf_len ) ) goto err ; long double d = ( long double ) val ; snprintf ( op -> txt , R_ASM_BUFSIZE , \"%s<S2SV_blank>%\" LDBLFMT , opdef -> txt , d ) ; op -> len += n ; } break ; default : goto err ; } return op -> len ; err : op -> len = 1 ; snprintf ( op -> txt , R_ASM_BUFSIZE , \"invalid\" ) ; return op -> len ; }\n","target":"<S2SV_ModStart> count ) ; char * txt = op -> txt ; int txtLen = strlen ( op -> txt ) ; int txtLeft = R_ASM_BUFSIZE - txtLen ; txt += txtLen ; <S2SV_ModStart> < count && txtLen <S2SV_ModEnd> + 10 < <S2SV_ModStart> ++ ) { snprintf ( txt , txtLeft <S2SV_ModEnd> , \"%d<S2SV_blank>\" , <S2SV_ModStart> ] ) ; txtLen = strlen ( txt ) ; txt += txtLen ; txtLeft -= txtLen ; <S2SV_ModStart> } snprintf ( txt , txtLeft - 1 <S2SV_ModEnd> , \"%d\" ,\n","project_and_commit_id":"radare@radare2/bd276ef2fd8ac3401e65be7c126a43175ccfbcd7","cve_id":"CVE-2018-11378","original_address":"https://github.com/radare/radare2/commit/bd276ef2fd8ac3401e65be7c126a43175ccfbcd7","time":"2018-05-22T19:29Z"},
	{"Unnamed: 0":1869,"cwe_id":"CWE-000","source":"CWE-000 static PyObject * get_value ( PyObject * self , const char * buffer , int * position , int type , int max , PyObject * as_class , unsigned char tz_aware , unsigned char uuid_subtype ) { struct module_state * state = GETSTATE ( self ) ; PyObject * value ; PyObject * error ; switch ( type ) { case 1 : { double d ; if ( max < 8 ) { goto invalid ; } memcpy ( & d , buffer + * position , 8 ) ; value = PyFloat_FromDouble ( d ) ; if ( ! value ) { return NULL ; } * position += 8 ; break ; } case 2 : case 14 : { int value_length = ( ( int * ) ( buffer + * position ) ) [ 0 ] - 1 ; if ( max < value_length ) { goto invalid ; } * position += 4 ; value = PyUnicode_DecodeUTF8 ( buffer + * position , value_length , \"strict\" ) ; if ( ! value ) { return NULL ; } * position += value_length + 1 ; break ; } case 3 : { int size ; memcpy ( & size , buffer + * position , 4 ) ; if ( max < size ) { goto invalid ; } value = elements_to_dict ( self , buffer + * position + 4 , size - 5 , as_class , tz_aware , uuid_subtype ) ; if ( ! value ) { return NULL ; } if ( strcmp ( buffer + * position + 5 , \"$ref\" ) == 0 ) { PyObject * dbref ; PyObject * collection = PyDict_GetItemString ( value , \"$ref\" ) ; PyObject * id = PyDict_GetItemString ( value , \"$id\" ) ; PyObject * database = PyDict_GetItemString ( value , \"$db\" ) ; Py_INCREF ( collection ) ; PyDict_DelItemString ( value , \"$ref\" ) ; <S2SV_StartBug> Py_INCREF ( id ) ; <S2SV_EndBug> <S2SV_StartBug> PyDict_DelItemString ( value , \"$id\" ) ; <S2SV_EndBug> if ( database == NULL ) { database = Py_None ; Py_INCREF ( database ) ; } else { Py_INCREF ( database ) ; PyDict_DelItemString ( value , \"$db\" ) ; } dbref = PyObject_CallFunctionObjArgs ( state -> DBRef , collection , id , database , value , NULL ) ; Py_DECREF ( value ) ; value = dbref ; Py_DECREF ( id ) ; Py_DECREF ( collection ) ; Py_DECREF ( database ) ; if ( ! value ) { return NULL ; } } * position += size ; break ; } case 4 : { int size , end ; memcpy ( & size , buffer + * position , 4 ) ; if ( max < size ) { goto invalid ; } end = * position + size - 1 ; * position += 4 ; value = PyList_New ( 0 ) ; if ( ! value ) { return NULL ; } while ( * position < end ) { PyObject * to_append ; int type = ( int ) buffer [ ( * position ) ++ ] ; int key_size = strlen ( buffer + * position ) ; * position += key_size + 1 ; to_append = get_value ( self , buffer , position , type , max - key_size , as_class , tz_aware , uuid_subtype ) ; if ( ! to_append ) { Py_DECREF ( value ) ; return NULL ; } PyList_Append ( value , to_append ) ; Py_DECREF ( to_append ) ; } ( * position ) ++ ; break ; } case 5 : { PyObject * data ; PyObject * st ; int length , subtype ; memcpy ( & length , buffer + * position , 4 ) ; if ( max < length ) { goto invalid ; } subtype = ( unsigned char ) buffer [ * position + 4 ] ; # if PY_MAJOR_VERSION >= 3 if ( subtype == 0 ) { value = PyBytes_FromStringAndSize ( buffer + * position + 5 , length ) ; * position += length + 5 ; break ; } if ( subtype == 2 ) { data = PyBytes_FromStringAndSize ( buffer + * position + 9 , length - 4 ) ; } else { data = PyBytes_FromStringAndSize ( buffer + * position + 5 , length ) ; } # else if ( subtype == 2 ) { data = PyString_FromStringAndSize ( buffer + * position + 9 , length - 4 ) ; } else { data = PyString_FromStringAndSize ( buffer + * position + 5 , length ) ; } # endif if ( ! data ) { return NULL ; } if ( ( subtype == 3 || subtype == 4 ) && state -> UUID ) { PyObject * kwargs ; PyObject * args = PyTuple_New ( 0 ) ; if ( ! args ) { Py_DECREF ( data ) ; return NULL ; } kwargs = PyDict_New ( ) ; if ( ! kwargs ) { Py_DECREF ( data ) ; Py_DECREF ( args ) ; return NULL ; } assert ( length == 16 ) ; if ( uuid_subtype == CSHARP_LEGACY ) { PyDict_SetItemString ( kwargs , \"bytes_le\" , data ) ; } else { if ( uuid_subtype == JAVA_LEGACY ) { char big_endian [ 16 ] ; _fix_java ( buffer + * position + 5 , big_endian ) ; Py_DECREF ( data ) ; # if PY_MAJOR_VERSION >= 3 data = PyBytes_FromStringAndSize ( big_endian , length ) ; # else data = PyString_FromStringAndSize ( big_endian , length ) ; # endif } PyDict_SetItemString ( kwargs , \"bytes\" , data ) ; } value = PyObject_Call ( state -> UUID , args , kwargs ) ; Py_DECREF ( args ) ; Py_DECREF ( kwargs ) ; Py_DECREF ( data ) ; if ( ! value ) { return NULL ; } * position += length + 5 ; break ; } # if PY_MAJOR_VERSION >= 3 st = PyLong_FromLong ( subtype ) ; # else st = PyInt_FromLong ( subtype ) ; # endif if ( ! st ) { Py_DECREF ( data ) ; return NULL ; } value = PyObject_CallFunctionObjArgs ( state -> Binary , data , st , NULL ) ; Py_DECREF ( st ) ; Py_DECREF ( data ) ; if ( ! value ) { return NULL ; } * position += length + 5 ; break ; } case 6 : case 10 : { value = Py_None ; Py_INCREF ( value ) ; break ; } case 7 : { if ( max < 12 ) { goto invalid ; } # if PY_MAJOR_VERSION >= 3 value = PyObject_CallFunction ( state -> ObjectId , \"y#\" , buffer + * position , 12 ) ; # else value = PyObject_CallFunction ( state -> ObjectId , \"s#\" , buffer + * position , 12 ) ; # endif if ( ! value ) { return NULL ; } * position += 12 ; break ; } case 8 : { value = buffer [ ( * position ) ++ ] ? Py_True : Py_False ; Py_INCREF ( value ) ; break ; } case 9 : { PyObject * naive ; PyObject * replace ; PyObject * args ; PyObject * kwargs ; if ( max < 8 ) { goto invalid ; } naive = datetime_from_millis ( * ( long long * ) ( buffer + * position ) ) ; * position += 8 ; if ( ! tz_aware ) { value = naive ; break ; } if ( ! naive ) { return NULL ; } replace = PyObject_GetAttrString ( naive , \"replace\" ) ; Py_DECREF ( naive ) ; if ( ! replace ) { return NULL ; } args = PyTuple_New ( 0 ) ; if ( ! args ) { Py_DECREF ( replace ) ; return NULL ; } kwargs = PyDict_New ( ) ; if ( ! kwargs ) { Py_DECREF ( replace ) ; Py_DECREF ( args ) ; return NULL ; } if ( PyDict_SetItemString ( kwargs , \"tzinfo\" , state -> UTC ) == - 1 ) { Py_DECREF ( replace ) ; Py_DECREF ( args ) ; Py_DECREF ( kwargs ) ; return NULL ; } value = PyObject_Call ( replace , args , kwargs ) ; Py_DECREF ( replace ) ; Py_DECREF ( args ) ; Py_DECREF ( kwargs ) ; break ; } case 11 : { PyObject * pattern ; int flags_length , flags , i ; int pattern_length = strlen ( buffer + * position ) ; if ( max < pattern_length ) { goto invalid ; } pattern = PyUnicode_DecodeUTF8 ( buffer + * position , pattern_length , \"strict\" ) ; if ( ! pattern ) { return NULL ; } * position += pattern_length + 1 ; flags_length = strlen ( buffer + * position ) ; if ( max < pattern_length + flags_length ) { Py_DECREF ( pattern ) ; goto invalid ; } flags = 0 ; for ( i = 0 ; i < flags_length ; i ++ ) { if ( buffer [ * position + i ] == 'i' ) { flags |= 2 ; } else if ( buffer [ * position + i ] == 'l' ) { flags |= 4 ; } else if ( buffer [ * position + i ] == 'm' ) { flags |= 8 ; } else if ( buffer [ * position + i ] == 's' ) { flags |= 16 ; } else if ( buffer [ * position + i ] == 'u' ) { flags |= 32 ; } else if ( buffer [ * position + i ] == 'x' ) { flags |= 64 ; } } * position += flags_length + 1 ; value = PyObject_CallFunction ( state -> RECompile , \"Oi\" , pattern , flags ) ; Py_DECREF ( pattern ) ; break ; } case 12 : { int collection_length ; PyObject * collection ; PyObject * id ; * position += 4 ; collection_length = strlen ( buffer + * position ) ; if ( max < collection_length ) { goto invalid ; } collection = PyUnicode_DecodeUTF8 ( buffer + * position , collection_length , \"strict\" ) ; if ( ! collection ) { return NULL ; } * position += collection_length + 1 ; if ( max < collection_length + 12 ) { Py_DECREF ( collection ) ; goto invalid ; } id = PyObject_CallFunction ( state -> ObjectId , \"s#\" , buffer + * position , 12 ) ; if ( ! id ) { Py_DECREF ( collection ) ; return NULL ; } * position += 12 ; value = PyObject_CallFunctionObjArgs ( state -> DBRef , collection , id , NULL ) ; Py_DECREF ( collection ) ; Py_DECREF ( id ) ; break ; } case 13 : { PyObject * code ; int value_length = ( ( int * ) ( buffer + * position ) ) [ 0 ] - 1 ; if ( max < value_length ) { goto invalid ; } * position += 4 ; code = PyUnicode_DecodeUTF8 ( buffer + * position , value_length , \"strict\" ) ; if ( ! code ) { return NULL ; } * position += value_length + 1 ; value = PyObject_CallFunctionObjArgs ( state -> Code , code , NULL , NULL ) ; Py_DECREF ( code ) ; break ; } case 15 : { int code_length , scope_size ; PyObject * code ; PyObject * scope ; * position += 8 ; code_length = strlen ( buffer + * position ) ; if ( max < 8 + code_length ) { goto invalid ; } code = PyUnicode_DecodeUTF8 ( buffer + * position , code_length , \"strict\" ) ; if ( ! code ) { return NULL ; } * position += code_length + 1 ; memcpy ( & scope_size , buffer + * position , 4 ) ; scope = elements_to_dict ( self , buffer + * position + 4 , scope_size - 5 , ( PyObject * ) & PyDict_Type , tz_aware , uuid_subtype ) ; if ( ! scope ) { Py_DECREF ( code ) ; return NULL ; } * position += scope_size ; value = PyObject_CallFunctionObjArgs ( state -> Code , code , scope , NULL ) ; Py_DECREF ( code ) ; Py_DECREF ( scope ) ; break ; } case 16 : { int i ; if ( max < 4 ) { goto invalid ; } memcpy ( & i , buffer + * position , 4 ) ; # if PY_MAJOR_VERSION >= 3 value = PyLong_FromLong ( i ) ; # else value = PyInt_FromLong ( i ) ; # endif if ( ! value ) { return NULL ; } * position += 4 ; break ; } case 17 : { unsigned int time , inc ; if ( max < 8 ) { goto invalid ; } memcpy ( & inc , buffer + * position , 4 ) ; memcpy ( & time , buffer + * position + 4 , 4 ) ; value = PyObject_CallFunction ( state -> Timestamp , \"II\" , time , inc ) ; if ( ! value ) { return NULL ; } * position += 8 ; break ; } case 18 : { long long ll ; if ( max < 8 ) { goto invalid ; } memcpy ( & ll , buffer + * position , 8 ) ; value = PyLong_FromLongLong ( ll ) ; if ( ! value ) { return NULL ; } * position += 8 ; break ; } case - 1 : { value = PyObject_CallFunctionObjArgs ( state -> MinKey , NULL ) ; break ; } case 127 : { value = PyObject_CallFunctionObjArgs ( state -> MaxKey , NULL ) ; break ; } default : { PyObject * InvalidDocument = _error ( \"InvalidDocument\" ) ; PyErr_SetString ( InvalidDocument , \"no<S2SV_blank>c<S2SV_blank>decoder<S2SV_blank>for<S2SV_blank>this<S2SV_blank>type<S2SV_blank>yet\" ) ; Py_DECREF ( InvalidDocument ) ; return NULL ; } } return value ; invalid : error = _error ( \"InvalidBSON\" ) ; PyErr_SetNone ( error ) ; Py_DECREF ( error ) ; return NULL ; }\n","target":"<S2SV_ModStart> \"$ref\" ) ; if ( id == NULL ) { id = Py_None ; <S2SV_ModStart> id ) ; } else { Py_INCREF ( id ) ; <S2SV_ModStart> \"$id\" ) ; }\n","project_and_commit_id":"mongodb@mongo-python-driver/a060c15ef87e0f0e72974c7c0e57fe811bbd06a2","cve_id":"CVE-2013-2132","original_address":"https://github.com/mongodb/mongo-python-driver/commit/a060c15ef87e0f0e72974c7c0e57fe811bbd06a2","time":"2013-08-15T17:55Z"},
	{"Unnamed: 0":5968,"cwe_id":"CWE-399","source":"CWE-399 <S2SV_StartBug> void ptrace_triggered ( struct perf_event * bp , int nmi , <S2SV_EndBug> struct perf_sample_data * data , struct pt_regs * regs ) { struct perf_event_attr attr ; attr = bp -> attr ; attr . disabled = true ; modify_user_hw_breakpoint ( bp , & attr ) ; }\n","target":"<S2SV_ModStart> perf_event * bp <S2SV_ModEnd> , struct perf_sample_data\n","project_and_commit_id":"torvalds@linux/a8b0ca17b80e92faab46ee7179ba9e99ccb61233","cve_id":"CVE-2011-2918","original_address":"https://github.com/torvalds/linux/commit/a8b0ca17b80e92faab46ee7179ba9e99ccb61233","time":"2012-05-24T23:55Z"},
	{"Unnamed: 0":4727,"cwe_id":"CWE-476","source":"CWE-476 static int inet_rtm_getroute ( struct sk_buff * in_skb , struct nlmsghdr * nlh , struct netlink_ext_ack * extack ) { struct net * net = sock_net ( in_skb -> sk ) ; struct rtmsg * rtm ; struct nlattr * tb [ RTA_MAX + 1 ] ; struct fib_result res = { } ; struct rtable * rt = NULL ; struct flowi4 fl4 ; __be32 dst = 0 ; __be32 src = 0 ; u32 iif ; int err ; int mark ; struct sk_buff * skb ; u32 table_id = RT_TABLE_MAIN ; kuid_t uid ; err = nlmsg_parse ( nlh , sizeof ( * rtm ) , tb , RTA_MAX , rtm_ipv4_policy , extack ) ; if ( err < 0 ) goto errout ; rtm = nlmsg_data ( nlh ) ; skb = alloc_skb ( NLMSG_GOODSIZE , GFP_KERNEL ) ; if ( ! skb ) { err = - ENOBUFS ; goto errout ; } skb_reset_mac_header ( skb ) ; skb_reset_network_header ( skb ) ; src = tb [ RTA_SRC ] ? nla_get_in_addr ( tb [ RTA_SRC ] ) : 0 ; dst = tb [ RTA_DST ] ? nla_get_in_addr ( tb [ RTA_DST ] ) : 0 ; iif = tb [ RTA_IIF ] ? nla_get_u32 ( tb [ RTA_IIF ] ) : 0 ; mark = tb [ RTA_MARK ] ? nla_get_u32 ( tb [ RTA_MARK ] ) : 0 ; if ( tb [ RTA_UID ] ) uid = make_kuid ( current_user_ns ( ) , nla_get_u32 ( tb [ RTA_UID ] ) ) ; else uid = ( iif ? INVALID_UID : current_uid ( ) ) ; ip_hdr ( skb ) -> protocol = IPPROTO_UDP ; ip_hdr ( skb ) -> saddr = src ; ip_hdr ( skb ) -> daddr = dst ; skb_reserve ( skb , MAX_HEADER + sizeof ( struct iphdr ) ) ; memset ( & fl4 , 0 , sizeof ( fl4 ) ) ; fl4 . daddr = dst ; fl4 . saddr = src ; fl4 . flowi4_tos = rtm -> rtm_tos ; fl4 . flowi4_oif = tb [ RTA_OIF ] ? nla_get_u32 ( tb [ RTA_OIF ] ) : 0 ; fl4 . flowi4_mark = mark ; fl4 . flowi4_uid = uid ; rcu_read_lock ( ) ; if ( iif ) { struct net_device * dev ; dev = dev_get_by_index_rcu ( net , iif ) ; if ( ! dev ) { err = - ENODEV ; goto errout_free ; } skb -> protocol = htons ( ETH_P_IP ) ; skb -> dev = dev ; skb -> mark = mark ; err = ip_route_input_rcu ( skb , dst , src , rtm -> rtm_tos , dev , & res ) ; rt = skb_rtable ( skb ) ; if ( err == 0 && rt -> dst . error ) err = - rt -> dst . error ; } else { rt = ip_route_output_key_hash_rcu ( net , & fl4 , & res , skb ) ; err = 0 ; if ( IS_ERR ( rt ) ) err = PTR_ERR ( rt ) ; else skb_dst_set ( skb , & rt -> dst ) ; } if ( err ) goto errout_free ; if ( rtm -> rtm_flags & RTM_F_NOTIFY ) rt -> rt_flags |= RTCF_NOTIFY ; if ( rtm -> rtm_flags & RTM_F_LOOKUP_TABLE ) table_id = rt -> rt_table_id ; if ( rtm -> rtm_flags & RTM_F_FIB_MATCH ) <S2SV_StartBug> err = fib_dump_info ( skb , NETLINK_CB ( in_skb ) . portid , <S2SV_EndBug> nlh -> nlmsg_seq , RTM_NEWROUTE , table_id , rt -> rt_type , res . prefix , res . prefixlen , fl4 . flowi4_tos , res . fi , 0 ) ; else err = rt_fill_info ( net , dst , src , table_id , & fl4 , skb , NETLINK_CB ( in_skb ) . portid , nlh -> nlmsg_seq ) ; if ( err < 0 ) goto errout_free ; <S2SV_StartBug> rcu_read_unlock ( ) ; <S2SV_EndBug> err = rtnl_unicast ( skb , net , NETLINK_CB ( in_skb ) . portid ) ; errout : return err ; errout_free : rcu_read_unlock ( ) ; kfree_skb ( skb ) ; goto errout ; }\n","target":"<S2SV_ModStart> & RTM_F_FIB_MATCH ) { if ( ! res . fi ) { err = fib_props [ res . type ] . error ; if ( ! err ) err = - EHOSTUNREACH ; <S2SV_ModEnd> goto errout_free ; <S2SV_ModStart> goto errout_free ; } err = fib_dump_info ( skb , NETLINK_CB ( in_skb ) . portid , nlh -> nlmsg_seq , RTM_NEWROUTE , table_id , rt -> rt_type , res . prefix , res . prefixlen , fl4 . flowi4_tos , res . fi , 0 ) ; } else { err = rt_fill_info ( net , dst , src , table_id , & fl4 , skb , NETLINK_CB ( in_skb ) . portid , nlh -> nlmsg_seq ) ; } if ( err < 0 ) goto errout_free ;\n","project_and_commit_id":"torvalds@linux/bc3aae2bbac46dd894c89db5d5e98f7f0ef9e205","cve_id":"CVE-2017-13686","original_address":"https://github.com/torvalds/linux/commit/bc3aae2bbac46dd894c89db5d5e98f7f0ef9e205","time":"2017-08-24T22:29Z"},
	{"Unnamed: 0":4623,"cwe_id":"CWE-189","source":"CWE-189 int i915_gem_execbuffer2 ( struct drm_device * dev , void * data , struct drm_file * file ) { struct drm_i915_gem_execbuffer2 * args = data ; struct drm_i915_gem_exec_object2 * exec2_list = NULL ; int ret ; <S2SV_StartBug> if ( args -> buffer_count < 1 ) { <S2SV_EndBug> DRM_DEBUG ( \"execbuf2<S2SV_blank>with<S2SV_blank>%d<S2SV_blank>buffers\\\\n\" , args -> buffer_count ) ; return - EINVAL ; } exec2_list = kmalloc ( sizeof ( * exec2_list ) * args -> buffer_count , GFP_KERNEL | __GFP_NOWARN | __GFP_NORETRY ) ; if ( exec2_list == NULL ) exec2_list = drm_malloc_ab ( sizeof ( * exec2_list ) , args -> buffer_count ) ; if ( exec2_list == NULL ) { DRM_DEBUG ( \"Failed<S2SV_blank>to<S2SV_blank>allocate<S2SV_blank>exec<S2SV_blank>list<S2SV_blank>for<S2SV_blank>%d<S2SV_blank>buffers\\\\n\" , args -> buffer_count ) ; return - ENOMEM ; } ret = copy_from_user ( exec2_list , ( struct drm_i915_relocation_entry __user * ) ( uintptr_t ) args -> buffers_ptr , sizeof ( * exec2_list ) * args -> buffer_count ) ; if ( ret != 0 ) { DRM_DEBUG ( \"copy<S2SV_blank>%d<S2SV_blank>exec<S2SV_blank>entries<S2SV_blank>failed<S2SV_blank>%d\\\\n\" , args -> buffer_count , ret ) ; drm_free_large ( exec2_list ) ; return - EFAULT ; } ret = i915_gem_do_execbuffer ( dev , data , file , args , exec2_list ) ; if ( ! ret ) { ret = copy_to_user ( ( struct drm_i915_relocation_entry __user * ) ( uintptr_t ) args -> buffers_ptr , exec2_list , sizeof ( * exec2_list ) * args -> buffer_count ) ; if ( ret ) { ret = - EFAULT ; DRM_DEBUG ( \"failed<S2SV_blank>to<S2SV_blank>copy<S2SV_blank>%d<S2SV_blank>exec<S2SV_blank>entries<S2SV_blank>\" \"back<S2SV_blank>to<S2SV_blank>user<S2SV_blank>(%d)\\\\n\" , args -> buffer_count , ret ) ; } } drm_free_large ( exec2_list ) ; return ret ; }\n","target":"<S2SV_ModStart> buffer_count < 1 || args -> buffer_count > UINT_MAX / sizeof ( * exec2_list )\n","project_and_commit_id":"torvalds@linux/ed8cd3b2cd61004cab85380c52b1817aca1ca49b","cve_id":"CVE-2012-2383","original_address":"https://github.com/torvalds/linux/commit/ed8cd3b2cd61004cab85380c52b1817aca1ca49b","time":"2012-06-13T10:24Z"},
	{"Unnamed: 0":2851,"cwe_id":"CWE-399","source":"CWE-399 static int kvm_set_guest_paused ( struct kvm_vcpu * vcpu ) { <S2SV_StartBug> if ( ! vcpu -> arch . time_page ) <S2SV_EndBug> return - EINVAL ; vcpu -> arch . pvclock_set_guest_stopped_request = true ; kvm_make_request ( KVM_REQ_CLOCK_UPDATE , vcpu ) ; return 0 ; }\n","target":"<S2SV_ModStart> -> arch . pv_time_enabled <S2SV_ModEnd> ) return -\n","project_and_commit_id":"torvalds@linux/0b79459b482e85cb7426aa7da683a9f2c97aeae1","cve_id":"CVE-2013-1797","original_address":"https://github.com/torvalds/linux/commit/0b79459b482e85cb7426aa7da683a9f2c97aeae1","time":"2013-03-22T11:59Z"},
	{"Unnamed: 0":5062,"cwe_id":"CWE-189","source":"CWE-189 static u32 apic_get_tmcct ( struct kvm_lapic * apic ) { ktime_t remaining ; s64 ns ; u32 tmcct ; ASSERT ( apic != NULL ) ; <S2SV_StartBug> if ( kvm_apic_get_reg ( apic , APIC_TMICT ) == 0 ) <S2SV_EndBug> return 0 ; remaining = hrtimer_get_remaining ( & apic -> lapic_timer . timer ) ; if ( ktime_to_ns ( remaining ) < 0 ) remaining = ktime_set ( 0 , 0 ) ; ns = mod_64 ( ktime_to_ns ( remaining ) , apic -> lapic_timer . period ) ; tmcct = div64_u64 ( ns , ( APIC_BUS_CYCLE_NS * apic -> divide_count ) ) ; return tmcct ; }\n","target":"<S2SV_ModStart> , APIC_TMICT ) == 0 || apic -> lapic_timer . period\n","project_and_commit_id":"torvalds@linux/b963a22e6d1a266a67e9eecc88134713fd54775c","cve_id":"CVE-2013-6367","original_address":"https://github.com/torvalds/linux/commit/b963a22e6d1a266a67e9eecc88134713fd54775c","time":"2013-12-14T18:08Z"},
	{"Unnamed: 0":2509,"cwe_id":"CWE-264","source":"CWE-264 static int <S2SV_StartBug> validate_event ( struct pmu_hw_events * hw_events , <S2SV_EndBug> struct perf_event * event ) { <S2SV_StartBug> struct arm_pmu * armpmu = to_arm_pmu ( event -> pmu ) ; <S2SV_EndBug> struct hw_perf_event fake_event = event -> hw ; struct pmu * leader_pmu = event -> group_leader -> pmu ; if ( is_software_event ( event ) ) return 1 ; <S2SV_StartBug> if ( event -> pmu != leader_pmu || event -> state < PERF_EVENT_STATE_OFF ) <S2SV_EndBug> return 1 ; if ( event -> state == PERF_EVENT_STATE_OFF && ! event -> attr . enable_on_exec ) return 1 ; <S2SV_StartBug> return armpmu -> get_event_idx ( hw_events , & fake_event ) >= 0 ; <S2SV_EndBug> }\n","target":"<S2SV_ModStart> int validate_event ( struct pmu * pmu , <S2SV_ModStart> arm_pmu * armpmu <S2SV_ModEnd> ; struct hw_perf_event <S2SV_ModStart> -> pmu != pmu ) return 0 ; if ( event -> pmu != <S2SV_ModStart> return 1 ; armpmu = to_arm_pmu ( event -> pmu ) ;\n","project_and_commit_id":"torvalds@linux/8fff105e13041e49b82f92eef034f363a6b1c071","cve_id":"CVE-2015-8955","original_address":"https://github.com/torvalds/linux/commit/8fff105e13041e49b82f92eef034f363a6b1c071","time":"2016-10-10T10:59Z"},
	{"Unnamed: 0":1049,"cwe_id":"CWE-000","source":"CWE-000 apr_status_t modsecurity_tx_init ( modsec_rec * msr ) { const char * s = NULL ; const apr_array_header_t * arr ; char * semicolon = NULL ; char * comma = NULL ; apr_table_entry_t * te ; int i ; apr_pool_cleanup_register ( msr -> mp , msr , modsecurity_tx_cleanup , apr_pool_cleanup_null ) ; msr -> request_content_length = - 1 ; s = apr_table_get ( msr -> request_headers , \"Content-Length\" ) ; if ( s != NULL ) { msr -> request_content_length = strtol ( s , NULL , 10 ) ; } msr -> reqbody_chunked = 0 ; msr -> reqbody_should_exist = 0 ; if ( msr -> request_content_length == - 1 ) { char * transfer_encoding = ( char * ) apr_table_get ( msr -> request_headers , \"Transfer-Encoding\" ) ; <S2SV_StartBug> if ( ( transfer_encoding != NULL ) && ( strstr ( transfer_encoding , \"chunked\" ) != NULL ) ) { <S2SV_EndBug> msr -> reqbody_should_exist = 1 ; msr -> reqbody_chunked = 1 ; } } else { msr -> reqbody_should_exist = 1 ; } msr -> request_content_type = NULL ; s = apr_table_get ( msr -> request_headers , \"Content-Type\" ) ; if ( s != NULL ) msr -> request_content_type = s ; if ( ( msr -> request_content_type != NULL ) && ( strncasecmp ( msr -> request_content_type , \"application/x-www-form-urlencoded\" , 33 ) == 0 ) ) { msr -> msc_reqbody_storage = MSC_REQBODY_MEMORY ; msr -> msc_reqbody_spilltodisk = 0 ; msr -> msc_reqbody_processor = \"URLENCODED\" ; } else { if ( ( msr -> request_content_length != - 1 ) && ( msr -> request_content_length > msr -> txcfg -> reqbody_inmemory_limit ) ) { msr -> msc_reqbody_storage = MSC_REQBODY_DISK ; } msr -> msc_reqbody_storage = MSC_REQBODY_MEMORY ; msr -> msc_reqbody_spilltodisk = 1 ; if ( msr -> request_content_type != NULL ) { if ( strncasecmp ( msr -> request_content_type , \"multipart/form-data\" , 19 ) == 0 ) { msr -> msc_reqbody_processor = \"MULTIPART\" ; } } } if ( msr -> txcfg -> reqbody_buffering != REQUEST_BODY_FORCEBUF_OFF ) { msr -> msc_reqbody_storage = MSC_REQBODY_MEMORY ; msr -> msc_reqbody_spilltodisk = 0 ; } msr -> arguments = apr_table_make ( msr -> mp , 32 ) ; if ( msr -> arguments == NULL ) return - 1 ; if ( msr -> query_string != NULL ) { int invalid_count = 0 ; if ( parse_arguments ( msr , msr -> query_string , strlen ( msr -> query_string ) , msr -> txcfg -> argument_separator , \"QUERY_STRING\" , msr -> arguments , & invalid_count ) < 0 ) { msr_log ( msr , 1 , \"Initialisation:<S2SV_blank>Error<S2SV_blank>occurred<S2SV_blank>while<S2SV_blank>parsing<S2SV_blank>QUERY_STRING<S2SV_blank>arguments.\" ) ; return - 1 ; } if ( invalid_count ) { msr -> urlencoded_error = 1 ; } } msr -> arguments_to_sanitize = apr_table_make ( msr -> mp , 16 ) ; if ( msr -> arguments_to_sanitize == NULL ) return - 1 ; msr -> request_headers_to_sanitize = apr_table_make ( msr -> mp , 16 ) ; if ( msr -> request_headers_to_sanitize == NULL ) return - 1 ; msr -> response_headers_to_sanitize = apr_table_make ( msr -> mp , 16 ) ; if ( msr -> response_headers_to_sanitize == NULL ) return - 1 ; msr -> pattern_to_sanitize = apr_table_make ( msr -> mp , 32 ) ; if ( msr -> pattern_to_sanitize == NULL ) return - 1 ; msr -> removed_targets = apr_table_make ( msr -> mp , 16 ) ; if ( msr -> removed_targets == NULL ) return - 1 ; msr -> request_cookies = apr_table_make ( msr -> mp , 16 ) ; if ( msr -> request_cookies == NULL ) return - 1 ; msr -> matched_vars = apr_table_make ( msr -> mp , 8 ) ; if ( msr -> matched_vars == NULL ) return - 1 ; apr_table_clear ( msr -> matched_vars ) ; msr -> perf_rules = apr_table_make ( msr -> mp , 8 ) ; if ( msr -> perf_rules == NULL ) return - 1 ; apr_table_clear ( msr -> perf_rules ) ; arr = apr_table_elts ( msr -> request_headers ) ; te = ( apr_table_entry_t * ) arr -> elts ; for ( i = 0 ; i < arr -> nelts ; i ++ ) { if ( strcasecmp ( te [ i ] . key , \"Cookie\" ) == 0 ) { if ( msr -> txcfg -> cookie_format == COOKIES_V0 ) { semicolon = apr_pstrdup ( msr -> mp , te [ i ] . val ) ; while ( ( * semicolon != 0 ) && ( * semicolon != ';' ) ) semicolon ++ ; if ( * semicolon == ';' ) { parse_cookies_v0 ( msr , te [ i ] . val , msr -> request_cookies , \";\" ) ; } else { comma = apr_pstrdup ( msr -> mp , te [ i ] . val ) ; while ( ( * comma != 0 ) && ( * comma != ',' ) ) comma ++ ; if ( * comma == ',' ) { comma ++ ; if ( * comma == 0x20 ) { if ( msr -> txcfg -> debuglog_level >= 5 ) { msr_log ( msr , 5 , \"Cookie<S2SV_blank>v0<S2SV_blank>parser:<S2SV_blank>Using<S2SV_blank>comma<S2SV_blank>as<S2SV_blank>a<S2SV_blank>separator.<S2SV_blank>Semi-colon<S2SV_blank>was<S2SV_blank>not<S2SV_blank>identified!\" ) ; } parse_cookies_v0 ( msr , te [ i ] . val , msr -> request_cookies , \",\" ) ; } else { parse_cookies_v0 ( msr , te [ i ] . val , msr -> request_cookies , \";\" ) ; } } else { parse_cookies_v0 ( msr , te [ i ] . val , msr -> request_cookies , \";\" ) ; } } } else { parse_cookies_v1 ( msr , te [ i ] . val , msr -> request_cookies ) ; } } } msr -> tx_vars = apr_table_make ( msr -> mp , 32 ) ; if ( msr -> tx_vars == NULL ) return - 1 ; msr -> geo_vars = apr_table_make ( msr -> mp , 8 ) ; if ( msr -> geo_vars == NULL ) return - 1 ; msr -> collections_original = apr_table_make ( msr -> mp , 8 ) ; if ( msr -> collections_original == NULL ) return - 1 ; msr -> collections = apr_table_make ( msr -> mp , 8 ) ; if ( msr -> collections == NULL ) return - 1 ; msr -> collections_dirty = apr_table_make ( msr -> mp , 8 ) ; if ( msr -> collections_dirty == NULL ) return - 1 ; msr -> tcache = NULL ; msr -> tcache_items = 0 ; msr -> matched_rules = apr_array_make ( msr -> mp , 16 , sizeof ( void * ) ) ; if ( msr -> matched_rules == NULL ) return - 1 ; msr -> matched_var = ( msc_string * ) apr_pcalloc ( msr -> mp , sizeof ( msc_string ) ) ; if ( msr -> matched_var == NULL ) return - 1 ; msr -> highest_severity = 255 ; msr -> removed_rules = apr_array_make ( msr -> mp , 16 , sizeof ( char * ) ) ; if ( msr -> removed_rules == NULL ) return - 1 ; msr -> removed_rules_tag = apr_array_make ( msr -> mp , 16 , sizeof ( char * ) ) ; if ( msr -> removed_rules_tag == NULL ) return - 1 ; msr -> removed_rules_msg = apr_array_make ( msr -> mp , 16 , sizeof ( char * ) ) ; if ( msr -> removed_rules_msg == NULL ) return - 1 ; return 1 ; }\n","target":"<S2SV_ModStart> ) && ( m_strcasestr <S2SV_ModEnd> ( transfer_encoding ,\n","project_and_commit_id":"SpiderLabs@ModSecurity/f8d441cd25172fdfe5b613442fedfc0da3cc333d","cve_id":"CVE-2013-5705","original_address":"https://github.com/SpiderLabs/ModSecurity/commit/f8d441cd25172fdfe5b613442fedfc0da3cc333d","time":"2014-04-15T10:55Z"},
	{"Unnamed: 0":2538,"cwe_id":"CWE-400","source":"CWE-400 static int swp_handler ( struct pt_regs * regs , unsigned int instr ) { unsigned int address , destreg , data , type ; unsigned int res = 0 ; <S2SV_StartBug> perf_sw_event ( PERF_COUNT_SW_EMULATION_FAULTS , 1 , 0 , regs , regs -> ARM_pc ) ; <S2SV_EndBug> if ( current -> pid != previous_pid ) { pr_debug ( \"\\\\\"%s\\\\\"<S2SV_blank>(%ld)<S2SV_blank>uses<S2SV_blank>deprecated<S2SV_blank>SWP{B}<S2SV_blank>instruction\\\\n\" , current -> comm , ( unsigned long ) current -> pid ) ; previous_pid = current -> pid ; } address = regs -> uregs [ EXTRACT_REG_NUM ( instr , RN_OFFSET ) ] ; data = regs -> uregs [ EXTRACT_REG_NUM ( instr , RT2_OFFSET ) ] ; destreg = EXTRACT_REG_NUM ( instr , RT_OFFSET ) ; type = instr & TYPE_SWPB ; pr_debug ( \"addr<S2SV_blank>in<S2SV_blank>r%d->0x%08x,<S2SV_blank>dest<S2SV_blank>is<S2SV_blank>r%d,<S2SV_blank>source<S2SV_blank>in<S2SV_blank>r%d->0x%08x)\\\\n\" , EXTRACT_REG_NUM ( instr , RN_OFFSET ) , address , destreg , EXTRACT_REG_NUM ( instr , RT2_OFFSET ) , data ) ; if ( ! access_ok ( VERIFY_WRITE , ( address & ~ 3 ) , 4 ) ) { pr_debug ( \"SWP{B}<S2SV_blank>emulation:<S2SV_blank>access<S2SV_blank>to<S2SV_blank>%p<S2SV_blank>not<S2SV_blank>allowed!\\\\n\" , ( void * ) address ) ; res = - EFAULT ; } else { res = emulate_swpX ( address , & data , type ) ; } if ( res == 0 ) { regs -> ARM_pc += 4 ; regs -> uregs [ destreg ] = data ; } else if ( res == - EFAULT ) { set_segfault ( regs , address ) ; } return 0 ; }\n","target":"<S2SV_ModStart> , 1 , <S2SV_ModEnd> regs , regs\n","project_and_commit_id":"torvalds@linux/a8b0ca17b80e92faab46ee7179ba9e99ccb61233","cve_id":"CVE-2011-2918","original_address":"https://github.com/torvalds/linux/commit/a8b0ca17b80e92faab46ee7179ba9e99ccb61233","time":"2012-05-24T23:55Z"},
	{"Unnamed: 0":2419,"cwe_id":"CWE-119","source":"CWE-119 void vp8_update_gf_useage_maps ( VP8_COMP * cpi , VP8_COMMON * cm , MACROBLOCK * x ) { int mb_row , mb_col ; MODE_INFO * this_mb_mode_info = cm -> mi ; x -> gf_active_ptr = ( signed char * ) cpi -> gf_active_flags ; if ( ( cm -> frame_type == KEY_FRAME ) || ( cm -> refresh_golden_frame ) ) { <S2SV_StartBug> vpx_memset ( cpi -> gf_active_flags , 1 , ( cm -> mb_rows * cm -> mb_cols ) ) ; <S2SV_EndBug> cpi -> gf_active_count = cm -> mb_rows * cm -> mb_cols ; } else { for ( mb_row = 0 ; mb_row < cm -> mb_rows ; mb_row ++ ) { for ( mb_col = 0 ; mb_col < cm -> mb_cols ; mb_col ++ ) { if ( ( this_mb_mode_info -> mbmi . ref_frame == GOLDEN_FRAME ) || ( this_mb_mode_info -> mbmi . ref_frame == ALTREF_FRAME ) ) { if ( * ( x -> gf_active_ptr ) == 0 ) { * ( x -> gf_active_ptr ) = 1 ; cpi -> gf_active_count ++ ; } } else if ( ( this_mb_mode_info -> mbmi . mode != ZEROMV ) && * ( x -> gf_active_ptr ) ) { * ( x -> gf_active_ptr ) = 0 ; cpi -> gf_active_count -- ; } x -> gf_active_ptr ++ ; this_mb_mode_info ++ ; } this_mb_mode_info ++ ; } } }\n","target":"<S2SV_ModStart> ) ) { memset <S2SV_ModEnd> ( cpi ->\n","project_and_commit_id":"external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426","cve_id":"CVE-2016-1621","original_address":"https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426","time":"2016-03-12T21:59Z"},
	{"Unnamed: 0":2516,"cwe_id":"CWE-362","source":"CWE-362 static long ext4_zero_range ( struct file * file , loff_t offset , loff_t len , int mode ) { struct inode * inode = file_inode ( file ) ; handle_t * handle = NULL ; unsigned int max_blocks ; loff_t new_size = 0 ; int ret = 0 ; int flags ; int credits ; int partial_begin , partial_end ; loff_t start , end ; ext4_lblk_t lblk ; <S2SV_StartBug> struct address_space * mapping = inode -> i_mapping ; <S2SV_EndBug> unsigned int blkbits = inode -> i_blkbits ; trace_ext4_zero_range ( inode , offset , len , mode ) ; if ( ! S_ISREG ( inode -> i_mode ) ) return - EINVAL ; if ( ext4_should_journal_data ( inode ) ) { ret = ext4_force_commit ( inode -> i_sb ) ; if ( ret ) return ret ; } <S2SV_StartBug> if ( mapping -> nrpages && mapping_tagged ( mapping , PAGECACHE_TAG_DIRTY ) ) { <S2SV_EndBug> ret = filemap_write_and_wait_range ( mapping , offset , offset + len - 1 ) ; if ( ret ) return ret ; } start = round_up ( offset , 1 << blkbits ) ; end = round_down ( ( offset + len ) , 1 << blkbits ) ; if ( start < offset || end > offset + len ) return - EINVAL ; partial_begin = offset & ( ( 1 << blkbits ) - 1 ) ; partial_end = ( offset + len ) & ( ( 1 << blkbits ) - 1 ) ; lblk = start >> blkbits ; max_blocks = ( end >> blkbits ) ; if ( max_blocks < lblk ) max_blocks = 0 ; else max_blocks -= lblk ; mutex_lock ( & inode -> i_mutex ) ; if ( ! ( ext4_test_inode_flag ( inode , EXT4_INODE_EXTENTS ) ) ) { ret = - EOPNOTSUPP ; goto out_mutex ; } if ( ! ( mode & FALLOC_FL_KEEP_SIZE ) && offset + len > i_size_read ( inode ) ) { new_size = offset + len ; ret = inode_newsize_ok ( inode , new_size ) ; if ( ret ) goto out_mutex ; } flags = EXT4_GET_BLOCKS_CREATE_UNWRIT_EXT ; if ( mode & FALLOC_FL_KEEP_SIZE ) flags |= EXT4_GET_BLOCKS_KEEP_SIZE ; if ( partial_begin || partial_end ) { ret = ext4_alloc_file_blocks ( file , round_down ( offset , 1 << blkbits ) >> blkbits , ( round_up ( ( offset + len ) , 1 << blkbits ) - round_down ( offset , 1 << blkbits ) ) >> blkbits , new_size , flags , mode ) ; if ( ret ) goto out_mutex ; } if ( max_blocks > 0 ) { flags |= ( EXT4_GET_BLOCKS_CONVERT_UNWRITTEN | EXT4_EX_NOCACHE ) ; <S2SV_StartBug> truncate_pagecache_range ( inode , start , end - 1 ) ; <S2SV_EndBug> inode -> i_mtime = inode -> i_ctime = ext4_current_time ( inode ) ; <S2SV_StartBug> ext4_inode_block_unlocked_dio ( inode ) ; <S2SV_EndBug> inode_dio_wait ( inode ) ; ret = ext4_alloc_file_blocks ( file , lblk , max_blocks , new_size , <S2SV_StartBug> flags , mode ) ; <S2SV_EndBug> if ( ret ) goto out_dio ; } if ( ! partial_begin && ! partial_end ) goto out_dio ; credits = ( 2 * ext4_ext_index_trans_blocks ( inode , 2 ) ) + 1 ; if ( ext4_should_journal_data ( inode ) ) credits += 2 ; handle = ext4_journal_start ( inode , EXT4_HT_MISC , credits ) ; if ( IS_ERR ( handle ) ) { ret = PTR_ERR ( handle ) ; ext4_std_error ( inode -> i_sb , ret ) ; goto out_dio ; } inode -> i_mtime = inode -> i_ctime = ext4_current_time ( inode ) ; if ( new_size ) { ext4_update_inode_size ( inode , new_size ) ; } else { if ( ( offset + len ) > i_size_read ( inode ) ) ext4_set_inode_flag ( inode , EXT4_INODE_EOFBLOCKS ) ; } ext4_mark_inode_dirty ( handle , inode ) ; ret = ext4_zero_partial_blocks ( handle , inode , offset , len ) ; if ( file -> f_flags & O_SYNC ) ext4_handle_sync ( handle ) ; ext4_journal_stop ( handle ) ; out_dio : ext4_inode_resume_unlocked_dio ( inode ) ; out_mutex : mutex_unlock ( & inode -> i_mutex ) ; return ret ; }\n","target":"<S2SV_ModStart> ext4_lblk_t lblk ; <S2SV_ModEnd> unsigned int blkbits <S2SV_ModStart> ret ; } <S2SV_ModEnd> start = round_up <S2SV_ModStart> EXT4_EX_NOCACHE ) ; ext4_inode_block_unlocked_dio ( inode ) ; inode_dio_wait ( inode ) ; down_write ( & EXT4_I ( inode ) -> i_mmap_sem ) ; <S2SV_ModStart> inode ) ; <S2SV_ModEnd> ret = ext4_alloc_file_blocks <S2SV_ModStart> flags , mode ) ; up_write ( & EXT4_I ( inode ) -> i_mmap_sem\n","project_and_commit_id":"torvalds@linux/ea3d7209ca01da209cda6f0dea8be9cc4b7a933b","cve_id":"CVE-2015-8839","original_address":"https://github.com/torvalds/linux/commit/ea3d7209ca01da209cda6f0dea8be9cc4b7a933b","time":"2016-05-02T10:59Z"},
	{"Unnamed: 0":3363,"cwe_id":"CWE-362","source":"CWE-362 int btrfs_search_slot ( struct btrfs_trans_handle * trans , struct btrfs_root * root , struct btrfs_key * key , struct btrfs_path * p , int ins_len , int cow ) { struct extent_buffer * b ; int slot ; int ret ; int err ; int level ; int lowest_unlock = 1 ; int root_lock ; int write_lock_level = 0 ; u8 lowest_level = 0 ; int min_write_lock_level ; int prev_cmp ; lowest_level = p -> lowest_level ; WARN_ON ( lowest_level && ins_len > 0 ) ; WARN_ON ( p -> nodes [ 0 ] != NULL ) ; BUG_ON ( ! cow && ins_len ) ; if ( ins_len < 0 ) { lowest_unlock = 2 ; write_lock_level = 2 ; } else if ( ins_len > 0 ) { write_lock_level = 1 ; } if ( ! cow ) write_lock_level = - 1 ; if ( cow && ( p -> keep_locks || p -> lowest_level ) ) write_lock_level = BTRFS_MAX_LEVEL ; min_write_lock_level = write_lock_level ; again : prev_cmp = - 1 ; root_lock = BTRFS_READ_LOCK ; level = 0 ; if ( p -> search_commit_root ) { if ( p -> need_commit_sem ) down_read ( & root -> fs_info -> commit_root_sem ) ; b = root -> commit_root ; extent_buffer_get ( b ) ; level = btrfs_header_level ( b ) ; if ( p -> need_commit_sem ) up_read ( & root -> fs_info -> commit_root_sem ) ; if ( ! p -> skip_locking ) btrfs_tree_read_lock ( b ) ; } else { if ( p -> skip_locking ) { b = btrfs_root_node ( root ) ; level = btrfs_header_level ( b ) ; } else { b = btrfs_read_lock_root_node ( root ) ; level = btrfs_header_level ( b ) ; if ( level <= write_lock_level ) { btrfs_tree_read_unlock ( b ) ; free_extent_buffer ( b ) ; b = btrfs_lock_root_node ( root ) ; root_lock = BTRFS_WRITE_LOCK ; level = btrfs_header_level ( b ) ; } } } p -> nodes [ level ] = b ; if ( ! p -> skip_locking ) p -> locks [ level ] = root_lock ; while ( b ) { level = btrfs_header_level ( b ) ; if ( cow ) { if ( ! should_cow_block ( trans , root , b ) ) goto cow_done ; if ( level > write_lock_level || ( level + 1 > write_lock_level && level + 1 < BTRFS_MAX_LEVEL && p -> nodes [ level + 1 ] ) ) { write_lock_level = level + 1 ; btrfs_release_path ( p ) ; goto again ; } btrfs_set_path_blocking ( p ) ; err = btrfs_cow_block ( trans , root , b , p -> nodes [ level + 1 ] , p -> slots [ level + 1 ] , & b ) ; if ( err ) { ret = err ; goto done ; } } cow_done : p -> nodes [ level ] = b ; btrfs_clear_path_blocking ( p , NULL , 0 ) ; if ( ! ins_len && ! p -> keep_locks ) { int u = level + 1 ; if ( u < BTRFS_MAX_LEVEL && p -> locks [ u ] ) { btrfs_tree_unlock_rw ( p -> nodes [ u ] , p -> locks [ u ] ) ; p -> locks [ u ] = 0 ; } } ret = key_search ( b , key , level , & prev_cmp , & slot ) ; if ( level != 0 ) { int dec = 0 ; if ( ret && slot > 0 ) { dec = 1 ; slot -= 1 ; } p -> slots [ level ] = slot ; err = setup_nodes_for_search ( trans , root , p , b , level , ins_len , & write_lock_level ) ; if ( err == - EAGAIN ) goto again ; if ( err ) { ret = err ; goto done ; } b = p -> nodes [ level ] ; slot = p -> slots [ level ] ; if ( slot == 0 && ins_len && write_lock_level < level + 1 ) { write_lock_level = level + 1 ; btrfs_release_path ( p ) ; goto again ; } unlock_up ( p , level , lowest_unlock , min_write_lock_level , & write_lock_level ) ; if ( level == lowest_level ) { if ( dec ) p -> slots [ level ] ++ ; goto done ; } err = read_block_for_search ( trans , root , p , & b , level , slot , key , 0 ) ; if ( err == - EAGAIN ) goto again ; if ( err ) { ret = err ; goto done ; } if ( ! p -> skip_locking ) { level = btrfs_header_level ( b ) ; if ( level <= write_lock_level ) { err = btrfs_try_tree_write_lock ( b ) ; if ( ! err ) { btrfs_set_path_blocking ( p ) ; btrfs_tree_lock ( b ) ; btrfs_clear_path_blocking ( p , b , BTRFS_WRITE_LOCK ) ; } p -> locks [ level ] = BTRFS_WRITE_LOCK ; } else { err = btrfs_try_tree_read_lock ( b ) ; if ( ! err ) { btrfs_set_path_blocking ( p ) ; btrfs_tree_read_lock ( b ) ; btrfs_clear_path_blocking ( p , b , BTRFS_READ_LOCK ) ; } p -> locks [ level ] = BTRFS_READ_LOCK ; } p -> nodes [ level ] = b ; } } else { p -> slots [ level ] = slot ; if ( ins_len > 0 && btrfs_leaf_free_space ( root , b ) < ins_len ) { if ( write_lock_level < 1 ) { write_lock_level = 1 ; btrfs_release_path ( p ) ; goto again ; } btrfs_set_path_blocking ( p ) ; err = split_leaf ( trans , root , key , p , ins_len , ret == 0 ) ; btrfs_clear_path_blocking ( p , NULL , 0 ) ; BUG_ON ( err > 0 ) ; if ( err ) { ret = err ; goto done ; } } if ( ! p -> search_for_split ) unlock_up ( p , level , lowest_unlock , min_write_lock_level , & write_lock_level ) ; goto done ; } } ret = 1 ; done : if ( ! p -> leave_spinning ) btrfs_set_path_blocking ( p ) ; <S2SV_StartBug> if ( ret < 0 ) <S2SV_EndBug> btrfs_release_path ( p ) ; return ret ; }\n","target":"<S2SV_ModStart> ret < 0 && ! p -> skip_release_on_error\n","project_and_commit_id":"torvalds@linux/5f5bc6b1e2d5a6f827bc860ef2dc5b6f365d1339","cve_id":"CVE-2014-9710","original_address":"https://github.com/torvalds/linux/commit/5f5bc6b1e2d5a6f827bc860ef2dc5b6f365d1339","time":"2015-05-27T10:59Z"},
	{"Unnamed: 0":5006,"cwe_id":"CWE-20","source":"CWE-20 error_t rawSocketSendEthPacket ( Socket * socket , const SocketMsg * message , uint_t flags ) { error_t error ; # if ( ETH_SUPPORT == ENABLED ) size_t length ; NetBuffer * buffer ; NetInterface * interface ; <S2SV_StartBug> if ( socket -> interface != NULL ) <S2SV_EndBug> { interface = socket -> interface ; } else { interface = netGetDefaultInterface ( ) ; } interface = nicGetPhysicalInterface ( interface ) ; if ( interface -> nicDriver != NULL && interface -> nicDriver -> type == NIC_TYPE_ETHERNET ) { buffer = netBufferAlloc ( 0 ) ; if ( buffer == NULL ) return ERROR_OUT_OF_MEMORY ; length = message -> length ; error = netBufferAppend ( buffer , message -> data , length ) ; if ( ! error ) { if ( ! interface -> nicDriver -> autoPadding ) { if ( length < ( ETH_MIN_FRAME_SIZE - ETH_CRC_SIZE ) ) { size_t n ; n = ( ETH_MIN_FRAME_SIZE - ETH_CRC_SIZE ) - length ; error = netBufferAppend ( buffer , ethPadding , n ) ; length += n ; } } } if ( ! error ) { if ( ! interface -> nicDriver -> autoCrcCalc ) { uint32_t crc ; crc = ethCalcCrcEx ( buffer , 0 , length ) ; crc = htole32 ( crc ) ; error = netBufferAppend ( buffer , & crc , sizeof ( crc ) ) ; length += sizeof ( crc ) ; } } if ( ! error ) { NetTxAncillary ancillary ; ancillary = NET_DEFAULT_TX_ANCILLARY ; # if ( ETH_PORT_TAGGING_SUPPORT == ENABLED ) ancillary . port = message -> switchPort ; # endif # if ( ETH_TIMESTAMP_SUPPORT == ENABLED ) ancillary . timestampId = message -> timestampId ; # endif TRACE_DEBUG ( \"Sending<S2SV_blank>raw<S2SV_blank>Ethernet<S2SV_blank>frame<S2SV_blank>(%\" PRIuSIZE \"<S2SV_blank>bytes)...\\\\r\\\\n\" , length ) ; error = nicSendPacket ( interface , buffer , 0 , & ancillary ) ; } netBufferFree ( buffer ) ; } else # endif { error = ERROR_INVALID_INTERFACE ; } return error ; }\n","target":"<S2SV_ModStart> * interface ; if ( message -> interface != NULL ) { interface = message -> interface ; } else\n","project_and_commit_id":"Oryx-Embedded@CycloneTCP/de5336016edbe1e90327d0ed1cba5c4e49114366","cve_id":"CVE-2021-26788","original_address":"https://github.com/Oryx-Embedded/CycloneTCP/commit/de5336016edbe1e90327d0ed1cba5c4e49114366","time":"2021-03-08T13:15Z"},
	{"Unnamed: 0":2198,"cwe_id":"CWE-000","source":"CWE-000 static struct net_device * _init_airo_card ( unsigned short irq , int port , int is_pcmcia , struct pci_dev * pci , struct device * dmdev ) { struct net_device * dev ; struct airo_info * ai ; int i , rc ; CapabilityRid cap_rid ; dev = alloc_netdev ( sizeof ( * ai ) , \"\" , ether_setup ) ; if ( ! dev ) { airo_print_err ( \"\" , \"Couldn\\'t<S2SV_blank>alloc_etherdev\" ) ; return NULL ; } ai = dev -> ml_priv = netdev_priv ( dev ) ; ai -> wifidev = NULL ; ai -> flags = 1 << FLAG_RADIO_DOWN ; ai -> jobs = 0 ; ai -> dev = dev ; if ( pci && ( pci -> device == 0x5000 || pci -> device == 0xa504 ) ) { airo_print_dbg ( \"\" , \"Found<S2SV_blank>an<S2SV_blank>MPI350<S2SV_blank>card\" ) ; set_bit ( FLAG_MPI , & ai -> flags ) ; } spin_lock_init ( & ai -> aux_lock ) ; sema_init ( & ai -> sem , 1 ) ; ai -> config . len = 0 ; ai -> pci = pci ; init_waitqueue_head ( & ai -> thr_wait ) ; ai -> tfm = NULL ; add_airo_dev ( ai ) ; if ( airo_networks_allocate ( ai ) ) goto err_out_free ; airo_networks_initialize ( ai ) ; skb_queue_head_init ( & ai -> txq ) ; if ( test_bit ( FLAG_MPI , & ai -> flags ) ) dev -> netdev_ops = & mpi_netdev_ops ; else dev -> netdev_ops = & airo_netdev_ops ; dev -> wireless_handlers = & airo_handler_def ; ai -> wireless_data . spy_data = & ai -> spy_data ; dev -> wireless_data = & ai -> wireless_data ; dev -> irq = irq ; dev -> base_addr = port ; <S2SV_StartBug> SET_NETDEV_DEV ( dev , dmdev ) ; <S2SV_EndBug> reset_card ( dev , 1 ) ; msleep ( 400 ) ; if ( ! is_pcmcia ) { if ( ! request_region ( dev -> base_addr , 64 , DRV_NAME ) ) { rc = - EBUSY ; airo_print_err ( dev -> name , \"Couldn\\'t<S2SV_blank>request<S2SV_blank>region\" ) ; goto err_out_nets ; } } if ( test_bit ( FLAG_MPI , & ai -> flags ) ) { if ( mpi_map_card ( ai , pci ) ) { airo_print_err ( \"\" , \"Could<S2SV_blank>not<S2SV_blank>map<S2SV_blank>memory\" ) ; goto err_out_res ; } } if ( probe ) { if ( setup_card ( ai , dev -> dev_addr , 1 ) != SUCCESS ) { airo_print_err ( dev -> name , \"MAC<S2SV_blank>could<S2SV_blank>not<S2SV_blank>be<S2SV_blank>enabled\" ) ; rc = - EIO ; goto err_out_map ; } } else if ( ! test_bit ( FLAG_MPI , & ai -> flags ) ) { ai -> bap_read = fast_bap_read ; set_bit ( FLAG_FLASHING , & ai -> flags ) ; } strcpy ( dev -> name , \"eth%d\" ) ; rc = register_netdev ( dev ) ; if ( rc ) { airo_print_err ( dev -> name , \"Couldn\\'t<S2SV_blank>register_netdev\" ) ; goto err_out_map ; } ai -> wifidev = init_wifidev ( ai , dev ) ; if ( ! ai -> wifidev ) goto err_out_reg ; rc = readCapabilityRid ( ai , & cap_rid , 1 ) ; if ( rc != SUCCESS ) { rc = - EIO ; goto err_out_wifi ; } ai -> wep_capable = ( cap_rid . softCap & cpu_to_le16 ( 0x02 ) ) ? 1 : 0 ; ai -> max_wep_idx = ( cap_rid . softCap & cpu_to_le16 ( 0x80 ) ) ? 3 : 0 ; airo_print_info ( dev -> name , \"Firmware<S2SV_blank>version<S2SV_blank>%x.%x.%02d\" , ( ( le16_to_cpu ( cap_rid . softVer ) >> 8 ) & 0xF ) , ( le16_to_cpu ( cap_rid . softVer ) & 0xFF ) , le16_to_cpu ( cap_rid . softSubVer ) ) ; if ( le16_to_cpu ( cap_rid . softVer ) > 0x530 || ( le16_to_cpu ( cap_rid . softVer ) == 0x530 && le16_to_cpu ( cap_rid . softSubVer ) >= 17 ) ) { airo_print_info ( ai -> dev -> name , \"WPA<S2SV_blank>supported.\" ) ; set_bit ( FLAG_WPA_CAPABLE , & ai -> flags ) ; ai -> bssListFirst = RID_WPA_BSSLISTFIRST ; ai -> bssListNext = RID_WPA_BSSLISTNEXT ; ai -> bssListRidLen = sizeof ( BSSListRid ) ; } else { airo_print_info ( ai -> dev -> name , \"WPA<S2SV_blank>unsupported<S2SV_blank>with<S2SV_blank>firmware<S2SV_blank>\" \"versions<S2SV_blank>older<S2SV_blank>than<S2SV_blank>5.30.17.\" ) ; ai -> bssListFirst = RID_BSSLISTFIRST ; ai -> bssListNext = RID_BSSLISTNEXT ; ai -> bssListRidLen = sizeof ( BSSListRid ) - sizeof ( BSSListRidExtra ) ; } set_bit ( FLAG_REGISTERED , & ai -> flags ) ; airo_print_info ( dev -> name , \"MAC<S2SV_blank>enabled<S2SV_blank>%pM\" , dev -> dev_addr ) ; if ( probe && ! test_bit ( FLAG_MPI , & ai -> flags ) ) for ( i = 0 ; i < MAX_FIDS ; i ++ ) ai -> fids [ i ] = transmit_allocate ( ai , AIRO_DEF_MTU , i >= MAX_FIDS / 2 ) ; if ( setup_proc_entry ( dev , dev -> ml_priv ) < 0 ) goto err_out_wifi ; return dev ; err_out_wifi : unregister_netdev ( ai -> wifidev ) ; free_netdev ( ai -> wifidev ) ; err_out_reg : unregister_netdev ( dev ) ; err_out_map : if ( test_bit ( FLAG_MPI , & ai -> flags ) && pci ) { pci_free_consistent ( pci , PCI_SHARED_LEN , ai -> shared , ai -> shared_dma ) ; iounmap ( ai -> pciaux ) ; iounmap ( ai -> pcimem ) ; mpi_unmap_card ( ai -> pci ) ; } err_out_res : if ( ! is_pcmcia ) release_region ( dev -> base_addr , 64 ) ; err_out_nets : airo_networks_free ( ai ) ; err_out_free : del_airo_dev ( ai ) ; free_netdev ( dev ) ; return NULL ; }\n","target":"<S2SV_ModStart> = port ; dev -> priv_flags &= ~ IFF_TX_SKB_SHARING ;\n","project_and_commit_id":"torvalds@linux/550fd08c2cebad61c548def135f67aba284c6162","cve_id":"CVE-2011-4112","original_address":"https://github.com/torvalds/linux/commit/550fd08c2cebad61c548def135f67aba284c6162","time":"2012-05-17T11:00Z"},
	{"Unnamed: 0":5582,"cwe_id":"CWE-000","source":"CWE-000 struct bpf_prog * bpf_prog_get ( u32 ufd ) { struct fd f = fdget ( ufd ) ; struct bpf_prog * prog ; prog = __bpf_prog_get ( f ) ; if ( IS_ERR ( prog ) ) return prog ; <S2SV_StartBug> atomic_inc ( & prog -> aux -> refcnt ) ; <S2SV_EndBug> fdput ( f ) ; return prog ; }\n","target":"<S2SV_ModStart> return prog ; prog = bpf_prog_inc ( prog <S2SV_ModEnd> ) ; fdput\n","project_and_commit_id":"torvalds@linux/92117d8443bc5afacc8d5ba82e541946310f106e","cve_id":"CVE-2016-4558","original_address":"https://github.com/torvalds/linux/commit/92117d8443bc5afacc8d5ba82e541946310f106e","time":"2016-05-23T10:59Z"},
	{"Unnamed: 0":4431,"cwe_id":"CWE-119","source":"CWE-119 static int catc_probe ( struct usb_interface * intf , const struct usb_device_id * id ) { struct device * dev = & intf -> dev ; struct usb_device * usbdev = interface_to_usbdev ( intf ) ; struct net_device * netdev ; struct catc * catc ; u8 broadcast [ ETH_ALEN ] ; <S2SV_StartBug> int i , pktsz , ret ; <S2SV_EndBug> if ( usb_set_interface ( usbdev , intf -> altsetting -> desc . bInterfaceNumber , 1 ) ) { dev_err ( dev , \"Can\\'t<S2SV_blank>set<S2SV_blank>altsetting<S2SV_blank>1.\\\\n\" ) ; return - EIO ; } netdev = alloc_etherdev ( sizeof ( struct catc ) ) ; if ( ! netdev ) return - ENOMEM ; catc = netdev_priv ( netdev ) ; netdev -> netdev_ops = & catc_netdev_ops ; netdev -> watchdog_timeo = TX_TIMEOUT ; netdev -> ethtool_ops = & ops ; catc -> usbdev = usbdev ; catc -> netdev = netdev ; spin_lock_init ( & catc -> tx_lock ) ; spin_lock_init ( & catc -> ctrl_lock ) ; init_timer ( & catc -> timer ) ; catc -> timer . data = ( long ) catc ; catc -> timer . function = catc_stats_timer ; catc -> ctrl_urb = usb_alloc_urb ( 0 , GFP_KERNEL ) ; catc -> tx_urb = usb_alloc_urb ( 0 , GFP_KERNEL ) ; catc -> rx_urb = usb_alloc_urb ( 0 , GFP_KERNEL ) ; catc -> irq_urb = usb_alloc_urb ( 0 , GFP_KERNEL ) ; if ( ( ! catc -> ctrl_urb ) || ( ! catc -> tx_urb ) || ( ! catc -> rx_urb ) || ( ! catc -> irq_urb ) ) { dev_err ( & intf -> dev , \"No<S2SV_blank>free<S2SV_blank>urbs<S2SV_blank>available.\\\\n\" ) ; ret = - ENOMEM ; goto fail_free ; } if ( le16_to_cpu ( usbdev -> descriptor . idVendor ) == 0x0423 && le16_to_cpu ( usbdev -> descriptor . idProduct ) == 0xa && le16_to_cpu ( catc -> usbdev -> descriptor . bcdDevice ) == 0x0130 ) { dev_dbg ( dev , \"Testing<S2SV_blank>for<S2SV_blank>f5u011\\\\n\" ) ; catc -> is_f5u011 = 1 ; atomic_set ( & catc -> recq_sz , 0 ) ; pktsz = RX_PKT_SZ ; } else { pktsz = RX_MAX_BURST * ( PKT_SZ + 2 ) ; } usb_fill_control_urb ( catc -> ctrl_urb , usbdev , usb_sndctrlpipe ( usbdev , 0 ) , NULL , NULL , 0 , catc_ctrl_done , catc ) ; usb_fill_bulk_urb ( catc -> tx_urb , usbdev , usb_sndbulkpipe ( usbdev , 1 ) , NULL , 0 , catc_tx_done , catc ) ; usb_fill_bulk_urb ( catc -> rx_urb , usbdev , usb_rcvbulkpipe ( usbdev , 1 ) , catc -> rx_buf , pktsz , catc_rx_done , catc ) ; usb_fill_int_urb ( catc -> irq_urb , usbdev , usb_rcvintpipe ( usbdev , 2 ) , catc -> irq_buf , 2 , catc_irq_done , catc , 1 ) ; if ( ! catc -> is_f5u011 ) { <S2SV_StartBug> dev_dbg ( dev , \"Checking<S2SV_blank>memory<S2SV_blank>size\\\\n\" ) ; <S2SV_EndBug> <S2SV_StartBug> i = 0x12345678 ; <S2SV_EndBug> <S2SV_StartBug> catc_write_mem ( catc , 0x7a80 , & i , 4 ) ; <S2SV_EndBug> <S2SV_StartBug> i = 0x87654321 ; <S2SV_EndBug> <S2SV_StartBug> catc_write_mem ( catc , 0xfa80 , & i , 4 ) ; <S2SV_EndBug> <S2SV_StartBug> catc_read_mem ( catc , 0x7a80 , & i , 4 ) ; <S2SV_EndBug> <S2SV_StartBug> switch ( i ) { <S2SV_EndBug> case 0x12345678 : catc_set_reg ( catc , TxBufCount , 8 ) ; catc_set_reg ( catc , RxBufCount , 32 ) ; dev_dbg ( dev , \"64k<S2SV_blank>Memory\\\\n\" ) ; break ; default : dev_warn ( & intf -> dev , \"Couldn\\'t<S2SV_blank>detect<S2SV_blank>memory<S2SV_blank>size,<S2SV_blank>assuming<S2SV_blank>32k\\\\n\" ) ; case 0x87654321 : catc_set_reg ( catc , TxBufCount , 4 ) ; catc_set_reg ( catc , RxBufCount , 16 ) ; dev_dbg ( dev , \"32k<S2SV_blank>Memory\\\\n\" ) ; break ; <S2SV_StartBug> } <S2SV_EndBug> dev_dbg ( dev , \"Getting<S2SV_blank>MAC<S2SV_blank>from<S2SV_blank>SEEROM.\\\\n\" ) ; catc_get_mac ( catc , netdev -> dev_addr ) ; dev_dbg ( dev , \"Setting<S2SV_blank>MAC<S2SV_blank>into<S2SV_blank>registers.\\\\n\" ) ; for ( i = 0 ; i < 6 ; i ++ ) catc_set_reg ( catc , StationAddr0 - i , netdev -> dev_addr [ i ] ) ; dev_dbg ( dev , \"Filling<S2SV_blank>the<S2SV_blank>multicast<S2SV_blank>list.\\\\n\" ) ; eth_broadcast_addr ( broadcast ) ; catc_multicast ( broadcast , catc -> multicast ) ; catc_multicast ( netdev -> dev_addr , catc -> multicast ) ; catc_write_mem ( catc , 0xfa80 , catc -> multicast , 64 ) ; dev_dbg ( dev , \"Clearing<S2SV_blank>error<S2SV_blank>counters.\\\\n\" ) ; for ( i = 0 ; i < 8 ; i ++ ) catc_set_reg ( catc , EthStats + i , 0 ) ; catc -> last_stats = jiffies ; dev_dbg ( dev , \"Enabling.\\\\n\" ) ; catc_set_reg ( catc , MaxBurst , RX_MAX_BURST ) ; catc_set_reg ( catc , OpModes , OpTxMerge | OpRxMerge | OpLenInclude | Op3MemWaits ) ; catc_set_reg ( catc , LEDCtrl , LEDLink ) ; catc_set_reg ( catc , RxUnit , RxEnable | RxPolarity | RxMultiCast ) ; } else { dev_dbg ( dev , \"Performing<S2SV_blank>reset\\\\n\" ) ; catc_reset ( catc ) ; catc_get_mac ( catc , netdev -> dev_addr ) ; dev_dbg ( dev , \"Setting<S2SV_blank>RX<S2SV_blank>Mode\\\\n\" ) ; catc -> rxmode [ 0 ] = RxEnable | RxPolarity | RxMultiCast ; catc -> rxmode [ 1 ] = 0 ; f5u011_rxmode ( catc , catc -> rxmode ) ; } dev_dbg ( dev , \"Init<S2SV_blank>done.\\\\n\" ) ; printk ( KERN_INFO \"%s:<S2SV_blank>%s<S2SV_blank>USB<S2SV_blank>Ethernet<S2SV_blank>at<S2SV_blank>usb-%s-%s,<S2SV_blank>%pM.\\\\n\" , netdev -> name , ( catc -> is_f5u011 ) ? \"Belkin<S2SV_blank>F5U011\" : \"CATC<S2SV_blank>EL1210A<S2SV_blank>NetMate\" , usbdev -> bus -> bus_name , usbdev -> devpath , netdev -> dev_addr ) ; usb_set_intfdata ( intf , catc ) ; SET_NETDEV_DEV ( netdev , & intf -> dev ) ; ret = register_netdev ( netdev ) ; if ( ret ) goto fail_clear_intfdata ; return 0 ; fail_clear_intfdata : usb_set_intfdata ( intf , NULL ) ; fail_free : usb_free_urb ( catc -> ctrl_urb ) ; usb_free_urb ( catc -> tx_urb ) ; usb_free_urb ( catc -> rx_urb ) ; usb_free_urb ( catc -> irq_urb ) ; free_netdev ( netdev ) ; return ret ; }\n","target":"<S2SV_ModStart> ] ; int <S2SV_ModEnd> pktsz , ret <S2SV_ModStart> is_f5u011 ) { u32 * buf ; int i ; <S2SV_ModStart> \"Checking<S2SV_blank>memory<S2SV_blank>size\\\\n\" ) ; buf = kmalloc ( 4 , GFP_KERNEL ) ; if ( ! buf ) { ret = - ENOMEM ; goto fail_free ; } * buf <S2SV_ModEnd> = 0x12345678 ; <S2SV_ModStart> , 0x7a80 , buf <S2SV_ModEnd> , 4 ) <S2SV_ModStart> 4 ) ; * buf <S2SV_ModEnd> = 0x87654321 ; <S2SV_ModStart> , 0xfa80 , buf <S2SV_ModEnd> , 4 ) <S2SV_ModStart> , 0x7a80 , buf <S2SV_ModEnd> , 4 ) <S2SV_ModStart> ; switch ( * buf <S2SV_ModEnd> ) { case <S2SV_ModStart> break ; } kfree ( buf ) ;\n","project_and_commit_id":"torvalds@linux/2d6a0e9de03ee658a9adc3bfb2f0ca55dff1e478","cve_id":"CVE-2017-8070","original_address":"https://github.com/torvalds/linux/commit/2d6a0e9de03ee658a9adc3bfb2f0ca55dff1e478","time":"2017-04-23T05:59Z"},
	{"Unnamed: 0":5247,"cwe_id":"CWE-59","source":"CWE-59 static int lxc_mount_auto_mounts ( struct lxc_conf * conf , int flags , struct lxc_handler * handler ) { int r ; size_t i ; static struct { int match_mask ; int match_flag ; const char * source ; const char * destination ; const char * fstype ; unsigned long flags ; const char * options ; } default_mounts [ ] = { { LXC_AUTO_PROC_MASK , LXC_AUTO_PROC_MIXED , \"proc\" , \"%r/proc\" , \"proc\" , MS_NODEV | MS_NOEXEC | MS_NOSUID , NULL } , <S2SV_StartBug> { LXC_AUTO_PROC_MASK , LXC_AUTO_PROC_MIXED , \"%r/proc/sys/net\" , \"%r/proc/net\" , NULL , MS_BIND , NULL } , <S2SV_EndBug> { LXC_AUTO_PROC_MASK , LXC_AUTO_PROC_MIXED , \"%r/proc/sys\" , \"%r/proc/sys\" , NULL , MS_BIND , NULL } , { LXC_AUTO_PROC_MASK , LXC_AUTO_PROC_MIXED , NULL , \"%r/proc/sys\" , NULL , MS_REMOUNT | MS_BIND | MS_RDONLY , NULL } , <S2SV_StartBug> { LXC_AUTO_PROC_MASK , LXC_AUTO_PROC_MIXED , \"%r/proc/net\" , \"%r/proc/sys/net\" , NULL , MS_MOVE , NULL } , <S2SV_EndBug> { LXC_AUTO_PROC_MASK , LXC_AUTO_PROC_MIXED , \"%r/proc/sysrq-trigger\" , \"%r/proc/sysrq-trigger\" , NULL , MS_BIND , NULL } , { LXC_AUTO_PROC_MASK , LXC_AUTO_PROC_MIXED , NULL , \"%r/proc/sysrq-trigger\" , NULL , MS_REMOUNT | MS_BIND | MS_RDONLY , NULL } , { LXC_AUTO_PROC_MASK , LXC_AUTO_PROC_RW , \"proc\" , \"%r/proc\" , \"proc\" , MS_NODEV | MS_NOEXEC | MS_NOSUID , NULL } , { LXC_AUTO_SYS_MASK , LXC_AUTO_SYS_RW , \"sysfs\" , \"%r/sys\" , \"sysfs\" , 0 , NULL } , { LXC_AUTO_SYS_MASK , LXC_AUTO_SYS_RO , \"sysfs\" , \"%r/sys\" , \"sysfs\" , MS_RDONLY , NULL } , { LXC_AUTO_SYS_MASK , LXC_AUTO_SYS_MIXED , \"sysfs\" , \"%r/sys\" , \"sysfs\" , MS_NODEV | MS_NOEXEC | MS_NOSUID , NULL } , { LXC_AUTO_SYS_MASK , LXC_AUTO_SYS_MIXED , \"%r/sys\" , \"%r/sys\" , NULL , MS_BIND , NULL } , { LXC_AUTO_SYS_MASK , LXC_AUTO_SYS_MIXED , NULL , \"%r/sys\" , NULL , MS_REMOUNT | MS_BIND | MS_RDONLY , NULL } , { LXC_AUTO_SYS_MASK , LXC_AUTO_SYS_MIXED , \"sysfs\" , \"%r/sys/devices/virtual/net\" , \"sysfs\" , 0 , NULL } , { LXC_AUTO_SYS_MASK , LXC_AUTO_SYS_MIXED , \"%r/sys/devices/virtual/net/devices/virtual/net\" , \"%r/sys/devices/virtual/net\" , NULL , MS_BIND , NULL } , { LXC_AUTO_SYS_MASK , LXC_AUTO_SYS_MIXED , NULL , \"%r/sys/devices/virtual/net\" , NULL , MS_REMOUNT | MS_BIND | MS_NOSUID | MS_NODEV | MS_NOEXEC , NULL } , { 0 , 0 , NULL , NULL , NULL , 0 , NULL } } ; for ( i = 0 ; default_mounts [ i ] . match_mask ; i ++ ) { if ( ( flags & default_mounts [ i ] . match_mask ) == default_mounts [ i ] . match_flag ) { char * source = NULL ; char * destination = NULL ; int saved_errno ; unsigned long mflags ; if ( default_mounts [ i ] . source ) { source = lxc_string_replace ( \"%r\" , conf -> rootfs . path ? conf -> rootfs . mount : \"\" , default_mounts [ i ] . source ) ; if ( ! source ) { SYSERROR ( \"memory<S2SV_blank>allocation<S2SV_blank>error\" ) ; return - 1 ; } } if ( default_mounts [ i ] . destination ) { destination = lxc_string_replace ( \"%r\" , conf -> rootfs . path ? conf -> rootfs . mount : \"\" , default_mounts [ i ] . destination ) ; if ( ! destination ) { saved_errno = errno ; SYSERROR ( \"memory<S2SV_blank>allocation<S2SV_blank>error\" ) ; free ( source ) ; errno = saved_errno ; return - 1 ; } } mflags = add_required_remount_flags ( source , destination , default_mounts [ i ] . flags ) ; <S2SV_StartBug> r = mount ( source , destination , default_mounts [ i ] . fstype , mflags , default_mounts [ i ] . options ) ; <S2SV_EndBug> saved_errno = errno ; if ( r < 0 && errno == ENOENT ) { INFO ( \"Mount<S2SV_blank>source<S2SV_blank>or<S2SV_blank>target<S2SV_blank>for<S2SV_blank>%s<S2SV_blank>on<S2SV_blank>%s<S2SV_blank>doesn\\'t<S2SV_blank>exist.<S2SV_blank>Skipping.\" , source , destination ) ; r = 0 ; } else if ( r < 0 ) SYSERROR ( \"error<S2SV_blank>mounting<S2SV_blank>%s<S2SV_blank>on<S2SV_blank>%s<S2SV_blank>flags<S2SV_blank>%lu\" , source , destination , mflags ) ; free ( source ) ; free ( destination ) ; if ( r < 0 ) { errno = saved_errno ; return - 1 ; } } } if ( flags & LXC_AUTO_CGROUP_MASK ) { int cg_flags ; cg_flags = flags & LXC_AUTO_CGROUP_MASK ; if ( cg_flags == LXC_AUTO_CGROUP_NOSPEC || cg_flags == LXC_AUTO_CGROUP_FULL_NOSPEC ) { int has_sys_admin = 0 ; if ( ! lxc_list_empty ( & conf -> keepcaps ) ) { has_sys_admin = in_caplist ( CAP_SYS_ADMIN , & conf -> keepcaps ) ; } else { has_sys_admin = ! in_caplist ( CAP_SYS_ADMIN , & conf -> caps ) ; } if ( cg_flags == LXC_AUTO_CGROUP_NOSPEC ) { cg_flags = has_sys_admin ? LXC_AUTO_CGROUP_RW : LXC_AUTO_CGROUP_MIXED ; } else { cg_flags = has_sys_admin ? LXC_AUTO_CGROUP_FULL_RW : LXC_AUTO_CGROUP_FULL_MIXED ; } } if ( ! cgroup_mount ( conf -> rootfs . path ? conf -> rootfs . mount : \"\" , handler , cg_flags ) ) { SYSERROR ( \"error<S2SV_blank>mounting<S2SV_blank>/sys/fs/cgroup\" ) ; return - 1 ; } } return 0 ; }\n","target":"<S2SV_ModStart> , \"%r/proc/sys/net\" , \"%r/proc/tty\" <S2SV_ModEnd> , NULL , <S2SV_ModStart> , LXC_AUTO_PROC_MIXED , \"%r/proc/tty\" <S2SV_ModEnd> , \"%r/proc/sys/net\" , <S2SV_ModStart> ; r = safe_mount ( source , destination , default_mounts [ i ] . fstype , mflags , default_mounts [ i ] . options , conf -> rootfs . path ? conf -> rootfs . mount : NULL <S2SV_ModEnd> ) ; saved_errno\n","project_and_commit_id":"lxc@lxc/592fd47a6245508b79fe6ac819fe6d3b2c1289be","cve_id":"CVE-2015-1335","original_address":"https://github.com/lxc/lxc/commit/592fd47a6245508b79fe6ac819fe6d3b2c1289be","time":"2015-10-01T20:59Z"},
	{"Unnamed: 0":3858,"cwe_id":"CWE-200","source":"CWE-200 static int pptp_connect ( struct socket * sock , struct sockaddr * uservaddr , int sockaddr_len , int flags ) { struct sock * sk = sock -> sk ; struct sockaddr_pppox * sp = ( struct sockaddr_pppox * ) uservaddr ; struct pppox_sock * po = pppox_sk ( sk ) ; struct pptp_opt * opt = & po -> proto . pptp ; struct rtable * rt ; struct flowi4 fl4 ; int error = 0 ; <S2SV_StartBug> if ( sp -> sa_protocol != PX_PROTO_PPTP ) <S2SV_EndBug> return - EINVAL ; if ( lookup_chan_dst ( sp -> sa_addr . pptp . call_id , sp -> sa_addr . pptp . sin_addr . s_addr ) ) return - EALREADY ; lock_sock ( sk ) ; if ( sk -> sk_state & PPPOX_CONNECTED ) { error = - EBUSY ; goto end ; } if ( sk -> sk_state & PPPOX_DEAD ) { error = - EALREADY ; goto end ; } if ( ! opt -> src_addr . sin_addr . s_addr || ! sp -> sa_addr . pptp . sin_addr . s_addr ) { error = - EINVAL ; goto end ; } po -> chan . private = sk ; po -> chan . ops = & pptp_chan_ops ; rt = ip_route_output_ports ( sock_net ( sk ) , & fl4 , sk , opt -> dst_addr . sin_addr . s_addr , opt -> src_addr . sin_addr . s_addr , 0 , 0 , IPPROTO_GRE , RT_CONN_FLAGS ( sk ) , 0 ) ; if ( IS_ERR ( rt ) ) { error = - EHOSTUNREACH ; goto end ; } sk_setup_caps ( sk , & rt -> dst ) ; po -> chan . mtu = dst_mtu ( & rt -> dst ) ; if ( ! po -> chan . mtu ) po -> chan . mtu = PPP_MRU ; ip_rt_put ( rt ) ; po -> chan . mtu -= PPTP_HEADER_OVERHEAD ; po -> chan . hdrlen = 2 + sizeof ( struct pptp_gre_header ) ; error = ppp_register_channel ( & po -> chan ) ; if ( error ) { pr_err ( \"PPTP:<S2SV_blank>failed<S2SV_blank>to<S2SV_blank>register<S2SV_blank>PPP<S2SV_blank>channel<S2SV_blank>(%d)\\\\n\" , error ) ; goto end ; } opt -> dst_addr = sp -> sa_addr . pptp ; sk -> sk_state = PPPOX_CONNECTED ; end : release_sock ( sk ) ; return error ; }\n","target":"<S2SV_ModStart> ; if ( sockaddr_len < sizeof ( struct sockaddr_pppox ) ) return - EINVAL ; if (\n","project_and_commit_id":"torvalds@linux/09ccfd238e5a0e670d8178cf50180ea81ae09ae1","cve_id":"CVE-2015-8569","original_address":"https://github.com/torvalds/linux/commit/09ccfd238e5a0e670d8178cf50180ea81ae09ae1","time":"2015-12-28T11:59Z"},
	{"Unnamed: 0":5401,"cwe_id":"CWE-200","source":"CWE-200 static int sched_read_attr ( struct sched_attr __user * uattr , struct sched_attr * attr , unsigned int usize ) { int ret ; if ( ! access_ok ( VERIFY_WRITE , uattr , usize ) ) return - EFAULT ; if ( usize < sizeof ( * attr ) ) { unsigned char * addr ; unsigned char * end ; addr = ( void * ) attr + usize ; end = ( void * ) attr + sizeof ( * attr ) ; for ( ; addr < end ; addr ++ ) { if ( * addr ) goto err_size ; } attr -> size = usize ; } <S2SV_StartBug> ret = copy_to_user ( uattr , attr , usize ) ; <S2SV_EndBug> if ( ret ) return - EFAULT ; out : return ret ; err_size : ret = - E2BIG ; goto out ; }\n","target":"<S2SV_ModStart> , attr , attr -> size <S2SV_ModEnd> ) ; if\n","project_and_commit_id":"torvalds@linux/4efbc454ba68def5ef285b26ebfcfdb605b52755","cve_id":"CVE-2014-9903","original_address":"https://github.com/torvalds/linux/commit/4efbc454ba68def5ef285b26ebfcfdb605b52755","time":"2016-06-27T10:59Z"},
	{"Unnamed: 0":2154,"cwe_id":"CWE-119","source":"CWE-119 static void tg3_read_vpd ( struct tg3 * tp ) { u8 * vpd_data ; unsigned int block_end , rosize , len ; u32 vpdlen ; int j , i = 0 ; vpd_data = ( u8 * ) tg3_vpd_readblock ( tp , & vpdlen ) ; if ( ! vpd_data ) goto out_no_vpd ; i = pci_vpd_find_tag ( vpd_data , 0 , vpdlen , PCI_VPD_LRDT_RO_DATA ) ; if ( i < 0 ) goto out_not_found ; rosize = pci_vpd_lrdt_size ( & vpd_data [ i ] ) ; block_end = i + PCI_VPD_LRDT_TAG_SIZE + rosize ; i += PCI_VPD_LRDT_TAG_SIZE ; if ( block_end > vpdlen ) goto out_not_found ; j = pci_vpd_find_info_keyword ( vpd_data , i , rosize , PCI_VPD_RO_KEYWORD_MFR_ID ) ; if ( j > 0 ) { len = pci_vpd_info_field_size ( & vpd_data [ j ] ) ; j += PCI_VPD_INFO_FLD_HDR_SIZE ; if ( j + len > block_end || len != 4 || memcmp ( & vpd_data [ j ] , \"1028\" , 4 ) ) goto partno ; j = pci_vpd_find_info_keyword ( vpd_data , i , rosize , PCI_VPD_RO_KEYWORD_VENDOR0 ) ; if ( j < 0 ) goto partno ; len = pci_vpd_info_field_size ( & vpd_data [ j ] ) ; j += PCI_VPD_INFO_FLD_HDR_SIZE ; if ( j + len > block_end ) goto partno ; <S2SV_StartBug> memcpy ( tp -> fw_ver , & vpd_data [ j ] , len ) ; <S2SV_EndBug> <S2SV_StartBug> strncat ( tp -> fw_ver , \"<S2SV_blank>bc<S2SV_blank>\" , vpdlen - len - 1 ) ; <S2SV_EndBug> } partno : i = pci_vpd_find_info_keyword ( vpd_data , i , rosize , PCI_VPD_RO_KEYWORD_PARTNO ) ; if ( i < 0 ) goto out_not_found ; len = pci_vpd_info_field_size ( & vpd_data [ i ] ) ; i += PCI_VPD_INFO_FLD_HDR_SIZE ; if ( len > TG3_BPN_SIZE || ( len + i ) > vpdlen ) goto out_not_found ; memcpy ( tp -> board_part_number , & vpd_data [ i ] , len ) ; out_not_found : kfree ( vpd_data ) ; if ( tp -> board_part_number [ 0 ] ) return ; out_no_vpd : if ( tg3_asic_rev ( tp ) == ASIC_REV_5717 ) { if ( tp -> pdev -> device == TG3PCI_DEVICE_TIGON3_5717 || tp -> pdev -> device == TG3PCI_DEVICE_TIGON3_5717_C ) strcpy ( tp -> board_part_number , \"BCM5717\" ) ; else if ( tp -> pdev -> device == TG3PCI_DEVICE_TIGON3_5718 ) strcpy ( tp -> board_part_number , \"BCM5718\" ) ; else goto nomatch ; } else if ( tg3_asic_rev ( tp ) == ASIC_REV_57780 ) { if ( tp -> pdev -> device == TG3PCI_DEVICE_TIGON3_57780 ) strcpy ( tp -> board_part_number , \"BCM57780\" ) ; else if ( tp -> pdev -> device == TG3PCI_DEVICE_TIGON3_57760 ) strcpy ( tp -> board_part_number , \"BCM57760\" ) ; else if ( tp -> pdev -> device == TG3PCI_DEVICE_TIGON3_57790 ) strcpy ( tp -> board_part_number , \"BCM57790\" ) ; else if ( tp -> pdev -> device == TG3PCI_DEVICE_TIGON3_57788 ) strcpy ( tp -> board_part_number , \"BCM57788\" ) ; else goto nomatch ; } else if ( tg3_asic_rev ( tp ) == ASIC_REV_57765 ) { if ( tp -> pdev -> device == TG3PCI_DEVICE_TIGON3_57761 ) strcpy ( tp -> board_part_number , \"BCM57761\" ) ; else if ( tp -> pdev -> device == TG3PCI_DEVICE_TIGON3_57765 ) strcpy ( tp -> board_part_number , \"BCM57765\" ) ; else if ( tp -> pdev -> device == TG3PCI_DEVICE_TIGON3_57781 ) strcpy ( tp -> board_part_number , \"BCM57781\" ) ; else if ( tp -> pdev -> device == TG3PCI_DEVICE_TIGON3_57785 ) strcpy ( tp -> board_part_number , \"BCM57785\" ) ; else if ( tp -> pdev -> device == TG3PCI_DEVICE_TIGON3_57791 ) strcpy ( tp -> board_part_number , \"BCM57791\" ) ; else if ( tp -> pdev -> device == TG3PCI_DEVICE_TIGON3_57795 ) strcpy ( tp -> board_part_number , \"BCM57795\" ) ; else goto nomatch ; } else if ( tg3_asic_rev ( tp ) == ASIC_REV_57766 ) { if ( tp -> pdev -> device == TG3PCI_DEVICE_TIGON3_57762 ) strcpy ( tp -> board_part_number , \"BCM57762\" ) ; else if ( tp -> pdev -> device == TG3PCI_DEVICE_TIGON3_57766 ) strcpy ( tp -> board_part_number , \"BCM57766\" ) ; else if ( tp -> pdev -> device == TG3PCI_DEVICE_TIGON3_57782 ) strcpy ( tp -> board_part_number , \"BCM57782\" ) ; else if ( tp -> pdev -> device == TG3PCI_DEVICE_TIGON3_57786 ) strcpy ( tp -> board_part_number , \"BCM57786\" ) ; else goto nomatch ; } else if ( tg3_asic_rev ( tp ) == ASIC_REV_5906 ) { strcpy ( tp -> board_part_number , \"BCM95906\" ) ; } else { nomatch : strcpy ( tp -> board_part_number , \"none\" ) ; } }\n","target":"<S2SV_ModStart> goto partno ; if ( len >= sizeof <S2SV_ModEnd> ( tp -> <S2SV_ModStart> tp -> fw_ver ) ) len = sizeof <S2SV_ModEnd> ( tp -> <S2SV_ModStart> tp -> fw_ver ) - 1 ; memset ( tp -> fw_ver , 0 , sizeof ( tp -> fw_ver ) ) ; snprintf ( tp -> fw_ver , sizeof ( tp -> fw_ver ) , \"%.*s<S2SV_blank>bc<S2SV_blank>\" , len , & vpd_data [ j ] <S2SV_ModEnd> ) ; }\n","project_and_commit_id":"torvalds@linux/715230a44310a8cf66fbfb5a46f9a62a9b2de424","cve_id":"CVE-2013-1929","original_address":"https://github.com/torvalds/linux/commit/715230a44310a8cf66fbfb5a46f9a62a9b2de424","time":"2013-06-07T14:03Z"},
	{"Unnamed: 0":2280,"cwe_id":"CWE-125","source":"CWE-125 static void rx_cache_insert ( netdissect_options * ndo , const u_char * bp , const struct ip * ip , int dport ) { struct rx_cache_entry * rxent ; const struct rx_header * rxh = ( const struct rx_header * ) bp ; if ( ndo -> ndo_snapend - bp + 1 <= ( int ) ( sizeof ( struct rx_header ) + sizeof ( int32_t ) ) ) return ; rxent = & rx_cache [ rx_cache_next ] ; if ( ++ rx_cache_next >= RX_CACHE_SIZE ) rx_cache_next = 0 ; rxent -> callnum = EXTRACT_32BITS ( & rxh -> callNumber ) ; UNALIGNED_MEMCPY ( & rxent -> client , & ip -> ip_src , sizeof ( uint32_t ) ) ; UNALIGNED_MEMCPY ( & rxent -> server , & ip -> ip_dst , sizeof ( uint32_t ) ) ; rxent -> dport = dport ; <S2SV_StartBug> rxent -> serviceId = EXTRACT_32BITS ( & rxh -> serviceId ) ; <S2SV_EndBug> rxent -> opcode = EXTRACT_32BITS ( bp + sizeof ( struct rx_header ) ) ; }\n","target":"<S2SV_ModStart> -> serviceId = EXTRACT_16BITS <S2SV_ModEnd> ( & rxh\n","project_and_commit_id":"the-tcpdump-group@tcpdump/c24922e692a52121e853a84ead6b9337f4c08a94","cve_id":"CVE-2018-14466","original_address":"https://github.com/the-tcpdump-group/tcpdump/commit/c24922e692a52121e853a84ead6b9337f4c08a94","time":"2019-10-03T16:15Z"},
	{"Unnamed: 0":929,"cwe_id":"CWE-362","source":"CWE-362 void __kvm_migrate_pit_timer ( struct kvm_vcpu * vcpu ) { struct kvm_pit * pit = vcpu -> kvm -> arch . vpit ; struct hrtimer * timer ; if ( ! kvm_vcpu_is_bsp ( vcpu ) || ! pit ) return ; timer = & pit -> pit_state . timer ; <S2SV_StartBug> if ( hrtimer_cancel ( timer ) ) <S2SV_EndBug> hrtimer_start_expires ( timer , HRTIMER_MODE_ABS ) ; <S2SV_StartBug> } <S2SV_EndBug>\n","target":"<S2SV_ModStart> . timer ; mutex_lock ( & pit -> pit_state . lock ) ; <S2SV_ModStart> HRTIMER_MODE_ABS ) ; mutex_unlock ( & pit -> pit_state . lock ) ;\n","project_and_commit_id":"torvalds@linux/2febc839133280d5a5e8e1179c94ea674489dae2","cve_id":"CVE-2014-3611","original_address":"https://github.com/torvalds/linux/commit/2febc839133280d5a5e8e1179c94ea674489dae2","time":"2014-11-10T11:55Z"},
	{"Unnamed: 0":1300,"cwe_id":"CWE-119","source":"CWE-119 static int nci_extract_activation_params_iso_dep ( struct nci_dev * ndev , struct nci_rf_intf_activated_ntf * ntf , __u8 * data ) { struct activation_params_nfca_poll_iso_dep * nfca_poll ; struct activation_params_nfcb_poll_iso_dep * nfcb_poll ; switch ( ntf -> activation_rf_tech_and_mode ) { case NCI_NFC_A_PASSIVE_POLL_MODE : nfca_poll = & ntf -> activation_params . nfca_poll_iso_dep ; <S2SV_StartBug> nfca_poll -> rats_res_len = * data ++ ; <S2SV_EndBug> pr_debug ( \"rats_res_len<S2SV_blank>%d\\\\n\" , nfca_poll -> rats_res_len ) ; if ( nfca_poll -> rats_res_len > 0 ) { memcpy ( nfca_poll -> rats_res , data , nfca_poll -> rats_res_len ) ; } break ; case NCI_NFC_B_PASSIVE_POLL_MODE : nfcb_poll = & ntf -> activation_params . nfcb_poll_iso_dep ; <S2SV_StartBug> nfcb_poll -> attrib_res_len = * data ++ ; <S2SV_EndBug> pr_debug ( \"attrib_res_len<S2SV_blank>%d\\\\n\" , nfcb_poll -> attrib_res_len ) ; if ( nfcb_poll -> attrib_res_len > 0 ) { memcpy ( nfcb_poll -> attrib_res , data , nfcb_poll -> attrib_res_len ) ; } break ; default : pr_err ( \"unsupported<S2SV_blank>activation_rf_tech_and_mode<S2SV_blank>0x%x\\\\n\" , ntf -> activation_rf_tech_and_mode ) ; return NCI_STATUS_RF_PROTOCOL_ERROR ; } return NCI_STATUS_OK ; }\n","target":"<S2SV_ModStart> -> rats_res_len = min_t ( __u8 , <S2SV_ModStart> * data ++ , 20 ) <S2SV_ModStart> -> attrib_res_len = min_t ( __u8 , <S2SV_ModStart> * data ++ , 50 )\n","project_and_commit_id":"torvalds@linux/67de956ff5dc1d4f321e16cfbd63f5be3b691b43","cve_id":"CVE-2012-3364","original_address":"https://github.com/torvalds/linux/commit/67de956ff5dc1d4f321e16cfbd63f5be3b691b43","time":"2013-01-22T23:55Z"},
	{"Unnamed: 0":5679,"cwe_id":"CWE-404","source":"CWE-404 static void cp2112_gpio_set ( struct gpio_chip * chip , unsigned offset , int value ) { struct cp2112_device * dev = gpiochip_get_data ( chip ) ; struct hid_device * hdev = dev -> hdev ; u8 * buf = dev -> in_out_buffer ; <S2SV_StartBug> unsigned long flags ; <S2SV_EndBug> int ret ; <S2SV_StartBug> spin_lock_irqsave ( & dev -> lock , flags ) ; <S2SV_EndBug> buf [ 0 ] = CP2112_GPIO_SET ; buf [ 1 ] = value ? 0xff : 0 ; buf [ 2 ] = 1 << offset ; ret = hid_hw_raw_request ( hdev , CP2112_GPIO_SET , buf , CP2112_GPIO_SET_LENGTH , HID_FEATURE_REPORT , HID_REQ_SET_REPORT ) ; if ( ret < 0 ) hid_err ( hdev , \"error<S2SV_blank>setting<S2SV_blank>GPIO<S2SV_blank>values:<S2SV_blank>%d\\\\n\" , ret ) ; <S2SV_StartBug> spin_unlock_irqrestore ( & dev -> lock , flags ) ; <S2SV_EndBug> }\n","target":"<S2SV_ModStart> -> in_out_buffer ; <S2SV_ModEnd> int ret ; <S2SV_ModStart> int ret ; mutex_lock <S2SV_ModEnd> ( & dev <S2SV_ModStart> dev -> lock <S2SV_ModEnd> ) ; buf <S2SV_ModStart> ret ) ; mutex_unlock <S2SV_ModEnd> ( & dev <S2SV_ModStart> dev -> lock <S2SV_ModEnd> ) ; }\n","project_and_commit_id":"torvalds@linux/7a7b5df84b6b4e5d599c7289526eed96541a0654","cve_id":"CVE-2017-8071","original_address":"https://github.com/torvalds/linux/commit/7a7b5df84b6b4e5d599c7289526eed96541a0654","time":"2017-04-23T05:59Z"},
	{"Unnamed: 0":2067,"cwe_id":"CWE-88","source":"CWE-88 static int fsck_gitmodules_fn ( const char * var , const char * value , void * vdata ) { struct fsck_gitmodules_data * data = vdata ; const char * subsection , * key ; int subsection_len ; char * name ; if ( parse_config_key ( var , \"submodule\" , & subsection , & subsection_len , & key ) < 0 || ! subsection ) return 0 ; name = xmemdupz ( subsection , subsection_len ) ; if ( check_submodule_name ( name ) < 0 ) data -> ret |= report ( data -> options , data -> obj , FSCK_MSG_GITMODULES_NAME , \"disallowed<S2SV_blank>submodule<S2SV_blank>name:<S2SV_blank>%s\" , name ) ; <S2SV_StartBug> free ( name ) ; <S2SV_EndBug> return 0 ; }\n","target":"<S2SV_ModStart> name ) ; if ( ! strcmp ( key , \"url\" ) && value && looks_like_command_line_option ( value ) ) data -> ret |= report ( data -> options , data -> obj , FSCK_MSG_GITMODULES_URL , \"disallowed<S2SV_blank>submodule<S2SV_blank>url:<S2SV_blank>%s\" , value ) ;\n","project_and_commit_id":"git@git/a124133e1e6ab5c7a9fef6d0e6bcb084e3455b46","cve_id":"CVE-2018-17456","original_address":"https://github.com/git/git/commit/a124133e1e6ab5c7a9fef6d0e6bcb084e3455b46","time":"2018-10-06T14:29Z"},
	{"Unnamed: 0":1983,"cwe_id":"CWE-125","source":"CWE-125 const char * linkaddr_string ( netdissect_options * ndo , const u_char * ep , const unsigned int type , const unsigned int len ) { register u_int i ; register char * cp ; <S2SV_StartBug> register struct enamemem * tp ; <S2SV_EndBug> if ( len == 0 ) return ( \"<empty>\" ) ; if ( type == LINKADDR_ETHER && len == ETHER_ADDR_LEN ) return ( etheraddr_string ( ndo , ep ) ) ; if ( type == LINKADDR_FRELAY ) return ( q922_string ( ndo , ep , len ) ) ; tp = lookup_bytestring ( ndo , ep , len ) ; <S2SV_StartBug> if ( tp -> e_name ) <S2SV_EndBug> return ( tp -> e_name ) ; tp -> e_name = cp = ( char * ) malloc ( len * 3 ) ; <S2SV_StartBug> if ( tp -> e_name == NULL ) <S2SV_EndBug> ( * ndo -> ndo_error ) ( ndo , \"linkaddr_string:<S2SV_blank>malloc\" ) ; * cp ++ = hex [ * ep >> 4 ] ; * cp ++ = hex [ * ep ++ & 0xf ] ; for ( i = len - 1 ; i > 0 ; -- i ) { * cp ++ = ':' ; * cp ++ = hex [ * ep >> 4 ] ; * cp ++ = hex [ * ep ++ & 0xf ] ; } * cp = '\\\\0' ; <S2SV_StartBug> return ( tp -> e_name ) ; <S2SV_EndBug> }\n","target":"<S2SV_ModStart> ; register struct bsnamemem <S2SV_ModEnd> * tp ; <S2SV_ModStart> ( tp -> bs_name ) return ( tp -> bs_name ) ; tp -> bs_name <S2SV_ModEnd> = cp = <S2SV_ModStart> ( tp -> bs_name <S2SV_ModEnd> == NULL ) <S2SV_ModStart> ( tp -> bs_name <S2SV_ModEnd> ) ; }\n","project_and_commit_id":"the-tcpdump-group@tcpdump/730fc35968c5433b9e2a829779057f4f9495dc51","cve_id":"CVE-2017-12894","original_address":"https://github.com/the-tcpdump-group/tcpdump/commit/730fc35968c5433b9e2a829779057f4f9495dc51","time":"2017-09-14T06:29Z"},
	{"Unnamed: 0":6411,"cwe_id":"CWE-200","source":"CWE-200 int x25_negotiate_facilities ( struct sk_buff * skb , struct sock * sk , struct x25_facilities * new , struct x25_dte_facilities * dte ) { struct x25_sock * x25 = x25_sk ( sk ) ; struct x25_facilities * ours = & x25 -> facilities ; struct x25_facilities theirs ; int len ; memset ( & theirs , 0 , sizeof ( theirs ) ) ; <S2SV_StartBug> memcpy ( new , ours , sizeof ( * new ) ) ; <S2SV_EndBug> len = x25_parse_facilities ( skb , & theirs , dte , & x25 -> vc_facil_mask ) ; if ( len < 0 ) return len ; if ( ( theirs . reverse & 0x01 ) && ( ours -> reverse & 0x01 ) ) { SOCK_DEBUG ( sk , \"X.25:<S2SV_blank>rejecting<S2SV_blank>reverse<S2SV_blank>charging<S2SV_blank>request\\\\n\" ) ; return - 1 ; } new -> reverse = theirs . reverse ; if ( theirs . throughput ) { int theirs_in = theirs . throughput & 0x0f ; int theirs_out = theirs . throughput & 0xf0 ; int ours_in = ours -> throughput & 0x0f ; int ours_out = ours -> throughput & 0xf0 ; if ( ! ours_in || theirs_in < ours_in ) { SOCK_DEBUG ( sk , \"X.25:<S2SV_blank>inbound<S2SV_blank>throughput<S2SV_blank>negotiated\\\\n\" ) ; new -> throughput = ( new -> throughput & 0xf0 ) | theirs_in ; } if ( ! ours_out || theirs_out < ours_out ) { SOCK_DEBUG ( sk , \"X.25:<S2SV_blank>outbound<S2SV_blank>throughput<S2SV_blank>negotiated\\\\n\" ) ; new -> throughput = ( new -> throughput & 0x0f ) | theirs_out ; } } if ( theirs . pacsize_in && theirs . pacsize_out ) { if ( theirs . pacsize_in < ours -> pacsize_in ) { SOCK_DEBUG ( sk , \"X.25:<S2SV_blank>packet<S2SV_blank>size<S2SV_blank>inwards<S2SV_blank>negotiated<S2SV_blank>down\\\\n\" ) ; new -> pacsize_in = theirs . pacsize_in ; } if ( theirs . pacsize_out < ours -> pacsize_out ) { SOCK_DEBUG ( sk , \"X.25:<S2SV_blank>packet<S2SV_blank>size<S2SV_blank>outwards<S2SV_blank>negotiated<S2SV_blank>down\\\\n\" ) ; new -> pacsize_out = theirs . pacsize_out ; } } if ( theirs . winsize_in && theirs . winsize_out ) { if ( theirs . winsize_in < ours -> winsize_in ) { SOCK_DEBUG ( sk , \"X.25:<S2SV_blank>window<S2SV_blank>size<S2SV_blank>inwards<S2SV_blank>negotiated<S2SV_blank>down\\\\n\" ) ; new -> winsize_in = theirs . winsize_in ; } if ( theirs . winsize_out < ours -> winsize_out ) { SOCK_DEBUG ( sk , \"X.25:<S2SV_blank>window<S2SV_blank>size<S2SV_blank>outwards<S2SV_blank>negotiated<S2SV_blank>down\\\\n\" ) ; new -> winsize_out = theirs . winsize_out ; } } return len ; }\n","target":"<S2SV_ModStart> ( * new ) ) ; memset ( dte , 0 , sizeof ( * dte\n","project_and_commit_id":"torvalds@linux/79e48650320e6fba48369fccf13fd045315b19b8","cve_id":"CVE-2016-4580","original_address":"https://github.com/torvalds/linux/commit/79e48650320e6fba48369fccf13fd045315b19b8","time":"2016-05-23T10:59Z"},
	{"Unnamed: 0":1669,"cwe_id":"CWE-119","source":"CWE-119 <S2SV_StartBug> void vp9_predict_intra_block ( const MACROBLOCKD * xd , int block_idx , int bwl_in , <S2SV_EndBug> <S2SV_StartBug> TX_SIZE tx_size , MB_PREDICTION_MODE mode , <S2SV_EndBug> const uint8_t * ref , int ref_stride , uint8_t * dst , int dst_stride , int aoff , int loff , int plane ) { <S2SV_StartBug> const int bwl = bwl_in - tx_size ; <S2SV_EndBug> <S2SV_StartBug> const int wmask = ( 1 << bwl ) - 1 ; <S2SV_EndBug> <S2SV_StartBug> const int have_top = ( block_idx >> bwl ) || xd -> up_available ; <S2SV_EndBug> <S2SV_StartBug> const int have_left = ( block_idx & wmask ) || xd -> left_available ; <S2SV_EndBug> const int have_right = ( ( block_idx & wmask ) != wmask ) ; const int x = aoff * 4 ; const int y = loff * 4 ; assert ( bwl >= 0 ) ; build_intra_predictors ( xd , ref , ref_stride , dst , dst_stride , mode , tx_size , have_top , have_left , have_right , x , y , plane ) ; }\n","target":"<S2SV_ModStart> xd , int <S2SV_ModEnd> bwl_in , TX_SIZE <S2SV_ModStart> TX_SIZE tx_size , PREDICTION_MODE <S2SV_ModEnd> mode , const <S2SV_ModStart> { const int bw <S2SV_ModEnd> = ( 1 <S2SV_ModStart> ( 1 << bwl_in ) ; const int txw = ( 1 << tx_size ) <S2SV_ModEnd> ; const int <S2SV_ModStart> int have_top = loff <S2SV_ModEnd> || xd -> <S2SV_ModStart> int have_left = aoff || xd -> left_available ; const int have_right = ( aoff + txw ) < bw ; const int x = aoff * 4 ; const int y = loff * 4 ; # if CONFIG_VP9_HIGHBITDEPTH if ( xd -> cur_buf -> flags & YV12_FLAG_HIGHBITDEPTH ) { build_intra_predictors_high ( xd , ref , ref_stride , dst , dst_stride , mode , tx_size , have_top , have_left , have_right , x , y , plane , xd -> bd ) ; return ; } # endif <S2SV_ModEnd> build_intra_predictors ( xd\n","project_and_commit_id":"external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426","cve_id":"CVE-2016-1621","original_address":"https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426","time":"2016-03-12T21:59Z"},
	{"Unnamed: 0":5009,"cwe_id":"CWE-369","source":"CWE-369 tmsize_t TIFFReadEncodedStrip ( TIFF * tif , uint32 strip , void * buf , tmsize_t size ) { static const char module [ ] = \"TIFFReadEncodedStrip\" ; TIFFDirectory * td = & tif -> tif_dir ; uint32 rowsperstrip ; uint32 stripsperplane ; uint32 stripinplane ; uint16 plane ; uint32 rows ; tmsize_t stripsize ; if ( ! TIFFCheckRead ( tif , 0 ) ) return ( ( tmsize_t ) ( - 1 ) ) ; if ( strip >= td -> td_nstrips ) { TIFFErrorExt ( tif -> tif_clientdata , module , \"%lu:<S2SV_blank>Strip<S2SV_blank>out<S2SV_blank>of<S2SV_blank>range,<S2SV_blank>max<S2SV_blank>%lu\" , ( unsigned long ) strip , ( unsigned long ) td -> td_nstrips ) ; return ( ( tmsize_t ) ( - 1 ) ) ; } rowsperstrip = td -> td_rowsperstrip ; if ( rowsperstrip > td -> td_imagelength ) rowsperstrip = td -> td_imagelength ; <S2SV_StartBug> stripsperplane = ( ( td -> td_imagelength + rowsperstrip - 1 ) / rowsperstrip ) ; <S2SV_EndBug> stripinplane = ( strip % stripsperplane ) ; plane = ( uint16 ) ( strip / stripsperplane ) ; rows = td -> td_imagelength - stripinplane * rowsperstrip ; if ( rows > rowsperstrip ) rows = rowsperstrip ; stripsize = TIFFVStripSize ( tif , rows ) ; if ( stripsize == 0 ) return ( ( tmsize_t ) ( - 1 ) ) ; if ( td -> td_compression == COMPRESSION_NONE && size != ( tmsize_t ) ( - 1 ) && size >= stripsize && ! isMapped ( tif ) && ( ( tif -> tif_flags & TIFF_NOREADRAW ) == 0 ) ) { if ( TIFFReadRawStrip1 ( tif , strip , buf , stripsize , module ) != stripsize ) return ( ( tmsize_t ) ( - 1 ) ) ; if ( ! isFillOrder ( tif , td -> td_fillorder ) && ( tif -> tif_flags & TIFF_NOBITREV ) == 0 ) TIFFReverseBits ( buf , stripsize ) ; ( * tif -> tif_postdecode ) ( tif , buf , stripsize ) ; return ( stripsize ) ; } if ( ( size != ( tmsize_t ) ( - 1 ) ) && ( size < stripsize ) ) stripsize = size ; if ( ! TIFFFillStrip ( tif , strip ) ) return ( ( tmsize_t ) ( - 1 ) ) ; if ( ( * tif -> tif_decodestrip ) ( tif , buf , stripsize , plane ) <= 0 ) return ( ( tmsize_t ) ( - 1 ) ) ; ( * tif -> tif_postdecode ) ( tif , buf , stripsize ) ; return ( stripsize ) ; }\n","target":"<S2SV_ModStart> ; stripsperplane = TIFFhowmany_32_maxuint_compat <S2SV_ModEnd> ( td -> <S2SV_ModStart> td -> td_imagelength , <S2SV_ModEnd> rowsperstrip ) ;\n","project_and_commit_id":"vadz@libtiff/438274f938e046d33cb0e1230b41da32ffe223e1","cve_id":"CVE-2016-10266","original_address":"https://github.com/vadz/libtiff/commit/438274f938e046d33cb0e1230b41da32ffe223e1","time":"2017-03-24T19:59Z"},
	{"Unnamed: 0":278,"cwe_id":"CWE-190","source":"CWE-190 static void * zend_mm_realloc_heap ( zend_mm_heap * heap , void * ptr , size_t size , size_t copy_size ZEND_FILE_LINE_DC ZEND_FILE_LINE_ORIG_DC ) { size_t page_offset ; size_t old_size ; size_t new_size ; void * ret ; # if ZEND_DEBUG size_t real_size ; zend_mm_debug_info * dbg ; # endif page_offset = ZEND_MM_ALIGNED_OFFSET ( ptr , ZEND_MM_CHUNK_SIZE ) ; if ( UNEXPECTED ( page_offset == 0 ) ) { if ( UNEXPECTED ( ptr == NULL ) ) { return zend_mm_alloc_heap ( heap , size ZEND_FILE_LINE_RELAY_CC ZEND_FILE_LINE_ORIG_RELAY_CC ) ; } old_size = zend_mm_get_huge_block_size ( heap , ptr ZEND_FILE_LINE_RELAY_CC ZEND_FILE_LINE_ORIG_RELAY_CC ) ; # if ZEND_DEBUG real_size = size ; size = ZEND_MM_ALIGNED_SIZE ( size ) + ZEND_MM_ALIGNED_SIZE ( sizeof ( zend_mm_debug_info ) ) ; # endif if ( size > ZEND_MM_MAX_LARGE_SIZE ) { # if ZEND_DEBUG size = real_size ; # endif # ifdef ZEND_WIN32 new_size = ZEND_MM_ALIGNED_SIZE_EX ( size , MAX ( REAL_PAGE_SIZE , ZEND_MM_CHUNK_SIZE ) ) ; # else new_size = ZEND_MM_ALIGNED_SIZE_EX ( size , REAL_PAGE_SIZE ) ; # endif if ( new_size == old_size ) { # if ZEND_DEBUG zend_mm_change_huge_block_size ( heap , ptr , new_size , real_size ZEND_FILE_LINE_RELAY_CC ZEND_FILE_LINE_ORIG_RELAY_CC ) ; # else zend_mm_change_huge_block_size ( heap , ptr , new_size ZEND_FILE_LINE_RELAY_CC ZEND_FILE_LINE_ORIG_RELAY_CC ) ; # endif return ptr ; } else if ( new_size < old_size ) { if ( zend_mm_chunk_truncate ( heap , ptr , old_size , new_size ) ) { # if ZEND_MM_STAT || ZEND_MM_LIMIT heap -> real_size -= old_size - new_size ; # endif # if ZEND_MM_STAT heap -> size -= old_size - new_size ; # endif # if ZEND_DEBUG zend_mm_change_huge_block_size ( heap , ptr , new_size , real_size ZEND_FILE_LINE_RELAY_CC ZEND_FILE_LINE_ORIG_RELAY_CC ) ; # else zend_mm_change_huge_block_size ( heap , ptr , new_size ZEND_FILE_LINE_RELAY_CC ZEND_FILE_LINE_ORIG_RELAY_CC ) ; # endif return ptr ; } } else { # if ZEND_MM_LIMIT if ( UNEXPECTED ( heap -> real_size + ( new_size - old_size ) > heap -> limit ) ) { if ( zend_mm_gc ( heap ) && heap -> real_size + ( new_size - old_size ) <= heap -> limit ) { } else if ( heap -> overflow == 0 ) { # if ZEND_DEBUG zend_mm_safe_error ( heap , \"Allowed<S2SV_blank>memory<S2SV_blank>size<S2SV_blank>of<S2SV_blank>%zu<S2SV_blank>bytes<S2SV_blank>exhausted<S2SV_blank>at<S2SV_blank>%s:%d<S2SV_blank>(tried<S2SV_blank>to<S2SV_blank>allocate<S2SV_blank>%zu<S2SV_blank>bytes)\" , heap -> limit , __zend_filename , __zend_lineno , size ) ; # else zend_mm_safe_error ( heap , \"Allowed<S2SV_blank>memory<S2SV_blank>size<S2SV_blank>of<S2SV_blank>%zu<S2SV_blank>bytes<S2SV_blank>exhausted<S2SV_blank>(tried<S2SV_blank>to<S2SV_blank>allocate<S2SV_blank>%zu<S2SV_blank>bytes)\" , heap -> limit , size ) ; # endif return NULL ; } } # endif if ( zend_mm_chunk_extend ( heap , ptr , old_size , new_size ) ) { # if ZEND_MM_STAT || ZEND_MM_LIMIT heap -> real_size += new_size - old_size ; # endif # if ZEND_MM_STAT heap -> real_peak = MAX ( heap -> real_peak , heap -> real_size ) ; heap -> size += new_size - old_size ; heap -> peak = MAX ( heap -> peak , heap -> size ) ; # endif # if ZEND_DEBUG zend_mm_change_huge_block_size ( heap , ptr , new_size , real_size ZEND_FILE_LINE_RELAY_CC ZEND_FILE_LINE_ORIG_RELAY_CC ) ; # else zend_mm_change_huge_block_size ( heap , ptr , new_size ZEND_FILE_LINE_RELAY_CC ZEND_FILE_LINE_ORIG_RELAY_CC ) ; # endif return ptr ; } } } } else { zend_mm_chunk * chunk = ( zend_mm_chunk * ) ZEND_MM_ALIGNED_BASE ( ptr , ZEND_MM_CHUNK_SIZE ) ; int page_num = ( int ) ( page_offset / ZEND_MM_PAGE_SIZE ) ; zend_mm_page_info info = chunk -> map [ page_num ] ; # if ZEND_DEBUG size_t real_size = size ; size = ZEND_MM_ALIGNED_SIZE ( size ) + ZEND_MM_ALIGNED_SIZE ( sizeof ( zend_mm_debug_info ) ) ; # endif ZEND_MM_CHECK ( chunk -> heap == heap , \"zend_mm_heap<S2SV_blank>corrupted\" ) ; if ( info & ZEND_MM_IS_SRUN ) { <S2SV_StartBug> int old_bin_num , bin_num ; <S2SV_EndBug> old_bin_num = ZEND_MM_SRUN_BIN_NUM ( info ) ; old_size = bin_data_size [ old_bin_num ] ; <S2SV_StartBug> bin_num = ZEND_MM_SMALL_SIZE_TO_BIN ( size ) ; <S2SV_EndBug> if ( old_bin_num == bin_num ) { # if ZEND_DEBUG dbg = zend_mm_get_debug_info ( heap , ptr ) ; dbg -> size = real_size ; dbg -> filename = __zend_filename ; dbg -> orig_filename = __zend_orig_filename ; dbg -> lineno = __zend_lineno ; dbg -> orig_lineno = __zend_orig_lineno ; # endif <S2SV_StartBug> return ptr ; <S2SV_EndBug> } } else { ZEND_MM_CHECK ( ZEND_MM_ALIGNED_OFFSET ( page_offset , ZEND_MM_PAGE_SIZE ) == 0 , \"zend_mm_heap<S2SV_blank>corrupted\" ) ; old_size = ZEND_MM_LRUN_PAGES ( info ) * ZEND_MM_PAGE_SIZE ; if ( size > ZEND_MM_MAX_SMALL_SIZE && size <= ZEND_MM_MAX_LARGE_SIZE ) { new_size = ZEND_MM_ALIGNED_SIZE_EX ( size , ZEND_MM_PAGE_SIZE ) ; if ( new_size == old_size ) { # if ZEND_DEBUG dbg = zend_mm_get_debug_info ( heap , ptr ) ; dbg -> size = real_size ; dbg -> filename = __zend_filename ; dbg -> orig_filename = __zend_orig_filename ; dbg -> lineno = __zend_lineno ; dbg -> orig_lineno = __zend_orig_lineno ; # endif return ptr ; } else if ( new_size < old_size ) { int new_pages_count = ( int ) ( new_size / ZEND_MM_PAGE_SIZE ) ; int rest_pages_count = ( int ) ( ( old_size - new_size ) / ZEND_MM_PAGE_SIZE ) ; # if ZEND_MM_STAT heap -> size -= rest_pages_count * ZEND_MM_PAGE_SIZE ; # endif chunk -> map [ page_num ] = ZEND_MM_LRUN ( new_pages_count ) ; chunk -> free_pages += rest_pages_count ; zend_mm_bitset_reset_range ( chunk -> free_map , page_num + new_pages_count , rest_pages_count ) ; # if ZEND_DEBUG dbg = zend_mm_get_debug_info ( heap , ptr ) ; dbg -> size = real_size ; dbg -> filename = __zend_filename ; dbg -> orig_filename = __zend_orig_filename ; dbg -> lineno = __zend_lineno ; dbg -> orig_lineno = __zend_orig_lineno ; # endif return ptr ; } else { int new_pages_count = ( int ) ( new_size / ZEND_MM_PAGE_SIZE ) ; int old_pages_count = ( int ) ( old_size / ZEND_MM_PAGE_SIZE ) ; if ( page_num + new_pages_count <= ZEND_MM_PAGES && zend_mm_bitset_is_free_range ( chunk -> free_map , page_num + old_pages_count , new_pages_count - old_pages_count ) ) { # if ZEND_MM_STAT do { size_t size = heap -> size + ( new_size - old_size ) ; size_t peak = MAX ( heap -> peak , size ) ; heap -> size = size ; heap -> peak = peak ; } while ( 0 ) ; # endif chunk -> free_pages -= new_pages_count - old_pages_count ; zend_mm_bitset_set_range ( chunk -> free_map , page_num + old_pages_count , new_pages_count - old_pages_count ) ; chunk -> map [ page_num ] = ZEND_MM_LRUN ( new_pages_count ) ; # if ZEND_DEBUG dbg = zend_mm_get_debug_info ( heap , ptr ) ; dbg -> size = real_size ; dbg -> filename = __zend_filename ; dbg -> orig_filename = __zend_orig_filename ; dbg -> lineno = __zend_lineno ; dbg -> orig_lineno = __zend_orig_lineno ; # endif return ptr ; } } } } # if ZEND_DEBUG size = real_size ; # endif } # if ZEND_MM_STAT do { size_t orig_peak = heap -> peak ; size_t orig_real_peak = heap -> real_peak ; # endif ret = zend_mm_alloc_heap ( heap , size ZEND_FILE_LINE_RELAY_CC ZEND_FILE_LINE_ORIG_RELAY_CC ) ; memcpy ( ret , ptr , MIN ( old_size , copy_size ) ) ; zend_mm_free_heap ( heap , ptr ZEND_FILE_LINE_RELAY_CC ZEND_FILE_LINE_ORIG_RELAY_CC ) ; # if ZEND_MM_STAT heap -> peak = MAX ( orig_peak , heap -> size ) ; heap -> real_peak = MAX ( orig_real_peak , heap -> real_size ) ; } while ( 0 ) ; # endif return ret ; }\n","target":"<S2SV_ModStart> { int old_bin_num <S2SV_ModEnd> = ZEND_MM_SRUN_BIN_NUM ( <S2SV_ModStart> old_bin_num ] ; if ( size <= ZEND_MM_MAX_SMALL_SIZE ) { int <S2SV_ModStart> return ptr ; }\n","project_and_commit_id":"php@php-src/c2a13ced4272f2e65d2773e2ea6ca11c1ce4a911","cve_id":"CVE-2016-7133","original_address":"https://github.com/php/php-src/commit/c2a13ced4272f2e65d2773e2ea6ca11c1ce4a911?w=1","time":"2016-09-12T01:59Z"},
	{"Unnamed: 0":1235,"cwe_id":"CWE-119","source":"CWE-119 void vp9_adapt_mode_probs ( VP9_COMMON * cm ) { int i , j ; <S2SV_StartBug> FRAME_CONTEXT * fc = & cm -> fc ; <S2SV_EndBug> const FRAME_CONTEXT * pre_fc = & cm -> frame_contexts [ cm -> frame_context_idx ] ; const FRAME_COUNTS * counts = & cm -> counts ; for ( i = 0 ; i < INTRA_INTER_CONTEXTS ; i ++ ) <S2SV_StartBug> fc -> intra_inter_prob [ i ] = adapt_prob ( pre_fc -> intra_inter_prob [ i ] , <S2SV_EndBug> counts -> intra_inter [ i ] ) ; for ( i = 0 ; i < COMP_INTER_CONTEXTS ; i ++ ) <S2SV_StartBug> fc -> comp_inter_prob [ i ] = adapt_prob ( pre_fc -> comp_inter_prob [ i ] , <S2SV_EndBug> counts -> comp_inter [ i ] ) ; for ( i = 0 ; i < REF_CONTEXTS ; i ++ ) <S2SV_StartBug> fc -> comp_ref_prob [ i ] = adapt_prob ( pre_fc -> comp_ref_prob [ i ] , <S2SV_EndBug> counts -> comp_ref [ i ] ) ; for ( i = 0 ; i < REF_CONTEXTS ; i ++ ) for ( j = 0 ; j < 2 ; j ++ ) <S2SV_StartBug> fc -> single_ref_prob [ i ] [ j ] = adapt_prob ( pre_fc -> single_ref_prob [ i ] [ j ] , <S2SV_EndBug> counts -> single_ref [ i ] [ j ] ) ; for ( i = 0 ; i < INTER_MODE_CONTEXTS ; i ++ ) <S2SV_StartBug> adapt_probs ( vp9_inter_mode_tree , pre_fc -> inter_mode_probs [ i ] , <S2SV_EndBug> counts -> inter_mode [ i ] , fc -> inter_mode_probs [ i ] ) ; for ( i = 0 ; i < BLOCK_SIZE_GROUPS ; i ++ ) <S2SV_StartBug> adapt_probs ( vp9_intra_mode_tree , pre_fc -> y_mode_prob [ i ] , <S2SV_EndBug> counts -> y_mode [ i ] , fc -> y_mode_prob [ i ] ) ; for ( i = 0 ; i < INTRA_MODES ; ++ i ) <S2SV_StartBug> adapt_probs ( vp9_intra_mode_tree , pre_fc -> uv_mode_prob [ i ] , <S2SV_EndBug> counts -> uv_mode [ i ] , fc -> uv_mode_prob [ i ] ) ; for ( i = 0 ; i < PARTITION_CONTEXTS ; i ++ ) <S2SV_StartBug> adapt_probs ( vp9_partition_tree , pre_fc -> partition_prob [ i ] , <S2SV_EndBug> counts -> partition [ i ] , fc -> partition_prob [ i ] ) ; if ( cm -> interp_filter == SWITCHABLE ) { for ( i = 0 ; i < SWITCHABLE_FILTER_CONTEXTS ; i ++ ) <S2SV_StartBug> adapt_probs ( vp9_switchable_interp_tree , pre_fc -> switchable_interp_prob [ i ] , <S2SV_EndBug> counts -> switchable_interp [ i ] , fc -> switchable_interp_prob [ i ] ) ; } if ( cm -> tx_mode == TX_MODE_SELECT ) { int j ; unsigned int branch_ct_8x8p [ TX_SIZES - 3 ] [ 2 ] ; unsigned int branch_ct_16x16p [ TX_SIZES - 2 ] [ 2 ] ; unsigned int branch_ct_32x32p [ TX_SIZES - 1 ] [ 2 ] ; for ( i = 0 ; i < TX_SIZE_CONTEXTS ; ++ i ) { tx_counts_to_branch_counts_8x8 ( counts -> tx . p8x8 [ i ] , branch_ct_8x8p ) ; for ( j = 0 ; j < TX_SIZES - 3 ; ++ j ) <S2SV_StartBug> fc -> tx_probs . p8x8 [ i ] [ j ] = adapt_prob ( pre_fc -> tx_probs . p8x8 [ i ] [ j ] , <S2SV_EndBug> branch_ct_8x8p [ j ] ) ; tx_counts_to_branch_counts_16x16 ( counts -> tx . p16x16 [ i ] , branch_ct_16x16p ) ; for ( j = 0 ; j < TX_SIZES - 2 ; ++ j ) <S2SV_StartBug> fc -> tx_probs . p16x16 [ i ] [ j ] = adapt_prob ( pre_fc -> tx_probs . p16x16 [ i ] [ j ] , <S2SV_EndBug> branch_ct_16x16p [ j ] ) ; tx_counts_to_branch_counts_32x32 ( counts -> tx . p32x32 [ i ] , branch_ct_32x32p ) ; for ( j = 0 ; j < TX_SIZES - 1 ; ++ j ) <S2SV_StartBug> fc -> tx_probs . p32x32 [ i ] [ j ] = adapt_prob ( pre_fc -> tx_probs . p32x32 [ i ] [ j ] , <S2SV_EndBug> branch_ct_32x32p [ j ] ) ; } } for ( i = 0 ; i < SKIP_CONTEXTS ; ++ i ) <S2SV_StartBug> fc -> skip_probs [ i ] = adapt_prob ( pre_fc -> skip_probs [ i ] , counts -> skip [ i ] ) ; <S2SV_EndBug> }\n","target":"<S2SV_ModStart> * fc = <S2SV_ModEnd> cm -> fc <S2SV_ModStart> i ] = mode_mv_merge_probs <S2SV_ModEnd> ( pre_fc -> <S2SV_ModStart> i ] = mode_mv_merge_probs <S2SV_ModEnd> ( pre_fc -> <S2SV_ModStart> i ] = mode_mv_merge_probs <S2SV_ModEnd> ( pre_fc -> <S2SV_ModStart> j ] = mode_mv_merge_probs ( <S2SV_ModEnd> pre_fc -> single_ref_prob <S2SV_ModStart> i ++ ) vpx_tree_merge_probs <S2SV_ModEnd> ( vp9_inter_mode_tree , <S2SV_ModStart> i ++ ) vpx_tree_merge_probs <S2SV_ModEnd> ( vp9_intra_mode_tree , <S2SV_ModStart> ++ i ) vpx_tree_merge_probs <S2SV_ModEnd> ( vp9_intra_mode_tree , <S2SV_ModStart> i ++ ) vpx_tree_merge_probs <S2SV_ModEnd> ( vp9_partition_tree , <S2SV_ModStart> i ++ ) vpx_tree_merge_probs <S2SV_ModEnd> ( vp9_switchable_interp_tree , <S2SV_ModStart> j ] = mode_mv_merge_probs ( <S2SV_ModEnd> pre_fc -> tx_probs <S2SV_ModStart> j ] = mode_mv_merge_probs ( <S2SV_ModEnd> pre_fc -> tx_probs <S2SV_ModStart> j ] = mode_mv_merge_probs ( <S2SV_ModEnd> pre_fc -> tx_probs <S2SV_ModStart> i ] = mode_mv_merge_probs ( <S2SV_ModEnd> pre_fc -> skip_probs\n","project_and_commit_id":"external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426","cve_id":"CVE-2016-1621","original_address":"https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426","time":"2016-03-12T21:59Z"},
	{"Unnamed: 0":4915,"cwe_id":"CWE-400","source":"CWE-400 static struct sk_buff * * gre_gro_receive ( struct sk_buff * * head , struct sk_buff * skb ) { struct sk_buff * * pp = NULL ; struct sk_buff * p ; const struct gre_base_hdr * greh ; unsigned int hlen , grehlen ; unsigned int off ; int flush = 1 ; struct packet_offload * ptype ; <S2SV_StartBug> __be16 type ; <S2SV_EndBug> off = skb_gro_offset ( skb ) ; hlen = off + sizeof ( * greh ) ; greh = skb_gro_header_fast ( skb , off ) ; if ( skb_gro_header_hard ( skb , hlen ) ) { greh = skb_gro_header_slow ( skb , hlen , off ) ; if ( unlikely ( ! greh ) ) goto out ; } if ( ( greh -> flags & ~ ( GRE_KEY | GRE_CSUM ) ) != 0 ) goto out ; type = greh -> protocol ; rcu_read_lock ( ) ; ptype = gro_find_receive_by_type ( type ) ; if ( ! ptype ) goto out_unlock ; grehlen = GRE_HEADER_SECTION ; if ( greh -> flags & GRE_KEY ) grehlen += GRE_HEADER_SECTION ; if ( greh -> flags & GRE_CSUM ) grehlen += GRE_HEADER_SECTION ; hlen = off + grehlen ; if ( skb_gro_header_hard ( skb , hlen ) ) { greh = skb_gro_header_slow ( skb , hlen , off ) ; if ( unlikely ( ! greh ) ) goto out_unlock ; } if ( ( greh -> flags & GRE_CSUM ) && ! NAPI_GRO_CB ( skb ) -> flush ) { if ( skb_gro_checksum_simple_validate ( skb ) ) goto out_unlock ; skb_gro_checksum_try_convert ( skb , IPPROTO_GRE , 0 , null_compute_pseudo ) ; } for ( p = * head ; p ; p = p -> next ) { const struct gre_base_hdr * greh2 ; if ( ! NAPI_GRO_CB ( p ) -> same_flow ) continue ; greh2 = ( struct gre_base_hdr * ) ( p -> data + off ) ; if ( greh2 -> flags != greh -> flags || greh2 -> protocol != greh -> protocol ) { NAPI_GRO_CB ( p ) -> same_flow = 0 ; continue ; } if ( greh -> flags & GRE_KEY ) { if ( * ( __be32 * ) ( greh2 + 1 ) != * ( __be32 * ) ( greh + 1 ) ) { NAPI_GRO_CB ( p ) -> same_flow = 0 ; continue ; } } } skb_gro_pull ( skb , grehlen ) ; skb_gro_postpull_rcsum ( skb , greh , grehlen ) ; pp = ptype -> callbacks . gro_receive ( head , skb ) ; flush = 0 ; out_unlock : rcu_read_unlock ( ) ; out : NAPI_GRO_CB ( skb ) -> flush |= flush ; return pp ; }\n","target":"<S2SV_ModStart> ; __be16 type ; if ( NAPI_GRO_CB ( skb ) -> encap_mark ) goto out ; NAPI_GRO_CB ( skb ) -> encap_mark = 1\n","project_and_commit_id":"torvalds@linux/fac8e0f579695a3ecbc4d3cac369139d7f819971","cve_id":"CVE-2016-8666","original_address":"https://github.com/torvalds/linux/commit/fac8e0f579695a3ecbc4d3cac369139d7f819971","time":"2016-10-16T21:59Z"},
	{"Unnamed: 0":4454,"cwe_id":"CWE-119","source":"CWE-119 static plist_t parse_string_node ( const char * * bnode , uint64_t size ) { plist_data_t data = plist_new_plist_data ( ) ; data -> type = PLIST_STRING ; data -> strval = ( char * ) malloc ( sizeof ( char ) * ( size + 1 ) ) ; <S2SV_StartBug> memcpy ( data -> strval , * bnode , size ) ; <S2SV_EndBug> data -> strval [ size ] = '\\\\0' ; data -> length = strlen ( data -> strval ) ; return node_create ( NULL , data ) ; }\n","target":"<S2SV_ModStart> ) ) ; if ( ! data -> strval ) { plist_free_data ( data ) ; PLIST_BIN_ERR ( \"%s:<S2SV_blank>Could<S2SV_blank>not<S2SV_blank>allocate<S2SV_blank>%\" PRIu64 \"<S2SV_blank>bytes\\\\n\" , __func__ , sizeof ( char ) * ( size + 1 ) ) ; return NULL ; }\n","project_and_commit_id":"libimobiledevice@libplist/fbd8494d5e4e46bf2e90cb6116903e404374fb56","cve_id":"CVE-2017-6435","original_address":"https://github.com/libimobiledevice/libplist/commit/fbd8494d5e4e46bf2e90cb6116903e404374fb56","time":"2017-03-15T14:59Z"},
	{"Unnamed: 0":2273,"cwe_id":"CWE-264","source":"CWE-264 <S2SV_StartBug> int xt_check_entry_offsets ( const void * base , <S2SV_EndBug> unsigned int target_offset , unsigned int next_offset ) { <S2SV_StartBug> const struct xt_entry_target * t ; <S2SV_EndBug> <S2SV_StartBug> const char * e = base ; <S2SV_EndBug> if ( target_offset + sizeof ( * t ) > next_offset ) return - EINVAL ; t = ( void * ) ( e + target_offset ) ; if ( t -> u . target_size < sizeof ( * t ) ) return - EINVAL ; if ( target_offset + t -> u . target_size > next_offset ) return - EINVAL ; if ( strcmp ( t -> u . user . name , XT_STANDARD_TARGET ) == 0 && target_offset + sizeof ( struct xt_standard_target ) != next_offset ) return - EINVAL ; return 0 ; }\n","target":"<S2SV_ModStart> void * base , const char * elems <S2SV_ModStart> next_offset ) { long size_of_base_struct = elems - ( const char * ) base ; <S2SV_ModStart> e = base ; if ( target_offset < size_of_base_struct ) return - EINVAL\n","project_and_commit_id":"torvalds@linux/ce683e5f9d045e5d67d1312a42b359cb2ab2a13c","cve_id":"CVE-2016-4997","original_address":"https://github.com/torvalds/linux/commit/ce683e5f9d045e5d67d1312a42b359cb2ab2a13c","time":"2016-07-03T21:59Z"},
	{"Unnamed: 0":2518,"cwe_id":"CWE-119","source":"CWE-119 static void tg3_read_vpd ( struct tg3 * tp ) { u8 * vpd_data ; unsigned int block_end , rosize , len ; u32 vpdlen ; int j , i = 0 ; vpd_data = ( u8 * ) tg3_vpd_readblock ( tp , & vpdlen ) ; if ( ! vpd_data ) goto out_no_vpd ; i = pci_vpd_find_tag ( vpd_data , 0 , vpdlen , PCI_VPD_LRDT_RO_DATA ) ; if ( i < 0 ) goto out_not_found ; rosize = pci_vpd_lrdt_size ( & vpd_data [ i ] ) ; block_end = i + PCI_VPD_LRDT_TAG_SIZE + rosize ; i += PCI_VPD_LRDT_TAG_SIZE ; if ( block_end > vpdlen ) goto out_not_found ; j = pci_vpd_find_info_keyword ( vpd_data , i , rosize , PCI_VPD_RO_KEYWORD_MFR_ID ) ; if ( j > 0 ) { len = pci_vpd_info_field_size ( & vpd_data [ j ] ) ; j += PCI_VPD_INFO_FLD_HDR_SIZE ; if ( j + len > block_end || len != 4 || memcmp ( & vpd_data [ j ] , \"1028\" , 4 ) ) goto partno ; j = pci_vpd_find_info_keyword ( vpd_data , i , rosize , PCI_VPD_RO_KEYWORD_VENDOR0 ) ; if ( j < 0 ) goto partno ; len = pci_vpd_info_field_size ( & vpd_data [ j ] ) ; j += PCI_VPD_INFO_FLD_HDR_SIZE ; if ( j + len > block_end ) goto partno ; <S2SV_StartBug> memcpy ( tp -> fw_ver , & vpd_data [ j ] , len ) ; <S2SV_EndBug> <S2SV_StartBug> strncat ( tp -> fw_ver , \"<S2SV_blank>bc<S2SV_blank>\" , vpdlen - len - 1 ) ; <S2SV_EndBug> } partno : i = pci_vpd_find_info_keyword ( vpd_data , i , rosize , PCI_VPD_RO_KEYWORD_PARTNO ) ; if ( i < 0 ) goto out_not_found ; len = pci_vpd_info_field_size ( & vpd_data [ i ] ) ; i += PCI_VPD_INFO_FLD_HDR_SIZE ; if ( len > TG3_BPN_SIZE || ( len + i ) > vpdlen ) goto out_not_found ; memcpy ( tp -> board_part_number , & vpd_data [ i ] , len ) ; out_not_found : kfree ( vpd_data ) ; if ( tp -> board_part_number [ 0 ] ) return ; out_no_vpd : if ( tg3_asic_rev ( tp ) == ASIC_REV_5717 ) { if ( tp -> pdev -> device == TG3PCI_DEVICE_TIGON3_5717 || tp -> pdev -> device == TG3PCI_DEVICE_TIGON3_5717_C ) strcpy ( tp -> board_part_number , \"BCM5717\" ) ; else if ( tp -> pdev -> device == TG3PCI_DEVICE_TIGON3_5718 ) strcpy ( tp -> board_part_number , \"BCM5718\" ) ; else goto nomatch ; } else if ( tg3_asic_rev ( tp ) == ASIC_REV_57780 ) { if ( tp -> pdev -> device == TG3PCI_DEVICE_TIGON3_57780 ) strcpy ( tp -> board_part_number , \"BCM57780\" ) ; else if ( tp -> pdev -> device == TG3PCI_DEVICE_TIGON3_57760 ) strcpy ( tp -> board_part_number , \"BCM57760\" ) ; else if ( tp -> pdev -> device == TG3PCI_DEVICE_TIGON3_57790 ) strcpy ( tp -> board_part_number , \"BCM57790\" ) ; else if ( tp -> pdev -> device == TG3PCI_DEVICE_TIGON3_57788 ) strcpy ( tp -> board_part_number , \"BCM57788\" ) ; else goto nomatch ; } else if ( tg3_asic_rev ( tp ) == ASIC_REV_57765 ) { if ( tp -> pdev -> device == TG3PCI_DEVICE_TIGON3_57761 ) strcpy ( tp -> board_part_number , \"BCM57761\" ) ; else if ( tp -> pdev -> device == TG3PCI_DEVICE_TIGON3_57765 ) strcpy ( tp -> board_part_number , \"BCM57765\" ) ; else if ( tp -> pdev -> device == TG3PCI_DEVICE_TIGON3_57781 ) strcpy ( tp -> board_part_number , \"BCM57781\" ) ; else if ( tp -> pdev -> device == TG3PCI_DEVICE_TIGON3_57785 ) strcpy ( tp -> board_part_number , \"BCM57785\" ) ; else if ( tp -> pdev -> device == TG3PCI_DEVICE_TIGON3_57791 ) strcpy ( tp -> board_part_number , \"BCM57791\" ) ; else if ( tp -> pdev -> device == TG3PCI_DEVICE_TIGON3_57795 ) strcpy ( tp -> board_part_number , \"BCM57795\" ) ; else goto nomatch ; } else if ( tg3_asic_rev ( tp ) == ASIC_REV_57766 ) { if ( tp -> pdev -> device == TG3PCI_DEVICE_TIGON3_57762 ) strcpy ( tp -> board_part_number , \"BCM57762\" ) ; else if ( tp -> pdev -> device == TG3PCI_DEVICE_TIGON3_57766 ) strcpy ( tp -> board_part_number , \"BCM57766\" ) ; else if ( tp -> pdev -> device == TG3PCI_DEVICE_TIGON3_57782 ) strcpy ( tp -> board_part_number , \"BCM57782\" ) ; else if ( tp -> pdev -> device == TG3PCI_DEVICE_TIGON3_57786 ) strcpy ( tp -> board_part_number , \"BCM57786\" ) ; else goto nomatch ; } else if ( tg3_asic_rev ( tp ) == ASIC_REV_5906 ) { strcpy ( tp -> board_part_number , \"BCM95906\" ) ; } else { nomatch : strcpy ( tp -> board_part_number , \"none\" ) ; } }\n","target":"<S2SV_ModStart> goto partno ; if ( len >= sizeof <S2SV_ModEnd> ( tp -> <S2SV_ModStart> tp -> fw_ver ) ) len = sizeof <S2SV_ModEnd> ( tp -> <S2SV_ModStart> tp -> fw_ver ) - 1 ; memset ( tp -> fw_ver , 0 , sizeof ( tp -> fw_ver ) ) ; snprintf ( tp -> fw_ver , sizeof ( tp -> fw_ver ) , \"%.*s<S2SV_blank>bc<S2SV_blank>\" , len , & vpd_data [ j ] <S2SV_ModEnd> ) ; }\n","project_and_commit_id":"torvalds@linux/715230a44310a8cf66fbfb5a46f9a62a9b2de424","cve_id":"CVE-2013-1929","original_address":"https://github.com/torvalds/linux/commit/715230a44310a8cf66fbfb5a46f9a62a9b2de424","time":"2013-06-07T14:03Z"},
	{"Unnamed: 0":963,"cwe_id":"CWE-665","source":"CWE-665 int main ( int argc , char * * argv ) { int result ; int error = FALSE ; int display_license = FALSE ; int display_help = FALSE ; int c = 0 ; struct tm * tm , tm_s ; time_t now ; char datestring [ 256 ] ; nagios_macros * mac ; const char * worker_socket = NULL ; int i ; # ifdef HAVE_SIGACTION struct sigaction sig_action ; # endif # ifdef HAVE_GETOPT_H int option_index = 0 ; static struct option long_options [ ] = { { \"help\" , no_argument , 0 , 'h' } , { \"version\" , no_argument , 0 , 'V' } , { \"license\" , no_argument , 0 , 'V' } , { \"verify-config\" , no_argument , 0 , 'v' } , { \"daemon\" , no_argument , 0 , 'd' } , { \"test-scheduling\" , no_argument , 0 , 's' } , { \"precache-objects\" , no_argument , 0 , 'p' } , { \"use-precached-objects\" , no_argument , 0 , 'u' } , { \"enable-timing-point\" , no_argument , 0 , 'T' } , { \"worker\" , required_argument , 0 , 'W' } , { 0 , 0 , 0 , 0 } } ; # define getopt ( argc , argv , o ) getopt_long ( argc , argv , o , long_options , & option_index ) # endif memset ( & loadctl , 0 , sizeof ( loadctl ) ) ; mac = get_global_macros ( ) ; if ( argc < 2 ) error = TRUE ; while ( 1 ) { c = getopt ( argc , argv , \"+hVvdspuxTW\" ) ; if ( c == - 1 || c == EOF ) break ; switch ( c ) { case '?' : case 'h' : display_help = TRUE ; break ; case 'V' : display_license = TRUE ; break ; case 'v' : verify_config ++ ; break ; case 's' : test_scheduling = TRUE ; break ; case 'd' : daemon_mode = TRUE ; break ; case 'p' : precache_objects = TRUE ; break ; case 'u' : use_precached_objects = TRUE ; break ; case 'T' : enable_timing_point = TRUE ; break ; case 'W' : worker_socket = optarg ; break ; case 'x' : printf ( \"Warning:<S2SV_blank>-x<S2SV_blank>is<S2SV_blank>deprecated<S2SV_blank>and<S2SV_blank>will<S2SV_blank>be<S2SV_blank>removed\\\\n\" ) ; break ; default : break ; } } # ifdef DEBUG_MEMORY mtrace ( ) ; # endif if ( worker_socket ) { exit ( nagios_core_worker ( worker_socket ) ) ; } init_main_cfg_vars ( 1 ) ; init_shared_cfg_vars ( 1 ) ; if ( daemon_mode == FALSE ) { printf ( \"\\\\nNagios<S2SV_blank>Core<S2SV_blank>%s\\\\n\" , PROGRAM_VERSION ) ; printf ( \"Copyright<S2SV_blank>(c)<S2SV_blank>2009-present<S2SV_blank>Nagios<S2SV_blank>Core<S2SV_blank>Development<S2SV_blank>Team<S2SV_blank>and<S2SV_blank>Community<S2SV_blank>Contributors\\\\n\" ) ; printf ( \"Copyright<S2SV_blank>(c)<S2SV_blank>1999-2009<S2SV_blank>Ethan<S2SV_blank>Galstad\\\\n\" ) ; printf ( \"Last<S2SV_blank>Modified:<S2SV_blank>%s\\\\n\" , PROGRAM_MODIFICATION_DATE ) ; printf ( \"License:<S2SV_blank>GPL\\\\n\\\\n\" ) ; printf ( \"Website:<S2SV_blank>https://www.nagios.org\\\\n\" ) ; } if ( display_license == TRUE ) { printf ( \"This<S2SV_blank>program<S2SV_blank>is<S2SV_blank>free<S2SV_blank>software;<S2SV_blank>you<S2SV_blank>can<S2SV_blank>redistribute<S2SV_blank>it<S2SV_blank>and/or<S2SV_blank>modify\\\\n\" ) ; printf ( \"it<S2SV_blank>under<S2SV_blank>the<S2SV_blank>terms<S2SV_blank>of<S2SV_blank>the<S2SV_blank>GNU<S2SV_blank>General<S2SV_blank>Public<S2SV_blank>License<S2SV_blank>version<S2SV_blank>2<S2SV_blank>as\\\\n\" ) ; printf ( \"published<S2SV_blank>by<S2SV_blank>the<S2SV_blank>Free<S2SV_blank>Software<S2SV_blank>Foundation.\\\\n\\\\n\" ) ; printf ( \"This<S2SV_blank>program<S2SV_blank>is<S2SV_blank>distributed<S2SV_blank>in<S2SV_blank>the<S2SV_blank>hope<S2SV_blank>that<S2SV_blank>it<S2SV_blank>will<S2SV_blank>be<S2SV_blank>useful,\\\\n\" ) ; printf ( \"but<S2SV_blank>WITHOUT<S2SV_blank>ANY<S2SV_blank>WARRANTY;<S2SV_blank>without<S2SV_blank>even<S2SV_blank>the<S2SV_blank>implied<S2SV_blank>warranty<S2SV_blank>of\\\\n\" ) ; printf ( \"MERCHANTABILITY<S2SV_blank>or<S2SV_blank>FITNESS<S2SV_blank>FOR<S2SV_blank>A<S2SV_blank>PARTICULAR<S2SV_blank>PURPOSE.<S2SV_blank><S2SV_blank>See<S2SV_blank>the\\\\n\" ) ; printf ( \"GNU<S2SV_blank>General<S2SV_blank>Public<S2SV_blank>License<S2SV_blank>for<S2SV_blank>more<S2SV_blank>details.\\\\n\\\\n\" ) ; printf ( \"You<S2SV_blank>should<S2SV_blank>have<S2SV_blank>received<S2SV_blank>a<S2SV_blank>copy<S2SV_blank>of<S2SV_blank>the<S2SV_blank>GNU<S2SV_blank>General<S2SV_blank>Public<S2SV_blank>License\\\\n\" ) ; printf ( \"along<S2SV_blank>with<S2SV_blank>this<S2SV_blank>program;<S2SV_blank>if<S2SV_blank>not,<S2SV_blank>write<S2SV_blank>to<S2SV_blank>the<S2SV_blank>Free<S2SV_blank>Software\\\\n\" ) ; printf ( \"Foundation,<S2SV_blank>Inc.,<S2SV_blank>675<S2SV_blank>Mass<S2SV_blank>Ave,<S2SV_blank>Cambridge,<S2SV_blank>MA<S2SV_blank>02139,<S2SV_blank>USA.\\\\n\\\\n\" ) ; exit ( OK ) ; } if ( optind >= argc ) error = TRUE ; if ( error == TRUE || display_help == TRUE ) { printf ( \"Usage:<S2SV_blank>%s<S2SV_blank>[options]<S2SV_blank><main_config_file>\\\\n\" , argv [ 0 ] ) ; printf ( \"\\\\n\" ) ; printf ( \"Options:\\\\n\" ) ; printf ( \"\\\\n\" ) ; printf ( \"<S2SV_blank><S2SV_blank>-v,<S2SV_blank>--verify-config<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Verify<S2SV_blank>all<S2SV_blank>configuration<S2SV_blank>data<S2SV_blank>(-v<S2SV_blank>-v<S2SV_blank>for<S2SV_blank>more<S2SV_blank>info)\\\\n\" ) ; printf ( \"<S2SV_blank><S2SV_blank>-s,<S2SV_blank>--test-scheduling<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Shows<S2SV_blank>projected/recommended<S2SV_blank>check<S2SV_blank>scheduling<S2SV_blank>and<S2SV_blank>other\\\\n\" ) ; printf ( \"<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>diagnostic<S2SV_blank>info<S2SV_blank>based<S2SV_blank>on<S2SV_blank>the<S2SV_blank>current<S2SV_blank>configuration<S2SV_blank>files.\\\\n\" ) ; printf ( \"<S2SV_blank><S2SV_blank>-T,<S2SV_blank>--enable-timing-point<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Enable<S2SV_blank>timed<S2SV_blank>commentary<S2SV_blank>on<S2SV_blank>initialization\\\\n\" ) ; printf ( \"<S2SV_blank><S2SV_blank>-x,<S2SV_blank>--dont-verify-paths<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Deprecated<S2SV_blank>(Don\\'t<S2SV_blank>check<S2SV_blank>for<S2SV_blank>circular<S2SV_blank>object<S2SV_blank>paths)\\\\n\" ) ; printf ( \"<S2SV_blank><S2SV_blank>-p,<S2SV_blank>--precache-objects<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Precache<S2SV_blank>object<S2SV_blank>configuration\\\\n\" ) ; printf ( \"<S2SV_blank><S2SV_blank>-u,<S2SV_blank>--use-precached-objects<S2SV_blank><S2SV_blank>Use<S2SV_blank>precached<S2SV_blank>object<S2SV_blank>config<S2SV_blank>file\\\\n\" ) ; printf ( \"<S2SV_blank><S2SV_blank>-d,<S2SV_blank>--daemon<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Starts<S2SV_blank>Nagios<S2SV_blank>in<S2SV_blank>daemon<S2SV_blank>mode,<S2SV_blank>instead<S2SV_blank>of<S2SV_blank>as<S2SV_blank>a<S2SV_blank>foreground<S2SV_blank>process\\\\n\" ) ; printf ( \"<S2SV_blank><S2SV_blank>-W,<S2SV_blank>--worker<S2SV_blank>/path/to/socket<S2SV_blank>Act<S2SV_blank>as<S2SV_blank>a<S2SV_blank>worker<S2SV_blank>for<S2SV_blank>an<S2SV_blank>already<S2SV_blank>running<S2SV_blank>daemon\\\\n\" ) ; printf ( \"\\\\n\" ) ; printf ( \"Visit<S2SV_blank>the<S2SV_blank>Nagios<S2SV_blank>website<S2SV_blank>at<S2SV_blank>https://www.nagios.org/<S2SV_blank>for<S2SV_blank>bug<S2SV_blank>fixes,<S2SV_blank>new\\\\n\" ) ; printf ( \"releases,<S2SV_blank>online<S2SV_blank>documentation,<S2SV_blank>FAQs,<S2SV_blank>information<S2SV_blank>on<S2SV_blank>subscribing<S2SV_blank>to\\\\n\" ) ; printf ( \"the<S2SV_blank>mailing<S2SV_blank>lists,<S2SV_blank>and<S2SV_blank>commercial<S2SV_blank>support<S2SV_blank>options<S2SV_blank>for<S2SV_blank>Nagios.\\\\n\" ) ; printf ( \"\\\\n\" ) ; exit ( ERROR ) ; } config_file = nspath_absolute ( argv [ optind ] , NULL ) ; if ( config_file == NULL ) { printf ( \"Error<S2SV_blank>allocating<S2SV_blank>memory.\\\\n\" ) ; exit ( ERROR ) ; } config_file_dir = nspath_absolute_dirname ( config_file , NULL ) ; # ifdef HAVE_SIGACTION sig_action . sa_sigaction = NULL ; sig_action . sa_handler = handle_sigxfsz ; sigfillset ( & sig_action . sa_mask ) ; sig_action . sa_flags = SA_NODEFER | SA_RESTART ; sigaction ( SIGXFSZ , & sig_action , NULL ) ; # else signal ( SIGXFSZ , handle_sigxfsz ) ; # endif if ( verify_config || test_scheduling || precache_objects ) { reset_variables ( ) ; set_loadctl_defaults ( ) ; if ( verify_config ) printf ( \"Reading<S2SV_blank>configuration<S2SV_blank>data...\\\\n\" ) ; result = read_main_config_file ( config_file ) ; if ( result != OK ) { printf ( \"<S2SV_blank><S2SV_blank><S2SV_blank>Error<S2SV_blank>processing<S2SV_blank>main<S2SV_blank>config<S2SV_blank>file!\\\\n\\\\n\" ) ; exit ( EXIT_FAILURE ) ; } if ( verify_config ) printf ( \"<S2SV_blank><S2SV_blank><S2SV_blank>Read<S2SV_blank>main<S2SV_blank>config<S2SV_blank>file<S2SV_blank>okay...\\\\n\" ) ; if ( ( result = drop_privileges ( nagios_user , nagios_group ) ) == ERROR ) { printf ( \"<S2SV_blank><S2SV_blank><S2SV_blank>Failed<S2SV_blank>to<S2SV_blank>drop<S2SV_blank>privileges.<S2SV_blank><S2SV_blank>Aborting.\" ) ; exit ( EXIT_FAILURE ) ; } if ( ! verify_config && test_configured_paths ( ) == ERROR ) { printf ( \"<S2SV_blank><S2SV_blank><S2SV_blank>One<S2SV_blank>or<S2SV_blank>more<S2SV_blank>path<S2SV_blank>problems<S2SV_blank>detected.<S2SV_blank>Aborting.\\\\n\" ) ; exit ( EXIT_FAILURE ) ; } result = read_all_object_data ( config_file ) ; if ( result != OK ) { printf ( \"<S2SV_blank><S2SV_blank><S2SV_blank>Error<S2SV_blank>processing<S2SV_blank>object<S2SV_blank>config<S2SV_blank>files!\\\\n\\\\n\" ) ; if ( ! strstr ( config_file , \"nagios.cfg\" ) ) { printf ( \"\\\\n***><S2SV_blank>The<S2SV_blank>name<S2SV_blank>of<S2SV_blank>the<S2SV_blank>main<S2SV_blank>configuration<S2SV_blank>file<S2SV_blank>looks<S2SV_blank>suspicious...\\\\n\" ) ; printf ( \"\\\\n\" ) ; printf ( \"<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Make<S2SV_blank>sure<S2SV_blank>you<S2SV_blank>are<S2SV_blank>specifying<S2SV_blank>the<S2SV_blank>name<S2SV_blank>of<S2SV_blank>the<S2SV_blank>MAIN<S2SV_blank>configuration<S2SV_blank>file<S2SV_blank>on\\\\n\" ) ; printf ( \"<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>the<S2SV_blank>command<S2SV_blank>line<S2SV_blank>and<S2SV_blank>not<S2SV_blank>the<S2SV_blank>name<S2SV_blank>of<S2SV_blank>another<S2SV_blank>configuration<S2SV_blank>file.<S2SV_blank><S2SV_blank>The\\\\n\" ) ; printf ( \"<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>main<S2SV_blank>configuration<S2SV_blank>file<S2SV_blank>is<S2SV_blank>typically<S2SV_blank>\\'%s\\'\\\\n\" , DEFAULT_CONFIG_FILE ) ; } printf ( \"\\\\n***><S2SV_blank>One<S2SV_blank>or<S2SV_blank>more<S2SV_blank>problems<S2SV_blank>was<S2SV_blank>encountered<S2SV_blank>while<S2SV_blank>processing<S2SV_blank>the<S2SV_blank>config<S2SV_blank>files...\\\\n\" ) ; printf ( \"\\\\n\" ) ; printf ( \"<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Check<S2SV_blank>your<S2SV_blank>configuration<S2SV_blank>file(s)<S2SV_blank>to<S2SV_blank>ensure<S2SV_blank>that<S2SV_blank>they<S2SV_blank>contain<S2SV_blank>valid\\\\n\" ) ; printf ( \"<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>directives<S2SV_blank>and<S2SV_blank>data<S2SV_blank>definitions.<S2SV_blank><S2SV_blank>If<S2SV_blank>you<S2SV_blank>are<S2SV_blank>upgrading<S2SV_blank>from<S2SV_blank>a<S2SV_blank>previous\\\\n\" ) ; printf ( \"<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>version<S2SV_blank>of<S2SV_blank>Nagios,<S2SV_blank>you<S2SV_blank>should<S2SV_blank>be<S2SV_blank>aware<S2SV_blank>that<S2SV_blank>some<S2SV_blank>variables/definitions\\\\n\" ) ; printf ( \"<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>may<S2SV_blank>have<S2SV_blank>been<S2SV_blank>removed<S2SV_blank>or<S2SV_blank>modified<S2SV_blank>in<S2SV_blank>this<S2SV_blank>version.<S2SV_blank><S2SV_blank>Make<S2SV_blank>sure<S2SV_blank>to<S2SV_blank>read\\\\n\" ) ; printf ( \"<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>the<S2SV_blank>HTML<S2SV_blank>documentation<S2SV_blank>regarding<S2SV_blank>the<S2SV_blank>config<S2SV_blank>files,<S2SV_blank>as<S2SV_blank>well<S2SV_blank>as<S2SV_blank>the\\\\n\" ) ; printf ( \"<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>\\'Whats<S2SV_blank>New\\'<S2SV_blank>section<S2SV_blank>to<S2SV_blank>find<S2SV_blank>out<S2SV_blank>what<S2SV_blank>has<S2SV_blank>changed.\\\\n\\\\n\" ) ; exit ( EXIT_FAILURE ) ; } if ( verify_config ) { printf ( \"<S2SV_blank><S2SV_blank><S2SV_blank>Read<S2SV_blank>object<S2SV_blank>config<S2SV_blank>files<S2SV_blank>okay...\\\\n\\\\n\" ) ; printf ( \"Running<S2SV_blank>pre-flight<S2SV_blank>check<S2SV_blank>on<S2SV_blank>configuration<S2SV_blank>data...\\\\n\\\\n\" ) ; } result = pre_flight_check ( ) ; if ( result != OK ) { printf ( \"\\\\n***><S2SV_blank>One<S2SV_blank>or<S2SV_blank>more<S2SV_blank>problems<S2SV_blank>was<S2SV_blank>encountered<S2SV_blank>while<S2SV_blank>running<S2SV_blank>the<S2SV_blank>pre-flight<S2SV_blank>check...\\\\n\" ) ; printf ( \"\\\\n\" ) ; printf ( \"<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Check<S2SV_blank>your<S2SV_blank>configuration<S2SV_blank>file(s)<S2SV_blank>to<S2SV_blank>ensure<S2SV_blank>that<S2SV_blank>they<S2SV_blank>contain<S2SV_blank>valid\\\\n\" ) ; printf ( \"<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>directives<S2SV_blank>and<S2SV_blank>data<S2SV_blank>definitions.<S2SV_blank><S2SV_blank>If<S2SV_blank>you<S2SV_blank>are<S2SV_blank>upgrading<S2SV_blank>from<S2SV_blank>a<S2SV_blank>previous\\\\n\" ) ; printf ( \"<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>version<S2SV_blank>of<S2SV_blank>Nagios,<S2SV_blank>you<S2SV_blank>should<S2SV_blank>be<S2SV_blank>aware<S2SV_blank>that<S2SV_blank>some<S2SV_blank>variables/definitions\\\\n\" ) ; printf ( \"<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>may<S2SV_blank>have<S2SV_blank>been<S2SV_blank>removed<S2SV_blank>or<S2SV_blank>modified<S2SV_blank>in<S2SV_blank>this<S2SV_blank>version.<S2SV_blank><S2SV_blank>Make<S2SV_blank>sure<S2SV_blank>to<S2SV_blank>read\\\\n\" ) ; printf ( \"<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>the<S2SV_blank>HTML<S2SV_blank>documentation<S2SV_blank>regarding<S2SV_blank>the<S2SV_blank>config<S2SV_blank>files,<S2SV_blank>as<S2SV_blank>well<S2SV_blank>as<S2SV_blank>the\\\\n\" ) ; printf ( \"<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>\\'Whats<S2SV_blank>New\\'<S2SV_blank>section<S2SV_blank>to<S2SV_blank>find<S2SV_blank>out<S2SV_blank>what<S2SV_blank>has<S2SV_blank>changed.\\\\n\\\\n\" ) ; exit ( EXIT_FAILURE ) ; } if ( verify_config ) { printf ( \"\\\\nThings<S2SV_blank>look<S2SV_blank>okay<S2SV_blank>-<S2SV_blank>No<S2SV_blank>serious<S2SV_blank>problems<S2SV_blank>were<S2SV_blank>detected<S2SV_blank>during<S2SV_blank>the<S2SV_blank>pre-flight<S2SV_blank>check\\\\n\" ) ; } if ( test_scheduling == TRUE ) { init_event_queue ( ) ; timing_point ( \"Done<S2SV_blank>initializing<S2SV_blank>event<S2SV_blank>queue\\\\n\" ) ; initialize_retention_data ( config_file ) ; read_initial_state_information ( ) ; timing_point ( \"Retention<S2SV_blank>data<S2SV_blank>and<S2SV_blank>initial<S2SV_blank>state<S2SV_blank>parsed\\\\n\" ) ; init_timing_loop ( ) ; timing_point ( \"Timing<S2SV_blank>loop<S2SV_blank>initialized\\\\n\" ) ; display_scheduling_info ( ) ; } if ( precache_objects ) { result = fcache_objects ( object_precache_file ) ; timing_point ( \"Done<S2SV_blank>precaching<S2SV_blank>objects\\\\n\" ) ; if ( result == OK ) { printf ( \"Object<S2SV_blank>precache<S2SV_blank>file<S2SV_blank>created:\\\\n%s\\\\n\" , object_precache_file ) ; } else { printf ( \"Failed<S2SV_blank>to<S2SV_blank>precache<S2SV_blank>objects<S2SV_blank>to<S2SV_blank>\\'%s\\':<S2SV_blank>%s\\\\n\" , object_precache_file , strerror ( errno ) ) ; } } cleanup ( ) ; timing_point ( \"Exiting\\\\n\" ) ; neb_free_module_list ( ) ; free ( config_file_dir ) ; free ( config_file ) ; exit ( result ) ; } else { if ( strchr ( argv [ 0 ] , '/' ) ) nagios_binary_path = nspath_absolute ( argv [ 0 ] , NULL ) ; else nagios_binary_path = strdup ( argv [ 0 ] ) ; if ( ! nagios_binary_path ) { logit ( NSLOG_RUNTIME_ERROR , TRUE , \"Error:<S2SV_blank>Unable<S2SV_blank>to<S2SV_blank>allocate<S2SV_blank>memory<S2SV_blank>for<S2SV_blank>nagios_binary_path\\\\n\" ) ; exit ( EXIT_FAILURE ) ; } if ( ! ( nagios_iobs = iobroker_create ( ) ) ) { logit ( NSLOG_RUNTIME_ERROR , TRUE , \"Error:<S2SV_blank>Failed<S2SV_blank>to<S2SV_blank>create<S2SV_blank>IO<S2SV_blank>broker<S2SV_blank>set:<S2SV_blank>%s\\\\n\" , strerror ( errno ) ) ; exit ( EXIT_FAILURE ) ; } do { wproc_num_workers_spawned = wproc_num_workers_online = 0 ; caught_signal = sigshutdown = FALSE ; sig_id = 0 ; reset_variables ( ) ; timing_point ( \"Variables<S2SV_blank>reset\\\\n\" ) ; nagios_pid = ( int ) getpid ( ) ; result = read_main_config_file ( config_file ) ; if ( result != OK ) { logit ( NSLOG_CONFIG_ERROR , TRUE , \"Error:<S2SV_blank>Failed<S2SV_blank>to<S2SV_blank>process<S2SV_blank>config<S2SV_blank>file<S2SV_blank>\\'%s\\'.<S2SV_blank>Aborting\\\\n\" , config_file ) ; exit ( EXIT_FAILURE ) ; } timing_point ( \"Main<S2SV_blank>config<S2SV_blank>file<S2SV_blank>read\\\\n\" ) ; program_start = time ( NULL ) ; my_free ( mac -> x [ MACRO_PROCESSSTARTTIME ] ) ; asprintf ( & mac -> x [ MACRO_PROCESSSTARTTIME ] , \"%llu\" , ( unsigned long long ) program_start ) ; <S2SV_StartBug> if ( drop_privileges ( nagios_user , nagios_group ) == ERROR ) { <S2SV_EndBug> logit ( NSLOG_PROCESS_INFO | NSLOG_RUNTIME_ERROR | NSLOG_CONFIG_ERROR , TRUE , \"Failed<S2SV_blank>to<S2SV_blank>drop<S2SV_blank>privileges.<S2SV_blank><S2SV_blank>Aborting.\" ) ; cleanup ( ) ; exit ( ERROR ) ; } if ( test_path_access ( nagios_binary_path , X_OK ) ) { logit ( NSLOG_RUNTIME_ERROR , TRUE , \"Error:<S2SV_blank>failed<S2SV_blank>to<S2SV_blank>access()<S2SV_blank>%s:<S2SV_blank>%s\\\\n\" , nagios_binary_path , strerror ( errno ) ) ; logit ( NSLOG_RUNTIME_ERROR , TRUE , \"Error:<S2SV_blank>Spawning<S2SV_blank>workers<S2SV_blank>will<S2SV_blank>be<S2SV_blank>impossible.<S2SV_blank>Aborting.\\\\n\" ) ; exit ( EXIT_FAILURE ) ; } if ( test_configured_paths ( ) == ERROR ) { <S2SV_StartBug> exit ( EXIT_FAILURE ) ; <S2SV_EndBug> } if ( daemon_mode == TRUE && sigrestart == FALSE ) { result = daemon_init ( ) ; if ( result == ERROR ) { logit ( NSLOG_PROCESS_INFO | NSLOG_RUNTIME_ERROR , TRUE , \"Bailing<S2SV_blank>out<S2SV_blank>due<S2SV_blank>to<S2SV_blank>failure<S2SV_blank>to<S2SV_blank>daemonize.<S2SV_blank>(PID=%d)\" , ( int ) getpid ( ) ) ; cleanup ( ) ; exit ( EXIT_FAILURE ) ; } nagios_pid = ( int ) getpid ( ) ; } logit ( NSLOG_PROCESS_INFO , TRUE , \"Nagios<S2SV_blank>%s<S2SV_blank>starting...<S2SV_blank>(PID=%d)\\\\n\" , PROGRAM_VERSION , ( int ) getpid ( ) ) ; now = time ( NULL ) ; tm = localtime_r ( & now , & tm_s ) ; strftime ( datestring , sizeof ( datestring ) , \"%a<S2SV_blank>%b<S2SV_blank>%d<S2SV_blank>%H:%M:%S<S2SV_blank>%Z<S2SV_blank>%Y\" , tm ) ; logit ( NSLOG_PROCESS_INFO , TRUE , \"Local<S2SV_blank>time<S2SV_blank>is<S2SV_blank>%s\" , datestring ) ; write_log_file_info ( NULL ) ; open_debug_log ( ) ; # ifdef USE_EVENT_BROKER neb_init_modules ( ) ; neb_init_callback_list ( ) ; # endif timing_point ( \"NEB<S2SV_blank>module<S2SV_blank>API<S2SV_blank>initialized\\\\n\" ) ; setup_sighandler ( ) ; if ( qh_init ( qh_socket_path ? qh_socket_path : DEFAULT_QUERY_SOCKET ) != OK ) { logit ( NSLOG_RUNTIME_ERROR , TRUE , \"Error:<S2SV_blank>Failed<S2SV_blank>to<S2SV_blank>initialize<S2SV_blank>query<S2SV_blank>handler.<S2SV_blank>Aborting\\\\n\" ) ; exit ( EXIT_FAILURE ) ; } timing_point ( \"Query<S2SV_blank>handler<S2SV_blank>initialized\\\\n\" ) ; nerd_init ( ) ; timing_point ( \"NERD<S2SV_blank>initialized\\\\n\" ) ; if ( init_workers ( num_check_workers ) < 0 ) { logit ( NSLOG_RUNTIME_ERROR , TRUE , \"Failed<S2SV_blank>to<S2SV_blank>spawn<S2SV_blank>workers.<S2SV_blank>Aborting\\\\n\" ) ; exit ( EXIT_FAILURE ) ; } timing_point ( \"%u<S2SV_blank>workers<S2SV_blank>spawned\\\\n\" , wproc_num_workers_spawned ) ; i = 0 ; while ( i < 50 && wproc_num_workers_online < wproc_num_workers_spawned ) { iobroker_poll ( nagios_iobs , 50 ) ; i ++ ; } timing_point ( \"%u<S2SV_blank>workers<S2SV_blank>connected\\\\n\" , wproc_num_workers_online ) ; set_loadctl_defaults ( ) ; # ifdef USE_EVENT_BROKER if ( neb_load_all_modules ( ) != OK ) { logit ( NSLOG_CONFIG_ERROR , ERROR , \"Error:<S2SV_blank>Module<S2SV_blank>loading<S2SV_blank>failed.<S2SV_blank>Aborting.\\\\n\" ) ; if ( daemon_dumps_core ) neb_unload_all_modules ( NEBMODULE_FORCE_UNLOAD , NEBMODULE_NEB_SHUTDOWN ) ; exit ( EXIT_FAILURE ) ; } timing_point ( \"Modules<S2SV_blank>loaded\\\\n\" ) ; broker_program_state ( NEBTYPE_PROCESS_PRELAUNCH , NEBFLAG_NONE , NEBATTR_NONE , NULL ) ; timing_point ( \"First<S2SV_blank>callback<S2SV_blank>made\\\\n\" ) ; # endif if ( result == OK ) result = read_all_object_data ( config_file ) ; if ( result != OK ) logit ( NSLOG_PROCESS_INFO | NSLOG_RUNTIME_ERROR | NSLOG_CONFIG_ERROR , TRUE , \"Bailing<S2SV_blank>out<S2SV_blank>due<S2SV_blank>to<S2SV_blank>one<S2SV_blank>or<S2SV_blank>more<S2SV_blank>errors<S2SV_blank>encountered<S2SV_blank>in<S2SV_blank>the<S2SV_blank>configuration<S2SV_blank>files.<S2SV_blank>Run<S2SV_blank>Nagios<S2SV_blank>from<S2SV_blank>the<S2SV_blank>command<S2SV_blank>line<S2SV_blank>with<S2SV_blank>the<S2SV_blank>-v<S2SV_blank>option<S2SV_blank>to<S2SV_blank>verify<S2SV_blank>your<S2SV_blank>config<S2SV_blank>before<S2SV_blank>restarting.<S2SV_blank>(PID=%d)\" , ( int ) getpid ( ) ) ; else { if ( ( result = pre_flight_check ( ) ) != OK ) logit ( NSLOG_PROCESS_INFO | NSLOG_RUNTIME_ERROR | NSLOG_VERIFICATION_ERROR , TRUE , \"Bailing<S2SV_blank>out<S2SV_blank>due<S2SV_blank>to<S2SV_blank>errors<S2SV_blank>encountered<S2SV_blank>while<S2SV_blank>running<S2SV_blank>the<S2SV_blank>pre-flight<S2SV_blank>check.<S2SV_blank><S2SV_blank>Run<S2SV_blank>Nagios<S2SV_blank>from<S2SV_blank>the<S2SV_blank>command<S2SV_blank>line<S2SV_blank>with<S2SV_blank>the<S2SV_blank>-v<S2SV_blank>option<S2SV_blank>to<S2SV_blank>verify<S2SV_blank>your<S2SV_blank>config<S2SV_blank>before<S2SV_blank>restarting.<S2SV_blank>(PID=%d)\\\\n\" , ( int ) getpid ( ) ) ; } if ( result != OK ) { if ( sigrestart == TRUE ) { cleanup_status_data ( TRUE ) ; } # ifdef USE_EVENT_BROKER broker_program_state ( NEBTYPE_PROCESS_SHUTDOWN , NEBFLAG_PROCESS_INITIATED , NEBATTR_SHUTDOWN_ABNORMAL , NULL ) ; # endif cleanup ( ) ; exit ( ERROR ) ; } timing_point ( \"Object<S2SV_blank>configuration<S2SV_blank>parsed<S2SV_blank>and<S2SV_blank>understood\\\\n\" ) ; fcache_objects ( object_cache_file ) ; timing_point ( \"Objects<S2SV_blank>cached\\\\n\" ) ; init_event_queue ( ) ; timing_point ( \"Event<S2SV_blank>queue<S2SV_blank>initialized\\\\n\" ) ; # ifdef USE_EVENT_BROKER broker_program_state ( NEBTYPE_PROCESS_START , NEBFLAG_NONE , NEBATTR_NONE , NULL ) ; # endif if ( sigrestart == FALSE ) { initialize_status_data ( config_file ) ; timing_point ( \"Status<S2SV_blank>data<S2SV_blank>initialized\\\\n\" ) ; } initialize_downtime_data ( ) ; timing_point ( \"Downtime<S2SV_blank>data<S2SV_blank>initialized\\\\n\" ) ; initialize_retention_data ( config_file ) ; timing_point ( \"Retention<S2SV_blank>data<S2SV_blank>initialized\\\\n\" ) ; read_initial_state_information ( ) ; timing_point ( \"Initial<S2SV_blank>state<S2SV_blank>information<S2SV_blank>read\\\\n\" ) ; initialize_comment_data ( ) ; timing_point ( \"Comment<S2SV_blank>data<S2SV_blank>initialized\\\\n\" ) ; initialize_performance_data ( config_file ) ; timing_point ( \"Performance<S2SV_blank>data<S2SV_blank>initialized\\\\n\" ) ; init_timing_loop ( ) ; timing_point ( \"Event<S2SV_blank>timing<S2SV_blank>loop<S2SV_blank>initialized\\\\n\" ) ; init_check_stats ( ) ; timing_point ( \"check<S2SV_blank>stats<S2SV_blank>initialized\\\\n\" ) ; check_for_nagios_updates ( FALSE , TRUE ) ; timing_point ( \"Update<S2SV_blank>check<S2SV_blank>concluded\\\\n\" ) ; update_all_status_data ( ) ; timing_point ( \"Status<S2SV_blank>data<S2SV_blank>updated\\\\n\" ) ; log_host_states ( INITIAL_STATES , NULL ) ; log_service_states ( INITIAL_STATES , NULL ) ; timing_point ( \"Initial<S2SV_blank>states<S2SV_blank>logged\\\\n\" ) ; sigrestart = FALSE ; launch_command_file_worker ( ) ; timing_point ( \"Command<S2SV_blank>file<S2SV_blank>worker<S2SV_blank>launched\\\\n\" ) ; # ifdef USE_EVENT_BROKER broker_program_state ( NEBTYPE_PROCESS_EVENTLOOPSTART , NEBFLAG_NONE , NEBATTR_NONE , NULL ) ; # endif event_start = time ( NULL ) ; my_free ( mac -> x [ MACRO_EVENTSTARTTIME ] ) ; asprintf ( & mac -> x [ MACRO_EVENTSTARTTIME ] , \"%llu\" , ( unsigned long long ) event_start ) ; timing_point ( \"Entering<S2SV_blank>event<S2SV_blank>execution<S2SV_blank>loop\\\\n\" ) ; event_execution_loop ( ) ; qh_deinit ( qh_socket_path ? qh_socket_path : DEFAULT_QUERY_SOCKET ) ; if ( caught_signal == TRUE ) { if ( sig_id == SIGHUP ) logit ( NSLOG_PROCESS_INFO , TRUE , \"Caught<S2SV_blank>SIGHUP,<S2SV_blank>restarting...\\\\n\" ) ; } # ifdef USE_EVENT_BROKER broker_program_state ( NEBTYPE_PROCESS_EVENTLOOPEND , NEBFLAG_NONE , NEBATTR_NONE , NULL ) ; if ( sigshutdown == TRUE ) broker_program_state ( NEBTYPE_PROCESS_SHUTDOWN , NEBFLAG_USER_INITIATED , NEBATTR_SHUTDOWN_NORMAL , NULL ) ; else if ( sigrestart == TRUE ) broker_program_state ( NEBTYPE_PROCESS_RESTART , NEBFLAG_USER_INITIATED , NEBATTR_RESTART_NORMAL , NULL ) ; # endif save_state_information ( FALSE ) ; cleanup_retention_data ( ) ; cleanup_performance_data ( ) ; cleanup_downtime_data ( ) ; if ( sigrestart == FALSE ) { cleanup_status_data ( TRUE ) ; } free_worker_memory ( WPROC_FORCE ) ; if ( sigshutdown == TRUE ) { iobroker_destroy ( nagios_iobs , IOBROKER_CLOSE_SOCKETS ) ; nagios_iobs = NULL ; logit ( NSLOG_PROCESS_INFO , TRUE , \"Successfully<S2SV_blank>shutdown...<S2SV_blank>(PID=%d)\\\\n\" , ( int ) getpid ( ) ) ; } cleanup ( ) ; close_debug_log ( ) ; } while ( sigrestart == TRUE && sigshutdown == FALSE ) ; if ( daemon_mode == TRUE ) unlink ( lock_file ) ; my_free ( lock_file ) ; my_free ( config_file ) ; my_free ( config_file_dir ) ; my_free ( nagios_binary_path ) ; } return OK ; }\n","target":"<S2SV_ModStart> ; if ( daemon_mode == TRUE && sigrestart == FALSE ) { result = daemon_init ( ) ; if ( result == ERROR ) { logit ( NSLOG_PROCESS_INFO | NSLOG_RUNTIME_ERROR , TRUE , \"Bailing<S2SV_blank>out<S2SV_blank>due<S2SV_blank>to<S2SV_blank>failure<S2SV_blank>to<S2SV_blank>daemonize.<S2SV_blank>(PID=%d)\" , ( int ) getpid ( ) ) ; cleanup ( ) ; exit ( EXIT_FAILURE ) ; } nagios_pid = ( int ) getpid ( ) ; } if ( <S2SV_ModStart> exit ( EXIT_FAILURE <S2SV_ModEnd> ) ; }\n","project_and_commit_id":"NagiosEnterprises@nagioscore/1b197346d490df2e2d3b1dcce5ac6134ad0c8752","cve_id":"CVE-2017-12847","original_address":"https://github.com/NagiosEnterprises/nagioscore/commit/1b197346d490df2e2d3b1dcce5ac6134ad0c8752","time":"2017-08-23T21:29Z"},
	{"Unnamed: 0":3265,"cwe_id":"CWE-125","source":"CWE-125 uint32 TIFFNumberOfStrips ( TIFF * tif ) { TIFFDirectory * td = & tif -> tif_dir ; <S2SV_StartBug> uint32 nstrips ; <S2SV_EndBug> if ( td -> td_nstrips ) return td -> td_nstrips ; nstrips = ( td -> td_rowsperstrip == ( uint32 ) - 1 ? 1 : TIFFhowmany_32 ( td -> td_imagelength , td -> td_rowsperstrip ) ) ; if ( td -> td_planarconfig == PLANARCONFIG_SEPARATE ) nstrips = _TIFFMultiply32 ( tif , nstrips , ( uint32 ) td -> td_samplesperpixel , \"TIFFNumberOfStrips\" ) ; return ( nstrips ) ; }\n","target":"<S2SV_ModStart> ; uint32 nstrips <S2SV_ModEnd> ; nstrips =\n","project_and_commit_id":"vadz@libtiff/9a72a69e035ee70ff5c41541c8c61cd97990d018","cve_id":"CVE-2016-10270","original_address":"https://github.com/vadz/libtiff/commit/9a72a69e035ee70ff5c41541c8c61cd97990d018","time":"2017-03-24T19:59Z"},
	{"Unnamed: 0":924,"cwe_id":"CWE-415","source":"CWE-415 static int f_midi_set_alt ( struct usb_function * f , unsigned intf , unsigned alt ) { struct f_midi * midi = func_to_midi ( f ) ; unsigned i ; int err ; if ( intf != midi -> ms_id ) return 0 ; err = f_midi_start_ep ( midi , f , midi -> in_ep ) ; if ( err ) return err ; err = f_midi_start_ep ( midi , f , midi -> out_ep ) ; if ( err ) return err ; while ( kfifo_avail ( & midi -> in_req_fifo ) ) { struct usb_request * req = midi_alloc_ep_req ( midi -> in_ep , midi -> buflen ) ; if ( req == NULL ) return - ENOMEM ; req -> length = 0 ; req -> complete = f_midi_complete ; kfifo_put ( & midi -> in_req_fifo , req ) ; } for ( i = 0 ; i < midi -> qlen && err == 0 ; i ++ ) { struct usb_request * req = midi_alloc_ep_req ( midi -> out_ep , midi -> buflen ) ; if ( req == NULL ) return - ENOMEM ; req -> complete = f_midi_complete ; err = usb_ep_queue ( midi -> out_ep , req , GFP_ATOMIC ) ; if ( err ) { ERROR ( midi , \"%s:<S2SV_blank>couldn\\'t<S2SV_blank>enqueue<S2SV_blank>request:<S2SV_blank>%d\\\\n\" , midi -> out_ep -> name , err ) ; <S2SV_StartBug> free_ep_req ( midi -> out_ep , req ) ; <S2SV_EndBug> return err ; } } return 0 ; }\n","target":"<S2SV_ModStart> err ) ; if ( req -> buf != NULL )\n","project_and_commit_id":"torvalds@linux/7fafcfdf6377b18b2a726ea554d6e593ba44349f","cve_id":"CVE-2018-20961","original_address":"https://github.com/torvalds/linux/commit/7fafcfdf6377b18b2a726ea554d6e593ba44349f","time":"2019-08-07T15:15Z"},
	{"Unnamed: 0":3619,"cwe_id":"CWE-125","source":"CWE-125 static int decode_studio_vop_header ( Mpeg4DecContext * ctx , GetBitContext * gb ) { MpegEncContext * s = & ctx -> m ; if ( get_bits_left ( gb ) <= 32 ) return 0 ; s -> partitioned_frame = 0 ; <S2SV_StartBug> s -> decode_mb = mpeg4_decode_studio_mb ; <S2SV_EndBug> decode_smpte_tc ( ctx , gb ) ; skip_bits ( gb , 10 ) ; skip_bits ( gb , 2 ) ; s -> pict_type = get_bits ( gb , 2 ) + AV_PICTURE_TYPE_I ; if ( get_bits1 ( gb ) ) { skip_bits1 ( gb ) ; skip_bits1 ( gb ) ; s -> progressive_frame = get_bits1 ( gb ) ^ 1 ; } if ( s -> pict_type == AV_PICTURE_TYPE_I ) { if ( get_bits1 ( gb ) ) reset_studio_dc_predictors ( s ) ; } if ( ctx -> shape != BIN_ONLY_SHAPE ) { s -> alternate_scan = get_bits1 ( gb ) ; s -> frame_pred_frame_dct = get_bits1 ( gb ) ; s -> dct_precision = get_bits ( gb , 2 ) ; s -> intra_dc_precision = get_bits ( gb , 2 ) ; s -> q_scale_type = get_bits1 ( gb ) ; } if ( s -> alternate_scan ) { ff_init_scantable ( s -> idsp . idct_permutation , & s -> inter_scantable , ff_alternate_vertical_scan ) ; ff_init_scantable ( s -> idsp . idct_permutation , & s -> intra_scantable , ff_alternate_vertical_scan ) ; ff_init_scantable ( s -> idsp . idct_permutation , & s -> intra_h_scantable , ff_alternate_vertical_scan ) ; ff_init_scantable ( s -> idsp . idct_permutation , & s -> intra_v_scantable , ff_alternate_vertical_scan ) ; } else { ff_init_scantable ( s -> idsp . idct_permutation , & s -> inter_scantable , ff_zigzag_direct ) ; ff_init_scantable ( s -> idsp . idct_permutation , & s -> intra_scantable , ff_zigzag_direct ) ; ff_init_scantable ( s -> idsp . idct_permutation , & s -> intra_h_scantable , ff_alternate_horizontal_scan ) ; ff_init_scantable ( s -> idsp . idct_permutation , & s -> intra_v_scantable , ff_alternate_vertical_scan ) ; } mpeg4_load_default_matrices ( s ) ; next_start_code_studio ( gb ) ; extension_and_user_data ( s , gb , 4 ) ; return 0 ; }\n","target":"<S2SV_ModStart> ; s -> interlaced_dct = 0 ; s ->\n","project_and_commit_id":"FFmpeg@FFmpeg/1f686d023b95219db933394a7704ad9aa5f01cbb","cve_id":"CVE-2019-11339","original_address":"https://github.com/FFmpeg/FFmpeg/commit/1f686d023b95219db933394a7704ad9aa5f01cbb","time":"2019-04-19T00:29Z"},
	{"Unnamed: 0":6044,"cwe_id":"CWE-119","source":"CWE-119 static int mov_read_dref ( MOVContext * c , AVIOContext * pb , MOVAtom atom ) { AVStream * st ; MOVStreamContext * sc ; int entries , i , j ; if ( c -> fc -> nb_streams < 1 ) return 0 ; st = c -> fc -> streams [ c -> fc -> nb_streams - 1 ] ; sc = st -> priv_data ; avio_rb32 ( pb ) ; entries = avio_rb32 ( pb ) ; if ( entries >= UINT_MAX / sizeof ( * sc -> drefs ) ) return AVERROR_INVALIDDATA ; av_free ( sc -> drefs ) ; <S2SV_StartBug> sc -> drefs = av_mallocz ( entries * sizeof ( * sc -> drefs ) ) ; <S2SV_EndBug> if ( ! sc -> drefs ) return AVERROR ( ENOMEM ) ; sc -> drefs_count = entries ; for ( i = 0 ; i < sc -> drefs_count ; i ++ ) { MOVDref * dref = & sc -> drefs [ i ] ; uint32_t size = avio_rb32 ( pb ) ; int64_t next = avio_tell ( pb ) + size - 4 ; if ( size < 12 ) return AVERROR_INVALIDDATA ; dref -> type = avio_rl32 ( pb ) ; avio_rb32 ( pb ) ; av_dlog ( c -> fc , \"type<S2SV_blank>%.4s<S2SV_blank>size<S2SV_blank>%d\\\\n\" , ( char * ) & dref -> type , size ) ; if ( dref -> type == MKTAG ( 'a' , 'l' , 'i' , 's' ) && size > 150 ) { uint16_t volume_len , len ; int16_t type ; avio_skip ( pb , 10 ) ; volume_len = avio_r8 ( pb ) ; volume_len = FFMIN ( volume_len , 27 ) ; avio_read ( pb , dref -> volume , 27 ) ; dref -> volume [ volume_len ] = 0 ; av_log ( c -> fc , AV_LOG_DEBUG , \"volume<S2SV_blank>%s,<S2SV_blank>len<S2SV_blank>%d\\\\n\" , dref -> volume , volume_len ) ; avio_skip ( pb , 12 ) ; len = avio_r8 ( pb ) ; len = FFMIN ( len , 63 ) ; avio_read ( pb , dref -> filename , 63 ) ; dref -> filename [ len ] = 0 ; av_log ( c -> fc , AV_LOG_DEBUG , \"filename<S2SV_blank>%s,<S2SV_blank>len<S2SV_blank>%d\\\\n\" , dref -> filename , len ) ; avio_skip ( pb , 16 ) ; dref -> nlvl_from = avio_rb16 ( pb ) ; dref -> nlvl_to = avio_rb16 ( pb ) ; av_log ( c -> fc , AV_LOG_DEBUG , \"nlvl<S2SV_blank>from<S2SV_blank>%d,<S2SV_blank>nlvl<S2SV_blank>to<S2SV_blank>%d\\\\n\" , dref -> nlvl_from , dref -> nlvl_to ) ; avio_skip ( pb , 16 ) ; for ( type = 0 ; type != - 1 && avio_tell ( pb ) < next ; ) { if ( url_feof ( pb ) ) return AVERROR_EOF ; type = avio_rb16 ( pb ) ; len = avio_rb16 ( pb ) ; av_log ( c -> fc , AV_LOG_DEBUG , \"type<S2SV_blank>%d,<S2SV_blank>len<S2SV_blank>%d\\\\n\" , type , len ) ; if ( len & 1 ) len += 1 ; if ( type == 2 ) { av_free ( dref -> path ) ; dref -> path = av_mallocz ( len + 1 ) ; if ( ! dref -> path ) return AVERROR ( ENOMEM ) ; avio_read ( pb , dref -> path , len ) ; if ( len > volume_len && ! strncmp ( dref -> path , dref -> volume , volume_len ) ) { len -= volume_len ; memmove ( dref -> path , dref -> path + volume_len , len ) ; dref -> path [ len ] = 0 ; } for ( j = 0 ; j < len ; j ++ ) if ( dref -> path [ j ] == ':' ) dref -> path [ j ] = '/' ; av_log ( c -> fc , AV_LOG_DEBUG , \"path<S2SV_blank>%s\\\\n\" , dref -> path ) ; } else if ( type == 0 ) { av_free ( dref -> dir ) ; dref -> dir = av_malloc ( len + 1 ) ; if ( ! dref -> dir ) return AVERROR ( ENOMEM ) ; avio_read ( pb , dref -> dir , len ) ; dref -> dir [ len ] = 0 ; for ( j = 0 ; j < len ; j ++ ) if ( dref -> dir [ j ] == ':' ) dref -> dir [ j ] = '/' ; av_log ( c -> fc , AV_LOG_DEBUG , \"dir<S2SV_blank>%s\\\\n\" , dref -> dir ) ; } else avio_skip ( pb , len ) ; } } avio_seek ( pb , next , SEEK_SET ) ; } return 0 ; }\n","target":"<S2SV_ModStart> ; sc -> drefs_count = 0 ; sc ->\n","project_and_commit_id":"FFmpeg@FFmpeg/689e59b7ffed34eba6159dcc78e87133862e3746","cve_id":"CVE-2016-3062","original_address":"https://github.com/FFmpeg/FFmpeg/commit/689e59b7ffed34eba6159dcc78e87133862e3746","time":"2016-06-16T18:59Z"},
	{"Unnamed: 0":1713,"cwe_id":"CWE-119","source":"CWE-119 int vp9_rc_drop_frame ( VP9_COMP * cpi ) { <S2SV_StartBug> const VP9_CONFIG * oxcf = & cpi -> oxcf ; <S2SV_EndBug> RATE_CONTROL * const rc = & cpi -> rc ; if ( ! oxcf -> drop_frames_water_mark ) { return 0 ; } else { if ( rc -> buffer_level < 0 ) { return 1 ; } else { int drop_mark = ( int ) ( oxcf -> drop_frames_water_mark * <S2SV_StartBug> oxcf -> optimal_buffer_level / 100 ) ; <S2SV_EndBug> if ( ( rc -> buffer_level > drop_mark ) && ( rc -> decimation_factor > 0 ) ) { -- rc -> decimation_factor ; } else if ( rc -> buffer_level <= drop_mark && rc -> decimation_factor == 0 ) { rc -> decimation_factor = 1 ; } if ( rc -> decimation_factor > 0 ) { if ( rc -> decimation_count > 0 ) { -- rc -> decimation_count ; return 1 ; } else { rc -> decimation_count = rc -> decimation_factor ; return 0 ; } } else { rc -> decimation_count = 0 ; return 0 ; } } } }\n","target":"<S2SV_ModStart> ) { const VP9EncoderConfig <S2SV_ModEnd> * oxcf = <S2SV_ModStart> -> drop_frames_water_mark * rc <S2SV_ModEnd> -> optimal_buffer_level /\n","project_and_commit_id":"external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426","cve_id":"CVE-2016-1621","original_address":"https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426","time":"2016-03-12T21:59Z"},
	{"Unnamed: 0":6572,"cwe_id":"CWE-362","source":"CWE-362 static int snd_ctl_elem_add ( struct snd_ctl_file * file , struct snd_ctl_elem_info * info , int replace ) { struct snd_card * card = file -> card ; struct snd_kcontrol kctl , * _kctl ; unsigned int access ; long private_size ; struct user_element * ue ; int idx , err ; if ( ! replace && card -> user_ctl_count >= MAX_USER_CONTROLS ) return - ENOMEM ; if ( info -> count < 1 ) return - EINVAL ; access = info -> access == 0 ? SNDRV_CTL_ELEM_ACCESS_READWRITE : ( info -> access & ( SNDRV_CTL_ELEM_ACCESS_READWRITE | SNDRV_CTL_ELEM_ACCESS_INACTIVE | SNDRV_CTL_ELEM_ACCESS_TLV_READWRITE ) ) ; info -> id . numid = 0 ; memset ( & kctl , 0 , sizeof ( kctl ) ) ; down_write ( & card -> controls_rwsem ) ; _kctl = snd_ctl_find_id ( card , & info -> id ) ; err = 0 ; if ( _kctl ) { if ( replace ) err = snd_ctl_remove ( card , _kctl ) ; else err = - EBUSY ; } else { if ( replace ) err = - ENOENT ; } up_write ( & card -> controls_rwsem ) ; if ( err < 0 ) return err ; memcpy ( & kctl . id , & info -> id , sizeof ( info -> id ) ) ; kctl . count = info -> owner ? info -> owner : 1 ; access |= SNDRV_CTL_ELEM_ACCESS_USER ; if ( info -> type == SNDRV_CTL_ELEM_TYPE_ENUMERATED ) kctl . info = snd_ctl_elem_user_enum_info ; else kctl . info = snd_ctl_elem_user_info ; if ( access & SNDRV_CTL_ELEM_ACCESS_READ ) kctl . get = snd_ctl_elem_user_get ; if ( access & SNDRV_CTL_ELEM_ACCESS_WRITE ) kctl . put = snd_ctl_elem_user_put ; if ( access & SNDRV_CTL_ELEM_ACCESS_TLV_READWRITE ) { kctl . tlv . c = snd_ctl_elem_user_tlv ; access |= SNDRV_CTL_ELEM_ACCESS_TLV_CALLBACK ; } switch ( info -> type ) { case SNDRV_CTL_ELEM_TYPE_BOOLEAN : case SNDRV_CTL_ELEM_TYPE_INTEGER : private_size = sizeof ( long ) ; if ( info -> count > 128 ) return - EINVAL ; break ; case SNDRV_CTL_ELEM_TYPE_INTEGER64 : private_size = sizeof ( long long ) ; if ( info -> count > 64 ) return - EINVAL ; break ; case SNDRV_CTL_ELEM_TYPE_ENUMERATED : private_size = sizeof ( unsigned int ) ; if ( info -> count > 128 || info -> value . enumerated . items == 0 ) return - EINVAL ; break ; case SNDRV_CTL_ELEM_TYPE_BYTES : private_size = sizeof ( unsigned char ) ; if ( info -> count > 512 ) return - EINVAL ; break ; case SNDRV_CTL_ELEM_TYPE_IEC958 : private_size = sizeof ( struct snd_aes_iec958 ) ; if ( info -> count != 1 ) return - EINVAL ; break ; default : return - EINVAL ; } private_size *= info -> count ; ue = kzalloc ( sizeof ( struct user_element ) + private_size , GFP_KERNEL ) ; if ( ue == NULL ) return - ENOMEM ; <S2SV_StartBug> ue -> info = * info ; <S2SV_EndBug> ue -> info . access = 0 ; ue -> elem_data = ( char * ) ue + sizeof ( * ue ) ; ue -> elem_data_size = private_size ; if ( ue -> info . type == SNDRV_CTL_ELEM_TYPE_ENUMERATED ) { err = snd_ctl_elem_init_enum_names ( ue ) ; if ( err < 0 ) { kfree ( ue ) ; return err ; } } kctl . private_free = snd_ctl_elem_user_free ; _kctl = snd_ctl_new ( & kctl , access ) ; if ( _kctl == NULL ) { kfree ( ue -> priv_data ) ; kfree ( ue ) ; return - ENOMEM ; } _kctl -> private_data = ue ; for ( idx = 0 ; idx < _kctl -> count ; idx ++ ) _kctl -> vd [ idx ] . owner = file ; err = snd_ctl_add ( card , _kctl ) ; if ( err < 0 ) return err ; down_write ( & card -> controls_rwsem ) ; card -> user_ctl_count ++ ; up_write ( & card -> controls_rwsem ) ; return 0 ; }\n","target":"<S2SV_ModStart> ; ue -> card = card ; ue ->\n","project_and_commit_id":"torvalds@linux/07f4d9d74a04aa7c72c5dae0ef97565f28f17b92","cve_id":"CVE-2014-4652","original_address":"https://github.com/torvalds/linux/commit/07f4d9d74a04aa7c72c5dae0ef97565f28f17b92","time":"2014-07-03T04:22Z"},
	{"Unnamed: 0":5684,"cwe_id":"CWE-119","source":"CWE-119 void vp9_cyclic_refresh_free ( CYCLIC_REFRESH * cr ) { vpx_free ( cr -> map ) ; <S2SV_StartBug> vpx_free ( cr ) ; <S2SV_EndBug> }\n","target":"<S2SV_ModStart> vpx_free ( cr -> last_coded_q_map ) ; vpx_free ( cr\n","project_and_commit_id":"external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426","cve_id":"CVE-2016-1621","original_address":"https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426","time":"2016-03-12T21:59Z"},
	{"Unnamed: 0":2986,"cwe_id":"CWE-399","source":"CWE-399 static Image * ReadPSImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { # define BoundingBox \"BoundingBox:\" # define BeginDocument \"BeginDocument:\" # define BeginXMPPacket \"<?xpacket<S2SV_blank>begin=\" # define EndXMPPacket \"<?xpacket<S2SV_blank>end=\" # define ICCProfile \"BeginICCProfile:\" # define CMYKCustomColor \"CMYKCustomColor:\" # define CMYKProcessColor \"CMYKProcessColor:\" # define DocumentMedia \"DocumentMedia:\" # define DocumentCustomColors \"DocumentCustomColors:\" # define DocumentProcessColors \"DocumentProcessColors:\" # define EndDocument \"EndDocument:\" # define HiResBoundingBox \"HiResBoundingBox:\" # define ImageData \"ImageData:\" # define PageBoundingBox \"PageBoundingBox:\" # define LanguageLevel \"LanguageLevel:\" # define PageMedia \"PageMedia:\" # define Pages \"Pages:\" # define PhotoshopProfile \"BeginPhotoshop:\" # define PostscriptLevel \"!PS-\" # define RenderPostscriptText \"<S2SV_blank><S2SV_blank>Rendering<S2SV_blank>Postscript...<S2SV_blank><S2SV_blank>\" # define SpotColor \"+<S2SV_blank>\" char command [ MaxTextExtent ] , * density , filename [ MaxTextExtent ] , geometry [ MaxTextExtent ] , input_filename [ MaxTextExtent ] , message [ MaxTextExtent ] , * options , postscript_filename [ MaxTextExtent ] ; const char * option ; const DelegateInfo * delegate_info ; GeometryInfo geometry_info ; Image * image , * next , * postscript_image ; ImageInfo * read_info ; int c , file ; MagickBooleanType cmyk , fitPage , skip , status ; MagickStatusType flags ; PointInfo delta , resolution ; RectangleInfo page ; register char * p ; register ssize_t i ; SegmentInfo bounds , hires_bounds ; short int hex_digits [ 256 ] ; size_t length , priority ; ssize_t count ; StringInfo * profile ; unsigned long columns , extent , language_level , pages , rows , scene , spotcolor ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickCoreSignature ) ; if ( image_info -> debug != MagickFalse ) ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , \"%s\" , image_info -> filename ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickCoreSignature ) ; image = AcquireImage ( image_info ) ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } status = AcquireUniqueSymbolicLink ( image_info -> filename , input_filename ) ; if ( status == MagickFalse ) { ThrowFileException ( exception , FileOpenError , \"UnableToCreateTemporaryFile\" , image_info -> filename ) ; image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } ( void ) memset ( hex_digits , 0 , sizeof ( hex_digits ) ) ; hex_digits [ ( int ) '0' ] = 0 ; hex_digits [ ( int ) '1' ] = 1 ; hex_digits [ ( int ) '2' ] = 2 ; hex_digits [ ( int ) '3' ] = 3 ; hex_digits [ ( int ) '4' ] = 4 ; hex_digits [ ( int ) '5' ] = 5 ; hex_digits [ ( int ) '6' ] = 6 ; hex_digits [ ( int ) '7' ] = 7 ; hex_digits [ ( int ) '8' ] = 8 ; hex_digits [ ( int ) '9' ] = 9 ; hex_digits [ ( int ) 'a' ] = 10 ; hex_digits [ ( int ) 'b' ] = 11 ; hex_digits [ ( int ) 'c' ] = 12 ; hex_digits [ ( int ) 'd' ] = 13 ; hex_digits [ ( int ) 'e' ] = 14 ; hex_digits [ ( int ) 'f' ] = 15 ; hex_digits [ ( int ) 'A' ] = 10 ; hex_digits [ ( int ) 'B' ] = 11 ; hex_digits [ ( int ) 'C' ] = 12 ; hex_digits [ ( int ) 'D' ] = 13 ; hex_digits [ ( int ) 'E' ] = 14 ; hex_digits [ ( int ) 'F' ] = 15 ; delta . x = DefaultResolution ; delta . y = DefaultResolution ; if ( ( image -> x_resolution == 0.0 ) || ( image -> y_resolution == 0.0 ) ) { flags = ParseGeometry ( PSDensityGeometry , & geometry_info ) ; image -> x_resolution = geometry_info . rho ; image -> y_resolution = geometry_info . sigma ; if ( ( flags & SigmaValue ) == 0 ) image -> y_resolution = image -> x_resolution ; } if ( image_info -> density != ( char * ) NULL ) { flags = ParseGeometry ( image_info -> density , & geometry_info ) ; image -> x_resolution = geometry_info . rho ; image -> y_resolution = geometry_info . sigma ; if ( ( flags & SigmaValue ) == 0 ) image -> y_resolution = image -> x_resolution ; } ( void ) ParseAbsoluteGeometry ( PSPageGeometry , & page ) ; if ( image_info -> page != ( char * ) NULL ) ( void ) ParseAbsoluteGeometry ( image_info -> page , & page ) ; resolution . x = image -> x_resolution ; resolution . y = image -> y_resolution ; page . width = ( size_t ) ceil ( ( double ) ( page . width * resolution . x / delta . x ) - 0.5 ) ; page . height = ( size_t ) ceil ( ( double ) ( page . height * resolution . y / delta . y ) - 0.5 ) ; ( void ) memset ( & bounds , 0 , sizeof ( bounds ) ) ; ( void ) memset ( command , 0 , sizeof ( command ) ) ; cmyk = image_info -> colorspace == CMYKColorspace ? MagickTrue : MagickFalse ; ( void ) memset ( & hires_bounds , 0 , sizeof ( hires_bounds ) ) ; priority = 0 ; columns = 0 ; rows = 0 ; extent = 0 ; spotcolor = 0 ; language_level = 1 ; skip = MagickFalse ; pages = ( ~ 0UL ) ; p = command ; for ( c = ReadBlobByte ( image ) ; c != EOF ; c = ReadBlobByte ( image ) ) { * p ++ = ( char ) c ; if ( ( strchr ( \"\\\\n\\\\r%\" , c ) == ( char * ) NULL ) && ( ( size_t ) ( p - command ) < ( MaxTextExtent - 1 ) ) ) continue ; * p = '\\\\0' ; p = command ; if ( LocaleNCompare ( BeginDocument , command , strlen ( BeginDocument ) ) == 0 ) skip = MagickTrue ; if ( LocaleNCompare ( EndDocument , command , strlen ( EndDocument ) ) == 0 ) skip = MagickFalse ; if ( skip != MagickFalse ) continue ; if ( LocaleNCompare ( PostscriptLevel , command , strlen ( PostscriptLevel ) ) == 0 ) { ( void ) SetImageProperty ( image , \"ps:Level\" , command + 4 ) ; if ( GlobExpression ( command , \"*EPSF-*\" , MagickTrue ) != MagickFalse ) pages = 1 ; } if ( LocaleNCompare ( LanguageLevel , command , strlen ( LanguageLevel ) ) == 0 ) ( void ) sscanf ( command , LanguageLevel \"<S2SV_blank>%lu\" , & language_level ) ; if ( LocaleNCompare ( Pages , command , strlen ( Pages ) ) == 0 ) ( void ) sscanf ( command , Pages \"<S2SV_blank>%lu\" , & pages ) ; if ( LocaleNCompare ( ImageData , command , strlen ( ImageData ) ) == 0 ) ( void ) sscanf ( command , ImageData \"<S2SV_blank>%lu<S2SV_blank>%lu\" , & columns , & rows ) ; length = strlen ( DocumentProcessColors ) ; if ( LocaleNCompare ( DocumentProcessColors , command , length ) == 0 ) { if ( ( GlobExpression ( command , \"*Cyan*\" , MagickTrue ) != MagickFalse ) || ( GlobExpression ( command , \"*Magenta*\" , MagickTrue ) != MagickFalse ) || ( GlobExpression ( command , \"*Yellow*\" , MagickTrue ) != MagickFalse ) ) cmyk = MagickTrue ; } if ( LocaleNCompare ( CMYKCustomColor , command , strlen ( CMYKCustomColor ) ) == 0 ) cmyk = MagickTrue ; if ( LocaleNCompare ( CMYKProcessColor , command , strlen ( CMYKProcessColor ) ) == 0 ) cmyk = MagickTrue ; length = strlen ( DocumentCustomColors ) ; if ( ( LocaleNCompare ( DocumentCustomColors , command , length ) == 0 ) || ( LocaleNCompare ( CMYKCustomColor , command , strlen ( CMYKCustomColor ) ) == 0 ) || ( LocaleNCompare ( SpotColor , command , strlen ( SpotColor ) ) == 0 ) ) { char property [ MaxTextExtent ] , * value ; register char * p ; ( void ) FormatLocaleString ( property , MaxTextExtent , \"ps:SpotColor-%.20g\" , ( double ) ( spotcolor ++ ) ) ; for ( p = command ; * p != '\\\\0' ; p ++ ) if ( isspace ( ( int ) ( unsigned char ) * p ) != 0 ) break ; value = ConstantString ( p ) ; ( void ) SubstituteString ( & value , \"(\" , \"\" ) ; ( void ) SubstituteString ( & value , \")\" , \"\" ) ; ( void ) StripString ( value ) ; if ( * value != '\\\\0' ) ( void ) SetImageProperty ( image , property , value ) ; value = DestroyString ( value ) ; continue ; } if ( image_info -> page != ( char * ) NULL ) continue ; count = 0 ; i = 0 ; if ( LocaleNCompare ( BoundingBox , command , strlen ( BoundingBox ) ) == 0 ) { count = ( ssize_t ) sscanf ( command , BoundingBox \"<S2SV_blank>%lf<S2SV_blank>%lf<S2SV_blank>%lf<S2SV_blank>%lf\" , & bounds . x1 , & bounds . y1 , & bounds . x2 , & bounds . y2 ) ; i = 2 ; } if ( LocaleNCompare ( DocumentMedia , command , strlen ( DocumentMedia ) ) == 0 ) { count = ( ssize_t ) sscanf ( command , DocumentMedia \"<S2SV_blank>%lf<S2SV_blank>%lf<S2SV_blank>%lf<S2SV_blank>%lf\" , & bounds . x1 , & bounds . y1 , & bounds . x2 , & bounds . y2 ) ; i = 1 ; } if ( LocaleNCompare ( HiResBoundingBox , command , strlen ( HiResBoundingBox ) ) == 0 ) { count = ( ssize_t ) sscanf ( command , HiResBoundingBox \"<S2SV_blank>%lf<S2SV_blank>%lf<S2SV_blank>%lf<S2SV_blank>%lf\" , & bounds . x1 , & bounds . y1 , & bounds . x2 , & bounds . y2 ) ; i = 3 ; } if ( LocaleNCompare ( PageBoundingBox , command , strlen ( PageBoundingBox ) ) == 0 ) { count = ( ssize_t ) sscanf ( command , PageBoundingBox \"<S2SV_blank>%lf<S2SV_blank>%lf<S2SV_blank>%lf<S2SV_blank>%lf\" , & bounds . x1 , & bounds . y1 , & bounds . x2 , & bounds . y2 ) ; i = 1 ; } if ( LocaleNCompare ( PageMedia , command , strlen ( PageMedia ) ) == 0 ) { count = ( ssize_t ) sscanf ( command , PageMedia \"<S2SV_blank>%lf<S2SV_blank>%lf<S2SV_blank>%lf<S2SV_blank>%lf\" , & bounds . x1 , & bounds . y1 , & bounds . x2 , & bounds . y2 ) ; i = 1 ; } if ( ( count != 4 ) || ( i < ( ssize_t ) priority ) ) continue ; if ( ( fabs ( bounds . x2 - bounds . x1 ) <= fabs ( hires_bounds . x2 - hires_bounds . x1 ) ) || ( fabs ( bounds . y2 - bounds . y1 ) <= fabs ( hires_bounds . y2 - hires_bounds . y1 ) ) ) if ( i == ( ssize_t ) priority ) continue ; hires_bounds = bounds ; priority = ( size_t ) i ; } if ( ( fabs ( hires_bounds . x2 - hires_bounds . x1 ) >= MagickEpsilon ) && ( fabs ( hires_bounds . y2 - hires_bounds . y1 ) >= MagickEpsilon ) ) { ( void ) FormatLocaleString ( geometry , MaxTextExtent , \"%gx%g%+.15g%+.15g\" , hires_bounds . x2 - hires_bounds . x1 , hires_bounds . y2 - hires_bounds . y1 , hires_bounds . x1 , hires_bounds . y1 ) ; ( void ) SetImageProperty ( image , \"ps:HiResBoundingBox\" , geometry ) ; page . width = ( size_t ) ceil ( ( double ) ( ( hires_bounds . x2 - hires_bounds . x1 ) * resolution . x / delta . x ) - 0.5 ) ; page . height = ( size_t ) ceil ( ( double ) ( ( hires_bounds . y2 - hires_bounds . y1 ) * resolution . y / delta . y ) - 0.5 ) ; } fitPage = MagickFalse ; option = GetImageOption ( image_info , \"eps:fit-page\" ) ; if ( option != ( char * ) NULL ) { char * geometry ; MagickStatusType flags ; geometry = GetPageGeometry ( option ) ; flags = ParseMetaGeometry ( geometry , & page . x , & page . y , & page . width , & page . height ) ; if ( flags == NoValue ) { ( void ) ThrowMagickException ( exception , GetMagickModule ( ) , OptionError , <S2SV_StartBug> \"InvalidGeometry\" , \"`%s\\'\" , option ) ; <S2SV_EndBug> image = DestroyImage ( image ) ; return ( ( Image * ) NULL ) ; } page . width = ( size_t ) ceil ( ( double ) ( page . width * image -> x_resolution / delta . x ) - 0.5 ) ; page . height = ( size_t ) ceil ( ( double ) ( page . height * image -> y_resolution / delta . y ) - 0.5 ) ; geometry = DestroyString ( geometry ) ; fitPage = MagickTrue ; } if ( IssRGBCompatibleColorspace ( image_info -> colorspace ) != MagickFalse ) cmyk = MagickFalse ; file = AcquireUniqueFileResource ( postscript_filename ) ; if ( file == - 1 ) { ThrowFileException ( & image -> exception , FileOpenError , \"UnableToOpenFile\" , image_info -> filename ) ; image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } ( void ) CopyMagickString ( command , \"/setpagedevice<S2SV_blank>{pop}<S2SV_blank>bind<S2SV_blank>1<S2SV_blank>index<S2SV_blank>where<S2SV_blank>{\" \"dup<S2SV_blank>wcheck<S2SV_blank>{3<S2SV_blank>1<S2SV_blank>roll<S2SV_blank>put}<S2SV_blank>{pop<S2SV_blank>def}<S2SV_blank>ifelse}<S2SV_blank>{def}<S2SV_blank>ifelse\\\\n\" \"<</UseCIEColor<S2SV_blank>true>>setpagedevice\\\\n\" , MaxTextExtent ) ; count = write ( file , command , ( unsigned int ) strlen ( command ) ) ; if ( image_info -> page == ( char * ) NULL ) { char translate_geometry [ MaxTextExtent ] ; ( void ) FormatLocaleString ( translate_geometry , MaxTextExtent , \"%g<S2SV_blank>%g<S2SV_blank>translate\\\\n\" , - hires_bounds . x1 , - hires_bounds . y1 ) ; count = write ( file , translate_geometry , ( unsigned int ) strlen ( translate_geometry ) ) ; } file = close ( file ) - 1 ; if ( image_info -> monochrome != MagickFalse ) delegate_info = GetDelegateInfo ( \"ps:mono\" , ( char * ) NULL , exception ) ; else if ( cmyk != MagickFalse ) delegate_info = GetDelegateInfo ( \"ps:cmyk\" , ( char * ) NULL , exception ) ; else delegate_info = GetDelegateInfo ( \"ps:alpha\" , ( char * ) NULL , exception ) ; if ( delegate_info == ( const DelegateInfo * ) NULL ) { ( void ) RelinquishUniqueFileResource ( postscript_filename ) ; image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } density = AcquireString ( \"\" ) ; options = AcquireString ( \"\" ) ; ( void ) FormatLocaleString ( density , MaxTextExtent , \"%gx%g\" , resolution . x , resolution . y ) ; ( void ) FormatLocaleString ( options , MaxTextExtent , \"-g%.20gx%.20g<S2SV_blank>\" , ( double ) page . width , ( double ) page . height ) ; read_info = CloneImageInfo ( image_info ) ; * read_info -> magick = '\\\\0' ; if ( read_info -> number_scenes != 0 ) { char pages [ MaxTextExtent ] ; ( void ) FormatLocaleString ( pages , MaxTextExtent , \"-dFirstPage=%.20g<S2SV_blank>\" \"-dLastPage=%.20g<S2SV_blank>\" , ( double ) read_info -> scene + 1 , ( double ) ( read_info -> scene + read_info -> number_scenes ) ) ; ( void ) ConcatenateMagickString ( options , pages , MaxTextExtent ) ; read_info -> number_scenes = 0 ; if ( read_info -> scenes != ( char * ) NULL ) * read_info -> scenes = '\\\\0' ; } if ( * image_info -> magick == 'E' ) { option = GetImageOption ( image_info , \"eps:use-cropbox\" ) ; if ( ( option == ( const char * ) NULL ) || ( IsStringTrue ( option ) != MagickFalse ) ) ( void ) ConcatenateMagickString ( options , \"-dEPSCrop<S2SV_blank>\" , MaxTextExtent ) ; if ( fitPage != MagickFalse ) ( void ) ConcatenateMagickString ( options , \"-dEPSFitPage<S2SV_blank>\" , MaxTextExtent ) ; } ( void ) CopyMagickString ( filename , read_info -> filename , MaxTextExtent ) ; ( void ) AcquireUniqueFilename ( filename ) ; ( void ) RelinquishUniqueFileResource ( filename ) ; ( void ) ConcatenateMagickString ( filename , \"%d\" , MaxTextExtent ) ; ( void ) FormatLocaleString ( command , MaxTextExtent , GetDelegateCommands ( delegate_info ) , read_info -> antialias != MagickFalse ? 4 : 1 , read_info -> antialias != MagickFalse ? 4 : 1 , density , options , filename , postscript_filename , input_filename ) ; options = DestroyString ( options ) ; density = DestroyString ( density ) ; * message = '\\\\0' ; status = InvokePostscriptDelegate ( read_info -> verbose , command , message , exception ) ; ( void ) InterpretImageFilename ( image_info , image , filename , 1 , read_info -> filename ) ; if ( ( status == MagickFalse ) || ( IsPostscriptRendered ( read_info -> filename ) == MagickFalse ) ) { ( void ) ConcatenateMagickString ( command , \"<S2SV_blank>-c<S2SV_blank>showpage\" , MaxTextExtent ) ; status = InvokePostscriptDelegate ( read_info -> verbose , command , message , exception ) ; } ( void ) RelinquishUniqueFileResource ( postscript_filename ) ; ( void ) RelinquishUniqueFileResource ( input_filename ) ; postscript_image = ( Image * ) NULL ; if ( status == MagickFalse ) for ( i = 1 ; ; i ++ ) { ( void ) InterpretImageFilename ( image_info , image , filename , ( int ) i , read_info -> filename ) ; if ( IsPostscriptRendered ( read_info -> filename ) == MagickFalse ) break ; ( void ) RelinquishUniqueFileResource ( read_info -> filename ) ; } else for ( i = 1 ; ; i ++ ) { ( void ) InterpretImageFilename ( image_info , image , filename , ( int ) i , read_info -> filename ) ; if ( IsPostscriptRendered ( read_info -> filename ) == MagickFalse ) break ; read_info -> blob = NULL ; read_info -> length = 0 ; next = ReadImage ( read_info , exception ) ; ( void ) RelinquishUniqueFileResource ( read_info -> filename ) ; if ( next == ( Image * ) NULL ) break ; AppendImageToList ( & postscript_image , next ) ; } ( void ) RelinquishUniqueFileResource ( read_info -> filename ) ; read_info = DestroyImageInfo ( read_info ) ; if ( postscript_image == ( Image * ) NULL ) { if ( * message != '\\\\0' ) ( void ) ThrowMagickException ( exception , GetMagickModule ( ) , DelegateError , \"PostscriptDelegateFailed\" , \"`%s\\'\" , message ) ; image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } if ( LocaleCompare ( postscript_image -> magick , \"BMP\" ) == 0 ) { Image * cmyk_image ; cmyk_image = ConsolidateCMYKImages ( postscript_image , exception ) ; if ( cmyk_image != ( Image * ) NULL ) { postscript_image = DestroyImageList ( postscript_image ) ; postscript_image = cmyk_image ; } } ( void ) SeekBlob ( image , 0 , SEEK_SET ) ; for ( c = ReadBlobByte ( image ) ; c != EOF ; c = ReadBlobByte ( image ) ) { * p ++ = ( char ) c ; if ( ( strchr ( \"\\\\n\\\\r%\" , c ) == ( char * ) NULL ) && ( ( size_t ) ( p - command ) < ( MaxTextExtent - 1 ) ) ) continue ; * p = '\\\\0' ; p = command ; if ( LocaleNCompare ( BeginDocument , command , strlen ( BeginDocument ) ) == 0 ) skip = MagickTrue ; if ( LocaleNCompare ( EndDocument , command , strlen ( EndDocument ) ) == 0 ) skip = MagickFalse ; if ( skip != MagickFalse ) continue ; if ( LocaleNCompare ( PostscriptLevel , command , strlen ( PostscriptLevel ) ) == 0 ) { ( void ) SetImageProperty ( image , \"ps:Level\" , command + 4 ) ; if ( GlobExpression ( command , \"*EPSF-*\" , MagickTrue ) != MagickFalse ) pages = 1 ; } if ( LocaleNCompare ( LanguageLevel , command , strlen ( LanguageLevel ) ) == 0 ) ( void ) sscanf ( command , LanguageLevel \"<S2SV_blank>%lu\" , & language_level ) ; if ( LocaleNCompare ( Pages , command , strlen ( Pages ) ) == 0 ) ( void ) sscanf ( command , Pages \"<S2SV_blank>%lu\" , & pages ) ; if ( LocaleNCompare ( ImageData , command , strlen ( ImageData ) ) == 0 ) ( void ) sscanf ( command , ImageData \"<S2SV_blank>%lu<S2SV_blank>%lu\" , & columns , & rows ) ; if ( LocaleNCompare ( ICCProfile , command , strlen ( ICCProfile ) ) == 0 ) { unsigned char * datum ; profile = AcquireStringInfo ( MaxTextExtent ) ; datum = GetStringInfoDatum ( profile ) ; for ( i = 0 ; ( c = ProfileInteger ( image , hex_digits ) ) != EOF ; i ++ ) { if ( i >= ( ssize_t ) GetStringInfoLength ( profile ) ) { SetStringInfoLength ( profile , ( size_t ) i << 1 ) ; datum = GetStringInfoDatum ( profile ) ; } datum [ i ] = ( unsigned char ) c ; } SetStringInfoLength ( profile , ( size_t ) i + 1 ) ; ( void ) SetImageProfile ( image , \"icc\" , profile ) ; profile = DestroyStringInfo ( profile ) ; continue ; } if ( LocaleNCompare ( PhotoshopProfile , command , strlen ( PhotoshopProfile ) ) == 0 ) { unsigned char * p ; count = ( ssize_t ) sscanf ( command , PhotoshopProfile \"<S2SV_blank>%lu\" , & extent ) ; if ( count != 1 ) continue ; length = extent ; if ( ( MagickSizeType ) length > GetBlobSize ( image ) ) ThrowReaderException ( CorruptImageError , \"InsufficientImageDataInFile\" ) ; profile = BlobToStringInfo ( ( const void * ) NULL , length ) ; if ( profile != ( StringInfo * ) NULL ) { p = GetStringInfoDatum ( profile ) ; for ( i = 0 ; i < ( ssize_t ) length ; i ++ ) * p ++ = ( unsigned char ) ProfileInteger ( image , hex_digits ) ; ( void ) SetImageProfile ( image , \"8bim\" , profile ) ; profile = DestroyStringInfo ( profile ) ; } continue ; } if ( LocaleNCompare ( BeginXMPPacket , command , strlen ( BeginXMPPacket ) ) == 0 ) { register size_t i ; p = command ; profile = StringToStringInfo ( command ) ; for ( i = GetStringInfoLength ( profile ) - 1 ; c != EOF ; i ++ ) { SetStringInfoLength ( profile , ( size_t ) ( i + 1 ) ) ; c = ReadBlobByte ( image ) ; GetStringInfoDatum ( profile ) [ i ] = ( unsigned char ) c ; * p ++ = ( char ) c ; if ( ( strchr ( \"\\\\n\\\\r%\" , c ) == ( char * ) NULL ) && ( ( size_t ) ( p - command ) < ( MaxTextExtent - 1 ) ) ) continue ; * p = '\\\\0' ; p = command ; if ( LocaleNCompare ( EndXMPPacket , command , strlen ( EndXMPPacket ) ) == 0 ) break ; } SetStringInfoLength ( profile , ( size_t ) i ) ; ( void ) SetImageProfile ( image , \"xmp\" , profile ) ; profile = DestroyStringInfo ( profile ) ; continue ; } } ( void ) CloseBlob ( image ) ; if ( image_info -> number_scenes != 0 ) { Image * clone_image ; register ssize_t i ; for ( i = 0 ; i < ( ssize_t ) image_info -> scene ; i ++ ) { clone_image = CloneImage ( postscript_image , 1 , 1 , MagickTrue , exception ) ; if ( clone_image != ( Image * ) NULL ) PrependImageToList ( & postscript_image , clone_image ) ; } } do { ( void ) CopyMagickString ( postscript_image -> filename , filename , MaxTextExtent ) ; ( void ) CopyMagickString ( postscript_image -> magick , image -> magick , MaxTextExtent ) ; if ( columns != 0 ) postscript_image -> magick_columns = columns ; if ( rows != 0 ) postscript_image -> magick_rows = rows ; postscript_image -> page = page ; ( void ) CloneImageProfiles ( postscript_image , image ) ; ( void ) CloneImageProperties ( postscript_image , image ) ; next = SyncNextImageInList ( postscript_image ) ; if ( next != ( Image * ) NULL ) postscript_image = next ; } while ( next != ( Image * ) NULL ) ; image = DestroyImageList ( image ) ; scene = 0 ; for ( next = GetFirstImageInList ( postscript_image ) ; next != ( Image * ) NULL ; ) { next -> scene = scene ++ ; next = GetNextImageInList ( next ) ; } return ( GetFirstImageInList ( postscript_image ) ) ; }\n","target":"<S2SV_ModStart> \"`%s\\'\" , option ) ; geometry = DestroyString ( geometry\n","project_and_commit_id":"ImageMagick@ImageMagick6/7d11230060fa9c8f67e53c85224daf6648805c7b","cve_id":"CVE-2019-13137","original_address":"https://github.com/ImageMagick/ImageMagick6/commit/7d11230060fa9c8f67e53c85224daf6648805c7b","time":"2019-07-01T20:15Z"},
	{"Unnamed: 0":4696,"cwe_id":"CWE-835","source":"CWE-835 static Status accept_xsmp_connection ( SmsConn sms_conn , GsmXsmpServer * server , unsigned long * mask_ret , SmsCallbacks * callbacks_ret , char * * failure_reason_ret ) { IceConn ice_conn ; <S2SV_StartBug> GsmXSMPClient * client ; <S2SV_EndBug> if ( server -> priv -> xsmp_sockets == NULL ) { g_debug ( \"GsmXsmpServer:<S2SV_blank>In<S2SV_blank>shutdown,<S2SV_blank>rejecting<S2SV_blank>new<S2SV_blank>client\" ) ; * failure_reason_ret = strdup ( _ ( \"Refusing<S2SV_blank>new<S2SV_blank>client<S2SV_blank>connection<S2SV_blank>because<S2SV_blank>the<S2SV_blank>session<S2SV_blank>is<S2SV_blank>currently<S2SV_blank>being<S2SV_blank>shut<S2SV_blank>down\\\\n\" ) ) ; return FALSE ; } ice_conn = SmsGetIceConnection ( sms_conn ) ; <S2SV_StartBug> client = ice_conn -> context ; <S2SV_EndBug> <S2SV_StartBug> g_return_val_if_fail ( client != NULL , TRUE ) ; <S2SV_EndBug> <S2SV_StartBug> gsm_xsmp_client_connect ( client , sms_conn , mask_ret , callbacks_ret ) ; <S2SV_EndBug> return TRUE ; }\n","target":"<S2SV_ModStart> IceConn ice_conn ; GsmClient * client ; GsmIceConnectionWatch * data <S2SV_ModEnd> ; if ( <S2SV_ModStart> sms_conn ) ; data <S2SV_ModEnd> = ice_conn -> <S2SV_ModStart> -> context ; free_ice_connection_watch ( data ) ; client = gsm_xsmp_client_new ( ice_conn ) ; gsm_store_add ( server -> priv -> client_store , gsm_client_peek_id ( client ) , G_OBJECT ( client ) ) ; g_object_unref ( client <S2SV_ModEnd> ) ; gsm_xsmp_client_connect <S2SV_ModStart> ; gsm_xsmp_client_connect ( GSM_XSMP_CLIENT ( client ) <S2SV_ModEnd> , sms_conn ,\n","project_and_commit_id":"GNOME@gnome-session/b0dc999e0b45355314616321dbb6cb71e729fc9d","cve_id":"CVE-2017-11171","original_address":"https://github.com/GNOME/gnome-session/commit/b0dc999e0b45355314616321dbb6cb71e729fc9d","time":"2017-07-11T20:29Z"},
	{"Unnamed: 0":85,"cwe_id":"CWE-264","source":"CWE-264 static int futex_wait_requeue_pi ( u32 __user * uaddr , unsigned int flags , u32 val , ktime_t * abs_time , u32 bitset , u32 __user * uaddr2 ) { struct hrtimer_sleeper timeout , * to = NULL ; struct rt_mutex_waiter rt_waiter ; struct rt_mutex * pi_mutex = NULL ; struct futex_hash_bucket * hb ; union futex_key key2 = FUTEX_KEY_INIT ; struct futex_q q = futex_q_init ; int res , ret ; if ( uaddr == uaddr2 ) return - EINVAL ; if ( ! bitset ) return - EINVAL ; if ( abs_time ) { to = & timeout ; hrtimer_init_on_stack ( & to -> timer , ( flags & FLAGS_CLOCKRT ) ? CLOCK_REALTIME : CLOCK_MONOTONIC , HRTIMER_MODE_ABS ) ; hrtimer_init_sleeper ( to , current ) ; hrtimer_set_expires_range_ns ( & to -> timer , * abs_time , current -> timer_slack_ns ) ; } debug_rt_mutex_init_waiter ( & rt_waiter ) ; RB_CLEAR_NODE ( & rt_waiter . pi_tree_entry ) ; RB_CLEAR_NODE ( & rt_waiter . tree_entry ) ; rt_waiter . task = NULL ; ret = get_futex_key ( uaddr2 , flags & FLAGS_SHARED , & key2 , VERIFY_WRITE ) ; if ( unlikely ( ret != 0 ) ) goto out ; q . bitset = bitset ; q . rt_waiter = & rt_waiter ; q . requeue_pi_key = & key2 ; ret = futex_wait_setup ( uaddr , val , flags , & q , & hb ) ; if ( ret ) goto out_key2 ; <S2SV_StartBug> futex_wait_queue_me ( hb , & q , to ) ; <S2SV_EndBug> spin_lock ( & hb -> lock ) ; ret = handle_early_requeue_pi_wakeup ( hb , & q , & key2 , to ) ; spin_unlock ( & hb -> lock ) ; if ( ret ) goto out_put_keys ; if ( ! q . rt_waiter ) { if ( q . pi_state && ( q . pi_state -> owner != current ) ) { spin_lock ( q . lock_ptr ) ; ret = fixup_pi_state_owner ( uaddr2 , & q , current ) ; spin_unlock ( q . lock_ptr ) ; } } else { WARN_ON ( ! q . pi_state ) ; pi_mutex = & q . pi_state -> pi_mutex ; ret = rt_mutex_finish_proxy_lock ( pi_mutex , to , & rt_waiter , 1 ) ; debug_rt_mutex_free_waiter ( & rt_waiter ) ; spin_lock ( q . lock_ptr ) ; res = fixup_owner ( uaddr2 , & q , ! ret ) ; if ( res ) ret = ( res < 0 ) ? res : 0 ; unqueue_me_pi ( & q ) ; } if ( ret == - EFAULT ) { if ( pi_mutex && rt_mutex_owner ( pi_mutex ) == current ) rt_mutex_unlock ( pi_mutex ) ; } else if ( ret == - EINTR ) { ret = - EWOULDBLOCK ; } out_put_keys : put_futex_key ( & q . key ) ; out_key2 : put_futex_key ( & key2 ) ; out : if ( to ) { hrtimer_cancel ( & to -> timer ) ; destroy_hrtimer_on_stack ( & to -> timer ) ; } return ret ; }\n","target":"<S2SV_ModStart> goto out_key2 ; if ( match_futex ( & q . key , & key2 ) ) { ret = - EINVAL ; goto out_put_keys ; }\n","project_and_commit_id":"torvalds@linux/e9c243a5a6de0be8e584c604d353412584b592f8","cve_id":"CVE-2014-3153","original_address":"https://github.com/torvalds/linux/commit/e9c243a5a6de0be8e584c604d353412584b592f8","time":"2014-06-07T14:55Z"},
	{"Unnamed: 0":110,"cwe_id":"CWE-125","source":"CWE-125 <S2SV_StartBug> int ntlm_read_message_fields ( wStream * s , NTLM_MESSAGE_FIELDS * fields ) <S2SV_EndBug> { if ( Stream_GetRemainingLength ( s ) < 8 ) return - 1 ; Stream_Read_UINT16 ( s , fields -> Len ) ; Stream_Read_UINT16 ( s , fields -> MaxLen ) ; Stream_Read_UINT32 ( s , fields -> BufferOffset ) ; return 1 ; }\n","target":"<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> static\n","project_and_commit_id":"FreeRDP@FreeRDP/2ee663f39dc8dac3d9988e847db19b2d7e3ac8c6","cve_id":"CVE-2018-8789","original_address":"https://github.com/FreeRDP/FreeRDP/commit/2ee663f39dc8dac3d9988e847db19b2d7e3ac8c6","time":"2018-11-29T18:29Z"},
	{"Unnamed: 0":2180,"cwe_id":"CWE-787","source":"CWE-787 static int decode_zbuf ( AVBPrint * bp , const uint8_t * data , const uint8_t * data_end ) { z_stream zstream ; unsigned char * buf ; unsigned buf_size ; int ret ; zstream . zalloc = ff_png_zalloc ; zstream . zfree = ff_png_zfree ; zstream . opaque = NULL ; if ( inflateInit ( & zstream ) != Z_OK ) return AVERROR_EXTERNAL ; zstream . next_in = ( unsigned char * ) data ; zstream . avail_in = data_end - data ; av_bprint_init ( bp , 0 , - 1 ) ; while ( zstream . avail_in > 0 ) { <S2SV_StartBug> av_bprint_get_buffer ( bp , 1 , & buf , & buf_size ) ; <S2SV_EndBug> if ( ! buf_size ) { ret = AVERROR ( ENOMEM ) ; goto fail ; } zstream . next_out = buf ; <S2SV_StartBug> zstream . avail_out = buf_size ; <S2SV_EndBug> ret = inflate ( & zstream , Z_PARTIAL_FLUSH ) ; if ( ret != Z_OK && ret != Z_STREAM_END ) { ret = AVERROR_EXTERNAL ; goto fail ; } bp -> len += zstream . next_out - buf ; if ( ret == Z_STREAM_END ) break ; } inflateEnd ( & zstream ) ; bp -> str [ bp -> len ] = 0 ; return 0 ; fail : inflateEnd ( & zstream ) ; av_bprint_finalize ( bp , NULL ) ; return ret ; }\n","target":"<S2SV_ModStart> ( bp , 2 , & buf , & buf_size ) ; if ( buf_size < 2 <S2SV_ModEnd> ) { ret <S2SV_ModStart> avail_out = buf_size - 1\n","project_and_commit_id":"FFmpeg@FFmpeg/e371f031b942d73e02c090170975561fabd5c264","cve_id":"CVE-2017-7866","original_address":"https://github.com/FFmpeg/FFmpeg/commit/e371f031b942d73e02c090170975561fabd5c264","time":"2017-04-14T04:59Z"},
	{"Unnamed: 0":3697,"cwe_id":"CWE-125","source":"CWE-125 static bool _bson_iter_next_internal ( bson_iter_t * iter , uint32_t next_keylen , const char * * key , uint32_t * bson_type , bool * unsupported ) { const uint8_t * data ; uint32_t o ; unsigned int len ; BSON_ASSERT ( iter ) ; * unsupported = false ; if ( ! iter -> raw ) { * key = NULL ; * bson_type = BSON_TYPE_EOD ; return false ; } data = iter -> raw ; len = iter -> len ; iter -> off = iter -> next_off ; iter -> type = iter -> off ; iter -> key = iter -> off + 1 ; iter -> d1 = 0 ; iter -> d2 = 0 ; iter -> d3 = 0 ; iter -> d4 = 0 ; if ( next_keylen == 0 ) { for ( o = iter -> key ; o < len ; o ++ ) { if ( ! data [ o ] ) { iter -> d1 = ++ o ; goto fill_data_fields ; } } } else { o = iter -> key + next_keylen + 1 ; iter -> d1 = o ; goto fill_data_fields ; } goto mark_invalid ; fill_data_fields : * key = bson_iter_key_unsafe ( iter ) ; * bson_type = ITER_TYPE ( iter ) ; switch ( * bson_type ) { case BSON_TYPE_DATE_TIME : case BSON_TYPE_DOUBLE : case BSON_TYPE_INT64 : case BSON_TYPE_TIMESTAMP : iter -> next_off = o + 8 ; break ; case BSON_TYPE_CODE : case BSON_TYPE_SYMBOL : case BSON_TYPE_UTF8 : { uint32_t l ; if ( ( o + 4 ) >= len ) { iter -> err_off = o ; goto mark_invalid ; } iter -> d2 = o + 4 ; memcpy ( & l , iter -> raw + iter -> d1 , sizeof ( l ) ) ; l = BSON_UINT32_FROM_LE ( l ) ; if ( l > ( len - ( o + 4 ) ) ) { iter -> err_off = o ; goto mark_invalid ; } iter -> next_off = o + 4 + l ; if ( BSON_UNLIKELY ( ( l == 0 ) || ( iter -> next_off >= len ) ) ) { iter -> err_off = o ; goto mark_invalid ; } if ( BSON_UNLIKELY ( ( iter -> raw + iter -> d2 ) [ l - 1 ] != '\\\\0' ) ) { iter -> err_off = o + 4 + l - 1 ; goto mark_invalid ; } } break ; case BSON_TYPE_BINARY : { bson_subtype_t subtype ; uint32_t l ; if ( o >= ( len - 4 ) ) { iter -> err_off = o ; goto mark_invalid ; } iter -> d2 = o + 4 ; iter -> d3 = o + 5 ; memcpy ( & l , iter -> raw + iter -> d1 , sizeof ( l ) ) ; l = BSON_UINT32_FROM_LE ( l ) ; <S2SV_StartBug> if ( l >= ( len - o ) ) { <S2SV_EndBug> iter -> err_off = o ; goto mark_invalid ; } subtype = * ( iter -> raw + iter -> d2 ) ; if ( subtype == BSON_SUBTYPE_BINARY_DEPRECATED ) { int32_t binary_len ; if ( l < 4 ) { iter -> err_off = o ; goto mark_invalid ; } memcpy ( & binary_len , ( iter -> raw + iter -> d3 ) , sizeof ( binary_len ) ) ; binary_len = BSON_UINT32_FROM_LE ( binary_len ) ; if ( binary_len + 4 != l ) { iter -> err_off = iter -> d3 ; goto mark_invalid ; } } iter -> next_off = o + 5 + l ; } break ; case BSON_TYPE_ARRAY : case BSON_TYPE_DOCUMENT : { uint32_t l ; if ( o >= ( len - 4 ) ) { iter -> err_off = o ; goto mark_invalid ; } memcpy ( & l , iter -> raw + iter -> d1 , sizeof ( l ) ) ; l = BSON_UINT32_FROM_LE ( l ) ; if ( ( l > len ) || ( l > ( len - o ) ) ) { iter -> err_off = o ; goto mark_invalid ; } iter -> next_off = o + l ; } break ; case BSON_TYPE_OID : iter -> next_off = o + 12 ; break ; case BSON_TYPE_BOOL : { char val ; if ( iter -> d1 >= len ) { iter -> err_off = o ; goto mark_invalid ; } memcpy ( & val , iter -> raw + iter -> d1 , 1 ) ; if ( val != 0x00 && val != 0x01 ) { iter -> err_off = o ; goto mark_invalid ; } iter -> next_off = o + 1 ; } break ; case BSON_TYPE_REGEX : { bool eor = false ; bool eoo = false ; for ( ; o < len ; o ++ ) { if ( ! data [ o ] ) { iter -> d2 = ++ o ; eor = true ; break ; } } if ( ! eor ) { iter -> err_off = iter -> next_off ; goto mark_invalid ; } for ( ; o < len ; o ++ ) { if ( ! data [ o ] ) { eoo = true ; break ; } } if ( ! eoo ) { iter -> err_off = iter -> next_off ; goto mark_invalid ; } iter -> next_off = o + 1 ; } break ; case BSON_TYPE_DBPOINTER : { uint32_t l ; if ( o >= ( len - 4 ) ) { iter -> err_off = o ; goto mark_invalid ; } iter -> d2 = o + 4 ; memcpy ( & l , iter -> raw + iter -> d1 , sizeof ( l ) ) ; l = BSON_UINT32_FROM_LE ( l ) ; if ( l == 0 || l > ( len - o - 4 ) ) { iter -> err_off = o ; goto mark_invalid ; } if ( * ( iter -> raw + o + l + 3 ) ) { iter -> err_off = o + l + 3 ; goto mark_invalid ; } iter -> d3 = o + 4 + l ; iter -> next_off = o + 4 + l + 12 ; } break ; case BSON_TYPE_CODEWSCOPE : { uint32_t l ; uint32_t doclen ; if ( ( len < 19 ) || ( o >= ( len - 14 ) ) ) { iter -> err_off = o ; goto mark_invalid ; } iter -> d2 = o + 4 ; iter -> d3 = o + 8 ; memcpy ( & l , iter -> raw + iter -> d1 , sizeof ( l ) ) ; l = BSON_UINT32_FROM_LE ( l ) ; if ( ( l < 14 ) || ( l >= ( len - o ) ) ) { iter -> err_off = o ; goto mark_invalid ; } iter -> next_off = o + l ; if ( iter -> next_off >= len ) { iter -> err_off = o ; goto mark_invalid ; } memcpy ( & l , iter -> raw + iter -> d2 , sizeof ( l ) ) ; l = BSON_UINT32_FROM_LE ( l ) ; if ( l == 0 || l >= ( len - o - 4 - 4 ) ) { iter -> err_off = o ; goto mark_invalid ; } if ( ( o + 4 + 4 + l + 4 ) >= iter -> next_off ) { iter -> err_off = o + 4 ; goto mark_invalid ; } iter -> d4 = o + 4 + 4 + l ; memcpy ( & doclen , iter -> raw + iter -> d4 , sizeof ( doclen ) ) ; doclen = BSON_UINT32_FROM_LE ( doclen ) ; if ( ( o + 4 + 4 + l + doclen ) != iter -> next_off ) { iter -> err_off = o + 4 + 4 + l ; goto mark_invalid ; } } break ; case BSON_TYPE_INT32 : iter -> next_off = o + 4 ; break ; case BSON_TYPE_DECIMAL128 : iter -> next_off = o + 16 ; break ; case BSON_TYPE_MAXKEY : case BSON_TYPE_MINKEY : case BSON_TYPE_NULL : case BSON_TYPE_UNDEFINED : iter -> next_off = o ; break ; default : * unsupported = true ; case BSON_TYPE_EOD : iter -> err_off = o ; goto mark_invalid ; } if ( iter -> next_off >= len ) { iter -> err_off = o ; goto mark_invalid ; } iter -> err_off = 0 ; return true ; mark_invalid : iter -> raw = NULL ; iter -> len = 0 ; iter -> next_off = 0 ; return false ; }\n","target":"<S2SV_ModStart> len - o - 4\n","project_and_commit_id":"mongodb@mongo-c-driver/0d9a4d98bfdf4acd2c0138d4aaeb4e2e0934bd84","cve_id":"CVE-2018-16790","original_address":"https://github.com/mongodb/mongo-c-driver/commit/0d9a4d98bfdf4acd2c0138d4aaeb4e2e0934bd84","time":"2018-09-10T05:29Z"},
	{"Unnamed: 0":3543,"cwe_id":"CWE-415","source":"CWE-415 static OM_uint32 init_ctx_reselect ( OM_uint32 * minor_status , spnego_gss_ctx_id_t sc , OM_uint32 acc_negState , gss_OID supportedMech , gss_buffer_t * responseToken , gss_buffer_t * mechListMIC , OM_uint32 * negState , send_token_flag * tokflag ) { OM_uint32 tmpmin ; <S2SV_StartBug> size_t i ; <S2SV_EndBug> generic_gss_release_oid ( & tmpmin , & sc -> internal_mech ) ; gss_delete_sec_context ( & tmpmin , & sc -> ctx_handle , GSS_C_NO_BUFFER ) ; for ( i = 0 ; i < sc -> mech_set -> count ; i ++ ) { if ( g_OID_equal ( supportedMech , & sc -> mech_set -> elements [ i ] ) ) break ; } if ( i == sc -> mech_set -> count ) return GSS_S_DEFECTIVE_TOKEN ; sc -> internal_mech = & sc -> mech_set -> elements [ i ] ; if ( acc_negState != REQUEST_MIC ) return GSS_S_DEFECTIVE_TOKEN ; sc -> mech_complete = 0 ; sc -> mic_reqd = 1 ; * negState = REQUEST_MIC ; * tokflag = CONT_TOKEN_SEND ; return GSS_S_CONTINUE_NEEDED ; }\n","target":"<S2SV_ModStart> ; size_t i <S2SV_ModEnd> ; gss_delete_sec_context (\n","project_and_commit_id":"krb5@krb5/f18ddf5d82de0ab7591a36e465bc24225776940f","cve_id":"CVE-2014-4343","original_address":"https://github.com/krb5/krb5/commit/f18ddf5d82de0ab7591a36e465bc24225776940f","time":"2014-08-14T05:01Z"},
	{"Unnamed: 0":4631,"cwe_id":"CWE-119","source":"CWE-119 static size_t encode_tiles ( VP9_COMP * cpi , uint8_t * data_ptr ) { VP9_COMMON * const cm = & cpi -> common ; <S2SV_StartBug> vp9_writer residual_bc ; <S2SV_EndBug> int tile_row , tile_col ; <S2SV_StartBug> TOKENEXTRA * tok [ 4 ] [ 1 << 6 ] , * tok_end ; <S2SV_EndBug> size_t total_size = 0 ; const int tile_cols = 1 << cm -> log2_tile_cols ; const int tile_rows = 1 << cm -> log2_tile_rows ; <S2SV_StartBug> vpx_memset ( cm -> above_seg_context , 0 , sizeof ( * cm -> above_seg_context ) * <S2SV_EndBug> mi_cols_aligned_to_sb ( cm -> mi_cols ) ) ; <S2SV_StartBug> tok [ 0 ] [ 0 ] = cpi -> tok ; <S2SV_EndBug> for ( tile_row = 0 ; tile_row < tile_rows ; tile_row ++ ) { if ( tile_row ) tok [ tile_row ] [ 0 ] = tok [ tile_row - 1 ] [ tile_cols - 1 ] + cpi -> tok_count [ tile_row - 1 ] [ tile_cols - 1 ] ; for ( tile_col = 1 ; tile_col < tile_cols ; tile_col ++ ) tok [ tile_row ] [ tile_col ] = tok [ tile_row ] [ tile_col - 1 ] + cpi -> tok_count [ tile_row ] [ tile_col - 1 ] ; } for ( tile_row = 0 ; tile_row < tile_rows ; tile_row ++ ) { for ( tile_col = 0 ; tile_col < tile_cols ; tile_col ++ ) { TileInfo tile ; vp9_tile_init ( & tile , cm , tile_row , tile_col ) ; <S2SV_StartBug> tok_end = tok [ tile_row ] [ tile_col ] + cpi -> tok_count [ tile_row ] [ tile_col ] ; <S2SV_EndBug> if ( tile_col < tile_cols - 1 || tile_row < tile_rows - 1 ) <S2SV_StartBug> vp9_start_encode ( & residual_bc , data_ptr + total_size + 4 ) ; <S2SV_EndBug> else <S2SV_StartBug> vp9_start_encode ( & residual_bc , data_ptr + total_size ) ; <S2SV_EndBug> <S2SV_StartBug> write_modes ( cpi , & tile , & residual_bc , & tok [ tile_row ] [ tile_col ] , tok_end ) ; <S2SV_EndBug> <S2SV_StartBug> assert ( tok [ tile_row ] [ tile_col ] == tok_end ) ; <S2SV_EndBug> <S2SV_StartBug> vp9_stop_encode ( & residual_bc ) ; <S2SV_EndBug> if ( tile_col < tile_cols - 1 || tile_row < tile_rows - 1 ) { mem_put_be32 ( data_ptr + total_size , residual_bc . pos ) ; total_size += 4 ; } total_size += residual_bc . pos ; } } return total_size ; }\n","target":"<S2SV_ModStart> -> common ; vpx_writer <S2SV_ModEnd> residual_bc ; int <S2SV_ModStart> tile_col ; TOKENEXTRA <S2SV_ModEnd> * tok_end ; <S2SV_ModStart> -> log2_tile_rows ; memset <S2SV_ModEnd> ( cm -> <S2SV_ModStart> ) ) ; for ( tile_row = 0 ; tile_row < tile_rows ; tile_row ++ ) { for ( tile_col = 0 ; tile_col < tile_cols ; tile_col ++ ) { int tile_idx = tile_row * tile_cols + tile_col ; TOKENEXTRA * tok = cpi -> tile_tok [ tile_row ] [ tile_col ] <S2SV_ModEnd> ; tok_end = <S2SV_ModStart> ; tok_end = cpi -> tile_tok [ tile_row ] [ tile_col ] + <S2SV_ModEnd> cpi -> tok_count <S2SV_ModStart> - 1 ) vpx_start_encode <S2SV_ModEnd> ( & residual_bc <S2SV_ModStart> ) ; else vpx_start_encode <S2SV_ModEnd> ( & residual_bc <S2SV_ModStart> cpi , & cpi -> tile_data [ tile_idx ] . tile_info , <S2SV_ModEnd> & residual_bc , <S2SV_ModStart> , & tok <S2SV_ModEnd> , tok_end ) <S2SV_ModStart> assert ( tok <S2SV_ModEnd> == tok_end ) <S2SV_ModStart> tok_end ) ; vpx_stop_encode <S2SV_ModEnd> ( & residual_bc\n","project_and_commit_id":"external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426","cve_id":"CVE-2016-1621","original_address":"https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426","time":"2016-03-12T21:59Z"},
	{"Unnamed: 0":885,"cwe_id":"CWE-119","source":"CWE-119 <S2SV_StartBug> static int read_mv_component ( vp9_reader * r , <S2SV_EndBug> const nmv_component * mvcomp , int usehp ) { int mag , d , fr , hp ; <S2SV_StartBug> const int sign = vp9_read ( r , mvcomp -> sign ) ; <S2SV_EndBug> <S2SV_StartBug> const int mv_class = vp9_read_tree ( r , vp9_mv_class_tree , mvcomp -> classes ) ; <S2SV_EndBug> const int class0 = mv_class == MV_CLASS_0 ; if ( class0 ) { <S2SV_StartBug> d = vp9_read_tree ( r , vp9_mv_class0_tree , mvcomp -> class0 ) ; <S2SV_EndBug> } else { int i ; const int n = mv_class + CLASS0_BITS - 1 ; d = 0 ; for ( i = 0 ; i < n ; ++ i ) <S2SV_StartBug> d |= vp9_read ( r , mvcomp -> bits [ i ] ) << i ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> <S2SV_StartBug> fr = vp9_read_tree ( r , vp9_mv_fp_tree , class0 ? mvcomp -> class0_fp [ d ] <S2SV_EndBug> : mvcomp -> fp ) ; <S2SV_StartBug> hp = usehp ? vp9_read ( r , class0 ? mvcomp -> class0_hp : mvcomp -> hp ) <S2SV_EndBug> : 1 ; <S2SV_StartBug> mag = vp9_get_mv_mag ( mv_class , ( d << 3 ) | ( fr << 1 ) | hp ) + 1 ; <S2SV_EndBug> return sign ? - mag : mag ; }\n","target":"<S2SV_ModStart> int read_mv_component ( vpx_reader <S2SV_ModEnd> * r , <S2SV_ModStart> int sign = vpx_read <S2SV_ModEnd> ( r , <S2SV_ModStart> int mv_class = vpx_read_tree <S2SV_ModEnd> ( r , <S2SV_ModStart> { d = vpx_read_tree <S2SV_ModEnd> ( r , <S2SV_ModStart> -> class0 ) ; mag = 0 <S2SV_ModStart> ) d |= vpx_read <S2SV_ModEnd> ( r , <S2SV_ModStart> << i ; mag = CLASS0_SIZE << ( mv_class + 2 ) ; <S2SV_ModStart> } fr = vpx_read_tree <S2SV_ModEnd> ( r , <S2SV_ModStart> = usehp ? vpx_read <S2SV_ModEnd> ( r , <S2SV_ModStart> 1 ; mag += ( <S2SV_ModEnd> ( d <<\n","project_and_commit_id":"external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426","cve_id":"CVE-2016-1621","original_address":"https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426","time":"2016-03-12T21:59Z"},
	{"Unnamed: 0":154,"cwe_id":"CWE-400","source":"CWE-400 static void perf_log_throttle ( struct perf_event * event , int enable ) { struct perf_output_handle handle ; struct perf_sample_data sample ; int ret ; struct { struct perf_event_header header ; u64 time ; u64 id ; u64 stream_id ; } throttle_event = { . header = { . type = PERF_RECORD_THROTTLE , . misc = 0 , . size = sizeof ( throttle_event ) , } , . time = perf_clock ( ) , . id = primary_event_id ( event ) , . stream_id = event -> id , } ; if ( enable ) throttle_event . header . type = PERF_RECORD_UNTHROTTLE ; perf_event_header__init_id ( & throttle_event . header , & sample , event ) ; ret = perf_output_begin ( & handle , event , <S2SV_StartBug> throttle_event . header . size , 1 , 0 ) ; <S2SV_EndBug> if ( ret ) return ; perf_output_put ( & handle , throttle_event ) ; perf_event__output_id_sample ( event , & handle , & sample ) ; perf_output_end ( & handle ) ; }\n","target":"<S2SV_ModStart> . size , <S2SV_ModEnd> 0 ) ;\n","project_and_commit_id":"torvalds@linux/a8b0ca17b80e92faab46ee7179ba9e99ccb61233","cve_id":"CVE-2011-2918","original_address":"https://github.com/torvalds/linux/commit/a8b0ca17b80e92faab46ee7179ba9e99ccb61233","time":"2012-05-24T23:55Z"},
	{"Unnamed: 0":4718,"cwe_id":"CWE-119","source":"CWE-119 int mlx4_register_vlan ( struct mlx4_dev * dev , u8 port , u16 vlan , int * index ) { struct mlx4_vlan_table * table = & mlx4_priv ( dev ) -> port [ port ] . vlan_table ; int i , err = 0 ; int free = - 1 ; mutex_lock ( & table -> mutex ) ; for ( i = MLX4_VLAN_REGULAR ; i < MLX4_MAX_VLAN_NUM ; i ++ ) { if ( free < 0 && ( table -> refs [ i ] == 0 ) ) { free = i ; continue ; } if ( table -> refs [ i ] && ( vlan == ( MLX4_VLAN_MASK & be32_to_cpu ( table -> entries [ i ] ) ) ) ) { * index = i ; ++ table -> refs [ i ] ; goto out ; <S2SV_StartBug> } <S2SV_EndBug> } if ( table -> total == table -> max ) { err = - ENOSPC ; goto out ; } table -> refs [ free ] = 1 ; table -> entries [ free ] = cpu_to_be32 ( vlan | MLX4_VLAN_VALID ) ; err = mlx4_set_port_vlan_table ( dev , port , table -> entries ) ; if ( unlikely ( err ) ) { mlx4_warn ( dev , \"Failed<S2SV_blank>adding<S2SV_blank>vlan:<S2SV_blank>%u\\\\n\" , vlan ) ; table -> refs [ free ] = 0 ; table -> entries [ free ] = 0 ; goto out ; } * index = free ; ++ table -> total ; out : mutex_unlock ( & table -> mutex ) ; return err ; }\n","target":"<S2SV_ModStart> out ; } } if ( free < 0 ) { err = - ENOMEM ; goto out ;\n","project_and_commit_id":"torvalds@linux/0926f91083f34d047abc74f1ca4fa6a9c161f7db","cve_id":"CVE-2010-5332","original_address":"https://github.com/torvalds/linux/commit/0926f91083f34d047abc74f1ca4fa6a9c161f7db","time":"2019-07-27T22:15Z"},
	{"Unnamed: 0":4091,"cwe_id":"CWE-200","source":"CWE-200 static int sched_read_attr ( struct sched_attr __user * uattr , struct sched_attr * attr , unsigned int usize ) { int ret ; if ( ! access_ok ( VERIFY_WRITE , uattr , usize ) ) return - EFAULT ; if ( usize < sizeof ( * attr ) ) { unsigned char * addr ; unsigned char * end ; addr = ( void * ) attr + usize ; end = ( void * ) attr + sizeof ( * attr ) ; for ( ; addr < end ; addr ++ ) { if ( * addr ) goto err_size ; } attr -> size = usize ; } <S2SV_StartBug> ret = copy_to_user ( uattr , attr , usize ) ; <S2SV_EndBug> if ( ret ) return - EFAULT ; out : return ret ; err_size : ret = - E2BIG ; goto out ; }\n","target":"<S2SV_ModStart> , attr , attr -> size <S2SV_ModEnd> ) ; if\n","project_and_commit_id":"torvalds@linux/4efbc454ba68def5ef285b26ebfcfdb605b52755","cve_id":"CVE-2014-9903","original_address":"https://github.com/torvalds/linux/commit/4efbc454ba68def5ef285b26ebfcfdb605b52755","time":"2016-06-27T10:59Z"},
	{"Unnamed: 0":1901,"cwe_id":"CWE-119","source":"CWE-119 static Image * ReadHDRImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { char format [ MaxTextExtent ] , keyword [ MaxTextExtent ] , tag [ MaxTextExtent ] , value [ MaxTextExtent ] ; double gamma ; Image * image ; int c ; MagickBooleanType status , value_expected ; register PixelPacket * q ; register unsigned char * p ; register ssize_t i , x ; ssize_t count , y ; unsigned char * end , pixel [ 4 ] , * pixels ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickSignature ) ; if ( image_info -> debug != MagickFalse ) ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , \"%s\" , image_info -> filename ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickSignature ) ; image = AcquireImage ( image_info ) ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } image -> columns = 0 ; image -> rows = 0 ; * format = '\\\\0' ; c = ReadBlobByte ( image ) ; if ( c == EOF ) { image = DestroyImage ( image ) ; return ( ( Image * ) NULL ) ; } while ( isgraph ( c ) && ( image -> columns == 0 ) && ( image -> rows == 0 ) ) { if ( c == ( int ) '#' ) { char * comment ; register char * p ; size_t length ; length = MaxTextExtent ; comment = AcquireString ( ( char * ) NULL ) ; for ( p = comment ; comment != ( char * ) NULL ; p ++ ) { c = ReadBlobByte ( image ) ; if ( ( c == EOF ) || ( c == ( int ) '\\\\n' ) ) break ; if ( ( size_t ) ( p - comment + 1 ) >= length ) { * p = '\\\\0' ; length <<= 1 ; comment = ( char * ) ResizeQuantumMemory ( comment , length + MaxTextExtent , sizeof ( * comment ) ) ; if ( comment == ( char * ) NULL ) break ; p = comment + strlen ( comment ) ; } * p = ( char ) c ; } if ( comment == ( char * ) NULL ) ThrowReaderException ( ResourceLimitError , \"MemoryAllocationFailed\" ) ; * p = '\\\\0' ; ( void ) SetImageProperty ( image , \"comment\" , comment ) ; comment = DestroyString ( comment ) ; c = ReadBlobByte ( image ) ; } else if ( isalnum ( c ) == MagickFalse ) c = ReadBlobByte ( image ) ; else { register char * p ; p = keyword ; do { if ( ( size_t ) ( p - keyword ) < ( MaxTextExtent - 1 ) ) * p ++ = c ; c = ReadBlobByte ( image ) ; } while ( isalnum ( c ) || ( c == '_' ) ) ; * p = '\\\\0' ; value_expected = MagickFalse ; while ( ( isspace ( ( int ) ( ( unsigned char ) c ) ) != 0 ) || ( c == '=' ) ) { if ( c == '=' ) value_expected = MagickTrue ; c = ReadBlobByte ( image ) ; } if ( LocaleCompare ( keyword , \"Y\" ) == 0 ) value_expected = MagickTrue ; if ( value_expected == MagickFalse ) continue ; p = value ; while ( ( c != '\\\\n' ) && ( c != '\\\\0' ) ) { if ( ( size_t ) ( p - value ) < ( MaxTextExtent - 1 ) ) * p ++ = c ; c = ReadBlobByte ( image ) ; } * p = '\\\\0' ; switch ( * keyword ) { case 'F' : case 'f' : { if ( LocaleCompare ( keyword , \"format\" ) == 0 ) { ( void ) CopyMagickString ( format , value , MaxTextExtent ) ; break ; } ( void ) FormatLocaleString ( tag , MaxTextExtent , \"hdr:%s\" , keyword ) ; ( void ) SetImageProperty ( image , tag , value ) ; break ; } case 'G' : case 'g' : { if ( LocaleCompare ( keyword , \"gamma\" ) == 0 ) { image -> gamma = StringToDouble ( value , ( char * * ) NULL ) ; break ; } ( void ) FormatLocaleString ( tag , MaxTextExtent , \"hdr:%s\" , keyword ) ; ( void ) SetImageProperty ( image , tag , value ) ; break ; } case 'P' : case 'p' : { if ( LocaleCompare ( keyword , \"primaries\" ) == 0 ) { float chromaticity [ 6 ] , white_point [ 2 ] ; ( void ) sscanf ( value , \"%g<S2SV_blank>%g<S2SV_blank>%g<S2SV_blank>%g<S2SV_blank>%g<S2SV_blank>%g<S2SV_blank>%g<S2SV_blank>%g\" , & chromaticity [ 0 ] , & chromaticity [ 1 ] , & chromaticity [ 2 ] , & chromaticity [ 3 ] , & chromaticity [ 4 ] , & chromaticity [ 5 ] , & white_point [ 0 ] , & white_point [ 1 ] ) ; image -> chromaticity . red_primary . x = chromaticity [ 0 ] ; image -> chromaticity . red_primary . y = chromaticity [ 1 ] ; image -> chromaticity . green_primary . x = chromaticity [ 2 ] ; image -> chromaticity . green_primary . y = chromaticity [ 3 ] ; image -> chromaticity . blue_primary . x = chromaticity [ 4 ] ; image -> chromaticity . blue_primary . y = chromaticity [ 5 ] ; image -> chromaticity . white_point . x = white_point [ 0 ] , image -> chromaticity . white_point . y = white_point [ 1 ] ; break ; } ( void ) FormatLocaleString ( tag , MaxTextExtent , \"hdr:%s\" , keyword ) ; ( void ) SetImageProperty ( image , tag , value ) ; break ; } case 'Y' : case 'y' : { if ( strcmp ( keyword , \"Y\" ) == 0 ) { int height , width ; ( void ) sscanf ( value , \"%d<S2SV_blank>+X<S2SV_blank>%d\" , & height , & width ) ; image -> columns = ( size_t ) width ; image -> rows = ( size_t ) height ; break ; } ( void ) FormatLocaleString ( tag , MaxTextExtent , \"hdr:%s\" , keyword ) ; ( void ) SetImageProperty ( image , tag , value ) ; break ; } default : { ( void ) FormatLocaleString ( tag , MaxTextExtent , \"hdr:%s\" , keyword ) ; ( void ) SetImageProperty ( image , tag , value ) ; break ; } } } if ( ( image -> columns == 0 ) && ( image -> rows == 0 ) ) while ( isspace ( ( int ) ( ( unsigned char ) c ) ) != 0 ) c = ReadBlobByte ( image ) ; } if ( ( LocaleCompare ( format , \"32-bit_rle_rgbe\" ) != 0 ) && ( LocaleCompare ( format , \"32-bit_rle_xyze\" ) != 0 ) ) ThrowReaderException ( CorruptImageError , \"ImproperImageHeader\" ) ; if ( ( image -> columns == 0 ) || ( image -> rows == 0 ) ) ThrowReaderException ( CorruptImageError , \"NegativeOrZeroImageSize\" ) ; ( void ) SetImageColorspace ( image , RGBColorspace ) ; if ( LocaleCompare ( format , \"32-bit_rle_xyze\" ) == 0 ) ( void ) SetImageColorspace ( image , XYZColorspace ) ; image -> compression = ( image -> columns < 8 ) || ( image -> columns > 0x7ffff ) ? NoCompression : RLECompression ; if ( image_info -> ping != MagickFalse ) { ( void ) CloseBlob ( image ) ; return ( GetFirstImageInList ( image ) ) ; } <S2SV_StartBug> pixels = ( unsigned char * ) AcquireQuantumMemory ( image -> columns , 4 * <S2SV_EndBug> sizeof ( * pixels ) ) ; if ( pixels == ( unsigned char * ) NULL ) ThrowReaderException ( ResourceLimitError , \"MemoryAllocationFailed\" ) ; for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { if ( image -> compression != RLECompression ) { count = ReadBlob ( image , 4 * image -> columns * sizeof ( * pixels ) , pixels ) ; if ( count != ( ssize_t ) ( 4 * image -> columns * sizeof ( * pixels ) ) ) break ; } else { count = ReadBlob ( image , 4 * sizeof ( * pixel ) , pixel ) ; if ( count != 4 ) break ; if ( ( size_t ) ( ( ( ( size_t ) pixel [ 2 ] ) << 8 ) | pixel [ 3 ] ) != image -> columns ) { ( void ) memcpy ( pixels , pixel , 4 * sizeof ( * pixel ) ) ; count = ReadBlob ( image , 4 * ( image -> columns - 1 ) * sizeof ( * pixels ) , pixels + 4 ) ; image -> compression = NoCompression ; } else { p = pixels ; for ( i = 0 ; i < 4 ; i ++ ) { end = & pixels [ ( i + 1 ) * image -> columns ] ; while ( p < end ) { count = ReadBlob ( image , 2 * sizeof ( * pixel ) , pixel ) ; if ( count < 1 ) break ; if ( pixel [ 0 ] > 128 ) { count = ( ssize_t ) pixel [ 0 ] - 128 ; if ( ( count == 0 ) || ( count > ( ssize_t ) ( end - p ) ) ) break ; while ( count -- > 0 ) * p ++ = pixel [ 1 ] ; } else { count = ( ssize_t ) pixel [ 0 ] ; if ( ( count == 0 ) || ( count > ( ssize_t ) ( end - p ) ) ) break ; * p ++ = pixel [ 1 ] ; if ( -- count > 0 ) { count = ReadBlob ( image , ( size_t ) count * sizeof ( * p ) , p ) ; if ( count < 1 ) break ; p += count ; } } } } } } q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( PixelPacket * ) NULL ) break ; i = 0 ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { if ( image -> compression == RLECompression ) { pixel [ 0 ] = pixels [ x ] ; pixel [ 1 ] = pixels [ x + image -> columns ] ; pixel [ 2 ] = pixels [ x + 2 * image -> columns ] ; pixel [ 3 ] = pixels [ x + 3 * image -> columns ] ; } else { pixel [ 0 ] = pixels [ i ++ ] ; pixel [ 1 ] = pixels [ i ++ ] ; pixel [ 2 ] = pixels [ i ++ ] ; pixel [ 3 ] = pixels [ i ++ ] ; } SetPixelRed ( q , 0 ) ; SetPixelGreen ( q , 0 ) ; SetPixelBlue ( q , 0 ) ; if ( pixel [ 3 ] != 0 ) { gamma = pow ( 2.0 , pixel [ 3 ] - ( 128.0 + 8.0 ) ) ; SetPixelRed ( q , ClampToQuantum ( QuantumRange * gamma * pixel [ 0 ] ) ) ; SetPixelGreen ( q , ClampToQuantum ( QuantumRange * gamma * pixel [ 1 ] ) ) ; SetPixelBlue ( q , ClampToQuantum ( QuantumRange * gamma * pixel [ 2 ] ) ) ; } q ++ ; } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ; if ( status == MagickFalse ) break ; } pixels = ( unsigned char * ) RelinquishMagickMemory ( pixels ) ; if ( EOFBlob ( image ) != MagickFalse ) ThrowFileException ( exception , CorruptImageError , \"UnexpectedEndOfFile\" , image -> filename ) ; ( void ) CloseBlob ( image ) ; return ( GetFirstImageInList ( image ) ) ; }\n","target":"<S2SV_ModStart> ) ; } status = SetImageExtent ( image , image -> columns , image -> rows ) ; if ( status == MagickFalse ) { InheritException ( exception , & image -> exception ) ; return ( DestroyImageList ( image ) ) ; }\n","project_and_commit_id":"ImageMagick@ImageMagick/f6e9d0d9955e85bdd7540b251cd50d598dacc5e6","cve_id":"CVE-2016-10066","original_address":"https://github.com/ImageMagick/ImageMagick/commit/f6e9d0d9955e85bdd7540b251cd50d598dacc5e6","time":"2017-03-03T17:59Z"},
	{"Unnamed: 0":116,"cwe_id":"CWE-20","source":"CWE-20 <S2SV_StartBug> error_t mqttSnClientDisconnect ( MqttSnClientContext * context ) <S2SV_EndBug> { error_t error ; systime_t time ; if ( context == NULL ) return ERROR_INVALID_PARAMETER ; error = NO_ERROR ; while ( ! error ) { time = osGetSystemTime ( ) ; if ( context -> state == MQTT_SN_CLIENT_STATE_ACTIVE ) { context -> startTime = time ; <S2SV_StartBug> error = mqttSnClientSendDisconnect ( context , 0 ) ; <S2SV_EndBug> } else if ( context -> state == MQTT_SN_CLIENT_STATE_SENDING_REQ ) { if ( timeCompare ( time , context -> startTime + context -> timeout ) >= 0 ) { mqttSnClientShutdownConnection ( context ) ; error = ERROR_TIMEOUT ; } else if ( timeCompare ( time , context -> retransmitStartTime + MQTT_SN_CLIENT_RETRY_TIMEOUT ) >= 0 ) { <S2SV_StartBug> error = mqttSnClientSendDisconnect ( context , 0 ) ; <S2SV_EndBug> } else { error = mqttSnClientProcessEvents ( context , MQTT_SN_CLIENT_TICK_INTERVAL ) ; } } else if ( context -> state == MQTT_SN_CLIENT_STATE_DISCONNECTING ) { error = mqttSnClientShutdownConnection ( context ) ; mqttSnClientCloseConnection ( context ) ; context -> state = MQTT_SN_CLIENT_STATE_DISCONNECTED ; } else if ( context -> state == MQTT_SN_CLIENT_STATE_DISCONNECTED ) { break ; } else { error = ERROR_WRONG_STATE ; } } if ( error != NO_ERROR && error != ERROR_WOULD_BLOCK ) { mqttSnClientCloseConnection ( context ) ; context -> state = MQTT_SN_CLIENT_STATE_DISCONNECTED ; } return error ; }\n","target":"<S2SV_ModStart> MqttSnClientContext * context , systime_t duration <S2SV_ModStart> ( context , duration / 1000 <S2SV_ModEnd> ) ; } <S2SV_ModStart> ( context , duration / 1000 <S2SV_ModEnd> ) ; }\n","project_and_commit_id":"Oryx-Embedded@CycloneTCP/de5336016edbe1e90327d0ed1cba5c4e49114366","cve_id":"CVE-2021-26788","original_address":"https://github.com/Oryx-Embedded/CycloneTCP/commit/de5336016edbe1e90327d0ed1cba5c4e49114366","time":"2021-03-08T13:15Z"},
	{"Unnamed: 0":6092,"cwe_id":"CWE-119","source":"CWE-119 <S2SV_StartBug> static void encode_segmentation ( VP9_COMP * cpi , <S2SV_EndBug> struct vp9_write_bit_buffer * wb ) { int i , j ; <S2SV_StartBug> struct segmentation * seg = & cpi -> common . seg ; <S2SV_EndBug> vp9_wb_write_bit ( wb , seg -> enabled ) ; if ( ! seg -> enabled ) return ; <S2SV_StartBug> vp9_wb_write_bit ( wb , seg -> update_map ) ; <S2SV_EndBug> if ( seg -> update_map ) { <S2SV_StartBug> vp9_choose_segmap_coding_method ( cpi ) ; <S2SV_EndBug> for ( i = 0 ; i < SEG_TREE_PROBS ; i ++ ) { const int prob = seg -> tree_probs [ i ] ; const int update = prob != MAX_PROB ; <S2SV_StartBug> vp9_wb_write_bit ( wb , update ) ; <S2SV_EndBug> if ( update ) vp9_wb_write_literal ( wb , prob , 8 ) ; } <S2SV_StartBug> vp9_wb_write_bit ( wb , seg -> temporal_update ) ; <S2SV_EndBug> if ( seg -> temporal_update ) { for ( i = 0 ; i < PREDICTION_PROBS ; i ++ ) { const int prob = seg -> pred_probs [ i ] ; const int update = prob != MAX_PROB ; <S2SV_StartBug> vp9_wb_write_bit ( wb , update ) ; <S2SV_EndBug> if ( update ) vp9_wb_write_literal ( wb , prob , 8 ) ; } } } <S2SV_StartBug> vp9_wb_write_bit ( wb , seg -> update_data ) ; <S2SV_EndBug> if ( seg -> update_data ) { <S2SV_StartBug> vp9_wb_write_bit ( wb , seg -> abs_delta ) ; <S2SV_EndBug> for ( i = 0 ; i < MAX_SEGMENTS ; i ++ ) { for ( j = 0 ; j < SEG_LVL_MAX ; j ++ ) { <S2SV_StartBug> const int active = vp9_segfeature_active ( seg , i , j ) ; <S2SV_EndBug> vp9_wb_write_bit ( wb , active ) ; if ( active ) { <S2SV_StartBug> const int data = vp9_get_segdata ( seg , i , j ) ; <S2SV_EndBug> const int data_max = vp9_seg_feature_data_max ( j ) ; if ( vp9_is_segfeature_signed ( j ) ) { encode_unsigned_max ( wb , abs ( data ) , data_max ) ; <S2SV_StartBug> vp9_wb_write_bit ( wb , data < 0 ) ; <S2SV_EndBug> } else { encode_unsigned_max ( wb , data , data_max ) ; } } } } } }\n","target":"<S2SV_ModStart> void encode_segmentation ( VP9_COMMON * cm , MACROBLOCKD * xd , struct vpx_write_bit_buffer <S2SV_ModEnd> * wb ) <S2SV_ModStart> , j ; const <S2SV_ModStart> seg = & cm -> seg ; vpx_wb_write_bit <S2SV_ModEnd> ( wb , <S2SV_ModStart> ) return ; vpx_wb_write_bit <S2SV_ModEnd> ( wb , <S2SV_ModStart> { vp9_choose_segmap_coding_method ( cm , xd <S2SV_ModEnd> ) ; for <S2SV_ModStart> != MAX_PROB ; vpx_wb_write_bit ( wb , update ) ; if ( update ) vpx_wb_write_literal <S2SV_ModEnd> ( wb , <S2SV_ModStart> ) ; } vpx_wb_write_bit <S2SV_ModEnd> ( wb , <S2SV_ModStart> != MAX_PROB ; vpx_wb_write_bit ( wb , update ) ; if ( update ) vpx_wb_write_literal <S2SV_ModEnd> ( wb , <S2SV_ModStart> } } } vpx_wb_write_bit <S2SV_ModEnd> ( wb , <S2SV_ModStart> update_data ) { vpx_wb_write_bit <S2SV_ModEnd> ( wb , <S2SV_ModStart> int active = segfeature_active ( seg , i , j ) ; vpx_wb_write_bit <S2SV_ModEnd> ( wb , <S2SV_ModStart> int data = get_segdata <S2SV_ModEnd> ( seg , <S2SV_ModStart> data_max ) ; vpx_wb_write_bit <S2SV_ModEnd> ( wb ,\n","project_and_commit_id":"external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426","cve_id":"CVE-2016-1621","original_address":"https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426","time":"2016-03-12T21:59Z"},
	{"Unnamed: 0":2959,"cwe_id":"CWE-476","source":"CWE-476 jp2_box_t * jp2_box_get ( jas_stream_t * in ) { jp2_box_t * box ; jp2_boxinfo_t * boxinfo ; jas_stream_t * tmpstream ; uint_fast32_t len ; uint_fast64_t extlen ; bool dataflag ; box = 0 ; tmpstream = 0 ; if ( ! ( box = jas_malloc ( sizeof ( jp2_box_t ) ) ) ) { goto error ; } box -> ops = & jp2_boxinfo_unk . ops ; if ( jp2_getuint32 ( in , & len ) || jp2_getuint32 ( in , & box -> type ) ) { goto error ; } boxinfo = jp2_boxinfolookup ( box -> type ) ; <S2SV_StartBug> box -> info = boxinfo ; <S2SV_EndBug> box -> ops = & boxinfo -> ops ; box -> len = len ; JAS_DBGLOG ( 10 , ( \"preliminary<S2SV_blank>processing<S2SV_blank>of<S2SV_blank>JP2<S2SV_blank>box:<S2SV_blank>type=%c%s%c<S2SV_blank>(0x%08x);<S2SV_blank>length=%d\\\\n\" , \\'\"\\' , boxinfo -> name , \\'\"\\' , box -> type , box -> len ) ) ; if ( box -> len == 1 ) { if ( jp2_getuint64 ( in , & extlen ) ) { goto error ; } if ( extlen > 0xffffffffUL ) { jas_eprintf ( \"warning:<S2SV_blank>cannot<S2SV_blank>handle<S2SV_blank>large<S2SV_blank>64-bit<S2SV_blank>box<S2SV_blank>length\\\\n\" ) ; extlen = 0xffffffffUL ; } box -> len = extlen ; box -> datalen = extlen - JP2_BOX_HDRLEN ( true ) ; } else { box -> datalen = box -> len - JP2_BOX_HDRLEN ( false ) ; } if ( box -> len != 0 && box -> len < 8 ) { goto error ; } dataflag = ! ( box -> info -> flags & ( JP2_BOX_SUPER | JP2_BOX_NODATA ) ) ; if ( dataflag ) { if ( ! ( tmpstream = jas_stream_memopen ( 0 , 0 ) ) ) { goto error ; } if ( jas_stream_copy ( tmpstream , in , box -> datalen ) ) { <S2SV_StartBug> box -> ops = & jp2_boxinfo_unk . ops ; <S2SV_EndBug> jas_eprintf ( \"cannot<S2SV_blank>copy<S2SV_blank>box<S2SV_blank>data\\\\n\" ) ; goto error ; } <S2SV_StartBug> jas_stream_rewind ( tmpstream ) ; <S2SV_EndBug> if ( box -> ops -> getdata ) { if ( ( * box -> ops -> getdata ) ( box , tmpstream ) ) { jas_eprintf ( \"cannot<S2SV_blank>parse<S2SV_blank>box<S2SV_blank>data\\\\n\" ) ; goto error ; } } jas_stream_close ( tmpstream ) ; } if ( jas_getdbglevel ( ) >= 1 ) { jp2_box_dump ( box , stderr ) ; } return box ; error : if ( box ) { jp2_box_destroy ( box ) ; } if ( tmpstream ) { jas_stream_close ( tmpstream ) ; } return 0 ; }\n","target":"<S2SV_ModStart> info = boxinfo <S2SV_ModEnd> ; box -> <S2SV_ModStart> ) ) { <S2SV_ModEnd> jas_eprintf ( \"cannot<S2SV_blank>copy<S2SV_blank>box<S2SV_blank>data\\\\n\" <S2SV_ModStart> ( tmpstream ) ; box -> ops = & boxinfo -> ops\n","project_and_commit_id":"mdadams@jasper/bdfe95a6e81ffb4b2fad31a76b57943695beed20","cve_id":"CVE-2016-10250","original_address":"https://github.com/mdadams/jasper/commit/bdfe95a6e81ffb4b2fad31a76b57943695beed20","time":"2017-03-15T14:59Z"},
	{"Unnamed: 0":3194,"cwe_id":"CWE-401","source":"CWE-401 static Image * ReadPSImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { # define BoundingBox \"BoundingBox:\" # define BeginDocument \"BeginDocument:\" # define BeginXMPPacket \"<?xpacket<S2SV_blank>begin=\" # define EndXMPPacket \"<?xpacket<S2SV_blank>end=\" # define ICCProfile \"BeginICCProfile:\" # define CMYKCustomColor \"CMYKCustomColor:\" # define CMYKProcessColor \"CMYKProcessColor:\" # define DocumentMedia \"DocumentMedia:\" # define DocumentCustomColors \"DocumentCustomColors:\" # define DocumentProcessColors \"DocumentProcessColors:\" # define EndDocument \"EndDocument:\" # define HiResBoundingBox \"HiResBoundingBox:\" # define ImageData \"ImageData:\" # define PageBoundingBox \"PageBoundingBox:\" # define LanguageLevel \"LanguageLevel:\" # define PageMedia \"PageMedia:\" # define Pages \"Pages:\" # define PhotoshopProfile \"BeginPhotoshop:\" # define PostscriptLevel \"!PS-\" # define RenderPostscriptText \"<S2SV_blank><S2SV_blank>Rendering<S2SV_blank>Postscript...<S2SV_blank><S2SV_blank>\" # define SpotColor \"+<S2SV_blank>\" char command [ MaxTextExtent ] , * density , filename [ MaxTextExtent ] , geometry [ MaxTextExtent ] , input_filename [ MaxTextExtent ] , message [ MaxTextExtent ] , * options , postscript_filename [ MaxTextExtent ] ; const char * option ; const DelegateInfo * delegate_info ; GeometryInfo geometry_info ; Image * image , * next , * postscript_image ; ImageInfo * read_info ; int c , file ; MagickBooleanType cmyk , fitPage , skip , status ; MagickStatusType flags ; PointInfo delta , resolution ; RectangleInfo page ; register char * p ; register ssize_t i ; SegmentInfo bounds , hires_bounds ; short int hex_digits [ 256 ] ; size_t length , priority ; ssize_t count ; StringInfo * profile ; unsigned long columns , extent , language_level , pages , rows , scene , spotcolor ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickCoreSignature ) ; if ( image_info -> debug != MagickFalse ) ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , \"%s\" , image_info -> filename ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickCoreSignature ) ; image = AcquireImage ( image_info ) ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } status = AcquireUniqueSymbolicLink ( image_info -> filename , input_filename ) ; if ( status == MagickFalse ) { ThrowFileException ( exception , FileOpenError , \"UnableToCreateTemporaryFile\" , image_info -> filename ) ; image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } ( void ) memset ( hex_digits , 0 , sizeof ( hex_digits ) ) ; hex_digits [ ( int ) '0' ] = 0 ; hex_digits [ ( int ) '1' ] = 1 ; hex_digits [ ( int ) '2' ] = 2 ; hex_digits [ ( int ) '3' ] = 3 ; hex_digits [ ( int ) '4' ] = 4 ; hex_digits [ ( int ) '5' ] = 5 ; hex_digits [ ( int ) '6' ] = 6 ; hex_digits [ ( int ) '7' ] = 7 ; hex_digits [ ( int ) '8' ] = 8 ; hex_digits [ ( int ) '9' ] = 9 ; hex_digits [ ( int ) 'a' ] = 10 ; hex_digits [ ( int ) 'b' ] = 11 ; hex_digits [ ( int ) 'c' ] = 12 ; hex_digits [ ( int ) 'd' ] = 13 ; hex_digits [ ( int ) 'e' ] = 14 ; hex_digits [ ( int ) 'f' ] = 15 ; hex_digits [ ( int ) 'A' ] = 10 ; hex_digits [ ( int ) 'B' ] = 11 ; hex_digits [ ( int ) 'C' ] = 12 ; hex_digits [ ( int ) 'D' ] = 13 ; hex_digits [ ( int ) 'E' ] = 14 ; hex_digits [ ( int ) 'F' ] = 15 ; delta . x = DefaultResolution ; delta . y = DefaultResolution ; if ( ( image -> x_resolution == 0.0 ) || ( image -> y_resolution == 0.0 ) ) { flags = ParseGeometry ( PSDensityGeometry , & geometry_info ) ; image -> x_resolution = geometry_info . rho ; image -> y_resolution = geometry_info . sigma ; if ( ( flags & SigmaValue ) == 0 ) image -> y_resolution = image -> x_resolution ; } if ( image_info -> density != ( char * ) NULL ) { flags = ParseGeometry ( image_info -> density , & geometry_info ) ; image -> x_resolution = geometry_info . rho ; image -> y_resolution = geometry_info . sigma ; if ( ( flags & SigmaValue ) == 0 ) image -> y_resolution = image -> x_resolution ; } ( void ) ParseAbsoluteGeometry ( PSPageGeometry , & page ) ; if ( image_info -> page != ( char * ) NULL ) ( void ) ParseAbsoluteGeometry ( image_info -> page , & page ) ; resolution . x = image -> x_resolution ; resolution . y = image -> y_resolution ; page . width = ( size_t ) ceil ( ( double ) ( page . width * resolution . x / delta . x ) - 0.5 ) ; page . height = ( size_t ) ceil ( ( double ) ( page . height * resolution . y / delta . y ) - 0.5 ) ; ( void ) memset ( & bounds , 0 , sizeof ( bounds ) ) ; ( void ) memset ( command , 0 , sizeof ( command ) ) ; cmyk = image_info -> colorspace == CMYKColorspace ? MagickTrue : MagickFalse ; ( void ) memset ( & hires_bounds , 0 , sizeof ( hires_bounds ) ) ; priority = 0 ; columns = 0 ; rows = 0 ; extent = 0 ; spotcolor = 0 ; language_level = 1 ; skip = MagickFalse ; pages = ( ~ 0UL ) ; p = command ; for ( c = ReadBlobByte ( image ) ; c != EOF ; c = ReadBlobByte ( image ) ) { * p ++ = ( char ) c ; if ( ( strchr ( \"\\\\n\\\\r%\" , c ) == ( char * ) NULL ) && ( ( size_t ) ( p - command ) < ( MaxTextExtent - 1 ) ) ) continue ; * p = '\\\\0' ; p = command ; if ( LocaleNCompare ( BeginDocument , command , strlen ( BeginDocument ) ) == 0 ) skip = MagickTrue ; if ( LocaleNCompare ( EndDocument , command , strlen ( EndDocument ) ) == 0 ) skip = MagickFalse ; if ( skip != MagickFalse ) continue ; if ( LocaleNCompare ( PostscriptLevel , command , strlen ( PostscriptLevel ) ) == 0 ) { ( void ) SetImageProperty ( image , \"ps:Level\" , command + 4 ) ; if ( GlobExpression ( command , \"*EPSF-*\" , MagickTrue ) != MagickFalse ) pages = 1 ; } if ( LocaleNCompare ( LanguageLevel , command , strlen ( LanguageLevel ) ) == 0 ) ( void ) sscanf ( command , LanguageLevel \"<S2SV_blank>%lu\" , & language_level ) ; if ( LocaleNCompare ( Pages , command , strlen ( Pages ) ) == 0 ) ( void ) sscanf ( command , Pages \"<S2SV_blank>%lu\" , & pages ) ; if ( LocaleNCompare ( ImageData , command , strlen ( ImageData ) ) == 0 ) ( void ) sscanf ( command , ImageData \"<S2SV_blank>%lu<S2SV_blank>%lu\" , & columns , & rows ) ; length = strlen ( DocumentProcessColors ) ; if ( LocaleNCompare ( DocumentProcessColors , command , length ) == 0 ) { if ( ( GlobExpression ( command , \"*Cyan*\" , MagickTrue ) != MagickFalse ) || ( GlobExpression ( command , \"*Magenta*\" , MagickTrue ) != MagickFalse ) || ( GlobExpression ( command , \"*Yellow*\" , MagickTrue ) != MagickFalse ) ) cmyk = MagickTrue ; } if ( LocaleNCompare ( CMYKCustomColor , command , strlen ( CMYKCustomColor ) ) == 0 ) cmyk = MagickTrue ; if ( LocaleNCompare ( CMYKProcessColor , command , strlen ( CMYKProcessColor ) ) == 0 ) cmyk = MagickTrue ; length = strlen ( DocumentCustomColors ) ; if ( ( LocaleNCompare ( DocumentCustomColors , command , length ) == 0 ) || ( LocaleNCompare ( CMYKCustomColor , command , strlen ( CMYKCustomColor ) ) == 0 ) || ( LocaleNCompare ( SpotColor , command , strlen ( SpotColor ) ) == 0 ) ) { char property [ MaxTextExtent ] , * value ; register char * p ; ( void ) FormatLocaleString ( property , MaxTextExtent , \"ps:SpotColor-%.20g\" , ( double ) ( spotcolor ++ ) ) ; for ( p = command ; * p != '\\\\0' ; p ++ ) if ( isspace ( ( int ) ( unsigned char ) * p ) != 0 ) break ; value = ConstantString ( p ) ; ( void ) SubstituteString ( & value , \"(\" , \"\" ) ; ( void ) SubstituteString ( & value , \")\" , \"\" ) ; ( void ) StripString ( value ) ; if ( * value != '\\\\0' ) ( void ) SetImageProperty ( image , property , value ) ; value = DestroyString ( value ) ; continue ; } if ( image_info -> page != ( char * ) NULL ) continue ; count = 0 ; i = 0 ; if ( LocaleNCompare ( BoundingBox , command , strlen ( BoundingBox ) ) == 0 ) { count = ( ssize_t ) sscanf ( command , BoundingBox \"<S2SV_blank>%lf<S2SV_blank>%lf<S2SV_blank>%lf<S2SV_blank>%lf\" , & bounds . x1 , & bounds . y1 , & bounds . x2 , & bounds . y2 ) ; i = 2 ; } if ( LocaleNCompare ( DocumentMedia , command , strlen ( DocumentMedia ) ) == 0 ) { count = ( ssize_t ) sscanf ( command , DocumentMedia \"<S2SV_blank>%lf<S2SV_blank>%lf<S2SV_blank>%lf<S2SV_blank>%lf\" , & bounds . x1 , & bounds . y1 , & bounds . x2 , & bounds . y2 ) ; i = 1 ; } if ( LocaleNCompare ( HiResBoundingBox , command , strlen ( HiResBoundingBox ) ) == 0 ) { count = ( ssize_t ) sscanf ( command , HiResBoundingBox \"<S2SV_blank>%lf<S2SV_blank>%lf<S2SV_blank>%lf<S2SV_blank>%lf\" , & bounds . x1 , & bounds . y1 , & bounds . x2 , & bounds . y2 ) ; i = 3 ; } if ( LocaleNCompare ( PageBoundingBox , command , strlen ( PageBoundingBox ) ) == 0 ) { count = ( ssize_t ) sscanf ( command , PageBoundingBox \"<S2SV_blank>%lf<S2SV_blank>%lf<S2SV_blank>%lf<S2SV_blank>%lf\" , & bounds . x1 , & bounds . y1 , & bounds . x2 , & bounds . y2 ) ; i = 1 ; } if ( LocaleNCompare ( PageMedia , command , strlen ( PageMedia ) ) == 0 ) { count = ( ssize_t ) sscanf ( command , PageMedia \"<S2SV_blank>%lf<S2SV_blank>%lf<S2SV_blank>%lf<S2SV_blank>%lf\" , & bounds . x1 , & bounds . y1 , & bounds . x2 , & bounds . y2 ) ; i = 1 ; } if ( ( count != 4 ) || ( i < ( ssize_t ) priority ) ) continue ; if ( ( fabs ( bounds . x2 - bounds . x1 ) <= fabs ( hires_bounds . x2 - hires_bounds . x1 ) ) || ( fabs ( bounds . y2 - bounds . y1 ) <= fabs ( hires_bounds . y2 - hires_bounds . y1 ) ) ) if ( i == ( ssize_t ) priority ) continue ; hires_bounds = bounds ; priority = ( size_t ) i ; } if ( ( fabs ( hires_bounds . x2 - hires_bounds . x1 ) >= MagickEpsilon ) && ( fabs ( hires_bounds . y2 - hires_bounds . y1 ) >= MagickEpsilon ) ) { ( void ) FormatLocaleString ( geometry , MaxTextExtent , \"%gx%g%+.15g%+.15g\" , hires_bounds . x2 - hires_bounds . x1 , hires_bounds . y2 - hires_bounds . y1 , hires_bounds . x1 , hires_bounds . y1 ) ; ( void ) SetImageProperty ( image , \"ps:HiResBoundingBox\" , geometry ) ; page . width = ( size_t ) ceil ( ( double ) ( ( hires_bounds . x2 - hires_bounds . x1 ) * resolution . x / delta . x ) - 0.5 ) ; page . height = ( size_t ) ceil ( ( double ) ( ( hires_bounds . y2 - hires_bounds . y1 ) * resolution . y / delta . y ) - 0.5 ) ; } fitPage = MagickFalse ; option = GetImageOption ( image_info , \"eps:fit-page\" ) ; if ( option != ( char * ) NULL ) { char * geometry ; MagickStatusType flags ; geometry = GetPageGeometry ( option ) ; flags = ParseMetaGeometry ( geometry , & page . x , & page . y , & page . width , & page . height ) ; if ( flags == NoValue ) { ( void ) ThrowMagickException ( exception , GetMagickModule ( ) , OptionError , <S2SV_StartBug> \"InvalidGeometry\" , \"`%s\\'\" , option ) ; <S2SV_EndBug> image = DestroyImage ( image ) ; return ( ( Image * ) NULL ) ; } page . width = ( size_t ) ceil ( ( double ) ( page . width * image -> x_resolution / delta . x ) - 0.5 ) ; page . height = ( size_t ) ceil ( ( double ) ( page . height * image -> y_resolution / delta . y ) - 0.5 ) ; geometry = DestroyString ( geometry ) ; fitPage = MagickTrue ; } if ( IssRGBCompatibleColorspace ( image_info -> colorspace ) != MagickFalse ) cmyk = MagickFalse ; file = AcquireUniqueFileResource ( postscript_filename ) ; if ( file == - 1 ) { ThrowFileException ( & image -> exception , FileOpenError , \"UnableToOpenFile\" , image_info -> filename ) ; image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } ( void ) CopyMagickString ( command , \"/setpagedevice<S2SV_blank>{pop}<S2SV_blank>bind<S2SV_blank>1<S2SV_blank>index<S2SV_blank>where<S2SV_blank>{\" \"dup<S2SV_blank>wcheck<S2SV_blank>{3<S2SV_blank>1<S2SV_blank>roll<S2SV_blank>put}<S2SV_blank>{pop<S2SV_blank>def}<S2SV_blank>ifelse}<S2SV_blank>{def}<S2SV_blank>ifelse\\\\n\" \"<</UseCIEColor<S2SV_blank>true>>setpagedevice\\\\n\" , MaxTextExtent ) ; count = write ( file , command , ( unsigned int ) strlen ( command ) ) ; if ( image_info -> page == ( char * ) NULL ) { char translate_geometry [ MaxTextExtent ] ; ( void ) FormatLocaleString ( translate_geometry , MaxTextExtent , \"%g<S2SV_blank>%g<S2SV_blank>translate\\\\n\" , - hires_bounds . x1 , - hires_bounds . y1 ) ; count = write ( file , translate_geometry , ( unsigned int ) strlen ( translate_geometry ) ) ; } file = close ( file ) - 1 ; if ( image_info -> monochrome != MagickFalse ) delegate_info = GetDelegateInfo ( \"ps:mono\" , ( char * ) NULL , exception ) ; else if ( cmyk != MagickFalse ) delegate_info = GetDelegateInfo ( \"ps:cmyk\" , ( char * ) NULL , exception ) ; else delegate_info = GetDelegateInfo ( \"ps:alpha\" , ( char * ) NULL , exception ) ; if ( delegate_info == ( const DelegateInfo * ) NULL ) { ( void ) RelinquishUniqueFileResource ( postscript_filename ) ; image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } density = AcquireString ( \"\" ) ; options = AcquireString ( \"\" ) ; ( void ) FormatLocaleString ( density , MaxTextExtent , \"%gx%g\" , resolution . x , resolution . y ) ; ( void ) FormatLocaleString ( options , MaxTextExtent , \"-g%.20gx%.20g<S2SV_blank>\" , ( double ) page . width , ( double ) page . height ) ; read_info = CloneImageInfo ( image_info ) ; * read_info -> magick = '\\\\0' ; if ( read_info -> number_scenes != 0 ) { char pages [ MaxTextExtent ] ; ( void ) FormatLocaleString ( pages , MaxTextExtent , \"-dFirstPage=%.20g<S2SV_blank>\" \"-dLastPage=%.20g<S2SV_blank>\" , ( double ) read_info -> scene + 1 , ( double ) ( read_info -> scene + read_info -> number_scenes ) ) ; ( void ) ConcatenateMagickString ( options , pages , MaxTextExtent ) ; read_info -> number_scenes = 0 ; if ( read_info -> scenes != ( char * ) NULL ) * read_info -> scenes = '\\\\0' ; } if ( * image_info -> magick == 'E' ) { option = GetImageOption ( image_info , \"eps:use-cropbox\" ) ; if ( ( option == ( const char * ) NULL ) || ( IsStringTrue ( option ) != MagickFalse ) ) ( void ) ConcatenateMagickString ( options , \"-dEPSCrop<S2SV_blank>\" , MaxTextExtent ) ; if ( fitPage != MagickFalse ) ( void ) ConcatenateMagickString ( options , \"-dEPSFitPage<S2SV_blank>\" , MaxTextExtent ) ; } ( void ) CopyMagickString ( filename , read_info -> filename , MaxTextExtent ) ; ( void ) AcquireUniqueFilename ( filename ) ; ( void ) RelinquishUniqueFileResource ( filename ) ; ( void ) ConcatenateMagickString ( filename , \"%d\" , MaxTextExtent ) ; ( void ) FormatLocaleString ( command , MaxTextExtent , GetDelegateCommands ( delegate_info ) , read_info -> antialias != MagickFalse ? 4 : 1 , read_info -> antialias != MagickFalse ? 4 : 1 , density , options , filename , postscript_filename , input_filename ) ; options = DestroyString ( options ) ; density = DestroyString ( density ) ; * message = '\\\\0' ; status = InvokePostscriptDelegate ( read_info -> verbose , command , message , exception ) ; ( void ) InterpretImageFilename ( image_info , image , filename , 1 , read_info -> filename ) ; if ( ( status == MagickFalse ) || ( IsPostscriptRendered ( read_info -> filename ) == MagickFalse ) ) { ( void ) ConcatenateMagickString ( command , \"<S2SV_blank>-c<S2SV_blank>showpage\" , MaxTextExtent ) ; status = InvokePostscriptDelegate ( read_info -> verbose , command , message , exception ) ; } ( void ) RelinquishUniqueFileResource ( postscript_filename ) ; ( void ) RelinquishUniqueFileResource ( input_filename ) ; postscript_image = ( Image * ) NULL ; if ( status == MagickFalse ) for ( i = 1 ; ; i ++ ) { ( void ) InterpretImageFilename ( image_info , image , filename , ( int ) i , read_info -> filename ) ; if ( IsPostscriptRendered ( read_info -> filename ) == MagickFalse ) break ; ( void ) RelinquishUniqueFileResource ( read_info -> filename ) ; } else for ( i = 1 ; ; i ++ ) { ( void ) InterpretImageFilename ( image_info , image , filename , ( int ) i , read_info -> filename ) ; if ( IsPostscriptRendered ( read_info -> filename ) == MagickFalse ) break ; read_info -> blob = NULL ; read_info -> length = 0 ; next = ReadImage ( read_info , exception ) ; ( void ) RelinquishUniqueFileResource ( read_info -> filename ) ; if ( next == ( Image * ) NULL ) break ; AppendImageToList ( & postscript_image , next ) ; } ( void ) RelinquishUniqueFileResource ( read_info -> filename ) ; read_info = DestroyImageInfo ( read_info ) ; if ( postscript_image == ( Image * ) NULL ) { if ( * message != '\\\\0' ) ( void ) ThrowMagickException ( exception , GetMagickModule ( ) , DelegateError , \"PostscriptDelegateFailed\" , \"`%s\\'\" , message ) ; image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } if ( LocaleCompare ( postscript_image -> magick , \"BMP\" ) == 0 ) { Image * cmyk_image ; cmyk_image = ConsolidateCMYKImages ( postscript_image , exception ) ; if ( cmyk_image != ( Image * ) NULL ) { postscript_image = DestroyImageList ( postscript_image ) ; postscript_image = cmyk_image ; } } ( void ) SeekBlob ( image , 0 , SEEK_SET ) ; for ( c = ReadBlobByte ( image ) ; c != EOF ; c = ReadBlobByte ( image ) ) { * p ++ = ( char ) c ; if ( ( strchr ( \"\\\\n\\\\r%\" , c ) == ( char * ) NULL ) && ( ( size_t ) ( p - command ) < ( MaxTextExtent - 1 ) ) ) continue ; * p = '\\\\0' ; p = command ; if ( LocaleNCompare ( BeginDocument , command , strlen ( BeginDocument ) ) == 0 ) skip = MagickTrue ; if ( LocaleNCompare ( EndDocument , command , strlen ( EndDocument ) ) == 0 ) skip = MagickFalse ; if ( skip != MagickFalse ) continue ; if ( LocaleNCompare ( PostscriptLevel , command , strlen ( PostscriptLevel ) ) == 0 ) { ( void ) SetImageProperty ( image , \"ps:Level\" , command + 4 ) ; if ( GlobExpression ( command , \"*EPSF-*\" , MagickTrue ) != MagickFalse ) pages = 1 ; } if ( LocaleNCompare ( LanguageLevel , command , strlen ( LanguageLevel ) ) == 0 ) ( void ) sscanf ( command , LanguageLevel \"<S2SV_blank>%lu\" , & language_level ) ; if ( LocaleNCompare ( Pages , command , strlen ( Pages ) ) == 0 ) ( void ) sscanf ( command , Pages \"<S2SV_blank>%lu\" , & pages ) ; if ( LocaleNCompare ( ImageData , command , strlen ( ImageData ) ) == 0 ) ( void ) sscanf ( command , ImageData \"<S2SV_blank>%lu<S2SV_blank>%lu\" , & columns , & rows ) ; if ( LocaleNCompare ( ICCProfile , command , strlen ( ICCProfile ) ) == 0 ) { unsigned char * datum ; profile = AcquireStringInfo ( MaxTextExtent ) ; datum = GetStringInfoDatum ( profile ) ; for ( i = 0 ; ( c = ProfileInteger ( image , hex_digits ) ) != EOF ; i ++ ) { if ( i >= ( ssize_t ) GetStringInfoLength ( profile ) ) { SetStringInfoLength ( profile , ( size_t ) i << 1 ) ; datum = GetStringInfoDatum ( profile ) ; } datum [ i ] = ( unsigned char ) c ; } SetStringInfoLength ( profile , ( size_t ) i + 1 ) ; ( void ) SetImageProfile ( image , \"icc\" , profile ) ; profile = DestroyStringInfo ( profile ) ; continue ; } if ( LocaleNCompare ( PhotoshopProfile , command , strlen ( PhotoshopProfile ) ) == 0 ) { unsigned char * p ; count = ( ssize_t ) sscanf ( command , PhotoshopProfile \"<S2SV_blank>%lu\" , & extent ) ; if ( count != 1 ) continue ; length = extent ; if ( ( MagickSizeType ) length > GetBlobSize ( image ) ) ThrowReaderException ( CorruptImageError , \"InsufficientImageDataInFile\" ) ; profile = BlobToStringInfo ( ( const void * ) NULL , length ) ; if ( profile != ( StringInfo * ) NULL ) { p = GetStringInfoDatum ( profile ) ; for ( i = 0 ; i < ( ssize_t ) length ; i ++ ) * p ++ = ( unsigned char ) ProfileInteger ( image , hex_digits ) ; ( void ) SetImageProfile ( image , \"8bim\" , profile ) ; profile = DestroyStringInfo ( profile ) ; } continue ; } if ( LocaleNCompare ( BeginXMPPacket , command , strlen ( BeginXMPPacket ) ) == 0 ) { register size_t i ; p = command ; profile = StringToStringInfo ( command ) ; for ( i = GetStringInfoLength ( profile ) - 1 ; c != EOF ; i ++ ) { SetStringInfoLength ( profile , ( size_t ) ( i + 1 ) ) ; c = ReadBlobByte ( image ) ; GetStringInfoDatum ( profile ) [ i ] = ( unsigned char ) c ; * p ++ = ( char ) c ; if ( ( strchr ( \"\\\\n\\\\r%\" , c ) == ( char * ) NULL ) && ( ( size_t ) ( p - command ) < ( MaxTextExtent - 1 ) ) ) continue ; * p = '\\\\0' ; p = command ; if ( LocaleNCompare ( EndXMPPacket , command , strlen ( EndXMPPacket ) ) == 0 ) break ; } SetStringInfoLength ( profile , ( size_t ) i ) ; ( void ) SetImageProfile ( image , \"xmp\" , profile ) ; profile = DestroyStringInfo ( profile ) ; continue ; } } ( void ) CloseBlob ( image ) ; if ( image_info -> number_scenes != 0 ) { Image * clone_image ; register ssize_t i ; for ( i = 0 ; i < ( ssize_t ) image_info -> scene ; i ++ ) { clone_image = CloneImage ( postscript_image , 1 , 1 , MagickTrue , exception ) ; if ( clone_image != ( Image * ) NULL ) PrependImageToList ( & postscript_image , clone_image ) ; } } do { ( void ) CopyMagickString ( postscript_image -> filename , filename , MaxTextExtent ) ; ( void ) CopyMagickString ( postscript_image -> magick , image -> magick , MaxTextExtent ) ; if ( columns != 0 ) postscript_image -> magick_columns = columns ; if ( rows != 0 ) postscript_image -> magick_rows = rows ; postscript_image -> page = page ; ( void ) CloneImageProfiles ( postscript_image , image ) ; ( void ) CloneImageProperties ( postscript_image , image ) ; next = SyncNextImageInList ( postscript_image ) ; if ( next != ( Image * ) NULL ) postscript_image = next ; } while ( next != ( Image * ) NULL ) ; image = DestroyImageList ( image ) ; scene = 0 ; for ( next = GetFirstImageInList ( postscript_image ) ; next != ( Image * ) NULL ; ) { next -> scene = scene ++ ; next = GetNextImageInList ( next ) ; } return ( GetFirstImageInList ( postscript_image ) ) ; }\n","target":"<S2SV_ModStart> \"`%s\\'\" , option ) ; geometry = DestroyString ( geometry\n","project_and_commit_id":"ImageMagick@ImageMagick6/7d11230060fa9c8f67e53c85224daf6648805c7b","cve_id":"CVE-2019-13137","original_address":"https://github.com/ImageMagick/ImageMagick6/commit/7d11230060fa9c8f67e53c85224daf6648805c7b","time":"2019-07-01T20:15Z"},
	{"Unnamed: 0":1915,"cwe_id":"CWE-119","source":"CWE-119 static void y4m_convert_mono_420jpeg ( y4m_input * _y4m , unsigned char * _dst , unsigned char * _aux ) { <S2SV_StartBug> int c_sz ; <S2SV_EndBug> _dst += _y4m -> pic_w * _y4m -> pic_h ; c_sz = ( ( _y4m -> pic_w + _y4m -> dst_c_dec_h - 1 ) / _y4m -> dst_c_dec_h ) * ( ( _y4m -> pic_h + _y4m -> dst_c_dec_v - 1 ) / _y4m -> dst_c_dec_v ) ; memset ( _dst , 128 , c_sz * 2 ) ; }\n","target":"<S2SV_ModStart> { int c_sz ; ( void ) _aux\n","project_and_commit_id":"external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426","cve_id":"CVE-2016-1621","original_address":"https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426","time":"2016-03-12T21:59Z"},
	{"Unnamed: 0":6032,"cwe_id":"CWE-399","source":"CWE-399 static int hugetlbfs_statfs ( struct dentry * dentry , struct kstatfs * buf ) { struct hugetlbfs_sb_info * sbinfo = HUGETLBFS_SB ( dentry -> d_sb ) ; struct hstate * h = hstate_inode ( dentry -> d_inode ) ; buf -> f_type = HUGETLBFS_MAGIC ; buf -> f_bsize = huge_page_size ( h ) ; if ( sbinfo ) { spin_lock ( & sbinfo -> stat_lock ) ; <S2SV_StartBug> if ( sbinfo -> max_blocks >= 0 ) { <S2SV_EndBug> <S2SV_StartBug> buf -> f_blocks = sbinfo -> max_blocks ; <S2SV_EndBug> <S2SV_StartBug> buf -> f_bavail = buf -> f_bfree = sbinfo -> free_blocks ; <S2SV_EndBug> buf -> f_files = sbinfo -> max_inodes ; buf -> f_ffree = sbinfo -> free_inodes ; } spin_unlock ( & sbinfo -> stat_lock ) ; } buf -> f_namelen = NAME_MAX ; return 0 ; }\n","target":"<S2SV_ModStart> ( sbinfo -> spool ) { long free_pages ; spin_lock ( & sbinfo -> spool -> lock ) ; <S2SV_ModEnd> buf -> f_blocks <S2SV_ModStart> = sbinfo -> spool -> max_hpages ; free_pages = sbinfo -> spool -> max_hpages - sbinfo -> spool -> used_hpages <S2SV_ModEnd> ; buf -> <S2SV_ModStart> -> f_bfree = free_pages ; spin_unlock ( & sbinfo -> spool -> lock ) <S2SV_ModEnd> ; buf ->\n","project_and_commit_id":"torvalds@linux/90481622d75715bfcb68501280a917dbfe516029","cve_id":"CVE-2012-2133","original_address":"https://github.com/torvalds/linux/commit/90481622d75715bfcb68501280a917dbfe516029","time":"2012-07-03T16:40Z"},
	{"Unnamed: 0":3414,"cwe_id":"CWE-125","source":"CWE-125 int ff_mms_asf_header_parser ( MMSContext * mms ) { uint8_t * p = mms -> asf_header ; uint8_t * end ; int flags , stream_id ; mms -> stream_num = 0 ; if ( mms -> asf_header_size < sizeof ( ff_asf_guid ) * 2 + 22 || memcmp ( p , ff_asf_header , sizeof ( ff_asf_guid ) ) ) { av_log ( NULL , AV_LOG_ERROR , \"Corrupt<S2SV_blank>stream<S2SV_blank>(invalid<S2SV_blank>ASF<S2SV_blank>header,<S2SV_blank>size=%d)\\\\n\" , mms -> asf_header_size ) ; return AVERROR_INVALIDDATA ; } end = mms -> asf_header + mms -> asf_header_size ; p += sizeof ( ff_asf_guid ) + 14 ; while ( end - p >= sizeof ( ff_asf_guid ) + 8 ) { uint64_t chunksize ; if ( ! memcmp ( p , ff_asf_data_header , sizeof ( ff_asf_guid ) ) ) { chunksize = 50 ; } else { chunksize = AV_RL64 ( p + sizeof ( ff_asf_guid ) ) ; } if ( ! chunksize || chunksize > end - p ) { av_log ( NULL , AV_LOG_ERROR , \"Corrupt<S2SV_blank>stream<S2SV_blank>(header<S2SV_blank>chunksize<S2SV_blank>%\" PRId64 \"<S2SV_blank>is<S2SV_blank>invalid)\\\\n\" , chunksize ) ; return AVERROR_INVALIDDATA ; } if ( ! memcmp ( p , ff_asf_file_header , sizeof ( ff_asf_guid ) ) ) { if ( end - p > sizeof ( ff_asf_guid ) * 2 + 68 ) { mms -> asf_packet_len = AV_RL32 ( p + sizeof ( ff_asf_guid ) * 2 + 64 ) ; if ( mms -> asf_packet_len <= 0 || mms -> asf_packet_len > sizeof ( mms -> in_buffer ) ) { av_log ( NULL , AV_LOG_ERROR , \"Corrupt<S2SV_blank>stream<S2SV_blank>(too<S2SV_blank>large<S2SV_blank>pkt_len<S2SV_blank>%d)\\\\n\" , mms -> asf_packet_len ) ; return AVERROR_INVALIDDATA ; } } } else if ( ! memcmp ( p , ff_asf_stream_header , sizeof ( ff_asf_guid ) ) ) { <S2SV_StartBug> flags = AV_RL16 ( p + sizeof ( ff_asf_guid ) * 3 + 24 ) ; <S2SV_EndBug> stream_id = flags & 0x7F ; if ( mms -> stream_num < MMS_MAX_STREAMS && 46 + mms -> stream_num * 6 < sizeof ( mms -> out_buffer ) ) { mms -> streams = av_fast_realloc ( mms -> streams , & mms -> nb_streams_allocated , ( mms -> stream_num + 1 ) * sizeof ( MMSStream ) ) ; if ( ! mms -> streams ) return AVERROR ( ENOMEM ) ; mms -> streams [ mms -> stream_num ] . id = stream_id ; mms -> stream_num ++ ; } else { av_log ( NULL , AV_LOG_ERROR , \"Corrupt<S2SV_blank>stream<S2SV_blank>(too<S2SV_blank>many<S2SV_blank>A/V<S2SV_blank>streams)\\\\n\" ) ; return AVERROR_INVALIDDATA ; } <S2SV_StartBug> } else if ( ! memcmp ( p , ff_asf_ext_stream_header , sizeof ( ff_asf_guid ) ) ) { <S2SV_EndBug> if ( end - p >= 88 ) { int stream_count = AV_RL16 ( p + 84 ) , ext_len_count = AV_RL16 ( p + 86 ) ; uint64_t skip_bytes = 88 ; while ( stream_count -- ) { if ( end - p < skip_bytes + 4 ) { av_log ( NULL , AV_LOG_ERROR , \"Corrupt<S2SV_blank>stream<S2SV_blank>(next<S2SV_blank>stream<S2SV_blank>name<S2SV_blank>length<S2SV_blank>is<S2SV_blank>not<S2SV_blank>in<S2SV_blank>the<S2SV_blank>buffer)\\\\n\" ) ; return AVERROR_INVALIDDATA ; } skip_bytes += 4 + AV_RL16 ( p + skip_bytes + 2 ) ; } while ( ext_len_count -- ) { if ( end - p < skip_bytes + 22 ) { av_log ( NULL , AV_LOG_ERROR , \"Corrupt<S2SV_blank>stream<S2SV_blank>(next<S2SV_blank>extension<S2SV_blank>system<S2SV_blank>info<S2SV_blank>length<S2SV_blank>is<S2SV_blank>not<S2SV_blank>in<S2SV_blank>the<S2SV_blank>buffer)\\\\n\" ) ; return AVERROR_INVALIDDATA ; } skip_bytes += 22 + AV_RL32 ( p + skip_bytes + 18 ) ; } if ( end - p < skip_bytes ) { av_log ( NULL , AV_LOG_ERROR , \"Corrupt<S2SV_blank>stream<S2SV_blank>(the<S2SV_blank>last<S2SV_blank>extension<S2SV_blank>system<S2SV_blank>info<S2SV_blank>length<S2SV_blank>is<S2SV_blank>invalid)\\\\n\" ) ; return AVERROR_INVALIDDATA ; } if ( chunksize - skip_bytes > 24 ) chunksize = skip_bytes ; } } else if ( ! memcmp ( p , ff_asf_head1_guid , sizeof ( ff_asf_guid ) ) ) { chunksize = 46 ; <S2SV_StartBug> } <S2SV_EndBug> p += chunksize ; } return 0 ; }\n","target":"<S2SV_ModStart> ) ) { if ( end - p >= ( sizeof ( ff_asf_guid ) * 3 + 26 ) ) { <S2SV_ModStart> ; } } } <S2SV_ModStart> = 46 ; if ( chunksize > end - p ) { av_log ( NULL , AV_LOG_ERROR , \"Corrupt<S2SV_blank>stream<S2SV_blank>(header<S2SV_blank>chunksize<S2SV_blank>%\" PRId64 \"<S2SV_blank>is<S2SV_blank>invalid)\\\\n\" , chunksize ) ; return AVERROR_INVALIDDATA ; }\n","project_and_commit_id":"FFmpeg@FFmpeg/cced03dd667a5df6df8fd40d8de0bff477ee02e8","cve_id":"CVE-2018-1999010","original_address":"https://github.com/FFmpeg/FFmpeg/commit/cced03dd667a5df6df8fd40d8de0bff477ee02e8","time":"2018-07-23T15:29Z"},
	{"Unnamed: 0":5857,"cwe_id":"CWE-119","source":"CWE-119 <S2SV_StartBug> static void show_object ( struct object * object , struct strbuf * path , <S2SV_EndBug> <S2SV_StartBug> const char * last , void * data ) <S2SV_EndBug> { struct bitmap * base = data ; bitmap_set ( base , find_object_pos ( object -> oid . hash ) ) ; mark_as_seen ( object ) ; }\n","target":"<S2SV_ModStart> * object , <S2SV_ModEnd> const char * <S2SV_ModStart> const char * name <S2SV_ModEnd> , void *\n","project_and_commit_id":"git@git/de1e67d0703894cb6ea782e36abb63976ab07e60","cve_id":"CVE-2016-2324","original_address":"https://github.com/git/git/commit/de1e67d0703894cb6ea782e36abb63976ab07e60","time":"2016-04-08T14:59Z"},
	{"Unnamed: 0":387,"cwe_id":"CWE-444","source":"CWE-444 bool agoo_ws_create_req ( agooCon c , long mlen ) { uint8_t op = 0x0F & * c -> buf ; if ( NULL == ( c -> req = agoo_req_create ( mlen ) ) ) { agoo_log_cat ( & agoo_error_cat , \"Out<S2SV_blank>of<S2SV_blank>memory<S2SV_blank>attempting<S2SV_blank>to<S2SV_blank>allocate<S2SV_blank>request.\" ) ; return true ; } if ( NULL == c -> up || agoo_server . ctx_nil_value == c -> up -> ctx ) { return true ; } memset ( c -> req , 0 , sizeof ( struct _agooReq ) ) ; if ( ( long ) c -> bcnt <= mlen ) { memcpy ( c -> req -> msg , c -> buf , c -> bcnt ) ; if ( ( long ) c -> bcnt < mlen ) { memset ( c -> req -> msg + c -> bcnt , 0 , mlen - c -> bcnt ) ; } } else { memcpy ( c -> req -> msg , c -> buf , mlen ) ; } c -> req -> msg [ mlen ] = '\\\\0' ; c -> req -> mlen = mlen ; c -> req -> method = ( AGOO_WS_OP_BIN == op ) ? AGOO_ON_BIN : AGOO_ON_MSG ; c -> req -> upgrade = AGOO_UP_NONE ; c -> req -> up = c -> up ; <S2SV_StartBug> c -> req -> res = NULL ; <S2SV_EndBug> if ( c -> up -> on_msg ) { c -> req -> hook = agoo_hook_create ( AGOO_NONE , NULL , c -> up -> ctx , PUSH_HOOK , & agoo_server . eval_queue ) ; } return false ; }\n","target":"<S2SV_ModStart> -> up ; memcpy ( c -> req -> remote , c -> remote , sizeof ( c -> remote ) ) ;\n","project_and_commit_id":"ohler55@agoo/23d03535cf7b50d679a60a953a0cae9519a4a130","cve_id":"CVE-2020-7670","original_address":"https://github.com/ohler55/agoo/commit/23d03535cf7b50d679a60a953a0cae9519a4a130","time":"2020-06-10T16:15Z"},
	{"Unnamed: 0":5934,"cwe_id":"CWE-19","source":"CWE-19 STATIC int xfs_attr_leaf_addname ( xfs_da_args_t * args ) { xfs_inode_t * dp ; struct xfs_buf * bp ; int retval , error , committed , forkoff ; trace_xfs_attr_leaf_addname ( args ) ; dp = args -> dp ; args -> blkno = 0 ; error = xfs_attr3_leaf_read ( args -> trans , args -> dp , args -> blkno , - 1 , & bp ) ; if ( error ) return error ; retval = xfs_attr3_leaf_lookup_int ( bp , args ) ; if ( ( args -> flags & ATTR_REPLACE ) && ( retval == ENOATTR ) ) { xfs_trans_brelse ( args -> trans , bp ) ; return retval ; } else if ( retval == EEXIST ) { if ( args -> flags & ATTR_CREATE ) { xfs_trans_brelse ( args -> trans , bp ) ; return retval ; } trace_xfs_attr_leaf_replace ( args ) ; args -> op_flags |= XFS_DA_OP_RENAME ; args -> blkno2 = args -> blkno ; args -> index2 = args -> index ; args -> rmtblkno2 = args -> rmtblkno ; args -> rmtblkcnt2 = args -> rmtblkcnt ; <S2SV_StartBug> } <S2SV_EndBug> retval = xfs_attr3_leaf_add ( bp , args ) ; if ( retval == ENOSPC ) { xfs_bmap_init ( args -> flist , args -> firstblock ) ; error = xfs_attr3_leaf_to_node ( args ) ; if ( ! error ) { error = xfs_bmap_finish ( & args -> trans , args -> flist , & committed ) ; } if ( error ) { ASSERT ( committed ) ; args -> trans = NULL ; xfs_bmap_cancel ( args -> flist ) ; return ( error ) ; } if ( committed ) xfs_trans_ijoin ( args -> trans , dp , 0 ) ; error = xfs_trans_roll ( & args -> trans , dp ) ; if ( error ) return ( error ) ; error = xfs_attr_node_addname ( args ) ; return ( error ) ; } error = xfs_trans_roll ( & args -> trans , dp ) ; if ( error ) return ( error ) ; if ( args -> rmtblkno > 0 ) { error = xfs_attr_rmtval_set ( args ) ; if ( error ) return ( error ) ; } if ( args -> op_flags & XFS_DA_OP_RENAME ) { error = xfs_attr3_leaf_flipflags ( args ) ; if ( error ) return ( error ) ; args -> index = args -> index2 ; args -> blkno = args -> blkno2 ; args -> rmtblkno = args -> rmtblkno2 ; args -> rmtblkcnt = args -> rmtblkcnt2 ; <S2SV_StartBug> if ( args -> rmtblkno ) { <S2SV_EndBug> error = xfs_attr_rmtval_remove ( args ) ; if ( error ) return ( error ) ; } error = xfs_attr3_leaf_read ( args -> trans , args -> dp , args -> blkno , - 1 , & bp ) ; if ( error ) return error ; xfs_attr3_leaf_remove ( bp , args ) ; if ( ( forkoff = xfs_attr_shortform_allfit ( bp , dp ) ) ) { xfs_bmap_init ( args -> flist , args -> firstblock ) ; error = xfs_attr3_leaf_to_shortform ( bp , args , forkoff ) ; if ( ! error ) { error = xfs_bmap_finish ( & args -> trans , args -> flist , & committed ) ; } if ( error ) { ASSERT ( committed ) ; args -> trans = NULL ; xfs_bmap_cancel ( args -> flist ) ; return ( error ) ; } if ( committed ) xfs_trans_ijoin ( args -> trans , dp , 0 ) ; } error = xfs_trans_roll ( & args -> trans , dp ) ; } else if ( args -> rmtblkno > 0 ) { error = xfs_attr3_leaf_clearflag ( args ) ; } return error ; }\n","target":"<S2SV_ModStart> -> rmtblkcnt ; args -> rmtvaluelen2 = args -> rmtvaluelen ; args -> rmtblkno = 0 ; args -> rmtblkcnt = 0 ; args -> rmtvaluelen = 0 ; <S2SV_ModStart> -> rmtblkcnt2 ; args -> rmtvaluelen = args -> rmtvaluelen2 ;\n","project_and_commit_id":"torvalds@linux/8275cdd0e7ac550dcce2b3ef6d2fb3b808c1ae59","cve_id":"CVE-2015-0274","original_address":"https://github.com/torvalds/linux/commit/8275cdd0e7ac550dcce2b3ef6d2fb3b808c1ae59","time":"2015-03-16T10:59Z"},
	{"Unnamed: 0":2916,"cwe_id":"CWE-125","source":"CWE-125 static void get_nb10 ( ut8 * dbg_data , SCV_NB10_HEADER * res ) { const int nb10sz = 16 ; <S2SV_StartBug> memcpy ( res , dbg_data , nb10sz ) ; <S2SV_EndBug> res -> file_name = ( ut8 * ) strdup ( ( const char * ) dbg_data + nb10sz ) ; }\n","target":"<S2SV_ModStart> = 16 ; <S2SV_ModEnd> } <S2SV_null> <S2SV_null>\n","project_and_commit_id":"radare@radare2/4e1cf0d3e6f6fe2552a269def0af1cd2403e266c","cve_id":"CVE-2018-11379","original_address":"https://github.com/radare/radare2/commit/4e1cf0d3e6f6fe2552a269def0af1cd2403e266c","time":"2018-05-22T19:29Z"},
	{"Unnamed: 0":4006,"cwe_id":"CWE-476","source":"CWE-476 static int stv06xx_isoc_init ( struct gspca_dev * gspca_dev ) <S2SV_StartBug> { <S2SV_EndBug> struct usb_host_interface * alt ; struct sd * sd = ( struct sd * ) gspca_dev ; <S2SV_StartBug> alt = & gspca_dev -> dev -> actconfig -> intf_cache [ 0 ] -> altsetting [ 1 ] ; <S2SV_EndBug> alt -> endpoint [ 0 ] . desc . wMaxPacketSize = cpu_to_le16 ( sd -> sensor -> max_packet_size [ gspca_dev -> curr_mode ] ) ; return 0 ; }\n","target":"<S2SV_ModStart> gspca_dev ) { struct usb_interface_cache * intfc ; <S2SV_ModStart> ) gspca_dev ; intfc = <S2SV_ModEnd> gspca_dev -> dev <S2SV_ModStart> [ 0 ] ; if ( intfc -> num_altsetting < 2 ) return - ENODEV ; alt = & intfc <S2SV_ModStart> [ 1 ] ; if ( alt -> desc . bNumEndpoints < 1 ) return - ENODEV\n","project_and_commit_id":"torvalds@linux/485b06aadb933190f4bc44e006076bc27a23f205","cve_id":"CVE-2020-11609","original_address":"https://github.com/torvalds/linux/commit/485b06aadb933190f4bc44e006076bc27a23f205","time":"2020-04-07T17:15Z"},
	{"Unnamed: 0":1532,"cwe_id":"CWE-119","source":"CWE-119 static VALUE cState_object_nl_set ( VALUE self , VALUE object_nl ) { unsigned long len ; GET_STATE ( self ) ; Check_Type ( object_nl , T_STRING ) ; len = RSTRING_LEN ( object_nl ) ; if ( len == 0 ) { if ( state -> object_nl ) { ruby_xfree ( state -> object_nl ) ; state -> object_nl = NULL ; } } else { if ( state -> object_nl ) ruby_xfree ( state -> object_nl ) ; <S2SV_StartBug> state -> object_nl = strdup ( RSTRING_PTR ( object_nl ) ) ; <S2SV_EndBug> state -> object_nl_len = len ; } return Qnil ; }\n","target":"<S2SV_ModStart> -> object_nl = fstrndup <S2SV_ModEnd> ( RSTRING_PTR ( <S2SV_ModStart> ( object_nl ) , len\n","project_and_commit_id":"flori@json/8f782fd8e181d9cfe9387ded43a5ca9692266b85","cve_id":"CVE-2017-14064","original_address":"https://github.com/flori/json/commit/8f782fd8e181d9cfe9387ded43a5ca9692266b85","time":"2017-08-31T17:29Z"},
	{"Unnamed: 0":2070,"cwe_id":"CWE-000","source":"CWE-000 krb5_error_code krb5_ldap_put_principal ( krb5_context context , krb5_db_entry * entry , char * * db_args ) { int l = 0 , kerberos_principal_object_type = 0 ; unsigned int ntrees = 0 , tre = 0 ; krb5_error_code st = 0 , tempst = 0 ; LDAP * ld = NULL ; LDAPMessage * result = NULL , * ent = NULL ; char * * subtreelist = NULL ; char * user = NULL , * subtree = NULL , * principal_dn = NULL ; char * * values = NULL , * strval [ 10 ] = { NULL } , errbuf [ 1024 ] ; char * filtuser = NULL ; struct berval * * bersecretkey = NULL ; LDAPMod * * mods = NULL ; krb5_boolean create_standalone_prinicipal = FALSE ; krb5_boolean krb_identity_exists = FALSE , establish_links = FALSE ; char * standalone_principal_dn = NULL ; krb5_tl_data * tl_data = NULL ; krb5_key_data * * keys = NULL ; kdb5_dal_handle * dal_handle = NULL ; krb5_ldap_context * ldap_context = NULL ; krb5_ldap_server_handle * ldap_server_handle = NULL ; osa_princ_ent_rec princ_ent = { 0 } ; xargs_t xargs = { 0 } ; char * polname = NULL ; OPERATION optype ; krb5_boolean found_entry = FALSE ; krb5_clear_error_message ( context ) ; SETUP_CONTEXT ( ) ; if ( ldap_context -> lrparams == NULL || ldap_context -> container_dn == NULL ) return EINVAL ; GET_HANDLE ( ) ; if ( ! is_principal_in_realm ( ldap_context , entry -> princ ) ) { st = EINVAL ; k5_setmsg ( context , st , _ ( \"Principal<S2SV_blank>does<S2SV_blank>not<S2SV_blank>belong<S2SV_blank>to<S2SV_blank>the<S2SV_blank>default<S2SV_blank>realm\" ) ) ; goto cleanup ; } if ( ( ( st = krb5_unparse_name ( context , entry -> princ , & user ) ) != 0 ) || ( ( st = krb5_ldap_unparse_principal_name ( user ) ) != 0 ) ) goto cleanup ; filtuser = ldap_filter_correct ( user ) ; if ( filtuser == NULL ) { st = ENOMEM ; goto cleanup ; } if ( entry -> mask & KADM5_PRINCIPAL ) optype = ADD_PRINCIPAL ; else optype = MODIFY_PRINCIPAL ; if ( ( ( st = krb5_get_princ_type ( context , entry , & kerberos_principal_object_type ) ) != 0 ) || ( ( st = krb5_get_userdn ( context , entry , & principal_dn ) ) != 0 ) ) goto cleanup ; if ( ( st = process_db_args ( context , db_args , & xargs , optype ) ) != 0 ) goto cleanup ; if ( entry -> mask & KADM5_LOAD ) { unsigned int tree = 0 ; int numlentries = 0 ; char * filter = NULL ; if ( asprintf ( & filter , FILTER \"%s))\" , filtuser ) < 0 ) { filter = NULL ; st = ENOMEM ; goto cleanup ; } if ( ( st = krb5_get_subtree_info ( ldap_context , & subtreelist , & ntrees ) ) != 0 ) goto cleanup ; found_entry = FALSE ; for ( tree = 0 ; found_entry == FALSE && tree < ntrees ; ++ tree ) { if ( principal_dn == NULL ) { LDAP_SEARCH_1 ( subtreelist [ tree ] , ldap_context -> lrparams -> search_scope , filter , principal_attributes , IGNORE_STATUS ) ; } else { LDAP_SEARCH_1 ( principal_dn , LDAP_SCOPE_BASE , filter , principal_attributes , IGNORE_STATUS ) ; } if ( st == LDAP_SUCCESS ) { numlentries = ldap_count_entries ( ld , result ) ; if ( numlentries > 1 ) { free ( filter ) ; st = EINVAL ; k5_setmsg ( context , st , _ ( \"operation<S2SV_blank>can<S2SV_blank>not<S2SV_blank>continue,<S2SV_blank>more<S2SV_blank>than<S2SV_blank>one<S2SV_blank>\" \"entry<S2SV_blank>with<S2SV_blank>principal<S2SV_blank>name<S2SV_blank>\\\\\"%s\\\\\"<S2SV_blank>found\" ) , user ) ; goto cleanup ; } else if ( numlentries == 1 ) { found_entry = TRUE ; if ( principal_dn == NULL ) { ent = ldap_first_entry ( ld , result ) ; if ( ent != NULL ) { if ( ( principal_dn = ldap_get_dn ( ld , ent ) ) == NULL ) { ldap_get_option ( ld , LDAP_OPT_RESULT_CODE , & st ) ; st = set_ldap_error ( context , st , 0 ) ; free ( filter ) ; goto cleanup ; } } } } } else if ( st != LDAP_NO_SUCH_OBJECT ) { st = set_ldap_error ( context , st , 0 ) ; free ( filter ) ; goto cleanup ; } ldap_msgfree ( result ) ; result = NULL ; } free ( filter ) ; if ( found_entry == FALSE && principal_dn != NULL ) { create_standalone_prinicipal = TRUE ; standalone_principal_dn = strdup ( principal_dn ) ; CHECK_NULL ( standalone_principal_dn ) ; } } if ( principal_dn == NULL && xargs . dn == NULL ) { if ( entry -> princ -> length == 2 && entry -> princ -> data [ 0 ] . length == strlen ( \"krbtgt\" ) && strncmp ( entry -> princ -> data [ 0 ] . data , \"krbtgt\" , entry -> princ -> data [ 0 ] . length ) == 0 ) { subtree = strdup ( ldap_context -> lrparams -> realmdn ) ; } else if ( xargs . containerdn ) { if ( ( st = checkattributevalue ( ld , xargs . containerdn , NULL , NULL , NULL ) ) != 0 ) { if ( st == KRB5_KDB_NOENTRY || st == KRB5_KDB_CONSTRAINT_VIOLATION ) { int ost = st ; st = EINVAL ; k5_prependmsg ( context , ost , st , _ ( \"\\'%s\\'<S2SV_blank>not<S2SV_blank>found\" ) , xargs . containerdn ) ; } goto cleanup ; } subtree = strdup ( xargs . containerdn ) ; } else if ( ldap_context -> lrparams -> containerref && strlen ( ldap_context -> lrparams -> containerref ) != 0 ) { subtree = strdup ( ldap_context -> lrparams -> containerref ) ; } else { subtree = strdup ( ldap_context -> lrparams -> realmdn ) ; } CHECK_NULL ( subtree ) ; if ( asprintf ( & standalone_principal_dn , \"krbprincipalname=%s,%s\" , filtuser , subtree ) < 0 ) standalone_principal_dn = NULL ; CHECK_NULL ( standalone_principal_dn ) ; create_standalone_prinicipal = TRUE ; free ( subtree ) ; subtree = NULL ; } if ( xargs . dn_from_kbd == TRUE ) { int dnlen = 0 , subtreelen = 0 ; char * dn = NULL ; krb5_boolean outofsubtree = TRUE ; if ( xargs . dn != NULL ) { dn = xargs . dn ; } else if ( xargs . linkdn != NULL ) { dn = xargs . linkdn ; } else if ( standalone_principal_dn != NULL ) { dn = standalone_principal_dn ; } if ( subtreelist == NULL ) { st = krb5_get_subtree_info ( ldap_context , & subtreelist , & ntrees ) ; if ( st ) goto cleanup ; } for ( tre = 0 ; tre < ntrees ; ++ tre ) { if ( subtreelist [ tre ] == NULL || strlen ( subtreelist [ tre ] ) == 0 ) { outofsubtree = FALSE ; break ; } else { dnlen = strlen ( dn ) ; subtreelen = strlen ( subtreelist [ tre ] ) ; if ( ( dnlen >= subtreelen ) && ( strcasecmp ( ( dn + dnlen - subtreelen ) , subtreelist [ tre ] ) == 0 ) ) { outofsubtree = FALSE ; break ; } } } if ( outofsubtree == TRUE ) { st = EINVAL ; k5_setmsg ( context , st , _ ( \"DN<S2SV_blank>is<S2SV_blank>out<S2SV_blank>of<S2SV_blank>the<S2SV_blank>realm<S2SV_blank>subtree\" ) ) ; goto cleanup ; } if ( standalone_principal_dn == NULL ) { char * attributes [ ] = { \"krbticketpolicyreference\" , \"krbprincipalname\" , NULL } ; ldap_msgfree ( result ) ; result = NULL ; LDAP_SEARCH_1 ( dn , LDAP_SCOPE_BASE , 0 , attributes , IGNORE_STATUS ) ; if ( st == LDAP_SUCCESS ) { ent = ldap_first_entry ( ld , result ) ; if ( ent != NULL ) { if ( ( values = ldap_get_values ( ld , ent , \"krbticketpolicyreference\" ) ) != NULL ) { ldap_value_free ( values ) ; } if ( ( values = ldap_get_values ( ld , ent , \"krbprincipalname\" ) ) != NULL ) { krb_identity_exists = TRUE ; ldap_value_free ( values ) ; } } } else { st = set_ldap_error ( context , st , OP_SEARCH ) ; goto cleanup ; } } } if ( xargs . dn != NULL && krb_identity_exists == TRUE ) { st = EINVAL ; snprintf ( errbuf , sizeof ( errbuf ) , _ ( \"ldap<S2SV_blank>object<S2SV_blank>is<S2SV_blank>already<S2SV_blank>kerberized\" ) ) ; k5_setmsg ( context , st , \"%s\" , errbuf ) ; goto cleanup ; } if ( xargs . linkdn != NULL ) { if ( optype == MODIFY_PRINCIPAL && kerberos_principal_object_type != KDB_STANDALONE_PRINCIPAL_OBJECT ) { st = EINVAL ; snprintf ( errbuf , sizeof ( errbuf ) , _ ( \"link<S2SV_blank>information<S2SV_blank>can<S2SV_blank>not<S2SV_blank>be<S2SV_blank>set/updated<S2SV_blank>as<S2SV_blank>the<S2SV_blank>\" \"kerberos<S2SV_blank>principal<S2SV_blank>belongs<S2SV_blank>to<S2SV_blank>an<S2SV_blank>ldap<S2SV_blank>object\" ) ) ; k5_setmsg ( context , st , \"%s\" , errbuf ) ; goto cleanup ; } { char * * linkdns = NULL ; int j = 0 ; if ( ( st = krb5_get_linkdn ( context , entry , & linkdns ) ) != 0 ) { snprintf ( errbuf , sizeof ( errbuf ) , _ ( \"Failed<S2SV_blank>getting<S2SV_blank>object<S2SV_blank>references\" ) ) ; k5_setmsg ( context , st , \"%s\" , errbuf ) ; goto cleanup ; } if ( linkdns != NULL ) { st = EINVAL ; snprintf ( errbuf , sizeof ( errbuf ) , _ ( \"kerberos<S2SV_blank>principal<S2SV_blank>is<S2SV_blank>already<S2SV_blank>linked<S2SV_blank>to<S2SV_blank>a<S2SV_blank>ldap<S2SV_blank>\" \"object\" ) ) ; k5_setmsg ( context , st , \"%s\" , errbuf ) ; for ( j = 0 ; linkdns [ j ] != NULL ; ++ j ) free ( linkdns [ j ] ) ; free ( linkdns ) ; goto cleanup ; } } establish_links = TRUE ; } if ( entry -> mask & KADM5_LAST_SUCCESS ) { memset ( strval , 0 , sizeof ( strval ) ) ; if ( ( strval [ 0 ] = getstringtime ( entry -> last_success ) ) == NULL ) goto cleanup ; if ( ( st = krb5_add_str_mem_ldap_mod ( & mods , \"krbLastSuccessfulAuth\" , LDAP_MOD_REPLACE , strval ) ) != 0 ) { free ( strval [ 0 ] ) ; goto cleanup ; } free ( strval [ 0 ] ) ; } if ( entry -> mask & KADM5_LAST_FAILED ) { memset ( strval , 0 , sizeof ( strval ) ) ; if ( ( strval [ 0 ] = getstringtime ( entry -> last_failed ) ) == NULL ) goto cleanup ; if ( ( st = krb5_add_str_mem_ldap_mod ( & mods , \"krbLastFailedAuth\" , LDAP_MOD_REPLACE , strval ) ) != 0 ) { free ( strval [ 0 ] ) ; goto cleanup ; } free ( strval [ 0 ] ) ; } if ( entry -> mask & KADM5_FAIL_AUTH_COUNT ) { krb5_kvno fail_auth_count ; fail_auth_count = entry -> fail_auth_count ; if ( entry -> mask & KADM5_FAIL_AUTH_COUNT_INCREMENT ) fail_auth_count ++ ; st = krb5_add_int_mem_ldap_mod ( & mods , \"krbLoginFailedCount\" , LDAP_MOD_REPLACE , fail_auth_count ) ; if ( st != 0 ) goto cleanup ; } else if ( entry -> mask & KADM5_FAIL_AUTH_COUNT_INCREMENT ) { int attr_mask = 0 ; krb5_boolean has_fail_count ; st = krb5_get_attributes_mask ( context , entry , & attr_mask ) ; if ( st != 0 ) goto cleanup ; has_fail_count = ( ( attr_mask & KDB_FAIL_AUTH_COUNT_ATTR ) != 0 ) ; # ifdef LDAP_MOD_INCREMENT if ( ldap_server_handle -> server_info -> modify_increment && has_fail_count ) { st = krb5_add_int_mem_ldap_mod ( & mods , \"krbLoginFailedCount\" , LDAP_MOD_INCREMENT , 1 ) ; if ( st != 0 ) goto cleanup ; } else { # endif if ( has_fail_count ) { st = krb5_add_int_mem_ldap_mod ( & mods , \"krbLoginFailedCount\" , LDAP_MOD_DELETE , entry -> fail_auth_count ) ; if ( st != 0 ) goto cleanup ; } st = krb5_add_int_mem_ldap_mod ( & mods , \"krbLoginFailedCount\" , LDAP_MOD_ADD , entry -> fail_auth_count + 1 ) ; if ( st != 0 ) goto cleanup ; # ifdef LDAP_MOD_INCREMENT } # endif } else if ( optype == ADD_PRINCIPAL ) { st = krb5_add_int_mem_ldap_mod ( & mods , \"krbLoginFailedCount\" , LDAP_MOD_ADD , 0 ) ; } if ( entry -> mask & KADM5_MAX_LIFE ) { if ( ( st = krb5_add_int_mem_ldap_mod ( & mods , \"krbmaxticketlife\" , LDAP_MOD_REPLACE , entry -> max_life ) ) != 0 ) goto cleanup ; } if ( entry -> mask & KADM5_MAX_RLIFE ) { if ( ( st = krb5_add_int_mem_ldap_mod ( & mods , \"krbmaxrenewableage\" , LDAP_MOD_REPLACE , entry -> max_renewable_life ) ) != 0 ) goto cleanup ; } if ( entry -> mask & KADM5_ATTRIBUTES ) { if ( ( st = krb5_add_int_mem_ldap_mod ( & mods , \"krbticketflags\" , LDAP_MOD_REPLACE , entry -> attributes ) ) != 0 ) goto cleanup ; } if ( entry -> mask & KADM5_PRINCIPAL ) { memset ( strval , 0 , sizeof ( strval ) ) ; strval [ 0 ] = user ; if ( ( st = krb5_add_str_mem_ldap_mod ( & mods , \"krbprincipalname\" , LDAP_MOD_REPLACE , strval ) ) != 0 ) goto cleanup ; } if ( entry -> mask & KADM5_PRINC_EXPIRE_TIME ) { memset ( strval , 0 , sizeof ( strval ) ) ; if ( ( strval [ 0 ] = getstringtime ( entry -> expiration ) ) == NULL ) goto cleanup ; if ( ( st = krb5_add_str_mem_ldap_mod ( & mods , \"krbprincipalexpiration\" , LDAP_MOD_REPLACE , strval ) ) != 0 ) { free ( strval [ 0 ] ) ; goto cleanup ; } free ( strval [ 0 ] ) ; } if ( entry -> mask & KADM5_PW_EXPIRATION ) { memset ( strval , 0 , sizeof ( strval ) ) ; if ( ( strval [ 0 ] = getstringtime ( entry -> pw_expiration ) ) == NULL ) goto cleanup ; if ( ( st = krb5_add_str_mem_ldap_mod ( & mods , \"krbpasswordexpiration\" , LDAP_MOD_REPLACE , strval ) ) != 0 ) { free ( strval [ 0 ] ) ; goto cleanup ; } free ( strval [ 0 ] ) ; } if ( entry -> mask & KADM5_POLICY ) { memset ( & princ_ent , 0 , sizeof ( princ_ent ) ) ; for ( tl_data = entry -> tl_data ; tl_data ; tl_data = tl_data -> tl_data_next ) { if ( tl_data -> tl_data_type == KRB5_TL_KADM_DATA ) { if ( ( st = krb5_lookup_tl_kadm_data ( tl_data , & princ_ent ) ) != 0 ) { goto cleanup ; } break ; } } if ( princ_ent . aux_attributes & KADM5_POLICY ) { memset ( strval , 0 , sizeof ( strval ) ) ; if ( ( st = krb5_ldap_name_to_policydn ( context , princ_ent . policy , & polname ) ) != 0 ) goto cleanup ; strval [ 0 ] = polname ; if ( ( st = krb5_add_str_mem_ldap_mod ( & mods , \"krbpwdpolicyreference\" , LDAP_MOD_REPLACE , strval ) ) != 0 ) goto cleanup ; } else { st = EINVAL ; k5_setmsg ( context , st , \"Password<S2SV_blank>policy<S2SV_blank>value<S2SV_blank>null\" ) ; goto cleanup ; } } else if ( entry -> mask & KADM5_LOAD && found_entry == TRUE ) { if ( ( st = krb5_add_str_mem_ldap_mod ( & mods , \"krbpwdpolicyreference\" , LDAP_MOD_REPLACE , NULL ) ) != 0 ) goto cleanup ; } if ( entry -> mask & KADM5_POLICY_CLR ) { if ( ( st = krb5_add_str_mem_ldap_mod ( & mods , \"krbpwdpolicyreference\" , LDAP_MOD_DELETE , NULL ) ) != 0 ) goto cleanup ; } if ( entry -> mask & KADM5_KEY_DATA || entry -> mask & KADM5_KVNO ) { krb5_kvno mkvno ; if ( ( st = krb5_dbe_lookup_mkvno ( context , entry , & mkvno ) ) != 0 ) goto cleanup ; bersecretkey = krb5_encode_krbsecretkey ( entry -> key_data , entry -> n_key_data , mkvno ) ; <S2SV_StartBug> if ( ( st = krb5_add_ber_mem_ldap_mod ( & mods , \"krbprincipalkey\" , <S2SV_EndBug> <S2SV_StartBug> LDAP_MOD_REPLACE | LDAP_MOD_BVALUES , bersecretkey ) ) != 0 ) <S2SV_EndBug> goto cleanup ; if ( ! ( entry -> mask & KADM5_PRINCIPAL ) ) { memset ( strval , 0 , sizeof ( strval ) ) ; if ( ( strval [ 0 ] = getstringtime ( entry -> pw_expiration ) ) == NULL ) goto cleanup ; if ( ( st = krb5_add_str_mem_ldap_mod ( & mods , \"krbpasswordexpiration\" , LDAP_MOD_REPLACE , strval ) ) != 0 ) { free ( strval [ 0 ] ) ; goto cleanup ; } free ( strval [ 0 ] ) ; } { krb5_timestamp last_pw_changed ; if ( ( st = krb5_dbe_lookup_last_pwd_change ( context , entry , & last_pw_changed ) ) != 0 ) goto cleanup ; memset ( strval , 0 , sizeof ( strval ) ) ; if ( ( strval [ 0 ] = getstringtime ( last_pw_changed ) ) == NULL ) goto cleanup ; if ( ( st = krb5_add_str_mem_ldap_mod ( & mods , \"krbLastPwdChange\" , LDAP_MOD_REPLACE , strval ) ) != 0 ) { free ( strval [ 0 ] ) ; goto cleanup ; } free ( strval [ 0 ] ) ; } } if ( entry -> tl_data != NULL ) { int count = 0 ; struct berval * * ber_tl_data = NULL ; krb5_tl_data * ptr ; krb5_timestamp unlock_time ; for ( ptr = entry -> tl_data ; ptr != NULL ; ptr = ptr -> tl_data_next ) { if ( ptr -> tl_data_type == KRB5_TL_LAST_PWD_CHANGE # ifdef SECURID || ptr -> tl_data_type == KRB5_TL_DB_ARGS # endif || ptr -> tl_data_type == KRB5_TL_KADM_DATA || ptr -> tl_data_type == KDB_TL_USER_INFO || ptr -> tl_data_type == KRB5_TL_CONSTRAINED_DELEGATION_ACL || ptr -> tl_data_type == KRB5_TL_LAST_ADMIN_UNLOCK ) continue ; count ++ ; } if ( count != 0 ) { int j ; ber_tl_data = ( struct berval * * ) calloc ( count + 1 , sizeof ( struct berval * ) ) ; if ( ber_tl_data == NULL ) { st = ENOMEM ; goto cleanup ; } for ( j = 0 , ptr = entry -> tl_data ; ptr != NULL ; ptr = ptr -> tl_data_next ) { if ( ptr -> tl_data_type == KRB5_TL_LAST_PWD_CHANGE # ifdef SECURID || ptr -> tl_data_type == KRB5_TL_DB_ARGS # endif || ptr -> tl_data_type == KRB5_TL_KADM_DATA || ptr -> tl_data_type == KDB_TL_USER_INFO || ptr -> tl_data_type == KRB5_TL_CONSTRAINED_DELEGATION_ACL || ptr -> tl_data_type == KRB5_TL_LAST_ADMIN_UNLOCK ) continue ; if ( ( st = tl_data2berval ( ptr , & ber_tl_data [ j ] ) ) != 0 ) break ; j ++ ; } if ( st == 0 ) { ber_tl_data [ count ] = NULL ; st = krb5_add_ber_mem_ldap_mod ( & mods , \"krbExtraData\" , LDAP_MOD_REPLACE | LDAP_MOD_BVALUES , ber_tl_data ) ; } for ( j = 0 ; ber_tl_data [ j ] != NULL ; j ++ ) { free ( ber_tl_data [ j ] -> bv_val ) ; free ( ber_tl_data [ j ] ) ; } free ( ber_tl_data ) ; if ( st != 0 ) goto cleanup ; } if ( ( st = krb5_dbe_lookup_last_admin_unlock ( context , entry , & unlock_time ) ) != 0 ) goto cleanup ; if ( unlock_time != 0 ) { memset ( strval , 0 , sizeof ( strval ) ) ; if ( ( strval [ 0 ] = getstringtime ( unlock_time ) ) == NULL ) goto cleanup ; if ( ( st = krb5_add_str_mem_ldap_mod ( & mods , \"krbLastAdminUnlock\" , LDAP_MOD_REPLACE , strval ) ) != 0 ) { free ( strval [ 0 ] ) ; goto cleanup ; } free ( strval [ 0 ] ) ; } } if ( xargs . tktpolicydn != NULL ) { int tmask = 0 ; if ( strlen ( xargs . tktpolicydn ) != 0 ) { st = checkattributevalue ( ld , xargs . tktpolicydn , \"objectclass\" , policyclass , & tmask ) ; CHECK_CLASS_VALIDITY ( st , tmask , _ ( \"ticket<S2SV_blank>policy<S2SV_blank>object<S2SV_blank>value:<S2SV_blank>\" ) ) ; strval [ 0 ] = xargs . tktpolicydn ; strval [ 1 ] = NULL ; if ( ( st = krb5_add_str_mem_ldap_mod ( & mods , \"krbticketpolicyreference\" , LDAP_MOD_REPLACE , strval ) ) != 0 ) goto cleanup ; } else { if ( ( st = krb5_add_str_mem_ldap_mod ( & mods , \"krbticketpolicyreference\" , LDAP_MOD_DELETE , NULL ) ) != 0 ) goto cleanup ; } } if ( establish_links == TRUE ) { memset ( strval , 0 , sizeof ( strval ) ) ; strval [ 0 ] = xargs . linkdn ; if ( ( st = krb5_add_str_mem_ldap_mod ( & mods , \"krbObjectReferences\" , LDAP_MOD_REPLACE , strval ) ) != 0 ) goto cleanup ; } if ( mods == NULL ) goto cleanup ; if ( create_standalone_prinicipal == TRUE ) { memset ( strval , 0 , sizeof ( strval ) ) ; strval [ 0 ] = \"krbprincipal\" ; strval [ 1 ] = \"krbprincipalaux\" ; strval [ 2 ] = \"krbTicketPolicyAux\" ; if ( ( st = krb5_add_str_mem_ldap_mod ( & mods , \"objectclass\" , LDAP_MOD_ADD , strval ) ) != 0 ) goto cleanup ; st = ldap_add_ext_s ( ld , standalone_principal_dn , mods , NULL , NULL ) ; if ( st == LDAP_ALREADY_EXISTS && entry -> mask & KADM5_LOAD ) { st = ldap_delete_ext_s ( ld , standalone_principal_dn , NULL , NULL ) ; if ( st != LDAP_SUCCESS ) { snprintf ( errbuf , sizeof ( errbuf ) , _ ( \"Principal<S2SV_blank>delete<S2SV_blank>failed<S2SV_blank>(trying<S2SV_blank>to<S2SV_blank>replace<S2SV_blank>\" \"entry):<S2SV_blank>%s\" ) , ldap_err2string ( st ) ) ; st = translate_ldap_error ( st , OP_ADD ) ; k5_setmsg ( context , st , \"%s\" , errbuf ) ; goto cleanup ; } else { st = ldap_add_ext_s ( ld , standalone_principal_dn , mods , NULL , NULL ) ; } } if ( st != LDAP_SUCCESS ) { snprintf ( errbuf , sizeof ( errbuf ) , _ ( \"Principal<S2SV_blank>add<S2SV_blank>failed:<S2SV_blank>%s\" ) , ldap_err2string ( st ) ) ; st = translate_ldap_error ( st , OP_ADD ) ; k5_setmsg ( context , st , \"%s\" , errbuf ) ; goto cleanup ; } } else { { char * attrvalues [ ] = { \"krbprincipalaux\" , \"krbTicketPolicyAux\" , NULL } ; int p , q , r = 0 , amask = 0 ; if ( ( st = checkattributevalue ( ld , ( xargs . dn ) ? xargs . dn : principal_dn , \"objectclass\" , attrvalues , & amask ) ) != 0 ) goto cleanup ; memset ( strval , 0 , sizeof ( strval ) ) ; for ( p = 1 , q = 0 ; p <= 2 ; p <<= 1 , ++ q ) { if ( ( p & amask ) == 0 ) strval [ r ++ ] = attrvalues [ q ] ; } if ( r != 0 ) { if ( ( st = krb5_add_str_mem_ldap_mod ( & mods , \"objectclass\" , LDAP_MOD_ADD , strval ) ) != 0 ) goto cleanup ; } } if ( xargs . dn != NULL ) st = ldap_modify_ext_s ( ld , xargs . dn , mods , NULL , NULL ) ; else st = ldap_modify_ext_s ( ld , principal_dn , mods , NULL , NULL ) ; if ( st != LDAP_SUCCESS ) { snprintf ( errbuf , sizeof ( errbuf ) , _ ( \"User<S2SV_blank>modification<S2SV_blank>failed:<S2SV_blank>%s\" ) , ldap_err2string ( st ) ) ; st = translate_ldap_error ( st , OP_MOD ) ; k5_setmsg ( context , st , \"%s\" , errbuf ) ; goto cleanup ; } if ( entry -> mask & KADM5_FAIL_AUTH_COUNT_INCREMENT ) entry -> fail_auth_count ++ ; } cleanup : if ( user ) free ( user ) ; if ( filtuser ) free ( filtuser ) ; free_xargs ( xargs ) ; if ( standalone_principal_dn ) free ( standalone_principal_dn ) ; if ( principal_dn ) free ( principal_dn ) ; if ( polname != NULL ) free ( polname ) ; for ( tre = 0 ; tre < ntrees ; tre ++ ) free ( subtreelist [ tre ] ) ; free ( subtreelist ) ; if ( subtree ) free ( subtree ) ; if ( bersecretkey ) { for ( l = 0 ; bersecretkey [ l ] ; ++ l ) { if ( bersecretkey [ l ] -> bv_val ) free ( bersecretkey [ l ] -> bv_val ) ; free ( bersecretkey [ l ] ) ; } free ( bersecretkey ) ; } if ( keys ) free ( keys ) ; ldap_mods_free ( mods , 1 ) ; ldap_osa_free_princ_ent ( & princ_ent ) ; ldap_msgfree ( result ) ; krb5_ldap_put_handle_to_pool ( ldap_context , ldap_server_handle ) ; return ( st ) ; }\n","target":"<S2SV_ModStart> ; if ( bersecretkey == NULL ) { st = ENOMEM ; goto cleanup ; } if ( bersecretkey [ 0 ] != NULL || ! create_standalone_prinicipal ) { <S2SV_ModEnd> st = krb5_add_ber_mem_ldap_mod <S2SV_ModStart> , bersecretkey ) ; if ( st != 0 ) goto cleanup ; } <S2SV_ModEnd> if ( !\n","project_and_commit_id":"krb5@krb5/04038bf3633c4b909b5ded3072dc88c8c419bf16","cve_id":"CVE-2014-5354","original_address":"https://github.com/krb5/krb5/commit/04038bf3633c4b909b5ded3072dc88c8c419bf16","time":"2014-12-16T23:59Z"},
	{"Unnamed: 0":5765,"cwe_id":"CWE-119","source":"CWE-119 static struct se_portal_group * vhost_scsi_make_tpg ( struct se_wwn * wwn , struct config_group * group , const char * name ) { struct vhost_scsi_tport * tport = container_of ( wwn , struct vhost_scsi_tport , tport_wwn ) ; struct vhost_scsi_tpg * tpg ; <S2SV_StartBug> unsigned long tpgt ; <S2SV_EndBug> int ret ; if ( strstr ( name , \"tpgt_\" ) != name ) return ERR_PTR ( - EINVAL ) ; <S2SV_StartBug> if ( kstrtoul ( name + 5 , 10 , & tpgt ) || tpgt > UINT_MAX ) <S2SV_EndBug> return ERR_PTR ( - EINVAL ) ; tpg = kzalloc ( sizeof ( struct vhost_scsi_tpg ) , GFP_KERNEL ) ; if ( ! tpg ) { pr_err ( \"Unable<S2SV_blank>to<S2SV_blank>allocate<S2SV_blank>struct<S2SV_blank>vhost_scsi_tpg\" ) ; return ERR_PTR ( - ENOMEM ) ; } mutex_init ( & tpg -> tv_tpg_mutex ) ; INIT_LIST_HEAD ( & tpg -> tv_tpg_list ) ; tpg -> tport = tport ; tpg -> tport_tpgt = tpgt ; ret = core_tpg_register ( & vhost_scsi_fabric_configfs -> tf_ops , wwn , & tpg -> se_tpg , tpg , TRANSPORT_TPG_TYPE_NORMAL ) ; if ( ret < 0 ) { kfree ( tpg ) ; return NULL ; } mutex_lock ( & vhost_scsi_mutex ) ; list_add_tail ( & tpg -> tv_tpg_list , & vhost_scsi_list ) ; mutex_unlock ( & vhost_scsi_mutex ) ; return & tpg -> se_tpg ; }\n","target":"<S2SV_ModStart> * tpg ; u16 <S2SV_ModEnd> tpgt ; int <S2SV_ModStart> ; if ( kstrtou16 <S2SV_ModEnd> ( name + <S2SV_ModStart> ) || tpgt >= VHOST_SCSI_MAX_TARGET <S2SV_ModEnd> ) return ERR_PTR\n","project_and_commit_id":"torvalds@linux/59c816c1f24df0204e01851431d3bab3eb76719c","cve_id":"CVE-2015-4036","original_address":"https://github.com/torvalds/linux/commit/59c816c1f24df0204e01851431d3bab3eb76719c","time":"2015-08-31T20:59Z"},
	{"Unnamed: 0":3103,"cwe_id":"CWE-119","source":"CWE-119 <S2SV_StartBug> static void nonrd_pick_partition ( VP9_COMP * cpi , const TileInfo * const tile , <S2SV_EndBug> TOKENEXTRA * * tp , int mi_row , <S2SV_StartBug> int mi_col , BLOCK_SIZE bsize , int * rate , <S2SV_EndBug> <S2SV_StartBug> int64_t * dist , int do_recon , int64_t best_rd ) { <S2SV_EndBug> VP9_COMMON * const cm = & cpi -> common ; <S2SV_StartBug> MACROBLOCK * const x = & cpi -> mb ; <S2SV_EndBug> MACROBLOCKD * const xd = & x -> e_mbd ; const int ms = num_8x8_blocks_wide_lookup [ bsize ] / 2 ; TOKENEXTRA * tp_orig = * tp ; <S2SV_StartBug> PICK_MODE_CONTEXT * ctx = get_block_context ( x , bsize ) ; <S2SV_EndBug> int i ; <S2SV_StartBug> BLOCK_SIZE subsize ; <S2SV_EndBug> int this_rate , sum_rate = 0 , best_rate = INT_MAX ; int64_t this_dist , sum_dist = 0 , best_dist = INT64_MAX ; int64_t sum_rd = 0 ; int do_split = bsize >= BLOCK_8X8 ; int do_rect = 1 ; const int force_horz_split = ( mi_row + ms >= cm -> mi_rows ) ; const int force_vert_split = ( mi_col + ms >= cm -> mi_cols ) ; const int xss = x -> e_mbd . plane [ 1 ] . subsampling_x ; const int yss = x -> e_mbd . plane [ 1 ] . subsampling_y ; int partition_none_allowed = ! force_horz_split && ! force_vert_split ; int partition_horz_allowed = ! force_vert_split && yss <= xss && bsize >= BLOCK_8X8 ; int partition_vert_allowed = ! force_horz_split && xss <= yss && bsize >= BLOCK_8X8 ; ( void ) * tp_orig ; <S2SV_StartBug> if ( bsize < BLOCK_8X8 ) { <S2SV_EndBug> if ( x -> ab_index != 0 ) { * rate = 0 ; * dist = 0 ; return ; } } assert ( num_8x8_blocks_wide_lookup [ bsize ] == num_8x8_blocks_high_lookup [ bsize ] ) ; <S2SV_StartBug> x -> in_active_map = check_active_map ( cpi , x , mi_row , mi_col , bsize ) ; <S2SV_EndBug> if ( cpi -> sf . auto_min_max_partition_size ) { <S2SV_StartBug> partition_none_allowed &= ( bsize <= cpi -> sf . max_partition_size && <S2SV_EndBug> <S2SV_StartBug> bsize >= cpi -> sf . min_partition_size ) ; <S2SV_EndBug> <S2SV_StartBug> partition_horz_allowed &= ( ( bsize <= cpi -> sf . max_partition_size && <S2SV_EndBug> <S2SV_StartBug> bsize > cpi -> sf . min_partition_size ) || <S2SV_EndBug> force_horz_split ) ; <S2SV_StartBug> partition_vert_allowed &= ( ( bsize <= cpi -> sf . max_partition_size && <S2SV_EndBug> <S2SV_StartBug> bsize > cpi -> sf . min_partition_size ) || <S2SV_EndBug> force_vert_split ) ; <S2SV_StartBug> do_split &= bsize > cpi -> sf . min_partition_size ; <S2SV_EndBug> } if ( cpi -> sf . use_square_partition_only ) { partition_horz_allowed &= force_horz_split ; partition_vert_allowed &= force_vert_split ; } <S2SV_StartBug> if ( ! x -> in_active_map && ( partition_horz_allowed || partition_vert_allowed ) ) <S2SV_EndBug> do_split = 0 ; if ( partition_none_allowed ) { <S2SV_StartBug> nonrd_pick_sb_modes ( cpi , tile , mi_row , mi_col , <S2SV_EndBug> <S2SV_StartBug> & this_rate , & this_dist , bsize ) ; <S2SV_EndBug> ctx -> mic . mbmi = xd -> mi [ 0 ] -> mbmi ; <S2SV_StartBug> if ( this_rate != INT_MAX ) { <S2SV_EndBug> int pl = partition_plane_context ( xd , mi_row , mi_col , bsize ) ; <S2SV_StartBug> this_rate += x -> partition_cost [ pl ] [ PARTITION_NONE ] ; <S2SV_EndBug> <S2SV_StartBug> sum_rd = RDCOST ( x -> rdmult , x -> rddiv , this_rate , this_dist ) ; <S2SV_EndBug> if ( sum_rd < best_rd ) { <S2SV_StartBug> int64_t stop_thresh = 4096 ; <S2SV_EndBug> int64_t stop_thresh_rd ; best_rate = this_rate ; best_dist = this_dist ; best_rd = sum_rd ; if ( bsize >= BLOCK_8X8 ) * ( get_sb_partitioning ( x , bsize ) ) = bsize ; stop_thresh >>= 8 - ( b_width_log2_lookup [ bsize ] + b_height_log2_lookup [ bsize ] ) ; <S2SV_StartBug> stop_thresh_rd = RDCOST ( x -> rdmult , x -> rddiv , 0 , stop_thresh ) ; <S2SV_EndBug> <S2SV_StartBug> if ( ! x -> e_mbd . lossless && best_rd < stop_thresh_rd ) { <S2SV_EndBug> do_split = 0 ; do_rect = 0 ; } } } <S2SV_StartBug> if ( ! x -> in_active_map ) { <S2SV_EndBug> do_split = 0 ; do_rect = 0 ; } } store_pred_mv ( x , ctx ) ; sum_rd = 0 ; if ( do_split ) { int pl = partition_plane_context ( xd , mi_row , mi_col , bsize ) ; <S2SV_StartBug> sum_rate += x -> partition_cost [ pl ] [ PARTITION_SPLIT ] ; <S2SV_EndBug> subsize = get_subsize ( bsize , PARTITION_SPLIT ) ; <S2SV_StartBug> for ( i = 0 ; i < 4 && sum_rd < best_rd ; ++ i ) { <S2SV_EndBug> const int x_idx = ( i & 1 ) * ms ; const int y_idx = ( i >> 1 ) * ms ; if ( mi_row + y_idx >= cm -> mi_rows || mi_col + x_idx >= cm -> mi_cols ) continue ; <S2SV_StartBug> * get_sb_index ( x , subsize ) = i ; <S2SV_EndBug> load_pred_mv ( x , ctx ) ; <S2SV_StartBug> nonrd_pick_partition ( cpi , tile , tp , mi_row + y_idx , mi_col + x_idx , <S2SV_EndBug> <S2SV_StartBug> subsize , & this_rate , & this_dist , 0 , <S2SV_EndBug> best_rd - sum_rd ) ; if ( this_rate == INT_MAX ) { <S2SV_StartBug> sum_rd = INT64_MAX ; <S2SV_EndBug> } else { <S2SV_StartBug> sum_rate += this_rate ; <S2SV_EndBug> sum_dist += this_dist ; sum_rd = RDCOST ( x -> rdmult , x -> rddiv , sum_rate , sum_dist ) ; } } if ( sum_rd < best_rd ) { best_rate = sum_rate ; best_dist = sum_dist ; best_rd = sum_rd ; * ( get_sb_partitioning ( x , bsize ) ) = subsize ; } else { <S2SV_StartBug> if ( cpi -> sf . less_rectangular_check ) <S2SV_EndBug> do_rect &= ! partition_none_allowed ; } } if ( partition_horz_allowed && do_rect ) { subsize = get_subsize ( bsize , PARTITION_HORZ ) ; <S2SV_StartBug> * get_sb_index ( x , subsize ) = 0 ; <S2SV_EndBug> if ( cpi -> sf . adaptive_motion_search ) load_pred_mv ( x , ctx ) ; nonrd_pick_sb_modes ( cpi , tile , mi_row , mi_col , & this_rate , & this_dist , subsize ) ; get_block_context ( x , subsize ) -> mic . mbmi = xd -> mi [ 0 ] -> mbmi ; <S2SV_StartBug> sum_rd = RDCOST ( x -> rdmult , x -> rddiv , sum_rate , sum_dist ) ; <S2SV_EndBug> if ( sum_rd < best_rd && mi_row + ms < cm -> mi_rows ) { <S2SV_StartBug> * get_sb_index ( x , subsize ) = 1 ; <S2SV_EndBug> load_pred_mv ( x , ctx ) ; <S2SV_StartBug> nonrd_pick_sb_modes ( cpi , tile , mi_row + ms , mi_col , <S2SV_EndBug> <S2SV_StartBug> & this_rate , & this_dist , subsize ) ; <S2SV_EndBug> get_block_context ( x , subsize ) -> mic . mbmi = xd -> mi [ 0 ] -> mbmi ; <S2SV_StartBug> if ( this_rate == INT_MAX ) { <S2SV_EndBug> <S2SV_StartBug> sum_rd = INT64_MAX ; <S2SV_EndBug> } else { int pl = partition_plane_context ( xd , mi_row , mi_col , bsize ) ; <S2SV_StartBug> this_rate += x -> partition_cost [ pl ] [ PARTITION_HORZ ] ; <S2SV_EndBug> <S2SV_StartBug> sum_rate += this_rate ; <S2SV_EndBug> sum_dist += this_dist ; <S2SV_StartBug> sum_rd = RDCOST ( x -> rdmult , x -> rddiv , sum_rate , sum_dist ) ; <S2SV_EndBug> } } if ( sum_rd < best_rd ) { best_rd = sum_rd ; best_rate = sum_rate ; best_dist = sum_dist ; * ( get_sb_partitioning ( x , bsize ) ) = subsize ; } } if ( partition_vert_allowed && do_rect ) { subsize = get_subsize ( bsize , PARTITION_VERT ) ; <S2SV_StartBug> * get_sb_index ( x , subsize ) = 0 ; <S2SV_EndBug> if ( cpi -> sf . adaptive_motion_search ) load_pred_mv ( x , ctx ) ; nonrd_pick_sb_modes ( cpi , tile , mi_row , mi_col , & this_rate , & this_dist , subsize ) ; get_block_context ( x , subsize ) -> mic . mbmi = xd -> mi [ 0 ] -> mbmi ; <S2SV_StartBug> sum_rd = RDCOST ( x -> rdmult , x -> rddiv , sum_rate , sum_dist ) ; <S2SV_EndBug> if ( sum_rd < best_rd && mi_col + ms < cm -> mi_cols ) { <S2SV_StartBug> * get_sb_index ( x , subsize ) = 1 ; <S2SV_EndBug> load_pred_mv ( x , ctx ) ; <S2SV_StartBug> nonrd_pick_sb_modes ( cpi , tile , mi_row , mi_col + ms , <S2SV_EndBug> <S2SV_StartBug> & this_rate , & this_dist , subsize ) ; <S2SV_EndBug> get_block_context ( x , subsize ) -> mic . mbmi = xd -> mi [ 0 ] -> mbmi ; <S2SV_StartBug> if ( this_rate == INT_MAX ) { <S2SV_EndBug> <S2SV_StartBug> sum_rd = INT64_MAX ; <S2SV_EndBug> } else { int pl = partition_plane_context ( xd , mi_row , mi_col , bsize ) ; <S2SV_StartBug> this_rate += x -> partition_cost [ pl ] [ PARTITION_VERT ] ; <S2SV_EndBug> <S2SV_StartBug> sum_rate += this_rate ; <S2SV_EndBug> sum_dist += this_dist ; <S2SV_StartBug> sum_rd = RDCOST ( x -> rdmult , x -> rddiv , sum_rate , sum_dist ) ; <S2SV_EndBug> } } if ( sum_rd < best_rd ) { best_rate = sum_rate ; best_dist = sum_dist ; best_rd = sum_rd ; * ( get_sb_partitioning ( x , bsize ) ) = subsize ; } } * rate = best_rate ; * dist = best_dist ; <S2SV_StartBug> if ( best_rate == INT_MAX ) <S2SV_EndBug> return ; fill_mode_info_sb ( cm , x , mi_row , mi_col , bsize , <S2SV_StartBug> * ( get_sb_partitioning ( x , bsize ) ) ) ; <S2SV_EndBug> <S2SV_StartBug> if ( best_rate < INT_MAX && best_dist < INT64_MAX && do_recon ) { <S2SV_EndBug> int output_enabled = ( bsize == BLOCK_64X64 ) ; <S2SV_StartBug> if ( ( cpi -> oxcf . aq_mode == COMPLEXITY_AQ ) && cm -> seg . update_map ) { <S2SV_EndBug> vp9_select_in_frame_q_segment ( cpi , mi_row , mi_col , output_enabled , <S2SV_StartBug> best_rate ) ; <S2SV_EndBug> } if ( cpi -> oxcf . aq_mode == CYCLIC_REFRESH_AQ ) vp9_cyclic_refresh_set_rate_and_dist_sb ( cpi -> cyclic_refresh , best_rate , best_dist ) ; encode_sb_rt ( cpi , tile , tp , mi_row , mi_col , output_enabled , bsize ) ; } <S2SV_StartBug> if ( bsize == BLOCK_64X64 ) { <S2SV_EndBug> assert ( tp_orig < * tp ) ; <S2SV_StartBug> assert ( best_rate < INT_MAX ) ; <S2SV_EndBug> <S2SV_StartBug> assert ( best_dist < INT64_MAX ) ; <S2SV_EndBug> } else { assert ( tp_orig == * tp ) ; } }\n","target":"<S2SV_ModStart> * cpi , ThreadData * td , TileDataEnc * tile_data <S2SV_ModEnd> , TOKENEXTRA * <S2SV_ModStart> BLOCK_SIZE bsize , RD_COST * rd_cost , <S2SV_ModEnd> int do_recon , <S2SV_ModStart> , int64_t best_rd , PC_TREE * pc_tree ) { const SPEED_FEATURES * const sf = & cpi -> sf ; <S2SV_ModEnd> VP9_COMMON * const <S2SV_ModStart> -> common ; TileInfo * const tile_info = & tile_data -> tile_info ; <S2SV_ModStart> x = & td <S2SV_ModEnd> -> mb ; <S2SV_ModStart> * ctx = & pc_tree -> none <S2SV_ModEnd> ; int i <S2SV_ModStart> ; BLOCK_SIZE subsize = bsize ; RD_COST this_rdc , sum_rdc , best_rdc <S2SV_ModEnd> ; int do_split <S2SV_ModStart> * tp_orig ; <S2SV_ModEnd> assert ( num_8x8_blocks_wide_lookup <S2SV_ModStart> ] ) ; vp9_rd_cost_init ( & sum_rdc ) ; vp9_rd_cost_reset ( & best_rdc ) ; best_rdc . rdcost = best_rd ; if ( sf -> <S2SV_ModEnd> auto_min_max_partition_size ) { <S2SV_ModStart> ( bsize <= x -> <S2SV_ModEnd> max_partition_size && bsize <S2SV_ModStart> && bsize >= x -> <S2SV_ModEnd> min_partition_size ) ; <S2SV_ModStart> ( bsize <= x -> <S2SV_ModEnd> max_partition_size && bsize <S2SV_ModStart> && bsize > x -> <S2SV_ModEnd> min_partition_size ) || <S2SV_ModStart> ( bsize <= x -> <S2SV_ModEnd> max_partition_size && bsize <S2SV_ModStart> && bsize > x -> <S2SV_ModEnd> min_partition_size ) || <S2SV_ModStart> &= bsize > x -> min_partition_size ; } if ( sf -> <S2SV_ModEnd> use_square_partition_only ) { <S2SV_ModStart> force_vert_split ; } ctx -> pred_pixel_ready = ! ( partition_vert_allowed || partition_horz_allowed || do_split ) <S2SV_ModEnd> ; if ( <S2SV_ModStart> ( cpi , tile_data , x <S2SV_ModEnd> , mi_row , <S2SV_ModStart> mi_col , & this_rdc , bsize , ctx ) ; ctx <S2SV_ModEnd> -> mic . <S2SV_ModStart> -> mbmi ; ctx -> mbmi_ext = * x -> mbmi_ext ; ctx -> skip_txfm [ 0 ] = x -> skip_txfm [ 0 ] ; ctx -> skip = x -> skip ; if ( this_rdc . rate <S2SV_ModEnd> != INT_MAX ) <S2SV_ModStart> bsize ) ; this_rdc . rate += cpi <S2SV_ModEnd> -> partition_cost [ <S2SV_ModStart> PARTITION_NONE ] ; this_rdc . rdcost <S2SV_ModEnd> = RDCOST ( <S2SV_ModStart> -> rddiv , this_rdc . rate , this_rdc . dist ) ; if ( this_rdc . rdcost < best_rdc . rdcost <S2SV_ModEnd> ) { int64_t <S2SV_ModStart> ) { int64_t dist_breakout_thr = sf -> partition_search_breakout_dist_thr ; int64_t rate_breakout_thr = sf -> partition_search_breakout_rate_thr ; dist_breakout_thr <S2SV_ModEnd> >>= 8 - <S2SV_ModStart> ] ) ; rate_breakout_thr *= num_pels_log2_lookup [ bsize ] ; best_rdc = this_rdc ; if ( bsize >= BLOCK_8X8 ) pc_tree -> partitioning = PARTITION_NONE <S2SV_ModEnd> ; if ( <S2SV_ModStart> . lossless && this_rdc . rate < rate_breakout_thr && this_rdc . dist < dist_breakout_thr <S2SV_ModEnd> ) { do_split <S2SV_ModStart> } } } } store_pred_mv ( x , ctx ) ; if ( do_split <S2SV_ModEnd> ) { int <S2SV_ModStart> bsize ) ; sum_rdc . rate += cpi <S2SV_ModEnd> -> partition_cost [ <S2SV_ModStart> [ PARTITION_SPLIT ] ; sum_rdc . rdcost = RDCOST ( x -> rdmult , x -> rddiv , sum_rdc . rate , sum_rdc . dist ) <S2SV_ModStart> < 4 && sum_rdc . rdcost < best_rdc . rdcost <S2SV_ModEnd> ; ++ i <S2SV_ModStart> ) continue ; <S2SV_ModEnd> load_pred_mv ( x <S2SV_ModStart> ( cpi , td , tile_data <S2SV_ModEnd> , tp , <S2SV_ModStart> subsize , & this_rdc , 0 , best_rdc . rdcost - sum_rdc . rdcost , pc_tree -> split [ i ] ) ; if ( this_rdc . rate <S2SV_ModEnd> == INT_MAX ) <S2SV_ModStart> INT_MAX ) { vp9_rd_cost_reset ( & sum_rdc ) <S2SV_ModEnd> ; } else <S2SV_ModStart> } else { sum_rdc . rate += this_rdc . rate ; sum_rdc . dist += this_rdc . dist ; sum_rdc . rdcost += this_rdc . rdcost ; } } if ( sum_rdc . rdcost < best_rdc . rdcost ) { best_rdc = sum_rdc ; pc_tree -> partitioning = PARTITION_SPLIT <S2SV_ModEnd> ; } else <S2SV_ModStart> { if ( sf -> <S2SV_ModEnd> less_rectangular_check ) do_rect <S2SV_ModStart> PARTITION_HORZ ) ; if ( sf -> adaptive_motion_search ) load_pred_mv ( x , ctx ) ; pc_tree -> horizontal [ 0 ] . pred_pixel_ready = 1 ; nonrd_pick_sb_modes ( cpi , tile_data , x , mi_row , mi_col , & sum_rdc , subsize , & pc_tree -> horizontal [ 0 ] ) ; pc_tree -> horizontal [ 0 ] . <S2SV_ModEnd> mic . mbmi <S2SV_ModStart> -> mbmi ; pc_tree -> horizontal [ 0 ] . mbmi_ext = * x -> mbmi_ext ; pc_tree -> horizontal [ 0 ] . skip_txfm [ 0 ] = x -> skip_txfm [ 0 ] ; pc_tree -> horizontal [ 0 ] . skip = x -> skip ; if ( sum_rdc . rdcost < best_rdc . rdcost <S2SV_ModEnd> && mi_row + <S2SV_ModStart> mi_rows ) { <S2SV_ModEnd> load_pred_mv ( x <S2SV_ModStart> ctx ) ; pc_tree -> horizontal [ 1 ] . pred_pixel_ready = 1 ; <S2SV_ModStart> ( cpi , tile_data , x <S2SV_ModEnd> , mi_row + <S2SV_ModStart> mi_col , & this_rdc , subsize , & pc_tree -> horizontal [ 1 ] ) ; pc_tree -> horizontal [ 1 ] . <S2SV_ModEnd> mic . mbmi <S2SV_ModStart> -> mbmi ; pc_tree -> horizontal [ 1 ] . mbmi_ext = * x -> mbmi_ext ; pc_tree -> horizontal [ 1 ] . skip_txfm [ 0 ] = x -> skip_txfm [ 0 ] ; pc_tree -> horizontal [ 1 ] . skip = x -> skip ; if ( this_rdc . rate <S2SV_ModEnd> == INT_MAX ) <S2SV_ModStart> INT_MAX ) { vp9_rd_cost_reset ( & sum_rdc ) <S2SV_ModEnd> ; } else <S2SV_ModStart> bsize ) ; this_rdc . rate += cpi <S2SV_ModEnd> -> partition_cost [ <S2SV_ModStart> PARTITION_HORZ ] ; sum_rdc . rate += this_rdc . rate ; sum_rdc . dist += this_rdc . dist ; sum_rdc . rdcost <S2SV_ModEnd> = RDCOST ( <S2SV_ModStart> -> rddiv , sum_rdc . rate , sum_rdc . dist ) ; } } if ( sum_rdc . rdcost < best_rdc . rdcost ) { best_rdc = sum_rdc ; pc_tree -> partitioning = PARTITION_HORZ ; } else { pred_pixel_ready_reset ( pc_tree , bsize ) <S2SV_ModEnd> ; } } <S2SV_ModStart> PARTITION_VERT ) ; if ( sf -> adaptive_motion_search ) load_pred_mv ( x , ctx ) ; pc_tree -> vertical [ 0 ] . pred_pixel_ready = 1 ; nonrd_pick_sb_modes ( cpi , tile_data , x , mi_row , mi_col , & sum_rdc , subsize , & pc_tree -> vertical [ 0 ] ) ; pc_tree -> vertical [ 0 ] . <S2SV_ModEnd> mic . mbmi <S2SV_ModStart> -> mbmi ; pc_tree -> vertical [ 0 ] . mbmi_ext = * x -> mbmi_ext ; pc_tree -> vertical [ 0 ] . skip_txfm [ 0 ] = x -> skip_txfm [ 0 ] ; pc_tree -> vertical [ 0 ] . skip = x -> skip ; if ( sum_rdc . rdcost < best_rdc . rdcost <S2SV_ModEnd> && mi_col + <S2SV_ModStart> mi_cols ) { <S2SV_ModEnd> load_pred_mv ( x <S2SV_ModStart> ctx ) ; pc_tree -> vertical [ 1 ] . pred_pixel_ready = 1 ; <S2SV_ModStart> ( cpi , tile_data , x <S2SV_ModEnd> , mi_row , <S2SV_ModStart> ms , & this_rdc , subsize , & pc_tree -> vertical [ 1 ] ) ; pc_tree -> vertical [ 1 ] . <S2SV_ModEnd> mic . mbmi <S2SV_ModStart> -> mbmi ; pc_tree -> vertical [ 1 ] . mbmi_ext = * x -> mbmi_ext ; pc_tree -> vertical [ 1 ] . skip_txfm [ 0 ] = x -> skip_txfm [ 0 ] ; pc_tree -> vertical [ 1 ] . skip = x -> skip ; if ( this_rdc . rate <S2SV_ModEnd> == INT_MAX ) <S2SV_ModStart> INT_MAX ) { vp9_rd_cost_reset ( & sum_rdc ) <S2SV_ModEnd> ; } else <S2SV_ModStart> bsize ) ; sum_rdc . rate += cpi <S2SV_ModEnd> -> partition_cost [ <S2SV_ModStart> PARTITION_VERT ] ; sum_rdc . rate += this_rdc . rate ; sum_rdc . dist += this_rdc . dist ; sum_rdc . rdcost <S2SV_ModEnd> = RDCOST ( <S2SV_ModStart> -> rddiv , sum_rdc . rate , sum_rdc . dist ) ; } } if ( sum_rdc . rdcost < best_rdc . rdcost ) { best_rdc = sum_rdc ; pc_tree -> partitioning = PARTITION_VERT ; } else { pred_pixel_ready_reset ( pc_tree , bsize ) ; } } * rd_cost = best_rdc ; if ( best_rdc . rate <S2SV_ModEnd> == INT_MAX ) <S2SV_ModStart> == INT_MAX ) { vp9_rd_cost_reset ( rd_cost ) ; return ; } <S2SV_ModEnd> fill_mode_info_sb ( cm <S2SV_ModStart> , bsize , pc_tree ) ; if ( best_rdc . rate <S2SV_ModEnd> < INT_MAX && <S2SV_ModStart> < INT_MAX && best_rdc . dist <S2SV_ModEnd> < INT64_MAX && <S2SV_ModStart> BLOCK_64X64 ) ; encode_sb_rt ( cpi , td , tile_info , tp <S2SV_ModEnd> , mi_row , <S2SV_ModStart> , output_enabled , bsize , pc_tree <S2SV_ModEnd> ) ; } <S2SV_ModStart> bsize == BLOCK_64X64 && do_recon <S2SV_ModStart> ; assert ( best_rdc . rate <S2SV_ModEnd> < INT_MAX ) <S2SV_ModStart> ; assert ( best_rdc . dist <S2SV_ModEnd> < INT64_MAX )\n","project_and_commit_id":"external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426","cve_id":"CVE-2016-1621","original_address":"https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426","time":"2016-03-12T21:59Z"},
	{"Unnamed: 0":232,"cwe_id":"CWE-119","source":"CWE-119 static int filter_frame ( AVFilterLink * inlink , AVFrame * in ) { DelogoContext * s = inlink -> dst -> priv ; AVFilterLink * outlink = inlink -> dst -> outputs [ 0 ] ; const AVPixFmtDescriptor * desc = av_pix_fmt_desc_get ( inlink -> format ) ; AVFrame * out ; int hsub0 = desc -> log2_chroma_w ; int vsub0 = desc -> log2_chroma_h ; int direct = 0 ; int plane ; AVRational sar ; if ( av_frame_is_writable ( in ) ) { direct = 1 ; out = in ; } else { out = ff_get_video_buffer ( outlink , outlink -> w , outlink -> h ) ; if ( ! out ) { av_frame_free ( & in ) ; return AVERROR ( ENOMEM ) ; } av_frame_copy_props ( out , in ) ; } sar = in -> sample_aspect_ratio ; if ( ! sar . num ) sar . num = sar . den = 1 ; <S2SV_StartBug> for ( plane = 0 ; plane < 4 && in -> data [ plane ] ; plane ++ ) { <S2SV_EndBug> int hsub = plane == 1 || plane == 2 ? hsub0 : 0 ; int vsub = plane == 1 || plane == 2 ? vsub0 : 0 ; apply_delogo ( out -> data [ plane ] , out -> linesize [ plane ] , in -> data [ plane ] , in -> linesize [ plane ] , FF_CEIL_RSHIFT ( inlink -> w , hsub ) , FF_CEIL_RSHIFT ( inlink -> h , vsub ) , sar , s -> x >> hsub , s -> y >> vsub , FF_CEIL_RSHIFT ( s -> w + ( s -> x & ( ( 1 << hsub ) - 1 ) ) , hsub ) , FF_CEIL_RSHIFT ( s -> h + ( s -> y & ( ( 1 << vsub ) - 1 ) ) , vsub ) , s -> band >> FFMIN ( hsub , vsub ) , s -> show , direct ) ; } if ( ! direct ) av_frame_free ( & in ) ; return ff_filter_frame ( outlink , out ) ; }\n","target":"<S2SV_ModStart> in -> data [ plane ] && in -> linesize\n","project_and_commit_id":"FFmpeg@FFmpeg/e43a0a232dbf6d3c161823c2e07c52e76227a1bc","cve_id":"CVE-2013-4263","original_address":"https://github.com/FFmpeg/FFmpeg/commit/e43a0a232dbf6d3c161823c2e07c52e76227a1bc","time":"2013-11-23T17:55Z"},
	{"Unnamed: 0":4841,"cwe_id":"CWE-125","source":"CWE-125 static UINT drive_process_irp_write ( DRIVE_DEVICE * drive , IRP * irp ) { DRIVE_FILE * file ; UINT32 Length ; UINT64 Offset ; <S2SV_StartBug> if ( ! drive || ! irp || ! irp -> input || ! irp -> output || ! irp -> Complete ) <S2SV_EndBug> return ERROR_INVALID_PARAMETER ; if ( Stream_GetRemainingLength ( irp -> input ) < 32 ) return ERROR_INVALID_DATA ; Stream_Read_UINT32 ( irp -> input , Length ) ; Stream_Read_UINT64 ( irp -> input , Offset ) ; Stream_Seek ( irp -> input , 20 ) ; <S2SV_StartBug> file = drive_get_file_by_id ( drive , irp -> FileId ) ; <S2SV_EndBug> if ( ! file ) { irp -> IoStatus = STATUS_UNSUCCESSFUL ; Length = 0 ; } else if ( ! drive_file_seek ( file , Offset ) ) { irp -> IoStatus = drive_map_windows_err ( GetLastError ( ) ) ; Length = 0 ; } <S2SV_StartBug> else if ( ! drive_file_write ( file , Stream_Pointer ( irp -> input ) , Length ) ) <S2SV_EndBug> { irp -> IoStatus = drive_map_windows_err ( GetLastError ( ) ) ; Length = 0 ; } Stream_Write_UINT32 ( irp -> output , Length ) ; Stream_Write_UINT8 ( irp -> output , 0 ) ; return irp -> Complete ( irp ) ; }\n","target":"<S2SV_ModStart> UINT64 Offset ; void * ptr ; <S2SV_ModStart> 20 ) ; ptr = Stream_Pointer ( irp -> input ) ; if ( ! Stream_SafeSeek ( irp -> input , Length ) ) return ERROR_INVALID_DATA ; <S2SV_ModStart> ( file , ptr <S2SV_ModEnd> , Length )\n","project_and_commit_id":"FreeRDP@FreeRDP/6b485b146a1b9d6ce72dfd7b5f36456c166e7a16","cve_id":"CVE-2020-11089","original_address":"https://github.com/FreeRDP/FreeRDP/commit/6b485b146a1b9d6ce72dfd7b5f36456c166e7a16","time":"2020-05-29T20:15Z"},
	{"Unnamed: 0":4050,"cwe_id":"CWE-190","source":"CWE-190 static int jpc_dec_process_siz ( jpc_dec_t * dec , jpc_ms_t * ms ) { jpc_siz_t * siz = & ms -> parms . siz ; int compno ; int tileno ; jpc_dec_tile_t * tile ; jpc_dec_tcomp_t * tcomp ; int htileno ; int vtileno ; jpc_dec_cmpt_t * cmpt ; <S2SV_StartBug> dec -> xstart = siz -> xoff ; <S2SV_EndBug> dec -> ystart = siz -> yoff ; dec -> xend = siz -> width ; dec -> yend = siz -> height ; dec -> tilewidth = siz -> tilewidth ; dec -> tileheight = siz -> tileheight ; dec -> tilexoff = siz -> tilexoff ; dec -> tileyoff = siz -> tileyoff ; dec -> numcomps = siz -> numcomps ; if ( ! ( dec -> cp = jpc_dec_cp_create ( dec -> numcomps ) ) ) { return - 1 ; } if ( ! ( dec -> cmpts = jas_alloc2 ( dec -> numcomps , sizeof ( jpc_dec_cmpt_t ) ) ) ) { return - 1 ; } for ( compno = 0 , cmpt = dec -> cmpts ; compno < dec -> numcomps ; ++ compno , ++ cmpt ) { cmpt -> prec = siz -> comps [ compno ] . prec ; cmpt -> sgnd = siz -> comps [ compno ] . sgnd ; cmpt -> hstep = siz -> comps [ compno ] . hsamp ; cmpt -> vstep = siz -> comps [ compno ] . vsamp ; cmpt -> width = JPC_CEILDIV ( dec -> xend , cmpt -> hstep ) - JPC_CEILDIV ( dec -> xstart , cmpt -> hstep ) ; cmpt -> height = JPC_CEILDIV ( dec -> yend , cmpt -> vstep ) - JPC_CEILDIV ( dec -> ystart , cmpt -> vstep ) ; cmpt -> hsubstep = 0 ; cmpt -> vsubstep = 0 ; } dec -> image = 0 ; dec -> numhtiles = JPC_CEILDIV ( dec -> xend - dec -> tilexoff , dec -> tilewidth ) ; dec -> numvtiles = JPC_CEILDIV ( dec -> yend - dec -> tileyoff , dec -> tileheight ) ; <S2SV_StartBug> dec -> numtiles = dec -> numhtiles * dec -> numvtiles ; <S2SV_EndBug> JAS_DBGLOG ( 10 , ( \"numtiles<S2SV_blank>=<S2SV_blank>%d;<S2SV_blank>numhtiles<S2SV_blank>=<S2SV_blank>%d;<S2SV_blank>numvtiles<S2SV_blank>=<S2SV_blank>%d;\\\\n\" , dec -> numtiles , dec -> numhtiles , dec -> numvtiles ) ) ; if ( ! ( dec -> tiles = jas_alloc2 ( dec -> numtiles , sizeof ( jpc_dec_tile_t ) ) ) ) { return - 1 ; } <S2SV_StartBug> for ( tileno = 0 , tile = dec -> tiles ; tileno < dec -> numtiles ; ++ tileno , <S2SV_EndBug> ++ tile ) { htileno = tileno % dec -> numhtiles ; vtileno = tileno / dec -> numhtiles ; tile -> realmode = 0 ; tile -> state = JPC_TILE_INIT ; tile -> xstart = JAS_MAX ( dec -> tilexoff + htileno * dec -> tilewidth , dec -> xstart ) ; tile -> ystart = JAS_MAX ( dec -> tileyoff + vtileno * dec -> tileheight , dec -> ystart ) ; tile -> xend = JAS_MIN ( dec -> tilexoff + ( htileno + 1 ) * dec -> tilewidth , dec -> xend ) ; tile -> yend = JAS_MIN ( dec -> tileyoff + ( vtileno + 1 ) * dec -> tileheight , dec -> yend ) ; tile -> numparts = 0 ; tile -> partno = 0 ; tile -> pkthdrstream = 0 ; tile -> pkthdrstreampos = 0 ; tile -> pptstab = 0 ; tile -> cp = 0 ; tile -> pi = 0 ; if ( ! ( tile -> tcomps = jas_alloc2 ( dec -> numcomps , sizeof ( jpc_dec_tcomp_t ) ) ) ) { return - 1 ; } for ( compno = 0 , cmpt = dec -> cmpts , tcomp = tile -> tcomps ; compno < dec -> numcomps ; ++ compno , ++ cmpt , ++ tcomp ) { tcomp -> rlvls = 0 ; tcomp -> numrlvls = 0 ; tcomp -> data = 0 ; tcomp -> xstart = JPC_CEILDIV ( tile -> xstart , cmpt -> hstep ) ; tcomp -> ystart = JPC_CEILDIV ( tile -> ystart , cmpt -> vstep ) ; tcomp -> xend = JPC_CEILDIV ( tile -> xend , cmpt -> hstep ) ; tcomp -> yend = JPC_CEILDIV ( tile -> yend , cmpt -> vstep ) ; tcomp -> tsfb = 0 ; } } dec -> pkthdrstreams = 0 ; dec -> state = JPC_MH ; return 0 ; }\n","target":"<S2SV_ModStart> * cmpt ; size_t size ; <S2SV_ModStart> tileheight ) ; if ( ! jas_safe_size_mul ( <S2SV_ModEnd> dec -> numhtiles <S2SV_ModStart> dec -> numhtiles , <S2SV_ModEnd> dec -> numvtiles <S2SV_ModStart> dec -> numvtiles , & size <S2SV_ModEnd> ) ) { <S2SV_ModStart> 1 ; } dec -> numtiles = size ; JAS_DBGLOG ( 10 , ( \"numtiles<S2SV_blank>=<S2SV_blank>%d;<S2SV_blank>numhtiles<S2SV_blank>=<S2SV_blank>%d;<S2SV_blank>numvtiles<S2SV_blank>=<S2SV_blank>%d;\\\\n\" , dec -> numtiles , dec -> numhtiles , dec -> numvtiles ) ) ; if ( ! ( dec -> tiles = jas_alloc2 ( dec -> numtiles , sizeof ( jpc_dec_tile_t ) ) ) ) { return - 1 ; }\n","project_and_commit_id":"mdadams@jasper/d91198abd00fc435a397fe6bad906a4c1748e9cf","cve_id":"CVE-2016-9387","original_address":"https://github.com/mdadams/jasper/commit/d91198abd00fc435a397fe6bad906a4c1748e9cf","time":"2017-03-23T18:59Z"},
	{"Unnamed: 0":1310,"cwe_id":"CWE-20","source":"CWE-20 long do_shmat ( int shmid , char __user * shmaddr , int shmflg , ulong * raddr , unsigned long shmlba ) { struct shmid_kernel * shp ; unsigned long addr ; unsigned long size ; struct file * file ; int err ; unsigned long flags ; unsigned long prot ; int acc_mode ; struct ipc_namespace * ns ; struct shm_file_data * sfd ; struct path path ; fmode_t f_mode ; unsigned long populate = 0 ; err = - EINVAL ; if ( shmid < 0 ) goto out ; else if ( ( addr = ( ulong ) shmaddr ) ) { if ( addr & ( shmlba - 1 ) ) { <S2SV_StartBug> if ( shmflg & SHM_RND ) <S2SV_EndBug> addr &= ~ ( shmlba - 1 ) ; else # ifndef __ARCH_FORCE_SHMLBA if ( addr & ~ PAGE_MASK ) # endif goto out ; } flags = MAP_SHARED | MAP_FIXED ; } else { if ( ( shmflg & SHM_REMAP ) ) goto out ; flags = MAP_SHARED ; } if ( shmflg & SHM_RDONLY ) { prot = PROT_READ ; acc_mode = S_IRUGO ; f_mode = FMODE_READ ; } else { prot = PROT_READ | PROT_WRITE ; acc_mode = S_IRUGO | S_IWUGO ; f_mode = FMODE_READ | FMODE_WRITE ; } if ( shmflg & SHM_EXEC ) { prot |= PROT_EXEC ; acc_mode |= S_IXUGO ; } ns = current -> nsproxy -> ipc_ns ; rcu_read_lock ( ) ; shp = shm_obtain_object_check ( ns , shmid ) ; if ( IS_ERR ( shp ) ) { err = PTR_ERR ( shp ) ; goto out_unlock ; } err = - EACCES ; if ( ipcperms ( ns , & shp -> shm_perm , acc_mode ) ) goto out_unlock ; err = security_shm_shmat ( shp , shmaddr , shmflg ) ; if ( err ) goto out_unlock ; ipc_lock_object ( & shp -> shm_perm ) ; if ( ! ipc_valid_object ( & shp -> shm_perm ) ) { ipc_unlock_object ( & shp -> shm_perm ) ; err = - EIDRM ; goto out_unlock ; } path = shp -> shm_file -> f_path ; path_get ( & path ) ; shp -> shm_nattch ++ ; size = i_size_read ( d_inode ( path . dentry ) ) ; ipc_unlock_object ( & shp -> shm_perm ) ; rcu_read_unlock ( ) ; err = - ENOMEM ; sfd = kzalloc ( sizeof ( * sfd ) , GFP_KERNEL ) ; if ( ! sfd ) { path_put ( & path ) ; goto out_nattch ; } file = alloc_file ( & path , f_mode , is_file_hugepages ( shp -> shm_file ) ? & shm_file_operations_huge : & shm_file_operations ) ; err = PTR_ERR ( file ) ; if ( IS_ERR ( file ) ) { kfree ( sfd ) ; path_put ( & path ) ; goto out_nattch ; } file -> private_data = sfd ; file -> f_mapping = shp -> shm_file -> f_mapping ; sfd -> id = shp -> shm_perm . id ; sfd -> ns = get_ipc_ns ( ns ) ; sfd -> file = shp -> shm_file ; sfd -> vm_ops = NULL ; err = security_mmap_file ( file , prot , flags ) ; if ( err ) goto out_fput ; if ( down_write_killable ( & current -> mm -> mmap_sem ) ) { err = - EINTR ; goto out_fput ; } if ( addr && ! ( shmflg & SHM_REMAP ) ) { err = - EINVAL ; if ( addr + size < addr ) goto invalid ; if ( find_vma_intersection ( current -> mm , addr , addr + size ) ) goto invalid ; } addr = do_mmap_pgoff ( file , addr , size , prot , flags , 0 , & populate , NULL ) ; * raddr = addr ; err = 0 ; if ( IS_ERR_VALUE ( addr ) ) err = ( long ) addr ; invalid : up_write ( & current -> mm -> mmap_sem ) ; if ( populate ) mm_populate ( addr , populate ) ; out_fput : fput ( file ) ; out_nattch : down_write ( & shm_ids ( ns ) . rwsem ) ; shp = shm_lock ( ns , shmid ) ; shp -> shm_nattch -- ; if ( shm_may_destroy ( ns , shp ) ) shm_destroy ( ns , shp ) ; else shm_unlock ( shp ) ; up_write ( & shm_ids ( ns ) . rwsem ) ; return err ; out_unlock : rcu_read_unlock ( ) ; out : return err ; }\n","target":"<S2SV_ModStart> { if ( ( <S2SV_ModStart> shmflg & SHM_RND ) && addr >= shmlba\n","project_and_commit_id":"torvalds@linux/e1d35d4dc7f089e6c9c080d556feedf9c706f0c7","cve_id":"CVE-2017-5669","original_address":"https://github.com/torvalds/linux/commit/e1d35d4dc7f089e6c9c080d556feedf9c706f0c7","time":"2017-02-24T15:59Z"},
	{"Unnamed: 0":4040,"cwe_id":"CWE-399","source":"CWE-399 static void update_exception_bitmap ( struct kvm_vcpu * vcpu ) { u32 eb ; eb = ( 1u << PF_VECTOR ) | ( 1u << UD_VECTOR ) | ( 1u << MC_VECTOR ) | <S2SV_StartBug> ( 1u << NM_VECTOR ) | ( 1u << DB_VECTOR ) ; <S2SV_EndBug> if ( ( vcpu -> guest_debug & ( KVM_GUESTDBG_ENABLE | KVM_GUESTDBG_USE_SW_BP ) ) == ( KVM_GUESTDBG_ENABLE | KVM_GUESTDBG_USE_SW_BP ) ) eb |= 1u << BP_VECTOR ; if ( to_vmx ( vcpu ) -> rmode . vm86_active ) eb = ~ 0 ; if ( enable_ept ) eb &= ~ ( 1u << PF_VECTOR ) ; if ( vcpu -> fpu_active ) eb &= ~ ( 1u << NM_VECTOR ) ; if ( is_guest_mode ( vcpu ) ) eb |= get_vmcs12 ( vcpu ) -> exception_bitmap ; vmcs_write32 ( EXCEPTION_BITMAP , eb ) ; }\n","target":"<S2SV_ModStart> 1u << DB_VECTOR ) | ( 1u << AC_VECTOR\n","project_and_commit_id":"torvalds@linux/54a20552e1eae07aa240fa370a0293e006b5faed","cve_id":"CVE-2015-5307","original_address":"https://github.com/torvalds/linux/commit/54a20552e1eae07aa240fa370a0293e006b5faed","time":"2015-11-16T11:59Z"},
	{"Unnamed: 0":5987,"cwe_id":"CWE-399","source":"CWE-399 int __kvm_set_memory_region ( struct kvm * kvm , struct kvm_userspace_memory_region * mem , int user_alloc ) { int r ; gfn_t base_gfn ; unsigned long npages ; struct kvm_memory_slot * memslot , * slot ; struct kvm_memory_slot old , new ; struct kvm_memslots * slots , * old_memslots ; r = check_memory_region_flags ( mem ) ; if ( r ) goto out ; r = - EINVAL ; if ( mem -> memory_size & ( PAGE_SIZE - 1 ) ) goto out ; if ( mem -> guest_phys_addr & ( PAGE_SIZE - 1 ) ) goto out ; if ( user_alloc && ( ( mem -> userspace_addr & ( PAGE_SIZE - 1 ) ) || ! access_ok ( VERIFY_WRITE , ( void __user * ) ( unsigned long ) mem -> userspace_addr , mem -> memory_size ) ) ) goto out ; if ( mem -> slot >= KVM_MEM_SLOTS_NUM ) goto out ; if ( mem -> guest_phys_addr + mem -> memory_size < mem -> guest_phys_addr ) goto out ; memslot = id_to_memslot ( kvm -> memslots , mem -> slot ) ; base_gfn = mem -> guest_phys_addr >> PAGE_SHIFT ; npages = mem -> memory_size >> PAGE_SHIFT ; r = - EINVAL ; if ( npages > KVM_MEM_MAX_NR_PAGES ) goto out ; if ( ! npages ) mem -> flags &= ~ KVM_MEM_LOG_DIRTY_PAGES ; new = old = * memslot ; new . id = mem -> slot ; new . base_gfn = base_gfn ; new . npages = npages ; new . flags = mem -> flags ; r = - EINVAL ; if ( npages && old . npages && npages != old . npages ) goto out_free ; if ( ! npages && ! old . npages ) goto out_free ; r = - EEXIST ; kvm_for_each_memslot ( slot , kvm -> memslots ) { if ( slot -> id >= KVM_MEMORY_SLOTS || slot == memslot ) continue ; if ( ! ( ( base_gfn + npages <= slot -> base_gfn ) || ( base_gfn >= slot -> base_gfn + slot -> npages ) ) ) goto out_free ; } if ( ! ( new . flags & KVM_MEM_LOG_DIRTY_PAGES ) ) new . dirty_bitmap = NULL ; r = - ENOMEM ; if ( ! old . npages ) { new . user_alloc = user_alloc ; new . userspace_addr = mem -> userspace_addr ; if ( kvm_arch_create_memslot ( & new , npages ) ) goto out_free ; } else if ( npages && mem -> userspace_addr != old . userspace_addr ) { r = - EINVAL ; goto out_free ; } if ( ( new . flags & KVM_MEM_LOG_DIRTY_PAGES ) && ! new . dirty_bitmap ) { if ( kvm_create_dirty_bitmap ( & new ) < 0 ) goto out_free ; } if ( ! npages || base_gfn != old . base_gfn ) { struct kvm_memory_slot * slot ; r = - ENOMEM ; slots = kmemdup ( kvm -> memslots , sizeof ( struct kvm_memslots ) , GFP_KERNEL ) ; if ( ! slots ) goto out_free ; slot = id_to_memslot ( slots , mem -> slot ) ; slot -> flags |= KVM_MEMSLOT_INVALID ; update_memslots ( slots , NULL ) ; old_memslots = kvm -> memslots ; rcu_assign_pointer ( kvm -> memslots , slots ) ; synchronize_srcu_expedited ( & kvm -> srcu ) ; <S2SV_StartBug> kvm_arch_flush_shadow_memslot ( kvm , slot ) ; <S2SV_EndBug> kfree ( old_memslots ) ; } r = kvm_arch_prepare_memory_region ( kvm , & new , old , mem , user_alloc ) ; if ( r ) <S2SV_StartBug> goto out_free ; <S2SV_EndBug> if ( npages ) { r = kvm_iommu_map_pages ( kvm , & new ) ; if ( r ) goto out_free ; } else kvm_iommu_unmap_pages ( kvm , & old ) ; r = - ENOMEM ; slots = kmemdup ( kvm -> memslots , sizeof ( struct kvm_memslots ) , GFP_KERNEL ) ; if ( ! slots ) goto out_free ; <S2SV_StartBug> if ( ! npages ) { <S2SV_EndBug> new . dirty_bitmap = NULL ; memset ( & new . arch , 0 , sizeof ( new . arch ) ) ; } update_memslots ( slots , & new ) ; old_memslots = kvm -> memslots ; rcu_assign_pointer ( kvm -> memslots , slots ) ; synchronize_srcu_expedited ( & kvm -> srcu ) ; kvm_arch_commit_memory_region ( kvm , mem , old , user_alloc ) ; kvm_free_physmem_slot ( & old , & new ) ; kfree ( old_memslots ) ; return 0 ; <S2SV_StartBug> out_free : <S2SV_EndBug> kvm_free_physmem_slot ( & new , & old ) ; out : return r ; }\n","target":"<S2SV_ModStart> srcu ) ; kvm_iommu_unmap_pages ( kvm , & old ) ; <S2SV_ModStart> ) goto out_free <S2SV_ModEnd> ; r = <S2SV_ModStart> ; if ( npages ) { r = kvm_iommu_map_pages ( kvm , & new ) ; if ( r ) goto out_slots ; } if ( <S2SV_ModStart> return 0 ; out_slots : kfree ( slots ) ;\n","project_and_commit_id":"torvalds@linux/e40f193f5bb022e927a57a4f5d5194e4f12ddb74","cve_id":"CVE-2013-4592","original_address":"https://github.com/torvalds/linux/commit/e40f193f5bb022e927a57a4f5d5194e4f12ddb74","time":"2013-11-20T13:19Z"},
	{"Unnamed: 0":6082,"cwe_id":"CWE-362","source":"CWE-362 <S2SV_StartBug> static struct desc_struct * get_desc ( unsigned short sel ) <S2SV_EndBug> { struct desc_ptr gdt_desc = { 0 , 0 } ; unsigned long desc_base ; # ifdef CONFIG_MODIFY_LDT_SYSCALL if ( ( sel & SEGMENT_TI_MASK ) == SEGMENT_LDT ) { <S2SV_StartBug> struct desc_struct * desc = NULL ; <S2SV_EndBug> struct ldt_struct * ldt ; sel >>= 3 ; mutex_lock ( & current -> active_mm -> context . lock ) ; ldt = current -> active_mm -> context . ldt ; <S2SV_StartBug> if ( ldt && sel < ldt -> nr_entries ) <S2SV_EndBug> <S2SV_StartBug> desc = & ldt -> entries [ sel ] ; <S2SV_EndBug> mutex_unlock ( & current -> active_mm -> context . lock ) ; <S2SV_StartBug> return desc ; <S2SV_EndBug> } # endif native_store_gdt ( & gdt_desc ) ; desc_base = sel & ~ ( SEGMENT_RPL_MASK | SEGMENT_TI_MASK ) ; if ( desc_base > gdt_desc . size ) <S2SV_StartBug> return NULL ; <S2SV_EndBug> return ( struct desc_struct * ) ( gdt_desc . address + desc_base ) ; <S2SV_StartBug> } <S2SV_EndBug>\n","target":"<S2SV_ModStart> <S2SV_null> <S2SV_null> static bool get_desc ( <S2SV_ModStart> struct desc_struct * out , <S2SV_ModEnd> unsigned short sel <S2SV_ModStart> SEGMENT_LDT ) { bool success = false <S2SV_ModEnd> ; struct ldt_struct <S2SV_ModStart> -> nr_entries ) { * out = <S2SV_ModEnd> ldt -> entries <S2SV_ModStart> sel ] ; success = true ; } <S2SV_ModStart> ) ; return success <S2SV_ModEnd> ; } # <S2SV_ModStart> size ) return false ; * out = * <S2SV_ModEnd> ( struct desc_struct <S2SV_ModStart> desc_base ) ; return true ;\n","project_and_commit_id":"torvalds@linux/de9f869616dd95e95c00bdd6b0fcd3421e8a4323","cve_id":"CVE-2019-13233","original_address":"https://github.com/torvalds/linux/commit/de9f869616dd95e95c00bdd6b0fcd3421e8a4323","time":"2019-07-04T13:15Z"},
	{"Unnamed: 0":3771,"cwe_id":"CWE-119","source":"CWE-119 int psf_binheader_readf ( SF_PRIVATE * psf , char const * format , ... ) { va_list argptr ; sf_count_t * countptr , countdata ; unsigned char * ucptr , sixteen_bytes [ 16 ] ; unsigned int * intptr , intdata ; unsigned short * shortptr ; char * charptr ; float * floatptr ; double * doubleptr ; char c ; <S2SV_StartBug> int byte_count = 0 , count ; <S2SV_EndBug> if ( ! format ) return psf_ftell ( psf ) ; va_start ( argptr , format ) ; while ( ( c = * format ++ ) ) <S2SV_StartBug> { switch ( c ) <S2SV_EndBug> { case 'e' : psf -> rwf_endian = SF_ENDIAN_LITTLE ; break ; case 'E' : psf -> rwf_endian = SF_ENDIAN_BIG ; break ; case 'm' : intptr = va_arg ( argptr , unsigned int * ) ; <S2SV_StartBug> ucptr = ( unsigned char * ) intptr ; <S2SV_EndBug> byte_count += header_read ( psf , ucptr , sizeof ( int ) ) ; * intptr = GET_MARKER ( ucptr ) ; break ; case 'h' : <S2SV_StartBug> intptr = va_arg ( argptr , unsigned int * ) ; <S2SV_EndBug> ucptr = ( unsigned char * ) intptr ; byte_count += header_read ( psf , sixteen_bytes , sizeof ( sixteen_bytes ) ) ; { int k ; intdata = 0 ; for ( k = 0 ; k < 16 ; k ++ ) intdata ^= sixteen_bytes [ k ] << k ; } * intptr = intdata ; break ; case '1' : charptr = va_arg ( argptr , char * ) ; * charptr = 0 ; byte_count += header_read ( psf , charptr , sizeof ( char ) ) ; break ; case '2' : shortptr = va_arg ( argptr , unsigned short * ) ; * shortptr = 0 ; ucptr = ( unsigned char * ) shortptr ; byte_count += header_read ( psf , ucptr , sizeof ( short ) ) ; if ( psf -> rwf_endian == SF_ENDIAN_BIG ) * shortptr = GET_BE_SHORT ( ucptr ) ; else * shortptr = GET_LE_SHORT ( ucptr ) ; break ; case '3' : intptr = va_arg ( argptr , unsigned int * ) ; * intptr = 0 ; byte_count += header_read ( psf , sixteen_bytes , 3 ) ; if ( psf -> rwf_endian == SF_ENDIAN_BIG ) * intptr = GET_BE_3BYTE ( sixteen_bytes ) ; else * intptr = GET_LE_3BYTE ( sixteen_bytes ) ; break ; case '4' : intptr = va_arg ( argptr , unsigned int * ) ; * intptr = 0 ; ucptr = ( unsigned char * ) intptr ; byte_count += header_read ( psf , ucptr , sizeof ( int ) ) ; if ( psf -> rwf_endian == SF_ENDIAN_BIG ) * intptr = psf_get_be32 ( ucptr , 0 ) ; else * intptr = psf_get_le32 ( ucptr , 0 ) ; break ; case '8' : countptr = va_arg ( argptr , sf_count_t * ) ; * countptr = 0 ; byte_count += header_read ( psf , sixteen_bytes , 8 ) ; if ( psf -> rwf_endian == SF_ENDIAN_BIG ) countdata = psf_get_be64 ( sixteen_bytes , 0 ) ; else countdata = psf_get_le64 ( sixteen_bytes , 0 ) ; * countptr = countdata ; break ; case 'f' : floatptr = va_arg ( argptr , float * ) ; * floatptr = 0.0 ; byte_count += header_read ( psf , floatptr , sizeof ( float ) ) ; if ( psf -> rwf_endian == SF_ENDIAN_BIG ) * floatptr = float32_be_read ( ( unsigned char * ) floatptr ) ; else * floatptr = float32_le_read ( ( unsigned char * ) floatptr ) ; break ; case 'd' : doubleptr = va_arg ( argptr , double * ) ; * doubleptr = 0.0 ; byte_count += header_read ( psf , doubleptr , sizeof ( double ) ) ; if ( psf -> rwf_endian == SF_ENDIAN_BIG ) * doubleptr = double64_be_read ( ( unsigned char * ) doubleptr ) ; else * doubleptr = double64_le_read ( ( unsigned char * ) doubleptr ) ; break ; case 's' : psf_log_printf ( psf , \"Format<S2SV_blank>conversion<S2SV_blank>\\'s\\'<S2SV_blank>not<S2SV_blank>implemented<S2SV_blank>yet.\\\\n\" ) ; break ; case 'b' : charptr = va_arg ( argptr , char * ) ; count = va_arg ( argptr , size_t ) ; <S2SV_StartBug> if ( count > 0 ) <S2SV_EndBug> byte_count += header_read ( psf , charptr , count ) ; break ; <S2SV_StartBug> case 'G' : <S2SV_EndBug> charptr = va_arg ( argptr , char * ) ; count = va_arg ( argptr , size_t ) ; <S2SV_StartBug> if ( count > 0 ) <S2SV_EndBug> byte_count += header_gets ( psf , charptr , count ) ; break ; case 'z' : psf_log_printf ( psf , \"Format<S2SV_blank>conversion<S2SV_blank>\\'z\\'<S2SV_blank>not<S2SV_blank>implemented<S2SV_blank>yet.\\\\n\" ) ; break ; case 'p' : count = va_arg ( argptr , size_t ) ; <S2SV_StartBug> header_seek ( psf , count , SEEK_SET ) ; <S2SV_EndBug> byte_count = count ; break ; case 'j' : count = va_arg ( argptr , size_t ) ; if ( count ) { header_seek ( psf , count , SEEK_CUR ) ; <S2SV_StartBug> byte_count += count ; <S2SV_EndBug> } ; break ; default : psf_log_printf ( psf , \"***<S2SV_blank>Invalid<S2SV_blank>format<S2SV_blank>specifier<S2SV_blank>`%c\\'\\\\n\" , c ) ; psf -> error = SFE_INTERNAL ; break ; } ; } ; va_end ( argptr ) ; return byte_count ; }\n","target":"<S2SV_ModStart> 0 , count = 0 <S2SV_ModStart> ) ) { if ( psf -> header . indx + 16 >= psf -> header . len && psf_bump_header_allocation ( psf , 16 ) ) return count ; <S2SV_ModStart> * ) ; * intptr = 0 ; <S2SV_ModStart> int * ) ; * intptr = 0 <S2SV_ModStart> size_t ) ; memset ( charptr , 0 , count ) ; byte_count += header_read ( psf , charptr , count ) ; break ; case 'G' : charptr = va_arg ( argptr , char * ) ; count = va_arg ( argptr , size_t ) ; memset ( charptr , 0 , count ) ; if ( psf -> header . indx + count >= psf -> header . len && psf_bump_header_allocation ( psf , count ) ) return 0 ; byte_count += header_gets <S2SV_ModEnd> ( psf , <S2SV_ModStart> break ; case 'z' : psf_log_printf ( psf , \"Format<S2SV_blank>conversion<S2SV_blank>\\'z\\'<S2SV_blank>not<S2SV_blank>implemented<S2SV_blank>yet.\\\\n\" ) ; break ; case 'p' : <S2SV_ModEnd> count = va_arg <S2SV_ModStart> size_t ) ; header_seek ( psf , count , SEEK_SET ) ; byte_count = count ; break ; case 'j' <S2SV_ModEnd> : count = <S2SV_ModStart> , count , <S2SV_ModEnd> SEEK_CUR ) ; <S2SV_ModStart> byte_count += count <S2SV_ModEnd> ; break ;\n","project_and_commit_id":"erikd@libsndfile/708e996c87c5fae77b104ccfeb8f6db784c32074","cve_id":"CVE-2017-7586","original_address":"https://github.com/erikd/libsndfile/commit/708e996c87c5fae77b104ccfeb8f6db784c32074","time":"2017-04-07T20:59Z"},
	{"Unnamed: 0":4106,"cwe_id":"CWE-190","source":"CWE-190 static void bump_cpu_timer ( struct k_itimer * timer , u64 now ) { int i ; u64 delta , incr ; if ( timer -> it . cpu . incr == 0 ) return ; if ( now < timer -> it . cpu . expires ) return ; incr = timer -> it . cpu . incr ; delta = now + incr - timer -> it . cpu . expires ; for ( i = 0 ; incr < delta - incr ; i ++ ) incr = incr << 1 ; for ( ; i >= 0 ; incr >>= 1 , i -- ) { if ( delta < incr ) continue ; timer -> it . cpu . expires += incr ; <S2SV_StartBug> timer -> it_overrun += 1 << i ; <S2SV_EndBug> delta -= incr ; } }\n","target":"<S2SV_ModStart> -> it_overrun += 1LL <S2SV_ModEnd> << i ;\n","project_and_commit_id":"torvalds@linux/78c9c4dfbf8c04883941445a195276bb4bb92c76","cve_id":"CVE-2018-12896","original_address":"https://github.com/torvalds/linux/commit/78c9c4dfbf8c04883941445a195276bb4bb92c76","time":"2018-07-02T17:29Z"},
	{"Unnamed: 0":6449,"cwe_id":"CWE-399","source":"CWE-399 int __kvm_set_memory_region ( struct kvm * kvm , struct kvm_userspace_memory_region * mem , int user_alloc ) { int r ; gfn_t base_gfn ; unsigned long npages ; unsigned long i ; struct kvm_memory_slot * memslot ; struct kvm_memory_slot old , new ; struct kvm_memslots * slots , * old_memslots ; r = check_memory_region_flags ( mem ) ; if ( r ) goto out ; r = - EINVAL ; if ( mem -> memory_size & ( PAGE_SIZE - 1 ) ) goto out ; if ( mem -> guest_phys_addr & ( PAGE_SIZE - 1 ) ) goto out ; if ( user_alloc && ( ( mem -> userspace_addr & ( PAGE_SIZE - 1 ) ) || ! access_ok ( VERIFY_WRITE , ( void __user * ) ( unsigned long ) mem -> userspace_addr , mem -> memory_size ) ) ) goto out ; if ( mem -> slot >= KVM_MEM_SLOTS_NUM ) goto out ; if ( mem -> guest_phys_addr + mem -> memory_size < mem -> guest_phys_addr ) goto out ; memslot = id_to_memslot ( kvm -> memslots , mem -> slot ) ; base_gfn = mem -> guest_phys_addr >> PAGE_SHIFT ; npages = mem -> memory_size >> PAGE_SHIFT ; r = - EINVAL ; if ( npages > KVM_MEM_MAX_NR_PAGES ) goto out ; if ( ! npages ) mem -> flags &= ~ KVM_MEM_LOG_DIRTY_PAGES ; new = old = * memslot ; new . id = mem -> slot ; new . base_gfn = base_gfn ; new . npages = npages ; new . flags = mem -> flags ; r = - EINVAL ; if ( npages && old . npages && npages != old . npages ) goto out_free ; r = - EEXIST ; for ( i = 0 ; i < KVM_MEMORY_SLOTS ; ++ i ) { struct kvm_memory_slot * s = & kvm -> memslots -> memslots [ i ] ; if ( s == memslot || ! s -> npages ) continue ; if ( ! ( ( base_gfn + npages <= s -> base_gfn ) || ( base_gfn >= s -> base_gfn + s -> npages ) ) ) goto out_free ; } if ( ! ( new . flags & KVM_MEM_LOG_DIRTY_PAGES ) ) new . dirty_bitmap = NULL ; r = - ENOMEM ; if ( npages && ! old . npages ) { new . user_alloc = user_alloc ; new . userspace_addr = mem -> userspace_addr ; if ( kvm_arch_create_memslot ( & new , npages ) ) goto out_free ; } if ( ( new . flags & KVM_MEM_LOG_DIRTY_PAGES ) && ! new . dirty_bitmap ) { if ( kvm_create_dirty_bitmap ( & new ) < 0 ) goto out_free ; } <S2SV_StartBug> if ( ! npages ) { <S2SV_EndBug> struct kvm_memory_slot * slot ; r = - ENOMEM ; slots = kmemdup ( kvm -> memslots , sizeof ( struct kvm_memslots ) , GFP_KERNEL ) ; if ( ! slots ) goto out_free ; slot = id_to_memslot ( slots , mem -> slot ) ; slot -> flags |= KVM_MEMSLOT_INVALID ; update_memslots ( slots , NULL ) ; old_memslots = kvm -> memslots ; rcu_assign_pointer ( kvm -> memslots , slots ) ; synchronize_srcu_expedited ( & kvm -> srcu ) ; kvm_arch_flush_shadow_memslot ( kvm , slot ) ; kfree ( old_memslots ) ; } r = kvm_arch_prepare_memory_region ( kvm , & new , old , mem , user_alloc ) ; if ( r ) goto out_free ; if ( npages ) { r = kvm_iommu_map_pages ( kvm , & new ) ; if ( r ) goto out_free ; } else kvm_iommu_unmap_pages ( kvm , & old ) ; r = - ENOMEM ; slots = kmemdup ( kvm -> memslots , sizeof ( struct kvm_memslots ) , GFP_KERNEL ) ; if ( ! slots ) goto out_free ; if ( ! npages ) { new . dirty_bitmap = NULL ; memset ( & new . arch , 0 , sizeof ( new . arch ) ) ; } update_memslots ( slots , & new ) ; old_memslots = kvm -> memslots ; rcu_assign_pointer ( kvm -> memslots , slots ) ; synchronize_srcu_expedited ( & kvm -> srcu ) ; kvm_arch_commit_memory_region ( kvm , mem , old , user_alloc ) ; if ( npages && old . base_gfn != mem -> guest_phys_addr >> PAGE_SHIFT ) kvm_arch_flush_shadow_all ( kvm ) ; kvm_free_physmem_slot ( & old , & new ) ; kfree ( old_memslots ) ; return 0 ; out_free : kvm_free_physmem_slot ( & new , & old ) ; out : return r ; }\n","target":"<S2SV_ModStart> ( ! npages || base_gfn != old . base_gfn\n","project_and_commit_id":"torvalds@linux/12d6e7538e2d418c08f082b1b44ffa5fb7270ed8","cve_id":"CVE-2013-4592","original_address":"https://github.com/torvalds/linux/commit/12d6e7538e2d418c08f082b1b44ffa5fb7270ed8","time":"2013-11-20T13:19Z"},
	{"Unnamed: 0":5233,"cwe_id":"CWE-119","source":"CWE-119 static __u8 * kye_report_fixup ( struct hid_device * hdev , __u8 * rdesc , unsigned int * rsize ) { switch ( hdev -> product ) { case USB_DEVICE_ID_KYE_ERGO_525V : <S2SV_StartBug> if ( * rsize >= 74 && <S2SV_EndBug> <S2SV_StartBug> rdesc [ 61 ] == 0x05 && rdesc [ 62 ] == 0x08 && <S2SV_EndBug> rdesc [ 63 ] == 0x19 && rdesc [ 64 ] == 0x08 && rdesc [ 65 ] == 0x29 && rdesc [ 66 ] == 0x0f && rdesc [ 71 ] == 0x75 && rdesc [ 72 ] == 0x08 && rdesc [ 73 ] == 0x95 && rdesc [ 74 ] == 0x01 ) { hid_info ( hdev , \"fixing<S2SV_blank>up<S2SV_blank>Kye/Genius<S2SV_blank>Ergo<S2SV_blank>Mouse<S2SV_blank>\" \"report<S2SV_blank>descriptor\\\\n\" ) ; rdesc [ 62 ] = 0x09 ; rdesc [ 64 ] = 0x04 ; rdesc [ 66 ] = 0x07 ; rdesc [ 72 ] = 0x01 ; rdesc [ 74 ] = 0x08 ; } break ; case USB_DEVICE_ID_KYE_EASYPEN_I405X : if ( * rsize == EASYPEN_I405X_RDESC_ORIG_SIZE ) { rdesc = easypen_i405x_rdesc_fixed ; * rsize = sizeof ( easypen_i405x_rdesc_fixed ) ; } break ; case USB_DEVICE_ID_KYE_MOUSEPEN_I608X : if ( * rsize == MOUSEPEN_I608X_RDESC_ORIG_SIZE ) { rdesc = mousepen_i608x_rdesc_fixed ; * rsize = sizeof ( mousepen_i608x_rdesc_fixed ) ; } break ; case USB_DEVICE_ID_KYE_EASYPEN_M610X : if ( * rsize == EASYPEN_M610X_RDESC_ORIG_SIZE ) { rdesc = easypen_m610x_rdesc_fixed ; * rsize = sizeof ( easypen_m610x_rdesc_fixed ) ; } break ; case USB_DEVICE_ID_GENIUS_GILA_GAMING_MOUSE : rdesc = kye_consumer_control_fixup ( hdev , rdesc , rsize , 104 , \"Genius<S2SV_blank>Gila<S2SV_blank>Gaming<S2SV_blank>Mouse\" ) ; break ; case USB_DEVICE_ID_GENIUS_GX_IMPERATOR : rdesc = kye_consumer_control_fixup ( hdev , rdesc , rsize , 83 , \"Genius<S2SV_blank>Gx<S2SV_blank>Imperator<S2SV_blank>Keyboard\" ) ; break ; case USB_DEVICE_ID_GENIUS_MANTICORE : rdesc = kye_consumer_control_fixup ( hdev , rdesc , rsize , 104 , \"Genius<S2SV_blank>Manticore<S2SV_blank>Keyboard\" ) ; break ; } return rdesc ; }\n","target":"<S2SV_ModStart> * rsize >= 75 && rdesc [ 61 ] == 0x05 && rdesc [ 62 ] == 0x08 && rdesc [ 63 ] == 0x19 && rdesc [ 64 ] == 0x08 && rdesc [ 65 ] == 0x29 && rdesc [ 66 ] == 0x0f && rdesc [ 71 ] == 0x75 && rdesc [ 72 ] == 0x08 && rdesc [ 73 ] == 0x95 && rdesc [ 74 ] == 0x01 ) { hid_info ( hdev , \"fixing<S2SV_blank>up<S2SV_blank>Kye/Genius<S2SV_blank>Ergo<S2SV_blank>Mouse<S2SV_blank>\" \"report<S2SV_blank>descriptor\\\\n\" ) ; <S2SV_ModEnd> rdesc [ 62 <S2SV_ModStart> [ 62 ] = 0x09 ; rdesc [ 64 ] = 0x04 ; rdesc [ 66 ] = 0x07 ; rdesc [ 72 ] = 0x01 ; rdesc [ 74 ] = 0x08 <S2SV_ModEnd> ; } break\n","project_and_commit_id":"torvalds@linux/4ab25786c87eb20857bbb715c3ae34ec8fd6a214","cve_id":"CVE-2014-3184","original_address":"https://github.com/torvalds/linux/commit/4ab25786c87eb20857bbb715c3ae34ec8fd6a214","time":"2014-09-28T10:55Z"},
	{"Unnamed: 0":3331,"cwe_id":"CWE-908","source":"CWE-908 static int init_device ( u2fh_devs * devs , struct u2fdevice * dev ) { unsigned char resp [ 1024 ] ; unsigned char nonce [ 8 ] ; if ( obtain_nonce ( nonce ) != 0 ) { return U2FH_TRANSPORT_ERROR ; } size_t resplen = sizeof ( resp ) ; dev -> cid = CID_BROADCAST ; if ( u2fh_sendrecv ( devs , dev -> id , U2FHID_INIT , nonce , sizeof ( nonce ) , resp , & resplen ) == U2FH_OK ) { <S2SV_StartBug> U2FHID_INIT_RESP initresp ; <S2SV_EndBug> <S2SV_StartBug> if ( resplen > sizeof ( initresp ) ) <S2SV_EndBug> { return U2FH_MEMORY_ERROR ; } memcpy ( & initresp , resp , resplen ) ; <S2SV_StartBug> dev -> cid = initresp . cid ; <S2SV_EndBug> <S2SV_StartBug> dev -> versionInterface = initresp . versionInterface ; <S2SV_EndBug> <S2SV_StartBug> dev -> versionMajor = initresp . versionMajor ; <S2SV_EndBug> <S2SV_StartBug> dev -> versionMinor = initresp . versionMinor ; <S2SV_EndBug> <S2SV_StartBug> dev -> capFlags = initresp . capFlags ; <S2SV_EndBug> } else { return U2FH_TRANSPORT_ERROR ; } return U2FH_OK ; }\n","target":"<S2SV_ModStart> U2FH_OK ) { int offs = sizeof ( nonce ) <S2SV_ModEnd> ; if ( <S2SV_ModStart> if ( resplen < 17 ) { return U2FH_SIZE_ERROR ; } if ( memcmp ( nonce , resp , sizeof ( nonce ) ) != 0 ) { return U2FH_TRANSPORT_ERROR ; } <S2SV_ModEnd> dev -> cid <S2SV_ModStart> -> cid = resp [ offs ] << 24 | resp [ offs + 1 ] << 16 | resp [ offs + 2 ] << 8 | resp [ offs + 3 ] ; offs += 4 <S2SV_ModEnd> ; dev -> <S2SV_ModStart> -> versionInterface = resp [ offs ++ ] <S2SV_ModEnd> ; dev -> <S2SV_ModStart> -> versionMajor = resp [ offs ++ ] <S2SV_ModEnd> ; dev -> <S2SV_ModStart> -> versionMinor = resp [ offs ++ ] ; dev -> versionBuild = resp [ offs ++ ] <S2SV_ModEnd> ; dev -> <S2SV_ModStart> -> capFlags = resp [ offs ++ ] <S2SV_ModEnd> ; } else\n","project_and_commit_id":"Yubico@libu2f-host/e4bb58cc8b6202a421e65f8230217d8ae6e16eb5","cve_id":"CVE-2019-9578","original_address":"https://github.com/Yubico/libu2f-host/commit/e4bb58cc8b6202a421e65f8230217d8ae6e16eb5","time":"2019-03-05T23:29Z"},
	{"Unnamed: 0":545,"cwe_id":"CWE-787","source":"CWE-787 rfbBool HandleRFBServerMessage ( rfbClient * client ) { rfbServerToClientMsg msg ; if ( client -> serverPort == - 1 ) client -> vncRec -> readTimestamp = TRUE ; if ( ! ReadFromRFBServer ( client , ( char * ) & msg , 1 ) ) return FALSE ; switch ( msg . type ) { case rfbSetColourMapEntries : { break ; } case rfbFramebufferUpdate : { rfbFramebufferUpdateRectHeader rect ; int linesToRead ; int bytesPerLine ; int i ; if ( ! ReadFromRFBServer ( client , ( ( char * ) & msg . fu ) + 1 , sz_rfbFramebufferUpdateMsg - 1 ) ) return FALSE ; msg . fu . nRects = rfbClientSwap16IfLE ( msg . fu . nRects ) ; for ( i = 0 ; i < msg . fu . nRects ; i ++ ) { if ( ! ReadFromRFBServer ( client , ( char * ) & rect , sz_rfbFramebufferUpdateRectHeader ) ) return FALSE ; rect . encoding = rfbClientSwap32IfLE ( rect . encoding ) ; if ( rect . encoding == rfbEncodingLastRect ) break ; rect . r . x = rfbClientSwap16IfLE ( rect . r . x ) ; rect . r . y = rfbClientSwap16IfLE ( rect . r . y ) ; rect . r . w = rfbClientSwap16IfLE ( rect . r . w ) ; rect . r . h = rfbClientSwap16IfLE ( rect . r . h ) ; if ( rect . encoding == rfbEncodingXCursor || rect . encoding == rfbEncodingRichCursor ) { if ( ! HandleCursorShape ( client , rect . r . x , rect . r . y , rect . r . w , rect . r . h , rect . encoding ) ) { return FALSE ; } continue ; } if ( rect . encoding == rfbEncodingPointerPos ) { if ( ! client -> HandleCursorPos ( client , rect . r . x , rect . r . y ) ) { return FALSE ; } continue ; } if ( rect . encoding == rfbEncodingKeyboardLedState ) { client -> KeyboardLedStateEnabled = 1 ; if ( client -> HandleKeyboardLedState != NULL ) client -> HandleKeyboardLedState ( client , rect . r . x , 0 ) ; client -> CurrentKeyboardLedState = rect . r . x ; continue ; } if ( rect . encoding == rfbEncodingNewFBSize ) { client -> width = rect . r . w ; client -> height = rect . r . h ; client -> updateRect . x = client -> updateRect . y = 0 ; client -> updateRect . w = client -> width ; client -> updateRect . h = client -> height ; if ( ! client -> MallocFrameBuffer ( client ) ) return FALSE ; SendFramebufferUpdateRequest ( client , 0 , 0 , rect . r . w , rect . r . h , FALSE ) ; rfbClientLog ( \"Got<S2SV_blank>new<S2SV_blank>framebuffer<S2SV_blank>size:<S2SV_blank>%dx%d\\\\n\" , rect . r . w , rect . r . h ) ; continue ; } if ( rect . encoding == rfbEncodingSupportedMessages ) { int loop ; if ( ! ReadFromRFBServer ( client , ( char * ) & client -> supportedMessages , sz_rfbSupportedMessages ) ) return FALSE ; rfbClientLog ( \"client2server<S2SV_blank>supported<S2SV_blank>messages<S2SV_blank>(bit<S2SV_blank>flags)\\\\n\" ) ; for ( loop = 0 ; loop < 32 ; loop += 8 ) rfbClientLog ( \"%02X:<S2SV_blank>%04x<S2SV_blank>%04x<S2SV_blank>%04x<S2SV_blank>%04x<S2SV_blank>-<S2SV_blank>%04x<S2SV_blank>%04x<S2SV_blank>%04x<S2SV_blank>%04x\\\\n\" , loop , client -> supportedMessages . client2server [ loop ] , client -> supportedMessages . client2server [ loop + 1 ] , client -> supportedMessages . client2server [ loop + 2 ] , client -> supportedMessages . client2server [ loop + 3 ] , client -> supportedMessages . client2server [ loop + 4 ] , client -> supportedMessages . client2server [ loop + 5 ] , client -> supportedMessages . client2server [ loop + 6 ] , client -> supportedMessages . client2server [ loop + 7 ] ) ; rfbClientLog ( \"server2client<S2SV_blank>supported<S2SV_blank>messages<S2SV_blank>(bit<S2SV_blank>flags)\\\\n\" ) ; for ( loop = 0 ; loop < 32 ; loop += 8 ) rfbClientLog ( \"%02X:<S2SV_blank>%04x<S2SV_blank>%04x<S2SV_blank>%04x<S2SV_blank>%04x<S2SV_blank>-<S2SV_blank>%04x<S2SV_blank>%04x<S2SV_blank>%04x<S2SV_blank>%04x\\\\n\" , loop , client -> supportedMessages . server2client [ loop ] , client -> supportedMessages . server2client [ loop + 1 ] , client -> supportedMessages . server2client [ loop + 2 ] , client -> supportedMessages . server2client [ loop + 3 ] , client -> supportedMessages . server2client [ loop + 4 ] , client -> supportedMessages . server2client [ loop + 5 ] , client -> supportedMessages . server2client [ loop + 6 ] , client -> supportedMessages . server2client [ loop + 7 ] ) ; continue ; } if ( rect . encoding == rfbEncodingSupportedEncodings ) { char * buffer ; buffer = malloc ( rect . r . w ) ; if ( ! ReadFromRFBServer ( client , buffer , rect . r . w ) ) { free ( buffer ) ; return FALSE ; } free ( buffer ) ; continue ; } if ( rect . encoding == rfbEncodingServerIdentity ) { char * buffer ; buffer = malloc ( rect . r . w + 1 ) ; if ( ! ReadFromRFBServer ( client , buffer , rect . r . w ) ) { free ( buffer ) ; return FALSE ; } buffer [ rect . r . w ] = 0 ; rfbClientLog ( \"Connected<S2SV_blank>to<S2SV_blank>Server<S2SV_blank>\\\\\"%s\\\\\"\\\\n\" , buffer ) ; free ( buffer ) ; continue ; } if ( rect . encoding != rfbEncodingUltraZip ) { if ( ( rect . r . x + rect . r . w > client -> width ) || ( rect . r . y + rect . r . h > client -> height ) ) { rfbClientLog ( \"Rect<S2SV_blank>too<S2SV_blank>large:<S2SV_blank>%dx%d<S2SV_blank>at<S2SV_blank>(%d,<S2SV_blank>%d)\\\\n\" , rect . r . w , rect . r . h , rect . r . x , rect . r . y ) ; return FALSE ; } client -> SoftCursorLockArea ( client , rect . r . x , rect . r . y , rect . r . w , rect . r . h ) ; } switch ( rect . encoding ) { case rfbEncodingRaw : { int y = rect . r . y , h = rect . r . h ; bytesPerLine = rect . r . w * client -> format . bitsPerPixel / 8 ; linesToRead = bytesPerLine ? ( RFB_BUFFER_SIZE / bytesPerLine ) : 0 ; while ( linesToRead && h > 0 ) { if ( linesToRead > h ) linesToRead = h ; if ( ! ReadFromRFBServer ( client , client -> buffer , bytesPerLine * linesToRead ) ) return FALSE ; client -> GotBitmap ( client , ( uint8_t * ) client -> buffer , rect . r . x , y , rect . r . w , linesToRead ) ; h -= linesToRead ; y += linesToRead ; } break ; } case rfbEncodingCopyRect : { rfbCopyRect cr ; if ( ! ReadFromRFBServer ( client , ( char * ) & cr , sz_rfbCopyRect ) ) return FALSE ; cr . srcX = rfbClientSwap16IfLE ( cr . srcX ) ; cr . srcY = rfbClientSwap16IfLE ( cr . srcY ) ; client -> SoftCursorLockArea ( client , cr . srcX , cr . srcY , rect . r . w , rect . r . h ) ; client -> GotCopyRect ( client , cr . srcX , cr . srcY , rect . r . w , rect . r . h , rect . r . x , rect . r . y ) ; break ; } case rfbEncodingRRE : { switch ( client -> format . bitsPerPixel ) { case 8 : if ( ! HandleRRE8 ( client , rect . r . x , rect . r . y , rect . r . w , rect . r . h ) ) return FALSE ; break ; case 16 : if ( ! HandleRRE16 ( client , rect . r . x , rect . r . y , rect . r . w , rect . r . h ) ) return FALSE ; break ; case 32 : if ( ! HandleRRE32 ( client , rect . r . x , rect . r . y , rect . r . w , rect . r . h ) ) return FALSE ; break ; } break ; } case rfbEncodingCoRRE : { switch ( client -> format . bitsPerPixel ) { case 8 : if ( ! HandleCoRRE8 ( client , rect . r . x , rect . r . y , rect . r . w , rect . r . h ) ) return FALSE ; break ; case 16 : if ( ! HandleCoRRE16 ( client , rect . r . x , rect . r . y , rect . r . w , rect . r . h ) ) return FALSE ; break ; case 32 : if ( ! HandleCoRRE32 ( client , rect . r . x , rect . r . y , rect . r . w , rect . r . h ) ) return FALSE ; break ; } break ; } case rfbEncodingHextile : { switch ( client -> format . bitsPerPixel ) { case 8 : if ( ! HandleHextile8 ( client , rect . r . x , rect . r . y , rect . r . w , rect . r . h ) ) return FALSE ; break ; case 16 : if ( ! HandleHextile16 ( client , rect . r . x , rect . r . y , rect . r . w , rect . r . h ) ) return FALSE ; break ; case 32 : if ( ! HandleHextile32 ( client , rect . r . x , rect . r . y , rect . r . w , rect . r . h ) ) return FALSE ; break ; } break ; } case rfbEncodingUltra : { switch ( client -> format . bitsPerPixel ) { case 8 : if ( ! HandleUltra8 ( client , rect . r . x , rect . r . y , rect . r . w , rect . r . h ) ) return FALSE ; break ; case 16 : if ( ! HandleUltra16 ( client , rect . r . x , rect . r . y , rect . r . w , rect . r . h ) ) return FALSE ; break ; case 32 : if ( ! HandleUltra32 ( client , rect . r . x , rect . r . y , rect . r . w , rect . r . h ) ) return FALSE ; break ; } break ; } case rfbEncodingUltraZip : { switch ( client -> format . bitsPerPixel ) { case 8 : if ( ! HandleUltraZip8 ( client , rect . r . x , rect . r . y , rect . r . w , rect . r . h ) ) return FALSE ; break ; case 16 : if ( ! HandleUltraZip16 ( client , rect . r . x , rect . r . y , rect . r . w , rect . r . h ) ) return FALSE ; break ; case 32 : if ( ! HandleUltraZip32 ( client , rect . r . x , rect . r . y , rect . r . w , rect . r . h ) ) return FALSE ; break ; } break ; } case rfbEncodingTRLE : { switch ( client -> format . bitsPerPixel ) { case 8 : if ( ! HandleTRLE8 ( client , rect . r . x , rect . r . y , rect . r . w , rect . r . h ) ) return FALSE ; break ; case 16 : if ( client -> si . format . greenMax > 0x1F ) { if ( ! HandleTRLE16 ( client , rect . r . x , rect . r . y , rect . r . w , rect . r . h ) ) return FALSE ; } else { if ( ! HandleTRLE15 ( client , rect . r . x , rect . r . y , rect . r . w , rect . r . h ) ) return FALSE ; } break ; case 32 : { uint32_t maxColor = ( client -> format . redMax << client -> format . redShift ) | ( client -> format . greenMax << client -> format . greenShift ) | ( client -> format . blueMax << client -> format . blueShift ) ; if ( ( client -> format . bigEndian && ( maxColor & 0xff ) == 0 ) || ( ! client -> format . bigEndian && ( maxColor & 0xff000000 ) == 0 ) ) { if ( ! HandleTRLE24 ( client , rect . r . x , rect . r . y , rect . r . w , rect . r . h ) ) return FALSE ; } else if ( ! client -> format . bigEndian && ( maxColor & 0xff ) == 0 ) { if ( ! HandleTRLE24Up ( client , rect . r . x , rect . r . y , rect . r . w , rect . r . h ) ) return FALSE ; } else if ( client -> format . bigEndian && ( maxColor & 0xff000000 ) == 0 ) { if ( ! HandleTRLE24Down ( client , rect . r . x , rect . r . y , rect . r . w , rect . r . h ) ) return FALSE ; } else if ( ! HandleTRLE32 ( client , rect . r . x , rect . r . y , rect . r . w , rect . r . h ) ) return FALSE ; break ; } } break ; } # ifdef LIBVNCSERVER_HAVE_LIBZ case rfbEncodingZlib : { switch ( client -> format . bitsPerPixel ) { case 8 : if ( ! HandleZlib8 ( client , rect . r . x , rect . r . y , rect . r . w , rect . r . h ) ) return FALSE ; break ; case 16 : if ( ! HandleZlib16 ( client , rect . r . x , rect . r . y , rect . r . w , rect . r . h ) ) return FALSE ; break ; case 32 : if ( ! HandleZlib32 ( client , rect . r . x , rect . r . y , rect . r . w , rect . r . h ) ) return FALSE ; break ; } break ; } # ifdef LIBVNCSERVER_HAVE_LIBJPEG case rfbEncodingTight : { switch ( client -> format . bitsPerPixel ) { case 8 : if ( ! HandleTight8 ( client , rect . r . x , rect . r . y , rect . r . w , rect . r . h ) ) return FALSE ; break ; case 16 : if ( ! HandleTight16 ( client , rect . r . x , rect . r . y , rect . r . w , rect . r . h ) ) return FALSE ; break ; case 32 : if ( ! HandleTight32 ( client , rect . r . x , rect . r . y , rect . r . w , rect . r . h ) ) return FALSE ; break ; } break ; } # endif case rfbEncodingZRLE : client -> appData . qualityLevel = 9 ; case rfbEncodingZYWRLE : { switch ( client -> format . bitsPerPixel ) { case 8 : if ( ! HandleZRLE8 ( client , rect . r . x , rect . r . y , rect . r . w , rect . r . h ) ) return FALSE ; break ; case 16 : if ( client -> si . format . greenMax > 0x1F ) { if ( ! HandleZRLE16 ( client , rect . r . x , rect . r . y , rect . r . w , rect . r . h ) ) return FALSE ; } else { if ( ! HandleZRLE15 ( client , rect . r . x , rect . r . y , rect . r . w , rect . r . h ) ) return FALSE ; } break ; case 32 : { uint32_t maxColor = ( client -> format . redMax << client -> format . redShift ) | ( client -> format . greenMax << client -> format . greenShift ) | ( client -> format . blueMax << client -> format . blueShift ) ; if ( ( client -> format . bigEndian && ( maxColor & 0xff ) == 0 ) || ( ! client -> format . bigEndian && ( maxColor & 0xff000000 ) == 0 ) ) { if ( ! HandleZRLE24 ( client , rect . r . x , rect . r . y , rect . r . w , rect . r . h ) ) return FALSE ; } else if ( ! client -> format . bigEndian && ( maxColor & 0xff ) == 0 ) { if ( ! HandleZRLE24Up ( client , rect . r . x , rect . r . y , rect . r . w , rect . r . h ) ) return FALSE ; } else if ( client -> format . bigEndian && ( maxColor & 0xff000000 ) == 0 ) { if ( ! HandleZRLE24Down ( client , rect . r . x , rect . r . y , rect . r . w , rect . r . h ) ) return FALSE ; } else if ( ! HandleZRLE32 ( client , rect . r . x , rect . r . y , rect . r . w , rect . r . h ) ) return FALSE ; break ; } } break ; } # endif default : { rfbBool handled = FALSE ; rfbClientProtocolExtension * e ; for ( e = rfbClientExtensions ; ! handled && e ; e = e -> next ) if ( e -> handleEncoding && e -> handleEncoding ( client , & rect ) ) handled = TRUE ; if ( ! handled ) { rfbClientLog ( \"Unknown<S2SV_blank>rect<S2SV_blank>encoding<S2SV_blank>%d\\\\n\" , ( int ) rect . encoding ) ; return FALSE ; } } } client -> SoftCursorUnlockScreen ( client ) ; client -> GotFrameBufferUpdate ( client , rect . r . x , rect . r . y , rect . r . w , rect . r . h ) ; } if ( ! SendIncrementalFramebufferUpdateRequest ( client ) ) return FALSE ; if ( client -> FinishedFrameBufferUpdate ) client -> FinishedFrameBufferUpdate ( client ) ; break ; } case rfbBell : { client -> Bell ( client ) ; break ; } case rfbServerCutText : { char * buffer ; if ( ! ReadFromRFBServer ( client , ( ( char * ) & msg ) + 1 , sz_rfbServerCutTextMsg - 1 ) ) return FALSE ; msg . sct . length = rfbClientSwap32IfLE ( msg . sct . length ) ; <S2SV_StartBug> buffer = malloc ( ( uint64_t ) msg . sct . length + 1 ) ; <S2SV_EndBug> if ( ! ReadFromRFBServer ( client , buffer , msg . sct . length ) ) { free ( buffer ) ; return FALSE ; } buffer [ msg . sct . length ] = 0 ; if ( client -> GotXCutText ) client -> GotXCutText ( client , buffer , msg . sct . length ) ; free ( buffer ) ; break ; } case rfbTextChat : { char * buffer = NULL ; if ( ! ReadFromRFBServer ( client , ( ( char * ) & msg ) + 1 , sz_rfbTextChatMsg - 1 ) ) return FALSE ; msg . tc . length = rfbClientSwap32IfLE ( msg . sct . length ) ; switch ( msg . tc . length ) { case rfbTextChatOpen : rfbClientLog ( \"Received<S2SV_blank>TextChat<S2SV_blank>Open\\\\n\" ) ; if ( client -> HandleTextChat != NULL ) client -> HandleTextChat ( client , ( int ) rfbTextChatOpen , NULL ) ; break ; case rfbTextChatClose : rfbClientLog ( \"Received<S2SV_blank>TextChat<S2SV_blank>Close\\\\n\" ) ; if ( client -> HandleTextChat != NULL ) client -> HandleTextChat ( client , ( int ) rfbTextChatClose , NULL ) ; break ; case rfbTextChatFinished : rfbClientLog ( \"Received<S2SV_blank>TextChat<S2SV_blank>Finished\\\\n\" ) ; if ( client -> HandleTextChat != NULL ) client -> HandleTextChat ( client , ( int ) rfbTextChatFinished , NULL ) ; break ; default : buffer = malloc ( msg . tc . length + 1 ) ; if ( ! ReadFromRFBServer ( client , buffer , msg . tc . length ) ) { free ( buffer ) ; return FALSE ; } buffer [ msg . tc . length ] = 0 ; rfbClientLog ( \"Received<S2SV_blank>TextChat<S2SV_blank>\\\\\"%s\\\\\"\\\\n\" , buffer ) ; if ( client -> HandleTextChat != NULL ) client -> HandleTextChat ( client , ( int ) msg . tc . length , buffer ) ; free ( buffer ) ; break ; } break ; } case rfbXvp : { if ( ! ReadFromRFBServer ( client , ( ( char * ) & msg ) + 1 , sz_rfbXvpMsg - 1 ) ) return FALSE ; SetClient2Server ( client , rfbXvp ) ; SetServer2Client ( client , rfbXvp ) ; if ( client -> HandleXvpMsg ) client -> HandleXvpMsg ( client , msg . xvp . version , msg . xvp . code ) ; break ; } case rfbResizeFrameBuffer : { if ( ! ReadFromRFBServer ( client , ( ( char * ) & msg ) + 1 , sz_rfbResizeFrameBufferMsg - 1 ) ) return FALSE ; client -> width = rfbClientSwap16IfLE ( msg . rsfb . framebufferWidth ) ; client -> height = rfbClientSwap16IfLE ( msg . rsfb . framebufferHeigth ) ; client -> updateRect . x = client -> updateRect . y = 0 ; client -> updateRect . w = client -> width ; client -> updateRect . h = client -> height ; if ( ! client -> MallocFrameBuffer ( client ) ) return FALSE ; SendFramebufferUpdateRequest ( client , 0 , 0 , client -> width , client -> height , FALSE ) ; rfbClientLog ( \"Got<S2SV_blank>new<S2SV_blank>framebuffer<S2SV_blank>size:<S2SV_blank>%dx%d\\\\n\" , client -> width , client -> height ) ; break ; } case rfbPalmVNCReSizeFrameBuffer : { if ( ! ReadFromRFBServer ( client , ( ( char * ) & msg ) + 1 , sz_rfbPalmVNCReSizeFrameBufferMsg - 1 ) ) return FALSE ; client -> width = rfbClientSwap16IfLE ( msg . prsfb . buffer_w ) ; client -> height = rfbClientSwap16IfLE ( msg . prsfb . buffer_h ) ; client -> updateRect . x = client -> updateRect . y = 0 ; client -> updateRect . w = client -> width ; client -> updateRect . h = client -> height ; if ( ! client -> MallocFrameBuffer ( client ) ) return FALSE ; SendFramebufferUpdateRequest ( client , 0 , 0 , client -> width , client -> height , FALSE ) ; rfbClientLog ( \"Got<S2SV_blank>new<S2SV_blank>framebuffer<S2SV_blank>size:<S2SV_blank>%dx%d\\\\n\" , client -> width , client -> height ) ; break ; } default : { rfbBool handled = FALSE ; rfbClientProtocolExtension * e ; for ( e = rfbClientExtensions ; ! handled && e ; e = e -> next ) if ( e -> handleMessage && e -> handleMessage ( client , & msg ) ) handled = TRUE ; if ( ! handled ) { char buffer [ 256 ] ; rfbClientLog ( \"Unknown<S2SV_blank>message<S2SV_blank>type<S2SV_blank>%d<S2SV_blank>from<S2SV_blank>VNC<S2SV_blank>server\\\\n\" , msg . type ) ; ReadFromRFBServer ( client , buffer , 256 ) ; return FALSE ; } } } return TRUE ; }\n","target":"<S2SV_ModStart> length ) ; if ( msg . sct . length > 1 << 20 ) { rfbClientErr ( \"Ignoring<S2SV_blank>too<S2SV_blank>big<S2SV_blank>cut<S2SV_blank>text<S2SV_blank>length<S2SV_blank>sent<S2SV_blank>by<S2SV_blank>server:<S2SV_blank>%u<S2SV_blank>B<S2SV_blank>><S2SV_blank>1<S2SV_blank>MB\\\\n\" , ( unsigned int ) msg . sct . length ) ; return FALSE ; }\n","project_and_commit_id":"LibVNC@libvncserver/c5ba3fee85a7ecbbca1df5ffd46d32b92757bc2a","cve_id":"CVE-2018-20748","original_address":"https://github.com/LibVNC/libvncserver/commit/c5ba3fee85a7ecbbca1df5ffd46d32b92757bc2a","time":"2019-01-30T18:29Z"},
	{"Unnamed: 0":4881,"cwe_id":"CWE-416","source":"CWE-416 static int xfrm_user_rcv_msg ( struct sk_buff * skb , struct nlmsghdr * nlh , struct netlink_ext_ack * extack ) { struct net * net = sock_net ( skb -> sk ) ; struct nlattr * attrs [ XFRMA_MAX + 1 ] ; const struct xfrm_link * link ; int type , err ; # ifdef CONFIG_COMPAT if ( in_compat_syscall ( ) ) return - EOPNOTSUPP ; # endif type = nlh -> nlmsg_type ; if ( type > XFRM_MSG_MAX ) return - EINVAL ; type -= XFRM_MSG_BASE ; link = & xfrm_dispatch [ type ] ; if ( ! netlink_net_capable ( skb , CAP_NET_ADMIN ) ) return - EPERM ; if ( ( type == ( XFRM_MSG_GETSA - XFRM_MSG_BASE ) || type == ( XFRM_MSG_GETPOLICY - XFRM_MSG_BASE ) ) && ( nlh -> nlmsg_flags & NLM_F_DUMP ) ) { if ( link -> dump == NULL ) return - EINVAL ; { struct netlink_dump_control c = { <S2SV_StartBug> . dump = link -> dump , <S2SV_EndBug> . done = link -> done , } ; return netlink_dump_start ( net -> xfrm . nlsk , skb , nlh , & c ) ; } } err = nlmsg_parse ( nlh , xfrm_msg_min [ type ] , attrs , link -> nla_max ? : XFRMA_MAX , link -> nla_pol ? : xfrma_policy , extack ) ; if ( err < 0 ) return err ; if ( link -> doit == NULL ) return - EINVAL ; return link -> doit ( skb , nlh , attrs ) ; }\n","target":"<S2SV_ModStart> = { . start = link -> start , .\n","project_and_commit_id":"torvalds@linux/1137b5e2529a8f5ca8ee709288ecba3e68044df2","cve_id":"CVE-2017-16939","original_address":"https://github.com/torvalds/linux/commit/1137b5e2529a8f5ca8ee709288ecba3e68044df2","time":"2017-11-24T10:29Z"},
	{"Unnamed: 0":873,"cwe_id":"CWE-20","source":"CWE-20 static int do_replace ( struct net * net , const void __user * user , unsigned int len ) { int ret , countersize ; struct ebt_table_info * newinfo ; struct ebt_replace tmp ; if ( copy_from_user ( & tmp , user , sizeof ( tmp ) ) != 0 ) return - EFAULT ; if ( len != sizeof ( tmp ) + tmp . entries_size ) { BUGPRINT ( \"Wrong<S2SV_blank>len<S2SV_blank>argument\\\\n\" ) ; return - EINVAL ; } if ( tmp . entries_size == 0 ) { BUGPRINT ( \"Entries_size<S2SV_blank>never<S2SV_blank>zero\\\\n\" ) ; return - EINVAL ; } if ( tmp . nentries >= ( ( INT_MAX - sizeof ( struct ebt_table_info ) ) / NR_CPUS - SMP_CACHE_BYTES ) / sizeof ( struct ebt_counter ) ) return - ENOMEM ; if ( tmp . num_counters >= INT_MAX / sizeof ( struct ebt_counter ) ) return - ENOMEM ; <S2SV_StartBug> countersize = COUNTER_OFFSET ( tmp . nentries ) * nr_cpu_ids ; <S2SV_EndBug> newinfo = vmalloc ( sizeof ( * newinfo ) + countersize ) ; if ( ! newinfo ) return - ENOMEM ; if ( countersize ) memset ( newinfo -> counters , 0 , countersize ) ; newinfo -> entries = vmalloc ( tmp . entries_size ) ; if ( ! newinfo -> entries ) { ret = - ENOMEM ; goto free_newinfo ; } if ( copy_from_user ( newinfo -> entries , tmp . entries , tmp . entries_size ) != 0 ) { BUGPRINT ( \"Couldn\\'t<S2SV_blank>copy<S2SV_blank>entries<S2SV_blank>from<S2SV_blank>userspace\\\\n\" ) ; ret = - EFAULT ; goto free_entries ; } ret = do_replace_finish ( net , & tmp , newinfo ) ; if ( ret == 0 ) return ret ; free_entries : vfree ( newinfo -> entries ) ; free_newinfo : vfree ( newinfo ) ; return ret ; }\n","target":"<S2SV_ModStart> - ENOMEM ; tmp . name [ sizeof ( tmp . name ) - 1 ] = 0 ;\n","project_and_commit_id":"torvalds@linux/d846f71195d57b0bbb143382647c2c6638b04c5a","cve_id":"CVE-2011-1080","original_address":"https://github.com/torvalds/linux/commit/d846f71195d57b0bbb143382647c2c6638b04c5a","time":"2012-06-21T23:55Z"},
	{"Unnamed: 0":3945,"cwe_id":"CWE-000","source":"CWE-000 static int closeVirtualHostDirective ( MaState * state , cchar * key , cchar * value ) { HttpEndpoint * endpoint ; char * address , * ip , * addresses , * tok ; int port ; if ( state -> enabled ) { if ( state -> endpoints && * state -> endpoints ) { <S2SV_StartBug> addresses = state -> endpoints ; <S2SV_EndBug> <S2SV_StartBug> while ( ( address = stok ( addresses , \"<S2SV_blank>\\\\t,\" , & tok ) ) != 0 ) { <S2SV_EndBug> addresses = 0 ; mprParseSocketAddress ( address , & ip , & port , NULL , - 1 ) ; if ( ( endpoint = httpLookupEndpoint ( ip , port ) ) == 0 ) { mprLog ( \"error<S2SV_blank>appweb<S2SV_blank>config\" , 0 , \"Cannot<S2SV_blank>find<S2SV_blank>listen<S2SV_blank>directive<S2SV_blank>for<S2SV_blank>virtual<S2SV_blank>host<S2SV_blank>%s\" , address ) ; return MPR_ERR_BAD_SYNTAX ; } else { httpAddHostToEndpoint ( endpoint , state -> host ) ; } } } else { httpAddHostToEndpoints ( state -> host ) ; } } closeDirective ( state , key , value ) ; return 0 ; }\n","target":"<S2SV_ModStart> endpoints ) { for ( addresses = sclone ( <S2SV_ModEnd> state -> endpoints <S2SV_ModStart> state -> endpoints ) ; <S2SV_ModEnd> ( address = <S2SV_ModStart> ) != 0 ; addresses = tok ) { <S2SV_ModEnd> mprParseSocketAddress ( address\n","project_and_commit_id":"embedthis@appweb/7e6a925f5e86a19a7934a94bbd6959101d0b84eb","cve_id":"CVE-2014-9708","original_address":"https://github.com/embedthis/appweb/commit/7e6a925f5e86a19a7934a94bbd6959101d0b84eb","time":"2015-03-31T14:59Z"},
	{"Unnamed: 0":5105,"cwe_id":"CWE-119","source":"CWE-119 static int mark_source_chains ( const struct xt_table_info * newinfo , unsigned int valid_hooks , void * entry0 ) { unsigned int hook ; for ( hook = 0 ; hook < NF_INET_NUMHOOKS ; hook ++ ) { unsigned int pos = newinfo -> hook_entry [ hook ] ; struct ip6t_entry * e = ( struct ip6t_entry * ) ( entry0 + pos ) ; if ( ! ( valid_hooks & ( 1 << hook ) ) ) continue ; e -> counters . pcnt = pos ; for ( ; ; ) { const struct xt_standard_target * t = ( void * ) ip6t_get_target_c ( e ) ; int visited = e -> comefrom & ( 1 << hook ) ; if ( e -> comefrom & ( 1 << NF_INET_NUMHOOKS ) ) { pr_err ( \"iptables:<S2SV_blank>loop<S2SV_blank>hook<S2SV_blank>%u<S2SV_blank>pos<S2SV_blank>%u<S2SV_blank>%08X.\\\\n\" , hook , pos , e -> comefrom ) ; return 0 ; } e -> comefrom |= ( ( 1 << hook ) | ( 1 << NF_INET_NUMHOOKS ) ) ; <S2SV_StartBug> if ( ( e -> target_offset == sizeof ( struct ip6t_entry ) && <S2SV_EndBug> ( strcmp ( t -> target . u . user . name , XT_STANDARD_TARGET ) == 0 ) && <S2SV_StartBug> t -> verdict < 0 && <S2SV_EndBug> unconditional ( & e -> ipv6 ) ) || visited ) { unsigned int oldpos , size ; if ( ( strcmp ( t -> target . u . user . name , XT_STANDARD_TARGET ) == 0 ) && t -> verdict < - NF_MAX_VERDICT - 1 ) { duprintf ( \"mark_source_chains:<S2SV_blank>bad<S2SV_blank>\" \"negative<S2SV_blank>verdict<S2SV_blank>(%i)\\\\n\" , t -> verdict ) ; return 0 ; } do { e -> comefrom ^= ( 1 << NF_INET_NUMHOOKS ) ; # ifdef DEBUG_IP_FIREWALL_USER if ( e -> comefrom & ( 1 << NF_INET_NUMHOOKS ) ) { duprintf ( \"Back<S2SV_blank>unset<S2SV_blank>\" \"on<S2SV_blank>hook<S2SV_blank>%u<S2SV_blank>\" \"rule<S2SV_blank>%u\\\\n\" , hook , pos ) ; } # endif oldpos = pos ; pos = e -> counters . pcnt ; e -> counters . pcnt = 0 ; if ( pos == oldpos ) goto next ; e = ( struct ip6t_entry * ) ( entry0 + pos ) ; } while ( oldpos == pos + e -> next_offset ) ; size = e -> next_offset ; e = ( struct ip6t_entry * ) ( entry0 + pos + size ) ; e -> counters . pcnt = pos ; pos += size ; } else { int newpos = t -> verdict ; if ( strcmp ( t -> target . u . user . name , XT_STANDARD_TARGET ) == 0 && newpos >= 0 ) { if ( newpos > newinfo -> size - sizeof ( struct ip6t_entry ) ) { duprintf ( \"mark_source_chains:<S2SV_blank>\" \"bad<S2SV_blank>verdict<S2SV_blank>(%i)\\\\n\" , newpos ) ; return 0 ; } duprintf ( \"Jump<S2SV_blank>rule<S2SV_blank>%u<S2SV_blank>-><S2SV_blank>%u\\\\n\" , pos , newpos ) ; } else { newpos = pos + e -> next_offset ; } e = ( struct ip6t_entry * ) ( entry0 + newpos ) ; e -> counters . pcnt = pos ; pos = newpos ; } } next : duprintf ( \"Finished<S2SV_blank>chain<S2SV_blank>%u\\\\n\" , hook ) ; } return 1 ; }\n","target":"<S2SV_ModStart> if ( ( unconditional ( e <S2SV_ModEnd> ) && ( <S2SV_ModStart> verdict < 0 <S2SV_ModEnd> ) || visited\n","project_and_commit_id":"torvalds@linux/54d83fc74aa9ec72794373cb47432c5f7fb1a309","cve_id":"CVE-2016-3134","original_address":"https://github.com/torvalds/linux/commit/54d83fc74aa9ec72794373cb47432c5f7fb1a309","time":"2016-04-27T17:59Z"},
	{"Unnamed: 0":1492,"cwe_id":"CWE-119","source":"CWE-119 static noinline int hiddev_ioctl_usage ( struct hiddev * hiddev , unsigned int cmd , void __user * user_arg ) { struct hid_device * hid = hiddev -> hid ; struct hiddev_report_info rinfo ; struct hiddev_usage_ref_multi * uref_multi = NULL ; struct hiddev_usage_ref * uref ; struct hid_report * report ; struct hid_field * field ; int i ; uref_multi = kmalloc ( sizeof ( struct hiddev_usage_ref_multi ) , GFP_KERNEL ) ; if ( ! uref_multi ) return - ENOMEM ; uref = & uref_multi -> uref ; if ( cmd == HIDIOCGUSAGES || cmd == HIDIOCSUSAGES ) { if ( copy_from_user ( uref_multi , user_arg , sizeof ( * uref_multi ) ) ) goto fault ; } else { if ( copy_from_user ( uref , user_arg , sizeof ( * uref ) ) ) goto fault ; } switch ( cmd ) { case HIDIOCGUCODE : rinfo . report_type = uref -> report_type ; rinfo . report_id = uref -> report_id ; if ( ( report = hiddev_lookup_report ( hid , & rinfo ) ) == NULL ) goto inval ; if ( uref -> field_index >= report -> maxfield ) goto inval ; field = report -> field [ uref -> field_index ] ; if ( uref -> usage_index >= field -> maxusage ) goto inval ; uref -> usage_code = field -> usage [ uref -> usage_index ] . hid ; if ( copy_to_user ( user_arg , uref , sizeof ( * uref ) ) ) goto fault ; goto goodreturn ; default : if ( cmd != HIDIOCGUSAGE && cmd != HIDIOCGUSAGES && uref -> report_type == HID_REPORT_TYPE_INPUT ) goto inval ; if ( uref -> report_id == HID_REPORT_ID_UNKNOWN ) { field = hiddev_lookup_usage ( hid , uref ) ; if ( field == NULL ) goto inval ; } else { rinfo . report_type = uref -> report_type ; rinfo . report_id = uref -> report_id ; if ( ( report = hiddev_lookup_report ( hid , & rinfo ) ) == NULL ) goto inval ; if ( uref -> field_index >= report -> maxfield ) goto inval ; field = report -> field [ uref -> field_index ] ; if ( cmd == HIDIOCGCOLLECTIONINDEX ) { if ( uref -> usage_index >= field -> maxusage ) goto inval ; } else if ( uref -> usage_index >= field -> report_count ) goto inval ; <S2SV_StartBug> else if ( ( cmd == HIDIOCGUSAGES || cmd == HIDIOCSUSAGES ) && <S2SV_EndBug> ( uref_multi -> num_values > HID_MAX_MULTI_USAGES || uref -> usage_index + uref_multi -> num_values > field -> report_count ) ) goto inval ; <S2SV_StartBug> } <S2SV_EndBug> switch ( cmd ) { case HIDIOCGUSAGE : uref -> value = field -> value [ uref -> usage_index ] ; if ( copy_to_user ( user_arg , uref , sizeof ( * uref ) ) ) goto fault ; goto goodreturn ; case HIDIOCSUSAGE : field -> value [ uref -> usage_index ] = uref -> value ; goto goodreturn ; case HIDIOCGCOLLECTIONINDEX : i = field -> usage [ uref -> usage_index ] . collection_index ; kfree ( uref_multi ) ; return i ; case HIDIOCGUSAGES : for ( i = 0 ; i < uref_multi -> num_values ; i ++ ) uref_multi -> values [ i ] = field -> value [ uref -> usage_index + i ] ; if ( copy_to_user ( user_arg , uref_multi , sizeof ( * uref_multi ) ) ) goto fault ; goto goodreturn ; case HIDIOCSUSAGES : for ( i = 0 ; i < uref_multi -> num_values ; i ++ ) field -> value [ uref -> usage_index + i ] = uref_multi -> values [ i ] ; goto goodreturn ; } goodreturn : kfree ( uref_multi ) ; return 0 ; fault : kfree ( uref_multi ) ; return - EFAULT ; inval : kfree ( uref_multi ) ; return - EINVAL ; } }\n","target":"<S2SV_ModStart> goto inval ; } <S2SV_ModEnd> if ( ( <S2SV_ModStart> goto inval ; <S2SV_ModEnd> switch ( cmd\n","project_and_commit_id":"torvalds@linux/93a2001bdfd5376c3dc2158653034c20392d15c5","cve_id":"CVE-2016-5829","original_address":"https://github.com/torvalds/linux/commit/93a2001bdfd5376c3dc2158653034c20392d15c5","time":"2016-06-27T10:59Z"},
	{"Unnamed: 0":1327,"cwe_id":"CWE-125","source":"CWE-125 void qedi_dbg_err ( struct qedi_dbg_ctx * qedi , const char * func , u32 line , const char * fmt , ... ) { va_list va ; <S2SV_StartBug> struct va_format vaf ; <S2SV_EndBug> char nfunc [ 32 ] ; memset ( nfunc , 0 , sizeof ( nfunc ) ) ; memcpy ( nfunc , func , sizeof ( nfunc ) - 1 ) ; va_start ( va , fmt ) ; vaf . fmt = fmt ; vaf . va = & va ; if ( likely ( qedi ) && likely ( qedi -> pdev ) ) pr_err ( \"[%s]:[%s:%d]:%d:<S2SV_blank>%pV\" , dev_name ( & qedi -> pdev -> dev ) , <S2SV_StartBug> nfunc , line , qedi -> host_no , & vaf ) ; <S2SV_EndBug> else <S2SV_StartBug> pr_err ( \"[0000:00:00.0]:[%s:%d]:<S2SV_blank>%pV\" , nfunc , line , & vaf ) ; <S2SV_EndBug> va_end ( va ) ; }\n","target":"<S2SV_ModStart> struct va_format vaf <S2SV_ModEnd> ; va_start ( <S2SV_ModStart> dev ) , func <S2SV_ModEnd> , line , <S2SV_ModStart> ( \"[0000:00:00.0]:[%s:%d]:<S2SV_blank>%pV\" , func <S2SV_ModEnd> , line ,\n","project_and_commit_id":"torvalds@linux/c09581a52765a85f19fc35340127396d5e3379cc","cve_id":"CVE-2019-15090","original_address":"https://github.com/torvalds/linux/commit/c09581a52765a85f19fc35340127396d5e3379cc","time":"2019-08-16T00:15Z"},
	{"Unnamed: 0":2283,"cwe_id":"CWE-416","source":"CWE-416 static int xfrm_dump_policy_done ( struct netlink_callback * cb ) { <S2SV_StartBug> struct xfrm_policy_walk * walk = ( struct xfrm_policy_walk * ) & cb -> args [ 1 ] ; <S2SV_EndBug> struct net * net = sock_net ( cb -> skb -> sk ) ; xfrm_policy_walk_done ( walk , net ) ; return 0 ; }\n","target":"<S2SV_ModStart> xfrm_policy_walk * ) <S2SV_ModEnd> cb -> args <S2SV_ModStart> cb -> args <S2SV_ModEnd> ; struct net\n","project_and_commit_id":"torvalds@linux/1137b5e2529a8f5ca8ee709288ecba3e68044df2","cve_id":"CVE-2017-16939","original_address":"https://github.com/torvalds/linux/commit/1137b5e2529a8f5ca8ee709288ecba3e68044df2","time":"2017-11-24T10:29Z"},
	{"Unnamed: 0":4673,"cwe_id":"CWE-264","source":"CWE-264 static int sd_ioctl ( struct block_device * bdev , fmode_t mode , unsigned int cmd , unsigned long arg ) { struct gendisk * disk = bdev -> bd_disk ; struct scsi_disk * sdkp = scsi_disk ( disk ) ; struct scsi_device * sdp = sdkp -> device ; void __user * p = ( void __user * ) arg ; int error ; SCSI_LOG_IOCTL ( 1 , sd_printk ( KERN_INFO , sdkp , \"sd_ioctl:<S2SV_blank>disk=%s,<S2SV_blank>\" \"cmd=0x%x\\\\n\" , disk -> disk_name , cmd ) ) ; <S2SV_StartBug> error = scsi_nonblockable_ioctl ( sdp , cmd , p , <S2SV_EndBug> ( mode & FMODE_NDELAY ) != 0 ) ; if ( ! scsi_block_when_processing_errors ( sdp ) || ! error ) goto out ; switch ( cmd ) { case SCSI_IOCTL_GET_IDLUN : case SCSI_IOCTL_GET_BUS_NUMBER : error = scsi_ioctl ( sdp , cmd , p ) ; break ; default : error = scsi_cmd_blk_ioctl ( bdev , mode , cmd , p ) ; if ( error != - ENOTTY ) break ; error = scsi_ioctl ( sdp , cmd , p ) ; break ; } out : return error ; }\n","target":"<S2SV_ModStart> ; error = scsi_verify_blk_ioctl ( bdev , cmd ) ; if ( error < 0 ) return error ; error =\n","project_and_commit_id":"torvalds@linux/0bfc96cb77224736dfa35c3c555d37b3646ef35e","cve_id":"CVE-2011-4127","original_address":"https://github.com/torvalds/linux/commit/0bfc96cb77224736dfa35c3c555d37b3646ef35e","time":"2012-07-03T16:40Z"},
	{"Unnamed: 0":405,"cwe_id":"CWE-119","source":"CWE-119 static int rtmp_packet_read_one_chunk ( URLContext * h , RTMPPacket * p , int chunk_size , RTMPPacket * * prev_pkt_ptr , int * nb_prev_pkt , uint8_t hdr ) { uint8_t buf [ 16 ] ; int channel_id , timestamp , size ; uint32_t ts_field ; uint32_t extra = 0 ; enum RTMPPacketType type ; int written = 0 ; int ret , toread ; RTMPPacket * prev_pkt ; written ++ ; channel_id = hdr & 0x3F ; if ( channel_id < 2 ) { buf [ 1 ] = 0 ; if ( ffurl_read_complete ( h , buf , channel_id + 1 ) != channel_id + 1 ) return AVERROR ( EIO ) ; written += channel_id + 1 ; channel_id = AV_RL16 ( buf ) + 64 ; } if ( ( ret = ff_rtmp_check_alloc_array ( prev_pkt_ptr , nb_prev_pkt , channel_id ) ) < 0 ) return ret ; prev_pkt = * prev_pkt_ptr ; size = prev_pkt [ channel_id ] . size ; type = prev_pkt [ channel_id ] . type ; extra = prev_pkt [ channel_id ] . extra ; hdr >>= 6 ; if ( hdr == RTMP_PS_ONEBYTE ) { ts_field = prev_pkt [ channel_id ] . ts_field ; } else { if ( ffurl_read_complete ( h , buf , 3 ) != 3 ) return AVERROR ( EIO ) ; written += 3 ; ts_field = AV_RB24 ( buf ) ; if ( hdr != RTMP_PS_FOURBYTES ) { if ( ffurl_read_complete ( h , buf , 3 ) != 3 ) return AVERROR ( EIO ) ; written += 3 ; size = AV_RB24 ( buf ) ; if ( ffurl_read_complete ( h , buf , 1 ) != 1 ) return AVERROR ( EIO ) ; written ++ ; type = buf [ 0 ] ; if ( hdr == RTMP_PS_TWELVEBYTES ) { if ( ffurl_read_complete ( h , buf , 4 ) != 4 ) return AVERROR ( EIO ) ; written += 4 ; extra = AV_RL32 ( buf ) ; } } } if ( ts_field == 0xFFFFFF ) { if ( ffurl_read_complete ( h , buf , 4 ) != 4 ) return AVERROR ( EIO ) ; timestamp = AV_RB32 ( buf ) ; } else { timestamp = ts_field ; } if ( hdr != RTMP_PS_TWELVEBYTES ) timestamp += prev_pkt [ channel_id ] . timestamp ; <S2SV_StartBug> if ( ! prev_pkt [ channel_id ] . read ) { <S2SV_EndBug> if ( ( ret = ff_rtmp_packet_create ( p , channel_id , type , timestamp , size ) ) < 0 ) return ret ; p -> read = written ; p -> offset = 0 ; prev_pkt [ channel_id ] . ts_field = ts_field ; prev_pkt [ channel_id ] . timestamp = timestamp ; } else { RTMPPacket * prev = & prev_pkt [ channel_id ] ; p -> data = prev -> data ; p -> size = prev -> size ; p -> channel_id = prev -> channel_id ; p -> type = prev -> type ; p -> ts_field = prev -> ts_field ; p -> extra = prev -> extra ; p -> offset = prev -> offset ; p -> read = prev -> read + written ; p -> timestamp = prev -> timestamp ; prev -> data = NULL ; } p -> extra = extra ; prev_pkt [ channel_id ] . channel_id = channel_id ; prev_pkt [ channel_id ] . type = type ; prev_pkt [ channel_id ] . size = size ; prev_pkt [ channel_id ] . extra = extra ; size = size - p -> offset ; toread = FFMIN ( size , chunk_size ) ; if ( ffurl_read_complete ( h , p -> data + p -> offset , toread ) != toread ) { ff_rtmp_packet_destroy ( p ) ; return AVERROR ( EIO ) ; } size -= toread ; p -> read += toread ; p -> offset += toread ; if ( size > 0 ) { RTMPPacket * prev = & prev_pkt [ channel_id ] ; prev -> data = p -> data ; prev -> read = p -> read ; prev -> offset = p -> offset ; p -> data = NULL ; return AVERROR ( EAGAIN ) ; } prev_pkt [ channel_id ] . read = 0 ; return p -> read ; }\n","target":"<S2SV_ModStart> ; if ( prev_pkt [ channel_id ] . read && size != prev_pkt [ channel_id ] . size ) { av_log ( NULL , AV_LOG_ERROR , \"RTMP<S2SV_blank>packet<S2SV_blank>size<S2SV_blank>mismatch<S2SV_blank>%d<S2SV_blank>!=<S2SV_blank>%d\\\\n\" , size , prev_pkt [ channel_id ] . size ) ; ff_rtmp_packet_destroy ( & prev_pkt [ channel_id ] ) ; prev_pkt [ channel_id ] . read = 0 ; } if (\n","project_and_commit_id":"FFmpeg@FFmpeg/7d57ca4d9a75562fa32e40766211de150f8b3ee7","cve_id":"CVE-2016-10191","original_address":"https://github.com/FFmpeg/FFmpeg/commit/7d57ca4d9a75562fa32e40766211de150f8b3ee7","time":"2017-02-09T15:59Z"},
	{"Unnamed: 0":4874,"cwe_id":"CWE-476","source":"CWE-476 int fscrypt_setup_filename ( struct inode * dir , const struct qstr * iname , int lookup , struct fscrypt_name * fname ) { int ret = 0 , bigname = 0 ; memset ( fname , 0 , sizeof ( struct fscrypt_name ) ) ; fname -> usr_fname = iname ; if ( ! dir -> i_sb -> s_cop -> is_encrypted ( dir ) || fscrypt_is_dot_dotdot ( iname ) ) { fname -> disk_name . name = ( unsigned char * ) iname -> name ; fname -> disk_name . len = iname -> len ; return 0 ; } <S2SV_StartBug> ret = fscrypt_get_crypt_info ( dir ) ; <S2SV_EndBug> if ( ret && ret != - EOPNOTSUPP ) return ret ; if ( dir -> i_crypt_info ) { ret = fscrypt_fname_alloc_buffer ( dir , iname -> len , & fname -> crypto_buf ) ; if ( ret ) return ret ; ret = fname_encrypt ( dir , iname , & fname -> crypto_buf ) ; if ( ret ) goto errout ; fname -> disk_name . name = fname -> crypto_buf . name ; fname -> disk_name . len = fname -> crypto_buf . len ; return 0 ; } if ( ! lookup ) return - ENOKEY ; if ( iname -> name [ 0 ] == '_' ) bigname = 1 ; if ( ( bigname && ( iname -> len != 33 ) ) || ( ! bigname && ( iname -> len > 43 ) ) ) return - ENOENT ; fname -> crypto_buf . name = kmalloc ( 32 , GFP_KERNEL ) ; if ( fname -> crypto_buf . name == NULL ) return - ENOMEM ; ret = digest_decode ( iname -> name + bigname , iname -> len - bigname , fname -> crypto_buf . name ) ; if ( ret < 0 ) { ret = - ENOENT ; goto errout ; } fname -> crypto_buf . len = ret ; if ( bigname ) { memcpy ( & fname -> hash , fname -> crypto_buf . name , 4 ) ; memcpy ( & fname -> minor_hash , fname -> crypto_buf . name + 4 , 4 ) ; } else { fname -> disk_name . name = fname -> crypto_buf . name ; fname -> disk_name . len = fname -> crypto_buf . len ; } return 0 ; errout : fscrypt_fname_free_buffer ( & fname -> crypto_buf ) ; return ret ; }\n","target":"<S2SV_ModStart> } ret = fscrypt_get_encryption_info <S2SV_ModEnd> ( dir )\n","project_and_commit_id":"torvalds@linux/1b53cf9815bb4744958d41f3795d5d5a1d365e2d","cve_id":"CVE-2017-7374","original_address":"https://github.com/torvalds/linux/commit/1b53cf9815bb4744958d41f3795d5d5a1d365e2d","time":"2017-03-31T20:59Z"},
	{"Unnamed: 0":1215,"cwe_id":"CWE-119","source":"CWE-119 int vp8cx_encode_inter_macroblock ( VP8_COMP * cpi , MACROBLOCK * x , TOKENEXTRA * * t , int recon_yoffset , int recon_uvoffset , int mb_row , int mb_col ) { MACROBLOCKD * const xd = & x -> e_mbd ; int intra_error = 0 ; int rate ; int distortion ; x -> skip = 0 ; if ( xd -> segmentation_enabled ) x -> encode_breakout = cpi -> segment_encode_breakout [ xd -> mode_info_context -> mbmi . segment_id ] ; else x -> encode_breakout = cpi -> oxcf . encode_breakout ; # if CONFIG_TEMPORAL_DENOISING x -> best_reference_frame = INTRA_FRAME ; x -> best_zeromv_reference_frame = INTRA_FRAME ; x -> best_sse_inter_mode = 0 ; x -> best_sse_mv . as_int = 0 ; x -> need_to_clamp_best_mvs = 0 ; # endif if ( cpi -> sf . RD ) { int zbin_mode_boost_enabled = x -> zbin_mode_boost_enabled ; if ( cpi -> sf . use_fastquant_for_pick ) { x -> quantize_b = vp8_fast_quantize_b ; <S2SV_StartBug> x -> quantize_b_pair = vp8_fast_quantize_b_pair ; <S2SV_EndBug> x -> zbin_mode_boost_enabled = 0 ; } vp8_rd_pick_inter_mode ( cpi , x , recon_yoffset , recon_uvoffset , & rate , <S2SV_StartBug> & distortion , & intra_error ) ; <S2SV_EndBug> if ( cpi -> sf . improved_quant ) { <S2SV_StartBug> x -> quantize_b = vp8_regular_quantize_b ; <S2SV_EndBug> x -> quantize_b_pair = vp8_regular_quantize_b_pair ; } x -> zbin_mode_boost_enabled = zbin_mode_boost_enabled ; } else { vp8_pick_inter_mode ( cpi , x , recon_yoffset , recon_uvoffset , & rate , & distortion , & intra_error , mb_row , mb_col ) ; } x -> prediction_error += distortion ; x -> intra_error += intra_error ; if ( cpi -> oxcf . tuning == VP8_TUNE_SSIM ) { adjust_act_zbin ( cpi , x ) ; } # if 0 cpi -> frame_distortion += distortion ; cpi -> last_mb_distortion = distortion ; # endif if ( xd -> segmentation_enabled ) { if ( cpi -> current_layer == 0 && cpi -> cyclic_refresh_mode_enabled ) { if ( ( xd -> mode_info_context -> mbmi . segment_id == 1 ) && ( ( xd -> mode_info_context -> mbmi . ref_frame != LAST_FRAME ) || ( xd -> mode_info_context -> mbmi . mode != ZEROMV ) ) ) { xd -> mode_info_context -> mbmi . segment_id = 0 ; vp8cx_mb_init_quantizer ( cpi , x , 1 ) ; } } } { x -> zbin_mode_boost = 0 ; if ( x -> zbin_mode_boost_enabled ) { if ( xd -> mode_info_context -> mbmi . ref_frame != INTRA_FRAME ) { if ( xd -> mode_info_context -> mbmi . mode == ZEROMV ) { if ( xd -> mode_info_context -> mbmi . ref_frame != LAST_FRAME && cpi -> oxcf . number_of_layers == 1 ) x -> zbin_mode_boost = GF_ZEROMV_ZBIN_BOOST ; else x -> zbin_mode_boost = LF_ZEROMV_ZBIN_BOOST ; } else if ( xd -> mode_info_context -> mbmi . mode == SPLITMV ) x -> zbin_mode_boost = 0 ; else x -> zbin_mode_boost = MV_ZBIN_BOOST ; } } if ( cpi -> sf . improved_quant ) vp8_update_zbin_extra ( cpi , x ) ; } x -> count_mb_ref_frame_usage [ xd -> mode_info_context -> mbmi . ref_frame ] ++ ; if ( xd -> mode_info_context -> mbmi . ref_frame == INTRA_FRAME ) { vp8_encode_intra16x16mbuv ( x ) ; if ( xd -> mode_info_context -> mbmi . mode == B_PRED ) { vp8_encode_intra4x4mby ( x ) ; } else { vp8_encode_intra16x16mby ( x ) ; } sum_intra_stats ( cpi , x ) ; } else { int ref_fb_idx ; if ( xd -> mode_info_context -> mbmi . ref_frame == LAST_FRAME ) ref_fb_idx = cpi -> common . lst_fb_idx ; else if ( xd -> mode_info_context -> mbmi . ref_frame == GOLDEN_FRAME ) ref_fb_idx = cpi -> common . gld_fb_idx ; else ref_fb_idx = cpi -> common . alt_fb_idx ; xd -> pre . y_buffer = cpi -> common . yv12_fb [ ref_fb_idx ] . y_buffer + recon_yoffset ; xd -> pre . u_buffer = cpi -> common . yv12_fb [ ref_fb_idx ] . u_buffer + recon_uvoffset ; xd -> pre . v_buffer = cpi -> common . yv12_fb [ ref_fb_idx ] . v_buffer + recon_uvoffset ; if ( ! x -> skip ) { vp8_encode_inter16x16 ( x ) ; } else vp8_build_inter16x16_predictors_mb ( xd , xd -> dst . y_buffer , xd -> dst . u_buffer , xd -> dst . v_buffer , xd -> dst . y_stride , xd -> dst . uv_stride ) ; } if ( ! x -> skip ) { vp8_tokenize_mb ( cpi , x , t ) ; if ( xd -> mode_info_context -> mbmi . mode != B_PRED ) vp8_inverse_transform_mby ( xd ) ; vp8_dequant_idct_add_uv_block ( xd -> qcoeff + 16 * 16 , xd -> dequant_uv , xd -> dst . u_buffer , xd -> dst . v_buffer , xd -> dst . uv_stride , xd -> eobs + 16 ) ; } else { xd -> mode_info_context -> mbmi . mb_skip_coeff = 1 ; if ( cpi -> common . mb_no_coeff_skip ) { x -> skip_true_count ++ ; vp8_fix_contexts ( xd ) ; } else { vp8_stuff_mb ( cpi , x , t ) ; } } return rate ; }\n","target":"<S2SV_ModStart> ; x -> <S2SV_ModEnd> zbin_mode_boost_enabled = 0 <S2SV_ModStart> , & intra_error , mb_row , mb_col <S2SV_ModStart> quantize_b = vp8_regular_quantize_b <S2SV_ModEnd> ; } x\n","project_and_commit_id":"external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426","cve_id":"CVE-2016-1621","original_address":"https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426","time":"2016-03-12T21:59Z"},
	{"Unnamed: 0":2935,"cwe_id":"CWE-125","source":"CWE-125 static void rtc_irq_eoi_tracking_reset ( struct kvm_ioapic * ioapic ) { ioapic -> rtc_status . pending_eoi = 0 ; <S2SV_StartBug> bitmap_zero ( ioapic -> rtc_status . dest_map . map , KVM_MAX_VCPUS ) ; <S2SV_EndBug> }\n","target":"<S2SV_ModStart> . map , KVM_MAX_VCPU_ID <S2SV_ModEnd> ) ; }\n","project_and_commit_id":"torvalds@linux/81cdb259fb6d8c1c4ecfeea389ff5a73c07f5755","cve_id":"CVE-2016-9777","original_address":"https://github.com/torvalds/linux/commit/81cdb259fb6d8c1c4ecfeea389ff5a73c07f5755","time":"2016-12-28T07:59Z"},
	{"Unnamed: 0":2761,"cwe_id":"CWE-125","source":"CWE-125 int SMB2_negotiate ( const unsigned int xid , struct cifs_ses * ses ) { struct smb_rqst rqst ; struct smb2_negotiate_req * req ; struct smb2_negotiate_rsp * rsp ; struct kvec iov [ 1 ] ; struct kvec rsp_iov ; int rc = 0 ; int resp_buftype ; struct TCP_Server_Info * server = ses -> server ; int blob_offset , blob_length ; char * security_blob ; int flags = CIFS_NEG_OP ; unsigned int total_len ; cifs_dbg ( FYI , \"Negotiate<S2SV_blank>protocol\\\\n\" ) ; if ( ! server ) { WARN ( 1 , \"%s:<S2SV_blank>server<S2SV_blank>is<S2SV_blank>NULL!\\\\n\" , __func__ ) ; return - EIO ; } rc = smb2_plain_req_init ( SMB2_NEGOTIATE , NULL , ( void * * ) & req , & total_len ) ; if ( rc ) return rc ; req -> sync_hdr . SessionId = 0 ; memset ( server -> preauth_sha_hash , 0 , SMB2_PREAUTH_HASH_SIZE ) ; memset ( ses -> preauth_sha_hash , 0 , SMB2_PREAUTH_HASH_SIZE ) ; if ( strcmp ( ses -> server -> vals -> version_string , SMB3ANY_VERSION_STRING ) == 0 ) { req -> Dialects [ 0 ] = cpu_to_le16 ( SMB30_PROT_ID ) ; req -> Dialects [ 1 ] = cpu_to_le16 ( SMB302_PROT_ID ) ; req -> DialectCount = cpu_to_le16 ( 2 ) ; total_len += 4 ; } else if ( strcmp ( ses -> server -> vals -> version_string , SMBDEFAULT_VERSION_STRING ) == 0 ) { req -> Dialects [ 0 ] = cpu_to_le16 ( SMB21_PROT_ID ) ; req -> Dialects [ 1 ] = cpu_to_le16 ( SMB30_PROT_ID ) ; req -> Dialects [ 2 ] = cpu_to_le16 ( SMB302_PROT_ID ) ; req -> Dialects [ 3 ] = cpu_to_le16 ( SMB311_PROT_ID ) ; req -> DialectCount = cpu_to_le16 ( 4 ) ; total_len += 8 ; } else { req -> Dialects [ 0 ] = cpu_to_le16 ( ses -> server -> vals -> protocol_id ) ; req -> DialectCount = cpu_to_le16 ( 1 ) ; total_len += 2 ; } if ( ses -> sign ) req -> SecurityMode = cpu_to_le16 ( SMB2_NEGOTIATE_SIGNING_REQUIRED ) ; else if ( global_secflags & CIFSSEC_MAY_SIGN ) req -> SecurityMode = cpu_to_le16 ( SMB2_NEGOTIATE_SIGNING_ENABLED ) ; else req -> SecurityMode = 0 ; req -> Capabilities = cpu_to_le32 ( ses -> server -> vals -> req_capabilities ) ; if ( ses -> server -> vals -> protocol_id == SMB20_PROT_ID ) memset ( req -> ClientGUID , 0 , SMB2_CLIENT_GUID_SIZE ) ; else { memcpy ( req -> ClientGUID , server -> client_guid , SMB2_CLIENT_GUID_SIZE ) ; if ( ( ses -> server -> vals -> protocol_id == SMB311_PROT_ID ) || ( strcmp ( ses -> server -> vals -> version_string , SMBDEFAULT_VERSION_STRING ) == 0 ) ) assemble_neg_contexts ( req , & total_len ) ; } iov [ 0 ] . iov_base = ( char * ) req ; iov [ 0 ] . iov_len = total_len ; memset ( & rqst , 0 , sizeof ( struct smb_rqst ) ) ; rqst . rq_iov = iov ; rqst . rq_nvec = 1 ; rc = cifs_send_recv ( xid , ses , & rqst , & resp_buftype , flags , & rsp_iov ) ; cifs_small_buf_release ( req ) ; rsp = ( struct smb2_negotiate_rsp * ) rsp_iov . iov_base ; if ( rc == - EOPNOTSUPP ) { cifs_dbg ( VFS , \"Dialect<S2SV_blank>not<S2SV_blank>supported<S2SV_blank>by<S2SV_blank>server.<S2SV_blank>Consider<S2SV_blank>\" \"specifying<S2SV_blank>vers=1.0<S2SV_blank>or<S2SV_blank>vers=2.0<S2SV_blank>on<S2SV_blank>mount<S2SV_blank>for<S2SV_blank>accessing\" \"<S2SV_blank>older<S2SV_blank>servers\\\\n\" ) ; goto neg_exit ; } else if ( rc != 0 ) goto neg_exit ; if ( strcmp ( ses -> server -> vals -> version_string , SMB3ANY_VERSION_STRING ) == 0 ) { if ( rsp -> DialectRevision == cpu_to_le16 ( SMB20_PROT_ID ) ) { cifs_dbg ( VFS , \"SMB2<S2SV_blank>dialect<S2SV_blank>returned<S2SV_blank>but<S2SV_blank>not<S2SV_blank>requested\\\\n\" ) ; return - EIO ; } else if ( rsp -> DialectRevision == cpu_to_le16 ( SMB21_PROT_ID ) ) { cifs_dbg ( VFS , \"SMB2.1<S2SV_blank>dialect<S2SV_blank>returned<S2SV_blank>but<S2SV_blank>not<S2SV_blank>requested\\\\n\" ) ; return - EIO ; } } else if ( strcmp ( ses -> server -> vals -> version_string , SMBDEFAULT_VERSION_STRING ) == 0 ) { if ( rsp -> DialectRevision == cpu_to_le16 ( SMB20_PROT_ID ) ) { cifs_dbg ( VFS , \"SMB2<S2SV_blank>dialect<S2SV_blank>returned<S2SV_blank>but<S2SV_blank>not<S2SV_blank>requested\\\\n\" ) ; return - EIO ; } else if ( rsp -> DialectRevision == cpu_to_le16 ( SMB21_PROT_ID ) ) { ses -> server -> ops = & smb21_operations ; <S2SV_StartBug> } else if ( rsp -> DialectRevision == cpu_to_le16 ( SMB311_PROT_ID ) ) <S2SV_EndBug> <S2SV_StartBug> ses -> server -> ops = & smb311_operations ; <S2SV_EndBug> } else if ( le16_to_cpu ( rsp -> DialectRevision ) != ses -> server -> vals -> protocol_id ) { cifs_dbg ( VFS , \"Illegal<S2SV_blank>0x%x<S2SV_blank>dialect<S2SV_blank>returned:<S2SV_blank>not<S2SV_blank>requested\\\\n\" , le16_to_cpu ( rsp -> DialectRevision ) ) ; return - EIO ; } cifs_dbg ( FYI , \"mode<S2SV_blank>0x%x\\\\n\" , rsp -> SecurityMode ) ; if ( rsp -> DialectRevision == cpu_to_le16 ( SMB20_PROT_ID ) ) cifs_dbg ( FYI , \"negotiated<S2SV_blank>smb2.0<S2SV_blank>dialect\\\\n\" ) ; else if ( rsp -> DialectRevision == cpu_to_le16 ( SMB21_PROT_ID ) ) cifs_dbg ( FYI , \"negotiated<S2SV_blank>smb2.1<S2SV_blank>dialect\\\\n\" ) ; else if ( rsp -> DialectRevision == cpu_to_le16 ( SMB30_PROT_ID ) ) cifs_dbg ( FYI , \"negotiated<S2SV_blank>smb3.0<S2SV_blank>dialect\\\\n\" ) ; else if ( rsp -> DialectRevision == cpu_to_le16 ( SMB302_PROT_ID ) ) cifs_dbg ( FYI , \"negotiated<S2SV_blank>smb3.02<S2SV_blank>dialect\\\\n\" ) ; else if ( rsp -> DialectRevision == cpu_to_le16 ( SMB311_PROT_ID ) ) cifs_dbg ( FYI , \"negotiated<S2SV_blank>smb3.1.1<S2SV_blank>dialect\\\\n\" ) ; else { cifs_dbg ( VFS , \"Illegal<S2SV_blank>dialect<S2SV_blank>returned<S2SV_blank>by<S2SV_blank>server<S2SV_blank>0x%x\\\\n\" , le16_to_cpu ( rsp -> DialectRevision ) ) ; rc = - EIO ; goto neg_exit ; } server -> dialect = le16_to_cpu ( rsp -> DialectRevision ) ; memcpy ( server -> preauth_sha_hash , ses -> preauth_sha_hash , SMB2_PREAUTH_HASH_SIZE ) ; server -> negflavor = CIFS_NEGFLAVOR_EXTENDED ; server -> maxBuf = min_t ( unsigned int , le32_to_cpu ( rsp -> MaxTransactSize ) , SMB2_MAX_BUFFER_SIZE ) ; server -> max_read = le32_to_cpu ( rsp -> MaxReadSize ) ; server -> max_write = le32_to_cpu ( rsp -> MaxWriteSize ) ; server -> sec_mode = le16_to_cpu ( rsp -> SecurityMode ) ; if ( ( server -> sec_mode & SMB2_SEC_MODE_FLAGS_ALL ) != server -> sec_mode ) cifs_dbg ( FYI , \"Server<S2SV_blank>returned<S2SV_blank>unexpected<S2SV_blank>security<S2SV_blank>mode<S2SV_blank>0x%x\\\\n\" , server -> sec_mode ) ; server -> capabilities = le32_to_cpu ( rsp -> Capabilities ) ; server -> capabilities |= SMB2_NT_FIND | SMB2_LARGE_FILES ; security_blob = smb2_get_data_area_len ( & blob_offset , & blob_length , ( struct smb2_sync_hdr * ) rsp ) ; if ( blob_length == 0 ) { cifs_dbg ( FYI , \"missing<S2SV_blank>security<S2SV_blank>blob<S2SV_blank>on<S2SV_blank>negprot\\\\n\" ) ; server -> sec_ntlmssp = true ; } rc = cifs_enable_signing ( server , ses -> sign ) ; if ( rc ) goto neg_exit ; if ( blob_length ) { rc = decode_negTokenInit ( security_blob , blob_length , server ) ; if ( rc == 1 ) rc = 0 ; else if ( rc == 0 ) rc = - EIO ; } if ( rsp -> DialectRevision == cpu_to_le16 ( SMB311_PROT_ID ) ) { if ( rsp -> NegotiateContextCount ) rc = smb311_decode_neg_context ( rsp , server , rsp_iov . iov_len ) ; else cifs_dbg ( VFS , \"Missing<S2SV_blank>expected<S2SV_blank>negotiate<S2SV_blank>contexts\\\\n\" ) ; } neg_exit : free_rsp_buf ( resp_buftype , rsp ) ; return rc ; }\n","target":"<S2SV_ModStart> & smb21_operations ; ses -> server -> vals = & smb21_values ; <S2SV_ModStart> SMB311_PROT_ID ) ) { <S2SV_ModStart> & smb311_operations ; ses -> server -> vals = & smb311_values ; }\n","project_and_commit_id":"torvalds@linux/b57a55e2200ede754e4dc9cce4ba9402544b9365","cve_id":"CVE-2019-15918","original_address":"https://github.com/torvalds/linux/commit/b57a55e2200ede754e4dc9cce4ba9402544b9365","time":"2019-09-04T19:15Z"},
	{"Unnamed: 0":1335,"cwe_id":"CWE-388","source":"CWE-388 static void vmx_complete_atomic_exit ( struct vcpu_vmx * vmx ) { u32 exit_intr_info ; if ( ! ( vmx -> exit_reason == EXIT_REASON_MCE_DURING_VMENTRY || vmx -> exit_reason == EXIT_REASON_EXCEPTION_NMI ) ) return ; vmx -> exit_intr_info = vmcs_read32 ( VM_EXIT_INTR_INFO ) ; exit_intr_info = vmx -> exit_intr_info ; if ( is_machine_check ( exit_intr_info ) ) kvm_machine_check ( ) ; <S2SV_StartBug> if ( ( exit_intr_info & INTR_INFO_INTR_TYPE_MASK ) == INTR_TYPE_NMI_INTR && <S2SV_EndBug> ( exit_intr_info & INTR_INFO_VALID_MASK ) ) { kvm_before_handle_nmi ( & vmx -> vcpu ) ; asm ( \"int<S2SV_blank>$2\" ) ; kvm_after_handle_nmi ( & vmx -> vcpu ) ; } }\n","target":"<S2SV_ModStart> ; if ( is_nmi ( exit_intr_info <S2SV_ModEnd> ) ) {\n","project_and_commit_id":"torvalds@linux/ef85b67385436ddc1998f45f1d6a210f935b3388","cve_id":"CVE-2016-9588","original_address":"https://github.com/torvalds/linux/commit/ef85b67385436ddc1998f45f1d6a210f935b3388","time":"2016-12-28T07:59Z"},
	{"Unnamed: 0":4640,"cwe_id":"CWE-399","source":"CWE-399 <S2SV_StartBug> static struct fsnotify_group * inotify_new_group ( struct user_struct * user , unsigned int max_events ) <S2SV_EndBug> { struct fsnotify_group * group ; group = fsnotify_alloc_group ( & inotify_fsnotify_ops ) ; if ( IS_ERR ( group ) ) return group ; group -> max_events = max_events ; spin_lock_init ( & group -> inotify_data . idr_lock ) ; idr_init ( & group -> inotify_data . idr ) ; group -> inotify_data . last_wd = 0 ; <S2SV_StartBug> group -> inotify_data . user = user ; <S2SV_EndBug> <S2SV_StartBug> group -> inotify_data . fa = NULL ; <S2SV_EndBug> return group ; }\n","target":"<S2SV_ModStart> * inotify_new_group ( <S2SV_ModEnd> unsigned int max_events <S2SV_ModStart> -> inotify_data . fa = NULL <S2SV_ModEnd> ; group -> <S2SV_ModStart> -> inotify_data . user = get_current_user ( ) ; if ( atomic_inc_return ( & group -> inotify_data . user -> inotify_devs ) > inotify_max_user_instances ) { fsnotify_put_group ( group ) ; return ERR_PTR ( - EMFILE ) ; } <S2SV_ModEnd> return group ;\n","project_and_commit_id":"torvalds@linux/d0de4dc584ec6aa3b26fffea320a8457827768fc","cve_id":"CVE-2011-1479","original_address":"https://github.com/torvalds/linux/commit/d0de4dc584ec6aa3b26fffea320a8457827768fc","time":"2012-06-21T23:55Z"},
	{"Unnamed: 0":3469,"cwe_id":"CWE-119","source":"CWE-119 static RList * relocs ( RBinFile * arch ) { struct r_bin_bflt_obj * obj = ( struct r_bin_bflt_obj * ) arch -> o -> bin_obj ; RList * list = r_list_newf ( ( RListFree ) free ) ; int i , len , n_got , amount ; if ( ! list || ! obj ) { r_list_free ( list ) ; return NULL ; } if ( obj -> hdr -> flags & FLAT_FLAG_GOTPIC ) { n_got = get_ngot_entries ( obj ) ; if ( n_got ) { amount = n_got * sizeof ( ut32 ) ; if ( amount < n_got || amount > UT32_MAX ) { goto out_error ; } <S2SV_StartBug> struct reloc_struct_t * got_table = calloc ( 1 , n_got * sizeof ( ut32 ) ) ; <S2SV_EndBug> if ( got_table ) { ut32 offset = 0 ; for ( i = 0 ; i < n_got ; offset += 4 , i ++ ) { ut32 got_entry ; if ( obj -> hdr -> data_start + offset + 4 > obj -> size || obj -> hdr -> data_start + offset + 4 < offset ) { break ; } len = r_buf_read_at ( obj -> b , obj -> hdr -> data_start + offset , ( ut8 * ) & got_entry , sizeof ( ut32 ) ) ; if ( ! VALID_GOT_ENTRY ( got_entry ) || len != sizeof ( ut32 ) ) { break ; } got_table [ i ] . addr_to_patch = got_entry ; got_table [ i ] . data_offset = got_entry + BFLT_HDR_SIZE ; } obj -> n_got = n_got ; obj -> got_table = got_table ; } } } if ( obj -> hdr -> reloc_count > 0 ) { int n_reloc = obj -> hdr -> reloc_count ; amount = n_reloc * sizeof ( struct reloc_struct_t ) ; if ( amount < n_reloc || amount > UT32_MAX ) { goto out_error ; } struct reloc_struct_t * reloc_table = calloc ( 1 , amount + 1 ) ; if ( ! reloc_table ) { goto out_error ; } amount = n_reloc * sizeof ( ut32 ) ; if ( amount < n_reloc || amount > UT32_MAX ) { free ( reloc_table ) ; goto out_error ; } ut32 * reloc_pointer_table = calloc ( 1 , amount + 1 ) ; if ( ! reloc_pointer_table ) { free ( reloc_table ) ; goto out_error ; } if ( obj -> hdr -> reloc_start + amount > obj -> size || obj -> hdr -> reloc_start + amount < amount ) { free ( reloc_table ) ; free ( reloc_pointer_table ) ; goto out_error ; } len = r_buf_read_at ( obj -> b , obj -> hdr -> reloc_start , ( ut8 * ) reloc_pointer_table , amount ) ; if ( len != amount ) { free ( reloc_table ) ; free ( reloc_pointer_table ) ; goto out_error ; } for ( i = 0 ; i < obj -> hdr -> reloc_count ; i ++ ) { ut32 reloc_offset = r_swap_ut32 ( reloc_pointer_table [ i ] ) + BFLT_HDR_SIZE ; if ( reloc_offset < obj -> hdr -> bss_end && reloc_offset < obj -> size ) { ut32 reloc_fixed , reloc_data_offset ; if ( reloc_offset + sizeof ( ut32 ) > obj -> size || reloc_offset + sizeof ( ut32 ) < reloc_offset ) { free ( reloc_table ) ; free ( reloc_pointer_table ) ; goto out_error ; } len = r_buf_read_at ( obj -> b , reloc_offset , ( ut8 * ) & reloc_fixed , sizeof ( ut32 ) ) ; if ( len != sizeof ( ut32 ) ) { eprintf ( \"problem<S2SV_blank>while<S2SV_blank>reading<S2SV_blank>relocation<S2SV_blank>entries\\\\n\" ) ; free ( reloc_table ) ; free ( reloc_pointer_table ) ; goto out_error ; } reloc_data_offset = r_swap_ut32 ( reloc_fixed ) + BFLT_HDR_SIZE ; reloc_table [ i ] . addr_to_patch = reloc_offset ; reloc_table [ i ] . data_offset = reloc_data_offset ; RBinReloc * reloc = R_NEW0 ( RBinReloc ) ; if ( reloc ) { reloc -> type = R_BIN_RELOC_32 ; reloc -> paddr = reloc_table [ i ] . addr_to_patch ; reloc -> vaddr = reloc -> paddr ; r_list_append ( list , reloc ) ; } } } free ( reloc_pointer_table ) ; obj -> reloc_table = reloc_table ; } return list ; out_error : r_list_free ( list ) ; return NULL ; }\n","target":"<S2SV_ModStart> * sizeof ( struct reloc_struct_t <S2SV_ModEnd> ) ) ;\n","project_and_commit_id":"radare@radare2/72794dc3523bbd5bb370de3c5857cb736c387e18","cve_id":"CVE-2017-6194","original_address":"https://github.com/radare/radare2/commit/72794dc3523bbd5bb370de3c5857cb736c387e18","time":"2017-04-03T05:59Z"},
	{"Unnamed: 0":389,"cwe_id":"CWE-20","source":"CWE-20 static apr_status_t parse_chunk_size ( http_ctx_t * ctx , const char * buffer , apr_size_t len , int linelimit ) { apr_size_t i = 0 ; while ( i < len ) { char c = buffer [ i ] ; ap_xlate_proto_from_ascii ( & c , 1 ) ; <S2SV_StartBug> if ( ctx -> state == BODY_CHUNK_END ) { <S2SV_EndBug> if ( c == LF ) { <S2SV_StartBug> ctx -> state = BODY_CHUNK ; <S2SV_EndBug> } i ++ ; continue ; } if ( ctx -> state == BODY_CHUNK ) { if ( ! apr_isxdigit ( c ) ) { <S2SV_StartBug> return APR_EGENERAL ; <S2SV_EndBug> } else { ctx -> state = BODY_CHUNK_PART ; } ctx -> remaining = 0 ; <S2SV_StartBug> ctx -> chunkbits = sizeof ( long ) * 8 ; <S2SV_EndBug> ctx -> chunk_used = 0 ; } <S2SV_StartBug> if ( c == ';' || c == CR ) { <S2SV_EndBug> ctx -> state = BODY_CHUNK_EXT ; } <S2SV_StartBug> else if ( c == LF ) { <S2SV_EndBug> if ( ctx -> remaining ) { ctx -> state = BODY_CHUNK_DATA ; } else { ctx -> state = BODY_CHUNK_TRAILER ; } } else if ( ctx -> state != BODY_CHUNK_EXT ) { <S2SV_StartBug> int xvalue = 0 ; <S2SV_EndBug> if ( ! ctx -> remaining && c == '0' ) { i ++ ; <S2SV_StartBug> continue ; <S2SV_EndBug> } if ( c >= '0' && c <= '9' ) { xvalue = c - '0' ; } else if ( c >= 'A' && c <= 'F' ) { xvalue = c - 'A' + 0xa ; } else if ( c >= 'a' && c <= 'f' ) { xvalue = c - 'a' + 0xa ; } else { <S2SV_StartBug> return APR_EGENERAL ; <S2SV_EndBug> } ctx -> remaining = ( ctx -> remaining << 4 ) | xvalue ; <S2SV_StartBug> ctx -> chunkbits -= 4 ; <S2SV_EndBug> if ( ctx -> chunkbits <= 0 || ctx -> remaining < 0 ) { return APR_ENOSPC ; <S2SV_StartBug> } <S2SV_EndBug> } i ++ ; } ctx -> chunk_used += len ; if ( ctx -> chunk_used < 0 || ctx -> chunk_used > linelimit ) { return APR_ENOSPC ; } return APR_SUCCESS ; }\n","target":"<S2SV_ModStart> state == BODY_CHUNK_END || ctx -> state == BODY_CHUNK_END_LF <S2SV_ModStart> state = BODY_CHUNK ; } else if ( c == CR && ctx -> state == BODY_CHUNK_END ) { ctx -> state = BODY_CHUNK_END_LF ; } else { return APR_EINVAL <S2SV_ModStart> ) { return APR_EINVAL <S2SV_ModEnd> ; } else <S2SV_ModStart> = sizeof ( apr_off_t <S2SV_ModEnd> ) * 8 <S2SV_ModStart> ( c == LF ) { if ( ctx -> remaining ) { ctx -> state = BODY_CHUNK_DATA ; } else { ctx -> state = BODY_CHUNK_TRAILER ; } } else if ( ctx -> state == BODY_CHUNK_LF ) { return APR_EINVAL ; } else if ( c == CR ) { ctx -> state = BODY_CHUNK_LF ; } else if ( c == ';' <S2SV_ModEnd> ) { ctx <S2SV_ModStart> else if ( ctx -> state == BODY_CHUNK_EXT ) { if ( c != '\\\\t' && apr_iscntrl ( c ) ) { return APR_EINVAL ; } } else if ( ctx -> state == BODY_CHUNK_PART <S2SV_ModEnd> ) { int <S2SV_ModStart> { int xvalue <S2SV_ModEnd> ; if ( <S2SV_ModStart> ++ ; continue ; } ctx -> chunkbits -= 4 ; if ( ctx -> chunkbits < 0 ) { return APR_ENOSPC <S2SV_ModStart> else { return APR_EINVAL <S2SV_ModEnd> ; } ctx <S2SV_ModStart> | xvalue ; if ( <S2SV_ModEnd> ctx -> remaining <S2SV_ModStart> APR_ENOSPC ; } } else { return APR_EGENERAL ;\n","project_and_commit_id":"apache@httpd/e427c41257957b57036d5a549b260b6185d1dd73","cve_id":"CVE-2015-3183","original_address":"https://github.com/apache/httpd/commit/e427c41257957b57036d5a549b260b6185d1dd73","time":"2015-07-20T23:59Z"},
	{"Unnamed: 0":557,"cwe_id":"CWE-476","source":"CWE-476 unsigned int ipt_do_table ( struct sk_buff * skb , const struct nf_hook_state * state , struct xt_table * table ) { unsigned int hook = state -> hook ; static const char nulldevname [ IFNAMSIZ ] __attribute__ ( ( aligned ( sizeof ( long ) ) ) ) ; const struct iphdr * ip ; unsigned int verdict = NF_DROP ; const char * indev , * outdev ; const void * table_base ; struct ipt_entry * e , * * jumpstack ; unsigned int stackidx , cpu ; const struct xt_table_info * private ; struct xt_action_param acpar ; unsigned int addend ; stackidx = 0 ; ip = ip_hdr ( skb ) ; indev = state -> in ? state -> in -> name : nulldevname ; outdev = state -> out ? state -> out -> name : nulldevname ; acpar . fragoff = ntohs ( ip -> frag_off ) & IP_OFFSET ; acpar . thoff = ip_hdrlen ( skb ) ; acpar . hotdrop = false ; acpar . state = state ; WARN_ON ( ! ( table -> valid_hooks & ( 1 << hook ) ) ) ; local_bh_disable ( ) ; addend = xt_write_recseq_begin ( ) ; private = READ_ONCE ( table -> private ) ; cpu = smp_processor_id ( ) ; table_base = private -> entries ; jumpstack = ( struct ipt_entry * * ) private -> jumpstack [ cpu ] ; if ( static_key_false ( & xt_tee_enabled ) ) jumpstack += private -> stacksize * __this_cpu_read ( nf_skb_duplicated ) ; e = get_entry ( table_base , private -> hook_entry [ hook ] ) ; do { const struct xt_entry_target * t ; const struct xt_entry_match * ematch ; struct xt_counters * counter ; WARN_ON ( ! e ) ; if ( ! ip_packet_match ( ip , indev , outdev , & e -> ip , acpar . fragoff ) ) { no_match : e = ipt_next_entry ( e ) ; continue ; } xt_ematch_foreach ( ematch , e ) { acpar . match = ematch -> u . kernel . match ; acpar . matchinfo = ematch -> data ; if ( ! acpar . match -> match ( skb , & acpar ) ) goto no_match ; } counter = xt_get_this_cpu_counter ( & e -> counters ) ; ADD_COUNTER ( * counter , skb -> len , 1 ) ; t = ipt_get_target ( e ) ; WARN_ON ( ! t -> u . kernel . target ) ; # if IS_ENABLED ( CONFIG_NETFILTER_XT_TARGET_TRACE ) if ( unlikely ( skb -> nf_trace ) ) trace_packet ( state -> net , skb , hook , state -> in , state -> out , table -> name , private , e ) ; # endif if ( ! t -> u . kernel . target -> target ) { int v ; v = ( ( struct xt_standard_target * ) t ) -> verdict ; if ( v < 0 ) { if ( v != XT_RETURN ) { verdict = ( unsigned int ) ( - v ) - 1 ; break ; } if ( stackidx == 0 ) { e = get_entry ( table_base , private -> underflow [ hook ] ) ; } else { e = jumpstack [ -- stackidx ] ; e = ipt_next_entry ( e ) ; } continue ; } if ( table_base + v != ipt_next_entry ( e ) && <S2SV_StartBug> ! ( e -> ip . flags & IPT_F_GOTO ) ) <S2SV_EndBug> jumpstack [ stackidx ++ ] = e ; <S2SV_StartBug> e = get_entry ( table_base , v ) ; <S2SV_EndBug> continue ; } acpar . target = t -> u . kernel . target ; acpar . targinfo = t -> data ; verdict = t -> u . kernel . target -> target ( skb , & acpar ) ; if ( verdict == XT_CONTINUE ) { ip = ip_hdr ( skb ) ; e = ipt_next_entry ( e ) ; } else { break ; } } while ( ! acpar . hotdrop ) ; xt_write_recseq_end ( addend ) ; local_bh_enable ( ) ; if ( acpar . hotdrop ) return NF_DROP ; else return verdict ; }\n","target":"<S2SV_ModStart> IPT_F_GOTO ) ) { if ( unlikely ( stackidx >= private -> stacksize ) ) { verdict = NF_DROP ; break ; } <S2SV_ModStart> = e ; }\n","project_and_commit_id":"torvalds@linux/57ebd808a97d7c5b1e1afb937c2db22beba3c1f8","cve_id":"CVE-2018-1065","original_address":"https://github.com/torvalds/linux/commit/57ebd808a97d7c5b1e1afb937c2db22beba3c1f8","time":"2018-03-02T08:29Z"},
	{"Unnamed: 0":3847,"cwe_id":"CWE-863","source":"CWE-863 static int userfaultfd_unregister ( struct userfaultfd_ctx * ctx , unsigned long arg ) { struct mm_struct * mm = ctx -> mm ; struct vm_area_struct * vma , * prev , * cur ; int ret ; struct uffdio_range uffdio_unregister ; unsigned long new_flags ; bool found ; unsigned long start , end , vma_end ; const void __user * buf = ( void __user * ) arg ; ret = - EFAULT ; if ( copy_from_user ( & uffdio_unregister , buf , sizeof ( uffdio_unregister ) ) ) goto out ; ret = validate_range ( mm , uffdio_unregister . start , uffdio_unregister . len ) ; if ( ret ) goto out ; start = uffdio_unregister . start ; end = start + uffdio_unregister . len ; ret = - ENOMEM ; if ( ! mmget_not_zero ( mm ) ) goto out ; down_write ( & mm -> mmap_sem ) ; vma = find_vma_prev ( mm , start , & prev ) ; if ( ! vma ) goto out_unlock ; ret = - EINVAL ; if ( vma -> vm_start >= end ) goto out_unlock ; if ( is_vm_hugetlb_page ( vma ) ) { unsigned long vma_hpagesize = vma_kernel_pagesize ( vma ) ; if ( start & ( vma_hpagesize - 1 ) ) goto out_unlock ; } found = false ; ret = - EINVAL ; for ( cur = vma ; cur && cur -> vm_start < end ; cur = cur -> vm_next ) { cond_resched ( ) ; BUG_ON ( ! ! cur -> vm_userfaultfd_ctx . ctx ^ ! ! ( cur -> vm_flags & ( VM_UFFD_MISSING | VM_UFFD_WP ) ) ) ; if ( ! vma_can_userfault ( cur ) ) goto out_unlock ; found = true ; } BUG_ON ( ! found ) ; if ( vma -> vm_start < start ) prev = vma ; ret = 0 ; do { cond_resched ( ) ; BUG_ON ( ! vma_can_userfault ( vma ) ) ; <S2SV_StartBug> if ( ! vma -> vm_userfaultfd_ctx . ctx ) <S2SV_EndBug> goto skip ; if ( vma -> vm_start > start ) start = vma -> vm_start ; vma_end = min ( end , vma -> vm_end ) ; if ( userfaultfd_missing ( vma ) ) { struct userfaultfd_wake_range range ; range . start = start ; range . len = vma_end - start ; wake_userfault ( vma -> vm_userfaultfd_ctx . ctx , & range ) ; } new_flags = vma -> vm_flags & ~ ( VM_UFFD_MISSING | VM_UFFD_WP ) ; prev = vma_merge ( mm , prev , start , vma_end , new_flags , vma -> anon_vma , vma -> vm_file , vma -> vm_pgoff , vma_policy ( vma ) , NULL_VM_UFFD_CTX ) ; if ( prev ) { vma = prev ; goto next ; } if ( vma -> vm_start < start ) { ret = split_vma ( mm , vma , start , 1 ) ; if ( ret ) break ; } if ( vma -> vm_end > end ) { ret = split_vma ( mm , vma , end , 0 ) ; if ( ret ) break ; } next : vma -> vm_flags = new_flags ; vma -> vm_userfaultfd_ctx = NULL_VM_UFFD_CTX ; skip : prev = vma ; start = vma -> vm_end ; vma = vma -> vm_next ; } while ( vma && vma -> vm_start < end ) ; out_unlock : up_write ( & mm -> mmap_sem ) ; mmput ( mm ) ; out : return ret ; }\n","target":"<S2SV_ModStart> ) ) ; WARN_ON ( ! ( vma -> vm_flags & VM_MAYWRITE ) ) ;\n","project_and_commit_id":"torvalds@linux/29ec90660d68bbdd69507c1c8b4e33aa299278b1","cve_id":"CVE-2018-18397","original_address":"https://github.com/torvalds/linux/commit/29ec90660d68bbdd69507c1c8b4e33aa299278b1","time":"2018-12-12T10:29Z"},
	{"Unnamed: 0":1628,"cwe_id":"CWE-125","source":"CWE-125 PyObject * ast2obj_keyword ( void * _o ) { keyword_ty o = ( keyword_ty ) _o ; PyObject * result = NULL , * value = NULL ; if ( ! o ) { <S2SV_StartBug> Py_INCREF ( Py_None ) ; <S2SV_EndBug> return Py_None ; } result = PyType_GenericNew ( keyword_type , NULL , NULL ) ; if ( ! result ) return NULL ; value = ast2obj_identifier ( o -> arg ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_arg , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; value = ast2obj_expr ( o -> value ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_value , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; return result ; failed : Py_XDECREF ( value ) ; Py_XDECREF ( result ) ; return NULL ; }\n","target":"<S2SV_ModStart> o ) { Py_RETURN_NONE <S2SV_ModEnd> ; } result\n","project_and_commit_id":"python@typed_ast/156afcb26c198e162504a57caddfe0acd9ed7dce","cve_id":"CVE-2019-19275","original_address":"https://github.com/python/typed_ast/commit/156afcb26c198e162504a57caddfe0acd9ed7dce","time":"2019-11-26T15:15Z"},
	{"Unnamed: 0":3494,"cwe_id":"CWE-264","source":"CWE-264 struct sock * cookie_v6_check ( struct sock * sk , struct sk_buff * skb ) { struct tcp_options_received tcp_opt ; struct inet_request_sock * ireq ; struct tcp_request_sock * treq ; struct ipv6_pinfo * np = inet6_sk ( sk ) ; struct tcp_sock * tp = tcp_sk ( sk ) ; const struct tcphdr * th = tcp_hdr ( skb ) ; __u32 cookie = ntohl ( th -> ack_seq ) - 1 ; struct sock * ret = sk ; struct request_sock * req ; int mss ; struct dst_entry * dst ; __u8 rcv_wscale ; if ( ! sysctl_tcp_syncookies || ! th -> ack || th -> rst ) goto out ; if ( tcp_synq_no_recent_overflow ( sk ) ) goto out ; mss = __cookie_v6_check ( ipv6_hdr ( skb ) , th , cookie ) ; if ( mss == 0 ) { NET_INC_STATS_BH ( sock_net ( sk ) , LINUX_MIB_SYNCOOKIESFAILED ) ; goto out ; } NET_INC_STATS_BH ( sock_net ( sk ) , LINUX_MIB_SYNCOOKIESRECV ) ; memset ( & tcp_opt , 0 , sizeof ( tcp_opt ) ) ; tcp_parse_options ( skb , & tcp_opt , 0 , NULL ) ; if ( ! cookie_timestamp_decode ( & tcp_opt ) ) goto out ; ret = NULL ; req = inet_reqsk_alloc ( & tcp6_request_sock_ops , sk , false ) ; if ( ! req ) goto out ; ireq = inet_rsk ( req ) ; treq = tcp_rsk ( req ) ; treq -> tfo_listener = false ; if ( security_inet_conn_request ( sk , skb , req ) ) goto out_free ; req -> mss = mss ; ireq -> ir_rmt_port = th -> source ; ireq -> ir_num = ntohs ( th -> dest ) ; ireq -> ir_v6_rmt_addr = ipv6_hdr ( skb ) -> saddr ; ireq -> ir_v6_loc_addr = ipv6_hdr ( skb ) -> daddr ; if ( ipv6_opt_accepted ( sk , skb , & TCP_SKB_CB ( skb ) -> header . h6 ) || np -> rxopt . bits . rxinfo || np -> rxopt . bits . rxoinfo || np -> rxopt . bits . rxhlim || np -> rxopt . bits . rxohlim ) { atomic_inc ( & skb -> users ) ; ireq -> pktopts = skb ; } ireq -> ir_iif = sk -> sk_bound_dev_if ; if ( ! sk -> sk_bound_dev_if && ipv6_addr_type ( & ireq -> ir_v6_rmt_addr ) & IPV6_ADDR_LINKLOCAL ) ireq -> ir_iif = tcp_v6_iif ( skb ) ; ireq -> ir_mark = inet_request_mark ( sk , skb ) ; req -> num_retrans = 0 ; ireq -> snd_wscale = tcp_opt . snd_wscale ; ireq -> sack_ok = tcp_opt . sack_ok ; ireq -> wscale_ok = tcp_opt . wscale_ok ; ireq -> tstamp_ok = tcp_opt . saw_tstamp ; req -> ts_recent = tcp_opt . saw_tstamp ? tcp_opt . rcv_tsval : 0 ; treq -> snt_synack . v64 = 0 ; treq -> rcv_isn = ntohl ( th -> seq ) - 1 ; treq -> snt_isn = cookie ; { struct in6_addr * final_p , final ; struct flowi6 fl6 ; memset ( & fl6 , 0 , sizeof ( fl6 ) ) ; fl6 . flowi6_proto = IPPROTO_TCP ; fl6 . daddr = ireq -> ir_v6_rmt_addr ; <S2SV_StartBug> final_p = fl6_update_dst ( & fl6 , np -> opt , & final ) ; <S2SV_EndBug> fl6 . saddr = ireq -> ir_v6_loc_addr ; fl6 . flowi6_oif = sk -> sk_bound_dev_if ; fl6 . flowi6_mark = ireq -> ir_mark ; fl6 . fl6_dport = ireq -> ir_rmt_port ; fl6 . fl6_sport = inet_sk ( sk ) -> inet_sport ; security_req_classify_flow ( req , flowi6_to_flowi ( & fl6 ) ) ; dst = ip6_dst_lookup_flow ( sk , & fl6 , final_p ) ; if ( IS_ERR ( dst ) ) goto out_free ; } req -> rsk_window_clamp = tp -> window_clamp ? : dst_metric ( dst , RTAX_WINDOW ) ; tcp_select_initial_window ( tcp_full_space ( sk ) , req -> mss , & req -> rsk_rcv_wnd , & req -> rsk_window_clamp , ireq -> wscale_ok , & rcv_wscale , dst_metric ( dst , RTAX_INITRWND ) ) ; ireq -> rcv_wscale = rcv_wscale ; ireq -> ecn_ok = cookie_ecn_ok ( & tcp_opt , sock_net ( sk ) , dst ) ; ret = tcp_get_cookie_sock ( sk , skb , req , dst ) ; out : return ret ; out_free : reqsk_free ( req ) ; return NULL ; }\n","target":"<S2SV_ModStart> & fl6 , rcu_dereference ( <S2SV_ModStart> np -> opt )\n","project_and_commit_id":"torvalds@linux/45f6fad84cc305103b28d73482b344d7f5b76f39","cve_id":"CVE-2016-3841","original_address":"https://github.com/torvalds/linux/commit/45f6fad84cc305103b28d73482b344d7f5b76f39","time":"2016-08-06T20:59Z"},
	{"Unnamed: 0":998,"cwe_id":"CWE-119","source":"CWE-119 int l2tp_packet_send ( int sock , struct l2tp_packet_t * pack ) { <S2SV_StartBug> uint8_t * buf = mempool_alloc ( buf_pool ) ; <S2SV_EndBug> struct l2tp_avp_t * avp ; struct l2tp_attr_t * attr ; <S2SV_StartBug> uint8_t * ptr ; <S2SV_EndBug> <S2SV_StartBug> int n ; <S2SV_EndBug> int len = sizeof ( pack -> hdr ) ; if ( ! buf ) { log_emerg ( \"l2tp:<S2SV_blank>out<S2SV_blank>of<S2SV_blank>memory\\\\n\" ) ; return - 1 ; } memset ( buf , 0 , L2TP_MAX_PACKET_SIZE ) ; <S2SV_StartBug> ptr = buf + sizeof ( pack -> hdr ) ; <S2SV_EndBug> list_for_each_entry ( attr , & pack -> attrs , entry ) { if ( len + sizeof ( * avp ) + attr -> length >= L2TP_MAX_PACKET_SIZE ) { log_error ( \"l2tp:<S2SV_blank>cann\\'t<S2SV_blank>send<S2SV_blank>packet<S2SV_blank>(exceeds<S2SV_blank>maximum<S2SV_blank>size)\\\\n\" ) ; mempool_free ( buf ) ; return - 1 ; } avp = ( struct l2tp_avp_t * ) ptr ; avp -> type = htons ( attr -> attr -> id ) ; <S2SV_StartBug> avp -> M = attr -> M ; <S2SV_EndBug> avp -> H = attr -> H ; <S2SV_StartBug> avp -> length = sizeof ( * avp ) + attr -> length ; <S2SV_EndBug> * ( uint16_t * ) ptr = htons ( * ( uint16_t * ) ptr ) ; if ( attr -> H ) memcpy ( avp -> val , attr -> val . octets , attr -> length ) ; else switch ( attr -> attr -> type ) { case ATTR_TYPE_INT16 : * ( int16_t * ) avp -> val = htons ( attr -> val . int16 ) ; break ; case ATTR_TYPE_INT32 : * ( int32_t * ) avp -> val = htonl ( attr -> val . int32 ) ; break ; case ATTR_TYPE_INT64 : * ( uint64_t * ) avp -> val = htobe64 ( attr -> val . uint64 ) ; break ; case ATTR_TYPE_STRING : case ATTR_TYPE_OCTETS : memcpy ( avp -> val , attr -> val . string , attr -> length ) ; break ; } ptr += sizeof ( * avp ) + attr -> length ; len += sizeof ( * avp ) + attr -> length ; } pack -> hdr . length = htons ( len ) ; memcpy ( buf , & pack -> hdr , sizeof ( pack -> hdr ) ) ; <S2SV_StartBug> n = sendto ( sock , buf , ntohs ( pack -> hdr . length ) , 0 , <S2SV_EndBug> & pack -> addr , sizeof ( pack -> addr ) ) ; mempool_free ( buf ) ; if ( n < 0 ) { if ( errno == EAGAIN ) { if ( conf_verbose ) log_warn ( \"l2tp:<S2SV_blank>buffer<S2SV_blank>overflow<S2SV_blank>(packet<S2SV_blank>lost)\\\\n\" ) ; } else { if ( conf_verbose ) log_warn ( \"l2tp:<S2SV_blank>sendto:<S2SV_blank>%s\\\\n\" , strerror ( errno ) ) ; return - 1 ; } } <S2SV_StartBug> if ( n != ntohs ( pack -> hdr . length ) ) { <S2SV_EndBug> if ( conf_verbose ) <S2SV_StartBug> log_warn ( \"l2tp:<S2SV_blank>short<S2SV_blank>write<S2SV_blank>(%i/%i)\\\\n\" , n , ntohs ( pack -> hdr . length ) ) ; <S2SV_EndBug> } return 0 ; }\n","target":"<S2SV_ModStart> pack ) { struct l2tp_hdr_t * hdr <S2SV_ModEnd> ; struct l2tp_avp_t <S2SV_ModStart> ; uint8_t * buf , * <S2SV_ModStart> ; int n , len ; buf = mempool_alloc ( buf_pool <S2SV_ModEnd> ) ; if <S2SV_ModStart> L2TP_MAX_PACKET_SIZE ) ; hdr = ( struct l2tp_hdr_t * ) buf ; ptr = ( uint8_t * ) ( hdr + 1 ) ; len = <S2SV_ModEnd> sizeof ( pack <S2SV_ModStart> ; avp -> flags = htons ( ( attr -> M ? L2TP_AVP_FLAG_M : 0 ) | ( attr -> H ? L2TP_AVP_FLAG_H : 0 ) | ( ( <S2SV_ModEnd> sizeof ( * <S2SV_ModStart> attr -> length ) & L2TP_AVP_LEN_MASK ) <S2SV_ModEnd> ) ; if <S2SV_ModStart> ) ) ; hdr -> flags = htons ( pack -> hdr . flags ) ; <S2SV_ModStart> , buf , len <S2SV_ModEnd> , 0 , <S2SV_ModStart> ( n != len <S2SV_ModEnd> ) { if <S2SV_ModStart> , n , len <S2SV_ModEnd> ) ; }\n","project_and_commit_id":"accel-ppp@accel-ppp/2324bcd5ba12cf28f47357a8f03cd41b7c04c52b","cve_id":"CVE-2020-15173","original_address":"https://github.com/accel-ppp/accel-ppp/commit/2324bcd5ba12cf28f47357a8f03cd41b7c04c52b","time":"2020-09-09T23:15Z"},
	{"Unnamed: 0":6478,"cwe_id":"CWE-119","source":"CWE-119 static int check_alu_op ( struct bpf_verifier_env * env , struct bpf_insn * insn ) { struct bpf_reg_state * regs = cur_regs ( env ) ; u8 opcode = BPF_OP ( insn -> code ) ; int err ; if ( opcode == BPF_END || opcode == BPF_NEG ) { if ( opcode == BPF_NEG ) { if ( BPF_SRC ( insn -> code ) != 0 || insn -> src_reg != BPF_REG_0 || insn -> off != 0 || insn -> imm != 0 ) { verbose ( env , \"BPF_NEG<S2SV_blank>uses<S2SV_blank>reserved<S2SV_blank>fields\\\\n\" ) ; return - EINVAL ; } } else { if ( insn -> src_reg != BPF_REG_0 || insn -> off != 0 || ( insn -> imm != 16 && insn -> imm != 32 && insn -> imm != 64 ) || BPF_CLASS ( insn -> code ) == BPF_ALU64 ) { verbose ( env , \"BPF_END<S2SV_blank>uses<S2SV_blank>reserved<S2SV_blank>fields\\\\n\" ) ; return - EINVAL ; } } err = check_reg_arg ( env , insn -> dst_reg , SRC_OP ) ; if ( err ) return err ; if ( is_pointer_value ( env , insn -> dst_reg ) ) { verbose ( env , \"R%d<S2SV_blank>pointer<S2SV_blank>arithmetic<S2SV_blank>prohibited\\\\n\" , insn -> dst_reg ) ; return - EACCES ; } err = check_reg_arg ( env , insn -> dst_reg , DST_OP ) ; if ( err ) return err ; } else if ( opcode == BPF_MOV ) { if ( BPF_SRC ( insn -> code ) == BPF_X ) { if ( insn -> imm != 0 || insn -> off != 0 ) { verbose ( env , \"BPF_MOV<S2SV_blank>uses<S2SV_blank>reserved<S2SV_blank>fields\\\\n\" ) ; return - EINVAL ; } err = check_reg_arg ( env , insn -> src_reg , SRC_OP ) ; if ( err ) return err ; } else { if ( insn -> src_reg != BPF_REG_0 || insn -> off != 0 ) { verbose ( env , \"BPF_MOV<S2SV_blank>uses<S2SV_blank>reserved<S2SV_blank>fields\\\\n\" ) ; return - EINVAL ; } } err = check_reg_arg ( env , insn -> dst_reg , DST_OP ) ; if ( err ) return err ; if ( BPF_SRC ( insn -> code ) == BPF_X ) { if ( BPF_CLASS ( insn -> code ) == BPF_ALU64 ) { regs [ insn -> dst_reg ] = regs [ insn -> src_reg ] ; regs [ insn -> dst_reg ] . live |= REG_LIVE_WRITTEN ; } else { if ( is_pointer_value ( env , insn -> src_reg ) ) { verbose ( env , \"R%d<S2SV_blank>partial<S2SV_blank>copy<S2SV_blank>of<S2SV_blank>pointer\\\\n\" , insn -> src_reg ) ; return - EACCES ; } mark_reg_unknown ( env , regs , insn -> dst_reg ) ; <S2SV_StartBug> regs [ insn -> dst_reg ] . var_off = tnum_cast ( <S2SV_EndBug> regs [ insn -> dst_reg ] . var_off , 4 ) ; <S2SV_StartBug> __update_reg_bounds ( & regs [ insn -> dst_reg ] ) ; <S2SV_EndBug> } } else { regs [ insn -> dst_reg ] . type = SCALAR_VALUE ; if ( BPF_CLASS ( insn -> code ) == BPF_ALU64 ) { __mark_reg_known ( regs + insn -> dst_reg , insn -> imm ) ; } else { __mark_reg_known ( regs + insn -> dst_reg , ( u32 ) insn -> imm ) ; } } } else if ( opcode > BPF_END ) { verbose ( env , \"invalid<S2SV_blank>BPF_ALU<S2SV_blank>opcode<S2SV_blank>%x\\\\n\" , opcode ) ; return - EINVAL ; } else { if ( BPF_SRC ( insn -> code ) == BPF_X ) { if ( insn -> imm != 0 || insn -> off != 0 ) { verbose ( env , \"BPF_ALU<S2SV_blank>uses<S2SV_blank>reserved<S2SV_blank>fields\\\\n\" ) ; return - EINVAL ; } err = check_reg_arg ( env , insn -> src_reg , SRC_OP ) ; if ( err ) return err ; } else { if ( insn -> src_reg != BPF_REG_0 || insn -> off != 0 ) { verbose ( env , \"BPF_ALU<S2SV_blank>uses<S2SV_blank>reserved<S2SV_blank>fields\\\\n\" ) ; return - EINVAL ; } } err = check_reg_arg ( env , insn -> dst_reg , SRC_OP ) ; if ( err ) return err ; if ( ( opcode == BPF_MOD || opcode == BPF_DIV ) && BPF_SRC ( insn -> code ) == BPF_K && insn -> imm == 0 ) { verbose ( env , \"div<S2SV_blank>by<S2SV_blank>zero\\\\n\" ) ; return - EINVAL ; } if ( ( opcode == BPF_LSH || opcode == BPF_RSH || opcode == BPF_ARSH ) && BPF_SRC ( insn -> code ) == BPF_K ) { int size = BPF_CLASS ( insn -> code ) == BPF_ALU64 ? 64 : 32 ; if ( insn -> imm < 0 || insn -> imm >= size ) { verbose ( env , \"invalid<S2SV_blank>shift<S2SV_blank>%d\\\\n\" , insn -> imm ) ; return - EINVAL ; } } err = check_reg_arg ( env , insn -> dst_reg , DST_OP_NO_MARK ) ; if ( err ) return err ; return adjust_reg_min_max_vals ( env , insn ) ; } return 0 ; }\n","target":"<S2SV_ModStart> dst_reg ) ; coerce_reg_to_size <S2SV_ModEnd> ( & regs <S2SV_ModStart> -> dst_reg ] , 4\n","project_and_commit_id":"torvalds@linux/0c17d1d2c61936401f4702e1846e2c19b200f958","cve_id":"CVE-2017-16996","original_address":"https://github.com/torvalds/linux/commit/0c17d1d2c61936401f4702e1846e2c19b200f958","time":"2017-12-27T17:08Z"},
	{"Unnamed: 0":757,"cwe_id":"CWE-125","source":"CWE-125 static Image * ReadMATImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { Image * image , * image2 = NULL , * rotated_image ; register Quantum * q ; unsigned int status ; MATHeader MATLAB_HDR ; size_t size ; size_t CellType ; QuantumInfo * quantum_info ; ImageInfo * clone_info ; int i ; ssize_t ldblk ; unsigned char * BImgBuff = NULL ; double MinVal , MaxVal ; unsigned z , z2 ; unsigned Frames ; int logging ; int sample_size ; MagickOffsetType filepos = 0x80 ; BlobInfo * blob ; size_t one ; unsigned int ( * ReadBlobXXXLong ) ( Image * image ) ; unsigned short ( * ReadBlobXXXShort ) ( Image * image ) ; void ( * ReadBlobDoublesXXX ) ( Image * image , size_t len , double * data ) ; void ( * ReadBlobFloatsXXX ) ( Image * image , size_t len , float * data ) ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickCoreSignature ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickCoreSignature ) ; logging = LogMagickEvent ( CoderEvent , GetMagickModule ( ) , \"enter\" ) ; image = AcquireImage ( image_info , exception ) ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } clone_info = CloneImageInfo ( image_info ) ; if ( ReadBlob ( image , 124 , ( unsigned char * ) & MATLAB_HDR . identific ) != 124 ) ThrowReaderException ( CorruptImageError , \"ImproperImageHeader\" ) ; MATLAB_HDR . Version = ReadBlobLSBShort ( image ) ; if ( ReadBlob ( image , 2 , ( unsigned char * ) & MATLAB_HDR . EndianIndicator ) != 2 ) ThrowReaderException ( CorruptImageError , \"ImproperImageHeader\" ) ; if ( logging ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , \"<S2SV_blank><S2SV_blank>Endian<S2SV_blank>%c%c\" , MATLAB_HDR . EndianIndicator [ 0 ] , MATLAB_HDR . EndianIndicator [ 1 ] ) ; if ( ! strncmp ( MATLAB_HDR . EndianIndicator , \"IM\" , 2 ) ) { ReadBlobXXXLong = ReadBlobLSBLong ; ReadBlobXXXShort = ReadBlobLSBShort ; ReadBlobDoublesXXX = ReadBlobDoublesLSB ; ReadBlobFloatsXXX = ReadBlobFloatsLSB ; image -> endian = LSBEndian ; } else if ( ! strncmp ( MATLAB_HDR . EndianIndicator , \"MI\" , 2 ) ) { ReadBlobXXXLong = ReadBlobMSBLong ; ReadBlobXXXShort = ReadBlobMSBShort ; ReadBlobDoublesXXX = ReadBlobDoublesMSB ; ReadBlobFloatsXXX = ReadBlobFloatsMSB ; image -> endian = MSBEndian ; } else goto MATLAB_KO ; if ( strncmp ( MATLAB_HDR . identific , \"MATLAB\" , 6 ) ) MATLAB_KO : ThrowReaderException ( CorruptImageError , \"ImproperImageHeader\" ) ; filepos = TellBlob ( image ) ; while ( ! EOFBlob ( image ) ) { Frames = 1 ; ( void ) SeekBlob ( image , filepos , SEEK_SET ) ; MATLAB_HDR . DataType = ReadBlobXXXLong ( image ) ; if ( EOFBlob ( image ) ) break ; MATLAB_HDR . ObjectSize = ReadBlobXXXLong ( image ) ; if ( EOFBlob ( image ) ) break ; filepos += MATLAB_HDR . ObjectSize + 4 + 4 ; image2 = image ; # if defined ( MAGICKCORE_ZLIB_DELEGATE ) if ( MATLAB_HDR . DataType == miCOMPRESSED ) { image2 = DecompressBlock ( image , MATLAB_HDR . ObjectSize , clone_info , exception ) ; if ( image2 == NULL ) continue ; MATLAB_HDR . DataType = ReadBlobXXXLong ( image2 ) ; } # endif if ( MATLAB_HDR . DataType != miMATRIX ) continue ; MATLAB_HDR . unknown1 = ReadBlobXXXLong ( image2 ) ; MATLAB_HDR . unknown2 = ReadBlobXXXLong ( image2 ) ; MATLAB_HDR . unknown5 = ReadBlobXXXLong ( image2 ) ; MATLAB_HDR . StructureClass = MATLAB_HDR . unknown5 & 0xFF ; MATLAB_HDR . StructureFlag = ( MATLAB_HDR . unknown5 >> 8 ) & 0xFF ; MATLAB_HDR . unknown3 = ReadBlobXXXLong ( image2 ) ; if ( image != image2 ) MATLAB_HDR . unknown4 = ReadBlobXXXLong ( image2 ) ; MATLAB_HDR . unknown4 = ReadBlobXXXLong ( image2 ) ; MATLAB_HDR . DimFlag = ReadBlobXXXLong ( image2 ) ; MATLAB_HDR . SizeX = ReadBlobXXXLong ( image2 ) ; MATLAB_HDR . SizeY = ReadBlobXXXLong ( image2 ) ; switch ( MATLAB_HDR . DimFlag ) { case 8 : z2 = z = 1 ; break ; case 12 : z2 = z = ReadBlobXXXLong ( image2 ) ; ( void ) ReadBlobXXXLong ( image2 ) ; if ( z != 3 ) ThrowReaderException ( CoderError , \"MultidimensionalMatricesAreNotSupported\" ) ; break ; case 16 : z2 = z = ReadBlobXXXLong ( image2 ) ; if ( z != 3 && z != 1 ) ThrowReaderException ( CoderError , \"MultidimensionalMatricesAreNotSupported\" ) ; Frames = ReadBlobXXXLong ( image2 ) ; break ; default : ThrowReaderException ( CoderError , \"MultidimensionalMatricesAreNotSupported\" ) ; } MATLAB_HDR . Flag1 = ReadBlobXXXShort ( image2 ) ; MATLAB_HDR . NameFlag = ReadBlobXXXShort ( image2 ) ; if ( logging ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , \"MATLAB_HDR.StructureClass<S2SV_blank>%d\" , MATLAB_HDR . StructureClass ) ; if ( MATLAB_HDR . StructureClass != mxCHAR_CLASS && MATLAB_HDR . StructureClass != mxSINGLE_CLASS && MATLAB_HDR . StructureClass != mxDOUBLE_CLASS && MATLAB_HDR . StructureClass != mxINT8_CLASS && MATLAB_HDR . StructureClass != mxUINT8_CLASS && MATLAB_HDR . StructureClass != mxINT16_CLASS && MATLAB_HDR . StructureClass != mxUINT16_CLASS && MATLAB_HDR . StructureClass != mxINT32_CLASS && MATLAB_HDR . StructureClass != mxUINT32_CLASS && MATLAB_HDR . StructureClass != mxINT64_CLASS && MATLAB_HDR . StructureClass != mxUINT64_CLASS ) ThrowReaderException ( CoderError , \"UnsupportedCellTypeInTheMatrix\" ) ; switch ( MATLAB_HDR . NameFlag ) { case 0 : size = ReadBlobXXXLong ( image2 ) ; size = 4 * ( ssize_t ) ( ( size + 3 + 1 ) / 4 ) ; ( void ) SeekBlob ( image2 , size , SEEK_CUR ) ; break ; case 1 : case 2 : case 3 : case 4 : ( void ) ReadBlob ( image2 , 4 , ( unsigned char * ) & size ) ; break ; default : goto MATLAB_KO ; } CellType = ReadBlobXXXLong ( image2 ) ; if ( logging ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , \"MATLAB_HDR.CellType:<S2SV_blank>%.20g\" , ( double ) CellType ) ; ( void ) ReadBlob ( image2 , 4 , ( unsigned char * ) & size ) ; NEXT_FRAME : switch ( CellType ) { case miINT8 : case miUINT8 : sample_size = 8 ; if ( MATLAB_HDR . StructureFlag & FLAG_LOGICAL ) image -> depth = 1 ; else image -> depth = 8 ; ldblk = ( ssize_t ) MATLAB_HDR . SizeX ; break ; case miINT16 : case miUINT16 : sample_size = 16 ; image -> depth = 16 ; ldblk = ( ssize_t ) ( 2 * MATLAB_HDR . SizeX ) ; break ; case miINT32 : case miUINT32 : sample_size = 32 ; image -> depth = 32 ; ldblk = ( ssize_t ) ( 4 * MATLAB_HDR . SizeX ) ; break ; case miINT64 : case miUINT64 : sample_size = 64 ; image -> depth = 64 ; ldblk = ( ssize_t ) ( 8 * MATLAB_HDR . SizeX ) ; break ; case miSINGLE : sample_size = 32 ; image -> depth = 32 ; ( void ) SetImageOption ( clone_info , \"quantum:format\" , \"floating-point\" ) ; if ( MATLAB_HDR . StructureFlag & FLAG_COMPLEX ) { } ldblk = ( ssize_t ) ( 4 * MATLAB_HDR . SizeX ) ; break ; case miDOUBLE : sample_size = 64 ; image -> depth = 64 ; ( void ) SetImageOption ( clone_info , \"quantum:format\" , \"floating-point\" ) ; DisableMSCWarning ( 4127 ) if ( sizeof ( double ) != 8 ) RestoreMSCWarning ThrowReaderException ( CoderError , \"IncompatibleSizeOfDouble\" ) ; if ( MATLAB_HDR . StructureFlag & FLAG_COMPLEX ) { } ldblk = ( ssize_t ) ( 8 * MATLAB_HDR . SizeX ) ; break ; default : ThrowReaderException ( CoderError , \"UnsupportedCellTypeInTheMatrix\" ) ; } ( void ) sample_size ; image -> columns = MATLAB_HDR . SizeX ; image -> rows = MATLAB_HDR . SizeY ; quantum_info = AcquireQuantumInfo ( clone_info , image ) ; if ( quantum_info == ( QuantumInfo * ) NULL ) ThrowReaderException ( ResourceLimitError , \"MemoryAllocationFailed\" ) ; one = 1 ; image -> colors = one << image -> depth ; if ( image -> columns == 0 || image -> rows == 0 ) goto MATLAB_KO ; if ( ( MATLAB_HDR . DimFlag == 8 ) && ( ( MATLAB_HDR . StructureFlag & FLAG_COMPLEX ) == 0 ) ) { image -> type = GrayscaleType ; SetImageColorspace ( image , GRAYColorspace , exception ) ; } if ( image_info -> ping ) { size_t temp = image -> columns ; image -> columns = image -> rows ; image -> rows = temp ; goto done_reading ; } status = SetImageExtent ( image , image -> columns , image -> rows , exception ) ; if ( status == MagickFalse ) return ( DestroyImageList ( image ) ) ; BImgBuff = ( unsigned char * ) AcquireQuantumMemory ( ( size_t ) ( ldblk ) , sizeof ( double ) ) ; if ( BImgBuff == NULL ) ThrowReaderException ( ResourceLimitError , \"MemoryAllocationFailed\" ) ; MinVal = 0 ; MaxVal = 0 ; if ( CellType == miDOUBLE || CellType == miSINGLE ) { CalcMinMax ( image2 , image_info -> endian , MATLAB_HDR . SizeX , MATLAB_HDR . SizeY , CellType , ldblk , BImgBuff , & quantum_info -> minimum , & quantum_info -> maximum ) ; } if ( z == 1 ) z = 0 ; do { for ( i = 0 ; i < ( ssize_t ) MATLAB_HDR . SizeY ; i ++ ) { q = GetAuthenticPixels ( image , 0 , MATLAB_HDR . SizeY - i - 1 , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) { if ( logging ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , \"<S2SV_blank><S2SV_blank>MAT<S2SV_blank>set<S2SV_blank>image<S2SV_blank>pixels<S2SV_blank>returns<S2SV_blank>unexpected<S2SV_blank>NULL<S2SV_blank>on<S2SV_blank>a<S2SV_blank>row<S2SV_blank>%u.\" , ( unsigned ) ( MATLAB_HDR . SizeY - i - 1 ) ) ; goto done_reading ; } if ( ReadBlob ( image2 , ldblk , ( unsigned char * ) BImgBuff ) != ( ssize_t ) ldblk ) { if ( logging ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , \"<S2SV_blank><S2SV_blank>MAT<S2SV_blank>cannot<S2SV_blank>read<S2SV_blank>scanrow<S2SV_blank>%u<S2SV_blank>from<S2SV_blank>a<S2SV_blank>file.\" , ( unsigned ) ( MATLAB_HDR . SizeY - i - 1 ) ) ; goto ExitLoop ; } if ( ( CellType == miINT8 || CellType == miUINT8 ) && ( MATLAB_HDR . StructureFlag & FLAG_LOGICAL ) ) { FixLogical ( ( unsigned char * ) BImgBuff , ldblk ) ; if ( ImportQuantumPixels ( image , ( CacheView * ) NULL , quantum_info , z2qtype [ z ] , BImgBuff , exception ) <= 0 ) { ImportQuantumPixelsFailed : if ( logging ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , \"<S2SV_blank><S2SV_blank>MAT<S2SV_blank>failed<S2SV_blank>to<S2SV_blank>ImportQuantumPixels<S2SV_blank>for<S2SV_blank>a<S2SV_blank>row<S2SV_blank>%u\" , ( unsigned ) ( MATLAB_HDR . SizeY - i - 1 ) ) ; break ; } } else { if ( ImportQuantumPixels ( image , ( CacheView * ) NULL , quantum_info , z2qtype [ z ] , BImgBuff , exception ) <= 0 ) goto ImportQuantumPixelsFailed ; if ( z <= 1 && ( CellType == miINT8 || CellType == miINT16 || CellType == miINT32 || CellType == miINT64 ) ) FixSignedValues ( image , q , MATLAB_HDR . SizeX ) ; } if ( ! SyncAuthenticPixels ( image , exception ) ) { if ( logging ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , \"<S2SV_blank><S2SV_blank>MAT<S2SV_blank>failed<S2SV_blank>to<S2SV_blank>sync<S2SV_blank>image<S2SV_blank>pixels<S2SV_blank>for<S2SV_blank>a<S2SV_blank>row<S2SV_blank>%u\" , ( unsigned ) ( MATLAB_HDR . SizeY - i - 1 ) ) ; goto ExitLoop ; } } } while ( z -- >= 2 ) ; <S2SV_StartBug> ExitLoop : <S2SV_EndBug> if ( MATLAB_HDR . StructureFlag & FLAG_COMPLEX ) { CellType = ReadBlobXXXLong ( image2 ) ; i = ReadBlobXXXLong ( image2 ) ; if ( CellType == miDOUBLE || CellType == miSINGLE ) { CalcMinMax ( image2 , image_info -> endian , MATLAB_HDR . SizeX , MATLAB_HDR . SizeY , CellType , ldblk , BImgBuff , & MinVal , & MaxVal ) ; } if ( CellType == miDOUBLE ) for ( i = 0 ; i < ( ssize_t ) MATLAB_HDR . SizeY ; i ++ ) { ReadBlobDoublesXXX ( image2 , ldblk , ( double * ) BImgBuff ) ; InsertComplexDoubleRow ( image , ( double * ) BImgBuff , i , MinVal , MaxVal , exception ) ; } if ( CellType == miSINGLE ) for ( i = 0 ; i < ( ssize_t ) MATLAB_HDR . SizeY ; i ++ ) { ReadBlobFloatsXXX ( image2 , ldblk , ( float * ) BImgBuff ) ; InsertComplexFloatRow ( image , ( float * ) BImgBuff , i , MinVal , MaxVal , exception ) ; } } if ( ( MATLAB_HDR . DimFlag == 8 ) && ( ( MATLAB_HDR . StructureFlag & FLAG_COMPLEX ) == 0 ) ) image -> type = GrayscaleType ; if ( image -> depth == 1 ) image -> type = BilevelType ; if ( image2 == image ) image2 = NULL ; rotated_image = RotateImage ( image , 90.0 , exception ) ; if ( rotated_image != ( Image * ) NULL ) { rotated_image -> page . x = 0 ; rotated_image -> page . y = 0 ; blob = rotated_image -> blob ; rotated_image -> blob = image -> blob ; rotated_image -> colors = image -> colors ; image -> blob = blob ; AppendImageToList ( & image , rotated_image ) ; DeleteImageFromList ( & image ) ; } done_reading : if ( image2 != NULL ) if ( image2 != image ) { DeleteImageFromList ( & image2 ) ; if ( clone_info ) { if ( clone_info -> file ) { fclose ( clone_info -> file ) ; clone_info -> file = NULL ; ( void ) remove_utf8 ( clone_info -> filename ) ; } } } AcquireNextImage ( image_info , image , exception ) ; if ( image -> next == ( Image * ) NULL ) break ; image = SyncNextImageInList ( image ) ; image -> columns = image -> rows = 0 ; image -> colors = 0 ; RelinquishMagickMemory ( BImgBuff ) ; BImgBuff = NULL ; if ( -- Frames > 0 ) { z = z2 ; if ( image2 == NULL ) image2 = image ; goto NEXT_FRAME ; } if ( ( image2 != NULL ) && ( image2 != image ) ) { DeleteImageFromList ( & image2 ) ; if ( clone_info ) { if ( clone_info -> file ) { fclose ( clone_info -> file ) ; clone_info -> file = NULL ; ( void ) remove_utf8 ( clone_info -> filename ) ; } } } } clone_info = DestroyImageInfo ( clone_info ) ; RelinquishMagickMemory ( BImgBuff ) ; CloseBlob ( image ) ; { Image * p ; ssize_t scene = 0 ; p = image ; image = NULL ; while ( p != ( Image * ) NULL ) { Image * tmp = p ; if ( ( p -> rows == 0 ) || ( p -> columns == 0 ) ) { p = p -> previous ; DeleteImageFromList ( & tmp ) ; } else { image = p ; p = p -> previous ; } } for ( p = image ; p != ( Image * ) NULL ; p = p -> next ) p -> scene = scene ++ ; } if ( clone_info != NULL ) { if ( clone_info -> file ) { fclose ( clone_info -> file ) ; clone_info -> file = NULL ; ( void ) remove_utf8 ( clone_info -> filename ) ; } DestroyImageInfo ( clone_info ) ; clone_info = NULL ; } if ( logging ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , \"return\" ) ; if ( image == NULL ) ThrowReaderException ( CorruptImageError , \"ImproperImageHeader\" ) ; return ( image ) ; }\n","target":"<S2SV_ModStart> 2 ) ; quantum_info = DestroyQuantumInfo ( quantum_info ) ;\n","project_and_commit_id":"ImageMagick@ImageMagick/a6240a163cb787909703d9fc649cf861f60ddd7c","cve_id":"CVE-2016-10070","original_address":"https://github.com/ImageMagick/ImageMagick/commit/a6240a163cb787909703d9fc649cf861f60ddd7c","time":"2017-03-03T18:59Z"},
	{"Unnamed: 0":5102,"cwe_id":"CWE-20","source":"CWE-20 int dns_packet_is_reply_for ( DnsPacket * p , const DnsResourceKey * key ) { int r ; assert ( p ) ; assert ( key ) ; if ( DNS_PACKET_QR ( p ) != 1 ) return 0 ; r = dns_packet_extract ( p ) ; if ( r < 0 ) return r ; <S2SV_StartBug> if ( p -> question -> n_keys != 1 ) <S2SV_EndBug> return 0 ; return dns_resource_key_equal ( p -> question -> keys [ 0 ] , key ) ; }\n","target":"<S2SV_ModStart> ; if ( ! p -> question ) return 0 ; if (\n","project_and_commit_id":"systemd@systemd/a924f43f30f9c4acaf70618dd2a055f8b0f166be","cve_id":"CVE-2017-9217","original_address":"https://github.com/systemd/systemd/commit/a924f43f30f9c4acaf70618dd2a055f8b0f166be","time":"2017-05-24T05:29Z"},
	{"Unnamed: 0":1305,"cwe_id":"CWE-476","source":"CWE-476 int mp4boxMain ( int argc , char * * argv ) { u32 i , j ; const char * gpac_profile = \"0\" ; GF_Err e = GF_OK ; nb_tsel_acts = nb_add = nb_cat = nb_track_act = nb_sdp_ex = max_ptime = nb_meta_act = rtp_rate = major_brand = nb_alt_brand_add = nb_alt_brand_rem = car_dur = minor_version = 0 ; split_duration = 0.0 ; split_start = - 1.0 ; interleaving_time = 0 ; dash_duration = dash_subduration = 0.0 ; import_fps . num = import_fps . den = 0 ; import_flags = 0 ; split_size = 0 ; movie_time = 0 ; dump_nal = dump_saps = dump_saps_mode = force_new = 0 ; FullInter = HintInter = encode = do_scene_log = old_interleave = do_saf = do_hash = verbose = do_mpd_rip = merge_vtt_cues = get_nb_tracks = GF_FALSE ; # ifndef GPAC_DISABLE_SCENE_DUMP dump_mode = GF_SM_DUMP_NONE ; # endif Frag = force_ocr = remove_sys_tracks = agg_samples = remove_hint = keep_sys_tracks = remove_root_od = single_group = clean_groups = compress_moov = GF_FALSE ; conv_type = HintIt = needSave = print_sdp = regular_iod = dump_std = open_edit = dump_rtp = dump_cr = dump_srt = dump_ttxt = dump_m2ts = dump_cart = import_subtitle = force_cat = pack_wgt = dash_live = GF_FALSE ; no_fragments_defaults = GF_FALSE ; single_traf_per_moof = hls_clock = GF_FALSE ; tfdt_per_traf = GF_FALSE ; dump_nal_type = 0 ; dump_isom = 0 ; print_info = 0 ; align_cat = GF_TRUE ; subsegs_per_sidx = 0 ; track_dump_type = 0 ; crypt = 0 ; time_shift_depth = 0 ; file = NULL ; itunes_tags = pes_dump = NULL ; seg_name = dash_ctx_file = NULL ; compress_top_boxes = NULL ; initial_moof_sn = 0 ; initial_tfdt = 0 ; # ifndef GPAC_DISABLE_SCENE_ENCODER memset ( & smenc_opts , 0 , sizeof ( smenc_opts ) ) ; # endif trackID = stat_level = hint_flags = 0 ; program_number = 0 ; info_track_id = 0 ; do_flat = 0 ; inName = outName = mediaSource = input_ctx = output_ctx = drm_file = avi2raw = cprt = chap_file = pack_file = raw_cat = high_dynamc_range_filename = use_init_seg = box_patch_filename = NULL ; # ifndef GPAC_DISABLE_SWF_IMPORT swf_flags = GF_SM_SWF_SPLIT_TIMELINE ; # endif swf_flatten_angle = 0.0f ; tmpdir = NULL ; for ( i = 1 ; i < ( u32 ) argc ; i ++ ) { if ( ! strcmp ( argv [ i ] , \"-mem-track\" ) || ! strcmp ( argv [ i ] , \"-mem-track-stack\" ) ) { # ifdef GPAC_MEMORY_TRACKING mem_track = ! strcmp ( argv [ i ] , \"-mem-track-stack\" ) ? GF_MemTrackerBackTrace : GF_MemTrackerSimple ; # else fprintf ( stderr , \"WARNING<S2SV_blank>-<S2SV_blank>GPAC<S2SV_blank>not<S2SV_blank>compiled<S2SV_blank>with<S2SV_blank>Memory<S2SV_blank>Tracker<S2SV_blank>-<S2SV_blank>ignoring<S2SV_blank>\\\\\"%s\\\\\"\\\\n\" , argv [ i ] ) ; # endif break ; } else if ( ! strcmp ( argv [ i ] , \"-p\" ) ) { if ( i + 1 < ( u32 ) argc ) gpac_profile = argv [ i + 1 ] ; else { fprintf ( stderr , \"Bad<S2SV_blank>argument<S2SV_blank>for<S2SV_blank>-p,<S2SV_blank>expecting<S2SV_blank>profile<S2SV_blank>name<S2SV_blank>but<S2SV_blank>no<S2SV_blank>more<S2SV_blank>args\\\\n\" ) ; return 1 ; } } else if ( ! strncmp ( argv [ i ] , \"-p=\" , 3 ) ) gpac_profile = argv [ i ] + 3 ; } # ifdef _TWO_DIGIT_EXPONENT _set_output_format ( _TWO_DIGIT_EXPONENT ) ; # endif gf_sys_init ( mem_track , gpac_profile ) ; if ( argc < 2 ) { fprintf ( stderr , \"Not<S2SV_blank>enough<S2SV_blank>arguments<S2SV_blank>-<S2SV_blank>check<S2SV_blank>usage<S2SV_blank>with<S2SV_blank>-h\\\\n\" \"MP4Box<S2SV_blank>-<S2SV_blank>GPAC<S2SV_blank>version<S2SV_blank>%s\\\\n\" \"%s\\\\n\" , gf_gpac_version ( ) , gf_gpac_copyright ( ) ) ; gf_sys_close ( ) ; return 0 ; } helpout = stdout ; i = mp4box_parse_args ( argc , argv ) ; if ( i ) { return mp4box_cleanup ( i - 1 ) ; } if ( ! inName && dump_std ) inName = \"std\" ; if ( ! inName ) { if ( has_next_arg ) { fprintf ( stderr , \"Broken<S2SV_blank>argument<S2SV_blank>specifier<S2SV_blank>or<S2SV_blank>file<S2SV_blank>name<S2SV_blank>missing<S2SV_blank>-<S2SV_blank>check<S2SV_blank>usage<S2SV_blank>with<S2SV_blank>-h\\\\n\" ) ; } else { PrintUsage ( ) ; } return mp4box_cleanup ( 1 ) ; } if ( ! strcmp ( inName , \"std\" ) ) dump_std = 2 ; if ( ! strcmp ( inName , \"stdb\" ) ) { inName = \"std\" ; dump_std = 1 ; } if ( ! interleaving_time ) { if ( dash_duration ) interleaving_time = dash_duration ; else if ( ! do_flat ) { interleaving_time = DEFAULT_INTERLEAVING_IN_SEC ; } } if ( dump_std ) outName = \"std\" ; if ( dump_std == 2 ) { # ifdef WIN32 if ( _setmode ( _fileno ( stdout ) , _O_BINARY ) == - 1 ) # else if ( freopen ( NULL , \"wb\" , stdout ) == NULL ) # endif { fprintf ( stderr , \"Fatal<S2SV_blank>error:<S2SV_blank>cannot<S2SV_blank>reopen<S2SV_blank>stdout<S2SV_blank>in<S2SV_blank>binary<S2SV_blank>mode.\\\\n\" ) ; return mp4box_cleanup ( 1 ) ; } } # if ! defined ( GPAC_DISABLE_STREAMING ) && ! defined ( GPAC_DISABLE_SENG ) if ( live_scene ) { int ret = live_session ( argc , argv ) ; return mp4box_cleanup ( ret ) ; } # endif GF_LOG_Level level = verbose ? GF_LOG_DEBUG : GF_LOG_INFO ; gf_log_set_tool_level ( GF_LOG_CONTAINER , level ) ; gf_log_set_tool_level ( GF_LOG_SCENE , level ) ; gf_log_set_tool_level ( GF_LOG_PARSER , level ) ; gf_log_set_tool_level ( GF_LOG_AUTHOR , level ) ; gf_log_set_tool_level ( GF_LOG_CODING , level ) ; gf_log_set_tool_level ( GF_LOG_DASH , level ) ; # ifdef GPAC_MEMORY_TRACKING if ( mem_track ) gf_log_set_tool_level ( GF_LOG_MEMORY , level ) ; # endif e = gf_sys_set_args ( argc , ( const char * * ) argv ) ; if ( e ) { fprintf ( stderr , \"Error<S2SV_blank>assigning<S2SV_blank>libgpac<S2SV_blank>arguments:<S2SV_blank>%s\\\\n\" , gf_error_to_string ( e ) ) ; return mp4box_cleanup ( 1 ) ; } if ( raw_cat ) { char chunk [ 4096 ] ; FILE * fin , * fout ; s64 to_copy , done ; fin = gf_fopen ( raw_cat , \"rb\" ) ; if ( ! fin ) return mp4box_cleanup ( 1 ) ; fout = gf_fopen ( inName , \"a+b\" ) ; if ( ! fout ) { gf_fclose ( fin ) ; return mp4box_cleanup ( 1 ) ; } gf_fseek ( fin , 0 , SEEK_END ) ; to_copy = gf_ftell ( fin ) ; gf_fseek ( fin , 0 , SEEK_SET ) ; done = 0 ; while ( 1 ) { u32 nb_bytes = ( u32 ) gf_fread ( chunk , 4096 , fin ) ; gf_fwrite ( chunk , nb_bytes , fout ) ; done += nb_bytes ; fprintf ( stderr , \"Appending<S2SV_blank>file<S2SV_blank>%s<S2SV_blank>-<S2SV_blank>%02.2f<S2SV_blank>done\\\\r\" , raw_cat , 100.0 * done / to_copy ) ; if ( done >= to_copy ) break ; } gf_fclose ( fin ) ; gf_fclose ( fout ) ; return mp4box_cleanup ( 0 ) ; } if ( compress_top_boxes ) { if ( size_top_box ) { u64 top_size = do_size_top_boxes ( inName , compress_top_boxes , size_top_box ) ; fprintf ( stdout , LLU \"\\\\n\" , top_size ) ; return mp4box_cleanup ( e ? 1 : 0 ) ; } else { e = do_compress_top_boxes ( inName , outName , compress_top_boxes , comp_top_box_version , comp_lzma ) ; return mp4box_cleanup ( e ? 1 : 0 ) ; } } if ( do_mpd_rip ) { e = rip_mpd ( inName , outName ) ; return mp4box_cleanup ( e ? 1 : 0 ) ; } # ifndef GPAC_DISABLE_CORE_TOOLS if ( do_wget != NULL ) { e = gf_dm_wget ( do_wget , inName , 0 , 0 , NULL ) ; if ( e != GF_OK ) { fprintf ( stderr , \"Cannot<S2SV_blank>retrieve<S2SV_blank>%s:<S2SV_blank>%s\\\\n\" , do_wget , gf_error_to_string ( e ) ) ; return mp4box_cleanup ( 1 ) ; } return mp4box_cleanup ( 0 ) ; } # endif if ( udp_dest ) { GF_Socket * sock = gf_sk_new ( GF_SOCK_TYPE_UDP ) ; u16 port = 2345 ; char * sep = strrchr ( udp_dest , ':' ) ; if ( sep ) { sep [ 0 ] = 0 ; port = atoi ( sep + 1 ) ; } e = gf_sk_bind ( sock , \"127.0.0.1\" , 0 , udp_dest , port , 0 ) ; if ( sep ) sep [ 0 ] = ':' ; if ( e ) fprintf ( stderr , \"Failed<S2SV_blank>to<S2SV_blank>bind<S2SV_blank>socket<S2SV_blank>to<S2SV_blank>%s:<S2SV_blank>%s\\\\n\" , udp_dest , gf_error_to_string ( e ) ) ; else { e = gf_sk_send ( sock , ( u8 * ) inName , ( u32 ) strlen ( inName ) ) ; if ( e ) fprintf ( stderr , \"Failed<S2SV_blank>to<S2SV_blank>send<S2SV_blank>datagram:<S2SV_blank>%s\\\\n\" , gf_error_to_string ( e ) ) ; } gf_sk_del ( sock ) ; return 0 ; } # ifndef GPAC_DISABLE_MPD if ( do_mpd ) { Bool remote = GF_FALSE ; GF_MPD * mpd ; char * mpd_base_url = NULL ; if ( ! strnicmp ( inName , \"http://\" , 7 ) || ! strnicmp ( inName , \"https://\" , 8 ) ) { # if ! defined ( GPAC_DISABLE_CORE_TOOLS ) e = gf_dm_wget ( inName , \"tmp_main.m3u8\" , 0 , 0 , & mpd_base_url ) ; if ( e != GF_OK ) { fprintf ( stderr , \"Cannot<S2SV_blank>retrieve<S2SV_blank>M3U8<S2SV_blank>(%s):<S2SV_blank>%s\\\\n\" , inName , gf_error_to_string ( e ) ) ; if ( mpd_base_url ) gf_free ( mpd_base_url ) ; return mp4box_cleanup ( 1 ) ; } remote = GF_TRUE ; # else gf_free ( mpd_base_url ) ; fprintf ( stderr , \"HTTP<S2SV_blank>Downloader<S2SV_blank>disabled<S2SV_blank>in<S2SV_blank>this<S2SV_blank>build\\\\n\" ) ; return mp4box_cleanup ( 1 ) ; # endif if ( outName ) strcpy ( outfile , outName ) ; else { const char * sep = gf_file_basename ( inName ) ; char * ext = gf_file_ext_start ( sep ) ; if ( ext ) ext [ 0 ] = 0 ; sprintf ( outfile , \"%s.mpd\" , sep ) ; if ( ext ) ext [ 0 ] = '.' ; } } else { if ( outName ) strcpy ( outfile , outName ) ; else { char * dst = strdup ( inName ) ; char * ext = strstr ( dst , \".m3u8\" ) ; if ( ext ) ext [ 0 ] = 0 ; sprintf ( outfile , \"%s.mpd\" , dst ) ; gf_free ( dst ) ; } } mpd = gf_mpd_new ( ) ; if ( ! mpd ) { e = GF_OUT_OF_MEM ; fprintf ( stderr , \"[DASH]<S2SV_blank>Error:<S2SV_blank>MPD<S2SV_blank>creation<S2SV_blank>problem<S2SV_blank>%s\\\\n\" , gf_error_to_string ( e ) ) ; mp4box_cleanup ( 1 ) ; } FILE * f = gf_fopen ( remote ? \"tmp_main.m3u8\" : inName , \"r\" ) ; u32 manif_type = 0 ; if ( f ) { char szDATA [ 1000 ] ; s32 read ; szDATA [ 999 ] = 0 ; read = ( s32 ) gf_fread ( szDATA , 999 , f ) ; if ( read < 0 ) read = 0 ; szDATA [ read ] = 0 ; gf_fclose ( f ) ; if ( strstr ( szDATA , \"SmoothStreamingMedia\" ) ) manif_type = 2 ; else if ( strstr ( szDATA , \"#EXTM3U\" ) ) manif_type = 1 ; } if ( manif_type == 1 ) { e = gf_m3u8_to_mpd ( remote ? \"tmp_main.m3u8\" : inName , mpd_base_url ? mpd_base_url : inName , outfile , 0 , \"video/mp2t\" , GF_TRUE , use_url_template , segment_timeline , NULL , mpd , GF_TRUE , GF_TRUE ) ; } else if ( manif_type == 2 ) { e = gf_mpd_smooth_to_mpd ( remote ? \"tmp_main.m3u8\" : inName , mpd , mpd_base_url ? mpd_base_url : inName ) ; } else { e = GF_NOT_SUPPORTED ; } if ( ! e ) gf_mpd_write_file ( mpd , outfile ) ; if ( mpd ) gf_mpd_del ( mpd ) ; if ( mpd_base_url ) gf_free ( mpd_base_url ) ; if ( remote ) { gf_file_delete ( \"tmp_main.m3u8\" ) ; } if ( e != GF_OK ) { fprintf ( stderr , \"Error<S2SV_blank>converting<S2SV_blank>%s<S2SV_blank>(%s)<S2SV_blank>to<S2SV_blank>MPD<S2SV_blank>(%s):<S2SV_blank>%s\\\\n\" , ( manif_type == 1 ) ? \"HLS\" : \"Smooth\" , inName , outfile , gf_error_to_string ( e ) ) ; return mp4box_cleanup ( 1 ) ; } else { fprintf ( stderr , \"Done<S2SV_blank>converting<S2SV_blank>%s<S2SV_blank>(%s)<S2SV_blank>to<S2SV_blank>MPD<S2SV_blank>(%s)\\\\n\" , ( manif_type == 1 ) ? \"HLS\" : \"Smooth\" , inName , outfile ) ; return mp4box_cleanup ( 0 ) ; } } # endif if ( dash_duration && ! nb_dash_inputs ) { dash_inputs = set_dash_input ( dash_inputs , inName , & nb_dash_inputs ) ; } if ( do_saf && ! encode ) { switch ( get_file_type_by_ext ( inName ) ) { case GF_FILE_TYPE_BT_WRL_X3DV : case GF_FILE_TYPE_XMT_X3D : case GF_FILE_TYPE_SVG : encode = GF_TRUE ; break ; case GF_FILE_TYPE_NOT_SUPPORTED : case GF_FILE_TYPE_ISO_MEDIA : case GF_FILE_TYPE_SWF : case GF_FILE_TYPE_LSR_SAF : break ; } } # ifndef GPAC_DISABLE_SCENE_DUMP if ( dump_mode == GF_SM_DUMP_SVG ) { if ( strstr ( inName , \".srt\" ) || strstr ( inName , \".ttxt\" ) ) import_subtitle = 2 ; } # endif if ( import_subtitle && ! trackID ) { # ifndef GPAC_DISABLE_MEDIA_IMPORT GF_MediaImporter import ; file = gf_isom_open ( \"ttxt_convert\" , GF_ISOM_OPEN_WRITE , NULL ) ; if ( timescale && file ) gf_isom_set_timescale ( file , timescale ) ; memset ( & import , 0 , sizeof ( GF_MediaImporter ) ) ; import . dest = file ; import . in_name = inName ; e = gf_media_import ( & import ) ; if ( e ) { fprintf ( stderr , \"Error<S2SV_blank>importing<S2SV_blank>%s:<S2SV_blank>%s\\\\n\" , inName , gf_error_to_string ( e ) ) ; gf_isom_delete ( file ) ; gf_file_delete ( \"ttxt_convert\" ) ; return mp4box_cleanup ( 1 ) ; } strcpy ( outfile , inName ) ; if ( strchr ( outfile , '.' ) ) { while ( outfile [ strlen ( outfile ) - 1 ] != '.' ) outfile [ strlen ( outfile ) - 1 ] = 0 ; outfile [ strlen ( outfile ) - 1 ] = 0 ; } # ifndef GPAC_DISABLE_ISOM_DUMP dump_isom_timed_text ( file , gf_isom_get_track_id ( file , 1 ) , dump_std ? NULL : ( outName ? outName : outfile ) , outName ? GF_TRUE : GF_FALSE , GF_TRUE , ( import_subtitle == 2 ) ? GF_TEXTDUMPTYPE_SVG : ( dump_srt ? GF_TEXTDUMPTYPE_SRT : GF_TEXTDUMPTYPE_TTXT ) ) ; # endif gf_isom_delete ( file ) ; gf_file_delete ( \"ttxt_convert\" ) ; if ( e ) { fprintf ( stderr , \"Error<S2SV_blank>converting<S2SV_blank>%s:<S2SV_blank>%s\\\\n\" , inName , gf_error_to_string ( e ) ) ; return mp4box_cleanup ( 1 ) ; } return mp4box_cleanup ( 0 ) ; # else fprintf ( stderr , \"Feature<S2SV_blank>not<S2SV_blank>supported\\\\n\" ) ; return mp4box_cleanup ( 1 ) ; # endif } # if ! defined ( GPAC_DISABLE_MEDIA_IMPORT ) && ! defined ( GPAC_DISABLE_ISOM_WRITE ) if ( nb_add || nb_cat ) { u32 ipass , nb_pass = 1 ; char * mux_args = NULL ; GF_FilterSession * fs = NULL ; if ( nb_add ) { GF_ISOOpenMode open_mode = GF_ISOM_OPEN_EDIT ; if ( force_new ) { open_mode = ( do_flat || ( force_new == 2 ) ) ? GF_ISOM_OPEN_WRITE : GF_ISOM_WRITE_EDIT ; } else { FILE * test = gf_fopen ( inName , \"rb\" ) ; if ( ! test ) { open_mode = ( do_flat ) ? GF_ISOM_OPEN_WRITE : GF_ISOM_WRITE_EDIT ; if ( ! outName ) outName = inName ; } else { gf_fclose ( test ) ; if ( ! gf_isom_probe_file ( inName ) ) { open_mode = ( do_flat ) ? GF_ISOM_OPEN_WRITE : GF_ISOM_WRITE_EDIT ; if ( ! outName ) outName = inName ; } } } open_edit = do_flat ? GF_FALSE : GF_TRUE ; file = gf_isom_open ( inName , open_mode , tmpdir ) ; if ( ! file ) { fprintf ( stderr , \"Cannot<S2SV_blank>open<S2SV_blank>destination<S2SV_blank>file<S2SV_blank>%s:<S2SV_blank>%s\\\\n\" , inName , gf_error_to_string ( gf_isom_last_error ( NULL ) ) ) ; return mp4box_cleanup ( 1 ) ; } if ( freeze_box_order ) gf_isom_freeze_order ( file ) ; } if ( do_flat && interleaving_time ) { char szSubArg [ 100 ] ; gf_isom_set_storage_mode ( file , GF_ISOM_STORE_FASTSTART ) ; do_flat = 2 ; nb_pass = 2 ; fs = gf_fs_new_defaults ( 0 ) ; if ( ! fs ) { fprintf ( stderr , \"Error<S2SV_blank>creating<S2SV_blank>filter<S2SV_blank>session\\\\n\" ) ; gf_isom_delete ( file ) ; return mp4box_cleanup ( 1 ) ; } gf_dynstrcat ( & mux_args , \"mp4mx:importer:store=fstart\" , \":\" ) ; sprintf ( szSubArg , \"file=%p\" , file ) ; gf_dynstrcat ( & mux_args , szSubArg , \":\" ) ; sprintf ( szSubArg , \"cdur=%g\" , interleaving_time ) ; gf_dynstrcat ( & mux_args , szSubArg , \":\" ) ; } for ( ipass = 0 ; ipass < nb_pass ; ipass ++ ) { u32 tk_idx = 1 ; for ( i = 0 ; i < ( u32 ) argc ; i ++ ) { char * margs = NULL ; if ( ! strcmp ( argv [ i ] , \"-add\" ) ) { char * src = argv [ i + 1 ] ; while ( src ) { char * loc_src = src ; char * sep = NULL ; while ( 1 ) { char * opt_sep ; sep = strchr ( loc_src , '+' ) ; if ( ! sep ) break ; sep [ 0 ] = 0 ; if ( strstr ( src , \"://\" ) ) break ; opt_sep = gf_url_colon_suffix ( src ) ; if ( opt_sep ) opt_sep [ 0 ] = 0 ; if ( gf_file_exists ( src ) ) { if ( opt_sep ) opt_sep [ 0 ] = ':' ; break ; } if ( opt_sep ) opt_sep [ 0 ] = ':' ; sep [ 0 ] = '+' ; loc_src = sep + 1 ; } e = import_file ( file , src , import_flags , import_fps , agg_samples , fs , ( fs && ( ipass == 0 ) ) ? & margs : NULL , tk_idx ) ; tk_idx ++ ; if ( margs ) { gf_dynstrcat ( & mux_args , margs , \":\" ) ; gf_free ( margs ) ; } if ( e ) { fprintf ( stderr , \"Error<S2SV_blank>importing<S2SV_blank>%s:<S2SV_blank>%s\\\\n\" , argv [ i + 1 ] , gf_error_to_string ( e ) ) ; gf_isom_delete ( file ) ; if ( fs ) gf_fs_del ( fs ) ; return mp4box_cleanup ( 1 ) ; } if ( sep ) { sep [ 0 ] = '+' ; src = sep + 1 ; } else { break ; } } i ++ ; } else if ( ! strcmp ( argv [ i ] , \"-cat\" ) || ! strcmp ( argv [ i ] , \"-catx\" ) || ! strcmp ( argv [ i ] , \"-catpl\" ) ) { if ( nb_pass == 2 ) { fprintf ( stderr , \"Cannot<S2SV_blank>cat<S2SV_blank>files<S2SV_blank>when<S2SV_blank>using<S2SV_blank>-newfs<S2SV_blank>mode\\\\n\" ) ; return mp4box_cleanup ( 1 ) ; } if ( ! file ) { u8 open_mode = GF_ISOM_OPEN_EDIT ; if ( force_new ) { open_mode = ( do_flat ) ? GF_ISOM_OPEN_WRITE : GF_ISOM_WRITE_EDIT ; } else { FILE * test = gf_fopen ( inName , \"rb\" ) ; if ( ! test ) { open_mode = ( do_flat ) ? GF_ISOM_OPEN_WRITE : GF_ISOM_WRITE_EDIT ; if ( ! outName ) outName = inName ; } else gf_fclose ( test ) ; } open_edit = GF_TRUE ; file = gf_isom_open ( inName , open_mode , tmpdir ) ; if ( ! file ) { fprintf ( stderr , \"Cannot<S2SV_blank>open<S2SV_blank>destination<S2SV_blank>file<S2SV_blank>%s:<S2SV_blank>%s\\\\n\" , inName , gf_error_to_string ( gf_isom_last_error ( NULL ) ) ) ; return mp4box_cleanup ( 1 ) ; } } e = cat_isomedia_file ( file , argv [ i + 1 ] , import_flags , import_fps , agg_samples , tmpdir , force_cat , align_cat , ! strcmp ( argv [ i ] , \"-catx\" ) ? GF_TRUE : GF_FALSE , ! strcmp ( argv [ i ] , \"-catpl\" ) ? GF_TRUE : GF_FALSE ) ; if ( e ) { fprintf ( stderr , \"Error<S2SV_blank>appending<S2SV_blank>%s:<S2SV_blank>%s\\\\n\" , argv [ i + 1 ] , gf_error_to_string ( e ) ) ; gf_isom_delete ( file ) ; return mp4box_cleanup ( 1 ) ; } i ++ ; } } if ( ( nb_pass == 2 ) && ! ipass ) { GF_Filter * mux_filter = gf_fs_load_filter ( fs , mux_args , NULL ) ; gf_free ( mux_args ) ; if ( ! mux_filter ) { fprintf ( stderr , \"Error<S2SV_blank>loadin<S2SV_blank>isobmff<S2SV_blank>mux<S2SV_blank>filter\\\\n\" ) ; gf_isom_delete ( file ) ; gf_fs_del ( fs ) ; return mp4box_cleanup ( 1 ) ; } e = gf_fs_run ( fs ) ; if ( e == GF_EOS ) e = GF_OK ; if ( ! e ) e = gf_fs_get_last_connect_error ( fs ) ; if ( ! e ) e = gf_fs_get_last_process_error ( fs ) ; if ( e ) { fprintf ( stderr , \"Error<S2SV_blank>importing<S2SV_blank>sources:<S2SV_blank>%s\\\\n\" , gf_error_to_string ( e ) ) ; gf_isom_delete ( file ) ; gf_fs_del ( fs ) ; return mp4box_cleanup ( 1 ) ; } } } if ( fs ) { if ( fs_dump_flags & 1 ) gf_fs_print_stats ( fs ) ; if ( fs_dump_flags & 2 ) gf_fs_print_connections ( fs ) ; gf_fs_del ( fs ) ; } # ifndef GPAC_DISABLE_AV_PARSERS if ( ! keep_sys_tracks ) remove_systems_tracks ( file ) ; # endif needSave = GF_TRUE ; } # endif # if ! defined ( GPAC_DISABLE_ISOM_WRITE ) && ! defined ( GPAC_DISABLE_SCENE_ENCODER ) && ! defined ( GPAC_DISABLE_MEDIA_IMPORT ) else if ( chunk_mode ) { if ( ! inName ) { fprintf ( stderr , \"chunk<S2SV_blank>encoding<S2SV_blank>syntax:<S2SV_blank>[-outctx<S2SV_blank>outDump]<S2SV_blank>-inctx<S2SV_blank>inScene<S2SV_blank>auFile\\\\n\" ) ; return mp4box_cleanup ( 1 ) ; } e = EncodeFileChunk ( inName , outName ? outName : inName , input_ctx , output_ctx , tmpdir ) ; if ( e ) { fprintf ( stderr , \"Error<S2SV_blank>encoding<S2SV_blank>chunk<S2SV_blank>file<S2SV_blank>%s\\\\n\" , gf_error_to_string ( e ) ) ; return mp4box_cleanup ( 1 ) ; } goto exit ; } # endif else if ( encode ) { # if ! defined ( GPAC_DISABLE_ISOM_WRITE ) && ! defined ( GPAC_DISABLE_SCENE_ENCODER ) && ! defined ( GPAC_DISABLE_MEDIA_IMPORT ) FILE * logs = NULL ; if ( do_scene_log ) { char alogfile [ GF_MAX_PATH ] ; strcpy ( alogfile , inName ) ; if ( strchr ( alogfile , '.' ) ) { while ( alogfile [ strlen ( alogfile ) - 1 ] != '.' ) alogfile [ strlen ( alogfile ) - 1 ] = 0 ; alogfile [ strlen ( alogfile ) - 1 ] = 0 ; } strcat ( alogfile , \"_enc.logs\" ) ; logs = gf_fopen ( alogfile , \"wt\" ) ; } strcpy ( outfile , outName ? outName : inName ) ; if ( strchr ( outfile , '.' ) ) { while ( outfile [ strlen ( outfile ) - 1 ] != '.' ) outfile [ strlen ( outfile ) - 1 ] = 0 ; outfile [ strlen ( outfile ) - 1 ] = 0 ; } strcat ( outfile , \".mp4\" ) ; file = gf_isom_open ( outfile , GF_ISOM_WRITE_EDIT , tmpdir ) ; smenc_opts . mediaSource = mediaSource ? mediaSource : outfile ; e = EncodeFile ( inName , file , & smenc_opts , logs ) ; if ( logs ) gf_fclose ( logs ) ; if ( e ) goto err_exit ; needSave = GF_TRUE ; if ( do_saf ) { needSave = GF_FALSE ; open_edit = GF_FALSE ; } # endif } # ifndef GPAC_DISABLE_ISOM_WRITE else if ( pack_file ) { char * fileName = gf_url_colon_suffix ( pack_file ) ; if ( fileName && ( ( fileName - pack_file ) == 4 ) ) { fileName [ 0 ] = 0 ; file = package_file ( fileName + 1 , pack_file , tmpdir , pack_wgt ) ; fileName [ 0 ] = ':' ; } else { file = package_file ( pack_file , NULL , tmpdir , pack_wgt ) ; if ( ! file ) { fprintf ( stderr , \"Failed<S2SV_blank>to<S2SV_blank>package<S2SV_blank>file\\\\n\" ) ; return mp4box_cleanup ( 1 ) ; } } if ( ! outName ) outName = inName ; needSave = GF_TRUE ; open_edit = GF_TRUE ; } # endif if ( dash_duration ) { Bool del_file = GF_FALSE ; char szMPD [ GF_MAX_PATH ] , * sep ; char szStateFile [ GF_MAX_PATH ] ; Bool dyn_state_file = GF_FALSE ; u32 do_abort = 0 ; GF_DASHSegmenter * dasher = NULL ; if ( crypt ) { fprintf ( stderr , \"MP4Box<S2SV_blank>cannot<S2SV_blank>crypt<S2SV_blank>and<S2SV_blank>DASH<S2SV_blank>on<S2SV_blank>the<S2SV_blank>same<S2SV_blank>pass.<S2SV_blank>Please<S2SV_blank>encrypt<S2SV_blank>your<S2SV_blank>content<S2SV_blank>first.\\\\n\" ) ; return mp4box_cleanup ( 1 ) ; } strcpy ( outfile , outName ? outName : gf_url_get_resource_name ( inName ) ) ; sep = strrchr ( outfile , '.' ) ; if ( sep ) sep [ 0 ] = 0 ; if ( ! outName ) strcat ( outfile , \"_dash\" ) ; strcpy ( szMPD , outfile ) ; if ( outName && sep ) { sep [ 0 ] = '.' ; strcat ( szMPD , sep ) ; } else { strcat ( szMPD , \".mpd\" ) ; } if ( ( dash_subduration > 0 ) && ( dash_duration > dash_subduration ) ) { fprintf ( stderr , \"Warning:<S2SV_blank>-subdur<S2SV_blank>parameter<S2SV_blank>(%g<S2SV_blank>s)<S2SV_blank>should<S2SV_blank>be<S2SV_blank>greater<S2SV_blank>than<S2SV_blank>segment<S2SV_blank>duration<S2SV_blank>(%g<S2SV_blank>s),<S2SV_blank>using<S2SV_blank>segment<S2SV_blank>duration<S2SV_blank>instead\\\\n\" , dash_subduration , dash_duration ) ; dash_subduration = dash_duration ; } if ( dash_mode && dash_live ) fprintf ( stderr , \"Live<S2SV_blank>DASH-ing<S2SV_blank>-<S2SV_blank>press<S2SV_blank>\\'q\\'<S2SV_blank>to<S2SV_blank>quit,<S2SV_blank>\\'s\\'<S2SV_blank>to<S2SV_blank>save<S2SV_blank>context<S2SV_blank>and<S2SV_blank>quit\\\\n\" ) ; if ( ! dash_ctx_file && dash_live ) { u32 r1 ; u64 add = ( u64 ) ( intptr_t ) & dasher ; add ^= gf_net_get_utc ( ) ; r1 = ( u32 ) add ^ ( u32 ) ( add / 0xFFFFFFFF ) ; r1 ^= gf_rand ( ) ; sprintf ( szStateFile , \"%s/dasher_%X.xml\" , gf_get_default_cache_directory ( ) , r1 ) ; dash_ctx_file = szStateFile ; dyn_state_file = GF_TRUE ; } else if ( dash_ctx_file ) { if ( force_new ) gf_file_delete ( dash_ctx_file ) ; } if ( dash_profile == GF_DASH_PROFILE_AUTO ) dash_profile = dash_mode ? GF_DASH_PROFILE_LIVE : GF_DASH_PROFILE_FULL ; if ( ! dash_mode ) { time_shift_depth = 0 ; mpd_update_time = 0 ; } else if ( ( dash_profile >= GF_DASH_PROFILE_MAIN ) && ! use_url_template && ! mpd_update_time ) { mpd_update_time = ( Double ) ( dash_subduration ? dash_subduration : dash_duration ) ; fprintf ( stderr , \"Using<S2SV_blank>default<S2SV_blank>MPD<S2SV_blank>refresh<S2SV_blank>of<S2SV_blank>%g<S2SV_blank>seconds\\\\n\" , mpd_update_time ) ; } if ( file && needSave ) { gf_isom_close ( file ) ; file = NULL ; del_file = GF_TRUE ; } dasher = gf_dasher_new ( szMPD , dash_profile , tmpdir , dash_scale , dash_ctx_file ) ; if ( ! dasher ) { return mp4box_cleanup ( 1 ) ; } e = gf_dasher_set_info ( dasher , dash_title , cprt , dash_more_info , dash_source , NULL ) ; if ( e ) { fprintf ( stderr , \"DASH<S2SV_blank>Error:<S2SV_blank>%s\\\\n\" , gf_error_to_string ( e ) ) ; gf_dasher_del ( dasher ) ; return mp4box_cleanup ( 1 ) ; } gf_dasher_set_start_date ( dasher , dash_start_date ) ; gf_dasher_set_location ( dasher , dash_source ) ; for ( i = 0 ; i < nb_mpd_base_urls ; i ++ ) { e = gf_dasher_add_base_url ( dasher , mpd_base_urls [ i ] ) ; if ( e ) { fprintf ( stderr , \"DASH<S2SV_blank>Error:<S2SV_blank>%s\\\\n\" , gf_error_to_string ( e ) ) ; gf_dasher_del ( dasher ) ; return mp4box_cleanup ( 1 ) ; } } if ( segment_timeline && ! use_url_template ) { fprintf ( stderr , \"DASH<S2SV_blank>Warning:<S2SV_blank>using<S2SV_blank>-segment-timeline<S2SV_blank>with<S2SV_blank>no<S2SV_blank>-url-template.<S2SV_blank>Forcing<S2SV_blank>URL<S2SV_blank>template.\\\\n\" ) ; use_url_template = GF_TRUE ; } e = gf_dasher_enable_url_template ( dasher , ( Bool ) use_url_template , seg_name , seg_ext , init_seg_ext ) ; if ( ! e ) e = gf_dasher_enable_segment_timeline ( dasher , segment_timeline ) ; if ( ! e ) e = gf_dasher_enable_single_segment ( dasher , single_segment ) ; if ( ! e ) e = gf_dasher_enable_single_file ( dasher , single_file ) ; if ( ! e ) e = gf_dasher_set_switch_mode ( dasher , bitstream_switching_mode ) ; if ( ! e ) e = gf_dasher_set_durations ( dasher , dash_duration , interleaving_time , dash_subduration ) ; if ( ! e ) e = gf_dasher_enable_rap_splitting ( dasher , seg_at_rap , frag_at_rap ) ; if ( ! e ) e = gf_dasher_set_segment_marker ( dasher , segment_marker ) ; if ( ! e ) e = gf_dasher_enable_sidx ( dasher , ( subsegs_per_sidx >= 0 ) ? 1 : 0 , ( u32 ) subsegs_per_sidx , daisy_chain_sidx , use_ssix ) ; if ( ! e ) e = gf_dasher_set_dynamic_mode ( dasher , dash_mode , mpd_update_time , time_shift_depth , mpd_live_duration ) ; if ( ! e ) e = gf_dasher_set_min_buffer ( dasher , min_buffer ) ; if ( ! e ) e = gf_dasher_set_ast_offset ( dasher , ast_offset_ms ) ; if ( ! e ) e = gf_dasher_enable_memory_fragmenting ( dasher , memory_frags ) ; if ( ! e ) e = gf_dasher_set_initial_isobmf ( dasher , initial_moof_sn , initial_tfdt ) ; if ( ! e ) e = gf_dasher_configure_isobmf_default ( dasher , no_fragments_defaults , pssh_mode , samplegroups_in_traf , single_traf_per_moof , tfdt_per_traf , mvex_after_traks , sdtp_in_traf ) ; if ( ! e ) e = gf_dasher_enable_utc_ref ( dasher , insert_utc ) ; if ( ! e ) e = gf_dasher_enable_real_time ( dasher , frag_real_time ) ; if ( ! e ) e = gf_dasher_set_content_protection_location_mode ( dasher , cp_location_mode ) ; if ( ! e ) e = gf_dasher_set_profile_extension ( dasher , dash_profile_extension ) ; if ( ! e ) e = gf_dasher_enable_cached_inputs ( dasher , no_cache ) ; if ( ! e ) e = gf_dasher_enable_loop_inputs ( dasher , ! no_loop ) ; if ( ! e ) e = gf_dasher_set_split_mode ( dasher , dash_split_mode ) ; if ( ! e ) e = gf_dasher_set_hls_clock ( dasher , hls_clock ) ; if ( ! e && dash_cues ) e = gf_dasher_set_cues ( dasher , dash_cues , strict_cues ) ; if ( ! e && fs_dump_flags ) e = gf_dasher_print_session_info ( dasher , fs_dump_flags ) ; for ( i = 0 ; i < nb_dash_inputs ; i ++ ) { if ( ! e ) e = gf_dasher_add_input ( dasher , & dash_inputs [ i ] ) ; } if ( e ) { fprintf ( stderr , \"DASH<S2SV_blank>Setup<S2SV_blank>Error:<S2SV_blank>%s\\\\n\" , gf_error_to_string ( e ) ) ; gf_dasher_del ( dasher ) ; return mp4box_cleanup ( 1 ) ; } dash_cumulated_time = 0 ; while ( 1 ) { if ( run_for && ( dash_cumulated_time >= run_for ) ) { fprintf ( stderr , \"Done<S2SV_blank>running,<S2SV_blank>computing<S2SV_blank>static<S2SV_blank>MPD\\\\n\" ) ; do_abort = 3 ; } dash_prev_time = gf_sys_clock ( ) ; if ( do_abort >= 2 ) { e = gf_dasher_set_dynamic_mode ( dasher , GF_DASH_DYNAMIC_LAST , 0 , time_shift_depth , mpd_live_duration ) ; } if ( ! e ) e = gf_dasher_process ( dasher ) ; if ( ! dash_live && ( e == GF_EOS ) ) { fprintf ( stderr , \"Nothing<S2SV_blank>to<S2SV_blank>dash,<S2SV_blank>too<S2SV_blank>early<S2SV_blank>...\\\\n\" ) ; e = GF_OK ; } if ( do_abort ) break ; if ( dash_live && ( e == GF_IO_ERR ) ) { fprintf ( stderr , \"Error<S2SV_blank>dashing<S2SV_blank>file<S2SV_blank>(%s)<S2SV_blank>but<S2SV_blank>continuing<S2SV_blank>...\\\\n\" , gf_error_to_string ( e ) ) ; e = GF_OK ; } if ( e ) break ; if ( dash_live ) { u64 ms_in_session = 0 ; u32 slept = gf_sys_clock ( ) ; u32 sleep_for = gf_dasher_next_update_time ( dasher , & ms_in_session ) ; fprintf ( stderr , \"Next<S2SV_blank>generation<S2SV_blank>scheduled<S2SV_blank>in<S2SV_blank>%u<S2SV_blank>ms<S2SV_blank>(DASH<S2SV_blank>time<S2SV_blank>\" LLU \"<S2SV_blank>ms)\\\\r\" , sleep_for , ms_in_session ) ; if ( run_for && ( ms_in_session >= run_for ) ) { dash_cumulated_time = 1 + run_for ; continue ; } while ( 1 ) { if ( gf_prompt_has_input ( ) ) { char c = ( char ) gf_prompt_get_char ( ) ; if ( c == 'X' ) { do_abort = 1 ; break ; } if ( c == 'q' ) { do_abort = 2 ; break ; } if ( c == 's' ) { do_abort = 3 ; break ; } } if ( dash_mode == GF_DASH_DYNAMIC_DEBUG ) { break ; } if ( ! sleep_for ) break ; gf_sleep ( sleep_for / 10 ) ; sleep_for = gf_dasher_next_update_time ( dasher , NULL ) ; if ( sleep_for <= 1 ) { dash_now_time = gf_sys_clock ( ) ; dash_cumulated_time += ( dash_now_time - dash_prev_time ) ; fprintf ( stderr , \"Slept<S2SV_blank>for<S2SV_blank>%d<S2SV_blank>ms<S2SV_blank>before<S2SV_blank>generation,<S2SV_blank>dash<S2SV_blank>cumulated<S2SV_blank>time<S2SV_blank>%d\\\\n\" , dash_now_time - slept , dash_cumulated_time ) ; break ; } } } else { break ; } } gf_dasher_del ( dasher ) ; if ( ! run_for && dash_ctx_file && ( do_abort == 3 ) && ( dyn_state_file ) && ! gf_sys_is_test_mode ( ) ) { char szName [ 1024 ] ; fprintf ( stderr , \"Enter<S2SV_blank>file<S2SV_blank>name<S2SV_blank>to<S2SV_blank>save<S2SV_blank>dash<S2SV_blank>context:\\\\n\" ) ; if ( scanf ( \"%1023s\" , szName ) == 1 ) { gf_file_move ( dash_ctx_file , szName ) ; } } if ( e ) fprintf ( stderr , \"Error<S2SV_blank>DASHing<S2SV_blank>file:<S2SV_blank>%s\\\\n\" , gf_error_to_string ( e ) ) ; if ( file ) gf_isom_delete ( file ) ; if ( del_file ) gf_file_delete ( inName ) ; if ( e ) return mp4box_cleanup ( 1 ) ; goto exit ; } else if ( ! file && ! do_hash # ifndef GPAC_DISABLE_MEDIA_EXPORT && ! ( track_dump_type & GF_EXPORT_AVI_NATIVE ) # endif ) { FILE * st = gf_fopen ( inName , \"rb\" ) ; Bool file_exists = 0 ; GF_ISOOpenMode omode ; if ( st ) { file_exists = 1 ; gf_fclose ( st ) ; } switch ( get_file_type_by_ext ( inName ) ) { case 1 : omode = ( u8 ) ( force_new ? GF_ISOM_WRITE_EDIT : ( open_edit ? GF_ISOM_OPEN_EDIT : ( ( ( dump_isom > 0 ) || print_info ) ? GF_ISOM_OPEN_READ_DUMP : GF_ISOM_OPEN_READ ) ) ) ; if ( crypt ) { omode = GF_ISOM_OPEN_READ ; if ( use_init_seg ) file = gf_isom_open ( use_init_seg , GF_ISOM_OPEN_READ , tmpdir ) ; } if ( ! crypt && use_init_seg ) { file = gf_isom_open ( use_init_seg , GF_ISOM_OPEN_READ_DUMP , tmpdir ) ; if ( file ) { e = gf_isom_open_segment ( file , inName , 0 , 0 , 0 ) ; if ( e ) { fprintf ( stderr , \"Error<S2SV_blank>opening<S2SV_blank>segment<S2SV_blank>%s:<S2SV_blank>%s\\\\n\" , inName , gf_error_to_string ( e ) ) ; gf_isom_delete ( file ) ; file = NULL ; } } } if ( ! file ) file = gf_isom_open ( inName , omode , tmpdir ) ; if ( ! file && ( gf_isom_last_error ( NULL ) == GF_ISOM_INCOMPLETE_FILE ) && ! open_edit ) { u64 missing_bytes ; e = gf_isom_open_progressive ( inName , 0 , 0 , GF_FALSE , & file , & missing_bytes ) ; fprintf ( stderr , \"Truncated<S2SV_blank>file<S2SV_blank>-<S2SV_blank>missing<S2SV_blank>\" LLD \"<S2SV_blank>bytes\\\\n\" , missing_bytes ) ; } if ( ! file ) { if ( open_edit && nb_meta_act ) { file = gf_isom_open ( inName , GF_ISOM_WRITE_EDIT , tmpdir ) ; if ( ! outName && file ) outName = inName ; } if ( ! file ) { fprintf ( stderr , \"Error<S2SV_blank>opening<S2SV_blank>file<S2SV_blank>%s:<S2SV_blank>%s\\\\n\" , inName , gf_error_to_string ( gf_isom_last_error ( NULL ) ) ) ; return mp4box_cleanup ( 1 ) ; } } if ( freeze_box_order ) gf_isom_freeze_order ( file ) ; break ; case 2 : case 3 : case 4 : case 5 : break ; case 6 : # ifndef GPAC_DISABLE_SCENE_DUMP if ( ( dump_mode == GF_SM_DUMP_LASER ) || ( dump_mode == GF_SM_DUMP_SVG ) ) { break ; } # endif default : if ( ! open_edit && file_exists && ! gf_isom_probe_file ( inName ) && track_dump_type ) { } # ifndef GPAC_DISABLE_ISOM_WRITE else if ( ! open_edit && file_exists # ifndef GPAC_DISABLE_SCENE_DUMP && dump_mode == GF_SM_DUMP_NONE # endif ) { # ifndef GPAC_DISABLE_MEDIA_IMPORT if ( dvbhdemux ) { GF_MediaImporter import ; file = gf_isom_open ( \"ttxt_convert\" , GF_ISOM_OPEN_WRITE , NULL ) ; memset ( & import , 0 , sizeof ( GF_MediaImporter ) ) ; import . dest = file ; import . in_name = inName ; import . flags = GF_IMPORT_MPE_DEMUX ; e = gf_media_import ( & import ) ; if ( e ) { fprintf ( stderr , \"Error<S2SV_blank>importing<S2SV_blank>%s:<S2SV_blank>%s\\\\n\" , inName , gf_error_to_string ( e ) ) ; gf_isom_delete ( file ) ; gf_file_delete ( \"ttxt_convert\" ) ; return mp4box_cleanup ( 1 ) ; } } # endif if ( dump_m2ts ) { # ifndef GPAC_DISABLE_MPEG2TS dump_mpeg2_ts ( inName , pes_dump , program_number ) ; # endif } else if ( dump_timestamps ) { # ifndef GPAC_DISABLE_MPEG2TS dump_mpeg2_ts ( inName , pes_dump , program_number ) ; # endif # ifndef GPAC_DISABLE_CORE_TOOLS } else if ( do_bin_xml ) { xml_bs_to_bin ( inName , outName , dump_std ) ; # endif } else if ( do_hash ) { hash_file ( inName , dump_std ) ; } else if ( print_info ) { # ifndef GPAC_DISABLE_MEDIA_IMPORT convert_file_info ( inName , info_track_id ) ; # endif } else { fprintf ( stderr , \"Input<S2SV_blank>%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>an<S2SV_blank>MP4<S2SV_blank>file,<S2SV_blank>operation<S2SV_blank>not<S2SV_blank>allowed\\\\n\" , inName ) ; return mp4box_cleanup ( 1 ) ; } goto exit ; } # endif else if ( open_edit ) { file = gf_isom_open ( inName , GF_ISOM_WRITE_EDIT , tmpdir ) ; if ( ! outName && file ) outName = inName ; } else if ( ! file_exists ) { fprintf ( stderr , \"Error<S2SV_blank>creating<S2SV_blank>file<S2SV_blank>%s:<S2SV_blank>%s\\\\n\" , inName , gf_error_to_string ( GF_URL_ERROR ) ) ; return mp4box_cleanup ( 1 ) ; } else { fprintf ( stderr , \"Cannot<S2SV_blank>open<S2SV_blank>%s<S2SV_blank>-<S2SV_blank>extension<S2SV_blank>not<S2SV_blank>supported\\\\n\" , inName ) ; return mp4box_cleanup ( 1 ) ; } } } if ( high_dynamc_range_filename ) { e = parse_high_dynamc_range_xml_desc ( file , high_dynamc_range_filename ) ; if ( e ) goto err_exit ; } if ( file && keep_utc && open_edit ) { gf_isom_keep_utc_times ( file , 1 ) ; } strcpy ( outfile , outName ? outName : inName ) ; { char * szExt = gf_file_ext_start ( outfile ) ; if ( szExt ) { if ( ! stricmp ( szExt , \".3gp\" ) || ! stricmp ( szExt , \".3gpp\" ) || ! stricmp ( szExt , \".3g2\" ) ) conv_type = GF_ISOM_CONV_TYPE_3GPP ; else if ( ! stricmp ( szExt , \".m4a\" ) || ! stricmp ( szExt , \".m4v\" ) ) conv_type = GF_ISOM_CONV_TYPE_IPOD ; else if ( ! stricmp ( szExt , \".psp\" ) ) conv_type = GF_ISOM_CONV_TYPE_PSP ; else if ( ! stricmp ( szExt , \".mov\" ) || ! stricmp ( szExt , \".qt\" ) ) conv_type = GF_ISOM_CONV_TYPE_MOV ; * szExt = 0 ; } } # ifndef GPAC_DISABLE_MEDIA_EXPORT if ( track_dump_type & GF_EXPORT_AVI_NATIVE ) { char szFile [ GF_MAX_PATH + 24 ] ; GF_MediaExporter mdump ; memset ( & mdump , 0 , sizeof ( mdump ) ) ; mdump . in_name = inName ; mdump . flags = GF_EXPORT_AVI_NATIVE ; mdump . trackID = trackID ; if ( dump_std ) { mdump . out_name = \"std\" ; } else if ( outName ) { mdump . out_name = outName ; } else if ( trackID > 2 ) { sprintf ( szFile , \"%s_audio%d\" , outfile , trackID - 1 ) ; mdump . out_name = szFile ; } else { sprintf ( szFile , \"%s_%s\" , outfile , ( trackID == 1 ) ? \"video\" : \"audio\" ) ; mdump . out_name = szFile ; } mdump . print_stats_graph = fs_dump_flags ; e = gf_media_export ( & mdump ) ; if ( e ) goto err_exit ; goto exit ; } if ( ! open_edit && track_dump_type && ! gf_isom_probe_file ( inName ) ) { GF_MediaExporter mdump ; char szFile [ GF_MAX_PATH + 24 ] ; for ( i = 0 ; i < nb_track_act ; i ++ ) { TrackAction * tka = & tracks [ i ] ; if ( tka -> act_type != TRAC_ACTION_RAW_EXTRACT ) continue ; memset ( & mdump , 0 , sizeof ( mdump ) ) ; mdump . in_name = inName ; mdump . flags = tka -> dump_type ; mdump . trackID = tka -> trackID ; mdump . sample_num = tka -> sample_num ; if ( outName ) { mdump . out_name = outName ; mdump . flags |= GF_EXPORT_MERGE ; } else if ( nb_track_act > 1 ) { sprintf ( szFile , \"%s_track%d\" , outfile , mdump . trackID ) ; mdump . out_name = szFile ; } else { mdump . out_name = outfile ; } mdump . print_stats_graph = fs_dump_flags ; e = gf_media_export ( & mdump ) ; if ( e ) goto err_exit ; } goto exit ; } # endif # ifndef GPAC_DISABLE_SCENE_DUMP if ( dump_mode != GF_SM_DUMP_NONE ) { e = dump_isom_scene ( inName , dump_std ? NULL : ( outName ? outName : outfile ) , outName ? GF_TRUE : GF_FALSE , dump_mode , do_scene_log , no_odf_conf ) ; if ( e ) goto err_exit ; } # endif # ifndef GPAC_DISABLE_SCENE_STATS if ( stat_level ) dump_isom_scene_stats ( inName , dump_std ? NULL : ( outName ? outName : outfile ) , outName ? GF_TRUE : GF_FALSE , stat_level ) ; # endif # ifndef GPAC_DISABLE_ISOM_HINTING if ( ! HintIt && print_sdp ) dump_isom_sdp ( file , dump_std ? NULL : ( outName ? outName : outfile ) , outName ? GF_TRUE : GF_FALSE ) ; # endif if ( get_nb_tracks ) { fprintf ( stdout , \"%d\\\\n\" , gf_isom_get_track_count ( file ) ) ; } if ( print_info ) { if ( ! file ) { fprintf ( stderr , \"Cannot<S2SV_blank>print<S2SV_blank>info<S2SV_blank>on<S2SV_blank>a<S2SV_blank>non<S2SV_blank>ISOM<S2SV_blank>file<S2SV_blank>(%s)\\\\n\" , inName ) ; } else { if ( info_track_id ) DumpTrackInfo ( file , info_track_id , 1 , ( print_info == 2 ) ? GF_TRUE : GF_FALSE ) ; else DumpMovieInfo ( file ) ; } } # ifndef GPAC_DISABLE_ISOM_DUMP if ( dump_isom ) { e = dump_isom_xml ( file , dump_std ? NULL : ( outName ? outName : outfile ) , outName ? GF_TRUE : GF_FALSE , ( dump_isom == 2 ) ? GF_TRUE : GF_FALSE , merge_vtt_cues , use_init_seg ? GF_TRUE : GF_FALSE , ( dump_isom == 3 ) ? GF_TRUE : GF_FALSE ) ; if ( e ) goto err_exit ; } if ( dump_cr ) dump_isom_ismacryp ( file , dump_std ? NULL : ( outName ? outName : outfile ) , outName ? GF_TRUE : GF_FALSE ) ; if ( ( dump_ttxt || dump_srt ) && trackID ) { if ( trackID == ( u32 ) - 1 ) { for ( j = 0 ; j < gf_isom_get_track_count ( file ) ; j ++ ) { trackID = gf_isom_get_track_id ( file , j + 1 ) ; dump_isom_timed_text ( file , trackID , dump_std ? NULL : ( outName ? outName : outfile ) , outName ? GF_TRUE : GF_FALSE , GF_FALSE , dump_srt ? GF_TEXTDUMPTYPE_SRT : GF_TEXTDUMPTYPE_TTXT ) ; } } else { dump_isom_timed_text ( file , trackID , dump_std ? NULL : ( outName ? outName : outfile ) , outName ? GF_TRUE : GF_FALSE , GF_FALSE , dump_srt ? GF_TEXTDUMPTYPE_SRT : GF_TEXTDUMPTYPE_TTXT ) ; } } # ifndef GPAC_DISABLE_ISOM_HINTING if ( dump_rtp ) dump_isom_rtp ( file , dump_std ? NULL : ( outName ? outName : outfile ) , outName ? GF_TRUE : GF_FALSE ) ; # endif # endif if ( dump_timestamps ) dump_isom_timestamps ( file , dump_std ? NULL : ( outName ? outName : outfile ) , outName ? GF_TRUE : GF_FALSE , dump_timestamps ) ; if ( dump_nal ) dump_isom_nal ( file , dump_nal , dump_std ? NULL : ( outName ? outName : outfile ) , outName ? GF_TRUE : GF_FALSE , dump_nal_type ) ; if ( dump_saps ) dump_isom_saps ( file , dump_saps , dump_saps_mode , dump_std ? NULL : ( outName ? outName : outfile ) , outName ? GF_TRUE : GF_FALSE ) ; if ( do_hash ) { e = hash_file ( inName , dump_std ) ; if ( e ) goto err_exit ; } # ifndef GPAC_DISABLE_CORE_TOOLS if ( do_bin_xml ) { e = xml_bs_to_bin ( inName , outName , dump_std ) ; if ( e ) goto err_exit ; } # endif if ( dump_cart ) dump_isom_cover_art ( file , dump_std ? NULL : ( outName ? outName : outfile ) , outName ? GF_TRUE : GF_FALSE ) ; if ( dump_chap ) dump_isom_chapters ( file , dump_std ? NULL : ( outName ? outName : outfile ) , outName ? GF_TRUE : GF_FALSE , dump_chap ) ; if ( dump_udta_type ) dump_isom_udta ( file , dump_std ? NULL : ( outName ? outName : outfile ) , outName ? GF_TRUE : GF_FALSE , dump_udta_type , dump_udta_track ) ; if ( dump_iod ) { GF_InitialObjectDescriptor * iod = ( GF_InitialObjectDescriptor * ) gf_isom_get_root_od ( file ) ; if ( ! iod ) { <S2SV_StartBug> fprintf ( stderr , \"File<S2SV_blank>%s<S2SV_blank>has<S2SV_blank>no<S2SV_blank>IOD\" , inName ) ; <S2SV_EndBug> } else { char szName [ GF_MAX_PATH + 10 ] ; FILE * iodf ; sprintf ( szName , \"%s.iod\" , outfile ) ; iodf = gf_fopen ( szName , \"wb\" ) ; if ( ! iodf ) { fprintf ( stderr , \"Cannot<S2SV_blank>open<S2SV_blank>destination<S2SV_blank>%s\\\\n\" , szName ) ; } else { u8 * desc ; u32 size ; GF_BitStream * bs = gf_bs_from_file ( iodf , GF_BITSTREAM_WRITE ) ; if ( gf_odf_desc_write ( ( GF_Descriptor * ) iod , & desc , & size ) == GF_OK ) { gf_fwrite ( desc , size , iodf ) ; gf_free ( desc ) ; } else { fprintf ( stderr , \"Error<S2SV_blank>writing<S2SV_blank>IOD<S2SV_blank>%s\\\\n\" , szName ) ; } gf_fclose ( iodf ) ; gf_bs_del ( bs ) ; } gf_odf_desc_del ( ( GF_Descriptor * ) iod ) ; } } # if ! defined ( GPAC_DISABLE_ISOM_WRITE ) && ! defined ( GPAC_DISABLE_MEDIA_IMPORT ) if ( split_duration || split_size || split_range_str ) { split_isomedia_file ( file , split_duration , split_size , inName , interleaving_time , split_start , adjust_split_end , outName , tmpdir , seg_at_rap , split_range_str ) ; open_edit = GF_FALSE ; needSave = GF_FALSE ; } # endif # ifndef GPAC_DISABLE_MEDIA_EXPORT if ( track_dump_type ) { char szFile [ GF_MAX_PATH + 24 ] ; GF_MediaExporter mdump ; for ( i = 0 ; i < nb_track_act ; i ++ ) { TrackAction * tka = & tracks [ i ] ; if ( tka -> act_type != TRAC_ACTION_RAW_EXTRACT ) continue ; memset ( & mdump , 0 , sizeof ( mdump ) ) ; mdump . file = file ; mdump . flags = tka -> dump_type ; mdump . trackID = tka -> trackID ; mdump . sample_num = tka -> sample_num ; if ( tka -> out_name ) { mdump . out_name = tka -> out_name ; } else if ( outName ) { mdump . out_name = outName ; mdump . flags |= GF_EXPORT_MERGE ; mdump . flags |= GF_EXPORT_NO_FILE_EXT ; } else if ( mdump . trackID ) { sprintf ( szFile , \"%s_track%d\" , outfile , mdump . trackID ) ; mdump . out_name = szFile ; } else { sprintf ( szFile , \"%s_export\" , outfile ) ; mdump . out_name = szFile ; } if ( tka -> trackID == ( u32 ) - 1 ) { for ( j = 0 ; j < gf_isom_get_track_count ( file ) ; j ++ ) { mdump . trackID = gf_isom_get_track_id ( file , j + 1 ) ; sprintf ( szFile , \"%s_track%d\" , outfile , mdump . trackID ) ; mdump . out_name = szFile ; mdump . print_stats_graph = fs_dump_flags ; e = gf_media_export ( & mdump ) ; if ( e ) goto err_exit ; } } else { mdump . print_stats_graph = fs_dump_flags ; e = gf_media_export ( & mdump ) ; if ( e ) goto err_exit ; } } } else if ( do_saf ) { GF_MediaExporter mdump ; memset ( & mdump , 0 , sizeof ( mdump ) ) ; mdump . file = file ; mdump . flags = GF_EXPORT_SAF ; mdump . out_name = outfile ; mdump . print_stats_graph = fs_dump_flags ; e = gf_media_export ( & mdump ) ; if ( e ) goto err_exit ; } # endif for ( i = 0 ; i < nb_meta_act ; i ++ ) { u32 tk = 0 ; # ifndef GPAC_DISABLE_ISOM_WRITE Bool self_ref ; # endif MetaAction * meta = & metas [ i ] ; if ( meta -> trackID ) tk = gf_isom_get_track_by_id ( file , meta -> trackID ) ; switch ( meta -> act_type ) { # ifndef GPAC_DISABLE_ISOM_WRITE case META_ACTION_SET_TYPE : e = gf_isom_set_meta_type ( file , meta -> root_meta , tk , meta -> meta_4cc ) ; gf_isom_modify_alternate_brand ( file , GF_ISOM_BRAND_ISO2 , GF_TRUE ) ; needSave = GF_TRUE ; break ; case META_ACTION_ADD_ITEM : self_ref = ! stricmp ( meta -> szPath , \"NULL\" ) || ! stricmp ( meta -> szPath , \"this\" ) || ! stricmp ( meta -> szPath , \"self\" ) ; e = gf_isom_add_meta_item ( file , meta -> root_meta , tk , self_ref , self_ref ? NULL : meta -> szPath , meta -> szName , meta -> item_id , meta -> item_type , meta -> mime_type , meta -> enc_type , meta -> use_dref ? meta -> szPath : NULL , NULL , meta -> image_props ) ; if ( meta -> ref_type ) { e = gf_isom_meta_add_item_ref ( file , meta -> root_meta , tk , meta -> item_id , meta -> ref_item_id , meta -> ref_type , NULL ) ; } needSave = GF_TRUE ; break ; case META_ACTION_ADD_IMAGE_ITEM : { u32 old_tk_count = gf_isom_get_track_count ( file ) ; GF_Fraction _frac = { 0 , 0 } ; e = import_file ( file , meta -> szPath , 0 , _frac , 0 , NULL , NULL , 0 ) ; if ( e == GF_OK ) { u32 meta_type = gf_isom_get_meta_type ( file , meta -> root_meta , tk ) ; if ( ! meta_type ) { e = gf_isom_set_meta_type ( file , meta -> root_meta , tk , GF_META_ITEM_TYPE_PICT ) ; } else { if ( meta_type != GF_META_ITEM_TYPE_PICT ) { GF_LOG ( GF_LOG_ERROR , GF_LOG_CONTAINER , ( \"Warning:<S2SV_blank>file<S2SV_blank>already<S2SV_blank>has<S2SV_blank>a<S2SV_blank>root<S2SV_blank>\\'meta\\'<S2SV_blank>box<S2SV_blank>of<S2SV_blank>type<S2SV_blank>%s\\\\n\" , gf_4cc_to_str ( meta_type ) ) ) ; e = GF_BAD_PARAM ; } } if ( e == GF_OK ) { if ( ! meta -> item_id ) { e = gf_isom_meta_get_next_item_id ( file , meta -> root_meta , tk , & meta -> item_id ) ; } if ( e == GF_OK ) { e = gf_isom_iff_create_image_item_from_track ( file , meta -> root_meta , tk , 1 , meta -> szName , meta -> item_id , meta -> image_props , NULL ) ; if ( e == GF_OK && meta -> primary ) { e = gf_isom_set_meta_primary_item ( file , meta -> root_meta , tk , meta -> item_id ) ; } if ( e == GF_OK && meta -> ref_type ) { e = gf_isom_meta_add_item_ref ( file , meta -> root_meta , tk , meta -> item_id , meta -> ref_item_id , meta -> ref_type , NULL ) ; } } } } gf_isom_remove_track ( file , old_tk_count + 1 ) ; needSave = GF_TRUE ; } break ; case META_ACTION_REM_ITEM : e = gf_isom_remove_meta_item ( file , meta -> root_meta , tk , meta -> item_id ) ; needSave = GF_TRUE ; break ; case META_ACTION_SET_PRIMARY_ITEM : e = gf_isom_set_meta_primary_item ( file , meta -> root_meta , tk , meta -> item_id ) ; needSave = GF_TRUE ; break ; case META_ACTION_SET_XML : case META_ACTION_SET_BINARY_XML : e = gf_isom_set_meta_xml ( file , meta -> root_meta , tk , meta -> szPath , NULL , 0 , ( meta -> act_type == META_ACTION_SET_BINARY_XML ) ? 1 : 0 ) ; needSave = GF_TRUE ; break ; case META_ACTION_REM_XML : if ( gf_isom_get_meta_item_count ( file , meta -> root_meta , tk ) ) { e = gf_isom_remove_meta_xml ( file , meta -> root_meta , tk ) ; needSave = GF_TRUE ; } else { fprintf ( stderr , \"No<S2SV_blank>meta<S2SV_blank>box<S2SV_blank>in<S2SV_blank>input<S2SV_blank>file\\\\n\" ) ; } break ; case META_ACTION_DUMP_ITEM : if ( gf_isom_get_meta_item_count ( file , meta -> root_meta , tk ) ) { e = gf_isom_extract_meta_item ( file , meta -> root_meta , tk , meta -> item_id , strlen ( meta -> szPath ) ? meta -> szPath : NULL ) ; } else { fprintf ( stderr , \"No<S2SV_blank>meta<S2SV_blank>box<S2SV_blank>in<S2SV_blank>input<S2SV_blank>file\\\\n\" ) ; } break ; # endif case META_ACTION_DUMP_XML : if ( gf_isom_has_meta_xml ( file , meta -> root_meta , tk ) ) { e = gf_isom_extract_meta_xml ( file , meta -> root_meta , tk , meta -> szPath , NULL ) ; } else { fprintf ( stderr , \"No<S2SV_blank>meta<S2SV_blank>box<S2SV_blank>in<S2SV_blank>input<S2SV_blank>file\\\\n\" ) ; } break ; default : break ; } if ( meta -> image_props ) { gf_free ( meta -> image_props ) ; meta -> image_props = NULL ; } if ( e ) goto err_exit ; } if ( ! open_edit && ! needSave ) { if ( file ) gf_isom_delete ( file ) ; goto exit ; } # ifndef GPAC_DISABLE_ISOM_WRITE if ( clean_groups ) { e = gf_isom_reset_switch_parameters ( file ) ; if ( e ) goto err_exit ; needSave = GF_TRUE ; } for ( i = 0 ; i < nb_tsel_acts ; i ++ ) { switch ( tsel_acts [ i ] . act_type ) { case TSEL_ACTION_SET_PARAM : e = gf_isom_set_track_switch_parameter ( file , gf_isom_get_track_by_id ( file , tsel_acts [ i ] . trackID ) , tsel_acts [ i ] . refTrackID ? gf_isom_get_track_by_id ( file , tsel_acts [ i ] . refTrackID ) : 0 , tsel_acts [ i ] . is_switchGroup ? 1 : 0 , & tsel_acts [ i ] . switchGroupID , tsel_acts [ i ] . criteria , tsel_acts [ i ] . nb_criteria ) ; if ( e == GF_BAD_PARAM ) { u32 alternateGroupID , nb_groups ; gf_isom_get_track_switch_group_count ( file , gf_isom_get_track_by_id ( file , tsel_acts [ i ] . trackID ) , & alternateGroupID , & nb_groups ) ; if ( alternateGroupID ) fprintf ( stderr , \"Hint:<S2SV_blank>for<S2SV_blank>adding<S2SV_blank>more<S2SV_blank>tracks<S2SV_blank>to<S2SV_blank>group,<S2SV_blank>using:<S2SV_blank>-group-add<S2SV_blank>-refTrack=ID1:[criteria:]trackID=ID2\\\\n\" ) ; else fprintf ( stderr , \"Hint:<S2SV_blank>for<S2SV_blank>creates<S2SV_blank>a<S2SV_blank>new<S2SV_blank>grouping<S2SV_blank>information,<S2SV_blank>using<S2SV_blank>-group-add<S2SV_blank>-trackID=ID1:[criteria:]trackID=ID2\\\\n\" ) ; } if ( e ) goto err_exit ; needSave = GF_TRUE ; break ; case TSEL_ACTION_REMOVE_TSEL : e = gf_isom_reset_track_switch_parameter ( file , gf_isom_get_track_by_id ( file , tsel_acts [ i ] . trackID ) , 0 ) ; if ( e ) goto err_exit ; needSave = GF_TRUE ; break ; case TSEL_ACTION_REMOVE_ALL_TSEL_IN_GROUP : e = gf_isom_reset_track_switch_parameter ( file , gf_isom_get_track_by_id ( file , tsel_acts [ i ] . trackID ) , 1 ) ; if ( e ) goto err_exit ; needSave = GF_TRUE ; break ; default : break ; } } if ( remove_sys_tracks ) { # ifndef GPAC_DISABLE_AV_PARSERS remove_systems_tracks ( file ) ; # endif needSave = GF_TRUE ; if ( conv_type < GF_ISOM_CONV_TYPE_ISMA_EX ) conv_type = 0 ; } if ( remove_root_od ) { gf_isom_remove_root_od ( file ) ; needSave = GF_TRUE ; } # ifndef GPAC_DISABLE_ISOM_HINTING if ( remove_hint ) { for ( i = 0 ; i < gf_isom_get_track_count ( file ) ; i ++ ) { if ( gf_isom_get_media_type ( file , i + 1 ) == GF_ISOM_MEDIA_HINT ) { fprintf ( stderr , \"Removing<S2SV_blank>hint<S2SV_blank>track<S2SV_blank>ID<S2SV_blank>%d\\\\n\" , gf_isom_get_track_id ( file , i + 1 ) ) ; gf_isom_remove_track ( file , i + 1 ) ; i -- ; } } gf_isom_sdp_clean ( file ) ; needSave = GF_TRUE ; } # endif if ( timescale && ( timescale != gf_isom_get_timescale ( file ) ) ) { gf_isom_set_timescale ( file , timescale ) ; needSave = GF_TRUE ; } if ( ! encode ) { if ( ! file ) { fprintf ( stderr , \"Nothing<S2SV_blank>to<S2SV_blank>do<S2SV_blank>-<S2SV_blank>exiting\\\\n\" ) ; goto exit ; } if ( outName ) { strcpy ( outfile , outName ) ; } else { char * rel_name = strrchr ( inName , GF_PATH_SEPARATOR ) ; if ( ! rel_name ) rel_name = strrchr ( inName , '/' ) ; strcpy ( outfile , \"\" ) ; if ( tmpdir ) { strcpy ( outfile , tmpdir ) ; if ( ! strchr ( \"\\\\\\\\/\" , tmpdir [ strlen ( tmpdir ) - 1 ] ) ) strcat ( outfile , \"/\" ) ; } if ( ! pack_file ) strcat ( outfile , \"out_\" ) ; strcat ( outfile , rel_name ? rel_name + 1 : inName ) ; if ( pack_file ) { strcpy ( outfile , rel_name ? rel_name + 1 : inName ) ; rel_name = strrchr ( outfile , '.' ) ; if ( rel_name ) rel_name [ 0 ] = 0 ; strcat ( outfile , \".m21\" ) ; } } # ifndef GPAC_DISABLE_MEDIA_IMPORT if ( ( conv_type == GF_ISOM_CONV_TYPE_ISMA ) || ( conv_type == GF_ISOM_CONV_TYPE_ISMA_EX ) ) { fprintf ( stderr , \"Converting<S2SV_blank>to<S2SV_blank>ISMA<S2SV_blank>Audio-Video<S2SV_blank>MP4<S2SV_blank>file...\\\\n\" ) ; e = gf_media_make_isma ( file , crypt ? 1 : 0 , GF_FALSE , ( conv_type == GF_ISOM_CONV_TYPE_ISMA_EX ) ? 1 : 0 ) ; if ( e ) goto err_exit ; needSave = GF_TRUE ; } if ( conv_type == GF_ISOM_CONV_TYPE_3GPP ) { fprintf ( stderr , \"Converting<S2SV_blank>to<S2SV_blank>3GP<S2SV_blank>file...\\\\n\" ) ; e = gf_media_make_3gpp ( file ) ; if ( e ) goto err_exit ; needSave = GF_TRUE ; } if ( conv_type == GF_ISOM_CONV_TYPE_PSP ) { fprintf ( stderr , \"Converting<S2SV_blank>to<S2SV_blank>PSP<S2SV_blank>file...\\\\n\" ) ; e = gf_media_make_psp ( file ) ; if ( e ) goto err_exit ; needSave = GF_TRUE ; } if ( conv_type == GF_ISOM_CONV_TYPE_MOV ) { e = gf_media_check_qt_prores ( file ) ; if ( e ) goto err_exit ; needSave = GF_TRUE ; if ( interleaving_time ) interleaving_time = 0.5 ; } # endif if ( conv_type == GF_ISOM_CONV_TYPE_IPOD ) { u32 ipod_major_brand = 0 ; fprintf ( stderr , \"Setting<S2SV_blank>up<S2SV_blank>iTunes/iPod<S2SV_blank>file...\\\\n\" ) ; for ( i = 0 ; i < gf_isom_get_track_count ( file ) ; i ++ ) { u32 mType = gf_isom_get_media_type ( file , i + 1 ) ; switch ( mType ) { case GF_ISOM_MEDIA_VISUAL : case GF_ISOM_MEDIA_AUXV : case GF_ISOM_MEDIA_PICT : ipod_major_brand = GF_ISOM_BRAND_M4V ; gf_isom_set_ipod_compatible ( file , i + 1 ) ; break ; case GF_ISOM_MEDIA_AUDIO : if ( ! ipod_major_brand ) ipod_major_brand = GF_ISOM_BRAND_M4A ; else gf_isom_modify_alternate_brand ( file , GF_ISOM_BRAND_M4A , GF_TRUE ) ; break ; case GF_ISOM_MEDIA_TEXT : if ( gf_isom_get_media_subtype ( file , i + 1 , 1 ) == GF_ISOM_SUBTYPE_TX3G ) { Bool is_chap = 0 ; for ( j = 0 ; j < gf_isom_get_track_count ( file ) ; j ++ ) { s32 count = gf_isom_get_reference_count ( file , j + 1 , GF_ISOM_REF_CHAP ) ; if ( count > 0 ) { u32 tk , k ; for ( k = 0 ; k < ( u32 ) count ; k ++ ) { gf_isom_get_reference ( file , j + 1 , GF_ISOM_REF_CHAP , k + 1 , & tk ) ; if ( tk == i + 1 ) { is_chap = 1 ; break ; } } if ( is_chap ) break ; } if ( is_chap ) break ; } if ( ! is_chap ) gf_isom_set_media_type ( file , i + 1 , GF_ISOM_MEDIA_SUBT ) ; } break ; } } gf_isom_set_brand_info ( file , ipod_major_brand , 1 ) ; gf_isom_modify_alternate_brand ( file , GF_ISOM_BRAND_MP42 , GF_TRUE ) ; needSave = GF_TRUE ; } } else if ( outName ) { strcpy ( outfile , outName ) ; } for ( j = 0 ; j < nb_track_act ; j ++ ) { TrackAction * tka = & tracks [ j ] ; u32 track = tka -> trackID ? gf_isom_get_track_by_id ( file , tka -> trackID ) : 0 ; timescale = gf_isom_get_timescale ( file ) ; switch ( tka -> act_type ) { case TRAC_ACTION_REM_TRACK : e = gf_isom_remove_track ( file , track ) ; if ( e ) { fprintf ( stderr , \"Error<S2SV_blank>Removing<S2SV_blank>track<S2SV_blank>ID<S2SV_blank>%d:<S2SV_blank>%s\\\\n\" , tka -> trackID , gf_error_to_string ( e ) ) ; } else { fprintf ( stderr , \"Removing<S2SV_blank>track<S2SV_blank>ID<S2SV_blank>%d\\\\n\" , tka -> trackID ) ; } needSave = GF_TRUE ; break ; case TRAC_ACTION_SET_LANGUAGE : for ( i = 0 ; i < gf_isom_get_track_count ( file ) ; i ++ ) { if ( track && ( track != i + 1 ) ) continue ; e = gf_isom_set_media_language ( file , i + 1 , tka -> lang ) ; if ( e ) goto err_exit ; needSave = GF_TRUE ; } needSave = GF_TRUE ; break ; case TRAC_ACTION_SET_KIND : for ( i = 0 ; i < gf_isom_get_track_count ( file ) ; i ++ ) { if ( track && ( track != i + 1 ) ) continue ; e = gf_isom_add_track_kind ( file , i + 1 , tka -> kind_scheme , tka -> kind_value ) ; if ( e ) goto err_exit ; needSave = GF_TRUE ; } needSave = GF_TRUE ; break ; case TRAC_ACTION_REM_KIND : for ( i = 0 ; i < gf_isom_get_track_count ( file ) ; i ++ ) { if ( track && ( track != i + 1 ) ) continue ; e = gf_isom_remove_track_kind ( file , i + 1 , tka -> kind_scheme , tka -> kind_value ) ; if ( e ) goto err_exit ; needSave = GF_TRUE ; } needSave = GF_TRUE ; break ; case TRAC_ACTION_SET_DELAY : if ( tka -> delay_ms ) { u64 tk_dur ; gf_isom_remove_edits ( file , track ) ; tk_dur = gf_isom_get_track_duration ( file , track ) ; if ( gf_isom_get_edits_count ( file , track ) ) needSave = GF_TRUE ; if ( tka -> delay_ms > 0 ) { gf_isom_append_edit ( file , track , ( timescale * tka -> delay_ms ) / 1000 , 0 , GF_ISOM_EDIT_EMPTY ) ; gf_isom_append_edit ( file , track , tk_dur , 0 , GF_ISOM_EDIT_NORMAL ) ; needSave = GF_TRUE ; } else { u64 to_skip = ( timescale * ( - tka -> delay_ms ) ) / 1000 ; if ( to_skip < tk_dur ) { u64 media_time = ( - tka -> delay_ms ) * gf_isom_get_media_timescale ( file , track ) / 1000 ; gf_isom_append_edit ( file , track , tk_dur - to_skip , media_time , GF_ISOM_EDIT_NORMAL ) ; needSave = GF_TRUE ; } else { fprintf ( stderr , \"Warning:<S2SV_blank>request<S2SV_blank>negative<S2SV_blank>delay<S2SV_blank>longer<S2SV_blank>than<S2SV_blank>track<S2SV_blank>duration<S2SV_blank>-<S2SV_blank>ignoring\\\\n\" ) ; } } } else if ( gf_isom_get_edits_count ( file , track ) ) { gf_isom_remove_edits ( file , track ) ; needSave = GF_TRUE ; } break ; case TRAC_ACTION_SET_KMS_URI : for ( i = 0 ; i < gf_isom_get_track_count ( file ) ; i ++ ) { if ( track && ( track != i + 1 ) ) continue ; if ( ! gf_isom_is_media_encrypted ( file , i + 1 , 1 ) ) continue ; if ( ! gf_isom_is_ismacryp_media ( file , i + 1 , 1 ) ) continue ; e = gf_isom_change_ismacryp_protection ( file , i + 1 , 1 , NULL , ( char * ) tka -> kms ) ; if ( e ) goto err_exit ; needSave = GF_TRUE ; } break ; case TRAC_ACTION_SET_ID : if ( ! tka -> trackID && ( gf_isom_get_track_count ( file ) == 1 ) ) { fprintf ( stderr , \"Warning:<S2SV_blank>track<S2SV_blank>id<S2SV_blank>is<S2SV_blank>not<S2SV_blank>specified,<S2SV_blank>but<S2SV_blank>file<S2SV_blank>has<S2SV_blank>only<S2SV_blank>one<S2SV_blank>track<S2SV_blank>-<S2SV_blank>assume<S2SV_blank>that<S2SV_blank>you<S2SV_blank>want<S2SV_blank>to<S2SV_blank>change<S2SV_blank>id<S2SV_blank>for<S2SV_blank>this<S2SV_blank>track\\\\n\" ) ; track = 1 ; } if ( track ) { u32 newTrack ; newTrack = gf_isom_get_track_by_id ( file , tka -> newTrackID ) ; if ( newTrack != 0 ) { fprintf ( stderr , \"Error:<S2SV_blank>Cannot<S2SV_blank>set<S2SV_blank>track<S2SV_blank>id<S2SV_blank>with<S2SV_blank>value<S2SV_blank>%d<S2SV_blank>because<S2SV_blank>a<S2SV_blank>track<S2SV_blank>already<S2SV_blank>exists<S2SV_blank>-<S2SV_blank>ignoring\" , tka -> newTrackID ) ; } else { e = gf_isom_set_track_id ( file , track , tka -> newTrackID ) ; needSave = GF_TRUE ; } } else { fprintf ( stderr , \"Error:<S2SV_blank>Cannot<S2SV_blank>change<S2SV_blank>id<S2SV_blank>for<S2SV_blank>track<S2SV_blank>%d<S2SV_blank>because<S2SV_blank>it<S2SV_blank>does<S2SV_blank>not<S2SV_blank>exist<S2SV_blank>-<S2SV_blank>ignoring\" , tka -> trackID ) ; } break ; case TRAC_ACTION_SWAP_ID : if ( track ) { u32 tk1 , tk2 ; tk1 = gf_isom_get_track_by_id ( file , tka -> trackID ) ; tk2 = gf_isom_get_track_by_id ( file , tka -> newTrackID ) ; if ( ! tk1 || ! tk2 ) { fprintf ( stderr , \"Error:<S2SV_blank>Cannot<S2SV_blank>swap<S2SV_blank>track<S2SV_blank>IDs<S2SV_blank>because<S2SV_blank>not<S2SV_blank>existing<S2SV_blank>-<S2SV_blank>ignoring\" ) ; } else { e = gf_isom_set_track_id ( file , tk2 , 0 ) ; if ( ! e ) e = gf_isom_set_track_id ( file , tk1 , tka -> newTrackID ) ; if ( ! e ) e = gf_isom_set_track_id ( file , tk2 , tka -> trackID ) ; needSave = GF_TRUE ; } } else { fprintf ( stderr , \"Error:<S2SV_blank>Cannot<S2SV_blank>change<S2SV_blank>id<S2SV_blank>for<S2SV_blank>track<S2SV_blank>%d<S2SV_blank>because<S2SV_blank>it<S2SV_blank>does<S2SV_blank>not<S2SV_blank>exist<S2SV_blank>-<S2SV_blank>ignoring\" , tka -> trackID ) ; } break ; case TRAC_ACTION_SET_PAR : e = gf_media_change_par ( file , track , tka -> par_num , tka -> par_den , tka -> force_par , tka -> rewrite_bs ) ; needSave = GF_TRUE ; break ; case TRAC_ACTION_SET_CLAP : e = gf_isom_set_clean_aperture ( file , track , 1 , tka -> clap_wnum , tka -> clap_wden , tka -> clap_hnum , tka -> clap_hden , tka -> clap_honum , tka -> clap_hoden , tka -> clap_vonum , tka -> clap_voden ) ; needSave = GF_TRUE ; break ; case TRAC_ACTION_SET_MX : e = gf_isom_set_track_matrix ( file , track , tka -> mx ) ; needSave = GF_TRUE ; break ; case TRAC_ACTION_SET_HANDLER_NAME : e = gf_isom_set_handler_name ( file , track , tka -> hdl_name ) ; needSave = GF_TRUE ; break ; case TRAC_ACTION_ENABLE : if ( ! gf_isom_is_track_enabled ( file , track ) ) { e = gf_isom_set_track_enabled ( file , track , GF_TRUE ) ; needSave = GF_TRUE ; } break ; case TRAC_ACTION_DISABLE : if ( gf_isom_is_track_enabled ( file , track ) ) { e = gf_isom_set_track_enabled ( file , track , GF_FALSE ) ; needSave = GF_TRUE ; } break ; case TRAC_ACTION_REFERENCE : e = gf_isom_set_track_reference ( file , track , GF_4CC ( tka -> lang [ 0 ] , tka -> lang [ 1 ] , tka -> lang [ 2 ] , tka -> lang [ 3 ] ) , ( u32 ) tka -> delay_ms ) ; needSave = GF_TRUE ; break ; case TRAC_ACTION_REM_NON_RAP : fprintf ( stderr , \"Removing<S2SV_blank>non-rap<S2SV_blank>samples<S2SV_blank>from<S2SV_blank>track<S2SV_blank>%d\\\\n\" , tka -> trackID ) ; e = gf_media_remove_non_rap ( file , track , GF_FALSE ) ; needSave = GF_TRUE ; break ; case TRAC_ACTION_REM_NON_REFS : fprintf ( stderr , \"Removing<S2SV_blank>non-reference<S2SV_blank>samples<S2SV_blank>from<S2SV_blank>track<S2SV_blank>%d\\\\n\" , tka -> trackID ) ; e = gf_media_remove_non_rap ( file , track , GF_TRUE ) ; needSave = GF_TRUE ; break ; case TRAC_ACTION_SET_UDTA : fprintf ( stderr , \"Assigning<S2SV_blank>udta<S2SV_blank>box\\\\n\" ) ; e = set_file_udta ( file , track , tka -> udta_type , tka -> src_name , tka -> sample_num ? GF_TRUE : GF_FALSE ) ; if ( e ) goto err_exit ; needSave = GF_TRUE ; break ; default : break ; } if ( e ) goto err_exit ; } if ( itunes_tags ) { char * tags = itunes_tags ; while ( tags ) { char * val ; char * sep = gf_url_colon_suffix ( tags ) ; u32 tlen , itag = 0 ; if ( sep ) { while ( sep ) { for ( itag = 0 ; itag < nb_itunes_tags ; itag ++ ) { if ( ! strnicmp ( sep + 1 , itags [ itag ] . name , strlen ( itags [ itag ] . name ) ) ) break ; } if ( itag < nb_itunes_tags ) { break ; } sep = gf_url_colon_suffix ( sep + 1 ) ; } if ( sep ) sep [ 0 ] = 0 ; } for ( itag = 0 ; itag < nb_itunes_tags ; itag ++ ) { if ( ! strnicmp ( tags , itags [ itag ] . name , strlen ( itags [ itag ] . name ) ) ) { break ; } } if ( itag == nb_itunes_tags ) { fprintf ( stderr , \"Invalid<S2SV_blank>iTune<S2SV_blank>tag<S2SV_blank>format<S2SV_blank>\\\\\"%s\\\\\"<S2SV_blank>-<S2SV_blank>ignoring\\\\n\" , tags ) ; tags = NULL ; continue ; } itag = itags [ itag ] . code ; val = strchr ( tags , '=' ) ; if ( ! val ) { fprintf ( stderr , \"Invalid<S2SV_blank>iTune<S2SV_blank>tag<S2SV_blank>format<S2SV_blank>\\\\\"%s\\\\\"<S2SV_blank>(expecting<S2SV_blank>\\'=\\')<S2SV_blank>-<S2SV_blank>ignoring\\\\n\" , tags ) ; tags = NULL ; continue ; } val ++ ; if ( ( val [ 0 ] == ':' ) || ! val [ 0 ] || ! stricmp ( val , \"NULL\" ) ) val = NULL ; tlen = val ? ( u32 ) strlen ( val ) : 0 ; switch ( itag ) { case GF_ISOM_ITUNE_COVER_ART : { u8 * d = NULL ; e = GF_OK ; if ( val ) { char * ext ; e = gf_file_load_data ( val , ( u8 * * ) & d , & tlen ) ; ext = strrchr ( val , '.' ) ; if ( ! stricmp ( ext , \".png\" ) ) tlen |= 0x80000000 ; } if ( ! e ) e = gf_isom_apple_set_tag ( file , GF_ISOM_ITUNE_COVER_ART , d , tlen ) ; if ( d ) gf_free ( d ) ; } break ; case GF_ISOM_ITUNE_TEMPO : gf_isom_apple_set_tag ( file , itag , NULL , val ? atoi ( val ) : 0 ) ; break ; case GF_ISOM_ITUNE_GENRE : { u8 _v = gf_id3_get_genre_tag ( val ) ; if ( _v ) { gf_isom_apple_set_tag ( file , itag , NULL , _v ) ; } else { if ( ! val ) val = \"\" ; gf_isom_apple_set_tag ( file , itag , ( u8 * ) val , ( u32 ) strlen ( val ) ) ; } } break ; case GF_ISOM_ITUNE_DISK : case GF_ISOM_ITUNE_TRACKNUMBER : { u32 n , t ; char _t [ 8 ] ; n = t = 0 ; if ( val ) { memset ( _t , 0 , sizeof ( char ) * 8 ) ; tlen = ( itag == GF_ISOM_ITUNE_DISK ) ? 6 : 8 ; if ( sscanf ( val , \"%u/%u\" , & n , & t ) == 2 ) { _t [ 3 ] = n ; _t [ 2 ] = n >> 8 ; _t [ 5 ] = t ; _t [ 4 ] = t >> 8 ; } else if ( sscanf ( val , \"%u\" , & n ) == 1 ) { _t [ 3 ] = n ; _t [ 2 ] = n >> 8 ; } else tlen = 0 ; } if ( ! val || tlen ) gf_isom_apple_set_tag ( file , itag , val ? ( u8 * ) _t : NULL , tlen ) ; } break ; case GF_ISOM_ITUNE_GAPLESS : case GF_ISOM_ITUNE_COMPILATION : { u8 _t [ 1 ] ; if ( val && ! stricmp ( val , \"yes\" ) ) _t [ 0 ] = 1 ; else _t [ 0 ] = 0 ; gf_isom_apple_set_tag ( file , itag , _t , 1 ) ; } break ; default : gf_isom_apple_set_tag ( file , itag , ( u8 * ) val , tlen ) ; break ; } needSave = GF_TRUE ; if ( sep ) { sep [ 0 ] = ':' ; tags = sep + 1 ; } else { tags = NULL ; } } } if ( movie_time ) { gf_isom_set_creation_time ( file , movie_time ) ; for ( i = 0 ; i < gf_isom_get_track_count ( file ) ; i ++ ) { gf_isom_set_track_creation_time ( file , i + 1 , movie_time ) ; } needSave = GF_TRUE ; } if ( cprt ) { e = gf_isom_set_copyright ( file , \"und\" , cprt ) ; needSave = GF_TRUE ; if ( e ) goto err_exit ; } if ( chap_file ) { # ifndef GPAC_DISABLE_MEDIA_IMPORT e = gf_media_import_chapters ( file , chap_file , import_fps , chap_qt ) ; needSave = GF_TRUE ; # else fprintf ( stderr , \"Warning:<S2SV_blank>GPAC<S2SV_blank>compiled<S2SV_blank>without<S2SV_blank>Media<S2SV_blank>Import,<S2SV_blank>chapters<S2SV_blank>can\\'t<S2SV_blank>be<S2SV_blank>imported\\\\n\" ) ; e = GF_NOT_SUPPORTED ; # endif if ( e ) goto err_exit ; } if ( major_brand ) { gf_isom_set_brand_info ( file , major_brand , minor_version ) ; needSave = GF_TRUE ; } for ( i = 0 ; i < nb_alt_brand_add ; i ++ ) { gf_isom_modify_alternate_brand ( file , brand_add [ i ] , GF_TRUE ) ; needSave = GF_TRUE ; } for ( i = 0 ; i < nb_alt_brand_rem ; i ++ ) { gf_isom_modify_alternate_brand ( file , brand_rem [ i ] , GF_FALSE ) ; needSave = GF_TRUE ; } if ( box_patch_filename ) { e = gf_isom_apply_box_patch ( file , box_patch_trackID , box_patch_filename , GF_FALSE ) ; if ( e ) { fprintf ( stderr , \"Failed<S2SV_blank>to<S2SV_blank>apply<S2SV_blank>box<S2SV_blank>patch<S2SV_blank>%s:<S2SV_blank>%s\\\\n\" , box_patch_filename , gf_error_to_string ( e ) ) ; goto err_exit ; } needSave = GF_TRUE ; } # ifndef GPAC_DISABLE_CRYPTO if ( crypt ) { if ( ! drm_file ) { fprintf ( stderr , \"Missing<S2SV_blank>DRM<S2SV_blank>file<S2SV_blank>location<S2SV_blank>-<S2SV_blank>usage<S2SV_blank>\\'-%s<S2SV_blank>drm_file<S2SV_blank>input_file\\\\n\" , ( crypt == 1 ) ? \"crypt\" : \"decrypt\" ) ; e = GF_BAD_PARAM ; goto err_exit ; } if ( get_file_type_by_ext ( inName ) != GF_FILE_TYPE_ISO_MEDIA ) { fprintf ( stderr , \"MP4Box<S2SV_blank>can<S2SV_blank>crypt<S2SV_blank>only<S2SV_blank>ISOMedia<S2SV_blank>File\\\\n\" ) ; e = GF_BAD_PARAM ; goto err_exit ; } if ( crypt == 1 ) { if ( use_init_seg ) { e = gf_crypt_fragment ( file , drm_file , outfile , inName , fs_dump_flags ) ; } else { e = gf_crypt_file ( file , drm_file , outfile , interleaving_time , fs_dump_flags ) ; } } else if ( crypt == 2 ) { if ( use_init_seg ) { e = gf_decrypt_fragment ( file , drm_file , outfile , inName , fs_dump_flags ) ; } else { e = gf_decrypt_file ( file , drm_file , outfile , interleaving_time , fs_dump_flags ) ; } } if ( e ) goto err_exit ; needSave = outName ? GF_FALSE : GF_TRUE ; if ( ! Frag && ! HintIt && ! FullInter && ! force_co64 ) { char szName [ GF_MAX_PATH ] ; strcpy ( szName , gf_isom_get_filename ( file ) ) ; gf_isom_delete ( file ) ; file = NULL ; if ( ! outName ) { e = gf_file_move ( outfile , szName ) ; if ( e ) goto err_exit ; } goto exit ; } } # endif # ifndef GPAC_DISABLE_ISOM_FRAGMENTS if ( Frag ) { if ( ! interleaving_time ) interleaving_time = DEFAULT_INTERLEAVING_IN_SEC ; if ( HintIt ) fprintf ( stderr , \"Warning:<S2SV_blank>cannot<S2SV_blank>hint<S2SV_blank>and<S2SV_blank>fragment<S2SV_blank>-<S2SV_blank>ignoring<S2SV_blank>hint\\\\n\" ) ; fprintf ( stderr , \"Fragmenting<S2SV_blank>file<S2SV_blank>(%.3f<S2SV_blank>seconds<S2SV_blank>fragments)\\\\n\" , interleaving_time ) ; e = gf_media_fragment_file ( file , outfile , interleaving_time , use_mfra ) ; if ( e ) fprintf ( stderr , \"Error<S2SV_blank>while<S2SV_blank>fragmenting<S2SV_blank>file:<S2SV_blank>%s\\\\n\" , gf_error_to_string ( e ) ) ; if ( ! e && ! outName ) { if ( gf_file_exists ( inName ) && gf_file_delete ( inName ) ) fprintf ( stderr , \"Error<S2SV_blank>removing<S2SV_blank>file<S2SV_blank>%s\\\\n\" , inName ) ; else if ( gf_file_move ( outfile , inName ) ) fprintf ( stderr , \"Error<S2SV_blank>renaming<S2SV_blank>file<S2SV_blank>%s<S2SV_blank>to<S2SV_blank>%s\\\\n\" , outfile , inName ) ; } if ( e ) goto err_exit ; gf_isom_delete ( file ) ; goto exit ; } # endif # ifndef GPAC_DISABLE_ISOM_HINTING if ( HintIt ) { if ( force_ocr ) SetupClockReferences ( file ) ; fprintf ( stderr , \"Hinting<S2SV_blank>file<S2SV_blank>with<S2SV_blank>Path-MTU<S2SV_blank>%d<S2SV_blank>Bytes\\\\n\" , MTUSize ) ; MTUSize -= 12 ; e = HintFile ( file , MTUSize , max_ptime , rtp_rate , hint_flags , HintCopy , HintInter , regular_iod , single_group , hint_no_offset ) ; if ( e ) goto err_exit ; needSave = GF_TRUE ; if ( print_sdp ) dump_isom_sdp ( file , dump_std ? NULL : ( outName ? outName : outfile ) , outName ? GF_TRUE : GF_FALSE ) ; } # endif # if ! defined ( GPAC_DISABLE_ISOM_HINTING ) && ! defined ( GPAC_DISABLE_SENG ) for ( i = 0 ; i < nb_sdp_ex ; i ++ ) { if ( sdp_lines [ i ] . trackID ) { u32 track = gf_isom_get_track_by_id ( file , sdp_lines [ i ] . trackID ) ; if ( gf_isom_get_media_type ( file , track ) != GF_ISOM_MEDIA_HINT ) { s32 ref_count ; u32 k , count = gf_isom_get_track_count ( file ) ; for ( j = 0 ; j < count ; j ++ ) { if ( gf_isom_get_media_type ( file , j + 1 ) != GF_ISOM_MEDIA_HINT ) continue ; ref_count = gf_isom_get_reference_count ( file , j + 1 , GF_ISOM_REF_HINT ) ; if ( ref_count < 0 ) continue ; for ( k = 0 ; k < ( u32 ) ref_count ; k ++ ) { u32 refTk ; if ( gf_isom_get_reference ( file , j + 1 , GF_ISOM_REF_HINT , k + 1 , & refTk ) ) continue ; if ( refTk == track ) { track = j + 1 ; j = count ; break ; } } } } gf_isom_sdp_add_track_line ( file , track , sdp_lines [ i ] . line ) ; needSave = GF_TRUE ; } else { gf_isom_sdp_add_line ( file , sdp_lines [ i ] . line ) ; needSave = GF_TRUE ; } } # endif if ( FullInter ) { e = gf_isom_set_storage_mode ( file , GF_ISOM_STORE_TIGHT ) ; } else if ( do_flat ) { e = gf_isom_set_storage_mode ( file , ( do_flat == 1 ) ? GF_ISOM_STORE_FLAT : GF_ISOM_STORE_STREAMABLE ) ; needSave = GF_TRUE ; } else { e = gf_isom_make_interleave ( file , interleaving_time ) ; if ( ! e && old_interleave ) e = gf_isom_set_storage_mode ( file , GF_ISOM_STORE_INTERLEAVED ) ; } if ( force_co64 ) gf_isom_force_64bit_chunk_offset ( file , GF_TRUE ) ; if ( compress_moov ) gf_isom_enable_compression ( file , GF_ISO_COMP_MOOV , GF_FALSE ) ; if ( e ) goto err_exit ; if ( ! encode && ! force_new ) gf_isom_set_final_name ( file , outfile ) ; if ( needSave ) { if ( ! gf_sys_is_quiet ( ) ) { if ( outName ) { gf_isom_set_final_name ( file , outfile ) ; } else if ( encode || pack_file ) { fprintf ( stderr , \"Saving<S2SV_blank>to<S2SV_blank>%s:<S2SV_blank>\" , gf_isom_get_filename ( file ) ) ; } else { fprintf ( stderr , \"Saving<S2SV_blank>%s:<S2SV_blank>\" , inName ) ; } if ( HintIt && FullInter ) fprintf ( stderr , \"Hinted<S2SV_blank>file<S2SV_blank>-<S2SV_blank>Full<S2SV_blank>Interleaving\\\\n\" ) ; else if ( FullInter ) fprintf ( stderr , \"Full<S2SV_blank>Interleaving\\\\n\" ) ; else if ( ( force_new == 2 ) && interleaving_time ) fprintf ( stderr , \"Fast-start<S2SV_blank>interleaved<S2SV_blank>storage\\\\n\" ) ; else if ( do_flat || ! interleaving_time ) fprintf ( stderr , \"Flat<S2SV_blank>storage\\\\n\" ) ; else fprintf ( stderr , \"%.3f<S2SV_blank>secs<S2SV_blank>Interleaving%s\\\\n\" , interleaving_time , old_interleave ? \"<S2SV_blank>-<S2SV_blank>no<S2SV_blank>drift<S2SV_blank>control\" : \"\" ) ; } else { if ( outName ) gf_isom_set_final_name ( file , outfile ) ; } e = gf_isom_close ( file ) ; file = NULL ; if ( ! e && ! outName && ! encode && ! force_new && ! pack_file ) { if ( gf_file_exists ( inName ) ) { e = gf_file_delete ( inName ) ; if ( e ) { fprintf ( stderr , \"Error<S2SV_blank>removing<S2SV_blank>file<S2SV_blank>%s\\\\n\" , inName ) ; } } e = gf_file_move ( outfile , inName ) ; if ( e ) { fprintf ( stderr , \"Error<S2SV_blank>renaming<S2SV_blank>file<S2SV_blank>%s<S2SV_blank>to<S2SV_blank>%s\\\\n\" , outfile , inName ) ; } } } else { gf_isom_delete ( file ) ; } if ( e ) { fprintf ( stderr , \"Error:<S2SV_blank>%s\\\\n\" , gf_error_to_string ( e ) ) ; goto err_exit ; } goto exit ; # else gf_isom_delete ( file ) ; fprintf ( stderr , \"Error:<S2SV_blank>Read-only<S2SV_blank>version<S2SV_blank>of<S2SV_blank>MP4Box.\\\\n\" ) ; return mp4box_cleanup ( 1 ) ; # endif err_exit : if ( file ) gf_isom_delete ( file ) ; fprintf ( stderr , \"\\\\n\\\\tError:<S2SV_blank>%s\\\\n\" , gf_error_to_string ( e ) ) ; return mp4box_cleanup ( 1 ) ; exit : mp4box_cleanup ( 0 ) ; # ifdef GPAC_MEMORY_TRACKING if ( mem_track && ( gf_memory_size ( ) || gf_file_handles_count ( ) ) ) { gf_log_set_tool_level ( GF_LOG_MEMORY , GF_LOG_INFO ) ; gf_memory_print ( ) ; return 2 ; } # endif return 0 ; }\n","target":"<S2SV_ModStart> ( stderr , \"File<S2SV_blank>%s<S2SV_blank>has<S2SV_blank>no<S2SV_blank>IOD\\\\n\" <S2SV_ModEnd> , inName )\n","project_and_commit_id":"gpac@gpac/9eeac00b38348c664dfeae2525bba0cf1bc32349","cve_id":"CVE-2020-23930","original_address":"https://github.com/gpac/gpac/commit/9eeac00b38348c664dfeae2525bba0cf1bc32349","time":"2021-04-21T18:15Z"},
	{"Unnamed: 0":3870,"cwe_id":"CWE-000","source":"CWE-000 static void hub_activate ( struct usb_hub * hub , enum hub_activation_type type ) { struct usb_device * hdev = hub -> hdev ; struct usb_hcd * hcd ; int ret ; int port1 ; int status ; bool need_debounce_delay = false ; unsigned delay ; <S2SV_StartBug> if ( type == HUB_INIT2 ) <S2SV_EndBug> goto init2 ; <S2SV_StartBug> if ( type == HUB_INIT3 ) <S2SV_EndBug> goto init3 ; if ( type != HUB_RESUME ) { if ( hdev -> parent && hub_is_superspeed ( hdev ) ) { ret = usb_control_msg ( hdev , usb_sndctrlpipe ( hdev , 0 ) , HUB_SET_DEPTH , USB_RT_HUB , hdev -> level - 1 , 0 , NULL , 0 , USB_CTRL_SET_TIMEOUT ) ; if ( ret < 0 ) dev_err ( hub -> intfdev , \"set<S2SV_blank>hub<S2SV_blank>depth<S2SV_blank>failed\\\\n\" ) ; } if ( type == HUB_INIT ) { delay = hub_power_on_good_delay ( hub ) ; hub_power_on ( hub , false ) ; INIT_DELAYED_WORK ( & hub -> init_work , hub_init_func2 ) ; queue_delayed_work ( system_power_efficient_wq , & hub -> init_work , msecs_to_jiffies ( delay ) ) ; usb_autopm_get_interface_no_resume ( to_usb_interface ( hub -> intfdev ) ) ; return ; } else if ( type == HUB_RESET_RESUME ) { hcd = bus_to_hcd ( hdev -> bus ) ; if ( hcd -> driver -> update_hub_device ) { ret = hcd -> driver -> update_hub_device ( hcd , hdev , & hub -> tt , GFP_NOIO ) ; if ( ret < 0 ) { dev_err ( hub -> intfdev , \"Host<S2SV_blank>not<S2SV_blank>\" \"accepting<S2SV_blank>hub<S2SV_blank>info<S2SV_blank>\" \"update.\\\\n\" ) ; dev_err ( hub -> intfdev , \"LS/FS<S2SV_blank>devices<S2SV_blank>\" \"and<S2SV_blank>hubs<S2SV_blank>may<S2SV_blank>not<S2SV_blank>work<S2SV_blank>\" \"under<S2SV_blank>this<S2SV_blank>hub\\\\n.\" ) ; } } hub_power_on ( hub , true ) ; } else { hub_power_on ( hub , true ) ; } } init2 : for ( port1 = 1 ; port1 <= hdev -> maxchild ; ++ port1 ) { struct usb_port * port_dev = hub -> ports [ port1 - 1 ] ; struct usb_device * udev = port_dev -> child ; u16 portstatus , portchange ; portstatus = portchange = 0 ; status = hub_port_status ( hub , port1 , & portstatus , & portchange ) ; if ( udev || ( portstatus & USB_PORT_STAT_CONNECTION ) ) dev_dbg ( & port_dev -> dev , \"status<S2SV_blank>%04x<S2SV_blank>change<S2SV_blank>%04x\\\\n\" , portstatus , portchange ) ; if ( ( portstatus & USB_PORT_STAT_ENABLE ) && ( type != HUB_RESUME || ! ( portstatus & USB_PORT_STAT_CONNECTION ) || ! udev || udev -> state == USB_STATE_NOTATTACHED ) ) { portstatus &= ~ USB_PORT_STAT_ENABLE ; if ( ! hub_is_superspeed ( hdev ) ) usb_clear_port_feature ( hdev , port1 , USB_PORT_FEAT_ENABLE ) ; } if ( portchange & USB_PORT_STAT_C_CONNECTION ) { need_debounce_delay = true ; usb_clear_port_feature ( hub -> hdev , port1 , USB_PORT_FEAT_C_CONNECTION ) ; } if ( portchange & USB_PORT_STAT_C_ENABLE ) { need_debounce_delay = true ; usb_clear_port_feature ( hub -> hdev , port1 , USB_PORT_FEAT_C_ENABLE ) ; } if ( portchange & USB_PORT_STAT_C_RESET ) { need_debounce_delay = true ; usb_clear_port_feature ( hub -> hdev , port1 , USB_PORT_FEAT_C_RESET ) ; } if ( ( portchange & USB_PORT_STAT_C_BH_RESET ) && hub_is_superspeed ( hub -> hdev ) ) { need_debounce_delay = true ; usb_clear_port_feature ( hub -> hdev , port1 , USB_PORT_FEAT_C_BH_PORT_RESET ) ; } if ( ! ( portstatus & USB_PORT_STAT_CONNECTION ) || ( portchange & USB_PORT_STAT_C_CONNECTION ) ) clear_bit ( port1 , hub -> removed_bits ) ; if ( ! udev || udev -> state == USB_STATE_NOTATTACHED ) { if ( udev || ( portstatus & USB_PORT_STAT_CONNECTION ) || ( portstatus & USB_PORT_STAT_OVERCURRENT ) ) set_bit ( port1 , hub -> change_bits ) ; } else if ( portstatus & USB_PORT_STAT_ENABLE ) { bool port_resumed = ( portstatus & USB_PORT_STAT_LINK_STATE ) == USB_SS_PORT_LS_U0 ; if ( portchange || ( hub_is_superspeed ( hub -> hdev ) && port_resumed ) ) set_bit ( port1 , hub -> change_bits ) ; } else if ( udev -> persist_enabled ) { # ifdef CONFIG_PM udev -> reset_resume = 1 ; # endif if ( test_bit ( port1 , hub -> power_bits ) ) set_bit ( port1 , hub -> change_bits ) ; } else { usb_set_device_state ( udev , USB_STATE_NOTATTACHED ) ; set_bit ( port1 , hub -> change_bits ) ; } } if ( need_debounce_delay ) { delay = HUB_DEBOUNCE_STABLE ; if ( type == HUB_INIT2 ) { INIT_DELAYED_WORK ( & hub -> init_work , hub_init_func3 ) ; queue_delayed_work ( system_power_efficient_wq , & hub -> init_work , msecs_to_jiffies ( delay ) ) ; <S2SV_StartBug> return ; <S2SV_EndBug> } else { msleep ( delay ) ; } } init3 : hub -> quiescing = 0 ; status = usb_submit_urb ( hub -> urb , GFP_NOIO ) ; if ( status < 0 ) dev_err ( hub -> intfdev , \"activate<S2SV_blank>--><S2SV_blank>%d\\\\n\" , status ) ; if ( hub -> has_indicators && blinkenlights ) queue_delayed_work ( system_power_efficient_wq , & hub -> leds , LED_CYCLE_PERIOD ) ; kick_hub_wq ( hub ) ; if ( type <= HUB_INIT3 ) usb_autopm_put_interface_async ( to_usb_interface ( hub -> intfdev ) ) ; <S2SV_StartBug> } <S2SV_EndBug>\n","target":"<S2SV_ModStart> type == HUB_INIT2 || type == HUB_INIT3 ) { device_lock ( hub -> intfdev ) ; if ( hub -> disconnected ) { device_unlock ( hub -> intfdev ) ; kref_put ( & hub -> kref , hub_release ) ; return ; } if ( type == HUB_INIT2 <S2SV_ModStart> goto init2 ; goto init3 ; } kref_get ( & hub -> kref ) <S2SV_ModEnd> ; if ( <S2SV_ModStart> ) ) ; device_unlock ( hub -> intfdev ) ; <S2SV_ModStart> ) ) ; if ( type == HUB_INIT2 || type == HUB_INIT3 ) device_unlock ( hub -> intfdev ) ; kref_put ( & hub -> kref , hub_release ) ;\n","project_and_commit_id":"torvalds@linux/e50293ef9775c5f1cf3fcc093037dd6a8c5684ea","cve_id":"CVE-2015-8816","original_address":"https://github.com/torvalds/linux/commit/e50293ef9775c5f1cf3fcc093037dd6a8c5684ea","time":"2016-04-27T17:59Z"},
	{"Unnamed: 0":428,"cwe_id":"CWE-000","source":"CWE-000 static void sas_resume_port ( struct asd_sas_phy * phy ) { struct domain_device * dev ; struct asd_sas_port * port = phy -> port ; struct sas_ha_struct * sas_ha = phy -> ha ; struct sas_internal * si = to_sas_internal ( sas_ha -> core . shost -> transportt ) ; if ( si -> dft -> lldd_port_formed ) si -> dft -> lldd_port_formed ( phy ) ; if ( port -> suspended ) port -> suspended = 0 ; else { return ; } list_for_each_entry ( dev , & port -> dev_list , dev_list_node ) { int i , rc ; rc = sas_notify_lldd_dev_found ( dev ) ; if ( rc ) { <S2SV_StartBug> sas_unregister_dev ( port , dev ) ; <S2SV_EndBug> continue ; } if ( dev -> dev_type == SAS_EDGE_EXPANDER_DEVICE || dev -> dev_type == SAS_FANOUT_EXPANDER_DEVICE ) { dev -> ex_dev . ex_change_count = - 1 ; for ( i = 0 ; i < dev -> ex_dev . num_phys ; i ++ ) { struct ex_phy * phy = & dev -> ex_dev . ex_phy [ i ] ; phy -> phy_change_count = - 1 ; } } } sas_discover_event ( port , DISCE_RESUME ) ; }\n","target":"<S2SV_ModStart> port , dev ) ; sas_destruct_devices ( port\n","project_and_commit_id":"torvalds@linux/0558f33c06bb910e2879e355192227a8e8f0219d","cve_id":"CVE-2017-18232","original_address":"https://github.com/torvalds/linux/commit/0558f33c06bb910e2879e355192227a8e8f0219d","time":"2018-03-15T04:29Z"},
	{"Unnamed: 0":2101,"cwe_id":"CWE-601","source":"CWE-601 static apr_byte_t oidc_validate_post_logout_url ( request_rec * r , const char * url , char * * err_str , char * * err_desc ) { apr_uri_t uri ; const char * c_host = NULL ; if ( apr_uri_parse ( r -> pool , url , & uri ) != APR_SUCCESS ) { * err_str = apr_pstrdup ( r -> pool , \"Malformed<S2SV_blank>URL\" ) ; * err_desc = apr_psprintf ( r -> pool , \"Logout<S2SV_blank>URL<S2SV_blank>malformed:<S2SV_blank>%s\" , url ) ; oidc_error ( r , \"%s:<S2SV_blank>%s\" , * err_str , * err_desc ) ; return FALSE ; } c_host = oidc_get_current_url_host ( r ) ; if ( ( uri . hostname != NULL ) && ( ( strstr ( c_host , uri . hostname ) == NULL ) || ( strstr ( uri . hostname , c_host ) == NULL ) ) ) { * err_str = apr_pstrdup ( r -> pool , \"Invalid<S2SV_blank>Request\" ) ; * err_desc = apr_psprintf ( r -> pool , \"logout<S2SV_blank>value<S2SV_blank>\\\\\"%s\\\\\"<S2SV_blank>does<S2SV_blank>not<S2SV_blank>match<S2SV_blank>the<S2SV_blank>hostname<S2SV_blank>of<S2SV_blank>the<S2SV_blank>current<S2SV_blank>request<S2SV_blank>\\\\\"%s\\\\\"\" , apr_uri_unparse ( r -> pool , & uri , 0 ) , c_host ) ; oidc_error ( r , \"%s:<S2SV_blank>%s\" , * err_str , * err_desc ) ; return FALSE ; <S2SV_StartBug> } else if ( strstr ( url , \"/\" ) != url ) { <S2SV_EndBug> * err_str = apr_pstrdup ( r -> pool , \"Malformed<S2SV_blank>URL\" ) ; * err_desc = apr_psprintf ( r -> pool , \"No<S2SV_blank>hostname<S2SV_blank>was<S2SV_blank>parsed<S2SV_blank>and<S2SV_blank>it<S2SV_blank>does<S2SV_blank>not<S2SV_blank>seem<S2SV_blank>to<S2SV_blank>be<S2SV_blank>relative,<S2SV_blank>i.e<S2SV_blank>starting<S2SV_blank>with<S2SV_blank>\\'/\\':<S2SV_blank>%s\" , url ) ; oidc_error ( r , \"%s:<S2SV_blank>%s\" , * err_str , * err_desc ) ; return FALSE ; } if ( ( ( strstr ( url , \"\\\\n\" ) != NULL ) || strstr ( url , \"\\\\r\" ) != NULL ) ) { * err_str = apr_pstrdup ( r -> pool , \"Invalid<S2SV_blank>Request\" ) ; * err_desc = apr_psprintf ( r -> pool , \"logout<S2SV_blank>value<S2SV_blank>\\\\\"%s\\\\\"<S2SV_blank>contains<S2SV_blank>illegal<S2SV_blank>\\\\\"\\\\n\\\\\"<S2SV_blank>or<S2SV_blank>\\\\\"\\\\r\\\\\"<S2SV_blank>character(s)\" , url ) ; oidc_error ( r , \"%s:<S2SV_blank>%s\" , * err_str , * err_desc ) ; return FALSE ; } return TRUE ; }\n","target":"<S2SV_ModStart> else if ( ( uri . hostname == NULL ) && ( <S2SV_ModStart> != url ) )\n","project_and_commit_id":"zmartzone@mod_auth_openidc/ce37080c6aea30aabae8b4a9b4eea7808445cc8e","cve_id":"CVE-2019-14857","original_address":"https://github.com/zmartzone/mod_auth_openidc/commit/ce37080c6aea30aabae8b4a9b4eea7808445cc8e","time":"2019-11-26T12:15Z"},
	{"Unnamed: 0":5314,"cwe_id":"CWE-772","source":"CWE-772 int sas_smp_get_phy_events ( struct sas_phy * phy ) { int res ; u8 * req ; u8 * resp ; struct sas_rphy * rphy = dev_to_rphy ( phy -> dev . parent ) ; struct domain_device * dev = sas_find_dev_by_rphy ( rphy ) ; req = alloc_smp_req ( RPEL_REQ_SIZE ) ; if ( ! req ) return - ENOMEM ; resp = alloc_smp_resp ( RPEL_RESP_SIZE ) ; if ( ! resp ) { kfree ( req ) ; return - ENOMEM ; } req [ 1 ] = SMP_REPORT_PHY_ERR_LOG ; req [ 9 ] = phy -> number ; res = smp_execute_task ( dev , req , RPEL_REQ_SIZE , resp , RPEL_RESP_SIZE ) ; if ( ! res ) goto out ; phy -> invalid_dword_count = scsi_to_u32 ( & resp [ 12 ] ) ; phy -> running_disparity_error_count = scsi_to_u32 ( & resp [ 16 ] ) ; phy -> loss_of_dword_sync_count = scsi_to_u32 ( & resp [ 20 ] ) ; phy -> phy_reset_problem_count = scsi_to_u32 ( & resp [ 24 ] ) ; out : <S2SV_StartBug> kfree ( resp ) ; <S2SV_EndBug> return res ; }\n","target":"<S2SV_ModStart> : kfree ( req ) ; kfree (\n","project_and_commit_id":"torvalds@linux/4a491b1ab11ca0556d2fda1ff1301e862a2d44c4","cve_id":"CVE-2018-7757","original_address":"https://github.com/torvalds/linux/commit/4a491b1ab11ca0556d2fda1ff1301e862a2d44c4","time":"2018-03-08T14:29Z"},
	{"Unnamed: 0":5852,"cwe_id":"CWE-284","source":"CWE-284 static MYSQL * db_connect ( char * host , char * database , char * user , char * passwd ) { MYSQL * mysql ; if ( verbose ) fprintf ( stdout , \"Connecting<S2SV_blank>to<S2SV_blank>%s\\\\n\" , host ? host : \"localhost\" ) ; if ( ! ( mysql = mysql_init ( NULL ) ) ) return 0 ; if ( opt_compress ) mysql_options ( mysql , MYSQL_OPT_COMPRESS , NullS ) ; if ( opt_local_file ) mysql_options ( mysql , MYSQL_OPT_LOCAL_INFILE , ( char * ) & opt_local_file ) ; <S2SV_StartBug> # ifdef HAVE_OPENSSL <S2SV_EndBug> if ( opt_use_ssl ) { mysql_ssl_set ( mysql , opt_ssl_key , opt_ssl_cert , opt_ssl_ca , opt_ssl_capath , opt_ssl_cipher ) ; mysql_options ( mysql , MYSQL_OPT_SSL_CRL , opt_ssl_crl ) ; mysql_options ( mysql , MYSQL_OPT_SSL_CRLPATH , opt_ssl_crlpath ) ; } mysql_options ( mysql , MYSQL_OPT_SSL_VERIFY_SERVER_CERT , ( char * ) & opt_ssl_verify_server_cert ) ; # endif if ( opt_protocol ) mysql_options ( mysql , MYSQL_OPT_PROTOCOL , ( char * ) & opt_protocol ) ; if ( opt_bind_addr ) mysql_options ( mysql , MYSQL_OPT_BIND , opt_bind_addr ) ; # if defined ( _WIN32 ) && ! defined ( EMBEDDED_LIBRARY ) if ( shared_memory_base_name ) mysql_options ( mysql , MYSQL_SHARED_MEMORY_BASE_NAME , shared_memory_base_name ) ; # endif if ( opt_plugin_dir && * opt_plugin_dir ) mysql_options ( mysql , MYSQL_PLUGIN_DIR , opt_plugin_dir ) ; if ( opt_default_auth && * opt_default_auth ) mysql_options ( mysql , MYSQL_DEFAULT_AUTH , opt_default_auth ) ; mysql_options ( mysql , MYSQL_SET_CHARSET_NAME , default_charset ) ; mysql_options ( mysql , MYSQL_OPT_CONNECT_ATTR_RESET , 0 ) ; mysql_options4 ( mysql , MYSQL_OPT_CONNECT_ATTR_ADD , \"program_name\" , \"mysqlimport\" ) ; if ( ! ( mysql_real_connect ( mysql , host , user , passwd , database , opt_mysql_port , opt_mysql_unix_port , 0 ) ) ) { ignore_errors = 0 ; db_error ( mysql ) ; } mysql -> reconnect = 0 ; if ( verbose ) fprintf ( stdout , \"Selecting<S2SV_blank>database<S2SV_blank>%s\\\\n\" , database ) ; if ( mysql_select_db ( mysql , database ) ) { ignore_errors = 0 ; db_error ( mysql ) ; } return mysql ; }\n","target":"<S2SV_ModStart> opt_local_file ) ; SSL_SET_OPTIONS ( mysql ) ; <S2SV_ModEnd> if ( opt_protocol\n","project_and_commit_id":"mysql@mysql-server/3bd5589e1a5a93f9c224badf983cd65c45215390","cve_id":"CVE-2015-3152","original_address":"https://github.com/mysql/mysql-server/commit/3bd5589e1a5a93f9c224badf983cd65c45215390","time":"2016-05-16T10:59Z"},
	{"Unnamed: 0":1940,"cwe_id":"CWE-552","source":"CWE-552 static ssize_t _consolefs_writev ( oe_fd_t * desc , const struct oe_iovec * iov , int iovcnt ) { ssize_t ret = - 1 ; file_t * file = _cast_file ( desc ) ; void * buf = NULL ; size_t buf_size = 0 ; <S2SV_StartBug> if ( ! file || ( ! iov && iovcnt ) || iovcnt < 0 || iovcnt > OE_IOV_MAX ) <S2SV_EndBug> OE_RAISE_ERRNO ( OE_EINVAL ) ; <S2SV_StartBug> if ( oe_iov_pack ( iov , iovcnt , & buf , & buf_size ) != 0 ) <S2SV_EndBug> <S2SV_StartBug> OE_RAISE_ERRNO ( OE_ENOMEM ) ; <S2SV_EndBug> if ( oe_syscall_writev_ocall ( & ret , file -> host_fd , buf , iovcnt , buf_size ) != OE_OK ) { OE_RAISE_ERRNO ( OE_EINVAL ) ; } <S2SV_StartBug> done : <S2SV_EndBug> if ( buf ) oe_free ( buf ) ; return ret ; }\n","target":"<S2SV_ModStart> = 0 ; size_t data_size = 0 ; <S2SV_ModStart> , & buf_size , & data_size <S2SV_ModStart> OE_RAISE_ERRNO ( OE_ENOMEM ) ; if ( data_size > OE_SSIZE_MAX ) OE_RAISE_ERRNO ( OE_EINVAL <S2SV_ModStart> ) ; } if ( ret > ( ssize_t ) data_size ) { ret = - 1 ; OE_RAISE_ERRNO ( OE_EINVAL ) ; }\n","project_and_commit_id":"openenclave@openenclave/bcac8e7acb514429fee9e0b5d0c7a0308fd4d76b","cve_id":"CVE-2020-15224","original_address":"https://github.com/openenclave/openenclave/commit/bcac8e7acb514429fee9e0b5d0c7a0308fd4d76b","time":"2020-10-14T19:15Z"},
	{"Unnamed: 0":6248,"cwe_id":"CWE-20","source":"CWE-20 static int hash_recvmsg ( struct kiocb * unused , struct socket * sock , struct msghdr * msg , size_t len , int flags ) { struct sock * sk = sock -> sk ; struct alg_sock * ask = alg_sk ( sk ) ; struct hash_ctx * ctx = ask -> private ; unsigned ds = crypto_ahash_digestsize ( crypto_ahash_reqtfm ( & ctx -> req ) ) ; int err ; if ( len > ds ) len = ds ; else if ( len < ds ) msg -> msg_flags |= MSG_TRUNC ; <S2SV_StartBug> msg -> msg_namelen = 0 ; <S2SV_EndBug> lock_sock ( sk ) ; if ( ctx -> more ) { ctx -> more = 0 ; ahash_request_set_crypt ( & ctx -> req , NULL , ctx -> result , 0 ) ; err = af_alg_wait_for_completion ( crypto_ahash_final ( & ctx -> req ) , & ctx -> completion ) ; if ( err ) goto unlock ; } err = memcpy_toiovec ( msg -> msg_iov , ctx -> result , len ) ; unlock : release_sock ( sk ) ; return err ? : len ; }\n","target":"<S2SV_ModStart> |= MSG_TRUNC ; <S2SV_ModEnd> lock_sock ( sk\n","project_and_commit_id":"torvalds@linux/f3d3342602f8bcbf37d7c46641cb9bca7618eb1c","cve_id":"CVE-2013-7271","original_address":"https://github.com/torvalds/linux/commit/f3d3342602f8bcbf37d7c46641cb9bca7618eb1c","time":"2014-01-06T16:55Z"},
	{"Unnamed: 0":1189,"cwe_id":"CWE-399","source":"CWE-399 static void xen_netbk_tx_submit ( struct xen_netbk * netbk ) { struct gnttab_copy * gop = netbk -> tx_copy_ops ; struct sk_buff * skb ; while ( ( skb = __skb_dequeue ( & netbk -> tx_queue ) ) != NULL ) { struct xen_netif_tx_request * txp ; struct xenvif * vif ; u16 pending_idx ; unsigned data_len ; pending_idx = * ( ( u16 * ) skb -> data ) ; vif = netbk -> pending_tx_info [ pending_idx ] . vif ; txp = & netbk -> pending_tx_info [ pending_idx ] . req ; if ( unlikely ( xen_netbk_tx_check_gop ( netbk , skb , & gop ) ) ) { netdev_dbg ( vif -> dev , \"netback<S2SV_blank>grant<S2SV_blank>failed.\\\\n\" ) ; skb_shinfo ( skb ) -> nr_frags = 0 ; kfree_skb ( skb ) ; continue ; } data_len = skb -> len ; memcpy ( skb -> data , ( void * ) ( idx_to_kaddr ( netbk , pending_idx ) | txp -> offset ) , data_len ) ; if ( data_len < txp -> size ) { txp -> offset += data_len ; txp -> size -= data_len ; } else { <S2SV_StartBug> xen_netbk_idx_release ( netbk , pending_idx ) ; <S2SV_EndBug> } if ( txp -> flags & XEN_NETTXF_csum_blank ) skb -> ip_summed = CHECKSUM_PARTIAL ; else if ( txp -> flags & XEN_NETTXF_data_validated ) skb -> ip_summed = CHECKSUM_UNNECESSARY ; xen_netbk_fill_frags ( netbk , skb ) ; if ( skb_headlen ( skb ) < PKT_PROT_LEN && skb_is_nonlinear ( skb ) ) { int target = min_t ( int , skb -> len , PKT_PROT_LEN ) ; __pskb_pull_tail ( skb , target - skb_headlen ( skb ) ) ; } skb -> dev = vif -> dev ; skb -> protocol = eth_type_trans ( skb , skb -> dev ) ; if ( checksum_setup ( vif , skb ) ) { netdev_dbg ( vif -> dev , \"Can\\'t<S2SV_blank>setup<S2SV_blank>checksum<S2SV_blank>in<S2SV_blank>net_tx_action\\\\n\" ) ; kfree_skb ( skb ) ; continue ; } vif -> dev -> stats . rx_bytes += skb -> len ; vif -> dev -> stats . rx_packets ++ ; xenvif_receive_skb ( vif , skb ) ; } }\n","target":"<S2SV_ModStart> netbk , pending_idx , XEN_NETIF_RSP_OKAY\n","project_and_commit_id":"torvalds@linux/7d5145d8eb2b9791533ffe4dc003b129b9696c48","cve_id":"CVE-2013-0217","original_address":"https://github.com/torvalds/linux/commit/7d5145d8eb2b9791533ffe4dc003b129b9696c48","time":"2013-02-18T04:41Z"},
	{"Unnamed: 0":6151,"cwe_id":"CWE-20","source":"CWE-20 void exit_io_context ( void ) { struct io_context * ioc ; task_lock ( current ) ; ioc = current -> io_context ; current -> io_context = NULL ; task_unlock ( current ) ; if ( atomic_dec_and_test ( & ioc -> nr_tasks ) ) { if ( ioc -> aic && ioc -> aic -> exit ) ioc -> aic -> exit ( ioc -> aic ) ; cfq_exit ( ioc ) ; <S2SV_StartBug> put_io_context ( ioc ) ; <S2SV_EndBug> } <S2SV_StartBug> } <S2SV_EndBug>\n","target":"<S2SV_ModStart> ioc ) ; } <S2SV_ModStart> ) ; } <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null>\n","project_and_commit_id":"torvalds@linux/61cc74fbb87af6aa551a06a370590c9bc07e29d9","cve_id":"CVE-2012-0879","original_address":"https://github.com/torvalds/linux/commit/61cc74fbb87af6aa551a06a370590c9bc07e29d9","time":"2012-05-17T11:00Z"},
	{"Unnamed: 0":3312,"cwe_id":"CWE-125","source":"CWE-125 void ripng_print ( netdissect_options * ndo , const u_char * dat , unsigned int length ) { register const struct rip6 * rp = ( const struct rip6 * ) dat ; register const struct netinfo6 * ni ; <S2SV_StartBug> register u_int amt ; <S2SV_EndBug> register u_int i ; int j ; int trunc ; if ( ndo -> ndo_snapend < dat ) return ; amt = ndo -> ndo_snapend - dat ; i = min ( length , amt ) ; if ( i < ( sizeof ( struct rip6 ) - sizeof ( struct netinfo6 ) ) ) return ; i -= ( sizeof ( struct rip6 ) - sizeof ( struct netinfo6 ) ) ; switch ( rp -> rip6_cmd ) { case RIP6_REQUEST : <S2SV_StartBug> j = length / sizeof ( * ni ) ; <S2SV_EndBug> if ( j == 1 <S2SV_StartBug> && rp -> rip6_nets -> rip6_metric == HOPCNT_INFINITY6 <S2SV_EndBug> && IN6_IS_ADDR_UNSPECIFIED ( & rp -> rip6_nets -> rip6_dest ) ) { ND_PRINT ( ( ndo , \"<S2SV_blank>ripng-req<S2SV_blank>dump\" ) ) ; break ; } <S2SV_StartBug> if ( j * sizeof ( * ni ) != length - 4 ) <S2SV_EndBug> ND_PRINT ( ( ndo , \"<S2SV_blank>ripng-req<S2SV_blank>%d[%u]:\" , j , length ) ) ; else <S2SV_StartBug> ND_PRINT ( ( ndo , \"<S2SV_blank>ripng-req<S2SV_blank>%d:\" , j ) ) ; <S2SV_EndBug> trunc = ( ( i / sizeof ( * ni ) ) * sizeof ( * ni ) != i ) ; <S2SV_StartBug> for ( ni = rp -> rip6_nets ; i >= sizeof ( * ni ) ; <S2SV_EndBug> <S2SV_StartBug> i -= sizeof ( * ni ) , ++ ni ) { <S2SV_EndBug> if ( ndo -> ndo_vflag > 1 ) ND_PRINT ( ( ndo , \"\\\\n\\\\t\" ) ) ; else ND_PRINT ( ( ndo , \"<S2SV_blank>\" ) ) ; rip6_entry_print ( ndo , ni , 0 ) ; } <S2SV_StartBug> break ; <S2SV_EndBug> case RIP6_RESPONSE : <S2SV_StartBug> j = length / sizeof ( * ni ) ; <S2SV_EndBug> <S2SV_StartBug> if ( j * sizeof ( * ni ) != length - 4 ) <S2SV_EndBug> ND_PRINT ( ( ndo , \"<S2SV_blank>ripng-resp<S2SV_blank>%d[%u]:\" , j , length ) ) ; else ND_PRINT ( ( ndo , \"<S2SV_blank>ripng-resp<S2SV_blank>%d:\" , j ) ) ; <S2SV_StartBug> trunc = ( ( i / sizeof ( * ni ) ) * sizeof ( * ni ) != i ) ; <S2SV_EndBug> <S2SV_StartBug> for ( ni = rp -> rip6_nets ; i >= sizeof ( * ni ) ; <S2SV_EndBug> <S2SV_StartBug> i -= sizeof ( * ni ) , ++ ni ) { <S2SV_EndBug> if ( ndo -> ndo_vflag > 1 ) ND_PRINT ( ( ndo , \"\\\\n\\\\t\" ) ) ; else ND_PRINT ( ( ndo , \"<S2SV_blank>\" ) ) ; rip6_entry_print ( ndo , ni , ni -> rip6_metric ) ; } <S2SV_StartBug> if ( trunc ) <S2SV_EndBug> ND_PRINT ( ( ndo , \"[|ripng]\" ) ) ; break ; default : ND_PRINT ( ( ndo , \"<S2SV_blank>ripng-%d<S2SV_blank>??<S2SV_blank>%u\" , rp -> rip6_cmd , length ) ) ; break ; <S2SV_StartBug> } <S2SV_EndBug> if ( rp -> rip6_vers != RIP6_VERSION ) ND_PRINT ( ( ndo , \"<S2SV_blank>[vers<S2SV_blank>%d]\" , rp -> rip6_vers ) ) ; <S2SV_StartBug> } <S2SV_EndBug>\n","target":"<S2SV_ModStart> * ni ; unsigned int length_left ; u_int j ; ND_TCHECK ( rp -> rip6_cmd <S2SV_ModEnd> ) ; switch <S2SV_ModStart> case RIP6_REQUEST : length_left = length ; if ( length_left < ( sizeof ( struct rip6 ) - sizeof ( struct netinfo6 ) ) ) goto trunc ; length_left -= ( sizeof ( struct rip6 ) - sizeof ( struct netinfo6 ) ) ; j = length_left <S2SV_ModEnd> / sizeof ( <S2SV_ModStart> j == 1 ) { ND_TCHECK ( rp -> rip6_nets ) ; if ( <S2SV_ModEnd> rp -> rip6_nets <S2SV_ModStart> break ; } } <S2SV_ModStart> ni ) != length_left ) ND_PRINT ( ( ndo , \"<S2SV_blank>ripng-req<S2SV_blank>%u[%u]:\" , j , length <S2SV_ModEnd> ) ) ; <S2SV_ModStart> ( ndo , \"<S2SV_blank>ripng-req<S2SV_blank>%u:\" , j ) <S2SV_ModEnd> ) ; for <S2SV_ModStart> -> rip6_nets ; length_left <S2SV_ModEnd> >= sizeof ( <S2SV_ModStart> ni ) ; length_left <S2SV_ModEnd> -= sizeof ( <S2SV_ModStart> ni ) { ND_TCHECK ( * ni ) ; <S2SV_ModStart> ) ; } if ( length_left != 0 ) goto trunc ; <S2SV_ModStart> case RIP6_RESPONSE : length_left = length ; if ( length_left < ( sizeof ( struct rip6 ) - sizeof ( struct netinfo6 ) ) ) goto trunc ; length_left -= ( sizeof ( struct rip6 ) - sizeof ( struct netinfo6 ) ) ; j = length_left <S2SV_ModEnd> / sizeof ( <S2SV_ModStart> ni ) != length_left ) ND_PRINT ( ( ndo , \"<S2SV_blank>ripng-resp<S2SV_blank>%d[%u]:\" , j , length <S2SV_ModEnd> ) ) ; <S2SV_ModStart> ) ) ; <S2SV_ModEnd> for ( ni <S2SV_ModStart> -> rip6_nets ; length_left <S2SV_ModEnd> >= sizeof ( <S2SV_ModStart> ni ) ; length_left <S2SV_ModEnd> -= sizeof ( <S2SV_ModStart> ni ) { ND_TCHECK ( * ni ) ; <S2SV_ModStart> } if ( length_left != 0 ) goto trunc <S2SV_ModEnd> ; break ; <S2SV_ModStart> break ; } ND_TCHECK ( rp -> rip6_vers ) ; <S2SV_ModStart> ) ) ; return ; trunc : ND_PRINT ( ( ndo , \"[|ripng]\" ) ) ; return ;\n","project_and_commit_id":"the-tcpdump-group@tcpdump/e942fb84fbe3a73a98a00d2a279425872b5fb9d2","cve_id":"CVE-2017-12992","original_address":"https://github.com/the-tcpdump-group/tcpdump/commit/e942fb84fbe3a73a98a00d2a279425872b5fb9d2","time":"2017-09-14T06:29Z"},
	{"Unnamed: 0":1494,"cwe_id":"CWE-119","source":"CWE-119 void WT_NoiseGenerator ( S_WT_VOICE * pWTVoice , S_WT_INT_FRAME * pWTIntFrame ) { EAS_PCM * pOutputBuffer ; EAS_I32 phaseInc ; EAS_I32 tmp0 ; EAS_I32 tmp1 ; EAS_I32 nInterpolatedSample ; EAS_I32 numSamples ; numSamples = pWTIntFrame -> numSamples ; if ( numSamples <= 0 ) { <S2SV_StartBug> ALOGE ( \"b/26366256\" ) ; <S2SV_EndBug> return ; } pOutputBuffer = pWTIntFrame -> pAudioBuffer ; phaseInc = pWTIntFrame -> frame . phaseIncrement ; tmp0 = ( EAS_I32 ) ( pWTVoice -> phaseAccum ) >> 18 ; tmp1 = ( EAS_I32 ) ( pWTVoice -> loopEnd ) >> 18 ; while ( numSamples -- ) { nInterpolatedSample = MULT_AUDIO_COEF ( tmp0 , ( PHASE_ONE - pWTVoice -> phaseFrac ) ) ; nInterpolatedSample += MULT_AUDIO_COEF ( tmp1 , pWTVoice -> phaseFrac ) ; * pOutputBuffer ++ = ( EAS_PCM ) nInterpolatedSample ; pWTVoice -> phaseFrac += ( EAS_U32 ) phaseInc ; if ( GET_PHASE_INT_PART ( pWTVoice -> phaseFrac ) ) { tmp0 = tmp1 ; pWTVoice -> phaseAccum = pWTVoice -> loopEnd ; pWTVoice -> loopEnd = ( 5 * pWTVoice -> loopEnd + 1 ) ; tmp1 = ( EAS_I32 ) ( pWTVoice -> loopEnd ) >> 18 ; pWTVoice -> phaseFrac = GET_PHASE_FRAC_PART ( pWTVoice -> phaseFrac ) ; } } }\n","target":"<S2SV_ModStart> ALOGE ( \"b/26366256\" ) ; android_errorWriteLog ( 0x534e4554 , \"26366256\"\n","project_and_commit_id":"external@sonivox/24d7c408c52143bce7b49de82f3913fd8d1219cf","cve_id":"CVE-2016-0838","original_address":"https://android.googlesource.com/platform/external/sonivox/+/24d7c408c52143bce7b49de82f3913fd8d1219cf","time":"2016-04-18T00:59Z"},
	{"Unnamed: 0":6340,"cwe_id":"CWE-189","source":"CWE-189 static EAS_RESULT Parse_wave ( SDLS_SYNTHESIZER_DATA * pDLSData , EAS_I32 pos , EAS_U16 waveIndex ) { EAS_RESULT result ; EAS_U32 temp ; EAS_I32 size ; EAS_I32 endChunk ; EAS_I32 chunkPos ; EAS_I32 wsmpPos = 0 ; EAS_I32 fmtPos = 0 ; EAS_I32 dataPos = 0 ; EAS_I32 dataSize = 0 ; S_WSMP_DATA * p ; void * pSample ; S_WSMP_DATA wsmp ; chunkPos = pos + 12 ; if ( ( result = EAS_HWFileSeek ( pDLSData -> hwInstData , pDLSData -> fileHandle , pos ) ) != EAS_SUCCESS ) return result ; if ( ( result = NextChunk ( pDLSData , & pos , & temp , & size ) ) != EAS_SUCCESS ) return result ; if ( temp != CHUNK_WAVE ) { { } return EAS_ERROR_FILE_FORMAT ; } pos = chunkPos ; endChunk = pos + size ; while ( pos < endChunk ) { chunkPos = pos ; if ( ( result = NextChunk ( pDLSData , & pos , & temp , & size ) ) != EAS_SUCCESS ) return result ; switch ( temp ) { case CHUNK_WSMP : wsmpPos = chunkPos + 8 ; break ; case CHUNK_FMT : fmtPos = chunkPos + 8 ; break ; case CHUNK_DATA : dataPos = chunkPos + 8 ; dataSize = size ; break ; default : break ; } } <S2SV_StartBug> if ( dataSize > MAX_DLS_WAVE_SIZE ) <S2SV_EndBug> { return EAS_ERROR_SOUND_LIBRARY ; } if ( pDLSData -> pDLS == NULL ) p = & wsmp ; else p = & pDLSData -> wsmpData [ waveIndex ] ; p -> fineTune = 0 ; p -> unityNote = 60 ; p -> gain = 0 ; p -> loopStart = 0 ; p -> loopLength = 0 ; if ( ! fmtPos ) { { } return EAS_ERROR_UNRECOGNIZED_FORMAT ; } if ( ! dataPos ) { { } return EAS_ERROR_UNRECOGNIZED_FORMAT ; } if ( wsmpPos ) { if ( ( result = Parse_wsmp ( pDLSData , wsmpPos , p ) ) != EAS_SUCCESS ) return result ; } if ( ( result = Parse_fmt ( pDLSData , fmtPos , p ) ) != EAS_SUCCESS ) return result ; if ( bitDepth == 8 ) { if ( p -> bitsPerSample == 8 ) size = dataSize ; else size = dataSize >> 1 ; if ( p -> loopLength ) size ++ ; } else { if ( p -> bitsPerSample == 16 ) size = dataSize ; else size = dataSize << 1 ; if ( p -> loopLength ) size += 2 ; } if ( pDLSData -> pDLS == NULL ) { pDLSData -> wavePoolSize += ( EAS_U32 ) size ; return EAS_SUCCESS ; } pSample = pDLSData -> pDLS -> pDLSSamples + pDLSData -> wavePoolOffset ; pDLSData -> pDLS -> pDLSSampleOffsets [ waveIndex ] = pDLSData -> wavePoolOffset ; pDLSData -> pDLS -> pDLSSampleLen [ waveIndex ] = ( EAS_U32 ) size ; pDLSData -> wavePoolOffset += ( EAS_U32 ) size ; if ( pDLSData -> wavePoolOffset > pDLSData -> wavePoolSize ) { { } return EAS_ERROR_SOUND_LIBRARY ; } if ( ( result = Parse_data ( pDLSData , dataPos , dataSize , p , pSample ) ) != EAS_SUCCESS ) return result ; return EAS_SUCCESS ; }\n","target":"<S2SV_ModStart> } if ( dataSize < 0 ||\n","project_and_commit_id":"external@sonivox/e999f077f6ef59d20282f1e04786816a31fb8be6","cve_id":"CVE-2015-3836","original_address":"https://android.googlesource.com/platform/external/sonivox/+/e999f077f6ef59d20282f1e04786816a31fb8be6","time":"2015-10-01T00:59Z"},
	{"Unnamed: 0":1419,"cwe_id":"CWE-362","source":"CWE-362 long do_shmat ( int shmid , char __user * shmaddr , int shmflg , ulong * raddr , unsigned long shmlba ) { struct shmid_kernel * shp ; unsigned long addr ; unsigned long size ; struct file * file ; int err ; unsigned long flags ; unsigned long prot ; int acc_mode ; struct ipc_namespace * ns ; struct shm_file_data * sfd ; struct path path ; fmode_t f_mode ; unsigned long populate = 0 ; err = - EINVAL ; if ( shmid < 0 ) goto out ; else if ( ( addr = ( ulong ) shmaddr ) ) { if ( addr & ( shmlba - 1 ) ) { if ( shmflg & SHM_RND ) addr &= ~ ( shmlba - 1 ) ; else # ifndef __ARCH_FORCE_SHMLBA if ( addr & ~ PAGE_MASK ) # endif goto out ; } flags = MAP_SHARED | MAP_FIXED ; } else { if ( ( shmflg & SHM_REMAP ) ) goto out ; flags = MAP_SHARED ; } if ( shmflg & SHM_RDONLY ) { prot = PROT_READ ; acc_mode = S_IRUGO ; f_mode = FMODE_READ ; } else { prot = PROT_READ | PROT_WRITE ; acc_mode = S_IRUGO | S_IWUGO ; f_mode = FMODE_READ | FMODE_WRITE ; } if ( shmflg & SHM_EXEC ) { prot |= PROT_EXEC ; acc_mode |= S_IXUGO ; } ns = current -> nsproxy -> ipc_ns ; rcu_read_lock ( ) ; shp = shm_obtain_object_check ( ns , shmid ) ; if ( IS_ERR ( shp ) ) { err = PTR_ERR ( shp ) ; goto out_unlock ; } err = - EACCES ; if ( ipcperms ( ns , & shp -> shm_perm , acc_mode ) ) goto out_unlock ; err = security_shm_shmat ( shp , shmaddr , shmflg ) ; if ( err ) goto out_unlock ; <S2SV_StartBug> ipc_lock_object ( & shp -> shm_perm ) ; <S2SV_EndBug> path = shp -> shm_file -> f_path ; path_get ( & path ) ; shp -> shm_nattch ++ ; size = i_size_read ( path . dentry -> d_inode ) ; ipc_unlock_object ( & shp -> shm_perm ) ; rcu_read_unlock ( ) ; err = - ENOMEM ; sfd = kzalloc ( sizeof ( * sfd ) , GFP_KERNEL ) ; if ( ! sfd ) { path_put ( & path ) ; goto out_nattch ; } file = alloc_file ( & path , f_mode , is_file_hugepages ( shp -> shm_file ) ? & shm_file_operations_huge : & shm_file_operations ) ; err = PTR_ERR ( file ) ; if ( IS_ERR ( file ) ) { kfree ( sfd ) ; path_put ( & path ) ; goto out_nattch ; } file -> private_data = sfd ; file -> f_mapping = shp -> shm_file -> f_mapping ; sfd -> id = shp -> shm_perm . id ; sfd -> ns = get_ipc_ns ( ns ) ; sfd -> file = shp -> shm_file ; sfd -> vm_ops = NULL ; err = security_mmap_file ( file , prot , flags ) ; if ( err ) goto out_fput ; down_write ( & current -> mm -> mmap_sem ) ; if ( addr && ! ( shmflg & SHM_REMAP ) ) { err = - EINVAL ; if ( find_vma_intersection ( current -> mm , addr , addr + size ) ) goto invalid ; if ( addr < current -> mm -> start_stack && addr > current -> mm -> start_stack - size - PAGE_SIZE * 5 ) goto invalid ; } addr = do_mmap_pgoff ( file , addr , size , prot , flags , 0 , & populate ) ; * raddr = addr ; err = 0 ; if ( IS_ERR_VALUE ( addr ) ) err = ( long ) addr ; invalid : up_write ( & current -> mm -> mmap_sem ) ; if ( populate ) mm_populate ( addr , populate ) ; out_fput : fput ( file ) ; out_nattch : down_write ( & shm_ids ( ns ) . rwsem ) ; shp = shm_lock ( ns , shmid ) ; BUG_ON ( IS_ERR ( shp ) ) ; shp -> shm_nattch -- ; if ( shm_may_destroy ( ns , shp ) ) shm_destroy ( ns , shp ) ; else shm_unlock ( shp ) ; up_write ( & shm_ids ( ns ) . rwsem ) ; return err ; out_unlock : rcu_read_unlock ( ) ; out : return err ; }\n","target":"<S2SV_ModStart> shm_perm ) ; if ( shp -> shm_file == NULL ) { ipc_unlock_object ( & shp -> shm_perm ) ; err = - EIDRM ; goto out_unlock ; }\n","project_and_commit_id":"torvalds@linux/a399b29dfbaaaf91162b2dc5a5875dd51bbfa2a1","cve_id":"CVE-2013-7026","original_address":"https://github.com/torvalds/linux/commit/a399b29dfbaaaf91162b2dc5a5875dd51bbfa2a1","time":"2013-12-09T18:55Z"},
	{"Unnamed: 0":5326,"cwe_id":"CWE-119","source":"CWE-119 <S2SV_StartBug> static void <S2SV_EndBug> horDiff8 ( TIFF * tif , uint8 * cp0 , tmsize_t cc ) { TIFFPredictorState * sp = PredictorState ( tif ) ; tmsize_t stride = sp -> stride ; unsigned char * cp = ( unsigned char * ) cp0 ; <S2SV_StartBug> assert ( ( cc % stride ) == 0 ) ; <S2SV_EndBug> if ( cc > stride ) { cc -= stride ; if ( stride == 3 ) { unsigned int r1 , g1 , b1 ; unsigned int r2 = cp [ 0 ] ; unsigned int g2 = cp [ 1 ] ; unsigned int b2 = cp [ 2 ] ; do { r1 = cp [ 3 ] ; cp [ 3 ] = ( unsigned char ) ( ( r1 - r2 ) & 0xff ) ; r2 = r1 ; g1 = cp [ 4 ] ; cp [ 4 ] = ( unsigned char ) ( ( g1 - g2 ) & 0xff ) ; g2 = g1 ; b1 = cp [ 5 ] ; cp [ 5 ] = ( unsigned char ) ( ( b1 - b2 ) & 0xff ) ; b2 = b1 ; cp += 3 ; } while ( ( cc -= 3 ) > 0 ) ; } else if ( stride == 4 ) { unsigned int r1 , g1 , b1 , a1 ; unsigned int r2 = cp [ 0 ] ; unsigned int g2 = cp [ 1 ] ; unsigned int b2 = cp [ 2 ] ; unsigned int a2 = cp [ 3 ] ; do { r1 = cp [ 4 ] ; cp [ 4 ] = ( unsigned char ) ( ( r1 - r2 ) & 0xff ) ; r2 = r1 ; g1 = cp [ 5 ] ; cp [ 5 ] = ( unsigned char ) ( ( g1 - g2 ) & 0xff ) ; g2 = g1 ; b1 = cp [ 6 ] ; cp [ 6 ] = ( unsigned char ) ( ( b1 - b2 ) & 0xff ) ; b2 = b1 ; a1 = cp [ 7 ] ; cp [ 7 ] = ( unsigned char ) ( ( a1 - a2 ) & 0xff ) ; a2 = a1 ; cp += 4 ; } while ( ( cc -= 4 ) > 0 ) ; } else { cp += cc - 1 ; do { REPEAT4 ( stride , cp [ stride ] = ( unsigned char ) ( ( cp [ stride ] - cp [ 0 ] ) & 0xff ) ; cp -- ) } while ( ( cc -= stride ) > 0 ) ; } } <S2SV_StartBug> } <S2SV_EndBug>\n","target":"<S2SV_ModStart> <S2SV_null> <S2SV_null> static int <S2SV_ModEnd> horDiff8 ( TIFF <S2SV_ModStart> ) cp0 ; if <S2SV_ModEnd> ( ( cc <S2SV_ModStart> % stride ) != 0 ) { TIFFErrorExt ( tif -> tif_clientdata , \"horDiff8\" , \"%s\" , \"(cc%stride)!=0\" ) ; return 0 ; } <S2SV_ModEnd> if ( cc <S2SV_ModStart> ; } } return 1 ;\n","project_and_commit_id":"vadz@libtiff/3ca657a8793dd011bf869695d72ad31c779c3cc1","cve_id":"CVE-2016-9535","original_address":"https://github.com/vadz/libtiff/commit/3ca657a8793dd011bf869695d72ad31c779c3cc1","time":"2016-11-22T19:59Z"},
	{"Unnamed: 0":4853,"cwe_id":"CWE-119","source":"CWE-119 static gboolean cosine_seek_read ( wtap * wth , gint64 seek_off , struct wtap_pkthdr * phdr , Buffer * buf , int * err , gchar * * err_info ) { <S2SV_StartBug> int pkt_len ; <S2SV_EndBug> char line [ COSINE_LINE_LENGTH ] ; if ( file_seek ( wth -> random_fh , seek_off , SEEK_SET , err ) == - 1 ) return FALSE ; if ( file_gets ( line , COSINE_LINE_LENGTH , wth -> random_fh ) == NULL ) { * err = file_error ( wth -> random_fh , err_info ) ; if ( * err == 0 ) { * err = WTAP_ERR_SHORT_READ ; } return FALSE ; } <S2SV_StartBug> pkt_len = parse_cosine_rec_hdr ( phdr , line , err , err_info ) ; <S2SV_EndBug> if ( pkt_len == - 1 ) return FALSE ; <S2SV_StartBug> return parse_cosine_hex_dump ( wth -> random_fh , phdr , pkt_len , buf , err , <S2SV_EndBug> err_info ) ; }\n","target":"<S2SV_ModStart> err_info ) { <S2SV_ModEnd> char line [ <S2SV_ModStart> FALSE ; } return parse_cosine_packet <S2SV_ModEnd> ( wth -> <S2SV_ModStart> , phdr , buf , line <S2SV_ModEnd> , err ,\n","project_and_commit_id":"wireshark@wireshark/f5ec0afb766f19519ea9623152cca3bbe2229500","cve_id":"CVE-2016-5356","original_address":"https://github.com/wireshark/wireshark/commit/f5ec0afb766f19519ea9623152cca3bbe2229500","time":"2016-08-07T16:59Z"},
	{"Unnamed: 0":2961,"cwe_id":"CWE-310","source":"CWE-310 int ASN1_item_verify ( const ASN1_ITEM * it , X509_ALGOR * a , ASN1_BIT_STRING * signature , void * asn , EVP_PKEY * pkey ) { EVP_MD_CTX ctx ; unsigned char * buf_in = NULL ; int ret = - 1 , inl ; int mdnid , pknid ; if ( ! pkey ) { ASN1err ( ASN1_F_ASN1_ITEM_VERIFY , ERR_R_PASSED_NULL_PARAMETER ) ; return - 1 ; } if ( signature -> type == V_ASN1_BIT_STRING && signature -> flags & 0x7 ) { <S2SV_StartBug> ASN1err ( ASN1_F_ASN1_VERIFY , ASN1_R_INVALID_BIT_STRING_BITS_LEFT ) ; <S2SV_EndBug> return - 1 ; } EVP_MD_CTX_init ( & ctx ) ; if ( ! OBJ_find_sigid_algs ( OBJ_obj2nid ( a -> algorithm ) , & mdnid , & pknid ) ) { ASN1err ( ASN1_F_ASN1_ITEM_VERIFY , ASN1_R_UNKNOWN_SIGNATURE_ALGORITHM ) ; goto err ; } if ( mdnid == NID_undef ) { if ( ! pkey -> ameth || ! pkey -> ameth -> item_verify ) { ASN1err ( ASN1_F_ASN1_ITEM_VERIFY , ASN1_R_UNKNOWN_SIGNATURE_ALGORITHM ) ; goto err ; } ret = pkey -> ameth -> item_verify ( & ctx , it , asn , a , signature , pkey ) ; if ( ret != 2 ) goto err ; ret = - 1 ; } else { const EVP_MD * type ; type = EVP_get_digestbynid ( mdnid ) ; if ( type == NULL ) { ASN1err ( ASN1_F_ASN1_ITEM_VERIFY , ASN1_R_UNKNOWN_MESSAGE_DIGEST_ALGORITHM ) ; goto err ; } if ( EVP_PKEY_type ( pknid ) != pkey -> ameth -> pkey_id ) { ASN1err ( ASN1_F_ASN1_ITEM_VERIFY , ASN1_R_WRONG_PUBLIC_KEY_TYPE ) ; goto err ; } if ( ! EVP_DigestVerifyInit ( & ctx , NULL , type , NULL , pkey ) ) { ASN1err ( ASN1_F_ASN1_ITEM_VERIFY , ERR_R_EVP_LIB ) ; ret = 0 ; goto err ; } } inl = ASN1_item_i2d ( asn , & buf_in , it ) ; if ( buf_in == NULL ) { ASN1err ( ASN1_F_ASN1_ITEM_VERIFY , ERR_R_MALLOC_FAILURE ) ; goto err ; } ret = EVP_DigestVerifyUpdate ( & ctx , buf_in , inl ) ; OPENSSL_cleanse ( buf_in , ( unsigned int ) inl ) ; OPENSSL_free ( buf_in ) ; if ( ! ret ) { ASN1err ( ASN1_F_ASN1_ITEM_VERIFY , ERR_R_EVP_LIB ) ; goto err ; } ret = - 1 ; if ( EVP_DigestVerifyFinal ( & ctx , signature -> data , ( size_t ) signature -> length ) <= 0 ) { ASN1err ( ASN1_F_ASN1_ITEM_VERIFY , ERR_R_EVP_LIB ) ; ret = 0 ; goto err ; } ret = 1 ; err : EVP_MD_CTX_cleanup ( & ctx ) ; return ( ret ) ; }\n","target":"<S2SV_ModStart> { ASN1err ( ASN1_F_ASN1_ITEM_VERIFY <S2SV_ModEnd> , ASN1_R_INVALID_BIT_STRING_BITS_LEFT )\n","project_and_commit_id":"openssl@openssl/cb62ab4b17818fe66d2fed0a7fe71969131c811b","cve_id":"CVE-2014-8275","original_address":"https://github.com/openssl/openssl/commit/cb62ab4b17818fe66d2fed0a7fe71969131c811b","time":"2015-01-09T02:59Z"},
	{"Unnamed: 0":1990,"cwe_id":"CWE-264","source":"CWE-264 static void veth_setup ( struct net_device * dev ) { <S2SV_StartBug> ether_setup ( dev ) ; <S2SV_EndBug> dev -> netdev_ops = & veth_netdev_ops ; dev -> ethtool_ops = & veth_ethtool_ops ; dev -> features |= NETIF_F_LLTX ; dev -> destructor = veth_dev_free ; dev -> hw_features = NETIF_F_NO_CSUM | NETIF_F_SG | NETIF_F_RXCSUM ; }\n","target":"<S2SV_ModStart> ( dev ) ; dev -> priv_flags &= ~ IFF_TX_SKB_SHARING\n","project_and_commit_id":"torvalds@linux/550fd08c2cebad61c548def135f67aba284c6162","cve_id":"CVE-2011-4112","original_address":"https://github.com/torvalds/linux/commit/550fd08c2cebad61c548def135f67aba284c6162","time":"2012-05-17T11:00Z"},
	{"Unnamed: 0":3024,"cwe_id":"CWE-200","source":"CWE-200 static int l2tp_ip_recvmsg ( struct kiocb * iocb , struct sock * sk , struct msghdr * msg , size_t len , int noblock , int flags , int * addr_len ) { struct inet_sock * inet = inet_sk ( sk ) ; size_t copied = 0 ; int err = - EOPNOTSUPP ; struct sockaddr_in * sin = ( struct sockaddr_in * ) msg -> msg_name ; struct sk_buff * skb ; if ( flags & MSG_OOB ) <S2SV_StartBug> goto out ; <S2SV_EndBug> if ( addr_len ) * addr_len = sizeof ( * sin ) ; skb = skb_recv_datagram ( sk , flags , noblock , & err ) ; if ( ! skb ) goto out ; copied = skb -> len ; if ( len < copied ) { msg -> msg_flags |= MSG_TRUNC ; copied = len ; } err = skb_copy_datagram_iovec ( skb , 0 , msg -> msg_iov , copied ) ; if ( err ) goto done ; sock_recv_timestamp ( msg , sk , skb ) ; if ( sin ) { sin -> sin_family = AF_INET ; sin -> sin_addr . s_addr = ip_hdr ( skb ) -> saddr ; sin -> sin_port = 0 ; memset ( & sin -> sin_zero , 0 , sizeof ( sin -> sin_zero ) ) ; <S2SV_StartBug> } <S2SV_EndBug> if ( inet -> cmsg_flags ) ip_cmsg_recv ( msg , skb ) ; if ( flags & MSG_TRUNC ) copied = skb -> len ; done : skb_free_datagram ( sk , skb ) ; out : return err ? err : copied ; }\n","target":"<S2SV_ModStart> ) goto out <S2SV_ModEnd> ; skb = <S2SV_ModStart> ) ) ; * addr_len = sizeof ( * sin ) ;\n","project_and_commit_id":"torvalds@linux/bceaa90240b6019ed73b49965eac7d167610be69","cve_id":"CVE-2013-7281","original_address":"https://github.com/torvalds/linux/commit/bceaa90240b6019ed73b49965eac7d167610be69","time":"2014-01-08T16:55Z"},
	{"Unnamed: 0":5777,"cwe_id":"CWE-125","source":"CWE-125 static const u_char * ikev2_auth_print ( netdissect_options * ndo , u_char tpay , const struct isakmp_gen * ext , u_int item_len _U_ , const u_char * ep , uint32_t phase _U_ , uint32_t doi _U_ , uint32_t proto _U_ , int depth _U_ ) { struct ikev2_auth a ; const char * v2_auth [ ] = { \"invalid\" , \"rsasig\" , \"shared-secret\" , \"dsssig\" } ; const u_char * authdata = ( const u_char * ) ext + sizeof ( a ) ; unsigned int len ; <S2SV_StartBug> ND_TCHECK ( * ext ) ; <S2SV_EndBug> UNALIGNED_MEMCPY ( & a , ext , sizeof ( a ) ) ; ikev2_pay_print ( ndo , NPSTR ( tpay ) , a . h . critical ) ; len = ntohs ( a . h . len ) ; ND_PRINT ( ( ndo , \"<S2SV_blank>len=%u<S2SV_blank>method=%s\" , len - 4 , STR_OR_ID ( a . auth_method , v2_auth ) ) ) ; if ( len > 4 ) { if ( ndo -> ndo_vflag > 1 ) { ND_PRINT ( ( ndo , \"<S2SV_blank>authdata=(\" ) ) ; if ( ! rawprint ( ndo , ( const uint8_t * ) authdata , len - sizeof ( a ) ) ) goto trunc ; ND_PRINT ( ( ndo , \")<S2SV_blank>\" ) ) ; } else if ( ndo -> ndo_vflag ) { if ( ! ike_show_somedata ( ndo , authdata , ep ) ) goto trunc ; } } return ( const u_char * ) ext + len ; trunc : ND_PRINT ( ( ndo , \"<S2SV_blank>[|%s]\" , NPSTR ( tpay ) ) ) ; return NULL ; }\n","target":"<S2SV_ModStart> int len ; ND_TCHECK2 ( * ext , sizeof ( a ) <S2SV_ModEnd> ) ; UNALIGNED_MEMCPY\n","project_and_commit_id":"the-tcpdump-group@tcpdump/8dca25d26c7ca2caf6138267f6f17111212c156e","cve_id":"CVE-2017-13690","original_address":"https://github.com/the-tcpdump-group/tcpdump/commit/8dca25d26c7ca2caf6138267f6f17111212c156e","time":"2017-09-14T06:29Z"},
	{"Unnamed: 0":4555,"cwe_id":"CWE-399","source":"CWE-399 static int xfrm6_tunnel_rcv ( struct sk_buff * skb ) { struct ipv6hdr * iph = ipv6_hdr ( skb ) ; __be32 spi ; spi = xfrm6_tunnel_spi_lookup ( ( xfrm_address_t * ) & iph -> saddr ) ; <S2SV_StartBug> return xfrm6_rcv_spi ( skb , spi ) ; <S2SV_EndBug> }\n","target":"<S2SV_ModStart> , spi ) > 0 ? : 0\n","project_and_commit_id":"torvalds@linux/d0772b70faaf8e9f2013b6c4273d94d5eac8047a","cve_id":"CVE-2012-1583","original_address":"https://github.com/torvalds/linux/commit/d0772b70faaf8e9f2013b6c4273d94d5eac8047a","time":"2012-06-16T21:55Z"},
	{"Unnamed: 0":4709,"cwe_id":"CWE-119","source":"CWE-119 void update_rate_histogram ( struct rate_hist * hist , const vpx_codec_enc_cfg_t * cfg , const vpx_codec_cx_pkt_t * pkt ) { int i ; int64_t then = 0 ; int64_t avg_bitrate = 0 ; int64_t sum_sz = 0 ; const int64_t now = pkt -> data . frame . pts * 1000 * ( uint64_t ) cfg -> g_timebase . num / ( uint64_t ) cfg -> g_timebase . den ; int idx = hist -> frames ++ % hist -> samples ; hist -> pts [ idx ] = now ; hist -> sz [ idx ] = ( int ) pkt -> data . frame . sz ; if ( now < cfg -> rc_buf_initial_sz ) return ; <S2SV_StartBug> then = now ; <S2SV_EndBug> for ( i = hist -> frames ; i > 0 && hist -> frames - i < hist -> samples ; i -- ) { const int i_idx = ( i - 1 ) % hist -> samples ; then = hist -> pts [ i_idx ] ; if ( now - then > cfg -> rc_buf_sz ) break ; sum_sz += hist -> sz [ i_idx ] ; } if ( now == then ) return ; avg_bitrate = sum_sz * 8 * 1000 / ( now - then ) ; idx = ( int ) ( avg_bitrate * ( RATE_BINS / 2 ) / ( cfg -> rc_target_bitrate * 1000 ) ) ; if ( idx < 0 ) idx = 0 ; if ( idx > RATE_BINS - 1 ) idx = RATE_BINS - 1 ; if ( hist -> bucket [ idx ] . low > avg_bitrate ) hist -> bucket [ idx ] . low = ( int ) avg_bitrate ; if ( hist -> bucket [ idx ] . high < avg_bitrate ) hist -> bucket [ idx ] . high = ( int ) avg_bitrate ; hist -> bucket [ idx ] . count ++ ; hist -> total ++ ; }\n","target":"<S2SV_ModStart> ) return ; if ( ! cfg -> rc_target_bitrate ) return ;\n","project_and_commit_id":"external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426","cve_id":"CVE-2016-1621","original_address":"https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426","time":"2016-03-12T21:59Z"},
	{"Unnamed: 0":3166,"cwe_id":"CWE-119","source":"CWE-119 static int decode_cblk ( Jpeg2000DecoderContext * s , Jpeg2000CodingStyle * codsty , Jpeg2000T1Context * t1 , Jpeg2000Cblk * cblk , int width , int height , int bandpos ) { int passno = cblk -> npasses , pass_t = 2 , bpno = cblk -> nonzerobits - 1 , y ; int clnpass_cnt = 0 ; int bpass_csty_symbol = codsty -> cblk_style & JPEG2000_CBLK_BYPASS ; <S2SV_StartBug> int vert_causal_ctx_csty_symbol = codsty -> cblk_style & JPEG2000_CBLK_VSC ; <S2SV_EndBug> for ( y = 0 ; y < height ; y ++ ) memset ( t1 -> data [ y ] , 0 , width * sizeof ( * * t1 -> data ) ) ; if ( ! cblk -> length ) return 0 ; for ( y = 0 ; y < height + 2 ; y ++ ) memset ( t1 -> flags [ y ] , 0 , ( width + 2 ) * sizeof ( * * t1 -> flags ) ) ; cblk -> data [ cblk -> length ] = 0xff ; cblk -> data [ cblk -> length + 1 ] = 0xff ; ff_mqc_initdec ( & t1 -> mqc , cblk -> data ) ; while ( passno -- ) { switch ( pass_t ) { case 0 : decode_sigpass ( t1 , width , height , bpno + 1 , bandpos , bpass_csty_symbol && ( clnpass_cnt >= 4 ) , vert_causal_ctx_csty_symbol ) ; break ; case 1 : decode_refpass ( t1 , width , height , bpno + 1 ) ; if ( bpass_csty_symbol && clnpass_cnt >= 4 ) ff_mqc_initdec ( & t1 -> mqc , cblk -> data ) ; break ; case 2 : decode_clnpass ( s , t1 , width , height , bpno + 1 , bandpos , codsty -> cblk_style & JPEG2000_CBLK_SEGSYM , vert_causal_ctx_csty_symbol ) ; clnpass_cnt = clnpass_cnt + 1 ; if ( bpass_csty_symbol && clnpass_cnt >= 4 ) ff_mqc_initdec ( & t1 -> mqc , cblk -> data ) ; break ; } pass_t ++ ; if ( pass_t == 3 ) { bpno -- ; pass_t = 0 ; } } return 0 ; }\n","target":"<S2SV_ModStart> cblk_style & JPEG2000_CBLK_VSC ; av_assert0 ( width <= JPEG2000_MAX_CBLKW ) ; av_assert0 ( height <= JPEG2000_MAX_CBLKH )\n","project_and_commit_id":"FFmpeg@FFmpeg/9a271a9368eaabf99e6c2046103acb33957e63b7","cve_id":"CVE-2013-7018","original_address":"https://github.com/FFmpeg/FFmpeg/commit/9a271a9368eaabf99e6c2046103acb33957e63b7","time":"2013-12-09T16:36Z"},
	{"Unnamed: 0":1945,"cwe_id":"CWE-119","source":"CWE-119 static int store_icy ( URLContext * h , int size ) { HTTPContext * s = h -> priv_data ; <S2SV_StartBug> int remaining = s -> icy_metaint - s -> icy_data_read ; <S2SV_EndBug> if ( remaining < 0 ) return AVERROR_INVALIDDATA ; if ( ! remaining ) { uint8_t ch ; int len = http_read_stream_all ( h , & ch , 1 ) ; if ( len < 0 ) return len ; if ( ch > 0 ) { char data [ 255 * 16 + 1 ] ; int ret ; len = ch * 16 ; ret = http_read_stream_all ( h , data , len ) ; if ( ret < 0 ) return ret ; data [ len + 1 ] = 0 ; if ( ( ret = av_opt_set ( s , \"icy_metadata_packet\" , data , 0 ) ) < 0 ) return ret ; update_metadata ( s , data ) ; } s -> icy_data_read = 0 ; remaining = s -> icy_metaint ; } return FFMIN ( size , remaining ) ; }\n","target":"<S2SV_ModStart> -> priv_data ; uint64_t remaining ; if ( s -> icy_metaint < s -> icy_data_read ) return AVERROR_INVALIDDATA ; <S2SV_ModEnd> remaining = s <S2SV_ModStart> s -> icy_data_read <S2SV_ModEnd> ; if (\n","project_and_commit_id":"FFmpeg@FFmpeg/2a05c8f813de6f2278827734bf8102291e7484aa","cve_id":"CVE-2016-10190","original_address":"https://github.com/FFmpeg/FFmpeg/commit/2a05c8f813de6f2278827734bf8102291e7484aa","time":"2017-02-09T15:59Z"},
	{"Unnamed: 0":5941,"cwe_id":"CWE-416","source":"CWE-416 static struct mm_struct * mm_init ( struct mm_struct * mm , struct task_struct * p , struct user_namespace * user_ns ) { mm -> mmap = NULL ; mm -> mm_rb = RB_ROOT ; mm -> vmacache_seqnum = 0 ; atomic_set ( & mm -> mm_users , 1 ) ; atomic_set ( & mm -> mm_count , 1 ) ; init_rwsem ( & mm -> mmap_sem ) ; INIT_LIST_HEAD ( & mm -> mmlist ) ; mm -> core_state = NULL ; atomic_long_set ( & mm -> nr_ptes , 0 ) ; mm_nr_pmds_init ( mm ) ; mm -> map_count = 0 ; mm -> locked_vm = 0 ; mm -> pinned_vm = 0 ; memset ( & mm -> rss_stat , 0 , sizeof ( mm -> rss_stat ) ) ; spin_lock_init ( & mm -> page_table_lock ) ; mm_init_cpumask ( mm ) ; mm_init_aio ( mm ) ; mm_init_owner ( mm , p ) ; <S2SV_StartBug> mmu_notifier_mm_init ( mm ) ; <S2SV_EndBug> init_tlb_flush_pending ( mm ) ; # if defined ( CONFIG_TRANSPARENT_HUGEPAGE ) && ! USE_SPLIT_PMD_PTLOCKS mm -> pmd_huge_pte = NULL ; # endif if ( current -> mm ) { mm -> flags = current -> mm -> flags & MMF_INIT_MASK ; mm -> def_flags = current -> mm -> def_flags & VM_INIT_DEF_MASK ; } else { mm -> flags = default_dump_filter ; mm -> def_flags = 0 ; } if ( mm_alloc_pgd ( mm ) ) goto fail_nopgd ; if ( init_new_context ( p , mm ) ) goto fail_nocontext ; mm -> user_ns = get_user_ns ( user_ns ) ; return mm ; fail_nocontext : mm_free_pgd ( mm ) ; fail_nopgd : free_mm ( mm ) ; return NULL ; }\n","target":"<S2SV_ModStart> p ) ; RCU_INIT_POINTER ( mm -> exe_file , NULL ) ;\n","project_and_commit_id":"torvalds@linux/2b7e8665b4ff51c034c55df3cff76518d1a9ee3a","cve_id":"CVE-2017-17052","original_address":"https://github.com/torvalds/linux/commit/2b7e8665b4ff51c034c55df3cff76518d1a9ee3a","time":"2017-11-29T03:29Z"},
	{"Unnamed: 0":55,"cwe_id":"CWE-119","source":"CWE-119 void vp8_create_common ( VP8_COMMON * oci ) { vp8_machine_specific_config ( oci ) ; vp8_init_mbmode_probs ( oci ) ; vp8_default_bmode_probs ( oci -> fc . bmode_prob ) ; oci -> mb_no_coeff_skip = 1 ; oci -> no_lpf = 0 ; oci -> filter_type = NORMAL_LOOPFILTER ; oci -> use_bilinear_mc_filter = 0 ; oci -> full_pixel = 0 ; oci -> multi_token_partition = ONE_PARTITION ; oci -> clamp_type = RECON_CLAMP_REQUIRED ; <S2SV_StartBug> vpx_memset ( oci -> ref_frame_sign_bias , 0 , sizeof ( oci -> ref_frame_sign_bias ) ) ; <S2SV_EndBug> oci -> copy_buffer_to_gf = 0 ; oci -> copy_buffer_to_arf = 0 ; }\n","target":"<S2SV_ModStart> = RECON_CLAMP_REQUIRED ; memset <S2SV_ModEnd> ( oci ->\n","project_and_commit_id":"external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426","cve_id":"CVE-2016-1621","original_address":"https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426","time":"2016-03-12T21:59Z"},
	{"Unnamed: 0":2119,"cwe_id":"CWE-200","source":"CWE-200 static int raw_recvmsg ( struct kiocb * iocb , struct sock * sk , struct msghdr * msg , size_t len , int noblock , int flags , int * addr_len ) { struct inet_sock * inet = inet_sk ( sk ) ; size_t copied = 0 ; int err = - EOPNOTSUPP ; struct sockaddr_in * sin = ( struct sockaddr_in * ) msg -> msg_name ; struct sk_buff * skb ; if ( flags & MSG_OOB ) <S2SV_StartBug> goto out ; <S2SV_EndBug> if ( addr_len ) * addr_len = sizeof ( * sin ) ; if ( flags & MSG_ERRQUEUE ) { err = ip_recv_error ( sk , msg , len ) ; goto out ; } skb = skb_recv_datagram ( sk , flags , noblock , & err ) ; if ( ! skb ) goto out ; copied = skb -> len ; if ( len < copied ) { msg -> msg_flags |= MSG_TRUNC ; copied = len ; } err = skb_copy_datagram_iovec ( skb , 0 , msg -> msg_iov , copied ) ; if ( err ) goto done ; sock_recv_ts_and_drops ( msg , sk , skb ) ; if ( sin ) { sin -> sin_family = AF_INET ; sin -> sin_addr . s_addr = ip_hdr ( skb ) -> saddr ; sin -> sin_port = 0 ; memset ( & sin -> sin_zero , 0 , sizeof ( sin -> sin_zero ) ) ; <S2SV_StartBug> } <S2SV_EndBug> if ( inet -> cmsg_flags ) ip_cmsg_recv ( msg , skb ) ; if ( flags & MSG_TRUNC ) copied = skb -> len ; done : skb_free_datagram ( sk , skb ) ; out : if ( err ) return err ; return copied ; }\n","target":"<S2SV_ModStart> ) goto out <S2SV_ModEnd> ; if ( <S2SV_ModStart> ) ) ; * addr_len = sizeof ( * sin ) ;\n","project_and_commit_id":"torvalds@linux/bceaa90240b6019ed73b49965eac7d167610be69","cve_id":"CVE-2013-7281","original_address":"https://github.com/torvalds/linux/commit/bceaa90240b6019ed73b49965eac7d167610be69","time":"2014-01-08T16:55Z"},
	{"Unnamed: 0":1303,"cwe_id":"CWE-20","source":"CWE-20 static ssize_t yurex_read ( struct file * file , char __user * buffer , size_t count , loff_t * ppos ) { struct usb_yurex * dev ; <S2SV_StartBug> int retval = 0 ; <S2SV_EndBug> int bytes_read = 0 ; char in_buffer [ 20 ] ; unsigned long flags ; dev = file -> private_data ; mutex_lock ( & dev -> io_mutex ) ; if ( ! dev -> interface ) { <S2SV_StartBug> retval = - ENODEV ; <S2SV_EndBug> goto exit ; } spin_lock_irqsave ( & dev -> lock , flags ) ; <S2SV_StartBug> bytes_read = snprintf ( in_buffer , 20 , \"%lld\\\\n\" , dev -> bbu ) ; <S2SV_EndBug> spin_unlock_irqrestore ( & dev -> lock , flags ) ; <S2SV_StartBug> if ( * ppos < bytes_read ) { <S2SV_EndBug> if ( copy_to_user ( buffer , in_buffer + * ppos , bytes_read - * ppos ) ) retval = - EFAULT ; else { retval = bytes_read - * ppos ; * ppos += bytes_read ; } } exit : mutex_unlock ( & dev -> io_mutex ) ; <S2SV_StartBug> return retval ; <S2SV_EndBug> }\n","target":"<S2SV_ModStart> dev ; int len <S2SV_ModEnd> = 0 ; <S2SV_ModStart> interface ) { mutex_unlock ( & dev -> io_mutex ) ; return - ENODEV <S2SV_ModEnd> ; } spin_lock_irqsave <S2SV_ModStart> flags ) ; len <S2SV_ModEnd> = snprintf ( <S2SV_ModStart> flags ) ; <S2SV_ModEnd> mutex_unlock ( & <S2SV_ModStart> ) ; return simple_read_from_buffer ( buffer , count , ppos , in_buffer , len ) <S2SV_ModEnd> ; } <S2SV_null>\n","project_and_commit_id":"torvalds@linux/f1e255d60ae66a9f672ff9a207ee6cd8e33d2679","cve_id":"CVE-2018-16276","original_address":"https://github.com/torvalds/linux/commit/f1e255d60ae66a9f672ff9a207ee6cd8e33d2679","time":"2018-08-31T16:29Z"},
	{"Unnamed: 0":5779,"cwe_id":"CWE-399","source":"CWE-399 static int dcbnl_getperm_hwaddr ( struct net_device * netdev , struct nlmsghdr * nlh , u32 seq , struct nlattr * * tb , struct sk_buff * skb ) { u8 perm_addr [ MAX_ADDR_LEN ] ; if ( ! netdev -> dcbnl_ops -> getpermhwaddr ) return - EOPNOTSUPP ; <S2SV_StartBug> netdev -> dcbnl_ops -> getpermhwaddr ( netdev , perm_addr ) ; <S2SV_EndBug> return nla_put ( skb , DCB_ATTR_PERM_HWADDR , sizeof ( perm_addr ) , perm_addr ) ; }\n","target":"<S2SV_ModStart> - EOPNOTSUPP ; memset ( perm_addr , 0 , sizeof ( perm_addr ) ) ;\n","project_and_commit_id":"torvalds@linux/29cd8ae0e1a39e239a3a7b67da1986add1199fc0","cve_id":"CVE-2013-2634","original_address":"https://github.com/torvalds/linux/commit/29cd8ae0e1a39e239a3a7b67da1986add1199fc0","time":"2013-03-22T11:59Z"},
	{"Unnamed: 0":3273,"cwe_id":"CWE-000","source":"CWE-000 static int aiptek_probe ( struct usb_interface * intf , const struct usb_device_id * id ) { struct usb_device * usbdev = interface_to_usbdev ( intf ) ; struct usb_endpoint_descriptor * endpoint ; struct aiptek * aiptek ; struct input_dev * inputdev ; int i ; int speeds [ ] = { 0 , AIPTEK_PROGRAMMABLE_DELAY_50 , AIPTEK_PROGRAMMABLE_DELAY_400 , AIPTEK_PROGRAMMABLE_DELAY_25 , AIPTEK_PROGRAMMABLE_DELAY_100 , AIPTEK_PROGRAMMABLE_DELAY_200 , AIPTEK_PROGRAMMABLE_DELAY_300 } ; int err = - ENOMEM ; speeds [ 0 ] = programmableDelay ; aiptek = kzalloc ( sizeof ( struct aiptek ) , GFP_KERNEL ) ; inputdev = input_allocate_device ( ) ; if ( ! aiptek || ! inputdev ) { dev_warn ( & intf -> dev , \"cannot<S2SV_blank>allocate<S2SV_blank>memory<S2SV_blank>or<S2SV_blank>input<S2SV_blank>device\\\\n\" ) ; goto fail1 ; } aiptek -> data = usb_alloc_coherent ( usbdev , AIPTEK_PACKET_LENGTH , GFP_ATOMIC , & aiptek -> data_dma ) ; if ( ! aiptek -> data ) { dev_warn ( & intf -> dev , \"cannot<S2SV_blank>allocate<S2SV_blank>usb<S2SV_blank>buffer\\\\n\" ) ; goto fail1 ; } aiptek -> urb = usb_alloc_urb ( 0 , GFP_KERNEL ) ; if ( ! aiptek -> urb ) { dev_warn ( & intf -> dev , \"cannot<S2SV_blank>allocate<S2SV_blank>urb\\\\n\" ) ; goto fail2 ; } aiptek -> inputdev = inputdev ; aiptek -> usbdev = usbdev ; aiptek -> intf = intf ; aiptek -> ifnum = intf -> altsetting [ 0 ] . desc . bInterfaceNumber ; aiptek -> inDelay = 0 ; aiptek -> endDelay = 0 ; aiptek -> previousJitterable = 0 ; aiptek -> lastMacro = - 1 ; aiptek -> curSetting . pointerMode = AIPTEK_POINTER_EITHER_MODE ; aiptek -> curSetting . coordinateMode = AIPTEK_COORDINATE_ABSOLUTE_MODE ; aiptek -> curSetting . toolMode = AIPTEK_TOOL_BUTTON_PEN_MODE ; aiptek -> curSetting . xTilt = AIPTEK_TILT_DISABLE ; aiptek -> curSetting . yTilt = AIPTEK_TILT_DISABLE ; aiptek -> curSetting . mouseButtonLeft = AIPTEK_MOUSE_LEFT_BUTTON ; aiptek -> curSetting . mouseButtonMiddle = AIPTEK_MOUSE_MIDDLE_BUTTON ; aiptek -> curSetting . mouseButtonRight = AIPTEK_MOUSE_RIGHT_BUTTON ; aiptek -> curSetting . stylusButtonUpper = AIPTEK_STYLUS_UPPER_BUTTON ; aiptek -> curSetting . stylusButtonLower = AIPTEK_STYLUS_LOWER_BUTTON ; aiptek -> curSetting . jitterDelay = jitterDelay ; aiptek -> curSetting . programmableDelay = programmableDelay ; aiptek -> newSetting = aiptek -> curSetting ; usb_make_path ( usbdev , aiptek -> features . usbPath , sizeof ( aiptek -> features . usbPath ) ) ; strlcat ( aiptek -> features . usbPath , \"/input0\" , sizeof ( aiptek -> features . usbPath ) ) ; inputdev -> name = \"Aiptek\" ; inputdev -> phys = aiptek -> features . usbPath ; usb_to_input_id ( usbdev , & inputdev -> id ) ; inputdev -> dev . parent = & intf -> dev ; input_set_drvdata ( inputdev , aiptek ) ; inputdev -> open = aiptek_open ; inputdev -> close = aiptek_close ; for ( i = 0 ; i < ARRAY_SIZE ( eventTypes ) ; ++ i ) __set_bit ( eventTypes [ i ] , inputdev -> evbit ) ; for ( i = 0 ; i < ARRAY_SIZE ( absEvents ) ; ++ i ) __set_bit ( absEvents [ i ] , inputdev -> absbit ) ; for ( i = 0 ; i < ARRAY_SIZE ( relEvents ) ; ++ i ) __set_bit ( relEvents [ i ] , inputdev -> relbit ) ; __set_bit ( MSC_SERIAL , inputdev -> mscbit ) ; for ( i = 0 ; i < ARRAY_SIZE ( buttonEvents ) ; ++ i ) __set_bit ( buttonEvents [ i ] , inputdev -> keybit ) ; for ( i = 0 ; i < ARRAY_SIZE ( macroKeyEvents ) ; ++ i ) __set_bit ( macroKeyEvents [ i ] , inputdev -> keybit ) ; input_set_abs_params ( inputdev , ABS_X , 0 , 2999 , 0 , 0 ) ; input_set_abs_params ( inputdev , ABS_Y , 0 , 2249 , 0 , 0 ) ; input_set_abs_params ( inputdev , ABS_PRESSURE , 0 , 511 , 0 , 0 ) ; input_set_abs_params ( inputdev , ABS_TILT_X , AIPTEK_TILT_MIN , AIPTEK_TILT_MAX , 0 , 0 ) ; input_set_abs_params ( inputdev , ABS_TILT_Y , AIPTEK_TILT_MIN , AIPTEK_TILT_MAX , 0 , 0 ) ; input_set_abs_params ( inputdev , ABS_WHEEL , AIPTEK_WHEEL_MIN , AIPTEK_WHEEL_MAX - 1 , 0 , 0 ) ; <S2SV_StartBug> endpoint = & intf -> altsetting [ 0 ] . endpoint [ 0 ] . desc ; <S2SV_EndBug> usb_fill_int_urb ( aiptek -> urb , aiptek -> usbdev , usb_rcvintpipe ( aiptek -> usbdev , endpoint -> bEndpointAddress ) , aiptek -> data , 8 , aiptek_irq , aiptek , endpoint -> bInterval ) ; aiptek -> urb -> transfer_dma = aiptek -> data_dma ; aiptek -> urb -> transfer_flags |= URB_NO_TRANSFER_DMA_MAP ; for ( i = 0 ; i < ARRAY_SIZE ( speeds ) ; ++ i ) { aiptek -> curSetting . programmableDelay = speeds [ i ] ; ( void ) aiptek_program_tablet ( aiptek ) ; if ( input_abs_get_max ( aiptek -> inputdev , ABS_X ) > 0 ) { dev_info ( & intf -> dev , \"Aiptek<S2SV_blank>using<S2SV_blank>%d<S2SV_blank>ms<S2SV_blank>programming<S2SV_blank>speed\\\\n\" , aiptek -> curSetting . programmableDelay ) ; break ; } } if ( i == ARRAY_SIZE ( speeds ) ) { dev_info ( & intf -> dev , \"Aiptek<S2SV_blank>tried<S2SV_blank>all<S2SV_blank>speeds,<S2SV_blank>no<S2SV_blank>sane<S2SV_blank>response\\\\n\" ) ; <S2SV_StartBug> goto fail3 ; <S2SV_EndBug> } usb_set_intfdata ( intf , aiptek ) ; err = sysfs_create_group ( & intf -> dev . kobj , & aiptek_attribute_group ) ; if ( err ) { dev_warn ( & intf -> dev , \"cannot<S2SV_blank>create<S2SV_blank>sysfs<S2SV_blank>group<S2SV_blank>err:<S2SV_blank>%d\\\\n\" , err ) ; goto fail3 ; } err = input_register_device ( aiptek -> inputdev ) ; if ( err ) { dev_warn ( & intf -> dev , \"input_register_device<S2SV_blank>returned<S2SV_blank>err:<S2SV_blank>%d\\\\n\" , err ) ; goto fail4 ; } return 0 ; fail4 : sysfs_remove_group ( & intf -> dev . kobj , & aiptek_attribute_group ) ; fail3 : usb_free_urb ( aiptek -> urb ) ; fail2 : usb_free_coherent ( usbdev , AIPTEK_PACKET_LENGTH , aiptek -> data , aiptek -> data_dma ) ; fail1 : usb_set_intfdata ( intf , NULL ) ; input_free_device ( inputdev ) ; kfree ( aiptek ) ; return err ; }\n","target":"<S2SV_ModStart> 0 ) ; if ( intf -> altsetting [ 0 ] . desc . bNumEndpoints < 1 ) { dev_err ( & intf -> dev , \"interface<S2SV_blank>has<S2SV_blank>%d<S2SV_blank>endpoints,<S2SV_blank>but<S2SV_blank>must<S2SV_blank>have<S2SV_blank>minimum<S2SV_blank>1\\\\n\" , intf -> altsetting [ 0 ] . desc . bNumEndpoints ) ; err = - EINVAL ; goto fail3 ; } <S2SV_ModStart> \"Aiptek<S2SV_blank>tried<S2SV_blank>all<S2SV_blank>speeds,<S2SV_blank>no<S2SV_blank>sane<S2SV_blank>response\\\\n\" ) ; err = - EINVAL ;\n","project_and_commit_id":"torvalds@linux/8e20cf2bce122ce9262d6034ee5d5b76fbb92f96","cve_id":"CVE-2015-7515","original_address":"https://github.com/torvalds/linux/commit/8e20cf2bce122ce9262d6034ee5d5b76fbb92f96","time":"2016-04-27T17:59Z"},
	{"Unnamed: 0":985,"cwe_id":"CWE-362","source":"CWE-362 static int newque ( struct ipc_namespace * ns , struct ipc_params * params ) { struct msg_queue * msq ; int id , retval ; key_t key = params -> key ; int msgflg = params -> flg ; msq = ipc_rcu_alloc ( sizeof ( * msq ) ) ; if ( ! msq ) return - ENOMEM ; msq -> q_perm . mode = msgflg & S_IRWXUGO ; msq -> q_perm . key = key ; msq -> q_perm . security = NULL ; retval = security_msg_queue_alloc ( msq ) ; if ( retval ) { ipc_rcu_putref ( msq , ipc_rcu_free ) ; return retval ; } <S2SV_StartBug> id = ipc_addid ( & msg_ids ( ns ) , & msq -> q_perm , ns -> msg_ctlmni ) ; <S2SV_EndBug> if ( id < 0 ) { ipc_rcu_putref ( msq , msg_rcu_free ) ; return id ; } <S2SV_StartBug> msq -> q_stime = msq -> q_rtime = 0 ; <S2SV_EndBug> msq -> q_ctime = get_seconds ( ) ; msq -> q_cbytes = msq -> q_qnum = 0 ; msq -> q_qbytes = ns -> msg_ctlmnb ; msq -> q_lspid = msq -> q_lrpid = 0 ; INIT_LIST_HEAD ( & msq -> q_messages ) ; INIT_LIST_HEAD ( & msq -> q_receivers ) ; INIT_LIST_HEAD ( & msq -> q_senders ) ; ipc_unlock_object ( & msq -> q_perm ) ; rcu_read_unlock ( ) ; return msq -> q_perm . id ; }\n","target":"<S2SV_ModStart> retval ; } msq -> q_stime = msq -> q_rtime = 0 ; msq -> q_ctime = get_seconds ( ) ; msq -> q_cbytes = msq -> q_qnum = 0 ; msq -> q_qbytes = ns -> msg_ctlmnb ; msq -> q_lspid = msq -> q_lrpid = 0 ; INIT_LIST_HEAD ( & msq -> q_messages ) ; INIT_LIST_HEAD ( & msq -> q_receivers ) ; INIT_LIST_HEAD ( & msq -> q_senders ) ; <S2SV_ModStart> id ; } <S2SV_ModEnd> ipc_unlock_object ( &\n","project_and_commit_id":"torvalds@linux/b9a532277938798b53178d5a66af6e2915cb27cf","cve_id":"CVE-2015-7613","original_address":"https://github.com/torvalds/linux/commit/b9a532277938798b53178d5a66af6e2915cb27cf","time":"2015-10-19T10:59Z"},
	{"Unnamed: 0":919,"cwe_id":"CWE-190","source":"CWE-190 SPL_METHOD ( SplFileObject , fread ) { spl_filesystem_object * intern = ( spl_filesystem_object * ) zend_object_store_get_object ( getThis ( ) TSRMLS_CC ) ; long length = 0 ; if ( zend_parse_parameters ( ZEND_NUM_ARGS ( ) TSRMLS_CC , \"l\" , & length ) == FAILURE ) { return ; } if ( length <= 0 ) { php_error_docref ( NULL TSRMLS_CC , E_WARNING , \"Length<S2SV_blank>parameter<S2SV_blank>must<S2SV_blank>be<S2SV_blank>greater<S2SV_blank>than<S2SV_blank>0\" ) ; RETURN_FALSE ; } <S2SV_StartBug> Z_STRVAL_P ( return_value ) = emalloc ( length + 1 ) ; <S2SV_EndBug> Z_STRLEN_P ( return_value ) = php_stream_read ( intern -> u . file . stream , Z_STRVAL_P ( return_value ) , length ) ; Z_STRVAL_P ( return_value ) [ Z_STRLEN_P ( return_value ) ] = 0 ; Z_TYPE_P ( return_value ) = IS_STRING ; }\n","target":"<S2SV_ModStart> RETURN_FALSE ; } if ( length > INT_MAX ) { php_error_docref ( NULL TSRMLS_CC , E_WARNING , \"Length<S2SV_blank>parameter<S2SV_blank>must<S2SV_blank>be<S2SV_blank>no<S2SV_blank>more<S2SV_blank>than<S2SV_blank>%d\" , INT_MAX ) ; RETURN_FALSE ; }\n","project_and_commit_id":"php@php-src/7245bff300d3fa8bacbef7897ff080a6f1c23eba","cve_id":"CVE-2016-5770","original_address":"https://github.com/php/php-src/commit/7245bff300d3fa8bacbef7897ff080a6f1c23eba?w=1","time":"2016-08-07T10:59Z"},
	{"Unnamed: 0":4136,"cwe_id":"CWE-78","source":"CWE-78 static void <S2SV_StartBug> build_config ( char * prefix , struct server * server ) <S2SV_EndBug> { char * path = NULL ; int path_size = strlen ( prefix ) + strlen ( server -> port ) + 20 ; path = ss_malloc ( path_size ) ; snprintf ( path , path_size , \"%s/.shadowsocks_%s.conf\" , prefix , server -> port ) ; FILE * f = fopen ( path , \"w+\" ) ; if ( f == NULL ) { if ( verbose ) { LOGE ( \"unable<S2SV_blank>to<S2SV_blank>open<S2SV_blank>config<S2SV_blank>file\" ) ; } ss_free ( path ) ; return ; } fprintf ( f , \"{\\\\n\" ) ; fprintf ( f , \"\\\\\"server_port\\\\\":%d,\\\\n\" , atoi ( server -> port ) ) ; <S2SV_StartBug> fprintf ( f , \"\\\\\"password\\\\\":\\\\\"%s\\\\\"\" , server -> password ) ; <S2SV_EndBug> if ( server -> fast_open [ 0 ] ) fprintf ( f , \",\\\\n\\\\\"fast_open\\\\\":<S2SV_blank>%s\" , server -> fast_open ) ; if ( server -> mode ) fprintf ( f , \",\\\\n\\\\\"mode\\\\\":\\\\\"%s\\\\\"\" , server -> mode ) ; <S2SV_StartBug> if ( server -> method ) fprintf ( f , \",\\\\n\\\\\"method\\\\\":\\\\\"%s\\\\\"\" , server -> method ) ; <S2SV_EndBug> if ( server -> plugin ) fprintf ( f , \",\\\\n\\\\\"plugin\\\\\":\\\\\"%s\\\\\"\" , server -> plugin ) ; if ( server -> plugin_opts ) fprintf ( f , \",\\\\n\\\\\"plugin_opts\\\\\":\\\\\"%s\\\\\"\" , server -> plugin_opts ) ; fprintf ( f , \"\\\\n}\\\\n\" ) ; fclose ( f ) ; ss_free ( path ) ; }\n","target":"<S2SV_ModStart> prefix , struct manager_ctx * manager , struct <S2SV_ModStart> server -> password ) ; if ( server -> method ) fprintf ( f , \",\\\\n\\\\\"method\\\\\":\\\\\"%s\\\\\"\" , server -> method ) ; else if ( manager -> method ) fprintf ( f , \",\\\\n\\\\\"method\\\\\":\\\\\"%s\\\\\"\" , manager -> method <S2SV_ModStart> ( server -> <S2SV_ModEnd> plugin ) fprintf\n","project_and_commit_id":"shadowsocks@shadowsocks-libev/c67d275803dc6ea22c558d06b1f7ba9f94cd8de3","cve_id":"CVE-2017-15924","original_address":"https://github.com/shadowsocks/shadowsocks-libev/commit/c67d275803dc6ea22c558d06b1f7ba9f94cd8de3","time":"2017-10-27T16:29Z"},
	{"Unnamed: 0":6675,"cwe_id":"CWE-200","source":"CWE-200 static void sg_fill_request_table ( Sg_fd * sfp , sg_req_info_t * rinfo ) { Sg_request * srp ; int val ; unsigned int ms ; val = 0 ; list_for_each_entry ( srp , & sfp -> rq_list , entry ) { if ( val > SG_MAX_QUEUE ) break ; <S2SV_StartBug> memset ( & rinfo [ val ] , 0 , SZ_SG_REQ_INFO ) ; <S2SV_EndBug> rinfo [ val ] . req_state = srp -> done + 1 ; rinfo [ val ] . problem = srp -> header . masked_status & srp -> header . host_status & srp -> header . driver_status ; if ( srp -> done ) rinfo [ val ] . duration = srp -> header . duration ; else { ms = jiffies_to_msecs ( jiffies ) ; rinfo [ val ] . duration = ( ms > srp -> header . duration ) ? ( ms - srp -> header . duration ) : 0 ; } rinfo [ val ] . orphan = srp -> orphan ; rinfo [ val ] . sg_io_owned = srp -> sg_io_owned ; rinfo [ val ] . pack_id = srp -> header . pack_id ; rinfo [ val ] . usr_ptr = srp -> header . usr_ptr ; val ++ ; } }\n","target":"<S2SV_ModStart> ) break ; <S2SV_ModEnd> rinfo [ val\n","project_and_commit_id":"torvalds@linux/3e0097499839e0fe3af380410eababe5a47c4cf9","cve_id":"CVE-2017-14991","original_address":"https://github.com/torvalds/linux/commit/3e0097499839e0fe3af380410eababe5a47c4cf9","time":"2017-10-04T01:29Z"},
	{"Unnamed: 0":1865,"cwe_id":"CWE-787","source":"CWE-787 static BOOL gdi_Bitmap_Decompress ( rdpContext * context , rdpBitmap * bitmap , const BYTE * pSrcData , UINT32 DstWidth , UINT32 DstHeight , UINT32 bpp , UINT32 length , BOOL compressed , UINT32 codecId ) { UINT32 SrcSize = length ; rdpGdi * gdi = context -> gdi ; <S2SV_StartBug> bitmap -> compressed = FALSE ; <S2SV_EndBug> bitmap -> format = gdi -> dstFormat ; <S2SV_StartBug> bitmap -> length = DstWidth * DstHeight * GetBytesPerPixel ( bitmap -> format ) ; <S2SV_EndBug> bitmap -> data = ( BYTE * ) _aligned_malloc ( bitmap -> length , 16 ) ; if ( ! bitmap -> data ) return FALSE ; if ( compressed ) { if ( bpp < 32 ) { if ( ! interleaved_decompress ( context -> codecs -> interleaved , pSrcData , SrcSize , DstWidth , DstHeight , bpp , bitmap -> data , bitmap -> format , 0 , 0 , 0 , DstWidth , DstHeight , & gdi -> palette ) ) return FALSE ; } else { if ( ! planar_decompress ( context -> codecs -> planar , pSrcData , SrcSize , DstWidth , DstHeight , bitmap -> data , bitmap -> format , 0 , 0 , 0 , DstWidth , DstHeight , TRUE ) ) return FALSE ; } } else { const UINT32 SrcFormat = gdi_get_pixel_format ( bpp ) ; const size_t sbpp = GetBytesPerPixel ( SrcFormat ) ; const size_t dbpp = GetBytesPerPixel ( bitmap -> format ) ; if ( ( sbpp == 0 ) || ( dbpp == 0 ) ) return FALSE ; else { const size_t dstSize = SrcSize * dbpp / sbpp ; if ( dstSize < bitmap -> length ) return FALSE ; } if ( ! freerdp_image_copy ( bitmap -> data , bitmap -> format , 0 , 0 , 0 , DstWidth , DstHeight , pSrcData , SrcFormat , 0 , 0 , 0 , & gdi -> palette , FREERDP_FLIP_VERTICAL ) ) return FALSE ; } return TRUE ; }\n","target":"<S2SV_ModStart> -> gdi ; UINT32 size = DstWidth * DstHeight ; <S2SV_ModStart> -> dstFormat ; if ( ( GetBytesPerPixel ( bitmap -> format ) == 0 ) || ( DstWidth == 0 ) || ( DstHeight == 0 ) || ( DstWidth > UINT32_MAX / DstHeight ) || ( size > ( UINT32_MAX / GetBytesPerPixel ( bitmap -> format ) ) ) ) return FALSE ; size *= GetBytesPerPixel ( bitmap -> format ) ; <S2SV_ModStart> -> length = size <S2SV_ModEnd> ; bitmap ->\n","project_and_commit_id":"FreeRDP@FreeRDP/09b9d4f1994a674c4ec85b4947aa656eda1aed8a","cve_id":"CVE-2018-8787","original_address":"https://github.com/FreeRDP/FreeRDP/commit/09b9d4f1994a674c4ec85b4947aa656eda1aed8a","time":"2018-11-29T18:29Z"},
	{"Unnamed: 0":5885,"cwe_id":"CWE-362","source":"CWE-362 int ext4_insert_range ( struct inode * inode , loff_t offset , loff_t len ) { struct super_block * sb = inode -> i_sb ; handle_t * handle ; struct ext4_ext_path * path ; struct ext4_extent * extent ; ext4_lblk_t offset_lblk , len_lblk , ee_start_lblk = 0 ; unsigned int credits , ee_len ; int ret = 0 , depth , split_flag = 0 ; loff_t ioffset ; if ( ! ext4_test_inode_flag ( inode , EXT4_INODE_EXTENTS ) ) return - EOPNOTSUPP ; if ( offset & ( EXT4_CLUSTER_SIZE ( sb ) - 1 ) || len & ( EXT4_CLUSTER_SIZE ( sb ) - 1 ) ) return - EINVAL ; if ( ! S_ISREG ( inode -> i_mode ) ) return - EOPNOTSUPP ; trace_ext4_insert_range ( inode , offset , len ) ; offset_lblk = offset >> EXT4_BLOCK_SIZE_BITS ( sb ) ; len_lblk = len >> EXT4_BLOCK_SIZE_BITS ( sb ) ; if ( ext4_should_journal_data ( inode ) ) { ret = ext4_force_commit ( inode -> i_sb ) ; if ( ret ) return ret ; } ioffset = round_down ( offset , PAGE_SIZE ) ; ret = filemap_write_and_wait_range ( inode -> i_mapping , ioffset , LLONG_MAX ) ; if ( ret ) return ret ; mutex_lock ( & inode -> i_mutex ) ; if ( ! ext4_test_inode_flag ( inode , EXT4_INODE_EXTENTS ) ) { ret = - EOPNOTSUPP ; goto out_mutex ; } if ( inode -> i_size + len > inode -> i_sb -> s_maxbytes ) { ret = - EFBIG ; goto out_mutex ; } if ( offset >= i_size_read ( inode ) ) { ret = - EINVAL ; goto out_mutex ; } <S2SV_StartBug> truncate_pagecache ( inode , ioffset ) ; <S2SV_EndBug> <S2SV_StartBug> ext4_inode_block_unlocked_dio ( inode ) ; <S2SV_EndBug> inode_dio_wait ( inode ) ; credits = ext4_writepage_trans_blocks ( inode ) ; handle = ext4_journal_start ( inode , EXT4_HT_TRUNCATE , credits ) ; if ( IS_ERR ( handle ) ) { ret = PTR_ERR ( handle ) ; <S2SV_StartBug> goto out_dio ; <S2SV_EndBug> } inode -> i_size += len ; EXT4_I ( inode ) -> i_disksize += len ; inode -> i_mtime = inode -> i_ctime = ext4_current_time ( inode ) ; ret = ext4_mark_inode_dirty ( handle , inode ) ; if ( ret ) goto out_stop ; down_write ( & EXT4_I ( inode ) -> i_data_sem ) ; ext4_discard_preallocations ( inode ) ; path = ext4_find_extent ( inode , offset_lblk , NULL , 0 ) ; if ( IS_ERR ( path ) ) { up_write ( & EXT4_I ( inode ) -> i_data_sem ) ; goto out_stop ; } depth = ext_depth ( inode ) ; extent = path [ depth ] . p_ext ; if ( extent ) { ee_start_lblk = le32_to_cpu ( extent -> ee_block ) ; ee_len = ext4_ext_get_actual_len ( extent ) ; if ( ( offset_lblk > ee_start_lblk ) && ( offset_lblk < ( ee_start_lblk + ee_len ) ) ) { if ( ext4_ext_is_unwritten ( extent ) ) split_flag = EXT4_EXT_MARK_UNWRIT1 | EXT4_EXT_MARK_UNWRIT2 ; ret = ext4_split_extent_at ( handle , inode , & path , offset_lblk , split_flag , EXT4_EX_NOCACHE | EXT4_GET_BLOCKS_PRE_IO | EXT4_GET_BLOCKS_METADATA_NOFAIL ) ; } ext4_ext_drop_refs ( path ) ; kfree ( path ) ; if ( ret < 0 ) { up_write ( & EXT4_I ( inode ) -> i_data_sem ) ; goto out_stop ; } } ret = ext4_es_remove_extent ( inode , offset_lblk , EXT_MAX_BLOCKS - offset_lblk ) ; if ( ret ) { up_write ( & EXT4_I ( inode ) -> i_data_sem ) ; goto out_stop ; } ret = ext4_ext_shift_extents ( inode , handle , ee_start_lblk > offset_lblk ? ee_start_lblk : offset_lblk , len_lblk , SHIFT_RIGHT ) ; up_write ( & EXT4_I ( inode ) -> i_data_sem ) ; if ( IS_SYNC ( inode ) ) ext4_handle_sync ( handle ) ; out_stop : ext4_journal_stop ( handle ) ; <S2SV_StartBug> out_dio : <S2SV_EndBug> ext4_inode_resume_unlocked_dio ( inode ) ; out_mutex : mutex_unlock ( & inode -> i_mutex ) ; return ret ; }\n","target":"<S2SV_ModStart> out_mutex ; } ext4_inode_block_unlocked_dio ( inode ) ; inode_dio_wait ( inode ) ; down_write ( & EXT4_I ( inode ) -> i_mmap_sem ) ; <S2SV_ModStart> ioffset ) ; <S2SV_ModEnd> credits = ext4_writepage_trans_blocks <S2SV_ModStart> ) ; goto out_mmap <S2SV_ModEnd> ; } inode <S2SV_ModStart> handle ) ; out_mmap : up_write ( & EXT4_I ( inode ) -> i_mmap_sem ) ; <S2SV_ModEnd> ext4_inode_resume_unlocked_dio ( inode\n","project_and_commit_id":"torvalds@linux/ea3d7209ca01da209cda6f0dea8be9cc4b7a933b","cve_id":"CVE-2015-8839","original_address":"https://github.com/torvalds/linux/commit/ea3d7209ca01da209cda6f0dea8be9cc4b7a933b","time":"2016-05-02T10:59Z"},
	{"Unnamed: 0":4078,"cwe_id":"CWE-476","source":"CWE-476 bool ExprResolveLhs ( struct xkb_context * ctx , const ExprDef * expr , const char * * elem_rtrn , const char * * field_rtrn , ExprDef * * index_rtrn ) { switch ( expr -> expr . op ) { case EXPR_IDENT : * elem_rtrn = NULL ; * field_rtrn = xkb_atom_text ( ctx , expr -> ident . ident ) ; * index_rtrn = NULL ; return ( * field_rtrn != NULL ) ; case EXPR_FIELD_REF : * elem_rtrn = xkb_atom_text ( ctx , expr -> field_ref . element ) ; * field_rtrn = xkb_atom_text ( ctx , expr -> field_ref . field ) ; * index_rtrn = NULL ; <S2SV_StartBug> return true ; <S2SV_EndBug> case EXPR_ARRAY_REF : * elem_rtrn = xkb_atom_text ( ctx , expr -> array_ref . element ) ; * field_rtrn = xkb_atom_text ( ctx , expr -> array_ref . field ) ; * index_rtrn = expr -> array_ref . entry ; <S2SV_StartBug> return true ; <S2SV_EndBug> default : break ; } log_wsgo ( ctx , \"Unexpected<S2SV_blank>operator<S2SV_blank>%d<S2SV_blank>in<S2SV_blank>ResolveLhs\\\\n\" , expr -> expr . op ) ; return false ; }\n","target":"<S2SV_ModStart> NULL ; return ( * elem_rtrn != NULL && * field_rtrn != NULL ) <S2SV_ModEnd> ; case EXPR_ARRAY_REF <S2SV_ModStart> . entry ; if ( expr -> array_ref . element != XKB_ATOM_NONE && * elem_rtrn == NULL ) return false ; if ( * field_rtrn == NULL ) return false ;\n","project_and_commit_id":"xkbcommon@libxkbcommon/bb4909d2d8fa6b08155e449986a478101e2b2634","cve_id":"CVE-2018-15859","original_address":"https://github.com/xkbcommon/libxkbcommon/commit/bb4909d2d8fa6b08155e449986a478101e2b2634","time":"2018-08-25T21:29Z"},
	{"Unnamed: 0":5942,"cwe_id":"CWE-119","source":"CWE-119 static int xlate_to_uni ( const unsigned char * name , int len , unsigned char * outname , int * longlen , int * outlen , int escape , int utf8 , struct nls_table * nls ) { const unsigned char * ip ; unsigned char nc ; unsigned char * op ; unsigned int ec ; int i , k , fill ; int charlen ; if ( utf8 ) { <S2SV_StartBug> * outlen = utf8s_to_utf16s ( name , len , ( wchar_t * ) outname ) ; <S2SV_EndBug> if ( * outlen < 0 ) return * outlen ; else if ( * outlen > FAT_LFN_LEN ) return - ENAMETOOLONG ; op = & outname [ * outlen * sizeof ( wchar_t ) ] ; } else { if ( nls ) { for ( i = 0 , ip = name , op = outname , * outlen = 0 ; i < len && * outlen <= FAT_LFN_LEN ; * outlen += 1 ) { if ( escape && ( * ip == ':' ) ) { if ( i > len - 5 ) return - EINVAL ; ec = 0 ; for ( k = 1 ; k < 5 ; k ++ ) { nc = ip [ k ] ; ec <<= 4 ; if ( nc >= '0' && nc <= '9' ) { ec |= nc - '0' ; continue ; } if ( nc >= 'a' && nc <= 'f' ) { ec |= nc - ( 'a' - 10 ) ; continue ; } if ( nc >= 'A' && nc <= 'F' ) { ec |= nc - ( 'A' - 10 ) ; continue ; } return - EINVAL ; } * op ++ = ec & 0xFF ; * op ++ = ec >> 8 ; ip += 5 ; i += 5 ; } else { if ( ( charlen = nls -> char2uni ( ip , len - i , ( wchar_t * ) op ) ) < 0 ) return - EINVAL ; ip += charlen ; i += charlen ; op += 2 ; } } if ( i < len ) return - ENAMETOOLONG ; } else { for ( i = 0 , ip = name , op = outname , * outlen = 0 ; i < len && * outlen <= FAT_LFN_LEN ; i ++ , * outlen += 1 ) { * op ++ = * ip ++ ; * op ++ = 0 ; } if ( i < len ) return - ENAMETOOLONG ; } } * longlen = * outlen ; if ( * outlen % 13 ) { * op ++ = 0 ; * op ++ = 0 ; * outlen += 1 ; if ( * outlen % 13 ) { fill = 13 - ( * outlen % 13 ) ; for ( i = 0 ; i < fill ; i ++ ) { * op ++ = 0xff ; * op ++ = 0xff ; } * outlen += fill ; } } return 0 ; }\n","target":"<S2SV_ModStart> , len , UTF16_HOST_ENDIAN , <S2SV_ModStart> * ) outname , FAT_LFN_LEN + 2\n","project_and_commit_id":"torvalds@linux/0720a06a7518c9d0c0125bd5d1f3b6264c55c3dd","cve_id":"CVE-2013-1773","original_address":"https://github.com/torvalds/linux/commit/0720a06a7518c9d0c0125bd5d1f3b6264c55c3dd","time":"2013-02-28T19:55Z"},
	{"Unnamed: 0":2456,"cwe_id":"CWE-672","source":"CWE-672 int sc_pkcs15_decode_prkdf_entry ( struct sc_pkcs15_card * p15card , struct sc_pkcs15_object * obj , const u8 * * buf , size_t * buflen ) { sc_context_t * ctx = p15card -> card -> ctx ; struct sc_pkcs15_prkey_info info ; int r , i , gostr3410_params [ 3 ] ; struct sc_pkcs15_keyinfo_gostparams * keyinfo_gostparams ; size_t usage_len = sizeof ( info . usage ) ; size_t af_len = sizeof ( info . access_flags ) ; struct sc_asn1_entry asn1_com_key_attr [ C_ASN1_COM_KEY_ATTR_SIZE ] ; struct sc_asn1_entry asn1_com_prkey_attr [ C_ASN1_COM_PRKEY_ATTR_SIZE ] ; struct sc_asn1_entry asn1_rsakey_attr [ C_ASN1_RSAKEY_ATTR_SIZE ] ; struct sc_asn1_entry asn1_prk_rsa_attr [ C_ASN1_PRK_RSA_ATTR_SIZE ] ; struct sc_asn1_entry asn1_dsakey_attr [ C_ASN1_DSAKEY_ATTR_SIZE ] ; struct sc_asn1_entry asn1_prk_dsa_attr [ C_ASN1_PRK_DSA_ATTR_SIZE ] ; struct sc_asn1_entry asn1_dsakey_i_p_attr [ C_ASN1_DSAKEY_I_P_ATTR_SIZE ] ; struct sc_asn1_entry asn1_dsakey_value_attr [ C_ASN1_DSAKEY_VALUE_ATTR_SIZE ] ; struct sc_asn1_entry asn1_gostr3410key_attr [ C_ASN1_GOSTR3410KEY_ATTR_SIZE ] ; struct sc_asn1_entry asn1_prk_gostr3410_attr [ C_ASN1_PRK_GOSTR3410_ATTR_SIZE ] ; struct sc_asn1_entry asn1_ecckey_attr [ C_ASN1_ECCKEY_ATTR ] ; struct sc_asn1_entry asn1_prk_ecc_attr [ C_ASN1_PRK_ECC_ATTR ] ; struct sc_asn1_entry asn1_prkey [ C_ASN1_PRKEY_SIZE ] ; struct sc_asn1_entry asn1_supported_algorithms [ C_ASN1_SUPPORTED_ALGORITHMS_SIZE ] ; struct sc_asn1_pkcs15_object rsa_prkey_obj = { obj , asn1_com_key_attr , asn1_com_prkey_attr , asn1_prk_rsa_attr } ; struct sc_asn1_pkcs15_object dsa_prkey_obj = { obj , asn1_com_key_attr , asn1_com_prkey_attr , asn1_prk_dsa_attr } ; struct sc_asn1_pkcs15_object gostr3410_prkey_obj = { obj , asn1_com_key_attr , asn1_com_prkey_attr , asn1_prk_gostr3410_attr } ; struct sc_asn1_pkcs15_object ecc_prkey_obj = { obj , asn1_com_key_attr , asn1_com_prkey_attr , asn1_prk_ecc_attr } ; sc_copy_asn1_entry ( c_asn1_prkey , asn1_prkey ) ; sc_copy_asn1_entry ( c_asn1_supported_algorithms , asn1_supported_algorithms ) ; sc_copy_asn1_entry ( c_asn1_prk_rsa_attr , asn1_prk_rsa_attr ) ; sc_copy_asn1_entry ( c_asn1_rsakey_attr , asn1_rsakey_attr ) ; sc_copy_asn1_entry ( c_asn1_prk_dsa_attr , asn1_prk_dsa_attr ) ; sc_copy_asn1_entry ( c_asn1_dsakey_attr , asn1_dsakey_attr ) ; sc_copy_asn1_entry ( c_asn1_dsakey_value_attr , asn1_dsakey_value_attr ) ; sc_copy_asn1_entry ( c_asn1_dsakey_i_p_attr , asn1_dsakey_i_p_attr ) ; sc_copy_asn1_entry ( c_asn1_prk_gostr3410_attr , asn1_prk_gostr3410_attr ) ; sc_copy_asn1_entry ( c_asn1_gostr3410key_attr , asn1_gostr3410key_attr ) ; sc_copy_asn1_entry ( c_asn1_prk_ecc_attr , asn1_prk_ecc_attr ) ; sc_copy_asn1_entry ( c_asn1_ecckey_attr , asn1_ecckey_attr ) ; sc_copy_asn1_entry ( c_asn1_com_prkey_attr , asn1_com_prkey_attr ) ; sc_copy_asn1_entry ( c_asn1_com_key_attr , asn1_com_key_attr ) ; sc_format_asn1_entry ( asn1_prkey + 0 , & rsa_prkey_obj , NULL , 0 ) ; sc_format_asn1_entry ( asn1_prkey + 1 , & ecc_prkey_obj , NULL , 0 ) ; sc_format_asn1_entry ( asn1_prkey + 2 , & dsa_prkey_obj , NULL , 0 ) ; sc_format_asn1_entry ( asn1_prkey + 3 , & gostr3410_prkey_obj , NULL , 0 ) ; sc_format_asn1_entry ( asn1_prk_rsa_attr + 0 , asn1_rsakey_attr , NULL , 0 ) ; sc_format_asn1_entry ( asn1_prk_dsa_attr + 0 , asn1_dsakey_attr , NULL , 0 ) ; sc_format_asn1_entry ( asn1_prk_gostr3410_attr + 0 , asn1_gostr3410key_attr , NULL , 0 ) ; sc_format_asn1_entry ( asn1_prk_ecc_attr + 0 , asn1_ecckey_attr , NULL , 0 ) ; sc_format_asn1_entry ( asn1_rsakey_attr + 0 , & info . path , NULL , 0 ) ; sc_format_asn1_entry ( asn1_rsakey_attr + 1 , & info . modulus_length , NULL , 0 ) ; sc_format_asn1_entry ( asn1_dsakey_attr + 0 , asn1_dsakey_value_attr , NULL , 0 ) ; sc_format_asn1_entry ( asn1_dsakey_value_attr + 0 , & info . path , NULL , 0 ) ; sc_format_asn1_entry ( asn1_dsakey_value_attr + 1 , asn1_dsakey_i_p_attr , NULL , 0 ) ; sc_format_asn1_entry ( asn1_dsakey_i_p_attr + 0 , & info . path , NULL , 0 ) ; sc_format_asn1_entry ( asn1_gostr3410key_attr + 0 , & info . path , NULL , 0 ) ; sc_format_asn1_entry ( asn1_gostr3410key_attr + 1 , & gostr3410_params [ 0 ] , NULL , 0 ) ; sc_format_asn1_entry ( asn1_gostr3410key_attr + 2 , & gostr3410_params [ 1 ] , NULL , 0 ) ; sc_format_asn1_entry ( asn1_gostr3410key_attr + 3 , & gostr3410_params [ 2 ] , NULL , 0 ) ; sc_format_asn1_entry ( asn1_ecckey_attr + 0 , & info . path , NULL , 0 ) ; sc_format_asn1_entry ( asn1_ecckey_attr + 1 , & info . field_length , NULL , 0 ) ; sc_format_asn1_entry ( asn1_com_key_attr + 0 , & info . id , NULL , 0 ) ; sc_format_asn1_entry ( asn1_com_key_attr + 1 , & info . usage , & usage_len , 0 ) ; sc_format_asn1_entry ( asn1_com_key_attr + 2 , & info . native , NULL , 0 ) ; sc_format_asn1_entry ( asn1_com_key_attr + 3 , & info . access_flags , & af_len , 0 ) ; sc_format_asn1_entry ( asn1_com_key_attr + 4 , & info . key_reference , NULL , 0 ) ; for ( i = 0 ; i < SC_MAX_SUPPORTED_ALGORITHMS && ( asn1_supported_algorithms + i ) -> name ; i ++ ) sc_format_asn1_entry ( asn1_supported_algorithms + i , & info . algo_refs [ i ] , NULL , 0 ) ; sc_format_asn1_entry ( asn1_com_key_attr + 5 , asn1_supported_algorithms , NULL , 0 ) ; sc_format_asn1_entry ( asn1_com_prkey_attr + 0 , & info . subject . value , & info . subject . len , 0 ) ; memset ( & info , 0 , sizeof ( info ) ) ; info . key_reference = - 1 ; info . native = 1 ; memset ( gostr3410_params , 0 , sizeof ( gostr3410_params ) ) ; r = sc_asn1_decode_choice ( ctx , asn1_prkey , * buf , * buflen , buf , buflen ) ; if ( r < 0 ) { <S2SV_StartBug> if ( asn1_com_prkey_attr -> flags & SC_ASN1_PRESENT && <S2SV_EndBug> asn1_com_prkey_attr [ 0 ] . flags & SC_ASN1_PRESENT ) { free ( asn1_com_prkey_attr [ 0 ] . parm ) ; } } if ( r == SC_ERROR_ASN1_END_OF_CONTENTS ) return r ; LOG_TEST_RET ( ctx , r , \"PrKey<S2SV_blank>DF<S2SV_blank>ASN.1<S2SV_blank>decoding<S2SV_blank>failed\" ) ; if ( asn1_prkey [ 0 ] . flags & SC_ASN1_PRESENT ) { obj -> type = SC_PKCS15_TYPE_PRKEY_RSA ; } else if ( asn1_prkey [ 1 ] . flags & SC_ASN1_PRESENT ) { obj -> type = SC_PKCS15_TYPE_PRKEY_EC ; } else if ( asn1_prkey [ 2 ] . flags & SC_ASN1_PRESENT ) { obj -> type = SC_PKCS15_TYPE_PRKEY_DSA ; if ( asn1_dsakey_i_p_attr [ 0 ] . flags & SC_ASN1_PRESENT ) info . path . type = SC_PATH_TYPE_PATH_PROT ; } else if ( asn1_prkey [ 3 ] . flags & SC_ASN1_PRESENT ) { obj -> type = SC_PKCS15_TYPE_PRKEY_GOSTR3410 ; assert ( info . modulus_length == 0 ) ; info . modulus_length = SC_PKCS15_GOSTR3410_KEYSIZE ; assert ( info . params . len == 0 ) ; info . params . len = sizeof ( struct sc_pkcs15_keyinfo_gostparams ) ; info . params . data = malloc ( info . params . len ) ; if ( info . params . data == NULL ) LOG_FUNC_RETURN ( ctx , SC_ERROR_OUT_OF_MEMORY ) ; assert ( sizeof ( * keyinfo_gostparams ) == info . params . len ) ; keyinfo_gostparams = info . params . data ; keyinfo_gostparams -> gostr3410 = gostr3410_params [ 0 ] ; keyinfo_gostparams -> gostr3411 = gostr3410_params [ 1 ] ; keyinfo_gostparams -> gost28147 = gostr3410_params [ 2 ] ; } else { sc_log ( ctx , \"Neither<S2SV_blank>RSA<S2SV_blank>or<S2SV_blank>DSA<S2SV_blank>or<S2SV_blank>GOSTR3410<S2SV_blank>or<S2SV_blank>ECC<S2SV_blank>key<S2SV_blank>in<S2SV_blank>PrKDF<S2SV_blank>entry.\" ) ; LOG_FUNC_RETURN ( ctx , SC_ERROR_INVALID_ASN1_OBJECT ) ; } if ( ! p15card -> app || ! p15card -> app -> ddo . aid . len ) { r = sc_pkcs15_make_absolute_path ( & p15card -> file_app -> path , & info . path ) ; if ( r < 0 ) { sc_pkcs15_free_key_params ( & info . params ) ; return r ; } } else { info . path . aid = p15card -> app -> ddo . aid ; } sc_log ( ctx , \"PrivKey<S2SV_blank>path<S2SV_blank>\\'%s\\'\" , sc_print_path ( & info . path ) ) ; if ( info . key_reference < - 1 ) info . key_reference += 256 ; if ( ( obj -> flags & SC_PKCS15_CO_FLAG_PRIVATE ) && ( obj -> auth_id . len == 0 ) ) { sc_log ( ctx , \"Private<S2SV_blank>key<S2SV_blank>%s<S2SV_blank>has<S2SV_blank>no<S2SV_blank>auth<S2SV_blank>ID<S2SV_blank>-<S2SV_blank>checking<S2SV_blank>AccessControlRules\" , sc_pkcs15_print_id ( & info . id ) ) ; for ( i = 0 ; i < SC_PKCS15_MAX_ACCESS_RULES ; i ++ ) { if ( obj -> access_rules [ i ] . access_mode & ( SC_PKCS15_ACCESS_RULE_MODE_EXECUTE | SC_PKCS15_ACCESS_RULE_MODE_PSO_CDS | SC_PKCS15_ACCESS_RULE_MODE_PSO_DECRYPT | SC_PKCS15_ACCESS_RULE_MODE_INT_AUTH ) ) { if ( obj -> access_rules [ i ] . auth_id . len != 0 ) { obj -> auth_id = obj -> access_rules [ i ] . auth_id ; sc_log ( ctx , \"Auth<S2SV_blank>ID<S2SV_blank>found<S2SV_blank>-<S2SV_blank>%s\" , sc_pkcs15_print_id ( & obj -> auth_id ) ) ; break ; } } } if ( i == SC_PKCS15_MAX_ACCESS_RULES ) sc_log ( ctx , \"Warning:<S2SV_blank>No<S2SV_blank>auth<S2SV_blank>ID<S2SV_blank>found\" ) ; } obj -> data = malloc ( sizeof ( info ) ) ; if ( obj -> data == NULL ) { sc_pkcs15_free_key_params ( & info . params ) ; LOG_FUNC_RETURN ( ctx , SC_ERROR_OUT_OF_MEMORY ) ; } memcpy ( obj -> data , & info , sizeof ( info ) ) ; sc_log ( ctx , \"Key<S2SV_blank>Subject<S2SV_blank>%s\" , sc_dump_hex ( info . subject . value , info . subject . len ) ) ; sc_log ( ctx , \"Key<S2SV_blank>path<S2SV_blank>%s\" , sc_print_path ( & info . path ) ) ; return 0 ; }\n","target":"<S2SV_ModStart> 0 ) { free ( info . subject . value ) ; <S2SV_ModEnd> } if (\n","project_and_commit_id":"OpenSC@OpenSC/6ce6152284c47ba9b1d4fe8ff9d2e6a3f5ee02c7","cve_id":"CVE-2019-19480","original_address":"https://github.com/OpenSC/OpenSC/commit/6ce6152284c47ba9b1d4fe8ff9d2e6a3f5ee02c7","time":"2019-12-01T23:15Z"},
	{"Unnamed: 0":4353,"cwe_id":"CWE-400","source":"CWE-400 static void perf_event_read_event ( struct perf_event * event , struct task_struct * task ) { struct perf_output_handle handle ; struct perf_sample_data sample ; struct perf_read_event read_event = { . header = { . type = PERF_RECORD_READ , . misc = 0 , . size = sizeof ( read_event ) + event -> read_size , } , . pid = perf_event_pid ( event , task ) , . tid = perf_event_tid ( event , task ) , } ; int ret ; perf_event_header__init_id ( & read_event . header , & sample , event ) ; <S2SV_StartBug> ret = perf_output_begin ( & handle , event , read_event . header . size , 0 , 0 ) ; <S2SV_EndBug> if ( ret ) return ; perf_output_put ( & handle , read_event ) ; perf_output_read ( & handle , event ) ; perf_event__output_id_sample ( event , & handle , & sample ) ; perf_output_end ( & handle ) ; }\n","target":"<S2SV_ModStart> size , 0 <S2SV_ModEnd> ) ; if\n","project_and_commit_id":"torvalds@linux/a8b0ca17b80e92faab46ee7179ba9e99ccb61233","cve_id":"CVE-2011-2918","original_address":"https://github.com/torvalds/linux/commit/a8b0ca17b80e92faab46ee7179ba9e99ccb61233","time":"2012-05-24T23:55Z"},
	{"Unnamed: 0":4583,"cwe_id":"CWE-17","source":"CWE-17 static int do_dentry_open ( struct file * f , int ( * open ) ( struct inode * , struct file * ) , const struct cred * cred ) { static const struct file_operations empty_fops = { } ; struct inode * inode ; int error ; f -> f_mode = OPEN_FMODE ( f -> f_flags ) | FMODE_LSEEK | FMODE_PREAD | FMODE_PWRITE ; if ( unlikely ( f -> f_flags & O_PATH ) ) f -> f_mode = FMODE_PATH ; path_get ( & f -> f_path ) ; inode = f -> f_inode = f -> f_path . dentry -> d_inode ; if ( f -> f_mode & FMODE_WRITE ) { error = __get_file_write_access ( inode , f -> f_path . mnt ) ; if ( error ) goto cleanup_file ; if ( ! special_file ( inode -> i_mode ) ) file_take_write ( f ) ; } f -> f_mapping = inode -> i_mapping ; <S2SV_StartBug> file_sb_list_add ( f , inode -> i_sb ) ; <S2SV_EndBug> if ( unlikely ( f -> f_mode & FMODE_PATH ) ) { f -> f_op = & empty_fops ; return 0 ; } f -> f_op = fops_get ( inode -> i_fop ) ; if ( unlikely ( WARN_ON ( ! f -> f_op ) ) ) { error = - ENODEV ; goto cleanup_all ; } error = security_file_open ( f , cred ) ; if ( error ) goto cleanup_all ; error = break_lease ( inode , f -> f_flags ) ; if ( error ) goto cleanup_all ; if ( ! open ) open = f -> f_op -> open ; if ( open ) { error = open ( inode , f ) ; if ( error ) goto cleanup_all ; } if ( ( f -> f_mode & ( FMODE_READ | FMODE_WRITE ) ) == FMODE_READ ) i_readcount_inc ( inode ) ; f -> f_flags &= ~ ( O_CREAT | O_EXCL | O_NOCTTY | O_TRUNC ) ; file_ra_state_init ( & f -> f_ra , f -> f_mapping -> host -> i_mapping ) ; return 0 ; cleanup_all : fops_put ( f -> f_op ) ; <S2SV_StartBug> file_sb_list_del ( f ) ; <S2SV_EndBug> if ( f -> f_mode & FMODE_WRITE ) { put_write_access ( inode ) ; if ( ! special_file ( inode -> i_mode ) ) { file_reset_write ( f ) ; __mnt_drop_write ( f -> f_path . mnt ) ; } } cleanup_file : path_put ( & f -> f_path ) ; f -> f_path . mnt = NULL ; f -> f_path . dentry = NULL ; f -> f_inode = NULL ; return error ; }\n","target":"<S2SV_ModStart> -> i_mapping ; <S2SV_ModEnd> if ( unlikely <S2SV_ModStart> f_op ) ; <S2SV_ModEnd> if ( f\n","project_and_commit_id":"torvalds@linux/eee5cc2702929fd41cce28058dc6d6717f723f87","cve_id":"CVE-2014-8172","original_address":"https://github.com/torvalds/linux/commit/eee5cc2702929fd41cce28058dc6d6717f723f87","time":"2015-03-16T10:59Z"},
	{"Unnamed: 0":2149,"cwe_id":"CWE-362","source":"CWE-362 static ssize_t driver_override_store ( struct device * dev , struct device_attribute * attr , const char * buf , size_t count ) { struct platform_device * pdev = to_platform_device ( dev ) ; <S2SV_StartBug> char * driver_override , * old = pdev -> driver_override , * cp ; <S2SV_EndBug> if ( count > PATH_MAX ) return - EINVAL ; driver_override = kstrndup ( buf , count , GFP_KERNEL ) ; if ( ! driver_override ) return - ENOMEM ; cp = strchr ( driver_override , '\\\\n' ) ; if ( cp ) * cp = '\\\\0' ; <S2SV_StartBug> if ( strlen ( driver_override ) ) { <S2SV_EndBug> pdev -> driver_override = driver_override ; } else { kfree ( driver_override ) ; pdev -> driver_override = NULL ; } <S2SV_StartBug> kfree ( old ) ; <S2SV_EndBug> return count ; }\n","target":"<S2SV_ModStart> , * old <S2SV_ModEnd> , * cp <S2SV_ModStart> = '\\\\0' ; device_lock ( dev ) ; old = pdev -> driver_override ; <S2SV_ModStart> NULL ; } device_unlock ( dev ) ;\n","project_and_commit_id":"torvalds@linux/6265539776a0810b7ce6398c27866ddb9c6bd154","cve_id":"CVE-2017-12146","original_address":"https://github.com/torvalds/linux/commit/6265539776a0810b7ce6398c27866ddb9c6bd154","time":"2017-09-08T19:29Z"},
	{"Unnamed: 0":3949,"cwe_id":"CWE-19","source":"CWE-19 static int nft_flush_table ( struct nft_ctx * ctx ) { int err ; struct nft_chain * chain , * nc ; struct nft_set * set , * ns ; <S2SV_StartBug> list_for_each_entry_safe ( chain , nc , & ctx -> table -> chains , list ) { <S2SV_EndBug> ctx -> chain = chain ; err = nft_delrule_by_chain ( ctx ) ; if ( err < 0 ) goto out ; <S2SV_StartBug> err = nft_delchain ( ctx ) ; <S2SV_EndBug> if ( err < 0 ) goto out ; } <S2SV_StartBug> list_for_each_entry_safe ( set , ns , & ctx -> table -> sets , list ) { <S2SV_EndBug> <S2SV_StartBug> if ( set -> flags & NFT_SET_ANONYMOUS && <S2SV_EndBug> ! list_empty ( & set -> bindings ) ) continue ; err = nft_delset ( ctx , set ) ; if ( err < 0 ) goto out ; } err = nft_deltable ( ctx ) ; out : return err ; }\n","target":"<S2SV_ModStart> * ns ; list_for_each_entry ( chain <S2SV_ModEnd> , & ctx <S2SV_ModStart> goto out ; } list_for_each_entry_safe ( set , ns , & ctx -> table -> sets , list ) { if ( set -> flags & NFT_SET_ANONYMOUS && ! list_empty ( & set -> bindings ) ) continue ; err = nft_delset ( ctx , set <S2SV_ModEnd> ) ; if <S2SV_ModStart> } list_for_each_entry_safe ( chain , nc <S2SV_ModEnd> , & ctx <S2SV_ModStart> -> table -> chains <S2SV_ModEnd> , list ) <S2SV_ModStart> list ) { ctx -> chain = chain ; err = nft_delchain ( ctx <S2SV_ModEnd> ) ; if\n","project_and_commit_id":"torvalds@linux/a2f18db0c68fec96631c10cad9384c196e9008ac","cve_id":"CVE-2015-1573","original_address":"https://github.com/torvalds/linux/commit/a2f18db0c68fec96631c10cad9384c196e9008ac","time":"2016-05-02T10:59Z"},
	{"Unnamed: 0":3185,"cwe_id":"CWE-119","source":"CWE-119 static void sum_intra_stats ( FRAME_COUNTS * counts , const MODE_INFO * mi ) { <S2SV_StartBug> const MB_PREDICTION_MODE y_mode = mi -> mbmi . mode ; <S2SV_EndBug> <S2SV_StartBug> const MB_PREDICTION_MODE uv_mode = mi -> mbmi . uv_mode ; <S2SV_EndBug> const BLOCK_SIZE bsize = mi -> mbmi . sb_type ; if ( bsize < BLOCK_8X8 ) { int idx , idy ; const int num_4x4_w = num_4x4_blocks_wide_lookup [ bsize ] ; const int num_4x4_h = num_4x4_blocks_high_lookup [ bsize ] ; for ( idy = 0 ; idy < 2 ; idy += num_4x4_h ) for ( idx = 0 ; idx < 2 ; idx += num_4x4_w ) ++ counts -> y_mode [ 0 ] [ mi -> bmi [ idy * 2 + idx ] . as_mode ] ; } else { ++ counts -> y_mode [ size_group_lookup [ bsize ] ] [ y_mode ] ; } ++ counts -> uv_mode [ y_mode ] [ uv_mode ] ; }\n","target":"<S2SV_ModStart> ) { const PREDICTION_MODE <S2SV_ModEnd> y_mode = mi <S2SV_ModStart> mode ; const PREDICTION_MODE <S2SV_ModEnd> uv_mode = mi\n","project_and_commit_id":"external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426","cve_id":"CVE-2016-1621","original_address":"https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426","time":"2016-03-12T21:59Z"},
	{"Unnamed: 0":2386,"cwe_id":"CWE-119","source":"CWE-119 <S2SV_StartBug> static void choose_intra_uv_mode ( VP9_COMP * cpi , PICK_MODE_CONTEXT * ctx , <S2SV_EndBug> BLOCK_SIZE bsize , TX_SIZE max_tx_size , int * rate_uv , int * rate_uv_tokenonly , int64_t * dist_uv , int * skip_uv , <S2SV_StartBug> MB_PREDICTION_MODE * mode_uv ) { <S2SV_EndBug> <S2SV_StartBug> MACROBLOCK * const x = & cpi -> mb ; <S2SV_EndBug> if ( cpi -> sf . use_uv_intra_rd_estimate ) { rd_sbuv_dcpred ( cpi , x , rate_uv , rate_uv_tokenonly , dist_uv , skip_uv , bsize < BLOCK_8X8 ? BLOCK_8X8 : bsize ) ; } else { rd_pick_intra_sbuv_mode ( cpi , x , ctx , rate_uv , rate_uv_tokenonly , dist_uv , skip_uv , bsize < BLOCK_8X8 ? BLOCK_8X8 : bsize , max_tx_size ) ; } * mode_uv = x -> e_mbd . mi [ 0 ] -> mbmi . uv_mode ; }\n","target":"<S2SV_ModStart> * cpi , MACROBLOCK * const x , <S2SV_ModStart> * skip_uv , PREDICTION_MODE <S2SV_ModEnd> * mode_uv ) <S2SV_ModStart> mode_uv ) { <S2SV_ModEnd> if ( cpi\n","project_and_commit_id":"external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426","cve_id":"CVE-2016-1621","original_address":"https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426","time":"2016-03-12T21:59Z"},
	{"Unnamed: 0":1493,"cwe_id":"CWE-400","source":"CWE-400 int handle_ldf_stq ( u32 insn , struct pt_regs * regs ) { unsigned long addr = compute_effective_address ( regs , insn , 0 ) ; int freg = ( ( insn >> 25 ) & 0x1e ) | ( ( insn >> 20 ) & 0x20 ) ; struct fpustate * f = FPUSTATE ; int asi = decode_asi ( insn , regs ) ; int flag = ( freg < 32 ) ? FPRS_DL : FPRS_DU ; <S2SV_StartBug> perf_sw_event ( PERF_COUNT_SW_EMULATION_FAULTS , 1 , 0 , regs , 0 ) ; <S2SV_EndBug> save_and_clear_fpu ( ) ; current_thread_info ( ) -> xfsr [ 0 ] &= ~ 0x1c000 ; if ( freg & 3 ) { current_thread_info ( ) -> xfsr [ 0 ] |= ( 6 << 14 ) ; do_fpother ( regs ) ; return 0 ; } if ( insn & 0x200000 ) { u64 first = 0 , second = 0 ; if ( current_thread_info ( ) -> fpsaved [ 0 ] & flag ) { first = * ( u64 * ) & f -> regs [ freg ] ; second = * ( u64 * ) & f -> regs [ freg + 2 ] ; } if ( asi < 0x80 ) { do_privact ( regs ) ; return 1 ; } switch ( asi ) { case ASI_P : case ASI_S : break ; case ASI_PL : case ASI_SL : { u64 tmp = __swab64p ( & first ) ; first = __swab64p ( & second ) ; second = tmp ; break ; } default : if ( tlb_type == hypervisor ) sun4v_data_access_exception ( regs , addr , 0 ) ; else spitfire_data_access_exception ( regs , 0 , addr ) ; return 1 ; } if ( put_user ( first >> 32 , ( u32 __user * ) addr ) || __put_user ( ( u32 ) first , ( u32 __user * ) ( addr + 4 ) ) || __put_user ( second >> 32 , ( u32 __user * ) ( addr + 8 ) ) || __put_user ( ( u32 ) second , ( u32 __user * ) ( addr + 12 ) ) ) { if ( tlb_type == hypervisor ) sun4v_data_access_exception ( regs , addr , 0 ) ; else spitfire_data_access_exception ( regs , 0 , addr ) ; return 1 ; } } else { u32 data [ 4 ] __attribute__ ( ( aligned ( 8 ) ) ) ; int size , i ; int err ; if ( asi < 0x80 ) { do_privact ( regs ) ; return 1 ; } else if ( asi > ASI_SNFL ) { if ( tlb_type == hypervisor ) sun4v_data_access_exception ( regs , addr , 0 ) ; else spitfire_data_access_exception ( regs , 0 , addr ) ; return 1 ; } switch ( insn & 0x180000 ) { case 0x000000 : size = 1 ; break ; case 0x100000 : size = 4 ; break ; default : size = 2 ; break ; } for ( i = 0 ; i < size ; i ++ ) data [ i ] = 0 ; err = get_user ( data [ 0 ] , ( u32 __user * ) addr ) ; if ( ! err ) { for ( i = 1 ; i < size ; i ++ ) err |= __get_user ( data [ i ] , ( u32 __user * ) ( addr + 4 * i ) ) ; } if ( err && ! ( asi & 0x2 ) ) { if ( tlb_type == hypervisor ) sun4v_data_access_exception ( regs , addr , 0 ) ; else spitfire_data_access_exception ( regs , 0 , addr ) ; return 1 ; } if ( asi & 0x8 ) { u64 tmp ; switch ( size ) { case 1 : data [ 0 ] = le32_to_cpup ( data + 0 ) ; break ; default : * ( u64 * ) ( data + 0 ) = le64_to_cpup ( ( u64 * ) ( data + 0 ) ) ; break ; case 4 : tmp = le64_to_cpup ( ( u64 * ) ( data + 0 ) ) ; * ( u64 * ) ( data + 0 ) = le64_to_cpup ( ( u64 * ) ( data + 2 ) ) ; * ( u64 * ) ( data + 2 ) = tmp ; break ; } } if ( ! ( current_thread_info ( ) -> fpsaved [ 0 ] & FPRS_FEF ) ) { current_thread_info ( ) -> fpsaved [ 0 ] = FPRS_FEF ; current_thread_info ( ) -> gsr [ 0 ] = 0 ; } if ( ! ( current_thread_info ( ) -> fpsaved [ 0 ] & flag ) ) { if ( freg < 32 ) memset ( f -> regs , 0 , 32 * sizeof ( u32 ) ) ; else memset ( f -> regs + 32 , 0 , 32 * sizeof ( u32 ) ) ; } memcpy ( f -> regs + freg , data , size * 4 ) ; current_thread_info ( ) -> fpsaved [ 0 ] |= flag ; } advance ( regs ) ; return 1 ; }\n","target":"<S2SV_ModStart> , 1 , <S2SV_ModEnd> regs , 0\n","project_and_commit_id":"torvalds@linux/a8b0ca17b80e92faab46ee7179ba9e99ccb61233","cve_id":"CVE-2011-2918","original_address":"https://github.com/torvalds/linux/commit/a8b0ca17b80e92faab46ee7179ba9e99ccb61233","time":"2012-05-24T23:55Z"},
	{"Unnamed: 0":4352,"cwe_id":"CWE-59","source":"CWE-59 void vrrp_print_json ( void ) { FILE * file ; element e ; struct json_object * array ; if ( LIST_ISEMPTY ( vrrp_data -> vrrp ) ) return ; <S2SV_StartBug> file = fopen ( \"/tmp/keepalived.json\" , \"w\" ) ; <S2SV_EndBug> if ( ! file ) { log_message ( LOG_INFO , \"Can\\'t<S2SV_blank>open<S2SV_blank>/tmp/keepalived.json<S2SV_blank>(%d:<S2SV_blank>%s)\" , errno , strerror ( errno ) ) ; return ; } array = json_object_new_array ( ) ; for ( e = LIST_HEAD ( vrrp_data -> vrrp ) ; e ; ELEMENT_NEXT ( e ) ) { struct json_object * instance_json , * json_stats , * json_data , * vips , * evips , * track_ifp , * track_script ; # ifdef _HAVE_FIB_ROUTING_ struct json_object * vroutes , * vrules ; # endif element f ; vrrp_t * vrrp = ELEMENT_DATA ( e ) ; instance_json = json_object_new_object ( ) ; json_stats = json_object_new_object ( ) ; json_data = json_object_new_object ( ) ; vips = json_object_new_array ( ) ; evips = json_object_new_array ( ) ; track_ifp = json_object_new_array ( ) ; track_script = json_object_new_array ( ) ; # ifdef _HAVE_FIB_ROUTING_ vroutes = json_object_new_array ( ) ; vrules = json_object_new_array ( ) ; # endif json_object_object_add ( json_data , \"iname\" , json_object_new_string ( vrrp -> iname ) ) ; json_object_object_add ( json_data , \"dont_track_primary\" , json_object_new_int ( vrrp -> dont_track_primary ) ) ; json_object_object_add ( json_data , \"skip_check_adv_addr\" , json_object_new_int ( vrrp -> skip_check_adv_addr ) ) ; json_object_object_add ( json_data , \"strict_mode\" , json_object_new_int ( ( int ) vrrp -> strict_mode ) ) ; # ifdef _HAVE_VRRP_VMAC_ json_object_object_add ( json_data , \"vmac_ifname\" , json_object_new_string ( vrrp -> vmac_ifname ) ) ; # endif if ( ! LIST_ISEMPTY ( vrrp -> track_ifp ) ) { for ( f = LIST_HEAD ( vrrp -> track_ifp ) ; f ; ELEMENT_NEXT ( f ) ) { interface_t * ifp = ELEMENT_DATA ( f ) ; json_object_array_add ( track_ifp , json_object_new_string ( ifp -> ifname ) ) ; } } json_object_object_add ( json_data , \"track_ifp\" , track_ifp ) ; if ( ! LIST_ISEMPTY ( vrrp -> track_script ) ) { for ( f = LIST_HEAD ( vrrp -> track_script ) ; f ; ELEMENT_NEXT ( f ) ) { tracked_sc_t * tsc = ELEMENT_DATA ( f ) ; vrrp_script_t * vscript = tsc -> scr ; json_object_array_add ( track_script , json_object_new_string ( cmd_str ( & vscript -> script ) ) ) ; } } json_object_object_add ( json_data , \"track_script\" , track_script ) ; json_object_object_add ( json_data , \"ifp_ifname\" , json_object_new_string ( vrrp -> ifp -> ifname ) ) ; json_object_object_add ( json_data , \"master_priority\" , json_object_new_int ( vrrp -> master_priority ) ) ; json_object_object_add ( json_data , \"last_transition\" , json_object_new_double ( timeval_to_double ( & vrrp -> last_transition ) ) ) ; json_object_object_add ( json_data , \"garp_delay\" , json_object_new_double ( vrrp -> garp_delay / TIMER_HZ_FLOAT ) ) ; json_object_object_add ( json_data , \"garp_refresh\" , json_object_new_int ( ( int ) vrrp -> garp_refresh . tv_sec ) ) ; json_object_object_add ( json_data , \"garp_rep\" , json_object_new_int ( ( int ) vrrp -> garp_rep ) ) ; json_object_object_add ( json_data , \"garp_refresh_rep\" , json_object_new_int ( ( int ) vrrp -> garp_refresh_rep ) ) ; json_object_object_add ( json_data , \"garp_lower_prio_delay\" , json_object_new_int ( ( int ) ( vrrp -> garp_lower_prio_delay / TIMER_HZ ) ) ) ; json_object_object_add ( json_data , \"garp_lower_prio_rep\" , json_object_new_int ( ( int ) vrrp -> garp_lower_prio_rep ) ) ; json_object_object_add ( json_data , \"lower_prio_no_advert\" , json_object_new_int ( ( int ) vrrp -> lower_prio_no_advert ) ) ; json_object_object_add ( json_data , \"higher_prio_send_advert\" , json_object_new_int ( ( int ) vrrp -> higher_prio_send_advert ) ) ; json_object_object_add ( json_data , \"vrid\" , json_object_new_int ( vrrp -> vrid ) ) ; json_object_object_add ( json_data , \"base_priority\" , json_object_new_int ( vrrp -> base_priority ) ) ; json_object_object_add ( json_data , \"effective_priority\" , json_object_new_int ( vrrp -> effective_priority ) ) ; json_object_object_add ( json_data , \"vipset\" , json_object_new_boolean ( vrrp -> vipset ) ) ; if ( ! LIST_ISEMPTY ( vrrp -> vip ) ) { for ( f = LIST_HEAD ( vrrp -> vip ) ; f ; ELEMENT_NEXT ( f ) ) { ip_address_t * vip = ELEMENT_DATA ( f ) ; char ipaddr [ INET6_ADDRSTRLEN ] ; inet_ntop ( vrrp -> family , & ( vip -> u . sin . sin_addr . s_addr ) , ipaddr , INET6_ADDRSTRLEN ) ; json_object_array_add ( vips , json_object_new_string ( ipaddr ) ) ; } } json_object_object_add ( json_data , \"vips\" , vips ) ; if ( ! LIST_ISEMPTY ( vrrp -> evip ) ) { for ( f = LIST_HEAD ( vrrp -> evip ) ; f ; ELEMENT_NEXT ( f ) ) { ip_address_t * evip = ELEMENT_DATA ( f ) ; char ipaddr [ INET6_ADDRSTRLEN ] ; inet_ntop ( vrrp -> family , & ( evip -> u . sin . sin_addr . s_addr ) , ipaddr , INET6_ADDRSTRLEN ) ; json_object_array_add ( evips , json_object_new_string ( ipaddr ) ) ; } } json_object_object_add ( json_data , \"evips\" , evips ) ; json_object_object_add ( json_data , \"promote_secondaries\" , json_object_new_boolean ( vrrp -> promote_secondaries ) ) ; # ifdef _HAVE_FIB_ROUTING_ if ( ! LIST_ISEMPTY ( vrrp -> vroutes ) ) { for ( f = LIST_HEAD ( vrrp -> vroutes ) ; f ; ELEMENT_NEXT ( f ) ) { ip_route_t * route = ELEMENT_DATA ( f ) ; char * buf = MALLOC ( ROUTE_BUF_SIZE ) ; format_iproute ( route , buf , ROUTE_BUF_SIZE ) ; json_object_array_add ( vroutes , json_object_new_string ( buf ) ) ; } } json_object_object_add ( json_data , \"vroutes\" , vroutes ) ; if ( ! LIST_ISEMPTY ( vrrp -> vrules ) ) { for ( f = LIST_HEAD ( vrrp -> vrules ) ; f ; ELEMENT_NEXT ( f ) ) { ip_rule_t * rule = ELEMENT_DATA ( f ) ; char * buf = MALLOC ( RULE_BUF_SIZE ) ; format_iprule ( rule , buf , RULE_BUF_SIZE ) ; json_object_array_add ( vrules , json_object_new_string ( buf ) ) ; } } json_object_object_add ( json_data , \"vrules\" , vrules ) ; # endif json_object_object_add ( json_data , \"adver_int\" , json_object_new_double ( vrrp -> adver_int / TIMER_HZ_FLOAT ) ) ; json_object_object_add ( json_data , \"master_adver_int\" , json_object_new_double ( vrrp -> master_adver_int / TIMER_HZ_FLOAT ) ) ; json_object_object_add ( json_data , \"accept\" , json_object_new_int ( ( int ) vrrp -> accept ) ) ; json_object_object_add ( json_data , \"nopreempt\" , json_object_new_boolean ( vrrp -> nopreempt ) ) ; json_object_object_add ( json_data , \"preempt_delay\" , json_object_new_int ( ( int ) ( vrrp -> preempt_delay / TIMER_HZ ) ) ) ; json_object_object_add ( json_data , \"state\" , json_object_new_int ( vrrp -> state ) ) ; json_object_object_add ( json_data , \"wantstate\" , json_object_new_int ( vrrp -> wantstate ) ) ; json_object_object_add ( json_data , \"version\" , json_object_new_int ( vrrp -> version ) ) ; if ( vrrp -> script_backup ) json_object_object_add ( json_data , \"script_backup\" , json_object_new_string ( cmd_str ( vrrp -> script_backup ) ) ) ; if ( vrrp -> script_master ) json_object_object_add ( json_data , \"script_master\" , json_object_new_string ( cmd_str ( vrrp -> script_master ) ) ) ; if ( vrrp -> script_fault ) json_object_object_add ( json_data , \"script_fault\" , json_object_new_string ( cmd_str ( vrrp -> script_fault ) ) ) ; if ( vrrp -> script_stop ) json_object_object_add ( json_data , \"script_stop\" , json_object_new_string ( cmd_str ( vrrp -> script_stop ) ) ) ; if ( vrrp -> script ) json_object_object_add ( json_data , \"script\" , json_object_new_string ( cmd_str ( vrrp -> script ) ) ) ; if ( vrrp -> script_master_rx_lower_pri ) json_object_object_add ( json_data , \"script_master_rx_lower_pri\" , json_object_new_string ( cmd_str ( vrrp -> script_master_rx_lower_pri ) ) ) ; json_object_object_add ( json_data , \"smtp_alert\" , json_object_new_boolean ( vrrp -> smtp_alert ) ) ; # ifdef _WITH_VRRP_AUTH_ if ( vrrp -> auth_type ) { json_object_object_add ( json_data , \"auth_type\" , json_object_new_int ( vrrp -> auth_type ) ) ; if ( vrrp -> auth_type != VRRP_AUTH_AH ) { char auth_data [ sizeof ( vrrp -> auth_data ) + 1 ] ; memcpy ( auth_data , vrrp -> auth_data , sizeof ( vrrp -> auth_data ) ) ; auth_data [ sizeof ( vrrp -> auth_data ) ] = '\\\\0' ; json_object_object_add ( json_data , \"auth_data\" , json_object_new_string ( auth_data ) ) ; } } else json_object_object_add ( json_data , \"auth_type\" , json_object_new_int ( 0 ) ) ; # endif json_object_object_add ( json_stats , \"advert_rcvd\" , json_object_new_int64 ( ( int64_t ) vrrp -> stats -> advert_rcvd ) ) ; json_object_object_add ( json_stats , \"advert_sent\" , json_object_new_int64 ( vrrp -> stats -> advert_sent ) ) ; json_object_object_add ( json_stats , \"become_master\" , json_object_new_int64 ( vrrp -> stats -> become_master ) ) ; json_object_object_add ( json_stats , \"release_master\" , json_object_new_int64 ( vrrp -> stats -> release_master ) ) ; json_object_object_add ( json_stats , \"packet_len_err\" , json_object_new_int64 ( ( int64_t ) vrrp -> stats -> packet_len_err ) ) ; json_object_object_add ( json_stats , \"advert_interval_err\" , json_object_new_int64 ( ( int64_t ) vrrp -> stats -> advert_interval_err ) ) ; json_object_object_add ( json_stats , \"ip_ttl_err\" , json_object_new_int64 ( ( int64_t ) vrrp -> stats -> ip_ttl_err ) ) ; json_object_object_add ( json_stats , \"invalid_type_rcvd\" , json_object_new_int64 ( ( int64_t ) vrrp -> stats -> invalid_type_rcvd ) ) ; json_object_object_add ( json_stats , \"addr_list_err\" , json_object_new_int64 ( ( int64_t ) vrrp -> stats -> addr_list_err ) ) ; json_object_object_add ( json_stats , \"invalid_authtype\" , json_object_new_int64 ( vrrp -> stats -> invalid_authtype ) ) ; # ifdef _WITH_VRRP_AUTH_ json_object_object_add ( json_stats , \"authtype_mismatch\" , json_object_new_int64 ( vrrp -> stats -> authtype_mismatch ) ) ; json_object_object_add ( json_stats , \"auth_failure\" , json_object_new_int64 ( vrrp -> stats -> auth_failure ) ) ; # endif json_object_object_add ( json_stats , \"pri_zero_rcvd\" , json_object_new_int64 ( ( int64_t ) vrrp -> stats -> pri_zero_rcvd ) ) ; json_object_object_add ( json_stats , \"pri_zero_sent\" , json_object_new_int64 ( ( int64_t ) vrrp -> stats -> pri_zero_sent ) ) ; json_object_object_add ( instance_json , \"data\" , json_data ) ; json_object_object_add ( instance_json , \"stats\" , json_stats ) ; json_object_array_add ( array , instance_json ) ; } fprintf ( file , \"%s\" , json_object_to_json_string ( array ) ) ; fclose ( file ) ; }\n","target":"<S2SV_ModStart> ; file = fopen_safe <S2SV_ModEnd> ( \"/tmp/keepalived.json\" ,\n","project_and_commit_id":"acassen@keepalived/04f2d32871bb3b11d7dc024039952f2fe2750306","cve_id":"CVE-2018-19044","original_address":"https://github.com/acassen/keepalived/commit/04f2d32871bb3b11d7dc024039952f2fe2750306","time":"2018-11-08T20:29Z"},
	{"Unnamed: 0":65,"cwe_id":"CWE-20","source":"CWE-20 int res_inverse ( vorbis_dsp_state * vd , vorbis_info_residue * info , ogg_int32_t * * in , int * nonzero , int ch ) { int i , j , k , s , used = 0 ; codec_setup_info * ci = ( codec_setup_info * ) vd -> vi -> codec_setup ; codebook * phrasebook = ci -> book_param + info -> groupbook ; int samples_per_partition = info -> grouping ; int partitions_per_word = phrasebook -> dim ; int pcmend = ci -> blocksizes [ vd -> W ] ; if ( info -> type < 2 ) { int max = pcmend >> 1 ; int end = ( info -> end < max ? info -> end : max ) ; int n = end - info -> begin ; if ( n > 0 ) { int partvals = n / samples_per_partition ; int partwords = ( partvals + partitions_per_word - 1 ) / partitions_per_word ; for ( i = 0 ; i < ch ; i ++ ) if ( nonzero [ i ] ) in [ used ++ ] = in [ i ] ; ch = used ; if ( used ) { char * * partword = ( char * * ) alloca ( ch * sizeof ( * partword ) ) ; for ( j = 0 ; j < ch ; j ++ ) partword [ j ] = ( char * ) alloca ( partwords * partitions_per_word * sizeof ( * partword [ j ] ) ) ; for ( s = 0 ; s < info -> stages ; s ++ ) { for ( i = 0 ; i < partvals ; ) { if ( s == 0 ) { partword [ 0 ] [ i + partitions_per_word - 1 ] = 1 ; for ( k = partitions_per_word - 2 ; k >= 0 ; k -- ) partword [ 0 ] [ i + k ] = partword [ 0 ] [ i + k + 1 ] * info -> partitions ; for ( j = 1 ; j < ch ; j ++ ) for ( k = partitions_per_word - 1 ; k >= 0 ; k -- ) partword [ j ] [ i + k ] = partword [ j - 1 ] [ i + k ] ; for ( j = 0 ; j < ch ; j ++ ) { int temp = vorbis_book_decode ( phrasebook , & vd -> opb ) ; if ( temp == - 1 ) goto eopbreak ; for ( k = 0 ; k < partitions_per_word ; k ++ ) { ogg_uint32_t div = partword [ j ] [ i + k ] ; partword [ j ] [ i + k ] = temp / div ; temp -= partword [ j ] [ i + k ] * div ; } } } for ( k = 0 ; k < partitions_per_word && i < partvals ; k ++ , i ++ ) for ( j = 0 ; j < ch ; j ++ ) { long offset = info -> begin + i * samples_per_partition ; <S2SV_StartBug> if ( info -> stagemasks [ ( int ) partword [ j ] [ i ] ] & ( 1 << s ) ) { <S2SV_EndBug> codebook * stagebook = ci -> book_param + info -> stagebooks [ ( partword [ j ] [ i ] << 3 ) + s ] ; if ( info -> type ) { if ( vorbis_book_decodev_add ( stagebook , in [ j ] + offset , & vd -> opb , samples_per_partition , - 8 ) == - 1 ) goto eopbreak ; } else { if ( vorbis_book_decodevs_add ( stagebook , in [ j ] + offset , & vd -> opb , samples_per_partition , - 8 ) == - 1 ) goto eopbreak ; } } } } } } } } else { int max = ( pcmend * ch ) >> 1 ; int end = ( info -> end < max ? info -> end : max ) ; int n = end - info -> begin ; if ( n > 0 ) { int partvals = n / samples_per_partition ; int partwords = ( partvals + partitions_per_word - 1 ) / partitions_per_word ; char * partword = ( char * ) alloca ( partwords * partitions_per_word * sizeof ( * partword ) ) ; int beginoff = info -> begin / ch ; for ( i = 0 ; i < ch ; i ++ ) if ( nonzero [ i ] ) break ; if ( i == ch ) return ( 0 ) ; samples_per_partition /= ch ; for ( s = 0 ; s < info -> stages ; s ++ ) { for ( i = 0 ; i < partvals ; ) { if ( s == 0 ) { int temp ; partword [ i + partitions_per_word - 1 ] = 1 ; for ( k = partitions_per_word - 2 ; k >= 0 ; k -- ) partword [ i + k ] = partword [ i + k + 1 ] * info -> partitions ; temp = vorbis_book_decode ( phrasebook , & vd -> opb ) ; if ( temp == - 1 ) goto eopbreak ; for ( k = 0 ; k < partitions_per_word ; k ++ ) { ogg_uint32_t div = partword [ i + k ] ; partword [ i + k ] = temp / div ; temp -= partword [ i + k ] * div ; } } for ( k = 0 ; k < partitions_per_word && i < partvals ; k ++ , i ++ ) if ( info -> stagemasks [ ( int ) partword [ i ] ] & ( 1 << s ) ) { codebook * stagebook = ci -> book_param + info -> stagebooks [ ( partword [ i ] << 3 ) + s ] ; if ( vorbis_book_decodevv_add ( stagebook , in , i * samples_per_partition + beginoff , ch , & vd -> opb , samples_per_partition , - 8 ) == - 1 ) goto eopbreak ; } } } } } eopbreak : return 0 ; }\n","target":"<S2SV_ModStart> * samples_per_partition ; int idx = ( int ) partword [ j ] [ i ] ; if ( idx < info -> partitions && <S2SV_ModEnd> info -> stagemasks <S2SV_ModStart> -> stagemasks [ idx <S2SV_ModEnd> ] & (\n","project_and_commit_id":"external@tremolo/659030a2e80c38fb8da0a4eb68695349eec6778b","cve_id":"CVE-2016-3756","original_address":"https://android.googlesource.com/platform/external/tremolo/+/659030a2e80c38fb8da0a4eb68695349eec6778b","time":"2016-07-11T01:59Z"},
	{"Unnamed: 0":2542,"cwe_id":"CWE-476","source":"CWE-476 static int nsv_read_chunk ( AVFormatContext * s , int fill_header ) { NSVContext * nsv = s -> priv_data ; AVIOContext * pb = s -> pb ; AVStream * st [ 2 ] = { NULL , NULL } ; NSVStream * nst ; AVPacket * pkt ; int i , err = 0 ; uint8_t auxcount ; uint32_t vsize ; uint16_t asize ; <S2SV_StartBug> uint16_t auxsize ; <S2SV_EndBug> if ( nsv -> ahead [ 0 ] . data || nsv -> ahead [ 1 ] . data ) return 0 ; null_chunk_retry : if ( pb -> eof_reached ) return - 1 ; for ( i = 0 ; i < NSV_MAX_RESYNC_TRIES && nsv -> state < NSV_FOUND_NSVS && ! err ; i ++ ) err = nsv_resync ( s ) ; if ( err < 0 ) return err ; if ( nsv -> state == NSV_FOUND_NSVS ) err = nsv_parse_NSVs_header ( s ) ; if ( err < 0 ) return err ; if ( nsv -> state != NSV_HAS_READ_NSVS && nsv -> state != NSV_FOUND_BEEF ) return - 1 ; auxcount = avio_r8 ( pb ) ; vsize = avio_rl16 ( pb ) ; asize = avio_rl16 ( pb ) ; vsize = ( vsize << 4 ) | ( auxcount >> 4 ) ; auxcount &= 0x0f ; av_log ( s , AV_LOG_TRACE , \"NSV<S2SV_blank>CHUNK<S2SV_blank>%\" PRIu8 \"<S2SV_blank>aux,<S2SV_blank>%\" PRIu32 \"<S2SV_blank>bytes<S2SV_blank>video,<S2SV_blank>%\" PRIu16 \"<S2SV_blank>bytes<S2SV_blank>audio\\\\n\" , auxcount , vsize , asize ) ; for ( i = 0 ; i < auxcount ; i ++ ) { uint32_t av_unused auxtag ; auxsize = avio_rl16 ( pb ) ; auxtag = avio_rl32 ( pb ) ; avio_skip ( pb , auxsize ) ; vsize -= auxsize + sizeof ( uint16_t ) + sizeof ( uint32_t ) ; } if ( pb -> eof_reached ) return - 1 ; if ( ! vsize && ! asize ) { nsv -> state = NSV_UNSYNC ; goto null_chunk_retry ; } if ( s -> nb_streams > 0 ) st [ s -> streams [ 0 ] -> id ] = s -> streams [ 0 ] ; if ( s -> nb_streams > 1 ) st [ s -> streams [ 1 ] -> id ] = s -> streams [ 1 ] ; if ( vsize && st [ NSV_ST_VIDEO ] ) { nst = st [ NSV_ST_VIDEO ] -> priv_data ; pkt = & nsv -> ahead [ NSV_ST_VIDEO ] ; <S2SV_StartBug> av_get_packet ( pb , pkt , vsize ) ; <S2SV_EndBug> pkt -> stream_index = st [ NSV_ST_VIDEO ] -> index ; pkt -> dts = nst -> frame_offset ; pkt -> flags |= nsv -> state == NSV_HAS_READ_NSVS ? AV_PKT_FLAG_KEY : 0 ; for ( i = 0 ; i < FFMIN ( 8 , vsize ) ; i ++ ) av_log ( s , AV_LOG_TRACE , \"NSV<S2SV_blank>video:<S2SV_blank>[%d]<S2SV_blank>=<S2SV_blank>%02\" PRIx8 \"\\\\n\" , i , pkt -> data [ i ] ) ; } if ( st [ NSV_ST_VIDEO ] ) ( ( NSVStream * ) st [ NSV_ST_VIDEO ] -> priv_data ) -> frame_offset ++ ; if ( asize && st [ NSV_ST_AUDIO ] ) { nst = st [ NSV_ST_AUDIO ] -> priv_data ; pkt = & nsv -> ahead [ NSV_ST_AUDIO ] ; if ( asize && st [ NSV_ST_AUDIO ] -> codecpar -> codec_tag == MKTAG ( 'P' , 'C' , 'M' , '<S2SV_blank>' ) ) { uint8_t bps ; uint8_t channels ; uint16_t samplerate ; bps = avio_r8 ( pb ) ; channels = avio_r8 ( pb ) ; samplerate = avio_rl16 ( pb ) ; if ( ! channels || ! samplerate ) return AVERROR_INVALIDDATA ; asize -= 4 ; av_log ( s , AV_LOG_TRACE , \"NSV<S2SV_blank>RAWAUDIO:<S2SV_blank>bps<S2SV_blank>%\" PRIu8 \",<S2SV_blank>nchan<S2SV_blank>%\" PRIu8 \",<S2SV_blank>srate<S2SV_blank>%\" PRIu16 \"\\\\n\" , bps , channels , samplerate ) ; if ( fill_header ) { st [ NSV_ST_AUDIO ] -> need_parsing = AVSTREAM_PARSE_NONE ; if ( bps != 16 ) { av_log ( s , AV_LOG_TRACE , \"NSV<S2SV_blank>AUDIO<S2SV_blank>bit/sample<S2SV_blank>!=<S2SV_blank>16<S2SV_blank>(%\" PRIu8 \")!!!\\\\n\" , bps ) ; } bps /= channels ; if ( bps == 8 ) st [ NSV_ST_AUDIO ] -> codecpar -> codec_id = AV_CODEC_ID_PCM_U8 ; samplerate /= 4 ; channels = 1 ; st [ NSV_ST_AUDIO ] -> codecpar -> channels = channels ; st [ NSV_ST_AUDIO ] -> codecpar -> sample_rate = samplerate ; av_log ( s , AV_LOG_TRACE , \"NSV<S2SV_blank>RAWAUDIO:<S2SV_blank>bps<S2SV_blank>%\" PRIu8 \",<S2SV_blank>nchan<S2SV_blank>%\" PRIu8 \",<S2SV_blank>srate<S2SV_blank>%\" PRIu16 \"\\\\n\" , bps , channels , samplerate ) ; } } <S2SV_StartBug> av_get_packet ( pb , pkt , asize ) ; <S2SV_EndBug> pkt -> stream_index = st [ NSV_ST_AUDIO ] -> index ; pkt -> flags |= nsv -> state == NSV_HAS_READ_NSVS ? AV_PKT_FLAG_KEY : 0 ; if ( nsv -> state == NSV_HAS_READ_NSVS && st [ NSV_ST_VIDEO ] ) { pkt -> dts = ( ( ( NSVStream * ) st [ NSV_ST_VIDEO ] -> priv_data ) -> frame_offset - 1 ) ; pkt -> dts *= ( int64_t ) 1000 * nsv -> framerate . den ; pkt -> dts += ( int64_t ) nsv -> avsync * nsv -> framerate . num ; av_log ( s , AV_LOG_TRACE , \"NSV<S2SV_blank>AUDIO:<S2SV_blank>sync:%\" PRId16 \",<S2SV_blank>dts:%\" PRId64 , nsv -> avsync , pkt -> dts ) ; } nst -> frame_offset ++ ; } nsv -> state = NSV_UNSYNC ; return 0 ; }\n","target":"<S2SV_ModStart> ; uint16_t auxsize ; int ret <S2SV_ModStart> NSV_ST_VIDEO ] ; if ( ( ret = <S2SV_ModStart> , vsize ) ) < 0 ) return ret <S2SV_ModStart> ; } } if ( ( ret = <S2SV_ModStart> , asize ) ) < 0 ) return ret\n","project_and_commit_id":"libav@libav/fe6eea99efac66839052af547426518efd970b24","cve_id":"CVE-2017-9051","original_address":"https://github.com/libav/libav/commit/fe6eea99efac66839052af547426518efd970b24","time":"2017-05-18T06:29Z"},
	{"Unnamed: 0":6676,"cwe_id":"CWE-125","source":"CWE-125 int obj2ast_comprehension ( PyObject * obj , comprehension_ty * out , PyArena * arena ) { PyObject * tmp = NULL ; expr_ty target ; expr_ty iter ; asdl_seq * ifs ; int is_async ; <S2SV_StartBug> if ( _PyObject_HasAttrId ( obj , & PyId_target ) ) { <S2SV_EndBug> int res ; tmp = _PyObject_GetAttrId ( obj , & PyId_target ) ; <S2SV_StartBug> if ( tmp == NULL ) goto failed ; <S2SV_EndBug> res = obj2ast_expr ( tmp , & target , arena ) ; if ( res != 0 ) goto failed ; Py_CLEAR ( tmp ) ; <S2SV_StartBug> } else { <S2SV_EndBug> PyErr_SetString ( PyExc_TypeError , \"required<S2SV_blank>field<S2SV_blank>\\\\\"target\\\\\"<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>comprehension\" ) ; return 1 ; } <S2SV_StartBug> if ( _PyObject_HasAttrId ( obj , & PyId_iter ) ) { <S2SV_EndBug> int res ; tmp = _PyObject_GetAttrId ( obj , & PyId_iter ) ; <S2SV_StartBug> if ( tmp == NULL ) goto failed ; <S2SV_EndBug> res = obj2ast_expr ( tmp , & iter , arena ) ; if ( res != 0 ) goto failed ; Py_CLEAR ( tmp ) ; <S2SV_StartBug> } else { <S2SV_EndBug> PyErr_SetString ( PyExc_TypeError , \"required<S2SV_blank>field<S2SV_blank>\\\\\"iter\\\\\"<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>comprehension\" ) ; return 1 ; } if ( _PyObject_HasAttrId ( obj , & PyId_ifs ) ) { int res ; Py_ssize_t len ; <S2SV_StartBug> Py_ssize_t i ; <S2SV_EndBug> tmp = _PyObject_GetAttrId ( obj , & PyId_ifs ) ; if ( tmp == NULL ) goto failed ; if ( ! PyList_Check ( tmp ) ) { PyErr_Format ( PyExc_TypeError , \"comprehension<S2SV_blank>field<S2SV_blank>\\\\\"ifs\\\\\"<S2SV_blank>must<S2SV_blank>be<S2SV_blank>a<S2SV_blank>list,<S2SV_blank>not<S2SV_blank>a<S2SV_blank>%.200s\" , tmp -> ob_type -> tp_name ) ; goto failed ; } len = PyList_GET_SIZE ( tmp ) ; ifs = _Ta3_asdl_seq_new ( len , arena ) ; if ( ifs == NULL ) goto failed ; for ( i = 0 ; i < len ; i ++ ) { <S2SV_StartBug> expr_ty value ; <S2SV_EndBug> <S2SV_StartBug> res = obj2ast_expr ( PyList_GET_ITEM ( tmp , i ) , & value , arena ) ; <S2SV_EndBug> if ( res != 0 ) goto failed ; if ( len != PyList_GET_SIZE ( tmp ) ) { PyErr_SetString ( PyExc_RuntimeError , \"comprehension<S2SV_blank>field<S2SV_blank>\\\\\"ifs\\\\\"<S2SV_blank>changed<S2SV_blank>size<S2SV_blank>during<S2SV_blank>iteration\" ) ; goto failed ; } <S2SV_StartBug> asdl_seq_SET ( ifs , i , value ) ; <S2SV_EndBug> } Py_CLEAR ( tmp ) ; <S2SV_StartBug> } else { <S2SV_EndBug> PyErr_SetString ( PyExc_TypeError , \"required<S2SV_blank>field<S2SV_blank>\\\\\"ifs\\\\\"<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>comprehension\" ) ; return 1 ; } <S2SV_StartBug> if ( _PyObject_HasAttrId ( obj , & PyId_is_async ) ) { <S2SV_EndBug> int res ; tmp = _PyObject_GetAttrId ( obj , & PyId_is_async ) ; <S2SV_StartBug> if ( tmp == NULL ) goto failed ; <S2SV_EndBug> res = obj2ast_int ( tmp , & is_async , arena ) ; if ( res != 0 ) goto failed ; <S2SV_StartBug> Py_CLEAR ( tmp ) ; <S2SV_EndBug> } else { PyErr_SetString ( PyExc_TypeError , \"required<S2SV_blank>field<S2SV_blank>\\\\\"is_async\\\\\"<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>comprehension\" ) ; return 1 ; } * out = comprehension ( target , iter , ifs , is_async , arena ) ; return 0 ; failed : Py_XDECREF ( tmp ) ; return 1 ; }\n","target":"<S2SV_ModStart> ; if ( lookup_attr_id <S2SV_ModEnd> ( obj , <S2SV_ModStart> , & PyId_target , & tmp ) < 0 ) { return 1 ; } <S2SV_ModEnd> if ( tmp <S2SV_ModStart> == NULL ) { PyErr_SetString ( PyExc_TypeError , \"required<S2SV_blank>field<S2SV_blank>\\\\\"target\\\\\"<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>comprehension\" ) ; return 1 ; } else { int res <S2SV_ModEnd> ; res = <S2SV_ModStart> ) ; } if ( lookup_attr_id <S2SV_ModEnd> ( obj , <S2SV_ModStart> , & PyId_iter , & tmp ) < 0 ) { return 1 ; } <S2SV_ModEnd> if ( tmp <S2SV_ModStart> == NULL ) { PyErr_SetString ( PyExc_TypeError , \"required<S2SV_blank>field<S2SV_blank>\\\\\"iter\\\\\"<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>comprehension\" ) ; return 1 ; } else { int res <S2SV_ModEnd> ; res = <S2SV_ModStart> ) ; } if ( lookup_attr_id ( obj , & PyId_ifs , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , \"required<S2SV_blank>field<S2SV_blank>\\\\\"ifs\\\\\"<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>comprehension\" ) ; return 1 ; } else <S2SV_ModEnd> { int res <S2SV_ModStart> ; Py_ssize_t i <S2SV_ModEnd> ; if ( <S2SV_ModStart> ) { expr_ty val <S2SV_ModEnd> ; res = <S2SV_ModStart> ) , & val <S2SV_ModEnd> , arena ) <S2SV_ModStart> , i , val <S2SV_ModEnd> ) ; } <S2SV_ModStart> ) ; } if ( lookup_attr_id <S2SV_ModEnd> ( obj , <S2SV_ModStart> , & PyId_is_async , & tmp ) < 0 ) { return 1 ; } <S2SV_ModEnd> if ( tmp <S2SV_ModStart> == NULL ) { PyErr_SetString ( PyExc_TypeError , \"required<S2SV_blank>field<S2SV_blank>\\\\\"is_async\\\\\"<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>comprehension\" ) ; return 1 ; } else { int res <S2SV_ModEnd> ; res = <S2SV_ModStart> ( tmp ) <S2SV_ModEnd> ; } *\n","project_and_commit_id":"python@typed_ast/156afcb26c198e162504a57caddfe0acd9ed7dce","cve_id":"CVE-2019-19275","original_address":"https://github.com/python/typed_ast/commit/156afcb26c198e162504a57caddfe0acd9ed7dce","time":"2019-11-26T15:15Z"},
	{"Unnamed: 0":214,"cwe_id":"CWE-787","source":"CWE-787 static char * get_object ( FILE * fp , int obj_id , const xref_t * xref , size_t * size , int * is_stream ) { static const int blk_sz = 256 ; int i , total_sz , read_sz , n_blks , search , stream ; size_t obj_sz ; char * c , * data ; long start ; const xref_entry_t * entry ; if ( size ) * size = 0 ; if ( is_stream ) * is_stream = 0 ; start = ftell ( fp ) ; entry = NULL ; for ( i = 0 ; i < xref -> n_entries ; i ++ ) if ( xref -> entries [ i ] . obj_id == obj_id ) { entry = & xref -> entries [ i ] ; break ; } if ( ! entry ) return NULL ; fseek ( fp , entry -> offset , SEEK_SET ) ; obj_sz = 0 ; total_sz = 0 ; n_blks = 1 ; <S2SV_StartBug> data = malloc ( blk_sz * n_blks ) ; <S2SV_EndBug> memset ( data , 0 , blk_sz * n_blks ) ; stream = 0 ; while ( ( read_sz = fread ( data + total_sz , 1 , blk_sz - 1 , fp ) ) && ! ferror ( fp ) ) { total_sz += read_sz ; * ( data + total_sz ) = '\\\\0' ; if ( total_sz + blk_sz >= ( blk_sz * n_blks ) ) data = realloc ( data , blk_sz * ( ++ n_blks ) ) ; search = total_sz - read_sz ; if ( search < 0 ) search = 0 ; if ( ( c = strstr ( data + search , \"endobj\" ) ) ) { * ( c + strlen ( \"endobj\" ) + 1 ) = '\\\\0' ; obj_sz = ( void * ) strstr ( data + search , \"endobj\" ) - ( void * ) data ; obj_sz += strlen ( \"endobj\" ) + 1 ; break ; } else if ( strstr ( data , \"stream\" ) ) stream = 1 ; } clearerr ( fp ) ; fseek ( fp , start , SEEK_SET ) ; if ( size ) * size = obj_sz ; if ( is_stream ) * is_stream = stream ; return data ; }\n","target":"<S2SV_ModStart> ; data = safe_calloc ( <S2SV_ModEnd> blk_sz * n_blks\n","project_and_commit_id":"enferex@pdfresurrect/0c4120fffa3dffe97b95c486a120eded82afe8a6","cve_id":"CVE-2019-14934","original_address":"https://github.com/enferex/pdfresurrect/commit/0c4120fffa3dffe97b95c486a120eded82afe8a6","time":"2019-08-11T22:15Z"},
	{"Unnamed: 0":6722,"cwe_id":"CWE-415","source":"CWE-415 int read_file ( struct sc_card * card , char * str_path , unsigned char * * data , size_t * data_len ) { struct sc_path path ; struct sc_file * file ; unsigned char * p ; int ok = 0 ; int r ; size_t len ; sc_format_path ( str_path , & path ) ; if ( SC_SUCCESS != sc_select_file ( card , & path , & file ) ) { goto err ; } <S2SV_StartBug> len = file ? file -> size : 4096 ; <S2SV_EndBug> p = realloc ( * data , len ) ; if ( ! p ) { goto err ; } * data = p ; * data_len = len ; r = sc_read_binary ( card , 0 , p , len , 0 ) ; if ( r < 0 ) goto err ; * data_len = r ; ok = 1 ; err : sc_file_free ( file ) ; return ok ; }\n","target":"<S2SV_ModStart> len = file && file -> size > 0\n","project_and_commit_id":"OpenSC@OpenSC/360e95d45ac4123255a4c796db96337f332160ad","cve_id":"CVE-2018-16425","original_address":"https://github.com/OpenSC/OpenSC/commit/360e95d45ac4123255a4c796db96337f332160ad","time":"2018-09-04T00:29Z"},
	{"Unnamed: 0":4558,"cwe_id":"CWE-787","source":"CWE-787 int mp4client_main ( int argc , char * * argv ) { char c ; const char * str ; int ret_val = 0 ; u32 i , times [ 100 ] , nb_times , dump_mode ; u32 simulation_time_in_ms = 0 ; u32 initial_service_id = 0 ; Bool auto_exit = GF_FALSE ; Bool logs_set = GF_FALSE ; Bool start_fs = GF_FALSE ; Bool use_rtix = GF_FALSE ; Bool pause_at_first = GF_FALSE ; Bool no_cfg_save = GF_FALSE ; Bool is_cfg_only = GF_FALSE ; Double play_from = 0 ; # ifdef GPAC_MEMORY_TRACKING GF_MemTrackerType mem_track = GF_MemTrackerNone ; # endif Double fps = GF_IMPORT_DEFAULT_FPS ; Bool fill_ar , visible , do_uncache , has_command ; char * url_arg , * out_arg , * the_cfg , * rti_file , * views , * mosaic ; FILE * logfile = NULL ; Float scale = 1 ; # ifndef WIN32 dlopen ( NULL , RTLD_NOW | RTLD_GLOBAL ) ; # endif strcpy ( the_url , \".\" ) ; memset ( & user , 0 , sizeof ( GF_User ) ) ; dump_mode = DUMP_NONE ; fill_ar = visible = do_uncache = has_command = GF_FALSE ; url_arg = out_arg = the_cfg = rti_file = views = mosaic = NULL ; nb_times = 0 ; times [ 0 ] = 0 ; for ( i = 1 ; i < ( u32 ) argc ; i ++ ) { char * arg = argv [ i ] ; if ( ! strcmp ( arg , \"-c\" ) || ! strcmp ( arg , \"-cfg\" ) ) { the_cfg = argv [ i + 1 ] ; i ++ ; } else if ( ! strcmp ( arg , \"-mem-track\" ) || ! strcmp ( arg , \"-mem-track-stack\" ) ) { # ifdef GPAC_MEMORY_TRACKING mem_track = ! strcmp ( arg , \"-mem-track-stack\" ) ? GF_MemTrackerBackTrace : GF_MemTrackerSimple ; # else fprintf ( stderr , \"WARNING<S2SV_blank>-<S2SV_blank>GPAC<S2SV_blank>not<S2SV_blank>compiled<S2SV_blank>with<S2SV_blank>Memory<S2SV_blank>Tracker<S2SV_blank>-<S2SV_blank>ignoring<S2SV_blank>\\\\\"%s\\\\\"\\\\n\" , arg ) ; # endif } else if ( ! strcmp ( arg , \"-gui\" ) ) { gui_mode = 1 ; } else if ( ! strcmp ( arg , \"-guid\" ) ) { gui_mode = 2 ; } else if ( ! strcmp ( arg , \"-h\" ) || ! strcmp ( arg , \"-help\" ) ) { PrintUsage ( ) ; return 0 ; } } # ifdef GPAC_MEMORY_TRACKING gf_sys_init ( mem_track ) ; # else gf_sys_init ( GF_MemTrackerNone ) ; # endif gf_sys_set_args ( argc , ( const char * * ) argv ) ; cfg_file = gf_cfg_init ( the_cfg , NULL ) ; if ( ! cfg_file ) { fprintf ( stderr , \"Error:<S2SV_blank>Configuration<S2SV_blank>File<S2SV_blank>not<S2SV_blank>found\\\\n\" ) ; return 1 ; } if ( gf_log_set_tools_levels ( gf_cfg_get_key ( cfg_file , \"General\" , \"Logs\" ) ) != GF_OK ) { return 1 ; } if ( gf_cfg_get_key ( cfg_file , \"General\" , \"Logs\" ) != NULL ) { logs_set = GF_TRUE ; } if ( ! gui_mode ) { str = gf_cfg_get_key ( cfg_file , \"General\" , \"ForceGUI\" ) ; if ( str && ! strcmp ( str , \"yes\" ) ) gui_mode = 1 ; } for ( i = 1 ; i < ( u32 ) argc ; i ++ ) { char * arg = argv [ i ] ; if ( ! strcmp ( arg , \"-rti\" ) ) { rti_file = argv [ i + 1 ] ; i ++ ; } else if ( ! strcmp ( arg , \"-rtix\" ) ) { rti_file = argv [ i + 1 ] ; i ++ ; use_rtix = GF_TRUE ; } else if ( ! stricmp ( arg , \"-size\" ) ) { if ( sscanf ( argv [ i + 1 ] , \"%dx%d\" , & forced_width , & forced_height ) != 2 ) { forced_width = forced_height = 0 ; } i ++ ; } else if ( ! strcmp ( arg , \"-quiet\" ) ) { be_quiet = 1 ; } else if ( ! strcmp ( arg , \"-strict-error\" ) ) { gf_log_set_strict_error ( 1 ) ; } else if ( ! strcmp ( arg , \"-log-file\" ) || ! strcmp ( arg , \"-lf\" ) ) { logfile = gf_fopen ( argv [ i + 1 ] , \"wt\" ) ; gf_log_set_callback ( logfile , on_gpac_log ) ; i ++ ; } else if ( ! strcmp ( arg , \"-logs\" ) ) { if ( gf_log_set_tools_levels ( argv [ i + 1 ] ) != GF_OK ) { return 1 ; } logs_set = GF_TRUE ; i ++ ; } else if ( ! strcmp ( arg , \"-log-clock\" ) || ! strcmp ( arg , \"-lc\" ) ) { log_time_start = 1 ; } else if ( ! strcmp ( arg , \"-log-utc\" ) || ! strcmp ( arg , \"-lu\" ) ) { log_utc_time = 1 ; } # if defined ( __DARWIN__ ) || defined ( __APPLE__ ) else if ( ! strcmp ( arg , \"-thread\" ) ) threading_flags = 0 ; # else else if ( ! strcmp ( arg , \"-no-thread\" ) ) threading_flags = GF_TERM_NO_DECODER_THREAD | GF_TERM_NO_COMPOSITOR_THREAD | GF_TERM_WINDOW_NO_THREAD ; # endif else if ( ! strcmp ( arg , \"-no-cthread\" ) || ! strcmp ( arg , \"-no-compositor-thread\" ) ) threading_flags |= GF_TERM_NO_COMPOSITOR_THREAD ; else if ( ! strcmp ( arg , \"-no-audio\" ) ) no_audio = 1 ; else if ( ! strcmp ( arg , \"-no-regulation\" ) ) no_regulation = 1 ; else if ( ! strcmp ( arg , \"-fs\" ) ) start_fs = 1 ; else if ( ! strcmp ( arg , \"-opt\" ) ) { set_cfg_option ( argv [ i + 1 ] ) ; i ++ ; } else if ( ! strcmp ( arg , \"-conf\" ) ) { set_cfg_option ( argv [ i + 1 ] ) ; is_cfg_only = GF_TRUE ; i ++ ; } else if ( ! strcmp ( arg , \"-ifce\" ) ) { gf_cfg_set_key ( cfg_file , \"Network\" , \"DefaultMCastInterface\" , argv [ i + 1 ] ) ; i ++ ; } else if ( ! stricmp ( arg , \"-help\" ) ) { PrintUsage ( ) ; return 1 ; } else if ( ! stricmp ( arg , \"-noprog\" ) ) { no_prog = 1 ; gf_set_progress_callback ( NULL , progress_quiet ) ; } else if ( ! stricmp ( arg , \"-no-save\" ) || ! stricmp ( arg , \"--no-save\" ) ) { no_cfg_save = 1 ; } else if ( ! stricmp ( arg , \"-ntp-shift\" ) ) { s32 shift = atoi ( argv [ i + 1 ] ) ; i ++ ; gf_net_set_ntp_shift ( shift ) ; } else if ( ! stricmp ( arg , \"-run-for\" ) ) { simulation_time_in_ms = atoi ( argv [ i + 1 ] ) * 1000 ; if ( ! simulation_time_in_ms ) simulation_time_in_ms = 1 ; i ++ ; } else if ( ! strcmp ( arg , \"-out\" ) ) { out_arg = argv [ i + 1 ] ; i ++ ; } else if ( ! stricmp ( arg , \"-fps\" ) ) { fps = atof ( argv [ i + 1 ] ) ; i ++ ; } else if ( ! strcmp ( arg , \"-avi\" ) || ! strcmp ( arg , \"-sha\" ) ) { dump_mode &= 0xFFFF0000 ; if ( ! strcmp ( arg , \"-sha\" ) ) dump_mode |= DUMP_SHA1 ; else dump_mode |= DUMP_AVI ; if ( ( url_arg || ( i + 2 < ( u32 ) argc ) ) && get_time_list ( argv [ i + 1 ] , times , & nb_times ) ) { if ( ! strcmp ( arg , \"-avi\" ) && ( nb_times != 2 ) ) { fprintf ( stderr , \"Only<S2SV_blank>one<S2SV_blank>time<S2SV_blank>arg<S2SV_blank>found<S2SV_blank>for<S2SV_blank>-avi<S2SV_blank>-<S2SV_blank>check<S2SV_blank>usage\\\\n\" ) ; return 1 ; } i ++ ; } } else if ( ! strcmp ( arg , \"-rgbds\" ) ) { dump_mode |= DUMP_RGB_DEPTH_SHAPE ; } else if ( ! strcmp ( arg , \"-rgbd\" ) ) { dump_mode |= DUMP_RGB_DEPTH ; } else if ( ! strcmp ( arg , \"-depth\" ) ) { dump_mode |= DUMP_DEPTH_ONLY ; } else if ( ! strcmp ( arg , \"-bmp\" ) ) { dump_mode &= 0xFFFF0000 ; dump_mode |= DUMP_BMP ; if ( ( url_arg || ( i + 2 < ( u32 ) argc ) ) && get_time_list ( argv [ i + 1 ] , times , & nb_times ) ) i ++ ; } else if ( ! strcmp ( arg , \"-png\" ) ) { dump_mode &= 0xFFFF0000 ; dump_mode |= DUMP_PNG ; if ( ( url_arg || ( i + 2 < ( u32 ) argc ) ) && get_time_list ( argv [ i + 1 ] , times , & nb_times ) ) i ++ ; } else if ( ! strcmp ( arg , \"-raw\" ) ) { dump_mode &= 0xFFFF0000 ; dump_mode |= DUMP_RAW ; if ( ( url_arg || ( i + 2 < ( u32 ) argc ) ) && get_time_list ( argv [ i + 1 ] , times , & nb_times ) ) i ++ ; } else if ( ! stricmp ( arg , \"-scale\" ) ) { sscanf ( argv [ i + 1 ] , \"%f\" , & scale ) ; i ++ ; } else if ( ! strcmp ( arg , \"-c\" ) || ! strcmp ( arg , \"-cfg\" ) ) { i ++ ; } if ( ! gui_mode ) { if ( arg [ 0 ] != '-' ) { if ( url_arg ) { fprintf ( stderr , \"Several<S2SV_blank>input<S2SV_blank>URLs<S2SV_blank>provided<S2SV_blank>(\\\\\"%s\\\\\",<S2SV_blank>\\\\\"%s\\\\\").<S2SV_blank>Check<S2SV_blank>your<S2SV_blank>command-line.\\\\n\" , url_arg , arg ) ; return 1 ; } url_arg = arg ; } else if ( ! strcmp ( arg , \"-loop\" ) ) loop_at_end = 1 ; else if ( ! strcmp ( arg , \"-bench\" ) ) bench_mode = 1 ; else if ( ! strcmp ( arg , \"-vbench\" ) ) bench_mode = 2 ; else if ( ! strcmp ( arg , \"-sbench\" ) ) bench_mode = 3 ; else if ( ! strcmp ( arg , \"-no-addon\" ) ) enable_add_ons = GF_FALSE ; else if ( ! strcmp ( arg , \"-pause\" ) ) pause_at_first = 1 ; else if ( ! strcmp ( arg , \"-play-from\" ) ) { play_from = atof ( ( const char * ) argv [ i + 1 ] ) ; i ++ ; } else if ( ! strcmp ( arg , \"-speed\" ) ) { playback_speed = FLT2FIX ( atof ( ( const char * ) argv [ i + 1 ] ) ) ; if ( playback_speed <= 0 ) playback_speed = FIX_ONE ; i ++ ; } else if ( ! strcmp ( arg , \"-no-wnd\" ) ) user . init_flags |= GF_TERM_WINDOWLESS ; else if ( ! strcmp ( arg , \"-no-back\" ) ) user . init_flags |= GF_TERM_WINDOW_TRANSPARENT ; else if ( ! strcmp ( arg , \"-align\" ) ) { if ( argv [ i + 1 ] [ 0 ] == 'm' ) align_mode = 1 ; else if ( argv [ i + 1 ] [ 0 ] == 'b' ) align_mode = 2 ; align_mode <<= 8 ; if ( argv [ i + 1 ] [ 1 ] == 'm' ) align_mode |= 1 ; else if ( argv [ i + 1 ] [ 1 ] == 'r' ) align_mode |= 2 ; i ++ ; } else if ( ! strcmp ( arg , \"-fill\" ) ) { fill_ar = GF_TRUE ; } else if ( ! strcmp ( arg , \"-show\" ) ) { visible = 1 ; } else if ( ! strcmp ( arg , \"-uncache\" ) ) { do_uncache = GF_TRUE ; } else if ( ! strcmp ( arg , \"-exit\" ) ) auto_exit = GF_TRUE ; else if ( ! stricmp ( arg , \"-views\" ) ) { views = argv [ i + 1 ] ; i ++ ; } else if ( ! stricmp ( arg , \"-mosaic\" ) ) { mosaic = argv [ i + 1 ] ; i ++ ; } else if ( ! stricmp ( arg , \"-com\" ) ) { has_command = GF_TRUE ; i ++ ; } else if ( ! stricmp ( arg , \"-service\" ) ) { initial_service_id = atoi ( argv [ i + 1 ] ) ; i ++ ; } } } if ( is_cfg_only ) { gf_cfg_del ( cfg_file ) ; fprintf ( stderr , \"GPAC<S2SV_blank>Config<S2SV_blank>updated\\\\n\" ) ; return 0 ; } if ( do_uncache ) { const char * cache_dir = gf_cfg_get_key ( cfg_file , \"General\" , \"CacheDirectory\" ) ; do_flatten_cache ( cache_dir ) ; fprintf ( stderr , \"GPAC<S2SV_blank>Cache<S2SV_blank>dir<S2SV_blank>%s<S2SV_blank>flattened\\\\n\" , cache_dir ) ; gf_cfg_del ( cfg_file ) ; return 0 ; } if ( dump_mode && ! url_arg ) { FILE * test ; url_arg = ( char * ) gf_cfg_get_key ( cfg_file , \"General\" , \"StartupFile\" ) ; test = url_arg ? gf_fopen ( url_arg , \"rt\" ) : NULL ; if ( ! test ) url_arg = NULL ; else gf_fclose ( test ) ; if ( ! url_arg ) { fprintf ( stderr , \"Missing<S2SV_blank>argument<S2SV_blank>for<S2SV_blank>dump\\\\n\" ) ; PrintUsage ( ) ; if ( logfile ) gf_fclose ( logfile ) ; return 1 ; } } if ( ! gui_mode && ! url_arg && ( gf_cfg_get_key ( cfg_file , \"General\" , \"StartupFile\" ) != NULL ) ) { gui_mode = 1 ; } # ifdef WIN32 if ( gui_mode == 1 ) { const char * opt ; TCHAR buffer [ 1024 ] ; DWORD res = GetCurrentDirectory ( 1024 , buffer ) ; buffer [ res ] = 0 ; opt = gf_cfg_get_key ( cfg_file , \"General\" , \"ModulesDirectory\" ) ; if ( strstr ( opt , buffer ) ) { gui_mode = 1 ; } else { gui_mode = 2 ; } } # endif if ( gui_mode == 1 ) { hide_shell ( 1 ) ; } if ( gui_mode ) { no_prog = 1 ; gf_set_progress_callback ( NULL , progress_quiet ) ; } if ( ! url_arg && simulation_time_in_ms ) simulation_time_in_ms += gf_sys_clock ( ) ; # if defined ( __DARWIN__ ) || defined ( __APPLE__ ) carbon_init ( ) ; # endif if ( dump_mode ) rti_file = NULL ; if ( ! logs_set ) { gf_log_set_tool_level ( GF_LOG_ALL , GF_LOG_WARNING ) ; } if ( rti_file || logfile || log_utc_time || log_time_start ) gf_log_set_callback ( NULL , on_gpac_log ) ; if ( rti_file ) init_rti_logs ( rti_file , url_arg , use_rtix ) ; { GF_SystemRTInfo rti ; if ( gf_sys_get_rti ( 0 , & rti , 0 ) ) fprintf ( stderr , \"System<S2SV_blank>info:<S2SV_blank>%d<S2SV_blank>MB<S2SV_blank>RAM<S2SV_blank>-<S2SV_blank>%d<S2SV_blank>cores\\\\n\" , ( u32 ) ( rti . physical_memory / 1024 / 1024 ) , rti . nb_cores ) ; } if ( dump_mode ) { user . init_flags |= GF_TERM_NO_DECODER_THREAD | GF_TERM_NO_COMPOSITOR_THREAD | GF_TERM_NO_REGULATION ; if ( ! visible ) user . init_flags |= GF_TERM_INIT_HIDE ; gf_cfg_set_key ( cfg_file , \"Audio\" , \"DriverName\" , \"Raw<S2SV_blank>Audio<S2SV_blank>Output\" ) ; no_cfg_save = GF_TRUE ; } else { init_w = forced_width ; init_h = forced_height ; } user . modules = gf_modules_new ( NULL , cfg_file ) ; if ( user . modules ) i = gf_modules_get_count ( user . modules ) ; if ( ! i || ! user . modules ) { fprintf ( stderr , \"Error:<S2SV_blank>no<S2SV_blank>modules<S2SV_blank>found<S2SV_blank>-<S2SV_blank>exiting\\\\n\" ) ; if ( user . modules ) gf_modules_del ( user . modules ) ; gf_cfg_del ( cfg_file ) ; gf_sys_close ( ) ; if ( logfile ) gf_fclose ( logfile ) ; return 1 ; } fprintf ( stderr , \"Modules<S2SV_blank>Found<S2SV_blank>:<S2SV_blank>%d<S2SV_blank>\\\\n\" , i ) ; str = gf_cfg_get_key ( cfg_file , \"General\" , \"GPACVersion\" ) ; if ( ! str || strcmp ( str , GPAC_FULL_VERSION ) ) { gf_cfg_del_section ( cfg_file , \"PluginsCache\" ) ; gf_cfg_set_key ( cfg_file , \"General\" , \"GPACVersion\" , GPAC_FULL_VERSION ) ; } user . config = cfg_file ; user . EventProc = GPAC_EventProc ; user . opaque = user . modules ; if ( threading_flags ) user . init_flags |= threading_flags ; if ( no_audio ) user . init_flags |= GF_TERM_NO_AUDIO ; if ( no_regulation ) user . init_flags |= GF_TERM_NO_REGULATION ; if ( threading_flags & ( GF_TERM_NO_DECODER_THREAD | GF_TERM_NO_COMPOSITOR_THREAD ) ) term_step = GF_TRUE ; if ( dump_mode ) user . init_flags |= GF_TERM_USE_AUDIO_HW_CLOCK ; if ( bench_mode ) { gf_cfg_discard_changes ( user . config ) ; auto_exit = GF_TRUE ; gf_cfg_set_key ( user . config , \"Audio\" , \"DriverName\" , \"Raw<S2SV_blank>Audio<S2SV_blank>Output\" ) ; if ( bench_mode != 2 ) { gf_cfg_set_key ( user . config , \"Video\" , \"DriverName\" , \"Raw<S2SV_blank>Video<S2SV_blank>Output\" ) ; gf_cfg_set_key ( user . config , \"RAWVideo\" , \"RawOutput\" , \"null\" ) ; gf_cfg_set_key ( user . config , \"Compositor\" , \"OpenGLMode\" , \"disable\" ) ; } else { gf_cfg_set_key ( user . config , \"Video\" , \"DisableVSync\" , \"yes\" ) ; } } { char dim [ 50 ] ; sprintf ( dim , \"%d\" , forced_width ) ; gf_cfg_set_key ( user . config , \"Compositor\" , \"DefaultWidth\" , forced_width ? dim : NULL ) ; sprintf ( dim , \"%d\" , forced_height ) ; gf_cfg_set_key ( user . config , \"Compositor\" , \"DefaultHeight\" , forced_height ? dim : NULL ) ; } fprintf ( stderr , \"Loading<S2SV_blank>GPAC<S2SV_blank>Terminal\\\\n\" ) ; i = gf_sys_clock ( ) ; term = gf_term_new ( & user ) ; if ( ! term ) { fprintf ( stderr , \"\\\\nInit<S2SV_blank>error<S2SV_blank>-<S2SV_blank>check<S2SV_blank>you<S2SV_blank>have<S2SV_blank>at<S2SV_blank>least<S2SV_blank>one<S2SV_blank>video<S2SV_blank>out<S2SV_blank>and<S2SV_blank>one<S2SV_blank>rasterizer...\\\\nFound<S2SV_blank>modules:\\\\n\" ) ; list_modules ( user . modules ) ; gf_modules_del ( user . modules ) ; gf_cfg_discard_changes ( cfg_file ) ; gf_cfg_del ( cfg_file ) ; gf_sys_close ( ) ; if ( logfile ) gf_fclose ( logfile ) ; return 1 ; } fprintf ( stderr , \"Terminal<S2SV_blank>Loaded<S2SV_blank>in<S2SV_blank>%d<S2SV_blank>ms\\\\n\" , gf_sys_clock ( ) - i ) ; if ( bench_mode ) { display_rti = 2 ; gf_term_set_option ( term , GF_OPT_VIDEO_BENCH , ( bench_mode == 3 ) ? 2 : 1 ) ; if ( bench_mode == 1 ) bench_mode = 2 ; } if ( dump_mode ) { if ( fill_ar ) gf_term_set_option ( term , GF_OPT_ASPECT_RATIO , GF_ASPECT_RATIO_FILL_SCREEN ) ; } else { str = gf_cfg_get_key ( cfg_file , \"Video\" , \"DriverName\" ) ; if ( ! bench_mode && ! strcmp ( str , \"Raw<S2SV_blank>Video<S2SV_blank>Output\" ) ) fprintf ( stderr , \"WARNING:<S2SV_blank>using<S2SV_blank>raw<S2SV_blank>output<S2SV_blank>video<S2SV_blank>(memory<S2SV_blank>only)<S2SV_blank>-<S2SV_blank>no<S2SV_blank>display<S2SV_blank>used\\\\n\" ) ; str = gf_cfg_get_key ( cfg_file , \"Audio\" , \"DriverName\" ) ; if ( ! str || ! strcmp ( str , \"No<S2SV_blank>Audio<S2SV_blank>Output<S2SV_blank>Available\" ) ) fprintf ( stderr , \"WARNING:<S2SV_blank>no<S2SV_blank>audio<S2SV_blank>output<S2SV_blank>available<S2SV_blank>-<S2SV_blank>make<S2SV_blank>sure<S2SV_blank>no<S2SV_blank>other<S2SV_blank>program<S2SV_blank>is<S2SV_blank>locking<S2SV_blank>the<S2SV_blank>sound<S2SV_blank>card\\\\n\" ) ; str = gf_cfg_get_key ( cfg_file , \"General\" , \"NoMIMETypeFetch\" ) ; no_mime_check = ( str && ! stricmp ( str , \"yes\" ) ) ? 1 : 0 ; } str = gf_cfg_get_key ( cfg_file , \"HTTPProxy\" , \"Enabled\" ) ; if ( str && ! strcmp ( str , \"yes\" ) ) { str = gf_cfg_get_key ( cfg_file , \"HTTPProxy\" , \"Name\" ) ; if ( str ) fprintf ( stderr , \"HTTP<S2SV_blank>Proxy<S2SV_blank>%s<S2SV_blank>enabled\\\\n\" , str ) ; } if ( rti_file ) { str = gf_cfg_get_key ( cfg_file , \"General\" , \"RTIRefreshPeriod\" ) ; if ( str ) { rti_update_time_ms = atoi ( str ) ; } else { gf_cfg_set_key ( cfg_file , \"General\" , \"RTIRefreshPeriod\" , \"200\" ) ; } UpdateRTInfo ( \"At<S2SV_blank>GPAC<S2SV_blank>load<S2SV_blank>time\\\\n\" ) ; } Run = 1 ; if ( dump_mode ) { if ( ! nb_times ) { times [ 0 ] = 0 ; nb_times ++ ; } ret_val = dump_file ( url_arg , out_arg , dump_mode , fps , forced_width , forced_height , scale , times , nb_times ) ; Run = 0 ; } else if ( views ) { } else if ( ! gui_mode && url_arg ) { char * ext ; if ( strlen ( url_arg ) >= sizeof ( the_url ) ) { fprintf ( stderr , \"Input<S2SV_blank>url<S2SV_blank>%s<S2SV_blank>is<S2SV_blank>too<S2SV_blank>long,<S2SV_blank>truncating<S2SV_blank>to<S2SV_blank>%d<S2SV_blank>chars.\\\\n\" , url_arg , ( int ) ( sizeof ( the_url ) - 1 ) ) ; strncpy ( the_url , url_arg , sizeof ( the_url ) - 1 ) ; the_url [ sizeof ( the_url ) - 1 ] = 0 ; } else { strcpy ( the_url , url_arg ) ; } ext = strrchr ( the_url , '.' ) ; if ( ext && ( ! stricmp ( ext , \".m3u\" ) || ! stricmp ( ext , \".pls\" ) ) ) { GF_Err e = GF_OK ; fprintf ( stderr , \"Opening<S2SV_blank>Playlist<S2SV_blank>%s\\\\n\" , the_url ) ; strcpy ( pl_path , the_url ) ; if ( ! strncmp ( \"http:\" , the_url , 5 ) ) { GF_DownloadSession * sess = gf_dm_sess_new ( term -> downloader , the_url , GF_NETIO_SESSION_NOT_THREADED , NULL , NULL , & e ) ; if ( sess ) { e = gf_dm_sess_process ( sess ) ; if ( ! e ) { strncpy ( the_url , gf_dm_sess_get_cache_name ( sess ) , sizeof ( the_url ) - 1 ) ; <S2SV_StartBug> the_url [ sizeof ( the_cfg ) - 1 ] = 0 ; <S2SV_EndBug> } gf_dm_sess_del ( sess ) ; } } playlist = e ? NULL : gf_fopen ( the_url , \"rt\" ) ; readonly_playlist = 1 ; if ( playlist ) { request_next_playlist_item = GF_TRUE ; } else { if ( e ) fprintf ( stderr , \"Failed<S2SV_blank>to<S2SV_blank>open<S2SV_blank>playlist<S2SV_blank>%s:<S2SV_blank>%s\\\\n\" , the_url , gf_error_to_string ( e ) ) ; fprintf ( stderr , \"Hit<S2SV_blank>\\'h\\'<S2SV_blank>for<S2SV_blank>help\\\\n\\\\n\" ) ; } } else { fprintf ( stderr , \"Opening<S2SV_blank>URL<S2SV_blank>%s\\\\n\" , the_url ) ; if ( pause_at_first ) fprintf ( stderr , \"[Status:<S2SV_blank>Paused]\\\\n\" ) ; gf_term_connect_from_time ( term , the_url , ( u64 ) ( play_from * 1000 ) , pause_at_first ) ; } } else { fprintf ( stderr , \"Hit<S2SV_blank>\\'h\\'<S2SV_blank>for<S2SV_blank>help\\\\n\\\\n\" ) ; str = gf_cfg_get_key ( cfg_file , \"General\" , \"StartupFile\" ) ; if ( str ) { strncpy ( the_url , \"MP4Client<S2SV_blank>\" GPAC_FULL_VERSION , sizeof ( the_url ) - 1 ) ; the_url [ sizeof ( the_url ) - 1 ] = 0 ; gf_term_connect ( term , str ) ; startup_file = 1 ; is_connected = 1 ; } } if ( gui_mode == 2 ) gui_mode = 0 ; if ( start_fs ) gf_term_set_option ( term , GF_OPT_FULLSCREEN , 1 ) ; if ( views ) { char szTemp [ 4046 ] ; sprintf ( szTemp , \"views://%s\" , views ) ; gf_term_connect ( term , szTemp ) ; } if ( mosaic ) { char szTemp [ 4046 ] ; sprintf ( szTemp , \"mosaic://%s\" , mosaic ) ; gf_term_connect ( term , szTemp ) ; } if ( bench_mode ) { rti_update_time_ms = 500 ; bench_mode_start = gf_sys_clock ( ) ; } while ( Run ) { if ( ( gui_mode == 1 ) || ! gf_prompt_has_input ( ) ) { if ( reload ) { reload = 0 ; gf_term_disconnect ( term ) ; gf_term_connect ( term , startup_file ? gf_cfg_get_key ( cfg_file , \"General\" , \"StartupFile\" ) : the_url ) ; } if ( restart && gf_term_get_option ( term , GF_OPT_IS_OVER ) ) { restart = 0 ; gf_term_play_from_time ( term , 0 , 0 ) ; } if ( request_next_playlist_item ) { c = '\\\\n' ; request_next_playlist_item = 0 ; goto force_input ; } if ( has_command && is_connected ) { has_command = GF_FALSE ; for ( i = 0 ; i < ( u32 ) argc ; i ++ ) { if ( ! strcmp ( argv [ i ] , \"-com\" ) ) { gf_term_scene_update ( term , NULL , argv [ i + 1 ] ) ; i ++ ; } } } if ( initial_service_id && is_connected ) { GF_ObjectManager * root_od = gf_term_get_root_object ( term ) ; if ( root_od ) { gf_term_select_service ( term , root_od , initial_service_id ) ; initial_service_id = 0 ; } } if ( ! use_rtix || display_rti ) UpdateRTInfo ( NULL ) ; if ( term_step ) { gf_term_process_step ( term ) ; } else { gf_sleep ( rti_update_time_ms ) ; } if ( auto_exit && eos_seen && gf_term_get_option ( term , GF_OPT_IS_OVER ) ) { Run = GF_FALSE ; } if ( simulation_time_in_ms && ( ( gf_term_get_elapsed_time_in_ms ( term ) > simulation_time_in_ms ) || ( ! url_arg && gf_sys_clock ( ) > simulation_time_in_ms ) ) ) { Run = GF_FALSE ; } continue ; } c = gf_prompt_get_char ( ) ; force_input : switch ( c ) { case 'q' : { GF_Event evt ; memset ( & evt , 0 , sizeof ( GF_Event ) ) ; evt . type = GF_EVENT_QUIT ; gf_term_send_event ( term , & evt ) ; } break ; case 'X' : exit ( 0 ) ; break ; case 'Q' : break ; case 'o' : startup_file = 0 ; gf_term_disconnect ( term ) ; fprintf ( stderr , \"Enter<S2SV_blank>the<S2SV_blank>absolute<S2SV_blank>URL\\\\n\" ) ; if ( 1 > scanf ( \"%s\" , the_url ) ) { fprintf ( stderr , \"Cannot<S2SV_blank>read<S2SV_blank>absolute<S2SV_blank>URL,<S2SV_blank>aborting\\\\n\" ) ; break ; } if ( rti_file ) init_rti_logs ( rti_file , the_url , use_rtix ) ; gf_term_connect ( term , the_url ) ; break ; case 'O' : gf_term_disconnect ( term ) ; fprintf ( stderr , \"Enter<S2SV_blank>the<S2SV_blank>absolute<S2SV_blank>URL<S2SV_blank>to<S2SV_blank>the<S2SV_blank>playlist\\\\n\" ) ; if ( 1 > scanf ( \"%s\" , the_url ) ) { fprintf ( stderr , \"Cannot<S2SV_blank>read<S2SV_blank>the<S2SV_blank>absolute<S2SV_blank>URL,<S2SV_blank>aborting.\\\\n\" ) ; break ; } playlist = gf_fopen ( the_url , \"rt\" ) ; if ( playlist ) { if ( 1 > fscanf ( playlist , \"%s\" , the_url ) ) { fprintf ( stderr , \"Cannot<S2SV_blank>read<S2SV_blank>any<S2SV_blank>URL<S2SV_blank>from<S2SV_blank>playlist,<S2SV_blank>aborting.\\\\n\" ) ; gf_fclose ( playlist ) ; break ; } fprintf ( stderr , \"Opening<S2SV_blank>URL<S2SV_blank>%s\\\\n\" , the_url ) ; gf_term_connect ( term , the_url ) ; } break ; case '\\\\n' : case 'N' : if ( playlist ) { int res ; gf_term_disconnect ( term ) ; res = fscanf ( playlist , \"%s\" , the_url ) ; if ( ( res == EOF ) && loop_at_end ) { fseek ( playlist , 0 , SEEK_SET ) ; res = fscanf ( playlist , \"%s\" , the_url ) ; } if ( res == EOF ) { fprintf ( stderr , \"No<S2SV_blank>more<S2SV_blank>items<S2SV_blank>-<S2SV_blank>exiting\\\\n\" ) ; Run = 0 ; } else if ( the_url [ 0 ] == '#' ) { request_next_playlist_item = GF_TRUE ; } else { fprintf ( stderr , \"Opening<S2SV_blank>URL<S2SV_blank>%s\\\\n\" , the_url ) ; gf_term_connect_with_path ( term , the_url , pl_path ) ; } } break ; case 'P' : if ( playlist ) { u32 count ; gf_term_disconnect ( term ) ; if ( 1 > scanf ( \"%u\" , & count ) ) { fprintf ( stderr , \"Cannot<S2SV_blank>read<S2SV_blank>number,<S2SV_blank>aborting.\\\\n\" ) ; break ; } while ( count ) { if ( fscanf ( playlist , \"%s\" , the_url ) ) { fprintf ( stderr , \"Failed<S2SV_blank>to<S2SV_blank>read<S2SV_blank>line,<S2SV_blank>aborting\\\\n\" ) ; break ; } count -- ; } fprintf ( stderr , \"Opening<S2SV_blank>URL<S2SV_blank>%s\\\\n\" , the_url ) ; gf_term_connect ( term , the_url ) ; } break ; case 'r' : if ( is_connected ) reload = 1 ; break ; case 'D' : if ( is_connected ) gf_term_disconnect ( term ) ; break ; case 'p' : if ( is_connected ) { Bool is_pause = gf_term_get_option ( term , GF_OPT_PLAY_STATE ) ; fprintf ( stderr , \"[Status:<S2SV_blank>%s]\\\\n\" , is_pause ? \"Playing\" : \"Paused\" ) ; gf_term_set_option ( term , GF_OPT_PLAY_STATE , is_pause ? GF_STATE_PLAYING : GF_STATE_PAUSED ) ; } break ; case 's' : if ( is_connected ) { gf_term_set_option ( term , GF_OPT_PLAY_STATE , GF_STATE_STEP_PAUSE ) ; fprintf ( stderr , \"Step<S2SV_blank>time:<S2SV_blank>\" ) ; PrintTime ( gf_term_get_time_in_ms ( term ) ) ; fprintf ( stderr , \"\\\\n\" ) ; } break ; case 'z' : case 'T' : if ( ! CanSeek || ( Duration <= 2000 ) ) { fprintf ( stderr , \"scene<S2SV_blank>not<S2SV_blank>seekable\\\\n\" ) ; } else { Double res ; s32 seekTo ; fprintf ( stderr , \"Duration:<S2SV_blank>\" ) ; PrintTime ( Duration ) ; res = gf_term_get_time_in_ms ( term ) ; if ( c == 'z' ) { res *= 100 ; res /= ( s64 ) Duration ; fprintf ( stderr , \"<S2SV_blank>(current<S2SV_blank>%.2f<S2SV_blank>%%)\\\\nEnter<S2SV_blank>Seek<S2SV_blank>percentage:\\\\n\" , res ) ; if ( scanf ( \"%d\" , & seekTo ) == 1 ) { if ( seekTo > 100 ) seekTo = 100 ; res = ( Double ) ( s64 ) Duration ; res /= 100 ; res *= seekTo ; gf_term_play_from_time ( term , ( u64 ) ( s64 ) res , 0 ) ; } } else { u32 r , h , m , s ; fprintf ( stderr , \"<S2SV_blank>-<S2SV_blank>Current<S2SV_blank>Time:<S2SV_blank>\" ) ; PrintTime ( ( u64 ) res ) ; fprintf ( stderr , \"\\\\nEnter<S2SV_blank>seek<S2SV_blank>time<S2SV_blank>(Format:<S2SV_blank>s,<S2SV_blank>m:s<S2SV_blank>or<S2SV_blank>h:m:s):\\\\n\" ) ; h = m = s = 0 ; r = scanf ( \"%d:%d:%d\" , & h , & m , & s ) ; if ( r == 2 ) { s = m ; m = h ; h = 0 ; } else if ( r == 1 ) { s = h ; m = h = 0 ; } if ( r && ( r <= 3 ) ) { u64 time = h * 3600 + m * 60 + s ; gf_term_play_from_time ( term , time * 1000 , 0 ) ; } } } break ; case 't' : { if ( is_connected ) { fprintf ( stderr , \"Current<S2SV_blank>Time:<S2SV_blank>\" ) ; PrintTime ( gf_term_get_time_in_ms ( term ) ) ; fprintf ( stderr , \"<S2SV_blank>-<S2SV_blank>Duration:<S2SV_blank>\" ) ; PrintTime ( Duration ) ; fprintf ( stderr , \"\\\\n\" ) ; } } break ; case 'w' : if ( is_connected ) PrintWorldInfo ( term ) ; break ; case 'v' : if ( is_connected ) PrintODList ( term , NULL , 0 , 0 , \"Root\" ) ; break ; case 'i' : if ( is_connected ) { u32 ID ; fprintf ( stderr , \"Enter<S2SV_blank>OD<S2SV_blank>ID<S2SV_blank>(0<S2SV_blank>for<S2SV_blank>main<S2SV_blank>OD):<S2SV_blank>\" ) ; fflush ( stderr ) ; if ( scanf ( \"%ud\" , & ID ) == 1 ) { ViewOD ( term , ID , ( u32 ) - 1 , NULL ) ; } else { char str_url [ GF_MAX_PATH ] ; if ( scanf ( \"%s\" , str_url ) == 1 ) ViewOD ( term , 0 , ( u32 ) - 1 , str_url ) ; } } break ; case 'j' : if ( is_connected ) { u32 num ; do { fprintf ( stderr , \"Enter<S2SV_blank>OD<S2SV_blank>number<S2SV_blank>(0<S2SV_blank>for<S2SV_blank>main<S2SV_blank>OD):<S2SV_blank>\" ) ; fflush ( stderr ) ; } while ( 1 > scanf ( \"%ud\" , & num ) ) ; ViewOD ( term , ( u32 ) - 1 , num , NULL ) ; } break ; case 'b' : if ( is_connected ) ViewODs ( term , 1 ) ; break ; case 'm' : if ( is_connected ) ViewODs ( term , 0 ) ; break ; case 'l' : list_modules ( user . modules ) ; break ; case 'n' : if ( is_connected ) set_navigation ( ) ; break ; case 'x' : if ( is_connected ) gf_term_set_option ( term , GF_OPT_NAVIGATION_TYPE , 0 ) ; break ; case 'd' : if ( is_connected ) { GF_ObjectManager * odm = NULL ; char radname [ GF_MAX_PATH ] , * sExt ; GF_Err e ; u32 i , count , odid ; Bool xml_dump , std_out ; radname [ 0 ] = 0 ; do { fprintf ( stderr , \"Enter<S2SV_blank>Inline<S2SV_blank>OD<S2SV_blank>ID<S2SV_blank>if<S2SV_blank>any<S2SV_blank>or<S2SV_blank>0<S2SV_blank>:<S2SV_blank>\" ) ; fflush ( stderr ) ; } while ( 1 > scanf ( \"%ud\" , & odid ) ) ; if ( odid ) { GF_ObjectManager * root_odm = gf_term_get_root_object ( term ) ; if ( ! root_odm ) break ; count = gf_term_get_object_count ( term , root_odm ) ; for ( i = 0 ; i < count ; i ++ ) { GF_MediaInfo info ; odm = gf_term_get_object ( term , root_odm , i ) ; if ( gf_term_get_object_info ( term , odm , & info ) == GF_OK ) { if ( info . od -> objectDescriptorID == odid ) break ; } odm = NULL ; } } do { fprintf ( stderr , \"Enter<S2SV_blank>file<S2SV_blank>radical<S2SV_blank>name<S2SV_blank>(+\\\\\\'.x\\\\\\'<S2SV_blank>for<S2SV_blank>XML<S2SV_blank>dumping)<S2SV_blank>-<S2SV_blank>\\\\\"std\\\\\"<S2SV_blank>for<S2SV_blank>stderr:<S2SV_blank>\" ) ; fflush ( stderr ) ; } while ( 1 > scanf ( \"%s\" , radname ) ) ; sExt = strrchr ( radname , '.' ) ; xml_dump = 0 ; if ( sExt ) { if ( ! stricmp ( sExt , \".x\" ) ) xml_dump = 1 ; sExt [ 0 ] = 0 ; } std_out = strnicmp ( radname , \"std\" , 3 ) ? 0 : 1 ; e = gf_term_dump_scene ( term , std_out ? NULL : radname , NULL , xml_dump , 0 , odm ) ; fprintf ( stderr , \"Dump<S2SV_blank>done<S2SV_blank>(%s)\\\\n\" , gf_error_to_string ( e ) ) ; } break ; case 'c' : PrintGPACConfig ( ) ; break ; case '3' : { Bool use_3d = ! gf_term_get_option ( term , GF_OPT_USE_OPENGL ) ; if ( gf_term_set_option ( term , GF_OPT_USE_OPENGL , use_3d ) == GF_OK ) { fprintf ( stderr , \"Using<S2SV_blank>%s<S2SV_blank>for<S2SV_blank>2D<S2SV_blank>drawing\\\\n\" , use_3d ? \"OpenGL\" : \"2D<S2SV_blank>rasterizer\" ) ; } } break ; case 'k' : { Bool opt = gf_term_get_option ( term , GF_OPT_STRESS_MODE ) ; opt = ! opt ; fprintf ( stderr , \"Turning<S2SV_blank>stress<S2SV_blank>mode<S2SV_blank>%s\\\\n\" , opt ? \"on\" : \"off\" ) ; gf_term_set_option ( term , GF_OPT_STRESS_MODE , opt ) ; } break ; case '4' : gf_term_set_option ( term , GF_OPT_ASPECT_RATIO , GF_ASPECT_RATIO_4_3 ) ; break ; case '5' : gf_term_set_option ( term , GF_OPT_ASPECT_RATIO , GF_ASPECT_RATIO_16_9 ) ; break ; case '6' : gf_term_set_option ( term , GF_OPT_ASPECT_RATIO , GF_ASPECT_RATIO_FILL_SCREEN ) ; break ; case '7' : gf_term_set_option ( term , GF_OPT_ASPECT_RATIO , GF_ASPECT_RATIO_KEEP ) ; break ; case 'C' : switch ( gf_term_get_option ( term , GF_OPT_MEDIA_CACHE ) ) { case GF_MEDIA_CACHE_DISABLED : gf_term_set_option ( term , GF_OPT_MEDIA_CACHE , GF_MEDIA_CACHE_ENABLED ) ; break ; case GF_MEDIA_CACHE_ENABLED : gf_term_set_option ( term , GF_OPT_MEDIA_CACHE , GF_MEDIA_CACHE_DISABLED ) ; break ; case GF_MEDIA_CACHE_RUNNING : fprintf ( stderr , \"Streaming<S2SV_blank>Cache<S2SV_blank>is<S2SV_blank>running<S2SV_blank>-<S2SV_blank>please<S2SV_blank>stop<S2SV_blank>it<S2SV_blank>first\\\\n\" ) ; continue ; } switch ( gf_term_get_option ( term , GF_OPT_MEDIA_CACHE ) ) { case GF_MEDIA_CACHE_ENABLED : fprintf ( stderr , \"Streaming<S2SV_blank>Cache<S2SV_blank>Enabled\\\\n\" ) ; break ; case GF_MEDIA_CACHE_DISABLED : fprintf ( stderr , \"Streaming<S2SV_blank>Cache<S2SV_blank>Disabled\\\\n\" ) ; break ; case GF_MEDIA_CACHE_RUNNING : fprintf ( stderr , \"Streaming<S2SV_blank>Cache<S2SV_blank>Running\\\\n\" ) ; break ; } break ; case 'S' : case 'A' : if ( gf_term_get_option ( term , GF_OPT_MEDIA_CACHE ) == GF_MEDIA_CACHE_RUNNING ) { gf_term_set_option ( term , GF_OPT_MEDIA_CACHE , ( c == 'S' ) ? GF_MEDIA_CACHE_DISABLED : GF_MEDIA_CACHE_DISCARD ) ; fprintf ( stderr , \"Streaming<S2SV_blank>Cache<S2SV_blank>stopped\\\\n\" ) ; } else { fprintf ( stderr , \"Streaming<S2SV_blank>Cache<S2SV_blank>not<S2SV_blank>running\\\\n\" ) ; } break ; case 'R' : display_rti = ! display_rti ; ResetCaption ( ) ; break ; case 'F' : if ( display_rti ) display_rti = 0 ; else display_rti = 2 ; ResetCaption ( ) ; break ; case 'u' : { GF_Err e ; char szCom [ 8192 ] ; fprintf ( stderr , \"Enter<S2SV_blank>command<S2SV_blank>to<S2SV_blank>send:\\\\n\" ) ; fflush ( stdin ) ; szCom [ 0 ] = 0 ; if ( 1 > scanf ( \"%[^\\\\t\\\\n]\" , szCom ) ) { fprintf ( stderr , \"Cannot<S2SV_blank>read<S2SV_blank>command<S2SV_blank>to<S2SV_blank>send,<S2SV_blank>aborting.\\\\n\" ) ; break ; } e = gf_term_scene_update ( term , NULL , szCom ) ; if ( e ) fprintf ( stderr , \"Processing<S2SV_blank>command<S2SV_blank>failed:<S2SV_blank>%s\\\\n\" , gf_error_to_string ( e ) ) ; } break ; case 'e' : { GF_Err e ; char jsCode [ 8192 ] ; fprintf ( stderr , \"Enter<S2SV_blank>JavaScript<S2SV_blank>code<S2SV_blank>to<S2SV_blank>evaluate:\\\\n\" ) ; fflush ( stdin ) ; jsCode [ 0 ] = 0 ; if ( 1 > scanf ( \"%[^\\\\t\\\\n]\" , jsCode ) ) { fprintf ( stderr , \"Cannot<S2SV_blank>read<S2SV_blank>code<S2SV_blank>to<S2SV_blank>evaluate,<S2SV_blank>aborting.\\\\n\" ) ; break ; } e = gf_term_scene_update ( term , \"application/ecmascript\" , jsCode ) ; if ( e ) fprintf ( stderr , \"Processing<S2SV_blank>JS<S2SV_blank>code<S2SV_blank>failed:<S2SV_blank>%s\\\\n\" , gf_error_to_string ( e ) ) ; } break ; case 'L' : { char szLog [ 1024 ] , * cur_logs ; cur_logs = gf_log_get_tools_levels ( ) ; fprintf ( stderr , \"Enter<S2SV_blank>new<S2SV_blank>log<S2SV_blank>level<S2SV_blank>(current<S2SV_blank>tools<S2SV_blank>%s):\\\\n\" , cur_logs ) ; gf_free ( cur_logs ) ; if ( scanf ( \"%s\" , szLog ) < 1 ) { fprintf ( stderr , \"Cannot<S2SV_blank>read<S2SV_blank>new<S2SV_blank>log<S2SV_blank>level,<S2SV_blank>aborting.\\\\n\" ) ; break ; } gf_log_modify_tools_levels ( szLog ) ; } break ; case 'g' : { GF_SystemRTInfo rti ; gf_sys_get_rti ( rti_update_time_ms , & rti , 0 ) ; fprintf ( stderr , \"GPAC<S2SV_blank>allocated<S2SV_blank>memory<S2SV_blank>\" LLD \"\\\\n\" , rti . gpac_memory ) ; } break ; case 'M' : { u32 size ; do { fprintf ( stderr , \"Enter<S2SV_blank>new<S2SV_blank>video<S2SV_blank>cache<S2SV_blank>memory<S2SV_blank>in<S2SV_blank>kBytes<S2SV_blank>(current<S2SV_blank>%ud):\\\\n\" , gf_term_get_option ( term , GF_OPT_VIDEO_CACHE_SIZE ) ) ; } while ( 1 > scanf ( \"%ud\" , & size ) ) ; gf_term_set_option ( term , GF_OPT_VIDEO_CACHE_SIZE , size ) ; } break ; case 'H' : { u32 http_bitrate = gf_term_get_option ( term , GF_OPT_HTTP_MAX_RATE ) ; do { fprintf ( stderr , \"Enter<S2SV_blank>new<S2SV_blank>http<S2SV_blank>bitrate<S2SV_blank>in<S2SV_blank>bps<S2SV_blank>(0<S2SV_blank>for<S2SV_blank>none)<S2SV_blank>-<S2SV_blank>current<S2SV_blank>limit:<S2SV_blank>%d\\\\n\" , http_bitrate ) ; } while ( 1 > scanf ( \"%ud\" , & http_bitrate ) ) ; gf_term_set_option ( term , GF_OPT_HTTP_MAX_RATE , http_bitrate ) ; } break ; case 'E' : gf_term_set_option ( term , GF_OPT_RELOAD_CONFIG , 1 ) ; break ; case 'B' : switch_bench ( ! bench_mode ) ; break ; case 'Y' : { char szOpt [ 8192 ] ; fprintf ( stderr , \"Enter<S2SV_blank>option<S2SV_blank>to<S2SV_blank>set<S2SV_blank>(Section:Name=Value):\\\\n\" ) ; fflush ( stdin ) ; szOpt [ 0 ] = 0 ; if ( 1 > scanf ( \"%[^\\\\t\\\\n]\" , szOpt ) ) { fprintf ( stderr , \"Cannot<S2SV_blank>read<S2SV_blank>option\\\\n\" ) ; break ; } set_cfg_option ( szOpt ) ; } break ; case 'Z' : { char szFileName [ 100 ] ; u32 nb_pass , nb_views , offscreen_view = 0 ; GF_VideoSurface fb ; GF_Err e ; nb_pass = 1 ; nb_views = gf_term_get_option ( term , GF_OPT_NUM_STEREO_VIEWS ) ; if ( nb_views > 1 ) { fprintf ( stderr , \"Auto-stereo<S2SV_blank>mode<S2SV_blank>detected<S2SV_blank>-<S2SV_blank>type<S2SV_blank>number<S2SV_blank>of<S2SV_blank>view<S2SV_blank>to<S2SV_blank>dump<S2SV_blank>(0<S2SV_blank>is<S2SV_blank>main<S2SV_blank>output,<S2SV_blank>1<S2SV_blank>to<S2SV_blank>%d<S2SV_blank>offscreen<S2SV_blank>view,<S2SV_blank>%d<S2SV_blank>for<S2SV_blank>all<S2SV_blank>offscreen,<S2SV_blank>%d<S2SV_blank>for<S2SV_blank>all<S2SV_blank>offscreen<S2SV_blank>and<S2SV_blank>main)\\\\n\" , nb_views , nb_views + 1 , nb_views + 2 ) ; if ( scanf ( \"%d\" , & offscreen_view ) != 1 ) { offscreen_view = 0 ; } if ( offscreen_view == nb_views + 1 ) { offscreen_view = 1 ; nb_pass = nb_views ; } else if ( offscreen_view == nb_views + 2 ) { offscreen_view = 0 ; nb_pass = nb_views + 1 ; } } while ( nb_pass ) { nb_pass -- ; if ( offscreen_view ) { sprintf ( szFileName , \"view%d_dump.png\" , offscreen_view ) ; e = gf_term_get_offscreen_buffer ( term , & fb , offscreen_view - 1 , 0 ) ; } else { sprintf ( szFileName , \"gpac_video_dump_\" LLU \".png\" , gf_net_get_utc ( ) ) ; e = gf_term_get_screen_buffer ( term , & fb ) ; } offscreen_view ++ ; if ( e ) { fprintf ( stderr , \"Error<S2SV_blank>dumping<S2SV_blank>screen<S2SV_blank>buffer<S2SV_blank>%s\\\\n\" , gf_error_to_string ( e ) ) ; nb_pass = 0 ; } else { # ifndef GPAC_DISABLE_AV_PARSERS u32 dst_size = fb . width * fb . height * 4 ; char * dst = ( char * ) gf_malloc ( sizeof ( char ) * dst_size ) ; e = gf_img_png_enc ( fb . video_buffer , fb . width , fb . height , fb . pitch_y , fb . pixel_format , dst , & dst_size ) ; if ( e ) { fprintf ( stderr , \"Error<S2SV_blank>encoding<S2SV_blank>PNG<S2SV_blank>%s\\\\n\" , gf_error_to_string ( e ) ) ; nb_pass = 0 ; } else { FILE * png = gf_fopen ( szFileName , \"wb\" ) ; if ( ! png ) { fprintf ( stderr , \"Error<S2SV_blank>writing<S2SV_blank>file<S2SV_blank>%s\\\\n\" , szFileName ) ; nb_pass = 0 ; } else { gf_fwrite ( dst , dst_size , 1 , png ) ; gf_fclose ( png ) ; fprintf ( stderr , \"Dump<S2SV_blank>to<S2SV_blank>%s\\\\n\" , szFileName ) ; } } if ( dst ) gf_free ( dst ) ; gf_term_release_screen_buffer ( term , & fb ) ; # endif } } fprintf ( stderr , \"Done:<S2SV_blank>%s\\\\n\" , szFileName ) ; } break ; case 'G' : { GF_ObjectManager * root_od , * odm ; u32 index ; char szOpt [ 8192 ] ; fprintf ( stderr , \"Enter<S2SV_blank>0-based<S2SV_blank>index<S2SV_blank>of<S2SV_blank>object<S2SV_blank>to<S2SV_blank>select<S2SV_blank>or<S2SV_blank>service<S2SV_blank>ID:\\\\n\" ) ; fflush ( stdin ) ; szOpt [ 0 ] = 0 ; if ( 1 > scanf ( \"%[^\\\\t\\\\n]\" , szOpt ) ) { fprintf ( stderr , \"Cannot<S2SV_blank>read<S2SV_blank>OD<S2SV_blank>ID\\\\n\" ) ; break ; } index = atoi ( szOpt ) ; odm = NULL ; root_od = gf_term_get_root_object ( term ) ; if ( root_od ) { if ( gf_term_find_service ( term , root_od , index ) ) { gf_term_select_service ( term , root_od , index ) ; } else { fprintf ( stderr , \"Cannot<S2SV_blank>find<S2SV_blank>service<S2SV_blank>%d<S2SV_blank>-<S2SV_blank>trying<S2SV_blank>with<S2SV_blank>object<S2SV_blank>index\\\\n\" , index ) ; odm = gf_term_get_object ( term , root_od , index ) ; if ( odm ) { gf_term_select_object ( term , odm ) ; } else { fprintf ( stderr , \"Cannot<S2SV_blank>find<S2SV_blank>object<S2SV_blank>at<S2SV_blank>index<S2SV_blank>%d\\\\n\" , index ) ; } } } } break ; case 'h' : PrintHelp ( ) ; break ; default : break ; } } if ( bench_mode ) { PrintAVInfo ( GF_TRUE ) ; } if ( simulation_time_in_ms ) { gf_log_set_strict_error ( 0 ) ; } i = gf_sys_clock ( ) ; gf_term_disconnect ( term ) ; if ( rti_file ) UpdateRTInfo ( \"Disconnected\\\\n\" ) ; fprintf ( stderr , \"Deleting<S2SV_blank>terminal...<S2SV_blank>\" ) ; if ( playlist ) gf_fclose ( playlist ) ; # if defined ( __DARWIN__ ) || defined ( __APPLE__ ) carbon_uninit ( ) ; # endif gf_term_del ( term ) ; fprintf ( stderr , \"done<S2SV_blank>(in<S2SV_blank>%d<S2SV_blank>ms)<S2SV_blank>-<S2SV_blank>ran<S2SV_blank>for<S2SV_blank>%d<S2SV_blank>ms\\\\n\" , gf_sys_clock ( ) - i , gf_sys_clock ( ) ) ; fprintf ( stderr , \"GPAC<S2SV_blank>cleanup<S2SV_blank>...\\\\n\" ) ; gf_modules_del ( user . modules ) ; if ( no_cfg_save ) gf_cfg_discard_changes ( cfg_file ) ; gf_cfg_del ( cfg_file ) ; gf_sys_close ( ) ; if ( rti_logs ) gf_fclose ( rti_logs ) ; if ( logfile ) gf_fclose ( logfile ) ; if ( gui_mode ) { hide_shell ( 2 ) ; } # ifdef GPAC_MEMORY_TRACKING if ( mem_track && ( gf_memory_size ( ) || gf_file_handles_count ( ) ) ) { gf_log_set_tool_level ( GF_LOG_MEMORY , GF_LOG_INFO ) ; gf_memory_print ( ) ; return 2 ; } # endif return ret_val ; }\n","target":"<S2SV_ModStart> [ sizeof ( the_url <S2SV_ModEnd> ) - 1\n","project_and_commit_id":"gpac@gpac/1c449a34fe0b50aaffb881bfb9d7c5ab0bb18cdd","cve_id":"CVE-2018-20763","original_address":"https://github.com/gpac/gpac/commit/1c449a34fe0b50aaffb881bfb9d7c5ab0bb18cdd","time":"2019-02-06T23:29Z"},
	{"Unnamed: 0":4309,"cwe_id":"CWE-20","source":"CWE-20 int cifs_mount ( struct super_block * sb , struct cifs_sb_info * cifs_sb , char * mount_data_global , const char * devname ) { int rc ; int xid ; struct smb_vol * volume_info ; struct cifsSesInfo * pSesInfo ; struct cifsTconInfo * tcon ; struct TCP_Server_Info * srvTcp ; char * full_path ; char * mount_data = mount_data_global ; struct tcon_link * tlink ; # ifdef CONFIG_CIFS_DFS_UPCALL struct dfs_info3_param * referrals = NULL ; unsigned int num_referrals = 0 ; int referral_walks_count = 0 ; try_mount_again : # endif rc = 0 ; tcon = NULL ; pSesInfo = NULL ; srvTcp = NULL ; full_path = NULL ; tlink = NULL ; xid = GetXid ( ) ; volume_info = kzalloc ( sizeof ( struct smb_vol ) , GFP_KERNEL ) ; if ( ! volume_info ) { rc = - ENOMEM ; goto out ; } if ( cifs_parse_mount_options ( mount_data , devname , volume_info ) ) { rc = - EINVAL ; goto out ; } if ( volume_info -> nullauth ) { cFYI ( 1 , \"null<S2SV_blank>user\" ) ; volume_info -> username = \"\" ; } else if ( volume_info -> username ) { cFYI ( 1 , \"Username:<S2SV_blank>%s\" , volume_info -> username ) ; } else { cifserror ( \"No<S2SV_blank>username<S2SV_blank>specified\" ) ; rc = - EINVAL ; goto out ; } if ( volume_info -> iocharset == NULL ) { volume_info -> local_nls = load_nls_default ( ) ; } else { volume_info -> local_nls = load_nls ( volume_info -> iocharset ) ; if ( volume_info -> local_nls == NULL ) { cERROR ( 1 , \"CIFS<S2SV_blank>mount<S2SV_blank>error:<S2SV_blank>iocharset<S2SV_blank>%s<S2SV_blank>not<S2SV_blank>found\" , volume_info -> iocharset ) ; rc = - ELIBACC ; goto out ; } } cifs_sb -> local_nls = volume_info -> local_nls ; srvTcp = cifs_get_tcp_session ( volume_info ) ; if ( IS_ERR ( srvTcp ) ) { rc = PTR_ERR ( srvTcp ) ; goto out ; } pSesInfo = cifs_get_smb_ses ( srvTcp , volume_info ) ; if ( IS_ERR ( pSesInfo ) ) { rc = PTR_ERR ( pSesInfo ) ; pSesInfo = NULL ; goto mount_fail_check ; } setup_cifs_sb ( volume_info , cifs_sb ) ; if ( pSesInfo -> capabilities & CAP_LARGE_FILES ) sb -> s_maxbytes = MAX_LFS_FILESIZE ; else sb -> s_maxbytes = MAX_NON_LFS ; sb -> s_time_gran = 100 ; tcon = cifs_get_tcon ( pSesInfo , volume_info ) ; if ( IS_ERR ( tcon ) ) { rc = PTR_ERR ( tcon ) ; tcon = NULL ; goto remote_path_check ; } if ( ! tcon -> ipc ) { CIFSSMBQFSDeviceInfo ( xid , tcon ) ; CIFSSMBQFSAttributeInfo ( xid , tcon ) ; } if ( tcon -> ses -> capabilities & CAP_UNIX ) reset_cifs_unix_caps ( xid , tcon , sb , volume_info ) ; else tcon -> unix_ext = 0 ; if ( ( cifs_sb -> mnt_cifs_flags & CIFS_MOUNT_POSIX_PATHS ) == 0 ) convert_delimiter ( cifs_sb -> prepath , CIFS_DIR_SEP ( cifs_sb ) ) ; if ( ( tcon -> unix_ext == 0 ) && ( cifs_sb -> rsize > ( 1024 * 127 ) ) ) { cifs_sb -> rsize = 1024 * 127 ; cFYI ( DBG2 , \"no<S2SV_blank>very<S2SV_blank>large<S2SV_blank>read<S2SV_blank>support,<S2SV_blank>rsize<S2SV_blank>now<S2SV_blank>127K\" ) ; } if ( ! ( tcon -> ses -> capabilities & CAP_LARGE_WRITE_X ) ) cifs_sb -> wsize = min ( cifs_sb -> wsize , ( tcon -> ses -> server -> maxBuf - MAX_CIFS_HDR_SIZE ) ) ; if ( ! ( tcon -> ses -> capabilities & CAP_LARGE_READ_X ) ) cifs_sb -> rsize = min ( cifs_sb -> rsize , ( tcon -> ses -> server -> maxBuf - MAX_CIFS_HDR_SIZE ) ) ; remote_path_check : <S2SV_StartBug> if ( ! rc && cifs_sb -> prepathlen && tcon ) { <S2SV_EndBug> full_path = cifs_build_path_to_root ( cifs_sb , tcon ) ; if ( full_path == NULL ) { rc = - ENOMEM ; goto mount_fail_check ; } rc = is_path_accessible ( xid , tcon , cifs_sb , full_path ) ; if ( rc != 0 && rc != - EREMOTE ) { kfree ( full_path ) ; goto mount_fail_check ; } kfree ( full_path ) ; } if ( rc == - EREMOTE ) { # ifdef CONFIG_CIFS_DFS_UPCALL if ( referral_walks_count > MAX_NESTED_LINKS ) { rc = - ELOOP ; goto mount_fail_check ; } if ( ( cifs_sb -> mnt_cifs_flags & CIFS_MOUNT_POSIX_PATHS ) == 0 ) convert_delimiter ( cifs_sb -> prepath , CIFS_DIR_SEP ( cifs_sb ) ) ; full_path = build_unc_path_to_root ( volume_info , cifs_sb ) ; if ( IS_ERR ( full_path ) ) { rc = PTR_ERR ( full_path ) ; goto mount_fail_check ; } cFYI ( 1 , \"Getting<S2SV_blank>referral<S2SV_blank>for:<S2SV_blank>%s\" , full_path ) ; rc = get_dfs_path ( xid , pSesInfo , full_path + 1 , cifs_sb -> local_nls , & num_referrals , & referrals , cifs_sb -> mnt_cifs_flags & CIFS_MOUNT_MAP_SPECIAL_CHR ) ; if ( ! rc && num_referrals > 0 ) { char * fake_devname = NULL ; if ( mount_data != mount_data_global ) kfree ( mount_data ) ; mount_data = cifs_compose_mount_options ( cifs_sb -> mountdata , full_path + 1 , referrals , & fake_devname ) ; free_dfs_info_array ( referrals , num_referrals ) ; kfree ( fake_devname ) ; kfree ( full_path ) ; if ( IS_ERR ( mount_data ) ) { rc = PTR_ERR ( mount_data ) ; mount_data = NULL ; goto mount_fail_check ; } if ( tcon ) cifs_put_tcon ( tcon ) ; else if ( pSesInfo ) cifs_put_smb_ses ( pSesInfo ) ; cleanup_volume_info ( & volume_info ) ; referral_walks_count ++ ; FreeXid ( xid ) ; goto try_mount_again ; } # else rc = - EOPNOTSUPP ; # endif } if ( rc ) goto mount_fail_check ; tlink = kzalloc ( sizeof * tlink , GFP_KERNEL ) ; if ( tlink == NULL ) { rc = - ENOMEM ; goto mount_fail_check ; } tlink -> tl_uid = pSesInfo -> linux_uid ; tlink -> tl_tcon = tcon ; tlink -> tl_time = jiffies ; set_bit ( TCON_LINK_MASTER , & tlink -> tl_flags ) ; set_bit ( TCON_LINK_IN_TREE , & tlink -> tl_flags ) ; cifs_sb -> master_tlink = tlink ; spin_lock ( & cifs_sb -> tlink_tree_lock ) ; tlink_rb_insert ( & cifs_sb -> tlink_tree , tlink ) ; spin_unlock ( & cifs_sb -> tlink_tree_lock ) ; queue_delayed_work ( system_nrt_wq , & cifs_sb -> prune_tlinks , TLINK_IDLE_EXPIRE ) ; mount_fail_check : if ( rc ) { if ( mount_data != mount_data_global ) kfree ( mount_data ) ; if ( tcon ) cifs_put_tcon ( tcon ) ; else if ( pSesInfo ) cifs_put_smb_ses ( pSesInfo ) ; else cifs_put_tcp_session ( srvTcp ) ; goto out ; } out : cleanup_volume_info ( & volume_info ) ; FreeXid ( xid ) ; return rc ; }\n","target":"<S2SV_ModStart> ( ! rc <S2SV_ModEnd> && tcon )\n","project_and_commit_id":"torvalds@linux/70945643722ffeac779d2529a348f99567fa5c33","cve_id":"CVE-2011-3363","original_address":"https://github.com/torvalds/linux/commit/70945643722ffeac779d2529a348f99567fa5c33","time":"2012-05-24T23:55Z"},
	{"Unnamed: 0":3618,"cwe_id":"CWE-189","source":"CWE-189 TSQuery QTN2QT ( QTNode * in ) { TSQuery out ; int len ; int sumlen = 0 , nnode = 0 ; QTN2QTState state ; <S2SV_StartBug> cntsize ( in , & sumlen , & nnode ) ; <S2SV_EndBug> len = COMPUTESIZE ( nnode , sumlen ) ; out = ( TSQuery ) palloc0 ( len ) ; SET_VARSIZE ( out , len ) ; out -> size = nnode ; state . curitem = GETQUERY ( out ) ; state . operand = state . curoperand = GETOPERAND ( out ) ; fillQT ( & state , in ) ; return out ; }\n","target":"<S2SV_ModStart> , & nnode ) ; if ( TSQUERY_TOO_BIG ( nnode , sumlen ) ) ereport ( ERROR , ( errcode ( ERRCODE_PROGRAM_LIMIT_EXCEEDED ) , errmsg ( \"tsquery<S2SV_blank>is<S2SV_blank>too<S2SV_blank>large\" ) )\n","project_and_commit_id":"postgres@postgres/31400a673325147e1205326008e32135a78b4d8a","cve_id":"CVE-2014-2669","original_address":"https://github.com/postgres/postgres/commit/31400a673325147e1205326008e32135a78b4d8a","time":"2014-03-31T14:58Z"},
	{"Unnamed: 0":1742,"cwe_id":"CWE-119","source":"CWE-119 static void dump_boot ( DOS_FS * fs , struct boot_sector * b , unsigned lss ) { unsigned short sectors ; printf ( \"Boot<S2SV_blank>sector<S2SV_blank>contents:\\\\n\" ) ; if ( ! atari_format ) { char id [ 9 ] ; strncpy ( id , ( const char * ) b -> system_id , 8 ) ; id [ 8 ] = 0 ; printf ( \"System<S2SV_blank>ID<S2SV_blank>\\\\\"%s\\\\\"\\\\n\" , id ) ; } else { printf ( \"Serial<S2SV_blank>number<S2SV_blank>0x%x\\\\n\" , b -> system_id [ 5 ] | ( b -> system_id [ 6 ] << 8 ) | ( b -> system_id [ 7 ] << 16 ) ) ; } printf ( \"Media<S2SV_blank>byte<S2SV_blank>0x%02x<S2SV_blank>(%s)\\\\n\" , b -> media , get_media_descr ( b -> media ) ) ; printf ( \"%10d<S2SV_blank>bytes<S2SV_blank>per<S2SV_blank>logical<S2SV_blank>sector\\\\n\" , GET_UNALIGNED_W ( b -> sector_size ) ) ; printf ( \"%10d<S2SV_blank>bytes<S2SV_blank>per<S2SV_blank>cluster\\\\n\" , fs -> cluster_size ) ; printf ( \"%10d<S2SV_blank>reserved<S2SV_blank>sector%s\\\\n\" , le16toh ( b -> reserved ) , le16toh ( b -> reserved ) == 1 ? \"\" : \"s\" ) ; printf ( \"First<S2SV_blank>FAT<S2SV_blank>starts<S2SV_blank>at<S2SV_blank>byte<S2SV_blank>%llu<S2SV_blank>(sector<S2SV_blank>%llu)\\\\n\" , ( unsigned long long ) fs -> fat_start , ( unsigned long long ) fs -> fat_start / lss ) ; printf ( \"%10d<S2SV_blank>FATs,<S2SV_blank>%d<S2SV_blank>bit<S2SV_blank>entries\\\\n\" , b -> fats , fs -> fat_bits ) ; <S2SV_StartBug> printf ( \"%10d<S2SV_blank>bytes<S2SV_blank>per<S2SV_blank>FAT<S2SV_blank>(=<S2SV_blank>%u<S2SV_blank>sectors)\\\\n\" , fs -> fat_size , <S2SV_EndBug> <S2SV_StartBug> fs -> fat_size / lss ) ; <S2SV_EndBug> if ( ! fs -> root_cluster ) { printf ( \"Root<S2SV_blank>directory<S2SV_blank>starts<S2SV_blank>at<S2SV_blank>byte<S2SV_blank>%llu<S2SV_blank>(sector<S2SV_blank>%llu)\\\\n\" , ( unsigned long long ) fs -> root_start , ( unsigned long long ) fs -> root_start / lss ) ; printf ( \"%10d<S2SV_blank>root<S2SV_blank>directory<S2SV_blank>entries\\\\n\" , fs -> root_entries ) ; } else { printf ( \"Root<S2SV_blank>directory<S2SV_blank>start<S2SV_blank>at<S2SV_blank>cluster<S2SV_blank>%lu<S2SV_blank>(arbitrary<S2SV_blank>size)\\\\n\" , ( unsigned long ) fs -> root_cluster ) ; } printf ( \"Data<S2SV_blank>area<S2SV_blank>starts<S2SV_blank>at<S2SV_blank>byte<S2SV_blank>%llu<S2SV_blank>(sector<S2SV_blank>%llu)\\\\n\" , ( unsigned long long ) fs -> data_start , ( unsigned long long ) fs -> data_start / lss ) ; printf ( \"%10lu<S2SV_blank>data<S2SV_blank>clusters<S2SV_blank>(%llu<S2SV_blank>bytes)\\\\n\" , ( unsigned long ) fs -> data_clusters , ( unsigned long long ) fs -> data_clusters * fs -> cluster_size ) ; printf ( \"%u<S2SV_blank>sectors/track,<S2SV_blank>%u<S2SV_blank>heads\\\\n\" , le16toh ( b -> secs_track ) , le16toh ( b -> heads ) ) ; printf ( \"%10u<S2SV_blank>hidden<S2SV_blank>sectors\\\\n\" , atari_format ? ( ( ( unsigned char * ) & b -> hidden ) [ 0 ] | ( ( unsigned char * ) & b -> hidden ) [ 1 ] << 8 ) : le32toh ( b -> hidden ) ) ; sectors = GET_UNALIGNED_W ( b -> sectors ) ; printf ( \"%10u<S2SV_blank>sectors<S2SV_blank>total\\\\n\" , sectors ? sectors : le32toh ( b -> total_sect ) ) ; }\n","target":"<S2SV_ModStart> ; printf ( \"%10lld<S2SV_blank>bytes<S2SV_blank>per<S2SV_blank>FAT<S2SV_blank>(=<S2SV_blank>%llu<S2SV_blank>sectors)\\\\n\" , ( long long ) <S2SV_ModEnd> fs -> fat_size <S2SV_ModStart> -> fat_size , ( long long )\n","project_and_commit_id":"dosfstools@dosfstools/e8eff147e9da1185f9afd5b25948153a3b97cf52","cve_id":"CVE-2016-4804","original_address":"https://github.com/dosfstools/dosfstools/commit/e8eff147e9da1185f9afd5b25948153a3b97cf52","time":"2016-06-03T14:59Z"},
	{"Unnamed: 0":2374,"cwe_id":"CWE-264","source":"CWE-264 static ssize_t ib_uverbs_write ( struct file * filp , const char __user * buf , size_t count , loff_t * pos ) { struct ib_uverbs_file * file = filp -> private_data ; struct ib_device * ib_dev ; struct ib_uverbs_cmd_hdr hdr ; __u32 command ; __u32 flags ; int srcu_key ; ssize_t ret ; <S2SV_StartBug> if ( count < sizeof hdr ) <S2SV_EndBug> return - EINVAL ; if ( copy_from_user ( & hdr , buf , sizeof hdr ) ) return - EFAULT ; srcu_key = srcu_read_lock ( & file -> device -> disassociate_srcu ) ; ib_dev = srcu_dereference ( file -> device -> ib_dev , & file -> device -> disassociate_srcu ) ; if ( ! ib_dev ) { ret = - EIO ; goto out ; } if ( hdr . command & ~ ( __u32 ) ( IB_USER_VERBS_CMD_FLAGS_MASK | IB_USER_VERBS_CMD_COMMAND_MASK ) ) { ret = - EINVAL ; goto out ; } command = hdr . command & IB_USER_VERBS_CMD_COMMAND_MASK ; if ( verify_command_mask ( ib_dev , command ) ) { ret = - EOPNOTSUPP ; goto out ; } if ( ! file -> ucontext && command != IB_USER_VERBS_CMD_GET_CONTEXT ) { ret = - EINVAL ; goto out ; } flags = ( hdr . command & IB_USER_VERBS_CMD_FLAGS_MASK ) >> IB_USER_VERBS_CMD_FLAGS_SHIFT ; if ( ! flags ) { if ( command >= ARRAY_SIZE ( uverbs_cmd_table ) || ! uverbs_cmd_table [ command ] ) { ret = - EINVAL ; goto out ; } if ( hdr . in_words * 4 != count ) { ret = - EINVAL ; goto out ; } ret = uverbs_cmd_table [ command ] ( file , ib_dev , buf + sizeof ( hdr ) , hdr . in_words * 4 , hdr . out_words * 4 ) ; } else if ( flags == IB_USER_VERBS_CMD_FLAG_EXTENDED ) { struct ib_uverbs_ex_cmd_hdr ex_hdr ; struct ib_udata ucore ; struct ib_udata uhw ; size_t written_count = count ; if ( command >= ARRAY_SIZE ( uverbs_ex_cmd_table ) || ! uverbs_ex_cmd_table [ command ] ) { ret = - ENOSYS ; goto out ; } if ( ! file -> ucontext ) { ret = - EINVAL ; goto out ; } if ( count < ( sizeof ( hdr ) + sizeof ( ex_hdr ) ) ) { ret = - EINVAL ; goto out ; } if ( copy_from_user ( & ex_hdr , buf + sizeof ( hdr ) , sizeof ( ex_hdr ) ) ) { ret = - EFAULT ; goto out ; } count -= sizeof ( hdr ) + sizeof ( ex_hdr ) ; buf += sizeof ( hdr ) + sizeof ( ex_hdr ) ; if ( ( hdr . in_words + ex_hdr . provider_in_words ) * 8 != count ) { ret = - EINVAL ; goto out ; } if ( ex_hdr . cmd_hdr_reserved ) { ret = - EINVAL ; goto out ; } if ( ex_hdr . response ) { if ( ! hdr . out_words && ! ex_hdr . provider_out_words ) { ret = - EINVAL ; goto out ; } if ( ! access_ok ( VERIFY_WRITE , ( void __user * ) ( unsigned long ) ex_hdr . response , ( hdr . out_words + ex_hdr . provider_out_words ) * 8 ) ) { ret = - EFAULT ; goto out ; } } else { if ( hdr . out_words || ex_hdr . provider_out_words ) { ret = - EINVAL ; goto out ; } } INIT_UDATA_BUF_OR_NULL ( & ucore , buf , ( unsigned long ) ex_hdr . response , hdr . in_words * 8 , hdr . out_words * 8 ) ; INIT_UDATA_BUF_OR_NULL ( & uhw , buf + ucore . inlen , ( unsigned long ) ex_hdr . response + ucore . outlen , ex_hdr . provider_in_words * 8 , ex_hdr . provider_out_words * 8 ) ; ret = uverbs_ex_cmd_table [ command ] ( file , ib_dev , & ucore , & uhw ) ; if ( ! ret ) ret = written_count ; } else { ret = - ENOSYS ; } out : srcu_read_unlock ( & file -> device -> disassociate_srcu , srcu_key ) ; return ret ; }\n","target":"<S2SV_ModStart> ; if ( WARN_ON_ONCE ( ! ib_safe_file_access ( filp ) ) ) return - EACCES ; if (\n","project_and_commit_id":"torvalds@linux/e6bd18f57aad1a2d1ef40e646d03ed0f2515c9e3","cve_id":"CVE-2016-4565","original_address":"https://github.com/torvalds/linux/commit/e6bd18f57aad1a2d1ef40e646d03ed0f2515c9e3","time":"2016-05-23T10:59Z"},
	{"Unnamed: 0":3629,"cwe_id":"CWE-119","source":"CWE-119 static void set_active_map ( const vpx_codec_enc_cfg_t * cfg , vpx_codec_ctx_t * codec ) { unsigned int i ; <S2SV_StartBug> vpx_active_map_t map = { 0 } ; <S2SV_EndBug> map . rows = ( cfg -> g_h + 15 ) / 16 ; map . cols = ( cfg -> g_w + 15 ) / 16 ; map . active_map = ( uint8_t * ) malloc ( map . rows * map . cols ) ; for ( i = 0 ; i < map . rows * map . cols ; ++ i ) map . active_map [ i ] = i % 2 ; if ( vpx_codec_control ( codec , VP8E_SET_ACTIVEMAP , & map ) ) die_codec ( codec , \"Failed<S2SV_blank>to<S2SV_blank>set<S2SV_blank>active<S2SV_blank>map\" ) ; free ( map . active_map ) ; }\n","target":"<S2SV_ModStart> map = { 0 , 0 ,\n","project_and_commit_id":"external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426","cve_id":"CVE-2016-1621","original_address":"https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426","time":"2016-03-12T21:59Z"},
	{"Unnamed: 0":3393,"cwe_id":"CWE-125","source":"CWE-125 u_int ieee802_15_4_if_print ( netdissect_options * ndo , const struct pcap_pkthdr * h , const u_char * p ) { u_int caplen = h -> caplen ; u_int hdrlen ; uint16_t fc ; uint8_t seq ; uint16_t panid = 0 ; if ( caplen < 3 ) { ND_PRINT ( ( ndo , \"[|802.15.4]\" ) ) ; return caplen ; } hdrlen = 3 ; fc = EXTRACT_LE_16BITS ( p ) ; seq = EXTRACT_LE_8BITS ( p + 2 ) ; p += 3 ; caplen -= 3 ; ND_PRINT ( ( ndo , \"IEEE<S2SV_blank>802.15.4<S2SV_blank>%s<S2SV_blank>packet<S2SV_blank>\" , ftypes [ FC_FRAME_TYPE ( fc ) ] ) ) ; if ( ndo -> ndo_vflag ) ND_PRINT ( ( ndo , \"seq<S2SV_blank>%02x<S2SV_blank>\" , seq ) ) ; switch ( FC_DEST_ADDRESSING_MODE ( fc ) ) { case FC_ADDRESSING_MODE_NONE : if ( fc & FC_PAN_ID_COMPRESSION ) { ND_PRINT ( ( ndo , \"[|802.15.4]\" ) ) ; return hdrlen ; } if ( ndo -> ndo_vflag ) ND_PRINT ( ( ndo , \"none<S2SV_blank>\" ) ) ; break ; case FC_ADDRESSING_MODE_RESERVED : if ( ndo -> ndo_vflag ) ND_PRINT ( ( ndo , \"reserved<S2SV_blank>destination<S2SV_blank>addressing<S2SV_blank>mode\" ) ) ; return hdrlen ; case FC_ADDRESSING_MODE_SHORT : if ( caplen < 2 ) { ND_PRINT ( ( ndo , \"[|802.15.4]\" ) ) ; return hdrlen ; } panid = EXTRACT_LE_16BITS ( p ) ; p += 2 ; caplen -= 2 ; hdrlen += 2 ; if ( caplen < 2 ) { ND_PRINT ( ( ndo , \"[|802.15.4]\" ) ) ; return hdrlen ; } if ( ndo -> ndo_vflag ) ND_PRINT ( ( ndo , \"%04x:%04x<S2SV_blank>\" , panid , EXTRACT_LE_16BITS ( p + 2 ) ) ) ; p += 2 ; caplen -= 2 ; hdrlen += 2 ; break ; case FC_ADDRESSING_MODE_LONG : if ( caplen < 2 ) { ND_PRINT ( ( ndo , \"[|802.15.4]\" ) ) ; return hdrlen ; } panid = EXTRACT_LE_16BITS ( p ) ; p += 2 ; caplen -= 2 ; hdrlen += 2 ; if ( caplen < 8 ) { ND_PRINT ( ( ndo , \"[|802.15.4]\" ) ) ; return hdrlen ; } if ( ndo -> ndo_vflag ) <S2SV_StartBug> ND_PRINT ( ( ndo , \"%04x:%s<S2SV_blank>\" , panid , le64addr_string ( ndo , p + 2 ) ) ) ; <S2SV_EndBug> p += 8 ; caplen -= 8 ; hdrlen += 8 ; break ; } if ( ndo -> ndo_vflag ) ND_PRINT ( ( ndo , \"<<S2SV_blank>\" ) ) ; switch ( FC_SRC_ADDRESSING_MODE ( fc ) ) { case FC_ADDRESSING_MODE_NONE : if ( ndo -> ndo_vflag ) ND_PRINT ( ( ndo , \"none<S2SV_blank>\" ) ) ; break ; case FC_ADDRESSING_MODE_RESERVED : if ( ndo -> ndo_vflag ) ND_PRINT ( ( ndo , \"reserved<S2SV_blank>source<S2SV_blank>addressing<S2SV_blank>mode\" ) ) ; return 0 ; case FC_ADDRESSING_MODE_SHORT : if ( ! ( fc & FC_PAN_ID_COMPRESSION ) ) { if ( caplen < 2 ) { ND_PRINT ( ( ndo , \"[|802.15.4]\" ) ) ; return hdrlen ; } panid = EXTRACT_LE_16BITS ( p ) ; p += 2 ; caplen -= 2 ; hdrlen += 2 ; } if ( caplen < 2 ) { ND_PRINT ( ( ndo , \"[|802.15.4]\" ) ) ; return hdrlen ; } if ( ndo -> ndo_vflag ) ND_PRINT ( ( ndo , \"%04x:%04x<S2SV_blank>\" , panid , EXTRACT_LE_16BITS ( p ) ) ) ; p += 2 ; caplen -= 2 ; hdrlen += 2 ; break ; case FC_ADDRESSING_MODE_LONG : if ( ! ( fc & FC_PAN_ID_COMPRESSION ) ) { if ( caplen < 2 ) { ND_PRINT ( ( ndo , \"[|802.15.4]\" ) ) ; return hdrlen ; } panid = EXTRACT_LE_16BITS ( p ) ; p += 2 ; caplen -= 2 ; hdrlen += 2 ; } if ( caplen < 8 ) { ND_PRINT ( ( ndo , \"[|802.15.4]\" ) ) ; return hdrlen ; } if ( ndo -> ndo_vflag ) ND_PRINT ( ( ndo , \"%04x:%s<S2SV_blank>\" , panid , le64addr_string ( ndo , p ) ) ) ; p += 8 ; caplen -= 8 ; hdrlen += 8 ; break ; } if ( ! ndo -> ndo_suppress_default_print ) ND_DEFAULTPRINT ( p , caplen ) ; return hdrlen ; }\n","target":"<S2SV_ModStart> ndo , p <S2SV_ModEnd> ) ) )\n","project_and_commit_id":"the-tcpdump-group@tcpdump/a7e5f58f402e6919ec444a57946bade7dfd6b184","cve_id":"CVE-2017-13000","original_address":"https://github.com/the-tcpdump-group/tcpdump/commit/a7e5f58f402e6919ec444a57946bade7dfd6b184","time":"2017-09-14T06:29Z"},
	{"Unnamed: 0":2044,"cwe_id":"CWE-119","source":"CWE-119 static void GTextFieldSave ( GTextField * gt , int utf8 ) { unichar_t * ret ; char * cret ; FILE * file ; unichar_t * pt ; if ( _ggadget_use_gettext ) { char * temp = GWidgetOpenFile8 ( _ ( \"Save\" ) , NULL , \"*.{txt,py}\" , NULL , NULL ) ; ret = utf82u_copy ( temp ) ; free ( temp ) ; } else ret = GWidgetSaveAsFile ( GStringGetResource ( _STR_Save , NULL ) , NULL , txt , NULL , NULL ) ; if ( ret == NULL ) return ; cret = u2def_copy ( ret ) ; free ( ret ) ; file = fopen ( cret , \"w\" ) ; if ( file == NULL ) { if ( _ggadget_use_gettext ) GWidgetError8 ( _ ( \"Could<S2SV_blank>not<S2SV_blank>open<S2SV_blank>file\" ) , _ ( \"Could<S2SV_blank>not<S2SV_blank>open<S2SV_blank>%.100s\" ) , cret ) ; else GWidgetError ( errort , error , cret ) ; free ( cret ) ; return ; } free ( cret ) ; if ( utf8 ) { putc ( 0xef , file ) ; putc ( 0xbb , file ) ; putc ( 0xbf , file ) ; for ( pt = gt -> text ; * pt ; ++ pt ) { if ( * pt < 0x80 ) putc ( * pt , file ) ; else if ( * pt < 0x800 ) { putc ( 0xc0 | ( * pt >> 6 ) , file ) ; putc ( 0x80 | ( * pt & 0x3f ) , file ) ; } else if ( * pt >= 0xd800 && * pt < 0xdc00 && pt [ 1 ] >= 0xdc00 && pt [ 1 ] < 0xe000 ) { int u = ( ( * pt >> 6 ) & 0xf ) + 1 , y = ( ( * pt & 3 ) << 4 ) | ( ( pt [ 1 ] >> 6 ) & 0xf ) ; putc ( 0xf0 | ( u >> 2 ) , file ) ; putc ( 0x80 | ( ( u & 3 ) << 4 ) | ( ( * pt >> 2 ) & 0xf ) , file ) ; putc ( 0x80 | y , file ) ; putc ( 0x80 | ( pt [ 1 ] & 0x3f ) , file ) ; } else { putc ( 0xe0 | ( * pt >> 12 ) , file ) ; putc ( 0x80 | ( ( * pt >> 6 ) & 0x3f ) , file ) ; putc ( 0x80 | ( * pt & 0x3f ) , file ) ; } } } else { putc ( 0xfeff >> 8 , file ) ; putc ( 0xfeff & 0xff , file ) ; for ( pt = gt -> text ; * pt ; ++ pt ) { putc ( * pt >> 8 , file ) ; putc ( * pt & 0xff , file ) ; } } fclose ( file ) ; <S2SV_StartBug> } <S2SV_EndBug>\n","target":"<S2SV_ModStart> file ) ; GTextFieldSaved ( gt ) ;\n","project_and_commit_id":"fontforge@fontforge/626f751752875a0ddd74b9e217b6f4828713573c","cve_id":"CVE-2019-15785","original_address":"https://github.com/fontforge/fontforge/commit/626f751752875a0ddd74b9e217b6f4828713573c","time":"2019-08-29T13:15Z"},
	{"Unnamed: 0":1145,"cwe_id":"CWE-401","source":"CWE-401 struct clock_source * dce100_clock_source_create ( struct dc_context * ctx , struct dc_bios * bios , enum clock_source_id id , const struct dce110_clk_src_regs * regs , bool dp_clk_src ) { struct dce110_clk_src * clk_src = kzalloc ( sizeof ( struct dce110_clk_src ) , GFP_KERNEL ) ; if ( ! clk_src ) return NULL ; if ( dce110_clk_src_construct ( clk_src , ctx , bios , id , regs , & cs_shift , & cs_mask ) ) { clk_src -> base . dp_clk_src = dp_clk_src ; return & clk_src -> base ; } <S2SV_StartBug> BREAK_TO_DEBUGGER ( ) ; <S2SV_EndBug> return NULL ; }\n","target":"<S2SV_ModStart> base ; } kfree ( clk_src ) ;\n","project_and_commit_id":"torvalds@linux/055e547478a11a6360c7ce05e2afc3e366968a12","cve_id":"CVE-2019-19083","original_address":"https://github.com/torvalds/linux/commit/055e547478a11a6360c7ce05e2afc3e366968a12","time":"2019-11-18T06:15Z"},
	{"Unnamed: 0":4072,"cwe_id":"CWE-415","source":"CWE-415 static int read_public_key ( RSA * rsa ) { int r ; sc_path_t path ; sc_file_t * file ; u8 buf [ 2048 ] , * p = buf ; size_t bufsize , keysize ; r = select_app_df ( ) ; if ( r ) return 1 ; sc_format_path ( \"I1012\" , & path ) ; r = sc_select_file ( card , & path , & file ) ; if ( r ) { fprintf ( stderr , \"Unable<S2SV_blank>to<S2SV_blank>select<S2SV_blank>public<S2SV_blank>key<S2SV_blank>file:<S2SV_blank>%s\\\\n\" , sc_strerror ( r ) ) ; return 2 ; } <S2SV_StartBug> bufsize = file -> size ; <S2SV_EndBug> sc_file_free ( file ) ; r = sc_read_binary ( card , 0 , buf , bufsize , 0 ) ; if ( r < 0 ) { fprintf ( stderr , \"Unable<S2SV_blank>to<S2SV_blank>read<S2SV_blank>public<S2SV_blank>key<S2SV_blank>file:<S2SV_blank>%s\\\\n\" , sc_strerror ( r ) ) ; return 2 ; } bufsize = r ; do { if ( bufsize < 4 ) return 3 ; keysize = ( p [ 0 ] << 8 ) | p [ 1 ] ; if ( keysize == 0 ) break ; if ( keysize < 3 ) return 3 ; if ( p [ 2 ] == opt_key_num ) break ; p += keysize ; bufsize -= keysize ; } while ( 1 ) ; if ( keysize == 0 ) { printf ( \"Key<S2SV_blank>number<S2SV_blank>%d<S2SV_blank>not<S2SV_blank>found.\\\\n\" , opt_key_num ) ; return 2 ; } return parse_public_key ( p , keysize , rsa ) ; }\n","target":"<S2SV_ModStart> } bufsize = MIN ( <S2SV_ModStart> file -> size , sizeof buf )\n","project_and_commit_id":"OpenSC@OpenSC/360e95d45ac4123255a4c796db96337f332160ad","cve_id":"CVE-2018-16425","original_address":"https://github.com/OpenSC/OpenSC/commit/360e95d45ac4123255a4c796db96337f332160ad","time":"2018-09-04T00:29Z"},
	{"Unnamed: 0":5337,"cwe_id":"CWE-416","source":"CWE-416 static void timerfd_setup_cancel ( struct timerfd_ctx * ctx , int flags ) <S2SV_StartBug> { <S2SV_EndBug> if ( ( ctx -> clockid == CLOCK_REALTIME || ctx -> clockid == CLOCK_REALTIME_ALARM ) && ( flags & TFD_TIMER_ABSTIME ) && ( flags & TFD_TIMER_CANCEL_ON_SET ) ) { if ( ! ctx -> might_cancel ) { ctx -> might_cancel = true ; spin_lock ( & cancel_lock ) ; list_add_rcu ( & ctx -> clist , & cancel_list ) ; spin_unlock ( & cancel_lock ) ; } <S2SV_StartBug> } else if ( ctx -> might_cancel ) { <S2SV_EndBug> timerfd_remove_cancel ( ctx ) ; } <S2SV_StartBug> } <S2SV_EndBug>\n","target":"<S2SV_ModStart> flags ) { spin_lock ( & ctx -> cancel_lock ) ; <S2SV_ModStart> } } else { __timerfd_remove_cancel <S2SV_ModEnd> ( ctx ) <S2SV_ModStart> ) ; } spin_unlock ( & ctx -> cancel_lock ) ;\n","project_and_commit_id":"torvalds@linux/1e38da300e1e395a15048b0af1e5305bd91402f6","cve_id":"CVE-2017-10661","original_address":"https://github.com/torvalds/linux/commit/1e38da300e1e395a15048b0af1e5305bd91402f6","time":"2017-08-19T18:29Z"},
	{"Unnamed: 0":2029,"cwe_id":"CWE-119","source":"CWE-119 static inline void header_put_le_int ( SF_PRIVATE * psf , int x ) <S2SV_StartBug> { if ( psf -> headindex < SIGNED_SIZEOF ( psf -> header ) - 4 ) <S2SV_EndBug> <S2SV_StartBug> { psf -> header [ psf -> headindex ++ ] = x ; <S2SV_EndBug> <S2SV_StartBug> psf -> header [ psf -> headindex ++ ] = ( x >> 8 ) ; <S2SV_EndBug> <S2SV_StartBug> psf -> header [ psf -> headindex ++ ] = ( x >> 16 ) ; <S2SV_EndBug> <S2SV_StartBug> psf -> header [ psf -> headindex ++ ] = ( x >> 24 ) ; <S2SV_EndBug> <S2SV_StartBug> } ; <S2SV_EndBug> }\n","target":"<S2SV_ModStart> x ) { <S2SV_ModEnd> psf -> header <S2SV_ModStart> psf -> header . ptr [ <S2SV_ModEnd> psf -> header <S2SV_ModStart> psf -> header . indx <S2SV_ModEnd> ++ ] = <S2SV_ModStart> psf -> header . ptr <S2SV_ModStart> [ psf -> header . indx <S2SV_ModEnd> ++ ] = <S2SV_ModStart> psf -> header . ptr <S2SV_ModStart> [ psf -> header . indx <S2SV_ModEnd> ++ ] = <S2SV_ModStart> psf -> header . ptr <S2SV_ModStart> [ psf -> header . indx <S2SV_ModEnd> ++ ] = <S2SV_ModStart> ) ; } <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null>\n","project_and_commit_id":"erikd@libsndfile/708e996c87c5fae77b104ccfeb8f6db784c32074","cve_id":"CVE-2017-7586","original_address":"https://github.com/erikd/libsndfile/commit/708e996c87c5fae77b104ccfeb8f6db784c32074","time":"2017-04-07T20:59Z"},
	{"Unnamed: 0":3154,"cwe_id":"CWE-772","source":"CWE-772 static int hwsim_new_radio_nl ( struct sk_buff * msg , struct genl_info * info ) { struct hwsim_new_radio_params param = { 0 } ; const char * hwname = NULL ; int ret ; param . reg_strict = info -> attrs [ HWSIM_ATTR_REG_STRICT_REG ] ; param . p2p_device = info -> attrs [ HWSIM_ATTR_SUPPORT_P2P_DEVICE ] ; param . channels = channels ; param . destroy_on_close = info -> attrs [ HWSIM_ATTR_DESTROY_RADIO_ON_CLOSE ] ; if ( info -> attrs [ HWSIM_ATTR_CHANNELS ] ) param . channels = nla_get_u32 ( info -> attrs [ HWSIM_ATTR_CHANNELS ] ) ; if ( info -> attrs [ HWSIM_ATTR_NO_VIF ] ) param . no_vif = true ; if ( info -> attrs [ HWSIM_ATTR_RADIO_NAME ] ) { hwname = kasprintf ( GFP_KERNEL , \"%.*s\" , nla_len ( info -> attrs [ HWSIM_ATTR_RADIO_NAME ] ) , ( char * ) nla_data ( info -> attrs [ HWSIM_ATTR_RADIO_NAME ] ) ) ; if ( ! hwname ) return - ENOMEM ; param . hwname = hwname ; } if ( info -> attrs [ HWSIM_ATTR_USE_CHANCTX ] ) param . use_chanctx = true ; else param . use_chanctx = ( param . channels > 1 ) ; if ( info -> attrs [ HWSIM_ATTR_REG_HINT_ALPHA2 ] ) param . reg_alpha2 = nla_data ( info -> attrs [ HWSIM_ATTR_REG_HINT_ALPHA2 ] ) ; if ( info -> attrs [ HWSIM_ATTR_REG_CUSTOM_REG ] ) { u32 idx = nla_get_u32 ( info -> attrs [ HWSIM_ATTR_REG_CUSTOM_REG ] ) ; <S2SV_StartBug> if ( idx >= ARRAY_SIZE ( hwsim_world_regdom_custom ) ) <S2SV_EndBug> return - EINVAL ; <S2SV_StartBug> param . regd = hwsim_world_regdom_custom [ idx ] ; <S2SV_EndBug> } ret = mac80211_hwsim_new_radio ( info , & param ) ; kfree ( hwname ) ; return ret ; }\n","target":"<S2SV_ModStart> hwsim_world_regdom_custom ) ) { kfree ( hwname ) ; <S2SV_ModStart> - EINVAL ; }\n","project_and_commit_id":"torvalds@linux/0ddcff49b672239dda94d70d0fcf50317a9f4b51","cve_id":"CVE-2018-8087","original_address":"https://github.com/torvalds/linux/commit/0ddcff49b672239dda94d70d0fcf50317a9f4b51","time":"2018-03-13T06:29Z"},
	{"Unnamed: 0":1587,"cwe_id":"CWE-125","source":"CWE-125 static inline void get_conn_text ( const conn * c , const int af , char * addr , struct sockaddr * sock_addr ) { char addr_text [ MAXPATHLEN ] ; addr_text [ 0 ] = '\\\\0' ; const char * protoname = \"?\" ; unsigned short port = 0 ; <S2SV_StartBug> switch ( af ) { <S2SV_EndBug> case AF_INET : ( void ) inet_ntop ( af , & ( ( struct sockaddr_in * ) sock_addr ) -> sin_addr , addr_text , sizeof ( addr_text ) - 1 ) ; port = ntohs ( ( ( struct sockaddr_in * ) sock_addr ) -> sin_port ) ; protoname = IS_UDP ( c -> transport ) ? \"udp\" : \"tcp\" ; break ; case AF_INET6 : addr_text [ 0 ] = '[' ; addr_text [ 1 ] = '\\\\0' ; if ( inet_ntop ( af , & ( ( struct sockaddr_in6 * ) sock_addr ) -> sin6_addr , addr_text + 1 , sizeof ( addr_text ) - 2 ) ) { strcat ( addr_text , \"]\" ) ; } port = ntohs ( ( ( struct sockaddr_in6 * ) sock_addr ) -> sin6_port ) ; protoname = IS_UDP ( c -> transport ) ? \"udp6\" : \"tcp6\" ; break ; case AF_UNIX : <S2SV_StartBug> strncpy ( addr_text , <S2SV_EndBug> <S2SV_StartBug> ( ( struct sockaddr_un * ) sock_addr ) -> sun_path , <S2SV_EndBug> sizeof ( addr_text ) - 1 ) ; addr_text [ sizeof ( addr_text ) - 1 ] = '\\\\0' ; protoname = \"unix\" ; break ; } if ( strlen ( addr_text ) < 2 ) { sprintf ( addr_text , \"<AF<S2SV_blank>%d>\" , af ) ; } if ( port ) { sprintf ( addr , \"%s:%s:%u\" , protoname , addr_text , port ) ; } else { sprintf ( addr , \"%s:%s\" , protoname , addr_text ) ; } }\n","target":"<S2SV_ModStart> = 0 ; size_t pathlen = 0 ; <S2SV_ModStart> case AF_UNIX : pathlen = sizeof ( <S2SV_ModEnd> ( ( struct <S2SV_ModStart> ) -> sun_path ) ; if ( MAXPATHLEN <= pathlen ) { pathlen = MAXPATHLEN - 1 ; } strncpy ( addr_text , ( ( struct sockaddr_un * ) sock_addr ) -> sun_path , pathlen ) ; addr_text [ pathlen <S2SV_ModEnd> ] = '\\\\0'\n","project_and_commit_id":"memcached@memcached/554b56687a19300a75ec24184746b5512580c819","cve_id":"CVE-2019-15026","original_address":"https://github.com/memcached/memcached/commit/554b56687a19300a75ec24184746b5512580c819","time":"2019-08-30T15:15Z"},
	{"Unnamed: 0":315,"cwe_id":"CWE-20","source":"CWE-20 static int zip_read_mac_metadata ( struct archive_read * a , struct archive_entry * entry , struct zip_entry * rsrc ) { struct zip * zip = ( struct zip * ) a -> format -> data ; unsigned char * metadata , * mp ; int64_t offset = archive_filter_bytes ( & a -> archive , 0 ) ; size_t remaining_bytes , metadata_bytes ; ssize_t hsize ; int ret = ARCHIVE_OK , eof ; switch ( rsrc -> compression ) { <S2SV_StartBug> case 0 : <S2SV_EndBug> # ifdef HAVE_ZLIB_H case 8 : # endif break ; default : archive_set_error ( & a -> archive , ARCHIVE_ERRNO_FILE_FORMAT , \"Unsupported<S2SV_blank>ZIP<S2SV_blank>compression<S2SV_blank>method<S2SV_blank>(%s)\" , compression_name ( rsrc -> compression ) ) ; return ( ARCHIVE_WARN ) ; } if ( rsrc -> uncompressed_size > ( 4 * 1024 * 1024 ) ) { archive_set_error ( & a -> archive , ARCHIVE_ERRNO_FILE_FORMAT , \"Mac<S2SV_blank>metadata<S2SV_blank>is<S2SV_blank>too<S2SV_blank>large:<S2SV_blank>%jd<S2SV_blank>><S2SV_blank>4M<S2SV_blank>bytes\" , <S2SV_StartBug> ( intmax_t ) rsrc -> uncompressed_size ) ; <S2SV_EndBug> return ( ARCHIVE_WARN ) ; } metadata = malloc ( ( size_t ) rsrc -> uncompressed_size ) ; if ( metadata == NULL ) { archive_set_error ( & a -> archive , ENOMEM , \"Can\\'t<S2SV_blank>allocate<S2SV_blank>memory<S2SV_blank>for<S2SV_blank>Mac<S2SV_blank>metadata\" ) ; return ( ARCHIVE_FATAL ) ; } if ( offset < rsrc -> local_header_offset ) __archive_read_consume ( a , rsrc -> local_header_offset - offset ) ; else if ( offset != rsrc -> local_header_offset ) { __archive_read_seek ( a , rsrc -> local_header_offset , SEEK_SET ) ; } hsize = zip_get_local_file_header_size ( a , 0 ) ; __archive_read_consume ( a , hsize ) ; remaining_bytes = ( size_t ) rsrc -> compressed_size ; metadata_bytes = ( size_t ) rsrc -> uncompressed_size ; mp = metadata ; eof = 0 ; while ( ! eof && remaining_bytes ) { const unsigned char * p ; ssize_t bytes_avail ; size_t bytes_used ; p = __archive_read_ahead ( a , 1 , & bytes_avail ) ; if ( p == NULL ) { archive_set_error ( & a -> archive , ARCHIVE_ERRNO_FILE_FORMAT , \"Truncated<S2SV_blank>ZIP<S2SV_blank>file<S2SV_blank>header\" ) ; ret = ARCHIVE_WARN ; goto exit_mac_metadata ; } if ( ( size_t ) bytes_avail > remaining_bytes ) bytes_avail = remaining_bytes ; switch ( rsrc -> compression ) { case 0 : <S2SV_StartBug> memcpy ( mp , p , bytes_avail ) ; <S2SV_EndBug> bytes_used = ( size_t ) bytes_avail ; metadata_bytes -= bytes_used ; mp += bytes_used ; if ( metadata_bytes == 0 ) eof = 1 ; break ; # ifdef HAVE_ZLIB_H case 8 : { int r ; ret = zip_deflate_init ( a , zip ) ; if ( ret != ARCHIVE_OK ) goto exit_mac_metadata ; zip -> stream . next_in = ( Bytef * ) ( uintptr_t ) ( const void * ) p ; zip -> stream . avail_in = ( uInt ) bytes_avail ; zip -> stream . total_in = 0 ; zip -> stream . next_out = mp ; zip -> stream . avail_out = ( uInt ) metadata_bytes ; zip -> stream . total_out = 0 ; r = inflate ( & zip -> stream , 0 ) ; switch ( r ) { case Z_OK : break ; case Z_STREAM_END : eof = 1 ; break ; case Z_MEM_ERROR : archive_set_error ( & a -> archive , ENOMEM , \"Out<S2SV_blank>of<S2SV_blank>memory<S2SV_blank>for<S2SV_blank>ZIP<S2SV_blank>decompression\" ) ; ret = ARCHIVE_FATAL ; goto exit_mac_metadata ; default : archive_set_error ( & a -> archive , ARCHIVE_ERRNO_MISC , \"ZIP<S2SV_blank>decompression<S2SV_blank>failed<S2SV_blank>(%d)\" , r ) ; ret = ARCHIVE_FATAL ; goto exit_mac_metadata ; } bytes_used = zip -> stream . total_in ; metadata_bytes -= zip -> stream . total_out ; mp += zip -> stream . total_out ; break ; } # endif default : bytes_used = 0 ; break ; } __archive_read_consume ( a , bytes_used ) ; remaining_bytes -= bytes_used ; } archive_entry_copy_mac_metadata ( entry , metadata , ( size_t ) rsrc -> uncompressed_size - metadata_bytes ) ; exit_mac_metadata : __archive_read_seek ( a , offset , SEEK_SET ) ; zip -> decompress_init = 0 ; free ( metadata ) ; return ( ret ) ; }\n","target":"<S2SV_ModStart> case 0 : if ( rsrc -> uncompressed_size != rsrc -> compressed_size ) { archive_set_error ( & a -> archive , ARCHIVE_ERRNO_FILE_FORMAT , \"Malformed<S2SV_blank>OS<S2SV_blank>X<S2SV_blank>metadata<S2SV_blank>entry:<S2SV_blank>inconsistent<S2SV_blank>size\" ) ; return ( ARCHIVE_FATAL ) ; } <S2SV_ModStart> rsrc -> uncompressed_size ) ; return ( ARCHIVE_WARN ) ; } if ( rsrc -> compressed_size > ( 4 * 1024 * 1024 ) ) { archive_set_error ( & a -> archive , ARCHIVE_ERRNO_FILE_FORMAT , \"Mac<S2SV_blank>metadata<S2SV_blank>is<S2SV_blank>too<S2SV_blank>large:<S2SV_blank>%jd<S2SV_blank>><S2SV_blank>4M<S2SV_blank>bytes\" , ( intmax_t ) rsrc -> compressed_size <S2SV_ModStart> case 0 : if ( ( size_t ) bytes_avail > metadata_bytes ) bytes_avail = metadata_bytes ;\n","project_and_commit_id":"libarchive@libarchive/d0331e8e5b05b475f20b1f3101fe1ad772d7e7e7","cve_id":"CVE-2016-1541","original_address":"https://github.com/libarchive/libarchive/commit/d0331e8e5b05b475f20b1f3101fe1ad772d7e7e7","time":"2016-05-07T10:59Z"},
	{"Unnamed: 0":2882,"cwe_id":"CWE-119","source":"CWE-119 static void wdm_in_callback ( struct urb * urb ) { struct wdm_device * desc = urb -> context ; int status = urb -> status ; <S2SV_StartBug> spin_lock ( & desc -> iuspin ) ; <S2SV_EndBug> clear_bit ( WDM_RESPONDING , & desc -> flags ) ; if ( status ) { switch ( status ) { case - ENOENT : dev_dbg ( & desc -> intf -> dev , \"nonzero<S2SV_blank>urb<S2SV_blank>status<S2SV_blank>received:<S2SV_blank>-ENOENT\" ) ; goto skip_error ; case - ECONNRESET : dev_dbg ( & desc -> intf -> dev , \"nonzero<S2SV_blank>urb<S2SV_blank>status<S2SV_blank>received:<S2SV_blank>-ECONNRESET\" ) ; goto skip_error ; case - ESHUTDOWN : dev_dbg ( & desc -> intf -> dev , \"nonzero<S2SV_blank>urb<S2SV_blank>status<S2SV_blank>received:<S2SV_blank>-ESHUTDOWN\" ) ; goto skip_error ; case - EPIPE : dev_err ( & desc -> intf -> dev , \"nonzero<S2SV_blank>urb<S2SV_blank>status<S2SV_blank>received:<S2SV_blank>-EPIPE\\\\n\" ) ; break ; default : dev_err ( & desc -> intf -> dev , \"Unexpected<S2SV_blank>error<S2SV_blank>%d\\\\n\" , status ) ; break ; } } desc -> rerr = status ; <S2SV_StartBug> desc -> reslength = urb -> actual_length ; <S2SV_EndBug> <S2SV_StartBug> memmove ( desc -> ubuf + desc -> length , desc -> inbuf , desc -> reslength ) ; <S2SV_EndBug> desc -> length += desc -> reslength ; skip_error : wake_up ( & desc -> wait ) ; set_bit ( WDM_READ , & desc -> flags ) ; spin_unlock ( & desc -> iuspin ) ; }\n","target":"<S2SV_ModStart> -> status ; int length = urb -> actual_length ; <S2SV_ModStart> = status ; if ( length + desc -> length > desc -> wMaxCommand ) { set_bit ( WDM_OVERFLOW , & desc -> flags ) ; } else { if ( ! test_bit ( WDM_OVERFLOW , & desc -> flags ) ) { <S2SV_ModEnd> memmove ( desc <S2SV_ModStart> -> inbuf , length ) ; desc -> length += length ; <S2SV_ModStart> desc -> reslength = length ; } } <S2SV_ModEnd> skip_error : wake_up\n","project_and_commit_id":"torvalds@linux/c0f5ecee4e741667b2493c742b60b6218d40b3aa","cve_id":"CVE-2013-1860","original_address":"https://github.com/torvalds/linux/commit/c0f5ecee4e741667b2493c742b60b6218d40b3aa","time":"2013-03-22T11:59Z"},
	{"Unnamed: 0":2535,"cwe_id":"CWE-119","source":"CWE-119 <S2SV_StartBug> static vpx_codec_err_t vp8_set_postproc ( vpx_codec_alg_priv_t * ctx , <S2SV_EndBug> int ctr_id , va_list args ) { # if CONFIG_POSTPROC vp8_postproc_cfg_t * data = va_arg ( args , vp8_postproc_cfg_t * ) ; if ( data ) { ctx -> postproc_cfg_set = 1 ; ctx -> postproc_cfg = * ( ( vp8_postproc_cfg_t * ) data ) ; return VPX_CODEC_OK ; } else return VPX_CODEC_INVALID_PARAM ; # else <S2SV_StartBug> return VPX_CODEC_INCAPABLE ; <S2SV_EndBug> # endif }\n","target":"<S2SV_ModStart> vpx_codec_alg_priv_t * ctx <S2SV_ModEnd> , va_list args <S2SV_ModStart> ; # else ( void ) ctx ; ( void ) args ;\n","project_and_commit_id":"external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426","cve_id":"CVE-2016-1621","original_address":"https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426","time":"2016-03-12T21:59Z"},
	{"Unnamed: 0":2039,"cwe_id":"CWE-119","source":"CWE-119 static Bool FFD_CanHandleURL ( GF_InputService * plug , const char * url ) { Bool has_audio , has_video ; s32 i ; AVFormatContext * ctx ; AVOutputFormat * fmt_out ; Bool ret = GF_FALSE ; <S2SV_StartBug> char * ext , szName [ 1000 ] , szExt [ 20 ] ; <S2SV_EndBug> const char * szExtList ; FFDemux * ffd ; if ( ! plug || ! url ) return GF_FALSE ; if ( ! strnicmp ( url , \"rtsp://\" , 7 ) ) return GF_FALSE ; if ( ! strnicmp ( url , \"rtspu://\" , 8 ) ) return GF_FALSE ; if ( ! strnicmp ( url , \"rtp://\" , 6 ) ) return GF_FALSE ; if ( ! strnicmp ( url , \"plato://\" , 8 ) ) return GF_FALSE ; if ( ! strnicmp ( url , \"udp://\" , 6 ) ) return GF_FALSE ; if ( ! strnicmp ( url , \"tcp://\" , 6 ) ) return GF_FALSE ; if ( ! strnicmp ( url , \"data:\" , 5 ) ) return GF_FALSE ; ffd = ( FFDemux * ) plug -> priv ; <S2SV_StartBug> strcpy ( szName , url ) ; <S2SV_EndBug> ext = strrchr ( szName , '#' ) ; if ( ext ) ext [ 0 ] = 0 ; ext = strrchr ( szName , '?' ) ; if ( ext ) ext [ 0 ] = 0 ; ext = strrchr ( szName , '.' ) ; if ( ext && strlen ( ext ) > 19 ) ext = NULL ; <S2SV_StartBug> if ( ext && strlen ( ext ) > 1 ) { <S2SV_EndBug> strcpy ( szExt , & ext [ 1 ] ) ; strlwr ( szExt ) ; # ifndef FFMPEG_DEMUX_ENABLE_MPEG2TS if ( strstr ( \"ts<S2SV_blank>m2t<S2SV_blank>mts<S2SV_blank>dmb<S2SV_blank>trp\" , szExt ) ) return GF_FALSE ; # endif if ( ! strcmp ( szExt , \"mp4\" ) || ! strcmp ( szExt , \"mpg4\" ) || ! strcmp ( szExt , \"m4a\" ) || ! strcmp ( szExt , \"m21\" ) || ! strcmp ( szExt , \"m4v\" ) || ! strcmp ( szExt , \"m4a\" ) || ! strcmp ( szExt , \"m4s\" ) || ! strcmp ( szExt , \"3gs\" ) || ! strcmp ( szExt , \"3gp\" ) || ! strcmp ( szExt , \"3gpp\" ) || ! strcmp ( szExt , \"3gp2\" ) || ! strcmp ( szExt , \"3g2\" ) || ! strcmp ( szExt , \"mp3\" ) || ! strcmp ( szExt , \"ac3\" ) || ! strcmp ( szExt , \"amr\" ) || ! strcmp ( szExt , \"bt\" ) || ! strcmp ( szExt , \"wrl\" ) || ! strcmp ( szExt , \"x3dv\" ) || ! strcmp ( szExt , \"xmt\" ) || ! strcmp ( szExt , \"xmta\" ) || ! strcmp ( szExt , \"x3d\" ) || ! strcmp ( szExt , \"jpg\" ) || ! strcmp ( szExt , \"jpeg\" ) || ! strcmp ( szExt , \"png\" ) ) return GF_FALSE ; { u32 i ; for ( i = 0 ; FFD_MIME_TYPES [ i ] ; i += 3 ) { if ( gf_service_check_mime_register ( plug , FFD_MIME_TYPES [ i ] , FFD_MIME_TYPES [ i + 1 ] , FFD_MIME_TYPES [ i + 2 ] , ext ) ) return GF_TRUE ; } } } ffd_parse_options ( ffd , url ) ; ctx = NULL ; if ( open_file ( & ctx , szName , NULL , ffd -> options ? & ffd -> options : NULL ) < 0 ) { AVInputFormat * av_in = NULL ; if ( ext && ! strcmp ( szExt , \"cmp\" ) ) av_in = av_find_input_format ( \"m4v\" ) ; if ( open_file ( & ctx , szName , av_in , ffd -> options ? & ffd -> options : NULL ) < 0 ) { return GF_FALSE ; } } if ( ! ctx ) goto exit ; if ( av_find_stream_info ( ctx ) < 0 ) goto exit ; has_video = has_audio = GF_FALSE ; for ( i = 0 ; i < ( s32 ) ctx -> nb_streams ; i ++ ) { AVCodecContext * enc = ctx -> streams [ i ] -> codec ; switch ( enc -> codec_type ) { case AVMEDIA_TYPE_AUDIO : if ( ! has_audio ) has_audio = GF_TRUE ; break ; case AVMEDIA_TYPE_VIDEO : if ( ! has_video ) has_video = GF_TRUE ; break ; default : break ; } } if ( ! has_audio && ! has_video ) goto exit ; ret = GF_TRUE ; # if ( ( LIBAVFORMAT_VERSION_MAJOR == 52 ) && ( LIBAVFORMAT_VERSION_MINOR <= 47 ) ) || ( LIBAVFORMAT_VERSION_MAJOR < 52 ) fmt_out = guess_stream_format ( NULL , url , NULL ) ; # else fmt_out = av_guess_format ( NULL , url , NULL ) ; # endif if ( fmt_out ) gf_service_register_mime ( plug , fmt_out -> mime_type , fmt_out -> extensions , fmt_out -> name ) ; else { ext = strrchr ( szName , '.' ) ; if ( ext ) { strcpy ( szExt , & ext [ 1 ] ) ; strlwr ( szExt ) ; szExtList = gf_modules_get_option ( ( GF_BaseInterface * ) plug , \"MimeTypes\" , \"application/x-ffmpeg\" ) ; if ( ! szExtList ) { gf_service_register_mime ( plug , \"application/x-ffmpeg\" , szExt , \"Other<S2SV_blank>Movies<S2SV_blank>(FFMPEG)\" ) ; } else if ( ! strstr ( szExtList , szExt ) ) { u32 len ; char * buf ; len = ( u32 ) ( strlen ( szExtList ) + strlen ( szExt ) + 10 ) ; buf = ( char * ) gf_malloc ( sizeof ( char ) * len ) ; sprintf ( buf , \"\\\\\"%s<S2SV_blank>\" , szExt ) ; strcat ( buf , & szExtList [ 1 ] ) ; gf_modules_set_option ( ( GF_BaseInterface * ) plug , \"MimeTypes\" , \"application/x-ffmpeg\" , buf ) ; gf_free ( buf ) ; } } } exit : # if FF_API_CLOSE_INPUT_FILE if ( ctx ) av_close_input_file ( ctx ) ; # else if ( ctx ) avformat_close_input ( & ctx ) ; # endif return ret ; }\n","target":"<S2SV_ModStart> , szName [ 1024 <S2SV_ModEnd> ] , szExt <S2SV_ModStart> -> priv ; if ( strlen ( url ) >= sizeof ( szName ) ) return GF_FALSE ; <S2SV_ModStart> ) > 1 && strlen ( ext ) <= sizeof ( szExt )\n","project_and_commit_id":"gpac@gpac/35ab4475a7df9b2a4bcab235e379c0c3ec543658","cve_id":"CVE-2018-20762","original_address":"https://github.com/gpac/gpac/commit/35ab4475a7df9b2a4bcab235e379c0c3ec543658","time":"2019-02-06T23:29Z"},
	{"Unnamed: 0":2555,"cwe_id":"CWE-125","source":"CWE-125 static MagickBooleanType GetEXIFProperty ( const Image * image , const char * property , ExceptionInfo * exception ) { # define MaxDirectoryStack 16 # define EXIF_DELIMITER \"\\\\n\" # define EXIF_NUM_FORMATS 12 # define EXIF_FMT_BYTE 1 # define EXIF_FMT_STRING 2 # define EXIF_FMT_USHORT 3 # define EXIF_FMT_ULONG 4 # define EXIF_FMT_URATIONAL 5 # define EXIF_FMT_SBYTE 6 # define EXIF_FMT_UNDEFINED 7 # define EXIF_FMT_SSHORT 8 # define EXIF_FMT_SLONG 9 # define EXIF_FMT_SRATIONAL 10 # define EXIF_FMT_SINGLE 11 # define EXIF_FMT_DOUBLE 12 # define TAG_EXIF_OFFSET 0x8769 # define TAG_GPS_OFFSET 0x8825 # define TAG_INTEROP_OFFSET 0xa005 <S2SV_StartBug> # define EXIFMultipleValues ( size , format , arg ) { ssize_t component ; size_t length ; unsigned char * p1 ; length = 0 ; p1 = p ; for ( component = 0 ; component < components ; component ++ ) { length += FormatLocaleString ( buffer + length , MagickPathExtent - length , format \",<S2SV_blank>\" , arg ) ; if ( length >= ( MagickPathExtent - 1 ) ) length = MagickPathExtent - 1 ; p1 += size ; } if ( length > 1 ) buffer [ length - 2 ] = '\\\\0' ; value = AcquireString ( buffer ) ; } <S2SV_EndBug> <S2SV_StartBug> # define EXIFMultipleFractions ( size , format , arg1 , arg2 ) { ssize_t component ; size_t length ; unsigned char * p1 ; length = 0 ; p1 = p ; for ( component = 0 ; component < components ; component ++ ) { length += FormatLocaleString ( buffer + length , MagickPathExtent - length , format \",<S2SV_blank>\" , ( arg1 ) , ( arg2 ) ) ; if ( length >= ( MagickPathExtent - 1 ) ) length = MagickPathExtent - 1 ; p1 += size ; } if ( length > 1 ) buffer [ length - 2 ] = '\\\\0' ; value = AcquireString ( buffer ) ; } <S2SV_EndBug> typedef struct _DirectoryInfo { const unsigned char * directory ; size_t entry ; ssize_t offset ; } DirectoryInfo ; typedef struct _TagInfo { size_t tag ; const char * description ; } TagInfo ; static TagInfo EXIFTag [ ] = { { 0x001 , \"exif:InteroperabilityIndex\" } , { 0x002 , \"exif:InteroperabilityVersion\" } , { 0x100 , \"exif:ImageWidth\" } , { 0x101 , \"exif:ImageLength\" } , { 0x102 , \"exif:BitsPerSample\" } , { 0x103 , \"exif:Compression\" } , { 0x106 , \"exif:PhotometricInterpretation\" } , { 0x10a , \"exif:FillOrder\" } , { 0x10d , \"exif:DocumentName\" } , { 0x10e , \"exif:ImageDescription\" } , { 0x10f , \"exif:Make\" } , { 0x110 , \"exif:Model\" } , { 0x111 , \"exif:StripOffsets\" } , { 0x112 , \"exif:Orientation\" } , { 0x115 , \"exif:SamplesPerPixel\" } , { 0x116 , \"exif:RowsPerStrip\" } , { 0x117 , \"exif:StripByteCounts\" } , { 0x11a , \"exif:XResolution\" } , { 0x11b , \"exif:YResolution\" } , { 0x11c , \"exif:PlanarConfiguration\" } , { 0x11d , \"exif:PageName\" } , { 0x11e , \"exif:XPosition\" } , { 0x11f , \"exif:YPosition\" } , { 0x118 , \"exif:MinSampleValue\" } , { 0x119 , \"exif:MaxSampleValue\" } , { 0x120 , \"exif:FreeOffsets\" } , { 0x121 , \"exif:FreeByteCounts\" } , { 0x122 , \"exif:GrayResponseUnit\" } , { 0x123 , \"exif:GrayResponseCurve\" } , { 0x124 , \"exif:T4Options\" } , { 0x125 , \"exif:T6Options\" } , { 0x128 , \"exif:ResolutionUnit\" } , { 0x12d , \"exif:TransferFunction\" } , { 0x131 , \"exif:Software\" } , { 0x132 , \"exif:DateTime\" } , { 0x13b , \"exif:Artist\" } , { 0x13e , \"exif:WhitePoint\" } , { 0x13f , \"exif:PrimaryChromaticities\" } , { 0x140 , \"exif:ColorMap\" } , { 0x141 , \"exif:HalfToneHints\" } , { 0x142 , \"exif:TileWidth\" } , { 0x143 , \"exif:TileLength\" } , { 0x144 , \"exif:TileOffsets\" } , { 0x145 , \"exif:TileByteCounts\" } , { 0x14a , \"exif:SubIFD\" } , { 0x14c , \"exif:InkSet\" } , { 0x14d , \"exif:InkNames\" } , { 0x14e , \"exif:NumberOfInks\" } , { 0x150 , \"exif:DotRange\" } , { 0x151 , \"exif:TargetPrinter\" } , { 0x152 , \"exif:ExtraSample\" } , { 0x153 , \"exif:SampleFormat\" } , { 0x154 , \"exif:SMinSampleValue\" } , { 0x155 , \"exif:SMaxSampleValue\" } , { 0x156 , \"exif:TransferRange\" } , { 0x157 , \"exif:ClipPath\" } , { 0x158 , \"exif:XClipPathUnits\" } , { 0x159 , \"exif:YClipPathUnits\" } , { 0x15a , \"exif:Indexed\" } , { 0x15b , \"exif:JPEGTables\" } , { 0x15f , \"exif:OPIProxy\" } , { 0x200 , \"exif:JPEGProc\" } , { 0x201 , \"exif:JPEGInterchangeFormat\" } , { 0x202 , \"exif:JPEGInterchangeFormatLength\" } , { 0x203 , \"exif:JPEGRestartInterval\" } , { 0x205 , \"exif:JPEGLosslessPredictors\" } , { 0x206 , \"exif:JPEGPointTransforms\" } , { 0x207 , \"exif:JPEGQTables\" } , { 0x208 , \"exif:JPEGDCTables\" } , { 0x209 , \"exif:JPEGACTables\" } , { 0x211 , \"exif:YCbCrCoefficients\" } , { 0x212 , \"exif:YCbCrSubSampling\" } , { 0x213 , \"exif:YCbCrPositioning\" } , { 0x214 , \"exif:ReferenceBlackWhite\" } , { 0x2bc , \"exif:ExtensibleMetadataPlatform\" } , { 0x301 , \"exif:Gamma\" } , { 0x302 , \"exif:ICCProfileDescriptor\" } , { 0x303 , \"exif:SRGBRenderingIntent\" } , { 0x320 , \"exif:ImageTitle\" } , { 0x5001 , \"exif:ResolutionXUnit\" } , { 0x5002 , \"exif:ResolutionYUnit\" } , { 0x5003 , \"exif:ResolutionXLengthUnit\" } , { 0x5004 , \"exif:ResolutionYLengthUnit\" } , { 0x5005 , \"exif:PrintFlags\" } , { 0x5006 , \"exif:PrintFlagsVersion\" } , { 0x5007 , \"exif:PrintFlagsCrop\" } , { 0x5008 , \"exif:PrintFlagsBleedWidth\" } , { 0x5009 , \"exif:PrintFlagsBleedWidthScale\" } , { 0x500A , \"exif:HalftoneLPI\" } , { 0x500B , \"exif:HalftoneLPIUnit\" } , { 0x500C , \"exif:HalftoneDegree\" } , { 0x500D , \"exif:HalftoneShape\" } , { 0x500E , \"exif:HalftoneMisc\" } , { 0x500F , \"exif:HalftoneScreen\" } , { 0x5010 , \"exif:JPEGQuality\" } , { 0x5011 , \"exif:GridSize\" } , { 0x5012 , \"exif:ThumbnailFormat\" } , { 0x5013 , \"exif:ThumbnailWidth\" } , { 0x5014 , \"exif:ThumbnailHeight\" } , { 0x5015 , \"exif:ThumbnailColorDepth\" } , { 0x5016 , \"exif:ThumbnailPlanes\" } , { 0x5017 , \"exif:ThumbnailRawBytes\" } , { 0x5018 , \"exif:ThumbnailSize\" } , { 0x5019 , \"exif:ThumbnailCompressedSize\" } , { 0x501a , \"exif:ColorTransferFunction\" } , { 0x501b , \"exif:ThumbnailData\" } , { 0x5020 , \"exif:ThumbnailImageWidth\" } , { 0x5021 , \"exif:ThumbnailImageHeight\" } , { 0x5022 , \"exif:ThumbnailBitsPerSample\" } , { 0x5023 , \"exif:ThumbnailCompression\" } , { 0x5024 , \"exif:ThumbnailPhotometricInterp\" } , { 0x5025 , \"exif:ThumbnailImageDescription\" } , { 0x5026 , \"exif:ThumbnailEquipMake\" } , { 0x5027 , \"exif:ThumbnailEquipModel\" } , { 0x5028 , \"exif:ThumbnailStripOffsets\" } , { 0x5029 , \"exif:ThumbnailOrientation\" } , { 0x502a , \"exif:ThumbnailSamplesPerPixel\" } , { 0x502b , \"exif:ThumbnailRowsPerStrip\" } , { 0x502c , \"exif:ThumbnailStripBytesCount\" } , { 0x502d , \"exif:ThumbnailResolutionX\" } , { 0x502e , \"exif:ThumbnailResolutionY\" } , { 0x502f , \"exif:ThumbnailPlanarConfig\" } , { 0x5030 , \"exif:ThumbnailResolutionUnit\" } , { 0x5031 , \"exif:ThumbnailTransferFunction\" } , { 0x5032 , \"exif:ThumbnailSoftwareUsed\" } , { 0x5033 , \"exif:ThumbnailDateTime\" } , { 0x5034 , \"exif:ThumbnailArtist\" } , { 0x5035 , \"exif:ThumbnailWhitePoint\" } , { 0x5036 , \"exif:ThumbnailPrimaryChromaticities\" } , { 0x5037 , \"exif:ThumbnailYCbCrCoefficients\" } , { 0x5038 , \"exif:ThumbnailYCbCrSubsampling\" } , { 0x5039 , \"exif:ThumbnailYCbCrPositioning\" } , { 0x503A , \"exif:ThumbnailRefBlackWhite\" } , { 0x503B , \"exif:ThumbnailCopyRight\" } , { 0x5090 , \"exif:LuminanceTable\" } , { 0x5091 , \"exif:ChrominanceTable\" } , { 0x5100 , \"exif:FrameDelay\" } , { 0x5101 , \"exif:LoopCount\" } , { 0x5110 , \"exif:PixelUnit\" } , { 0x5111 , \"exif:PixelPerUnitX\" } , { 0x5112 , \"exif:PixelPerUnitY\" } , { 0x5113 , \"exif:PaletteHistogram\" } , { 0x1000 , \"exif:RelatedImageFileFormat\" } , { 0x1001 , \"exif:RelatedImageLength\" } , { 0x1002 , \"exif:RelatedImageWidth\" } , { 0x800d , \"exif:ImageID\" } , { 0x80e3 , \"exif:Matteing\" } , { 0x80e4 , \"exif:DataType\" } , { 0x80e5 , \"exif:ImageDepth\" } , { 0x80e6 , \"exif:TileDepth\" } , { 0x828d , \"exif:CFARepeatPatternDim\" } , { 0x828e , \"exif:CFAPattern2\" } , { 0x828f , \"exif:BatteryLevel\" } , { 0x8298 , \"exif:Copyright\" } , { 0x829a , \"exif:ExposureTime\" } , { 0x829d , \"exif:FNumber\" } , { 0x83bb , \"exif:IPTC/NAA\" } , { 0x84e3 , \"exif:IT8RasterPadding\" } , { 0x84e5 , \"exif:IT8ColorTable\" } , { 0x8649 , \"exif:ImageResourceInformation\" } , { 0x8769 , \"exif:ExifOffset\" } , { 0x8773 , \"exif:InterColorProfile\" } , { 0x8822 , \"exif:ExposureProgram\" } , { 0x8824 , \"exif:SpectralSensitivity\" } , { 0x8825 , \"exif:GPSInfo\" } , { 0x8827 , \"exif:ISOSpeedRatings\" } , { 0x8828 , \"exif:OECF\" } , { 0x8829 , \"exif:Interlace\" } , { 0x882a , \"exif:TimeZoneOffset\" } , { 0x882b , \"exif:SelfTimerMode\" } , { 0x9000 , \"exif:ExifVersion\" } , { 0x9003 , \"exif:DateTimeOriginal\" } , { 0x9004 , \"exif:DateTimeDigitized\" } , { 0x9101 , \"exif:ComponentsConfiguration\" } , { 0x9102 , \"exif:CompressedBitsPerPixel\" } , { 0x9201 , \"exif:ShutterSpeedValue\" } , { 0x9202 , \"exif:ApertureValue\" } , { 0x9203 , \"exif:BrightnessValue\" } , { 0x9204 , \"exif:ExposureBiasValue\" } , { 0x9205 , \"exif:MaxApertureValue\" } , { 0x9206 , \"exif:SubjectDistance\" } , { 0x9207 , \"exif:MeteringMode\" } , { 0x9208 , \"exif:LightSource\" } , { 0x9209 , \"exif:Flash\" } , { 0x920a , \"exif:FocalLength\" } , { 0x920b , \"exif:FlashEnergy\" } , { 0x920c , \"exif:SpatialFrequencyResponse\" } , { 0x920d , \"exif:Noise\" } , { 0x9211 , \"exif:ImageNumber\" } , { 0x9212 , \"exif:SecurityClassification\" } , { 0x9213 , \"exif:ImageHistory\" } , { 0x9214 , \"exif:SubjectArea\" } , { 0x9215 , \"exif:ExposureIndex\" } , { 0x9216 , \"exif:TIFF-EPStandardID\" } , { 0x927c , \"exif:MakerNote\" } , { 0x9C9b , \"exif:WinXP-Title\" } , { 0x9C9c , \"exif:WinXP-Comments\" } , { 0x9C9d , \"exif:WinXP-Author\" } , { 0x9C9e , \"exif:WinXP-Keywords\" } , { 0x9C9f , \"exif:WinXP-Subject\" } , { 0x9286 , \"exif:UserComment\" } , { 0x9290 , \"exif:SubSecTime\" } , { 0x9291 , \"exif:SubSecTimeOriginal\" } , { 0x9292 , \"exif:SubSecTimeDigitized\" } , { 0xa000 , \"exif:FlashPixVersion\" } , { 0xa001 , \"exif:ColorSpace\" } , { 0xa002 , \"exif:ExifImageWidth\" } , { 0xa003 , \"exif:ExifImageLength\" } , { 0xa004 , \"exif:RelatedSoundFile\" } , { 0xa005 , \"exif:InteroperabilityOffset\" } , { 0xa20b , \"exif:FlashEnergy\" } , { 0xa20c , \"exif:SpatialFrequencyResponse\" } , { 0xa20d , \"exif:Noise\" } , { 0xa20e , \"exif:FocalPlaneXResolution\" } , { 0xa20f , \"exif:FocalPlaneYResolution\" } , { 0xa210 , \"exif:FocalPlaneResolutionUnit\" } , { 0xa214 , \"exif:SubjectLocation\" } , { 0xa215 , \"exif:ExposureIndex\" } , { 0xa216 , \"exif:TIFF/EPStandardID\" } , { 0xa217 , \"exif:SensingMethod\" } , { 0xa300 , \"exif:FileSource\" } , { 0xa301 , \"exif:SceneType\" } , { 0xa302 , \"exif:CFAPattern\" } , { 0xa401 , \"exif:CustomRendered\" } , { 0xa402 , \"exif:ExposureMode\" } , { 0xa403 , \"exif:WhiteBalance\" } , { 0xa404 , \"exif:DigitalZoomRatio\" } , { 0xa405 , \"exif:FocalLengthIn35mmFilm\" } , { 0xa406 , \"exif:SceneCaptureType\" } , { 0xa407 , \"exif:GainControl\" } , { 0xa408 , \"exif:Contrast\" } , { 0xa409 , \"exif:Saturation\" } , { 0xa40a , \"exif:Sharpness\" } , { 0xa40b , \"exif:DeviceSettingDescription\" } , { 0xa40c , \"exif:SubjectDistanceRange\" } , { 0xa420 , \"exif:ImageUniqueID\" } , { 0xc4a5 , \"exif:PrintImageMatching\" } , { 0xa500 , \"exif:Gamma\" } , { 0xc640 , \"exif:CR2Slice\" } , { 0x10000 , \"exif:GPSVersionID\" } , { 0x10001 , \"exif:GPSLatitudeRef\" } , { 0x10002 , \"exif:GPSLatitude\" } , { 0x10003 , \"exif:GPSLongitudeRef\" } , { 0x10004 , \"exif:GPSLongitude\" } , { 0x10005 , \"exif:GPSAltitudeRef\" } , { 0x10006 , \"exif:GPSAltitude\" } , { 0x10007 , \"exif:GPSTimeStamp\" } , { 0x10008 , \"exif:GPSSatellites\" } , { 0x10009 , \"exif:GPSStatus\" } , { 0x1000a , \"exif:GPSMeasureMode\" } , { 0x1000b , \"exif:GPSDop\" } , { 0x1000c , \"exif:GPSSpeedRef\" } , { 0x1000d , \"exif:GPSSpeed\" } , { 0x1000e , \"exif:GPSTrackRef\" } , { 0x1000f , \"exif:GPSTrack\" } , { 0x10010 , \"exif:GPSImgDirectionRef\" } , { 0x10011 , \"exif:GPSImgDirection\" } , { 0x10012 , \"exif:GPSMapDatum\" } , { 0x10013 , \"exif:GPSDestLatitudeRef\" } , { 0x10014 , \"exif:GPSDestLatitude\" } , { 0x10015 , \"exif:GPSDestLongitudeRef\" } , { 0x10016 , \"exif:GPSDestLongitude\" } , { 0x10017 , \"exif:GPSDestBearingRef\" } , { 0x10018 , \"exif:GPSDestBearing\" } , { 0x10019 , \"exif:GPSDestDistanceRef\" } , { 0x1001a , \"exif:GPSDestDistance\" } , { 0x1001b , \"exif:GPSProcessingMethod\" } , { 0x1001c , \"exif:GPSAreaInformation\" } , { 0x1001d , \"exif:GPSDateStamp\" } , { 0x1001e , \"exif:GPSDifferential\" } , { 0x00000 , ( const char * ) NULL } } ; const StringInfo * profile ; const unsigned char * directory , * exif ; DirectoryInfo directory_stack [ MaxDirectoryStack ] ; EndianType endian ; MagickBooleanType status ; register ssize_t i ; size_t entry , length , number_entries , tag , tag_value ; SplayTreeInfo * exif_resources ; ssize_t all , id , level , offset , tag_offset ; static int tag_bytes [ ] = { 0 , 1 , 1 , 2 , 4 , 8 , 1 , 1 , 2 , 4 , 8 , 4 , 8 } ; profile = GetImageProfile ( image , \"exif\" ) ; if ( profile == ( const StringInfo * ) NULL ) return ( MagickFalse ) ; if ( ( property == ( const char * ) NULL ) || ( * property == '\\\\0' ) ) return ( MagickFalse ) ; while ( isspace ( ( int ) ( ( unsigned char ) * property ) ) != 0 ) property ++ ; if ( strlen ( property ) <= 5 ) return ( MagickFalse ) ; all = 0 ; tag = ( ~ 0UL ) ; switch ( * ( property + 5 ) ) { case '*' : { tag = 0 ; all = 1 ; break ; } case '!' : { tag = 0 ; all = 2 ; break ; } case '#' : case '@' : { int c ; size_t n ; tag = ( * ( property + 5 ) == '@' ) ? 1UL : 0UL ; property += 6 ; n = strlen ( property ) ; if ( n != 4 ) return ( MagickFalse ) ; n /= 4 ; do { for ( i = ( ssize_t ) n - 1L ; i >= 0 ; i -- ) { c = ( * property ++ ) ; tag <<= 4 ; if ( ( c >= '0' ) && ( c <= '9' ) ) tag |= ( c - '0' ) ; else if ( ( c >= 'A' ) && ( c <= 'F' ) ) tag |= ( c - ( 'A' - 10 ) ) ; else if ( ( c >= 'a' ) && ( c <= 'f' ) ) tag |= ( c - ( 'a' - 10 ) ) ; else return ( MagickFalse ) ; } } while ( * property != '\\\\0' ) ; break ; } default : { for ( i = 0 ; ; i ++ ) { if ( EXIFTag [ i ] . tag == 0 ) break ; if ( LocaleCompare ( EXIFTag [ i ] . description , property ) == 0 ) { tag = ( size_t ) EXIFTag [ i ] . tag ; break ; } } break ; } } if ( tag == ( ~ 0UL ) ) return ( MagickFalse ) ; length = GetStringInfoLength ( profile ) ; exif = GetStringInfoDatum ( profile ) ; while ( length != 0 ) { if ( ReadPropertyByte ( & exif , & length ) != 0x45 ) continue ; if ( ReadPropertyByte ( & exif , & length ) != 0x78 ) continue ; if ( ReadPropertyByte ( & exif , & length ) != 0x69 ) continue ; if ( ReadPropertyByte ( & exif , & length ) != 0x66 ) continue ; if ( ReadPropertyByte ( & exif , & length ) != 0x00 ) continue ; if ( ReadPropertyByte ( & exif , & length ) != 0x00 ) continue ; break ; } if ( length < 16 ) return ( MagickFalse ) ; id = ( ssize_t ) ReadPropertySignedShort ( LSBEndian , exif ) ; endian = LSBEndian ; if ( id == 0x4949 ) endian = LSBEndian ; else if ( id == 0x4D4D ) endian = MSBEndian ; else return ( MagickFalse ) ; if ( ReadPropertyUnsignedShort ( endian , exif + 2 ) != 0x002a ) return ( MagickFalse ) ; offset = ( ssize_t ) ReadPropertySignedLong ( endian , exif + 4 ) ; if ( ( offset < 0 ) || ( size_t ) offset >= length ) return ( MagickFalse ) ; status = MagickFalse ; directory = exif + offset ; level = 0 ; entry = 0 ; tag_offset = 0 ; exif_resources = NewSplayTree ( ( int ( * ) ( const void * , const void * ) ) NULL , ( void * ( * ) ( void * ) ) NULL , ( void * ( * ) ( void * ) ) NULL ) ; do { if ( level > 0 ) { level -- ; directory = directory_stack [ level ] . directory ; entry = directory_stack [ level ] . entry ; tag_offset = directory_stack [ level ] . offset ; } if ( ( directory < exif ) || ( directory > ( exif + length - 2 ) ) ) break ; number_entries = ( size_t ) ReadPropertyUnsignedShort ( endian , directory ) ; for ( ; entry < number_entries ; entry ++ ) { register unsigned char * p , * q ; size_t format ; ssize_t number_bytes , components ; q = ( unsigned char * ) ( directory + ( 12 * entry ) + 2 ) ; <S2SV_StartBug> if ( GetValueFromSplayTree ( exif_resources , q ) == q ) <S2SV_EndBug> break ; ( void ) AddValueToSplayTree ( exif_resources , q , q ) ; tag_value = ( size_t ) ReadPropertyUnsignedShort ( endian , q ) + tag_offset ; format = ( size_t ) ReadPropertyUnsignedShort ( endian , q + 2 ) ; if ( format >= ( sizeof ( tag_bytes ) / sizeof ( * tag_bytes ) ) ) break ; <S2SV_StartBug> components = ( ssize_t ) ReadPropertySignedLong ( endian , q + 4 ) ; <S2SV_EndBug> number_bytes = ( size_t ) components * tag_bytes [ format ] ; if ( number_bytes < components ) break ; if ( number_bytes <= 4 ) p = q + 8 ; else { ssize_t offset ; offset = ( ssize_t ) ReadPropertySignedLong ( endian , q + 8 ) ; if ( ( offset < 0 ) || ( size_t ) offset >= length ) continue ; if ( ( ssize_t ) ( offset + number_bytes ) < offset ) continue ; if ( ( size_t ) ( offset + number_bytes ) > length ) continue ; p = ( unsigned char * ) ( exif + offset ) ; } if ( ( all != 0 ) || ( tag == ( size_t ) tag_value ) ) { char buffer [ MagickPathExtent ] , * value ; value = ( char * ) NULL ; * buffer = '\\\\0' ; switch ( format ) { case EXIF_FMT_BYTE : case EXIF_FMT_UNDEFINED : { EXIFMultipleValues ( 1 , \"%.20g\" , ( double ) ( * ( unsigned char * ) p1 ) ) ; break ; } case EXIF_FMT_SBYTE : { EXIFMultipleValues ( 1 , \"%.20g\" , ( double ) ( * ( signed char * ) p1 ) ) ; break ; } case EXIF_FMT_SSHORT : { EXIFMultipleValues ( 2 , \"%hd\" , ReadPropertySignedShort ( endian , p1 ) ) ; break ; } case EXIF_FMT_USHORT : { EXIFMultipleValues ( 2 , \"%hu\" , ReadPropertyUnsignedShort ( endian , p1 ) ) ; break ; } case EXIF_FMT_ULONG : { EXIFMultipleValues ( 4 , \"%.20g\" , ( double ) ReadPropertyUnsignedLong ( endian , p1 ) ) ; break ; } case EXIF_FMT_SLONG : { EXIFMultipleValues ( 4 , \"%.20g\" , ( double ) ReadPropertySignedLong ( endian , p1 ) ) ; break ; } case EXIF_FMT_URATIONAL : { EXIFMultipleFractions ( 8 , \"%.20g/%.20g\" , ( double ) ReadPropertyUnsignedLong ( endian , p1 ) , ( double ) ReadPropertyUnsignedLong ( endian , p1 + 4 ) ) ; break ; } case EXIF_FMT_SRATIONAL : { EXIFMultipleFractions ( 8 , \"%.20g/%.20g\" , ( double ) ReadPropertySignedLong ( endian , p1 ) , ( double ) ReadPropertySignedLong ( endian , p1 + 4 ) ) ; break ; } case EXIF_FMT_SINGLE : { EXIFMultipleValues ( 4 , \"%f\" , ( double ) * ( float * ) p1 ) ; break ; } case EXIF_FMT_DOUBLE : { EXIFMultipleValues ( 8 , \"%f\" , * ( double * ) p1 ) ; break ; } default : case EXIF_FMT_STRING : { value = ( char * ) NULL ; if ( ~ ( ( size_t ) number_bytes ) >= 1 ) value = ( char * ) AcquireQuantumMemory ( ( size_t ) number_bytes + 1UL , sizeof ( * value ) ) ; if ( value != ( char * ) NULL ) { register ssize_t i ; for ( i = 0 ; i < ( ssize_t ) number_bytes ; i ++ ) { value [ i ] = '.' ; if ( ( isprint ( ( int ) p [ i ] ) != 0 ) || ( p [ i ] == '\\\\0' ) ) value [ i ] = ( char ) p [ i ] ; } value [ i ] = '\\\\0' ; } break ; } } if ( value != ( char * ) NULL ) { char * key ; register const char * p ; key = AcquireString ( property ) ; switch ( all ) { case 1 : { const char * description ; register ssize_t i ; description = \"unknown\" ; for ( i = 0 ; ; i ++ ) { if ( EXIFTag [ i ] . tag == 0 ) break ; if ( EXIFTag [ i ] . tag == tag_value ) { description = EXIFTag [ i ] . description ; break ; } } ( void ) FormatLocaleString ( key , MagickPathExtent , \"%s\" , description ) ; if ( level == 2 ) ( void ) SubstituteString ( & key , \"exif:\" , \"exif:thumbnail:\" ) ; break ; } case 2 : { if ( tag_value < 0x10000 ) ( void ) FormatLocaleString ( key , MagickPathExtent , \"#%04lx\" , ( unsigned long ) tag_value ) ; else if ( tag_value < 0x20000 ) ( void ) FormatLocaleString ( key , MagickPathExtent , \"@%04lx\" , ( unsigned long ) ( tag_value & 0xffff ) ) ; else ( void ) FormatLocaleString ( key , MagickPathExtent , \"unknown\" ) ; break ; } default : { if ( level == 2 ) ( void ) SubstituteString ( & key , \"exif:\" , \"exif:thumbnail:\" ) ; } } p = ( const char * ) NULL ; if ( image -> properties != ( void * ) NULL ) p = ( const char * ) GetValueFromSplayTree ( ( SplayTreeInfo * ) image -> properties , key ) ; if ( p == ( const char * ) NULL ) ( void ) SetImageProperty ( ( Image * ) image , key , value , exception ) ; value = DestroyString ( value ) ; key = DestroyString ( key ) ; status = MagickTrue ; } } if ( ( tag_value == TAG_EXIF_OFFSET ) || ( tag_value == TAG_INTEROP_OFFSET ) || ( tag_value == TAG_GPS_OFFSET ) ) { ssize_t offset ; offset = ( ssize_t ) ReadPropertySignedLong ( endian , p ) ; if ( ( ( size_t ) offset < length ) && ( level < ( MaxDirectoryStack - 2 ) ) ) { ssize_t tag_offset1 ; tag_offset1 = ( ssize_t ) ( ( tag_value == TAG_GPS_OFFSET ) ? 0x10000 : 0 ) ; directory_stack [ level ] . directory = directory ; entry ++ ; directory_stack [ level ] . entry = entry ; directory_stack [ level ] . offset = tag_offset ; level ++ ; directory_stack [ level ] . directory = exif + offset ; directory_stack [ level ] . offset = tag_offset1 ; directory_stack [ level ] . entry = 0 ; level ++ ; if ( ( directory + 2 + ( 12 * number_entries ) ) > ( exif + length ) ) break ; offset = ( ssize_t ) ReadPropertySignedLong ( endian , directory + 2 + ( 12 * number_entries ) ) ; if ( ( offset != 0 ) && ( ( size_t ) offset < length ) && ( level < ( MaxDirectoryStack - 2 ) ) ) { directory_stack [ level ] . directory = exif + offset ; directory_stack [ level ] . entry = 0 ; directory_stack [ level ] . offset = tag_offset1 ; level ++ ; } } break ; } } } while ( level > 0 ) ; exif_resources = DestroySplayTree ( exif_resources ) ; return ( status ) ; }\n","target":"<S2SV_ModStart> , arg ) \\\\\\n{ <S2SV_ModEnd> ssize_t component ; <S2SV_ModStart> buffer ) ; \\\\\\n} <S2SV_ModEnd> # define EXIFMultipleFractions <S2SV_ModStart> , arg2 ) \\\\\\n{ <S2SV_ModEnd> ssize_t component ; <S2SV_ModStart> buffer ) ; \\\\\\n} <S2SV_ModEnd> typedef struct _DirectoryInfo <S2SV_ModStart> ; if ( q > ( exif + length - 12 ) ) break ; if ( <S2SV_ModStart> + 4 ) ; if ( components < 0 ) break\n","project_and_commit_id":"ImageMagick@ImageMagick/d8ab7f046587f2e9f734b687ba7e6e10147c294b","cve_id":"CVE-2016-5842","original_address":"https://github.com/ImageMagick/ImageMagick/commit/d8ab7f046587f2e9f734b687ba7e6e10147c294b","time":"2016-12-13T15:59Z"},
	{"Unnamed: 0":2990,"cwe_id":"CWE-284","source":"CWE-284 static ssize_t out_write ( struct audio_stream_out * stream , const void * buffer , size_t bytes ) { struct a2dp_stream_out * out = ( struct a2dp_stream_out * ) stream ; int sent ; DEBUG ( \"write<S2SV_blank>%zu<S2SV_blank>bytes<S2SV_blank>(fd<S2SV_blank>%d)\" , bytes , out -> common . audio_fd ) ; pthread_mutex_lock ( & out -> common . lock ) ; if ( out -> common . state == AUDIO_A2DP_STATE_SUSPENDED ) { DEBUG ( \"stream<S2SV_blank>suspended\" ) ; pthread_mutex_unlock ( & out -> common . lock ) ; return - 1 ; } if ( ( out -> common . state == AUDIO_A2DP_STATE_STOPPED ) || ( out -> common . state == AUDIO_A2DP_STATE_STANDBY ) ) { if ( start_audio_datapath ( & out -> common ) < 0 ) { int us_delay = calc_audiotime ( out -> common . cfg , bytes ) ; DEBUG ( \"emulate<S2SV_blank>a2dp<S2SV_blank>write<S2SV_blank>delay<S2SV_blank>(%d<S2SV_blank>us)\" , us_delay ) ; <S2SV_StartBug> usleep ( us_delay ) ; <S2SV_EndBug> pthread_mutex_unlock ( & out -> common . lock ) ; return - 1 ; } } else if ( out -> common . state != AUDIO_A2DP_STATE_STARTED ) { ERROR ( \"stream<S2SV_blank>not<S2SV_blank>in<S2SV_blank>stopped<S2SV_blank>or<S2SV_blank>standby\" ) ; pthread_mutex_unlock ( & out -> common . lock ) ; return - 1 ; } pthread_mutex_unlock ( & out -> common . lock ) ; sent = skt_write ( out -> common . audio_fd , buffer , bytes ) ; if ( sent == - 1 ) { skt_disconnect ( out -> common . audio_fd ) ; out -> common . audio_fd = AUDIO_SKT_DISCONNECTED ; if ( out -> common . state != AUDIO_A2DP_STATE_SUSPENDED ) out -> common . state = AUDIO_A2DP_STATE_STOPPED ; else ERROR ( \"write<S2SV_blank>failed<S2SV_blank>:<S2SV_blank>stream<S2SV_blank>suspended,<S2SV_blank>avoid<S2SV_blank>resetting<S2SV_blank>state\" ) ; } else { const size_t frames = bytes / audio_stream_out_frame_size ( stream ) ; out -> frames_rendered += frames ; out -> frames_presented += frames ; } DEBUG ( \"wrote<S2SV_blank>%d<S2SV_blank>bytes<S2SV_blank>out<S2SV_blank>of<S2SV_blank>%zu<S2SV_blank>bytes\" , sent , bytes ) ; return sent ; }\n","target":"<S2SV_ModStart> us_delay ) ; TEMP_FAILURE_RETRY ( <S2SV_ModStart> usleep ( us_delay )\n","project_and_commit_id":"system@bt/472271b153c5dc53c28beac55480a8d8434b2d5c","cve_id":"CVE-2016-3839","original_address":"https://android.googlesource.com/platform/system/bt/+/472271b153c5dc53c28beac55480a8d8434b2d5c","time":"2016-08-05T20:59Z"},
	{"Unnamed: 0":305,"cwe_id":"CWE-401","source":"CWE-401 struct clock_source * dce110_clock_source_create ( struct dc_context * ctx , struct dc_bios * bios , enum clock_source_id id , const struct dce110_clk_src_regs * regs , bool dp_clk_src ) { struct dce110_clk_src * clk_src = kzalloc ( sizeof ( struct dce110_clk_src ) , GFP_KERNEL ) ; if ( ! clk_src ) return NULL ; if ( dce110_clk_src_construct ( clk_src , ctx , bios , id , regs , & cs_shift , & cs_mask ) ) { clk_src -> base . dp_clk_src = dp_clk_src ; return & clk_src -> base ; } <S2SV_StartBug> BREAK_TO_DEBUGGER ( ) ; <S2SV_EndBug> return NULL ; }\n","target":"<S2SV_ModStart> base ; } kfree ( clk_src ) ;\n","project_and_commit_id":"torvalds@linux/055e547478a11a6360c7ce05e2afc3e366968a12","cve_id":"CVE-2019-19083","original_address":"https://github.com/torvalds/linux/commit/055e547478a11a6360c7ce05e2afc3e366968a12","time":"2019-11-18T06:15Z"},
	{"Unnamed: 0":6735,"cwe_id":"CWE-295","source":"CWE-295 static krb5_error_code tgs_build_reply ( krb5_context context , krb5_kdc_configuration * config , KDC_REQ * req , KDC_REQ_BODY * b , hdb_entry_ex * krbtgt , krb5_enctype krbtgt_etype , const krb5_keyblock * replykey , int rk_is_subkey , krb5_ticket * ticket , krb5_data * reply , const char * from , const char * * e_text , AuthorizationData * * auth_data , const struct sockaddr * from_addr ) { krb5_error_code ret ; krb5_principal cp = NULL , sp = NULL , rsp = NULL , tp = NULL , dp = NULL ; krb5_principal krbtgt_out_principal = NULL ; char * spn = NULL , * cpn = NULL , * tpn = NULL , * dpn = NULL , * krbtgt_out_n = NULL ; hdb_entry_ex * server = NULL , * client = NULL , * s4u2self_impersonated_client = NULL ; HDB * clientdb , * s4u2self_impersonated_clientdb ; krb5_realm ref_realm = NULL ; EncTicketPart * tgt = & ticket -> ticket ; krb5_principals spp = NULL ; const EncryptionKey * ekey ; krb5_keyblock sessionkey ; krb5_kvno kvno ; <S2SV_StartBug> krb5_data rspac ; <S2SV_EndBug> const char * our_realm = krb5_principal_get_comp_string ( context , krbtgt -> entry . principal , 1 ) ; char * * capath = NULL ; size_t num_capath = 0 ; hdb_entry_ex * krbtgt_out = NULL ; METHOD_DATA enc_pa_data ; PrincipalName * s ; Realm r ; EncTicketPart adtkt ; char opt_str [ 128 ] ; int signedpath = 0 ; Key * tkey_check ; Key * tkey_sign ; int flags = HDB_F_FOR_TGS_REQ ; memset ( & sessionkey , 0 , sizeof ( sessionkey ) ) ; memset ( & adtkt , 0 , sizeof ( adtkt ) ) ; krb5_data_zero ( & rspac ) ; memset ( & enc_pa_data , 0 , sizeof ( enc_pa_data ) ) ; s = b -> sname ; r = b -> realm ; flags |= HDB_F_CANON ; if ( b -> kdc_options . enc_tkt_in_skey ) { Ticket * t ; hdb_entry_ex * uu ; krb5_principal p ; Key * uukey ; krb5uint32 second_kvno = 0 ; krb5uint32 * kvno_ptr = NULL ; if ( b -> additional_tickets == NULL || b -> additional_tickets -> len == 0 ) { ret = KRB5KDC_ERR_BADOPTION ; kdc_log ( context , config , 0 , \"No<S2SV_blank>second<S2SV_blank>ticket<S2SV_blank>present<S2SV_blank>in<S2SV_blank>request\" ) ; goto out ; } t = & b -> additional_tickets -> val [ 0 ] ; if ( ! get_krbtgt_realm ( & t -> sname ) ) { kdc_log ( context , config , 0 , \"Additional<S2SV_blank>ticket<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>ticket-granting<S2SV_blank>ticket\" ) ; ret = KRB5KDC_ERR_POLICY ; goto out ; } _krb5_principalname2krb5_principal ( context , & p , t -> sname , t -> realm ) ; if ( t -> enc_part . kvno ) { second_kvno = * t -> enc_part . kvno ; kvno_ptr = & second_kvno ; } ret = _kdc_db_fetch ( context , config , p , HDB_F_GET_KRBTGT , kvno_ptr , NULL , & uu ) ; krb5_free_principal ( context , p ) ; if ( ret ) { if ( ret == HDB_ERR_NOENTRY ) ret = KRB5KDC_ERR_S_PRINCIPAL_UNKNOWN ; goto out ; } ret = hdb_enctype2key ( context , & uu -> entry , NULL , t -> enc_part . etype , & uukey ) ; if ( ret ) { _kdc_free_ent ( context , uu ) ; ret = KRB5KDC_ERR_ETYPE_NOSUPP ; goto out ; } ret = krb5_decrypt_ticket ( context , t , & uukey -> key , & adtkt , 0 ) ; _kdc_free_ent ( context , uu ) ; if ( ret ) goto out ; ret = verify_flags ( context , config , & adtkt , spn ) ; if ( ret ) goto out ; s = & adtkt . cname ; r = adtkt . crealm ; } _krb5_principalname2krb5_principal ( context , & sp , * s , r ) ; ret = krb5_unparse_name ( context , sp , & spn ) ; if ( ret ) goto out ; _krb5_principalname2krb5_principal ( context , & cp , tgt -> cname , tgt -> crealm ) ; ret = krb5_unparse_name ( context , cp , & cpn ) ; if ( ret ) goto out ; unparse_flags ( KDCOptions2int ( b -> kdc_options ) , asn1_KDCOptions_units ( ) , opt_str , sizeof ( opt_str ) ) ; if ( * opt_str ) kdc_log ( context , config , 0 , \"TGS-REQ<S2SV_blank>%s<S2SV_blank>from<S2SV_blank>%s<S2SV_blank>for<S2SV_blank>%s<S2SV_blank>[%s]\" , cpn , from , spn , opt_str ) ; else kdc_log ( context , config , 0 , \"TGS-REQ<S2SV_blank>%s<S2SV_blank>from<S2SV_blank>%s<S2SV_blank>for<S2SV_blank>%s\" , cpn , from , spn ) ; server_lookup : ret = _kdc_db_fetch ( context , config , sp , HDB_F_GET_SERVER | flags , NULL , NULL , & server ) ; if ( ret == HDB_ERR_NOT_FOUND_HERE ) { kdc_log ( context , config , 5 , \"target<S2SV_blank>%s<S2SV_blank>does<S2SV_blank>not<S2SV_blank>have<S2SV_blank>secrets<S2SV_blank>at<S2SV_blank>this<S2SV_blank>KDC,<S2SV_blank>need<S2SV_blank>to<S2SV_blank>proxy\" , sp ) ; goto out ; } else if ( ret == HDB_ERR_WRONG_REALM ) { free ( ref_realm ) ; ref_realm = strdup ( server -> entry . principal -> realm ) ; if ( ref_realm == NULL ) { ret = krb5_enomem ( context ) ; goto out ; } kdc_log ( context , config , 5 , \"Returning<S2SV_blank>a<S2SV_blank>referral<S2SV_blank>to<S2SV_blank>realm<S2SV_blank>%s<S2SV_blank>for<S2SV_blank>\" \"server<S2SV_blank>%s.\" , ref_realm , spn ) ; krb5_free_principal ( context , sp ) ; sp = NULL ; ret = krb5_make_principal ( context , & sp , r , KRB5_TGS_NAME , ref_realm , NULL ) ; if ( ret ) goto out ; free ( spn ) ; spn = NULL ; ret = krb5_unparse_name ( context , sp , & spn ) ; if ( ret ) goto out ; goto server_lookup ; } else if ( ret ) { const char * new_rlm , * msg ; Realm req_rlm ; krb5_realm * realms ; if ( ( req_rlm = get_krbtgt_realm ( & sp -> name ) ) != NULL ) { if ( capath == NULL ) { ret = _krb5_find_capath ( context , tgt -> crealm , our_realm , req_rlm , TRUE , & capath , & num_capath ) ; if ( ret ) goto out ; } new_rlm = num_capath > 0 ? capath [ -- num_capath ] : NULL ; if ( new_rlm ) { kdc_log ( context , config , 5 , \"krbtgt<S2SV_blank>from<S2SV_blank>%s<S2SV_blank>via<S2SV_blank>%s<S2SV_blank>for<S2SV_blank>\" \"realm<S2SV_blank>%s<S2SV_blank>not<S2SV_blank>found,<S2SV_blank>trying<S2SV_blank>%s\" , tgt -> crealm , our_realm , req_rlm , new_rlm ) ; free ( ref_realm ) ; ref_realm = strdup ( new_rlm ) ; if ( ref_realm == NULL ) { ret = krb5_enomem ( context ) ; goto out ; } krb5_free_principal ( context , sp ) ; sp = NULL ; krb5_make_principal ( context , & sp , r , KRB5_TGS_NAME , ref_realm , NULL ) ; free ( spn ) ; spn = NULL ; ret = krb5_unparse_name ( context , sp , & spn ) ; if ( ret ) goto out ; goto server_lookup ; } } else if ( need_referral ( context , config , & b -> kdc_options , sp , & realms ) ) { if ( strcmp ( realms [ 0 ] , sp -> realm ) != 0 ) { kdc_log ( context , config , 5 , \"Returning<S2SV_blank>a<S2SV_blank>referral<S2SV_blank>to<S2SV_blank>realm<S2SV_blank>%s<S2SV_blank>for<S2SV_blank>\" \"server<S2SV_blank>%s<S2SV_blank>that<S2SV_blank>was<S2SV_blank>not<S2SV_blank>found\" , realms [ 0 ] , spn ) ; krb5_free_principal ( context , sp ) ; sp = NULL ; krb5_make_principal ( context , & sp , r , KRB5_TGS_NAME , realms [ 0 ] , NULL ) ; free ( spn ) ; spn = NULL ; ret = krb5_unparse_name ( context , sp , & spn ) ; if ( ret ) { krb5_free_host_realm ( context , realms ) ; goto out ; } free ( ref_realm ) ; ref_realm = strdup ( realms [ 0 ] ) ; krb5_free_host_realm ( context , realms ) ; goto server_lookup ; } krb5_free_host_realm ( context , realms ) ; } msg = krb5_get_error_message ( context , ret ) ; kdc_log ( context , config , 0 , \"Server<S2SV_blank>not<S2SV_blank>found<S2SV_blank>in<S2SV_blank>database:<S2SV_blank>%s:<S2SV_blank>%s\" , spn , msg ) ; krb5_free_error_message ( context , msg ) ; if ( ret == HDB_ERR_NOENTRY ) ret = KRB5KDC_ERR_S_PRINCIPAL_UNKNOWN ; goto out ; } if ( b -> kdc_options . canonicalize ) rsp = server -> entry . principal ; else rsp = sp ; { krb5_enctype etype ; if ( b -> kdc_options . enc_tkt_in_skey ) { size_t i ; ekey = & adtkt . key ; for ( i = 0 ; i < b -> etype . len ; i ++ ) if ( b -> etype . val [ i ] == adtkt . key . keytype ) break ; if ( i == b -> etype . len ) { kdc_log ( context , config , 0 , \"Addition<S2SV_blank>ticket<S2SV_blank>have<S2SV_blank>not<S2SV_blank>matching<S2SV_blank>etypes\" ) ; krb5_clear_error_message ( context ) ; ret = KRB5KDC_ERR_ETYPE_NOSUPP ; goto out ; } etype = b -> etype . val [ i ] ; kvno = 0 ; } else { Key * skey ; ret = _kdc_find_etype ( context , krb5_principal_is_krbtgt ( context , sp ) ? config -> tgt_use_strongest_session_key : config -> svc_use_strongest_session_key , FALSE , server , b -> etype . val , b -> etype . len , & etype , NULL ) ; if ( ret ) { kdc_log ( context , config , 0 , \"Server<S2SV_blank>(%s)<S2SV_blank>has<S2SV_blank>no<S2SV_blank>support<S2SV_blank>for<S2SV_blank>etypes\" , spn ) ; goto out ; } ret = _kdc_get_preferred_key ( context , config , server , spn , NULL , & skey ) ; if ( ret ) { kdc_log ( context , config , 0 , \"Server<S2SV_blank>(%s)<S2SV_blank>has<S2SV_blank>no<S2SV_blank>supported<S2SV_blank>etypes\" , spn ) ; goto out ; } ekey = & skey -> key ; kvno = server -> entry . kvno ; } ret = krb5_generate_random_keyblock ( context , etype , & sessionkey ) ; if ( ret ) goto out ; } ret = hdb_enctype2key ( context , & krbtgt -> entry , NULL , krbtgt_etype , & tkey_check ) ; if ( ret ) { kdc_log ( context , config , 0 , \"Failed<S2SV_blank>to<S2SV_blank>find<S2SV_blank>key<S2SV_blank>for<S2SV_blank>krbtgt<S2SV_blank>PAC<S2SV_blank>check\" ) ; goto out ; } ret = krb5_make_principal ( context , & krbtgt_out_principal , our_realm , KRB5_TGS_NAME , our_realm , NULL ) ; if ( ret ) { kdc_log ( context , config , 0 , \"Failed<S2SV_blank>to<S2SV_blank>make<S2SV_blank>krbtgt<S2SV_blank>principal<S2SV_blank>name<S2SV_blank>object<S2SV_blank>for<S2SV_blank>\" \"authz-data<S2SV_blank>signatures\" ) ; goto out ; } ret = krb5_unparse_name ( context , krbtgt_out_principal , & krbtgt_out_n ) ; if ( ret ) { kdc_log ( context , config , 0 , \"Failed<S2SV_blank>to<S2SV_blank>make<S2SV_blank>krbtgt<S2SV_blank>principal<S2SV_blank>name<S2SV_blank>object<S2SV_blank>for<S2SV_blank>\" \"authz-data<S2SV_blank>signatures\" ) ; goto out ; } ret = _kdc_db_fetch ( context , config , krbtgt_out_principal , HDB_F_GET_KRBTGT , NULL , NULL , & krbtgt_out ) ; if ( ret ) { char * ktpn = NULL ; ret = krb5_unparse_name ( context , krbtgt -> entry . principal , & ktpn ) ; kdc_log ( context , config , 0 , \"No<S2SV_blank>such<S2SV_blank>principal<S2SV_blank>%s<S2SV_blank>(needed<S2SV_blank>for<S2SV_blank>authz-data<S2SV_blank>signature<S2SV_blank>keys)<S2SV_blank>\" \"while<S2SV_blank>processing<S2SV_blank>TGS-REQ<S2SV_blank>for<S2SV_blank>service<S2SV_blank>%s<S2SV_blank>with<S2SV_blank>krbtg<S2SV_blank>%s\" , krbtgt_out_n , spn , ( ret == 0 ) ? ktpn : \"<unknown>\" ) ; free ( ktpn ) ; ret = KRB5KRB_AP_ERR_NOT_US ; goto out ; } if ( strcmp ( krb5_principal_get_realm ( context , server -> entry . principal ) , krb5_principal_get_realm ( context , krbtgt_out -> entry . principal ) ) != 0 ) { char * ktpn ; ret = krb5_unparse_name ( context , krbtgt_out -> entry . principal , & ktpn ) ; kdc_log ( context , config , 0 , \"Request<S2SV_blank>with<S2SV_blank>wrong<S2SV_blank>krbtgt:<S2SV_blank>%s\" , ( ret == 0 ) ? ktpn : \"<unknown>\" ) ; if ( ret == 0 ) free ( ktpn ) ; ret = KRB5KRB_AP_ERR_NOT_US ; goto out ; } ret = _kdc_get_preferred_key ( context , config , krbtgt_out , krbtgt_out_n , NULL , & tkey_sign ) ; if ( ret ) { kdc_log ( context , config , 0 , \"Failed<S2SV_blank>to<S2SV_blank>find<S2SV_blank>key<S2SV_blank>for<S2SV_blank>krbtgt<S2SV_blank>PAC<S2SV_blank>signature\" ) ; goto out ; } ret = hdb_enctype2key ( context , & krbtgt_out -> entry , NULL , tkey_sign -> key . keytype , & tkey_sign ) ; if ( ret ) { kdc_log ( context , config , 0 , \"Failed<S2SV_blank>to<S2SV_blank>find<S2SV_blank>key<S2SV_blank>for<S2SV_blank>krbtgt<S2SV_blank>PAC<S2SV_blank>signature\" ) ; goto out ; } ret = _kdc_db_fetch ( context , config , cp , HDB_F_GET_CLIENT | flags , NULL , & clientdb , & client ) ; if ( ret == HDB_ERR_NOT_FOUND_HERE ) { } else if ( ret ) { const char * krbtgt_realm , * msg ; krbtgt_realm = krb5_principal_get_realm ( context , krbtgt_out -> entry . principal ) ; if ( strcmp ( krb5_principal_get_realm ( context , cp ) , krbtgt_realm ) == 0 ) { if ( ret == HDB_ERR_NOENTRY ) ret = KRB5KDC_ERR_C_PRINCIPAL_UNKNOWN ; kdc_log ( context , config , 1 , \"Client<S2SV_blank>no<S2SV_blank>longer<S2SV_blank>in<S2SV_blank>database:<S2SV_blank>%s\" , cpn ) ; goto out ; } msg = krb5_get_error_message ( context , ret ) ; kdc_log ( context , config , 1 , \"Client<S2SV_blank>not<S2SV_blank>found<S2SV_blank>in<S2SV_blank>database:<S2SV_blank>%s\" , msg ) ; krb5_free_error_message ( context , msg ) ; } ret = check_PAC ( context , config , cp , NULL , client , server , krbtgt , & tkey_check -> key , ekey , & tkey_sign -> key , tgt , & rspac , & signedpath ) ; if ( ret ) { const char * msg = krb5_get_error_message ( context , ret ) ; kdc_log ( context , config , 0 , \"Verify<S2SV_blank>PAC<S2SV_blank>failed<S2SV_blank>for<S2SV_blank>%s<S2SV_blank>(%s)<S2SV_blank>from<S2SV_blank>%s<S2SV_blank>with<S2SV_blank>%s\" , spn , cpn , from , msg ) ; krb5_free_error_message ( context , msg ) ; goto out ; } ret = check_KRB5SignedPath ( context , config , krbtgt , cp , tgt , & spp , & signedpath ) ; if ( ret ) { const char * msg = krb5_get_error_message ( context , ret ) ; kdc_log ( context , config , 0 , \"KRB5SignedPath<S2SV_blank>check<S2SV_blank>failed<S2SV_blank>for<S2SV_blank>%s<S2SV_blank>(%s)<S2SV_blank>from<S2SV_blank>%s<S2SV_blank>with<S2SV_blank>%s\" , spn , cpn , from , msg ) ; krb5_free_error_message ( context , msg ) ; goto out ; } tp = cp ; tpn = cpn ; if ( client ) { const PA_DATA * sdata ; int i = 0 ; sdata = _kdc_find_padata ( req , & i , KRB5_PADATA_FOR_USER ) ; if ( sdata ) { krb5_crypto crypto ; krb5_data datack ; PA_S4U2Self self ; const char * str ; ret = decode_PA_S4U2Self ( sdata -> padata_value . data , sdata -> padata_value . length , & self , NULL ) ; if ( ret ) { kdc_log ( context , config , 0 , \"Failed<S2SV_blank>to<S2SV_blank>decode<S2SV_blank>PA-S4U2Self\" ) ; goto out ; } ret = _krb5_s4u2self_to_checksumdata ( context , & self , & datack ) ; if ( ret ) goto out ; ret = krb5_crypto_init ( context , & tgt -> key , 0 , & crypto ) ; if ( ret ) { const char * msg = krb5_get_error_message ( context , ret ) ; free_PA_S4U2Self ( & self ) ; krb5_data_free ( & datack ) ; kdc_log ( context , config , 0 , \"krb5_crypto_init<S2SV_blank>failed:<S2SV_blank>%s\" , msg ) ; krb5_free_error_message ( context , msg ) ; goto out ; } ret = krb5_verify_checksum ( context , crypto , KRB5_KU_OTHER_CKSUM , datack . data , datack . length , & self . cksum ) ; krb5_data_free ( & datack ) ; krb5_crypto_destroy ( context , crypto ) ; if ( ret ) { const char * msg = krb5_get_error_message ( context , ret ) ; free_PA_S4U2Self ( & self ) ; kdc_log ( context , config , 0 , \"krb5_verify_checksum<S2SV_blank>failed<S2SV_blank>for<S2SV_blank>S4U2Self:<S2SV_blank>%s\" , msg ) ; krb5_free_error_message ( context , msg ) ; goto out ; } ret = _krb5_principalname2krb5_principal ( context , & tp , self . name , self . realm ) ; free_PA_S4U2Self ( & self ) ; if ( ret ) goto out ; ret = krb5_unparse_name ( context , tp , & tpn ) ; if ( ret ) goto out ; if ( rspac . data ) { krb5_pac p = NULL ; krb5_data_free ( & rspac ) ; ret = _kdc_db_fetch ( context , config , tp , HDB_F_GET_CLIENT | flags , NULL , & s4u2self_impersonated_clientdb , & s4u2self_impersonated_client ) ; if ( ret ) { const char * msg ; if ( ret == HDB_ERR_NOENTRY ) ret = KRB5KDC_ERR_C_PRINCIPAL_UNKNOWN ; msg = krb5_get_error_message ( context , ret ) ; kdc_log ( context , config , 1 , \"S2U4Self<S2SV_blank>principal<S2SV_blank>to<S2SV_blank>impersonate<S2SV_blank>%s<S2SV_blank>not<S2SV_blank>found<S2SV_blank>in<S2SV_blank>database:<S2SV_blank>%s\" , tpn , msg ) ; krb5_free_error_message ( context , msg ) ; goto out ; } ret = _kdc_pac_generate ( context , s4u2self_impersonated_client , & p ) ; if ( ret ) { kdc_log ( context , config , 0 , \"PAC<S2SV_blank>generation<S2SV_blank>failed<S2SV_blank>for<S2SV_blank>--<S2SV_blank>%s\" , tpn ) ; goto out ; } if ( p != NULL ) { ret = _krb5_pac_sign ( context , p , ticket -> ticket . authtime , s4u2self_impersonated_client -> entry . principal , ekey , & tkey_sign -> key , & rspac ) ; krb5_pac_free ( context , p ) ; if ( ret ) { kdc_log ( context , config , 0 , \"PAC<S2SV_blank>signing<S2SV_blank>failed<S2SV_blank>for<S2SV_blank>--<S2SV_blank>%s\" , tpn ) ; goto out ; } } } ret = check_s4u2self ( context , config , clientdb , client , sp ) ; if ( ret ) { kdc_log ( context , config , 0 , \"S4U2Self:<S2SV_blank>%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>allowed<S2SV_blank>\" \"to<S2SV_blank>impersonate<S2SV_blank>to<S2SV_blank>service<S2SV_blank>\" \"(tried<S2SV_blank>for<S2SV_blank>user<S2SV_blank>%s<S2SV_blank>to<S2SV_blank>service<S2SV_blank>%s)\" , cpn , tpn , spn ) ; goto out ; } if ( client -> entry . flags . trusted_for_delegation ) { str = \"[forwardable]\" ; } else { b -> kdc_options . forwardable = 0 ; str = \"\" ; } kdc_log ( context , config , 0 , \"s4u2self<S2SV_blank>%s<S2SV_blank>impersonating<S2SV_blank>%s<S2SV_blank>to<S2SV_blank>\" \"service<S2SV_blank>%s<S2SV_blank>%s\" , cpn , tpn , spn , str ) ; } } if ( client != NULL && b -> additional_tickets != NULL && b -> additional_tickets -> len != 0 && b -> kdc_options . enc_tkt_in_skey == 0 ) { int ad_signedpath = 0 ; Key * clientkey ; Ticket * t ; if ( ! signedpath ) { ret = KRB5KDC_ERR_BADOPTION ; kdc_log ( context , config , 0 , \"Constrained<S2SV_blank>delegation<S2SV_blank>done<S2SV_blank>on<S2SV_blank>service<S2SV_blank>ticket<S2SV_blank>%s/%s\" , cpn , spn ) ; goto out ; } t = & b -> additional_tickets -> val [ 0 ] ; ret = hdb_enctype2key ( context , & client -> entry , hdb_kvno2keys ( context , & client -> entry , t -> enc_part . kvno ? * t -> enc_part . kvno : 0 ) , t -> enc_part . etype , & clientkey ) ; if ( ret ) { ret = KRB5KDC_ERR_ETYPE_NOSUPP ; goto out ; } ret = krb5_decrypt_ticket ( context , t , & clientkey -> key , & adtkt , 0 ) ; if ( ret ) { kdc_log ( context , config , 0 , \"failed<S2SV_blank>to<S2SV_blank>decrypt<S2SV_blank>ticket<S2SV_blank>for<S2SV_blank>\" \"constrained<S2SV_blank>delegation<S2SV_blank>from<S2SV_blank>%s<S2SV_blank>to<S2SV_blank>%s<S2SV_blank>\" , cpn , spn ) ; goto out ; } ret = _krb5_principalname2krb5_principal ( context , & tp , adtkt . cname , adtkt . crealm ) ; if ( ret ) goto out ; ret = krb5_unparse_name ( context , tp , & tpn ) ; if ( ret ) goto out ; ret = _krb5_principalname2krb5_principal ( context , & dp , t -> sname , t -> realm ) ; if ( ret ) goto out ; ret = krb5_unparse_name ( context , dp , & dpn ) ; if ( ret ) goto out ; if ( adtkt . flags . forwardable == 0 ) { kdc_log ( context , config , 0 , \"Missing<S2SV_blank>forwardable<S2SV_blank>flag<S2SV_blank>on<S2SV_blank>ticket<S2SV_blank>for<S2SV_blank>\" \"constrained<S2SV_blank>delegation<S2SV_blank>from<S2SV_blank>%s<S2SV_blank>(%s)<S2SV_blank>as<S2SV_blank>%s<S2SV_blank>to<S2SV_blank>%s<S2SV_blank>\" , cpn , dpn , tpn , spn ) ; ret = KRB5KDC_ERR_BADOPTION ; goto out ; } ret = check_constrained_delegation ( context , config , clientdb , client , server , sp ) ; if ( ret ) { kdc_log ( context , config , 0 , \"constrained<S2SV_blank>delegation<S2SV_blank>from<S2SV_blank>%s<S2SV_blank>(%s)<S2SV_blank>as<S2SV_blank>%s<S2SV_blank>to<S2SV_blank>%s<S2SV_blank>not<S2SV_blank>allowed\" , cpn , dpn , tpn , spn ) ; goto out ; } ret = verify_flags ( context , config , & adtkt , tpn ) ; if ( ret ) { goto out ; } krb5_data_free ( & rspac ) ; ret = check_PAC ( context , config , tp , dp , client , server , krbtgt , & clientkey -> key , ekey , & tkey_sign -> key , & adtkt , & rspac , & ad_signedpath ) ; if ( ret ) { const char * msg = krb5_get_error_message ( context , ret ) ; kdc_log ( context , config , 0 , \"Verify<S2SV_blank>delegated<S2SV_blank>PAC<S2SV_blank>failed<S2SV_blank>to<S2SV_blank>%s<S2SV_blank>for<S2SV_blank>client\" \"%s<S2SV_blank>(%s)<S2SV_blank>as<S2SV_blank>%s<S2SV_blank>from<S2SV_blank>%s<S2SV_blank>with<S2SV_blank>%s\" , spn , cpn , dpn , tpn , from , msg ) ; krb5_free_error_message ( context , msg ) ; goto out ; } ret = check_KRB5SignedPath ( context , config , krbtgt , cp , & adtkt , NULL , & ad_signedpath ) ; if ( ret ) { const char * msg = krb5_get_error_message ( context , ret ) ; kdc_log ( context , config , 0 , \"KRB5SignedPath<S2SV_blank>check<S2SV_blank>from<S2SV_blank>service<S2SV_blank>%s<S2SV_blank>failed<S2SV_blank>\" \"for<S2SV_blank>delegation<S2SV_blank>to<S2SV_blank>%s<S2SV_blank>for<S2SV_blank>client<S2SV_blank>%s<S2SV_blank>(%s)\" \"from<S2SV_blank>%s<S2SV_blank>failed<S2SV_blank>with<S2SV_blank>%s\" , spn , tpn , dpn , cpn , from , msg ) ; krb5_free_error_message ( context , msg ) ; goto out ; } if ( ! ad_signedpath ) { ret = KRB5KDC_ERR_BADOPTION ; kdc_log ( context , config , 0 , \"Ticket<S2SV_blank>not<S2SV_blank>signed<S2SV_blank>with<S2SV_blank>PAC<S2SV_blank>nor<S2SV_blank>SignedPath<S2SV_blank>service<S2SV_blank>%s<S2SV_blank>failed<S2SV_blank>\" \"for<S2SV_blank>delegation<S2SV_blank>to<S2SV_blank>%s<S2SV_blank>for<S2SV_blank>client<S2SV_blank>%s<S2SV_blank>(%s)\" \"from<S2SV_blank>%s\" , spn , tpn , dpn , cpn , from ) ; goto out ; } kdc_log ( context , config , 0 , \"constrained<S2SV_blank>delegation<S2SV_blank>for<S2SV_blank>%s<S2SV_blank>\" \"from<S2SV_blank>%s<S2SV_blank>(%s)<S2SV_blank>to<S2SV_blank>%s\" , tpn , cpn , dpn , spn ) ; } ret = kdc_check_flags ( context , config , client , cpn , server , spn , FALSE ) ; if ( ret ) goto out ; if ( ( b -> kdc_options . validate || b -> kdc_options . renew ) && ! krb5_principal_compare ( context , krbtgt -> entry . principal , server -> entry . principal ) ) { kdc_log ( context , config , 0 , \"Inconsistent<S2SV_blank>request.\" ) ; ret = KRB5KDC_ERR_SERVER_NOMATCH ; goto out ; } if ( ! _kdc_check_addresses ( context , config , tgt -> caddr , from_addr ) ) { ret = KRB5KRB_AP_ERR_BADADDR ; kdc_log ( context , config , 0 , \"Request<S2SV_blank>from<S2SV_blank>wrong<S2SV_blank>address\" ) ; goto out ; } if ( ref_realm ) { PA_DATA pa ; krb5_crypto crypto ; kdc_log ( context , config , 0 , \"Adding<S2SV_blank>server<S2SV_blank>referral<S2SV_blank>to<S2SV_blank>%s\" , ref_realm ) ; ret = krb5_crypto_init ( context , & sessionkey , 0 , & crypto ) ; if ( ret ) goto out ; ret = build_server_referral ( context , config , crypto , ref_realm , NULL , s , & pa . padata_value ) ; krb5_crypto_destroy ( context , crypto ) ; if ( ret ) { kdc_log ( context , config , 0 , \"Failed<S2SV_blank>building<S2SV_blank>server<S2SV_blank>referral\" ) ; goto out ; } pa . padata_type = KRB5_PADATA_SERVER_REFERRAL ; ret = add_METHOD_DATA ( & enc_pa_data , & pa ) ; krb5_data_free ( & pa . padata_value ) ; if ( ret ) { kdc_log ( context , config , 0 , \"Add<S2SV_blank>server<S2SV_blank>referral<S2SV_blank>METHOD-DATA<S2SV_blank>failed\" ) ; goto out ; } } ret = tgs_make_reply ( context , config , b , tp , tgt , replykey , rk_is_subkey , ekey , & sessionkey , kvno , * auth_data , server , rsp , spn , client , cp , <S2SV_StartBug> krbtgt_out , <S2SV_EndBug> tkey_sign -> key . keytype , spp , & rspac , & enc_pa_data , e_text , reply ) ; out : if ( tpn != cpn ) free ( tpn ) ; free ( spn ) ; free ( cpn ) ; free ( dpn ) ; free ( krbtgt_out_n ) ; _krb5_free_capath ( context , capath ) ; krb5_data_free ( & rspac ) ; krb5_free_keyblock_contents ( context , & sessionkey ) ; if ( krbtgt_out ) _kdc_free_ent ( context , krbtgt_out ) ; if ( server ) _kdc_free_ent ( context , server ) ; if ( client ) _kdc_free_ent ( context , client ) ; if ( s4u2self_impersonated_client ) _kdc_free_ent ( context , s4u2self_impersonated_client ) ; if ( tp && tp != cp ) krb5_free_principal ( context , tp ) ; krb5_free_principal ( context , cp ) ; krb5_free_principal ( context , dp ) ; krb5_free_principal ( context , sp ) ; krb5_free_principal ( context , krbtgt_out_principal ) ; free ( ref_realm ) ; free_METHOD_DATA ( & enc_pa_data ) ; free_EncTicketPart ( & adtkt ) ; return ret ; }\n","target":"<S2SV_ModStart> ; krb5_data rspac ; const char * tgt_realm = krb5_principal_get_realm ( context , krbtgt -> entry . principal ) <S2SV_ModStart> , cp , tgt_realm ,\n","project_and_commit_id":"heimdal@heimdal/b1e699103f08d6a0ca46a122193c9da65f6cf837","cve_id":"CVE-2017-6594","original_address":"https://github.com/heimdal/heimdal/commit/b1e699103f08d6a0ca46a122193c9da65f6cf837","time":"2017-08-28T19:29Z"},
	{"Unnamed: 0":576,"cwe_id":"CWE-000","source":"CWE-000 static int unix_dgram_connect ( struct socket * sock , struct sockaddr * addr , int alen , int flags ) { struct sock * sk = sock -> sk ; struct net * net = sock_net ( sk ) ; struct sockaddr_un * sunaddr = ( struct sockaddr_un * ) addr ; struct sock * other ; unsigned int hash ; int err ; if ( addr -> sa_family != AF_UNSPEC ) { err = unix_mkname ( sunaddr , alen , & hash ) ; if ( err < 0 ) goto out ; alen = err ; if ( test_bit ( SOCK_PASSCRED , & sock -> flags ) && ! unix_sk ( sk ) -> addr && ( err = unix_autobind ( sock ) ) != 0 ) goto out ; restart : other = unix_find_other ( net , sunaddr , alen , sock -> type , hash , & err ) ; if ( ! other ) goto out ; unix_state_double_lock ( sk , other ) ; if ( sock_flag ( other , SOCK_DEAD ) ) { unix_state_double_unlock ( sk , other ) ; sock_put ( other ) ; goto restart ; } err = - EPERM ; if ( ! unix_may_send ( sk , other ) ) goto out_unlock ; err = security_unix_may_send ( sk -> sk_socket , other -> sk_socket ) ; if ( err ) goto out_unlock ; } else { other = NULL ; unix_state_double_lock ( sk , other ) ; } if ( unix_peer ( sk ) ) { struct sock * old_peer = unix_peer ( sk ) ; unix_peer ( sk ) = other ; <S2SV_StartBug> unix_state_double_unlock ( sk , other ) ; <S2SV_EndBug> if ( other != old_peer ) unix_dgram_disconnected ( sk , old_peer ) ; sock_put ( old_peer ) ; } else { unix_peer ( sk ) = other ; unix_state_double_unlock ( sk , other ) ; } return 0 ; out_unlock : unix_state_double_unlock ( sk , other ) ; sock_put ( other ) ; out : return err ; }\n","target":"<S2SV_ModStart> = other ; unix_dgram_peer_wake_disconnect_wakeup ( sk , old_peer ) ;\n","project_and_commit_id":"torvalds@linux/7d267278a9ece963d77eefec61630223fce08c6c","cve_id":"CVE-2013-7446","original_address":"https://github.com/torvalds/linux/commit/7d267278a9ece963d77eefec61630223fce08c6c","time":"2015-12-28T11:59Z"},
	{"Unnamed: 0":1561,"cwe_id":"CWE-000","source":"CWE-000 static void sas_init_port ( struct asd_sas_port * port , struct sas_ha_struct * sas_ha , int i ) { memset ( port , 0 , sizeof ( * port ) ) ; port -> id = i ; INIT_LIST_HEAD ( & port -> dev_list ) ; INIT_LIST_HEAD ( & port -> disco_list ) ; INIT_LIST_HEAD ( & port -> destroy_list ) ; <S2SV_StartBug> spin_lock_init ( & port -> phy_list_lock ) ; <S2SV_EndBug> INIT_LIST_HEAD ( & port -> phy_list ) ; port -> ha = sas_ha ; spin_lock_init ( & port -> dev_list_lock ) ; }\n","target":"<S2SV_ModStart> destroy_list ) ; INIT_LIST_HEAD ( & port -> sas_port_del_list ) ;\n","project_and_commit_id":"torvalds@linux/0558f33c06bb910e2879e355192227a8e8f0219d","cve_id":"CVE-2017-18232","original_address":"https://github.com/torvalds/linux/commit/0558f33c06bb910e2879e355192227a8e8f0219d","time":"2018-03-15T04:29Z"},
	{"Unnamed: 0":761,"cwe_id":"CWE-17","source":"CWE-17 <S2SV_StartBug> int udf_get_filename ( struct super_block * sb , uint8_t * sname , uint8_t * dname , <S2SV_EndBug> <S2SV_StartBug> int flen ) <S2SV_EndBug> { struct ustr * filename , * unifilename ; int len = 0 ; filename = kmalloc ( sizeof ( struct ustr ) , GFP_NOFS ) ; if ( ! filename ) return 0 ; unifilename = kmalloc ( sizeof ( struct ustr ) , GFP_NOFS ) ; if ( ! unifilename ) goto out1 ; <S2SV_StartBug> if ( udf_build_ustr_exact ( unifilename , sname , flen ) ) <S2SV_EndBug> goto out2 ; if ( UDF_QUERY_FLAG ( sb , UDF_FLAG_UTF8 ) ) { if ( ! udf_CS0toUTF8 ( filename , unifilename ) ) { udf_debug ( \"Failed<S2SV_blank>in<S2SV_blank>udf_get_filename:<S2SV_blank>sname<S2SV_blank>=<S2SV_blank>%s\\\\n\" , sname ) ; goto out2 ; } } else if ( UDF_QUERY_FLAG ( sb , UDF_FLAG_NLS_MAP ) ) { if ( ! udf_CS0toNLS ( UDF_SB ( sb ) -> s_nls_map , filename , unifilename ) ) { udf_debug ( \"Failed<S2SV_blank>in<S2SV_blank>udf_get_filename:<S2SV_blank>sname<S2SV_blank>=<S2SV_blank>%s\\\\n\" , sname ) ; goto out2 ; } } else goto out2 ; <S2SV_StartBug> len = udf_translate_to_linux ( dname , filename -> u_name , filename -> u_len , <S2SV_EndBug> unifilename -> u_name , unifilename -> u_len ) ; out2 : kfree ( unifilename ) ; out1 : kfree ( filename ) ; return len ; }\n","target":"<S2SV_ModStart> * sname , int slen , <S2SV_ModStart> * dname , int dlen <S2SV_ModEnd> ) { struct <S2SV_ModStart> , sname , slen <S2SV_ModEnd> ) ) goto <S2SV_ModStart> ( dname , dlen ,\n","project_and_commit_id":"torvalds@linux/0e5cc9a40ada6046e6bc3bdfcd0c0d7e4b706b14","cve_id":"CVE-2014-9731","original_address":"https://github.com/torvalds/linux/commit/0e5cc9a40ada6046e6bc3bdfcd0c0d7e4b706b14","time":"2015-08-31T10:59Z"},
	{"Unnamed: 0":4701,"cwe_id":"CWE-476","source":"CWE-476 bool ExprResolveLhs ( struct xkb_context * ctx , const ExprDef * expr , const char * * elem_rtrn , const char * * field_rtrn , ExprDef * * index_rtrn ) { switch ( expr -> expr . op ) { case EXPR_IDENT : * elem_rtrn = NULL ; * field_rtrn = xkb_atom_text ( ctx , expr -> ident . ident ) ; * index_rtrn = NULL ; <S2SV_StartBug> return true ; <S2SV_EndBug> case EXPR_FIELD_REF : * elem_rtrn = xkb_atom_text ( ctx , expr -> field_ref . element ) ; * field_rtrn = xkb_atom_text ( ctx , expr -> field_ref . field ) ; * index_rtrn = NULL ; return true ; case EXPR_ARRAY_REF : * elem_rtrn = xkb_atom_text ( ctx , expr -> array_ref . element ) ; * field_rtrn = xkb_atom_text ( ctx , expr -> array_ref . field ) ; * index_rtrn = expr -> array_ref . entry ; return true ; default : break ; } log_wsgo ( ctx , \"Unexpected<S2SV_blank>operator<S2SV_blank>%d<S2SV_blank>in<S2SV_blank>ResolveLhs\\\\n\" , expr -> expr . op ) ; return false ; }\n","target":"<S2SV_ModStart> NULL ; return ( * field_rtrn != NULL ) <S2SV_ModEnd> ; case EXPR_FIELD_REF\n","project_and_commit_id":"xkbcommon@libxkbcommon/38e1766bc6e20108948aec8a0b222a4bad0254e9","cve_id":"CVE-2018-15861","original_address":"https://github.com/xkbcommon/libxkbcommon/commit/38e1766bc6e20108948aec8a0b222a4bad0254e9","time":"2018-08-25T21:29Z"},
	{"Unnamed: 0":771,"cwe_id":"CWE-295","source":"CWE-295 static int int_x509_param_set_hosts ( X509_VERIFY_PARAM_ID * id , int mode , const char * name , size_t namelen ) { char * copy ; <S2SV_StartBug> if ( name && memchr ( name , '\\\\0' , namelen ) ) <S2SV_EndBug> return 0 ; if ( mode == SET_HOST && id -> hosts ) { string_stack_free ( id -> hosts ) ; id -> hosts = NULL ; } if ( name == NULL || namelen == 0 ) return 1 ; copy = strndup ( name , namelen ) ; if ( copy == NULL ) return 0 ; if ( id -> hosts == NULL && ( id -> hosts = sk_OPENSSL_STRING_new_null ( ) ) == NULL ) { free ( copy ) ; return 0 ; } if ( ! sk_OPENSSL_STRING_push ( id -> hosts , copy ) ) { free ( copy ) ; if ( sk_OPENSSL_STRING_num ( id -> hosts ) == 0 ) { sk_OPENSSL_STRING_free ( id -> hosts ) ; id -> hosts = NULL ; } return 0 ; } return 1 ; }\n","target":"<S2SV_ModStart> if ( name != NULL && namelen == 0 ) namelen = strlen ( name ) ; if ( name\n","project_and_commit_id":"libressl-portable@openbsd/0654414afcce51a16d35d05060190a3ec4618d42","cve_id":"CVE-2018-8970","original_address":"https://github.com/libressl-portable/openbsd/commit/0654414afcce51a16d35d05060190a3ec4618d42","time":"2018-03-24T21:29Z"},
	{"Unnamed: 0":2497,"cwe_id":"CWE-20","source":"CWE-20 static int __sock_diag_rcv_msg ( struct sk_buff * skb , struct nlmsghdr * nlh ) { int err ; struct sock_diag_req * req = nlmsg_data ( nlh ) ; const struct sock_diag_handler * hndl ; if ( nlmsg_len ( nlh ) < sizeof ( * req ) ) return - EINVAL ; <S2SV_StartBug> hndl = sock_diag_lock_handler ( req -> sdiag_family ) ; <S2SV_EndBug> if ( hndl == NULL ) err = - ENOENT ; else err = hndl -> dump ( skb , nlh ) ; sock_diag_unlock_handler ( hndl ) ; return err ; }\n","target":"<S2SV_ModStart> - EINVAL ; if ( req -> sdiag_family >= AF_MAX ) return - EINVAL ;\n","project_and_commit_id":"torvalds@linux/6e601a53566d84e1ffd25e7b6fe0b6894ffd79c0","cve_id":"CVE-2013-1763","original_address":"https://github.com/torvalds/linux/commit/6e601a53566d84e1ffd25e7b6fe0b6894ffd79c0","time":"2013-02-28T19:55Z"},
	{"Unnamed: 0":5579,"cwe_id":"CWE-400","source":"CWE-400 static enum gro_result dev_gro_receive ( struct napi_struct * napi , struct sk_buff * skb ) { struct sk_buff * * pp = NULL ; struct packet_offload * ptype ; __be16 type = skb -> protocol ; struct list_head * head = & offload_base ; int same_flow ; enum gro_result ret ; int grow ; if ( ! ( skb -> dev -> features & NETIF_F_GRO ) ) goto normal ; if ( skb_is_gso ( skb ) || skb_has_frag_list ( skb ) || skb -> csum_bad ) goto normal ; gro_list_prepare ( napi , skb ) ; rcu_read_lock ( ) ; list_for_each_entry_rcu ( ptype , head , list ) { if ( ptype -> type != type || ! ptype -> callbacks . gro_receive ) continue ; skb_set_network_header ( skb , skb_gro_offset ( skb ) ) ; skb_reset_mac_len ( skb ) ; NAPI_GRO_CB ( skb ) -> same_flow = 0 ; NAPI_GRO_CB ( skb ) -> flush = 0 ; NAPI_GRO_CB ( skb ) -> free = 0 ; <S2SV_StartBug> NAPI_GRO_CB ( skb ) -> udp_mark = 0 ; <S2SV_EndBug> NAPI_GRO_CB ( skb ) -> gro_remcsum_start = 0 ; switch ( skb -> ip_summed ) { case CHECKSUM_COMPLETE : NAPI_GRO_CB ( skb ) -> csum = skb -> csum ; NAPI_GRO_CB ( skb ) -> csum_valid = 1 ; NAPI_GRO_CB ( skb ) -> csum_cnt = 0 ; break ; case CHECKSUM_UNNECESSARY : NAPI_GRO_CB ( skb ) -> csum_cnt = skb -> csum_level + 1 ; NAPI_GRO_CB ( skb ) -> csum_valid = 0 ; break ; default : NAPI_GRO_CB ( skb ) -> csum_cnt = 0 ; NAPI_GRO_CB ( skb ) -> csum_valid = 0 ; } pp = ptype -> callbacks . gro_receive ( & napi -> gro_list , skb ) ; break ; } rcu_read_unlock ( ) ; if ( & ptype -> list == head ) goto normal ; same_flow = NAPI_GRO_CB ( skb ) -> same_flow ; ret = NAPI_GRO_CB ( skb ) -> free ? GRO_MERGED_FREE : GRO_MERGED ; if ( pp ) { struct sk_buff * nskb = * pp ; * pp = nskb -> next ; nskb -> next = NULL ; napi_gro_complete ( nskb ) ; napi -> gro_count -- ; } if ( same_flow ) goto ok ; if ( NAPI_GRO_CB ( skb ) -> flush ) goto normal ; if ( unlikely ( napi -> gro_count >= MAX_GRO_SKBS ) ) { struct sk_buff * nskb = napi -> gro_list ; while ( nskb -> next ) { pp = & nskb -> next ; nskb = * pp ; } * pp = NULL ; nskb -> next = NULL ; napi_gro_complete ( nskb ) ; } else { napi -> gro_count ++ ; } NAPI_GRO_CB ( skb ) -> count = 1 ; NAPI_GRO_CB ( skb ) -> age = jiffies ; NAPI_GRO_CB ( skb ) -> last = skb ; skb_shinfo ( skb ) -> gso_size = skb_gro_len ( skb ) ; skb -> next = napi -> gro_list ; napi -> gro_list = skb ; ret = GRO_HELD ; pull : grow = skb_gro_offset ( skb ) - skb_headlen ( skb ) ; if ( grow > 0 ) gro_pull_from_frag0 ( skb , grow ) ; ok : return ret ; normal : ret = GRO_NORMAL ; goto pull ; }\n","target":"<S2SV_ModStart> skb ) -> encap_mark <S2SV_ModEnd> = 0 ;\n","project_and_commit_id":"torvalds@linux/fac8e0f579695a3ecbc4d3cac369139d7f819971","cve_id":"CVE-2016-8666","original_address":"https://github.com/torvalds/linux/commit/fac8e0f579695a3ecbc4d3cac369139d7f819971","time":"2016-10-16T21:59Z"},
	{"Unnamed: 0":2672,"cwe_id":"CWE-20","source":"CWE-20 static void __munlock_pagevec ( struct pagevec * pvec , struct zone * zone ) { int i ; int nr = pagevec_count ( pvec ) ; <S2SV_StartBug> int delta_munlocked ; <S2SV_EndBug> struct pagevec pvec_putback ; int pgrescued = 0 ; pagevec_init ( & pvec_putback , 0 ) ; spin_lock_irq ( zone_lru_lock ( zone ) ) ; for ( i = 0 ; i < nr ; i ++ ) { struct page * page = pvec -> pages [ i ] ; if ( TestClearPageMlocked ( page ) ) { if ( __munlock_isolate_lru_page ( page , false ) ) continue ; else __munlock_isolation_failed ( page ) ; <S2SV_StartBug> } <S2SV_EndBug> pagevec_add ( & pvec_putback , pvec -> pages [ i ] ) ; pvec -> pages [ i ] = NULL ; } <S2SV_StartBug> delta_munlocked = - nr + pagevec_count ( & pvec_putback ) ; <S2SV_EndBug> __mod_zone_page_state ( zone , NR_MLOCK , delta_munlocked ) ; spin_unlock_irq ( zone_lru_lock ( zone ) ) ; pagevec_release ( & pvec_putback ) ; for ( i = 0 ; i < nr ; i ++ ) { struct page * page = pvec -> pages [ i ] ; if ( page ) { lock_page ( page ) ; if ( ! __putback_lru_fast_prepare ( page , & pvec_putback , & pgrescued ) ) { get_page ( page ) ; __munlock_isolated_page ( page ) ; unlock_page ( page ) ; put_page ( page ) ; } } } if ( pagevec_count ( & pvec_putback ) ) __putback_lru_fast ( & pvec_putback , pgrescued ) ; }\n","target":"<S2SV_ModStart> ; int delta_munlocked = - nr <S2SV_ModStart> ) ; } else { delta_munlocked ++ ; } <S2SV_ModStart> NULL ; } <S2SV_ModEnd> __mod_zone_page_state ( zone\n","project_and_commit_id":"torvalds@linux/70feee0e1ef331b22cc51f383d532a0d043fbdcc","cve_id":"CVE-2017-18221","original_address":"https://github.com/torvalds/linux/commit/70feee0e1ef331b22cc51f383d532a0d043fbdcc","time":"2018-03-07T08:29Z"},
	{"Unnamed: 0":0,"cwe_id":"CWE-000","source":"CWE-000 static void unix_release_sock ( struct sock * sk , int embrion ) { struct unix_sock * u = unix_sk ( sk ) ; struct path path ; struct sock * skpair ; struct sk_buff * skb ; int state ; unix_remove_socket ( sk ) ; unix_state_lock ( sk ) ; sock_orphan ( sk ) ; sk -> sk_shutdown = SHUTDOWN_MASK ; path = u -> path ; u -> path . dentry = NULL ; u -> path . mnt = NULL ; state = sk -> sk_state ; sk -> sk_state = TCP_CLOSE ; unix_state_unlock ( sk ) ; wake_up_interruptible_all ( & u -> peer_wait ) ; skpair = unix_peer ( sk ) ; if ( skpair != NULL ) { if ( sk -> sk_type == SOCK_STREAM || sk -> sk_type == SOCK_SEQPACKET ) { unix_state_lock ( skpair ) ; skpair -> sk_shutdown = SHUTDOWN_MASK ; if ( ! skb_queue_empty ( & sk -> sk_receive_queue ) || embrion ) skpair -> sk_err = ECONNRESET ; unix_state_unlock ( skpair ) ; skpair -> sk_state_change ( skpair ) ; sk_wake_async ( skpair , SOCK_WAKE_WAITD , POLL_HUP ) ; } <S2SV_StartBug> sock_put ( skpair ) ; <S2SV_EndBug> unix_peer ( sk ) = NULL ; } while ( ( skb = skb_dequeue ( & sk -> sk_receive_queue ) ) != NULL ) { if ( state == TCP_LISTEN ) unix_release_sock ( skb -> sk , 1 ) ; UNIXCB ( skb ) . consumed = skb -> len ; kfree_skb ( skb ) ; } if ( path . dentry ) path_put ( & path ) ; sock_put ( sk ) ; if ( unix_tot_inflight ) unix_gc ( ) ; }\n","target":"<S2SV_ModStart> ) ; } unix_dgram_peer_wake_disconnect ( sk , skpair ) ;\n","project_and_commit_id":"torvalds@linux/7d267278a9ece963d77eefec61630223fce08c6c","cve_id":"CVE-2013-7446","original_address":"https://github.com/torvalds/linux/commit/7d267278a9ece963d77eefec61630223fce08c6c","time":"2015-12-28T11:59Z"},
	{"Unnamed: 0":3508,"cwe_id":"CWE-119","source":"CWE-119 static int PredictorEncodeTile ( TIFF * tif , uint8 * bp0 , tmsize_t cc0 , uint16 s ) { static const char module [ ] = \"PredictorEncodeTile\" ; TIFFPredictorState * sp = PredictorState ( tif ) ; uint8 * working_copy ; tmsize_t cc = cc0 , rowsize ; unsigned char * bp ; int result_code ; assert ( sp != NULL ) ; assert ( sp -> encodepfunc != NULL ) ; assert ( sp -> encodetile != NULL ) ; working_copy = ( uint8 * ) _TIFFmalloc ( cc0 ) ; if ( working_copy == NULL ) { TIFFErrorExt ( tif -> tif_clientdata , module , \"Out<S2SV_blank>of<S2SV_blank>memory<S2SV_blank>allocating<S2SV_blank>\" TIFF_SSIZE_FORMAT \"<S2SV_blank>byte<S2SV_blank>temp<S2SV_blank>buffer.\" , cc0 ) ; return 0 ; } memcpy ( working_copy , bp0 , cc0 ) ; bp = working_copy ; rowsize = sp -> rowsize ; assert ( rowsize > 0 ) ; <S2SV_StartBug> assert ( ( cc0 % rowsize ) == 0 ) ; <S2SV_EndBug> while ( cc > 0 ) { ( * sp -> encodepfunc ) ( tif , bp , rowsize ) ; cc -= rowsize ; bp += rowsize ; } result_code = ( * sp -> encodetile ) ( tif , working_copy , cc0 , s ) ; _TIFFfree ( working_copy ) ; return result_code ; }\n","target":"<S2SV_ModStart> 0 ) ; if <S2SV_ModEnd> ( ( cc0 <S2SV_ModStart> % rowsize ) != 0 ) { TIFFErrorExt ( tif -> tif_clientdata , \"PredictorEncodeTile\" , \"%s\" , \"(cc0%rowsize)!=0\" ) ; return 0 ; } <S2SV_ModEnd> while ( cc\n","project_and_commit_id":"vadz@libtiff/3ca657a8793dd011bf869695d72ad31c779c3cc1","cve_id":"CVE-2016-9535","original_address":"https://github.com/vadz/libtiff/commit/3ca657a8793dd011bf869695d72ad31c779c3cc1","time":"2016-11-22T19:59Z"},
	{"Unnamed: 0":2521,"cwe_id":"CWE-119","source":"CWE-119 static ssize_t wdm_read ( struct file * file , char __user * buffer , size_t count , loff_t * ppos ) { int rv , cntr ; int i = 0 ; struct wdm_device * desc = file -> private_data ; rv = mutex_lock_interruptible ( & desc -> rlock ) ; if ( rv < 0 ) return - ERESTARTSYS ; cntr = ACCESS_ONCE ( desc -> length ) ; if ( cntr == 0 ) { desc -> read = 0 ; retry : if ( test_bit ( WDM_DISCONNECTING , & desc -> flags ) ) { rv = - ENODEV ; goto err ; } <S2SV_StartBug> i ++ ; <S2SV_EndBug> if ( file -> f_flags & O_NONBLOCK ) { if ( ! test_bit ( WDM_READ , & desc -> flags ) ) { rv = cntr ? cntr : - EAGAIN ; goto err ; } rv = 0 ; } else { rv = wait_event_interruptible ( desc -> wait , test_bit ( WDM_READ , & desc -> flags ) ) ; } if ( test_bit ( WDM_DISCONNECTING , & desc -> flags ) ) { rv = - ENODEV ; goto err ; } if ( test_bit ( WDM_RESETTING , & desc -> flags ) ) { rv = - EIO ; goto err ; } usb_mark_last_busy ( interface_to_usbdev ( desc -> intf ) ) ; if ( rv < 0 ) { rv = - ERESTARTSYS ; goto err ; } spin_lock_irq ( & desc -> iuspin ) ; if ( desc -> rerr ) { desc -> rerr = 0 ; spin_unlock_irq ( & desc -> iuspin ) ; rv = - EIO ; goto err ; } if ( ! test_bit ( WDM_READ , & desc -> flags ) ) { spin_unlock_irq ( & desc -> iuspin ) ; goto retry ; } if ( ! desc -> reslength ) { dev_dbg ( & desc -> intf -> dev , \"%s:<S2SV_blank>zero<S2SV_blank>length<S2SV_blank>-<S2SV_blank>clearing<S2SV_blank>WDM_READ\\\\n\" , __func__ ) ; clear_bit ( WDM_READ , & desc -> flags ) ; spin_unlock_irq ( & desc -> iuspin ) ; goto retry ; } cntr = desc -> length ; spin_unlock_irq ( & desc -> iuspin ) ; } if ( cntr > count ) cntr = count ; rv = copy_to_user ( buffer , desc -> ubuf , cntr ) ; if ( rv > 0 ) { rv = - EFAULT ; goto err ; } spin_lock_irq ( & desc -> iuspin ) ; for ( i = 0 ; i < desc -> length - cntr ; i ++ ) desc -> ubuf [ i ] = desc -> ubuf [ i + cntr ] ; desc -> length -= cntr ; if ( ! desc -> length ) clear_bit ( WDM_READ , & desc -> flags ) ; spin_unlock_irq ( & desc -> iuspin ) ; rv = cntr ; err : mutex_unlock ( & desc -> rlock ) ; return rv ; }\n","target":"<S2SV_ModStart> err ; } if ( test_bit ( WDM_OVERFLOW , & desc -> flags ) ) { clear_bit ( WDM_OVERFLOW , & desc -> flags ) ; rv = - ENOBUFS ; goto err ; }\n","project_and_commit_id":"torvalds@linux/c0f5ecee4e741667b2493c742b60b6218d40b3aa","cve_id":"CVE-2013-1860","original_address":"https://github.com/torvalds/linux/commit/c0f5ecee4e741667b2493c742b60b6218d40b3aa","time":"2013-03-22T11:59Z"},
	{"Unnamed: 0":759,"cwe_id":"CWE-787","source":"CWE-787 static void WritePixels ( struct ngiflib_img * i , struct ngiflib_decode_context * context , const u8 * pixels , u16 n ) { u16 tocopy ; struct ngiflib_gif * p = i -> parent ; while ( n > 0 ) { tocopy = ( context -> Xtogo < n ) ? context -> Xtogo : n ; if ( ! i -> gce . transparent_flag ) { # ifndef NGIFLIB_INDEXED_ONLY if ( p -> mode & NGIFLIB_MODE_INDEXED ) { # endif ngiflib_memcpy ( context -> frbuff_p . p8 , pixels , tocopy ) ; pixels += tocopy ; context -> frbuff_p . p8 += tocopy ; # ifndef NGIFLIB_INDEXED_ONLY } else { int j ; for ( j = ( int ) tocopy ; j > 0 ; j -- ) { * ( context -> frbuff_p . p32 ++ ) = GifIndexToTrueColor ( i -> palette , * pixels ++ ) ; } } # endif } else { int j ; # ifndef NGIFLIB_INDEXED_ONLY if ( p -> mode & NGIFLIB_MODE_INDEXED ) { # endif for ( j = ( int ) tocopy ; j > 0 ; j -- ) { if ( * pixels != i -> gce . transparent_color ) * context -> frbuff_p . p8 = * pixels ; pixels ++ ; context -> frbuff_p . p8 ++ ; } # ifndef NGIFLIB_INDEXED_ONLY } else { for ( j = ( int ) tocopy ; j > 0 ; j -- ) { if ( * pixels != i -> gce . transparent_color ) { * context -> frbuff_p . p32 = GifIndexToTrueColor ( i -> palette , * pixels ) ; } pixels ++ ; context -> frbuff_p . p32 ++ ; } } # endif } context -> Xtogo -= tocopy ; if ( context -> Xtogo == 0 ) { # ifdef NGIFLIB_ENABLE_CALLBACKS if ( p -> line_cb ) p -> line_cb ( p , context -> line_p , context -> curY ) ; # endif context -> Xtogo = i -> width ; switch ( context -> pass ) { case 0 : context -> curY ++ ; break ; case 1 : context -> curY += 8 ; <S2SV_StartBug> if ( context -> curY >= p -> height ) { <S2SV_EndBug> context -> pass ++ ; context -> curY = i -> posY + 4 ; } break ; case 2 : context -> curY += 8 ; <S2SV_StartBug> if ( context -> curY >= p -> height ) { <S2SV_EndBug> context -> pass ++ ; context -> curY = i -> posY + 2 ; } break ; case 3 : context -> curY += 4 ; <S2SV_StartBug> if ( context -> curY >= p -> height ) { <S2SV_EndBug> context -> pass ++ ; context -> curY = i -> posY + 1 ; } break ; case 4 : context -> curY += 2 ; <S2SV_StartBug> break ; <S2SV_EndBug> } # ifndef NGIFLIB_INDEXED_ONLY if ( p -> mode & NGIFLIB_MODE_INDEXED ) { # endif # ifdef NGIFLIB_ENABLE_CALLBACKS context -> line_p . p8 = p -> frbuff . p8 + ( u32 ) context -> curY * p -> width ; context -> frbuff_p . p8 = context -> line_p . p8 + i -> posX ; # else context -> frbuff_p . p8 = p -> frbuff . p8 + ( u32 ) context -> curY * p -> width + i -> posX ; # endif # ifndef NGIFLIB_INDEXED_ONLY } else { # ifdef NGIFLIB_ENABLE_CALLBACKS context -> line_p . p32 = p -> frbuff . p32 + ( u32 ) context -> curY * p -> width ; context -> frbuff_p . p32 = context -> line_p . p32 + i -> posX ; # else context -> frbuff_p . p32 = p -> frbuff . p32 + ( u32 ) context -> curY * p -> width + i -> posX ; # endif } # endif } n -= tocopy ; } }\n","target":"<S2SV_ModStart> += 8 ; <S2SV_ModEnd> break ; case <S2SV_ModStart> += 8 ; <S2SV_ModEnd> break ; case <S2SV_ModStart> += 4 ; <S2SV_ModEnd> break ; case <S2SV_ModStart> ; break ; } while ( context -> pass > 0 && context -> pass < 4 && context -> curY >= p -> height ) { switch ( ++ context -> pass ) { case 2 : context -> curY = i -> posY + 4 ; break ; case 3 : context -> curY = i -> posY + 2 ; break ; case 4 : context -> curY = i -> posY + 1 ; break ; }\n","project_and_commit_id":"miniupnp@ngiflib/37d939a6f511d16d4c95678025c235fe62e6417a","cve_id":"CVE-2019-16347","original_address":"https://github.com/miniupnp/ngiflib/commit/37d939a6f511d16d4c95678025c235fe62e6417a","time":"2019-09-16T13:15Z"},
	{"Unnamed: 0":2129,"cwe_id":"CWE-617","source":"CWE-617 struct pci_vdev * pci_get_vdev_info ( int slot ) { struct businfo * bi ; struct slotinfo * si ; struct pci_vdev * dev = NULL ; bi = pci_businfo [ 0 ] ; <S2SV_StartBug> assert ( bi != NULL ) ; <S2SV_EndBug> si = & bi -> slotinfo [ slot ] ; if ( si != NULL ) dev = si -> si_funcs [ 0 ] . fi_devi ; else fprintf ( stderr , \"slot=%d<S2SV_blank>is<S2SV_blank>empty!\\\\n\" , slot ) ; return dev ; }\n","target":"<S2SV_ModStart> 0 ] ; if ( bi == NULL ) return NULL <S2SV_ModEnd> ; si =\n","project_and_commit_id":"projectacrn@acrn-hypervisor/2b3dedfb9ba13f15887f22b935d373f36c9a59fa","cve_id":"CVE-2019-18844","original_address":"https://github.com/projectacrn/acrn-hypervisor/commit/2b3dedfb9ba13f15887f22b935d373f36c9a59fa","time":"2019-11-13T20:15Z"},
	{"Unnamed: 0":895,"cwe_id":"CWE-787","source":"CWE-787 <S2SV_StartBug> static void nsc_encode_subsampling ( NSC_CONTEXT * context ) <S2SV_EndBug> { UINT16 x ; UINT16 y ; <S2SV_StartBug> BYTE * co_dst ; <S2SV_EndBug> BYTE * cg_dst ; INT8 * co_src0 ; INT8 * co_src1 ; INT8 * cg_src0 ; INT8 * cg_src1 ; UINT32 tempWidth ; <S2SV_StartBug> UINT32 tempHeight ; <S2SV_EndBug> tempWidth = ROUND_UP_TO ( context -> width , 8 ) ; tempHeight = ROUND_UP_TO ( context -> height , 2 ) ; <S2SV_StartBug> for ( y = 0 ; y < tempHeight >> 1 ; y ++ ) <S2SV_EndBug> { <S2SV_StartBug> co_dst = context -> priv -> PlaneBuffers [ 1 ] + y * ( tempWidth >> 1 ) ; <S2SV_EndBug> <S2SV_StartBug> cg_dst = context -> priv -> PlaneBuffers [ 2 ] + y * ( tempWidth >> 1 ) ; <S2SV_EndBug> <S2SV_StartBug> co_src0 = ( INT8 * ) context -> priv -> PlaneBuffers [ 1 ] + ( y << 1 ) * tempWidth ; <S2SV_EndBug> <S2SV_StartBug> co_src1 = co_src0 + tempWidth ; <S2SV_EndBug> <S2SV_StartBug> cg_src0 = ( INT8 * ) context -> priv -> PlaneBuffers [ 2 ] + ( y << 1 ) * tempWidth ; <S2SV_EndBug> <S2SV_StartBug> cg_src1 = cg_src0 + tempWidth ; <S2SV_EndBug> for ( x = 0 ; x < tempWidth >> 1 ; x ++ ) { * co_dst ++ = ( BYTE ) ( ( ( INT16 ) * co_src0 + ( INT16 ) * ( co_src0 + 1 ) + ( INT16 ) * co_src1 + ( INT16 ) * ( co_src1 + 1 ) ) >> 2 ) ; * cg_dst ++ = ( BYTE ) ( ( ( INT16 ) * cg_src0 + ( INT16 ) * ( cg_src0 + 1 ) + ( INT16 ) * cg_src1 + ( INT16 ) * ( cg_src1 + 1 ) ) >> 2 ) ; co_src0 += 2 ; co_src1 += 2 ; cg_src0 += 2 ; cg_src1 += 2 ; } } <S2SV_StartBug> } <S2SV_EndBug>\n","target":"<S2SV_ModStart> <S2SV_null> <S2SV_null> static BOOL <S2SV_ModEnd> nsc_encode_subsampling ( NSC_CONTEXT <S2SV_ModStart> UINT16 y ; <S2SV_ModEnd> UINT32 tempWidth ; <S2SV_ModStart> ; UINT32 tempHeight ; if ( ! context ) return FALSE <S2SV_ModStart> 2 ) ; if ( tempHeight == 0 ) return FALSE ; if ( tempWidth > context -> priv -> PlaneBuffersLength / tempHeight ) return FALSE ; <S2SV_ModStart> ++ ) { BYTE * <S2SV_ModStart> 1 ) ; BYTE * <S2SV_ModStart> 1 ) ; const INT8 * <S2SV_ModStart> * tempWidth ; const INT8 * <S2SV_ModStart> + tempWidth ; const INT8 * <S2SV_ModStart> * tempWidth ; const INT8 * <S2SV_ModStart> ; } } return TRUE ;\n","project_and_commit_id":"FreeRDP@FreeRDP/d1112c279bd1a327e8e4d0b5f371458bf2579659","cve_id":"CVE-2018-8788","original_address":"https://github.com/FreeRDP/FreeRDP/commit/d1112c279bd1a327e8e4d0b5f371458bf2579659","time":"2018-11-29T18:29Z"},
	{"Unnamed: 0":1786,"cwe_id":"CWE-834","source":"CWE-834 static MagickBooleanType ReadPSDLayersInternal ( Image * image , const ImageInfo * image_info , const PSDInfo * psd_info , const MagickBooleanType skip_layers , ExceptionInfo * exception ) { char type [ 4 ] ; LayerInfo * layer_info ; MagickSizeType size ; MagickBooleanType status ; register ssize_t i ; ssize_t count , j , number_layers ; size = GetPSDSize ( psd_info , image ) ; if ( size == 0 ) { ( void ) ReadBlobLong ( image ) ; count = ReadBlob ( image , 4 , ( unsigned char * ) type ) ; ReversePSDString ( image , type , 4 ) ; status = MagickFalse ; if ( ( count == 0 ) || ( LocaleNCompare ( type , \"8BIM\" , 4 ) != 0 ) ) return ( MagickTrue ) ; else { count = ReadBlob ( image , 4 , ( unsigned char * ) type ) ; ReversePSDString ( image , type , 4 ) ; if ( ( count != 0 ) && ( LocaleNCompare ( type , \"Lr16\" , 4 ) == 0 ) ) size = GetPSDSize ( psd_info , image ) ; else return ( MagickTrue ) ; } } status = MagickTrue ; if ( size != 0 ) { layer_info = ( LayerInfo * ) NULL ; number_layers = ( short ) ReadBlobShort ( image ) ; if ( number_layers < 0 ) { number_layers = MagickAbsoluteValue ( number_layers ) ; if ( image -> debug != MagickFalse ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , \"<S2SV_blank><S2SV_blank>negative<S2SV_blank>layer<S2SV_blank>count<S2SV_blank>corrected<S2SV_blank>for\" ) ; image -> alpha_trait = BlendPixelTrait ; } if ( skip_layers != MagickFalse ) return ( MagickTrue ) ; if ( image -> debug != MagickFalse ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , \"<S2SV_blank><S2SV_blank>image<S2SV_blank>contains<S2SV_blank>%.20g<S2SV_blank>layers\" , ( double ) number_layers ) ; if ( number_layers == 0 ) ThrowBinaryException ( CorruptImageError , \"InvalidNumberOfLayers\" , image -> filename ) ; layer_info = ( LayerInfo * ) AcquireQuantumMemory ( ( size_t ) number_layers , sizeof ( * layer_info ) ) ; if ( layer_info == ( LayerInfo * ) NULL ) { if ( image -> debug != MagickFalse ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , \"<S2SV_blank><S2SV_blank>allocation<S2SV_blank>of<S2SV_blank>LayerInfo<S2SV_blank>failed\" ) ; ThrowBinaryException ( ResourceLimitError , \"MemoryAllocationFailed\" , image -> filename ) ; } ( void ) ResetMagickMemory ( layer_info , 0 , ( size_t ) number_layers * sizeof ( * layer_info ) ) ; for ( i = 0 ; i < number_layers ; i ++ ) { ssize_t x , y ; if ( image -> debug != MagickFalse ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , \"<S2SV_blank><S2SV_blank>reading<S2SV_blank>layer<S2SV_blank>#%.20g\" , ( double ) i + 1 ) ; layer_info [ i ] . page . y = ReadBlobSignedLong ( image ) ; layer_info [ i ] . page . x = ReadBlobSignedLong ( image ) ; y = ReadBlobSignedLong ( image ) ; x = ReadBlobSignedLong ( image ) ; layer_info [ i ] . page . width = ( size_t ) ( x - layer_info [ i ] . page . x ) ; layer_info [ i ] . page . height = ( size_t ) ( y - layer_info [ i ] . page . y ) ; layer_info [ i ] . channels = ReadBlobShort ( image ) ; if ( layer_info [ i ] . channels > MaxPSDChannels ) { layer_info = DestroyLayerInfo ( layer_info , number_layers ) ; ThrowBinaryException ( CorruptImageError , \"MaximumChannelsExceeded\" , image -> filename ) ; } if ( image -> debug != MagickFalse ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , \"<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>offset(%.20g,%.20g),<S2SV_blank>size(%.20g,%.20g),<S2SV_blank>channels=%.20g\" , ( double ) layer_info [ i ] . page . x , ( double ) layer_info [ i ] . page . y , ( double ) layer_info [ i ] . page . height , ( double ) layer_info [ i ] . page . width , ( double ) layer_info [ i ] . channels ) ; for ( j = 0 ; j < ( ssize_t ) layer_info [ i ] . channels ; j ++ ) { layer_info [ i ] . channel_info [ j ] . type = ( short ) ReadBlobShort ( image ) ; layer_info [ i ] . channel_info [ j ] . size = ( size_t ) GetPSDSize ( psd_info , image ) ; if ( image -> debug != MagickFalse ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , \"<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>channel[%.20g]:<S2SV_blank>type=%.20g,<S2SV_blank>size=%.20g\" , ( double ) j , ( double ) layer_info [ i ] . channel_info [ j ] . type , ( double ) layer_info [ i ] . channel_info [ j ] . size ) ; } count = ReadBlob ( image , 4 , ( unsigned char * ) type ) ; ReversePSDString ( image , type , 4 ) ; if ( ( count == 0 ) || ( LocaleNCompare ( type , \"8BIM\" , 4 ) != 0 ) ) { if ( image -> debug != MagickFalse ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , \"<S2SV_blank><S2SV_blank>layer<S2SV_blank>type<S2SV_blank>was<S2SV_blank>%.4s<S2SV_blank>instead<S2SV_blank>of<S2SV_blank>8BIM\" , type ) ; layer_info = DestroyLayerInfo ( layer_info , number_layers ) ; ThrowBinaryException ( CorruptImageError , \"ImproperImageHeader\" , image -> filename ) ; } count = ReadBlob ( image , 4 , ( unsigned char * ) layer_info [ i ] . blendkey ) ; ReversePSDString ( image , layer_info [ i ] . blendkey , 4 ) ; layer_info [ i ] . opacity = ( Quantum ) ScaleCharToQuantum ( ( unsigned char ) ReadBlobByte ( image ) ) ; layer_info [ i ] . clipping = ( unsigned char ) ReadBlobByte ( image ) ; layer_info [ i ] . flags = ( unsigned char ) ReadBlobByte ( image ) ; layer_info [ i ] . visible = ! ( layer_info [ i ] . flags & 0x02 ) ; if ( image -> debug != MagickFalse ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , \"<S2SV_blank><S2SV_blank><S2SV_blank>blend=%.4s,<S2SV_blank>opacity=%.20g,<S2SV_blank>clipping=%s,<S2SV_blank>flags=%d,<S2SV_blank>visible=%s\" , layer_info [ i ] . blendkey , ( double ) layer_info [ i ] . opacity , layer_info [ i ] . clipping ? \"true\" : \"false\" , layer_info [ i ] . flags , layer_info [ i ] . visible ? \"true\" : \"false\" ) ; ( void ) ReadBlobByte ( image ) ; size = ReadBlobLong ( image ) ; if ( size != 0 ) { MagickSizeType combined_length , length ; if ( image -> debug != MagickFalse ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , \"<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>layer<S2SV_blank>contains<S2SV_blank>additional<S2SV_blank>info\" ) ; length = ReadBlobLong ( image ) ; combined_length = length + 4 ; if ( length != 0 ) { layer_info [ i ] . mask . page . y = ReadBlobSignedLong ( image ) ; layer_info [ i ] . mask . page . x = ReadBlobSignedLong ( image ) ; layer_info [ i ] . mask . page . height = ( size_t ) ( ReadBlobSignedLong ( image ) - layer_info [ i ] . mask . page . y ) ; layer_info [ i ] . mask . page . width = ( size_t ) ( ReadBlobSignedLong ( image ) - layer_info [ i ] . mask . page . x ) ; layer_info [ i ] . mask . background = ( unsigned char ) ReadBlobByte ( image ) ; layer_info [ i ] . mask . flags = ( unsigned char ) ReadBlobByte ( image ) ; if ( ! ( layer_info [ i ] . mask . flags & 0x01 ) ) { layer_info [ i ] . mask . page . y = layer_info [ i ] . mask . page . y - layer_info [ i ] . page . y ; layer_info [ i ] . mask . page . x = layer_info [ i ] . mask . page . x - layer_info [ i ] . page . x ; } if ( image -> debug != MagickFalse ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , \"<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>layer<S2SV_blank>mask:<S2SV_blank>offset(%.20g,%.20g),<S2SV_blank>size(%.20g,%.20g),<S2SV_blank>length=%.20g\" , ( double ) layer_info [ i ] . mask . page . x , ( double ) layer_info [ i ] . mask . page . y , ( double ) layer_info [ i ] . mask . page . width , ( double ) layer_info [ i ] . mask . page . height , ( double ) ( ( MagickOffsetType ) length ) - 18 ) ; if ( DiscardBlobBytes ( image , ( MagickSizeType ) ( length - 18 ) ) == MagickFalse ) { layer_info = DestroyLayerInfo ( layer_info , number_layers ) ; ThrowBinaryException ( CorruptImageError , \"UnexpectedEndOfFile\" , image -> filename ) ; } } length = ReadBlobLong ( image ) ; combined_length += length + 4 ; if ( length != 0 ) { if ( image -> debug != MagickFalse ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , \"<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>layer<S2SV_blank>blending<S2SV_blank>ranges:<S2SV_blank>length=%.20g\" , ( double ) ( ( MagickOffsetType ) length ) ) ; <S2SV_StartBug> for ( j = 0 ; j < ( ssize_t ) length ; j += 8 ) <S2SV_EndBug> { size_t blend_source = ReadBlobLong ( image ) ; size_t blend_dest = ReadBlobLong ( image ) ; if ( EOFBlob ( image ) != MagickFalse ) { layer_info = DestroyLayerInfo ( layer_info , number_layers ) ; ThrowBinaryException ( CorruptImageError , <S2SV_StartBug> \"InsufficientImageDataInFile\" , image -> filename ) ; <S2SV_EndBug> } if ( image -> debug != MagickFalse ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , \"<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>source(%x),<S2SV_blank>dest(%x)\" , ( unsigned int ) blend_source , ( unsigned int ) blend_dest ) ; } } length = ( MagickSizeType ) ( unsigned char ) ReadBlobByte ( image ) ; combined_length += length + 1 ; if ( length > 0 ) ( void ) ReadBlob ( image , ( size_t ) length ++ , layer_info [ i ] . name ) ; layer_info [ i ] . name [ length ] = '\\\\0' ; if ( image -> debug != MagickFalse ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , \"<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>layer<S2SV_blank>name:<S2SV_blank>%s\" , layer_info [ i ] . name ) ; if ( ( length % 4 ) != 0 ) { length = 4 - ( length % 4 ) ; combined_length += length ; if ( DiscardBlobBytes ( image , length ) == MagickFalse ) { layer_info = DestroyLayerInfo ( layer_info , number_layers ) ; ThrowBinaryException ( CorruptImageError , \"UnexpectedEndOfFile\" , image -> filename ) ; } } length = ( MagickSizeType ) size - combined_length ; if ( length > 0 ) { unsigned char * info ; if ( length > GetBlobSize ( image ) ) { layer_info = DestroyLayerInfo ( layer_info , number_layers ) ; ThrowBinaryException ( CorruptImageError , \"InsufficientImageDataInFile\" , image -> filename ) ; } layer_info [ i ] . info = AcquireStringInfo ( ( const size_t ) length ) ; info = GetStringInfoDatum ( layer_info [ i ] . info ) ; ( void ) ReadBlob ( image , ( const size_t ) length , info ) ; } } } for ( i = 0 ; i < number_layers ; i ++ ) { if ( ( layer_info [ i ] . page . width == 0 ) || ( layer_info [ i ] . page . height == 0 ) ) { if ( image -> debug != MagickFalse ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , \"<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>layer<S2SV_blank>data<S2SV_blank>is<S2SV_blank>empty\" ) ; if ( layer_info [ i ] . info != ( StringInfo * ) NULL ) layer_info [ i ] . info = DestroyStringInfo ( layer_info [ i ] . info ) ; continue ; } layer_info [ i ] . image = CloneImage ( image , layer_info [ i ] . page . width , layer_info [ i ] . page . height , MagickFalse , exception ) ; if ( layer_info [ i ] . image == ( Image * ) NULL ) { layer_info = DestroyLayerInfo ( layer_info , number_layers ) ; if ( image -> debug != MagickFalse ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , \"<S2SV_blank><S2SV_blank>allocation<S2SV_blank>of<S2SV_blank>image<S2SV_blank>for<S2SV_blank>layer<S2SV_blank>%.20g<S2SV_blank>failed\" , ( double ) i ) ; ThrowBinaryException ( ResourceLimitError , \"MemoryAllocationFailed\" , image -> filename ) ; } if ( layer_info [ i ] . info != ( StringInfo * ) NULL ) { ( void ) SetImageProfile ( layer_info [ i ] . image , \"psd:additional-info\" , layer_info [ i ] . info , exception ) ; layer_info [ i ] . info = DestroyStringInfo ( layer_info [ i ] . info ) ; } } if ( image_info -> ping == MagickFalse ) { for ( i = 0 ; i < number_layers ; i ++ ) { if ( layer_info [ i ] . image == ( Image * ) NULL ) { for ( j = 0 ; j < layer_info [ i ] . channels ; j ++ ) { if ( DiscardBlobBytes ( image , ( MagickSizeType ) layer_info [ i ] . channel_info [ j ] . size ) == MagickFalse ) { layer_info = DestroyLayerInfo ( layer_info , number_layers ) ; ThrowBinaryException ( CorruptImageError , \"UnexpectedEndOfFile\" , image -> filename ) ; } } continue ; } if ( image -> debug != MagickFalse ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , \"<S2SV_blank><S2SV_blank>reading<S2SV_blank>data<S2SV_blank>for<S2SV_blank>layer<S2SV_blank>%.20g\" , ( double ) i ) ; status = ReadPSDLayer ( image , image_info , psd_info , & layer_info [ i ] , exception ) ; if ( status == MagickFalse ) break ; status = SetImageProgress ( image , LoadImagesTag , i , ( MagickSizeType ) number_layers ) ; if ( status == MagickFalse ) break ; } } if ( status != MagickFalse ) { for ( i = 0 ; i < number_layers ; i ++ ) { if ( layer_info [ i ] . image == ( Image * ) NULL ) { for ( j = i ; j < number_layers - 1 ; j ++ ) layer_info [ j ] = layer_info [ j + 1 ] ; number_layers -- ; i -- ; } } if ( number_layers > 0 ) { for ( i = 0 ; i < number_layers ; i ++ ) { if ( i > 0 ) layer_info [ i ] . image -> previous = layer_info [ i - 1 ] . image ; if ( i < ( number_layers - 1 ) ) layer_info [ i ] . image -> next = layer_info [ i + 1 ] . image ; layer_info [ i ] . image -> page = layer_info [ i ] . page ; } image -> next = layer_info [ 0 ] . image ; layer_info [ 0 ] . image -> previous = image ; } layer_info = ( LayerInfo * ) RelinquishMagickMemory ( layer_info ) ; } else layer_info = DestroyLayerInfo ( layer_info , number_layers ) ; } return ( status ) ; }\n","target":"<S2SV_ModStart> ) ) ; if ( DiscardBlobBytes ( image , length ) == <S2SV_ModEnd> MagickFalse ) { <S2SV_ModStart> ( CorruptImageError , \"UnexpectedEndOfFile\" <S2SV_ModEnd> , image -> <S2SV_ModStart> image -> filename <S2SV_ModEnd> ) ; }\n","project_and_commit_id":"ImageMagick@ImageMagick/04a567494786d5bb50894fc8bb8fea0cf496bea8","cve_id":"CVE-2017-14174","original_address":"https://github.com/ImageMagick/ImageMagick/commit/04a567494786d5bb50894fc8bb8fea0cf496bea8","time":"2017-09-07T06:29Z"},
	{"Unnamed: 0":4855,"cwe_id":"CWE-399","source":"CWE-399 static netdev_tx_t veth_xmit ( struct sk_buff * skb , struct net_device * dev ) { struct net_device * rcv = NULL ; struct veth_priv * priv , * rcv_priv ; struct veth_net_stats * stats , * rcv_stats ; int length ; priv = netdev_priv ( dev ) ; rcv = priv -> peer ; rcv_priv = netdev_priv ( rcv ) ; stats = this_cpu_ptr ( priv -> stats ) ; rcv_stats = this_cpu_ptr ( rcv_priv -> stats ) ; if ( ! ( rcv -> flags & IFF_UP ) ) goto tx_drop ; if ( dev -> features & NETIF_F_NO_CSUM ) skb -> ip_summed = rcv_priv -> ip_summed ; length = skb -> len + ETH_HLEN ; if ( dev_forward_skb ( rcv , skb ) != NET_RX_SUCCESS ) goto rx_drop ; stats -> tx_bytes += length ; stats -> tx_packets ++ ; rcv_stats -> rx_bytes += length ; rcv_stats -> rx_packets ++ ; return NETDEV_TX_OK ; tx_drop : kfree_skb ( skb ) ; stats -> tx_dropped ++ ; return NETDEV_TX_OK ; rx_drop : <S2SV_StartBug> kfree_skb ( skb ) ; <S2SV_EndBug> rcv_stats -> rx_dropped ++ ; return NETDEV_TX_OK ; }\n","target":"<S2SV_ModStart> ; rx_drop : <S2SV_ModEnd> rcv_stats -> rx_dropped\n","project_and_commit_id":"torvalds@linux/6ec82562ffc6f297d0de36d65776cff8e5704867","cve_id":"CVE-2013-2017","original_address":"https://github.com/torvalds/linux/commit/6ec82562ffc6f297d0de36d65776cff8e5704867","time":"2013-05-03T11:57Z"},
	{"Unnamed: 0":1853,"cwe_id":"CWE-189","source":"CWE-189 void jiffies_to_timespec ( const unsigned long jiffies , struct timespec * value ) { <S2SV_StartBug> u64 nsec = ( u64 ) jiffies * TICK_NSEC ; <S2SV_EndBug> <S2SV_StartBug> value -> tv_sec = div_long_long_rem ( nsec , NSEC_PER_SEC , & value -> tv_nsec ) ; <S2SV_EndBug> }\n","target":"<S2SV_ModStart> value ) { u32 rem ; value -> tv_sec = div_u64_rem ( <S2SV_ModEnd> ( u64 ) <S2SV_ModStart> jiffies * TICK_NSEC , NSEC_PER_SEC , & rem ) <S2SV_ModStart> ; value -> tv_nsec = rem <S2SV_ModEnd> ; } <S2SV_null>\n","project_and_commit_id":"torvalds@linux/f8bd2258e2d520dff28c855658bd24bdafb5102d","cve_id":"CVE-2011-3209","original_address":"https://github.com/torvalds/linux/commit/f8bd2258e2d520dff28c855658bd24bdafb5102d","time":"2012-10-03T11:02Z"},
	{"Unnamed: 0":3428,"cwe_id":"CWE-119","source":"CWE-119 int dtls1_get_record ( SSL * s ) { int ssl_major , ssl_minor ; int i , n ; SSL3_RECORD * rr ; unsigned char * p = NULL ; unsigned short version ; DTLS1_BITMAP * bitmap ; unsigned int is_next_epoch ; rr = & ( s -> s3 -> rrec ) ; <S2SV_StartBug> dtls1_process_buffered_records ( s ) ; <S2SV_EndBug> if ( dtls1_get_processed_record ( s ) ) return 1 ; again : if ( ( s -> rstate != SSL_ST_READ_BODY ) || ( s -> packet_length < DTLS1_RT_HEADER_LENGTH ) ) { n = ssl3_read_n ( s , DTLS1_RT_HEADER_LENGTH , s -> s3 -> rbuf . len , 0 ) ; if ( n <= 0 ) return ( n ) ; if ( s -> packet_length != DTLS1_RT_HEADER_LENGTH ) { s -> packet_length = 0 ; goto again ; } s -> rstate = SSL_ST_READ_BODY ; p = s -> packet ; if ( s -> msg_callback ) s -> msg_callback ( 0 , 0 , SSL3_RT_HEADER , p , DTLS1_RT_HEADER_LENGTH , s , s -> msg_callback_arg ) ; rr -> type = * ( p ++ ) ; ssl_major = * ( p ++ ) ; ssl_minor = * ( p ++ ) ; version = ( ssl_major << 8 ) | ssl_minor ; n2s ( p , rr -> epoch ) ; memcpy ( & ( s -> s3 -> read_sequence [ 2 ] ) , p , 6 ) ; p += 6 ; n2s ( p , rr -> length ) ; if ( ! s -> first_packet ) { if ( version != s -> version ) { rr -> length = 0 ; s -> packet_length = 0 ; goto again ; } } if ( ( version & 0xff00 ) != ( s -> version & 0xff00 ) ) { rr -> length = 0 ; s -> packet_length = 0 ; goto again ; } if ( rr -> length > SSL3_RT_MAX_ENCRYPTED_LENGTH ) { rr -> length = 0 ; s -> packet_length = 0 ; goto again ; } } if ( rr -> length > s -> packet_length - DTLS1_RT_HEADER_LENGTH ) { i = rr -> length ; n = ssl3_read_n ( s , i , i , 1 ) ; if ( n != i ) { rr -> length = 0 ; s -> packet_length = 0 ; goto again ; } } s -> rstate = SSL_ST_READ_HEADER ; bitmap = dtls1_get_bitmap ( s , rr , & is_next_epoch ) ; if ( bitmap == NULL ) { rr -> length = 0 ; s -> packet_length = 0 ; goto again ; } # ifndef OPENSSL_NO_SCTP if ( ! BIO_dgram_is_sctp ( SSL_get_rbio ( s ) ) ) { # endif if ( ! ( s -> d1 -> listen && rr -> type == SSL3_RT_HANDSHAKE && s -> packet_length > DTLS1_RT_HEADER_LENGTH && s -> packet [ DTLS1_RT_HEADER_LENGTH ] == SSL3_MT_CLIENT_HELLO ) && ! dtls1_record_replay_check ( s , bitmap ) ) { rr -> length = 0 ; s -> packet_length = 0 ; goto again ; } # ifndef OPENSSL_NO_SCTP } # endif if ( rr -> length == 0 ) goto again ; if ( is_next_epoch ) { if ( ( SSL_in_init ( s ) || s -> in_handshake ) && ! s -> d1 -> listen ) { <S2SV_StartBug> dtls1_buffer_record ( s , & ( s -> d1 -> unprocessed_rcds ) , rr -> seq_num ) ; <S2SV_EndBug> } rr -> length = 0 ; s -> packet_length = 0 ; goto again ; } if ( ! dtls1_process_record ( s ) ) { rr -> length = 0 ; s -> packet_length = 0 ; goto again ; } <S2SV_StartBug> return ( 1 ) ; <S2SV_EndBug> }\n","target":"<S2SV_ModStart> rrec ) ; if ( <S2SV_ModStart> ( s ) < 0 ) return - 1 <S2SV_ModStart> listen ) { if ( <S2SV_ModStart> rr -> seq_num ) < 0 ) return - 1 ; dtls1_record_bitmap_update ( s , bitmap <S2SV_ModStart> again ; } dtls1_record_bitmap_update ( s , bitmap ) ;\n","project_and_commit_id":"openssl@openssl/103b171d8fc282ef435f8de9afbf7782e312961f","cve_id":"CVE-2015-0206","original_address":"https://github.com/openssl/openssl/commit/103b171d8fc282ef435f8de9afbf7782e312961f","time":"2015-01-09T02:59Z"},
	{"Unnamed: 0":5644,"cwe_id":"CWE-125","source":"CWE-125 void __skb_tstamp_tx ( struct sk_buff * orig_skb , struct skb_shared_hwtstamps * hwtstamps , struct sock * sk , int tstype ) { struct sk_buff * skb ; <S2SV_StartBug> bool tsonly ; <S2SV_EndBug> if ( ! sk ) return ; tsonly = sk -> sk_tsflags & SOF_TIMESTAMPING_OPT_TSONLY ; if ( ! skb_may_tx_timestamp ( sk , tsonly ) ) return ; if ( tsonly ) { # ifdef CONFIG_INET if ( ( sk -> sk_tsflags & SOF_TIMESTAMPING_OPT_STATS ) && sk -> sk_protocol == IPPROTO_TCP && <S2SV_StartBug> sk -> sk_type == SOCK_STREAM ) <S2SV_EndBug> skb = tcp_get_timestamping_opt_stats ( sk ) ; <S2SV_StartBug> else <S2SV_EndBug> # endif skb = alloc_skb ( 0 , GFP_ATOMIC ) ; } else { skb = skb_clone ( orig_skb , GFP_ATOMIC ) ; } if ( ! skb ) return ; if ( tsonly ) { skb_shinfo ( skb ) -> tx_flags = skb_shinfo ( orig_skb ) -> tx_flags ; skb_shinfo ( skb ) -> tskey = skb_shinfo ( orig_skb ) -> tskey ; } if ( hwtstamps ) * skb_hwtstamps ( skb ) = * hwtstamps ; else skb -> tstamp = ktime_get_real ( ) ; <S2SV_StartBug> __skb_complete_tx_timestamp ( skb , sk , tstype ) ; <S2SV_EndBug> }\n","target":"<S2SV_ModStart> ; bool tsonly , opt_stats = false <S2SV_ModStart> == SOCK_STREAM ) { <S2SV_ModStart> sk ) ; opt_stats = true ; } <S2SV_ModStart> sk , tstype , opt_stats\n","project_and_commit_id":"torvalds@linux/4ef1b2869447411ad3ef91ad7d4891a83c1a509a","cve_id":"CVE-2017-7277","original_address":"https://github.com/torvalds/linux/commit/4ef1b2869447411ad3ef91ad7d4891a83c1a509a","time":"2017-03-28T06:59Z"},
	{"Unnamed: 0":3544,"cwe_id":"CWE-476","source":"CWE-476 static int hash_accept ( struct socket * sock , struct socket * newsock , int flags ) { struct sock * sk = sock -> sk ; struct alg_sock * ask = alg_sk ( sk ) ; struct hash_ctx * ctx = ask -> private ; struct ahash_request * req = & ctx -> req ; char state [ crypto_ahash_statesize ( crypto_ahash_reqtfm ( req ) ) ] ; struct sock * sk2 ; struct alg_sock * ask2 ; struct hash_ctx * ctx2 ; <S2SV_StartBug> int err ; <S2SV_EndBug> <S2SV_StartBug> err = crypto_ahash_export ( req , state ) ; <S2SV_EndBug> if ( err ) return err ; err = af_alg_accept ( ask -> parent , newsock ) ; if ( err ) return err ; sk2 = newsock -> sk ; ask2 = alg_sk ( sk2 ) ; ctx2 = ask2 -> private ; <S2SV_StartBug> ctx2 -> more = 1 ; <S2SV_EndBug> err = crypto_ahash_import ( & ctx2 -> req , state ) ; if ( err ) { sock_orphan ( sk2 ) ; sock_put ( sk2 ) ; } return err ; }\n","target":"<S2SV_ModStart> * ctx2 ; bool more ; <S2SV_ModStart> int err ; lock_sock ( sk ) ; more = ctx -> more ; err = more ? <S2SV_ModEnd> crypto_ahash_export ( req <S2SV_ModStart> , state ) : 0 ; release_sock ( sk ) <S2SV_ModStart> -> more = more ; if ( ! more ) return err <S2SV_ModEnd> ; err =\n","project_and_commit_id":"torvalds@linux/4afa5f9617927453ac04b24b584f6c718dfb4f45","cve_id":"CVE-2016-8646","original_address":"https://github.com/torvalds/linux/commit/4afa5f9617927453ac04b24b584f6c718dfb4f45","time":"2016-11-28T03:59Z"},
	{"Unnamed: 0":2009,"cwe_id":"CWE-444","source":"CWE-444 agooCon agoo_con_create ( agooErr err , int sock , uint64_t id , agooBind b ) { agooCon c ; if ( NULL == ( c = ( agooCon ) AGOO_CALLOC ( 1 , sizeof ( struct _agooCon ) ) ) ) { AGOO_ERR_MEM ( err , \"Connection\" ) ; } else { <S2SV_StartBug> c -> sock = sock ; <S2SV_EndBug> c -> id = id ; c -> timeout = dtime ( ) + CON_TIMEOUT ; c -> bind = b ; c -> loop = NULL ; pthread_mutex_init ( & c -> res_lock , 0 ) ; } return c ; }\n","target":"<S2SV_ModStart> } else { struct sockaddr_storage addr ; socklen_t len = sizeof ( addr ) ; getpeername ( sock , ( struct sockaddr * ) & addr , & len ) ; if ( addr . ss_family == AF_INET ) { struct sockaddr_in * s = ( struct sockaddr_in * ) & addr ; inet_ntop ( AF_INET , & s -> sin_addr , c -> remote , sizeof ( c -> remote ) ) ; } else { struct sockaddr_in6 * s = ( struct sockaddr_in6 * ) & addr ; inet_ntop ( AF_INET6 , & s -> sin6_addr , c -> remote , sizeof ( c -> remote ) ) ; }\n","project_and_commit_id":"ohler55@agoo/23d03535cf7b50d679a60a953a0cae9519a4a130","cve_id":"CVE-2020-7670","original_address":"https://github.com/ohler55/agoo/commit/23d03535cf7b50d679a60a953a0cae9519a4a130","time":"2020-06-10T16:15Z"},
	{"Unnamed: 0":2744,"cwe_id":"CWE-404","source":"CWE-404 int install_process_keyring_to_cred ( struct cred * new ) { struct key * keyring ; if ( new -> process_keyring ) <S2SV_StartBug> return - EEXIST ; <S2SV_EndBug> keyring = keyring_alloc ( \"_pid\" , new -> uid , new -> gid , new , KEY_POS_ALL | KEY_USR_VIEW , KEY_ALLOC_QUOTA_OVERRUN , NULL , NULL ) ; if ( IS_ERR ( keyring ) ) return PTR_ERR ( keyring ) ; new -> process_keyring = keyring ; return 0 ; }\n","target":"<S2SV_ModStart> process_keyring ) return 0 <S2SV_ModEnd> ; keyring =\n","project_and_commit_id":"torvalds@linux/c9f838d104fed6f2f61d68164712e3204bf5271b","cve_id":"CVE-2017-7472","original_address":"https://github.com/torvalds/linux/commit/c9f838d104fed6f2f61d68164712e3204bf5271b","time":"2017-05-11T19:29Z"},
	{"Unnamed: 0":4799,"cwe_id":"CWE-125","source":"CWE-125 static u_int ieee802_11_print ( netdissect_options * ndo , const u_char * p , u_int length , u_int orig_caplen , int pad , u_int fcslen ) { uint16_t fc ; u_int caplen , hdrlen , meshdrlen ; struct lladdr_info src , dst ; int llc_hdrlen ; caplen = orig_caplen ; if ( length < fcslen ) { ND_PRINT ( ( ndo , \"%s\" , tstr ) ) ; return caplen ; } length -= fcslen ; if ( caplen > length ) { fcslen = caplen - length ; caplen -= fcslen ; ndo -> ndo_snapend -= fcslen ; } if ( caplen < IEEE802_11_FC_LEN ) { ND_PRINT ( ( ndo , \"%s\" , tstr ) ) ; return orig_caplen ; } fc = EXTRACT_LE_16BITS ( p ) ; hdrlen = extract_header_length ( ndo , fc ) ; if ( hdrlen == 0 ) { return ( 0 ) ; } if ( pad ) hdrlen = roundup2 ( hdrlen , 4 ) ; if ( ndo -> ndo_Hflag && FC_TYPE ( fc ) == T_DATA && DATA_FRAME_IS_QOS ( FC_SUBTYPE ( fc ) ) ) { <S2SV_StartBug> meshdrlen = extract_mesh_header_length ( p + hdrlen ) ; <S2SV_EndBug> hdrlen += meshdrlen ; } else meshdrlen = 0 ; if ( caplen < hdrlen ) { ND_PRINT ( ( ndo , \"%s\" , tstr ) ) ; return hdrlen ; } if ( ndo -> ndo_eflag ) ieee_802_11_hdr_print ( ndo , fc , p , hdrlen , meshdrlen ) ; length -= hdrlen ; caplen -= hdrlen ; p += hdrlen ; src . addr_string = etheraddr_string ; dst . addr_string = etheraddr_string ; switch ( FC_TYPE ( fc ) ) { case T_MGMT : get_mgmt_src_dst_mac ( p - hdrlen , & src . addr , & dst . addr ) ; if ( ! mgmt_body_print ( ndo , fc , src . addr , p , length ) ) { ND_PRINT ( ( ndo , \"%s\" , tstr ) ) ; return hdrlen ; } break ; case T_CTRL : if ( ! ctrl_body_print ( ndo , fc , p - hdrlen ) ) { ND_PRINT ( ( ndo , \"%s\" , tstr ) ) ; return hdrlen ; } break ; case T_DATA : if ( DATA_FRAME_IS_NULL ( FC_SUBTYPE ( fc ) ) ) return hdrlen ; if ( FC_PROTECTED ( fc ) ) { ND_PRINT ( ( ndo , \"Data\" ) ) ; if ( ! wep_print ( ndo , p ) ) { ND_PRINT ( ( ndo , \"%s\" , tstr ) ) ; return hdrlen ; } } else { get_data_src_dst_mac ( fc , p - hdrlen , & src . addr , & dst . addr ) ; llc_hdrlen = llc_print ( ndo , p , length , caplen , & src , & dst ) ; if ( llc_hdrlen < 0 ) { if ( ! ndo -> ndo_suppress_default_print ) ND_DEFAULTPRINT ( p , caplen ) ; llc_hdrlen = - llc_hdrlen ; } hdrlen += llc_hdrlen ; } break ; default : break ; } return hdrlen ; }\n","target":"<S2SV_ModStart> ) ) { if ( caplen < hdrlen + 1 ) { ND_PRINT ( ( ndo , \"%s\" , tstr ) ) ; return hdrlen ; }\n","project_and_commit_id":"the-tcpdump-group@tcpdump/4846b3c5d0a850e860baf4f07340495d29837d09","cve_id":"CVE-2018-16227","original_address":"https://github.com/the-tcpdump-group/tcpdump/commit/4846b3c5d0a850e860baf4f07340495d29837d09","time":"2019-10-03T16:15Z"},
	{"Unnamed: 0":198,"cwe_id":"CWE-125","source":"CWE-125 void qedi_dbg_info ( struct qedi_dbg_ctx * qedi , const char * func , u32 line , u32 level , const char * fmt , ... ) { va_list va ; <S2SV_StartBug> struct va_format vaf ; <S2SV_EndBug> char nfunc [ 32 ] ; memset ( nfunc , 0 , sizeof ( nfunc ) ) ; memcpy ( nfunc , func , sizeof ( nfunc ) - 1 ) ; va_start ( va , fmt ) ; vaf . fmt = fmt ; vaf . va = & va ; if ( ! ( qedi_dbg_log & level ) ) goto ret ; if ( likely ( qedi ) && likely ( qedi -> pdev ) ) pr_info ( \"[%s]:[%s:%d]:%d:<S2SV_blank>%pV\" , dev_name ( & qedi -> pdev -> dev ) , <S2SV_StartBug> nfunc , line , qedi -> host_no , & vaf ) ; <S2SV_EndBug> else <S2SV_StartBug> pr_info ( \"[0000:00:00.0]:[%s:%d]:<S2SV_blank>%pV\" , nfunc , line , & vaf ) ; <S2SV_EndBug> ret : va_end ( va ) ; }\n","target":"<S2SV_ModStart> struct va_format vaf <S2SV_ModEnd> ; va_start ( <S2SV_ModStart> dev ) , func <S2SV_ModEnd> , line , <S2SV_ModStart> ( \"[0000:00:00.0]:[%s:%d]:<S2SV_blank>%pV\" , func <S2SV_ModEnd> , line ,\n","project_and_commit_id":"torvalds@linux/c09581a52765a85f19fc35340127396d5e3379cc","cve_id":"CVE-2019-15090","original_address":"https://github.com/torvalds/linux/commit/c09581a52765a85f19fc35340127396d5e3379cc","time":"2019-08-16T00:15Z"},
	{"Unnamed: 0":5891,"cwe_id":"CWE-119","source":"CWE-119 static void mt_decode_mb_rows ( VP8D_COMP * pbi , MACROBLOCKD * xd , int start_mb_row ) { volatile const int * last_row_current_mb_col ; volatile int * current_mb_col ; int mb_row ; VP8_COMMON * pc = & pbi -> common ; const int nsync = pbi -> sync_range ; const int first_row_no_sync_above = pc -> mb_cols + nsync ; int num_part = 1 << pbi -> common . multi_token_partition ; int last_mb_row = start_mb_row ; YV12_BUFFER_CONFIG * yv12_fb_new = pbi -> dec_fb_ref [ INTRA_FRAME ] ; YV12_BUFFER_CONFIG * yv12_fb_lst = pbi -> dec_fb_ref [ LAST_FRAME ] ; int recon_y_stride = yv12_fb_new -> y_stride ; int recon_uv_stride = yv12_fb_new -> uv_stride ; unsigned char * ref_buffer [ MAX_REF_FRAMES ] [ 3 ] ; unsigned char * dst_buffer [ 3 ] ; int i ; int ref_fb_corrupted [ MAX_REF_FRAMES ] ; ref_fb_corrupted [ INTRA_FRAME ] = 0 ; for ( i = 1 ; i < MAX_REF_FRAMES ; i ++ ) { YV12_BUFFER_CONFIG * this_fb = pbi -> dec_fb_ref [ i ] ; ref_buffer [ i ] [ 0 ] = this_fb -> y_buffer ; ref_buffer [ i ] [ 1 ] = this_fb -> u_buffer ; ref_buffer [ i ] [ 2 ] = this_fb -> v_buffer ; ref_fb_corrupted [ i ] = this_fb -> corrupted ; } dst_buffer [ 0 ] = yv12_fb_new -> y_buffer ; dst_buffer [ 1 ] = yv12_fb_new -> u_buffer ; dst_buffer [ 2 ] = yv12_fb_new -> v_buffer ; xd -> up_available = ( start_mb_row != 0 ) ; for ( mb_row = start_mb_row ; mb_row < pc -> mb_rows ; mb_row += ( pbi -> decoding_thread_count + 1 ) ) { int recon_yoffset , recon_uvoffset ; int mb_col ; int filter_level ; loop_filter_info_n * lfi_n = & pc -> lf_info ; last_mb_row = mb_row ; xd -> current_bc = & pbi -> mbc [ mb_row % num_part ] ; if ( mb_row > 0 ) last_row_current_mb_col = & pbi -> mt_current_mb_col [ mb_row - 1 ] ; else last_row_current_mb_col = & first_row_no_sync_above ; current_mb_col = & pbi -> mt_current_mb_col [ mb_row ] ; recon_yoffset = mb_row * recon_y_stride * 16 ; recon_uvoffset = mb_row * recon_uv_stride * 8 ; xd -> above_context = pc -> above_context ; <S2SV_StartBug> vpx_memset ( xd -> left_context , 0 , sizeof ( ENTROPY_CONTEXT_PLANES ) ) ; <S2SV_EndBug> xd -> left_available = 0 ; xd -> mb_to_top_edge = - ( ( mb_row * 16 ) ) << 3 ; xd -> mb_to_bottom_edge = ( ( pc -> mb_rows - 1 - mb_row ) * 16 ) << 3 ; if ( pbi -> common . filter_level ) { xd -> recon_above [ 0 ] = pbi -> mt_yabove_row [ mb_row ] + 0 * 16 + 32 ; xd -> recon_above [ 1 ] = pbi -> mt_uabove_row [ mb_row ] + 0 * 8 + 16 ; xd -> recon_above [ 2 ] = pbi -> mt_vabove_row [ mb_row ] + 0 * 8 + 16 ; xd -> recon_left [ 0 ] = pbi -> mt_yleft_col [ mb_row ] ; xd -> recon_left [ 1 ] = pbi -> mt_uleft_col [ mb_row ] ; xd -> recon_left [ 2 ] = pbi -> mt_vleft_col [ mb_row ] ; xd -> recon_left_stride [ 0 ] = 1 ; xd -> recon_left_stride [ 1 ] = 1 ; } else { xd -> recon_above [ 0 ] = dst_buffer [ 0 ] + recon_yoffset ; xd -> recon_above [ 1 ] = dst_buffer [ 1 ] + recon_uvoffset ; xd -> recon_above [ 2 ] = dst_buffer [ 2 ] + recon_uvoffset ; xd -> recon_left [ 0 ] = xd -> recon_above [ 0 ] - 1 ; xd -> recon_left [ 1 ] = xd -> recon_above [ 1 ] - 1 ; xd -> recon_left [ 2 ] = xd -> recon_above [ 2 ] - 1 ; xd -> recon_above [ 0 ] -= xd -> dst . y_stride ; xd -> recon_above [ 1 ] -= xd -> dst . uv_stride ; xd -> recon_above [ 2 ] -= xd -> dst . uv_stride ; xd -> recon_left_stride [ 0 ] = xd -> dst . y_stride ; xd -> recon_left_stride [ 1 ] = xd -> dst . uv_stride ; setup_intra_recon_left ( xd -> recon_left [ 0 ] , xd -> recon_left [ 1 ] , xd -> recon_left [ 2 ] , xd -> dst . y_stride , xd -> dst . uv_stride ) ; } for ( mb_col = 0 ; mb_col < pc -> mb_cols ; mb_col ++ ) { * current_mb_col = mb_col - 1 ; if ( ( mb_col & ( nsync - 1 ) ) == 0 ) { while ( mb_col > ( * last_row_current_mb_col - nsync ) ) { x86_pause_hint ( ) ; thread_sleep ( 0 ) ; } } xd -> mb_to_left_edge = - ( ( mb_col * 16 ) << 3 ) ; xd -> mb_to_right_edge = ( ( pc -> mb_cols - 1 - mb_col ) * 16 ) << 3 ; # if CONFIG_ERROR_CONCEALMENT { int corrupt_residual = ( ! pbi -> independent_partitions && pbi -> frame_corrupt_residual ) || vp8dx_bool_error ( xd -> current_bc ) ; if ( pbi -> ec_active && ( xd -> mode_info_context -> mbmi . ref_frame == INTRA_FRAME ) && corrupt_residual ) { vp8_interpolate_motion ( xd , mb_row , mb_col , pc -> mb_rows , pc -> mb_cols , pc -> mode_info_stride ) ; } } # endif xd -> dst . y_buffer = dst_buffer [ 0 ] + recon_yoffset ; xd -> dst . u_buffer = dst_buffer [ 1 ] + recon_uvoffset ; xd -> dst . v_buffer = dst_buffer [ 2 ] + recon_uvoffset ; xd -> pre . y_buffer = ref_buffer [ xd -> mode_info_context -> mbmi . ref_frame ] [ 0 ] + recon_yoffset ; xd -> pre . u_buffer = ref_buffer [ xd -> mode_info_context -> mbmi . ref_frame ] [ 1 ] + recon_uvoffset ; xd -> pre . v_buffer = ref_buffer [ xd -> mode_info_context -> mbmi . ref_frame ] [ 2 ] + recon_uvoffset ; xd -> corrupted |= ref_fb_corrupted [ xd -> mode_info_context -> mbmi . ref_frame ] ; mt_decode_macroblock ( pbi , xd , 0 ) ; xd -> left_available = 1 ; xd -> corrupted |= vp8dx_bool_error ( xd -> current_bc ) ; xd -> recon_above [ 0 ] += 16 ; xd -> recon_above [ 1 ] += 8 ; xd -> recon_above [ 2 ] += 8 ; if ( ! pbi -> common . filter_level ) { xd -> recon_left [ 0 ] += 16 ; xd -> recon_left [ 1 ] += 8 ; xd -> recon_left [ 2 ] += 8 ; } if ( pbi -> common . filter_level ) { int skip_lf = ( xd -> mode_info_context -> mbmi . mode != B_PRED && xd -> mode_info_context -> mbmi . mode != SPLITMV && xd -> mode_info_context -> mbmi . mb_skip_coeff ) ; const int mode_index = lfi_n -> mode_lf_lut [ xd -> mode_info_context -> mbmi . mode ] ; const int seg = xd -> mode_info_context -> mbmi . segment_id ; const int ref_frame = xd -> mode_info_context -> mbmi . ref_frame ; filter_level = lfi_n -> lvl [ seg ] [ ref_frame ] [ mode_index ] ; if ( mb_row != pc -> mb_rows - 1 ) { <S2SV_StartBug> vpx_memcpy ( ( pbi -> mt_yabove_row [ mb_row + 1 ] + 32 + mb_col * 16 ) , ( xd -> dst . y_buffer + 15 * recon_y_stride ) , 16 ) ; <S2SV_EndBug> <S2SV_StartBug> vpx_memcpy ( ( pbi -> mt_uabove_row [ mb_row + 1 ] + 16 + mb_col * 8 ) , ( xd -> dst . u_buffer + 7 * recon_uv_stride ) , 8 ) ; <S2SV_EndBug> <S2SV_StartBug> vpx_memcpy ( ( pbi -> mt_vabove_row [ mb_row + 1 ] + 16 + mb_col * 8 ) , ( xd -> dst . v_buffer + 7 * recon_uv_stride ) , 8 ) ; <S2SV_EndBug> } if ( mb_col != pc -> mb_cols - 1 ) { MODE_INFO * next = xd -> mode_info_context + 1 ; if ( next -> mbmi . ref_frame == INTRA_FRAME ) { for ( i = 0 ; i < 16 ; i ++ ) pbi -> mt_yleft_col [ mb_row ] [ i ] = xd -> dst . y_buffer [ i * recon_y_stride + 15 ] ; for ( i = 0 ; i < 8 ; i ++ ) { pbi -> mt_uleft_col [ mb_row ] [ i ] = xd -> dst . u_buffer [ i * recon_uv_stride + 7 ] ; pbi -> mt_vleft_col [ mb_row ] [ i ] = xd -> dst . v_buffer [ i * recon_uv_stride + 7 ] ; } } } if ( filter_level ) { if ( pc -> filter_type == NORMAL_LOOPFILTER ) { loop_filter_info lfi ; FRAME_TYPE frame_type = pc -> frame_type ; const int hev_index = lfi_n -> hev_thr_lut [ frame_type ] [ filter_level ] ; lfi . mblim = lfi_n -> mblim [ filter_level ] ; lfi . blim = lfi_n -> blim [ filter_level ] ; lfi . lim = lfi_n -> lim [ filter_level ] ; lfi . hev_thr = lfi_n -> hev_thr [ hev_index ] ; if ( mb_col > 0 ) vp8_loop_filter_mbv ( xd -> dst . y_buffer , xd -> dst . u_buffer , xd -> dst . v_buffer , recon_y_stride , recon_uv_stride , & lfi ) ; if ( ! skip_lf ) vp8_loop_filter_bv ( xd -> dst . y_buffer , xd -> dst . u_buffer , xd -> dst . v_buffer , recon_y_stride , recon_uv_stride , & lfi ) ; if ( mb_row > 0 ) vp8_loop_filter_mbh ( xd -> dst . y_buffer , xd -> dst . u_buffer , xd -> dst . v_buffer , recon_y_stride , recon_uv_stride , & lfi ) ; if ( ! skip_lf ) vp8_loop_filter_bh ( xd -> dst . y_buffer , xd -> dst . u_buffer , xd -> dst . v_buffer , recon_y_stride , recon_uv_stride , & lfi ) ; } else { if ( mb_col > 0 ) vp8_loop_filter_simple_mbv ( xd -> dst . y_buffer , recon_y_stride , lfi_n -> mblim [ filter_level ] ) ; if ( ! skip_lf ) vp8_loop_filter_simple_bv ( xd -> dst . y_buffer , recon_y_stride , lfi_n -> blim [ filter_level ] ) ; if ( mb_row > 0 ) vp8_loop_filter_simple_mbh ( xd -> dst . y_buffer , recon_y_stride , lfi_n -> mblim [ filter_level ] ) ; if ( ! skip_lf ) vp8_loop_filter_simple_bh ( xd -> dst . y_buffer , recon_y_stride , lfi_n -> blim [ filter_level ] ) ; } } } recon_yoffset += 16 ; recon_uvoffset += 8 ; ++ xd -> mode_info_context ; xd -> above_context ++ ; } if ( pbi -> common . filter_level ) { if ( mb_row != pc -> mb_rows - 1 ) { int lasty = yv12_fb_lst -> y_width + VP8BORDERINPIXELS ; int lastuv = ( yv12_fb_lst -> y_width >> 1 ) + ( VP8BORDERINPIXELS >> 1 ) ; for ( i = 0 ; i < 4 ; i ++ ) { pbi -> mt_yabove_row [ mb_row + 1 ] [ lasty + i ] = pbi -> mt_yabove_row [ mb_row + 1 ] [ lasty - 1 ] ; pbi -> mt_uabove_row [ mb_row + 1 ] [ lastuv + i ] = pbi -> mt_uabove_row [ mb_row + 1 ] [ lastuv - 1 ] ; pbi -> mt_vabove_row [ mb_row + 1 ] [ lastuv + i ] = pbi -> mt_vabove_row [ mb_row + 1 ] [ lastuv - 1 ] ; } } } else vp8_extend_mb_row ( yv12_fb_new , xd -> dst . y_buffer + 16 , xd -> dst . u_buffer + 8 , xd -> dst . v_buffer + 8 ) ; * current_mb_col = mb_col + nsync ; ++ xd -> mode_info_context ; xd -> up_available = 1 ; xd -> mode_info_context += xd -> mode_info_stride * pbi -> decoding_thread_count ; } if ( last_mb_row == ( pc -> mb_rows - 1 ) ) sem_post ( & pbi -> h_event_end_decoding ) ; }\n","target":"<S2SV_ModStart> -> above_context ; memset <S2SV_ModEnd> ( xd -> <S2SV_ModStart> 1 ) { memcpy <S2SV_ModEnd> ( ( pbi <S2SV_ModStart> 16 ) ; memcpy <S2SV_ModEnd> ( ( pbi <S2SV_ModStart> 8 ) ; memcpy <S2SV_ModEnd> ( ( pbi\n","project_and_commit_id":"external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426","cve_id":"CVE-2016-1621","original_address":"https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426","time":"2016-03-12T21:59Z"},
	{"Unnamed: 0":980,"cwe_id":"CWE-20","source":"CWE-20 static int mxf_read_primer_pack ( void * arg , AVIOContext * pb , int tag , int size , UID uid , int64_t klv_offset ) { MXFContext * mxf = arg ; int item_num = avio_rb32 ( pb ) ; int item_len = avio_rb32 ( pb ) ; if ( item_len != 18 ) { avpriv_request_sample ( pb , \"Primer<S2SV_blank>pack<S2SV_blank>item<S2SV_blank>length<S2SV_blank>%d\" , item_len ) ; return AVERROR_PATCHWELCOME ; } <S2SV_StartBug> if ( item_num > 65536 ) { <S2SV_EndBug> av_log ( mxf -> fc , AV_LOG_ERROR , \"item_num<S2SV_blank>%d<S2SV_blank>is<S2SV_blank>too<S2SV_blank>large\\\\n\" , item_num ) ; return AVERROR_INVALIDDATA ; } if ( mxf -> local_tags ) av_log ( mxf -> fc , AV_LOG_VERBOSE , \"Multiple<S2SV_blank>primer<S2SV_blank>packs\\\\n\" ) ; av_free ( mxf -> local_tags ) ; mxf -> local_tags_count = 0 ; mxf -> local_tags = av_calloc ( item_num , item_len ) ; if ( ! mxf -> local_tags ) return AVERROR ( ENOMEM ) ; mxf -> local_tags_count = item_num ; avio_read ( pb , mxf -> local_tags , item_num * item_len ) ; return 0 ; }\n","target":"<S2SV_ModStart> item_num > 65536 || item_num < 0\n","project_and_commit_id":"FFmpeg@FFmpeg/9d00fb9d70ee8c0cc7002b89318c5be00f1bbdad","cve_id":"CVE-2017-14169","original_address":"https://github.com/FFmpeg/FFmpeg/commit/9d00fb9d70ee8c0cc7002b89318c5be00f1bbdad","time":"2017-09-07T06:29Z"},
	{"Unnamed: 0":1801,"cwe_id":"CWE-787","source":"CWE-787 static void write_version ( FILE * fp , const char * fname , const char * dirname , xref_t * xref ) { long start ; char * c , * new_fname , data ; FILE * new_fp ; start = ftell ( fp ) ; if ( ( c = strstr ( fname , \".pdf\" ) ) ) * c = '\\\\0' ; <S2SV_StartBug> new_fname = malloc ( strlen ( fname ) + strlen ( dirname ) + 16 ) ; <S2SV_EndBug> snprintf ( new_fname , strlen ( fname ) + strlen ( dirname ) + 16 , \"%s/%s-version-%d.pdf\" , dirname , fname , xref -> version ) ; if ( ! ( new_fp = fopen ( new_fname , \"w\" ) ) ) { ERR ( \"Could<S2SV_blank>not<S2SV_blank>create<S2SV_blank>file<S2SV_blank>\\'%s\\'\\\\n\" , new_fname ) ; fseek ( fp , start , SEEK_SET ) ; free ( new_fname ) ; return ; } fseek ( fp , 0 , SEEK_SET ) ; while ( fread ( & data , 1 , 1 , fp ) ) fwrite ( & data , 1 , 1 , new_fp ) ; fprintf ( new_fp , \"\\\\r\\\\nstartxref\\\\r\\\\n%ld\\\\r\\\\n%%%%EOF\" , xref -> start ) ; fclose ( new_fp ) ; free ( new_fname ) ; fseek ( fp , start , SEEK_SET ) ; }\n","target":"<S2SV_ModStart> ; new_fname = safe_calloc <S2SV_ModEnd> ( strlen (\n","project_and_commit_id":"enferex@pdfresurrect/0c4120fffa3dffe97b95c486a120eded82afe8a6","cve_id":"CVE-2019-14934","original_address":"https://github.com/enferex/pdfresurrect/commit/0c4120fffa3dffe97b95c486a120eded82afe8a6","time":"2019-08-11T22:15Z"},
	{"Unnamed: 0":4013,"cwe_id":"CWE-125","source":"CWE-125 static int rsvp_obj_print ( netdissect_options * ndo , const u_char * pptr , u_int plen , const u_char * tptr , const char * ident , u_int tlen , const struct rsvp_common_header * rsvp_com_header ) { const struct rsvp_object_header * rsvp_obj_header ; const u_char * obj_tptr ; union { const struct rsvp_obj_integrity_t * rsvp_obj_integrity ; const struct rsvp_obj_frr_t * rsvp_obj_frr ; } obj_ptr ; u_short rsvp_obj_len , rsvp_obj_ctype , obj_tlen , intserv_serv_tlen ; int hexdump , processed , padbytes , error_code , error_value , i , sigcheck ; union { float f ; uint32_t i ; } bw ; uint8_t namelen ; u_int action , subchannel ; while ( tlen >= sizeof ( struct rsvp_object_header ) ) { ND_TCHECK2 ( * tptr , sizeof ( struct rsvp_object_header ) ) ; rsvp_obj_header = ( const struct rsvp_object_header * ) tptr ; rsvp_obj_len = EXTRACT_16BITS ( rsvp_obj_header -> length ) ; rsvp_obj_ctype = rsvp_obj_header -> ctype ; if ( rsvp_obj_len % 4 ) { ND_PRINT ( ( ndo , \"%sERROR:<S2SV_blank>object<S2SV_blank>header<S2SV_blank>size<S2SV_blank>%u<S2SV_blank>not<S2SV_blank>a<S2SV_blank>multiple<S2SV_blank>of<S2SV_blank>4\" , ident , rsvp_obj_len ) ) ; return - 1 ; } if ( rsvp_obj_len < sizeof ( struct rsvp_object_header ) ) { ND_PRINT ( ( ndo , \"%sERROR:<S2SV_blank>object<S2SV_blank>header<S2SV_blank>too<S2SV_blank>short<S2SV_blank>%u<S2SV_blank><<S2SV_blank>%lu\" , ident , rsvp_obj_len , ( unsigned long ) sizeof ( const struct rsvp_object_header ) ) ) ; return - 1 ; } ND_PRINT ( ( ndo , \"%s%s<S2SV_blank>Object<S2SV_blank>(%u)<S2SV_blank>Flags:<S2SV_blank>[%s\" , ident , tok2str ( rsvp_obj_values , \"Unknown\" , rsvp_obj_header -> class_num ) , rsvp_obj_header -> class_num , ( ( rsvp_obj_header -> class_num ) & 0x80 ) ? \"ignore\" : \"reject\" ) ) ; if ( rsvp_obj_header -> class_num > 128 ) ND_PRINT ( ( ndo , \"<S2SV_blank>%s\" , ( ( rsvp_obj_header -> class_num ) & 0x40 ) ? \"and<S2SV_blank>forward\" : \"silently\" ) ) ; ND_PRINT ( ( ndo , \"<S2SV_blank>if<S2SV_blank>unknown],<S2SV_blank>Class-Type:<S2SV_blank>%s<S2SV_blank>(%u),<S2SV_blank>length:<S2SV_blank>%u\" , tok2str ( rsvp_ctype_values , \"Unknown\" , ( ( rsvp_obj_header -> class_num ) << 8 ) + rsvp_obj_ctype ) , rsvp_obj_ctype , rsvp_obj_len ) ) ; if ( tlen < rsvp_obj_len ) { ND_PRINT ( ( ndo , \"%sERROR:<S2SV_blank>object<S2SV_blank>goes<S2SV_blank>past<S2SV_blank>end<S2SV_blank>of<S2SV_blank>objects<S2SV_blank>TLV\" , ident ) ) ; return - 1 ; } obj_tptr = tptr + sizeof ( struct rsvp_object_header ) ; obj_tlen = rsvp_obj_len - sizeof ( struct rsvp_object_header ) ; if ( ! ND_TTEST2 ( * tptr , rsvp_obj_len ) ) return - 1 ; hexdump = FALSE ; switch ( rsvp_obj_header -> class_num ) { case RSVP_OBJ_SESSION : switch ( rsvp_obj_ctype ) { case RSVP_CTYPE_IPV4 : if ( obj_tlen < 8 ) return - 1 ; ND_PRINT ( ( ndo , \"%s<S2SV_blank><S2SV_blank>IPv4<S2SV_blank>DestAddress:<S2SV_blank>%s,<S2SV_blank>Protocol<S2SV_blank>ID:<S2SV_blank>0x%02x\" , ident , ipaddr_string ( ndo , obj_tptr ) , * ( obj_tptr + sizeof ( struct in_addr ) ) ) ) ; ND_PRINT ( ( ndo , \"%s<S2SV_blank><S2SV_blank>Flags:<S2SV_blank>[0x%02x],<S2SV_blank>DestPort<S2SV_blank>%u\" , ident , * ( obj_tptr + 5 ) , EXTRACT_16BITS ( obj_tptr + 6 ) ) ) ; obj_tlen -= 8 ; obj_tptr += 8 ; break ; case RSVP_CTYPE_IPV6 : if ( obj_tlen < 20 ) return - 1 ; ND_PRINT ( ( ndo , \"%s<S2SV_blank><S2SV_blank>IPv6<S2SV_blank>DestAddress:<S2SV_blank>%s,<S2SV_blank>Protocol<S2SV_blank>ID:<S2SV_blank>0x%02x\" , ident , ip6addr_string ( ndo , obj_tptr ) , * ( obj_tptr + sizeof ( struct in6_addr ) ) ) ) ; ND_PRINT ( ( ndo , \"%s<S2SV_blank><S2SV_blank>Flags:<S2SV_blank>[0x%02x],<S2SV_blank>DestPort<S2SV_blank>%u\" , ident , * ( obj_tptr + sizeof ( struct in6_addr ) + 1 ) , EXTRACT_16BITS ( obj_tptr + sizeof ( struct in6_addr ) + 2 ) ) ) ; obj_tlen -= 20 ; obj_tptr += 20 ; break ; case RSVP_CTYPE_TUNNEL_IPV6 : if ( obj_tlen < 36 ) return - 1 ; ND_PRINT ( ( ndo , \"%s<S2SV_blank><S2SV_blank>IPv6<S2SV_blank>Tunnel<S2SV_blank>EndPoint:<S2SV_blank>%s,<S2SV_blank>Tunnel<S2SV_blank>ID:<S2SV_blank>0x%04x,<S2SV_blank>Extended<S2SV_blank>Tunnel<S2SV_blank>ID:<S2SV_blank>%s\" , ident , ip6addr_string ( ndo , obj_tptr ) , EXTRACT_16BITS ( obj_tptr + 18 ) , ip6addr_string ( ndo , obj_tptr + 20 ) ) ) ; obj_tlen -= 36 ; obj_tptr += 36 ; break ; case RSVP_CTYPE_14 : if ( obj_tlen < 26 ) return - 1 ; ND_PRINT ( ( ndo , \"%s<S2SV_blank><S2SV_blank>IPv6<S2SV_blank>P2MP<S2SV_blank>LSP<S2SV_blank>ID:<S2SV_blank>0x%08x,<S2SV_blank>Tunnel<S2SV_blank>ID:<S2SV_blank>0x%04x,<S2SV_blank>Extended<S2SV_blank>Tunnel<S2SV_blank>ID:<S2SV_blank>%s\" , ident , EXTRACT_32BITS ( obj_tptr ) , EXTRACT_16BITS ( obj_tptr + 6 ) , ip6addr_string ( ndo , obj_tptr + 8 ) ) ) ; obj_tlen -= 26 ; obj_tptr += 26 ; break ; case RSVP_CTYPE_13 : if ( obj_tlen < 12 ) return - 1 ; ND_PRINT ( ( ndo , \"%s<S2SV_blank><S2SV_blank>IPv4<S2SV_blank>P2MP<S2SV_blank>LSP<S2SV_blank>ID:<S2SV_blank>%s,<S2SV_blank>Tunnel<S2SV_blank>ID:<S2SV_blank>0x%04x,<S2SV_blank>Extended<S2SV_blank>Tunnel<S2SV_blank>ID:<S2SV_blank>%s\" , ident , ipaddr_string ( ndo , obj_tptr ) , EXTRACT_16BITS ( obj_tptr + 6 ) , ipaddr_string ( ndo , obj_tptr + 8 ) ) ) ; obj_tlen -= 12 ; obj_tptr += 12 ; break ; case RSVP_CTYPE_TUNNEL_IPV4 : case RSVP_CTYPE_UNI_IPV4 : if ( obj_tlen < 12 ) return - 1 ; ND_PRINT ( ( ndo , \"%s<S2SV_blank><S2SV_blank>IPv4<S2SV_blank>Tunnel<S2SV_blank>EndPoint:<S2SV_blank>%s,<S2SV_blank>Tunnel<S2SV_blank>ID:<S2SV_blank>0x%04x,<S2SV_blank>Extended<S2SV_blank>Tunnel<S2SV_blank>ID:<S2SV_blank>%s\" , ident , ipaddr_string ( ndo , obj_tptr ) , EXTRACT_16BITS ( obj_tptr + 6 ) , ipaddr_string ( ndo , obj_tptr + 8 ) ) ) ; obj_tlen -= 12 ; obj_tptr += 12 ; break ; default : hexdump = TRUE ; } break ; case RSVP_OBJ_CONFIRM : switch ( rsvp_obj_ctype ) { case RSVP_CTYPE_IPV4 : if ( obj_tlen < sizeof ( struct in_addr ) ) return - 1 ; ND_PRINT ( ( ndo , \"%s<S2SV_blank><S2SV_blank>IPv4<S2SV_blank>Receiver<S2SV_blank>Address:<S2SV_blank>%s\" , ident , ipaddr_string ( ndo , obj_tptr ) ) ) ; obj_tlen -= sizeof ( struct in_addr ) ; obj_tptr += sizeof ( struct in_addr ) ; break ; case RSVP_CTYPE_IPV6 : if ( obj_tlen < sizeof ( struct in6_addr ) ) return - 1 ; ND_PRINT ( ( ndo , \"%s<S2SV_blank><S2SV_blank>IPv6<S2SV_blank>Receiver<S2SV_blank>Address:<S2SV_blank>%s\" , ident , ip6addr_string ( ndo , obj_tptr ) ) ) ; obj_tlen -= sizeof ( struct in6_addr ) ; obj_tptr += sizeof ( struct in6_addr ) ; break ; default : hexdump = TRUE ; } break ; case RSVP_OBJ_NOTIFY_REQ : switch ( rsvp_obj_ctype ) { case RSVP_CTYPE_IPV4 : if ( obj_tlen < sizeof ( struct in_addr ) ) return - 1 ; ND_PRINT ( ( ndo , \"%s<S2SV_blank><S2SV_blank>IPv4<S2SV_blank>Notify<S2SV_blank>Node<S2SV_blank>Address:<S2SV_blank>%s\" , ident , ipaddr_string ( ndo , obj_tptr ) ) ) ; obj_tlen -= sizeof ( struct in_addr ) ; obj_tptr += sizeof ( struct in_addr ) ; break ; case RSVP_CTYPE_IPV6 : if ( obj_tlen < sizeof ( struct in6_addr ) ) return - 1 ; ND_PRINT ( ( ndo , \"%s<S2SV_blank><S2SV_blank>IPv6<S2SV_blank>Notify<S2SV_blank>Node<S2SV_blank>Address:<S2SV_blank>%s\" , ident , ip6addr_string ( ndo , obj_tptr ) ) ) ; obj_tlen -= sizeof ( struct in6_addr ) ; obj_tptr += sizeof ( struct in6_addr ) ; break ; default : hexdump = TRUE ; } break ; case RSVP_OBJ_SUGGESTED_LABEL : case RSVP_OBJ_UPSTREAM_LABEL : case RSVP_OBJ_RECOVERY_LABEL : case RSVP_OBJ_LABEL : switch ( rsvp_obj_ctype ) { case RSVP_CTYPE_1 : while ( obj_tlen >= 4 ) { ND_PRINT ( ( ndo , \"%s<S2SV_blank><S2SV_blank>Label:<S2SV_blank>%u\" , ident , EXTRACT_32BITS ( obj_tptr ) ) ) ; obj_tlen -= 4 ; obj_tptr += 4 ; } break ; case RSVP_CTYPE_2 : if ( obj_tlen < 4 ) return - 1 ; ND_PRINT ( ( ndo , \"%s<S2SV_blank><S2SV_blank>Generalized<S2SV_blank>Label:<S2SV_blank>%u\" , ident , EXTRACT_32BITS ( obj_tptr ) ) ) ; obj_tlen -= 4 ; obj_tptr += 4 ; break ; case RSVP_CTYPE_3 : if ( obj_tlen < 12 ) return - 1 ; ND_PRINT ( ( ndo , \"%s<S2SV_blank><S2SV_blank>Waveband<S2SV_blank>ID:<S2SV_blank>%u%s<S2SV_blank><S2SV_blank>Start<S2SV_blank>Label:<S2SV_blank>%u,<S2SV_blank>Stop<S2SV_blank>Label:<S2SV_blank>%u\" , ident , EXTRACT_32BITS ( obj_tptr ) , ident , EXTRACT_32BITS ( obj_tptr + 4 ) , EXTRACT_32BITS ( obj_tptr + 8 ) ) ) ; obj_tlen -= 12 ; obj_tptr += 12 ; break ; default : hexdump = TRUE ; } break ; case RSVP_OBJ_STYLE : switch ( rsvp_obj_ctype ) { case RSVP_CTYPE_1 : if ( obj_tlen < 4 ) return - 1 ; ND_PRINT ( ( ndo , \"%s<S2SV_blank><S2SV_blank>Reservation<S2SV_blank>Style:<S2SV_blank>%s,<S2SV_blank>Flags:<S2SV_blank>[0x%02x]\" , ident , tok2str ( rsvp_resstyle_values , \"Unknown\" , EXTRACT_24BITS ( obj_tptr + 1 ) ) , * ( obj_tptr ) ) ) ; obj_tlen -= 4 ; obj_tptr += 4 ; break ; default : hexdump = TRUE ; } break ; case RSVP_OBJ_SENDER_TEMPLATE : switch ( rsvp_obj_ctype ) { case RSVP_CTYPE_IPV4 : if ( obj_tlen < 8 ) return - 1 ; ND_PRINT ( ( ndo , \"%s<S2SV_blank><S2SV_blank>Source<S2SV_blank>Address:<S2SV_blank>%s,<S2SV_blank>Source<S2SV_blank>Port:<S2SV_blank>%u\" , ident , ipaddr_string ( ndo , obj_tptr ) , EXTRACT_16BITS ( obj_tptr + 6 ) ) ) ; obj_tlen -= 8 ; obj_tptr += 8 ; break ; case RSVP_CTYPE_IPV6 : if ( obj_tlen < 20 ) return - 1 ; ND_PRINT ( ( ndo , \"%s<S2SV_blank><S2SV_blank>Source<S2SV_blank>Address:<S2SV_blank>%s,<S2SV_blank>Source<S2SV_blank>Port:<S2SV_blank>%u\" , ident , ip6addr_string ( ndo , obj_tptr ) , EXTRACT_16BITS ( obj_tptr + 18 ) ) ) ; obj_tlen -= 20 ; obj_tptr += 20 ; break ; case RSVP_CTYPE_13 : if ( obj_tlen < 40 ) return - 1 ; ND_PRINT ( ( ndo , \"%s<S2SV_blank><S2SV_blank>IPv6<S2SV_blank>Tunnel<S2SV_blank>Sender<S2SV_blank>Address:<S2SV_blank>%s,<S2SV_blank>LSP<S2SV_blank>ID:<S2SV_blank>0x%04x\" \"%s<S2SV_blank><S2SV_blank>Sub-Group<S2SV_blank>Originator<S2SV_blank>ID:<S2SV_blank>%s,<S2SV_blank>Sub-Group<S2SV_blank>ID:<S2SV_blank>0x%04x\" , ident , ip6addr_string ( ndo , obj_tptr ) , EXTRACT_16BITS ( obj_tptr + 18 ) , ident , ip6addr_string ( ndo , obj_tptr + 20 ) , EXTRACT_16BITS ( obj_tptr + 38 ) ) ) ; obj_tlen -= 40 ; obj_tptr += 40 ; break ; case RSVP_CTYPE_TUNNEL_IPV4 : if ( obj_tlen < 8 ) return - 1 ; ND_PRINT ( ( ndo , \"%s<S2SV_blank><S2SV_blank>IPv4<S2SV_blank>Tunnel<S2SV_blank>Sender<S2SV_blank>Address:<S2SV_blank>%s,<S2SV_blank>LSP-ID:<S2SV_blank>0x%04x\" , ident , ipaddr_string ( ndo , obj_tptr ) , EXTRACT_16BITS ( obj_tptr + 6 ) ) ) ; obj_tlen -= 8 ; obj_tptr += 8 ; break ; case RSVP_CTYPE_12 : if ( obj_tlen < 16 ) return - 1 ; ND_PRINT ( ( ndo , \"%s<S2SV_blank><S2SV_blank>IPv4<S2SV_blank>Tunnel<S2SV_blank>Sender<S2SV_blank>Address:<S2SV_blank>%s,<S2SV_blank>LSP<S2SV_blank>ID:<S2SV_blank>0x%04x\" \"%s<S2SV_blank><S2SV_blank>Sub-Group<S2SV_blank>Originator<S2SV_blank>ID:<S2SV_blank>%s,<S2SV_blank>Sub-Group<S2SV_blank>ID:<S2SV_blank>0x%04x\" , ident , ipaddr_string ( ndo , obj_tptr ) , EXTRACT_16BITS ( obj_tptr + 6 ) , ident , ipaddr_string ( ndo , obj_tptr + 8 ) , EXTRACT_16BITS ( obj_tptr + 12 ) ) ) ; obj_tlen -= 16 ; obj_tptr += 16 ; break ; default : hexdump = TRUE ; } break ; case RSVP_OBJ_LABEL_REQ : switch ( rsvp_obj_ctype ) { case RSVP_CTYPE_1 : while ( obj_tlen >= 4 ) { ND_PRINT ( ( ndo , \"%s<S2SV_blank><S2SV_blank>L3<S2SV_blank>Protocol<S2SV_blank>ID:<S2SV_blank>%s\" , ident , tok2str ( ethertype_values , \"Unknown<S2SV_blank>Protocol<S2SV_blank>(0x%04x)\" , EXTRACT_16BITS ( obj_tptr + 2 ) ) ) ) ; obj_tlen -= 4 ; obj_tptr += 4 ; } break ; case RSVP_CTYPE_2 : if ( obj_tlen < 12 ) return - 1 ; ND_PRINT ( ( ndo , \"%s<S2SV_blank><S2SV_blank>L3<S2SV_blank>Protocol<S2SV_blank>ID:<S2SV_blank>%s\" , ident , tok2str ( ethertype_values , \"Unknown<S2SV_blank>Protocol<S2SV_blank>(0x%04x)\" , EXTRACT_16BITS ( obj_tptr + 2 ) ) ) ) ; ND_PRINT ( ( ndo , \",%s<S2SV_blank>merge<S2SV_blank>capability\" , ( ( * ( obj_tptr + 4 ) ) & 0x80 ) ? \"no\" : \"\" ) ) ; ND_PRINT ( ( ndo , \"%s<S2SV_blank><S2SV_blank>Minimum<S2SV_blank>VPI/VCI:<S2SV_blank>%u/%u\" , ident , ( EXTRACT_16BITS ( obj_tptr + 4 ) ) & 0xfff , ( EXTRACT_16BITS ( obj_tptr + 6 ) ) & 0xfff ) ) ; ND_PRINT ( ( ndo , \"%s<S2SV_blank><S2SV_blank>Maximum<S2SV_blank>VPI/VCI:<S2SV_blank>%u/%u\" , ident , ( EXTRACT_16BITS ( obj_tptr + 8 ) ) & 0xfff , ( EXTRACT_16BITS ( obj_tptr + 10 ) ) & 0xfff ) ) ; obj_tlen -= 12 ; obj_tptr += 12 ; break ; case RSVP_CTYPE_3 : if ( obj_tlen < 12 ) return - 1 ; ND_PRINT ( ( ndo , \"%s<S2SV_blank><S2SV_blank>L3<S2SV_blank>Protocol<S2SV_blank>ID:<S2SV_blank>%s\" , ident , tok2str ( ethertype_values , \"Unknown<S2SV_blank>Protocol<S2SV_blank>(0x%04x)\" , EXTRACT_16BITS ( obj_tptr + 2 ) ) ) ) ; ND_PRINT ( ( ndo , \"%s<S2SV_blank><S2SV_blank>Minimum/Maximum<S2SV_blank>DLCI:<S2SV_blank>%u/%u,<S2SV_blank>%s%s<S2SV_blank>bit<S2SV_blank>DLCI\" , ident , ( EXTRACT_32BITS ( obj_tptr + 4 ) ) & 0x7fffff , ( EXTRACT_32BITS ( obj_tptr + 8 ) ) & 0x7fffff , ( ( ( EXTRACT_16BITS ( obj_tptr + 4 ) >> 7 ) & 3 ) == 0 ) ? \"10\" : \"\" , ( ( ( EXTRACT_16BITS ( obj_tptr + 4 ) >> 7 ) & 3 ) == 2 ) ? \"23\" : \"\" ) ) ; obj_tlen -= 12 ; obj_tptr += 12 ; break ; case RSVP_CTYPE_4 : if ( obj_tlen < 4 ) return - 1 ; ND_PRINT ( ( ndo , \"%s<S2SV_blank><S2SV_blank>LSP<S2SV_blank>Encoding<S2SV_blank>Type:<S2SV_blank>%s<S2SV_blank>(%u)\" , ident , tok2str ( gmpls_encoding_values , \"Unknown\" , * obj_tptr ) , * obj_tptr ) ) ; ND_PRINT ( ( ndo , \"%s<S2SV_blank><S2SV_blank>Switching<S2SV_blank>Type:<S2SV_blank>%s<S2SV_blank>(%u),<S2SV_blank>Payload<S2SV_blank>ID:<S2SV_blank>%s<S2SV_blank>(0x%04x)\" , ident , tok2str ( gmpls_switch_cap_values , \"Unknown\" , * ( obj_tptr + 1 ) ) , * ( obj_tptr + 1 ) , tok2str ( gmpls_payload_values , \"Unknown\" , EXTRACT_16BITS ( obj_tptr + 2 ) ) , EXTRACT_16BITS ( obj_tptr + 2 ) ) ) ; obj_tlen -= 4 ; obj_tptr += 4 ; break ; default : hexdump = TRUE ; } break ; case RSVP_OBJ_RRO : case RSVP_OBJ_ERO : switch ( rsvp_obj_ctype ) { case RSVP_CTYPE_IPV4 : while ( obj_tlen >= 4 ) { u_char length ; ND_TCHECK2 ( * obj_tptr , 4 ) ; length = * ( obj_tptr + 1 ) ; ND_PRINT ( ( ndo , \"%s<S2SV_blank><S2SV_blank>Subobject<S2SV_blank>Type:<S2SV_blank>%s,<S2SV_blank>length<S2SV_blank>%u\" , ident , tok2str ( rsvp_obj_xro_values , \"Unknown<S2SV_blank>%u\" , RSVP_OBJ_XRO_MASK_SUBOBJ ( * obj_tptr ) ) , length ) ) ; if ( length == 0 ) { ND_PRINT ( ( ndo , \"%s<S2SV_blank><S2SV_blank>ERROR:<S2SV_blank>zero<S2SV_blank>length<S2SV_blank>ERO<S2SV_blank>subtype\" , ident ) ) ; break ; } switch ( RSVP_OBJ_XRO_MASK_SUBOBJ ( * obj_tptr ) ) { u_char prefix_length ; case RSVP_OBJ_XRO_IPV4 : if ( length != 8 ) { ND_PRINT ( ( ndo , \"<S2SV_blank>ERROR:<S2SV_blank>length<S2SV_blank>!=<S2SV_blank>8\" ) ) ; goto invalid ; } ND_TCHECK2 ( * obj_tptr , 8 ) ; prefix_length = * ( obj_tptr + 6 ) ; if ( prefix_length != 32 ) { ND_PRINT ( ( ndo , \"<S2SV_blank>ERROR:<S2SV_blank>Prefix<S2SV_blank>length<S2SV_blank>%u<S2SV_blank>!=<S2SV_blank>32\" , prefix_length ) ) ; goto invalid ; } ND_PRINT ( ( ndo , \",<S2SV_blank>%s,<S2SV_blank>%s/%u,<S2SV_blank>Flags:<S2SV_blank>[%s]\" , RSVP_OBJ_XRO_MASK_LOOSE ( * obj_tptr ) ? \"Loose\" : \"Strict\" , ipaddr_string ( ndo , obj_tptr + 2 ) , * ( obj_tptr + 6 ) , bittok2str ( rsvp_obj_rro_flag_values , \"none\" , * ( obj_tptr + 7 ) ) ) ) ; break ; case RSVP_OBJ_XRO_LABEL : if ( length != 8 ) { ND_PRINT ( ( ndo , \"<S2SV_blank>ERROR:<S2SV_blank>length<S2SV_blank>!=<S2SV_blank>8\" ) ) ; goto invalid ; } ND_TCHECK2 ( * obj_tptr , 8 ) ; ND_PRINT ( ( ndo , \",<S2SV_blank>Flags:<S2SV_blank>[%s]<S2SV_blank>(%#x),<S2SV_blank>Class-Type:<S2SV_blank>%s<S2SV_blank>(%u),<S2SV_blank>%u\" , bittok2str ( rsvp_obj_rro_label_flag_values , \"none\" , * ( obj_tptr + 2 ) ) , * ( obj_tptr + 2 ) , tok2str ( rsvp_ctype_values , \"Unknown\" , * ( obj_tptr + 3 ) + 256 * RSVP_OBJ_RRO ) , * ( obj_tptr + 3 ) , EXTRACT_32BITS ( obj_tptr + 4 ) ) ) ; } obj_tlen -= * ( obj_tptr + 1 ) ; obj_tptr += * ( obj_tptr + 1 ) ; } break ; default : hexdump = TRUE ; } break ; case RSVP_OBJ_HELLO : switch ( rsvp_obj_ctype ) { case RSVP_CTYPE_1 : case RSVP_CTYPE_2 : if ( obj_tlen < 8 ) return - 1 ; ND_PRINT ( ( ndo , \"%s<S2SV_blank><S2SV_blank>Source<S2SV_blank>Instance:<S2SV_blank>0x%08x,<S2SV_blank>Destination<S2SV_blank>Instance:<S2SV_blank>0x%08x\" , ident , EXTRACT_32BITS ( obj_tptr ) , EXTRACT_32BITS ( obj_tptr + 4 ) ) ) ; obj_tlen -= 8 ; obj_tptr += 8 ; break ; default : hexdump = TRUE ; } break ; case RSVP_OBJ_RESTART_CAPABILITY : switch ( rsvp_obj_ctype ) { case RSVP_CTYPE_1 : if ( obj_tlen < 8 ) return - 1 ; ND_PRINT ( ( ndo , \"%s<S2SV_blank><S2SV_blank>Restart<S2SV_blank><S2SV_blank>Time:<S2SV_blank>%ums,<S2SV_blank>Recovery<S2SV_blank>Time:<S2SV_blank>%ums\" , ident , EXTRACT_32BITS ( obj_tptr ) , EXTRACT_32BITS ( obj_tptr + 4 ) ) ) ; obj_tlen -= 8 ; obj_tptr += 8 ; break ; default : hexdump = TRUE ; } break ; case RSVP_OBJ_SESSION_ATTRIBUTE : switch ( rsvp_obj_ctype ) { case RSVP_CTYPE_TUNNEL_IPV4 : if ( obj_tlen < 4 ) return - 1 ; namelen = * ( obj_tptr + 3 ) ; if ( obj_tlen < 4 + namelen ) return - 1 ; ND_PRINT ( ( ndo , \"%s<S2SV_blank><S2SV_blank>Session<S2SV_blank>Name:<S2SV_blank>\" , ident ) ) ; for ( i = 0 ; i < namelen ; i ++ ) safeputchar ( ndo , * ( obj_tptr + 4 + i ) ) ; ND_PRINT ( ( ndo , \"%s<S2SV_blank><S2SV_blank>Setup<S2SV_blank>Priority:<S2SV_blank>%u,<S2SV_blank>Holding<S2SV_blank>Priority:<S2SV_blank>%u,<S2SV_blank>Flags:<S2SV_blank>[%s]<S2SV_blank>(%#x)\" , ident , ( int ) * obj_tptr , ( int ) * ( obj_tptr + 1 ) , bittok2str ( rsvp_session_attribute_flag_values , \"none\" , * ( obj_tptr + 2 ) ) , * ( obj_tptr + 2 ) ) ) ; obj_tlen -= 4 + * ( obj_tptr + 3 ) ; obj_tptr += 4 + * ( obj_tptr + 3 ) ; break ; default : hexdump = TRUE ; } break ; case RSVP_OBJ_GENERALIZED_UNI : switch ( rsvp_obj_ctype ) { int subobj_type , af , subobj_len , total_subobj_len ; case RSVP_CTYPE_1 : if ( obj_tlen < 4 ) return - 1 ; total_subobj_len = obj_tlen ; while ( total_subobj_len > 0 ) { <S2SV_StartBug> subobj_len = EXTRACT_16BITS ( obj_tptr ) ; <S2SV_EndBug> subobj_type = ( EXTRACT_16BITS ( obj_tptr + 2 ) ) >> 8 ; af = ( EXTRACT_16BITS ( obj_tptr + 2 ) ) & 0x00FF ; ND_PRINT ( ( ndo , \"%s<S2SV_blank><S2SV_blank>Subobject<S2SV_blank>Type:<S2SV_blank>%s<S2SV_blank>(%u),<S2SV_blank>AF:<S2SV_blank>%s<S2SV_blank>(%u),<S2SV_blank>length:<S2SV_blank>%u\" , ident , tok2str ( rsvp_obj_generalized_uni_values , \"Unknown\" , subobj_type ) , subobj_type , tok2str ( af_values , \"Unknown\" , af ) , af , subobj_len ) ) ; <S2SV_StartBug> if ( subobj_len == 0 ) <S2SV_EndBug> goto invalid ; switch ( subobj_type ) { case RSVP_GEN_UNI_SUBOBJ_SOURCE_TNA_ADDRESS : case RSVP_GEN_UNI_SUBOBJ_DESTINATION_TNA_ADDRESS : switch ( af ) { case AFNUM_INET : if ( subobj_len < 8 ) return - 1 ; ND_PRINT ( ( ndo , \"%s<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>UNI<S2SV_blank>IPv4<S2SV_blank>TNA<S2SV_blank>address:<S2SV_blank>%s\" , ident , ipaddr_string ( ndo , obj_tptr + 4 ) ) ) ; break ; case AFNUM_INET6 : if ( subobj_len < 20 ) return - 1 ; ND_PRINT ( ( ndo , \"%s<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>UNI<S2SV_blank>IPv6<S2SV_blank>TNA<S2SV_blank>address:<S2SV_blank>%s\" , ident , ip6addr_string ( ndo , obj_tptr + 4 ) ) ) ; break ; case AFNUM_NSAP : if ( subobj_len ) { hexdump = TRUE ; } break ; } break ; case RSVP_GEN_UNI_SUBOBJ_DIVERSITY : if ( subobj_len ) { hexdump = TRUE ; } break ; case RSVP_GEN_UNI_SUBOBJ_EGRESS_LABEL : if ( subobj_len < 16 ) { return - 1 ; } ND_PRINT ( ( ndo , \"%s<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>U-bit:<S2SV_blank>%x,<S2SV_blank>Label<S2SV_blank>type:<S2SV_blank>%u,<S2SV_blank>Logical<S2SV_blank>port<S2SV_blank>id:<S2SV_blank>%u,<S2SV_blank>Label:<S2SV_blank>%u\" , ident , ( ( EXTRACT_32BITS ( obj_tptr + 4 ) ) >> 31 ) , ( ( EXTRACT_32BITS ( obj_tptr + 4 ) ) & 0xFF ) , EXTRACT_32BITS ( obj_tptr + 8 ) , EXTRACT_32BITS ( obj_tptr + 12 ) ) ) ; break ; case RSVP_GEN_UNI_SUBOBJ_SERVICE_LEVEL : if ( subobj_len < 8 ) { return - 1 ; } ND_PRINT ( ( ndo , \"%s<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Service<S2SV_blank>level:<S2SV_blank>%u\" , ident , ( EXTRACT_32BITS ( obj_tptr + 4 ) ) >> 24 ) ) ; break ; default : hexdump = TRUE ; break ; } total_subobj_len -= subobj_len ; obj_tptr += subobj_len ; obj_tlen += subobj_len ; } if ( total_subobj_len ) { hexdump = TRUE ; } break ; default : hexdump = TRUE ; } break ; case RSVP_OBJ_RSVP_HOP : switch ( rsvp_obj_ctype ) { case RSVP_CTYPE_3 : case RSVP_CTYPE_IPV4 : if ( obj_tlen < 8 ) return - 1 ; ND_PRINT ( ( ndo , \"%s<S2SV_blank><S2SV_blank>Previous/Next<S2SV_blank>Interface:<S2SV_blank>%s,<S2SV_blank>Logical<S2SV_blank>Interface<S2SV_blank>Handle:<S2SV_blank>0x%08x\" , ident , ipaddr_string ( ndo , obj_tptr ) , EXTRACT_32BITS ( obj_tptr + 4 ) ) ) ; obj_tlen -= 8 ; obj_tptr += 8 ; if ( obj_tlen ) hexdump = TRUE ; break ; case RSVP_CTYPE_4 : case RSVP_CTYPE_IPV6 : if ( obj_tlen < 20 ) return - 1 ; ND_PRINT ( ( ndo , \"%s<S2SV_blank><S2SV_blank>Previous/Next<S2SV_blank>Interface:<S2SV_blank>%s,<S2SV_blank>Logical<S2SV_blank>Interface<S2SV_blank>Handle:<S2SV_blank>0x%08x\" , ident , ip6addr_string ( ndo , obj_tptr ) , EXTRACT_32BITS ( obj_tptr + 16 ) ) ) ; obj_tlen -= 20 ; obj_tptr += 20 ; hexdump = TRUE ; break ; default : hexdump = TRUE ; } break ; case RSVP_OBJ_TIME_VALUES : switch ( rsvp_obj_ctype ) { case RSVP_CTYPE_1 : if ( obj_tlen < 4 ) return - 1 ; ND_PRINT ( ( ndo , \"%s<S2SV_blank><S2SV_blank>Refresh<S2SV_blank>Period:<S2SV_blank>%ums\" , ident , EXTRACT_32BITS ( obj_tptr ) ) ) ; obj_tlen -= 4 ; obj_tptr += 4 ; break ; default : hexdump = TRUE ; } break ; case RSVP_OBJ_SENDER_TSPEC : case RSVP_OBJ_ADSPEC : case RSVP_OBJ_FLOWSPEC : switch ( rsvp_obj_ctype ) { case RSVP_CTYPE_2 : if ( obj_tlen < 4 ) return - 1 ; ND_PRINT ( ( ndo , \"%s<S2SV_blank><S2SV_blank>Msg-Version:<S2SV_blank>%u,<S2SV_blank>length:<S2SV_blank>%u\" , ident , ( * obj_tptr & 0xf0 ) >> 4 , EXTRACT_16BITS ( obj_tptr + 2 ) << 2 ) ) ; obj_tptr += 4 ; obj_tlen -= 4 ; while ( obj_tlen >= 4 ) { intserv_serv_tlen = EXTRACT_16BITS ( obj_tptr + 2 ) << 2 ; ND_PRINT ( ( ndo , \"%s<S2SV_blank><S2SV_blank>Service<S2SV_blank>Type:<S2SV_blank>%s<S2SV_blank>(%u),<S2SV_blank>break<S2SV_blank>bit<S2SV_blank>%s<S2SV_blank>set,<S2SV_blank>Service<S2SV_blank>length:<S2SV_blank>%u\" , ident , tok2str ( rsvp_intserv_service_type_values , \"unknown\" , * ( obj_tptr ) ) , * ( obj_tptr ) , ( * ( obj_tptr + 1 ) & 0x80 ) ? \"\" : \"not\" , intserv_serv_tlen ) ) ; obj_tptr += 4 ; obj_tlen -= 4 ; while ( intserv_serv_tlen >= 4 ) { processed = rsvp_intserv_print ( ndo , obj_tptr , obj_tlen ) ; if ( processed == 0 ) break ; obj_tlen -= processed ; intserv_serv_tlen -= processed ; obj_tptr += processed ; } } break ; default : hexdump = TRUE ; } break ; case RSVP_OBJ_FILTERSPEC : switch ( rsvp_obj_ctype ) { case RSVP_CTYPE_IPV4 : if ( obj_tlen < 8 ) return - 1 ; ND_PRINT ( ( ndo , \"%s<S2SV_blank><S2SV_blank>Source<S2SV_blank>Address:<S2SV_blank>%s,<S2SV_blank>Source<S2SV_blank>Port:<S2SV_blank>%u\" , ident , ipaddr_string ( ndo , obj_tptr ) , EXTRACT_16BITS ( obj_tptr + 6 ) ) ) ; obj_tlen -= 8 ; obj_tptr += 8 ; break ; case RSVP_CTYPE_IPV6 : if ( obj_tlen < 20 ) return - 1 ; ND_PRINT ( ( ndo , \"%s<S2SV_blank><S2SV_blank>Source<S2SV_blank>Address:<S2SV_blank>%s,<S2SV_blank>Source<S2SV_blank>Port:<S2SV_blank>%u\" , ident , ip6addr_string ( ndo , obj_tptr ) , EXTRACT_16BITS ( obj_tptr + 18 ) ) ) ; obj_tlen -= 20 ; obj_tptr += 20 ; break ; case RSVP_CTYPE_3 : if ( obj_tlen < 20 ) return - 1 ; ND_PRINT ( ( ndo , \"%s<S2SV_blank><S2SV_blank>Source<S2SV_blank>Address:<S2SV_blank>%s,<S2SV_blank>Flow<S2SV_blank>Label:<S2SV_blank>%u\" , ident , ip6addr_string ( ndo , obj_tptr ) , EXTRACT_24BITS ( obj_tptr + 17 ) ) ) ; obj_tlen -= 20 ; obj_tptr += 20 ; break ; case RSVP_CTYPE_TUNNEL_IPV6 : if ( obj_tlen < 20 ) return - 1 ; ND_PRINT ( ( ndo , \"%s<S2SV_blank><S2SV_blank>Source<S2SV_blank>Address:<S2SV_blank>%s,<S2SV_blank>LSP-ID:<S2SV_blank>0x%04x\" , ident , ipaddr_string ( ndo , obj_tptr ) , EXTRACT_16BITS ( obj_tptr + 18 ) ) ) ; obj_tlen -= 20 ; obj_tptr += 20 ; break ; case RSVP_CTYPE_13 : if ( obj_tlen < 40 ) return - 1 ; ND_PRINT ( ( ndo , \"%s<S2SV_blank><S2SV_blank>IPv6<S2SV_blank>Tunnel<S2SV_blank>Sender<S2SV_blank>Address:<S2SV_blank>%s,<S2SV_blank>LSP<S2SV_blank>ID:<S2SV_blank>0x%04x\" \"%s<S2SV_blank><S2SV_blank>Sub-Group<S2SV_blank>Originator<S2SV_blank>ID:<S2SV_blank>%s,<S2SV_blank>Sub-Group<S2SV_blank>ID:<S2SV_blank>0x%04x\" , ident , ip6addr_string ( ndo , obj_tptr ) , EXTRACT_16BITS ( obj_tptr + 18 ) , ident , ip6addr_string ( ndo , obj_tptr + 20 ) , EXTRACT_16BITS ( obj_tptr + 38 ) ) ) ; obj_tlen -= 40 ; obj_tptr += 40 ; break ; case RSVP_CTYPE_TUNNEL_IPV4 : if ( obj_tlen < 8 ) return - 1 ; ND_PRINT ( ( ndo , \"%s<S2SV_blank><S2SV_blank>Source<S2SV_blank>Address:<S2SV_blank>%s,<S2SV_blank>LSP-ID:<S2SV_blank>0x%04x\" , ident , ipaddr_string ( ndo , obj_tptr ) , EXTRACT_16BITS ( obj_tptr + 6 ) ) ) ; obj_tlen -= 8 ; obj_tptr += 8 ; break ; case RSVP_CTYPE_12 : if ( obj_tlen < 16 ) return - 1 ; ND_PRINT ( ( ndo , \"%s<S2SV_blank><S2SV_blank>IPv4<S2SV_blank>Tunnel<S2SV_blank>Sender<S2SV_blank>Address:<S2SV_blank>%s,<S2SV_blank>LSP<S2SV_blank>ID:<S2SV_blank>0x%04x\" \"%s<S2SV_blank><S2SV_blank>Sub-Group<S2SV_blank>Originator<S2SV_blank>ID:<S2SV_blank>%s,<S2SV_blank>Sub-Group<S2SV_blank>ID:<S2SV_blank>0x%04x\" , ident , ipaddr_string ( ndo , obj_tptr ) , EXTRACT_16BITS ( obj_tptr + 6 ) , ident , ipaddr_string ( ndo , obj_tptr + 8 ) , EXTRACT_16BITS ( obj_tptr + 12 ) ) ) ; obj_tlen -= 16 ; obj_tptr += 16 ; break ; default : hexdump = TRUE ; } break ; case RSVP_OBJ_FASTREROUTE : obj_ptr . rsvp_obj_frr = ( const struct rsvp_obj_frr_t * ) obj_tptr ; switch ( rsvp_obj_ctype ) { case RSVP_CTYPE_1 : if ( obj_tlen < sizeof ( struct rsvp_obj_frr_t ) ) return - 1 ; bw . i = EXTRACT_32BITS ( obj_ptr . rsvp_obj_frr -> bandwidth ) ; ND_PRINT ( ( ndo , \"%s<S2SV_blank><S2SV_blank>Setup<S2SV_blank>Priority:<S2SV_blank>%u,<S2SV_blank>Holding<S2SV_blank>Priority:<S2SV_blank>%u,<S2SV_blank>Hop-limit:<S2SV_blank>%u,<S2SV_blank>Bandwidth:<S2SV_blank>%.10g<S2SV_blank>Mbps\" , ident , ( int ) obj_ptr . rsvp_obj_frr -> setup_prio , ( int ) obj_ptr . rsvp_obj_frr -> hold_prio , ( int ) obj_ptr . rsvp_obj_frr -> hop_limit , bw . f * 8 / 1000000 ) ) ; ND_PRINT ( ( ndo , \"%s<S2SV_blank><S2SV_blank>Include-any:<S2SV_blank>0x%08x,<S2SV_blank>Exclude-any:<S2SV_blank>0x%08x,<S2SV_blank>Include-all:<S2SV_blank>0x%08x\" , ident , EXTRACT_32BITS ( obj_ptr . rsvp_obj_frr -> include_any ) , EXTRACT_32BITS ( obj_ptr . rsvp_obj_frr -> exclude_any ) , EXTRACT_32BITS ( obj_ptr . rsvp_obj_frr -> include_all ) ) ) ; obj_tlen -= sizeof ( struct rsvp_obj_frr_t ) ; obj_tptr += sizeof ( struct rsvp_obj_frr_t ) ; break ; case RSVP_CTYPE_TUNNEL_IPV4 : if ( obj_tlen < 16 ) return - 1 ; bw . i = EXTRACT_32BITS ( obj_ptr . rsvp_obj_frr -> bandwidth ) ; ND_PRINT ( ( ndo , \"%s<S2SV_blank><S2SV_blank>Setup<S2SV_blank>Priority:<S2SV_blank>%u,<S2SV_blank>Holding<S2SV_blank>Priority:<S2SV_blank>%u,<S2SV_blank>Hop-limit:<S2SV_blank>%u,<S2SV_blank>Bandwidth:<S2SV_blank>%.10g<S2SV_blank>Mbps\" , ident , ( int ) obj_ptr . rsvp_obj_frr -> setup_prio , ( int ) obj_ptr . rsvp_obj_frr -> hold_prio , ( int ) obj_ptr . rsvp_obj_frr -> hop_limit , bw . f * 8 / 1000000 ) ) ; ND_PRINT ( ( ndo , \"%s<S2SV_blank><S2SV_blank>Include<S2SV_blank>Colors:<S2SV_blank>0x%08x,<S2SV_blank>Exclude<S2SV_blank>Colors:<S2SV_blank>0x%08x\" , ident , EXTRACT_32BITS ( obj_ptr . rsvp_obj_frr -> include_any ) , EXTRACT_32BITS ( obj_ptr . rsvp_obj_frr -> exclude_any ) ) ) ; obj_tlen -= 16 ; obj_tptr += 16 ; break ; default : hexdump = TRUE ; } break ; case RSVP_OBJ_DETOUR : switch ( rsvp_obj_ctype ) { case RSVP_CTYPE_TUNNEL_IPV4 : while ( obj_tlen >= 8 ) { ND_PRINT ( ( ndo , \"%s<S2SV_blank><S2SV_blank>PLR-ID:<S2SV_blank>%s,<S2SV_blank>Avoid-Node-ID:<S2SV_blank>%s\" , ident , ipaddr_string ( ndo , obj_tptr ) , ipaddr_string ( ndo , obj_tptr + 4 ) ) ) ; obj_tlen -= 8 ; obj_tptr += 8 ; } break ; default : hexdump = TRUE ; } break ; case RSVP_OBJ_CLASSTYPE : case RSVP_OBJ_CLASSTYPE_OLD : switch ( rsvp_obj_ctype ) { case RSVP_CTYPE_1 : ND_PRINT ( ( ndo , \"%s<S2SV_blank><S2SV_blank>CT:<S2SV_blank>%u\" , ident , EXTRACT_32BITS ( obj_tptr ) & 0x7 ) ) ; obj_tlen -= 4 ; obj_tptr += 4 ; break ; default : hexdump = TRUE ; } break ; case RSVP_OBJ_ERROR_SPEC : switch ( rsvp_obj_ctype ) { case RSVP_CTYPE_3 : case RSVP_CTYPE_IPV4 : if ( obj_tlen < 8 ) return - 1 ; error_code = * ( obj_tptr + 5 ) ; error_value = EXTRACT_16BITS ( obj_tptr + 6 ) ; ND_PRINT ( ( ndo , \"%s<S2SV_blank><S2SV_blank>Error<S2SV_blank>Node<S2SV_blank>Address:<S2SV_blank>%s,<S2SV_blank>Flags:<S2SV_blank>[0x%02x]%s<S2SV_blank><S2SV_blank>Error<S2SV_blank>Code:<S2SV_blank>%s<S2SV_blank>(%u)\" , ident , ipaddr_string ( ndo , obj_tptr ) , * ( obj_tptr + 4 ) , ident , tok2str ( rsvp_obj_error_code_values , \"unknown\" , error_code ) , error_code ) ) ; switch ( error_code ) { case RSVP_OBJ_ERROR_SPEC_CODE_ROUTING : ND_PRINT ( ( ndo , \",<S2SV_blank>Error<S2SV_blank>Value:<S2SV_blank>%s<S2SV_blank>(%u)\" , tok2str ( rsvp_obj_error_code_routing_values , \"unknown\" , error_value ) , error_value ) ) ; break ; case RSVP_OBJ_ERROR_SPEC_CODE_DIFFSERV_TE : case RSVP_OBJ_ERROR_SPEC_CODE_DIFFSERV_TE_OLD : ND_PRINT ( ( ndo , \",<S2SV_blank>Error<S2SV_blank>Value:<S2SV_blank>%s<S2SV_blank>(%u)\" , tok2str ( rsvp_obj_error_code_diffserv_te_values , \"unknown\" , error_value ) , error_value ) ) ; break ; default : ND_PRINT ( ( ndo , \",<S2SV_blank>Unknown<S2SV_blank>Error<S2SV_blank>Value<S2SV_blank>(%u)\" , error_value ) ) ; break ; } obj_tlen -= 8 ; obj_tptr += 8 ; break ; case RSVP_CTYPE_4 : case RSVP_CTYPE_IPV6 : if ( obj_tlen < 20 ) return - 1 ; error_code = * ( obj_tptr + 17 ) ; error_value = EXTRACT_16BITS ( obj_tptr + 18 ) ; ND_PRINT ( ( ndo , \"%s<S2SV_blank><S2SV_blank>Error<S2SV_blank>Node<S2SV_blank>Address:<S2SV_blank>%s,<S2SV_blank>Flags:<S2SV_blank>[0x%02x]%s<S2SV_blank><S2SV_blank>Error<S2SV_blank>Code:<S2SV_blank>%s<S2SV_blank>(%u)\" , ident , ip6addr_string ( ndo , obj_tptr ) , * ( obj_tptr + 16 ) , ident , tok2str ( rsvp_obj_error_code_values , \"unknown\" , error_code ) , error_code ) ) ; switch ( error_code ) { case RSVP_OBJ_ERROR_SPEC_CODE_ROUTING : ND_PRINT ( ( ndo , \",<S2SV_blank>Error<S2SV_blank>Value:<S2SV_blank>%s<S2SV_blank>(%u)\" , tok2str ( rsvp_obj_error_code_routing_values , \"unknown\" , error_value ) , error_value ) ) ; break ; default : break ; } obj_tlen -= 20 ; obj_tptr += 20 ; break ; default : hexdump = TRUE ; } break ; case RSVP_OBJ_PROPERTIES : switch ( rsvp_obj_ctype ) { case RSVP_CTYPE_1 : if ( obj_tlen < 4 ) return - 1 ; padbytes = EXTRACT_16BITS ( obj_tptr + 2 ) ; ND_PRINT ( ( ndo , \"%s<S2SV_blank><S2SV_blank>TLV<S2SV_blank>count:<S2SV_blank>%u,<S2SV_blank>padding<S2SV_blank>bytes:<S2SV_blank>%u\" , ident , EXTRACT_16BITS ( obj_tptr ) , padbytes ) ) ; obj_tlen -= 4 ; obj_tptr += 4 ; while ( obj_tlen >= 2 + padbytes ) { ND_PRINT ( ( ndo , \"%s<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s<S2SV_blank>TLV<S2SV_blank>(0x%02x),<S2SV_blank>length:<S2SV_blank>%u\" , ident , tok2str ( rsvp_obj_prop_tlv_values , \"unknown\" , * obj_tptr ) , * obj_tptr , * ( obj_tptr + 1 ) ) ) ; if ( obj_tlen < * ( obj_tptr + 1 ) ) return - 1 ; if ( * ( obj_tptr + 1 ) < 2 ) return - 1 ; print_unknown_data ( ndo , obj_tptr + 2 , \"\\\\n\\\\t\\\\t\" , * ( obj_tptr + 1 ) - 2 ) ; obj_tlen -= * ( obj_tptr + 1 ) ; obj_tptr += * ( obj_tptr + 1 ) ; } break ; default : hexdump = TRUE ; } break ; case RSVP_OBJ_MESSAGE_ID : case RSVP_OBJ_MESSAGE_ID_ACK : case RSVP_OBJ_MESSAGE_ID_LIST : switch ( rsvp_obj_ctype ) { case RSVP_CTYPE_1 : case RSVP_CTYPE_2 : if ( obj_tlen < 8 ) return - 1 ; ND_PRINT ( ( ndo , \"%s<S2SV_blank><S2SV_blank>Flags<S2SV_blank>[0x%02x],<S2SV_blank>epoch:<S2SV_blank>%u\" , ident , * obj_tptr , EXTRACT_24BITS ( obj_tptr + 1 ) ) ) ; obj_tlen -= 4 ; obj_tptr += 4 ; while ( obj_tlen >= 4 ) { ND_PRINT ( ( ndo , \"%s<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Message-ID<S2SV_blank>0x%08x<S2SV_blank>(%u)\" , ident , EXTRACT_32BITS ( obj_tptr ) , EXTRACT_32BITS ( obj_tptr ) ) ) ; obj_tlen -= 4 ; obj_tptr += 4 ; } break ; default : hexdump = TRUE ; } break ; case RSVP_OBJ_INTEGRITY : switch ( rsvp_obj_ctype ) { case RSVP_CTYPE_1 : if ( obj_tlen < sizeof ( struct rsvp_obj_integrity_t ) ) return - 1 ; obj_ptr . rsvp_obj_integrity = ( const struct rsvp_obj_integrity_t * ) obj_tptr ; ND_PRINT ( ( ndo , \"%s<S2SV_blank><S2SV_blank>Key-ID<S2SV_blank>0x%04x%08x,<S2SV_blank>Sequence<S2SV_blank>0x%08x%08x,<S2SV_blank>Flags<S2SV_blank>[%s]\" , ident , EXTRACT_16BITS ( obj_ptr . rsvp_obj_integrity -> key_id ) , EXTRACT_32BITS ( obj_ptr . rsvp_obj_integrity -> key_id + 2 ) , EXTRACT_32BITS ( obj_ptr . rsvp_obj_integrity -> sequence ) , EXTRACT_32BITS ( obj_ptr . rsvp_obj_integrity -> sequence + 4 ) , bittok2str ( rsvp_obj_integrity_flag_values , \"none\" , obj_ptr . rsvp_obj_integrity -> flags ) ) ) ; ND_PRINT ( ( ndo , \"%s<S2SV_blank><S2SV_blank>MD5-sum<S2SV_blank>0x%08x%08x%08x%08x<S2SV_blank>\" , ident , EXTRACT_32BITS ( obj_ptr . rsvp_obj_integrity -> digest ) , EXTRACT_32BITS ( obj_ptr . rsvp_obj_integrity -> digest + 4 ) , EXTRACT_32BITS ( obj_ptr . rsvp_obj_integrity -> digest + 8 ) , EXTRACT_32BITS ( obj_ptr . rsvp_obj_integrity -> digest + 12 ) ) ) ; sigcheck = signature_verify ( ndo , pptr , plen , obj_ptr . rsvp_obj_integrity -> digest , rsvp_clear_checksum , rsvp_com_header ) ; ND_PRINT ( ( ndo , \"<S2SV_blank>(%s)\" , tok2str ( signature_check_values , \"Unknown\" , sigcheck ) ) ) ; obj_tlen += sizeof ( struct rsvp_obj_integrity_t ) ; obj_tptr += sizeof ( struct rsvp_obj_integrity_t ) ; break ; default : hexdump = TRUE ; } break ; case RSVP_OBJ_ADMIN_STATUS : switch ( rsvp_obj_ctype ) { case RSVP_CTYPE_1 : if ( obj_tlen < 4 ) return - 1 ; ND_PRINT ( ( ndo , \"%s<S2SV_blank><S2SV_blank>Flags<S2SV_blank>[%s]\" , ident , bittok2str ( rsvp_obj_admin_status_flag_values , \"none\" , EXTRACT_32BITS ( obj_tptr ) ) ) ) ; obj_tlen -= 4 ; obj_tptr += 4 ; break ; default : hexdump = TRUE ; } break ; case RSVP_OBJ_LABEL_SET : switch ( rsvp_obj_ctype ) { case RSVP_CTYPE_1 : if ( obj_tlen < 4 ) return - 1 ; action = ( EXTRACT_16BITS ( obj_tptr ) >> 8 ) ; ND_PRINT ( ( ndo , \"%s<S2SV_blank><S2SV_blank>Action:<S2SV_blank>%s<S2SV_blank>(%u),<S2SV_blank>Label<S2SV_blank>type:<S2SV_blank>%u\" , ident , tok2str ( rsvp_obj_label_set_action_values , \"Unknown\" , action ) , action , ( ( EXTRACT_32BITS ( obj_tptr ) & 0x7F ) ) ) ) ; switch ( action ) { case LABEL_SET_INCLUSIVE_RANGE : case LABEL_SET_EXCLUSIVE_RANGE : if ( obj_tlen < 12 ) return - 1 ; ND_PRINT ( ( ndo , \"%s<S2SV_blank><S2SV_blank>Start<S2SV_blank>range:<S2SV_blank>%u,<S2SV_blank>End<S2SV_blank>range:<S2SV_blank>%u\" , ident , EXTRACT_32BITS ( obj_tptr + 4 ) , EXTRACT_32BITS ( obj_tptr + 8 ) ) ) ; obj_tlen -= 12 ; obj_tptr += 12 ; break ; default : obj_tlen -= 4 ; obj_tptr += 4 ; subchannel = 1 ; while ( obj_tlen >= 4 ) { ND_PRINT ( ( ndo , \"%s<S2SV_blank><S2SV_blank>Subchannel<S2SV_blank>#%u:<S2SV_blank>%u\" , ident , subchannel , EXTRACT_32BITS ( obj_tptr ) ) ) ; obj_tptr += 4 ; obj_tlen -= 4 ; subchannel ++ ; } break ; } break ; default : hexdump = TRUE ; } break ; case RSVP_OBJ_S2L : switch ( rsvp_obj_ctype ) { case RSVP_CTYPE_IPV4 : if ( obj_tlen < 4 ) return - 1 ; ND_PRINT ( ( ndo , \"%s<S2SV_blank><S2SV_blank>Sub-LSP<S2SV_blank>destination<S2SV_blank>address:<S2SV_blank>%s\" , ident , ipaddr_string ( ndo , obj_tptr ) ) ) ; obj_tlen -= 4 ; obj_tptr += 4 ; break ; case RSVP_CTYPE_IPV6 : if ( obj_tlen < 16 ) return - 1 ; ND_PRINT ( ( ndo , \"%s<S2SV_blank><S2SV_blank>Sub-LSP<S2SV_blank>destination<S2SV_blank>address:<S2SV_blank>%s\" , ident , ip6addr_string ( ndo , obj_tptr ) ) ) ; obj_tlen -= 16 ; obj_tptr += 16 ; break ; default : hexdump = TRUE ; } break ; case RSVP_OBJ_SCOPE : case RSVP_OBJ_POLICY_DATA : case RSVP_OBJ_ACCEPT_LABEL_SET : case RSVP_OBJ_PROTECTION : default : if ( ndo -> ndo_vflag <= 1 ) print_unknown_data ( ndo , obj_tptr , \"\\\\n\\\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>\" , obj_tlen ) ; break ; } if ( ndo -> ndo_vflag > 1 || hexdump == TRUE ) print_unknown_data ( ndo , tptr + sizeof ( struct rsvp_object_header ) , \"\\\\n\\\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>\" , rsvp_obj_len - sizeof ( struct rsvp_object_header ) ) ; tptr += rsvp_obj_len ; tlen -= rsvp_obj_len ; } return 0 ; invalid : ND_PRINT ( ( ndo , \"%s\" , istr ) ) ; return - 1 ; trunc : ND_PRINT ( ( ndo , \"\\\\n\\\\t\\\\t\" ) ) ; ND_PRINT ( ( ndo , \"%s\" , tstr ) ) ; return - 1 ; }\n","target":"<S2SV_ModStart> 0 ) { if ( total_subobj_len < 4 ) goto invalid ; <S2SV_ModStart> if ( subobj_len < 4 || subobj_len > total_subobj_len <S2SV_ModEnd> ) goto invalid\n","project_and_commit_id":"the-tcpdump-group@tcpdump/289c672020280529fd382f3502efab7100d638ec","cve_id":"CVE-2017-13051","original_address":"https://github.com/the-tcpdump-group/tcpdump/commit/289c672020280529fd382f3502efab7100d638ec","time":"2017-09-14T06:29Z"},
	{"Unnamed: 0":5874,"cwe_id":"CWE-000","source":"CWE-000 static int replace_map_fd_with_map_ptr ( struct verifier_env * env ) { struct bpf_insn * insn = env -> prog -> insnsi ; int insn_cnt = env -> prog -> len ; int i , j ; for ( i = 0 ; i < insn_cnt ; i ++ , insn ++ ) { if ( BPF_CLASS ( insn -> code ) == BPF_LDX && ( BPF_MODE ( insn -> code ) != BPF_MEM || insn -> imm != 0 ) ) { verbose ( \"BPF_LDX<S2SV_blank>uses<S2SV_blank>reserved<S2SV_blank>fields\\\\n\" ) ; return - EINVAL ; } if ( BPF_CLASS ( insn -> code ) == BPF_STX && ( ( BPF_MODE ( insn -> code ) != BPF_MEM && BPF_MODE ( insn -> code ) != BPF_XADD ) || insn -> imm != 0 ) ) { verbose ( \"BPF_STX<S2SV_blank>uses<S2SV_blank>reserved<S2SV_blank>fields\\\\n\" ) ; return - EINVAL ; } if ( insn [ 0 ] . code == ( BPF_LD | BPF_IMM | BPF_DW ) ) { struct bpf_map * map ; struct fd f ; if ( i == insn_cnt - 1 || insn [ 1 ] . code != 0 || insn [ 1 ] . dst_reg != 0 || insn [ 1 ] . src_reg != 0 || insn [ 1 ] . off != 0 ) { verbose ( \"invalid<S2SV_blank>bpf_ld_imm64<S2SV_blank>insn\\\\n\" ) ; return - EINVAL ; } if ( insn -> src_reg == 0 ) goto next_insn ; if ( insn -> src_reg != BPF_PSEUDO_MAP_FD ) { verbose ( \"unrecognized<S2SV_blank>bpf_ld_imm64<S2SV_blank>insn\\\\n\" ) ; return - EINVAL ; } f = fdget ( insn -> imm ) ; map = __bpf_map_get ( f ) ; if ( IS_ERR ( map ) ) { verbose ( \"fd<S2SV_blank>%d<S2SV_blank>is<S2SV_blank>not<S2SV_blank>pointing<S2SV_blank>to<S2SV_blank>valid<S2SV_blank>bpf_map\\\\n\" , insn -> imm ) ; return PTR_ERR ( map ) ; } insn [ 0 ] . imm = ( u32 ) ( unsigned long ) map ; insn [ 1 ] . imm = ( ( u64 ) ( unsigned long ) map ) >> 32 ; for ( j = 0 ; j < env -> used_map_cnt ; j ++ ) if ( env -> used_maps [ j ] == map ) { fdput ( f ) ; goto next_insn ; } if ( env -> used_map_cnt >= MAX_USED_MAPS ) { fdput ( f ) ; return - E2BIG ; } <S2SV_StartBug> env -> used_maps [ env -> used_map_cnt ++ ] = map ; <S2SV_EndBug> <S2SV_StartBug> bpf_map_inc ( map , false ) ; <S2SV_EndBug> fdput ( f ) ; next_insn : insn ++ ; i ++ ; } } return 0 ; }\n","target":"<S2SV_ModStart> E2BIG ; } map = bpf_map_inc ( map , false ) ; if ( IS_ERR ( map ) ) { fdput ( f ) ; return PTR_ERR ( map ) ; } <S2SV_ModStart> = map ; <S2SV_ModEnd> fdput ( f\n","project_and_commit_id":"torvalds@linux/92117d8443bc5afacc8d5ba82e541946310f106e","cve_id":"CVE-2016-4558","original_address":"https://github.com/torvalds/linux/commit/92117d8443bc5afacc8d5ba82e541946310f106e","time":"2016-05-23T10:59Z"},
	{"Unnamed: 0":5397,"cwe_id":"CWE-000","source":"CWE-000 bool_t xdr_krb5_principal ( XDR * xdrs , krb5_principal * objp ) { int ret ; char * p = NULL ; krb5_principal pr = NULL ; static krb5_context context = NULL ; if ( ! context && kadm5_init_krb5_context ( & context ) ) return ( FALSE ) ; switch ( xdrs -> x_op ) { case XDR_ENCODE : if ( * objp ) { if ( ( ret = krb5_unparse_name ( context , * objp , & p ) ) != 0 ) return FALSE ; } if ( ! xdr_nullstring ( xdrs , & p ) ) return FALSE ; if ( p ) free ( p ) ; break ; case XDR_DECODE : if ( ! xdr_nullstring ( xdrs , & p ) ) return FALSE ; if ( p ) { ret = krb5_parse_name ( context , p , & pr ) ; if ( ret != 0 ) return FALSE ; * objp = pr ; free ( p ) ; } else * objp = NULL ; break ; case XDR_FREE : if ( * objp != NULL ) krb5_free_principal ( context , * objp ) ; <S2SV_StartBug> break ; <S2SV_EndBug> } return TRUE ; }\n","target":"<S2SV_ModStart> objp ) ; * objp = NULL ;\n","project_and_commit_id":"krb5@krb5/a197e92349a4aa2141b5dff12e9dd44c2a2166e3","cve_id":"CVE-2014-9421","original_address":"https://github.com/krb5/krb5/commit/a197e92349a4aa2141b5dff12e9dd44c2a2166e3","time":"2015-02-19T11:59Z"},
	{"Unnamed: 0":5366,"cwe_id":"CWE-119","source":"CWE-119 static int vp8_rd_pick_best_mbsegmentation ( VP8_COMP * cpi , MACROBLOCK * x , int_mv * best_ref_mv , int best_rd , int * mdcounts , int * returntotrate , int * returnyrate , int * returndistortion , int mvthresh ) { int i ; BEST_SEG_INFO bsi ; <S2SV_StartBug> vpx_memset ( & bsi , 0 , sizeof ( bsi ) ) ; <S2SV_EndBug> bsi . segment_rd = best_rd ; bsi . ref_mv = best_ref_mv ; bsi . mvp . as_int = best_ref_mv -> as_int ; bsi . mvthresh = mvthresh ; bsi . mdcounts = mdcounts ; for ( i = 0 ; i < 16 ; i ++ ) { bsi . modes [ i ] = ZERO4X4 ; } if ( cpi -> compressor_speed == 0 ) { rd_check_segment ( cpi , x , & bsi , BLOCK_16X8 ) ; rd_check_segment ( cpi , x , & bsi , BLOCK_8X16 ) ; rd_check_segment ( cpi , x , & bsi , BLOCK_8X8 ) ; rd_check_segment ( cpi , x , & bsi , BLOCK_4X4 ) ; } else { int sr ; rd_check_segment ( cpi , x , & bsi , BLOCK_8X8 ) ; if ( bsi . segment_rd < best_rd ) { int col_min = ( ( best_ref_mv -> as_mv . col + 7 ) >> 3 ) - MAX_FULL_PEL_VAL ; int row_min = ( ( best_ref_mv -> as_mv . row + 7 ) >> 3 ) - MAX_FULL_PEL_VAL ; int col_max = ( best_ref_mv -> as_mv . col >> 3 ) + MAX_FULL_PEL_VAL ; int row_max = ( best_ref_mv -> as_mv . row >> 3 ) + MAX_FULL_PEL_VAL ; int tmp_col_min = x -> mv_col_min ; int tmp_col_max = x -> mv_col_max ; int tmp_row_min = x -> mv_row_min ; int tmp_row_max = x -> mv_row_max ; if ( x -> mv_col_min < col_min ) x -> mv_col_min = col_min ; if ( x -> mv_col_max > col_max ) x -> mv_col_max = col_max ; if ( x -> mv_row_min < row_min ) x -> mv_row_min = row_min ; if ( x -> mv_row_max > row_max ) x -> mv_row_max = row_max ; bsi . sv_mvp [ 0 ] . as_int = bsi . mvs [ 0 ] . as_int ; bsi . sv_mvp [ 1 ] . as_int = bsi . mvs [ 2 ] . as_int ; bsi . sv_mvp [ 2 ] . as_int = bsi . mvs [ 8 ] . as_int ; bsi . sv_mvp [ 3 ] . as_int = bsi . mvs [ 10 ] . as_int ; { sr = MAXF ( ( abs ( bsi . sv_mvp [ 0 ] . as_mv . row - bsi . sv_mvp [ 2 ] . as_mv . row ) ) >> 3 , ( abs ( bsi . sv_mvp [ 0 ] . as_mv . col - bsi . sv_mvp [ 2 ] . as_mv . col ) ) >> 3 ) ; vp8_cal_step_param ( sr , & bsi . sv_istep [ 0 ] ) ; sr = MAXF ( ( abs ( bsi . sv_mvp [ 1 ] . as_mv . row - bsi . sv_mvp [ 3 ] . as_mv . row ) ) >> 3 , ( abs ( bsi . sv_mvp [ 1 ] . as_mv . col - bsi . sv_mvp [ 3 ] . as_mv . col ) ) >> 3 ) ; vp8_cal_step_param ( sr , & bsi . sv_istep [ 1 ] ) ; rd_check_segment ( cpi , x , & bsi , BLOCK_8X16 ) ; } { sr = MAXF ( ( abs ( bsi . sv_mvp [ 0 ] . as_mv . row - bsi . sv_mvp [ 1 ] . as_mv . row ) ) >> 3 , ( abs ( bsi . sv_mvp [ 0 ] . as_mv . col - bsi . sv_mvp [ 1 ] . as_mv . col ) ) >> 3 ) ; vp8_cal_step_param ( sr , & bsi . sv_istep [ 0 ] ) ; sr = MAXF ( ( abs ( bsi . sv_mvp [ 2 ] . as_mv . row - bsi . sv_mvp [ 3 ] . as_mv . row ) ) >> 3 , ( abs ( bsi . sv_mvp [ 2 ] . as_mv . col - bsi . sv_mvp [ 3 ] . as_mv . col ) ) >> 3 ) ; vp8_cal_step_param ( sr , & bsi . sv_istep [ 1 ] ) ; rd_check_segment ( cpi , x , & bsi , BLOCK_16X8 ) ; } if ( cpi -> sf . no_skip_block4x4_search || bsi . segment_num == BLOCK_8X8 ) { bsi . mvp . as_int = bsi . sv_mvp [ 0 ] . as_int ; rd_check_segment ( cpi , x , & bsi , BLOCK_4X4 ) ; } x -> mv_col_min = tmp_col_min ; x -> mv_col_max = tmp_col_max ; x -> mv_row_min = tmp_row_min ; x -> mv_row_max = tmp_row_max ; } } for ( i = 0 ; i < 16 ; i ++ ) { BLOCKD * bd = & x -> e_mbd . block [ i ] ; bd -> bmi . mv . as_int = bsi . mvs [ i ] . as_int ; * bd -> eob = bsi . eobs [ i ] ; } * returntotrate = bsi . r ; * returndistortion = bsi . d ; * returnyrate = bsi . segment_yrate ; x -> e_mbd . mode_info_context -> mbmi . partitioning = bsi . segment_num ; x -> partition_info -> count = vp8_mbsplit_count [ bsi . segment_num ] ; for ( i = 0 ; i < x -> partition_info -> count ; i ++ ) { int j ; j = vp8_mbsplit_offset [ bsi . segment_num ] [ i ] ; x -> partition_info -> bmi [ i ] . mode = bsi . modes [ j ] ; x -> partition_info -> bmi [ i ] . mv . as_mv = bsi . mvs [ j ] . as_mv ; } x -> partition_info -> bmi [ 15 ] . mv . as_int = bsi . mvs [ 15 ] . as_int ; return bsi . segment_rd ; }\n","target":"<S2SV_ModStart> BEST_SEG_INFO bsi ; memset <S2SV_ModEnd> ( & bsi\n","project_and_commit_id":"external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426","cve_id":"CVE-2016-1621","original_address":"https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426","time":"2016-03-12T21:59Z"},
	{"Unnamed: 0":3246,"cwe_id":"CWE-399","source":"CWE-399 int cib_remote_msg ( gpointer data ) { <S2SV_StartBug> const char * value = NULL ; <S2SV_EndBug> xmlNode * command = NULL ; <S2SV_StartBug> cib_client_t * client = data ; <S2SV_EndBug> crm_trace ( \"%s<S2SV_blank>callback\" , client -> encrypted ? \"secure\" : \"clear-text\" ) ; <S2SV_StartBug> command = crm_recv_remote_msg ( client -> session , client -> encrypted ) ; <S2SV_EndBug> if ( command == NULL ) { return - 1 ; } <S2SV_StartBug> value = crm_element_name ( command ) ; <S2SV_EndBug> if ( safe_str_neq ( value , \"cib_command\" ) ) { crm_log_xml_trace ( command , \"Bad<S2SV_blank>command:<S2SV_blank>\" ) ; goto bail ; } if ( client -> name == NULL ) { value = crm_element_value ( command , F_CLIENTNAME ) ; if ( value == NULL ) { client -> name = strdup ( client -> id ) ; } else { client -> name = strdup ( value ) ; } } if ( client -> callback_id == NULL ) { value = crm_element_value ( command , F_CIB_CALLBACK_TOKEN ) ; if ( value != NULL ) { client -> callback_id = strdup ( value ) ; crm_trace ( \"Callback<S2SV_blank>channel<S2SV_blank>for<S2SV_blank>%s<S2SV_blank>is<S2SV_blank>%s\" , client -> id , client -> callback_id ) ; } else { client -> callback_id = strdup ( client -> id ) ; } } xml_remove_prop ( command , F_ORIG ) ; xml_remove_prop ( command , F_CIB_HOST ) ; xml_remove_prop ( command , F_CIB_GLOBAL_UPDATE ) ; crm_xml_add ( command , F_TYPE , T_CIB ) ; crm_xml_add ( command , F_CIB_CLIENTID , client -> id ) ; crm_xml_add ( command , F_CIB_CLIENTNAME , client -> name ) ; # if ENABLE_ACL <S2SV_StartBug> crm_xml_add ( command , F_CIB_USER , client -> user ) ; <S2SV_EndBug> # endif if ( crm_element_value ( command , F_CIB_CALLID ) == NULL ) { char * call_uuid = crm_generate_uuid ( ) ; <S2SV_StartBug> crm_xml_add ( command , F_CIB_CALLID , call_uuid ) ; <S2SV_EndBug> free ( call_uuid ) ; } if ( crm_element_value ( command , F_CIB_CALLOPTS ) == NULL ) { crm_xml_add_int ( command , F_CIB_CALLOPTS , 0 ) ; } crm_log_xml_trace ( command , \"Remote<S2SV_blank>command:<S2SV_blank>\" ) ; cib_common_callback_worker ( 0 , 0 , command , client , TRUE ) ; bail : free_xml ( command ) ; command = NULL ; return 0 ; }\n","target":"<S2SV_ModStart> data ) { <S2SV_ModEnd> xmlNode * command <S2SV_ModStart> client = data ; int disconnected = 0 ; int timeout = client -> remote_auth ? - 1 : 1000 <S2SV_ModStart> \"clear-text\" ) ; # ifdef HAVE_GNUTLS_GNUTLS_H if ( client -> encrypted && ( client -> handshake_complete == FALSE ) ) { int rc = 0 ; do { rc = gnutls_handshake ( * <S2SV_ModEnd> client -> session <S2SV_ModStart> client -> session ) ; if ( rc < 0 && rc != GNUTLS_E_AGAIN ) { crm_err ( \"Remote<S2SV_blank>cib<S2SV_blank>tls<S2SV_blank>handshake<S2SV_blank>failed\" ) ; <S2SV_ModEnd> return - 1 <S2SV_ModStart> 1 ; } } while ( rc == GNUTLS_E_INTERRUPTED ) ; if ( rc == 0 ) { crm_debug ( \"Remote<S2SV_blank>cib<S2SV_blank>tls<S2SV_blank>handshake<S2SV_blank>completed\" ) ; client -> handshake_complete = TRUE ; if ( client -> remote_auth_timeout ) { g_source_remove ( client -> remote_auth_timeout ) ; } client -> remote_auth_timeout = g_timeout_add ( REMOTE_AUTH_TIMEOUT , remote_auth_timeout_cb , client ) ; } return 0 ; } # endif crm_recv_remote_msg ( client -> session , & client -> recv_buf , client -> encrypted , timeout , & disconnected ) ; if ( client -> remote_auth == FALSE ) { xmlNode * reg <S2SV_ModEnd> ; # if <S2SV_ModStart> # if ENABLE_ACL const char * user = NULL ; # endif command = crm_parse_remote_buffer ( & client -> recv_buf ) ; if ( cib_remote_auth ( command ) == FALSE ) { free_xml ( command ) ; return - 1 ; } crm_debug ( \"remote<S2SV_blank>connection<S2SV_blank>authenticated<S2SV_blank>successfully\" ) ; client -> remote_auth = TRUE ; g_source_remove ( client -> remote_auth_timeout ) ; client -> remote_auth_timeout = 0 ; client -> name = crm_element_value_copy ( command , \"name\" ) ; # if ENABLE_ACL user = crm_element_value ( command , \"user\" ) ; if ( user ) { new_client -> user = strdup ( user ) ; } # endif reg = create_xml_node ( NULL , \"cib_result\" <S2SV_ModEnd> ) ; crm_xml_add <S2SV_ModStart> ; crm_xml_add ( reg , F_CIB_OPERATION , CRM_OP_REGISTER ) ; crm_xml_add ( reg , F_CIB_CLIENTID , client -> id ) ; crm_send_remote_msg ( client -> session , reg , client -> encrypted ) ; free_xml ( reg ) ; free_xml ( command ) ; } command = crm_parse_remote_buffer ( & client -> recv_buf ) ; while ( command ) { crm_trace ( \"command<S2SV_blank>received\" ) ; cib_handle_remote_msg ( client , command ) ; free_xml ( command ) ; command = crm_parse_remote_buffer ( & client -> recv_buf ) ; } if ( disconnected ) { crm_trace ( \"disconnected<S2SV_blank>while<S2SV_blank>receiving<S2SV_blank>remote<S2SV_blank>cib<S2SV_blank>msg.\" ) ; return - 1 ; } return <S2SV_ModEnd> 0 ; }\n","project_and_commit_id":"ClusterLabs@pacemaker/564f7cc2a51dcd2f28ab12a13394f31be5aa3c93","cve_id":"CVE-2013-0281","original_address":"https://github.com/ClusterLabs/pacemaker/commit/564f7cc2a51dcd2f28ab12a13394f31be5aa3c93","time":"2013-11-23T11:55Z"},
	{"Unnamed: 0":1499,"cwe_id":"CWE-125","source":"CWE-125 int _yr_scan_match_callback ( uint8_t * match_data , int32_t match_length , int flags , void * args ) { CALLBACK_ARGS * callback_args = ( CALLBACK_ARGS * ) args ; YR_STRING * string = callback_args -> string ; YR_MATCH * new_match ; int result = ERROR_SUCCESS ; int tidx = callback_args -> context -> tidx ; size_t match_offset = match_data - callback_args -> data ; <S2SV_StartBug> match_length += callback_args -> forward_matches ; <S2SV_EndBug> if ( callback_args -> full_word ) { if ( flags & RE_FLAGS_WIDE ) { if ( match_offset >= 2 && * ( match_data - 1 ) == 0 && isalnum ( * ( match_data - 2 ) ) ) return ERROR_SUCCESS ; if ( match_offset + match_length + 1 < callback_args -> data_size && * ( match_data + match_length + 1 ) == 0 && isalnum ( * ( match_data + match_length ) ) ) return ERROR_SUCCESS ; } else { if ( match_offset >= 1 && isalnum ( * ( match_data - 1 ) ) ) return ERROR_SUCCESS ; if ( match_offset + match_length < callback_args -> data_size && isalnum ( * ( match_data + match_length ) ) ) return ERROR_SUCCESS ; } } if ( STRING_IS_CHAIN_PART ( string ) ) { result = _yr_scan_verify_chained_string_match ( string , callback_args -> context , match_data , callback_args -> data_base , match_offset , match_length ) ; } else { if ( string -> matches [ tidx ] . count == 0 ) { FAIL_ON_ERROR ( yr_arena_write_data ( callback_args -> context -> matching_strings_arena , & string , sizeof ( string ) , NULL ) ) ; } FAIL_ON_ERROR ( yr_arena_allocate_memory ( callback_args -> context -> matches_arena , sizeof ( YR_MATCH ) , ( void * * ) & new_match ) ) ; new_match -> data_length = yr_min ( match_length , MAX_MATCH_DATA ) ; FAIL_ON_ERROR ( yr_arena_write_data ( callback_args -> context -> matches_arena , match_data , new_match -> data_length , ( void * * ) & new_match -> data ) ) ; if ( result == ERROR_SUCCESS ) { new_match -> base = callback_args -> data_base ; new_match -> offset = match_offset ; new_match -> match_length = match_length ; new_match -> prev = NULL ; new_match -> next = NULL ; FAIL_ON_ERROR ( _yr_scan_add_match_to_list ( new_match , & string -> matches [ tidx ] , STRING_IS_GREEDY_REGEXP ( string ) ) ) ; } } return result ; }\n","target":"<S2SV_ModStart> callback_args -> forward_matches ; assert ( match_offset + match_length <= callback_args -> data_size )\n","project_and_commit_id":"VirusTotal@yara/992480c30f75943e9cd6245bb2015c7737f9b661","cve_id":"CVE-2017-9465","original_address":"https://github.com/VirusTotal/yara/commit/992480c30f75943e9cd6245bb2015c7737f9b661","time":"2017-06-06T21:29Z"},
	{"Unnamed: 0":4830,"cwe_id":"CWE-416","source":"CWE-416 <S2SV_StartBug> static struct ion_handle * ion_handle_get_by_id ( struct ion_client * client , <S2SV_EndBug> int id ) { struct ion_handle * handle ; mutex_lock ( & client -> lock ) ; <S2SV_StartBug> handle = idr_find ( & client -> idr , id ) ; <S2SV_EndBug> if ( handle ) ion_handle_get ( handle ) ; mutex_unlock ( & client -> lock ) ; <S2SV_StartBug> return handle ? handle : ERR_PTR ( - EINVAL ) ; <S2SV_EndBug> }\n","target":"<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_ModEnd> struct ion_handle * <S2SV_ModStart> ; handle = ion_handle_get_by_id_nolock ( client , id <S2SV_ModEnd> ) ; mutex_unlock <S2SV_ModStart> ; return handle <S2SV_ModEnd> ; } <S2SV_null>\n","project_and_commit_id":"torvalds@linux/9590232bb4f4cc824f3425a6e1349afbe6d6d2b7","cve_id":"CVE-2016-9120","original_address":"https://github.com/torvalds/linux/commit/9590232bb4f4cc824f3425a6e1349afbe6d6d2b7","time":"2016-12-08T21:59Z"},
	{"Unnamed: 0":334,"cwe_id":"CWE-552","source":"CWE-552 static ssize_t _epoll_readv ( oe_fd_t * desc , const struct oe_iovec * iov , int iovcnt ) { ssize_t ret = - 1 ; epoll_t * file = _cast_epoll ( desc ) ; void * buf = NULL ; size_t buf_size = 0 ; <S2SV_StartBug> if ( ! file || ( iovcnt && ! iov ) || iovcnt < 0 || iovcnt > OE_IOV_MAX ) <S2SV_EndBug> OE_RAISE_ERRNO ( OE_EINVAL ) ; <S2SV_StartBug> if ( oe_iov_pack ( iov , iovcnt , & buf , & buf_size ) != 0 ) <S2SV_EndBug> <S2SV_StartBug> OE_RAISE_ERRNO ( OE_ENOMEM ) ; <S2SV_EndBug> if ( oe_syscall_readv_ocall ( & ret , file -> host_fd , buf , iovcnt , buf_size ) != OE_OK ) { OE_RAISE_ERRNO ( OE_EINVAL ) ; } <S2SV_StartBug> if ( oe_iov_sync ( iov , iovcnt , buf , buf_size ) != 0 ) <S2SV_EndBug> OE_RAISE_ERRNO ( OE_EINVAL ) ; done : if ( buf ) oe_free ( buf ) ; return ret ; }\n","target":"<S2SV_ModStart> = 0 ; size_t data_size = 0 ; <S2SV_ModStart> , & buf_size , & data_size <S2SV_ModStart> OE_RAISE_ERRNO ( OE_ENOMEM ) ; if ( data_size > OE_SSIZE_MAX ) OE_RAISE_ERRNO ( OE_EINVAL <S2SV_ModStart> } if ( ret > ( ssize_t ) data_size ) { ret = - 1 ; OE_RAISE_ERRNO ( OE_EINVAL ) ; } if (\n","project_and_commit_id":"openenclave@openenclave/bcac8e7acb514429fee9e0b5d0c7a0308fd4d76b","cve_id":"CVE-2020-15224","original_address":"https://github.com/openenclave/openenclave/commit/bcac8e7acb514429fee9e0b5d0c7a0308fd4d76b","time":"2020-10-14T19:15Z"},
	{"Unnamed: 0":5466,"cwe_id":"CWE-399","source":"CWE-399 static void call_bind_status ( struct rpc_task * task ) { int status = - EIO ; if ( task -> tk_status >= 0 ) { dprint_status ( task ) ; task -> tk_status = 0 ; task -> tk_action = call_connect ; return ; } switch ( task -> tk_status ) { case - ENOMEM : dprintk ( \"RPC:<S2SV_blank>%5u<S2SV_blank>rpcbind<S2SV_blank>out<S2SV_blank>of<S2SV_blank>memory\\\\n\" , task -> tk_pid ) ; rpc_delay ( task , HZ >> 2 ) ; goto retry_timeout ; case - EACCES : dprintk ( \"RPC:<S2SV_blank>%5u<S2SV_blank>remote<S2SV_blank>rpcbind:<S2SV_blank>RPC<S2SV_blank>program/version<S2SV_blank>\" \"unavailable\\\\n\" , task -> tk_pid ) ; if ( task -> tk_msg . rpc_proc -> p_proc == 0 ) { status = - EOPNOTSUPP ; break ; } <S2SV_StartBug> rpc_delay ( task , 3 * HZ ) ; <S2SV_EndBug> goto retry_timeout ; case - ETIMEDOUT : dprintk ( \"RPC:<S2SV_blank>%5u<S2SV_blank>rpcbind<S2SV_blank>request<S2SV_blank>timed<S2SV_blank>out\\\\n\" , task -> tk_pid ) ; goto retry_timeout ; case - EPFNOSUPPORT : dprintk ( \"RPC:<S2SV_blank>%5u<S2SV_blank>unrecognized<S2SV_blank>remote<S2SV_blank>rpcbind<S2SV_blank>service\\\\n\" , task -> tk_pid ) ; break ; case - EPROTONOSUPPORT : dprintk ( \"RPC:<S2SV_blank>%5u<S2SV_blank>remote<S2SV_blank>rpcbind<S2SV_blank>version<S2SV_blank>unavailable,<S2SV_blank>retrying\\\\n\" , task -> tk_pid ) ; task -> tk_status = 0 ; task -> tk_action = call_bind ; return ; case - ECONNREFUSED : case - ECONNRESET : case - ENOTCONN : case - EHOSTDOWN : case - EHOSTUNREACH : case - ENETUNREACH : case - EPIPE : dprintk ( \"RPC:<S2SV_blank>%5u<S2SV_blank>remote<S2SV_blank>rpcbind<S2SV_blank>unreachable:<S2SV_blank>%d\\\\n\" , task -> tk_pid , task -> tk_status ) ; if ( ! RPC_IS_SOFTCONN ( task ) ) { rpc_delay ( task , 5 * HZ ) ; goto retry_timeout ; } status = task -> tk_status ; break ; default : dprintk ( \"RPC:<S2SV_blank>%5u<S2SV_blank>unrecognized<S2SV_blank>rpcbind<S2SV_blank>error<S2SV_blank>(%d)\\\\n\" , task -> tk_pid , - task -> tk_status ) ; } rpc_exit ( task , status ) ; return ; retry_timeout : task -> tk_action = call_timeout ; }\n","target":"<S2SV_ModStart> break ; } if ( task -> tk_rebind_retry == 0 ) break ; task -> tk_rebind_retry -- ;\n","project_and_commit_id":"torvalds@linux/0b760113a3a155269a3fba93a409c640031dd68f","cve_id":"CVE-2011-2491","original_address":"https://github.com/torvalds/linux/commit/0b760113a3a155269a3fba93a409c640031dd68f","time":"2013-03-01T12:37Z"},
	{"Unnamed: 0":1345,"cwe_id":"CWE-399","source":"CWE-399 static void do_local_notify ( xmlNode * notify_src , const char * client_id , gboolean sync_reply , gboolean from_peer ) { cib_client_t * client_obj = NULL ; int local_rc = pcmk_ok ; if ( client_id != NULL ) { client_obj = g_hash_table_lookup ( client_list , client_id ) ; } else { crm_trace ( \"No<S2SV_blank>client<S2SV_blank>to<S2SV_blank>sent<S2SV_blank>the<S2SV_blank>response<S2SV_blank>to.<S2SV_blank>F_CIB_CLIENTID<S2SV_blank>not<S2SV_blank>set.\" ) ; } if ( client_obj == NULL ) { local_rc = - ECONNRESET ; } else { int rid = 0 ; if ( sync_reply ) { <S2SV_StartBug> CRM_LOG_ASSERT ( client_obj -> request_id ) ; <S2SV_EndBug> rid = client_obj -> request_id ; client_obj -> request_id = 0 ; crm_trace ( \"Sending<S2SV_blank>response<S2SV_blank>%d<S2SV_blank>to<S2SV_blank>%s<S2SV_blank>%s\" , <S2SV_StartBug> rid , client_obj -> name , from_peer ? \"(originator<S2SV_blank>of<S2SV_blank>delegated<S2SV_blank>request)\" : \"\" ) ; <S2SV_EndBug> } else { crm_trace ( \"Sending<S2SV_blank>an<S2SV_blank>event<S2SV_blank>to<S2SV_blank>%s<S2SV_blank>%s\" , client_obj -> name , from_peer ? \"(originator<S2SV_blank>of<S2SV_blank>delegated<S2SV_blank>request)\" : \"\" ) ; } if ( client_obj -> ipc && crm_ipcs_send ( client_obj -> ipc , rid , notify_src , ! sync_reply ) < 0 ) { local_rc = - ENOMSG ; # ifdef HAVE_GNUTLS_GNUTLS_H } else if ( client_obj -> session ) { crm_send_remote_msg ( client_obj -> session , notify_src , client_obj -> encrypted ) ; # endif } else if ( client_obj -> ipc == NULL ) { crm_err ( \"Unknown<S2SV_blank>transport<S2SV_blank>for<S2SV_blank>%s\" , client_obj -> name ) ; } } if ( local_rc != pcmk_ok && client_obj != NULL ) { crm_warn ( \"%sSync<S2SV_blank>reply<S2SV_blank>to<S2SV_blank>%s<S2SV_blank>failed:<S2SV_blank>%s\" , sync_reply ? \"\" : \"A-\" , client_obj ? client_obj -> name : \"<unknown>\" , pcmk_strerror ( local_rc ) ) ; } }\n","target":"<S2SV_ModStart> sync_reply ) { if ( client_obj -> ipc ) { <S2SV_ModStart> \"\" ) ; } else { crm_trace ( \"Sending<S2SV_blank>response<S2SV_blank>to<S2SV_blank>%s<S2SV_blank>%s\" , client_obj -> name , from_peer ? \"(originator<S2SV_blank>of<S2SV_blank>delegated<S2SV_blank>request)\" : \"\" ) ; }\n","project_and_commit_id":"ClusterLabs@pacemaker/564f7cc2a51dcd2f28ab12a13394f31be5aa3c93","cve_id":"CVE-2013-0281","original_address":"https://github.com/ClusterLabs/pacemaker/commit/564f7cc2a51dcd2f28ab12a13394f31be5aa3c93","time":"2013-11-23T11:55Z"},
	{"Unnamed: 0":2189,"cwe_id":"CWE-674","source":"CWE-674 static int renameUnmapSelectCb ( Walker * pWalker , Select * p ) { Parse * pParse = pWalker -> pParse ; int i ; if ( pParse -> nErr ) return WRC_Abort ; <S2SV_StartBug> if ( ALWAYS ( p -> pEList ) ) { <S2SV_EndBug> ExprList * pList = p -> pEList ; for ( i = 0 ; i < pList -> nExpr ; i ++ ) { if ( pList -> a [ i ] . zName ) { sqlite3RenameTokenRemap ( pParse , 0 , ( void * ) pList -> a [ i ] . zName ) ; } } } if ( ALWAYS ( p -> pSrc ) ) { SrcList * pSrc = p -> pSrc ; for ( i = 0 ; i < pSrc -> nSrc ; i ++ ) { sqlite3RenameTokenRemap ( pParse , 0 , ( void * ) pSrc -> a [ i ] . zName ) ; } } renameWalkWith ( pWalker , p ) ; return WRC_Continue ; }\n","target":"<S2SV_ModStart> ; if ( p -> selFlags & SF_View ) return WRC_Prune ; if (\n","project_and_commit_id":"sqlite@sqlite/38096961c7cd109110ac21d3ed7dad7e0cb0ae06","cve_id":"CVE-2019-19645","original_address":"https://github.com/sqlite/sqlite/commit/38096961c7cd109110ac21d3ed7dad7e0cb0ae06","time":"2019-12-09T16:15Z"},
	{"Unnamed: 0":5099,"cwe_id":"CWE-119","source":"CWE-119 static int iwl_process_add_sta_resp ( struct iwl_priv * priv , struct iwl_addsta_cmd * addsta , struct iwl_rx_packet * pkt ) { u8 sta_id = addsta -> sta . sta_id ; unsigned long flags ; int ret = - EIO ; if ( pkt -> hdr . flags & IWL_CMD_FAILED_MSK ) { IWL_ERR ( priv , \"Bad<S2SV_blank>return<S2SV_blank>from<S2SV_blank>REPLY_ADD_STA<S2SV_blank>(0x%08X)\\\\n\" , pkt -> hdr . flags ) ; return ret ; } IWL_DEBUG_INFO ( priv , \"Processing<S2SV_blank>response<S2SV_blank>for<S2SV_blank>adding<S2SV_blank>station<S2SV_blank>%u\\\\n\" , sta_id ) ; spin_lock_irqsave ( & priv -> shrd -> sta_lock , flags ) ; switch ( pkt -> u . add_sta . status ) { case ADD_STA_SUCCESS_MSK : IWL_DEBUG_INFO ( priv , \"REPLY_ADD_STA<S2SV_blank>PASSED\\\\n\" ) ; <S2SV_StartBug> iwl_sta_ucode_activate ( priv , sta_id ) ; <S2SV_EndBug> ret = 0 ; break ; case ADD_STA_NO_ROOM_IN_TABLE : IWL_ERR ( priv , \"Adding<S2SV_blank>station<S2SV_blank>%d<S2SV_blank>failed,<S2SV_blank>no<S2SV_blank>room<S2SV_blank>in<S2SV_blank>table.\\\\n\" , sta_id ) ; break ; case ADD_STA_NO_BLOCK_ACK_RESOURCE : IWL_ERR ( priv , \"Adding<S2SV_blank>station<S2SV_blank>%d<S2SV_blank>failed,<S2SV_blank>no<S2SV_blank>block<S2SV_blank>ack<S2SV_blank>\" \"resource.\\\\n\" , sta_id ) ; break ; case ADD_STA_MODIFY_NON_EXIST_STA : IWL_ERR ( priv , \"Attempting<S2SV_blank>to<S2SV_blank>modify<S2SV_blank>non-existing<S2SV_blank>station<S2SV_blank>%d\\\\n\" , sta_id ) ; break ; default : IWL_DEBUG_ASSOC ( priv , \"Received<S2SV_blank>REPLY_ADD_STA:(0x%08X)\\\\n\" , pkt -> u . add_sta . status ) ; break ; } IWL_DEBUG_INFO ( priv , \"%s<S2SV_blank>station<S2SV_blank>id<S2SV_blank>%u<S2SV_blank>addr<S2SV_blank>%pM\\\\n\" , priv -> stations [ sta_id ] . sta . mode == STA_CONTROL_MODIFY_MSK ? \"Modified\" : \"Added\" , sta_id , priv -> stations [ sta_id ] . sta . sta . addr ) ; IWL_DEBUG_INFO ( priv , \"%s<S2SV_blank>station<S2SV_blank>according<S2SV_blank>to<S2SV_blank>cmd<S2SV_blank>buffer<S2SV_blank>%pM\\\\n\" , priv -> stations [ sta_id ] . sta . mode == STA_CONTROL_MODIFY_MSK ? \"Modified\" : \"Added\" , addsta -> sta . addr ) ; spin_unlock_irqrestore ( & priv -> shrd -> sta_lock , flags ) ; return ret ; }\n","target":"<S2SV_ModStart> \"REPLY_ADD_STA<S2SV_blank>PASSED\\\\n\" ) ; ret = iwl_sta_ucode_activate ( priv , sta_id ) <S2SV_ModEnd> ; break ;\n","project_and_commit_id":"torvalds@linux/2da424b0773cea3db47e1e81db71eeebde8269d4","cve_id":"CVE-2012-6712","original_address":"https://github.com/torvalds/linux/commit/2da424b0773cea3db47e1e81db71eeebde8269d4","time":"2019-07-27T22:15Z"},
	{"Unnamed: 0":558,"cwe_id":"CWE-264","source":"CWE-264 static struct mnt_namespace * dup_mnt_ns ( struct mnt_namespace * mnt_ns , struct user_namespace * user_ns , struct fs_struct * fs ) { struct mnt_namespace * new_ns ; struct vfsmount * rootmnt = NULL , * pwdmnt = NULL ; struct mount * p , * q ; struct mount * old = mnt_ns -> root ; struct mount * new ; int copy_flags ; new_ns = alloc_mnt_ns ( user_ns ) ; if ( IS_ERR ( new_ns ) ) return new_ns ; down_write ( & namespace_sem ) ; copy_flags = CL_COPY_ALL | CL_EXPIRE ; if ( user_ns != mnt_ns -> user_ns ) <S2SV_StartBug> copy_flags |= CL_SHARED_TO_SLAVE ; <S2SV_EndBug> new = copy_tree ( old , old -> mnt . mnt_root , copy_flags ) ; if ( IS_ERR ( new ) ) { up_write ( & namespace_sem ) ; free_mnt_ns ( new_ns ) ; return ERR_CAST ( new ) ; } new_ns -> root = new ; br_write_lock ( & vfsmount_lock ) ; list_add_tail ( & new_ns -> list , & new -> mnt_list ) ; br_write_unlock ( & vfsmount_lock ) ; p = old ; q = new ; while ( p ) { q -> mnt_ns = new_ns ; if ( fs ) { if ( & p -> mnt == fs -> root . mnt ) { fs -> root . mnt = mntget ( & q -> mnt ) ; rootmnt = & p -> mnt ; } if ( & p -> mnt == fs -> pwd . mnt ) { fs -> pwd . mnt = mntget ( & q -> mnt ) ; pwdmnt = & p -> mnt ; } } p = next_mnt ( p , old ) ; q = next_mnt ( q , new ) ; } up_write ( & namespace_sem ) ; if ( rootmnt ) mntput ( rootmnt ) ; if ( pwdmnt ) mntput ( pwdmnt ) ; return new_ns ; }\n","target":"<S2SV_ModStart> copy_flags |= CL_SHARED_TO_SLAVE | CL_UNPRIVILEGED\n","project_and_commit_id":"torvalds@linux/132c94e31b8bca8ea921f9f96a57d684fa4ae0a9","cve_id":"CVE-2013-1957","original_address":"https://github.com/torvalds/linux/commit/132c94e31b8bca8ea921f9f96a57d684fa4ae0a9","time":"2013-04-24T19:55Z"},
	{"Unnamed: 0":4384,"cwe_id":"CWE-362","source":"CWE-362 int ext4_setattr ( struct dentry * dentry , struct iattr * attr ) { struct inode * inode = d_inode ( dentry ) ; int error , rc = 0 ; int orphan = 0 ; const unsigned int ia_valid = attr -> ia_valid ; error = inode_change_ok ( inode , attr ) ; if ( error ) return error ; if ( is_quota_modification ( inode , attr ) ) { error = dquot_initialize ( inode ) ; if ( error ) return error ; } if ( ( ia_valid & ATTR_UID && ! uid_eq ( attr -> ia_uid , inode -> i_uid ) ) || ( ia_valid & ATTR_GID && ! gid_eq ( attr -> ia_gid , inode -> i_gid ) ) ) { handle_t * handle ; handle = ext4_journal_start ( inode , EXT4_HT_QUOTA , ( EXT4_MAXQUOTAS_INIT_BLOCKS ( inode -> i_sb ) + EXT4_MAXQUOTAS_DEL_BLOCKS ( inode -> i_sb ) ) + 3 ) ; if ( IS_ERR ( handle ) ) { error = PTR_ERR ( handle ) ; goto err_out ; } error = dquot_transfer ( inode , attr ) ; if ( error ) { ext4_journal_stop ( handle ) ; return error ; } if ( attr -> ia_valid & ATTR_UID ) inode -> i_uid = attr -> ia_uid ; if ( attr -> ia_valid & ATTR_GID ) inode -> i_gid = attr -> ia_gid ; error = ext4_mark_inode_dirty ( handle , inode ) ; ext4_journal_stop ( handle ) ; } if ( attr -> ia_valid & ATTR_SIZE ) { handle_t * handle ; loff_t oldsize = inode -> i_size ; int shrink = ( attr -> ia_size <= inode -> i_size ) ; if ( ! ( ext4_test_inode_flag ( inode , EXT4_INODE_EXTENTS ) ) ) { struct ext4_sb_info * sbi = EXT4_SB ( inode -> i_sb ) ; if ( attr -> ia_size > sbi -> s_bitmap_maxbytes ) return - EFBIG ; } if ( ! S_ISREG ( inode -> i_mode ) ) return - EINVAL ; if ( IS_I_VERSION ( inode ) && attr -> ia_size != inode -> i_size ) inode_inc_iversion ( inode ) ; if ( ext4_should_order_data ( inode ) && ( attr -> ia_size < inode -> i_size ) ) { error = ext4_begin_ordered_truncate ( inode , attr -> ia_size ) ; if ( error ) goto err_out ; } if ( attr -> ia_size != inode -> i_size ) { handle = ext4_journal_start ( inode , EXT4_HT_INODE , 3 ) ; if ( IS_ERR ( handle ) ) { error = PTR_ERR ( handle ) ; goto err_out ; } if ( ext4_handle_valid ( handle ) && shrink ) { error = ext4_orphan_add ( handle , inode ) ; orphan = 1 ; } if ( ! shrink ) { inode -> i_mtime = ext4_current_time ( inode ) ; inode -> i_ctime = inode -> i_mtime ; } down_write ( & EXT4_I ( inode ) -> i_data_sem ) ; EXT4_I ( inode ) -> i_disksize = attr -> ia_size ; rc = ext4_mark_inode_dirty ( handle , inode ) ; if ( ! error ) error = rc ; if ( ! error ) i_size_write ( inode , attr -> ia_size ) ; up_write ( & EXT4_I ( inode ) -> i_data_sem ) ; ext4_journal_stop ( handle ) ; if ( error ) { if ( orphan ) ext4_orphan_del ( NULL , inode ) ; goto err_out ; } } if ( ! shrink ) pagecache_isize_extended ( inode , oldsize , inode -> i_size ) ; if ( orphan ) { if ( ! ext4_should_journal_data ( inode ) ) { ext4_inode_block_unlocked_dio ( inode ) ; inode_dio_wait ( inode ) ; ext4_inode_resume_unlocked_dio ( inode ) ; } else ext4_wait_for_tail_page_commit ( inode ) ; } <S2SV_StartBug> truncate_pagecache ( inode , inode -> i_size ) ; <S2SV_EndBug> if ( shrink ) <S2SV_StartBug> ext4_truncate ( inode ) ; <S2SV_EndBug> } if ( ! rc ) { setattr_copy ( inode , attr ) ; mark_inode_dirty ( inode ) ; } if ( orphan && inode -> i_nlink ) ext4_orphan_del ( NULL , inode ) ; if ( ! rc && ( ia_valid & ATTR_MODE ) ) rc = posix_acl_chmod ( inode , inode -> i_mode ) ; err_out : ext4_std_error ( inode -> i_sb , error ) ; if ( ! error ) error = rc ; return error ; }\n","target":"<S2SV_ModStart> ) ; } down_write ( & EXT4_I ( inode ) -> i_mmap_sem ) ; <S2SV_ModStart> ext4_truncate ( inode ) ; up_write ( & EXT4_I ( inode ) -> i_mmap_sem\n","project_and_commit_id":"torvalds@linux/ea3d7209ca01da209cda6f0dea8be9cc4b7a933b","cve_id":"CVE-2015-8839","original_address":"https://github.com/torvalds/linux/commit/ea3d7209ca01da209cda6f0dea8be9cc4b7a933b","time":"2016-05-02T10:59Z"},
	{"Unnamed: 0":4852,"cwe_id":"CWE-000","source":"CWE-000 static void sas_eh_finish_cmd ( struct scsi_cmnd * cmd ) { struct sas_ha_struct * sas_ha = SHOST_TO_SAS_HA ( cmd -> device -> host ) ; <S2SV_StartBug> struct sas_task * task = TO_SAS_TASK ( cmd ) ; <S2SV_EndBug> sas_end_task ( cmd , task ) ; <S2SV_StartBug> scsi_eh_finish_cmd ( cmd , & sas_ha -> eh_done_q ) ; <S2SV_EndBug> }\n","target":"<S2SV_ModStart> ) ; struct domain_device * dev = cmd_to_domain_dev ( cmd ) ; struct <S2SV_ModStart> task ) ; if ( dev_is_sata ( dev ) ) { list_move_tail ( & cmd -> eh_entry , & sas_ha -> eh_ata_q ) ; return ; }\n","project_and_commit_id":"torvalds@linux/318aaf34f1179b39fa9c30fa0f3288b645beee39","cve_id":"CVE-2018-10021","original_address":"https://github.com/torvalds/linux/commit/318aaf34f1179b39fa9c30fa0f3288b645beee39","time":"2018-04-11T17:29Z"},
	{"Unnamed: 0":3090,"cwe_id":"CWE-125","source":"CWE-125 static const u_char * ikev1_n_print ( netdissect_options * ndo , u_char tpay _U_ , const struct isakmp_gen * ext , u_int item_len , const u_char * ep , uint32_t phase _U_ , uint32_t doi0 _U_ , uint32_t proto0 _U_ , int depth _U_ ) { const struct ikev1_pl_n * p ; struct ikev1_pl_n n ; const u_char * cp ; const u_char * ep2 ; uint32_t doi ; uint32_t proto ; static const char * notify_error_str [ ] = { NULL , \"INVALID-PAYLOAD-TYPE\" , \"DOI-NOT-SUPPORTED\" , \"SITUATION-NOT-SUPPORTED\" , \"INVALID-COOKIE\" , \"INVALID-MAJOR-VERSION\" , \"INVALID-MINOR-VERSION\" , \"INVALID-EXCHANGE-TYPE\" , \"INVALID-FLAGS\" , \"INVALID-MESSAGE-ID\" , \"INVALID-PROTOCOL-ID\" , \"INVALID-SPI\" , \"INVALID-TRANSFORM-ID\" , \"ATTRIBUTES-NOT-SUPPORTED\" , \"NO-PROPOSAL-CHOSEN\" , \"BAD-PROPOSAL-SYNTAX\" , \"PAYLOAD-MALFORMED\" , \"INVALID-KEY-INFORMATION\" , \"INVALID-ID-INFORMATION\" , \"INVALID-CERT-ENCODING\" , \"INVALID-CERTIFICATE\" , \"CERT-TYPE-UNSUPPORTED\" , \"INVALID-CERT-AUTHORITY\" , \"INVALID-HASH-INFORMATION\" , \"AUTHENTICATION-FAILED\" , \"INVALID-SIGNATURE\" , \"ADDRESS-NOTIFICATION\" , \"NOTIFY-SA-LIFETIME\" , \"CERTIFICATE-UNAVAILABLE\" , \"UNSUPPORTED-EXCHANGE-TYPE\" , \"UNEQUAL-PAYLOAD-LENGTHS\" , } ; static const char * ipsec_notify_error_str [ ] = { \"RESERVED\" , } ; static const char * notify_status_str [ ] = { \"CONNECTED\" , } ; static const char * ipsec_notify_status_str [ ] = { \"RESPONDER-LIFETIME\" , \"REPLAY-STATUS\" , \"INITIAL-CONTACT\" , } ; # define NOTIFY_ERROR_STR ( x ) STR_OR_ID ( ( x ) , notify_error_str ) # define IPSEC_NOTIFY_ERROR_STR ( x ) STR_OR_ID ( ( u_int ) ( ( x ) - 8192 ) , ipsec_notify_error_str ) # define NOTIFY_STATUS_STR ( x ) STR_OR_ID ( ( u_int ) ( ( x ) - 16384 ) , notify_status_str ) # define IPSEC_NOTIFY_STATUS_STR ( x ) STR_OR_ID ( ( u_int ) ( ( x ) - 24576 ) , ipsec_notify_status_str ) ND_PRINT ( ( ndo , \"%s:\" , NPSTR ( ISAKMP_NPTYPE_N ) ) ) ; p = ( const struct ikev1_pl_n * ) ext ; ND_TCHECK ( * p ) ; UNALIGNED_MEMCPY ( & n , ext , sizeof ( n ) ) ; doi = ntohl ( n . doi ) ; proto = n . prot_id ; if ( doi != 1 ) { ND_PRINT ( ( ndo , \"<S2SV_blank>doi=%d\" , doi ) ) ; ND_PRINT ( ( ndo , \"<S2SV_blank>proto=%d\" , proto ) ) ; if ( ntohs ( n . type ) < 8192 ) ND_PRINT ( ( ndo , \"<S2SV_blank>type=%s\" , NOTIFY_ERROR_STR ( ntohs ( n . type ) ) ) ) ; else if ( ntohs ( n . type ) < 16384 ) ND_PRINT ( ( ndo , \"<S2SV_blank>type=%s\" , numstr ( ntohs ( n . type ) ) ) ) ; else if ( ntohs ( n . type ) < 24576 ) ND_PRINT ( ( ndo , \"<S2SV_blank>type=%s\" , NOTIFY_STATUS_STR ( ntohs ( n . type ) ) ) ) ; else ND_PRINT ( ( ndo , \"<S2SV_blank>type=%s\" , numstr ( ntohs ( n . type ) ) ) ) ; if ( n . spi_size ) { ND_PRINT ( ( ndo , \"<S2SV_blank>spi=\" ) ) ; if ( ! rawprint ( ndo , ( const uint8_t * ) ( p + 1 ) , n . spi_size ) ) goto trunc ; } return ( const u_char * ) ( p + 1 ) + n . spi_size ; } ND_PRINT ( ( ndo , \"<S2SV_blank>doi=ipsec\" ) ) ; ND_PRINT ( ( ndo , \"<S2SV_blank>proto=%s\" , PROTOIDSTR ( proto ) ) ) ; if ( ntohs ( n . type ) < 8192 ) ND_PRINT ( ( ndo , \"<S2SV_blank>type=%s\" , NOTIFY_ERROR_STR ( ntohs ( n . type ) ) ) ) ; else if ( ntohs ( n . type ) < 16384 ) ND_PRINT ( ( ndo , \"<S2SV_blank>type=%s\" , IPSEC_NOTIFY_ERROR_STR ( ntohs ( n . type ) ) ) ) ; else if ( ntohs ( n . type ) < 24576 ) ND_PRINT ( ( ndo , \"<S2SV_blank>type=%s\" , NOTIFY_STATUS_STR ( ntohs ( n . type ) ) ) ) ; else if ( ntohs ( n . type ) < 32768 ) ND_PRINT ( ( ndo , \"<S2SV_blank>type=%s\" , IPSEC_NOTIFY_STATUS_STR ( ntohs ( n . type ) ) ) ) ; else ND_PRINT ( ( ndo , \"<S2SV_blank>type=%s\" , numstr ( ntohs ( n . type ) ) ) ) ; if ( n . spi_size ) { ND_PRINT ( ( ndo , \"<S2SV_blank>spi=\" ) ) ; if ( ! rawprint ( ndo , ( const uint8_t * ) ( p + 1 ) , n . spi_size ) ) goto trunc ; } cp = ( const u_char * ) ( p + 1 ) + n . spi_size ; ep2 = ( const u_char * ) p + item_len ; if ( cp < ep ) { switch ( ntohs ( n . type ) ) { case IPSECDOI_NTYPE_RESPONDER_LIFETIME : { const struct attrmap * map = oakley_t_map ; size_t nmap = sizeof ( oakley_t_map ) / sizeof ( oakley_t_map [ 0 ] ) ; ND_PRINT ( ( ndo , \"<S2SV_blank>attrs=(\" ) ) ; while ( cp < ep && cp < ep2 ) { cp = ikev1_attrmap_print ( ndo , cp , <S2SV_StartBug> ( ep < ep2 ) ? ep : ep2 , map , nmap ) ; <S2SV_EndBug> } ND_PRINT ( ( ndo , \")\" ) ) ; break ; } case IPSECDOI_NTYPE_REPLAY_STATUS : ND_PRINT ( ( ndo , \"<S2SV_blank>status=(\" ) ) ; ND_PRINT ( ( ndo , \"replay<S2SV_blank>detection<S2SV_blank>%sabled\" , EXTRACT_32BITS ( cp ) ? \"en\" : \"dis\" ) ) ; ND_PRINT ( ( ndo , \")\" ) ) ; break ; default : if ( ndo -> ndo_vflag > 3 ) { ND_PRINT ( ( ndo , \"<S2SV_blank>data=(\" ) ) ; if ( ! rawprint ( ndo , ( const uint8_t * ) ( cp ) , ep - cp ) ) goto trunc ; ND_PRINT ( ( ndo , \")\" ) ) ; } else { if ( ! ike_show_somedata ( ndo , cp , ep ) ) goto trunc ; } break ; } } return ( const u_char * ) ext + item_len ; trunc : ND_PRINT ( ( ndo , \"<S2SV_blank>[|%s]\" , NPSTR ( ISAKMP_NPTYPE_N ) ) ) ; return NULL ; }\n","target":"<S2SV_ModStart> , cp , ep2 <S2SV_ModEnd> , map , <S2SV_ModStart> nmap ) ; if ( cp == NULL ) { ND_PRINT ( ( ndo , \")\" ) ) ; goto trunc ; }\n","project_and_commit_id":"the-tcpdump-group@tcpdump/e0a5a02b0fc1900a69d6c37ed0aab36fb8494e6d","cve_id":"CVE-2017-13039","original_address":"https://github.com/the-tcpdump-group/tcpdump/commit/e0a5a02b0fc1900a69d6c37ed0aab36fb8494e6d","time":"2017-09-14T06:29Z"},
	{"Unnamed: 0":2370,"cwe_id":"CWE-125","source":"CWE-125 static void sycc444_to_rgb ( opj_image_t * img ) { int * d0 , * d1 , * d2 , * r , * g , * b ; const int * y , * cb , * cr ; <S2SV_StartBug> unsigned int maxw , maxh , max , i ; <S2SV_EndBug> int offset , upb ; upb = ( int ) img -> comps [ 0 ] . prec ; offset = 1 << ( upb - 1 ) ; upb = ( 1 << upb ) - 1 ; <S2SV_StartBug> maxw = ( unsigned int ) img -> comps [ 0 ] . w ; maxh = ( unsigned int ) img -> comps [ 0 ] . h ; <S2SV_EndBug> max = maxw * maxh ; y = img -> comps [ 0 ] . data ; cb = img -> comps [ 1 ] . data ; cr = img -> comps [ 2 ] . data ; <S2SV_StartBug> d0 = r = ( int * ) malloc ( sizeof ( int ) * ( size_t ) max ) ; <S2SV_EndBug> <S2SV_StartBug> d1 = g = ( int * ) malloc ( sizeof ( int ) * ( size_t ) max ) ; <S2SV_EndBug> <S2SV_StartBug> d2 = b = ( int * ) malloc ( sizeof ( int ) * ( size_t ) max ) ; <S2SV_EndBug> if ( r == NULL || g == NULL || b == NULL ) goto fails ; for ( i = 0U ; i < max ; ++ i ) { sycc_to_rgb ( offset , upb , * y , * cb , * cr , r , g , b ) ; ++ y ; ++ cb ; ++ cr ; ++ r ; ++ g ; ++ b ; } free ( img -> comps [ 0 ] . data ) ; img -> comps [ 0 ] . data = d0 ; free ( img -> comps [ 1 ] . data ) ; img -> comps [ 1 ] . data = d1 ; free ( img -> comps [ 2 ] . data ) ; img -> comps [ 2 ] . data = d2 ; <S2SV_StartBug> return ; <S2SV_EndBug> fails : <S2SV_StartBug> if ( r ) free ( r ) ; <S2SV_EndBug> if ( g ) free ( g ) ; if ( b ) free ( b ) ; }\n","target":"<S2SV_ModStart> * cr ; size_t <S2SV_ModEnd> maxw , maxh <S2SV_ModStart> maxw = ( size_t <S2SV_ModEnd> ) img -> <S2SV_ModStart> maxh = ( size_t <S2SV_ModEnd> ) img -> <S2SV_ModStart> int ) * <S2SV_ModEnd> max ) ; <S2SV_ModStart> int ) * <S2SV_ModEnd> max ) ; <S2SV_ModStart> int ) * <S2SV_ModEnd> max ) ; <S2SV_ModStart> = d2 ; img -> color_space = OPJ_CLRSPC_SRGB ; <S2SV_ModStart> ; fails : free ( r ) ; free ( g ) ; <S2SV_ModEnd> free ( b\n","project_and_commit_id":"uclouvain@openjpeg/15f081c89650dccee4aa4ae66f614c3fdb268767","cve_id":"CVE-2016-3183","original_address":"https://github.com/uclouvain/openjpeg/commit/15f081c89650dccee4aa4ae66f614c3fdb268767","time":"2017-02-03T16:59Z"},
	{"Unnamed: 0":4026,"cwe_id":"CWE-252","source":"CWE-252 static Image * ReadCALSImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { char filename [ MagickPathExtent ] , header [ MagickPathExtent ] , message [ MagickPathExtent ] ; FILE * file ; Image * image ; ImageInfo * read_info ; int c , unique_file ; MagickBooleanType status ; register ssize_t i ; unsigned long density , direction , height , orientation , pel_path , type , width ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickCoreSignature ) ; if ( image_info -> debug != MagickFalse ) ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , \"%s\" , image_info -> filename ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickCoreSignature ) ; image = AcquireImage ( image_info , exception ) ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } ( void ) memset ( header , 0 , sizeof ( header ) ) ; density = 0 ; direction = 0 ; orientation = 1 ; pel_path = 0 ; type = 1 ; width = 0 ; height = 0 ; for ( i = 0 ; i < 16 ; i ++ ) { if ( ReadBlob ( image , 128 , ( unsigned char * ) header ) != 128 ) break ; switch ( * header ) { case 'R' : case 'r' : { if ( LocaleNCompare ( header , \"rdensty:\" , 8 ) == 0 ) { ( void ) sscanf ( header + 8 , \"%lu\" , & density ) ; break ; } if ( LocaleNCompare ( header , \"rpelcnt:\" , 8 ) == 0 ) { ( void ) sscanf ( header + 8 , \"%lu,%lu\" , & width , & height ) ; break ; } if ( LocaleNCompare ( header , \"rorient:\" , 8 ) == 0 ) { ( void ) sscanf ( header + 8 , \"%lu,%lu\" , & pel_path , & direction ) ; if ( pel_path == 90 ) orientation = 5 ; else if ( pel_path == 180 ) orientation = 3 ; else if ( pel_path == 270 ) orientation = 7 ; if ( direction == 90 ) orientation ++ ; break ; } if ( LocaleNCompare ( header , \"rtype:\" , 6 ) == 0 ) { ( void ) sscanf ( header + 6 , \"%lu\" , & type ) ; break ; } break ; } } } file = ( FILE * ) NULL ; unique_file = AcquireUniqueFileResource ( filename ) ; if ( unique_file != - 1 ) file = fdopen ( unique_file , \"wb\" ) ; if ( ( unique_file == - 1 ) || ( file == ( FILE * ) NULL ) ) ThrowImageException ( FileOpenError , \"UnableToCreateTemporaryFile\" ) ; while ( ( c = ReadBlobByte ( image ) ) != EOF ) <S2SV_StartBug> ( void ) fputc ( c , file ) ; <S2SV_EndBug> ( void ) fclose ( file ) ; ( void ) CloseBlob ( image ) ; image = DestroyImage ( image ) ; read_info = CloneImageInfo ( image_info ) ; SetImageInfoBlob ( read_info , ( void * ) NULL , 0 ) ; ( void ) FormatLocaleString ( read_info -> filename , MagickPathExtent , \"group4:%s\" , filename ) ; ( void ) FormatLocaleString ( message , MagickPathExtent , \"%lux%lu\" , width , height ) ; ( void ) CloneString ( & read_info -> size , message ) ; ( void ) FormatLocaleString ( message , MagickPathExtent , \"%lu\" , density ) ; ( void ) CloneString ( & read_info -> density , message ) ; read_info -> orientation = ( OrientationType ) orientation ; image = ReadImage ( read_info , exception ) ; if ( image != ( Image * ) NULL ) { ( void ) CopyMagickString ( image -> filename , image_info -> filename , MagickPathExtent ) ; ( void ) CopyMagickString ( image -> magick_filename , image_info -> filename , MagickPathExtent ) ; ( void ) CopyMagickString ( image -> magick , \"CALS\" , MagickPathExtent ) ; } read_info = DestroyImageInfo ( read_info ) ; ( void ) RelinquishUniqueFileResource ( filename ) ; return ( image ) ; }\n","target":"<S2SV_ModStart> != EOF ) if ( <S2SV_ModEnd> fputc ( c <S2SV_ModStart> , file ) != c ) break\n","project_and_commit_id":"ImageMagick@ImageMagick/6b6bff054d569a77973f2140c0e86366e6168a6c","cve_id":"CVE-2018-16643","original_address":"https://github.com/ImageMagick/ImageMagick/commit/6b6bff054d569a77973f2140c0e86366e6168a6c","time":"2018-09-06T22:29Z"},
	{"Unnamed: 0":2834,"cwe_id":"CWE-119","source":"CWE-119 WORD32 ih264d_parse_nal_unit ( iv_obj_t * dec_hdl , ivd_video_decode_op_t * ps_dec_op , UWORD8 * pu1_buf , UWORD32 u4_length ) { dec_bit_stream_t * ps_bitstrm ; dec_struct_t * ps_dec = ( dec_struct_t * ) dec_hdl -> pv_codec_handle ; ivd_video_decode_ip_t * ps_dec_in = ( ivd_video_decode_ip_t * ) ps_dec -> pv_dec_in ; dec_slice_params_t * ps_cur_slice = ps_dec -> ps_cur_slice ; UWORD8 u1_first_byte , u1_nal_ref_idc ; UWORD8 u1_nal_unit_type ; WORD32 i_status = OK ; ps_bitstrm = ps_dec -> ps_bitstrm ; if ( pu1_buf ) { if ( u4_length ) { ps_dec_op -> u4_frame_decoded_flag = 0 ; ih264d_process_nal_unit ( ps_dec -> ps_bitstrm , pu1_buf , u4_length ) ; SWITCHOFFTRACE ; u1_first_byte = ih264d_get_bits_h264 ( ps_bitstrm , 8 ) ; if ( NAL_FORBIDDEN_BIT ( u1_first_byte ) ) { H264_DEC_DEBUG_PRINT ( \"\\\\nForbidden<S2SV_blank>bit<S2SV_blank>set<S2SV_blank>in<S2SV_blank>Nal<S2SV_blank>Unit,<S2SV_blank>Let\\'s<S2SV_blank>try\\\\n\" ) ; } <S2SV_StartBug> u1_nal_unit_type = NAL_UNIT_TYPE ( u1_first_byte ) ; <S2SV_EndBug> ps_dec -> u1_nal_unit_type = u1_nal_unit_type ; u1_nal_ref_idc = ( UWORD8 ) ( NAL_REF_IDC ( u1_first_byte ) ) ; switch ( u1_nal_unit_type ) { case SLICE_DATA_PARTITION_A_NAL : case SLICE_DATA_PARTITION_B_NAL : case SLICE_DATA_PARTITION_C_NAL : if ( ! ps_dec -> i4_decode_header ) ih264d_parse_slice_partition ( ps_dec , ps_bitstrm ) ; break ; case IDR_SLICE_NAL : case SLICE_NAL : DEBUG_THREADS_PRINTF ( \"Decoding<S2SV_blank><S2SV_blank>a<S2SV_blank>slice<S2SV_blank>NAL\\\\n\" ) ; if ( ! ps_dec -> i4_decode_header ) { if ( ps_dec -> i4_header_decoded == 3 ) { ps_dec -> u4_slice_start_code_found = 1 ; ih264d_rbsp_to_sodb ( ps_dec -> ps_bitstrm ) ; i_status = ih264d_parse_decode_slice ( ( UWORD8 ) ( u1_nal_unit_type == IDR_SLICE_NAL ) , u1_nal_ref_idc , ps_dec ) ; if ( ( ps_dec -> u4_first_slice_in_pic != 0 ) && ( ( ps_dec -> ps_dec_err_status -> u1_err_flag & REJECT_CUR_PIC ) == 0 ) ) { ps_dec -> u4_first_slice_in_pic = 1 ; } if ( i_status != OK ) { return i_status ; } } else { H264_DEC_DEBUG_PRINT ( \"\\\\nSlice<S2SV_blank>NAL<S2SV_blank>Supplied<S2SV_blank>but<S2SV_blank>no<S2SV_blank>header<S2SV_blank>has<S2SV_blank>been<S2SV_blank>supplied\\\\n\" ) ; } } break ; case SEI_NAL : if ( ! ps_dec -> i4_decode_header ) { ih264d_rbsp_to_sodb ( ps_dec -> ps_bitstrm ) ; i_status = ih264d_parse_sei_message ( ps_dec , ps_bitstrm ) ; if ( i_status != OK ) return i_status ; ih264d_parse_sei ( ps_dec , ps_bitstrm ) ; } break ; case SEQ_PARAM_NAL : ih264d_rbsp_to_sodb ( ps_dec -> ps_bitstrm ) ; i_status = ih264d_parse_sps ( ps_dec , ps_bitstrm ) ; if ( i_status == ERROR_INV_SPS_PPS_T ) return i_status ; if ( ! i_status ) ps_dec -> i4_header_decoded |= 0x1 ; break ; case PIC_PARAM_NAL : ih264d_rbsp_to_sodb ( ps_dec -> ps_bitstrm ) ; i_status = ih264d_parse_pps ( ps_dec , ps_bitstrm ) ; if ( i_status == ERROR_INV_SPS_PPS_T ) return i_status ; if ( ! i_status ) ps_dec -> i4_header_decoded |= 0x2 ; break ; case ACCESS_UNIT_DELIMITER_RBSP : if ( ! ps_dec -> i4_decode_header ) { ih264d_access_unit_delimiter_rbsp ( ps_dec ) ; } break ; case END_OF_STREAM_RBSP : if ( ! ps_dec -> i4_decode_header ) { ih264d_parse_end_of_stream ( ps_dec ) ; } break ; case FILLER_DATA_NAL : if ( ! ps_dec -> i4_decode_header ) { ih264d_parse_filler_data ( ps_dec , ps_bitstrm ) ; } break ; default : H264_DEC_DEBUG_PRINT ( \"\\\\nUnknown<S2SV_blank>NAL<S2SV_blank>type<S2SV_blank>%d\\\\n\" , u1_nal_unit_type ) ; break ; } } } return i_status ; }\n","target":"<S2SV_ModStart> u1_first_byte ) ; if ( ( ps_dec -> u2_total_mbs_coded != 0 ) && ( u1_nal_unit_type > IDR_SLICE_NAL ) ) { return ERROR_INCOMPLETE_FRAME ; }\n","project_and_commit_id":"external@libavc/a78887bcffbc2995cf9ed72e0697acf560875e9e","cve_id":"CVE-2016-3820","original_address":"https://android.googlesource.com/platform/external/libavc/+/a78887bcffbc2995cf9ed72e0697acf560875e9e","time":"2016-08-05T20:59Z"},
	{"Unnamed: 0":3800,"cwe_id":"CWE-835","source":"CWE-835 static long madvise_willneed ( struct vm_area_struct * vma , struct vm_area_struct * * prev , unsigned long start , unsigned long end ) { struct file * file = vma -> vm_file ; <S2SV_StartBug> # ifdef CONFIG_SWAP <S2SV_EndBug> if ( ! file ) { <S2SV_StartBug> * prev = vma ; <S2SV_EndBug> force_swapin_readahead ( vma , start , end ) ; return 0 ; } if ( shmem_mapping ( file -> f_mapping ) ) { <S2SV_StartBug> * prev = vma ; <S2SV_EndBug> force_shm_swapin_readahead ( vma , start , end , file -> f_mapping ) ; return 0 ; } # else if ( ! file ) return - EBADF ; # endif if ( IS_DAX ( file_inode ( file ) ) ) { return 0 ; } <S2SV_StartBug> * prev = vma ; <S2SV_EndBug> start = ( ( start - vma -> vm_start ) >> PAGE_SHIFT ) + vma -> vm_pgoff ; if ( end > vma -> vm_end ) end = vma -> vm_end ; end = ( ( end - vma -> vm_start ) >> PAGE_SHIFT ) + vma -> vm_pgoff ; force_page_cache_readahead ( file -> f_mapping , file , start , end - start ) ; return 0 ; }\n","target":"<S2SV_ModStart> -> vm_file ; * prev = vma ; <S2SV_ModStart> file ) { <S2SV_ModEnd> force_swapin_readahead ( vma <S2SV_ModStart> ) ) { <S2SV_ModEnd> force_shm_swapin_readahead ( vma <S2SV_ModStart> 0 ; } <S2SV_ModEnd> start = (\n","project_and_commit_id":"torvalds@linux/6ea8d958a2c95a1d514015d4e29ba21a8c0a1a91","cve_id":"CVE-2017-18208","original_address":"https://github.com/torvalds/linux/commit/6ea8d958a2c95a1d514015d4e29ba21a8c0a1a91","time":"2018-03-01T05:29Z"},
	{"Unnamed: 0":2802,"cwe_id":"CWE-119","source":"CWE-119 static Bool FFD_CanHandleURL ( GF_InputService * plug , const char * url ) { Bool has_audio , has_video ; s32 i ; AVFormatContext * ctx ; AVOutputFormat * fmt_out ; Bool ret = GF_FALSE ; <S2SV_StartBug> char * ext , szName [ 1000 ] , szExt [ 20 ] ; <S2SV_EndBug> const char * szExtList ; FFDemux * ffd ; if ( ! plug || ! url ) return GF_FALSE ; if ( ! strnicmp ( url , \"rtsp://\" , 7 ) ) return GF_FALSE ; if ( ! strnicmp ( url , \"rtspu://\" , 8 ) ) return GF_FALSE ; if ( ! strnicmp ( url , \"rtp://\" , 6 ) ) return GF_FALSE ; if ( ! strnicmp ( url , \"plato://\" , 8 ) ) return GF_FALSE ; if ( ! strnicmp ( url , \"udp://\" , 6 ) ) return GF_FALSE ; if ( ! strnicmp ( url , \"tcp://\" , 6 ) ) return GF_FALSE ; if ( ! strnicmp ( url , \"data:\" , 5 ) ) return GF_FALSE ; ffd = ( FFDemux * ) plug -> priv ; <S2SV_StartBug> strcpy ( szName , url ) ; <S2SV_EndBug> ext = strrchr ( szName , '#' ) ; if ( ext ) ext [ 0 ] = 0 ; ext = strrchr ( szName , '?' ) ; if ( ext ) ext [ 0 ] = 0 ; ext = strrchr ( szName , '.' ) ; if ( ext && strlen ( ext ) > 19 ) ext = NULL ; <S2SV_StartBug> if ( ext && strlen ( ext ) > 1 ) { <S2SV_EndBug> strcpy ( szExt , & ext [ 1 ] ) ; strlwr ( szExt ) ; # ifndef FFMPEG_DEMUX_ENABLE_MPEG2TS if ( strstr ( \"ts<S2SV_blank>m2t<S2SV_blank>mts<S2SV_blank>dmb<S2SV_blank>trp\" , szExt ) ) return GF_FALSE ; # endif if ( ! strcmp ( szExt , \"mp4\" ) || ! strcmp ( szExt , \"mpg4\" ) || ! strcmp ( szExt , \"m4a\" ) || ! strcmp ( szExt , \"m21\" ) || ! strcmp ( szExt , \"m4v\" ) || ! strcmp ( szExt , \"m4a\" ) || ! strcmp ( szExt , \"m4s\" ) || ! strcmp ( szExt , \"3gs\" ) || ! strcmp ( szExt , \"3gp\" ) || ! strcmp ( szExt , \"3gpp\" ) || ! strcmp ( szExt , \"3gp2\" ) || ! strcmp ( szExt , \"3g2\" ) || ! strcmp ( szExt , \"mp3\" ) || ! strcmp ( szExt , \"ac3\" ) || ! strcmp ( szExt , \"amr\" ) || ! strcmp ( szExt , \"bt\" ) || ! strcmp ( szExt , \"wrl\" ) || ! strcmp ( szExt , \"x3dv\" ) || ! strcmp ( szExt , \"xmt\" ) || ! strcmp ( szExt , \"xmta\" ) || ! strcmp ( szExt , \"x3d\" ) || ! strcmp ( szExt , \"jpg\" ) || ! strcmp ( szExt , \"jpeg\" ) || ! strcmp ( szExt , \"png\" ) ) return GF_FALSE ; { u32 i ; for ( i = 0 ; FFD_MIME_TYPES [ i ] ; i += 3 ) { if ( gf_service_check_mime_register ( plug , FFD_MIME_TYPES [ i ] , FFD_MIME_TYPES [ i + 1 ] , FFD_MIME_TYPES [ i + 2 ] , ext ) ) return GF_TRUE ; } } } ffd_parse_options ( ffd , url ) ; ctx = NULL ; if ( open_file ( & ctx , szName , NULL , ffd -> options ? & ffd -> options : NULL ) < 0 ) { AVInputFormat * av_in = NULL ; if ( ext && ! strcmp ( szExt , \"cmp\" ) ) av_in = av_find_input_format ( \"m4v\" ) ; if ( open_file ( & ctx , szName , av_in , ffd -> options ? & ffd -> options : NULL ) < 0 ) { return GF_FALSE ; } } if ( ! ctx ) goto exit ; if ( av_find_stream_info ( ctx ) < 0 ) goto exit ; has_video = has_audio = GF_FALSE ; for ( i = 0 ; i < ( s32 ) ctx -> nb_streams ; i ++ ) { AVCodecContext * enc = ctx -> streams [ i ] -> codec ; switch ( enc -> codec_type ) { case AVMEDIA_TYPE_AUDIO : if ( ! has_audio ) has_audio = GF_TRUE ; break ; case AVMEDIA_TYPE_VIDEO : if ( ! has_video ) has_video = GF_TRUE ; break ; default : break ; } } if ( ! has_audio && ! has_video ) goto exit ; ret = GF_TRUE ; # if ( ( LIBAVFORMAT_VERSION_MAJOR == 52 ) && ( LIBAVFORMAT_VERSION_MINOR <= 47 ) ) || ( LIBAVFORMAT_VERSION_MAJOR < 52 ) fmt_out = guess_stream_format ( NULL , url , NULL ) ; # else fmt_out = av_guess_format ( NULL , url , NULL ) ; # endif if ( fmt_out ) gf_service_register_mime ( plug , fmt_out -> mime_type , fmt_out -> extensions , fmt_out -> name ) ; else { ext = strrchr ( szName , '.' ) ; if ( ext ) { strcpy ( szExt , & ext [ 1 ] ) ; strlwr ( szExt ) ; szExtList = gf_modules_get_option ( ( GF_BaseInterface * ) plug , \"MimeTypes\" , \"application/x-ffmpeg\" ) ; if ( ! szExtList ) { gf_service_register_mime ( plug , \"application/x-ffmpeg\" , szExt , \"Other<S2SV_blank>Movies<S2SV_blank>(FFMPEG)\" ) ; } else if ( ! strstr ( szExtList , szExt ) ) { u32 len ; char * buf ; len = ( u32 ) ( strlen ( szExtList ) + strlen ( szExt ) + 10 ) ; buf = ( char * ) gf_malloc ( sizeof ( char ) * len ) ; sprintf ( buf , \"\\\\\"%s<S2SV_blank>\" , szExt ) ; strcat ( buf , & szExtList [ 1 ] ) ; gf_modules_set_option ( ( GF_BaseInterface * ) plug , \"MimeTypes\" , \"application/x-ffmpeg\" , buf ) ; gf_free ( buf ) ; } } } exit : # if FF_API_CLOSE_INPUT_FILE if ( ctx ) av_close_input_file ( ctx ) ; # else if ( ctx ) avformat_close_input ( & ctx ) ; # endif return ret ; }\n","target":"<S2SV_ModStart> , szName [ 1024 <S2SV_ModEnd> ] , szExt <S2SV_ModStart> -> priv ; if ( strlen ( url ) >= sizeof ( szName ) ) return GF_FALSE ; <S2SV_ModStart> ) > 1 && strlen ( ext ) <= sizeof ( szExt )\n","project_and_commit_id":"gpac@gpac/35ab4475a7df9b2a4bcab235e379c0c3ec543658","cve_id":"CVE-2018-20762","original_address":"https://github.com/gpac/gpac/commit/35ab4475a7df9b2a4bcab235e379c0c3ec543658","time":"2019-02-06T23:29Z"},
	{"Unnamed: 0":5612,"cwe_id":"CWE-476","source":"CWE-476 static Sdb * store_versioninfo_gnu_verdef ( ELFOBJ * bin , Elf_ ( Shdr ) * shdr , int sz ) { const char * section_name = \"\" ; const char * link_section_name = \"\" ; char * end = NULL ; Elf_ ( Shdr ) * link_shdr = NULL ; ut8 dfs [ sizeof ( Elf_ ( Verdef ) ) ] = { 0 } ; Sdb * sdb ; int cnt , i ; if ( shdr -> sh_link > bin -> ehdr . e_shnum ) { return false ; } link_shdr = & bin -> shdr [ shdr -> sh_link ] ; if ( ( int ) shdr -> sh_size < 1 ) { return false ; } Elf_ ( Verdef ) * defs = calloc ( shdr -> sh_size , sizeof ( char ) ) ; if ( ! defs ) { return false ; } if ( bin -> shstrtab && shdr -> sh_name < bin -> shstrtab_size ) { section_name = & bin -> shstrtab [ shdr -> sh_name ] ; } if ( link_shdr && bin -> shstrtab && link_shdr -> sh_name < bin -> shstrtab_size ) { link_section_name = & bin -> shstrtab [ link_shdr -> sh_name ] ; } if ( ! defs ) { bprintf ( \"Warning:<S2SV_blank>Cannot<S2SV_blank>allocate<S2SV_blank>memory<S2SV_blank>(Check<S2SV_blank>Elf_(Verdef))\\\\n\" ) ; return NULL ; } sdb = sdb_new0 ( ) ; end = ( char * ) defs + shdr -> sh_size ; sdb_set ( sdb , \"section_name\" , section_name , 0 ) ; sdb_num_set ( sdb , \"entries\" , shdr -> sh_info , 0 ) ; sdb_num_set ( sdb , \"addr\" , shdr -> sh_addr , 0 ) ; sdb_num_set ( sdb , \"offset\" , shdr -> sh_offset , 0 ) ; sdb_num_set ( sdb , \"link\" , shdr -> sh_link , 0 ) ; sdb_set ( sdb , \"link_section_name\" , link_section_name , 0 ) ; for ( cnt = 0 , i = 0 ; i >= 0 && cnt < shdr -> sh_info && ( ( char * ) defs + i < end ) ; ++ cnt ) { Sdb * sdb_verdef = sdb_new0 ( ) ; char * vstart = ( ( char * ) defs ) + i ; <S2SV_StartBug> char key [ 32 ] = { 0 } ; <S2SV_EndBug> Elf_ ( Verdef ) * verdef = ( Elf_ ( Verdef ) * ) vstart ; Elf_ ( Verdaux ) aux = { 0 } ; int j = 0 ; int isum = 0 ; r_buf_read_at ( bin -> b , shdr -> sh_offset + i , dfs , sizeof ( Elf_ ( Verdef ) ) ) ; verdef -> vd_version = READ16 ( dfs , j ) verdef -> vd_flags = READ16 ( dfs , j ) verdef -> vd_ndx = READ16 ( dfs , j ) verdef -> vd_cnt = READ16 ( dfs , j ) verdef -> vd_hash = READ32 ( dfs , j ) verdef -> vd_aux = READ32 ( dfs , j ) verdef -> vd_next = READ32 ( dfs , j ) int vdaux = verdef -> vd_aux ; <S2SV_StartBug> if ( vdaux < 1 || vstart + vdaux < vstart ) { <S2SV_EndBug> sdb_free ( sdb_verdef ) ; goto out_error ; } <S2SV_StartBug> vstart += vdaux ; <S2SV_EndBug> if ( vstart > end || vstart + sizeof ( Elf_ ( Verdaux ) ) > end ) { sdb_free ( sdb_verdef ) ; goto out_error ; } j = 0 ; aux . vda_name = READ32 ( vstart , j ) aux . vda_next = READ32 ( vstart , j ) isum = i + verdef -> vd_aux ; if ( aux . vda_name > bin -> dynstr_size ) { sdb_free ( sdb_verdef ) ; goto out_error ; } sdb_num_set ( sdb_verdef , \"idx\" , i , 0 ) ; sdb_num_set ( sdb_verdef , \"vd_version\" , verdef -> vd_version , 0 ) ; sdb_num_set ( sdb_verdef , \"vd_ndx\" , verdef -> vd_ndx , 0 ) ; sdb_num_set ( sdb_verdef , \"vd_cnt\" , verdef -> vd_cnt , 0 ) ; sdb_set ( sdb_verdef , \"vda_name\" , & bin -> dynstr [ aux . vda_name ] , 0 ) ; sdb_set ( sdb_verdef , \"flags\" , get_ver_flags ( verdef -> vd_flags ) , 0 ) ; for ( j = 1 ; j < verdef -> vd_cnt ; ++ j ) { int k ; Sdb * sdb_parent = sdb_new0 ( ) ; isum += aux . vda_next ; vstart += aux . vda_next ; <S2SV_StartBug> if ( vstart > end || vstart + sizeof ( Elf_ ( Verdaux ) ) > end ) { <S2SV_EndBug> sdb_free ( sdb_verdef ) ; sdb_free ( sdb_parent ) ; goto out_error ; } k = 0 ; aux . vda_name = READ32 ( vstart , k ) aux . vda_next = READ32 ( vstart , k ) if ( aux . vda_name > bin -> dynstr_size ) { sdb_free ( sdb_verdef ) ; sdb_free ( sdb_parent ) ; goto out_error ; } sdb_num_set ( sdb_parent , \"idx\" , isum , 0 ) ; sdb_num_set ( sdb_parent , \"parent\" , j , 0 ) ; sdb_set ( sdb_parent , \"vda_name\" , & bin -> dynstr [ aux . vda_name ] , 0 ) ; snprintf ( key , sizeof ( key ) , \"parent%d\" , j - 1 ) ; sdb_ns_set ( sdb_verdef , key , sdb_parent ) ; } snprintf ( key , sizeof ( key ) , \"verdef%d\" , cnt ) ; sdb_ns_set ( sdb , key , sdb_verdef ) ; if ( ! verdef -> vd_next ) { sdb_free ( sdb_verdef ) ; goto out_error ; } if ( ( st32 ) verdef -> vd_next < 1 ) { eprintf ( \"Warning:<S2SV_blank>Invalid<S2SV_blank>vd_next<S2SV_blank>in<S2SV_blank>the<S2SV_blank>ELF<S2SV_blank>version\\\\n\" ) ; break ; } i += verdef -> vd_next ; } free ( defs ) ; return sdb ; out_error : free ( defs ) ; sdb_free ( sdb ) ; return NULL ; }\n","target":"<S2SV_ModStart> + i ; size_t vstart_off = i ; <S2SV_ModStart> < 1 || shdr -> sh_size - vstart_off < vdaux <S2SV_ModEnd> ) { sdb_free <S2SV_ModStart> ; } vstart += vdaux ; vstart_off <S2SV_ModStart> . vda_next ; vstart_off += aux . vda_next ;\n","project_and_commit_id":"radare@radare2/fbaf24bce7ea4211e4608b3ab6c1b45702cb243d","cve_id":"CVE-2017-16359","original_address":"https://github.com/radare/radare2/commit/fbaf24bce7ea4211e4608b3ab6c1b45702cb243d","time":"2017-11-01T17:29Z"},
	{"Unnamed: 0":6448,"cwe_id":"CWE-20","source":"CWE-20 static Image * ReadCALSImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { char filename [ MagickPathExtent ] , header [ MagickPathExtent ] , message [ MagickPathExtent ] ; FILE * file ; Image * image ; ImageInfo * read_info ; int c , unique_file ; MagickBooleanType status ; register ssize_t i ; unsigned long density , direction , height , orientation , pel_path , type , width ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickCoreSignature ) ; if ( image_info -> debug != MagickFalse ) ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , \"%s\" , image_info -> filename ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickCoreSignature ) ; image = AcquireImage ( image_info , exception ) ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } ( void ) memset ( header , 0 , sizeof ( header ) ) ; density = 0 ; direction = 0 ; orientation = 1 ; pel_path = 0 ; type = 1 ; width = 0 ; height = 0 ; for ( i = 0 ; i < 16 ; i ++ ) { if ( ReadBlob ( image , 128 , ( unsigned char * ) header ) != 128 ) break ; switch ( * header ) { case 'R' : case 'r' : { if ( LocaleNCompare ( header , \"rdensty:\" , 8 ) == 0 ) { ( void ) sscanf ( header + 8 , \"%lu\" , & density ) ; break ; } if ( LocaleNCompare ( header , \"rpelcnt:\" , 8 ) == 0 ) { ( void ) sscanf ( header + 8 , \"%lu,%lu\" , & width , & height ) ; break ; } if ( LocaleNCompare ( header , \"rorient:\" , 8 ) == 0 ) { ( void ) sscanf ( header + 8 , \"%lu,%lu\" , & pel_path , & direction ) ; if ( pel_path == 90 ) orientation = 5 ; else if ( pel_path == 180 ) orientation = 3 ; else if ( pel_path == 270 ) orientation = 7 ; if ( direction == 90 ) orientation ++ ; break ; } if ( LocaleNCompare ( header , \"rtype:\" , 6 ) == 0 ) { ( void ) sscanf ( header + 6 , \"%lu\" , & type ) ; break ; } break ; } } } file = ( FILE * ) NULL ; unique_file = AcquireUniqueFileResource ( filename ) ; if ( unique_file != - 1 ) file = fdopen ( unique_file , \"wb\" ) ; if ( ( unique_file == - 1 ) || ( file == ( FILE * ) NULL ) ) ThrowImageException ( FileOpenError , \"UnableToCreateTemporaryFile\" ) ; while ( ( c = ReadBlobByte ( image ) ) != EOF ) <S2SV_StartBug> ( void ) fputc ( c , file ) ; <S2SV_EndBug> ( void ) fclose ( file ) ; ( void ) CloseBlob ( image ) ; image = DestroyImage ( image ) ; read_info = CloneImageInfo ( image_info ) ; SetImageInfoBlob ( read_info , ( void * ) NULL , 0 ) ; ( void ) FormatLocaleString ( read_info -> filename , MagickPathExtent , \"group4:%s\" , filename ) ; ( void ) FormatLocaleString ( message , MagickPathExtent , \"%lux%lu\" , width , height ) ; ( void ) CloneString ( & read_info -> size , message ) ; ( void ) FormatLocaleString ( message , MagickPathExtent , \"%lu\" , density ) ; ( void ) CloneString ( & read_info -> density , message ) ; read_info -> orientation = ( OrientationType ) orientation ; image = ReadImage ( read_info , exception ) ; if ( image != ( Image * ) NULL ) { ( void ) CopyMagickString ( image -> filename , image_info -> filename , MagickPathExtent ) ; ( void ) CopyMagickString ( image -> magick_filename , image_info -> filename , MagickPathExtent ) ; ( void ) CopyMagickString ( image -> magick , \"CALS\" , MagickPathExtent ) ; } read_info = DestroyImageInfo ( read_info ) ; ( void ) RelinquishUniqueFileResource ( filename ) ; return ( image ) ; }\n","target":"<S2SV_ModStart> != EOF ) if ( <S2SV_ModEnd> fputc ( c <S2SV_ModStart> , file ) != c ) break\n","project_and_commit_id":"ImageMagick@ImageMagick/6b6bff054d569a77973f2140c0e86366e6168a6c","cve_id":"CVE-2018-16643","original_address":"https://github.com/ImageMagick/ImageMagick/commit/6b6bff054d569a77973f2140c0e86366e6168a6c","time":"2018-09-06T22:29Z"},
	{"Unnamed: 0":6603,"cwe_id":"CWE-190","source":"CWE-190 SQLITE_PRIVATE int sqlite3VtabEponymousTableInit ( Parse * pParse , Module * pMod ) { const sqlite3_module * pModule = pMod -> pModule ; Table * pTab ; char * zErr = 0 ; int rc ; sqlite3 * db = pParse -> db ; if ( pMod -> pEpoTab ) return 1 ; if ( pModule -> xCreate != 0 && pModule -> xCreate != pModule -> xConnect ) return 0 ; pTab = sqlite3DbMallocZero ( db , sizeof ( Table ) ) ; if ( pTab == 0 ) return 0 ; pTab -> zName = sqlite3DbStrDup ( db , pMod -> zName ) ; if ( pTab -> zName == 0 ) { sqlite3DbFree ( db , pTab ) ; return 0 ; } pMod -> pEpoTab = pTab ; pTab -> nTabRef = 1 ; pTab -> pSchema = db -> aDb [ 0 ] . pSchema ; assert ( pTab -> nModuleArg == 0 ) ; pTab -> iPKey = - 1 ; <S2SV_StartBug> addModuleArgument ( db , pTab , sqlite3DbStrDup ( db , pTab -> zName ) ) ; <S2SV_EndBug> <S2SV_StartBug> addModuleArgument ( db , pTab , 0 ) ; <S2SV_EndBug> <S2SV_StartBug> addModuleArgument ( db , pTab , sqlite3DbStrDup ( db , pTab -> zName ) ) ; <S2SV_EndBug> rc = vtabCallConstructor ( db , pTab , pMod , pModule -> xConnect , & zErr ) ; if ( rc ) { sqlite3ErrorMsg ( pParse , \"%s\" , zErr ) ; sqlite3DbFree ( db , zErr ) ; sqlite3VtabEponymousTableClear ( db , pMod ) ; return 0 ; } return 1 ; }\n","target":"<S2SV_ModStart> ; addModuleArgument ( pParse <S2SV_ModEnd> , pTab , <S2SV_ModStart> ; addModuleArgument ( pParse <S2SV_ModEnd> , pTab , <S2SV_ModStart> ; addModuleArgument ( pParse <S2SV_ModEnd> , pTab ,\n","project_and_commit_id":"chromium@chromium/517ac71c9ee27f856f9becde8abea7d1604af9d4","cve_id":"CVE-2019-5827","original_address":"https://github.com/chromium/chromium/commit/517ac71c9ee27f856f9becde8abea7d1604af9d4","time":"2019-06-27T17:15Z"},
	{"Unnamed: 0":4906,"cwe_id":"CWE-119","source":"CWE-119 WORD32 ih264d_start_of_pic ( dec_struct_t * ps_dec , WORD32 i4_poc , pocstruct_t * ps_temp_poc , UWORD16 u2_frame_num , dec_pic_params_t * ps_pps ) { pocstruct_t * ps_prev_poc = & ps_dec -> s_cur_pic_poc ; pocstruct_t * ps_cur_poc = ps_temp_poc ; pic_buffer_t * pic_buf ; ivd_video_decode_op_t * ps_dec_output = ( ivd_video_decode_op_t * ) ps_dec -> pv_dec_out ; dec_slice_params_t * ps_cur_slice = ps_dec -> ps_cur_slice ; dec_seq_params_t * ps_seq = ps_pps -> ps_sps ; UWORD8 u1_bottom_field_flag = ps_cur_slice -> u1_bottom_field_flag ; UWORD8 u1_field_pic_flag = ps_cur_slice -> u1_field_pic_flag ; high_profile_tools_t s_high_profile ; WORD32 ret ; H264_MUTEX_LOCK ( & ps_dec -> process_disp_mutex ) ; ps_prev_poc -> i4_pic_order_cnt_lsb = ps_cur_poc -> i4_pic_order_cnt_lsb ; ps_prev_poc -> i4_pic_order_cnt_msb = ps_cur_poc -> i4_pic_order_cnt_msb ; ps_prev_poc -> i4_delta_pic_order_cnt_bottom = ps_cur_poc -> i4_delta_pic_order_cnt_bottom ; ps_prev_poc -> i4_delta_pic_order_cnt [ 0 ] = ps_cur_poc -> i4_delta_pic_order_cnt [ 0 ] ; ps_prev_poc -> i4_delta_pic_order_cnt [ 1 ] = ps_cur_poc -> i4_delta_pic_order_cnt [ 1 ] ; ps_prev_poc -> u1_bot_field = ps_dec -> ps_cur_slice -> u1_bottom_field_flag ; ps_prev_poc -> i4_prev_frame_num_ofst = ps_cur_poc -> i4_prev_frame_num_ofst ; ps_prev_poc -> u2_frame_num = u2_frame_num ; ps_dec -> i1_prev_mb_qp_delta = 0 ; ps_dec -> i1_next_ctxt_idx = 0 ; ps_dec -> u4_nmb_deblk = 0 ; if ( ps_dec -> u4_num_cores == 1 ) ps_dec -> u4_nmb_deblk = 1 ; if ( ps_seq -> u1_mb_aff_flag == 1 ) { ps_dec -> u4_nmb_deblk = 0 ; if ( ps_dec -> u4_num_cores > 2 ) ps_dec -> u4_num_cores = 2 ; } ps_dec -> u4_use_intrapred_line_copy = 0 ; if ( ps_seq -> u1_mb_aff_flag == 0 ) { ps_dec -> u4_use_intrapred_line_copy = 1 ; } ps_dec -> u4_app_disable_deblk_frm = 0 ; if ( ps_dec -> i4_degrade_type && ps_dec -> i4_degrade_pics ) { WORD32 degrade_pic ; ps_dec -> i4_degrade_pic_cnt ++ ; degrade_pic = 0 ; switch ( ps_dec -> i4_degrade_pics ) { case 4 : { degrade_pic = 1 ; break ; } case 3 : { if ( ps_cur_slice -> u1_slice_type != I_SLICE ) degrade_pic = 1 ; break ; } case 2 : { if ( ( ps_cur_slice -> u1_slice_type != I_SLICE ) && ( ps_dec -> i4_degrade_pic_cnt != ps_dec -> i4_nondegrade_interval ) ) degrade_pic = 1 ; break ; } case 1 : { if ( 0 == ps_cur_slice -> u1_nal_ref_idc ) { degrade_pic = 1 ; } break ; } } if ( degrade_pic ) { if ( ps_dec -> i4_degrade_type & 0x2 ) ps_dec -> u4_app_disable_deblk_frm = 1 ; if ( 0 == ps_cur_slice -> u1_nal_ref_idc ) { if ( ps_dec -> i4_degrade_type & 0x4 ) ps_dec -> i4_mv_frac_mask = 0 ; if ( ps_dec -> i4_degrade_type & 0x8 ) ps_dec -> i4_mv_frac_mask = 0 ; } } else ps_dec -> i4_degrade_pic_cnt = 0 ; } { dec_err_status_t * ps_err = ps_dec -> ps_dec_err_status ; if ( ps_dec -> u1_sl_typ_5_9 && ( ( ps_cur_slice -> u1_slice_type == I_SLICE ) || ( ps_cur_slice -> u1_slice_type == SI_SLICE ) ) ) ps_err -> u1_cur_pic_type = PIC_TYPE_I ; else ps_err -> u1_cur_pic_type = PIC_TYPE_UNKNOWN ; if ( ps_err -> u1_pic_aud_i == PIC_TYPE_I ) { ps_err -> u1_cur_pic_type = PIC_TYPE_I ; ps_err -> u1_pic_aud_i = PIC_TYPE_UNKNOWN ; } if ( ps_cur_slice -> u1_nal_unit_type == IDR_SLICE_NAL ) { if ( ps_err -> u1_err_flag ) ih264d_reset_ref_bufs ( ps_dec -> ps_dpb_mgr ) ; ps_err -> u1_err_flag = ACCEPT_ALL_PICS ; } } if ( ps_dec -> u1_init_dec_flag && ps_dec -> s_prev_seq_params . u1_eoseq_pending ) { WORD32 j ; for ( j = 0 ; j < MAX_DISP_BUFS_NEW ; j ++ ) { ih264_buf_mgr_release ( ( buf_mgr_t * ) ps_dec -> pv_pic_buf_mgr , j , BUF_MGR_REF ) ; ih264_buf_mgr_release ( ( buf_mgr_t * ) ps_dec -> pv_mv_buf_mgr , ps_dec -> au1_pic_buf_id_mv_buf_id_map [ j ] , BUF_MGR_REF ) ; ih264_buf_mgr_release ( ( buf_mgr_t * ) ps_dec -> pv_pic_buf_mgr , j , BUF_MGR_IO ) ; } ps_dec -> u1_second_field = 0 ; ps_dec -> i4_cur_display_seq = 0 ; ps_dec -> s_prev_seq_params . u1_eoseq_pending = 0 ; } ret = ih264d_init_pic ( ps_dec , u2_frame_num , i4_poc , ps_pps ) ; if ( ret != OK ) return ret ; ps_dec -> pv_parse_tu_coeff_data = ps_dec -> pv_pic_tu_coeff_data ; ps_dec -> pv_proc_tu_coeff_data = ps_dec -> pv_pic_tu_coeff_data ; ps_dec -> ps_nmb_info = ps_dec -> ps_frm_mb_info ; if ( ps_dec -> u1_separate_parse ) { UWORD16 pic_wd ; UWORD16 pic_ht ; UWORD32 num_mbs ; pic_wd = ps_dec -> u2_pic_wd ; pic_ht = ps_dec -> u2_pic_ht ; num_mbs = ( pic_wd * pic_ht ) >> 8 ; if ( ps_dec -> pu1_dec_mb_map ) { memset ( ( void * ) ps_dec -> pu1_dec_mb_map , 0 , num_mbs ) ; } if ( ps_dec -> pu1_recon_mb_map ) { memset ( ( void * ) ps_dec -> pu1_recon_mb_map , 0 , num_mbs ) ; } if ( ps_dec -> pu2_slice_num_map ) { memset ( ( void * ) ps_dec -> pu2_slice_num_map , 0 , ( num_mbs * sizeof ( UWORD16 ) ) ) ; } } ps_dec -> ps_parse_cur_slice = & ( ps_dec -> ps_dec_slice_buf [ 0 ] ) ; ps_dec -> ps_decode_cur_slice = & ( ps_dec -> ps_dec_slice_buf [ 0 ] ) ; ps_dec -> ps_computebs_cur_slice = & ( ps_dec -> ps_dec_slice_buf [ 0 ] ) ; <S2SV_StartBug> ps_dec -> s_high_profile . u1_scaling_present = 0 ; <S2SV_EndBug> ps_dec -> s_high_profile . u1_transform8x8_present = 0 ; if ( 1 == ps_dec -> u4_share_disp_buf ) { UWORD32 i ; for ( i = 0 ; i < MAX_DISP_BUFS_NEW ; i ++ ) { if ( 0 == ps_dec -> u4_disp_buf_to_be_freed [ i ] ) continue ; ih264_buf_mgr_release ( ( buf_mgr_t * ) ps_dec -> pv_pic_buf_mgr , i , BUF_MGR_IO ) ; ps_dec -> u4_disp_buf_to_be_freed [ i ] = 0 ; ps_dec -> u4_disp_buf_mapping [ i ] = 0 ; } } if ( ! ( u1_field_pic_flag && 0 != ps_dec -> u1_top_bottom_decoded ) ) { pic_buffer_t * ps_cur_pic ; WORD32 cur_pic_buf_id , cur_mv_buf_id ; col_mv_buf_t * ps_col_mv ; while ( 1 ) { ps_cur_pic = ( pic_buffer_t * ) ih264_buf_mgr_get_next_free ( ( buf_mgr_t * ) ps_dec -> pv_pic_buf_mgr , & cur_pic_buf_id ) ; if ( ps_cur_pic == NULL ) { ps_dec -> i4_error_code = ERROR_UNAVAIL_PICBUF_T ; return ERROR_UNAVAIL_PICBUF_T ; } if ( 0 == ps_dec -> u4_disp_buf_mapping [ cur_pic_buf_id ] ) { break ; } } ps_col_mv = ( col_mv_buf_t * ) ih264_buf_mgr_get_next_free ( ( buf_mgr_t * ) ps_dec -> pv_mv_buf_mgr , & cur_mv_buf_id ) ; if ( ps_col_mv == NULL ) { ps_dec -> i4_error_code = ERROR_UNAVAIL_MVBUF_T ; return ERROR_UNAVAIL_MVBUF_T ; } ps_dec -> ps_cur_pic = ps_cur_pic ; ps_dec -> u1_pic_buf_id = cur_pic_buf_id ; ps_cur_pic -> u4_ts = ps_dec -> u4_ts ; ps_cur_pic -> u1_mv_buf_id = cur_mv_buf_id ; ps_dec -> au1_pic_buf_id_mv_buf_id_map [ cur_pic_buf_id ] = cur_mv_buf_id ; ps_cur_pic -> pu1_col_zero_flag = ( UWORD8 * ) ps_col_mv -> pv_col_zero_flag ; ps_cur_pic -> ps_mv = ( mv_pred_t * ) ps_col_mv -> pv_mv ; ps_dec -> au1_pic_buf_ref_flag [ cur_pic_buf_id ] = 0 ; if ( ps_dec -> u1_first_slice_in_stream ) { ps_dec -> ps_ref_pic_buf_lx [ 0 ] = ps_dec -> ps_dpb_mgr -> ps_init_dpb [ 0 ] ; * ( ps_dec -> ps_dpb_mgr -> ps_init_dpb [ 0 ] [ 0 ] ) = * ps_cur_pic ; } if ( ! ps_dec -> ps_cur_pic ) { WORD32 j ; H264_DEC_DEBUG_PRINT ( \"-------<S2SV_blank>Display<S2SV_blank>Buffers<S2SV_blank>Reset<S2SV_blank>--------\\\\n\" ) ; for ( j = 0 ; j < MAX_DISP_BUFS_NEW ; j ++ ) { ih264_buf_mgr_release ( ( buf_mgr_t * ) ps_dec -> pv_pic_buf_mgr , j , BUF_MGR_REF ) ; ih264_buf_mgr_release ( ( buf_mgr_t * ) ps_dec -> pv_mv_buf_mgr , ps_dec -> au1_pic_buf_id_mv_buf_id_map [ j ] , BUF_MGR_REF ) ; ih264_buf_mgr_release ( ( buf_mgr_t * ) ps_dec -> pv_pic_buf_mgr , j , BUF_MGR_IO ) ; } ps_dec -> i4_cur_display_seq = 0 ; ps_dec -> i4_prev_max_display_seq = 0 ; ps_dec -> i4_max_poc = 0 ; ps_cur_pic = ( pic_buffer_t * ) ih264_buf_mgr_get_next_free ( ( buf_mgr_t * ) ps_dec -> pv_pic_buf_mgr , & cur_pic_buf_id ) ; if ( ps_cur_pic == NULL ) { ps_dec -> i4_error_code = ERROR_UNAVAIL_PICBUF_T ; return ERROR_UNAVAIL_PICBUF_T ; } ps_col_mv = ( col_mv_buf_t * ) ih264_buf_mgr_get_next_free ( ( buf_mgr_t * ) ps_dec -> pv_mv_buf_mgr , & cur_mv_buf_id ) ; if ( ps_col_mv == NULL ) { ps_dec -> i4_error_code = ERROR_UNAVAIL_MVBUF_T ; return ERROR_UNAVAIL_MVBUF_T ; } ps_dec -> ps_cur_pic = ps_cur_pic ; ps_dec -> u1_pic_buf_id = cur_pic_buf_id ; ps_cur_pic -> u4_ts = ps_dec -> u4_ts ; ps_dec -> apv_buf_id_pic_buf_map [ cur_pic_buf_id ] = ( void * ) ps_cur_pic ; ps_cur_pic -> u1_mv_buf_id = cur_mv_buf_id ; ps_dec -> au1_pic_buf_id_mv_buf_id_map [ cur_pic_buf_id ] = cur_mv_buf_id ; ps_cur_pic -> pu1_col_zero_flag = ( UWORD8 * ) ps_col_mv -> pv_col_zero_flag ; ps_cur_pic -> ps_mv = ( mv_pred_t * ) ps_col_mv -> pv_mv ; ps_dec -> au1_pic_buf_ref_flag [ cur_pic_buf_id ] = 0 ; } ps_dec -> ps_cur_pic -> u1_picturetype = u1_field_pic_flag ; ps_dec -> ps_cur_pic -> u4_pack_slc_typ = SKIP_NONE ; H264_DEC_DEBUG_PRINT ( \"got<S2SV_blank>a<S2SV_blank>buffer\\\\n\" ) ; } else { H264_DEC_DEBUG_PRINT ( \"did<S2SV_blank>not<S2SV_blank>get<S2SV_blank>a<S2SV_blank>buffer\\\\n\" ) ; } ps_dec -> u4_pic_buf_got = 1 ; ps_dec -> ps_cur_pic -> i4_poc = i4_poc ; ps_dec -> ps_cur_pic -> i4_frame_num = u2_frame_num ; ps_dec -> ps_cur_pic -> i4_pic_num = u2_frame_num ; ps_dec -> ps_cur_pic -> i4_top_field_order_cnt = ps_pps -> i4_top_field_order_cnt ; ps_dec -> ps_cur_pic -> i4_bottom_field_order_cnt = ps_pps -> i4_bottom_field_order_cnt ; ps_dec -> ps_cur_pic -> i4_avg_poc = ps_pps -> i4_avg_poc ; ps_dec -> ps_cur_pic -> u4_time_stamp = ps_dec -> u4_pts ; ps_dec -> s_cur_pic = * ( ps_dec -> ps_cur_pic ) ; if ( u1_field_pic_flag && u1_bottom_field_flag ) { WORD32 i4_temp_poc ; WORD32 i4_top_field_order_poc , i4_bot_field_order_poc ; ps_dec -> s_cur_pic . pu1_buf1 += ps_dec -> s_cur_pic . u2_frm_wd_y ; ps_dec -> s_cur_pic . pu1_buf2 += ps_dec -> s_cur_pic . u2_frm_wd_uv ; ps_dec -> s_cur_pic . pu1_buf3 += ps_dec -> s_cur_pic . u2_frm_wd_uv ; ps_dec -> s_cur_pic . ps_mv += ( ( ps_dec -> u2_pic_ht * ps_dec -> u2_pic_wd ) >> 5 ) ; ps_dec -> s_cur_pic . pu1_col_zero_flag += ( ( ps_dec -> u2_pic_ht * ps_dec -> u2_pic_wd ) >> 5 ) ; ps_dec -> ps_cur_pic -> u1_picturetype |= BOT_FLD ; i4_top_field_order_poc = ps_dec -> ps_cur_pic -> i4_top_field_order_cnt ; i4_bot_field_order_poc = ps_dec -> ps_cur_pic -> i4_bottom_field_order_cnt ; i4_temp_poc = MIN ( i4_top_field_order_poc , i4_bot_field_order_poc ) ; ps_dec -> ps_cur_pic -> i4_avg_poc = i4_temp_poc ; } ps_cur_slice -> u1_mbaff_frame_flag = ps_seq -> u1_mb_aff_flag && ( ! u1_field_pic_flag ) ; ps_dec -> ps_cur_pic -> u1_picturetype |= ( ps_cur_slice -> u1_mbaff_frame_flag << 2 ) ; ps_dec -> ps_cur_mb_row = ps_dec -> ps_nbr_mb_row ; ps_dec -> ps_cur_mb_row += 2 ; ps_dec -> ps_top_mb_row = ps_dec -> ps_nbr_mb_row ; ps_dec -> ps_top_mb_row += ( ( ps_dec -> u2_frm_wd_in_mbs + 2 ) << ( 1 - ps_dec -> ps_cur_sps -> u1_frame_mbs_only_flag ) ) ; ps_dec -> ps_top_mb_row += 2 ; ps_dec -> ps_mv_cur = ps_dec -> s_cur_pic . ps_mv ; ps_dec -> ps_mv_top = ps_dec -> ps_mv_top_p [ 0 ] ; ps_dec -> u1_mv_top_p = 0 ; ps_dec -> u1_mb_idx = 0 ; ps_dec -> ps_mv_left = ps_dec -> s_cur_pic . ps_mv ; ps_dec -> u2_total_mbs_coded = 0 ; ps_dec -> i4_submb_ofst = - ( SUB_BLK_SIZE ) ; ps_dec -> u4_pred_info_idx = 0 ; ps_dec -> u4_pred_info_pkd_idx = 0 ; ps_dec -> u4_dma_buf_idx = 0 ; ps_dec -> ps_mv = ps_dec -> s_cur_pic . ps_mv ; ps_dec -> ps_mv_bank_cur = ps_dec -> s_cur_pic . ps_mv ; ps_dec -> pu1_col_zero_flag = ps_dec -> s_cur_pic . pu1_col_zero_flag ; ps_dec -> ps_part = ps_dec -> ps_parse_part_params ; ps_dec -> i2_prev_slice_mbx = - 1 ; ps_dec -> i2_prev_slice_mby = 0 ; ps_dec -> u2_mv_2mb [ 0 ] = 0 ; ps_dec -> u2_mv_2mb [ 1 ] = 0 ; ps_dec -> u1_last_pic_not_decoded = 0 ; <S2SV_StartBug> ps_dec -> u2_cur_slice_num = 0 ; <S2SV_EndBug> ps_dec -> u2_cur_slice_num_dec_thread = 0 ; ps_dec -> u2_cur_slice_num_bs = 0 ; ps_dec -> u4_intra_pred_line_ofst = 0 ; ps_dec -> pu1_cur_y_intra_pred_line = ps_dec -> pu1_y_intra_pred_line ; ps_dec -> pu1_cur_u_intra_pred_line = ps_dec -> pu1_u_intra_pred_line ; ps_dec -> pu1_cur_v_intra_pred_line = ps_dec -> pu1_v_intra_pred_line ; ps_dec -> pu1_cur_y_intra_pred_line_base = ps_dec -> pu1_y_intra_pred_line ; ps_dec -> pu1_cur_u_intra_pred_line_base = ps_dec -> pu1_u_intra_pred_line ; ps_dec -> pu1_cur_v_intra_pred_line_base = ps_dec -> pu1_v_intra_pred_line ; ps_dec -> pu1_prev_y_intra_pred_line = ps_dec -> pu1_y_intra_pred_line + ( ps_dec -> u2_frm_wd_in_mbs * MB_SIZE ) ; ps_dec -> pu1_prev_u_intra_pred_line = ps_dec -> pu1_u_intra_pred_line + ps_dec -> u2_frm_wd_in_mbs * BLK8x8SIZE * YUV420SP_FACTOR ; ps_dec -> pu1_prev_v_intra_pred_line = ps_dec -> pu1_v_intra_pred_line + ps_dec -> u2_frm_wd_in_mbs * BLK8x8SIZE ; ps_dec -> ps_deblk_mbn = ps_dec -> ps_deblk_pic ; { if ( ps_cur_slice -> u1_mbaff_frame_flag ) { ps_dec -> pf_compute_bs = ih264d_compute_bs_mbaff ; ps_dec -> pf_mvpred = ih264d_mvpred_mbaff ; } else { ps_dec -> pf_compute_bs = ih264d_compute_bs_non_mbaff ; ps_dec -> u1_cur_mb_fld_dec_flag = ps_cur_slice -> u1_field_pic_flag ; } } { UWORD8 u1_field_pic_flag = ps_dec -> ps_cur_slice -> u1_field_pic_flag ; UWORD8 u1_mbaff = ps_cur_slice -> u1_mbaff_frame_flag ; UWORD8 uc_lastmbs = ( ( ( ps_dec -> u2_pic_wd ) >> 4 ) % ( ps_dec -> u1_recon_mb_grp >> u1_mbaff ) ) ; UWORD16 ui16_lastmbs_widthY = ( uc_lastmbs ? ( uc_lastmbs << 4 ) : ( ( ps_dec -> u1_recon_mb_grp >> u1_mbaff ) << 4 ) ) ; UWORD16 ui16_lastmbs_widthUV = uc_lastmbs ? ( uc_lastmbs << 3 ) : ( ( ps_dec -> u1_recon_mb_grp >> u1_mbaff ) << 3 ) ; ps_dec -> s_tran_addrecon . pu1_dest_y = ps_dec -> s_cur_pic . pu1_buf1 ; ps_dec -> s_tran_addrecon . pu1_dest_u = ps_dec -> s_cur_pic . pu1_buf2 ; ps_dec -> s_tran_addrecon . pu1_dest_v = ps_dec -> s_cur_pic . pu1_buf3 ; ps_dec -> s_tran_addrecon . u2_frm_wd_y = ps_dec -> u2_frm_wd_y << u1_field_pic_flag ; ps_dec -> s_tran_addrecon . u2_frm_wd_uv = ps_dec -> u2_frm_wd_uv << u1_field_pic_flag ; if ( u1_field_pic_flag ) { ui16_lastmbs_widthY += ps_dec -> u2_frm_wd_y ; ui16_lastmbs_widthUV += ps_dec -> u2_frm_wd_uv ; } ps_dec -> s_tran_addrecon . u4_inc_y [ 0 ] = ( ( ps_dec -> u1_recon_mb_grp << 4 ) >> u1_mbaff ) ; ps_dec -> s_tran_addrecon . u4_inc_uv [ 0 ] = ( ( ps_dec -> u1_recon_mb_grp << 4 ) >> u1_mbaff ) ; ps_dec -> s_tran_addrecon . u4_inc_y [ 1 ] = ( ui16_lastmbs_widthY + ( PAD_LEN_Y_H << 1 ) + ps_dec -> s_tran_addrecon . u2_frm_wd_y * ( ( 15 << u1_mbaff ) + u1_mbaff ) ) ; ps_dec -> s_tran_addrecon . u4_inc_uv [ 1 ] = ( ui16_lastmbs_widthUV + ( PAD_LEN_UV_H << 2 ) + ps_dec -> s_tran_addrecon . u2_frm_wd_uv * ( ( 15 << u1_mbaff ) + u1_mbaff ) ) ; ih264d_assign_pic_num ( ps_dec ) ; ps_dec -> s_tran_addrecon . u2_mv_top_left_inc = ( ps_dec -> u1_recon_mb_grp << 2 ) - 1 - ( u1_mbaff << 2 ) ; ps_dec -> s_tran_addrecon . u2_mv_left_inc = ( ( ps_dec -> u1_recon_mb_grp >> u1_mbaff ) - 1 ) << ( 4 + u1_mbaff ) ; } if ( ps_seq -> u1_profile_idc == HIGH_PROFILE_IDC ) { if ( ( ps_seq -> i4_seq_scaling_matrix_present_flag ) || ( ps_pps -> i4_pic_scaling_matrix_present_flag ) ) { ih264d_form_scaling_matrix_picture ( ps_seq , ps_pps , ps_dec ) ; ps_dec -> s_high_profile . u1_scaling_present = 1 ; } else { ih264d_form_default_scaling_matrix ( ps_dec ) ; } if ( ps_pps -> i4_transform_8x8_mode_flag ) { ps_dec -> s_high_profile . u1_transform8x8_present = 1 ; } } else { ih264d_form_default_scaling_matrix ( ps_dec ) ; } ps_dec -> s_high_profile . u1_direct_8x8_inference_flag = ps_seq -> u1_direct_8x8_inference_flag ; ps_dec -> s_high_profile . s_cavlc_ctxt = ps_dec -> s_cavlc_ctxt ; ps_dec -> i1_recon_in_thread3_flag = 1 ; ps_dec -> ps_frame_buf_ip_recon = & ps_dec -> s_tran_addrecon ; if ( ps_dec -> u1_separate_parse ) { memcpy ( & ps_dec -> s_tran_addrecon_parse , & ps_dec -> s_tran_addrecon , sizeof ( tfr_ctxt_t ) ) ; if ( ps_dec -> u4_num_cores >= 3 && ps_dec -> i1_recon_in_thread3_flag ) { memcpy ( & ps_dec -> s_tran_iprecon , & ps_dec -> s_tran_addrecon , sizeof ( tfr_ctxt_t ) ) ; ps_dec -> ps_frame_buf_ip_recon = & ps_dec -> s_tran_iprecon ; } } ih264d_init_deblk_tfr_ctxt ( ps_dec , & ( ps_dec -> s_pad_mgr ) , & ( ps_dec -> s_tran_addrecon ) , ps_dec -> u2_frm_wd_in_mbs , 0 ) ; ps_dec -> ps_cur_deblk_mb = ps_dec -> ps_deblk_pic ; ps_dec -> u4_cur_deblk_mb_num = 0 ; ps_dec -> u4_deblk_mb_x = 0 ; ps_dec -> u4_deblk_mb_y = 0 ; ps_dec -> pu4_wt_ofsts = ps_dec -> pu4_wts_ofsts_mat ; H264_MUTEX_UNLOCK ( & ps_dec -> process_disp_mutex ) ; return OK ; }\n","target":"<S2SV_ModStart> ; ps_dec -> u2_cur_slice_num = 0 ; ps_dec -> <S2SV_ModStart> ; ps_dec -> <S2SV_ModEnd> u2_cur_slice_num_dec_thread = 0\n","project_and_commit_id":"external@libavc/a78887bcffbc2995cf9ed72e0697acf560875e9e","cve_id":"CVE-2016-3820","original_address":"https://android.googlesource.com/platform/external/libavc/+/a78887bcffbc2995cf9ed72e0697acf560875e9e","time":"2016-08-05T20:59Z"},
	{"Unnamed: 0":4406,"cwe_id":"CWE-119","source":"CWE-119 void process_pfa ( FILE * ifp , const char * ifp_filename , struct font_reader * fr ) { char buffer [ LINESIZE ] ; int c = 0 ; int blocktyp = PFA_ASCII ; char saved_orphan = 0 ; ( void ) ifp_filename ; while ( c != EOF ) { char * line = buffer , * last = buffer ; int crlf = 0 ; c = getc ( ifp ) ; while ( c != EOF && c != '\\\\r' && c != '\\\\n' && last < buffer + LINESIZE - 1 ) { * last ++ = c ; c = getc ( ifp ) ; } if ( last == buffer + LINESIZE - 1 ) ungetc ( c , ifp ) ; else if ( c == '\\\\r' && blocktyp != PFA_BINARY ) { c = getc ( ifp ) ; if ( c != '\\\\n' ) ungetc ( c , ifp ) , crlf = 1 ; else crlf = 2 ; * last ++ = '\\\\n' ; } else if ( c != EOF ) * last ++ = c ; * last = 0 ; if ( blocktyp == PFA_ASCII ) { <S2SV_StartBug> if ( strncmp ( line , \"currentfile<S2SV_blank>eexec\" , 17 ) == 0 && isspace ( line [ 17 ] ) ) { <S2SV_EndBug> char saved_p ; <S2SV_StartBug> for ( line += 18 ; isspace ( * line ) ; line ++ ) <S2SV_EndBug> ; saved_p = * line ; * line = 0 ; fr -> output_ascii ( buffer , line - buffer ) ; * line = saved_p ; blocktyp = PFA_EEXEC_TEST ; if ( ! * line ) continue ; } else { fr -> output_ascii ( line , last - line ) ; continue ; } } if ( blocktyp == PFA_EEXEC_TEST ) { <S2SV_StartBug> for ( ; line < last && isspace ( * line ) ; line ++ ) <S2SV_EndBug> ; if ( line == last ) continue ; <S2SV_StartBug> else if ( last >= line + 4 && isxdigit ( line [ 0 ] ) && isxdigit ( line [ 1 ] ) <S2SV_EndBug> <S2SV_StartBug> && isxdigit ( line [ 2 ] ) && isxdigit ( line [ 3 ] ) ) <S2SV_EndBug> blocktyp = PFA_HEX ; else blocktyp = PFA_BINARY ; memmove ( buffer , line , last - line + 1 ) ; last = buffer + ( last - line ) ; line = buffer ; if ( blocktyp == PFA_BINARY && crlf ) { last [ - 1 ] = '\\\\r' ; if ( crlf == 2 ) * last ++ = '\\\\n' ; } } if ( all_zeroes ( line ) ) { fr -> output_ascii ( line , last - line ) ; blocktyp = PFA_ASCII ; } else if ( blocktyp == PFA_HEX ) { int len = translate_hex_string ( line , & saved_orphan ) ; if ( len ) fr -> output_binary ( ( unsigned char * ) line , len ) ; } else fr -> output_binary ( ( unsigned char * ) line , last - line ) ; } fr -> output_end ( ) ; }\n","target":"<S2SV_ModStart> && isspace ( ( unsigned char ) <S2SV_ModStart> ; isspace ( ( unsigned char ) <S2SV_ModStart> && isspace ( ( unsigned char ) <S2SV_ModStart> && isxdigit ( ( unsigned char ) <S2SV_ModStart> && isxdigit ( ( unsigned char ) <S2SV_ModStart> && isxdigit ( ( unsigned char ) <S2SV_ModStart> && isxdigit ( ( unsigned char )\n","project_and_commit_id":"kohler@t1utils/6b9d1aafcb61a3663c883663eb19ccdbfcde8d33","cve_id":"CVE-2015-3905","original_address":"https://github.com/kohler/t1utils/commit/6b9d1aafcb61a3663c883663eb19ccdbfcde8d33","time":"2015-06-08T14:59Z"},
	{"Unnamed: 0":5611,"cwe_id":"CWE-000","source":"CWE-000 static rfbBool rfbSetClientColourMapBGR233 ( rfbClientPtr cl ) { <S2SV_StartBug> char buf [ sz_rfbSetColourMapEntriesMsg + 256 * 3 * 2 ] ; <S2SV_EndBug> <S2SV_StartBug> rfbSetColourMapEntriesMsg * scme = ( rfbSetColourMapEntriesMsg * ) buf ; <S2SV_EndBug> <S2SV_StartBug> uint16_t * rgb = ( uint16_t * ) ( & buf [ sz_rfbSetColourMapEntriesMsg ] ) ; <S2SV_EndBug> int i , len ; int r , g , b ; if ( cl -> format . bitsPerPixel != 8 ) { rfbErr ( \"%s:<S2SV_blank>client<S2SV_blank>not<S2SV_blank>8<S2SV_blank>bits<S2SV_blank>per<S2SV_blank>pixel\\\\n\" , \"rfbSetClientColourMapBGR233\" ) ; rfbCloseClient ( cl ) ; return FALSE ; } scme -> type = rfbSetColourMapEntries ; scme -> firstColour = Swap16IfLE ( 0 ) ; scme -> nColours = Swap16IfLE ( 256 ) ; len = sz_rfbSetColourMapEntriesMsg ; i = 0 ; for ( b = 0 ; b < 4 ; b ++ ) { for ( g = 0 ; g < 8 ; g ++ ) { for ( r = 0 ; r < 8 ; r ++ ) { rgb [ i ++ ] = Swap16IfLE ( r * 65535 / 7 ) ; rgb [ i ++ ] = Swap16IfLE ( g * 65535 / 7 ) ; rgb [ i ++ ] = Swap16IfLE ( b * 65535 / 3 ) ; } } } len += 256 * 3 * 2 ; <S2SV_StartBug> if ( rfbWriteExact ( cl , buf , len ) < 0 ) { <S2SV_EndBug> rfbLogPerror ( \"rfbSetClientColourMapBGR233:<S2SV_blank>write\" ) ; rfbCloseClient ( cl ) ; return FALSE ; } return TRUE ; }\n","target":"<S2SV_ModStart> cl ) { union { char bytes <S2SV_ModEnd> [ sz_rfbSetColourMapEntriesMsg + <S2SV_ModStart> ] ; rfbSetColourMapEntriesMsg msg ; } buf ; rfbSetColourMapEntriesMsg * scme = & buf . msg <S2SV_ModEnd> ; uint16_t * <S2SV_ModStart> ( & buf . bytes <S2SV_ModStart> cl , buf . bytes\n","project_and_commit_id":"LibVNC@libvncserver/53073c8d7e232151ea2ecd8a1243124121e10e2d","cve_id":"CVE-2020-14400","original_address":"https://github.com/LibVNC/libvncserver/commit/53073c8d7e232151ea2ecd8a1243124121e10e2d","time":"2020-06-17T16:15Z"},
	{"Unnamed: 0":3851,"cwe_id":"CWE-000","source":"CWE-000 int ext4_ext_get_blocks ( handle_t * handle , struct inode * inode , ext4_lblk_t iblock , unsigned int max_blocks , struct buffer_head * bh_result , int flags ) { struct ext4_ext_path * path = NULL ; struct ext4_extent_header * eh ; struct ext4_extent newex , * ex , * last_ex ; ext4_fsblk_t newblock ; int err = 0 , depth , ret , cache_type ; unsigned int allocated = 0 ; struct ext4_allocation_request ar ; ext4_io_end_t * io = EXT4_I ( inode ) -> cur_aio_dio ; __clear_bit ( BH_New , & bh_result -> b_state ) ; ext_debug ( \"blocks<S2SV_blank>%u/%u<S2SV_blank>requested<S2SV_blank>for<S2SV_blank>inode<S2SV_blank>%lu\\\\n\" , iblock , max_blocks , inode -> i_ino ) ; cache_type = ext4_ext_in_cache ( inode , iblock , & newex ) ; if ( cache_type ) { if ( cache_type == EXT4_EXT_CACHE_GAP ) { if ( ( flags & EXT4_GET_BLOCKS_CREATE ) == 0 ) { goto out2 ; } } else if ( cache_type == EXT4_EXT_CACHE_EXTENT ) { newblock = iblock - le32_to_cpu ( newex . ee_block ) + ext_pblock ( & newex ) ; allocated = ext4_ext_get_actual_len ( & newex ) - ( iblock - le32_to_cpu ( newex . ee_block ) ) ; goto out ; } else { BUG ( ) ; } } path = ext4_ext_find_extent ( inode , iblock , NULL ) ; if ( IS_ERR ( path ) ) { err = PTR_ERR ( path ) ; path = NULL ; goto out2 ; } depth = ext_depth ( inode ) ; if ( path [ depth ] . p_ext == NULL && depth != 0 ) { ext4_error ( inode -> i_sb , \"bad<S2SV_blank>extent<S2SV_blank>address<S2SV_blank>\" \"inode:<S2SV_blank>%lu,<S2SV_blank>iblock:<S2SV_blank>%d,<S2SV_blank>depth:<S2SV_blank>%d\" , inode -> i_ino , iblock , depth ) ; err = - EIO ; goto out2 ; } eh = path [ depth ] . p_hdr ; ex = path [ depth ] . p_ext ; if ( ex ) { ext4_lblk_t ee_block = le32_to_cpu ( ex -> ee_block ) ; ext4_fsblk_t ee_start = ext_pblock ( ex ) ; unsigned short ee_len ; ee_len = ext4_ext_get_actual_len ( ex ) ; if ( iblock >= ee_block && iblock < ee_block + ee_len ) { newblock = iblock - ee_block + ee_start ; allocated = ee_len - ( iblock - ee_block ) ; ext_debug ( \"%u<S2SV_blank>fit<S2SV_blank>into<S2SV_blank>%u:%d<S2SV_blank>-><S2SV_blank>%llu\\\\n\" , iblock , ee_block , ee_len , newblock ) ; if ( ! ext4_ext_is_uninitialized ( ex ) ) { ext4_ext_put_in_cache ( inode , ee_block , ee_len , ee_start , EXT4_EXT_CACHE_EXTENT ) ; goto out ; } ret = ext4_ext_handle_uninitialized_extents ( handle , inode , iblock , max_blocks , path , flags , allocated , bh_result , newblock ) ; return ret ; } } if ( ( flags & EXT4_GET_BLOCKS_CREATE ) == 0 ) { ext4_ext_put_gap_in_cache ( inode , path , iblock ) ; goto out2 ; } ar . lleft = iblock ; err = ext4_ext_search_left ( inode , path , & ar . lleft , & ar . pleft ) ; if ( err ) goto out2 ; ar . lright = iblock ; err = ext4_ext_search_right ( inode , path , & ar . lright , & ar . pright ) ; if ( err ) goto out2 ; if ( max_blocks > EXT_INIT_MAX_LEN && ! ( flags & EXT4_GET_BLOCKS_UNINIT_EXT ) ) max_blocks = EXT_INIT_MAX_LEN ; else if ( max_blocks > EXT_UNINIT_MAX_LEN && ( flags & EXT4_GET_BLOCKS_UNINIT_EXT ) ) max_blocks = EXT_UNINIT_MAX_LEN ; newex . ee_block = cpu_to_le32 ( iblock ) ; newex . ee_len = cpu_to_le16 ( max_blocks ) ; err = ext4_ext_check_overlap ( inode , & newex , path ) ; if ( err ) allocated = ext4_ext_get_actual_len ( & newex ) ; else allocated = max_blocks ; ar . inode = inode ; ar . goal = ext4_ext_find_goal ( inode , path , iblock ) ; ar . logical = iblock ; ar . len = allocated ; if ( S_ISREG ( inode -> i_mode ) ) ar . flags = EXT4_MB_HINT_DATA ; else ar . flags = 0 ; newblock = ext4_mb_new_blocks ( handle , & ar , & err ) ; if ( ! newblock ) goto out2 ; ext_debug ( \"allocate<S2SV_blank>new<S2SV_blank>block:<S2SV_blank>goal<S2SV_blank>%llu,<S2SV_blank>found<S2SV_blank>%llu/%u\\\\n\" , ar . goal , newblock , allocated ) ; ext4_ext_store_pblock ( & newex , newblock ) ; newex . ee_len = cpu_to_le16 ( ar . len ) ; if ( flags & EXT4_GET_BLOCKS_UNINIT_EXT ) { ext4_ext_mark_uninitialized ( & newex ) ; <S2SV_StartBug> if ( flags == EXT4_GET_BLOCKS_PRE_IO ) { <S2SV_EndBug> if ( io ) io -> flag = EXT4_IO_UNWRITTEN ; else ext4_set_inode_state ( inode , EXT4_STATE_DIO_UNWRITTEN ) ; <S2SV_StartBug> } <S2SV_EndBug> } if ( unlikely ( EXT4_I ( inode ) -> i_flags & EXT4_EOFBLOCKS_FL ) ) { if ( eh -> eh_entries ) { last_ex = EXT_LAST_EXTENT ( eh ) ; if ( iblock + ar . len > le32_to_cpu ( last_ex -> ee_block ) + ext4_ext_get_actual_len ( last_ex ) ) EXT4_I ( inode ) -> i_flags &= ~ EXT4_EOFBLOCKS_FL ; } else { WARN_ON ( eh -> eh_entries == 0 ) ; ext4_error ( inode -> i_sb , __func__ , \"inode#%lu,<S2SV_blank>eh->eh_entries<S2SV_blank>=<S2SV_blank>0!\" , inode -> i_ino ) ; } } err = ext4_ext_insert_extent ( handle , inode , path , & newex , flags ) ; if ( err ) { ext4_discard_preallocations ( inode ) ; ext4_free_blocks ( handle , inode , 0 , ext_pblock ( & newex ) , ext4_ext_get_actual_len ( & newex ) , 0 ) ; goto out2 ; } newblock = ext_pblock ( & newex ) ; allocated = ext4_ext_get_actual_len ( & newex ) ; if ( allocated > max_blocks ) allocated = max_blocks ; set_buffer_new ( bh_result ) ; if ( flags & EXT4_GET_BLOCKS_DELALLOC_RESERVE ) ext4_da_update_reserve_space ( inode , allocated , 1 ) ; if ( ( flags & EXT4_GET_BLOCKS_UNINIT_EXT ) == 0 ) { ext4_ext_put_in_cache ( inode , iblock , allocated , newblock , EXT4_EXT_CACHE_EXTENT ) ; ext4_update_inode_fsync_trans ( handle , inode , 1 ) ; } else ext4_update_inode_fsync_trans ( handle , inode , 0 ) ; out : if ( allocated > max_blocks ) allocated = max_blocks ; ext4_ext_show_leaf ( inode , path ) ; set_buffer_mapped ( bh_result ) ; bh_result -> b_bdev = inode -> i_sb -> s_bdev ; bh_result -> b_blocknr = newblock ; out2 : if ( path ) { ext4_ext_drop_refs ( path ) ; kfree ( path ) ; } return err ? err : allocated ; }\n","target":"<S2SV_ModStart> ; if ( ( flags & EXT4_GET_BLOCKS_PRE_IO ) ) <S2SV_ModEnd> { if ( <S2SV_ModStart> ) ; } if ( ext4_should_dioread_nolock ( inode ) ) set_buffer_uninit ( bh_result ) ;\n","project_and_commit_id":"torvalds@linux/744692dc059845b2a3022119871846e74d4f6e11","cve_id":"CVE-2015-8324","original_address":"https://github.com/torvalds/linux/commit/744692dc059845b2a3022119871846e74d4f6e11","time":"2016-05-02T10:59Z"},
	{"Unnamed: 0":4138,"cwe_id":"CWE-476","source":"CWE-476 static int SMB2_sess_establish_session ( struct SMB2_sess_data * sess_data ) { int rc = 0 ; struct cifs_ses * ses = sess_data -> ses ; mutex_lock ( & ses -> server -> srv_mutex ) ; <S2SV_StartBug> if ( ses -> server -> sign && ses -> server -> ops -> generate_signingkey ) { <S2SV_EndBug> <S2SV_StartBug> rc = ses -> server -> ops -> generate_signingkey ( ses ) ; <S2SV_EndBug> kfree ( ses -> auth_key . response ) ; ses -> auth_key . response = NULL ; if ( rc ) { cifs_dbg ( FYI , \"SMB3<S2SV_blank>session<S2SV_blank>key<S2SV_blank>generation<S2SV_blank>failed\\\\n\" ) ; mutex_unlock ( & ses -> server -> srv_mutex ) ; <S2SV_StartBug> goto keygen_exit ; <S2SV_EndBug> } } if ( ! ses -> server -> session_estab ) { ses -> server -> sequence_number = 0x2 ; ses -> server -> session_estab = true ; } mutex_unlock ( & ses -> server -> srv_mutex ) ; cifs_dbg ( FYI , \"SMB2/3<S2SV_blank>session<S2SV_blank>established<S2SV_blank>successfully\\\\n\" ) ; spin_lock ( & GlobalMid_Lock ) ; ses -> status = CifsGood ; ses -> need_reconnect = false ; spin_unlock ( & GlobalMid_Lock ) ; <S2SV_StartBug> keygen_exit : <S2SV_EndBug> if ( ! ses -> server -> sign ) { kfree ( ses -> auth_key . response ) ; ses -> auth_key . response = NULL ; } return rc ; }\n","target":"<S2SV_ModStart> -> server -> <S2SV_ModEnd> ops -> generate_signingkey <S2SV_ModStart> ( ses ) <S2SV_ModEnd> ; if ( <S2SV_ModStart> srv_mutex ) ; return rc <S2SV_ModEnd> ; } } <S2SV_ModStart> GlobalMid_Lock ) ; <S2SV_ModEnd> return rc ;\n","project_and_commit_id":"torvalds@linux/cabfb3680f78981d26c078a26e5c748531257ebb","cve_id":"CVE-2018-1066","original_address":"https://github.com/torvalds/linux/commit/cabfb3680f78981d26c078a26e5c748531257ebb","time":"2018-03-02T08:29Z"},
	{"Unnamed: 0":4320,"cwe_id":"CWE-17","source":"CWE-17 <S2SV_StartBug> int udf_get_filename ( struct super_block * sb , uint8_t * sname , uint8_t * dname , <S2SV_EndBug> <S2SV_StartBug> int flen ) <S2SV_EndBug> { struct ustr * filename , * unifilename ; int len = 0 ; filename = kmalloc ( sizeof ( struct ustr ) , GFP_NOFS ) ; if ( ! filename ) return 0 ; unifilename = kmalloc ( sizeof ( struct ustr ) , GFP_NOFS ) ; if ( ! unifilename ) goto out1 ; <S2SV_StartBug> if ( udf_build_ustr_exact ( unifilename , sname , flen ) ) <S2SV_EndBug> goto out2 ; if ( UDF_QUERY_FLAG ( sb , UDF_FLAG_UTF8 ) ) { if ( ! udf_CS0toUTF8 ( filename , unifilename ) ) { udf_debug ( \"Failed<S2SV_blank>in<S2SV_blank>udf_get_filename:<S2SV_blank>sname<S2SV_blank>=<S2SV_blank>%s\\\\n\" , sname ) ; goto out2 ; } } else if ( UDF_QUERY_FLAG ( sb , UDF_FLAG_NLS_MAP ) ) { if ( ! udf_CS0toNLS ( UDF_SB ( sb ) -> s_nls_map , filename , unifilename ) ) { udf_debug ( \"Failed<S2SV_blank>in<S2SV_blank>udf_get_filename:<S2SV_blank>sname<S2SV_blank>=<S2SV_blank>%s\\\\n\" , sname ) ; goto out2 ; } } else goto out2 ; <S2SV_StartBug> len = udf_translate_to_linux ( dname , filename -> u_name , filename -> u_len , <S2SV_EndBug> unifilename -> u_name , unifilename -> u_len ) ; out2 : kfree ( unifilename ) ; out1 : kfree ( filename ) ; return len ; }\n","target":"<S2SV_ModStart> * sname , int slen , <S2SV_ModStart> * dname , int dlen <S2SV_ModEnd> ) { struct <S2SV_ModStart> , sname , slen <S2SV_ModEnd> ) ) goto <S2SV_ModStart> ( dname , dlen ,\n","project_and_commit_id":"torvalds@linux/0e5cc9a40ada6046e6bc3bdfcd0c0d7e4b706b14","cve_id":"CVE-2014-9731","original_address":"https://github.com/torvalds/linux/commit/0e5cc9a40ada6046e6bc3bdfcd0c0d7e4b706b14","time":"2015-08-31T10:59Z"},
	{"Unnamed: 0":778,"cwe_id":"CWE-416","source":"CWE-416 struct net * get_net_ns_by_id ( struct net * net , int id ) { struct net * peer ; if ( id < 0 ) return NULL ; rcu_read_lock ( ) ; spin_lock_bh ( & net -> nsid_lock ) ; peer = idr_find ( & net -> netns_ids , id ) ; if ( peer ) <S2SV_StartBug> get_net ( peer ) ; <S2SV_EndBug> spin_unlock_bh ( & net -> nsid_lock ) ; rcu_read_unlock ( ) ; return peer ; }\n","target":"<S2SV_ModStart> ( peer ) peer = maybe_get_net <S2SV_ModEnd> ( peer )\n","project_and_commit_id":"torvalds@linux/21b5944350052d2583e82dd59b19a9ba94a007f0","cve_id":"CVE-2017-15129","original_address":"https://github.com/torvalds/linux/commit/21b5944350052d2583e82dd59b19a9ba94a007f0","time":"2018-01-09T19:29Z"},
	{"Unnamed: 0":6657,"cwe_id":"CWE-20","source":"CWE-20 static void dns_resolver_describe ( const struct key * key , struct seq_file * m ) { seq_puts ( m , key -> description ) ; <S2SV_StartBug> if ( key_is_instantiated ( key ) ) { <S2SV_EndBug> int err = PTR_ERR ( key -> payload . data [ dns_key_error ] ) ; if ( err ) seq_printf ( m , \":<S2SV_blank>%d\" , err ) ; else seq_printf ( m , \":<S2SV_blank>%u\" , key -> datalen ) ; } }\n","target":"<S2SV_ModStart> ; if ( key_is_positive <S2SV_ModEnd> ( key )\n","project_and_commit_id":"torvalds@linux/363b02dab09b3226f3bd1420dad9c72b79a42a76","cve_id":"CVE-2017-15951","original_address":"https://github.com/torvalds/linux/commit/363b02dab09b3226f3bd1420dad9c72b79a42a76","time":"2017-10-28T02:29Z"},
	{"Unnamed: 0":364,"cwe_id":"CWE-119","source":"CWE-119 static void dump_boot ( DOS_FS * fs , struct boot_sector * b , unsigned lss ) { unsigned short sectors ; printf ( \"Boot<S2SV_blank>sector<S2SV_blank>contents:\\\\n\" ) ; if ( ! atari_format ) { char id [ 9 ] ; strncpy ( id , ( const char * ) b -> system_id , 8 ) ; id [ 8 ] = 0 ; printf ( \"System<S2SV_blank>ID<S2SV_blank>\\\\\"%s\\\\\"\\\\n\" , id ) ; } else { printf ( \"Serial<S2SV_blank>number<S2SV_blank>0x%x\\\\n\" , b -> system_id [ 5 ] | ( b -> system_id [ 6 ] << 8 ) | ( b -> system_id [ 7 ] << 16 ) ) ; } printf ( \"Media<S2SV_blank>byte<S2SV_blank>0x%02x<S2SV_blank>(%s)\\\\n\" , b -> media , get_media_descr ( b -> media ) ) ; printf ( \"%10d<S2SV_blank>bytes<S2SV_blank>per<S2SV_blank>logical<S2SV_blank>sector\\\\n\" , GET_UNALIGNED_W ( b -> sector_size ) ) ; printf ( \"%10d<S2SV_blank>bytes<S2SV_blank>per<S2SV_blank>cluster\\\\n\" , fs -> cluster_size ) ; printf ( \"%10d<S2SV_blank>reserved<S2SV_blank>sector%s\\\\n\" , le16toh ( b -> reserved ) , le16toh ( b -> reserved ) == 1 ? \"\" : \"s\" ) ; printf ( \"First<S2SV_blank>FAT<S2SV_blank>starts<S2SV_blank>at<S2SV_blank>byte<S2SV_blank>%llu<S2SV_blank>(sector<S2SV_blank>%llu)\\\\n\" , ( unsigned long long ) fs -> fat_start , ( unsigned long long ) fs -> fat_start / lss ) ; printf ( \"%10d<S2SV_blank>FATs,<S2SV_blank>%d<S2SV_blank>bit<S2SV_blank>entries\\\\n\" , b -> fats , fs -> fat_bits ) ; <S2SV_StartBug> printf ( \"%10d<S2SV_blank>bytes<S2SV_blank>per<S2SV_blank>FAT<S2SV_blank>(=<S2SV_blank>%u<S2SV_blank>sectors)\\\\n\" , fs -> fat_size , <S2SV_EndBug> <S2SV_StartBug> fs -> fat_size / lss ) ; <S2SV_EndBug> if ( ! fs -> root_cluster ) { printf ( \"Root<S2SV_blank>directory<S2SV_blank>starts<S2SV_blank>at<S2SV_blank>byte<S2SV_blank>%llu<S2SV_blank>(sector<S2SV_blank>%llu)\\\\n\" , ( unsigned long long ) fs -> root_start , ( unsigned long long ) fs -> root_start / lss ) ; printf ( \"%10d<S2SV_blank>root<S2SV_blank>directory<S2SV_blank>entries\\\\n\" , fs -> root_entries ) ; } else { printf ( \"Root<S2SV_blank>directory<S2SV_blank>start<S2SV_blank>at<S2SV_blank>cluster<S2SV_blank>%lu<S2SV_blank>(arbitrary<S2SV_blank>size)\\\\n\" , ( unsigned long ) fs -> root_cluster ) ; } printf ( \"Data<S2SV_blank>area<S2SV_blank>starts<S2SV_blank>at<S2SV_blank>byte<S2SV_blank>%llu<S2SV_blank>(sector<S2SV_blank>%llu)\\\\n\" , ( unsigned long long ) fs -> data_start , ( unsigned long long ) fs -> data_start / lss ) ; printf ( \"%10lu<S2SV_blank>data<S2SV_blank>clusters<S2SV_blank>(%llu<S2SV_blank>bytes)\\\\n\" , ( unsigned long ) fs -> data_clusters , ( unsigned long long ) fs -> data_clusters * fs -> cluster_size ) ; printf ( \"%u<S2SV_blank>sectors/track,<S2SV_blank>%u<S2SV_blank>heads\\\\n\" , le16toh ( b -> secs_track ) , le16toh ( b -> heads ) ) ; printf ( \"%10u<S2SV_blank>hidden<S2SV_blank>sectors\\\\n\" , atari_format ? ( ( ( unsigned char * ) & b -> hidden ) [ 0 ] | ( ( unsigned char * ) & b -> hidden ) [ 1 ] << 8 ) : le32toh ( b -> hidden ) ) ; sectors = GET_UNALIGNED_W ( b -> sectors ) ; printf ( \"%10u<S2SV_blank>sectors<S2SV_blank>total\\\\n\" , sectors ? sectors : le32toh ( b -> total_sect ) ) ; }\n","target":"<S2SV_ModStart> ; printf ( \"%10lld<S2SV_blank>bytes<S2SV_blank>per<S2SV_blank>FAT<S2SV_blank>(=<S2SV_blank>%llu<S2SV_blank>sectors)\\\\n\" , ( long long ) <S2SV_ModEnd> fs -> fat_size <S2SV_ModStart> -> fat_size , ( long long )\n","project_and_commit_id":"dosfstools@dosfstools/e8eff147e9da1185f9afd5b25948153a3b97cf52","cve_id":"CVE-2016-4804","original_address":"https://github.com/dosfstools/dosfstools/commit/e8eff147e9da1185f9afd5b25948153a3b97cf52","time":"2016-06-03T14:59Z"},
	{"Unnamed: 0":5208,"cwe_id":"CWE-119","source":"CWE-119 static ssize_t cifs_iovec_write ( struct file * file , const struct iovec * iov , unsigned long nr_segs , loff_t * poffset ) { unsigned long nr_pages , i ; <S2SV_StartBug> size_t copied , len , cur_len ; <S2SV_EndBug> ssize_t total_written = 0 ; loff_t offset ; struct iov_iter it ; struct cifsFileInfo * open_file ; struct cifs_tcon * tcon ; struct cifs_sb_info * cifs_sb ; struct cifs_writedata * wdata , * tmp ; struct list_head wdata_list ; int rc ; pid_t pid ; len = iov_length ( iov , nr_segs ) ; if ( ! len ) return 0 ; rc = generic_write_checks ( file , poffset , & len , 0 ) ; if ( rc ) return rc ; INIT_LIST_HEAD ( & wdata_list ) ; cifs_sb = CIFS_SB ( file -> f_path . dentry -> d_sb ) ; open_file = file -> private_data ; tcon = tlink_tcon ( open_file -> tlink ) ; if ( ! tcon -> ses -> server -> ops -> async_writev ) return - ENOSYS ; offset = * poffset ; if ( cifs_sb -> mnt_cifs_flags & CIFS_MOUNT_RWPIDFORWARD ) pid = open_file -> pid ; else pid = current -> tgid ; iov_iter_init ( & it , iov , nr_segs , len , 0 ) ; do { size_t save_len ; nr_pages = get_numpages ( cifs_sb -> wsize , len , & cur_len ) ; wdata = cifs_writedata_alloc ( nr_pages , cifs_uncached_writev_complete ) ; if ( ! wdata ) { rc = - ENOMEM ; break ; } rc = cifs_write_allocate_pages ( wdata -> pages , nr_pages ) ; if ( rc ) { kfree ( wdata ) ; break ; } save_len = cur_len ; for ( i = 0 ; i < nr_pages ; i ++ ) { <S2SV_StartBug> copied = min_t ( const size_t , cur_len , PAGE_SIZE ) ; <S2SV_EndBug> copied = iov_iter_copy_from_user ( wdata -> pages [ i ] , & it , <S2SV_StartBug> 0 , copied ) ; <S2SV_EndBug> cur_len -= copied ; iov_iter_advance ( & it , copied ) ; <S2SV_StartBug> } <S2SV_EndBug> <S2SV_StartBug> cur_len = save_len - cur_len ; <S2SV_EndBug> wdata -> sync_mode = WB_SYNC_ALL ; wdata -> nr_pages = nr_pages ; wdata -> offset = ( __u64 ) offset ; wdata -> cfile = cifsFileInfo_get ( open_file ) ; wdata -> pid = pid ; wdata -> bytes = cur_len ; wdata -> pagesz = PAGE_SIZE ; wdata -> tailsz = cur_len - ( ( nr_pages - 1 ) * PAGE_SIZE ) ; rc = cifs_uncached_retry_writev ( wdata ) ; if ( rc ) { kref_put ( & wdata -> refcount , cifs_uncached_writedata_release ) ; break ; } list_add_tail ( & wdata -> list , & wdata_list ) ; offset += cur_len ; len -= cur_len ; } while ( len > 0 ) ; if ( ! list_empty ( & wdata_list ) ) rc = 0 ; restart_loop : list_for_each_entry_safe ( wdata , tmp , & wdata_list , list ) { if ( ! rc ) { rc = wait_for_completion_killable ( & wdata -> done ) ; if ( rc ) rc = - EINTR ; else if ( wdata -> result ) rc = wdata -> result ; else total_written += wdata -> bytes ; if ( rc == - EAGAIN ) { rc = cifs_uncached_retry_writev ( wdata ) ; goto restart_loop ; } } list_del_init ( & wdata -> list ) ; kref_put ( & wdata -> refcount , cifs_uncached_writedata_release ) ; } if ( total_written > 0 ) * poffset += total_written ; cifs_stats_bytes_written ( tcon , total_written ) ; return total_written ? total_written : ( ssize_t ) rc ; }\n","target":"<S2SV_ModStart> i ; size_t bytes , <S2SV_ModStart> ++ ) { bytes <S2SV_ModEnd> = min_t ( <S2SV_ModStart> , 0 , bytes <S2SV_ModEnd> ) ; cur_len <S2SV_ModStart> copied ) ; if ( copied < bytes ) break ; <S2SV_ModStart> save_len - cur_len ; if ( ! cur_len ) { for ( i = 0 ; i < nr_pages ; i ++ ) put_page ( wdata -> pages [ i ] ) ; kfree ( wdata ) ; rc = - EFAULT ; break ; } for ( ; nr_pages > i + 1 ; nr_pages -- ) put_page ( wdata -> pages [ nr_pages - 1 ] )\n","project_and_commit_id":"torvalds@linux/5d81de8e8667da7135d3a32a964087c0faf5483f","cve_id":"CVE-2014-0069","original_address":"https://github.com/torvalds/linux/commit/5d81de8e8667da7135d3a32a964087c0faf5483f","time":"2014-02-28T06:18Z"},
	{"Unnamed: 0":2352,"cwe_id":"CWE-17","source":"CWE-17 struct file * get_empty_filp ( void ) { const struct cred * cred = current_cred ( ) ; static long old_max ; struct file * f ; int error ; if ( get_nr_files ( ) >= files_stat . max_files && ! capable ( CAP_SYS_ADMIN ) ) { if ( percpu_counter_sum_positive ( & nr_files ) >= files_stat . max_files ) goto over ; } f = kmem_cache_zalloc ( filp_cachep , GFP_KERNEL ) ; if ( unlikely ( ! f ) ) return ERR_PTR ( - ENOMEM ) ; percpu_counter_inc ( & nr_files ) ; f -> f_cred = get_cred ( cred ) ; error = security_file_alloc ( f ) ; if ( unlikely ( error ) ) { file_free ( f ) ; return ERR_PTR ( error ) ; } <S2SV_StartBug> INIT_LIST_HEAD ( & f -> f_u . fu_list ) ; <S2SV_EndBug> atomic_long_set ( & f -> f_count , 1 ) ; rwlock_init ( & f -> f_owner . lock ) ; spin_lock_init ( & f -> f_lock ) ; eventpoll_init_file ( f ) ; return f ; over : if ( get_nr_files ( ) > old_max ) { pr_info ( \"VFS:<S2SV_blank>file-max<S2SV_blank>limit<S2SV_blank>%lu<S2SV_blank>reached\\\\n\" , get_max_files ( ) ) ; old_max = get_nr_files ( ) ; } return ERR_PTR ( - ENFILE ) ; }\n","target":"<S2SV_ModStart> ) ; } <S2SV_ModEnd> atomic_long_set ( &\n","project_and_commit_id":"torvalds@linux/eee5cc2702929fd41cce28058dc6d6717f723f87","cve_id":"CVE-2014-8172","original_address":"https://github.com/torvalds/linux/commit/eee5cc2702929fd41cce28058dc6d6717f723f87","time":"2015-03-16T10:59Z"},
	{"Unnamed: 0":6668,"cwe_id":"CWE-200","source":"CWE-200 int dse_bind ( Slapi_PBlock * pb ) { ber_tag_t method ; struct berval * cred ; Slapi_Value * * bvals ; struct dse * pdse ; Slapi_Attr * attr ; Slapi_DN * sdn = NULL ; Slapi_Entry * ec = NULL ; if ( slapi_pblock_get ( pb , SLAPI_PLUGIN_PRIVATE , & pdse ) < 0 || slapi_pblock_get ( pb , SLAPI_BIND_TARGET_SDN , & sdn ) < 0 || slapi_pblock_get ( pb , SLAPI_BIND_METHOD , & method ) < 0 || slapi_pblock_get ( pb , SLAPI_BIND_CREDENTIALS , & cred ) < 0 ) { slapi_send_ldap_result ( pb , LDAP_OPERATIONS_ERROR , NULL , NULL , 0 , NULL ) ; return SLAPI_BIND_FAIL ; } if ( method == LDAP_AUTH_SIMPLE && cred -> bv_len == 0 ) { slapi_send_ldap_result ( pb , LDAP_SUCCESS , NULL , NULL , 0 , NULL ) ; return ( SLAPI_BIND_FAIL ) ; } ec = dse_get_entry_copy ( pdse , sdn , DSE_USE_LOCK ) ; if ( ec == NULL ) { <S2SV_StartBug> slapi_send_ldap_result ( pb , LDAP_NO_SUCH_OBJECT , NULL , NULL , 0 , NULL ) ; <S2SV_EndBug> return ( SLAPI_BIND_FAIL ) ; } switch ( method ) { case LDAP_AUTH_SIMPLE : { Slapi_Value cv ; if ( slapi_entry_attr_find ( ec , \"userpassword\" , & attr ) != 0 ) { <S2SV_StartBug> slapi_send_ldap_result ( pb , LDAP_INAPPROPRIATE_AUTH , NULL , NULL , 0 , NULL ) ; <S2SV_EndBug> slapi_entry_free ( ec ) ; return SLAPI_BIND_FAIL ; } bvals = attr_get_present_values ( attr ) ; slapi_value_init_berval ( & cv , cred ) ; if ( slapi_pw_find_sv ( bvals , & cv ) != 0 ) { <S2SV_StartBug> slapi_send_ldap_result ( pb , LDAP_INVALID_CREDENTIALS , NULL , NULL , 0 , NULL ) ; <S2SV_EndBug> slapi_entry_free ( ec ) ; value_done ( & cv ) ; return SLAPI_BIND_FAIL ; } value_done ( & cv ) ; } break ; default : slapi_send_ldap_result ( pb , LDAP_STRONG_AUTH_NOT_SUPPORTED , NULL , \"auth<S2SV_blank>method<S2SV_blank>not<S2SV_blank>supported\" , 0 , NULL ) ; slapi_entry_free ( ec ) ; return SLAPI_BIND_FAIL ; } slapi_entry_free ( ec ) ; return SLAPI_BIND_SUCCESS ; }\n","target":"<S2SV_ModStart> NULL ) { slapi_pblock_set ( pb , SLAPI_PB_RESULT_TEXT , \"Entry<S2SV_blank>does<S2SV_blank>not<S2SV_blank>exist\" ) ; slapi_send_ldap_result ( pb , LDAP_INVALID_CREDENTIALS <S2SV_ModEnd> , NULL , <S2SV_ModStart> 0 ) { slapi_pblock_set ( pb , SLAPI_PB_RESULT_TEXT , \"Entry<S2SV_blank>does<S2SV_blank>not<S2SV_blank>have<S2SV_blank>userpassword<S2SV_blank>set\" ) ; slapi_send_ldap_result ( pb , LDAP_INVALID_CREDENTIALS <S2SV_ModEnd> , NULL , <S2SV_ModStart> 0 ) { slapi_pblock_set ( pb , SLAPI_PB_RESULT_TEXT , \"Invalid<S2SV_blank>credentials\" ) ;\n","project_and_commit_id":"389ds@389-ds-base/b6aae4d8e7c8a6ddd21646f94fef1bf7f22c3f32","cve_id":"CVE-2020-35518","original_address":"https://github.com/389ds/389-ds-base/commit/b6aae4d8e7c8a6ddd21646f94fef1bf7f22c3f32","time":"2021-03-26T17:15Z"},
	{"Unnamed: 0":4920,"cwe_id":"CWE-200","source":"CWE-200 int main ( int argc , char * * argv ) { int fd = xopen ( \"/dev/null\" , O_RDWR ) ; while ( fd < 2 ) fd = xdup ( fd ) ; if ( fd > 2 ) close ( fd ) ; if ( argc < 8 ) { error_msg_and_die ( \"Usage:<S2SV_blank>%s<S2SV_blank>SIGNO<S2SV_blank>CORE_SIZE_LIMIT<S2SV_blank>PID<S2SV_blank>UID<S2SV_blank>GID<S2SV_blank>TIME<S2SV_blank>BINARY_NAME<S2SV_blank>[HOSTNAME]\" , argv [ 0 ] ) ; } if ( strchr ( argv [ 1 ] , '<S2SV_blank>' ) ) { int i ; for ( i = 1 ; argv [ i ] ; i ++ ) { strchrnul ( argv [ i ] , '<S2SV_blank>' ) [ 0 ] = '\\\\0' ; } } logmode = LOGMODE_JOURNAL ; load_abrt_conf ( ) ; bool setting_MakeCompatCore ; bool setting_SaveBinaryImage ; { map_string_t * settings = new_map_string ( ) ; load_abrt_plugin_conf_file ( \"CCpp.conf\" , settings ) ; const char * value ; value = get_map_string_item_or_NULL ( settings , \"MakeCompatCore\" ) ; setting_MakeCompatCore = value && string_to_bool ( value ) ; value = get_map_string_item_or_NULL ( settings , \"SaveBinaryImage\" ) ; setting_SaveBinaryImage = value && string_to_bool ( value ) ; value = get_map_string_item_or_NULL ( settings , \"VerboseLog\" ) ; if ( value ) g_verbose = xatoi_positive ( value ) ; free_map_string ( settings ) ; } errno = 0 ; const char * signal_str = argv [ 1 ] ; int signal_no = xatoi_positive ( signal_str ) ; off_t ulimit_c = strtoull ( argv [ 2 ] , NULL , 10 ) ; if ( ulimit_c < 0 ) { ulimit_c = ~ ( ( off_t ) 1 << ( sizeof ( off_t ) * 8 - 1 ) ) ; } const char * pid_str = argv [ 3 ] ; pid_t pid = xatoi_positive ( argv [ 3 ] ) ; uid_t uid = xatoi_positive ( argv [ 4 ] ) ; if ( errno || pid <= 0 ) { perror_msg_and_die ( \"PID<S2SV_blank>\\'%s\\'<S2SV_blank>or<S2SV_blank>limit<S2SV_blank>\\'%s\\'<S2SV_blank>is<S2SV_blank>bogus\" , argv [ 3 ] , argv [ 2 ] ) ; } { char * s = xmalloc_fopen_fgetline_fclose ( VAR_RUN \"/abrt/saved_core_pattern\" ) ; if ( s && s [ 0 ] != '|' ) core_basename = s ; else free ( s ) ; } struct utsname uts ; if ( ! argv [ 8 ] ) { uname ( & uts ) ; argv [ 8 ] = uts . nodename ; } char path [ PATH_MAX ] ; int src_fd_binary = - 1 ; char * executable = get_executable ( pid , setting_SaveBinaryImage ? & src_fd_binary : NULL ) ; if ( executable && strstr ( executable , \"/abrt-hook-ccpp\" ) ) { error_msg_and_die ( \"PID<S2SV_blank>%lu<S2SV_blank>is<S2SV_blank>\\'%s\\',<S2SV_blank>not<S2SV_blank>dumping<S2SV_blank>it<S2SV_blank>to<S2SV_blank>avoid<S2SV_blank>recursion\" , ( long ) pid , executable ) ; } user_pwd = get_cwd ( pid ) ; log_notice ( \"user_pwd:\\'%s\\'\" , user_pwd ) ; sprintf ( path , \"/proc/%lu/status\" , ( long ) pid ) ; proc_pid_status = xmalloc_xopen_read_close ( path , NULL ) ; uid_t fsuid = uid ; uid_t tmp_fsuid = get_fsuid ( ) ; int suid_policy = dump_suid_policy ( ) ; if ( tmp_fsuid != uid ) { fsuid = 0 ; if ( suid_policy == DUMP_SUID_UNSAFE ) fsuid = tmp_fsuid ; else { g_user_core_flags = O_EXCL ; g_need_nonrelative = 1 ; } } <S2SV_StartBug> if ( setting_MakeCompatCore && ulimit_c != 0 ) <S2SV_EndBug> user_core_fd = open_user_core ( uid , fsuid , pid , & argv [ 1 ] ) ; if ( executable == NULL ) { error_msg ( \"Can\\'t<S2SV_blank>read<S2SV_blank>/proc/%lu/exe<S2SV_blank>link\" , ( long ) pid ) ; goto create_user_core ; } const char * signame = NULL ; switch ( signal_no ) { case SIGILL : signame = \"ILL\" ; break ; case SIGFPE : signame = \"FPE\" ; break ; case SIGSEGV : signame = \"SEGV\" ; break ; case SIGBUS : signame = \"BUS\" ; break ; case SIGABRT : signame = \"ABRT\" ; break ; case SIGTRAP : signame = \"TRAP\" ; break ; default : goto create_user_core ; } if ( ! daemon_is_ok ( ) ) { log ( \"abrtd<S2SV_blank>is<S2SV_blank>not<S2SV_blank>running.<S2SV_blank>If<S2SV_blank>it<S2SV_blank>crashed,<S2SV_blank>\" \"/proc/sys/kernel/core_pattern<S2SV_blank>contains<S2SV_blank>a<S2SV_blank>stale<S2SV_blank>value,<S2SV_blank>\" \"consider<S2SV_blank>resetting<S2SV_blank>it<S2SV_blank>to<S2SV_blank>\\'core\\'\" ) ; goto create_user_core ; } if ( g_settings_nMaxCrashReportsSize > 0 ) { if ( low_free_space ( g_settings_nMaxCrashReportsSize , g_settings_dump_location ) ) goto create_user_core ; } snprintf ( path , sizeof ( path ) , \"%s/last-ccpp\" , g_settings_dump_location ) ; if ( check_recent_crash_file ( path , executable ) ) { goto create_user_core ; } const char * last_slash = strrchr ( executable , '/' ) ; if ( last_slash && strncmp ( ++ last_slash , \"abrt\" , 4 ) == 0 ) { if ( snprintf ( path , sizeof ( path ) , \"%s/%s-coredump\" , g_settings_dump_location , last_slash ) >= sizeof ( path ) ) error_msg_and_die ( \"Error<S2SV_blank>saving<S2SV_blank>\\'%s\\':<S2SV_blank>truncated<S2SV_blank>long<S2SV_blank>file<S2SV_blank>path\" , path ) ; int abrt_core_fd = xopen3 ( path , O_WRONLY | O_CREAT | O_TRUNC , 0600 ) ; off_t core_size = copyfd_eof ( STDIN_FILENO , abrt_core_fd , COPYFD_SPARSE ) ; if ( core_size < 0 || fsync ( abrt_core_fd ) != 0 ) { unlink ( path ) ; error_msg_and_die ( \"Error<S2SV_blank>saving<S2SV_blank>\\'%s\\'\" , path ) ; } log ( \"Saved<S2SV_blank>core<S2SV_blank>dump<S2SV_blank>of<S2SV_blank>pid<S2SV_blank>%lu<S2SV_blank>(%s)<S2SV_blank>to<S2SV_blank>%s<S2SV_blank>(%llu<S2SV_blank>bytes)\" , ( long ) pid , executable , path , ( long long ) core_size ) ; if ( proc_cwd != NULL ) closedir ( proc_cwd ) ; return 0 ; } unsigned path_len = snprintf ( path , sizeof ( path ) , \"%s/ccpp-%s-%lu.new\" , g_settings_dump_location , iso_date_string ( NULL ) , ( long ) pid ) ; if ( path_len >= ( sizeof ( path ) - sizeof ( \"/\" FILENAME_COREDUMP ) ) ) { goto create_user_core ; } <S2SV_StartBug> dd = dd_create_skeleton ( path , fsuid , DEFAULT_DUMP_DIR_MODE , 0 ) ; <S2SV_EndBug> if ( dd ) { char * rootdir = get_rootdir ( pid ) ; dd_create_basic_files ( dd , fsuid , NULL ) ; char source_filename [ sizeof ( \"/proc/%lu/somewhat_long_name\" ) + sizeof ( long ) * 3 ] ; int source_base_ofs = sprintf ( source_filename , \"/proc/%lu/smaps\" , ( long ) pid ) ; source_base_ofs -= strlen ( \"smaps\" ) ; char * dest_filename = concat_path_file ( dd -> dd_dirname , \"also_somewhat_longish_name\" ) ; char * dest_base = strrchr ( dest_filename , '/' ) + 1 ; strcpy ( source_filename + source_base_ofs , \"maps\" ) ; strcpy ( dest_base , FILENAME_MAPS ) ; copy_file_ext ( source_filename , dest_filename , 0640 , dd -> dd_uid , dd -> dd_gid , O_RDONLY , O_WRONLY | O_CREAT | O_TRUNC | O_EXCL ) ; strcpy ( source_filename + source_base_ofs , \"limits\" ) ; strcpy ( dest_base , FILENAME_LIMITS ) ; copy_file_ext ( source_filename , dest_filename , 0640 , dd -> dd_uid , dd -> dd_gid , O_RDONLY , O_WRONLY | O_CREAT | O_TRUNC | O_EXCL ) ; strcpy ( source_filename + source_base_ofs , \"cgroup\" ) ; strcpy ( dest_base , FILENAME_CGROUP ) ; copy_file_ext ( source_filename , dest_filename , 0640 , dd -> dd_uid , dd -> dd_gid , O_RDONLY , O_WRONLY | O_CREAT | O_TRUNC | O_EXCL ) ; strcpy ( dest_base , FILENAME_OPEN_FDS ) ; dump_fd_info ( dest_filename , source_filename , source_base_ofs , dd -> dd_uid , dd -> dd_gid ) ; free ( dest_filename ) ; dd_save_text ( dd , FILENAME_ANALYZER , \"CCpp\" ) ; dd_save_text ( dd , FILENAME_TYPE , \"CCpp\" ) ; dd_save_text ( dd , FILENAME_EXECUTABLE , executable ) ; dd_save_text ( dd , FILENAME_PID , pid_str ) ; dd_save_text ( dd , FILENAME_PROC_PID_STATUS , proc_pid_status ) ; if ( user_pwd ) dd_save_text ( dd , FILENAME_PWD , user_pwd ) ; if ( rootdir ) { if ( strcmp ( rootdir , \"/\" ) != 0 ) dd_save_text ( dd , FILENAME_ROOTDIR , rootdir ) ; } char * reason = xasprintf ( \"%s<S2SV_blank>killed<S2SV_blank>by<S2SV_blank>SIG%s\" , last_slash , signame ? signame : signal_str ) ; dd_save_text ( dd , FILENAME_REASON , reason ) ; free ( reason ) ; char * cmdline = get_cmdline ( pid ) ; dd_save_text ( dd , FILENAME_CMDLINE , cmdline ? : \"\" ) ; free ( cmdline ) ; char * environ = get_environ ( pid ) ; dd_save_text ( dd , FILENAME_ENVIRON , environ ? : \"\" ) ; free ( environ ) ; char * fips_enabled = xmalloc_fopen_fgetline_fclose ( \"/proc/sys/crypto/fips_enabled\" ) ; if ( fips_enabled ) { if ( strcmp ( fips_enabled , \"0\" ) != 0 ) dd_save_text ( dd , \"fips_enabled\" , fips_enabled ) ; free ( fips_enabled ) ; } dd_save_text ( dd , FILENAME_ABRT_VERSION , VERSION ) ; if ( src_fd_binary > 0 ) { strcpy ( path + path_len , \"/\" FILENAME_BINARY ) ; int dst_fd = create_or_die ( path ) ; off_t sz = copyfd_eof ( src_fd_binary , dst_fd , COPYFD_SPARSE ) ; if ( fsync ( dst_fd ) != 0 || close ( dst_fd ) != 0 || sz < 0 ) { dd_delete ( dd ) ; error_msg_and_die ( \"Error<S2SV_blank>saving<S2SV_blank>\\'%s\\'\" , path ) ; } close ( src_fd_binary ) ; } strcpy ( path + path_len , \"/\" FILENAME_COREDUMP ) ; int abrt_core_fd = create_or_die ( path ) ; off_t core_size = copyfd_sparse ( STDIN_FILENO , abrt_core_fd , user_core_fd , ulimit_c ) ; if ( fsync ( abrt_core_fd ) != 0 || close ( abrt_core_fd ) != 0 || core_size < 0 ) { unlink ( path ) ; dd_delete ( dd ) ; if ( user_core_fd >= 0 ) unlinkat ( dirfd ( proc_cwd ) , core_basename , 0 ) ; error_msg_and_die ( \"Error<S2SV_blank>writing<S2SV_blank>\\'%s\\'\" , path ) ; } if ( user_core_fd >= 0 && ( fsync ( user_core_fd ) != 0 || close ( user_core_fd ) != 0 || ( ulimit_c == 0 || core_size > ulimit_c ) ) ) { unlinkat ( dirfd ( proc_cwd ) , core_basename , 0 ) ; } # if 0 { char * java_log = xasprintf ( \"/tmp/jvm-%lu/hs_error.log\" , ( long ) pid ) ; int src_fd = open ( java_log , O_RDONLY ) ; free ( java_log ) ; if ( src_fd < 0 ) { java_log = xasprintf ( \"%s/hs_err_pid%lu.log\" , user_pwd , ( long ) pid ) ; src_fd = open ( java_log , O_RDONLY ) ; free ( java_log ) ; } if ( src_fd >= 0 ) { strcpy ( path + path_len , \"/hs_err.log\" ) ; int dst_fd = create_or_die ( path ) ; off_t sz = copyfd_eof ( src_fd , dst_fd , COPYFD_SPARSE ) ; if ( close ( dst_fd ) != 0 || sz < 0 ) { dd_delete ( dd ) ; error_msg_and_die ( \"Error<S2SV_blank>saving<S2SV_blank>\\'%s\\'\" , path ) ; } close ( src_fd ) ; } } # endif dd_reset_ownership ( dd ) ; dd_close ( dd ) ; path [ path_len ] = '\\\\0' ; char * newpath = xstrndup ( path , path_len - ( sizeof ( \".new\" ) - 1 ) ) ; if ( rename ( path , newpath ) == 0 ) strcpy ( path , newpath ) ; free ( newpath ) ; log ( \"Saved<S2SV_blank>core<S2SV_blank>dump<S2SV_blank>of<S2SV_blank>pid<S2SV_blank>%lu<S2SV_blank>(%s)<S2SV_blank>to<S2SV_blank>%s<S2SV_blank>(%llu<S2SV_blank>bytes)\" , ( long ) pid , executable , path , ( long long ) core_size ) ; notify_new_path ( path ) ; if ( g_settings_nMaxCrashReportsSize > 0 ) { unsigned maxsize = g_settings_nMaxCrashReportsSize + g_settings_nMaxCrashReportsSize / 4 ; maxsize |= 63 ; trim_problem_dirs ( g_settings_dump_location , maxsize * ( double ) ( 1024 * 1024 ) , path ) ; } free ( rootdir ) ; if ( proc_cwd != NULL ) closedir ( proc_cwd ) ; return 0 ; } create_user_core : if ( user_core_fd >= 0 ) { off_t core_size = copyfd_size ( STDIN_FILENO , user_core_fd , ulimit_c , COPYFD_SPARSE ) ; if ( fsync ( user_core_fd ) != 0 || close ( user_core_fd ) != 0 || core_size < 0 ) { perror_msg ( \"Error<S2SV_blank>writing<S2SV_blank>\\'%s\\'<S2SV_blank>at<S2SV_blank>\\'%s\\'\" , core_basename , user_pwd ) ; unlinkat ( dirfd ( proc_cwd ) , core_basename , 0 ) ; if ( proc_cwd != NULL ) closedir ( proc_cwd ) ; return 1 ; } if ( ulimit_c == 0 || core_size > ulimit_c ) { unlinkat ( dirfd ( proc_cwd ) , core_basename , 0 ) ; if ( proc_cwd != NULL ) closedir ( proc_cwd ) ; return 1 ; } log ( \"Saved<S2SV_blank>core<S2SV_blank>dump<S2SV_blank>of<S2SV_blank>pid<S2SV_blank>%lu<S2SV_blank>to<S2SV_blank>%s<S2SV_blank>at<S2SV_blank>%s<S2SV_blank>(%llu<S2SV_blank>bytes)\" , ( long ) pid , core_basename , user_pwd , ( long long ) core_size ) ; } if ( proc_cwd != NULL ) closedir ( proc_cwd ) ; return 0 ; }\n","target":"<S2SV_ModStart> ; } } const uid_t dduid = g_settings_privatereports ? 0 : fsuid ; <S2SV_ModStart> ( path , dduid <S2SV_ModEnd> , DEFAULT_DUMP_DIR_MODE ,\n","project_and_commit_id":"abrt@abrt/8939398b82006ba1fec4ed491339fc075f43fc7c","cve_id":"CVE-2015-1870","original_address":"https://github.com/abrt/abrt/commit/8939398b82006ba1fec4ed491339fc075f43fc7c","time":"2017-06-26T15:29Z"},
	{"Unnamed: 0":4314,"cwe_id":"CWE-416","source":"CWE-416 static int ipxitf_ioctl ( unsigned int cmd , void __user * arg ) { int rc = - EINVAL ; struct ifreq ifr ; int val ; switch ( cmd ) { case SIOCSIFADDR : { struct sockaddr_ipx * sipx ; struct ipx_interface_definition f ; rc = - EFAULT ; if ( copy_from_user ( & ifr , arg , sizeof ( ifr ) ) ) break ; sipx = ( struct sockaddr_ipx * ) & ifr . ifr_addr ; rc = - EINVAL ; if ( sipx -> sipx_family != AF_IPX ) break ; f . ipx_network = sipx -> sipx_network ; memcpy ( f . ipx_device , ifr . ifr_name , sizeof ( f . ipx_device ) ) ; memcpy ( f . ipx_node , sipx -> sipx_node , IPX_NODE_LEN ) ; f . ipx_dlink_type = sipx -> sipx_type ; f . ipx_special = sipx -> sipx_special ; if ( sipx -> sipx_action == IPX_DLTITF ) rc = ipxitf_delete ( & f ) ; else rc = ipxitf_create ( & f ) ; break ; } case SIOCGIFADDR : { struct sockaddr_ipx * sipx ; struct ipx_interface * ipxif ; struct net_device * dev ; rc = - EFAULT ; if ( copy_from_user ( & ifr , arg , sizeof ( ifr ) ) ) break ; sipx = ( struct sockaddr_ipx * ) & ifr . ifr_addr ; dev = __dev_get_by_name ( & init_net , ifr . ifr_name ) ; rc = - ENODEV ; if ( ! dev ) break ; ipxif = ipxitf_find_using_phys ( dev , ipx_map_frame_type ( sipx -> sipx_type ) ) ; rc = - EADDRNOTAVAIL ; if ( ! ipxif ) break ; sipx -> sipx_family = AF_IPX ; sipx -> sipx_network = ipxif -> if_netnum ; memcpy ( sipx -> sipx_node , ipxif -> if_node , sizeof ( sipx -> sipx_node ) ) ; <S2SV_StartBug> rc = - EFAULT ; <S2SV_EndBug> <S2SV_StartBug> if ( copy_to_user ( arg , & ifr , sizeof ( ifr ) ) ) <S2SV_EndBug> break ; <S2SV_StartBug> ipxitf_put ( ipxif ) ; <S2SV_EndBug> rc = 0 ; break ; } case SIOCAIPXITFCRT : rc = - EFAULT ; if ( get_user ( val , ( unsigned char __user * ) arg ) ) break ; rc = 0 ; ipxcfg_auto_create_interfaces = val ; break ; case SIOCAIPXPRISLT : rc = - EFAULT ; if ( get_user ( val , ( unsigned char __user * ) arg ) ) break ; rc = 0 ; ipxcfg_set_auto_select ( val ) ; break ; } return rc ; }\n","target":"<S2SV_ModStart> ; rc = 0 ; if ( copy_to_user ( arg , & ifr , sizeof ( ifr ) ) ) rc = <S2SV_ModStart> - EFAULT ; <S2SV_ModEnd> ipxitf_put ( ipxif <S2SV_ModStart> ( ipxif ) <S2SV_ModEnd> ; break ;\n","project_and_commit_id":"torvalds@linux/ee0d8d8482345ff97a75a7d747efc309f13b0d80","cve_id":"CVE-2017-7487","original_address":"https://github.com/torvalds/linux/commit/ee0d8d8482345ff97a75a7d747efc309f13b0d80","time":"2017-05-14T22:29Z"},
	{"Unnamed: 0":2183,"cwe_id":"CWE-59","source":"CWE-59 void vrrp_print_stats ( void ) { <S2SV_StartBug> FILE * file ; <S2SV_EndBug> <S2SV_StartBug> file = fopen ( stats_file , \"w\" ) ; <S2SV_EndBug> if ( ! file ) { log_message ( LOG_INFO , \"Can\\'t<S2SV_blank>open<S2SV_blank>%s<S2SV_blank>(%d:<S2SV_blank>%s)\" , stats_file , errno , strerror ( errno ) ) ; return ; } list l = vrrp_data -> vrrp ; element e ; vrrp_t * vrrp ; <S2SV_StartBug> for ( e = LIST_HEAD ( l ) ; e ; ELEMENT_NEXT ( e ) ) { <S2SV_EndBug> vrrp = ELEMENT_DATA ( e ) ; fprintf ( file , \"VRRP<S2SV_blank>Instance:<S2SV_blank>%s\\\\n\" , vrrp -> iname ) ; fprintf ( file , \"<S2SV_blank><S2SV_blank>Advertisements:\\\\n\" ) ; fprintf ( file , \"<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Received:<S2SV_blank>%\" PRIu64 \"\\\\n\" , vrrp -> stats -> advert_rcvd ) ; fprintf ( file , \"<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Sent:<S2SV_blank>%d\\\\n\" , vrrp -> stats -> advert_sent ) ; fprintf ( file , \"<S2SV_blank><S2SV_blank>Became<S2SV_blank>master:<S2SV_blank>%d\\\\n\" , vrrp -> stats -> become_master ) ; fprintf ( file , \"<S2SV_blank><S2SV_blank>Released<S2SV_blank>master:<S2SV_blank>%d\\\\n\" , vrrp -> stats -> release_master ) ; fprintf ( file , \"<S2SV_blank><S2SV_blank>Packet<S2SV_blank>Errors:\\\\n\" ) ; fprintf ( file , \"<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Length:<S2SV_blank>%\" PRIu64 \"\\\\n\" , vrrp -> stats -> packet_len_err ) ; fprintf ( file , \"<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>TTL:<S2SV_blank>%\" PRIu64 \"\\\\n\" , vrrp -> stats -> ip_ttl_err ) ; fprintf ( file , \"<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Invalid<S2SV_blank>Type:<S2SV_blank>%\" PRIu64 \"\\\\n\" , vrrp -> stats -> invalid_type_rcvd ) ; fprintf ( file , \"<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Advertisement<S2SV_blank>Interval:<S2SV_blank>%\" PRIu64 \"\\\\n\" , vrrp -> stats -> advert_interval_err ) ; fprintf ( file , \"<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Address<S2SV_blank>List:<S2SV_blank>%\" PRIu64 \"\\\\n\" , vrrp -> stats -> addr_list_err ) ; fprintf ( file , \"<S2SV_blank><S2SV_blank>Authentication<S2SV_blank>Errors:\\\\n\" ) ; fprintf ( file , \"<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Invalid<S2SV_blank>Type:<S2SV_blank>%d\\\\n\" , vrrp -> stats -> invalid_authtype ) ; # ifdef _WITH_VRRP_AUTH_ fprintf ( file , \"<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Type<S2SV_blank>Mismatch:<S2SV_blank>%d\\\\n\" , vrrp -> stats -> authtype_mismatch ) ; fprintf ( file , \"<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Failure:<S2SV_blank>%d\\\\n\" , vrrp -> stats -> auth_failure ) ; # endif fprintf ( file , \"<S2SV_blank><S2SV_blank>Priority<S2SV_blank>Zero:\\\\n\" ) ; fprintf ( file , \"<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Received:<S2SV_blank>%\" PRIu64 \"\\\\n\" , vrrp -> stats -> pri_zero_rcvd ) ; fprintf ( file , \"<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Sent:<S2SV_blank>%\" PRIu64 \"\\\\n\" , vrrp -> stats -> pri_zero_sent ) ; } fclose ( file ) ; }\n","target":"<S2SV_ModStart> FILE * file = fopen_safe <S2SV_ModEnd> ( stats_file , <S2SV_ModStart> , \"w\" ) <S2SV_ModEnd> ; element e <S2SV_ModStart> * vrrp ; if ( ! file ) { log_message ( LOG_INFO , \"Can\\'t<S2SV_blank>open<S2SV_blank>%s<S2SV_blank>(%d:<S2SV_blank>%s)\" , stats_file , errno , strerror ( errno ) ) ; return ; } LIST_FOREACH ( vrrp_data -> vrrp , vrrp , e ) { <S2SV_ModEnd> fprintf ( file\n","project_and_commit_id":"acassen@keepalived/04f2d32871bb3b11d7dc024039952f2fe2750306","cve_id":"CVE-2018-19044","original_address":"https://github.com/acassen/keepalived/commit/04f2d32871bb3b11d7dc024039952f2fe2750306","time":"2018-11-08T20:29Z"},
	{"Unnamed: 0":2405,"cwe_id":"CWE-125","source":"CWE-125 int common_timer_set ( struct k_itimer * timr , int flags , struct itimerspec64 * new_setting , struct itimerspec64 * old_setting ) { const struct k_clock * kc = timr -> kclock ; bool sigev_none ; ktime_t expires ; if ( old_setting ) common_timer_get ( timr , old_setting ) ; timr -> it_interval = 0 ; if ( kc -> timer_try_to_cancel ( timr ) < 0 ) return TIMER_RETRY ; timr -> it_active = 0 ; timr -> it_requeue_pending = ( timr -> it_requeue_pending + 2 ) & ~ REQUEUE_PENDING ; timr -> it_overrun_last = 0 ; if ( ! new_setting -> it_value . tv_sec && ! new_setting -> it_value . tv_nsec ) return 0 ; timr -> it_interval = timespec64_to_ktime ( new_setting -> it_interval ) ; expires = timespec64_to_ktime ( new_setting -> it_value ) ; <S2SV_StartBug> sigev_none = ( timr -> it_sigev_notify & ~ SIGEV_THREAD_ID ) == SIGEV_NONE ; <S2SV_EndBug> kc -> timer_arm ( timr , expires , flags & TIMER_ABSTIME , sigev_none ) ; timr -> it_active = ! sigev_none ; return 0 ; }\n","target":"<S2SV_ModStart> ; sigev_none = <S2SV_ModEnd> timr -> it_sigev_notify <S2SV_ModStart> timr -> it_sigev_notify <S2SV_ModEnd> == SIGEV_NONE ;\n","project_and_commit_id":"torvalds@linux/cef31d9af908243421258f1df35a4a644604efbe","cve_id":"CVE-2017-18344","original_address":"https://github.com/torvalds/linux/commit/cef31d9af908243421258f1df35a4a644604efbe","time":"2018-07-26T19:29Z"},
	{"Unnamed: 0":584,"cwe_id":"CWE-119","source":"CWE-119 static int PredictorDecodeRow ( TIFF * tif , uint8 * op0 , tmsize_t occ0 , uint16 s ) { TIFFPredictorState * sp = PredictorState ( tif ) ; assert ( sp != NULL ) ; assert ( sp -> decoderow != NULL ) ; assert ( sp -> decodepfunc != NULL ) ; if ( ( * sp -> decoderow ) ( tif , op0 , occ0 , s ) ) { <S2SV_StartBug> ( * sp -> decodepfunc ) ( tif , op0 , occ0 ) ; <S2SV_EndBug> <S2SV_StartBug> return 1 ; <S2SV_EndBug> } else return 0 ; }\n","target":"<S2SV_ModStart> ) ) { return <S2SV_ModStart> occ0 ) ; <S2SV_ModEnd> } else return\n","project_and_commit_id":"vadz@libtiff/3ca657a8793dd011bf869695d72ad31c779c3cc1","cve_id":"CVE-2016-9535","original_address":"https://github.com/vadz/libtiff/commit/3ca657a8793dd011bf869695d72ad31c779c3cc1","time":"2016-11-22T19:59Z"},
	{"Unnamed: 0":6766,"cwe_id":"CWE-264","source":"CWE-264 int _mkp_stage_30 ( struct plugin * p , struct client_session * cs , struct session_request * sr ) { mk_ptr_t referer ; ( void ) p ; ( void ) cs ; PLUGIN_TRACE ( \"[FD<S2SV_blank>%i]<S2SV_blank>Mandril<S2SV_blank>validating<S2SV_blank>URL\" , cs -> socket ) ; <S2SV_StartBug> if ( mk_security_check_url ( sr -> uri ) < 0 ) { <S2SV_EndBug> PLUGIN_TRACE ( \"[FD<S2SV_blank>%i]<S2SV_blank>Close<S2SV_blank>connection,<S2SV_blank>blocked<S2SV_blank>URL\" , cs -> socket ) ; mk_api -> header_set_http_status ( sr , MK_CLIENT_FORBIDDEN ) ; return MK_PLUGIN_RET_CLOSE_CONX ; } PLUGIN_TRACE ( \"[FD<S2SV_blank>%d]<S2SV_blank>Mandril<S2SV_blank>validating<S2SV_blank>hotlinking\" , cs -> socket ) ; referer = mk_api -> header_get ( & sr -> headers_toc , \"Referer\" , strlen ( \"Referer\" ) ) ; if ( mk_security_check_hotlink ( sr -> uri_processed , sr -> host , referer ) < 0 ) { PLUGIN_TRACE ( \"[FD<S2SV_blank>%i]<S2SV_blank>Close<S2SV_blank>connection,<S2SV_blank>deny<S2SV_blank>hotlinking.\" , cs -> socket ) ; mk_api -> header_set_http_status ( sr , MK_CLIENT_FORBIDDEN ) ; return MK_PLUGIN_RET_CLOSE_CONX ; } return MK_PLUGIN_RET_NOT_ME ; }\n","target":"<S2SV_ModStart> ( sr -> uri_processed <S2SV_ModEnd> ) < 0\n","project_and_commit_id":"monkey@monkey/15f72c1ee5e0afad20232bdf0fcecab8d62a5d89","cve_id":"CVE-2013-2182","original_address":"https://github.com/monkey/monkey/commit/15f72c1ee5e0afad20232bdf0fcecab8d62a5d89","time":"2014-06-13T14:55Z"},
	{"Unnamed: 0":4594,"cwe_id":"CWE-20","source":"CWE-20 static ssize_t generic_perform_write ( struct file * file , struct iov_iter * i , loff_t pos ) { struct address_space * mapping = file -> f_mapping ; const struct address_space_operations * a_ops = mapping -> a_ops ; long status = 0 ; ssize_t written = 0 ; unsigned int flags = 0 ; if ( segment_eq ( get_fs ( ) , KERNEL_DS ) ) flags |= AOP_FLAG_UNINTERRUPTIBLE ; do { struct page * page ; pgoff_t index ; unsigned long offset ; unsigned long bytes ; size_t copied ; void * fsdata ; offset = ( pos & ( PAGE_CACHE_SIZE - 1 ) ) ; index = pos >> PAGE_CACHE_SHIFT ; bytes = min_t ( unsigned long , PAGE_CACHE_SIZE - offset , iov_iter_count ( i ) ) ; again : if ( unlikely ( iov_iter_fault_in_readable ( i , bytes ) ) ) { status = - EFAULT ; break ; } status = a_ops -> write_begin ( file , mapping , pos , bytes , flags , & page , & fsdata ) ; if ( unlikely ( status ) ) break ; pagefault_disable ( ) ; copied = iov_iter_copy_from_user_atomic ( page , i , offset , bytes ) ; pagefault_enable ( ) ; flush_dcache_page ( page ) ; status = a_ops -> write_end ( file , mapping , pos , bytes , copied , page , fsdata ) ; if ( unlikely ( status < 0 ) ) break ; copied = status ; cond_resched ( ) ; <S2SV_StartBug> if ( unlikely ( copied == 0 ) ) { <S2SV_EndBug> bytes = min_t ( unsigned long , PAGE_CACHE_SIZE - offset , iov_iter_single_seg_count ( i ) ) ; goto again ; } <S2SV_StartBug> iov_iter_advance ( i , copied ) ; <S2SV_EndBug> pos += copied ; written += copied ; balance_dirty_pages_ratelimited ( mapping ) ; } while ( iov_iter_count ( i ) ) ; return written ? written : status ; }\n","target":"<S2SV_ModStart> ( ) ; iov_iter_advance ( i , copied ) ; <S2SV_ModStart> again ; } <S2SV_ModEnd> pos += copied\n","project_and_commit_id":"torvalds@linux/124d3b7041f9a0ca7c43a6293e1cae4576c32fd5","cve_id":"CVE-2008-7316","original_address":"https://github.com/torvalds/linux/commit/124d3b7041f9a0ca7c43a6293e1cae4576c32fd5","time":"2016-05-02T10:59Z"},
	{"Unnamed: 0":6083,"cwe_id":"CWE-200","source":"CWE-200 static void adjust_branches ( struct bpf_prog * prog , int pos , int delta ) { struct bpf_insn * insn = prog -> insnsi ; int insn_cnt = prog -> len ; int i ; for ( i = 0 ; i < insn_cnt ; i ++ , insn ++ ) { if ( BPF_CLASS ( insn -> code ) != BPF_JMP || BPF_OP ( insn -> code ) == BPF_CALL || BPF_OP ( insn -> code ) == BPF_EXIT ) continue ; if ( i < pos && i + insn -> off + 1 > pos ) insn -> off += delta ; <S2SV_StartBug> else if ( i > pos && i + insn -> off + 1 < pos ) <S2SV_EndBug> insn -> off -= delta ; } }\n","target":"<S2SV_ModStart> i > pos + delta <S2SV_ModStart> off + 1 <= pos + delta <S2SV_ModEnd> ) insn ->\n","project_and_commit_id":"torvalds@linux/a1b14d27ed0965838350f1377ff97c93ee383492","cve_id":"CVE-2016-2383","original_address":"https://github.com/torvalds/linux/commit/a1b14d27ed0965838350f1377ff97c93ee383492","time":"2016-04-27T17:59Z"},
	{"Unnamed: 0":3598,"cwe_id":"CWE-200","source":"CWE-200 int btrfs_truncate_inode_items ( struct btrfs_trans_handle * trans , struct btrfs_root * root , struct inode * inode , u64 new_size , u32 min_type ) { struct btrfs_path * path ; struct extent_buffer * leaf ; struct btrfs_file_extent_item * fi ; struct btrfs_key key ; struct btrfs_key found_key ; u64 extent_start = 0 ; u64 extent_num_bytes = 0 ; u64 extent_offset = 0 ; u64 item_end = 0 ; u64 last_size = new_size ; u32 found_type = ( u8 ) - 1 ; int found_extent ; int del_item ; int pending_del_nr = 0 ; int pending_del_slot = 0 ; int extent_type = - 1 ; int ret ; int err = 0 ; u64 ino = btrfs_ino ( inode ) ; u64 bytes_deleted = 0 ; bool be_nice = 0 ; bool should_throttle = 0 ; bool should_end = 0 ; BUG_ON ( new_size > 0 && min_type != BTRFS_EXTENT_DATA_KEY ) ; if ( ! btrfs_is_free_space_inode ( inode ) && test_bit ( BTRFS_ROOT_REF_COWS , & root -> state ) ) be_nice = 1 ; path = btrfs_alloc_path ( ) ; if ( ! path ) return - ENOMEM ; path -> reada = - 1 ; if ( test_bit ( BTRFS_ROOT_REF_COWS , & root -> state ) || root == root -> fs_info -> tree_root ) btrfs_drop_extent_cache ( inode , ALIGN ( new_size , root -> sectorsize ) , ( u64 ) - 1 , 0 ) ; if ( min_type == 0 && root == BTRFS_I ( inode ) -> root ) btrfs_kill_delayed_inode_items ( inode ) ; key . objectid = ino ; key . offset = ( u64 ) - 1 ; key . type = ( u8 ) - 1 ; search_again : if ( be_nice && bytes_deleted > 32 * 1024 * 1024 ) { if ( btrfs_should_end_transaction ( trans , root ) ) { err = - EAGAIN ; goto error ; } } path -> leave_spinning = 1 ; ret = btrfs_search_slot ( trans , root , & key , path , - 1 , 1 ) ; if ( ret < 0 ) { err = ret ; goto out ; } if ( ret > 0 ) { if ( path -> slots [ 0 ] == 0 ) goto out ; path -> slots [ 0 ] -- ; } while ( 1 ) { fi = NULL ; leaf = path -> nodes [ 0 ] ; btrfs_item_key_to_cpu ( leaf , & found_key , path -> slots [ 0 ] ) ; found_type = found_key . type ; if ( found_key . objectid != ino ) break ; if ( found_type < min_type ) break ; item_end = found_key . offset ; if ( found_type == BTRFS_EXTENT_DATA_KEY ) { fi = btrfs_item_ptr ( leaf , path -> slots [ 0 ] , struct btrfs_file_extent_item ) ; extent_type = btrfs_file_extent_type ( leaf , fi ) ; if ( extent_type != BTRFS_FILE_EXTENT_INLINE ) { item_end += btrfs_file_extent_num_bytes ( leaf , fi ) ; } else if ( extent_type == BTRFS_FILE_EXTENT_INLINE ) { item_end += btrfs_file_extent_inline_len ( leaf , path -> slots [ 0 ] , fi ) ; } item_end -- ; } if ( found_type > min_type ) { del_item = 1 ; } else { if ( item_end < new_size ) break ; if ( found_key . offset >= new_size ) del_item = 1 ; else del_item = 0 ; } found_extent = 0 ; if ( found_type != BTRFS_EXTENT_DATA_KEY ) goto delete ; if ( del_item ) last_size = found_key . offset ; else last_size = new_size ; if ( extent_type != BTRFS_FILE_EXTENT_INLINE ) { u64 num_dec ; extent_start = btrfs_file_extent_disk_bytenr ( leaf , fi ) ; if ( ! del_item ) { u64 orig_num_bytes = btrfs_file_extent_num_bytes ( leaf , fi ) ; extent_num_bytes = ALIGN ( new_size - found_key . offset , root -> sectorsize ) ; btrfs_set_file_extent_num_bytes ( leaf , fi , extent_num_bytes ) ; num_dec = ( orig_num_bytes - extent_num_bytes ) ; if ( test_bit ( BTRFS_ROOT_REF_COWS , & root -> state ) && extent_start != 0 ) inode_sub_bytes ( inode , num_dec ) ; btrfs_mark_buffer_dirty ( leaf ) ; } else { extent_num_bytes = btrfs_file_extent_disk_num_bytes ( leaf , fi ) ; extent_offset = found_key . offset - btrfs_file_extent_offset ( leaf , fi ) ; num_dec = btrfs_file_extent_num_bytes ( leaf , fi ) ; if ( extent_start != 0 ) { found_extent = 1 ; if ( test_bit ( BTRFS_ROOT_REF_COWS , & root -> state ) ) inode_sub_bytes ( inode , num_dec ) ; } } } else if ( extent_type == BTRFS_FILE_EXTENT_INLINE ) { if ( ! del_item && <S2SV_StartBug> btrfs_file_extent_compression ( leaf , fi ) == 0 && <S2SV_EndBug> btrfs_file_extent_encryption ( leaf , fi ) == 0 && btrfs_file_extent_other_encoding ( leaf , fi ) == 0 ) { u32 size = new_size - found_key . offset ; <S2SV_StartBug> if ( test_bit ( BTRFS_ROOT_REF_COWS , & root -> state ) ) <S2SV_EndBug> inode_sub_bytes ( inode , item_end + 1 - <S2SV_StartBug> new_size ) ; <S2SV_EndBug> btrfs_set_file_extent_ram_bytes ( leaf , fi , size ) ; size = btrfs_file_extent_calc_inline_size ( size ) ; btrfs_truncate_item ( root , path , size , 1 ) ; } else if ( test_bit ( BTRFS_ROOT_REF_COWS , & root -> state ) ) { inode_sub_bytes ( inode , item_end + 1 - found_key . offset ) ; } } delete : if ( del_item ) { if ( ! pending_del_nr ) { pending_del_slot = path -> slots [ 0 ] ; pending_del_nr = 1 ; } else if ( pending_del_nr && path -> slots [ 0 ] + 1 == pending_del_slot ) { pending_del_nr ++ ; pending_del_slot = path -> slots [ 0 ] ; } else { BUG ( ) ; } } else { break ; } should_throttle = 0 ; if ( found_extent && ( test_bit ( BTRFS_ROOT_REF_COWS , & root -> state ) || root == root -> fs_info -> tree_root ) ) { btrfs_set_path_blocking ( path ) ; bytes_deleted += extent_num_bytes ; ret = btrfs_free_extent ( trans , root , extent_start , extent_num_bytes , 0 , btrfs_header_owner ( leaf ) , ino , extent_offset , 0 ) ; BUG_ON ( ret ) ; if ( btrfs_should_throttle_delayed_refs ( trans , root ) ) btrfs_async_run_delayed_refs ( root , trans -> delayed_ref_updates * 2 , 0 ) ; if ( be_nice ) { if ( truncate_space_check ( trans , root , extent_num_bytes ) ) { should_end = 1 ; } if ( btrfs_should_throttle_delayed_refs ( trans , root ) ) { should_throttle = 1 ; } } } if ( found_type == BTRFS_INODE_ITEM_KEY ) break ; if ( path -> slots [ 0 ] == 0 || path -> slots [ 0 ] != pending_del_slot || should_throttle || should_end ) { if ( pending_del_nr ) { ret = btrfs_del_items ( trans , root , path , pending_del_slot , pending_del_nr ) ; if ( ret ) { btrfs_abort_transaction ( trans , root , ret ) ; goto error ; } pending_del_nr = 0 ; } btrfs_release_path ( path ) ; if ( should_throttle ) { unsigned long updates = trans -> delayed_ref_updates ; if ( updates ) { trans -> delayed_ref_updates = 0 ; ret = btrfs_run_delayed_refs ( trans , root , updates * 2 ) ; if ( ret && ! err ) err = ret ; } } if ( should_end ) { err = - EAGAIN ; goto error ; } goto search_again ; } else { path -> slots [ 0 ] -- ; } } out : if ( pending_del_nr ) { ret = btrfs_del_items ( trans , root , path , pending_del_slot , pending_del_nr ) ; if ( ret ) btrfs_abort_transaction ( trans , root , ret ) ; } error : if ( root -> root_key . objectid != BTRFS_TREE_LOG_OBJECTID ) btrfs_ordered_update_i_size ( inode , last_size , NULL ) ; btrfs_free_path ( path ) ; if ( be_nice && bytes_deleted > 32 * 1024 * 1024 ) { unsigned long updates = trans -> delayed_ref_updates ; if ( updates ) { trans -> delayed_ref_updates = 0 ; ret = btrfs_run_delayed_refs ( trans , root , updates * 2 ) ; if ( ret && ! err ) err = ret ; } } return err ; }\n","target":"<S2SV_ModStart> ! del_item && btrfs_file_extent_encryption ( leaf , fi ) == 0 && btrfs_file_extent_other_encoding ( leaf , fi ) == 0 ) { if ( <S2SV_ModStart> , fi ) != BTRFS_COMPRESS_NONE && pending_del_nr ) { err = btrfs_del_items ( trans , root , path , pending_del_slot , pending_del_nr ) ; if ( err ) { btrfs_abort_transaction ( trans , root , err ) ; goto error ; } pending_del_nr = 0 ; } err = truncate_inline_extent ( inode , path , & found_key , item_end , new_size ) ; if ( err ) { btrfs_abort_transaction ( trans , root , err ) ; goto error ; } } else <S2SV_ModEnd> if ( test_bit <S2SV_ModStart> state ) ) { <S2SV_ModStart> 1 - new_size <S2SV_ModEnd> ) ; }\n","project_and_commit_id":"torvalds@linux/0305cd5f7fca85dae392b9ba85b116896eb7c1c7","cve_id":"CVE-2015-8374","original_address":"https://github.com/torvalds/linux/commit/0305cd5f7fca85dae392b9ba85b116896eb7c1c7","time":"2015-12-28T11:59Z"},
	{"Unnamed: 0":5147,"cwe_id":"CWE-362","source":"CWE-362 static int userauth_hostbased ( struct ssh * ssh ) { Authctxt * authctxt = ssh -> authctxt ; struct sshbuf * b ; struct sshkey * key = NULL ; char * pkalg , * cuser , * chost ; u_char * pkblob , * sig ; size_t alen , blen , slen ; int r , pktype , authenticated = 0 ; <S2SV_StartBug> if ( ! authctxt -> valid ) { <S2SV_EndBug> debug2 ( \"%s:<S2SV_blank>disabled<S2SV_blank>because<S2SV_blank>of<S2SV_blank>invalid<S2SV_blank>user\" , __func__ ) ; return 0 ; } if ( ( r = sshpkt_get_cstring ( ssh , & pkalg , & alen ) ) != 0 || ( r = sshpkt_get_string ( ssh , & pkblob , & blen ) ) != 0 || ( r = sshpkt_get_cstring ( ssh , & chost , NULL ) ) != 0 || ( r = sshpkt_get_cstring ( ssh , & cuser , NULL ) ) != 0 || ( r = sshpkt_get_string ( ssh , & sig , & slen ) ) != 0 ) fatal ( \"%s:<S2SV_blank>packet<S2SV_blank>parsing:<S2SV_blank>%s\" , __func__ , ssh_err ( r ) ) ; debug ( \"%s:<S2SV_blank>cuser<S2SV_blank>%s<S2SV_blank>chost<S2SV_blank>%s<S2SV_blank>pkalg<S2SV_blank>%s<S2SV_blank>slen<S2SV_blank>%zu\" , __func__ , cuser , chost , pkalg , slen ) ; # ifdef DEBUG_PK debug ( \"signature:\" ) ; sshbuf_dump_data ( sig , siglen , stderr ) ; # endif pktype = sshkey_type_from_name ( pkalg ) ; if ( pktype == KEY_UNSPEC ) { logit ( \"%s:<S2SV_blank>unsupported<S2SV_blank>public<S2SV_blank>key<S2SV_blank>algorithm:<S2SV_blank>%s\" , __func__ , pkalg ) ; goto done ; } if ( ( r = sshkey_from_blob ( pkblob , blen , & key ) ) != 0 ) { error ( \"%s:<S2SV_blank>key_from_blob:<S2SV_blank>%s\" , __func__ , ssh_err ( r ) ) ; goto done ; } if ( key == NULL ) { error ( \"%s:<S2SV_blank>cannot<S2SV_blank>decode<S2SV_blank>key:<S2SV_blank>%s\" , __func__ , pkalg ) ; goto done ; } if ( key -> type != pktype ) { error ( \"%s:<S2SV_blank>type<S2SV_blank>mismatch<S2SV_blank>for<S2SV_blank>decoded<S2SV_blank>key<S2SV_blank>\" \"(received<S2SV_blank>%d,<S2SV_blank>expected<S2SV_blank>%d)\" , __func__ , key -> type , pktype ) ; goto done ; } if ( sshkey_type_plain ( key -> type ) == KEY_RSA && ( ssh -> compat & SSH_BUG_RSASIGMD5 ) != 0 ) { error ( \"Refusing<S2SV_blank>RSA<S2SV_blank>key<S2SV_blank>because<S2SV_blank>peer<S2SV_blank>uses<S2SV_blank>unsafe<S2SV_blank>\" \"signature<S2SV_blank>format\" ) ; goto done ; } if ( match_pattern_list ( pkalg , options . hostbased_key_types , 0 ) != 1 ) { logit ( \"%s:<S2SV_blank>key<S2SV_blank>type<S2SV_blank>%s<S2SV_blank>not<S2SV_blank>in<S2SV_blank>HostbasedAcceptedKeyTypes\" , __func__ , sshkey_type ( key ) ) ; goto done ; } <S2SV_StartBug> if ( ( b = sshbuf_new ( ) ) == NULL ) <S2SV_EndBug> fatal ( \"%s:<S2SV_blank>sshbuf_new<S2SV_blank>failed\" , __func__ ) ; if ( ( r = sshbuf_put_string ( b , session_id2 , session_id2_len ) ) != 0 || ( r = sshbuf_put_u8 ( b , SSH2_MSG_USERAUTH_REQUEST ) ) != 0 || ( r = sshbuf_put_cstring ( b , authctxt -> user ) ) != 0 || ( r = sshbuf_put_cstring ( b , authctxt -> service ) ) != 0 || ( r = sshbuf_put_cstring ( b , \"hostbased\" ) ) != 0 || ( r = sshbuf_put_string ( b , pkalg , alen ) ) != 0 || ( r = sshbuf_put_string ( b , pkblob , blen ) ) != 0 || ( r = sshbuf_put_cstring ( b , chost ) ) != 0 || ( r = sshbuf_put_cstring ( b , cuser ) ) != 0 ) fatal ( \"%s:<S2SV_blank>buffer<S2SV_blank>error:<S2SV_blank>%s\" , __func__ , ssh_err ( r ) ) ; # ifdef DEBUG_PK sshbuf_dump ( b , stderr ) ; # endif auth2_record_info ( authctxt , \"client<S2SV_blank>user<S2SV_blank>\\\\\"%.100s\\\\\",<S2SV_blank>client<S2SV_blank>host<S2SV_blank>\\\\\"%.100s\\\\\"\" , cuser , chost ) ; authenticated = 0 ; if ( PRIVSEP ( hostbased_key_allowed ( authctxt -> pw , cuser , chost , key ) ) && PRIVSEP ( sshkey_verify ( key , sig , slen , sshbuf_ptr ( b ) , sshbuf_len ( b ) , pkalg , ssh -> compat ) ) == 0 ) authenticated = 1 ; auth2_record_key ( authctxt , authenticated , key ) ; sshbuf_free ( b ) ; done : debug2 ( \"%s:<S2SV_blank>authenticated<S2SV_blank>%d\" , __func__ , authenticated ) ; sshkey_free ( key ) ; free ( pkalg ) ; free ( pkblob ) ; free ( cuser ) ; free ( chost ) ; free ( sig ) ; return authenticated ; }\n","target":"<S2SV_ModStart> = 0 ; <S2SV_ModEnd> if ( ( <S2SV_ModStart> } if ( ! authctxt -> valid || authctxt -> user == NULL ) { debug2 ( \"%s:<S2SV_blank>disabled<S2SV_blank>because<S2SV_blank>of<S2SV_blank>invalid<S2SV_blank>user\" , __func__ ) ; goto done ; } if (\n","project_and_commit_id":"openbsd@src/779974d35b4859c07bc3cb8a12c74b43b0a7d1e0","cve_id":"CVE-2018-15473","original_address":"https://github.com/openbsd/src/commit/779974d35b4859c07bc3cb8a12c74b43b0a7d1e0","time":"2018-08-17T19:29Z"},
	{"Unnamed: 0":1823,"cwe_id":"CWE-190","source":"CWE-190 static int read_SubStreamsInfo ( struct archive_read * a , struct _7z_substream_info * ss , struct _7z_folder * f , size_t numFolders ) { const unsigned char * p ; uint64_t * usizes ; size_t unpack_streams ; int type ; unsigned i ; uint32_t numDigests ; memset ( ss , 0 , sizeof ( * ss ) ) ; for ( i = 0 ; i < numFolders ; i ++ ) f [ i ] . numUnpackStreams = 1 ; if ( ( p = header_bytes ( a , 1 ) ) == NULL ) return ( - 1 ) ; type = * p ; if ( type == kNumUnPackStream ) { unpack_streams = 0 ; for ( i = 0 ; i < numFolders ; i ++ ) { if ( parse_7zip_uint64 ( a , & ( f [ i ] . numUnpackStreams ) ) < 0 ) return ( - 1 ) ; if ( UMAX_ENTRY < f [ i ] . numUnpackStreams ) return ( - 1 ) ; <S2SV_StartBug> unpack_streams += ( size_t ) f [ i ] . numUnpackStreams ; <S2SV_EndBug> } if ( ( p = header_bytes ( a , 1 ) ) == NULL ) return ( - 1 ) ; type = * p ; } else unpack_streams = numFolders ; ss -> unpack_streams = unpack_streams ; if ( unpack_streams ) { ss -> unpackSizes = calloc ( unpack_streams , sizeof ( * ss -> unpackSizes ) ) ; ss -> digestsDefined = calloc ( unpack_streams , sizeof ( * ss -> digestsDefined ) ) ; ss -> digests = calloc ( unpack_streams , sizeof ( * ss -> digests ) ) ; if ( ss -> unpackSizes == NULL || ss -> digestsDefined == NULL || ss -> digests == NULL ) return ( - 1 ) ; } usizes = ss -> unpackSizes ; for ( i = 0 ; i < numFolders ; i ++ ) { unsigned pack ; uint64_t sum ; if ( f [ i ] . numUnpackStreams == 0 ) continue ; sum = 0 ; if ( type == kSize ) { for ( pack = 1 ; pack < f [ i ] . numUnpackStreams ; pack ++ ) { if ( parse_7zip_uint64 ( a , usizes ) < 0 ) return ( - 1 ) ; sum += * usizes ++ ; } } * usizes ++ = folder_uncompressed_size ( & f [ i ] ) - sum ; } if ( type == kSize ) { if ( ( p = header_bytes ( a , 1 ) ) == NULL ) return ( - 1 ) ; type = * p ; } for ( i = 0 ; i < unpack_streams ; i ++ ) { ss -> digestsDefined [ i ] = 0 ; ss -> digests [ i ] = 0 ; } numDigests = 0 ; for ( i = 0 ; i < numFolders ; i ++ ) { if ( f [ i ] . numUnpackStreams != 1 || ! f [ i ] . digest_defined ) numDigests += ( uint32_t ) f [ i ] . numUnpackStreams ; } if ( type == kCRC ) { struct _7z_digests tmpDigests ; unsigned char * digestsDefined = ss -> digestsDefined ; uint32_t * digests = ss -> digests ; int di = 0 ; memset ( & tmpDigests , 0 , sizeof ( tmpDigests ) ) ; if ( read_Digests ( a , & ( tmpDigests ) , numDigests ) < 0 ) { free_Digest ( & tmpDigests ) ; return ( - 1 ) ; } for ( i = 0 ; i < numFolders ; i ++ ) { if ( f [ i ] . numUnpackStreams == 1 && f [ i ] . digest_defined ) { * digestsDefined ++ = 1 ; * digests ++ = f [ i ] . digest ; } else { unsigned j ; for ( j = 0 ; j < f [ i ] . numUnpackStreams ; j ++ , di ++ ) { * digestsDefined ++ = tmpDigests . defineds [ di ] ; * digests ++ = tmpDigests . digests [ di ] ; } } } free_Digest ( & tmpDigests ) ; if ( ( p = header_bytes ( a , 1 ) ) == NULL ) return ( - 1 ) ; type = * p ; } if ( type != kEnd ) return ( - 1 ) ; return ( 0 ) ; }\n","target":"<S2SV_ModStart> 1 ) ; if ( unpack_streams > SIZE_MAX - UMAX_ENTRY ) { return ( - 1 ) ; }\n","project_and_commit_id":"libarchive@libarchive/e79ef306afe332faf22e9b442a2c6b59cb175573","cve_id":"CVE-2016-4300","original_address":"https://github.com/libarchive/libarchive/commit/e79ef306afe332faf22e9b442a2c6b59cb175573","time":"2016-09-21T14:25Z"},
	{"Unnamed: 0":6148,"cwe_id":"CWE-787","source":"CWE-787 static int bmpr_read_rle ( struct iwbmprcontext * rctx ) { int retval = 0 ; if ( ! ( rctx -> compression == IWBMP_BI_RLE8 && rctx -> bitcount == 8 ) && ! ( rctx -> compression == IWBMP_BI_RLE4 && rctx -> bitcount == 4 ) ) { iw_set_error ( rctx -> ctx , \"Compression<S2SV_blank>type<S2SV_blank>incompatible<S2SV_blank>with<S2SV_blank>image<S2SV_blank>type\" ) ; <S2SV_StartBug> } <S2SV_EndBug> if ( rctx -> topdown ) { <S2SV_StartBug> iw_set_error ( rctx -> ctx , \"Compression<S2SV_blank>not<S2SV_blank>allowed<S2SV_blank>with<S2SV_blank>top-down<S2SV_blank>images\" ) ; <S2SV_EndBug> } rctx -> img -> imgtype = IW_IMGTYPE_RGBA ; rctx -> img -> bit_depth = 8 ; rctx -> img -> bpr = iw_calc_bytesperrow ( rctx -> width , 32 ) ; rctx -> img -> pixels = ( iw_byte * ) iw_malloc_large ( rctx -> ctx , rctx -> img -> bpr , rctx -> img -> height ) ; if ( ! rctx -> img -> pixels ) goto done ; if ( ! bmpr_read_rle_internal ( rctx ) ) goto done ; if ( ! bmpr_has_transparency ( rctx -> img ) ) { bmpr_strip_alpha ( rctx -> img ) ; } retval = 1 ; done : return retval ; }\n","target":"<S2SV_ModStart> \"Compression<S2SV_blank>type<S2SV_blank>incompatible<S2SV_blank>with<S2SV_blank>image<S2SV_blank>type\" ) ; goto done ; <S2SV_ModStart> , \"Compression<S2SV_blank>not<S2SV_blank>allowed<S2SV_blank>with<S2SV_blank>top-down<S2SV_blank>images\" ) ; goto done\n","project_and_commit_id":"jsummers@imageworsener/a4f247707f08e322f0b41e82c3e06e224240a654","cve_id":"CVE-2017-9203","original_address":"https://github.com/jsummers/imageworsener/commit/a4f247707f08e322f0b41e82c3e06e224240a654","time":"2017-05-23T04:29Z"},
	{"Unnamed: 0":612,"cwe_id":"CWE-000","source":"CWE-000 static int sd2_parse_rsrc_fork ( SF_PRIVATE * psf ) { SD2_RSRC rsrc ; int k , marker , error = 0 ; psf_use_rsrc ( psf , SF_TRUE ) ; memset ( & rsrc , 0 , sizeof ( rsrc ) ) ; rsrc . rsrc_len = psf_get_filelen ( psf ) ; psf_log_printf ( psf , \"Resource<S2SV_blank>length<S2SV_blank>:<S2SV_blank>%d<S2SV_blank>(0x%04X)\\\\n\" , rsrc . rsrc_len , rsrc . rsrc_len ) ; if ( rsrc . rsrc_len > SIGNED_SIZEOF ( psf -> header ) ) { rsrc . rsrc_data = calloc ( 1 , rsrc . rsrc_len ) ; rsrc . need_to_free_rsrc_data = SF_TRUE ; } else { rsrc . rsrc_data = psf -> header ; rsrc . need_to_free_rsrc_data = SF_FALSE ; } ; psf_fread ( rsrc . rsrc_data , rsrc . rsrc_len , 1 , psf ) ; psf -> headindex = psf -> headend = rsrc . rsrc_len ; rsrc . data_offset = read_rsrc_int ( & rsrc , 0 ) ; rsrc . map_offset = read_rsrc_int ( & rsrc , 4 ) ; rsrc . data_length = read_rsrc_int ( & rsrc , 8 ) ; rsrc . map_length = read_rsrc_int ( & rsrc , 12 ) ; if ( rsrc . data_offset == 0x51607 && rsrc . map_offset == 0x20000 ) { psf_log_printf ( psf , \"Trying<S2SV_blank>offset<S2SV_blank>of<S2SV_blank>0x52<S2SV_blank>bytes.\\\\n\" ) ; rsrc . data_offset = read_rsrc_int ( & rsrc , 0x52 + 0 ) + 0x52 ; rsrc . map_offset = read_rsrc_int ( & rsrc , 0x52 + 4 ) + 0x52 ; rsrc . data_length = read_rsrc_int ( & rsrc , 0x52 + 8 ) ; rsrc . map_length = read_rsrc_int ( & rsrc , 0x52 + 12 ) ; } ; psf_log_printf ( psf , \"<S2SV_blank><S2SV_blank>data<S2SV_blank>offset<S2SV_blank>:<S2SV_blank>0x%04X\\\\n<S2SV_blank><S2SV_blank>map<S2SV_blank><S2SV_blank>offset<S2SV_blank>:<S2SV_blank>0x%04X\\\\n\" \"<S2SV_blank><S2SV_blank>data<S2SV_blank>length<S2SV_blank>:<S2SV_blank>0x%04X\\\\n<S2SV_blank><S2SV_blank>map<S2SV_blank><S2SV_blank>length<S2SV_blank>:<S2SV_blank>0x%04X\\\\n\" , rsrc . data_offset , rsrc . map_offset , rsrc . data_length , rsrc . map_length ) ; if ( rsrc . data_offset > rsrc . rsrc_len ) { psf_log_printf ( psf , \"Error<S2SV_blank>:<S2SV_blank>rsrc.data_offset<S2SV_blank>(%d,<S2SV_blank>0x%x)<S2SV_blank>><S2SV_blank>len\\\\n\" , rsrc . data_offset , rsrc . data_offset ) ; error = SFE_SD2_BAD_DATA_OFFSET ; goto parse_rsrc_fork_cleanup ; } ; if ( rsrc . map_offset > rsrc . rsrc_len ) { psf_log_printf ( psf , \"Error<S2SV_blank>:<S2SV_blank>rsrc.map_offset<S2SV_blank>><S2SV_blank>len\\\\n\" ) ; error = SFE_SD2_BAD_MAP_OFFSET ; goto parse_rsrc_fork_cleanup ; } ; if ( rsrc . data_length > rsrc . rsrc_len ) { psf_log_printf ( psf , \"Error<S2SV_blank>:<S2SV_blank>rsrc.data_length<S2SV_blank>><S2SV_blank>len\\\\n\" ) ; error = SFE_SD2_BAD_DATA_LENGTH ; goto parse_rsrc_fork_cleanup ; } ; if ( rsrc . map_length > rsrc . rsrc_len ) { psf_log_printf ( psf , \"Error<S2SV_blank>:<S2SV_blank>rsrc.map_length<S2SV_blank>><S2SV_blank>len\\\\n\" ) ; error = SFE_SD2_BAD_MAP_LENGTH ; goto parse_rsrc_fork_cleanup ; } ; if ( rsrc . data_offset + rsrc . data_length != rsrc . map_offset || rsrc . map_offset + rsrc . map_length != rsrc . rsrc_len ) { psf_log_printf ( psf , \"Error<S2SV_blank>:<S2SV_blank>This<S2SV_blank>does<S2SV_blank>not<S2SV_blank>look<S2SV_blank>like<S2SV_blank>a<S2SV_blank>MacOSX<S2SV_blank>resource<S2SV_blank>fork.\\\\n\" ) ; error = SFE_SD2_BAD_RSRC ; goto parse_rsrc_fork_cleanup ; } ; if ( rsrc . map_offset + 28 >= rsrc . rsrc_len ) { psf_log_printf ( psf , \"Bad<S2SV_blank>map<S2SV_blank>offset<S2SV_blank>(%d<S2SV_blank>+<S2SV_blank>28<S2SV_blank>><S2SV_blank>%d).\\\\n\" , rsrc . map_offset , rsrc . rsrc_len ) ; error = SFE_SD2_BAD_RSRC ; goto parse_rsrc_fork_cleanup ; } ; rsrc . string_offset = rsrc . map_offset + read_rsrc_short ( & rsrc , rsrc . map_offset + 26 ) ; if ( rsrc . string_offset > rsrc . rsrc_len ) { psf_log_printf ( psf , \"Bad<S2SV_blank>string<S2SV_blank>offset<S2SV_blank>(%d).\\\\n\" , rsrc . string_offset ) ; error = SFE_SD2_BAD_RSRC ; goto parse_rsrc_fork_cleanup ; } ; rsrc . type_offset = rsrc . map_offset + 30 ; <S2SV_StartBug> rsrc . type_count = read_rsrc_short ( & rsrc , rsrc . map_offset + 28 ) + 1 ; <S2SV_EndBug> if ( rsrc . type_count < 1 ) { psf_log_printf ( psf , \"Bad<S2SV_blank>type<S2SV_blank>count.\\\\n\" ) ; error = SFE_SD2_BAD_RSRC ; goto parse_rsrc_fork_cleanup ; } ; rsrc . item_offset = rsrc . type_offset + rsrc . type_count * 8 ; if ( rsrc . item_offset < 0 || rsrc . item_offset > rsrc . rsrc_len ) { psf_log_printf ( psf , \"Bad<S2SV_blank>item<S2SV_blank>offset<S2SV_blank>(%d).\\\\n\" , rsrc . item_offset ) ; error = SFE_SD2_BAD_RSRC ; goto parse_rsrc_fork_cleanup ; } ; rsrc . str_index = - 1 ; for ( k = 0 ; k < rsrc . type_count ; k ++ ) <S2SV_StartBug> { marker = read_rsrc_marker ( & rsrc , rsrc . type_offset + k * 8 ) ; <S2SV_EndBug> if ( marker == STR_MARKER ) { rsrc . str_index = k ; rsrc . str_count = read_rsrc_short ( & rsrc , rsrc . type_offset + k * 8 + 4 ) + 1 ; error = parse_str_rsrc ( psf , & rsrc ) ; goto parse_rsrc_fork_cleanup ; } ; } ; psf_log_printf ( psf , \"No<S2SV_blank>\\'STR<S2SV_blank>\\'<S2SV_blank>resource.\\\\n\" ) ; error = SFE_SD2_BAD_RSRC ; parse_rsrc_fork_cleanup : psf_use_rsrc ( psf , SF_FALSE ) ; if ( rsrc . need_to_free_rsrc_data ) free ( rsrc . rsrc_data ) ; return error ; }\n","target":"<S2SV_ModStart> + 30 ; if ( rsrc . map_offset + 28 > rsrc . rsrc_len ) { psf_log_printf ( psf , \"Bad<S2SV_blank>map<S2SV_blank>offset.\\\\n\" ) ; goto parse_rsrc_fork_cleanup ; } ; <S2SV_ModStart> ++ ) { if ( <S2SV_ModEnd> rsrc . type_offset <S2SV_ModStart> k * 8 > rsrc . rsrc_len ) { psf_log_printf ( psf , \"Bad<S2SV_blank>rsrc<S2SV_blank>marker.\\\\n\" ) ; goto parse_rsrc_fork_cleanup ; } ; marker = read_rsrc_marker ( & rsrc , rsrc . type_offset + k * 8\n","project_and_commit_id":"erikd@libsndfile/dbe14f00030af5d3577f4cabbf9861db59e9c378","cve_id":"CVE-2014-9496","original_address":"https://github.com/erikd/libsndfile/commit/dbe14f00030af5d3577f4cabbf9861db59e9c378","time":"2015-01-16T16:59Z"},
	{"Unnamed: 0":1464,"cwe_id":"CWE-59","source":"CWE-59 static bool cgroupfs_mount_cgroup ( void * hdata , const char * root , int type ) { size_t bufsz = strlen ( root ) + sizeof ( \"/sys/fs/cgroup\" ) ; char * path = NULL ; char * * parts = NULL ; char * dirname = NULL ; char * abs_path = NULL ; char * abs_path2 = NULL ; struct cgfs_data * cgfs_d ; struct cgroup_process_info * info , * base_info ; int r , saved_errno = 0 ; cgfs_d = hdata ; if ( ! cgfs_d ) return false ; base_info = cgfs_d -> info ; if ( type == LXC_AUTO_CGROUP_FULL_NOSPEC ) type = LXC_AUTO_CGROUP_FULL_MIXED ; else if ( type == LXC_AUTO_CGROUP_NOSPEC ) type = LXC_AUTO_CGROUP_MIXED ; if ( type < LXC_AUTO_CGROUP_RO || type > LXC_AUTO_CGROUP_FULL_MIXED ) { ERROR ( \"could<S2SV_blank>not<S2SV_blank>mount<S2SV_blank>cgroups<S2SV_blank>into<S2SV_blank>container:<S2SV_blank>invalid<S2SV_blank>type<S2SV_blank>specified<S2SV_blank>internally\" ) ; errno = EINVAL ; return false ; } path = calloc ( 1 , bufsz ) ; if ( ! path ) return false ; snprintf ( path , bufsz , \"%s/sys/fs/cgroup\" , root ) ; <S2SV_StartBug> r = mount ( \"cgroup_root\" , path , \"tmpfs\" , MS_NOSUID | MS_NODEV | MS_NOEXEC | MS_RELATIME , \"size=10240k,mode=755\" ) ; <S2SV_EndBug> if ( r < 0 ) { SYSERROR ( \"could<S2SV_blank>not<S2SV_blank>mount<S2SV_blank>tmpfs<S2SV_blank>to<S2SV_blank>/sys/fs/cgroup<S2SV_blank>in<S2SV_blank>the<S2SV_blank>container\" ) ; return false ; } for ( info = base_info ; info ; info = info -> next ) { size_t subsystem_count , i ; struct cgroup_mount_point * mp = info -> designated_mount_point ; if ( ! mp ) mp = lxc_cgroup_find_mount_point ( info -> hierarchy , info -> cgroup_path , true ) ; if ( ! mp ) { SYSERROR ( \"could<S2SV_blank>not<S2SV_blank>find<S2SV_blank>original<S2SV_blank>mount<S2SV_blank>point<S2SV_blank>for<S2SV_blank>cgroup<S2SV_blank>hierarchy<S2SV_blank>while<S2SV_blank>trying<S2SV_blank>to<S2SV_blank>mount<S2SV_blank>cgroup<S2SV_blank>filesystem\" ) ; goto out_error ; } subsystem_count = lxc_array_len ( ( void * * ) info -> hierarchy -> subsystems ) ; parts = calloc ( subsystem_count + 1 , sizeof ( char * ) ) ; if ( ! parts ) goto out_error ; for ( i = 0 ; i < subsystem_count ; i ++ ) { if ( ! strncmp ( info -> hierarchy -> subsystems [ i ] , \"name=\" , 5 ) ) parts [ i ] = info -> hierarchy -> subsystems [ i ] + 5 ; else parts [ i ] = info -> hierarchy -> subsystems [ i ] ; } dirname = lxc_string_join ( \",\" , ( const char * * ) parts , false ) ; if ( ! dirname ) goto out_error ; abs_path = lxc_append_paths ( path , dirname ) ; if ( ! abs_path ) goto out_error ; r = mkdir_p ( abs_path , 0755 ) ; if ( r < 0 && errno != EEXIST ) { SYSERROR ( \"could<S2SV_blank>not<S2SV_blank>create<S2SV_blank>cgroup<S2SV_blank>subsystem<S2SV_blank>directory<S2SV_blank>/sys/fs/cgroup/%s\" , dirname ) ; goto out_error ; } abs_path2 = lxc_append_paths ( abs_path , info -> cgroup_path ) ; if ( ! abs_path2 ) goto out_error ; if ( type == LXC_AUTO_CGROUP_FULL_RO || type == LXC_AUTO_CGROUP_FULL_RW || type == LXC_AUTO_CGROUP_FULL_MIXED ) { if ( strcmp ( mp -> mount_prefix , \"/\" ) != 0 ) { ERROR ( \"could<S2SV_blank>not<S2SV_blank>automatically<S2SV_blank>mount<S2SV_blank>cgroup-full<S2SV_blank>to<S2SV_blank>/sys/fs/cgroup/%s:<S2SV_blank>host<S2SV_blank>has<S2SV_blank>no<S2SV_blank>mount<S2SV_blank>point<S2SV_blank>for<S2SV_blank>this<S2SV_blank>cgroup<S2SV_blank>filesystem<S2SV_blank>that<S2SV_blank>has<S2SV_blank>access<S2SV_blank>to<S2SV_blank>the<S2SV_blank>root<S2SV_blank>cgroup\" , dirname ) ; goto out_error ; } r = mount ( mp -> mount_point , abs_path , \"none\" , MS_BIND , 0 ) ; if ( r < 0 ) { SYSERROR ( \"error<S2SV_blank>bind-mounting<S2SV_blank>%s<S2SV_blank>to<S2SV_blank>%s\" , mp -> mount_point , abs_path ) ; goto out_error ; } if ( type == LXC_AUTO_CGROUP_FULL_RO || type == LXC_AUTO_CGROUP_FULL_MIXED ) { r = mount ( NULL , abs_path , NULL , MS_REMOUNT | MS_BIND | MS_RDONLY , NULL ) ; if ( r < 0 ) { SYSERROR ( \"error<S2SV_blank>re-mounting<S2SV_blank>%s<S2SV_blank>readonly\" , abs_path ) ; goto out_error ; } } if ( type == LXC_AUTO_CGROUP_FULL_MIXED ) { r = mount ( abs_path2 , abs_path2 , NULL , MS_BIND , NULL ) ; if ( r < 0 ) { SYSERROR ( \"error<S2SV_blank>bind-mounting<S2SV_blank>%s<S2SV_blank>onto<S2SV_blank>itself\" , abs_path2 ) ; goto out_error ; } r = mount ( NULL , abs_path2 , NULL , MS_REMOUNT | MS_BIND , NULL ) ; if ( r < 0 ) { SYSERROR ( \"error<S2SV_blank>re-mounting<S2SV_blank>%s<S2SV_blank>readwrite\" , abs_path2 ) ; goto out_error ; } } } else { r = mkdir_p ( abs_path2 , 0755 ) ; if ( r < 0 && errno != EEXIST ) { SYSERROR ( \"could<S2SV_blank>not<S2SV_blank>create<S2SV_blank>cgroup<S2SV_blank>directory<S2SV_blank>/sys/fs/cgroup/%s%s\" , dirname , info -> cgroup_path ) ; goto out_error ; } if ( type == LXC_AUTO_CGROUP_MIXED || type == LXC_AUTO_CGROUP_RO ) { r = mount ( abs_path , abs_path , NULL , MS_BIND , NULL ) ; if ( r < 0 ) { SYSERROR ( \"error<S2SV_blank>bind-mounting<S2SV_blank>%s<S2SV_blank>onto<S2SV_blank>itself\" , abs_path ) ; goto out_error ; } r = mount ( NULL , abs_path , NULL , MS_REMOUNT | MS_BIND | MS_RDONLY , NULL ) ; if ( r < 0 ) { SYSERROR ( \"error<S2SV_blank>re-mounting<S2SV_blank>%s<S2SV_blank>readonly\" , abs_path ) ; goto out_error ; } } free ( abs_path ) ; abs_path = NULL ; abs_path = cgroup_to_absolute_path ( mp , info -> cgroup_path , NULL ) ; if ( ! abs_path ) goto out_error ; r = mount ( abs_path , abs_path2 , \"none\" , MS_BIND , 0 ) ; if ( r < 0 ) { SYSERROR ( \"error<S2SV_blank>bind-mounting<S2SV_blank>%s<S2SV_blank>to<S2SV_blank>%s\" , abs_path , abs_path2 ) ; goto out_error ; } if ( type == LXC_AUTO_CGROUP_RO ) { r = mount ( NULL , abs_path2 , NULL , MS_REMOUNT | MS_BIND | MS_RDONLY , NULL ) ; if ( r < 0 ) { SYSERROR ( \"error<S2SV_blank>re-mounting<S2SV_blank>%s<S2SV_blank>readonly\" , abs_path2 ) ; goto out_error ; } } } free ( abs_path ) ; free ( abs_path2 ) ; abs_path = NULL ; abs_path2 = NULL ; if ( subsystem_count > 1 ) { for ( i = 0 ; i < subsystem_count ; i ++ ) { abs_path = lxc_append_paths ( path , parts [ i ] ) ; if ( ! abs_path ) goto out_error ; r = symlink ( dirname , abs_path ) ; if ( r < 0 ) WARN ( \"could<S2SV_blank>not<S2SV_blank>create<S2SV_blank>symlink<S2SV_blank>%s<S2SV_blank>-><S2SV_blank>%s<S2SV_blank>in<S2SV_blank>/sys/fs/cgroup<S2SV_blank>of<S2SV_blank>container\" , parts [ i ] , dirname ) ; free ( abs_path ) ; abs_path = NULL ; } } free ( dirname ) ; free ( parts ) ; dirname = NULL ; parts = NULL ; } free ( path ) ; return true ; out_error : saved_errno = errno ; free ( path ) ; free ( dirname ) ; free ( parts ) ; free ( abs_path ) ; free ( abs_path2 ) ; errno = saved_errno ; return false ; }\n","target":"<S2SV_ModStart> ; r = safe_mount <S2SV_ModEnd> ( \"cgroup_root\" , <S2SV_ModStart> MS_RELATIME , \"size=10240k,mode=755\" , root\n","project_and_commit_id":"lxc@lxc/592fd47a6245508b79fe6ac819fe6d3b2c1289be","cve_id":"CVE-2015-1335","original_address":"https://github.com/lxc/lxc/commit/592fd47a6245508b79fe6ac819fe6d3b2c1289be","time":"2015-10-01T20:59Z"},
	{"Unnamed: 0":6042,"cwe_id":"CWE-20","source":"CWE-20 static bool nested_vmx_exit_handled ( struct kvm_vcpu * vcpu ) { u32 intr_info = vmcs_read32 ( VM_EXIT_INTR_INFO ) ; struct vcpu_vmx * vmx = to_vmx ( vcpu ) ; struct vmcs12 * vmcs12 = get_vmcs12 ( vcpu ) ; u32 exit_reason = vmx -> exit_reason ; if ( vmx -> nested . nested_run_pending ) return 0 ; if ( unlikely ( vmx -> fail ) ) { pr_info_ratelimited ( \"%s<S2SV_blank>failed<S2SV_blank>vm<S2SV_blank>entry<S2SV_blank>%x\\\\n\" , __func__ , vmcs_read32 ( VM_INSTRUCTION_ERROR ) ) ; return 1 ; } switch ( exit_reason ) { case EXIT_REASON_EXCEPTION_NMI : if ( ! is_exception ( intr_info ) ) return 0 ; else if ( is_page_fault ( intr_info ) ) return enable_ept ; return vmcs12 -> exception_bitmap & ( 1u << ( intr_info & INTR_INFO_VECTOR_MASK ) ) ; case EXIT_REASON_EXTERNAL_INTERRUPT : return 0 ; case EXIT_REASON_TRIPLE_FAULT : return 1 ; case EXIT_REASON_PENDING_INTERRUPT : return nested_cpu_has ( vmcs12 , CPU_BASED_VIRTUAL_INTR_PENDING ) ; case EXIT_REASON_NMI_WINDOW : return nested_cpu_has ( vmcs12 , CPU_BASED_VIRTUAL_NMI_PENDING ) ; case EXIT_REASON_TASK_SWITCH : return 1 ; case EXIT_REASON_CPUID : return 1 ; case EXIT_REASON_HLT : return nested_cpu_has ( vmcs12 , CPU_BASED_HLT_EXITING ) ; case EXIT_REASON_INVD : return 1 ; case EXIT_REASON_INVLPG : return nested_cpu_has ( vmcs12 , CPU_BASED_INVLPG_EXITING ) ; case EXIT_REASON_RDPMC : return nested_cpu_has ( vmcs12 , CPU_BASED_RDPMC_EXITING ) ; case EXIT_REASON_RDTSC : return nested_cpu_has ( vmcs12 , CPU_BASED_RDTSC_EXITING ) ; case EXIT_REASON_VMCALL : case EXIT_REASON_VMCLEAR : case EXIT_REASON_VMLAUNCH : case EXIT_REASON_VMPTRLD : case EXIT_REASON_VMPTRST : case EXIT_REASON_VMREAD : case EXIT_REASON_VMRESUME : case EXIT_REASON_VMWRITE : case EXIT_REASON_VMOFF : case EXIT_REASON_VMON : <S2SV_StartBug> return 1 ; <S2SV_EndBug> case EXIT_REASON_CR_ACCESS : return nested_vmx_exit_handled_cr ( vcpu , vmcs12 ) ; case EXIT_REASON_DR_ACCESS : return nested_cpu_has ( vmcs12 , CPU_BASED_MOV_DR_EXITING ) ; case EXIT_REASON_IO_INSTRUCTION : return nested_vmx_exit_handled_io ( vcpu , vmcs12 ) ; case EXIT_REASON_MSR_READ : case EXIT_REASON_MSR_WRITE : return nested_vmx_exit_handled_msr ( vcpu , vmcs12 , exit_reason ) ; case EXIT_REASON_INVALID_STATE : return 1 ; case EXIT_REASON_MWAIT_INSTRUCTION : return nested_cpu_has ( vmcs12 , CPU_BASED_MWAIT_EXITING ) ; case EXIT_REASON_MONITOR_INSTRUCTION : return nested_cpu_has ( vmcs12 , CPU_BASED_MONITOR_EXITING ) ; case EXIT_REASON_PAUSE_INSTRUCTION : return nested_cpu_has ( vmcs12 , CPU_BASED_PAUSE_EXITING ) || nested_cpu_has2 ( vmcs12 , SECONDARY_EXEC_PAUSE_LOOP_EXITING ) ; case EXIT_REASON_MCE_DURING_VMENTRY : return 0 ; case EXIT_REASON_TPR_BELOW_THRESHOLD : return 1 ; case EXIT_REASON_APIC_ACCESS : return nested_cpu_has2 ( vmcs12 , SECONDARY_EXEC_VIRTUALIZE_APIC_ACCESSES ) ; case EXIT_REASON_EPT_VIOLATION : case EXIT_REASON_EPT_MISCONFIG : return 0 ; case EXIT_REASON_PREEMPTION_TIMER : return vmcs12 -> pin_based_vm_exec_control & PIN_BASED_VMX_PREEMPTION_TIMER ; case EXIT_REASON_WBINVD : return nested_cpu_has2 ( vmcs12 , SECONDARY_EXEC_WBINVD_EXITING ) ; case EXIT_REASON_XSETBV : return 1 ; default : return 1 ; } }\n","target":"<S2SV_ModStart> case EXIT_REASON_VMON : case EXIT_REASON_INVEPT :\n","project_and_commit_id":"torvalds@linux/bfd0a56b90005f8c8a004baf407ad90045c2b11e","cve_id":"CVE-2014-3645","original_address":"https://github.com/torvalds/linux/commit/bfd0a56b90005f8c8a004baf407ad90045c2b11e","time":"2014-11-10T11:55Z"},
	{"Unnamed: 0":4595,"cwe_id":"CWE-119","source":"CWE-119 static TEE_Result set_rmem_param ( const struct optee_msg_param_rmem * rmem , struct param_mem * mem ) <S2SV_StartBug> { <S2SV_EndBug> uint64_t shm_ref = READ_ONCE ( rmem -> shm_ref ) ; mem -> mobj = mobj_reg_shm_get_by_cookie ( shm_ref ) ; if ( ! mem -> mobj ) return TEE_ERROR_BAD_PARAMETERS ; mem -> offs = READ_ONCE ( rmem -> offs ) ; mem -> size = READ_ONCE ( rmem -> size ) ; <S2SV_StartBug> return TEE_SUCCESS ; <S2SV_EndBug> }\n","target":"<S2SV_ModStart> mem ) { size_t req_size = 0 ; <S2SV_ModStart> size ) ; if ( ADD_OVERFLOW ( mem -> offs , mem -> size , & req_size ) || mem -> mobj -> size < req_size ) return TEE_ERROR_SECURITY ;\n","project_and_commit_id":"OP-TEE@optee_os/e3adcf566cb278444830e7badfdcc3983e334fd1","cve_id":"CVE-2019-1010292","original_address":"https://github.com/OP-TEE/optee_os/commit/e3adcf566cb278444830e7badfdcc3983e334fd1","time":"2019-07-16T14:15Z"},
	{"Unnamed: 0":2130,"cwe_id":"CWE-000","source":"CWE-000 static int ati_remote2_probe ( struct usb_interface * interface , const struct usb_device_id * id ) { struct usb_device * udev = interface_to_usbdev ( interface ) ; struct usb_host_interface * alt = interface -> cur_altsetting ; struct ati_remote2 * ar2 ; int r ; if ( alt -> desc . bInterfaceNumber ) return - ENODEV ; ar2 = kzalloc ( sizeof ( struct ati_remote2 ) , GFP_KERNEL ) ; if ( ! ar2 ) return - ENOMEM ; ar2 -> udev = udev ; <S2SV_StartBug> ar2 -> intf [ 0 ] = interface ; <S2SV_EndBug> ar2 -> ep [ 0 ] = & alt -> endpoint [ 0 ] . desc ; ar2 -> intf [ 1 ] = usb_ifnum_to_if ( udev , 1 ) ; <S2SV_StartBug> r = usb_driver_claim_interface ( & ati_remote2_driver , ar2 -> intf [ 1 ] , ar2 ) ; <S2SV_EndBug> if ( r ) goto fail1 ; alt = ar2 -> intf [ 1 ] -> cur_altsetting ; <S2SV_StartBug> ar2 -> ep [ 1 ] = & alt -> endpoint [ 0 ] . desc ; <S2SV_EndBug> r = ati_remote2_urb_init ( ar2 ) ; if ( r ) <S2SV_StartBug> goto fail2 ; <S2SV_EndBug> ar2 -> channel_mask = channel_mask ; ar2 -> mode_mask = mode_mask ; r = ati_remote2_setup ( ar2 , ar2 -> channel_mask ) ; if ( r ) <S2SV_StartBug> goto fail2 ; <S2SV_EndBug> usb_make_path ( udev , ar2 -> phys , sizeof ( ar2 -> phys ) ) ; strlcat ( ar2 -> phys , \"/input0\" , sizeof ( ar2 -> phys ) ) ; strlcat ( ar2 -> name , \"ATI<S2SV_blank>Remote<S2SV_blank>Wonder<S2SV_blank>II\" , sizeof ( ar2 -> name ) ) ; r = sysfs_create_group ( & udev -> dev . kobj , & ati_remote2_attr_group ) ; if ( r ) <S2SV_StartBug> goto fail2 ; <S2SV_EndBug> r = ati_remote2_input_init ( ar2 ) ; if ( r ) <S2SV_StartBug> goto fail3 ; <S2SV_EndBug> usb_set_intfdata ( interface , ar2 ) ; interface -> needs_remote_wakeup = 1 ; return 0 ; <S2SV_StartBug> fail3 : <S2SV_EndBug> sysfs_remove_group ( & udev -> dev . kobj , & ati_remote2_attr_group ) ; fail2 : <S2SV_StartBug> ati_remote2_urb_cleanup ( ar2 ) ; <S2SV_EndBug> usb_driver_release_interface ( & ati_remote2_driver , ar2 -> intf [ 1 ] ) ; fail1 : kfree ( ar2 ) ; return r ; }\n","target":"<S2SV_ModStart> = udev ; if ( alt -> desc . bNumEndpoints < 1 || ! alt -> endpoint ) { dev_err ( & interface -> dev , \"%s():<S2SV_blank>interface<S2SV_blank>0<S2SV_blank>must<S2SV_blank>have<S2SV_blank>an<S2SV_blank>endpoint\\\\n\" , __func__ ) ; r = - ENODEV ; goto fail1 ; } <S2SV_ModStart> 1 ) ; if ( ( udev -> actconfig -> desc . bNumInterfaces < 2 ) || ! ar2 -> intf [ 1 ] ) { dev_err ( & interface -> dev , \"%s():<S2SV_blank>need<S2SV_blank>2<S2SV_blank>interfaces,<S2SV_blank>found<S2SV_blank>%d\\\\n\" , __func__ , udev -> actconfig -> desc . bNumInterfaces ) ; r = - ENODEV ; goto fail1 ; } <S2SV_ModStart> -> cur_altsetting ; if ( alt -> desc . bNumEndpoints < 1 || ! alt -> endpoint ) { dev_err ( & interface -> dev , \"%s():<S2SV_blank>interface<S2SV_blank>1<S2SV_blank>must<S2SV_blank>have<S2SV_blank>an<S2SV_blank>endpoint\\\\n\" , __func__ ) ; r = - ENODEV ; goto fail2 ; } <S2SV_ModStart> r ) goto fail3 <S2SV_ModEnd> ; ar2 -> <S2SV_ModStart> r ) goto fail3 <S2SV_ModEnd> ; usb_make_path ( <S2SV_ModStart> r ) goto fail3 <S2SV_ModEnd> ; r = <S2SV_ModStart> r ) goto fail4 <S2SV_ModEnd> ; usb_set_intfdata ( <S2SV_ModStart> return 0 ; fail4 : sysfs_remove_group ( & udev -> dev . kobj , & ati_remote2_attr_group ) ; fail3 : ati_remote2_urb_cleanup ( ar2 <S2SV_ModEnd> ) ; fail2 <S2SV_ModStart> ; fail2 : <S2SV_ModEnd> usb_driver_release_interface ( &\n","project_and_commit_id":"torvalds@linux/950336ba3e4a1ffd2ca60d29f6ef386dd2c7351d","cve_id":"CVE-2016-2185","original_address":"https://github.com/torvalds/linux/commit/950336ba3e4a1ffd2ca60d29f6ef386dd2c7351d","time":"2016-05-02T10:59Z"},
	{"Unnamed: 0":2536,"cwe_id":"CWE-119","source":"CWE-119 static int asn1_decode_entry ( sc_context_t * ctx , struct sc_asn1_entry * entry , const u8 * obj , size_t objlen , int depth ) { void * parm = entry -> parm ; int ( * callback_func ) ( sc_context_t * nctx , void * arg , const u8 * nobj , size_t nobjlen , int ndepth ) ; size_t * len = ( size_t * ) entry -> arg ; int r = 0 ; callback_func = parm ; sc_debug ( ctx , SC_LOG_DEBUG_ASN1 , \"%*.*sdecoding<S2SV_blank>\\'%s\\',<S2SV_blank>raw<S2SV_blank>data:%s%s\\\\n\" , depth , depth , \"\" , entry -> name , sc_dump_hex ( obj , objlen > 16 ? 16 : objlen ) , objlen > 16 ? \"...\" : \"\" ) ; switch ( entry -> type ) { case SC_ASN1_STRUCT : if ( parm != NULL ) r = asn1_decode ( ctx , ( struct sc_asn1_entry * ) parm , obj , objlen , NULL , NULL , 0 , depth + 1 ) ; break ; case SC_ASN1_NULL : break ; case SC_ASN1_BOOLEAN : if ( parm != NULL ) { if ( objlen != 1 ) { sc_debug ( ctx , SC_LOG_DEBUG_ASN1 , \"invalid<S2SV_blank>ASN.1<S2SV_blank>object<S2SV_blank>length:<S2SV_blank>%\" SC_FORMAT_LEN_SIZE_T \"u\\\\n\" , objlen ) ; r = SC_ERROR_INVALID_ASN1_OBJECT ; } else * ( ( int * ) parm ) = obj [ 0 ] ? 1 : 0 ; } break ; case SC_ASN1_INTEGER : case SC_ASN1_ENUMERATED : if ( parm != NULL ) { r = sc_asn1_decode_integer ( obj , objlen , ( int * ) entry -> parm ) ; sc_debug ( ctx , SC_LOG_DEBUG_ASN1 , \"%*.*sdecoding<S2SV_blank>\\'%s\\'<S2SV_blank>returned<S2SV_blank>%d\\\\n\" , depth , depth , \"\" , entry -> name , * ( ( int * ) entry -> parm ) ) ; } break ; case SC_ASN1_BIT_STRING_NI : case SC_ASN1_BIT_STRING : if ( parm != NULL ) { int invert = entry -> type == SC_ASN1_BIT_STRING ? 1 : 0 ; assert ( len != NULL ) ; if ( objlen < 1 ) { r = SC_ERROR_INVALID_ASN1_OBJECT ; break ; } if ( entry -> flags & SC_ASN1_ALLOC ) { u8 * * buf = ( u8 * * ) parm ; * buf = malloc ( objlen - 1 ) ; if ( * buf == NULL ) { r = SC_ERROR_OUT_OF_MEMORY ; break ; } * len = objlen - 1 ; parm = * buf ; } r = decode_bit_string ( obj , objlen , ( u8 * ) parm , * len , invert ) ; if ( r >= 0 ) { * len = r ; r = 0 ; } } break ; case SC_ASN1_BIT_FIELD : if ( parm != NULL ) r = decode_bit_field ( obj , objlen , ( u8 * ) parm , * len ) ; break ; case SC_ASN1_OCTET_STRING : if ( parm != NULL ) { size_t c ; assert ( len != NULL ) ; if ( ( entry -> flags & SC_ASN1_UNSIGNED ) <S2SV_StartBug> && obj [ 0 ] == 0x00 && objlen > 1 ) { <S2SV_EndBug> objlen -- ; obj ++ ; } if ( entry -> flags & SC_ASN1_ALLOC ) { u8 * * buf = ( u8 * * ) parm ; * buf = malloc ( objlen ) ; if ( * buf == NULL ) { r = SC_ERROR_OUT_OF_MEMORY ; break ; } c = * len = objlen ; parm = * buf ; } else c = objlen > * len ? * len : objlen ; memcpy ( parm , obj , c ) ; * len = c ; } break ; case SC_ASN1_GENERALIZEDTIME : if ( parm != NULL ) { size_t c ; assert ( len != NULL ) ; if ( entry -> flags & SC_ASN1_ALLOC ) { u8 * * buf = ( u8 * * ) parm ; * buf = malloc ( objlen ) ; if ( * buf == NULL ) { r = SC_ERROR_OUT_OF_MEMORY ; break ; } c = * len = objlen ; parm = * buf ; } else c = objlen > * len ? * len : objlen ; memcpy ( parm , obj , c ) ; * len = c ; } break ; case SC_ASN1_OBJECT : if ( parm != NULL ) r = sc_asn1_decode_object_id ( obj , objlen , ( struct sc_object_id * ) parm ) ; break ; case SC_ASN1_PRINTABLESTRING : case SC_ASN1_UTF8STRING : if ( parm != NULL ) { assert ( len != NULL ) ; if ( entry -> flags & SC_ASN1_ALLOC ) { u8 * * buf = ( u8 * * ) parm ; * buf = malloc ( objlen + 1 ) ; if ( * buf == NULL ) { r = SC_ERROR_OUT_OF_MEMORY ; break ; } * len = objlen + 1 ; parm = * buf ; } r = sc_asn1_decode_utf8string ( obj , objlen , ( u8 * ) parm , len ) ; if ( entry -> flags & SC_ASN1_ALLOC ) { * len -= 1 ; } } break ; case SC_ASN1_PATH : if ( entry -> parm != NULL ) r = asn1_decode_path ( ctx , obj , objlen , ( sc_path_t * ) parm , depth ) ; break ; case SC_ASN1_PKCS15_ID : if ( entry -> parm != NULL ) { struct sc_pkcs15_id * id = ( struct sc_pkcs15_id * ) parm ; size_t c = objlen > sizeof ( id -> value ) ? sizeof ( id -> value ) : objlen ; memcpy ( id -> value , obj , c ) ; id -> len = c ; } break ; case SC_ASN1_PKCS15_OBJECT : if ( entry -> parm != NULL ) r = asn1_decode_p15_object ( ctx , obj , objlen , ( struct sc_asn1_pkcs15_object * ) parm , depth ) ; break ; case SC_ASN1_ALGORITHM_ID : if ( entry -> parm != NULL ) r = sc_asn1_decode_algorithm_id ( ctx , obj , objlen , ( struct sc_algorithm_id * ) parm , depth ) ; break ; case SC_ASN1_SE_INFO : if ( entry -> parm != NULL ) r = asn1_decode_se_info ( ctx , obj , objlen , ( sc_pkcs15_sec_env_info_t * * * ) entry -> parm , len , depth ) ; break ; case SC_ASN1_CALLBACK : if ( entry -> parm != NULL ) r = callback_func ( ctx , entry -> arg , obj , objlen , depth ) ; break ; default : sc_debug ( ctx , SC_LOG_DEBUG_ASN1 , \"invalid<S2SV_blank>ASN.1<S2SV_blank>type:<S2SV_blank>%d\\\\n\" , entry -> type ) ; return SC_ERROR_INVALID_ASN1_OBJECT ; } if ( r ) { sc_debug ( ctx , SC_LOG_DEBUG_ASN1 , \"decoding<S2SV_blank>of<S2SV_blank>ASN.1<S2SV_blank>object<S2SV_blank>\\'%s\\'<S2SV_blank>failed:<S2SV_blank>%s\\\\n\" , entry -> name , sc_strerror ( r ) ) ; return r ; } entry -> flags |= SC_ASN1_PRESENT ; return 0 ; }\n","target":"<S2SV_ModStart> SC_ASN1_UNSIGNED ) && objlen > 1 && <S2SV_ModStart> ] == 0x00 <S2SV_ModEnd> ) { objlen\n","project_and_commit_id":"OpenSC@OpenSC/a3fc7693f3a035a8a7921cffb98432944bb42740","cve_id":"CVE-2019-15946","original_address":"https://github.com/OpenSC/OpenSC/commit/a3fc7693f3a035a8a7921cffb98432944bb42740","time":"2019-09-05T17:15Z"},
	{"Unnamed: 0":5570,"cwe_id":"CWE-416","source":"CWE-416 static int try_smi_init ( struct smi_info * new_smi ) { int rv = 0 ; int i ; char * init_name = NULL ; pr_info ( \"Trying<S2SV_blank>%s-specified<S2SV_blank>%s<S2SV_blank>state<S2SV_blank>machine<S2SV_blank>at<S2SV_blank>%s<S2SV_blank>address<S2SV_blank>0x%lx,<S2SV_blank>slave<S2SV_blank>address<S2SV_blank>0x%x,<S2SV_blank>irq<S2SV_blank>%d\\\\n\" , ipmi_addr_src_to_str ( new_smi -> io . addr_source ) , si_to_str [ new_smi -> io . si_type ] , addr_space_to_str [ new_smi -> io . addr_type ] , new_smi -> io . addr_data , new_smi -> io . slave_addr , new_smi -> io . irq ) ; switch ( new_smi -> io . si_type ) { case SI_KCS : new_smi -> handlers = & kcs_smi_handlers ; break ; case SI_SMIC : new_smi -> handlers = & smic_smi_handlers ; break ; case SI_BT : new_smi -> handlers = & bt_smi_handlers ; break ; default : rv = - EIO ; goto out_err ; } new_smi -> si_num = smi_num ; if ( ! new_smi -> io . dev ) { init_name = kasprintf ( GFP_KERNEL , \"ipmi_si.%d\" , new_smi -> si_num ) ; new_smi -> pdev = platform_device_alloc ( \"ipmi_si\" , new_smi -> si_num ) ; if ( ! new_smi -> pdev ) { pr_err ( \"Unable<S2SV_blank>to<S2SV_blank>allocate<S2SV_blank>platform<S2SV_blank>device\\\\n\" ) ; rv = - ENOMEM ; goto out_err ; } new_smi -> io . dev = & new_smi -> pdev -> dev ; new_smi -> io . dev -> driver = & ipmi_platform_driver . driver ; new_smi -> io . dev -> init_name = init_name ; } new_smi -> si_sm = kmalloc ( new_smi -> handlers -> size ( ) , GFP_KERNEL ) ; if ( ! new_smi -> si_sm ) { rv = - ENOMEM ; goto out_err ; } new_smi -> io . io_size = new_smi -> handlers -> init_data ( new_smi -> si_sm , & new_smi -> io ) ; rv = new_smi -> io . io_setup ( & new_smi -> io ) ; if ( rv ) { dev_err ( new_smi -> io . dev , \"Could<S2SV_blank>not<S2SV_blank>set<S2SV_blank>up<S2SV_blank>I/O<S2SV_blank>space\\\\n\" ) ; goto out_err ; } if ( new_smi -> handlers -> detect ( new_smi -> si_sm ) ) { if ( new_smi -> io . addr_source ) dev_err ( new_smi -> io . dev , \"Interface<S2SV_blank>detection<S2SV_blank>failed\\\\n\" ) ; rv = - ENODEV ; goto out_err ; } rv = try_get_dev_id ( new_smi ) ; if ( rv ) { if ( new_smi -> io . addr_source ) dev_err ( new_smi -> io . dev , \"There<S2SV_blank>appears<S2SV_blank>to<S2SV_blank>be<S2SV_blank>no<S2SV_blank>BMC<S2SV_blank>at<S2SV_blank>this<S2SV_blank>location\\\\n\" ) ; goto out_err ; } setup_oem_data_handler ( new_smi ) ; setup_xaction_handlers ( new_smi ) ; check_for_broken_irqs ( new_smi ) ; new_smi -> waiting_msg = NULL ; new_smi -> curr_msg = NULL ; atomic_set ( & new_smi -> req_events , 0 ) ; new_smi -> run_to_completion = false ; for ( i = 0 ; i < SI_NUM_STATS ; i ++ ) atomic_set ( & new_smi -> stats [ i ] , 0 ) ; new_smi -> interrupt_disabled = true ; atomic_set ( & new_smi -> need_watch , 0 ) ; rv = try_enable_event_buffer ( new_smi ) ; if ( rv == 0 ) new_smi -> has_event_buffer = true ; start_clear_flags ( new_smi ) ; if ( new_smi -> io . irq ) { new_smi -> interrupt_disabled = false ; atomic_set ( & new_smi -> req_events , 1 ) ; } if ( new_smi -> pdev && ! new_smi -> pdev_registered ) { rv = platform_device_add ( new_smi -> pdev ) ; if ( rv ) { dev_err ( new_smi -> io . dev , \"Unable<S2SV_blank>to<S2SV_blank>register<S2SV_blank>system<S2SV_blank>interface<S2SV_blank>device:<S2SV_blank>%d\\\\n\" , rv ) ; goto out_err ; } new_smi -> pdev_registered = true ; } dev_set_drvdata ( new_smi -> io . dev , new_smi ) ; rv = device_add_group ( new_smi -> io . dev , & ipmi_si_dev_attr_group ) ; if ( rv ) { dev_err ( new_smi -> io . dev , \"Unable<S2SV_blank>to<S2SV_blank>add<S2SV_blank>device<S2SV_blank>attributes:<S2SV_blank>error<S2SV_blank>%d\\\\n\" , rv ) ; goto out_err ; } new_smi -> dev_group_added = true ; rv = ipmi_register_smi ( & handlers , new_smi , new_smi -> io . dev , new_smi -> io . slave_addr ) ; if ( rv ) { dev_err ( new_smi -> io . dev , \"Unable<S2SV_blank>to<S2SV_blank>register<S2SV_blank>device:<S2SV_blank>error<S2SV_blank>%d\\\\n\" , rv ) ; goto out_err ; } smi_num ++ ; dev_info ( new_smi -> io . dev , \"IPMI<S2SV_blank>%s<S2SV_blank>interface<S2SV_blank>initialized\\\\n\" , si_to_str [ new_smi -> io . si_type ] ) ; WARN_ON ( new_smi -> io . dev -> init_name != NULL ) ; out_err : <S2SV_StartBug> kfree ( init_name ) ; <S2SV_EndBug> return rv ; }\n","target":"<S2SV_ModStart> ; out_err : if ( rv && new_smi -> io . io_cleanup ) { new_smi -> io . io_cleanup ( & new_smi -> io ) ; new_smi -> io . io_cleanup = NULL ; }\n","project_and_commit_id":"torvalds@linux/401e7e88d4ef80188ffa07095ac00456f901b8c4","cve_id":"CVE-2019-11811","original_address":"https://github.com/torvalds/linux/commit/401e7e88d4ef80188ffa07095ac00456f901b8c4","time":"2019-05-07T14:29Z"},
	{"Unnamed: 0":5235,"cwe_id":"CWE-000","source":"CWE-000 rfbBool SetFormatAndEncodings ( rfbClient * client ) { rfbSetPixelFormatMsg spf ; <S2SV_StartBug> char buf [ sz_rfbSetEncodingsMsg + MAX_ENCODINGS * 4 ] ; <S2SV_EndBug> <S2SV_StartBug> rfbSetEncodingsMsg * se = ( rfbSetEncodingsMsg * ) buf ; <S2SV_EndBug> <S2SV_StartBug> uint32_t * encs = ( uint32_t * ) ( & buf [ sz_rfbSetEncodingsMsg ] ) ; <S2SV_EndBug> int len = 0 ; rfbBool requestCompressLevel = FALSE ; rfbBool requestQualityLevel = FALSE ; rfbBool requestLastRectEncoding = FALSE ; rfbClientProtocolExtension * e ; if ( ! SupportsClient2Server ( client , rfbSetPixelFormat ) ) return TRUE ; spf . type = rfbSetPixelFormat ; spf . pad1 = 0 ; spf . pad2 = 0 ; spf . format = client -> format ; spf . format . redMax = rfbClientSwap16IfLE ( spf . format . redMax ) ; spf . format . greenMax = rfbClientSwap16IfLE ( spf . format . greenMax ) ; spf . format . blueMax = rfbClientSwap16IfLE ( spf . format . blueMax ) ; if ( ! WriteToRFBServer ( client , ( char * ) & spf , sz_rfbSetPixelFormatMsg ) ) return FALSE ; if ( ! SupportsClient2Server ( client , rfbSetEncodings ) ) return TRUE ; se -> type = rfbSetEncodings ; se -> pad = 0 ; se -> nEncodings = 0 ; if ( client -> appData . encodingsString ) { const char * encStr = client -> appData . encodingsString ; int encStrLen ; do { const char * nextEncStr = strchr ( encStr , '<S2SV_blank>' ) ; if ( nextEncStr ) { encStrLen = nextEncStr - encStr ; nextEncStr ++ ; } else { encStrLen = strlen ( encStr ) ; } if ( strncasecmp ( encStr , \"raw\" , encStrLen ) == 0 ) { encs [ se -> nEncodings ++ ] = rfbClientSwap32IfLE ( rfbEncodingRaw ) ; } else if ( strncasecmp ( encStr , \"copyrect\" , encStrLen ) == 0 ) { encs [ se -> nEncodings ++ ] = rfbClientSwap32IfLE ( rfbEncodingCopyRect ) ; # ifdef LIBVNCSERVER_HAVE_LIBZ # ifdef LIBVNCSERVER_HAVE_LIBJPEG } else if ( strncasecmp ( encStr , \"tight\" , encStrLen ) == 0 ) { encs [ se -> nEncodings ++ ] = rfbClientSwap32IfLE ( rfbEncodingTight ) ; requestLastRectEncoding = TRUE ; if ( client -> appData . compressLevel >= 0 && client -> appData . compressLevel <= 9 ) requestCompressLevel = TRUE ; if ( client -> appData . enableJPEG ) requestQualityLevel = TRUE ; # endif # endif } else if ( strncasecmp ( encStr , \"hextile\" , encStrLen ) == 0 ) { encs [ se -> nEncodings ++ ] = rfbClientSwap32IfLE ( rfbEncodingHextile ) ; # ifdef LIBVNCSERVER_HAVE_LIBZ } else if ( strncasecmp ( encStr , \"zlib\" , encStrLen ) == 0 ) { encs [ se -> nEncodings ++ ] = rfbClientSwap32IfLE ( rfbEncodingZlib ) ; if ( client -> appData . compressLevel >= 0 && client -> appData . compressLevel <= 9 ) requestCompressLevel = TRUE ; } else if ( strncasecmp ( encStr , \"zlibhex\" , encStrLen ) == 0 ) { encs [ se -> nEncodings ++ ] = rfbClientSwap32IfLE ( rfbEncodingZlibHex ) ; if ( client -> appData . compressLevel >= 0 && client -> appData . compressLevel <= 9 ) requestCompressLevel = TRUE ; } else if ( strncasecmp ( encStr , \"trle\" , encStrLen ) == 0 ) { encs [ se -> nEncodings ++ ] = rfbClientSwap32IfLE ( rfbEncodingTRLE ) ; } else if ( strncasecmp ( encStr , \"zrle\" , encStrLen ) == 0 ) { encs [ se -> nEncodings ++ ] = rfbClientSwap32IfLE ( rfbEncodingZRLE ) ; } else if ( strncasecmp ( encStr , \"zywrle\" , encStrLen ) == 0 ) { encs [ se -> nEncodings ++ ] = rfbClientSwap32IfLE ( rfbEncodingZYWRLE ) ; requestQualityLevel = TRUE ; # endif } else if ( ( strncasecmp ( encStr , \"ultra\" , encStrLen ) == 0 ) || ( strncasecmp ( encStr , \"ultrazip\" , encStrLen ) == 0 ) ) { encs [ se -> nEncodings ++ ] = rfbClientSwap32IfLE ( rfbEncodingUltra ) ; encs [ se -> nEncodings ++ ] = rfbClientSwap32IfLE ( rfbEncodingUltraZip ) ; } else if ( strncasecmp ( encStr , \"corre\" , encStrLen ) == 0 ) { encs [ se -> nEncodings ++ ] = rfbClientSwap32IfLE ( rfbEncodingCoRRE ) ; } else if ( strncasecmp ( encStr , \"rre\" , encStrLen ) == 0 ) { encs [ se -> nEncodings ++ ] = rfbClientSwap32IfLE ( rfbEncodingRRE ) ; } else { rfbClientLog ( \"Unknown<S2SV_blank>encoding<S2SV_blank>\\'%.*s\\'\\\\n\" , encStrLen , encStr ) ; } encStr = nextEncStr ; } while ( encStr && se -> nEncodings < MAX_ENCODINGS ) ; if ( se -> nEncodings < MAX_ENCODINGS && requestCompressLevel ) { encs [ se -> nEncodings ++ ] = rfbClientSwap32IfLE ( client -> appData . compressLevel + rfbEncodingCompressLevel0 ) ; } if ( se -> nEncodings < MAX_ENCODINGS && requestQualityLevel ) { if ( client -> appData . qualityLevel < 0 || client -> appData . qualityLevel > 9 ) client -> appData . qualityLevel = 5 ; encs [ se -> nEncodings ++ ] = rfbClientSwap32IfLE ( client -> appData . qualityLevel + rfbEncodingQualityLevel0 ) ; } } else { if ( SameMachine ( client -> sock ) ) { rfbClientLog ( \"Same<S2SV_blank>machine:<S2SV_blank>preferring<S2SV_blank>raw<S2SV_blank>encoding\\\\n\" ) ; encs [ se -> nEncodings ++ ] = rfbClientSwap32IfLE ( rfbEncodingRaw ) ; } encs [ se -> nEncodings ++ ] = rfbClientSwap32IfLE ( rfbEncodingCopyRect ) ; # ifdef LIBVNCSERVER_HAVE_LIBZ # ifdef LIBVNCSERVER_HAVE_LIBJPEG encs [ se -> nEncodings ++ ] = rfbClientSwap32IfLE ( rfbEncodingTight ) ; requestLastRectEncoding = TRUE ; # endif # endif encs [ se -> nEncodings ++ ] = rfbClientSwap32IfLE ( rfbEncodingHextile ) ; # ifdef LIBVNCSERVER_HAVE_LIBZ encs [ se -> nEncodings ++ ] = rfbClientSwap32IfLE ( rfbEncodingZlib ) ; encs [ se -> nEncodings ++ ] = rfbClientSwap32IfLE ( rfbEncodingZRLE ) ; encs [ se -> nEncodings ++ ] = rfbClientSwap32IfLE ( rfbEncodingZYWRLE ) ; # endif encs [ se -> nEncodings ++ ] = rfbClientSwap32IfLE ( rfbEncodingUltra ) ; encs [ se -> nEncodings ++ ] = rfbClientSwap32IfLE ( rfbEncodingUltraZip ) ; encs [ se -> nEncodings ++ ] = rfbClientSwap32IfLE ( rfbEncodingCoRRE ) ; encs [ se -> nEncodings ++ ] = rfbClientSwap32IfLE ( rfbEncodingRRE ) ; if ( client -> appData . compressLevel >= 0 && client -> appData . compressLevel <= 9 ) { encs [ se -> nEncodings ++ ] = rfbClientSwap32IfLE ( client -> appData . compressLevel + rfbEncodingCompressLevel0 ) ; } else { encs [ se -> nEncodings ++ ] = rfbClientSwap32IfLE ( rfbEncodingCompressLevel1 ) ; } if ( client -> appData . enableJPEG ) { if ( client -> appData . qualityLevel < 0 || client -> appData . qualityLevel > 9 ) client -> appData . qualityLevel = 5 ; encs [ se -> nEncodings ++ ] = rfbClientSwap32IfLE ( client -> appData . qualityLevel + rfbEncodingQualityLevel0 ) ; } } if ( client -> appData . useRemoteCursor ) { if ( se -> nEncodings < MAX_ENCODINGS ) encs [ se -> nEncodings ++ ] = rfbClientSwap32IfLE ( rfbEncodingXCursor ) ; if ( se -> nEncodings < MAX_ENCODINGS ) encs [ se -> nEncodings ++ ] = rfbClientSwap32IfLE ( rfbEncodingRichCursor ) ; if ( se -> nEncodings < MAX_ENCODINGS ) encs [ se -> nEncodings ++ ] = rfbClientSwap32IfLE ( rfbEncodingPointerPos ) ; } if ( se -> nEncodings < MAX_ENCODINGS ) encs [ se -> nEncodings ++ ] = rfbClientSwap32IfLE ( rfbEncodingKeyboardLedState ) ; if ( se -> nEncodings < MAX_ENCODINGS && client -> canHandleNewFBSize ) encs [ se -> nEncodings ++ ] = rfbClientSwap32IfLE ( rfbEncodingNewFBSize ) ; if ( se -> nEncodings < MAX_ENCODINGS && requestLastRectEncoding ) encs [ se -> nEncodings ++ ] = rfbClientSwap32IfLE ( rfbEncodingLastRect ) ; if ( se -> nEncodings < MAX_ENCODINGS ) encs [ se -> nEncodings ++ ] = rfbClientSwap32IfLE ( rfbEncodingSupportedMessages ) ; if ( se -> nEncodings < MAX_ENCODINGS ) encs [ se -> nEncodings ++ ] = rfbClientSwap32IfLE ( rfbEncodingSupportedEncodings ) ; if ( se -> nEncodings < MAX_ENCODINGS ) encs [ se -> nEncodings ++ ] = rfbClientSwap32IfLE ( rfbEncodingServerIdentity ) ; if ( se -> nEncodings < MAX_ENCODINGS ) encs [ se -> nEncodings ++ ] = rfbClientSwap32IfLE ( rfbEncodingXvp ) ; for ( e = rfbClientExtensions ; e ; e = e -> next ) if ( e -> encodings ) { int * enc ; for ( enc = e -> encodings ; * enc ; enc ++ ) if ( se -> nEncodings < MAX_ENCODINGS ) encs [ se -> nEncodings ++ ] = rfbClientSwap32IfLE ( * enc ) ; } len = sz_rfbSetEncodingsMsg + se -> nEncodings * 4 ; se -> nEncodings = rfbClientSwap16IfLE ( se -> nEncodings ) ; <S2SV_StartBug> if ( ! WriteToRFBServer ( client , buf , len ) ) return FALSE ; <S2SV_EndBug> return TRUE ; }\n","target":"<S2SV_ModStart> rfbSetPixelFormatMsg spf ; union { char bytes <S2SV_ModEnd> [ sz_rfbSetEncodingsMsg + <S2SV_ModStart> ] ; rfbSetEncodingsMsg msg ; } buf ; rfbSetEncodingsMsg * se = & buf . msg <S2SV_ModEnd> ; uint32_t * <S2SV_ModStart> ( & buf . bytes <S2SV_ModStart> client , buf . bytes\n","project_and_commit_id":"LibVNC@libvncserver/23e5cbe6b090d7f22982aee909a6a618174d3c2d","cve_id":"CVE-2020-14399","original_address":"https://github.com/LibVNC/libvncserver/commit/23e5cbe6b090d7f22982aee909a6a618174d3c2d","time":"2020-06-17T16:15Z"},
	{"Unnamed: 0":1633,"cwe_id":"CWE-74","source":"CWE-74 int imap_open_connection ( struct ImapAccountData * adata ) { if ( mutt_socket_open ( adata -> conn ) < 0 ) return - 1 ; adata -> state = IMAP_CONNECTED ; if ( imap_cmd_step ( adata ) != IMAP_RES_OK ) { imap_close_connection ( adata ) ; return - 1 ; } if ( mutt_str_startswith ( adata -> buf , \"*<S2SV_blank>OK\" , CASE_IGNORE ) ) { if ( ! mutt_str_startswith ( adata -> buf , \"*<S2SV_blank>OK<S2SV_blank>[CAPABILITY\" , CASE_IGNORE ) && check_capabilities ( adata ) ) { goto bail ; } # ifdef USE_SSL if ( ! adata -> conn -> ssf && ( C_SslForceTls || ( adata -> capabilities & IMAP_CAP_STARTTLS ) ) ) { enum QuadOption ans ; if ( C_SslForceTls ) ans = MUTT_YES ; else if ( ( ans = query_quadoption ( C_SslStarttls , _ ( \"Secure<S2SV_blank>connection<S2SV_blank>with<S2SV_blank>TLS?\" ) ) ) == MUTT_ABORT ) { goto err_close_conn ; } if ( ans == MUTT_YES ) { <S2SV_StartBug> enum ImapExecResult rc = imap_exec ( adata , \"STARTTLS\" , IMAP_CMD_NO_FLAGS ) ; <S2SV_EndBug> if ( rc == IMAP_EXEC_FATAL ) goto bail ; if ( rc != IMAP_EXEC_ERROR ) { if ( mutt_ssl_starttls ( adata -> conn ) ) { mutt_error ( _ ( \"Could<S2SV_blank>not<S2SV_blank>negotiate<S2SV_blank>TLS<S2SV_blank>connection\" ) ) ; goto err_close_conn ; } else { if ( imap_exec ( adata , \"CAPABILITY\" , IMAP_CMD_NO_FLAGS ) ) goto bail ; } } } } if ( C_SslForceTls && ! adata -> conn -> ssf ) { mutt_error ( _ ( \"Encrypted<S2SV_blank>connection<S2SV_blank>unavailable\" ) ) ; goto err_close_conn ; } # endif } else if ( mutt_str_startswith ( adata -> buf , \"*<S2SV_blank>PREAUTH\" , CASE_IGNORE ) ) { # ifdef USE_SSL if ( adata -> conn -> ssf == 0 ) { bool proceed = true ; if ( C_SslForceTls ) { proceed = false ; } else if ( C_SslStarttls != MUTT_NO ) { proceed = mutt_yesorno ( _ ( \"Abort<S2SV_blank>unencrypted<S2SV_blank>PREAUTH<S2SV_blank>connection?\" ) , C_SslStarttls ) != MUTT_NO ; } if ( ! proceed ) { mutt_error ( _ ( \"Encrypted<S2SV_blank>connection<S2SV_blank>unavailable\" ) ) ; goto err_close_conn ; } } # endif adata -> state = IMAP_AUTHENTICATED ; if ( check_capabilities ( adata ) != 0 ) goto bail ; FREE ( & adata -> capstr ) ; } else { imap_error ( \"imap_open_connection()\" , adata -> buf ) ; goto bail ; } return 0 ; # ifdef USE_SSL err_close_conn : imap_close_connection ( adata ) ; # endif bail : FREE ( & adata -> capstr ) ; return - 1 ; }\n","target":"<S2SV_ModStart> , \"STARTTLS\" , IMAP_CMD_SINGLE ) ; mutt_socket_empty ( adata -> conn <S2SV_ModEnd> ) ; if\n","project_and_commit_id":"neomutt@neomutt/fb013ec666759cb8a9e294347c7b4c1f597639cc","cve_id":"CVE-2020-14954","original_address":"https://github.com/neomutt/neomutt/commit/fb013ec666759cb8a9e294347c7b4c1f597639cc","time":"2020-06-21T17:15Z"},
	{"Unnamed: 0":2330,"cwe_id":"CWE-190","source":"CWE-190 int jas_matrix_cmp ( jas_matrix_t * mat0 , jas_matrix_t * mat1 ) { <S2SV_StartBug> int i ; <S2SV_EndBug> int j ; if ( mat0 -> numrows_ != mat1 -> numrows_ || mat0 -> numcols_ != mat1 -> numcols_ ) { return 1 ; } for ( i = 0 ; i < mat0 -> numrows_ ; i ++ ) { for ( j = 0 ; j < mat0 -> numcols_ ; j ++ ) { if ( jas_matrix_get ( mat0 , i , j ) != jas_matrix_get ( mat1 , i , j ) ) { return 1 ; } } } return 0 ; }\n","target":"<S2SV_ModStart> mat1 ) { jas_matind_t i ; jas_matind_t <S2SV_ModEnd> j ; if\n","project_and_commit_id":"mdadams@jasper/d42b2388f7f8e0332c846675133acea151fc557a","cve_id":"CVE-2016-9557","original_address":"https://github.com/mdadams/jasper/commit/d42b2388f7f8e0332c846675133acea151fc557a","time":"2017-03-23T18:59Z"},
	{"Unnamed: 0":4716,"cwe_id":"CWE-119","source":"CWE-119 static ssize_t __nfs4_get_acl_uncached ( struct inode * inode , void * buf , size_t buflen ) { struct page * pages [ NFS4ACL_MAXPAGES ] = { NULL , } ; struct nfs_getaclargs args = { . fh = NFS_FH ( inode ) , . acl_pages = pages , . acl_len = buflen , } ; struct nfs_getaclres res = { . acl_len = buflen , } ; struct rpc_message msg = { . rpc_proc = & nfs4_procedures [ NFSPROC4_CLNT_GETACL ] , . rpc_argp = & args , . rpc_resp = & res , } ; unsigned int npages = DIV_ROUND_UP ( buflen , PAGE_SIZE ) ; int ret = - ENOMEM , i ; if ( npages == 0 ) npages = 1 ; if ( npages > ARRAY_SIZE ( pages ) ) return - ERANGE ; for ( i = 0 ; i < npages ; i ++ ) { pages [ i ] = alloc_page ( GFP_KERNEL ) ; if ( ! pages [ i ] ) goto out_free ; } res . acl_scratch = alloc_page ( GFP_KERNEL ) ; if ( ! res . acl_scratch ) goto out_free ; args . acl_len = npages * PAGE_SIZE ; args . acl_pgbase = 0 ; dprintk ( \"%s<S2SV_blank><S2SV_blank>buf<S2SV_blank>%p<S2SV_blank>buflen<S2SV_blank>%zu<S2SV_blank>npages<S2SV_blank>%d<S2SV_blank>args.acl_len<S2SV_blank>%zu\\\\n\" , __func__ , buf , buflen , npages , args . acl_len ) ; ret = nfs4_call_sync ( NFS_SERVER ( inode ) -> client , NFS_SERVER ( inode ) , & msg , & args . seq_args , & res . seq_res , 0 ) ; if ( ret ) goto out_free ; if ( res . acl_flags & NFS4_ACL_TRUNC ) { if ( buf == NULL ) goto out_ok ; ret = - ERANGE ; goto out_free ; } nfs4_write_cached_acl ( inode , pages , res . acl_data_offset , res . acl_len ) ; <S2SV_StartBug> if ( buf ) <S2SV_EndBug> <S2SV_StartBug> _copy_from_pages ( buf , pages , res . acl_data_offset , res . acl_len ) ; <S2SV_EndBug> out_ok : ret = res . acl_len ; out_free : for ( i = 0 ; i < npages ; i ++ ) if ( pages [ i ] ) __free_page ( pages [ i ] ) ; if ( res . acl_scratch ) __free_page ( res . acl_scratch ) ; return ret ; }\n","target":"<S2SV_ModStart> ( buf ) { if ( res . acl_len > buflen ) { ret = - ERANGE ; goto out_free ; } <S2SV_ModStart> acl_len ) ; }\n","project_and_commit_id":"torvalds@linux/7d3e91a89b7adbc2831334def9e494dd9892f9af","cve_id":"CVE-2013-4591","original_address":"https://github.com/torvalds/linux/commit/7d3e91a89b7adbc2831334def9e494dd9892f9af","time":"2013-11-20T13:19Z"},
	{"Unnamed: 0":284,"cwe_id":"CWE-611","source":"CWE-611 void xmlParsePEReference ( xmlParserCtxtPtr ctxt ) { const xmlChar * name ; xmlEntityPtr entity = NULL ; xmlParserInputPtr input ; if ( RAW != '%' ) return ; NEXT ; name = xmlParseName ( ctxt ) ; if ( name == NULL ) { xmlFatalErrMsg ( ctxt , XML_ERR_NAME_REQUIRED , \"xmlParsePEReference:<S2SV_blank>no<S2SV_blank>name\\\\n\" ) ; return ; } if ( RAW != ';' ) { xmlFatalErr ( ctxt , XML_ERR_ENTITYREF_SEMICOL_MISSING , NULL ) ; return ; } NEXT ; ctxt -> nbentities ++ ; if ( ( ctxt -> sax != NULL ) && ( ctxt -> sax -> getParameterEntity != NULL ) ) entity = ctxt -> sax -> getParameterEntity ( ctxt -> userData , name ) ; if ( ctxt -> instate == XML_PARSER_EOF ) return ; if ( entity == NULL ) { if ( ( ctxt -> standalone == 1 ) || ( ( ctxt -> hasExternalSubset == 0 ) && ( ctxt -> hasPErefs == 0 ) ) ) { xmlFatalErrMsgStr ( ctxt , XML_ERR_UNDECLARED_ENTITY , \"PEReference:<S2SV_blank>%%%s;<S2SV_blank>not<S2SV_blank>found\\\\n\" , name ) ; } else { xmlWarningMsg ( ctxt , XML_WAR_UNDECLARED_ENTITY , \"PEReference:<S2SV_blank>%%%s;<S2SV_blank>not<S2SV_blank>found\\\\n\" , name , NULL ) ; ctxt -> valid = 0 ; } xmlParserEntityCheck ( ctxt , 0 , NULL , 0 ) ; } else { if ( ( entity -> etype != XML_INTERNAL_PARAMETER_ENTITY ) && ( entity -> etype != XML_EXTERNAL_PARAMETER_ENTITY ) ) { xmlWarningMsg ( ctxt , XML_WAR_UNDECLARED_ENTITY , \"Internal:<S2SV_blank>%%%s;<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>parameter<S2SV_blank>entity\\\\n\" , name , NULL ) ; } else if ( ctxt -> input -> free != deallocblankswrapper ) { input = xmlNewBlanksWrapperInputStream ( ctxt , entity ) ; if ( xmlPushInput ( ctxt , input ) < 0 ) return ; } else { <S2SV_StartBug> input = xmlNewEntityInputStream ( ctxt , entity ) ; <S2SV_EndBug> if ( xmlPushInput ( ctxt , input ) < 0 ) return ; if ( ( entity -> etype == XML_EXTERNAL_PARAMETER_ENTITY ) && ( CMP5 ( CUR_PTR , '<' , '?' , 'x' , 'm' , 'l' ) ) && ( IS_BLANK_CH ( NXT ( 5 ) ) ) ) { xmlParseTextDecl ( ctxt ) ; if ( ctxt -> errNo == XML_ERR_UNSUPPORTED_ENCODING ) { xmlHaltParser ( ctxt ) ; return ; } } } } ctxt -> hasPErefs = 1 ; }\n","target":"<S2SV_ModStart> } else { if ( ( entity -> etype == XML_EXTERNAL_PARAMETER_ENTITY ) && ( ( ctxt -> options & XML_PARSE_NOENT ) == 0 ) && ( ( ctxt -> options & XML_PARSE_DTDVALID ) == 0 ) && ( ( ctxt -> options & XML_PARSE_DTDLOAD ) == 0 ) && ( ( ctxt -> options & XML_PARSE_DTDATTR ) == 0 ) && ( ctxt -> replaceEntities == 0 ) && ( ctxt -> validate == 0 ) ) return ;\n","project_and_commit_id":"external@libxml2/308396a55280f69ad4112d4f9892f4cbeff042aa","cve_id":"CVE-2017-7375","original_address":"https://android.googlesource.com/platform/external/libxml2/+/308396a55280f69ad4112d4f9892f4cbeff042aa","time":"2018-02-19T19:29Z"},
	{"Unnamed: 0":6526,"cwe_id":"CWE-399","source":"CWE-399 static void vmx_set_constant_host_state ( struct vcpu_vmx * vmx ) { u32 low32 , high32 ; unsigned long tmpl ; struct desc_ptr dt ; <S2SV_StartBug> vmcs_writel ( HOST_CR0 , read_cr0 ( ) & ~ X86_CR0_TS ) ; <S2SV_EndBug> <S2SV_StartBug> vmcs_writel ( HOST_CR4 , read_cr4 ( ) ) ; <S2SV_EndBug> vmcs_writel ( HOST_CR3 , read_cr3 ( ) ) ; vmcs_write16 ( HOST_CS_SELECTOR , __KERNEL_CS ) ; # ifdef CONFIG_X86_64 vmcs_write16 ( HOST_DS_SELECTOR , 0 ) ; vmcs_write16 ( HOST_ES_SELECTOR , 0 ) ; # else vmcs_write16 ( HOST_DS_SELECTOR , __KERNEL_DS ) ; vmcs_write16 ( HOST_ES_SELECTOR , __KERNEL_DS ) ; # endif vmcs_write16 ( HOST_SS_SELECTOR , __KERNEL_DS ) ; vmcs_write16 ( HOST_TR_SELECTOR , GDT_ENTRY_TSS * 8 ) ; native_store_idt ( & dt ) ; vmcs_writel ( HOST_IDTR_BASE , dt . address ) ; vmx -> host_idt_base = dt . address ; vmcs_writel ( HOST_RIP , vmx_return ) ; rdmsr ( MSR_IA32_SYSENTER_CS , low32 , high32 ) ; vmcs_write32 ( HOST_IA32_SYSENTER_CS , low32 ) ; rdmsrl ( MSR_IA32_SYSENTER_EIP , tmpl ) ; vmcs_writel ( HOST_IA32_SYSENTER_EIP , tmpl ) ; if ( vmcs_config . vmexit_ctrl & VM_EXIT_LOAD_IA32_PAT ) { rdmsr ( MSR_IA32_CR_PAT , low32 , high32 ) ; vmcs_write64 ( HOST_IA32_PAT , low32 | ( ( u64 ) high32 << 32 ) ) ; } }\n","target":"<S2SV_ModStart> desc_ptr dt ; unsigned long cr4 ; <S2SV_ModStart> ; vmcs_writel ( HOST_CR3 , read_cr3 ( ) ) ; cr4 = read_cr4 ( ) ; vmcs_writel ( HOST_CR4 , cr4 ) ; vmx -> host_state . vmcs_host_cr4 = cr4 <S2SV_ModEnd> ; vmcs_write16 (\n","project_and_commit_id":"torvalds@linux/d974baa398f34393db76be45f7d4d04fbdbb4a0a","cve_id":"CVE-2014-3690","original_address":"https://github.com/torvalds/linux/commit/d974baa398f34393db76be45f7d4d04fbdbb4a0a","time":"2014-11-10T11:55Z"},
	{"Unnamed: 0":6744,"cwe_id":"CWE-000","source":"CWE-000 int config__parse_args ( struct mosquitto_db * db , struct mosquitto__config * config , int argc , char * argv [ ] ) { int i ; int port_tmp ; for ( i = 1 ; i < argc ; i ++ ) { if ( ! strcmp ( argv [ i ] , \"-c\" ) || ! strcmp ( argv [ i ] , \"--config-file\" ) ) { if ( i < argc - 1 ) { db -> config_file = argv [ i + 1 ] ; if ( config__read ( db , config , false ) ) { log__printf ( NULL , MOSQ_LOG_ERR , \"Error:<S2SV_blank>Unable<S2SV_blank>to<S2SV_blank>open<S2SV_blank>configuration<S2SV_blank>file.\" ) ; return MOSQ_ERR_INVAL ; } } else { log__printf ( NULL , MOSQ_LOG_ERR , \"Error:<S2SV_blank>-c<S2SV_blank>argument<S2SV_blank>given,<S2SV_blank>but<S2SV_blank>no<S2SV_blank>config<S2SV_blank>file<S2SV_blank>specified.\" ) ; return MOSQ_ERR_INVAL ; } i ++ ; } else if ( ! strcmp ( argv [ i ] , \"-d\" ) || ! strcmp ( argv [ i ] , \"--daemon\" ) ) { config -> daemon = true ; } else if ( ! strcmp ( argv [ i ] , \"-h\" ) || ! strcmp ( argv [ i ] , \"--help\" ) ) { print_usage ( ) ; return MOSQ_ERR_INVAL ; } else if ( ! strcmp ( argv [ i ] , \"-p\" ) || ! strcmp ( argv [ i ] , \"--port\" ) ) { if ( i < argc - 1 ) { port_tmp = atoi ( argv [ i + 1 ] ) ; if ( port_tmp < 1 || port_tmp > 65535 ) { log__printf ( NULL , MOSQ_LOG_ERR , \"Error:<S2SV_blank>Invalid<S2SV_blank>port<S2SV_blank>specified<S2SV_blank>(%d).\" , port_tmp ) ; return MOSQ_ERR_INVAL ; } else { if ( config -> default_listener . port ) { log__printf ( NULL , MOSQ_LOG_WARNING , \"Warning:<S2SV_blank>Default<S2SV_blank>listener<S2SV_blank>port<S2SV_blank>specified<S2SV_blank>multiple<S2SV_blank>times.<S2SV_blank>Only<S2SV_blank>the<S2SV_blank>latest<S2SV_blank>will<S2SV_blank>be<S2SV_blank>used.\" ) ; } config -> default_listener . port = port_tmp ; } } else { log__printf ( NULL , MOSQ_LOG_ERR , \"Error:<S2SV_blank>-p<S2SV_blank>argument<S2SV_blank>given,<S2SV_blank>but<S2SV_blank>no<S2SV_blank>port<S2SV_blank>specified.\" ) ; return MOSQ_ERR_INVAL ; } i ++ ; } else if ( ! strcmp ( argv [ i ] , \"-v\" ) || ! strcmp ( argv [ i ] , \"--verbose\" ) ) { db -> verbose = true ; } else { fprintf ( stderr , \"Error:<S2SV_blank>Unknown<S2SV_blank>option<S2SV_blank>\\'%s\\'.\\\\n\" , argv [ i ] ) ; print_usage ( ) ; return MOSQ_ERR_INVAL ; } } if ( config -> listener_count == 0 # ifdef WITH_TLS || config -> default_listener . cafile || config -> default_listener . capath || config -> default_listener . certfile || config -> default_listener . keyfile || config -> default_listener . ciphers || config -> default_listener . psk_hint || config -> default_listener . require_certificate || config -> default_listener . crlfile || config -> default_listener . use_identity_as_username || config -> default_listener . use_subject_as_username # endif || config -> default_listener . use_username_as_clientid || config -> default_listener . host || config -> default_listener . port || config -> default_listener . max_connections != - 1 || config -> default_listener . mount_point || config -> default_listener . protocol != mp_mqtt || config -> default_listener . socket_domain || config -> default_listener . security_options . password_file || config -> default_listener . security_options . psk_file || config -> default_listener . security_options . auth_plugin_config_count || config -> default_listener . security_options . allow_anonymous != - 1 ) { config -> listener_count ++ ; config -> listeners = mosquitto__realloc ( config -> listeners , sizeof ( struct mosquitto__listener ) * config -> listener_count ) ; if ( ! config -> listeners ) { log__printf ( NULL , MOSQ_LOG_ERR , \"Error:<S2SV_blank>Out<S2SV_blank>of<S2SV_blank>memory.\" ) ; return MOSQ_ERR_NOMEM ; } memset ( & config -> listeners [ config -> listener_count - 1 ] , 0 , sizeof ( struct mosquitto__listener ) ) ; if ( config -> default_listener . port ) { config -> listeners [ config -> listener_count - 1 ] . port = config -> default_listener . port ; } else { config -> listeners [ config -> listener_count - 1 ] . port = 1883 ; } if ( config -> default_listener . host ) { config -> listeners [ config -> listener_count - 1 ] . host = config -> default_listener . host ; } else { config -> listeners [ config -> listener_count - 1 ] . host = NULL ; } if ( config -> default_listener . mount_point ) { config -> listeners [ config -> listener_count - 1 ] . mount_point = config -> default_listener . mount_point ; } else { config -> listeners [ config -> listener_count - 1 ] . mount_point = NULL ; } config -> listeners [ config -> listener_count - 1 ] . max_connections = config -> default_listener . max_connections ; config -> listeners [ config -> listener_count - 1 ] . protocol = config -> default_listener . protocol ; config -> listeners [ config -> listener_count - 1 ] . socket_domain = config -> default_listener . socket_domain ; config -> listeners [ config -> listener_count - 1 ] . client_count = 0 ; config -> listeners [ config -> listener_count - 1 ] . socks = NULL ; config -> listeners [ config -> listener_count - 1 ] . sock_count = 0 ; config -> listeners [ config -> listener_count - 1 ] . client_count = 0 ; config -> listeners [ config -> listener_count - 1 ] . use_username_as_clientid = config -> default_listener . use_username_as_clientid ; # ifdef WITH_TLS config -> listeners [ config -> listener_count - 1 ] . tls_version = config -> default_listener . tls_version ; config -> listeners [ config -> listener_count - 1 ] . cafile = config -> default_listener . cafile ; config -> listeners [ config -> listener_count - 1 ] . capath = config -> default_listener . capath ; config -> listeners [ config -> listener_count - 1 ] . certfile = config -> default_listener . certfile ; config -> listeners [ config -> listener_count - 1 ] . keyfile = config -> default_listener . keyfile ; config -> listeners [ config -> listener_count - 1 ] . ciphers = config -> default_listener . ciphers ; config -> listeners [ config -> listener_count - 1 ] . psk_hint = config -> default_listener . psk_hint ; config -> listeners [ config -> listener_count - 1 ] . require_certificate = config -> default_listener . require_certificate ; config -> listeners [ config -> listener_count - 1 ] . ssl_ctx = NULL ; config -> listeners [ config -> listener_count - 1 ] . crlfile = config -> default_listener . crlfile ; config -> listeners [ config -> listener_count - 1 ] . use_identity_as_username = config -> default_listener . use_identity_as_username ; config -> listeners [ config -> listener_count - 1 ] . use_subject_as_username = config -> default_listener . use_subject_as_username ; # endif <S2SV_StartBug> config -> listeners [ config -> listener_count - 1 ] . security_options . password_file = config -> default_listener . security_options . password_file ; <S2SV_EndBug> config -> listeners [ config -> listener_count - 1 ] . security_options . psk_file = config -> default_listener . security_options . psk_file ; config -> listeners [ config -> listener_count - 1 ] . security_options . auth_plugin_configs = config -> default_listener . security_options . auth_plugin_configs ; config -> listeners [ config -> listener_count - 1 ] . security_options . auth_plugin_config_count = config -> default_listener . security_options . auth_plugin_config_count ; config -> listeners [ config -> listener_count - 1 ] . security_options . allow_anonymous = config -> default_listener . security_options . allow_anonymous ; } if ( ! config -> user ) { config -> user = \"mosquitto\" ; } if ( db -> verbose ) { config -> log_type = INT_MAX ; } return config__check ( config ) ; }\n","target":"<S2SV_ModStart> . security_options . acl_file = config -> default_listener . security_options . acl_file ; config -> listeners [ config -> listener_count - 1 ] . security_options .\n","project_and_commit_id":"eclipse@mosquitto/9097577b49b7fdcf45d30975976dd93808ccc0c4","cve_id":"CVE-2018-20145","original_address":"https://github.com/eclipse/mosquitto/commit/9097577b49b7fdcf45d30975976dd93808ccc0c4","time":"2018-12-13T20:29Z"},
	{"Unnamed: 0":1162,"cwe_id":"CWE-200","source":"CWE-200 static int load_script ( struct linux_binprm * bprm ) { const char * i_arg , * i_name ; char * cp ; struct file * file ; char interp [ BINPRM_BUF_SIZE ] ; int retval ; if ( ( bprm -> buf [ 0 ] != '#' ) || ( bprm -> buf [ 1 ] != '!' ) ) return - ENOEXEC ; allow_write_access ( bprm -> file ) ; fput ( bprm -> file ) ; bprm -> file = NULL ; bprm -> buf [ BINPRM_BUF_SIZE - 1 ] = '\\\\0' ; if ( ( cp = strchr ( bprm -> buf , '\\\\n' ) ) == NULL ) cp = bprm -> buf + BINPRM_BUF_SIZE - 1 ; * cp = '\\\\0' ; while ( cp > bprm -> buf ) { cp -- ; if ( ( * cp == '<S2SV_blank>' ) || ( * cp == '\\\\t' ) ) * cp = '\\\\0' ; else break ; } for ( cp = bprm -> buf + 2 ; ( * cp == '<S2SV_blank>' ) || ( * cp == '\\\\t' ) ; cp ++ ) ; if ( * cp == '\\\\0' ) return - ENOEXEC ; i_name = cp ; i_arg = NULL ; for ( ; * cp && ( * cp != '<S2SV_blank>' ) && ( * cp != '\\\\t' ) ; cp ++ ) ; while ( ( * cp == '<S2SV_blank>' ) || ( * cp == '\\\\t' ) ) * cp ++ = '\\\\0' ; if ( * cp ) i_arg = cp ; strcpy ( interp , i_name ) ; retval = remove_arg_zero ( bprm ) ; if ( retval ) return retval ; retval = copy_strings_kernel ( 1 , & bprm -> interp , bprm ) ; if ( retval < 0 ) return retval ; bprm -> argc ++ ; if ( i_arg ) { retval = copy_strings_kernel ( 1 , & i_arg , bprm ) ; if ( retval < 0 ) return retval ; bprm -> argc ++ ; } retval = copy_strings_kernel ( 1 , & i_name , bprm ) ; if ( retval ) return retval ; bprm -> argc ++ ; <S2SV_StartBug> bprm -> interp = interp ; <S2SV_EndBug> file = open_exec ( interp ) ; if ( IS_ERR ( file ) ) return PTR_ERR ( file ) ; bprm -> file = file ; retval = prepare_binprm ( bprm ) ; if ( retval < 0 ) return retval ; <S2SV_StartBug> return search_binary_handler ( bprm ) ; <S2SV_EndBug> }\n","target":"<S2SV_ModStart> argc ++ ; retval = bprm_change_interp ( interp , <S2SV_ModEnd> bprm ) ; <S2SV_ModStart> return retval ; file = open_exec ( interp ) ; if ( IS_ERR ( file ) ) return PTR_ERR ( file ) ; bprm -> file = file ; retval = prepare_binprm ( bprm ) ; if ( retval < 0 ) return retval ;\n","project_and_commit_id":"torvalds@linux/b66c5984017533316fd1951770302649baf1aa33","cve_id":"CVE-2012-4530","original_address":"https://github.com/torvalds/linux/commit/b66c5984017533316fd1951770302649baf1aa33","time":"2013-02-18T04:41Z"},
	{"Unnamed: 0":1080,"cwe_id":"CWE-476","source":"CWE-476 unsigned int ip6t_do_table ( struct sk_buff * skb , const struct nf_hook_state * state , struct xt_table * table ) { unsigned int hook = state -> hook ; static const char nulldevname [ IFNAMSIZ ] __attribute__ ( ( aligned ( sizeof ( long ) ) ) ) ; unsigned int verdict = NF_DROP ; const char * indev , * outdev ; const void * table_base ; struct ip6t_entry * e , * * jumpstack ; unsigned int stackidx , cpu ; const struct xt_table_info * private ; struct xt_action_param acpar ; unsigned int addend ; stackidx = 0 ; indev = state -> in ? state -> in -> name : nulldevname ; outdev = state -> out ? state -> out -> name : nulldevname ; acpar . hotdrop = false ; acpar . state = state ; WARN_ON ( ! ( table -> valid_hooks & ( 1 << hook ) ) ) ; local_bh_disable ( ) ; addend = xt_write_recseq_begin ( ) ; private = READ_ONCE ( table -> private ) ; cpu = smp_processor_id ( ) ; table_base = private -> entries ; jumpstack = ( struct ip6t_entry * * ) private -> jumpstack [ cpu ] ; if ( static_key_false ( & xt_tee_enabled ) ) jumpstack += private -> stacksize * __this_cpu_read ( nf_skb_duplicated ) ; e = get_entry ( table_base , private -> hook_entry [ hook ] ) ; do { const struct xt_entry_target * t ; const struct xt_entry_match * ematch ; struct xt_counters * counter ; WARN_ON ( ! e ) ; acpar . thoff = 0 ; if ( ! ip6_packet_match ( skb , indev , outdev , & e -> ipv6 , & acpar . thoff , & acpar . fragoff , & acpar . hotdrop ) ) { no_match : e = ip6t_next_entry ( e ) ; continue ; } xt_ematch_foreach ( ematch , e ) { acpar . match = ematch -> u . kernel . match ; acpar . matchinfo = ematch -> data ; if ( ! acpar . match -> match ( skb , & acpar ) ) goto no_match ; } counter = xt_get_this_cpu_counter ( & e -> counters ) ; ADD_COUNTER ( * counter , skb -> len , 1 ) ; t = ip6t_get_target_c ( e ) ; WARN_ON ( ! t -> u . kernel . target ) ; # if IS_ENABLED ( CONFIG_NETFILTER_XT_TARGET_TRACE ) if ( unlikely ( skb -> nf_trace ) ) trace_packet ( state -> net , skb , hook , state -> in , state -> out , table -> name , private , e ) ; # endif if ( ! t -> u . kernel . target -> target ) { int v ; v = ( ( struct xt_standard_target * ) t ) -> verdict ; if ( v < 0 ) { if ( v != XT_RETURN ) { verdict = ( unsigned int ) ( - v ) - 1 ; break ; } if ( stackidx == 0 ) e = get_entry ( table_base , private -> underflow [ hook ] ) ; else e = ip6t_next_entry ( jumpstack [ -- stackidx ] ) ; continue ; } if ( table_base + v != ip6t_next_entry ( e ) && ! ( e -> ipv6 . flags & IP6T_F_GOTO ) ) { <S2SV_StartBug> jumpstack [ stackidx ++ ] = e ; <S2SV_EndBug> } e = get_entry ( table_base , v ) ; continue ; } acpar . target = t -> u . kernel . target ; acpar . targinfo = t -> data ; verdict = t -> u . kernel . target -> target ( skb , & acpar ) ; if ( verdict == XT_CONTINUE ) e = ip6t_next_entry ( e ) ; else break ; } while ( ! acpar . hotdrop ) ; xt_write_recseq_end ( addend ) ; local_bh_enable ( ) ; if ( acpar . hotdrop ) return NF_DROP ; else return verdict ; }\n","target":"<S2SV_ModStart> ) ) { if ( unlikely ( stackidx >= private -> stacksize ) ) { verdict = NF_DROP ; break ; }\n","project_and_commit_id":"torvalds@linux/57ebd808a97d7c5b1e1afb937c2db22beba3c1f8","cve_id":"CVE-2018-1065","original_address":"https://github.com/torvalds/linux/commit/57ebd808a97d7c5b1e1afb937c2db22beba3c1f8","time":"2018-03-02T08:29Z"},
	{"Unnamed: 0":1637,"cwe_id":"CWE-617","source":"CWE-617 static enum AVPixelFormat h263_get_format ( AVCodecContext * avctx ) <S2SV_StartBug> { <S2SV_EndBug> if ( avctx -> bits_per_raw_sample > 8 ) { <S2SV_StartBug> av_assert1 ( avctx -> profile == FF_PROFILE_MPEG4_SIMPLE_STUDIO ) ; <S2SV_EndBug> return avctx -> pix_fmt ; } if ( avctx -> codec -> id == AV_CODEC_ID_MSS2 ) return AV_PIX_FMT_YUV420P ; if ( CONFIG_GRAY && ( avctx -> flags & AV_CODEC_FLAG_GRAY ) ) { if ( avctx -> color_range == AVCOL_RANGE_UNSPECIFIED ) avctx -> color_range = AVCOL_RANGE_MPEG ; return AV_PIX_FMT_GRAY8 ; } return avctx -> pix_fmt = ff_get_format ( avctx , avctx -> codec -> pix_fmts ) ; }\n","target":"<S2SV_ModStart> avctx ) { MpegEncContext * s = avctx -> priv_data ; <S2SV_ModStart> { av_assert1 ( s -> studio_profile <S2SV_ModEnd> ) ; return\n","project_and_commit_id":"FFmpeg@FFmpeg/bd27a9364ca274ca97f1df6d984e88a0700fb235","cve_id":"CVE-2018-13304","original_address":"https://github.com/FFmpeg/FFmpeg/commit/bd27a9364ca274ca97f1df6d984e88a0700fb235","time":"2018-07-05T17:29Z"},
	{"Unnamed: 0":3944,"cwe_id":"CWE-476","source":"CWE-476 static MagickBooleanType ReadPSDChannel ( Image * image , const ImageInfo * image_info , const PSDInfo * psd_info , LayerInfo * layer_info , const size_t channel , const PSDCompressionType compression , ExceptionInfo * exception ) { Image * channel_image , * mask ; MagickOffsetType offset ; MagickBooleanType status ; channel_image = image ; mask = ( Image * ) NULL ; if ( layer_info -> channel_info [ channel ] . type < - 1 ) { const char * option ; option = GetImageOption ( image_info , \"psd:preserve-opacity-mask\" ) ; if ( ( layer_info -> channel_info [ channel ] . type != - 2 ) || ( layer_info -> mask . flags > 2 ) || ( ( layer_info -> mask . flags & 0x02 ) && ( IsStringTrue ( option ) == MagickFalse ) ) ) { SeekBlob ( image , layer_info -> channel_info [ channel ] . size - 2 , SEEK_CUR ) ; return ( MagickTrue ) ; } mask = CloneImage ( image , layer_info -> mask . page . width , layer_info -> mask . page . height , MagickFalse , exception ) ; <S2SV_StartBug> mask -> matte = MagickFalse ; <S2SV_EndBug> <S2SV_StartBug> channel_image = mask ; <S2SV_EndBug> } offset = TellBlob ( image ) ; status = MagickTrue ; switch ( compression ) { case Raw : status = ReadPSDChannelRaw ( channel_image , psd_info -> channels , layer_info -> channel_info [ channel ] . type , exception ) ; break ; case RLE : { MagickOffsetType * sizes ; sizes = ReadPSDRLESizes ( channel_image , psd_info , channel_image -> rows ) ; if ( sizes == ( MagickOffsetType * ) NULL ) ThrowBinaryException ( ResourceLimitError , \"MemoryAllocationFailed\" , image -> filename ) ; status = ReadPSDChannelRLE ( channel_image , psd_info , layer_info -> channel_info [ channel ] . type , sizes , exception ) ; sizes = ( MagickOffsetType * ) RelinquishMagickMemory ( sizes ) ; } break ; case ZipWithPrediction : case ZipWithoutPrediction : # ifdef MAGICKCORE_ZLIB_DELEGATE status = ReadPSDChannelZip ( channel_image , layer_info -> channels , layer_info -> channel_info [ channel ] . type , compression , layer_info -> channel_info [ channel ] . size - 2 , exception ) ; # else ( void ) ThrowMagickException ( exception , GetMagickModule ( ) , MissingDelegateWarning , \"DelegateLibrarySupportNotBuiltIn\" , \"\\'%s\\'<S2SV_blank>(ZLIB)\" , image -> filename ) ; # endif break ; default : ( void ) ThrowMagickException ( exception , GetMagickModule ( ) , TypeWarning , \"CompressionNotSupported\" , \"\\'%.20g\\'\" , ( double ) compression ) ; break ; } SeekBlob ( image , offset + layer_info -> channel_info [ channel ] . size - 2 , SEEK_SET ) ; if ( status == MagickFalse ) { if ( mask != ( Image * ) NULL ) DestroyImage ( mask ) ; ThrowBinaryException ( CoderError , \"UnableToDecompressImage\" , image -> filename ) ; } layer_info -> mask . image = mask ; return ( status ) ; }\n","target":"<S2SV_ModStart> exception ) ; if ( mask != ( Image * ) NULL ) { <S2SV_ModStart> = mask ; }\n","project_and_commit_id":"ImageMagick@ImageMagick/7f2dc7a1afc067d0c89f12c82bcdec0445fb1b94","cve_id":"CVE-2017-6497","original_address":"https://github.com/ImageMagick/ImageMagick/commit/7f2dc7a1afc067d0c89f12c82bcdec0445fb1b94","time":"2017-03-06T02:59Z"},
	{"Unnamed: 0":1460,"cwe_id":"CWE-444","source":"CWE-444 static void * listen_loop ( void * x ) { int optval = 1 ; struct pollfd pa [ 100 ] ; struct pollfd * p ; struct _agooErr err = AGOO_ERR_INIT ; struct sockaddr_in client_addr ; int client_sock ; int pcnt = 0 ; socklen_t alen = 0 ; agooCon con ; int i ; uint64_t cnt = 0 ; agooBind b ; for ( b = agoo_server . binds , p = pa ; NULL != b ; b = b -> next , p ++ , pcnt ++ ) { p -> fd = b -> fd ; p -> events = POLLIN ; p -> revents = 0 ; } memset ( & client_addr , 0 , sizeof ( client_addr ) ) ; atomic_fetch_add ( & agoo_server . running , 1 ) ; while ( agoo_server . active ) { if ( 0 > ( i = poll ( pa , pcnt , 200 ) ) ) { if ( EAGAIN == errno ) { continue ; } agoo_log_cat ( & agoo_error_cat , \"Server<S2SV_blank>polling<S2SV_blank>error.<S2SV_blank>%s.\" , strerror ( errno ) ) ; break ; } if ( 0 == i ) { continue ; } for ( b = agoo_server . binds , p = pa ; NULL != b ; b = b -> next , p ++ ) { if ( 0 != ( p -> revents & POLLIN ) ) { if ( 0 > ( client_sock = accept ( p -> fd , ( struct sockaddr * ) & client_addr , & alen ) ) ) { agoo_log_cat ( & agoo_error_cat , \"Server<S2SV_blank>with<S2SV_blank>pid<S2SV_blank>%d<S2SV_blank>accept<S2SV_blank>connection<S2SV_blank>failed.<S2SV_blank>%s.\" , getpid ( ) , strerror ( errno ) ) ; } else if ( NULL == ( con = agoo_con_create ( & err , client_sock , ++ cnt , b ) ) ) { agoo_log_cat ( & agoo_error_cat , \"Server<S2SV_blank>with<S2SV_blank>pid<S2SV_blank>%d<S2SV_blank>accept<S2SV_blank>connection<S2SV_blank>failed.<S2SV_blank>%s.\" , getpid ( ) , err . msg ) ; close ( client_sock ) ; cnt -- ; agoo_err_clear ( & err ) ; } else { int con_cnt ; # ifdef OSX_OS setsockopt ( client_sock , SOL_SOCKET , SO_NOSIGPIPE , & optval , sizeof ( optval ) ) ; # endif # ifdef PLATFORM_LINUX setsockopt ( client_sock , IPPROTO_TCP , TCP_QUICKACK , & optval , sizeof ( optval ) ) ; # endif fcntl ( client_sock , F_SETFL , O_NONBLOCK ) ; setsockopt ( client_sock , SOL_SOCKET , SO_KEEPALIVE , & optval , sizeof ( optval ) ) ; setsockopt ( client_sock , IPPROTO_TCP , TCP_NODELAY , & optval , sizeof ( optval ) ) ; <S2SV_StartBug> agoo_log_cat ( & agoo_con_cat , \"Server<S2SV_blank>with<S2SV_blank>pid<S2SV_blank>%d<S2SV_blank>accepted<S2SV_blank>connection<S2SV_blank>%llu<S2SV_blank>on<S2SV_blank>%s<S2SV_blank>[%d]\" , <S2SV_EndBug> <S2SV_StartBug> getpid ( ) , ( unsigned long long ) cnt , b -> id , con -> sock ) ; <S2SV_EndBug> con_cnt = atomic_fetch_add ( & agoo_server . con_cnt , 1 ) ; if ( agoo_server . loop_max > agoo_server . loop_cnt && agoo_server . loop_cnt * LOOP_UP < con_cnt ) { add_con_loop ( ) ; } agoo_queue_push ( & agoo_server . con_queue , ( void * ) con ) ; } } if ( 0 != ( p -> revents & ( POLLERR | POLLHUP | POLLNVAL ) ) ) { if ( 0 != ( p -> revents & ( POLLHUP | POLLNVAL ) ) ) { agoo_log_cat ( & agoo_error_cat , \"Agoo<S2SV_blank>server<S2SV_blank>with<S2SV_blank>pid<S2SV_blank>%d<S2SV_blank>socket<S2SV_blank>on<S2SV_blank>%s<S2SV_blank>closed.\" , getpid ( ) , b -> id ) ; } else { agoo_log_cat ( & agoo_error_cat , \"Agoo<S2SV_blank>server<S2SV_blank>with<S2SV_blank>pid<S2SV_blank>%d<S2SV_blank>socket<S2SV_blank>on<S2SV_blank>%s<S2SV_blank>error.\" , getpid ( ) , b -> id ) ; } agoo_server . active = false ; } p -> revents = 0 ; } } for ( b = agoo_server . binds ; NULL != b ; b = b -> next ) { agoo_bind_close ( b ) ; } atomic_fetch_sub ( & agoo_server . running , 1 ) ; return NULL ; }\n","target":"<S2SV_ModStart> & agoo_con_cat , \"Server<S2SV_blank>with<S2SV_blank>pid<S2SV_blank>%d<S2SV_blank>accepted<S2SV_blank>connection<S2SV_blank>%llu<S2SV_blank>on<S2SV_blank>%s<S2SV_blank>[%d]<S2SV_blank>from<S2SV_blank>%s\" <S2SV_ModEnd> , getpid ( <S2SV_ModStart> con -> sock , con -> remote\n","project_and_commit_id":"ohler55@agoo/23d03535cf7b50d679a60a953a0cae9519a4a130","cve_id":"CVE-2020-7670","original_address":"https://github.com/ohler55/agoo/commit/23d03535cf7b50d679a60a953a0cae9519a4a130","time":"2020-06-10T16:15Z"},
	{"Unnamed: 0":3406,"cwe_id":"CWE-400","source":"CWE-400 static int simulate_rdhwr ( struct pt_regs * regs , unsigned int opcode ) { struct thread_info * ti = task_thread_info ( current ) ; if ( ( opcode & OPCODE ) == SPEC3 && ( opcode & FUNC ) == RDHWR ) { int rd = ( opcode & RD ) >> 11 ; int rt = ( opcode & RT ) >> 16 ; perf_sw_event ( PERF_COUNT_SW_EMULATION_FAULTS , <S2SV_StartBug> 1 , 0 , regs , 0 ) ; <S2SV_EndBug> switch ( rd ) { case 0 : regs -> regs [ rt ] = smp_processor_id ( ) ; return 0 ; case 1 : regs -> regs [ rt ] = min ( current_cpu_data . dcache . linesz , current_cpu_data . icache . linesz ) ; return 0 ; case 2 : regs -> regs [ rt ] = read_c0_count ( ) ; return 0 ; case 3 : switch ( current_cpu_data . cputype ) { case CPU_20KC : case CPU_25KF : regs -> regs [ rt ] = 1 ; break ; default : regs -> regs [ rt ] = 2 ; } return 0 ; case 29 : regs -> regs [ rt ] = ti -> tp_value ; return 0 ; default : return - 1 ; } } return - 1 ; }\n","target":"<S2SV_ModStart> , 1 , <S2SV_ModEnd> regs , 0\n","project_and_commit_id":"torvalds@linux/a8b0ca17b80e92faab46ee7179ba9e99ccb61233","cve_id":"CVE-2011-2918","original_address":"https://github.com/torvalds/linux/commit/a8b0ca17b80e92faab46ee7179ba9e99ccb61233","time":"2012-05-24T23:55Z"},
	{"Unnamed: 0":1448,"cwe_id":"CWE-119","source":"CWE-119 static inline int check_entry_size_and_hooks ( struct arpt_entry * e , struct xt_table_info * newinfo , const unsigned char * base , const unsigned char * limit , const unsigned int * hook_entries , const unsigned int * underflows , unsigned int valid_hooks ) { unsigned int h ; int err ; if ( ( unsigned long ) e % __alignof__ ( struct arpt_entry ) != 0 || ( unsigned char * ) e + sizeof ( struct arpt_entry ) >= limit || ( unsigned char * ) e + e -> next_offset > limit ) { duprintf ( \"Bad<S2SV_blank>offset<S2SV_blank>%p\\\\n\" , e ) ; return - EINVAL ; } if ( e -> next_offset < sizeof ( struct arpt_entry ) + sizeof ( struct xt_entry_target ) ) { duprintf ( \"checking:<S2SV_blank>element<S2SV_blank>%p<S2SV_blank>size<S2SV_blank>%u\\\\n\" , e , e -> next_offset ) ; return - EINVAL ; } err = check_entry ( e ) ; if ( err ) return err ; for ( h = 0 ; h < NF_ARP_NUMHOOKS ; h ++ ) { if ( ! ( valid_hooks & ( 1 << h ) ) ) continue ; if ( ( unsigned char * ) e - base == hook_entries [ h ] ) newinfo -> hook_entry [ h ] = hook_entries [ h ] ; if ( ( unsigned char * ) e - base == underflows [ h ] ) { if ( ! check_underflow ( e ) ) { <S2SV_StartBug> pr_err ( \"Underflows<S2SV_blank>must<S2SV_blank>be<S2SV_blank>unconditional<S2SV_blank>and<S2SV_blank>\" <S2SV_EndBug> \"use<S2SV_blank>the<S2SV_blank>STANDARD<S2SV_blank>target<S2SV_blank>with<S2SV_blank>\" \"ACCEPT/DROP\\\\n\" ) ; return - EINVAL ; } newinfo -> underflow [ h ] = underflows [ h ] ; } } e -> counters = ( ( struct xt_counters ) { 0 , 0 } ) ; e -> comefrom = 0 ; return 0 ; }\n","target":"<S2SV_ModStart> ) ) { pr_debug <S2SV_ModEnd> ( \"Underflows<S2SV_blank>must<S2SV_blank>be<S2SV_blank>unconditional<S2SV_blank>and<S2SV_blank>\" \"use<S2SV_blank>the<S2SV_blank>STANDARD<S2SV_blank>target<S2SV_blank>with<S2SV_blank>\"\n","project_and_commit_id":"torvalds@linux/54d83fc74aa9ec72794373cb47432c5f7fb1a309","cve_id":"CVE-2016-3134","original_address":"https://github.com/torvalds/linux/commit/54d83fc74aa9ec72794373cb47432c5f7fb1a309","time":"2016-04-27T17:59Z"},
	{"Unnamed: 0":2745,"cwe_id":"CWE-119","source":"CWE-119 vpx_image_t * vpx_codec_get_frame ( vpx_codec_ctx_t * ctx , vpx_codec_iter_t * iter ) { vpx_image_t * img ; if ( ! ctx || ! iter || ! ctx -> iface || ! ctx -> priv ) img = NULL ; else <S2SV_StartBug> img = ctx -> iface -> dec . get_frame ( ctx -> priv -> alg_priv , iter ) ; <S2SV_EndBug> return img ; }\n","target":"<S2SV_ModStart> . get_frame ( get_alg_priv ( ctx ) <S2SV_ModEnd> , iter )\n","project_and_commit_id":"external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426","cve_id":"CVE-2016-1621","original_address":"https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426","time":"2016-03-12T21:59Z"},
	{"Unnamed: 0":1683,"cwe_id":"CWE-476","source":"CWE-476 static struct o2nm_cluster * to_o2nm_cluster_from_node ( struct o2nm_node * node ) { <S2SV_StartBug> return to_o2nm_cluster ( node -> nd_item . ci_parent -> ci_parent ) ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug>\n","target":"<S2SV_ModStart> node ) { if ( node -> nd_item . ci_parent ) <S2SV_ModStart> ci_parent ) ; else return NULL ;\n","project_and_commit_id":"torvalds@linux/853bc26a7ea39e354b9f8889ae7ad1492ffa28d2","cve_id":"CVE-2017-18216","original_address":"https://github.com/torvalds/linux/commit/853bc26a7ea39e354b9f8889ae7ad1492ffa28d2","time":"2018-03-05T18:29Z"},
	{"Unnamed: 0":4140,"cwe_id":"CWE-264","source":"CWE-264 int __kvm_set_memory_region ( struct kvm * kvm , struct kvm_userspace_memory_region * mem , int user_alloc ) { int r ; gfn_t base_gfn ; unsigned long npages ; unsigned long i ; struct kvm_memory_slot * memslot ; struct kvm_memory_slot old , new ; struct kvm_memslots * slots , * old_memslots ; r = - EINVAL ; if ( mem -> memory_size & ( PAGE_SIZE - 1 ) ) goto out ; if ( mem -> guest_phys_addr & ( PAGE_SIZE - 1 ) ) goto out ; if ( user_alloc && ( ( mem -> userspace_addr & ( PAGE_SIZE - 1 ) ) || ! access_ok ( VERIFY_WRITE , ( void __user * ) ( unsigned long ) mem -> userspace_addr , mem -> memory_size ) ) ) goto out ; if ( mem -> slot >= KVM_MEM_SLOTS_NUM ) goto out ; if ( mem -> guest_phys_addr + mem -> memory_size < mem -> guest_phys_addr ) goto out ; memslot = id_to_memslot ( kvm -> memslots , mem -> slot ) ; base_gfn = mem -> guest_phys_addr >> PAGE_SHIFT ; npages = mem -> memory_size >> PAGE_SHIFT ; r = - EINVAL ; if ( npages > KVM_MEM_MAX_NR_PAGES ) goto out ; if ( ! npages ) mem -> flags &= ~ KVM_MEM_LOG_DIRTY_PAGES ; new = old = * memslot ; new . id = mem -> slot ; new . base_gfn = base_gfn ; new . npages = npages ; new . flags = mem -> flags ; r = - EINVAL ; if ( npages && old . npages && npages != old . npages ) goto out_free ; r = - EEXIST ; for ( i = 0 ; i < KVM_MEMORY_SLOTS ; ++ i ) { struct kvm_memory_slot * s = & kvm -> memslots -> memslots [ i ] ; if ( s == memslot || ! s -> npages ) continue ; if ( ! ( ( base_gfn + npages <= s -> base_gfn ) || ( base_gfn >= s -> base_gfn + s -> npages ) ) ) goto out_free ; } if ( ! ( new . flags & KVM_MEM_LOG_DIRTY_PAGES ) ) new . dirty_bitmap = NULL ; r = - ENOMEM ; # ifndef CONFIG_S390 if ( npages && ! new . rmap ) { new . rmap = vzalloc ( npages * sizeof ( * new . rmap ) ) ; if ( ! new . rmap ) goto out_free ; new . user_alloc = user_alloc ; new . userspace_addr = mem -> userspace_addr ; } if ( ! npages ) goto skip_lpage ; for ( i = 0 ; i < KVM_NR_PAGE_SIZES - 1 ; ++ i ) { unsigned long ugfn ; unsigned long j ; int lpages ; int level = i + 2 ; ( void ) level ; if ( new . lpage_info [ i ] ) continue ; lpages = 1 + ( ( base_gfn + npages - 1 ) >> KVM_HPAGE_GFN_SHIFT ( level ) ) ; lpages -= base_gfn >> KVM_HPAGE_GFN_SHIFT ( level ) ; new . lpage_info [ i ] = vzalloc ( lpages * sizeof ( * new . lpage_info [ i ] ) ) ; if ( ! new . lpage_info [ i ] ) goto out_free ; if ( base_gfn & ( KVM_PAGES_PER_HPAGE ( level ) - 1 ) ) new . lpage_info [ i ] [ 0 ] . write_count = 1 ; if ( ( base_gfn + npages ) & ( KVM_PAGES_PER_HPAGE ( level ) - 1 ) ) new . lpage_info [ i ] [ lpages - 1 ] . write_count = 1 ; ugfn = new . userspace_addr >> PAGE_SHIFT ; if ( ( base_gfn ^ ugfn ) & ( KVM_PAGES_PER_HPAGE ( level ) - 1 ) || ! largepages_enabled ) for ( j = 0 ; j < lpages ; ++ j ) new . lpage_info [ i ] [ j ] . write_count = 1 ; } skip_lpage : if ( ( new . flags & KVM_MEM_LOG_DIRTY_PAGES ) && ! new . dirty_bitmap ) { if ( kvm_create_dirty_bitmap ( & new ) < 0 ) goto out_free ; } # else new . user_alloc = user_alloc ; if ( user_alloc ) new . userspace_addr = mem -> userspace_addr ; # endif if ( ! npages ) { struct kvm_memory_slot * slot ; r = - ENOMEM ; slots = kmemdup ( kvm -> memslots , sizeof ( struct kvm_memslots ) , GFP_KERNEL ) ; if ( ! slots ) goto out_free ; slot = id_to_memslot ( slots , mem -> slot ) ; slot -> flags |= KVM_MEMSLOT_INVALID ; update_memslots ( slots , NULL ) ; old_memslots = kvm -> memslots ; rcu_assign_pointer ( kvm -> memslots , slots ) ; synchronize_srcu_expedited ( & kvm -> srcu ) ; kvm_arch_flush_shadow ( kvm ) ; kfree ( old_memslots ) ; } r = kvm_arch_prepare_memory_region ( kvm , & new , old , mem , user_alloc ) ; if ( r ) goto out_free ; if ( npages ) { r = kvm_iommu_map_pages ( kvm , & new ) ; if ( r ) goto out_free ; <S2SV_StartBug> } <S2SV_EndBug> r = - ENOMEM ; slots = kmemdup ( kvm -> memslots , sizeof ( struct kvm_memslots ) , GFP_KERNEL ) ; if ( ! slots ) goto out_free ; if ( ! npages ) { new . rmap = NULL ; new . dirty_bitmap = NULL ; for ( i = 0 ; i < KVM_NR_PAGE_SIZES - 1 ; ++ i ) new . lpage_info [ i ] = NULL ; } update_memslots ( slots , & new ) ; old_memslots = kvm -> memslots ; rcu_assign_pointer ( kvm -> memslots , slots ) ; synchronize_srcu_expedited ( & kvm -> srcu ) ; kvm_arch_commit_memory_region ( kvm , mem , old , user_alloc ) ; if ( npages && old . base_gfn != mem -> guest_phys_addr >> PAGE_SHIFT ) kvm_arch_flush_shadow ( kvm ) ; kvm_free_physmem_slot ( & old , & new ) ; kfree ( old_memslots ) ; return 0 ; out_free : kvm_free_physmem_slot ( & new , & old ) ; out : return r ; }\n","target":"<S2SV_ModStart> out_free ; } else kvm_iommu_unmap_pages ( kvm , & old ) ;\n","project_and_commit_id":"torvalds@linux/09ca8e1173bcb12e2a449698c9ae3b86a8a10195","cve_id":"CVE-2012-2121","original_address":"https://github.com/torvalds/linux/commit/09ca8e1173bcb12e2a449698c9ae3b86a8a10195","time":"2012-05-17T11:00Z"}
]
